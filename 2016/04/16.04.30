01:19:50 <bitemyapp> puregreen: the parsers chapter is primarily in trifecta.
01:19:56 <bitemyapp> puregreen: so...sure.
01:20:10 <puregreen> oh, cool
01:20:31 <bitemyapp> puregreen: but it doesn't anything super-advanced, it just teaches the basics of using parser combinator libraries, tokenization in terms of trifecta and then a little bit of how to cross-over to attoparsec.
01:21:35 <puregreen> hm, so no explanations for creating those pretty error messages that I couldn't figure out how to work with after spending about 2h reading the docs?
01:22:53 <bitemyapp> I'm not sure what you mean, do you mean the mark/highlight stuff, <?>, or the default behavior?
01:23:02 <suppi> can anyone recommend an easy to use http client lib?
01:23:07 <bitemyapp> suppi: wreq
01:23:24 <bitemyapp> suppi: tho' http-conduit added a module recently...h/o
01:23:33 <bitemyapp> suppi: http://haskelliseasy.readthedocs.io/en/latest/#http-clients
01:23:33 <suppi> bitemyapp, alright... i'll give it another try... thanks
01:24:00 <bitemyapp> suppi: new simple module: https://github.com/snoyberg/http-client/blob/master/http-conduit/Network/HTTP/Simple.hs
01:24:07 <bitemyapp> suppi: so there's two choices
01:24:07 <puregreen> bitemyapp: primarily things in Text.Trifecta.Rendering (carets, spans, fixits)
01:24:14 <suppi> bitemyapp, thanks!
01:25:29 <bitemyapp> suppi: np
01:25:35 <Axman6> bitemyapp: if you've got a tutorial on using trifecta, I*'m buying the book right now =)
01:25:36 <suppi> ok, perhaps my problem is less with the http client lib and more with the analyzing the html i get :)
01:25:45 <bitemyapp> puregreen: we have to assume readers of our book have never parsed anything before
01:25:52 <bitemyapp> puregreen: so the tutorial is quite basic.
01:26:02 <bitemyapp> it's nothing you couldn't do with parsec or megaparsec.
01:26:11 <bitemyapp> Axman6: ^^
01:26:22 <bitemyapp> We don't cover highlight / rendering.
01:27:07 <Axman6> bitemyapp: at LambdaJam yesterday there was a great talk which uses trifecta to build a language parser which was easy to extend using lens. pretty mind blowing stuff
01:27:09 <suppi> bitemyapp, btw, what was the reason you chose trifecta over megaparsec?
01:27:15 <Axman6> bitemyapp: maybe you should =)
01:27:41 <bitemyapp> Axman6: I don't think you understand the audience or how our work works.
01:27:51 <suppi> i think the parsers chapter is long as it is already :P
01:28:00 <bitemyapp> Axman6: we go into pretty extensive detail, no-stones-unturned, exercises-galore for what we cover.
01:28:13 <bitemyapp> Axman6: covering highlighting would've doubled the size of the chapter.
01:28:25 <bitemyapp> Axman6: the book is already so long (nearly 1,200 pages) that we almost couldn't find a printer for the book.
01:28:28 <bitemyapp> So, no.
01:28:33 <bitemyapp> we're not going to in this book.
01:28:37 <Axman6> could be another chapter, somewhat like RWH's project based chapters
01:28:38 <suppi> almost? :P
01:28:41 <bitemyapp> Axman6: no
01:28:44 <bitemyapp> no, no, no.
01:28:48 <Axman6> =)
01:28:50 <bitemyapp> the book is nearly done and it will be done.
01:28:59 <bitemyapp> I don't think you understand what writing a 1,200 page book is like.
01:29:11 <bitemyapp> I am to the point where I will flense the nicer bits of skin off my arms to be done with this.
01:29:46 <suppi> ouch...
01:30:17 <bitemyapp> it doesn't matter that the book is good, it's been stressful and I'm tired of thinking about it. We are both (Julie and I) extremely burnt out and want to do other things now.
01:30:50 <suppi> obviously... it shows you've invested quite a lot in it
01:30:55 <bitemyapp> writing a 1,200 page book in a year and a half is very hard. Especially a technical one guided by user testing. We've processed over a thousand support tickets now, plus private review.
01:31:16 <bitemyapp> this is in addition to my full time day job and my coauthor has two kids to take care of and educate.
01:32:13 <bitemyapp> I know people who've taken 2.5 years to write a 250 page basic introduction to some server technology with three authors.
01:32:26 <bitemyapp> that don't have to assume they're working with people new to programming. We do.
01:32:31 <Axman6> yeah nut you're not a chump like them
01:33:07 <Axman6> not*
01:33:13 <Axman6> uh, but*
01:33:18 <bitemyapp> corrected the wrong word lol
01:33:34 <Axman6> yeah >_< I'm pretty sick at the moment
01:33:40 <bitemyapp> aww, sorry to hear it.
01:34:02 <Axman6> any idea of the rough cost of the printed book?
01:34:26 <bitemyapp> we're not exactly happy with the quotes we've gotten, but it'll be doable.
01:34:50 <bitemyapp> It'll be more than the ebook and anyone in not-US is not likely to be jazzed with the total cost given shipping, VAT, forex.
01:35:35 <bitemyapp> And unlike the ebook, we can't really discount it for extenuating circumstances.
01:38:25 * hackagebot sql-words 0.1.4.0 - Simple idea SQL keywords data constructor into OverloadedString  https://hackage.haskell.org/package/sql-words-0.1.4.0 (KeiHibino)
01:39:06 <bitemyapp> but we'll see what we can do. we don't really have any idea what interest there is overseas.
01:40:05 <Axman6> well, there's one here. but I'm going to buy the preview now anyway
01:40:29 <bitemyapp> Axman6: honored :)
01:40:41 <bitemyapp> Axman6: coauthor and I are working together much of the weekend to get the next release out.
01:40:55 <Axman6> though, as someone who isn't really the target audience, I probably won't end up getting the hard copy. might convince work to do it though
01:42:25 <bitemyapp> Axman6: yeah. Some experienced folk have picked up bits and pieces from it. One was a 10 year user of Haskell, said it filled out some details.
01:42:43 <bitemyapp> Axman6: most check it out so they have a sense of how it compares with the alternatives for when they talk to people wanting to learn.
01:50:36 <Axman6> bitemyapp: yeah that's my main reason for wanting to read it
01:52:43 <Axman6> bitemyapp: $$$
01:52:47 <Axman6> :)
01:53:26 * hackagebot transformers-lift 0.1.0.1 - Ad-hoc type classes for lifting  https://hackage.haskell.org/package/transformers-lift-0.1.0.1 (int_index)
03:25:00 <orion> Does this if block look strange to anyone?: https://github.com/lpeterse/haskell-socket/blob/master/src/System/Socket.hsc#L262
03:25:57 <puregreen> orion: not to me, but perhaps you could use MultiWayIf instead
03:36:27 <kaictl_work> orion: the only thing that looks off to me is the indentation on line 268-273
03:43:09 <Axman6> orion: what do think is weird about it?
03:46:11 <orion> The indentation. It's hard to follow.
03:51:48 <kaictl_work> orion: the lines i mentioned should be indented one level more to line up with the `if` in the `else if` there.
03:53:50 <puregreen> I agree that the indentation is unusual, but at least for me it's obvious how the code is supposed to work and so I can read it just fine without any changes
03:54:21 <puregreen> perhaps it's only obvious to me because I wrote similar code in the past, of course :)
03:56:06 <kaictl_work> i mean the code isn't unclear, but the way it's indented is a bit misleading.
03:59:38 <Axman6> MultiWayIf definitely would make that code clearer
04:28:55 <int-index> I'm trying to define a type-restricted proxy# and this is what I get http://lpaste.net/161983
04:28:58 <int-index> what are my options?
04:38:33 * hackagebot hw-prim 0.0.0.9 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.0.9 (haskellworks)
04:47:38 <r444> int-index: it's kinda awkward solution, but to avoid the restriction you can do foo :: () -> Proxy# Foo; foo _ = proxy#
04:48:01 <int-index> r444, defeats the purpose (I want Proxy# instead of Proxy because it has no runtime rep)
04:48:57 <r444> afaik you can't make an unlifted CAF in haskell
04:49:25 <int-index> I know, but for proxy# it's an unnecessary restriction. Looking for ways to make GHC shut up
04:49:38 <int-index> and do what I say.
04:50:23 <sgronblo> is anyone using snap and stack together and have figured out how to enable the development mode?
04:50:47 <dredozubov_> i guess you have to sprinkle this proxies by hand for now
04:50:52 <dredozubov_> these*
04:51:17 <int-index> yes, the best solution I can think of is a quasi-quoter, so [p|Foo|] expands into (proxy# :: Proxy# Foo)
04:51:31 <int-index> still ugly tho, would prefer just writing foo
05:00:42 <ertes> is there a way to tell GHC that a certain value is never needed at run-time?  like (especially inductive) proofs
05:01:21 <sgronblo> `cabal run` /= `./.cabal-sandbox/mybinary` ?
05:03:34 * hackagebot ddc-base 0.4.2.1 - Disciplined Disciple Compiler common utilities.  https://hackage.haskell.org/package/ddc-base-0.4.2.1 (BenLippmeier)
05:08:34 * hackagebot ddc-core 0.4.2.1 - Disciplined Disciple Compiler core language and type checker.  https://hackage.haskell.org/package/ddc-core-0.4.2.1 (BenLippmeier)
05:08:36 * hackagebot ddc-core-simpl 0.4.2.1 - Disciplined Disciple Compiler code transformations.  https://hackage.haskell.org/package/ddc-core-simpl-0.4.2.1 (BenLippmeier)
05:08:38 * hackagebot ddc-core-salt 0.4.2.1 - Disciplined Disciple Compiler C code generator.  https://hackage.haskell.org/package/ddc-core-salt-0.4.2.1 (BenLippmeier)
05:08:40 * hackagebot ddc-core-llvm 0.4.2.1 - Disciplined Disciple Compiler LLVM code generator.  https://hackage.haskell.org/package/ddc-core-llvm-0.4.2.1 (BenLippmeier)
05:13:34 * hackagebot ddc-core-tetra 0.4.2.1 - Disciplined Disciple Compiler intermediate language.  https://hackage.haskell.org/package/ddc-core-tetra-0.4.2.1 (BenLippmeier)
05:13:36 * hackagebot ddc-core-flow 0.4.2.1 - Disciplined Disciple Compiler data flow compiler.  https://hackage.haskell.org/package/ddc-core-flow-0.4.2.1 (BenLippmeier)
05:13:38 * hackagebot ddc-core-babel 0.4.2.1 - Disciplined Disciple Compiler PHP code generator.  https://hackage.haskell.org/package/ddc-core-babel-0.4.2.1 (BenLippmeier)
05:13:40 * hackagebot rss-conduit 0.2.0.2 - Streaming parser/renderer for the RSS 2.0 standard.  https://hackage.haskell.org/package/rss-conduit-0.2.0.2 (koral)
05:13:42 * hackagebot ddc-source-tetra 0.4.2.1 - Disciplined Disciple Compiler source language.  https://hackage.haskell.org/package/ddc-source-tetra-0.4.2.1 (BenLippmeier)
05:18:44 * hackagebot ddc-build 0.4.2.1 - Disciplined Disciple Compiler build framework.  https://hackage.haskell.org/package/ddc-build-0.4.2.1 (BenLippmeier)
05:18:46 * hackagebot ddc-driver 0.4.2.1 - Disciplined Disciple Compiler top-level driver.  https://hackage.haskell.org/package/ddc-driver-0.4.2.1 (BenLippmeier)
05:18:48 * hackagebot ddc-code 0.4.2.1 - Disciplined Disciple Compiler base libraries.  https://hackage.haskell.org/package/ddc-code-0.4.2.1 (BenLippmeier)
05:18:50 * hackagebot ddc-tools 0.4.2.1 - Disciplined Disciple Compiler command line tools.  https://hackage.haskell.org/package/ddc-tools-0.4.2.1 (BenLippmeier)
05:23:35 * hackagebot conduit-parse 0.1.1.1 - Parsing framework based on conduit.  https://hackage.haskell.org/package/conduit-parse-0.1.1.1 (koral)
05:23:50 <muesli4> Hi, what's the best way to include HUnit into a cabal test suite?
05:24:39 <muesli4> I found https://github.com/pbrisbin/cabal-test-hunit but it is apparently not on hackage.
05:33:35 * hackagebot imm 1.0.0.0 - Execute arbitrary actions for each unread element of RSS/Atom feeds  https://hackage.haskell.org/package/imm-1.0.0.0 (koral)
05:41:01 <maerwald> @hoogle (a -> m b) -> f a -> m b
05:41:05 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
05:41:05 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
05:41:05 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
05:41:28 <maerwald> am I missing this function somewhere? http://lpaste.net/161984
05:53:31 <cocreature> maerwald: if f is also a functor you can do \x y -> asum (fmap x y)
05:55:30 <maerwald> that just looks more obfuscated
05:56:49 <cocreature> fair enough
05:57:04 <lpaste> Cale pasted ‚Äúlol‚Äù at http://lpaste.net/161986
05:58:36 * hackagebot ether 0.4.0.2 - Monad transformers and classes  https://hackage.haskell.org/package/ether-0.4.0.2 (int_index)
05:59:33 <lpaste> Cale revised ‚Äúlol‚Äù: ‚Äúlol‚Äù at http://lpaste.net/161986
05:59:54 <Cale_> (skip's type was less general than it should have been, fixed)
06:01:56 <Cale_> This is... surprisingly practical.
06:08:48 <ertes> Cale_: this is one of those things that you compose "backward", isn't it?
06:09:07 <ertes> like:  push x . hex
06:11:34 <Cale_> ertes: yeah -- it's forwards with respect to the production of the string though
06:11:50 <ertes> Cale_: nice idea, though i'm not sure when i would use it
06:11:51 <Cale_> but the stack manipulation you read left to right
06:12:49 <Cale_> The stack manipulation stuff is all a bit silly
06:12:54 <ertes> Cale_: seems like you lose the ability to share:  push x . push x . hex . hex
06:13:11 <Cale_> push x . dup . hex . hex
06:13:27 <ertes> i mean sharing of the formatted string
06:13:34 <Cale_> oh, sure
06:14:15 <Cale_> Well, we could write apply :: (u -> v) -> Format m (v -> a) (u -> a)
06:14:39 <Cale_> and then  apply (\x -> showHex x "")  and dup the result
06:15:20 <ertes> that could work‚Ä¶  but it kinda ruins the experience =)
06:15:58 <ertes> nice idea anyway‚Ä¶  i think this is the first interesting use case of Cokleisli i've seen
06:16:56 <Cale_> Yeah... there was a talk at the NY Haskell meetup about using polymorphic continuations to do things like printf
06:17:33 <ertes> Cale_: actually you could even get the sharing specifically by *not* using Cokleisli, but the underlying comonad instead
06:18:08 <Cale_> and the speaker, Daniel Patterson, had this operation (%) :: ((String -> b) -> c) -> ((String -> a) -> b) -> ((String -> a) -> c
06:18:34 <Cale_> and I was like "this category has to already have a name"
06:30:53 <ertes> yeah, that type signature almost shouts "comonad!" at you
06:32:35 <ertes> however, i would go without Cokleisli there and use (=>=) directly instead
06:33:16 <ertes> or rather (=<=) in this case
06:33:26 <Cale_> Well, Cokleisli produces a nicer type-level understanding of what's going on I think
06:33:53 <ertes> make it a type alias =)
06:34:30 <Cale_> The objects in the category here basically tell you how the type of your "printf" is changing
06:34:54 <ertes> type Print m a b = (m -> a) -> b
06:36:01 <ertes> btw, this is very similar to what boomerang does
06:36:32 <ertes> it constructs printers and parsers at the same time from a single description in the same stack-manipulation way
06:37:26 <ertes> in fact it looks very "adjoint" to this in nature (working with tuples instead of functions)
06:43:04 <Cale_> oh, I suppose the other thing about using Cokleisli is that the inferred types are fairly readable
06:46:12 <ertes> true
06:49:34 <ertes> i seem to be less sensitive to that, probably because i grew up with iteratees
06:52:46 <Cale_> I've done the stack manipulation CPS stuff before, but the types were completely unreadable
06:53:15 <Cale_> (and that was even with no monoid involved there)
06:55:01 <pkug> what are the recommended code bases to read when learning Haskell ? more of a real world application domain than scientific stuff
06:57:26 <TRENT_reznor> hi all
06:58:17 <TRENT_reznor> is there a way to selectively import an exported module?
06:58:39 * hackagebot pinchot 0.18.0.0 - Write grammars, not parsers  https://hackage.haskell.org/package/pinchot-0.18.0.0 (OmariNorman)
06:59:10 <TRENT_reznor> for example if I have a library that exports module X as module Lib ( moudle X) ... import qualified blah as X
06:59:30 <TRENT_reznor> is there a syntax by which I can selectively import X?
07:00:31 <lyxia> I've never heard of such a feature
07:01:04 <TRENT_reznor> wouldn't that make sense though? i can selectively import other things
07:02:58 <geekosaur> TRENT_reznor, the exporting module exports all names as being from itself; an importing module has no way to know that some subset of names actually came from somewhere else
07:05:15 <TRENT_reznor> geekosaur well given the current compiler implementation, i don't see why the dependency chain couldn't be worked out
07:05:54 <TRENT_reznor> this would be useful to have for like a custom prelude. In almost every file I have import Data.Vector as V, import Data.Text as T
07:05:55 <TRENT_reznor> maybe there's a workaround?
07:06:23 <TRENT_reznor> it would be nice to be able to compress that all into import ExtendedPrelude (V, T)
07:07:00 <geekosaur> no? unless it goes to whole-program compilation, it can't determine which of multiple modules might have provided a given name.
07:07:27 <geekosaur> (thta is, recompiles every library you use from source every time you use it)
07:08:07 <TRENT_reznor> well is there any other workaround to compress common imports ala import ExtendedPrelude (V, T)
07:08:16 <TRENT_reznor> I mean I could just not selectively import
07:08:28 <TRENT_reznor> but then the module names are implicit
07:08:39 <nh2> is there a way for me to use TH in a fashion like this? $([d| data = (FILL_IN_CONSTRUCTORS_FROM_VARIABLE :: [Con]) deriving (Eq, Ord) |])? In other words, I want to quasiquote then entre data declaration except from the constructors, so that I don't have to build the `deriving` clause with TH
07:09:10 <TRENT_reznor> so I would just have V.whatever in my code and I'd have to know a bunch fo module abbreviations were loaded from my ExtendedPrelude library
07:10:02 <Cale_> nh2: TH only has splices for expressions, patterns, types, and lists of declarations
07:10:25 <Cale_> the sequence of cases in a data declaration isn't one of those things, so unfortunately not
07:10:46 <Cale_> however, I believe the deriving clause is just a list...
07:11:58 <Cale_> Yeah, it's that last list of Name values
07:12:29 <nh2> Cale_: yes, it's just a list, that'll do; would still be nicer though if I could do as much as possible in standard Haskell syntax
07:12:32 <nh2> thanks!
07:12:58 <Cale_> Which is kind of interesting, because I think you can have more interesting things in deriving clauses than just names
07:15:06 <geekosaur> urgh. network's playing up early; had to bring up work hotspot :/
07:16:11 <geekosaur> TRENT_reznor, I'm not aware of a workaround, unless the {-# SOURCE #-} pragma on import (hack for mutually recursive modules) has this (side) effect
07:16:58 <TRENT_reznor> geekosaur bummer :(
07:17:00 <geekosaur> but I'm not sure the boilerplate involved there is any better in practice
07:17:15 <TRENT_reznor> guess i'll have to just add comments
07:17:42 <TRENT_reznor> are there better solutions for custom preludes importing common modules? i know there are a couple that have been made
07:18:54 <geekosaur> most of them replace standard Prelude exports wholesale
07:19:34 <geekosaur> I think most people just start from a template that has all the imports they want in it
07:21:16 <TRENT_reznor> yeah i'm not looking to replace the prelude. i just want to cutdown on my preamble biolerplate
07:21:34 <sm> TRENT_reznor: I am finding base-prelude is a nice easy one to start with
07:22:22 <runeks> Is there a simple way (avoiding boilerplate) to apply the same (overloaded) function to all the types contained in this data type? http://lpaste.net/161991
07:22:31 <Cale_> TRENT_reznor: yeah, it's sort of unfortunate... it would be nice if you could re-export modules with the qualifications intact
07:24:14 <TRENT_reznor> Cale_ ooh you can't ? I just started to read http://www.stephendiehl.com/posts/protolude.html
07:24:53 <TRENT_reznor> it looks like that X qualification would be preserved no? (haven't gotten to the end)
07:24:55 * geekosaur now tempted to see if importing with the SOURCE pragma would have that side effect
07:25:02 <Cale_> nope
07:25:28 <TRENT_reznor> :'(
07:26:08 <TRENT_reznor> so if you have say module MyModule ( module X, module Y, module Z )
07:26:14 <Cale_> if you choose to re-export a module by including it in the export list, you can't export it qualified
07:26:17 <TRENT_reznor> where X Y Z are qualified imports
07:26:25 <TRENT_reznor> and then I import MyModule
07:26:30 <Cale_> It just exports everything in X
07:26:31 <TRENT_reznor> I wouldn't reference X functions as X. ?
07:26:38 <TRENT_reznor> oh man that's a bummer
07:26:46 <geekosaur> no, as I said earlier, they're all MyModule.
07:27:40 <TRENT_reznor> waah
07:33:11 <geekosaur> mm, nope, the hs-boot hack is tied to SOURCE
07:38:11 <geekosaur> nope, doesn't work
07:39:30 <geekosaur> not sure whether that hack, if it had worked, would be neat, disgusting, or both >.>
07:52:46 <maerwald> Anyone good with exceptions and Alternative class? I have a case where I convert a "Maybe a" to a value or throw an Exception or somesuch when there is no value. <|> doesn't get triggered when I use throwM and friends, but it does when I just use `fail` or `empty`, which cannot be used in that context though. This all happens in a ReaderT type.
07:54:08 <maerwald> https://hackage.haskell.org/package/mongoDB-2.0.10/docs/src/Database-MongoDB-Query.html#fetch that's the function... because it does throwIO it breaks the use of the Alternative class
07:56:44 <EvanR> easy, just never change code
07:56:48 <EvanR> oops
07:57:00 <sm> woah.. deja vu
07:57:14 <EvanR> couldnt sworn i had got disconnected
07:58:42 * hackagebot relational-query 0.8.2.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.2.0 (KeiHibino)
08:13:37 <chaoxu> Hi guys, want to create a function that print out some string and return a number. What type should it be?
08:14:01 <Rembane> chaoxu: IO Int
08:14:09 <Rembane> chaoxu: Or rather: String -> IO Int
08:15:09 <chaoxu> cool, thanks
08:18:12 <Rembane> chaoxu: No worries, good luck! :)
08:18:29 <chaoxu> for IO monad, does it basically store all outputs inside it and only output to screen when evaluated through "main"?
08:19:00 <maerwald> what?
08:20:24 <maerwald> Evaluation doesn't cause any code execution or anything on your screen. IO is a magic type that is specific to the compiler implementation.
08:20:57 <maerwald> when your IO code hits the runtime system it may or may not do something as all IO actions can fail
08:21:16 <maerwald> so "IO Int" doesn't always return a number...
08:21:56 <maerwald> and nitpickers will now say "it never returns a number" 
08:22:46 <maerwald> maybe read https://www.seas.upenn.edu/~cis194/fall14/spring13/lectures/08-IO.html
08:23:10 <chaoxu> got it
08:26:31 <chaoxu> I want to write something bizzarre: suppose someone give me functions f,g that both logging String using IO and return a Int, I want to get the return of them and compare which number is bigger, and I only want to see the logging of this one on screen. Is it possible?
08:26:44 <chaoxu> I cannot change f,g, it's given by others
08:28:02 <puregreen> chaoxu: technically you can do it by capturing the string and then outputting it by yourself
08:28:03 <puregreen> http://hackage.haskell.org/package/silently-1.2.5/docs/System-IO-Silently.html
08:28:35 <geekosaur> oh, someone packaged the fd-swapping hack?
08:28:48 <chaoxu> puregreen: wow, this is cool
08:29:04 <puregreen> chaoxu: but I wonder what you need it for :)
08:29:20 <puregreen> geekosaur: apparently hspec people needed it
08:29:29 <chaoxu> puregreen: shadowing traffic
08:29:34 <geekosaur> that I can believe
08:29:56 <maerwald> sounds like you want something like: compareBlah :: IO Int -> IO Int -> IO Ordering
08:29:57 <chaoxu> puregreen: I want to be able to run two algorithms for the same traffic and compare result.
08:30:23 <chaoxu> puregreen: only return result of better one, but I also want the logging of the better one to be seen in the end
08:30:27 <tom_cruise> Hi 
08:31:41 <chaoxu> When does IO actually happen? how to you put a order on IO actions given functions can evaluated in mulitple order?
08:32:24 <Rembane> chaoxu: IO can only be evaluated in one order.
08:32:58 <chaoxu> Rembane: because we have to chain IO monad using bind, and that defines the order right?
08:33:01 <maerwald> > compare <$> (return 1 :: IO Int) <*> (return 2 :: IO Int)
08:33:01 <raek> chaoxu: the I/O action in the main variable is the one executed
08:33:02 <lambdabot>  <IO Ordering>
08:33:12 <maerwald> :t compare <$> (return 1 :: IO Int) <*> (return 2 :: IO Int)
08:33:13 <lambdabot> IO Ordering
08:33:13 <Rembane> chaoxu: Exactly!
08:33:27 <monochrom> A runtime system makes IO happen. It also performs IO actions differently from evaluating expressions. So IO actions can obey your order while evaluation doesn't.
08:34:21 <ertes> chaoxu: the easiest option is to look for an API that doesn't insist on dumping the algorithm and its log into the same function
08:34:22 <raek> chaoxu: you can think of the haskell runtime being an interpreter that interpets IO values and executes them. compound IO values (>>=) are executed left to right
08:34:39 <ertes> you want separation of concerns
08:35:12 <chaoxu> ertes: that's right, unfortunately those functions are provided by others
08:35:13 <raek> the IO values are eveluated whenever the runtime needs to look at them
08:35:21 <chaoxu> raek: got it, thanks
08:35:40 <geekosaur> also note that if your f and g are coming from the FFI, capturing their I/O may require even more trickery
08:37:02 <chaoxu> geekosaur: what's FFI?
08:37:25 <geekosaur> fireuign function interface. that is, f and g are calling something written in C and you want to capture the IO done in C
08:37:40 <chaoxu> geekosaur: got it
08:39:29 <jonsesy> silently sounds nice.. it works as advertised?
08:39:51 <jonsesy> ignoring IO done by C functions
08:40:01 <tom_cruise> I wish ghcjs was less klunky. Finally got it working with reflex starter and now I can't get the new reflex starter to build
08:40:47 <geekosaur> I don't know if it does or not. there's at least one edge case I can think of there though, involving unflushed stdio buffers C-side
08:41:21 <tom_cruise> Is it possible to use the c ffi and still use concurrency features in Haskell?
08:41:21 <geekosaur> or unflushed buffers in some other buffering system that your Haskell code can't know about
08:41:43 <chaoxu> In haskell, it's not possible to get crazy out-of-order output like multithreading programming in Python or Java?
08:42:15 <jonsesy> I would expect it to only work if you call haskell's io functions
08:42:22 <ertes> tom_cruise: yeah‚Ä¶  most of the time you will compile with -threaded, but honestly i just do that for every program
08:43:01 <ertes> chaoxu: it's possible:  mapM_ (forkIO . forever . putStrLn) ["thread 1", "thread 2"] >> getLine
08:43:24 <ertes> chaoxu: to make it behave more deterministically, you need a logger thread that you send messages to
08:43:43 <chaoxu> ertes: that's amazing, thanks
08:43:44 <geekosaur> tom_cruise, there are some things you need to watch out for, in particular you have to create threads with forkOS if you're using FFI with functions that have thread local state
08:43:47 <tom_cruise>  Ertes so do you have to somehow declare ffi as pure ? What command does that? 
08:44:47 <raek> chaoxu: but at least you can grep the code for calls to forkIO... (and it's documentation is quite clear about what happens)
08:45:01 <chaoxu> raek: thanks
08:45:08 <ertes> tom_cruise: not an FFI expert, but you have to tell the compiler what (thread-) safety assumptions it can make for which C functions
08:45:32 <tom_cruise> Geekosaur is there a tutorial somewhere? Learning resources on intermediate ffi usage seem sparse 
08:45:38 <jonsesy> ertes why doesn't pressing enter kill that program
08:45:48 <raek> but pure code does not have those kind of problems, due to the lack of side-effetcs
08:45:54 <ertes> jonsesy: good question‚Ä¶  it should
08:46:16 <geekosaur> jonsesy, did you compile it, or run it in ghci?
08:46:19 <ertes> jonsesy: maybe your terminal can't keep up with the rapid output, so it takes a while to register
08:46:26 <jonsesy> I ran it in ghci
08:46:30 <jonsesy> ertes yeah that might be it
08:46:33 <ertes> jonsesy: oh
08:46:39 <ertes> in GHCi the threads keep running
08:46:52 <geekosaur> because I think ghci's happy to let threads run forever concurrently with input, whereas a main program will exit when the main thread does
08:46:58 <jonsesy> ah of course
08:47:50 <geekosaur> tom_cruise, I''m not aware of any offhand
08:48:44 * hackagebot cabal-debian 4.32.3 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.32.3 (DavidFox)
08:48:52 <aweinstock> thread-safety is one of the main differences between unsafePerformIO and unsafeDupablePerformIO, I think
08:50:14 <ertes> :t flip runContT return $ mapM (\msg -> ContT $ bracket (forkIO (forever $ putStrLn msg)) killThread) ["thread 1", "thread 2"] >> liftIO getLine
08:50:15 <geekosaur> no
08:50:15 <lambdabot> Not in scope: ‚ÄòforkIO‚Äô
08:50:16 <lambdabot> Not in scope: ‚ÄòkillThread‚Äô
08:50:22 <ertes> jonsesy: that one should work
08:50:31 <ertes> it does for me in GHCi
08:50:51 <geekosaur> unsafeDupablePerformIO just omits locking the buffer pointers of Handle-s so two threads aren't modifying them at the same time
08:51:04 <geekosaur> since the FFI can't modify the internals of Handles
08:53:09 <bitemyapp> Axman6: wait money is your reason for wanting to check it out?
08:54:15 <jonsesy> i've been away from haskell for a while, stopping just when stack started to appear. is it preferred now over cabal sandboxes?
08:55:16 <ertes> jonsesy: it's an alternative, not a replacement‚Ä¶  it tries its best to give you a full, reliable haskell environment from nothing
08:55:32 <ertes> if sandboxes work for you, there is nothing wrong with using them
08:57:39 <erisco> it partly depends on how hip you want to be
08:59:03 <ertes> it depends on how your deployment process works:  cabal-install is bad at deployment
08:59:32 <jonsesy> one thing that i find annoying with cabal sandboxes is that if i use some huge library, such at gtk2hs, in several unrelated projects (and i do), it has to be recompiled from scratch on each one
08:59:47 <jonsesy> does stack address that in any way?
09:00:02 <geekosaur> yes, it caches compatible builds
09:00:17 <jonsesy> neat
09:00:19 <geekosaur> I think cabal has that coming soon as well
09:00:42 <geekosaur> (there's a nix-like package management thing in development/testing)
09:01:16 <ertes> jonsesy: if you're familiar with nix, stack is basically a haskell-specific mini-nix with a much easier learning curve
09:02:14 <jonsesy> ah I see
09:17:40 <Athas> Nice, GHC compiles pretty quickly and with low memory usage if I disable optimisations.
09:17:56 <Athas> Well, "low".
09:32:01 <jonsesy> is there a stdout FILE * in haskell's ffi?
09:32:30 <jonsesy> stdout is a bit hard to google and get relevant search results
09:33:11 <geekosaur> not sure what you are asking
09:35:08 <jonsesy> I need C's stdout file pointer from stdio.h. Was just wondering if it is already imported in foreign interface or if I should import it myself
09:35:23 <jonsesy> <jonsesy> I need C's stdout file pointer from stdio.h. Was just wondering if it is already imported in foreign interface or if I should import it myself
09:36:27 <maerwald> jonsesy: yes
09:36:36 <maerwald> https://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-IO.html#v:stdOutput
09:36:56 <geekosaur> no, that's a file descriptor
09:37:02 <jonsesy> yeah not FILE *
09:37:04 <geekosaur> stdio handles are not predefined in the FFI
09:37:34 <geekosaur> and depending on platform, may not be trivially importable
09:38:16 <geekosaur> (there is, in particular, no guarantee that it is a linker symbol. old stdio implementations had it as a preprocessor macro)
09:40:53 <Axman6> bitemyapp: no, I bought the book =)
09:41:30 <bitemyapp> Axman6: oh awesome. Love to hear what you think when you've had a chance to dig in a bit
10:14:22 <Big_G> What are the general thoughts on mocking in this channel? I have someone that is a bit overzealous with mocks in the testing framework and I'm trying to convince them you don't need mocks if you write pure functions
10:14:55 <ertes> would i want to write a web application with servant?  seems like i'd have to violate REST a bit to make it work as a full web framework
10:15:29 <vans> hi
10:17:21 <Guest37942> i'm new to haskell and i would like to know how to change an element in a list (for instance let l = [1,2,3,4,5,6] and i want to change the 5 to 0 : [1,2,3,4,0,6]) effectively without rebuilding all the list
10:17:22 <simpson> Big_G: Verified fakes are awesome, when appropriate. Good examples are the various "pure" functions around libraries like lens and conduits.
10:17:45 <simpson> Big_G: Haskell mocks sound like a PITA. What are you mocking, IO?
10:18:11 <simpson> Guest37942: Since Haskell values are generally immutable, you must rebuild the list.
10:18:13 <ertes> Guest37942: you will be "rebuilding" the part of the list before the change, while you can reuse the later part
10:18:20 <Big_G> simpson, What are verified fakes? This is actually a Java codebase at work. I'm just trying to write in as functional a style as the language allows
10:18:54 <ertes> Guest37942: but "rebuilding" is a very misleading term, because it suggests that you should think of lists as a data structure, and that is almost always a bad idea in haskell
10:19:22 <simpson> Big_G: Aha. So, the idea is that you make a working implementation of the interface, but it doesn't have much functionality beyond being simple. For a VFS, an in-memory tree; for an HTTP request, an in-memory HTTP resource; etc.
10:19:44 <simpson> Big_G: The "verified" part of the fake is that the fake has its own unit tests that show that the fake correctly implements the interface.
10:19:48 <Guest37942> ertes ok, so there is no possible to achieve the performance of destructive update ?
10:19:55 <Guest37942> +way
10:20:11 <simpson> Guest37942: There are several ways to do so. Are you working on homework or are you making production things?
10:20:35 <davean> VB
10:20:50 <ertes> Guest37942: that's where the misleading part comes in: a haskell list (which semantically is a linked list) can compile to anything from a fast, tight loop to a horribly inefficient in-memory data structure
10:20:52 <Guest37942> i'm working on a challenge of code, where there is a board with moving pieces, so the board is changing all the time
10:21:12 <ertes> Guest37942: in other words, your question is too vague‚Ä¶  try introducing the context of a certain application
10:21:15 <simpson> Guest37942: Ah. Then you want arrays: http://hackage.haskell.org/package/array
10:21:33 <ertes> (don't recommend the array library‚Ä¶)
10:22:17 <Guest37942> to be more specific, i'm updating an [[Int]] board, making simulation in it by moving integer inside
10:22:23 <simpson> Guest37942: There's two great benefits to Arrays over standard lists: They can be mutated in several different convenient Monads, including IO and STM; and they can do the 2D indexing of the board for you automatically.
10:22:40 <simpson> ertes: (Array is a big step up from lists; what would you prefer that I recommend in the future, and why?)
10:23:02 <cocreature> probably vector
10:23:32 <Guest37942> simpson i'm going to check array, it seems nice
10:23:33 <davean> Guest37942: In both the mutable and immutable cases you have to walk the list. If it's performance your after you should avoid that.
10:23:37 <ertes> Guest37942: that's when lists are inappropriate‚Ä¶  generally you should avoid them as an in-memory data structure‚Ä¶  arrays and maps are suitable for your use case‚Ä¶  in fact, if your board is mostly empty, maps may actually work better, because with arrays you need mutation for them to be efficient
10:23:44 <ertes> simpson: the vector library
10:24:10 <simpson> ertes: Okay. What's vector got that array doesn't? I have never worked with vector before.
10:24:36 <ertes> simpson: a comprehensive, stream-fusing API
10:24:43 <Guest37942> is the vector library suitable for things like board[4][21] = 5 in imperative languages
10:25:07 <simpson> ertes: Okay. I will keep that in mind but I will definitely recommend *against* vector and *for* array in this particular situation.
10:25:52 <ertes> Guest37942: vector gives you mutable and immutable single-dimensional arrays‚Ä¶  for your particular use case i would recommend not using arrays for now, but instead use Data.Map.Strict from the 'containers' library
10:26:44 <simpson> Guest37942: I also agree with ertes that just using standard Maps might be fine. You can map from (Rank, File) to (Color, Piece), or however you've got your board's types structured.
10:26:44 <Guest37942> ertes ok, i'm going to checkk array, vectors and map so
10:26:51 <ertes> Guest37942: it's going to be less efficient than a mutable array, but way more efficient than a list of lists
10:27:13 <ertes> Map is usually a good compromise, especially for beginners
10:27:50 <simpson> Also, the standard StateT construction for interactive games works very well with Maps, especially after one embraces the unholiness of lens.
10:28:15 <ertes> yeah
10:28:22 <simpson> Because then you really can do stuff like: board . at (A, 8) .= (White, Knight)
10:28:26 <ertes> at (3, 4) .= Just somePiece
10:28:57 <simpson> Do you need the Just with modern lens on Maps? I don't remember how `at` works. Or maybe I'm thinking of `ix`.
10:28:59 <simpson> :t at
10:29:00 <lambdabot> (Functor f, At m) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
10:29:02 <simpson> :t ix
10:29:03 <lambdabot> (Applicative f, Ixed m) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
10:29:07 <Guest37942> it's funny how many strange words pop when you crawl the web to get how to do a simple efficient b[x][y] = n in haskell :p
10:29:10 <simpson> Okay, so `at` does have the Maybe built-in.
10:29:25 <simpson> Guest37942: Immutability changes everything.
10:29:34 <simpson> Pardon the pun.
10:29:36 <ertes> simpson: yeah, otherwise it would have to be a traversal/prism
10:29:56 <simpson> ertes: Huh. Maybe there was another operator to do that automatically.
10:30:15 <ertes> Guest37942: well, you can always just write it imperatively, but i assume that's not why you're looking at haskell =)
10:30:52 <Guest37942> simpson: yes i know that haskell might not be the good language for my heavy mutable related work, but still i want to do it in haskell :p
10:30:52 <simpson> Guest37942: It helps to remember that, in all the languages I know, assigning to an array index is *always* a more complex operation under the hood than just mere mutation.
10:31:40 <simpson> Guest37942: Oh, mutability is overrated. Moreover, if you put an MArray into STM, you get something so much better than mutability, *and* it's mutable!
10:31:55 <ertes> Guest37942: i suggest that you just write it with Map and the tools you already know, then slowly start to learn more techniques (StateT, lenses, etc.)
10:32:20 <ertes> Guest37942: one nice thing about haskell is that you can learn most things in isolation
10:33:03 <Guest37942> thank you for your help guys :)
10:33:15 <ertes> Guest37942: personally i would follow a completely different paradigm for a board game, but i may be overloading you with information right now, so just go ahead =)
10:33:44 <Guest37942> ertes, shot, i'll bookmark pointers :p
10:33:58 <ertes> Guest37942: that's the problem‚Ä¶  i don't have any
10:35:14 <simpson> Guest37942: If you want to see some very trashy lens code, one of my 1GAMs uses lens: https://github.com/MostAwesomeDude/1gam/blob/master/Pong.hs
10:35:36 <simpson> But you should definitely read it with a horrified look on your face.
10:36:04 <Guest37942> hoo, huhu
10:36:35 <Guest37942> operator overriding make sourcecode intimidating
10:37:03 <simpson> There's no overrides; all the operators are from other libraries.
10:37:15 <simpson> Haskell lets us fully program the operator space. We can create our own operators at any time.
10:37:36 <Guest37942> ok !
10:38:10 <Guest37942> it's hard to fully anderstand applicative usage
10:38:51 <obadz> if I write a ghci command like ':doc' that takes a module as an argument, is there a way to tell ghci to use module name completion on its argument?
10:38:55 <obadz> like it would for import
10:39:48 <chaoxu> hi guys, when using Data.Vector, I found define function as "fun empty = -1" will capture even non-empty Vector, isn't it weird?
10:40:10 <puregreen> chaoxu: ‚Äúempty‚Äù is interpreted as a variable name here
10:40:23 <puregreen> so it doesn't compare the vector with ‚Äúempty‚Äù
10:40:39 <chaoxu> puregreen: ah, right, how to make sure it compare with "empty"?
10:40:41 <puregreen> this is a common gotcha for beginners
10:41:02 <geekosaur> fun v | v == empty = ...
10:41:15 <puregreen> or ‚Äúfun v | V.null v = ...‚Äù
10:41:22 <geekosaur> probably better, yeh
10:42:17 <chaoxu> thanks
10:42:24 * geekosaur doesn't actually use Vector much, doesn't know its api offhand
10:43:07 <puregreen> this sounded vaguely Yoda-ish
11:04:03 <chaoxu> for sequential algorithm like Fisher-Yates algorithm, is it better to use recursion or monad?
11:04:41 <ertes> chaoxu: try formulating your question without using the word "monad"
11:05:35 <chaoxu> ertes: actually, I guess I have to use recursion to simulate a for loop in Java
11:05:56 <hpc> to answer the question you probably wanted to ask instead, look for a data structure that supports an efficient swap operation, and let the algorithm follow from that
11:05:57 <ertes> if you mean the fisher-yates shuffle, you are going to use a mutable vector
11:06:31 <ertes> or a Seq, but then you don't get much of the speed advantage of fisher-yates
11:06:52 <chaoxu> ertes: isn't mutable vector impure?
11:07:03 <ertes> it's mutable
11:07:35 <simpson> chaoxu: What's "impure" mean?
11:07:40 <ertes> (the "pure"/"impure" classification is not as useful as you might think)
11:08:04 <chaoxu> simpson: I am not totally sure, i guess side-effect means impure
11:08:28 <simpson> chaoxu: Ah. Then no, there's no side effects; the mutability is not really on the side when you're asking for mutability as a primary feature!
11:08:47 <xa0> Trivially, IO/ST things are impure, other things are pure
11:09:01 <ertes> chaoxu: i'd put it like this: you are going to write imperative code, because it is an imperative algorithm
11:09:14 <xa0> (But you could have ST processes in something that is overall pure)
11:09:42 <ertes> chaoxu: in much the same way as, say, the sieve of eratosthenes
11:09:48 <chaoxu> ertes: exactly, how to write this imperative code in Haskell?
11:10:09 <xa0> Imperatively üòÑ
11:10:21 <ertes> chaoxu: first you need a mutable array you want to shuffle
11:10:45 <chaoxu> Yea, but do you need to use some Monad like ST to conform to Haskell principle?
11:10:45 <ertes> chaoxu: using the 'modify' function you can apply a mutable vector transform to an immutable vector
11:10:52 <ertes> yes
11:10:56 <ertes> 'modify' uses ST
11:11:27 <chaoxu> cool, can you point me to some example of writing this kind of imperitive code?
11:11:33 <dredozubov_> :t modify
11:11:34 <lambdabot> MonadState s m => (s -> s) -> m ()
11:12:01 <jle`> wrong modify, heh
11:12:10 <ertes> for the shuffle itself you also need a random number generator
11:12:34 <ertes> chaoxu: the vector-algorithms library has an implementation of that shuffle
11:12:50 <ertes> you could look at its source code‚Ä¶  hopefully it is simple enough
11:12:57 <chaoxu> ertes: cool, thanks
11:13:07 <ertes> wait
11:13:41 <ertes> sorry, it's in mwc-random, not vector-algorithms
11:14:15 <ertes> in its .Distributions module
11:23:50 * hackagebot libravatar 0.3.0.1 - Use Libravatar, the decentralized avatar delivery service  https://hackage.haskell.org/package/libravatar-0.3.0.1 (akrasner)
11:28:20 * paolino_ loves reflex
11:28:27 <paolino_> http://lambdasistemi.net/public/ghcjs/Lambda/
11:29:14 <paolino_> and big hugs to ghcjs obviously
11:31:27 <ann> So as my first time on here(and IRCs in general), is it always this quiet or am I missing something?
11:33:20 <jle`> ann: it goes up and down throughout the day :)  but, if people ask questions, they usually get a fast response/start a vibrant discussion
11:33:34 <jle`> unless nobody knows the answer
11:34:03 <jle`> even though it's quiet (nobody's talking), there are usually a few dozen people watching and waiting for a question/something to talk bout
11:34:26 <ann> Right, that makes sense! thanks :)
11:35:14 <ann> I guess timezones will have an effect..
11:37:44 <jle`> mhm, it's the ebb and flow :)
11:38:22 <jle`> sometimes nobody answers right away, too ... but it's not because people are ignoring you, it's just that nobody online knows how to answer :)
11:39:21 <suppi> can i upload a package to hackage that is both an application and a library and have others use the library?
11:39:31 <ertes> suppi: yeah
11:39:34 <ertes> see pandoc
11:39:42 <suppi> ertes, how do i do that?
11:40:09 <ertes> suppi: if you have a 'library' and 'executable' section in your cabal file, just upload it normally
11:40:22 <suppi> ertes, alright. thanks :)
11:40:36 <suppi> ertes, from the hackage website?
11:40:49 <suppi> ertes, or should i use `stack upload` or something like that?
11:40:50 <ertes> suppi: you can use the website or the 'cabal' tool
11:41:00 <ertes> or 'stack', if it supports uploading
11:42:49 <ertes> suppi: my personal workflow is: ./Setup sdist, then untar the package into a fresh directory and see if it still builds and, if applicable, passes all tests
11:42:56 <ertes> if yes, cabal upload
11:43:14 <ertes> also check that your documentation looks fine
11:43:51 * hackagebot pursuit-client 0.1.0 - A cli client for pursuit  https://hackage.haskell.org/package/pursuit-client-0.1.0 (gilmi)
11:45:32 <suppi> ertes, thanks
11:46:11 <Peaker> is there a good reason for Oleg's configurations paper to use _|_ instead of proxy ot pass type params?
11:46:25 <ertes> Peaker: history
11:46:57 <ertes> IIRC at the time Proxy wasn't a widely known idiom
11:47:04 <Peaker> he writes: "If Haskell had a way to pass a type argument, we would have used it.".  Seems weird that a paper with clever ingenuity misses such a simple trick :)
11:47:31 <suppi> ertes, how do i make the docs show on hackage?
11:47:42 <ertes> suppi: in most cases just be patient
11:47:56 <suppi> ertes, alright. thank you very much :)
11:49:09 <ertes> suppi: this one just got uploaded: https://hackage.haskell.org/package/pursuit-client
11:49:19 <ertes> check the part that says "Status"
11:49:26 <ertes> "Docs pending"
11:49:36 <ertes> when that changes, either you have docs, or you have an error log =)
11:50:05 <suppi> ertes, great. thanks :)
11:51:08 <ertes> suppi: you missed a few things
11:52:13 <ertes> suppi: 1. i recommend adding the README.md to the package (extra-source-files), because then the hackage page actually displays it at the bottom (rendered by pandoc)
11:53:29 <geekosaur> Peaker, consider that I started using Haskell in 2006. at the time Proxy wasn't a thing, and people still talked about "idioms" and idiom brackets as their natural form --- this became Applicative
11:54:05 <ertes> suppi: 2. more a style note: write a more useful 'description'; it should give a quick overview of the package‚Ä¶  you can use haddock syntax for it (except that you use a singleton dot instead of an empty line to separate paragraphs)
11:54:17 <geekosaur> Haskell moves fairly quickly these days, but a lot of things that people think of as "standard" are actually fairly recent in Haskell's history
11:55:11 <ertes> suppi: 3. use at least lower bounds in 'build-depends'‚Ä¶  i normally use the best lower bound i know or the current package version, and the next major version as upper bound
11:55:21 <ertes> like this: vector >= 0.11 && < 1
11:55:53 <Athas> ertes: why an upper bound at all?
11:56:54 <ertes> Athas: by the package versioning policy, breaking changes occur with minor version increments
11:56:56 <dolio> Because that allows it to continue building even if someone releases a newer version that breaks your code.
11:57:21 <ertes> (it's less a policy than just a convention)
11:57:39 <Athas> Isn't that solved better with something like Stack snapshots?
11:57:47 <geekosaur> which is definitely a thing, yesterday someone was in here asking for hackage trustees to adjust some packages' upper bounds against a breaking change they'd just released
11:57:51 <Athas> Also, I guess the biggest problem is putting an upper bound on base.
11:58:40 <ertes> Athas: when the build is going to fail, you probably don't want to wait for a confusing compiler error‚Ä¶  you want the solver to tell you that there is no compatible package version around
11:58:49 <ertes> so snapshots don't solve this
11:59:41 <puregreen> geekosaur: that someone was me (but luckily the maintainers of affected packages were very responsive and fixed everything on their own)
12:00:05 <Athas> ertes: in my seven years of Haskell experience, I must admit that I've been more annoyed by upper bounds than by breaking changes.
12:00:13 * geekosaur didn't want to point fingers
12:00:14 <Athas> Particularly upper bounds on base when new versions of GHC are released.
12:00:58 <geekosaur> Athas, yes, that flamewar breaks out regularly, life should be easier for the devs at the expense of end users getting inscrutible errors that often they are in the worst position to understand
12:01:47 <Athas> geekosaur: okay, then it's not worth rehashing, what's the difference between an end user and a developer, if both these classes are building Haskell programs?
12:01:53 <Athas> That just sounds like a programmer to me.
12:01:55 <ertes> Athas: and if we wouldn't have upper bounds, you might as well be annoyed by breaking changes and wishing for upper bounds right now‚Ä¶  we don't know what the best solution is =)
12:02:15 <geekosaur> Athas, is someone building pandoc to convert documentation a developer?
12:02:16 <ertes> Athas: and that is precisely why i set the next major version as the upper bound rather than the next minor
12:02:39 <geekosaur> Is someone who's building git-annex to help manage large binary files in a non_haskell repo a "developer" for the purposes of this?
12:02:48 <ertes> my experience is that breaking changes between minor versions are often not breaking enough to break my packages
12:02:59 <geekosaur> we do have a feew things that are not libraries for other Haskell devs
12:03:16 <Athas> geekosaur: well, I'd say they should be using a prebuilt Pandoc, or a proper source release, but the latter doesn't have any nice tooling I think.
12:03:36 <geekosaur> pandoc only started getting packaged a year ago
12:03:39 <monochrom> a developer of project X does not have time to trouble-shoot library Y, even when X uses Y
12:03:45 <geekosaur> git-anne still isn't widely packaged
12:03:53 <Athas> A source release would either include all dependencies, or frozen dependency version numbers.
12:04:52 <geekosaur> and, unfortunately, haskell devs' idea of releases involve hackage and/or stackage, not the kind of self-contained or at least self-managed release common in (say) the C world
12:05:00 <dolio> Snapshots actually introduce new problems for anything not in the list of specially managed packages.
12:05:36 <dolio> Because something outside the special set may not build with the only version of a library allowed by the snapshot.
12:06:20 <Athas> Actually, I've been thinking of a related issue.  I'd really like to make a binary release of my Haskell program.  Do any tooling scripts or the like exist?
12:06:38 <Athas> For now, just a normal ./configure && make-tarball (but with prebuilt binaries, like the GHC bindist).
12:06:42 <ertes> i think the current scheme is fine‚Ä¶  it does require maintenance from time to time, but that's a necessary evil to provide something programmers sometimes forget about: UX
12:07:03 <sm> Athas: there are tools for building windows and mac installers
12:07:06 <geekosaur> I don't think so. about the only Haskell projects that use anything like that are cabal and stack
12:07:19 <geekosaur> and afaik they're both hand-rolled, since nobody else is doing it
12:07:41 <Athas> sm: but those are exactly the platforms I don't care about! :-)
12:07:51 <Peaker> It's nice to know I contributed something relevant to that paper (they use StablePtrs extensively, and I've improved their speed by ~3x in micro-benchmarks :-) )
12:07:54 <geekosaur> (and, conveniently, they can each use bootstrap versions of themselves to provide the skeleton)
12:08:05 <sm> what are you wanting, that you don't have ?
12:08:26 <ertes> Athas: binary releases can be problematic, unless you target specific distributions, at which point you could just as well make actual distribution packages
12:08:31 <ertes> and that's hard work
12:08:51 * hackagebot category-printf 0.1.0.0 - Highbrow approach to type-safe printf format specifications.  https://hackage.haskell.org/package/category-printf-0.1.0.0 (CaleGibbard)
12:09:55 <Athas> ertes: it doesn't look like my program is dynamically linked to anything funky.  The funkiest part is libgmp.
12:10:25 <sm> Athas: you can offer binaries for common *ix platforms which have the right lib version, beyond that you should probably work with packagers
12:10:45 <thoughtpolice> Yes, there's nothing much for pre-canned stuff on Linux because practically speaking, you either make distro packages or just have one-off tooling to repackage it in a .tar.gz and tell people to put it somewhere. If you don't need many FFI libraries you can probably get by, though (e.g. the libgmp dependency is fairly stable in practice)
12:11:01 <Athas> Yeah, sure, I'm okay with just working on the most common ones.
12:11:09 <geekosaur> note that there *are* tools to generate various distributions' packaging from cabal files
12:11:10 <ertes> Athas: and that's where?  /usr/lib/libgmp.so?  /lib/libgmp.so?  /nix/store/b7i1...zy7i-gmp-6.1.0/lib/libgmp.so?  /usr/local/lib/libgmp.so?
12:11:21 <geekosaur> maintained by the haskell folks involved with those distros
12:11:57 <ertes> Athas: i'm 99% certain that your first binary package won't run on my system without binary patching or an LD_* hack =)
12:12:02 <thoughtpolice> (FWIW, GHC tends to settle for a common, stable Debian distribution for the bread-and-butter Linux packages, but we do need other builds for say, CentOS machines)
12:12:20 <thoughtpolice> ertes: NixOS is a bit of a cheat if you're using that argument though, because neither will anything else.
12:12:27 <Athas> ertes: I only care about Debian and RHEL and RHEL-alikes, to be honest.
12:12:37 <Athas> After that, I should worry about Windows and OS X first.
12:12:39 <Cale_> http://hackage.haskell.org/package/category-printf-0.1.0.0/docs/Control-Category-Printf.html
12:12:46 <Cale_> :D
12:12:53 <thoughtpolice> Athas: For Windows, I can highly recommend hooking into the nsis package.
12:12:53 <ertes> Cale_: just saw =)
12:13:33 <ertes> thoughtpolice: i know‚Ä¶  i use that to remind people that they are already making assumptions when they think about paths and dependencies
12:13:36 <thoughtpolice> I have a Shake build system building quite a lot of code on Windows, that integrates with NSIS quite nicely.
12:14:41 <thoughtpolice> ertes: Right, I'm just saying NixOS is so utterly atypical it's basically a foregone conclusion that it will have to be repackaged to work. For others it's not so cut and dried; you can get away with one build targeting every common Ubuntu and Debian distro today, for example.
12:14:42 <geekosaur> so basically look at a Haskell package for the distribution you're targeting and contact the maintainer address in the metadata. they can point you to the tooling they use
12:14:55 <sm> suppi: http://hackage.haskell.org/package/iridium may be helpful
12:14:59 <geekosaur> I think in most cases it's not on Hackage but in the distribution's own source development repo(s)
12:15:40 <thoughtpolice> It's also not like repackaging a Haskell binary for NixOS with patchelf or whatever is substantially different than any other arbitrary application. It just goes without saying on Nix you have to do something extra.
12:16:02 <geekosaur> (mostly because it's rarely in Haskell; Debian's is likely to be in perl and RHEL/Centos's in python, for example)
12:16:16 <Athas> Well, all this makes it sound like some tooling script would be useful!
12:16:31 <ertes> or a self-contained executable
12:16:57 <Athas> For that matter, the package could ship object files and do the final linking on the user's machine.
12:17:03 <Athas> I don't know whether GHC would support that workflow.
12:17:35 <thoughtpolice> It won't, so I wouldn't suggest it (you'd have to ship the object files of every Haskell library you depend on, which isn't easily supported).
12:17:46 <ertes> Athas: well, if you still need GHC, it sounds like you don't gain much from a binary package
12:18:09 <Athas> ertes: why would you need GHC for the final linking?
12:18:14 <Athas> It's done with ld(1) or whatever.
12:18:20 <geekosaur> well, there's always the way ancient unixes supported kernel relinking
12:18:24 <Athas> You can distribute the GHC runtime as well.
12:18:27 <sm> there is also a magical commercial tool that makes run-anywhere *ix binaries
12:18:54 <geekosaur> manually link a huge .o (with -r) with everything but the parts the end user is to upply and provide a script that does that last part
12:18:57 <thoughtpolice> Replicating the magical incantation GHC might use to construct the final link may not be obvious depending on the platform (GHC for example might need to pass different options depending on the compiler)
12:19:02 <geekosaur> it's rather unmaintainable though
12:19:30 <thoughtpolice> Shipping object files is really just asking for huge amounts of pain and essentially no upsides, especially if binaries are just a convenience over building the source.
12:19:30 <geekosaur> ..in large part because of that (it worked for kernels because the vendor of course knew their toolchain)
12:19:49 <ertes> Athas: would be interesting to see in action, but i think this will be a headache‚Ä¶  however, you can probably create an single object file somehow and then link it with all the non-haskell stuff
12:19:53 <ertes> not sure how to do it though
12:20:16 <geekosaur> capture ghc' link line with -v
12:20:29 <geekosaur> add the -r option at the start and omit the user-provided objects
12:20:30 <thoughtpolice> (And to be clear, GHC never invokes ld directly, it always invokes it through the desired C compiler, as if it were a linker. Hence, needing to know things about how to possibly construct arguments, or what might be supported, etc)
12:20:34 <Athas> ertes: it is definitely more than I room for in my PhD time budget!  I think I will just build a bunch of binaries on whatever Debian and RHEL systems I can find.
12:20:55 <geekosaur> may need to force loading of any .a-s that will be used by the user-provided stuff but not by the vendor-provided code
12:21:02 <geekosaur> this *is* strongly platform dependent
12:21:25 <geekosaur> yes, but ghc -v invokes gcc -v in my experience so you end up seeing it
12:22:54 <geekosaur> you might be able to use gcc with -Wl,-r but gcc wil llikely not be happy with the result; it also is not designed for this use case
12:23:09 <geekosaur> which is why it's such a nonportable hassle
12:24:00 <geekosaur> basically if you can come up with any other way to solve your problem, do so; this is a last resort
12:24:05 <Cale_> *Main> printfLn (dup . s . " plus " . swap . dup . s . " is " . apply2 (+) . s) 5 7
12:24:05 <Cale_> 5 plus 7 is 12
12:24:24 <ertes> to be honest if i'd have to make a binary package, i'd just make a self-contained one
12:24:30 * sm finds it: http://www.magicermine.com (or the free http://statifier.sourceforge.net). But http://phusion.github.io/holy-build-box/ looks interesting
12:25:16 <ertes> because making smaller, more sensible packages is the job of the individual distribution package maintainers
12:35:29 <nitrix> Quick question; my game uses message passing for objects to communicate with each others. It's multiplayer, the state is synced when someone joins and the server is authoritative for everything.
12:35:49 <hpc> have you tried turning it off and on again? ;)
12:36:03 <nitrix> hpc: Me?
12:36:26 <simpson> nitrix: What's the question?
12:36:55 <nitrix> simpson: Thanks for the offer. I'll figure out on my own.
12:37:07 <nitrix> This channel can be so disapointing at times.
12:37:29 <hpc> ?
12:37:31 <s_aly> hpc: IT Crowd xD
12:37:35 <MarcelineVQ> you didn't actually ask a question with your quick question
12:37:37 <simpson> nitrix: Well, yes, this channel's not a great channel, but I'd still like to know your question.
12:37:59 <ertes> nitrix: i think the comment is not representative, and i'm also interested in your question =)
12:38:28 <hpc> i am confused how a joke makes this channel disappointing
12:38:51 <s_aly> That's a nice way to get everyone's attention to ask a question by not asking a question if that makes any sense.
12:38:52 <ertes> hpc: a bad day, a misunderstanding, ‚Ä¶
12:39:09 <nitrix> s_aly: Questions sometimes need context.
12:39:25 <simpson> They also need inquiries.
12:39:53 <ertes> btw, compared to other channels of this size i've seen, this one is actually pretty great
12:39:59 <s_aly> ^
12:43:26 <simpson> nitrix: So, did you have a question? You said all the things that I like, like "message passing" and "objects" and "communicate".
12:43:49 <ertes> and all the things i like, like "game"
12:44:37 <nitrix> simpson: ertes: How would I maintain the state once it's synced? Since the message passing is deterministic in my case, I'm assuming I only need to broadcast any inputs that triggers a chain of reaction in the system (timers and player interractions)? I accidently headed off to a design with Objects with ObjectIds and I think it's unecessary.
12:45:15 <ertes> nitrix: how is your overall application designed?  or are you currently in the designing phase?
12:46:12 <nitrix> ertes: There's a lot written already, but I don't like many parts and been reworking them continually for a few weeks now.
12:46:15 <simpson> nitrix: There's two approaches. You could either ensure that every state is applied (using some sort of consensus algorithm), or you could have each state update contain redundant information to make dropped packets acceptable, which is famously discussed in Quake 2's design.
12:46:42 <ertes> nitrix: are you doing what i call 'predictive presentation'?  i.e. do you render the assumed future state without acknowledgement from the other peer(s)?
12:47:11 <simpson> nitrix: Neither of these are especially great. Many people shrug, delegate it to TCP, and insist that you get a better pipe if you want less lag.
12:47:34 <nitrix> The state isn't the thing that worries me. I'm curious about how, if I do end up using some form of "indirection mechanism/pointer" for other things (machinery, life support, whatever), things that are shared by different aspect of the game, how do people do this?
12:47:55 <nitrix> IDs work, but they feel like a manual indirection system.
12:48:10 <nitrix> With O(log n) lookups :/ C pointers are O(1).
12:48:13 <ertes> nitrix: you mean collections of objects?
12:48:32 <simpson> Let objects refer to other objects directly. Then, pass a message to the top-level object and let it update the other objects by passing more messages within the system.
12:48:40 <nitrix> ertes: I'm thinking any two things that are sharing something in common.
12:48:41 <simpson> IOW write in Smalltalk instead of Haskell~
12:49:01 <ertes> nitrix: i like to un-fix the types, if possible
12:49:25 <ertes> let O and P be object types, and they can refer to each other
12:50:05 <ertes> the fixed types would look like this:  data O = O Int P; data P = P String [O] P
12:50:39 <ertes> the "un-fixed" types would look like this:  data O p = O Int p; data P o p = P String [o] p
12:51:08 <ertes> now you can apply any collection structure you want like an IntMap:  O Int, P Int Int
12:51:23 <watChmeFly> Hey guys
12:51:24 <ertes> does that make sense?
12:51:32 <nitrix> ertes: That much I understand, let me give you a more concrete exemple.
12:51:37 <watChmeFly> Is anyone here familiar with Scala?  I'm in their channel but nobody is active
12:52:53 <nitrix> ertes: Let's say the world of the game is 2D, tile-based. And for the sake of example, any guild can claim ownership over a tile aand make it their territory.
12:53:53 * hackagebot propellor 3.0.2 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.0.2 (JoeyHess)
12:54:24 <nitrix> ertes: One way would be to have a data structure for the tiles, in which, you have some guildID that you can lookup to have information about the guild. Because, you know, the world and the guilds, can change arbitrarily so you want to create a separation of the two, yet, not have duplicates of your guild info everywhere to update.
12:55:11 <ertes> nitrix: if there is any guild "key", i would just use an appropriate data structure
12:55:41 <ertes> if it's Int, i'd use IntMap, especially when the online guilds can change a lot
12:55:50 <nitrix> ertes: Another approach, is to have another data structure of some mapping from guilds "key" to the tiles they own, but you can't just store a copy of the tile either, so you need again, a tileID....
12:56:14 <ertes> nitrix: you need sets with indices, i think
12:56:16 <ertes> like ixset
12:56:31 <ertes> basically you have relational data
12:57:17 <nitrix> ertes: One way or another, you have this indirection system to allow the two sets of elements to be arbitrarily related without duplicating the elements.
12:58:53 <nitrix> I understand Haskell doesn't _duplicate_ values; but conceptually, you'd have to update all of them, thus the ID idea.
12:59:13 <nitrix> But I don't like it and the time complexity is poor.
12:59:28 <nitrix> ertes: What's different with ixset?
12:59:41 <ertes> nitrix: ixset basically gives you in-memory relational tables
12:59:53 <ertes> so you would take the normalised database approach
13:00:23 <nitrix> Did I explain the problem correctly, btw?
13:00:32 <hpc> ixset does have some disadvantages though
13:00:34 <ertes> good question =)
13:00:42 <hpc> it uses instance resolution to figure out which index to perform the lookup with
13:01:02 <ertes> nitrix: it's about duplicate values that should be semantically linked
13:01:09 <nitrix> Mhm.
13:01:30 <ertes> let's say guild 5 has taken tile 20
13:01:45 <nitrix> I want A to be linked with B, and be able to change A or B at will, without the relation to disapear.
13:01:49 <ertes> and only tile 20
13:01:55 <nitrix> Similarly, many A to B, or many B to A, if possible.
13:02:19 <ertes> when we talk about "guild 5's only tile" and "tile 20", we should be talking about identical things
13:02:24 <ertes> that's what you mean, right?
13:02:28 <nitrix> I know that's borderline asking to break purity, but there are use cases.
13:02:31 <ertes> not just equal, but identical
13:02:41 <nitrix> *referential transparency I should say.
13:03:20 <ertes> now the way you represent those highly depends on the way you have structured your overall application
13:03:36 <ertes> for example if you're using FRP, you will probably take a very different approach
13:03:55 <ertes> if you're using a state monad, again, different approach
13:04:02 <nitrix> I'll figure the complications due to framework on my own.
13:05:04 <nitrix> It's the basis that blocks me. Here's another example; tiles belonging to some roomID that has their collective information about heat, pressure, air composition, etc.
13:05:59 <nitrix> Not the best example because those are probably always close together so you could devise some system to partition the space, but it's not what I'm after.
13:06:11 <nitrix> I'm just thinking data relation.
13:07:51 <maerwald> hmm, IO has an Alternative instance? where is that defined?
13:09:29 <nitrix> maerwald: alternative-io package.
13:10:03 <nitrix> maerwald: As the description says though, the side effects prevents roll-backs, so it breaks Alternative laws.
13:10:16 <maerwald> yeah, exceptions break it
13:10:39 <nitrix> Exceptions shouldn't, I think.
13:10:52 <maerwald> ofc they do
13:11:44 <nitrix> Maybe catch and rethrow AltIOgoNext... it's not pretty at all.
13:12:34 <nitrix> maerwald: What about using ErrorT on IO instead?
13:12:50 <maerwald> can't
13:13:37 <ertesx> nitrix: the most generic way is to use normalised relations (as in relational algebra), and we have packages for that like ixset‚Ä¶  it's a catch-all approach with O(log n) operations for most important things
13:13:44 <nitrix> ertes: IxSet is promising. Thanks for the suggestion.
13:13:51 <nitrix> ertesx: Any other packages to look at?
13:14:05 <ertesx> nitrix: there is 'tables', but it has been deprecated
13:14:48 <ertesx> there are also some variants of ixset that work without the boolean blindness (it uses Typeable to reify types in queries)
13:14:57 <nitrix> ertesx: I might implement a IxMap.
13:14:57 <ertesx> but i think ixset is the only well maintained package
13:15:06 <ertesx> why IxMap?
13:15:49 <ertesx> when you would have Map X Y, with ixset you would rather have IxSet (X, Y) and declare X as an index
13:15:56 <nitrix> I think I want a key-value relation, yet a way to query an index to access some of the pairs :/
13:16:14 <nitrix> Right.
13:16:34 <ertesx> (you would use a custom product type, not (,))
13:16:40 <nitrix> It's just the key and the value are fairly complicated records, maybe a few lenses to implement the Indexable instance will do
13:17:08 <nitrix> ertesx: I'll prototype something and see :)
13:17:22 <nitrix> Can't be worse than where I was headed to.
13:17:39 <nitrix> Game development in Haskell can get really hairy it seems.
13:18:00 <simpson> Just as hairy as in any other language.
13:18:26 <yyyyy> if it's the logic part and not engine-level programming i would assume it would be less hairy
13:18:27 <ertesx> nitrix: well, we don't get to just use the pointers and manual memory management, as you would probably do in C++
13:18:32 <nitrix> Higher upfront cost on design I guess. The rest should be smooth sailing after that.
13:18:33 <mniip> other languages have facilities to hide the hairy stuff behind the hood
13:19:20 <nitrix> yyyyy: Yeah; I'm doing the engine as well, so I guess it's two-in-one, project.
13:19:23 <yyyyy> plus, you can always do FFI
13:19:46 <nitrix> yyyyy: Last resort :P
13:19:56 <ertesx> nitrix: btw, in most cases IntMap will suffice, and there is also nothing wrong with using IxSet only where appropriate and using regular maps everywhere else
13:19:57 <maerwald> nitrix: this is weird... (throwIO $ userError "blah") <|> (print 3) -- this works when Control.Monad.Catch is imported
13:19:58 <yyyyy> nitrix: maybe you can extract the logic outside and interact through message passing
13:20:42 <yyyyy> serialise a DSL of actions to the engine, perhaps? and build a higher-level DSL by using haskell to compile down to the DSL
13:20:51 <ertesx> nitrix: well, one thing you can do of course: you can use Ptrs =)
13:22:18 <ertesx> but then your whole API will be IO-based
13:22:53 <simpson> Well, the actions of objects are generally going to inhabit some Monad.
13:23:10 <ertesx> simpson: not necessarily
13:23:13 <nitrix> simpson: Surprisingly not mine
13:23:20 <nitrix> simpson: Due to message passing.
13:23:29 <simpson> nitrix: How do you model refused messages?
13:23:37 <nitrix> I don't :)
13:23:57 <simpson> Ah, so you have some sort of proof that messages can't be refused? Or you have partiality?
13:24:00 <ertesx> simpson: for example when you use FRP, your whole game will be expressed in terms of pure events and behaviours
13:24:05 <nitrix> They're just ignored, but I guess they could be returned as well, it's not a problem.
13:24:15 <simpson> ertesx: I did mean "objects", though.
13:24:35 <ertesx> i'm not sure what an "object" is
13:24:35 <simpson> For example, the kinds of things that the objective package enables: http://hackage.haskell.org/package/objective
13:24:47 <nitrix> simpson: , objMsg    :: Message -> ([Message], Object)
13:25:07 <nitrix> Yes, this could be nicer (State)
13:25:19 <simpson> nitrix: Ah, so zero returned messages corresponds to message refusal?
13:25:31 <nitrix> simpson: What do you mean, refused?
13:25:55 <simpson> nitrix: For example, in Smalltalk and all of its kids, messages are sometimes not handled by their recipients, causing exceptions or panics or whatnot.
13:26:08 <nitrix> simpson: It takes one message, and returns a new object with inner state modified, along possible new messages to reply.
13:26:23 <simpson> ertesx: An object is a bundle of state and behavior, characterized by encapsulation and a totally uniform calling convention, usually called a "message-passing convention".
13:26:27 <nitrix> simpson: It's perfectly fine for me.
13:26:42 <nitrix> simpson: If someone steps on a tile, it might get messaged about it, but it can choose to do nothing.
13:26:43 <ertesx> simpson: i see‚Ä¶  sounds like automata
13:26:44 <simpson> nitrix: Ah, so unrecognized messages fail silently.
13:26:52 <ertesx> as in automaton categories
13:27:01 <nitrix> simpson: Well the thing is, they aren't necessarily failures.
13:27:03 <simpson> ertesx: Yeah, check out http://hackage.haskell.org/package/objective-1.1.1/docs/Control-Object-Object.html
13:27:17 <nitrix> The tile's behavior determines if it's something that affects it.
13:27:19 <simpson> nitrix: Sure. I'm just comparing and contrasting with other message-passing object systems.
13:27:29 <nitrix> A wall of brick wont catch on fire for example.
13:27:38 <nitrix> It still knows about it, but wont react.
13:27:51 <simpson> Sure, sure. Sounds hard to reason about, though.
13:27:51 <ertesx> i wonder why Object is not a Category (possible since base 4.7 or 4.8, not sure)
13:28:08 <simpson> ertesx: fumieval probably just didn't add the instance.
13:28:34 <nitrix> simpson: More or less. Each object can compose various message handlers, which essentially gives you "components".
13:28:58 <simpson> nitrix: Sure. Object composition is vital.
13:29:40 <nitrix> The only thing that's interesting is this:
13:29:44 <nitrix> objMsg :: Message -> ([Message], Object)
13:29:51 <nitrix> objMsg :: Object -> Message -> ([Message], Object)
13:30:12 <nitrix> You'd expect the object's objMsg function to take the said Object as a parameter, but it doesn't.
13:30:28 <simpson> Is that due to a typeclass? Is this a method?
13:30:37 <nitrix> simpson: https://github.com/nitrix/lspace/blob/master/src/Types/Object.hs
13:30:44 <nitrix> simpson: It isn't, it's a simple data type.
13:31:00 <simpson> Ah, I see. The Self convention.
13:31:06 <nitrix> And yet, it's stateful and even, in its own module, functions are implemented in terms of the type itself, e.g. a Door, Book, etc.
13:31:14 <nitrix> Even though from the outside, they're all Objects.
13:31:17 <simpson> Sure, sure.
13:31:29 <nitrix> simpson: https://github.com/nitrix/lspace/blob/master/src/Object/Player.hs
13:31:46 <simpson> Masque's call signature for Monte looks like: call :: Obj -> Message -> Maybe Obj
13:32:03 <nitrix> Oh yeah, if it needs to destroy itself.
13:32:15 <simpson> Oh, Nothing indicates that evaluation errored.
13:32:23 <nitrix> Ah I see.
13:32:34 <nitrix> How's that called? Self convention?
13:32:37 <ertesx> all of this looks a lot like AFRP in disguise
13:32:43 <nitrix> It really is.
13:32:51 <simpson> We actually use a big transformer stack, but the stack only stores error information and some evaluation context.
13:33:00 <simpson> ertesx: Well, AFRP that isn't type-safe.
13:33:10 <nitrix> I just can't wrap my mind around FRP and their obsession over time, so I rolled my own solution that's time-agnostic.
13:33:26 <simpson> ertesx: Since objects have a totally uniform calling convention, you can't know whether an object *actually* will respond to a message in 100% of cases until runtime.
13:33:42 <hiptobecubic> isn't the whole point to have "signals varying over time" or something?
13:34:14 <nitrix> simpson: ertesx:To be honest, I think it's an okay tradeoff.
13:34:48 <simpson> nitrix: Sure. It's just very strange, because it reminds me more of PHP than of serious object-based languages.
13:35:19 <nitrix> simpson: Everything else is super sane, it's just the message passing :/
13:35:37 <ertesx> nitrix: if you start to generalise this, you'll end up with the underlying type of AFRP
13:36:05 <ertesx> if you exclude the continuous time aspect and the discrete event aspect, then AFRP is really just communicating components
13:36:26 <simpson> ertesx: How do you feel about the objective constructor, newtype Object f g = Object { runObject :: forall x. f x -> g (x, Object f g) }
13:36:29 <nitrix> I might move the thing to netwire once I grasp it better.
13:36:30 <maerwald> wow, this is weird... "(throwM $ userError "blah") <|> (print 3)" works, while "(throwM $ MyOwnException  "blah") <|> (print 3)" does not
13:36:47 <maerwald> seems userError does something differently that's not represented in the type?
13:37:09 <ertesx> simpson: it's basically yampa's SF or netwire's Wire, except without time and (in netwire's case) without inhibition
13:37:17 <nitrix> Right.
13:37:28 <ertesx> SF and Wire are arrows though, which this one isn't
13:37:42 <ertesx> nitrix: don't use netwire
13:38:10 <nitrix> ertesx: simpson I think the two files are enough to show what I'm doing. I thought it was clever.
13:38:21 <nitrix> I have a lot more to learn about Haskell, it's the best I could do at that time :/
13:38:37 <simpson> nitrix: I think that I understand. The "Self convention" refers to the way that the classic object-based language Self structured its objects.
13:38:49 <simpson> nitrix: Which eventually evolved into Python taking a `self` argument on every method.
13:39:01 <ertesx> nitrix: if you're going for AFRP, i currently recommend yampa‚Ä¶  netwire will be replaced by a more sensible abstraction in the coming weeks/months
13:39:51 <nitrix> Mkay.
13:40:19 <ertesx> you can also use "first-class" FRP‚Ä¶  reactive-banana and reflex are very good libraries, and personally i prefer the latter
13:40:34 <nitrix> simpson: playerObject :: Object -> Player -> Object
13:41:05 <pixelzerg> hello
13:41:06 <nitrix> simpson: It's trapping the Player argument. All functions in the record work on that player:   , objSprite = playerSprite p
13:41:37 <nitrix> simpson: Then when it gets messaged and has to return a new Object, that new object is build from that player too.
13:42:07 <ertesx> nitrix: what is the [Message]?  response messages?
13:42:42 <nitrix> simpson: Thus yeah, the player is trapped. From the outside world, it's an Object you can message and produces a new object, and from inside the module, you get to use a Player type statefully, not some overly general Object that has thousands of fields to accomodate everything.
13:42:47 <nitrix> ertesx: Yeah.
13:42:54 <maerwald> nitrix: if you have an idea https://github.com/mongodb-haskell/mongodb/issues/45#issuecomment-215993574
13:43:41 <nitrix> ertesx: It's naive currently, objects reply to their senders only. You can't arbitrarily message one object directly either.
13:44:32 <nitrix> ertesx: They're an abstraction layer on top of it for coordoning what the messages do. Some of them are very complicated, like, when two ships dock togheter, parts of the world (which is a bunch of maps and sets, union together) etc.
13:44:43 <nitrix> ertesx: I really couldn't find better ways :/
13:44:50 <nitrix> *There is
13:44:51 <ertesx> nitrix: i strongly recommend using automata:  newtype Auto a b = Auto (a -> (b, Auto a b))
13:44:55 <simpson> nitrix: That's not really a problem; Mark Miller showed that, with some tweaks, you can construct a *capability-safe* object system if you prevent objects from being globally accessible.
13:45:17 <nitrix> simpson: Right. They aren't globally accessible. Never will.
13:45:29 <ertesx> nitrix: myPlayer :: Auto Message (Player, [Message])
13:46:07 <ertesx> nitrix: Auto is an instance of ArrowLoop, so you can pass response messages everywhere
13:46:08 <nitrix> ertesx: Which package?
13:46:26 <ertesx> nitrix: the 'machines' package has a predefined one called Mealy
13:46:39 <deepak_> yoooooooooo
13:46:39 <ertesx> there is no "standard" package for them though
13:47:16 <nitrix> ertesx: I see. But defining it would let people know it's "stateful inside" (automata) ?
13:47:44 <deepak_> zzzzzzzzzzzzzzzzzz
13:47:56 <deepak_> hfhv
13:48:22 <ertesx> nitrix: yeah, in its most generic description it's a language for locally stateful components
13:49:13 <nitrix> ertesx: I'll do just that. Those are very constructive suggestions. I appreciate.
13:49:30 <nitrix> ertesx: Same as well.
13:49:33 <nitrix> simpson: ^
13:49:59 <ertesx> nitrix: welcome to the wonderful world of reinventing AFRP =)
13:50:49 <simpson> ertesx: Don't worry about it. (Or, IOW, welcome to the wonderful world of reinventing Smalltalk.)
13:51:38 <nitrix> I actually took the idea from Erlang.
13:52:45 <nitrix> Squished the triangle piece real good until it type-checked into a square :P
13:54:37 <ertesx> simpson: i don't‚Ä¶  though i think that smalltalk and AFRP have little in common except the underlying technology
13:54:49 <ertesx> they are very different idioms
13:56:20 <simpson> ertesx: Well, sure. The former is not fully typeable.
13:57:49 <ertesx> simpson: no, i mean the general idiom‚Ä¶  smalltalk is about sending messages, while AFRP is more about manipulating over time
13:58:27 <ertesx> simpson: and i think there is no smalltalk equivalent to switching, which is very common in AFRP
13:58:59 <simpson> ertesx: Smalltalk had a feature called "become", which allows any object to transform into another object, without disturbing any of the referring objects.
13:59:06 <simpson> It can emulate AFRP switching.
13:59:14 <simpson> Or vice versa, whichever way you want to go.
13:59:17 <Forty-Bot> is there a better way to do something like lines 13-15 in <http://paste.fedoraproject.org/361403/46204809/>?
14:00:20 <paolino_> Forty-Bot, it's a fold
14:00:41 <Forty-Bot> right, but how would I rewrite it?
14:01:03 <ertesx> Forty-Bot: foldl' (\x f -> f x) x0
14:01:31 <Forty-Bot> ah, thanks
14:01:41 <ertesx> :t foldl' (\x f -> f x)
14:01:42 <lambdabot> Foldable t => b -> t (b -> b) -> b
14:03:12 <ertesx> okay, something is wrong today‚Ä¶  it has been over a minute, and nobody has rewritten the lambda into flipped id yet‚Ä¶
14:03:34 <monochrom> haha
14:03:41 <Forty-Bot> hehe
14:03:45 <mniip> oh I had that in my mind right as you wrote it
14:04:00 <ertesx> mniip: i know
14:04:02 <ertesx> everybody had
14:04:31 <bergey> :t appEndo . foldMap Endo
14:04:32 <lambdabot> Foldable t => t (a -> a) -> a -> a
14:04:53 <bergey> ... if we're playing code golf now =)
14:08:05 <maerwald> can someone explain why test3 has different behavior than test2 here http://lpaste.net/162004
14:08:07 <bennofs> :t ala Endo foldMap -- wanna golf? use lens
14:08:08 <lambdabot> Foldable t => t (a -> a) -> a -> a
14:08:09 <maerwald> types are the same
14:08:15 <ertesx> :t \xs -> concat (map (\x -> [x - 1, x + 1]) xs)  -- this is a social experiment
14:08:16 <lambdabot> Num a => [a] -> [a]
14:10:09 <ertesx> tempting, isn't it?
14:11:09 <ertesx> and i know some of you are already secretly rewriting it, at least in their heads
14:11:16 <ertesx> some of you even have a (>>=) in it
14:11:20 <ertesx> and some a zipWith ($)
14:13:05 <bergey> bennofs: Yes, that one's nice too.
14:13:47 <monochrom> maerwald: which library is Control.Monad.Catch from, so I can read it?
14:13:50 <bennofs> maerwald: where did you get the Alternative IO instance from? Is this defined in Control.Monad.Catch?
14:13:56 <bennofs> monochrom: exceptions I think
14:13:59 <bennofs> @hackage exceptions
14:13:59 <lambdabot> http://hackage.haskell.org/package/exceptions
14:14:32 <maerwald> bennofs: yes, exceptions... I don't know how Control.Monad.Catch pulls in the Alternative IO, as you can see the left hand side of <|> is actually MonadThrow
14:15:04 <maerwald> but that doesn't explain why test2 behaves different than test3, because those types are ...well, the same
14:15:19 <monochrom> alright, maybe it is not about throwM, but rather <|>
14:15:57 <bennofs> instance MonadPlus IO where
14:15:59 <bennofs>     mzero       = ioError (userError "mzero")
14:16:01 <bennofs>     m `mplus` n = m `catchIOError` \ _ -> n
14:16:05 <bennofs> from http://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.Error.html
14:16:07 <bennofs> :o
14:17:08 <monochrom> and Alternative
14:17:25 <bennofs> Alternative uses (<|>) = mplus
14:18:10 <monochrom> so <|> watches for IOException only, which is userError.
14:18:19 <maerwald> omg
14:18:25 <maerwald> that's not nice
14:19:10 <monochrom> Control.Monad.Trans.Error itself is getting deprecated. It may be bad for Control.Monad.Catch to use it at all.
14:20:10 <bennofs> that instance seems like it has moved to base-4.9 though, not sure how I feel about that
14:20:35 <monochrom> ah but it wants to provide "instance MonadThrow (ErrorT e m)" so it has to import Control.Monad.Trans.Error
14:23:01 <monochrom> at any rate it may be a bad idea to endow IO with a universal mplus or <|> at all, since base doesn't do it when it could.
14:23:48 <maerwald> I just want <|> to work with my _own_ exceptions which happens inside ReaderT, so I need class constraints
14:24:04 <maerwald> would that work if I do: instance MonadPlus MyException where ...?
14:24:33 <monochrom> because people are going to argue to no end which exceptions it should honour or not honour. for example sometimes you want it to honour AsyncExceptions, sometimes not. one size will not fit all.
14:25:29 <bennofs> monochrom: it does do it in base-4.19, shipping with GHC 8
14:26:00 <monochrom> I think you're better off writing your own infix operator that honours your exception, and any other exceptions you care about.
14:27:05 <monochrom> bennofs: could you link me to that? thanks.
14:27:25 <monochrom> I'm very bad at finding links to GHC RC'ss
14:28:36 <bennofs> monochrom: you can see it at https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Base.hs#L1100 and https://github.com/ghc/ghc/blob/master/libraries/base/GHC/IO.hs#L150
14:30:01 <monochrom> I guess if you call it "IO" then you want to focus on "IOExceptions" :D
14:30:38 <maerwald> typeclass spagehtti :/
14:31:50 <monochrom> I think people will be fine with it if haddock says that it focuses on IOException/IOError
14:32:09 <monochrom> (and by today's haddock this documentation can be done)
14:36:16 <jle`> i wonder where the term 'hoist' came from
14:36:26 <jle`> was it an invention of Tekmo?
14:37:04 <monochrom> there was "lambda hoisting" before Tekmo.
14:38:21 <hpc> ghc taking a casual gig of memory to build OpenGLRaw lol
14:39:30 <ertesx> jle`: i think Tekmo introduced it in the context of natural transformations
14:39:56 <jle`> monochrom: what does lambda hoisting refer to?
14:40:02 <monochrom> I forgot
14:40:07 <jle`> i ask mostly because i see the terminology used a lot now in non-tekmo projects
14:40:18 <jle`> like a lot of edwardk packages use it
14:40:21 <ertesx> jle`: well, "map" is already taken
14:40:37 <monochrom> but I just found http://link.springer.com/article/10.1007%2FBF03037416
14:41:17 <jle`> i'm ... not sure if it's super related, hm
14:41:31 <monochrom> no, I'm just doing etymology
14:41:54 <monochrom> i.e., "did someone in FP used 'hoist' earlier?"
14:42:00 <jle`> ah, ok
14:54:12 <int-index> ertesx, nice social experiment. I immediately felt the urge to rewrite it with >>=
14:55:53 <ertesx> =)
14:59:28 <ertesx> :t maybe Nothing (\x -> Just (x ** sin x))  -- this is a social experiment
14:59:29 <lambdabot> Floating a => Maybe a -> Maybe a
15:00:00 <monochrom> that looks like an fmap
15:00:42 <monochrom> also, for the previous experiment, I would use concatMap, then I would consider replacing it by >>=, but not sure (toss a coin to find out)
15:00:58 <int-index> I like do-notation for lists
15:01:09 <int-index> :t \xs -> do x <- xs; [x - 1, x + 1]
15:01:10 <lambdabot> Num b => [b] -> [b]
15:01:21 <orion> What's the overhead of MVar compared to IORef if you're storing a connection handle in one thread and reading it by potentially hundreds of threads? (One write, many reads)
15:01:28 <monochrom> however, "Nothing -> Nothing; Just x -> Just (f x)" cries for fmap
15:01:57 <ertesx> orion: for mostly or exclusively reading, MVar is going to be more expensive‚Ä¶  not sure by how much though
15:02:23 <monochrom> in fact, recently it was important for me to go for fmap in an example to see the generalization to all functors.
15:02:33 <ertesx> i'm pretty sure someone will get rid of the lambda, too =)
15:03:19 <int-index> without importing Control.Arrow? =p
15:03:24 <ertesx> yeah
15:03:36 <ertesx> since base 4.8 everything you need is in the Prelude
15:05:09 <int-index> :t liftA2 (**) id sin
15:05:10 <lambdabot> Floating c => c -> c
15:07:19 <int-index> :t fmap ((**)<$>id<*>sin) -- never write code like this
15:07:20 <lambdabot> (Floating a, Functor f) => f a -> f a
15:08:09 <ertesx> and that's just ‚Ä¶
15:11:08 <montanonic> With parsec/megaparsec, what's an idiomatic way of returning a result right now if you're at the end of the current input, and otherwise continuing on?
15:12:21 <ertesx> :t fmap ((**) <*> sin)  -- i guess i could have made the S pattern more obvious
15:12:23 <lambdabot> (Floating a, Functor f) => f a -> f a
15:12:56 <lyxia> montanonic: (eof >> return early) <|> continuing on
15:13:07 <int-index> I totally forgot that <*> is S for (->)
15:13:12 <dredozubov_> montanonic: use alternative
15:13:15 <dredozubov_> :t (<|>)
15:13:16 <lambdabot> Alternative f => f a -> f a -> f a
15:13:26 <montanonic> lyxia, dredozubov_: awesome, thank you both
15:13:56 <int-index> lyxia, `early <$ eof` instead of `eof >> return early`
15:16:16 <lyxia> int-index: oh, yeah that's cleaner
15:18:46 <Peaker> :t ($>)
15:18:47 <lambdabot>     Not in scope: ‚Äò$>‚Äô
15:18:47 <lambdabot>     Perhaps you meant one of these:
15:18:47 <lambdabot>       data constructor ‚ÄòSeq.:>‚Äô (imported from Data.Sequence),
15:19:10 <jle`> lyxia: these days we even have eof $> early
15:19:18 <jle`> oh, sorry, missed Peaker 's message
15:19:28 <jle`> :t (Data.Functor.$>)
15:19:29 <lambdabot> Functor f => f a -> b -> f b
15:19:40 <jle`> > "hello" $> ' '
15:19:42 <lambdabot>      Not in scope: ‚Äò$>‚Äô
15:19:42 <lambdabot>      Perhaps you meant one of these:
15:19:42 <lambdabot>        data constructor ‚ÄòSeq.:>‚Äô (imported from Data.Sequence),
15:19:50 <jle`> @import Data.Functor
15:19:51 <lambdabot> Unknown command, try @list
15:20:06 <Peaker> (<$) blends more nicely with Applicative style invocations. But ($>) is nicer when you have results last, in left-to-right code (e.g: with &, >>= and <&>)
15:21:11 <ertesx> @let import Data.Functor
15:21:12 <lambdabot>  Defined.
15:22:38 <Zemyla> Is there a name for the operation that produces n copies of a list?
15:23:45 <ertesx> Zemyla: "copies"?
15:23:48 <johnw> replicate?
15:24:01 <Zemyla> johnw: No, that produces n copies of an element.
15:24:08 <johnw> i mean, make the element be a list
15:24:10 <ertesx> > replicate 3 [1,2,3]
15:24:12 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
15:24:21 <johnw> (concat .) . replicate
15:37:29 <jle`> Zemyla: lists can contain lists, too :)
15:39:21 <orion> If my goal is to wait for a IORef (Maybe Foo) to be not Nothing, am I better off using an MVar instead, or is the overhead prohibitive?
15:39:37 <ertesx> orion: use MVar
15:39:44 <orion> heh
15:41:01 <ertesx> orion: MVar is a very cheap primitive abstraction‚Ä¶  pretty much all non-transactional concurrency abstractions are based on it
15:42:16 <orion> https://gist.github.com/chemist/5853246
15:42:24 <haskell177> What is illegal instance and why does I get that error here? http://lpaste.net/162007
15:43:13 <haskell177> I mean flexible instance
15:43:56 <lyxia> haskell177: the arguments of a typeclass must have the form "Constructor var var ... var". "Add a" has this form, but "a" doesn't.
15:44:13 <lyxia> FlexibleInstances lifts that constraint
15:45:16 <ertesx> orion: sure, but the numbers may be misleading you
15:45:24 <haskell177> all the var must be the same in "Constructor var var ... var"?
15:45:35 <geekosaur> must be different
15:45:36 <lyxia> no, they actually shouldn't be the same either
15:46:23 <haskell177> I don't really get it then lol, why isn't a legal here?
15:46:40 <haskell177> because it doesn't have a constructor?
15:47:02 <geekosaur> the haskell standard is extremely conservative
15:47:49 <geekosaur> so it only supports the simplest "template". ghc can handle more but requires you to enable FlexibleInstances to make sure you know that you';re not doing something that is standard Haskell.
15:47:59 <geekosaur> (It is not clear that this serves a practical purpose these days.)
15:49:23 <int-e> haskell177: the whole (Add a) is what it's complaining about... it's expecting a type variable instead.
15:49:29 <EvanR> FlexibleInstances and FlexibleContexts seem obvious to enable
15:49:38 <EvanR> always
15:49:52 <EvanR> standards be damned
15:49:58 <haskell177> so it's not a "code smell" to add these extensions?
15:50:04 <geekosaur> not those, no
15:50:24 <alk> kiba{VZ/ws mist
15:50:28 <geekosaur> back in the day, it was a warning that such code wouldn't work in hugs, uhc, yhc, ...
15:50:42 <haskell177> oh great then, thanks :D
15:50:52 <geekosaur> but for several years now ghc has been the only maintained Haskell compiler, and de facto it is the standard
15:51:25 <geekosaur> (well, someone --- Utrecht students? --- is still making changes to uhc, which is up on github. but nobody seems to know its current status)
15:51:36 <haskell177> there is ghcjs now too
15:51:39 <maerwald> not standard, just most widely used compiler
15:51:45 <geekosaur> but that is part of ghc
15:52:00 <andromeda-galaxy> haskell177: ghcjs uses the ghc frontend, etc. it's just a different code generator stage
15:52:35 <ntnt> are there any https://github.com/begriffs/haskell-vim-now users here? if so, have you tried neovim ?
15:57:54 <thoughtpolice> EvanR: No, FlexibleInstances at least is certainly going to be a point of discussion, but it is not so clear cut. It can be used to violate instance coherence even in the absence of any orphans. That's not an outright rejection, but the feature is not so simple.
16:00:02 <thoughtpolice> (But, to be honest, while it's not an outright rejection, it's certainly not doing it any favors in terms of voting)
16:00:34 <thoughtpolice> Oh, I misread. I thought you were referring to Prime, but I see you mean regardless of that. Nevermind in that case :)
16:04:57 <montanonic> If I have some Parser, and I want it to always skip any space that ever comes up, what would I write? (using Parsec)
16:06:23 <EvanR> you have to put a whitespace parser before and in between anything
16:06:44 <EvanR> many space
16:08:11 <montanonic> EvanR: see, I was hoping there was a cleaner way to do that, but yeah, I think I might have to
16:08:16 <hpc> many space, such parse
16:08:16 <hpc> wow
16:09:45 <EvanR> montanonic: you cant engineer it to always put this parser between anything since you probably dont want tthat
16:10:09 <montanonic> Is there not a "run this parser unless there is this character, in which case use this parser until it fails, then return back to the original parser"
16:11:01 <montanonic> I guess that would be resuming with Partials
16:13:08 <EvanR> montanonic: sure
16:13:48 <EvanR> takeWhile or takeUntil, followed by many p, followed by a recursive call
16:15:01 <montanonic> EvanR: I'll give that a try. Thank you.
16:19:13 <nocturne777> what would be most performant library when one needs a multi-dimensional array? 
16:19:46 <ertesx> orion: trying to benchmark IORef with a more interesting experiment, but it turns out to be difficult, because it livelocks all the time =)
16:20:29 <ertesx> i think it's a livelock
16:21:07 <ertesx> sometimes it's done in seconds, but sometimes it seems to go into an infinite loop, which is most likely two writes restarting each other
16:22:08 <ertesx> nocturne777: vector
16:22:33 <EvanR> ertesx: what, really?
16:22:39 <EvanR> re live locked IORefs
16:22:50 <nocturne777> ertesx: vector does not seem to have support for mutable multi-dimentional arrays
16:22:55 <ertesx> EvanR: it's busy-locking, and i'm assuming it's a live-lock
16:23:13 <ertesx> nocturne777: but it is very fast‚Ä¶  you would just need to do the coordinate translation yourself
16:23:40 <nocturne777> ertesx: I tried Data.Array, which turned out to be not as fast
16:23:44 <ertesx> nocturne777: \x y -> w*y + x  -- where w is the width
16:24:08 <orion> How expensive is forkIO?
16:24:14 <nocturne777> ertesx: I will give vector a shot
16:24:41 <ertesx> orion: wait, i'll post the code
16:25:01 <EvanR> yeah a 4x4 array is easily implemented as a 16-vector
16:25:13 <orion> Also, if a thread calls forkIO, and /that/ thread calls forkIO, if the parent thread dies, does the child die?
16:25:20 <EvanR> a matrix library would be nice though
16:25:43 <EvanR> orion: no, forkIO threads continue on
16:25:44 <geekosaur> orion: forkIO threads are cheap, and the only "special" thread is the main one
16:26:03 <maerwald> orion: forkIO forks a "green thread", not a native OS thread
16:26:04 <EvanR> the async library can be used to create parent child threads
16:26:15 <orion> So, it's completely reasonable for me to forkIO $ writeHTTPRequestToLogFile
16:26:17 <maerwald> so it's cheaper
16:26:31 <ertesx> EvanR, orion: http://lpaste.net/162014
16:26:49 <EvanR> orion: sure that ought to work, though by itself you might have issues with error handling
16:26:59 <EvanR> if the write fails, what do you want to happen
16:27:05 <ertesx> TVar seems to win every round
16:27:18 <ertesx> especially when multiple OS threads are there
16:27:21 <montanonic> So, I guess it seems like it's just better to use Data.Text.strip or something like that to get rid of all whitespace first, and *then* Parse it
16:27:34 <orion> EvanR: I don't care if the write fails.
16:27:43 <EvanR> well ok...
16:27:52 <ertesx> IORef can perform anywhere from 'slightly better than MVar' to livelock
16:27:53 <EvanR> you will get stderr report of the exception though
16:27:59 <EvanR> you might want to surpress that
16:28:01 <ertesx> with 1000 IORefs it usually livelocks
16:28:07 <ertesx> so i recommend not using IORef
16:28:13 <ertesx> at least for such a busy application
16:28:27 <EvanR> ertesx: i dont understand this behavior, why is it happening?
16:28:52 <ertesx> EvanR: as far as i understand, atomicModifyIORef behaves similar to STM: it doesn't wait, but restart
16:29:05 <ertesx> if it would busy-wait instead, it would just take a very long time
16:29:46 <EvanR> so its looping and if you have too many things looping you get no cpu time to do anything else?
16:30:09 <EvanR> and it slows down to almost stopped (but its not stopped)
16:30:11 <EvanR> is that right
16:30:23 <ertesx> for a livelock two things are enough, if they conflict and are both expensive enough not to finish in time, before the other one tries again
16:30:48 <ertesx> and it is a lock, so it does indeed stop
16:31:48 <EvanR> what is expensive?
16:31:56 <EvanR> just writing the pointer to the cell?
16:32:06 <EvanR> its not evaluating thunks at the point is it
16:32:11 <ertesx> EvanR: the time between entering the critical section and leaving it
16:32:14 <koz_> Could someone point me to something considered to be a good paper on a functional data structure? Recent ones preferred.
16:32:29 <ertesx> EvanR: my example is (atomicModifyIORef' is strict)
16:32:43 <maerwald> "a functional data structure"?
16:33:02 <EvanR> why is it evaluating inside the critical section o_O
16:33:06 <erisco> isn't there a definition for (a -> s -> (s, a)) -> s -> a -> [a] other than StateT?
16:33:07 <EvanR> and not prior
16:33:24 <ertesx> i generally recommend not using IORef in concurrency‚Ä¶  TVar has similar semantics, but almost always wins both the benchmark and the safety contest
16:33:39 <erisco> well, one which uses StateT anyways
16:33:44 <ertesx> EvanR: because i wanted it to
16:33:49 <erisco> :t iterate -- like this but with a state
16:33:50 <lambdabot> (a -> a) -> a -> [a]
16:34:06 <erisco> I guess you can just use a 2-tuple for a
16:34:11 <EvanR> ertesx: i thought this was the choice of how atomicModifyIORef' is implemented
16:36:29 <ertesx> EvanR: i've just changed it to the nonstrict version, and it's almost an order of magnitude slower than TVar now
16:36:39 <EvanR> how o_O
16:36:51 * EvanR very confused now about how IORefs work
16:37:34 <ertesx> this one isn't IORef's fault directly‚Ä¶  now that it's basically just pointer swapping, all the computation is delayed, and i'm essentially just building thunks
16:37:45 <ertesx> succ (succ (succ (succ (succ ...
16:38:01 <EvanR> oh
16:38:22 <ertesx> since there is a consumer waiting, they are periodically evaluated, but not as quick as when the writing thread does it
16:40:09 <EvanR> also i was mistaking the whole discussion to be about atomicWriteIORef
16:40:46 <ertesx> well, in most cases what you write depends on what is currently stored =)
16:41:19 <EvanR> a dumb caching thing...
16:42:00 <ertesx> anyway, bottom line: use TVar for mutable variables and MVar for channels
16:42:22 <ertesx> IORefs don't seem to offer an advantage
16:42:36 <EvanR> i think TChans were faster
16:42:50 <EvanR> or TMVars
16:43:07 <EvanR> you tested high contention?
16:43:18 <ertesx> note that MVar offers a fairness guarantee that the STM constructs don't
16:43:52 <ertesx> i think 1001 threads fighting over a single variable simultaneously is pretty high-contention =)
16:44:21 <EvanR> TVar doesnt have fairness?
16:44:24 <montanonic> ertesx: while on the topic, how does TVar compare to STRef?
16:44:41 <montanonic> does STRef have the same flaws as IORef?
16:44:57 <EvanR> can multiple threads get to the same STRef?
16:45:36 <montanonic> oh, I don't know for sure but I'm pretty sure *no*, given how ST stays pure
16:46:07 <EvanR> so STRef may be even faster for being a dumb cell
16:46:25 <ertesx> montanonic: IORef and STRef are the same thing
16:46:36 <montanonic> ertesx: okay, just wanted to confirm; ty
16:46:51 <ertesx> montanonic: however, you never get STRef in a multi-threaded setting
16:46:57 <ertesx> (unless you do unsafe stuff)
16:46:59 <montanonic> right
16:47:40 <ertesx> EvanR: nope, TVar is not fair (in the sense MVar is)
16:48:00 <montanonic> oh, I see, I didn't realize TVar was the data structure used with STM
16:48:09 <montanonic> I thought STM and TVar were different
16:48:14 <chaoxu> hi guys, can I mix IO and Maybe inside the same do block? I want to get value of that Maybe and then print it
16:48:16 <montanonic> well, I mean, they are, but you know
16:48:44 <montanonic> chaoxu: IO (Maybe a) is a valid type, if that's what you're asking
16:48:44 <koz_> chaoxu: Does pattern matching not work for you?
16:49:00 <chaoxu> koz_: right, this will work, thanks
16:49:15 <koz_> chaoxu: You can also fmap into a Maybe and have that do your IO.
16:49:24 <ertesx> chaoxu: you can use 'case' in a do-block on any value that is in scope, including those bound by "<-"
16:49:46 <ertesx> chaoxu: do mx <- tryToGetX; case mx of Just x -> ...; Nothing -> ...
16:49:51 <EvanR> the question is about Maybe Printable -> IO ()
16:50:40 <EvanR> whenJust mx print ;)
16:51:01 <koz_> EvanR: wouldn't 'fmap print mx' work?
16:51:04 <montanonic> chaoxu: 'mapM_ print yourMaybeValue' will do nothing if the Maybe value is Nothing, that's yet another way
16:51:15 <EvanR> :t fmap print Nothing
16:51:16 <lambdabot> Maybe (IO ())
16:51:20 <EvanR> no
16:51:25 <montanonic> koz_: you'd need to sequence it
16:51:37 <montanonic> :t sequence (fmap print Nothing)
16:51:38 <lambdabot> IO (Maybe ())
16:51:42 <xa0> Maybe IO ()
16:51:45 <koz_> EvanR and montanonic: Yeah, I see now.
16:51:46 <mniip> :t traverse print Nothing
16:51:47 <lambdabot> IO (Maybe ())
16:52:02 <ertesx> IO () Maybe
16:52:04 <xa0> MaybeT IO ()
16:52:05 <ertesx> Maybe () IO
16:52:11 <EvanR> () Maybe IO
16:52:17 <mniip> (IO Maybe)
16:52:27 <ertesx> IO M(aybe )
16:52:29 <EvanR> such horrible constructions
16:52:29 <montanonic> Maybe (IO ())
16:52:47 <EvanR> Maybe (IO (
16:52:58 <mniip> Maybe)))
16:53:07 <erisco> > fix (((:) <$> head <*>) . (. (filter <$> ((liftA (/=0) <$> flip mod).head) <*> id))) [2..]
16:53:09 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:53:12 <ertesx> > fix ("Maybe " ++)
16:53:14 <lambdabot>  "Maybe Maybe Maybe Maybe Maybe Maybe Maybe Maybe Maybe Maybe Maybe Maybe May...
16:53:15 <srhb> mniip: Wrong kind.
16:53:15 <EvanR> )MeO(Iyb
16:53:17 <mniip> jeez even writing that makes me feel sick
16:53:22 <srhb> :-P
16:53:26 <ertesx> EvanR: +a
16:53:33 <erisco> I made a sieve
16:53:34 <koz_> :t fix
16:53:35 <lambdabot> (a -> a) -> a
16:53:38 <mniip> > sort "Maybe IO ()"
16:53:39 <lambdabot>  "  ()IMOabey"
16:53:45 <erisco> a point-free sieve
16:54:55 <koz_> What libraries is lambdabot aware of?
16:55:03 <xa0> > map concat $ sequence ["Maybe", "T", " ", "(", "IO", " ", "()", ")"]
16:55:04 <lambdabot>      Couldn't match type ‚ÄòChar‚Äô with ‚Äò[a]‚Äô
16:55:04 <lambdabot>      Expected type: [[a]]
16:55:04 <lambdabot>        Actual type: [Char]
16:55:11 <ertesx> erisco: anything that has "mod" or "div" is not a sieve
16:55:18 <ertesx> erisco: you made point-free trial division
16:55:46 <ertesx> a sieve uses bit operations to find primes
16:56:05 <erisco> ertesx, I don't really know what you mean
16:56:13 <koz_> ertesx: Do *all* sieves use bitops?
16:56:23 <erisco> it removes 2 and all the multiples of 2, then it removes 3 and all the multiples of 3, then it removes 5 and all the multiples of 5, and so on
16:56:45 <erisco> how do I determine if something is a multiple? I use mod
16:57:02 <AleXoundOS__> Hi. Is there exact match for uint_fast8_t type in FFI? Or I should avoid using fast* types and use uint8_t?
16:57:12 <Rembane> erisco: Or you first jump 2 steps for all numbers, then restart and jump three steps and so on.
16:57:29 <erisco> sure but there is no difference
16:57:33 <ertesx> koz_: all sieves i know of
16:57:59 <ertesx> erisco: there is‚Ä¶  you won't find the first one million primes using modulo in less than a second =)
16:58:27 <ertesx> the point of sieving is that it's faaaaaaaaaaaaaaast
16:59:30 <EvanR> AleXoundOS__: Word8 
16:59:52 <AleXoundOS__> EvanR, so Word8 = uint8_t, but is there uint_fast8_t analogue?
16:59:52 <EvanR> i dont think haskell exists on enough platforms for uint_fast8_t to make any difference
17:00:05 <AleXoundOS__> ok
17:00:20 <EvanR> its just PCs and phones as far as i know
17:00:21 <koz_> EvanR: Just x86 and ARM, right?
17:00:32 <koz_> Well, x86_64 I guess.
17:01:09 <AleXoundOS__> I think in practice uint_fast8_t doesn't make difference. But uint_fast16_t does.
17:01:28 <EvanR> AleXoundOS__: the full list appears to be "Char, Int, Double, Float, Bool, Int8, Int16, Int32, Int64, Word8, Word16, Word32, Word64, Ptr a, FunPtr a, StablePtr a or a renaming of any of these using newtype"
17:01:39 <erisco> ertesx, I don't see how that is a requirement of sieves, i.e. to have some quality of fastness
17:01:55 <AleXoundOS__> EvanR, thank you
17:02:42 <EvanR> and the return type of a foreign function can also be ()
17:03:44 <ertesx> erisco: in number theory sieves are commonly understood as things that "divide without actually dividing" by using the fact that "x ‚â° y (mod n)" is the same statement as "there exists an integer k, such that x - y = k*n"
17:04:25 <ertesx> erisco: in simpler terms, integers divisible by p are all a multiple of p apart
17:04:38 <ertesx> sieving is the process of finding all of them without dividing by p
17:04:47 <ertesx> and without any checking
17:06:10 <erisco> okay I will remove mod
17:09:29 <chaoxu> how to logging something inside a do block of RandT monad?
17:09:46 <chaoxu> for debugging reason
17:10:17 <EvanR> make a debug action
17:10:34 <EvanR> internally it can use Debug.Trace
17:10:41 <EvanR> (if you dont have IO)
17:11:57 <chaoxu> The most straightforward way seems to be evaluate a IO monad inside that do block, but don't know how to do that
17:12:05 <maerwald> Debug.Trace is for debugging, not logging
17:12:06 <EvanR> are you transforming over IO
17:12:21 <EvanR> "04:09 < chaoxu> for debugging reason"
17:12:51 <EvanR> :t liftIO
17:12:52 <lambdabot> MonadIO m => IO a -> m a
17:13:10 <simpson> :t traceM
17:13:11 <lambdabot>     Not in scope: ‚ÄòtraceM‚Äô
17:13:11 <lambdabot>     Perhaps you meant ‚Äòbraces‚Äô (imported from Text.PrettyPrint.HughesPJ)
17:13:40 <maerwald> chaoxu: you're not supposed to use Debug.Trace in "production" code, since it uses unsafePerformIO under the hood. If you want proper debugging via logging at runtime, you have to do something else.
17:14:16 <chaoxu> EvanR: What's transforming over IO? liftIO lift any monad to IO? How does it achieve that?
17:14:17 <maerwald> for anything else, Debug.Trace is the quickest solution during development
17:14:42 <EvanR> chaoxu: i was asking if you were doing RandT IO, in which case you can use liftIO (print "whatever")
17:14:57 <chaoxu> EvanR: no, it's RandT [Int]
17:15:12 <EvanR> oh, then you need to use Debug.Trace
17:15:54 <koz_> Is there a way to indicate a pattern of a tuple with two identical elements?
17:15:57 <EvanR> and create a traceM 
17:16:01 <koz_> (x, x) obviously doesn't work.
17:16:17 <EvanR> unfortunately (x,x) doesnt work, which would be a non-linear pattern
17:16:28 <EvanR> (x,y) | x == y = 
17:16:40 <koz_> EvanR: Will that work in a case statement?
17:16:43 <EvanR> yes
17:16:49 <koz_> Oh, neat! Thanks!
17:17:05 <EvanR> (x,y) | x == y -> in a case
17:18:38 <koz_> EvanR: I guessed as much.
17:18:44 <koz_> That's a really neat thing I didn't know about.
17:18:57 <EvanR> lookup "guards"
17:19:02 * hackagebot tar 0.5.0.2 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-0.5.0.2 (DuncanCoutts)
17:29:02 * hackagebot json-rpc-server 0.2.4.0 - JSON-RPC 2.0 on the server side.  https://hackage.haskell.org/package/json-rpc-server-0.2.4.0 (KristenKozak)
17:29:13 <chaoxu> Can a function return a Int but also print something? I guess it must have type IO Int. Sounds hacky
17:29:33 <simpson> chaoxu: What's hacky about that?
17:30:22 <chaoxu> simpson: since returned Int is not because of IO input
17:31:15 <EvanR> chaoxu: IO Int isnt a function
17:31:35 <EvanR> its an IO action that returns an Int 
17:31:49 <simpson> chaoxu: Well, why are you printing? Is this related to your earlier question about debugging?
17:32:07 <xa0> EvanR: I see nothing wrong in what he said
17:32:28 <EvanR> can a function... it must have type IO Int, sounds hacky
17:32:34 <EvanR> not hacky but inaccurate
17:32:49 <xa0> Meh
17:33:04 <EvanR> you can make an IO action print something and return an Int just like that though
17:34:30 <chaoxu> simpson: yea, just anything involving IO has to been lift to IO, it seems you have to keep lift monads to higher ones if you want more functionality
17:34:59 <Inter-> Anyone have any clue if a 80% heat reflection and 15% dark silver solarfilm would act as a good material for a window with a LCD screen behind it? What optional materials could I use?
17:35:18 <koz_> chaoxu: return 3 in the right context is an IO Int, despite having done no IO.
17:35:46 <EvanR> anything involving IO must involve the IO type, which are IO programs
17:35:48 <simpson> chaoxu: We were trying to tell you about Debug.Trace, which contains functions that can print debugging information.
17:35:58 <simpson> chaoxu: Debug.Trace functionality does *not* require IO!
17:36:21 <EvanR> Inter-: try #electronics ?
17:36:39 <Inter-> Thanx :)
17:37:32 <mathu> i have a list of tuples [(a,a)]; i want a list of every permutation like [fst (a,a), fst (a,a)], [fst (a,a), snd (a,a)], [snd (a,a), fst (a,a)], [snd (a,a), snd (a,a)]
17:39:12 <mathu> i know there'll be (2^n - 1) resulting lists and i can think of this basically as a bitstring, but i'm struggling to think of how best to write the code
17:40:04 <koz_> mathu: You can represent each permutation as a bitstring.
17:40:27 <koz_> Basically 0 = not included, 1 = included, and your bitstrings will have a length equal to the number of elements you're permuting.
17:40:52 <simpson> :t Data.List.permutations
17:40:53 <lambdabot> [a] -> [[a]]
17:41:18 <EvanR> those arent permutations
17:41:21 <simpson> Oh, I see.
17:41:39 <mathu> well, permutations for every number of 1s 0-n
17:42:25 <xa0> mathu: what would you get for [(a,a), (b,b)]
17:42:49 <mathu> xa0: hm? every element of every tuple is an a
17:43:04 <xa0> Oh I misunderstood you, I get it.
17:43:56 <EvanR> theres gotta be a short list comprehension for this
17:44:50 <johnw> > liftA2 (,) <$> [fst,snd] <*> [fst,snd] <*> [(a,a), (b,c)]
17:44:52 <lambdabot>  [(a,a),(b,b),(a,a),(b,c),(a,a),(c,b),(a,a),(c,c)]
17:45:04 <johnw> pretty easily rewritten as a list comprehension
17:46:56 <simpson> IIUC, given [(a,b),(c,d)], they want [[a, c], [b, c], [a, d], [b, d]].
17:47:26 <johnw> he never said anything about the behavior across tuples in the list
17:47:46 <xa0> The explanation wasn't ideal but I agree with simpson
17:49:30 <mathu> say i have a list of three tuples. i essentially want [snd, snd, snd], [snd, snd, fst], [snd, fst, snd], [snd, fst, fst], [fst, snd, snd], [fst, snd, fst], [fst, fst, snd], [fst, fst, fst]
17:49:55 <mathu> so i guess it's not 2^n-1 lists, but just 2^n
17:50:32 <erisco> these tuples are all of type (a,a) ?
17:50:42 <mathu> and instead of a list of functions it would be the functions applied to the list of tuples in that order :P
17:50:46 <mathu> erisco: yes
17:52:46 <mathu> oh hey replicateM is a function that exists
17:54:33 <lpaste> ertes pasted ‚ÄúPure prime sieve‚Äù at http://lpaste.net/162017
17:54:35 <mathu> it seems awkward to me to create a list of functions and then perform them over the list of arguments but hey i think i can get the code working at least
17:54:57 <ertes> erisco: this one is a real sieve: http://lpaste.net/162017
17:55:12 <ertes> erisco: since i'm not actually using a mutable bit-field, it's horribly inefficient
17:55:58 <erisco> efficiency wasn'
17:56:02 <EvanR> mathu: seems correct to me
17:56:03 <erisco> t the interest, point-free was
17:56:22 <EvanR> functional programming at its finest ;)
17:57:19 <erisco> I started working on a new version which marks integers as in or out but am too tired to finish it now
17:58:09 <erisco> I accidentally wrote this bit which does the wrong thing ((.) <$> (map snd .) . filter . (.fst) . (==) <*> zip . (cycle . enumFromTo 1)) <$> head <*> id
17:58:35 <erisco> it doesn't keep the discarded integers around, so as it progresses it throws out the wrong ones
18:00:01 <ertes> you can always pass your code through @pl for some extra obfuscation =)
18:00:29 <erisco>  @pl has the tendency to produce awful results
18:00:58 <haskell177> @pl test a b = a + b
18:00:58 <lambdabot> test = (+)
18:01:18 <EvanR> @pl \a b -> a + b
18:01:18 <lambdabot> (+)
18:02:31 <ertes> @pl \f x g -> f (g x) x
18:02:31 <lambdabot> join . (flip .) . (. flip id) . (.)
18:03:45 <erisco> see?
18:04:03 * hackagebot json-rpc-client 0.2.4.0 - JSON-RPC 2.0 on the client side.  https://hackage.haskell.org/package/json-rpc-client-0.2.4.0 (KristenKozak)
18:04:27 <ertes> not that there is a much nicer way to do it =)
18:04:29 <haskell177> can I type a where in the @pl definition
18:05:27 <erisco> sure there is, such as flip <$> ((<*>) <$> flip)
18:06:00 <orion> I wrote a web server that converts HTTP requests to JSON and pushes them to RabbitMQ. I am using Warp for the server which creates one Haskell thread per HTTP request. Should I create one RMQ Channel per request, or should I create one Channel for the entire server?
18:06:20 <danilo2> Hello guys! :) Is it ok and wise to enable 
18:06:27 <orion> Or should I have a pool of Channels?
18:06:31 <danilo2> Hello guys! :) Is it ok and wise to enable "fontconfig" use flag globally ?
18:06:32 <rom1504> danilo2: yes
18:06:44 <erisco> which of course is also just   flip . (<*>) . flip
18:06:52 <rom1504> ah no, I wanted to say you should "enable"
18:07:06 <geekosaur> was that intended for #gentoo?
18:07:10 <ertes> orion: that's more an RMQ question than a haskell question
18:07:13 <erisco> so, that is why I am not too fond of @pl, but it is worth a shot for free
18:07:27 <danilo2> Yep, that was for gentoo , sorry guys :)
18:07:41 <maerwald> haskell does not have USE flags, except a few packages that misuse cabal flags
18:07:47 <orion> ertes: That's probably true.
18:13:52 <haskell177> I don't get why I got errors if I don't add the type to integer literals http://lpaste.net/162018
18:15:49 <EvanR> output :: a -> (b, String)
18:15:59 <EvanR> with your type sig there, it knows that b is Integer
18:16:12 <EvanR> but a can be any Num since you used a number literal
18:16:18 <EvanR> so it doesnt know which instance to use
18:17:00 <haskell177> so how can I fix it?
18:17:57 <EvanR> exactly what do you want to fix, this looks like test code
18:18:12 <EvanR> if you had passed the integers in as arguments there would be more information to go on
18:19:18 <haskell177> I'm more worried if there is something wrong with my instance definition that makes this error pops out :p
18:20:18 <EvanR> nope
18:20:33 <EvanR> as it says your code is ambiguous
18:23:04 <EvanR> haskell177: you might want to check out GADTs for representing arithmetic expressions as data
18:23:29 <EvanR> they let you get more control over the type parameters 
18:23:31 <xa0> > (\x -> map (zipWith (flip ($)) x) ((.(:[])).(:) <$> [fst,snd] <*> [fst,snd])) [(a,b), (c,d)]
18:23:33 <lambdabot>  [[a,c],[a,d],[b,c],[b,d]]
18:23:39 <xa0> I don't think I can golf this any further
18:23:58 <EvanR> (.(:[])).(:) great googley moogley
18:24:04 <xa0> Haha
18:24:13 <xa0> It's one of my favourite operators
18:24:35 <haskell177> :t :[]
18:24:36 <lambdabot> parse error on input ‚Äò:‚Äô
18:24:41 <EvanR> :t (:[])
18:24:42 <lambdabot> a -> [a]
18:24:45 <xa0> It's just \x y -> [x,y]
18:24:55 <haskell177> oh so it's like a golfed return
18:24:59 <xa0> Yeah
18:25:05 <orion> If you maintain a pool of resources like connection handles, is it a bad idea to use (i, _) <- myThreadId >>= threadCapability as an index to an Array of handles?
18:25:05 <EvanR> > pure 4 :: [Int]
18:25:06 <haskell177> but much cooler
18:25:07 <lambdabot>  [4]
18:25:13 <xa0> :p
18:25:20 <haskell177> it should be an emoji
18:25:35 <EvanR> orion: o_O use a Data.Map
18:26:03 <EvanR> (.(:[])).(:)
18:26:07 <EvanR> (\x y -> [x,y])
18:26:12 <EvanR> \x y -> [x,y]
18:26:19 <EvanR> it is technically shorter
18:26:52 <orion> So this is bad code?: https://github.com/kazu-yamamoto/logger/blob/d2afcf87eae9c599761a04423fb43a891e21b68b/fast-logger/System/Log/FastLogger.hs#L106
18:27:15 <erisco> hm, you'd think [,] would be a function
18:27:15 <mathu> how would y'all handle writing a fold over Data.Tree? subforests are lists of trees, so i want to fold over each and use the result as the accumulator for the next. not sure how to tackle that
18:27:39 <EvanR> orion: capability is like a number between 1 and 4 right... what use is it
18:27:52 <erisco> I guess that is not consistent with []
18:27:54 <mathu> i can't `foldr (treeFold f z) ?` because then each tree has the same accumulator and i'm not sure what to use as the accumulator for the foldr
18:28:04 <EvanR> implement Foldable for you tree
18:28:24 <EvanR> :t foldr
18:28:25 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
18:29:17 <mathu> well, that's kind of the trouble EvanR
18:29:36 <EvanR> you will have to thread the accumulator yourself to each thing
18:29:49 <EvanR> and keep it so you can continue
18:29:55 <mathu> yup, which i don't know how to do haha
18:30:04 <montanonic> mathu: don't start with a fold
18:30:06 <EvanR> its an exercise in writing a recursive function
18:30:09 <montanonic> mathu: just use recursion
18:31:16 <mathu> montanonic: hm, i'll try that approach
18:32:00 <koz_> How does one make a Map from CorePrelude?
18:32:45 <koz_> (like, an empty one)
18:32:46 <montanonic> mathu: once you solve it with basic recursion, make a foldable instance
18:39:33 <xa0> :T flip id
18:39:47 <xa0> :t flip id
18:39:48 <lambdabot> b -> (b -> c) -> c
18:40:35 <xa0> :t flip ($)
18:40:36 <lambdabot> a -> (a -> c) -> c
18:40:44 <EvanR> koz_: it doesnt have anything exported for that
18:41:21 <EvanR> :t id id id id id
18:41:22 <lambdabot> a -> a
18:41:35 <EvanR> :t id . id $ id . id $ id
18:41:36 <lambdabot> a -> a
18:42:55 <EvanR> :t lex
18:42:57 <lambdabot> ReadS String
18:43:04 <erisco> EvanR, not enough fmap
18:43:35 <EvanR> :t id fmap fmap id id fmap id fmap id
18:43:36 <lambdabot> Functor f => f a -> f a
18:43:48 <EvanR> haskell is easy, nothing is ever wrong!
18:44:26 <koz_> EvanR: Or for adding elements either. Guess I have to do some importin'.
18:44:42 <EvanR> yeah, but it exports the type for Map
18:44:45 <erisco> > mappend `id` "hello " `id` "polymorphism"
18:44:47 <lambdabot>  "hello polymorphism"
18:44:54 <EvanR> so you dont have to import qualified M and unqualified Map
18:45:04 <EvanR> two imports, which is annoying
18:53:39 <AleXoundOS__> Is there an easy way to convert from CFile to Handle? There is System.Posix.IO.fdToHandle, but it's input is not the same as CFile. Even if I manage to get System.Posix.Types.Fd from CFile, I'm not sure that it's the right way.
18:58:18 <EvanR> AleXoundOS__: so CFile itself seems to be for use with Ptr, some foreign calls return  Ptr CFile
18:58:45 <AleXoundOS__> yeah, sorry, I have Ptr CFile
18:58:45 <EvanR> which is opaque
18:59:28 <EvanR> "The proper function is int fileno(FILE *stream). It can be found in <stdio.h>, and is a POSIX standard but not standard C."
18:59:37 <EvanR> maybe fileno is somewhere in the ffi
18:59:59 <EvanR> you can create a Handle from an FD as a last resort
19:00:52 <AleXoundOS__> ok, but isn't is the same? fileno returns FD, right?
19:02:09 <AleXoundOS__> EvanR, Is there another way (without creating Handle from an FD "as a last resort")?
19:02:12 <geekosaur> no
19:02:33 <geekosaur> C file handles and Haskell file handles are only related in that they both are based on FDs (on Posix-ish systems)
19:02:53 <geekosaur> note that Windows throws in some gotchas, such as that sockets don't actually have file descriptors
19:03:15 <EvanR> o_O
19:04:02 <AleXoundOS__> So first I need to get FD using fileno using FFI. Then I use System.Posix.IO.fdToHandle to get a Handle from FD? Right?
19:04:07 <geekosaur> winsock synthesizes file descriptor values; those are recognized by windows stdio and redirected to winsock, but using them directly will fail with non-winsock functions
19:04:18 <geekosaur> AleXoundOS__, yes
19:04:28 <AleXoundOS__> ok, thank you
19:05:33 <geekosaur> (and there's some grottiness in Haskell's Handle internals to store winsock sockets and actual Windows file descriptors separately and use separate backends for them)
19:26:08 <moplove> hello everyone. Feels nice to be in here again. Been a long time
19:26:18 <EvanR> wb
19:26:19 <moplove> but sadly my return was inspired by some trouble
19:26:48 <moplove> I'm a pretty novice Haskell dev so I just don't know the right way to deal with stuff like this
19:27:06 <moplove> I'm using Network.Wreq and noticed that some functions use strict bytestrings and some use lazy ones
19:27:31 <moplove> dealing with conversions between Text and ByteString, and lazy versions of both, is turning into a bit of a nightmare
19:27:38 <geekosaur> :t toChunks
19:27:39 <lambdabot>     Not in scope: ‚ÄòtoChunks‚Äô
19:27:39 <lambdabot>     Perhaps you meant ‚ÄòBSLC.toChunks‚Äô (imported from Data.ByteString.Lazy.Char8)
19:27:39 <moplove> wondering if anyone might have tips
19:27:54 <geekosaur> :t BSLC.toChunks
19:27:55 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
19:28:32 <EvanR> (why Char8)
19:28:50 <geekosaur> ask int-e?
19:29:02 <geekosaur> or whoever's managing lb's source these days
19:29:06 * hackagebot hinotify-bytestring 0.3.8.1 - Haskell binding to inotify, using ByteString filepaths  https://hackage.haskell.org/package/hinotify-bytestring-0.3.8.1 (maerwald)
19:29:10 <EvanR> moplove: agree on a common text type, like Text, and only convert to and from at the boundaries of your program
19:29:16 <geekosaur> I was a bit surprised as well
19:29:34 <EvanR> validate early fail early
19:29:51 <geekosaur> moplove, there's a number of competing issues here driving the types
19:30:02 <geekosaur> (1) network streams are best described by lazy ByteStrings
19:30:47 <geekosaur> (2) many other things are best described by (strict or lazy) Text --- but, in a network protocol, these are often chunks interleaved with control packets that are ByteString (octet strings)
19:31:33 <geekosaur> so Wreq is forcing you to think about things that many other languages (and, sadly, programmers and programs) don't think about and therefore get wrong more often than they get it right
19:31:52 <moplove> yeah that makes sense
19:32:40 <moplove> and the idea that Haskell makes you think about stuff other languages don't is definitely something I see commonly. I like the idea of it a lot, if it can be dealt with in a way that doesn't limit the dev
19:32:53 <moplove> I'm just missing all of the knowledge about how to use Haskell right so it doesn't limit me, haha
19:33:07 <moplove> EvanR: that sounds like a  great practice for dealing with this, thanks!
19:33:08 <geekosaur> if it could be automated somehow, there'd be a lot fewer buggy programs out there in any language
19:33:54 <EvanR> strict and lazy text is kind of a performance tradeoff
19:34:02 <EvanR> which one is better depends on use case
19:34:36 <moplove> "If you have a hammer, ever problem looks like a nail" --Someone, probably. I've been learning about lenses finally, because of Wreq, and it makes me wonder if there is a way to abstract text like lenses abstract setters and getters *shrug*
19:34:43 <orion> 18:27:17 < EvanR> orion: capability is like a number between 1 and 4 right... what use is it
19:35:21 <EvanR> moplove: sure
19:35:39 <orion> EvanR: The idea is that you select a resource (socket, connection, channel, etc) from a pool of resources based on the thread's capability number.
19:35:42 <EvanR> Data.Text.Lens
19:35:54 <moplove> it was just a casual thought in the moment
19:35:56 <orion> That way, you get an even distribution of resource utilization.
19:36:23 <EvanR> that seems like mixing up the capability with an even distribution of resources strategy
19:36:35 <EvanR> what guarantee do you have that capability is good for that
19:36:49 <geekosaur> or something like mono-traversable maybe. unfortunately that abstraction is leaky, insofar as it can lead to unexpected terrible performance or memory bloat
19:36:54 <EvanR> at least if you abstract away how the distribution is determined you can fix it later if its broken
19:43:52 <moplove> ooo, template haskell, or an extension like that, to convert between text types while still allowing for compile time type checking. You'd still need to be explicit, it would just make it more concise and readable
19:44:12 <moplove> (again, just thoughts out loud)
19:44:40 <EvanR> im not seeing how that would be better than using normal conversion functions
19:45:44 <moplove> code clutter. Obfuscates what the code is doing by forcing you to visually filter out what you're telling the computer to do vs the algorithm you're describing
19:45:53 <EvanR> what
19:45:59 <moplove> it's like foreach loops in other languages, as one example
19:46:32 <moplove> knowing that there is an iterator traversing the collection isn't important for understanding the algorithmb
19:46:38 <EvanR> bytestring and text arent at all alike, what you do to convert them is part of the algorithm
19:47:23 <moplove> well and there are times when you do need to know about the iterator, and even manipulate it
19:47:27 <moplove> and you don't use foreach loops in those contexts
19:47:29 <EvanR> what i meant was code like "convert myText" vs "[convert|myText|]" or some other thing
19:47:38 <EvanR> which puts convert there
19:48:12 <EvanR> conversion also may be a non trivial part of the performance analysis, so if its invisible somehow that would not make sense
19:48:14 <moplove> that kind of template haskell implementation of this idea wouldn't be very good, I agree
19:48:39 <moplove> templates might not be the actual way to do it, I was just pointing out extensions that essentially modify code
19:48:46 <moplove> OverloadedStrings might be a better example for this case
19:48:50 <EvanR> not seeing how "convert myText" is similar to an expanded for loop
19:50:02 <moplove> well the extreme of what we're talking about is dynamic types or automatic casting, and the reasons for having those
19:50:18 <moplove> I'm not suggesting that, since I think Haskell's strict types are a good thing
19:50:26 <moplove> but I mean that it's the same benefits
19:50:53 <EvanR> dynamic types exist because you couldnt figure out a proper type system and so resort to runtime crashing on mistakes
19:50:59 <moplove> the arguments you're putting forth against what I'm suggesting can be made against implicit casting, too
19:51:22 <moplove> :T
19:51:26 <EvanR> yeah auto conversion is bad
19:51:34 <moplove> I don't think it's that simple
19:51:43 <moplove> no doubt everyone here likes strict types
19:51:52 <moplove> but there is goodness in dynamic types and automatic conversion
19:52:02 <EvanR> the more guessing the implementation does at what it thinks you want to do, the less it can tell you you did something wrong
19:52:14 <moplove> you always have to know the cons of what you're using and deal with them. That's this whole conversation
19:52:39 <moplove> no I agree, which is why I was saying you'd still need to be explicit
19:53:10 <moplove> Haskell is a case study in how much you can deterministically infer with very little information
19:53:23 <moplove> I'm suggesting that there is a way to make converting between text types much more concise
19:53:33 <EvanR> its a single function call
19:53:40 <moplove> well, questioning if there is one, and proposing mechanisms
19:53:49 <moplove> well, sometimes a single function call. Sometimes a chain of a few
19:53:55 <moplove> but the bigger problem is that they're everywhere
19:54:05 <moplove> and there are circumstances where you shouldn't need to say, because it should be obvious
19:54:17 <moplove> this is much more like OverloadedStrings
19:54:39 <moplove> you can still run into problems with overloaded strings, and the type system will stop you, but where it can figure it out it works just great to keep things more concise
19:56:30 <EvanR> i think ids be a step backwards to move these single words into a place where you cant change them, thats a specific flaw ive struggled with in other languages
19:56:32 <moplove> the more I think about it the more I realize OverloadedStrings are exactly what I'm talking about. That extension just doesn't cover this circumstance
19:56:55 <moplove> it wouldn't necessarily work like that
19:56:56 <EvanR> polymorphic literals isnt really like auto conversion though, since you are conceptually putting a static value in
19:57:23 <EvanR> and you know its value already
19:57:27 <moplove> I agree there are differences, but the underlying idea is extremely similar
19:58:07 <moplove> either way, I'm not proposing a specific solution here. I don't know Haskell well enough to say this would necessarily work. But it's an idea that I think makes sense
19:58:23 <EvanR> a lot of auto conversion stuff is side stepped in haskell because libraries agree to use the same types, like Int instead of Natural
19:58:27 <moplove> and your objections are reasonable too, but they're specific to implementations that don't necessarily apply
19:58:42 <EvanR> so auto conversion technologies like subtyping luckily not necessary
19:58:59 <moplove> well clearly not completely unnecessary
19:59:57 <EvanR> you might also be missing opportunities for abstraction, if your lib is mixing literally every kind of text and bytestring, then you can make wrappers for your operations that do the conversion the way you want
20:00:18 <EvanR> then in the majority of your program you use a standard single type
20:01:02 <moplove> I'm not sure what you mean by wrappers here, but I do like your suggestion earlier about doing all of the conversions at the leaves and using one standard type internally
20:01:06 <moplove> which I'm doing now and is great
20:01:43 <EvanR> if the lib gives you a ByteString -> IO (), but you have lazy ByteString, then make a lazy version that uses the first version
20:01:49 <EvanR> by converting
20:02:22 <justin_beiber> hey
20:02:44 <justin_beiber> is there a reason more people don't use linear for math (vs. hmatriX)?
20:02:50 <justin_beiber> or repa
20:03:07 <moplove> oh, gotcha now. I can see how that could be useful, but might also clutter my project with wrappers. Not a bad case for templates, actually. But I think it would depend on how many functions I'd need to wrap and with how many wrappers
20:03:16 <justin_beiber> is it too slow?
20:03:23 <EvanR> you arent going to run out of functions
20:03:25 <EvanR> make more
20:03:35 <moplove> huh?
20:03:50 <moplove> EvanR: I don't understand that last comment
20:03:51 <EvanR> the idea is to abstract repeated stuff out so you can more easily read your main program
20:04:15 <moplove> yeah
20:04:58 <moplove> my point was that having lots of functions that all do almost the same thing just slightly different clutters a project
20:05:09 <moplove> that's one thing that I really like about lenses
20:05:16 <moplove> such an elegant way to handle the abstraction
20:05:19 <EvanR> having a module somewhere clutters the whole project?
20:06:00 <moplove> I didn't say whole project
20:06:15 <moplove> reading that module would be annoying, though
20:06:43 <moplove> hiding the clutter away in one place doesn't get rid of it. It's helpful, but not the same as avoiding the clutter
20:07:00 <EvanR> wrapper = original . convert
20:07:26 <moplove> eh, I think I've made my point at this point
20:08:40 <Grasshopper> Stack is failing to perform a sanity check for GHC (I'm following the user guide). http://lpaste.net/162020
20:08:52 <Grasshopper> Has anyone encountered this before?
20:09:01 <montanonic> Anyone have thoughts on making all (USD) currency values Ints that correspond to cents, vs storing them as a Numeric(12,2) type in PostgreSQL? With Persistent, it's quite a bit easier to work with Ints, but I just finished setting it up to work with Numeric, and I just realized I could encode currency as an Int instead.
20:09:20 <EvanR> theres also Centi
20:09:37 <EvanR> > 1.1 - 1
20:09:38 <lambdabot>  0.10000000000000009
20:09:41 <EvanR> > 1.1 - 1 :: Cent
20:09:42 <lambdabot>      Not in scope: type constructor or class ‚ÄòCent‚Äô
20:09:42 <lambdabot>      Perhaps you meant one of these:
20:09:42 <lambdabot>        ‚ÄòCont‚Äô (imported from Control.Monad.Cont),
20:09:43 <EvanR> > 1.1 - 1 :: Centi
20:09:45 <lambdabot>  0.10
20:10:00 <montanonic> EvanR: I didn't realize. That's nice
20:10:11 <dolio> montanonic: I think rounding to cents is not good enough.
20:10:24 <montanonic> dolio: oh yes? Why not.
20:10:24 <montanonic> ?
20:10:26 <dolio> Might depend who you talk to, though.
20:10:46 <EvanR> clearly you should use Numeric(12,4) just in case
20:11:19 <EvanR> alternatively real-valued prices
20:11:26 <montanonic> Just to clarify, I'm only using these values to store things like wages and hourly rates
20:11:30 <montanonic> EvanR: what's that?
20:11:34 <EvanR> a joke
20:11:40 <montanonic> hah
20:11:53 <dolio> In that case it might be good enough.
20:11:55 <EvanR> $3.099999999999...
20:12:01 <sm> if you needed to store the price of a stock, eg, you might want many decimal digits
20:12:11 <montanonic> sm: yeah, definitely not doing that for this app
20:12:16 <sm> ha
20:12:30 <dolio> But yeah. I think people doing investing might get mad if everything got rounded to cents all the time.
20:12:30 <sm> you're bound to want it eventually
20:12:50 <montanonic> dolio: right, I see; you need fractional prices in that case
20:12:52 <EvanR> just saying Int cents and Centi are isomorphic, and rely on picking cents. you could also use Pico for 12 decimal places
20:12:56 <dolio> Also gas stations.
20:13:10 <dolio> Actually, rounding is in the favor of gas stations.
20:13:22 <geekosaur> yeh, places that deal with cents but also need to deal with currency conversions often work in 1/10 cent
20:13:59 <montanonic> Since I'm not hoping to ever be doing high-frequency trading, I like EvanR's suggestion to use Centi <-> Int
20:14:09 <dolio> montanonic: You might not need full fractions. Maybe just a few more decimal places.
20:14:33 <justin_beiber> is there a way to evaluate javascript expressions within haskell somehow? particularly ghci
20:14:48 <justin_beiber> for instance if i have some jmacro functions I want to test
20:14:53 <EvanR> rational prices would be a possible DOS for almost irrational prices
20:15:11 <justin_beiber> without having to fire up some sort of server & open a browser.
20:15:16 <EvanR> and be inappropriate since 1/7 is silly
20:15:34 <geekosaur> do you mean ghci or ghcjsi?
20:15:44 <geekosaur> (or ghcijs or whatever it is called)
20:16:20 <justin_beiber> geekosaur no vanilla haskell
20:16:33 <geekosaur> ghc/ghci has nothing whatsoever to do with javascript, the only integration you'll get there is if you have something else that will give you a javascript prompt then you can shell out to it at the prompt with :!
20:16:35 <justin_beiber> although i'd be interested in the ghcjsi or whatever too
20:17:08 <EvanR> i see two haskell bindings to v8
20:17:09 <geekosaur> otherwise, no, the entire universe is not built atop javascript and ghc/ghci certainly is not and you can't magically get at "the javascript" that isn't there
20:17:19 <justin_beiber> geekosaur i realize that ... just wondering if someone has figured out a hack. for example, there are a few hacks to evaluate R within haskell/ghci
20:17:29 <justin_beiber> as well as maxima
20:17:36 <sm> there's gotta be a hack
20:17:41 <geekosaur> hm, if there are *useful* bindings then maybe
20:17:57 <sm> we have inline-c, inline-js anyone
20:18:00 <justin_beiber> seems like it should be feasible talk to a node repl or something
20:18:03 <geekosaur> (useful, here, means youd ont have to build up an evaluation context manually to be able to feed it arbitrary expressions for evaluation)
20:18:33 <justin_beiber> geekosaur we already have that between jmacro and julius
20:19:16 <EvanR> https://mail.haskell.org/pipermail/haskell-cafe/2012-September/103323.html
20:19:16 <geekosaur> there's also some hackery you can do with ghci's :def if you have external commands you can run, that give you limited ability to interface interactive haskell and external programs
20:21:51 <justin_beiber> EvanR huh make an http server duh
20:22:12 <justin_beiber> that's what i'm trying to avoid though, sure i could setup a minimal spock server
20:22:27 <justin_beiber> but it's not as fluid as working within the repl
20:22:51 <Rotaerk> justin_beiber, making a new pop song about haskell?
20:23:09 <Rotaerk> I don't think most people would get it
20:24:00 <dolio> Idris Elba was in here recently, too.
20:24:03 <dolio> We've got star power.
20:24:08 * hackagebot postgresql-simple 0.5.1.3 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.1.3 (LeonSmith)
20:24:48 <sm> trent reznor too
20:26:44 <justin_beiber> rotaerk can't be an artist without a "difficult" phase
20:27:26 <geekosaur> .oO {as in having difficulties, or being difficult? or both?}
20:27:35 <thoughtpolice> geekosaur: Yes.
20:29:08 * hackagebot bcrypt 0.0.9 - Haskell bindings to the bcrypt password hash  https://hackage.haskell.org/package/bcrypt-0.0.9 (AndrewMiller)
20:31:07 <justin_beiber> kanye told me my next album should be in tidal so..
20:34:35 <EvanR> so type inference has exponential complexity
20:34:50 <EvanR> how are we able to use it for anything
20:37:41 <simpson> The worst cases are relatively rare, so the typical runtime is much better.
20:39:09 * hackagebot hw-succinct 0.0.0.9 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.9 (haskellworks)
20:41:08 <justin_beiber> are there specific extensions needed for jmacro? examples don't seem to work
20:44:09 * hackagebot QLearn 0.1.0.0 - A library for fast, easy-to-use Q-learning.  https://hackage.haskell.org/package/QLearn-0.1.0.0 (dpandya)
20:52:52 <conal> nitrix: about your comment "I just can't wrap my mind around FRP and their obsession over time, so I rolled my own solution that's time-agnostic." The reasons are not complicated, and they're important/fundamental. We can discuss sometime if you're interested.
20:54:18 <shanemikel> leksah is coming along nicely
20:55:43 <nitrix> conal: Sure; I'm just think it's more natural to think in terms of "cause and effects" rather than "half the time you're that, the remainder of the time you'll inhebit, etc".
20:56:52 <nitrix> Worst case, things that happen periodically, timers and such, that are relying on time, would trigger a chain reaction, of cause & effects, but I don't think that should be the default.
20:57:16 <nitrix> It's maybe like 10% of a game? (totally arbitrary stats there)
20:57:42 <conal> nitrix: i can't tell if you're asking for a discussion of why time i FRP. i think it's from a different perspective from what you're mentioning here.
20:58:01 <conal> (why time *in* FRP)
20:58:24 <nitrix> Possible, but yeah, we could talk about it eventually when it comes to that. I have so many other areas of my game to fix up first :)
20:58:35 <nitrix> conal: cheers :P
20:58:45 <conal> nitrix: sure. just let me know if/when you're interested. take care.
21:00:30 <geekosaur> didn't the netwire tutorial used to start with a good overview of why time is so important in FRP?
21:00:53 <geekosaur> and other approaches look simpler but end up causing more problems?
21:01:06 <conal> nitrix: a teaser: the reasons (for time in FRP) correspond to what Peter Landin called "genuinely functional" or "denotative" programming.
21:03:25 <justin_beiber> weird
21:03:27 <geekosaur> and yes, the context there is that we're talking about functional programming, not a functional-ish wrapper around fundamentally procedural programming
21:03:38 <justin_beiber> haskell mode supports syntax highlighting for jmacro but not julius :(
21:03:55 <conal> geekosaur: what landin called "merely masquerading" (rather than "genuinely functional").
21:04:08 <geekosaur> yep
21:14:21 <geppettodivacin> I was playing with some simple examples of general lambda calculus over the last few days and figured I'd port some of the expressions over to Haskell.
21:14:37 <geppettodivacin> However, I was surprised to find many of them didn't work due to the infinite types restriction.
21:15:10 <geekosaur> y combinator, ho!
21:15:12 <geppettodivacin> @let y r = (\x -> r (x x)) (\x -> r (x x)) -- The recursion function, for example
21:15:13 <lambdabot>  .L.hs:178:20:
21:15:13 <lambdabot>      Occurs check: cannot construct the infinite type: r0 ~ r0 -> t
21:15:13 <lambdabot>      Expected type: r0 -> t
21:15:25 <geppettodivacin> geekosaur: y combinator?
21:15:34 <haskell177> Sometimes, if you type the type definition it's working geppettodivacin
21:15:34 <geekosaur> what you just wrote
21:15:57 <EvanR> in general not everything in untyped lambda calculus can be well-typed in typed lambda calculus
21:16:03 <geekosaur> it's a somewhat famous problem
21:16:38 <EvanR> however haskell can do it with recursive data types
21:16:41 <geppettodivacin> geekosaur: I didn't realize that's what y-combinator referred to. Now that you mention it, that makes a lot of sense.
21:17:03 <geppettodivacin> EvanR: Do you mean that new types would have to be defined for it all to work?
21:17:44 <EvanR> data L = V String | A L L | L String L
21:17:59 <EvanR> the type of any lambda expression would be L
21:18:24 <geppettodivacin> What would the strings be for?
21:18:31 <EvanR> displaying variables
21:18:41 <EvanR> and if you wanted to do beta reduction, that
21:19:45 <geppettodivacin> OK, so it wouldn't be done as functions, but instead as recursively defined types which would then be interpreted as functions? That makes sense.
21:20:20 <EvanR> its not formally clear to me that the type L (untyped lambda calculus terms) really are functions
21:20:35 <geppettodivacin> It just surprised me at first when I realized, as you pointed out above, untyped lambda calculus couldn't always be well-typed.
21:20:39 <EvanR> but thats the lore
21:20:59 <EvanR> i think this cant be well typed
21:21:20 <geekosaur> figuring out how to type that is where fix came from, iirc
21:21:23 <EvanR> the x in x x
21:21:30 <geppettodivacin> There were other functions that I had problems well-typing because the same variable had to unify to two different types at the same time.
21:21:35 <geekosaur> or, more generally, the Mu type
21:21:59 <geekosaur> (I think. it's late...)
21:22:15 <c_wraith> You can actually implement (\x -> x x) (\x -> x x) in haskell, you just need to use newtypes to absorb the infinite types.
21:22:18 <EvanR> geppettodivacin: the key is that there arent any types, its untyped. equivalently all terms have the same type
21:22:28 <c_wraith> So it's a bit noisier, since you have to wrap and unwrap terms
21:22:29 <geppettodivacin> Would it be possible to write the y combinator as elegantly as fix is written in simple lambda calculus?
21:23:23 <geppettodivacin> c_wraith: I originally tried to work with newtypes, but if I recall correctly it got messy wrapping and unwrapping the functions.
21:23:39 <c_wraith> geppettodivacin: yeah, it's messy.  But it can be done. :)
21:23:44 <EvanR> you can always make a parser for lambda terms
21:23:53 <EvanR> and avoid the wrapping and unwrapping
21:26:17 <geppettodivacin> I think the most useful thing I learned from looking into this all (other than marveling at Church-encoded values) was that I actually understand how to use fix now.
21:26:44 <c_wraith> geppettodivacin: http://okmij.org/ftp/Haskell/Fix.hs actually contains 3 different implementations of the Y combinator without value-level recursion. :)
21:27:56 <geppettodivacin> c_wraith: I was actually wondering the other way. I love how Haskell defines fix because it's simple and elegant. Can that be done in simple untyped lambda calculus?
21:29:17 <c_wraith> I doubt there's anything that clever.  Going to a system with fewer tools for expression typically results in things taking more work to express. :)
21:29:39 <EvanR> geppettodivacin: you mean with recursive let?
21:29:48 <geppettodivacin> EvanR: Yeah, that.
21:29:56 <EvanR> since LC doesnt have that... nope
21:29:59 <geppettodivacin> I figured that if it could be done, it would have been.
21:30:29 <EvanR> it doesnt have any directly recursive features
21:31:08 <geppettodivacin> What do you mean by "directly recursive?" I don't consider let to be a recursive structure.
21:31:10 <EvanR> Y combinator can do it because of the ability to make a copy of a term
21:31:25 <EvanR> recursive let is definitely recursive
21:32:05 <geppettodivacin> @src fix
21:32:06 <lambdabot> fix f = let x = f x in x
21:32:22 <EvanR> thats the faster version
21:32:32 <geppettodivacin> As opposed to?
21:32:39 <EvanR> fix f = f (fix f)
21:32:54 <geppettodivacin> Oh. I don't know if I'd ever seen that version.
21:33:03 <EvanR> thats the defining characteristic of fix ;)
21:33:43 <EvanR> its the value for which f x = x
21:34:50 <geppettodivacin> It's not immediately obvious to me why those two definitions are equivalent.
21:35:12 <EvanR> you can evaluate the let yourself
21:35:52 <EvanR> fix f = f (let x = f x in x)
21:36:12 <EvanR> then rewrite the inner part using the original definition 
21:37:51 <geppettodivacin> Hmm. Cool.
21:38:06 <EvanR> actually i dont know how i did that
21:38:48 <geppettodivacin> I just kind of trusted you on that. An f kind of appeared out of nowhere.
21:39:05 <EvanR> the f is the easy part
21:39:31 <EvanR> to eval  let x = y in z, replace all free occurrences of x in z with y
21:40:49 <geppettodivacin> But the f appeared to the left of the let.
21:41:13 <geppettodivacin> A place where it wasn't before.
21:41:19 <EvanR> well it evaluates to f something, thats what x is
21:41:55 <geppettodivacin> I can see that if x = f x, then x = f (f x), and so on down the line.
21:42:01 <EvanR> > let x = f something in x
21:42:02 <lambdabot>  Not in scope: ‚Äòsomething‚Äô
21:42:08 <EvanR> > let x = f s in x
21:42:09 <lambdabot>      No instance for (Show a0)
21:42:09 <lambdabot>        arising from a use of ‚Äòshow_M590917982551187617410187‚Äô
21:42:09 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
21:42:17 <EvanR> nevermind
21:42:47 <EvanR> x is an infinite nesting of calls to f
21:43:47 <geppettodivacin> Got it.
21:44:57 <EvanR> so is fix f, f (fix f), f (f (fix f)), ...
21:45:12 <sgronblo> Trying to learn about using Snap, found postgres simple, which led to resource-pool which made me wonder if it's the responsibility of the user of a resource to ensure the resource is restored to a valid state after it is done with it.
21:45:23 <EvanR> rewriting code based on equations is really nifty and its great haskell makes it so you can do that
21:45:38 <EvanR> because of referential transparency
21:46:20 <EvanR> sgronblo: there is the bracket pattern, which does cleanup even if an error occurs
21:46:28 <EvanR> :t bracket
21:46:30 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:47:26 <cocreature> and there is the managed package for simple stack based resource allocation and resourcet for more complex patterns
21:47:29 <EvanR> acquire resource, release resource, use resource
21:54:05 <sgronblo> EvanR: Ah right, so your withResource action should ideally be written using bracket
21:54:38 <EvanR> or something like it, Control.Exception has a few
21:55:00 <EvanR> :t finally
21:55:00 <lambdabot> IO a -> IO b -> IO a
21:55:35 <EvanR> :t forkFinally
21:55:36 <lambdabot> Not in scope: ‚ÄòforkFinally‚Äô
21:55:53 <EvanR> IO a -> (Either SomeException a -> IO ()) -> IO ThreadId
22:05:13 <orion> Is there a pre-defined operation in base which does: [1,2,3,4] -> [2,3,4,1] ?
22:06:44 <sgronblo> orion: at least it seems to be simply \a -> (tail a) ++ (head a) ?
22:07:04 <orion> Yes, that is also true.
22:09:22 <EvanR> @pl \a -> (tail a) ++ (head a)
22:09:22 <lambdabot> liftM2 (++) tail head
22:09:40 <EvanR> :t (++) <*> tail <*> head
22:09:41 <lambdabot>     Couldn't match type ‚Äò[a]‚Äô with ‚Äòa -> b‚Äô
22:09:42 <lambdabot>     Expected type: [a] -> [a] -> a -> b
22:09:42 <lambdabot>       Actual type: [a] -> [a] -> [a]
22:09:53 <EvanR> :t \(x:xs) -> xs ++ [x]
22:09:55 <lambdabot> [a] -> [a]
22:10:18 <EvanR> orion: and this will be more efficient with a zipper...
22:12:48 <haskell177> drop 1 . cycle
22:13:28 <haskell177> wait no, forget it, you still need the length somewhere
22:15:27 <cocreature> :t \x -> uncurry (flip (++)) . splitAt x
22:15:28 <lambdabot> Int -> [a] -> [a]
22:15:56 <cocreature> probably needs a mod length if you want to rotate more than once
22:24:46 <EvanR> a finite rotating sequence could be implemented behind the scenes with a cyclic list, and toList truncates
22:25:32 <EvanR> next need a continuous type which can be rotated by a real... and rotate 2pi = id
22:26:16 <cocreature> I‚Äôve always wanted to rotate my lists by 2pi
22:27:50 <EvanR> a list of the reals in well-ordered form
22:28:03 <cocreature> good lucks with that
22:28:23 <EvanR> it begins with 3
22:28:30 <EvanR> thats all i got
22:28:41 <cocreature> I am pretty sure it begins with 5 not with 3
22:28:50 <cocreature> 5 is clearly superior to 3
22:29:03 <EvanR> which is why 3 is first, its the least
22:29:06 <monochrom> I know eh? The next ones are 3.1, 3.14, 3.141, 3.1415, 3.14159...
22:34:03 <haskell177> Is there a way to use "hole" in type? I want to do something like this http://lpaste.net/162021
22:36:43 <cocreature> haskell177: you can have holes in types but you are trying to have holes for the constructor in a pattern match and that‚Äôs not possible
22:37:20 <haskell177> okay thanks cocreature 
22:37:36 <cocreature> haskell177: you can however just write a function Foo a -> (a,a) and then pattern match on the result of that
22:38:54 <haskell177> but I still need to know if it's a A or B or C or D
22:39:10 <haskell177> I only want to merge some of the cases
22:39:55 <cocreature> in the first two cases you don‚Äôt, in the last case you can then do a normal pattern match to figure out what the constructor is. whether that‚Äôs worth it depends on the number of cases you want to merge
22:43:16 <haskell177> I want to merge every case that contains an "Nothing" (or in my case, another datatype, I just used Maybe to simplify my example)
22:44:01 <paolino_> maybe you want to separate A B from C and D at definition, sometimes tagging out is not the clearest. data AB = A | B ; data ABCD a = NA a AB | C a | D a
22:44:34 <cocreature> you can probably derive traversable and then use sequenceA to get from Foo (Maybe a) to Maybe (Foo a)
22:44:58 <cocreature> the maybe will be Nothing if anything is Nothing
22:46:13 <haskell177> I think that the traversable could work in my case, thanks!
23:15:54 <moplove> I could use some lens help if anyone can help out. I have a JSON ByteString and am trying to extract specific values from a list in the JSON. Not sure how to do it
23:16:10 <moplove> I've tried several combinations of lens getters but am not sure the right combination for this
23:20:20 <EvanR> try parsing the bytestring into a data structure
23:22:34 <moplove> at what level?
23:22:43 <moplove> the array in the JSON level?
23:23:46 <moplove> I only need one value from the objects in the array. One value from each object
23:25:31 <moplove> let ls = json ^.. key "data" . values
23:25:31 <moplove> let innerVals = map (^. key "innerKey" . _String) ls
23:25:34 <moplove> ?
