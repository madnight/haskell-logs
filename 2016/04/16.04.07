00:00:00 <Job316> or snd, as the case may be
00:00:10 <jle`> comparing f x y = compare (f x) (f y)
00:00:35 <zRecursi`> sure
00:01:27 <jle`> some people like to use 'on' for some reason
00:01:39 <jle`> on g f x y = g (f x) (f y), so comparing = on compare
00:01:46 <Lokathor> for (==), you'd want: comparing snd a b == EQ
00:01:55 <jle`> i remember reading someone's justification on this
00:01:56 <Lokathor> i guess
00:02:16 <jle`> :t (==) `on` snd
00:02:17 <lambdabot> Eq a => (a1, a) -> (a1, a) -> Bool
00:02:44 <jle`> ah, yeah, people usually use on infix.  (g `on` f) x y =  f x `g` f y
00:03:02 <jle`> lambdabot actually has the cutest definition
00:03:08 <jle`> @src on
00:03:08 <lambdabot> (*) `on` f = \x y -> f x * f y
00:04:00 <jle`> so yeah, you might want (==) `on` snd
00:04:05 <Job316> oh that is clever
00:04:38 <jle`> hopefully not too clever :)
00:05:58 <zRecursi`> a bit like human language ?
00:07:39 * hackagebot markdown 0.1.14 - Convert Markdown to HTML, with XSS protection  https://hackage.haskell.org/package/markdown-0.1.14 (MichaelSnoyman)
00:07:39 * hackagebot language-c-quote 0.11.5.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.5.1 (GeoffreyMainland)
00:30:57 <isuckathaskell> hello?
00:32:27 <isuckathaskell> can someone help me
00:33:16 <liste> isuckathaskell: very likely. go ahead with your question
00:33:41 <isuckathaskell> okay, its kind of a complicated one
00:33:57 <isuckathaskell> since its a school assignment so you'll need the code
00:35:17 <liste> @lpaste -- isuckathaskell paste your code here
00:35:18 <lambdabot> Haskell pastebin: http://lpaste.net/
00:37:49 * hackagebot read-env-var 0.1.0.0 - Functions for safely reading environment variables.  https://hackage.haskell.org/package/read-env-var-0.1.0.0 (cdepillabout)
00:37:59 <isuckathaskell> ok, http://lpaste.net/3878706586159415296
00:38:51 <isuckathaskell> basically i have to build langtons ant, and the issue im having is i dont know how to refer to the cell the ant is on, i need to alter the state of the cell but i can't figure out how to do that
00:41:59 <MichaelBurge> isuckathaskell: If you have a value of type SquareWorld, then you have a value of type Ant via the 'theAnt' function. If you have an 'Ant', then - your code doesn't show the definition of Ant - but I assume it has coordinates.
00:42:29 <isuckathaskell> it does yeah
00:42:29 <MichaelBurge> isuckathaskell: Probably you want to write a function 'SquareWorld -> SquareWorld' that processes one iteration of the process. Then, you alter the state by producing a new world with the updated values.
00:42:57 <MichaelBurge> Within such a function, you'll have the coordinates you need and can build a new SquareWorld with the correct values
00:43:30 <isuckathaskell> but i dont know how to refer to the cell whose values i wanna change
00:44:34 <MichaelBurge> isuckathaskell: It looks like you should use 'findCell' with the coordinates of your ant and your SquareWorld value, in order to get the cell that the ant is on
00:46:25 <isuckathaskell> that was my thinking, so at the bottom in the function transitionWorld, where it says theWorld, i need to change that value to the cell i wanna change right?
00:47:10 <isuckathaskell> but since findCell returns a maybe cell, i need to pass it through the deMaybeCell function, but i cant figure out how to get that to work syntactically without it giving me errors
00:50:16 <MichaelBurge> isuckathaskell: If you successfully construct a value of type 'Maybe Cell', then you should just be able to call deMaybeCell on it. Try: 'let mCell = findCell .. :: Maybe Cell in deMaybeCell mCell'
00:51:31 <isuckathaskell> with the ants coords in the ..?
00:51:35 <MichaelBurge> yeah
00:52:26 <isuckathaskell> parse error on input ‘in’
00:52:50 * hackagebot tellbot 0.6.0.12 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.12 (DimitriSabadie)
00:53:07 <MichaelBurge> isuckathaskell: Can you repaste the code?
00:53:16 <isuckathaskell> sure
00:54:40 <isuckatHaskell> woops
00:54:46 <isuckatHaskell> im back, sorry first time on freenode
00:56:10 <isuckatHaskell> http://lpaste.net/3878706586159415296
00:56:13 <isuckatHaskell> thats my code now
00:56:41 <isuckatHaskell> only stuff i changed is down the bottom in the transitionWorld function
00:58:08 <MichaelBurge> isuckatHaskell: I think that SquareWorld doesn't have an mCell value
00:59:04 <isuckatHaskell> ??
00:59:09 <MichaelBurge> isuckatHaskell: You'll probably want to write an updateWorld method of type 'Cell -> CellState -> SquareWorld -> SquareWorld' function
00:59:31 <MichaelBurge> the first argument is the cell to update, the second is its new value, the third is the world, and the result is the new world
01:00:47 <isuckatHaskell> but i dont know how to change the world
01:00:50 <MichaelBurge> isuckatHaskell: Then transitionWorld would call out to updateWorld for each cell in the SquareWorlds list of cells.
01:01:49 <MichaelBurge> isuckatHaskell: You don't change the world, you return a new world with that one cell changed.
01:04:04 <isuckatHaskell> ok lemme update my pastebin again
01:04:41 <isuckatHaskell> http://lpaste.net/3878706586159415296
01:05:12 <cariveri> Hi everyone. whats the best combo of linux distro and haskell gui environment? assume I can start from scratch.
01:06:59 <isuckatHaskell> im just using sublime text and a command terminal for haskell....
01:07:12 <rydgel> haskell with Stack is pretty much alright with all Linux distro
01:07:17 <cocreature> cariveri: what do you mean by “haskell gui environment”?
01:08:33 <ntnt> I have "possiblyFoo :: Either String Foo" -- now, is there a way to define a *GLOBAL* "foo :: Foo" where (1) on running the program, it checks to see if it's an Either String or an actual Foo, and if it's an "Either String", then it prints the err msgs and quits. Is there a way to do this via unsafePerformIO ?
01:09:26 <cariveri> cocreature: Id like to create a gui app using haskell and I ran into a problem last time. I used gtk2hs and gtk2 was abbandoned on ubuntu which created problemes getting it to run again.
01:09:44 <bhiliyam> > 2 + 3
01:09:46 <lambdabot>  5
01:10:09 <cocreature> cariveri: no idea about that I don’t write guis, but rydgel is right that stack + any linux distro should be fine
01:10:14 <cariveri> cocreature: so assuming I can start from scratch, there is perhaps a better combo for doing this. what linux and what gui library would you prefer? I guess there was progress.
01:11:09 <MichaelBurge> cariveri: Have you considered using something like Electron, and then using one of the Haskell libraries that emits Javascript?
01:12:33 <rydgel> cariveri: gui library for what? Linux WM? Haskell IDE?
01:13:05 <rydgel> cariveri: or GUI lib for writing Haskell's app?
01:13:36 <cariveri> rydgel: for haskells apps yes.
01:14:27 <cariveri> rydgel: I used gtk2hs. but it seems developement was stopped since ubutnu doesnt support gtk2 anymore.
01:15:02 <bernalex> I wonder, could you write fac 0 = 1; fac (n+1) = (n+1) * fac n; in haskell, back when n+1 matching was allowed?
01:15:14 <bernalex> if so I kind of miss it, despite never having used it.
01:15:34 <cocreature> cariveri: are you sure about that? there is so much software out there still depending on gtk2 that I can’t imagine this to be true
01:16:08 <cariveri> cocreature: what linux idstro do you use?
01:16:11 <srhb> bernalex: Isn't there still a language extension for n+k patterns?
01:16:20 <cocreature> cariveri: archlinux
01:16:26 <bernalex> srhb: I don't think so, but I'm not sure.
01:16:33 <cocreature> nope n+k patterns is dead
01:16:48 <srhb> bernalex: :set -XNPlusKPatterns
01:16:54 <srhb> At least my ghci doesn't complain.
01:16:58 <bernalex> I just checked btw, and you could indeed write fac like I proposed.
01:17:16 <bernalex> srhb: I think they were chucked out of haskell 2010, but I guess there's an extension for them now then. that's good.
01:17:17 <cariveri> cocreature: then of course that is not on your radar, because on archlunx you can do anything like anyways. but I decided that arch is not yet the right distro for me though.
01:17:31 <srhb> bernalex: Works fine here, indeed.
01:18:12 <bernalex> srhb: yeah works fine. neat.
01:18:18 <rydgel> cariveri: I'm using Arch too. And gtk2hs is still being developed, I see commit on the project a few fays ago
01:18:28 <bernalex> > let fac 0 = 1; fac (n+1) = (n+1) * fac n
01:18:30 <lambdabot>  <hint>:1:21: Parse error in pattern: n + 1
01:18:31 <bernalex> @let fac 0 = 1; fac (n+1) = (n+1) * fac n
01:18:31 <lambdabot>  Parse failed: NPlusKPatterns is not enabled
01:18:34 <bernalex> ah
01:18:36 <bernalex> figured.
01:18:44 <cocreature> cariveri: there is a gtk2 package for ubuntu https://launchpad.net/ubuntu/+source/gtk+2.0 so I’m not sure what you mean by it not being supported anymore
01:21:25 <rydgel> there is also qt if you don't like Gtk. cariveri: What kind of app do you want to do?
01:22:10 <cariveri> rydgel: it is simple. I need menues boxes and string input/outputs . 
01:22:11 <cocreature> bernalex: you can do something similar using viewpatterns http://lpaste.net/159005
01:22:48 <bernalex> cocreature: that's not nearly as elegant though.
01:22:53 <cocreature> yeah
01:23:04 <bernalex> but yeah there are some neat tricks with viewpatterns
01:23:13 <bernalex> thanks for the paste!
01:25:13 <rydgel> cariveri: Gtk or Qt will works fine under any Linux you want, as long as the Gtk or Qt is installed (which is probably already the case with big graphical distros like Ubuntu)
01:26:04 <cariveri> rydgel: ok. perhaps its jsut that I am stuck on an older ubuntu distro that I cannot upgrade anymore.
01:27:04 <rydgel> cariveri: it's fine, if you use Stack you can have the last up-to-date GHC/Haskell and packages
01:27:11 <rydgel> cariveri: even on old distros
01:27:44 <rydgel> cariveri: you will basically don't use your Linux package manager to install your Haskell env, you will let Stack do it for you
01:28:37 <cariveri> Stack? hmm. it is like cabal or additional?
01:29:50 <cdtdev> Stack is a really cool tool.
01:30:04 <cdtdev> It works with cabal, but manages a lot of stuff for you to help things from breaking.
01:30:04 <rydgel> cariveri: It's something similar to Cabal yes, actually it uses Cabal under the hood but simplify everything
01:30:33 <cdtdev> For example, Stack takes care of "Cabal hell" for you.
01:31:00 <cariveri> rydgel: ok. so I would reinstall ubuntu and then Stack then haskell then gtk2hs?
01:31:05 <rydgel> Stack changed my life. I used Cabal for years and stuff and was used to its problem. But now I can't go back. I don't see myself not using Stack anymore.
01:31:34 <cdtdev> I would honestly like to see something more like Cargo for Haskell.
01:31:41 <cdtdev> Stack is close, but not quite as nice.
01:31:42 <Athas> I wish equational-reasoning was on Stack, though.
01:32:51 <Athas> Actually, now I'm curious, how does Stack with with multiple unreleased packages that depend on each other?  In Cabal it Just Works, because they all install to the same database, so your just 'cabal install' them manually one after another.
01:32:52 <rydgel> cariveri: basically yes. Install Linux, install Stack. Make a new project with Stack and add gtk2hs or other dependencies in your new generated cabal file. Then Stack will automaticcaly install what's missing even the correct GHC compiler and so on.
01:33:56 <rydgel> You just have to put ~/.stack/bin or something similar to your global $PATH and you are good to go. Stack is well documented
01:38:48 <cariveri> rydgel: developement is one thing. now how about running. is gtk2hs good to make sure that the app runs on old and new ubuntu distros?
01:39:47 <rydgel> cariveri: I think so. Gtk was here for years. And huge amounts of Linux apps use that.
01:40:31 <cariveri> rydgel: if possible Id like to avoid that I have to release frequently new version just because the newer distros have changed things. but I guess it is not possible, is it?
01:41:16 <Athas> You never know what might change.  But Gtk is probably among the stablest libraries.
01:41:23 <Athas> Certainly the stablest non-dead GUI library.
01:42:00 <cariveri> Athas: ok. still seems to be a good choice then :) 
01:42:42 <rydgel> cariveri: Gtk is very stable. IIRC when Gtk switched from 1.0 to 2.0, that needed a bit of work. But I don't see that happening again soon.
01:43:46 <rydgel> And IIRC you were still able to run old Gtk (1.0) apps on new Linux just by installing the old Gtk lib that was still here.
01:44:03 <rydgel> I'm not an expert in GUIs tho :)
01:45:25 <quicksilver> wxWidgets is pretty stable is it not?
01:45:37 <rydgel> quicksilver: it is
01:46:09 <rydgel> and it's still in development too
01:48:04 <cariveri> ok guys. thanks for advice.
01:48:20 <rydgel> Since your project is really simple, I would say it's all about taste. You might want to see how to do Gtok, Wx or Qt in Haskell and choose what you like most
01:48:31 <rydgel> Gtk*
01:53:06 * hackagebot diagrams-wx 0.1.1.0 - Backend for rendering diagrams in wxWidgets  https://hackage.haskell.org/package/diagrams-wx-0.1.1.0 (MichaelSmith)
01:54:16 <quicksilver> as it happens the 3 libraries have rather different haskells tyles
01:54:30 <quicksilver> just the authors chose different approachs to wrapping classes and attributes and stuff
01:54:34 <quicksilver> so it's qiute interesting to try them all
02:03:38 <nineonine> can i make a type that has a list of tuples, but the snd of tuple is polymorphic ?
02:03:42 <nineonine> like 
02:04:01 <nineonine> type Params = (Show a) => [(Text, a)]
02:05:25 <pavonia> You can wrap it into a new datatype, but you probably don't want to
02:06:24 <liste> nineonine: what would be the benefit of that compared to [(Text, String)] ?
02:07:13 <nineonine> sometimes it can be Int instead of String
02:07:41 <anohigisavay> hi
02:08:13 <quicksilver> nineonine: but what would you do with it?
02:08:25 <anohigisavay> is an embedded language implemented with a custom quasiquotation (hamlet in yesod, for example) an Internal DSL or External DSL?
02:08:28 <quicksilver> (Show a) => [(Text, a)] suggests all you can do is 'show' it
02:08:33 <quicksilver> and if all you can do is show it
02:08:36 <quicksilver> when why not just show it
02:08:43 <quicksilver> and get [(Text,String)]
02:08:55 <quicksilver> (I am just explaining liste's remark in more detail)
02:09:32 <nineonine> i got it
02:10:05 <nineonine> well i was just curious if it is possible to create this heterogeneous data structure
02:10:19 <quicksilver> it is, yes.
02:10:42 <nineonine> what should be done for that ?
02:10:55 <cocreature> there are two ways to do it
02:10:57 <quicksilver> data Params = Show a => MkParams Text a
02:11:02 <cocreature> 1. you wrap your type in an existential
02:11:04 <quicksilver> and then use [Params]
02:11:11 <cocreature> 2. you write a custom hlist type that is parametrized by a list of types
02:11:20 <quicksilver> but it's actually no better (in fact, no different) from [(Text,String)]
02:12:16 <quicksilver> it is perhaps interesting to read https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ about existentials
02:12:29 <quicksilver> although I haven't read it for a few years and I forget exactly what he said :)
02:12:37 <nineonine> great ! thanks for the read
02:14:51 <trollando> hi guys
02:16:17 <nineonine> but can you do it with type ?
02:16:20 <nineonine> not with data 
02:16:21 <nineonine> ?
02:16:27 <quicksilver> no
02:16:35 <quicksilver> the type checker needs explicit constructors
02:16:35 <nineonine> :\
02:16:48 <quicksilver> otherwise the inference is not feasible
02:16:52 <quicksilver> I never use 'type' personally
02:16:56 <quicksilver> always data or newtyp
02:17:13 <nineonine> what are the benefits of doing that way ?
02:17:43 <cocreature> you actually get new types
02:18:11 <quicksilver> what are the benefits of using 'type' ?
02:18:17 <quicksilver> none, IMO :)
02:18:21 <nineonine> :))
02:18:25 <tdammers> quicksilver: readability, arguably
02:18:42 <quicksilver> tdammers: and occasionally :type will not inline your synonyms
02:18:45 <quicksilver> but then other times it will
02:18:46 <rydgel> `type` is useful. I like to do simple constraints
02:18:49 <quicksilver> unpredictability ftw.
02:19:05 <cocreature> yeah constraints are a nice usecase
02:19:05 <quicksilver> rydgel: type was useful for constraint synonyms before the new constraint stuff
02:19:07 <tdammers> although in my experience, 'type' reduces readability, because now I have to look up the actual type manually
02:19:14 <rydgel> quicksilver: oh.
02:19:18 <rydgel> quicksilver: tell me
02:19:28 <quicksilver> well constraints are a proper kind now
02:19:30 <tdammers> [Pair
02:19:33 <tdammers> oops
02:19:43 <tdammers> [Pair] vs. [(Text, Value)]
02:19:47 <tdammers> I prefer the latter
02:20:07 <quicksilver> so you can actually right type Stringy a = (Read a, Show a)
02:20:10 <quicksilver> write
02:20:19 <quicksilver> (example from GHC manual page https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/constraint-kind.html)
02:20:24 <aarvar> aren't constraints an example of where you *don't* want to use type aliases?
02:20:58 <aarvar> class (Read a, Show a) => ReadShow a; instance (Read a, Show a) => ReadShow a
02:25:54 <rydgel> quicksilver: thanks
02:32:58 <fr33domlover> hmmm should I put monad transformer modules under Control.Monad.Trans or under the specific category they are related to? e.g. Network.MyProtocol.Monad
03:11:01 <syahdeini_> Hi all. 
03:12:56 <martinvlk> ...just ask your question ;-)
03:14:56 <syahdeini_> I don't have a question,  I'm currently learning rails, and I will learn more on web security
03:18:29 <pantsman-> hi syahdeini_ 
03:45:49 <maerwald> is there a common way to structure two versions of a module which differ in types and import but not really in terms of implementation? E.g. one module uses String, the other ByteString
03:46:09 <maerwald> coming up with a class changes the API, which is a no-go
03:48:40 <Jinxit> so you can't do it polymorphically?
03:49:13 <maerwald> no, it changes the api
03:49:36 <Jinxit> even if the old use is still valid?
03:49:43 <maerwald> wat?
03:50:19 <Jinxit> as in, changing to a more generic version shouldn't invalidate any old program
03:50:29 <Jinxit> but that might still be verboten
03:51:20 <maerwald> it's not an option and is a mess to implement 
03:52:05 <liste> aren't String and ByteString really semantically different anyway
03:52:15 <maerwald> yes
03:53:08 <maerwald> which means you'll end up with orphan instances, broken documentation and heavy type aliases
03:53:15 * hackagebot servant 0.6.1 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.6.1 (SoenkeHahn)
03:54:35 <tdammers> String: list of characters. ByteString: array of bytes.
03:54:41 <tdammers> totally not the same in any regard
03:54:48 <tdammers> also, the "String" part in "ByteString" is a lie
03:55:03 <maerwald> I know. It's still valid for this use case
03:55:12 <tdammers> I don't doubt that
03:55:37 <tdammers> just like both ByteString and Aeson.Value are valid and useful representations of JSON data
03:55:42 <maerwald> e.g. modules like System.Posix.Files have two versions: one is broken and uses String as output path names and the other is correct and uses ByteString
03:56:00 <maerwald> the problem is other modules like hinotify only work with String, so I want to convert them
03:56:04 <tdammers> filenames are an unsolvable problem in that regard :D
03:56:13 <maerwald> ByteString works correctly
03:56:26 <tdammers> on POSIX at least, yes
03:56:43 <maerwald> yes, I think System.Posix.Files is about POSIX :P
03:56:47 <tdammers> lol yeah
03:57:22 <maerwald> converting libraries like hinotify is easy, but the maintainer will probably say no if I copy paste the module and convert it to bytestrin
03:57:28 <maerwald> because then he'll have to maintain two files
03:57:44 <tdammers> the clean solution would be to make the module polymorphic somehow
03:57:51 <maerwald> again, already tried
03:57:56 <maerwald> doesn't work cleanly and changes api
03:58:03 <tdammers> yeah, hm
03:58:15 * hackagebot servant-server 0.6.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.6.1 (SoenkeHahn)
03:58:17 * hackagebot servant-client 0.6.1 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.6.1 (SoenkeHahn)
03:58:20 * hackagebot servant-cassava 0.6.1 - Servant CSV content-type for cassava  https://hackage.haskell.org/package/servant-cassava-0.6.1 (SoenkeHahn)
03:58:24 <maerwald> especially since the module has a data type that also includes String
03:58:29 <maerwald> if it was only functions... it would be easier
03:58:45 <tdammers> hmm, can the data type be made polymorphic?
03:58:54 <maerwald> that all sucks
03:59:11 <tdammers> it does
03:59:12 <maerwald> I was more thinking along the line of TH maybe?
03:59:19 <maerwald> or some preprocessor hack
03:59:21 <maerwald> I dunno
04:00:08 <maerwald> C macros for the rescue!
04:01:00 <tdammers> well, if ByteString is the correct type, then you could change all those Strings to ByteString, and use some sort of convenience library to make the conversion painless
04:01:08 <tdammers> e.g. string-convert (shameless plug)
04:01:31 <maerwald> that'll break even more API :P
04:01:51 <maerwald> I'm trying not to piss off the maintainer ;)
04:02:20 <tdammers> you could copy the String version to .ByteString, change all strings to bytestrings, and then replace the implementations of everything in the original module with wrapped calls to the bytestring versions
04:02:35 <tdammers> compatibility maintained, correctness achieved
04:02:47 <tdammers> next step would be tasteful deprecation
04:03:16 * hackagebot servant-docs 0.6.1 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.6.1 (SoenkeHahn)
04:03:18 * hackagebot servant-foreign 0.6.1 - Helpers for generating clients for servant APIs in any programming language  https://hackage.haskell.org/package/servant-foreign-0.6.1 (SoenkeHahn)
04:03:20 * hackagebot servant-js 0.6.1 - Automatically derive javascript functions to query servant webservices.  https://hackage.haskell.org/package/servant-js-0.6.1 (SoenkeHahn)
04:03:22 * hackagebot servant-blaze 0.6.1 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.6.1 (SoenkeHahn)
04:03:23 <maerwald> that could work
04:03:47 <raduom> In trifecta how can i tell it what i expect to be treated as whitespace so i don't have to intermix skipWhitespace between all the parsers?
04:06:43 <maerwald> also find it funny how every library uses getFileSystemEncoding for String based paths, although the documentation says things like "On Windows, this encoding *should not* be used if possible" and "This TextEncoding is used to decode and encode command line arguments and environment variables on non-Windows platforms."
04:08:16 * hackagebot servant-lucid 0.6.1 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.6.1 (SoenkeHahn)
04:08:18 * hackagebot servant-mock 0.6.1 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.6.1 (SoenkeHahn)
04:31:27 <maerwald> tdammers: wrapping is not so easy either since the return types I get are not the same :/
04:32:22 <maerwald> now I need conversion functions not just for ByteString -> String, but for the internal types as well
04:40:48 <Walther> hum. weird errors with http://lpaste.net/4980028237708001280
04:41:00 <Walther>     No instance for (Show t0) arising from a use of ‘show’
04:41:08 <Walther>     In the second argument of ‘($)’, namely ‘show $ sort []’
04:44:06 <bergmark> Walther: doesn't the error say that the type variable is ambiguous?
04:44:46 <Walther> implying i should manually add a type annotation to the function?
04:45:33 <bergmark> right
04:46:29 <Walther> added sort :: Ord thing => [thing] -> [thing] and still getting the ambiguity error
04:46:46 <Walther> but what is the ambiguity on an empty list anyway ._.
04:47:08 <latro`a> you can't really define a polymorphic show instance
04:47:28 <latro`a> try replacing the [] in main with ([] :: [Double])
04:47:57 <bergmark> Walther: the compiler doesn't know that the list is empty
04:47:59 <latro`a> (also, there *is* an ambiguity even in real practice, because the ordinary empty list is [] but the empty string is shown as "")
04:53:22 <Walther> bergmark: that would kinda make the entire function only return doubles?
04:56:32 <srhb> Walther: Yes. But there's no instance Show for any type a, and the Show instance for lists of a relies on the Show instance for a
04:56:54 <bergmark> Walther: the problem occurs because both show, sort, and the list literal are polymorphic, if you add a type signature to just one of them there is no ambiguity
04:56:59 <Walther> srhb: hm, so the "bug" in use like this isn't a bug on sort functions end
04:57:22 <srhb> Walther: No, if you want your function to show something, you must demand that that something is Showable.
04:57:30 <Walther> right
04:57:40 <Walther> deriving Show
04:57:59 <Walther> erm, deriving something
04:58:17 <srhb> Walther: In this case you just need to specify what the type is, really.
04:58:18 * hackagebot werewolf 0.5.3.0 - A game engine for playing werewolf within a chat client  https://hackage.haskell.org/package/werewolf-0.5.3.0 (hjwylde)
04:59:02 <Walther> well darn. Because as you can probably guess from the wording, this is mostly intended as a pretty piece of very readable code
04:59:14 <Walther> "let me sort things out for you, tiny or big" as the comment
04:59:29 <srhb> Walther: Woah, what's with the whitespace at the end of the lines? :P
04:59:38 <Walther> oops, pasted from vim :)
05:00:43 <srhb> Walther: You could use a defaulting rule, but I think that adding the annotation at the last line is just fine
05:01:03 <srhb> Walther: ie print . sort $ ([] :: [Int]) or something like that
05:01:38 <Walther> srhb: the test cases obviously don't need to be in the actual presented snippet (and image screenshot of highlighted code)
05:01:45 <srhb> Walther: Or bind emptyListOfInt = [] :: [Int]
05:01:47 <Walther> as long as the code snippet can be considered "working"
05:02:14 <srhb> Well it's obviously not working unless you choose a type there :-)
05:02:28 <Walther> well, sort is working for an empty list, showing it isn't :P
05:02:47 <srhb> Sure.
05:02:53 <srhb> Showing does too.
05:02:58 <Walther>     putStrLn $ show $ sort ([] :: [Int]) and the test case works
05:03:01 <srhb> (as long as you pick the type of the empty list)
05:03:05 <Walther> yeah
05:03:37 <Walther> and i think not manually choosing the type for returning might be better
05:03:54 <Walther> if someone e.g. creates their own data type that implements Ord
05:05:56 <srhb> Walther: Uhm, I don't think anyone suggested choosing a concrete type for sort
05:06:32 <srhb> Walther: Aside from ORd a => [a] -> [a]
05:06:48 <Walther> srhb: i think someone suggested adding a concrete type to the return value on empty list
05:07:05 <Walther> but yeah, choosing the type of empty list in the test case is enough
05:07:08 <Walther> thanks for the help!
05:07:19 <pyrtsa> Walther: FWIW, your code works for me without problems. GHC correctly infers `sort` to have type `Ord a => [a] -> [a]` and even `show . sort []` works correctly without annotating anything.
05:07:35 <pyrtsa> (Disclaimer: this was in GHCi)
05:07:56 <Walther> iirc GHCi has magic powder in stuff related to show and print and such
05:08:01 <maerwald> ghci has different defaults
05:08:03 <Walther> i used runhaskell
05:08:05 <srhb> Walther: It has extended defaulting, yes.
05:08:09 <pyrtsa> Right.
05:08:48 <sigrlami> Hi, everyone! I'm having trouble running yesod app in ghci, using stack, can't load my modules
05:08:53 <sigrlami> I'm using
05:09:00 <sigrlami> stack ghci --ghci-options "-XTemplateHaskell -XTypeFamilies -XDeriveDataTypeable -XOverloadedStrings -XGADTs -XMultiParamTypeClasses -XQuasiQuotes -XCPP" Import.hs
05:09:10 <sigrlami> to load needed extension and reload everything from Import,
05:09:29 <sigrlami> but getting "No local directories found as children of Import.hs" on this
05:09:53 <sigrlami> or if without Import.hs, getting bunch of not found standard modules, like Application, setc
05:10:06 <sigrlami> any suggestion how to fix this?
05:10:36 <bergmark> sigrlami: specify the package name instead of a module name
05:12:59 <ziman> @djinn Monad m => (a -> m b) -> m (a -> b)
05:12:59 <lambdabot> -- f cannot be realized.
05:13:04 <sigrlami> bergmark: awesome! thanks! that was quick, indeed working fine
05:13:21 <akegalj> hey. We are planning on adding GUI to our application. It is a bussiness application (ie, similar to bitcoin-qt client), with few tabs, table with some results, user menu, buttons. We were considering not doing this in web/browser but as a standalone UI. We can do it in some low-level bindings to gtk/qt/wxWigets but we would prefer FRP (if it makes sense doing FRP for this case). What would you suggest?
05:14:13 <maerwald> last I checked FRP is still very early development overall
05:14:43 <akegalj> maerwald: hm, we were using elm with good success
05:14:58 <maerwald> elm is not a non-browser UI 
05:14:59 <tdammers> akegalj: elm isn't frp
05:15:23 <akegalj> maerwald, tdammers: oh, ok. I thought it has something to do with frp
05:15:27 <tdammers> elm is reactive, and elm is a pure functional language
05:15:29 <maerwald> :D
05:15:31 <tdammers> so it's definitely related
05:15:45 <tdammers> but the thing it lacksto qualify as FRP is behaviors
05:16:10 <tdammers> elm's reactive model is a discrete one that models time as just another kind of discrete even
05:16:13 <akegalj> tdammers: probably I don't know what frp is, maybe haskell has some reactive library then?
05:16:14 <tdammers> event, even
05:16:22 <tdammers> yeah, there's a few of them
05:16:43 <maerwald> but I'm not sure you want to use that in production
05:16:47 <akegalj> tdammers: like sodium, reactive-banana
05:16:59 <akegalj> maerwald: ok, thats a good note
05:17:00 <tdammers> yep
05:17:17 <tdammers> the nasty problem with FRP, IIRC, is to get the performance characteristics right
05:17:37 <maerwald> straight gtk bindings are relatively easy to work with
05:18:01 <maerwald> and you don't get odd API breakages... just the stuff upstream messes up :D
05:18:18 * hackagebot clash-prelude 0.10.7 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.7 (ChristiaanBaaij)
05:18:25 <akegalj> tdammers: yes, I saw some discussions on garmage collection problems 
05:19:11 <akegalj> maerwald: yes, I was working with gtk2hs before, but we were thinking maybe trying something new
05:19:23 <akegalj> maerwald: do you know how good are qt bindings ?
05:19:33 <maerwald> never tried them but I hear people like em
05:20:38 <mniip> hmm
05:21:43 <akegalj> tdammers, maerwald thanks :)
05:21:57 <maerwald> I'd also consider the fact that not every haskell programmer is fond of FRP, so it may increase maintenance cost. It's a relatively new technology
05:22:48 <rydgel> Yeah just like Haskell itself
05:22:54 <maerwald> nah
05:23:02 <tdammers> haskell isn't very new
05:23:03 <maerwald> functional programming is decades old
05:23:13 <akegalj> maerwald: yes, that's a good point. On the other side this should be pritty small/simple ui so it should be easily replaced
05:23:18 <ggVGc> question, is haskell good for getting girls?
05:23:23 <maerwald> lambda calculus almost a hundred years
05:23:24 <rydgel> yes
05:23:44 <maerwald> FRP is from ~1997, at least wiki says that
05:23:49 <maerwald> that's pretty new
05:25:02 <tdammers> ggVGc: the answer is yes, Haskell can do that
05:25:03 <mniip> I just thought of something
05:25:21 <mniip> it is, in theory, possible to make a Traversable ((->) e)
05:25:32 <mniip> mathematically, it can make sense
05:25:32 <maerwald> ggVGc: I tried, I'd say no, but maybe it was just me
05:25:41 <ggVGc> I'm writing a sequencer, if I make some sweet tunes and become famous, haskell will directly supported getting interest from girls
05:25:46 <ggVGc> however, I am already married, so..
05:26:15 <srhb> And let's not bring that "get girls" stereotyping into the channel anyways.
05:26:34 <maerwald> it's not strictly typed, yeah
05:26:44 <rydgel> ggVGc: that works, she asks from time to time if I "do monads". I think she likes the word.
05:27:04 <ggVGc> I'm still trying to get it right when to use mapM
05:27:05 <maerwald> take it to #haskell-offtopic :P
05:27:11 <ggVGc> it only works out half the time I try
05:28:20 <ggVGc> for example, I thought I could use mapM here, https://gist.github.com/129c56a7f7cb7a2619d817a270e1889e
05:28:33 <ggVGc> how do I rewrite that to not have "maybe Nothing ..."
05:28:54 <maerwald> :t for_
05:28:55 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
05:29:33 <bergmark> ggVGc: i think hlint would tell you
05:29:49 <mniip> implementation-wise, we can have something like
05:29:51 <mniip> :t fmap Data.Functor.Rep.index . sequenceA . Data.Functor.Rep.tabulate
05:29:52 <lambdabot> (Applicative f, Traversable f1, Data.Functor.Rep.Representable f1) => (Data.Functor.Rep.Rep f1 -> f a) -> f (Data.Functor.Rep.Rep f1 -> a)
05:32:24 <ggVGc> bergmark: nope..
05:32:30 <ggVGc> maybe it should jus tbe like that
05:32:46 <ggVGc> but it seems like it could be generalised, since it's a chained maybe
05:32:50 <mniip> instance (Traversable f, Representable f) => Traversable ((->) (Rep f))
05:33:13 <maerwald> ggVGc: it has the same type signature as (=<<)
05:33:29 <maerwald> :t maybe Nothing
05:33:30 <lambdabot> (a -> Maybe a1) -> Maybe a -> Maybe a1
05:33:33 <mniip> and we can basically have a Rep for any bounded type
05:33:34 <maerwald> :t (=<<)
05:33:35 <lambdabot> Monad m => (a -> m b) -> m a -> m b
05:34:11 <bergmark> :t [maybe Nothing, (=<<), mapM_]
05:34:13 <lambdabot> [(a -> Maybe ()) -> Maybe a -> Maybe ()]
05:34:43 <maerwald> I don't see the problem 
05:34:49 <maerwald> does it not typecheck?
05:36:19 <maerwald> also, the use of & ... meh :o
05:38:04 <ggVGc> maerwald: ah, nice, thanks
05:38:16 <ggVGc> I should get more into using the monadic operators
05:40:00 <martin___> I'd like the "read" operation to return a Int in ghci. 
05:40:13 <martin___> So I type :t (read :: Int)
05:40:15 <mniip> restrict its type
05:40:27 <mniip> not like that
05:40:35 <mniip> :t read
05:40:36 <lambdabot> Read a => String -> a
05:40:46 <mniip> either you restrict it with (read :: String -> Int)
05:40:52 <mniip> or with (read something :: Int)
05:40:55 <martin___> Aha
05:41:08 <martin___> :t read :: String -> Int
05:41:09 <lambdabot> String -> Int
05:41:31 <martin___> Thank you mniip! :)
05:48:08 <Athas> Is there a way to do array programming in Haskell that approaches the convenience of using lists?
05:48:19 * hackagebot stack 1.0.4.3 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.0.4.3 (borsboom)
05:48:56 <Athas> Using lists I can express the algorithms very nicely, but there are some invariants (like regularity) that are not guaranteed, and performance is abysmal.  Performance is not my main goal, but it would be nice if it were a little bit faster...
05:51:39 <srhb> Athas: Are you talking about pattern matching? If so, view patterns and pattern synonyms might be helpful.
06:02:07 <Athas> srhb: no, not really.  I'm mostly talking about things like multidimensional arrays.
06:02:24 <Athas> Being able to provide one index to a two-dimensional array and getting a one-dimensional array back.
06:03:27 <srhb> I guess I don't find that particularly convenient for lists either..
06:07:09 <Athas> You can map a list.  I also want to map a two-dimensional array, passing a one-dimensional array to the function.
06:08:49 <ggole> Sounds like you want APL.
06:09:39 <srhb> Athas: LIke map over the dimensions?
06:16:57 <trollando> Is Data.List.Split a good lib ?
06:20:53 <Athas> ggole: actually, APL is inconvenient too.
06:21:02 <Athas> srhb: well, over the outer dimension.
06:21:08 <mjrosenb> APL... the language?
06:21:21 <Athas> Yes.
06:21:43 <Athas> If you have a multidimensional array in APL, it is kind of inconvenient to only map the outer dimension.
06:21:51 <Athas> It really wants to operate on the bottommost level.
06:23:20 * hackagebot leancheck 0.3.0 - Cholesterol-free property-based testing  https://hackage.haskell.org/package/leancheck-0.3.0 (rudymatela)
06:25:12 <quxbam> Is GHC.Generic faster than syb?  Is uniplate from derive-generic faster than the original uniplate?
06:25:43 <quxbam> deriving data and typeable explodes my compile times, perhaps it's better with derive generic?
06:27:51 <bergmark> quxbam: as of GHC 7.10 Typeable is always implicitly derived
06:28:21 * hackagebot aeson-diff 1.0.0.0 - Extract and apply patches to JSON documents.  https://hackage.haskell.org/package/aeson-diff-1.0.0.0 (ThomasSutton)
06:28:48 <quxbam> bergmark: ah, so it must be the deriving data part
06:28:58 <quxbam> which is *extremely* slow in my case
06:29:44 <quxbam> what about runtime performance? Are simple queries and transformations faster with generic?
06:29:46 <ph88> does <|> have a name ?
06:29:51 <quxbam> or
06:29:53 <srhb> ph88: or?
06:29:59 <ph88> oki thx :p
06:30:06 <srhb> ph88: Not to be confused with `or`
06:30:25 <srhb> ph88: (Joke aside, we tend to just call things what they sort of do, even if we have several of them.)
06:32:35 <puregreen> what was that package for showing dates like “yesterday” or “5 hours ago”?
06:33:19 <hjulle> puregreen: fuzzytime?
06:33:44 <puregreen> like that, except that it was smaller and not GPLed
06:34:46 <puregreen> ah
06:34:50 <puregreen> friendly-time
06:38:21 * hackagebot clash-lib 0.6.15 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.15 (ChristiaanBaaij)
06:38:23 * hackagebot clash-vhdl 0.6.11 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.11 (ChristiaanBaaij)
06:43:21 * hackagebot clash-ghc 0.6.17 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.17 (ChristiaanBaaij)
07:21:02 <sotomashi> Hi. I have a very long string, how can place it on multiple lines? something like this "fdsfdsfdsfd\   aaaaaaaaaa\   bbfdsfsdfdsfd\   fdsfdsfds"  But this doesn't compile.
07:22:01 <Athas> sotomashi: you can make multiple strings and use 'concat' to put them together.
07:22:12 <Athas> Or you can use someting like https://hackage.haskell.org/package/raw-strings-qq
07:22:18 <rcat> sotomashi: inverted slash at the beginning and the end of each line
07:22:22 <trollando> Perfomance wise : Is it better 1) to construct a list with ´prepend´ and ´reverse´ the list. or 2) to construct a list with ´append´
07:22:30 <rcat> stomp:  
07:22:51 <rcat> sotomashi: "aa\    \bb\   \c"
07:22:57 <rcat> but in different lines...
07:23:24 <rcat> http://stackoverflow.com/a/12220976
07:24:03 <ggVGc> is it a huge code smell that many of my functions are defined as Model -> Model, or Model -> a, or a -> Model -> Model
07:24:12 <ggVGc> half my code base operates on my main model :(
07:24:40 <trollando> rcat, any advice ?
07:24:53 <sotomashi> rcat -- I don't need different lines in the string, I just need to be able to split it into different strings. Can I do that with something like "\" ?
07:24:53 <Athas> ggVGc: it is a smell in that it merits investigation, but it may well be the best way to do it.
07:25:09 <hjulle> trollando: You can always benchmark it yourself
07:25:13 <sotomashi> rcat -- because the string is very long.
07:26:35 <ggVGc> Athas: reason is that many of them are in the form of "Take some index from a field in the model, and lookup another field in the model using the index", so they all are fairly bound to the model
07:26:45 <ggVGc> but maybe I've structured the model of the program wrong, and hence this
07:26:48 <lyxia> sotomashi: that will produce a single line
07:27:31 <sotomashi> lyxia -- sorry, once again? how exactly?
07:27:55 <hjulle> trollando: But in your case, I'd guess that the fastest alternative is to use diffference lists.
07:28:20 <sotomashi> "aa\                 \bb\                \c" (3 different lines) doesn't compile
07:28:39 <Athas> ggVGc: it sounds like an inherently sequential stateful computation.  Changing the type might require changing the algorithm.
07:29:09 <hjulle> trollando: https://wiki.haskell.org/Difference_list
07:29:28 <trollando> hjulle, thanks
07:31:36 <trollando> hjulle, http://hastebin.com/xirumibovo.hs
07:31:42 <rcat> sotomashi: yes, you don't need to introduce \n inside the string
07:31:52 <lyxia> sotomashi: please paste your attempt
07:32:15 <rcat> sotomashi: if you wanted to include \n in the string you could do something like
07:32:30 <rcat> "aaa\   \bbbb\n\     \cccccc"
07:32:39 <rcat> which includes the \n, but not in the other example
07:32:46 <hjulle> sotomashi: Notice that there must be a backslash at the beginning of the new line as well as at the start of the old line
07:33:30 <sotomashi> rcat, lyxia -- I do need \n  inside a string because I want it to be on different lines, only in an IDE. But really I want it to be a single line.
07:34:46 <hjulle> sotomashi: https://mail.haskell.org/pipermail/haskell-cafe/2006-January/013911.html
07:35:16 <sotomashi> hjulle -- that doesn't compile
07:35:45 <lyxia> sotomashi: http://lpaste.net/159015 I just did it and it compiles. Please give details.
07:40:45 <sotomashi> lyxia -- yes, thx.
07:48:29 <trollando> hjulle, I did a small benchmark : v1 is faster
07:49:09 <trollando> v2 (4.80 secs, 4,396,055,424 bytes)
07:49:15 <trollando> v1 (2.66 secs,   121,834,528 bytes)
07:50:03 <hjulle> trollando: Another way to write it is: foldr (\c f c1 -> (c1,c) : f c) (const []) xs x
07:51:41 <hjulle> trollando: Or just "zip (init xs) (tail xs)"
07:52:29 <Gurkenglas> Which is semantically equal to "zip xs (tail xs)" because zip truncates
07:53:58 <hjulle> trollando: But that result makes sense, because repeatedly appending will copy the list every time, while reversing only copies the list once.
07:57:12 <trollando> hjulle, nice, with zip we have better space usage, but v1 has better speed
08:01:03 <trollando> thanks a lot
08:01:05 <trollando> cya
08:01:10 <hjulle> trollando: I got better time as well for zip. (But I did not try compiling with optimizations)
08:02:20 <hjulle> trollando: cya
08:09:23 <stevenxl> Hello #haskell 
08:32:37 <djanatyn> yo
08:32:48 <djanatyn> anybody working on any interesting problems
08:33:55 <kjotki> hai
08:42:40 <Darwin226> Hey guys. I have a `newtype T m a = T (ReaderT S m a)` and I can do `deriving MonadIO` using GeneralizedNewtypeDeriving. I'm assuming this makes a MonadIO m => MonadIO (T m) instance. Is there a way to derive
08:43:04 <Darwin226> MonadReader so that the instance skips the ReaderT and passes things through to the m?
08:43:48 <lyxia> just implement it by hand
08:43:52 <GLM> Is there a way to have a reduce like function that only takes one variable?
08:45:11 <meditans> GLM: what would the signature be?
08:47:34 <mjrosenb> Monoid a => [a] -> a?
08:47:56 <GLM> ([a] -> [b]) -> [[a]] -> b
08:48:15 <GLM> If it helps, this is for a neural network and each of those [a] is a layer of weights
08:48:47 <Darwin226> How do you reduce the [[b]] to a b?
08:49:37 <StoneToad> GLM: if you require b to be a member of foldable...
08:49:44 <StoneToad> instance
08:50:06 <Darwin226> StoneToad: Maybe you mean Monoid?
08:50:06 <GLM> Darwin226: At the moment, I take the head (there should only be one element) of the final list
08:50:49 <meditans> GLM: so, break your function in two parts: the fold over the list and the head
08:51:10 <mjrosenb> GLM: that would imply that your input [[a]] only has one element?
08:51:57 <StoneToad> Darwin226: ah yea, there's already a foldable instance for [] if you're contents is a monoid
08:52:26 <GLM> mjrosenb: The size of each list should be decreasing as it folds
08:52:52 <Darwin226> StoneToad: I think you're mistaken. There's a foldable instance for lists regardless of what's in them
08:53:02 <ggVGc> man, adding lenses to this project was a huge step forward
08:53:14 <Darwin226> and Foldable b doesn't make sense in the above context since the class takes types of kind * -> *
08:53:50 <StoneToad> yea, but you don't need to provide any explicit functions if it's a monoid
08:56:29 <StoneToad> GLM: it sounds to me though like you've already got your solution? since you're repeatedly reducing your function until it only produces one element as the output...
08:56:40 <StoneToad> a one element list as the output*
08:57:03 <GLM> StoneToad: Kind of. I'm close but I'm not sure how I can guarantee that there will only be one element in that final list
08:57:47 <StoneToad> can you garantee that the reduce function will always return no more then n-1 elements for an n element list?
08:58:06 <StoneToad> guess it's being provided as an argument, so you can't...
09:00:15 <mjrosenb> GLM: I'm not too certain how you can be using something with that type to be processing the bs, but you likely know better than I.
09:00:56 <GLM> If you have any ideas, I'll all ears
09:03:22 <hexagoxel> Darwin226: i guess you need/can use StandaloneDeriving for deriving that MonadIO instance.
09:03:26 * hackagebot irc-dcc 1.2.0 - A DCC message parsing and helper library for IRC clients  https://hackage.haskell.org/package/irc-dcc-1.2.0 (JanGerlinger)
09:03:39 <S11001001> GLM: I think you need an extra argument, ([b] -> [b]) in that case.
09:04:08 <Darwin226> hexagoxel: Nah, the MonadIO works as expected (I think; the compiler isn't complaining)
09:05:19 <hexagoxel> ah oops, well then the MonadReader instance. the ghc users guide uses MonadState as one StandaloneDeriving example..
09:07:43 <Jaxan> If I have two sorted lists xs and ys. Is `(,) <$> xs <*> ys` guaranteed to be sorted?
09:08:38 <hexagoxel> > (,) <$> [1,2,3] <*> [1,2,3]
09:08:39 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
09:08:58 <johnw> I think the answer is yes, but it's a great test for QuickCheck to be sure
09:09:29 <blob_> hello! does anyone know if there are any known issues with accelerated rendering in the sdl2 library? doesn't render correctly for me, but if I switch to software rendering everything looks right
09:11:42 <Jaxan> johnw: it seems to work when I test it with quickcheck
09:12:00 <johnw> Jaxan: given the Ord nature of tuples, it sounds right
09:12:38 <Jaxan> johnw: well, it also depends on <*>
09:13:10 <johnw> Jaxan: since you said lists, I know what <*> is doing
09:13:27 * hackagebot webapi 0.2.1.0 - WAI based library for web api  https://hackage.haskell.org/package/webapi-0.2.1.0 (ersran9)
09:21:31 <Jaxan> johnw: maybe my real question is: can there be a valid Applicative instance for [], for which it doesn't hold. That seems to be the case, so the current applicative instance for [] is chosen to be a nice one ;-)
09:22:39 <Jaxan> (similarly: there are two natural Ord instances for pairs)
09:26:08 <johnw> ah, I was just thinking in terms of current <*> and current (,)
09:39:32 <ggVGc> is there a better way to write this without the explicit mzero case? https://gist.github.com/11ef0fa9a482c7e2d9ce74973d45314b
09:39:50 <ggVGc> I tried when and guard, but doesn't seem to be what I want
09:42:33 <monochrom> yes it can be replaced by guard. and more parentheses
09:42:55 <ggVGc> essentially I want this I think? https://gist.github.com/2ded79c1d1f638a6e5d71d55215b9b3c
09:42:58 <monochrom> and a negation
09:43:40 <monochrom> line 1 "guard (not ((m^.triggerSeqs&toList)&hasSameSeq e1 e2))", line 2 "return StrongGreen"
09:44:02 <monochrom> err, I guess I'm wrong about negation
09:44:09 <lyxia> guard f $> StrongGreen
09:45:09 <ggVGc> where is $> defined?
09:45:14 <monochrom> line 1 "guard ((m^.triggerSeqs&toList)&hasSameSeq e1 e2)", line 2 "return StrongGreen"
09:45:32 <hexagoxel> or MonadComprehension's [ StrongGreen | m^.trig… ]
09:46:16 <monochrom> > do { x <- Just 4; guard (odd x); return x }
09:46:18 <lambdabot>  Nothing
09:46:23 <monochrom> > do { x <- Just 4; guard (even x); return x }
09:46:24 <lambdabot>  Just 4
09:46:26 <monochrom> works
09:47:35 <mjrosenb> > (\v -> do { x <- v; guard (even x); return x}) <$> [Just 1, Just 2]
09:47:37 <lambdabot>  [Nothing,Just 2]
09:47:52 <ggVGc> > fromMaybe 10 $ do { x <- Nothing; guard (even x); return 67 }
09:47:54 <lambdabot>  10
09:48:26 <ggVGc> cool, thanks
09:49:02 <ggVGc> mjrosenb: what's with the semicolon? I can't get it to compile without adding it
09:49:11 <ggVGc> but I don't completely understand
09:49:26 <ggVGc> I thougth line break and semicolo were equivalent
09:49:54 <ggVGc> oh, wait, works now
09:50:02 <monochrom> no, line-break-and-suitable-indentation
09:50:37 <mjrosenb> also, iirc the semicolon is only valid inside of a curlbraced list of expressions?
09:50:59 <monochrom> > if True ; then () ; else ()
09:51:00 <lambdabot>  ()
09:51:04 <monochrom> :)
09:51:10 <mjrosenb> well, nevermind then
09:51:19 * mjrosenb quietly removes his foot from his mouth
09:51:36 <monochrom> it is how they got do-if-then-else to work. your statement was right for Haskell 98
09:52:00 <mjrosenb> hah.  I kind of wondered what trickery they used for that.
09:52:33 <monochrom> Haskell 2010 changed the grammar to "if exp [;] then x [;] y". it's an ingenious way to minimally change the grammar and get what you want
09:52:49 <mjrosenb> this is the thing where the traditional 'else goes at the same indentation level as if' causes do parsing to get really sad?
09:53:00 <monochrom> yeah
09:53:32 <monochrom> http://lpaste.net/81623
09:54:26 <ggVGc> monochrom: so, this works, but not with any indentation https://gist.github.com/22f553ce7f5e1b3b3f8f6f2b8e91ac1e
09:54:30 <ggVGc> what's actually goinf on here?
09:54:42 <ggVGc> the signature of guard is also weird to me
09:56:06 <monochrom> both lines are indented to the same level. that is why they are parsed right
09:57:58 <ggVGc> but how does guard work?
09:58:02 <ggVGc> it's very strange to me
09:58:11 <monochrom> @src guard
09:58:11 <lambdabot> guard True  = return ()
09:58:11 <lambdabot> guard False = mzero
09:59:06 <EvanR> its a miracle
10:04:26 <Gurkenglas> Someone replace that mzero with an empty
10:04:42 <Gurkenglas> (Where do we put pull requests for lambdabot?)
10:05:20 <Gurkenglas> (As in, do changes to https://github.com/lambdabot/lambdabot change our channel's lambdabot?)
10:07:05 <puregreen> Gurkenglas: there's a separate branch for the freenode instance
10:07:16 <puregreen> but I think you're supposed to make pull requests against master
10:09:49 <Gurkenglas> Aww, that's already fixed on master
10:11:32 <Gurkenglas> And has been for a year, a week and a day :D
10:11:46 <Gurkenglas> (Is there some way to look up the exact time of a commit?)
10:13:13 <Gurkenglas> And so it is on Freenode
10:13:21 <Gurkenglas> *the freenode branch
10:16:59 <Gurkenglas> https://github.com/lambdabot/lambdabot/issues/128 , fixed later, works now though
10:53:24 <mike993> hi, everyone, I'm doing some Haskell exercise, in particular one asks to implement some of the standard high-order functions on a Binary Search Tree
10:54:02 <mike993> I've implemented the map function but when it comes to the foldl I don't understand how to implement it
10:54:18 <mike993> here's the code I started writing if someon'e interested: http://pastebin.com/v3QHcZ5p
10:56:17 <nitrix> mike993: The map is correct.
10:57:23 <mike993> nitrix: thank you for checking, I'm not sure how to implement the foldl; though I might try with the map I've implemented but I'm not sure how to go about it
10:57:41 <nitrix> mike993: The fold should be a type error atm.
10:58:08 <mjrosenb> implementing fold with map is... difficult.
10:59:51 <mike993> nitrix: could you be more specific?
11:00:01 <nitrix> mike993: I think what's challenging is that you're trying to both implement foldl (generally speaking) and also, mentally transpose the idea to your data structure.
11:00:39 <nitrix> mike993: Do you know about typed holes?
11:00:56 <dmj> @def map2' f xs = foldr (\y ys -> f y : ys) [] xs
11:00:59 <lambdabot>  Defined.
11:01:01 <mike993> nitrix: nope, I'm a total newbie :/
11:01:13 <dmj> :t map2'
11:01:14 <lambdabot> Foldable t => (a -> a1) -> t a -> [a1]
11:02:35 <nitrix> mike993: Identifiers begining with an underscore are typed holes e.g _x. GHC trips on those and shows you a detailed report on the hole and what type is has; thus, when implementing functions like this, it may help you if you start with a hole and progressively refine it until the desired type.
11:03:10 <nitrix> Now, the type of `f` is :: (b -> a -> b)
11:03:53 <nitrix> f z n (...) (...), f has way too many arguments :P
11:04:29 <nitrix> I'd ditch the use of bstMap, it'll make your life easier :)
11:05:04 <mike993> nitrix: how you'd go about it?
11:05:17 <mike993> nitrix: plain pattern matching?
11:06:45 <nitrix> Let me see if I can come up with something :P
11:07:04 <mike993> nitrix: thank you very much :)
11:07:06 <nitrix> You could have a where clause with two recursive functions, leftFold, rightFold; would that help?
11:08:18 <nitrix> or branchFold even.
11:08:28 <mike993> nitrix: you mean fold for the left tree and fold for the right tree?
11:09:18 <nitrix> I'm just trying to help you decomposet he problem into a recursive function with an accumulator; exactly what foldl do.
11:13:37 <mike993> nitrix: yes, but I don't understand how to do it :S
11:13:40 <djbeau> mike993: I haven't a concrete implementation in my head, but it seems to me that a key observation is that a Node has two BSTrees...so the bstFold should have to perform two distinct sub-folds
11:13:50 <djbeau> if that makes any sense :P
11:14:08 <djbeau> and then combine the results of those subfolds
11:15:42 <djbeau> and I do not mean to imply that the subfolds are indepedent operations
11:17:07 <mike993> djbeau: yeah, that's the idea but I'm kind of lost...
11:17:38 <nitrix> What about some kind of (bstFold f (bstFold f (f z n) t1) t2) ?
11:18:17 <ertesx> what are the valid paths for change logs (relative to package root) such that hackage finds and displays them?
11:18:46 <ertesx> (markdown preferred, if possible)
11:19:21 <ertesx> /CHANGELOG.md?
11:20:07 <nitrix> mike993: bstFold _ z Nil = z
11:20:17 <nitrix> mike993: bstFold f z (Node n t1 t2) = (bstFold f (bstFold f (f z n) t1) t2)
11:20:32 <nitrix> It's a naive implementation, but it shows the idea I think.
11:20:47 <nitrix> @let data BSTree a = Nil | Node a (BSTree a) (BSTree a)
11:20:49 <lambdabot>  Defined.
11:21:24 <mike993> nitrix: oww, right, stupid error with the base case :S
11:21:35 <nitrix> > bstFold (+) 0 $ Node 1 (Node 4 Nil (Node 5 Nil Nil)) Nil
11:21:36 <lambdabot>  Not in scope: ‘bstFold’    Ambiguous occurrence ‘Node’
11:21:36 <lambdabot>      It could refer to either ‘L.Node’,
11:21:36 <lambdabot>                               defined at /tmp/mueval16425488991501252996.hs:1...
11:21:50 <nitrix> @let bstFold _ z Nil = z; bstFold f z (Node n t1 t2) = (bstFold f (bstFold f (f z n) t1) t2)
11:21:51 <lambdabot>  .L.hs:165:14:
11:21:51 <lambdabot>      Ambiguous occurrence ‘Node’
11:21:51 <lambdabot>      It could refer to either ‘L.Node’, defined at .L.hs:161:17
11:22:08 <nitrix> Obviously someone has Node defined already :P
11:22:24 <mike993> lol :)
11:22:31 <nitrix> @let data MyBSTree a = MyNil | MyNode a (MyBSTree a) (MyBSTree a)
11:22:33 <lambdabot>  Defined.
11:22:33 <ski> @index Node
11:22:33 <lambdabot> Data.Tree, Data.Graph
11:22:47 <ski> @type Data.Tree.Node
11:22:49 <lambdabot> a -> Forest a -> Tree a
11:23:04 <nitrix> @let bstFold' _ z MyNil = z; bstFold' f z (MyNode n t1 t2) = (bstFold' f (bstFold' f (f z n) t1) t2)
11:23:06 <lambdabot>  Defined.
11:23:08 <ski> (where `type Forest a = [Tree a]')
11:23:28 <nitrix> > bstFold' (+) 0 $ MyNode 1 (MyNode 4 MyNil (MyNode 5 MyNil MyNil)) MyNil
11:23:30 <lambdabot>  10
11:23:33 <nitrix> Works :)
11:23:44 <mike993> thank you! :D
11:24:18 <ski> mike993 : btw, note that that's two different concepts named "fold"
11:24:23 <nitrix> You might want to re-organise a bit the folding so that the ordering in which the folds are performed makes some sense to you.
11:24:27 <ski> s/that that/that there/
11:25:12 <nitrix> (+) is commutative, but not all binary operators are like that.
11:25:30 <ski> one is combining a sequence of elements from/in a structure in some (traversal) order. this is `foldr',`foldl',and `Foldable'
11:26:11 <ski> the other one (also called "catamorphism") means "replacing" the data constructors of a value of a data type with custom provided functions
11:26:43 <mike993> the one I wanted was 'foldl'
11:27:38 <ski> @let bstCata :: (a -> r -> r -> r) -> r -> BSTree a -> r; bstCata node nil Nil = nil; bstCata node nil (Node a l r) = node a (bstCata node nil l) (bstCata node nil r)
11:27:39 <lambdabot>  .L.hs:170:19:
11:27:39 <lambdabot>      Ambiguous occurrence ‘Node’
11:27:39 <lambdabot>      It could refer to either ‘L.Node’, defined at .L.hs:161:17
11:27:53 <ski> @let bstCata :: (a -> r -> r -> r) -> r -> BSTree a -> r; bstCata node nil MyNil = nil; bstCata node nil (MyNode a l r) = node a (bstCata node nil l) (bstCata node nil r)
11:27:54 <lambdabot>  .L.hs:169:18:
11:27:55 <lambdabot>      Couldn't match expected type ‘BSTree a’
11:27:55 <lambdabot>                  with actual type ‘MyBSTree t0’
11:27:59 <Cale> heh
11:28:03 <ski> oh, you renamed that as well :)
11:28:09 <ski> (sorry for the noise)
11:28:24 <ski> @let bstCata :: (a -> r -> r -> r) -> r -> MyBSTree a -> r; bstCata node nil MyNil = nil; bstCata node nil (MyNode a l r) = node a (bstCata node nil l) (bstCata node nil r)
11:28:26 <lambdabot>  Defined.
11:28:28 <ski> there
11:29:35 <nitrix> ski: So, cata means it'd replace MyNode / Nil ?
11:30:15 <Cale> bstCata (\x l r -> l . (x:) . r) id (MyNode 3 (MyNode 1 (MyNode 0 MyNil MyNil) (MyNode 2 MyNil MyNil)) (MyNode 4 MyNil MyNil)) []
11:30:16 <Cale> > bstCata (\x l r -> l . (x:) . r) id (MyNode 3 (MyNode 1 (MyNode 0 MyNil MyNil) (MyNode 2 MyNil MyNil)) (MyNode 4 MyNil MyNil)) []
11:30:18 <lambdabot>  [0,1,2,3,4]
11:30:24 <nitrix> Oh I get it now. Nice example.
11:30:36 <nitrix> This is actually very nice.
11:30:45 <nitrix> So it preserves the structure but converts it?
11:30:48 <Cale> yeah
11:31:07 <Cale> You can easily implement a foldl-like operation using the cata, but you can't go the other way
11:31:12 <ski> > let showNil = "Nil"; showNode a l r = concat ["(Node ",show a," ",l," ",r,")"] in bstCata showNode showNil (MyNode 1 (MyNode 4 MyNil (MyNode 5 MyNil MyNil)) MyNil)
11:31:13 <lambdabot>  "(Node 1 (Node 4 Nil (Node 5 Nil Nil)) Nil)"
11:31:42 <ski> > let showNil = "()"; showNode a l r = concat ["(",l," ",show a," ",r,")"] in bstCata showNode showNil (MyNode 1 (MyNode 4 MyNil (MyNode 5 MyNil MyNil)) MyNil)
11:31:44 <lambdabot>  "((() 4 (() 5 ())) 1 ())"
11:31:51 <ski> > let showNil = ""; showNode a l r = concat ["(",l," ",show a," ",r,")"] in bstCata showNode showNil (MyNode 1 (MyNode 4 MyNil (MyNode 5 MyNil MyNil)) MyNil)
11:31:54 <lambdabot>  "(( 4 ( 5 )) 1 )"
11:32:17 <Cale> Whenever you implement a data structure, you should consider whether it would be worth having such a function which recursively replaces the data constructors with other given values.
11:33:08 <mike993> That's very interesting
11:33:09 <Cale> @data Nature a = Rock | Stream a (Nature a) | Bush (Nature a) (Nature a) deriving (Eq, Ord, Show)
11:33:10 <lambdabot> Unknown command, try @list
11:33:11 <mike993> Thank you
11:33:11 <ski> mike993,nitrix : anyway, it happens that `foldr' (but not `foldl') is a fold for lists, in *both* senses of the term ! (which is probably also why the same term is used for these two different concepts)
11:33:12 <Cale> @let data Nature a = Rock | Stream a (Nature a) | Bush (Nature a) (Nature a) deriving (Eq, Ord, Show)
11:33:14 <lambdabot>  Defined.
11:33:26 <ski> @src foldr
11:33:27 <lambdabot> foldr f z []     = z
11:33:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:33:40 <ski> > foldr f z [0,1,2,3]
11:33:42 <lambdabot>  f 0 (f 1 (f 2 (f 3 z)))
11:33:45 <ski> > foldr (-) z [0,1,2,3]
11:33:47 <lambdabot>  0 - (1 - (2 - (3 - z)))
11:33:48 <Cale> @let foldNature rock stream bush = f where f Rock = rock; f (Stream x n) = stream x (f n); f (Bush n1 n2) = bush (f n1) (f n2)
11:33:51 <lambdabot>  Defined.
11:33:55 <Cale> :t foldNature
11:33:58 <lambdabot> t1 -> (t -> t1 -> t1) -> (t1 -> t1 -> t1) -> Nature t -> t1
11:34:13 <ski> replaces the `(:)' constructor with `f'/`(-)', and the empty list `[]' constructor with `z'
11:34:48 <Cale> (I love this type for examples, it's sort of surreal :D)
11:35:02 <mike993> lol
11:36:39 <Gurkenglas> int-e, "@src guard" has been commited to empty a year and a week and a day ago but querying Freenode's lambdabot still yields mzero
11:36:39 <Cale> @let sizeNature = foldNature 0 (1+) (+)
11:36:42 <lambdabot>  Defined.
11:36:45 <Cale> :t sizeNature
11:36:46 <lambdabot> (Num t, Num (t -> t)) => Nature (t -> t) -> t
11:36:52 <Cale> oh, whoops :D
11:36:57 <monochrom> I want a natural in which there are also birds
11:37:00 <Cale> @undefined
11:37:00 <lambdabot> Undefined.
11:37:32 <Cale> monochrom: that's what you get if you do this with combinator logic ;)
11:38:28 <mike993> Guys since you're warmed up may I ask you a 'filter' implementation?
11:38:32 <mike993> http://pastebin.com/UuhZ71sF
11:38:33 * hackagebot timelike 0.2.2 - Type classes for types representing time  https://hackage.haskell.org/package/timelike-0.2.2 (esz)
11:39:27 <mike993> I don't know how to preserve the data structure using 'filter'
11:39:28 <Cale> mike993: Do merge before filter
11:40:08 <Gurkenglas> I'd write Nature in terms of Fix and then do: foldNature rock stream bush = cata \case Rock -> rock; Stream x n -> stream x n; Bush n1 n2 -> bush n1 n2
11:40:58 <Cale> Gurkenglas: well, you'd have cata then, so you almost wouldn't need foldNature, but yeah :)
11:41:02 <Gurkenglas> *"cata $", until we get the haskell extension that allows removing that $
11:41:26 <mike993> Cale: I've never used it
11:41:50 <Cale> The point of writing stuff like  foldNature  is to simulate cata for types that are not explicitly written in terms of fixpoints (i.e. most of them)
11:43:03 <Cale> mike993: Actually, assuming that these are binary search trees, there might be a better operation for the specific case you'll have here where you have two subtrees with the guarantee that all the node labels in the left subtree are less than all the node labels in the right
11:43:42 <mike993> Cale: sorry if I haven't already said it, but these ARE BSTs
11:44:08 <Cale> Well, bstMap won't work in that case unless the function you give it is monotone
11:44:39 <Gurkenglas> Can one implement language extensions and then use them like a library instead of getting them through the bureaucratic hoops?
11:44:40 <Cale> Ordinarily, a map function would have to reconstruct the search tree
11:45:00 <Cale> Gurkenglas: You can implement preprocessors as arbitrary executables
11:45:07 <Cale> and tell ghc to use them
11:45:15 <mike993> Cale: you're right I haven't thought about that ._.
11:45:20 <Gurkenglas> Is that how language extensions are born?
11:45:41 <Cale> Gurkenglas: sometimes... though I don't know of many examples of that really happening.
11:45:42 <monochrom> no
11:46:01 <Cale> Well, I think the Arrow syntax started out as a preprocessor before it was in GHC
11:46:07 <monochrom> the arrow notation was a preprocessor for maybe a few months
11:46:25 <Gurkenglas> Is there an API to tell ghci to treat this language extension identifier as an instruction to run that preprocessor?
11:46:33 <Cale> no
11:46:37 <Zemyla> So who first implemented Template Haskell?
11:46:42 <Cale> It's an extra commandline flag
11:47:08 <monochrom> problem with preprocessor is that it takes more effort to map error locations-messages back and forth than to simply develop on GHC
11:47:52 <Cale> yeah, and it's also hard to make sure that your preprocessor really handles all the syntax that GHC does
11:48:40 <Cale> and there are some bits of syntax which are tricky to handle if you really have to interact with them, like RecordWildCards
11:49:21 <Cale> (the Foo {..} syntax binds a bunch of names, but you can't tell what those are from syntax alone)
11:49:38 <ertesx> /CHANGELOG.md worked
11:49:40 <mjrosenb> are RecordWildCards the ones that can magically bring variables into scope, and magically insert values into a record?
11:49:43 <Cale> yeah
11:49:50 <monochrom> approximately the only language-extension preprocessor, in the whole world, throughout history , inside or outside Haskell, that actually survived more than a few months, was "cfront" an early implementation of C++ that converted C++ to C.
11:50:15 <Gurkenglas> How hard would you estimate it to be to write a preprocessor that wraps every do block in round brackets, and another that wraps every indentation block in round brackets?
11:50:19 <Cale> Is she still active?
11:50:38 <Gurkenglas> (ever indentation block in value-level expressions)
11:50:40 <Cale> It lasted a few years anyway :)
11:50:48 <Gurkenglas> *every
11:51:04 <mjrosenb> monochrom: there are crazy things like coffeescript et al.
11:51:13 <puregreen> I think there was some preprocessor that someone did to show off ArgumentDo
11:51:18 <puregreen> I'll try to find it now
11:51:48 <tdammers> I've been pondering a preprocessor for C that adds lambda functions for quite a while now...
11:52:10 <ertesx> tdammers: or you use modern C++
11:52:26 <puregreen> a-ha
11:52:33 <puregreen> Gurkenglas: take a look at https://github.com/gibiansky/ghc-reskin
11:52:34 <Cale> tdammers: That's called a "compiler" ;)
11:52:50 <tdammers> Cale: yeah, that's where my musing usually end up
11:53:30 <Zemyla> Well, C++ originally compiled to C.
11:53:44 <tdammers> So did Haskell
11:53:57 <nitrix> *GHC
11:54:14 <monochrom> but Haskell doesn't count as "a language extension of C"
11:54:44 <monochrom> but of course this is subjective
11:54:45 <ertesx> neither does C++ really; it's incompatible
11:54:47 <Gurkenglas> Ah, you can supply ghc options in the first .hs line, very good. Thanks!
11:55:08 <int-e> @src guard
11:55:12 <lambdabot> guard True  = pure ()
11:55:18 <lambdabot> guard False = empty
11:55:28 <monochrom> @type guard
11:55:35 <Gurkenglas> :D what had been the problem?
11:55:38 <lambdabot> Alternative f => Bool -> f ()
11:55:59 <monochrom> then that's a good change
11:56:05 <int-e> Gurkenglas: ~/.lambdabot/State contained an old version of the `source` file
11:56:17 <int-e> which I have now removed so this should not happen again
11:56:42 <Gurkenglas> You mean having old versions of files should not happen again?
11:58:16 <int-e> Gurkenglas: it's now picking up the file from the installed package instead
12:10:14 <sinelaw> ski: more naming: adding/removing a label from a 'composite', is called what for rows / columns? 
12:10:26 <sinelaw> "inject" is for columns IIRC
12:10:39 <sinelaw> (adds a constructor)
12:11:03 <cocreature> I have a haddock comment that for some reason attaches to the instance declaration before it instead of the function after it, is there anything I can do about this?
12:11:37 <SLi> I'm trying to use a different prelude (classy-prelude for now, I don't know if that's a good choice). Seems it doesn't import IO for some reason. Am I supposed to just import it from System.IO separately?
12:13:07 <SLi> Or: How do I write the type of my main function?
12:13:13 <sm> weird
12:14:46 <SLi> Is an alternative prelude generally a good idea? :) I got tired when it felt half of my time writing Haskell is spent organizing imports...
12:16:06 <sinelaw> SLi: I use Prelude.Compat sometimes, but it's the same as latest prelude
12:16:06 <sm> SLi: same here, but I've been slow to try it
12:16:20 <sinelaw> (just makes it easier to maintain backwards-compatible code)
12:16:31 <sm> base-prelude seems a nice easy beginner prelude that saves some (not all) import noise
12:16:47 <sm> I think after that I'd try basic-prelude, then classy-prelude
12:17:23 <sm> and yes, it has been good
12:18:04 <SLi> Hmm.
12:21:42 <sm> SLi: does main :: MonadIO m => m () work ?
12:23:18 <SLi> sm: Argh, sorry for the noise, actually now that I *properly* import ClassyPrelude in all my files, IO () does work :P I didn't notice that I had errors from two different files...
12:23:32 <SLi> :P
12:23:35 <sm> ah
12:23:40 <SLi> So user error.
12:33:02 <johnw> some alternate preludes are a lot more opinionated than others
12:36:45 <pklausler> hey, is there a good Haskell idiom for an APL inner product? something like:   innerProduct :: (a->b->c) -> [a] -> [b] -> [[c]]
12:37:23 <ertesx> pklausler: can you give an example?
12:37:35 <pklausler> it's easy with list comprehensions, I know, but maybe there's something more general for Traversables
12:38:03 <pklausler> innerProduct f xs ys = [[x `f` y | y <- ys] | x <- xs]
12:38:15 <mathman> Can someone suggest me some good AI projects
12:38:20 <puregreen> liftA2
12:38:22 <johnw> or just innerProduct = liftA2
12:38:25 <pklausler> example: use with (*) to get a multiplication table
12:38:36 <ertesx> that's not quite liftA2
12:38:41 <puregreen> oh, right
12:38:59 <ertesx> \f xs ys -> xs >>= \x -> map (f x) ys
12:39:01 <ertesx> something like that
12:39:03 <pklausler> liftA2 flattens the lists
12:39:21 <ertesx> :t \f xs ys -> xs >>= \x -> f x <$> ys
12:39:22 <lambdabot> Monad m => (a -> a1 -> b) -> m a -> m a1 -> m b
12:39:32 <ertesx> ah, nope
12:39:39 <ertesx> :t \f xs ys -> xs >>= \x -> pure (f x <$> ys)
12:39:39 <pklausler> i guess i'm looking for a point-free trick
12:39:40 <lambdabot> (Monad m, Functor f) => (a -> a1 -> b) -> m a -> f a1 -> m (f b)
12:39:48 <ertesx> that should work
12:40:05 <EvanR> how do I iterate a s -> (a,s) to get a [a]
12:40:09 <ertesx> pklausler: will probably look ugly in point-free style, unless you flip the arguments
12:40:23 <ertesx> EvanR: map fst or unfoldr
12:40:25 <Zemyla> :t unfoldr
12:40:27 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:40:43 <EvanR> ok, for some reason i thought it could be done with monads
12:41:15 <pklausler> innerProduct = flip lessUglyInnerProduct
12:41:41 <ertesx> EvanR: a proper ListT over State would work, but it's massive overengineering
12:42:48 <ertesx> pklausler: oh, and call it something else…  inner products are a well known vector spaces concept that disagrees with APL's "inner products"
12:43:11 <ertesx> pklausler: you have something along the lines of cartesian products
12:43:42 * hackagebot nanovg 0.1.0.0 - Haskell bindings for nanovg  https://hackage.haskell.org/package/nanovg-0.1.0.0 (cocreature)
12:44:33 <pklausler> i'll call it whatever i like, thanks
12:45:47 <nitrix> Rude.
12:46:35 <ertesx> that's what you get for trying to be helpful…  have fun
12:47:19 <Zemyla> :t \f xs ys -> map (\x -> map (f x) ys) xs
12:47:20 <lambdabot> (a -> a1 -> b) -> [a] -> [a1] -> [[b]]
12:47:37 <shachaf> I think this is APL outer product anyway.
12:47:50 <shachaf> And also more similar to the outer product in linear algebra.
12:48:26 <Zemyla> The inner product is a combination of a fold and a zip.
12:48:42 * hackagebot nanovg 0.1.0.1 - Haskell bindings for nanovg  https://hackage.haskell.org/package/nanovg-0.1.0.1 (cocreature)
12:49:10 <Zemyla> @pl \f xs ys -> map (\x -> map (f x) ys) xs
12:49:10 <lambdabot> flip . (map .) . flip . (map .)
12:49:27 <Zemyla> That is a very nice pointfree.
12:49:27 <ertesx> :t \f xs ys -> fmap (\x -> f x <$> ys) xs
12:49:28 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f1 a1 -> f (f1 b)
12:49:35 <pklausler> shachaf is right, this is APL's outer product
12:49:56 <monochrom> yeah but you gotta call it whatever you gotta like
12:49:57 <Zemyla> :t flip . (map .)
12:49:58 <lambdabot> (a -> a1 -> b) -> [a1] -> a -> [b]
12:50:08 <leetcool> hey everyone
12:50:22 <Zemyla> :t flip . (map .) . flip . (map .) . flip . (map .)
12:50:23 <lambdabot> (a -> a1 -> b) -> [[a1]] -> [a] -> [[[b]]]
12:50:35 <ertesx> Zemyla: aesthetically pleasing…  not "nice" in the sense that stupid me could make sense of it by looking at it =)
12:51:38 <shachaf> Psh, why stop there?
12:51:47 <shachaf> :t fmap flip (fmap fmap) . fmap flip (fmap fmap)
12:51:48 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f1 a1 -> f (f1 b)
12:52:03 <monochrom> why stop there? answer: because it needs to terminate :)
12:52:22 <ertesx> why stop there?
12:52:23 <ertesx> :t fmap flip (fmap fmap) `fmap` fmap flip (fmap fmap)
12:52:24 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f1 a1 -> f (f1 b)
12:52:41 <shachaf> :t fmap fmap fmap flip fmap fmap . fmap fmap fmap flip fmap fmap
12:52:42 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f1 a1 -> f (f1 b)
12:52:43 <shachaf> There we go.
12:52:44 <pklausler> that's exactly the type signature that i think that i wanted
12:52:59 <tdammers> totally
12:53:29 <Zemyla> shachaf: Niw that you're done fmapping all over the channel, are you going to clean it up?
12:54:07 <pklausler> :t (<$>) (<$>) (<$>) flip (<$>) (<$>) . (<$>) (<$>) (<$>) flip (<$>) (<$>)
12:54:08 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f1 a1 -> f (f1 b)
12:54:52 <ertesx> :t (<$>) (<$>) (<$>) flip (<$>) (<$>) <$> (<$>) (<$>) (<$>) flip (<$>) (<$>)
12:54:53 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f1 a1 -> f (f1 b)
12:55:57 <pklausler> surely something shorter can be built from <*> if we don't need distinct f/f1
12:56:19 <shachaf> What functions can be used to make something both point-free and parenthesis-free?
12:56:36 <Zemyla> $
12:56:46 <pklausler> ($) = id of course
12:56:50 <shachaf> That's not really parenthesis-free.
12:57:05 <shachaf> a b $ c d = ($) (a b) (c d)
12:57:12 <ertesx> something without right-associated function application
12:57:13 <shachaf> Let's say without infix operators.
12:58:30 <ertesx> i don't think it's possible in general
12:59:34 <pklausler> hmm.  too bad (.) is infix
12:59:40 <shachaf> Why not?
12:59:58 <ertesx> though it might be:  you could write a brainfuck interpreter and replace the loop construct by labels and gotos
13:02:51 <ertesx> shachaf: do you mean something fundamental?  like the no-right-association thing?  or just style?
13:03:17 <shachaf> I don't quite understand the question but the answer is probably yes.
13:04:22 <shachaf> Another way to put it: If you had unlambda without `, where everything was left-associated, what primitives would you need to be able to write any function?
13:07:04 <ertesx> i'd start with:  s f g x = f x (g x); sr f g x = f (g x)
13:07:35 <pklausler> s = (<*>) or (=<<)
13:08:27 <ertesx> then add versions with more arguments to handle deeper parentheses…  but i'm pretty sure that would explode exponentially
13:14:14 <ecognium> I am trying to integrate basic-auth Wai middleware but not sure how to return an `IO Bool` correctly from inside a MonadReader.  I don't understand much about Monad/stacking to figure out the right way to do this
13:14:27 <ecognium> My function signature looks like this: `validateBasicAuth :: (MonadReader Config IO, MonadIO IO) => ByteString -> ByteString -> IO Bool` 
13:14:57 <Zemyla> ecognium: liftIO?
13:15:00 <ecognium> and I am trying to use it  as: basicAuth validateBasicAuth "My realm"
13:16:54 <ecognium> HttpAuth is here: https://hackage.haskell.org/package/wai-extra-3.0.12/docs/Network-Wai-Middleware-HttpAuth.html 
13:17:20 <ecognium> Zemyla:   i tried liftIO but not sure if I should do it inside my validateBasicAuth or outside.  
13:17:29 <Zemyla> Inside.
13:17:47 <Zemyla> IO isn't a MonadReader.
13:17:53 <ecognium>     mu <- runDb $ selectFirst [ AuthUsername ==. bsToText user, AuthPassword ==. bsToText pass ] []
13:17:53 <ecognium>     return True
13:18:09 <geekosaur> that function signature seems weird. "MonadIO IO" in the context?
13:18:54 <ecognium> I added liftIO $ runDb but that does not work either. I get: 
13:18:57 <geekosaur> it's unnecessary and close to meaningless; you don't need to say that for concrete types, only for type variables
13:18:59 <ecognium>  No instance for (Control.Monad.Reader.Class.MonadReader Config IO)
13:18:59 <ecognium>       arising from a use of ‘validateBasicAuth’
13:20:24 <ecognium> geekosaur:  it used to be `m` instead of `IO` but since I wanted only `IO` I just replaced m with IO.. that part type-checked but I cannot figure out how to use it inside `basicAuth` 
13:20:49 <geekosaur> if it's IO then you don't need that aprt at all
13:21:03 <EvanR> can I use gmp's modular exponentiation directly
13:21:08 <EvanR> it seems funny to somehow importa gmp
13:23:32 <ecognium> geekosaur:  `validateBasicAuth`  seems to type check with `IO Bool` as the return type.. However when I use it inside `basicAuth` it gives me the No Instance for ...  I am using MonadReader because my `runDb` accesses some pool information from there
13:24:22 <ecognium> since I added that context, does that mean my return type is not really `IO Bool`? Sorry I am still a beginner in Haskell and Monads confuse me a lot
13:24:26 <geekosaur> no
13:24:31 <geekosaur> it does mean you have no idea what a context does
13:24:59 <geekosaur> hint: you can completely omit the context because it does nothing whatsoever because it has no type variables in it
13:25:04 <geekosaur> your problem is elsewhere
13:25:21 <ecognium> my `runDb` has this signature: runDb :: (MonadReader Config m, MonadIO m) => SqlPersistT IO b -> m b 
13:25:53 <geekosaur> yes. you have type vars there
13:26:02 <geekosaur> so you need something to ensure that the chosen m has those instances
13:26:08 <geekosaur> but with (MonadReader Config IO, MonadIO IO) =>
13:26:19 <geekosaur> either it does or it doesn't
13:26:32 <geekosaur> and you have no control and no need to declare that something needs to check
13:26:37 <geekosaur> it does nothing
13:27:29 <geekosaur> also the Config part has no referent because there's nothing that uses it
13:27:39 <geekosaur> in runDb, the m used it
13:27:54 <geekosaur> in validateBasicAuth :: (MonadReader Config IO, MonadIO IO) => ByteString -> ByteString -> IO Bool
13:28:01 <geekosaur> it's inaccessible and useless
13:28:20 <geekosaur> to be more clear: *you need the m*
13:31:01 <geekosaur> actually, hm. you need it but it's not clear you can access it even then. need to know more
13:32:53 <ecognium> geekosaur:  thanks. I switched back to using m. I am not sure I understand what I am doing.. I am calling everything in the reader context but need to figure out how to use it correctly.  
13:33:29 <EvanR> this syntax is weird
13:33:30 <ecognium> I am launching a Wai application as: run port $ bauth $ logger $ app cfg 
13:33:39 <EvanR> https://wiki.haskell.org/Testing_primality 
13:33:42 <geekosaur> for starters, m *is* the reader.  when you decided to switch it to IO, you got rid of the reader
13:33:52 <EvanR> how is that valid haskell
13:33:56 <ecognium> where bauth was my bauth = basicAuth validateBasicAuth "realm" 
13:34:01 <geekosaur> just having it mentioned in the context does nothing
13:36:09 <ecognium> geekosaur:  i thinking i am sort of getting it.. but let's see.. It seems like my bauth should be in the context to  and then use it properly
13:37:19 <geekosaur> I don't know what you're doing (I don't generally do web stuff) so I don't think I can help much
13:38:24 <Darwin226> Hey, is there a way to somehow include other text files in my project but in a way that they are always accessable at runtime?
13:38:41 <cocreature> @hackage file-embed
13:38:41 <lambdabot> http://hackage.haskell.org/package/file-embed
13:38:45 <cocreature> ^ Darwin226 
13:39:09 <Darwin226> Yeah, usually this would work but I need it to be an actual file
13:39:24 <Darwin226> it's a powershell script that I need to run with powershell
13:39:25 <enthropy> cabal includes files you list in data-files in the package, and creates a Paths_yourpackagename module that tells you where to find it
13:39:52 <Darwin226> enthropy: Hey hey, what? I didn't know about this. Where are those files put then?
13:40:00 <enthropy> which you can find in dist/build/autogen/Paths_whateveryoupackageiscalled.hs
13:41:10 * enthropy has for example a directory ~/.cabal/share/x86_64-linux-ghc-7.6.3/criterion-0.8.1.0, but it varies between OS / how you install
13:42:30 <Darwin226> This is amazing!
13:43:04 <Darwin226> The only way I can see this going wrong is if the user clones my project, installs it and then removes the source thinking "oh, I already have the executable"
13:43:19 <Darwin226> but that kind of seems unlikely enough that I don't really care
13:43:59 <enthropy> the data files aren't generally installed into somewhere in the source directory
13:46:57 <Darwin226> Oh, even better.
13:52:15 <sword_smith> I have just reinstalled Ubuntu and I need help with installing the correct packages using cabal. I want to install the package that is needed in order for the instruction "import Control.Monad.State.Lazy" to work. That module is used in a compiler that I am writing.
13:53:22 <Shou> sword_smith, mtl
13:56:01 <sword_smith> Shou: Thank you. That worked. I was unable to locate the package name. How do you, in general, find the package name that contains a given module?
13:57:36 <Shou> I generally just google the import and "hackage" and that gives you the package name in the Hackage docs title
13:57:51 <geekosaur> @hayoo module Control.Monad.State.Lazy
13:57:55 <lambdabot> Unknown command, try @list
13:58:05 <geekosaur> @hoogle module Control.Monad.State.Lazy
13:58:07 <lambdabot> No results found
13:58:12 <geekosaur> ... why did I do that, I wanted @hoogle
13:58:47 <geekosaur> sigh
13:59:01 <geekosaur> generally you ask the hoogle on fpcomplete since that has most of the useful stuff
13:59:06 <geekosaur> @where hoogle
13:59:06 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
13:59:26 <geekosaur> hayoo searches all of hackage and askig it about Control.Monad.State.Lazy should work
14:00:26 <sword_smith> geekosaur: That worked. Thank you: https://www.stackage.org/lts-5.11/hoogle?q=Control.Monad.State.Lazy 
14:01:39 <sword_smith> geekosaur: I have previously used <https://www.haskell.org/hoogle/>. Is fpcomplete better? :)
14:02:00 <geekosaur> yes, the haskell.org one only searches the stuff that ships with ghc itself
14:02:14 <geekosaur> fpcomplete's searches everything in stackage
14:03:02 <geekosaur> hoogle can't quite cope with all of hackage yet; hayoo wins there
14:04:22 <sword_smith> Woo! My compiler compiles
14:05:22 <Zemyla> sword_smith: Can you compile your compiler with your compiler?
14:06:10 <shachaf> @let data HList :: [*] -> * where { HNil :: HList '[]; (:!) :: x -> HList xs -> HList (x ': xs) }
14:06:11 <lambdabot>  Defined.
14:06:14 <shachaf> :t let { end (x :! HNil) = x } in end
14:06:16 <lambdabot>     Couldn't match expected type ‘t2’ with actual type ‘x’
14:06:16 <lambdabot>       ‘t2’ is untouchable
14:06:16 <lambdabot>         inside the constraints (xs ~ '[])
14:06:20 <shachaf> Why does that have an inference issue?
14:07:16 <sword_smith> Zemyla: I am writing a compiler for a simple functional-ish language in Haskell. So no, not atm. But I have considered writing a compiler in my language, and then compile it by hand and the put the compiler into the hand-compiled compiler and see if the result agrees with the hand-compiled compiler.
14:07:33 <sword_smith> But I have a day-job and I am also a bit lazy ...
14:07:52 <sword_smith> That was how Donald Knuth solved the bootstrapping problem btw.
14:09:15 <puregreen> what's the easiest way to do splitting with text-icu?
14:09:35 <puregreen> the actual ICU library provides a “split” function, but text-icu doesn't export it
14:10:56 <puregreen> and if you use 'span' like this, it doesn't give you the last match: «map ICU.span $ ICU.findAll "\\s+" " a   b c"» returns ["","a","b"]
14:12:21 <puregreen> (I could add \z to the regex so that another match would be created for end of string, but then it doesn't work on " a b c ")
14:15:46 <Zemyla> Are there any native Haskell regex libraries?
14:16:40 <mmachenry> Zemyla: A bunch: https://wiki.haskell.org/Regular_expressions
14:17:12 <Zemyla> I wish Symbols could be decomposed at compile time.
14:17:23 <verement> puregreen: is there a reason not to use Data.Text.words?
14:17:39 <puregreen> verement: it was just for the sake of example
14:18:25 <puregreen> in reality the regex could be arbitrary
14:19:58 <puregreen> I agree that regexes are often a bad solution, but given that my usecase is literally “I'm writing a small tutorial on using regexes from text-icu”, there's really no other way :)
14:22:47 <Zemyla> Is there such a thing as type-safe regexes?
14:22:58 <verement> puregreen: try "(\\s+|\\z)" as your regex
14:23:11 <byorgey> Zemyla: what would that mean?
14:23:40 <verement> or even without the capture group
14:24:03 <koz_> Zemyla: I too am curious what you mean by 'type-safe'. Regexes only target text.
14:25:02 <Zemyla> Yes, but they return tuples or lists of strings (or lists of tuples of strings, etc.)
14:25:26 <puregreen> verement: doesn't work (see http://lpaste.net/159071), but I think I already found a way
14:25:31 <ski> shachaf : hmm. iiuc, because it's matching on a GADT with indices
14:25:45 <puregreen> I need to use 'span' on all matches and then 'suffix 0' on the last match
14:29:18 <ski> @tell sinelaw "more naming: adding/removing a label from a 'composite', is called what for rows / columns?","\"inject\" is for columns IIRC","(adds a constructor)" -- not sure if you're thinking about adding a label-type-pair to a column, or including a value via a label in a sum type constructed from it. (the former ?). anyway "project" seems to go nice with "inject" ?
14:29:18 <lambdabot> Consider it noted.
14:31:45 <drk_lrd_777_> hi can any one reccomend a good book on recursive decent parsers in haskell
14:32:00 <drk_lrd_777_> I want something which dives deep into monads
14:32:12 <drk_lrd_777_> thats why im looking into monadic parsers
14:32:20 <drk_lrd_777_> anyhelp will be appreciated.
14:32:22 <drk_lrd_777_> Thanks :)
14:34:04 * hackagebot xdcc 1.0.2 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.0.2 (JanGerlinger)
14:35:21 <Zemyla> drk_lrd_777_: They aren't that difficult. Derive the monad instance for the simplest recursive descent parser: String -> Maybe (a, String)
14:38:03 <dmj> drk_lrd_777_: http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf
14:38:13 <dpk-atk> hello
14:38:49 <dmj> @google monadic parser combinators
14:38:50 <lambdabot> http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf
14:38:50 <lambdabot> Title: Monadic Parser Combinators
14:39:04 * hackagebot monad-hash 0.1 - Monad transformer for incremental hashing  https://hackage.haskell.org/package/monad-hash-0.1 (akrasner)
14:40:14 <dpk-atk> I'm a pretty big noob to haskell. Could one of you pros take a look at my code and give some advice how to make it better? :D
14:41:44 <fr33domlover> @where paste
14:41:44 <lambdabot> Haskell pastebin: http://lpaste.net/
14:41:47 <fr33domlover> dpk-atk, ^
14:41:49 <sm> dpk-atk: hmm.. hmm.. add some type signatures
14:42:08 <dpk-atk> http://lpaste.net/159072
14:42:15 <dpk-atk> http://lpaste.net/159077
14:42:15 <vvq> Is there any way to create a type level function which will return `'False` for types of kind `*` and `'True` for types of kind `* -> *`?
14:43:00 <sm> dpk-atk: looks fine. hlint will give you more ideas
14:43:15 <johnw> vvq: that sounds like mapping kinds to types, not types to types
14:43:18 <dpk-atk> i feel iike the fromJust calls are bad
14:43:24 <dpk-atk> and im not sure what to do about them
14:43:59 <sm> if it's a script, I like to include a stack hashbang line with --package options to make it more robust
14:44:14 <sm> ah, yes, hlint would rightly complain about those
14:44:36 <dpk-atk> what exactly do you mean by that
14:44:43 <dpk-atk> sorry i dont know much about stack and nothing about hlint
14:46:04 <sm> your script depends on a package which will probably be missing when you run it in the future.. stack is a tool that can solve that. But never mind
14:46:13 <sm> install hlint first, it's very informative
14:46:14 <vvq> johnw: Note the ticks. I'm imagining something like `foo :: (IsHigherKinded Int ~ 'False, IsHigherKinded Maybe ~ 'True) => ...`
14:46:36 <sm> dpk-atk: in fact, the pink warnings on your paste are from hlint
14:46:55 <sm> and the yellow one, even
14:47:02 <dpk-atk> ah i see
14:47:05 <dpk-atk> thanks a lot
14:47:25 <sm> so it thinks you can use isNothing somehow instead of fromJust
14:47:41 <sm> oh.. no
14:47:58 <sm> ok, I guess it didn't complain about fromJust >:(
14:49:04 <dpk-atk> ah right
14:49:07 <dpk-atk> that seems useful
14:51:31 <sm> hlint a.hs --refactor > b.hs will apply the changes for you
14:51:56 <dpk-atk> oh cool
14:52:02 <mikail_> Hi, I have a question around commenting. I have data type which has 4 fields that are all Decimal so it looks like this: data Foo = Foo Decimal Decimal Decimal Decimal. I don't want to use records because I know the problems around using them and want to avoid them. What would be the best way to comment the code to indicate the meaning of those Decimal fields.
14:52:44 <dmj> mikail_: why not newtype them? Let the types be the documentation
14:53:14 <sm> dpk-atk: I think your validate function could be clarified
14:53:27 <dmj> mikail_: what if you accidentally swap two of them while in a function? GHC will still typecheck
14:53:39 <sm> it's validating, but also performing some IO (? exportEnvVars)
14:53:45 <suppi> yes, as dmj said, newtype will help both with the names and with haskell catching a change of arguments order as a type error
14:54:05 <mikail_> yes that's a good point
14:54:12 <mikail_> i will look into newtype
14:54:14 <mikail_> thanks
14:54:34 <dmj`> mikail_: records are only realy problematic if you use field names with sum types, it introduces partial functions. Or if you have a deeply nested record that needs updating
14:55:18 <mikail_> but i noticed a problem where i had to records both with a field called price and the compiler complained
14:55:25 <EvanR> sums with record fields dont make sense!
14:55:28 <mikail_> *two*
14:55:33 <EvanR> records are products not sums
14:55:52 <dmj`> to avoid data F = L { foo :: String, zoo :: String } | R { bar :: String, woz :: String }
14:55:54 <dmj`> snake types
14:55:58 * dmj` gasps
14:55:59 <EvanR> (otoh this paper on extensible records also includes extensible sums)
14:56:36 <LiveviL> Hello? 
14:56:50 <LiveviL> *sighs*
14:56:56 <dmj`> mikail_: data F = L LType | R Rtype, data LType = L { foo :: String... etc... is how I would avoid that scenario
14:58:30 <dmj`> EvanR: sure, but sums can have constructors with fields
14:59:11 <LiveviL> You guys taking about rc stuff? 
14:59:15 <EvanR> they can but it doesnt make sense
14:59:46 <dmj`> EvanR: yea, agreed
15:02:13 <sm> dpk-atk: and in this simplified example, since both versions are required there's no reason to make them Maybes at all. I guess the real code is more complex
15:03:58 <wedify> LiveviL: rc stuff?
15:05:13 <sm> dpk-atk: you could do something more like http://lpaste.net/159109
15:05:24 <LiveviL> Wedify: sorry, just from small context observed 
15:06:21 <dpk-atk> omg
15:06:26 <dpk-atk> thats exactly what i was looking for :D
15:06:28 <dpk-atk> thanks
15:23:34 <pklausler> back
15:24:54 <pklausler> found another way to write outerProduct :: (a->b->c) -> f1 a -> f2 b -> f1 (f2 c)
15:25:24 <pklausler> outerProduct f xs ys = (<$> ys) <$> (f <$> xs)
15:29:13 <mounty> Hello, there's lots of information in the Yesod documentation and elsewhere about using SQL with TH to generate a safe, strongly-typed interface to SQLite tables etc.
15:29:22 <mounty> But what about when the structure of the tables isn't known at compile-time?
15:29:32 <mounty> In that case, I'd expect to start by obtaining a list of column names from the table, then read each row as a [PersistentValue]
15:29:44 <mounty> What support, and what example code, is available for that?
15:31:18 <EvanR> mounty: TH can access the database to get this information at compile time, if necessary
15:31:46 <EvanR> one of these libs might already do that
15:32:20 <dpk-atk> This is probably a dumb question, but why do so many libraries use monoids so much
15:32:29 <dpk-atk> like why do we care about associativity?
15:32:30 <sm> mounty: seen https://www.schoolofhaskell.com/school/advanced-haskell/persistent-in-detail/existing-database ?
15:32:39 <dpk-atk> outside of parallelization possibly
15:32:44 <dpk-atk> like when composing options
15:32:51 <dpk-atk> it seems deterministic if its not parallelized
15:33:08 <dpk-atk> so shouldn't just having an identity and totality be enough?
15:33:31 <ski> pklausler : i sometimes define
15:33:38 <ski> @let pamf = flip fmap
15:33:39 <lambdabot>  Defined.
15:33:48 <ski> pklausler : and then i can say stuff like
15:34:02 <ski> > [0 .. 3] `pamf` \x -> [x .. 3] `pamf` \y -> (x,y)
15:34:03 <lambdabot>  [[(0,0),(0,1),(0,2),(0,3)],[(1,1),(1,2),(1,3)],[(2,2),(2,3)],[(3,3)]]
15:34:37 <pklausler> yes, flip fmap is handy; should be <$$> as an analogue to <**>
15:35:05 * ski thinks `<*>' ought to have been named `<$>' anyway ..
15:35:18 <pklausler> maybe <$$> already exists?
15:35:22 <pklausler> :t (<$$>)
15:35:24 <lambdabot>     Not in scope: ‘<$$>’
15:35:24 <lambdabot>     Perhaps you meant one of these:
15:35:24 <lambdabot>       ‘<$>’ (imported from Control.Applicative),
15:35:28 <pklausler> nope
15:35:36 <EvanR> dpk-atk: monoids pop up everywhere, when you see the <> operator you instantly get a feel for what this lib is like
15:35:50 <EvanR> and you know there an some mempty that is something
15:35:51 <ski> there's something in Parsec, but it looks different
15:35:55 <EvanR> and you know what it does
15:36:05 <EvanR> you can also parameterized your library of a choice of monoid 
15:36:09 <pklausler> if (<$>) were (<*>) instead, what would (<*>) become?
15:36:12 <EvanR> over a choice of monoid*
15:39:14 <dpk-atk> right but why cant something similar to <> be defined for operations that aren't associative in a typeclass that doesnt demand associativity 
15:39:46 <dpk-atk> and why is that a bad solution to something like composing parser options
15:39:55 <dpk-atk> like why is associativity useful
15:40:49 <pklausler> mconcat
15:42:34 <mounty> sm: thanks
15:42:51 <Cale> dpk-atk: Well, there are a lot of reasons you might want associativity. One is if you want to be able to rebalance trees whose branches are indexed with combinations of the elements in the leaves. Associativity is exactly the condition you need to be able to recompute the indices efficiently when doing a tree rotation.
15:42:52 <pklausler> hmm, i see that mconcat is documented as needing to work as if defined by foldr, so never mind
15:43:51 <Cale> mconcat is documented that way with the understanding that mappend is associative though :)
15:44:57 <pklausler> sure, but it would remain well-defined even if mappend weren't; i was hoping that one could define mconcat with either foldr or foldl, because associativity, but i guess you can't
15:45:33 <Cale> There are various reasons why an implementor of an algorithm might rely on associativity of an operation when refactoring it.
15:46:32 <pklausler> non-commutative operations are not uncommon in mathematics, but non-associative operations are harder to come up with examples for
15:47:23 <Cale> Well, subtraction :)
15:48:14 <Cale> But yeah, for stuff which is more fundamental, there's the Lie bracket and not a whole lot else.
15:48:42 <Cale> Oh, and the cross product
15:48:52 <pklausler> right
15:49:09 <pklausler> and exponentiation, i suppose
15:49:20 <Cale> (both of which satisfy the Jacobi identity, interestingly)
15:49:31 <dpk-atk> but couldn't a version of mconcat be made that doesn't care about associativity?
15:49:35 <dpk-atk> i mean its just a fold
15:49:41 <ski> dpk-atk : associativity makes refactoring (e.g. unfolding/folding definitions) easier
15:50:13 <pklausler> mconcat today doesn't care, it's foldr
15:50:54 <mounty> sm:  no;  that SoH page still uses TH with compile-time data type.
15:50:58 <dpk-atk> doesn't this add restrictions tho, like for instance now u cant use <> in a class that functions like subtraction
15:50:59 <pklausler> i mean to say, mconcat doesn't assume associativity, there's a fixed order of operation
15:51:38 <dpk-atk> (Sub 3) <> (Sub 2) <> (Sub 1) could be like useful
15:51:46 <dpk-atk> but now it cant use functions that require monoids
15:51:52 <dpk-atk> even tho those functions are meaningful
15:51:52 <mounty> sm:  I mean the situation where you're writing an application like pgadmin for example which will work with any table.
15:53:02 <pklausler> perhaps one could contend that mconcat is broken, since subtraction is infixl;  a - b - c groups as (a-b)-c, but mconcat uses foldr
15:53:14 <ski> pklausler : loops, bol loops, gyrogrops, moufang loops, loops with power-associativity
15:56:32 <Cale> ski: Though really, once you're into that territory, you're almost doing combinatorics of Latin squares moreso than algebra. :)
15:56:45 <ReinH> pklausler: well, subtraction doesn't form a monoid.
15:56:54 <Cale> gyrogroups are a bit different, granted
15:57:01 <ski> dpk-atk : `mconcat' is expected to satisfy `mconcat (ms0 ++ ms1) = mconcat ms0 <> mconcat ms1'. `mconcat' should be (the canonical) monoid morphism from the initial monoid over `m' (iow lists of `m's) into the monoid `m'
15:57:02 <Cale> They're sort of "almost associative"
15:57:24 <ReinH> A version of mconcat that doesn't care about associativity would not be mconcat, it would just form a magma.
15:57:35 * ski nods
15:57:44 <Cale> Yeah, if there weren't the need for associativity, you wouldn't just want mconcat
15:57:58 <Cale> you'd want at least the left associating product and the right associating product
15:58:11 <ski> dpk-atk : the implementation doesn't specify the expected behaviour. it's just one way of implementing it
15:58:12 <ReinH> and if you want to specify associativity, hey look there's foldr and foldl.
15:58:15 <Cale> Or perhaps simply something which explicitly took a tree structure as an argument
15:58:24 <Gurkenglas> What do you call (->)? A type constructor constructor?
15:58:34 <xa0> lol
15:58:40 <pklausler> ski: mconcat documented in terms of foldr, though
15:58:45 <ReinH> Gurkenglas: (->) is the type constructor that constructs functions.
15:58:46 <Cale> Gurkenglas: It's still just a type constructor. It's also a type of kind * -> * -> *
15:58:48 <ski> Gurkenglas : a type constructor, of course
15:58:57 <ReinH> (function types)
15:59:15 * ski thinks it's a bit strange to call stuff like `Either String' "type constructors"
15:59:41 <ski> (i understand where that terminology is coming from, though)
15:59:43 <Cale> Integer is also a type constructor... though I think if we're not being rigid prescriptivists there's sort of two common senses of the word, and it only fits one of them
15:59:59 <pklausler> ski: IIUIC, Either String is a type, not a TC, yes?
16:00:01 <ski> yes, there's two different nomenclatures here
16:00:10 <ski> pklausler : depends on who you ask :)
16:00:15 <Cale> "type constructor" gets used to mean "type function" a lot
16:00:16 <pklausler> ok, ask me
16:00:23 <ReinH> A binary type constructor. But of course type constructors are curried. So. A unary type constructor that constructs a unary type constructor that constructs a type.
16:00:32 <ReinH> Which is itself a nullary type constructor.
16:00:39 <ReinH> So maybe let's just say "type constructor".
16:00:54 <Cale> ReinH: Well, (->) String really ought not to be called a type constructor...
16:00:55 <ski> some people call every type expression with kind of shape `... -> ...' a "type constructor" (well, at least if the latter `...' "ends" with a `*', as opposed to a `Constraint', say)
16:01:01 <dpk-atk> right, I get that, but I'm just wondering why a class with just totality and identity couldn't just implement left/right (mconcat) and then monoids just use this super classes mconcat with the caveat that it obeys the mconcat monoid laws
16:01:05 <ReinH> Cale: ought it not? What about Either String?
16:01:14 <pklausler> why can't we call things with kind * types and be done with it?  confused, i am
16:01:20 <Cale> ReinH: In the same way that you wouldn't call Left Nothing a data constructor
16:01:38 <ReinH> dpk-atk: what properties do monoids have that this super-class lacks? I think you're just defining monoids in a different way.
16:01:49 <Cale> (even though Left and Nothing are both data constructors, the application of one to the other isn't)
16:02:03 <ReinH> Cale: how is that the same? Left Nothing is a value that is not a function. Either String takes a type and gives a type.
16:02:09 <ski> dpk-atk : "totality" being ?
16:02:13 <dpk-atk> the monoid has associativity
16:02:18 <Cale> ReinH: Well, fair enough, (,) Nothing then
16:02:19 <ski> dpk-atk : and what's "left/right (mconcat)" ?
16:02:22 <dpk-atk> superclass is not associative
16:02:25 <Cale> ReinH: Is that a data constructor? :)
16:02:27 <ReinH> dpk-atk: so you're asking for a "magma".
16:02:33 <mikail_> @messages
16:02:33 <lambdabot> You don't have any messages
16:02:35 <ReinH> And magmas exist, but they are generally not very useful.
16:02:37 <dpk-atk> yeah i think thats it
16:02:45 <dpk-atk> i dont know categorytheory/abstract algebra
16:02:48 <ski> pklausler : for similar reason that `not' is also a value (a function value)
16:02:52 <ReinH> And so we don't have a class for them in base
16:03:04 <dpk-atk> but i dont understand why magmas don't solve the issues that most library writers who use monoid have
16:03:08 <Cale> dpk-atk: What we do have is the other superclass of monoid
16:03:12 <ReinH> The algebraic hierarchy could be much better filled out and much more granular
16:03:16 <ReinH> we have ones that we tend to use
16:03:27 <Cale> dpk-atk: Semigroups show up a bit more often than nonassociative algebras
16:03:35 <ReinH> We could have Left Zero Semigroups too, and maybe some package does, but generally we don't use them much.
16:03:43 <Cale> heh
16:03:47 <dpk-atk> semigroups are the ones without an identity right?
16:03:50 <ReinH> Right.
16:03:51 <Cale> right
16:03:57 <ReinH> And there is a useful module for semigroups
16:04:00 <dpk-atk> what are left zero semigroups
16:04:05 <ReinH> semigroups with a left zero. :D
16:04:12 <Cale> http://hackage.haskell.org/package/semigroups
16:04:12 <pklausler> without necessarily having an identity, that is
16:04:14 <dpk-atk> ohhhh
16:04:16 <dpk-atk> i see
16:04:24 <ski> dpk-atk : just abstract algebra (universal algebra, if you want more generality. only after that, category theory)
16:04:29 <ReinH> and a left zero is, of course, a zero on the left.
16:04:43 <ski> s/generality/generality and uniformity/
16:05:19 <ReinH> Rather, a left zero semigroup is a semigroup where *every* element is a left zero.
16:05:45 <dpk-atk> would I be correct in saying that a semigroups version of mconcat could be implemented using foldr1
16:05:57 <ReinH> dpk-atk: Here is a list of things that we could include in the algebraic typeclass hierarchy/lattice if we wanted to be super complete https://en.wikipedia.org/wiki/Special_classes_of_semigroups
16:06:06 <ski> dpk-atk : yes
16:06:07 <Cale> dpk-atk: yeah, though you'd probably want it to be Nonempty a -> a
16:06:13 <ReinH> So necessarily we must be rather summary ;)
16:06:23 <ski> (what Cale said)
16:06:37 <Cale> and indeed...
16:06:37 <dpk-atk> i see
16:06:40 <Cale> :t sconcat
16:06:41 <lambdabot>     Not in scope: ‘sconcat’
16:06:41 <lambdabot>     Perhaps you meant one of these:
16:06:41 <lambdabot>       ‘concat’ (imported from Data.List),
16:06:44 <dpk-atk> so we use monoids for practical reasons
16:06:46 <ReinH> https://hackage.haskell.org/package/semigroups-0.18.1/docs/Data-Semigroup.html#v:sconcat
16:06:46 <Cale> aw, no semigroups for us
16:06:48 <ReinH> And so it is.
16:06:56 <ReinH> dpk-atk: We use monoids for many practical purposes.
16:06:58 <ReinH> Like adding.
16:07:05 <ReinH> And concatenating strings.
16:07:13 <ski> @let import Data.Semigroup
16:07:14 <lambdabot>  Defined.
16:07:16 <ReinH> The latter of which contains all of programming.
16:07:22 <ski> @type sconcat
16:07:23 <lambdabot> Semigroup a => Data.List.NonEmpty.NonEmpty a -> a
16:07:29 <Cale> dpk-atk: Yeah, there are real applications of all the common type classes
16:07:37 <ReinH> (Which is why they are included)
16:07:45 <dpk-atk> how would you do the analogue of (Sub 10) <> (Sub 5) <> (Sub 2) 
16:07:47 <Cale> dpk-atk: One example I like to give is that there's a Monoid instance for Ordering
16:07:54 <ReinH> dpk-atk: You wouldn't, because subtraction is not associative.
16:08:00 <dpk-atk> right
16:08:03 <ReinH> > 1 - 2 - 3
16:08:04 <dpk-atk> but that seems like a useful thing
16:08:05 <lambdabot>  -4
16:08:08 <dpk-atk> like in a magma class
16:08:10 <ReinH> (-) is already properly (left) associative
16:08:11 <orion> Is it considered rude to force users to import Lens if they want to interact with your library?
16:08:12 <dpk-atk> make soemthing like <m>
16:08:20 <Cale> data Ordering = LT | EQ | GT is a type which is used to represent the results of comparisons (less than, equal, or greater than)
16:08:32 <ReinH> orion: it doesn't seem to be
16:08:39 <ReinH> given how many popular libraries do so
16:08:57 <puregreen> orion: I wouldn't consider it rude and usually when a library makes me do that I assume it's because it's going to be easier for me this way
16:09:05 <dpk-atk> thanks so much for help
16:09:12 <ReinH> dpk-atk: Sure, we could have two classes to represent the two associativities. We just haven't found much need for them.
16:09:25 <ReinH> Maybe they exist in a package somewhere.
16:09:26 <dpk-atk> do you nkow any good resources to learn the required abstract algebra/category theory
16:09:31 <dpk-atk> ive just been looka t wikipedia
16:09:36 <Cale> dpk-atk: The monoid instance for Ordering has  EQ <> y = y, and x <> y = x otherwise, i.e. we use the result on the left unless the things compared as equal, in which case we use the result on the right.
16:09:38 <pklausler> similar comments for rings, fields, etc.
16:09:39 <ReinH> dpk-atk: I do. http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
16:09:51 <dpk-atk> thanks
16:09:58 <Cale> dpk-atk: There's also an instance (Monoid a) => Monoid (e -> a), which combines functions by combining their results
16:10:05 <ReinH> dpk-atk: These days I would also add to the list http://www.amazon.com/Category-Cambridge-Studies-Advanced-Mathematics/dp/1107044243
16:10:08 <pklausler> also not associative: floating-point operations
16:10:17 <ReinH> pklausler: we like to pretend though.
16:10:18 <Cale> dpk-atk: and hence, e -> e -> Ordering, the sort of thing you give to sortBy, is also a monoid
16:10:44 <Cale> > sortBy (comparing length <> compare) (words "here is a bunch of words to sort by length and then alphabetically")
16:10:44 <ski> dpk-atk : you could possibly try the (slow-going) book "Conceptual Mathematics" by Steve Schanuel and Willian Lawvere. it's basic Category Theory, not assuming you know lots of other math fields
16:10:45 <lambdabot>      Ambiguous occurrence ‘<>’
16:10:45 <lambdabot>      It could refer to either ‘Data.Monoid.<>’,
16:10:45 <lambdabot>                               imported from ‘Data.Monoid’ at /tmp/mueval16425...
16:10:51 <Cale> ...
16:10:54 <Cale> @undefine
16:10:54 <lambdabot> Undefined.
16:10:56 <Cale> > sortBy (comparing length <> compare) (words "here is a bunch of words to sort by length and then alphabetically")
16:10:58 <lambdabot>  ["a","by","is","of","to","and","here","sort","then","bunch","words","length"...
16:11:16 <dpk-atk> i see
16:11:19 <orion> Is there a shortcut for exporting Lenses
16:11:41 <Gurkenglas> Does the Reader functionality provided by ?x have an equivalent to local? If would be nice to have things like 'let ?errormsg = "mconcat" in foldr1'
16:11:48 <ReinH> Cale: one of my favorite monoids.
16:11:56 <ski> dpk-atk : there's also a "Sets for Mathematics" by William Lawvere and Robert Rosebrugh, which isn't that hard in the earlier part, iirc
16:12:03 <puregreen> orion: if you mean “export all lenses generated for fields of a record”, then I've never seen any
16:12:23 <pklausler> not sure that it's faster to compare lengths first, though
16:12:39 <pklausler> ah, never mind.
16:13:04 <dpk-atk> thx for the help
16:13:25 <Cale> http://projects.haskell.org/diagrams/doc/manual.html#essential-concepts -- there are also lots of great examples of monoids used in the diagrams library
16:13:52 <orion> puregreen: I see. Do libraries normally re-export Control.Lens, or do they make the user import it themselves?
16:13:59 <ReinH> (fwiw sortBy uses mergesort)
16:14:21 <ReinH> Other nice examples of monoids include bloom filters, hyperloglog, a few other interesting data structures.
16:15:03 <ReinH> and the monoid for bloom filters is incredibly performant, being a bitwise OR of two bit vectors.
16:15:17 <ReinH> and a zeroed out bit vector for the identity.
16:15:34 <puregreen> orion: I'm not sure, to be honest
16:15:38 <ReinH> so literally 0 and ||
16:15:51 <puregreen> I know that wreq doesn't, for one
16:15:53 <Tehnix> I know that wreq doesn't, for one
16:16:37 <ski> > let f :: (?x :: Integer) => ((?x :: Integer) => o) -> o;f x = let ?x = ?x + 1 in x in let ?x = 0 in f ?x  -- Gurkenglas
16:16:38 <lambdabot>  1
16:17:22 <dpk-atk> so the monoid for bloom filters is the set (\x y -> x || y, 0x0000000000)
16:17:35 <dpk-atk> is that the monoid on the hashing operation of bloom filter?
16:17:50 <ski> (this is an example of an `f' that's referentially opaque. the meaning of `?x' outside the `f ...' context is different to the meaning of it inside)
16:18:13 <ReinH> The underlying representation of a bloom filter is a bit vector
16:18:25 <ReinH> the monoid operates on bit vectors
16:18:51 <ReinH> with 0s for identity and bitwise OR for multiply
16:19:14 <ski> Gurkenglas : did you get that ?
16:19:24 <Gurkenglas> ski, parsing
16:20:02 <ReinH> s/0s/an empty bit vector
16:21:11 <ski> Gurkenglas : without the explicit rank-2 signature, it doesn't work (not surprising, since GHC doesn't infer rank-2. though istr reading that it *is* inferrable (but not higher-ranks). perhaps that only holds for the plain `forall' rank thing, not for class constraints and dynamic scope^Wextend^W^Wimplicit parameters constraints, though)
16:21:15 <dpk-atk> ah i see
16:25:17 <Gurkenglas> ski, parsing complete. I now see that this isn't enough for the 'let ?errormsg = "mconcat" in foldr1' I was hoping for - it would require default values for ?errormsg or I would have to specify ?errormsg = "foldr1" for every regular use. Is there something for that?
16:27:59 <ski> Gurkenglas : so `f' is basically doing an `local (+ 1)' wrt `?x'. or i suppose you might think of something like `local (over _?x (+ 1))', lens-wise
16:28:55 <Gurkenglas> Ya I got that and realized I had asked the wrong question, it needs defaults not local :D
16:29:00 <ski> Gurkenglas : i don't recall seeing default values (at module level, i suppose, perhaps exportable)
16:29:06 <Gurkenglas> (Defaults feel pretty dual to local, btw)
16:29:21 <ski> hm, i suppose it's "at the other end"
16:37:43 <alexashka> hi guys, maybe somebody can help me through this: I am looking at http://dev.stephendiehl.com/hask/#mtl-transformers - there's a simple looking example of Reader T with type Eval a = ReaderT Env Maybe a
16:38:34 <alexashka> from my limited understanding - ReaderT has the type of ReaderT environment monad output
16:39:05 <alexashka> so that reads env, monad. The output is a. But when I run the example, the output is Maybe a
16:40:07 <alexashka> so I'm at a loss here :) I don't understand monad transformers clearly
16:46:09 <oranje> It reads only env, in order to produce a value in the lower monad (Maybe, in this case)
16:47:12 <oranje> Intuitively, it's a monadic computation in Maybe, parameterized by some Env.
16:49:51 <ski> @unmtl ReaderT Env Maybe a
16:49:53 <lambdabot> Env -> Maybe a
16:50:07 <ski> alexashka ^
16:50:17 <alexashka> ya, you're right I just checked the signature of runReaderT, it is ma, not a
16:50:24 * ski nods to roconnor
16:50:35 <ski> @type runReaderT
16:50:37 <lambdabot> ReaderT r m a -> r -> m a
16:50:38 <ski> @type runReader
16:50:39 <lambdabot> Reader r a -> r -> a
16:52:42 <alexashka> hm, let me see if I am getting this right then - lookup "variable" env produces 'Maybe a'. Then when it is lift (lookup "variable" env) that wraps the Maybe a in what? ReaderT Env Maybe a?
16:55:43 <roconnor> hi ski
16:56:07 <drk_lrd_777_> zemyla: thanks
16:56:16 <drk_lrd_777_> dmj: thanks!
16:58:45 <alexashka> another question: why does toMonad a = return a compile? Doesn't it need a type signature to know which implementation to use?
16:58:54 <hpc> what's the syntax for enumFromThenTo?
16:59:06 <hpc> i could have sworn it was [0, 10, .., 100]
16:59:06 <EvanR> :t return 
16:59:07 <lambdabot> Monad m => a -> m a
16:59:14 <hpc> > [0, 10, .., 100]
16:59:15 <lambdabot>  <hint>:1:9: parse error on input ‘..’
16:59:19 <EvanR> alexashka: it will get the most general type signature automatically
16:59:22 <Zemyla> @let tomonad a = return a
16:59:24 <lambdabot>  Defined.
16:59:27 <Zemyla> :t tomonad
16:59:28 <lambdabot> Monad m => a -> m a
16:59:32 <hpc> > [0, 10 .., 100]
16:59:33 <lambdabot>  <hint>:1:10: parse error on input ‘,’
16:59:37 <hpc> > [0, 10 .. 100]
16:59:38 <lambdabot>  [0,10,20,30,40,50,60,70,80,90,100]
16:59:49 <EvanR> alexashka: toMonad ends up being polymorphic, works with any monad
16:59:49 <hpc> oh bah
17:00:17 <alexashka> @EvanR hm, meaning there's a default implementation for return that simply returns the value given to it?
17:00:17 <lambdabot> Unknown command, try @list
17:00:22 <EvanR> no
17:00:42 <EvanR> what the function does depends on where you use it
17:00:54 <EvanR> at that point the specific monad will be chosen
17:01:04 <Axman6> > let toMonad a = return a in (toMonad 1 :: [Int], toMonad 1 :: Maybe Int)
17:01:06 <lambdabot>  ([1],Just 1)
17:01:07 <alexashka> oh, when I'm simply using it in ghci, it's using IO... Right?
17:01:14 <Axman6> yes
17:01:21 <alexashka> *slaps forehead* :D
17:01:26 <EvanR> its defaulting to IO in ghci... wonderful ;)
17:06:27 <mounty> Why are so many cross-references in Hackage wrong?
17:06:49 <mounty> E.g., https://hackage.haskell.org/package/persistent-2.1.1/docs/Database-Persist-Sql.html then follow the link to withStmt
17:07:31 <mounty> Are these pages maintained by hand?
17:07:54 <Axman6> they should be generated automatically
17:08:37 <meditans> hi all, I need some pointer on type level programming. At this point I'm quite familiar with the possibilities of the extensions around, but I need to create a precise model of how the computation happens at the type level (so that I can visualize the computational steps in my head, as I do with term-level code)
17:08:47 <meditans> could you point me towards some resources?
17:09:05 <mounty> Axman6:  I agree, but the fact remains that they are frequently broken, in my experience of trying to navigate around the Persistent documentation.
17:13:03 <meditans> an example of a question I have is: when I use, let's say, a type family, at what stage is the computation performed? What happens before and what after that stage?
17:13:56 <ski> roconnor : just checking whether you're alive :)
17:14:31 <oranje> meditans: I can't give you an answer (I'd like to know it myself) but I think Richard Eisenberg's publications might lead you in the right direction https://www.cis.upenn.edu/~eir/pubs.html
17:14:32 <ntnt> how does I convert a length 4 hex string to an integer ?
17:15:22 <EvanR> :t readHex
17:15:24 <lambdabot> (Eq a, Num a) => ReadS a
17:15:45 <EvanR> > readHex "f00f" "" :: Integer
17:15:47 <lambdabot>      Couldn't match expected type ‘[Char] -> Integer’
17:15:47 <lambdabot>                  with actual type ‘[(Integer, String)]’
17:15:47 <lambdabot>      The function ‘readHex’ is applied to two arguments,
17:15:49 <dpk-atk> hey, could someone please explain kinds to me
17:15:55 <meditans> oranje: thanks, do you have any specific pick among those papers?
17:16:17 <dpk-atk> i read some articles but they aren't really helping me develop an intuition for htem
17:16:24 <ski> > (readHex :: ReadS Integer) "f00f"
17:16:25 <lambdabot>  [(61455,"")]
17:16:40 <EvanR> 00f
17:16:40 <ntnt> ski: thanks
17:16:41 <meditans> dpk-atk: I'll try to give you an intuition then, and others will chime in to correct my mistakes xD
17:17:07 <ski> > (readHex :: ReadS Integer) "f00fgruff"
17:17:08 <lambdabot>  [(61455,"gruff")]
17:17:13 <meditans> dpk-atk: so, the main intuition is that kinds classify types as types classify terms
17:17:44 <meditans> for example, all the ints are classified into the Int type, all the strings in String etc
17:17:51 <ski> ntnt : so either check that the remaining string is empty, or grab it and continue
17:17:58 <dpk-atk> right
17:18:06 <dpk-atk> so ints, and strings have the same "kind" right
17:18:12 <meditans> at the type level, the starting situation is a bit different: the first kind you encounter is *
17:18:25 <meditans> dpk-atk: yes, and that kind is *
17:18:25 <EvanR> i like the constructive way, "" is a string, and for any char c and string s, c:s is a string too
17:18:42 <EvanR> and nothing else is a string
17:18:46 <meditans> dpk-atk: because * is the kind which classifies the `inhabited` types
17:18:55 <Rembane> EvanR: So you can prepend any character to a string?
17:18:57 <ski> ntnt : `[n | (n,"") <- readHex s]' or `[n | (n,s1) <- readHex s0,("","") <- lex s1]' may be useful
17:19:09 <meditans> which is to say, the types which have values (terms)
17:19:15 <EvanR> Rembane: yeah
17:19:19 <ski> (s/inhabited/inhabitable/)
17:19:27 <Rembane> EvanR: Sweet!
17:19:32 <ntnt> ski: doesn't that given weird failures if it doesn't quite match ?
17:19:33 <EvanR> sarcasm?
17:19:58 <meditans> dpk-atk: so, if you can offer a concrete term of a type, that type has kind *
17:20:02 <ski> ntnt : it gives a list of number
17:20:18 <dpk-atk> so any type with one data constructor that has no arguments is kind *
17:20:20 <dpk-atk> ?
17:20:33 <Axman6> > let s = "ell" in ['h':s,'b':s,'s':s]
17:20:34 <oranje> meditans: nevermind, I suppose this paper is the one to read https://www.cse.unsw.edu.au/~chak/papers/tc-tfs.pdf
17:20:35 <lambdabot>  ["hell","bell","sell"]
17:20:46 <dpk-atk> err value constructor
17:21:15 <meditans> dpk-atk: you don't need to have only one data constructor, per se
17:21:15 <meditans>  
17:21:40 <meditans> data Foo = Bar | Baz | Qux Int String has kind *
17:21:48 <ski> dpk-atk : any *unparametrized* data type that you define will have kind `*'
17:22:22 <meditans> dpk-atk: exactly ^^^
17:22:42 <meditans> instead, if you begin to parametrize, like in:
17:22:50 <meditans> data Foo a = Bar String a
17:23:11 <ski> or even `data Ignore a = Ignored'
17:23:18 <athan> Hi everyone, I was wondering how `()` could be used as a Constraint, such that the type itself might be overloaded. For instance, check this out:
17:23:19 <meditans> Foo will have kind * -> *, because by itself you have to supply foo with a thing of kind * to get a concrete type
17:23:53 <athan> @let foo = 1 :: () => Int
17:23:54 <lambdabot>  Defined.
17:23:58 <athan> :t foo
17:23:59 <lambdabot> Int
17:24:06 <athan> @undefine
17:24:06 <lambdabot> Undefined.
17:24:25 <ski> dpk-atk : while in `data Baz a = MBaz (a String)', `Baz' will get kind `(* -> *) -> *', since `a' gets the inferred kind `* -> *' here
17:24:39 <athan> The `()` constraint is just thrown away, which is fine, but I'd like to programmatically use `()` as a `Constraint` without the need for the type annotation `::`
17:24:49 <meditans> dpk-atk: you can inspect the kind of a type in ghci, with the command ":k" (in the simple cases)
17:24:58 <athan> or really, is there a `Unit` constraint?
17:25:00 <ski> @type let foo :: () => Int; foo = 1 in foo
17:25:01 <lambdabot> Int
17:25:01 <pavonia> athan: () is the empty constraint, no?
17:25:25 <athan> pavonia: It is, but specifically it is not a Constraint, because the `()` symbol is the type `data () = ()`
17:25:27 <meditans> dpk-atk: do you have any question on this part?
17:25:31 <athan> when the name is used
17:25:34 <dpk-atk> i see
17:25:39 <dpk-atk> what about something like
17:25:45 <athan> pavonia: But if you use it in a type annotation, it magically works
17:25:49 <athan> like how I did with `foo`
17:26:02 <dpk-atk> data Mytype = KindStar | Kind2Star a
17:26:09 <geekosaur> athan, I think it's just syntax at that level
17:26:14 <ski> dpk-atk : `a' not in scope
17:26:20 <geekosaur> unrelated to the data type () or the ddata constructor ()
17:26:20 <dpk-atk> data Mytype = KindStar | Kind2Star String
17:26:30 <meditans> dpk-atk: is your datatype parametrized?
17:26:31 <oranje> Yes I imagine () is parsed to something different depending on where it appears
17:26:45 <ski> dpk-atk : `KindStar :: Mytype' and `Kind2Star :: String -> Mytype', also `Mytype :: *'
17:26:48 <dpk-atk> well for both cases
17:26:49 <pavonia> Yeah, I think so to, just like "derving ()"
17:26:53 <ski> dpk-atk : no `* -> *' in sight
17:27:05 <pavonia> *too
17:27:13 <dpk-atk> ahhhh i see
17:27:17 <dpk-atk> that explains everything
17:27:22 * ski smiles
17:27:24 <athan> geekosaur: Yeah I think you're right
17:27:58 <dpk-atk> i was confusing data constractor params with value constructor params
17:28:39 <dpk-atk> what about soemthing like (*->*) -> *
17:28:44 <dpk-atk> what does that even mean
17:29:25 <meditans> well, is the kind of a thing which is parametrized on something of kind * -> *
17:29:40 <meditans> for example, [] has kind * -> *, or Maybe
17:29:58 <ski> dpk-atk : consider `type List ref a = ref (Cell ref a); data Cell ref a = Nil | Cons a (List ref a)'. `List IORef a' is like a list, but with the tails indirected through `IORef's
17:30:13 <EvanR> some type constructors take other type constructors as arguments
17:30:48 <EvanR> like map is a function that takes functions as arguments
17:31:34 <ski> dpk-atk : or consider `data Tree shape a = Leaf a | Branch (shape (Tree shape a))'. if you define `data Two a = MkTwo a a', then `Tree Two a' is a binary tree. `Tree [] a' is an tree with any number of children in the nodes, &c.
17:32:41 <dpk-atk> oh wow
17:32:42 <meditans> ski: this `Tree shape a` example is perfect
17:32:44 <dpk-atk> that second example
17:32:47 <dpk-atk> is great
17:33:02 * ski smiles
17:33:21 <meditans> dpk-atk: try to spell the kind of Tree in that example
17:33:48 <dpk-atk> * -> * -> *
17:33:56 <ski> not quite. try again ?
17:34:20 <arahael> Blegh.  So I have a lazy bytestring, is this not compatible with the breakSubstring in Data.ByteString?
17:34:29 <Axman6> no
17:34:45 <arahael> Is there a reason why there's no lazy version of breakSubstring?
17:34:50 <Axman6> there's probably a Data.ByteString.Lazy.breakSubstring
17:34:57 <Axman6> you sure there isn't?
17:35:02 <arahael> None that i can see. :(
17:35:07 <dpk-atk> lol. im not sure, (* -> *) -> *?
17:35:20 <Axman6> dpk-atk: closer
17:35:24 <ski> dpk-atk : better :) but not quite there
17:35:31 <arahael> Axman6: I'm looking here: https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html
17:35:57 <meditans> dpk-atk: maybe think about what type parameters that type takes, and what types does construct
17:36:11 <arahael> Axman6: And here: https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html
17:36:16 <dpk-atk> hmmm
17:36:50 <Axman6> arahael: you can always use toStrict... but that seems annoying, and could result in lots of memory usage if you're using lazy IO
17:36:56 <dpk-atk> * -> (* -> *) -> *
17:36:57 <meditans> oranje: thanks for the precise paper :)
17:37:05 <arahael> Axman6: Which I am. I'm using this to parse a mbox file.
17:37:20 <Axman6> dpk-atk: do you agree that Tree shape a has kind *? what kind does Tree shape have? and then Tree?
17:37:48 <Axman6> arahael: any reason not to use a proper parser?
17:37:57 <meditans> dpk-atk: closer, yes, but you may want to pay attention to the order of the parameter in Tree
17:38:04 <arahael> Axman6: Such as Data.MBox?  It assumes that the mbox is unicode text.
17:38:15 <dpk-atk> (* -> *) -> * -> 8
17:38:16 <arahael> Axman6: Whereas, in practice, the encoding is actually undefined at this level.
17:38:21 <dpk-atk> (* -> *) -> * -> *
17:38:24 <arahael> Axman6: (And fails to load my INBOX)
17:38:25 <meditans> dpk-atk: that's it :)
17:38:29 <dpk-atk> there we go
17:38:31 <Axman6> arahael: such as attoparsec
17:38:48 <dpk-atk> so shape has kind (*-*)
17:38:55 <dpk-atk> and then it takes in a * parameter
17:39:30 <arahael> Axman6: It's probably a good excuse for me to learn that, though my approach was to just chunk the mbox into each message, and then use an existing haskell parser on those.
17:39:30 <ski> dpk-atk : you can also think of it as `Tree :: (* -> *) -> (* -> *)'
17:39:52 <lethjakman> So, I'm having an issue in hamlet where: No instance for (IsString a0) arising from the literal ‘"Logout"’
17:40:11 <ski> dpk-atk : if we had fixed the content type in the leaves, instead of parameterizing over it, we'd have had just `(* -> *) -> *'
17:40:16 <arahael> Axman6: You can get nearly all the way there with just splitting on "\nFrom ".
17:40:18 <lethjakman> I tried adding :: Text and :: String
17:40:21 <Axman6> arahael: you could always improve the current package too =)
17:40:27 <lethjakman> But it always says "Illegal data constructor name '::'
17:40:36 <lethjakman> Is there a good way to declare a Text in hamlet?
17:40:37 <arahael> Axman6: To improve the current Data.MBox, I'd need to remove the use of Text, and replace it with ByteString.
17:40:59 <Axman6> arahael: does it read the data in as Text and then parse it? that seems broken
17:41:09 <arahael> Axman6: No, it expects a lazy stream of Text.
17:41:21 <arahael> Axman6: So, yeah... The parser expects you to parse the mbox file first(!)
17:41:24 <Axman6> that's lame and broken
17:41:37 <arahael> Axman6: Especially once you realise that messages can be in any encoding.
17:41:46 <Axman6> does the MBox format have metadata telling you what encoding the message is it?
17:41:54 <arahael> Axman6: No.
17:41:59 <Axman6> s/ it/
17:42:08 <Axman6> well that makes life much harder
17:42:25 <Axman6> though, in that case you should just be treating the messages as ByteStrings
17:42:48 <arahael> Axman6: Not really.  mbox formats delegates that to the message format.  It's basically an archive of messages.
17:43:14 <Axman6> right, but somewhere the encoding needs to be recorded, or it could be anything
17:43:23 <Axman6> does the message specify its encoding?
17:43:32 <arahael> Axman6: That's just it. It literaly coudl be anything.  *hopefully* the message specifies the encoding.
17:43:42 <arahael> Axman6: We are talking about email here.
17:43:42 <athan> higher-order typeclasses ftw
17:43:59 <EvanR> o_O
17:43:59 <meditans> dpk-atk: was this part clear, till now?
17:44:17 * hackagebot unit-constraint 0.0.0 - Extremely simple typeclass  https://hackage.haskell.org/package/unit-constraint-0.0.0 (athanclark)
17:45:41 <arahael> Axman6: The main reason I didn't look at using attoparsec, though, was that at the mbox level, the parsing is really, really sipmle.
17:45:44 <arahael> *simple
17:45:47 <Axman6> arahael: right, so there are two separate parsers needed, one which parses MBox items with a bytestring for the email contents, and another which (attempts to) parse the actual messages
17:45:56 <arahael> Axman6: Indeed.
17:46:11 <arahael> Axman6: It's further complicated by mbox files not really being entirely documented.
17:46:18 <Axman6> great, I expect to see it on hackage by the end of the day :P
17:46:22 <arahael> It's not a standard file format.
17:46:24 <arahael> Heh.
17:47:16 <arahael> Incidentially, do you have a good learning resource for attoparsec?
17:47:49 <Axman6> umm... there's probably many. let me see if I can find a good cannonical use of it
17:48:12 <arahael> Axman6: Funnily enough, it contains RFC2616, which is relevant.
17:48:38 <arahael> (Email headers and HTTP headers have some, sometimes surprising, overlaps)
17:48:45 <Axman6> you might find this a good start: https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
17:48:53 <arahael> Thanks.
17:49:02 <arahael> I'd best get to work, this was my distraction of the day. :)
17:49:27 <dpk-atk> yeah
17:51:16 <meditans> dpk-atk: perfect, that's about all you need to know for the everyday kind usage
17:51:19 <Axman6> arahael: might be worth finding a robust email address parser too. luckily writing one in a parser combinator library is a lot easier than trying to write a regex... http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html
17:52:19 <meditans> dpk-atk: when you'll feel ready to delve in more advanced topics, you'll discover that there exists other kinds, which aren't * or constructions made with * and ->
17:53:10 <dpk-atk> O_O
17:53:17 <dpk-atk> what do they use
17:53:37 <meditans> dpk-atk: for example, the so-called promoted types, or the constraint types, but that's for another time. In the meantime, remember that the extension KindsSignatures lets you annotate your types with the kind
17:53:51 <dpk-atk> ah i see
17:53:55 <dpk-atk> thanks so much
17:54:02 <dpk-atk> really helped clear things up for me :)
17:54:18 * hackagebot streaming 0.1.4.1 - an elementary streaming prelude and general stream type.  https://hackage.haskell.org/package/streaming-0.1.4.1 (MichaelThompson)
17:54:29 <ski> dpk-atk : e.g. `Eq :: * -> Constraint' and `MonadReader :: * -> (* -> *) -> Constraint'
17:54:30 <meditans> dpk-atk: glad it worked, I'll steal ski's example, from now on :)
17:54:53 <ski> meditans : go ahead :)
17:55:37 <maerwald> the documentation on 'bracket' is a bit thin... does "release resource" action also get executed if the in-between computation fails?
17:55:53 <Axman6> yes
17:56:13 <Axman6> that's the whole point of bracket, the release will always execute as long as the resource allocation happened
17:57:19 <hpc> that "still happens on failure" is the only thing that distinguishes bracket from (>>=)
17:59:21 <maerwald> someone should fix the documentation, it's not very precise about it
18:05:41 <monochrom> "because bracket will install the necessary exception handler to release the resource in the event that an exception is raised during the computation" is very precise to me. in fact, too precise.
18:05:58 <maerwald> "the computation" is not precise
18:06:05 <maerwald> it could refer to either of those computations
18:11:49 <monochrom> alright
18:14:18 * hackagebot streaming-bytestring 0.1.4.3 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.4.3 (MichaelThompson)
18:25:08 <athan> Constraint-level lambdas, please :D
18:25:14 <zRecursive> Cv
18:39:19 * hackagebot unfoldable-restricted 0.0.0 - An alternative to the Unfoldable typeclass  https://hackage.haskell.org/package/unfoldable-restricted-0.0.0 (athanclark)
18:39:21 * hackagebot quiver-instances 0.1.0.0 - Extra instances for Quiver  https://hackage.haskell.org/package/quiver-instances-0.1.0.0 (IvanMiljenovic)
18:44:20 * hackagebot quiver-instances 0.1.0.1 - Extra instances for Quiver  https://hackage.haskell.org/package/quiver-instances-0.1.0.1 (IvanMiljenovic)
18:49:20 * hackagebot quiver-interleave 0.2.0.0 - Interleave values from multiple Quivers  https://hackage.haskell.org/package/quiver-interleave-0.2.0.0 (IvanMiljenovic)
18:49:22 * hackagebot quiver-binary 0.1.1.0 - Binary serialisation support for Quivers  https://hackage.haskell.org/package/quiver-binary-0.1.1.0 (IvanMiljenovic)
19:13:06 <ntnt> why is the return type of readHEx [(Int, String)] instead of Maybe (Int, String) ?
19:13:10 <ntnt> why would there ever be more than one result ?
19:13:46 <ntnt> > readHex "\\u2222"
19:13:47 <lambdabot>  []
19:13:51 <ntnt> > readHex "\u2222"
19:13:52 <lambdabot>  <hint>:1:11:
19:13:52 <lambdabot>      lexical error in string/character literal at character 'u'
19:13:56 <ntnt> > readHex "u2222"
19:13:58 <lambdabot>  []
19:14:03 <ntnt> > readHex "2222"
19:14:05 <lambdabot>  [(8738,"")]
19:14:15 <ntnt> why would readHex ever return more than one item ?
19:16:12 <zRecursive> :t readHex
19:16:13 <lambdabot> (Eq a, Num a) => ReadS a
19:16:56 <zRecursive> > readHex "ef123"
19:16:58 <lambdabot>  [(979235,"")]
19:17:25 <ntnt> >t digitToInt "2"
19:17:35 <ntnt> > map digitToInt "2323 def"
19:17:37 <lambdabot>  [2,3,2,3,*Exception: Char.digitToInt: not a digit ' '
19:18:05 <zRecursive> @hoogle readHex
19:18:05 <lambdabot> Numeric readHex :: Num a => ReadS a
19:18:05 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
19:18:29 <zRecursive> @package Numeric
19:18:29 <lambdabot> http://hackage.haskell.org/package/Numeric
19:18:58 <zRecursive> @where readHex
19:18:58 <lambdabot> I know nothing about readhex.
19:20:38 <geekosaur> @index readHex
19:20:38 <lambdabot> Numeric
19:23:36 <orion> If I have two lists [a] and [b] and a function f :: a -> b -> c, what primitive should I look for to get all the combinations of f possible? Should I use do-notation in the list monad, list comprehension, or something else?
19:25:57 <verement> orion: f <$> _as <*> _bs
19:26:11 <mpickering> > (+) <$> [0,1,2] <*> [2,3,4]
19:26:12 <lambdabot>  [2,3,4,3,4,5,4,5,6]
19:26:59 <mpickering> Typing applicative operators on phones is so hard! 
19:31:27 <camm_> Hello everyone. I have a problem runing the test written with Hspec with stack test. Here is the information that I can give you http://lpaste.net/159258. Could you please help me? I don't know why the tests are not executed.
19:36:53 <orion> verement: Ah, nice, thanks. Applicative syntax!
20:09:41 <cj_howe> hey, i figured you haskellers might understand my predicament - basically, people keep telling me that everywhere you can get a programming job is really bad
20:10:30 <cj_howe> either management hasn't ever heard of the iron triangle and you can never meet their expectations, they don't believe in any level of quality, or you don't make any money
20:10:39 <cj_howe> i guess the last case would be like, education or something
20:10:56 <cj_howe> like doctorates and stuff
20:11:30 <cj_howe> is this even remotely true? i honestly don't believe it, but then again, i haven't really experienced anything i'd consider decent yet
20:12:22 <cj_howe> just spent a couple months on an elm project, but didn't have enough time to finish, and we didn't have nearly enough manpower
20:13:17 <zRecursive> Cv
20:15:27 <cj_howe> or maybe a clearer way to phrase the question is: how good does it get?
20:53:32 <Hafydd> ntnt: it wouldn't, but it's convenient for readHex to have the same return type as other parsers, so it can be composed with them.
21:00:39 <orion> ski: Ping
21:18:04 <codebje> cj_howe: there is frequently a collision between quality and time to deliver, but there are plenty of workplaces where management understand the tradeoffs involved
21:19:36 <codebje> I use One Neat Trick, Managers Hate Me: I deliver early and often; I get something working out the door ASAP then refine until either the project owners are satisfied, or (more likely) reprioritisation occurs and I get redeployed
21:24:15 <hick_richey> man f'in tired.. =/
21:56:29 <orion> So, I've created a bunch of types like this: data FooType :: * -> * where; FTAlpha :: FooType Alpha; FTBeta :: FooType Beta; data SomeFooType where; WrapFooType :: forall f. Foo f => FooType f -> SomeFooType
21:57:45 <orion> I am able to successfully call functions which have type signatures like this: f :: Int -> FooType f -> Thing f; f 0 FTAlpha
21:58:23 <orion> What I'm having difficulty doing is making a list of FooTypes and running the function f for each one.
21:59:02 <nil00> what's the standard regex library for Data.Text
21:59:31 <orion> I can't make a list such as: [FTAlpha, FTBeta] because I get a type error.
22:00:10 <orion> Instead, I have to do [WrapFooType FTAlpha, WrapFooType Beta], whose type is [SomeFooType]
22:00:25 <Cale> orion: Yeah, that's the entire reason why you'd have a SomeFooType type in the first place
22:00:31 <orion> But, that means I can no longer call f.
22:01:07 <Cale> Well, you can probably write something of type  [SomeFooType] -> [SomeThing]
22:02:20 <nil00> regex-tdfa?
22:03:13 <Cale> Attoparsec?
22:03:16 <Cale> ;)
22:03:39 <Cale> nil00: What are the regular expressions for?
22:04:07 <nil00> nil00 just some quick and dirty one-off data checking and munging
22:04:13 <nil00> Cale
22:04:27 <nil00> for some biological datasets
22:04:28 <Cale> Then yeah, I would use attoparsec
22:04:46 <Cale> Much nicer than regular expressions
22:04:48 <nil00> Cale I actually am using attoparsec for some of this
22:05:11 <nil00> for example reading the data in
22:05:19 <nil00> but idunno.., there's a few small string trimming tasks where it seems like overkill
22:05:44 <nil00> esp not being super facile with it beyond the basics
22:05:54 <orion> Cale: I'm not sure how that would help.
22:07:11 <johnw> if I have something weaker than a Galois connection, say f(a) ≤ b → a ≤ g(b), rather than ↔, does this have a name?
22:07:50 <orion> I don't understand why I can't pattern match on the GADT and have the types be resolved.
22:09:27 * hackagebot nanovg 0.1.0.2 - Haskell bindings for nanovg  https://hackage.haskell.org/package/nanovg-0.1.0.2 (cocreature)
22:15:10 <Cale> orion: You can, inside of the pattern match
22:15:20 <Cale> orion: What's the type of the function you're trying to write?
22:15:39 <Cale> johnw: hmmm
22:20:32 <orion> Cale: This is the real code, along with the compiler error: http://lpaste.net/4114698048183992320
22:22:35 <orion> I don't understand why d can't be matched with d1. They have the same class constraint.
22:23:32 <Cale> Where's handshakeState defined?
22:24:29 * hackagebot werewolf-slack 0.4.0.0 - A chat interface for playing werewolf in Slack  https://hackage.haskell.org/package/werewolf-slack-0.4.0.0 (hjwylde)
22:25:52 <orion> Cale: https://github.com/centromere/cacophony/blob/test-vectors/src/Crypto/Noise/Internal/HandshakeState.hs#L155
22:28:24 <Cale> That's a function of two arguments, but you're applying handshakeState to three...
22:28:50 <Cale> orion: ^^
22:28:54 <johnw> Cale: :)
22:29:30 <orion> Cale: sorry... https://github.com/centromere/cacophony/blob/test-vectors/tests/vectors/HandshakeState.hs#L54
22:31:03 <Cale> Okay, so the type signature for mkHandshake says that for *any* types c, d, h, as long as I have instances Cipher c, Curve d, and Hash h, I should be able to supply some stuff, and obtain a HandshakeState c d h, where the c, d, and h are the types *I* chose.
22:31:17 <Cale> Is that true? It certainly doesn't appear to be true.
22:32:34 <orion> To what does "I" refer?
22:32:42 <Cale> The user of mkHandshake
22:33:17 <Cale> orion: Basically the problem is that your type signature says that mkHandshake's result should be polymorphic in a way that it is not polymorphic.
22:33:52 <orion> You're *supposed* to choose c, d, and h.
22:33:57 <Cale> It's trying to produce a value of type HandshakeState c d h for some *specific* types c, d, and h which *it* chose.
22:34:13 <Cale> Not which its caller gets to choose
22:34:43 <orion> I see.
22:36:46 <orion> Now, I could make the signature be (Cipher c, Curve d, Hash h) => [Plaintext] -> HandshakePattern -> Maybe Plaintext -> CipherType c -> CurveType d -> HashType h -> HandshakeState c d h, and I suppose that would allow the caller to choose.
22:37:08 <Cale> yeah
22:37:20 <Cale> That's exactly what I was about to suggest
22:37:40 <orion> However, if I do that I won't ever be able to call mkHandshake, because I have a list of [SomeCipherType], etc.
22:37:49 <Cale> The other options are to wrap the result in another existential, or to use continuation passing style with a higher rank type
22:38:41 <Cale> orion: If mkHandshake were allowed to choose the types c, d, and h, then you would have no guarantee that all the elements of your list had the same type
22:39:23 <Cale> (but Haskell doesn't have first class existentials, you need a newtype)
22:41:04 <orion> Ok, I can understand how there'd be no guarantee that the list elements were of the same type.
22:41:22 <brbblnch> hi Cale!
22:41:27 <Cale> brbblnch: hello
22:41:35 <orion> Cale: What do you think the best approach is to this problem?
22:42:08 <Cale> orion: Well, what did you plan to do with the list hss?
22:42:29 <orion> Cale: I plan on passing it to runHandshake -- https://github.com/centromere/cacophony/blob/test-vectors/tests/vectors/HandshakeState.hs#L73
22:42:46 <orion> Specifically fmapping it.
22:43:30 <Cale> orion: and then what would you do with the results of that?
22:43:48 <Cale> (I'm going to keep asking until there are no type variables for c, d, h left ;) 
22:44:41 <orion> results  = fmap runHandshake hss; results' = fmap messageLoop results; history  = fmap (\r -> fmap (\(a, b, c) -> (a, encode b, c)) (r ^. hrMsgHistory)) results'; print history;
22:45:08 <orion> messageLoop :: Cipher c => HandshakeResult c -> HandshakeResult c
22:45:44 <monochrom> Cale: are you simulating type-hole programming manually? :)
22:45:44 <orion> hrMsgHistory :: [(Plaintext, ByteString, Plaintext)]
22:49:24 <Cale> orion: Okay, so note that your whole thing is basically a bunch of fmaps one after the other
22:50:10 <Cale> orion: So, one option you have is to merge those functions together
22:50:17 <orion> When I try to pattern match in the list comprehension like this: hss = [mkHandshake payloads p psk c d h | p <- patterns, psk <- psks, WrapCipherType c <- ciphers, WrapCurveType d <- curves, WrapHashType h <- hashes] I get the following error: Couldn't match type ‘c00’ with ‘c’ because type variable ‘c’ would escape its scope. This (rigid, skolem) type variable is bound by ...
22:50:26 <Cale> yep
22:50:30 <orion> I have no idea what a skolem is.
22:51:46 <kadoban> That is always the part that sticks out about that error … I never can remember what it means or why.
22:51:48 <Cale> Well, you're not allowed to pattern match an existential and just let something of the existentially quantified type escape from the scope of the pattern match -- you have to do something with it right then and there
22:52:54 <nil00> is there a way to use Data.Vector without littering code with fromList everywhere?
22:53:08 <Cale> A skolem type variable is basically something which is introduced to represent a specific but unknown type.
22:53:53 <Cale> (when unpacking an existential, you need one of these, because you don't know what type the contents of the existential have)
22:54:16 <Cale> (but it matters that everything lines up -- it's not allowed to be conflated with any other type)
22:55:39 <Cale> By contrast, if you imagine typechecking  f x y = [x,y] or something, you can imagine introducing type variables to represent the types of x and y, and then discovering that x and y must be the same type, and so unifying them. Skolem type variables are not allowed to be equated like that.
22:56:05 <cocreature> nil00: -XOverloadedLists
22:56:41 <cocreature> Cale: that’s a really nice explanation, thanks!
22:56:58 <orion> Cale: I see.
22:58:10 <orion> So, would a potential solution be to create a single scope within which all those operations happen?
22:58:18 <Cale> yeah
22:58:23 <orion> Like a case statement.
22:58:26 <Cale> That's pretty much what you have to do
22:58:48 <Cale> and yeah, use case expressions, rather than let, because let will make Simon's brain explode
22:59:01 <orion> ha
22:59:35 <Cale> @let data Showable = forall a. Show a => Showable a
22:59:36 <lambdabot>  Defined.
23:00:01 <Cale> > let Showable s = Showable 74 in show s
23:00:03 <lambdabot>      My brain just exploded
23:00:03 <lambdabot>      I can't handle pattern bindings for existential or GADT data constructors.
23:00:03 <lambdabot>      Instead, use a case-expression, or do-notation, to unpack the constructor.
23:00:24 <dinnu93> how can I make infinite list of my own series, like infinite fibonacci number sequence ?
23:00:46 <Cale> dinnu93: Well, there are lots of ways...
23:00:53 <dinnu93> ok
23:01:07 <Cale> > let fibs a b = a : fibs b (a+b) in fibs 0 1
23:01:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:01:13 <cocreature> dinnu93: a simple way is to recurse on your list definition e.g. "ones = 1 : ones"
23:01:36 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
23:01:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:01:45 <dinnu93> Thank you cale: lambdabot: 
23:02:12 <dinnu93> I'm new to Haskell and I'm learning 
23:02:28 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
23:02:29 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:02:32 <dinnu93> can't I control the (..) operator to make my own sequences
23:02:36 <dinnu93> ?
23:02:55 <Cale> The [a..b] syntax only gives you arithmetic sequences
23:03:00 <Cale> There are 4 forms of it
23:03:16 <dinnu93> cale: ok
23:03:20 <cocreature> you can do [1,3..]
23:03:23 <cocreature> for a list of odd numbers
23:03:23 <Cale> [a..] will give you a sequence counting up from a (possibly infinite)
23:03:52 <Cale> [a,b..] will give you an arithmetic sequence starting with a and b, so stepping up by (b-a)
23:04:27 <Cale> and then there are the forms [a..c] and [a,b..c] which will stop when they reach c
23:04:37 <Cale> and that's all
23:05:11 <Cale> For anything else, you can just define other functions to produce it
23:05:16 <dinnu93> ok
23:05:32 <dinnu93> cale: Thanks 
23:05:49 <nil00> is there a way of defining a local scope within a module somehow?
23:06:32 <nil00> like if I want two define two ADTs with an identically named accessor. Or alternative I use the frames library and i want to be able to load more than 1 csv with the same column name
23:07:17 <cocreature> nil00: not possible
23:08:38 <nil00> cocreature i thought i saw some trick with anonymous functions a while back on reddit
23:08:42 <nil00> but i haven't been able to find it
23:08:59 <dinnu93> map (\x -> x^2) [1..]
23:09:54 <liste> > map (\× -> x^2) [1..]
23:09:56 <lambdabot>  <hint>:1:9: parse error on input ‘->’
23:10:01 <liste> > map (\x -> x^2) [1..]
23:10:03 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
23:10:32 <dinnu93> liste: nice so lambdabot: is a haskell interpreter ? 
23:11:10 <kadoban> Yep
23:11:18 <liste> dinnu93: among other things. you can do "/msg lambdabot @listmodules" to find out what it can do
23:12:38 <dfeuer> Where can I find a type that augments a Semigroupoid to produce a Category?
23:13:49 <dfeuer> Something like   data Categorize s a b where Id :: Categorize s a a; Raise :: s a b -> Categorize s a b ?
23:14:48 <dfeuer> instance Semigroupoid s => Category (Categorize s) where Id . y = y; y . Id = y; Raise x . Raise y = Raise (x `o` y)
23:14:57 <dfeuer> This must exist somewhere, right?
23:16:03 <dustmote> clearer way to write this? "mapM (liftM (readEither >=> checkStatusEither) . readFile)"
23:16:34 <dustmote> readEither and checkStatusEither both take a string and output a value in the Either monad
23:16:51 <dfeuer> dustmote, start by using <$> instead of liftM?
23:17:29 <dustmote> ah, ok.
23:18:00 <dfeuer> Also, consider ditching the  .  in favor of a lambda to name the thing.
23:18:49 <dfeuer> mapM $ \filename -> (readEither >=> checkStatusEither) <$> readFile filename
23:19:14 <dustmote> yep. that's what i arrived at to
23:19:16 <dfeuer> dustmote, then you can flip the arrows so everything flows thesame way:
23:19:18 <dustmote> this is more idiomatic?
23:19:37 <dfeuer> mapM $ \filename -> (checkStatusEither <=< readEither) <$> readFile filename
23:19:53 <dustmote> ah, that's better
23:20:02 <dfeuer> dustmote, I don't know. It's clearer, either way.
23:22:18 <dustmote> well, this has on "direction" of flow, which is what i was trying to achive
23:22:26 <dustmote> achieve*
23:22:28 <dustmote> thank you.
23:23:46 <dfeuer> You're welcome.
23:24:13 <dfeuer> dustmote, you don't happen to know a nice type for adding an identity to a Semigroupoid to get a Category, do you?
23:25:06 <dfeuer> *sigh*
23:27:33 <dustmote> dfeuer: I'm afraid that's well beyond my current level of study. Sorry.
23:27:47 <dfeuer> dustmote, not as much as you think :-)
23:28:00 <dfeuer> dustmote, the names are much scarier than the actual classes.
23:29:40 <dustmote> Heh.. Granted, but the answer to your question (I'd imagine) requires knowing the theoretical relationships that link the two classes in category theory.
23:29:50 <dustmote> Since I don't know any theory...
23:32:22 <thimoteus> dfeuer: not sure if this is what you're looking for, but this is how Category is defined in purescript: https://pursuit.purescript.org/packages/purescript-prelude/0.1.4/docs/Prelude#t:Category
23:33:47 <dfeuer> thimoteus, Maybe conceptually turns semigroups into monoids (although for hysterical raisins it doesn't turn Semigroups into Monoids). There's something similar that turns Semigroupoids into Categories, but I can't find it in a library.
23:35:58 <dfeuer> thimoteus, dustmote, I just opened an issue to possibly add such a thing to the semigroupoids package: https://github.com/ekmett/semigroupoids/issues/41
23:37:01 <nil00> damn
23:37:41 <dfeuer> nil00?
23:37:47 <nil00> after spending the last 2 hours tinkering with it I think samtools on hackage is completely broken
23:38:20 <nil00> and it's like 3am here
23:39:01 <dfeuer> Yeah, it's getting close to that here :(
23:39:54 <nil00> weird this library builds fine, but most of the Maybe commands are giving Nothing
23:40:36 <dfeuer> Does this make sense? https://github.com/atzeus/reflectionwithoutremorse/issues/4
23:40:37 <nil00> trying to decide if i should keep trying or give up and use R or python
23:42:17 <nil01> other options besides broken samtools are not looking much better
23:42:42 <nil01> biohazard has no documentation
23:43:29 <nil01> nothing else loads bam files
23:43:49 <nil01> 3am seems like  bad time to start writing my own FFI bindings 
23:44:03 <pharaun> yes :)
23:44:08 <pharaun> it is, i know, i've been there
23:44:11 <pharaun> way too often
23:44:32 * hackagebot pipes-transduce 0.4 - Interfacing pipes with foldl folds.  https://hackage.haskell.org/package/pipes-transduce-0.4 (DanielDiazCarrete)
23:45:53 <nil01> pharaun yet another lost battle trying to do productive work in haskell 
23:46:23 <nil01> retreating back to dynamic typing land :/
23:46:34 <pharaun> eh?
23:46:55 <pharaun> when i get to that point i would just put it down and go take a break (really hard to do that myself)
23:47:03 <pharaun> and i usually come back and go oh... <x>
23:47:47 <nil01> pharaun well i promised i'd finish this tonight. i can't even load the data file in haskell without forking this library or writing FFI bindings from scratch
23:47:58 <pharaun> ah
23:48:30 <nil01> i tried
23:49:00 <pharaun> if there's a deadline go over to R and fix it up then come back and poke at haskell again to see
23:49:49 <nil01> pharaun yeah. this is what i get for being one of the 3 people in the universe trying to do biological data analysis in haskell.
23:50:51 <pharaun> bleeding edge or not adquately covered area can and kinda always have sucked
23:51:06 <nil01> yeah data analysis in general is pretty weak
23:51:19 <pharaun> can be a really nice chance to write up your own set of libraries/suites to help the next person but yeah
23:51:45 <nil01> the subfield of biological science within that is almost literally like 2 or 3 people.
23:51:59 <pharaun> dang
23:52:51 <nil01> the past 6 months or so have been kindof this cycle
23:53:29 <nil01> try really hard to do it in haskell for the first 5 days, get a little better at haskell, give up and do it in R on the last night..
23:55:21 <joof> I know there's stuff like hlearn. No bioinformatics people love haskell? I guess everyone I know in that field sticks with python...
23:55:39 <joof> or R as you say
23:56:45 <nil01> there are like 4 or 5 visible people, 2 of which are maybe active
23:57:10 <nil01> same with libraries, there's probably like 6 or 7, but 5 of those don't work or are undocumented
23:57:44 <nil01> there's a lot of heterogeneous use cases (random dumb file formats), so even not having the ecosystem for that hurts
23:58:18 <nil01> not to mention algorithms being in some combo of C++ & R or python is the field's norm. there's almost nothing beyond rudimentary algorithms
23:58:22 <levi> Gabriel Gonzalez did some Haskell bioinformatics stuff a while ago, IIRC.
23:58:35 <nil01> but for now i'd be happy with just the data processing stuff
