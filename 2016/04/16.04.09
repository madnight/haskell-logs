00:00:10 <Tendies> can i do anything to replace this big if statement with something like guards within do notation? (i know guards themselves aren't allowed, but i want to know if there's anything easier to read )
00:00:14 <Tendies> http://lpaste.net/159304
00:01:40 <Gurkenglas> :t Control.Monad.Loops.andM
00:01:41 <lambdabot> Monad m => [m Bool] -> m Bool
00:01:48 <pavonia> You could use "case () of _ | cond1 -> ...; _ | cond2 -> ...; otherwise -> ..."
00:02:16 <Gurkenglas> Are lines 9 and 10 supposed to be identical?
00:03:07 <Gurkenglas> Why is line 11 indented differently from any other?
00:03:33 <Tendies> they could be, this is just an example. line 11 is 1 column off because i couldnt use tab
00:03:43 <Tendies> and i didnt notice
00:03:44 <srhb> If the failure is the same, why not cond1 && cond2 ?
00:04:03 <Gurkenglas> srhb, because he wants the effects of cond2 only if cond1 fails
00:04:13 <Gurkenglas> *if cond1 is true ._.
00:04:40 <srhb> ... yes?
00:04:50 <Tendies> ?
00:05:06 <srhb> I'll get more coffee I guess, I don't understand what I'm not understanding. :-P
00:05:22 <Gurkenglas> cond1 && cond2 will do all effects all the time, instead of shortcircuiting.
00:05:25 <Tendies> pavonia: in what i could glean from the internet, they said that using case like that would mean if any of those cases dont match it counts as a failure in the do block
00:05:30 <srhb> Gurkenglas: Since when?
00:05:33 <Tendies> is this not the case?
00:06:11 <pavonia> Tendies: That'S why there's the otherwise case which will always sucede
00:06:28 <Tendies> but in a do block if any line fails the whole thing fails, yes?
00:06:41 <Tendies> or is the case treated as one line as a whole
00:07:00 <Tendies> are all of the cases treated as one line *
00:07:08 <Gurkenglas> > (`runState` 0) $ do cond1 <- (do modify (+1); return True); cond2 <- (do modify (+1); return True); return $ cond1 && cond2
00:07:10 <lambdabot>  (True,2)
00:07:38 * hackagebot husk-scheme 3.19.2 - R5RS Scheme interpreter, compiler, and library.  https://hackage.haskell.org/package/husk-scheme-3.19.2 (JustinEthier)
00:07:38 * hackagebot AFSM 0.1.0.0 - Arrowized functional state machines  https://hackage.haskell.org/package/AFSM-0.1.0.0 (hanzhxu)
00:07:55 <pavonia> Tendies: If one line fails, "fail" is called, I think
00:08:03 <Gurkenglas> > (`runState` 0) $ andM [(do modify (+1); return False), (do modify (+1); return False)]
00:08:05 <lambdabot>  (False,1)
00:08:28 <Gurkenglas> Tendies, the whole block fails if one thing fails
00:08:42 <srhb> Gurkenglas: Oh, it wasn't clear to me from the example that that was the intention. Thanks. :-)
00:08:49 <Gurkenglas> But you can use <|> to combine parsers of equal type like "if the first fails, try the second one"
00:09:26 <Tendies> the number of times i've gotten to code needing <|> in this, is painful
00:09:49 <catsup> does anyone know of a full example of using optparse-applicative in the way they recommend here: https://github.com/pcapriotti/optparse-applicative#commands
00:09:58 <Gurkenglas> Painful because you dont like <|> or because you keep not noticing you need it?
00:10:11 <Tendies> because i can't use the library containing it
00:10:21 <Gurkenglas> Why not? It's base.
00:10:34 <Tendies> was that a recent addition?
00:10:42 <sidhe> what is the closest guide/tutorial to "how to implement fay from scratch" ?
00:10:49 <Tendies> in ghci it doesn't recognize :t (<|>)
00:11:17 <srhb> Tendies: It's not in Prelude, but it's in base.
00:11:24 <pavonia> It's in Control.Applicative
00:11:29 <srhb> Tendies: (module vs package)
00:11:46 <srhb> Tendies: Here's base's contents: https://hackage.haskell.org/package/base-4.8.2.0
00:12:20 <Gurkenglas> https://hackage.haskell.org/package/base-4.0.0.0/docs/Control-Applicative.html#t:Alternative looks like it's been in there for as long as there's been documentation
00:12:23 <Tendies> i failed to specify that i can only use prelude, Control.Applicative (Applicative(..)) and Control.Monad (liftM, ap)
00:12:43 <srhb> Tendies: Copy paste the definition of (<|>) then :-)
00:13:04 <Tendies> if i can't make the code easier to read that's fine just tell me it's not possible with what i've got
00:13:21 <srhb> I think it's fine, if you can't use the things that make it finer.
00:13:31 <sidhe> is http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-dynamic/dynamic.pdf available in ghc yet?
00:13:40 <Tendies> so case is not going to work, right?
00:14:21 <Gurkenglas> You can put the <|>-enhanced code in a comment if you want to educate your reviewers :)
00:14:49 <pavonia> Tendies: Why do you come to that conclusion?
00:15:32 <pavonia> You can think of if/then/else as a special case of case/of
00:15:38 <Tendies> what Gurkenglas said appears to conflict with what you said, pavonia
00:15:50 <Tendies> so i don't know which to choose D:
00:16:08 <pavonia> I don't see how (<|>) is related to that question, though
00:16:50 <Tendies> i think that would let me throw out the if-then-elses entirely
00:17:26 <Gurkenglas> Hm, cond1 and cond2 don't even look like they have any effects, do they? I think I was wrong.
00:17:44 <Tendies> oh, those are intended to be calls to other parsers that are also recursive
00:18:03 <lpaste> Gurkenglas annotated “No title” with “By the way, notice how you never not return True” at http://lpaste.net/159304#a159306
00:18:35 <lpaste> Gurkenglas revised “By the way, notice how you never not return True”: “Oops, there's a "char '<'" line” at http://lpaste.net/159306
00:19:13 <Tendies> if anything fails in any of them shouldnt the failure propogate and kill it?
00:19:25 <Gurkenglas> indeed
00:19:50 <Gurkenglas> If you can't use Alternative, you'll have to unpack the parser and explicitly see if it fails and work based on that
00:20:11 <Tendies> Alternative(..) i have
00:20:19 <Gurkenglas> (Or make a helper function that does that for you, effectively yielding Alternative or at least semigroupoids' Alt
00:20:30 <Tendies> oh wait i can't read
00:20:36 <Tendies> i don't have Alternative
00:21:23 <Gurkenglas> Do you have a direct line to who decided that you can't have Alternative and can tell them to come here? We might be able to convince them :P
00:21:40 <Tendies> i can only import this file http://lpaste.net/159301
00:21:45 <Tendies> that's how it came about
00:22:38 <Tendies> that guards example is showing that i can in fact use cases, Gurkenglas ?
00:22:46 <Tendies> i mean cases, sorry
00:23:07 <Gurkenglas> "Instead of Parser being instance of MonadPlus, directly implemented the failure and choice (+++) parsers." umm that's exactly the <|> that you've been missing
00:23:21 <pavonia> Isn't Applicative(..) exporting (<|>) too?
00:23:38 <pavonia> Err no
00:23:48 <Tendies> what people said earlier was that it only gets methods of Applicative
00:24:05 <pavonia> Yeah, I confused it with Alternative
00:24:10 <Tendies> me too :P
00:24:13 <Gurkenglas> I should have known when you use many, many uses Alternative
00:24:25 <Gurkenglas> *used many
00:24:26 <Tendies> so <|> is the same as +++?
00:24:30 <Gurkenglas> yeo
00:24:31 <Gurkenglas> *yep
00:24:57 <Tendies> and i'd just stick it in front of any lines i expect to fall through?
00:26:17 <Gurkenglas> p +++ q, with equal-typed parsers p and q, does "Execute p. Did that work? Okay, return its result. Did it not work? Pretend you didn't use it (backtracking the input!) and try q instead"
00:27:08 <Tendies> alright ill try that out, thanks guys
00:27:16 <Tendies> s/guys/people/
00:27:48 <Gurkenglas> By the way, http://lpaste.net/159301 seems to be only concerned with lists with 0 or 1 element. Why didn't he use Maybe?
00:28:52 <Tendies> it doesn't use Data.Maybe, i think?
00:29:06 <Gurkenglas> Right, why
00:29:42 <Tendies> I don't know
01:02:47 <ntnt> how does ghcjs work? what level of ghc does it intercept and then start generating js ?
01:04:24 <cocreature> ntnt: afaik it uses ghc to compile to stg and then generates js from that
01:07:06 <ntnt> cocreature: hmm, it's even lower than core
01:07:56 * hackagebot mnist-idx 0.1.2.3 - Read and write IDX data that is used in e.g. the MNIST database.  https://hackage.haskell.org/package/mnist-idx-0.1.2.3 (muzzle)
01:08:35 <srhb> ntnt: I'm guessing a lot of the core->core transformations are still relevant for making performance tolerable regardless of the end product language. :)
01:09:05 <cocreature> afaik stg is mostly a special form of core
01:13:43 <ntnt> where is c-- documented?
01:13:51 <ntnt> (c-- as in the core -> stg -> c-- )
01:26:51 <srhb> ntnt: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Cmm -- poorly
01:42:32 <const> hey! I'm trying to install netwire in a stack project, but I'm having a problem. the newest version of Netwire depends on profunctors (>= 4.3 & < 5), while my project uses profunctors 5.2. is there a way to either use multiple versions of the profunctors library or to force netwire to use the newer version?
01:48:48 <catsup> const: clone netwire into a directory, change its .cabal file to remove the upper bound, edit your project's stack.yaml to point to the directory
01:50:13 <catsup> (that'd be forcing netwire to use the newer version.  using multiple versions of a library in the same build isn't supported by ghc.)
01:50:54 <const> yeah, ok
01:51:21 <const> crossing my fingers netwire doesn't break then! :)
01:51:30 <catsup> well, if it does, it will probably be easy to fix
01:52:57 * hackagebot automitive-cse 0.0.1.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automitive-cse-0.0.1.0 (KeiHibino)
01:57:57 * hackagebot automotive-cse 0.0.1.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.0.1.0 (KeiHibino)
01:59:13 <cocreature> hm I thought you couldn’t upload the same version twice
01:59:39 <cocreature> oh there was a typo in the package name
02:03:33 <const> I have another question: how do I tell stack which project is the main project to build? I added the netwire library to the folder where my project resides and added it as a local package in stack.yaml, but when I build the project it only builds netwire
02:05:38 <kadoban> const: Can you lpaste the stack.yaml?
02:06:01 <const> sure! :)
02:06:02 <kadoban> You probably want to add it as an extra-dep, which means it should be in packages and with extra-dep set, or whatever the syntax is
02:06:53 <const> http://lpaste.net/159317
02:07:39 <kadoban> const: Oh did you change what was already there for packages? You're supposed to just add to it usually. Where is the code to your actual project (where's the yourproject.cabal file?)
02:07:43 <cocreature> you need a line such as - . in packages
02:07:50 <cocreature> assuming your package is in the current directory
02:08:05 <kadoban> I think you should probably have slightly different syntax for the netwire thing too, let me try to find it
02:08:39 <const> I'll try to add the - '.' that was there before :)
02:09:08 <cocreature> the syntax for extra-deps should be http://lpaste.net/159318
02:09:20 <cocreature> iirc
02:10:30 <const> okay
02:10:32 <kadoban> const: Yep, cocreature's looks right for that ^
02:11:03 <cocreature> obviously replace path by _OTHER/netwire-5.0.1/
02:11:42 <const> yep :)
02:11:52 <const> yeah that worked
02:12:01 <const> looks different than in the stack user guide
02:12:22 <kadoban> Does it?
02:12:41 <cocreature> the example here http://docs.haskellstack.org/en/stable/yaml_configuration/?highlight=extra-dep looks exactly like mine
02:12:51 <cocreature> (you need to scroll down a bit)
02:13:13 <const> yes :) http://lpaste.net/159319
02:13:25 <const> that's the one I found. it's on github though
02:13:47 <const> might be a different one compared to the website
02:13:49 <kadoban> Not sure I've seen that syntax before. Where's it from?
02:14:08 <const> https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md
02:14:21 <cocreature> well that’s the syntax for non extra-deps
02:14:22 <const> under multi-package projects
02:14:26 <cocreature> obviously that’s different
02:15:00 <const> oh. Multi-package as in a project where you yourself build multiple packages?
02:15:05 <cocreature> yep
02:15:20 <const> doh
02:15:21 <kadoban> Oh I see, those are just directory names, I thought they were … like hackage packages.
02:15:29 <cocreature> extra-dep: true means that is really is a dependency but for some reason it’s not on hackage
02:16:41 <const> yeah, thanks a lot :) haven't ever needed to add projects like that before and I got kind of confused. I'll try to remember to look in the manual from the stack website next time
02:17:06 <cocreature> yw
02:33:17 <puregreen> sm: around?
02:36:21 <puregreen> oh, by the way
02:36:24 <puregreen> kadoban: have you fixed the code that wasn't compiling yesterday?
03:03:08 * hackagebot zip 0.1.2 - Operations on zip archives  https://hackage.haskell.org/package/zip-0.1.2 (mrkkrp)
03:36:31 <ggVGc> can I get statstics on which functions of my program are using the most resources?
03:42:01 <dmwit> Yep, read the section on profiling in the GHC docs.
03:42:55 <dmwit> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
03:43:36 <dmwit> ggVGc: (just a highlight, no content in this message)
03:48:42 <ggVGc> thanks
04:36:03 <dysfun> i'm having difficulty using a FingerTree with the Sum monoid. I get this error. Any ideas? https://www.refheap.com/a5a6dfe5e34a27900f270e783
04:43:19 <Gurkenglas> Is there a way to tell the runtime to evaluate everything that depends on a given thunk until that thunk doesn't need to completely be kept in memory anymore?
04:44:25 <Rembane> Does seq do what you need?
04:44:43 <Gurkenglas> No.
04:45:21 <Gurkenglas> (It's related in the sense that it also forces evaluations.)
04:46:17 <Gurkenglas> let me throw together an example
04:50:55 <gfixler> hoogle-4.2.43 depends on haskell-src-exts-1.17.1 which failed to install.
04:51:05 <gfixler> anyone know what I should do about this?
04:51:37 <Gurkenglas> In "map $ length . filter . (==)", which counts the number of occurences in the first list of all values in the second list, using one pass per element of the second list, doing what I want on the first list would be to plug the first element of the first list into each pass's filter, allowing the runtime to discard the first list, only keeping pointers to its head and tail
04:54:53 <puregreen> gfixler: try to install haskell-src-exts itself and look at the error message
04:55:27 <Gurkenglas> And then running that recursively on the first list would end up deleting it from memory (and piling up a giant thunk for each pass, hm. Is there a way that doesn't do that?)
04:55:31 <puregreen> gfixler: googling suggests that installing happy might help
04:55:56 <Gurkenglas> (deleting its spine, anyway)
05:00:25 <gfixler> puregreen: thanks - happy seems to have helped
05:03:12 * hackagebot webkitgtk3-javascriptcore 0.14.0.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.14.0.0 (HamishMackenzie)
05:21:45 <ggVGc> I can;t make my mind up on if laziness is more or less useful in the general case
05:22:39 <ggVGc> the main thing with laziness is being able to implement certain algorithms much simpler eh? And to get "accidental" performence increases by things not being calculated if they're not needed
05:22:59 <suppi> it's about composition as well
05:23:02 <ggVGc> but is that worth the cost of "sometimes my program ends up magnitues slower because I made some laziness mistake
05:23:16 <ggVGc> and fixing laziness mistakes is often ugly it seems
05:23:26 <ggVGc> I don't have enough real world usage experience to know
05:24:17 <suppi> laziness bothers me sometimes when trying to trace things which are a bit complicated
05:24:44 <suppi> but usually i very much like the elegant solutions it brings to the table
05:29:27 <ggVGc> suppi: but is it worth the danger of you making some minor edit and all of a sudden running 10000% slower?
05:31:45 <Rembane> Gurkenglas: In that specific case there are other ways of getting the same result in less time and memory, but I suppose your actual use case is something else.
05:32:32 <Gurkenglas> (Less time, too? Do you require Ord?)
05:33:05 <Rembane> I require Ord
05:33:25 <Rembane> And using the Map of Data.Map
05:33:41 <Rembane> Less time might actually be a too bold claim
05:33:52 <Gurkenglas> That I could guess you would require Ord suggests that I could guess how you'd do it :P
05:34:03 <Gurkenglas> Nah, it's less time.
05:36:45 <Rembane> That's nice. :)
05:43:14 * hackagebot twitter-conduit 0.2.0 - Twitter API package with conduit interface and Streaming API support.  https://hackage.haskell.org/package/twitter-conduit-0.2.0 (TakahiroHimura)
05:49:59 <ph88> does haskell have something like this http://algebrite.org/ ?
05:59:22 <dredozubov> ph88: If you want libraries that covers different parts of algebrite, then yes. If you want a single library that covers all that, then no.
05:59:40 <ph88> what libraries cover the parts ?
05:59:42 <dredozubov> i don't see any particular reason to want exactly the latter though
05:59:51 <dredozubov> what do you want exactly?
06:00:39 <dredozubov> you refer to a library uniting plenty of loosely related concepts in itself
06:00:51 <ph88> a few links to haskell libraries so i can put them in a note and look at them later when i need this functionality
06:03:14 * hackagebot memory 0.12 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.12 (VincentHanquez)
06:05:01 <dredozubov> there was a nice list somewhere
06:05:09 <ph88> okay :p
06:05:13 <dredozubov> i'll try to find it
06:05:17 <ph88> ok thank you
06:08:10 <dredozubov> can't find that particular list, but you can try this instead, i guess https://github.com/krispo/awesome-haskell
06:11:14 <ph88> oki thx
06:13:18 <ph88> dredozubov, hhmm that's very broad, i bookmarked it but when i look back at that i wouldn't know what's interesting about it :P
06:14:46 <dredozubov> your inquiry is very broad itself, isn't it?
06:15:57 <ph88> not that broad :/
06:19:56 <puregreen> ph88: there was a project to make a CAS in Haskell, but I think nothing came out of it
06:20:28 <ph88> that's sad :(
06:20:46 <ph88> genetic algorithm + CAS is awesomeness :P
06:21:06 <puregreen> ph88: well, I looked at Hackage right now and there seem to be other projects
06:21:10 <puregreen> e.g. https://github.com/bollu/symengine.hs
06:21:19 <puregreen> which is actually a binding
06:22:22 <puregreen> and there's also https://github.com/junjihashimoto/th-cas which looks more like algebrite and isn't a binding
06:22:30 <puregreen> (look at the example)
06:24:20 <koomi> so I'm using a sandbox and yet cabal refuses to install some dependencies because it would supposedly break some globally installed packages
06:24:56 <koomi> can I actually break anything global by installing stuff into a sandbox? if not, can I tell cabal to ignore the global package-db?
06:25:45 <koomi> as for the second question, neither --user, --shadow-installed-packages nor --ghc-option=--no-global-package-db have any effect
06:28:35 <puregreen> meanwhile: are there any popular regex libraries I missed? http://lpaste.net/159324
06:28:46 <FAuUiDkld> I'm writting a haskell paper, anyone wants to read a page or two of it? : )
06:30:41 <marchelzo> puregreen: why are you compiling a list of them?
06:31:07 <puregreen> marchelzo: for my “guide for Haskell libraries” site
06:31:37 <puregreen> (after having compiled the list I'll start listing pros/cons and writing examples for each library, but first I need a list)
06:32:34 <marchelzo> ah, I see. cool idea.
06:32:51 <marchelzo> there really are too many choices when it comes to regex
06:48:43 * hackagebot cryptonite 0.14 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.14 (VincentHanquez)
06:53:08 <iphy> in a Happy parser, is there a way to also get the actual token, not just the matched value from inside the token?
06:53:25 <iphy> or: how are source locations handled, if not by putting it into the token?
06:53:43 * hackagebot tls 1.3.5 - TLS/SSL protocol native implementation (Server and Client)  https://hackage.haskell.org/package/tls-1.3.5 (VincentHanquez)
06:58:44 * hackagebot tls-debug 0.4.2 - Set of programs for TLS testing and debugging  https://hackage.haskell.org/package/tls-debug-0.4.2 (VincentHanquez)
07:08:56 <Ankhers> I'm trying to install hzk but it can't seem to find zookeeper.h. How can I tell stack / cabal where to find it?
07:18:12 <puregreen> has anybody experienced this error when running stack? “unknown public key OID [1,3,6,1,4,1,12656,1,37]”
07:18:51 <FAuUiDkld> I'm writting a haskell book, anyone wants to read a page or two of it? : )
07:19:22 <puregreen> specifically I'm on Windows (x64) and I'm trying to run “stack ghc”
07:19:37 <puregreen> FAuUiDkld: it was a paper an hour ago
07:19:41 <puregreen> but sure, I do
07:19:59 <FAuUiDkld> typo
07:21:01 <ggVGc> How would I index a list of lists with a tuple using Lens?
07:22:35 <puregreen> listoflists ^@.. (traversed <.> traversed)
07:23:20 <puregreen> > ["abcd","efgh"] ^@.. traversed<.>traversed
07:23:22 <lambdabot>  [((0,0),'a'),((0,1),'b'),((0,2),'c'),((0,3),'d'),((1,0),'e'),((1,1),'f'),((1...
07:23:58 <fozworth> @unpl (\l r t f -> l (r t f) f) (\t f -> t) (\t f -> f) 1 0
07:23:58 <lambdabot> 1
07:25:51 <puregreen> ggVGc: or you can use %@~ instead of ^@.. if you want to do something with the index
07:26:25 <puregreen> ggVGc: or did you mean that you want to get an element at some index, where index is a tuple?
07:27:44 <ggVGc> puregreen: well, the actual scenario I have is more generic I think. I have a list of lists, and I want to store a pointer into it. Essentially I want a zipper, but where it's not bound to the actual target data
07:27:51 <ggVGc> I want a zipper where the focus and the target is separated
07:28:01 <ggVGc> and I only find out if it's valid or not when I try to index some data wit it
07:49:55 <Big_G> Does anyone know a good tutorial for ree monads?
07:50:01 <hackrilege> Hi everybody. I'm having trouble extending scan to 2d. I can retain previous values in a fixed length buffer when using scan on lists, working with "local" data, of adjacent neighbors. In 2d I cannot traverse in a way that makes retaining and accessing neighbors fast in this way (the buffer)
07:51:12 <k0ral> Hello
07:51:34 <hackrilege> Big_G the main point for me is that it abstracted out the recursive call of recursive datatypes
07:53:01 <Big_G> hackrilege, I can understand the usefullness. There are just some details that I don't get. I also don't see why something like the Tree definition wouldn't work
07:53:23 <k0ral> how would you implement `function :: (Functor f, Functor g) => Cofree f a -> Cofree g b -> Cofree (Product f g) (a, b)` ?
07:53:27 <hackrilege> What don't you get?
07:53:38 <hackrilege> If you can articulate I can explain
07:54:11 <nshepperd> Big_G: I sort of read the explanation from http://stackoverflow.com/questions/13352205/what-are-free-monads a few times until I understood
07:54:26 <nshepperd> I'm not sure theres a real tutorial
07:54:37 <Big_G> I'd have to look at the definition but the number of times fix / f is used seems to be kind of arbitrary
07:54:54 <hackrilege> Let's focus on what about Free Tree is confusing
07:55:18 <Big_G> Can you implement a binary tree with only free?
07:55:51 <nshepperd> Big_G: you can, yeah. data Twice a = Twice a a deriving (Functor)
07:56:06 <nshepperd> Free Twice a would be a binary tree
07:56:54 <hackrilege> Big_G Fix contains only infinitely many calls to the data constructor, Free can terminate, so non infinite data structures such as lists of variable length can be represented
07:57:39 <xa0> isn't a tree more of a cofree thing
07:57:46 <hackrilege> nshepperd, any ideas about scan2d I asked about above?
07:57:56 <Big_G> hackrilege, That blows my mind but I'll be back in a few
07:58:22 <nshepperd> Big_G: Free is basically a tree, but having at each internal node a "functorful" of branches
07:59:01 <hackrilege> newtype Fix f = Fix (f (Fix f))
07:59:07 <nshepperd> so if your functor is "a pair of items" that's a binary tree 
08:00:46 <hackrilege> data Free f r = Pure r | Free (f (Free f r))
08:00:50 <nshepperd> if your functor was "three items" you would get a ternary tree
08:01:39 <hackrilege> But how to tie the knot!!?
08:02:20 <hackrilege> E.g. If representing a 2d grid as Free (,,,)
08:02:50 <nshepperd> what
08:03:00 <hackrilege> 4 neighbors, but difficulty updating the numerous different references to the same object
08:06:34 <nshepperd> assuming you actually mean Free Four where data Four a = Four a a a a, that's not a grid, that's a particular materialized traversal of a grid
08:07:03 <hackrilege> Yes that's what I meant
08:07:32 <nshepperd> you can't update the grid with that
08:07:35 <hackrilege> But I could make it behave like a grid if I could make it update properly
08:07:54 <hackrilege> Simultaneously...
08:08:22 <Big_G> nshepperd, Can you add a value to twice to have a value at each node in the binary tree?
08:08:41 <hackrilege> But I would have to store with some label the nodes accessed previously that are neighbors
08:09:24 <hackrilege> I guess for simplicity I should discuss a bidirectional linked list
08:09:30 <hackrilege> Double linked list
08:09:36 <nshepperd> well, it's really just a 4-tree, but you can construct a 4-tree from a traversal of a grid, which I assume is what you've done
08:10:03 <hackrilege> http://stackoverflow.com/questions/1844195/doubly-linked-list-in-a-purely-functional-programming-language/1844243
08:10:43 <hackrilege> Yeah, it's a 4 tree, but if it's node elements refer to its own branches...
08:11:32 <hackrilege> Or rather, that the same object lies at several nodes and is updated
08:11:51 <nshepperd> Big_G: Sure! data Internal b a = Internal b a a deriving Functor; then `Free (Internal b) b` is a traditional binary search tree, with values at all nodes and leaves
08:11:53 <hackrilege> I could store pointers at the nodes to one object
08:13:21 <Big_G> Why isn't that like the traditional definition for a BST where you only have a, not b?
08:13:28 <hackrilege> If Tree2 = Free Two, I should be able to make a double linked list out of it
08:14:24 <hackrilege> Big_G that's a restriction you can enforce yourself, generally types are as general as possible
08:15:00 <nshepperd> Big_G: type BST a = Free (Internal a) a -- there you go :)
08:15:24 <Big_G> hackrilege, I can appreciate that but My concerns are that they'd be different types. In one case a would be a primitive like Int to represent a node value but it would need to represent a Tree type elsewhere
08:18:30 <Big_G> If free monads are about lifting functors, what is the functor in the case of the tree?
08:18:32 <NikolajK> What does it mean to add "~/Library/Haskell/bin" to my $PATH
08:18:33 <NikolajK> ?
08:18:40 <NikolajK> the internet isn't very helpful
08:19:10 <Clint> it means that you are on macos x
08:19:21 <NikolajK> I hope your joke ends here
08:19:56 <hackrilege> It's a Windows environmental variable
08:20:10 <hackrilege> You can change it in control panel. Google it
08:20:26 <hackrilege> $Path...
08:21:13 <hackrilege> If your on Windows... Otherwise out can be changed from the terminal
08:21:14 <nshepperd> Big_G: the functors are Twice and Internal b
08:21:22 <NikolajK> I did, some sources say to write somethng into what I get when I type "sudo vi /etc/launchd.conf"
08:21:28 <NikolajK> but I don't know vi
08:21:32 <NikolajK> or what to write there
08:21:41 <hackrilege> It's not relevant here sorry
08:22:23 <hackrilege> If you can't modify your path you will need to get help on that elsewhere
08:22:41 <hackrilege> It's not Haskell
08:23:06 <NikolajK> I want to add ~/Library/Haskell/bin, but okay
08:23:12 <NikolajK> thx
08:23:15 <hackrilege> Sry
08:23:26 <Big_G> nshepperd, What are the rules for deriving Functor? It seems like pretty much anything could be one
08:23:49 <nshepperd> NikolajK: if you're in a terminal you can do "export PATH=$HOME/Library/Haskell/bin:$PATH"
08:24:05 <hackrilege> If you wanted to type the Word Haskell in latex, but had problems using latex, it's a latex issue, not a Haskell issue
08:24:28 <ggVGc> how do I rewrite this to not use the explicit fmap? https://gist.github.com/84d45c280e92dde795dcfd08a20ef67a
08:24:28 <nshepperd> NikolajK: that applies only inside that terminal and goes away when you close it
08:24:55 <nshepperd> no idea how to do it globally in osx
08:24:57 <hackrilege> And you can get that command to rub when you open your terminal
08:25:03 <hackrilege> Run
08:25:16 <xa0> Run, clever boy, run
08:25:18 <hackrilege> Or on startup
08:25:29 <hackrilege> Anyway...
08:25:51 <hackrilege> So binary tree to double linked list... How?
08:26:04 <hackrilege> How to update
08:26:38 <nshepperd> Big_G: Pretty much! as long as the type argument appears in positive position
08:27:26 <Big_G> What counts as a positive position?
08:28:12 <dysfun> how can i get a strict bytestring from a lazy bytestring?
08:28:55 <dysfun> or is there some way of specifying that I don't care about which one?
08:29:26 <hackrilege> Pack and unpack?
08:30:06 <dysfun> transiting through a String? that seems rather wasteful
08:30:22 <hackrilege> I'm no expert
08:30:27 <puregreen> there's fromStrict and toStrict
08:30:36 <puregreen> or fromLazy and toLazy, I don't remember
08:30:44 <puregreen> in the Data.ByteString.Lazy module
08:31:47 <nshepperd> Big_G: well, I should say either just as a value in the ADT or as the argument of another functor
08:32:40 <dysfun> it's Data.ByteString.Lazy.toStrict.  you were right the first time :)
08:33:46 * hackagebot givegif 1.0.0.0 - CLI Giphy search tool with previews in iTerm 2  https://hackage.haskell.org/package/givegif-1.0.0.0 (passy)
08:33:48 <hackrilege> nshepperd. Do you know how to tie the knot? Can you help me write a double linked list using a binary Tree?
08:34:14 <Big_G> nshepperd, Do I get common methods like fmap for free in the tree example?
08:34:42 <hackrilege> Deriving Functor?
08:34:55 <Iceland_jack> Big_G: If you mean 'Free Pair' for 'data Pair a = P a a' then yes
08:35:21 <hackrilege> Don't you also get join?
08:35:48 <hackrilege> A Free Functor is a natural Monad?
08:35:51 <obadz> sometimes I really wish we had means to debug haskell code that did not require rebuilding the world :-/
08:36:06 <hackrilege> ...
08:36:25 <Big_G> How do I actually construct this tree?
08:37:04 <hackrilege> Using the constructor
08:37:10 <nshepperd> Big_G: yes, for Free Pair as Iceland_jack says. for 'BST a = Free (Internal a) a' you'll need to write such instances yourself i think
08:37:16 <Iceland_jack> Big_G: 
08:37:16 <Iceland_jack>     leaf l r = wrap (P l r)
08:37:26 <Iceland_jack> that's it
08:37:39 <Iceland_jack> @let data Pair a = a :# a deriving (Show, Functor)
08:37:40 <lambdabot>  Defined.
08:37:48 <Iceland_jack>     leaf :: MonadFree Pair m => m a -> m a -> m a
08:38:05 <Iceland_jack> or
08:38:05 <Iceland_jack>     leaf :: Free Pair a -> Free Pair a -> Free Pair a
08:38:26 <Iceland_jack> sorry! branch
08:38:43 <Iceland_jack>     branch :: Free Pair a -> Free Pair a -> Free Pair a
08:38:43 <Iceland_jack>     branch left right = wrap (P left right)
08:38:56 <nshepperd> hackrilege: what you want is not possible. values do not have "identity" in haskell, so you can't tell if two 'branches' in the tree are the 'same' thing
08:39:05 <hackrilege> :t wrap
08:39:06 <lambdabot> Not in scope: ‘wrap’
08:39:25 <hackrilege> I could use pointers
08:39:39 <hackrilege> Which are instances of Eq
08:40:08 <hackrilege> I can tell if leaves contain the same references
08:40:29 <nshepperd> you could do that, if you want to violate referential transparency and make a brittle unreliable program
08:40:48 <hackrilege> Doh
08:41:05 <hackrilege> Seriously though, how do I do this properly?
08:42:12 <nshepperd> the keywords you want to google are probably 'zipper' and 'comonad'
08:44:34 <fr33domlover> Is there a typeclass for types which supports (1) get an empty "container" (2) append an item to a container? I suppose sort of generalization of Builder
08:48:26 <NikolajK> @nshepperd: k, thx the local thing worked
08:48:26 <lambdabot> Unknown command, try @list
08:48:49 <NikolajK> unshepperd, okay thanks, the local thing goes through
08:48:52 <nshepperd> fr33domlover: Alternative! empty = empty; append a xs = pure a <|> xs
08:49:24 <nshepperd> or xs <|> pure a, whichever way you want to go I guess
08:50:30 <fr33domlover> nshepperd, but is it the same thing semantically? Alternative suggests "pick one of them" and append is more like "remember all of them"
08:52:51 <hackrilege> could you briefly explain the relevance of zippers and comonads in this instance?
08:53:30 <hackrilege> I know comonad, it's basically an anamorphism
08:54:13 <hackrilege> Zipper is like a label on an element that can traverse a datastructure
08:55:06 <hackrilege> I don't see how these are helping me tie the knot in my binary tree I'm using to represent a double linked list
08:56:03 <nshepperd> fr33domlover: well, is it a problem if the caller decides they only want to be given one element and gives you an instance such as Maybe?
08:56:51 <nshepperd> containers that can contain multiple elements generally do have an Alternative instances that stores them all
08:57:34 <nshepperd> hackrilege: they're what you should be using instead of trying to tie the knot in a binary tree
08:58:25 <k0ral> fr33domlover: Monoid
08:58:32 <fr33domlover> nshepperd, if I use 'pure a' though, I can as well use Monoid :P
08:59:04 <fr33domlover> k0ral, yes thanks :)
08:59:14 <fr33domlover> I'll just keep my own typeclass for now
08:59:23 <fr33domlover> it's a trivial use case anyway
08:59:37 <paldepind> What does the apostrophe in this type mean: Get '[JSON] [User]
09:00:55 <hackrilege> But I'm trying to tie the knot in a binary tree...
09:01:09 <hackrilege> In which case this alternative helps little
09:01:50 <hackrilege> Are you sure such a process is impossible while retaining referential transparent?
09:02:34 * fr33domlover is using 'fgl' and it works great :)
09:02:51 <fr33domlover> (inductive graph library)
09:03:54 * hackagebot hit-graph 0.1 - Use graph algorithms to access and manipulate Git repos  https://hackage.haskell.org/package/hit-graph-0.1 (akrasner)
09:06:17 <bennofs> paldepind: where did you find that?
09:06:59 <bennofs> paldepind: I'd assume that it means that its a promoted [JSON] value, using the -XDataKinds extension
09:07:39 <bennofs> paldepind: so it's like a list value with one element (JSON), just at the type level
09:08:13 <hackrilege> What the hell is the point in me describing my problem over and over to have the only advice be "you need zippers". This is not teaching, or learning, or helpful!!!!!!!!
09:08:41 <hackrilege> If I had been helped sufficiently I would not have a problem
09:08:43 <nshepperd> hackrilege: yes, it's impossible
09:08:47 <hackrilege> Thank you
09:09:01 <nshepperd> knot tying is purely operational, it is not observable in pure code
09:09:06 <hackrilege> Why?
09:09:09 <nshepperd> effectively, it is just an optimization
09:09:21 <hackrilege> This does not make sense
09:09:59 <bennofs> hackrilege: you can tie the knot, but after you've done that, you cannot modify the structure any further (you can't "observe" the knot tying. So you could write a double-linked list, but you can
09:10:11 <bennofs> but you can't write an insert function for it if you use knot-tying
09:10:30 <hackrilege> The understanding I lack is about why I cannot update two references to the same data simultaneously. I think... Is that the problem here?
09:10:49 <bennofs> hackrilege: because you cannot update stuff that is immutable in general?
09:11:12 <hackrilege> Then why is creating two new references insufficient
09:12:49 <hackrilege> I have constructors for list, I can use them to pattern match the tail, I can't do this in 2d to write scan2d
09:13:52 <hackrilege> So I make Free Four as a tree, I make it's contents refer to the same object using pointers, I can traverse as desired
09:14:13 <bennofs> hackrilege: because you cannot update immutable values. you can only create a modified copy of them.
09:14:25 <hackrilege> Now I'm told I'm breaking everything and it will not work
09:15:01 <hackrilege> I will copy the whole object upon modification in order to simultaneously update the references
09:15:51 <hackrilege> But I guess that's so slow it ruins my nice neighbour accessing constructor I was using to access local information
09:16:58 <bennofs> hackrilege: hmm, I'm sorry I don't understand that. I haven't followed the discussion since its beginning, can you summerise in short what your problem is?
09:17:07 <hackrilege> How do I write scan2d. How do I represent a matrix?
09:17:24 <hackrilege> Using Free
09:17:55 <paldepind> bennofs: It's from the package servant's documentation.
09:18:20 <hackrilege> I think it looks like a kind of 2d double linked list, then I can access neighbours...
09:18:45 <paldepind> bennofs: Thank you! You are right. 'P refer to a promoted P.
09:18:55 * hackagebot cryptonite 0.15 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.15 (VincentHanquez)
09:19:02 <bennofs> hackagebot: what is scan2d?
09:19:09 <hackrilege> But I guess I really want a zipper To do that! To avoid copying the whole object
09:20:04 <nshepperd> oh well, if this is related to your scan stuff you should probably use the normal matrix representation, Vector (Vector a)
09:20:10 <hackrilege> bennofs, I can store values as i scan, dropping old ones from a buffer.
09:20:20 <nshepperd> which is by far the most efficient for a wholesale update like that
09:20:21 <hackrilege> I can't do this in 2d
09:21:15 <bennofs> hackrilege: in what order would a scan2d traverse the matrix?
09:21:28 <hackrilege> I want a Free datatype, I want to traverse using constructors like I do to define scan for list
09:21:53 <hackrilege> bennofs, many ways are possible
09:22:04 <hackrilege> It shouldn't matter
09:22:45 <hackrilege> > (1,2) < (2,1)
09:22:46 <lambdabot>  True
09:22:55 <bennofs> hackrilege: well, in scan for 1d lists, you have access to an "accumulator". Would that still be a single value in your 2D case?
09:23:01 <hackrilege> That's the natural ordering
09:23:11 <edwardk> > do do do do do do do do do do do do do do do do batman
09:23:12 <lambdabot>  "I'm batman"
09:23:19 <hackrilege> Lol
09:23:51 <edwardk> came up when testing a parser earlier
09:23:58 <nshepperd> haha
09:24:08 <hackrilege> Edk, why do your indexed monads have 3 type parameters!?
09:24:44 <hackrilege> Since the accumulator is polymorphic it can have funky type
09:24:44 <edwardk> hackrilege: http://stackoverflow.com/a/28708799
09:24:55 <hackrilege> Thanks
09:25:54 <hackrilege> It can't work with just a single Ix for the index?
09:28:59 <hackrilege> The problem with scan2d is that we would like to inform the compiler that elements not adjacent in terms of 1d traversal may be adjacent and should be contained in the "local" buffer
09:29:37 <hackrilege> If the accumulator is a buffer of fixed max length for storing adjacent values for eg a convolution
09:30:51 <bennofs> hackrilege: oh, so you want to have both the "top" and the "left" (assuming your scan starts in the top-left corner) values in the accumulator for scan2d?
09:31:26 <hackrilege> think stencil
09:31:55 <bennofs> that is kind of a different operation than scan is for list. with scan for list, you only have access to the current element, not its neighbours
09:32:09 <hackrilege> https://en.m.wikipedia.org/wiki/Five-point_stencil
09:33:07 <hackrilege> But the traversal of a 1d list uses constructors  to pattern match neighbors
09:33:18 <hackrilege> Free Four could do the same
09:34:11 <bennofs> hackrilege: oh, so you mean like (x:y:z:xs) in 1d?
09:34:15 <hackrilege> Basically it's a 0 access time query
09:34:35 <hackrilege> Yes like that bennofs
09:35:03 <hackrilege> But in 2d!
09:35:40 <hackrilege> Maybe there is a reason I was finding this difficult
09:36:34 <hackrilege> I can do this if and only if i use a mutable object?
09:37:38 <EvanR> maybe you can use 2 zippers at once
09:37:43 <hackrilege> (I can make the Free Four graph)
09:38:14 <hackrilege> EvanR how do envisage that working?
09:38:28 <puregreen> sm: around?
09:38:59 <EvanR> one zipper goes left and right and each node contains a zipper that goes up and down in the appropriate column
09:39:24 <hackrilege> Sounds perfect
09:40:13 <hackrilege> But if I had [[a]] I can't easily write the zipper. It uses !! Which is slow
09:40:40 <hackrilege> Hence my need for the four constructors of Free Four
09:40:43 <EvanR> if the requirement is to do it using [[a]] then..
09:40:59 <hackrilege> To step to the neighbors
09:41:13 <hackrilege> No I want a recursive datatype
09:41:33 <nocturne777> let's say we do "forkIO io" (t1)  and inside io we do another forkIO (t2).  After a while t2 receives an asynchronous exception. Does this asynchronous exception propogate to t1 and kill it as well?
09:41:42 <hackrilege> Low battery...
09:41:45 <EvanR> nocturne777: no
09:41:52 <EvanR> but you can arrange for that
09:42:00 <EvanR> the library async has a nice primitive for this
09:42:19 <sm> puregreen: hi
09:43:16 <EvanR> nocturne777: by default forkIOs just die when they get an exception and dont affect anyone else, unless its the main thread in which case everything comes crashing down
09:43:17 <puregreen> sm: I added ?~ and makeClassy, should I add anything else before making a release? (I could always make another release but it's more convenient to make just one)
09:43:39 <sm> puregreen: those are the only things I know of right now
09:43:47 <puregreen> okay, thanks
09:43:55 * hackagebot lambdaya-bus 0.0.0.1 - Fpga bus core and serialization for RedPitaya  https://hackage.haskell.org/package/lambdaya-bus-0.0.0.1 (ralu)
09:44:40 <nocturne777> EvanR: async library has this example:     withAsync (getURL url1) $ \a1 -> do      withAsync (getURL url2) $ \a2 -> do 
09:45:00 <nocturne777> so in this case, if a2 throws an exception a1 does not receive it ?
09:45:44 <EvanR> a1 and a2 are promises
09:45:57 <nocturne777> I know so we have to wait on them
09:45:57 <EvanR> whoever waits for them will recieve it
09:46:42 <EvanR> and whoever called withAsync
09:46:49 <nocturne777> it the case of "wait a1", if we get an asynchronous exception, a2 is gonna get killed (since it is the child thread)
09:46:57 <EvanR> a2 isnt a thread
09:47:26 <ggVGc> hahaha, this is pretty mad, https://github.com/seliopou/typo
09:47:28 <ggVGc> I like it
09:48:12 <nocturne777> EvanR: I know, but a2 is going to be executed in seperate thread
09:48:36 <EvanR> wait a2, yes
09:48:47 <nocturne777> the thread that executes a1 is the parent of the thread that executes a2
09:49:26 <EvanR> withAsync forms parents basically
09:49:33 <EvanR> normally that is not a thing
09:49:56 <EvanR> if the parent dies somehow, all children are killed
09:50:08 <nocturne777> EvanR: but not the other way around, right ?
09:50:18 <EvanR> if you are doing a wait then yes
09:50:45 <EvanR> because you as a parent will die, and the other children will be killed
09:58:04 <Guest12485> ggVGc: ha ha!  Reminds me of C++ template metaprogramming
09:58:46 <EvanR> nocturne777: oh wow.... it even has link and link2 which cause exceptions to be rethrown in whatever thread without having to wait
09:58:49 <EvanR> didnt know that
09:58:56 <EvanR> let the games begin
09:59:13 * hackagebot lambdaya-bus 0.0.0.2 - Fpga bus core and serialization for RedPitaya  https://hackage.haskell.org/package/lambdaya-bus-0.0.0.2 (ralu)
09:59:15 * hackagebot hsdev 0.1.8.0 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.8.0 (AlexandrRuchkin)
10:04:13 * hackagebot hdocs 0.4.4.2 - Haskell docs tool  https://hackage.haskell.org/package/hdocs-0.4.4.2 (AlexandrRuchkin)
10:07:34 <Ankhers> I'm trying to install hzk but it can't seem to find zookeeper.h. How can I tell stack / cabal where to find it?
10:16:52 <cocreature> Ankhers: there is an extra-include-dirs option that you can put in your stack.yaml http://docs.haskellstack.org/en/stable/yaml_configuration/?highlight=include#extra-include-dirsextra-lib-dirs
10:20:37 <Gurkenglas> Can finding what is expressible in terms of elements from a given set and a given binary operation be expressed as a graph problem?
10:21:11 <nocturne777> EvanR: come to think of it, I think I was asking the wrong question.  in the case of "wait a1 >> wait a2", if "wait a2" throws an exception, of course "a1" won't be affected as it is promise will already have been fulfilled. 
10:22:42 <hackrilege> Sorry, dropped connection
10:24:40 <nocturne777> EvanR: wheareas in the case of "waithBoth", it tries to wait concurrently.
10:30:20 <hackrilege> http://www.cl.cam.ac.uk/~dao29/ixmonad/ixmonad-fita14.pdf
10:30:27 <Gurkenglas> The trivial translation of the problem into something graphlike is having edges have two starting nodes and one end node. You'd look at the graph that has its node set be the given set, and that has an edge from each pair of nodes to the node that the operation combines them into. It'd be a sort of modified REACH. Is there a reduction of that onto anything that has already been worked on?
10:32:13 <EvanR> nocturne777: yes... if youre stuck waiting for a1 and a2 crashes you wont know it until later. so withBoth is faster
10:32:56 <hackrilege> Gurkenglas, what was the original problem?
10:33:29 <Gurkenglas> hackrilege, given a list of values of different types, build a term of a given type
10:36:57 <hackrilege> You would need some function
10:37:19 <Gurkenglas> some of the values are, of course, functions.
10:37:52 <hackrilege> I'm sure I don't understand! Sorry
10:38:20 <hackrilege> http://arxiv.org/abs/1401.5391 indexed monads with one type parameter
10:39:57 <Ankhers> cocreature: Thank you
10:40:25 <hackrilege> "The operation"
10:40:44 <hackrilege> Would need to be defined?
10:42:07 <Gurkenglas> The operation is function application
10:43:03 <hackrilege> So you can only apply functions to values, to values to values and not all of the element pairs have edges to return values
10:43:11 <hackrilege> Not*
10:43:28 <hackrilege> Am I missing something?
10:43:43 <hackrilege> I'm still not sure what is the question
10:43:49 <Gurkenglas> Right, it has to typecheck, the operation is partial. But that shouldn't change the reduction to a graph problem much, right?
10:49:00 <hackrilege> So your question is "is a graph of elements which are functions or values, where each value that can be applied to the functions is connected to them via the return value, equivalent to identifying all possible type checking function application operations between elements of the set"?
10:51:08 <hackrilege> I'm having trouble considering it because I can't make graphs or lists with various content types
10:51:36 <hackrilege> So I guess really your graph is just a big tuple
10:52:20 <oisdk_> Is there a name for a catamorphism which works on two structures at once? https://gist.github.com/oisdk/1f9f3e0245c95da8e735a797c68da88c
10:52:46 <hackrilege> And you want to find all pairs such that the type of the second element matches the first argument type of the first element?
10:54:15 * hackagebot cryptohash-sha256 0.11.7.1 - Fast, pure and practical SHA-256 implementation  https://hackage.haskell.org/package/cryptohash-sha256-0.11.7.1 (HerbertValerioRiedel)
10:54:17 * hackagebot hsdev 0.1.8.1 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.8.1 (AlexandrRuchkin)
10:55:28 <hackrilege> Is that right Gurkenglas?
10:56:21 <tippenein> what image processing library would you'all recommend? hip? friday? __ ?
10:56:36 <Gurkenglas> No, I assume that I already have all the pairs of values such that the first can be applied to the second. You shouldn't distinguish between functions and values too much.
10:56:36 <hackrilege> oisdk_ can you write this without Mu and Base? I don't understand the code... Can you until the recursive call?
10:57:12 <hackrilege> If you have those, what is the problem?
10:57:14 <Gurkenglas> Consider the alternative definition of graphs where edges, instead of connecting one starting node to one ending node
10:57:22 <Gurkenglas> connect two starting nodes to one ending node
10:57:26 <hackrilege> Ah
10:57:37 <hackrilege> No just use two edges
10:57:46 <Gurkenglas> No, that wouldn't work.
10:57:46 <hackrilege> What's wrong with that?
10:58:53 <Gurkenglas> Once you've introduced two edges for each possible function application, you can't tell which pairs of edges belonged together
10:59:23 <hackrilege> I see a graph of unconnected elements in a plain connected in pairs to elements in another plain, using two edges. Every element in the first plain had one edge, every element in the second pain has two...
10:59:46 <hackrilege> Aha
11:00:18 <Gurkenglas> The starting nodes and ending nodes are not in seperate sets, the ending node of one edge can be a starting node of another
11:00:46 <hackrilege> So the return value actually has many, but an even number of edges connecting it, and you want to retain which edges are in pairs..
11:01:01 <Gurkenglas> This all is to solve the problem of telling what nodes can be reached from some subset of all the nodes via the 2-1 edges. That means that whenever the two starting nodes of some edge are already inside the set, the ending node gets added to the set, until you can't make it any bigger
11:01:23 <hackrilege> Why not use a tuple, the index of the two elements and the return value?
11:01:38 <Gurkenglas> Rephrase that.
11:01:53 <hackrilege> An edge is a tuple of two indexes
11:02:00 <hackrilege> You want a tuple of three
11:02:07 <hackrilege> No?
11:02:41 <Gurkenglas> Right, although the first two from that triple are used in a different way from the third
11:02:52 <Gurkenglas> (The first two are called "starting" and the last "ending")
11:05:20 <oisdk_> hackrilege it needs Μu, or else the typechecker complains. I can do something similar for foldr https://gist.github.com/oisdk/7f4abd6ea1e362ddd2b654abc0343611
11:05:51 <oisdk_> I'm using the recursion-schemes library, I was just wondering if that kind of thing already existed
11:06:03 <hackrilege> Actually all three elements have unique type
11:06:28 <hackrilege> One is the function, one is the argument, one is the return.
11:06:37 <Gurkenglas> In the graph problem, whether you are the function or the argument shouldn't matter
11:07:23 <Gurkenglas> You need both to be in the set of expressible terms to be able to express the return
11:07:26 <hackrilege> Because you can find tuples containing this value as either the first second or third element of the tuple
11:07:46 <Gurkenglas> Rephrase that.
11:09:31 * hackagebot microlens 0.4.3.0 - A tiny part of the lens library with no dependencies  https://hackage.haskell.org/package/microlens-0.4.3.0 (Artyom)
11:09:33 * hackagebot cgi 3001.3.0.1 - A library for writing CGI programs  https://hackage.haskell.org/package/cgi-3001.3.0.1 (cheecheeo)
11:09:35 * hackagebot microlens-th 0.4.0.0 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.4.0.0 (Artyom)
11:09:37 * hackagebot microlens-ghc 0.4.3.0 - microlens + array, bytestring, containers, transformers  https://hackage.haskell.org/package/microlens-ghc-0.4.3.0 (Artyom)
11:11:51 <hackrilege> Sorry, phone needed charge
11:12:49 <hackrilege> I'm still not sure I understand.
11:14:31 * hackagebot microlens-platform 0.3.0.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.3.0.0 (Artyom)
11:14:53 <puregreen> sm: okay, I've released new versions of microlens and microlens-th
11:15:06 <hackrilege> data Graph a = {nodes::[(Int,(Either a (a->a))], edges::[(Int, Int, Int)]}
11:16:06 <hackrilege> How is that?
11:16:17 <FAuUiDkld> I'm writting a haskell book, anyone wants to read a page or two of it? : )
11:16:26 <hackrilege> I don't know how to make it polymorphic the way you desire...
11:16:45 <hackrilege> I'll proof read the pages, link them up
11:18:43 <Gurkenglas> It doesn't need to be polymorphic. data OpGraph a = OpGraph [a] [((a, a), a)]
11:19:08 <hackrilege> So what's the question?
11:19:52 <hackrilege> Indexes are better no? You have duplicate information I think
11:20:53 <EvanR> ok, async is officially awesome
11:21:03 <EvanR> so many sweet utilities
11:22:24 <Gurkenglas> opgraphreach :: Ord a => OpGraph a -> [a] -> [a] -- Given a list, find the smallest list containing all its elements such that for all edges with the starting nodes in it, it also contains the ending node
11:22:34 <EvanR> a page of code to seamlessly eavesdrop on encrypted conversation! http://lpaste.net/159339
11:22:51 <hackrilege> I'm still looking for an easier (than repa) implementation of stencil for a 2d matrix
11:22:51 <Gurkenglas> You don't need to implement this; I just want to see whether that can be reduced to some other graph problem
11:24:09 <hackrilege> Poor Alice and Bob
11:24:29 <Gurkenglas> EvanR, 21 and 23 should be "(alice, bob) <- getArgs >>= \case" so we know the args aren't used after 32
11:25:14 <EvanR> good call
11:25:26 <EvanR> what extension is that
11:25:31 <Gurkenglas> LambdaCase
11:26:01 <hackrilege> You forget the functions when reaching?
11:26:39 <Gurkenglas> hackrilege, "<hackrilege> Gurkenglas, what was the original problem?" <- that the original problem was function-value-stuff isn't actually relevant
11:27:11 <hackrilege> Kk
11:27:37 <sm> puregreen: thanks! I opened https://github.com/haskell-servant/servant-swagger/issues/39
11:28:07 <EvanR> it even "politely" waits for both taps to crash due to connection reset to end the program so they dont suspect anything
11:28:09 <puregreen> sm: (@neongreen, not @aelve)
11:28:16 <Gurkenglas> EvanR, 32 is exitSuccess? If that line happened in a batch script, I think it should fail. For similar reasons, 31 should go on stderr
11:28:17 * puregreen has a confusing system of nicks
11:28:33 <EvanR> Gurkenglas: agreed
11:28:59 <sm> puregreen: I'm confused, indeed.. microlens repo is https://github.com/aelve/microlens ?
11:29:52 <hackrilege> Anyway yes the mapping you describe is simple to implement, but as you don't store the functions, it's less informative than the original graph. Basically the graph is a crazy function to map over each element in the supplied list, concatinate with the original list and recursively apply this operation until the return list does not grow (fixed point)
11:30:08 <puregreen> sm: yep, but aelve more like a company— no, on the other hand, “FPComplete has released” is correct too so it doesn't matter
11:30:33 <puregreen> * is more like
11:30:46 <Gurkenglas> Shouldn't 53 be indented beyond 52 o.o? Are they, like, sharing the same do block
11:31:02 <Gurkenglas> *sharing lines 54-56, using some weird extension
11:31:36 <sm> oh I see, aelve is the organisation. Thanks
11:32:42 <EvanR> Gurkenglas: that is how the async docs do it
11:32:55 <EvanR> when you want several async actions running at once
11:33:14 <EvanR> also i updated the paste
11:33:32 <Gurkenglas> Why do 52 and 53 name a1 and a2, shadowing earlier equal names, when they aren't even used after that
11:34:04 <puregreen> sm: swagger2 uses makePrisms
11:34:06 <puregreen> https://github.com/GetShopTV/swagger2/blob/master/src/Data/Swagger/Lens.hs#L55
11:34:12 <sm> argh
11:34:17 <Gurkenglas> Why do 35 and 36 introduce those names in the first place? Is this even tested?
11:34:22 <puregreen> sm: yeah :(
11:34:25 <sm> I may have to give up on this :)
11:34:53 <puregreen> prisms mean profunctors, so yeah
11:35:41 <sm> I was thinking microlens would be a good thing to add to protolude/basic-prelude, eh
11:36:00 <EvanR> Gurkenglas: a1 a2 arent used
11:36:22 <EvanR> im sorry for using shadowing, even though shadowing is the shit
11:37:04 <Gurkenglas> I'll just do some initial refactoring annotation stuff
11:37:32 <EvanR> the original a1 and a2 are not used after the withBoth
11:37:50 <EvanR> if they were it would cause an error
11:38:27 <Gurkenglas> Oh wait I missed line 37, even though I did Ctrl-F. Huh
11:38:33 <Gurkenglas> I thought they just were unused
11:39:00 <hackrilege> Microlens is no good, should make a standard for what a minimal "lens" library should supply
11:39:22 <Gurkenglas> Why's there waitBoth but not waitAll?
11:39:45 <puregreen> hackrilege: there's no consensus *whatsoever* on what a minimal lens library should supply
11:39:55 <dolio> lens is the minimal lens library.
11:40:02 <hackrilege> Bs
11:40:40 <sm> hackrilege: that's uncalled for
11:40:46 <hackrilege> If such a specification existed at least it would then be obvious what the library provides
11:41:03 <ggVGc> how would i factor out the lens from this function? https://gist.github.com/4e2ea794b862935727618d1f6b03b52d
11:41:16 <ggVGc> the lens pointing to the current bar that is
11:41:58 <hackrilege> Perhaps the question is what functions can a lens library not exist without?
11:42:12 <dhinojosa> Mental check, you cannot create a module in GHCi, correct?
11:42:12 <hackrilege> And then put that in a class called Lens
11:42:47 <glguy> ggVGc: You're asking how to pass it to getCurBar as a parameter?
11:44:06 <Ainieco> how does aeson + GenericDerive process ALLCAPS json field names?
11:44:24 <puregreen> dhinojosa: seems to be correct
11:44:26 <Ainieco> does it downcases it ?
11:44:46 <ggVGc> glguy: well, more that I'd like getCurBar to instead be a lens that focuses on the "current bar instance"
11:44:54 <hackrilege> What functions would the lens class require an implementation for, just as a start
11:44:56 <ggVGc> glguy: so I can use it for setting also
11:45:30 <puregreen> Ainieco: by default it doesn't do any processing
11:45:46 <hackrilege> Until I can answer that question I feel I don't know what a lens is
11:46:15 <hackrilege> And the existence of such a class I would be reassured by...
11:46:26 <Ainieco> puregreen: how to deal with capitalized field names without manual FromJSON?
11:46:51 <puregreen> Ainieco: see https://artyom.me/aeson#generics-handling-weird-field-names-in-data
11:47:03 <glguy> ggVGc: You'll make a thing: curBar :: Traversal' Foo Bar
11:47:19 <puregreen> Ainieco: you still need “instance FromJSON”, but you can reuse generic decoding
11:47:23 <dhinojosa> :puregreen Thanks
11:47:39 <kostja> hi! why is there no netwire on stackage?
11:47:46 <hackrilege> puregreen, what are the best functions of lens in your opinion?
11:47:47 <Ainieco> puregreen: thank you
11:48:02 <bizarrefish> Hi all, I made an algorithm and I'm not sure what it's called. It's a way of storing a sequence of symbols, such that a list of locations of a given subsequence can be located in O(1).
11:48:09 <bizarrefish> I kinda want to call it a suffix-graph
11:48:22 <ggVGc> glguy: but how do I implement it? How do compose lenses where there are two "paths", like in this example where one "path" finds the index and the other uses the index to look in the "top level" list?
11:48:22 <bizarrefish> There's global index, Map[String->PosMap]. PosMap is Map[Number->String] . The index maps each known symbol/word to a PosMap. The PosMap maps a position integer to each following symbol, for every occurrence of the PosMap's symbol.
11:49:04 <glguy> ggVGc: I added a comment to your paste
11:49:19 <ggVGc> glguy: thanks!
11:49:55 <Clint> kostja: ask the maintainer
11:51:06 <hackrilege> Can anyone name a single useful function from the lens library?
11:52:05 <puregreen> hackrilege: lenses usually provide get :: s -> a and modify :: (a -> a) -> s -> s. Many libraries also support lens families, where modify :: (a -> b) -> s -> t. Van Laarhoven lenses also provide Functor f => (a -> f b) -> s -> f t. Which of those should the “lenses class” provide? I don't know.
11:53:26 <hackrilege> Thanks! What is s?
11:53:32 <ggVGc> glguy: is there some way (maybe convoluted) defining this `curBar` using only composition of existing lenses?
11:53:40 <Gurkenglas> Ah, mapConcurrently is waitAll, right?
11:53:48 <ggVGc> rather than defining a new traversal in this way
11:54:32 * hackagebot blatex 0.1.0.8 - Blog in LaTeX  https://hackage.haskell.org/package/blatex-0.1.0.8 (2016rshah)
11:54:57 <puregreen> hackrilege: “s” is the type of the “bigger” structure. You could sort of say that if you have “Lens' s a”, then you have a pointer to an “a” inside of “s”. </handwavy>
11:55:08 <glguy> ggVGc: Nope
11:55:31 <ggVGc> okay, cool, just trying to get a better understanding of lenses as a whole
11:55:34 <hackrilege> Shouldn't you say Lens s =>
11:55:39 <glguy> ggVGc: When you're defining new lens and traversals for your type you'll have to write them out. these are the base cases for the other stuff you'll compose
11:55:50 <ggVGc> yeah, that makes sense
11:56:05 <glguy> ggVGc: You might peek at the output of -ddump-splices to see what sort of things the template haskell is generating
11:56:08 <ggVGc> my current project has loads of custom setters and getters based on lenses, because I didn't know how to define new traversals
11:56:11 <glguy> the output isn't actually that complicated
11:56:11 <ggVGc> will sort that out now
11:57:04 <Gurkenglas> EvanR, I feel like your code calls for a monad transformer that just duplicates every line, once for alice, once for bob, because this isnt commutative so traverse doesnt help
11:57:04 <puregreen> hackrilege: I could say “Lens' l s a => l s a” but I'm not aware of any library that provides lenses as *classes* instead of just types and to be honest I'm not even entirely sure you can make Lens from “lens” an instance of a typeclass in a way that you want it to be, but I'm lazy to check right now
11:57:48 <hackrilege> So that this structure s, with its modifiable contents a has functions get modify and vanlaarhoven defined over it
11:58:22 <Ainieco> how to convert String to lazy ByteString?
11:58:34 <Ainieco> pack doesn't work because it expects [Word8]
11:58:36 <hackrilege> But then I'd expect s to take a as a parameter
11:59:01 <hackrilege> I thought there were all carrots and stuff...
11:59:02 <dolio> Ainieco: Use the .Char8 modules.
11:59:09 <Ainieco> dolio: ah, yeah, thanks
11:59:09 <puregreen> s and a can be unrelated types (e.g. I can make a lens that targets a Text inside a String)
11:59:20 <hackrilege> Hmm
11:59:23 <puregreen> (which is actually an isomorphism but whatever)
11:59:40 <hackrilege> But you need a casting between text and string then?
11:59:45 <puregreen> yep
12:00:11 <hackrilege> It seems like a Functor!?
12:00:25 <puregreen> hm, how so?
12:00:27 <hackrilege> How is a lens more than a Functor?
12:00:43 <hackrilege> This operation seems like fmap
12:01:45 <puregreen> well, yeah, “modify :: (a -> a) -> s -> s” could be thought of as fmap
12:01:47 <hackrilege> If it also is a Monad of Monoids then  then I can fold it
12:02:03 <hackrilege> As in get
12:02:04 <puregreen> don't forget that you also need “get :: s -> a”, which isn't related to Functor
12:02:18 <hackrilege> Yeah, that's fold
12:02:24 <Apocalisp> sounds like comonad :)
12:02:30 <ggVGc> glguy: why is `curBar` a traversal and not a prism?
12:02:42 <hackrilege> Or coreturn
12:02:47 <EvanR> Gurkenglas: im not sure a monad transformer would help
12:03:17 <glguy> ggVGc: Because you can't reconstitute the whole Foo given a single Bar
12:03:19 <EvanR> note thats its not 2 copies of the same code
12:03:41 <EvanR> they are entangled when it says f a b or f b a
12:03:44 <hackrilege> So really copure, don't need cojoin
12:04:03 <hackrilege> Lens is coapplicative?
12:04:24 <ggVGc> glguy: ah, I was locked onto "a prism has 1 or 0 results", but a prism also has to be able to backtrack to the original object?
12:04:30 <ggVGc> hm, why isn't that true for this though
12:04:39 <ggVGc> oh, yeah, I get it
12:04:39 <EvanR> there is 1 thread doing the dummy report not two, and im about to add another thread which disentangles both
12:04:46 <glguy> ggVGc: A Foo has an index and potentially many Bars
12:04:47 <EvanR> so the output doesnt get clobbered
12:05:21 <ggVGc> glguy: right, so going backwards I can only construct a Foo with the focused Br
12:05:24 <ggVGc> Bar*
12:05:28 <ggVGc> wich isn't the original object
12:05:30 <puregreen> hackrilege: fold can return more than one element, so it should be extend (or “coreturn”), yeah
12:05:35 <ggVGc> cool, that helped a lot
12:06:24 <puregreen> hackrilege: and of course, you can't just say (Functor s, Comonad s) => Lens s, because the whole point is that you should be able to have several different lenses for the same type
12:06:37 <hackrilege> I prefer copure...
12:06:56 <puregreen> copure sounds awful
12:06:57 <hackrilege> Several different lenses... Interesting
12:07:11 <edwardk> puregreen: Comonad has Functor as a superclass so that context, as little sense as it makes, is somewhat redundant
12:07:30 <eitanC> Hi all: Question, is there a library for heterogeneous sequences (i.e. finger trees)? HLists are great and easy to roll your own but operations have bad performance.
12:08:04 <hackrilege> I could get many functionalities such as Sum and Product
12:08:21 <hackrilege> I don't need lens, just datatype wrappers?
12:08:25 <eitanC> Hi @edwardk
12:08:38 <puregreen> edwardk: what's a class that provides extract without duplicate/extend?
12:08:51 <Cale> eitanC: There's https://hackage.haskell.org/package/dependent-map-0.2.1.0/docs/Data-Dependent-Map.html
12:08:54 <edwardk> puregreen: Copointed from the 'pointed' package
12:09:10 <hackrilege> Is the primary utility of lens to circumvent the constructors of these days wrapping instances?
12:09:11 <Cale> eitanC: Not exactly sequences, but might be useful in some of the cases where people tend to use HList
12:09:21 <edwardk> hackrilege: "Coapplicative" can't exist
12:09:26 <eitanC> Cale: thanks!
12:09:32 * hackagebot unfoldable-restricted 0.0.2 - An alternative to the Unfoldable typeclass  https://hackage.haskell.org/package/unfoldable-restricted-0.0.2 (athanclark)
12:09:59 <edwardk> contravariant applicative stuff exists, see Divisible and Decidable in the contravariant package, but it is a whole different beast
12:10:53 <mniip> is that something like 'f a -> a' with 'f (Either a b) -> (f a, f b)' ?
12:11:35 <edwardk> mniip: http://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant-Divisible.html
12:11:48 <ggVGc> glguy: hm, what do I do in a case like this where there's a function involved? https://gist.github.com/7da186cb73818d35af89388a6ad50b73
12:11:57 <ggVGc> I'd like to turn that into a Traversal also
12:12:48 <Gurkenglas> Why can't you supply liftA2 (,) instead of liftA2 id to define Applicative :I
12:12:51 <edwardk> mniip: the thing you just described can't exist. if f was functorial you'd be able to make f a into f (Either b a) then extract an f b, from the second operation, and a 'b' from f b -> b.
12:12:59 <mniip> wouldn't "divide id" be (**) ?
12:13:00 <glguy> ggVGc: First step is to make cursor a Traversal or Lens. It has to be "reversable"
12:13:19 <mniip> ooh
12:13:28 <ggVGc> ah, right..
12:13:43 <ggVGc> so that's the point of the Control.Zipper.Lens package
12:13:46 <ggVGc> thanks
12:13:49 <Gurkenglas> (and liftA0 () instead of liftA0)
12:14:53 <ggVGc> glguy: yeah, it makes sense. To make a new traversable all the oeprations have to themselves be traversabbles or lenses obviously
12:15:38 <edwardk> mniip: https://www.youtube.com/watch?v=cB8DapKQz-I starts off with an introduction of the contravariant applicative machinery by deconstructing the statement that a "monad is a monoid in the category of endofunctors" and motivating how applicatives are also monoids in that category w.r.t. a different notion of a tensor
12:15:52 <mniip> that went over my head :o
12:16:00 <edwardk> mniip: try the talk =)
12:16:04 <edwardk> i go a lot slower there
12:16:53 <hackrilege> It's not helpful ed
12:17:03 <hackrilege> You need to be able to be succinct
12:17:33 <sm> lol
12:17:44 <mniip> edwardk, by the way, I noticed a slight problem with the docs of some of your packages
12:17:54 <edwardk> ?
12:18:19 <hackrilege> Referring someone to an hour long presentation simply because the definition you would like to use is too high level, is not actually less of a barrier than the high level description
12:18:44 <edwardk> hackrilege: the very start of the talk is a detailed description of why the construction involved is universal.
12:18:54 <edwardk> you can use the class without caring where it comes from
12:18:54 <mniip> edwardk, e.g in profunctors, the TYPE kind pops up in a few places, and it's linked to a file:///usr/local/share/ URL
12:19:07 <athan> Is the -XTypeInType extension just `* :: *`?
12:19:08 <hackrilege> Something about fix fmap
12:19:13 <edwardk> mniip: this is an issue with building docs on ghc 8
12:19:36 <mniip> can't you just tell it to link to GHC.Types like it should?
12:20:02 <hackrilege> after studying your library I'm left clueless as to its utility. I see it as a large obfuscation threatening the future of our language
12:20:03 <sinelaw> What's the worst thing to lose if not having FlexibleContexts?
12:20:16 <mniip> sinelaw, mtl and friends?
12:20:44 <edwardk> hackrilege: the module in question is used to make my discrimination library work. that in turn lets you "sort in linear time" values drawn from any data structure in haskell worth sorting
12:20:45 <mniip> hackrilege, our whole language is a huge obfuscation
12:20:57 <athan> sinelaw: partially concrete constraints, like `MonadSomething Foo m`
12:20:59 <hackrilege> The documentation you provide is uninformative, your numerous explanations on stack exchange uniformly unintelligible
12:21:00 <edwardk> hackrilege: that is the motivation. now you can choose to spend time exploring why it works or not
12:21:02 <obadz> edwardk: speaking of succinct, is there a blog post/approachable explanation somewhere of the compressed string search using wavelet tries that you kindly walked us through at compose conf? Found the papers but that's a bit hard to digest?
12:21:40 <obadz> edwardk: found your explanation at the time to be crystal clear but it's hard to retrace it now :)
12:21:48 <edwardk> obadz: what you are looking for is an FM-index. https://en.wikipedia.org/wiki/FM-index
12:22:17 <edwardk> hackrilege: I'm sorry that you do not find what I do useful to you. You are free to not use it.
12:22:17 <sinelaw> mniip: yeah... It does complicate inference, doesn't it? You need to allow propagating constraints from unification somehow without pinning the constraint on a type variable
12:22:59 <hackrilege> I have spent a lot of wasted effort trying to understand your work. It is becoming MY job to communicate what you fail to and I do it from a much less informed position. Your inability to document your work adequately is add much as a shame as your work is a triumph
12:22:59 <obadz> edwardk: cool, thanks!
12:23:00 <mniip> are you implementing a typechecker?
12:23:16 <sinelaw> mniip: yes
12:23:31 <Cale> hackrilege: dude pls
12:23:35 <sinelaw> wtf
12:23:44 <edwardk> hackrilege: you are giving me very little reason to continue to try to engage you in discussion
12:23:52 <hackrilege> Ed, my problem is actually that I'm finding myself having to rewrite it without a decent description of how it works
12:24:12 <hackrilege> For people like me, with finite lives
12:24:21 <sinelaw> hackrilege: you can write your own libraries if you want
12:24:26 <puregreen> hackrilege: so someone is making you rewrite lens and that makes you annoyed?
12:25:09 <puregreen> I can sort of... imagine that
12:25:23 <hackrilege> My point is that I will have to sinelaw, and I wouldn't if ed had more skill communicating succinctly
12:25:26 <mniip> I tried rewriting a bit of lens and it was only fun
12:25:29 <Ainieco> https://artyom.me/aeson#parsing-without-creating-extra-types i don't understand what "people" function does, docs doesn't help https://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson-Types.html#g:5
12:25:36 <hackrilege> It's his life's work and many can't read it
12:25:43 <Ainieco> could someone please explain?
12:25:52 <edwardk> hackrilege: what is my life's work? lens? please.
12:25:54 <sinelaw> hackrilege: you also would need to if he didn't write it in the first place
12:26:01 <mniip> hackrilege, can many people read linux kernel code?
12:26:03 <hackrilege> And now it's my life's work to translate it without an intelligible manual
12:26:09 <sinelaw> hackrilege: get a new job?
12:26:10 <mniip> gmp code?
12:26:17 <mniip> stl code?
12:26:42 <hackrilege> Is that formalism becoming a corner stone of our language?
12:26:45 <Ainieco> seems like it doesn't matter what you give to withObject in "people" example, even empty string works
12:26:47 <sinelaw> hackrilege: somebody made something, gave it to you for free, and you are complaining that it isn't what you want
12:26:51 <Cale> hackrilege: no.
12:27:15 <Cale> hackrilege: lens is a library which you're free to use or not use.
12:27:21 <puregreen> Ainieco: yep, it doesn't matter
12:27:34 <puregreen> Ainieco: "people" is only going to be used in error messages
12:28:02 <hackrilege> Here is the goose that lays the golden egg, I bought it down the road. Which shop? Turn left at the Coyoneda
12:28:15 <Ainieco> puregreen: i see, thanks
12:28:45 <sinelaw> edwardk: I don't use lens and I think you're awesome
12:28:46 <mniip> hackrilege, the solution might not always be obvious
12:28:49 <mniip> unless you're dutch
12:29:21 <amovah> Hi, I’m newbie on haskell. I have question about groupBy
12:29:24 <hackrilege> I bought a phone back from the future! Did you bring the charger?
12:29:32 <athan> Are Word8's lightweight to store in a database? I think persistent converts them to ints or something, maybe acid-state does it minimally?
12:29:47 <hackrilege> Without clear explanation these tools are at best useless and at worst detracting
12:29:49 <athan> I just need a scalar value without massive amounts of precision
12:30:03 <sinelaw> this is getting to be annoying
12:30:03 <edwardk> http://packdeps.haskellers.com/reverse/lens shows 530 reverse dependencies on lens. hackage looks like it holds about 24x as many packages as that, so 4% or so of the libraries out there see to use lens. Now, sure, I've made some inroads in getting folks to adopt a library that I wrote, for myself, so I could play around with graphics. Nothing is making you
12:30:03 <edwardk> learn it or use it.
12:30:14 <mniip> lens is fairly well explained
12:30:24 <amovah> what are x and y parameters, in this: groupBy (\x y -> (x > 0) == (y > 0)) values  
12:30:46 <sinelaw> :t groupBy
12:30:48 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
12:30:49 <edwardk> there are dozens of tutorials and overviews of lens out there and I've spent more time documenting lens than any other package I've ever written.
12:30:54 <puregreen> regardless of how well or badly lens is explained, many people benefit from using lens so “Without clear explanation these tools are at best useless and at worst detracting” is a factually wrong statement
12:30:56 <athan> amovah: Thems are Nums
12:30:57 <Cale> amovah: They're the values being compared to see if they belong in the same group
12:30:59 <edwardk> That documentation is a sucking pit of need that will never be filled.
12:31:02 <thimoteus> and yet, plenty of people manage to use lens regardless
12:31:16 <athan> er shoot yeah Cale's right, actually just Ords
12:31:25 <dhex> Hi
12:31:34 <Cale> athan: No, they need to be Num as well, if 0 is to make sense
12:31:36 <dhex> How to write script to see who is join and then write a message? like a while loop
12:31:47 <Cale> But we came at the question from different ends :)
12:31:49 <athan> erp >< sorry, my head is a bit dusty
12:31:49 <edwardk> You're free to believe that more documentation could exist. You're free to send pull requests to try to get things explained better. I'm also rather thoroughly disgusted with this conversation.
12:31:51 <mauke> dhex: are you writing a spam bot?
12:31:57 <dhex> Yes
12:32:03 <athan> lol
12:32:03 <mauke> dhex: in haskell?
12:32:08 <dhex> no
12:32:13 <mauke> then why are you here?
12:32:15 <ralu> good
12:32:30 <dhex> Just want to see who is joining and write them a comment in same channel they joined
12:32:31 <mniip> I was about to mention progress
12:32:47 <mauke> dhex: you're off topic
12:32:49 <sinelaw> dhex: this channel is about the Haskell programming language
12:32:58 <dhex> ooooo shit
12:33:01 <dhex> lmao
12:33:25 <dhex> Sorry
12:33:36 <dhex> Sorry mauke mniip 
12:34:26 <Oejet> dhex: It might be more on-topic in #botters.
12:34:36 * hackagebot hsdev 0.1.8.2 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.8.2 (AlexandrRuchkin)
12:35:05 <mniip> I don't think many people on this network will be willing to help you write a spambot
12:35:41 <sinelaw> edwardk: in ermine, how do you track constraints? do you store with each unbound metavar? that would prohibit FlexibleContexts
12:36:14 <edwardk> you can't bury constraints int he variables, they really are part of the context
12:36:20 <sinelaw> or do you accumulate them while inferring a la "typing haskell in haskell?" (Which would support FlexibleContexts)
12:36:32 <edwardk> We're pretty close to THiH
12:36:46 <edwardk> in the scala version they are just administrative, and have no operational behavior
12:36:59 <sinelaw> edwardk: but what about the "row type has no label X" constraints
12:37:07 <edwardk> in the haskell version we emit a "witness" which is an elaborated term in core with holes for missing constraints
12:37:28 <edwardk> sinelaw: those have no residue in the runtime in either scala or haskell
12:37:38 <edwardk> they are proven at compile time and discharged there
12:37:40 <sinelaw> i'm talking about during inference
12:37:56 <sinelaw> they arise during unification
12:37:58 <edwardk> we accumulate a bag of constraints, THiH style, and discharge them
12:38:05 <sinelaw> unification accumulates constraints too?
12:38:26 <edwardk> unification never causes new constraints, it just merges variables mentioned in constraints.
12:39:37 <sinelaw> edwardk: e.g. when unifying two open row types, I need to introduce a fresh var for the intersection, and this fresh var needs constraints that it doesn't have any of the non-intersecting labels
12:39:38 <edwardk> a -> a with an undischarged Num a constraint  unifying with Int -> Int    becomes Int -> Int with an undischarged Num Int constraint, which then can easily be discharged
12:40:01 <athan> edwardk: Have you gotten a sweet constraint solver / type checker with propogators working yet? :D
12:41:19 <edwardk> no, unifying the two row types doesn't have to do any variable creation: If you have one row type, say a, that can be partitioned into d,e,f  and another b that can be partitioned into c and d. and unify a with b, then you have one row type a that can be partitioned into d,e,f  and also can be partitioned into c,d
12:41:29 <edwardk> this didn't require any new variables to be created
12:41:56 <edwardk> given the new context that only required unification to reach, it is now possible to discharge some constraints and show that c can be partitioned into e and f.
12:42:06 <edwardk> but that is done during constraint resolution, not unification
12:42:18 <edwardk> unification doesn't ever do anything with the constraint set
12:42:31 <edwardk> except unify some variables in it
12:42:48 <sinelaw> I see
12:42:50 <edwardk> athan: been off playing with other things for a while
12:44:00 <athan> edwardk: dangit ._.
12:44:22 <edwardk> athan: i'll be giving a couple of talks in 3-4 weeks about propagators though
12:44:36 <edwardk> one at lambdajam in brisbane, and another at yow! west in perth
12:45:27 <sinelaw> edwardk: I'm not sure I understood which part of the inference creates the composite partition constraint? not unficiation of 'a' and 'b'?
12:45:42 <edwardk> same general material, different emphasis. the former is mostly folks who know scala/haskell, the latter audience more java focused. So I'll be able to talk about haskell tricks a bit at the first possibly, while the latter will be mostly the theory side
12:45:48 <athan> eff yeah, I hope I'll be able to understand it!
12:46:20 <edwardk> there isn't a composite partition constraint, there are two constraints, just like there were before, but now both mention 'a' rather than one mentioning 'a' and the other mentioning 'b', since we unified a and b
12:46:54 <ralu> Is there any upcoming conference in Europe?
12:47:03 <sinelaw> ah ok
12:47:33 <edwardk> sinelaw: then later on during constraint simplification we find constraints we can discharge or simplify and remove them
12:49:13 <sinelaw> edwardk: so I assume row types 't' such as { foo : Int | r } are represented as just 't' + a constraint in the context saying t can be partitioned into { foo : Int } and { | r } 
12:49:51 <Hiro`> Hey everyone. The Yesod book tells me to use the -ddump-splices GHC command to view generated code for my application. Unfortunately, it doesn't tell me *how* to use it. (I'm running my apps like this: stack runghc my_app.hs.)
12:49:54 <edwardk> sinelaw: yep
12:50:26 <sinelaw> edwardk: cool, thanks 
12:51:09 <edwardk> sinelaw: by solely working with 'can be partitioned into' constraints we get a simple vocabulary that can express all the thoughts we need
12:52:00 <edwardk> type Has x y = exists z. x <- (y,z); type Lacks x y = exists z. z <- (x,y)
12:52:21 <edwardk> and Lacks acts as a disjointness check
12:52:49 <edwardk> (we have existentials in our constraint system for row types)
12:53:14 <sinelaw> is that easy to resolve mechanically?
12:53:42 <edwardk> yes
12:55:07 <edwardk> it just lets us move the quantifier under the =>, by using (exists y. Foo x y) => Bar x  instead of a more GHC like  forall y. Foo x y => Bar z
12:55:14 <Cale> Yeah, that partitioning primitive is really nice
12:55:46 <edwardk> this is necessary for us because our typechecker isn't like GHCs, but rather more like HMF, so we can only let people 'forall' over variables that occur on the right hand side of the =>
12:56:06 <sinelaw> Haskell 98 :)
12:56:09 <edwardk> since we have to put all of our variables in a canonical order
12:56:12 <sinelaw> (Not really, I know)
12:56:25 <edwardk> (this is needed for how we check rank-n types)
12:56:43 <edwardk> GHC uses a more clever scheme
12:56:44 <sinelaw> for skolem escape checking?
12:57:16 <edwardk> well, for checking that the variables are the same variables on either side.
12:57:25 <sinelaw> alpha equivalence?
12:57:33 <sinelaw> or do you mean something else
12:57:45 <edwardk> we can skolemize both in one pass, then unify with skolems in place
12:58:27 <edwardk> rather than have to do something to deal with two expressions like forall c. (forall a b. a -> b) -> c   not unifying with forall c. (forall b a. a -> b) -> c
12:58:50 <edwardk> HMF uses a canonical variable ordering based on first appearance
12:58:55 <edwardk> but constraints are unordered
12:59:38 <edwardk> so we needed first class existentials in our constraints to work around the simplistic model we picked for the rest of the typechecker
12:59:57 <edwardk> morally this could arise in haskell today
13:00:22 <edwardk> foo m = do x <- get; y <- m; put x; return y
13:00:36 <sinelaw> what's the problem with the constraints? 
13:00:37 <edwardk> foo :: MonadState s m => m a -> m a
13:00:54 <edwardk> 's' doesn't occur in the right hand side of the =>
13:01:01 <edwardk> but in our world we can use
13:01:11 <edwardk> foo :: (exists s. MonadState s m) => m a -> m a
13:01:25 <edwardk> (if we have the requisite fundep machinery, etc.)
13:02:06 <edwardk> ultimately you want (Foo a, Bar b) => ... to typcheck as (Bar b, Foo a) => ...
13:02:15 <edwardk> so you can't use the order that a and b occur in the constraints
13:02:40 <edwardk> you might be able to construct a global order on all constraints and reconstruct HMF semantics that way
13:02:43 <edwardk> but we didn't
13:02:55 <edwardk> brb
13:03:01 <sinelaw> ok
13:06:05 <edwardk> ok, back
13:06:33 <sinelaw> ok, I was wondering why we care about order of constraints at all? since unification always deals with the RHS 
13:06:37 <sinelaw> we don't compare them
13:07:13 <bizarrefish> Anyone used 'haste' in production?
13:07:27 <johnw> bizarrefish: good thing you quoted that, otherwise it would be a universal yes
13:07:31 <sinelaw> and I assume they are desgined to resolve to the same thing regardless of order
13:07:42 <bizarrefish> johnw: Heh, tru that
13:07:55 <athan> Anyone know where a good instance of Hashable might be for UTCTime? :(
13:08:41 <edwardk> sinelaw: the issue is that the way HMF unifies higher rank types requires the variables be put into a canonical order
13:08:44 <johnw> athan: isn't an accurate time sort of its own hash already?
13:09:21 <maerwald> cabal is annoying: http://lpaste.net/159350
13:09:38 <edwardk> sinelaw: the last rule in figure 5 in http://research.microsoft.com/pubs/64591/tr-2007-118.pdf
13:09:52 <sinelaw> edwardk: I was referring to what you said: "we needed first class existentials in our constraints to work around the simplistic model we picked for the rest of the typechecker"
13:09:53 <cocreature> maerwald: you forgot --shutupiknowhatimdoing
13:09:54 <sinelaw> ok looking
13:10:14 <maerwald> cocreature: it doesn't tell me anything about it, so cabal is obviously lying
13:10:24 <edwardk> manufactures a single skolem variable. then instantiates a in forall a. whatever     to that, and b in forall b. whatever to the same variable then proceeds.
13:10:46 <edwardk> and then simply checks for escape
13:10:51 <nocturne777> I find example "geturls9.hs" in the book misleading http://chimera.labs.oreilly.com/books/1230000000929/ch11.html#sec_conc-symmetric 
13:11:03 <sinelaw> edwardk, that's pretty straightforward, right
13:11:08 <nocturne777> in that example, the function is only capable of creating one promise at a time
13:11:17 <edwardk> it is gorgeously simple, and easy to build
13:11:21 <nocturne777> I don't think it can download multiple urls at the same time
13:11:36 <edwardk> but it isn't as flexible as the OutsideIn(X) shenanigans we play in GHC
13:11:41 <sinelaw> edwardk, it is
13:12:30 <nocturne777> EvanR: don't you think so ?
13:12:30 <athan> johnw: I think so, I'm just going with `hashUsing formatISO8601` :\
13:12:32 <sinelaw> edwardk, (I meant it's simple and easy to build, was agreeing)
13:12:52 <edwardk> it only really arises as an issue once you start allowing ImpredicativeTypes though, which GHC has largely given up on
13:13:06 <sinelaw> edwardk, so my question was why do the existentials help
13:13:34 <edwardk> at the time, however, a good chunk of our library was using impredicative types to hold reports and things that had quantifiers on the outside
13:14:28 <edwardk> To make that simple instantiation scheme work it relies on the fact that the forall'd variables will occur in the exact same order in both terms
13:14:39 <edwardk> which we can get from mthe right hand side of the =>
13:14:50 <edwardk> but the left hand side of => doesn't have any intrinsic ordering
13:15:10 <edwardk> HMF wasn't defined with typeclasses in mind
13:15:48 <edwardk> that's all
13:16:08 <mniip> RHS of => is a set, isn't it
13:16:12 <mniip> no ordering intended
13:16:13 <sinelaw> ok, but you don't need to unify the left hand sides, just accumulate them
13:16:21 <sinelaw> so what problem is there left to solve?
13:16:35 <sinelaw> (which is solved by existentials in the constraints)
13:16:40 <edwardk> mniip: you have an ordering from the shape of the term. think of it as a tree, walk the leaves left to right in first occurrence
13:17:05 <edwardk> sinelaw: you do need to 'unify' them if you have a rank-n type, and the nested quantifier mentions typeclasses
13:17:06 <mniip> that doesn't work on MPTCs, does it?
13:17:24 <mniip> oh wait, FlexibleContexts is something else huh
13:17:50 <ntnt> suppose I run into a situation where I go "hmm, a continuation would be a great idea here" -- at that point, shoudl ( 1) use continuations, or (2) re-examine my assumptions 
13:18:26 <sinelaw> edwardk, you mean checking that the constraints are exaclty the same when unifying a pair of rank-n type, ok
13:18:44 <edwardk> consider unifying (forall a b. (Foo a b, Bar b a) => b) -> c   with (forall d e. (Bar e d, Foo d e) => e) -> f
13:19:14 <maerwald> anyone got a fast low-level file copy function? I even tried with the sendfile syscall, but it's still somewhat slow
13:19:34 <edwardk> when we get down to the forall a b. (Foo a b, Bar b a) => b part of the unification, we go through the variables in a "canonical order", but the ordering on the left of the => isn't canonical
13:19:36 <maerwald> compared to C code at least
13:20:32 <boris_rh> #haskell-beginners
13:20:44 <sinelaw> so in HMF it is canonical, and then easy but it doesn't talk about constraints
13:21:00 <edwardk> sinelaw: and we bolted on constraints
13:21:02 <edwardk> yeah
13:21:47 <ggVGc> are these equivalent in this case, or is there a different? https://gist.github.com/eda3bbde2ea9b22e604ab390f1a29603
13:21:50 <ggVGc> they both compile
13:21:51 <sinelaw> and your solution is to existentials for the vars that appear only inside constraints
13:21:56 <sinelaw> *use
13:21:58 <edwardk> one can argue that we did the wrong thing for regular typeclass constraints, where the ordering does matter in terms of code generation, but for erasable constraints the ordering truly doesn't.
13:22:11 <edwardk> yes
13:22:17 <edwardk> which was about an hour's work
13:22:37 <edwardk> and nicely let us have things like Has and Lacks above
13:23:08 <edwardk> We've now spent longer talking about it than we spent implementing it ;)
13:23:16 <sinelaw> haha
13:43:45 <nitrix> edwardk: Do you mind the question "How long ago did you start learning Haskell?" and what background you had? I'm starting with absolutly not math background and some of the concepts are fairly overwhelming to say the least.
13:44:30 <edwardk> i started haskell in 2006. before that i never really did functional programming as such, but i'd done a lot of c++ template meta-programming
13:45:12 <nitrix> I see. 10 years is quite an awful lot of time in C.S. when I think about it...
13:45:39 <EvanR> encountered an interesting issue with duped Chans and async
13:45:42 <edwardk> i did have the benefit of just having finished a masters in math, and was in the process of finishing a masters in c.s. but the math i learned wasn't germane to anything haskell, and the c.s. didn't cover any of the relevant thought processes for haskell either come to think of it
13:45:52 <nitrix> So it is do-able; learning category / type theory on the fly and you dig your Haskell hole into "abstraction nonsense".
13:46:48 <edwardk> I jumped in with both feet, and started reading everything I could get my hands in in terms of type theory and category theory for months, assuming that everyone in the Haskell community knew all the same stuff Cale did. Little did i know he was a freak of nature ;)
13:46:58 <Cale> haha
13:47:02 <johnw> nitrix: you just described how I approached Haskell
13:47:13 <edwardk> and yeah johnw took the same path
13:47:19 <Cale> Wait, everyone doesn't know all the same stuff I do?
13:47:21 <johnw> for me, edwardk was a huge motivator
13:47:26 <edwardk> now he sits around proving stuff in coq all day
13:47:27 <nitrix> Yeah, I noticed Cale is a specimen already.
13:47:30 <EvanR> i have to leave in a second... but it seems that if you dup a Chan, and begin writing to the original in an async thread, then try to read the duped chan to get the data in a second async thread, it blocks on reading forever
13:47:34 <johnw> my constant goal was, "What do I need to read so that Ed doesn't sound like a freak of nature?"
13:47:37 <nitrix> edwardk: hehe :)
13:47:47 <EvanR> if you try to read the duped chan in the main thread it gets the data
13:47:58 <raichoo> johnw: Isn't that what drives most of us? :P
13:48:04 <edwardk> cale: we are slowly catching up =)
13:48:09 <johnw> raichoo: yeah, it's good to have heroes
13:48:19 <nocturne777> EvanR: are you talking about the problem I mentioned ?
13:48:19 <nitrix> edwardk: johnw, This is cheering me up. Thanks guys.
13:48:27 <EvanR> nocturne777: i dont think so
13:48:48 <johnw> not that edwardk always makes sense to me, still, but at least it's a ton of fun catching up
13:48:50 <raichoo> johnw: I would not go as for as calling Edward my hero, but he's certainly inspiring :D
13:48:51 <edwardk> that said, even if we ever do manage to catch up, ddarius will have lapped us a few times in the meantime
13:48:55 <EvanR> nocturne777: oh, actually i didnt say what you mentioned
13:49:14 <edwardk> I need to get him to get his ass back in here
13:49:36 <EvanR> nocturne777: let me try with -threaded
13:50:03 <EvanR> nope
13:50:23 <nocturne777> EvanR: it does it one at a time right?
13:50:32 <EvanR> nocturne777: when i get back i want to check what your problem was, but this isnt related
13:50:57 <EvanR> no it does both actions concurrently, but one cant get anything out of the duped chan. it does everything leading up to that
13:52:08 <nocturne777> EvanR: I don't understand the channel part. there is no use of channels in there
13:52:09 <EvanR> maybe its a weird interaction behind the scenes in STM
13:52:16 <EvanR> nocturne777: in my code
13:52:44 <EvanR> (a weird interaction with STM, given that Chans arent using STM i dont think and async is)
13:53:41 <nitrix> edwardk: Still using primarily Haskell day-to-day, after those 10 years?
13:53:51 <edwardk> Yep.
13:53:51 <nocturne777> EvanR: I just get the impression that the fact that "waitBoth a b" blocks won't let it process more than (one-two) at a time
13:53:53 <nitrix> :)
13:54:02 <edwardk> It is the best language I have to think in
13:54:19 <nitrix> edwardk: Looks like I have bread crumbs to eat. Thanks for that :)
13:54:33 <edwardk> If something sufficiently better came along, I'd switch in a heartbeat, but there isn't anything even close for me right now.
13:54:38 <EvanR> nocturne777: waithBoth a b waits for a and b, the threads associated with a and b were already running
13:54:45 <maerwald> edwardk: idris? 
13:54:53 <maerwald> I mean it's too early, but..
13:55:22 <edwardk> maerwald: i strongly believe laziness is the right default for composing algorithms, and dislike idris' notion of "typeclasses"
13:55:22 <EvanR> idris isnt lazy, doesnt have fancy extensions, barely has modules (not really), type directed disambiguation probably wont work for you
13:55:34 <EvanR> but its repl is very nice
13:55:36 <edwardk> maerwald: so it pretty much gets disqualified immediately
13:56:09 <maerwald> I want totality checker and dependent types though :(
13:56:20 <EvanR> a totality checking will probably make you hate totality checking
13:56:25 <EvanR> nocturne777: bbl
13:56:52 <edwardk> maerwald: i like having those things for roughly 5% of the code i write. when i need them, i go write stuff in coq
13:56:53 <nocturne777> EvanR: ok, let's talk when you are back
13:56:57 <nitrix> I want to believe in Laziness; I really do. It's hard to convince people. I've seen benefits a few time; but as a begineer trying to work on his game, it's infuriating.
13:57:41 <edwardk> nitrix: i look at it this way. every other language has taken the other side of the bet. i have this one language to really think in, and try to find new things.
13:59:04 <edwardk> haskell was designed as a research language to explore non-strict semantics. i find the output of that research to be fascinating
13:59:51 <nitrix> Agreed.
13:59:59 <edwardk> haskell doesn't need to "achieve success" by becoming every other language. Basically all of its successes seem to come from doubling down on the unique qualities it has.
14:01:09 <nitrix> Back to coding then >:)
14:01:33 <mniip> but StrictHaskell
14:02:59 <edwardk> mniip: *shrug* it makes tibbe happy, but the semantics of it are all over the place
14:03:14 <edwardk> i'm more interested in getting more interesting stuff into kind #
14:03:25 <mniip> what's kind #
14:03:26 <edwardk> where we can write strict code as needed with well defined semantics
14:03:30 <mniip> (that's not a thing anymore!)
14:03:57 <maerwald> I know this sounds scary, but can I check for a kernel version in a .cabal file? :P
14:04:42 <dolio> You can do it in a Setup.hs, I'm sure.
14:04:44 <mniip> edwardk, I was thinking about low-level computations recently
14:04:45 <maerwald> the sendfile(2) syscall allows to work on non-sockets since kernel 2.6.33 ... I don't think there's any macro for that
14:04:49 <mniip> but in a different direction
14:05:12 <mniip> rather than unboxed computations, I was interested in computations that do not allocate memory
14:06:55 <ralu> mniip: tell more please
14:07:08 <mniip> I'm afraid I don't have more
14:07:50 <edwardk> mniip: https://www.youtube.com/watch?v=I1FuZrDhOEk&index=16&list=PLnqUlCo055hVfNkQHP7z43r10yNo-mc7B is a little lightning talk about my structs package where i talk about more efficient classic strict 'oop' style code
14:07:55 <edwardk> inside the ghc runtime system
14:08:18 <mniip> edwardk, oh no I mean strictly no allocations
14:08:37 <edwardk> sure. i just don't have many computations that fit into that straightjacket.
14:08:45 <nocturne777> one should not use Control.Exception.Lifted and exceptions in the same monad stack. Am I correct on this assumption?
14:08:57 <edwardk> i was just fishing for the link for me talking about doing interesting stuff in kind #
14:09:00 <mniip> I have this weird idea of a (non-stg) functional programming language implementation that bootstraps on itself by having an allocator implemented in itself
14:09:24 <edwardk> mniip: sounds very BitC ish
14:09:57 <edwardk> i confess, once i can't have closures in a language, I find it kind of sucks to think in.
14:10:15 <mniip> stack-allocated closures?
14:10:30 <mniip> hmm
14:10:45 <edwardk> i have that language. it's called c++ ;)
14:10:48 <mniip> yeah
14:11:07 <mniip> C++ is dysfunctional though
14:12:27 <silver> there're functors!
14:12:49 <ralu> That re not functors I guess
14:12:55 <silver> aka overloaded operator()
14:13:15 <ralu> :D
14:13:31 <ralu> you got me
14:19:48 <ralu> Reason being that I have never realized how Functors in Haskell is different from Functor in C++.
14:20:22 <nocturne777> edwardk: there's the "exceptions" library authored by you and there's also the Control.Exception.Lifted from the "lifted-base" library. in a given project, is there a case where in some parts of the project you prefer one library over the other or do you simply use one of them at all times? 
14:23:06 <nocturne777> I personally want to limi my self to "exceptions" only, but some of the libraries that I use rely on MonadBaseControl
14:23:17 <athan> Can I write a function definition with multiple lines? Like `foo (Foo a);  (Foo b) = ...`?
14:23:44 <mniip> put foo after ;
14:24:16 <athan> mniip: ? no, I want to split the pattern matches of my two parameters
14:24:25 <athan> if `foo :: Foo -> Foo -> ...`
14:24:32 <mniip> ah
14:24:40 <mniip> that I'm not sure you can do
14:24:54 <athan> yeah I think you're right :\
14:25:52 <dmj> @def fzzz :: Maybe Int -> Int; fzzz (Just 3) = 3; fzzz Nothing = 4  
14:25:53 <lambdabot>  Defined.
14:26:32 <mniip> dmj, they mean something along the lines of foo a b = ...
14:26:36 <mniip> but with a newline between a and b
14:27:33 <dmj> mniip: don't see why that would be a problem
14:28:06 <mniip> dmj, care to demonstrate?
14:30:07 <athan> dmj: Yeah it causes a parse error :\
14:30:22 <athan> I'm just `let`ing to break them apart instead
14:30:33 <dmj> then I don't understand, new lines between parameters are allowed in top level definitions
14:31:04 <mniip> athan, that introduces a change in the closure structure and potential change in performance
14:31:34 <dmj> athan: can you paste code that causes the parse error
14:31:55 <athan> mniip: :\ shoot
14:32:42 <athan> http://lpaste.net/159358
14:33:42 <dmj> athan: no parse error for me
14:34:15 <athan> ><
14:43:02 <athan> Iceland_jack: Hey! So that `one` function you wrote only shows the mutual termination toward bottom, s.t. `one :: (a -> Void) -> (((a -> Void) -> Void) -> Void) -> Void`, not that `(a -> Void) = (((a -> Void) -> Void) -> Void)` :s
14:43:12 * athan has no idea how this style of equality works
14:43:45 <athan> something like `data (=) a b where; refl : a = a` or something? So it would leverage a constraint solver to do the typechecking?
14:43:56 <athan> I think I'm thinking funny
14:50:40 <llinguini> Hey can I match entire lists
14:50:42 <athan> Does anyone here know how to add Word8 or bit-like structures without them cycling their value, or overflowing?
14:50:55 <athan> llinguini: Yep, you should be able to do `foo [1,2,3,4] = ...`
14:51:06 <athan> but that's very partial
14:51:11 <edwardk> nocturne777: exceptions handles situations where the base monad is not IO
14:51:16 <llinguini> athan: So I have a list of type [Exp] and Exp has a constructor CloVal
14:51:25 <llinguini> I want to do something if list contains all CloVals
14:51:31 <llinguini> is there a way to pattern match that?
14:51:37 <Cale> athan: convert them to Word16 first?
14:52:02 <athan> llinguini: You could make a condition: `foo xs | all isColVal xs = ...`
14:52:19 <athan> where `isColVal (ColVal _) = True`
14:52:30 <athan> Cale: Yeah... :\ hm
14:53:57 <xnil> is there a way to use the `type` keyword alongside typeclass constraints?
14:54:17 <xnil> say, i have a type variable `Real a`
14:54:30 <xnil> and i frequently use [a]
14:55:01 <xnil> i'd like to give this a more semantic name; could i not just call it 'Reals'?
14:55:14 <Cale> You mean Reals a ?
14:55:14 <xnil> or am i forever destined to write `Real a => [a]` ?
14:55:20 <xnil> no, Cale
14:55:29 <athan> xnil: I'm actually pretty sure you can
14:55:34 <Cale> Then no, that's not possible
14:55:38 <athan> `type Reals a = Real a => [a]`
14:55:40 <athan> shoot
14:55:46 <xnil> i'd like to just write `:: Reals` instead of `:: Real a => [a]`
14:55:54 <xnil> i figured as much. that's alright.
14:56:04 <Cale> Besides, type synonyms are evil
14:56:10 <xnil> hardly!
14:56:15 <xnil> well, i suppose so.
14:56:29 <Cale> They make it really awkward to figure out how to use things, because you have to know about all of them
14:56:32 <xnil> i'm interested in learning at a conceptual level how data constructors are passed around
14:57:07 <xnil> what does their computational overhead look like if nowhere in your program do you do pattern matching on them?
14:57:22 <xnil> do they just take up a byte or so of memory?
14:57:27 <Cale> Well, they take memory
14:57:33 <nocturne777> I always encounter the term "base monad". in this monad stack, "ReaderT AppConfig (ExceptT Err IO) a", can we say that the base monad is ExcepT ?
14:57:33 <Cale> several bytes
14:57:34 <xnil> sure haskell could...
14:57:38 <xnil> newtype.
14:57:40 <xnil> i should use newtype.
14:57:44 <athan> xnil: I think it's a word per cell, plus a word for pointing unless you use {-# UNPACK #-} or something similar
14:57:52 <dmj> nocturne777: it would be IO
14:57:59 <Cale> There will be a 64 bit constructor pointer, and then pointers to each of the fields.
14:58:08 <xnil> Cale: thank you.
14:58:32 <nocturne777> dmj: so, the base moand simply means the monad at the bottom of the entire monad stack ?
14:59:50 <xnil> could i perhaps use `newtype Reals a = Reals a` and instantiate `Reals a` as a member of the `Real` typeclass?
14:59:50 <ill_logic> Do I want to put my constraints in my cabal.config file or my MyProject.cabal file?
14:59:53 <llinguini> one more question, what's the right place to put a where after a case
15:00:00 <xnil> or is there a more intuitive way of doing this
15:00:07 <llinguini> for example case (somefunc x) of 
15:00:13 <Cale> nocturne777: I really kind of dislike all the superfluous terminology surrounding monad transformers
15:00:26 <Cale> (especially "stack")
15:00:27 <llinguini> then I want to do where somefunc
15:00:31 <llinguini> or is it better to do let?
15:00:51 <athan> llinguini: I use `where` usually at the end of some statement
15:00:57 <athan> while `let` can be used more inline :)
15:01:05 <nocturne777> Cale: yes, it can be a bit confusing when different people are using different terms. 
15:01:19 <athan> so `foo ... = ... let n = ...; x = ...; ...; where bar = ...`
15:01:45 <Cale> The difference between let and where is that where is part of the syntax of declarations, and will scope over multiple guards
15:02:03 <McOmghall> Is there any typeclass that implements internal difference in a type?
15:02:25 <athan> McOmghall: Num?
15:02:35 <Cale> McOmghall: internal difference?
15:03:00 <Cale> (whereas let is part of the syntax of expressions)
15:03:04 <McOmghall> Yeah, like it generalizes across types that implement internal subtraction
15:03:09 <McOmghall> be it integers or sets
15:03:15 <Cale> What is "internal subtraction"?
15:03:40 <dmj> nocturne777: yea
15:03:45 <McOmghall> it's 2 - 1 = 1 for integers
15:04:08 <McOmghall> and {a, b} - {a} = {b} for sets
15:04:21 <McOmghall> subtraction that results on an element of the same type
15:04:33 <Cale> ah, then not really
15:04:44 <athan> McOmghall: There's actually a bit of theory regarding why those two operations aren't the same idea
15:04:59 <athan> but Num implements subtraction
15:05:23 <McOmghall> i see
15:05:27 <athan> something something ring over symmetric difference :s
15:05:57 <McOmghall> then I'll guess I make my own typeclass 
15:06:00 <McOmghall> ty guys
15:07:28 <Cale> McOmghall: These two operations have different laws -- there's not really anything corresponding to addition in the set case, since the set you're subtracting might have elements in it that aren't in the set you're subtracting it from.
15:07:54 <Cale> McOmghall: So it's hard to write code which is genuinely polymorphic across both.
15:11:52 <athan> Cale: Do you know of a _truncating_ fromIntegral? It just causes cycles too :\
15:11:59 <athan> > fromIntegral (500 :: Int) :: Word8
15:12:01 <lambdabot>  244
15:12:15 <athan> ideally it would just be 254 :\
15:12:31 <athan> > fromIntegral (-10 :: Int) :: Word8
15:12:34 <lambdabot>  246
15:12:41 <athan> which would ideally just be `0` ><
15:14:17 <mirpa> you have to check that Int is in bounds of Word8 first
15:15:37 <athan> mirpa: There's nothing lower level? :\
15:15:46 <athan> id hate to have to waste cycles on that condition
15:16:09 <mirpa> overflow is most sensible low-level thing to do
15:16:45 <mirpa> in terms of performance
15:17:10 <athan> well yeah, but I'm just trying to see if there's something else that already exists
15:17:15 <athan> for this use case
15:17:15 <mirpa> so anything else will incure performance penalty
15:17:33 <athan> hm :\
15:18:27 <mirpa> I don't think so, you probably want to define overflow as either error or Maybe...
15:19:09 <mirpa> but you can use minBound/maxBound from Bounded typeclass
15:21:24 <mirpa> or mask lowest byte and test for zero
15:35:30 <athan> Can I have 0-arity guards?
15:35:51 <athan> something like `let x | someVarInScope < z = ...;`?
15:36:18 <mniip> have you tried?
15:36:25 <hpc> you can do empty case with i forget the name of the extension
15:36:35 <hpc> it's meant to be used with Void
15:36:51 <hpc> it's case {} of _ | ... -> ...
15:37:13 <mniip> huh
15:37:33 <athan> thanks :)
15:37:39 <hpc> or something like that
15:37:42 <athan> idk it just goes against the grain for what I've been taught :\
15:39:20 <mirpa> aren't you looking for MultiWayIf?
15:40:17 <verement> > let x | False = 2 | True = 3 in x
15:40:18 <lambdabot>  3
15:48:46 <llinguini> So I run the following
15:49:41 <llinguini> DefVal n v -> do putStrLn (show val)
15:49:42 <llinguini> return env' <- H.insert n v env
15:49:51 <llinguini> Then I get parse errorn on the return
15:51:03 <verement> why do you have return?
15:52:33 <llinguini> should I not?
15:52:53 <aarvar> llinguini: the left side of a generator needs to be a pattern
16:11:11 <deeplow> :t
16:11:15 <deeplow> :t map
16:11:16 <lambdabot> (a -> b) -> [a] -> [b]
16:28:33 <Geff22> Hello to all. I have a strange problem with GLFW: some times ago I write an application with using GLFW-b. And it's work normally on both ow my computers. But today application start to fail initialization on one of them. I think that problem with Haskell or with OS, becouse C++ GLFW example project work normally. So I don't know how to fix it or find reason why 'init' faild. Does any one now what can it be? Also I upgrade my vidocard drivers, but this 
16:28:33 <Geff22> doesn't help.
16:29:52 * hackagebot gpio 0.1.0.0 - Simple project template from stack  https://hackage.haskell.org/package/gpio-0.1.0.0 (tgolson)
16:29:54 * hackagebot gpio 0.1.0.1 - Haskell GPIO interface, designed specifically for the RaspberryPi.  https://hackage.haskell.org/package/gpio-0.1.0.1 (tgolson)
16:45:28 <llinguini> Hey so I'm looking at this one line of code but I'm having trouble understanding what it really means
16:46:10 <llinguini> eval <$> ee <*> pure env
16:46:27 <llinguini> I know that <$> does fmap eval ee on the list ee
16:46:34 <llinguini> but what is the second part really doing
16:52:21 <verement> :t (<*>)
16:52:23 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:53:54 <verement> > Just (+1) <*> Just 4
16:53:55 <lambdabot>  Just 5
16:54:47 <verement> > [(+1), (*2)] <*> [2..4]
16:54:48 <lambdabot>  [3,4,5,4,6,8]
16:58:24 <ryantrinkle> is there a way to specialize a function on the strictness analysis of its application site?
16:58:39 <ryantrinkle> in particular, i'd like to use a different implementation if one of the arguments is *known* to be in WHNF
16:58:41 <ryantrinkle> statically
16:59:45 <mniip> not without hacking deep into the RTS
17:00:07 <mniip> but see GHC.Prim.unpackClosure#
17:00:36 <mniip> but there be dragons
17:01:32 <ryantrinkle> mniip: weird, that's listed under bytecode operations
17:01:51 <mniip> it gives you the closure type
17:02:01 <mniip> oh wait
17:02:03 <mniip> it does not
17:02:07 <mniip> sec
17:02:40 <mniip> oh
17:02:44 <llinguini> verement: I don't understand what's happening in the second example with the lists
17:03:00 <mniip> getClosureType x = case unpackClosure# x of (# i#, _, _ #) -> indexInt32OffAddr# (plusAddr# i# 8#) 0#
17:03:03 <mniip> was my implementation
17:03:10 <mniip> but that's only for x86_64 ghc
17:03:15 <llinguini> Also what is the pure really mean?
17:04:14 <Tertain> llinguini: list is an Applicative, so it's [2 + 1, 3 + 1, 4 + 1, 2 * 2, 3 * 2, 4 * 2] 
17:04:25 <verement> llinguini: every function from the first list is combined with every value from the second list
17:14:57 <hackrilege> im trying to understand zippers, could someone talk me through an example? i have prepared a paste, this is basically how i would like to use zippers... http://lpaste.net/159364
17:20:36 <hackrilege> with so many dependencies its important its well presented. i admit its more than one mans job
17:21:28 <puregreen> I'm having a weird bug with acid-state/safecopy (specifically, when I add a phantom parameter migration stops working) – does anybody know what's going on? http://lpaste.net/159365
17:21:32 <hackrilege> thats all i was trying to say
17:22:46 <hackrilege> puregreen, not sure about the libraries you are using sorry
17:24:23 <hackrilege> is it possible to use zippers on cyclic datatypes?
17:26:20 <xa0> Why not? They're lazy
17:30:12 <hackrilege> i heard it broke referential transparency..
17:31:44 <Eduard_Munteanu> Um, no? Streams (infinite lists) have zippers just fine.
17:34:01 <hackrilege> > let (x,y) = (0:y,1:x) in x
17:34:02 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
17:34:44 <Cale> If you want to maintain the cyclic-ness, that's not happening though.
17:34:52 <hackrilege> :(
17:35:28 <Cale> The first thing you do is going to turn the cyclic datastructure into an infinite one -- they're indistinguishable as values of course.
17:35:33 <hackrilege> did you see the stencil im trying to extend to 2d? http://lpaste.net/159364
17:36:07 <hackrilege> i thought if i included neighbors in a second list to a rose tree...
17:36:32 <hackrilege> data Cycamore a = a [Cycamore a] [Cycamore a]
17:36:57 <hackrilege> some of the neighbors should not be traversed too..
17:38:02 <hackrilege> following only the path indicated by the first list, but allowing access to unwise (leading to infinite loops) neighbors for easy local access...
17:38:28 <hackrilege> would that fix it??
17:39:31 <hackrilege> this thing that extends the loops to make an infinite datastructure you describe would not occur unless you traversed to the elements of the second list
17:41:16 <Cale> Well, okay, if you make a zipper on a cyclic datastructure, it's indistinguishable from a corresponding infinite one. As soon as you make a change somewhere, it's no longer really cyclic.
17:41:20 <hackrilege> the elements of the first list should indicate a Hamiltonian path
17:41:42 <Cale> Because well, it's just not -- there's an element in the middle of this doubly-infinite sequence which is different from the others.
17:42:24 <hackrilege> and apparently i cant update the neighbors?
17:45:18 <Cale> If you're working with structures which are supposed to remain cyclic, and be noticeably so, I recommend using something like an IntMap, where the keys in the IntMap act as pointers.
17:45:43 <hackrilege> > let (x,y) = (0:y,1:x) in (\l->[a|a<-zip [1..] l,(fst a) == 2]) x
17:45:47 <lambdabot>  mueval-core: Time limit exceeded
17:46:16 <hackrilege> i can see that it would break the way you describe ^
17:46:25 <hackrilege> right?
17:46:58 <hackrilege> i want to traverse using constructors and pattern matching
17:47:18 <hackrilege> as im used to writing recursions using (x:xs)
17:47:24 <Cale> Yeah, that's not going to be nice at all
17:47:30 <hackrilege> but this breaks down in 2d
17:47:44 <hackrilege> and i was thinking about Free Four
17:47:57 <Cale> It's possible to *make* cyclic structures like that, with trickery like tying the knot
17:48:12 <hackrilege> but then it needs to have these dumb references i cant update...
17:48:17 <Cale> But their cyclic nature is fragile
17:48:23 <hackrilege> i would like also to edit them
17:48:42 <Cale> Asking to be able to edit the references is the same as asking for mutation.
17:48:53 <hackrilege> so i use TVar?
17:49:02 <Cale> Basically, that would involve every variable being an IORef, or a TVar, sure.
17:49:11 <hackrilege> its slow?
17:49:39 <Cale> It's not slow, it's just horrible
17:49:45 <hackrilege> thats ok
17:49:49 <Cale> (and hard to figure out what'
17:50:04 <Cale> what's going on if mixed with lazy evaluation)
17:50:15 <hackrilege> should be fine
17:51:01 <hackrilege> the constructors are the zipper methods
17:51:09 <hackrilege> eg, up
17:51:45 <hackrilege> data Four a = Four {up::a,right::a,down::a,left::a}
17:52:05 <hackrilege> is that right?
17:52:18 <hackrilege> im not sure if thats how zippers work...
17:52:36 <hackrilege> in Free Four
17:53:52 <hackrilege> no idea how to put the TVar into that to make it work!
17:54:50 <hackrilege> up.right == right.up
17:55:02 <hackrilege> in a really deep way...
17:55:28 <hackrilege> i guess i just construct i carefully?
17:55:41 <hackrilege> over...
17:56:38 <Cale> hackrilege: Well, you wouldn't use zippers if you were building everything out of mutable cells
17:57:06 <Cale> hackrilege: The zipper for a 4-way branching tree is pretty complicated
17:57:59 <hackrilege> hmm
17:58:07 <hackrilege> i dont see why zippers are out now...
17:58:48 <Cale> hackrilege: Well, the purpose of a zipper is to represent a point of focus in an immutable structure around which you can make edits efficiently.
17:58:59 <Cale> If everything is mutable, you can make edite efficiently anyway
17:59:04 <Cale> edits*
17:59:23 <hackrilege> here is the version i had using Data.Map btw http://lpaste.net/
18:00:14 <MarcelineVQ> :>
18:00:30 <hackrilege> aha, but the most effecient traversal for a full update, like map, is with a neat zipper... thats why i wanted these methods to quickly access neighbors
18:00:51 <hackrilege> oops
18:00:52 <hackrilege> http://lpaste.net/159367
18:01:31 <Cale> hackrilege: I don't think that's true. If you're rebuilding the whole structure anyway, there's no point in using a zipper
18:01:58 <hackrilege> fine
18:02:05 <hackrilege> no zippers here
18:02:11 <hackrilege> thats ok for me
18:02:29 <Cale> The point of a zipper is to allow fast edits around some local cursor. You wouldn't want to incur the overhead of going back and forth between an original type and its zipper if you were reconstructing everything
18:02:36 <hackrilege> but i think my traversal will still use the methods eg up that look to me like the kind of things you get from using zippers
18:04:07 <hackrilege> its expensive to load things into the zip of the zipper, the container that the data is temporarily loaded into (like my buffer in http://lpaste.net/159367), is a wasteful way to do a traversal
18:04:10 <hackrilege> is that right?
18:04:24 <hackrilege> its*
18:04:32 <hackrilege> so its*
18:04:33 <hackrilege> sorry
18:05:26 <hackrilege> is my buffer stencil anything like a zipper?
18:05:52 <Cale> If you're doing convolution, you probably want all your data in arrays of some sort.
18:06:08 <hackrilege> oh it was here sorry http://lpaste.net/159364
18:06:09 <Cale> Well, if you care about performance at all
18:06:51 <hackrilege> could i describe a structure to you and see how you would deal with the cycles?
18:07:02 <ryantrinkle> any suggestions for low-level profiling haskell code? e.g. is there a way to get linux's 'perf' to have better symbol names for haskell code?
18:07:02 <hackrilege> ok, a lasso
18:07:42 <hackrilege> a single list whose last element is somewhere inside it making it cyclic
18:07:50 <Cale> hackrilege: I suppose I can see why a zipper on the original 2D array is tempting just because you want to be able to see the neighbours of each cell quickly.
18:07:56 <hackrilege> yes!
18:08:03 <hackrilege> thats the whole point
18:08:16 <hackrilege> its That speed that is alluring
18:08:18 <Cale> hackrilege: However, building that zipper is much more expensive than doing the entire convolution ought to be, if you care about performance
18:08:37 <hackrilege> i dont need to with Free Four
18:08:52 <hackrilege> the zipper would only afford me methods that are the constructors of Four
18:08:54 <hackrilege> right?
18:09:29 <hackrilege> accessors sorry
18:10:57 <hackrilege> eg tail is a fast computation
18:10:58 <Eduard_Munteanu> ryantrinkle, do you already know how to use GHC's profiling?
18:11:25 <hackrilege> when pattern matching (:)
18:11:27 <Cale> Eduard_Munteanu: yes
18:11:38 <hackrilege> i guess its lazy...
18:12:27 <hackrilege> am i making sense Cale?
18:12:41 <Cale> ryantrinkle: This isn't really what you're asking about, but there's ThreadScope...
18:14:45 <Cale> hackrilege: It's just if you have a really large image (istr you said you were working with gigapixel images), then the allocation involved in constructing these things, even if you're clever enough to ensure that the right parts become garbage so that maximum space usage isn't insanely high, just the time taken doing allocations is going to be ridiculous
18:15:23 <Cale> hackrilege: and it seems really hard to ensure that it'll perform sensibly, just to avoid a small amount of index arithmetic on 2D unboxed arrays
18:16:24 <Sonderblade> im reading that haskells old generation is collected using copying. doesnt that mean it requires twice as much memory than if it had used in place compacting?
18:16:38 <hackrilege> ok
18:17:23 <hackrilege> thing is though, its that very anamorphism that is my thesis
18:17:51 <hackrilege> and the cojoin should only use local data
18:18:25 <hackrilege> > repeat 0
18:18:27 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
18:18:58 <Cale> hackrilege: If it's just an academic exercise and you don't really care whether it's going to take forever, well, use whatever data structures you like
18:19:07 <hackrilege> > iterate (:0) []
18:19:08 <lambdabot>      Occurs check: cannot construct the infinite type: t ~ [t]
18:19:08 <lambdabot>      Expected type: [t] -> [t]
18:19:08 <lambdabot>        Actual type: [t] -> [[t]]
18:19:12 <hackrilege> sry
18:19:36 <hackrilege> i would love to Cale, but i cant figure out how to do my 2dGrid...
18:19:47 <hackrilege> using Free Four
18:19:49 <Cale> hackrilege: It's just that there's really very few appropriate data structures which don't involve big flat packed arrays at that scale.
18:20:08 <hackrilege> riiiiight
18:20:25 <hackrilege> hence our constant pulling in opposite directions
18:20:30 <hackrilege> thats what i need to not use
18:20:43 <Cale> Why not?
18:20:52 <hackrilege> because i want to use Free Four
18:21:06 <hackrilege> to do this pattern matching navigation thing
18:21:41 <hackrilege> its taken me long enough to determine thats what im trying to do
18:22:05 <hackrilege> handling the nasty cycle from right.up==up.right
18:22:24 <hackrilege> and i really could do with some help because i cant figure out how to do that
18:22:50 <hackrilege> mostly i receive suggestions to use Array, which isnt really what im getting at
18:23:44 <hackrilege> and i cant be sure even if i understand it correctly...
18:24:46 <Cale> Yeah, that's going to be the problem. Your type is indistinguishable from a 4-way branching tree
18:26:55 <mniip> here's an idea
18:26:59 <Cale> hackrilege: Everyone's going to tell you to use arrays because they're assuming you want a program that works
18:27:16 <hackrilege> cool ill clear that up initailly next time
18:27:19 <mniip> prefer one cardinal direction to the other, and do a list of lists
18:27:32 <Cale> yeah
18:27:50 <hackrilege> hmm?
18:27:55 <Cale> You could use a list zipper of lists, and then turn the focused one into a list zipper
18:28:13 <hackrilege> a 4 way branching tree with branches pointing to the same thing is whats required
18:28:26 <mniip> ListZipper a = ([a], [a])
18:29:12 <mniip> GridZipper a = (ListZipper (ListZipper a, a), ListZipper a)
18:29:29 <llinguini> Hey so I have a Constructor Val String, and I want to git rid of the container and return the raw string in a lamda function
18:29:35 <llinguini> I can't think of how to do it
18:29:45 <Cale> llinguini: case?
18:30:29 <llinguini> \v -> case v of (Val s -> s)?
18:30:33 <hackrilege> mniip that is blowing my mind
18:30:41 <Cale> llinguini: yeah, something like that
18:30:50 <llinguini> Doesnt this have an unmatched pattern? can I safely ignore the unmatched case?
18:31:01 <Cale> llinguini: You can't safely ignore the unmatched case
18:31:09 <Cale> You should handle it somehow
18:31:22 <Cale> llinguini: I don't know the definition of your type
18:31:24 <hackrilege> cant i just use Free Four, handel the cycles and use a Tree Zipper?
18:31:47 <hackrilege> is your way better?
18:32:01 <llinguini> Cale: What if I check that the input of lambda has to be of the above type? 
18:32:21 <Cale> llinguini: You can just write (\(Val s) -> s)
18:32:38 <mniip> ok how about
18:32:42 <Cale> llinguini: but you'll get an essentially uncatchable exception if the input to the lambda doesn't have that form
18:32:55 <mniip> data ListZipper a = ListZipper { left :: [a], right :: [b] }
18:33:09 <Cale> llinguini: it's not a good way to do things unless you're really sure it's really going to be a Val s
18:33:35 <hackrilege> i get the List Zipper!
18:33:35 <mniip> data GridZipper a = GridZipper { above :: [(ListZipper a, a)], below :: [(ListZipper a, a)], here :: ListZipper a }
18:34:12 <hackrilege> hmmmmmmmm
18:34:24 <Cale> llinguini: If you have to test the thing to see whether or not to apply this function to it, then you ought to just be pattern matching it at that point
18:34:25 <hackrilege> That Looks Good
18:34:26 <ryantrinkle> Eduard_Munteanu, Cale: I think i found what i need: https://www.schoolofhaskell.com/user/bitonic/perf-for-low-level-profiling
18:34:52 <mniip> wait I forget
18:35:00 <mniip> is a Zipper of a type T
18:35:00 <ryantrinkle> i'm profiling at the level of tens of nanoseconds, so -prof is a bit of a confounder
18:35:04 <hackrilege> i have no idea why you have lists of zippers though
18:35:14 <mniip> dT/dx
18:35:18 <mniip> or dT/dx * x
18:35:27 <hackrilege> !?!?!?
18:35:45 <Cale> ryantrinkle: interesting
18:35:50 <mniip> is it the one-hole context, or do we store the value being examined, too
18:35:50 <llinguini> Cale: patternmatching looks cleaner too. I will do that.
18:35:53 <ryantrinkle> Cale: it's low level reflex stuff
18:36:30 <ryantrinkle> hunting for small improvements to very-frequently-used stuff like performEvent :)
18:36:34 <hackrilege> store the value might as well
18:36:46 <hackrilege> ListZipper = ([a],a,[a])
18:36:53 <ryantrinkle> *subscribeEvent
18:36:57 <ryantrinkle> not performEvent
18:37:19 <ryantrinkle> hopefully ghc 8 will be out soon :)
18:37:27 <hackrilege> or even (a,([a],[a]))
18:37:34 <hackrilege> for extending to 4
18:39:00 <hackrilege> data Periodic2dGrid a = Periodic2dGrid {contents::a,coord::Coord,north::(Periodic2dGrid a),east::(Periodic2dGrid a),south::(Periodic2dGrid a),west ::(Periodic2dGrid a)}
18:39:16 <llinguini> Cale: Thank you I think this is working correctly now.
18:40:02 <hackrilege> if its not periodic use Maybe a
18:40:15 <hackrilege> for one of the neighbors on the edges
18:40:25 <hackrilege> to be Nothing
18:44:54 <hackrilege> wait so if ListZipper a = ([a],a,[a]) then GridZipper = ListZipper (ListZipper a)!?!?1!??!?
18:45:13 <hackrilege> ??
18:47:15 <hackrilege> its something to do with this right? http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.8611
18:47:45 <hackrilege> but i dont understand any of that...
18:49:49 <hackrilege> ok..
18:49:56 <hackrilege> no confirmations...
19:24:42 <JoshS> I was just arguing over what order macro evaluation makes sense in (I know, non-haskell) languages.  And i was arguing for inside-right
19:24:48 <JoshS> that's similar to normal order...
19:25:07 <JoshS> I hear that Haskell has something like macros in templates
19:25:15 <JoshS> is that outside-in?
19:27:21 <geekosaur> lazy evaluation is outside-in, and often gives you something akin to macros in other languages
19:28:34 <JoshS> It seems to me that macros that actually process what's inside them can only be stable if they never see a new macro inside them
19:28:44 <JoshS> therefore macros should be evaluated from outside in
19:28:54 <JoshS> "new" as in "defined at a later time"
19:29:10 <JoshS> I mean
19:29:13 <JoshS> I said that wrong
19:29:27 <JoshS> therefore macros should be evaluated from INSIDE OUT
19:29:43 <JoshS> I'm tired
19:29:58 <ryantrinkle> is there a way to warn when the non-specialized version of a function is used?
19:30:01 <geekosaur> keep in mind that Haskell does not actually give you macros (ignoring TH for the moment)
19:30:03 <JoshS> inside out is harder... But in some languages right to left would do it
19:30:19 <JoshS> I'm designing a new languages
19:30:23 <geekosaur> it's just that lazy evluation makes macros unnecessary for many (not all) uses
19:30:33 <JoshS> how about template-haskell
19:30:52 <JoshS> what is it's evaluation strategy
19:30:53 <maerwald> pure evil
19:31:12 <JoshS> EVIL petting zoo?
19:31:26 <geekosaur> template haskell gives you actual macros, insofar as it is evaluated at compile time instead of runtime and generates an AST. it's still lazy evaluation, just at compile time
19:31:42 <geekosaur> so still done from outside in but on demand instead of stgrictly
19:32:10 <JoshS> well if a macro can demand the result of another macro it COULD be inside out in effect
19:32:14 <JoshS> but the matching would have to be smarter than I can imagine
19:33:50 <geekosaur> you can't really do that with TH though, since a TH splice produces an AST and you would have to essentially duplicate the compiler's internals to process that AST further
19:34:07 <geekosaur> (so, TH is *also* not a macro system in the usual meaning of the term)
19:34:36 <JoshS> yeah the substitution has to be smart to do taht
19:34:44 <JoshS> sigh .. too tired to type well or work
19:34:48 <JoshS> I better get some rest
19:34:54 <geekosaur> TH code can invoke other code at compile time, but that produces normal values (just at compile time)
19:35:16 <JoshS> does anyone like my idea of inside out macros?
19:35:35 <JoshS> does that simplify
19:36:10 <geekosaur> in fact, when we need "real" macros we tend to use the C preprocessor (which means, problems on OS X and FreeBSD because clang's cpp doesn't like Haskell code very much...)
19:36:17 <JoshS> lol
19:36:39 <JoshS> use ed :p
19:36:58 <dolio> I don't know what qualifies CPP as a real macro that TH fails.
19:37:14 <dolio> CPP is just less overhead if you're doing dumb text stuff.
19:40:48 <geekosaur> anyway: evaluating from the inside out is necessary for strict evaluation. for lazy evaluation, outside in works better\
19:41:18 <geekosaur> this is more or less independent of macros, except insofar as a macro system (e,g, cpp as applied to Haskell) may use strict instead of lazy evaluation
19:41:50 <geekosaur> ...I should say , may not use the same kind of evaluation as the language itself
19:42:09 <JoshS> usually they're not strict in that sense, but they're still strict :/
19:42:21 <dolio> I'm also not sure why one order would make more sense for macros.
19:42:31 <geekosaur> I didn;t say it did
19:42:31 <JoshS> well the issue I see is
19:42:41 <geekosaur> I was pointing out that cpp is strict (TH is not!)
19:42:43 <JoshS> if a macro is code rather than templates
19:42:52 <dolio> Either your outer macros get to see the unexpanded inner macros and work on them, or only get to see the expanded results of those macros. The choice is arbitrary.
19:42:55 <JoshS> or even if it is
19:43:03 <geekosaur> so for cpp you get evaluation from the inside out, but only for what cpp itself evaluates
19:43:06 <JoshS> I have a language with no macros
19:43:10 <JoshS> call it language A
19:43:18 <JoshS> I add a macro b to it
19:43:25 <JoshS> now it's language B
19:43:30 <JoshS> I add another macro to it
19:43:34 <JoshS> now it's language C
19:43:46 <JoshS> but macro b was written for language A or B
19:43:48 <JoshS> not for C
19:43:58 <JoshS> It can't recognize the new construct
19:44:11 <JoshS> but if macros are evaluate inside out
19:44:21 <JoshS> then all macros ONLY see language A
19:44:43 <JoshS> Is that clear?
19:44:46 <geekosaur> yes
19:45:12 <JoshS> funny, the people in #scheme can't seem to follow my argument
19:45:46 <dolio> How do I write a macro that works on B if I want to, then?
19:46:10 <JoshS> A becomes A
19:46:13 <JoshS> B becomes A
19:46:14 <geekosaur> are they thinking about it *in* scheme? one of the (if not *the*) point of scheme is hygienic macros... which ought to avoid that issue
19:46:18 <JoshS> so you always write to A
19:46:23 <JoshS> so there is no problem
19:46:38 <JoshS> they avoid SOME issues
19:46:39 <dolio> Yes, there is a problem. I want to write a macro on B, not A.
19:46:50 <JoshS> but not all cases of that problem
19:47:21 <geekosaur> anyway this is fairly complex and I'm not too surprised that some people have trouble keeping track of the multiple levels
19:47:28 <JoshS> dolio, but my method gives you a stable system that doesn't depend on what macros are included
19:47:45 <dolio> It avoids one problem and has other problems.
19:48:25 <geekosaur> OI'm also seeing dolio's point. and sensing Gödel lurking somewhere in the background... 
19:50:07 <dolio> I don't think it's really an evaluation order issue, either. Or at least not necessarily.
19:50:47 <dolio> You'd probably only think about it that way if you're not being precise about what type of things are being operated on, like in Lisp.
19:50:56 <geekosaur> it's not. that does give you a handle to more easily think about the ramifications, by sticking to a simpler subset as it were
19:51:29 <dolio> Like, TH works the way described, but it's evaluating things lazily, presumably.
19:52:36 <dolio> You will just never see syntax with TH inside it, because you only get to see the result of running any TH inside the syntax in 'outer' TH.
19:52:58 <geekosaur> I should also mention that lazy evaluation could be either inside-out or outside-in; outside-in just gives you more expressiveness that you can't easily get via strict evaluation (except by using closures to achieve laziness)
19:53:31 <JoshS> is lazy evaluation outside-in in mechanism but inside-out in effect?
19:53:44 <dolio> Just like you don't need to evaluate things inner-most first to make sure that functions only see the _result_ of inner functions, and not their unevaluated expressions or something.
19:54:07 <geekosaur> JoshS, see what dolio just said
19:55:48 <geekosaur> you will get the same result either way, outside-in just retains more laziness longer whereas inside-out is more strict in effect (this matters if you are, for exmple, using a lazy list but only taking part of it. if you switch to inside-out you may end up evaluating the whole list (which will never complete because it's infinite) before the part that limits the result
19:57:18 <dolio> The important thing is that if I write `f (1 + 1)` f is not able to tell that I didn't write `f 2` instead.
19:57:39 <dolio> I don't have to reduce `1 + 1` to `2` before entering f to accomplish that.
20:00:21 <geekosaur> hm, actually no, laziness is the difference between inside out and outside in. both are actually outside in initially; strict means you need to keep working your way inward to find the thing to evaluate, lazy means you stop until something requires the next level inward
20:01:44 <JoshS> I see
20:08:11 <dolio> Anyhow, I agree that this is a sensible property for a language to have. I don't want `f : Integer -> Integer` to be able to do something special when given `g x : Integer` by knowing that its argument came from g.
20:08:52 <dolio> But I could imagine a macro language throwing some of that out.
20:13:57 <Sgeo> I made something akin to edwardk's reflection library in a different language (Rust), how should I show it off?
20:15:18 <ertesx> Sgeo: demonstrate its usefulness
20:15:32 <cyphase> Show HN maybe?
20:16:01 <Sgeo> It's actually slightly unergonimic to use and bloats the binary, tbh
20:17:16 <ertesx> Sgeo: reflection is very useful, so if you feel that its usefulness outweighs its weaknesses, write an example program and show it
20:17:52 <ertesx> ideally it should be difficult or awkward to express without reflection
20:18:12 <Sgeo> I don't think I actually have a sufficient understanding of its use cases
20:19:04 <ertesx> Sgeo: some information is better communicated on the type level:  information that is type-bound rather than value-bound
20:19:36 <ertesx> the canonical example is modular arithmetic:  the modulus is type-bound, while the integer is value-bound
20:20:09 <ertesx> (+) :: Mod n -> Mod n -> Mod n  -- all values share the same modulus, but they differ in their representants
20:21:27 <Sgeo> Hmm. But the approach I took is painful overkill for that use-case... maybe. Or not, if someone wants to do modulus with BigInts or something
20:21:50 <ertesx> Sgeo: have you used 'reflection' in a non-trivial way?
20:21:54 <Sgeo> ertesx, nope
20:22:04 <ertesx> then you should do that first =)
20:22:11 <Sgeo> But I want to write Rust code lol
20:22:21 <llinguini> What's the best way to check if everything in a list is equal?
20:22:32 <llinguini> considiring large lists
20:25:56 <ertesx> llinguini: write a simple recursive function
20:26:23 <ertesx> you can do it with a cascaded fold, but that may be ugly
20:26:50 <ertesx> :t \xs -> foldr (\x _ -> foldr (\y -> (x == y &&)) True xs) True xs
20:26:52 <lambdabot> (Eq a, Foldable t) => t a -> Bool
20:27:03 <ertesx> (\xs -> foldr (\x _ -> foldr (\y -> (x == y &&)) True xs) True xs) [1,1,1,1]
20:27:10 <ertesx> > (\xs -> foldr (\x _ -> foldr (\y -> (x == y &&)) True xs) True xs) [1,1,1,1]
20:27:11 <lambdabot>  True
20:27:15 <ertesx> > (\xs -> foldr (\x _ -> foldr (\y -> (x == y &&)) True xs) True xs) [1,1,2,1,1]
20:27:17 <lambdabot>  False
20:28:21 <harwiltz> Hi guys. I'm writing a program in haskell that has a recursive 'loop', which waits for user input to go onto the next loop. However, I have a signal handler that is called when the terminal is resized, and that screws up the display of my program. 
20:28:35 <harwiltz> I'm using hscurses, so I want to pass the newly edited windows to my loop
20:28:39 <harwiltz> Is this possible?
20:29:27 <ertesx> harwiltz: if you can handle the window change within the loop, it's simple…  i don't know if ncurses has event waiting
20:29:46 <ertesx> otherwise you need to use concurrency, e.g. an MVar or STM
20:29:47 <harwiltz> ertesx: I'm handling the window change using a handler that I install with installHandler
20:30:03 <harwiltz> ertesx: Mind explaining what that is? Never heard of that
20:30:35 <ertesx> harwiltz: think of the signal handler as a separate thread…  the MVar is a simple abstraction that allows threads to communicate
20:30:42 <ertesx> see Control.Concurrent.MVar
20:30:58 <harwiltz> That sounds like it might be helpful. Thanks
20:31:19 <ertesx> harwiltz: you may want to check out vty, too
20:31:35 <harwiltz> ertesx: I think pretty much everyone in this channel that I've spoken to says that :)
20:31:49 <harwiltz> I've been working on this for a while though, don't want to restart now
20:32:16 <geekosaur> note that curses installs its own handler for SIGWINCH so make sure that yours is invoking its (this likely means installing it after initscr() and saving the existing handler tpo be called from yours)
20:32:40 <harwiltz> geekosaur: Yup, mine is definitely invoking the right function
20:33:21 <harwiltz> I tried starting another loop from my handler, and it works for one frame then gets very glitchy for some reason
20:33:37 <harwiltz> Probably because both loops are handling each input
20:35:51 <ertesx> is there a way to compile the executables of a cabal project with different compilers?  specifically: one with GHC, one with GHCJS
20:37:25 <ertesx> harwiltz: you might find STM useful in this case, because you are going to use a separate thread for gathering input anyway
20:37:53 <harwiltz> Do you guys know if there is a way to 'inject' some sort of key event? For example, I'm detecting keys with getCh, if I can send a key to my original loop I can stop the loop
20:38:05 <harwiltz> ertesx: Just about to look into that
20:38:13 <ertesx> harwiltz: the signal handler may communicate with your loop, and the input thread does, too…  in your loop you no longer look for input, but you see whether one of the threads put something into the MVar
20:38:14 <geekosaur> harwiltz, not at all portably
20:38:16 <harwiltz> But there is no info on thr hackage page
20:38:25 <geekosaur> you probably want an MVar for that
20:38:33 <harwiltz> ertesx: Ohh I see
20:39:00 <geekosaur> rather than trying to write a binding for the TIOCSTI ioctl, and then generate a key sequence to inject with it from terminfo (urgh)
20:39:06 <harwiltz> But then isn't an MVar like a imperative language variable?
20:39:07 <ertesx> harwiltz: to do that properly you need an MVar (Either InputEvent WinChEvent)
20:39:37 <ertesx> harwiltz: with STM you can have two separate channels (TMVar) and see which one has a value in a transaction
20:39:53 <ertesx> harwiltz: yes, MVar is imperative
20:39:56 <geekosaur> (for one thing, you have zero control over whether your TIOCSTI is happening in the mmiddle of a terminal-generated key sequence)
20:40:23 <harwiltz> ertesx: I didn't realize this was possible in Haskell... I probably should have done this in C haha
20:40:51 <ertesx> harwiltz: the way to write interactive applications non-imperatively is with functional reactive programming (FRP), but it has a learning curve of its own
20:40:59 <geekosaur> ^
20:41:08 <geekosaur> and I don;'t think there's any FRP for curses as yet
20:41:16 <geekosaur> or vty for that matter
20:41:19 <ertesx> neither is there for vty
20:41:21 <harwiltz> So basically all ncurses haskell programs use this MVar for terminal resizing?
20:41:40 <ertesx> harwiltz: under the hood FRP is going to use it, too =)
20:42:03 <ertesx> MVar, even though it's high-level, is rather low-level by haskell standards =)
20:42:10 <harwiltz> So my function has to take a TMVar as a parameter now right?
20:42:23 <ertesx> first decide whether you want the MVar or the STM approach
20:42:38 <harwiltz> probably regular MVar actually
20:42:43 <ertesx> MVar is very easy to learn, while STM is useful generally
20:43:01 <harwiltz> I literally just need it for this purpose only, so I think it should be fine
20:43:12 <ertesx> in that case before your start anything that might put something into the MVar, you create it
20:43:20 <geekosaur> keep in mind that the available wrappers over (n)curses are fairly thin, plus STM is more suited to threads and threads will break curses fairly badly
20:43:27 <ertesx> trust me, you will "need" it for much more, once you get into haskell concurrency
20:43:29 <ertesx> =)
20:43:54 <harwiltz> I'm just using haskell for recreational purposes, hopefully it wont come to that hahaha
20:44:02 <geekosaur> so you're often better off with the simpler imperative-style stuff just because it behaves more like curses expects
20:44:14 <harwiltz> So I use newEmptyMVar to initialize it
20:44:24 <harwiltz> And then pass that to my function
20:44:45 <ertesx> yeah, you refer to that MVar in your loop, in your signal handler and in your input gatherer
20:45:00 <ertesx> if you gather input from curses, you have to create the thread using forkOS (see geekosaur's comment)
20:45:07 <harwiltz> Is the MVar going to be passed a Window?
20:46:05 <harwiltz> Maybe a bit stupid, but do you know if there's a way to just restart the program in the handler?
20:46:10 <harwiltz> That might be easier
20:46:27 <ertesx> harwiltz: very simple example:  do msgVar <- newEmptyMVar; forkIO (forever $ takeMVar msgVar >>= print); forkIO (forever $ putMVar msgVar "blah"); forkIO (forever $ putMVar msgVar "blubb"); getLine
20:46:46 <ertesx> harwiltz: yes, but it involves threads as well =)
20:46:54 <harwiltz> ertesx: Jesus
20:46:57 <ertesx> really, learn MVar…  it takes 10 minutes to see how it works
20:47:50 <harwiltz> yea... i just kinda have finals to study for and wanted to work on this quickly, didn't expect to have to do so much research lol
20:48:17 <ertesx> wait…  this code is really just not well laid out
20:49:53 <harwiltz> Can I just put a forkProcess in my signal handler?
20:50:26 <geekosaur> what would that do? (perhaps you wanted executeFile instead?)
20:51:20 <harwiltz> I thought maybe it would create a new thread so that my input only applies to the new loop
20:51:43 <ertesx> harwiltz: http://lpaste.net/9026488030176739328
20:52:32 <harwiltz> Ok reading that now, thanks
20:52:47 <ertesx> that's how MVar works…  two threads put values into the MVar, one thread takes values out (in your case, the main loop)
20:52:56 <harwiltz> Whats that getLine function?
20:53:09 <ertesx> it just waits for you to press enter in this case
20:53:11 <geekosaur> forkProcess creates a new process, not a new thread. it solves nothing though, the problems with input are not just thread problems. they derive from the fact that a terminal has one input and one output stream and multiple threads/processes/whatever will end up fighting over them if allowed to run concurrently
20:53:25 <harwiltz> Oh I see
20:53:34 <ertesx> without it the program would simply exit after launching the threads, because the program ends as soon as the main thread ends
20:53:42 <hackrilege> outch my paste hurts http://lpaste.net/159376
20:53:44 <geekosaur> which is why (a) ncurses makes no attempt whatsoever to be threadsafe (b) it also gets seriously messed up if you fork()
20:53:56 <harwiltz> Ok, I see
20:54:08 <harwiltz> I just don't understand what I'm actually supposed to put in the MVar
20:54:13 <ertesx> and yeah, use forkOS instead of forkIO, if you use any curses function inside the new thread
20:54:16 <harwiltz> Is it supposed to hold the Window objects?
20:54:26 <geekosaur> no, don;t use any curses functions from the new thread
20:54:36 <harwiltz> So what do the MVar's actually store?
20:54:37 <geekosaur> at best they won;t work, at worst you'll segfault
20:54:48 <ertesx> hmm
20:54:54 <ertesx> or use the single-threaded run-time
20:55:12 <ertesx> curses is really awkward with haskell
20:55:20 <harwiltz> I'm starting to see that now
20:55:21 <hackrilege> my problem is that fmap must change the value of the left reference from a to b
20:55:28 <hackrilege> its hellish
20:55:29 <harwiltz> I might have to just rewrite this in c or something
20:55:55 <ertesx> harwiltz: when the window size changes, you want your loop to know the new window size…  you can send the new size
20:56:03 <harwiltz> how?
20:56:17 <ertesx> MVar (Int, Int)  -- width and height
20:56:17 <harwiltz> Oh the MVar holds the size.....
20:56:39 <harwiltz> So every iteration, the loop grabs the size from the MVar and creates new Windows
20:56:41 <ertesx> harwiltz: before you rewrite this in C, check out vty
20:56:52 <ertesx> it doesn't have any of those problems, because it's a pure haskell library
20:56:56 <harwiltz> ertesx: First I'll try this MVar stuff
20:57:15 <ertesx> harwiltz: the MVar behaves more like a message-passing channel
20:57:22 <ertesx> you put something in, you take something out
20:57:47 <harwiltz> so the signal handler puts a size in the mvar, then the loop retrieves it
20:57:51 <ertesx> that's why it starts "empty"…  takeMVar on an empty MVar will block, until something is there to take
20:57:56 <ertesx> yeah
20:58:02 <harwiltz> I see
20:58:05 <harwiltz> I'm going to try that
20:58:25 <harwiltz> So I don't need any forking/thread creation right?
20:58:58 <ertesx> you do for input gathering…  but beware of the remarks above
20:59:15 <ertesx> if you get input from regular haskell actions (getChar, getLine, etc.), there is nothing to worry about
20:59:17 <harwiltz> well I take input with getCh
20:59:36 <ertesx> in that case try the single-threaded run-time…  it does not use operating system threads
20:59:44 <ertesx> (just compile without -threaded)
20:59:57 <harwiltz> I don't compile with -threaded
21:00:09 <ertesx> the single-threaded run-time is the default
21:00:17 <harwiltz> Ok that's good
21:00:29 <harwiltz> So I don't need any of those forkIO things right?
21:00:34 <harwiltz> or forkOS
21:00:59 <ertesx> in your case, let's say you read String input from the user, your MVar actually needs the following type:  MVar (Either (Int, Int) String)
21:01:21 <harwiltz> Why do I need a string in the mvar?
21:01:23 <ertesx> you create one thread for input gathering that writes 'Right str' whenever a string 'str' comes in
21:01:40 <ertesx> and the signal handler writes 'Left (w, h)'
21:01:47 <harwiltz> I'm only changing the size of the window upon a sigwinch 
21:02:17 <ertesx> in your loop:  msg <- takeMVar myMVar;  case msg of Right str -> ...; Left (w, h) -> ...
21:02:33 <harwiltz> But why would it ever have a string?
21:02:47 <ertesx> "let's say you read String input from the user"
21:02:53 <ertesx> i don't know what your input type is =)
21:03:05 <harwiltz> But my input is unrelated to when I change the window size
21:03:16 <harwiltz> My window size only changes when I get a sigwinch
21:03:29 <ertesx> the MVar is a collective information channel…  it informs the loop that "something happened"
21:03:42 <ertesx> and the value it carries tells it *what* happened
21:04:18 <harwiltz> Ok, but I'm handling key events anyway, why can't I just create new windows every frame?
21:04:30 <harwiltz> I guess that would be slow haha
21:04:36 <ertesx> likely =)
21:04:50 <ertesx> let me extend the example a little
21:05:12 <harwiltz> So I modify the MVar every time I get an input, and every time I get a sigwinch
21:05:29 <nitrix> My game doesn't have a single MVar nor IORef yet :)
21:05:36 <nitrix> Pretty proud of that :P
21:05:53 <hackrilege> sorry i dropped connection
21:08:38 <ertesx> harwiltz: you don't "modify" the MVar…  think of it as a sort of pipe
21:08:44 <ertesx> a FIFO pipe
21:09:00 <harwiltz> ertesx: ok I understand
21:09:14 <Cale> It's a pipe that has a maximum length of 1 :)
21:09:37 <harwiltz> But where do I put these forkOS calls? I'm most confused now about how I will actually structure this
21:09:50 <Cale> Do you really need forkOS?
21:09:55 <Cale> and not forkIO?
21:10:12 <harwiltz> Cale: ertesx recommended forkOS over forkIO
21:10:31 <Cale> What C libraries are you using?
21:10:43 <harwiltz> I'm using hscurses
21:10:58 <ertesx> harwiltz: http://lpaste.net/6582851346142068736
21:11:04 <Cale> If you're using external libraries with thread-local state, then forkOS might be useful.
21:11:50 <Cale> But otherwise, forkIO is probably better
21:11:59 <harwiltz> ertesx: Thansk, this is looking pretty cool
21:12:20 <ertesx> harwiltz: according to geekosaur's remarks, forkOS won't even help in the case of curses (not sure why though)…  using the single-threaded run-time is probably the safest option here
21:12:32 <ertesx> it's unfortunate, but yeah…  use vty in your next project =)
21:12:38 <harwiltz> Ok, so forkIO is good?
21:12:48 <ertesx> use forkOS anyway
21:12:49 <Cale> Wait, what's going on?
21:12:58 <harwiltz> ertesx: hahaha ok. Thanks a lot for all thi
21:12:59 <harwiltz> *this
21:13:06 <Cale> You probably should do all the terminal IO from one thread
21:13:19 <Cale> (probably the main thread)
21:13:44 <Cale> and then just send that thread messages using MVar or something like Chan
21:13:51 <harwiltz> ertesx: And do I use forkIO . forever?
21:14:05 <harwiltz> sorry forkOS . forever?
21:14:25 <ertesx> harwiltz: forkOS . forever $ action = forkOS (forever action) = forkOS (do action; action; action; action; ...)
21:14:28 <Cale> Wait, I don't really understand why forkOS is helpful here... does curses use thread-local state?
21:14:31 <harwiltz> Cale: I don't know what Chan is haha. I'm having trouble resizing my curses windows upon sigwinch
21:15:08 <harwiltz> ertesx: Don't I only need to do it once since it's a loop?
21:15:11 <ertesx> Cale: harwiltz is trying to react properly to a SIGWINCH signal while also getting input
21:15:44 <ertesx> harwiltz: is this the first time you do threading/concurrency?
21:15:50 <harwiltz> ertesx: yes
21:16:07 <harwiltz> Also just realized your forks were outside the loop haha
21:16:12 <harwiltz> So I would need forever
21:16:20 <ertesx> harwiltz: if i tell you that it's extremely useful, would you mind looking into a book?  it's available online for free =)
21:16:53 <harwiltz> ertesx: Sure. Can't guarantee that ill get into it right away because I have a bunch of assignments and finals coming up, but I'll read it
21:17:07 <ertesx> i call this one The Book:  http://chimera.labs.oreilly.com/books/1230000000929/
21:17:17 <harwiltz> hahaha thanks
21:17:34 <ertesx> every haskell programmer needs to read it…  no exceptions =)
21:17:52 <dmj`> hah
21:18:16 <ertesx> you will mostly be interested in part II: concurrent haskell
21:18:35 <ertesx> parallel haskell is for heating up all the cores to get more speed…  concurrent programming is rather an abstraction
21:18:38 <Adeon> that's a pretty interesting use case for forkOS
21:18:41 <harwiltz> ertesx: Do you know if there is any way to read it offline, or do I need to buy if for that?
21:19:22 <ertesx> harwiltz: good question…  i don't see a download
21:19:54 <harwiltz> No big deal, I can read it online
21:20:30 <harwiltz> Alright all, I gotta go to sleep. Thanks a lot for the help ertesx and everyone that helped
21:20:51 <harwiltz> ertesx: I'll definitely read this book, I think it will actually be pretty useful for a course I'm taking next semester
21:21:56 <ertesx> it's useful for most applications that have to communicate with this weird thing we refer to as the real world =)
21:22:40 <ertesx> we even have a RealWorld type…  but it's so weird and obscure that you'll probably (hopefully) never have to see it =)
21:23:26 <Cale> It's poorly named
21:24:09 <harwiltz> hahahaha
21:24:13 <harwiltz> awesome
21:24:18 <ertesx> yeah, i would have called it Louis or something
21:24:19 <harwiltz> Ill check that out too.
21:24:26 <ertesx> don't =)
21:24:34 <harwiltz> :D Goodnight guys
21:24:41 <ertesx> good night
21:26:29 <Cale> (at least, I think RealWorld is a terrible name for something which is a zero bits wide token passed around to trick the dependency analysis into putting I/O in the correct sequence)
21:27:36 <roconnor> HackyIOToken maybe is a better name.
21:28:09 <ertesx> ST Louis ()
21:28:36 <ertesx> though there are some inhabitants apparently
21:30:25 <ertesx> but if we're talking about terrible names, let's start with 'return'…  and i never agreed with "()" either
21:30:43 <sqrt2> why is it called return in the first place?
21:30:46 <sqrt2> what was the reasoning there
21:31:18 <sqrt2> i do agree that () looks too empty
21:32:44 <ertesx> () has to be the one type i most frequently explain multiple times, especially since its value has the same name…  "it's just a name for a very boring type:  like Bool without False"
21:36:31 <Cale> sqrt2: Well, return v is the action which does nothing except to return v as its result when executed
21:36:36 <Cale> I think it's a fine name, personally.
21:37:32 <Cale> It just doesn't have the control effect that the return statement does in imperative languages
21:37:59 <Cale> But you couldn't really expect it to have that effect -- it would violate the monad laws.
21:38:45 <ertesx> 'pure' seems like a good name, because it doesn't cause as much confusion and also highlights the effectlessness
21:39:10 <sqrt2> it just seems like "return" only makes sense in conjunction with do syntax (because otherwise, return v actually doesn't return v), but with do syntax you immediately have the analogy to the return from imperative languages
21:39:20 <Cale> It does return v
21:39:23 <Cale> from itself
21:39:24 <sqrt2> it returns m v
21:39:30 <Cale> when executed
21:39:39 <shachaf> "return v" is a function that returns v
21:39:39 <kadoban> Cale: It's an okay name as long as you're already pretty lodged in haskell thought already. If you're not, it carries connotations that … aren't very good.
21:39:42 <Cale> If you write  k <- return v
21:39:45 <shachaf> > (return 5) 3
21:39:46 <lambdabot>  5
21:39:48 <Cale> in the middle of a do-block
21:39:54 <Cale> then k will be equal to v
21:40:04 <Cale> The result of the action (return v) is always v
21:40:15 <sqrt2> like i said, it makes sense in conjunction with do syntax
21:40:20 <shachaf> Monads generalize the idea of a function returning something to all sorts of values returning things.
21:40:28 <sqrt2> but then you immediately have the confusion with imperative languages
21:40:28 <Cale> sqrt2: But that doesn't rely on do-notation
21:40:34 <sqrt2> i never said it did
21:40:46 <Cale> sqrt2: liftM2 (+) (return 5) readLn
21:41:04 <sqrt2> you don't have to explain to me that return v is just a monadic value like any other
21:41:05 <Cale> return 5 is an action which is always going to do nothing and return 5 when run
21:41:14 <Cale> liftM2 is going to run it alongside readLn
21:41:19 <sqrt2> i'm just saying the name seems like it was coined with do syntax in mind
21:41:20 <Cale> and then add the results
21:41:22 <sqrt2> which i don't like
21:41:29 <Cale> I dunno
21:41:39 <Cale> Maybe it was, but do-syntax is extremely common
21:41:58 <Cale> But I don't think you need the do syntax to be able to talk about the results of executing actions
21:42:13 <Cale> return v >>= f  =  f v  is one of the monad laws
21:42:20 <ertesx> do return (); putStrLn "Hello world!"  -- a program i show very early in workshops to really get "return" across
21:44:17 <Cale> If you regard  x >>= f  as meaning "the action which first executes the action x, obtaining some result v, and then executes f v, returning its result as its own"
21:45:04 <Cale> Then the monad law that return v >>= f = f v makes it clear that return v must always return the result v when executed
21:47:46 <Cale> It just has to be made clear that the thing that v is being returned from is the action (return v) itself, and not some surrounding context.
21:48:12 <dfeuer> Anyone have a GHC 8 source tree and feel like testing something out for me? I haven't had GHC development set up properly for a while.
21:52:13 <hackrilege> hey look it compiles!! http://lpaste.net/159376
21:52:51 <hackrilege> the test works ok
21:53:10 <hackrilege> im having trouble folding, it means i need to face my unsafePerformIO...
21:53:32 <hackrilege> can anyone take a look, Cale, this is one of the things we were talking about...
21:54:26 <Cale> hackrilege: Oh uhhh... STM inside unsafePerformIO is scary
21:54:32 <hackrilege> yah
21:54:53 <hackrilege> i probably shouldnt do it like that!
21:55:22 <hackrilege> this is the best i could do without understanding quite how to handle the monads
21:55:33 <hackrilege> and it seems to work!
21:55:39 <Cale> I mean, in the sense that it was at least at one point entirely broken, if it's not broken right now.
21:55:41 <nocturne777> Cale: if a thread receives an asyncronous exception, do its children also receive this exception and die ?
21:56:00 <Cale> nocturne777: no
21:56:11 <Cale> nocturne777: threads don't have children
21:56:21 <Cale> they're all peers
21:56:35 <dfeuer> WTF? unsafePerformIO in a Show instance?
21:56:38 <Cale> except I suppose for the main thread which kills the whole program when it ends
21:56:47 <hackrilege> lol
21:56:56 <hackrilege> honestly it works ok
21:57:10 <dfeuer> hackrilege, what the heck is that supposed to be doing?
21:57:25 <hackrilege> its a double linked list. says so on the tin
21:57:34 <dfeuer> No, it does not work okay. It is fundamentally and extremely broken.
21:57:42 <nocturne777>  Cale: I think the expalantions in "Parallel and Concurrent Programming in Haskell" are a bit confusing
21:57:43 <hackrilege> lololool
21:57:50 <hackrilege> its not that bad!
21:57:54 <Cale> nocturne777: Which part are you reading?
21:57:56 <nocturne777> it uses this children and parent terminology
21:58:02 <hackrilege> i think its pretty snazzy infact
21:58:08 <nocturne777> Cale: http://chimera.labs.oreilly.com/books/1230000000929/ch11.html
21:58:09 <dfeuer> hackrilege, in what universe is it not that bad?
21:58:25 <hackrilege> its slightly lazy and probably i can fix it
21:58:27 <Cale> nocturne777: Ah, well, Async creates this illusion
21:58:51 <Cale> nocturne777: That's actually a major part of what that library does
21:58:55 <dfeuer> hackrilege, I think you can fix it by removing the Show instance. Why do you have one?
21:59:07 <hackrilege> i just dont think its possible actually to show a monad?
21:59:15 <dfeuer> ???
21:59:18 <hackrilege> so its fine to hack it
21:59:27 <hackrilege> show IO a
21:59:36 <Cale> nocturne777: So while forkIO doesn't create any kind of parent/child relationship, concurrently and race certainly do.
21:59:38 <hackrilege> when really you mean show a
21:59:40 <nocturne777> Cale: that withAsync in geturls7.hs example makes you think as if the second withAsync is forked off of the first withAsync, but that's not the case at all
22:00:21 <hackrilege> really im worried about the fold instance since i can see myself wanting to extract the values in the same kind of way
22:00:22 <dfeuer> hackrilege, you are correct that it's impossible to show a value of type `IO a`, regardless of `a`. That is not a problem. Just don't try!
22:00:53 <hackrilege> but i think i can do that with traverse or something i cant remember, t (m a) -> m (t a)
22:01:44 <Cale> nocturne777: Yeah, the first argument to withAsync is the action which runs asynchronously. The second argument is a function from the Async value representing the future result of the asynchronous action, to an action to be executed potentially using that result.
22:01:51 <hackrilege> sequence...
22:01:55 <hackrilege> :t sequence
22:01:57 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
22:02:44 <hackrilege> can you help me handle the STM monad properly to write my fold instance?? i think i need to use sequence...
22:02:47 <dfeuer> hackrilege, a Link contains an STM action. Those are inherently non-showable. There is no way to show them. They cannot be shown. Showing them is a think you cannot do.
22:02:48 <Cale> nocturne777: When that second action terminates, the asynchronous computation is killed if it hadn't finished.
22:03:03 <hackrilege> im trying to fold them not show them
22:03:20 <hackrilege> the show thing just illustraits how tricky it is to get at these values
22:03:27 <dfeuer> hackrilege, you also cannot *fold* STM actions. For very similar reasons.
22:03:36 <hackrilege> its a hack im fine with retaining as it allows me to look at the objects i create
22:03:46 <Cale> nocturne777: e.g. if one of the waits was conditional, for example, and didn't end up happening, then the download might be cancelled
22:03:51 <hackrilege> why cant i use sequence?
22:04:05 <hackrilege> why cant i fold them!?
22:04:09 <dfeuer> hackrilege, can you even begin to express what you expect your "hack" to *do*?
22:04:10 <hackrilege> what!?
22:04:25 <hackrilege> the hack shows the object
22:04:33 <dfeuer> What object?
22:04:33 <hackrilege> im not talking about my show hack
22:04:38 <dfeuer> You don't have an object!
22:04:38 <hackrilege> Link
22:04:45 <hackrilege> ...
22:04:48 <hackrilege> function
22:04:50 <hackrilege> idk
22:04:58 <hackrilege> datatype
22:05:16 <hackrilege> datatype === object from now on
22:05:27 <dfeuer> You have a *recipe* for baking an object. You can get an object by *following* the recipe. There is no object *in* the recipe.
22:05:42 <hackrilege> kk
22:05:48 <hackrilege> thanks
22:05:59 <nocturne777> Cale: the part that I don't understand is "how" in geturls7.hs the thrown exception because of "wait a1" could result in the early termination of a long running tasks in a2 ?
22:06:07 <hackrilege> im going to bake buritos now
22:06:19 <ertesx> @quote /bin/ls
22:06:19 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
22:06:41 <Cale> nocturne777: withAsync handles the exception, kills off the asynchronous thread, and then re-throws it again
22:07:16 <hackrilege> seriously though. i hack so i can see the damn things, leave it alone, now why cant i fold?
22:07:55 <hackrilege> > unsafePerformIO . getLine
22:07:58 <lambdabot>  Not in scope: ‘unsafePerformIO’
22:08:03 <hackrilege> jk
22:08:15 <dfeuer> hackrilege, for the same reason, more or less.
22:09:00 <hackrilege> can i get a seccond oppinion plz
22:09:14 <hackrilege> that one contains no additional information
22:09:39 <nocturne777> Cale: I understand that part as it is using bracket underneath, but how does this still affect a2, which is running on a different thread?
22:09:57 <hackrilege> hmmmmm
22:10:20 <hackrilege> damn i cant write fold stupid monads
22:10:22 <Cale> nocturne777: both of the withAsyncs are going to get the exception, kill their thread, and rethrow it again
22:10:42 <hackrilege> argh this datatype sucks
22:11:01 <dfeuer> hackrilege, you actually can write a Foldable instance for BiLinkedList, but it's a really boring/useless one:
22:11:04 <Cale> nocturne777: First the inner one, killing the thread associated with a2, and then the outer one (which won't have to, but will still attempt to kill the thread associated with a1)
22:11:24 <Cale> er...
22:11:28 <hackrilege> no i want to fold in the usual sense not in a boring useless way
22:11:46 <Cale> (Let me think a moment if what I said is actually right ;)
22:12:23 <dfeuer> instance Foldable BiLinkedList where foldMap f BiLinkedList {value = v} = f v; foldMap _ Empty = mempty
22:12:37 <dfeuer> That's the best you can do.
22:12:50 <Cale> ah, okay, it's supposed to be the getURL for a1 which throws the exception, so its withAsync is the one which catches an exception
22:13:01 <hackrilege> but join!!!!!!
22:13:15 <hackrilege> cant i smash all the monads together?
22:13:26 <hackrilege> to make one big monad?
22:13:35 <dfeuer> hackrilege, you can smash STM actions together; absolutely. But you'll get an STM action.
22:13:42 <aarvar> Just curious, might hackrilege be what's known as a "troll"?
22:13:44 <hackrilege> so i cant resolve fold
22:13:45 <nocturne777> Cale: first withAsync catched the exception and re-throws it, correct ?
22:13:55 <nocturne777> catches*
22:13:55 <Cale> yeah
22:13:59 <dfeuer> aarvar, good question. I don't know their history.
22:14:09 <hackrilege> aarvar, no im just trying to be funny today because normally im just angry
22:14:33 <hackrilege> and i am wasting way too much time creating nothing more than something to laugh at
22:14:40 <leewz> how do i pass in a particular version of "read"? example: i want to pass the "read" that takes an Int
22:14:48 <hackrilege> http://lpaste.net/159376
22:14:51 <hackrilege> if your interested
22:16:28 <Cale> nocturne777: Oh, right, right, so the exception happens there, and the wait a1 causes an exception to be thrown
22:16:47 <Cale> http://chimera.labs.oreilly.com/books/1230000000929/ch10.html#sec_stm-async -- see the implementation of waitSTM here
22:17:08 <aarvar> :t read
22:17:09 <lambdabot> Read a => String -> a
22:17:16 <aarvar> leewz: as in that read?
22:17:20 <leewz> yep
22:17:33 <aarvar> :t read :: String -> Int
22:17:34 <lambdabot> String -> Int
22:17:36 <aarvar> like that?
22:17:44 <Cale> and that exception is happening in the body of the second withAsync which catches it and kills off the thread for a2
22:17:50 <leewz> sounds right. couldn't figure out how to google it.
22:18:03 <aarvar> > read "1" :: Int
22:18:04 <lambdabot>  1
22:18:09 <leewz> nah, i knew that part
22:18:28 <leewz> thanks
22:18:47 <hackrilege> how do i wrap up the STM thing to be part of my datastructure so it just goes away and does not bother me any more?
22:18:53 <Cale> and then it's rethrown, and the first withAsync catches it, attempting to kill off the thread for a1 (which is already gone, but that's okay) and then re-throwing the exception
22:18:56 <nocturne777> Cale: let's call the thread of execution here t0, which forks two threads t1 and t2 that drive a1 and a2, respectively. t1 throws an exception and when we do "wait a1" on t0, we get an exception. 
22:19:10 <Cale> right
22:19:17 <hackrilege> as in, my datastructure is a monad anyway
22:19:33 <hackrilege> probably...
22:19:34 <Cale> nocturne777: and then that exception bubbles out to the containing withAsync, which catches it
22:19:45 <Cale> nocturne777: and kills off its associated thread
22:20:06 <Cale> (which cleans up a2)
22:20:09 <aarvar> hackrilege: turn left at the coyoneda
22:20:19 <hackrilege> thanks boss
22:21:27 <hackrilege> you know how i could make my paste better aarvar. think of anything cool that i can do even if this particular thing i cant?
22:22:21 <hackrilege> "haha, he is trying to fold a burrito" just kind of hurts...
22:23:06 <hackrilege> you know, constructive informative or educational
22:23:08 <hackrilege> ok nvm
22:23:11 <dfeuer> hackrilege, why are you wasting your time with this?
22:23:23 <hackrilege> THATS NOT IMPORTANT
22:23:25 <nocturne777> Cale: sorry for being dense, but how does that clean up a2? the containing withAsync is killing its own thread (t1) with cancel. I don't understand how t2 receives this exception
22:23:38 <hackrilege> that is literally a pointless discussion...
22:23:44 <Cale> nocturne777: the immediately containing withAsync is the one for a2
22:23:58 <hackrilege> when metadiscussions start about why discuss having discussions i go
22:23:58 <Cale> nocturne777: if you look outwards from the wait a1 line
22:24:00 <hackrilege> bye
22:25:56 <Cale> I have to say I feel kinda sorry for hackrilege -- I don't know what to say to him to get him pointed in the right direction, but he's often working very hard on what at least looks to me like quite misguided projects, and it's frustrating to watch :/
22:27:14 <MarcelineVQ> yeah :( he's not a troll despite how it can seem but he's not great at interactions, especially when it's critical.
22:28:05 <aarvar> oops
22:31:31 <chrisbarrett> hey all. anyone on right now with parser combinator experience, especially trifecta? Keen to bounce ideas off someone.
22:32:43 <chrisbarrett> s/bounce ideas off/crib from someone who knows what they're doing
22:33:12 <kadoban> Lots of people have some experience there. You might be better off just saying more in-detail what you're grapling with.
22:34:59 <sunny837> Hi 
22:36:47 <chrisbarrett> heh, sure. So, I'm writing a parser for a JSON DSL. I want to parse the JSON and validate it. Importantly, I want to emit line and column numbers for errors at the end of the process. I've implemented a JSON parser with trifecta and the error messages are beautiful. I'm not sure how I should approach validation/type checking though, now that I have a parse tree
22:38:20 <chrisbarrett> my initial thought was to collect line+column numbers when parsing and using those when mapping to the validated representation, but I'm not clear how to hook into trifecta's error printing stuff once the JSON parsing is already done
22:38:28 <nocturne777> Cale: I get it now, thank you.  since we get the exception in second bracket's "in-between" function, that's how the a2 gets cleaned up too
22:39:23 <Cale> yeah
22:39:30 <chrisbarrett> kadoban: so, I'm wondering how the pros would implement something like this, to make sure I'm going down the right path ;)
22:40:43 <Cale> chrisbarrett: Have you looked at how Aeson does things?
22:41:39 <Cale> oh, err... maybe you're asking about something different
22:42:25 <Cale> chrisbarrett: So my understanding so far is that you've gone from a textual representation of the JSON to some algebraic datatype like aeson's Value type, yeah?
22:42:39 <chrisbarrett> Cale: I want informative error messages with line+column numbers, so I think that rules out Aeson (unless I've missed something)
22:42:53 <chrisbarrett> Cale: yep
22:43:02 <Cale> Oh, I see what you mean, you want to be able to provide source locations when pulling apart the resulting structure
22:43:04 <Cale> okay
22:43:22 <chrisbarrett> yeah, and return error messages that are relevant to the actual DSL
22:43:23 <Cale> So that means you have to store those in the algebraic datatype, pretty much
22:43:57 <Cale> So your equivalent to Aeson's Value type will be annotated with source locations.
22:44:02 <cocreature> trifecta has a couple of combinators for that, search for "spanned"
22:44:04 <Cale> You might want to make it a type parameter
22:45:00 <siwica>  I am using emacs for writing haskell code. What is the best way to quickly view the implementation of a function in the standard library?
22:46:12 <Ralith> Cale: it sounds like he specifically wants to format error messages identically to trifecta
22:46:15 <chrisbarrett> Cale: yep, that's no problem. The thing that I'd really *like* to do is generate more error messages using trifecta's error pretty printing machinery, outside of the parsing, and I haven't figured out how to do that from the haddocks yet
22:46:34 <Cale> oh, okay
22:47:02 <chrisbarrett> Cale: maybe my question is a bit specific :p
22:47:09 <cocreature> there is renderingCaret https://hackage.haskell.org/package/trifecta-1.5.2/docs/Text-Trifecta-Rendering.html#v:renderingCaret
22:47:24 <cocreature> which is what trifecta seems to use internally if I read the source correctly
22:48:52 <chrisbarrett> cocreature: thanks, I'll have a look. 
22:49:27 <cocreature> chrisbarrett: you can then wrap it in explain https://hackage.haskell.org/package/trifecta-1.5.2/docs/Text-Trifecta-Result.html#v:explain to get a doc which you can just print
22:49:33 <Cale> also, addSpan will add a ^~~~~ thing showing not only the caret at the start, but how long the thing is
22:49:48 <chrisbarrett> aaaaaah
22:50:04 <chrisbarrett> thanks peeps, that's making sense
22:56:10 <wz1000> Which network library should I use?
22:57:46 <pavonia> Depends on what you want to do
23:01:03 <wz1000> Something simple that will work for communication with other devices on the LAN. Preferably with SSL
23:06:53 <cocreature> tcp?
23:06:58 <cocreature> if so client or server?
23:11:26 <wz1000> Server
23:11:47 <cocreature> in that case a combination of network and tls will probably do the trick
23:12:11 <nocturne777> Cale: in haskell, if an exception occurs in a thread, that thread actually exits and we do not have to kill it explicitly with throwTo? 
23:12:41 <cocreature> nocturne777: at least if the thread doesn’t catch that exception
23:13:19 <wz1000> cocreature: Thanks
23:13:37 <Hi-Angel> What «cabal install» means by «At least the following dependencies are missing: time -any, transformers -any» when «ghc-pkg list | grep -e "time\|transformers"» says they're here?
23:14:05 <cocreature> Hi-Angel: are you in a sandbox?
23:14:18 <Hi-Angel> sorry, «cabal install gtk3»
23:14:21 <Hi-Angel> No, I'm not
23:15:38 <Oejet> wz1000: One option, that I've come to like, is using a TLS client proxy (like socat, or stunnel), and using the normal `network` package.
23:16:56 <wz1000> Oejet: That makes a lot of sense
23:17:12 <cocreature> yeah that might be easier
23:17:33 <cocreature> there is also network-simple which builds upon network but provides a slightly simpler api
23:20:41 <Cale> nocturne777: If it's not caught, it'll kill the thread.
23:21:36 <Cale> nocturne777: That's actually how killThread works --  killThread tid = throwTo tid ThreadKilled
23:22:20 <Cale> nocturne777: The exception shows up asynchronously, and if it's not caught, it eventually causes that thread to die.
23:27:27 <Cale> nocturne777: There's a good paper on it here http://research.microsoft.com/en-us/um/people/simonpj/Papers/asynch-exns.htm -- but there are apparently some small differences between what's in GHC and the paper, see the note here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.2.0/Control-Concurrent.html#v:throwTo
23:28:49 <nocturne777> Cale: if I have something like forkFinally io (\_ -> ..), even if the main thread wants to exit, the handler in forkFinally is going to be still executed, right?
23:29:29 <nocturne777> it is because of the masking behavior of forkFinally, I think
23:30:19 <Cale> yeah
23:30:20 <nocturne777> I think my assumption is wrong in thise case
23:30:22 <Cale> er
23:30:35 <Cale> Hmm, I don't know when it comes to the main thread ending
23:31:12 <Cale> For anything else which would normally cause the thread to exit, that function will get applied
23:31:31 <nocturne777> I think the documentation is clear on this when it comes to the main thread: http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.htm
23:31:31 <Cale> Let's try it I suppose!
23:32:30 <nocturne777> it says you have to do something explicit
23:33:08 <Cale> Oh, that's if you want to wait for all the other threads to finish, sure
23:33:33 <Cale> but yeah, probably that's correct
23:33:38 <Cale> Let's check
23:34:50 <leewz> is there a command arg to pass to ghc so that it doesn't recompile if there's no changes in source code?
23:34:55 <Cale> yeah, it doesn't get to run in that case
23:35:18 <Cale> leewz: That's the usual behaviour
23:35:47 <Cale> but -fno-force-recomp
23:35:51 <leewz> oh, so it is
23:35:52 <Cale> (which is default)
23:36:13 <leewz> cool
23:36:14 <runway77> hi, could you please help me with a simple addressbook haskell program? there is a compilation error and I don't know how to go further: http://pastebin.com/CZDzRqdd
23:36:17 <runway77> thanks
23:36:40 <leewz> what's the error?
23:36:42 <runway77> Error:(8, 13) ghc: Couldn't match expected type ‘(Name, Address)’
23:36:42 <runway77>                 with actual type ‘[(Name, Address)]’
23:36:44 <runway77>     In the pattern: (n, a) : r
23:36:44 <runway77>     In the pattern: [(n, a) : r]
23:36:46 <runway77>     In an equation for ‘entry’:
23:36:46 <runway77>         entry name [(n, a) : r]
23:36:47 <Cale> runway77: an AddressBook is supposed to be a list of pairs of Name and Address
23:36:48 <runway77>           | name == n = a
23:36:48 <runway77>           | otherwise = entry name r
23:36:51 <Cale> but you've written a list of lists
23:37:02 <Cale> [x] is a list with one element, which is x
23:37:05 <leewz> expects a tuple, gets a list of tuples
23:37:27 <Cale> [(n,a):r] is a list with one element which is a list whose first element is (n,a) and whose tail is r
23:37:44 <Cale> You probably meant to write ((n,a):r)
23:37:55 <tippenein> is it so hard to generate a guid?
23:38:06 <Cale> tippenein: No?
23:39:13 <tippenein> what is the preferred way?
23:39:55 <tippenein> maybe I expect too much from documentation, but I also didn't see anything from a glance at the couple libraries that exist
23:40:53 <Cale> Well, okay, if you want to do it really well, maybe it's a little bit tricky -- you should probably use system entropy rather than a PRNG
23:41:26 <Cale> But fundamentally, you're just generating a bunch of random bytes
23:41:26 <tippenein> I really just need a random string. I don't need a "really good" guid
23:45:39 <Cale> In that case, replicateM 16 randomIO :: [Word8]
23:49:39 <Cale> (sorry about that type signature, should be IO [Word8] of course
23:49:41 <Cale> )
23:50:44 <fr33domlover> For better randomless than 'random' there's 'DRBG' and 'cryptonite', but iirc they don't provide Random instances, you just get a ByteString and need to convert to the type you want
23:50:52 <fr33domlover> *randomness
23:51:27 <Cale> There's also https://hackage.haskell.org/package/tf-random
23:52:45 <Cale> which uses a cryptographic hash to make sure to provide a good splitting operation on its generator states, which is crucial to many recursive applications
23:53:52 <Cale> In turn, that's used by QuickCheck (which had some instances where tests would mysteriously pass before that was put into use, caused by PRNGs that had been split many times and become correlated)
23:54:18 <Cale> QuickCheck's Gen monad is actually quite a nice way to generate random values as well
23:54:25 <Cale> It really belongs in its own library
23:56:08 <tippenein> so, this seems like it should require much less explaining
23:56:35 <Gurkenglas> What's the line to derive an instance when you're not at the data declaration?
23:56:38 <nocturne777> Cale: again from http://chimera.labs.oreilly.com/books/1230000000929/ch11.html#sec_conc-symmetric. in geturls9.hs, the author claims that multiple tasks can be executed concurrently, but to me it seems like it can only fetch one website at a time
23:56:50 <tippenein> is this applicable, not even sure https://github.com/aslatter/uuid/blob/master/uuid/Data/UUID/V1.hs#L59-L64
23:56:56 <Cale> tippenein: If you don't want to think too hard about it, you can use randomIO
23:57:01 <Cale> :t randomIO
23:57:02 <lambdabot> Random a => IO a
23:57:06 <Cale> :t randomRIO
23:57:07 <lambdabot> Random a => (a, a) -> IO a
23:57:14 <Cale> ^^ if you want values in a particular range
23:57:37 <Cale> tippenein: Don't bother with that method
23:57:44 <nocturne777> waitBoth, which is called as part of concurrently, is not allow it to continue until it fetches one site
23:57:58 <Cale> tippenein: People have come up with all sorts of silly ways to reduce the entropy provided by a GUID
23:58:22 <Cale> tippenein: It is somewhat of a standard thing to do, what that code is doing
23:58:38 <Cale> But I don't really understand why you'd want to do that
23:58:54 <tippenein> Cale: I'm honestly curious. Are other libraries like SecureRandom in ruby not generating "true" guids?
