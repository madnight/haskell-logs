00:00:07 <akegalj> will anyone of you guys attend LambdaConf next month? I am trying to find some more detailed schedule on their page. Does it end on 28. of May or 29. of May?
00:04:04 <akegalj> ok, seems 29. will be for hacking only workshoop. Resolved
00:10:34 <YellowOnion> Is there a prefix version of (^.) in lens?
00:11:04 <shachaf> view
00:11:38 <YellowOnion> shachaf, thanks, maybe my issue is something else then.
00:11:51 <shachaf> Well, the arguments are flipped.
00:12:20 <cocreature> Lokathor: do you have the source somewhere public? I can take a quick look, maybe I’ll spot something
00:12:34 <cocreature> 100times slower than java doesn’t sound normal
00:13:40 <Lokathor> cocreature, yes
00:13:59 <Lokathor> https://github.com/Lokathor/ludolib is the haskell project
00:14:29 <Lokathor> the PCGen32 takes about 700ms on my machine to run the 1million times loop
00:15:26 <Lokathor> compared to this java version of the PCGen32, https://github.com/Lokathor/JPCG, which takes about 7ms, according to this simplistic benchmark runner: http://lpaste.net/160817
00:15:40 <Zemyla> You know, the fact that QuickCheck can produce arbitrary functions is pretty amazing.
00:17:06 <lyxia> Zemyla: yeah that's neat
00:18:53 <Zemyla> And since pretty much every monad is either a record or a function or a combination of those, it can generate random monads.
00:23:58 <YellowOnion> shachaf, (_1 . ix 3) should create a getter ([a],b) -> a right?
00:24:33 <shachaf> No, because the element might not exist in the list.
00:27:18 <YellowOnion> shachaf, I've been using it in other parts of my code, so I'm not sure what I don't understand.
00:27:55 <Lokathor> cocreature, i've gotta get to sleep, but if you find anything (in Data.PCGen or any other module for that matter) just file an issue on the repo please.
00:29:15 <cocreature> Lokathor: will do
00:29:50 <YellowOnion> @t head . tail . tail . fst
00:29:51 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
00:30:03 <YellowOnion> :t head . tail . tail . fst
00:30:04 <lambdabot> ([c], b) -> c
00:56:12 <Nux_> How come when I use "import qualified MyModule (myFunc1)" I get access to "MyModule.myFunc2" from the ghci interpreter I'm running on the file?
00:57:32 <Nux_> Does the interpreter behave differently to compiled haskell in this respect or is the info at "https://wiki.haskell.org/Import" wrong?
00:58:37 <Nux_> I'm using GHC 7.10.3
01:01:21 <lyxia> Nux_: you're using :load right?
01:01:30 <Nux_> no
01:01:32 <srhb> It works regardless, if you give the full name.
01:01:39 <srhb> So yes, ghci is different in this regard.
01:01:55 <Nux_> srhb, oh ok
01:02:19 <srhb> In fact, even if you don't import it in any way, it will still work
01:02:19 <Nux_> lyxia, I'm running ghci on a file that declares the imports
01:02:34 <Nux_> srhb, oh
01:03:13 <Nux_> but compiled haskell should still behaves as outlined in the info at that link?
01:03:16 <srhb> Yes.
01:03:18 <Nux_> *behave
01:03:21 <Nux_> k cheers
01:04:22 <srhb> Again, I'm not sure it was intentional, but you can try firing up a clean ghci and notice you can use something like Data.List.genericLength just fine, but if you define foo = Data.List.genericLength in a file and try running ghci on that, it will barf (correctly, in my opinion)
01:04:28 <kadoban> ghci is wacky stuff. I still have little idea how it actually behaves even after all this time.
01:04:32 <srhb> The whole "things are implicitly imported" thing is a misfeature.
01:04:52 <srhb> Or at least completely non-trivial to understand. :-)
01:05:10 <orion> Why are the Pipes contained in Pipes.Network.TCP.TLS Producers and Consumers? If you're using TLS, wouldn't you want it to be a "Pipe"?
01:05:30 <Nux_> srhb, seems like it :) thanks
01:08:18 <cocreature> orion: the Context already contains the conneciton info on one side
01:08:30 <cocreature> orion: but a pipes interface would also be a reasonable thing to have
01:08:49 <orion> ah
01:09:08 <cocreature> but I’m not sure how you would initialize a Pipes based interface
01:09:22 <cocreature> I don’t think it makes sense to have a tls context without a connection
01:09:50 <orion> If you have a Producer that's bound to a Context and a Consumer that's bound to a Context, how do you ensure that the two stay in sync?
01:10:10 <orion> Oresumably they're bound to the same Context
01:10:16 <orion> Presumably*
01:37:01 <Mariooo> ciao
01:37:12 <Mariooo> !list
01:54:17 <theduke_> Got any http clients to recommend? I found wreq, but it's a bit bloated
01:57:57 <cocreature> theduke_: http-client?
01:59:23 <suppi> one of those? http://hackage.haskell.org/packages/search?terms=http%2Dclient
02:01:17 <arahael> theduke_: It's only bloated if your compiler doesn't remove the bits you don't use.
02:01:25 <arahael> theduke_: Everything you use, you'd otherwise be implementing yourself.
02:26:36 <ph88^> hey guys in parsec/attoparsec i can do this   satisfy (\x -> isDigit x && x /= '8')   but what if i want to check for more than 1 character?   for example i want to check "isAlpha and not is 'hello'"
02:34:31 <pavonia> ph88^: Cases like this are a bit tricky, you should probably rearrange your parser or grammar such that the "hello" case is handled earlier and only the other cases remain
02:35:09 <pavonia> Maybe you could provide more information about what you are trying to parse
02:35:56 <ph88^> pavonia, is that my only option? to rearrange the grammar?
02:36:54 <ph88^> eh i guess i could use lookahead as well .. but this is ugly
02:37:05 <pavonia> No, but in my experience it's usually better than bloating your parser
02:37:08 <ph88^> it seems i can not do && with Parser  right ?
02:37:22 <ph88^> yes it's better, but i want to explore this route for the moment
02:38:01 <pavonia> You could try something like (try (String "hello" >> fail "") <|> many isAlpha)
02:39:17 <pavonia> Hhm, or returning an Either and filtering the Rights later or something
02:39:30 <ph88^> what's that   fail ""  ?
02:39:49 <pavonia> A parser that always fails
02:40:08 <pavonia> Parsec has specialized parsers for different types of failures
02:40:41 <pavonia> Not sure if try still backtracks for all of them
02:41:21 <ph88^> so i can: 1. rearrange grammar 2. lookahead 3. try with fail  do you know any other options?
02:43:08 <ph88^> by the way .. i don't think rearrange grammar will be always possible .. i believe there are grammars which can not be rearranged to solve this .. but i can't proof this right now ^^
02:43:09 <pavonia> Something like many isAlpha >>= \s -> case s of "hello" -> fail; _ -> return s
02:44:08 <ph88^> wow that notation is totally weird to me o_O
02:44:19 <ph88^> not sure how i'm suppose to read that
02:44:34 <pavonia> It's just expanded do-notation
02:44:51 <pavonia> do { s <- many isAlpha; case s of "hello" -> fail; _ -> return s }
02:45:17 <ph88^> aha, so it's a 4th option ?
02:45:58 <ph88^> i think i like this last option the best ^^ .. will have to try it though
02:49:57 <pavonia> Still, more information about the actual use case would be helpful. It looks like the very common case of handling language keywords differently which is usually already done at the token level
02:51:02 <ph88^> which "token level"  are you talking about ?
02:51:37 <ph88^> if you talk about "token level" i start thinking about a seperate lexing stage .. of which i didn't think was available with parsec/attoparsec
02:54:17 <pavonia> ph88^: I mean returning different tokens like (try (string "hello" >> return KeywordHello) <|> (Variable <$> many isAlpha)) instead of filtering some cases
02:55:04 <pavonia> Having another lexical parsing stage is another option, right
02:55:46 <ph88^> pavonia, i think the case that you show me "returning different tokens like" falls under the option "rearranging grammar", no ?
02:56:40 <pavonia> Perhaps yeah
02:57:39 <pavonia> Depends on you actual grammar (which I still have no idea about ;)
02:59:20 * hackagebot werewolf 1.0.2.0 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.0.2.0 (hjwylde)
03:01:45 <ph88^> pavonia, the use case is a bit complicated that's why i have been a bit quiet about it :P
03:03:03 <ph88^> pavonia, i'm trying to make a parser-combinator in another language that looks like parsec/attoparsec .. and to show-case this parser i'm trying to port an LL(k) grammar used with a parser with a seperate lexing stage .. so now i'm running into problems .. i didn't realise this beforehand but it's ok because it's a nice challange :)
03:03:20 <ph88^> out for lunch, be back later
03:30:59 <dsub> How do i use curly braces in a case statement in ghci? What I'm after is a way to define a short function in ghci which uses patten-matching. How do I accomplish this?
03:31:24 <homam> xml
03:32:30 <hpc> dsub: what you more likely want is something like
03:32:50 <hpc> dsub: type ":{", then type what you want on multiple lines with layout, then type ":}"
03:33:28 <hpc> though really you should probably be doing "ghci file.hs" and ":r"
03:34:40 <carp> Hi guys. I am searching for updates from John Carmack about Haskell. A few years ago he played with porting Wolfenstein. He said someone who gets into haskell now will be kicking everyones ass in 5 years.
03:35:04 <carp> How is haskell getting along these days? I dont know how to word this question better :)
03:35:33 <carp> Has john carmack revisited or made any more statements? I cant find any if he has.
03:36:08 <dsub> hpc: Thanks!
03:39:25 * ski . o O ( <http://functionaltalks.org/2013/08/26/john-carmack-thoughts-on-haskell/>,<https://web.archive.org/web/20140719080947/http://www.altdev.co/2012/04/26/functional-programming-in-c/>,<https://www.youtube.com/watch?feature=player_detailpage&v=1PhArSujR_A#t=125>,<http://lambda-the-ultimate.org/node/1277> )
03:43:20 <Hafydd> I can't believe that the opinion of some game developer who doesn't even use Haskell is considered important.
03:44:18 <Hafydd> I wonder if Haskell is worth using... ah, yes! Let's ask John Carmack!
03:44:20 * ski . o O ( <https://www.youtube.com/watch?feature=player_detailpage&v=4zgYG-_ha28#t=3234>,<https://web.archive.org/web/20140719065227/http://www.altdev.co/2011/11/22/parallel-implementations/>,<https://web.archive.org/web/20140719091731/http://www.altdev.co/2011/12/24/static-code-analysis/> )
03:45:54 <ski> getting some kind of confirmation from people you have respect for can be useful, if you're not (yet) a Haskell user
03:59:17 <dhex> Asuran, ???
04:13:26 <bernalex> carp: jcarmack got the basics of wolf3d down in haskell, but put it aside, citing lack of time. he uses racket more now, because he has an IDE for it on his phone, so he can use it while travelling.
04:13:40 <bernalex> carp: I don't know what you mean by "how is haskell getting along" though.
04:15:42 <carp> bernalex: I am a hobbyist game maker, I heard about a game called Wayward Tide in development as of 2015 using haskell. But it doesnt seem to have made a big splash from my limited game news reading in the years since carmack made that speech.
04:16:15 <carp> Im just checking in here, trying to figure out how the current haskell game making scene is, that kind of thing.
04:16:44 <carp> (haskell, not wayward tide I mean)
04:19:15 <bernalex> carp: there effectively is no haskell game making scene. there are a couple of commercial developers using it, but there is no big famous title primarily written in Haskell. however, the new SDL2 bindings are supposedly very good, and the haskell-game guys (the github organisation) are making progress with other things too -- so there are reasons to be optimistic. I am personally presently working on a
04:19:17 <bernalex> haskell game, and have written several half-arsed incomplete tiny ones. check out #haskell-game to get more feedback.
04:20:57 <bernalex> carp: the game industry today is mostly AAA developers doing their thing with all of their in-house tooling etc., or indie devs licensing ready-made proprietary game engines which also are not in Haskell. both of these situations effectively makes haskell largely unheard of in established companies -- they couldn't use it even if some programmers wanted to use it.
04:21:46 <bernalex> carp: jcarmack -- amongst others of course -- have however noted that learning haskell will a) make you a better programmer overall, regardless of what you use on a day to day basis, and b) there is nothing precluding *you* from establishing the haskell game heritage. get going. ;)
04:27:50 <carp> bernalex: That was exactly the type of answer I was looking for, thanks very much!
04:28:34 <carp> bernalex: Go on then do tell, whats the game you are working on currently?
04:28:47 <bernalex> carp: have you played super bomberman or other bomberman titles?
04:28:51 <carp> yes
04:30:42 <bernalex> carp: kind of like that, but with snowball throwing. you have a guy. 3/4th perspective. you walk around on the snow. you make snowballs (holding up to N at the time), and throw them at your opponenents (charging up your shot first). trees make the levels a maze. so it's a very simple game. I intend on having it easy to play lan and online, and also to have a single player campaign. porting to e.g. android
04:30:44 <bernalex> would be useful too.
04:32:10 <bernalex> carp: currently spending/wasting/enjoying my time learning how to do pixelart. I've never even attempted it before, so it's quite an endeavour to get into, making all the animations etc. I am using a low-res and low-colour style, somewhat similar to the gameboy. I am also composing the music myself, currently using the freeboy gameboy emulator.
04:32:28 <carp> bernalex: Exciting stuff, I love that perspective and gameplay. (I made my own pokemon/zelda tileset for games like that infact :)
04:32:54 <cheater> i preferred tank war, which was like that except you could shoot through the scenery.
04:33:06 <bernalex> carp: you might appreciate this thing I made recently: https://secure.plaimi.net/~alexander/tmp/pokemon.png :-P learning pixelart takes time!
04:33:44 <carp> bernalex: lol nice character
04:34:08 <bernalex> carp: personally, I have a kind of goal of reusing the source code to make a more jrpg-y game later on. if I can make this sustainable (i.e. make money). I really like the æsthetics of games like pokémon, animal crossing, snes harvest moon, and recently stardew valley.
04:35:19 <cheater> it almost sounds like you'd like to be a graphic artist
04:35:20 <bernalex> but I'm broke and have to grow up and get a boring day job as soon as possible, so we shall see, I suppose.
04:36:22 <carp> bernalex: yes, seems like we are on the same wavelength. stardew valley certainly did ok in sales! There are lots of free to use pokemon tilesets you might be interested in. search 'kyledove'
04:36:24 <bernalex> cheater: I'm too interested in basically everything. I don't even want to know how many careers I've considered in my life... but gamedev is nice, because you get to stimulate a lot of things at once.
04:37:37 <bernalex> carp: those look cool. it's not relevant to my simple arcade-y game, but it's definitely worth looking at for the jrpg-y game. thanks!
04:38:32 <carp> bernalex: for the rpg game, im been playing with solarus engine. Its very good and gpl licenced. http://www.solarus-games.org/
04:38:37 <cheater> life is long
04:39:26 <bernalex> cheater: yeah I briefly looked at it. what's your experience with it so far?
04:39:35 <carp> But im so tempted to really dive in to haskell instead. its so time consuming and hard to program though ha
04:40:24 <bernalex> funny. I'm considering not using haskell. :]
04:40:37 <bernalex> if I were programming from scratch, which I still might end up doing, I will definitely use haskell though.
04:41:11 <maerwald> Why is it that a lot of people suggest FRP for gui work, but when you look at it you see 0 tutorials, a few bitrotten examples and toy project, but nothing seriously done. And no glue code for most frameworks.
04:41:34 <cheater> have a look at fay and ghcjs
04:41:35 <bernalex> same reason poeple suggest haskell for games.
04:41:37 <maerwald> seems like it's just hyped
04:41:42 <cheater> bernalex: no.
04:41:46 <carp> bernalex: well if you want to make a zelda clone I can recommend that solarus engine, it has a full graphical editor and is pleasant to use.
04:41:50 <maerwald> cheater: I do gtk
04:42:00 <Rembane> maerwald: There are some working frp libsraries in Javascript
04:42:16 <maerwald> and none in gtk
04:42:16 <cheater> maerwald: the sad truth is few people develop libraries around gtk nowadays.
04:42:17 <maerwald> or qt
04:42:27 <cheater> everyone wants to stuff everything in the browser.
04:42:37 <bernalex> FRP is a beautiful idea. but if you to learn it and use it practically, you are lost. just like haskell for gamedev.
04:42:40 <maerwald> then people should just stop suggesting FRP for gui work
04:42:46 <cheater> if you want frp for a desktop toolkit, you might be on your own.
04:42:56 <cheater> a gui built in the browser is still a gui
04:43:00 <bernalex> maerwald: reactive-banana's wx bindings were nice.
04:43:05 <maerwald> I don't use wx
04:43:41 <bernalex> if you only want to use GTK. the problem is with you, not the statement, unless they recommended it specifically for GTK.
04:43:57 <maerwald> bernalex: there are no bindings to qt either
04:44:05 <Boomerang> reactive-banana sdl (with GLUT) is not too bad :)
04:44:13 <maerwald> and that little wx glue code is just that... I don't think anyone is actually using it for real world projects
04:44:40 <maerwald> stuff like GTK/QT have a bazillion widgets and events. You have to map the whole framework properly into FRP
04:45:01 <maerwald> not just a few toy examples like input boxes
04:45:04 <bernalex> people frequently use yampa for gui development. idk much about gtk or qt though.
04:46:04 <bernalex> carp: I'm not going to make a zelda clone, really, so I guess it depends on how much I can tweak it to my usecase. another reason why it's a good idea to write it from scratch is the aforementioned hope of reusing the code for feature games that will likely play drastically differently.
04:47:07 <bernalex> carp: if there were a quick and easy get-rich shortcut for my game so that I could, idk, pay rent for three months, then I'd take it and write from scratch for sure. :p I'm completely broke, and need to get something going quickly.
04:48:20 <carp> bernalex: reusing of code is the thing Im interested in too. I think its obvious I am not an expert ofcourse but possibly there would be a lot of stuff that could be reused between a 2d zelda clone and a 2d rts game.
04:48:38 <carp> I designed my tileset so that it could be used for either type of game.
04:49:07 <carp> quick and easy get rich button, press here.
04:49:50 <maerwald> I think the most important part is to have a clean code base and get something done. If I see during the process that some parts of my code MIGHT be reusable, I'll put extra effort into that to make it a library. Otherwise not.
04:49:53 <ntnt> have any of the "haskell semantics w/ lisp syntax" projects survived?
04:50:01 <ntnt> I'm seriously conidering them given my hatred of TH
04:50:32 <bernalex> carp: yeah I hope to reuse gfx and music too
04:52:06 <bernalex> carp: I'm compiling solarus now, to have a look. taking a quick break from animating air-born snowballs, heh. but I guess this is officially too offtopic, so I'm in #haskell-game and #haskell-offtopic if you want to talk more about that. :]
04:52:56 <maerwald> solarus is nice
05:07:53 <carp> maerwald: do come tell me what you know about solarus in #haskell-game
05:22:58 <hackrilege> finally i have a really nice thing with zippers!! http://lpaste.net/160835
05:24:06 <hackrilege> it implements a stencil convolution of a central difference approximation to a derivative with awesome syntax!
05:24:26 * hackagebot prelude-edsl 0.4 - An EDSL-motivated subset of the Prelude  https://hackage.haskell.org/package/prelude-edsl-0.4 (EmilAxelsson)
05:25:12 <lonokhov> is there package with "sort -V" (versions-sort) implementation?
05:25:39 <hackrilege> "its sometimes easier to traverse a List of ListZippers than it is to just use the zipper"
05:25:56 <hackrilege> sorry zipper
05:26:47 <hackrilege> check out the definition of slope on line 33
05:26:50 <zipper> LOL
05:26:57 <zipper> It's cool
05:27:03 <hackrilege> thanks!
05:27:14 <hackrilege> oh you meant its ok to bother you...
05:27:25 <hackrilege> |:-|
05:27:50 <nitrix> Stencil convolution of a central difference approximation ._.
05:28:03 * nitrix shivers.
05:28:06 <Akii> I hope I'm not the only one that has no clue what that is
05:29:04 <hackrilege> that parses fine! convolution <-> map over subregion, centeral difference approximation <-> average your immidiate neighbours
05:32:29 <hackrilege> > scanl (\((a,b),c) d-> ((b,c),(c-a)/2)) ((0,0),0) [1..10]
05:32:31 <lambdabot>  [((0.0,0.0),0.0),((0.0,0.0),0.0),((0.0,0.0),0.0),((0.0,0.0),0.0),((0.0,0.0),...
05:32:37 <hackrilege> oops
05:33:12 <hackrilege> > scanl (\((a,b),c) d-> ((b,c),(d-a)/2)) ((0,0),0) [1..10]
05:33:13 <lambdabot>  [((0.0,0.0),0.0),((0.0,0.0),0.5),((0.0,0.5),1.0),((0.5,1.0),1.5),((1.0,1.5),...
05:33:40 <hackrilege> > map snd $ scanl (\((a,b),c) d-> ((b,c),(d-a)/2)) ((0,0),0) [1..10]
05:33:42 <lambdabot>  [0.0,0.5,1.0,1.5,1.75,2.0,2.25,2.625,3.0,3.375,3.6875]
05:33:48 <hackrilege> !?
05:33:50 <hackrilege> omg
05:33:54 <hackrilege> ok not that
05:33:58 <hackrilege> but something like that
05:35:38 <hackrilege> > map snd $ scanl (\((a,b),_) d-> ((b,d),(d-a)/2)) ((0,0),0) [1..10]
05:35:40 <lambdabot>  [0.0,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
05:38:02 <hackrilege> a nice smooth slope
05:38:24 <hackrilege> with some boundary artifacts
05:38:37 <matt-> too much flattery
05:39:36 <hackrilege> can anyone comment on the style used in the paste? regarding the function meta and the storing of zipper values
05:39:59 <hackrilege> its supposed to be more efficient than just using a zipper
05:40:25 <hackrilege> and it will take a more complex example to show how it outperforms scan (scan2d?)
05:40:49 <hackrilege> http://lpaste.net/160835
05:42:08 <hackrilege> sorry about the mess above, i was just trying to explain what i meant by stencil convolution of central difference approximation to a derivative
05:43:23 <hackrilege> :t scanl (\((a,b),_) d-> ((b,d),(d-a)/2))
05:43:24 <lambdabot> Fractional t => ((t, t), t) -> [t] -> [((t, t), t)]
05:49:09 <Peaker> can I tell ghc to explain why it thinks it needs to rebuild everything when there's no need to?
05:50:55 <hackrilege> > let left = (\(xs,y:ys)->(y:xs,ys)) in \ l -> map (\s->s l) $ scanl (.) (head.snd)  (repeat left)
05:50:56 <lambdabot>      No instance for (Typeable b0)
05:50:56 <lambdabot>        arising from a use of ‘show_M647379036680598203529041’
05:50:56 <lambdabot>      In the expression:
05:52:19 <hackrilege> > let left = (\(xs,y:ys)->(y:xs,ys)) in \ l -> map (\s->s l) $ scanl (.) (head.snd)  (repeat left) [2..5]
05:52:20 <lambdabot>      Couldn't match expected type ‘[Integer] -> [t -> b]’
05:52:20 <lambdabot>                  with actual type ‘[([c0], [c0]) -> c0]’
05:52:20 <lambdabot>      Relevant bindings include l :: t (bound at <interactive>:1:41)
05:52:44 <hackrilege> argh, can anyone see whats wrong with that!?
05:54:28 * hackagebot ratel-wai 0.1.2 - Notify Honeybadger about exceptions via a WAI middleware.  https://hackage.haskell.org/package/ratel-wai-0.1.2 (fozworth)
05:55:39 <srhb> :t scanl
05:55:41 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
05:55:50 <srhb> hackrilege: That's one at least
05:57:00 <hackrilege> ?
05:57:17 <srhb> hackrilege: It doesn't take four arguments, only three.
05:58:01 <hackrilege> > let left = (\(xs,y:ys)->(y:xs,ys)) in \ l -> map (\s->s l)  (scanl (.) (head.snd)  (repeat left)) [2..5]
05:58:02 <lambdabot>      Couldn't match expected type ‘[Integer] -> r’
05:58:02 <lambdabot>                  with actual type ‘[b]’
05:58:02 <lambdabot>      Relevant bindings include
05:59:05 <hackrilege> > let left = (\(xs,y:ys)->(y:xs,ys)) in \ l -> map (\s->s l)  ((scanl (.) (head.snd)  (repeat left)) [2..5])
05:59:07 <lambdabot>      Couldn't match expected type ‘[Integer] -> [t -> b]’
05:59:07 <lambdabot>                  with actual type ‘[([c0], [c0]) -> c0]’
05:59:07 <lambdabot>      Relevant bindings include l :: t (bound at <interactive>:1:41)
05:59:26 <srhb> hackrilege: You can also poke lambdabot privately, to avoid the error spam in the public channel. :)
05:59:28 * hackagebot ratel 0.1.3 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-0.1.3 (fozworth)
05:59:52 <hackrilege> > let left = (\(xs,y:ys)->(y:xs,ys)) in (\ l -> map (\s->s l)  (scanl (.) (head.snd)  (repeat left))) [2..5]
05:59:53 <lambdabot>      Couldn't match expected type ‘([b], [b])’
05:59:54 <lambdabot>                  with actual type ‘[Integer]’
05:59:54 <lambdabot>      In the first argument of ‘\ l
05:59:58 <hackrilege> ok
06:00:05 <hackrilege> sorry
06:00:43 <hackrilege> i thoght someone with good eyes might be able to spot the error
06:00:53 <hackrilege> didnt think it would be so hard"
06:01:36 <hackrilege> anyway, i was just wanting that someone could comment on my paste, http://lpaste.net/160835
06:01:54 <hackrilege> i was just trying to show what i was getting at with a stencil convolution
06:02:03 <srhb> hackrilege: Oh, it's fine if you're trying to get help tracking down an error. :)
06:02:56 <hackrilege> anyway thats not the important part. im trying to investigate the function meta in this paste
06:03:11 <hackrilege> have you ever seen it?
06:04:07 <hackrilege> also how is the compiler infering the type of test as a function on lists of Doubles!?
06:05:53 <hackrilege> are all Frational Sum types Doubles?
06:08:16 <hackrilege> i know some of my earlier pastes on this subject were long and thats why people didnt read them but i have condensed it down a lot now and i think its starting to look neat enough to discuss..
06:09:03 <hackrilege> about the granularity problem
06:09:25 <hackrilege> and if this approach is redundant
06:09:28 * hackagebot deepseq 1.4.2.0 - Deep evaluation of data structures  https://hackage.haskell.org/package/deepseq-1.4.2.0 (HerbertValerioRiedel)
06:09:30 * hackagebot lackey 0.3.1 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-0.3.1 (fozworth)
06:12:42 <anax> After an update of haskell-mode I get the message "async" instead of the type of a function. Do you know a workaround?
06:20:15 * hackagebot autoexporter 0.2.1 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-0.2.1 (fozworth)
06:20:17 * hackagebot octane 0.4.18 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.18 (fozworth)
06:25:13 <joneshf-laptop> How do you prove that a data type cannot implement a typeclass?
06:26:02 <hpc> either it's the wrong kind, or it can't implement a method
06:26:12 <hpc> usually parametricity takes care of proving you can't implement a method
06:26:17 <joneshf-laptop> yeah, the second one
06:26:32 <hpc> like (,) can't be an arrow because you can't implement arr
06:27:39 <joneshf-laptop> but how can you show that?
06:27:51 <joneshf-laptop> is there an algorithm?
06:28:15 <joneshf-laptop> or is it just, "stare for a while, think hard, and magic the answer"?
06:28:19 <hpc> no algorithm that i know of, you just have to logic it out
06:28:34 <hpc> so like
06:28:45 <hpc> arr :: (a -> b) -> (a, b)
06:29:02 <hpc> how do you produce a value of type a?
06:29:12 <hpc> it can only be bottom because of parametricity
06:29:34 <hpc> and similarly the only way to produce b is to pass an 'a' to the function, or just be bottom
06:29:56 <hpc> so 'b' can sometimes be defined if the function is non-strict in its argument
06:31:04 <hpc> but now there's a problem
06:31:05 <joneshf-laptop> i understood up to the last sentence
06:31:08 <hpc> arr id = id
06:31:18 <mrvdb> anax: i'm having the same issue, haven't looked into it yet.
06:31:30 <hpc> joneshf-laptop: imagine it f = const False
06:31:39 <hpc> > (const False) undefined
06:31:40 <lambdabot>  False
06:32:25 <hpc> anyway, arr (Prelude.id) = (Category.id)
06:32:37 <hpc> so what's Category.id for (,)?
06:32:41 <joneshf-laptop> hpc, Sorry, I still don't understand.
06:32:53 <joneshf-laptop> hpc, how does that allow `b` to be defined?
06:33:13 <hpc> joneshf-laptop: it allows b to be defined /sometimes/
06:33:29 <hpc> suppose you had arr f = (undefined, f undefined)
06:33:43 <hpc> with the right f, you might not need an 'a'
06:33:53 <joneshf-laptop> ah
06:33:58 <hpc> anyway i just realized this is all a red herring because i forgot Arrow needs Category
06:34:01 <hpc> so better example!
06:34:05 <joneshf-laptop> yeah
06:34:06 <hpc> instance Category (,)
06:34:22 <joneshf-laptop> how about this one: pretend I'm not THAT great with parametricity, and also pretend I'm trying to implement `Traversable` for `Cont r`, how do I go about deciding whether or not this is possible?
06:34:38 <hpc> oh i see
06:35:35 <maerwald> hmm... how about a Monad instance that cannot satisfy the monad laws?
06:35:46 <joneshf-laptop> so  I need to implement `traverse :: Applicative f => (a -> f b) -> Cont r a -> f (Cont r b)` yeah?
06:35:53 <maerwald> do you consider that "implemented"?
06:36:16 <hpc> okay, so Traversable requires Foldable
06:36:19 <joneshf-laptop> maerwald, i'd say its unlawfully implemented
06:36:25 <hpc> try and write foldMap :: Monoid m => (a -> m) -> Cont r a -> m
06:36:31 <hpc> @unmtl Cont r a
06:36:31 <lambdabot> (a -> r) -> r
06:36:36 <hpc> or rather
06:36:50 <hpc> foldMap :: Monoid m => (a -> m) -> ((a -> r) -> r) -> m
06:37:06 <joneshf-laptop> I couldn't figure that out either
06:37:12 <hpc> m can be mempty
06:37:19 <joneshf-laptop> aside from the.. yeah
06:37:30 <hpc> or it can be that first function applied to an 'a'
06:37:32 <hpc> which we don't have
06:37:42 <joneshf-laptop> but I didn't check the laws there
06:37:49 <hpc> so the only good implementation is foldMap _ _ = mempty
06:38:25 <hpc> uh, hmm
06:38:31 <joneshf-laptop> how do we know that we can't somehow apply the first function?
06:38:41 <hpc> so fold = foldMap id
06:38:48 <hpc> or rather, fold = \_ -> mempty
06:38:56 <hpc> (as specified by Foldable's laws)
06:39:15 <hpc> er, hmm
06:39:35 <maerwald> joneshf-laptop: if you ignore the laws, you can come up with a low of funny class implementations that are just valid on type level
06:39:47 <maerwald> even going for "undefined" ;)
06:40:03 <maerwald> or throwing errors
06:40:09 <joneshf-laptop> maerwald, fair point.
06:40:31 * hpc is trying to figure out where in the laws that foldMap _ _ = mempty is forbidden
06:41:00 <joneshf-laptop> maerwald, lets revise my question to "lawfully implement" :)
06:41:36 <maerwald> joneshf-laptop: this might also be interesting https://stackoverflow.com/questions/13056663/why-is-there-no-io-transformer-in-haskell
06:42:20 <maerwald> you can implement it with unsafePerformIO, but :D
06:42:26 <maerwald> better not...
06:44:22 <hpc> all of Foldable's laws can be satisfied by any minimal definition
06:44:56 <hpc> afaict
06:46:09 <hpc> my suspicion is that Cont won't work by way of 'a' being in a negative position in Cont's type, but don't quote me on that in any way whatsoever
06:47:36 <joneshf-laptop> I didn't think Foldable had real laws?
06:48:32 <hpc> ah, k
06:48:43 <joneshf-laptop> I'm still unsure what to do in the Traversable situation
06:49:36 <scshunt> joneshf-laptop: you're trying to prove that Cont can't lawfully implement Traversable?
06:49:49 <joneshf-laptop> I'm fine with the not being able to implement that type class, but only if it's because there is no lawful implementation, not if it's because I don't know how to implment it.
06:50:00 <joneshf-laptop> scshunt, can or cannot, I don't know which is true
06:50:45 <scshunt> really the only way to prove something like this is the same as any mathematical proof: just keep logicing things until you either get an answer or a contradiction
06:51:30 <joneshf-laptop> scshunt, how do I proceed when I get neither?
06:51:57 <scshunt> joneshf-laptop: you keep pushing
06:52:16 <joneshf-laptop> scshunt, this is just a specific example, I'm more lost in the general case of understanding whena data type can or cannot implement a type class. Though hpc has given some good food for thought
06:52:52 <hpc> joneshf-laptop: if it helps, look at other proofs to get an idea of the techniques involved
06:52:53 <joneshf-laptop> scshunt, pushing how? Do you have any resources, or algorithms, or something that might help me understand what other avenues I can take?
06:53:06 <scshunt> joneshf-laptop: a good book on mathematical proof, really
06:53:09 <hpc> proofs of things are the entirety of math and deciding how to approach a problem is sometimes more art than science
06:53:12 <scshunt> joneshf-laptop: here, let me do a simple example with Functor
06:53:40 <scshunt> let's suppose we have data Foo a where { Foo a :: Foo a, Bar :: Foo Int }
06:53:50 <scshunt> can we implement Functor for this?
06:54:01 <scshunt> we just need fmap
06:54:29 <scshunt> recall that fmap :: (a -> b) -> f a -> f b, so in this case, we need (a -> b) -> Foo a -> Foo b
06:54:44 <scshunt> fmap f (Foo v) is easy, you set it to Foo (f v)
06:54:52 <scshunt> but fmap f (Bar i) = ?
06:55:09 <scshunt> of course, this is only a valid pattern when a ~ Int
06:55:19 <hpc> scshunt: i spotted the isomorphism that makes that rather easy :D
06:55:29 <nitrix> (Bar (Foo i))  :P
06:55:36 <hpc> oh wait, that's a gadt syntax thing
06:55:40 <scshunt> hpc: yes
06:55:43 * hpc thought it was a record derpaderp
06:55:58 <scshunt> so we know that f :: Int -> b
06:56:06 <scshunt> but we can't make Bar (f i), since Bar only takes an Int
06:56:13 <scshunt> err wait
06:56:16 <scshunt> I screwed up the definition
06:56:26 <nitrix> Thought so :P
06:56:34 <scshunt> let's suppose I made it data Foo a where { Foo :: a -> Foo a, Bar :: Int -> Foo Int }
06:56:37 <scshunt> there we go
06:56:47 <scshunt> now read everything I said in that context
06:56:52 <nitrix> I didn't know you could use `where` there.
06:56:57 <scshunt> nitrix: it's GADT syntax
06:57:05 <scshunt> the only way to make a Foo b here is to return Foo (f b)
06:57:21 <scshunt> we're forced to do so in order to define fmap
06:57:32 <scshunt> but now, we look at the Functor laws, and we see that one law is that fmap id = id
06:57:43 <scshunt> but id $ Bar i = Bar i, while fmap id $ Bar i = Foo i
06:57:48 <scshunt> we've violated this law
06:58:05 <scshunt> so this definition of fmap won't work
06:58:10 <scshunt> but it was the *only* definition that would work
06:58:22 <scshunt> so therefore there is no instance of Functor for our toy type
07:01:57 <joneshf-laptop> scshunt, sorry I have to run, I'll read this in a couple hours
07:02:07 <joneshf-laptop> scshunt, hpc maerwald thanks for all your help!
07:21:47 <jophish> I have a AST describing a language which consists of (among other things) a set of nested declarations of type Decl. Is there a way using generics of creating a function to extract all the values of type Decl from a given tree?
07:24:40 <bergmark> jophish: yes, e.g. `universeBi` from uniplate
07:25:57 <jophish> bergmark: I'll give it a try, thanks!
07:35:51 <Lokathor> the version of a loop with carefully applied additional strictness has ~500x improved performance compared to the normal version just using execState
07:35:53 <Lokathor> yikes
07:38:54 <jophish> bergmark: It works, amazing. Thanks again
07:44:05 <hackrilege> Lokathor, wowza! can you paste your code?
07:45:21 <apsod> Hm, is lens appropriate for dealing with lateral composition? e.g. i have a JSON structure and want to change fields depending on the content of other fields.
07:45:31 <Lokathor> hackrilege, slightly better: i can give you a diff of the whole repo https://github.com/Lokathor/ludolib/commit/6c8d8862b8c901e2657999a6edcb3ecdf6eaaf1a
07:49:55 <Akii> what's the meaning of ! and # in !Word#?
07:51:26 <liste> Akii: ! is a strictness annotation, # means unpacked (in this case)
07:51:46 <liste> unboxed*
07:52:25 <statusfailed> How do I do synchronous communication with another thread? e.g., thread A asks thread B for an item, and waits until thread B returns it
07:52:31 <Akii> ah, thanks!
07:52:49 <statusfailed> I think I could use two Chans, but I'm not sure if there's a better way
07:54:12 <Lokathor> statusfailed, MVar is alright for this. Async, if B has to pass an item only once
07:54:25 <Lokathor> TVar of course is better than MVar in most situations
07:54:32 <hpc> Akii: normally, '#' is a symbol-like character and wouldn't be valid there
07:54:42 <hpc> Akii: but GHC has a MagicHash extension that lets it work in that context
07:54:57 <statusfailed> Lokathor: what do you mean if B has to pass an item only once?
07:55:03 <hpc> Akii: it's technically just another character, but convention makes it mean as mentioned above
07:55:33 <hpc> Akii: similarly to ' meaning "strict" and _ meaning "drop the result" in definitions using Monad
07:56:04 <Akii> but those are more like conventions, right?
07:56:15 <hpc> yep
07:56:32 <Lokathor> statusfailed, if B gives an item over to A just once and then dies, you can use an async.
07:56:45 <Lokathor> if B and A are passing items back and forth for whatever reason, you'll need MVar or TVar
07:56:58 <hpc> just so you understand the mechanism (or lack of one) behind # meaning what it does
07:57:05 <hpc> which helps just for making it look less scary
07:57:24 <Lokathor> statusfailed, http://chimera.labs.oreilly.com/books/1230000000929/index.html there's a really good (and free) book all about this sort of stuff
07:57:29 <Akii> yep, nice thanks :D
07:57:59 <statusfailed> Lokathor: ah I see - nah B needs to stay alive
07:58:02 <statusfailed> cheers, i'll look through it
07:58:16 <Lokathor> Akii, note that the !Word# is actually no different from Word#, though perhaps the submitter didn't know that
07:58:48 <Akii> so unboxing implies strictness
07:59:07 <Lokathor> correct, there's no lazy version of an unboxed value
07:59:59 <hpc> or perhaps a bit more directly, in ghc thunks are implemented in terms of boxing
08:01:29 <Lokathor> anyway, 500x faster, damn those tuples, etc
08:01:38 <Lokathor> but i gotta get to work, have fun folks
08:10:03 <roelof> Anyone who uses the Haskforce plugin and know if and how I can use a repl ? 
08:12:07 <hackrilege> edeted my paste so now its now super readable! http://lpaste.net/160835
08:14:27 <hackrilege> i would like to know how this compares in performance to a standard use of zipper... i think it could be faster for the 2d case
08:14:51 <hackrilege> i also cant quite understand how the extension to 2d would work
08:15:15 <hackrilege> if anyone has any suggestions
08:25:20 * hackagebot diagrams-contrib 1.3.0.9 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.3.0.9 (BrentYorgey)
08:28:57 <roelof> no haskforce users here ? 
08:35:19 <roelof> Is there a IDE except emacs where I can easily use a repl within the ide ? 
08:36:52 <Akii> roelof: intellij should be able to, I think
08:37:06 <nitrix> roelof: Personally, I use i3wm as my window manager. Any other tiled window manager could do, then I just switch window and reload my file or copy-paste things in there.
08:37:56 <nitrix> roelof: I'm not a fan of IDEs; the diagnosis by GHC are fairly clear. I know it's not want you want to hear but, just saying it's still very usable and I'm comfortable with it.
08:38:00 <roelof> nitrix:  so you do not use a ide ? what do you use then to make the source files ? 
08:38:12 <nitrix> I use a text editor. Vim.
08:38:34 <roelof> oke, and then in another windows a prompt ? 
08:39:03 <nitrix> Yeah, but because I have a tiling window manager, they're right next to each others, almost part of my vim.
08:39:06 <maerwald> I also don't understand why people want to put functionality that works fine in separate pieces into one piece. That's a different story if it was about refactoring tools though. They have to be part of the editor/IDE.
08:39:41 <nitrix> Switching between the REPL and the insert mode with vim would be the exact same amount of key presses if it was integrated, I just don't see the point.
08:39:47 <maerwald> Like... do you really need an integrated shell in your gui filemanager?
08:39:52 <roelof> maerwald:  what do you use then ? 
08:40:07 <maerwald> gvim + terminal in i3wm
08:40:16 <nitrix> roelof: All I have is a few plugins that "understands" haskell code to navigate it and refactor it more easily.
08:40:46 <roelof> nitrix:  oke, thanks, I will investigate this way of working 
08:40:47 <maerwald> maybe vim users are more used to the terminal since vim plugins are often broken... unlike in emacs ;)
08:40:54 <jophish> vim inside tmux works very well for me
08:41:11 <maerwald> jophish: more levels of hotkeys please
08:41:12 <nitrix> I heard the emacs experience is better though.
08:41:24 <maerwald> X11 hotkeys, wm hotkeys, terminal hotkeys, tmux hotkeys, vim hotkeys
08:41:24 <nitrix> But it isn't for me :)
08:41:26 <maerwald> omg
08:41:55 <nitrix> roelof: On a side note, look at i3wm. It's very cool.
08:41:58 <jophish> maerwald: I don't use the first three in that list, and I have a little bit of overlap for the tmux and vim keys
08:42:03 <jophish> depending on context
08:42:09 <maerwald> bad enough
08:42:10 <jophish> (for example switching between panes)
08:42:39 <roelof> nitrix:  I do not know it, I always used to do things in kde or gnome 
08:43:17 <maerwald> roelof: you can just use i3wm instead of kwin in kde
08:43:24 <maerwald> no switching of "DE" required
08:43:32 <jophish> maerwald: wait, don't you have it the same as me, just swap i3wm for tmux...
08:43:46 <maerwald> jophish: no
08:44:02 <roelof> maerwald:  oke, then I have to google how that is going to work 
08:44:03 <aweinstock> I use vim + screen + stumpwm
08:44:51 <maerwald> jophish: given that your "I don't use the first three" cannot be correct anyway ;) 
08:45:21 <maerwald> you have a terminal either way... or vty, whatever
08:45:25 <jophish> maerwald: perhaps this is a discussion for haskell-blah
08:45:27 <maerwald> which has hotkeys
08:45:35 <maerwald> jophish: no, I don't join that channel
08:45:40 <maerwald> you can join #haskell-offtopic though
08:45:43 <jophish> sure
08:46:12 <aweinstock> what's the difference between -blah and -offtopic?
08:46:36 <jophish> aweinstock: blah is for the cool kids I'm guessing
08:47:02 <maerwald> aweinstock: -blah is ruled by someone I don't know with weird rules. Looks like a private channel, not really a haskell one
08:47:10 <geekosaur> ^
08:47:27 <maerwald> #haskell-offtopic has the same moderators as here
08:48:17 <ertes> what i don't understand is that "your preference is stupid/pointless/…" is such a common response
08:48:31 <aweinstock> I'd been hanging out in haskell-blah for a while, not even knowing about haskell-offtopic
08:49:05 <ertes> haskell-interactive-mode in emacs is a very useful tool, and it's reasonable to ask for similar tools
08:49:18 <maerwald> leksah might be able to do that too
08:51:04 * JuanDaugherty retried leksah within last month
08:51:20 <jophish> JuanDaugherty: any good?
08:51:26 <JuanDaugherty> messed up a working config I think with the new build issues
08:51:39 <JuanDaugherty> leksah is nice but I'm tending to eclipse fp
08:52:39 <JuanDaugherty> leksah would be superior if it weren't for the intangibles related to usability, maint, etc.
08:52:56 <JuanDaugherty> usablilty/buildabilty
08:53:21 <JuanDaugherty> he's switching from gtk2hs to something else but said it would still have same profile
08:53:32 <maerwald> JuanDaugherty: what is he switching to?
08:53:33 <JuanDaugherty> which sfaik could be common to hs gui apps
08:53:45 <JuanDaugherty> is glxgi a thing?
08:54:00 <JuanDaugherty> sounded like that iirc
08:54:51 * JuanDaugherty thought he was in -offtopic
08:55:37 * roelof is going to eat dinner so have all a nice evening 
08:56:06 <ertes> does anyone use yi?
08:56:21 <maerwald> too basic for my taste
08:56:24 <JuanDaugherty> leksah embeds yi iirc
08:56:31 <maerwald> JuanDaugherty: except it doesn't work
08:56:36 <maerwald> as in: compile :P
08:56:53 <maerwald> unmaintained codepath
08:57:03 <JuanDaugherty> well it worked fine when I got it built some years back
08:57:12 <maerwald> 3 months in haskell is already bitrot
08:57:14 <maerwald> years is...
08:57:43 <JuanDaugherty> yeah and leksah is a big program
08:58:04 <JuanDaugherty> eclipse fp is more modest
08:58:25 <maerwald> I get cancer just by thinking about eclipse :/
08:58:35 <geekosaur> this might be the first time I've heard eclipse described as modest >.>
08:58:52 <JuanDaugherty> there's an acclimation period like most software cultures
08:59:30 <JuanDaugherty> it's the default IDE of this time
08:59:38 <maerwald> erm
09:00:00 <silver> android switched to Idea as far as I know
09:00:29 <JuanDaugherty> last I saw they were pushing a branded eclipse
09:00:35 <ertes> does "modest" mean "stops wasting your CPU time and gives you (a lot of) RAM back by segfaulting in your face"?
09:00:59 <ertes> that's my most recent experience with eclipse, but it was like a decade ago
09:01:32 <JuanDaugherty> yeah, like I said working with eclipse takes a gestalt shift from what you may expect working with commercial or single lang IDEs
09:03:12 <ertes> considering that i don't mind running a whole sub-operating-system just to write haskell code =)
09:03:33 <ertes> (come on, tell me you don't know what i'm talking about!)
09:04:25 <JuanDaugherty> you mean the haskell/cabal env? or eclipse/leksah?
09:05:47 <maerwald> he probably means stack
09:05:57 <JuanDaugherty> ah
09:06:19 <geekosaur> emacs? >.>
09:06:38 <ertes> we have a winner!
09:06:48 <JuanDaugherty> there's an hs mode/pkg but it was underwhelming iirc
09:09:16 <ertes> emacs takes so long to load that i actually run it as a daemon (similar to what neovim does – i think)
09:10:02 <Oejet> aweinstock: #haskell-blah is the older of the offtopic channels.
09:10:59 <maerwald> and they kick people who don't have ssl enabled
09:11:21 <geekosaur> I hung around in there for a couple weeks, seemed to have very little overlap with the rest of the haskell channels
09:11:28 <pavonia> There are several offtopic channels?
09:11:29 <geekosaur> it has gone its own way
09:11:29 <Oejet> aweinstock: A long time ago #nothaskell forked from it mostly in order to have a code of conduct I think (I may be corrected).
09:14:01 <JuanDaugherty> pavonia, there's 2, one requires tls, the other doesn't
09:14:21 <srhb> People seem very reluctant to detail why #haskell-offtopic split off from #haskell-blah.
09:14:33 <srhb> (Which may be sound, but, curiosity!)
09:14:36 <JuanDaugherty> i just gave the reason without naming names
09:14:51 <srhb> JuanDaugherty: Oh sorry, I missed that.
09:15:05 <ertesx> the TLS thing?  what's a weird reason for a split
09:15:28 <Oejet> aweinstock: On 2016-04-01 #-blah becase TLS-only after a two months transition period.
09:15:36 <geekosaur> but it is correct because it means #haskell-blah is inaccessible for many folks now
09:15:48 <Oejet> s/becase/became/
09:15:53 <srhb> I see. :)
09:15:56 <maerwald> ertesx: well, I think that's just one of the symptoms showing that's not a community driven channel, but a private one
09:16:12 <maerwald> which is fine ofc
09:16:17 <ertesx> i see
09:16:21 <maerwald> but then it also makes sense to create another one
09:16:29 <ertesx> the code-of-conduct thing seems more reasonable, although it could cause some unforunate community fragmentation
09:16:58 <silver> community generally uses tls
09:17:37 <Oejet> geekosaur: Not really. Enabling TLS is trivial in most clients, and for the rest (a tiny number of people), we can figure out a solution.
09:17:56 <geekosaur> the problems may not be technical
09:18:09 <maerwald> there already is a solution: join #haskell-offtopic ;)
09:18:10 <Oejet> maerwald: It's not a private channel.
09:19:03 <geekosaur> lots of places already restrict IRC heavily. encrypting it can push you over an administrative line
09:19:46 <ertesx> a long time ago when it was called #nothaskell, i found that there was very little community overlap and a very strict CoC, which is a strong indication that it's not a technical thing at all
09:19:51 <ertesx> not sure if it's still that way
09:21:08 <geekosaur> ertesx, I meant re enabling irc-over-ssl
09:21:27 <ertesx> geekosaur: ah
09:22:07 <Oejet> geekosaur: I'm aware of one case of that. A workaround was found.
09:23:07 <geekosaur> and you're still ignoring the bit where there is very little overlap between #haskell-blah and other haskell resources currently and they are making decisions without much community involvement
09:23:09 <Oejet> geekosaur: Ah, you mean like traffic inspection?
09:23:42 <geekosaur> but apparently you think staging what would probably be interpreted as an invasion as reasonable
09:23:56 <ertesx> "you"?
09:24:11 <hpc> what is the overlap between -blah and here anyway?
09:24:11 <Oejet> geekosaur: Ah, yes. That might be true, but if so it also true for a long time before TLS.
09:24:21 <geekosaur> Oejet's arguments in the ultimate direction of "let's just use #haskell-blah"
09:24:27 <ertesx> ah
09:24:32 <silver> wait what
09:24:46 <geekosaur> it's *not* the offtopic channel any more, hasn't been for a long time. it is something else
09:25:02 <geekosaur> the TLS change is just emphasis
09:25:06 <Oejet> geekosaur: (My last message referred to the overlap)
09:25:09 <ertesx> i'll go with #haskell – someone has to…
09:25:21 * hackagebot heredocs 0.1.0.0 - heredocument  https://hackage.haskell.org/package/heredocs-0.1.0.0 (KatsutoshiItoh)
09:25:56 <silver> geekosaur, what do you mean by "offtopic channel"?
09:26:10 <Oejet> geekosaur: No, it has been _the_ offtopic channel.
09:26:31 <hpc> this lists only -blah and no other off-topic channels: https://wiki.haskell.org/IRC_channel
09:27:09 <maerwald> hpc: I already pinged Cale to fix it
09:29:09 <hpc> wiki.haskell.org also needs a favicon and a good cert, but that's getting a bit in the weeds
09:30:28 <sphinxo> Why in Data.Maybe is catMaybes called catMaybes?
09:30:51 <sphinxo> I can't think of a better name, but it seems out of place
09:31:18 <hpc> it's out of place as a definition first imo
09:31:24 <hpc> but it's convenient sometimes so it stays in
09:31:37 <hpc> that's probably why it feels odd
09:31:54 <sphinxo> I'm writing a python (ikr) library that has similar functionalilty and i'm wondering what a better name might be
09:32:09 <maerwald> fromMaybes
09:32:12 <ertesx> sphinxo: it's 'concat' with differently typed layers; "Maybes" as in "list of Maybe"
09:32:17 <ertesx> sphinxo: i think, the name is fine
09:32:29 <maerwald> :t fromMaybe
09:32:30 <lambdabot> a -> Maybe a -> a
09:32:40 <simpson> sphinxo: What, something like def nonNones(l): return [x for x in l if x is not None]
09:32:59 <sphinxo> yeah equivelent
09:33:10 <maerwald> fromMaybes would then be [Maybe a] -> a. I think that makes sense
09:33:20 <sphinxo> frommaybes works nicely i think
09:33:38 <sphinxo> I already have from_maybe
09:33:53 <sphinxo> Thanks
09:34:14 <ertesx> catMaybes :: F (G a) -> F a
09:34:25 <ertesx> concat :: F (F a) -> F a
09:34:51 <ertesx> concatButWithMaybesInTheInnerLayer
09:34:51 <hpc> in your python script, are you using a maybe-like class or just null?
09:34:59 <sphinxo> Maybe like class
09:35:38 <sphinxo> inheriting from monad,applicative and functor
09:35:48 <maerwald> I also have something like: maybeD :: (Default b) => (a -> b) -> Maybe a -> b
09:35:49 <maerwald> didn't find it elsewhere
09:35:55 <ertesx> there is probably a generalisation of monads that would call 'catMaybes' just 'join'
09:36:01 <sphinxo> doing shoddy typeclasses with @abstractmethod 
09:36:16 <hpc> or traverse
09:36:21 <ertesx> maerwald: looks like foldMap, except with a less principled mempty
09:36:42 <maerwald> I think the Default class is more appropriate here
09:36:57 <ertesx> sure, it can be…  it's just less principled =)
09:37:12 <ertesx> in cases like that i prefer to use 'maybe' though
09:37:52 <maerwald> that can be awkward with a lot of code duplication, depending on the context
09:38:02 <maerwald> e.g. I had that problem with the ICal library
09:38:27 <maerwald> and Default just did the right thing
09:38:31 <ertesx> maerwald: it's really just 'maybe def' where you would write 'maybeD'
09:38:36 <maerwald> yes
09:38:43 <maerwald> that's how it's defined
09:50:22 * hackagebot webapi 0.2.2.0 - WAI based library for web api  https://hackage.haskell.org/package/webapi-0.2.2.0 (ersran9)
10:25:24 * hackagebot shine 0.1.0.0 - Declarative graphics for the browser using GHCJS  https://hackage.haskell.org/package/shine-0.1.0.0 (fgaz)
10:40:25 * hackagebot yesod-job-queue 0.1.0.2 - Background jobs library for Yesod.  https://hackage.haskell.org/package/yesod-job-queue-0.1.0.2 (nakaji_dayo)
10:40:43 <sm> so much software..
10:46:43 <orion> Let's say you have a data type representing cryptographic state and you want to write a Pipe to abstract over securing and unsecuring messages. The State is altered each time you secure/unsecure a message, meaning that the states need to be linked to one another. Is parameterizing the Pipe by an MVar a sensible design choice?
10:51:35 <Molleman> sup
10:52:20 <Molleman> Were are everyone from? <3
10:53:20 <kadoban> Hello. I am from the internet. You?
10:53:35 <Molleman> From Sweden ;)
10:55:35 <srhb> Molleman: There's also #haskell.se -- not so active, but they're trying! :-)
10:56:28 <Sornaensis> can someone tell me what makes haskell useful when you have languages like go and clojure which are good at concurrent programming and functional programming respectively
10:56:49 <srhb> Sornaensis: It's purely functional!
10:57:06 <insitu> Sornaensis because Haskell is good at BOTH concurrent and functional programming :-)
10:57:25 <insitu> orion why an MVar?
10:57:47 <srhb> Sornaensis: Also, I dispute the premise. ;)
10:58:24 <kadoban> Sornaensis: Being able to write code that works and works reliably makes it useful. The type system helps catch bugs that would creep up at runtime in many other languages, and is very expressible. It saves you a lot in the maintenance phase as well, doing refactoring on haskell code is a dream, because 95% of the time, it's totally obvious when you do it wrong.
10:58:40 <kadoban> I've never done anything concurrent in haskell really, unless some reflex-dom counts.
11:00:56 <simpson> Sornaensis: Haskell is not meant to be useful.
11:01:04 <maerwald> Sornaensis: refactoring
11:01:11 <mnoonan> Haskell's threads seem very comparable to Go's goroutines.. does Go actually have any advantage in the concurrency story?
11:02:25 <srhb> mnoonan: I think that's the question being asked. :)
11:03:28 <maerwald> Sornaensis: I don't care for most of haskells technical properties very much... rather the effect they have. And refactoring in haskell is usually a pleasure. Which I cannot say from most languages.
11:03:58 <simpson> Sornaensis: So, do you feel like your question was answered?
11:04:00 <maerwald> and I consider refactoring the most fundamental thing programmers do in their daily life
11:04:08 <maerwald> not writing _new_ code
11:04:24 <Sornaensis> yea but if you need a degree in category theory just to read some simple algorithms
11:04:30 <maerwald> wat?
11:04:35 <Sornaensis> how do you ever get to the refactoring stage
11:04:38 <simpson> maerwald: That's a shame; the most essential skill for a programmer should be reading and auditing.
11:04:43 <Sornaensis> like, stuff is so overly complicated
11:04:44 <simpson> Sornaensis: Oh, you *did* want to pick a fight!
11:05:05 <orion> insitu: Because the inbound message pipe needs to share state with the outbound message pipe.
11:05:11 <maerwald> simpson: reading code is implied in refactoring.
11:05:19 <srhb> Sornaensis: That's mostly a myth perpetuated about Haskell.
11:05:32 <simpson> maerwald: Yeah, but when's the last time that you just read somebody else's code, without altering it? Musicians listen to music all the time; why shouldn't programmers read code?
11:05:45 <srhb> Sornaensis: You get extra tools to analyze your programs with a language like Haskell. Because it's possible. You don't _have_ to use them. :)
11:05:51 <maerwald> simpson: programmers in industry rarely read code without refactoring purposes
11:06:00 <maerwald> so I don't consider that the most fundamental thing
11:06:03 <srhb> Sornaensis: For most people (who stick with Haskell) the extra tools are a blessing, something you can't really do in other languages.
11:06:04 <simpson> maerwald: That's too bad! We should encourage people to read more code.
11:06:04 <EvanR> a PHD in pure math is an effect of learning haskell, not a prereq
11:06:17 <maerwald> simpson: again: that's implied in refactoring
11:06:29 <simpson> maerwald: I get that (refactoring -> reading). I
11:06:39 <srhb> Sornaensis: And yes, it does sometimes make clanking in programs in another language feel like being a monkey at a typewriter. :-)
11:06:39 <simpson> maerwald: I'm just saying that (reading) should be worthwhile on its own.
11:06:48 <EvanR> the most important activity done by programmers is being replaced
11:06:54 <maerwald> reading code without being interested to refactor, alter or improve the code might be cool hobby thing
11:06:58 <EvanR> liskov programmer substitution principle
11:07:02 <maerwald> but it's not the most fundamental part of a programmers day
11:07:05 <maerwald> which was my point
11:07:30 <simpson> maerwald: Yes, many programmers are still learning how to program. And that's okay too.
11:07:34 <maerwald> writing software from scratch is what you do 10% of your time maybe
11:07:58 <maerwald> and writing software from scratch is pretty nice in perl... but refactoring...not.
11:08:23 <EvanR> maerwald: on a good day, its possible to spend 90% of your time writing new PHP and 0-10% fixing it despite it being completely broken
11:08:45 <EvanR> because fixing it is not worth it or just not part of the schedule
11:08:58 <koala_man> 10%? you lucky dog
11:09:06 <maerwald> I currently spend 100% of my time refactoring broken javascript code. It's going to be 2 months down the line. If it was written in haskell... it would be unlikely that it takes more than a few days.
11:09:26 <srhb> koala_man: Back in my day (etc.)
11:10:18 <maerwald> I don't like to spend my time understand broken crap because people were able to express things they didn't even think through. That's rather hard to do in haskell.
11:10:41 <srhb> Sornaensis: Why do you think Haskell is overly complicated?
11:11:21 <maerwald> that's pretty much the only reason I like haskell... I couldn't care less about "type safety" if someone can come up with a similar approach (a new prolog?) that has similar refactoring advantages
11:11:43 <maerwald> Go does not have that.
11:11:59 <EvanR> depending on what you focus on haskell's language is very simple
11:12:15 <simpson> lens.
11:12:32 <EvanR> you might come to think lens is simple
11:12:38 <maerwald> lo
11:13:01 <maerwald> depends on the definition of simple
11:13:06 <EvanR> at some point people thought nested gotos were simple
11:13:33 <EvanR> also lens is a particular library
11:13:48 <maerwald> I don't see a useful use case for lenses in most of what I do. If my data structures are that nested that I am considering lens... I'm either doing something wrong or I am writing a compiler.
11:13:53 <hguant> what's wrong with nested goto's?
11:14:13 <EvanR> nothing, use the basic monad!
11:14:17 <EvanR> its so simple
11:14:24 <srhb> Basic as in Cont?
11:14:32 <EvanR> theres also BASIC
11:14:35 <maerwald> the worst of all monads :P
11:14:44 <srhb> I... What.
11:15:14 <hpc> dude that monad is the best
11:15:31 <maerwald> the ways it lets you obfuscate stuff are horrible
11:15:38 <maerwald> almost nothing of it is intuitive
11:16:13 <EvanR> at some point continuations was the height of functional programming technology
11:16:20 <EvanR> and its ... "so simple"
11:17:22 <maerwald> hyped stuff like FRP :P
11:17:48 <EvanR> if you ever find something thats undeniably simple in software... then you should buy fish vegetables meat and wine and have yourself a good party to celebrate yourself
11:18:10 <orion> Arrows really let me down.
11:18:45 <hpc> maerwald: anything can be rewritten into garbage by someone sufficiently creative ;)
11:19:40 <maerwald> hpc: that's not the point
11:20:56 <maerwald> you don't have to be particularly creative for the continuation monad to end up being garbage
11:21:34 <srhb> And yet it doesn't really happen a lot.
11:21:45 <maerwald> because most people don't even use it ;)
11:21:51 <EvanR> modern notion of garbage is interesting if you think about the kind of software that was super mario bros, or old arcade games
11:22:07 <EvanR> imagine what they thought was garbage!
11:22:55 <hpc> they didn't really care, they made mario and nobody ever had to go back and change it after
11:23:35 <EvanR> yes somebody did... on the wii you can now buy it again 
11:23:37 <hpc> also they were too busy making the machine do whatever they damn well wanted it to do
11:24:03 <hpc> sidescrolling meant refreshing the whole screen at once, which was HUUUUUGE at the time
11:24:19 <EvanR> no they used the scrolling support
11:24:40 <EvanR> you only need to update the edge blocks
11:25:05 <koala_man> mario had a bunch of techniques that were probably considered awesome and clever at the time by allowing you to squeeze more power out of crappy hardware, but which today would be a major headache because it makes changes really tricky
11:25:10 <EvanR> later on the PC it was helluva intensive
11:26:14 <koala_man> clouds and bushes use the same sprites, which is really clever. but if someone said "add some berries to the bushes", you'd curse out the programmer that made you refactor the entire cloud/bush drawing to allow it
11:26:40 <EvanR> "clever"
11:26:40 <srhb> I've lost track of how this even remotely relates to Haskell, Go, Clojure, concurrent or functional. but I think the asker lost interest anyway.
11:27:14 <hpc> it started from bad monads
11:27:32 <EvanR> wonders if this is a bad monad https://hackage.haskell.org/package/acme-all-monad
11:28:36 <osfameron> what does it actually do?
11:28:41 <EvanR> anything
11:29:00 <EvanR> for all values of anything
11:29:13 <osfameron> as so common with haskell modules, it appears to have no actual documentation
11:29:16 <osfameron> because types
11:29:17 <EvanR> (so maybe that implies it does nothing)
11:29:34 <hpc> osfameron: yes, how dare this acme module have no haddock
11:29:40 <hpc> ;)
11:29:52 <osfameron> what's the point of an acme module that has no documentation to show why it's funny?
11:29:54 <EvanR> it might be making fun of the style of docs that monad transformers have
11:30:49 <osfameron> ah
11:30:53 <hpc> you really need to read the source to truly enjoy an acme module as well
11:31:07 <hpc> and not so much the docs of monad transformers, as just their structure in general
11:31:13 <hpc> of having a type alias main definition
11:31:23 <hpc> and then sub-modules for the FooT and for MonadFoo
11:31:30 <hpc> all of which do the same thing
11:31:36 <EvanR> it doesnt seem to have a MonadAll instance for Cont and ContT
11:32:01 <srhb> hpc: MonadAll (AllT m) is great
11:33:03 <srhb> HAHAHA.
11:33:08 <jle`> EvanR: it looks like it's lawful
11:33:11 <srhb> acme-php has gotten a dependency on acme-left-pad :D
11:33:31 <tdammers> that must be the first left-pad joke that's actually kind of funny
11:33:39 <srhb> And hilarious at that. :P
11:33:50 <hpc> don't worry, acme-left-pad has a terrible implementation as well
11:34:34 <hpc> i forgot how much idiocy cabal allows through so the initial version of acme-left-pad is totally empty
11:35:07 <srhb> hpc: I thought it was just because Hackage runs on steam and wishes of good fortune.
11:35:31 <hpc> hopefully there's going to be a much bigger update to acme-php coming soon
11:35:53 <hpc> it's going to be tricky to get right, and i need to make sure it's funny enough
11:35:55 <hpc> but oh man
11:35:56 <hpc> i can't wait
11:36:19 <EvanR> are you going to add fully support for acme-java and acme-javascript
11:36:31 <EvanR> like real php
11:36:40 <srhb> Also something something opcache
11:36:41 <hpc> without spoiling too much, let's just say i am going to add documentation
11:36:50 <srhb> :-)
11:37:39 <geekosaur> acme-cobol-on-cogs >.>
11:38:09 <cgrs> hi everyone!
11:38:27 <cgrs> i'm having an error on a function right here: http://lpaste.net/6442759992666750976
11:38:30 <cgrs> on the last line
11:39:26 <tdammers> http://intercaloninterstates.org/
11:39:42 <EvanR> lol
11:39:53 <dpk-atk> hey guys
11:39:58 <dpk-atk> i'm trying to understand comonads
11:40:00 <cgrs> It says something like "can't deduce the type (Fractional Int) from the context (Ord Int)"
11:40:03 <dpk-atk> does anyone hav ea good example?
11:40:07 <dpk-atk> thats intuitive
11:41:05 <hpc> i was really hoping for backwards intercal
11:41:17 <geekosaur> cgrs, haskell does not automatically coerce numbers
11:41:22 <hpc> like how a lot of highways say things like
11:41:24 <hpc> AHEAD
11:41:26 <hpc> X-ING
11:41:27 <hpc> PED
11:41:32 <cgrs> geekosaur: so, what do i have to do?
11:41:54 <geekosaur> you use n with `take`, whose type signature fixes it as Int, but you are dividing something by numbers from a sequence defined from it in `ratio`
11:42:18 <geekosaur> so for starters, `ratio` wants to use `(fromIntegral i)` instead of just `i`
11:42:40 <cgrs> geekosaur: thanks :D
11:42:42 <geekosaur> also it's helpful if you include the entire error message in such pastes
11:43:10 <cgrs> Oh, okay
11:43:48 <cgrs> geekosaur: done for future references
11:45:27 * hackagebot located 0.1.0.0 - Source location helpers  https://hackage.haskell.org/package/located-0.1.0.0 (TrevorElliott)
11:45:53 <cgrs> geekosaur: the fun of it is that i just helped a mate with the same thing, but with `sqrt`
11:46:31 <cgrs> `Maybe` I'm `Just` tired...
11:50:27 * hackagebot learn-physics 0.6.0.0 - Haskell code for learning physics  https://hackage.haskell.org/package/learn-physics-0.6.0.0 (ScottWalck)
11:50:39 <geekosaur> `Fractional Int` should always be a warning that you did something like that :)
11:55:27 * hackagebot csv-table 0.1.0.0 - Scripts for manipulating tables stored as CSV files  https://hackage.haskell.org/package/csv-table-0.1.0.0 (ranjitjhala)
11:57:26 <nek0> Hello again. I struggle right now to interface a C function that returns an iterator and make the iterator usable in Haskell. Is there an elegant way to do this? I suspect I will need to use monads.
11:57:49 <hpc> what's an iterator in C?
11:58:49 <tdammers> "I suspect I will need to use monads" is almost always wrong
11:58:52 <nek0> hpc: In my case its a data structure like a struct, which upon calling a special function changes its contents.
11:59:59 <hpc> my first thought is that the muation involved in that has instantly constrained it to involving IO in some way
12:01:51 <nek0> hpc: I think so, too.
12:01:54 <dcoutts> nek0: basic approach is wrap it and not hide the mutation. So e.g. next :: TheIter -> IO (Maybe a)
12:02:00 <dcoutts> where that simply modifies the iterator
12:03:04 <dcoutts> sometimes it can make sense to use ST if the effects are purely local
12:03:17 <nek0> what is ST?
12:03:27 <dcoutts> which gives a route to using a pure and possibly lazy interface
12:03:52 <dcoutts> nek0: you can think of it as the safe subset of IO, only mutable variables no "real" external effects
12:04:09 <dcoutts> and the API is such that mutable variables used locally can be externally pure
12:05:29 <dcoutts> so some code that creates, uses and then forgets a mutable variable can hide the fact that it's using mutation, the overall result can be pure, no longer in ST
12:05:59 <nek0> Problem is; that I will have external effects. I am iterating over pixel data with the possibility of changing them.
12:06:06 <dcoutts> ok, then it's IO
12:07:55 <nek0> I don't know to wrap the whole thing up, so it works in haskell and interfaces the data from and in C.
12:08:35 <nek0> Maybe I'm thinking in the wrong way about it. I'm still new to Haskell FFI.
12:40:31 * hackagebot Plot-ho-matic 0.9.0.6 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.6 (GregHorn)
12:41:03 <hatman> test
12:41:16 <hatman> test\n test
12:47:02 <acertain> is there a Seq with type-level length somewhere on hackage?
12:58:45 <nitrix> Hi, is that all there is to GADTs?! Instead of letting the compiler generate the constructor and patterns for the given names, you declare things by giving their complete type signature, and that's it!?
12:59:29 <Peaker> nitrix: GADTs let you do stuff that ordinary ADTs cannot do, it's not just new syntax
12:59:33 <nitrix> data Maybe a = Just a | Nothing  v.s.  data Maybe a where Just :: a -> Maybe a; Nothing :: Maybe a ?
12:59:52 <nitrix> Peaker: Yeah, I've understood that much, but that stuff can be done already with existentials I think.
13:00:04 <Peaker> nitrix: for example:  data MaybeInt a where Just :: Char -> Maybe Int ; Nothing :: Maybe Bool
13:00:16 <nitrix> Peaker: Right.
13:00:52 <Peaker> nitrix: or:  data HaveOrdInstanceInside a where C :: Ord a => HaveInstanceInside a
13:01:19 <nitrix> Peaker: couldn't someone use existantial quantification to reproduce this?
13:01:32 <Peaker> nitrix: classic case for GADTs is "type-safe ASTs".  data Expr a where Add :: Expr Int -> Expr Int -> Expr Int ; And :: Expr Bool -> Expr Bool -> Expr Bool ; ...
13:01:48 <Peaker> nitrix: there is no existential in the "HaveOrdInstanceInside" example
13:02:12 <acertain> conceptually, a GADT stores equality proofs for it's non-uniform parameters (those that vary between constructors). `data Foo a where Foo :: Foo Char` is equivalent to `data Foo a where Foo :: (a ~ Char) -> Foo a`
13:02:17 <nitrix> Mhhh, well, not in that example I guess. It's actually a good point.
13:02:25 <nitrix> So it does buy you things that aren't possible otherwise.
13:02:41 <shachaf> Peaker: GHC calls that an existential.
13:02:57 <shachaf> Or at least the extension that turns it on is ExistentialQuantification.
13:02:58 <nitrix> o:
13:03:50 <shachaf> It's the dual of => rather than forall, but there isn't really a name for that.
13:04:14 <aerialB> If I do something like "f (take n xs) (drop n xs)" will ghc optimize by combining take and drop into one operation?
13:04:16 <acertain> Foo stores a proof that a is Char, and you can extract that proof into local context by pattern matching. to make a `Foo a`, you need a proof that a is Char in the local context
13:04:45 <Peaker> aerialB: probably not
13:05:15 <nitrix> aerialB: As far as I know, it wont.
13:05:21 <aerialB> alright
13:05:46 <nitrix> aerialB: If xs has to be built lazyly though, it might leverage memoization and share that for both.
13:05:54 <nitrix> aerialB: But there's two traversal as far as I know.
13:06:15 <nitrix> I don't know why I say "might", it's what it does, unless there's an optimization :P
13:06:57 <nitrix> shachaf: Okay, so, is GADT syntaxic sugar for ExistentialQuantitication almosT?
13:07:23 <scshunt> no
13:07:28 <scshunt> GADT is far more powerful
13:07:37 <nitrix> More powerful ._.
13:08:24 <acertain> `data Foo a where Foo :: (a ~ Char) -> Foo a` can also be written `data Foo a = ((a ~ Char) => Foo)`
13:08:27 <shachaf> GADTs are ExistentialQuantification + type equality constraints.
13:08:54 <bblfish> What is the relation between Free Monoids, Free Categories and Free Monads?
13:09:04 <shachaf> They're all free.
13:09:48 <geekosaur> (correct but meaningless answers for $500...)
13:09:58 <Enigmagic> I've started charging for my free monoids
13:10:01 <bblfish> yes, what does that mean? Does that mean that they can be constructed out of an underlying X, where X is a Set in the case of free Monoids, X is a graph in the case of free Categories, ...
13:10:04 <shachaf> https://en.wikipedia.org/wiki/Free_object
13:10:23 <shachaf> Yes, "free" is always in relation to something.
13:10:39 <sm> weird. https://www.haskell.org/cabal/users-guide/developing-packages.html -> data-files says wildcards are supported in filenames, but I'm getting "filepath wildcard 'doc/*.txt does not match any files"
13:10:51 <shachaf> For a monoid M, you can talk about the underlying set UM.
13:11:05 <sm> from stack build. Not sure about cabal build
13:11:35 <fizruk> shachaf: or underlying semigroup? in which case Maybe is free monoid?
13:11:35 <scshunt> acertain, shachaf: how do you write something like "data Foo a where Foo :: a -> Foo (Maybe a)" using existentials?
13:11:46 <shachaf> A free monoid a set X is a monoid FX such that, for any monoid M, monoid homomorphisms : FX -> M are in natural correspondence with functions : X -> UM
13:11:56 <shachaf> fizruk: Yes.
13:12:20 <fizruk> \o/
13:12:35 <orion> When writing a class function whose return type doesn't reference the instance type, what's better?: (proxy a -> Foo) or (a -> Foo)?
13:12:37 <shachaf> scshunt: data Foo b = forall a. b ~ Maybe a => Foo a
13:12:39 <acertain> `data Foo a = (forall b. (a ~ Maybe b) => Foo b)`
13:13:02 <orion> The first requires (Proxy :: Proxy SomeA) and the latter requires (undefined :: SomeA).
13:13:24 <bblfish> Ok, so Free X means that one can specify X constructively.
13:14:26 <sm> it looks like the stack devs had the same problem: https://github.com/commercialhaskell/stack/blob/master/stack.cabal#L21
13:14:37 <shachaf> No, it has nothing to do with constructivism.
13:14:47 <verement> aerialB: uncurry f (splitAt n xs)
13:16:24 <aerialB> verement: oh yes I went looking for that afterwards :) I was more wondering how far the optimization rabbithole goes with ghc
13:16:42 <geekosaur> Free X is, more or less, a data structure that represents the actions possible with X. this lets you store and replay those actions generically
13:18:45 <bblfish> ah ok geekosaur: So a Graph is the data structure that allows you to represent categories, and a Set is the data structure that allows you to represent monoids.
13:19:17 <shachaf> No.
13:20:24 <Peaker> My understanding is: If you "record" monoid operations in an AST, while forgetting the minimal detail you must forget in order to abide by the Monoid laws, then you get a Free monoid structure
13:21:38 <bblfish> well ok, I'll read this more carefully then https://en.wikipedia.org/wiki/Free_object
13:22:56 <shachaf> What geekosaur and Peaker are saying is right, at least for the case of free things in universal algebra.
13:23:19 <dolio> The problem is being precise about what all that means.
13:23:23 <shachaf> The categorical definition is more general.
13:23:27 <EvanR> is there a simple answer for the free commutative monoid
13:24:02 <Peaker> EvanR: If Free Monoid is the list, I'd expect free commutative monoid to be the MultiSet?
13:24:17 <shachaf> In universal algebra, you can say that free objects for some algebraic structure on a set are what you can make by starting with elements of that set as atoms, making every finite expression that you can make using the algebraic operations you have, and then quotienting by the laws.
13:24:44 <jle`> orion: the proxy a one is more commonly picked these days
13:24:50 <Peaker> shachaf: what is quotienting?
13:25:06 <shachaf> Peaker: Considering two things equivalent.
13:25:24 <orion> jle`: Why?
13:25:40 <jle`> well, it doesn't require using undefined, which was always sort of a hack
13:25:44 <shachaf> You can say that the elements of the free monoids are a bunch of equivalence classes. For [Bool], you have
13:25:48 <jle`> it doesn't require passing bottom, heh
13:26:16 <shachaf> {mempty, mempty <> mempty, mempty <> (mempty <> mempty), (mempty <> mempty) <> mempty, ...}
13:26:31 <jle`> orion: and in GHC 8.0 we'll have visible type application, so we can do Proxy @SomeA instead
13:26:45 <shachaf> {False, False <> mempty, mempty <> False, (mempty <> False) <> mempty, mempty <> (False <> mempty), ...}
13:26:54 <orion> jle`: Cool.
13:27:14 <shachaf> {False <> (True <> False), (False <> True) <> False, (False <> (True <> mempty)) <> False, ...}
13:27:24 <fce> => /bar scroll nicklist * -100%
13:27:34 <EvanR> Peaker: so bag?
13:27:35 <fce> Oops
13:27:43 <shachaf> Since all the elements of all those equivalence classes are forced to be equal by the laws.
13:28:07 <Peaker> EvanR: I think so -- but I'm just making an educated guess
13:28:15 <Peaker> (semi-)educated guess :)
13:28:26 <Peaker> (These are all things I've reverse engineered more than learned properly :) )
13:29:18 <jle`> orion: the type signature also implies that no 'a' will ever be used
13:29:31 <shachaf> Peaker: Yes, (finite) multisets is right.
13:29:37 <jle`> orion: whereas (a -> Foo) doesn't have such an implication
13:30:20 <Peaker> shachaf: cool -- there's some alternative representation of Free X, using quantifiers, right?
13:30:54 <jle`> orion: you can't write a function `forall p. p a -> Foo` that uses any a's as inputs
13:30:59 <shachaf> You can represent it as newtype Bag a = Bag (forall r. CommutativeMonoid r => (a -> r) -> r)
13:31:03 <dolio> There's an alternative representation of almost everything using quantifiers. :)
13:31:11 <shachaf> Maybe that's what you're thinking of.
13:31:59 <Zemyla> What's the way to compile modules so only the functions used are included in the final executable?
13:32:05 <bblfish> some other links on Free Monads https://www.schoolofhaskell.com/user/dolio/many-roads-to-free-monads http://blog.functorial.com/posts/2012-07-22-What-Makes-The-Free-Monad-Free.html
13:32:26 <shachaf> But of course that can be pretty inefficient -- it effectively stores an expression like ((x <> (y <> z)) <> (mempty <> z)), and relies on you not being able to observe the details.
13:35:39 <Peaker> shachaf: interesting, so to observe the things I should be able to observe, I can give a law-abiding instance there?
13:35:54 <shachaf> Yes.
13:36:18 <shachaf> For example for (forall r. Monoid r => (a -> r) -> r), you can pass in (:[])
13:43:57 <Lokathor> So whats the difference between Control.Monad.State.Strict and Control.Monad.State.Lazy? Both seem to indicate that modify is lazy and modify' is strict.
13:44:53 <Darwin226> Hey guys. Say I'm making a command line utility program. After a user installs it, is there some place on the filesystem where my program can put stuff? (like download files to and so on)
13:45:36 <Lokathor> Darwin226, that depends on the system itself sadly. Windows and Linux have very different ideas of what goes where
13:45:49 * hackagebot hackport 0.5 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.5 (SergeiTrofimovich)
13:46:01 <Darwin226> Lokathor: Yeah, I was hoping cabal/stack would do away with the differences here
13:46:03 <dolio> The difference is the definition of (>>=). One uses case, and the other uses let.
13:46:41 <Lokathor> Dolio, so with the Strict version, every MonadState action becomes strict autatically?
13:46:51 <Lokathor> Automatically*
13:46:58 <dolio> I don't know what you mean by that.
13:46:58 <sm> Darwin226: you can declare files in data-files in the cabal file, and use getDataFileName to get that path at run time
13:47:10 <dolio> If it's implied by what I said, then yes. Otherwise, no. :)
13:47:16 <Darwin226> Lokathor: There's some documentation on what a strict monad is here https://hackage.haskell.org/package/transformers-0.4.2.0/docs/Control-Monad-Trans-Class.html
13:47:24 <sm> this works if the user installed with cabal or stack, or if packagers have done a good job with your program
13:47:48 <sm> or, you can embed files in your program at compile time with file-embed
13:48:08 <Darwin226> sm: This works well for files that I need to read at runtime
13:48:16 <Darwin226> but where can I put new files?
13:48:26 <sm> ohh, sorry
13:48:35 <sm> temporarily ?
13:48:50 <Darwin226> Ummm, well. Not really
13:48:52 <dolio> I think the only difference between the two is (>>=), so I suspect it won't have any relation to what is in MonadState.
13:49:11 <sm> well, that's up to your program and conventions of the platform its on
13:49:27 <Darwin226> Kind of how stack for example downloads it's template files, or resolver caches and things
13:50:05 <Lokathor> Dolio, so i guess either way i need to change modify to modify' at the right places
13:50:14 <sm> these may help: https://hackage.haskell.org/package/directory-1.2.5.1/docs/System-Directory.html#g:3 
13:50:21 <Darwin226> Actually, now that I think about it, what I'm doing is windows-only anyways so it shouldn't be that complicated
13:50:56 <EvanR> cant you put files in the registry or something
13:51:30 <Darwin226> EvanR: I'm not sure that's how it works. Registry is for settings
13:52:15 <Lokathor> Stack puts things in AppData, i know
13:52:19 <sm> getAppUserDataDirectory or getUserDocumentsDirectory
13:52:34 <Peaker> Lokathor: the strict/lazy is about the state's tuple, iirc. iiuc: Strict state monad will evaluate the state actions themselves left-to-right. With lazy state monad, some actions may not be evaluated, or evaluated out of order
13:53:34 <Lokathor> Hmm. Well i know in this case i need to evaluate every action fully by the end, so strict and modify' it is, i guess
13:54:34 <Darwin226> sm: Huh, I didn't know System.Directory had such specific functions. This is exactly what I need. Thank you
13:55:19 <cocreature> Lokathor: note that this will probably still be slower (although I’m not sure if the difference is significant) than the monomorphised pair type I had in my pr, since that can be unboxed
13:56:25 <Lokathor> Right, but i want to setup a loop that can run any RandomGen, so that StdGen and the PCGen can be run through the same loop for proper comparison
13:57:09 <Lokathor> Relative speed comparison is the main issue. In real code there will be all sorts of other factors as well
13:58:00 <Lokathor> modify' (snd . next) should do it
14:06:15 <benzrf> :t next
14:06:16 <lambdabot> RandomGen g => g -> (Int, g)
14:06:47 <Lokathor> Cocreature, note that unboxed values (the Word#) dont have a lazy form, so strictness annotation on them had no effect there.
14:07:03 <benzrf> hows modify' different from modify - strictness?
14:07:22 <Lokathor> But i did get the time down because of the rest of your suggestions
14:07:37 <Lokathor> Benzrf, yes
14:08:03 <hpc> for some usage patterns it will significantly reduce memory consumption
14:08:39 <EvanR> this isnt even my lazy form
14:08:57 <Lokathor> ^
14:10:50 * hackagebot interlude-l 0.1.0.0 - Prelude replacement based on protolude  https://hackage.haskell.org/package/interlude-l-0.1.0.0 (darwin226)
14:10:52 * hackagebot sbp 0.51.11 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.51.11 (markfine)
14:14:06 <Asuran> i heard something about haskell to javascript, is this working good?
14:14:26 <Hijiri> it's called GHCJS and I hear that it works well
14:14:46 <Asuran> and it hears intresting thanks
14:15:05 <Asuran> im intrested how this looks i check it up
14:16:41 <Asuran> its really intresting haskell i kinda could like this programming style instead of imperative
14:17:36 <Asuran> i wonder why its not more popular coding in c++ is so much work
14:17:44 <EvanR> agreed
14:17:55 <Asuran> for something its good but in general too much work 
14:18:02 <kadoban> Asuran: It seems to be gaining some popularity, slowly. And yes, it's quite nice.
14:18:21 <kadoban> GHCJS is really useful too, I've been messing around with it for a couple of projects
14:18:26 <Asuran> i would like this on neural network architecture like ibms SyNAPSE platform
14:18:31 <Asuran> imagine this
14:18:45 <Asuran> the efficiency, the possibilities, the computing power
14:19:08 <Asuran> 2 watts achieve 8000x more than current cpu
14:19:17 <Asuran> imagine x86 emulated on it , still worth it
14:19:57 <Asuran> and as programming language haskell :P
14:20:25 <Asuran> but how does haskell look on gui side? i guess its empty there?
14:20:34 <Asuran> i mean except qt i dont expect anychoices
14:21:26 <Lokathor> cocreature, you're right, even with modify' (snd . next), using replicateM vs the custom loop is about 90x slower.
14:25:14 <Lokathor> Asuran, there's also GTK I guess, and you can compile stuff to chrome's webkit I think
14:25:21 <Lokathor> and SDL2
14:25:37 <sm> and fltkhs
14:26:13 * hackagebot interlude-l 0.1.0.1 - Prelude replacement based on protolude  https://hackage.haskell.org/package/interlude-l-0.1.0.1 (darwin226)
14:27:20 <TheMystic> interesting... I had no idea people were writing custom Preludes
14:27:47 <hpc> some are better than others
14:28:12 <hpc> wink wink nudge nudge
14:28:26 <TheMystic> ooooh... "Banishes String. Banishes partial functions. Compiler warning on bottoms. [...]" I can see the attraction.
14:29:04 <stick> hello, does anyone know if you can disable prepending an error message with a function name in which it failed?
14:32:23 <Lokathor> cocreature, http://lpaste.net/160864 :3
14:34:21 <stick> please respond
14:36:07 <kadoban> stick: I suspect if you're starting to care what happens when you use stuff that does 'error', the solution is to not use 'error'.
14:36:47 <stick> what would I use then instead?
14:38:15 <kadoban> stick: Non-partial functions. In what context is this coming up? Sometimes you can use something from the 'safe' package, though the *Note functions should be avoided because they're not ... safe. Though they sound a bit like what you're directly asking for actually, I'd still ... suggest you try to avoid them in favor of the better ones.
14:38:45 <mildfate> Hey all, I'm brand new to Haskell and I'm attempting to translate a program I wrote in Java into Haskell as an exercise.  What are the recommended libraries for making HTTP requests, parsing the HTML in the response, selecting data within the DOM and parsing JSON?
14:39:22 <MichaelBurge> wreq or http-client for HTTP, Aeson for JSON
14:39:52 <mildfate> Can you parse HTML with wreq?  I only saw documentation on parsing JSON responses.
14:40:29 <MichaelBurge> mildfate: The idea is you would get back a bytestring, that you would parse using some HTML library
14:40:43 <mildfate> What's a good HTML lib?
14:41:01 <MichaelBurge> I haven't had to do that particular task, but I imagine one of the XML libraries would work.
14:41:03 <stick> kadoban: I have a program that accepts some arguments, parses it, then does some job, and I want it to fail in some universal way in both pure and non-pure functions where there's error in parsing the arguments
14:41:12 <MichaelBurge> Is the HTML well-formatted?
14:41:55 <stick> in IO monad, you can just use exitFailure from System.Exit and printing the error message before calling it
14:42:05 <kadoban> stick: Are you using a library to handle the argument parsing? I like optparse-applicative, but I've heard it's not exactly easy for people who aren't familiar with Applicative that much; but you should use a library regardless, I'm sure there are others.
14:42:05 <MichaelBurge> mildfate: You can try tagsoup: https://hackage.haskell.org/package/tagsoup
14:42:08 <stick> but there seems to be no obvious way to do the same for pure functions
14:42:30 <MichaelBurge> mildfate: It looks like ByteString satisfies the StringLike typeclass, so tagsoup should be able to handle the Bytestring you get back from wreq
14:43:20 <sm> stick: you may want to handle failure in the non-pure part of your program only, and have your pure functions return Either 
14:43:22 <stick> kadoban: no, I had no idea there's even a library for that, I just parse the arguments in a pure function and return a data structure with the needed flags set, which is then processed in the main function
14:43:24 <mildfate> MichaelBurge: Cool.  Is using Google the best way to find Haskell libraries for a variety of problems or is there a canonical list somewhere?
14:43:43 <kadoban> stick: You should parse the input you get as quickly as possible, and then you only have to deal with a nice haskelly model of the data, not the raw junk. This lets the type system help you the maximal amount. Plus then you get to avoid rewriting all of the logic of argument parsing, which is ... quite involved when you get right down to it.
14:43:59 <kadoban> (The first part of that is probably not new information to you, but I didn't feel like deleting it)
14:44:01 <MichaelBurge> mildfate: Google, and then you want to look on Hackage for the documentation since all the types are hyperlinked with each other and you can easily view the source.
14:44:29 <kadoban> stick: Yeah, definitely use a library. You'd have to ask others what the good ones are though, or I mean you can try optparse-applicative and see what you think.
14:44:43 <sm> cmdargs and docopt are good
14:45:22 <Welkin> DOCOPT?
14:45:29 <Welkin> is that a spiderman pun?
14:45:41 <stick> it would just be another dependency, and this part is done already anyways, but thanks for suggestion
14:46:30 <stick> anyway, Either is an option, i was just wondering if you could have error without that annoying "%function%: %error%" error format
14:46:50 <kadoban> stick: Well, if you just want to make the minimal amount of changes to get it working based on your current code, I guess the stuff in 'safe' ending in Note is it. IMO not really the cleanest way to go, but it should work.
14:47:21 <kadoban> (for some value of "work") Make sure it outputs how you like before you get too into it I guess, I've never used them. I think they do what you want though.
14:47:54 <dpk-atk> hey
14:48:04 <dpk-atk> could someone give me an intuitive example of a comonad?
14:48:11 <MichaelBurge> mildfate: The closest thing to a canonical list of Haskell packages would be Stackage, actually.
14:48:56 <kadoban> Well, hackage or stackage, depending if you want more messy or more curated.
14:49:18 <MichaelBurge> mildfate: https://www.stackage.org/ . And you should probably be using stack to develop your program.
14:49:56 <Welkin> just use stack
14:50:03 <mildfate> MichaelBurge: Cool.  Is there a standard tut for using Stack?
14:50:04 <Welkin> I've since switched from doing it manually
14:50:25 <MichaelBurge> mildfate: http://docs.haskellstack.org/en/stable/README/
14:50:37 <mildfate> Sweet!
14:50:44 <Cale> dpk-atk: Let m be any monoid. (It might be best for intuition to let m really be a vector space or say, pairs of Integer coordinates, but really all we need is a Monoid structure)
14:51:16 <Cale> dpk-atk: Then take W a = m -> a
14:51:37 <Cale> dpk-atk: We have extract f = f mempty
14:51:56 <Cale> dpk-atk: and we have duplicate f = (\x y -> f (mappend x y))
14:52:55 <Cale> So what does this mean when m is 2D coordinates? Well, our comonad consists of functions which assign values to each point in the plane. The function extract :: W a -> a  will get the value at the origin
14:53:01 <MichaelBurge> dpk-atk: This article is pretty good for comonads: http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
14:53:21 <Cale> and the function duplicate :: W a -> W (W a) will get all the possible translations of the input function
14:55:27 <Cale> I think that's the best example comonad. You generally have some way of getting a value at an "origin" of some sort, and then you have some way to get a structure filled with "translated" versions of your original structure.
14:56:05 <Cale> What exactly it means to do this "translation" may vary
14:56:26 <Cale> and what the "origin" is might also
14:56:40 <dpk-atk> yeah give me a few min trying to grok this lol
14:57:54 <dpk-atk> so for your example
14:58:06 <dpk-atk> lets use the monoid of integers under addition
14:58:29 <dpk-atk> lets say we have W String
14:58:36 <dpk-atk> that means that
14:59:00 <dpk-atk> W (String) = a sum  mapped to a String?
14:59:52 <dpk-atk> extract (String) = mapping from 0 to String
15:00:23 <Cale> dpk-atk: A value of type W String would be a function Integer -> String
15:00:40 <Cale> and if f was such a function, then extract f = f 0
15:01:04 <Cale> and duplicate f = (\x y -> f (x + y))
15:01:21 <stick> okay, found what I wanted, it was unsafePerformIO $ putStrLn message >>= exitFailure
15:01:38 <Cale> (note that to actually write the instance, we'll need a newtype wrapper, but for discussion, we don't)
15:01:44 <kadoban> stick: ew
15:02:29 <__jklftedfr__> oooohh, so many people
15:02:31 <stick> i know, it's so evil
15:03:08 <__jklftedfr__> what evil
15:03:23 <Cale> __jklftedfr__: stick wrote something involving unsafePerformIO
15:03:47 <maerwald> let's hang him :P
15:04:27 <__jklftedfr__> ahh
15:04:33 <maerwald> is it for debugging?
15:04:44 <maerwald> there's Debug.Trace
15:04:50 <kadoban> stick: At some point, if it works for you, all's good, but ... I strongly suspect there has to be a less fugly way to accomplish what you're doing.
15:04:59 <stick> it's an alternative for "error" that doesn't print a function name where it failed
15:06:00 <stick> kadoban: yeah, if I wanted to do it cleanly, I'd use or something else instead
15:06:14 * hackagebot texmath 0.8.6.2 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.6.2 (JohnMacFarlane)
15:06:17 <stick> but all I needed was really just "error" minus that function part
15:16:44 * hackagebot acme-php 0.0.5 - The flexibility of Haskell and the safety of PHP  https://hackage.haskell.org/package/acme-php-0.0.5 (JoeQuinn)
15:16:46 * hackagebot BlogLiterately 0.8.2.1 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.2.1 (BrentYorgey)
15:16:48 * hackagebot sbp 0.52.2 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.52.2 (markfine)
15:27:09 <hseg> Hi. Is it possible to define a function local to a type class instance? e.g. consider class C a where { foo, bar :: ... } and foo and bar have some commonalities. Is it possible to extract these commonalities?
15:27:28 <hseg> Or must I make them module-global?
15:27:52 <Welkin> you have to define your functions for every instance
15:28:01 <Welkin> unless you have a default definition
15:30:13 <hseg> I'm expressing myself unclearly. Suppose foo=comp f, bar=comp g. Can I share the definition of comp for both foo and bar (by having some form of a common where-clause) without leaking this to the rest of the module?
15:30:32 <hseg> Come think of it, the typeclass is irrelevant here.
15:31:19 <hseg> Which makes my answer obvious. No, of course you can't do this - why on earth would two functions be able to share where clauses?
15:31:23 <hseg> Sorry for the noise.
15:32:43 <Lokathor> so Safe makes GHC prevent me from importing and using unsafe operations, and Trustworthy is when I want to use potentially unsafe things but I promise I'll be good about it?
15:35:56 <shlomocomputer> When I write this:
15:36:04 <shlomocomputer> main = putStr $ unlines $ map show $ head $ filter isSolution possibilities
15:36:13 <shlomocomputer> my program runs in 1 second.
15:36:17 <shlomocomputer> When I write this:
15:36:28 <shlomocomputer> main = putStr $ maybe "No solution!\n" (unlines . map show) $ find isSolution possibilitie
15:36:29 <shlomocomputer> s
15:36:39 <shlomocomputer> it takes 3 seconds.
15:37:04 <Lokathor> :t find
15:37:04 <hseg> shlomocomputer: Note that your first example only evaluates the head of the list.
15:37:05 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
15:37:05 <shlomocomputer> I am at a loss as to why.
15:37:54 <shlomocomputer> But find only finds one item of the list.
15:38:39 <Lokathor> perhaps... there's rewrite rules that fire in the first case that don't in the second case?
15:38:40 <shlomocomputer> Essentially, find and (head . filter) are the same, modulo safety.  Aren't they?
15:38:45 <hseg> Fusion?
15:39:01 <shlomocomputer> Hoogling...
15:39:19 <EvanR> @src find
15:39:19 <lambdabot> find p = listToMaybe . filter p
15:39:59 <hseg> haddocks say find p = getFirst . foldMap (\ x -> First (if p x then Just x else Nothing))
15:40:13 <shlomocomputer> find has newtype wrappers "First" and "getFirst"
15:40:21 <shlomocomputer> yep
15:40:37 <hseg> Can't be that it's not lazy enough...
15:40:38 <EvanR> ehm why?
15:42:12 <hseg> Because chasing enough definitions, this seems to reduce to foldr (\x acc -> if isSolution x then Just x else acc) Nothing
15:42:29 <shlomocomputer> filter has the NOINLINE pragma
15:42:33 <hseg> But that's assuming that GHC agrees with my quick-and-dirty reduction.
15:42:47 <shlomocomputer> thanks for the discussion gtg
15:42:54 <hseg> What?
15:44:09 <Lokathor> So.. with regards to Safe Haskell, if GHC says I can't import a module because it's not Safe, I can still mark my module as Trustworthy if I'm confident that nothing weird happens when using the API exported?
15:44:15 <Lokathor> is that correct?
15:44:44 <hseg> ... Maybe GHC can't see through the application of First to turn this into a tight loop? Will need to check Core to be sure.
15:48:56 <ezyang> Does anyone know if there is a way to add an explicit kind parameter to a data type without turning on TypeInType? 
15:50:52 <acertain> how can I compare KnownNats?
15:51:03 <acertain> and get evidence
16:06:06 <Shou> ezyang: DataKinds?
16:06:26 <ezyang> Shou: Well, I still want the kind to be * or something like that 
16:07:09 <ClaudiusMaximus> maybe KindSignatures
16:08:07 <OnkelTem> Hi all
16:08:17 <ezyang> I filed a ticket for it https://ghc.haskell.org/trac/ghc/ticket/11963#ticket 
16:09:17 <OnkelTem> Where does 'stack setup' download/install its stuff? I'm getting 'no space left on driver' and would like to change the location
16:09:47 <mgsloan> OnkelTem: https://github.com/commercialhaskell/stack/issues/996
16:10:10 <OnkelTem> mgsloan: thanks!
16:10:13 <mgsloan> Setting TMPDIR will fix the issue
16:10:29 <OnkelTem> reasonable
16:15:03 <kqr> i don't know if this is a weird question. I have a couple of IO actions on the form of `do { x <- checkX; if X then makeX else return () }` except for `X`, `Y`, `Z` and so on. so they do a check and then perform an action if the check was successful, otherwise they do nothing. I'd like to compose these in the style of alternative, so that `operationX <|> operationY <|> operationZ` will only do the first
16:15:05 <kqr> successful operation. is there something like this?
16:15:26 <thimoteus> is there some kind of canonical name for the type Monad m => a -> m b ?
16:15:47 <Iceland_jack> thimoteus: Kleisli arrow
16:15:49 <jle`> thimoteus: people usually informally call it a "monadic function"
16:15:52 <thimoteus> thanks
16:15:53 <Iceland_jack> :t Kleisli
16:15:54 <lambdabot> (a -> m b) -> Kleisli m a b
16:16:03 <jle`> but it is indeed a morphism in the Kleisli category formed by m
16:16:22 <jle`> and i'm assuming you mean (a -> m b) for some Monad m, not a forall m. Monad m => a -> m b
16:16:29 <OnkelTem> mgsloan: worked! :)
16:17:38 <jle`> but yeah, informally, functions like putStrLn, put, tell, etc. are often informally called 'monadic functions' ... typically in contrast with the equally informal notion of "non-monadic functions" -- a -> m b vs. a -> b
16:18:03 <jle`> if you go back a few years you'll find people calling them "impure functions", but that language has gone out of fashion
16:18:12 <jle`> (for good reason, too)
16:18:21 <hpc> it doesn't really mean anything, it's just a terminology shortcut in the same way (Double -> Double) would be called a math function
16:18:55 <jle`> mhm
16:46:41 <cheater> is roman cheplyaka here?
16:46:50 * hackagebot gnss-converters 0.1.7 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.7 (markfine)
16:48:06 <mgsloan> cheater: I don't think so, he'd probably have the nick roche or feuerbach
16:49:08 <mounty_> Hello, I'd like to ask about loggingT and filtering of log messages, with Persistent.  Start with:  updateDB = persistAction (insertBy somedata) mypool
16:49:34 <mounty_> Then you can send log messages to stderr with runStderrLoggingT updateDB
16:51:10 <mounty_> But let's say you want to filter out some noise:  runStderrLoggingT $ filterLogger (\src level -> LevelInfo <= level) $ updateDB
16:51:39 <mounty_> I'm doing that in my app. but it's still logging Debug stuff from the SQL statements.
16:58:22 <mounty_> I even tried just return False unconditionally from the filter function.
17:03:33 <cheater> mgsloan: thanks
17:34:08 <dmj> anyone have built or hosted ghcjs-dom docs that display the type signatures of the functions that would be used by ghcjs
17:35:37 <mgsloan> dmj: "stack haddock ghcjs-dom" should do the trick
17:35:57 <mgsloan> (if you aren't in a project, "stack haddock ghcjs-dom --compiler ghcjs"
17:39:39 <dmj> mgsloan: am I doing it wrong? http://lpaste.net/3343395516087009280
17:41:15 <dmj> mgsloan: stack haddock ghcjs-dom requires webkitgtk-3.x which I've never been able to get installed on OSX, I don't think that would produce the docs I'm looking for anyways, but I probably just fudged the command line syntax
17:41:25 <dmj> for --compiler ghcjs
17:41:53 <dmj> on stack version 1.0.4.1
17:44:11 <mgsloan> I guess it probably needs to be more like --compiler ghcjs-0.2_ghc-7.10
17:45:08 <dmj> mgsloan: it seems to be working :)
17:46:06 <mgsloan> Great!
17:46:26 <dmj> grepping the source was getting old :) 
17:46:35 <dmj> mgsloan: thanks a *lot* ! 
17:46:40 <mgsloan> welcome!
17:54:48 * hackagebot gnss-converters 0.1.7 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.7 (markfine)
17:54:48 * hackagebot Plot-ho-matic 0.9.0.7 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.7 (GregHorn)
18:08:45 <kqr> anyone have experience with brick? http://hackage.haskell.org/package/brick-0.5/docs/Brick-Main.html
18:09:01 <kqr> i'm trying to figure out how to perform IO actions based on things happening inside the brick main loop
18:14:03 <Rotaerk> is this for bricking a device
18:14:43 * hackagebot deriving-compat 0.2 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.2 (ryanglscott)
18:15:13 <jamesmcn1mara> \join #purescript
18:15:33 <kqr> oh never mind, EventM is a MonadIO
18:16:34 <kqr> that makes things a lot easier
19:09:35 <fr33domlover> Is there a way in Yesod to add a "Cache-control: no-cache" header other than through addHeader ?
19:09:45 * hackagebot katip 0.2.0.0 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.2.0.0 (MichaelXavier)
19:09:47 <fr33domlover> All the cache related functions do other things
19:09:47 * hackagebot katip-elasticsearch 0.2.0.0 - ElasticSearch scribe for the Katip logging framework.  https://hackage.haskell.org/package/katip-elasticsearch-0.2.0.0 (MichaelXavier)
19:18:10 <ntnt> anyone have "learn free monads the brutal way" ? I just want (1) the type signatures, and (2) lots of tedious boring examples that hammers home how ot use it
19:22:48 <nitrix> ntnt: I don't want to point fingers, but all the material from Zed. A. Shaw with titles "Learn X the hard way" were incredibly incorrect and misleading.
19:23:35 <nitrix> Ah, he's gone. I don't know why people are so obssessed with learning things "quickly" or "the hard way".
19:25:14 <thimoteus> i thought the hard way just meant by practice?
19:28:26 <wrengr_away> jophish: you called?
19:40:29 <fr33domlover> Q: If I define a string literal in my code (say String, or Text, or ByteString) and then I take its 'length', is GHC able to optimize and compute the length at compile time?
19:44:30 <dolio> It will most likely not do that.
19:45:29 <dolio> The only one that might have a chance is the byte string, but I still wouldn't expect it.
19:51:33 <michael1> -h
20:25:44 <ntnt> do classics like http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672 apply to haskell, or does haskell refacotinr gowrk entirely differently due to purity ?
20:26:24 <mmercer> is haskell a good choice for web development? or is a more dynamic language more appropriate
20:26:37 <ntnt> snapframework is awesome
20:26:45 <dmj> ntnt: refactoring is made possible via the strong static type system in haskell, and equational reasoning
20:26:55 <ntnt> mmercer: look into http://snapframework.com/
20:27:02 <dmj> mmercer: I'd never go back to using a dynamic lang for web dev
20:27:03 <mmercer> thanks
20:27:06 <ntnt> mmercer: I thought web dev was stupid until I started using snap, then everythin gamde sense
20:27:22 <Lokathor> mmercer, for backend stuff, haskell can hardly be beat i think
20:27:40 <Rotaerk> there's also ghcjs-dom
20:27:46 <ntnt> there are days I want to use erlang for the backend
20:27:49 <dmj> yea web dev is meaningless w/o types (as is most things)
20:27:55 <ntnt> but these days, unless ghc is there to tell me "your program type checks", I just ahve this uneasy feeling
20:28:35 <mmercer> nice.. thanks for feedback. i'll give snap framework a try
20:28:37 <Lokathor> ntnt, i think that the book you linked to is less likely to apply to haskell. A lot of OO books/talks just sorta fall flat when you're not going with OO and OO patterns
20:29:01 <dmj> OO was a good idea at the time
20:29:01 <ntnt> Lokathor: I do get that impression too
20:29:13 <ntnt> it seems like without OO and without method calls, alot of 'standard refactoring' no longer applies
20:29:46 <Lokathor> that's why you should uncurry all functions, and you should write your funcions infix
20:30:00 <Lokathor> data `someFunc` (arg1,arg2) -- like this
20:31:27 <ntnt> Lokathor: that's bloody brilliant; should I also make everything IOVar, i.e. instead of data Student = Student { name :: String; id :: Int }, I shoul dinstead make it data Student = Student { name :: IOVar String, id :: IOVar Int } -- because how else can I get mutable state ?
20:31:52 <ntnt> and I should never use any pure functions, because "a -> IO b" is strictly more powerful than "a -> b"
20:31:56 <ntnt> so everything should be IO-ed
20:32:07 <Lokathor> the trick is that once you have your fields as IOVar, you should ALSO store the value itself in an IOVar, so that you get maximum mutability
20:33:22 <MichaelBurge> Is there a way to use GHC 8 with an older version of base?
20:33:32 <c_wraith> no
20:33:41 <c_wraith> GHC versions are hird-wired with their specific version of base
20:33:45 <c_wraith> *hard-wired
20:34:20 <MichaelBurge> Can you have multiple bases in scope at any given time?
20:34:36 <MichaelBurge> So GHC 8 could use its newer base, but I'd compile everything with an older base
20:34:40 <c_wraith> No.
20:34:44 <c_wraith> It's hard-wired.
20:34:51 <c_wraith> Not just compiled against it.
20:34:57 <c_wraith> But it generates code against it, too.
20:35:22 <c_wraith> Things like Typeable tend to change basically every release (in inner details)
20:35:36 <c_wraith> and GHC has code wired in to generate Typeable instances
20:35:47 <MichaelBurge> That's a little surprising actually. I would've expected the GHC.* namespace to be completely hardwire, with primitives like Int# and lots of magic.
20:35:58 <MichaelBurge> But things like Prelude or Data.List don't need to be hardwired
20:36:09 <MichaelBurge> Maybe Monad does
20:36:10 <c_wraith> Even Prelude does, to some expent
20:36:14 <c_wraith> *extent
20:36:50 <c_wraith> Things like the applicative-monad merge required changes to GHC
20:38:05 <MichaelBurge> That's too bad. I was hoping to get a particular bugfix that was making my generic instances take a huge amount of memory.
20:38:48 <c_wraith> GHC 8 isn't production-ready anyway
20:39:03 <c_wraith> It has one more RC planned before it's even close to production-ready
20:39:14 <c_wraith> It shouldn't be a surprise that it doesn't work right sometimes. :)
20:39:32 <MichaelBurge> Oh, the bug in question was I think even in GHC 7.4
20:39:35 <MichaelBurge> but the fix is scheduled for 8
20:41:55 <c_wraith> GHC isn't great about backporting fixes to old issues.  You could argue there's a real need for it, but so far there aren't enough developers to make it happen.
20:46:59 <ggVGc> out of the 7 programmers using haskell, only 5 work on GHC
20:49:52 <kadoban> Is that really true? What do the rest use? UHC or some in-house thing?
20:50:17 <ntnt> wow; there's other haskell implementations?
20:50:21 <ntnt> only 5/7? that seems low
20:50:41 <Lokathor> the other two use GHC but don't work on it
20:51:08 <matt-> freeloaders
20:51:15 <ntnt> oh; I'm definitely in the uses ghc but does not contrib to ghc camp
20:51:23 <kadoban> If that's what's being measured, it seems *way* high. No way 5/7 haskellers work on GHC.
20:51:45 <matt-> I think ggVGc was joking that there are only 7 people that use Haskell.
20:52:02 <MichaelBurge> I know one of the banks that employs Haskellers has their own in-house Haskell compiler
20:52:15 <ntnt> you mean ermine and standard chartered?
20:52:23 <MichaelBurge> I might
20:53:10 <ntnt> https://github.com/ermine-language isn't private info, in fact, it's a public github repo :-)
20:55:28 <kadoban> ermine is like some fork of haskell or something? Odd.
20:58:27 <c_wraith> ermine is edwardk's near-haskell on the JVM
20:58:48 <mildfate> Hi all, I installed cabal-install (not knowing what I was doing) and with it "cabal installed" wreq.  Then, after learning about stack, I uninstalled cabal install and "stack installed" wreq.  I thought that it would recognize the already installed package, but it didn't.  Which leads me to believe that I have two different installations of wreq somewhere.  How do I find and get rid of the one cabal installed?
20:59:10 <cheater> matt-: off by one error
20:59:14 <c_wraith> mildfate: look in ~/.ghc
20:59:22 <MichaelBurge> mildfate: Cabal probably installed it in your home directory, while stack stores it in a directory underneath your project
20:59:35 <MichaelBurge> They shouldn't conflict with each other if you're using stack to build the project, so you might just forget about the cabal one
20:59:37 <ggVGc> you guys reckon it would be possible to have decent execution speed of haskell without the inlining of everything?
20:59:49 * hackagebot purescript 0.8.5.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.8.5.0 (PhilFreeman)
21:00:03 <ggVGc> resulting in the huge file sizes of any haskell dev
21:00:09 <c_wraith> ggVGc: No.  Indirection is slow, and without inlining, there would be a *lot* of it.
21:00:17 <cheater> that is a question without value tbh
21:00:25 <kadoban> mildfate: stack and cabal have totally separate package databases. Also, in stack, 'stack install somelibrary' doesn't tend to make a lot of sense. You just specify it as a dependency in the cabal file of whatever project you're writing and then stack will build it when it needs to. Or if you're using it outside of a package context, you just do 'stack ghci -package wreq' for instance.
21:00:27 <ggVGc> c_wraith: it's a bit of a shame though isn't it :(
21:00:27 <mildfate> c_wraith: What should I be looking for?
21:00:28 <cheater> what's "decent"? at what load? doing what?
21:00:41 <MichaelBurge> ggVGc: I don't think so - the assembly that gets emitted with actual function calls is pretty indirect, so there'd be a lot of jumping around.
21:00:41 <matt-> cheater: oops
21:00:49 <c_wraith> mildfate: well, stack doesn't use anything inside ~/.ghc
21:01:21 <MichaelBurge> ggVGc: I wonder if you can use the FFI to invoke Haskell-Haskell, just to put an optimization fence up
21:01:26 <kadoban> MichaelBurge: 'stack install blah' is for executables. It builds the thing and then copies the executables to ~/.local/bin  . if there's no executables, it ... doesn't really make a ton of sense to do that.
21:01:32 <kadoban> mildfate: ^
21:01:42 <dolio> A compiler could do better than GHC does at non-inlined functions.
21:02:04 <dolio> In some sense, at least.
21:02:33 <ggVGc> I wish we could come up with a pure functional language that can compile to a simpler runtime environment
21:02:44 <ggVGc> I think that's a pretty big issue in the adoption of haskell
21:03:05 <c_wraith> It is?
21:03:23 <MichaelBurge> ggVGc: I don't actually know this, but I imagine Core or STG only call out to the runtime as some abstract foreign interface.
21:03:38 <ggVGc> c_wraith: a lot of cabal hell is because of the hig demands of dependencies for haskell, because of all the inlining. Depending on specific compiler versions etc.
21:04:17 <ggVGc> MichaelBurge: I didn't mean just the actual RTS. I meant "runtime environment" as in "the demands on the environment for any given haskell program to run"
21:04:21 <ggVGc> i.e for C it's very simple
21:04:23 <mildfate> c_wraith: Should I empty everything inside ~/.ghc?
21:04:48 <c_wraith> I haven't seen a cabal hell problem that wasn't caused by either very poor decisions (yesod) or intentionally messing up your environment in about 5 years.
21:05:15 <MichaelBurge> I don't know about 5 years, but recently stack does make it more convenient to escape Cabal hell.
21:05:31 <ggVGc> sure, stack is a different beast. but it's only a patch over the core problem really
21:05:32 <c_wraith> stack is the workaround to using yesod.
21:05:33 <matt-> c_wraith: Is Yesod popularly considered a bad decision?
21:05:35 <MichaelBurge> Sandboxes also used to satisfy that, though you ended up recompiling alot
21:05:43 <ggVGc> my stack dir is till 6gb for fairly simple projects
21:05:44 <YellowOnion> Does anyone here use ghci with bash on windows? and know how to get it to play nice?
21:05:57 <mildfate> c_wraith: I'm going to assume "yes, I should empty my ~/.ghc folder"
21:06:09 <c_wraith> mildfate: well, you can.  If the space savings matter.  leaving them doesn't hurt anything if the space doesn't matter.
21:06:10 <kadoban> c_wraith: I've never used yesod. stack still saves me tons of time. It helped eliminate the biweekly "welp, cabal-install is fucked up again, time to nuke the world and reinstall everything again" loop.
21:06:50 <ggVGc> kadoban: that's exactly what I mean, because of the narrow demand of compiled haskell
21:06:54 <ggVGc> demands*
21:06:57 <matt-> I'm just starting out. stack has certainly made things easier.
21:07:05 <kadoban> And it only became as rare as biweekly once I figured out sandboxes. Before that it was pretty much just constantly broken to various degrees, it was just a matter of how annoyed I had to be before I spent the time.
21:07:17 <MichaelBurge> c_wraith: I usually see Cabal hell when I iteratively add dependencies to a project, and it ends up stuck unable to satisfy them unless rerun the resolver from scratch with a clean slate.
21:07:45 <MichaelBurge> You don't see it with a plain project that has everything sorted out, but you do while developing.
21:07:54 <ggVGc> so, all of this is why I reckon simpler runtime demands would be beneficial for haskell adoption
21:08:08 <c_wraith> Cabal's plan is a much better approach.  It just needs to get finished. :)
21:08:30 <Lokathor> there are many copies, and they have a plan?
21:10:10 <monochrom> haha
21:12:41 <ezyang> It's nearly finished. Here's the draft announce: https://github.com/ezyang/cabal/blob/pr/nix-announce/nix-announce.rst 
21:12:49 <c_wraith> ezyang: awesome.
21:13:13 <ezyang> At this point I'm waiting for 1.24 release, then we'll publicize this widely 
21:13:22 <mildfate> I've stack installed wreq, how do I add it as a dependency to my project?
21:13:24 <dmj> ezyang: bravo
21:13:43 <Lokathor> mildfate, put it in your project.cabal file as a dependency
21:13:47 <mac10688> what is the stack channel? I tried /join #stack
21:13:59 <Lokathor> mac10688, #haskell-stack
21:14:10 <mac10688> Thanks Lokathor you are the man
21:14:24 <mildfate> Lokathor: Whaaaatt
21:14:30 <mildfate> I thought I wasn't supposed to use cabal>
21:14:31 <mildfate> ?
21:14:42 <Lokathor> mildfate, stack still uses the same cabal file format
21:15:20 <Cale> Yeah, stack is an alternative to the cabal-install tool, not the Cabal library
21:15:21 <Lokathor> internally, it uses the Cabal library, which is different from cabal-install the binary, which is named and referred to as "cabal" on its own 97% of the time; it's terrible and confusing, but that's how it is
21:15:35 <mildfate> christ ok
21:15:53 <Lokathor> so you'll still make a project.cabal, and you'll have a stack.yaml too
21:16:59 <c_wraith> ezyang: it might be worth a note early on that it uses ideas from Nix, but not Nix itself
21:17:33 <mildfate> So I've added wreq to the build-depends attribute of the executable block.  Now when I run "stack repl" how do I get access to the wreq lib?
21:18:06 <c_wraith> mildfate: import the module you need
21:18:14 <MichaelBurge> mildfate: You should be able to type 'import ...' where ... is a module in the wreq documentation
21:18:24 <simpson> ezyang: So, IIUC this is reinventing Nix?
21:19:39 <mildfate> c_wraith, MichaelBurge: Yay! Got it!
21:19:43 <mildfate> Thanks all!
21:21:23 <mildfate> What the eff is this, "No instance for (Data.String.IsString (IO t0)) arising from the literal ‘"http://httpbin.org/get"’ "
21:21:46 <c_wraith> mildfate: it means you enabled the OverloadedStrings extension
21:21:56 <MichaelBurge> mildfate: You did something equivalent to 'main = "hello"'
21:22:05 <mildfate> That's what they say to do in the wreq tutorial
21:22:15 <c_wraith> mildfate: without that extension, you'd be getting an error message saying [a] isn't the same as IO a
21:22:53 <mildfate> c_wraith: Wait wait, my project builds with "stack build"
21:23:08 <mildfate> I'm in the repl, at first *didn't* use overloaded strings and got the error
21:23:19 <mildfate> then set overloaded strings and am continuing to get the error
21:23:52 <mildfate> Sorry, not the same error
21:24:12 <mildfate> First one was "Couldn't match expected type ‘IO t0’ with actual type ‘[Char]’ In the first argument of ‘GHC.GHCi.ghciStepIO :: IO a_a64D -> IO a_a64D’, namely"
21:24:38 <mildfate> Next was the Data.String.IsString one
21:24:41 <MichaelBurge> mildfate: If it helps at all, I happen to be working on code that uses wreq right now. Maybe if I show this it'll help you: https://github.com/MichaelBurge/haskell-authorize-net/blob/master/src/Network/AuthorizeNet/Api.hs
21:24:47 <c_wraith> mildfate: the underlying cause is most likely that you have a string-valued expression as a statement in an IO block
21:24:50 <MichaelBurge> look at makeRequest to see the actual call with wreq
21:25:14 <ezyang> simpson: It's not reinventing if you know about it! 
21:25:18 <ezyang> c_wraith: Gotcha 
21:25:31 <SQLNoob> hey can anyone get me an invite into #programming?
21:25:32 <mildfate> MichaelBurge: I can't read that yet :/
21:25:34 <SQLNoob> I needed some help :(
21:26:07 <mildfate> I have "main = someFunc" and "someFunc = putStrLn "someFunc""
21:26:11 <c_wraith> ezyang: there's probably an unfixable additional known issue of libraries that use TH to compile environmental details that change into themselves. 
21:26:30 <doubling> SQLNoob: you can't just invite a stranger
21:26:41 <doubling> you have to be the son of a #programming member
21:26:41 <SQLNoob> good point doubling
21:26:46 <doubling> or save the life of a #programming member
21:26:47 <simpson> ezyang: I mean, it sounds like this won't actually interact with the Nix store?
21:26:49 <SQLNoob> can you be my father?
21:26:52 <ezyang> simpson: No. 
21:27:02 <ezyang> c_wraith: Yes, alas. 
21:27:25 <simpson> ezyang: That's unfortunate. We've been making our Monte tooling interact directly with Nix, and it's been a rewarding experience.
21:27:27 <c_wraith> ezyang: I'm pretty sure it's unfixable, but it would be handy to document it.
21:28:26 <ezyang> simpson: It certainly would be an interesting project, but it would be only helpful for the enlightened few who actually use Nix ;) 
21:29:01 <simpson> ezyang: Ah. We just said that people have to use Nix. If they insist on luddism, they can have a Docker image or whatever the kids are using these days.
21:29:34 <c_wraith> mildfate: is your short enough to easily be put on lpaste.net ?  This seems easiest to diagnose seeing actual code.
21:30:13 <c_wraith> simpson: luddism or whatever the kids are using these days? :P
21:31:03 <simpson> c_wraith: Pretty much.
21:31:19 <Lokathor> I heard a complaint the other day that people like cabal over stack because they want to just install a package and try it out and they can't do that with stack
21:31:23 <Lokathor> but you can do that with stack
21:31:32 <Lokathor> so i'm confused by what they even meant by that
21:32:21 <MichaelBurge> Lokathor: Certainly you can with executables. For libraries, don't you have to set up a new project that is managed by stack?
21:32:30 <Lokathor> nope
21:32:32 <Lokathor> stack install random
21:32:34 <Lokathor> stack ghci
21:32:37 <Lokathor> import System.Random
21:32:53 <MarcelineVQ> stack ghci --package random
21:32:56 <c_wraith> Lokathor: what does that do if you don't have a stackfile?
21:33:18 <Lokathor> it puts random in your "global project", and then you can use System.Random in ghci
21:33:22 <MichaelBurge> I think it uses your personal global stackfile, and installs it into a place like ~/.stack
21:33:27 <Lokathor> MarcelineVQ, i didn't need to use a flag with stack 1.0
21:33:48 <MarcelineVQ> you don't need to install was the point of that line
21:33:53 <Lokathor> oh, i see
21:34:09 <MarcelineVQ> I think mpickering showed me that one, it's a little hidden :X
21:34:09 <Lokathor> that's why they pay you the big bucks
21:34:40 <Lokathor> MarcelineVQ, i got a 500x speedup by cutting out monadic and lazyness overhread, it was cool
21:35:16 <MarcelineVQ> that's cuz you keeping implementing imperative algos
21:35:54 <Lokathor> the PCGen doesn't modify a single variable in place! it's all functional! honest coppa!
21:36:07 <MarcelineVQ> well, strict maybe a better term, you need to get all lazy and shit
21:36:26 <Lokathor> lazyness is what makes it take 770ms instead of 1.5ms
21:36:32 <MarcelineVQ> quit working so hard man, just give up and sleep all day like me
21:36:33 <Lokathor> :P
21:36:36 <mildfate> If I install a package with stack install, open a stack repl, and attempt to import a module from that package, will it not work unless I've declared that package in the build-depends attribute of my project?
21:37:00 <Lokathor> mildfate, if you're within a project's directory, you must have the dependency of your project before ghci opens, yes
21:37:30 <mildfate> hmm k
21:37:38 <Lokathor> if you add the dependency after you use "stack ghci", it won't be able to reconigure ghci while it's running, so just close ghci and open it up again
21:37:44 <mildfate> what if I want to use a dependency of an already declared package in the stack repl?
21:38:17 <Lokathor> IIRC, if you want to explicitly use a depended upon package you'll also need to add that to your file
21:38:22 <mildfate> That is, I've declared a dep. on wreq which has lens as a dep.  I want to use lens—do I need to declare a dep. on lens?
21:38:25 <mildfate> kk
21:38:35 <mildfate> This shit is complicated
21:38:41 <mildfate> I just want to mess around in the repl!
21:38:51 <Lokathor> ~reproducable builds~
21:38:57 <Lokathor> ~enterprise software~
21:39:34 <Lokathor> MarcelineVQ, also my game lib does cave generation now. it makes caves that are pretty nice to look at, but horrendusly slow to look at (like 2s for 200x200)
21:39:43 <Lokathor> er, slow to generate, i should say
21:41:26 <Lokathor> maybe you could rewrite it more functionally and get a speed boost
21:41:48 <Lokathor> using GADTs, and arrows, and FRP data kinds families multiparamater functor binds
21:42:41 <MarcelineVQ> maybe, you should check out noise algos though, there's lots of gpu's gems for them for example since noise is really useful for texturing games, might be a better fit than your flood-fill implentation
21:43:35 <Lokathor> well this particular generator is automata based, and the flood fill is just a check at the end to ensure connectivity. I'll add other generators in the future as well
21:44:40 <Lokathor> the trouble is, to get good looking results, I check all cells at range 1 and then usually all cells at range 2 as well, for each cell, of each pass
21:44:47 <Lokathor> just takes so much time
21:45:54 <Lokathor> I know I can make it faster by specializing the loop more though, I just gotta spend some time to do it. perhaps on the weekend
21:46:30 <c_wraith> 200x200 isn't big enough to be that slow, even with all that work.  There must be room for more cleverness.
21:46:37 <mildfate> What's the order of operations in the following expression: param "foo" .~ ["bar", "quux"]
21:47:00 <Lokathor> mildfate, param accepts "Foo", then .~ uses that and the list
21:47:02 <mildfate> Does .~ capture "foo" and the list first?
21:47:08 <mildfate> oh ok
21:47:21 <Lokathor> prefix application always trumps infix application
21:47:36 <kadoban> mildfate: Function application is always highest, so start there. But a function can't take an operator as an argument like that, so it must break there.
21:47:42 <mildfate> is "param" a lens or "param "foo""?
21:47:53 <c_wraith> mildfate: the order of operations is as demanded, which isn't based on syntax, really. You're really asking about how it's parsed, not the order the operations happen in.
21:48:00 <doubling> http://i.imgur.com/Vbsldvb.jpg
21:48:08 <c_wraith> mildfate: the latter
21:48:25 <c_wraith> mildfate: param is a function that produces a lens
21:48:59 <mildfate> so .~ takes a lens and a value and gives you a function that given a structure will set the lens to that value
21:49:08 <c_wraith> yes
21:49:41 <Lokathor> c_wraith, if you have a moment and care to browse, it's a mostly self contained module, https://github.com/Lokathor/ludolib/blob/master/src/Util/AutomataGen.hs
21:49:50 <c_wraith> > _1 .~ 10 $ (3, "hello")
21:49:52 <lambdabot>  (10,"hello")
21:49:55 <c_wraith> mildfate: ^
21:50:50 <mildfate> whoooooooah
21:50:58 <c_wraith> mildfate: _1 is a lens that targets the first element of a tuple
21:51:33 <Lokathor> it's pretty magic, but i'm pretty sure that edk is a good witch and not a bad witch, so it's okay
21:51:34 <mildfate> so the function param creates a lens out of a name?
21:52:38 <mildfate> > (.~) _1 10 $ (1, "a")
21:52:40 <lambdabot>  (10,"a")
21:53:08 <Lokathor> yeah kinda, _1 gives the location, .~ says what to do with it (replace), 10 is the new value that gets swapped in, then that whole thing gets applied to a particular tuple
21:53:24 <mildfate> > (.~) _1 10 (1, "a")
21:53:25 <lambdabot>  (10,"a")
21:53:34 <kadoban> I should really spend some time learning lens sometime soon ... so lazy.
21:53:50 <Lokathor> > _2 .~ "meow" $ (23,45)
21:53:52 <lambdabot>  (23,"meow")
21:54:03 <mildfate> that changed the type though, is that ok?
21:54:22 <Lokathor> yes, GHC will follow the types as you go
21:54:50 <Lokathor> it's not ultimately very differnet from how show takes some value and gives a String
21:55:06 <Lokathor> > show 24
21:55:07 <lambdabot>  "24"
21:55:08 <mildfate> In the repl, what's the difference between using "let =" and "<-"?
21:55:25 <Lokathor> let is for non-monadic things
21:55:40 <Lokathor> left arrow is for assigning results of IO actions
21:55:48 <mildfate> gotcha gotcha
21:55:52 <Lokathor> because the repl is *kinda* like doing things inside a giant IO do block
21:58:07 <Lokathor> c_wraith, i think i just need to make caveCopy faster
21:59:01 <mildfate> is it bad practice to turn infix operators into prefix operators?  I find it easier to parse
21:59:06 <mildfate> in my head
21:59:17 <Lokathor> naw it's totally fine
21:59:28 <Lokathor> i make prefix things into infix when it reads better all the time
21:59:59 <Lokathor> mid = VM.length vec `div` 2, and so on
22:00:36 <c_wraith> Lokathor: oof.  I'd be tempted to rewrite the code using repa and stencil convolutions, just to make it more declarative.  I might be...  foolish. :)
22:01:20 <Lokathor> I've heard of accelerate and GPU stuff, but i got the impression that you had to be doing really simple operations and memory access to get good gains there
22:01:27 <noffle> absolute newbie here. I'm trying to puzzle out why 'zip [1] "a"' yields (1, 'a'), but 'zip [1 2] "ab"' produces an error (which I am not yet able to decipher)
22:01:33 <kadoban> mildfate: It's a little funky, you should probably learn to do without when you can.
22:01:36 <noffle> isn't "ab" :: [Char]?
22:01:38 <c_wraith> Lokathor: well, repa isn't GPU stuff. :)
22:01:44 <Lokathor> noffle, try [1,2]
22:02:02 <MarcelineVQ> Lokathor: nah the hitch is that the time spend copying the data back and forth between ram and vram needs to be worth it
22:02:11 <noffle> oh gah, why did I think you could skip commas
22:02:11 <jle`> > zip [1,2] "ab"
22:02:12 <lambdabot>  [(1,'a'),(2,'b')]
22:02:13 <MarcelineVQ> So if anything larger coimputations is better
22:02:26 <kadoban> noffle: [1 2] is ... apply the argument to to the function 1 (which ... you probably understand why that doesn't work) and then make it a one-element list.
22:02:39 <noffle> kadoban: that makes sense
22:02:41 <kadoban> s/the argument to to/the argument 2 to/
22:02:57 <Lokathor> MarcelineVQ, hmm, I'll have to review the book
22:03:01 <Lokathor> c_wraith, what's repa then?
22:03:03 <noffle> thanks
22:03:40 <MarcelineVQ> Lokathor: http://chimera.labs.oreilly.com/books/1230000000929/ch05.html :>
22:04:41 <MarcelineVQ> Lokathor: coincidentally folowed by http://chimera.labs.oreilly.com/books/1230000000929/ch06.html
22:04:51 <Lokathor> oh that's absolutely the book i was talking about
22:05:10 <Lokathor> but first time around i kinda skimmed that and focused on TVar MVAr stuff
22:09:28 <mildfate> How do I go from Data.Text.Internal.Text to Data.String.IsString?
22:10:18 <Lokathor> hmm
22:10:40 <Lokathor> unpack converts Text to String, i suppose that might be the most direct
22:12:52 <jle`> Data.String.IsString is a typeclass
22:12:59 <liste> mildfate: Text already is IsString, or did you want to convert to some other/any IsString?
22:13:14 <Lokathor> oh IsString >_>
22:13:18 <liste> mildfate: you'll probably want -XOverloadedStrings
22:14:20 <mildfate> I'm following the wreq tut http://www.serpentine.com/wreq/tutorial.html.  I've already set OverloadedStrings.  Under "Changing default behaviors" they list a way to construct a url from a previous response.  I've stored that new url to a local var and I'm trying to perform another "get" on it, but it's erroring out
22:14:24 <jle`> mildfate: it doesn't quite make sense to turn a type into a typeclass
22:14:44 <jle`> what's the error?
22:14:57 <Lokathor> mildfate, you should probably lpaste the section and the error
22:15:58 <mildfate> http://pastebin.com/ck7f5iSH
22:16:39 <mildfate> my bad, http://lpaste.net/160907
22:17:00 <Lokathor> ah, try: get (unpack url)
22:17:19 <jle`> mildfate: it's expecting a String, but you gave it a Text
22:18:05 <jle`> @hoogle Text -> String
22:18:06 <lambdabot> Data.Text.Internal.Lazy showStructure :: Text -> String
22:18:06 <lambdabot> Data.Text.Internal showText :: Text -> String
22:18:06 <lambdabot> Data.Text unpack :: Text -> String
22:18:07 <Lokathor> unpack is from Data.Text, it turns Text into String. Note that ByteString also has an unpack, so a lot of the time if you're using both in the same module you'll have to specify
22:18:10 <mildfate> what the eff?
22:18:19 <mildfate> Why this crazy conversion? it looks like a string
22:18:28 <kadoban> The *only* thing that OverloadedStrings does is make it so string literals in your code can be used as any IsString instance.
22:18:42 <kadoban> mildfate: Because they're different types, they work differently.
22:18:50 <mildfate> :|
22:18:57 <jle`> mildfate: 'r' returns a Text
22:19:09 <jle`> er, r ^. responseBody . key "url" . _String does
22:19:31 <jle`> i think you can convert it to a 'String' outright in your lens
22:20:22 <jle`> you can do 'r ^. responseBody . key "url" . _String . unpack maybe
22:20:28 <jle`> er, s/unpack/unpacked
22:21:05 <mildfate> Do I need to "import Data.Text (unpacked)"?
22:21:12 <mildfate> it says I don't have Data.Text
22:21:18 <jle`> unpacked is from Data.Text.Lens
22:21:47 <Lokathor> annoying that _String returns a Text and not String
22:21:57 <jle`> yes that's rather unfortunate heh
22:22:38 <mildfate> Is it more common to use Text or String?
22:22:52 <jle`> Text is probably the data type we'd all be using if we had the choice
22:23:02 <liste> mildfate: yes, Text has much better performance
22:23:13 <mildfate> then we'd hope that "get" took a Text instead of a String?
22:23:17 <jle`> but everything in the base library uses String unfortunately, so a lot of other things ues String
22:23:24 <jle`> yes, we'd hope that get took a Text
22:23:26 <mildfate> ..jesus
22:23:52 <Lokathor> haskell's Text acts like Python/Java/Rust/Etc strings, a fixed block of glyphs in memory. String is a list of characters, and might even be infinite
22:24:11 <Lokathor> because any list can be infinite and all
22:24:13 <jle`> yeah, String is basically a char-by-char stream/iterator
22:24:24 <jle`> sometimes you want a char-by-char iterator, but ... probably not often
22:24:28 <mildfate> String is an alias for list of chars, right?
22:24:28 <Lokathor> here's hoping for GHC 9
22:24:32 <Lokathor> right
22:24:56 <jle`> one nice thing about String is that you can use 'fmap' on it, i suppose, but who fmaps strings
22:25:05 <jle`> (answer: some people do)
22:25:17 <liste> mildfate: yes
22:25:25 <Lokathor> > toLower <$> "HAHAHA"
22:25:27 <lambdabot>  "hahaha"
22:25:35 <jle`> but yeah, it doesn't really make sense for 'get' to use String
22:25:40 <jle`> s/use/take
22:26:02 <mildfate> So I'm using wreq to make GET requests, what should I be using to parse HTML?  I want to be able to get contents of tags in a similar way to jquery
22:27:18 <mildfate> tagsoup?
22:27:48 <Lokathor> you know i went to do a thing like you're doing recently, and i gave up and just pre-parsed it all into a text file
22:27:56 <Lokathor> now my bot reads from that file instead
22:28:05 <mildfate> dl'd into a text and then parse it?
22:28:12 <mildfate> Why is that better?
22:28:30 <Lokathor> well it was just the lts database, which doesn't update, so i could just pre-parse it all
22:28:34 <Lokathor> lts system.random
22:28:37 <Lokathor> ireniko, lts system.random
22:28:38 <ireniko> random-1.1: https://www.stackage.org/haddock/lts-5.5/random-1.1/System-Random.html
22:29:01 <mildfate> Its database?
22:29:17 <Lokathor> the haddock database
22:29:42 <Lokathor> https://www.stackage.org/lts-5.5/docs
22:30:32 <Lokathor> since the content i need doesn't update over time, i could just rip it all once and make a file for it.
22:30:54 <Lokathor> depending on what you want your program to do, that's probably not possible, if you want anything that changes over time
22:35:54 <mildfate> I'm surprised there's not some sort of "url builder" type in wreq
22:36:12 <mildfate> like, what if I want to change the scheme or port of a given url?
22:37:18 <Lokathor> i'm... not as shocked
22:37:46 <Lokathor> that's what pull requests are for! :333
22:45:34 <ntnt> I feel like (1) I have a solid understanding of Haskell and (2) my haskell *design* desicisions are junk
22:45:44 <ntnt> are there good screencasts of haskellers with good design that I can watch as they code ?
22:46:00 <Lokathor> live? i don't know
22:46:15 <ntnt> recordings are fine
22:46:16 <Lokathor> there are videos of people coding on youtube, usually archives though
22:46:28 <ntnt> are any of them haskell masters ?
22:46:42 <Lokathor> yeah, well, i guess the problem is that good code isn't sprung upon the world
22:46:57 <Lokathor> usually you have to iterate on it slowly just like any other language until you find the right design
22:47:13 <MarcelineVQ> there's this whole hackage thing I hear has some good code on it
22:47:18 <Lokathor> :3c
22:47:35 <Lokathor> ntnt, what is your area of interest?
22:47:53 <ntnt> MarcelineVQ: I heard there's subsequences of pi that also contain beautiful haskell code
22:48:08 <ntnt> Lokathor: I find myself productive in haskell up until about 3-4k LOC
22:48:18 <ntnt> then I seem to hit some type of wall, where the code no longer fits in my head or something
22:48:26 <ntnt> I think this is due to bad design
22:48:59 <Lokathor> ntnt, then i would start with taking a large project you have, and then look hard at it, and see where you like it and where you don't
22:49:20 <Lokathor> then think about the skills you have with haskell, and how you could make the exact same project better if you applied one of them more
22:49:53 <Lokathor> such as adding in a Reader to help keep things organized
22:50:38 <Lokathor> or re-writing parts to be less specific about the types involved, so that you know they're not looking inside data they shouldn't
22:51:21 <ntnt> Lokathor: this is surprisingly good advice
22:51:23 <Lokathor> it's like a workout, but for your brain. When a part gets hard that's the part you gotta exercise more (as long as you're not injuring yourself)
23:24:01 <angerman> does anyone have a python bytestring (b'...' and b"...") :: String -> ByteString parser?
23:26:47 <lpaste> nocturne777 pasted “gadts” at http://lpaste.net/160908
23:27:06 <nocturne777> is it overkill to use GADTs the I way I do in the pasted example ?
23:27:28 <mildfate> How do I turn a list of IOs into an IO of a list?
23:27:38 <Lokathor> :t sequence
23:27:39 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
23:28:07 <nocturne777> one could also use multiple ADTs to have the same kind of strong guarantees as well
23:28:14 <Lokathor> also note
23:28:17 <Lokathor> :t sequence_
23:28:18 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
23:28:25 <mildfate> heyo that's a cool function
23:29:21 <mildfate> I don't know how sequence works but it does what I need!
23:30:11 <Lokathor> sequence gives you the list of results of each action back
23:30:20 <Lokathor> sequence_ throws out the list for you
23:30:33 <Lovepon> :t mapM_
23:30:34 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
23:30:36 <Lovepon> :t mapM
23:30:37 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
23:30:42 <Lovepon> :t mapM_ id
23:30:43 <lambdabot> (Monad m, Foldable t) => t (m b) -> m ()
23:30:48 <Lovepon> Oh cool.
23:31:02 <Lovepon> :t mapM id
23:31:03 <lambdabot> (Monad m, Traversable t) => t (m b) -> m (t b)
23:31:07 <Lovepon> :t sequence
23:31:08 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
23:31:14 <Lovepon> I see. TIL.
23:31:33 <Lokathor> Lovepon, you can also PM lambdabot to get info about stuff if you like
23:31:49 <Lovepon> Lokathor: Yeah.
23:33:42 <srhb> mildfate: It's basically sequence (a:as) = x <- a; xs <- sequence as; return (x:xs)
23:35:25 * hackagebot testing-feat 0.4.0.3 - Functional Enumeration of Algebraic Types  https://hackage.haskell.org/package/testing-feat-0.4.0.3 (JonasDuregard)
23:55:13 <Xnuk> >> mapM_ id [Just 3, Nothing, Just (73 :: Int)]
23:55:16 <Xnuk> > mapM_ id [Just 3, Nothing, Just (73 :: Int)]
23:55:18 <lambdabot>  Nothing
