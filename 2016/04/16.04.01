00:00:09 <haskell939> So my function is incorrect?
00:00:17 <cocreature> I guess orphans are not so bad here since nobody is going to import the testsuite
00:00:31 <erikd> zRecursive: there is no System.Time in ghc 7.10. maybe you meant Data.Time
00:01:01 <mniip> haskell939, advice: forget that length and ! exist
00:01:08 <mniip> !! rather
00:01:16 <zRecursive> erikd: ok, thx
00:01:23 <haskell939> how do I write recursive then?
00:01:38 <mniip> hm?
00:01:51 <haskell939> I need to have my own recursive function defined
00:01:56 <haskell939> it's asked in the homework
00:02:01 <mniip> I don't see a problem
00:02:25 <haskell939> Can you tell me how do I access the element of of the list then?
00:02:35 <mniip> you can pattern match the list
00:03:13 <haskell939> but pattern match itself is the recursion itself
00:03:29 <haskell939> it says to solve this problem by using foldl
00:03:36 <haskell939> later on
00:04:00 <mniip> I think you better solve it the "dumb" way first
00:04:13 <haskell939> which is?
00:04:47 <jle`> maxList [x] = ??
00:04:51 <jle`> maxList (x:xs) = ??
00:05:07 <mniip> something based on that ^
00:05:19 <haskell939> ok
00:06:36 <jle`> what is the maximum value of a one-item list, for instance?
00:07:39 * hackagebot GLFW 0.5.2.5 - A Haskell binding for GLFW  https://hackage.haskell.org/package/GLFW-0.5.2.5 (PaulLiu)
00:07:39 * hackagebot luis-client 0.0.1 - An unofficial client for the LUIS NLP service.  https://hackage.haskell.org/package/luis-client-0.0.1 (MicxjoFunkcio)
00:10:37 <haskell939> how can I represent the minimum value?
00:10:53 <jle`> maxList [x] = ??
00:10:57 <jle`> what's the answer?
00:11:03 <jle`> what's the maximum value in the list [10] ?
00:11:19 <jle`> what's the maximum value in the list [100] ?  [-4] ?
00:11:46 <haskell939> foldl max 0 [1,3,51,2,31,23,12,412,34]
00:12:03 <haskell939> that's the answer
00:12:12 <haskell939> which doesn't work for negative numbers
00:12:28 <jle`> yeah :)  so let's get to the recrusive version
00:12:35 <haskell939> hang on
00:12:38 <jle`> if i told you my list was [x], one item long, what is the maximum item in that list?
00:12:44 <haskell939> how am I supposed to get this working in negative numbers?
00:12:46 <jle`> if i told you i had the list [10], what is the biggest item int hat list?
00:12:57 <Axman6> haskell939: you're really going to take that answer to your tutor? I'm like 100% sure you didn't write that
00:12:59 <jle`> if i told you i had the list [-4], what's the biggest item in that list?
00:13:16 <haskell939> which one
00:13:18 <haskell939> foldl one?
00:13:21 <Axman6> yes
00:13:26 <haskell939> but I wrote it?
00:13:45 <haskell939> http://zvon.org/other/haskell/Outputprelude/foldl_f.html
00:13:48 <Axman6> can you explain it?
00:13:48 <haskell939> I found the example here
00:14:08 <haskell939> foldl takes a function and then applies to the list
00:14:16 <haskell939> max is the function
00:14:27 <haskell939> that takes two arguments
00:14:35 <Axman6> right, the point of the exercise you've been given is to understand writing structurally recursive code, that is not what you've written
00:15:03 <haskell939> so it applies (max (max 0, first el), second el)
00:15:04 <haskell939> and so one
00:15:08 <haskell939> *on
00:15:27 <haskell939> oh yeah I know that
00:15:30 <haskell939> I'm not gonna put this there
00:15:36 <Axman6> good :)
00:15:39 <haskell939> I'm just curious how to represent minimum value
00:15:45 <haskell939> like Integer.MIN_VAL or something
00:15:50 <Axman6> you should try answering jle`'s question then ;)
00:16:10 <jle`> there's no minimum value for Integer :o  and you won't need to think about a minimum value for the structurally recursive version :)
00:16:11 <haskell939> -4
00:16:19 <jle`> yeah, so, in general, minVal [x] = ?
00:16:23 <Axman6> well, Integers have no bounds, there is no minimum value (except a number which is too big to fit in your address space)
00:16:26 <haskell939> x
00:16:32 <jle`> mhm, that's the first line of your function
00:16:34 <jle`> minVal [x] = x
00:16:38 <jle`> now, the second line:
00:16:50 <jle`> *maxVal, sorry
00:16:54 <jle`> maxVal (x:xs) = ?
00:17:02 <haskell939> what's that?
00:17:04 <haskell939> x:xs?
00:17:16 <jle`> ah, that's the 'cons' constructor for lists
00:17:19 <mniip> Axman6, well it can fit in your address space if sizeof(void *) > sizeof(size_t)
00:17:20 <jle`> the 'x' represents the first item in the list
00:17:24 <jle`> the xs represents the rest of the list
00:17:31 <jle`> so [1,2,3] = 1:[2,3]
00:17:34 <mniip> Axman6, such as on 16-bit 8086
00:17:39 <jle`> [1,2,3,4] = 1:[2,3,4], etc.
00:17:45 <haskell939> oh ok
00:18:00 <jle`> so you're trying to find maxVal of the list (x:xs) -- you have x, the first item, and xs, the rest of the list
00:18:02 <haskell939> well we need to iterate through xs then
00:19:29 <haskell939> no?
00:20:17 <jle`> what if you knew the maximum value in xs?
00:20:33 <jle`> then if x is bigger than the maximum value in xs, the answer is x
00:20:43 <jle`> and if x is smaller than the maximum value in xs, the answer is the maximum value in xs :)
00:21:04 <jle`> luckily for you, we already have a function to find the maximum value of a list
00:21:17 <jle`> it's the one we're defining :)
00:21:42 <haskell939> then max(s, xs)
00:21:50 <jle`> not max x xs
00:21:52 <jle`> xs is a list
00:21:56 <jle`> max x (the maximum value in xs)
00:22:02 <haskell939> yeah result of the xs
00:22:06 <mniip> which is?
00:22:08 <jle`> not the result, the maximum value :)
00:22:25 <haskell939> maximum value sorry
00:22:39 <jle`> yeah, and how do you get the maximum value of xs?
00:22:56 <jle`> what function takes a list and gives you the maximum value in that list?
00:23:14 <haskell939> by doing that step again
00:23:20 <haskell939> take the head of list
00:23:25 <haskell939> then get the remaining
00:23:28 <haskell939> do it recursively
00:23:49 <jle`> yeah, that's what maxVal does.  so you can just call maxVal on xs
00:23:55 <jle`> maxVal (x:xs) = max x (maxVal xs)
00:24:00 <jle`> and that's it!
00:24:19 <haskell939> whoa
00:24:28 <Axman6> but... what if I give it []? D:
00:24:31 <mniip> and thaat's how you really recursively traverse a list
00:24:44 <jle`> we didn't define an answer, becuase the answer is not defined :O
00:25:10 <mniip> Axman6, bottom
00:25:16 <mniip> a reasonable answer for such a function
00:26:26 <haskell939> maxListF [1,2,3,5,6,4,2,1,3,10,15,23,123,12,312,1232,2,3]  Program error: pattern match failure: maxListF []
00:26:34 <haskell939> maxListF :: Ord a => [a] -> a maxListF (x:xs) = max x (maxListF xs)
00:26:38 <haskell939> doesn't work
00:26:45 <haskell939> I knew there was an issue with this x:xs thing
00:26:52 <jle`> did you put the [x] case?
00:26:54 <mniip> you forgot the first equation
00:27:00 <haskell939> nope
00:27:07 <jle`> you need to handle both cases
00:27:10 <jle`> not every list is (x:xs)
00:27:10 <mniip> yes you did
00:27:18 <jle`> maxListF [x] = x
00:27:27 <mniip> jle`, to be fair the two equations need to be in a specific order
00:27:27 <jle`> maxListF (x:xs) = max x (maxList xs)
00:27:41 <jle`> ah, yeah, that's a tricky thing
00:27:50 <haskell939> but
00:27:52 <mniip> it's not as trivial as [] vs :
00:27:56 <haskell939> I don't understand this whole thing
00:28:04 <jle`> let's try to call maxListF [1,2,3]
00:28:08 <jle`> which pattern does this mathc?
00:28:17 <jle`> this matches the (x:xs) case, as 1:[2,3]
00:28:26 <haskell939> 1) why max[x] works?
00:28:26 <jle`> so maxListF [1,2,3] = max 1 (maxListF [2,3])
00:28:40 <jle`> so, what is maxListF [2,3] ?
00:28:54 <jle`> it matches the (x:xs) case, so maxListF [2,3] = max 2 (maxListF [3])
00:29:00 <jle`> and what is maxListF [3]?
00:29:10 <jle`> it matches the [x] case, matchListF [x] = x, so matchListF [3] = 3
00:29:22 <haskell939> No it's too complicated now
00:29:26 * Clint claps.
00:29:29 <haskell939> Let's reverse a bit
00:29:48 <haskell939> maxListF [x] = x
00:29:58 <haskell939> 1) I didn't define x
00:30:04 <mniip> yes you did
00:30:04 <jle`> it's called a pattern match
00:30:17 <mniip> it's bound in the '[x]' pattern
00:30:21 <haskell939> okay where did I define it?
00:30:30 <jle`> haskell939: do you understand how foo (x,y) = x + y works?
00:30:35 <mniip> maxListF [x] = x
00:30:35 <mniip>           ^
00:30:45 <jle`> `foo (x, y) = x + y` defines a new function by pattern matching on the input
00:30:51 <haskell939> yes
00:30:54 <jle`> it pattern matches on a tuple, and calls the first item x, and the second item y
00:30:56 <haskell939> but that's for defining it
00:30:57 <jle`> the same thing is happening here
00:30:59 <haskell939> I didn't use where
00:31:10 <jle`> `foo [x] = x` pattern matches on a single-item list, and calls that item x
00:31:19 <jle`> you don't need to use where to pattern match :D
00:31:28 <jle`> @let foo1 (x,y) = x + y
00:31:30 <lambdabot>  Defined.
00:31:32 <jle`> > foo1 (1,2)
00:31:34 <lambdabot>  3
00:31:40 <jle`> @let foo2 [x] = x
00:31:42 <lambdabot>  Defined.
00:31:43 <jle`> > foo2 [3]
00:31:44 <lambdabot>  3
00:31:55 <haskell939> > foo2 [3, 4]
00:31:57 <lambdabot>  *Exception: /tmp/mueval16425488991501252996.hs:179:1-12: Non-exhaustive patt...
00:32:02 <jle`> yeah, it's not defined for the two-item-list case
00:32:07 <jle`> it's only defined for the one-item-list case
00:32:08 <haskell939> ok
00:32:13 <mniip> that's because you only told it what to do with [x] lists
00:32:15 <haskell939> I thought [] meant a list
00:32:18 <mniip> and [3, 4] isn't one of those
00:32:30 <jle`> "[3]" is a one-item list
00:32:42 <mniip> [3] matches [x]
00:32:43 <jle`> the pattern "[x]" matches on the one-item list, and calls the first value x
00:32:44 <mniip> such that x matches 3
00:32:47 <haskell939> so foo [x] = x just means if there is a single element list just return it
00:32:52 <mniip> [3, 4] doesn't match [x]
00:33:01 <jle`> just like how the pattern "(x,y)" matches on the two-item tuple, and calls the first value x, the second value y
00:33:04 <jle`> you can do the same thing with lists too
00:33:08 <jle`> @let foo3 [x,y] = x + y
00:33:10 <lambdabot>  Defined.
00:33:11 <jle`> > foo3 [1,2]
00:33:12 <lambdabot>  3
00:33:16 <haskell939> ok
00:34:10 <jle`> yeah, `foo [x] = x` declares a function that takes a single-item list and returns the value inside the list.  just like foo (x,y) = x takes a tuple and returns the first item in the tuple
00:34:22 <jle`> `foo [x,y] = x` takes a two-item list and returns the first item in that list
00:34:35 <jle`> `foo [x,y,z] = x` takes a three item list and returns the first item in that list, etc.
00:34:38 <haskell939> ok
00:34:42 <bernalex> what json library should I use to read & dump a json file?
00:34:44 <haskell939> and why is it useful at all?
00:34:56 <jle`> well, we can define maxList on a case-by-case basis
00:35:03 <jle`> handle every case, and we have the whole function defined
00:35:09 <jle`> so the simplist case would be the max of a one-item list
00:35:11 <jle`> maxList [x] = x
00:35:22 <jle`> the next simplest case would be the more-than-one item list
00:35:28 <jle`> maxList (x:xs) = max x (maxList xs)
00:35:29 <mniip> haskell939, pattern matching is the essence of computation
00:35:38 <jle`> and...that handles all cases where an answer is defined
00:35:40 <jle`> so you're done!
00:36:18 <jle`> hooray
00:36:51 <haskell939> okay
00:36:58 <gfixler> I'll add that it's up to the programmer to understand which cases are necessary
00:37:00 <haskell939> so what's the case where we use it?
00:37:08 <jle`> we just used it right now :)
00:37:14 <haskell939> yeah we use it
00:37:20 <haskell939> but like under what circumstance
00:37:29 <haskell939> I'm talking specificly to that usage
00:37:34 <mniip> it's used all over the lace
00:37:36 <haskell939> we always use two values
00:37:39 <gfixler> it's a bit of a jump to be able to tell that a list can be dealt with in 2 ways
00:37:39 <mniip> place*
00:37:41 <bernalex> i.e. I have a json file that I'll read (using whatever), like { { "foo": 123, "bar": 345 } "foo": 678, "bar": 999 }. I need to parse that such that I can easily add things to it and dump it with such and such indent and separators.
00:37:43 <haskell939> maxListF (x:xs) = max x (maxListF xs)
00:37:45 <haskell939> here
00:37:58 <bernalex> I guess I should use aeson somehow
00:37:58 <haskell939> max x (maxListF remainingOfList)
00:38:07 <mniip> haskell939, are you familiar with mathematical induction?
00:38:13 <haskell939> oh hang on
00:38:14 <jle`> yeah, that'd be max (first item in list) (maxListF remainderOfList)
00:38:21 <haskell939> I think I got it now
00:38:31 <jle`> so, if we just reduce out the patterns
00:38:37 <zRecursive> @hoogle getClockTime
00:38:37 <lambdabot> System.Time getClockTime :: IO ClockTime
00:38:39 <jle`> maxList [1,2,3] = max 1 (maxList [2, 3])
00:38:43 <haskell939> it recurses untill the last element
00:38:46 <jle`>  = max 1 (max 2 (maxList [3]))
00:38:52 <jle`>  = max 1 (max 2 3)
00:38:55 <jle`>  = max 1 3
00:38:56 <jle`>  = 3
00:38:59 <haskell939> then once it is the last element then it returns x
00:39:02 <haskell939> then it starts comparing
00:39:14 <jle`> yeah, the easiest way to look at this stuff is to just evaluate it by hand
00:39:20 <jle`> you just replace function calls by their definition
00:39:24 <haskell939> yeah sorry
00:39:27 <haskell939> it's the weird syntax
00:39:33 <haskell939> making it magical
00:39:33 <jle`> so if you wanted to evaluate maxList [1,2,3], you say, "which case does that match on?"
00:39:39 <jle`> and you can see, "oh, that matches on the (x:xs) case"
00:39:46 <haskell939> now 2nd part
00:39:50 <haskell939> that I didn't understand
00:39:54 <jle`> so maxList (x:xs) = max x (maxList xs), so that means that maxList (1:[2,3]) = max x (maxList [2,3])
00:40:00 <haskell939> x:xs part
00:40:07 <jle`> er, maxList (1:[2,3]) = max 1 (maxList [2,3])
00:40:08 <haskell939> I have only given []
00:40:14 <haskell939> how does it become x:xs
00:40:21 <mniip> [1, 2, 3] is syntactic sugar for 1:(2:(3:[]))
00:40:23 <jle`> (x:xs) is a pattern that matches on a non-empty list
00:40:34 <jle`> and 'x' is bound to the first item, xs is bound to the rest of the list
00:40:39 <zRecursive> But now System.Time is obsolete, can i use still getClockTime ?
00:40:48 <jle`> @let foo4 (x:xs) = x
00:40:50 <lambdabot>  Defined.
00:41:00 <jle`> > foo4 (1:[2,3,4])
00:41:02 <lambdabot>  1
00:41:06 <jle`> > foo4 [1,2,3,4]
00:41:07 <lambdabot>  1
00:41:24 <jle`> (x:xs) matches [1,2,3,4], and x is 1, xs is [2,3,4]
00:41:25 <haskell939> hmm
00:41:27 <mniip> > 1:2:3:[]
00:41:29 <lambdabot>  [1,2,3]
00:41:30 <gfixler> > 1:(2:(3:[])) == [1,2,3]
00:41:31 <lambdabot>  True
00:41:33 <haskell939> alright
00:41:42 <jle`> but yeah, that's just because [1,2,3,4] is syntactic sugar for 1:[2,3,4]
00:41:43 <haskell939> but it's a keyword?
00:41:46 <haskell939> x:xs right
00:41:49 <mniip> no
00:41:50 <haskell939> like it can't be k:ks
00:41:56 <haskell939> or y:yz
00:41:56 <jle`> oh no, it can be k too
00:42:04 <jle`> @let foo4 (potato:chip) = potato
00:42:06 <lambdabot>  .L.hs:181:1: Warning:
00:42:06 <lambdabot>      Pattern match(es) are overlapped
00:42:06 <lambdabot>      In an equation for ‘foo4’: foo4 (potato : chip) = ...
00:42:08 <jle`> aw
00:42:19 <jle`> it's just normal pattern matching, though
00:42:26 <jle`> foo (bar, baz) = bar
00:42:32 <jle`> @let foo5 (bar, baz) = bar
00:42:33 <lambdabot>  Defined.
00:42:34 <jle`> > foo5 (1,2)
00:42:36 <lambdabot>  1
00:42:40 <haskell939> no I know that
00:42:46 <mniip> x:xs is no different
00:42:52 <jle`> @let foo6 (hello : world) = hello
00:42:54 <lambdabot>  Defined.
00:42:58 <jle`> > foo6 (1:[2,3,4])
00:42:59 <haskell939> so firstElement:remaningOfList
00:42:59 <lambdabot>  1
00:43:05 <mniip> yeah
00:43:17 <haskell939> okay
00:43:23 <gfixler> (might help to know what lists actually are)
00:43:33 <haskell939> gotcha
00:43:43 <mniip> as you will learn haskell, though, you will find that haskell code is usually very conscise, and long variables names are often redundant
00:44:05 <jle`> the important thing is the constructor; for tuples, the constructor is ","
00:44:12 <jle`> for non-empty lists, the constructor is ":"
00:44:18 <gfixler> haskell939: re: the weird syntax - what language(s) do you know already?
00:44:31 * mniip bets on java
00:44:51 * gfixler has 2 small points to make re: function syntax in haskell
00:45:13 <haskell939> Java
00:45:14 <jle`> haskell939: so, if i call maxList on [1,2,3], it'll match on the (x:xs) pattern, as (1:[2,3])
00:45:21 <gfixler> mniip++
00:45:27 <jle`> so maxList (1:[2,3]) = max 1 (maxList [2,3])
00:45:29 <haskell939> Ruby, C++11
00:45:48 <jle`> and if i call maxList on [2,3], it'll match on the (x:xs) pattern again, as (2:[3])
00:45:53 * mniip . o O ( C++11 is a separate language now? )
00:45:55 <jle`> so maxList [2,3] = max 2 (maxList [3])
00:46:10 <gfixler> point #1: Haskell functions are not a named pile of statements; they're single expressions
00:46:10 <haskell939> no C++14 is different
00:46:16 <opqdonut> mniip: saying you know C++11 is a good way to not end up in legacy c++ projects :)
00:46:19 <haskell939> so I wanted to point out that I don't know C++14
00:46:19 <jle`> and if i call maxList on [3], that'll match on the [x] pattern, as [3], so maxList [3] = 3
00:46:26 <mniip> I see
00:46:38 <mniip> I still write C++98 :( / :)
00:46:41 <gfixler> point #2: The = used in function definition means equal - the left and right side are interchangeable (modulo the pattern args)
00:46:50 <gfixler> :t head
00:46:52 <lambdabot> [a] -> a
00:46:56 <jle`> so maxList [1,2,3] = max 1 (maxList [2,3]) = max 1 (max 2 (maxList [3])) = max 1 (max 2 3) = max 1 3 = 3
00:46:57 <haskell939> okay cool
00:46:59 <gfixler> head takes a list and returns the first element
00:47:19 <gfixler> but we could also take an element and wrap it in a list and stick on a head, without changing the element semantically
00:47:29 <jle`> note that "all evaluation is" is just replacing function calls by the body of the function, there :)
00:47:33 <gfixler> > 3 = head [3,4,5]
00:47:34 <lambdabot>  <hint>:1:3: parse error on input ‘=’
00:47:38 <gfixler> > 3 == head [3,4,5]
00:47:39 <lambdabot>  True
00:47:50 <liste> > let 5 + 5 = 12 in 5 + 5
00:47:52 <lambdabot>  12
00:48:00 <mniip> liste pls
00:48:16 * liste gets his coat
00:48:31 * gfixler thinks "let" should be replaced with "pretend"
00:48:43 <mniip> emphasizing what gfixler said,
00:48:43 <haskell939> So how come this doesn't work
00:48:45 <haskell939> maxListF list = foldl max(x:xs)
00:48:52 <mniip> head [1,2,3] = 1
00:48:54 <jle`> you never bind x or xs to anything
00:48:55 <mniip> not only one way
00:48:59 <mniip> but the other way too
00:49:08 <jle`> `maxListF (x:xs) = foldl max x xs` would work
00:49:28 <jle`> but that takes all of the fun out of the recursion :P
00:49:47 <jle`> s/fun/learning exercise
00:49:47 <mniip> haskell939, answering specifically the question you asked, because x and xs aren't bound
00:50:17 <haskell939> ok
00:50:34 <jle`> that'd be like writing firstOfTuple tup = x
00:50:35 <gfixler> pattern bindings happen on the left of the =
00:50:39 <jle`> instead of firstOfTup (x,y) = x
00:50:56 <gfixler> (that's what I meant by "modulo some pattern args" earlier)
00:52:23 <haskell939> So I had a question earlier on
00:52:30 <haskell939> I could do that one with this then
00:53:04 <haskell939> if I have res1 = [2,3,4,5]
00:53:20 <haskell939> Instead of doing drop 1 res1
00:53:27 <haskell939> I can always do x:xs =res1
00:53:33 <haskell939> then xs
00:53:35 <haskell939> right?
00:53:42 <gfixler> yep
00:53:54 <gfixler> or even tail res1
00:54:14 <gfixler> > tail [2,3,4,5] == drop 1 [2,3,4,5]
00:54:15 <lambdabot>  True
00:54:29 <mniip> or (let x:xs = res1 in ...)
00:54:37 <mniip> or (case res1 of x:xs -> ...)
00:54:54 <mniip> or with where, as you've probably already done
00:55:01 <gfixler> or [3,4,5]
00:55:01 <zRecursive> @let picoSec = ctPicosec <$> (getClockTime >>= toCalendarTime)
00:55:02 <lambdabot>  .L.hs:174:11: Not in scope: ‘ctPicosec’
00:55:03 <lambdabot>  
00:55:03 <lambdabot>  .L.hs:174:26: Not in scope: ‘getClockTime’
00:55:42 <zRecursive> then how can i make picoSec work using ghc-7.10.3 ?
00:57:50 <bernalex> hm. what can I do when decode doesn't work and I'm not sure why? i.e. to figure out why I'm getting a Nothing
00:58:00 <bernalex> I have data Comment = C { id     :: Int , author :: String , text   :: String } deriving (Generic, Show)
00:58:36 <bernalex> and a file like [ { "id": 123, "author": "someone", "text": "something"}]
00:59:02 <bernalex> decode <$> B.readFile "comments.json" :: IO (Maybe Comment)
00:59:04 <lyxia> bernalex: there's decodeOrFail which returns an error
00:59:13 <lyxia> an error message
00:59:22 <bernalex> lyxia: where is that function?
00:59:29 <bernalex> @hayoo decodeOrFail
00:59:29 <lambdabot> Unknown command, try @list
00:59:33 <bernalex> @hoogle decodeOrFail
00:59:33 <lambdabot> No results found
00:59:43 <lyxia> bernalex: wait are you using cereal or binary
00:59:49 <bernalex> lyxia: aeson
00:59:54 <lyxia> aeson hmm
01:00:38 <lyxia> eitherDecode
01:01:12 <bernalex> ah yeah I forgot about that one! ta
01:01:17 <bernalex> Left "Error in $: expected record (:*:), encountered Array"
01:01:28 <bernalex> I have no clue what that amounts to though
01:02:12 <lyxia> if you're parsing a Comment it expects a record
01:02:17 <rydgel> bernalex: what's your Comment data type
01:02:18 <lyxia> but what you wrote starts with [
01:02:23 <rydgel> nvm you posted it
01:02:35 * hackagebot cblrepo 0.21.0 - Tool to maintain a database of CABAL packages and their dependencies  https://hackage.haskell.org/package/cblrepo-0.21.0 (MagnusTherning)
01:02:42 <bernalex> lyxia: derrrrrpppppppp
01:02:47 <bernalex> [Comment] not Comment.
01:02:49 <rydgel> yup
01:02:52 <bernalex> thanks for pointing out my derp. :]
01:09:21 <bernalex> now my next problem I have no clue about. I have a scotty web server. I am serving a static html file. said html has a form. how do I get the values of the two text fields in that form?
01:09:51 <bernalex> oh right that will be in the POST never mind
01:10:56 <haskell939> Sorry if I have a function like this
01:10:57 <haskell939> pt :: String -> String -> Either String Int
01:11:14 <haskell939> which then I define like this
01:11:18 <haskell939> pt cipher plaintext = 1
01:11:21 <haskell939> what's the problem?
01:11:33 <mniip> 1 is not an Either String Int
01:11:40 <haskell939> I get this eror
01:11:53 <haskell939>  Instance of Num (Either String Int) required for definition of crypt
01:12:07 <bernalex> :t 1
01:12:08 <lambdabot> Num a => a
01:12:14 <bernalex> you need to return an Either String Int
01:12:20 <mniip> that's an obscure error message that's telling you that 1 is not an Either String Int
01:12:26 <haskell939> yeah I'm returning Int
01:12:36 <mniip> Int is not Either String Int
01:12:38 <bernalex> haskell939: you should return  Either String Int
01:12:48 <haskell939> how do I make that type?
01:12:55 <bernalex> :t Right 1 :: Either String Int
01:12:57 <lambdabot> Either String Int
01:13:01 <bernalex> :t Right
01:13:02 <lambdabot> b -> Either a b
01:13:03 <bernalex> :t Left
01:13:04 <lambdabot> a -> Either a b
01:13:20 <mniip> @src Either
01:13:21 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:13:21 <bernalex> haskell939: so you use Right to make the right part, Left to make the left part.
01:13:23 <mniip> aw
01:13:36 <haskell939> isn't either return one of them
01:13:37 <haskell939> but not both
01:13:43 <mniip> it is
01:13:44 <bernalex> haskell939: yes.
01:13:49 <haskell939> so if I return 1
01:13:52 <haskell939> that's Int
01:13:54 <bernalex> that's a type error.
01:14:01 <bernalex> your function returns Either String Int not Int.
01:14:02 <mniip> data Either a b = Left a | Right b
01:14:18 <mniip> that's telling you that a value of type Either a b, is either a Left a, or a Right b
01:14:58 <haskell939>  = 1 -> Right
01:15:01 <haskell939> like this then?
01:15:04 <mniip> no
01:15:04 <bernalex> no
01:15:09 <bernalex> Right 1.
01:15:44 <bernalex> f x :: Int -> Either String Int
01:15:50 <haskell939> but then it returns Right 1
01:15:51 <bernalex> f 1 = Right 1
01:15:51 <haskell939> not 1
01:15:57 <bernalex> f _ = Left "not 1"
01:16:07 <bernalex> haskell939: yes. that's the type of your function.
01:16:24 <haskell939> ok
01:16:51 <bernalex> s/ x// in my example btw
01:19:59 <bernalex> what's a prelude thing that gets me "time.time() * 1000" from python?
01:20:28 <bernalex> apparently time.time() is Return the time in seconds since the epoch as a floating point number.
01:21:04 <rydgel> bernalex: getCurrentTime :: IO UTCTime
01:21:04 <Adeon> maybe POSIXTime from Data.Time.Clock.Posix
01:21:18 <bernalex> @hoogle getCurrentTime
01:21:19 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
01:21:19 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
01:22:05 <rydgel> or like Adeon said "getPOSIXTime :: IO POSIXTime"
01:22:13 <bernalex> rydgel: how do you -> seconds?
01:22:17 <rydgel> but it's in time lib
01:22:19 <bernalex> i.e. -> Int
01:22:23 <fr33domlover> there's also the 'clock' package
01:22:42 <fr33domlover> you can get the timespec since epoch using the Realtime clock
01:22:44 <Adeon> if you want monotonic time then the 'clock' package is great
01:22:53 <Adeon> it boils down to what you actually need
01:23:01 <bernalex> I posted what I need.
01:23:07 <bernalex> <bernalex> what's a prelude thing that gets me "time.time() * 1000" from python? 
01:23:09 <bernalex> <bernalex> apparently time.time() is Return the time in seconds since the epoch as a floating point number. 
01:24:50 <bernalex> oh, I forgot a part: int(time.time() * 1000)
01:25:13 <rydgel> round <$> getPOSIXTime give you a IO Int in seconds
01:25:51 <bernalex> getPOSIXTime seems the... rydgel yep. just figured it out. :]
01:26:59 <bernalex> round . (*1000) <$> getPOSIXTime -- seems to be correct, judging by ipython output
01:27:05 <rydgel> yup
01:27:36 <rydgel> you can do it too with `getCurrentTime` but it's a bit more complicated
01:28:02 <rydgel> smth like read <$> formatTime defaultTimeLocale "%s" <$> getCurrentTime
01:28:42 <bernalex> only one thing left now
01:28:47 <bernalex> file.write(json.dumps(comments, indent=4, separators=(',', ': '))) -- in haskell
01:28:48 <haskell939> given string I want to apply a function for each character which returns boolean and then connect these boolean values together with && operand and use the result
01:28:58 <haskell939> how do I do that?
01:29:11 <srhb> :t map
01:29:12 <lambdabot> (a -> b) -> [a] -> [b]
01:29:13 <srhb> :t and
01:29:14 <lambdabot> Foldable t => t Bool -> Bool
01:29:17 <bernalex> :t all
01:29:18 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
01:29:24 <srhb> Ah, yes.
01:29:27 <Adeon> aeson is your library for json but I don't remember if it does nice indenting
01:29:35 <Adeon> I've never had to care for that
01:29:47 <bernalex> Adeon: I'm using aeson, but I haven't seen anything about indentation either yet.
01:29:49 <srhb> haskell939: Basically, you just need to reformat your question like this
01:29:50 <rydgel> bernalex: you can first encode with Aeson your [Comment] which gives you a ByteString
01:29:59 <bernalex> Adeon: I've never cared either...
01:30:09 <srhb> @hoogle (a -> Bool) -> [a] -> Bool
01:30:10 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
01:30:11 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
01:30:11 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
01:30:16 <rydgel> oh pretty printing json..
01:30:23 <srhb> haskell939: Hoogle knows :-)
01:30:27 <haskell939> what's that mean?
01:30:27 <bernalex> rydgel: I'm already encoding it, yeah
01:30:49 <srhb> haskell939: You said a function that takes an element to Bool (a -> Bool), a list of these as, [a], and you want a Bool in the end
01:30:56 <haskell939> yeah
01:30:57 <srhb> haskell939: Ie (a -> Bool) -> [a] -> Bool
01:31:03 <haskell939> what's the syntax for that?
01:31:07 <srhb> haskell939: Then you ask Hoogle for that signature
01:31:16 <bernalex> rydgel: I'm reading a file, decoding it into [Comment], making a new Comment, and encode (cs ++ [c]). all that's left is updating the file.
01:31:27 <srhb> haskell939: And then Hoogle says "the function `all` does what you want"
01:32:13 <rydgel> bernalex: there is writeFile :: FilePath -> ByteString -> IO ()
01:32:19 <bernalex> > all (>5) [6..10]
01:32:21 <lambdabot>  True
01:32:21 <bernalex> haskell939: ^
01:32:26 <srhb> > all (== 'a') "aaaabcd"
01:32:27 <lambdabot>  False
01:32:29 <srhb> eh, too slow
01:32:39 <bernalex> rydgel: does that do indentation
01:32:43 <rydgel> bernalex: nop
01:32:53 <rydgel> bernalex: but there is an aeson-pretty package
01:32:57 <bernalex> rydgel: I'll have a look
01:32:59 <rydgel> bernalex: that does that
01:33:27 <bernalex> !hackage aeson-pretty
01:33:33 <bernalex> uhm this is not my web browser...
01:34:53 <haskell939> hmm
01:35:00 <haskell939> I meant a character in there
01:35:06 <haskell939> not a character from what I give
01:35:42 <srhb> haskell939: Can you rephrase that?
01:35:48 <bernalex> rydgel: encodePretty' { confIdent = 4, confCompare = mempty }
01:35:50 <haskell939> > all (== 'a') "aaaabcd"
01:35:51 <bernalex> probably
01:35:52 <lambdabot>  False
01:35:59 <haskell939> this we specify 'a' character
01:36:03 <srhb> haskell939: Yes.
01:36:18 <haskell939> whereas I want to do something for every character in "aaaabcd"
01:36:22 <srhb> haskell939: You can replace (== 'a') with any Char -> Bool function you like
01:36:36 <srhb> haskell939: That is what it does. It applies (== 'a') to each Char in the String.
01:36:50 <srhb> It
01:37:01 <srhb> It's really just and . map (== 'a')
01:37:09 <haskell939> > all (isAlpha) "abcd"
01:37:11 <lambdabot>  True
01:37:29 <haskell939> > all (isUpper) "abcd"
01:37:30 <lambdabot>  False
01:37:36 <haskell939> > all (isUpper) "aBCCd"
01:37:37 <lambdabot>  False
01:37:42 <haskell939> > all (isUpper) "aBCCD"
01:37:44 <lambdabot>  False
01:37:46 <haskell939> > all (isUpper) "ABcCD"
01:37:48 <lambdabot>  False
01:37:51 <haskell939> > all (isUpper) "ABCD"
01:37:54 <lambdabot>  True
01:37:56 <merijn> snoyberg is the proud author of the first April fools joke I didn't notice until the end of reading
01:37:59 <haskell939> okay that's the one
01:38:14 <srhb> merijn: I thought it was hilarious
01:38:40 <srhb> haskell939: The paranthesis is superfluous there.
01:38:55 <bernalex> merijn: who/what is snoyberg?
01:39:12 <bernalex> and what was the joke?
01:39:24 <rydgel> was python 8 an april fool too?
01:39:54 <srhb> bernalex: Michael Snoyberg, the author of Yesod, conduit etc.
01:40:08 <srhb> Er.. no
01:40:14 <srhb> Snoyman :-)
01:41:24 <bernalex> oh. yes, I know Snoyman. but what was the joke?
01:42:02 <srhb> bernalex: I'd rather not spoil it here. I'll /msg it
01:42:05 <bernalex> yes ta
01:42:25 <haskell939> Sorry
01:42:33 <haskell939> this lambda bot is better than my compiler
01:42:41 <xcombelle> which april fools joke merijn ?
01:42:42 <haskell939> ERROR "simple.hs":34 - Undefined variable "isUpper"
01:42:51 <haskell939> why do I get this error?
01:43:18 <rydgel> haskell939: did you import it from Data.Char?
01:47:17 <haskell939> I'll import now
01:48:02 <srhb> haskell939: You can use https://www.haskell.org/hoogle/ for that as well, finding ouy in which module some function belongs.
01:48:17 <srhb> haskell939: And the stackage version of hoogle will search all of the stackage packages too.
01:50:27 <bernalex> I haven't had cabal doing stupid things in a long time, so I fully expect this being my own fault. so with that disclaimer in place:
01:50:46 <bernalex> cabal install spits out:
01:50:49 <bernalex> cabal: Could not resolve dependencies:
01:50:51 <bernalex> trying: server-0.0.0 (user goal)
01:50:53 <bernalex> next goal: aseon-pretty (dependency of server-0.0.0)
01:50:55 <bernalex> Dependency tree exhaustively searched.
01:50:57 <bernalex> with build-depends:                        aseon-pretty >=0.7 && <0.8,
01:52:08 <merijn> xcombelle: I'll pm you
01:52:56 <rydgel> bernalex: "aseon-pretty" should be "aeson-pretty"
01:53:04 <bernalex> rydgel: xD
01:53:24 <bernalex> thanks again :p
01:54:16 <haskell939> > fromList [3,5]
01:54:17 <lambdabot>      No instance for (Show a0)
01:54:17 <lambdabot>        arising from a use of ‘show_M12769134803682363955884’
01:54:17 <lambdabot>      The type variable ‘a0’ is ambiguous
01:55:44 <haskell939> how do I make a list to set?
01:56:44 <bernalex> > fromList [3, 5] :: Set Int
01:56:46 <lambdabot>      Not in scope: type constructor or class ‘Set’
01:56:46 <lambdabot>      Perhaps you meant one of these:
01:56:46 <lambdabot>        ‘S.Set’ (imported from Data.Set),
01:56:48 <bernalex> :t fromList
01:56:49 <lambdabot> IsList l => [Item l] -> l
01:57:04 <bernalex> haskell939: that's not Set.fromList. with regular fromList you use it just like you typed.
01:57:20 <eskimo> Hi there! Has someone a pointer for me, how to get something like this to work: http://lpaste.net/158062
01:57:21 <haskell939> What do  you mean?
01:57:47 <bernalex> haskell939: lambdabot's fromList is not Set.fromList but a different function with that name. Set.fromList is used just like you tried typing above.
01:57:51 <haskell939> > Set.fromList [3,5]
01:57:52 <lambdabot>      Not in scope: ‘Set.fromList’
01:57:53 <lambdabot>      Perhaps you meant one of these:
01:57:53 <lambdabot>        ‘Seq.fromList’ (imported from Data.Sequence),
01:58:01 <rydgel> > S.fromList [3,5]
01:58:03 <lambdabot>  fromList [3,5]
01:58:12 <eskimo> I am trying to traverse a servant API - and I am having trouble with :<|> (choice)
01:58:18 <haskell939> Main> Set.fromList [3,5] ERROR - Undefined qualified variable "Set.fromList"
01:58:19 <rydgel> you should import Data.Set and use the fromList function from it
01:58:22 <haskell939> doesn't work on me
01:58:40 <rydgel> haskell939: you can import qualified Data.Set as S
01:58:45 <rydgel> haskell939: then use S.fromList
01:59:01 <srhb> Or just import Data.Set as S
01:59:08 <rydgel> or that yes
01:59:10 <eskimo> I have an endpoint and want to traverse the matching branch and not the other .... hmmm
01:59:34 <haskell939> ok
02:01:38 <haskell939> Sorry
02:01:39 <haskell939> do not use library functions that are not in the Haskell standard prelude.
02:01:46 <haskell939> does that mean I'm not allowed to import Set?
02:02:04 <rydgel> haskell939: probably
02:02:44 <haskell939> oh I wanted to use Set so that I can know if list has any duplicate element
02:02:44 <rydgel> haskell939: What are you trying to achieve?
02:03:33 <haskell939> if not (length foo == size (fromList foo)) then ....
02:03:34 <haskell939> like that
02:03:56 <haskell939> how simple, how elegant
02:06:33 <rydgel> haskell939: there is also `nub` from Data.List that removes duplicates in a list
02:06:40 <mfukar> It's not very hard to write a function to detect duplicates yourself
02:06:49 <rydgel> haskell939: but that's not in prelude either
02:06:50 <mfukar> are you familiar with elem?
02:08:58 <haskell939> no
02:08:58 <haskell939> elem?
02:10:13 <haskell939> I mean what should I do
02:10:18 <mfukar> @hoogle elem
02:10:19 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
02:10:19 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
02:10:19 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
02:10:51 <haskell939> write merge sort then check then apply the list then check the next element in the list?
02:11:35 <mfukar> Well sorting's not necessary, but it'll be faster. The idea is check if each element of the list appears in the tail of the list
02:11:46 <haskell939> elem "asd"
02:11:47 <haskell939> > elem "asd"
02:11:49 <lambdabot>      No instance for (Typeable t0)
02:11:49 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
02:11:49 <lambdabot>        arising from a use of ‘show_M57703424075482207816215’
02:12:01 <haskell939> > elem 'a' "asd"
02:12:03 <lambdabot>  True
02:12:08 <haskell939> > elem 'b' "asd"
02:12:09 <lambdabot>  False
02:12:45 <haskell939> @hoogle lookup
02:12:45 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:12:45 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:12:45 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
02:13:13 <haskell939> lookup 'a' "as"
02:13:20 <haskell939> > lookup 'a' "as"
02:13:21 <lambdabot>      Couldn't match type ‘Char’ with ‘(Char, b)’
02:13:21 <lambdabot>      Expected type: [(Char, b)]
02:13:21 <lambdabot>        Actual type: [Char]
02:13:43 <haskell939> how can I learn what function does what?
02:14:11 <mfukar> Hoogle's a good option. You can see the source code on hackage as well.
02:14:21 <bernalex> usually reading the types is enough for simple prelude things.
02:14:21 <mfukar> Sorry, Hoogle as in the website
02:14:53 <haskell939> > lookup 'a' [('b','c')]
02:14:54 <lambdabot>  Nothing
02:15:01 <haskell939> > lookup 'a' [('b','c', 'a')]
02:15:02 <lambdabot>      Couldn't match expected type ‘(Char, b)’
02:15:02 <lambdabot>                  with actual type ‘(Char, Char, Char)’
02:15:02 <lambdabot>      In the expression: ('b', 'c', 'a')
02:15:10 <haskell939> > lookup 'a' [('a','c')]
02:15:12 <lambdabot>  Just 'c'
02:15:21 <haskell939> > lookup 'a' [('a','c'), ("bc")]
02:15:23 <lambdabot>      Couldn't match expected type ‘(Char, Char)’
02:15:23 <lambdabot>                  with actual type ‘[Char]’
02:15:23 <lambdabot>      In the expression: ("bc")
02:15:25 <srhb> haskell939: Yeah, find the function on hoogle (for base things, the version of Hoogle on haskell.org, otherwise stackage) and then follow the links to the Hackage docs. In time you'll mostly only need to read the type signature to figure out what a function does.
02:15:41 <haskell939> > lookup 'a' [('a','c'), ('b', 'c')]
02:15:42 <lambdabot>  Just 'c'
02:15:48 <haskell939> > lookup 'a' [('a','c'), ('a', 'c')]
02:15:50 <lambdabot>  Just 'c'
02:15:52 <srhb> haskell939: You can also talk to lambdabot privately if you just want to experiment, to avoid spamming the channel, unless you're trying to have something explained by the channel 
02:15:53 <haskell939> > lookup 'a' [('a','c'), ('a', 'd')]
02:15:55 <lambdabot>  Just 'c'
02:16:00 <haskell939> oh sorry
02:16:00 <rydgel> haskell939: it's more like [(key1, value1), (key2, value2)...]
02:16:02 <srhb> haskell939: ie /query lambdabot in most irc clients
02:16:15 <srhb> haskell939: It's fine. :)
02:16:38 <haskell939> it seems better than my hugs thing
02:17:27 <srhb> haskell939: Hugs is woefully outdated, you should use ghci for most things.
02:30:30 <bernalex> rydgel: have you used encodepretty'?
02:31:09 <bernalex> for you or anyone else using aeson: encodepretty' myConf mzero *reverses* the kv-pairs. how do I avoid that?
02:34:45 <srhb> bernalex: Isn't that exactly what the Config is about?
02:35:04 <bernalex> srhb: hm?
02:35:26 <bernalex> srhb: oh I meant to paste encodePretty' 4 mzero
02:35:42 <srhb> bernalex: 
02:35:45 <bernalex> srhb: so just giving mzero ends up reversing the pairs. how do I just leave them alone?
02:36:50 <srhb> bernalex: I think you'd need to redefine it entirely, so it doesn't use sortBy
02:37:30 <srhb> Wait, mzero?
02:37:30 <bernalex> I can use Config 4 (keyOrder ["id", "author", "text"])
02:37:33 <bernalex> but that's really silly
02:38:01 <srhb> bernalex: Not mempty?
02:38:48 <bernalex> srhb: oops yes mempty
02:39:00 <rydgel> bernalex: no never used it sorry
02:39:50 <srhb> > sortBy mempty "abaacde"
02:39:52 <lambdabot>  "abaacde"
02:40:02 <srhb> bernalex: Weird, I would think that would work.
02:40:23 <bernalex> srhb: so would I
02:40:53 <bernalex> a more severe limitation of my site atm is that uh I probably shouldn't use scotty at all, because I need to dynamically do something
02:40:57 <srhb> bernalex: Can you provide a minimal example that doesn't work?
02:41:54 <rydgel> bernalex: what scotty prevents you to do?
02:42:06 <bernalex> rydgel: idk if scotty prevents it as such, but idk how to do it
02:42:26 <rydgel> bernalex: do you have any example?
02:42:31 <srhb> I wonder if you're just being bitten by HashMaps having surprising orders
02:42:49 <srhb> If so, you should just sort it for real.
02:43:02 <bernalex> rydgel: http://lpaste.net/2106128009202237440 ignore silly code in-between (it will be improved :p)
02:43:35 <bernalex> rydgel: what I want to do here is read the file and the data from the form, add a new comment to the file, return the json as the result
02:43:53 <bernalex> if you need more info/ctx I can probably put it on github so you can try it...
02:44:07 <bernalex> srhb: I can upload it for you too, I guess. the example is pretty tiny.
02:46:11 <bernalex> if I can figure out my github password...
02:46:31 <bernalex> oh. I just had the wrong remote.
02:47:05 <bernalex> srhb: rydgel: https://github.com:alexander-b/react-tutorial.git probably
02:47:45 <rydgel> bernalex: why is the order of keys important in your case?
02:47:59 <bernalex> https://github.com/alexander-b/react-tutorial.git to be precise
02:48:15 <bernalex> rydgel: "because reasons". I'm just doing what the other servers are doing.
02:48:30 <rydgel> ok
02:49:05 <rydgel> bernalex: I think Scotty is suited for that, just like Flask is for the Python version
02:49:34 <bernalex> srhb: you need to swap keyOrder ["id", "author", "text"] for mempty. then you can add something with a POST (just use the web gui), and check the comments.json.
02:50:18 <bernalex> rydgel: OK. what am I missing then? if you try cabal run, go to localhost:3000, and add a comment, you'll see that it does that whole "fake post" trick to make it seem responsive... and then it goes away for a second as scotty is reloading a new page.
02:50:39 <bernalex> in e.g. the PHP version (and probably the other versions too) this isn't an issue.
02:52:10 <puregreen> bernalex: yeah, encodePretty uses toJSON internally which messes up key order irrevocably
02:52:23 <bernalex> puregreen: sadface.jpeg
02:52:42 <bizarrefish> Lo all, what's the name of a construct that changes a [Monad a] into a Monad [a] ?
02:53:03 <srhb> @hoogle Monad m => [m a] -> m [a]
02:53:03 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
02:53:04 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
02:53:04 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
02:53:14 <bernalex> that's sequence, yes.
02:53:17 <bizarrefish> Or rather, more formally A (Monad a) into a Monad (A a) ?
02:53:30 <bizarrefish> Ahh, cool
02:53:36 <mniip> 1459504335 [12:52:15] <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
02:53:47 <srhb> bizarrefish: If you write it as a real type signature, you can search for it with Hoogle. Helps a lot. :-)
02:53:50 <mniip> although you probably want traverse or sequenceA for that
02:53:51 <bernalex> :t sequence
02:53:52 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
02:54:12 <bizarrefish> I had no idea that was there :)
02:54:16 <puregreen> bernalex: I might be mistaken, but I think your only bet is using some TH/generics magic to get the list of fields of Comment and then giving that list to keyOrder without having to hardcode it
02:54:17 * bizarrefish doesn't come here enugh
02:54:19 <bizarrefish> *enough
02:54:41 <bernalex> puregreen: hardcoding is less work than that, so that's OK.
02:55:22 <rydgel> bernalex: I would need to run your example locally to understand your issue I think
02:55:38 <bernalex> rydgel: please just do. it's very trivial. just cabal run.
02:57:30 <rydgel> bernalex: yeah hang on
02:59:41 <aaakfp> anyone that can recommend some machine learning / data mining package that works with stackage?
03:05:58 <rydgel> bernalex: seems to work fine here
03:06:07 <bernalex> rydgel: wut. here it "blinks" when I post.
03:06:12 <rydgel> bernalex: comments are added and it shows them well
03:06:37 <bernalex> that's odd. maybe the mistake is elsewhere. kind of hard to know.
03:06:58 <rydgel> bernalex: maybe it blinked, because the GET polling came in between
03:07:57 <rydgel> bernalex: Like you add a new comments, the js put it the DOM. A GET pooling is comming but the POSTing a the new comments wasn't finished and the comments.json wasn't yet updated
03:08:21 <bernalex> it shouldn't happen though. it doesn't in any of the other servers.
03:10:03 <Gurkenglas> How should I decide what template from "stack templates" to pick for "stack new"? (I want to make a GUI thingy, using gloss or something)
03:12:08 <rydgel> bernalex: Oh I see, it doesn't seem to return the new written comment in the POST response
03:13:02 <rydgel> bernalex: you whole "case cs ..." is actually doing nothing
03:13:20 <ongy> is there a faster way to convert a [String] into an [Int] than (map read) ?
03:13:29 <bernalex> rydgel: yes
03:13:35 <bernalex> rydgel: I don't have that any more in my local code
03:14:18 <rydgel> bernalex: instead of returning cs why don't you return cs ++ newComment?
03:14:31 <bernalex> rydgel: oh my
03:15:35 <rydgel> bernalex: can this cause your problem?
03:15:40 <bernalex> probably!
03:15:48 <bernalex> I'm going to have a look
03:17:41 <Gurkenglas> ongy, String is not your friend if you care for performance - but you probably shouldn't. What is your code? (Paste?)
03:19:47 <ongy> Gurkenglas: I don't have a small example, but profiling brought to my attention that this https://github.com/monky-hs/monky/blob/master/Monky/CPU.hs#L149 takes up 30% of time spent
03:19:53 <bernalex> rydgel: that was it! thanks!
03:21:06 <ongy> and you are right, converting the string to ByteString and using readInt reduces the time spent to 5%
03:21:15 <ongy> that's including the conversion
03:24:35 <bernalex> rydgel: do you know a good solution to this: http://lpaste.net/8703560172313772032 ? the middle block in comments should only happen on POST
03:25:05 <bernalex> rydgel: one silly way is to have data GP = G | P and then comments m, and check if m is P. but I'm sure it can be done more elegantly.
03:26:10 <rydgel> bernalex: I will probably split that into multiples functions, likes a commentsGet and commentsPost one. And put the similar stuff inside helpers functions
03:26:42 <bernalex> rydgel: I had that originally, and am leaning back towards it
03:27:17 <rydgel> alright gtg, be back in 1h
03:27:47 <bernalex> rydgel: thanks for your help so far
03:28:03 <hjulle> ongy: (And if you can avoid converting to string in the first place, the improvement will (probably) be even more.)
03:29:00 <merijn> Speaking of String not being a friend...do we have a Text version of the process package and stuff dealing with files?
03:31:38 <hjulle> merijn: There's Data.Text(.Lazy).IO?
03:32:19 <merijn> That's for accessing files, I mean I want to use Text instead of String for FilePaths/opening files
03:32:26 <hjulle> aha
03:32:38 <merijn> i.e. "readFile :: Text -> IO Text" as opposing to "readFile :: String -> IO Text"
03:32:58 <merijn> Same for the process library
03:33:02 <merijn> all the functions want String
03:34:11 <alex_698> hello
03:35:30 <alex_698> haskell newbie here
03:35:57 <alex_698> can anyone explain to me the process of setting up vim to work with haskell stepwise
03:36:04 <alex_698> i am a bit lost?
03:36:51 <iphy> is there a better way to write (\x y -> f x $ g y)?
03:37:09 <hjulle> alex_698: I use vanilla vim with haskell. All that's really needed is to open the file.
03:37:19 <hjulle> alex_698: Anything specific you want?
03:37:26 <alex_698> but how do you set up haskell mode?
03:37:27 <bernalex> @hoogle Functor f => String -> f String -> f String
03:37:27 <lambdabot> Network.CGI getVarWithDefault :: MonadCGI m => String -> String -> m String
03:37:27 <lambdabot> Graphics.UI.GLUT.Initialization initialize :: MonadIO m => String -> [String] -> m [String]
03:37:27 <lambdabot> Network.CGI.Cookie findCookie :: String -> String -> Maybe String
03:37:32 <bernalex> hm.
03:37:46 <hjulle> alex_698: What is haskell mode?
03:37:54 <alex_698> i have done cabal install ghc-mod and vimproc
03:37:57 <bernalex> alex_698: I just installed it and added let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['haskell'] }
03:38:05 <bernalex> for ghc-mod
03:38:08 <bernalex> let g:ghcmod_ghc_options = ['-Wall'] " ghc-mod check -Wall
03:38:17 <bernalex> and you need au Bufenter *.hs compiler ghc
03:38:25 <bernalex> if you want auto stuff, add
03:38:28 <bernalex> autocmd BufWritePost *.hs GhcModCheckAndLintAsync
03:38:30 <bernalex> autocmd BufReadPost *.hs GhcModCheckAndLintAsync
03:38:39 <alex_698> au Bufenter *.hs compiler ghc?
03:38:52 <bernalex> alex_698: you could look at https://github.com/begriffs/haskell-vim-now
03:39:02 <bernalex> e.g. install it and figure out what you like in it, and get those plug-ins manually.
03:39:50 <bernalex> anyone know if there's a function 'x # y = (++ x) <$> y' defined somewhere?
03:40:20 <mniip> fmap . flip mappend
03:40:38 <bernalex> that's a bit nicer I guess
03:40:42 <bernalex> I wish <> were in prelude
03:40:49 <bernalex> like almost every day I program in haskell I wish that
03:42:02 <hjulle> iphy: (\x -> f x . g) is better. ((.g) . f) is less readable.
03:42:14 <iphy> I went with that, yes
03:42:50 <mniip> :t \x -> ?f x . ?g
03:42:51 <lambdabot> (?f::t -> b -> c, ?g::a -> b) => t -> a -> c
03:43:00 <mniip> dang
03:43:12 <mniip> it looked just a tiny bit like >=>
03:43:39 <iphy> no monads
03:44:22 <mniip> -> is a monad
03:44:49 <quchen> (r ->) is a monad.
03:44:49 <hjulle> mniip: no. "(->) e"  is a monad
03:44:59 <mniip> pedantry :)
03:45:04 <hjulle> :)
03:45:53 <quchen> EitherT IO is Maybe, up to pedantry.
03:46:08 <hjulle> -> is an arrow. ;)
03:46:12 <ongy> hjulle: yes, by another 5%, the inherited time for all of getPercent is 0.0 now, this is quite nice
03:46:31 <alex_698> bernalex: that was amazing man! it worked!
03:46:37 <alex_698> what should i do now
03:47:46 <bernalex> alex_698: according to a quick look, I have ghcmod, haskell-vim, hlint-refactor-vim, neco-ghc, vim2hs, vim-hsimport, haskellmode, and probably others. ymmv.
03:48:00 <hjulle> ongy: Nice :)
03:48:26 <alex_698> bernalex: same package.
03:51:42 <mniip> quchen, well usually when something is said to be an instance of some typeclass, and there's a kind mismatch that is satisfiable by applying it to a number of universally quantified variables, that is what we do
03:54:04 <bernalex> mpickering: ping?
03:58:08 <bernalex> mpickering: ok if you come back, or anyone else knows: I installed apply-refact + the vim plugin. but I can't do anything because "modifiable is off". how do I amend that?
04:00:47 <Gurkenglas> I want a data structure of all the (infinitely many) paths through a directed weighted graph, lazily evaluated in ascending order of the sum of weights on each path. I have an idea of what to use, but to not prime you, what should I use here?
04:02:17 <Gurkenglas> (actually it would be the paths starting in one node, but my actual problem is only morally equivalent to that)
04:10:51 <fr33domlover> Gurkenglas, I'd start with the 'fgl' package
04:11:09 <fr33domlover> If no such algorithm exists there, write your own using that package
04:11:59 <fr33domlover> Maybe you need some variation on the shortest-paths-tree algorithm
04:14:10 <haskell939> Why is this invalid
04:14:12 <haskell939> if not (all (elem str) str) then
04:15:57 <rydgel> haskell939: elem takes 2 parameters, you give it one
04:16:03 <opqdonut> that's not it
04:16:06 <opqdonut> he uses it with all
04:16:11 <rydgel> oh
04:16:13 <hjulle> :t elem
04:16:13 <rydgel> indeed
04:16:14 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
04:16:16 <sqrt2> haskell939: you want "not (all (`elem` str) str)", i suppose
04:16:44 <rydgel> :t not (all (`elem` str) str)
04:16:45 <lambdabot>     Not in scope: ‘str’
04:16:46 <lambdabot>     Perhaps you meant data constructor ‘Str’ (imported from Text.PrettyPrint.HughesPJ)
04:16:46 <lambdabot>     Not in scope: ‘str’
04:16:50 <opqdonut> haskell939: I'm not sure what you're trying to accomplish, but try "flip elem str" instead
04:16:51 <rydgel> whoops
04:16:57 <bernalex> OK so I added a Haskell server to the react tutorial: https://github.com/alexander-b/react-tutorial/blob/master/server.hs if anyone has any feedback before I pop off a pull request to facebook, that would be great. I'd love to make it even shorter (without sacrificing readability), so any ideas are welcome. there are feature equivalent servers in other languages in the same repo. 
04:17:00 <opqdonut> haskell939: i.e. "\x -> elem x str"
04:17:25 <opqdonut> haskell939: but it seems to me like that if would always end up in else
04:17:32 <opqdonut> because all characters in the string are in the string :)
04:17:42 <bernalex> well except I have a bug. :p but I'll get onto that now.
04:17:58 <opqdonut> @scheck \str -> all (\c -> elem c str) str
04:18:00 <lambdabot>  No instance for (Show (t0 a0)) arising from a use of ‘myquickcheck’
04:18:00 <lambdabot>  The type variables ‘t0’, ‘a0’ are ambiguous Note: there are several potentia...
04:18:33 <sqrt2> opqdonut: that's if they actually meant to use the same string in both places and didn't just write it like that for brevity
04:18:48 <opqdonut> @scheck (\str -> all (\c -> elem c str) str) :: String -> Bool
04:18:50 <lambdabot>  +++ OK, passed 100 tests.
04:18:53 <opqdonut> sqrt2: oh right
04:19:13 <bernalex> apparently lazy reading of a file is a terrible idea
04:19:20 <mfukar> haskell939: if you're trying to implement duplicate detection, start with the first element of a list, nodupes (x:xs) = not (elem x xs) ...
04:19:38 <bernalex> since I can't see any consistency as to whether the file handle will be closed in time or not
04:20:45 <haskell939> yeah duplicate detection
04:20:47 <haskell939> So I wrote this
04:20:55 <haskell939> 	hasDuplicate2 (x:xs) = elem x xs
04:20:56 <opqdonut> bernalex: yes, lazy io is terrible
04:21:15 <opqdonut> bernalex: iteratees / pipes / conduits are a good alternative
04:21:27 <mfukar> cool, so hasDuplicate2 detects if the first element of a list has a duplicate
04:21:33 <haskell939> now all I need is to iterate through
04:21:33 <bernalex> opqdonut: I just used strict readFile & encode . fromStrict
04:21:35 <mfukar> how do you extend it to the second?
04:21:45 <opqdonut> bernalex: that works too :)
04:21:50 <haskell939> if it is false
04:21:51 <opqdonut> if you don't need streaming
04:21:53 <haskell939> then use the xs
04:21:59 <haskell939> to call the same method
04:22:02 <haskell939> *function
04:22:19 <mfukar> awesome, and how would you write that?
04:23:16 <haskell939> hasDuplicate2 (x:xs) = if ((elem x xs) == false) then hasDuplicate2(xs) else true
04:23:27 <haskell939> and then I also need hasDuplicate2 [x] = x
04:23:57 <bernalex> ok bugs fixed. same request as before: any feedback on making this as tiny as possible yet readable would be great: https://github.com/alexander-b/react-tutorial/blob/master/server.hs
04:24:17 <bernalex> I don't think I can make it as tiny as the PHP version whilst preserving readability. :p
04:24:23 <mfukar>  actually, hasDuplicate x = False
04:24:24 <bernalex> not that the PHP version is in any way readable
04:24:34 <haskell939> oh
04:24:39 <haskell939> not [x] ?
04:24:57 <mfukar> [x], you're right
04:25:07 <hjulle> haskell939: hasDuplicate2 [] = False
04:25:16 <mfukar> there's an easier way too, what hjulle just said
04:25:52 <hjulle> Otherwise it will crash for an empty list.
04:26:08 <hjulle> But hasDuplicate2 _ = False works as well
04:28:51 <mfukar> haskell939: another way to write it which may be more readable to some is hasDuplicates (x : xs) = elem x xs || hasDuplicates xs
04:29:26 <sdx23> bernalex: for apply-refact: :set modifiable -- for whatever reason that's set in your buffer. Also: thanks for pointing that plugin out :)
04:29:43 <hjulle> bernalex: make it as tiny as the perl version instead. :P
04:29:44 <bernalex> rydgel: if you're back -- any feedback on https://github.com/alexander-b/react-tutorial/blob/master/server.hs would be great!
04:29:56 <bernalex> hjulle: suggestions for how to do that are welcome :p
04:30:06 <rydgel> bernalex: sure
04:30:08 <haskell939> Sorry this code is giving error for this string
04:30:11 <haskell939> with "." inside
04:30:22 <bernalex> sdx23: how do I make it so that haskell files just are modifiable in general? and what are the repercussions of this? :p
04:30:25 <haskell939> Program error: pattern match failure: crypt_v4249 []
04:31:00 <sdx23> bernalex: they should be. Rather debug why they're set not modifiable. :verbose set modifiable?
04:31:28 <sdx23> (the question mark is important. And of course in a file you just opened)
04:31:45 <bernalex> sdx23: that just spat out "modifiable"
04:32:37 <sdx23> bernalex: then that error doesn't make any sense to me. Are you sure it acts on the same buffer?
04:33:04 <bernalex> sdx23: oh wait. OK. I was trying to make refact work via the syntastic window, which is obviously not modifiable.
04:33:17 <rydgel> bernalex: looks fine to me :)
04:33:29 <bernalex> sdx23: OK so I have
04:33:29 <haskell939> Actually you are right
04:33:32 <bernalex> let g:hlintRefactor#disableDefaultKeybindings = 1
04:33:32 <haskell939> I changed [x] to x
04:33:34 <bernalex> map <silent> <leader>hr :call ApplyOneSuggestion()<CR>
04:33:35 <haskell939> and it worked fine
04:33:36 <bernalex> map <silent> <leader>hR :call ApplyAllSuggestions()<CR>
04:33:38 <haskell939> I don't know why
04:34:06 <bernalex> rydgel: then if I do e.g. hr in the file rather than in syntastic, it just doesn't do anything.
04:34:11 <bernalex> sorry sdx23 :]
04:34:55 <bernalex> ,hR says "[number of lines in file] lines filtered" but doesn't do anything visible at all.
04:34:58 <Tekkkz> Hello! I can export a haskell script for C (e.g. http://ix.io/vrX) but I only know how to compile it with a c program when I use ghc for compiling. how to do it like following: make a .o file with ghc, then compile it with my program in other compiler, how to do that?
04:35:43 <sdx23> bernalex: ok, then you need to check whether your dependencies are working. Try doing it on the command line via hlint file --refactor
04:36:39 <bernalex> sdx23: that just spits out the file. do you have an example where this would actually work?
04:36:56 <bernalex> I tried adding a useless import, and having two functions f x y = x and f x y = y, which it gives plenty of suggestions for.
04:38:52 <sdx23> bernalex: main = do print 42 -- should remove the do
04:39:30 <bernalex> sdx23: OK that works. I guess I overestimated how useful apply-refact was.
04:39:34 <sdx23> mpickering: why does "main = do print (42)" need two calls to `hlint test.hs --refactor`?
04:39:49 <sdx23> bernalex: just hlint suggestions, not ghc-mod
04:40:14 <bernalex> sdx23: yes I see now
04:40:25 <bernalex> would be super useful to have it for ghc-mod too
04:40:36 <bernalex> rydgel: thanks for looking!
04:40:53 <sdx23> bernalex: poke you-know-whom to that :)
04:41:01 <bernalex> dxld?
04:41:16 <bernalex> or mpickering?
04:41:21 <bernalex> someone just do it please :p
04:42:09 <haskell939> Sorry I couldn't get this syntax working
04:42:11 <haskell939> all (['a'..'z']) plaintext
04:42:21 <haskell939> I tried putting == beginning or the end
04:42:23 <haskell939> didn't work
04:42:45 <hjulle> bernalex: My spontaneous thought is a complete rewrite using servant instead of scotty, but I do not know if that would actually make it shorter. :P
04:43:02 <bernalex> hjulle: servant is nice, but I don't know it
04:43:35 <bernalex> I missed the lovely oslo-haskell meetup on it since I'm broke =/
04:45:29 <mpickering> sdx23: because the hints are overlapping so applying one might make the other invalid
04:48:32 <sdx23> I see. So this won't work in general, and can't.
04:49:29 <sdx23> However, I still find it quite neat. Thanks for your work!
04:54:24 <bernalex> what would be perfect with syntastic is if you could just browse the list of suggestions and hit enter, and have them applied.
04:56:22 <bennofs> Ugh Ctrl-C'ing a parallel cabal build run and then restarting it can lead to a successful compile that produces executables which fail with sigsegv (and the executables even run fine for *some* part) :/ Has anyone experienced that before, or should I spent the time to try to make a reproducible case? This is with GHC 7.10
04:56:37 <bennofs> you can also easily produce linker errors this way
04:56:57 <dcoutts_> bennofs: yes, that'd be interesting, to know if it's ghc or cabal or what at fault
04:57:56 <bennofs> dcoutts_: ok, i'll try to investigate later
04:58:33 <dcoutts_> bennofs: my first suspicion would fall on the linking. I think it doesn't do the atomic file write trick
04:59:13 <bennofs> dcoutts_: yes, I think this is because it produces incomplete object files when interrupted while doing a parallel build
04:59:20 <sdx23> bernalex: should be possible to code this, Syntastic just opens the Error window (if configured to).
04:59:46 <dcoutts_> bennofs: if it's .o files we should blame ghc, if it's .a / .so files we have to work around the linker
05:00:04 <bennofs> dcoutts_: I also got this error: gcc: error: dist/build/Game.dyn_o: No such file or directory
05:00:14 <bennofs> dcoutts_: and this could only be fixed by cabal clean
05:00:22 <dcoutts_> interesting
05:02:54 <bennofs> Does somebody know of a not-too-complex standalone (it shouldn't have too much external deps) executable haskell project with multiple modules I could use to try to reproduce this compilation bug?
05:03:22 <bennofs> a small library with a test suite would also work
05:08:56 <Gurkenglas> fr33domlover, I was thinking of something like FRPs Events, because those are all about the "up-to-one-point-in-time" lazily infinite stuff
05:10:12 <cocreature> bennofs: xmonad?
05:10:31 <bennofs> cocreature: that could work
05:10:35 <bennofs> thanks
05:34:27 <haskell939> textLookUp c = lookup c someTupleList
05:34:38 <haskell939> map (textLookUp) plaintext
05:34:48 <haskell939> how come this isn't returning String?
05:35:28 <cocreature> haskell939: because lookup can fail so it returns a Maybe Char
05:39:20 <haskell939> but now I changed it to
05:39:28 <haskell939> map (toLower) plaintext
05:39:31 <haskell939> still it doesn't return String
05:40:11 <cocreature> [Char] is String if that’s what’s confusing you
05:40:19 <cocreature> :t map toLower
05:40:21 <lambdabot> [Char] -> [Char]
05:41:52 <haskell939> so how do I do my original one
05:41:57 <haskell939> with lambda I'm guessing?
05:42:38 <sdx23> :t catMaybes
05:42:39 <lambdabot> [Maybe a] -> [a]
05:47:46 <ertes> haskell939: style note:  map (f) xs = map f xs
05:50:27 <EvanR> "0' the canonical turing complete set that can decide the halting problem"
05:51:00 <EvanR> what is a turing complete set, how can a set decide something
05:51:53 <EvanR> and i thought the halting problem was undecidable
05:52:47 <ertes> EvanR: look at the date
05:53:13 <EvanR> april 1
05:53:27 <cocreature> EvanR: sounds like they’re talking about sets of programs for which the halting problem is decidable
05:53:44 <EvanR> fuck the rent is due and thats not a joke
05:54:01 <ertes> not saying it can't be legitimate, but take everything today with a grain of salt =)
05:54:12 * EvanR not leaving the house
05:54:36 <EvanR> cocreature: ok. but in what way would such a set by turing complete
05:54:55 <cocreature> EvanR: oh I didn’t see that part
05:55:41 <mfukar> EvanR: a set of processor instructions may be Turing complete
05:55:53 <haskell939> okay I'm still stuck with the syntax
05:56:00 <haskell939> 	textLookUp2 c = 'a'
05:56:08 <haskell939> map (textLookUp2) plaintext
05:56:13 <haskell939> so all I wanna do is this now
05:56:15 <EvanR> if thats what it is then... guess its a joke
05:57:48 <haskell939> Is this wrong thing to do? Should I be looking at recursive method instead?
05:57:59 <ertes> haskell939: what are you trying to do?
05:58:11 <ertes> (i joined a few minutes ago)
05:59:04 <EvanR> > map (\c -> 'a') "plaintext"
05:59:05 <lambdabot>  "aaaaaaaaa"
06:00:13 <hjulle> How do you extract a value out of a maybe in a MonadPlus?
06:00:50 <ertes> hjulle: in a Maybe?
06:01:27 <ertes> s/in a/out of/
06:01:45 <hjulle> I want a function :: MonadPlus m => Maybe a -> m a
06:01:52 <bennofs> hjulle: are you looking for Data.Foldable.asum?
06:02:00 <bennofs> :t Data.Foldable.asum
06:02:01 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
06:02:15 <EvanR> @hoogle MonadPlus m => Maybe a -> m a
06:02:15 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
06:02:16 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
06:02:16 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
06:02:20 <haskell939> my bad it was another problem
06:02:31 <haskell939> turns out it was Either issue where I was not specifying the entire thing with ()
06:02:35 <hjulle> :t asum . fmap pure
06:02:36 <lambdabot> (Functor t, Foldable t, Alternative f) => t a -> f a
06:02:38 <ertes> hjulle: maybe mzero return
06:03:49 <dsub> :t maybe mzero return
06:03:50 <hjulle> And a third alternative would be do {Just x <- mx; return x}
06:03:50 <lambdabot> MonadPlus m => Maybe a -> m a
06:04:19 <ertes> hjulle: Just x <- pure mx
06:04:23 <ertes> s/pure/return/
06:04:37 <cocreature> that uses fail which doesn’t have to coincide with mzero afaik
06:04:44 <hjulle> Mostly I hoped that there was an existing function that does what I want
06:04:51 <hjulle> cocreature: aha, thanks
06:04:57 <ertes> hjulle: there is: maybe mzero return
06:05:42 <ertes> it's a function, and it does what you want =)
06:06:10 <hjulle> But it is not in the standard library, it's just in the irc chat ;)
06:06:34 <hjulle> I'm trying to write short code.
06:06:43 <ertes> if you really want this function to have a dedicated name, you can give it one, but i suggest not doing that for clarity =)
06:07:27 <hjulle> :t asum . fmap pure -- Is another alternative
06:07:28 <lambdabot> (Functor t, Foldable t, Alternative f) => t a -> f a
06:07:37 <ertes> short code…  as in a shortest-code contest or as in concise code?
06:08:14 <hjulle> Concise
06:09:06 <dsub> hjulle: as long as you're not code-golfing I suspect you wont get more concise/clear than "maybe mzero return". Three well known functions, clear for everyone who knows basic haskell.
06:09:18 <ertes> they i'd definitely go with the 'maybe' variant…  the 'asum' variant is anything but concise, because it introduces intermediate layers that you don't really need
06:09:40 <hjulle> I have multiple maybe-values that I want to extract, so I'll probably make a function.
06:10:25 <ertes> with GHC 7.10 (and i tend to assume that nowadays) i'd even write:  maybe empty pure
06:10:29 <haskell939> how can I remove Just with only Prelude stuff?
06:10:57 <ertes> haskell939: you can't *remove Just*, but you can *handle Maybe* by using 'maybe'
06:11:02 <ertes> :t maybe
06:11:03 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:11:34 <ertes> (and a bunch of other functions that are basically higher-level interfaces to 'maybe')
06:11:46 <haskell939> okay
06:11:49 <haskell939> I know that maybe only returns Just
06:12:04 <ertes> haskell939: i mean the function called 'maybe'
06:12:07 <hjulle> ertes: Thanks for the advice
06:12:17 <dsub> haskell939: no, the function named 'maybe' does return what you specify it to return
06:12:26 <haskell939> I know
06:12:38 <haskell939> but the case that I am in
06:12:45 <haskell939> it never returns Nothing
06:12:59 <haskell939> so maybe will always be just
06:13:06 <ertes> haskell939: you can just pretend that it could, if you can handle it sensibly
06:13:26 <ertes> haskell939: in your earlier example i would convert the Maybe values to singleton lists
06:13:26 <haskell939> okay I know i handle it sensibly
06:13:31 <ertes> and then i would use 'concat'
06:13:35 <haskell939> how?
06:13:47 <ertes> that's an exercise for you…  you can do it using 'maybe' =)
06:14:00 <haskell939> hmm
06:14:01 <ertes> maybeToList :: Maybe a -> [a]
06:14:09 <ertes> maybeToList = maybe _nothingCase _justCase
06:14:21 <ertes> fill in _nothingCase and _justCase
06:14:25 <haskell939> sorry but I can't use maybeToList
06:14:25 <cocreature> :t maybe _ _ :: Maybe a -> [a]
06:14:26 <lambdabot>     Found hole ‘_’ with type: [a1]
06:14:26 <lambdabot>     Where: ‘a1’ is a rigid type variable bound by
06:14:26 <lambdabot>                 an expression type signature: Maybe a1 -> [a1] at <interactive>:1:1
06:14:30 <haskell939> it's in Data.Maybe
06:14:39 <ertes> haskell939: you aren't *using* it, you are *defining* it
06:14:45 <haskell939> ah ok
06:14:50 <ertes> call it something else if you prefer
06:15:04 <dsub> :t catMaybes
06:15:05 <lambdabot> [Maybe a] -> [a]
06:15:21 <haskell939> no catMaybes
06:15:26 <haskell939> I can't use that
06:16:19 <haskell939> I'm still confused
06:16:32 <haskell939> at this point it looks overly complicated that it makes more sense just to use filter
06:16:45 <haskell939> than lookup function
06:17:09 <ertes> haskell939: just try it…  it's not that much more complicated, but it's a good exercise to do it by hand
06:18:02 <bennofs> haskell939: you can use fromJust, but it'll throw an error at runtime if you get a Nothing, so it's generally better to avoid using it
06:18:06 <bennofs> :t fromJust
06:18:07 <lambdabot> Maybe a -> a
06:18:17 <ertes> haskell939: right now you have a [Maybe Char], but you need [Char]…  you can go there in two steps: first make it a list of lists, then concat the list
06:18:30 <ertes> [Maybe Char] to [[Char]] to [Char]
06:18:54 <dsub> haskell939: You could define a function analogous to catMaybes
06:19:20 <haskell939> benoffs it's not in prelude
06:19:43 <bennofs> oh
06:20:33 <ertes> haskell939: the first step, if you decide to follow my advice, requires a function maybeToList, and i suggest that you try to define it now
06:20:46 <haskell939> I don't understand it
06:20:50 <haskell939> why do I make a char a list
06:21:00 <haskell939> maybe char a list
06:21:22 <ertes> haskell939: you can think of Maybe Char as a list of characters with at most one item
06:21:39 <ertes> you're converting it to a regular list, just so you can apply 'concat' and flatten it
06:21:46 <haskell939> okay
06:21:49 <dsub> myCatMaybes = foldr f [] where f Nothing acc = acc; f (Just x) acc = x : acc
06:22:09 <ertes> [Just 'a', Just 'b', Just 'c'] becomes [['a'], ['b'], ['c']] and finally ['a', 'b', 'c']
06:22:23 <haskell939> ok
06:22:30 <haskell939> but it only returns Just a anyway
06:22:31 <ggVGc> so, stack haddock generates all local docs, but what's the best way to browse them?
06:22:53 <haskell939> it only returns single maybe
06:22:55 <ertes> haskell939: you know that, but the compiler doesn't, so it wants you to handle it =)
06:23:08 <haskell939> how do I do that?
06:23:21 <haskell939> just a list to a list?
06:23:59 <ertes> haskell939: are you familiar with the basics of writing functions?
06:24:07 <haskell939> a bit
06:24:34 <ertes> haskell939: can you write maybeToList in a very straightforward pattern-matching way?
06:25:02 <haskell939> was pattern matching x:xs thing?
06:25:08 <ertes> like this:  maybeToList (Just c) = ...  -- and a case for Nothing, too
06:25:24 <haskell939> no
06:25:24 <ertes> haskell939: pattern-matching is when you handle arguments by individual cases
06:25:29 <haskell939> if else?
06:26:34 <ertes> haskell939: a list can be either of the form (x : xs) or of the form [], right?
06:26:45 <haskell939>  maybeToList (Just c) = if type c == Just then c else ""
06:26:47 <haskell939> like this?
06:27:30 <ertes> haskell939: nope…  let's do this step by step…  what should be the result of `maybeToList (Just 'c')`?
06:27:44 <ertes> (this is: Just the character 'c')
06:28:43 <ertes> maybeToList (Just 'y') = ?  -- don't show code, just tell me what you would expect as the result when you apply it like this
06:29:56 <haskell939> fromJust (Just x) = x
06:29:59 <haskell939> okay found it
06:30:23 <ertes> i give up
06:34:47 <dsub> :)
06:37:34 <dsub> ertes: I salute you for your efforts. You can't succeed every time :)
06:37:45 <haskell939> thank you very much for your help
06:37:49 <ertes> i didn't succeed, because once again fromJust was suggested to a beginner
06:38:21 <dsub> I know...
06:38:22 <haskell939> I didn't use library code
06:38:29 <haskell939> 	fromJust (Just x) = x
06:38:32 <haskell939> this works fine
06:38:34 <haskell939> as a definition
06:38:52 <merijn> haskell939: Oh? What happens when I run "fromJust Nothing"?
06:38:58 <haskell939> error
06:39:00 <haskell939> all around
06:39:14 <dsub> *facepalm*
06:39:54 <chelfi> haskell939: this is why ertes is suggesting you use a solution that does not error on Nothing
06:39:55 <dsub> haskell939: The use/meaning of having a "Maybe a" value is to ensure that the user checks for Nothing.
06:40:18 <haskell939> yes but I know that it doesn't return Nothing
06:40:23 <haskell939> for that special case
06:40:35 <ertes> haskell939: there is a solution that cannot cause run-time errors…  we have Maybe for a reason…  but don't get me wrong: i don't blame you, i blame the #haskell channel =)
06:41:10 <Ferdirand> some languages are perfectly happy with that kind of semantic though
06:41:13 <haskell939> anyway
06:41:17 <haskell939> I'm going to go to bed now
06:41:23 <haskell939> I'll start with data stuff tomorrow
06:41:25 <chelfi> haskell939: the problem is you may or may not be wrong, while if you use a solution that handles all cases your program does not depend on you being right
06:41:40 <Ferdirand> Java has null, and the most infuriating inexplicable error you see popping up all the time is the NullPointerException
06:41:44 <haskell939> I just checked data it seemed overly complex
06:41:57 <ertes> haskell939: it's unfortunate that you need to *create* Maybe values in the first place in this case, but since you do, you could just as well learn to handle them properly, and that's what i was trying to teach
06:42:13 <haskell939> ertes: I understand that
06:42:29 <haskell939> but if that needed then I would use the library code anyway
06:42:45 <haskell939> fromJust :: Maybe a -> a fromJust Nothing = error "Maybe.fromJust: Nothing" fromJust (Just x) = x
06:42:47 <haskell939> like that
06:43:02 <haskell939> this handles error case
06:43:06 <ertes> haskell939: you shouldn't use fromJust at all, neither the library version nor your own
06:43:17 <dsub> haskell939: That does not handel error case
06:43:44 <haskell939> ok sorry
06:43:58 <haskell939> I'm really tired been learning haskell for like 10 hours
06:44:01 <haskell939> I need to sleep
06:44:11 <ertes> haskell939: fromJust is what we call a *partial* function…  and in haskell you should never consider any code that uses partiality to be a *solution*
06:44:28 <haskell939> who knows maybe I'll see some monad in my dream
06:45:01 <ertes> in some very specific cases we use them as *hacks*, but as a beginner try not to resort to hacks
06:45:14 <haskell939> ok sorry
06:45:18 <ertes> anyway, sweet monadic dreams, try again tomorrow =)
06:46:36 <merijn> Relevant: https://hackage.haskell.org/package/acme-safe-0.1.0.0/docs/Acme-Safe.html#v:safeFromJust
06:47:11 <ertes> haskell939: no need to be sorry…  again: i don't blame you in the slightest…  it's never the beginner's fault =)
06:47:54 <hpc> someone should make an acme-coerce package that consists solely of useful safe functions that have valid unsafeCoerce implementations
06:48:03 <hpc> (ghc-only of course)
06:48:12 <ertes> hpc: Data.Coerce?
06:48:49 <hpc> :t null
06:48:50 <lambdabot> Foldable t => t a -> Bool
06:49:23 <merijn> :t let safeCoerce :: Coercible a b => a -> b; safeCoerce = unsafeCoerce in safeCoerce
06:49:25 <lambdabot>     Not in scope: type constructor or class ‘Coercible’
06:49:25 <lambdabot>     Not in scope: ‘unsafeCoerce’
06:49:25 <lambdabot>     Perhaps you meant ‘safeCoerce’ (line 1)
06:49:28 <merijn> :p
06:49:54 <hpc> i was more thinking about things like
06:50:01 <hpc> listNonEmpty :: [a] -> Bool
06:50:05 <hpc> listNonEmpty = unsafeCoerce
06:53:33 <EvanR> hpc: thats so gross
06:54:10 <bernalex> hpc: some of us wish for good high-level GUI frameworks, physics engines, high-level opengl libraries... but YOU... you're thinking about all the important stuff that really matters.
06:55:18 <bernalex> ertes: you can write a safe fromJust
06:55:32 <bernalex> fromJust :: Maybe a -> Maybe a
06:55:35 <bernalex> fromJust = id
06:55:38 <bernalex> there!
06:57:02 <hpc> bernalex: i actually use a similar stunt in acme-php to avoid giving away the trick of my true/false shennanigans at the top of the file
06:57:11 <hpc> look at the coerce in sortBy
06:57:29 <hpc> just curious how far it can go
06:58:46 <xa0> bernalex: look at what merijn linked ;)
07:00:02 <bernalex> xa0: yes, I was confident such a thing had to exist. after all, all the good concepts in informatics are discovered rather than invented.
07:08:14 <joneshf-laptop> Is this a fair re-characterization of the Traversable identity law: `traverse pure == pure`?
07:08:42 <ertes> bernalex: safeLaunchTheRockets = pure ()
07:09:01 <ertes> now you can safely launch the rockets – even in every Applicative, not just IO
07:09:58 <Ferdirand> how unreasonable is it to define an instance Monoid (IO ()) ?
07:10:22 <bernalex> Ferdirand: that should be in GHC 7.12 or something.
07:10:22 <ertes> Ferdirand: unreasonable in the same way as:  instance Monoid Integer where mappend = (+)
07:10:40 <bernalex> ertes: hm? () is already a Monoid, and so in IO a.
07:10:55 <ertes> Ferdirand: but it would be reasonable to do something like Sum and Product
07:11:01 <bernalex> (for a being a Monoid)
07:11:23 <ertes> i.e. newtype wrappers for the various semantics you can implement as a monoid
07:15:32 <apsod> Aren't things like (Monoid a, Applicative f) => Monoid (f a) valid?
07:16:41 <merijn> apsod: Yes, every Applicative is a Monoid if it's content is
07:16:51 <ertes> apsod: they are, but for example Maybe implements a different monoid
07:16:52 <merijn> apsod: The problem is there's at least 6 or so valid Monoid instances
07:17:01 <merijn> ertes: The Maybe Monoid is wrong anyway
07:17:04 <merijn> It's an atrocity :\
07:17:45 <ertes> merijn: it's correct and has been very useful to me
07:18:20 <bernalex> what's wrong with the Maybe Monoid? looks OK to me
07:18:20 <apsod> Are there others viable Monoid instances for (f a) given (Monoid a, Applicative f)? 
07:18:31 <apsod> It should have a semigroup constraint on the inner type
07:18:33 <merijn> bernalex: mempty should be "Just mempty", not Nothing
07:18:36 <ertes> oh, btw, that beginner problem above could have been solved with it =)
07:18:48 <merijn> Alternatively "Semigroup a => Monoid (Maybe a)"
07:18:50 <ertes> :t foldr (<>) Nothing
07:18:52 <lambdabot> (Foldable t, Monoid a) => t (Maybe a) -> Maybe a
07:19:00 <ertes> oh, no
07:19:48 <dsub> Why should it be "Just mempty"?
07:20:03 <bernalex> merijn: hm. I think I agree.
07:20:19 <bernalex> for all things like that, I greatly prefer letting the leaves decide.
07:20:32 <merijn> dsub: Because "(Monoid a, Applicative f) => Monoid (f a)" should clearly have "mempty = pure mempty"
07:20:59 <ertes> merijn: i don't see why
07:21:06 <merijn> If you DON'T want "mempty = pure mempty" you clearly want Alternative
07:21:19 <merijn> Which has "Alternative f where empty :: f a"
07:21:37 <ertes> merijn: you can't have Alternative for all monoids that break that
07:21:46 <ertes> the Maybe monoid is actually an example of that
07:21:53 <merijn> ertes: Oh? In what way?
07:22:06 <ertes> try implementing the current Maybe monoid as an Alternative
07:22:47 <merijn> ertes: I didn't say you'd get the same behaviour
07:23:04 <ertes> merijn: but what if you *want* that behaviour?
07:23:11 <ertes> with your law you couldn't use Monoid
07:23:21 <merijn> ertes: Then my version works just as well?
07:23:29 <ertes> you'd need MyOwnMonoidThatIsNotRelatedToApplicativeInAnyWay
07:23:48 <merijn> ertes: Which is why the Monoid for applicatives does not exist
07:23:54 <merijn> To many valid implementations
07:24:11 <merijn> Adding one for Maybe is just inconsistent with lack of Monoid for anything else
07:24:17 <merijn> Especially since it's so questionable
07:24:42 <ertes> merijn: i don't understand…  Monoid is a nice generic class…  why would you restrict it with an arbitrary law "type constructor and also Applicative"?
07:24:53 <ertes> +if
07:25:23 <aaakfp> if I have   data X = A { _a :: Int } | B { _b :: Int } | C, then given stuff :: [A] I can write stuff ^.. traverse._a to get As or traver._b to get Bs, but how do I get A or Bs (and not Cs)?
07:26:30 <ertes> merijn: i don't see any inconsistency with the current Maybe monoid…  it's useful, and it's a perfectly valid monoid
07:27:04 <dsub> aaakfp: foldr f [] where f C acc = acc; f x acc = x : acc
07:27:05 <apsod> ertes: Because the current instance Monoid (Maybe a) is overspecified and arbitrary. Like having Monoid Integer where mappend = (+)?
07:27:14 <merijn> ertes: I'm saying that we don't have monoid instance for Applicative because there's too many valid ones. Maybe, arbitrarily DOES have a Monoid instance chosen for it and it's a highly undesirable one
07:27:29 <dsub> aaakfp: or, I might have misunderstood
07:27:53 <ertes> well, i agree on that part…  but then Maybe shouldn't have *any* Monoid instance
07:27:57 <merijn> ertes: There's plenty of valid monoids in existence, we don't implement most of them because they're too arbitrary. The one for Maybe is to arbitrary
07:28:10 <ertes> because using the liftA2 (<>) monoid is just as arbitrary
07:28:27 <gfixler> if I let 2 + 2 = 5, is there a way to unlet it?
07:28:34 <merijn> ertes: "Semigroup a => Monoid (Maybe a)" is ok, since Maybe is the free monoid for semigroups, but anything else is too arbitrary
07:28:39 <gfixler> tried :undef (+), but it doesn't accept it
07:28:46 <ertes> gfixler: you can have an inner let that shadows it yet again
07:28:52 <aaakfp> dsub: I was hoping for some lens magic.  If there are lots of C, D, E.. and I already have the lens traversals, it seems that it should be possible to compose the two traversals.
07:28:54 <gfixler> ertes: d'oh
07:28:59 <hjulle> bernalex: [react-tutorial] Why are you using strict byte strings when reading the JSON file?
07:29:08 <gfixler> ertes: wait... that means I need to know the def for (+)
07:29:20 <ertes> gfixler: yes…  you can't "unshadow"
07:29:42 <ertes> gfixler: but you can at least qualify with the module name:  (Prelude.+)
07:29:50 <bernalex> hjulle: because lazy io means that whenever I want to write to the file it can be unaccessible if the rts wants it to be.
07:30:04 <dsub> aaakfp: Ah, ok. sorry for confusion. Don't know lenses.
07:30:05 <gfixler> ertes: yeah, just tried it, but...
07:30:07 <gfixler> <interactive>:73:11: parse error on input `Prelude.+'
07:30:14 <gfixler> doesn't like Prelude.(+) either
07:30:22 <ertes> gfixler: (Prelude.+)
07:30:28 <gfixler> ertes: ah, just noticed that
07:30:38 <bernalex> hjulle: originally I read it lazily, but whenever you tried adding a comment it would 80% of the time complain that the file was locked (by lazy readFile).
07:30:49 <gfixler> ertes: sweet - thanks
07:31:01 <ertes> :t readFile
07:31:02 <lambdabot> FilePath -> String
07:31:25 <bernalex> :t Data.ByteString.Lazy.readFile
07:31:26 <lambdabot> FilePath -> IO BSLC.ByteString
07:31:46 <hjulle> bernalex: aha
07:32:22 <bernalex> hjulle: come to think of it, I should have investigated if I couldn't just make everything strict, and use Text instead of String.
07:32:34 <ertes> > readFile "blah"
07:32:36 <lambdabot>  "*Exception: blah: openFile: does not exist
07:32:45 <bernalex> but usually that means ending up with 100 SLOC extra, whereof 95 SLOC are imports. :p
07:32:59 <bernalex> i.e. imports + extensions
07:33:01 <rydgel> Lazy IO is dangerous
07:33:08 <rydgel> should be forbidden
07:33:43 <bernalex> with unrestrained resources, lazy IO is very elegant.
07:34:06 <bernalex> but oleg fixed it http://okmij.org/ftp/Streams.html
07:34:12 <Xnuk> @let a + b = a - b
07:34:12 <rydgel> bernalex: well, using conduit / pipes / iteratees is elegant too
07:34:13 <lambdabot>  .L.hs:178:17:
07:34:14 <lambdabot>      Ambiguous occurrence ‘+’
07:34:14 <lambdabot>      It could refer to either ‘L.+’, defined at .L.hs:185:3
07:34:27 <bernalex> rydgel: true. although I'm not very experienced with it.
07:34:37 <bernalex> Xnuk: please don't overload prelude terms. it makes lambdabot very annoying to use.
07:35:00 <bernalex> rydgel: *them
07:36:26 <Xnuk> bernalex: Is @undef a big deal?
07:36:30 <ertes> > writeFile "/etc/passwd" "blah"
07:36:31 <lambdabot>  *Exception: /etc/passwd: openFile: permission denied
07:37:00 <MarcelineVQ> how odd, it usually does't seem to even try to execute IO
07:37:01 <bernalex> Xnuk: it's annoying when someone has defined some legitimate and useful things in order to help someone, but then they have to undefine everything because someone thought it would be funny to have + be - or whatever.
07:37:18 <ertes> don't think so
07:37:19 <merijn> MarcelineVQ: Someone probably defined an Exception with that definition
07:37:22 <ertes> :t writeFile
07:37:23 <lambdabot> FilePath -> String -> ()
07:37:46 <ertes> :t getLine
07:37:47 <lambdabot> String
07:38:12 <ertes> > getLine
07:38:16 <lambdabot>  mueval-core: Time limit exceeded
07:39:31 <solirc> aristid: `base-compat` does not provide Proxy, the reason for this is that this would collide with the one defined in `tagged`.  But you can use `tagged` for backward compatibility instead.
07:39:46 <hjulle> bernalex: I tried porting the code to servant, but it ended up being a bit longer.
07:39:50 <aristid> solirc: that's what i ended up doing :)
07:39:57 <solirc> aristid: ok :)
07:45:02 <hjulle> bernalex: readComments = liftIO $ decode . fromStrict <$> readFile "comments.json" -- Is simpler and not less readable in my opinion
07:47:40 <ggVGc> what do I do if I want to keep the warning for unused binds, but have some code I want to keep in the project but that's not used right now?
07:47:52 <ggVGc> and don't want warnings about it
07:47:55 <xa0> prefix them with _
07:48:48 <merijn> ggVGc: "_ <- foo"
07:49:08 <merijn> Depending on which binds you mean
07:49:59 <bergmark> you can also do _don'tWarnAboutThese = undefined myFoo myBar
07:50:44 <ggVGc> bergmark: hah! I like that hack
07:50:45 <ggVGc> thanks
07:50:58 <xa0> that's what i was suggesting -_-
07:51:06 * xa0 will be clearer next time
07:51:34 <hpc> xa0: bergmark's suggestion is slightly different
07:51:51 <xa0> oh
07:51:56 <hpc> that suggestion makes myFoo and myBar have unused warnings ignored by way of being used
07:51:58 <xa0> whoops, didn't read properly
07:52:00 <hpc> by a thing that is itself ignored
07:52:10 <xa0> fair enonugh
07:52:42 <hpc> a cheeky application of your more general suggestion ;)
07:52:55 <xa0> :p
07:56:25 <bernalex> hpc: I guess
07:57:43 <Lokathor> oh no! ghc is already at version 8.2 today and you missed the 8.0 release this whole time!
07:57:56 <LysergicDreams> I'm trying to make a Servant-Postgresql template for stack. I stuck it in ~/.stack/templates but `stack new` doesn't find it.
08:02:29 <ggVGc> is this a reasonable way to store application modes in a way that's comparable? https://gist.github.com/06679ffb4b20cea4ffd5cd4f1957e696
08:02:46 <ggVGc> the application modes contain function reference, so are now comparable without some identifier
08:02:55 <ggVGc> figured a static map was the most reasonable way?
08:17:56 <jophish> What does "Source" mean here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/src/OccName.html#NameSpace
08:18:21 <jophish> Is it just "Data constructors defined by the user, not build in ones" or something?
08:20:50 <gfixler> jophish: it says a few lines down
08:20:56 <gfixler> "[Source data constructors] The data constructors mentioned in Haskell source code"
08:21:19 <jophish> ah, silly me. Thanks gfixler 
08:24:49 <armlesshobo> is there a way to compose a list of IO actions?
08:25:02 <PrincessLuna> []
08:25:03 <armlesshobo> I want the result of one IO action to be the input of the next
08:25:10 <gfixler> >>= ?
08:25:21 <PrincessLuna> ah
08:25:43 <gfixler> getLine >>= putStrLn, e.g.
08:26:02 <armlesshobo> i was thinking something like forM
08:26:06 <PrincessLuna> sorry I totally misinterpreted your question
08:26:08 <armlesshobo> errr
08:26:45 <armlesshobo> i think it would be foldl instead
08:26:50 <Hafydd> armlesshobo: foldM
08:26:56 <armlesshobo> ahh ok
08:26:57 <pmade> What about foldM with (>>=)?
08:27:00 <armlesshobo> ^
08:27:02 <armlesshobo> thank you
08:27:08 <armlesshobo> that's what I was looking for
08:27:11 <armlesshobo> (i think)
08:27:14 <armlesshobo> that sounds right to me
08:27:34 <jophish> > foldr1 [putStrLn "hello", print 4]
08:27:35 <lambdabot>      Couldn't match expected type ‘a -> a -> a’
08:27:36 <lambdabot>                  with actual type ‘[IO ()]’
08:27:36 <lambdabot>      In the first argument of ‘foldr1’, namely
08:28:19 <PrincessLuna> if you want [a -> IO a] -> a -> IO a
08:28:22 <jophish> err, excuse me
08:28:23 <PrincessLuna> something along the lines of
08:28:28 <PrincessLuna> :t foldr (>=>)
08:28:29 <lambdabot> (Monad m, Foldable t) => (b -> m c) -> t (b -> m b) -> b -> m c
08:28:30 <armlesshobo> Hafydd, pmade, PrincessLuna, gfixler: thank you
08:28:36 <armlesshobo> :t foldM
08:28:38 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
08:29:18 <PrincessLuna> :t foldr (>=>) return
08:29:19 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
08:31:16 <armlesshobo> it'd need to take in a list
08:31:31 <armlesshobo> :t foldM (>>=)
08:31:32 <lambdabot> (Monad m, Foldable t) => m a -> t (a -> m (m a)) -> m (m a)
08:32:03 <armlesshobo> err
08:32:25 <armlesshobo> nvm
08:34:48 <Hafydd> ...well, I suppose that isn't what you want.
08:34:51 <Hafydd> :t foldl' (>>=)
08:34:52 <lambdabot> (Monad m, Foldable t) => m a -> t (a -> m a) -> m a
08:34:56 <Hafydd> :t foldr (flip (>>=))
08:34:57 <lambdabot> (Monad m, Foldable t) => m a -> t (a -> m a) -> m a
08:36:19 <armlesshobo> Hafydd: yeah, but foldM is what I want
08:36:24 <Hafydd> Also known as foldr (=<<).
08:36:31 <Hafydd> armlesshobo: really?
08:36:41 <armlesshobo> except I'd pass in my function as the second argument
08:36:46 <armlesshobo> not (>>=)
08:37:16 <Hafydd> armlesshobo: if you have such a function, then I suppose that would work.
08:37:36 <armlesshobo> I'm assuming that (b) is the accumulator
08:37:52 <armlesshobo> and that the accumulator is passed into the function
08:38:25 <armlesshobo> I'll have to try it when I get home, but I have a good feeling about it
08:38:31 <Hafydd> armlesshobo: which b?
08:38:41 <armlesshobo> :t foldM
08:38:42 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
08:38:51 <armlesshobo> first b in the function
08:38:54 <Hafydd> Yes.
08:38:56 <armlesshobo> is the current accumulator
08:39:00 <armlesshobo> passed into the function
08:39:10 <armlesshobo> the second is the starting accumulator
08:42:03 <Hafydd> :t foldM (flip id)
08:42:04 <lambdabot> (Monad m, Foldable t) => b -> t (b -> m b) -> m b
08:43:06 <Hafydd> That also achieves what you initially described, but is less clear than using a standard fold, I think.
08:43:12 * hackagebot c2hs 0.28.1 - C->Haskell FFI tool that gives some cross-language type safety  https://hackage.haskell.org/package/c2hs-0.28.1 (IanRoss)
08:43:48 <Hafydd> However, foldM would be useful if you have a list of pure values that you want to combine in a monadic fashion.
08:43:56 <armlesshobo> yes
08:43:59 <armlesshobo> exactly what I have
08:44:03 <Hafydd> I see.
08:48:14 <armlesshobo> using foldM is the most concise, elegant way of going about it
08:48:55 <armlesshobo> for this scenario
09:10:57 <nitrix> Hi, what does `vector` means by "Copy a vector. The two vectors must have the same length and may not overlap."
09:11:00 <nitrix> May not overla[?
09:12:36 <monochrom> it is possible for "two" vectors to share the same memory. for example slicing does that.
09:20:52 <nitrix> I see.
09:21:11 <nitrix> So when you slice, if you get rid of the parent, the slice still needs the full vector in memory?
09:21:39 <monochrom> in fact yes.
09:21:55 <nitrix> It makes sense. Otherwise you wouldn't have O(1) complexity for slicing.
09:23:21 <monochrom> there is "clone" to say you want the opposite. copying out a small part so you can forget the big parent.
09:23:30 <nitrix> Right.
09:23:36 <nitrix> monochrom: Thanks :)
09:23:38 <monochrom> these are also true of bytestring and text
09:24:07 <nitrix> Oh o: !
09:24:53 <c_wraith> wasn't there another type specifically for not supporting that case? something like smallstring? 
09:24:54 <monochrom> in fact the trio {bytestring, text, immutable vector} all use the same low-level ideas and optimizations, and they inspire each other.
09:25:31 <nitrix> monochrom: Do you think it's sane to use a vector for a 2D array?
09:25:47 <nitrix> I looked at repa and it's.... overkill to say the least.
09:26:41 <c_wraith> it's sane, though there are two very different cases. 
09:27:10 <c_wraith> if it's a regular 2d array of known size, a single vector and some math for indexing. 
09:27:11 <monochrom> repa throws in parallelization, of course
09:27:32 <LysergicDreams> How do I use custom templates with Stack?
09:27:35 <c_wraith> if it's irregular, a vector of vectors still makes sense. 
09:27:51 <nitrix> c_wraith: It's regular.
09:28:17 <c_wraith> and yeah.. repa's complexity is so that you can get parallelism for no additional cost. 
09:28:18 <nitrix> The only problem is that, I might need to grow the X or Y axis, which means copying a lot of elements when resizing.
09:28:38 <c_wraith> not free.. you still have to pay the cost of understanding repa
09:30:00 <c_wraith> nitrix, best way to avoid that is making it too big, marking the edges of the in-use space, and using an exponential growth when in-use exceeds available 
09:30:20 <nitrix> c_wraith: Right.
09:30:33 <nitrix> Which is what you'd expect a vector to do, but oh well.
09:30:58 <nitrix> It's all wrapped in a module of mine anyway.
09:31:19 <c_wraith> even if vector did that, it'd only handle the 1d case, and the copying used by growing the 2d case is very different 
09:32:05 <monochrom> oh w00t, I may like to put that on the assignment when I teach amortization and growing arrays this summer
09:46:20 <hjulle> How do people usually place where clauses after do-notation? I'm unsure of which levels of indentation to use in different places.
09:46:50 <hjulle> (It's the estetics and readability I'm after)
09:47:17 <dmj> two spaces
09:47:23 <dmj> hjulle: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
09:52:11 <johnzorn> What does the .*. operator do in: a .*. b = listArray ... 
09:54:03 <PrincessLuna> johnzorn, it is being defined
09:54:38 <andromeda-galaxy> Cale: on the performance from yesterday: I got Cmm but I can't read it..
09:58:32 <hjulle> dmj: thx
09:59:14 <johnzorn> PrincessLuna: Ahh ok, explains why google was so unhelpful
10:00:23 <andromeda-galaxy> on a completely different front, does anyone know why this works: 'put empty :: forall t1 t2. (forall s. StateT (StateType t1 t2) (ST s) ())' but this doesn't: 'type MyMonad t1 t2 = forall s. StateT (StateType t1 t2) (ST s); put empty :: forall t1 t2. MyMonad t1 t2 ()' doesn't?
10:01:42 <dmj> hjulle: yw
10:04:52 <andromeda-galaxy> and, in the absence of impredicativity, is there any way to do that that doesn't invovle writing ':: forall t1 t2. (forall s. StateT (StateType t1 t2) (ST s) v)' all over the place?
10:08:15 <hjulle> andromeda-galaxy: What is StateType? I couldn't find anything on hoogle.
10:08:48 <andromeda-galaxy> hjulle: just my application-specific type holding on the the relevant state
10:10:20 <andromeda-galaxy> hjulle: at some point, StateType will probably include a few STRefs
10:15:25 <hjulle> andromeda-galaxy: It works if you add the type of the monadic value to MyMonad: "type MyMonad t1 t2 a = forall s. StateT (StateType t1 t2) (ST s) a"
10:15:48 <andromeda-galaxy> hjulle: interesting... do you know why?
10:16:15 <hjulle> Nope, just found out by testing different stuff
10:17:13 <andromeda-galaxy> hjulle: ah, okay, thanks; I'll probably try using that anyway  I've been trying to leave the type out so that it's possible to partially apply the synonym, etc. if necessary, but I don't think I'm actually using that anywhere so I'll try it anyway
10:17:40 <hjulle> My guess is that the value get the type "(forall s. StateT (StateType t1 t2) (ST s)) a" instead of "forall s. StateT (StateType t1 t2) (ST s) a"
10:17:46 <icicled> jle`: hiya, I've just discovered your prompt library & have been playing around with it - it's really neat!
10:18:26 <icicled> jle`: do you have any further examples - e.g. showing now to integrate it into a transformer stack?
10:19:04 <hjulle> andromeda-galaxy: I believe you can still partially appy the synonym even if you have an explicit variable.
10:19:12 <hjulle> *apply
10:19:19 <andromeda-galaxy> hjulle: ah right, that makes sense now, I see why impredicative types are needed there
10:19:28 <GLM> What is the canonical to map over nested monads (IO Either)?
10:19:35 <andromeda-galaxy> hmm, really? let me double check
10:19:37 <icicled> jle`: you mention abstracting over database calls for instance - I'm wondering what that would look like
10:19:42 <EvanR> a metric space seems to be defined in terms of a function from (X,X) to real numbers which satisfies some properties. is the real numbers here necessary to the proper functioning of metric spaces?
10:19:54 <EvanR> or is that just the most common choice
10:20:40 <EvanR> its not clear what aspects of real numbers are important just from the definition of metric space
10:20:53 <hjulle> GLM: If I understand your question correctly: using monad transformers.
10:21:09 <EvanR> GLM: fmap . fmap ?
10:22:00 <hjulle> Or fmap.fmap
10:22:52 <Sonderblade> EvanR: i dont know about haskell, but a metric space can certainly be defined using rational numbers
10:24:36 <andromeda-galaxy> hjulle: right, this came up a while ago when I was playing with Kleisli arrows, and also when reading the singletons paper: as far as I can tell, HS doesn't allow partially applied type synonyms (or similarly, partially applied type families), only newtypes and data types
10:25:21 <EvanR> Sonderblade: ok, so the important aspect is that it is a field?
10:25:33 <EvanR> ordered field
10:25:52 <EvanR> (even though the negations are not used)
10:27:15 <EvanR> DCPOs seem to be inappropriate because we want all distances to be comparable
10:28:18 <Sonderblade> EvanR: idk, i've seen a prof create a metric space using only rational numbers. how he did it or how it works i have no idea
10:28:44 <EvanR> if thats the case, then completeness isnt important
10:29:48 <Sonderblade> right. metric spaces does not need to be complete
10:29:54 <andromeda-galaxy> hmm, anyone know how to make stack use ghc master? 8.0.1-rc2 won't build hashtables
10:30:40 <EvanR> so maybe all you need is a total order with a least element zero and a monoidal operation for the triangle inequality
10:30:47 <EvanR> i.e. a monoidal chain
10:32:35 * Sonderblade realizes he is in over his head and politely exits the discussion
10:34:49 <ggVGc> how would I best model this two-way mapping? https://gist.github.com/6760801797dd10c22a371d1fd7813585
10:35:43 <EvanR> use a data type with an encode and decode operation
10:36:18 <Industrial> Hi, i'm new to the language and I'm wondering what is being passed into the defaultConfig function here https://gist.github.com/Industrial/30f0f7aeb30ba93f7c42a22fed1dee7b#file-xmonad-hs-L3
10:36:20 <EvanR> looks like you have one, you just need to move that code into its own two functions
10:37:08 <EvanR> Industrial: its record update syntax
10:37:29 <Industrial> Because, coming from JavaScript, that reads as passing an Object/Map but I guess it isn't because I can't replace that with `xmonad $ defaultConfig myConfig` and then somewhere `myConfig = {}` <-- syntax error
10:38:07 <EvanR> foo {a = b, c = d} will return a new record equal to foo but with a and c replaced 
10:38:27 <Industrial> right
10:38:33 <sleblanc> In GHCI, is there a way to assign a new value with an expression that refers to the previous value of same name, ignoring recursion semantics? e.g. let i = 0 :: Int; let i = toInteger i
10:38:53 <geekosaur> Industrial, so we are taking the current value of defaultConfig and then specifying replacements for some of the things inside it
10:38:57 <EvanR> so {a = b, c = d} doesnt work by itself
10:39:08 <geekosaur> record update syntax is sadly not first class, so you can't separate off the {} part
10:42:45 <geekosaur> sleblanc, there is not (but I think I've seen a ticket requesting it?)
10:44:29 <lyxia> let b = a\nlet a = f b
10:44:51 <jdreaver> Is there a library out there that can parse JSON at compile time into an Aeson Value? I'm working with a lot of JSON object literals, and they just look nicer when they are in JSON.
10:44:52 <EvanR> unreclet
10:46:14 <hpc> template haskell?
10:46:27 <sleblanc> geekosaur, thanks for the input
10:47:03 <jdreaver> yeah I'm assuming I have to use template haskell
10:47:21 <EvanR> there is template haskell to put strings into your code in various ways, which you can put a `parse' around
10:48:24 <jdreaver> Hmm, that sounds like the best approach. I was hoping someone else already did the work, but I'm alright with rolling my own :D
10:48:34 * geekosaur is thinking quasiquoter, actually
10:49:00 <hpc> QQs are TH
10:49:49 <EvanR> [json| {eat: "this"}]
10:49:53 <EvanR> oops
10:49:59 <EvanR> [json| {eat: "this"} |]
10:50:28 <EvanR> http://hackage.haskell.org/package/aeson-qq
10:50:58 <jdreaver> Oh awesome, thanks so much!
10:51:13 <geekosaur> right, was suggesting what to look for
10:51:32 * geekosaur is on a concall atm, so a bit "scattered"
11:02:26 <adas> If I enable DataKinds and do ' symbolVal (Proxy "hello")', it prints "hello" but when I do "symbolVal (Proxy 'Nothing)" it does not work. why is that?
11:05:37 <tippenein> getting this on travis - ghc failed to compile a sanity check. Please see:
11:06:19 <tippenein> also /usr/bin/ld: cannot find -lgmp
11:06:45 <tippenein> anyone run into this before? locally or otherwise
11:08:24 <armlesshobo> tippenein: that second message seems to be that you don't have the gmp library installed
11:08:28 <armlesshobo> or that it can't find it
11:08:52 <armlesshobo> https://gmplib.org
11:12:00 <armlesshobo> tippenein: could you provide a link to the full error output?
11:12:05 <armlesshobo> please*
11:12:10 <tippenein> https://travis-ci.org/tippenein/scrape_the_truth
11:12:21 <tippenein> I added the libgmp as an addon and pushed again
11:14:30 <tippenein> heh, seemed to get past that error. thanks
11:14:34 <tippenein> now it's - canonicalizePath: does not exist
11:15:05 <tippenein> it's weird because I've used the same travis file for everything, and this is the only one that has caused problems
11:19:23 <adas> If I enable DataKinds and do ' symbolVal (Proxy "hello")', it prints "hello" but when I do "symbolVal (Proxy 'Nothing)" it does not work. why is that?
11:26:17 <dmj`> anyone familiar with an array list implemenation in haskell, preferrably using vector
11:28:13 <andromeda-galaxy> adas: symbolVal needs a KnownSymbol instance which I believe ghc provides for type-level strings, which have kind "Symbol"
11:29:28 <andromeda-galaxy> 'Nothing has kind 'Maybe k, not Symbol
11:32:23 <Guest20723> grep >
11:34:10 <adas> ah okay. thanks for clarification
11:47:12 <jle`> icicled: hi!  thanks!  have you seen my blog post about the library?
11:49:28 <jle`> adas: hm, neither one of the one you showed should work
11:50:00 <jle`> they don't work with the 'Proxy' in base, at least
11:50:11 <jle`> are you using a different Proxy type?
11:53:11 <adas> jle`: Data.Proxy
11:54:18 <merijn> jle`: Good point
11:56:15 <jle`> adas: maybe you meant `symbolVal (Proxy :: Proxy "hello")`
11:58:41 * hackagebot luis-client 0.0.2 - An unofficial client for the LUIS NLP service.  https://hackage.haskell.org/package/luis-client-0.0.2 (MicxjoFunkcio)
11:58:43 * hackagebot regex-type 0.1.0.0 - Type-level regular expressions  https://hackage.haskell.org/package/regex-type-0.1.0.0 (kcsongor)
11:59:49 <adas> jle`: yup
12:11:39 <schell> is it possible to have a 2d Unboxed Vector?
12:12:03 <schell> Unbox a => Vector (Vector a)
12:12:35 <merijn> You can't unbox vectors, because they don't have a fixed size
12:12:45 <merijn> therefore you can have an unboxed vector of unboxed vectors
12:12:47 <schell> thanks - i thought that seemed fishy
12:13:18 <schell> you mean - you *can’t* have an uboxed vector of unboxed vectors
12:13:55 <EvanR> or you can use a 1D vector and index math
12:14:14 <schell> right - i don’t trust myself that much though
12:15:03 <schell> what about using Data.Vector.Generic as the outer vector? that seems legit
12:15:45 <schell> or i guess that’s just Data.Vector
12:20:50 <merijn> schell: eh, can't :)
12:21:07 <schell> i figured! just wanted to make sure ;)
12:21:12 <merijn> schell: Sure, a boxed vector containing unboxed vectors is fine
12:21:46 <merijn> schell: In fact, making sure all values have the same size is the entire reason boxing exists, so this is basically why we have boxed values to begin with :)
12:22:21 <merijn> But yeah, as EvanR points out it's often easier to use 2d coordinates to index into a 1D vector
12:22:30 <hjulle> What is the status of Data.Array? Doesn't those support 2d-arrays?
12:22:48 <merijn> hjulle: Yes, but everything is boxed there
12:22:55 <schell> i’m just getting into Vector, so i appreciate it
12:22:58 <hjulle> aha
12:23:03 <merijn> schell: The magic keyword is "dimension reduction"
12:23:35 <merijn> A common technique for implementing higher dimensional arrays (for languages that have them) using 1 dimensional arrays (i.e., RAM :p)
12:24:26 <schell> that’s basically doing ndx = (y * width + x)?
12:25:25 <hjulle> merijn: https://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array-Unboxed.html
12:25:34 <schell> technically my vectors have dimension just because it’s a vector in a vector, but i don’t care about indexing so much as traversal
12:26:21 <merijn> schell: Basically, yes
12:26:25 <quchen> Hah, after hours of implementing the STG, enabling -Wall ......aaaand: Haskell magic! http://lpaste.net/158094
12:26:58 <schell> though now my problem finding a concat that works with two different vector types
12:27:05 <quchen> After writing quite a bit of Coffeescript in the last weeks, this project reminded me of the enormous amount of headache I did not have to put up with due to typing. Yipeeee! :-)
12:27:16 <merijn> quchen: ;)
12:27:34 <ggVGc> has anyone here used this? https://nikita-volkov.github.io/record/
12:27:46 <schell> B.Vector (U.Vector a) ->  U.Vector a 
12:32:36 <eitanC> Is it possible to use an infix operator as a constructor name in a GADT?
12:33:48 <shachaf> Yes.
12:34:07 <merijn> eitanC: : is (arbitrarily) considered an uppercase symbol character
12:34:09 <eitanC> thanks shachaf, how’s it going? do i need any special extensions?
12:34:18 <merijn> eitanC: Therefore any operator starting with : is a constructor
12:34:24 <shachaf> No, it works the same way as any other infix constructor.
12:34:36 <shachaf> If you want to use GADT syntax you need to use parentheses, of course.
12:34:39 <eitanC> oh, must the operator begin with : then
12:34:41 <eitanC> ?
12:34:44 <hjulle> Yes
12:34:44 <shachaf> You can also express every GADT without using GADT syntax.
12:34:46 <shachaf> Yes.
12:34:57 <eitanC> thanks!
12:35:27 <merijn> shachaf: That seems like a typo? How do you represent "data Foo a where Foo :: a -> Foo Int" without GADT syntax?
12:36:20 <eitanC> data Foo a = forall a. Foo (a -> Int) ?
12:36:27 <shachaf> merijn: data Foo a = forall b. a ~ Int => Foo b
12:36:43 <merijn> huh
12:36:49 <merijn> Learn something new everyday :)
12:37:29 <EvanR> the power of ~
12:43:01 <PrincessLuna> ah yes
12:43:09 <PrincessLuna> coercions
12:43:43 * hackagebot prometheus 0.3.1 - Prometheus Haskell Client  https://hackage.haskell.org/package/prometheus-0.3.1 (LukeHoersten)
13:01:27 <ggVGc> okay I'm taking the plunge. adding lenses to a project for the first time
13:10:25 <Guest_98765> http://cur.lv/wo54f
13:11:38 <hjulle> Spam ^
13:12:08 <hpc> spam spam spam spamity spaaaaaam!
13:17:15 <cubuspl42> Why are you spamming?
13:19:48 <tippenein> Looking for advice on avoiding utf8 encoding errors while scraping with handsomesoup
13:21:32 <WeaponX> hi all, say I have a bunch of functions in a list, how do I apply them in sequence to a single value?
13:21:40 <WeaponX> :t sequence
13:21:42 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:21:48 <WeaponX> this is not it
13:23:04 <tippenein> :t mconcat
13:23:05 <lambdabot> Monoid a => [a] -> a
13:23:24 <tippenein> not that either?
13:23:25 <WeaponX> f [(+1),(*3)] 5 should be 18
13:23:39 <geekosaur> :t foldr ($) a
13:23:40 <lambdabot> Foldable t => t (Expr -> Expr) -> Expr
13:23:47 <ahihi> > foldr (flip (.)) id [(+1), (*3)] 1
13:23:49 <lambdabot>  6
13:23:56 <WeaponX> oh nice
13:24:26 <ahihi> oh, 5 not 1
13:24:28 <ahihi> but anyway :P
13:24:32 <WeaponX> any way to rewrite that in a more elegant manner?
13:24:54 <ahihi> I'm sure there is some operator equivalent to flip (.)
13:24:57 <hpc> > sequence [(+ 1), (* 3)] 1
13:24:59 <lambdabot>  [2,3]
13:25:14 <hpc> oh, hmm
13:25:29 <ahihi> > foldr (>>>) id [(+1), (*3)] 5
13:25:30 <lambdabot>  18
13:25:31 <hpc> :t \fs z -> foldr (flip (.)) id fs z
13:25:32 <lambdabot> Foldable t => t (c -> c) -> c -> c
13:26:00 <WeaponX> :t (>>>)
13:26:01 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
13:26:02 <hpc> > mconcat [(+ 1), (* 3)] 1
13:26:04 <lambdabot>      No instance for (Show a0)
13:26:04 <lambdabot>        arising from a use of ‘show_M871434106644083863318067’
13:26:04 <lambdabot>      The type variable ‘a0’ is ambiguous
13:26:21 <hpc> > mconcat [(+ 1) :: Int -> Int, (* 3)] 1
13:26:22 <lambdabot>      No instance for (Monoid Int) arising from a use of ‘mconcat’
13:26:23 <lambdabot>      In the expression: mconcat [(+ 1) :: Int -> Int, (* 3)] 1
13:26:27 <hpc> ppppf
13:26:41 * hpc gives up
13:26:54 <WeaponX> :t foldr (>>>) id
13:26:55 <lambdabot> Foldable t => t (c -> c) -> c -> c
13:27:00 <geekosaur> > foldl (flip ($)) 5 [(+1),(*3)]
13:27:01 <lambdabot>  18
13:27:15 <WeaponX> cool
13:28:13 <tippenein> I think the >>> version is most succinct
13:29:08 <WeaponX> how can I tell what version of GHC powers this lambdabot?
13:29:21 <hjulle> tippenein: But it requires an additional import and uses less common functions
13:29:28 <hpc> @version
13:29:28 <lambdabot> lambdabot 5.0.3
13:29:28 <lambdabot> git clone https://github.com/lambdabot/lambdabot
13:29:30 <ahihi> oh, (>>>) is from Control.Category. I thought I was using Arrow :)
13:29:45 <hpc> @ghcversion
13:29:46 <lambdabot> Unknown command, try @list
13:29:49 <hpc> hmm
13:31:51 <int-e> hpc: 7.10.2
13:32:12 <geekosaur> @version
13:32:12 <lambdabot> lambdabot 5.0.3
13:32:12 <lambdabot> git clone https://github.com/lambdabot/lambdabot
13:32:15 <WeaponX> > foldl1 (.) [(+1),(*3)] 5
13:32:16 <lambdabot>  16
13:32:18 <geekosaur> oh, it's not in there any more
13:49:07 * hackagebot overloaded-records 0.4.0.0 - Overloaded Records based on current GHC proposal.  https://hackage.haskell.org/package/overloaded-records-0.4.0.0 (PeterTrsko)
13:52:49 <icicled> jle`: yep I did see the blog post, however I am new to transformers - thus I was seeking your input
13:54:57 <icicled> something more than a trivial example would be really helpful - e.g. here's a transofmrer stack with prompt & this is an appropriate use of it while this other method is not
13:55:19 <icicled> that kind of docs are rare in haskell land from what I can tell =]
13:57:25 <schell> is there an equivalent function to “withArray” for Vector?
13:57:28 <tommd> You want an example of an incorrect transformer stack?
13:57:58 <icicled> sure, along with some useful ones
13:59:11 <icicled> I've been getting by with: ReaderT MyEnv (ExceptT Text IO) a
14:00:47 <icicled> with that particular stack I can't test my application without standing up the entire environment around IO (database, files, etc)
14:01:21 <icicled> I was hoping that with the "prompt" package I could achieve some level of testability without providing an entire IO enviornment
14:02:56 <andromeda-galaxy> is there a particularly efficient way to implement Data.Map's insertWith with Data.HashTable.ST.Cuckoo?
14:19:16 <mick_> Hi, how can I print a list of doubles in my program. main = putStrLn $ show [1,2]  works but if I put in a list of doubles it fails.
14:19:42 <mick_> No instance for (Show (IO [Double])) arising from a use of ‘show’
14:19:57 <mick_> do I need to create an instance or is there a library I can use
14:20:07 <dmj> :t print =<< (undefined :: IO [Double])
14:20:08 <lambdabot> IO ()
14:20:12 <monochrom> show actual complete verbatim code. the problem is elsewhere.
14:20:58 <dmj> mick_: you'll have to pull the list out of I/O first
14:21:14 <dmj> well, "out of I/O", meaning, use bind
14:21:35 <mick_> you mean in a `do` block?
14:21:49 <dmj> mick_: well do blocks for monads are just sugar for >>=
14:21:55 <dmj> and >>
14:21:55 <mick_> yeah
14:21:59 <mick_> ok let me try that
14:22:54 <wedify> why do '(1-(-0.99^80))/1.99' and '(1-(-0.99^80))/1-(-0.99)' yield such different results? (0.7 vs 2.4)
14:23:20 <quchen> wedify: Because of how floating-point arithmetic works on computers.
14:23:31 <quchen> > 0.1 + 0.2
14:23:32 <monochrom> is it simply because a/(b-c) is not the same as a/b-c?
14:23:32 <hpc> no, it's
14:23:32 <lambdabot>  0.30000000000000004
14:23:34 <mick_> great - it works now guys
14:23:35 <mick_> thanks
14:23:39 <dmj> \o/
14:23:44 <hpc> what monochrom said
14:23:47 <quchen> Oh.
14:23:55 <quchen> Went ahead too fast.
14:24:02 <hpc> it's usually floats though
14:24:05 <quchen> The danger of canned responses ;-)
14:24:09 <hpc> but not for a difference that wide
14:24:27 <quchen> Is there a flag to change the number of unmatched patterns GHC displays in warnings?
14:24:29 <hpc> it'd be nice to not have to open that can so often ;)
14:25:10 <wedify> monochrom: oh of course
14:25:52 <wedify> but then does this mean khan academy is wrong?
14:26:10 <wedify> cause it says the answer is 2.4 
14:26:51 <wedify> the problem is to find the sum of the geometric series: 1-0.99+0.99^2-0.99^3....
14:33:13 <quchen> Hm, are pattern guards in conjunction with -fwarn-incomplete-patterns broken? I get a warning that I missed a pattern (which has a pattern guard in the same definition). I thought maybe GHC assumed that all pattern guards fail, but when I add a fallthrough, it complains that my patterns are overlapped. :-|
14:33:53 <hjulle> wedify: Unless you read the question wrong, it actually seems like they are wrong.
14:34:10 <monochrom> wedify: the limit is 1 / (1 + 0.99)
14:34:11 <maerwald> > >.>
14:34:12 <lambdabot>  <hint>:1:1: parse error on input ‘>.>’
14:34:14 <maerwald> :t >.>
14:34:15 <lambdabot> parse error on input ‘>.>’
14:35:12 <monochrom> it also agrees with sum (reverse (take 4000 (iterate (* (-0.99)) 1)))
14:35:40 <monochrom> (I do a reverse in hope that it's safer for floating point)
14:35:46 <hjulle> And with wolfram alpha: https://www.wolframalpha.com/input/?i=sum+(-0.99)%5En+from+0+to+80
14:37:27 <Lokathor> so, if i stick a ref type (such as IORef, or TVar) into my Reader, can you modify the contents of the ref and have that be carried forward? Or does the modification do some sort of shadowing-esque magic that doesn't work with Reader's immutability?
14:37:56 <dmj> Lokathor: if your monad is an instance of MonadIO
14:37:57 <hpc> those are mutable and would work as expected, yes
14:38:01 <hpc> if that
14:38:11 <hpc> you do need to be able to do the mutation as well ;)
14:38:28 <Lokathor> hmm, i've had some troubles with that in the past, but I wasn't sure if it was because of having refs nested inside of refs, or if they just weren't Reader friendly in general
14:38:42 <hpc> you probably just had bugs in your code
14:38:49 <Lokathor> :O
14:38:53 <Lokathor> but probably
14:39:05 <hpc> they're pretty straightforward, but completely explicit and it feels weird to use them at first
14:39:09 * hackagebot interruptible 0.1.0.0 - Monad transformers that can be run and resumed later, conserving their context.  https://hackage.haskell.org/package/interruptible-0.1.0.0 (marcosdumay)
14:39:26 <EvanR> Lokathor: refs inside refs sounds kind of nuts
14:39:30 <hpc> you'll get used to it and embrace the horrors of impurity
14:39:41 <EvanR> but will work if you "know what youre doing"
14:39:48 <hpc> (even though it's technically still pure)
14:39:49 <dmj> unless you're making some kind of mutable linked list
14:39:51 <Lokathor> well, it was a TVar inside of a TVar, and then i'd update the contents of the inner TVar without putting that back inside the outer TVar.. and then other threads wouldn't see the changes properly
14:39:59 <Lokathor> so it was nested refs AND concurrency :3
14:40:00 <EvanR> it can also cause insane weirdness, like javascript or ruby when you do mutation
14:40:09 <dmj> Lokathor: why the nesting?
14:40:25 <Lokathor> "it seemed reasonable at the time"
14:40:44 <hpc> wait, do you even have to put back in the outer TVar?
14:40:48 <Lokathor> but then it went from working, to totally not working, and i just rewrote it all from scratch without nesting and things got fixed
14:41:04 <hpc> i guess so for transactional stuff
14:41:17 <hpc> i would avoid that nesting, yeah
14:41:45 <monochrom> no, there is no need of "putting back". the whole idea is a myth.
14:42:07 <EvanR> what, i havent heard this myth
14:42:13 <EvanR> how does it go
14:42:17 <hpc> monochrom: wouldn't the mutation make it register as an unexpected change and make the transaction retry?
14:42:26 <hpc> or is that tracked separately?
14:42:26 <Lokathor> well i wanted a map of room name to room data, but the room data was also in a tvar, so once a user was connected they'd be in just 1 room and their thread just had their own tvar. but it ended up with users nor seeing each other's updates, however i got it wrong
14:42:57 <dmj> why was the name in a tvar?
14:43:06 <EvanR> as a first step you can keep your entire program state in 1 TVar / MVar
14:43:36 <Lokathor> oh i know, i mean it works *now*
14:43:39 <EvanR> and it does not contain any TVars or MVars
14:43:43 <Lokathor> that's just how the failed design went
14:45:11 <hjulle> andromeda-galaxy: Without access to the internals of the module, I don't think you can get much better than just a lookup followed by an insert.
14:46:17 <andromeda-galaxy> hjulle: okay, that's what I suspected; I was just wondering if someone had come up with a version that did use the internals of the module to get better performance
14:46:41 <EvanR> have you tried HashMap
14:49:04 <andromeda-galaxy> EvanR: HashMap?
14:49:14 <andromeda-galaxy> is that the Data.HashMap from base?
14:49:27 <andromeda-galaxy> I've been trying to stay clear of IO, hashtables is a (supposedly fast) ST version
14:49:38 <EvanR> its not a hashtable
14:49:51 <EvanR> it claims to perform better on Map-like stuff that uses string keys
14:50:04 <EvanR> its not IO
14:50:22 <lpaste> monochrom pasted “TVar (TVar Char)” at http://lpaste.net/158100
14:50:35 <monochrom> hpc: ^ an experiment
14:50:47 <andromeda-galaxy> EvanR: oh I see, Data.HashMap from unordered-containers.  sorry, I got slightly confused
14:51:17 <andromeda-galaxy> I haven't tried that yet, I was looking for an asymptotic performance improvement
14:51:29 <EvanR> over log ? ;)
14:51:37 <EvanR> me too
14:51:54 <andromeda-galaxy> yes, I was going for O(1) instead of O(log n)
14:52:00 <EvanR> without IO?
14:52:15 <andromeda-galaxy> ideally...
14:52:23 <Lokathor> monochrom, okay, now again with STMContainers.Map, and have lookups in the map dynamically generate a new TVar if they don't find the one they're looking for, and then all of that thread's future edits only affect the TVar from the lookup :P
14:52:40 <andromeda-galaxy> (these tables are likely to contain hundreds of thousands of elements, which is why I wanted the asymptotic improvement)
14:53:44 <EvanR> which operation are you optimizing
14:54:35 <monochrom> mutable hash tables still does not give you O(1), you know?
14:55:54 <monochrom> unless you have scientific evidence that you always land in the "average" case
14:55:58 <hjulle> andromeda-galaxy: What keys do they have?
14:56:25 <andromeda-galaxy> EvanR: insert/delete/lookup
14:56:34 <andromeda-galaxy> hjulle: depends, this is part of a library
14:56:36 <EvanR> string keys?
14:56:50 <EvanR> oh, any Ord key
14:57:11 <andromeda-galaxy> (or Hashable)
14:59:09 * hackagebot liquid-fixpoint 0.5.0.0 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  https://hackage.haskell.org/package/liquid-fixpoint-0.5.0.0 (EricSeidel)
15:08:05 <blume> Good evening.
15:08:30 <dmj> blume: hey there
15:44:11 * hackagebot haste-gapi 0.1.0.0 - Google API bindings for the Haste compiler  https://hackage.haskell.org/package/haste-gapi-0.1.0.0 (nyson)
15:52:56 <blume> oh wait theres other compilers than ghc
15:52:59 <blume> 
15:53:03 <blume> ?
15:53:04 <blume> jk
15:53:19 <blume> have you heard that - o no u havent,
15:53:28 <xa0> are there really though
15:53:40 <xa0> ghc effectively IS haskell at this point, which is very sad
15:53:40 <blume> hmmmm
15:53:48 <blume> :o
15:53:52 <blume> let's discuss.
15:54:07 <blume> that sadness.
15:55:14 <danza> hi all, i am trying to set up an HTTPS Manager for http-client, but i am a bit lost. I think that i should use this record accessor http://hackage.haskell.org/package/http-client-0.4.2.2/docs/Network-HTTP-Client.html#v:managerTlsConnection, but i am not sure how
15:57:56 <blume> uh oh
15:59:45 <blume> im sure theres soimeone whos gonna help  you danza . sadly itza not me, mario. im luigi, your long losyt brother. i c what u did thear! now ..... go no w8 im sorry take this. <~@34567890
16:00:38 <blume> lambdabot: why is ghc == haskell?
16:00:57 <EvanR> ghc == haskell
16:00:59 <PrincessLuna> because plain haskell is boring
16:00:59 <EvanR> type error
16:01:10 <PrincessLuna> any more or less advanced haskell program makes use of extensions
16:01:42 <PrincessLuna> some of those extensions are so advanced that it's almost impossible to imagine another compiler reimplementing them all
16:02:10 <EvanR> there are multiple c++ compilers though...
16:02:30 <blume> so many l
16:02:31 <blume> reddit | wiki | help | credits | donate
16:02:38 <blume> anguages to choose from
16:02:46 <blume> oops
16:02:57 <blume> how did THAT happen
16:03:07 <blume> reddit | wiki | help | credits | donate
16:03:14 <blume> was not on purpose
16:03:25 <blume> plz no kick <3
16:03:55 <blume> forgive me, o haskell <3
16:04:18 <blume> you beautiful ..... language!
16:04:37 <blume> who needs ghc when you know about monads
16:04:50 <blume> or w/e typeclass right
16:04:50 <PrincessLuna> EvanR, C++ compilation is not as advanced
16:05:08 <blume> youre still so simple its unbelievable
16:05:21 <PrincessLuna> it's a sequence of heuristics called "optimizations"
16:05:37 <EvanR> c++ seems terribly complicated
16:05:40 <EvanR> even without optimizations
16:05:42 <PrincessLuna> typechecking haskell, on the other hand
16:05:43 <blume> yea
16:06:02 <blume> boredom? follow the types !
16:06:15 <PrincessLuna> that's without KitchenSink
16:06:20 <blume> its been a while
16:07:30 <quchen> EvanR: That's what I thought
16:07:49 <PrincessLuna> hmm, interesting
16:08:10 <PrincessLuna> if we have data EqBox a where EqBox :: Eq a => a -> EqBox a
16:08:22 <PrincessLuna> \(EqBox x) (EqBox y) -> x == y
16:08:29 <PrincessLuna> which typeclass dictionary does that use
16:08:41 <PrincessLuna> the first argument's or the second's?
16:09:51 <PrincessLuna> the two dictionaries should be the same
16:09:53 <quchen> ?let data EqBox a where EqBox :: Eq a => a -> EqBox a
16:09:54 <enthropy> PrincessLuna: it doesn't work
16:09:54 <lambdabot>  Defined.
16:09:57 <PrincessLuna> but nevertheless
16:10:04 <quchen> :t \(EqBox x) (EqBox y) -> x == y
16:10:05 <lambdabot> EqBox t -> EqBox t -> Bool
16:10:17 <PrincessLuna> enthropy, it doesn't?
16:10:22 <enthropy> oops, I was thinking about data EqBox2 where EqBox :: Eq a => a -> EqBox
16:10:23 <quchen> > (\(EqBox x) (EqBox y) -> x == y) (EqBox ()) (EqBox ())
16:10:24 <lambdabot>  True
16:10:53 <PrincessLuna> but what if
16:10:59 <PrincessLuna> instead of Eq, it was, say, Reifies
16:11:04 <PrincessLuna> that would be different
16:11:30 <EvanR> can you make a class where you can tell which dictionary was used
16:16:11 <enthropy> PrincessLuna: seems to be the second argument's dictionary
16:19:12 * hackagebot haste-gapi 0.1.0.1 - Google API bindings for the Haste compiler  https://hackage.haskell.org/package/haste-gapi-0.1.0.1 (nyson)
16:19:26 <enthropy> https://gist.github.com/aavogt/8e6a32595087ec9ed30de5b7226bb0df
16:19:32 <PrincessLuna> EvanR, Reifies
16:20:19 <enthropy> EvanR: or maybe simpler:   class C a where whichInstanceOfC :: a -> String?
16:25:03 <PrincessLuna> ooh
16:25:13 <PrincessLuna> I can't do that with Reifies
16:27:13 <enthropy> ghc isn't consistent between versions with that True/False
16:29:12 * hackagebot bindings-wlc 0.1.0.0 - Bindings against the wlc library  https://hackage.haskell.org/package/bindings-wlc-0.1.0.0 (ashleyis)
16:31:35 <PrincessLuna> oooh
16:31:45 <PrincessLuna> yeah reflection is smarter than me apparently
16:32:27 <ph88> try a mirror
16:32:34 <PrincessLuna> the "fake" dictionary is always bound to a quantified tyvar, that never unifies with other such dictionary
16:32:37 <PrincessLuna> other than itself
16:36:55 <Synaptic> hey, newbie here. quick question: can you access a data constructor used as a parameter in constructing another adt when defining an instance method?
16:37:56 <shachaf> You should clarify your question, maybe with some code.
16:38:22 <Synaptic> gotcha, gimme a sec.
16:40:41 <Synaptic> paste here: http://lpaste.net/158105
16:41:34 <geekosaur> the problem there is you don't want to use Size in the instance
16:41:45 <geekosaur> Size is a type, you want a value pattern
16:41:56 <geekosaur> also, parentheses
16:42:02 <geekosaur> show (Ball size) = ...
16:42:14 <lpaste> schell annotated “No title” with “No title (annotation)” at http://lpaste.net/158105#a158106
16:42:20 <Synaptic> gotcha
16:42:25 <Synaptic> thanks for the info
16:42:31 <schell> yar
16:42:51 <EvanR> "This is not a title"
16:43:03 <schell> lol
16:46:02 <desophos> are there "interface-oriented" (as opposed to "object-oriented") languages? i think haskell is like this in that it groups functionality into typeclasses which concrete types can implement (and allows polymorphism based on typeclass) but doesn't have "methods" bound to types, right? as opposed to something like java that has "objects" (which "own" both state and methods that operate on that state) and allows you to factor out methods into
16:46:02 <desophos>  "interfaces". this idea naturally seems to lead to complete partitioning of functions from state... are there languages that *enforce* this division?
16:46:30 <desophos> i might be thinking about this wrong, please enlighten me :)
16:47:59 <Hafydd> desophos: the process of defining a typeclass instance involves associating a method implementation with a certain type. Is that not what you mean?
16:48:57 <shachaf> Cale: Rice's theorem isn't about indiscreteness, just connectedness, right?
16:50:32 <Cale> It's about indiscreteness in a certain sense
16:52:20 <Hafydd> desophos: I don't think the distinction between "methods" and "state" has much use when all data is immutable and all functions are pure. They both become simply ways of extracting information about a value.
16:52:26 <shachaf> Well, it talks about decidability, not semidecidability, so it seems like it's about clopen sets to me.
16:52:43 <schell> is there a specific reason why Vector doesn’t have a Functor instance?
16:53:05 <Cale> shachaf: oh, you have a point...
16:53:12 <desophos> Hafydd: i think that's not quite what i mean; i'm wondering if it's possible to make a type simply a collection of method implementations
16:54:26 <desophos> Hafydd: maybe have abstractions that separate data structure from method implementation
16:54:37 <Hafydd> desophos: given that there's no subtype polymorphism in Haskell, that also doesn't seem useful except to group the methods under a "namespace".
16:57:03 <Cale> shachaf: So suppose T is the type of languages recognised by Turing machines. Does it have a nontrivial open set?
16:57:22 <Hafydd> desophos: but there is an idea in Haskell of having a type of values which are just collections of methods.
16:57:57 <Hafydd> As exposited here: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
16:59:11 <verement> schell: it doesn't?
16:59:44 <schell> it didn’t seem to - i’m changing from List to Vector and had to change all my fmap to V.map
17:00:20 <shachaf> Cale: Well, what's your topology?
17:00:27 <schell> ah - it’s *Unboxed* vectors
17:00:33 <shachaf> Cale: (I realize that I'm asking you the same question you just asked me.)
17:00:43 <schell> i’m guessing because with fmap you could change the type to something that’s not unboxed
17:01:59 <verement> makes sense
17:02:00 <schell> I’m a Vector noob, so these are all revelations for me
17:02:26 <schell> looking at the type of Data.Vector.Unboxed.map explained it
17:02:33 <schell> http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed.html#g:21
17:05:46 <desophos> Hafydd: hmm, that's interesting but i don't fully understand it due to not knowing enough haskell
17:08:30 <desophos> Hafydd: what use is a type without a data constructor?
17:08:36 <desophos> does that have a use?
17:08:40 <shachaf> Cale: Oh, now I remember asking about this: https://plus.google.com/+ShachafBenKiki/posts/8Vkzum3WL7G
17:08:49 <shachaf> (And also my other G+ post.)
17:09:13 <wedify> desophos: phantom type?
17:09:43 <monochrom> even a phantom type has data constructors. (they just are boring.)
17:10:35 <monochrom> but instead I'm going to be anal and ask: what does "have" mean?
17:10:52 <monochrom> take a look at bytestring, or text, or vector.
17:11:06 <monochrom> does ByteString "have" a data constructor?
17:11:23 <monochrom> if you break the abstraction boundary and "read the source code", it clearly dos.
17:11:48 <monochrom> but if you're an end-user and not supposed to break the abstraction boundary, then it clearly doesn't.
17:12:14 <monochrom> but does it mean that an end-user cannot use the ByteString type? even cannot create and use ByteString values?
17:12:42 <monochrom> so, what does "have" mean? is it a yes for ByteString? is it a no for ByteString?
17:12:51 <monochrom> and does it matter?
17:15:39 <Hafydd> desophos: types such as (->) Int do not have data constructors.
17:15:49 <desophos> i guess i shouldn't be asking these questions yet; i'm still a haskell beginner
17:15:52 <Hafydd> (That is a type constructor.)
17:16:22 <EvanR> @src Void
17:16:22 <lambdabot> Source not found. I feel much better now.
17:17:06 <maerwald> glad there is no Void too :D
17:18:01 <desophos> i was just thinking about taking the concept of interfaces to the extreme, really
17:18:02 <monochrom> there is Void. it is just younger than @src.
17:18:45 <monochrom>  @src is an independently handwritten collection that was set in stone 10 years ago. maybe 15 years go.
17:19:00 <monochrom> that's right, it can have nothing to do with reality
17:19:16 <wedify> desophos: i think with associated types and class definitions you have what you're looking for
17:19:24 <monochrom> it just happens that the handwritten code is of educational value
17:19:24 <maerwald> monochrom: so lambdabot lives in a dreamworld?!
17:19:54 <monochrom> no. @src lives in its own world.
17:20:08 <maerwald> where is this world?
17:20:15 <monochrom> you understand that lambdabot contains a lot of plugins that are pretty independent of each other, don't you?
17:20:35 <monochrom> so that one plugin doesn't tell you anything about lambdabot
17:20:55 <maerwald> sure it does
17:20:59 <EvanR> we should silently replace @src with a command that wgets the latest branch of GHC finds the code and directly pastes it, and see what happens
17:21:01 <maerwald> where's the code to that plugin?
17:21:03 <monochrom> for another example @pl does not accept all of Haskell syntax. but > does.
17:21:23 <EvanR> maerwald: @src spits out a file which is on someones computer
17:21:28 <desophos> wedify: cool! looking forward to learning those then
17:21:28 <maerwald> EvanR: well, some thing in base are optimized and may not be of educational value
17:21:40 <maerwald> so if you just get the real source code of functions...
17:21:41 <EvanR> they can edit the file
17:21:54 <monochrom> EvanR: you will have to address this question: if there are two implementations, one under #ifdef and one under #else, which one to choose?
17:22:03 <maerwald> #else
17:22:53 <EvanR> in that case activate emergency mode and suck the user who typed @src into VR and send them on a quest to find the lost define macro
17:23:01 <monochrom> in fact you can have as many as 4*2 branches: (#ifdef Linux, #elseifdef Windows, #elseifdef Mac, #else) x (#ifdef Haskell98, #else)
17:23:11 <maerwald> always choose #else :P
17:23:34 <wedify> first implementation found
17:23:45 <EvanR> ok, the 4 lost define macros of dark water
17:24:05 <monochrom> maerwald: most of the #else branches are uninformative. for example IIRC for pseq, the #else branch is pseq = seq.
17:24:29 <desophos> thanks for humoring my fancies, Hafydd wedify monochrom
17:24:45 <monochrom> it's basically #ifdef GHC pseq = the real thing #else pseq = seq
17:25:19 <andromeda-galaxy> Does anyone know why adding ST to the base of my monad transformer stack might increase performance a lot (200000 operations go from 1.3s to 760ms)?
17:25:36 <monochrom> the example may be not pseq. but look under the concurrency library in base. there are plenty of this.
17:27:18 <Cale> andromeda-galaxy: In place of what? Identity?
17:27:40 <andromeda-galaxy> Cale: yes, a hidden identity
17:27:48 <wedify> desophos: i wonder if the ultimate in interfaces is specifying operations and laws they obey
17:27:56 <Cale> bizarre
17:27:56 <monochrom> I want to reproduce this experiment.
17:28:03 <andromeda-galaxy> (it was a change from State MyState -> forall s. StateT (MyState s) (ST s))
17:28:28 <Cale> Are you taking advantage of ST's features at all?
17:28:50 <Cale> ST mutation is real mutation
17:29:07 <monochrom> well then if you also have to change "MyState" to "MyState s", then you are not purely simply exclusively only changing Identity to ST
17:29:24 <andromeda-galaxy> monochrom: yeah, that's true---I needed to add a few STRefs to mystate
17:29:36 <andromeda-galaxy> Cale: I am using STs features, but not to replace anything done in the StateT
17:29:49 <EvanR> wedify: dependent types!
17:29:52 <andromeda-galaxy> I added the ST and then added a bunch of code that uses the ST, but all of the existing code that didn't use the ST is still there
17:29:54 <Cale> Writing STRefs directly is going to be much cheaper than reconstructing a new record in a pure way
17:30:17 <andromeda-galaxy> Cale: right, but I'm comparing "writing records & no strefs" to "writing the same records & also strefs"
17:30:30 <monochrom> I want to reproduce this experiment.
17:30:33 <Cale> (Where "much" is some factor that we'd frequently give up in the interest of keeping the code easy to understand)
17:30:36 <andromeda-galaxy> (and actually, all of the code using strefs ends up not happening at runtime in my benchmarks because a pass in a [])
17:30:46 <wedify> EvanR: type hackery!
17:31:25 <desophos> well i'm off, maybe haskell has the answers 
17:31:27 <andromeda-galaxy> so apart from adding the ST to the bottom of the monad transformer stack, the old code is still there and identical to what it was before, and none of the code using strefs ever even gets executed right now
17:31:41 <monochrom> dependent types do not help you specify laws of operations.
17:31:48 <desophos> ¯\_(ツ)_/¯
17:32:04 <Cale> monochrom: They sort of do...
17:32:09 <Cale> monochrom: You have identity types.
17:32:16 <andromeda-galaxy> monochrom: I don't know if I can get a good minimum viable example here, but I've re-built and re-run benchmarks on both versions ~4 times...
17:32:36 <andromeda-galaxy> maybe I should ask in #ghc if ghc does any particular optimization in the case of code on top of ST?
17:32:51 <monochrom> this is a subjective, ergonomic "help", meaning that it is not enough to be "can be done", I also require it to be subjectively natural.
17:33:00 <Cale> ah
17:33:24 <monochrom> for example an awkward encoding that is provably correct does not count as "helps", on the count that it is awkward.
17:33:27 <Cale> Yeah, I suppose it doesn't help you if you don't know what the laws should be, and it ends up being lots of work actually proving the laws you come up with regardless.
17:35:08 <andromeda-galaxy> (wow, interest in that performance fluke was short-lived compared to last night)
17:35:15 <EvanR> yes you can have the laws in the type
17:35:31 <EvanR> and you probably wont be able to prove any of them
17:35:46 <EvanR> unless its something super mathematical like monads
17:35:59 <monochrom> as a litmus test, write Functor-Applicative-Monad laws. write LIFO stack laws. write FIFO queue laws. see what you get. make them as elegant as possible. this will be good experience (against the religion of Curry-Howard)
17:37:32 <EvanR> metric space laws
17:37:41 <EvanR> d(x,x) = 0
17:37:44 <hpc> how are they against the curry-howard religion?
17:37:51 <EvanR> triangle inequality, et 
17:38:43 <EvanR> bonus points for not having to prove any of these if you use category theory library!
17:38:44 <monochrom> I could answer you, but it's cheaper for me if I just say you should do the litmus test to see for yourself.
17:39:29 <EvanR> you want <whoever> to just write the laws? or also write elegant proofs
17:39:42 <monochrom> implement a LIFO stack in Agda. state LIFO stack laws in Agda types. prove in Agda that your implementation has those types.
17:40:22 <monochrom> I bet you get stuck and/or frustrated and/or disillusioned
17:41:31 <EvanR> i get stuck frustrated and disillusioned trying the same exercise but instead of a stack it was the NFL rulebook
17:41:45 <EvanR> dependent football
17:42:43 <wedify> EvanR: I tried chess. I ended up not finishing it because I didn't know how to move forward
17:43:04 <wedify> agda needs way more docs for a noob like me to use it
17:43:29 <EvanR> trying the lifo in idris
17:44:24 <wedify> i think the closest i could come to proving laws would be to write tests
18:00:19 <Cortland> hmm
18:00:24 <Cortland> Is anyone here?
18:00:33 <johnw> no, I am not here
18:00:42 <Cortland> Ahh, apologies.
18:00:50 * pavonia isn't here either
18:01:04 <Cortland> Anyone ever have a problem installing hakyll with stack?
18:01:27 <Cortland> not necessarily a problem but I keep getting: could not find module `hakyll`
18:01:43 <Cortland> And its hurting my feelings. By the way, I'm Cortland.
18:02:25 <geekosaur> 'hakyll' is not a module name. is that really the error?
18:02:38 <Cortland> Yep
18:02:53 <Cortland> Could not find module `Hakyll' Use -v to see a list of the files searched for.
18:03:05 <geekosaur> case matters...
18:03:11 <caconym_> :2
18:03:19 <Hijiri> :1
18:03:21 <caconym_> oops sorry guys ignore that
18:03:24 <Cortland> its importing 'Hakyll'
18:03:45 <geekosaur> so are you just running ghci after installing it?
18:03:52 <geekosaur> you would have to use 'stack ghci'
18:03:56 <EvanR> monochrom: dealing with cabal hell right now... and this signature looks kind of funny for a stack structure, but im going with it for now http://lpaste.net/158111
18:03:58 <Cortland> No
18:04:17 <Cortland> hmm, didn't use stack ghci
18:04:31 <geekosaur> or for compiling you probably want to be using a proper stack project, but 'stack exec -- ghc ...' would work for a quick test
18:04:34 <Cortland> So I'd go into ghci in my hakyll project?
18:04:44 <Cortland> brb then
18:05:09 <geekosaur> otherwise, I think you need to provide more information
18:05:35 <hjulle> Cortland: When are you getting the error message?
18:06:07 <Cortland> Well I was when I entered: ghc --make -threaded site.hs
18:06:14 <Cortland> but now its working thanks to stack exec
18:06:24 <Cortland> I see why the #haskell irc comes highly recommended thank you
18:06:27 <EvanR> and law2 is spelled wrong anyway
18:07:07 <lpaste> infinity0 pasted “derive more generic type when inputs are restricted” at http://lpaste.net/158112
18:07:29 <infinity0> i'm wondering if the above is possible in haskell ^
18:08:18 <Rotaerk> are there limits to the functionality accessible within GHCJS?
18:08:29 <Rotaerk> like, can you access the filesystem
18:08:57 <geekosaur> Cortland, stack installs stuff in its own private package cache, so a bare ghc or ghci won't find it. Normally you use stack to build packages that use stack-installed packages, so it all just works out; if you do need to build something separately you use 'stack exec' to let it see stack's private package cache.
18:08:59 <Rotaerk> and if so is there anything side-effectful that you *can't* do with it
18:08:59 <Hijiri> If you can't already, then probably you could through FFI
18:09:09 <Hijiri> but there are some security things with JS I think?
18:09:12 <Hijiri> I don't actually know
18:09:12 <monochrom> EvanR: this is done right, at least the comments are right. it is funny, which is part of my point, because now you have 5 "operations" of which 2 are not operations.
18:09:13 <Rotaerk> ah
18:09:30 <geekosaur> (the "--" makes sure that options following it go to the program you are running instead of to stack itself, since it uses something similar to GNU getopt)
18:09:36 <EvanR> monochrom: well should be (pop . push x) s = Just (s,x)
18:10:12 <EvanR> i consider empty an operation... i just didnt make its type () -> t
18:10:14 <monochrom> yeah, my error-correcting modem hides that typo
18:10:30 <hjulle> Cortland: You should probably use "stack build" to build your project. 
18:10:38 <hjulle> Cortland: http://docs.haskellstack.org/en/stable/README/#quick-start-guide
18:10:48 <monochrom> oh, empty is an operation in all senses. I'm referring to law0 and law1 being non-operation operations
18:11:30 <EvanR> oh 2 of which are NOT
18:12:08 <EvanR> theyre not operations
18:12:50 <Cortland> Even when i'm building a hakyll project?
18:15:17 <hjulle> Cortland: I'm not too familiar with hakyll, but I believe so.
18:15:50 <Rotaerk> don't hakyll me
18:16:58 <EvanR> now i just need the free construction plugin and generate the stack implementation automatically from the laws!
18:17:33 <monochrom> haha. if that can be done easily, next you should try FIFO queue, maybe it can be automated too, that will be cool
18:17:42 <geekosaur> well, given that you used stack to install hakyll, you'd set up a stack project in that case and use stack to build it. 
18:17:57 <geekosaur> otherwise, you probably don't want to use stack to install hakyll
18:18:27 <monochrom> stack is easy because even the laws alone strongly suggest "cons list"
19:23:52 <EvanR> http://lpaste.net/158111
19:25:00 <EvanR> in the end, ... its mostly auto verified by the type checker... it understands even if i dont!
19:25:06 <EvanR> Queue huh...
19:25:52 <Gurkenglas> Can I store the infinitely growing thunk of a named infinite data structure on the hard drive so I don't have to recompute it each time I restart ghci?
19:27:44 <Gurkenglas> (Hmm, perhaps with snapshots or even a growing time tree of recorded progress http://sketchtoy.com/66822335 )
19:29:34 <monochrom> EvanR: you've got an antimatter version, EvanL, in #haskell-beginners
19:30:16 <EvanR> are they programming a codata stack
19:31:28 <EvanR> the queue law is... "FIFO" and this is embarrassingly hard for me to formulate precisely
19:34:18 * hackagebot werewolf-slack 0.2.0.0 - A Slack chat client for playing werewolf  https://hackage.haskell.org/package/werewolf-slack-0.2.0.0 (hjwylde)
19:36:19 <Gurkenglas> ?x `elem` ?xs => let outs = evalStateT (replicateM ?n (StateT uncons)) (push ?in ?xs) in (?in `elem` outs => ?x `elem` outs) -- EvanR, how about this?
19:36:19 <lambdabot> Maybe you meant: v @ ? .
19:36:57 <EvanR> what the heck
19:37:03 <Gurkenglas> I guess that should be outs <-, not outs =
19:37:36 <EvanR> what language is that
19:37:43 <Gurkenglas> An improvised one!
19:38:09 <Gurkenglas> If x is in the queue, and then you take some elements from the queue gotten from pushing in into it, and those elements contain in, then those elements contain x
19:39:13 <EvanR> the operations i have so far are empty, push, and dequeue
19:39:22 <EvanR> no elem
19:39:23 <Gurkenglas>  :t dequeue
19:39:36 <EvanR> same as pop
19:39:43 <Gurkenglas> :t pop
19:39:44 <EvanR> a -> t -> Maybe (t, a)
19:39:44 <lambdabot>     Not in scope: ‘pop’
19:39:44 <lambdabot>     Perhaps you meant one of these:
19:39:44 <lambdabot>       ‘op’ (imported from Control.Lens),
19:40:04 <Gurkenglas> What's the a doing in there?
19:40:11 <EvanR> oops
19:40:25 <Gurkenglas> And the state argument is supposed to go on the right side of the tuple
19:40:46 <EvanR> i know i reversed it
19:41:28 <EvanR> t -> Maybe (a,t)
19:41:44 <zq> forall a
19:42:00 <EvanR> not for all a
19:42:07 <EvanR> theres some context
19:42:30 <EvanR> http://lpaste.net/158111
19:46:20 <Gurkenglas> (`evalState` empty) (traverse_ push ?xs >> replicateM ?n (state $ fromJust . dequeue)) `isPrefixOf` xs -- True when defined
19:46:38 <Gurkenglas> (Oh prefix that last xs with ?)
19:46:42 <EvanR> whats n
19:46:46 <Gurkenglas> anything
19:46:54 <Gurkenglas> For all xs and n, that's true when defined
19:47:05 <EvanR> ah 
19:47:39 <Gurkenglas> Of course that doesnt cover the case when you dequeue something in between unless you have some more laws, hmm
19:47:53 <EvanR> the law is after pushing any number of things onto empty then dequeueing n times should give the same input sequence
19:47:57 <Gurkenglas> Ah, dequeue commutes with push, that solves it
19:49:09 <EvanR> commutes?
19:49:38 <EvanR> push x . dequeue = dequeue . push x
19:49:59 <EvanR> as far as the state goes
19:50:03 <Gurkenglas> "out <- StateT dequeue; push in" = "push in; out <- StateT dequeue" when both are defined
19:50:54 <Gurkenglas> Oh forgot modify in here and the last law
19:51:30 <Gurkenglas> Also in this last one its prettier to say "when both are just"
19:53:49 <EvanR> interesting that the operations and the laws are simpler in terms of state
19:54:39 <Gurkenglas> In fact shouldnt that last one and "(`evalState` empty) . (modify . push >=> StateT dequeue) == id" already be enough?
19:55:23 <EvanR> yeah there must be less than 3 or 4 sentences to a fifo law ;)
19:56:52 <Gurkenglas> Then you say on the second to last one that justice flows right, and we have the definition of definedness?
19:58:33 <EvanR> :t (>=>)
19:58:34 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:59:05 <EvanR> heh . goes left and >=> goes right
19:59:15 <Gurkenglas> :t (<=<)
19:59:16 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
19:59:46 <EvanR> better
20:01:38 <EvanR> Gurkenglas: how does this one law expand to cover the way a queue is not a stack
20:02:00 <Gurkenglas> Well destack and push dont commute in there
20:02:31 <EvanR> the stack law is (pop . push x) s = Just (x, s) for all s
20:03:17 <EvanR> your law says the same just for empty
20:03:34 <Gurkenglas> yea, and queues have the additional law that push and dequeue commute
20:03:41 <EvanR> ohok
20:04:51 <EvanR> so.. you really need the commute law
20:04:57 <EvanR> isnt that enough
20:05:46 <Gurkenglas> if you just want to tell whether its a queue or a stack, i think so
20:06:12 <EvanR> in this case, just guarantee its a stack
20:06:13 <EvanR> er
20:06:15 <EvanR> a queue
20:06:37 <EvanR> would be funny if the only thing defining a queue is commutative 
20:06:47 <Gurkenglas> gurantee its a queue or gurantee its not a stack?
20:06:55 <EvanR> is a queue
20:07:33 <Gurkenglas> commute is not enough to prove (pop . push x) empty = Just (x, empty)
20:08:20 <EvanR> guess not
20:08:34 <EvanR> i was trying to generalize it to involve the values
20:08:41 <Gurkenglas> but you could say that arises from polymorphism
20:09:06 <EvanR> pop empty = Nothing sure does
20:09:19 * hackagebot werewolf-slack 0.2.0.1 - A Slack chat client for playing werewolf  https://hackage.haskell.org/package/werewolf-slack-0.2.0.1 (hjwylde)
20:09:20 <EvanR> i think thats what imeant, that one is "free"
20:09:24 <Gurkenglas> after youve defined definedness of course
20:10:58 <Gurkenglas> "(f a -> a -> a) empty" can't be anything other than id
20:19:19 * hackagebot relational-record 0.1.3.0 - Meta package of Relational Record  https://hackage.haskell.org/package/relational-record-0.1.3.0 (KeiHibino)
20:33:41 <pyon> Would a type constructor of (immutable) arrays whose size is always a power of 2, be a Monad?
20:33:59 <pyon> No, wait.
20:34:05 <pyon> Ignore my question. It was a stupid one.
20:37:14 <pyon> But they would be an Applicative, right?
20:37:21 <pyon> (Arrays whose size is a power of 2.)
20:39:49 * hackagebot werewolf 0.4.12.0 - A game engine for playing werewolf within a chat client  https://hackage.haskell.org/package/werewolf-0.4.12.0 (hjwylde)
21:36:41 <arahael> When running haskell code as a script (using stack, and -- stack --verbosity silent runghc); how do I output the stack trace when I have an error?
21:40:10 <arahael> Currently, I just have as an error: Prelude.head: empty list
21:40:15 <arahael> Which isn't entirely helpful.
21:47:25 <emmanuel_mobile> arahael: you are using head on an empty list. You might want to try (take 1) instead
21:47:51 <arahael> emmanuel_mobile: I've assumed that's the case, but I'm not doing so directly.  Some module is apparently using head.
21:48:49 <arahael> emmanuel_mobile: I'd like a bit more information - a stack trace of some sort would be *wonderful*.
21:50:01 <emmanuel_mobile> Is this happening in a module you don't have access to?
21:50:55 <emmanuel_mobile> Most libraries wouldn't make such a silly errors.
21:51:08 <emmanuel_mobile> But then again....
21:51:41 <arahael> emmanuel_mobile: I'm _assuming_ that this is probably being done in the mbox module, which is short enough to read, but I suppose the question is: How do I find out where this error is coming from *without* reading every line of code in the program?
21:52:14 <emmanuel_mobile> Have you used Debug.Trace?
21:53:16 <arahael> emmanuel_mobile: No, my program is really, really tiny.  Best Debug.Trace would get me is to know which Message the Mbox fails on.
21:54:39 <emmanuel_mobile> Well, you'll need to carefully go through your code... If it is small then you should be able to grep for the function head.
21:54:40 <arahael> emmanuel_mobile: I'm trying to find techniques that will help me *identify* where the errors occur, quickly, and easily.  Many langauges can do this, I'm sure Haskell can as well. (Actually, it does - using -prof and some sort of cryptic RHS argument or something...  But how do you do so within stack?)
21:54:52 <jle`> icicled: hi, sorry!  i've been out all day
21:54:54 <arahael> emmanuel_mobile: My code doesn't contain the term "head".
21:55:20 <jle`> icicled: generally you can always use it at the "bottom" of a transformer stack, the same place you'd use IO
21:55:53 <emmanuel_mobile> You can step through your code in the repl. But you have to remember that haskell is lazily evaluated.
21:56:10 <emmanuel_mobile> You would use the command :step
21:56:38 <andromeda-galaxy> hmm, any ideas on what a good NFData instance for an STRef (well specifically an ST hash table) would be?
21:56:43 <jle`> basically if you're ever uncomfortable with using all of IO when you only ever want to do a small specific amount of things, you can drop in Prompt
21:56:49 <jle`> in replaement
21:56:54 <arahael> emmanuel_mobile: The entirey of my file is more-or-less: putStr . unpack . unlines . (map addresses) $ parseMBox inbox; where 'inbox' is Text.
21:58:13 <emmanuel_mobile> Google the step command in ghci
21:58:52 <emmanuel_mobile> It should show you what functions are being called in parseMBox
21:59:28 <emmanuel_mobile> In ghci --> For ghci
21:59:47 <arahael> emmanuel_mobile: You're missing my point.
21:59:52 * hackagebot hpc-coveralls 1.0.4 - Coveralls.io support for Haskell.  https://hackage.haskell.org/package/hpc-coveralls-1.0.4 (killy971)
22:01:00 <emmanuel_mobile> Sorry, maybe I can't help you.
22:01:46 <arahael> emmanuel_mobile: That's ok.  I'll use the debugger instead, but my question remains: How do I get a stack trace when running stack in this configuration.
22:03:31 <Moggle> im using parsec, and it apparently doesn't include a basic parser for decimal numbers... do i really have to write it myself (its just a many1 digit i guess)? or is there a nice package out there which has a bunch of basic parsers ready to use?
22:03:54 <arahael> Moggle: "read"?
22:04:23 * arahael isn't really a parsec user - too naive a haskeller, to be honest.
22:05:48 <Moggle> arahael: using a parser within a parser seems a little silly :P
22:05:56 <Moggle> i could get away with it but i'd like a nice basic way to do it if i can
22:06:33 <arahael> Moggle: Maybe, but once you have the tokens, what's the harm? ;)
22:06:45 <Sgeo__> Rust has type families but not fundeps. Is there any negative consequence to not having fundeps if type families are present?
22:06:54 <Moggle> getting the tokens is a bit awkward is the problem :)
22:07:03 <Moggle> but it's not the end of the world
22:07:05 <Moggle> alright i'll just
22:07:14 <Moggle> sigh and write integer = manyOf1 digit or whatever 
22:08:13 <arahael> emmanuel_mobile: Actually, trying ghci, I'm not getting much further in.  I've used :set, :trace, and then finally :hist, but it's only showing the function calls that I wrote.  It's not delving into the Data.MBox code.
22:09:22 <Moggle> oh i found megaparsec, a fork of parsec with basic lexers
22:09:26 <Moggle> let's just use that.
22:10:00 <emmanuel_mobile> Hmmmm.... You might have to reinstall that library with profiling.
22:10:32 <arahael> Hmm.
22:10:33 <emmanuel_mobile> I'm on mobile.... The flags are a bit long.
22:11:01 <arahael> emmanuel_mobile: I'll look that up...  Mobile irc sucks, what are you using? ConnectBot for Irssi?
22:11:22 <emmanuel_mobile> I'm using AndroidIRC.
22:11:37 <emmanuel_mobile> I mean AndroIRC
22:11:40 <emmanuel_mobile> Lol
22:11:58 <arahael> emmanuel_mobile: If you have access to a remote shell server using screen or tmux, I highly recommend that. :)
22:12:55 <emmanuel_mobile> Something like tab completion on the phone would be nice
22:13:41 <arahael> emmanuel_mobile: Hence, irssi connectbot, and a remote shell. ;)  (Hacker's Keyboard provides the tab key)
22:14:09 <emmanuel_mobile> Thanks! Ill definitely look into that
22:15:00 <arahael> emmanuel_mobile: It definitely could be better - irssi (or weechat, even), definitely isn't optimised for phones, but it's the best I've found.  Most of the "pure phone apps", for lack of a better term, seem to be somehow unstable for irc.
22:15:43 <arahael> emmanuel_mobile: (Note: I use a tablet, which may well change things)
22:16:00 <emmanuel_mobile> That makes some sense.... Nothing really beats the physical keyboard.
22:16:31 <arahael> Indeed.
22:17:14 <hjulle> Sgeo__: IIRC fundeps and type families are used for basically the same thing. https://wiki.haskell.org/Functional_dependencies_vs._type_families
22:17:21 <arahael> Blegh, I'm just not getting much luck. It seems that using stack's "runghc" feature to essentially use haskell as a scripting language is seriously immature.
22:17:37 <arahael> Loads of docs for other configurations, including regular cabal.
22:18:42 <Sgeo__> hjulle, ty
22:19:06 * arahael tries something...
22:23:42 <arahael> Hmm, nope.  Using stack to install with --library-profiling and --executable profiling, and hten ghci, didn't seem to enable it for that module.
22:29:44 <hjulle> Moggle: There's also attoparsec which has "scientific" for parsing numbers.
22:31:12 <arahael> It seems that what I want may well be impossible, unless I set up a cabal project or properly use haskell as a compiled language.
22:32:00 <hjulle> Moggle: Go with attoparsec if you want speed, megaparsec if you want batteries, bells and whistles included: https://github.com/mrkkrp/megaparsec#megaparsec-and-attoparsec
22:34:53 * hackagebot werewolf 0.5.0.0 - A game engine for playing werewolf within a chat client  https://hackage.haskell.org/package/werewolf-0.5.0.0 (hjwylde)
22:45:04 <hjulle> [werewolf] Someone's busy with development. Two new versions of a package in less than two hours.
22:46:06 <arahael> Intruging concept, that.  Werewolves on irc.
22:49:01 <hjulle> I believe it's for slack, not IRC, but still.
22:49:56 <arahael> Even so.
22:56:19 <arahael> Hmm, so i think the mbox package is probably too faulty.
22:56:25 * arahael looks for a replacemnt.
23:30:03 * hackagebot werewolf-slack 0.3.0.0 - A Slack chat client for playing werewolf  https://hackage.haskell.org/package/werewolf-slack-0.3.0.0 (hjwylde)
23:59:40 <zRecursive> In emacs haskell mode, how can i make C-` to run 'ghci -lmsvcr100' not 'ghci' ?
