00:04:53 * hackagebot automotive-cse 0.1.1.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.1.0 (KeiHibino)
00:07:38 * hackagebot automotive-cse 0.1.0.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.0.0 (KeiHibino)
00:07:38 * hackagebot automotive-cse 0.1.1.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.1.0 (KeiHibino)
00:25:47 <Akii> so I made dis http://lpaste.net/160736
00:29:08 <Akii> kinda looks like a monoid, but that's dependent on the interpretation of the Event
00:29:26 <pkug> Hi there, is https://www.haskell.org/tutorial/ a reasonable place to start along with a Pearls of a Functional Algorithm Design book for somebody who already has programming background and some FP experience with Clojure .. ? asking because can't really afford http://haskellbook.com/
00:30:56 <nineonine> Akii: whats your question ?
00:31:08 <Akii> nineonine: I'm trying to abstract this concept
00:32:00 <Akii> I could use a typeclass actually
00:32:28 <Akii> init :: Projection e as the starting value
00:32:41 <kadoban> pkug: https://github.com/bitemyapp/learnhaskell has some good advice, IMO. Pearls of Functional Algorithm Design is pretty slow going, at least for me, and won't do much to teach you haskell.
00:32:47 <Akii> and then only apply would be required for implementation
00:32:49 <kadoban> Though I think it's a really good book too.
00:33:38 <Kneiva> r
00:36:13 <nineonine> Akii: so you want to give "Projection e" a Monoid Instance ?
00:36:25 <Akii> nineonine: nope, that wouldn't satisfy the laws
00:37:09 <pkug> kadoban: thanks! going through that, seems a great piece of advice.. i enjoyed Bentley's Programming Pearls a lot, was thinking reading about FP idioms and problem tackling in general alongside some Haskell specific studies would accelerate learning process a bit, picked up Purely Functional Data Structures from the library as well.
00:37:32 <Akii> so the goal is to have a way to define more projections with an arbitrary state that implements the apply method for some events
00:37:34 * hackagebot should-not-typecheck 2.1.0 - A HUnit/hspec assertion library to verify that an expression does not typecheck  https://hackage.haskell.org/package/should-not-typecheck-2.1.0 (CRogers)
00:38:01 <Akii> apply would have to be a partial function and down the road it'd be nice if I could somehow express what kind of events the projection can handle
00:39:20 <Akii> also `data Event` will come from all sorts of different modules, I need to find an abstract type for that as well
00:51:10 <fr33domlover> Why does GHC say this requires FlexibleInstances? > instance MonadBaseControl b m => MonadBaseControl b (ChannelT i m) where --...
00:52:11 <fr33domlover> (ChannelT i m) is a MT that's simply newtype wrapper of StateT
00:57:07 <lyxia> The canonical form of typeclass instances is TypeClass (TypeCon1 tyvar11 tyvar12 ...) (TypeCon2 tyvar21 tyvar22 ...) ...
00:57:43 <lyxia> b is not a concrete type constructor applied to type variables
00:58:28 <fr33domlover> lyxia, thanks :)
00:59:02 <lyxia> you're welcome
01:02:03 <fr33domlover> lyxia, another question: In MonadBaseControl there's a functional dependency between b and m. My instance fails to compile because "b is not implied by ChannelT..." . Does it mean I need to specify the fundep too? or should I use UndecidableInstances?
01:02:39 <fr33domlover> too much abstraction ^_^
01:04:22 <Cale> fr33domlover: The functional dependency m -> b means that the type m must uniquely determine which type b is.
01:06:02 <Cale> Well, I guess it's somewhat okay, given the constraint
01:06:13 <Cale> I guess you're just expected to use UndecidableInstances, yeah.
01:06:38 <fr33domlover> transformers-base uses UndecidableInstances too
01:06:45 <fr33domlover> i'll just try that then
01:11:08 <Cale> Personally, I just stay away from MonadBaseControl. There might be some example that comes along and convinces me otherwise, but my current take on it is that if it comes to the point where you need MonadBaseControl, something has gone wrong with how you're using monad transformers, and it might work out better just to take some different approach to constructing the library you're trying to write.
01:20:25 <ph88^> are there any haskell libraries for parsing that have a seperate lexing stage ?
01:21:40 <liste> ph88^: many parsers can parse lists of tokens
01:22:21 <ph88^> i didn't see any tutorial about a seperate lexing stage
01:22:36 <ph88^> or libraries for lexing
01:24:14 <Hijiri> I think Parsec can do it, but I have never used the token stuff myself
01:25:14 <liste> ph88^: https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read-Lex.html
01:27:48 <Akii> okay lol, seems like I didn't understand a thing about type-classes
01:29:10 <Akii> http://lpaste.net/160742
01:30:34 <Akii> I can't really have two instances of Projection Int for different events, right?
01:31:12 <Akii> (for reference, trying to abstract this http://lpaste.net/160736)
01:33:45 <Akii> well I could create a data type for each projection, that would work
01:51:03 <ph88^> liste, how can i specify token priority with that ?
01:59:51 <Akii> how can I think of type-classes, is this defining the functions "init" and "apply" on the data type "State"? http://lpaste.net/160742
02:07:37 * hackagebot creatur 5.9.11 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.11 (AmyDeBuitleir)
02:19:12 <Lovepon> I need persistent storage, but I don't want it to use an external database.
02:19:48 <Lovepon> I want something like vault, except persistent. Any ideas?
02:21:15 <MasseR> Lovepon: check acid-state
02:26:20 <liste> ph88^: you probably can't, it's pretty limited
02:26:33 <ph88^> o_O
02:29:46 <Akii> yay I just needed to tell haskell the type, kinda makes sense http://lpaste.net/160742
02:30:33 <Peaker> Is foldl now as good as foldl', with the FTP?
02:30:42 <Peaker> (if not, Akii ought to use foldl'!)
02:31:31 <Peaker> Akii: Why not "newtype State"? Why not extract the "State $" outside the "case" ?
02:32:41 <Akii> because I'm new to haskell, that's why :P
02:32:48 <haskell221> hi, can I defer type error for one outside library ?
02:32:48 <Akii> newtype makes sense
02:33:01 <Akii> can you explain the extraction thing?
02:33:20 <haskell221> I am compiling some lib with ghcjs and it has errors only in that case
02:33:28 <haskell221> but I know I won't use this lib
02:33:45 <Akii> (also note that State can be arbitrarily complex, in this case it would make sense to use a newtype though)
02:34:19 <haskell221> it's only a dependency for one library containing a type which I use
02:35:10 <Lovepon> MasseR: Thanks! I'll probably be using this with Vault.
02:36:06 <Lovepon> Hmm...
02:36:38 <Lovepon> Or not, I'll probably just make my own structure.
02:36:49 <Lovepon> I have to go, cya.
02:40:11 <Akii> Peaker: updated the paste, now using newtype. Thanks!
02:41:12 <Peaker> Akii: use foldl', too
02:41:39 <Akii> can you explain what you mean by 'Why not extract the "State $" outside the "case" ?'? :D
02:42:11 <ntnt> Cale: I just finished writing a 142 line TH thingy; and I hate haskell right now
02:42:11 <Peaker> Akii: http://lpaste.net/160742#line21
02:42:29 <ntnt> would ahve been like 15 lines in lisp macros
02:42:31 <Peaker> ntnt: heh, TH is not pleasant!
02:42:52 <Akii> ah, nice thanks!
02:43:01 <ntnt> yeah, I think TH is designed for this sweet spot where (1) it's annoying enough that you're discouraged t use it and (2) not annoying enough for anyone to write a TH replacement
02:43:37 <anohigisavay> hi. i'm using the BNF Converter C-- sample grammar to parse C-- source code into haskell
02:44:02 <anohigisavay> how do i evaluate the parse tree then
02:44:10 <anohigisavay> for example the functions
02:47:49 <Squarism> if i want to extract fields of a data type in an expression, is there some nice way?
02:48:57 <Squarism> data Bo = Bo Int
02:49:06 <Squarism> let s = Bo 2 
02:49:08 <ph88^> with parsec/attoparsec is it possible to match two things at the same time?  for example match digits but not digit 8  ?
02:49:15 <Akii> record syntax gives you accessor functions
02:49:33 <Akii> other than that, pattern matching could be used
02:50:17 <Akii> Squarism ^ :D
02:50:18 <Squarism> akii how would you check Bo is of value 2 in an if statment?
02:50:44 <Squarism> i would prefer not use record syntax
02:51:38 <Akii> how about derifing Eq and then if (s == Bo 2) ? :D
02:51:44 <Akii> deriving*
02:52:42 <lyxia> Squarism: data Bo = Bo { unBo :: Int }, let s = unBo (Bo 2)
02:53:05 <Akii> how would this look like with newtype in this case?
02:53:19 <Akii> if it's isomorphic can you just compare to Int then?
02:53:34 <Akii> (and it is isomorphic to Int)
02:54:32 <lyxia> it's the same syntax if you're using newtype
02:54:42 <lyxia> newtype Bo = Bo { unBo :: Int }
02:54:46 <Akii> right, sorry
02:56:16 <lyxia> you still have to wrap/unwrap explicitly, but you can directly compare to literals if you provide a Num instance.
03:04:23 <Peaker> ph88^: attoparsec's satisfy maybe?
03:04:23 <Peaker> Akii: the point of newtype is often to disallow using them as the underlying type
03:06:48 <ph88^> Peaker, you mean satisfy with boolean AND ?
03:06:59 <Akii> not sure I understand, you don't export them in the module and then you can't use them or how does that work?
03:07:28 <Peaker> ph88^: you're asking two different things: Can you parse 2 alternatives? Yes: a <|> b   And: Can you negate a parser? I don't think attoparsec can, but you can negate a predicate for "satisfy"
03:08:12 <ph88^> a <|> b  match a or b    but i want   a and b
03:08:21 <Peaker> Akii: well, maybe you don't want to outright forbid -- just make accidental use impossible. e.g:  newtype Mass = Mass Int ; newtype Length = Length Int ;  you don't want these two compared by accident! Not even with ints
03:08:37 <Peaker> ph88^: oh, you want an overlapped match of two successful parsers?
03:08:51 <ph88^> yes i think you could call it that way
03:08:56 <Peaker> ph88^: what's the use case?
03:09:05 <ph88^> i want 2 parsers to match but on the same string
03:09:23 <Akii> Peaker: I see, that's useful
03:09:24 <Peaker> ph88^: You can run each of the whole parsers on the string
03:09:34 <ph88^> because sometimes it's easier to write this way "all digits except digit 8" then "0 1 2 3 4 5 6 7 9"
03:10:34 <ph88^> i think the first parser will already consume input, so there must be a special function/operator to match 2 parsers on 1 input
03:11:05 <Peaker> ph88^: satisfy (\x -> isDigit x && x /= '8') ?
03:11:05 <Peaker> ph88^: This isn't really 2 successful parsers overlapping
03:13:06 <Peaker> ph88^: your use case doesn't require 2 parsers -- so what would you use it for?
03:34:23 <martinv> Hi, anyone knows what ghci means by "module XYZ is a package module" when I attempt to load it via :load? Is it saying it doesn't have access to the module source?
03:35:27 <martinv> I should say I start ghci via stack
03:39:47 <lyxia> martinv: you should use :m
03:41:03 <martinv> lyxia: I need :l because I want to work on taht module... but I now found the soultion, I have to use stack ghci mypkg:lib, which loads my lib, not executable and then I can load individual module with :l
03:41:32 <lyxia> I see.
03:51:30 <Guest86776> is it normal that sum . map is slow?
03:52:07 <Rembane> Guest86776: It depends. What are you trying to do?
03:52:28 <haskell666> what's wrong here?
03:52:30 <haskell666> randomPath :: RandomGen g => g -> (Path, g) randomPath g = let (g1, g2) = split g in (iterate (\x -> neighborsOf x !! (randomR (1, length $ neighborsOf x) g1)) startState, g2)
03:52:56 <haskell666> if I try to compile it says there's a problem at g1
03:53:31 <erikd> haskell666: use lpaste.net to post the code and the error message and then post the link here
03:53:41 <Guest86776> Rembane: it's just that I noticed while profiling that foldl' (\acc elt -> acc + log elt) is much faster, but I had expected sum . map to be optimized to that automatically...
03:54:42 <lyxia> haskell666: randomR returns a pair, !! expects an Int
03:54:57 <haskell666> how can I return an int?
03:55:20 <haskell666> code http://lpaste.net/160753
03:56:16 <haskell666> also, how can I reply to someone?
03:56:19 <Guest86776> at least while using profiling it is much faster, when not profiling it is only a little faster... 
03:56:20 <lyxia> also you should not use split but get g2 out of the result of randomR applied to g directly
03:56:39 <lyxia> haskell666: just prefix your messages with the nick of someone
04:01:15 <lyxia> haskell666: you're calling randomR with the same generator, that's not random at all.
04:01:29 <haskell666> lyxia how can I fix this?
04:01:41 <haskell666> <lyxia> is this working?
04:01:51 <Guest86776> under profiling the difference in time is -33% (or+50%), while memory usage is halved
04:02:16 <Guest86776> but it does not seem to reflect actual time difference
04:02:40 <Guest86776> so running with +RTS -p -RTS seems to distort the time it takes to complete
04:03:11 <Guest86776> is that normal?
04:03:37 <lyxia> haskell666: when you apply randomR, you get a new generator which the next call should use
04:03:52 <Guest86776> actual time difference when not profiling that is
04:03:55 <haskell666> so should I use (next g1) ?
04:06:26 <lyxia> haskell666: no, randomR does that already
04:07:52 <haskell666> So... is this working at all or should I write it again?
04:08:21 <lyxia> I'd say write it again
04:10:53 <Boomerang> haskell666: you can chain randomR by taking the next g everytime
04:10:57 <Boomerang> > do {g0 <- newStdGen; let {(a, g1) = randomR (0,10) g0; (b, g2) = randomR (20, 100) g1}; return (a,b)}
04:10:59 <lambdabot>  <IO (Integer,Integer)>
04:14:37 <ph88^> Peaker, yes that seems to be what i want :)
04:17:39 <Peaker> Stack build honours settings in ~/.cabal/config, right?
04:18:11 * Peaker is wasting most of his day doing slow rebuilds of whole packages... :(
04:18:19 <kadoban> Peaker: Don't think so
04:22:01 <ggVGc> Peaker: I spent several hours two days ago compiling and boostrapping GHCJS
04:22:32 <ggVGc> I think ghcjs is starting to deserve it's own "binary" archive of JS-compiled libraries
04:31:16 <srhb> ggVGc: This is why ryan has been recommending nix and his own bincache for it for quite some time.
04:34:07 <maerwald> can someone explain to me what the use of Reifies class from Data.Reflection is when I still end up passing an additional configuration argument around? I could just do it explicitly.
04:51:21 <meditans> hi, I have a problem with a file I'm writing: https://github.com/meditans/hyper-relation/blob/master/src/Data/HyperRelation/Internal/Relation.hs
04:51:55 <meditans> the naive way of defining the class Nullify (at the bottom of the file)
04:52:25 <meditans> is twarted by the fact that the type family Maybes is not injective
04:52:34 <meditans> how should I go around the problem?
04:54:28 <meditans> (the purpose of the nullify class is to change in Nothing a precise element of Relation (Maybes as))
05:00:14 <{AS}> Hi, does anyone know if there was a particular reason why recursive module support was removed in the latest version of Backpack? Or was it simply just relegated to future work?
05:00:17 <ertes> meditans: side note: i think you can define Relation as a simple GADT
05:01:08 <ertes> data Relation :: [*] -> * where EndRel :: Relation '[]; (:<->) :: a -> Relation as -> Relation (a ': as)
05:03:02 <meditans> ertes: I should try that, and see if it simplifies the code. Could that be done also for the HyperRelation' class in this file? https://github.com/meditans/hyper-relation/blob/master/src/Data/HyperRelation.hs
05:03:16 <meditans> s/done/doable
05:03:49 <ertes> meditans: yeah, looks like it
05:04:23 <meditans> ertes: so, this would have the advantage of taking back most of the constructions at the term level, right?
05:05:09 <meditans> I mean, most importantly, constructions like Nullify etc
05:05:18 <ertes> meditans: i don't know what you mean, but it would make them closed
05:05:33 <ertes> data families follow the open world assumption similar to type classes
05:06:14 <ertes> trying to figure out the purpose of Maybes
05:06:26 <ertes> or rather why it's not an actual type
05:06:49 <ertes> you can have the following construction:
05:07:14 <ertes> data Relation :: (* -> *) -> [*] -> * where EndRel :: Relation f '[]; (:<->) :: f a -> Relation f as -> Relation f (a ': as)
05:08:39 <meditans> ertes: I see, that would make things more compact
05:08:57 <ertes> it should be useful, as it gives you both individual types and a "common container" type
05:09:01 <ertes> or "common functor" if you will
05:09:10 <bblfish> ertes thanks for the help the other day. I finally managed to put my question clearly in StackOverflow "Why must fmap map every element of a List?" http://stackoverflow.com/questions/36715851/why-must-fmap-map-every-element-of-a-list
05:09:41 <ertes> bblfish: my pleasure, though i don't remember the context =)
05:10:32 <ertes> bblfish: by mere types fmap doesn't have to map over all elements…  the other option would be to discard elements…  also fmap can reorder
05:10:43 <ertes> or repeat
05:10:45 <meditans> ertes: ok, I'm going to rewrite things following the GATDs and common functor suggestion, and see what the solution looks like. Thanks for the help :)
05:10:52 <bblfish> ertes: you were trying to help me understand how to think about functors http://tunes.org/~nef/logs/haskell/16.04.16
05:11:06 <ertes> meditans: good luck =)
05:11:28 <ertes> ah, i remember
05:11:52 <bblfish> ertes there is a guy who as an answer to the question put forward that a "proof" that it does.
05:12:02 * bblfish got to go for lunch
05:12:09 <ertes> bblfish: a *correct* fmap has to
05:12:25 <ertes> but a *well typed* fmap doesn't
05:12:47 <ertes> well typed doesn't imply correct, because it also needs to satisfy a bunch of laws
05:19:20 <dysfun> which you could even enforce in agda
05:21:26 <meditans> ertes: if I define Relation as: data Relation :: [*] -> * where EndRel :: Relation '[]; (:<->) :: a -> Relation as -> Relation (a ': as) how would I derive automatically a Show instance?
05:21:50 <bblfish> Ah ok. I meant a correct fmap of course. 
05:21:57 <ertes> meditans: i think you get along with a single standalone clause
05:22:14 <ertes> meditans: if you're lucky, even 'deriving' might work
05:22:35 <ertes> bblfish: you may actually be interested in theorem provers like agda
05:23:12 <meditans> ertes: sorry, I copied the wrong code. I meant: data Relation :: (* -> *) -> [*] -> * where EndRel :: Relation f '[]; (:<->) :: f a -> Relation f as -> Relation f (a ': as)
05:23:21 <bblfish> ertes I am working my way towards that slowly, in between doing practical things
05:23:59 <ertes> meditans: if 'deriving' doesn't work, write a standalone clause and progressively make GHC shut up =)
05:24:09 <ertes> it will tell you what the context is missing
05:25:16 <meditans> ertes: I'm trying something along: deriving instance Show (RelationG f '[])
05:25:16 <meditans>  
05:25:30 <meditans> and it says     Inaccessible code in a pattern with constructor
05:26:08 <ertes> meditans: i'll give it a try
05:26:44 <meditans> ertes: thanks :)
05:30:44 <ertes> i'm not sure why that happens
05:30:57 <ertes> you may have to write the instance yourself
05:31:43 <meditans> ertes: ok, I wrote the instance myself, I was curious about why it can't be generated, thanks :)
05:32:03 <ertes> test.hs:20:1-73: Couldn't match type ‘a : as’ with ‘'[]’ …
05:32:36 <ertes> i guess i can't answer that without some deeper understanding of the deriving process, but honestly i've never really cared
05:33:37 <ertes> it probably means that you're going to have to write all instances by hand: Eq, Ord, etc.
05:34:01 <ertes> and the 'f' will be inconvenient, unless you use Eq1, Ord1, Show1, etc.
05:34:18 <meditans> ertes: I used Show (f a)
05:34:27 <meditans> what's Eq1, Ord1 ecc?
05:34:39 <ertes> type constructor variants of the classes
05:35:10 <ertes> :t (==#)
05:35:11 <lambdabot>     Not in scope: ‘==#’
05:35:11 <lambdabot>     Perhaps you meant one of these:
05:35:11 <lambdabot>       ‘==’ (imported from Data.Eq),
05:35:30 <ertes> i can never memorise what those functions are called
05:35:40 <ertes> (Eq a) => f a -> f a -> Bool
05:35:58 <Boomerang> @hoogle (Eq a) => f a -> f a -> Bool
05:36:02 <lambdabot> Data.Functor.Classes eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool
05:36:02 <lambdabot> Data.IntMap.Strict isProperSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
05:36:02 <lambdabot> Data.IntMap.Lazy isProperSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
05:36:16 <ertes> ah, there you go
05:36:21 <ertes> the first one
05:37:44 <meditans> oh, thanks, I didn't know those existed! Handy!
05:38:06 <meditans> ertes: in the meantime, the GADT approach is really simplifying the code
05:39:16 <Lovepon> Guys, how would I embed ghcjs/purescript/haste code in Blaze?
05:39:47 <ertes> Lovepon: either link it or dump it into an appropriate element
05:40:01 <ertes> just as you do with other javascript code
05:40:12 <Lovepon> ertes: Link it?
05:40:52 <ertes> Lovepon: <script src="my-ghcjs-project/all.js"></script>
05:41:36 <Lovepon> ertes: Ohhh, how the hell did I not think of that? Thanks. c:
05:43:07 <Lovepon> ertes: Is there a way to build them as stack/cabal builds them?
05:43:34 <ertes> i don't know how to do it with stack, but with cabal you simply configure with --ghcjs
05:43:40 <Lovepon> ertes: Forgetting to build some code happens to me all the time, and, well, I want to avoid it.
05:44:06 <ertes> however, i don't know a way to keep server and client code together that way
06:18:01 * hackagebot protolude 0.1.4 - A sensible set of defaults for writing custom Preludes.  https://hackage.haskell.org/package/protolude-0.1.4 (sdiehl)
06:18:03 * hackagebot syntactic 3.6 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.6 (EmilAxelsson)
06:31:57 <meditans> ertes: I completed the switch to GADTs, and the code is much more readable, https://github.com/meditans/hyper-relation/blob/GADTs/src/Data/HyperRelation/Internal/Relation.hs
06:32:32 <meditans> ertes: only one task remains that I haven't been able to translate yet: how to recover the nth element in a Relation defined this way
06:32:47 <meditans> (the commented code is the machinery I used in the previous version)
06:33:37 <Heather> I need my own turtle!
06:33:46 <meditans> there I used sideAt and TypeAt to be able to write the type of the element I was trying to fetch
06:34:13 <Heather> who is using turtle - why, why do you want special type for FilePath
06:34:34 <ertes> meditans: that's not necessarily the easiest task…  the proper way to do it includes singleton types, because then the compiler can verify that the element at the requested index is indeed of the requested result type
06:35:04 <Heather> making it hard to interact with everything, hiding default prelude filepath everywhere - for what effort? I just don't get it
06:35:06 <ertes> meditans: what you can do is a more dynamic solution through Typeable and or Data.Coerce, but it will result in a Maybe
06:35:26 <ertes> Heather: correctness
06:35:51 <meditans> ertes: let's say I want to do it the proper way, should I be using the singletons library then?
06:35:58 <ertes> there is almost uniform agreement that the default FilePath type is terrible, so there are all kinds of attempts to hide it
06:36:01 <meditans> I mean, do you have a specific pointer?
06:36:07 <Heather> ertes I simply can't get if there is simple way to interact with strings
06:36:30 <ertes> meditans: most likely singletons is what you would need, yeah
06:36:48 <ertes> meditans: or put differently: singletons would make it tolerable to some extent =)
06:37:06 <EvanR> how i learned to stop worrying and love type FilePath = String
06:37:12 <ggVGc> Heather: but a filepath is a special case of a string, and conceptually a completely different thing actually
06:37:27 <ertes> meditans: if you're doing this for the first time, you may want to implement this in a theorem prover first, so you have a general idea of how it works without being confused by the limitations of haskell's type system
06:38:09 <Heather> ggVGc yes and I even can't use IO actions on it because IO lib is using Strings, I can't even use something alike path </> "a" because "a" is a string
06:38:42 <Heather> I know, nobody cares but I really wonder if people is using it for something practical and how?
06:38:45 <ertes> Heather: IIRC turtle actually gives you variants of all of those with its own path type
06:38:51 <ggVGc> Heather: sure, and then you're forced to explicitly think about what you're doing, because you are comparing two concepts that might not actually be comparable
06:39:44 <ertes> Heather: given a choice, gabriel gonzales always goes for correctness, but he also usually makes it convenient enough, so i would be really surprised if turtle isn't prepared for that
06:39:44 <Heather> ggVGc sure .... if I have file named a in directory it's very different because a is not filename, it's a string, to make it file name you need to think of it alike about filename, right?
06:40:25 <Heather> ertes for now I can't find the way how can I use it
06:40:32 <EvanR> when newtypes attack
06:42:09 <ertes> Heather: unfortunately people think that "shell programming" implies renaming everything to terrible abbreviations or doing other weirdnesses…  for example what is readFile seems to be 'readonly' in turtle
06:42:23 <ertes> so you may have to skim over the library documentation a bit to find what you need
06:42:54 <ggVGc> Heather: my point is that strings can represent a lot of things that are not paths, so you might be doing comparisons that are not valid. Now correctness always comes at the cost of convenience, so I guess it's personal where people draw the line. Technically it's the same issue with "Int", or any other basic type, and sometimes we make newtypes because we want the extra security while sacrificing some ease
06:42:58 <ertes> alternatively i don't find the basic haskell libraries too bad for shell programming
06:43:00 <ggVGc>  of use
06:43:20 <ggVGc> Heather: by representing a filepath as a string, you could accidentally read the contents of a file in from somewhere and compare it to a filepath
06:43:27 <ertes> it's only when you need complicated globbing or similar "shelly" things when such a library becomes useful
06:43:28 <ggVGc> which the type system would say is fine
06:43:49 <EvanR> theres a few ways that Int or String could go wrong, for example in this case its that the ecosystem is using them everywhere
06:44:06 <EvanR> so its just a pain in the ass if you dont want to use them
06:44:10 <Heather> it's simply overkill
06:45:00 <EvanR> FilePath = String should work most of the time but there are some bad corner cases like shift-jis files
06:45:52 <EvanR> and if youre japanese thats kind of not a corner case
06:46:05 <ggVGc> who is japanese anyway
06:46:09 <ertes> Heather: i don't think it's overkill in a library, if it's more or less complete or provides a reasonable interface to the legacy APIs…  and i'm almost certain turtle does that
06:46:14 <ggVGc> and what have they contributed to technology??
06:46:15 <maerwald> that's why I use ByteString for filepath
06:46:28 <EvanR> all the best stuff is made in japan doc
06:46:39 <ggVGc> yeah, but, was it made in haskell!
06:47:05 <Rembane> maerwald: Won't you have to translate back and forth between the different string types if you do that?
06:47:17 <maerwald> Rembane: no, why?
06:47:31 <Heather> well... okay if you really think that FilePath is a thing
06:47:32 <EvanR> you kind of cant, so no
06:47:34 <maerwald> the posix functions all expect CString anyway
06:47:39 <Rembane> maerwald: Because every package I have seen use String as FilePath.
06:47:43 <maerwald> I don't use those
06:47:45 <Heather> then do you think there should be intuitive connection with a String?
06:47:49 <Rembane> maerwald: So you can go ByteString -> CString?
06:47:57 <Heather> somewhere in readme or documentation?
06:47:58 <EvanR> Rembane: if you dont know the encoding, you strictly speaking cant convert to a String even if you wanted to
06:48:03 <maerwald> @hackage posix-paths
06:48:03 <lambdabot> http://hackage.haskell.org/package/posix-paths
06:48:04 <Rembane> EvanR: That's true. 
06:48:20 <Rembane> maerwald: That's very nice! Thank you.
06:48:26 <ertes> Heather: it's using the system-filepath library: https://hackage.haskell.org/package/system-filepath
06:48:35 <maerwald> the unix package has a ByteString variants too
06:48:42 <maerwald> all other libraries I just hack/patch
06:48:50 <Heather> ertes yes it's overtaking interaction with everything by using it
06:49:19 <ertes> Heather: you should find everything there, including conversion functions, should you need them
06:49:39 <Heather> ertes I was looking but so far can't find them :S
06:49:45 <maerwald> Rembane: yes, if you go String -> CString, it involves a function called "getFileSystemEncoding"... and what that does, I don't know
06:49:58 <Heather> ertes </> only can combine two useless types
06:49:58 <EvanR> o_O
06:50:07 <Rembane> maerwald: It seems like a bit of dark, and foreboding magic.
06:50:39 <maerwald> Rembane: if you cal readdir (the posix function) it returns a null terminated C char array... as soon as you start interpreting it, you're already doing it wrong
06:50:50 <ertes> Heather: see Filesystem.Path.CurrentOS
06:50:52 <ggVGc> ^^^
06:50:53 <ggVGc> yep
06:50:58 <maerwald> the interesting problem is how to deal with _user input_ though
06:51:01 <ggVGc> maerwald: which is why so much software is so broken
06:51:05 <maerwald> but that's a different thing
06:51:21 <EvanR> user input has gotta be easier than this, since its usually delivered to you as unicode
06:51:50 <maerwald> EvanR: in Gtk+ input fields? :o
06:51:51 <EvanR> if youre scanning the keyboard though god help you
06:51:53 <Rembane> maerwald: Lets see. So I should never look at it but send it back to the OS?
06:52:02 <maerwald> GlibString something
06:52:08 <ertes> Heather: hmm…  actually the 'FilePath' type from that package is in fact useless…  i was assuming that it uses one of the more advanced path libraries
06:52:30 <EvanR> maerwald: ... please tell me thats a unicode text type ;)
06:52:37 <ggVGc> we should just had UUIDs for each path on every OS
06:52:40 <ggVGc> and be done with it
06:52:47 <maerwald> Rembane: well, you can look at certain things like '/' or '.'. I mean, you have to.
06:52:55 <EvanR> UUIDs solves everything
06:53:01 <ertes> Heather: well, almost useless…  it does keep you from mixing up FilePath and String…  but the more modern path packages actually provide some correctness guarantees about absolute/relative paths and file/directory paths
06:53:03 * hackagebot hw-conduit 0.0.0.6 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-conduit-0.0.0.6 (haskellworks)
06:53:03 <EvanR> we need a UUID for each UUID
06:53:06 <ggVGc> ertes: especially the input case
06:53:09 <maerwald> but those are clearly defined characters that exist in a filepath
06:53:10 <ggVGc> EvanR: &
06:53:12 <Rembane> maerwald: But all other things, just treat like a bytearray and try to ignore for as long as possible?
06:53:15 <maerwald> so you are allowed to look at them
06:53:51 <EvanR> (unique IDs or IDs for things at all often gets in the way of referential transparency)
06:53:55 <nitrix> ggVGc: UUIDs doesn't give you reproducability, while hashing does.
06:54:05 <ggVGc> let's hash the UUIDs
06:54:32 <nitrix> You're ignoring the problem statement.
06:55:14 <EvanR> maerwald: btw getFileSystemEncoding gives you a TextEncoding object that simply allows invalid utf8/utf16
06:55:26 <ggVGc> wow
06:55:42 <EvanR> thats different from an Encoding (from some encoding lib)
06:55:54 <EvanR> its for translating in the weird locale dependent system.io
06:56:04 <maerwald> it's scary that filepath and directory use that crap
06:56:10 <EvanR> yes
06:56:23 <maerwald> even modules in base
06:56:59 <maerwald> https://ghc.haskell.org/trac/ghc/wiki/Proposal/AbstractFilePath
06:57:11 <maerwald> not sure if that will ever hit
06:57:18 <EvanR> lol i thought i was joking
06:57:54 <EvanR> i think this whole issue calls for a sort-of-clever acme package
06:58:19 <EvanR> it just needs to carefully not be accidentally useful
06:59:38 <emmanuel_erc> maerwald: It would be nice to know what the internal representation would actually be. (Unless I missed that somehow.)
06:59:51 <maerwald> of what?
06:59:57 <emmanuel_erc> AbstractFilePath
07:00:10 <EvanR> that kind of defeats the name of it... in any case
07:00:20 <emmanuel_erc> sure.
07:00:26 <maerwald> WFP ByteArray# on widnows and PFP ByteArray#  on unix
07:00:42 <EvanR> basically bytestring
07:00:48 <emmanuel_erc> yeah
07:00:52 <emmanuel_erc> That makes sense.
07:01:38 * EvanR reads on to find out how horribly inconvenient it will be ;)
07:05:12 <EvanR> question fromFilePath :: FilePath -> String
07:05:23 <EvanR> how does it work
07:05:32 <ggVGc> EvanR: are you gonna solve file paths once and for all_
07:05:34 <ggVGc> ?
07:05:58 <maerwald> this is only filepath problems on lower-levels... even if you use ByteString you still end up with a plethora of other problems
07:06:03 <maerwald> because it's still not WELL typed
07:06:08 <EvanR> with a massive hangover prob not
07:06:10 <maerwald> could be absolute, not absolute and whatnot
07:06:22 <Jonsky> I tried to do "chr 4" but then haskell told me 'chr' is not in scope. Where can I find it?
07:06:28 <bennofs> Jonsky: Data.Char
07:06:33 <bennofs> http://hayoo.fh-wedel.de/?query=chr
07:06:33 <Jonsky> thanks
07:06:58 <EvanR> maerwald: that might be getting a little too crazy
07:07:01 <maerwald> @hackage path
07:07:01 <maerwald> is interesting, but it's still using String as filepath and has some weird semantics
07:07:01 <lambdabot> http://hackage.haskell.org/package/path
07:07:19 <ggVGc> we need to ask a japanese person about this
07:07:26 <ggVGc> why is there not a single japanese person on irc
07:07:28 <maerwald> but at least, we have absolute vs relative distinction, which is pretty important if you want to be e.g. thread safe
07:07:35 <Lovepon> ggVGc: What about Japanese?
07:07:39 <EvanR> theyre on irc but only about 3 of them use haskell
07:07:50 <ggVGc> Lovepon: they probably know a lot about writing software based on not-ascii
07:08:12 <Lovepon> ggVGc: Oh.
07:08:27 <Lovepon> so.
07:08:29 <EvanR> ggVGc: and using legacy encodings
07:08:34 <ggVGc> EvanR: I've literally never spoken to a japanese programmer
07:08:38 <ggVGc> in any online medium
07:08:49 <Lovepon> I'm using stack... I have no fucking idea how to make it work with ghcjs.
07:08:50 <ggVGc> I've met one in japan
07:10:02 <EvanR> i like AbstractFilePath proposal I'm just curious wtf fromFilePath would do, crash sometimes?
07:10:08 <maerwald> lol
07:10:14 <ggVGc> sounds useful
07:10:15 <maerwald> the conversion period will be the worst
07:10:28 <EvanR> if it would crash, how would it even know to crash
07:10:34 <ggVGc> I sincerely beleive for solving this, we need non-western non-english speaking programmers
07:10:37 <maerwald> because everyone will still just use Strings and then convert stuff around
07:10:39 <maerwald> what's the gain
07:10:53 <ggVGc> maerwald: you'd have to prevent that somehow
07:11:01 <ggVGc> or make it a really crap experience
07:11:06 <EvanR> just like you said, you might not need or want to convert String
07:11:11 <EvanR> in which case youre golden
07:11:23 <maerwald> ggVGc: even worse, pretty sure people will end up using Data.ByteString.Char8
07:11:25 <maerwald> wanna make a bet?
07:11:30 <ggVGc> :(((
07:11:37 <EvanR> why would they do that
07:11:46 <EvanR> it sounds very difficult
07:11:57 <ggVGc> here's the thing, by the time we solve this, local file systems will be obsolete and the only notion of paths will be URI's into the cloud
07:12:00 <ggVGc> so..
07:12:01 <ggVGc> maybe just let it die
07:12:32 <EvanR> that sounds awful enough to be true
07:12:33 <Darwin226> Hey guys, should the $() splice syntax work in any kind of quotation or is it a special feature of the built in quoters that allows this?
07:13:04 * hackagebot hw-bits 0.0.0.5 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.0.0.5 (haskellworks)
07:15:10 <maerwald> maybe japanese people don't use haskell because of the filepath mess?
07:15:11 <maerwald> :D
07:16:00 <bennofs> Darwin226: you mean like [customQuote| $(this) |] ?
07:16:16 <EvanR> mostly they use windows which has an abysmal haskell experience
07:16:35 * Lokathor nods quietly
07:16:56 <maerwald> although it's sort of "developed" by MS
07:16:58 <maerwald> which is weird
07:17:06 <EvanR> MS research
07:17:08 <maerwald> yes
07:17:21 <EvanR> AbstractFilePath proposal mailing list thread https://mail.haskell.org/pipermail/ghc-devs/2015-June/009276.html
07:19:45 <EvanR> this just blew my mind... getArgs to get a String (mkay...) then attempt to use one of the args as a FilePath
07:19:56 <EvanR> how in the
07:20:40 <EvanR> (not an edge case)
07:20:52 <Darwin226> bennofs: Yes
07:21:42 <bennofs> Darwin226: yes, the quote text can be an arbitrary string, there is no special support for $(...). If a quasi quote supports this, it's parsed manually by the quasi quote
07:22:44 <Darwin226> bennofs: Is there anything that can be done with quoters that don't support this? I want to insert a string at some specific place but that string should be extracted as an external string variable
07:22:50 <Darwin226> so that other code can use it
07:23:24 <bennofs> Darwin226: unfortunately, I don't think that is possible. 
07:29:16 <Lovepon> Well, I dunno how stack works.
07:31:32 <EvanR> its funny to see a PGP signed message containing only two characters +1
07:40:06 <EvanR> not discussed since june 2015, it seems for whatever other reason that the full scope of how the abstract type will work was never really specified
07:40:42 <EvanR> given the amount of breakage, seems underwhelming as a whole
07:42:06 <simpson> Well, instead of an abstract type, you could always use a very precise type that captures the rich semantics. Something like data FP = [Either ByteString Text].
07:42:31 <EvanR> thats not nearly rich enough
07:42:35 <simpson> With the caveat that you can't really have BS path segments on some platforms.
07:43:37 <EvanR> that thread goes over some genuinely difficult issues like normalization and weird shit like /? in windows
07:44:07 <EvanR> which makes abstract type an obvious answer even if abstract types werent already awesome
07:44:30 <simpson> I guess? Honestly, I'd normally recommend an *object*, but I know how people feel about those.
07:45:36 <EvanR> ... how would an object differ in this case besides look and feel?
07:46:02 <dolio> What even is an object in this case?
07:46:22 <simpson> dolio: It's that thing that makes Haskellers hiss and turn away, kind of like a cross for vampires.
07:46:50 <EvanR> especially if its something haskell doesnt actually have, but i was assuming a record of functions from the ADT api
07:46:56 <simpson> EvanR: The analogy is not to abstract types, but to abstract *typeclasses*; we could implement our own filepath-like things and they'd still interact with standard tooling.
07:47:20 <EvanR> no man i hated that suggestion to instead of an abstract type use IsFilePath typeclass
07:47:23 <EvanR> that makes no sense to me
07:48:35 <EvanR> if the point is to be able to convert whatever to this platforms filepath type, that is what the proposal is already taking care of
07:48:52 <EvanR> (via String at least)
07:49:50 <simpson> Sure, but as long as we're changing the type, we might as well change it to something extensible. It seems really weird to massively improve some part of base but only in one direction.
07:50:19 <simpson> Python did this too; they introduced "pathlib" and proclaimed victory over filesystem paths, but totally failed to enable anybody outside of the stdlib to make their own paths.
07:50:21 <EvanR> its extensible by the library maintainers
07:50:42 <EvanR> for the purposes of making it do new things on whatever platform
07:50:43 <dolio> Why do you need multiple implementations of file paths?
07:51:22 <EvanR> indeed we already have multiple implementations and it would be helluva nice if there was "only 1" 
07:51:24 <simpson> I dunno yet. Same reason that we have overloaded literals, I suppose.
07:51:38 <EvanR> it can be an IsString
07:51:43 <EvanR> (thats in the proposal)
07:52:13 <simpson> A bunch of networking protocols have paths of some sort. There's a bunch of file types that have paths inside them, with the file itself being the root.
07:52:34 <Lokathor> EvanR, so do any other languages get file paths "right"?
07:52:41 <EvanR> specifically concerned about file systems on OSes
07:52:51 <simpson> It would enable *fake* file paths, for making testing easier. No longer do we need to alter the actual filesystem in order to practically test filesystem code.
07:53:00 <maerwald> "file types that have paths inside them"? that's not allowed in unix
07:53:05 * hackagebot rethinkdb 2.2.0.4 - A driver for RethinkDB 2.2  https://hackage.haskell.org/package/rethinkdb-2.2.0.4 (codedmart)
07:53:13 <EvanR> Lokathor: since one of the main ideas here is that a filepath is an opaque blob of bytes, and it almost cant be invalid, yes because that is most languages string type
07:54:05 <simpson> maerwald: TAR, ZIP, ISO 9660, cpio, etc.
07:54:06 <EvanR> its just that haskells string type is not an opaque blob of bytes its list of Char
07:54:31 <maerwald> simpson: I thought you mean the filename
07:54:36 <Lokathor> so we need a toPath :: String -> Maybe FilePath i guess?
07:54:39 <EvanR> simpson: none of these are covered or in scope for standard lib filesystem IO functions
07:54:41 <dolio> If you want to not alter the filesystem, you have to implement different file opening functions, not a different file path type.
07:55:21 <simpson> dolio: That's the other position, yes. TBH I waffle constantly between the two positions; I've wanted to see a clean separation of filepath handling from filesystem accesses, but it's tricky.
07:55:31 <EvanR> zip files and ftp servers should not be built into the filesystem API
07:55:33 <simpson> e.g. traversing a file path requires touching the filesystem.
07:55:34 <EvanR> this isnt PHP
07:56:07 <simpson> EvanR: Right; that's why the API would provide for extensibility without actually putting all the different pieces of functionality into base.
07:56:38 <EvanR> the windows semantics for filesystem paths is completely inappropriate for zip files and URLs
07:56:51 <EvanR> namely half-assed UTF-16 bytes
07:56:58 <EvanR> with special features
07:57:03 <simpson> EvanR: Which is why you'd have IsFilePath or etc.
07:57:13 <EvanR> why?
07:57:26 <EvanR> to use URLs on the filesystem?
07:58:03 <simpson> I think that you're deliberately misunderstanding my point now.
07:58:05 * hackagebot hsc2hs 0.68 - A preprocessor that helps with writing Haskell bindings to C code  https://hackage.haskell.org/package/hsc2hs-0.68 (HerbertValerioRiedel)
07:58:05 <EvanR> "any conversion problem is a multiparameter typeclass" isnt my favorite
07:58:47 <simpson> Anyway, if you do solve filesystem and filepath handling, let me know; I've wanted to see it solved for a while now.
07:59:59 <maerwald> technically, it's easy to solve, but not for the whole ecosystem
08:00:32 <EvanR> are you referring to gtk+
08:00:44 <maerwald> ?
08:00:54 <EvanR> what does not for the whole ecosystem mean
08:01:15 <maerwald> I thought that was obvious now, given the discussion
08:01:24 <maerwald> it breaks APIs?
08:01:27 <EvanR> ok
08:01:39 <EvanR> it would break code all around
08:01:52 <EvanR> i thought you had a specific thing where solving it is not easy
08:17:17 <funrep> does stack replace cabal?
08:17:29 <dcoutts> funfun: depends who you talk to
08:17:34 <Heather_> stack is using cabal
08:17:42 <funrep> okey
08:18:34 <Heather_> and it's still being not a package manager and still can't handle abi breakage
08:19:01 <Heather_> just another handy hack to make your sandboxes a bit shiner
08:19:22 * funfun confused
08:20:28 <Heather_> time for me to disappear because it's really not place for an stack hater to speak about stuff :D
08:24:20 <matt-> funfun: cabal and stack are build tools, not package managers. That means its better to sandbox your projects with the dependencies they need, rather than trying to install packages you need in a global environment.
08:24:36 <matt-> At least, that's how I understand it. I'm sure somebody will correct me; I'm quite new at this.
08:25:07 <matt-> If you're not sure which one to use, stack is probably the best way to get started.
08:26:49 <srhb> matt-: Pretty much, though it might be worth mentioning the difference between Cabal the library and cabal-install. The former is used by both Stack and cabal-install, and cabal-install provides the executable "cabal" for maximum confusion.
08:27:25 <matt-> srhb: That explains so much.
08:27:45 <srhb> matt-: Hooray, I've explained things!
08:27:51 <Akii> :D
08:28:33 <srhb> Really, the cabal executable should have been called cabal-install, but I guess "cabal-install install" is a bit weird.
08:28:37 <nitrix> Hopefully cabal-install dies and we'll be left with Cabal and Stack.
08:28:51 <srhb> nitrix: Looks that way, certainly.
08:29:06 <dcoutts> nitrix: sorry to disappoint, there's a major new release out soon
08:29:09 <srhb> Except cabal-install is really nice to use with Nix, but I guess we can make Stack work, too.
08:29:20 <dcoutts> with a tech preview of new nix-style local builds
08:29:22 <srhb> Ooooh
08:29:31 <srhb> So long, Stack! :-)
08:30:02 <nitrix> I hate these kind of gotchas.
08:30:55 <dcoutts> if you're interested you can try the 1.24 branch now
08:31:07 <dcoutts> and the "new-build" tech-preview
08:31:09 <nitrix> The "it was Friday and 9PM" isn't an excuse when you have that many people embracing a project's bogus name and thinking it's okay.
08:31:31 <cgrs> hi everyone!
08:31:36 <nitrix> I really wonder how it came up to be. It surely confused me as a beginner.
08:31:37 <haskell620> how can I get a elements from a list up to one element for example I want to get everything before 12 and 12 also in [1,2,3,4,12,5,6,3]
08:31:42 <cgrs> i have a question about the dot operator
08:31:47 <srhb> dcoutts: Thanks :)
08:31:55 <srhb> haskell620: Maybe look at takeWhile
08:32:29 <haskell620> takeWhile gets everything before the element
08:32:32 <cgrs> how can I reduce the number of nested parentheses with that operator?
08:32:37 <haskell620> it would give me [1,2,3,4]
08:32:41 <haskell620> i want 12 also
08:33:41 <cgrs> haskell620: takeWhile (==12) maybe?
08:33:49 <nitrix> snd . span (/=12)
08:33:54 <fr33domlover> Which macros are predefined when enabling LANGUAGE CPP ? I can't find a list anywhere :-/
08:34:07 <fr33domlover> e.g.it seems __DATE__ and __TIME__ are available
08:34:07 <nitrix> > snd . span (/=12) $ [1,2,3,4,12,5,6,3]
08:34:08 <lambdabot>  [12,5,6,3]
08:34:18 <nitrix> Oh, before.
08:35:14 <Ferdirand> what if there is no 12 ? 
08:36:14 <srhb> cgrs: I don't understand the question. Can you elaborate?
08:37:10 <funfun> matt-: i didn't ask the question. i think it was funrep. ;)
08:37:23 <darkmercenary> hello, quick question, ive seen people do this before with records. what does it do? Rec{..} = ...
08:37:41 <matt-> funfun: Oops. I have a condition where I only read the first three letters of peoples' names. 
08:37:55 <funfun> no worries. :D
08:38:47 <hpc> darkmercenary: record wildcard syntax - it requires a language extension but it's sometimes a rather nice shorthand
08:38:56 <matt-> > reverse (dropWhile (/=12) (reverse [1,2,3,4,12,5,6,3]))
08:38:58 <lambdabot>  [1,2,3,4,12]
08:39:04 <cgrs> srhb: for example, http://lpaste.net/981195891635388416
08:39:04 <matt-> ¯\_(ツ)_/¯
08:39:10 <matt-> but empty list if no 12
08:39:15 <nitrix> matt-: That's bogus if you have 12 twice.
08:39:18 <hpc> how it works is well documented on the wiki
08:39:22 <cgrs> srhb: (line 30)
08:39:25 <nitrix>  > reverse (dropWhile (/=12) (reverse [1,2,3,4,12,5,6,12,3]))
08:39:28 <matt-> nitrix: good catch, thanks!
08:39:35 <nitrix> > reverse (dropWhile (/=12) (reverse [1,2,3,4,12,5,6,12,3]))
08:39:36 <lambdabot>  [1,2,3,4,12,5,6,12]
08:40:03 <lyxia> darkmercenary: if you have a data Rec = Rec { field :: Field }, let Rec{..} = ... is like let Rec field = ...
08:40:44 <cgrs> srhb: (that's a bad example lol)
08:40:49 <darkmercenary> hpc: thanks, yea i looked it up
08:40:52 <darkmercenary> lyxia: thank you
08:41:36 <darkmercenary> im doing stuff at work and i have to deal with lots of fields so i knew i saw something like that to help
08:41:57 <srhb> cgrs: Yeah, the answer to that is "not" :-)
08:42:05 <Athas> How do I best detect whether my program is running on OS X or a operating system?
08:42:11 <nitrix> @let takeWhileInclusive p (x:xs) = x : if p x then takeWhileInclusive p xs else []
08:42:12 <lambdabot>  Defined.
08:42:20 <cgrs> srhb: sorry mate xD
08:42:22 <hpc> darkmercenary: there's some other extensions having to do with records as well, but i don't remember their names or if they fall below or sideways to record wildcards
08:42:26 <hpc> might want do do a bit more digging
08:42:38 <srhb> cgrs: Whenever you're writing f(g(x)) you can do (f . g) x instead. That's all there is to it.
08:42:54 <nitrix> > takeWhileInclude (/=12) [1,2,3,4,12,5,6,12,3]
08:42:55 <lambdabot>      Not in scope: ‘takeWhileInclude’
08:42:56 <lambdabot>      Perhaps you meant ‘takeWhileInclusive’ (line 152)
08:42:59 <nitrix> > takeWhileInclusive (/=12) [1,2,3,4,12,5,6,12,3]
08:43:01 <lambdabot>  [1,2,3,4,12]
08:43:13 <nitrix> haskell620: ^
08:43:19 <cgrs> srhb: okay, i'll try again when i get a clearer example
08:43:23 <matt-> takeWhileInclusive (/=12) [1,2,3,4,5,6,3]
08:43:31 <matt-> > takeWhileInclusive (/=12) [1,2,3,4,5,6,3]
08:43:32 <lambdabot>  [1,2,3,4,5,6,3*Exception: /tmp/mueval1850952926437116466.hs:(152,1)-(153,51)...
08:43:34 <cgrs> i think i understood it for now
08:43:47 <nitrix> matt-: It needs a little hardening, but it's feasible.
08:45:04 <matt-> @let takeWhileInclusive p [] = []
08:45:05 <lambdabot>  Defined.
08:45:10 <nitrix> yup.
08:45:11 <darkmercenary> hpc: i think there was something called overloadedrecordfields but i think its not 100% done yet? i have to put my datatypes into different modules or give them prefixes or suffixes on their fieldnames because theyre so similar
08:45:20 <matt-> > takeWhileInclusive (/=12) [1,2,3,4,5,6,3]
08:45:21 <lambdabot>  [1,2,3,4,5,6,3]
08:45:35 <nitrix> haskell620: Does that helps (: ?
08:46:21 <haskell620> yeah thanks a lot
08:46:45 <cgrs> thanks ;D
08:46:50 <haskell620> also tell me please how can I reply to someone in here i'm a noob to irc
08:47:00 <matt-> haskell620: Like this.
08:47:13 <nitrix> haskell620: Everyone sees your message. Simply putting the name in your message shuold highlight them in their client.
08:47:19 <matt-> ^
08:47:35 <haskell620> nitrix did it work?
08:47:39 <nitrix> mhm :)
08:47:41 <hpc> haskell620: almost every irc client is going to allow you to just type "ha<tab>" and it will fill in the rest
08:47:54 <haskell620> ok thanks
08:49:55 <srhb> hpc: It's unambiguous with "has" -- incredibly.
08:51:57 <cgrs> srhb: got it => fst(Data.List.partition (odd) [1..10]) 
08:52:10 <cgrs> how could i get rid of the parentheses?
08:52:24 <srhb> (fst . partition odd) [1..10
08:52:27 <srhb> ]
08:52:41 <cgrs> srhb: that was what i was thinking ^^'
08:52:50 <srhb> cgrs: Note that the one around odd was superfluous anyway
08:52:59 <cgrs> yup? okay
08:53:02 <cgrs> thanks so much
08:53:03 <nitrix> Cr8: fst . partition odd $ ...
08:53:10 <nitrix> cgrs: *
08:53:43 <cgrs> (you know, i got a haskell test next day tomorrow... XD)
08:53:44 <nitrix> cgrs: (.) and ($) are important / commonly used grammar, I suggest you look them up :)
08:54:20 <cgrs> nitrix: i'll take another look, i'm totally sure they're pretty important
08:54:38 <cgrs> thanks people :)
08:54:48 <nitrix> Keep in mind too much is like not enough, as far as (.) goes. (So called, point-free style).
08:54:48 <srhb> cgrs: I think learning how to use (.) easily is mostly not about its definition, but more about understanding how function application works wrt. associativity etc.
08:55:31 <cgrs> okay mates, i'll take your advices
08:55:32 <srhb> That is, partition odd foo is (partition odd) foo, and so on.
08:55:41 <cgrs> you've been really helpful :)
08:56:02 <srhb> cgrs: Good luck with your test. :)
08:56:28 <cgrs> srhb: thanks! 
08:57:30 <guillaum3> Hi there. I was wondering something. There is a huge hype about dependent types, for example the famous "type safe" `printf :: String -> t` where t depends on the value of the String. However how does that behaves if the String is not known at compile time ?
08:58:41 <monochrom> I haven't heard anyone using printf to hype dependent types.
08:59:47 <funrep> guillaum3: interesting question
08:59:49 <EvanR> now hold on a minute
09:00:13 <EvanR> thats not how printf usually works, and arguably has less functionality than usual
09:00:48 <funrep> https://gist.github.com/puffnfresh/11202637
09:00:56 <funrep> (not mine but an implementation of it in idris)
09:01:36 <EvanR> perhaps printf :: (s :: String) -> PrintfArgs s -> String
09:01:54 <EvanR> or -> PrintfTy s
09:02:10 <spion> guillaum3: afaik you need to supply a proof that interpFormat really does result with that type. re funrep's gist
09:02:17 <spion> not sure how thats done.
09:03:44 <EvanR> if s is a constant then youll get a lot of magic going on for free
09:11:39 <maerwald> yes, there's a video about it https://www.youtube.com/watch?v=fVBck2Zngjo
09:12:15 <maerwald> dependent types is so much power though, I fear it will be heavily abused
09:12:34 <maerwald> resulting in stuff that is hard to reason about
09:43:09 * hackagebot stratosphere 0.1.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.1.0 (jdreaver)
09:54:28 <hackrilege> in this example, a list zipper is stored in each of its configurations in a tree, the zipper had functions left and right, as does the binary tree. im wondering if there is something deeper about this connection between a zoipeer annd a tree
09:54:29 <hackrilege> http://lpaste.net/160584
09:55:54 <hackrilege> even thought the zipper is stored at each fork in the Tree, and could be accessed and used to find adjacent elements, so could the tree, the adjacent zippers being stored in the branches at this fork inn the tree
09:57:13 <hackrilege> the single pointer dereferencing to find the contents of these branches should be less expensive than updating the full 2d zipper (map right) no??
09:57:47 <hackrilege> has anyone seen this consideration arise before or have any relevant reference material?
09:58:30 <hackrilege> or could help me think about this "zippers should be stored in something less expensive to navigate than a zipper" consideration
09:58:56 <hackrilege> *over*
09:59:45 <nineonine> hi everyone ! can anyone share the link to the video where SPJ discusses changes in ghc 8 ?
10:00:32 <nineonine> he usually does these status update videos
10:16:00 <apriori> hello guys. when using cabal, depending on whether the project is just build as-is or in a soundbox, the actual location of "dist" might change. is there a way to programmatically find that directory?
10:16:05 <apriori> like in the Cabal-API?
10:18:09 <davean> apriori: Uh, if you "cabal build" I was fairly sure everything ended up in "dist" as normal either way (and I've used both a decent bit)
10:18:19 <davean> apriori: can you expand on the issue?
10:18:41 <apriori> well, I try to fix the broken build process of LibClang
10:18:53 <apriori> it expects certain files to be put e.g. in dist/build
10:19:13 <apriori> issue is, if I build that project from somewhere else (to be put in a cabal sandbox), pathes change completely
10:19:14 <apriori> like:
10:19:28 <apriori>  "../LibClang/dist/dist-sandbox-9cc46a10/"
10:19:35 <davean> "to be put", waht do you mean by that?
10:19:46 <davean> Why aren't you just add-sourcing it?
10:20:00 <apriori> well, it does some chs generation in the Setup.hs
10:20:34 <apriori> and paths are hardcoded relative to the working directory
10:20:51 <apriori> or lets say "expected" working directory
10:21:34 <davean> so add-source fails to function properly because of that
10:22:00 <apriori> these are generated at runtime by Setup.hs
10:22:31 <davean> Right
10:23:10 * hackagebot hakyll 4.8.0.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.8.0.0 (JasperVanDerJeugt)
10:24:37 <apriori> ah
10:24:41 <apriori> I'm getting there
10:25:05 <apriori> Distribution.Simple.LocalBuildInfo->buildDir does what I'm searching for
10:29:42 <spion> is there an implementation of runSTMap ? right now I'm building an index to an array then using runSTArray...
11:16:11 <Jonsky> Is that isDigit has been moved out of preclude? I am learning Haskell from a book written in 2008
11:17:02 <shachaf> I don't know whether it's ever been in Prelude. But at any rate it isn't there now.
11:17:29 <Jonsky> http://teaching.csse.uwa.edu.au/units/CITS3211/lectureNotes/tourofprelude.html
11:17:51 <Jonsky> I also see it here. Maybe in the ancient time it was in the preclude...
11:18:10 <Jonsky> shachaf: and thanks for the answer
11:20:13 <Oejet> :t Data.Char.isDigit
11:20:15 <lambdabot> Char -> Bool
11:20:50 <shachaf> Well, it's still available in Data.Char, so that shouldn't preclude you from using it.
11:21:29 <Jonsky> another question: can I import Data.*?
11:22:53 <shachaf> You can't.
11:23:21 <jlyfsh> Newbie question: I'm trying to make a function [[String]] -> (String,String), the strings in [[String]] are always exactly 2 per list as in [["foo","bar"],["quz","qux"]]. I think there's a simple solution I simply can't see
11:23:41 <jlyfsh> Ergh, sorry. I meant [[String]] to [(String,String)]
11:23:54 <Cale> [(x,y) | [x,y] <- xs]
11:24:19 <Cale> Note: this will implicitly filter out any elements of xs which aren't exactly two elements long
11:24:57 <Jonsky> okay, seems I have to be careful with the import. Thanks again
11:25:08 <jlyfsh> Cale: Thanks! Now I feel stupid though. But Haskell does that to me a lot so it doesn't matter..
11:25:21 <jle`> no need to feel stupid :)
11:25:45 <Jonsky> good to know I am not the only starter here :)
11:26:51 <Oejet> Jonsky: You could do something like: import Data.Char as Char.
11:28:53 <Jonsky> Oejet: Thanks. Glad to see the syntax is similar to Python.
11:29:14 <Jonsky> (Am I allowed to mention the Great Snake here?)
11:29:33 <jle`> as long as it's on-topic :)
11:31:03 <Jonsky> :)
11:32:13 <darkmercenary> so im using selectList from persistent and im just getting all records from a table. the thing is im reusing selectList for all my tables
11:32:29 <darkmercenary> is it possible to just have a getall function like
11:32:30 <darkmercenary> getAll = do     xs <- runDB (selectList [] [])     let records = map (\(Entity _ v) -> v) xs     return records
11:32:47 <darkmercenary> and then have it figure out based on the type of whats using it
11:33:06 <darkmercenary> im getting type errors
11:33:13 <darkmercenary> "ambiguous"
11:35:10 <darkmercenary> the above wont give me an error if i give a type signature like getTableA :: Handler [ARecords]
11:35:35 <darkmercenary> however im using servant and itd be nice to just have getAll :: Handler [a]
11:35:48 <darkmercenary> and then use getAll as a handler for my servant routes
11:35:58 <darkmercenary> instead of redoing it
11:36:14 <lyxia> Handler [a] means you can get any type out of it...
11:36:40 <Oejet> Jonsky: For off-topic discussion there's e.g. #haskell-blah (requires SSL).
11:36:56 <haskell663> Hi how could I make this function give me another random at each iteration? http://lpaste.net/8963237713255858176
11:38:38 <darkmercenary> mmm let me rephrase then
11:38:50 <darkmercenary> how can i avoid writing this
11:39:15 <darkmercenary> getTableA :: Handler [ARecord]    getTableA = do     xs <- runDB (selectList [] [])     let records = map (\(Entity _ v) -> v) xs     return records
11:39:23 <darkmercenary> getTableB :: Handler [BRecord]    getTableB = do     xs <- runDB (selectList [] [])     let records = map (\(Entity _ v) -> v) xs     return records
11:39:32 <darkmercenary> getTableC :: Handler [CRecord]    getTableC = do     xs <- runDB (selectList [] [])     let records = map (\(Entity _ v) -> v) xs     return records
11:39:34 <darkmercenary> and so forth
11:39:54 <nitrix> >>=
11:40:04 <nitrix> Monadic binding.
11:40:09 <glguy> haskell663: You shouldn't be passing the same generator (g1) to every call to randomR like that
11:40:24 <lyxia> darkmercenary: you need to find the constraints that are used on ARecord etc.
11:41:23 <lyxia> darkmercenary: try a type hole like this "getTable :: _" and copy paste what GHC infers
11:41:35 <lyxia> at the place o
11:41:37 <lyxia> f the hole
11:42:36 <haskell663> glguy I thought so is there a solution?
11:42:52 <glguy> haskell663: don't throw away the generator that randomR returned
11:42:57 <glguy> use it for the next call
11:43:12 <haskell663> glhuy how please tell me
11:46:00 <darkmercenary>   Couldn't match expected type ‘SqlBackend’                 with actual type ‘PersistEntityBackend b0’
11:46:01 <darkmercenary>    The type variable ‘b0’ is ambiguous     Relevant bindings include       getAll :: m0 [b0] (bound at src/Novation/Handler.hs:99:1)     In the first argument of ‘runDB’, namely ‘(selectList [] [])’
11:46:02 <lpaste> glguy annotated “RandPath” with “RandPath (annotation)” at http://lpaste.net/8963237713255858176#a160768
11:46:25 <glguy> haskell663: Something like that
11:46:59 <jakeehrlich> How does one run their main application from stackage?
11:47:08 <haskell663> glguy woah thanks man
11:47:33 <jakeehrlich> Like I have a main under my app folder in a stackage project and I want to run that code with command line parameters
11:48:30 <cocreature> jakeehrlich: you probably mean a stack project not a stackage project, and in that case it’s “stack exec executablename -- parameters”
11:49:12 <jakeehrlich> what's my executables name?
11:49:36 <cocreature> I don’t know, look how you named it in your cabal file :)
11:50:23 <jakeehrlich> ah ok it defaults to <project_name>-exe when you run stack init
11:50:30 <jakeehrlich> Thank you that works!
11:58:14 * hackagebot shake 0.15.6 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.15.6 (NeilMitchell)
11:58:16 * hackagebot skulk 0.1.1.0 - Eclectic collection of utility functions  https://hackage.haskell.org/package/skulk-0.1.1.0 (geekyfox)
11:58:33 <Rembane> Shake and skulk. Nice combination.
12:00:00 <hpc> wow, different authors
12:05:26 <orion> I'm struggling to write a set of Arrows to do this: (Either a (b, c), Either a (b, c)) -> Maybe (c, c) -- anyone have any pointers?
12:05:56 <orion> So far I have x = undefined *** undefined. :)
12:10:45 <Hafydd> Pointers!
12:13:29 <scshunt> orion: why do you want arrows?
12:13:50 <hpc> @djinn (Either a (b, c), Either a (b, c)) -> Maybe (c, c)
12:13:50 <lambdabot> f (a, b) =
12:13:50 <lambdabot>     case a of
12:13:50 <lambdabot>     Left _ -> Nothing
12:13:50 <lambdabot>     Right (_, c) -> case b of
12:13:50 <lambdabot>                     Left _ -> Nothing
12:13:52 <lambdabot>                     Right (_, d) -> Just (d, c)
12:14:22 <orion> scshunt: Aren't arrows really good for transforming data like this?
12:14:52 <hpc> depending on who you ask, you may hear that arrows aren't really good for much of anything
12:15:10 <scshunt> ^
12:15:10 <orion> I didn't realize there was a divide in the community.
12:15:28 <orion> (On arrows at least)
12:15:29 <EvanR> that there is a divide might be fairness bias
12:15:33 <scshunt> imo arrows provide some cute notation for splitting and joining tuples
12:15:33 <hpc> to be fair, the issue of arrows isn't if they /can/ do something but if they should
12:15:55 <scshunt> anyway, it doesn't appear to me that you have much of an arrow here.
12:16:06 <scshunt> Either is not an instance of Arrow
12:16:16 <hpc> anyway if the type you gave is exactly what you will end up needing, i recommend something like that djinn output
12:16:25 <hpc> except not because that definition is horridly verbose
12:16:25 <orion> scshunt: ArrowChoice?
12:17:38 <scshunt> orion: is a subclass of Arrow
12:21:50 <adamCS> You can use the "arrowish" (&&&) to help some here.  But, as scshunt says, that's just syntactic sugar for operating on the input tuple.
12:22:34 <hpc> orion: what is this going to be used for?
12:23:03 <EvanR> wasnt there an simple pathological case to make the type checker take a really long time involving nested id's
12:23:05 <dolio> @type both._Right._2
12:23:06 <lambdabot> (Applicative f, Field2 a b a1 b1, Data.Bitraversable.Bitraversable r) => (a1 -> f b1) -> r (Either c a) (Either c a) -> f (r (Either c b) (Either c b))
12:23:17 <orion> http://lpaste.net/8880641132761972736 <-- This feels like a good solution.
12:23:18 <dolio> Whoops.
12:23:30 <hpc> EvanR: i know the one that's just a bunch of fmaps
12:23:39 <hpc> :t fmap fmap fmap fmap fmap fmap fmap
12:23:40 <lambdabot> (Functor f, Functor f1, Functor f2) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
12:23:52 <EvanR> this blog post, seems to have done it with nested id's but it runs really fast for me up to 10 levels http://spacemanaki.com/blog/2014/08/04/Just-LOOK-at-the-humongous-type/
12:23:54 <hpc> (that one gets noticably slow at 30-ish iirc)
12:24:11 <EvanR> didnt bother going further
12:24:35 <EvanR> :t id . id . id . id
12:24:36 <lambdabot> c -> c
12:24:40 * EvanR shrug
12:31:58 <NemesisD> hi folks. in ghci why is it if i do something like :set -fobject-code and then :show, that flag doesn't appear
12:33:22 <hsk3> To keep my GHCi environment tidy, I put this into my ~/.ghci file:          :set prompt "ghci> "
12:33:22 <hsk3> But how do I now see which modules are currently loaded?
12:33:26 <hsk3> Is there a command for that?
12:33:46 <NemesisD> hsk3: there's :show modules
12:34:19 <hsk3> NemesisD: But if I do "import Control.Monad" and then ":show modules", nothing shows.
12:35:14 <NemesisD> weird..
12:36:45 <adamCS> orion: Sorry! Wrong arrow operator.  I meant (***). Anyway, you could do it like this also: http://pastebin.com/vHuC9WGK
12:37:10 <hsk3> NemesisD: that's not what happens for you?
12:38:17 <NemesisD> hsk3: no, the same happens for me
12:39:40 <orion> adamCS: Thanks!
12:40:37 <adamCS> orion:  One more, combining the charms of each: http://pastebin.com/FrPYcuAS
12:40:40 <adamCS> np
12:40:56 <EvanR> "Just-in-time Static Type Checking for Dynamic Languages" https://arxiv.org/pdf/1604.03641v1
12:44:03 <jp_rider> hi, how do I use template haskell to create typeclass instances with type synonyms? It looks like TyVarBndr does not accept any ConT's
12:44:18 <jp_rider> When I try to use PlainTV, I get:
12:44:19 <jp_rider> Illegal type variable name: ‘User’
12:45:33 <EvanR> type variables have to have lower case letters
12:45:51 <jp_rider> Right, but I don't want a type variable
12:46:32 <jp_rider> I want something like: http://lpaste.net/1354255900562423808
12:48:01 <EvanR> this ticket mentions something called TySynD
12:48:04 <EvanR> https://ghc.haskell.org/trac/ghc/ticket/10891
12:48:10 <gkdfjgkdfgj> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
12:48:11 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
12:48:41 <EvanR> jp_rider: the context of the ticket is that since TH has its own AST some features of the language may not immediately make it into TH even if they are normally available
12:48:51 <gkdfjgkdfgj> @undo do (f, s')  <- p1 s ; (x, s'') <- p2 s' ; return (f x, s'')
12:48:51 <lambdabot> p1 s >>= \ (f, s') -> p2 s' >>= \ (x, s'') -> return (f x, s'')
12:49:03 <EvanR> i think that one is talking about type families though, not associated types
12:49:12 <EvanR> oh nvm thats the same thing
12:50:00 <EvanR> but its about reifying rather than generating
12:50:09 <jp_rider> hmm ok
12:50:42 <jp_rider> so you're saying TH might not be able to express the syntax as written?
12:51:32 <jp_rider> maybe there's a way to expand out the type family then?
12:52:13 <hsk3> Why doesn't ":show modules" show me anything?
12:52:16 <hsk3> Even after I load modules.
12:52:17 <hsk3> wtf?
12:52:34 <EvanR> jp_rider: im not sure if support exists
12:54:26 <jp_rider> ok ill keep poking around
12:54:29 <jp_rider> thanks for the help
12:55:29 <EvanR> jp_rider: in this ticket they seem to be having trouble with existing support, so theres that ;) https://ghc.haskell.org/trac/ghc/ticket/4135
12:57:06 <hsk3> NemesisD: ok ":show imports" does it :)
13:05:26 <cmotoche> When I open ghci with stack inside a project I load all the modules exposed in the project. Is there a way to clean the prompt? So, I only have a prompt like "*lambda> " instead of "*Main Application Auth... (many modules after that) > "
13:08:05 <nitrix> :set prompt
13:08:26 <nitrix> e.g. set prompt "ghci> "
13:08:47 <nitrix> Typically people add it to their ghci configuration file.
13:13:32 <jp_rider> EvanR: I moved the associated type from inside the typeclass to outside as a type family and it looks like that's working. Thanks!
13:14:07 <EvanR> Hummingbird works by tracking type information
13:14:07 <EvanR> dynamically, but then checking method bodies statically at
13:14:08 <EvanR> run time as each method is called
13:18:29 * hackagebot lmonad-yesod 1.0.0.0 - LMonad for Yesod integrates LMonad's IFC with Yesod web applications.  https://hackage.haskell.org/package/lmonad-yesod-1.0.0.0 (jp_rider)
13:19:33 <JagaJaga> Hi all! Do someone use gitlab runner (CI) with haskell project? Can you provide me your .gitlab-ci.yaml?
13:28:25 <muyfine> have some issues trying to get lenses to work with a sum type (that has a product type inside of it)
13:28:33 <muyfine> http://lpaste.net/160775
13:29:29 <muyfine> trying to figure out to make Fruits have an instance of HasFruit
13:32:40 <skdfjskdfjkdsjf> @pl h s = (\(r, s') -> runParser (r <$> p2) s') =<< (runParser p1) s
13:32:41 <lambdabot> h = (uncurry (runParser . (<$> p2)) =<<) . runParser p1
13:39:26 <skdfjskdfjkdsjf> @pl h s = (\(r, s') -> first r <$> p2 s') =<< p1 s
13:39:26 <lambdabot> h = (uncurry ((. p2) . (<$>) . first) =<<) . p1
13:42:41 <lpaste> byorgey annotated “Fruit.hs” with “Fruit.hs (annotation)” at http://lpaste.net/160775#a160776
13:43:20 <byorgey> muyfine: I don't think there's a way to generate an instance HasFruit Fruits by default, but writing an explicit instance is not hard --- see my annotation to your paste
13:44:12 <muyfine> byorgey - thanks! looking...
13:47:35 <muyfine> byorgey: thanks - that works perfectly. thanks so much, thought it was going to be a lot more involved
13:47:58 <byorgey> sure, glad to help
13:53:07 <skdfjskdfjkdsjf> @pl p1 <*> p2 = Parser $ \s -> (\(r, s') -> runParser (r <$> p2) s') =<< (runParser p1 s)
13:53:07 <lambdabot> (line 1, column 12):
13:53:07 <lambdabot> unexpected " "
13:53:39 <skdfjskdfjkdsjf> @pl Parser $ \s -> (\(r, s') -> runParser (r <$> p2) s') =<< (runParser p1 s)
13:53:40 <lambdabot> Parser ((uncurry (runParser . (<$> p2)) =<<) . runParser p1)
13:55:40 <skdfjskdfjkdsjf> @pl \(r, s') -> runParser (r <$> p2) s'
13:55:40 <lambdabot> uncurry (runParser . (<$> p2))
14:01:23 <kadoban> Huh, managed to get hlint to give me an invalid "redundant bracket" warning, without even using funny operators. I didn't think it could do that.
14:01:41 <hackrilege> if a list ([a]) zipper looks like ([a],[a]) what does a tree (Tree a,a,Tree a) zipper look like?
14:02:58 <hackrilege> similarly, what does a zipper for a rose tree (a,[RoseTree a]) look like?
14:04:11 <hackrilege> the latter is left as an exercise in http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/
14:05:10 <skdfjskdfjkdsjf> @pl h xs = (\(p, ys) -> p <$> g ys) <$> (f xs)
14:05:10 <lambdabot> h = (uncurry ((. g) . (<$>)) <$>) . f
14:06:16 <dalastboss> is there an analog of the show type class for text
14:10:16 <skdfjskdfjkdsjf> @pl x =<< f xs
14:10:16 <lambdabot> x =<< f xs
14:10:28 <skdfjskdfjkdsjf> @pl h xs = x =<< f xs
14:10:28 <lambdabot> h = (x =<<) . f
14:15:02 <ertesx> http://lpaste.net/160778
14:15:14 <ertesx> trying to implement an efficient 'merge' for sorted vectors
14:15:59 <ertesx> one (merge) uses vector's builtin streaming, while the other one (mergeST) just writes into a new array directly
14:16:33 <ertesx> i would expect both of them to perform about equally well, but in fact mergeST is about a hundred times faster
14:16:47 <ertesx> am i doing something wrong there with vector streaming?
14:28:32 * hackagebot hw-diagnostics 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-diagnostics-0.0.0.1 (haskellworks)
14:37:01 <yarax> Guys, trying to figure out how to implement "duck typing" sum in haskell. So it should be a function, that accepts either char or int, and depending on it either concat it or add
14:37:10 <yarax> Do I need to define a new type?
14:38:32 * hackagebot unix 2.7.2.0 - POSIX functionality  https://hackage.haskell.org/package/unix-2.7.2.0 (HerbertValerioRiedel)
14:39:20 <EvanR> you can accept Either Char Int, but its probably not what you want
14:43:16 <hackrilege> the problem im facing while trying to understand how to construct a zipper for a rose tree is that while a list can be constructed in reverse (snoc list) a tree isnt the same backwards! a list zipper ([a],[a]) has a backwards and a forwards list, but (Tree a,Tree a) couldnt be constructed in the same way, there are many branches which can be grown
14:43:34 <geppettodivacin> yarax: You could define a type class and define an instance for both Int and Char.
14:45:12 <hackrilege> the problem seems to be how to construct a tree with only a single constructor, and indicating which branch should be grown
14:45:15 <yarax> @geppettodivacin thanks!
14:45:15 <lambdabot> Unknown command, try @list
14:45:21 <EvanR> geppettodivacin: it might be tough to get it to either "add or append" that way
14:45:38 <EvanR> unless this is a reinvention of Monoid
14:45:51 <geppettodivacin> Mm, that's true.
14:46:20 <EvanR> this is more of what do you really want to do territory
14:46:24 <geppettodivacin> yarax: Are you talking about having a function that is f:: Char -> [Char] and f:: Int -> Int ?
14:48:32 * hackagebot rtcm 0.1.5 - RTCM Library.  https://hackage.haskell.org/package/rtcm-0.1.5 (markfine)
14:49:47 <EvanR> hackrilege: for a rose tree zipper you can either go back (in one way) or move forward (in many ways, or no ways)
14:50:05 <EvanR> or not be able to go back
14:50:26 <hackrilege> you should be able to go back
14:50:35 <EvanR> unless youre at the beginning
14:50:39 <hackrilege> oh ok
14:50:59 <EvanR> when you go forward, youll need to put the current level above you, and so the "back" structure will be upside down
14:51:12 <hackrilege> anyhow, am i right in thinking i would need to store a tree with its constructor open
14:51:15 <hackrilege> ?
14:51:35 <EvanR> constructor open?
14:51:38 <hackrilege> so then a ListZipper would be something like (:xs,:ys) ::  (a->[a],a->[a])
14:52:17 <EvanR> if you want to
14:52:23 <hackrilege> for a list this seems silly, because given [a] we can generate :[a] trivially, but given a tree, there are many places i can construct too
14:52:55 <EvanR> im sure you can do it with a tree and not in that style
14:53:03 <hackrilege> but i guess when you think about it upside down there is only one place to construct it and thats at the top
14:53:04 <EvanR> but that style is cool
14:53:27 <hackrilege> i have a paste about a compas, but its not complete...
14:53:30 <EvanR> check out the maze zipper... its in a post
14:54:11 <ertesx> Squarism: how did the exercise go?
14:54:22 <EvanR> https://en.wikibooks.org/wiki/Haskell/Zippers
14:54:23 <Squarism> ertesx, Hi
14:54:40 <ertesx> hi there
14:54:42 <Squarism> I gos some helt from people after you left. 
14:54:45 <Squarism> got
14:54:57 <hackrilege> EvanR, this paste is not what the way i would like to present this, but its the current state of the source code, relevant is 'compas'
14:55:11 <hackrilege> http://lpaste.net/160790
14:56:20 <Squarism> ertesx, working multichar hangman 
14:56:25 <Squarism> ertesx, http://lpaste.net/160792
14:57:26 <Squarism> ertesx,  hackrilege or nshepperd helped me
14:57:36 <ertesx> wow, that's complicated
14:57:39 <Squarism> cant remember who provided the monad solution
14:57:50 <ertesx> and how did the monad even make it there?
14:58:08 <hackrilege> nshepperd introduced it, i wasnt sure about it
14:58:28 <hackrilege> the annotations on this paste give a working non monadic version
14:58:29 <hackrilege> http://lpaste.net/160596
14:59:03 <ertesx> i like that one much better
14:59:42 <ertesx> Squarism: do you understand your solution?
14:59:47 <Squarism> ok, well i might switch back to that then.. im still interrested in learning this functor, applicative, monad interplay
15:00:11 <Squarism> well all but the monad stuff i have to admit
15:00:24 <Squarism> but hey.. who can resist a challange
15:00:27 <ertesx> if not, don't worry…  i don't understand it either =)
15:00:44 <hackrilege> my conclusion was that by containing a function returning itself, the datatype hangman is essentially a partially applied kliesli arrow and so it kind of behaves like a monad would...
15:01:09 <EvanR> class KindOfLikeAMonad a where
15:01:16 <mniip> huh
15:01:19 <mniip> this hangman thing
15:01:32 <mniip> looks suspiciously close to Free ((->) t)
15:01:46 <ertesx> it's basically Reader Char from what i see
15:01:47 <hackrilege> that datastructure alone facilitates a game, a string of computations, we would normally use monads for this
15:02:06 <mniip> ertesx, Free (Reader Char) rather
15:02:07 <hackrilege> but then i dont know about Reader or State
15:02:15 <hackrilege> and it sounds like that might be what they do too
15:02:15 <ertesx> mniip: yeah, something like that
15:02:25 <ertesx> Free to make it interpretable…
15:02:27 <EvanR> i reject that its something you would normally use monads for
15:02:41 <mniip> well I happen to know a bit about FreeT readers...
15:02:42 <EvanR> just using the number of games in haskell as evidence
15:02:47 <ertesx> EvanR: i do use Free ((->) A), but not like that
15:02:58 <hackrilege> but 'do'!!
15:03:08 <Squarism> ertesx, hackrilege - but doesnt the monad approach let us pass any gamestate (board and possibly other) to next Hangman instance wo having to pass it explicitly every time?
15:03:16 <ertesx> or more likely (MonadFree ((->) A) m)
15:03:25 <EvanR> is a "game" really about "do" (ignoring for the moment what do monads have to do with "do")
15:03:31 <hackrilege> :t fold return (>=>)
15:03:32 <lambdabot>     Could not deduce (Monad m0) arising from a use of ‘>=>’
15:03:32 <lambdabot>     from the context (Foldable ((->) a), Monoid a)
15:03:32 <lambdabot>       bound by the inferred type of
15:03:38 <hackrilege> sorry :(
15:03:41 <ertesx> Squarism: the state is still (supposed to be) implicit in the game implementation
15:03:58 <hackrilege> :t foldl return (>=>)
15:03:59 <lambdabot> (Monad m, Foldable t) => t a -> (a1 -> m b) -> (b -> m c) -> a1 -> m c
15:04:11 <hackrilege> !?
15:04:15 <hackrilege> ok nvm
15:04:20 <ertesx> Squarism: you can use State *within* the game implementation to do some explicitly stateful programming, but from the outside it will still look pure
15:04:55 <ertesx> Squarism: anyway, hackrilege's post is closer to what i thought you would come up with (i haven't tested it, but i'll just assume it works)
15:05:18 <ertesx> Squarism: my next step would be to introduce to you a much more elegant way to build hangman games
15:06:17 <hackrilege> Squarism, i cant see how Char -> Hangman is less convenient... im a bit lost because of lack of exposure to Reader, but im starting to think its a reasnable alternative to Monad
15:08:05 <Squarism> heres the working hackrilege solution (with my amatuer touch added) : http://lpaste.net/160793
15:08:29 <hackrilege> EvanR, did you see compas? the idea was basically storing constructors
15:08:37 <ertesx> what's InGameWar, and why is there a Board type now?
15:08:49 <ertesx> and what the hell is World?
15:09:12 <Squarism> ertesx, oh.. thats preps for a the game to come
15:09:28 <ertesx> ah, ok =)
15:09:48 <hackrilege> Squarism, you could add a Show instance, rather than defining boardToWord
15:09:51 <Squarism> InGameWar was my idea of the game shifting phase... as many games do
15:10:35 <Squarism> It gives the game a specific interface that require other commands. 
15:10:58 <Squarism> hackrilege, oh ok
15:11:46 <hackrilege> enter2!?
15:12:04 <ertesx> Squarism: ok, but if you're still interested, for the sake of simplicity i suggest returning to the original Hangman…  you can make a separate source file, if you want…  most of the stuff you wrote won't be needed any longer with the more "elegant" solution =)
15:12:37 <ertesx> (you will need hangmanStdio)
15:12:58 <hackrilege> i cant see what this is doing!
15:13:18 <Squarism> hackrilege, a function to support "other commands" for the other phase the game can be in - presented with the InGameWar "interface" instead  
15:14:07 <ertesx> i think 'enter2' was meant to be an extension of the basic game, because this is practicing for a game with changing command sets or mechanics
15:14:17 <Squarism> ertesx, im am interrested in what you mean by state beeing implicit 
15:14:35 <Squarism> ertesx, ok.. ill revert to that in git
15:15:01 <ertesx> Squarism: let me implement the ad-hoc solution myself and show you how i would have implemented it…  then i'll show you where the state is
15:15:18 <hackrilege> awesome more hangman!
15:15:30 <Squarism> ertesx, id be thrilled to see that!
15:15:36 <hackrilege> thrilled!
15:15:47 <Squarism> hackrilege, word!
15:17:19 <Squarism> hackrilege, i expect to learn one method-fits-all boardgame construction. That does thrill me. 
15:19:08 <orion> Is "role" a special keyword in Haskell?\
15:19:28 <orion> when I hlint a while which uses a variable named "role", I get a parse error, yet the code compiles successfully.
15:20:27 <Squarism> hackrilege, Many boardgame sites have huge problems implementing "undo" function. Says its too hard. It would be a nobrainer with a immutable variant
15:21:05 <EvanR> .oO( chu spaces! )
15:21:22 <Can_Not> are you looking to make board games more sophisticated than hangman?
15:21:43 <Squarism> No, thats sort of the upper level of complexity
15:22:36 <Squarism> just kidding. Well sure. Id like to do digital versions of some of the more popular boardgames
15:25:33 <ertesx> Squarism: http://lpaste.net/160796
15:25:45 <hackrilege> my zipper thing i was going to test using reversi
15:26:12 <Squarism> ertesx, thanx alot - will be checking right away
15:26:40 <hackrilege> poker is always fun
15:26:43 <ertesx> lpaste's auto-hlint is really annoying
15:27:00 <hackrilege> except when moneys involved of coarse...
15:27:19 <EvanR> you mean only when?
15:27:32 <Can_Not> nobody IRL wants to play poker for fun, they always insist using real money
15:27:44 <hackrilege> off topic
15:27:47 <hackrilege> sorry my bad
15:28:34 * hackagebot hw-prim 0.0.0.7 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.0.7 (haskellworks)
15:28:37 <hackrilege> but its a good example of a complex interactive dynamical system to evolve
15:28:55 <itd> Hello. I am trying to "cabal install thrift" but it fails. Some relevant output, hopefully: http://lpaste.net/160777 Where is my mistake?
15:29:29 <ertesx> Squarism: if something doesn't make sense immediately, let me know (i'm a bit suspicious of the beginner-friendliness of line 36, but you love challenges anyway) =)
15:30:28 <Squarism> ertesx, i know fold from Scala. But im trying to brain parse the meaning of it 
15:31:26 <ertesx> foldr (\x _ -> yes x) no  -- really just corresponds to 'maybe no yes'
15:31:39 <ertesx> a way to handle either emptiness or the first element of a list
15:31:53 <EvanR> > fold [Sum 1, Sum 2, Sum 3]
15:31:54 <lambdabot>  Sum {getSum = 6}
15:32:24 <EvanR> > fold [[1],[2],[3]]
15:32:26 <lambdabot>  [1,2,3]
15:32:35 <ertesx> :t foldr (\x _ -> print x) (putStrLn "No elements there!")
15:32:37 <lambdabot> (Show a, Foldable t) => t a -> IO ()
15:32:53 <Squarism> yeah i know fold
15:33:44 <Squarism> list.fold(startValue)( (x,total) -> {...newTotal.. }) in scala
15:34:03 <ertesx> that's more likely a strict left fold
15:34:08 <ertesx> foldr is a non-strict right-fold
15:34:11 <EvanR> i just read through the lens derivation on github... still not sure where Monoid comes from in context of Foldable
15:34:57 <ertesx> EvanR: where does Applicative come from in the context of Traversable?
15:35:08 <EvanR> i have a feeling theres an answer to that one
15:35:34 <hackrilege> foldl f bc l = if null l then bc else f (head l) (fold f bc (tail l))
15:35:50 <ertesx> it's basically the same answer…  Monoid is to Foldable what Applicative is to Traversable:  a sort of "most generic collector" or "lowest common denominator"
15:36:01 <Squarism> ertesx, so >>= is passing the string to foldr (monad style)?
15:36:34 <ertesx> Squarism: yeah, it's the same as:  "ln <- getLine; foldr _ _ ln"
15:36:45 <Squarism> got it
15:37:04 <Squarism> and pure() ?
15:37:12 <ertesx> same as return ()
15:37:19 <Squarism> ok
15:37:25 <ertesx> if the line is empty, abort the game
15:37:31 <ertesx> otherwise feed the first character to 'f'
15:37:37 <ertesx> and recur
15:37:49 <Squarism> ok... got it
15:38:15 <Squarism> so you can enter many guesses at once?
15:38:21 <ertesx> nope
15:38:36 <ertesx> but that's actually easy enough to implement
15:39:01 <Squarism> if getLine returns many characters?
15:39:18 <Squarism> wont hangmanStudio (f c) be called many times?
15:39:45 <ertesx> nope
15:41:00 <ertesx> foldr (\c _ -> hangmanStdio (f c)) (pure ()) "abc"
15:41:00 <ertesx>   = (\c _ -> hangmanStdio (f c)) 'a' (foldr (\c _ -> hangmanStdio (f c)) (pure ()) "bc")
15:41:01 <ertesx>   = hangmanStdio (f 'a')
15:44:22 <ertesx> Squarism: the whole point of that line is to reduce a three-line pattern-match into a single-line fold…  i didn't even realise i wrote it that way, until i had pasted it
15:45:17 <ertesx> my spinal cord seems to write most of my code =)
15:45:24 <Squarism> so recursion stops on "a"?
15:45:30 <ertesx> yeah
15:45:46 <ertesx> > foldr (\x _ -> Just x) Nothing "Hello"
15:45:48 <lambdabot>  Just 'H'
15:45:52 <ertesx> > foldr (\x _ -> Just x) Nothing ""
15:45:53 <lambdabot>  Nothing
15:46:22 <Squarism> Neat
15:46:34 <ertesx> > foldr (\x _ -> Just x) Nothing [1..]  -- since the fold function ignores its second argument, no recursion ever happens
15:46:36 <lambdabot>  Just 1
15:47:18 <Squarism> foldUntilJust ?
15:47:25 <ertesx> foldr f z (x : xs) = f x (foldr f z xs)  -- note the second argument of 'f'
15:48:02 <ertesx> the one above is just safeHead
15:48:12 <ertesx> it does not look beyond the first element
15:48:31 <ertesx> > foldr (\x _ -> Just x) Nothing ('x' : undefined)
15:48:32 <lambdabot>  Just 'x'
15:49:36 <ertesx> foldr (\x _ -> yes x) no xs = case xs of [] -> no; x : _ -> yes x
15:49:57 <Squarism> ok.. so z = pure in that example and will return?
15:50:11 <ertesx> yeah
15:50:35 <Squarism> thats abstract for Java programmer by day
15:50:44 <ertesx> 'pure ()' is the action that does nothing…  if the player enters an empty line, the remainder of the game is 'pure ()'
15:51:28 <EvanR> literally game semantics of IO
15:51:32 <hackrilege> http://lpaste.net/160797 poker?
15:51:44 <Squarism> ertesx, ok.. so i see you dont explicitly pass on mword
15:51:49 <Squarism> how does that work
15:51:52 <acowley> Is hslogger still a good choice for an off-the-shelf logging library?
15:52:00 <shelf> look
15:52:17 <ertesx> Squarism: mword is just presentation…  it's only used to draw the board (the message with the underscores)
15:52:18 <Squarism> in that same foldr expression
15:52:40 <ertesx> see line 33
15:53:19 <ertesx> it's the game's presentation…  it gets displayed, then the player makes a move…  then the whole thing starts over
15:54:41 <ertesx> remember that hangmanStdio is only an interpreter…  it is not in charge of any of the game logic…  all it does is connect the real-world player to the purely logical game
15:57:20 <Squarism> ertesx, parsing code... 
15:59:31 <ertesx> Squarism: take your time…  i know, this kind of separation could look very alien to an experienced imperative programmer…  but that's a taste of true functional style – and we're not even done yet =)
16:01:04 <ggVGc> whe are we done?
16:01:09 <ggVGc> I don't want to be done
16:06:53 <ertesx> don't worry…  you'd be surprised how much Hangman can be (over-?) engineered =)
16:07:39 <EvanR> hmm forth hangman
16:08:05 <ertesx> data GuessGame f a b x = Go (f (Maybe b)) (a -> x) | Stop (f b)
16:08:25 <ertesx> hangman :: String -> Fix (GuessGame [] Char Char)
16:08:36 <ertesx> =)
16:08:37 * hackagebot werewolf 1.0.1.0 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.0.1.0 (hjwylde)
16:09:08 <EvanR> hangman :: IO ()
16:09:26 <ertesx> that's so…  java…
16:11:35 <Squarism> haha.. ok.. i think i get it. I had some trouble getting : f :: Char -> Hangman ... f is defined in a context that upon invokation creates a redefine (context wise) f. A function that acts as a "class" almost.
16:11:56 <Squarism> f :: Char -> [Char] -> [Char]-> Hangman ... really
16:12:03 <Squarism> ?
16:12:11 <ertesx> it's simply a function that takes you to the next "game frame"
16:12:23 <ertesx> given a move, it gives you a new game that represents the current game *after* the move
16:12:34 <Squarism> i get that
16:12:49 <ertesx> therefore the first one is the correct one
16:12:56 <ertesx> f :: Char -> Hangman
16:13:02 <Squarism> yeah.. i get that
16:13:09 <EvanR> PublicT StaticT IO Void
16:13:57 <Squarism> but i had trouble seeing how the board was passed on. Its a member of the context in which f is defined
16:14:09 <ertesx> yeah
16:14:16 <ertesx> and that's where the state is
16:14:35 <Squarism> Crystal clear!
16:14:46 <ertesx> Squarism: can you point to the precise identifier in the code that represents the state?
16:14:48 <Squarism> even if very far from classes and mehtods
16:15:13 <EvanR> by misreading your explanation of hangman just now i just thought of a functor for hangman moves, wouldnt this somehow generate hangman too
16:15:21 <EvanR> evolution of hangman programmer
16:16:13 <ertesx> EvanR: i think you can go without a functor without loss of generality
16:17:07 <Squarism> ertesx, mword of hangmanStdio?  
16:17:15 <ertesx> but the more general version i wrote above as a joke is actually very general…  it even allows you to switch games dynamically, and it can represent anything from a simple number-guessing game to a maze game
16:17:19 <ertesx> Squarism: nope
16:17:35 <Zekka|Sigfig> (The question of whether such generality is useful is left to the reader!)
16:17:41 <ertesx> Squarism: again, hangmanStdio does not know anything about state…  it doesn't even understand the nature of the game
16:18:46 <Squarism> ertesx, i thought you meant the "current" state of the board? 
16:18:46 <ertesx> Squarism: if you think about state and look at hangmanStdio, you're trying to find the heart of the game in its feet =)
16:19:09 <ertesx> Squarism: mword is just presentation, and it isn't controlled by hangmanStdio
16:19:23 <ertesx> it has nothing to do with the game state whatsoever
16:21:23 <Squarism> well the modelling of the state is in InGame HERE ...
16:21:34 <Squarism> but that just the structure
16:21:36 <ntnt> has anyone tried splitting their module in 'layers' ?
16:21:47 <ntnt> I'm thikning if having folders called Z000, Z001, Z002, Z003, ...
16:21:53 <Squarism> (adHocHangman "hello") is just the intial state
16:21:54 <ntnt> where Zi can only depend on Zj for j < i
16:22:04 <ertesx> Squarism: the game logic (including the state) is entirely in lines 11-27
16:22:15 <ertesx> Squarism: *entirely*, no exceptions, no leaking
16:22:55 <Squarism> ertesx, isnt that just definitions on how to create state? 
16:23:51 <EvanR> the question is what makes hangman different from other games, its not that it has state or a way to iterate states or takes turns taking input
16:24:03 <ertesx> Squarism: in line 40 you tell adHocHangman what word to guess…  then adHocHangman does the rest, including calculating the initial state
16:25:02 <Squarism> ertesx, when you say state to a java programmer i interpret it as "where is current data" =D
16:25:05 <EvanR> its the rules of the game, what your choices mean and what constitutes the games winning or losing condition
16:25:45 <ertesx> Squarism: state is stuff that changes…  one way to get that is recursion =)
16:25:50 <EvanR> i think the most accurate way to talk about state is that when you repeat the "same process" you get different results each time
16:26:09 <ertesx> > let go n = n : go (n + 1) in go 5  -- this is stateful programming
16:26:10 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
16:26:12 <Squarism> and the only handle to that has hangmanStdio ?
16:26:20 <EvanR> so when you press the button over and over, you get different answers or effects
16:26:28 <EvanR> or in the case of hangman, take a turn
16:26:49 <EvanR> that doesnt necessarily mean theres mutable variables or objects
16:27:04 <ertesx> Squarism: let me just tell you where the state is…  maybe it's easier to look at the code and see *why* it is the state
16:27:09 <ertesx> ok?
16:27:26 <Squarism> ertesx, ok
16:27:29 <ertesx> i think you need an example here rather than explanations
16:27:41 <ertesx> the state is in line 16: foundChars
16:28:01 <ertesx> it's a set of characters that grows as the player makes guesses
16:28:26 <EvanR> otoh go (n+1) doesnt satisfy my criteria for state because go is a pure function and would give you the same answer if provided with the same input, its stateless
16:28:50 <ertesx> EvanR: i interpret lists themselves as stateful programming
16:28:53 <Squarism> ertesx, i get that 
16:29:13 <EvanR> which... i think is stretching terminology
16:29:59 <ertesx> EvanR: maybe, but it's useful to do it…  after all lists are a control structure
16:30:17 <EvanR> before lists are state, or lists are loops, or lists are control structures... lists are literally just lists stuck in space and time
16:30:18 <ertesx> Squarism: does the code make sense?  do you see how and *why* it works?
16:30:24 <EvanR> a sequence of values
16:30:36 <EvanR> they have no state
16:30:48 <EvanR> every time you look at them they are the same
16:30:50 <Squarism> ertesx, i do. 
16:30:52 <ertesx> EvanR: sure…  it's the "interpreter" of the list that observes "state"
16:31:05 <EvanR> you mean the generator?
16:31:13 <ertesx> no, the consumer
16:31:20 <EvanR> the observer and the generator are also stateless
16:31:38 <ertesx> EvanR: i don't think this discussion is useful
16:32:12 <EvanR> "state" is already confused enough, so at least this discussion is useful for confusing it more ;)
16:32:13 <Zekka|Sigfig> I call my eyes perception
16:32:23 <Zekka|Sigfig> and my hands are manipulation!
16:32:26 <EvanR> "state is lists" <- not good haskell
16:32:31 <Zekka|Sigfig> That’s much less confusing than calling them body parts
16:32:37 <ertesx> it's my way of thinking…  lists and especially infinite streams can represent changing things rather than sequences of things
16:32:39 <EvanR> "control structure is state" <- not good haskell
16:32:57 <ertesx> sometimes they are really just "sequences of things" (e.g. the usual String)
16:33:19 <hpc> haskell is the living embodiment of the separation of church and state
16:33:25 <ertesx> other times it's useful to look at them as stateful things
16:33:27 * hpc ducks
16:33:30 <Squarism> ertesx, if i ask you.. where is the reference to last version Hangman? Wouldnt you answer hangmanStdio ?  
16:33:30 <EvanR> infinite streams arent changing things in of themselves, an animation that shows that frames of a list isnt really stateful either
16:33:35 <MarcelineVQ> hpc: :>
16:33:43 <Squarism> version of
16:33:57 <ertesx> Squarism: not sure i understand the question
16:35:31 <ertesx> EvanR: sometimes i like to visualise 4D objects as 3D objects that change over time…  other times it's stupid to do that =)
16:35:33 <EvanR> the program itself doesnt have a reference to the last version, only the entire history
16:35:36 <ertesx> it's a different way of thinking
16:35:43 <EvanR> starting from the beginning
16:35:48 <Squarism> ertesx, Where is the latest reference to memory describing "The Game"? To me it looks as if hangmanStdio has that
16:36:03 <ertesx> i totally see state in lists…  it shapes my thoughts and interpretations and helps me write code
16:36:14 <EvanR> changing over time isnt the same thing as state, is all im saying
16:36:35 <EvanR> changing over space or any other variable isnt state
16:36:57 <Zekka|Sigfig> be sure to use the least confusing language possible!
16:37:06 <Zekka|Sigfig> things that make you feel like you’ve discovered something clever are often confusing.
16:37:31 <Zekka|Sigfig> This is a haskell channel though so confusing probably isn’t a huge turnoff =)
16:37:39 <EvanR> i didnt discover this, its stateful and statelessness from signal process
16:37:41 <ertesx> whatever =)
16:37:56 <ertesx> Squarism: i still don't quite get it
16:38:16 <EvanR> otoh a calculus problem with a variety of views isnt stateful, its always the same each time youre given the test
16:38:23 <maerwald> Zekka|Sigfig: I call my eyes liars, my hands lazy and my mouth manipulation :P
16:38:25 <ertesx> Squarism: sounds to me like you're still thinking in terms of memory cells and mutable variables
16:38:54 <ertesx> Squarism: try to think of it as reducing terms by applying definitions instead
16:39:29 <ertesx> hangmanStdio g  -- this is the action that lets you play the game g
16:39:55 <Squarism> ertesx, get that
16:41:10 <ertesx> ln <- getLine; case ln of [] -> pure ()  {- do nothing, i.e. the game ends here -};  c : _ -> hangmanStdio (f c)  -- pass the guess 'c' to the game logic, which responds with a new, updated game…  then the next action is to play that game
16:41:43 <ertesx> if you understand that, there isn't really anything more to understand about hangmanStdio
16:41:52 <ertesx> in a sense it's the most boring function in the whole code =)
16:58:26 <MichaelBurge> Is there a way to set stack to use the GHC 8 release candidate? I think I'm running into this bug, and want to pick up the fix: https://ghc.haskell.org/trac/ghc/ticket/5642
16:58:38 * hackagebot quiver-interleave 0.2.0.1 - Interleave values from multiple Quivers  https://hackage.haskell.org/package/quiver-interleave-0.2.0.1 (IvanMiljenovic)
16:59:46 <mgsloan> MichaelBurge: I'm actually working on it right now, since tolysz pinged this issue https://github.com/commercialhaskell/stack/issues/1579
17:00:15 <mgsloan> It is way trickier than it needs to be because cabal is demanding dependencies for components that aren't even being built >.<
17:00:25 <mgsloan> Cabal the library has quite a few assumptions we gotta work around
17:01:03 <mgsloan> It already seems to work well for packages that lack test-suites / benchmarks
17:01:18 <mgsloan> Though I haven't actually tried with GHC 8
17:01:29 <mgsloan> Note that you can totally use GHC 8, but there is no stackage snapshot for doing that
17:01:47 <mgsloan> allow-newer can allow using ghc 8 with a snapshot intended for 7.10.3
17:02:03 <MichaelBurge> Thanks for your work on this mgsloan. Anything that improves stack is really helpful.
17:02:15 <MichaelBurge> And I'll try using allow-newer
17:02:46 <mgsloan> Well, it won't work right quite yet, that's what I'm fixing :)
17:03:25 <Squarism> ertesx, i guess we have different view of state. Maybe different language is used in haskellworld. Where is state defined.. sure line 16. I can interpet them as member variable of a class. Created on line 22-23. But if we were to give a memory reference to that location id start by looking at "f" in hangmanStdio - in hopes it has reference to its context. Well lets leave it at that. 
17:04:13 <Squarism> ertesx, anyways. Im more than grateful for your guidance. 3 days ago i didnt know any haskell at all
17:08:39 * hackagebot quiver-sort 0.2.0.0 - Sort the values in a quiver  https://hackage.haskell.org/package/quiver-sort-0.2.0.0 (IvanMiljenovic)
17:09:40 <ertesx> Squarism: for now you may benefit from EvanR's view of state, an extreme variant of it even: there is little state in this game
17:09:59 <ertesx> but if anything should be seen as state, it's foundChars
17:10:11 <sm> go mgsloan!
17:10:42 <ertesx> Squarism: anyway, the next step is to dispense with adHocHangman =)
17:11:38 <ertesx> Squarism: the basic idea is this: imagine you'd knew how to construct a single-character game (and you do know how to do it at this point)
17:11:47 <ertesx> singleton :: Char -> Hangman
17:13:04 <ertesx> Squarism: now picture such a game: you have a game-master and a board with a single character…  imagine you have two of those, and you simply push them together
17:13:17 <ertesx> in other words: you'd know how to "concatenate" two games
17:13:50 <ertesx> then you could construct every game by concatenating singleton games
17:17:29 <mildfate> Hey all, I'm brand new to Haskell and trying to rewrite a web scraper I've written in Java into Haskell as a learning exercise. What libraries should I use for making http requests, parsing HTML, and parsing json?
17:19:40 <pavonia> aeson for json, tagsoup if your HTML may be broken
17:19:53 <EvanR> theres also HXT
17:20:19 <EvanR> i wonder if theres some "xpath-like thing" to search json
17:20:37 <nineonine> mildfate: consider wreq or http-client  for http
17:23:14 <Squarism> ertesx, that was the redifinition of Hangman into InGamePlayerA + InGamePlayerB you talked about earlier?
17:24:20 <ertesx> Squarism: nope, it's simply a different way to construct this same game
17:24:29 <ertesx> singleton :: Char -> Hangman  -- construct a singleton game
17:24:44 <ertesx> catHangman :: Hangman -> Hangman -> Hangman  -- concatenate two games
17:25:30 <ertesx> helloGame = singleton 'h' `catHangman` singleton 'e' `catHangman` singleton 'l' `catHangman` singleton 'l' `catHangman` singleton 'o'
17:27:29 <Squarism> ah ok
17:27:39 <ertesx> Squarism: before i go to bed, i'll give you one clause of catHangman just to get you started, and then i'll leave you with the exercise to implement it =)
17:28:11 <Squarism> well impressive.. that you can do that
17:28:57 <ertesx> catHangman (Won word1) (Won word2) = Won (word1 ++ word2)  -- if you concatenate two won games, the composite game is also a won game with just the two words concatenated
17:29:10 <ertesx> does that make sense?
17:30:21 <ertesx> Squarism: if you're interested in going on
17:30:23 <Squarism> i gotto say i need to focus on the endresult.. my haskell detour is mostly about creating https://www.youtube.com/watch?v=ccZmHRyCfxQ this
17:30:38 <Squarism> haskell guru skills must come later
17:30:50 <Zekka|Sigfig> can you meaningfully concatenate two hangman games?
17:31:05 <ertesx> in that case i'll just implement the game i would have written it
17:31:18 <EvanR> guru meditation: press left mouse button to continue
17:31:18 <ertesx> Zekka|Sigfig: yeah, Hangman is actually a full-blown monoid
17:31:24 <Zekka|Sigfig> You can probably come up with a definition of hangman that includes concatenation, but I don’t see how that’s part of the problem
17:31:27 <Squarism> ertesx, if i get time ill try to do your exercise
17:31:28 <EvanR> ertesx: semigroup!
17:31:33 <Zekka|Sigfig> ertesx: Well, it’s a party game
17:31:38 <ertesx> EvanR: monoid
17:31:48 <EvanR> how do you create an empty game
17:31:56 <ertesx> EvanR: Won []
17:31:59 <Zekka|Sigfig> maybe you can model it as a semigroup or a monoid but I’m not sure what that has to do with playing or implementing hangman
17:32:05 <EvanR> ah you didnt say you could do that
17:32:20 <EvanR> with just singleton and cat tho
17:32:38 <Zekka|Sigfig> I don’t think if you ask most people to tell you the rules of hangman, they’ll tell you about how to concatenatge games
17:32:51 <EvanR> its interesting nonetheless
17:33:07 <Zekka|Sigfig> I’d imagine most of them describe it as a process where one player suggests letters until the man is dead or the word is guessed, which doesn’t have anything to do with concatenation
17:33:28 <EvanR> its a useful DSL for creating new games from old!
17:33:41 <EvanR> if you had that for AAA games youd be rich
17:34:02 <maerwald> EvanR: lawl
17:34:22 <maerwald> skyrim </> borderlands
17:34:29 <EvanR> exactly
17:35:05 <Squarism> skyrim + nhl 16
17:35:37 <EvanR> toejam and earl <> battletoads
17:35:47 <EvanR> super mario <> duck hunt
17:36:21 <Zekka|Sigfig> FWIW I have a feeling the most straightforward way to write hangman is going to be an imperative program that asks for input every so often
17:36:43 <Rotaerk> Zelda > *
17:36:47 <EvanR> :t interact
17:36:49 <lambdabot> (String -> String) -> IO ()
17:36:57 <EvanR> hmm.
17:37:13 <EvanR> Zekka|Sigfig: this is haskell, everyone forgot how to do that
17:37:15 <Zekka|Sigfig> there’s two different kinds of input you take — one is getting the initial word, and one’s getting letter guesses
17:37:44 <ertesx> http://lpaste.net/160805
17:37:50 <ertesx> hangman monoid
17:38:28 <ertesx> what used to be 'adHocHangman' is now 'fromString' and is defined in terms of foldMap
17:38:28 <Zekka|Sigfig> OK, my first thought reading this is “why did you need to define a type and instantiate two typeclasses to do this?”
17:38:58 * hackagebot hw-succinct 0.0.0.7 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.7 (haskellworks)
17:39:13 <ertesx> because i'm using a design pattern that makes me implement this as a monoid
17:39:17 <Zekka|Sigfig> my next thought is “what is foldr (const . hangmanStdio . f) (pure ())”?
17:39:24 <ertesx> the IsString type class is just convenience
17:39:31 <Zekka|Sigfig> ertesx: Why are you doing that?
17:39:38 <Zekka|Sigfig> this is hangman, it can be implemented in like ten lines
17:40:14 <EvanR> Zekka|Sigfig: reimplementing a question loop for every hangman game will work, but this would be like the zeroth exercise of SICP, to abstract that part away from the games characteristic behavior
17:40:17 <Zekka|Sigfig> I’m not even sure where you’re concatenating games in this program, maybe if I look around longer I’ll find it
17:40:22 <EvanR> for every hangman-like game
17:40:33 <ertesx> Zekka|Sigfig: firstly separation of concerns, i.e. demonstrating an example of a functional DSL
17:40:43 <Zekka|Sigfig> ertesx: Oh, so it’s about obfuscation?
17:40:49 <EvanR> lol
17:41:15 <nshepperd> funny that you say that. the monadic version I wrote basically is an imperative program that asks for input every so often. except pure
17:41:21 <ertesx> Zekka|Sigfig: i see no reason not to do it here
17:41:24 <nshepperd> it even has a function called 'ask'!
17:41:25 <EvanR> HTML has no support for abstraction, so i would call what HTML currently is instead... obfuscation
17:41:36 <Zekka|Sigfig> ertesx: “I see no reason not to [X]” /= “I have a reason to do [X]"
17:42:01 <ertesx> Zekka|Sigfig: it fits my thought patterns and keeps my code maintainable as it grows
17:42:04 <Zekka|Sigfig> nshepperd: there’s a pretty good chance what you did won’t upset me — you can write a straightforward hangman in haskell afaict by not trying to abstract
17:42:30 <ertesx> Zekka|Sigfig: it would be unnatural for me to write it imperatively in those ten lines
17:42:40 <nshepperd> anyway, I thought this was an exercise in writing games abstractly
17:42:40 <Zekka|Sigfig> ertesx: Your code appears to be making a couple statements I don’t know the meaning of
17:42:50 <nshepperd> actually having a working hangman binary isn't the point :p
17:43:02 <Zekka|Sigfig> “the default hangman game is I won and the word is empty?”
17:43:19 <ertesx> Zekka|Sigfig: then you should learn haskell…  i don't complain about your code before i understand the language it's written in
17:43:27 <Zekka|Sigfig> ertesx: I used Haskell for nearly everything for three years
17:43:54 <tippenein> Anyone have experience sneaking haskell binaries into libraries in other languages? We have some parsers written in Ruby and I'd like to replace them with system calls to a binary..
17:44:09 <ertesx> Zekka|Sigfig: do you have…  you know…  a point?
17:44:15 <ertesx> if not, stop wasting my time
17:44:21 <Zekka|Sigfig> ertesx: Yeah, I think your implementation is really abstract in ways that make it hard to understand how it solves the problem
17:44:46 <Zekka|Sigfig> This is imho a very difficult way to solve hangman
17:45:02 <Zekka|Sigfig> It might be useful for something else, but I don’t think the ways you abstracted it create a clear path to actually solving other problems
17:45:06 <nshepperd> ertesx: whoa, I just read your implementation, that's a bit amazing
17:45:08 <ertesx> Zekka|Sigfig: all that proves is that we have different thought patterns and different ways to solve problems
17:45:09 <EvanR> tbqh implementing hangman in the C style in haskell would be a good exercise
17:45:30 <EvanR> i cant think of how to do it nicely off the top of my head
17:45:33 <Zekka|Sigfig> ertesx: Well, this gets to why I got out of Haskell — I solved a lot of problems this way and none of my friends could understand why I did it like that
17:45:47 <Zekka|Sigfig> I tried explaining it to them and the conclusion I came to was I didn’t really have a good reason to code that way
17:46:14 <EvanR> because haskell uses recursion instead of loops...
17:46:20 <EvanR> not much you can do about it
17:46:38 <joof> this is a weird arguemnt I jumped into. Link to code?
17:46:49 <Rotaerk> code written in a procedural language with loops shouldn't really use explicit loops much
17:46:51 <ertesx> Zekka|Sigfig: nothing wrong with that…  i didn't run into that problem, so i'm happy to solve problems algebraically
17:47:00 <EvanR> eh?
17:47:01 <Rotaerk> as long as the language has higher order functions
17:47:10 <EvanR> even then... eh?
17:47:11 <Zekka|Sigfig> joof: ertesx wrote this implementation of the game hangman: http://lpaste.net/160805
17:47:29 <Rotaerk> just like you shouldn't really be using recursion directly a lot of the time, but instead use fold, map, etc
17:47:34 <EvanR> Rotaerk: in lua this is basically unavoidable, and in JS youre back to the "by my coworkers ridicule me" argument
17:47:43 <Zekka|Sigfig> ertesx: It seems to me like the correct reaction to code that is this complex is extreme suspicion
17:47:47 <EvanR> and in haskell you cant really avoid recursion in all cases
17:47:51 <EvanR> directly
17:47:59 <Zekka|Sigfig> this does not look like it was written by someone whose goal was to simplify things
17:48:09 <ertesx> Zekka|Sigfig: the disagreement is that i do *not* think that this code is complex
17:48:18 <Rotaerk> it's not entirely avoidable, just saying that loops are a bit too generic, and you should use a more specific abstraction if one exists
17:48:33 <monochrom> there is something hand-in-hand with the pair (while loop, no algebraic data type pattern matching) and hand-in-hand with the pair (recursion, algebraic data type and pattern matching)
17:48:39 <Hijiri> ertesx: are you just using that fold to handle the empty case?
17:48:44 <EvanR> yeah but many procedural languages either dont have the power or the culture is to not use it
17:48:47 <Zekka|Sigfig> ertesx: What do you think complex code looks like?
17:49:01 <ertesx> Zekka|Sigfig: it has all the properties of good, readable, maintainable code:  it's local, it uses separation of concerns
17:49:01 <Hijiri> it seems like foldr (const . f) (x:xs) will always be f x
17:49:09 <nshepperd> Zekka|Sigfig: no, that makes sense, the "empty" game of hangman where the secret word is the empty string is always immediately won, because there's only one possible solution
17:49:10 <ntnt> in ghci, instead of :r to reload everhing, is there a way to just reload _one particular module_ ? I moved a bunch of code round, everything is broken, and I'm intendint to fix things one module at a time
17:49:13 <Rotaerk> I usually override/ignore the culture and just program how I want, in a language
17:49:22 <ertesx> Zekka|Sigfig: the average for-loop with more than 10 statements…  i have serious trouble parsing such code
17:49:35 <Rotaerk> if my way and the community's way are equivalent in value, and it's an arbitrary decision, I go with the community's option
17:49:42 <Rotaerk> but if I think my way's better, I don't hesitate to use it
17:49:46 <EvanR> the singleton concat construction of games is nice
17:49:55 <Hijiri> I think that foldr is obfuscatory for no good reason
17:49:57 <ertesx> Hijiri: the fold basically does this:  mconcat . map singleton
17:49:58 <EvanR> whether it will work for more complex games dunno
17:50:03 <maerwald> Hijiri: in some cases
17:50:11 <ertesx> Hijiri: turn a list of characters into a list of singleton games, then concatenate them
17:50:11 <nshepperd> Zekka|Sigfig: mempty doesn't always mean default
17:50:20 <Hijiri> ertesx: in hangmanStdio?
17:50:28 <Hijiri> I didn't say foldMap
17:50:30 <Hijiri> I said foldr
17:50:37 <ertesx> Hijiri: it's used in 'main', but the use is implicit (-XOverloadedStrings)
17:50:42 <ertesx> oh
17:50:45 <ertesx> sorry, yeah
17:51:01 <EvanR> foldr maybe an explicit loop combinator with a better name would be better
17:51:12 <EvanR> iterateGame
17:51:35 <Hijiri> the foldr there isn't used for iteration, it's used for doing something different based on whether the input is empty
17:51:35 <Zekka|Sigfig> ertesx: I don’t think I’m going to be able to convince you this is complex, but I’ll point to some features that suggest it
17:51:40 <joof> games have always been a pretty weird thing to express in haskell
17:51:55 <Zekka|Sigfig> your program contains a whole lot of conditionals in the form of pattern matching
17:51:59 <ertesx> Hijiri: that one basically does pattern-matching to handle empty and head
17:52:06 <ertesx> it does not recur
17:52:20 <Zekka|Sigfig> your code represents victory two different ways, one with control flow (you branch on Won) and one with a data type (Won)
17:52:34 <Hijiri> I think it makes the program harder to understand, because typically you don't use a fold to do list cases
17:52:44 <Zekka|Sigfig> your code introduces a notion that’s not probably part of most people’s models of hangman before they play with it, which is that a game is a collection that can be concatenated
17:52:55 <Hijiri> though maybe if I had seen the foldr (const . f) stuff before, I would have understood it immediately
17:53:07 <Hijiri> but it doesn't really make sense at first glance
17:54:08 <Zekka|Sigfig> There’s some other metrics you could use like tokens-per-line that I have a little bit less faith in
17:54:12 <nshepperd> it's definitely more reasonable to just use a case statement if you want to check whether a list is empty
17:54:44 <EvanR> Zekka|Sigfig: this isnt the first instance of the implementation that was presented
17:54:57 <EvanR> you cant complain about alternatives that do things differently or weirdly
17:55:16 <nshepperd> I think introducing a new notion here is the best thing about the code
17:55:34 <ertesx> Zekka|Sigfig: i see your point…  my justification is that i have a clear separation between interface (Monoid) and implementation, and all the complexity is highly local
17:55:35 <nshepperd> I learned something new about the game that I hadn't thought of before
17:55:42 <Zekka|Sigfig> nshepperd: Did you know that alphabets are monoids? My word processor has a notion that lets you concatenate the Cyrillic and Latin alphabets.
17:55:47 <EvanR> number one plus of haskell is all the new shit you run into, new ways of thinkinga bout
17:55:58 <EvanR> word processors are chu spaces!
17:56:05 <ertesx> Zekka|Sigfig: in the more traditional loop-style implementation everything is global, so every single branch counts, with no delimiters
17:56:22 <Zekka|Sigfig> ertesx: I have to bounce around a lot of your program just to see how it leads to jumping back to hangmanStdio
17:56:33 <nshepperd> Zekka|Sigfig: I did know that, so that's a poor example of an educational program
17:56:36 <Zekka|Sigfig> when you introduce abstraction, you also introduce complexity from accounting for abstraction
17:56:52 <Zekka|Sigfig> nshepperd: My point is that you can indefinitely pump these out — I’m not sure that they create deep understanding
17:57:29 <nshepperd> maybe you don't think that hangman being monoidal is interesting, but I did
17:57:42 <EvanR> you can use the word concatenation or fusing instead of monoid if that is adding complexity it of itself
17:57:55 <ertesx> Zekka|Sigfig: since you don't program that way in your day-to-day work (that's what i got from your earlier statement), i can totally see how coroutines and free structures in general may be confusing to you
17:58:06 <ertesx> Zekka|Sigfig: but if you can handle free monads, you can handle Hangman
17:58:13 <Zekka|Sigfig> ertesx: I do use coroutines and free structures, and used them more extensively when I used Haskell
17:58:23 <Zekka|Sigfig> But I don’t use them for this.
17:58:29 <ertesx> well, i do
17:59:03 <nshepperd> bah
17:59:14 <nshepperd> there's no "jumping back to hangmanStdio" here
17:59:37 <ertesx> nshepperd: actually there is
17:59:47 <ertesx> it's coroutines
17:59:52 <Zekka|Sigfig> nshepperd: Well, we know that this can be captured by a loop, and we know from the output that this program captures iterating until reaching a termination condition
17:59:58 <nshepperd> is your complaint just because line 31 is obfuscated?
18:00:01 <ertesx> singleton/mappend on one side, hangmanStdio on the other
18:00:06 <ertesx> and they ping-pong
18:00:33 <Zekka|Sigfig> nshepperd: No, it’s also because I don’t think lines 5 through 22 would need to exist in an ordinary implementation of hangman, and I think the check in 37 could be represented more simply by writing it inline
18:00:34 <nshepperd> I guess you can see it like that. It just looks like an interpreter to me
18:00:34 <EvanR> ill say it again i would be interested in a "intuitive" explanation about how "loops" well represents turn based games
18:00:45 <maerwald> haskellers... talk about abstraction in hangman implementations all day, but will never finish a 3d fps shooter :P
18:00:47 <EvanR> for something different ;)
18:01:00 <ertesx> i don't think loops represent *anything* well =)
18:01:19 <ertesx> this is not a joke: i have serious problems understanding loops i haven't written myself at most a few days ago
18:01:27 <Zekka|Sigfig> Well, most people read from top-to-bottom unless told to do otherwise
18:01:42 <nshepperd> get a line from stdin, follow that branch of the Hangman tree, continue interpreting
18:01:46 <Zekka|Sigfig> Loops are one way of getting code that can be read top-to-bottom, although they might not be the best way
18:01:50 <Lokathor> ertesx, you're an odd duck
18:01:50 <EvanR> but not everything is a list of commands, usually its not
18:01:57 <EvanR> in general youre not reading a huge list of commands
18:02:13 <Zekka|Sigfig> Hangman is a game that continues until one of two conditions is true — a loop gets read top-to-bottom until one of two conditions is true
18:02:21 <EvanR> and a lot of people skip around when reading
18:02:23 <Zekka|Sigfig> well, one condition — you can write two conditions there if you want
18:02:30 <maerwald> Zekka|Sigfig: I agree... in haskell you get used to jumping more around while reading a single function with let in, where and recursion and whatnot
18:02:38 <ertesx> in fact i'd rather write 100 lines of FRP code than 50 lines of callbacks
18:02:53 <Zekka|Sigfig> maerwald: Yeah, which annoyed me because my text editor didn’t make it easy to do
18:02:59 <EvanR> the basic monad!
18:03:02 <Lokathor> if only i knew how to write headless FRP :/
18:03:19 <ertesx> Lokathor: "headless"?
18:03:20 <Zekka|Sigfig> I’d say that it’s a mistake to call code written like this “separation of concerns” because the parts of your logic that determine things like what you actually jump to are off in another file with things you don’t care about
18:03:42 <Lokathor> ertesx, all the FRP examples i've seen are hooked up to a GUI, usually GHCJS in a browser
18:03:47 <Lokathor> i want to hook FRP up to an IRC bot
18:03:57 <Zekka|Sigfig> What that really comes down to is people have limited space on their screens and you probably can’t mechanically determine what the best things to put next to each other are
18:04:02 <ertesx> Lokathor: which framework?
18:04:05 <EvanR> .oO(but irc bots arent doing time vary values;)
18:04:15 <maerwald> Lokathor: you are lucky there are examples at all, for a lot of things there are just none :P
18:04:27 <Hijiri> irc bots can do time-varying values
18:04:29 <Lokathor> EvanR, they can be
18:04:35 <Hijiri> like
18:04:42 <Hijiri> the list of users in a room
18:04:43 <Zekka|Sigfig> Haskell, like Java, C++, and all the other languages that have strong opinions about what tools to use to solve your problems, gives you tools to sort things into like categories. But those are language-level tools, they don’t know what your problem is
18:04:44 <Lokathor> ertesx, well i've seen Reflex examples mostly lately
18:04:45 <maerwald> it seems to me there are more people that praise FRP than people who actually use it :P
18:04:53 <ertesx> Lokathor: wait
18:04:54 <EvanR> this whole time weve been talking about whats the more appropriate way to program something
18:04:55 <Lokathor> EvanR, I want an IRC bot that's an idle game
18:05:10 <EvanR> but irc bots and turn based games are really like hangman
18:05:14 <ertesx> Lokathor: this could help you: http://lpaste.net/159333
18:05:16 <EvanR> not quake 3
18:05:22 <Zekka|Sigfig> if you follow a guideline like “put all the types at the top of your file and all the functions at the bottom” you are potentially making your code harder to read, because types/functions are the language’s model — they’re not *your* model, and your model will use both
18:05:40 <Lokathor> ertesx, i'll check this soon
18:05:42 <monochrom> I have not read the code. (I was a slashdotter. Never read the original article! :) )  But I will comment on separating an interaction into data and interpreter. It is valueless if all you do is create that data and then only to interpret it. It is valuable if you have 2 or more ways to interpret the data, and/or 2 or more ways to create that data. E.g, how about having the computer play against itself (2nd interpreter). How about a test case that 
18:05:42 <monochrom> tests the interpreter (2nd source of data).
18:06:01 <Zekka|Sigfig> monochrom: It doesn’t sound like you would like ertesx’s code, presented as-is
18:06:04 <ertesx> Lokathor: more generally run a SpiderHost in a separate thread and do concurrent reading/writing there
18:06:15 <Lokathor> hmm
18:06:23 <monochrom> why?
18:06:24 * EvanR still working on pacman
18:06:32 <EvanR> (for the last N years)
18:06:34 <Zekka|Sigfig> it couldn’t easily be factored into bot vs bot because he hardcoded putStr / putStrLn — he only uses the interpreter to determine if hte game is won
18:06:55 <Zekka|Sigfig> He could potentially use it to implement other games that involve character entry but aren’t hangman
18:06:56 <ertesx> monochrom: this particular code is a simplified hangman (i call it tenderman)…  one feature of this kind of separation is that i can actually write game extensions
18:06:56 <Lokathor> EvanR, I want an IRC bot where you can PM it that you want to do a thing in the game, and then later you can message it again to check your progress, for example
18:07:15 <Zekka|Sigfig> (He has not done this yet)
18:07:15 <EvanR> so the irc bot is an interface to a real time game, that you cant see ;)
18:07:20 <ertesx> for example the ability to lose is not built in…  it would be written as a monoid morphism
18:07:24 <Lokathor> EvanR, yes exactly :3
18:07:59 <nshepperd> Zekka|Sigfig: eh? the interpreter doesn't do anything to determine if the game is won
18:08:06 <nshepperd> all it's doing is informing the player
18:08:08 <Zekka|Sigfig> (Which is obviously easier to understand than just writing a GOTO that leads to “you lose, your family is in ruins” — especially given that it involves extra state management not in ertesx’s existing hangman type)
18:08:42 <Zekka|Sigfig> nshepperd: Hm, when I said interpreter I meant to the combo of hangmanStdio and the Char -> Hangman infrastructure
18:08:45 <nshepperd> you could easily write a bot that beat the game in the shortest number of guesses or something
18:09:01 <ertesx> anyway, we're running a flamewar on when you should abstract
18:09:14 <EvanR> always abstract to hell!
18:09:18 <maerwald> no
18:09:20 <EvanR> lol
18:09:27 <nshepperd> that seems like a funny way to look at it
18:09:33 <Zekka|Sigfig> This is just reminding me too much of the java stuff I was trying to get away from when I originally picked up haskell
18:09:40 <maerwald> haha
18:09:40 <nshepperd> Char -> Hangman is clearly just a branch point in a tree
18:09:43 <Zekka|Sigfig> Observer everything! Interpreter everything!
18:09:49 <monochrom> I abstract when and when only I feel that I should or edwardk feels that I should.
18:09:51 <Zekka|Sigfig> At least Haskell is a little bit terser.
18:09:52 <ertesx> i'll exit with my personal opinion:  i abstract when it's comfortable, when it fits my thought pattern…  i don't think i overabstract in practical engineering
18:10:00 <maerwald> Zekka|Sigfig: except in java it's not even abstraction... it's just indirection :D
18:10:02 <monochrom> actually add Dijkstra there too
18:10:07 <Zekka|Sigfig> It’s not that much terser, it’s a little bit
18:10:18 <ertesx> this hangman game is *not* practical engineering…  it's simply not relevant
18:10:26 <monochrom> I abstract when and when only at least one of {I, edwardk, Dijkstra} would feel that I should.
18:10:34 <Zekka|Sigfig> maerwald: I don’t think there’s a really big practical difference between the tools Java gives you and the tools Haskell gives you, although I like Java’s type system a little less — but pretty much everyone here would probably disagree with me on that
18:10:48 <maerwald> yes, I do
18:10:49 <Zekka|Sigfig> I think Java is a lot more verbose and Java programmers *usually* have much worse taste
18:11:08 <Zekka|Sigfig> it’s not that hard to mechanically translate Haskell to Java though, excluding laziness
18:11:11 <maerwald> the difference between the tools are so fundamental I don't even know where to start
18:11:17 <EvanR> exception pasing style ftw
18:11:30 <hackrilege> i found reversi in haskell but its huge! http://codereview.stackexchange.com/questions/9950/reversi-othello-game-engine-command-line-interface
18:12:15 <ertesx> java: Enterprise.Factory.Facade.Business.Data.Object.Enterprise.Enterprise.IConcatenable
18:12:19 <ertesx> haskell: Data.Monoid
18:12:37 <EvanR> at least 19 different lines of the form import qualified Data.Whatever as X ;)
18:12:52 <EvanR> and 10 languag pragmas
18:13:24 <mgsloan> sm: MichaelBurge: HEAD of stack can now use GHC 8.0 along with snapshots (via "compiler: ghc-8.0" and "allow-newer: true" in config)
18:13:32 <ertesx> after having instantiated your 20th layer of object-oriented madness, tell me again that i overabstract =)
18:13:51 <Zekka|Sigfig> ertesx: it *really* doesn’t require you to do any of that
18:13:51 <sm> nice!
18:13:51 <MichaelBurge> mgsloan: Hey, that was fast. Thanks again!
18:14:07 <mgsloan> Welcome!  I already had code stashed, just had to get back to it and resolve a few things
18:14:13 <Zekka|Sigfig> I’m not trying to defend Java, I’m trying to defend what I see as good taste
18:14:43 <ertesx> Zekka|Sigfig: i know
18:14:57 <Zekka|Sigfig> the extreme bad taste I see in Java is not that hard to manifest elsewhere, and when you’re talking about record-manipulating languages they’re mostly pretty equivalent down to really local stuff
18:15:18 <Zekka|Sigfig> your code could easily be translated into Java, although thanks to java’s bad syntax it would have been far longerr
18:15:37 <ertesx> Zekka|Sigfig: but i don't think we're going to agree on good taste, but i'm pretty sure that there are some forms of bad taste we can agree on
18:15:40 <Zekka|Sigfig> the patterns you chose to use don’t have names in Java but they’re about as complicated as the patterns Java programmers really like for mysterious reasons
18:15:58 <ertesx> let's focus on that instead
18:16:13 <lpaste> nshepperd annotated “Hangman (algebraic version)” with “Hangman (algebraic version) (game playing bot)” at http://lpaste.net/160805#a160807
18:16:39 <ertesx> Zekka|Sigfig: foldMap can't be translated, because java lacks type constructor polymorphism
18:17:02 <Zekka|Sigfig> ertesx: It can be translated, but you have to propagate an extra type variable for each application of the constructor
18:17:17 <Zekka|Sigfig> Or you can lose type safety
18:17:25 <EvanR> you will need a trampoline or exceptions or something to translate the non strictness
18:17:34 <EvanR> or itll be stack overflow
18:17:47 <dolio> You need a trampoline anyway.
18:17:50 <Zekka|Sigfig> Nonstrictness isn’t that hard to translate, and I wrote a trampoline for translating nonstrict code that only took about 300loc to express
18:18:00 <Zekka|Sigfig> er, not nonstrict- - for translating arbitrarily-recursive code
18:18:05 <ertesx> nshepperd: nice =)
18:18:07 <sm> it's great to see #haskell seriously working on how to encode games in haskell
18:18:08 <Zekka|Sigfig> I should be clear, my last project involved mechanically translating a lot of haskell to java
18:18:19 <EvanR> if you did this, i think it would be worse than the haskell version ;)
18:18:30 <EvanR> but maybe im wrong
18:18:49 <EvanR> sm++
18:18:53 * sm catches up on backlog
18:18:59 * hackagebot clock 0.7.2 - High-resolution clock functions: monotonic, realtime, cputime.  https://hackage.haskell.org/package/clock-0.7.2 (CetinSert)
18:19:01 <Zekka|Sigfig> EvanR: Maybe polymorphism over type constructors is not necessary to implement hangman — and says something about ugliness in the solution!
18:19:24 <ertesx> Zekka|Sigfig: folds are not necessary either
18:19:27 <ertesx> neither are ADTs
18:19:29 <Zekka|Sigfig> ertesx: Good point, toss those too
18:19:31 <EvanR> Zekka|Sigfig: hey, you havent even seen my hangman moves functor which will be fix pointed to generate all possible games
18:19:33 <nshepperd> This seems like a very strange discussion anyway. The idea of treating games as trees is really fundamental to the, uh, theory of games. There shouldn't be anything contraversial about doing that
18:19:34 <ertesx> neither are named functions
18:19:34 <Squarism> wow.. what a discussion hangman spawned.  =D
18:19:48 <ertesx> neither are…  sorry for not writing it in assembly
18:19:56 * sm reads latest paste and pretends he read the backlog
18:19:59 <ertesx> what a stupid argument, seriously
18:20:00 <nshepperd> it lets you write AIs and multiple interfaces easily
18:20:07 <ertesx> let's finish this already
18:20:14 <Zekka|Sigfig> ertesx: OK, bye!
18:20:47 * EvanR continues to attempt to implement pacman
18:20:50 <sm> can we do pong next ?
18:20:57 <EvanR> anybody got a game tree for that one?
18:20:59 <hpc> Zekka|Sigfig: basically the french revolution ;)
18:21:17 <monochrom> yes! pong is not a discrete tree. modeling pong as data will be interesting.
18:21:31 <hpc> pong is a discrete tree of frames
18:21:35 <EvanR> gross
18:21:45 <hpc> traversed by input
18:21:55 <EvanR> what about the TV scanline
18:22:08 <EvanR> its kind of like input
18:23:04 <EvanR> (im serious does anyone have any ideas)
18:23:36 <monochrom> I worry that scanlines contain too much information you won't use
18:23:46 <nshepperd> I suppose pong would have an action type like  Wait Double | StartMoving (Up|Down) | Stop
18:24:04 <Squarism> Just a question about Hangman. Is it sane to encode phases in Hangman (aka Game Interface's).. as more types. data Game = CardPlay | PreBattle | PostBattle | RandomAffection | EndOfYearSelection | GameEnded ? Would atleast be clear to me
18:24:15 <nshepperd> or that would be one way to do it
18:24:31 <Squarism> ...each with their own arguments as required from the users
18:24:46 <ertesx> Squarism: yeah…  if you return a different game type, you could interpret it as having switched to a different game
18:24:51 <ertesx> or a different phase of the same game
18:25:02 <Hafydd> Squarism: what do you mean by "more types"? That is a single type.
18:25:51 <ertesx> Squarism: data GameA = GameA PresentationA (MoveA -> GameB) | EndGameA EndPresentationA  -- like that
18:26:00 <Squarism> Hafydd, ok.. what do you call the named "thingies" separeted by "|" ? 
18:26:15 <Hafydd> Squarism: constructors.
18:26:19 <Squarism> ok
18:26:21 <ertesx> Squarism: but most likely you want multiple *constructors* rather than types
18:26:39 <monochrom> constructor, tag, variant, value
18:26:46 <EvanR> to distinguish the single-word constructors from the entire thing between | you could call the later "cases"
18:26:49 <Strout> Smeef, I do too. My entire skin is like a baby. Probably because I haven't worked hard a day in my life. Whenever someone shakes my hand they are like, whooawh
18:26:54 <Squarism> ertesx, i used wrong lingo
18:27:51 <monochrom> Strout: wrong window?
18:28:03 <Strout> oh shit
18:28:06 <monochrom> hehe
18:28:09 <matt-> :P
18:28:25 <EvanR> nshepperd: thats actually pretty cool
18:28:26 <Strout> I was like... what's going on.
18:28:49 * matt- shakes Strout's hand
18:28:55 <matt-> whooawh
18:29:07 * Strout walks away in shame.
18:29:42 <Hafydd> stdtrout
18:30:35 <geekosaur> I thought that was mst >.>
18:38:16 <nineonine> hey everyone
18:38:33 <nineonine> could someone help me with free monad transformer ?
18:38:47 <nineonine> thats my 4th attempt here
18:38:48 <nineonine> hehe
18:39:11 <nineonine> im building api wrapper
18:39:45 <nineonine> and one of the data constructors for my functor
18:39:53 <nineonine> handles http responces
18:40:23 <nineonine> sometimes however there are actions that dont have response bodies
18:40:28 <nineonine> eg 204
18:40:54 <nineonine> so there is nothing to pass to next action 
18:40:57 <nineonine> here is the code
18:41:10 <nineonine> http://lpaste.net/160808
18:41:21 <nineonine> the problem is in the interpretIO function
18:41:54 <nineonine> when i run action with 204 response it always returns Left e
18:42:08 <nineonine> because there is no body and I have nothing to parse
18:42:48 <nineonine> its on lines 80-88
18:45:58 <sebben> hey, does anyone know where there's a list of those special infix operators? I've tried googling them and come up with nothing :/ Things like <$>
18:46:45 <EvanR> https://github.com/haskellcats/haskell-operators
18:47:47 <sebben> brilliant, thank you
18:49:24 <pavonia> nineonine: Can't you use an empty body for parsing?
18:49:42 <nineonine> well I can use decode
18:49:50 <nineonine> which will return Nothing in that case
18:50:09 <nineonine> but I would need to wrap the return value in Maybe
18:50:12 <ertesx> http://lpaste.net/160809 ⇐ inspired by the earlier discussion…  good night =)
18:50:16 <nineonine> probably my only option
18:50:30 <pavonia> nineonine: What is the expected behaviour for a 204 resposne?
18:51:22 <nineonine> I want to have Right () in case of 204
18:51:45 <pavonia> That doesn't work
18:51:46 <nineonine> instead i get 
18:51:48 <nineonine> Left (ParseError "Error in $: not enough input")
18:51:56 <nineonine> can you explain why ?
18:52:18 <pavonia> Because you don't choose the result type, the caller of that function does
18:52:26 <nineonine> I dont really understand free monads, this usage here is purely academic
18:52:38 <nineonine> oh
18:52:53 <nineonine> so it will always return Left smth ?
18:53:19 <pavonia> It hasn't anything to do with free monads, as far as I can see, it's just a limitation by the type of interpretIO
18:54:23 <nineonine> well I dont understand why 
18:54:30 <nineonine> () has FromJSON instance
18:54:54 <nineonine> actually
18:55:07 <pavonia> Yes, but what if I decide to use that function with a ~ Int?
18:55:11 <nineonine> I think I starting to get it
18:55:14 <nineonine> yeah, right
18:56:48 <nineonine> so how can I handle this ?
18:57:35 <nineonine> because some actions does not return anything
18:57:58 <nineonine> maybe I should try to create another Data constructor for the functor
18:58:53 <nineonine> like
18:59:18 <nineonine> runReqVoid -> Request ->  DiscogsF m ()
18:59:26 <nineonine> oops
18:59:29 <nineonine> runReqVoid :: Request ->  DiscogsF m ()
18:59:37 <nineonine> but
19:00:00 <nineonine> then I can nest next action here
19:00:08 <nineonine> cant*
19:01:51 <pavonia> I'd wrap the result into Maybe
19:03:51 <pavonia> Or if the caller knows in what situations a 204 can occur, you could return undefined/error in that case and keep your fingers crossed that the caller catches the exception properly
19:04:10 <EvanR> isnt 204 like... "OKish"
19:04:24 <EvanR> ive been taking 2xx as ok
19:04:46 <nineonine> well its API specific
19:04:51 <nineonine> nothing I can do about it
19:06:03 <nineonine> first seems to be a better approach
19:07:11 <nineonine> or maybe I can change the return type from Either DiscogsError a to something like EIther DiscogsResponse a
19:07:19 <nineonine> and just extend this DiscogsResponse
19:07:29 <nineonine> anyway, thanks for help !!!
19:09:47 <hackrilege> does anyone want to help me with writing reversi? i have the board and gameplay set up here; http://lpaste.net/160810
19:11:37 <EvanR> is that like go
19:11:56 <hackrilege> yeah, could do go instead actually if you like
19:12:20 <hackrilege> go is a natuaral extension, it flips regions, while reversi flips lines
19:12:46 <hackrilege> it seems good for testing my zipper
19:13:15 <kadoban> go isn't much like reversi, they just look kinda similarish.
19:13:22 <hackrilege> the idea being that local traversals should be handled by local copies of the zipper produced during a full pass
19:14:03 <EvanR> does it support infinite reversi
19:14:23 <hackrilege> reversi is all about taking control of the corners and edges
19:14:36 <hackrilege> as they are invulnerable to flips in one or both directions
19:15:10 <hackrilege> so no, that isnt a good idea. infinite go might be ok though, not sure ofthe importance of edges in that game
19:15:17 <nineonine> pavonia: wrapping a into Maybe worked like a charm B|
19:16:09 <kadoban> hackrilege: Corners and sides are quite important
19:16:36 <hackrilege> not sure what EvanR is getting at anyway, i think he is being daft
19:17:01 <EvanR> yeah infinity is daft
19:20:27 <hackrilege> still working on this zippers thing, have a new stable build id love it if someone could look at for me http://lpaste.net/160811
19:24:05 <hackrilege> there is a prime on line 167 that can be turned on and off
19:26:08 <Lokathor> http://lpaste.net/160812 so I know it's somehow possible to merge the case on autoResult with the runST line by using some sort of fmap deal, but I'm not having luck doing it myself rith now
19:56:04 <byorgey> Lokathor: return . fmap (SimpleDungeon width height . V.map (>0)) $ runST $ ...  ?
20:02:22 <Lokathor> byorgey, cool, works
21:13:26 <linoge> Why would it make more sense to have IO Either(String, Number) than Either (String, IO) ?
21:16:21 <KaneTW> that syntax doesn't make sense
21:17:35 <sreekn> hello everybody , had a question for you - im using learnyouahaskell to get some exercises done , but one of these wouldnt work . 
21:18:13 <sreekn> http://learnyouahaskell.com/syntax-in-functions <<< example involves passing arguments to variables under the "where" call - 
21:18:25 <sreekn> pasting code here below - 
21:18:52 <sreekn> http://pastebin.com/9bjwfh1H
21:19:25 <sreekn> ^^ this would not compile on my ghci prompt when i load this code, says that i have an assignment error in the line with skinny = 18.5
21:19:39 <sreekn> is this an unsupported feature in some haskell compilers ?
21:29:05 * hackagebot aur 5.0.1 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-5.0.1 (fosskers)
21:41:20 <liste> sreekn: ghci prompt has a bit different syntax than Haskell per se. try either putting that in a file and `:load'ing that, or put that code between :{ and :} in a GHCi prompt
21:59:07 * hackagebot persistent-template 2.1.7 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.1.7 (MichaelSnoyman)
22:10:29 <Lokathor> if any speed junkies would care to try and improve something: https://github.com/Lokathor/ludolib/blob/master/src/Util/AutomataGen.hs
22:11:04 <Lokathor> there's a benchmark build in the ludolib.cabal file as well and such
22:24:07 * hackagebot cookie 0.4.2 - HTTP cookie parsing and rendering  https://hackage.haskell.org/package/cookie-0.4.2 (MichaelSnoyman)
22:34:08 * hackagebot stream 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/stream-0.1.0.0 (MichaelSnoyman)
22:35:23 <Zemyla> Hmm, would Void1 (where newtype Void1 a = Void1 Void) be a comonad?
22:36:04 <Zemyla> extract (Void1 v) = absurd v; extend _ (Void1 v) = absurd v
22:39:58 <owickstrom> Hi! When using :reload in GHCi on a package module I get an error `module ‘X.Y.Z’ is a package module`. Is there anyway to reload modules from external packages in GHCi? Thx.
22:41:41 <cocreature> Zemyla: looks fine, the laws should hold trivially since you don’t have any inhabitants
22:42:37 <Zemyla> It's like the Proxy instance of Monad.
22:42:55 <johnw> except that the inclusion of Void is giving you extra powers
22:42:58 <cocreature> are you talking about the monad instance of proxy? :P
23:02:25 <insitu> is there an analog to Free/Cofree pairing for extensible effects (http://okmij.org/ftp/Haskell/extensible/) ?
23:03:57 <insitu> trying to link that to David Laing's (and others) work https://github.com/dalaing/cofun on linking free monad DSL with cofree comonad interpreters
23:04:09 * hackagebot automotive-cse 0.1.2.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.2.0 (KeiHibino)
23:10:35 <maybefbi> what is the proc notation? is it what LANGUAGE Arrows is about?
23:23:57 <kadoban> maybefbi: I believe so
23:24:31 <maybefbi> ok
23:34:10 * hackagebot latex-formulae-hakyll 0.2.0.2 - Use actual LaTeX to render formulae inside Hakyll pages  https://hackage.haskell.org/package/latex-formulae-hakyll-0.2.0.2 (LiamOConnorDavis)
23:34:12 * hackagebot agda-snippets-hakyll 0.1.2.1 - Literate Agda support using agda-snippets, for Hakyll pages.  https://hackage.haskell.org/package/agda-snippets-hakyll-0.1.2.1 (LiamOConnorDavis)
23:40:30 <Lokathor> a java implementation of the same RNG as the haskell version i'm testing runs in about 1/100th the time.
23:40:45 <Lokathor> and the haskell version i'm testing already runs about 30% faster than StdGen
23:41:18 <Lokathor> either these benchmarks are insanely off or it's a somewhat distressing sort of result :/
23:54:49 <yarax> geppettodivacin no it should be f:: (UnionAddableType a) => a -> a -> a
23:55:28 <yarax> but the result should unpacked, so I guess it should and new type and functor/monad here
23:59:53 <homam> is anybody here familiar with hxt lib? how can i render CDATA with hxt? i am using `mkelem tagName [] [txt text]` i need `txt` to render CDATA content
