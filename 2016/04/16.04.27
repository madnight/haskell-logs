00:07:37 * hackagebot type-fun 0.1.0 - Collection of widely reimplemented type families  https://hackage.haskell.org/package/type-fun-0.1.0 (AlekseyUymanov)
00:07:37 * hackagebot mandrill 0.5.2.0 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.5.2.0 (AlfredoDiNapoli)
00:11:26 <koz_> Could someone help me understand what I'm missing here? http://paste.rel4tion.org/339
00:14:39 <shachaf> You can't change type with "l{val=f v}"
00:15:08 <shachaf> Since if l is Internal you wouldn't be changing left and right.
00:15:18 <koz_> shachaf: Oh. So I have to build from scratch then?
00:16:22 <shachaf> Probably.
00:16:48 <koz_> shachaf: The *second* one typechecks OK though...
00:16:53 <koz_> I am *terribly* confused.
00:17:35 <shachaf> If you change all three values that mention "a", then it's fine.
00:17:48 <koz_> Ah, I see - so that's why it works.
00:17:53 <koz_> Alrighty, thanks for that.
00:32:49 <Lovepon> Wow.
00:32:59 <Lovepon> I actually got my crappy code to compile... now what?
00:34:29 <Lovepon> It's like a dog chasing cars kinda thing. Lol.
00:42:22 <superguest> so I just started following my first tutorial, https://wiki.haskell.org/The_Monadic_Way/Part_I#The_basic_evaluator
00:43:07 <superguest> Can someone explain the  "deriving (Show)" part of the type constructor?
00:43:17 <Lovepon> superguest: It's... well, what it says.
00:43:19 <MasseR> It automatically creates a Show instance
00:43:35 <MasseR> data Foo = Foo deriving Show
00:43:40 <MasseR> show Foo -- "Foo"
00:44:57 <MasseR> There's a few of these type classes that can be automatically derived, such as Show, Read, Enum and some others
00:44:58 <joehillen> superguest: "show :: a -> String" is basically Haskell toString() method. "deriving Show" creates a String representation for your type.
00:45:32 <superguest> joehillen, thank you for using the method() analogy.
00:45:38 <Lovepon> Cale: TBH, I'm quite unsatisfied with what I did.
00:47:59 <joehillen> superguest: I've you're coming from the OOP world. I suggest that you be careful trying to map your existing programming knowledge onto Haskell. It will only confuse and frustrate you. Haskell is different. It's best to approach it naively.
00:49:00 <joehillen> That's just some advice I wish someone had told me 3 years ago ;)
00:49:34 <simpson> Alternatively, Haskell is like an object-based language, but with weird semantic choices. Equality is opt-in, referential transparency is generally enforced, and fun is kept to a minimum.
00:50:15 <simpson> But you can still make unreadable one-liners with lens, you can still fire missiles with unsafePerformIO, and you can still confuse everybody with recursive types.
00:50:28 <simpson> Also you can make exponentially-long type signatures. Who doesn't love that?
00:50:52 <joehillen> simpson: why are you here?
00:51:47 <superguest> simpson I have very very new to this.  but the recursive types are much like the Backus-Naur Forms
00:51:50 <simpson> joehillen: To ask Haskell questions and watch them go unanswered, mostly. Sometimes I know the answers to peoples' questions, too.
00:51:58 <superguest> to me, at least.
00:52:10 <simpson> superguest: Careful; while they might superficially look similar, ADTs are not like grammars.
00:52:26 <simpson> joehillen: I dunno. What kind of answer were you looking for? Is there a registration page for this channel?
00:52:59 <adarqui> say I have a class: class QueryParam a where .. qp :: a -> (String, String) ... then I have a function: params :: QueryParam qp => [qp] -> [(String, String)] .. is there any way for me to pass an 'empty list' [] to this params function without it error'n: No instance, or overlapping instances etc? Theoretically only one instance of QueryParam will exist. i dno ;/
00:53:12 <Iceland_jack> The fun is certainly not kept to a minimum, Haskell puts the fun in *fun*ctional
00:53:40 <joehillen> simpson: with that attitude, why even bother learning haskell? You obviously already know everything.
00:54:21 <simpson> joehillen: Sorry, is there a minimum coolade level? I don't have to believe in the Haskeller rule-the-world mentality to use Haskell, right?
00:55:39 <simpson> joehillen: Alternatively, do you want to tackle one of my Haskell questions? They're pretty tough chewing. I've been building a compiler in Haskell, and HOAS is both the thing that I want and also the thing that doesn't work.
00:56:01 <simpson> I want to use `bound`, really, but every time I try, I both learn a lot and fail miserably.
00:56:10 <superguest> simpson, can you briefly explain what referential transparency is?  ^^ the terminologies and concepts are abstract in Haskell ^^
00:56:20 <adarqui> i want people to be able to create their own data type, make it an instance of my QueryParam class, and then just be able to pass [] to the function, or an actual list of values that they have instances of QueryParam for
00:57:01 <MasseR> superguest: given a function, if you apply it twice you will get the same result twice
00:57:15 <MasseR> Int -> Int -> Int, will always give the same result
00:57:22 <MasseR> It can't go ask the database for more data or anything
00:57:40 <simpson> superguest: What MasseR said. Also what WP says on the topic. Also it is related to Liskov substitution, which might be familiar to you as well.
00:58:18 <simpson> Although Liskov's about types, and not values.
00:58:31 <Iceland_jack> simpson: That question has a lot of different answers, use HOAS for surface syntax and translate into bound or what ever you want to use internally is my recommendation
00:58:59 <Iceland_jack> simpson: this is a good pearl to read http://www.cse.chalmers.se/~emax/documents/axelsson2013using.pdf 
00:59:11 <Iceland_jack> http://comonad.com/reader/2014/fast-circular-substitution/
00:59:14 <insitu> adarqui define instance QP a => QP [a]  ?
00:59:35 <simpson> Iceland_jack: Yeah, that's what I angled towards. The big complication is that I have to either unify all of my different object "subclasses" into a single ADT with dozens of constructors (ugh), or adopt the existential typeclass antipattern (also ugh).
00:59:41 <simpson> Iceland_jack: Thanks for the reading!
01:00:32 <Iceland_jack> simpson: Just make a type for unary, binary, ... operators, that's a nice compromise 
01:01:27 <Iceland_jack>     data Exp a where
01:01:27 <Iceland_jack>       UnOp :: Unary a b -> (Exp a -> Exp b)
01:01:27 <Iceland_jack> where 'Unary a b' contains all the stuff you need, constraints, Haskell function, showable, ...
01:01:32 <simpson> Iceland_jack: It's currently kind of a construction area, but https://github.com/monte-language/masque/blob/master/Masque/Monte.hs#L18-L28
01:01:32 <adarqui> hey insitu, I tried that.. but still no luck: http://hastebin.com/yetizagigi.hs
01:01:44 <adarqui> insitu: somehow i'd like to just do: poop1 []
01:01:55 <Iceland_jack> If you're not using a gadt it becomes a lot simpler
01:02:03 <Iceland_jack> and using bound actually makes sense :)
01:02:20 <simpson> Iceland_jack: You can see the HOAS constructor. And, with some thought, you can probably see what I see, which is that HOAS makes it nearly impossible to have any kind of extensional sameness or equality test.
01:02:51 <insitu> adarqui poop2 should be your qp defintion for instance QueryParam [a]
01:02:56 <Iceland_jack> simpson: Translate the higher-order syntax into first-order syntax asap
01:03:20 <Iceland_jack> what ever method you use for that, the pearl is a good place to start but what ever way you prefer to avoid variable capture
01:03:25 <simpson> Iceland_jack: Yeah. The first draft of this used Unique on every object in order to get the extensional behavior.
01:03:35 <simpson> Maybe I should read before I do more hacking.
01:03:53 <simpson> Everybody says "write a compiler in Haskell". They don't mention that writing production compilers is hard. :c
01:03:57 <adarqui> insitu: but then i get type errors between (String,String) and [(String,String)]
01:04:03 <adarqui> maybe i need a qpList or something ?
01:04:18 <insitu> adarqui my bad, I misread the signature
01:04:19 <Lisa1157> I am trying to apply map to 2 functions (take the result from the evaluation of func2 then use that as input for the map of func1) but I cant seem to get the syntax down.. 'map func1 time $ map func2 time inptList'
01:04:31 <adarqui> np
01:05:03 <insitu> adarqui I did something similar for CSV things, your codomain should be uniform
01:05:23 <insitu> eg class QueryParam a where qp :: a -> String
01:06:30 <insitu> not sure about the context/usage so hard to tell :)
01:07:27 <adarqui> i just changed everything to String, I mean i can collapse (String,String) into k ++ "=" ++ v ..
01:07:43 <adarqui> i dno, still no idea how to pass an empty list other than to make it a [String]
01:07:47 <adarqui> instead of [qp]
01:09:58 <adarqui> i mean if I made it an instance of Show, i could do it.. so somehow Show does this
01:45:49 <lyxia> adarqui: the problem with passing an empty list is that the qp type is ambiguous
01:46:12 <lyxia> so add an annotation ([] :: [MyQP]) where MyQP is a concrete type implementing qp
01:46:23 <lyxia> QueryParam
02:03:35 <Lovepon> Why is there no combineDynWith3, combineDynWith4.... ?
02:06:29 <Lovepon> Also, is there an intermediate monoidal type for aweson?
02:06:31 <Lovepon> aeson*
02:07:29 <Lovepon> Oh, Series?
02:17:01 <Lovepon> Cale: I just realized that Workflow is not exactly what I want.
02:17:22 <Lovepon> Cale: It's close, but not close enough. I have to do a lot of type casting just to make sure it works.
02:19:54 <Lovepon>   rec eResult <- widgetHold (unWorkflow w0) $ fmap unWorkflow $ switch $ fmap snd $ current eResult
02:19:57 <Lovepon> Wow. Lol.
02:22:17 <Lovepon> Cale: I looked at the souce of workflow and I'll probably be using widgetHold instead.
02:26:33 <Lovepon> The amount of one liners in the source... '_'
02:30:25 <adarqui> thanks lyxia 
02:31:06 <adarqui> i wanted to avoid that somehow but.. did it a while ago
02:31:15 <adarqui> thought there could be a way around it
02:31:31 * ski idly wonders what code adarqui is talking about
02:31:56 <Lovepon> [Event t ()] -> Event t a -> Event t a
02:32:06 <Lovepon> That's probably what I actually really need...
02:32:08 <adarqui> nothing special, just supplying an empty list without a type annotation and trying to get it to pick some kind of default instance
02:32:12 <Lovepon> Errr, no.
02:32:14 <Lovepon> Not even.
02:32:16 <adarqui> ski: ^
02:32:32 <Lovepon> How do I delete a dom object though.
02:32:56 <ski> adarqui : in the interactor ?
02:33:09 <adarqui> ? dno what that is
02:33:17 <ski> GHCi is an interactor
02:33:30 <adarqui> ooh, in the repl ya, but, also compiling it
02:33:34 <Lovepon> Oh, I think I know what I want. Something like continuation style passing in reflex.
02:33:34 <ski> aka read-eval-print-loop, in expression-oriented languages
02:34:16 <adarqui> i just settled for type annotating it.. was wasting lots of time looking into it
02:34:19 <adarqui> ;f
02:34:42 <ski> adarqui : anyway, usually the context will determine it
02:34:55 <ski> but in some cases it may be ambiguous without a type ascription
02:34:55 <adarqui> ya but, []
02:35:06 <adarqui> just [] i dno, no context there
02:35:10 <adarqui> so: function []
02:35:22 <ski> `function' is (part of) the context there
02:35:54 <ski> also, if this is in a module, it must be part of some containing definition
02:35:59 <ski> which is also part of the context
02:36:36 <ski> (generally, the whole module, plus imported modules, is the context. but often not all of that is relevant)
02:36:55 <ski> (well, the whole module, &c., except the subexpression in question, of course)
02:39:15 <Lovepon> "In mathematics, the free category or path category generated by a directed graph or quiver is the category that results from freely concatenating arrows together, whenever the target of one arrow is the source of the next."
02:39:26 <Lovepon> This is the part where I have to say "Ohhhhhhh"
02:39:28 <Lovepon> lol
02:47:02 <ocramz> hej all; I have an AD-related bug: 'couldn't match CDouble with AD.Reverse s CDouble'. CDouble is an instance of (Eq, Ord, Real, Floating, Fractional, Num), and `AD.Reverse s a` is too, when `a` is. What's missing?
02:48:23 <jophish> ocramz: sounds like you're missing a Lift
02:48:45 <jophish> https://hackage.haskell.org/package/ad-4.3.2/docs/Numeric-AD-Internal-Reverse.html#v:Lift
02:49:17 <jophish> although it'd be more idiomatic to use 'auto'
02:52:49 <ocramz> jophish: I do use auto already; I fmap `auto` on the input to AD.jacobian. OK, here's the whole picture: I'm using a type synonym, `type PCDouble = CDouble`, so the actual error is `couldn't match CDouble with AD.Reverse s PCDouble`
02:53:08 <ocramz> I thought instances would carry over?
02:53:58 <jophish> the type synonym won't make any difference there. But what I'm seeing is: "Couldn't match type A with B" and "auto :: A -> B"
02:54:19 <jophish> perhaps you need to apply auto again somewhere
02:55:27 <Lovepon> > sequence $ Just (print "Hello world.")
02:55:29 <lambdabot>  <IO (Maybe ())>
02:55:37 <Lovepon> :/
02:55:44 <Lovepon> are you fucking kidding me
02:56:24 <Lovepon> Well, at least I got my answer.
03:04:24 <oconnell> hello everybody, I've just started with haskell so please be kind if it's obvious but I haven't found it at first go: I can build a simple program with ghc --make, that gives me an object file and some *.hi etc. Does the ghc comes with some kind of 'make clean' option or do I really have to rm all these files manually (just when playing around, still don't have any complex build script by now). 
03:05:04 <ocramz> jophish: thank you, I'll practice my lifts
03:06:35 <jophish> ocramz: np, happy to help
03:07:09 <opqdonut> oconnell: no there's no --clean unfortunately
03:08:16 <opqdonut> oconnell: you can use -outputdir to redirect all files to a certain directory though
03:10:37 <ocramz> jophish: thanks to a SO answer, I diked everything out and just passed `V.map realToFrac . f . V.map realToFrac` to AD.jacobian, where `f` is not type-constrained yet . The types click and the only remaining constraints on `f` are `(Fractional a, Real b) => V.Vector a -> V.Vector b`. Pure magic.
03:12:58 <oconnell> opqdonut: oh, ok, thank you!
03:13:30 <ocramz> I mean I understand what `realToFrac` does but I don't get how the AD-related constraints vanish
03:13:49 <ocramz> s/how/why/
03:14:11 <jle`> adarqui: you can add a type annotation
03:14:23 <jle`> oops, was accidentally scrolled all the way back
03:15:56 <saffronol> so Num is still complicated? :S
03:16:42 <saffronol> (regard this as a rhetorical question)
03:18:20 * Lovepon regards saffronol's question as a philosophical question.
03:20:53 <ocramz> saffronol: when was the last time you checked?
03:29:20 <Lovepon> Hmmmm
03:29:56 <Lovepon> Can't Event t be a monad?
03:30:32 <Lovepon> join = coincidence
03:31:04 <Lovepon> x >>= f = join $ f <$> x
03:31:07 <Lovepon> Err
03:31:15 <Lovepon> x >>= f = coincidence $ f <$> x
03:31:41 <Lovepon> Can't we declare something likeee
03:32:03 <Lovepon> Hmmm
03:32:15 <Lovepon> :t foldl1 (>>=)
03:32:16 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> a
03:32:17 <lambdabot>     Expected type: (a -> a) -> (a -> a) -> a -> a
03:32:17 <lambdabot>       Actual type: (a -> a) -> (a -> a -> a) -> a -> a
03:32:24 <Lovepon> Yep, we can't. :/
03:32:43 <Lovepon> :t foldl1 (>=>)
03:32:44 <lambdabot> (Monad m, Foldable t) => t (b -> m b) -> b -> m b
03:32:48 <Lovepon> HOLY SHIT
03:32:50 <Lovepon> Oh wait.
03:32:53 <Lovepon> b -> m b
03:32:57 <Lovepon> Not what I need. :Y
03:36:08 <Xnuk> :t foldM
03:36:09 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
03:40:13 <saffronol> Lovepon: gimme your answer :P
03:40:31 <Lovepon> saffronol: '_'
03:40:36 <saffronol> ahhh
03:40:39 <saffronol> same here
03:40:43 <saffronol> 0_________________________________0
03:40:48 <Lovepon> xD
03:41:01 <saffronol> haskell can be complicated.
03:41:06 <Lovepon> I have no fucking idea how to reflex-dom.
03:41:12 <saffronol> me neither
03:41:20 <saffronol> watch your language please :)
03:41:27 <Lovepon> saffronol: Sorreh.
03:41:30 <saffronol> nvm
03:41:46 <Lovepon> It's just that... deadlines. ;~;
03:41:53 <saffronol> oh
03:41:55 <saffronol> ouch
03:42:05 <saffronol> but theres people here who know how to reflex-dom
03:42:49 <saffronol> deadlines are the biggest fear of the lazy evaluational programmer
03:43:12 <saffronol> i suggest a pause.
03:43:50 <Lovepon> https://wiki.haskell.org/wikiupload/1/17/Haskell-wordle-irc.png
03:44:02 <Lovepon> Did the swear words get filtered out?
03:44:18 <Lovepon> Considering this is a programming channel...
03:44:28 <runeks> What am I missing in order to generalize this function to work with different states ('s') and "readers" ('r')? 
03:44:31 <runeks> protoGetChanMap :: (MonadReader r m) => ProtoS r s ChannelMap
03:45:15 <runeks> newtype ProtoS r s a = CProtoS { getProtoS :: S.StateT s (ReaderT r (ExceptT ProtocolError IO)) a } deriving ...
03:46:34 <lyxia> protoGetChanMap :: (MonadReader r m) => ProtoS r s ChannelMap   < there's not m
03:47:16 <lyxia> remove that constraint
03:47:38 * hackagebot hakyll 4.8.1.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.8.1.0 (JasperVanDerJeugt)
03:47:42 <lyxia> runeks: ProtoS should be an instance of MonadReader 
03:48:20 <runeks> lyxia: I forgot to parametize ProtoS over m
03:48:24 <runeks> that seems to fix it
03:48:29 <lyxia> oh
03:48:42 <lyxia> but why
03:48:59 <lyxia> did you mean you replaced IO with m?
03:49:12 <runeks> lyxia: Yes
03:49:19 <lyxia> ok nvm then
03:52:59 <Aruro> how do i horizontally join documents in PrettyPring.ANSI.Leijen, every document is align (underline $ integer (numerator n)) <$> (integer (denominator n)) ?
03:53:27 <Aruro> at best i get diagonal set of fractions using hsep
03:54:48 <Aruro> what is desired is horizontal (one double-line) list of fractions
04:13:39 <ntnt> I'm having trouble deciding between RWST Either vs EitherT RWS
04:14:51 <opqdonut> I guess it depends on whether you want to handle the failures using R or S
04:15:05 <ntnt> what is R and S ?
04:15:20 <hpc> what is RWS :P
04:15:21 <ntnt> reader and state 
04:15:25 <ntnt> rws = reader writer state
04:16:50 <jaseemabid> How can you find if a variable is of type ThreadId with Data.Typeable and DeriveDataTypeable extension? `case typeOf t of ThreadId -> print "yes"` throws error "Constructor ‘ThreadId’ should have 1 argument, but has been given none"
04:17:47 <opqdonut> ntnt: what I mean is this: when you get a failure (Left) from somewhere, do you want to use the Reader or State to decide what to do with it?
04:18:14 <opqdonut> ntnt: or do you just want the whole computation to short-circuit to Left
04:19:14 <opqdonut> @unmtl ErrorT e (RWS r w s) a
04:19:14 <lambdabot> r -> s -> (Either e a, s, w)
04:19:21 <opqdonut> @unmtl RWST r w s Either a
04:19:21 <lambdabot> r -> s -> Either (a, s, w)
04:19:36 <Aruro> how do i horizontally join documents in PrettyPring.ANSI.Leijen, every document is align (underline $ integer (numerator n)) <$> (integer (denominator n)) ?
04:19:52 <Aruro> what is desired is horizontal (one double-line) list of fractions
04:20:04 <opqdonut> ntnt: see above. in the first case (ErrorT) you get a Left/Right result, and a new state, and any written values
04:20:17 <Aruro> at best i get diagonal set of fractions using hsep
04:20:20 <opqdonut> ntnt: in the seecond case (RWST), you only get a new state and the written values on success
04:20:35 <ski> (s/Either/(Either e)/)
04:20:59 <opqdonut> ski: oh right thanks
04:21:08 <Lovepon> Mmmmm
04:21:17 <opqdonut> @unmtl RWST r w s (Either e) a
04:21:17 <lambdabot> r -> s -> Either e (a, s, w)
04:21:18 <Lovepon> Cale: I think I "get" the problem.
04:22:00 <ntnt> opqdonut: hmm, TBH, I don't know what I want on failure yet
04:22:03 <ntnt> perhpas I should figure thatout first
04:22:50 <opqdonut> ntnt: it should be fairly easy to change from one monad to the other, so you can just start with either one
04:23:00 <opqdonut> ntnt: I think RWST is conceptually simpler
04:23:49 <Lovepon> Cale: From what I can see, widgetHold et. al. are too... how do I say this, centralized.
04:24:40 <Lovepon> Cale: Hmmmmm, I think it's my design that's problematic though.
04:28:35 <hexagoxel> jaseemabid: uh, why are you looking for runtime type information for a statically typed language? either `t :: ThreadId` or not; it does not make sense to branch on that.
04:32:50 <zoran119_> looking at types of (lines) and (map (words)), i expect to be able to make a function (f = lines . map (words))
04:33:27 <zoran119_> i expect it to work because the types should flow String -> [String] and then [String] -> [[String]]
04:33:33 <zoran119_> why doesn't this work?
04:33:51 <zoran119_> i get - Couldn't match type ‘[String]’ with ‘Char’
04:37:04 <ski> zoran119 : perhaps you meant `map words . lines' ?
04:37:45 <zoran119> ski: of course, thanks
04:37:52 <ski> `(map words . lines) s' would be `map words (lines s)', iow converting your string `s' to a list of lines (strings), then converting each of them to a list of words
04:39:00 * ski looks at jaseemabid
04:42:00 <ski> @type \t -> typeOf t == typeOf (let unIO :: IO a -> a; unIO = undefined in unIO Control.Concurrent.myThreadId)
04:42:01 <lambdabot> Typeable a => a -> Bool
04:42:11 <ski> jaseemabid : if you really must, you can do something along that line
04:42:38 <ski> there's probably a nicer way to refer to the `TypeRef' for `ThreadId', though
04:43:22 <ski> jaseemabid : .. also, if you wanted the *type-system* to make use of this knowledge, you'd use `cast' instead
04:44:05 <ski> jaseemabid : in any case, you get an error because your pattern was using the *data* constructor `ThreadId', not the *type* constructor `ThreadId'
04:44:28 <ski> (another reason why i don't like reusing the same name for the data constructor as for the type constructor
04:44:31 <ski> )
04:45:38 <ski> (iirc, the dynamic system in Clean was nicer here, allowing you to match directly on a dynamic package, also with binding type variables)
04:45:52 <ski> @type dynApply
04:45:53 <lambdabot> Dynamic -> Dynamic -> Maybe Dynamic
04:46:20 <ski> in Clean, this would have looked something like (in terms of the Haskell operations) :
04:46:46 <ski>   dynApply (toDyn (f :: a -> b)) (toDyn (x :: a)) = toDyn (f x :: b)
04:47:00 <ski> (i don't recall the concrete syntax they used, but the gist was this)
04:47:23 <ski> er, well obviously with a wrapping `Just', and an "or-else" `Nothing' case
04:53:05 <ski> hmm
05:02:47 <ski> Lisa1157 : did you mean `map (func1 time) (map (func2 time) inptList)' ?
05:03:54 <ski> Lisa1157 : you could also write this as `(map (func1 time) . map (func2 time)) inptList'
05:04:12 <ski> Lisa1157 : .. personally, i would prefer either of these over using `$' (which i think usually looks ugly)
05:05:05 <ski> Lisa1157 : btw, in your specific case, there's a general law that `map f . map g  =  map (f . g)', for every function `f' and `g' (so, we "fuse the two loops into a single one")
05:05:27 <ski> Lisa1157 : so, in this specific case, `map (func1 time . func2 time) inptList' is even better
05:14:51 <Lisa1157> ski: I managed to get it working with this syntax after trial and error
05:14:52 <Lisa1157> map (func1 t) $ (func2 t myList)
05:15:18 <ski> hm, that's not the same thing
05:15:36 <ski> in that case, `func2' operates on the whole list, not on an element at a time
05:16:07 <ski> Lisa1157 : do you know how `$' is defined ?
05:17:06 <Lisa1157> ohh my bad I did not correctly mention that func2 takes a list  and func1 takes 1 at a time
05:17:29 <ski> ok. your original question was
05:17:31 <Lisa1157> ski: I just thought $ was to make sure evaluation order is as expect
05:17:37 <ski> <Lisa1157> I am trying to apply map to 2 functions (take the result from the evaluation of func2 then use that as input for the map of func1) but I cant seem to get the syntax down.. 'map func1 time $ map func2 time inptList'
05:17:57 <ski> which led me to believe that both `func1' and `func2' operated on an element at a time
05:18:11 <Lisa1157> ski: yea.. sorry my bad
05:18:41 <ski> Lisa1157 : my advice is : if you don't know how `$' is defined (including the `infixr' declaration for it), then stay away from `$', at least for the while
05:19:04 <ski> Lisa1157 : instead learn to use brackets correctly. brackets are nothing to be feared
05:19:36 <ski> (Lisa1157 : no need to feel sorry. it was just me misinterpreting your question. if any bad, it's on my side for assuming something you didn't say)
05:20:17 <ski> Lisa1157 : remember that brackets are for grouping, they are not for "function calls" (as they happen to be in some other programming languages you may have seen)
05:20:31 <ski> (they are also used for tuples, but that's a separate thing)
05:20:54 <ski> Lisa1157 : so, i would write your expression above as just `map (func1 t) (func2 t myList)'
05:21:11 <Lisa1157> ski: ahh alright
05:21:18 <ski> the first argument to `map' is the function `func1 t', and we need to wrap it in brackets because it's not atomic
05:21:40 <ski> otoh, the argument to `func1', namely `t', is an atomic expression, so we don't *need* to wrap it
05:22:00 <ski> the second argument to map, `func2 t myList' also needs to be wrapped because it's not atomic
05:22:51 <ski> in your original question, if we ignore the second `map', you had `map func1 time $ func2 time inptList', which is wrong because `map func1 time' will be interpreted as if you had written `(map func1) time'
05:23:12 <ski> but what you intended was `map (func1 time)', and so you must write those brackets explicitly
05:23:41 <ski> Lisa1157 : in general, in Haskell `f x y z' means `(f x) y) z', we "pass one argument at a time to the function `f'"
05:23:45 <ski> so, if we had
05:23:50 <ski>   f :: A -> B -> C -> D
05:23:53 <ski> then this really means
05:23:58 <ski>   f :: A -> (B -> (C -> D))
05:24:22 <ski> so `f x' will have type `B -> (C -> D)', a function still expecting a `B', assuming `x' was an `A'
05:24:43 <ski> and `(f x) y' (which is simpler written `f x y') will have type `C -> D', a function still expecting a `C', assuming `y' was an `B'
05:24:48 <akegalj> I am trying to overlap some MessagePack instance, but I keep getting "Duplicate instance declaration" error http://lpaste.net/6989462286670757888 , how should this be properly done?
05:25:00 <ski> and then `((f x) y) z' (which is simpler written `f x y z') will have type `D'
05:25:06 <ski> Lisa1157 : does that make sense ?
05:25:36 <Lisa1157> ski: im just going through it slowly but yea seems to mostly make sense :)
05:26:05 <ski> (ask if there's anything unclear)
05:27:39 * ski waits for Lisa1157 to respond, before continuing with a few further points
05:28:38 <Lisa1157> ski: haha sorry I was looking up atomic, I can interoperate what u mean by the context but wanted to know the exact meaning. I understand the  f :: A -> (B -> (C -> D)) part
05:30:00 <ski> Lisa1157 : "atomic" is here in the sense of a expression (represented as a sequence of characters)
05:30:25 <ski> Lisa1157 : so `32' and `map' are atomic, but `32 + 3' isn't. however, `(32 + 3)' *is* atomic
05:30:37 <ski> we use brackets to wrap an expression into an atomic one
05:31:08 <Lisa1157> okay ic
05:31:09 <ski> Lisa1157 : anyway, re `f :: A -> B -> C -> D', sometimes you may hear the expression "In Haskell, functions are curried"
05:31:27 <ski> this is a misconception
05:31:40 <ski> in Haskell, every function always takes exactly one argument
05:31:48 <ski> and if it doesn't take an argument, then it's not a function
05:31:49 <ski> so, e.g.
05:31:54 <ski>   getLine :: IO String
05:31:57 <ski> is not a function
05:32:09 <ski> (it's an `IO'-action)
05:32:32 <ski> however, in practice, it makes sense to *represent* "multi-argument functions" somehow, in Haskell
05:32:33 <Lisa1157> ski: so func1 in my case is an 'func1' action?
05:32:51 <ski> no, in your case you had something like
05:33:06 <ski>   t :: T
05:33:09 <ski>   myList :: [A]
05:33:27 <ski>   func2 :: T -> [A] -> [B]
05:33:32 <ski>   func1 :: T -> A -> B
05:33:53 <ski> (well, i'm just *assuming* that your `myList' was actually a list. the types themselves in what you said doesn't force it)
05:34:08 <ski> both `func1' and `func2' are functions
05:34:28 <ski> er, sorry, the signature for `func1' should have been
05:34:32 <ski>   func1 :: T -> B -> C
05:35:01 <ski> anyway, there's two main ways to represent a "multi-argument function"
05:35:47 <ski> you can (a) make a function that takes the "first" argument, and returns a new function that takes the "second" argument, and returns a function that ... takes the "last" argument, and returns the "final result"
05:35:55 <ski> this is
05:35:56 <ski>   f :: A -> (B -> (C -> D))
05:36:04 <ski> and this is called "curried style"
05:36:37 <ski> the other option is (b) make a function that takes a tuple (or other composite structure, like a record) containing all the "multiple arguments" as parts
05:36:41 <ski> this is
05:36:49 <ski>   uncurried_f :: (A,B,C) -> D
05:37:09 <ski> and this is called "tupled style", or "uncurried style"
05:37:45 <ski> of course, `uncurried_f' *really* only takes a single argument. but that argument is a tuple, containing three parts, which we can *think* about as the "three arguments"
05:37:56 <Lisa1157> ski: is f :: A -> B -> C -> D uncurried too?
05:38:01 <ski> no
05:38:13 <ski> `f :: A -> B -> C -> D' is the same thing as `f :: A -> (B -> (C -> D))'
05:38:23 <shachaf> i,i "is f :: (A,B) -> C -> D uncurried?"
05:38:44 <ski> it's just that because this style is the most common in Haskell, they decided that you can drop the brackets, and have it mean the curried version
05:39:04 <ski> shachaf : both, yes :)
05:39:10 <ski> or perhaps one should say it's a mix
05:39:14 <shachaf> Currying is more a transformation than a state
05:39:20 <jaseemabid> ski: How can I differentiate b/w the constructor and data type ? 
05:39:33 <ski> (so these could be seen as extremes of a spectrum. sometimes intermediate forms are more appropriate)
05:39:40 <shachaf> Though you can take a thing and imagine that it was reached by currying another thing.
05:39:57 <ski> jaseemabid : the simplest way is to name them differently, when defining the data type
05:40:16 <jaseemabid> ski: But I'm dealing with a type I didn't define.
05:40:29 <Lisa1157> ski: why is a function that 'a function that takes the "first" argument, and returns a new function that takes the "second" argument, and returns a function that ... takes the "last" argument, and returns the "final result" ' significant?
05:40:32 <jaseemabid> ski, hexagoxel, I need a function to take Eq => a or ThreadId. 
05:40:47 <ski> jaseemabid : it doesn't really help here anyway, since the problem is that you meant to write a type, but you wrote it in a value expression context
05:41:30 <ski> jaseemabid : i'm sorry, "function to take Eq => a or ThreadId" doesn't make sense to me
05:41:37 <shachaf> It's unlikely that you need a function to take "Eq a => a". :-)
05:42:25 <Lisa1157> ski: why not just take multiple arguments? - Java/Py programmer here..
05:46:16 <Jinxit> currying gives you a lot of flexibility
05:46:22 <Jinxit> which you can't get in, say, java
05:52:43 * hackagebot invertible 0.1 - bidirectional arrows, bijective functions, and invariant functors  https://hackage.haskell.org/package/invertible-0.1 (DylanSimon)
05:55:14 <jaseemabid> ski: I'm toying with a little actor model implementation. There is a send function, that can take either an address (ThreadID) or a name. 
05:55:33 <jaseemabid> ski: Maybe I should wrap both cases with a Address type. 
06:47:45 * hackagebot text-show-instances 3.2.1 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3.2.1 (ryanglscott)
06:50:17 <jophish> What do people tend to do instead of `fmap . fmap . fmap`?
06:51:36 <Lovepon> jophish: they'd design it properly.
06:51:44 <Lovepon> jophish: jk.
06:51:57 <Lovepon> jophish: What type are yo working wtih anyway?
06:52:55 <EvanR> fmap^3
06:53:25 <Lovepon> EvanR: kek
06:53:30 <jophish> Lovepon: yeah, this is a little wonky corner here, I might switch things up. At the moment it's a list of AST elements annotated with Maybe values
06:53:39 <jophish> [MyAst (Maybe a)]
06:53:50 <Lovepon> jophish: I see.
06:54:19 <jophish> I think "design it properly" is a pretty good answer
06:54:24 <Lovepon> jophish: lol
06:54:35 <EvanR> exactly whats wrong with fmap . fmap . fmap
06:55:20 <Lovepon> EvanR: i have my reasons. '_'
06:55:20 <hpc> it's a symptom of poorly chosen types
06:55:24 <Lovepon> jk
06:55:26 <EvanR> its the simplest editor combinator for that type!
06:55:30 <Lovepon> EvanR: lol
06:55:38 <hpc> :t fmap . fmap . fmap
06:55:39 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
06:55:52 <hpc> heh
06:56:05 <kadoban> let fmapit = fmap . fmap . fmap  … boom, done.
06:56:15 <EvanR> right
06:56:18 <maerwald> hpc: you're saying whenever you need lenses you have poorly chosen types?
06:56:35 <Lovepon> Heck, if I even get two levels of nesting, I already start cringing. Lol.
06:56:52 <EvanR> modifying a "fully formed nest of data" ... lenses
06:57:42 <EvanR> even if you have a database value from which you make other reports as views, and you only modify the database.. the database is a fully formed nest of values
06:57:52 <hpc> maerwald: when it's that deep
06:58:14 <maerwald> I agree
06:58:24 <maerwald> unless you write a compiler or something
06:58:43 <EvanR> the Maybe might be a little much
06:58:55 <EvanR> in this case only
06:59:12 <Lovepon> hpc: There are only some things that are good when deep. This is not one of them.
07:00:07 <EvanR> i think a datapile consisting of a tree of small records is preferrable for performance to one huge record
07:01:14 <ggVGc> Lovepon: so what do you do?
07:01:32 <ggVGc> I often feel my data is inherently nested, so designing away from it would be an antipattern
07:02:20 <EvanR> use relational design! ;)
07:02:37 <ggVGc> EvanR: as in collections indexed by things?
07:02:45 * hackagebot open-typerep 0.6 - Open type representations and dynamic types  https://hackage.haskell.org/package/open-typerep-0.6 (EmilAxelsson)
07:02:52 <EvanR> as in... you have sets of entities, and relations between two sets
07:03:20 <EvanR> properties are just functions on a set
07:04:01 <hpc> ggVGc: as an example, say you have some value of type F (G (H Int)) that you're operating on
07:04:03 <EvanR> indexes map from values back to subsets of a set
07:04:12 <kahn> anybody else have issues with stylish-haskell in vim? on save it prepends a bunch of garbage characters to the top of the file, like... 4;0;rgb:00/2b/364;1;rgb:dc/32/2f4;2;rgb:85/99/004;3;rgb:b5/89/004;4;rgb:26/8b/d24;5;rgb:6c/71/c44;6;rgb:2a/a1/984;7;rgb:93/a1/a14;8;rgb:65/7b/834;9;rgb:dc/32/2f4;10;rgb:85/99/004;11;rgb:b5/89/004;12;rgb:26/8b/d24;13; etc etc...
07:04:29 <hpc> ggVGc: suppose you have an operation you want to perform that takes an F (G (H Int)) and adds 5 to all the Ints
07:04:29 <Lovepon> kahn: That doesn't look like garbage.
07:04:50 <kahn> well, it looks like colors, but it shouldn't be inserting this into the file ;)
07:04:54 <hpc> ggVGc: i would argue that's not a good operation to want, because the type it operates on is far removed from what you really want it to do
07:05:00 <tippenein> I'm confused about how to use Pipe's `for` - Pipes.for $ Pipes.Text.IO.readFile (glob "../tmp/tweets/tweets_*")
07:05:04 <Lovepon> kahn: Ah.
07:05:47 <ggVGc> EvanR: so my current sequencer is a good example. I have a Track, which has TrackEntries, and a TrackEntry has a list of TriggerEntries, and a TriggerEntry is a list of events for that trigger. THsi seems inherently hierarchical to me
07:05:48 <hpc> that operation could be written as a trio of fmaps, or you likely can refactor something else in a better way, which as a consequence makes you no longer want this operation
07:06:02 <ggVGc> hpc: what would you suggest in my case stated above
07:06:24 <EvanR> ggVGc: containment is a relation
07:06:37 <EvanR> one example of a relation
07:07:05 <ggVGc> EvanR: so how would a relational desing look in haskell rather than nested records? And what are the benefits?
07:07:20 <EvanR> if it werent pre-composed into a tree, you could search in ways that arent obvious with a tree
07:07:44 <ggVGc> yeah that's fair
07:07:49 <Lovepon> I'd use OOP.
07:07:58 <Lovepon> And use GetterFactoryGetterGetter
07:08:05 <ggVGc> that's not really helpful
07:08:16 <EvanR> ggVGc: heh... well haskell is really set up for relational programming
07:08:21 <EvanR> but there might be a way
07:08:27 <EvanR> s/is/isn't/
07:08:51 <ggVGc> well, so what do people do with that kind of data structure to not have a nested record like I have
07:08:54 <ggVGc> ?
07:09:01 <tippenein> looking for something like [FilePath] -> Producer Text.Text
07:09:13 <ggVGc> Lovepon: what do you do to avoid deeply nested records?
07:09:38 <Lovepon> ggVGc: Basically... I don't make them.
07:09:40 <ggVGc> I use lenses a lot now, because my code usually ends up with fairly deep nests of records. usually 3-4 levels often
07:09:45 <EvanR> i dont know, but to implement what i said it would simply be a bunch of Sets and BiMaps of some sort
07:09:52 <Lovepon> ggVGc: If I can't not-nest it, I don't make it.
07:09:53 <ggVGc> Lovepon: so, with my sequencer example, what would you have done?
07:09:56 <EvanR> and Maps for indexes
07:10:21 <EvanR> relations on sets forms a category and inner joins is the composition of relations
07:10:23 <hpc> ggVGc: in your case, conceivably you would want to fire triggers on a TrackEntity in many places
07:10:36 <hpc> ggVGc: maybe only firing particular triggers
07:10:54 <EvanR> subsets are identifiable as relations between a set and a one element set
07:10:58 <hpc> ggVGc: so you write some trigger function that operates on TrackEntry, and then a function on Track that calls that
07:11:23 <Lovepon> ggVGc: Can you describe it agin? My internet too slow.
07:11:28 <hpc> ggVGc: it's still technically nested the same as before, but slightly flatter by way of not caring what a TrackEntry is composed of
07:11:47 <ggVGc> hpc: but practically the only other way I see to lay out the data is to keep all instances of each type in separate lists, and have each entry index that list instead. Which to me is essentially the same thing
07:12:05 <EvanR> ggVGc: well 
07:12:07 <ggVGc> hpc: and how does this make the code simpler than using lenses?
07:12:08 <tippenein> this seems a bit closer.. for (each (glob "../tmp/tweets/tweets_*")) Text.readFile
07:12:09 <EvanR> Sets and Maps
07:12:41 <hpc> ggVGc: it gives names to significant operations
07:12:55 <EvanR> ggVGc: it turns out that there are more kinds of relations that crop up than just containment, so my idea also makes the data model more uniform
07:12:59 <srpx> Is there anything equivalent to Apache's Spark for Haskell? Seems like it is basically Scala for big data. A lot of map/folds going there.
07:13:02 <hpc> ggVGc: and it doesn't require changing the data layout even
07:14:30 <ggVGc> EvanR: is this how you actually write your haskell?
07:15:03 <ggVGc> hpc, EvanR, Lovepon, this is essentially the basis of my code model currently, https://gist.github.com/532e006f71d617afd7be42e0bba57d86
07:15:06 <EvanR> i tend to get caught up in writing a new language that makes what im saying a lot easier to write 
07:15:20 <hpc> ggVGc: you know how there's a rule in imperative programming to avoid nesting more than 2 or 3 levels of indentation?
07:15:49 <hpc> ggVGc: there's a lot of reasons behind that rule, like just the syntactic advantage of not starting every line halfway across the screen
07:15:59 <tippenein> that gist is a good example of how bad github is at highlighting code
07:16:04 <hpc> ggVGc: but also keeping things simpler by limiting how deeply into something you can make a function sensitive
07:16:25 <ggVGc> tippenein: yeah it's not so great eh..
07:16:35 <hpc> ggVGc: just about every unpeeling of an abstraction layer in a language with poor expressiveness involves a layer of indentation (via if-then-else, loop, etc)
07:16:37 <EvanR> ggVGc: on this subject though im skeptical about not having a lot of nesting, like a game state (even if you have a relation model) will have some nesting
07:17:16 <EvanR> or app state
07:17:16 <hpc> ggVGc: applying the same principle to haskell doesn't have the same highly visible result of "use less tabs", but the result of having better code is the same
07:17:26 <ggVGc> I'm just asking this time because multiple people seemed to express disliek of nesting records, and I've been trying to not do it so much, but I don't know a better way in haskell currently
07:17:37 <hpc> sometimes you do have to though
07:18:02 <hpc> writing code that manipulates 3d data always involves at least 3 levels of indentation for instance
07:18:06 <ggVGc> hpc: you don't have to convince me. I'm looking for practical tups on how to avoid nested records, because I genuionely don't know a better way to implement my data structures than that gist I pasted
07:18:07 <EvanR> exzctly what is it about records that makes nesting bad?
07:18:11 <Lovepon> ggVGc: I don't really understand it from the types alone.
07:18:30 <hpc> ggVGc: write simpler operations on nested data, and compose them
07:19:06 <lpaste> tippenein pasted “simple streaming files to stdout” at http://lpaste.net/161666
07:19:23 <acertain> is there any work on 'generalized pattern synonyms`, where you can e.g. `f (Traverse x) = b x` => `f y = traverse b y`
07:19:37 <ggVGc> hydraz: isn't that exactly lenses?
07:19:49 <ggVGc> hpc: ^
07:19:52 <ggVGc> sorry mis-highlight
07:20:16 <lpaste> tippenein revised “simple streaming files to stdout”: “simple streaming files to stdout” at http://lpaste.net/161666
07:20:29 <EvanR> also splitting your 3 or 4 "classes" into separate sets would make modifying the separately serialized versions easier, if oyu needed to
07:20:40 <hpc> ggVGc: lenses are just a tool, they don't really create an abstraction boundary in your code
07:20:40 <ggVGc> EvanR: well, the discussion in here when I arrived now was that "If you use lenses your data design is crap, because it means you're using too much nested records"
07:20:45 <EvanR> and works well with csv format
07:21:07 <tippenein> anyone help discerning the errors in that paste above. involving Pipes
07:21:24 <hpc> ggVGc: when you write operations that are "take a Track and do something with its double-nested events", instead think in terms of "take a Track and do something with its TrackEntries"
07:21:36 <hpc> ggVGc: and then "take a TrackEntry and do something with its event handlers"
07:21:58 <hpc> ggVGc: write them separately, give them separate names, and then your first operation doesn't need to know how the second works
07:22:05 <ggVGc> sure, but that doesn't have to do with the data layout
07:22:29 <ggVGc> I was under the impression you and Lovepon were arguing nested records were inherently a sign of bad design
07:22:29 <hpc> the data layout determines what the operations are
07:22:48 <Lovepon> ggVGc: I kinda am.
07:22:49 <EvanR> the data model is kind of a big ball of mud, you cant abstract it. it is the abstraction
07:22:56 <Lovepon> ggVGc: I don't know about the others.
07:23:18 <ggVGc> Lovepon: but what are you suggesting instead, to model a problem that in real life is inherently essentially a tree relationship?
07:23:35 <hpc> ggVGc: ah, yeah i should have made that more clear
07:23:44 <ggVGc> a human has a nose, which has two holes, which has hairs in them
07:23:54 <ggVGc> isn't that a tree inherently?
07:23:56 <hpc> ggVGc: when i said "poorly chosen types", i mean like having handleFoo :: ThingWithFoosAndBars :: IO ()
07:24:03 <hpc> ggVGc: vs handleFoo :: Foo -> IO ()
07:24:09 <EvanR> ggVGc: in haskell and in clojure i have noticed the idiom that your app has one giant value as its state, and nesting will definitely keep it organized and performant for updates
07:24:35 <ggVGc> EvanR: it's just the most straightforward mapping to the problem being modeled, imo
07:24:41 <ggVGc> it's the easiest to reason about and work with
07:24:41 <Lovepon> ggVGc: Well, if it's inherently such, then sure.
07:24:52 <EvanR> ggVGc: yes but then within that value... you can go many ways
07:24:57 <Lovepon> ggVGc: If it's not, then why complicate it.
07:25:06 <ggVGc> Lovepon: well, that's why I'm asking
07:25:18 <ggVGc> because you guys were waving absolute truths and rules
07:25:27 <EvanR> a relational approach is more generally applicable in my experience
07:25:34 <Lovepon> ggVGc: Sorry, it was more of a rule-of-thumb.
07:25:48 <ggVGc> EvanR: but doesn't it add cognitive obverhead over the code base?
07:26:08 <EvanR> you obviously would want to write a relational database system every time
07:26:12 <EvanR> would NOT
07:26:18 <EvanR> that is a reusable language
07:26:40 <Lovepon> ggVGc: Right, this one is questionable to me.
07:26:43 <Lovepon> , _trackEntries :: [Maybe TrackEntry]
07:26:44 <EvanR> but the methodology is a tool that removes overhead for me
07:26:57 <hpc> EvanR: heh, you've forgotten the word "not" twice now
07:27:04 <Lovepon> ggVGc: These are the kinds of things I factor out.
07:27:07 <hpc> EvanR: you should just add a ¬ key to your keyboard
07:27:08 <EvanR> wait until i start accidentally including it
07:27:21 <hpc> ;)
07:28:18 <EvanR> [Maybe TrackEntry] is like that to represent empty spaces
07:28:47 <EvanR> but really you have a relation between position and tracks ;)
07:29:02 <EvanR> its not a function since some are missing
07:29:48 <EvanR> you insert or delete by modifying the relation
07:30:15 <Jinxit> EvanR: Lovepon: how about this: a World has some Players which have an Inventory of Items which have Stats, would you not use nested records for this?
07:30:25 <EvanR> no
07:31:33 <Lovepon> Jinxit: FRP?
07:31:42 <EvanR> ;_;
07:31:48 <Lovepon> EvanR: wut?
07:32:06 <EvanR> i actually did implement a MUD with those objects, using relational
07:32:23 <Jinxit> EvanR: how would it look in relational style?
07:32:27 <Jinxit> and Lovepon, in FRP?
07:33:00 <Lovepon> EvanR: MUD?
07:33:00 <EvanR> in your simplified case, you just have a set of players, a set of items, and the "in players inventory" relation
07:33:33 <Jinxit> so the same as any relational DB?
07:33:34 <EvanR> not all items are in any inventory though... they could be in a room instead
07:33:48 <EvanR> well relational DBMS usually muck it up
07:34:12 <Lovepon> Jinxit: I'd do `data Player = Player (Int, Int) Inventory`
07:34:15 <EvanR> or people mess it up when using DBMS
07:34:42 <Lovepon> Jinxit: Or I'd just FRP everything, but that doesn't sound too nice.
07:34:51 <EvanR> i dont see how FRP applies?
07:35:02 <Jinxit> what are those Ints?
07:35:36 <Lovepon> EvanR: I'm making some assumptions right now.
07:35:47 <Lovepon> EvanR: That this is a game, etc. etc.
07:35:54 <EvanR> you have two questions you can ask: what are the players items, and what player is this item in? with a tree either way one of these questions cant be answered
07:36:02 <Lovepon> Hmmmm
07:36:23 <EvanR> you could have an index, or have a relation in the first place
07:36:32 <Jinxit> Lovepon: the code you gave was exactly what I said, "some Players which have an Inventory"
07:36:43 <Lovepon> Jinxit: Right.
07:36:44 <hpc> Jinxit: imo that data structure isn't inherently bad, but it makes it extremely tempting to write consumePotion :: World -> World
07:36:56 <Lovepon> hpc: lol
07:37:12 <Jinxit> EvanR: good point about the "parent" relationship, I've actually hit that wall before with nested data
07:37:13 <EvanR> consumePotion :: Player -> Item -> IO () ;)
07:37:33 <Jinxit> hpc: but that can always happen :)
07:37:37 <EvanR> Player and Item are on equal footing
07:37:40 <Lovepon> hpc: The Haskell car doesn't move, instead it makes a new car at the next position and destroys itself.
07:38:08 <Jinxit> EvanR: and how does this relational stuff actually take shape in Haskell? some library?
07:38:18 <EvanR> would be nice!
07:38:31 <EvanR> there is IxSet
07:38:43 <EvanR> but it kind of falls short of a full query language
07:38:54 <hpc> well, the query language is haskell
07:38:54 <EvanR> maybe
07:39:10 <EvanR> also IxSet is based on typeable...
07:40:27 <EvanR> consumePotion :: Player -> Item -> Transaction ()
07:40:44 <EvanR> commit :: Transaction a -> IO a, something
07:41:12 <hpc> honestly, i would do consumePotion :: Player -> Player
07:41:25 <EvanR> which potion?
07:41:31 <hpc> (assuming it's something like terraria where you just press 'h' and it munches a potion)
07:41:37 <hpc> heh
07:41:40 <Jinxit> let's say I have a function "use all consumables in inventory", that would require useAll :: Player -> PlayerItemRelations -> Whatever, right?
07:41:46 <EvanR> the one you previously indicated by updating the "current potion" slot? ;)
07:41:48 <Jinxit> sending all player->item relations around
07:41:59 <hpc> it depends on the game mechanics
07:42:39 <EvanR> Jinxit: well, i imagine you have access to anything in the database you want
07:42:40 <jophish> player ・__・―且 potion
07:42:47 <hpc> if the operation is "apply the specified potion's effects", i would maybe write applyEffects :: Player -> Potion -> Player
07:42:51 <EvanR> for whatever you need it for
07:42:59 <Jinxit> but that's equivalent to eatPotion :: World -> World
07:43:05 <jophish> oops, can't use underscores there
07:43:14 <hpc> and then for consuming particular potions, useItem :: Player -> Slot -> Player, which calls applyEffects and subtracts the item
07:43:33 <hpc> consumePotion would search for an applicable potion in the inventory and useItem it
07:43:45 <EvanR> Jinxit: you indeed have a main loop and it necessarily looks like that
07:43:49 <EvanR> and its not bad
07:44:04 <Jinxit> main loop sure
07:44:13 <EvanR> maybe bad for performance if you dont use enough nesting ;)
07:44:17 <Jinxit> other functions I would prefer to have as restricted as possible
07:44:18 <jophish> player ´・ω・っ且 potion, perhaps
07:44:44 <EvanR> Jinxit: well you pass in the parameters necessary and in the type also indicate you are using the database
07:45:04 <EvanR> to restrict access to the database in certain ways might be too much to handle for haskell
07:45:05 <Jinxit> so the database is a monolithic object?
07:45:36 <EvanR> well if you are going to update 2 out of 99 things
07:45:46 <EvanR> like 1 set and 1 relation, how do you put that in the type
07:46:12 <EvanR> and transactions would be nice
07:48:08 <Jinxit> by nesting it :D
07:48:15 <EvanR> but yeah the database is a monolithic thing, a commit updates a bunch of objects atomically
07:48:31 <Jinxit> like
07:48:38 <Jinxit> imagine handing off a part of the project to a newcomer
07:48:39 <EvanR> you have to change the schema carefully or random stuff will break
07:48:58 <Jinxit> like "write this buff function, you can work on the player and his items"
07:49:05 <Jinxit> but then you give full access to the DB
07:49:07 <Jinxit> boom
07:49:23 <EvanR> this sort of access-control-oriented-programming sounds theoretical ;)
07:49:24 <Jinxit> if it's encapsulated you can feel safe that he can only mess up so much
07:49:59 <EvanR> would be nice if you could restrict n00b programmer 3 to only be able to do specifically his task but
07:50:23 <EvanR> especially in game programming there is just too much random shit required
07:51:07 <Jinxit> well game programming is mostly a simple example
07:51:14 <EvanR> lol
07:51:15 <Jinxit> because everyone can relate to a Player and Inventory
07:51:42 <EvanR> its like the toughest domain to apply real principles to
07:52:01 <Jinxit> note "simple _example_"
07:52:16 <EvanR> for gui apps definitely relational
07:52:55 <EvanR> though i can see the language not being able to deal with it in for instance C
07:53:07 <EvanR> and you naturally resort to storing everything in a tree
07:53:38 <Jinxit> I don't think Haskell can be considered to be "able to deal with it" if you can't restrict access
07:54:06 <ij> Where can I see how thunks are implemented? 
07:54:06 <EvanR> access restriction is an interesting angle on this topic but i dont think thats what it originally was about
07:54:12 <ij> I mean read :)
07:55:34 <Jinxit> well the good thing I see about it is parent relations, but the bad thing is no access restriction
07:55:38 --- mode: adams.freenode.net set +o ChanServ
07:55:40 <Jinxit> just trying to see the pros and cons
07:55:57 <Jinxit> (and in my heart the access restriction feels more important)
07:56:01 <EvanR> can you explain how a large tree solves your access restriction goal?
07:56:05 <t0by> Evening.
07:56:09 <Jinxit> (worst case I pass the parent)
07:56:21 <t0by> > nub ((++) [1,2,3,4] [3,4,5]) ==  ((++) . nub) [1,2,3,4] [3,4,5] -- Why, please?
07:56:23 <lambdabot>  False
07:56:25 <Jinxit> you can at least restrict from the current object down
07:56:26 <EvanR> i.e. you can only update X
07:56:32 <t0by> I would expect that to be true
07:56:48 <t0by> i.e. nub (f x y) to be the same as  (f . nub) (x y)
07:56:58 <Jinxit> if I pass Player the n00b can't change World
07:57:10 <EvanR> you mean Player -> Player
07:57:15 <Jinxit> yes
07:57:29 <EvanR> this is definitely a incredibly simplified example ;)
07:57:47 <EvanR> solving just this wont really solve much
07:58:07 <Jinxit> when implementing hearthstone I ran into similar functions
07:58:11 <EvanR> also you have another access restriction problem
07:58:32 <EvanR> when you pass player in, your junior programmer can modify anything "under" player
07:58:39 <EvanR> when you might not want him to
07:59:08 <Jinxit> well, if you want him to be restricted to Inventory, then you pass that in
07:59:14 <Jinxit> or Inventory and Stats
07:59:18 <EvanR> what if you are restricted to Player
07:59:39 <Jinxit> if you can't change anything under player, then you can't modify anything :)
07:59:39 <EvanR> the hierarchy is just not able to satisfy this, since its fixed
07:59:56 <EvanR> how do you stop them from changing anything under player?
08:00:00 <EvanR> if you pass Player in
08:00:10 <Jinxit> fun :: Player -> Int
08:00:25 <EvanR> let me re-say this task ;)
08:00:31 <Jinxit> please do :)
08:01:08 <EvanR> you want to write a function to modify the Player, so Player -> Player for example, but also you DONT want to be able to modify Inventory or anything you nested under Player, just Player proper
08:01:27 <Jinxit> there is nothing in the Player that isn't under it
08:01:36 <lpaste> tippenein pasted “streaming multiple files, MonadSafe / Pipes” at http://lpaste.net/161669
08:01:42 <EvanR> so nothing has anything?
08:01:47 <Jinxit> I mean
08:02:06 <Jinxit> if the Player has an Int for health
08:02:10 <Jinxit> then you pass in that Int
08:02:10 <EvanR> change the names of the types so it brings up my problem, use a type that has properties that arent nested other objects
08:02:21 <Jinxit> and nothing else
08:02:24 <EvanR> sure you can modify an Int with Int -> Int
08:02:31 <Jinxit> exactly
08:02:32 <EvanR> but how do you write the function iasked for
08:02:36 <Jinxit> you don't
08:02:39 <EvanR> updates the players health
08:02:43 <EvanR> without modifying inventory
08:03:00 <Jinxit> pass in what you need, don't make the n00b ask for it
08:03:02 <EvanR> then how does the players health get modified ;)
08:03:14 <Jinxit> how does the Player get modified in Player -> Player?
08:03:16 <Jinxit> by replacing it
08:03:33 <EvanR> but how do you "know" that function doesnt modify the inventory accidentally
08:03:41 <Jinxit> because I only gave it an Int
08:03:43 <EvanR> its not specified in the type
08:03:52 <EvanR> you cant give Int to Player -> Player
08:04:09 <Jinxit> no because you don't write a function like Player -> Player unless you need the full object
08:04:13 <Jinxit> every subfield
08:04:40 <EvanR> then any modification of the players health must be done directly, without abstraction
08:04:51 <EvanR> it cant be made into a "player method"
08:05:04 <EvanR> it has to be repeated, with record update syntax, everywhere it occurs
08:05:22 <Jinxit> lenses make this rather easy
08:05:25 <EvanR> i guess that *might* solve the access restriction problem, but it seems wrong to me
08:05:35 <Jinxit> in fact it seems like a more reusable function
08:05:46 <Jinxit> was it a Player or Boss that lost health?
08:05:47 <EvanR> since youre directly access the player in more places, now you have even more places you "accidentally" modified the inventory
08:06:08 <Jinxit> I don't get that last point
08:06:23 <Jinxit> you mean when you call the functions that require health?
08:06:46 <EvanR> ive been showing how a tree does not provide all possible access restrictions due to the way it is nested, but you didnt get it ;)
08:07:10 <EvanR> it stops accessing of stuff above but allows everything below
08:07:17 <Jinxit> I get what you're saying, I'm just countering by saying what you want to do is straight up bad design
08:07:17 <EvanR> you cant do in between
08:07:39 <Jinxit> there is no way to restrict below
08:07:41 <Jinxit> in anything
08:07:46 <Jinxit> because below is what defines the object
08:07:56 <EvanR> requiring the only level 5 out of 10 be modified is bad design? i agree this whole acces restriction thing is too much, i was just playing along
08:08:10 <EvanR> there is a way to restrict below
08:08:24 <EvanR> in databases you can restrict access in any way you want
08:08:43 <EvanR> user X is only allowed to modify set Y
08:08:55 <EvanR> no parents, no children
08:09:09 <Jinxit> but on the other hand, you can't restrict it to a single entry
08:09:11 <EvanR> (subjective interpretations of relations to Y)
08:09:19 <Jinxit> you can't say "you can modify this player and his stuff"
08:09:28 <Jinxit> you can only give power over types
08:10:06 <EvanR> you can, in the same way
08:10:17 <Jinxit> and I'm saying that passing Player is bad design if you only want them to modify health
08:10:18 <EvanR> with a procedure, but now its getting irrelevant 
08:10:25 <Jinxit> yes
08:10:47 <EvanR> i am assuming Player is a record with properties, and there are other objects you arbitrarily nested inside of it
08:11:02 <Jinxit> yes
08:11:04 <EvanR> if you want to modify properties on player, then you use accessors, i dont think thats wrong
08:11:19 <EvanR> and there is no restriction in the type that those accessors are correct
08:11:42 <Jinxit> you mean you can't be sure it's a Player's health?
08:11:47 <EvanR> and thats fine because youve got lots of other things to worry about
08:11:57 <EvanR> right
08:12:11 <EvanR> modifyHealth :: (Int -> Int) -> Player -> Player
08:12:18 <EvanR> who knows what it does
08:12:32 <EvanR> do we need more access control
08:12:33 <Jinxit> well
08:12:40 <Jinxit> I would say modifyHealth :: Int -> Int
08:12:58 <Jinxit> and in the attack:: Player -> Player it might use modifyHealth
08:13:03 <EvanR> ... what does that do?
08:13:14 <Jinxit> maybe reduce health by 1, toy example
08:13:26 <EvanR> not very well named then, or useful
08:13:33 <Jinxit> toy example
08:13:34 <EvanR> (subtract 1)
08:13:56 <EvanR> the player access is more useful 
08:14:00 <Jinxit> and another way I (accidentally) solved the access problem was with typeclasses
08:14:07 <EvanR> sigh
08:14:46 <Jinxit> then you can pass the player object but in the signature it says "this thing has to have health" and nothing else
08:15:00 <EvanR> it is interesting that you consider restriction the most interesting design challenge, and ill leave it at that
08:15:24 <EvanR> i tend to avoid typeclasses for stuff like that
08:17:11 <simpson> EvanR, Jinxit: "Access control" is a losing game. You want capabilities, which Haskell lacks.
08:17:20 <EvanR> i was thinking about that
08:17:30 <Jinxit> capabilities?
08:17:31 <simpson> But, as always, it's interesting to see what kind of solutions people come up with.
08:17:45 <simpson> Jinxit: https://en.wikipedia.org/wiki/Object-capability_model
08:18:04 <EvanR> yes this would be more in line with what you were asking for
08:18:27 <EvanR> you give them the database and the capabilities for the task, and they cant do anything else
08:18:54 <EvanR> though i doubt it restricts them completely to their task
08:19:34 <Jinxit> I am not quite sure I get it, but isn't this just "modifyHealth :: HasHealth a => a -> a"?
08:20:02 <Jinxit> where HasHealth gives you some way to access that health, split into read/write if you want to be very specific
08:21:04 <EvanR> i would split into A.modifyHealth and B.modifyHealth and forget the typeclass
08:21:21 <EvanR> i dont think either one has much to do with capabilities
08:21:44 <EvanR> looking for a better resource than wikipedia
08:21:56 <Jinxit> yeah I don't think I understand it fully
08:22:50 <EvanR> its like permission to use methods
08:23:08 <Jinxit> and the typeclass there isn't?
08:23:27 <Jinxit> I mean sure, it might be kludgy to write, but it's at least possible
08:23:47 <EvanR> your thing lets you modify the health of "anything"
08:24:20 <Jinxit> yes, and I argue that's fine, because the one given the Player object already has full power over it
08:24:28 <EvanR> restrictions seem like a arbitrarily complex domain
08:25:23 <Jinxit> if we remove restrictions we get more complex state transitions
08:25:28 <EvanR> typeclasses for oop doesnt seem to really work, imo
08:25:28 <Jinxit> which I think we both agree is bad?
08:26:07 <EvanR> i have never really though of haskell as a restriction-oriented language, i always want to find ways to expand capabilities ;)
08:26:31 <Jinxit> it's like not wanting to be in IO all the time
08:27:12 <Jinxit> and this is of course something I follow in OOP languages as well
08:27:19 <EvanR> that particular example is kind of unfair
08:27:21 <Jinxit> but I think it's nice to apply it in Haskell
08:28:21 <EvanR> js isnt a restrictive language, you dont normally "miss" the ability to access the filesystem
08:28:39 <simpson> Jinxit: You might be interested in my side project: http://monte.readthedocs.org/en/latest/
08:31:37 <Jinxit> EvanR: sorry, could you rephrase that?
08:32:59 <EvanR> i was getting at the subjective feel of haskell not being IO everywhere by default
08:33:15 <Jinxit> simpson: where can I see a basic example with capabilities?
08:33:35 <EvanR> that its normal and not restrictive, and including IO everywhere would seem bizarre from a haskell perspective, like having js able to do "IO"
08:34:01 <simpson> Jinxit: http://monte.readthedocs.org/en/latest/taste.html#taste
08:34:12 <simpson> Jinxit: BTW, we're off-topic now, but #monte is a place if you're interested in more.
08:34:18 <EvanR> let me just return to a previous question, that how would you restrict in the type which set or relation could be updated, i wasnt saying that its impossible
08:34:56 <EvanR> i think it is possible, but the only way i can think of is too cumbersome to be worth it for game programming
08:35:28 <simpson> EvanR: It's a fair question. The best techniques I've seen involve a "smart constructor" or "smart slot" that both holds the actual state and also enforces a state invariant upon update.
08:35:35 <simpson> You'd have to hide the constructors.
08:37:25 <EvanR> yeah thats one way
08:48:10 <deni> is there an example somewhere of how to use ExceptT and IO? Speciically I want to try and see if I can catch all HttpException error messages so that I get back a Either MyError a back when I runExceptT
08:50:07 <deni> context: the goal is to abstract away the fact that I'm talking through a Http Api to something and translate the Http exceptions to more domain specific error messages so that the user doesn't have to think about http at all
08:58:08 <EvanR> deni: ExceptT ? it sounds like your http thing will throw an IO exception which is outside the scope of monad transformers
08:58:15 <deni> specifically I'm very much confused with throw vs. throwError vs. throwE
08:58:30 <EvanR> to get your Either MyError a to work, you use try from Control.Exception
08:58:50 <monochrom> yeah, "try" converts exception to Either.
08:59:21 <monochrom> you can then repackage Either into ExceptT or WhateverT if you want
08:59:37 <deni> monochrom: I'm not sure what you mean by repackage
08:59:53 <monochrom> perhaps it means "convert" again?
09:00:00 <deni> I did try using "try" and "catch" from Control.Exception so mask a HttpException into MyException
09:00:08 <deni> however that's still a IO exception
09:00:16 <EvanR> no try doesnst rethrow
09:00:29 <deni> I'm not sure in which part I'm supposed to transform that into an Either
09:00:43 <deni> in my runThing function?
09:00:46 <monochrom> 'using "try" and "catch"' is strange. you seldom use them together. you choose one. and it should be "try".
09:00:56 <deni> currently runThing = runExceptT $ runReaderT r (opts, h)
09:01:15 <EvanR> deni: "try" catches the exception and returns an Either value
09:01:21 <EvanR> your job is done, as explained
09:01:28 <deni> monochrom: oh I'm not using them together...just mentioning that I tried using both to see how they work
09:02:51 <EvanR> :t try
09:02:52 <lambdabot> Exception e => IO a -> IO (Either e a)
09:03:55 <EvanR> in case of Left e for some HttpException e, you can then convert the e to a MyError
09:11:28 <deni> EvanR: should I catch the exceptions in my http handler or in my runT where I actually run the handler?
09:12:13 <EvanR> i dont understand where your run is
09:12:50 <EvanR> are you sure you even need ExceptT
09:13:54 <jophish> When template haskell was first being thought up, was there any discussion of executing compile time haskell in a VM, instead of the current (imo crazy) solution of executing it natively?
09:14:17 <jophish> With all the implications for security and cross compilation that entails
09:14:32 <deni> EvanR: http://dpaste.com/0J5A9ZV
09:14:39 <EvanR> do you mean stop it from doing IO ?
09:14:40 <deni> EvanR: this doesn't actually compile btw
09:14:43 <deni> but that's the gist of it
09:16:16 <jophish> EvanR: perhaps, or at least restrict what it can do in terms of IO
09:16:23 <EvanR> deni: well do you want ExceptT or Either
09:16:37 <EvanR> or just use exceptions normally
09:17:05 <EvanR> jophish: seems to eliminate a huge use case for TH ;)
09:17:20 <deni> EvanR: I want ExceptT internally....eexternally it's Either
09:18:17 <EvanR> and are you converting ExceptT errors to Either or exceptions to Either
09:20:17 <deni> it would appear that I'm trying to convert exveption to exceptT and then to either
09:20:36 <EvanR> is that necessary?
09:20:46 <EvanR> how many exception mechanisms do you need ;)
09:20:50 <jophish> EvanR: I'm sure there's something in the design space a little safer than ACME.UploadMyCreditCardDetailsToPastebin
09:21:02 <deni> EvanR: what do you propose?
09:21:19 <EvanR> with TH one thing you can do is connect to a database to get a schema for use in generating type definitions
09:21:30 <EvanR> not sure how you can make that safe
09:21:57 <EvanR> maybe check how F# does it
09:22:26 <EvanR> deni: my first idea is to eliminate ExceptT and just use exceptions
09:24:26 <deni> I could do that if I was only in the IO monad
09:24:38 <deni> but the thing is I accept a http handler...which can be HttpHandler m
09:24:51 <deni> so I kinda need a standardized way to handler error independe of m
09:24:52 <EvanR> how does it report errors then?
09:25:04 <deni> and I thought that's what ExceptT was for
09:25:16 <EvanR> you added ExceptT or thats part of this crazy framework
09:25:26 <deni> I added it
09:25:31 <jophish> EvanR: I don't think you could, perhaps then we need -XSafeTemplateHaskell which avoids IO
09:25:38 <jophish> or simulates a subset of it
09:26:04 <EvanR> deni: well that wont magically make HttpHandler report errors using ExceptT
09:26:32 <EvanR> it reports errors some other way that i dont know
09:26:37 <EvanR> i assumed exceptions
09:27:04 <EvanR> if thats the case ExceptT does nothing
09:27:44 <monochrom> clearly, a function that does not declare ExceptT will not use it just because you add ExceptT on top.
09:28:02 <monochrom> if anything, you have to do your own conversion.
09:28:20 <monochrom> but that's a slippery slope to XY problems
09:30:56 <EvanR> this is at least a UVWXY problem since we start with how to use ExceptT with IO
09:31:06 <deni> monochrom: and that was my question from the beginning
09:31:12 <deni> how do I do that conversion
09:31:16 <deni> it wasn't clear to me
09:31:33 <EvanR> why do you want to insert ExcepT in the middle of all this
09:31:47 <deni> EvanR: yes it reports exceptions normally...I wanna catch them and convert to ExceptT
09:32:03 <monochrom> I don't know ExceptT. But I get to assume that a person who chooses ExceptT knows how to convert IO (Either a b) to ExceptT IO
09:32:21 <monochrom> So I just have to fill in how to convert exception to IO (Either a b)
09:32:36 <deni> EvanR: because I don't know of a better way to make the thing polymorphic like it's supposed to be...I mean is there another way I can model exceptions regardless of monad?
09:32:51 <EvanR> how would this be more polymorphic?
09:33:15 <EvanR> maybe you didnt explain the whole problem and i dont know what "this" is
09:33:35 <deni> monochrom: wrong types...but anyway... that's why I asking the question mate :D
09:34:04 <EvanR> so far it seems like youre trying to pass in an arbitrary http monad into a docker monad transformer, in which case everything will be able to use IO exceptions
09:34:17 <deni> EvanR: for insance...maybe I want a special kind of handler for tests that won't be in the IO monad but rather in the Maybe monad...or either...I still wanna be able to test the rest of the code
09:34:56 <EvanR> once youre in IO... 
09:35:09 <deni> EvanR: I am aware that IO exceptions with the default handler are possible.... but I wanna handle just the http exceptions...all of them
09:35:30 <deni> EvanR: point is....I'm not in IO always...I can design a fakeHttpHandler that won't be in IO
09:35:30 <EvanR> then you need wrappers for all the http actions
09:35:52 <EvanR> you need an ExceptT version of the http library
09:36:08 <deni> EvanR: why can't I just catch all the exceptions and then throwError ?
09:36:13 <EvanR> which.. will still be in IO
09:36:20 <deni> s /all/all http/
09:36:21 <EvanR> you will do that
09:36:29 <EvanR> for each http library method
09:37:15 <deni> I'm just calling httpLbs and wrapping it in a try/catch.... 
09:37:17 <EvanR> actually nevermind, Handler doesnt imply anything
09:37:20 <deni> I mean in theory that should work
09:37:36 <deni> EvanR: handler doesn't imply IO correct
09:37:56 <EvanR> i dont know what it implies, you didnt say
09:38:13 <EvanR> it seems to imply a monad
09:39:26 <EvanR> type HttpHandler m = m -> IO ...
09:39:27 <EvanR> er
09:39:35 <EvanR> type HttpHandler m = Request -> m ...
09:39:48 <EvanR> but i cant keep guessing at all these things with 2 hrs sleep
09:39:53 <EvanR> zzzzzz
09:41:28 <EvanR> maybe you want type HttpHandler m = Request -> ExceptT HttpError m Something
09:41:38 <deni> EvanR: type HttpHandler m = Request -> (ExceptT HTTP.HttpException m) Response
09:41:44 <deni> ups no
09:41:47 <deni> that's me experimenting just now
09:42:00 <deni> original was type HttpHandler m = Request -> m Response
09:42:16 <EvanR> there you go then
09:42:41 <deni> so I was hoping to get something likes this: http://dpaste.com/0BZZFKW
09:42:42 <EvanR> note you have to agree on the 1 error type
09:42:54 <deni> but that doesn't compile
09:43:04 <deni> EvanR: yeah the one error type will be in the problem domain
09:43:27 <EvanR> you will get an Either by doing runExceptT
09:44:20 <deni> yeah that's what I wnat
09:44:27 <deni> as long as I get the darn thing to compile
09:45:04 <nitrix> Who to contact when Hackage is down?
09:45:50 <deni> EvanR: it's still confusing to me to have to have ExceptT in the HttpHandler type and in DockerT....that's kinda wrong I think 
09:46:28 <EvanR> nitrix: the google cache ;)
09:46:53 <EvanR> deni: its not, the inner monad is ExceptT whatever
09:46:58 <nitrix> I believe we use CloudFlare? Why not enable the "Always On" thing?
09:47:08 <EvanR> to use it in DockerT you will need to lift
09:47:34 <EvanR> :t lift
09:47:36 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
09:47:44 <EvanR> welcome to transformer hell
09:48:27 <EvanR> the reason i dont like these "monad stacks" is the same reason i was complaining earlier about a fixed hierarchy of program data
09:48:48 <EvanR> you pick an ordering, but the ordering isnt really the point
09:49:05 <EvanR> (sometimes)
09:50:18 <deni> EvanR: yeah it's complaining here about not being lifter: http://dpaste.com/1YQPTEP
09:51:09 <EvanR> you have to lift
09:52:01 <EvanR> :t catch
09:52:02 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
09:52:48 <EvanR> nevermind, in the code you pasted the issue is that throwError is not an IO action
09:53:37 <EvanR> nevermind, in the code you pasted httpLbs request manager is not an ExceptT action
09:53:55 <EvanR> :t liftIO
09:53:56 <lambdabot> MonadIO m => IO a -> m a
09:56:33 <deni> EvanR: dspaste.com/1XHGR1E
09:56:44 <xplat|work> EvanR: the problem is in general it makes a difference which order you stack these things
09:56:51 <deni> I saw this one before..... have no idea what i means
09:56:54 <EvanR> broken link
09:57:40 <EvanR> xplat|work: in general yes, but thats now how people want it to be, they want to add effects alacarte, and also the interface between each level is insane (at least you can hide it)
09:57:48 <xplat|work> e.g. does backtracking revert your state, or does it keep the state you last set?
09:58:10 <deni> EvanR: http://dpaste.com/1XHGR1E
09:59:28 <xplat|work> the answer depends on if you have LogicT (StateT s m) or StateT s (LogicT m)
09:59:43 <deni> EvanR: this is the code: http://dpaste.com/22W8G0G
09:59:48 <xplat|work> and all the wanting in the world won't make two different things be the same thing
10:00:01 <EvanR> deni: ..... paste the type definitions
10:00:39 <xplat|work> the usual solution in 'a la carte' systems means which one you get depends on what context you run the code in
10:00:56 <EvanR> yes but people who want "7 global variables, exceptions, IO, and commands to brew coffee" wont be using LogicT or care about this
10:01:23 <xplat|work> the same issue happens with exceptions
10:02:08 <EvanR> does it?
10:02:51 <xplat|work> if you use (ReaderT (IORef s)) IO for state and use IO exceptions, your state survives exceptions
10:03:08 <deni> EvanR: http://dpaste.com/17P3YPS
10:03:39 <EvanR> deni: also the parens in the type are redundant
10:03:57 <xplat|work> if you use (StateT s IO) and IO exceptions, exceptions revert state to the beginning of the block the handler was attached to
10:05:29 <xplat|work> if you use EitherT e (StateT s m) then state survives, if you use StateT s (EitherT e m) it resets
10:06:44 <deni> EvanR: the linter is hinting at that I think...but that's not that important now
10:08:51 <EvanR> deni: it is saying that something thinks IOExceptions are expected somewhere
10:09:03 <xplat|work> in 'effect handler' systems, then, whether state survives exceptions or not depends whether the exception handler or the 'reference handler' for the global variable is higher up the call stack
10:09:08 <EvanR> so it must have to do with the definition of DockerT or some type not shown
10:09:35 <deni> EvanR: should I be using throwE instead of throwError?
10:09:42 <EvanR> :t throwE
10:09:43 <lambdabot>     Not in scope: ‘throwE’
10:09:43 <lambdabot>     Perhaps you meant one of these:
10:09:43 <lambdabot>       ‘throw’ (imported from Control.Exception),
10:09:47 <EvanR> no idea what that is
10:10:08 <deni> yeah and hackage is down so I can't link to it
10:10:12 <kahn> throwE is in Control.Monad.Trans.Except
10:10:14 <EvanR> your code is assuming everything we said and pasted, so you need to check the code you didnt tell us about
10:10:18 <kahn> https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-Except.html
10:10:57 <EvanR> o_O yet another error monad transformer
10:11:03 <EvanR> with the same name
10:11:25 <deni> EvanR: yeah no idea...the error is pointing to the lines I pasted
10:11:28 <deni> no idea why
10:11:44 <EvanR> its because you used DockerError when IOException was expected
10:11:56 <EvanR> the question is why IOException is expected
10:12:31 <xplat|work> if you use 'throw' then an IOException is expected
10:12:47 <xplat|work> using 'throwE' might work actually
10:13:01 <EvanR> no hes using throwError
10:13:33 <deni> xplat|work: EvanR it's maybe because catch is from Control.Exception
10:13:53 <deni> no idea....giving up for now....will revisit later. thanks for your help!
10:13:56 <EvanR> :t catch
10:13:57 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
10:14:11 <EvanR> :t throwError
10:14:13 <lambdabot> MonadError e m => e -> m a
10:14:19 <EvanR> two different e, dont see an issue
10:17:47 <LordBrain> is there a mirror of hackage?
10:18:35 <kadoban> stackage is a mirror of … some/most of it.
10:18:52 <hpc> i wish there was a hackage mirror at egakcah.leksah.org
10:22:44 <Lovepon> @src nub
10:22:44 <lambdabot> nub = nubBy (==)
10:22:44 <lambdabot> --OR
10:22:44 <lambdabot> nub l = go l []
10:22:44 <lambdabot>   where go []     _       = []
10:22:44 <lambdabot>         go (x:xs) ls
10:22:46 <lambdabot>             | x `elem` ls = go xs ls
10:22:48 <lambdabot>             | otherwise   = x : go xs (x:ls)
10:22:59 <Lovepon> @src nubBy
10:22:59 <lambdabot> nubBy eq []     = []
10:22:59 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:26:49 <LordBrain> what is the remote-repo line for my cabal config corresponding to the latest stackage lts?
10:27:23 <LordBrain> i tried remote-repo: stackage:http://www.stackage.org/stackage/604a3649795771f6dd8b80bfd4eeb748e1d97599 but got a 404
10:28:56 <LordBrain> or nightly, whatever
10:29:01 <LordBrain> i just need something while hackage is down
10:29:44 <statusbot> Status update: The hackage server is in an out of memory condition. We're investigating. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5720f6effe92599160002a31
10:30:22 <hexagoxel> LordBrain: lts defines what version of packages to use. it has nothing to do with the remotes used to download any actual package contents. i am not aware that stackage does any mirroring.
10:32:06 <LordBrain> it does
10:32:19 <LordBrain> i got it working with http://www.stackage.org/lts
10:32:22 <forze> I'd like to go from [[String]] to String - is there anything better than calling join|concat twice? I'd like something like fix (++) but the types don't allow it
10:33:58 <LordBrain> there's a function called concat
10:34:00 <LordBrain> :t concat
10:34:01 <lambdabot> Foldable t => t [a] -> [a]
10:34:44 <LordBrain> :t map conat
10:34:45 <lambdabot>     Not in scope: ‘conat’
10:34:46 <lambdabot>     Perhaps you meant one of these:
10:34:46 <lambdabot>       ‘concat’ (imported from Data.List),
10:34:51 <LordBrain> oops
10:34:54 <forze> LordBrain,  yes but that goes only as far as one layer no?
10:34:55 <LordBrain> you get the idea anyway
10:35:15 <forze> you need to do: concat  (concat xs)
10:35:23 <ggVGc> :(( hackage down?
10:35:27 <LordBrain> yeah
10:35:54 <forze> LordBrain, I guess the the other way to pose the question, is there any flatten function? 
10:36:08 <cocreature> forze: nope
10:36:54 <geekosaur> forze: try to construct a type for a hypothetical flatten function
10:36:54 <jle`> there's catTwice = concat . concat, i suppose
10:37:12 <mnoonan> is there a way to mash two traversables into one, so you could do concat . mash?
10:37:51 <Hafydd> mnoonan: what would be mash (Just 1) (Just 2)?
10:38:50 <Hafydd> Or do you mean it would be Traversable t => t (t a) -> t a?
10:39:35 <mnoonan> I was thinking Traversable t, Traversable t' => t (t' a) -> t'' a, but you're right that I hadn't thought through t'' :)
10:40:10 <mnoonan> maybe t (t' a) -> [a] though
10:40:42 <Hafydd> The latter would certainly be possible.
10:41:02 <jle`> :t foldMap toList
10:41:03 <lambdabot>     Ambiguous occurrence ‘toList’
10:41:03 <lambdabot>     It could refer to either ‘Data.Foldable.toList’,
10:41:03 <lambdabot>                              imported from ‘Data.Foldable’ at /home/lambda/.lambdabot/State/L.hs:88:1-20
10:41:12 <jle`> :t foldMap Data.Foldable.toList
10:41:13 <lambdabot> (Foldable t, Foldable t1) => t (t1 a) -> [a]
10:41:38 <Hafydd> t (t a) -> t a wouldn't be possible either, because it would require the size/shape of the structure to sometimes change.
10:41:50 <Hafydd> It wouldn't work for a fixed-length list, for example.
10:44:10 <hexagoxel> LordBrain: can you post a download link for any package from stackage?
10:44:53 <Iceland_jack> > let f='.';o c(x:y)=x:c y;z c(x:y)=f:c y;p n='p':ap fix p(o.n)in f:f:p z
10:44:54 <lambdabot>  "..pp.p.p...p.p...p.p...p.....p.p.....p...p.p...p.....p.....p.p.....p...p.p....
10:45:05 <forze> geekosaur, it would be "easy" if I could pattern match on the input types, which I don't think you can do, but essentially as long as `a` supports (++) in [a] you can use recursion, no?
10:45:06 <LordBrain> i'll see what i can do, give me a random package name
10:45:47 <Iceland_jack> > let f='.';o c(x:y)=x:c y;z c(x:y)=f:c y;p n='p':ap fix p(o.n)in zip [0..] (f:f:p z)
10:45:48 <lambdabot>  [(0,'.'),(1,'.'),(2,'p'),(3,'p'),(4,'.'),(5,'p'),(6,'.'),(7,'p'),(8,'.'),(9,...
10:46:10 <hexagoxel> LordBrain: ace
10:46:31 <forze> ;t mash
10:46:35 <forze> :t mash
10:46:36 <lambdabot>     Not in scope: ‘mash’
10:46:36 <lambdabot>     Perhaps you meant ‘mask’ (imported from Control.Exception)
10:48:00 <LordBrain> hexagoxel, http://www.stackage.org/lts/package/ace-0.6.tar.gz
10:49:51 <LordBrain> you'd need the version number, but other than that
10:50:29 <LordBrain> i guess you grab the version number from an index file somewhere
10:50:43 <hexagoxel> LordBrain: oh, neat! that is really good to know. but cabal-install probably won't cooperate, which is a shame.
10:51:11 <hexagoxel> thx
10:51:41 <LordBrain> i don't know why you say that it wont cooperate, i just added the remote-repo line to my config and remarked out hackage for now
10:52:27 <LordBrain> it would be nice if we could tell cabal to only use hackage when we are making sandboxes, and otherwise use stackage
10:52:31 <cocreature> see https://www.fpcomplete.com/blog/2015/03/hackage-mirror
10:53:40 <hexagoxel> ah, `cabal update` aborts the updating of the index for stackage when the error for hackage appears? wtf.
10:53:43 <LordBrain> oh great
10:53:57 <hexagoxel> so you _need_ to comment out hackage..
10:54:03 * hexagoxel did not expect such
10:54:13 <LordBrain> i didnt know about that mirror, cocreature just posted
10:54:30 <LordBrain> remote-repo: hackage.fpcomplete.com:http://hackage.fpcomplete.com/
10:54:46 <LordBrain> that gives a working mirror of hackage
10:57:31 <jle`> Iceland_jack: interesting
10:59:24 <infinity0> is there a quicker way of writing (\x -> x - 1)
10:59:29 <LordBrain> (-1)
10:59:35 <LordBrain> (subtract 1)
10:59:41 <LordBrain> sorry forgot about that little exception
10:59:46 <infinity0> heh
10:59:47 <glguy> infinity0: subtract 1
10:59:51 <infinity0> thanks :)
11:00:40 <LordBrain> the frege compiler actually uses spacing to distinguish
11:01:41 <LordBrain> so (- 1) is not (-1) in frege... or something like this, i think
11:02:36 <montanonic> infinity0: pred
11:02:40 <montanonic> > pred 3
11:02:41 <lambdabot>  2
11:02:59 <kadoban> The opposite of pred should be alien
11:02:59 <infinity0> montanonic: ah, very nice, thanks!
11:03:34 <infinity0> #haskell, crowd-sourced minimiser for komolgorov complexity
11:03:39 <montanonic> infinity0: pred works on any data that is an instance of Enum. It, of course, gets the predecessor of that value.
11:03:42 <LordBrain> i think subtract 1 is more readable
11:04:18 <LordBrain> but thats only because i so rarely use pred  that i forget it exists
11:04:36 <kadoban> Yeah I usually forget what succ and pred are called
11:10:20 <infinity0> is there a way to define a constraint alias? like instead of doing '(Monoid k, Ord k, Enum k) =>' I can alias it to 'EMonoid' or something
11:11:09 <infinity0> oh looks like it doesn't exist yet https://wiki.haskell.org/Context_alias
11:11:13 <kadoban> infinity0: Within a restricted domain you could use ScopedTypeVariables I tihnk it's called
11:11:25 <cocreature> infinity0: yep if you enable ConstraintKinds you can make a type synonym for it
11:11:28 <kadoban> Like if it's all in one big definition, with several smaller things.
11:11:29 <geekosaur> I think you can do that with some extensions currently?
11:11:33 <kadoban> Ah
11:11:35 <infinity0> ah ok i'll take a look thanks
11:11:58 <geekosaur> right, ConstraintKinds is what I was thinking of
11:12:09 <xplat|work> you can use 'type' to define context aliases if you have ConstraintKinds turned on
11:13:03 <xplat|work> so like 'type EMonoid k = (Monoid k, Ord k, Enum k)'
11:13:16 <xplat|work> you can't use it in deriving clauses tho
11:17:46 * geekosaur added a reference to that wiki page
11:21:29 <Draggor> http://imgur.com/CwxcYIh
11:21:31 <Draggor> err
11:21:33 <Draggor> wrong channel, sorry
11:26:40 <ocramz> is Hackage down?
11:26:51 <ocramz> "502 bad gateway"
11:26:53 <hexagoxel> ocramz: yes
11:26:57 <ocramz> ah ok
11:27:13 <hexagoxel> <statusbot> Status update: The hackage server is in an out of memory condition. We're investigating. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5720f6effe92599160002a31
11:27:34 <hpc> have they tried turning it off and on again? ;)
11:28:33 <hexagoxel> it is/was in a restart loop, in fact.
11:29:16 <hpc> :P
11:29:29 <hexagoxel> (but i am no admin; just quoting one line from -infrastructure)
11:32:02 <NingaLeaf> Well I guess I have to apologize to the local network admin accusing him of blocking Hackage
11:42:26 <darkmercenary> hello, if i have a function f = \x y z -> x + y + z. how can i write a function g such that i can do ... let result = g something = x y z .... f (result) ... f x y z
11:43:36 <darkmercenary> i dont want to do f = \tup -> let x = fst tup, y = snd tup, z = third(u get the idea) tup in x + y + z
11:43:44 <darkmercenary> where g would return a tuple
11:44:30 <fizruk> darkmercenary: you can define f = \(x, y, z) -> x + y + z, no?
11:44:35 <hiptobecubic> How does one properly test things like response handlers? In python we use mocks and stuff all over the place
11:45:44 <darkmercenary> o
11:45:55 <darkmercenary> ok great thanks
11:46:00 <darkmercenary> x.x
11:46:25 <simpson> hiptobecubic: There's a couple unit-testing frameworks, and some of the HTTP stuff out there is designed to work well with some of the frameworks.
11:47:36 <MichaelK> Hi, is there a way to force a library to export something (without modifying the source)? I want to use a foreign function defined in the unix package, but it's not exported..
11:49:06 <ocramz> darkmercenary: in general you can pattern match against type constructors, be it a list constructor, a tuple as in this case, a custom type constructor like e.g. `Left` in `data W a = Left a | Right a` ...
11:51:38 <hiptobecubic> MichaelK, pretty sure no. That's what exporting is for.
11:52:35 <MichaelK> hiptobecubic: then I'd have to make my own branch of the package, patch it, and require that in my library? 
11:52:43 <hiptobecubic> I believe so.
11:54:57 <MichaelK> hiptobecubic: that's sensical, but annoying
11:56:43 <hiptobecubic> MichaelK, it's one of those "better in the long run" kind of annoyances
11:56:54 <hiptobecubic> at least, that's what i'm told :)
11:57:51 <MichaelK> hiptobecubic: I figured. but then I'm faced with annoyance that doesn't seem better in the long run at all, hackage being down..
12:00:33 <sinelaw> jophish: which typechecker are you writing?
12:00:40 <emmanuel`> Hello there. I have a type signature that looks like "rowElimination :: Num a => TestRows a -> Writer Rank (ValidRows a)" and I want to be able to extract the (ValidRows a) to use within the ongoing computation. Is it possible to extract that part while still using the Writer Monad only?
12:06:41 <verement> emmanuel`: rowElimination testRows >>= \validRows -> …
12:09:11 <Zemyla> It really strikes me how much I depend on Hackage docs while doing Haskell.
12:10:16 <emmanuel`> verement: That makes sense. Lol. I was just considering if I should use the WriterT monad transformer, and wrap the ValidRows in a State Monad. That clearly would have been overkill.
12:17:04 <scshunt> Zemyla: yeah
12:17:19 <scshunt> Zemyla: I really wish there was a good way to like download a hackage or something
12:17:22 <scshunt> especially when working with stack
12:19:14 <hsk3> In a monad, does >> always do the same thing as *> ?
12:19:29 <CaleNYC> yeah, those are the same
12:19:58 <hsk3> CaleNYC: so i guess this follows from the monad and applicative laws.
12:20:06 <hsk3> that this always holds without exception (for valid monads)
12:20:22 <ryantrinkle> CaleNYC: it's a brand new Cale!
12:20:23 <scshunt> yep
12:20:30 <CaleNYC> Also, the laws that the Applicative structure actually agrees with the Monad structure
12:20:32 <scshunt> ryantrinkle: and the sun is high!
12:20:36 <CaleNYC> ryantrinkle: :D
12:20:43 <ryantrinkle> scshunt: indeed :)
12:20:45 <hsk3> hey wait...
12:20:46 <hpc> btw, you don't need to caveat "for valid monads" - if an instance breaks the laws, it doesn't count for reasoning about semantics
12:20:47 <scshunt> CaleNYC: where are you normally?
12:20:51 <CaleNYC> ryantrinkle: I'm at Ali's place
12:20:56 <hsk3> ryantrinkle: you're the link shortener guy!!
12:20:58 <CaleNYC> I'm normally in Brantford, Ontario
12:20:58 <hsk3> famous
12:20:59 <hpc> much like the unsafe* suite of definitions gets ignored, and sometimes seq
12:21:00 <ryantrinkle> CaleNYC: cool
12:21:09 <scshunt> CaleNYC: whoa, that's not far from me
12:21:12 <scshunt> <- Kitchener
12:21:15 <ryantrinkle> hsk3: yep! i'm afraid it's quite bitrotted, though!
12:21:17 <CaleNYC> Ah, cool
12:21:26 <hsk3> hehe ok
12:21:29 <CaleNYC> I went to university in Waterloo
12:21:50 <ryantrinkle> hsk3: gotta go, but join #reflex-frp if you wanna see some new(er) web stuff :)
12:21:57 <ryantrinkle> ttyl
12:23:01 <hsk3> CaleNYC: But interestingly, <* has nothing similar in monad
12:23:31 <hsk3> only *> has the similar (same) >>
12:23:38 <hsk3> <*  has no such counterpart
12:23:55 <CaleNYC> Right, for no particular reason.
12:29:48 <jle`> there's a good reason, actually :O
12:30:07 <jle`> it's not obvious how (<<) would behave
12:30:07 <scshunt> CaleNYC: as did I
12:30:28 <kadoban> jle`: Like (<*) ?
12:30:29 <jle`> because (=<<) = flip (>>=), it's reasonable to assume that (<<) = flip (>>)
12:30:56 <jle`> x >>= f = f =<< x, so it's reasonable to think that x >> y = y << x
12:31:05 <jle`> as in, >> is to >>= as << is to =<<
12:31:22 <kadoban> Seems reasonable, right?
12:31:33 <jle`> yeah. but it's also reasonable to think that it would be equal to (<*>)
12:31:37 <jle`> er, (<*)
12:31:50 <jle`> (>>) = (*>), so one could expect (<<) = (<*)
12:31:59 <kadoban> Oh right they're not the same are they
12:32:05 <jle`> so these are two contradictory implementations, yeah
12:33:54 <kadoban> > (flip (>>)) [1,2,3] [4,5]
12:33:56 <lambdabot>  [1,2,3,1,2,3]
12:34:00 <kadoban> > [1,2,3] <* [4,5]
12:34:02 <lambdabot>  [1,1,2,2,3,3]
12:34:03 <kadoban> :-/
12:35:33 <jle`> if you're following along in ghci, compare putStrLn "hello" <* putStrLn "world" with flip (<<) (putStrLn "hello") (putStrLn "world")
12:35:42 <jle`> the latter is putStrLn "world" >> putStrLn "hello"
12:36:00 <kadoban> Hmm, yes, better example.
12:36:09 <mauke> it's fine if your monad has no effects
12:36:14 <mauke> ban effects!
12:36:25 <jle`> "commutative monads" or something like that
12:36:46 <jle`> as long as they have 'commutative' effects, i've heard people say
12:36:52 <jle`> ie, Maybe
12:36:57 <jle`> Identity
12:37:11 <jle`> um...those are the only two I can think of off of the top of my head
12:37:24 <mauke> Reader
12:37:24 * geekosaur suspects that would be ineffective...
12:37:38 <jle`> 'Maybe' can be considered effectful
12:37:52 <bitemyapp> partiality is an effect
12:37:54 <jle`> but its effects are commutative so it's cool
12:38:27 <jle`> we cool
12:42:40 <darkmercenary> im working with gigantic records, all of the fields are "Maybe something", is there a easy way to write emptyThing = Thing Nothing Nothing Nothing ...
12:42:54 <jle`> i suppose Writer w over a commutative monoid w is a commutative monad
12:43:18 <jle`> so Writer (Sum a), Writer Any, Writer All ...
12:45:28 <kadoban> darkmercenary: You could use record syntax and then just write it once and give it a name, like defThing = Thing Nothing Nothing Nothing, etc.  Then use  defThing {one = Just Blah, two = Just OtherSomething} instead of Thing directly.
12:46:08 <mauke> might be possible with Data.Default and the deriving Generic stuff
12:50:34 <fr33domlover> did something happen to Hackage?
12:50:41 <fr33domlover> I get 502 Bad Gateway
12:51:15 <kosmikus> fr33domlover: https://www.reddit.com/r/haskell/comments/4gppm8/ann_hackagehaskellorg_is_down/
12:51:31 <fr33domlover> kosmikus, thanks
13:03:23 <osa1> is hackage down?
13:03:54 <geekosaur> [27 19:50] <kosmikus> fr33domlover: https://www.reddit.com/r/haskell/comments/4gppm8/ann_hackagehaskellorg_is_down/
13:05:14 <jle`> i guess i shouldn't have uploaded my package that generated 5TB of hackage documentation using TH
13:05:48 <CaleNYC> jle`: hahaha, are you serious?
13:06:19 <jle`> (no >_>)
13:07:30 <fr33domlover> Is it possible, using stack sdist and/or cabal upload, to include generated docs valid for Hackage?
13:07:56 <fr33domlover> some of my packages haven't got their docs made for long time, I don't mind generating locally if it helps
13:08:58 <jle`> it's possible to upload generated docs to hackage
13:09:19 <jle`> it's one of the options in the maintainer's page for a package :)
13:09:30 <jle`> i think there were a couple of blog posts describing a workflow
13:10:15 <fr33domlover> ah cool, i'll dig tomorrow and try to come up with the commands I need
13:10:56 <fr33domlover> I'm just not sure stack has feature parity with cabal-install on this, but i'll look for info :)
13:11:35 <bennofs> fr33domlover: recent cabal-install should have an option to genertae a docs tarball
13:12:48 <bennofs> fr33domlover: or perhaps that version is only in HEAD and not yet released? idk
13:14:14 <fr33domlover> bennofs, but i build with `stack` these days, not sure I want to build everything with cabal-install just for docs (unless it can do so cleanly without filling my home dir with all the extra garbage)
13:18:45 <bennofs> fr33domlover: ah, it's not yet in any released version of cabal-install anyways 
13:20:22 <bennofs> fr33domlover: you might want to take a look at https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh to see what magic flags you need to pass to haddock to make crosslinking work properly for the uploaded haddocks
13:20:49 <fr33domlover> bennofs, cool thanks!
13:34:15 <nitrix> Any reason why ZipList doesn't have a monoid instance?
13:34:48 <nitrix> I haven't worked out the laws, but it sure feels like it :/
13:36:36 <enthropy> nitrix: I think it's because they couldn't decide between: (<>) == (++) -- dropping the newtypes; Or (<>) could be liftA2 (<>)
13:39:35 <nitrix> > [1,2,3] <> [4,5,6]
13:39:36 <lambdabot>  [1,2,3,4,5,6]
13:40:15 <nitrix> enthropy: Isn't the (++) behavior for lists though? ZipList would instinctively have the "pairing" behavior :/
13:40:17 <jle`> yeah, zipWith (<>) with repeat mempty as mempty is a reasonable instance to expect from something that calls itself ZipList i guess
13:40:24 <jle`> but people might be surprised
13:47:53 <jle`> but people might be surprised
13:49:01 <athan> ZipList doesn't have an Alternative instance, does it?
13:49:41 <athan> nitrix: There isn't an Alternative instance for ZipList
13:49:52 <athan> where the alternative instance for [] _is_ ++ :)
13:49:54 <obadz> is there a way to tell ghc-mod to look for modules into globally installed packages rather than in cabal file? (when there is no cabal file…)
13:49:55 <athan> (I think)
14:03:28 <akegalj> is hackage down?
14:04:05 <Clint> akegalj: http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5720f6effe92599160002a31
14:04:43 <akegalj> Clint: thanks
14:06:40 <athan> Does ST make garbage collection.. uh... easier?
14:07:19 <athan> like can I obliterate an STRef, and thus remove whatever state was being allocated?
14:07:40 <c_wraith> athan: actually, STRefs make gc harder
14:07:43 <athan> D:
14:07:47 <athan> cripes
14:08:29 <hpc> ghc mostly manages
14:09:30 <hpc> ST actions are generally short, and refs themselves generally contain immutable values so there's not a whole lot of reasoning power lost for optimization
14:09:48 <hpc> (unless you're that guy who puts refs in refs)
14:10:21 <montanonic> hpc: why would ...
14:10:35 <montanonic> for porting over algorithms from C?
14:11:54 <Hijiri> You could have a mutable tree or something
14:12:06 <Hijiri> though if you're using a tree an immutable one would probably have the same asymptotics
14:12:23 <athan> hpc: ._.
14:14:22 <EvanR> refs in refs in refs etc... you get something like C
14:14:22 <llinguini> Hackage broken for you guys?
14:14:29 <llinguini> I can't seem to check things there
14:14:38 <llinguini> Nginx seems to be dead for them
14:14:41 <EvanR> however, ghc isnt designed to make that kind of things as fast as using immutability
14:14:50 <EvanR> down for everyone
14:14:59 <hydraz> llinguini: I'm getting a 502 on everything but the landing page
14:15:28 <EvanR> maybe their acid state ran out of memory
14:15:53 <llinguini> know of any other resource pages?
14:17:27 <tombert> is hackage down right now?  I'm gtting 502 errors when searching for a package
14:17:42 <llinguini> tombert: Yeah it's been down since today morning.
14:17:51 <llinguini> not sure why lol
14:18:31 <tombert> ah
14:18:42 <bernalex> tombert: there are numerous mirrors.
14:18:46 <tombert> I never bother questioning this, but who maintains hackage?
14:18:55 <bernalex> haskell-infra.
14:19:02 <bernalex> there's #haskell-infra fwiw.
14:19:09 <scshunt> oh
14:19:26 <scshunt> bernalex: no there isn't
14:19:34 <hydraz> bernalex: no there ain't
14:19:40 <bernalex> I guess it might be something else -- idr.
14:19:51 <bernalex> here's a mirror: https://www.fpcomplete.com/blog/2015/03/hackage-mirror
14:20:16 <bernalex> you need to comment out remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
14:25:28 <tombert> I could use something like stackage
14:25:44 <bernalex> tombert: stackage is up, yes
14:43:59 <verement> #haskell-infrastructure
15:09:31 <drostie> Someone on here surely knows -- there exists something which is just like lambda calculus but lacks variable names (each variable is added to a stack, each variable reference is just an integer saying how deep on the stack to look). What the heck is that thing called?
15:10:10 <peddie> drostie: are you talking about de Bruijn indices?
15:11:02 <drostie> @peddie: YES! thank you!!
15:11:02 <lambdabot> Unknown command, try @list
15:13:30 <peddie> drostie: you're welcome, and @ is for slack and twitter, not IRC :P
15:20:24 <dolio> There are also de Bruijn levels.
15:20:54 <troydm> what's wrong with http://hackage.haskell.org/packages/search?terms=wai
15:20:59 <troydm> ??
15:21:16 <puregreen> troydm: https://status.haskell.org/
15:21:20 <puregreen> Hackage is down
15:21:28 <troydm> ahh, thx puregreen 
16:08:23 <sizur> hackage down?
16:16:16 <geekosaur> sizur, yes
16:16:44 <Lokathor> so i made a thing, https://github.com/Lokathor/sdl2-hs-windows
16:17:03 <Lokathor> for folks that want sdl with haskell on windows, but don't have it easy to set up with stack yet
16:17:07 <Lokathor> probably a small audience
16:31:00 <RyanGlScott> Lokathor: I like it!
16:31:15 <RyanGlScott> But speaking as a Windows user, I'm not fond of telling new users to install C software on Windows like that
16:31:15 <Lokathor> did it work right?
16:31:35 <RyanGlScott> I find it's usually must less frustrating to install C libraries via MSYS2
16:31:36 <Lokathor> oh, you mean 7zip? or SDL.dll?
16:32:09 <RyanGlScott> I'm not a heavy stack user, but IIRC, stack encourages you to use MSYS2 on Windows as well
16:32:33 <RyanGlScott> It makes installing sdl2 as easy as "pacman -S mingw-w64-x86_64-SDL2"
16:32:34 <Lokathor> i had no clue that msys2 would act as a package manager and grab software for you
16:32:38 <hpc> i could never get any C depends to work on windows
16:32:58 <RyanGlScott> Lokathor: When you have to work on a spartan host like Windows, MSYS2 is a godsend.
16:33:24 <RyanGlScott> It also has pkg-config, which makes it a lot easier to specify the locations of headers/libraries correctly
16:33:36 <RyanGlScott> Instead of having to pass them in manually via --extra-lib-dirs/--extra-include-dirs
16:33:46 <Lokathor> huh, well the stack file does that, in this case
16:34:02 <RyanGlScott> hpc: To be fair, the GHC linker didn't start working well on Windows till 8.0 :P
16:34:15 <hpc> oh yay
16:34:46 <RyanGlScott> There's still some kinks I'm trying to figure out (e.g., GLFW-b and GLUT are a bit finicky in interpreted code on Windows)
16:34:57 <RyanGlScott> But a LOT of things started working in 8.0, including sdl2
16:35:12 <RyanGlScott> (Both in compiled and interpreted mode)
16:35:16 <Lokathor> RyanGlScott, it appears that pacman will get slightly older versions of the non-core SDL packages
16:35:46 <Lokathor> image, mixer, and ttf
16:36:01 <RyanGlScott> Ah, I didn't know that was a dealbreaker. In that case, carry on :)
16:36:17 <Lokathor> well, the bindings are specific to particular versions.. i'd imagine?
16:36:19 <RyanGlScott> Personally, I'm just happy to get SDL2 to play a beeping tone ;)
16:36:35 <RyanGlScott> Lokathor: I haven't had problems with using the MSYS2 versions.
16:36:35 <Lokathor> i honestly don't know. i haven't tried with pacman, i didn't really know it existed before now
16:37:13 <RyanGlScott> Well, pacman's just the delivery mechanism
16:37:30 <RyanGlScott> The important thing is the MinGW-w64 project
16:37:49 <RyanGlScott> Which gives us all of this tasty C software as native Windows libraries
16:38:11 <Lokathor> I never got into C/C++
16:38:14 <Lokathor> so it's all insanity to me
16:38:44 <RyanGlScott> Well, it also covers more than just C software
16:38:55 <Lokathor> microsoft showed off a new linux compatbility layer recently, so perhaps we can just only build for linux in the future, and then windows folks can run it through the layer
16:38:57 <RyanGlScott> It has Windows-native python, perl, ruby, etc
16:39:59 <RyanGlScott> Interestingly enough, it doesn't distribute GHC itself yet, though
16:40:14 <RyanGlScott> Even though GHC is built on top of a ton of MinGW-w64 software
16:42:03 <Lokathor> https://lokathor.gitbooks.io/haskell-stuff/content/graphics.html :3
16:43:02 <RyanGlScott> It's my hope that that image will become obsolete soon ;)
16:43:20 <Lokathor> on the one hand i agree
16:43:26 <Lokathor> on the other hand it's a quality imaeg
16:44:10 <RyanGlScott> The only one of those libraries that's still a pain to install even with MSYS2 is gloss (due to the GLUT dependency)
16:44:23 <Lokathor> gl doesn't need anything fancy
16:44:27 <RyanGlScott> But I suspect the GLUT package has other problems which make it hard to use at the moment
16:44:27 <Lokathor> just your time
16:44:37 <RyanGlScott> Ah, true. I forgot Windows comes with that by default.
16:44:56 <RyanGlScott> Just not any of the window managers
16:45:04 <Lokathor> of course... having a place to put that opengl context... for that you'll need glut or sdl or somesuch
16:45:08 <Lokathor> yeah
16:47:13 <Lokathor> https://github.com/Lokathor/gl-cube as i recall, this example compiles fairly painlessly
16:47:29 <Lokathor> using GLFW-b
16:47:58 <RyanGlScott> Lokathor: Just beware if you try running GLFW-b in GHCi on Windows... it's been known to segfaut
16:48:06 <RyanGlScott> For reasons that aren't yet clear to me
16:48:14 <Lokathor> oh i never trust ghci mixed with ffi
16:48:35 <Lokathor> it's like they say... two i's don't make a right, but -O3 does
16:48:55 <RyanGlScott> Phyx has been putting a lot of work into making GHCi work well with FFI on Windows
16:49:34 <RyanGlScott> AFAICT, GLUT and GLFW-b are the only two notable C libraries that still don't work in interpreted code
16:49:38 <thoughtpolice> RyanGlScott: the continuous complexity of the work he's doing is kind of amazing.
16:49:39 <RyanGlScott> (As of 8.0)
16:49:50 <thoughtpolice> Phyx for Windows President of GHC 2016.
16:49:56 <thoughtpolice> Or forever, whichever.
16:52:25 <RyanGlScott> thoughtpolice: Is Windows President the title where you get to shout "developers!" at people?
16:54:41 <Lokathor> no
16:54:44 <Lokathor> you can't shout it once
16:54:51 <Lokathor> you must shout it at least 10 times
16:54:59 <RyanGlScott> Ah, that's why they never made me president :(
16:55:19 <hiptobecubic> It has to be a multiple of 4 or the song is ruined.
16:55:35 <amyers> Question about this lpaste: http://lpaste.net/161687  Why is the second one a type error but not the first?
16:55:51 <thoughtpolice> RyanGlScott: Also yes. :)
16:56:18 <Lokathor> :t Data.Vector.Generic.Mutable.write
16:56:19 <lambdabot> (Control.Monad.Primitive.PrimMonad m, Data.Vector.Generic.Mutable.Base.MVector v a) => v (Control.Monad.Primitive.PrimState m) a -> Int -> a -> m ()
16:56:25 <Lokathor> :t Data.Vector.Generic.Mutable.swap
16:56:26 <lambdabot> (Control.Monad.Primitive.PrimMonad m, Data.Vector.Generic.Mutable.Base.MVector v a) => v (Control.Monad.Primitive.PrimState m) a -> Int -> Int -> m ()
16:56:59 <amyers> Lokathor, The only difference I see is a/Int for the last input
16:57:12 <Lokathor> yeah, well you can't write an Int into a vector of t
16:57:16 <Lokathor> it has to be a vector of ints
16:57:40 <amyers> unless I did something really dumb I'm writing a t I just read out
16:57:52 <amyers> with the write call
16:58:03 <Lokathor> oh so you did i suppose
16:58:05 <Lokathor> 0 is the index
16:58:10 <amyers> yup
16:58:48 <Lokathor> well what's the type error GHC says? you should add that to the lpaste probably
16:58:51 <amyers> Just added the error, I forgot that in the original paste
16:59:25 <Lokathor> oh
17:00:18 <Lokathor> yeah i dunno. What i do in this situation is take the type sig off, compile it, ask ghci what the type is
17:00:20 <Lokathor> and then put that on
17:00:44 <amyers> I tried that, I still get the same error.
17:00:59 <Lokathor> :(
17:01:12 * amyers glad it's not just him
17:01:14 <amyers> :p
17:01:45 <amyers> oh well, I only really need swap for what I'm doing
17:01:53 <amyers> I'm really curious to know why though
17:02:15 <Lokathor> oh wiat
17:02:16 <Lokathor> hmm
17:02:30 <Lokathor> mv GV.! 1
17:02:34 <Lokathor> GM.write
17:02:40 <Lokathor> you're mixing your vector operations
17:03:08 <amyers> hrm, okay but ! says it returns an element that's in the vector
17:03:20 <amyers> (!) :: Vector v a => v a -> Int -> a 
17:03:23 <Lokathor> but i don't think it works on mutable vectors
17:03:30 <Lokathor> you need to use GM.read
17:03:40 <Lokathor> x <- GM.read mv 1
17:03:43 <Lokathor> or however it goes
17:04:41 <sizur> I don't understand what's the effect of the ribbon width is in pretty printing
17:04:42 <amyers> huh, okay you're right
17:04:53 <amyers> I thought that would be okay because here Vector is
17:05:03 <amyers> class MVector (Mutable v) a => Vector v a where
17:05:29 <amyers> okay, but that's somewhere else, not in Generic.Mutable
17:05:47 <Lokathor> i think it's cause of how GV.modify works. within the modification function you're working with the mutable form, so you ahve to use mutable versions of the operations
17:06:19 <amyers> Ah, okay that makes more sense
17:06:31 <amyers> the issue isn't that ! wouldn't work, it's that it's not monadic?
17:06:57 <Lokathor> well, it'd be a type error
17:07:16 <Lokathor> V.! doesn't work conceptually because it's not sequenced in with the rest of the reads and writes
17:07:31 <amyers> oh, right!  the thing I'm working with is not the input type
17:08:02 <amyers> well okay wait, not I lost it
17:08:07 <Lokathor> on a normal vector, V.! can happen at any time and it'll always be the same
17:08:17 <amyers> modify :: Vector v a => (forall s. Mutable v s a -> ST s ()) -> v a -> v a 
17:08:19 <Lokathor> but with a mutable vector, GM.read has to happen at the correct moment
17:08:27 <amyers> (!) :: Vector v a => v a -> Int -> a 
17:08:34 <amyers> Conceptually I understand what you're saying
17:08:51 <amyers> Technically I don't understand why the types are disallowing it (though it's obviously a good thing)
17:09:16 <amyers> If the input to the function passed to modify is a Vector v a
17:09:20 <Lokathor> because inside the block that you're passing to modify is the (forall s. Mutable v s a -> ST s ()) part
17:09:22 <amyers> and ! operates on those 
17:09:35 <Lokathor> so you're not using a Vector a, you're using a Mutable v s a
17:09:43 <Lokathor> inside the block
17:09:54 <amyers> oh, dur I was looking at the wrong part of the type signature on modify
17:10:02 <amyers> okay, I'm with you now
17:10:16 <amyers> right, I don't have a Vector v a there
17:10:23 <amyers> I understand now! :)
17:10:28 <amyers> Thanks for the explanation!
17:18:06 <Tertain_> Say you had a function that you wanted to operate on both Maybe, and Either types. Would typeclasses be the best solution for that? I've used typeclasses for this, have trouble with automatic type inference afterwards.
17:18:25 <bitemyapp> Tertain_: come up with something more principled than "Maybe and Either"
17:18:41 <bitemyapp> Tertain_: if it's just "Maybe and Either", then it's actually Either.
17:18:55 <bitemyapp> Either () a ~ Maybe a
17:20:12 <Lokathor> if it's a group of library functions where some use maybe and some use either, i'd just write a "maybeToEither" function once and use it where I needed to, and then go with all Either
17:20:40 <Tertain_> okay, thanks guys
17:22:18 <wedify> ok a new filesystem representation of code, directories are modules and the whole program is the "sum" of the modules
17:22:39 <Lokathor> define "sum" in this context
17:22:57 <wedify> something concurrent  ithink
17:23:08 <wedify> semantics-wise i mean
17:24:09 * wedify vaguely grasping
17:24:45 <wedify> you could define shared variables and each module is also a "thread"
17:25:04 <wedify> so they're indepenent except for the shared values
17:25:44 <wedify> it is weird to think of a module as a thread but i see it as the thread that enters the values
17:25:52 <wedify> the definitions i mean
17:26:02 <wedify> and then is constant
17:26:42 <wedify> i suppose this means i should go review process-algbras
17:28:27 <wedify> i almost grasp temporal logic and how it used in frp programs
17:53:46 <Ohso_> I am about to give up on trying to understand Haskell. I am trying to read some binary data from a file and then print the length, but failing miserably.  :(
17:54:59 <athan> Ohso_: That's because that problem is difficult from a natural deduction perspective :\ I mean, for someone that's not familiar with how strict this language is
17:55:05 <athan> you would have to use a fold
17:56:30 <Ohso_> I was trying:
17:56:45 <Ohso_> myData = BS.readFile "test"
17:56:51 <Ohso_> main = print . BS.length myData
17:57:25 <Ohso_> ...oops forgot also:   import qualified Data.ByteString as BS
17:57:31 <wedify> use '
17:57:45 <wedify> =<<' instead of the composition 
17:58:01 <wedify> i think
17:58:24 <Ohso_> no difference
17:58:57 <Ohso_> well, slightly different error, but the underlying cause is the same I think:  src/Main.hs:11:28:
17:58:59 <Ohso_>     Couldn't match expected type `BS.ByteString'
17:59:01 <Ohso_>                 with actual type `IO BS.ByteString'
17:59:03 <Ohso_>     In the first argument of `BS.length', namely `myData'
17:59:05 <Ohso_>     In the second argument of `(=<<)', namely `BS.length myData'
17:59:07 <Ohso_>     In the expression: print =<< BS.length myData
17:59:12 <ntnt> is there a haskell convention for naming Types whose sole purpose in life is to be a Phantom Type 
17:59:18 <Ohso_> Looks like I have IO ByteString instead of just ByteString
17:59:35 <Ohso_> But I have no idea how to get there from here.
18:01:50 <MichaelBurge> Ohso_: http://lpaste.net/161690
18:02:12 <pavonia> ntnt: I don't think so
18:02:21 <MichaelBurge> Ohso_: You can use '<-' to 'pull from' a monad like IO when inside of a do block.
18:03:26 <wedify> use do syntax. 'do x <- BS.readFile f; print $ BS.length x'
18:10:59 <mpickering> Is there a comprehensive survey of the haskell-like to javascript options availible?
18:15:03 <Ohso_> Hmm, how do I capture the ByteString in a value I can reuse?
18:15:49 <Axman6> myBs <- BS.readFile "filename.txt" <- myBs is a ByteString in the following do block
19:23:10 <linoge> Hi there, if I have a type Maybe Array Maybe Array Maybe Array a, and what I really need is Maybe Array a
19:24:18 <linoge> How do I transform type 1 into 2?
19:24:46 <linoge> I mean, how would you call that operation?
19:26:41 <koz_> Hackage is 502ing me.
19:26:46 <koz_> Is it just me, or is something up with it?
19:26:54 <shanemikel> what's going on with hackage?
19:27:05 <verement> https://status.haskell.org
19:27:05 <koz_> shanemikel: Every time I try to search something on it, it 502s me.
19:27:26 <koz_> Well, there goes *that* bright idea...
19:28:09 <verement> linoge: Maybe :: * → * so I don't quite understand your types
19:29:02 <simpson> linoge: Is that Maybe (Array Maybe (Array Maybe (Array a)))?
19:29:08 <simpson> Or whatever that'd look like.
19:29:42 <shanemikel> I didn't realize it was a Maybe Hackage url
19:34:00 <aweinstock> simpson: the only way to parenthesize that that kind-checks is (Maybe (Array (Maybe (Array (Maybe (Array a))))))
19:34:40 <aweinstock> :t sequence
19:34:42 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
19:34:55 <aweinstock> :t sequence :: [Maybe a] -> Maybe [a]
19:34:56 <lambdabot> [Maybe a] -> Maybe [a]
19:35:05 <aweinstock> :t sequence.sequence
19:35:06 <lambdabot> (Monad t, Monad m, Traversable t, Traversable m) => m (t a) -> m (t a)
19:35:29 <aweinstock> :t mapM sequence
19:35:30 <lambdabot> (Monad m, Traversable t, Traversable t1) => t (t1 (m a)) -> m (t (t1 a))
19:35:45 <aweinstock> linoge: ^ probably something like the above
19:36:03 <aweinstock> linoge: or lenses
19:36:15 <simpson> aweinstock: Ah, I thought that Array had another spot for the type of indices. Nice.
19:37:09 <aweinstock> simpson: I was thinking of (Array :: * -> *), idk if that exists
19:37:40 <verement> Data.Array.Array :: * → * → *
19:37:42 <aweinstock> simpson: but even if it was (Array :: * -> * -> *) (like Data.Map?), Maybe wouldn't fit
19:38:46 <orion> Hackage is down.
19:38:59 <geekosaur> known
19:39:06 <geekosaur> status.haskell.org
19:44:20 <mgsloan> Ja, pretty much been down all day
19:45:15 <MichaelBurge> stackage is still up, so if you're using stack you can still work
19:49:43 <dcoutts_> MichaelBurge, mgsloan: it's up now
19:50:40 <dcoutts_> roll on cabal-1.24, with automatic use of mirrors
19:52:24 <Boney> Is there an easy way to take a Writer w a and make a Writer w m a?
19:52:28 <Boney> err
19:52:36 <Boney> Is there an easy way to take a Writer w a and make a WriterT w m a?
19:53:00 <Clint> Boney: hoist?
19:56:36 <Boney> Clint: I don't appear to have that, looks like it's in Control.Monad.Morph which I also don't have.
19:57:00 <Clint> Boney: you should get it
19:57:41 <orion> Are there any recommendations for when you're using a Reader+IO transformer and you need to make both IO calls and calls to functions within your transformer?
19:58:20 <Clint> orion: liftIO?
19:58:40 <orion> I need to accept a socket, so I need to be in IO, but then I need to call a function foo :: MyApp (...), then I need to make an IO call, then I need ...
19:59:58 <orion> And I need to handle exceptions, but I also need to call functions of the type MyApp (...) within the section where exceptions are caught.
20:01:15 <Boney> ah, it's in libghc-mmorph-dev in aptitude.
20:01:16 <Boney> getting...
20:01:42 <Lokathor> orion, what Cale said
20:02:34 <orion> Cale?
20:02:51 <Lokathor> Clint
20:02:53 <Lokathor> i mean
20:02:54 <Lokathor> >_>
20:03:11 <orion> I realize I need to use liftIO, but the code looks horrendous.
20:03:48 <Lokathor> myFunc :: (MonadIO m, MonadReader m) => Socket -> m ()
20:04:17 <Lokathor> like this, https://github.com/Lokathor/ireniko/blob/master/src/Control/IRC.hs#L51
20:05:49 <orion> Oh, neat.
20:09:50 <Boney> Clint: Cheers, that's worked.
20:10:36 <GLM> How can I convert a value of type IO [a] to [IO a]?
20:11:08 <Lokathor> do you mean... the other direction?
20:11:11 <Clint> Boney: enjoy
20:11:14 <Lokathor> because the other direction is easy
20:11:25 <simpson> Or at least well-known; `sequence`.
20:11:29 <simpson> :t sequence
20:11:30 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
20:12:14 <Lokathor> but IO is not Traversable so sequence can't go the other direction
20:12:33 <roboguy`> GLM: IO [a] to [IO a] is impossible. You'd have to "unexecute" IO actions
20:12:58 <MichaelBurge> GLM: I don't think it's possible. Otherwise you could turn IO LinesInAFile into a line-counting function that didn't need to actually read the file.
20:13:08 <GLM> I'm attempting to simulate getting a list of values from something external like a database. Wouldn't that be in an IO [a]?
20:14:24 <roboguy`> GLM: if you're actually doing it, it would. You're simulating it though?
20:14:30 <MichaelBurge> GLM: That would work. But why do you need a [IO a]?
20:14:45 <linoge> Lists are monads?
20:14:57 <geekosaur> yes
20:15:27 <GLM> I'm trying to simulate it with return because I'll eventually need to call external services and I want it to type check
20:15:34 <MichaelBurge> > [1,2] >>= (\x -> [5,10])
20:15:36 <lambdabot>  [5,10,5,10]
20:15:36 <linoge> So List (List a) is possible right?
20:16:12 <GLM> linoge: Yeah
20:17:22 <dfeuer> And you keep on trying till you run out of cake.
20:18:20 <linoge> I think I just followed a very stupid path of thinking
20:18:45 <linoge> [1, 2, [3, 4]] would not be a List (List a) right?
20:19:32 <simpson> > do {x <- [1,2]; y <- [3,4]; return (x, y);} -- linoge 
20:19:33 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
20:20:00 <dfeuer> :t [1,2, [3,4]]
20:20:01 <lambdabot> (Num t, Num [t]) => [[t]]
20:20:04 <kadoban> linoge: No, it'd be a type error almost certainly.
20:20:15 <dfeuer> That would be *problematic*.
20:20:18 <MichaelBurge> linoge: Nope. You could do it with some kind of 'data Value = VInt | VList [Value]'. If you write a Num and IsList instance, it might actually compile.
20:20:36 <dfeuer> Because  Num [t] is essentially unsatisfiable.
20:20:49 <shanemikel> any idea why `\_ -> Nothing` is working in a place where (const Nothing) wont?
20:21:01 <dfeuer> MichaelBurge, that sounds super-shady and unpleasant.
20:21:23 <MichaelBurge> shanemikel: My first guess is monomorphism restriction
20:21:30 <shanemikel> yeah, I just enabled it
20:21:31 <shanemikel> no dice
20:21:35 <zalatovo> linoge: although I suppose it would satisfy the type List (List (List (List (
20:21:42 <dfeuer> const :: a -> b -> a
20:21:51 <geekosaur> linoge, List (List a) is just [[a]]
20:22:19 <zalatovo> nvm what I said doesn't make sense
20:22:29 <dfeuer> shanemikel, can you show the example?
20:23:16 <statusbot> Status update: Hackage is now back online, after recovering from an out of memory error in the underlying database. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5720f6effe92599160002a31
20:23:18 <linoge> Yeah, I thought I discovered something back there c;
20:25:05 <shanemikel> in the function `arithmeticThing'`
20:25:07 <shanemikel> http://lpaste.net/9011708373401337856
20:25:12 <shanemikel> at the bottom
20:26:13 <orion> Lokathor: What's your strategy for handling IO exceptions?
20:26:13 <MichaelBurge> shanemikel: My second guess is that you would need ScopedTypeVariables to constrain the a in const :: a -> b -> a to be the same as as the output variable.
20:26:40 <tippenein> I'm using mzero :: Either String FileInfo as a placeholder for a value, and it essentially acts like a nil. Is this just bad practice or am I missing something about mzero?
20:27:03 <kadoban> :t mzero
20:27:04 <Lokathor> orion, "never have them what are you insane that's crazy"
20:27:04 <lambdabot> MonadPlus m => m a
20:27:05 <shanemikel> yeah, I thought that, but I didn't want to go with my gut
20:27:24 <tippenein> http://lpaste.net/161341
20:27:28 <shanemikel> playing with a lot of funny extensions and ideas here that I haven't before
20:27:33 <tippenein> for context on what I'm doing
20:27:38 <Lokathor> but honestly, I don't think I have "try" anywhere in the codebase of ireniko, so the first IO exception will probably crash the entire process
20:27:40 <kadoban> > mzero :: Either String Int
20:27:42 <lambdabot>  Left ""
20:27:42 <Lokathor> but!
20:27:45 <Lokathor> ireniko, date
20:27:45 <ireniko> It's the 44th of Discord, 3182
20:28:01 <Lokathor> it can keep track of the time well enough
20:28:43 <MichaelBurge> shanemikel: Oh, in your case I think it's simpler than that. $ has a lower procedence than parentheses
20:29:52 <dfeuer> MichaelBurge, yeah, just got there!
20:30:15 <shanemikel> there aren't any parens on that commented line, though
20:30:37 <dfeuer> shanemikel, yeah, so there should be a $ like on the other one.
20:30:57 <MichaelBurge> shanemikel: The first line says '(a `try` b) $ c'. While the second says ''a `try` (b $ c)"
20:31:04 <shanemikel> ahh
20:32:11 <shanemikel> thanks
20:32:40 <dfeuer> shanemikel, your IllegalOperandException is really just a clunky version of String. You'd generally be better of with String, unless you really want to avoid sharing in the error message (not likely).
20:34:22 <thimoteus> what does the i in ghci stand for?
20:34:27 <geekosaur> interactive
20:34:32 <thimoteus> thanks geekosaur 
20:34:33 <geekosaur> it's short for "ghc --interactive"
20:34:42 <MichaelBurge> I always thought it was interpreter
20:35:34 <shanemikel> The idea is, I'd like to be able to nest these arbitrary deeply, and I like the idea of saying exactly which class of exceptions will be thrown by a procedure.. consider that IllegalOperandException, in the context of a more realistic computation can be a sum type, and so-on
20:36:28 <shanemikel> and as I like the specific exception in the function sig, I also want to see it in pattern matches
20:36:29 * hackagebot pred-trie 0.5.1 - Predicative tries  https://hackage.haskell.org/package/pred-trie-0.5.1 (athanclark)
20:36:34 <dfeuer> shanemikel, you don't need existentials for that, and they're not helping you.
20:36:57 <shanemikel> what should I do?
20:37:00 <MichaelBurge> shanemikel: I just used a closed sum type with all the different kinds of exceptions.
20:37:05 <dfeuer> Existentials have their uses, for sure, but I don't think they make much sense there.
20:37:30 <shanemikel> I was thinking later that I might add instances to it
20:37:33 <dfeuer> data ArithExcept = ArithExcept String, if you like.
20:37:48 <dfeuer> But I don't think that's really all that likely to be really all that useful.
20:38:00 <MichaelBurge> shanemikel: If you control your codebase, it's probably easier to just add to the sum type. If you're writing a library, some fancy typeclass solution might work
20:38:06 <dfeuer> Unless you're doing fancy stuff like extensible effects.
20:38:48 <MichaelBurge> shanemikel: In general, you can write simple Haskell and change it later to be fancy Haskell if it causes problems.
20:38:49 <dfeuer> You *could* do things like express the exceptions something could throw with a type-level list, but there are all sorts of complications.
20:39:16 <shanemikel> dfeuer: do you have an example of somebody doing that?
20:39:44 <shanemikel> I thought this approach was rather novel for working with fancy continuations
20:39:52 <shanemikel> (that's why I did it)
20:39:53 <dfeuer> shanemikel, I'm not sure about that specifically, but you should look at the extensible-effects package. There's a lot of that sort of thing in there. It's hairy.
20:39:59 <MichaelBurge> shanemikel: There's this: http://www.well-typed.com/blog/2015/07/checked-exceptions/
20:42:40 <shanemikel> well, you can see I'm working with continuations, and I'm likely to try implementing some coroutines with them, and even a dumb almost-frp for pedagogical purposes, so I thought getting a full stack of typed + promotable extensions might help keep me from jumping off a bridge
20:42:54 <shanemikel> err.. exceptions
20:43:42 <shanemikel> the haskell wiki page for exceptions, and the other stuff written about error handling is really not so useful
20:45:02 <dfeuer> shanemikel, my limited experience suggests that one thing Haskell does is *very* strongly encourage you to think about error handling up front.
20:45:34 <dfeuer> *Where* and *how* you plan to handle an error is fundamental to how you should express the error condition.
20:47:06 <dfeuer> In many languages, the usual approach is to start by just throwing exceptions all over the place and then trying to figure out where to catch them. It doesn't always work out so well. In Haskell, that approach is almost unworkable.
20:49:01 <shanemikel> yeah, that's why I was trying to figure out a way to put 'em in the fn type.  if you'd noticed In my paste, I had a commented out fn called die.. so the caller has to be explicit to avoid handling the exceptions
20:50:37 <shanemikel> do you know how to derive show for my existential types?
20:57:04 <dfeuer> shanemikel, a good general rule is that you can't derive *anything* for existential types.
21:21:04 <shanemikel> thanks MichaelBurge, that well-typed link is gonna be useful to me.  I just wish they shared an approach for pure code, too
21:25:10 <shanemikel> oh, I didn't realize there was a built-in way to do pure exceptions.. I'll have to look at Control.Exceptions
21:34:16 <athan> Anyone ever get the "premature end of compression stream" error when using `cabal install` on a sandbox?
21:36:31 * hackagebot monad-unlift 0.1.2.0 - Typeclasses for representing monad transformer unlifting  https://hackage.haskell.org/package/monad-unlift-0.1.2.0 (MichaelSnoyman)
21:47:44 <akfp> I have data S = A | B | C.  Now how can I make a `pattern NotC <- A | B`?
21:49:34 <jle`> akfp: i might make a function isAB :: S -> Bool, and pattern NotC <- (isAB->True)
21:50:01 <jle`> but...that might not be the best solution <_<
21:50:04 <jle`> >_>
21:51:11 <jle`> it probably doesn't paly well with the exhaustiveness checker
21:52:56 <jle`> yup, just checked, exhaustiveness checker is not happy
21:56:32 * hackagebot hylogen 0.1.0.11 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.11 (sleexyz)
22:21:05 <koz_> http://paste.rel4tion.org/341 <-- could someone advise me on how to make this less eye-bleedingly repetitive?
22:22:48 <jle`> koz_: i suppose you can do compare (Conjunction phis _) y = case y of ...
22:22:58 <jle`> so you don't have to rewrite Conjunction every time, etc.
22:23:08 <koz_> jle`: Yeah, that makes sense. I'll do that now.
22:23:29 <jle`> or lambdacase everything, compare (Conjunction phis _) = \case Conjunction psis -> ...
22:24:21 <koz_> lambdacase?
22:26:16 <Iceland_jack> You enable LambdaCase by placing {-# LANGUAGE LambdaCase #-} at the top of your source file or by entering the following into GHCi:
22:26:16 <Iceland_jack>     ghci> :set -XLambdaCase
22:27:10 <jle`> it just is convenient becuase you don't need to pick an awkward throwaway name like 'y'
22:27:19 <koz_> Ah, I see.
22:27:26 <koz_> I might have to read up on lambdacase - thanks!
22:27:58 <jle`> it's a bit of sugar to replace \y -> case y of ... with \case ...
22:28:01 <Iceland_jack>     compare (Conjunction phis _) = \case
22:28:01 <Iceland_jack>       Conjunction psis _ -> sort phis `compare` sort phsis
22:28:01 <Iceland_jack>       Top                -> GT
22:28:01 <Iceland_jack>       Bottom             -> GT
22:29:40 <koz_> Iceland_jack: Ah, that *is* very cool. I'll use that, thanks.
23:05:10 <kadoban> Heh, apparently in an Ord instance,  compare a b = comparing Down b a -- is … not a good idea :-/
23:36:35 * hackagebot heredocs 0.1.2.1 - heredocument  https://hackage.haskell.org/package/heredocs-0.1.2.1 (KatsutoshiItoh)
23:41:01 <linman32> hi, is it possible to extend a typeclass with an extra fnct? e.g. add a function to Functor typeclass... obviously not interested in doing that case.
23:45:39 <liste> linman32: no, aside from modifying the source code of the typeclass. how would the instances be aware of your new function?
23:46:36 <linman32> locally in file would be fine
23:46:43 <kadoban> linman32: You'd probably want to make a new typelass FunctorWithWhatever that may require Functor as a superclass if you like.
23:48:19 <linman32> ok sounds good. thanks
23:53:15 <runeks> Anyone know of any tools that will give me a call graph (or data flow graph) of this code? http://lpaste.net/161699
23:53:23 <runeks> SourceGraph gives me this: http://imgh.us/Test-Server.svg
23:54:43 <runeks> which doesn't show the relationship between the sequenced function calls within eg. openHandler ( .. =<< parseProvideContract =<< getProvideContract =<< getMessage etc.)
23:55:25 <LordBrain> i vaguely recall a tool that had the name dot in it... not sure if it did call graphs or data flow tho
23:55:36 <LordBrain> might have just did module depends
23:55:40 <LordBrain> or something
23:56:18 <cocreature> dot is for all sorts of graphs
23:56:56 <runeks> LordBrain: I know there are a lot of tools for module imports. That's all I find when I search for it.
23:57:01 <cocreature> runeks: I haven’t seen anything which gives you call graphs for haskell (but ofc it might still exist)
23:57:15 <runeks> I only know SourceGraph, and it doesn't quite capture what I want
23:59:36 <LordBrain> i did a search and found this ghc-vis tool, did you look at that
