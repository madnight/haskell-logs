00:00:10 <Cale> There was a particular algorithm for generating Version 1 GUIDs which involved the MAC address of the generating machine and some other junk
00:00:34 <Cale> But if all you want is an identifier which is unique as possible, doing that stuff actually just makes the situation worse
00:01:50 <Cale> The more modern Version 4 GUIDs as generated by the WinAPI actually also are not entirely random strings -- there are 6 bits which are set to specific values
00:02:35 <Cale> Usually when people say GUID, they really mean UUID though.
00:02:46 <Cale> (which is just an arbitrary 128 bit value)
00:03:08 <Cale> well, even that isn't true
00:03:32 <Cale> It's needlessly complicated
00:03:41 <fr33domlover> UUID v4 is random
00:03:45 <Cale> see https://en.wikipedia.org/wiki/Globally_unique_identifier and https://en.wikipedia.org/wiki/Universally_unique_identifier
00:03:49 <Cale> yeah
00:04:01 <tippenein> Cale: "it's needlessly complicated"
00:04:04 <tippenein> true enough
00:05:12 <Cale> I don't really understand how people get to these weird ideas for generating identifiers which are going to be significantly worse than just generating random bits.
00:06:28 <nocturne777> tippenein: what's wrong with aslatter's uuid library? is it not generating the uuids properly ?
00:06:54 <Cale> nocturne777: It's generating them correctly according to a standard which is dumb
00:07:16 <Cale> Sure, you can say "well, if it includes a timestamp, then we know for sure that two that are generated by the same machine will be different, and if it contains the MAC address of the machine, then two different machines are unlikely to have the same MAC address"
00:09:10 <nocturne777> I actually plan to use that library in production
00:09:35 <nocturne777> since I could not find any other alternatives
00:09:40 <Cale> Just getting 128 bits of random noise is a better alternative
00:10:00 <Cale> You can do that easily with any random number generating library
00:11:13 <Cale> The probability that a cosmic ray comes along and flips one bit of your generated GUID in memory is probably significantly larger than 1/2^128
00:12:01 <Cale> and if you're generating them in a patterned way where most of the bits of a GUID generated around the same time by the same machine will be the same, that means that the MAC address/timestamp way is actually worse
00:12:31 <Cale> in terms of ensuring uniqueness
00:16:13 <Cale> (you have to be generating a lot of GUIDs on the same machine for this argument to really be worth much, but still... random generation is simpler and ultimately more resilient)
00:16:16 <nocturne777> Cale: I think the default uuid algorithm in most languages follow the same spec (RFC 4122)
00:17:34 <tippenein> so, now, to get a Text from the UUID I have to look through the source to figure out what the data type actually _is_
00:20:48 <runway78> thanks for help. i've posted probably too much lines at once here. i was banned :)
00:20:58 <runway78> now it works..
00:21:06 <tippenein> lpaste.net runway78 
00:21:16 <runway78> ok, thanks
00:22:15 <tippenein> also #haskell-beginners is also available
00:23:06 <runway78> thanks for info
00:26:10 <Cale> (but this channel is also for beginners)
00:27:31 <Cale> https://blogs.msdn.microsoft.com/oldnewthing/20160114-00/?p=92851
00:27:58 <Cale> for a little back of the envelope calculation regarding why randomly generating GUIDs is better
00:31:45 <tippenein> Cale: thanks for this.
00:34:42 <nocturne777> Cale: regarding my earlier question on concurrently's use by the author, do you think his comments are misleading?
00:38:50 <nocturne777> actually, nevermind. the author is right.
01:08:32 <llinguini> In ghci is there a way to see what constructor each member of a list uses?
01:18:28 <lipkab> Just typing in the variable name isn't good enough?
01:19:27 <lipkab> > let xs = [Maybe 'a', Nothing, Maybe 'b'] in xs
01:19:29 <lambdabot>      Not in scope: data constructor ‘Maybe’
01:19:29 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)    Not in ...
01:19:29 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
01:20:09 <lipkab> Silly lambdabot.
01:20:37 <lipkab> llinguini: Well, you get what I mean. Or is that not what you meant?
01:22:07 <llinguini> lipkab: so I was trying to find an unmatched pattern, and I was pretty sure that this list would always have these few constructors
01:22:25 <llinguini> I wanted to check if there were any other constructors used in the list
01:22:54 <llinguini> But I found out somehow that there is was in fact another constructor used
01:23:37 <lipkab> I see.
01:26:00 <llinguini> lipkab: but yeah, I'm still curious, is there a way to find that out from ghci?
01:26:10 <lipkab> Oh, sorry, lambdabot, you're not silly. I am.
01:26:42 <lipkab> llinguini: Did you try what I advised?
01:26:48 <lipkab> If you have a list ls.
01:27:29 <lipkab> And the elements of ls derive Show, you can just type ls and get all constructors.
01:27:57 <lipkab> > let ls = [Just 'a', Nothing, Just 'b'] in ls
01:27:57 <llinguini> lipkab: Well show isn't derived 
01:27:58 <lambdabot>  [Just 'a',Nothing,Just 'b']
01:28:30 <llinguini> show does some complicated unboxing of the Constructor before output
01:28:56 <llinguini> lipkab: but I get what you're saying. Wouldn't have worked for my case though.
01:30:05 <lipkab> I can't help then, sorry.
01:30:11 * hackagebot AFSM 0.1.1.0 - Arrowized functional state machines  https://hackage.haskell.org/package/AFSM-0.1.1.0 (hanzhxu)
01:30:41 <Cale> llinguini: You should generally derive Show, or else at least produce something which is valid Haskell source code for reconstructing the value.
01:31:18 <Cale> It makes debugging much nicer.
01:32:45 <llinguini> Cale: Well, this case I'm implementing a interpreted language so show isn't derived, but it prints out values sensible to the other language
01:33:01 <Cale> I would usually write a separate prettyprinting function for that
01:33:02 <llinguini> But sometimes they don't match up well with haskell types so types can't be inferred 
01:34:02 <llinguini> That seems like a better idea I suppose, isnteady of writing show myself
01:34:07 <Cale> It's obviously possible to use Show for whatever you like, but it just tends to be nice to be able to copy-paste it as Haskell source
01:35:26 <llinguini> actually this is for a Programming languages/Compilers class
01:35:39 <llinguini> it's my first time using haskell
01:35:56 <llinguini> or a functional language for that matter. 
01:37:06 <Cale> another reasonably easy way you could check, I suppose is to write a list comprehension like [x | x@(SomeConstructor y z) <- ls]
01:40:12 * hackagebot guid 0.1.0 - A simple wrapper around uuid  https://hackage.haskell.org/package/guid-0.1.0 (tippenein)
01:55:12 * hackagebot AFSM 0.1.1.1 - Arrowized functional state machines  https://hackage.haskell.org/package/AFSM-0.1.1.1 (hanzhxu)
01:55:14 * hackagebot socket 0.6.0.1 - An extensible socket library.  https://hackage.haskell.org/package/socket-0.6.0.1 (LarsPetersen)
02:12:25 <Gurkenglas> Why's there scanl and scanl' and scanl1 in Data.List but no scanl1'?
02:30:13 * hackagebot socket 0.5.3.1 - A portable and extensible sockets library.  https://hackage.haskell.org/package/socket-0.5.3.1 (LarsPetersen)
02:36:24 <aloiscochard> if by anychance, someone have around some code to clean ANSI escope code from a Data.Text, I would be very interested :) cheers
02:45:03 <fr33domlover> aloiscochard, check out the terminal related packages?
02:45:07 <fr33domlover> like ansi-terminal
02:45:17 <fr33domlover> if you need, extract code from there and adapt
02:51:43 <aloiscochard> fr33domlover: was trying a simple Attoparsec.Text approach, I'll look into this package ty
02:52:31 <cocreature> there is also ansi-wl-pprint
02:52:43 <cocreature> but that operates on Doc not on text iirc
03:40:15 * hackagebot repa-scalar 4.2.2.1 - Scalar data types and conversions.  https://hackage.haskell.org/package/repa-scalar-4.2.2.1 (BenLippmeier)
03:40:17 * hackagebot repa-convert 4.2.2.1 - Packing and unpacking flat tables.  https://hackage.haskell.org/package/repa-convert-4.2.2.1 (BenLippmeier)
03:40:19 * hackagebot repa-stream 4.2.2.1 - Stream functions not present in the vector library.  https://hackage.haskell.org/package/repa-stream-4.2.2.1 (BenLippmeier)
03:42:34 <Geff22> I found that with any version Nvidia drivers GLFW.init fails on my pc. But without them it's work normally. So I just have to wait, until GLFW-b's author update his lib.
03:43:15 <srhb> Geff22: Fails how?
03:43:36 <Geff22> init return False.
03:44:08 <srhb> Geff22: Are you sure that's a problem with glfw-b?
03:45:15 * hackagebot repa-array 4.2.2.1 - Bulk array representations and operators.  https://hackage.haskell.org/package/repa-array-4.2.2.1 (BenLippmeier)
03:46:15 <Geff22> I'm not sure. I compile C++ GLFW example project and it's work fine.
03:49:51 <srhb> Geff22: I also don't see any issue regarding this on the repository, so I don't imagine it will just magically be fixed, if it is indeed a problem with glfw-b
03:52:49 <srhb> Geff22: If you lpaste a minimal example of the failure, I can try running it here.
03:53:00 <srhb> Geff22: I'll have to just build glfw-b first though :-)
03:57:50 <Geff22> here: http://lpaste.net/159402 . But this example work on my second computer.
03:59:44 <cocreature> Geff22: what’s the c++ program that works?
03:59:51 <srhb> Geff22: Works just fine here.
04:02:35 <Geff22> cocreature: GLFW from github. Repository contains some examples.
04:02:50 <srhb> Geff22: Linking issues perhaps?
04:03:00 <cocreature> Geff22: you should try the exact same example in c++ and haskell to find out if it’s an issue in glfw-b
04:16:03 <Geff22> Hm. I build GLFW-3.1 (GLFW-b as I know use this version) and it's examples don't work. But GLFW examples from github works normally.
04:20:10 <mirpa> Geff22: your example works for me: debian, drivers 340.96-1, bindings-GLFW-3.1.2, GLFW-b-1.4.8.0
04:21:55 <Geff22> I see "Bugfix: Initialization failed on headless systems" in 3.1.2 changelog. Also one of the example print "monitor not found". Maybe problem here? 
04:22:49 <srhb> Geff22: Which changelog? And should be easy to test, just upgrade.
04:24:22 <Geff22> srhb: http://www.glfw.org/changelog.html . GLFW-3.1.2 works for me. But as I know GLFW-b use 3.1.
04:26:29 <srhb> Geff22: You're right. Is your system headless though?
04:26:44 <srhb> And honestly, the C++ one works, so I don't see why this changes anything.
04:27:17 <srhb> If I fail my init deliberately, glfw-b finds no monitors here either (which is expected.)
04:31:25 <Geff22> So problem in "headless" of my system?
04:31:33 <mirpa> maybe you should vote for update, there is update issue for 3.1.1 https://github.com/bsl/bindings-GLFW/issues/30
04:33:29 <mirpa> how do you find out which version of GLFW is used by GLFW-b - documentation?
04:34:09 <Geff22> Update will fix my problem. But only if GLFW-b upgraded to 3.1.2 which fix problem with headless.
04:35:07 <srhb> mirpa: Technically it's the version used by GLFW-bindings
04:35:07 <Geff22> mirpa: "GLFW-b depends on bindings-GLFW, which, as of the time of this writing, binds to GLFW 3.1, released 2015-01-18." from https://hackage.haskell.org/package/GLFW-b
04:35:37 <srhb> Geff22: I doubt that's your issue. Unless you tested the C++ version with a 3.2 GLFW
04:35:48 <srhb> Geff22: But in that case you could try to redo that test with 3.1 to narrow it down.
04:38:05 <Geff22> I tested with C++/3.2 and it's work. C++/3.1 and C++/3.1.1 doesn't.
04:38:17 <srhb> OK, that does make it seem more likely. :)
04:42:19 <Geff22> But what is strange: about 2 month ago all work normal. Maybe windows somehow became "headless"? So I should wait update or fix "headless" (but i don't know how).
04:45:01 <srhb> Sorry, I don't know how to investigate further if the issue is in the C library. Headless usually refers to systems without monitors attached, which it seems yours isn't.
04:49:47 <Geff22> Anyway thanks for helping me.
05:06:57 <gfixler> I'm curious about Fractional instances that aren't numbers
05:07:02 <gfixler> anyone have an example?
05:14:31 <MichaelBurge> gfixler: One example could be an AST for an embedded language, that uses instances like Fractional to make it easier to write expressions
05:15:18 * hackagebot repa-eval 4.0.0.2 - Low-level parallel operators on bulk random-accessble arrays.  https://hackage.haskell.org/package/repa-eval-4.0.0.2 (BenLippmeier)
05:15:41 <gfixler> MichaelBurge: do you mean, say, mathematical expressions that represent fractionals?
05:17:24 <MichaelBurge> gfixler: Here's an F# example of what I mean: https://github.com/jdh30/FSharpCompiler/blob/master/FSharpCompiler/FSharpCompiler/Tests.fs
05:17:47 <MichaelBurge> Even though those look like F# code, it's really sugar for an AST
05:18:02 <MichaelBurge> I imagine someone could do something similar for Fractional
05:18:23 <MichaelBurge> For monads, I believe that's what a free monad is. I'm sure there's a 'free fractional' somewhere
05:20:19 * hackagebot repa-flow 4.2.2.1 - Data-parallel data flows.  https://hackage.haskell.org/package/repa-flow-4.2.2.1 (BenLippmeier)
05:20:26 <gfixler> MichaelBurge: thanks, I'll have a look
05:20:38 <MichaelBurge> gfixler: Mathematical expressions would be a good example. Another would be representing real numbers as computer programs 'Integer -> (Integer, Integer)' that take a precision and output a rational approximation.
05:21:18 <MichaelBurge> gfixler: Then, when you added or divided these program numbers, you'd really be constructing a new program that might take longer to converge to a given precision.
05:21:38 <gfixler> ah, interesting
05:23:13 <saurabhnanda> hey, good people,  I seem to be doing something really stupid at http://lpaste.net/159404 -- can anyone help me with why this Aeson is being unable to parse this JSON?
05:23:34 <MichaelBurge> saurabhnanda: Have you tried 'decodeEither'?
05:24:03 <saurabhnanda> MichaelBurge: is it a Maybe bug or a data-type bug?
05:24:55 <saurabhnanda> MichaelBurge: also, can't find decodeEither, I can find decode and decodeStrict
05:25:11 <saurabhnanda> MichaelBurge: there's an eitherDecode
05:25:22 <MichaelBurge> saurabhnanda: That's the one I meant
05:25:42 <lyxia> saurabhnanda: your parrams field is an array not an object
05:26:49 <saurabhnanda> :i Data.Aeson.Object
05:26:58 <saurabhnanda> :i Data.Aeson.Value
05:27:17 <lyxia> type Object = HashMap Text Value
05:27:30 <saurabhnanda> @lambdabot :i Data.Aeson.Object
05:27:30 <lambdabot> Unknown command, try @list
05:27:44 <saurabhnanda> @lambdabot please upgrade yourself :P
05:27:44 <lambdabot> Unknown command, try @list
05:28:06 <saurabhnanda> lyxia: would decode x :: Maybe Value work?
05:28:46 <saurabhnanda> MichaelBurge: tried eitherDecode -- Left "Error in $: The key \"Method\" was not found"
05:29:08 <lyxia> oh
05:29:15 <MichaelBurge> saurabhnanda: It could be that Method should be uppercase in the JSON
05:29:31 <MichaelBurge> My usual debugging technique in a case like this is to write the instance manually rather than depend on the generic one
05:29:45 <MichaelBurge> Then you can use methods like traceShowM to parse it step-by-step
05:30:00 <saurabhnanda> MichaelBurge: lyxia: I've used fieldLabelModifier and constructorTagModifier but not sure whether it's correct
05:30:24 <saurabhnanda> MichaelBurge: I've written a bunch of instance methods by-hand, but want to use the generics to avoid boilerplate ow
05:30:25 <saurabhnanda> *now
05:31:41 <saurabhnanda> basically, I think it boils down to my confusion of how to use fieldLabelModifier and constructorTagModifier
05:31:46 <saurabhnanda> can you help me?
05:31:50 <maerwald> @hoogle Errno -> IO a -> IO a -> IO a
05:31:55 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
05:31:55 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
05:31:55 <lambdabot> Control.OldException bracket_ :: IO a -> IO b -> IO c -> IO c
05:32:26 <maerwald> am I the only one who wants to catch specific Errnos?
05:33:25 <MichaelBurge> saurabhnanda: I think the toLower should go on fieldLabelModifier, along with 'removePrefix' which is modifying the record methods?
05:33:38 <saurabhnanda> MichaelBurge: yup, trying that
05:33:52 <saurabhnanda> MichaelBurge: yup, that was the issue, now on to the next one
05:34:39 <saurabhnanda> lyxia: you were also right -- Left "Error in $: expected HashMap Text a, encountered Array"
05:35:11 <saurabhnanda> Brilliant -- this worked ==> Left "Error in $: expected HashMap Text a, encountered Array"
05:35:12 <saurabhnanda> sorry
05:35:29 <saurabhnanda> (eitherDecode r)::Either String (JsonRpcNotification Value) ==> Right (JsonRpcNotification {notifMethod = "aria2.onDownloadStart", notifParams = Array [Object (fromList [("gid",String "9641d0fc8e4b424c")])]})
05:35:37 <saurabhnanda> :i Either
05:35:42 <saurabhnanda> is Either a monad?
05:35:58 <saurabhnanda> yes it is
05:36:04 <MichaelBurge> Yeah, it short-circuits with Left
05:36:19 <saurabhnanda> cool, I can use this instead of Maybe -- this one gives the error message as well
05:36:32 <saurabhnanda> what's up with @lambdabot today?
05:36:37 <saurabhnanda> @lambdabot feeling down?
05:36:37 <lambdabot> Unknown command, try @list
05:36:52 <lyxia> it doesn't have :i
05:36:57 <lyxia> lambdabot isn't quite ghci
05:37:25 <saurabhnanda> lyxia: ah okay
05:38:02 <saurabhnanda> is there a fromRight function on the lines of fromJust?
05:39:29 <maerwald> @hoogle fromRight
05:39:31 <lambdabot> No results found
05:39:48 <maerwald> @hoogle rights
05:39:49 <lambdabot> Data.Either rights :: [Either a b] -> [b]
05:39:49 <lambdabot> Graphics.UI.GLUT.Window RightSide :: Cursor
05:39:49 <lambdabot> Language.Haskell.Lexer RightSquare :: Token
05:39:53 <maerwald> that's the one
05:40:07 <srhb> saurabhnanda: Why not use `either`?
05:40:17 <saurabhnanda> :t Data.Either.Unwrap.fromRight
05:40:19 <lambdabot> Not in scope: ‘Data.Either.Unwrap.fromRight’
05:40:21 <lyxia> https://hackage.haskell.org/package/either-4.4.1/docs/Data-Either-Combinators.html
05:40:42 <lyxia> http://hoogle.haskell.org/?hoogle=Either%20a%20b%20-%3E%20a
05:41:00 <srhb> :t either (const $ error "I write non-total Haskell :(") id
05:41:02 <lambdabot> Either a r -> r
05:41:28 <maerwald> srhb: uhm, your program or module is not non-total just because a function is 
05:41:40 <srhb> maerwald: No, but if you ever see that error, you did.
05:41:51 <maerwald> good point yeah
05:42:08 <maerwald> another reason I want a totality checker!
05:42:10 <saurabhnanda> okay, this brings me to a related point
05:42:15 <srhb> error is fine as long as you don't evaluate it. :-)
05:42:17 <saurabhnanda> recently I've started using fromJust quite a lot
05:42:19 <saurabhnanda> find it easier
05:42:35 <saurabhnanda> especially when I KNOW that the value can never by Nothing
05:42:45 <srhb> saurabhnanda: That is indeed the only reasonable time to use it.
05:42:48 <saurabhnanda> or when I'm looking up a HashMap and I know the value is there
05:42:56 <saurabhnanda> or when I don't know how to handle a Nothing
05:43:12 <srhb> Well, sure, but even then you might want to annotate your error.
05:43:13 <maerwald> saurabhnanda: just make sure you never do that for _external_ api
05:43:48 <maerwald> e.g. `head` in Prelude was a mistake... if people want an unsafe version, they should wrap it with fromJust
05:44:47 <saurabhnanda> hmm
05:44:58 <srhb> saurabhnanda: I tend to prefer `maybe (error "My assumption that X in Y is clearly wrong...") id` over fromJust
05:45:04 <saurabhnanda> is there a fromJust which can give me a precise error message
05:45:06 <saurabhnanda> ?
05:45:08 <srhb> saurabhnanda: That was I don't have to go digging for my reasoning. :-)
05:45:12 <srhb> That way*
05:45:25 <MichaelBurge> saurabhnanda: Sometimes I use a 'type ApplicationM a = ExceptT MyApplicationError IO a' closer to the top-level of the function. Then, rather than call 'error', I can produce an error value.
05:45:26 <saurabhnanda> :t maybe
05:45:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:45:35 <maerwald> saurabhnanda: you might be interested in MonadThrow
05:45:53 <maerwald> the typeclass
05:46:03 <saurabhnanda> what does 'maybe' do? the type sig doesn't tell me anything
05:46:13 <saurabhnanda> is there a way to pull docs in ghci?
05:46:34 <srhb> saurabhnanda: Actually iy does
05:46:52 <lyxia> located-base is a nice replacement for non-total functions
05:47:14 <maerwald> saurabhnanda: MonadThrow is an abstract "failure" typeclass which you can use as Maybe, Either or a real exception
05:47:28 <srhb> saurabhnanda: Given a `b` and a function (a -> b), it can take a `Maybe a` to a `b`. It does this by returning your `b` if it's Nothing, otherwise applying the `a -> b` to the `a` in the Just constructor.
05:47:36 <saurabhnanda> lyxia: what are non-total functions?
05:47:38 <maerwald> so if you can encode a proper error message but still use Maybe type where you don't care about it
05:48:13 <srhb> saurabhnanda: In other words: maybe b f (Just x) = f x; maybe b f Nothing = b
05:48:25 <srhb> ugh, should have called x a. Oh well.
05:48:40 <Geff22> Heh, I solved my problem with GLFW initialization and "monitor not found". GLFW conflicts with (!) TeamViewer monitor driver.
05:49:11 <srhb> Geff22: ...
05:49:12 <srhb> Ouch.
05:50:10 <lyxia> saurabhnanda: partial functions, like fromJust
05:50:27 <saurabhnanda> okay, back to coding. Thanks lyxia MichaelBurge shachaf maerwald
05:53:40 <saurabhnanda> what's the easiest way to access the value of "gid" from ==> Array [Object (fromList [("gid",String "9641d0fc8e4b424c")])] 
05:56:30 <saurabhnanda> time to learn lens, I guess
05:58:11 <maerwald> uh
05:58:51 <maerwald> cracking a nut with a sledgehammer
05:59:31 <saurabhnanda> maerwald: better way, please?
05:59:50 <ggole__> Pattern matching?
05:59:52 <maerwald> if it's one, I'd just wrap it in a custom accessor function
06:00:22 <srhb> Looks like Aeson, if so there's already `key`
06:01:55 <saurabhnanda> how to pattern match on an Array, which I believe is an alias of Vector
06:02:43 <srhb> saurabhnanda: You don't, but you can use the Vector indexing operations.
06:03:27 <saurabhnanda> srhb: right, that's why I was wondering if learning lenses is a better time investment rather than separate accessors for every other data-type
06:03:55 <srhb> I don't think it's a bad investment, but some people disagree. :)
06:04:50 <maerwald> saurabhnanda: IMO, lenses are only really useful if you have really complicated and nested data structures, like in a compiler. For most other use cases i'd throw this question at you: "why are your data structures that complex?"
06:04:51 <srhb> saurabhnanda: But you might look at whatever the library you're using provides for indexing.
06:05:40 <saurabhnanda> srhb: I'm dealing with flat-ish JSON with aeson, that's about it. For now..
06:06:17 <maerwald> most of the time I come across lenses in code they involve pretty much the same boilerplate code custom accessor functions would need... with the difference of abstraction. But then that abstraction isn't even used, lol
06:06:55 <saurabhnanda> also, is it a good idea to go "under the hood" of Aeson. At another place I've used the fact that Object is actually just a HashMap. Should I be using the fact that Array is just a Vector? Am I not tying myself to an internal implementation detail?
06:15:13 <geppettodivacin> I would think that, since they're type definitions and they haven't provided any indexing functions within aeson, that you would be perfectly fine assuming Array is a Vector.
06:15:50 <geppettodivacin> I would hope that's the reason they used type as opposed to newtype.
06:17:09 <saurabhnanda> geppettodivacin: well there's a Data.Aeson.Lens, but I can't wrap my head around it. Everything is suddenly looking like line-noise to me. Perl redux, it seems -- https://www.schoolofhaskell.com/user/tel/lens-aeson-traversals-prisms
06:30:23 <ania123> someone hellped me here to download a paper from springer webpage... I do not remember his nickname. I need help again, can one help me with this matter?
06:32:11 <ania123> is here anyone from MIT?
06:38:20 <maerwald> anyone knows a nice haskell vim colorscheme? trying to move away from solarized
06:40:43 <zaquest> maerwald, i like jellybeans
06:41:46 <ania123> is here anyone from MIT?
06:42:03 <maerwald> ania123: you asked that 2minutes ago already
06:42:15 <ania123> I repeated :)
06:42:59 <maerwald> please don't repeat every 2 minutes
06:43:13 <ggVGc> ania123: why?
06:44:14 <ertesx> luite: is ghcjs --interactive ready for use?  i'd like to use it with haskell-interactive-mode
06:44:41 <ania123> http://philpapers.org/rec/DEKRET
06:44:45 <ania123> I need this paper
06:44:54 <ania123> and from MIT it can be accesable :)
06:45:22 * hackagebot pinchot 0.16.0.0 - Write grammars, not parsers  https://hackage.haskell.org/package/pinchot-0.16.0.0 (OmariNorman)
06:46:42 <maerwald> zaquest: well, the point is I want to move away from dark colorschemes since I'm pretty sure now it requires more concentration than a light scheme for me. It's just that light solarized somewhat sucks
06:46:49 <maerwald> and jellybeans is a light one afais
06:47:08 <maerwald> and a lot of others don't have proper syntax highlighting on haskell
06:48:00 <ertesx> maerwald: usually increasing the font size and using a good font is the better option…  i say that because i've seen a lot of programmers write code with tiny fonts, and that's definitely straining
06:48:22 <maerwald> font is already quite large
06:49:56 <ARM9> I find dark and bright colorschemes equally distracting, I prefer something in between with low contrast
06:50:13 <ggVGc> green on black arryday
06:52:10 <ertesx> from time to time, maybe once every three months i invert my color scheme (emacs though, so i can't help)…  it's not the dark/light colours that are straining to me, but the monotony
06:52:43 <ertesx> when you do that, it feels fresh again…  in fact i'll do that now =)
06:53:44 <zaquest> maerwald, light themes are too bright for me, so i cant recommend one. do you know about this repo https://github.com/flazz/vim-colorschemes ?
07:12:12 <maerwald> this is really weird... there are some nice light themes, but pretty much all of them don't have the same powerful syntax higlighting as solarized
07:13:08 <ertesx> can't you just invert it?  replace all colour values by their exact inverses
07:13:36 <maerwald> invert what
07:14:11 <ertesx> i don't know how it works in vim, but i imagine a colour scheme to be a file with colour assignments or something
07:15:09 <ertesx> if it's like that you can just invert all colours…  write a little haskell program to do it (and use the colour package rather than computing with RGB to get even better results)
07:17:53 <ertesx> (i hope it still compiles, because it's a really useful package for dealing with colour)
07:22:56 <ertesx> there is also prizm, if colour fails
08:20:26 * hackagebot machines-io 0.2.0.12 - IO utilities for the machines library  https://hackage.haskell.org/package/machines-io-0.2.0.12 (aloiscochard)
08:20:28 * hackagebot machines-binary 0.3.0.2 - Binary utilities for the machines library  https://hackage.haskell.org/package/machines-binary-0.3.0.2 (aloiscochard)
08:20:32 <hsk3> > fmap length Just [1, 2, 3]
08:20:34 <lambdabot>  1
08:20:36 <hsk3> Why does that work?
08:20:45 <hsk3> It looks like fmap is taking three arguments there.
08:20:53 <hsk3> But that's wrong.
08:21:02 <hsk3> How is this thing parenthesized?
08:22:23 <dinnu93> Could not find module Control.Monad.State is the error I'm getting how to fix it ?
08:22:37 <dinnu93> I installed Haskell through STack
08:23:22 <hsk3> dinnu93: Step one, Google Control.Monad.State. You'll end up here: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State.html
08:23:22 <hsk3> Step two: Click Contents in the top-right corner.
08:23:29 <hsk3> You'll end up here: https://hackage.haskell.org/package/mtl-2.2.1
08:23:39 <hsk3> So you see it's in mtl package
08:23:43 <hsk3> "stack build mtl"
08:24:06 <kadoban> dinnu93: In what context?
08:24:25 <kadoban> dinnu93: Are you working on a specific project, with a .cabal file? Or using 'stack ghci', or something else?
08:24:52 <dinnu93> kadoban: One of my haskell assignments is using import Control.Monad.State
08:25:00 <dinnu93> hsk3: I'll try that
08:25:15 <kadoban> dinnu93: That didn't really answer what I was asking, but … well try it I guess *shrug*
08:25:26 * hackagebot machines-process 0.2.0.6 - Process (system) utilities for the machines library  https://hackage.haskell.org/package/machines-process-0.2.0.6 (aloiscochard)
08:26:26 <dinnu93> kadoban: I'm a newbie haskeller so I really didn't understand What you asked. 
08:26:58 <dinnu93> kadoban: I'm solving CIS194 Spring13 Lecture 07 Homework Assignment
08:27:37 <kadoban> dinnu93: Well, how you make the 'mtl' package available for yourself depends on how you're running the code with stack, essentially. If it's a cabal package, you add it to the .cabal file (in the build-depends), if it's stack ghci, you can do  'stack ghci --package mtl', etc.
08:27:42 <ggVGc> I beleve there are less than 5 non-newbie haskellers in the world
08:27:56 <kadoban> But you can try the suggestion above and not worry about it unless it doesn't work.
08:28:26 <dinnu93> ggVGc: lol
08:28:29 <hsk3> > fmap length Just [1, 2, 3]
08:28:30 <hsk3> Why does that work? It looks like fmap is taking three arguments there. But that's wrong. How is this thing parenthesized?
08:28:31 <lambdabot>  1
08:28:48 <dinnu93> kadoban: I'll try that
08:31:21 <Boomerang> hsk3: You're doing length on a Maybe
08:31:26 <Boomerang> > length (Just 3)
08:31:28 <lambdabot>  1
08:31:33 <Boomerang> > length Nothing
08:31:35 <lambdabot>  0
08:31:48 <kadoban> :t fmap length
08:31:49 <lambdabot> (Functor f, Foldable t) => f (t a) -> f Int
08:32:02 <Boomerang> So it doesn't actually matter what's inside the Maybe
08:32:07 <geekosaur> :t fmap length Justr
08:32:08 <lambdabot>     Not in scope: data constructor ‘Justr’
08:32:09 <lambdabot>     Perhaps you meant ‘Just’ (imported from Data.Maybe)
08:32:09 <geekosaur> er
08:32:11 <geekosaur> :t fmap length Just
08:32:13 <lambdabot> a -> Int
08:32:31 <hsk3> Boomerang: but shouldn't that be the same then as
08:32:32 <hsk3> > fmap length (Just [1,2,3])
08:32:33 <hsk3> But interestingly, it's NOT the same thing!
08:32:33 <geekosaur> at a guess, Foldable instance for (->) e
08:32:34 <lambdabot>  Just 3
08:32:42 <dinnu93> hsk3: I tried what you've said I'm still getting the same problem "Could not find module ‘Control.Monad.State’ "
08:32:58 <kadoban> dinnu93: What command are you actually running?
08:33:00 <hsk3> dinnu93: then maybe you gotta add mtl into the .cabal file if you've got one
08:33:09 <hsk3> under dependencies
08:33:12 <Boomerang> > fmap length Just undefined
08:33:14 <lambdabot>  1
08:33:23 <geekosaur> dinnu93, if you are running ghci to check this, use stack ghci instead
08:33:27 <Boomerang> lazy evaluation?
08:33:29 <dinnu93> ok but I installed haskell with stack 
08:33:33 <hsk3> > fmap length (Just undefined)
08:33:35 <lambdabot>      No instance for (Foldable t0) arising from a use of ‘length’
08:33:35 <lambdabot>      The type variable ‘t0’ is ambiguous
08:33:35 <lambdabot>      Note: there are several potential instances:
08:34:15 <dinnu93> kadoban: Ur command works that means the mtl package is there but it's just not visible
08:34:55 <geekosaur> dinnu93, when you install a package with stack, it's not installed in the glonbal package database but in stack's private database. you can only get at it using stack commands
08:35:06 <dinnu93> kadoban: I ran 'stack build mtl'
08:35:09 <geekosaur> if you were running "ghci", run "stack ghci" instead
08:35:22 <geekosaur> if you were running "ghc ...", run "stack exec -- ghc ..." instead
08:35:36 <dinnu93> geekosaur: I'll try that
08:35:49 <geekosaur> hsk3, repeating what I did earlier:
08:35:53 <geekosaur> :t fmap length Just
08:35:54 <lambdabot> a -> Int
08:36:00 <kadoban> dinnu93: I mean to run your actual code.
08:36:15 <geekosaur> the result is a function
08:36:21 <hsk3> geekosaur: a shit of course, so it's currying lol
08:36:36 <geekosaur> I am guessing that he Foldable instance here is for the primitive Reader/environment, ((->) e)
08:41:14 <hsk3> geekosaur: ah yeah of course
08:41:23 <hsk3> it's fmapping over the FUNCTION FUNCTOR!
08:41:28 <hsk3> i missed that
08:41:29 <hsk3> thanks
08:41:31 <geekosaur> yep
08:41:51 <geekosaur> that;s what you should generally expect if you see "an extra parameter"; it means that something has returned a function
08:41:57 <hsk3> :)
08:42:48 <geekosaur> (and indeed a constructor like Just behaves like a function)
08:50:34 * hackagebot sarsi 0.0.0.0 - A universal quickfix toolkit and his protocol.  https://hackage.haskell.org/package/sarsi-0.0.0.0 (aloiscochard)
09:01:00 <barrucadu> Anyone familiar with Heist? I'm having a little difficulty trying to figure out how to use it with Spock: Heist.Interpreted.renderTemplate doesn't appear to be rendering, it just returns the original template file without expanding any splices.
09:10:31 <barrucadu> Ah, I wasn't binding defaultInterpretedSplices
09:23:37 <maerwald> I wonder if there is a syntax highlighting engine for haskell in vim that doesn't use stupid regexes
09:24:27 <ARM9> what constitutes a stupid regex?
09:25:08 <maerwald>  "\(\<[A-Z][a-zA-Z0-9_']*\.\)\=[-!#$%&\*\+/<=>\?@\\^|~.][-!#$%&\*\+/<=>\?@\\^|~:.]*"
09:25:19 <maerwald> guess what it does
09:26:48 <ARM9> I don't know, identifiers?
09:30:07 <maerwald> there should be a way to interact with the GHC lexer or something
09:42:37 <ertes-t6v> ARM9: any regex that tries to parse a non-regular language
09:43:01 <ertes-t6v> and since almost all languages are non-regular…
09:47:02 <ertes-t6v> let's give them a less misleading name like parrelas instead of regexes…  "PARser for a REgular LAnguage" =)
09:48:23 <scshunt> ertes-t6v: well you might as well add a disclaimer saying they're not actually regular languages
09:50:14 <dolio> Doesn't that name have the same problem as "regex"?
09:50:37 * hackagebot sarsi 0.0.0.2 - A universal quickfix toolkit and his protocol.  https://hackage.haskell.org/package/sarsi-0.0.0.2 (aloiscochard)
09:50:50 <ertes-t6v> like: "This regular expression attempts to parse Haskell for syntax highlighting.  Of course Haskell is not regular, so the expression is very complicated to cover as many cases as possible and still not give you any guarantee whatsoever that your code will be properly highlighted.  Please use the coding style that the author of this regular expression wants you to use!"
09:52:18 <ertes-t6v> dolio: regex may mislead you into thinking that the regex *language* itself is regular, but it's rather a parser for a regular language
09:56:30 <Habib> hey, any os x haskellers here?
09:56:40 <Habib> i'm having a bit of an issue with hSetEcho on my terminal.
09:56:53 <dolio> Oh. But it's still not accurate, because most implementations have features that allow you to parse non-regular languages.
09:57:01 <dolio> Which is why people foolishly try to use them for that.
09:57:15 <dolio> Well, maybe not the only reason.
09:57:54 <puregreen> is there some way to make GHCi run hlint on every expression that you type?
09:59:23 <Habib> ooh, that's interesting
09:59:33 <Habib> runhaskell is flaky with hSetEcho, but ghc works great
10:03:30 <ertes-t6v> Habib: may be related to buffering, because the interpreter has different defaults IIRC…  see hSetBuffering
10:04:00 <Habib> ertes-t6v sorry, i should have specified that i've already got both of them in there
10:04:00 <ertes-t6v> you probably want LineBuffering to get the usual shell-like echo behaviour
10:04:06 <ertes-t6v> ah
10:04:18 <Habib> what's the etiquette on pasting snippets?
10:04:37 <ertes-t6v> post one-liners here, everything else on lpaste.net
10:04:44 <Habib> cheers
10:14:04 <Habib> @ertes-t6v http://lpaste.net/7963803230113103872
10:14:04 <lambdabot> Unknown command, try @list
10:14:11 <Habib> ertes-t6v http://lpaste.net/7963803230113103872
10:15:57 <Habib> sorry, ertes-t6v, i just got disconnected there (accidentally closed the wrong window) - http://lpaste.net/7963803230113103872
10:22:13 <ertes-t6v> Habib: sorry, if it's not the buffering, then i'm already out of clues…  be patient, someone else might know =)
10:22:23 <ertes-t6v> also name your OS…  it can be relevant
10:22:50 <Habib> i'm on os x 10.11.4 (el capitan)
10:23:07 <Habib> the weird thing is that it works when compiled, so it's not important
10:23:22 <Habib> it's only when interpreted through runhaskell that it acts strangely
10:25:13 <Habib> barring that, i was hoping to get some feedback on my haskell code. i know it's crap, but i was wondering how anyone here might do it differently (specifically the getCh IO action i wrote)
10:25:28 <troydm> how can I get current local time with type LocalTime?
10:29:21 <ertes-t6v> troydm: you can't, because LocalTime is not expressive enough
10:29:40 <ertes-t6v> troydm: you can get ZonedTime and get the local time for the local time zone
10:29:53 <ertes-t6v> or you can get UTCTime and convert to LocalTime by specifying a time zone
10:30:20 <monochrom> yeah, I think getZonedTime is your best bet
10:30:38 * hackagebot sarsi 0.0.0.4 - A universal quickfix toolkit and his protocol.  https://hackage.haskell.org/package/sarsi-0.0.0.4 (aloiscochard)
10:30:50 <ertes-t6v> note that ZonedTime contains a LocalTime (along with the TimeZone)
10:35:01 <dkov> /msg lambdabot @pl distance l r = sum $ zipWith (\x y -> if x == y then 0 else 1) l r
10:35:01 <dkov>  
10:37:35 <troydm> ertes-t6v: ic, thx
10:41:12 <Gurkenglas> dkov, sum . map (bool 1 0) .: zipWith (==)
10:51:11 <EvanR> what the heck does this do
10:51:12 <EvanR> getTimeZone :: UTCTime -> IO TimeZone
10:51:39 <EvanR> "Get the local time-zone for a given time (varying as per summertime adjustments)"
10:52:08 <monochrom> it does not tell you the current time zone. it tells you the timezone used at the given moment.
10:52:30 <monochrom> and yes at different moments one uses different time zones
10:52:34 <EvanR> that doesnt make any sense
10:52:52 <monochrom> it makes sense because EST and EDT are two different time zones
10:53:03 <EvanR> UTCTime has nothing to do with timezones
10:53:21 <monochrom> this is why IO is involved
10:53:22 <EvanR> "moments" don't have an intrisic time zone
10:53:36 <monochrom> but moment+location does
10:53:48 <EvanR> where is location coming into this?
10:53:50 <EvanR> or how?
10:54:13 <troydm> I have a FilePath, how do I remove last filename from it? or simply put how dow i get directory path from FilePath
10:54:39 <sm> takeDirectory
10:55:15 * EvanR begins tracing the source
10:55:18 <monochrom> moment UTC time 2016 April 10 17:53, location Hong Kong -> time zone HKT. change location to Toronto -> EDT
10:56:10 <puregreen> EvanR: getTimeZone tells you which timezone was used at your location at some moment in time
10:56:13 <EvanR> are you saying that this IO action is somehow divining the current location of the computer?
10:56:19 <troydm> sm: thx
10:56:30 <EvanR> "location" isnt an argument here, or mentioned
10:56:34 <monochrom> location Toronto, moment UTC time 2016 April 10 17:53 -> time zone EDT. change moment to UTC time 2016 Feb 29 17:53 -> time zone EST
10:57:01 <EvanR> and im not sure how it would know
10:57:12 <monochrom> the IO retrieves location, or location-equivalent things, such as the computer's "time zone file"
10:57:31 <puregreen> my laptop usually knows where it is (and changes the time zone accordingly)
10:57:34 <EvanR> if it used getCurrentTimeZone that would explain it
10:57:37 <puregreen> to be honest I'm not sure how it does it either
10:57:49 <EvanR> my computers do not know
10:58:10 <puregreen> my laptop must be smarter than your computers— ahem, enough of tomfoolery, sorry
10:58:12 <monochrom> but mine do
10:58:16 <EvanR> if its using the systems' timezone, then "current location" is inaccurate at best
10:58:33 <EvanR> as in longitude or gps
10:58:47 <EvanR> more importantly politicial body
10:59:01 <ertes-t6v> EvanR: most likely it takes the current time zone (say, CET) and figures out that at the given point in time it was CEST (summer time)
10:59:21 <EvanR> what is "it" in "it was CEST
10:59:23 <EvanR> "
10:59:33 <EvanR> im still kind of flabbergasted by this
10:59:45 <ertes-t6v> EvanR: here in germany the time zone changes spontaneously for daylight savings time
11:00:02 <ertes-t6v> two times a year we need to adjust our clocks by one hour
11:00:31 <EvanR> yeah, also it returns a TimeZone which is an offset, not a real time zone
11:00:57 <ertes-t6v> i think they are the same thing
11:00:59 <puregreen> EvanR: your computer knows the current Olson timezone, if I recall correctly
11:01:00 <EvanR> no
11:01:00 <puregreen> https://en.wikipedia.org/wiki/Tz_database
11:01:04 <ertes-t6v> at least to some approximation
11:01:04 <EvanR> yes
11:01:12 <puregreen> and an Olson timezone is more like a location than an actual time zone
11:01:17 <ertes-t6v> let me just check
11:01:32 <EvanR> the tz database has "time zone series" and there is a hackage package for that
11:01:57 <EvanR> TimeZone is just a number of minutes offset which is mildly useful depending
11:02:10 <EvanR> it lets you get UTCTime basically from a localtime and offset
11:02:31 <EvanR> going the other way requires historical data
11:02:57 <EvanR> this call seems to be treating UTCTime as some weird form of localtime ?
11:03:00 <ertes-t6v> EvanR: we currently have "summer time", so we're in time zone CEST…  now if i take the current time and add 300 days to it, the time zone is CET
11:03:26 <ertes-t6v> > getCurrentTime >>= getTimeZone . addUTCTime (300*86400)
11:03:26 <ertes-t6v> CET
11:03:28 <lambdabot>  Not in scope: ‘getCurrentTime’Not in scope: ‘getTimeZone’Not in scope: ‘addU...
11:03:30 <EvanR>  "in the returned time zone, at this moment in time, thats what time it was" is redundant
11:03:45 <ertes-t6v> EvanR: did that make sense?
11:04:11 <EvanR> "in the returned time zone, at the moment in time, you may have mistakenly thought this UTCTime was your localtime, but was off by this amount"
11:04:17 <ertes-t6v> just recently the time zone changed for us:  CET spontaneously became CEST *in the same location*
11:04:32 <monochrom> same here in Toronto
11:04:34 <EvanR> it doesnt use current time zone directly to do anything
11:04:45 <EvanR> (in the source)
11:04:57 <monochrom> I don't understand the complaint, if I assumed that it were not anal.
11:04:59 <ertes-t6v> i don't know *how* it does it, but that's apparently what it does
11:05:42 <EvanR> based on the types alone, and your nonsense or tangential answers about your countries timezones, i think the answer is you all have no idea what it does
11:06:11 <ertes-t6v> EvanR: http://lpaste.net/159423
11:06:46 <ertes-t6v> it tells me whether at the given point in time it was CET or CEST
11:07:30 <ertes-t6v> if you don't have daylight savings time in your region, you will probably always get the same result
11:08:27 <EvanR> i see, this is reaching outside the normal model of Data.Time to get at historical timezone data, and returning the answers in a weirdly baked form
11:09:40 <EvanR> the package timezone-series is a lot saner
11:09:43 <ertes-t6v> EvanR: it's 20:09 here in CEST, but in CET it would be a different local time
11:09:53 <EvanR> i get that
11:10:06 <ertes-t6v> now if you take this local time and add 300 days to it, you will get a value that *disagrees* with what the clock would tell
11:10:10 <ertes-t6v> it would be off by one hour
11:10:20 <EvanR> example of more saner
11:10:20 <ertes-t6v> that's where the getTimeZone comes in
11:10:35 <ertes-t6v> it's not Data.Time, which is insane
11:10:43 <ertes-t6v> it's the time zone that is
11:11:03 <ertes-t6v> and you *need* to handle it
11:11:19 <EvanR> i disagree, i think there is a better way
11:11:39 <EvanR> thats the first entry in Data.Time i noticed which is so mixed up
11:12:34 <ertes-t6v> there really isn't:  if i schedule something for 2016-12-01, 20:00, i need to be specific about which time zone i mean
11:12:43 <ertes-t6v> if i just say, "this time zone", i will be off by one hour
11:13:11 <ertes-t6v> so i say: "by this time zone, what's the time zone on 2016-12-01?" answer: CET
11:13:11 <EvanR> thats not necessarily true, theres many situations i could go through
11:13:20 <ertes-t6v> then i say, "ok, gimme 20:00 CET then"
11:14:25 <EvanR> its standard practice in MySQL and Postgres to only use UTCTime (encoded as the equivalent of LocalTime, by understanding)
11:14:47 <EvanR> displaying a scheduled time in the users configured timezone
11:14:59 <EvanR> so its really a view
11:15:01 <ertes-t6v> EvanR: the database is fine…  the trouble starts when you need to interact with the user
11:15:13 <ertes-t6v> because they will refer to their clocks, not UTC
11:15:28 <ertes-t6v> and *displaying* time is really not that much of a problem
11:15:35 <ertes-t6v> it's *reading* time that is
11:16:13 <EvanR> its technically not even possible ;)
11:16:34 <EvanR> if they pick a localtime in the future you cant know what future changes will be made to timezones
11:16:38 <ertes-t6v> also UTC isn't entirely free of problems either
11:16:48 <ertes-t6v> did you know that in a UTCTime it can be 23:60:30?
11:17:01 <puregreen> wait, can it?
11:17:02 <EvanR> it can't really
11:17:06 <ertes-t6v> it can
11:17:10 <ertes-t6v> leap seconds
11:17:11 <EvanR> it can be 23:60:00 or 23:60:01
11:17:19 <ertes-t6v> oh, yeah, sorry
11:17:20 <EvanR> but that is misleading
11:17:35 <ertes-t6v> it can be 23:60:00.5
11:17:37 <EvanR> UTCTime is really (Day, SecondsPastMidnight)
11:17:59 <EvanR> the way you display it can be used for all kinds of confusion
11:18:03 <ertes-t6v> that's why we have separate diff types:  NominalDiffTime pretends that leap seconds don't exist
11:18:14 <EvanR> the leap seconds dont actually matter because NominalDiffTime
11:18:28 <EvanR> and the fact that you often dont use time at all, youll use number of days 
11:20:09 <EvanR> so yeah you can convert a users choice of past localtime into UTC using timezone-series
11:20:23 <EvanR> but future conversions are liable to become invalidated
11:20:44 <EvanR> either way getTimeZone doesn't help
11:20:48 <ertes-t6v> EvanR: try this: fmap (\t -> addUTCTime 86400 t { utctDayTime = 86400 }) getCurrentTime
11:20:54 <ertes-t6v> it skips a day, so yes, it does matter
11:21:01 <EvanR> dont add 86400 seconds to add a day
11:21:03 <ertes-t6v> even with NominalDiffTime
11:21:50 <ertes-t6v> EvanR: you will have the same problem with every other way to add a day
11:21:57 <EvanR> add 1 day to the Day and use whatever time of day you want
11:22:01 <ertes-t6v> it's because you need to choose whether to round up or down
11:22:34 <ertes-t6v> EvanR: if you do that you get 23:60:00.5 on a day that doesn't have a leap second
11:22:34 <EvanR> i think people like to make time handling even more complicated to justify their own assertion that its really hard
11:22:39 <ertes-t6v> so you end up with an invalid date
11:22:49 <ertes-t6v> the proper way to add a day is by using NominalDiffTime
11:23:03 <EvanR> dont use any UTCTime's with leap seconds
11:23:09 <ertes-t6v> (or going through the gregorian calendar)
11:23:22 <ertes-t6v> EvanR: you don't get to choose what getCurrentTime returns =)
11:23:48 <ertes-t6v> the reason it's usually not a problem is that firstly it happens seldomly enough and that most operating systems don't even handle it
11:23:53 * EvanR sighs
11:24:12 <ertes-t6v> in linux you don't get skips, you get a slower/faster clock depending on the leap second (usually a slower one)
11:24:15 <EvanR> you will never get a leap second 
11:24:23 <EvanR> unix time doesnt have leap seconds
11:24:28 <EvanR> thats where the current time comes from
11:25:09 <troydm> is there a way to automaticly convert String to Text without typing pack everytime?
11:25:15 <troydm> not only for literals
11:25:28 <EvanR> youre looking for an implicit conversion
11:25:32 <troydm> but for variables too and for results of function applications
11:25:38 <geekosaur> no. haskell doesn;t do "automatic casting"
11:25:52 <ertes-t6v> EvanR: getCurrentTime can give you leap seconds…  it just doesn't on most systems
11:26:25 <EvanR> im just telling you from practical experience handling leap seconds in real life applications, that its completely pointless ;)
11:26:45 <EvanR> and causes people to be very frustrated with you as you explain the process at length in meetings
11:27:27 <EvanR> it is possible to structure your understanding of time in the application such that leap seconds do not exist (unless youre doing physics and for some ungodly reason using UTC for something)
11:28:13 <ertes-t6v> EvanR: same here…  use NominalDiffTime and be happy…  worst case: you'll be off by one second, which really isn't that much of an issue for most applications…  but there are some more complicated peculiarities related to time zones that you really do need to handle, at least if the application is for people in those time zones
11:28:30 <danilo2> Hello guys! :) Is there any deriveable typeclass in haskell that would construct a "phantom" data type instance? By phantom I mean something like `data Foo = Foo deriving (...)` and the constructor I'm talking about should be simmilar to Data.Default. I just want to tell `cons :: Foo` and get the Foo data type constructed. 
11:28:44 <EvanR> i only have times of day without leap seconds, and i add days by adding days, not seconds
11:29:25 <EvanR> as for timezones theres really not way to do it right
11:29:37 <EvanR> user input doesnt know future timezone changes
11:30:08 <ertes-t6v> well, in some cases you can use behaviour the user would *expect*…  and that involves getTimeZone =)
11:30:15 <EvanR> ....
11:30:31 <puregreen> not to mention that the user can expect 2 different things
11:30:46 <EvanR> im sure they are expecting getTimeZone :: UTCTime -> IO TimeZone to return "the timezone at that time"
11:31:12 <EvanR> because they are on acid
11:31:15 <ertes-t6v> the function is really just badly named, but it is useful
11:31:16 <statusfailed> danilo2: maybe I misunderstood, but does Data.Default work for you?
11:31:24 <EvanR> its badly explained
11:31:35 <danilo2> statusfailed: yes, but as far as I know I is not deriveable, is it ?
11:31:36 <statusfailed> oh, I don't know if that works with generics
11:31:36 <ertes-t6v> probably…  haven't read it
11:31:45 <EvanR> and is a poor substitute for timezone-series
11:31:45 <statusfailed> danilo2: sorry, I think you're right!
11:31:59 <statusfailed> that would be a neat project to understand generics though... hmm :D
11:32:31 <ertes-t6v> EvanR: no matter how you handle it abstractionwise, you still have to handle it
11:32:43 <ertes-t6v> i'm sure there are much better ways than getTimeZone
11:34:14 <danilo2> statusfailed: yep, making such generics for data.default would be nice
11:34:15 <EvanR> sure user input of date time is a thing
11:34:24 <EvanR> getTimeZone doesnt help with that
11:34:37 <ertes-t6v> and it's not really that bad:  user gave a time without referring to a time zone, you interpret it in the current one, apply getTimeZone, then interpret it again in the returned time zone
11:34:56 <EvanR> what??
11:35:00 <ertes-t6v> so when they say 2016-12-01, 20:00, you won't schedule something accidentally for 21:00 in CET
11:35:53 <EvanR> if you write that kind of code (assuming its even sound) no one will be able to maintain it because its crazy
11:36:08 <EvanR> i advocate straightforward methods
11:36:33 <EvanR> not obfuscated solutions contest entries
11:36:42 <ertes-t6v> EvanR: say that tonight daylight saving time ends and we will be back to CET…  if i negotiate a local meeting with you, i will say, "tomorrow 20:00"…  by convention we'll both assume that what is meant is 20:00 CET, not 20:00 CEST
11:36:58 <ertes-t6v> EvanR: again, it's not the handling that is crazy…  it's the convention itself!
11:37:04 <EvanR> its not
11:37:22 <ertes-t6v> EvanR: do you live in a region with daylight savings?
11:37:24 <EvanR> yes
11:38:58 <ertes-t6v> EvanR: today is time zone X, tomorrow Y…  user picks a date today: "tomorrow 20:00"
11:39:00 <EvanR> localtime's linear domain (excluding missing zones due to dst) is just another abstract model like everything else, calendars etc
11:39:04 <ertes-t6v> is that in X or Y in your application?
11:39:22 <EvanR> thinking of timestamps as having a timezone is mixing two totally different things in a confusing way
11:39:41 <EvanR> like you said, the right way to think of it is "we will meet today at 10PM and tomorrow at 10PM" and thats it
11:39:58 <EvanR> this is well defined in a model that doesnt do the equivalent of "everything is anything at any time sometimes"
11:40:12 <EvanR> timekeeping can be well typed
11:40:17 <ertes-t6v> EvanR: but what do you store in your data base?  a local time without a time zone?
11:40:36 <EvanR> it depends, for hours of operation we store local time of day
11:40:46 <EvanR> for event scheduling, utc
11:41:17 <EvanR> (localtime of day opening, plus duration youre open)
11:41:35 <ertes-t6v> that would be the latter, so you *have to* interpret it with respect to a certain time zone
11:41:41 <EvanR> no you dont
11:41:49 <ertes-t6v> alright then
11:42:38 <ertes-t6v> not sure how you go from LocalTime to UTCTime without using time zones, but fine…  i'm tired of this argument =)
11:42:55 <EvanR> im not sure which problem youre referring to
11:43:01 <EvanR> the hours of operation?
11:43:08 <ertes-t6v> EvanR: user gives you LocalTime, you need to store UTCTime
11:43:20 <ertes-t6v> that's the simplest instance of it
11:43:22 <EvanR> ok the same problem weve been talking about the whole time ;)
11:43:40 <ertes-t6v> yeah…  so how do you do it?  convert it with respect to the local time zone?
11:44:32 <EvanR> ill explain it again: first, this problem is impossible because they cant know future time zone changes. second, you ignore that and use timezone-series and the users detected timezone (not offset) to convert to Maybe UTCTime
11:44:49 <EvanR> Maybe because they might pick a non existent localtime
11:44:59 <EvanR> or just dont let them pick that time
11:45:10 <ertes-t6v> you could let them pick the time zone as well
11:45:15 <EvanR> you could
11:45:20 <EvanR> which is not an offset
11:45:32 <EvanR> its like Central Time (US & Canada)
11:45:58 <EvanR> which implies current and past shifts in DST rules
11:46:04 <ertes-t6v> the question really boils down to: how do you interpret "same time tomorrow", when given as loosely as that by a user?
11:46:11 <ertes-t6v> the technical answer is: "it's impossible"
11:46:34 <EvanR> that is possible because time zone rule changes wont unexpectedly happen tomorrow
11:46:54 <EvanR> so the above works
11:47:22 <ertes-t6v> well, it could mean that you need to skip anything from 23 to 25 hours depending on what the user *really* meant
11:47:27 <EvanR> (unless its 2 in the morning and same time tomorrow doesnt exist)
11:47:33 <EvanR> in which case reject their input
11:48:00 <EvanR> again it sounds like youre taking the worst possible case of what the user wants
11:48:08 <EvanR> which makes it more complex
11:48:21 <EvanR> if they are a power user then given the a utc picker
11:49:33 <ertes-t6v> EvanR: let me just tell you what my experience is…  maybe that explains why i'm making so much of it:  customer tells the application effectively, "tomorrow 14:00", and they are not "power users" in the sense that i could tell them to give me UTC times
11:49:51 <EvanR> sure
11:50:04 <ertes-t6v> what they *expect* is that i go by the local convention of just adjusting for time zone changes
11:50:14 <EvanR> sure
11:50:19 <ertes-t6v> so i do that
11:50:24 <ertes-t6v> and that's it
11:50:52 <EvanR> yes the above way covers basically any case of user inputting local time and the backend is using utc
11:51:14 <ertes-t6v> haven't had the pleasure to do it in haskell yet, but i certainly had to do it in the worst library in the worst language i've ever used in my whole life:  the zend framework, PHP
11:51:43 <EvanR> yeah basically every language has screwed up the entire process
11:52:14 <ertes-t6v> 'time' gets it right to *some* extent…  it's not a very friendly library, but it is explicit
11:52:32 <EvanR> time is much closer to the right thing (tm)
11:52:46 <EvanR> the TimeZone type is a little funky but works as a "just show them something" type
11:53:51 <EvanR> maybe i should write a book describing how bad and in what ways time libs are bad in all the major languages ;)
11:53:55 <EvanR> i wonder if that would sell
11:54:09 <new_guy> hi
11:55:03 <ski> hello new_guy
11:55:24 <new_guy> key ski
11:55:42 * hackagebot sarsi 0.0.1.0 - A universal quickfix toolkit and his protocol.  https://hackage.haskell.org/package/sarsi-0.0.1.0 (aloiscochard)
11:57:16 <new_guy> anyone on
11:58:31 <ertes-t6v> EvanR: i would buy and promote it =)
11:59:06 <ertes-t6v> EvanR: the trouble is not only in the time libraries, but the weird (a.k.a. "intuitive") conventions we have…  i'd say most people aren't even consciously aware that there is a convention to begin with
11:59:37 <EvanR> theyre not, but it is interesting to model those intuitive domains explicitly
11:59:55 <EvanR> and they end up not being that bad as long as you expose all the bits
12:00:09 <EvanR> leave nothing to the imagination of "time sucks"
12:02:09 <ertes-t6v> one way to do it could be to emulate time passing to up till the specified point in time and see what local changes have occurred
12:02:29 <EvanR> the arguably least weird "intuitive" convention of time is the current atomic time standard which models a unbroken real valued time base, its also completely inappropriate in your every day life and historical records
12:02:34 <ertes-t6v> and whether the given time is even fully determined
12:02:42 <EvanR> thats what timezone-series does
12:02:57 <ertes-t6v> ah, nice
12:03:06 <EvanR> it uses the tzdata base on the computer
12:03:17 <EvanR> actually you need a separate package for that
12:03:47 <EvanR> https://hackage.haskell.org/package/timezone-olson
12:04:39 <EvanR> heh "most olson timezone files dont contain leap second data"
12:07:13 <ertes-t6v> that looks like a very useful library…  thanks for the pointer
12:07:29 <ertes-t6v> compared to that, getTimeZone is indeed awkward
12:09:49 <EvanR> especially the trick you mentioned "convert to UTC using a given TimeZone (offset.. which is wrong due to it having no DST info except a "summertime" bool), then put the resulting UTC time into getTimeZone, then apply the TimeZone back to the original LocalTime)
12:09:53 <EvanR> "
12:11:27 <ertes-t6v> unfortunately it's the only way to do it with the 'time' interface
12:11:41 <ertes-t6v> unless you reinvent TimeZoneSeries
12:11:43 <EvanR> it doesnt even seem correct though
12:11:50 <EvanR> for that purpose
12:12:45 <ertes-t6v> it's ambiguous during the time of a clock change…  which time you get is up to getTimeZone's choice
12:12:53 <ertes-t6v> at other times it should work
12:13:03 <EvanR> before you even get to getTimeZone you cant get a proper UTC time
12:13:10 <EvanR> to use with it
12:13:45 <EvanR> you have to use a timezone series to get the utc time in the first place to pass into getTimeZone, after which youll just end up with the same answer you already have
12:14:07 <ertes-t6v> the process i described above is: get the UTCTime using the current local time zone, use getTimeZone, get the UTCTime using the returned time zone
12:14:15 <ertes-t6v> i should say TimeZone, not "time zone"
12:14:25 <EvanR> they input a date and a time (local time)
12:14:30 <EvanR> how do you get the utc ?
12:14:53 <EvanR> (to start your algorithm)
12:17:00 <athan> Can acid-state be distributed over multiple processes?
12:17:39 <EvanR> "Running two AcidState's from the same directory is an error but will not result in dataloss."
12:17:53 <EvanR> .. this is assuming you from same process though
12:18:13 <EvanR> but it seems to indicate there should be only 1 manager at a time
12:18:36 <ertes-t6v> EvanR: \lt -> do tz' <- getCurrentTimeZone; ZonedTime lt <$> getTimeZone (zonedTimeToUTC $ ZonedTime lt tz')
12:18:41 <ertes-t6v> where 'lt' is the user input
12:18:47 <athan> EvanR: dang :\ I think postgres / sql is better for that, then huh
12:18:52 * EvanR tries to parse that
12:19:31 <EvanR> ertes-t6v: right so you use the current offset, which could be wildly off if you go back far enough
12:19:40 <EvanR> and then you give the wrong time to getTimeZone
12:20:17 <EvanR> athan: those do have replication and stuff, acid state is an in-memory database
12:20:22 <ertes-t6v> EvanR: not sure what you mean
12:20:39 <athan> hmm, alright thanks EvanR!
12:21:10 <EvanR> ertes-t6v: instead of demanding a proof of correctness, i think ill just look for a counterexample
12:21:41 <ertes-t6v> EvanR: you will easily find one: use an argument that is either invalid or lies within a clock change
12:21:57 <EvanR> assuming the time is welldefined at all
12:22:05 <EvanR> i think you will get a utc time which is incorrect
12:22:20 <ertes-t6v> in the former case the action will return nonsense, in the latter case you get only one answer, when in fact there should be two
12:22:24 <ertes-t6v> getTimeZone does not account for that
12:22:27 <EvanR> thats a different topic
12:22:43 <ertes-t6v> let me see if i can find a counterexample myself
12:27:51 <ertes-t6v> EvanR: the only counterexamples i can find are the ones i mentioned
12:28:04 <ertes-t6v> near clock changes
12:29:13 <EvanR> what you mentioned is a region of time after the clock change
12:29:24 <EvanR> so an interval where the operation isnt single valued
12:29:54 <EvanR> but i am suspecting a snafu before that time
12:30:08 <EvanR> when you deal with DST rule changes (in US 2007)
12:30:32 <ertes-t6v> you mean something that isn't known in advance?
12:30:35 <EvanR> its just not obvious to me that it should work 
12:30:41 <EvanR> no
12:30:56 <EvanR> "use the wrong offset, then do some magic, then you have the right offset"
12:30:58 <zv> ah dst.
12:31:07 <zv> "the best laid times of mice and men often go awry"
12:31:24 <zv> or was it "plans"
12:33:14 <ertes-t6v> EvanR: if at t there is a clock change, then the function may get it wrong anywhere from t - minOffset to t + maxOffset
12:33:47 <ertes-t6v> it occurs, if the user gives a time that lies within the clock change or doesn't exist
12:33:59 <EvanR> only referring to times before the time change
12:34:11 <EvanR> not in the obviously invalid region
12:34:58 <ertes-t6v> i don't see how it would fail otherwise, but not saying that it can't
12:35:05 <ertes-t6v> this is obviously a fragile method
12:35:37 <jatentaki> hey, can somebody help with a newbie issue? I'm using way more memory than necessary and I don't know how to remedy it (probably annotating strictness, but where?) http://pastebin.com/ftCb1KCD
12:36:55 <ertes-t6v> jatentaki: your problem is sharing…  since the 'pairs' list is applied to twice, it won't get garbage-collected, so it will be built in memory
12:37:27 <ertes-t6v> jatentaki: the proper solution is to use a single fold (a strict left fold will work best)
12:37:39 <ertes-t6v> the quick-and-dirty solution is to make 'pairs' a function
12:37:44 <ertes-t6v> pairs () = ...
12:38:10 <jatentaki> I tried a version without the division (just returning a sum) and the memory still blew up
12:38:43 <ertes-t6v> jatentaki: do you compile with -O?  'sum' is defined in terms of foldl, not foldl'
12:38:54 <ertes-t6v> you should use: foldl' (+) 0
12:39:06 <ertes-t6v> (foldl' is from Data.Foldable)
12:39:08 <jatentaki> I'll give it a try
12:39:21 <EvanR> ertes-t6v: then a proof would suffice ;)
12:40:12 <leewz> i'm trying to figure why the Haskell Wiki's code blocks don't seem to respect browser font size.
12:40:56 <ertes-t6v> EvanR: a proof of a hypothesis for which counterexamples are already known?  that seems…  counterproductive =)
12:45:26 <mmercer> if i should use foldl' why is sum using foldl?
12:47:22 <davidMD> hey, so in a bunch of code I've been reading people tend to use a function rather than a normal data constructor. Is there a specific reason for this or is it simply stylistic?
12:48:13 <jatentaki> ertes-t6v: http://pastebin.com/AKTmpvUv I got the first part (summing) using foldl', but when I want to normalize it by the length (also computed using foldl', that's how it should be, right?) it exceeds reasonable memory bounds
12:48:32 <Cale> davidMD: Sometimes this is done just to give a place to enforce a constraint
12:49:09 <Cale> mmercer: In most cases, if you compile with optimisations, foldl will turn into foldl' for you automatically.
12:49:20 <mmercer> and if you don't?
12:49:47 <Cale> mmercer: If you don't, then the strictness analysis which does this won't happen
12:49:57 <davidMD> @cale thanks
12:49:59 <lambdabot> *** "thanks" gcide "The Collaborative International Dictionary of English v.0.48"
12:49:59 <lambdabot> thank \thank\ (th[a^][ng]k), n.; pl. {thanks} (th[a^][ng]ks).
12:49:59 <lambdabot>    [AS. [thorn]anc, [thorn]onc, thanks, favor, thought; akin to
12:49:59 <lambdabot>    OS. thank favor, pleasure, thanks, D. & G. dank thanks, Icel.
12:49:59 <lambdabot>    [thorn]["o]kk, Dan. tak, Sw. tack, Goth. [thorn]agks thanks;
12:50:01 <lambdabot> [35 @more lines]
12:50:21 <Cale> lol, lambdabot corrected my name to some dictionary lookup
12:50:44 * hackagebot chorale 0.1.2 - A module containing basic functions that the prelude does not offer  https://hackage.haskell.org/package/chorale-0.1.2 (FranzBenjaminMocnik)
12:50:47 <mmercer> so why isn't sum using foldl' insted
12:50:55 <Cale> mmercer: When the Prelude was originally constructed foldl' didn't exist.
12:51:16 <Cale> But also, you might want to use sum with certain numeric types for which addition can be lazier
12:51:24 <mmercer> why can't it be rewritten?
12:51:32 <Cale> (though I guess in that case, you'd probably want foldr rather than foldl)
12:52:47 <ertes-t6v> jatentaki: the idea is to fold only once
12:53:02 <jatentaki> and compute both sum and length at once?
12:53:19 <ertes-t6v> jatentaki: foldl' (\(x, n) dx -> (x + dx, n + 1)) (0, 0)
12:53:21 <ertes-t6v> yeah
12:53:30 <jatentaki> right, ok.
12:53:50 <ertes-t6v> that gives you the tight loop behaviour you want
12:54:52 <ertes-t6v> note that there is a singularity for []
13:00:28 <leewz> why doesn't the compiler choose the correct fold?
13:03:15 <Aruro> what is difference between unit testing? trying to look at HUnit and it does not look good :)
13:03:23 <Aruro> and property based testing
13:03:31 <Aruro> like QuickCheck
13:03:34 <ertes-t6v> leewz: because of the halting problem…  it's not obvious to the compiler that changing foldl to foldl' is semantically correct
13:04:34 <ertes-t6v> Aruro: property-based testing gives you quantifiers:  plus_Prop x y z = x + (y + z) == (x + y) + z
13:04:38 <bergey> Aruro: test cases list pairs of (input, expected output)
13:04:54 <leewz> but for certain cases, it is computable. halting problem just says that the general problem can't be solved.
13:05:26 <ertes-t6v> Aruro: HUnit doesn't give you "for all x, y, z, ..."…  if you use a quantifier with quickcheck, it generates random samples based on type information
13:05:34 <Aruro> bergey: well isnt property based testing useless? its just like running your comparison yoursel?
13:05:39 <bergey> property-based testing generates lots of inputs, tests that the output satisfies a given property.
13:06:05 <Grisha> Hi, I’m trying to code a little timetable - are there any chances to define something like data Hours = 8 | 10 | 12 | 14 | 16 | 16 deriving (Show, …)?
13:06:18 <Grisha> i.e. numerical constructors?
13:06:26 <ertes-t6v> Aruro: in quickcheck you can literally write:  prop_reverse xs = reverse (reverse xs) == xs
13:06:33 <Aruro> bergey: yes so i dont see any need for unit testing, why is it needed? isnt it done anycase by default?
13:06:56 <Aruro> ertes-t6v: yes, im trying to see why we need unit testing, seems pointless
13:07:10 <bergey> Aruro: You mean that property-based testing can subsume all the specific test cases?
13:07:23 <ertes-t6v> Grisha: the compiler won't know the numerical meaning of the individual constructors, so you'll need to build that yourself
13:07:33 <Aruro> bergey: well that too, and if u need specific tricky case u can do it yourself :)
13:07:49 <Aruro> bergey: i mean u would usually do it yourself anycase
13:07:54 <Grisha> ertes-t6v: in the ideal case, I would write smth like (8 :: Hours)
13:07:54 <ertes-t6v> Aruro: not sure…  i've never needed it, but it's there if you ever do =)
13:08:23 <ertes-t6v> Grisha: i doubt that that would be well defined, because you can only do that in terms of fromInteger (i.e. Num)
13:08:28 <Grisha> ertes-t6v: I could prefix them by H, like H8, H10, H12, but that looks ugly
13:08:38 <ertes-t6v> Grisha: in other words: if you want to make sense of (8 :: Hours), then in haskell you must also make sense of (9 :: Hours)
13:08:49 <Grisha> ertes-t6v: I see now
13:08:51 <Aruro> ertes-t6v: just i saw today in job description that people separate unit and property based testing , now that we started to think about it im not sure they understood themselfs the point.
13:08:58 <ertes-t6v> Grisha: and in general you'll also need  to make sense of 8 + 9 as well
13:08:58 <bergey> I often write only property tests, but if I had more time, I'd probably add a few specific cases also.  They're easy to read for folks who like to treat tests as part of the documentation.
13:09:32 <Grisha> ertes-t6v: but what if I don’t want my Hours to be added or multiplied?
13:09:49 <ertes-t6v> Grisha: then you don't write a Num instance and don't get integer literals
13:10:04 <Aruro> bergey: yes , so its more for documentation?
13:10:24 <Grisha> ertes-t6v: you’re saying that integer literals as constructors are possible only for Num instances?
13:10:31 <ertes-t6v> Aruro: i'm pretty sure that HUnit does have its use cases, but purely from an abstraction standpoint you're right: property-based testing covers unit testing
13:10:56 <ertes-t6v> Grisha: yes, because '8' is read as 'fromInteger theIntegerEight'
13:11:02 <leewz> for commutative associative functions, it could feel free to choose foldr vs foldl. for functions lazy in the first argument (as https://wiki.haskell.org/Foldr_Foldl_Foldl%27 puts it), it could use foldl over foldl'.
13:11:04 <kadoban> Grisha: Integer literals are of type :: Num a => a
13:11:26 <Grisha> kadoban: I see, thanks
13:11:30 <kadoban> :t 20
13:11:31 <lambdabot> Num a => a
13:11:35 <Grisha> ertes-t6v: starting to make sense to me now
13:11:52 <kadoban> If you should actually use that fact for your purposes kind of depends.
13:12:31 <Grisha> hm
13:12:45 <dolio> leewz: Why don't you write a GHC plugin that always makes the right decision about this?
13:12:51 <dolio> Should be easy.
13:13:10 <Grisha> then data Hour = H8 | H10 | H12 | H14 … deriving(whatever I need from them) seems to be the simplest choice for my little project
13:13:35 <kadoban> Grisha: Sounds possible, yeah.
13:13:42 <leewz> dolio: your snark missed the part where i said that the general problem might not be solvable, but a subset of it could be.
13:14:02 <mmercer> hang from a binary tree
13:14:04 <Grisha> kadoban, ertes-t6v: thanks a lot
13:14:18 <dolio> Then solve your easy subset.
13:15:11 <leewz> i'm asking questions here to get counterarguments to think about and broaden my understanding?
13:15:20 <leewz> what's your issue?
13:15:58 <ertes-t6v> leewz: the compiler doesn't understand the nature of left folds…  it can often infer some strictness properties and optimise foldl to *effectively* become foldl'
13:16:00 <Aruro> ertes-t6v: sry can u repost your last comment on HUnit, was away
13:16:26 <ertes-t6v> leewz: that's what happens when you use -O, but it can't happen in general, because that's undecidable
13:16:46 <ertes-t6v> it's the halting problem
13:16:48 <mmercer> i was told to always use foldl'.. so why isnt\' compiler doing the same? why not do foldl = foldl'
13:17:06 <leewz> so basically it does do that, if you tell it to try
13:17:12 <ertes-t6v> Aruro: i'm pretty sure that HUnit does have its use cases, but purely from an abstraction standpoint you're right: property-based testing covers unit testing
13:17:17 <JoeyAdams> Something something semantics involving undefined.
13:17:37 <Aruro> ertes-t6v: ty
13:17:41 <ertes-t6v> leewz: foldl is one of the few cases when it can infer it
13:18:06 <ertes-t6v> but only as an optimisation (strictness analysis), so only with -O
13:19:03 <leewz> while reading about the different folds, i was also wondering why it couldn't analyze the memory use of thunks vs their result and, when nearing memory limits, decide to evaluate some thunks to reduce memory use.
13:19:42 <ertes-t6v> leewz: same reason it doesn't do CSE: there is no way to guarantee that it will be better…  it might be worse
13:19:45 <puregreen> regarding foldl': is http://www.well-typed.com/blog/2014/04/fixing-foldl/ an April Fools' joke or not? It doesn't read like one but maybe I just don't see it
13:19:56 <ertes-t6v> leewz: (we do CSE in simple cases, but not in general)
13:20:14 <leewz> of course, not in general
13:21:16 <jatentaki> ertes-t6v: http://pastebin.com/GpKpgbtw here I have the program rewritten as a single foldl', but compiled with -O it still exceeds 2gb RAM. I don't know about the semantics of (x, y) = function... - does it call the function each time I ask for either x or y? Or just once and stores the results?
13:22:05 <athan> person
13:22:08 <athan> derp
13:22:13 <ertes-t6v> leewz: predicting the memory behaviour of a thunk is way more difficult than optimising strict functions to memory-efficient functions…  and i don't think the result would pay off, but of course that's just a guess
13:22:49 <leewz> i was thinking compile-time analysis
13:23:37 <ertes-t6v> jatentaki: is there a way to get rid of those green markers?  if not, please paste to lpaste.net instead
13:24:08 <jatentaki> I think that's some dumb formatting thinking the ' marks beginning of a string (python style). sure, I will
13:24:09 <ertes-t6v> leewz: that boils down to the halting problem again…  in order to do the analysis you effectively have to run the program
13:24:30 <leewz> anyone i would talk to for issues in the wiki's coding? e.g. i'm trying to figure out why "monospace" doesn't respect browser font size setting.
13:25:11 <jatentaki> http://lpaste.net/159434
13:25:26 <leewz> that's why it would be an if-possible rather than a general thing. but yeah, might not be worth it compared to other optimizations.
13:26:02 <leewz> the apostrophe-as-quote thing is an issue on the haskell wiki, too.
13:26:49 <ertes-t6v> jatentaki: oh yeah, that's not properly strict yet…  the easiest way to fix that is with BangPatterns:  add (x', n') dx = let !x = x' + dx; !n = n' + 1 in (x, n)
13:27:14 <ertes-t6v> jatentaki: it's because tuple fields are not strict, so it's only strict in the tuple itself, not its components
13:27:50 <jatentaki> is this just a byproduct of how the compiler works or is there some merit to being strict just in tuple?
13:28:02 <udrop> What's the best way to handle errors in Haskell? I have an IO () action that may fail to succeed. Client code may ignore the error or not, their choice. Default behavior should be to ignore. Should I return IO (Either error ())??
13:28:40 <ertes-t6v> jatentaki: (,) is defined that way:  case someTuple of (x, y) -> ...  -- at this point we know that it's a defined tuple, but the components are still not evaluated
13:28:42 <jatentaki> I mean a tuple contains fixed amount of stuff, you can tell in advance what exactly it is and how it is laid out. the only thing that can differ are the contents
13:29:10 <jatentaki> ok
13:29:15 <ertes-t6v> jatentaki: a common algorithmic approach in haskell is:  produce lazily, consume eagerly
13:29:37 <ertes-t6v> so our data structures are often non-strict by default
13:30:43 <kadoban> ertes-t6v: Sounds like my approach to life as well.
13:30:49 <ertes-t6v> but for cases when it's really not that common to produce lazily, there are strict ones as well, like the vector types from the 'linear' package:  you'll probably never need a non-strict 3D vector
13:30:52 <jatentaki> yup, now it works as supposed to
13:31:50 <jatentaki> that was way more advanced than what I expected it to be o.O
13:32:16 <ertes-t6v> jatentaki: first time haskell? =)
13:32:37 <jatentaki> more or less, did some reading and several examples like a year ago
13:32:45 <jatentaki> and now resuming the experience
13:33:29 <ertes-t6v> jatentaki: i tend to expose newcomers to strictness matters as early as possible, but in a more gentle way
13:33:52 <ania123> http://www.worldcat.org/title/recursive-equivalence-types/oclc/3199435/editions?editionsView=true&referer=br
13:33:57 <ania123> does one has access to that pape?
13:34:00 <ania123> can one help me?
13:34:53 <jatentaki> I remember last time I gave up after building a kind-of-complex program and then running into memory problems. Felt like 'ok, there's some 100 places I could make strict and I have no idea where.'
13:35:07 <Aruro> ania123: its book not paper
13:35:57 <ertes-t6v> jatentaki: strictness always boils down to two things: pattern-matching and sharing
13:36:09 <ertes-t6v> if you understand those two, you understand haskell memory behaviour
13:36:14 <ertes-t6v> (in a nutshell)
13:36:32 <ertes-t6v> s/haskell/GHC haskell/
13:38:47 <monochrom> in fact, there are some 100 places you should make stricter, and some other 100 places you should make less strict.
13:39:17 <Aruro> monochrom: model of evlatuation should be language extension
13:39:37 <udrop> anyone? Is returning IO(Either Error ()) sane?
13:39:54 <monochrom> but the overarching meta-problem is the myth that you can write 1000 lines in one go, and then, only then, you can "debug" problems one by one.
13:40:46 <Aruro> udrop: more than sane, contol.exception does that
13:40:47 * hackagebot tempo 0.1.0.0 - Command-line tool to log time-tracking information into JIRA Tempo plugin  https://hackage.haskell.org/package/tempo-0.1.0.0 (trubeko)
13:40:49 <monochrom> this meta-problem is not going to just affect program efficiency. because merely functional correctness (giving the right answer at all) is already at stake.
13:41:44 <Aruro> monochrom: how, its just model of evaluation?
13:41:50 <monochrom> I don't write 1000 lines in one go and then debug. not even 100 lines. every time I add one line, even one token, I already think "what is its consequence?"
13:42:34 <monochrom> if a certain token will cause a problem, with 99% chance I already catch it at the time it is added.
13:42:58 <jatentaki> well it was more of a case where I was running tests on some small sequence of let's say 100 elements
13:43:12 <jatentaki> so I could comprehend the results it spat out at me and all
13:43:27 <monochrom> there are a lot of unit testing and bottom-up building at the 5-line level, even 5-token level.
13:43:27 <jatentaki> and when I switched to big inputs it clogged up
13:43:48 <monochrom> by the time you have 100 lines it is already too late to debug, answer-wise or efficiency-wise
13:43:54 <ertes-t6v> as soon as you understand the evaluation of pattern-matching and the sharing behaviour, you start to program with that in mind
13:44:18 <ertes-t6v> and that leads you to the "good" pattern by itself:  produce lazily, consume eagerly
13:44:31 <jatentaki> but yeah, the way I was approaching the task wasn't "professional" in any way
13:44:37 <jatentaki> and it isn't today either
13:45:11 <Aruro> jatentaki: its not about professional, this question is weak point of current language paradigm
13:45:25 <Aruro> jatentaki: somebody will invent something nice soon
13:45:52 <ertes-t6v> jatentaki: it's the different approach in problem solving…  you need to rewire your brain a bit, if you came from other mainstream languages
13:46:06 <ertes-t6v> don't worry, it'll make click soon =)
13:46:13 <Grisha> it’s stupid me again
13:46:31 <ertes-t6v> Grisha: how can stupid us help stupid you? =)
13:46:35 <Aruro> Grisha: did u watch futurama episode about Leonardo?
13:46:46 <jatentaki> now you two, Aruro and ertes-t6v gave two completely orthogonal answers. Or is it me not grasping the common ground?
13:46:47 <Aruro> :D lol nice
13:46:58 <Grisha> I’m trying to import Text.Blaze.Html5 and running this single-line program in ghci produces “ouldn't match expected type ‘IO t0’
13:46:58 <Grisha>                 with actual type ‘Html -> Html’
13:46:59 <Grisha>     Probable cause: ‘main’ is applied to too few arguments
13:47:00 <Grisha>     In the expression: main
13:47:01 <Grisha>     When checking the type of the IO action ‘main’”
13:47:18 <ertes-t6v> jatentaki: i think Aruro was just saying the same thing in different words =)
13:47:27 <Grisha> Aruro: no, never watched Futurama ;(
13:47:29 <ertes-t6v> but "current language paradigm" is ambiguous
13:47:37 <aupiff> I have been thinking about lambda abstraction by convention being right-associative. Given that left- and right-associativity are simply a means to introduce a shorthand for non-associative operators (to eliminate parens), I'd assume that any operation we decide to treat as right-assoc. must be produce ambiguous terms if no associativity is assumed and parens are excluded. How could we misinterpret `\x.\y.
13:47:43 <aupiff>  x y x`? as `((\x.\y.) x y x)`? What would that mean?
13:47:48 <jatentaki> he said about someone inventing something soon. And you are talking about *me* needing to rewire my brain
13:48:05 <Grisha> so importing Text.Blaze.Html5 implicitly calls some main somewhere
13:48:31 <Aruro> jatentaki: no, he said u just need a bit of practice with it
13:48:49 <ertes-t6v> aupiff: the way the grammar is laid out, that one is not ambiguous…  the "left-associated" variant is a syntax error
13:48:52 <ralu> how long is queue for having hackage doc build?
13:49:04 <monochrom> aupiff: that is not the point of contention. the point is "(\x . x) y" vs "(\x. x y)", "(f g) x" vs "f (g x)", etc.
13:49:05 <ertes-t6v> ralu: takes 5-10 minutes for me
13:49:54 <ralu> Can i upload package withdocs build so they are available on hackage?
13:50:08 <jatentaki> yeah. And you (Aruro) said someone was going to find "something nice soon", as if it was a language problem, not a inherent software design problem. But I think we can cut the topic since it's not going to take us far (I don't think it is) 
13:50:12 <aupiff> monochrom: yes, that makes sense, but what if we have nested lambdas?
13:50:13 <monochrom> jatentaki: simply merge the two answers into: something will be invented to rewire your brain
13:50:32 <jatentaki> ok, sounds creepy
13:50:33 <Aruro> jatentaki: haskell is focused now on its strongest side - equational reasoning, the other side - evaluation is a bit messy for now. 
13:50:40 <ertes-t6v> Grisha: not sure what the problem is, but there is a HTML5 element called 'main', and that probably interferes with your main *action*, also called 'main'
13:50:57 <ertes-t6v> Grisha: blaze-html modules are supposed to be imported qualified:  import qualified Text.Blaze.Html5 as H
13:51:16 <monochrom> I don't think nested lambda poses extra ambiguity
13:51:29 <Grisha> ertes-t6v: perfettomenti, thanks
13:52:13 <ertes-t6v> Aruro: i don't think evaluation is messy
13:52:24 <Grisha> ertes-t6v: the online tutorial suggests an unqualified import
13:52:29 <Grisha> ertes-t6v: strange
13:52:30 <ertes-t6v> Aruro: it just takes time to learn and get used to, if you came from other mainstream languages
13:52:33 <aaakfp`> Is anybody using the stack image compose system?  I find it very useful to use docker-compose for my systems, but when I need to debug, I can't find any support at all.
13:52:38 <Grisha> ertes-t6v: or it’s probably me misunderstanding smth
13:53:07 <ertes-t6v> Grisha: not familiar with that one, but blaze-html introduces loads and loads of names that interfere with the Prelude
13:53:08 <Aruro> ertes-t6v: i agree, thats why 'a bit' :)
13:53:13 <ertes-t6v> Grisha: for example 'head'
13:53:34 <Grisha> ertes-t6v: of course
13:53:36 <ertes-t6v> Grisha: with the qualified import 'head' will refer to Prelude.head, the list function, while 'H.head' will refer to the <head> element
13:53:42 <Grisha> ertes-t6v: I see
13:53:55 <aupiff> monochrom: in the example `\x.\y. x y x` what would be the left-assoc. misinterpretation? `((\x.(\y. x)) y) x`?
13:54:17 <ertes-t6v> Grisha: the 'lucid' library appends underscores to all elements, so that you can import unqualified:  html_, head_, etc.
13:54:48 <ertes-t6v> it's similar to blaze-html in purpose, but offers a slightly different API
13:55:12 <monochrom> ertes-t6v: I'm going to use "I did a PhD thesis on this" to sound authoritative, but: lazy evaluation is a bit more difficult than eager. I wouldn't say messy. The right word is non-local. For each fragment of code you have to keep asking "I don't know its cost until you tell me how much of its answer is used by the rest of the program", which is pretty taxing.
13:55:18 <webstrand> I cant seem to use Data.Numbers.Primes, after installing into a cabal sandbox, only these files exist: http://dpaste.com/0C7C4C6 . runhaskell -v says it's looking for a .hs file but it doesn't exist. Is the primes package broken?
13:55:19 <Grisha> ertes-t6v: I will certainly take a look at lucid
13:56:15 <EvanR> ok i finally figured out why my async-heavy code was mysteriously blocking on reading Chans when there was obviously stuff going into the chan: i have 1 thread which is execute long running code
13:56:16 <monochrom> in fact the reason I chose this thesis topic was that I hoped to show that lazy evaluation is not harder. well, when I finished, I saw why it was harder, and exactly by how much.
13:56:35 <EvanR> and it seems that some of the other threads cant ever run, but some can
13:56:47 <ertes-t6v> monochrom: yeah, i agree…  i'll just say that it's not as bad as it sounds; you get used to it
13:56:51 <ClaudiusMaximus> webstrand: runhaskell won't know about the sandbox unless you cabal exec runhaskell
13:57:00 <nocturne777> EvanR: have you had a chance to think on the example I had a question about? :)
13:57:13 <Aruro> webstrand: did u try compiling it?
13:57:14 <aupiff> since left-assoc. is just a short-hand, I'd like to decide what the wrong interp. of a nested lambda term would be with all parens explicitly shown so that we could forget about l/r-assoc.
13:57:16 <EvanR> can you paste the example
13:57:21 <monochrom> I certain don't regret doing that thesis or staying with haskell. :)
13:57:49 <ertes-t6v> webstrand: not solving your problem, but whenever the term "prime number" comes up, i suggest taking a look at the 'arithmoi' library =)
13:58:19 <EvanR> i wish arithmoi had a discrete log function
13:58:28 <Aruro> monochrom: lazy evaluation is too broad term, inside of it can be many different algorithmical approaches
13:58:43 <webstrand> ClaudiusMaximus: That solves my problem, I thought sandboxing was automagic based on cwd.
13:59:28 <ertes-t6v> EvanR: BSGS and pollard rho are simple enough to implement, if you ever need it…  for quick-and-dirty purposes pari/gp has a good implementation, too
13:59:32 <Aruro> monochrom: its certainly very good topic to do phd in, btw
13:59:50 <geekosaur> nope, ghc doesn't grok either cabal or stack sansboxes so if you're not using the sandbox tools you'll need to use cabal exec or stack exec as appropriate
13:59:56 <EvanR> ertes-t6v: ok but... can you paste pollard rho into arithmoi ;)
14:00:20 <ertes-t6v> i think i have a BSGS implementation somewhere, but not rho, sorry
14:00:41 <monochrom> w00t pollard rho
14:00:44 <geekosaur> (also develop the habit of "cabal exec --"/"stack exec --", otherwise anything that loiks like an option will be passed to cabal/stack instead of your program)
14:00:58 <EvanR> question, if i have a thread which seems to be hogging the capability because its stuck doing some long running pure code, what do i introduce into that pure code to get it to preempt?
14:01:23 <EvanR> (this code is coincidentally a brute force discrete log loop)
14:01:28 <ertes-t6v> EvanR: i usually just invoke gp =)
14:01:28 * monochrom shows off: Pollard ρ
14:01:29 <lpaste> nocturne777 pasted “concurrently” at http://lpaste.net/159435
14:01:37 <EvanR> ertes-t6v: gp?
14:01:53 <hexagoxel> garbage polluter
14:01:56 <ertes-t6v> EvanR: a command line calculator with a focus on algebra and number theory
14:02:00 <EvanR> oh
14:02:10 <ertes-t6v> EvanR: it has lots of useful NT algorithms
14:02:17 * hexagoxel guessed wrongly :pp
14:02:23 <ertes-t6v> EvanR: the package is usually called 'pari' or 'parigp' or something along those lines
14:02:26 <nocturne777> EvanR: I pasted the example. it is the simplified version of geturl9.hs here => http://chimera.labs.oreilly.com/books/1230000000929/ch11.html#sec_conc-symmetric
14:02:30 <puregreen> would yield work? http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:yield
14:02:33 <Aruro> is anybody attempting to write haskell CAS like macsyma? or waiting to start?
14:02:36 <EvanR> yield is IO
14:02:41 <monochrom> but parigp doesn't count as Haskell...
14:02:41 <puregreen> oh, right
14:03:07 <monochrom> unsafePerformIO yield. I think this can be proved pure.
14:03:18 <EvanR> but will it yield more than 1 time?
14:03:36 <monochrom> but then you have to code up the right granularity of yielding, too
14:03:41 <ertes-t6v> EvanR: you can also introduce parallelism
14:03:55 <nocturne777> EvanR: the example I pasted finishes in 3 seconds. But I still don't understand how that is possible given that in concurrently's implementation waitBoth blocks the main thread and thus prevents it from processing other tasks 
14:04:07 <EvanR> nocturne777: are you using -threaded
14:04:24 <EvanR> ertes-t6v: how?
14:04:42 <nocturne777> EvanR: yes, I tested with -threaded  and  "cabal run +RTS -N4"
14:04:47 <ertes-t6v> EvanR: use 'par' in a way that makes the code wait for the result from time to time
14:05:15 <monochrom> wait, par doesn't wait, pseq does
14:05:35 <EvanR> why is this happening anyway? somehow my code is not doing memory allocation?
14:05:36 <monochrom> but then maybe par also causes yielding
14:05:43 <monochrom> right
14:05:46 <ertes-t6v> in any case introduce waiting or yield yourself
14:05:49 <ertes-t6v> or cause GC
14:05:53 <EvanR> that is crazy
14:06:04 <nocturne777> EvanR: in either case (threaded or not) the code finishes around 3secs
14:06:05 <EvanR> i am icrementing an Integer and doing SHA512 on it
14:06:15 <monochrom> this is a time when you say: GHC optimizer is too good
14:06:24 <ertes-t6v> EvanR: GHC probably optimises a lot of your allocation/GC away and gives you a tight loop
14:06:26 <ertes-t6v> hehe
14:06:34 <EvanR> i am astounded at thtis
14:07:07 <EvanR> im doing SHA512 on a string version of the integer, how is there no allocation...
14:07:07 <ertes-t6v> EvanR: an easy way out is to just use multiple OS threads
14:07:23 <EvanR> ah forkOS, i tried forkOn but it didnt help
14:07:24 <hexagoxel> nocturne777: it does not prevent "other tasks", because there are not other tasks. because you fold, the second parameter to `concurrently` runs your rest list.
14:07:29 <ertes-t6v> that looks like a tight loop
14:07:37 <ertes-t6v> EvanR: not forkOS, but +RTS -N2
14:07:44 <EvanR> i tried that
14:07:46 <monochrom> code optimization is a field of optimization what humans think can't be automatically optimzed, and pessimizing what humans think can be automatically optimized.
14:08:09 <hexagoxel> nocturne777: concurrently [..] (concurrently [..] [..])
14:08:20 <ertes-t6v> EvanR: wait, is it calling a C implementation of SHA?
14:08:27 <hexagoxel> the outer concurrently will wait, but only after starting the inner concurrently.
14:08:28 <EvanR> its from crypto hash
14:08:53 <EvanR> but its returning from the sha512 a lot
14:09:06 <ertes-t6v> check whether they are C implementations…  once the FFI is involved, concurrency gets awkward
14:09:53 <ertes-t6v> one possible way this might go wrong: the C function is entered and left a lot, but there is no allocation inbetween
14:10:01 <EvanR> its doing several C calls per hash
14:10:05 <ertes-t6v> so there is simply no opportunity for a context switch
14:10:22 <ertes-t6v> in this case yielding is probably your best bet
14:10:37 <EvanR> i guess i can rewrite it to be in IO
14:10:43 <EvanR> but this seems silly
14:10:59 <EvanR> especially if i cared about performance
14:11:01 <ertes-t6v> i wouldn't…  this is one of the rare cases when unsafePerformIO is okay
14:11:10 <ertes-t6v> unsafePerformIO yield `seq` ...
14:11:14 <EvanR> how do you use unsafePerformIO in a way that even works?
14:11:20 <EvanR> oh
14:12:09 <EvanR> i feel like im doing work to unoptimize it
14:12:23 <ertes-t6v> nice :: a -> a; nice = seq (unsafePerformIO yield)
14:12:26 <ertes-t6v> you are =)
14:12:26 <EvanR> trying forkOS first
14:12:54 <ertes-t6v> you're making the code slower, a.k.a. "nicer" =)
14:12:57 <EvanR> (this is all without -O2 or anything)
14:13:30 <ertes-t6v> -O isn't far from -O2…  usually -O2 will just make the compiler take longer without benefit
14:13:56 <EvanR> nope
14:14:11 <EvanR> not using -O at all... and forkOS didn't help
14:14:39 <ertes-t6v> forkOS only helps when the C functions are marked unsafe, i think
14:15:32 <EvanR> what principle am i missing here, "don't use concurrency for cpu-intensive tasks", or is there just a flaw in the design of the runtime
14:16:10 <ertes-t6v> you're really at an edge case here (long tight loop + C + concurrency), and i don't see any other way than to introduce context switching opporunities manually
14:16:26 <ertes-t6v> even just introducing a progress bar would already solve your problem
14:16:40 <EvanR> progress bar = IO
14:16:51 <nshepperd> ]]]]]]][[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[-17:06:12           EvanR | i am astounded at thtis
14:16:58 <EvanR> that is rewriting it in IO
14:17:13 <ertes-t6v> EvanR: yes, but separately…  all you need in the API is feedback…  you can do that in a number of pure ways, e.g. callbacks or streaming abstractions
14:17:39 <ertes-t6v> no IO/MonadIO involved in your hashing function itself
14:18:02 <EvanR> this is one line of code to loop through looking for solutions to b^e = x mod n
14:18:15 <ertes-t6v> solving for e?
14:18:19 <EvanR> exploding it into an unsolicited GUI seems... lol
14:18:51 <EvanR> yes, it works great for n = 2^21 or less ;)
14:19:14 <EvanR> it just freezes half the threads in the process
14:19:26 <ertes-t6v> EvanR: yourFavouriteFinder . zip [0..] . iterate (\x -> x*b `mod` n) $ 1
14:19:44 <EvanR> attempts to control which capability its own dont seem to work, probably because async doesnt make a choice
14:22:31 <ertes-t6v> EvanR: find (\(e, x) -> e `seq` x == 2) . zip [0..] . iterate (\x -> 5*x `mod` 1048583) $ 1
14:22:45 <ertes-t6v> solves 5^x ≡ 2 (mod 1048583) =)
14:22:56 <ertes-t6v> and quickly, too
14:23:12 <aupiff> Hear me out on this. I think saying that abstraction is right associative is vacuous. We know that 1. application is higher precedence than abstraction. Which means `\x. x y` has to be interpreted as `(\x. (x y))`
14:23:24 <nocturne777> hexagoxel: isn't it actually like "concurrently a1 (concurrently a2 (concurrently a3 []))" ?
14:23:32 <aupiff> So the only interesting cases to consider are nested lambda cases
14:24:02 <hexagoxel> nocturne777: my pattern is compatible with that, or was hoping to express such.
14:24:16 <hexagoxel> nocturne777: so, yes.
14:25:38 <aupiff> Case A: `\x. \y. x y x` Case B: `\x. x z (\y. x y)`
14:26:07 <nocturne777> hexagoxel: what I don't understand is that in the innermost () concurrently is going to wait for a3 to finish for 3 seconds. after that is going to have to wait on a2 for three seconds and after that on a1
14:26:18 <aupiff> I'd argue that being told nothing about lambda assoc. and only that application has higher precedence, we have to come to the standard interpretation of both case A and B.
14:26:32 <aupiff> does someone think this is wrong?
14:27:39 <nocturne777> hexagoxel: how can the stack start unwinding itself immediately without 3 seconds of wait for each "a" ?
14:27:45 <monochrom> aupiff: lambda abstraction is not an infix operator. questions like "does it have precedence 5?" have the same answer as "does it wear sun glasses?"
14:28:30 <ertes-t6v> even if you make lambda abstraction an infix syntax, left-associating it does not make sense
14:28:36 <hexagoxel> nocturne777: because a2 is/was already running, like, concurrently :p
14:28:43 <monochrom> as another example, it is neither lower precedence than application, nor shorter than Magic Johnson
14:29:06 <aupiff> monochrom: right, so books and papers published in peer-reviewed journals should never say it has left- or right-assoc.. but they do.
14:29:24 <monochrom> how you would parse "\x. x y" has be to specified outside the infix precedence system. this thing is not infix.
14:29:39 <monochrom> ok, but I haven't read them.
14:29:50 <monochrom> I have only read Haskell 2010, and it doesn't make that mistake.
14:29:53 <ertes-t6v> aupiff: let me write "x -> y" instead of "\x. y"…  (x -> y) -> z does not make sense
14:30:13 <ertes-t6v> you have to read it right-associatingly
14:30:28 <chasm> say we are accumulating a string in a state monad... instead of doing (modify (++s)), is it better to keep a fn in there and do (modify (\f s' -> f s ++ s')) (to avoid quadratic append)
14:30:38 <hexagoxel> nocturne777: the waiting on both children _does_ happen from tail back to front, but the operations are started concurrently, and finish at roughly the same point.
14:30:46 <monochrom> it says "greedily slurps everything to the end or to a suitable closing parentheses" which is a sensible description of one choice.
14:30:55 <aupiff> (x -> y) -> z makes sense in the types doesn't it?
14:31:07 <ertes-t6v> aupiff: if you make it "infix" in that way, you could say that it's read right-associatingly…  but usually we use a lambda syntax that isn't infix at all
14:31:38 <dolio> (x -> y) isn't a variable.
14:31:38 <ertes-t6v> aupiff: let me use a different syntax: instead of "\x. y" i'll write "x becomes y"
14:31:54 <ertes-t6v> x becomes (y becomes z) -- makes sense
14:32:04 <ertes-t6v> (x becomes y) becomes z -- non-sense
14:32:12 <monochrom> ooohhh, that gets interesting
14:32:49 <monochrom> x ↦ sin x + y
14:32:53 <aupiff> I don't think that's rigorous. (Int -> Int) -> Int makes perfect sense.
14:33:21 <dolio> That's not the same arrow.
14:33:26 <ertes-t6v> aupiff: haskell's (->) is not the "_ -> _" i've introduced as a substitute for "\_. _"
14:33:33 <aupiff> I'm aware it's not the same arrow
14:33:49 <Aruro> aupiff: i think associativity is wrong term here, lambda abstraction is term not operation
14:33:54 <aupiff> when we talk about left and right assoc, we shouldn't be considering the interpretation
14:33:57 <monochrom> moar arrows: → ⇒
14:34:15 <aupiff> we should be talking about what parens we got away with not writing
14:34:32 <ertes-t6v> aupiff: your grammar can totally allow "(x becomes y) becomes z", but it wouldn't make sense for it to read "x becomes y becomes z" as that
14:35:28 <EvanR> ertes-t6v: nice = seq (unsafePerformIO yield) doesnt seem to be doing anything...
14:35:33 <ertes-t6v> it *could* make sense to read "x becomes f x" as "(x becomes f) x", but "x becomes (f x)" is usually more useful
14:35:44 <polyaletheia> Hey should my package include a stack.yaml file as well as a cabal file, if I want to add it to Stackage?
14:36:23 <ertes-t6v> EvanR: you'd have to structure your algorithm in such a way that the x in 'nice x' is needed to continue…  then it will cause a yield
14:36:29 <monochrom> I wonder if the optimizer is so smart it eliminates "unsafePerformIO yield" altogether...
14:36:30 <dolio> You can format the monad rule for associativity that way.
14:36:30 <ertes-t6v> EvanR: if that doesn't work, then i'm out of clues
14:36:35 <hexagoxel> nocturne777: btw, `conc ioa ioas = uncurry (:) <$> concurrently ioa ioas`
14:36:45 <ertes-t6v> monochrom: even with the seq?
14:36:52 <dolio> (m >>= \x -> f x) >>= g = m >>= \x -> (f x >>= g)
14:36:57 <EvanR> where im using it as in... f i = if nice (powm b i n == x) then i else f (i+1)
14:37:00 <monochrom> I don't know. it's joke only :)
14:37:15 <dolio> Or m >>= (\x -> f x >>= g)
14:37:21 <nocturne777> hexagoxel: I get it now. for some reason I got hung up on waitBoth blocking everything
14:37:32 <Aruro> aupiff: its till the end of line convention or?
14:37:47 <Aruro> aupiff: assuming left to write reader/writer
14:37:47 <dolio> So that it looks more obviously about associativity.
14:37:48 <aupiff> Yeah it consumes as many vars as possible
14:37:53 <ertes-t6v> monochrom: the problem is that i could see how it does…
14:38:04 <aupiff> search "lambda abstraction is right-associative" on google
14:38:09 <aupiff> you'll find tons of results
14:38:12 <nocturne777> hexagoxel: thanks for the expalantion
14:38:16 <Aruro> aupiff: seems wrong :D
14:38:17 <EvanR> -O-1
14:38:19 <monochrom> we can always perform a simple experiment and look at Core...
14:38:26 <aupiff> what got me going is the 'binary lamdbda calc' paper
14:38:31 <EvanR> how do i look at core
14:38:50 <aupiff> I saw it and wanted to cry, and I thought I'd come here and people would tell me I'm not crazy
14:38:56 <hexagoxel> nocturne777: np.
14:38:57 <aupiff> https://tromp.github.io/cl/LC.pdf
14:39:04 <aupiff> I feel much better now.
14:39:05 <monochrom> -ddump-simpl -dsuppress-all -ddump-to-file
14:39:05 <Aruro> aupiff: people always misuse terminology :)
14:39:42 <ertes-t6v> aupiff: you're not crazy =)
14:39:45 <aupiff> yeah. Google Books search turns up some misuses as well
14:39:48 <Aruro> aupiff: and by people i also mean "paper writers"
14:39:55 <aupiff> hehe
14:40:20 <ertes-t6v> aupiff: i just don't agree that it's misuse…  again, from a purely grammatical standpoint you could read lambda abstractions left-associatingly
14:40:23 <EvanR> http://lpaste.net/159441
14:40:41 <ertes-t6v> aupiff: but since that would result in non-sense you don't
14:41:05 <aupiff> really?
14:41:25 <aupiff> how would you misinterpret my cases A and B
14:41:44 <aupiff> Case A: `\x. \y. x y x` Case B: `\x. x z (\y. x y)`
14:41:50 <EvanR> i guess the unsafePerformIO is not even there
14:42:17 <ertes-t6v> aupiff: the way we usually write lambda abstractions there is no ambiguity, but it is essentially binary, and with a different syntax, different associations become possible
14:42:33 <ertes-t6v> aupiff: the lambda "\" makes it unambiguous
14:43:21 <monochrom> nah, unsafePerformIO yield doesn't get eliminated that easily.
14:43:23 <ertes-t6v> in the same way parentheses make function calls in C unambiguous:  f(g(x))  -- the grammar only allows one interpretation
14:43:23 <aupiff> (\x. \y.) x y x ? But that's not allowed. Like I said, l- / r-assoc only exist to remove parens, if you agree with that, that you should be able to insert explicit parens for either interp.
14:43:33 <aupiff> then*
14:43:43 <EvanR> it has been inlined
14:43:51 <EvanR> nice = \ @ a_a4C3 tpl1_Xr -> case tpl_r6Af of _ { () -> tpl1_Xr }
14:43:56 <aupiff> Thus, I think its a horrible misuse. 
14:43:56 <monochrom> but something is strange. it does get turned into unsafePerformDupableIO instead
14:44:32 <EvanR> i kind of cant read that
14:44:56 <monochrom> oh wait, it is "unsafePerformDupableIO (noDuplicate# something else)" which may be exactly unsafePerformIO
14:45:22 <aupiff> ertes-t6v: it's just not an infix op. That's the end of it. It has a grammar that is not often discussed but amounts to: Grab everything until you hit a close parens or end-of-line
14:45:27 <dolio> It's close, at least.
14:46:02 <EvanR> monochrom: how are you getting unsafePerform anything at all ?
14:46:39 <monochrom> f :: Int -> Int; f 0 = 0; f x = unsafePerformIO yield `seq` f (x - 1)
14:46:41 <ertes-t6v> EvanR: i'm surprised that it vanished
14:46:48 <obadz> b -> ((a, [a]) -> b) -> [a] -> b ⇒ is this the catamorphism of lists (like maybe/either) ?
14:47:09 <EvanR> the nice call is there just inlined
14:47:16 <EvanR> but nice doesnt.. do anything?
14:47:17 <obadz> and does it have a name?
14:47:37 <monochrom> look up tpl_r6Af
14:47:39 <ertes-t6v> EvanR: you may have some data dependency problems…  nice is semantically just id, but has a yield side effect
14:47:56 <ertes-t6v> if your data dependencies work, it shouldn't vanish
14:48:03 <obadz> @let list d _ [] = d; list _ f (x:xs) = f x xs 
14:48:04 <lambdabot>  Defined.
14:48:24 <obadz> > list 0 fst [1,2,3]
14:48:26 <lambdabot>      Couldn't match type ‘Integer’ with ‘([Integer] -> t, b0)’
14:48:26 <lambdabot>      Expected type: Integer -> [Integer] -> t
14:48:26 <lambdabot>        Actual type: ([Integer] -> t, b0) -> [Integer] -> t
14:49:04 <verement> EvanR: what about {-# NOINLINE nice #-} ?
14:49:42 <EvanR> oh
14:49:45 <EvanR> tpl_r6Af might be yield
14:50:27 <ertes-t6v> obadz: listCata :: (Maybe (a, r) -> r) -> [a] -> r
14:50:42 <ertes-t6v> obadz: that's isomorphic to foldr
14:50:52 <EvanR> its inlined correctly, just not doing what i want
14:51:45 <verement> the resulting value () may be inlined, but you want the effect, not the value
14:52:02 <ertes-t6v> verement: the `seq` takes care of that
14:52:21 <ertes-t6v> it has become a `case` in core
14:52:23 <obadz> ertes-t6v: you're right I'm looking for foldr
14:52:42 <verement> but the case is only looking at the (), not the effect that produced the ()
14:53:08 <obadz> ertes-t6v: headMaybe = foldr (curry $ Just . fst) Nothing
14:53:51 <ertes-t6v> obadz: foldr (const . Just) Nothing
14:54:00 <EvanR> im now using all 4 cores, now i that i know i have them. and some threads are still not getting their stuff out of the chan ;_;
14:54:18 <EvanR> its not even 100%ing any of them
14:54:50 <monochrom> verement: compiled code shows that the yielding is preserved
14:55:11 <EvanR> verement: im assuming that evaluating the argument to case can cause side effects in core
14:55:34 <verement> it may cause the side effect once, but what about the next time?
14:55:43 <EvanR> the same effects?
14:55:48 <EvanR> every time
14:55:55 <EvanR> i dont know
14:56:11 <monochrom> the asm has a call to stg_yield#
14:56:22 <EvanR> that was my question prior was whether unsafePerformIO will do the IO each time, but since its in an seq..
14:56:22 <monochrom> and the call is inside a loop, not outside
14:56:49 <obadz> ertes-t6v: const . f is somehow hard to wrap head around imho
14:57:01 <ertes-t6v> EvanR: your parallelisation may be too coarse, or your data dependencies may be too strict (i don't know your code)…  in either case i'd try to avoid threading and use parallelism (Control.Parallel.Strategies, Control.Parallel, monad-par, repa, etc.)
14:57:31 <ertes-t6v> obadz: (\x y -> Just x) = (\x -> const (Just x)) = const . just
14:57:34 <ertes-t6v> Just
14:57:47 <ertes-t6v> obadz: read composition right-to-left
14:58:05 <EvanR> i have 2 threads which are logging the bytes going from 1 handle to another by dumping them into a chan. i have 2 threads reading from those chans and attaching a Left or Right and dumping that into 1 single 3rd chan
14:58:23 <EvanR> i have 1 thread doing the discrete log and writing the answer to an mvar
14:58:41 <EvanR> i have 1 thread reading the combined chan and printing things out (and never printing anything out)
14:58:57 <EvanR> and 1 thread waiting on MVar to do something else (which actually works once its written to)
14:59:02 <EvanR> and the main thread 
14:59:33 <ertes-t6v> EvanR: just a guess: could it be that the discrete log thread is doing work the other threads should have already done?  putChan/putMVar don't evaluate the value before sending it
14:59:49 <EvanR> forgot about that
15:00:25 <EvanR> yeah so thats probably done in the wrong thread, and then its killing my reporting thread too soon !
15:00:34 <monochrom> :)
15:00:35 <ertes-t6v> EvanR: also if you can, use MVar or TBQueue…  Chan involves a data structure with a cost of its own
15:00:57 <ertes-t6v> if it fills up, it costs
15:00:58 <EvanR> im actually using the Chans to backlog all the bytes for later
15:00:59 <monochrom> yeah, Chan is a lot of MVars inside MVars
15:01:16 <EvanR> there cant be any delay when im eavesdropping ;)
15:01:26 <verement> EvanR: worst case you could forkProcess and communicate through a pipe :-P
15:01:38 <monochrom> STMChan is cheaper. it's the conventional ([a],[a]) queue.
15:01:51 <EvanR> let me evaluate the answer in the correct thread, i have a feeling that was the problem all along
15:01:52 <ertes-t6v> EvanR: see if that's the bottleneck…  if it is, you could use something like a ring buffer
15:02:11 <ertes-t6v> EvanR: if your discrete log thread can't keep up, stuff is discarded, once the ring buffer is full
15:02:31 <monochrom> discrete backlog
15:02:39 <EvanR> lol
15:02:45 <ertes-t6v> hehe
15:02:49 <monochrom> in fact, discreet backlog, too
15:02:58 <ertes-t6v> just wanted to write that =)
15:05:07 <EvanR> yes... it thinks it got the secret already and kills the report thread then "freezes" later on 
15:05:19 <EvanR> and everything works as soon as that value is computed
15:05:29 <EvanR> putting evaluate in the cracker thread should fix it
15:05:50 <monochrom> nice
15:06:15 <ertes-t6v> EvanR: you can probably remove the yield hack
15:06:24 <ertes-t6v> i'm pretty sure it wasn't the problem to begin with
15:07:23 <EvanR> that fixed it
15:07:34 <EvanR> the scheduler is not completely broken after all!
15:08:09 <verement> whew
15:08:29 <EvanR> im so glad this almost trivial haskell exercise didnt require unsafePerformIO data dependency hack shenanigans
15:09:09 <scshunt> can I quote that?
15:09:28 <EvanR> for the record, there was no MVar, it was an `async' value
15:09:37 <onixoiie> hello!
15:09:51 <EvanR> the async was returning a pure value, and i didnt think that that value wouldnt be fully computed when `wait' is called on it
15:10:28 <EvanR> i guess its an odd way to use async
15:10:44 <onixoiie> im looking for a dark web hacking forum invite
15:10:56 <onixoiie> anyone know where i can get one
15:11:27 <monochrom> we don't. off topic.
15:11:53 <onixoiie> where can i go to talk about that because im obiously not in the right place
15:12:08 <monochrom> I don't know. I am not concierge
15:12:08 <ertes-t6v> EvanR: of course 'Async a' is basically 'MVar (Either SomeException a)'
15:12:14 <EvanR> right
15:12:26 <monochrom> why would anyone in any channel be concierge
15:12:29 <ertes-t6v> EvanR: (pure $!) instead of 'pure' should already fix it
15:12:41 <ertes-t6v> or ($!!) if you have a deep answer
15:12:48 <EvanR> this is an Integer
15:12:49 <onixoiie> not sure i just figured maybe someone here would know
15:12:56 <EvanR> i used evaluate instead of return
15:13:32 <ertes-t6v> yeah, that works, too
15:14:06 <ertes-t6v> (we're discussing pretty dark stuff here! discrete log is dark stuff!)
15:14:50 <monochrom> if you are already in IO, "evaluate" is a bit better. but this is not too important.
15:15:28 <ertes-t6v> not sure when it would even make a difference
15:15:46 <ertes-t6v> probably making too many assumptions here, in particular GHC
15:16:20 <ertes-t6v> taking for granted that you can catch 'throw' and 'undefined'
15:16:35 <EvanR> i feel like i probably usually want to evaluate before putting something in an MVar
15:18:53 <ertes-t6v> EvanR: not necessarily…  often you want reader threads to get back to reading ASAP and leave processing to other threads
15:19:10 <ertes-t6v> if you use concurrency *for parallelism*, then yes, you usually want that
15:20:04 <EvanR> in this case i didnt want to block other processing because discreteLog wasnt done yet
15:20:59 <EvanR> so not sure it counts as parallelism
15:22:02 <EvanR> it works! http://lpaste.net/159443
15:22:35 <EvanR> hmm the interleaving is all messed up
15:22:40 <EvanR> oh well
15:22:41 <ertes-t6v> you're doing both to some degree: concurrency as an abstraction and as parallelism
15:24:07 <EvanR> its just that i cant carry out the program properly if i wait for the answer
15:24:34 <EvanR> something else is going on
15:32:13 <dylukes> Hey all
15:32:15 <dylukes> So I have a haskell question today.
15:32:20 <dylukes> I'm implementing a Kasiski examination and wondering what a good way to do the following is.
15:32:55 <dylukes> let's say I have this
15:32:55 <dylukes> https://gist.github.com/DylanLukes/28ddb7350e3bae08c84ceeec820a819b
15:33:16 <whomp> why does "succ succ 8" not work, but "1:2:[]" does? should the first go to "succ (succ 8)", as the second seems to do "1:(2:[])"?
15:33:45 <dylukes> Now, I want to condense records
15:34:09 <dylukes> so if there's ("ABC", [1, 10]) and ("BCD", [2, 11])
15:34:11 <monochrom> the first is (succ succ) 8. the second is 1 : (2 : []). they are under different grammar rules
15:34:19 <dylukes> The result should be ("ABCD", [1, 10])
15:34:28 <dylukes> that is, I want to group the pairs by prefix matching. 
15:34:34 <monochrom> but perhaps you ask why different rules.
15:34:55 <andromeda-galaxy> whomp: in general, infix operators can be left or right associative, but that's not what's happening in this particular case
15:34:59 <whomp> monochrom, nah i'm still a beginner, thx for the clarification :)
15:35:13 <Cale> whomp: Because the infix operator (:) is defined to be right associative
15:35:38 <dylukes> I'm just not sure how to do this correctly for a map. It's O(n^2) traversal for the corresponding association list
15:35:43 <Cale> whomp: But function application associates to the left, so  succ succ 8  means  (succ succ) 8
15:36:05 <andromeda-galaxy> whomp: but succ succ 8 is (Succ succ) 8 not succ (succ 8)
15:36:08 <andromeda-galaxy> Cale: oops
15:36:10 <dylukes> I guess Repeat -> RepeatMap -> Maybe Repeat, and then gather the results  
15:36:24 <andromeda-galaxy> whomp: succ :: enum a => a -> a
15:36:50 <dylukes> So, I guess I can make this a fold.
15:36:58 <whomp> ah, cool thx
15:37:02 <andromeda-galaxy> since haskell has an open-world assumption about typeclasses, this means that given both Enum a and Enum (a -> a), it works to apply succ to succ
15:37:22 <andromeda-galaxy> which would then yield another function of type 'Enum a => a -> a' which is being applied to the 8
15:37:42 <andromeda-galaxy> this doesn't actually make sense, because functions aren't something that you can enumerate
15:38:17 <verement> :t succ succ
15:38:18 <lambdabot> (Enum a, Enum (a -> a)) => a -> a
15:38:34 <andromeda-galaxy> @ty succ succ 8
15:38:34 <xa0> "enum (a -> a)"
15:38:34 <lambdabot> (Enum a, Enum (a -> a), Num a) => a
15:38:37 <andromeda-galaxy> @ty succ (succ 8)
15:38:38 <lambdabot> (Enum a, Num a) => a
15:38:38 <xa0> that's not gonna work
15:38:50 <maerwald> > show $ BSC.pack "äöä"
15:38:50 <maerwald> how do you make this non-escaped? also tried utf8 functions and stuff, doesn't work
15:38:51 <lambdabot>  "\"\\228\\246\\228\""
15:38:54 <andromeda-galaxy> whomp: does that make sense?
15:40:52 <EvanR> > text $ BSC.pack "äöä"
15:40:53 <lambdabot>      Couldn't match type ‘BSC.ByteString’ with ‘[Char]’
15:40:53 <lambdabot>      Expected type: String
15:40:53 <lambdabot>        Actual type: BSC.ByteString
15:41:01 <EvanR> maerwald: what do you mean
15:41:38 <monochrom> maerwald: "show" will escape. almost always. sidestep "show" altogether. BSC has "putStrLn" IIRC
15:41:48 <EvanR> ah, you shouldnt use non-ascii characters when doing overloaded literal bytestrings
15:42:04 <EvanR> if you want to encode non-ascii characters you need to use encodeUtf8
15:42:13 <maerwald> EvanR: that doesn't change a thing
15:42:22 <maerwald> that's basically what I already do
15:42:33 <EvanR> repeat the problem?
15:43:04 <whomp> yeah that makes sense i think. i'm very new to haskell, so i'll keep digging
15:43:25 <maerwald> EvanR: I don't really understand what you not understand
15:43:33 <maerwald> the result is escaped
15:43:39 <EvanR> to convert a utf8 bytestring back to a string properly, use decodeUtf8
15:43:47 <EvanR> it wont be escaped
15:43:51 <maerwald> that's what I do
15:43:54 <maerwald> it is
15:44:04 <maerwald> decodeStrictByteString UTF8
15:44:09 <EvanR> you probably used show at some point
15:44:11 <monochrom> ok I'm clearly transparent.
15:44:15 <EvanR> ^
15:44:23 <maerwald> maybe it's the gtk API messing it up
15:48:00 <andromeda-galaxy> whomp: great, glad to be of help
15:59:55 <maerwald> EvanR: hmm... I think it's a problem with the Exception class/type
16:00:02 <maerwald> it seems to use show under the hood somewhere
16:00:46 <EvanR> weird
16:07:18 <maerwald> this doesn't feel right... when I convert it to a string via utf8 decoding then even when I use show it sholdn't be escaped
16:07:56 <maerwald> ah, I think I found the show 
16:08:50 <maerwald> well, how can I show an exception without showing it? lol
16:11:27 <jle`> what do you want to do?
16:11:29 <jle`> print it out?
16:11:31 <jle`> you can use 'print'
16:11:48 <jle`> or putStrLn (show e)
16:11:55 <jle`> instead of print (show e)
16:12:04 <maerwald> now, I need it as a String or similar to pass to a gtk function
16:12:06 <maerwald> *no
16:25:54 * hackagebot index-core 1.0.3 - Indexed Types  https://hackage.haskell.org/package/index-core-1.0.3 (GabrielGonzalez)
16:37:06 <ntnt> does anyone have a good todo-app of some sort implemented in haskell?
16:37:17 <ntnt> I don't want somethign to demonstrate a new framework; I mean something that one uses in practice
16:37:26 <ntnt> which is easy to sync with vim/emacs/git
16:40:18 <sm> ntnt: not in haskell, but good: taskwarrior
16:40:26 <sm> you could port it :)
16:40:48 <sm> just kidding, nm
16:40:59 <ntnt> i was hopng something programmable (thus the haskell requirement)
16:41:05 <ntnt> but task warrior looks like nethack, so maybe I'll give it a shot
16:41:44 <sm> there's todos and htodo on hackage
16:42:25 <ryantrinkle> i'm seeing a very strange issue with a criterion benchmark i'm running: when two tests are run together (in serial), the second one takes MUCH longer than if it is run alone
16:42:38 <ryantrinkle> about 3.5x slower
16:43:06 <ntnt> ryantrinkle: isn't laziness supposed to promise the exact opposite? in that if anything is cached, it shoudl be faster
16:43:15 <ClaudiusMaximus> maybe the heap is bigger so gc takes longer?
16:43:48 <ryantrinkle> ClaudiusMaximus: yes, that makes sense, but only if the live set is bigger, right?
16:44:04 <ClaudiusMaximus> i don't know, probably
16:44:29 <ClaudiusMaximus> what happens if you swap the order of the tests?
16:44:45 <ryantrinkle> ntnt: that's what i'd hope, but you never know :P
16:45:49 <ryantrinkle> ClaudiusMaximus: then both tests run in the expected time
16:47:17 <ClaudiusMaximus> if it were me, at this point i'd probably just put a comment to say "this is why the tests are in this order, LATER investigate cause"
16:47:32 <sm> does forcing a gc in between helps ?
16:47:34 <ryantrinkle> ClaudiusMaximus: hmm, yeah, but this is also a *regression :P
16:47:43 <ryantrinkle> so i want to get to the bottom
16:47:53 <ryantrinkle> my suspicion is that the first test is leaking memory
16:48:01 <sm> or a threadscope report ?
16:48:26 <sm> s/threadscope/heap profile/
16:48:52 <maerwald> is there an easy way to handle/catch two different exception _types_ at once? E.g. IOException and MyOwnExceptionType. Afais I'd need a nested catch
16:50:07 <Axman6> there's handles for that use case
16:50:12 <Axman6> :T handles
16:50:14 <Axman6> :t handles
16:50:15 <lambdabot>     Not in scope: ‘handles’
16:50:15 <lambdabot>     Perhaps you meant one of these:
16:50:15 <lambdabot>       ‘handle’ (imported from Control.Exception),
16:50:20 <Axman6> bleh
16:50:39 <maerwald> don't see any such function
16:50:51 <Axman6> catches, sorry
16:51:12 <ryantrinkle> ClaudiusMaximus, sm: ok, so this behavior only occurs when performGC is included *inside* the tests
16:51:16 <Axman6> catches :: IO a -> [Handler a] -> IO a where data Handler a = forall e . Exception e => Handler (e -> IO a)
16:51:34 <ryantrinkle> that was intentional, but if the heap is growing, it makes sense that a leak in the first could cause this
16:51:55 <ryantrinkle> maybe a CAF is getting much larger?
16:53:58 <ntnt> yeah, something like "test = use 0.8 gb of ram; leak 0.8 gb of ram", and "heap = 1gb of ram" would cause test2 to do bad things
16:54:51 <ryantrinkle> yeah
16:55:00 <ryantrinkle> now i just have to figure out what could be retaining that stuff...
17:04:35 <ertes-t6v> ryantrinkle: are you sure there is no sharing between the tests?  that may include more than just CAFs
17:05:19 <ryantrinkle> ertes-t6v: not 100% sure; i'm trying to ensure that, but it's tough because simplifying the program makes this effect start disappearing probablistically
17:06:25 * hackagebot pipes-parse 3.0.5 - Parsing infrastructure for the pipes ecosystem  https://hackage.haskell.org/package/pipes-parse-3.0.5 (GabrielGonzalez)
17:06:27 * hackagebot pipes-bytestring 2.1.2 - ByteString support for pipes  https://hackage.haskell.org/package/pipes-bytestring-2.1.2 (GabrielGonzalez)
17:07:36 <ertes-t6v> ryantrinkle: i highly doubt that GC would have such a huge effect…  see how much memory the individual tests take (x and y), then see if running both takes roughly `max x y`
17:08:09 <ertes-t6v> if not, that's a sign that you may have sharing
17:08:42 <ryantrinkle> ertes-t6v: yeah, that makes sense
17:08:54 <ertes-t6v> ryantrinkle: another way is to use -fno-cse and see if that fixes it
17:08:57 <ertes-t6v> if yes, you had sharing
17:09:11 <ertes-t6v> (the converse is not true)
17:09:30 <ryantrinkle> ertes-t6v: ah, that's a great idea
17:09:36 <ryantrinkle> is cse enabled by default these days?
17:09:54 <ertes-t6v> it has been for a long time, but it's only done in certain cases
17:10:16 <ryantrinkle> ah, i see; i've been assuming it was not on while reading this code
17:10:21 <ryantrinkle> that could make a big difference
17:10:27 <ertes-t6v> it has bitten me once, and that's how i know that trick =)
17:11:02 <ryantrinkle> ertes-t6v: yeah, makes sense :)
17:12:09 <maerwald> EvanR: had to write my own Show instance
17:15:03 <maerwald> I wonder if that means that the show instance for String is _not_ id?
17:15:15 <ryantrinkle> maerwald: it is not
17:15:29 <ryantrinkle> it adds double-quotes around it and escapes any characters inside that need it
17:15:40 <ertes-t6v> > show "" == ""
17:15:41 <lambdabot>  False
17:15:43 <maerwald> well... that was the problem then
17:16:02 <maerwald> simply deriving Show won't work then
17:16:05 <ryantrinkle> maerwald: generally the guideline I try to stick to is that show instances should produce Haskell code that produces the value
17:16:28 <ertes-t6v> i like to think of Show mostly as a debugging feature
17:16:29 <maerwald> this is about showing exceptions in user-friendly format
17:16:38 <ryantrinkle> the standard libs frequently violate that rule, but it's useful often enough to stick with it
17:16:40 <maerwald> so I don't really care if I break any rules 
17:16:54 <ryantrinkle> maerwald: I would recommend using something other than Show for user-facing strings
17:17:02 <maerwald> and there's only 'show' for printing exceptions really
17:17:07 <maerwald> there is nothing else
17:17:24 <ertes-t6v> there is 'catchJust'
17:17:35 <maerwald> ?
17:17:52 <ertes-t6v> catch your exception type and render it to something the user can digest
17:18:03 <maerwald> that involves show too
17:18:14 <maerwald> at least if you want to access the text within the exception
17:18:18 <maerwald> there is no way around it
17:18:38 <maerwald> and I'm not catching 2000 exceptions just to avoid show...
17:19:28 <ertes-t6v> well, yeah…  exceptions tend to make us a bit lazy about UX…  but using Show isn't too terrible
17:20:05 <ryantrinkle> yeah, it's not that big of a deal either way
17:20:08 <ertes-t6v> i tend not to provide Read instances for exception types, because i expect Read and Show to interact nicely, if both are defined
17:20:28 <ertes-t6v> also 'base' doesn't follow that rule too strictly either
17:21:26 * hackagebot chorale 0.1.3 - A module containing basic functions that the prelude does not offer  https://hackage.haskell.org/package/chorale-0.1.3 (FranzBenjaminMocnik)
17:22:25 <maerwald> catchJust is really not a sensible solution for this
17:22:39 <maerwald> especially when your code is all over with that
17:22:44 <ryantrinkle> ertes-t6v: -fno-cse did it!
17:22:45 <maerwald> that's gonna look funny
17:23:36 <ertes-t6v> ryantrinkle: great…  but also not so great, because that basically means that there is some sharing going on that you did not introduce explicitly
17:23:51 <ryantrinkle> ertes-t6v: well, i still think this indicates a regression in the underlying codebase
17:23:58 <ryantrinkle> something involving finalizers
17:24:09 <ryantrinkle> so i've gotta hunt it down
17:24:12 <ryantrinkle> but this is excellent data
17:25:03 <ertes-t6v> ryantrinkle: if you can't isolate it, that may be because there is nothing to isolate…  CSE is problematic, and this hints at a potential compiler bug
17:25:48 <ryantrinkle> well, i'll just have to make sure it gets reported upstream if that's the case
17:26:14 <ertes-t6v> yeah
17:27:21 <ertes-t6v> ryantrinkle: look for complicated cases that may look simple to the compiler, because it isn't aware of unsafe stuff (finalizers, unsafe IO, etc.)
17:27:41 <ryantrinkle> ertes-t6v: haha yeah, this stuff is packed with that kind of thing
17:28:59 <ertes-t6v> welcome to the wonderful world of broken semantics assumptions…  glad to share the fun =)
17:29:10 <Cale> ryantrinkle: as far as I know, the only case in which GHC will do CSE is where you have nested case expressions with an identical scrutinee
17:29:26 <Cale> But that might be out of date knowledge :)
17:29:59 <ryantrinkle> Cale: i suspect that can't be what's causing this one
17:30:14 <ryantrinkle> just because i haven't been seeing a lot of cases
17:30:14 <ryantrinkle> however
17:30:18 <monochrom> I saw "sin x + sin x" got CSE'ed to "let y = sin x in y + y" many years ago
17:30:48 <ryantrinkle> maybe there's a lot more inlining than i'm expecting
17:30:59 <ertes-t6v> monochrom: that may be the product of a rewrite rule though…  have you checked with -fno-cse?
17:31:22 <monochrom> no
17:31:26 * hackagebot quiver-instances 0.2.0.0 - Extra instances for Quiver  https://hackage.haskell.org/package/quiver-instances-0.2.0.0 (IvanMiljenovic)
17:31:47 <ryantrinkle> monochrom: i'm not sure i understand the significance of that example
17:32:29 <ryantrinkle> does sin x + sin x produce better machine code?
17:32:32 <ertes-t6v> ryantrinkle: Double is simple enough so that monochrom's example is fine, but what if the same rewriting happens with a lazy list?  it will become a memory object
17:32:44 <ryantrinkle> ah, yeah
17:32:53 <ryantrinkle> that makes sense
17:33:18 <Cale> Well, that kind of CSE is scary because it's structurally similar to something like  combs (x:xs) = map (x:) (combs xs) ++ combs xs, wherein if you do CSE, the space performance goes to hell.
17:33:31 <ertes-t6v> CSE can introduce arbitrary sharing
17:33:31 <ryantrinkle> right
17:41:27 * hackagebot quiver-sort 0.1.0.0 - Sort the values in a quiver  https://hackage.haskell.org/package/quiver-sort-0.1.0.0 (IvanMiljenovic)
17:43:27 <hackrilege> some kind of crazy zippers! http://lpaste.net/159547
17:52:22 <ertes> my assumption is that GHC feels safer about CSEing in the context of "flat" data types (where seq = deepseq)
17:52:55 <ertes> so check your strict fields, if you have any weak pointers or similar things in there
17:53:53 <ryantrinkle> ertes: ah, that's very interesting
17:54:08 <ryantrinkle> pretty much all my fields are strict, and they have IORefs and Weaks inside
18:03:47 <gfixler> I'm looking for a bit more understanding of comonads
18:04:05 <gfixler> specifically statements re: stream neighbors
18:04:36 <gfixler> e.g. a comonad allows you to walk a GoL impl cell-by-cell while seeing neighbors along the way
18:04:52 <gfixler> I don't have a sense of what that means/looks like in my head
18:05:04 <ertes> gfixler: store comonads may help there
18:05:16 <ertes> gfixler: are you familiar with them?
18:05:22 <gfixler> nope
18:05:34 <gfixler> investigating atm
18:05:55 <ertes> data Store s a = Store (s -> a) s  -- it's a function together with a "current" argument
18:06:17 <ertes> think of "function s -> a" as "table with values of type a indexed by s"
18:06:30 <gfixler> ok
18:06:32 <ertes> so a table with a current index
18:06:49 <gfixler> and to step the index, what happens?
18:07:12 <ertes> one particular kind of "table" is a picture:  type Picture = Store (V2 Int) RGB
18:07:13 <gfixler> I suppose that's the magical bit of comonads
18:07:59 <ertes> now you have a function, a filter that takes a picture and computes a new pixel at the current position by looking at neighbours, for example a "blur" filter
18:08:04 <ertes> blur :: Picture -> RGB
18:08:27 <ertes> if you 'extend' blur, it blurs a whole image
18:08:37 <gfixler> sweet - this is quite specifically what I'm interested in - image stuff
18:08:46 <ertes> extend :: (Picture -> RGB) -> (Picture -> Picture)
18:09:29 <gfixler> ertes: is extend the dual of bind?
18:09:37 <ertes> yeah
18:09:55 <gfixler> I've heard you can walk all around, e.g. an image, via comonads
18:09:57 <gfixler> is this true?
18:10:16 <ertes> in a sense…  you compute a single component by looking at the whole thing
18:10:26 <ertes> with monads you construct a whole thing by looking at a single component
18:10:38 <gfixler> I think I need to stew on that for a sec :)
18:10:46 <ertes> look at the types
18:10:50 <gfixler> because of a -> m b?
18:11:02 <ertes> (=<<) :: (a -> M b) -> M a -> M b
18:11:10 <ertes> extend :: (W a -> b) -> W a -> W b
18:11:33 <gfixler> single component is the b?
18:11:42 <gfixler> and "the whole thing" is the M b?
18:11:47 <leewz> how much work and learning would it be to write an analyzer for haskell code, anyway? (i mean setting it up so that you can look at an AST or something, not "how do i algorithms".) e.g. a syntax highlighter (assuming the code compiles), or simple CSE (and yes, i know that it's not always good to do CSE).
18:11:53 <ertes> gfixler: yeah
18:11:56 <gfixler> ertes: cool
18:13:28 <leewz> and then, how much effort would it be to minimize the source to what you need? i mean, if you're plugging into the full compiler, you'd have a lot of code you're probably not using.
18:14:21 <leewz> (this is just a theoretical question. i don't have anything in mind yet.)
18:14:24 <ertes> gfixler: it's easier to understand in terms of specific examples: given a picture with a current position, you know how to compute the pixel at that position, but just looking at the pixel at that position (fmap) is not enough…  you need to see the whole picture, so that you can examine the neighbouring pixels
18:14:48 <gfixler> ertes: right, but that's what I don't grok
18:15:08 <ertes> gfixler: say you want to invert all colours of a picture
18:15:14 <gfixler> ertes: so that whole picture could just be anything, e.g. a map or lists?
18:15:14 <ertes> invert :: RGB -> RGB
18:15:56 <ertes> gfixler: in this case you can simply use fmap, because colour inversion can be done by looking only at the pixel in question
18:16:06 <gfixler> ertes: right
18:16:22 <ertes> fmap :: (a -> b) -> F a -> F b  -- the argument function only needs to know individual 'a' values
18:16:29 <gfixler> ertes: I'm curious what it means to have access to the whole picture
18:16:39 <gfixler> ertes: does it just mean I'm presented with the structure holding the image data?
18:16:56 <gfixler> and then I just do whatever I'd normally do with a grid of pixels?
18:17:06 <ertes> gfixler: it really just means that the function you want to map isn't quite happy with seeing just individual pixels in isolation
18:17:30 <ertes> it wants to see the whole picture to determine the new pixel
18:17:40 <gfixler> ertes: right, so then it's just down to the provided function to accept the entire image
18:17:58 <gfixler> i.e. not something magic about accessing parts of an image in the comonad itself
18:18:38 <ertes> all these abstractions are fancy mappers…  they lift simple functions to functions that operate on structures
18:19:07 <gfixler> yeah, I guess a -> m b tells me that much
18:19:16 <ertes> there is nothing magic going on =)
18:19:18 <gfixler> it doesn't mean much - you have to provide everything yourself to fit that type
18:19:37 <gfixler> the talk I've heard had me imagining that comonads had some kind of accessor property about them
18:19:52 <gfixler> so if I want to blur with the 8 neighbor pixels
18:20:02 <ertes> well, the lifting functions (fmap, (=<<), extend, (<*>)) do stuff, but what they do isn't even that interesting
18:20:08 <gfixler> the comonad is just going to hand me the entire image and, say, an (x,y) pair?
18:20:33 <ertes> normally you would write this:  blur :: Picture -> Picture
18:20:37 <gfixler> and my function is responsible for then looking around that point at the neighbors
18:21:12 <gfixler> sorry if my questions are nebulous; my understanding is as well :)
18:21:24 <gfixler> I'm doing a line-following algorithm
18:21:31 <gfixler> asking questions all over the place to see where the road is
18:21:31 <ertes> let's recap
18:22:09 <ertes> type Image a = V2 Int -> a  -- a simple picture
18:22:21 <gfixler> yep
18:22:35 <leewz> simpler(?) question: how big is Haskell's primitive set? e.g. takeWhile isn't primitive, since you can define it with simpler things. "::" is probably primitive.
18:22:43 <ertes> gfixler: blur :: Image Colour -> Image Colour  -- a blurring filter…  makes sense?
18:22:52 <gfixler> ertes: yep
18:23:31 <ertes> gfixler: now 'blur' really does much more than is necessary…  the *essence* of blurring can be captured by a much simpler function
18:23:44 <Cale> leewz: It's a little bit funny, there are some things which become questionable. Are if/then/else expressions primitive? They can be conveniently defined in terms of case
18:24:00 <ertes> gfixler: blurPixel :: Image Colour -> V2 Int -> Colour  -- returns the blurred pixel at the given position
18:24:02 <gfixler> ertes: sounds a lot like what I've been doing this weekend (assembling a talk)
18:24:16 <ertes> gfixler: still makes sense?
18:24:20 <gfixler> ertes: completely
18:24:20 <leewz> and "case" can be defined with pattern matching
18:24:27 <gfixler> ertes: that might be what I was looking for, too
18:24:43 <gfixler> I've heard comonads allow you to drag neighbors along for the ride, etc
18:24:55 <Cale> leewz: Or the other way around
18:25:02 <ertes> gfixler: but that "essence" isn't quite enough, so you need a little combinator to blur a whole picture
18:25:04 <leewz> yep
18:25:04 <Cale> leewz: The very core of the language has something like 10 constructions.
18:25:09 <Cale> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
18:25:13 <gfixler> ertes: right
18:25:25 <Cale> At least, the very small functional language that GHC compiles Haskell to
18:25:28 <gfixler> ertes: that's the magical bit I'm missing (but feel close to now)
18:25:31 <ertes> gfixler: withImage :: (Image a -> V2 Int -> b) -> Image a -> Image b
18:25:32 <Cale> as an intermediate step
18:25:46 <leewz> i had "seq" in mind, actually
18:26:00 <gfixler> ertes: bingo - that's it
18:26:04 <Cale> At that level, seq gets defined in terms of case
18:26:12 <gfixler> ertes: no magic whatsoever
18:26:17 <Cale> Well, then there's all the IO actions
18:26:29 <ertes> gfixler: now this looks almost like an algebraic abstraction, but there is this "noise":  the V2 Int
18:26:43 <gfixler> ertes: yeah, it's gross
18:26:43 <ertes> gfixler: the idea of store comonads is to build this "current position" into the image type itself
18:26:47 <leewz> not sure how primitive "communication with C" is
18:26:54 <gfixler> ertes: ah, interesting
18:27:15 <ertes> gfixler: data Store s a = Store (s -> a) s  -- this is still Image, but with the current position built in
18:27:39 <leewz> "seq" doesn't have a source code link in the wiki. guess it's not implemented as a primitive.
18:28:03 <Cale> leewz: Yeah, it might actually not be primitive -- you can imagine defining IO as if it were any other datatype, with some more elaborate constructors for specifying FFI calls.
18:28:08 <ertes> gfixler: now you can write a slightly nicer withImage :: (Store s a -> b) -> Store s a -> Store s b
18:28:24 <gfixler> ertes: cool, though that does make it magical again
18:28:37 <gfixler> ertes: so is there an idea of "next pixel" in that impl?
18:28:50 <ertes> gfixler: nope
18:29:02 <gfixler> ertes: how is stepping through indices handled then?
18:29:15 <ertes> gfixler: maps are still completely local, but instead of just individual pixels they get access to the whole image along with the "current position"
18:29:18 <Cale> leewz: seq is stubbed out in the Prelude and handled specially by the compiler
18:29:23 <Cale> seq :: a -> b -> b
18:29:23 <Cale> seq = let x = x in x
18:29:35 <ertes> gfixler: it's handled transparently by withImage…  the blurring function does not see it
18:29:43 <leewz> well if-then-else is syntactically primitive, though not semantically primitive, unless you add in a construct to declare new keyworded syntax. welp, might as well do that.
18:29:48 <Cale> (this equation is clearly bogus)
18:29:53 <gfixler> ertes: okay, so for every type, you need some combinator to do the stepping
18:30:01 <gfixler> ertes: like withImage
18:30:08 <ertes> gfixler: that's the "not very interesting" thing that withImage does
18:30:21 <gfixler> ertes: I'm at least a little interested :)
18:30:21 <leewz> bogus?
18:30:39 <ertes> gfixler: now you realise that there is also a way to get something out of an image with a position: the current pixel
18:30:40 <Cale> seq = let x = x in x
18:30:47 <ertes> gfixler: current :: Store s a -> a
18:30:47 <gfixler> ertes: yes
18:30:59 <leewz> i mean, which way do you mean bogus?
18:31:00 <Cale> If this were really the definition, then seq would just produce an infinite loop every time it was used
18:31:11 <ertes> gfixler: next you realise that this has some interesting properties with withImage, and that category theory has a name for such a structure: comonad =)
18:31:11 * gfixler sees pos, peek, peeks, seek, seeks in Control.Comonad.Store docs
18:31:13 <ntnt> what is the current state of the art for building iOS, Mac, Android, and Windows Phone apps in Haskell? Is it "use ghcjs + native js wrapper" for all of them? Or do some of them have something better?
18:31:48 <leewz> i think i read that earlier as a def of "undefined" (or something similar), but i don't see how it would implement seq
18:31:54 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-prim-0.4.0.0/src/GHC-Prim.html#line-3175
18:32:08 <ertes> gfixler: so you invent a generic interface called Comonad and rename 'withImage' to 'extend', and 'current' to 'extract'…  and you find that 'extend' in its infix form composes nicely =)
18:32:23 <Cale> It doesn't, it's just there as a stub, and the compiler treats seq specially.
18:32:35 <ertes> gfixler: (blur =>= rotate 90 =>= someOtherFilter) myImage
18:32:50 <ertes> there you go, comonads…  another useful generic API =)
18:33:08 <gfixler> ertes: so extend is like map in that it operates on all indices in one go every time?
18:33:18 <ertes> gfixler: yeah
18:33:28 <gfixler> ertes: ah ha - that's a big piece of the puzzle filled in
18:33:57 <gfixler> ertes: what I've heard of comonads had me feeling like they were almost some user-controled thing
18:34:16 <gfixler> i.e. why I wondered about changing course, moving left, then up through pixels, etc
18:34:22 <gfixler> but that would just be dictated by the extend function
18:34:30 <ertes> gfixler: all abstractions built on functors have this locality property: you don't get to see the overall process, but only a local portion of it (in this case, a single pixel)
18:34:52 <gfixler> so then I wouldn't be writing 10 different ways to run through an image's pixels
18:35:05 <gfixler> there'd be one way - extend - that all things would use?
18:35:29 <ertes> everything that involves the specific nature of the object (e.g. an image) is outside of the comonadic interface
18:35:45 <ertes> for example moving the current position, retrieving the current position, etc.
18:35:48 <gfixler> ertes: right, but I need to choose what extend means for Image, right?
18:36:04 <gfixler> and, as with, say, monoid, I get one choice per type?
18:36:11 <ertes> yeah, although you don't have much choice, because it needs to satisfy the comonad laws =)
18:36:36 <ertes> i think there is only one valid instance for Store, but i'm not sure
18:36:44 <gfixler> well, not that it would matter, but e.g. row-by-row, column-by-column, boustrophedon...
18:36:45 <leewz> more practical question: what's a good (= quick + easy) way to test functions i'm defining? i'm coming from a Python background, where i work in an editor and paste into the console (well, IPython). i'd rather not compile for every test and redefine.
18:36:57 <gfixler> ertes: many ways to index through pixels
18:37:03 <ertes> gfixler: if that makes a difference, you're most likely already breaking the laws
18:37:11 <gfixler> ertes: got it
18:37:22 <gfixler> ertes: those wouldn't matter anyway with immutable structures
18:37:50 <ertes> gfixler: with Store you don't get to choose any of that anyway
18:37:57 <gfixler> so when you say "in this case, a single pixel," that just refers to the function I use with extend?
18:38:03 <ertes> remember that even though we've been talking about "images", we're dealing with functions
18:38:09 <ertes> yeah
18:38:32 <Cale> leewz: Put your declarations into a file, which you load in ghci in a separate window, and then :r in ghci will reload the file whenever you make changes
18:38:42 <gfixler> ertes: yeah, my talk this week is on image creation/compositing/rendering via continuous functions
18:38:43 <Cale> leewz: and you can test out expressions from there
18:38:53 <gfixler> ertes: inspired by conals Essence of FRP talk(s)
18:39:20 <gfixler> ertes: was hoping I could spool up enough on comonads to include them briefly at the end for htis
18:39:28 <gfixler> seems so - doesn't seem super complicated now
18:39:52 <gfixler> ertes: although, now I'm not sure
18:40:01 <gfixler> ertes: not sure if comonads deal in continuous spaces
18:40:05 <ertes> gfixler: i think you can show "functional image manipulation"
18:40:12 <ertes> gfixler: i would refrain from mentioning "comonads"
18:40:18 <gfixler> ertes: oh?
18:40:27 <gfixler> ertes: yeah, it's all function-based
18:40:55 <ertes> if your talk is mainly on FRP, you won't have time to clear up the confusion when you say "comonad" and don't properly explain it
18:41:02 <ertes> it's the same as with IO and "monads"
18:41:04 <gfixler> ertes: it's not on FRP
18:41:12 <gfixler> ertes: not dealing with time in any way
18:41:14 <ertes> you should never talk about monads the first time you mention IO
18:41:19 <gfixler> ertes: :)
18:41:41 <ntnt> by the time we get to stg, have all the cool optimizations beey done?
18:41:45 <gfixler> ertes: this is specifically on images as continuous functions
18:41:49 <ntnt> or do the performance increasing optimizations happen *after* stg ?
18:42:05 <gfixler> ertes: but comonads sound very discrete, and not a fit for continuous functions
18:42:15 <ertes> gfixler: they are a perfect fit
18:42:56 <ertes> gfixler: linear :: (Fractional a) => Store (V2 Int) a -> Store (V2 Double) a  -- turn a discrete picture into a continuous one by linear filtering
18:43:25 <gfixler> ertes: hmmm, I thought the indices were decided ahead of time
18:43:54 <ertes> gfixler: Comonad can't change the indices the same way Monad can't change the state type in State
18:43:58 <gfixler> ertes: i.e. that the extend function visited the indices automatically, and uncontrollably
18:44:25 <ertes> 'extend' doesn't really visit anything…  it's function composition =)
18:44:44 <gfixler> ertes: what would blurring mean without discrete neighbors?
18:44:57 <ertes> the actual iteration is done by another function:  at some point you have composed a bunch of image processing functions, and you'd like to make an actual picture in memory
18:45:04 <Cale> gfixler: convolution
18:45:23 <leewz> Cale: eurgh. i think i'd rather use :{\nlet <indent:<paste>> \n:}. but i'll keep it in mind.
18:45:34 <ertes> realise :: (Unbox a) => Store (V2 Int) a -> Store (V2 Int) a  -- build an actual picture in memory, potentially using a clever iteration rule and parallelism
18:45:42 <gfixler> Cale: I stopped at precalc 20+ years ago (and was bad at it!)
18:46:02 <Cale> leewz: That works, but it's easy to lose work that way for various reasons
18:46:17 <ertes> gfixler: the idea is that you read a picture from a file, then interpolate it into a continuous picture, then do all the continuous transformations you want to do, then make it discrete again to save it
18:46:26 <Cale> leewz: Much nicer and more organised just to put everything into a file from the start
18:46:30 * hackagebot webdriver-angular 0.1.10 - Webdriver actions to assist with testing a webpage which uses Angular.Js  https://hackage.haskell.org/package/webdriver-angular-0.1.10 (JohnLenz)
18:46:46 <ertes> gfixler: the transition from discrete to continuous and back is outside of the comonadic framework
18:46:50 <gfixler> ertes: funny that I mention comonads, and you've been bullet-pointing my talk on images ever since :)
18:46:50 <leewz> how's the delay between action and usability, though?
18:47:34 <ertes> well, it's not surprising, as i've done media processing with comonads =)
18:47:41 <gfixler> ertes: reading an image, converting to continuous, manipulating, and sampling back out to a discrete image was part of the plan for the talk :)
18:47:50 <gfixler> ertes: very appreciative of this discussion
18:48:03 <gfixler> ertes: and did you use the aforementioned convolution?
18:48:03 <Cale> leewz: pretty short
18:48:21 <Cale> leewz: :r is usually close to instantaneous
18:49:15 <ertes> gfixler: nope…  i've mostly done linear transforms on images
18:49:30 <ertes> take a matrix, invert it, read the source pixel
18:49:58 <gfixler> ertes: as said, I had bad maths classes, and never paid any attention
18:50:06 <gfixler> ertes: been trying to make up for it in my old age
18:50:19 <gfixler> ertes: but only halfway through alg I so far (Khan Academy)
18:50:37 <gfixler> ertes: I decided to just do everything on the site, then explore other areas elsewhere
18:51:11 <ertes> gfixler: same here =)
18:51:24 <gfixler> ertes: all the fun stuff is ahead of me still
18:53:20 <ertes> gfixler: you don't have to go all the way to matrices:  scale :: (Num s) => s -> Store s a -> b  -- find the pixel on the scaled image
18:53:52 <gfixler> ertes: oh, wait, is this pixel-access thing just the dual of pure?
18:54:06 <ertes> 'extract' is the dual of 'pure'
18:54:15 <gfixler> ertes: but you're still talking about extend?
18:54:43 <ertes> i recommend looking at it as a simple API for now
18:55:00 <gfixler> ertes: I think I need to go play with some comonads
18:55:06 <gfixler> ertes: I never really learn without doing
18:55:18 <ertes> all comonads have a notion of a "current value"
18:55:26 <ertes> 'extract' gives you that
18:55:29 <Cale> gfixler: Actually, when you do a Gaussian blur, it's really just a fast discrete approximation to computing a bunch of integrals. You can see a helpful animation here: https://en.wikipedia.org/wiki/File:Convolution_of_spiky_function_with_box2.gif -- only in a Gaussian blur's case, you'd want to use a smooth bump like https://en.wikipedia.org/wiki/Gaussian_function
18:55:47 <Cale> rather than a rectangle
18:55:55 <gfixler> ertes: does this mean you're extracting every pixel?
18:56:32 <ertes> extract (Store f p) = f p  -- no, only the current one; remember that every image comes with a "current position"
18:56:44 <ertes> 'extract' gives you the pixel at that position
18:57:03 <gfixler> ertes: I meant are you constantly doing extractions of the current position?
18:57:18 <ertes> yeah
18:57:25 <gfixler> ertes: sounds expensive
18:57:33 <ertes> it isn't =)
18:57:47 <Cale> Yeah, a comonadic interface expresses quite nicely what's going on with convolutions like this
18:58:16 <ertes> gfixler: most likely you're just indexing an in-memory array (depending on where the image came from)
18:58:22 <Cale> duplicate :: w a -> w (w a) basically gives you an image whose points are all the possible translations of the original
18:59:21 <Cale> and then you only need to know how to do the convolution at the origin
18:59:41 <Cale> and you fmap that over the image of translations
18:59:48 <gfixler> Cale: craziness - and sounds like something you could step through forever
18:59:48 <ertes> or "at any particular point"
19:00:13 <Cale> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html]
19:00:15 <Cale> oops
19:00:15 <ertes> gfixler: the picture – denotationally – is huge and potentially even infinite
19:00:19 <Cale> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
19:00:41 <gfixler> ertes: yeah, I've had the idea a few times in my head - "I'll just generate all permutations."
19:00:59 <gfixler> ertes: "then simply search through them... until the universe ends"
19:01:09 <Cale> It takes a bit of finesse to get things to be efficient
19:01:15 <ertes> it's a "lazy image" in a sense
19:01:29 <Cale> But this is a very nice way of structuring the ideas
19:01:37 <ertes> you explain how a pixel would be computed, and then you compute a subset of the pixels
19:01:39 <Cale> and it's possible to arrange for it to be efficient too
19:01:58 <dylukes> If I have a function step :: Int -> a - > a, and I want to run step 4 $ step 3 $ step 2 init 
19:02:03 <ertes> if you do it properly, you get the same efficiency as a tight loop that runs through an array
19:02:35 <dylukes> printing/storing each intermediate and terminating when the result has a condition
19:02:35 <dylukes> what's the best way to do that?
19:02:37 <dylukes> iterateUntilM?
19:02:49 <Cale> dylukes: looks like  foldr step init [4,3,2]
19:02:56 <ntnt> Suppose I have "impl1 :: (Foo1 f) -> f a -> b" and "impl2 :: (Foo2 f) -> f a -> b" -- is it somehow possible to define a function "magic:: (Foo1 f OR Foo2) -> f a -> b" ?? So It's sorta like "Union Types" -- but on typeclass constraints instead
19:02:59 <dylukes> It is, Cale.
19:03:03 <dylukes> I just want to print out/store intermediates.
19:03:08 <ertes> dylukes: mapM_ print . takeWhile p . iterate f  -- something like that?
19:03:20 <dylukes> I'll give it a shot.
19:03:29 <dylukes> What this is, is a Kasiski examination
19:03:32 <ertes> oh, wait…  your steps change
19:03:36 <dylukes> so a = Map String [Int]
19:03:46 <dylukes> And I want to know how many entries are in that map at each iteration
19:03:50 <dylukes> but stop when the result is empty
19:04:05 <dylukes> But there can be false positives so I want to display results for all n.
19:04:22 <dylukes> https://www.bucknell.edu/Documents/Engineering/MattBerntsen-thesis.pdf
19:04:29 <dylukes> it's an implementation of the dynamic algorithm on page 25
19:04:50 <dylukes> https://gist.github.com/DylanLukes/8c17d6988afa82c1c48cf2499bd001e7
19:04:57 <Cale> Perhaps a scanl
19:05:00 <dylukes> My code is not great haha.
19:05:17 <aweinstock> :t scanM
19:05:19 <lambdabot>     Not in scope: ‘scanM’
19:05:19 <lambdabot>     Perhaps you meant one of these:
19:05:19 <lambdabot>       ‘scanl’ (imported from Data.List),
19:05:39 <ertes> i think i need sleep
19:05:42 <Cale> Or even just a foldr which accumulates a function
19:05:45 <ertes> good night =)
19:05:53 <Cale> e.g...
19:06:03 <gfixler> night ertes - thanks again!
19:06:23 <ertes> my pleasure…  good luck with your talk
19:06:27 <gfixler> thanks
19:06:29 <geppettodivacin> ntnt: Can you make a typeclass and then define an instance for Foo1 and Foo2?
19:06:54 <geppettodivacin> Or, actually, on (Foo1 f) and Foo2.
19:07:10 <aweinstock> :let let {scanM f z [] = return z; scanM f z (x:xs) = do { y <- f x z; scanM f y xs}} in scanM
19:07:16 <aweinstock> :t let {scanM f z [] = return z; scanM f z (x:xs) = do { y <- f x z; scanM f y xs}} in scanM
19:07:17 <lambdabot> Monad m => (t -> a -> m a) -> a -> [t] -> m a
19:07:22 <ntnt> Suppose I have "impl1 :: (Foo1 f) => f a -> b" and "impl2 :: (Foo2 f) => f a -> b" -- is it somehow possible to define a function "magic:: (Foo1 f OR Foo2 f) => f a -> b" ?? So It's sorta like "Union Types" -- but on typeclass constraints instead
19:07:32 <ntnt> geppettodivacin:  I had a typo, Foo1/Foo2 are not constructors, they're typeclasses
19:07:42 <dylukes> ntnt How would that implementation work? 
19:07:42 <Cale> > foldr (\x xs s -> if S.member x s then Just x else xs (S.insert x s)) (const Nothing) "abcdecf" S.empty
19:07:44 <lambdabot>  Just 'c'
19:07:58 <aweinstock> ntnt: Either is type-level OR
19:08:00 <mmercer> why is if syntax and not a function?
19:08:08 <Cale> ^^ looking for duplicates with a Set
19:08:24 <aweinstock> ntnt: oops, misread
19:08:29 <dylukes> Hrm, I'll figure something out.
19:08:38 <ntnt> dylukes: compiler would look at type info, figure out which typeclass it safisfied, and call either foo1 or foo2 depending on the typeclass it satisfies
19:08:52 <Jinxit> ntnt: you could make a typeclass for it
19:09:29 <dylukes> Yeah, instances Foo1OrFoo2 Foo1 and Foo1OrFoo2 Foo2
19:09:31 <ryantrinkle> mmercer: i couldn't tell you why 'if' is syntax rather than a function, but there's Data.Bool.bool if you're looking for a function version
19:09:35 <Cale> > foldr (\x xs s -> if S.member x s then xs s else x : xs (S.insert x s)) (const []) "abracadabra" S.empty
19:09:37 <lambdabot>  "abrcd"
19:10:25 <Cale> dylukes: you can do a sort of "fold with state" like that
19:10:41 <mmercer> it just struck me when viewing above code, i think it would be a lot easier to read in a single line. 
19:10:46 <dylukes> Honestly this is just a top level bt
19:10:51 <dylukes> So I was just going to use monad loops and IO haha
19:11:14 <dylukes> I'm not concerned with writing a pure function to do it, just printing out each step.
19:11:29 <Cale> sure :)
19:12:34 <HaskellerNewbie> #haskell
19:13:06 <HaskellerNewbie> hi there?
19:13:09 <mmercer> if (f a) true false   vs    if (f a) then true else false
19:13:30 <mmercer> kind of a missed opportunity
19:13:43 <mmercer> haskell is one of the few languages where if could be a function
19:13:47 <toph_> is there a name for the free monoid over the powerset of a set?
19:14:15 <mmercer> I know about bool, but i have to read other people's code as well
19:14:53 <geppettodivacin> HaskellerNewbie: Hi! Do you have a question, or are you just going to hang for a while?
19:15:08 <geppettodivacin> HaskellerNewbie: You're welcome either way, btw.
19:15:51 <ryantrinkle> mmercer: yeah, makes sense :)
19:16:04 <geppettodivacin> mmercer: I appreciate the fact that if isn't a function. It decreases the need for explicit parenthases.
19:16:05 <HaskellerNewbie> please someone help me, I'm having trouble with IntelliJ + plugins
19:16:28 <jle`> mmercer: the reason why if is useful is because it introduces layouting
19:16:34 <mmercer> geppettodivacin in a single line I think parenthesis increase readability. probably not in multiple lines though
19:16:42 <jle`> if blah blah
19:16:44 <jle`>   then do
19:16:46 <jle`>     blah
19:16:48 <jle`>     blah
19:16:50 <jle`> etc.
19:16:58 <geppettodivacin> HaskellerNewbie: I didn't realize IntelliJ had a Haskell plugin.
19:17:04 <jle`> if introduces a layout block, so it's useful for that :)
19:17:30 <HaskellerNewbie> https://github.com/Atsky/haskell-idea-plugin and https://github.com/octomarat/HaskellDebugger
19:17:37 <geppettodivacin> mmercer: In a single line, parenthases might help.
19:18:03 <geppettodivacin> if (f x) then (g y) else (h x z)
19:18:23 <geppettodivacin> But I almost never write if statements in a single line unless they're really trivial.
19:18:34 <HaskellerNewbie> I can't figure out why remote-debugger print error
19:19:39 <HaskellerNewbie> anyone? please give me a hint
19:20:16 <geppettodivacin> HaskellerNewbie: I'm not sure many of us are particularly familiar with IntelliJ.
19:20:34 <geppettodivacin> I write all of my code in vim.
19:20:51 <geppettodivacin> HaskellerNewbie: If you give us the error, it might help a bit.
19:21:12 <geppettodivacin> HaskellerNewbie: If it's a long error, please post it in a pastebin.
19:22:06 <HaskellerNewbie> yeah, https://github.com/octomarat/HaskellDebugger  I tried run this on CLI it print error like this
19:22:09 <HaskellerNewbie> remote-debugger: panic! (the 'impossible' happened) (GHC version 7.10.3 for x86_64-apple-darwin): Main module not specified  Please report this as a GHC bug: http://www.haskell.org/ghc/reportabug
19:23:39 <HaskellerNewbie> I tried that various argument but it always says panic! thing
19:23:46 <dylukes> Cale I have a challenge for ya
19:23:49 <dylukes> been trying to work this out for a bit
19:23:51 <dylukes> so given
19:23:54 <dylukes> decode :: Key -> Ciphertext -> Plaintext
19:23:54 <dylukes> decode ks cs = [shift (26 - value k) c | (k, c) <- zip (cycle ks) cs]
19:24:06 <dylukes> (in other words, Vigenere decoding with a rotating key)
19:24:12 <dylukes> how does one both 1) skip whitespace 2) add it back in?
19:24:31 <xnil> Since #idris might take a while to respond... I did `stack install idris` and have no idea where the binary was installed. Any ideas?
19:24:44 <xnil> or rather, how do i get the idris repl up?
19:24:51 <geppettodivacin> HaskellerNewbie: That's weird, since there is definitely a Main module in the src/ directory. I'm not sure what to tell you there.
19:24:53 <dylukes> Not sure how to put away the whitespacing state and then bring it back.
19:25:31 <aweinstock> xnil: if you're on something debian-ish, (sudo updatedb && locate idris)
19:25:37 <geppettodivacin> HaskellerNewbie: What command are you using for the installation.
19:25:54 <aweinstock> xnil: or on anything unixy at all, "find / -name '*idris*'", but that might be slower
19:25:59 <xnil> that worked
19:26:02 <HaskellerNewbie> i tried all cabal, stack, build locally 
19:26:05 <xnil> but is there a Stack command to start idris?
19:26:23 <HaskellerNewbie> all the same, print panic error
19:26:31 * hackagebot AFSM 0.1.1.2 - Arrowized functional state machines  https://hackage.haskell.org/package/AFSM-0.1.1.2 (hanzhxu)
19:28:17 <aweinstock> dylukes: increment the key only when there's non-whitespace in a manually-recursive thingy?
19:28:25 <dylukes> That's what I'm doing/done
19:28:40 <dylukes> just wondering if there was a nice one liner to do that sort of "remove this but put it back"
19:29:49 <geppettodivacin> HaskellerNewbie: I can try compiling it myself and see how it goes, but other than that, I don't know what to say.
19:31:10 <geppettodivacin> HaskellerNewbie: There are several things that could have gone wrong. IMO, the most probable is that the Haskell platform has an old version of some dependencies and it's causing conflicts.
19:31:53 <geppettodivacin> One thing you might want to try is run `cabal sandbox init` in the build directory, then reinstall all of the dependencies in the sandbox with `cabal install --only-dependencies`
19:32:32 <geppettodivacin> (After running `cabal update`, of course, to make sure you're pulling the newest versions of libraries.
19:33:31 <HaskellerNewbie> Ok, thank! i'm trying...
19:34:31 <ryantrinkle> ertes: adding a noinline on the environment setup function passed to criterion fixes the issue
19:34:53 <ryantrinkle> (even with CSE enabled)
19:35:21 <ryantrinkle> so my best guess is now this: the test runner is getting inlined, the setup function is getting inlined into that, and then a CSE is creating sharing between different test cases
19:36:32 * hackagebot AFSM 0.1.1.3 - Arrowized functional state machines  https://hackage.haskell.org/package/AFSM-0.1.1.3 (hanzhxu)
19:38:36 <gfixler> random question - anything I can do to speed up putStrLn in the terminal?
19:38:57 <ryantrinkle> gfixler: what platform are you on?
19:39:14 <gfixler> ryantrinkle: Ubuntu with gnome-terminal/bash
19:39:41 <ryantrinkle> gfixler: have you tried changing the buffering?
19:40:04 <gfixler> ryantrinkle: no, but that sounds like the kind of answer I was looking for
19:40:45 <kadoban> Only problem is, I think buffering is on by default isn't it? Or maybe it depends on … something.
19:40:50 <ryantrinkle> https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hSetBuffering
19:41:02 <ryantrinkle> kadoban: i believe it's line-buffering on by default
19:41:11 <ryantrinkle> perhaps block buffering would be faster?
19:41:22 <kadoban> Ahh, yeah that'd likely improve it if so.
19:41:26 <ryantrinkle> i haven't ever benched something like this
19:41:29 <HaskellerNewbie> it produce same panic error
19:42:11 <HaskellerNewbie> please someone tell me https://github.com/octomarat/HaskellDebugger 's normal behavior
19:42:23 <HaskellerNewbie> behaviour?
19:43:34 <xnil> Pls, Haskellian gods, how do I start up the idris REPL from Stack?
19:43:39 <kadoban> behavior/behaviour are both right, depending on if American or British English.
19:44:41 <Cale> HaskellerNewbie: hmm, that's an odd error
19:45:37 <geppettodivacin> HaskellerNewbie: Mine is still compiling. My computer's painfully slow.
19:45:53 <HaskellerNewbie> I asked it on stackoverflow, github issue tracker, and now here
19:46:02 <HaskellerNewbie> Ah, Thanks, I can wait
19:46:06 <Cale> I was able to compile it, and I see the same thing when I run it
19:46:20 <Cale> I suspect it's just because we're not attempting to load any Haskell code into it
19:46:34 <HaskellerNewbie> I hope solve this here
19:47:07 <geppettodivacin> HaskellerNewbie: http://lpaste.net/159549
19:47:20 <geppettodivacin> That is the output of a successful build.
19:47:31 <geppettodivacin> It built just fine on my machine.
19:47:36 <Cale> geppettodivacin: It builds successfully, but did you try to run it?
19:47:45 <HaskellerNewbie> um, I don't know how exactly use remote-debugger on CLI, but tried what github readme says it print panic error
19:48:00 <geppettodivacin> Cale: Oh, good point. I'll give it a shot.
19:48:24 <geppettodivacin> Indeed. I get the same error you do.
19:48:30 <geppettodivacin> I thought it was a build error. Sorry.
19:48:55 <HaskellerNewbie> nope, thanks for your effort!
19:49:37 <geppettodivacin> HaskellerNewbie: I suspect it's a package that's been allowed to decay and die. It's been a year since the author updated the code.
19:49:45 <Cale> Ah, you need to specify a module to load with -m<filename>
19:49:50 <geppettodivacin> Oh.
19:49:56 <geppettodivacin> That would in fact be why, then.
19:50:22 <Cale> I don't think this is meant to be used by hand like this
19:50:45 <HaskellerNewbie> I want to make IntelliJ + https://github.com/atsky/haskell-idea-plugin + https://github.com/octomarat/HaskellDebugger work together but debugger fails
19:51:54 <HaskellerNewbie> yes, I think if it works fine on CLI it'll works fine on IntelliJ too, maybe...
19:52:00 <HaskellerNewbie> I thought
19:52:25 <geppettodivacin> HaskellerNewbie: After using the -m option as Cale suggested, it works.
19:52:36 <geppettodivacin> I'm not sure what it's supposed to do.
19:52:39 <HaskellerNewbie> works?
19:52:44 <geppettodivacin> But it doesn't panic.
19:52:50 <HaskellerNewbie> I'm still getting panic
19:53:19 <geppettodivacin> What is the command you're running?
19:55:14 <HaskellerNewbie> remote-debugger without command/ remote-debugger -m /path/to/src/Main.hs
19:55:20 <HaskellerNewbie> it print panic too
19:56:03 <geppettodivacin> HaskellerNewbie: Don't put a space between the -m and the path.
19:56:12 <geppettodivacin> Then try it again.
19:56:26 <HaskellerNewbie> oh
19:56:47 <HaskellerNewbie> my god, thank you! one small progress!
19:57:53 <HaskellerNewbie> change that small to big! Thanks a lot.
20:00:03 <xnil> How do I initialize the Idris repl from Stack?
20:00:14 <scshunt> suppose I make a change to a library package and want to test with my stackage project
20:00:24 <xnil> for haskell it's `stack repl` but of course idris is a package installed by stack so it won't work that way
20:00:27 <scshunt> How do I build an appropriate package and tell stackage to use it rather than the version in stack?
20:01:27 <HaskellerNewbie> I have no idea how to make this work on IntelliJ
20:01:48 <catsup> is there a standard function that flips an Either?
20:03:33 <dolio> either Right Left
20:04:38 <HaskellerNewbie> can you tell me popular way or normal way to debug haskell code?
20:05:09 <HaskellerNewbie> i read https://wiki.haskell.org/Debugging but it seems gdb way
20:05:57 <Jinxit> I haven't used any specific software for it, but I haven't written anything larger than a couple of pages of code
20:06:12 <Jinxit> the REPL is your friend
20:06:47 <geppettodivacin> HaskellerNewbie: I've used trace (as suggested in the article) and also just tested individual functions with ghci.
20:07:11 <geppettodivacin> If you make the functions small and testable enough, most debugging can be done simply by running your functions on different inputs.
20:07:42 <HaskellerNewbie> I'm from C++ world, I'm unfamiliar with almost anything in this Haskell world... orz
20:07:50 <geppettodivacin> Admittedly, it's not always possible for large code bases, but if you're just starting out, it should definitely be fine.
20:08:18 <geppettodivacin> HaskellerNewbie: How are you teaching yourself Haskell? With a book, a friend, etc?
20:08:42 <HaskellerNewbie> I think edx lecture with book
20:09:21 <HaskellerNewbie> it's hard because i'm not a english native
20:09:58 <saurabhnanda> I keep getting confused, should I be using ExceptT/EitherT or not?
20:10:10 <HaskellerNewbie> I thinks it's time to give up on this IntelliJ thing
20:10:23 <HaskellerNewbie> Thanks a lot geppettodivacin
20:10:39 <HaskellerNewbie> and Cale
20:10:49 <geppettodivacin> HaskellerNewbie: No problem! Feel free to ask questions when you start coding, too!
20:11:35 <Cale> HaskellerNewbie: If you just want to get started quickly, just grab any text editor you like (so long as it can be configured to convert tabs to spaces, that's important), and just use it alongside ghci
20:12:12 <Cale> HaskellerNewbie: You can have ghci open in a window alongside your editor, and whenever you save new changes, type :r in ghci to reload the file and try them out
20:13:08 <HaskellerNewbie> ah, OK. I think atom or sublime text before trying vim or emacs, lol
20:14:01 <geppettodivacin> Sublime seems like a pretty good text editor if you aren't into the whole vim/emacs power user kind of thing.
20:14:01 <hackrilege> :set editor emacs
20:14:19 <geppettodivacin> Most of us just already have one text editor or another under our fingers.
20:14:46 <hackrilege> i use :e to open up the default editor which is notepad on windows often
20:14:49 <saurabhnanda> can anyone take a look at this code and give me a suggestion? Should I be using ExceptT or EitherT here? http://lpaste.net/159555
20:16:33 * hackagebot yesod-static-angular 0.1.8 - Yesod generators for embedding AngularJs code into yesod-static at compile time  https://hackage.haskell.org/package/yesod-static-angular-0.1.8 (JohnLenz)
20:16:45 <TheMystic> String parsing question. GitHub's API gives me a Link: header that looks like: <https://api.github.com/organizations/1075558/repos?&page=2>; rel="next", <https://api.github.com/organizations/1075558/repos?&page=5>; rel="last"
20:17:08 <TheMystic> What's a quick way to pull out just the URL of the next page?
20:17:57 <TheMystic> Assuming I want to do it the "right" way and split on commas, then look at the rel= attribute and extract the URL if it's "next"
20:18:09 <HaskellerNewbie> I hope to be CLI expert like you guys too! I'm trying to get used to
20:19:24 <xnil> i wish a cli expert would come to the rescue for me.
20:19:46 <xnil> gonna ask again: how do i start up idris' repl, if i've installed idris using stack?
20:20:17 <kadoban> Same way you'd start it anyway, I'd think?
20:21:12 <geekosaur> it should be in ~/.local/bin, you might prepend that to $PATH
20:21:15 <kadoban> xnil: In case this is the part you're missing: stack installs binaries in ~/.local/bin/ , which you should likely add to your PATH
20:21:17 <geekosaur> otherwise, stack exec -- ..
20:24:50 <hackrilege> TheMystic, you could use https://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html#v:splitOn
20:24:53 <xnil> ah ok thank you kadobanban
20:25:05 <xnil> and geekosaur
20:25:23 <xnil> wait no
20:25:28 <xnil> there's no .local/ at all
20:25:41 <kadoban> xnil: Did you do 'stack install whatever' ?
20:25:48 <xnil> stack install idris.
20:26:16 <xnil> oh, derp
20:26:19 <xnil> just some perms problems
20:26:23 <xnil> thank you
20:26:44 <kadoban> In case you don't know: don't run 'stack' as root or using sudo or anything, there's no need to.
20:27:47 <xnil> yeah, somehow my /home/xnil/ got de-permed
20:28:11 <kadoban> weird
20:28:32 <xnil> #justubuntuthings
20:34:40 <xnil> wow, this is taking an eternity to build
20:35:35 <xnil> oh, i ran out of memory.
20:35:41 <scshunt> does anyone know how to override a stackage package when trying to build multiple packages in concert?
20:35:44 <xnil> nevermind. i wanted to love you, idris.
20:36:14 <scshunt> xnil: did you make it infinite loop/overflow?
20:36:31 <xnil> dunno how to make the installer loop like so
20:36:40 <kadoban> scshunt: You put your specific version in the packages section, and set extra-dep: true. You have to either have it locally or point to like a git commit in a git repo.
20:37:40 <scshunt> kadoban: how do I point it locally?
20:37:57 <scshunt> and is this in stack.yaml?
20:40:55 <kadoban> scshunt: Yeah, in stack.yaml. I can probably find the syntax, it's in the docs somewhere.
20:42:00 <scshunt> kadoban: docs? what docs?
20:42:06 <scshunt> I've never been able to find them :/
20:42:16 <kadoban> Hehe
20:42:41 <kadoban> scshunt: http://docs.haskellstack.org/en/stable/
20:42:48 <kadoban> I should be able to find the exact part you need though, sec.
20:42:50 <xnil> is there any talk of a Rust FFI for haskell
20:43:51 <xnil> whoa, i just looked at it being done https://github.com/aisamanra/rust-haskell-ffi/blob/master/main.hs
20:43:53 <xnil> that's really nice
20:44:10 <kadoban> scshunt: http://docs.haskellstack.org/en/stable/yaml_configuration/#project-config You want something like some of those packages: sections, make sure you notice the one extra-dep: true  setting too, you want that.
20:44:18 <scshunt> thanks
20:45:21 <hackrilege> i was looking into zippers, there is the game of life with a 2d zipper here http://lpaste.net/159547
20:45:30 <mmercer> how mature is haskell on android?
20:45:49 <kadoban> mmercer: Not at all.
20:46:01 <mmercer> too bad
20:46:06 <hackrilege> it has worked, but its not stable
20:46:10 <kadoban> If you want android, I'd probably personally look into doing like GHCJS with something like sencha touch maybe.
20:46:31 <kadoban> Or some of those other ones, condova whatever.
20:48:31 <hackrilege> mmercer check out neurocyte, via the llvm backend targeted to arm
20:49:20 <hackrilege> if you can get it to work post a write up!
20:50:48 <hackrilege> i have used the haskell package for linux on a debian kernal in an app using proot without rooting my phone
20:55:41 <saurabhn_> quick question. I'm inside the ExceptT monad and have a function which returns an "Either String a" value. How do I compose it?
21:16:58 <orion> grr
21:19:14 <Oejet> dylukes
21:19:21 <orion> Are Chans safe to use with async's 'concurrently' function so long as I have -threaded enabled?
21:19:41 <dylukes> hey wha's up Oejet 
21:22:03 * hackagebot gpio 0.1.0.2 - Haskell GPIO interface, designed specifically for the RaspberryPi.  https://hackage.haskell.org/package/gpio-0.1.0.2 (tgolson)
21:25:09 <tmft> test
21:25:35 <hackrilege> toast
21:26:46 <Cale> orion: Chans are safe whether you have -threaded enabled or not
21:29:48 <orion> Cale: I am running in to a problem with Chans. Imagine you setup two TLS participants which talk to one another in the same application. Imagine that you are using 'concurrently' to run the two connections and the threads are communicating via a single Chan. If you try to run that code you start getting decryption errors, BUT if you add "threadDelay 1000" after writeChan or readChan, everything works perfec
21:29:48 <orion> tly.
21:30:13 <Cale> what the...
21:31:22 <Cale> orion: It must be some detail regarding how TLS is being used
21:31:43 <c_wraith> my best guess is that the decryption error is caused by an exception thrown by an indefinite blocking error caused by a race condition in how the Chans are used
21:32:05 <c_wraith> Or..  wait.  Openssl bindings for SSL?
21:32:13 <c_wraith> By default, OpenSSL isn't re-entrant.
21:32:25 <c_wraith> That is, being used by two threads concurrently will break it.
21:32:37 <c_wraith> Unless you compile it with the special flags that say to not be broken.
21:34:19 <Cale> Yeah, you may want to start up a thread in which all openssl stuff happens, and talk to that thread via chans
21:36:30 <orion> c_wraith: I'm not actually using TLS. I said "TLS" because I don't think people know what Noise is yet.
21:37:19 <orion> Cale: How would I test that theory?
21:38:31 <dylukes> It works :D
21:38:31 <dylukes> Cale I solved the problem
21:38:40 <dylukes> now to turn in 80 lines of extremely terse but well commented Haskell
21:38:48 <Cale> dylukes: cool
21:38:50 <dylukes> Where I'm pretty sure ~200 lines of Java were expected.
21:39:15 <dylukes> Not sure if my code is all that great, but it works well enough.
21:39:19 <dylukes> My Haskell is so rusty.
21:40:28 <Cale> orion: uhh, well, if you're doing FFI to a C library for whatever crypto it is, you can generally expect things to be broken in the face of concurrency, because C is difficult when it comes to writing code which is safe in that regard.
21:41:16 <orion> Are there any tools I can use to track down the source of the problem?
21:42:08 <Cale> Oh, right, you were the guy with the heavily typed crypto library stuff...
21:42:13 <Cale> :)
21:42:19 <orion> ha, yes
21:42:50 <Cale> I don't know if it's that easy to track down apart from just not interacting with the C library from more than one thread.
21:43:25 <kadoban> orion: You should be able to check the docs for the library and see if it's reentrant, and if not … well, you're at least doing something that's not at all supposed to work, so you can safely assume that needs to be fixed.
21:43:52 <Cale> Yeah, it's just something you have to hope that the library authors documented
21:44:35 <kadoban> If they didn't, the safe assumption is they didn't code it to be reentrant either.
21:45:25 <orion> I'm using cryptonite.
21:45:40 <Cale> oh
21:45:54 <Cale> In that case, it'd be a cryptonite bug...
21:47:18 <orion> Sure, but I need evidence to support that claim.
21:47:38 <orion> I'm not sure how I would go about locating the exact source of the problem.
21:49:05 <Cale> Well, try to simplify your test case if it's complicated
21:50:34 <Cale> Maybe you can get it down to just a simple concurrently with some computations to which you know the desired result
21:50:43 <Cale> (in cryptonite)
21:51:22 <Cale> and if you can show that the result is incorrect when you run them together, that narrows down what you're looking through
21:52:22 * hackagebot twilio 0.1.3.1 - Twilio REST API library for Haskell  https://hackage.haskell.org/package/twilio-0.1.3.1 (andrus)
22:14:18 <cheater> that new boltzmann sampler for quickcheck looks very interesting
22:45:20 <mikeplus64> is there any package for generating html from ansi-wl-pprint Doc? looking at the type itself i don't see why it shouldn't be possible
22:47:06 <mikeplus64> alternatively, ansi terminal output -> html :)
22:48:28 <astones> I have a quesiton
22:48:30 <astones> http://pastebin.com/05Qz0dTU
22:49:20 <astones> this is a function to determine the length of a collatz chain(?) 
22:49:41 <astones> I've had a few functions like this, and writing it using i seems wrong 
22:49:52 <astones> is there some way I should be doing this?
22:50:13 <astones> I mean, it works as it is, but is that the right way to do this?
22:50:40 <dmwit> Seems fine. If you want you can do it without `i` but there's no real need to.
22:51:33 <dmwit> e.g. `collatz x | x == 1 = 0 | even x = 1+collatz (quot x 2) | otherwise = 1+collatz (3*x+1)
22:51:36 <dmwit> `
22:52:10 <astones> the point is to get the length though
22:52:24 <dmwit> Yes, and?
22:53:12 <astones> oh, I see
22:53:20 <astones> I just got it 
22:53:22 <astones> sorry about that
22:54:00 <dmwit> If you plan to use this for actual calculations you should pay attention to a few things. But I suspect this is rather an exercise than something you plan to use for serious computatio.n
22:54:34 <astones> I'm learning haskell expressly for the purpose of learning haskell
22:54:51 * dmwit nods
22:55:00 <astones> what are the few things I should pay attention to?
22:55:33 <dmwit> Laziness is going to mean that for long chains this function produces a very deeply nested thunk.
22:55:46 <dmwit> That can lead to stack overflow in old GHC's or prodigious memory use in new GHC's.
22:56:26 <astones> the solution to this would be? 
22:56:57 <dmwit> Go back to using `i`. =) (And add some strictness annotations with `seq` or bang patterns or similar.)
22:57:35 * hackagebot tidal-midi 0.6 - MIDI support for tidal  https://hackage.haskell.org/package/tidal-midi-0.6 (AlexMcLean)
22:57:47 <dmwit> e.g. make the calls be `collatz (quot x 2) $! i+1` and `collatz (3*x+1) $! i+1`, respectively.
22:57:50 <astones> does my original solution there not cause a stack overflow for large chains?
22:58:10 <dmwit> It's possible that GHC's strictness analysis can catch this one, actually. Might be worth experimenting with -O2 to make sure.
22:58:25 <dmwit> astones: Your original solution has the same problem as the one without `i`.
22:58:57 <astones> but adding $! would fix it? 
22:59:03 <dmwit> yes
22:59:35 <astones> I'm not at all familiar with bang patterns
22:59:41 <astones> I'll have to look those up
23:00:00 <dmwit> Okay. But just to be clear, `$!` is not a bang pattern.
23:00:03 <dmwit> ?src ($!)
23:00:03 <lambdabot> f $! x = x `seq` f x
23:02:31 <astones> so what exactly does ! do? from what I can see $ allows for collatz (quot x 2) $ i+1
23:03:08 <astones> 'collatz (quot x 2) $ i+1' for clarity 
23:03:52 <dmwit> `$` and `!` are not separate here. They are one token; one function name.
23:04:09 <astones> oh
23:04:31 <astones> I thought it was similar to saying  'i + 1' or 'i+1'
23:05:49 <astones> and so '$! i+1' was equalivent to '$ ! i+1'
23:07:51 <jle`> $ ! i + 1 isn't a meaningful thing in Haskell syntax, either
23:08:09 <jle`> you can't use two operators in a row like that
23:08:21 <astones> learning so much right now
23:08:52 <astones> looking up what exactly seq is, because I have a feeling that's what will allow me to understand the rest of it 
23:10:27 <jle`> `seq x y` says, "the result is supposed to be y, but when you evaluate this, evaluate x too"
23:11:10 <jle`> > seq "hello" 10
23:11:12 <lambdabot>  10
23:11:21 <jle`> > seq (sum [1..]) 10
23:11:31 <lambdabot>  mueval: ExitFailure 1
23:12:11 <astones> so this doesn't cause a stack overflow because 
23:12:21 <astones> I'm trying to work though this
23:12:28 <jle`> > snd (seq (sum [1..]) 10, "hello")
23:12:29 <lambdabot>  "hello"
23:12:35 <jle`> where would you expect a stack overflow to happen?
23:12:39 <jle`> we don't really have stack overflows in Haskell
23:12:41 <jle`> in the traditional sense
23:13:14 <jle`> so it'd be pretty surprising if an error that doesn't exist in Haskell starts showing up :P
23:13:32 <astones> an extremely long collatz sequence  using the script I had pasted earlier
23:13:49 <astones> I would expect to at least reach recursion depth
23:13:58 <jle`> recursion isn't implemented using a call stack
23:14:14 <jle`> so "recusion depth" isn't really a meaningful thing
23:14:52 <astones> I feel like I've hit a limit before
23:14:59 <jle`> you might have hit a heap limit
23:15:11 <jle`> where the memory your program takes up overflows heap memory
23:15:42 <astones> would using seq save me from that, and if so, how?
23:15:58 <zRecursive> @src seq
23:15:59 <lambdabot> Source not found. Abort, Retry, Panic?
23:16:08 <zRecursive> @src sequence
23:16:08 <lambdabot> sequence []     = return []
23:16:08 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:16:08 <lambdabot> --OR
23:16:08 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:16:29 <jle`> yeah, seq would help because laziness in GHC is implemented by allocating stuff, so if you have a bunch of chained lazy evaluations, you're going to have a bunch of allocations at each step
23:16:31 <cocreature> zRecursive: seq and sequence are two completey different things
23:16:48 <jle`> using seq prevents unnecessarily allocations that come from laziness
23:17:01 <zRecursive> cocreature: where is the source of `seq` ?
23:17:08 <jle`> um, i explained that in a really weird way, sorry
23:17:10 <cocreature> zRecursive: it’s a primitive so there is no source
23:17:23 <cocreature> zRecursive: well not unless you want to dig through the ghc source code
23:17:34 <zRecursive> ok
23:17:36 * hackagebot mono-traversable 0.10.2 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-0.10.2 (MichaelSnoyman)
23:17:42 <jle`> seq is sort of like a hint for the compiler, so it's not really "writable" in haskell.  it's provided by the compiler for you to use to give it hints
23:17:50 <jle`> or i suppose you can say:
23:18:04 <jle`> seq !x y = y
23:18:06 <jle`> hehe
23:18:30 <ahihi> aren't bang patterns implemented in terms of seq? :P
23:18:44 <jle`> :P
23:18:58 <cocreature> astones: in your case you are never forcing the evaluation of i, so (without optimizations) you’ll end up with (((i+1)+1)+1)… taking up a linear amount of memory and only at the end you are evaluating it
23:19:10 <jle`> ahihi: technically, they have their own semantics, so it could have been the other way around, too
23:19:17 <jle`> if we're just talking about the denotative semantics
23:19:27 <astones> (((i+1)+1)+1)… 
23:19:30 <jle`> s/their own/meaningful
23:19:31 <astones> this is what did it for me
23:19:59 <cocreature> astones: each recursive call to collatz adds one +1 
23:20:16 <zRecursive> a bit like foldl ?
23:20:18 <jle`> yeah, you're actually *allocating* a huge deferred computation tree that represents ((i+1)+1)+ .. etc.,  you can imagine a tree data structure with + as nodes, 1 as leaves, all being represented in memory
23:20:23 <astones> sorry, I meant that's what caused understanding
23:20:29 <cocreature> ah great :)
23:20:32 <jle`> so if you have enough, you're going to fill up the entire memory with that tree
23:20:51 <astones> followup question there then
23:20:52 <astones> collatz x   | x == 1 = 1   | mod x 2 == 0 = collatz (quot x 2)   | mod x 2 == 1 = collatz (3*x+1)
23:20:53 <cocreature> astones: so seq allows you to impose an ordering on evaluation, if you use seq i (collatz …) before every recursive call i will be evaluated
23:20:54 <jle`> before you can even begin to do the addition
23:21:05 <astones> would that allow for arbitrarly large chains?
23:21:21 <cocreature> afaik no, since == evaluates x
23:21:37 <cocreature> so the evaluation can’t be delayed
23:22:13 <dmwit> jle`: I told him it would cause a stack overflow on old GHC's. This was true back then, as deeply-nested thunks did indeed result in stack overflows.
23:23:21 <jle`> if you mean old as in ~ 7.6, i still think that calling it a "stack overflow" is misleading, since it's not an overflow of a call stack, which is what "stack overflow" means in other languages/contexts
23:23:21 <catsup> what's the prism to get the head of a list?
23:23:26 <astones> cocreature: I don't follow at this point 
23:23:40 <dmwit> jle`: "stack overflow" is what GHC called it when it printed an error.
23:24:03 <dmwit> I agree that it is a different kind of stack than the one traditionally used in other languages.
23:24:08 <astones> dmwit: that's true, I do remember seeing that error on something I had made very poorly
23:24:27 <jle`> yeah, i remember those days.  it was the overflow of the evaluation stack, but having it being called 'stack overflow' did lead me down a bunch of wild paths trying to solve it
23:24:50 <cocreature> astones: when collatz is called it first compares x to 1 using ==. to do that it has to figure out what x actually is. so if x previously was some large chain it will now be evaluated. since you are doing this in each recursive call you can’t build up a large chain since it is cleaned up at every point
23:25:03 <cocreature> collapsed is probably a better term than cleaned up
23:25:14 <astones> okay
23:25:30 <astones> so x == 1 = 1 is what is causing the problem here 
23:25:41 <astones> I see now
23:25:49 <cocreature> it’s not a problem, it’s what saves you from leaking memory :)
23:26:47 <astones> well, yes, but "the problem" in my head is that for very large chains, there's an issue where it won't reach the end given enough time
23:27:19 <astones> even though in that state it's a completely useless function, that just returns 1 
23:27:31 <enthropy> catsup: _head is probably what you're thinking about, but it's not a prism because it wouldn't follow the laws
23:28:04 <cocreature> astones: well that’s a property of the collatz sequence not of your code, right?
23:28:48 <astones> yes, it is
23:28:58 <enthropy> catsup: prism' (\x -> [x]) (\y -> case y of [x] -> Just x; _ -> Nothing) -- doesn't have a name afaik
23:29:09 <catsup> it's folded
23:29:22 <astones> but unless you're confirming a sequence ends at 1, there's no reason to call the collatz function I had just written
23:29:48 <astones> okay, so I think I've found a way to phrase what is confusing to me here
23:30:02 <cocreature> that’s great, because I no longer no what’s confusing you :)
23:30:18 <cocreature> *know (wtf, it’s too early)
23:30:31 <astones> http://pastebin.com/cQLkbt1n 
23:30:51 <astones> to prevent confusion later, that's the function I'm currently talking about
23:30:58 <catsup> > [Right 5] ^? folded . _Right
23:30:59 <lambdabot>  Just 5
23:31:01 <astones> so on each recursion
23:31:38 <astones> x would already be evaluated, say you call 'collatz 16 '
23:32:21 <astones> x == 1 : ghc should be able to say no immediately. second line it would call collatz 8 
23:32:40 <astones> ghc should also be able to say no immediately to 8 == 1
23:32:43 <cocreature> nope
23:32:49 <cocreature> it will call collatz (quot x 2)
23:32:58 <cocreature> eh collatz (quot 16 2)
23:33:03 <cocreature> it won’t directly evaluate it to 8
23:33:20 <astones> but once it hits the first line, it will eval to 8
23:33:23 <cocreature> yep
23:34:10 <astones> so at no point in time should more than 2 
23:34:11 <astones> um
23:34:16 <astones> I'm not sure of the word here
23:34:19 <astones> functions?
23:34:22 <astones> recursions?
23:34:52 <cocreature> “thunk” is what we call the things that are evaluated
23:34:59 <astones> thunk
23:34:59 <jle`> i'm not sure what your function is intended to return, btw
23:35:00 <astones> okay
23:35:05 <astones> 1
23:35:06 <jle`> is it just always supposed to return 1 for every number?
23:35:10 <astones> yeah
23:35:16 <astones> it's a useless function, like I said
23:35:18 <jle`> ah, ok
23:35:24 <jle`> collatz _ = 1 :)
23:35:25 <astones> purely for learning purposes
23:35:35 <cocreature> at least it will always return 1 if the collatz conjecture is correct :P
23:35:42 <cocreature> iirc it’s not yet proven
23:35:42 <jle`> ah, yes
23:35:50 <jle`> i have a proof but it doesn't fit in this irc channel
23:35:55 <astones> but at no point in time should more than 2 thunk(s?) be in memory
23:35:59 <cocreature> @where lpaste
23:35:59 <lambdabot> http://lpaste.net/
23:36:02 <cocreature> ^ jle` :P
23:36:02 <astones> thanks for that fermat 
23:36:27 <astones> is that not the way this works though?
23:36:48 <jle`> try evaluating this by hand on pen and paper
23:37:13 <jle`> that'll help you see when evaluation is being deferred and when it isn't
23:37:22 <jle`> and how many layers of thunks you're building up
23:37:34 <cocreature> astones: that sounds correct, although if you want to be precise (3*x+1) is (3*x)+1 which consists of two thunks, so you have three in total, but the exact number is not important. it’s just important that it doesn’t blow up
23:38:22 <jle`> collatz 4 = collatz (x `quot` 2)
23:38:40 <jle`> er, collatz 4 = collatz (4 `quot` 2)
23:38:53 <timbod7> What am I allowed to pass as X in `stack runghc --package X`? In particular, is there some way I can pass a path to a package that only exists in a local file? When I try to do this, I get a somewhat obscure message `No local directories found as children of X`.
23:39:03 <jle`> now, in order to evaluate collatz (4 `quot` 2), we need to evaluate (4 `quote` 2) enough to be able to evaluate the guards
23:39:18 <jle`> in this case, to do == 1, etc., we evaluate it down to the actual number -- 2
23:39:36 <Axman6> timbod7: #haskell-stack might be more useful
23:39:36 <jle`> so collatz (4 `quot` 2) = collatz 2 = collatz (2 `quot` 2)
23:39:45 <jle`>  = collatz 1 = 1
23:39:52 <jle`> and there you go :)
23:39:53 <timbod7> Axman6: thanks. I'll try there.
23:40:08 <jle`> you never build up any crazy nested thunks when evaluating collatz 4
23:41:19 <jle`> compare this to, say, foldl (+) 0 [1,2,3] = foldl (+) (0 + 1) [2,3] = foldl (+) ((0+1)+2)) [3] = foldl (+) (((0+1)+2)+3) [] = ((0+1)+2)+3
23:41:36 <astones> my thoughts are (using 16 again, because it's easy) http://pastebin.com/AYE3fBc6
23:41:55 <jle`> you never need to collapse any of the +'s together because it's never necessary to "proceed" for evaluation
23:42:17 <astones> I feel like thunks should be dropped where x is evaluated
23:42:20 <astones> is this not the case?
23:42:22 <Axman6> timbod7: usually you'd specify the path in your stack.yaml file though
23:42:37 <jle`> the first thunk that happens is (16 `quot` 2), but, you need to evaluate (16 `quot` 2) == 1
23:42:46 <jle`> so the process of evaluating that forces the thunk, to be 8 == 1
23:43:33 <cocreature> btw are evaluated thunks still called thunk?
23:43:33 <jle`> btw, collatz quot 16 2 is parsed as ((collatz quot) 16) 2, not collatz (quot 16 2)
23:43:34 <timbod7> Axman6: Yes - I understand that. But I'm writing a standalone script, with inline stack config as per the documentation.
23:43:58 <jle`> i call them forced thunks...but yeah, i'm not sure whether or not they're technically called thunks or not
23:44:04 <astones> yeah, and then collatz 16 should be dropped entirely from memory, as if you've called collatz 8
23:44:18 <astones> that was my understanding of it
23:44:19 <jle`> hold on, are you aware of how evaluation works in haskell?
23:44:22 <timbod7> Also - I don't think haskell-stack is an irc channel on freenode.
23:44:24 <astones> that may be entirely wrong
23:44:30 <jle`> "evaluation by substitution" ?
23:44:37 <cocreature> timbod7: it is
23:44:46 <kadoban> timbod7: I don't know that I've ever seen a syntax for that allowed in --package. Not sure it exists.  It's #haskell-stack
23:44:49 <jle`> evaluating functions in haskell works pretty much as if you're substituting the definition for the call
23:45:44 <jle`> so, if `collatz 16` happens, evaluating it becomes evaluating collatz (16 `quot` 2)
23:45:46 <timbod7> found the channel -- redirecting.
23:46:17 <jle`> and, now we need to know what to substitute collatz (16 `quot` 2) for
23:46:34 <astones> and then when you hit x == 1 it evaluates x to 8, right?
23:46:38 <jle`> in order to do that, we see which guard it matches ... the first, second, or third?  and in order to do that, we have to evaluate (16 `quot` 8)
23:46:46 <jle`> er, 16 `quot` 2, yeah
23:46:51 <astones> yeah
23:47:04 <jle`> so now we want to evaluate collatz 8, and that is substituted for collatz (8 `quot` 2)
23:47:10 <jle`> and so on
23:47:36 <astones> that feels like it should be allowed to go on forever
23:47:41 <astones> without using up all the memory
23:48:06 <jle`> yeah, i feel like this should be constant-space evaluation
23:48:10 <jle`> are you compiling with optimizations?
23:48:39 <astones> I have no idea, to be honest, this is mostly just a thought experiment and making sure I'm understanding how recursion works in haskell properly
23:48:52 <astones> and also learning for the sake of it
23:48:56 <cocreature> so it’s not actually using up all your memory?
23:49:00 <jle`> yeah, the process of evaluating "collatz n" should chug away in constant space
23:49:09 <jle`> unless there are bugs or space leaks in GHC itself
23:49:33 <cocreature> or you are not working with Int but some other instance of Num :)
23:49:51 <astones> okay, so after you hit the x == 1, collatz (the previous x) is completely dropped
23:50:24 <astones> and you now have collatz (whatever your current x is), as if that was the function you had called
23:50:30 <jle`> astones: well not exactly, when you hit x == 1, collatz (16 `quot` 2) becomes `collatz 8`
23:50:37 <cocreature> it’s replaced not dropped
23:51:03 <astones> I meant that, I'm just really really bad at phrasing things :P 
23:51:11 <astones> especially when it's 3 am
23:51:21 <jle`> yeah. if you try compiling this with optimizations on, it should be able to chug away in constant space
23:51:27 <astones> okay
23:51:46 <astones> so this http://pastebin.com/cQLkbt1n 
23:52:04 <cocreature> jle`: what optimizations do you need for this? I thought it should work even without them
23:52:06 <astones> should be able to chug away forever reguardless of if the collatz conjecture is false
23:52:33 <jle`> cocreature: i just said so as a precaution, heh.  but yeah, i suspect you're right
23:52:33 <astones> or: how would I need to change that to allow for that
23:52:47 <jle`> astones: it will operate in constant space, if that's what you mean
23:52:51 <cocreature> jle`: k, just making sure my understanding is not completely broken :)
23:52:59 <jle`> there could be some GC things
23:53:05 <jle`> not sure, heh
23:53:42 <jle`> astones: if you mean 'forever' as in, 'will not be limited by the space of my memory', then yes.  it operates in constant space
23:53:56 <astones> jle`: what I mean is supposing there were a number that looped back on itsself, and I had a computer that never turned off
23:54:19 <astones> that would work, and just never spit out an answer
23:54:35 <jle`> the most precise thing i could say is that it works in constant space
23:54:47 <jle`> the space usage doesn't grow over time, or with bigger n
23:55:02 <astones> okay
23:55:25 <astones> (3*x+1) being a bigger thunk was mentioned earlier
23:55:35 <kadoban> Well, I mean it'll grow logarithmically in x, but that shouldn't get too large usually ;)
23:55:53 <astones> lol
23:55:56 <cocreature> kadoban: we assume Int is used so it’ll just overflow :)
23:56:06 <jle`> astones: bigger, but bounded
23:56:08 <kadoban> Hehe, problem solved XD
23:56:27 <cocreature> kadoban: more like replaced by the problem of overflows :)
23:57:02 <astones> purely for the purposes of entertaining the idea here though
23:57:20 <astones> I'm not going to be making optimizations with this in mind, ever
23:57:25 <astones> I just want to make that clear
23:57:40 <astones> (3*x+1) is a bigger thunk than (quot x 2) 
23:57:43 <astones> so
23:57:49 <astones> would that means it uses more memory?
23:58:32 <jle`> i believe so, barring some optimizations from ghc or something.  but yeah, that doesn't change the asymptotics
23:59:00 <cocreature> I would be very surprised if the strictness analyzer doesn’t kick in here
23:59:20 <astones> so collatz 4 would, in fact, take up less memory than collatz 5
23:59:38 <jle`> maybe, but at this point we're talking about implementation details
23:59:38 <cocreature> but it’s one instruction more so even if you write it in assembly it will take up slightly more memory
23:59:57 <astones> purely because at some point in collatz 5 uses (3*x+1) at some point
