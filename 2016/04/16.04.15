00:00:02 <EvanR> fmap f and F(f) are just two notations for the same thing
00:00:17 <hackrilege> i thought F was like the constructor
00:00:19 <EvanR> its a function from f a to f b
00:00:30 <hackrilege> F /= f
00:00:32 <hackrilege> ok
00:00:43 <EvanR> F(X) is like the constructor
00:01:03 <hackrilege> nah im lost i cant understand what F is
00:01:16 <EvanR> i should have said, its a function from F a to F b
00:01:17 <cocreature> F is a functor C → D, it consists of two mappings, one on objects and one on arrows. in haskell the type constructor is the mapping on objects and fmap is the mapping on arrows
00:02:37 <EvanR> yeah basically everything followed from what a functor is
00:02:54 <EvanR> its core to life the universe and everything
00:04:13 <EvanR> hackrilege: you can consider any functor like Maybe, or whatever to be a data structure for describing expression trees to be evaluated
00:04:40 <EvanR> if a is the carrier type, then f a is the type of expression trees
00:04:48 <EvanR> and eval :: f a -> a is the evaluation rule
00:05:43 <EvanR> this is the functor for monoids, one kind of algebra
00:06:27 <dsub> Is this from category theory?
00:06:44 <EvanR> data T a = MEmpty | MAppend (T a) (T a)
00:07:03 <EvanR> | Something a
00:07:06 * EvanR hmmmm
00:09:11 <EvanR> dsub: yes... but i think this particular thing was originally from universal algebra?
00:09:58 <dsub> Ok. I wouldn't know, just asking to learn :)
00:11:16 <EvanR> the type T is actually just... data List a = Empty | Cons a (List a) when you take into account the associativity
00:11:48 <EvanR> and identity
00:11:58 <EvanR> or maybe i jumped the gun
00:30:31 <EvanR> apparently essential material for haskell and algebra/coalgebras http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
00:36:03 <dsub> This is over my head...
00:36:28 <EvanR> me too for the most part
00:38:56 <EvanR> the point is that ADTs are initial algebras of some endofunctor in haskell (and infinite ADTs are final coalgebras of some functor)
00:39:27 <EvanR> but not sure exactly how or to which or how often or why we should care ;)
00:40:01 <EvanR> one day one day
00:51:36 <Cale> EvanR: Well, the unique map is something interesting
00:52:51 <Cale> EvanR: I guess once you understand what the unique maps which make the thing initial/final are, you're allowed to not care again :)
00:54:20 <EvanR> there is a fold which lets you decide which algebra to specialize to
00:54:36 <EvanR> or unfold
00:55:12 <EvanR> but what i dont understand is which functor corresponds to the F in F-algebra for a given type
00:55:37 <Cale> EvanR: Well, it's the functor you're taking the fixed point of
00:55:54 <Cale> So in the case of Nat, for example, it's effectively Maybe
00:56:00 <EvanR> oh, does all this necessarily have to do with fix
00:57:06 <EvanR> its not just for list
00:59:27 <EvanR> the F is the non recursive kernel
01:03:30 <dwynwen_ddlleyw> I want to dedicate some time to learning haskell
01:04:09 <Iceland_jack> dwynwen_ddlleyw: Great idea :)
01:04:21 <dwynwen_ddlleyw> It's just so weird 
01:04:30 <dwynwen_ddlleyw> Most everything doesn't make sense 
01:04:45 <dwynwen_ddlleyw> Can I make GUIs in Haskell?
01:05:06 <arianvp> yes!
01:05:59 <dwynwen_ddlleyw> How would I do that?
01:06:20 <EvanR> https://hackage.haskell.org/package/threepenny-gui
01:07:49 <Guest79878> a
01:07:54 <srhb> You can do basically anything in Haskell that you would in another language -- it's just very different. :)
01:08:04 <srhb> Well, some of it is.
01:11:03 <EvanR> This gets you the free-foo monad, and foos are (monad) algebras of the free-foo monad. --doliorules
01:35:12 <Ongy> I'm trying to profile some haskell code, the package has a library and an executable I use for profiling, I copied it into a new dir, did cabal sandbox init, installed deps with library profiling and configure with --enable-library-profiling --enable-executable-profiling. When I execute the executable with +RTS -p I get the .prof file, but it looks *wrong*, MAIN has 25% individual time (timing the executable
01:35:14 <Ongy> says it took 5.17s usertime, so this shouldn't be true)
01:35:39 <quickpaper> Hi! Looking at a Haskell tutorial video. In same cases variables are assigned with a = True, sometimes a <- True, or let. Which is true?
01:36:19 <EvanR> three different situations
01:36:31 <EvanR> a = True -- works at the top level
01:36:36 <EvanR> do
01:36:42 <EvanR>   a <- True -- works in a do block
01:36:48 <kriztw> Ongy: profiling can change the performance characteristics of your program, so I wouldn't be too quick to dismiss it
01:36:58 <EvanR> let a = True in a -- works as a normal expression
01:37:14 <EvanR> do
01:37:22 <lyxia> uh, a <- True will typefail
01:37:26 <EvanR>   let a = True -- also works in a do block, note no `in'
01:37:49 <lyxia> a <- True makes sense in a pattern guard though
01:38:25 <EvanR> do { a <- return True; return a }
01:38:33 <Ongy> kriztw: the MAIN is whatever the rts does before my code is executed and I really don't think that is suppsoed to take over 1 second
01:38:40 <EvanR> just kidding
01:39:16 <kriztw> Ongy: can you pastebin your .prof file? I don't recall it taking that long for me, but on the other hand you seem to be doing the profiling correctly
01:39:31 <quickpaper> Makes sense. So use = generally and <- inside a do block?
01:40:02 <EvanR> you often have to use let x = ... in a do block too
01:40:35 <EvanR> let x = ... is just naming an expression
01:40:48 <EvanR> x <- ... is executing an action
01:41:00 <lyxia> quickpaper: <- is syntactic sugar for monadic bind
01:41:20 <quickpaper> Thanks EvanR Can you provide a quick example function
01:41:53 <quickpaper> lyxia: Hi! Sorry I haven't got to advanced stuff yet. Im 12
01:43:06 <EvanR> http://lpaste.net/160114
01:49:19 <Ongy> kriztw: oh, doing it a 4th time did something else than the first 3 (I didn't change anything -.-) so now the .prof looks reasonable
01:49:27 <Ongy> sometimes I hate profiling...
01:49:38 <lyxia> quickpaper: np I like to say big words to scare people
01:50:04 <quickpaper> EvanR: Installing haskell to try that function. 
01:50:42 <EvanR> no warranty express or implied
01:50:51 <quickpaper> lyxia: :) You're ok!
01:51:17 <quickpaper> EvanR: Just send me a check for $20 for Haskell for Mac if it doesn't work
01:58:09 <doubling> a
01:58:23 <EvanR> stop him hes doubling!
01:58:33 <EvanR> before he gets to aa
02:18:04 <quickpaper> EvanR: Thanks got it to work. The <- as action makes sense. 
02:18:56 <quickpaper> still not clear on when I'd use let quickFun x = do and when quickFun x = do
02:19:44 <EvanR> quickFun x = do... is a declaration, you can use it at the top level or in a where clause
02:20:53 <EvanR> let f x = ... (with no `in') is how you use a let in a do block
02:21:33 <EvanR> and this is the regular let syntax
02:21:49 <EvanR> > let f x = x + 1 in f 7
02:21:51 <lambdabot>  8
02:21:59 <EvanR> that is an expression
02:22:17 <EvanR> let _ = _ in _
02:34:27 <quickpaper> Ok that works too. 
02:34:36 <quickpaper> The let in is smart. 
02:34:45 <quickpaper> I'll keep practicing. Thanks EvanR 
02:39:31 <pauline__> Hey - I'm just going through the IO section of Learn You a Haskell for great good
02:39:56 <pauline__> I've tried the example, the girlfriend one - and it says the file denies permission
02:40:14 <sebbenbear> what does that mean?
02:40:25 <sebbenbear> I've googled it but I still can't resolve the issue
02:40:46 <sebbenbear> at this stage all I want to do is read from the file and display it to screen
02:41:39 <__uu___> hi, when learning the haskell wikibook, should I care about the "Further reading" sections?
02:41:56 <srhb> sebbenbear: paste your code, the locations of the files and where you ran the program from and how.
02:42:08 <srhb> sebbenbear: (lpaste.net)
02:42:19 <srhb> __uu___: Sounds fun, why not?
02:42:53 <__uu___> srhb: since I used to plan go through it asap.
02:43:08 <srhb> __uu___: Then I guess you could leave it for later.
02:43:15 <__uu___> but I am worring aobut missing important messages
02:43:25 <srhb> __uu___: Then you will feel lost and can go back. :-)
02:43:52 <srhb> __uu___: The Wikibook isn't really a comprehensive resource anyway, more useful for looking up specific topics.
02:43:58 <sebbenbear> http://lpaste.net/160115
02:44:07 <sebbenbear> and the input file is a directory down
02:44:27 <srhb> sebbenbear: How did you execute the file and from where?
02:44:33 <sebbenbear> using haskell for mac
02:44:53 <srhb> I don't know what that is. Can you run it from the terminal with runhaskell?
02:45:07 <sebbenbear> I'll try that
02:45:25 <__uu___> srhb: what about the permission of the '../input.txt'
02:45:42 <__uu___> srhb: thanks, that sounds reasonable
02:45:49 <__uu___> quiet reasonable
02:45:58 <sebbenbear> ah ok - it works in the terminal but not the tool
02:46:06 <srhb> sebbenbear: Probably a different path.
02:46:23 <srhb> sebbenbear: If you replace "../input.txt" with an absolute one, it will probably work in both.
02:46:39 <srhb> __uu___: Psychic debugging ruled that one out. :-)
02:46:59 <sebbenbear> yup, magical! thanks very much
02:47:03 <srhb> o/
02:47:16 <sebbenbear> \o
02:50:08 <jophish> hpc: I just looked at the Win32 package; HWND is a type synonym for HANDLE which is a type synonym for Ptr ()
02:50:11 <jophish> how horrible
02:59:02 <arahael> jophish: kinda.  it gets worse.
03:00:21 <arahael> jophish: it's basically a special kind of pointer with all sorts of restrictions involving 3 decades of backwards compatibility. 
03:02:06 <arahael> think thunking(?), 16-bit mode, 32-bit considerations, etc.  i'm not sure, but i'd not really just assume it's a pointer.  i'd rather assume it's a wholly opaque value.
03:02:49 <runeks> Anyone familiar with any tools for generating documentation of a serialization format from a Data.Serialize/Binary.Put instance?
03:06:00 <jophish> arahael: yeah, I've never treated it as anything like a pointer when programming in C++, I'm quite surprised to see that the Win32 package doesn't do the same
03:07:05 <arahael> jophish: it's well known that msdn gets things wrong at times.
03:11:22 <anxys> Hiya, has anyone ever used the MuCheck package?
03:11:52 <arahael> jophish: basically they outsource the doc to an external company, apparently.
03:13:28 <jophish> arahael: I raised an issue https://github.com/haskell/win32/issues/44
03:13:53 <jophish> arahael: I was talking about the Win32 Haskell package
03:16:12 <arahael> ah.
03:16:43 <arahael> jophish: i would consider other haskell code, you do want to be fairly consistent. hwnd is annoying as it is.
03:16:51 <Aruro> Does somebody know any upcoming hackathons in europe? Seems there would be no zurihac this year?
03:21:49 <cocreature> Aruro: there will be a zurihac afaik, it’s planned for july
03:22:12 <Aruro> cocreature: uff ok, last year they started in advance to promote
03:22:31 <cocreature> Aruro: I think the date is not yet fixed and it’s still a few months
03:22:33 <Aruro> cocreature: i remember i registered i think already in february
03:22:46 <Aruro> 3 i in one sentence
03:23:01 <Aruro> cocreature: ok ty nice to know, maybe i email organizers
03:23:33 <cocreature> Aruro: see https://www.reddit.com/r/haskell/comments/4cx5o0/video_jasper_van_der_jeugt_haskell_mistakes_ive/d1m83j1 and the last 5 minutes of that talk
03:25:29 <Aruro> cocreature: ty interesting talk too :)
03:32:21 <Aruro> shm has function split-cases which is very handy for huge sum types, is it possible to have suggestiong generated by -fwarn-incomplete-patterns pluged back into code?
03:41:55 <hjulle> > let f n = do x <- [0..n-1]; x:f x in (!!) ['a'..] <$> f 5
03:41:56 <lambdabot>  "abacabadabacabaeabacabadabacaba"
03:43:29 <hjulle> > let g = do x <- ['a'..]; x:takeWhile (/=x) g in takeWhile (/='f') g
03:43:31 <lambdabot>  "abacabadabacabaeabacabadabacaba"
03:49:06 <Aruro> hjulle: hjulle so?
03:49:30 <jmarciano> I wish to build haskell, but it says I need GHC compiler. I cannot find on website.
03:51:16 <int-index> jmarciano, use the stack tool
03:51:24 <jmarciano> I don't have stack
03:51:25 <hjulle> Aruro: I tried to find the shortest way of generating the "abacaba"-pattern in haskell. ;)
03:51:37 <int-index> jmarciano, http://docs.haskellstack.org/en/stable/README/
03:52:04 <int-index> It will install GHC for you and you can use it to install libraries.
03:53:04 <jmarciano> let me ee
03:53:43 <jmarciano> https://www.stackage.org/stack/linux-x86_64 this connection is untrusted.
03:54:14 <jmarciano> special warning when binary is required to build a compiler. oh....
03:55:47 <Aruro> jmarciano: which os u have?
03:55:51 <orion> jmarciano: Are you behind a corporate firewall?
03:56:39 <jmarciano> their SSL is not trusted for some reason
03:57:41 <jmarciano> that shall NEVER be on download of trusted tool
03:58:35 <Aruro> jmarciano: yes like u understand what NEVER means :D
03:59:19 <int-index> Their certificate is fine. Verify the checksum after downloading
03:59:38 <int-index> someone/something is probably messing with your connection
03:59:46 <jmarciano> it belongs to *.fpcomplete.com
04:00:33 <int-index> download from GitHub to avoid issues: https://github.com/commercialhaskell/stack/releases
04:01:01 <int-index> I personally use their PPA for Ubuntu
04:01:15 <Aruro> hjulle: interesting question, have u looked here: https://oeis.org/search?q=1%2C2%2C1%2C3%2C1%2C2%2C1&language=english&go=Search
04:01:18 <Aruro> hjulle: ?
04:01:29 <jmarciano> int-index: thanks
04:03:06 <Aruro> jmarciano: calm down SLL will not save you :D , https://en.wikipedia.org/wiki/Hardware_Trojan
04:12:34 <__uu___> hi, what is meaning of existence of 'fmap' since we have 'pure' already
04:13:52 <__uu___> and what does the "applicative" mean in "applicative functor"? why "applicative" compared with some other possible names? 
04:14:25 <liste> __uu___: you can have fmap without pure
04:14:45 <jmarciano> I still search how to use stack to install GHC
04:14:48 <jmarciano> I got stack.
04:14:48 <akfp> any war stories on using persistent?  I wonder if I should create lots of tables, or use more JSON serialization with fewer tables.
04:16:04 <__uu___> liste: I did follow you. `fmap f x = pure f <*> x` that is what I know,
04:16:34 <__uu___> but how I can do that "without pure"?
04:17:07 <__uu___> in other words, could I remove the concept of "Functor" from the system ?
04:17:26 <Aruro> jmarciano: run stack setup
04:17:54 <Aruro> jmarciano: in your projects dir
04:19:04 <Darwin226> Hey, is there a way to compose lens (i think prisms in my case) with regular functions?
04:19:35 <liste> __uu___: for example, Const is Functor, but can't be Applicative
04:19:39 <jmarciano> Aruro: thanks
04:19:41 <mniip> __uu___, some datatypes are Funtor but not Applicative
04:19:42 <Aruro> __uu___: fmap is a functor thing not applicative
04:19:49 <mniip> eh, Const r is an Applicative
04:19:53 <mniip> assuming Monoid r
04:20:06 <mniip> Const r, however, is not a Monad
04:20:32 <Darwin226> For example I'm going through a JSON object like this `^? key "something" . _Number . succ`
04:21:00 <jmarciano> I don't know about haskell, I would need to learn how it works. I only want to compile pandoc and have it for future to compile stuff
04:21:02 <Darwin226> This is a simplistic example with the succ function, but I'd use more complicated cases
04:21:55 <Aruro> __uu___: <*> is essentialy functor for Applicative
04:22:40 <Aruro> __uu___: so pure is not needed, it just helps u packing.
04:22:59 <Aruro> :t <*>
04:23:00 <lambdabot> parse error on input ‘<*>’
04:23:49 <Aruro> :t (<*>)
04:23:50 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:24:22 <Aruro> __uu___: remove first f after => and u got yourself functor's fmap
04:26:28 <__uu___> Aruro: "<*> is essentialy functor for Applicative", "functor"? or function ?\
04:26:47 <jophish> arahael: what do you mean by that? "i would consider other haskell code..."
04:27:04 <EvanR> https://raw.githubusercontent.com/sdiehl/cats/master/misc/screenshot.png
04:27:36 <doubling> huehue
04:27:40 <Aruro> __uu___: so if we take expression (+) 1 2 and wrap it in a box of [(+)] [1] [2] we need new function application which is <*> , so valid expression will be [(+)] <*> [1] <*> [2]
04:27:45 <__uu___> liste: oh, I undertand what you meant!  There are cases you can find fmap between categories, where  'pure' or '<*>' does not exist!
04:27:55 <Aruro> __uu___: it is your desired fmap
04:28:35 <jophish> EvanR: who wrote that?
04:28:50 <EvanR> got me https://github.com/sdiehl/cats
04:28:50 <__uu___> Aruro: ok, I got what you mean!
04:28:51 <akfp> Darwin226: After you've applied a function you couldn't write it back into the data structure, so it would be a getter, and then you can anyways compose the functions using normal function composition.
04:29:16 <__uu___> the 2nd question, what does "Applicative" mean literally ?
04:30:02 <Darwin226> akfp: Well, in my case these prisms take case
04:30:05 <Darwin226> *care
04:30:11 <Darwin226> of maybe wrapping, unwrapping
04:30:43 <Darwin226> Ah... I know it's dumb and I can just do & fmap myFunction
04:31:02 <Darwin226> but this requires parentheses where I previously didn't need any because & binds so loosely
04:31:09 <Aruro> __uu___: check out also here : https://en.wikibooks.org/wiki/Haskell/Applicative_functors  , haskell has very good wikibook
04:31:32 <__uu___> Aruro: that is where I came from, actually..
04:31:39 <Aruro> __uu___: :)
04:32:35 <Aruro> __uu___: if you reall want to know what is what check out original paper: http://www.staff.city.ac.uk/~ross/papers/Applicative.html
04:33:10 <__uu___> Aruro: wow! thanks!
04:33:41 <__uu___> Aruro: in fact, I find myself better understanding it mathematically..
04:34:14 <__uu___> so, the paper fits me well!
04:37:16 <Aruro> __uu___: glad u like it :)
04:49:55 <MichaelBurge> Is there a function sort :: (Foldable s, Ord a) => s a -> s a?
04:50:16 <LordBrain> :t sort
04:50:17 <lambdabot> Ord a => [a] -> [a]
04:50:21 <LordBrain> hmm
04:50:31 <ggVGc> woke up
04:50:36 <ggVGc> time for some haskell
04:50:38 <ggVGc> 'erryday
04:50:45 <mniip> you can do it with some toList, sortBy, and fmap
04:51:14 <Hafydd> MichaelBurge: no, there isn't. How would you construct the result value?
04:51:38 <mniip> Hafydd, it's doable
04:51:46 <Hafydd> mniip: how?
04:52:07 <MichaelBurge> Hafydd: Maybe there's a way to sort a list, and use it as an index while doing a second passthrough of the same original foldable
04:52:39 <mniip> hmm
04:52:43 <mniip> we need indexed map
04:53:10 <Hafydd> MichaelBurge: you might be able to do that if you also include the constraint Traversable s.
04:53:12 <mniip> needs Traversable
04:56:34 <mniip> @let sortT t = snd $ mapAccumL (\(x:xs) _ -> (xs, x)) (sort $ Data.Foldable.toList t) t
04:56:35 <lambdabot>  Defined.
04:56:41 <mniip> > sortT [1,3,5,2,4]
04:56:43 <lambdabot>  [1,2,3,4,5]
04:59:35 <Boomerang> :t sortT
04:59:36 <lambdabot> (Ord b, Traversable t) => t b -> t b
04:59:51 <MichaelBurge> Thanks mniip - I might use that actually
05:08:26 <ggVGc> I've started, kind of without much thought, using a naming convention for maybes like `fooMaybe`, since I often do things like fooMaybe >>= (\foo -> ...)
05:08:30 <ggVGc> do others do that?
05:08:41 <ggVGc> or some other convention?
05:10:22 <magneticduck> ggVGc: it's probably fine as long as it isn't redundant
05:10:40 <magneticduck> i.e. you're not just re-encoding information that's already present in the type signature
05:11:02 <ggVGc> magneticduck: I motly do it to avoid name clashes
05:11:14 <ggVGc> magneticduck: because foo >>= (\foo -> ...) is very confusing to me
05:11:43 <magneticduck> yeah that's definitely considered bad practice
05:12:09 <magneticduck> in fact iirc a lot of linters will give you an error about shadowing symbols like that
05:12:16 <Darwin226> To answer my own question from before, to lift a function into a getter you use `to` from Control.Lens.Getter
05:12:41 <magneticduck> ggVGc: but sometimes it might be more natural to name it 'getFoo', perhaps
05:13:06 <magneticduck> the fact that the method 'gets' a foo could be more interesting than the fact that it returns a maybe
05:13:42 <magneticduck> hopefully, the way you perceive the code (through your editor or IDE) should attach type-level information to values, without having to re-encode that information into the value names themselves
05:14:07 <Boomerang> Or do everything pointfree so you don't have to come up with many names ^^ Might not end up very readable...
05:14:24 <magneticduck> pointfree is the way of the gods!
05:15:17 <magneticduck> but unless you, and everybody contributing, can actually hold the whole program in their head as a single structure, it's helpful to attribute names to way-points ;)
05:15:19 <ggVGc> hm, that's interesting
05:15:30 <ggVGc> thinking of a Maybe instance as a function that "gets" it's contents
05:16:15 <ggVGc> but it reads a bit weird to me to go, getFoo&maybe (someDefault) (\foo -> ...)
05:16:19 <ggVGc> what do you guys do?
05:16:34 <magneticduck> just don't include the 'Maybe' at all
05:16:54 <Boomerang> > let foo = (Just 5) in ((+ 2) <$> foo)
05:16:55 <lambdabot>  Just 7
05:17:23 <ggVGc> eh? but I find the `maybe` function very convenient
05:17:39 <magneticduck> pattern matching is a pretty cool language feature
05:17:43 <magneticduck> it's not just there for implementation
05:18:08 <magneticduck> uh, anyway, it might not quite work in your case
05:18:35 <magneticduck> again, what's the problem with getFoo thingy >>= \foo ->
05:18:58 <magneticduck> or fooFromThingy blahBlah >>= \foo ->
05:19:06 <ggVGc> magneticduck: so, this for example. How would you write it? https://gist.github.com/c7ed6932d7a98455abd639546121d160
05:19:08 <magneticduck> the 'xFromY' naming pattern is also worth considering
05:20:16 <ggVGc> disregard my extraneous accidental $
05:20:18 <LordBrain> hmm, using & makes things reminescent of oo languages
05:20:38 <LordBrain> i guess that's why you like it?
05:20:48 <ggVGc> LordBrain: no, I just like reading left to right
05:20:59 <ggVGc> LordBrain: I like to start with the thing being procesed
05:21:33 <magneticduck> ggVGc: why does the function take two arguments?
05:21:40 <ggVGc> LordBrain: otherwise I read it like "Start doing these operations...oh btw, this is the thing your working on"
05:22:22 <ggVGc> magneticduck: oh, my type signature is wrong because I just refactored it just now
05:22:25 <Boomerang> type signature only shows one
05:22:30 <Boomerang> oh
05:22:31 <ggVGc> sorry
05:23:26 <magneticduck> `m&noteToNum $ defaultNoteEntry` is the kind of thing that makes outsiders look at Haskell all funny ^^
05:23:52 <ggVGc> yeah, but the $ is accidentally there since the expression wasn't a let binding before
05:23:58 <ggVGc> and I forgot to remove it
05:24:05 <magneticduck> yeah
05:24:12 <magneticduck> oh, two stylistic things
05:24:18 <ggVGc> but what about the maybe naming?
05:24:21 <magneticduck> 1) where statements are cooler than let statements in this situation
05:24:29 <ggVGc> yeah, I usually use where
05:24:43 <c_wraith> ggVGc, did that video help at all? 
05:24:52 <magneticduck> yeah, I think groupMaybe is fine here
05:25:16 <ggVGc> c_wraith: haven't had a chance to watch it yet. will do later tonight :)
05:26:10 <magneticduck> btw, it might be interesting to consider the tradeoff between 'xToY' vs the 'yFromX' naming convention
05:26:41 <magneticduck> with 'from', functions compose better, and it can be easier to find them through code completion
05:26:53 <ggVGc> magneticduck: not sure what you're refering to?
05:27:06 <magneticduck> noteFromNum vs numToNote
05:27:12 <ggVGc> ah, right
05:27:21 <magneticduck> it's a small thing
05:27:23 <LordBrain> Hmm, this is maybe weird, but i'd go hungarian with maybe, and shorten it to mb, so mbGroup
05:27:31 <magneticduck> but you seem to be interested in small things today ^^
05:27:50 <ggVGc> yeah I didn't put much thought into that
05:28:15 <ggVGc> but yeah, from is probably nicer, cheers
05:28:15 <magneticduck> I generally write my modules with three sections: constructors, accessors, and mutators
05:28:52 <magneticduck> constructors and accessors generally have the '.*From.*' naming scheme
05:30:13 <magneticduck> s/generally/can/
05:30:29 <magneticduck> aaanyway, my opinion isn't worth a whole lot more than anybody else's
05:30:43 <magneticduck> what's important is to put thought into things
05:36:38 <Boomerang> When creating a custom data type, is it better practice to implement fromString and toString functions or to make that data type instance of Read and Show?
05:36:59 <ggVGc> how do I get a type constructor for a type synonum?
05:37:29 <ggVGc> like, I have this `type TrigEntryGroup = NonEmptyList TriggerEntry`, but I can't go `let foo = TrigEntryGroup ...`
05:40:06 <Boomerang> if you need a constructor I usually make it a newtype instead of a type: `newtype TrigEntryGroup = TrigEntryGroup { trigEntryGroup :: NonEmptyList TriggerEntry }`
05:41:41 <Hafydd> Boomerang: that depends on the purpose of the toString and fromString functions. If the purpose is to read or show Haskell or pseudo-Haskell representations of the values, then of course using Read and Show is more convenient. If it isn't, then there might well be an existing class (like IsString, or Data.Binary) for that purpose.
05:42:12 <Hafydd> It may be that you want to implement multiple such instances.
05:42:50 <lyxia> ggVGc: Type synonyms don't introduce constructors. They're just like let bindings at the type level.
05:42:51 <Boomerang> It is to serialize as a string for JSON
05:43:19 <lyxia> ggVGc: I.e. everywhere you have TrigEntryGroup you can substitute with NonEmptyList TriggerEntry
05:43:31 <Hafydd> Boomerang: do you mean to serialise as JSON, or to serialise as a string value encoded in JSON?
05:44:45 <lyxia> ggVGc: just define foo as a NonEmptyList
05:44:47 <Hafydd> Boomerang: unless that representation happens to be the same one that you'd like to see when e.g. printing the value in ghci, and arguably even if it is, you should have separate functions for that explicit purpose.
05:44:59 <Hafydd> (Then you can easily change one while leaving the other the same, if you need to.)
05:45:52 <Boomerang> String value encoded in JSON. But I also need to serialize as ByteStrings (network stuff) so I don't know if it's justified to have a different way of dealing with strings compared to dealing with ByteStrings (toString, fromString, toByteString, fromByteString vs read, show, encode, decode)
05:46:42 <Boomerang> I guess when printing to ghci doesn't matter much
05:46:52 <Hafydd> Boomerang: the issue of whether the bytestring representation differs from the string representation is orthogonal to the issue of whether to use the Read and Show classes.
05:47:23 <Boomerang> What do you mean by orthogonal? Separate issue? :)
05:47:36 <Hafydd> Boomerang: yes, I mean that it's separate, and neither one has any bearing on the other.
05:48:27 <Boomerang> So if you were a user of my future library and you had to deal with data X would it be more obvious to read/show or to do fromString/toString?
05:48:32 <Hafydd> Of course you might want to implement toByteString = encode . toString, but using Show will not make that any easier.
05:49:49 <Hafydd> Boomerang: it would be more obvious to look in the documentation and see what was available. I certainly wouldn't take the Read/Show instances and assume they were suitable for network encoding.
05:50:29 <Hafydd> Boomerang: and, for what it's worth, I might at first think that a function called "fromString" is an implementation of the member of IsString. It may be better to use a name that describes what kind of string it is.
05:50:34 <Boomerang> For example the package Data.IP supports string representation of ip addresses
05:51:50 <Boomerang> so a user either has to read literal IPs or use language extensions like OverloadedStrings to make it seemless
05:52:09 <Boomerang> So that's what you were saying with IsString
05:52:57 <Hafydd> Boomerang: what is that an example of?
05:53:56 <Boomerang> of using read/show rather then fromString/toString. But I guess in the end it doesn't matter as long as I'm consistent and document it well. Thanks for your help! :)
05:55:30 <Hafydd> Boomerang: that isn't the conclusion you should draw from this at all.
05:55:53 <jmarciano> tried to compile pandoc and failed.
05:56:04 <Hafydd> Boomerang: if Data.IP had special functions to encode and decode IP addresses from the network, for example, they would certainly be different from the Read/Show instances.
05:56:30 <MichaelBurge> I'm having a little trouble phrasing a merge-join algorithm in terms of traversable. I know how to do it imperatively(1. sort both inputs, 2. advance left until keys are unequal, 3. advance right until keys are unequal, 4. Goto 2 if both inputs have elements), and could probably make it work using something like Conduit or Pipes
05:56:33 <Hafydd> Boomerang: and it would be inappropriate to use one for the other purpose.
05:56:36 <MichaelBurge> I have a nested loop join here: http://lpaste.net/160124
05:57:33 <Boomerang> Yes, in my use case there are two different serialization. One a string in a JSON file, the other as a ByteString which just represents binary data
05:57:34 <jmarciano>  /join #guile
05:58:18 <Hafydd> Boomerang: and both of those are distinct from Read/Show, which is for a pseudo-Haskell representation shown to the user.
06:00:35 <Boomerang> That's why I brought up the example of the IP package. When printing an IP it doens't print "IPv4 127.0.0.1" instead it prints "\"127.0.0.1\""
06:00:53 <Boomerang> my use case is very similar to the IP package
06:02:07 <Boomerang> as long as read . show == id, it's fine to use Read/Show instances as string serialization or do you completely disagree?
06:02:41 <MichaelBurge> Boomerang: Not for serialization. They're more for debugging.
06:03:11 <Boomerang> I see
06:03:12 <Hafydd> Boomerang: I do disagree. It's only a coincidence that the Haskell representation of an IP address (as a string) looks the same as the JSON representation of an IP address (as a string). It would be inappropriate to Show to generate JSON.
06:04:58 <Boomerang> I didn't want to be confusing with the JSON, that's where I would use the String. show doesn't generate JSON
06:05:41 <MichaelBurge> Boomerange: I might've missed something, but you would use something like Data.Aeson for JSON serialization, which defines its own typeclasses and helpers for implementing them.
06:05:49 <Hafydd> Boomerang: but your suggestion is to use Read/Show "as string serialisation."
06:05:59 <LordBrain> i think read . show == id is fine
06:06:51 <LordBrain> it used to work well as string serialization, but htere is a bug in many of the read instances nowadays that noone bothered fixing as everyone uses parsers and such
06:07:31 <Hafydd> One of the problems with this is that if you later want to have different representations for debugging and for serialisation, you'd have to modify a whole lot of code.
06:07:31 <LordBrain> so you're kind of fighting the grain if you try to use it that way seriously
06:08:00 <Boomerang> The approach taken by the IP package from what I understand is to be able to parse an IP literal that wasn't written for Haskell. So you could use read when parsing a web page/JSON or other
06:08:11 <Hafydd> The other problem is that the user wouldn't expect "show" to generate a serialisation.
06:08:11 <Boomerang> (I am using Aeson for JSON parsing)
06:09:10 <Boomerang> LordBrain: That's the main reason why I asking here for best practice. I do see the benefits of clear debugging
06:09:22 <LordBrain> show is mostly for debug these days, and for showing the the user, you use pretty or something like that, for serialization, binary
06:10:02 <MichaelBurge> Boomerang: I would use one of the parsing libraries, which you can usually get a "String -> Maybe a" or "String -> Either ErrorMessage a" out of at the end.
06:10:16 <LordBrain> for parsing, typically one of hte various parse packages...
06:10:17 <sebbenbear> hey - there's one bug that I still can't quite figure out. I'm adding numbers from a file, and have the error "Couldn't match IO with Char. Expected type Filepath -> Char. Actual type FilePath -> IO Integer." even though my definition is " :: IO ()"
06:10:57 <sebbenbear> http://pastebin.com/AVe2ZGwA
06:11:14 <LordBrain> probably need a return
06:11:20 <LordBrain> without looking at your code...
06:11:21 <sebbenbear> I don't quite understand why there's a type problem here
06:11:36 <Boomerang> MichaelBurge: I am using ReadP as a parsing library, it doesn't have much but has the advantage of being in the base package
06:12:03 <sebbenbear> I have a return in there
06:12:10 <sebbenbear> Is it not in the right place?
06:12:12 <LordBrain> getTotal is an io function
06:12:32 <LordBrain> you need to use fmap to apply to its result, and mapM to map it over the list
06:13:04 <LordBrain> writeFile f2 <$> mapM getTotal f1
06:13:31 <LordBrain> import Control.Applicative to get the <$> operator
06:13:39 <sebbenbear> mapM? Ok, I'll have a google, haven't seen <$> before
06:13:40 <LordBrain> that's just infix fmap
06:13:50 <sebbenbear> oh right
06:14:20 <LordBrain> :t mapM
06:14:21 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:14:25 <LordBrain> :t map
06:14:26 <lambdabot> (a -> b) -> [a] -> [b]
06:14:36 <Gurkenglas_> writeFile itself produces IO though, you'll want =<< instead of fmap
06:14:41 <LordBrain> well, substitute t for [] to simplify and you get the point
06:14:55 <LordBrain> oh
06:14:58 <LordBrain> good point
06:15:12 <LordBrain> writeFile f2 =<< mapM getTotal f1
06:15:35 <Gurkenglas_> Also getTotal gives you an Integer, so mapM will get you a list of Integers, but writeFile expects a String, so you need to convert that first
06:15:48 <Gurkenglas_> Perhaps with show and unlines
06:16:27 <Gurkenglas_> :t writeFile ?f2 =<< mapM ?getTotal ?f1
06:16:28 <lambdabot> (?f1::[a], ?f2::FilePath, ?getTotal::a -> IO Char) => IO ()
06:16:40 <Gurkenglas_> :t writeFile ?f2 . unlines . map show =<< mapM ?getTotal ?f1
06:16:41 <lambdabot> (Show a, ?f1::[a1], ?f2::FilePath, ?getTotal::a1 -> IO a) => IO ()
06:16:44 <LordBrain> hey probably doesnt even want a map there at all
06:17:28 <sebbenbear> "writeFile f2 =<< mapM getTotal f1" says there's no instance for (Num Char)
06:17:30 <Gurkenglas_> Ah yes, getTotal is supposed to be called only once on the whole file path provided in f1
06:17:39 <LordBrain> yeah
06:18:18 <Gurkenglas_> :t writeFile ?f2 . show =<< ?getTotal ?f1
06:18:19 <lambdabot> (Show a, ?f1::t, ?f2::FilePath, ?getTotal::t -> IO a) => IO ()
06:18:19 <LordBrain> sebbenbear, you don't want map or mapM at all
06:18:35 <sebbenbear> Yeah, this function should just get an [Int] out of it, sum them and pop that value into the file
06:18:45 <sebbenbear> oh really?
06:18:48 <sebbenbear> how come?
06:18:49 <LordBrain> you just want getTotal f1 >>= print
06:19:07 <Gurkenglas_> Well, print would be to stdout, not f2
06:19:32 <LordBrain> yeah... i'm too fast and lose
06:19:38 <Gurkenglas_> *loose
06:19:44 <LordBrain> o
06:19:54 <Gurkenglas_> I recommend you put all the IO into the sumFile definition, especially as you'll probably only be using this version for this assignment
06:20:02 <LordBrain> my fingers implement OoO execution
06:20:35 <Gurkenglas_> Oh and on line 3 I would match an exact number of arguments, but you may have an ulterior motive?
06:21:22 <Boomerang>  writeFile f2 =<< (show . sum . map read . lines) <$> readFile f1
06:21:43 <sebbenbear> Still learning, trying to piece everything together :) But that's really good advice, thank you!
06:21:55 <Gurkenglas_> You don't need the fmap with a little reshuffling:
06:22:12 <Gurkenglas_>  writeFile f2 . show . sum . map read . lines =<< readFile f1
06:23:45 <Gurkenglas_> There is little code that is used only in one place and deserves its own name
06:24:36 <LordBrain> eh subjective
06:25:34 <Gurkenglas_> (And most of it is used to tame the beast of recursion and place it behind a sane interface - and then it all probability someone else already did it and built a library around it)
06:25:42 <Gurkenglas_> *in all probability
06:27:05 <LordBrain> it depends on the surrounding program actually, tho its better if it is scoped locally in a where clause if you do that.  if you're making a command line tool then use do notation and pattern match on the args... do { args <- getArgs; case args of [infile,outfile] -> readFile infile >>= writeFile outFile . show . sum . map read . line }
06:28:04 <sebbenbear> Hm, those suggestions still didn't quite work, there's still a type error there
06:28:06 <LordBrain> you can add a default pattern _ -> putStr "I don't understand those arguments!" >> usage
06:28:30 <LordBrain> of course you ahve to define usage
06:29:25 <Gurkenglas_> sebbenbear, paste the new code to lpaste.net, and best include the entire ghci error although its probably not necessary this time
06:31:21 <LordBrain> if you match exact number of arguments the way Gurkenglas_ suggests youll get an exception if the user gives you anything that doesnt match, and if you decide you want to handle different kinds of errors you ahve to rewrite, but if you jsut slurp up args into one variable and pattern match on it, adding new kinds of inputs to the tool just means adding another line in the case statement.
06:32:10 <LordBrain> although, if your tool gets fancy enough, you'll probalby want to do some kind of parsing of options and so forth..
06:32:41 <sebbenbear> http://pastebin.com/2dV6hBQY
06:33:02 <sebbenbear>  Couldn't match expected type ‘[Char] -> [Char] -> t’
06:33:02 <sebbenbear>                 with actual type ‘IO ()’
06:33:02 <sebbenbear>     Relevant bindings include it :: t (bound at <interactive>:2:1)
06:33:04 <sebbenbear>     The function ‘sumFile’ is applied to two arguments,
06:33:06 <sebbenbear>     but its type ‘IO ()’ has none
06:33:08 <sebbenbear>     In the expression: sumFile "../numbers.txt" "../numbers_output.txt"
06:33:10 <sebbenbear>     In an equation for ‘it’:
06:33:12 <sebbenbear>         it = sumFile "../numbers.txt" "../numbers_output.txt"
06:33:16 <sebbenbear> ... probably should have included that in the paste
06:33:35 <sebbenbear> I think it's to do with the pattern matching of the arguments
06:33:47 <sebbenbear> but leaving it out creates a new error
06:33:52 <LordBrain> ooooh
06:34:12 <sebbenbear> where it can't match a [char] with char
06:34:15 <LordBrain> yo have getArgs in sumfile, but are calling it inside the interpretter
06:34:25 <LordBrain> you'll have to set hte program arguments to do that
06:35:38 <LordBrain> use :set args "../numbers.txt" "../numbers_output.txt"
06:35:42 <Gurkenglas_> LordBrain, one could do "args >>= \case" using LambdaCase to have less naming, and if one wants to make a big tool out of it there's libraries like turtle
06:35:45 <LordBrain> then call sumFile with nothing...
06:36:29 <sebbenbear> I'm using ghci, and passing them in as args when I'm calling the function - it worked for a different function that I had written, so I wasn't sure that was the case
06:36:36 <LordBrain> no no
06:36:39 <LordBrain> there is a difference
06:36:50 <Gurkenglas_> sebbenbear, was the one that worked called main?
06:36:54 <LordBrain> the arguments to the function are not what getArgs is for giving you, it gives you the command line arguments
06:37:08 <sebbenbear> yeah, it totally was >.>
06:37:16 <sebbenbear> hm
06:37:44 <LordBrain> if you typed the arguments on the command line when you called ghci then you don't need to type them again when you call sumFile
06:37:51 <LordBrain> however
06:38:10 <LordBrain> you're actually probably better off refactoring sumfile so it actually does take f1 and f2 as parameters
06:38:48 <LordBrain> you see the difference?
06:38:55 <magneticduck> hmm, what would be a good way to exercise some guarantee, say, that a certain newtype wrapping an Int is within a certain range?
06:39:03 <sebbenbear> I was keen to do that, that makes more sense to me
06:39:23 <Boomerang> instead of using ghci you could use runhaskell to pass whatever arguments every time
06:39:23 <sebbenbear> but we were given the type definition ":: IO ()"
06:39:38 <sebbenbear> so I assumed it had to get it inside the function
06:39:48 <magneticduck> if I'm constructing these values from external input, I can use a constructor returning Maybe
06:40:00 <magneticduck> makeValue x = if (x in range) then Just x else Nothing
06:40:21 <magneticduck> but if I want to construct these values in my own program, it's dumb to exercise runtime guarantees about them
06:40:34 <magneticduck> I need a compile-time check
06:40:46 <magneticduck> s/program/code
06:40:49 <LordBrain> then you need Nat
06:40:52 <LordBrain> heh
06:40:57 <LordBrain> and type level hackery
06:40:58 <Gurkenglas_> Your options are QuickCheck, I think TH and Dependent Types
06:41:16 <magneticduck> well I'll be using QuickCheck too
06:41:18 <Gurkenglas_> ("I think" applying only to "TH")
06:41:20 <magneticduck> but .. ick
06:41:27 <magneticduck> this should have a natural solution
06:41:34 <LordBrain> whatever happened to liquid haskell?
06:41:36 <magneticduck> Dependent types are nice, how's the support for them in haskell?
06:41:42 <magneticduck> and also TH, I'd like to learn more about TH
06:43:11 <LordBrain> does Liquid Haskell work as a preprocessor?
06:43:50 <l4m8d4> Hello, I have a noob question... so our lecture on haskell just started and we know only the basics of lists, list-comprehensions, the basic operators, but for example nothing about function declarations... So an exercise sheet we are given asks us to make a simple function that compares 3 integers for equality and returns a bool. The function header was given as ’alleGleich :: Eq a => a -> a -> a ->
06:43:51 <l4m8d4> Bool’. My function implementation is 'alleGleich a b c = ((compare a b) == EQ) && ((compare b c) == EQ)'. But ghci won't accept it like that, I think I did something wrong here - can someone explain to me what's the mistake?
06:44:50 <Gurkenglas_> l4m8d4, paste your code to lpaste.net pls
06:44:52 <l4m8d4> If I append 'let' before my implementation and run it in ghci, it works, but it doesn't seem to match the given function header
06:44:58 <pyrtsa> l4m8d4: `compare` requires `Ord`.
06:45:05 <magneticduck> LordBrain: I could also just 'let value = makeValue literal' and let Haskell's purity make the performance overhead of checking the invariant a non-issue
06:45:16 <mnoonan> ghci won't give you polymorphic types, it has to pick one concrete type
06:45:40 <pyrtsa> l4m8d4: If you want to constrain on `Eq a` (like you should), you should use `==` as the comparison.
06:45:42 <magneticduck> or I could just use errors https://wiki.haskell.org/Smart_constructors
06:46:22 <mnoonan> (wait, ignore what I said.. not totally awake yet)
06:46:51 <LordBrain> ghc actually leaves a lot of optimizations not done for the sake of provably terminating type-check... 
06:48:46 <Gurkenglas_> Can you tell it to try some experimental nonhalting optimizations, or were they just not implemented for that reason?
06:49:03 <Boomerang> > let alleGleich a b c = a == b && b == c
06:49:03 <l4m8d4> Here is my code on lpaste.net: http://lpaste.net/160126
06:49:04 <LordBrain> i think there is a switch, but i don't recall it
06:49:04 <lambdabot>  <no location info>:
06:49:04 <lambdabot>      not an expression: ‘let alleGleich a b c = a == b && b == c’
06:49:16 <Boomerang> @let alleGleich a b c = a == b && b == c
06:49:17 <lambdabot>  Defined.
06:49:28 <Boomerang> :t alleGleich
06:49:29 <lambdabot> Eq a => a -> a -> a -> Bool
06:49:38 <Gurkenglas_> Yep, after I told to paste the others answered correctly and I should have realized.
06:50:12 <Gurkenglas_> l4m8d4, tu vienna? Or what university in Germany is doing Haskell?
06:51:49 <l4m8d4> Okay, if I don't use the (overcomplicated) compare solution and compare directly it works - I still don't understand why, though
06:52:11 <Boomerang> l4m8d4: you shouldn't use `compare` but `==` as pyrtsa said
06:52:12 <magneticduck> @type compare -- l4m8d4 
06:52:13 <lambdabot> Ord a => a -> a -> Ordering
06:52:17 <Boomerang> :t (==)
06:52:18 <lambdabot> Eq a => a -> a -> Bool
06:52:21 <magneticduck> is your type Ord ?
06:52:32 <l4m8d4> Gurkenglas_: lmu munich does
06:52:34 <pyrtsa> l4m8d4: Because you specified the function to be constrained on anything that's `Eq a`. But that doesn't guarantee `compare` can be called on it.
06:53:26 <l4m8d4> pyrtsa: The problem is that I didn't specify the function header, it was given to us because we don't know yet how to dfine the header
06:53:49 <l4m8d4> But thanks for the explanation
06:53:56 <LordBrain> it is possible to write expressions that only involve computations with known compile time constants as inputs and ghc will not compute it compile time
06:54:57 <LordBrain> because someone wanted to be sure ghc would finish compiling... so in order for it to compute an arbitrary expression involving constants, it would have to prove termination, solve the halting problem...
06:55:24 <LordBrain> its quite easy therefore to end up with constant expressions that are needlessly computed at run time
06:55:27 <magneticduck> > undefined = undefined
06:55:28 <lambdabot>  <hint>:1:11: parse error on input ‘=’
06:55:41 <magneticduck> uh, anyway, yeah
06:56:09 <pyrtsa> l4m8d4: I'm not sure I follow. If there's a line somewhere in code that states `alleGleich :: Eq a => a -> a -> a -> Bool`, then GHC expects that to be its type.
06:56:45 <pyrtsa> If you omit that type signature, then `alleGleich a b c = ((compare a b) == EQ) && ((compare b c) == EQ)` works just right, and gets the inferred type `Ord a => ...`.
06:57:19 <Boomerang> But if it's an exercise you have to implement it with `Eq a => ...`
06:57:36 <pyrtsa> I'd guess it is. :)
06:57:50 <rydgel_> if you use compare, then a need the constraint of Eq
06:58:18 <LordBrain> of Ord
06:58:39 <magneticduck> btw, read 'allEqual :: Eq a => a -> a ...' as: 'for every a, if 'a' is Eq, then allEqual can have type a -> a ...
06:58:58 <LordBrain> foldr (==) [a,b,c]
06:59:07 <LordBrain> heh
06:59:22 <magneticduck> > (1 :: (Eq a) => a) -- this fails, because '1' can't have type 'a' for every Eq member
06:59:23 <lambdabot>      Could not deduce (Num a1) arising from the literal ‘1’
06:59:24 <lambdabot>      from the context (Eq a)
06:59:24 <lambdabot>        bound by the inferred type of it :: Eq a => a at <interactive>:1:1
06:59:36 <magneticduck> oh oops, he went
06:59:44 <magneticduck>  / she
06:59:52 <Boomerang> > alleGleich 3 3 3
06:59:54 <lambdabot>  True
06:59:56 <Boomerang> > alleGleich 3 3 4
06:59:58 <lambdabot>  False
07:00:00 <l4m8d4> I'm still here
07:00:12 * magneticduck glares at weechat nickname completion
07:02:45 <l4m8d4> Okay, I think I kinda get now why there is this problem... I guess nobody thought that someone would use "compare" instead of "==", because I couldn't have guessed that with what I already know from the lecture I think, because it didn't involve any function headers as far as I can remember :D
07:03:16 <LordBrain> we call them type signatures
07:03:40 <LordBrain> the function itself has a type, just like a value, because it is a value
07:05:41 <l4m8d4> LordBrain: Thanks. Thanks to all that helped. As I was expecting it was very obvious for someone that knows haskell anyway, so I hope it didn't waste too much of your time :D
07:40:10 <jophish> How on earth did edwardk come up with the names in here: https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#v:Fix
07:40:33 <jophish> oh, futumorphism is actually a thing
07:41:37 <jophish> lost it at "Zygohistomorphic prepromorphisms"
07:41:59 <Akii> rofl
07:42:07 <Akii> that's the best part about learning FP
07:42:09 <Akii> all those words
07:42:30 <jophish> neither of the maths phds in the office had heard of a futumorphism
07:42:36 <michaelt> jophish: that one was a pre-existing joke which he of course couldn't resist making real
07:42:45 <jophish> ah, gotcha
07:45:38 <michaelt> jophish: I take it you've seen http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf this has a number of xyzmorphisms, I guess it's 'locus classicus'. 
07:46:07 <jophish> ah, thanks for the link michaelt 
07:46:16 <hpc> qwertymorphism: the transformation from random letters to math
07:48:03 <Akii> lol hpc
07:48:11 <Akii> also thanks for that paper!
08:00:48 <acertain> is there any way to return a GADT constructor that doesn't vary between branches but it type does before doing pattern-matching to determine it's type?
08:01:24 <shachaf> I'm not managing to parse that question.
08:03:33 <nomeata> me neither. acertain, try again! :-)
08:05:32 <lpaste> acertain pasted “No title” at http://lpaste.net/160128
08:06:34 <acertain> does that make sense?
08:07:20 <monochrom> fmap f ~(Fmap g x) = Fmap (f . g) x
08:07:22 <acertain> i'm building an infinite self-recursive GADT
08:07:44 <acertain> monochrom, An existential or GADT data constructor cannot be used inside a lazy (~) pattern
08:09:27 <Aruro> acertain: can u show more of your GADT type?
08:11:03 <lpaste> acertain pasted “the GADT” at http://lpaste.net/160129
08:14:03 <Digit> hi. question(s) of package break warning from cabal install:, http://dpaste.com/1T027VS safe to use --force-reinstalls, how likely is "likely"? how important are those, do i need them, how can i check what uses them???       can i some other way avert disaster and still have my cake (funbot)?     
08:15:38 <doubling> please don't discuss package breaks they are a sign of mutation
08:15:43 <doubling> and thus one of my triggers
08:18:07 <MarcelineVQ> that might be a confusing joke for a new person
08:18:19 <byorgey> Digit: best solution is probably to build in a sandbox instead
08:18:40 <byorgey> Digit: cabal sandbox init  and then cabal install etc. as usual
08:19:55 <lpaste> byorgey annotated “No title” with “produce Fmap constructor first” at http://lpaste.net/160128#a160130
08:20:56 <byorgey> acertain: ^^^ there's my solution to your original problem.
08:21:21 <byorgey> though thinking about it again, I am not sure whether it actually solves your problem.
08:22:22 <Aruro> acertain: can u simluate lazy patterns?
08:23:24 <monochrom> Digit: "ghc-pkg dot" gives the whole dependency graph in graphviz notation.
08:31:06 <acertain> fmap f x = Fmap a b where (a,b) = case x of {Fmap g y -> unsafeCoerce (f . g , y); _ -> (f, x)}
08:31:17 <acertain> this works, but unsafeCoerce
08:35:44 <maerwald> wow, doctest is crazy :D
08:37:07 <Akii> nice
08:38:23 <mrvdb> good afternoon everyone, I'm (ab)using Hakyll to learn haskell and trying to write a function that counts posts, I've gotten this far: https://gist.github.com/mrvdb/613f6f66a4f3757dfe4daef61b899902 but running into circles now. Can anyone give me a nudge in the right direction?
08:39:54 <dmj`> mrvdb: can you show the post type
08:40:03 <dmj`> and define what constitutes as a post
08:40:13 <adamvh> i have a question about cabal - if i want to patch a library hosted on hackage, how do i do that?
08:40:27 <adamvh> as in just patch it locally to see if it helps me
08:40:36 <adamvh> and then perhaps escalate to github or what have you
08:40:47 <hpc> download the gzip at the bottom which contains the source
08:40:50 <dmj`> adamvh: you could 'cabal get <package>' then edit it
08:40:56 <Boomerang> mrvdb: you probably need to change the type signature of postCount. It will probably return `m Int`
08:40:57 <hpc> or right, cabal get
08:41:11 <adamvh> so if i then run cabal install inside that directory
08:41:16 <hpc> you can then run 'cabal install' within that folder to install that local copy, or just 'cabal build'
08:41:27 <adamvh> and then my local copy will be the patched one
08:41:35 <hpc> right
08:41:36 <adamvh> but it will have the same version number etc as the original?
08:41:41 <hpc> if you don't change it, yes
08:41:49 <adamvh> cheers
08:42:40 <adamvh> my repa code is not type-checking and i am beginning to suspect that it is because of an unnecessary Num constraint
08:42:51 <adamvh> deep in the bowels
08:42:56 <adamvh> but i wanna check
08:44:35 <__jim__> by any chance is anyone familiar with servant-js? 
08:44:37 <jophish> @seen koninkje
08:44:38 <lambdabot> x0niNkJe
08:44:44 <LordBrain> admvh; cabal unpack yourpackagename
08:44:56 <LordBrain> you don't have to download it separately
08:45:15 <LordBrain> when you go to link against it, you can use a sandbox and add-source the folder to the patched version
08:45:24 <lpaste> Boomerang pasted “mrvdb postCount” at http://lpaste.net/160136
08:45:24 <mrvdb> dmj`: i've updated the gist with the value of the pattern, not sure what else to include, what's missing?
08:45:28 <adamvh> thanks
08:45:55 <LordBrain> you can specify the version too, with the usual hyphen notation
08:46:53 <__jim__> I'm trying to generate an angular example using servant-js but it seems to fail on octetstream endpoints
08:47:28 <__jim__> :<|> "a" :> "b" :> BasicAuth "login" UserId :> Get '[OctetStream] TokenStream
08:48:59 <lpaste> “__jim__” pasted “servant-js error” at http://lpaste.net/160137
08:49:53 <__jim__> I see that its an instance issue, but I'm not sure what the intended way to generate this might be
08:50:05 <ntnt> besides TH, is there a way to *programatically* (without typing it out as source code) define new data types?
08:50:39 <LordBrain> types generally don't even exist at runtime
08:51:16 <LordBrain> although you can get around that of course with various tricks
08:51:54 <ntnt> how does Data.Data and Data.Typeable work then?
08:52:06 <ntnt> they way they work seems to imply that *some blob of info* is available at runtime
08:52:07 <LordBrain> having types depend on values would of course be dependently typed... you can get pretty close nowadays tho it isnt pretty
08:52:20 <adamvh> oh damn i was right
08:52:31 <adamvh> (maybe)
08:52:48 <adamvh> change one type constraint in the bowels of repa
08:52:55 <adamvh> and my code type checks and compiles
08:53:04 <adamvh> hmmm
08:53:31 <mrvdb> Boomerang: thanks for the paste, I think I'm still missing something conceptual here; not sure how to use that snippet.
08:53:59 <LordBrain> typeOf x doesn't actually look at its argument ntnt
08:54:13 <adamvh> and runs without incident
08:54:23 <LordBrain> :t typeOf
08:54:24 <lambdabot> Typeable a => a -> TypeRep
08:55:44 <adamvh> boom! that was satisfying
08:56:03 <roelof> Hello,any news on the haskell book, is it right it's still at 0.10.2 ? 
08:56:13 <LordBrain> that doesnt imply runtime info in general, it just means putting the appropriate TypeRep value corresponding to the compile time inferred type for its argument
08:57:18 <LordBrain> you can get run type type tho, using an "envelope"
08:57:20 <Boomerang> mrvdb: I don't know exactly where or how you call your function, but to be able to have a `do` statement you need to have a return type "m Int" like the function getMatches (I removed the `do` statement to make it a one liner and `<$>` is the infix version of fmap)
08:58:01 <LordBrain> the Data.Dynamic trick does this
08:58:18 <LordBrain> look at its definition
09:11:21 <ntnt_> with DMap, is it possible, at compile time, to know whether a given elem belongs in a DMap ?
09:13:04 <roelof> no one who has also works with the Haskell book written by bitemyapp 
09:43:13 <ntnt> is there a way, in haskell/cabal to say: when file blah.foo changes, run "fooToHs blah.foo" to get "blah.hs" ?
09:43:34 <ntnt> basically I want GHC to run my own custom pre processor
09:44:03 <Boomerang> you could use make and call cabal from make
09:44:20 <ntnt> I want this to also happen during a "ghci :r reload"
10:04:57 <maerwald> ntnt: you probably do that in Setup.hs
10:19:13 <bernalex> I have two strings. I want to make a random list of 64 occurences, weighted so that there are 8 of string x, and 56 of string y. anyone have a good idea on what the easiest way to do this would be?
10:22:13 <bernalex> I guess I could have a data A = B | C deriving (Random), and make it using that or something.
10:22:57 <bernalex> oh. you can't derive Random.
10:25:05 <bernalex> meh I'll just use a random number and find a sufficiently low % chance for the x string to happen. should be fine. what could go wrong.
10:25:35 <Boomerang> @let randomString str1 str2 = (\x -> if x < 9 then str1 else str2) <$> randomRIO (1, 64)
10:25:37 <lambdabot>  .L.hs:163:18:
10:25:37 <lambdabot>      No instance for (Ord a0) arising from a use of ‘<’
10:25:37 <lambdabot>      The type variable ‘a0’ is ambiguous
10:26:36 <bernalex> Boomerang: that's basically what I'm going to do for now, yeah
10:27:03 <Boomerang> It's probably good enough :)
10:27:12 <bernalex> yeah it's not super important anyway
10:27:24 <Boomerang> If you need more randomness outside maybe don't use the IO version of random
10:28:02 <Boomerang> @let randomString str1 str2 = (\x -> if x < 9 then str1 else str2) <$> randomRIO (1, 64 :: Int)
10:28:04 <lambdabot>  Defined.
10:28:14 <Boomerang> > randomString "hello" "world"
10:28:16 <lambdabot>  <IO [Char]>
10:34:32 <maerwald> you can't re-export just a single function from another module?
10:34:48 <marchelzo> @pl \s -> if null s then s else f s
10:34:49 <lambdabot> ap (if' =<< null) f
10:36:22 <geekosaur> maerwald, just export it?
10:36:28 <maerwald> ?
10:37:30 <geekosaur> afaik you can just reexport individual names. or is it unhappy if you imported it qualified and then try to put the qualified name in the export list, or something?
10:37:47 <bernalex> uh my brain is tired and my stomach's hungry
10:38:17 <bernalex> howto f a -> f (f a) -> f a?
10:38:34 <hpc> \_ -> join
10:38:43 <maerwald> geekosaur: I don't really know what you mean. If I do "module MainModule(module Foo(function)) where"  then I get parse exception
10:38:49 <Boomerang> @hoogle f a -> f (f a) -> f a
10:38:52 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
10:38:52 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
10:38:52 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
10:38:54 <bernalex> hpc: I mean like adding a Maybe Int to a Maybe (Maybe Int)
10:39:08 <akegalj> can I somehow pattern match in Haskell over data type (instead of over data type constructor)? Lats say I have `data MyError = A | B | C` and there is an instance `instance Exception MyError`. Can I somehow say: `myError (a :: MyError) = doSomethingWithMyError \n myError a = doSomethingWithAnyError`. Would something like this work?
10:39:08 <geekosaur> no, the module syntax there is for whole modules
10:39:11 <hpc> ah, fmap return, perhaps
10:39:12 <bernalex> hpc: uhm no I don't
10:39:12 <geekosaur> just export function
10:39:21 <hpc> heh
10:39:26 <bernalex> hpc: I'm more tired than I thought
10:39:26 <geekosaur> don't even mention the module
10:39:34 <geekosaur> (in the export list)
10:39:35 <hpc> bernalex: have you tried turning it off and on again?
10:39:57 <bernalex> hpc: here's an example: Maybe String and Maybe [String], result should be Maybe [String] not Maybe [Maybe String] or whatever.
10:40:03 <bernalex> hpc: I'm about to in 20 mins or so
10:40:32 <bernalex> basically mappending things. Maybe String/Maybe [String], or IO Int/IO [Int], etc.
10:41:00 <maerwald> geekosaur: didn't know I can reference qualified functions that are imported later
10:41:05 <geekosaur> sure
10:41:20 <EvanR> "recursive everything"
10:41:28 <hpc> bernalex: solve for whatever a -> f a -> f a would do, then liftM2 it or something
10:41:34 <bernalex> I guess
10:41:41 <bernalex> or just get rid of one of the functors
10:41:42 <lpaste> geekosaur pasted “qualified re-export” at http://lpaste.net/160139
10:41:51 * hpc is distracted and having trouble parsing the explanation ;)
10:43:21 <Boomerang> @let f = liftM2 (:) -- bernalex 
10:43:22 <lambdabot>  Defined.
10:43:34 <Boomerang> > f (Just 1) (Just [2,3,4])
10:43:35 <hpc> :t f
10:43:36 <lambdabot>      Ambiguous occurrence ‘f’
10:43:36 <lambdabot>      It could refer to either ‘L.f’,
10:43:36 <lambdabot>                               defined at /tmp/mueval1850952926437116466.hs:158:1
10:43:36 <lambdabot>     Ambiguous occurrence ‘f’
10:43:36 <lambdabot>     It could refer to either ‘L.f’,
10:43:38 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:158:1
10:43:40 <hpc> :t L.f
10:43:42 <lambdabot> Monad m => m a -> m [a] -> m [a]
10:43:46 <hpc> lol
10:43:51 <Boomerang> hehe :p
10:43:58 <Boomerang> works in ghci
10:44:08 <mauke> @undefine
10:44:08 <lambdabot> Undefined.
10:46:09 <geekosaur> maerwald, if you think about it, it also hasn't seen the module import at the time it sees `module Foo` in the export list...
10:47:08 <geekosaur> and it's got to keep track of not yet defined names anyway; tracking a qualified name isn't much extra
10:47:36 <geekosaur> in fact it's probably one of the simpler such cases :)
10:53:45 <l4m8d4> hey, I'm back with another question: So another exercise we should do was to make a function that takes a list and outputs the length of the list. The question I have now is, how does the type signature of such a function look like?
10:54:42 <hpc> functions have a type (a -> b) for some 'a' and 'b'
10:54:43 <Boomerang> length :: [a] -> Int
10:54:53 <hpc> or just spoil the whole exercise :P
10:56:09 <Boomerang> hpc from what I understood the type signature wans't the exercise
10:56:27 <Boomerang> I'm guessing l4m8d4 has to impolement length
10:56:33 <l4m8d4> Boomerang, hpc: The type signature wasn't the exercise, correct.
10:56:34 <Boomerang> or I missunderstood and I'm sorry
10:56:42 <hpc> heh, fair enough then
10:56:48 <Boomerang> :)
10:57:07 <l4m8d4> We basically don't even know how to do type signatures, I just wanted to put the function into a file and be able to load them
10:57:24 <l4m8d4> But it is nice to know that you can use these "type variables"
10:57:55 <Boomerang> If I recall there was a "type variable" in your earlier question too :)
10:57:55 <l4m8d4> Boomerang, hpc : Thanks
10:57:58 <hpc> l4m8d4: you can start by writing "f _ = undefined" as a totally invalid placeholder definition
10:58:05 <hpc> l4m8d4: and then use ":t f" in ghci to view its type
10:58:27 <hpc> l4m8d4: use ":r" to reload the file as you edit and repeat until the type and definition are satisfactory
10:58:35 <hpc> then you can paste the type signature from ghci into the file
10:59:05 <l4m8d4> Boomerang: Was there? Could be, but I guess I wasn't even aware at that point what the type signature meant exactly :D
10:59:10 <hpc> :t let f _ = undefined in f
10:59:11 <lambdabot> t -> t1
10:59:58 <l4m8d4> hpc: That's nice to know, thanks!
11:03:32 <saurabhnanda> is it possible to define "local code snippets" using `where` -- example: http://lpaste.net/160140 Motivation: Two branches of my case statement need to perform very similar stuff. I don't want to repeat my code. Also, I don't want to define a top-level function to which I will have to pass all the local state -- invoking the function will almost be as much work as copy-pasting the code.
11:05:17 <Zemyla> Why is Either not an instance of Bounded?
11:05:21 <bernalex> oh come on brain
11:05:32 <bernalex> how do you ++ a bunch of 'f a's?
11:05:44 <Zemyla> instance (Bounded a, Bounded b) => Bounded (Either a b) where { minBound = Left minBound; maxBound = Right maxBound }
11:05:46 <bernalex> oh wait
11:05:58 <bernalex> they are 'f a's not '[f a]'s. sigh. gg brain.
11:15:55 <saurabhnanda> any help, anyone?
11:16:20 <maerwald> mh, how do you test file operations reliably?
11:17:06 <monochrom> saurabhnanda: have you described what you need help with?
11:17:17 <monochrom> ah, you have
11:18:09 <saurabhnanda> is it possible to define "local code snippets" using `where` -- example: http://lpaste.net/160140 Motivation: Two branches of my case statement need to perform very similar stuff. I don't want to repeat my code. Also, I don't want to define a top-level function to which I will have to pass all the local state -- invoking the function will almost be as much work as copy-pasting the code.
11:18:15 <Boomerang> saurabhnanda: yes, you can write functions in the where clause that use some of the varibles defines outside
11:18:47 <Boomerang> *variables defined outside
11:18:54 <saurabhnanda> Boomerang: that code isn't working. I've tried putting the where clause and the function definitions at every possible level of indentation, but some variable or the other is not accessible.
11:19:54 <monochrom> saurabhnanda: indentation matters. you need this "where" to be one level outside "case nwCmd". In fact, it should belong to "Just userE ->".
11:19:57 <Boomerang> Ah yes I see now, to be able to use `userE`
11:20:35 <dwynwen_ddlleyw> Is Haskell dependent on whitespace 
11:20:51 <monochrom> it can. most people make it so.
11:21:23 <saurabhnanda> monochrom: Boomerang: now it can't find even more variables -- msg, userE, nwCmd
11:21:38 <monochrom> I see, you want to use nwCmd.
11:21:45 <monochrom> use a "let" rather than "where"
11:22:30 <saurabhnanda> so, what's the difference in let & where, in this particular case. Why isn't 'where' working?
11:22:42 <saurabhnanda> and can I define 'let' at the bottom of the code?
11:22:43 <monochrom> in fact, use a single "let" for both "nwCmd = ..." and "logTgram = ..." and "writeToChan = ..."
11:22:55 <saurabhnanda> yup, 'let' worked
11:23:12 <saurabhnanda> monochrom: how do I use a single 'let'?
11:23:41 <Boomerang> a `let` block like a `where` block
11:24:03 <Boomerang> (indentation matters)
11:24:04 <lpaste> monochrom annotated “how to reduce code duplication?” with “how to reduce code duplication? (annotation)” at http://lpaste.net/160140#a160141
11:24:15 <monochrom> like that
11:24:52 <saurabhnanda> monochrom: hmm. thanks. That works. But would still like to understand why 'where' didn't work?
11:24:54 <shachaf> i,i x = 5 `let` x + x
11:25:22 <monochrom> "let" (under do) is sibling of other commands in the same do-block.
11:25:24 <Boomerang> depending on the indetation `where` was only applied to the last statement`
11:25:58 <monochrom> "where" is attached to one and only one "pattern -> expr" branch.
11:26:44 <saurabhnanda> code compiles, but don't understand the need for such a subtle difference between where and let
11:27:01 <Boomerang> doesn't that depend on indentation monochrom ? couldn't you have a "where" at the "case" level?
11:27:17 <monochrom> no, there is no such thing
11:27:28 <Boomerang> alright :)
11:28:27 <saurabhnanda> thanks Boomerang monochrom
11:28:33 <monochrom> the code you're looking at, there is an outer "pattern1 -> expr1", and inside expr1 there is an inner "pattern2 -> expr2". this is why you can use indentation to control where your "where" belongs to.
11:28:47 <Boomerang> I was mixing up with guards where the indentation of "where" matters (whether it's a single guard or all of them)
11:30:37 <monochrom> "let" and "where" look similar under a simplified mental model that only says "use them for local definitions".
11:31:35 <monochrom> but a precise mental model will note that they are under almost opposite grammar rules and almost opposite scoping rules. they are almost antipodal, not similar.
11:32:45 <saurabhnanda> wow, my vocab keeps expanding the more I use Haskell :-) What, pray, is antipodal?
11:33:02 <hpc> the opposite of podal ;)
11:33:28 <monochrom> like North Pole vs South Pole
11:33:28 <hpc> (it means something along the lines of "polar opposite")
11:35:20 <MarcelineVQ> it's also the best thing to do to heckran for an easy fight
11:39:10 <saurabhnanda> TIL
11:42:25 <saurabhnanda> is it acceptable to completely forget how you got a bunch of monad transformers to compose, 2 weeks down the line?
11:42:42 <monochrom> yes
11:43:44 <saurabhnanda> if this is the first time you saw this code, would it make sense to you, or would you be like, wtf? http://lpaste.net/160142
11:46:19 <monochrom> I wonder if you can eliminate the MaybeT layer altogether.
11:48:38 <saurabhnanda> monochrom: you mean ExceptT or the inner MaybeT?
11:49:13 <monochrom> the inner MaybeT
11:49:38 <saurabhnanda> I needed a way to go from Maybe  => ExceptT String NwApp ()
11:49:47 <saurabhnanda> write my own function to do this composition?
11:50:49 <saurabhnanda> and do I really need the 'MaybeT $ return' snippets? Can they be converted to a simpler 'let'
11:50:51 <saurabhnanda> ?
11:53:49 <Boomerang> let mt = MaybeT . return
12:45:21 <nmdanny> can anybody help me with an issue regarding multi line string literals?
12:47:44 <Gurkenglas__> @ask
12:47:44 <lambdabot> Who should I ask?
12:47:49 <Gurkenglas__> @where ask
12:47:49 <lambdabot> Don't ask to ask, just ask.
12:48:31 <nmdanny> the following multiline string doesn't compile/lint correctly: http://lpaste.net/160143
12:49:03 <nmdanny> giving me the following error: lexical error in string/character literal at character 'F' AllFile 0Project 0No Issuesdb.hs54:1 CRLFUTF-8Haskell
12:49:15 <nmdanny> lexical error in string/character literal at character 'F'
12:55:35 <geekosaur> nmdanny, to do multiline string literals you need to use string gaps, or various quasiquoters on hackage
12:56:10 <geekosaur> http://lpaste.net/92725
12:56:31 <sm> that's what nmdanny did, no ?
12:56:57 <geekosaur> oh, i missed their lpaste
12:56:59 <geekosaur> sigh
12:57:06 <sm> ah, but you left out the space before FROM nmdanny 
12:58:03 <geekosaur> yes, the gap \   \ is completely removed so the SQL looks like store_nameFROM
12:58:14 <geekosaur> but that would not produce that compiler error
12:59:03 <sm> the plot thickens
12:59:49 <geekosaur> also I do not get an error if I drop that in a file and turn it into a valid module ("main = do" at top, "  putStrLn sql" at bottom)
13:00:15 <sm> what is nmdanny compiling/linting with, we wonder
13:00:40 <geekosaur> although it shows where things run together due to lack of spaces
13:01:21 <geekosaur> well, the first mispaste tells me they're working in Atom
13:03:25 <sm> which may be running ghc-mod or stylish-haskell or hlint or its own highlighter..
13:12:59 <nmdanny> I'm running in atom indeed,
13:14:23 <nmdanny> unfortunately I have deleted that code snippet already, but it was in a do block, in a file that has TH and QQ enabled. maybe one of those interfered?
13:49:21 <goovie_> Hello, are there any beginner open-source projects i could attempt to? I'd like to improve my haskell programming abilities and be exposed to some good haskell code.
13:58:14 <cheater> goovie_: you could contribute to #snapframework
14:00:07 <suppi> goovie_, or purescript
14:00:24 <cheater> or #diagrams
14:00:42 <suppi> or ghcid :)
14:03:38 <goovie_> this diagrams thing looks awesome
14:04:27 <goovie_> Looks like it's associated with 'Monoids: Theme and Variations' paper, which I have somewhere in my 'PDFs i might read one day' library
14:37:21 <nineonine> hi there, question about free monads here !
14:38:02 <nineonine> so I have a small dsl for handling http communication
14:38:17 <nineonine> one of its Constructors is HandleResponse
14:38:48 <nineonine> it accepts Response , does body parsing anf fails if necessary
14:39:04 <nineonine> in the implementation of the interpreter function
14:39:14 <nineonine> im using decode from Data.Aeson
14:40:12 <nineonine> when I do that , the compiler forces me to use type constraint 
14:40:23 <nineonine> it says Could not deduce (FromJSON a1) arising from a use of ‘decode’
14:40:44 <nineonine> Possible fix:
14:40:44 <nineonine>   add (FromJSON a1) to the context of
14:40:45 <nineonine>     the data constructor ‘HandleResponse’
14:41:21 <nineonine> however sometimes there is no body in response so there is nothing to parse and I want just to have empty tuple
14:41:31 <nineonine> but it does not have FromJSON instance
14:42:10 <nineonine> so what I want is to force complier forget the type of 'a' 
14:42:53 <nineonine> so it does not care which values im threading through my computation
14:42:58 <nineonine> is it possible ?
14:45:02 <dmj`> nineonine: if you're calling decode, you won't be able to remove the FromJSON a, could you paste your code?
14:45:50 <nineonine> sure !
14:45:57 <Boomerang> Doesn't decode return a Maybe? So if there is an empty body, it just returns Nothing?
14:46:46 <nineonine> http://lpaste.net/160149
14:47:06 <nineonine> im actually using eitherDecode
14:47:14 <nineonine> but it does not matter I guess
14:47:39 <nineonine> both decode and eitherDecode have this FromJSON constraint
14:48:35 <dmj`> nineonine: can you paste the error of adding a FromJSON constraint to interpretIO
14:48:48 <nineonine> yeah
14:49:22 <nineonine> http://lpaste.net/160150
14:50:06 <nineonine> im struggling to wrap my head around free monads
14:50:20 <nineonine> so there is a high chance to see some nonsense in the code
14:51:44 <dmj`> HandleResponse :: FromJSON a => Response ByteString -> (a -> next) -> DiscogsF m next
14:52:54 <nineonine> trying it now
14:53:46 <nineonine> well I actually tried it before
14:53:54 <nineonine> and I know it works
14:54:04 <nineonine> If I add constraints everywhere
14:54:56 <dmj`> nineonine: do you know the json you'll be receiving back?
14:55:01 <nineonine> yes
14:55:06 <nineonine> and sometimes there is no body
14:55:14 <nineonine> so i want my result to be ()
14:56:32 <dmj`> nineonine: what if you did (Maybe Value), empty body == Nothing, o/w Just Value
14:56:59 <dmj`> I think decode on an empty body is Nothing
14:58:08 <nineonine> i would need to wrap every result of my action in Maybe
14:58:45 <nineonine> but this might work
14:58:54 <dmj`> right
14:59:03 <dmj`> > decode (mempty :: Data.ByteString.Lazy.ByteString)
14:59:05 <lambdabot>  Not in scope: ‘decode’    Not in scope:
14:59:05 <lambdabot>        type constructor or class ‘Data.ByteString.Lazy.ByteString’
14:59:05 <lambdabot>      Perhaps you meant ‘Data.ByteString.Lens.IsByteString’ (imported from Dat...
14:59:17 <nineonine> please have a look at this example
14:59:17 <nineonine> https://github.com/intolerable/reddit/blob/master/src/Reddit.hs
14:59:44 <nineonine> sorry, that one
14:59:45 <nineonine> https://github.com/intolerable/reddit/blob/master/src/Reddit/Types/Reddit.hs
14:59:57 <dmj`> nineonine: also, are you sure you need a free monad? Is the goal to write bindings to the discog api
15:00:20 <nineonine> no 
15:00:29 <nineonine> just a pure academic interest
15:00:58 <nineonine> I just want to learn the free monad stuff
15:01:18 <dmj`> for sure
15:01:23 <dmj`> this article helped me: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
15:02:40 <nineonine> yeah I love haskellforall !!!
15:02:47 <nineonine> this article is the best imo
15:03:45 <nineonine> the most confusing part is how you define Data Constructors for the functor
15:04:00 <nineonine> sometimes when you need to pass some value to the next layer
15:05:03 <nineonine> super confusing 0_o
15:15:15 <mathu> is there a local-scoping apparatus that scopes across pattern matches, or would i have to do, like, fn = case () of ...
15:22:36 <hexagoxel> mathu: you need case … of …
15:25:13 <mathu> hexagoxel: alright, thanks
15:32:55 <jdt> I'm trying to figure out how to database connection information from a file. how to turn a String in to a ConnectionString is eluding me.
15:33:06 <jdt> I'd like to replace https://gist.github.com/justindthomas/b9948090d1fdf1f3887a5f95d147bd6c#file-gistfile1-txt-L42 ...
15:33:19 <jdt> with a call to: https://gist.github.com/justindthomas/b9948090d1fdf1f3887a5f95d147bd6c#file-gistfile1-txt-L53
15:33:52 <jdt> but everything I try ends in an endless tirade from GHC
15:33:53 <dmj`> @package configurator
15:33:53 <lambdabot> http://hackage.haskell.org/package/configurator
15:34:33 <koala_man> type ConnectionString = ByteString
15:35:51 <jdt> oh. okay. I think I understand. thanks.
15:37:22 <koala_man> jdt: I tried looking at the postgresql docs linked to by https://hackage.haskell.org/package/persistent-postgresql-2.5/src/Database/Persist/Postgresql.hs but I don't actually see which encoding it expects
15:37:53 <koala_man> hopefully all your data is 7bit ascii
15:38:54 <jdt> this person uses encodeUtf8 to create the connection string: http://taylor.fausak.me/2014/10/21/building-a-json-rest-api-in-haskell/
15:39:39 <jdt> I tried some various permutations of that but couldn't get it to work (something about a difference between Data.Text.Lazy and Data.Text.Internal I think?)
15:39:44 <jdt> it was driving me nuts.
15:42:08 <mauke> employ understanding
15:43:08 <hpc> mauke: workplace policy dictates that we promote internally
15:57:42 <fresheyeball> quick question 
15:57:50 <fresheyeball> I have an `Either A B`
15:57:56 <fresheyeball> and I'm doing a case statement 
15:58:12 <fresheyeball> in a function that returns an `Either A C`
15:58:21 <fresheyeball> Left x -> Left x 
15:58:22 <fresheyeball> works fine
15:58:27 <fresheyeball> x -> x 
15:58:29 <fresheyeball> does not
15:58:42 <fresheyeball> I get why but it feels dumb
15:58:51 <fresheyeball> is there a better way?
15:58:56 <Clint> what
15:59:03 <Rembane> fresheyeball: Why doesn't it work?
15:59:17 <fresheyeball> it says that my case statement does not have consistent returns
15:59:23 <monochrom> fresheyeball: no, you have to write "Left x -> Left x".
15:59:29 <fresheyeball> right I get that
15:59:37 <fresheyeball> I need to write `Left x -> Left x`
15:59:44 <Rembane> fresheyeball: So Right x -> Right x; does that work?=
15:59:49 <fresheyeball> yes
15:59:52 <fresheyeball> or no sorry
16:00:01 <fresheyeball> `Right x -> Right (foo x)`
16:00:07 <fresheyeball> is what is needed to compile 
16:00:13 <fresheyeball> where `foo :: B -> C`
16:00:18 <monochrom> everyone, the question is "case yyy of Left x -> Left x; Right p -> Right (f p)" vs "case yyy of l -> l; Right p -> Right (f p)"
16:00:34 <fresheyeball> monochrom: yes, that looks right
16:00:43 <fresheyeball> thanks for the sum up
16:00:57 <monochrom> and I should re-order the two branches. "Right p -> Right (f p); l -> l"
16:01:00 <fresheyeball> is there a language extension that would allow for `l -> l`
16:01:07 <fresheyeball> ?
16:01:12 <monochrom> I don't think there is one.
16:01:19 <Rembane> My intuition is that it should work. Weird.
16:01:35 <Clint> fresheyeball: shouldn't you just be using fmap?
16:01:50 <scshunt> fresheyeball: can you put a sample in lpaste so I can better understand exactly what you're trying to do?
16:02:22 <monochrom> Rembane: we're converting "Left x :: Either A B" to "Left x :: Either A C". the terms look the same, but the type checker sees a difference.
16:02:26 <fresheyeball> Clint: that version just started to get ugly
16:03:09 <monochrom> "fmap f yyy" is preferrable, but fmap's code still does "Left x -> Left x" internally
16:03:45 <fresheyeball> scshunt: here is my actual function http://lpaste.net/160152
16:03:51 <fresheyeball> it compiles fine, but is ugly ugly
16:03:52 <Rembane> monochrom: Oh. That's true. Thank you for updating my intuition.
16:04:12 <monochrom> a simpler example uses Maybe. "fmap h Nothing = Nothing" you can't replace it by "fmap h n@Nothing = n".
16:04:27 <Rembane> fresheyeball: There are "better named" functions in Data.Either for doing what you want to do, do eliminate some code.
16:04:43 <fresheyeball> Rembane: can I send me an lpaste? 
16:04:56 <fresheyeball> most of my function is `Maybe`
16:04:59 <monochrom> it is a bit annoying because you start worrying about efficiency.
16:05:18 <Rembane> fresheyeball: Yes. Momento.
16:05:40 <Rembane> fresheyeball: No, since I was wrong. fmap is the way to go. :)
16:05:58 <scshunt> fresheyeball: what monochrom said is correct, as is the suggestion to use fmap
16:05:59 <fresheyeball> Rembane: did you see my full function? http://lpaste.net/160152 ?
16:06:00 <scshunt> also, what is err?
16:06:17 <Rembane> fresheyeball: It's verbose.
16:06:18 <fresheyeball> err :: ByteString -> Either Reply b
16:06:25 <scshunt> fresheyeball: ok
16:06:30 <scshunt> fresheyeball: use a where clause
16:06:31 <fresheyeball> err = Left . Error
16:06:35 <Rembane> fresheyeball: Wanna play code golf or do you have another goal for this code snippet?
16:06:45 <fresheyeball> Rembane: code golf
16:06:47 <scshunt> return $ fmap fn raw where fn = ...
16:06:50 <fresheyeball> I just think its ugly
16:06:59 <fresheyeball> ok interesting 
16:07:45 <Rembane> fresheyeball: Sweet!
16:07:46 <ski> monochrom : i've pondered if it wouldn't be possible to infer a type of `forall a. Maybe a' for `n' there ..
16:11:35 <enthropy> ghc has gotten more verbose at reporting type errors, right?
16:12:02 <fresheyeball> Rembane: actually no can do
16:12:09 <fresheyeball> fmap is not going to work
16:12:15 <Rembane> fresheyeball: Why?
16:12:17 <fresheyeball> since I need left to handle error cases 
16:12:22 <enthropy> for example https://ghc.haskell.org/trac/ghc/ticket/11941#ticket doesn't exist in 7.6.3 but it does in 7.8 and newer
16:12:27 <fresheyeball> in the case statements on maybe
16:12:36 <Rembane> fresheyeball: Aha.
16:13:12 <Rembane> fresheyeball: Is it important for you to have two different error messages for form not found and form failed to parse
16:13:22 <fresheyeball> not really
16:14:03 <fresheyeball> crap I got to go
16:14:04 <Rembane> fresheyeball: Okay, lets see then.
16:14:07 <fresheyeball> ttyl
16:14:09 <Rembane> fresheyeball: Good luck! :D
16:18:19 <Rembane> fresheyeball: This might work: http://lpaste.net/160152
16:18:21 <Rembane> Meh
16:26:15 <hexagoxel> when i force a running multithreaded program to stop programmatically by calling exitSuccess (or simply by returning ()), how hard are other threads killed? e.g. are finally-blocks run?
16:27:32 <hexagoxel> (i guess not, because then the program easily would not terminate..)
16:28:16 <c_wraith> ski, I feel like that would interfere with introducing skolem variables when matching on an existential 
16:28:39 <ski> c_wraith : how/why ?
16:28:40 <hexagoxel> assuming no: does there exist any functionality that would allow "more graceful aborting"?
16:28:48 <c_wraith> ski, not that I'm sure why. just a suspicion. 
16:28:56 <enthropy> the inline-c package doesn't let you directly pass in a `newtype Foo = Foo (Ptr ())` to a c expression/function/whatever that should be a (foo*), right?
16:29:41 <hexagoxel> also, can someone point me to info about how ctrl-c is handled? will that cause throwTo to all threads?
16:29:42 <enthropy> http://hackage.haskell.org/package/inline-c-0.5.5.2/docs/Language-C-Types.html#t:TypeSpecifier has no mention of Ptr
16:30:31 <hexagoxel> followup questions: can i hook into forkIO? list all threads? or throw an exception to all threads?
16:30:41 <c_wraith> ski, hmm. no, not skolems. inferring that type would interfere with all kinds of Proxy-related tricks. 
16:31:13 <c_wraith> ski, since those tricks depend on types not being polymorphic 
16:31:43 <enthropy> hexagoxel: forkIO gives you a ThreadId so you could keep track of those yourself. Probably better is to use some package that's higher level (say async or parallel-io)
16:31:56 <dreams> How is pair equality implemented? is it: (a,b) == (x,y) = (a == x) && (b == y)
16:32:12 <ski> c_wraith : anyway, the idea would be that if `<var>@<pat>' is a pattern where `<pat>' is data constructor (applied to enough argument patterns) where some of the type parameters of the corresponding type doesn't occur in the argument types of that data constructor, then `<var>' could be generalized on these type parameters
16:33:10 <hexagoxel> enthropy: i am aware of means to manually achieve throwing-to-all-threads for all code under my _current_ project, but that seems rather weak.
16:33:10 <c_wraith> ski, yes, but that would then prevent you from usefully passing that argument to something wanting a type witness
16:33:53 <ski> c_wraith : so, e.g. since `Left :: forall a. a -> (forall b. Either a b)', if we match a value in `Either A B' with `e@(Left a)', then `e' would get type `forall b. Either A b')
16:34:38 <ski> c_wraith : i suppose you could use a separate witness, or match several times ?
16:34:54 <ski> dreams : yep
16:35:41 <ski> > (False,undefined) == (True,undefined)
16:35:42 <ski> > (undefined,False) == (undefined,True)
16:35:44 <lambdabot>  False
16:35:44 <lambdabot>  *Exception: Prelude.undefined
16:35:55 <c_wraith> ski, my point is mostly that there is code that depends on it not being generalized. 
16:36:01 <ski> (because `&&' is short-circuiting)
16:36:19 <ski> c_wraith : "is", or "could be" ?
16:36:38 <c_wraith> ski, I've written code that would break. :) 
16:36:44 <ski> ok :)
16:36:50 <c_wraith> (and in production systems!) 
16:37:22 * ski is curious about what the code looked like
16:38:09 <c_wraith> heck, that change would break Typeable 
16:38:48 <ski> but `typeOf' doesn't pattern-match on the argument, no ?
16:38:54 <c_wraith> well, not Typeable, since it doesn't match on the constructor. 
16:38:58 <ski> so i don't see how it would break
16:39:04 <c_wraith> but I've written code that does. 
16:39:14 <dreams> ski: so its lazy in its second argument. I know for a fact that this can introduce a space leak (from an experiment).
16:39:23 <ski> dreams : "it" being ?
16:40:02 <c_wraith> things like Storable instances for arrays with their size in their type. 
16:40:27 <ski> as phantom parameters ?
16:41:13 <dreams> ski: its strict in its first argument only, which means if the second argument is a large expression it will be retained in the heap until the first argument is evaluated to False. (I have not tried -O to see if the space leak goes away).
16:41:57 <ski> dreams : i'm still not sure what you mean by "it" in "so its lazy in its second argument" and "its strict in its first argument only, which means if the second argument is ..."
16:42:10 <dreams> ski: &&
16:42:19 <ski> ok
16:42:42 <ski> then, yes
16:42:58 <ski> and it's conditionally strict in the second argument (namely in case the first argument is `True')
16:43:11 <ski> @src (&&)
16:43:11 <lambdabot> True  && x = x
16:43:11 <lambdabot> False && _ = False
16:43:29 <ski> (and you can read this off from the definition of `(&&)' ^)
16:44:19 <ski> dreams : anyway, one reason why being (conditionally) non-strict in the right argument is desirable is things like
16:44:21 <dreams> ski: ots not?
16:44:49 <ski> > let x = 0; y = 7 in  x /= 0 && y `div` x > 0
16:44:51 <lambdabot>  False
16:45:06 <ski> > let x = 0; y = 7 in  y `div` x > 0 && x /= 0  -- reversing the order gives us an error
16:45:08 <lambdabot>  *Exception: divide by zero
16:45:39 <ski> so the condition `x /= 0' guards the division, making sure we don't perform it in case we'd attempt to divide by zero
16:45:55 <ski> if `&&' was strict in both arguments, then this wouldn't work
16:46:46 <ski> another simple (but not really idiomatic) example would be `not (null xs) && (..(head xs)..(tail xs)..)'
16:47:05 <ski> (more idiomatic, at least usually, would be to use explicit pattern-matching here)
16:48:41 * ski notes how you can specify the formation rule for `A /\ B' such that it is a well-formed proposition (formula) in case `A' is well-formed, and additionally : `B' is well-formed under the *assumption* that `A' is true
16:50:57 <ski> (and you can have a similar formation rule for `A => B', where you're assuming that `A' is well-formed, and also that `B' is well-formed under the assumption that `A' is true. these two formation rules would be what you get if you erase the explicit proof-dependence in `B' of a proof of `A', in dependent conjunction and implication)
16:52:38 <ski> (the proof of `B' can still depend on the proof of `A', in the implication case. but (in either of the two cases) the formula `B' itself can't. however, whether `B' is *well-formed* can still depend on there being a proof of `A' (and perhaps also on the particular proof used))
16:52:59 * ski ponders dependent disjunction
17:05:01 <Squarism> can you define and declare a variable on the same line in haskell? 
17:05:18 <Squarism> like ... let a :: Int = 3
17:05:54 <shachaf> You can write that with ScopedTypeVariables.
17:06:16 <Squarism> what is ScopedTypeVariables
17:06:19 <Squarism> ?
17:06:23 <shachaf> An extension that lets you write that.
17:06:30 <shachaf> If you let it in ghci it'll tell you to turn it on.
17:06:37 <shachaf> You can also write let a = 3 :: Int (no extensions required, but of course you might run into issues with the monomorphism restriction).
17:06:43 <shachaf> And you can write let a :: Int; a = 3
17:07:26 <Squarism> ofcourse i could =D
17:07:36 <Squarism> Im a total haskell newb
17:07:52 <alexashka> question: is there a way to see the code generated for something like someFunc x y = x + y when I do someFunc 1. So it'd be \y -> 1 + y
17:09:03 <Squarism> shachaf, so are people using ScopedTypeVariables? It sort of bothers me i have repeat myself for simple variables and functions in vanilla mode
17:09:25 <geekosaur> alexashka, not /per se/. there is ghc-vis that will let you see reductions in ghci
17:09:37 <shachaf> Off-hand I don't think let x :: Int = 5 is great style. But it's probably fine.
17:09:51 <Rembane> Squarism: Why would you want to do that?
17:10:08 <alexashka> @geekosaur ok, I guess I should google ghc-vis?
17:10:08 <lambdabot> Unknown command, try @list
17:10:25 <geekosaur> @hackage ghc-vis
17:10:25 <lambdabot> http://hackage.haskell.org/package/ghc-vis
17:10:27 <Squarism> 1. verbosity hides intent. 2. having to repeat myself is tedious
17:11:05 <monochrom> Ideally if you had a million instances of "x385 :: Int \n x = 385", it is of course horrible and you would like to merge two lines into one.
17:11:15 <monochrom> But practice is not ideal.
17:11:22 <Rembane> Squarism: That's legit. You generally don't have to add type signatures though.
17:11:37 <alexashka> @geekosaur this looks very helpful - thank you very much. How'd you find out about it?
17:11:37 <lambdabot> Unknown command, try @list
17:11:52 <shachaf> ScopedTypeVariables as an extension is fine and very useful, though.
17:12:02 <shachaf> This is just not the main purpose of it, just a side effect.
17:12:08 <monochrom> In practice maybe you have 2 instances of that kind your whole life. Instead, you have a million instances of "functon394 :: A -> B -> C -> D \n function394 x y z = ..."
17:12:24 <Squarism> Rembane, shachaf ok thanks!
17:12:26 <monochrom> at which point you will prefer to keep those two lines separate.
17:12:30 <geekosaur> I've been keeping an eye on such things for years, as they';ve evolved (the earliest one was "hat" which is also on hackage but doesn't work with modern ghc; it was a bit tightly tied to ghc 6.6)
17:12:55 <shachaf> monochrom: Well, ScopedTypeVariables lets you write function394 (x :: A) (y :: B) (z :: C) :: D = ...
17:12:56 <monochrom> no one is going to write "function394 :: A -> B -> C -> D = \x y z -> ..."
17:13:02 <Rembane> Squarism: np, good luck!
17:13:12 <Squarism> shachaf, but its nothing hackish / incomplete with that extension? 
17:13:39 <Squarism> there is..
17:13:50 <Squarism> even
17:14:06 <shachaf> monochrom: Hmm, or maybe it doesn't anymore.
17:14:20 <shachaf> I think it used to but it was deprecated but that was the original motivation for allowing this syntax.
17:14:23 <shachaf> But I could be wrong.
17:14:43 <monochrom> possibly it just doesn't like the ":: D" part
17:14:45 <alexashka> @geekosaur I may be asking for the wrong thing too - the trouble I'm having is with understanding the unwrapping of monad transformers. For instance if I have EitherT String (MaybeT IO) String. I have trouble understanding what running only runEitherT a will produce. I understand it'll be a MaybeT IO String but I have trouble intuiting how it really works
17:14:45 <lambdabot> Unknown command, try @list
17:14:58 <shachaf> monochrom: Yes, but that's the analogy of x :: Int = 5
17:15:16 <alexashka> @geekosaur so I'm hoping to see the monad code transformed from eitherT to maybeT to gain some intuition. Is that a good way to go you think?
17:15:16 <lambdabot> Unknown command, try @list
17:15:17 <shachaf> analogue
17:15:36 <shachaf> alexashka: Don't start your lines with "@". lambdabot doesn't like it.
17:15:50 <alexashka> oh, sorry, how do I address an individual?
17:16:04 <shachaf> The same way but without the @.
17:16:07 <monochrom> simply delete @ and you'll be fine
17:16:14 <alexashka> shachaf: *slaps forehead* yes sorry :)
17:16:15 <geekosaur> generally a nick followed by , or :
17:16:32 <geekosaur> irc just looks for a nick surrounded by whitespace or punctuation
17:16:37 <geekosaur> doesn't need an introducer
17:17:52 <taggers> Since bash is coming to windows 10, is it likely that stack build to docker will also work on win10? I can only imagine that the answer is yes
17:20:14 <geekosaur> someone already tried it and ran into the syscall emulation not supporting the timer syscalls made by the ghc runtime, iirc
17:20:14 <hpc> i just can't wait for wine
17:20:26 <hpc> finally we can have perfect windows xp emulation :P
17:20:52 <geekosaur> ("timer_create: Invalid argument" which is something we used to see when people tried to use ghc bindists on ancient debians)
17:21:33 <taggers> IIRC, the devs working on it know that lots of stuff isn't working at this point in time. I
17:21:47 <taggers> I've never wanted a feature so badly before in my life
17:22:34 <geekosaur> alexashka, in answer to your question, I don't know of any tools that can show that to you
17:22:57 <geekosaur> things like hat/(g)hood/ghc-vis would be a bit too low level for you, I think
17:23:25 <geekosaur> they'd show you the "un-monadified" stuff which would not make sense unless you understood the monads already
17:24:02 <geekosaur> @unmtl StateT SomeState (ReaderT SomeEnv) Identity
17:24:02 <lambdabot> Plugin `unmtl' failed with: `ReaderT SomeEnv (Identity, SomeState)' is not applied to enough arguments.
17:24:04 <geekosaur> @unmtl StateT SomeState (ReaderT SomeEnv) Identity a
17:24:04 <lambdabot> Plugin `unmtl' failed with: `ReaderT SomeEnv (Identity, SomeState)' is not applied to enough arguments.
17:24:13 <geekosaur> @unmtl StateT SomeState (ReaderT SomeEnv Identity) a
17:24:14 <lambdabot> SomeState -> SomeEnv -> (a, SomeState)
17:24:16 <geekosaur> derp
17:24:38 <geekosaur> that's the level it'd show you, and building an intuition from that could well be difficult
17:27:43 <alexashka> ok so maybe I should aim for clarifying questions - when you provide SomeState as per your example and it returns the ReaderT SomeEnv Identity a - what has it actually done?
17:28:08 <alexashka> for instance in someFunc x y = x + y, when I do someFunc 1, I can understand it resulted in \y -> 1 + y
17:28:22 <alexashka> what'd unwrapping the state monad result in exactly?
17:28:43 <geekosaur> did you see the unmtl I did above?
17:28:50 <alexashka> yes
17:28:51 <geekosaur> [16 00:23] <geekosaur> @unmtl StateT SomeState (ReaderT SomeEnv Identity) a
17:28:51 <geekosaur> [16 00:23] <lambdabot> SomeState -> SomeEnv -> (a, SomeState)
17:29:18 <geekosaur> that is literally what it is doing. for ReaderT Identity it'd be even simpler
17:29:26 <geekosaur> @unmtl ReaderT SomeEnv Identity a
17:29:27 <lambdabot> SomeEnv -> a
17:29:35 <geekosaur> that's all a ReaderT is
17:29:36 <alexashka> that's just the signature, I am more interested in how it modified the implementation
17:30:05 <alexashka> do you see what I mean? I feel we're talking past each other :P
17:30:10 <geekosaur> hm? there really isn't anything more to it than that
17:30:10 <Squarism> now that "enterprise software industry" is moving vs functional language paradigms. You see haskell exploading anytime soon?
17:30:32 <Squarism> moving towards... even
17:30:46 <geekosaur> I do not understand "modified the implementation"
17:30:59 <alexashka> ok so for someFunc, the implementation is x + y
17:31:07 <alexashka> when I provide the first argument, it becomes 1 + y
17:31:32 <systemfault> IHMO, There's a huge gap between using map/filter/reduce + some optional monad in popular OOP languages VS pure FP
17:32:58 <Rembane> What's in the gap? Monads?
17:33:13 <Squarism> systemfault, I wouldnt argue against that cause ive never done 100% FP. But once i started with those constructs more and more of my code got immutable
17:33:49 <geekosaur> Rembane, patterns of thinking / reasoning about code
17:34:21 <Squarism> now i really feel the pain evertime i open up for mutability
17:34:31 <geekosaur> youy can import FP concepts into other languages. mindsets don't import so easily
17:34:59 <alexashka> so for StateT String (ReaderT String IO) String. Let's say the implementation was do line <- lift lift getLine; return line; What's the implementation after I run runStateT "hello"?
17:35:17 <Cale> Squarism: Haskell is already being used at a scale that it's comfortable putting it into production. I'm more interested in where we go next.
17:35:42 <enthropy> :t runState
17:35:43 <lambdabot> State s a -> s -> (a, s)
17:35:54 <enthropy> alexashka: you expected the args to be flipped?
17:35:56 <Rembane> geekosaur: That seems like an even bigger gap than I imagined.
17:36:02 <Squarism> Cale: any prophecy about that?
17:36:23 <systemfault> Rembane: IMHO, the gap is the mutability escape hatch that most language have.
17:36:24 <Cale> Squarism: The obvious idea is that we should have a lazy-by-default dependently typed functional programming language, with proper type classes.
17:36:51 <alexashka> enthropy: I should probably come up with a better example :P
17:36:55 <Rembane> systemfault: So when a language goes 100% immutable it gets hard to work with for programmers who aren't used to it?
17:37:10 <geekosaur> alexashka, you haven't done anything with the state so it's going to reduce to \_ -> getLine
17:37:22 <geekosaur> or with the environment for that matter
17:37:33 <Cale> Squarism: a little farther out, absorbing ideas from HoTT seems like a good plan -- I would love to have higher inductive types in my language, and univalence seems like a nice idea.
17:37:56 <alexashka> geekosaur: right, let me think fo an example that does use the state a bit, it's clear that it'll reduce to that in that case yes
17:39:32 <Cale> (I'm not sure how well univalence would interact with type classes though...)
17:41:01 <Cale> Squarism: The grand vision is to eventually have a foundation for programming languages and mathematics which can be shared by programmers writing real-world software and working mathematicians who would like to check their proofs, such that work can freely be exchanged there.
17:42:04 <Squarism> Cale: Interresting to hear your thoughts. You seem to know concepts i vaguely can imagine - only having done Scala extensively. Read up on HoTT.. sounds nextgen! Thats what those AI's taking over the world are going to use im sure! =D
17:43:45 <alexashka> ok, is pasting multiline code in here ok?
17:43:51 <Cale> lpaste.net
17:43:57 <Cale> ^^ paste it there, and link it
17:44:18 <lpaste> alexashka pasted “Monad Transformers Example” at http://lpaste.net/160155
17:44:44 <alexashka> ah, there we go :)
17:44:59 <Cale> btw, modify (const x) is the same as put x
17:45:13 <alexashka> Cale: you're right, I am just learning
17:46:13 <alexashka> ok so had I only run runStateT someStateM "hey", without the runReaderT. What is it doing? Because it can't do the modify code until it runs the readerT
17:47:52 <alexashka> in other words the state modification depends upon the reader. So when I do runStateT and it produces the ReaderT String IO String. Has it captured the State monad in there?
17:48:30 <geekosaur> you actually have to run that inside a ReaderT environment for it to typecheck
17:50:10 <ntnt> are there videos of especially awesome haskell workflows? I'm currently using a 3-term setup, where right term = 70% of width = big giant VIM window editing code; left-top = ghci prompt (inside tmux so I can send cmds via vim), and left-bot = terminal where I use to run grep
17:50:23 <ntnt> however, I think there are other cooler setups around
17:50:27 <ntnt> anyone have one they recommend?
17:50:50 <geekosaur> and you can;t use the "ask" directly because the direct evaluation environment is the StateT, not a ReaderT. you would need to use lift ask, or use newtype deriving to make a type that is both MonadState String and MonadReader String
17:51:13 <geekosaur> (which, behind the scenes, would just be inserting "lift" for the ReaderT-using parts)
17:52:14 <tommd> Too much 'lift'ing inline with code makes me think the abstraction is bad and people should be more willing to make a newtype with properly named functions for what they really want instead of exposing the guts of StateT, ReaderT, etc.
17:52:25 <geekosaur> that behind the scenes part is done by newtype deriving of MonadReader; it would see that there is a MonadReader inside the MonadState it was given, and generate "instance MonadReader theDerivedNewtype where ask = lift ask"
17:53:15 <alexashka> geekosaur: when you say I have to run it inside a ReaderT environment, what do you mean by that?
17:53:23 <alexashka> I'm with you re lift ask
17:57:27 <geekosaur> in practice it means you dont just do runStateT "hello", you do runStateT (runReaderT yourFunction "world") "hello"
17:58:05 <geekosaur> altough you could do the runStateT from the inside of something you gave to runReaderT that does more than just the StateT part
17:58:38 <geekosaur> sorry, other way around with this ordering
17:59:01 <geekosaur> runReaderT (runStateT yourFuntion "hello") "world"
17:59:12 <alexashka> right - I understand that that's what is typically done
17:59:29 <alexashka> I'm trying to get to the bottom of how it actually works :)
17:59:41 <Squarism> when i define different "data" i get a compile error of they share the same name on fields?
17:59:43 <alexashka> back to someFunc x y when I give the x value, I know exactly what it's giving me back
18:00:05 <Squarism> ...with "record syntax" that is
18:00:07 <geekosaur> Squarism, yes
18:00:17 <alexashka> with monads where running the first monad seems to depend on having run the second - I am quite confused in regards to what actually happens
18:00:45 <Squarism> geekosaur, can i make them "data" local so to speak? 
18:00:52 <Cale> alexashka: The best thing to do here if you're curious about the mechanism is to work through the definition of ReaderT and StateT and make sure you understand how (>>=) works, and the other primitives like ask, get, and put
18:01:09 <hpc> alexashka: when you run an action of type (FooT Bar a), the result is something having to do with (Bar a), so you then run that
18:01:50 <alexashka> Cale: it's not so much the specific monads, it's what happens when you nest them and the value of the second monad precedes the code that runs the first
18:02:11 <Cale> Squarism: The field names are automatically defined to be functions which extract those fields from the record.
18:02:24 <geekosaur> alexashka, what the runReaderT stuff should be telling you is that that actually must be run *first*
18:02:34 <hpc> running one is peeling off that layer and getting back the next layer
18:02:55 <hpc> and it goes outmost inwards
18:03:20 <hpc> *from outmost to inwards
18:03:22 <alexashka> hpc: I understand the theory - it's the practice that leaves me confused :)
18:03:23 <Cale> alexashka: Well, the (>>=) for StateT, for instance, involves constructing a computation in another monad
18:03:52 <geekosaur> Squarism, ghc 8.0.1 will have the start (only the start, sadly) of a mechanism that will allow you to reuse field names that way. according to standard Haskell, you get a function for free from a field definition, so its type will be fixed when you use it in the first record and the second would be both a name conflict and a type conflict
18:04:32 <geekosaur> because it would want to simultaneously define foo :: MyRecordA -> SomeType and foo :: MyRecordB -> AnotherType
18:04:54 <Squarism> geekosaur, ouch.. 
18:05:28 <geekosaur> (ghc8 will get around this with typeclasses using type level strings... see https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields)
18:05:40 <alexashka> geekosaur: it is not telling me that at all
18:06:05 <lpaste> alexashka pasted “Updated Monad Transformers Ex” at http://lpaste.net/160156
18:06:10 <Squarism> geekosaur, so what convention do people use now then? car_name, person_name?
18:06:15 <geekosaur> alexashka, you keep asking where the ReaderT comes from
18:06:28 <geekosaur> the answer is *it must be supplied*. that is what the runReaderT does
18:06:57 <Squarism> geekosaur, or did you mean its per instance? So you have to rename them for every instance?
18:07:07 <alexashka> geekosaur: giveReader in that code sample is fine. So obviously I did runStateT first and it compiled
18:07:12 <Cale> Squarism: Things like that, yeah. Often just a short prefix, but if you have a lot of types, maybe just the whole type name. There's some choices to make about underscore vs. camel case
18:07:44 <Squarism> Cale, ah ok
18:08:10 <geekosaur> Squarism, generally we use a per-record prefix. (you *can* share them among multiple constructors of a record, provided they have the same type... but that runs into partiality, potentially, so don't do that)
18:08:33 <Cale> Squarism: At the company I'm working for, we use _typeName_fieldName (where the type name is made lowercase). This looks ugly, but there are Template Haskell macros for generating lenses and JSON that work smoothly with this.
18:09:07 <Cale> So if you don't like the initial underscore, you use the lens instead, which doesn't have that. :)
18:10:51 <megajosh2> Squarism: I always do something like mytypeFoo mytypeBar mytypeMagicPowerLevel
18:10:51 <Squarism> Good to know. Guess ill have to live with that i guess
18:11:13 <megajosh2> think C with structs
18:11:19 <megajosh2> and functions
18:11:25 <Cale> Squarism: If you need polymorphism across many record types, then you can define a type class
18:11:30 <Squarism> c ADT style
18:13:09 <geekosaur> eventually you won't have to. but this is *the* annoyance that led to lenses (and indeed lens)
18:13:59 <geekosaur> there are simpler things than the lens library that solve the same problem (at the cost of either some boilerplate or some template haskell that generates the boilerplate for you)
18:14:13 <geekosaur> ...and ghc8 will eventually be able to generate the boilerplate itself
18:15:06 <Squarism> oh.. just thought lenses were means for mutation of immutable data
18:15:53 <geekosaur> well, once you have the part that gives you first class record labels, you have like 95% of the "mutation" part
18:15:58 <aweinstock> you can fake mutation of immutable data without lenses, but lenses compose well
18:16:15 <geekosaur> and about 90% of a full generics implementation. so lens went the rest of the way :)
18:16:34 <geekosaur> fclabels, for example, just does the record fields part
18:16:54 <hpc> Squarism: lens is more of an abstraction over record-replacement syntax
18:17:04 <hpc> like (foo {bar = newBar})
18:17:18 <Cale> Lenses are like first class field labels in a way
18:17:22 <hpc> which denotes a new value that's the same as foo with bar replaced
18:17:31 <Cale> (in a nice way which composes)
18:17:35 <geekosaur> well, 90% is overstating since you want to generalize to all the other kinds of data structures. still it's like 60% or more because handling records is the hard part of that generalization :)
18:17:44 <Squarism> yeah.. meant "mutation" 
18:18:28 <aweinstock> it's possible to actually mutate immutable values with unsafePerformIO and poke ;)
18:18:48 <aweinstock> s/immutable/"immutable"/
18:19:21 <Cale> It's also possible to actually mutate them in ways that can't really be observed internally to the program, just by causing evaluation to occur ;)
18:20:00 <Cale> There's a lot of mutation which is taking place behind the scenes in a lazy evaluator -- expressions are being replaced by their evaluated results.
18:20:01 <Squarism> im planning to implement a board game. sounds like itll take a while before im productive
18:20:06 <hpc> the existence of unsafePerformIO hides a rather fun dirty secret about ghc
18:20:11 <hpc> which is that every 
18:20:20 <Cale> Squarism: Don't let this conversation scare you too much :D
18:20:41 <hpc> every "pure" value in haskell is IO, and you just avoid effects by convention
18:20:56 <hpc> (the IO type being the formalization of that convention within the type system)
18:21:09 <Cale> Squarism: But yeah, it can take quite some time to really be productive. For me, it was a couple months before I really felt like I could get useful things done with Haskell, and then about a year to be "comfortable", for some definition.
18:22:07 <jonsey> how does that mean that every pure value is IO? i am not following
18:22:59 <hpc> jonsey: so, unsafePerformIO attaches IO execution to the evaluation of a pure value
18:23:22 <Cale> jonsey: Well, hpc is referring to the fact that in GHC's implementation of Haskell, evaluation *can* actually cause IO effects to occur (which unsafePerformIO lets you do), and we're just, by convention, not using that most of the time.
18:23:23 <Squarism> Cale, ouch. Id hoped to have something running over the weekend =D
18:23:30 <hpc> jonsey: in order for this to be possible, the implementation of a pure value must necessarily admit the ability to perform IO execution during evaluation
18:23:37 <Squarism> Cale, which i understand will be impossible =D
18:23:54 <Cale> Squarism: Well, dive in and try, and at least you'll have good questions for us
18:24:04 <Squarism> Cale, any hints on making faster progress?
18:24:08 <hpc> Squarism: oh you can absolutely have something running over the weekend
18:24:21 <hpc> Squarism: depending on the something and the weekend, and how much you want to understand it when you're done
18:24:57 <Cale> Squarism: Mainly that one -- asking questions, even if they seem silly. There are a lot of people around here who remember what it was like starting out :D
18:25:23 <hpc> Squarism: the best hint i can give is you're going to find a lot of explanations for things that seem to be lacking
18:25:40 <hpc> Squarism: like "this is just a definition!" kind of lacking, and it's hard to see it ever being useful
18:25:59 <Squarism> hpc =D. I left coding by coincidence some 10 years ago. Yo'll allways have to pay interest at some point
18:26:00 <zRecursive> How to use another linker instead of GNU linker which is VERY slow ?
18:26:01 <Cale> Squarism: Also, maybe try to focus on getting good at manipulating lists -- not for the sake of forming lists of things, but for expressing iteration. Lists are our loops.
18:26:03 <hpc> Squarism: for those, they really are just definitions, but so many things match the definition that being able to treat them similarly is useful
18:26:36 <hpc> Squarism: so take them less as things and more as observations that a lot of other things act that way
18:26:46 <Cale> Squarism: and after you have the basic Prelude types down, I would say Data.Map and Data.Set are the two most important things to pick up soon after
18:27:33 <hpc> zRecursive: i believe gold is still a better linker?
18:27:34 <tippenein> What am I looking for if I need to combine an Either String [String] with something that takes a [String] as the first argument?
18:27:41 <tippenein> trying to compose with Either, basically
18:27:42 <hpc> or i remember it being better a few years ago
18:27:53 <hpc> for ghc's code generation
18:28:00 <Squarism> Cale, i have done some years of professional work in scala. So im down with map,flatMap,filter and Maybe 
18:28:05 <Cale> tippenein: Well, what should happen in the case that you have Left s?
18:28:24 <zRecursive> hpc: i heard of gold but how to tell ghc to use it ?
18:28:40 <tippenein> continue passing the s from Left
18:28:46 <hpc> zRecursive: your package manager should replace the ld on your path with it and it just works
18:29:03 <Squarism> hpc, ok.. will keep that in mind
18:29:05 <Cale> tippenein: Well, that doesn't have type [String] -- do you mean [s]?
18:29:38 <tippenein> well, actually.. Cale, what would you recommend for handling the composition of functions that can all possibly fail
18:29:40 <Cale> tippenein: So it'll be  case v of Left s -> f [s]; Right ss -> f ss ?
18:29:47 <zRecursive> hpc: ok
18:29:50 <tippenein> yeah, the [String] isn't important
18:30:24 <Cale> tippenein: Well, the monad instance for Either e is pretty useful
18:30:31 <MarcelineVQ> Cale: Do you have a link to that clicker-game reflex-dom example of yours?
18:31:38 <hpc> Squarism: oh, another tip that probably sounds weird but just in case you get discouraged
18:32:04 <Squarism> ok?
18:32:04 <Cale> MarcelineVQ: yeah, http://cale.yi.org/share/incremental.jsexe/ is the running thing... http://cale.yi.org/share/incremental.hs is the code for it
18:32:15 <hpc> Squarism: don't be afraid to try learning haskell in another language
18:32:22 <MarcelineVQ> Cale: thank you
18:32:37 <Squarism> hpc in java? 
18:32:38 <Cale> MarcelineVQ: Thinking of starting on a project?
18:32:40 <Squarism> =D
18:32:44 <MarcelineVQ> Cale: yes indeed
18:32:56 <Cale> MarcelineVQ: Note that there is #reflex-frp
18:33:02 <Squarism> hpc, or do you mean in in another human language?
18:33:09 <hpc> Squarism: you won't get the full effect of a lot of what makes haskell so unique, but some of the bendy perspective carries over
18:33:17 <hpc> probably more like javascript, but yeah
18:33:48 <hpc> where you can write something weird you see in haskell and see how it works in another environment
18:34:39 <hpc> understanding that it's not really going to work like it would in haskell, but it can help at least a bit to get into the mindset
18:34:48 <hpc> definitely as a last resort though
18:34:57 <Cale> It's really hard to translate most of the really remarkable things in Haskell to most other languages though
18:35:08 <Cale> anything which is a type class isn't likely to pan out so well
18:35:22 <hpc> it's a dangerous escape hatch if you want to seriously learn haskell
18:35:35 <Cale> e.g. most languages just don't have the kind of polymorphism you need to make monad a sensible idea
18:35:38 <Squarism> Scala borrows alot from haskell. pattern matching, type classes, currying, partial application and such.. so i got some idea of many concepts. Right now i feel the syntax and environemnt/tooling are the trickiest parts
18:35:40 <hpc> like so many movies where the character stops training right before the very end :P
18:36:06 <Squarism> hpc, also the monad part feels scary
18:36:31 <Squarism> ...and the lack of "classes" to "partition" your programs
18:36:31 <hpc> Squarism: you'll be surprised by how unscary it is
18:37:12 <hpc> my first hint especially applies to Monad, it's only what the definition is and there's just a lot of things that follow its pattern
18:37:43 <hpc> and there's plenty of build-up to it
18:38:10 <Squarism> This is the most brilliant explaination i found on monad, monoid, functor, applicative. http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
18:38:34 <Cale> Squarism: I understand those concepts and I find it horribly confusing
18:39:05 <Squarism> Cale, the picture tutorial?
18:39:11 <Cale> yeah
18:39:17 <Cale> It applies kind of okay to Maybe
18:39:17 <dmsthns> ignore -channels #freenode,#haskell * JOINS PARTS QUITS NICKS
18:40:18 <Cale> But these pictures don't work so well for most other monads -- there are some more container-like monads which you can perhaps capture pictorially, but the pictures wouldn't quite look like this
18:40:46 <Cale> But for Maybe alone, this is okay...
18:40:51 <hpc> Squarism: in general with type classes the closer you get to the code definition, the better you'll do
18:40:57 <Squarism> Cale, i guess i cant argue on its merits but to a complete amature like me it made sense
18:41:51 <Cale> Squarism: It's a little weird to think of something like, say, a Parser whose result is an Integer, as merely a box with an integer inside it.
18:42:18 <Squarism> =D
18:43:16 <Cale> Squarism: You can almost get away with it, if you already understand everything properly, but I wonder if it's not just causing confusion to beginners.
18:44:05 <hpc> perhaps the best way to put it is, the instant something about Functor/Applicative/Monad confuses you, immediately forget everything from that post
18:44:54 <Cale> Squarism: It's a box which, when you run the parser to pull the result of parsing out, may cause the world to be destroyed, or split into many sub-worlds, in each of which it has produced a different value, and perhaps depleted the input string by a different amount.
18:44:55 <Squarism> Cale, i have a spatial approach to things so i guess thats why i felt it made more sense than abstract talks about them
18:45:35 <Cale> Or IO actions
18:46:03 <Cale> getLine :: IO String is about as much like a box containing a string as /bin/ls is a box containing a listing of the contents of your home directory
18:46:45 <Cale> So you have to be a little careful about pictures like this
18:46:56 <Squarism> promise! =D
18:47:50 <Squarism> Well thanks both of you Cale and hpc! Thanks for very welcoming and helping attitude. Appricate it alot.
18:51:12 <maerwald> Cale: that's because you think of a box as a container. I see those pictures in a different way.
18:51:37 <hpc> look down, look up, these pictures are now diamonds
18:51:40 <Cale> maerwald: Well, I'm thinking of those pictures as pictures of physical objects
18:51:46 <maerwald> and it says in multiple places _context_ instead of "container"
18:52:03 <Cale> Yeah, the word "context" is another thing I can't stand
18:52:09 <maerwald> so it's pretty accurate if you don't insist that a picture of a box cannot describe an abstract concept
18:52:26 <hpc> a "context" to a value implies that the value is there with stuff attached
18:52:27 <maerwald> well that's nitpicking land then
18:52:35 <Cale> Monads are not contexts. A value of type IO String is not a String in an IO "context"
18:52:55 <Cale> It's something which will compute a String each time it is executed
18:53:04 <Cale> and may produce a different result each time
18:53:09 <scshunt> one or more strings
18:53:17 <scshunt> err
18:53:20 <Cale> zero or more, even :)
18:53:20 <scshunt> zero or more, in a general monad
18:53:39 <Cale> Well, we may simply not execute the IO action, and a String will never be computed
18:54:35 <hpc> or maybe it crashes
18:54:43 <hpc> or never returns
18:54:52 <maerwald> Cale: sure they are contexts, just not in the way you just described it
18:55:16 <hpc> i guess the question would be "what's a context"
18:55:23 <scshunt> Cale: I think a better example is an exception
18:55:24 <maerwald> a category
18:55:44 <Cale> Comonads are closer to giving you "values in a context"
18:55:52 <hpc> and is that a commonplace enough definition that someone who doesn't know the concepts yet can derive some use from them
18:56:03 <maerwald> but that's so much nitpicking I don't think it's valid critique to an illustration that tries to help, which it does
18:57:02 <jonsey> I don't mind boxes or the word context. but it irks me that he calls getLine a function
18:57:31 <arahael> jonsey: it _is_ a function...
18:57:37 <hpc> it's an action
18:57:37 <jonsey>   no it isn't
18:57:47 <hpc> the only values that are functions are those with (->) at the root of their type
18:57:48 <jonsey> :t getLine
18:57:49 <lambdabot> IO String
18:58:07 <maerwald> now we can debate over how 'function' is defined... *sigh*
18:58:16 <hpc> (and calling it an action is even debatably useful)
18:58:24 <bitemyapp> hmm
18:58:50 <hpc> is it a debate? "function" has a precise definition
18:59:08 <arahael> it does depend on which semantics you mean.
19:00:26 <hpc> i guess we could actually dig into it and ask what the domain and codomain of getLine are
19:00:57 <hpc> then the codomain is String and the domain is your keyboard
19:01:18 <monochrom> that is a function but it is not getLine.
19:01:24 <hpc> but now you're not talking about a function in hask
19:02:44 <arahael> hpc: it's sufficient if you're _talking_ about programming though.
19:03:09 <arahael> hpc: even if the words you say aren't acceptable by the compiler.  english is loose, like that.
19:04:04 <arahael> also, i thought this was python, i forgot to read before i answered.  stupid.
19:04:16 <hpc> heh
19:04:31 <hpc> but yeah, between people who can follow the "you know what i mean" it's quite fine
19:05:16 <hpc> teaching requires a certain additional level of precision, as certain lies (or "untruths" or whatever) will lead you down the wrong conceptual path if you accept them
19:05:20 <maerwald> sometimes, less nitpicking is helpful too :P
19:05:30 <hpc> some lies are better than others
19:05:50 <hpc> and in haskell calling something a function that isn't can be very damaging given the significance of what a function is
19:06:22 <arahael> hpc: was it a problem in that context though?
19:06:31 <monochrom> I think it's unfair to unconditionally cry "nitpick" when other people critique your wording.
19:06:55 <maerwald> I don't think anyone did that unconditionally.
19:07:02 <hpc> arahael: the original mention was in a document teaching Monad, so yes
19:07:16 <hpc> ((->) e) is an instance of Monad
19:07:20 <hpc> IO is an entirely different one
19:08:05 <hpc> calling getLine a function muddles the idea of actual functions being actions as well
19:08:32 <maerwald> hpc: I think you're overrating the names here. It's about how people touch these things and interact with them on a programming level that will make them understand the differences. Not just words.
19:09:13 <arahael> hpc: in my mind, IO is all about functions/actions/tokens that, when evaluated, returns something that may have had a side effect.
19:10:11 <Cale> arahael: careful
19:10:21 <Cale> arahael: IO actions do nothing much when evaluated
19:10:34 <Cale> arahael: It's only when you *execute* them that they have effects
19:10:46 <maerwald> yeah, the haskell language doesn't actually define execution afair
19:10:51 <Cale> Try evaluating getLine `seq` ()
19:10:54 <arahael> Cale: are we going to have a debate as to what evaluation means, after debating "function"?
19:11:01 <hpc> ... yes
19:11:09 <maerwald> arahael: but this is actually an important difference :P
19:11:10 <Cale> Evaluation means reducing expressions to values
19:11:10 <hpc> evaluation vs execution is an even more important distinction
19:11:57 <arahael> maerwald: gah!  i'm out of here! :)
19:12:19 <Cale> The process of reducing an expression for an IO action to an IO action value, since IO is an abstract type, only has the visible effect of making your CPU a bit warmer.
19:12:36 <Cale> It very importantly *doesn't* cause the IO action to actually execute.
19:12:53 <Cale> (If it did, Haskell would be a horrifying mess)
19:13:04 <hpc> if it did, unsafePerformIO = unsafeCoerce
19:13:42 <Cale> seq would basically let you unsafePerformIO too :)
19:14:13 <arahael> Cale: you are right, of course.  in increasing order of precision: evaluated. evaluated by the IO monad. executed by the IO monad. executed by the program.
19:14:13 <hpc> :t evaluate -- i am too sleepy to think of what this would be
19:14:14 <lambdabot> a -> IO a
19:14:27 <maerwald> arahael: executed by the RTS
19:14:50 <maerwald> which is compiled into the binary
19:15:27 <arahael> maerwald: sure.
19:15:45 <arahael> back later :)
19:15:55 <maerwald> so technically, you wouldn't have any guarantee that executing your haskell code via a different compiler does even remotely the same thing
19:15:58 <monochrom> hpc: evaluate and unsafePerformIO would be the isomorphism between a and IO a
19:15:59 <Cale> You should think of IO actions as being descriptions of steps to be carried out by the runtime system. Even if GHC's real implementation is a bit hackier than this, you can imagine that somewhere there's a bit of code in the RTS which is pattern matching on IO actions, seeing which things they say to do, and then carrying those steps out.
19:16:02 <maerwald> which is a bit unsettling
19:16:43 <Cale> It's possible (though perhaps hard to make efficient) to have an implementation of Haskell in which IO is not an abstract type
19:17:28 <Cale> where you could directly pattern match on IO actions and take them apart to see what they would do if executed (though the binds would obscure things a bit unless you had values of the appropriate types to plug in)
19:17:39 <Cale> Or write an alternate executor
19:17:41 <hpc> as an aside, i wonder how silly it would be to have IO be a data family
19:18:01 <spion_> i always thought this is a pretty cool way to explain IO https://gist.github.com/tonymorris/b5dba9d7d877051d0164
19:18:04 <arahael> Cale: for me, learning about free monads was a gokd framework, though i know that the "real" IO isn't a free monad.
19:18:20 <Cale> Yeah, that's what I mean -- you can certainly picture it as being implemented by one
19:18:34 <maerwald> Cale: there's probably someone who has done pseudo-pattern matching on IO via PatternSynonyms and ViewPatterns and other GHC hacks? :P
19:18:40 <Cale> hah
19:18:45 <arahael> anyway, i am gone :) Back later...
19:19:57 <Cale> maerwald: You'd need to do some low-level shenanigans, because GHC implements IO via impure functions, so it's hard to know what you're looking at
19:20:14 <maerwald> don't give me any ideas :P
19:20:37 <maerwald> in the end it will end up in a library :/
19:21:16 <Cale> One thing that people have done is to implement free monads which try to capture various subsets of what IO can do (like all terminal I/O), which can then be either realised as actual IO, or simulated in a pure fashion.
19:24:17 <monochrom> I just wrote one that provides only putchar and getchar
19:24:19 <maerwald> Cale: yeah, sometimes I'd like the compiler to tell me that my non-network app is not going to do network communication... just because I'm paranoid :P
19:25:01 <maerwald> But that's too much work. And no real effect system.
19:25:41 <monochrom> then I had two putchar-getchar programs talk to each other. there is no outside effect. they talk in a closed world.
19:28:26 <fresheyeball> hey out there
19:28:39 <fresheyeball> I would really like help refactoring an ugly function
19:28:40 <fresheyeball> http://lpaste.net/160158
19:32:24 <maerwald> I'd say the problem already lies within the data structure that is too nested. Not sure if doing things with monadic functions will actually help or obfuscate it more.
19:44:04 <mgsloan> Is there a way to temporarily pin unpinned type arrays?  I basically want "withByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> (Addr -> m a) -> m a" such that the Addr is valid during the inner action
19:44:11 <slack1256> Hi guys, I got a question about network's inet_ntoa function. I know it just a wrapper around the C version
19:45:09 <slack1256> But should `inet_ntoa 3232235813 >>= print` return 37.1.168.192?
19:45:59 <slack1256> I know about network byte order, but it seems it reorder wrongly or I should not have to use the dotted representation?
19:50:53 <geekosaur> how do you figure "reorder wrongly"?
19:51:13 <geekosaur> Prelude Network.Socket> inet_addr "192.168.1.37"      ==> 620865728
19:52:47 <Xnuk> @hoogle t (m a) -> m (t a)
19:52:49 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
19:52:50 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
19:52:50 <lambdabot> Test.QuickCheck.Gen.Unsafe promote :: Monad m => m (Gen a) -> Gen (m a)
19:54:37 <Xnuk> I often forget the function's name
19:54:39 <tdchayes> @hoogle [a]->Int
19:54:40 <lambdabot> Prelude length :: [a] -> Int
19:54:40 <lambdabot> Data.List length :: [a] -> Int
19:54:40 <lambdabot> Prelude head :: [a] -> a
19:55:35 <geekosaur> also: showHex 3232235813 ""      ==> "c0a80125"
20:09:06 <Gurkenglas__> fresheyeball, what's err? An alias for error?
20:11:30 <Gurkenglas__> fresheyeball, here's a refactoring assuming err is error: http://lpaste.net/160158#a160159
20:12:16 <Gurkenglas> (Even without that, you could have pulled the Right out of line 10 into line 6)
20:14:27 <lpaste> Gurkenglas revised “fresheyeball, here's a refactoring assuming err is error”: “No title” at http://lpaste.net/160159
20:14:41 <Gurkenglas> (missed one return - here's a fixed version)
20:17:20 <lpaste> Gurkenglas annotated “No title” with “And then of course you make it pointfree :P” at http://lpaste.net/160158#a160161
20:33:10 <yiqiao> a
20:37:36 <slack1256> now it making me wonder if the server is sending info backwards
20:37:41 <slack1256> *it's
20:57:25 <Big_G> Is there any difference to an infix on which side I put an argument if I want to partially apply it? i.e. (+1) vs (1+)
20:58:07 <mniip> yes
20:58:14 <mniip> > (/2) 10
20:58:16 <lambdabot>  5.0
20:58:18 <mniip> > (2/) 10
20:58:19 <lambdabot>  0.2
21:00:27 <ntnt> http://shaffner.us/cs/papers/tarpit.pdf <-- has anyone implemented this in haskell yet?
21:06:40 <slack1256> that is that paper about a database right?
21:07:00 <ntnt> no, in fact, it pretty strongly states that relational and db are orthogonal
21:26:33 <angerman> When using aeson to turn a json into a datastrucutre, the error messages are not very helpful. I understand that this is due to the performance considerations. Yet I wonder if one could not do a fast pass parse with aeson, and if that fails try to parse again but with a parser that has better error reporting?
21:30:27 <pavonia> angerman: Have you tried the aeson-better-errors package?
21:30:29 <ntnt> without using GHCI, is there a way to see the output of TH?
21:30:51 <ntnt> is there a way to tell cabal "put the TH output of Foo.hs at Foo.postTH.hs" ?
21:30:53 <angerman> pavonia, no. Let me check that out.
21:33:02 <angerman> pavonia ok, that's probably a good tool when starting afresh.
21:34:37 <slack1256> ntnt: -ddump-splices
21:43:57 <ntnt> did https://ghc.haskell.org/trac/ghc/ticket/8624 ever get implemented?
21:43:59 <ntnt> it's basically what I want
21:44:08 <ntnt> a Foo.th.hs of a Foo.hs.th for each Foo.hs that uses TH
21:46:42 <__uu___> hi, could someone plain the following result for me in steps?
21:46:50 <__uu___> raverse id [[0,1],[1,2]]
21:46:51 <__uu___> [[0,1],[0,2],[1,1],[1,2]]
21:47:21 <__uu___> s/raverse/traverse 
21:48:09 <__uu___> how did I reach [[0,1],[0,2],[1,1],[1,2]]?
21:49:01 <Cale> ntnt: Yes, it was merged into 7.10
21:49:14 <ntnt> Cale: how od I use it?
21:49:21 <ntnt> ghc is tleling me "unrecognized lag: -th-file"
21:49:26 <ntnt> when I use "ghc -ddump-splices -th-file"
21:49:26 <athan> __uu___: Wut
21:49:40 <athan> ntnt: Note the two dashes :)
21:49:45 <athan> I think :S
21:50:18 <__uu___> athan: I did not grasp how "traverse id" works 
21:50:37 <athan> ahhh okay
21:50:41 <ntnt> athan: https://gist.github.com/anonymous/5f5b1a57cc9f9ed2d6dfe74d53d361ed
21:50:43 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html#th-view-gen-code
21:50:46 <ntnt> athan , Cale: https://gist.github.com/anonymous/5f5b1a57cc9f9ed2d6dfe74d53d361ed
21:50:59 <athan> __uu___: The instance for lists is nondeterminism
21:51:07 <Cale> The flag -dth-dec-file shows the expansions of all top-level TH declaration splices, both typed and untyped, in the file M.th.hs where M is the name of the module being compiled.
21:51:14 <__uu___> instance Traversable [] where
21:51:15 <__uu___>     traverse _ []     = pure []
21:51:15 <__uu___>     traverse f (x:xs) = (:) <$> f x <*> traverse f xs
21:51:23 <ntnt> Cale: ah, thanks!
21:51:26 <athan> so this is basically `sequenceA`
21:52:15 <athan> I might be wrong here
21:52:20 <athan> sorry I just can't think hard right now
21:53:19 <Cale> You're right here, traverse id is the same thing as sequenceA
21:53:21 <__uu___> for traverse id [[0,1],[1,2]], (:)<$> id  [0,1] <*> traverse id [[1,2]] => (:) <$> id [0,1] <*> [[1],[2]], and then ?
21:53:26 <athan> > sequence [[0,1],[1,2]]
21:53:28 <lambdabot>  [[0,1],[0,2],[1,1],[1,2]]
21:53:41 <__uu___> sequenceA = traverse id
21:54:05 <athan> note the size of the outer list
21:54:09 <__uu___> :t id
21:54:11 <lambdabot> a -> a
21:54:18 <athan> > sequence [[0,1],[1,2],[2,3]]
21:54:19 <lambdabot>  [[0,1,2],[0,1,3],[0,2,2],[0,2,3],[1,1,2],[1,1,3],[1,2,2],[1,2,3]]
21:54:22 <Cale> __uu___: First evaluate (:) <$> [0,1]
21:54:26 <nshepperd> __uu___: right, you can do this, you just need the definition of Traversable [] and Applicative []
21:54:35 <Cale> It's simply [(0:), (1:)], right?
21:54:38 <athan> that's why you still retain lists of size 2
21:55:15 <Cale> and then you have [(0:), (1:)] <*> [[1], [2]], and fs <*> xs = [f x | f <- fs, x <- xs]
21:55:27 <__uu___> Cale: then [(0:), (1:)] <*> [[1],[2]]
21:55:35 <__uu___> aha!!
21:55:40 <__uu___> it is list !!
21:55:49 <__uu___> I am thinking of ZipList!!
21:56:19 <__uu___> s/am/was
21:56:44 <athan> > sequence $ ZipList [[0,1],[1,2]]
21:56:46 <lambdabot>      Could not deduce (Traversable ZipList)
21:56:46 <lambdabot>        arising from a use of ‘sequence’
21:56:46 <lambdabot>      from the context (Num a)
21:56:51 <athan> herpszi
21:57:02 <athan> > sequence [ZipList [0,1], ZipList[1,2]]
21:57:03 <lambdabot>      Could not deduce (Monad ZipList) arising from a use of ‘sequence’
21:57:03 <lambdabot>      from the context (Num a)
21:57:03 <lambdabot>        bound by the inferred type of it :: Num a => ZipList [a]
21:57:12 <athan> derpsizzurp
21:57:16 <athan> > sequenceA [ZipList [0,1], ZipList[1,2]]
21:57:18 <lambdabot>  ZipList {getZipList = [[0,1],[1,2]]}
21:57:29 <athan> untiss untisss untisss
22:01:31 <__uu___> now I can understand traverse (\x -> [0..x]) [0..3]
22:02:27 <__uu___> thank you all
22:14:30 <mniip> > traverse (enumFrom 0) [1,4,3,0]
22:14:31 <lambdabot>      Couldn't match expected type ‘Integer -> f b’
22:14:31 <lambdabot>                  with actual type ‘[Integer]’
22:14:31 <lambdabot>      Possible cause: ‘enumFrom’ is applied to too many arguments
22:14:38 <mniip> > traverse (enumFromTo 0) [1,4,3,0]
22:14:39 <lambdabot>  [[0,0,0,0],[0,0,1,0],[0,0,2,0],[0,0,3,0],[0,1,0,0],[0,1,1,0],[0,1,2,0],[0,1,...
22:14:41 <mniip> ooh
22:56:04 <broma0> If i have a type T with lenses "Lens' T a" "Lens' T b" into it, can i write a "Traversal T (a, b)"?
22:56:57 <broma0> that is, can i specify my traversal's targets using other lenses into some structure, and then wrap up the targets into a tuple?
23:09:19 <ntnt> suppose I want TH to output "data Foo = { foo :: Int }", I need it to be a "Q Something" , where Something != EXP
23:09:23 <ntnt> what should the Something be instead?
23:11:05 <ntnt> Q Dec, according to https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH.html#t:Dec
23:15:46 <ntnt> https://gist.github.com/anonymous/1d486df4996a3f400f37231d2f38e897 <- please help -- template haskell problem with varaibles being 'renamed' to 'avoid collisions'
23:16:42 <Cale> ntnt: You could use mkName
23:17:32 <ntnt> Cale: https://gist.github.com/anonymous/36fdb952f2f01ca270e4642885515bbd <-- something like that?
23:17:38 <ntnt> I'd prefer to not have to 'build stuff up manually)
23:18:07 <Cale> Well, what's the real goal? How are you building the type?
23:19:25 <ntnt> at the moment, just learn how to do basic things in TH
23:19:36 <ntnt> I would like to use TH to define a "data Foo = Foo { foo :: Int } "
23:19:56 <ntnt> but it appears that my attempt generates "data Foo_UniqueId = Foo_UniqueId { foo_uniqueId2 :: Int }"
23:19:58 <Cale> Yeah, but think about that for a moment -- you'd never want to use TH to define a type which was always the same
23:20:36 <Cale> You wouldn't need to put that type in a splice then, you could just declare it straightforwardly
23:20:54 <ntnt> okay, let me rephrase
23:21:09 <ntnt> let me rephrase this XY question into what I really truly want
23:25:25 <ntnt> Cale: https://gist.github.com/anonymous/ff4710d28fd16d83c2cf1a6f43634f28 <-- I want to implement genSTuff
23:25:56 <ntnt> it takes a type (Value), and some functions of the form Value -> ... and creates a new data structure which (1) has a store for the Value, and (2) creates indices for the maps (which are sorta like primary keys)
23:27:46 <Cale> So you're going to have to construct the list of arguments to the constructor directly anyway
23:28:45 <ntnt> hmm, good call
23:28:53 <ntnt> I was hoping sorta like lisp quasiquoting
23:28:58 <ntnt> where you setup a general template,
23:29:03 <ntnt>  then you just fill in the details as necessary
23:29:11 <Cale> Well, yeah, it is sort of like that, except you can't really use that here
23:29:32 <Cale> It's valid to have splices inside a declaration quote
23:29:34 <ntnt> maybe I should learn how to do it the hardway (from pure AST) rather than trying to be clever
23:29:41 <ntnt> go ahead
23:29:46 <ntnt> if you have time, explain to me why this can't be done
23:31:22 <Cale> But in this case, it doesn't help because "record fields" isn't a splice type -- only expressions, patterns, types, and lists of declarations are
23:35:44 <ntnt> Cale: thanks! this was rather helpful in pruning the 'search tree' of 'potential things try next'; it's rather clear that I should build this 'manually' now
23:39:10 <random> hi, why is this not valid?
23:39:11 <random> [\x->(x`mod`2, round $ x / 2 :: Int)] <*> [0..3] :: [(Int,Int)]
23:39:46 <pavonia> > [\x->(x`mod`2, round $ x / 2 :: Int)] <*> [0..3] :: [(Int,Int)]
23:39:47 <lambdabot>      No instance for (RealFrac Int) arising from a use of ‘round’
23:39:47 <lambdabot>      In the expression: round
23:39:47 <lambdabot>      In the expression: round $ x / 2 :: Int
23:40:05 <Cale> random: There's no type for which x `mod` 2 and x / 2 simultaneously make sense
23:40:17 <Cale> Perhaps you want x `div` 2
23:40:58 <Cale> (which does integer division in a way that corresponds with mod as the remainder)
23:41:06 <random> Cale: thanks! it works
23:41:15 <liste> t
23:41:20 <liste> :t divMod -- there's also this
23:41:22 <lambdabot> Integral a => a -> a -> (a, a)
23:41:33 <liste> > 11 `divMod` 2
23:41:35 <lambdabot>  (5,1)
23:41:58 <liste> > [divMod] <*> [0..3]
23:42:00 <lambdabot>  [<Integer -> (Integer,Integer)>,<Integer -> (Integer,Integer)>,<Integer -> (...
23:42:11 <Cale> careful though, that swaps the components of the pair
23:42:59 <Cale> > [(`divMod` 2)] <*> [0..3]
23:43:01 <lambdabot>  [(0,0),(0,1),(1,0),(1,1)]
23:43:13 <random> Cale: interesting. thanks for that tip
23:47:07 <Cale> > [(`divMod` 5),(`quotRem` 5)] <*> [-10 .. 10]
23:47:08 <lambdabot>  [(-2,0),(-2,1),(-2,2),(-2,3),(-2,4),(-1,0),(-1,1),(-1,2),(-1,3),(-1,4),(0,0)...
23:47:48 <ntnt> Cale: https://gist.github.com/bab4af4f09735acb4f2ee9ac53cae6b4 <-- how do I print out what the [d| ... |] look like?
23:48:07 <ntnt> I'm trying to 'reverse engineer' what I need to build, but that [d| ... |] is stuck in a Q Monad, so it's not clear to me how to print it
23:49:02 <Job316> can you not do infix lambdas? like `\x->x+1` 1 doesn't work. why?
23:50:15 <pavonia> The language doesn't support it
23:51:08 <ntnt> don't let other ppl's opinion stop you
23:51:09 <ntnt> use TH
23:51:19 <ntnt> (I'm kidding) :-)
23:51:30 <Job316> template could do crazy stuff like that?
23:52:30 <pavonia> Job316: You will run into parsing problems with that, e.g. what would `\x -> x `f`1` parse to?
23:53:24 <Job316> confusion, probably
23:53:34 <Cale> main = print $(lift . show =<< [d| data Foo = Foo |])
23:53:50 <Cale> ntnt: You'll have to import Language.Haskell.TH.Syntax
23:54:07 <ntnt> done
23:54:09 <Cale> lift :: (Lift t) => t -> Q Exp
23:54:31 <ntnt> that doesn't look like the type I want, [d| ... |] gives me a Q [Dec]
23:54:36 <ntnt> I need to somehow get t he [Dec
23:54:43 <ntnt>  ] out so I can call show on it
23:54:57 <Cale> That's what the =<< is doing
23:55:24 <ntnt> oh, Q is bigger than IO ?
23:55:35 <Cale> bigger than?
23:55:40 <Cale> Well it is, actually
23:55:49 <ntnt> so I do a runQ $ do x <- [d| ... |]; print x
23:55:55 <mniip> Q and IO intersect actually
23:55:59 <Cale> runIO :: IO a -> Q a
23:56:06 <mniip> not all IO actions can be embedded in Q
23:56:07 <Cale> But you don't need to do that
23:56:15 <Cale> Did you notice my example?
23:56:21 <Cale> main = print $(lift . show =<< [d| data Foo = Foo |])
23:56:21 <ntnt> no, your example?
23:56:22 <ntnt> where?
23:56:27 <ntnt> I'm an idiot
23:56:29 <ntnt> I didn't see that line
23:56:34 <ntnt> let me try that first
23:57:03 <Cale> the show instance is a little funny
23:57:22 <Cale> It doesn't quote names
23:57:45 <Cale> So what it emits is not *quite* valid
23:57:56 <Cale> but it's close
23:59:27 <ntnt> Cale: https://gist.github.com/anonymous/9bbb0465b6cacc5bb530d3e9c726a1d2 gives error: https://gist.github.com/anonymous/26be29d1b9cad40fd5567cb93a84e817
23:59:51 <lpaste> Cale pasted “my file” at http://lpaste.net/160173
