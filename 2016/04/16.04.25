00:01:18 <cocreature> MichaelBurge: I don’t think so, if you have an example I can take a look. maybe I’ll spot the error
00:02:54 <MichaelBurge> cocreature: http://lpaste.net/161370
00:03:14 <MichaelBurge> Network/AuthorizeNet/TH.hs:77:22: Parse error in pattern: $outerPattern
00:04:23 <MichaelBurge> cocreature: I'm thinking maybe you can't splice part of a pattern; you have to do an entire pattern
00:04:43 <cocreature> you are trying to assign to restrictsDec the result of a quasiquoter that gets an instance
00:04:51 <cocreature> what is that supposed to do?
00:05:10 <akegalj> hey. What is the name of ghc extension that makes some type variable (in top level function definition) visible/binded in type definition inside the functions ?
00:05:24 <cocreature> akegalj: sounds like ScopedTypeVariables
00:05:36 <akegalj> cocreature: thanks, will check that
00:05:53 <MichaelBurge> cocreature: You're right, I should probably throw a 'sequence [restrictsDec, schemaTypeDec, simpleTypeDec]' at the end, since it isn't as-is without an ending
00:06:14 <MichaelBurge> I don't think that affects this particular error though
00:06:37 <hackrilege> hmm i still cant figure out that forall syntax
00:07:21 <hackrilege> instance forall s a . Stack s => Stack (Compose s s) where
00:07:39 * hackagebot vcatt 0.1 - Recursively check that a directory is under version control.  https://hackage.haskell.org/package/vcatt-0.1 (bergey)
00:07:39 * hackagebot turtle 1.2.7 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.2.7 (GabrielGonzalez)
00:07:51 <hackrilege> im trying to use a inside because it complains about 'a' not rectifying to 'a1'
00:08:14 <MichaelBurge> cocreature: Same error with a sequence.
00:08:30 <MichaelBurge> I'll try splicing the entire pattern, but it'd be nice if there was a way to figure out the parse error without guessing
00:08:57 <hackrilege> http://lpaste.net/161372
00:09:07 <hackrilege> heres a paste with the error at the bottom
00:11:41 <MichaelBurge> hackrilege:  I wonder if your forall binds any kind, rather than just kinds *.
00:11:51 <MichaelBurge> hackrilege: I'd have to look at the syntax, but is there a way to limit a to the kind *?
00:12:34 * hackagebot hmatrix-banded 0.0.0.1 - HMatrix interface to LAPACK functions for banded matrices  https://hackage.haskell.org/package/hmatrix-banded-0.0.0.1 (HenningThielemann)
00:13:15 <MichaelBurge> hackrilege: Maybe 'forall (s :: *) (a :: *)' on line 156?
00:16:54 <hackrilege> then it just complains that s (s a) /= s (s a1
00:16:56 <hackrilege> )
00:17:29 <hackrilege> with 'forall (s :: * -> *(a :: *)
00:17:34 * hackagebot relational-record 0.1.4.0 - Meta package of Relational Record  https://hackage.haskell.org/package/relational-record-0.1.4.0 (KeiHibino)
00:17:43 <hackrilege> ad thats the error i was trying to resolve by adding the forall to fix the a
00:18:25 <cocreature> MichaelBurge: hm sry, apart from splicing the entire pattern I don’t have any idea
00:19:56 <MichaelBurge> hackrilege: I've had success using the 'asTypeOf' function to force GHC to declare two type variables equal
00:20:30 <hackrilege> hmm
00:20:31 <hackrilege> thanks
00:21:08 <hackrilege> also, all my instances of eg Stack s => Functor (Compose s s) where
00:21:22 <hackrilege> are overlapping if i turn off crazy language pragmas
00:21:29 <ski> hackrilege : `a' can't be bound in the class head
00:21:45 <hackrilege> ahhh
00:21:46 <hackrilege> ok
00:21:49 <hackrilege> !!!
00:21:54 <hackrilege> then how do i fix this?
00:22:08 <ski> perhaps try adding an explicit type signature for `out'
00:22:25 <ntnt_> I can implement callCC from scratch; I can see how the type sig works; I still can't explain in a single sentence *why* the type sig makes sense
00:22:39 <ski> hm, no. for `pull'
00:22:49 * hackagebot hmatrix-banded 0.0.0.2 - HMatrix interface to LAPACK functions for banded matrices  https://hackage.haskell.org/package/hmatrix-banded-0.0.0.2 (HenningThielemann)
00:24:18 <ski> anyway, `pull' is what should be polymorphic in `a', (but not `s')
00:24:42 <hackrilege> but a is bound in the class
00:24:52 <hackrilege> so should i put my forall there?
00:25:00 <ski> `a' is not bound in the class head
00:25:12 <ski> `a' is bound in the type signature for `pull'
00:25:14 <hackrilege> hmmm
00:25:27 <hackrilege> in the class head...
00:25:42 <ski> (and also, additionaly, in the other method type signatures?
00:25:52 <hackrilege> oh yeah
00:25:56 <ski> s/?/)/
00:26:08 <hackrilege> but i cant put forall statements their!
00:26:25 <ski> your `push :: a -> s a -> s a' in the class declaration amounts to `push :: forall a. a -> s a -> s a'
00:26:54 <hackrilege> right
00:27:06 <ski> so, if you add an explicit `push :: forall a. a -> Compose s s a -> Compose s s a' in the instance declaration, perhaps that'd help ?
00:27:18 <ski> (also with `ScopedTypeVariables', of course)
00:28:13 <MichaelBurge> ntnt_: callCC takes an action that depends on an 'exit' action to escape the context, and runs it while implementing its 'exit' action.
00:28:45 <ski> er, sorry. i'm reading it wrong. you want it for `pull', not `push'
00:29:02 <ski> MichaelBurge : can be used not only to exit
00:29:32 <ski> (but also to make the action finish more than once)
00:30:24 <ski> hackrilege : i.e., try `pull :: forall a. Compose s s a -> Maybe (a,Compose s s a)' there ?
00:31:09 <ski> hm, so `ssa :: s (s a)' (as you already know)
00:32:56 <hackrilege> awesome that got it working
00:33:36 <hackrilege> whatever working means in this context
00:33:46 <ski> also, you shouldn't use `fromJust' here
00:34:04 <hackrilege> lol yeah
00:34:08 <ski> but probably you only tried with `fromJust' to understand how to get the types right, yes ?
00:34:13 <hackrilege> yes
00:34:20 * ski nods
00:34:21 <hackrilege> and i had forgot
00:34:22 <MichaelBurge> cocreature: Yeah, that was the problem. If you look at the definition of ConP: 'ConP Name [Pat]', I was binding 'ConP name' and leaving the [Pat] outside of the splice.
00:34:42 <ski> anyway, i'm not sure you need to annotate this with type variables at all
00:34:51 <ski> (as long as the code is right)
00:35:07 <hackrilege> it was definitely complaining
00:35:44 <hackrilege> btw what do you think of that implementation of pull?
00:35:47 <hackrilege> seems mad to me
00:35:53 <hackrilege> only one available...
00:36:53 <hackrilege> i wonder what it will do. seems to be turning the stack into something that can be inserted and removed from in the middle which is good.
00:37:36 <ski>   pull (Compose ssa) = do (sa,ssa) <- pull ssa
00:37:39 <ski>                           (a,sa) <- pull sa
00:37:43 <ski>                           Just (a,push sa ssa)
00:37:48 <hackrilege> oh thanks
00:37:53 <ski> i think
00:38:17 <hackrilege> im so tired of this damn error handling with Maybe
00:38:38 <ski> so, you're grabbing the first stack from the stack of stacks, then grabbing the first element off that stack. then pushing the remainder stack back on top of the stack of stacks
00:39:01 <ski> using `Maybe' as a monad here helps with not having to deal with propagating the `Nothing's
00:39:22 <ski> (if you prefer, you could say `return' instead of `Just')
00:41:11 <ski> hmm
00:41:32 <ski> actually .. in case the first stack is empty, perhaps we should try looking into the later stack ?
00:41:45 <ski> i'm not sure, but it's a possible alternative
00:41:54 <hackrilege> problem is more with push actually
00:41:58 <hackrilege> via <|>
00:41:59 <ski> s/later stack/later stacks/
00:42:09 <hackrilege> dont know how to make it grow in a new stack
00:42:17 <hackrilege> see what i mean?
00:42:28 <Lovepon> Hmmmm
00:42:59 <ski> why would `(<|>)' "make it grow in a new stack" ?
00:43:00 <hackrilege> i imagine this will get more sever as it gets extended to n dimensions
00:43:16 <hackrilege> :t (<|>)
00:43:17 <lambdabot> Alternative f => f a -> f a -> f a
00:43:22 <hackrilege> :t (++)
00:43:23 <lambdabot> [a] -> [a] -> [a]
00:44:03 <hackrilege> but in this context of Zipable z => z [[]] a
00:44:05 <ski> hm, actually you have an `Alternative' instance for `Compose' (apparently intended for stacks) .. but it's empty
00:44:26 <hackrilege> yeah thats why i was considering this problem!
00:45:19 * ski isn't sure what all this code is about
00:45:26 <hackrilege> for Compose [] [] a, which is acting like [[a]], i can just add elements (push is like (:)) to the head of the first list
00:45:36 <hackrilege> i cant chose to start a new list
00:45:40 <hackrilege> choose*
00:45:54 <ski> perhaps a different combinator should start a new stack
00:46:32 <hackrilege> but then i need infinitly many when i go to n dimensions
00:46:37 <hackrilege> !!
00:47:01 <hackrilege> seems reasonable...
00:47:16 <hackrilege> though daunting
00:48:16 <hackrilege> infact basically thats the equivilant problem to using an upside down tree as your zipper and worrying about which branch to grow instead of growing from the top
00:48:44 <hackrilege> need a way of indicating the constructor acting as (:)
00:48:55 <hackrilege> when many growth sites exist
00:49:25 <hackrilege> this is the function choose in Unforldr
00:49:51 <dsm> is thare a function which extracts third element of tuple?
00:49:55 <hackrilege> Unfolder* https://hackage.haskell.org/package/unfoldable-0.8.3/docs/Data-Unfolder.html
00:50:21 <ski> @type \(_,_,z) -> z
00:50:23 <lambdabot> (t, t1, t2) -> t2
00:57:14 <Tangerine> what is an eta reduce?
00:58:33 * hackagebot monad-log 0.1.0.0 - A simple and fast logging monad  https://hackage.haskell.org/package/monad-log-0.1.0.0 (winterland)
00:58:34 <ggole> eta transformations go between \x -> f x <=> f
01:02:32 <Tangerine> so I'm just doing a reduce
01:02:51 <Tangerine> why am I getting a hint from sublimerelp to do an eta reduce?
01:03:14 <Tangerine> fromList :: Ord a => [a] -> Heap a
01:03:23 <Tangerine> fromList n = foldr insert empty n
01:04:01 <ski> well, it means that you can "cancel" the two `n's
01:04:05 <ski> because that's the same as
01:04:13 <ski>   fromList = \n -> foldr insert empty n
01:04:20 <ski> which by eta would correspond to
01:04:24 <ski>   fromList = foldr insert empty
01:04:41 <Tangerine> oh so I can just write
01:04:45 <Tangerine> fromList = foldr insert empty
01:04:49 <ski> yep
01:04:53 <Tangerine> ahh i see
01:04:59 <MichaelBurge> How does the old Haskell maxim "If it compiles, then it works" interact with Template Haskell? Do we only count compilation of the TH module, or the entire package?
01:05:47 <Tangerine> say I have a recursively defined structure such as a tree
01:05:54 <ski> MichaelBurge : unfortunately not as much, aiui, because TH type-checking doesn't mean that the code it generates withh type-check (unlike e.g. MetaML/MetaOCaml)
01:06:03 <Tangerine> how would I check if the value of a node is smaller than the value of its children?
01:06:15 <Tangerine> do I need to pattern match something like
01:06:26 <ski> of its direct children, or of all its children ?
01:06:41 <ski> (well, descendants, if you prefer)
01:07:00 <Tangerine> well I want to test that it is a minheap
01:07:12 <Tangerine> so I would need to check all of their descendants later on too
01:07:22 <Tangerine> would I do something like
01:07:36 <ski> yes, but by transitivity, you only need to check the direct ones
01:07:47 <Tangerine> yup
01:07:51 <Tangerine> do I need to do my pattern matching as
01:07:52 <ski> (otherwise it's doing needless work)
01:07:52 <Tangerine> isHeap n@(v (v1 l1 r1) (v2 l2 r2)) for my pattern matching?
01:08:04 <Tangerine> then check 
01:08:27 <ski> i don't know how your tree data type looks like
01:08:38 <Tangerine> lets say tree is
01:09:09 <Tangerine> data Tree a = Leaf | Node a (Tree a) (Tree a) 
01:09:36 <ski>   isHeap (Node a l r) = ... && isHeap l && isHeap r
01:09:38 <ski> i'd imagine
01:10:15 <ski> well, you're right that we need to access the top element of the children, if any, in some way
01:10:16 <Tangerine> ski: yes, but I also need to check that the value is greater than it's direct children's value
01:10:21 <ski> pondering the nicest way to do this ..
01:10:25 <Tangerine> yeah, I guess what I'm trying to say is
01:10:37 <Tangerine> is there any nice way to do this other than a really long pattern matching that includes children?
01:10:40 <ski> do you have a `minElement :: Tree a -> Maybe a' ?
01:10:48 <Tangerine> oh yes I do
01:10:53 <Tangerine> I should just use that huh
01:11:19 <ski> isHeap (Node a l r) = (all (\x -> ..a..x..) [x | Just x <- minElement [l,r]]) && ...
01:11:22 <ski> i think would work
01:11:48 <ski> or, perhaps nicer to put the check inside the list comprehension, and use `and' instead
01:11:54 <ski> (also, redundant brackets)
01:12:42 <ski> the match in the list comprehension will just drop the subtrees which don't have a min element
01:12:46 <ski> (iow are empty)
01:13:14 <ski> you could use `@' instead, but then you get four different cases here, which is tedious
01:13:18 <Tangerine> can I do pattern matching here?
01:13:22 <ski> where ?
01:13:42 <Tangerine> isValid n@(v l r) | v < findMin(r), v < findMin(l), isValid(r), isValid(l) = True
01:13:53 <Tangerine> and then isValid _ = False
01:14:43 <ski> writing guards like that is like writing `if ... then True else False'
01:15:01 <ski> (which can be shortened to just `...', by eta on `Bool')
01:15:35 <ski> instead put the whole boolean condition in the definiens
01:15:48 <ski>   isValid n@(v l r) = ...
01:16:27 <Tangerine> oh I'm missing the constructor. Oops
01:16:45 <ski> (yes, i figured this was meant as pseudo-code :)
01:17:01 <ski> also, `findMin r', not `findMin(r)' :)
01:17:15 <Tangerine> oh right haha. I'm so used to imperative code 
01:17:55 <hackrilege> ok, fwiw, i think not being able to choose to start growing a new sublist is the same as not being able to choose not to grow a new sublist so ill do that
01:18:11 <hackrilege> unless thats just as bad
01:18:12 <hackrilege> ...
01:18:28 <Tangerine> I didn't understand exactly what "isHeap (Node a l r) = (all (\x -> ..a..x..) [x | Just x <- minElement [l,r]]) && ..." means (mostly confused about the .'s
01:18:49 <Tangerine> so the first part before the = is just the pattern matching
01:20:06 <Tangerine> and I'm guessing all is a function that is basically a mini map reduce where reduce is the & and the map is the first thing
01:20:10 <ski> the `..a..x..' and `...' are just parts for you to fill in
01:20:14 <ski> "holes" if you will
01:20:37 <Tangerine> ahh
01:20:44 <ski>   all :: (a -> Bool) -> [a] -> Bool
01:20:53 <ski> > all even [2,4,8]
01:20:56 <lambdabot>  True
01:20:57 <ski> > all even [1,2,4,8]
01:20:59 <lambdabot>  False
01:21:01 <ski> > all even []
01:21:02 <lambdabot>  True
01:21:06 <ski> there's also `any'
01:21:24 <ski> > any even [2,4,8]
01:21:27 <lambdabot>  True
01:21:28 <ski> > any even [1,2,4,8]
01:21:30 <lambdabot>  True
01:21:30 <ski> > any even []
01:21:32 <lambdabot>  False
01:21:39 <Tangerine> what exactly does Just do?
01:21:53 <ski> wraps an `a' into a `Maybe a'
01:22:10 <ski> in this case, we're extracting an `a' out of the `Maybe a' returned by `findMin'
01:22:24 <ski> (since we're pattern-matching on the pattern `Just x')
01:22:48 <Tangerine> oooh, since the function technically outputs a Maybe
01:22:56 <ski> er, also the list comprehension there isn't quite right
01:23:11 <ski> it should be `Just x <- map minElement [l,r]'
01:23:33 <ski> or `t <- [l,r],Just x <- [minElement t]'
01:23:46 <ski> where `minElement' is your `findMin' afaiu
01:24:46 <ski> Tangerine : i'm not sure if "technically" there is needed. it simply outputs a `Maybe a' :)
01:25:22 <ski> you can *think* of this as either possibly outputting an `a', or otherwise terminating without any `a'
01:25:36 <ski> but that's an interpretation, a viewpoint
01:27:43 <Tangerine> any reason to use an All here when there are only two cases to consider?
01:27:56 <orion> Is there any real difference between pattern matching on [foo] and (foo : _)?
01:28:10 <lyxia> orion: foo : _ can have more elements in _
01:28:14 <ski> yes. you want to check both subtrees have a min element greater than `a'
01:28:29 <lyxia> orion: [foo] is strictly a list of length 1
01:28:34 <ski> you don't want to check that there is *some* subtree with a min element greater than `a'
01:28:47 <orion> lyxia: Ah, thanks
01:28:54 <ski> so, `all' corresponds to wanting to use `&&' between the conditions for the two subtrees
01:29:06 <ski> @src all
01:29:06 <lambdabot> all p = and . map p
01:29:07 <ski> @src and
01:29:07 <lambdabot> and = foldr (&&) True
01:29:18 <ski> there's the `&&' inside `all'
01:29:22 <Tangerine> ski: can't I just use '&&' here since it's only two cases?
01:29:37 <ski> Tangerine : well, you have at *most* two cases
01:29:56 <Tangerine> does Haskell's && not have early termination like it does in other languages?
01:29:56 <ski> so, then you'd have to enumerate all the four different possibilities, which is tedious
01:30:01 <ski> it does
01:30:07 <Tangerine> wait but
01:30:18 <Tangerine> if one of them is false, I don't need to enumerate other possibilities do I?
01:30:30 <Tangerine> > True && False
01:30:34 <lambdabot>  mueval-core: Time limit exceeded
01:30:45 <Tangerine> wait is that not a thing >.>
01:30:55 <ski> the first one that fails will short-circuit the evaluation of `all' so that the remaining one (if any) won't be checked
01:31:02 <ski> > True && False
01:31:06 <lambdabot>  mueval-core: Time limit exceeded
01:31:10 <ski> @botsmack
01:31:10 <lambdabot> :)
01:31:12 <Gurkenglas> Works in query.
01:31:43 <hexagoxel> > True && False
01:31:45 <lambdabot>  False
01:31:59 <ski> hexagoxel had the auspicies
01:33:58 <Tangerine> ski: there isn't any "if anys" that I think is necessary here, and if I was worried about that wouldn't I just put the "if any"s in the front
01:35:05 <ski> the list comprehension will take care of generating the list of direct children elements, if any
01:35:31 <ski> it could be that both `l' and `r' have a (top/min) element
01:35:37 <ski> or that only `l' does
01:35:38 <Kwoth> Hello, I'm stuck again. http://lpaste.net/161377 I'm trying to do second question on https://wiki.haskell.org/99_questions/1_to_10 , can someone just explain to me what am i doing wrong here. I'm just starting out sorry
01:35:40 <ski> or only `r'
01:35:42 <ski> or neither
01:36:00 <ski> the list comprehension will correspondingly generate a list of two, one, one, or zero elements
01:36:09 <ski> which then `all' will check against `a'
01:36:15 <ski> Tangerine : clear ?
01:36:48 <lyxia> Kwoth: n has type a but you're using it as a number
01:37:00 <ski> Kwoth : the middle `a' in `elementAt :: [a] -> a -> a' is wrong
01:37:04 <Tangerine> so otherwise, if there is anothing, I can't actually do the getMin?
01:37:10 <Tangerine> > 10 > Nothing
01:37:13 <lambdabot>      No instance for (Num (Maybe a0)) arising from the literal ‘10’
01:37:13 <lambdabot>      In the first argument of ‘(>)’, namely ‘10’
01:37:13 <lambdabot>      In the expression: 10 > Nothing    No instance for (Ord a0) arising from...
01:37:24 <ski> Tangerine : the list comprehension will filter away the `Nothings'
01:37:28 <ski> witness :
01:37:42 <ski> > [x | Just x <- [Just 3,7]]
01:37:44 <lambdabot>      No instance for (Show t0)
01:37:44 <lambdabot>        arising from a use of ‘show_M130076589850951046925557’
01:37:44 <lambdabot>      The type variable ‘t0’ is ambiguous
01:37:44 <ski> er
01:37:46 <ski> > [x | Just x <- [Just 3,Just 7]]
01:37:53 <lambdabot>  [3,7]
01:37:54 <ski> > [x | Just x <- [Just 3,Nothing]]
01:37:59 <ski> > [x | Just x <- [Nothing,Just 7]]
01:38:00 <lambdabot>  mueval-core: Time limit exceeded
01:38:02 <lambdabot>  [7]
01:38:06 <ski> > [x | Just x <- [Nothing,Nothing]]
01:38:08 <lambdabot>  []
01:38:17 <ski> er, lambdabot failed with
01:38:19 <ski> > [x | Just x <- [Just 3,Nothing]]
01:38:21 <lambdabot>  [3]
01:38:23 <ski> ok
01:38:33 <ski> so, you get a list with two, one, one, or zero elements
01:38:38 <Kwoth> lyxia: ski thanks a lot :) "elementAt :: [a] -> Integer -> a" fixed it
01:38:53 <ski> the `Nothing's and the `Just's disappear, only the elements (if any) remain
01:39:04 <ski> Tangerine : makes sense ?
01:39:12 <Tangerine> I see
01:39:54 <ski> a pattern-match to the left of `<-' in a list comprehension will just abort the current element generation if the pattern-match fails, and continue with the remaining combinations
01:40:09 <ski> so, when the element in the inner list is `Nothing', that will just be skipped
01:40:40 <hexagoxel> int-e: lambdabot is becoming more lazy than useful. fixpls?
01:43:23 <m0rphism> Hi, can someone recommend an introductory paper (not book) for type systems?
01:43:23 <hexagoxel> (ah, maybe @undefine already helped? latency seems to be down to 1-2sec now)
01:43:56 <m0rphism> Maybe something introducing the STLC and optionally a few basic extensions (unit, nat, ...)
01:44:25 <ggole> PLAI?
01:44:31 <m0rphism> A friend of mine wants to hold a program analysis seminar on type systems and the seminar requires a paper as basis
01:44:33 <ggole> (Although it's more of a book, I suppose.)
01:44:42 <ski> m0rphism : perhaps "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> could be useful ?
01:45:04 <m0rphism> ski: ggole: thanks! I'll take a look at them :)
01:46:38 <ggole> I suppose the problem here is that papers on type systems aren't usually written as introductory material
01:47:19 <merijn> m0rphism: Lemme see if I can find my old lecture notes
01:47:22 <m0rphism> ggole: Exactly :) Especially, as there are such great resources as /Types and Programming Languages/.
01:47:37 <merijn> But in general TaPL would be much preferable, yes.
01:47:46 <merijn> No university library around to pillage?
01:48:47 <ski> m0rphism : it has integers, booleans, lists, functions, recursion. adds pairs, eithers, streams, polymorphism, mutable references, (existential) abstraction
01:48:50 <merijn> oh...I don't have my old university stuff on this machine, but this looks like the right notes: http://www.cs.vu.nl//~femke/courses/lv/notes/notes.pdf
01:49:22 <ski> m0rphism : this paper was helpful for me, when i started teaching myself about type systems
01:49:30 <merijn> m0rphism: I used it as intro, but it's not as in-depth and elaborate as TaPL
01:50:01 <merijn> Bonus, it does discuss the parallels between different logics and type systems
01:50:48 <m0rphism> merijn: thanks, I'll have a look at that, too.
01:51:00 <Tangerine> how do I implement a helper function within a function?
01:51:39 <merijn> Tangerine: where/let clause?
01:51:47 <merijn> Tangerine: I think I don't understand your question? :)
01:51:47 <Tangerine> do I just say where
01:51:49 <Tangerine> and continue on?
01:51:59 <Tangerine> and do people usually use where or let?
01:52:10 <merijn> Tangerine: See example here: https://gist.github.com/merijn/c163cc106fd245d1cf2e
01:52:28 <merijn> Tangerine: I generally use where whenever possible. I think let looks ugly so I only use it when I *have* to
01:55:31 <ski> m0rphism : perhaps ezyang's "Interactive Tutorial of the Sequent Calculus" <http://logitext.mit.edu/logitext.fcgi/main> could also be of interest, though it's more of the logical side of it
01:58:26 <Tangerine> let's say a function returns a tuple
01:58:33 <Tangerine> how do I use the two values of the tuple?
01:58:49 <merijn> Tangerine: Pattern match on the tuple?
01:58:50 <mauke> pattern matching
01:58:54 <ski> the nicest is usually pattern-matching
01:59:30 <Tangerine> so lets say function f on an object returns tuple (a, b)
02:00:01 <ski> (hmm .. could you say `(let (x,y) = ... in ..(x,y)..) = ..(...)..' is eta for pairs ?)
02:00:06 <Tangerine> and I have another function that is some function of the object, and I want to use f onit
02:00:18 <Tangerine> oh so use more let and where?
02:00:24 <mauke> or case/of
02:00:35 <mauke> but what you said is just f (other obj)
02:00:46 <ski> yes, if the types fit, what mauke said
02:00:57 <merijn> Tangerine: "where (x, y) = f foo" <- use x and y wherever you want
02:01:02 <ski> (well, in the other order, i suppose)
02:01:14 <merijn> Or "case f foo of (x, y) -> {- use x and y here -}"
02:02:09 <ski> @src span
02:02:09 <lambdabot> span _ xs@[]                  = (xs, xs)
02:02:09 <lambdabot> span p xs@(x:xs') | p x       = let (ys,zs) = span p xs' in (x:ys,zs)
02:02:09 <lambdabot>                   | otherwise = ([],xs)
02:02:11 <merijn> This even works on the top level (many people seem unaware of that)
02:02:14 <ski> Tangerine : ^ that's an example
02:02:35 <merijn> "x, y :: Int; (x,y) = f foo" is perfectly fine at the top level, for example
02:02:36 * ski sometimes uses `[x,y,z] = ...' on the top-level
02:02:53 <merijn> ski: Yeah, but I think *many* people don't realise that "Just Works" :)
02:02:57 <m0rphism> ski: The /Polymorphic Type Inference/ paper is just what I was looking for, thank you very much :)
02:03:17 <ski> merijn : if it would work in a `where', then why not there ? :)
02:03:28 <ski> m0rphism : yw
02:03:48 <mauke> x@y@z = 42 also works at the top level
02:03:54 <m0rphism> merijn: The notes are also very helpful, but may go a bit too deep for this seminar, but I'll suggest it as a supplement :)
02:04:31 <ski> mauke : unfortunately `loop@(map f) (x:xs) = f x : loop xs' doesn't :/
02:05:49 <nick2000> http://lpaste.net/161381
02:06:28 <mauke> map f ((f -> y) : (map f -> ys)) = y : ys
02:06:49 <mauke> nick2000: bad indentation
02:06:53 <ski> m0rphism : btw, note that Miranda was a (also non-strict) predecessor to Haskell
02:07:05 <ski> (s/Miranda/Miranda[tm]/)
02:07:10 <nick2000> okay, then how do i fix it_
02:07:21 <mauke> nick2000: all statements in the do block must line up with the next token after 'do', which is 'w' in your case
02:07:32 <mauke> this is more obvious if you start a new line after 'do'
02:07:34 <ski> mauke : yes, but not quite the same thing
02:07:56 <Tangerine> thanks for the help! Now to try to understand how to deal with that pesky maybe...
02:08:15 <merijn> ski: Because no one reads the report :p
02:08:31 <merijn> Tangerine: "pattern matching", see a pattern? ;)
02:08:55 <nick2000> now i lined them to the "w" but it just says Main.hs:12:1:parse error (possibly incorrect indentation or mismatched brackets)
02:08:55 <merijn> Pun not intended, but pleasant in hindsight
02:08:58 <mauke> case ... of { Nothing -> ...; Just x -> ... }
02:09:13 <mauke> nick2000: annotate your paste with the new version
02:09:22 <ski> merijn : it's just an obvious orthogonal consequence, to try out that it also works, no ?
02:10:00 <merijn> nick2000: I recommend reading up on Haskell's layout rules: https://en.wikibooks.org/wiki/Haskell/Indentation
02:10:15 <nick2000> http://lpaste.net/161382
02:10:19 <merijn> nick2000: They are very flexible, but perhaps not quite what you'd naively expect
02:10:33 <ski> nick2000 : you didn't annotate the original paste, you made a new one :/
02:10:50 <merijn> The do isn't indented further than runGraphics
02:11:05 <merijn> I wouldn't put the do insid () anyway
02:11:07 <mauke> merijn: irrelevant
02:11:08 <ski> merijn : shouldn't matter
02:11:17 <ski> nick2000 : the last `)' must be indented more
02:11:46 <nick2000> ski: thanks! that workd!
02:11:46 <lpaste> merijn annotated “Why doesn't this work” with “My version” at http://lpaste.net/161382#a161383
02:11:56 <merijn> nick2000: I would write it like that
02:11:59 <nick2000> *worked
02:12:02 <mauke> nick2000: your last ) is in the first column, so the parser thinks it's a new declaration (which is a syntax error) and main is missing a ')'
02:12:12 <ski> nick2000 : otherwise it thinks the definition of `main' has ended before that `)'. and then you get the "mismatched brackets" problem
02:12:43 <merijn> I think the best (and most common) solution would be to adopt the "$ do" style :)
02:13:04 * ski thinks it would be nice if no `$' was needed in that case
02:13:42 <ski> (also `foo \x -> ..x..',`foo if ... then else ...',`foo case ... of ...', `foo let ... in ...', of course)
02:13:49 <mauke> mo $, mo problems
02:15:24 <merijn> ski: An extension was proposed making "do" introduce implicit parens for cases like thi
02:15:30 <merijn> But I think the discussion stranded
02:15:48 <ski> do you have a link ?
02:16:14 <ski> (it would also allow one to get rid of the `runST $ ...' special case)
02:16:50 <ski> (well, at least in the case that `...' starts with `do' .. or `let' or another of the keywords above)
02:17:05 <Lovepon> @pl flip f x . flip g y
02:17:05 <lambdabot> flip f x . flip g y
02:17:11 <Lovepon> oh
02:17:23 <Lovepon> well ok
02:17:40 <mauke> @pl \flip -> flip f x . flip g y
02:17:41 <lambdabot> ap ((.) . flip ($ f) x) (flip ($ g) y)
02:17:50 <ski>   (`f` x) . (`g` y)
02:17:54 <ski> Lovepon ^
02:18:26 <Lovepon> ski: Right.
02:18:45 <mauke> it could be factored harder if f = g or x = y
02:18:45 <Lovepon> ski: I'm debating whether to add parentheses or to use shift.
02:18:58 <ski> shift ?
02:19:30 <ski> @type shift
02:19:31 <lambdabot> Bits a => a -> Int -> a
02:20:11 <Lovepon> @pl shiftFill n = flip evalState 1 . flip convergeM n $ \n -> do
02:20:11 <lambdabot> shiftFill = ($ const do) . (flip evalState 1 .) . flip convergeM
02:20:18 <Lovepon> @pl shiftFill n = flip evalState 1 . flip convergeM n $ \n -> f n
02:20:18 <lambdabot> shiftFill = flip (flip evalState 1 .) f . flip convergeM
02:20:29 <Lovepon> Okay...
02:20:49 <ski>   shiftFill n = (`evalState` 1) . (`convergeM` n) $ \n -> do ..n..
02:21:12 <jophish> ggVGc: It's an algorithm for finding the eccentric anomaly of an orbiting body given the mean anomaly
02:22:31 <jophish> I'm using exact-real for the test suite, and for certain (very eccentric) orbits the number of iterations can become very large in order to get the required precision
02:23:34 <jophish> For Floats and Doubles the precision sucks anyway, so they can use the fast version without a problem
02:24:06 <ski> how about the stability of the algorithm, on floating-points ?
02:24:27 <Lovepon> Sweet jesus, what the hell am I doing?
02:24:52 <jophish> ski: I've not encountered any (unexpected) problems with it, it's a pretty standard Halley iterator
02:24:59 <jophish> brb
02:25:02 <ski> mhm
02:25:13 <Tangerine> ski: apparently the maybe thing you said early can be done with catMaybes
02:25:24 * ski was just curious as to whether jophish know anything about the stability of it
02:25:34 <ski> Tangerine : yes, that's an alternative
02:25:40 <ski> or `mapMaybe'
02:25:44 <ski> @type mapMaybe
02:25:45 <lambdabot> (a -> Maybe b) -> [a] -> [b]
02:26:01 <ski> (for some reason i didn't think about those at the time)
02:26:09 <Tangerine> @type catMaybe
02:26:10 <lambdabot>     Not in scope: ‘catMaybe’
02:26:10 <lambdabot>     Perhaps you meant one of these:
02:26:10 <lambdabot>       ‘catMaybes’ (imported from Data.Maybe),
02:26:31 <Tangerine> except my interpreter is saying not in scope?
02:26:37 <ski> @type catMaybes
02:26:38 <lambdabot> [Maybe a] -> [a]
02:26:47 <mauke> @index catMaybes
02:26:48 <lambdabot> Data.Maybe
02:26:49 <ski> @type (catMaybes .) . map
02:26:51 <lambdabot> (a1 -> Maybe a) -> [a1] -> [a]
02:27:06 <ski> @src catMaybes
02:27:07 <lambdabot> catMaybes ls = [x | Just x <- ls]
02:27:08 <ski> heh
02:27:16 <merijn> Tangerine: It's not in the prelude, so you need to import Data.Maybe :)
02:27:24 <merijn> Eh, wait
02:27:27 <merijn> Data.List maybe?
02:27:29 <merijn> I dunno
02:27:33 <merijn> Use hoogle :p
02:27:36 <ski> no, it's in `Data.Maybe'
02:27:41 <Tangerine> O
02:27:50 <ski> @hoogle catMaybes
02:27:50 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
02:27:53 <ski> Hoogle agrees
02:27:59 <Tangerine> I'm using SublimeHaskell at least
02:28:04 <Tangerine> and it didn't yell at me for findMin :: Ord a => Pqueue a -> Maybe a
02:28:13 <Tangerine> but yells at me for catMaybes
02:28:15 <Tangerine> strange..
02:28:17 <merijn> heh
02:28:24 <ski> well, you defined `findMin', didn't you ?
02:28:37 <Tangerine> yeah
02:28:44 <Tangerine> but it used Maybe
02:29:24 <mauke> @index Maybe
02:29:24 <lambdabot> Data.Maybe, Prelude
02:29:36 <mauke> Maybe is in the Prelude
02:29:51 <Tangerine> @index catMaybes
02:29:52 <lambdabot> Data.Maybe
02:30:02 <Tangerine> ahh
02:30:04 <Tangerine> so its NOT in the prelude
02:30:27 <ski> <merijn> Tangerine: It's not in the prelude, so you need to import Data.Maybe :)
02:30:56 <Tangerine> anyways, thanks for all the help!
02:30:58 <ski> np
02:34:11 <Lovepon>         generatePattern n = (`evalState` (n*2)) .  convergeM ((1 `shiftL` n) - 1) $ generatePattern' (shiftFill x)
02:34:15 <Lovepon> I wonder what's wrong. '_'
02:35:54 <mauke> x is not defined
02:36:23 <Lovepon> mauke: Defined somewhere else. I'm just joking, because that looks so ugly. Lol.
02:37:07 <ocramz> hej all
02:37:20 <m0rphism> ocramz: hi :)
02:38:09 <ocramz> o/ m0rphism 
02:39:51 <m0rphism> :D
02:41:12 <ski> hejsan ocramz
02:41:27 <ski> ocramz : du är inte i #haskell.se ?
02:42:26 <ocramz> ski : uhm, I'm afraid my Swedish is still too rudimentary.
02:42:50 <ski> åh, mhm
02:43:20 <ocramz> ski : I do live in Goteborg though. What abt you?
02:43:27 <ski> gbg
02:43:30 <Lovepon> Oh my God.
02:43:34 <Lovepon> What the
02:44:44 <ocramz> Lovepon : what happened
02:44:47 <bernalex> ski: er .se veldig aktiv? det er ganske lite liv i .no. :]
02:44:54 <ski> > 1 `shiftL` 4 - 1
02:44:55 <lambdabot>  15
02:44:58 <Lovepon> ocramz: That's the problem.
02:45:34 <Lovepon> I don't see how the hell this shouldn't typecheck.
02:45:39 <ski> bernalex : inte mycket. jag har ett (fåfängt ?) hopp om att det skulle vara mer livat med lite fler medlemmar ..
02:46:07 <bernalex> ski: samme her med .no. kanskje vi burde hatt et skandinavisk rom.
02:46:45 <Lovepon> Holy shit
02:46:52 <ski> bernalex : hm, ja. har funderat på det
02:46:53 <Lovepon> pyon: You'll gouge your eyes out when you see this shit.
02:47:25 <bernalex> ski: .se leder nok, pga chalmers osv. lite haskell i .no. =(
02:47:44 <ski> hm, finns det en dansk variant ?
02:48:02 <bernalex> srhb: ^
02:48:03 <srhb> ski: Nope.
02:48:09 <ski> tror de har SML vid DIKU ?
02:48:23 <srhb> ski: Not anymore, not as an introductory course, they're using F# now.
02:48:25 <bernalex> srhb: .de er sikkert registrert og satt opp med lambdabot osv. så bare å bruke.
02:48:32 <bernalex> ehm
02:48:34 <ski> srhb : hmm. a bit sad ..
02:48:34 <bernalex> .dk
02:48:39 <bernalex> eller .da. eller hva dere bruker. :p
02:49:02 <ski> border vara `.dk', eller kanske `-dk', men verkar inte finnas
02:49:26 <srhb> ski, bernalex: I tried starting one at some point, but there wasn't a huge amount of interest.
02:49:54 <srhb> ski, bernalex. #haskell.scandinavia, mayhaps :P
02:50:24 <ski> srhb : hur många andra danskar, ungefär, känner du till som frekventerar #haskell eller relaterade kanaler ?
02:50:27 <ocramz> ski : do you ever join the Got.Lambda meetup?
02:50:42 <ski> ocramz : not sure what that is :)
02:50:46 <srhb> ski: Three or so. 
02:51:26 <ocramz> ski : it's a meetup, as in meetup.com . This one is about FP in general 
02:51:40 <Lovepon> Okay...
02:52:20 <bernalex> srhb: should be for Scandinavian language. consider finlandssvenska and shapr and other people who kind of speak a Scandinavian language. :p
02:52:23 <Lovepon> pyon: I'm going to need help.
02:52:31 <srhb> bernalex: Nordic then! :-)
02:53:01 <srhb> Lovepon: Paste some code on lpaste.net ? :)
02:53:19 <Lovepon> shanemikel: I need help on finding a function I need.
02:53:27 <bernalex> srhb: hmmm Haskell Nordic sounds like a worse version of Haskell. at least that's how TV channels used to work. BBC/Discovery/MTV/etc. Nordic meant "kind of like the original, but with only realyl old reruns". :D
02:53:39 <srhb> bernalex: Ugh, yes, you're right.
02:53:45 <Lovepon> bernalex: lol
02:53:52 <Lovepon> srhb: *
02:53:55 * ski ponders icelandic and faroese
02:54:09 <Tangerine> > all (>3) []
02:54:10 <lambdabot>  True
02:54:10 <Lovepon> Hmmmm
02:54:23 <Lovepon> How do I say it.
02:54:24 <Tangerine> all (<3) []
02:54:34 <Tangerine> > all (<3) []
02:54:35 <lambdabot>  True
02:54:48 <ski> Tangerine : should work, with the right condition
02:55:11 <Lovepon> f :: (b -> a -> a) -> (b -> b) -> (b -> Bool) -> a -> a
02:55:11 <Tangerine> i thoughti t looks funny
02:55:13 <Tangerine> because it looks like
02:55:16 <Lovepon> I think that's what I need.
02:55:19 <Tangerine> everyone loves empty lists
02:55:21 <ggole> Hmm? Isn't all f []  true for any f?
02:55:26 <ggole> > all undefined []
02:55:28 <lambdabot>  True
02:55:33 <Lovepon> Actually
02:55:42 <liste> > any undefined []
02:55:43 <lambdabot>  False
02:55:50 <Lovepon> f :: (b -> a -> a) -> (b -> b) -> (b -> b) -> (c -> Bool) -> a -> a
02:56:00 <Lovepon> Yeah, that.
02:56:00 <ski> ggole : yes, but in Tangerine's real case, the list may also have one or two elements (or more, if they're doing wider-branched than binary)
02:56:01 <ocramz> abuse of lists will turn Haskell into Javascript
02:56:08 <Lovepon> Errrr, no, not yet.
02:56:17 <ggole> OK, I'm just missing the context.
02:56:19 <Lovepon> f :: (c -> a -> a) -> (b -> b) -> (b -> c) -> (c -> Bool) -> a -> a
02:56:22 <Lovepon> Yeah, that.
02:56:36 <jophish> ski: One can get a pretty reasonable initial guess for the problem. I *think* that the calculation I'm using for the initial guess will always fall in the zone of convergence however I have not proved this.
02:56:43 <Lovepon> f g update normalize p x =
02:56:52 <Lovepon> Maybe I should use the State monad for this.
02:57:14 <ski> Lovepon : where's `c' coming from ?
02:57:20 <Lovepon> ski: (b -> c)
02:57:27 <Lovepon> ski: "normalize"
02:57:30 <mauke> Lovepon: but you have no b
02:57:33 <Lovepon> ski: It's not exactly normalize.
02:57:39 <ski> Lovepon : yes, but then we have the same question for `b'
02:57:40 <Lovepon> mauke: Aw shit, you're right.
02:57:43 <Lovepon> mauke: b -> a -> 
02:57:45 <Lovepon> a
02:57:54 <Lovepon> How about
02:58:18 <Lovepon> f :: (c -> a -> a) -> (b -> b) -> (b -> c) -> (c -> Bool) -> State b a
02:58:30 <Lovepon> Ugh. I've been using state too much.
02:59:00 <ski> bernalex,srhb : #haskell.scandinavian ?
02:59:13 * ski looks at skejserjensen
02:59:40 <Lovepon> I think I'll just use state, again.
02:59:41 <bernalex> ski: you need to get someone to add lambdabot though.
03:00:08 <ski> m, yes
03:00:32 <bernalex> int-e maybe?
03:00:41 <ski> or shapr, if we can get a hold of him
03:02:15 <int-e> hexagoxel: that's a very unhelpful way of saying it. but fwiw, what you're seeing is that mueval has a quite impressive startup overhead (and that lambdabot's VM isn't the fastest). Not so easy to fix.
03:02:57 * ski nods
03:03:36 <bernalex> ski: iirc shapr didn't have access, and got int-e or someone else to do it for me for #plaimi
03:03:55 <int-e> shapr can do it temporarily... mompl
03:04:25 <ski> shapr used to have it, i'm pretty sure
03:04:45 <ski> @get-shapr
03:04:45 <lambdabot> shapr!!
03:05:23 * ski idly wonders in how long that hasn't been used
03:08:21 <Lovepon> Oh my God.
03:08:26 <Lovepon> pyon: What the fuck did I just make
03:09:02 <Lovepon> Holy shit.
03:09:06 * int-e needs to rewrite the IRC frontend and add some statistics (queries per minute, something like that)
03:09:11 * ski . o O ( "As I told you longe ago, do not calle up That which you can not put downe; either from dead Saltes or out of ye Spheres beyond." )
03:09:14 <Lovepon> 40000 bits, and the popcount works in less than a second.
03:09:19 <Lovepon> In ghci.
03:09:21 * int-e has no real idea how heavily lambdabot is being used.
03:09:24 <Lovepon> I just created a monster.
03:10:23 <Lovepon> I meant 400000 bits.
03:16:51 <MichaelBurge> Hello. I'm having a little trouble seeing how to use ScopedTypeVariables to access a type-level constant defined in a typeclass
03:17:01 <MichaelBurge> Does anyone mind telling me how to write this example? http://lpaste.net/161385
03:17:05 <Lovepon> Hmmm
03:17:18 <Lovepon> I just realized that there's already popcount in the stdlib.
03:17:41 <MichaelBurge> Lovepon: I think they added it to Data.Bits
03:17:53 <Lovepon> MichaelBurge: Yes.
03:17:58 <lpaste> lyxia annotated “ScopedTypeVariables for a Parse-related Task” with “ScopedTypeVariables for a Parse-related Task (annotation)” at http://lpaste.net/161385#a161387
03:18:01 <lyxia> MichaelBurge: ^
03:18:49 <MichaelBurge> lxyia: Ohh, do you have to explicitly bind variables when you're using ScopedTypeVariables? They don't automatically get a forall?
03:19:32 <lyxia> right
03:19:47 <MichaelBurge> lyxia: Yeah, it says it right here in the first bullet: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/other-type-extensions.html#decl-type-sigs
03:19:51 <MichaelBurge> Thanks for the help
03:19:54 <lyxia> yw
03:20:51 <ski> srhb : lambdabot är nu i #haskell.scandinavian
03:20:57 <ski> skejserjensen ^
03:30:37 <Lovepon> pyon: Done.
03:47:36 * ski funderade just på att pinga alla med `.se',`.no',`.dk' i kanalen. men det skulle nog vara lite ohyfsat ..
03:48:40 * hackagebot distributed-closure 0.3.0.0 - Serializable closures for distributed programming.  https://hackage.haskell.org/package/distributed-closure-0.3.0.0 (MathieuBoespflug)
03:53:38 <forze> hello all, I've got a pattern for printf (eg: "hello %s - foo %s") and a list of args ["world", "bar"] where the length of the args (and %s) is variable, is there a way to pass this to printf? I was thinking I could transform the list to a tuple and then uncurry but i've no clue how to transform the list to a tuple either
03:53:49 <Lovepon> >sqrt 2^100000
03:53:52 <Lovepon> > sqrt 2^100000
03:53:54 <lambdabot>  Infinity
03:54:11 <Lovepon> Hmmm
03:54:41 <Lovepon> My newton's method is taking me too long to calculate sqrt $ 2^100000. :/
03:56:14 <Lovepon> Wait..
03:56:43 <Lovepon> That's weird.
03:57:28 <ski> > 2 ^ (100000 `div` 2)
03:57:30 <lambdabot>  3160699436856317896135924659945691788984676387834935666847743155564943937902...
03:59:22 <Lovepon> Boom. Almost instant. Yay.
03:59:32 <Lisa1157> hi, im having trouble understanding GADTs, https://wiki.haskell.org/Generalised_algebraic_datatype under the '3 Example with lists' heading, what does the 'Nil :: List a Empty' line mean??
03:59:37 <Lovepon> My "initial guess" variable was wrong. Lol.
04:00:17 <Lisa1157> specfically what is meant by the 'a' in that line?
04:00:52 <MichaelBurge> Lisa1157: It's the same way that [] is the empty list for every type [a].
04:03:02 <MichaelBurge> Lisa1157: If you look at [], the actual type of the list is almost a phantom type. It doesn't really change the value, it just changes where it can be used.
04:03:18 <MichaelBurge> Lisa1157: Similarly, NonEmpty is a phantom type that doesn't affect the value, it just affects where you can use the value.
04:03:30 <Lovepon> There's a Stack Overflow question titled "Black magic in Haskell reflection" lol
04:06:13 <liste> forze: I think doing that would involve some serious typeclass hackery
04:06:33 <hexagoxel> Lisa1157: to properly introduce the variable, you could write `Nil :: forall a . List a Empty`
04:06:52 <forze> liste, I'm codegolfing, which might not the best way to learn the language but it's fun :D
04:08:06 <Lisa1157> hexagoxel: where does Empty come from?
04:09:08 <hexagoxel> Lisa1157: 3 lines above.
04:09:42 <hexagoxel> it is a type (with no representatives)
04:11:38 <Lisa1157> hexagoxel: hmm alright, I think i need to read further into things I dont quite understand how the 'data Empty' line magically works
04:12:34 <MichaelBurge> Lisa1157: It defines a type whose only member is bottom. I think there's a language extension needed to do constructorless types.
04:14:03 <Lisa1157> MichaelBurge: ah thx
04:14:04 <hexagoxel> Lisa1157: when you have three constructors, you write "data Foo = One | Two | Three", with one you write "data Foo = Foo", with zero you (can, with some extension) write "data Foo".
04:14:30 <srhb> MichaelBurge: Not anymore. data Void is valid in ghc 7.10 at least
04:14:33 <MichaelBurge> Lisa1157: But, if you wanted, you could also say "data Empty = Empty" and then just not export the constructor. So people could see the type but not be able to construct it.
04:15:19 <hexagoxel> (extension is "EmptyDataDecls")
04:15:58 <Lisa1157> ahh ic, that clears things up a bit thx guys ^_^
04:20:24 <lonokhov> TIL - you can compose Foldable with Data.Functor.Compose
04:23:04 <merijn> hexagoxel: No longer an extension
04:23:11 <merijn> hexagoxel: EmptyDataDecls is Haskell2010
04:23:12 <merijn> afaik
04:24:25 <Atium> > 1 + 1
04:24:27 <lambdabot>  2
04:24:34 <hexagoxel> might be; i only looked at the ghc manpage, which does not tell.
04:24:46 <Atium> > sum $ zipWith [1..10] [10..20]
04:24:47 <lambdabot>      Couldn't match expected type ‘Integer -> b0 -> c’
04:24:47 <lambdabot>                  with actual type ‘[Integer]’
04:24:47 <lambdabot>      In the first argument of ‘zipWith’, namely ‘[1 .. 10]’
04:24:55 <Atium> > sum $ zipWith (*) [1..10] [10..20]
04:24:56 <lambdabot>  880
04:25:41 <liste> > 2 – 2
04:25:43 <lambdabot>  3
04:25:48 <merijn> ...
04:25:57 <merijn> Looks like someone's been fudging definitions
04:26:14 <merijn> oh, that's not a minus...
04:26:20 <hexagoxel> and/or abusing unicode
04:31:50 <mmercer2> is there a way to list all the running threads?
04:32:22 <mmercer2> quick search in Control-Concurrent didn't give me anything
04:33:15 <srhb> mmercer2: Sure, many, as long as you keep track of them yourself! :-)
04:33:36 <mmercer2> a bit hard to do that when i am not the one creating them
04:35:46 <srhb> mmercer2: Yes, then you're out of luck.
04:36:30 <cocreature> well the runtime has to keep track of them somehow, so I would imagine there is _some_ way to get that list
04:36:53 <merijn> You can
04:37:04 <merijn> the tracing/runtime infrastructure can report that
04:37:21 <merijn> I'm assuming you're debugging/tracing and not needing actual ThreadId values to signal them?
04:38:30 <mmercer2> i need to kill snap's loop thread so that it releases handles to log files. without doing this I can't restart the server without also restarting cabal repl
04:39:29 <merijn> mmercer2: Ah, yeah, I don't think that's possible?
04:40:10 <srhb> Well, can't you just forkIO before starting Snap, and then kill that thread which you have control over?
04:40:46 <mmercer2> no because it fires its own thread. i can break out of the current thread with C-c, but the background thread keeps running 
04:41:12 <Lovepon> If I see the word "magic" in any Haskell source code. That's the time I git going.
04:41:30 <srhb> mmercer2: Oh, I didn't think the results of C-c would be the sam.
04:41:37 <srhb> same*
04:43:42 * hackagebot yesod-auth-hashdb 1.5.1 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.5.1 (paulrouse)
04:46:41 <merijn> Lovepon: That's where the fun starts :p
04:47:02 <maerwald> that's where the horror starts
04:47:05 <Lovepon> merijn: lol
04:47:36 <Lovepon> I think my library's pretty magic right now too.
04:47:54 <maerwald> rewrite it then
04:48:08 <Lovepon> maerwald: Nah.
04:48:26 <maerwald> magic code is bad, no matter the language
04:48:46 <merijn> Depends how you define magic
04:48:48 <Lovepon> Have you ever seen an arithmetic library that has (Bits a) => ?
04:48:50 <Lovepon> xD
04:49:12 <maerwald> merijn: that expression is pretty common in programming, I don't think it needs explanation
04:49:18 <merijn> And not all code can be non-magic
04:49:29 <maerwald> indeed, but then one shouldn't be happy about it
04:49:38 <merijn> I disagree
04:49:44 <merijn> I revel in horrific code :D
04:50:29 <merijn> The rush of subjugating that poor machine and system and making it bow to your depraved will :p
04:50:55 <maerwald> merijn: are you seriously saying it's good to write bad and non-understandable code just because it's cool or fun?
04:51:11 <Lovepon> Wow.
04:51:41 <Lovepon> My library's at least half the speed of arithmoi.
04:51:43 <Lovepon> And it's plain Haskell.
04:51:48 <Lovepon> I think I'm doing good. 'w'
04:52:10 <merijn> maerwald: No, I'm saying that problems that can be solved with code that can be written "simple and straightforward" is not fun to me
04:52:30 <maerwald> maybe you misunderstand what "simple" means then
04:52:41 <maerwald> simple solutions are not easy
04:52:57 <maerwald> everyone can come up with complicated solutions :P
04:53:25 <merijn> maerwald: You're not reading what I'm saying
04:53:43 <maerwald> pretty sure I am
04:53:46 <Lovepon> OHHH SHIIIITT
04:53:49 * Lovepon gets popcorn
04:53:53 <Akii> lol
04:53:57 <merijn> I'm not saying "complicated solutions are fun" I'm saying "problems that have non-complicated solutions are not fun"
04:54:25 <maerwald> merijn: so you don't like to come up with simple solutions for complicated problems?
04:55:19 <merijn> No, if I wanted that I'd go into politics :p
04:55:24 <maerwald> the most genius solutions are always simple
04:55:58 <merijn> That presupposes that a simple solution exists
04:56:07 <maerwald> no
05:05:45 <Lovepon> Welp.
05:06:54 <Lovepon> Holy.
05:09:33 <hpc> . o O ( some function from solutions to complexity, perhaps using size as a metric - then decide what threshold separates simple and complicated, then enumerate those simple solutions )
05:10:34 <hpc> (then solve in reverse for what problems they solve, and since there exists a simple solution to every problem, we've obtained coverage over problems)
05:10:59 <hpc> (we can of course perform this last step because there exists a simple solution to it embedded in the enumeration we just performed)
05:11:07 <MichaelBurge> merijin: The problems least likely to have a clean mathematical solution are those that have grown over the decades with tons of cruft, like ancient COBOL mainframes at banks
05:12:49 <Lovepon> Anyone wanna check out my library? :D
05:13:02 <MichaelBurge> what does it do
05:13:07 <Lovepon> MichaelBurge: Arithmetic.
05:13:19 <Lovepon> https://gitlab.com/Myrl/mya/tree/master
05:13:27 <MichaelBurge> Is it one of those type-level calculators?
05:13:35 <Lovepon> MichaelBurge: Lol. Nah.
05:14:28 <Lovepon> I also decided to go with Apache v2 License.
05:14:50 <hpc> i am a fan of the apache license
05:16:06 <Lovepon> Check it out. :D
05:16:40 <Lovepon> merijn: maerwald: Look at Primes and Powers.Squares.
05:17:04 <Lovepon> merijn: maerwald: Well, at least I used (*2) for some things, right?
05:17:14 <merijn> MichaelBurge: I prefer the "beating a runtime system/OS into doing my bidding" kinds of problems :)
05:18:29 <maerwald> MichaelBurge: I think it's a misconception here about the diffculty of a problem and the shape of the solution
05:18:56 <Lovepon> merijn: So, what do you think? :D
05:19:09 <Lovepon> merijn: I wrote it in my own unique style.
05:21:40 <merijn> Lovepon: To busy procrastinating from debugging to investigate other people's source >.>
05:22:02 <Lovepon> :(
05:22:10 <Lovepon> merijn: Mean.
05:27:56 <puregreen> does anybody know what could be the purpose of “base >= 4.4 || < 4.4” in build-depends?
05:28:40 <MichaelBurge> Lovepon: Your package reminds me of the code I used to write to solve Project Euler problems. If you're looking for something to do, those can be fun.
05:28:59 <Lovepon> MichaelBurge: I only have like 15 solved in PE.
05:32:05 <maerwald> puregreen: confusing people
05:32:30 <maerwald> it's the same as just "base" afais
05:34:40 * geekosaur wonders if some automatic dependency versions maintenance script went awry
05:35:00 <maerwald> broken dependency specs... nothing new in haskell land :P
05:37:24 <ntnt> is there a way to do Maybe -> Either in haskell ?
05:37:32 <ntnt> is there a *builtin* for Maybe -> Either ?
05:38:31 <bergmark> i think `either (Left x) Right' is the shortest you can do
05:39:11 <bergmark> s/either/maybe
05:39:20 <maerwald> > maybe (Left "") (Right) (Just 3)
05:39:21 <lambdabot>  Right 3
05:40:23 <maerwald> don't think there's a default function, because it's not clear what the "Left" is going to be there
05:42:33 <maerwald> so you'd rather want something like: toEither :: a -> Maybe b -> Either a b
05:43:17 <maerwald> but even then, I wouldn't say it's well defined that Just maps to Right, is it?
05:43:26 <maerwald> it's more of a guess 
05:43:45 * hackagebot inline-java 0.1 - Java interop via inline Java code in Haskell modules.  https://hackage.haskell.org/package/inline-java-0.1 (AlpMestanogullari)
05:43:47 * hackagebot sparkle 0.1 - Distributed Apache Spark applications in Haskell  https://hackage.haskell.org/package/sparkle-0.1 (AlpMestanogullari)
05:45:02 <bergmark> that toEither is `justErr' from errors
05:45:56 <maerwald> indeed
05:52:41 <companion_cube> heya! I have a static linking problem, even though I use  ghc -optl-static -static -lstdc++
05:53:14 <companion_cube> the linker cannot find -lgmp, but gmp is installed on my system
05:53:39 <companion_cube> (maybe it needs libgmp.a, not libgmp.so?)
05:54:02 <mpickering> puregreen: Can I ask you for your perspective about why you think it's not worth including Prisms in microlens? (Maybe over PM?(
05:56:45 <MichaelBurge> companion_cube: Try -static on your GHC options
05:56:55 <companion_cube> I have it
05:57:16 <geekosaur> companion_cube, yes. you said -optl-static, it wants static libs
05:58:04 <mpickering> puregreen: (or I can email if that is more convenient for you)
06:00:42 <puregreen> mpickering: sorry, was afk
06:04:19 <FjordPrefect> Is the summer of haskell program going to happen?
06:06:21 <puregreen> mpickering: if it was possible without a profunctors dependency I *would* include them (because why not), but the thing is that I haven't yet seen any particularly cool usecases for prisms. What I *have* seen is people trying to explain how prisms are useful and, tbh, not doing it very convincingly (e.g. see Edward's “The Unreasonable Effectiveness Of Lenses” talk +
06:06:21 <puregreen> https://www.reddit.com/r/haskell/comments/3kbj9r/edward_kmett_the_unreasonable_effectiveness_of/cuwm139)
06:07:49 <puregreen> mpickering: I admit that it probably depends *a lot* on what kind of code you're writing, but my current hypothesis is that “the kind of code that needs prisms is also the kind of code that wouldn't have any trouble depending on lens” (enterprisey stuff, lots of complicated exception handling, etc. I don't know)
06:09:30 <puregreen> and I realise that this isn't a particularly well-supported hypothesis, but given that I can't include prisms anyway no matter what, I haven't bothered investigating it further
06:10:25 <puregreen> FjordPrefect: I think so, yep
06:10:42 <puregreen> (organised by Haskell.org instead of Google)
06:11:00 <puregreen> (see https://www.reddit.com/r/haskell/comments/4dm1nc/summer_of_haskell_status_update_and_call_for/)
06:13:31 <mpickering> puregreen: That's an interesting perspective. My perspective is that you want to use prisms whenever you have sum types in your program.
06:14:00 <mpickering> to me, the whole appeal of `lens` is not lenses but the whole hierarchy
06:14:58 <puregreen> could you elaborate? or perhaps just send links to code where you're using prisms
06:15:37 <mpickering> it seems to me that the way lenses have been advertised - as a better way to do record updates - is not actually the best part
06:16:12 <mpickering> I don't think I have any lensy code in the wild. 
06:16:34 <mpickering> but that's an interesting perspective that I hadn't considered. 
06:16:41 <geekosaur> that's their origin and a point of "entry", not how their advertised.
06:17:03 <geekosaur> seems to me they're advertised as a generics library
06:22:38 <mpickering> Am I wrong in thinking that most people with a passing understanding would say that `lens` is a library for better record updates?
06:23:34 <geekosaur> minimal understanding, derived from the original lenses
06:23:52 <opqdonut> mpickering: yeah, I guess so
06:23:56 <geekosaur> don't confuse lens-the-library with lens-the-concept
06:23:58 <opqdonut> of course it's so much more
06:24:02 <hpc> i would agree with that
06:24:04 <opqdonut> geekosaur has a good point
06:24:20 <hpc> "passing understanding" is the entry point to any library of this type
06:24:34 <hpc> which introduces a major abstraction
06:24:58 <Lovepon> TMW Linux gets blunt and tells you "There are no jobs." :'(
06:25:43 <puregreen> regarding how is lens advertised vs. how it should be advertised: all this depends on the person/usecase as well :) initially I got hooked on Haskell because it had `map` and in Pascal I had to write the for loop (a very good reason, yeah). Fast forward 6 years and I find myself thinking “hey wouldn't it be nice to have a better Pascal with a great type system and higher-order functions and so on but without it being purely functional” and waiting
06:25:43 <puregreen> for Nim to get better and cursing myself for being too lazy to learn another language. Does it mean that I'm just an inferior form of programmer and if I wasn't I'd appreciate Haskell's features more? Or are my usecases simply different (and not “worse” in any objective sense)? I don't know. However, I'd still be wary of saying “lens is being advertised wrongly” when the true reason – even if it's depressive – might be “other people care
06:25:43 <puregreen> about nice-looking record updates more than they care about abstraction etc etc.”
06:26:30 <hpc> i would agree with that
06:26:50 <hpc> i don't feel a burning need to use lens, but that might change if i change my programming style
06:26:58 <c_wraith> lens is a data-manipulation swiss army knife.  Want to modify a data structure?  Lens has tools to make it easy.
06:27:22 <c_wraith> Want to do complex aggregations over a data structure?  Lens has tools to make it easy.
06:27:42 <Akii> so it's like map but changes the structure as well
06:27:58 <c_wraith> It's like a very targeted map.  or fold.
06:28:03 <hpc> there's a lot of other interesting steps on the road from map to lens imo
06:28:25 <companion_cube> puregreen: look at rust
06:28:28 <Akii> https://pbs.twimg.com/media/B58DjdCCQAASQrI.jpg
06:28:30 <companion_cube> it might be exactly what you want
06:28:48 * hackagebot wai-extra 3.0.15.1 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.15.1 (MichaelSnoyman)
06:28:50 * hackagebot auto-update 0.1.3.1 - Efficiently run periodic, on-demand actions  https://hackage.haskell.org/package/auto-update-0.1.3.1 (MichaelSnoyman)
06:29:16 <puregreen> companion_cube: looked at it, didn't like it, will look again in a year or so
06:29:54 <ntnt_> how does http://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-Except.html differ from Either ?
06:30:03 <companion_cube> really? sounds like what you asked for, imperative + map and HOF
06:32:59 <geekosaur> ntnt_, API. also Except has an explicit preference for one side vs. the other, whereas Either does not
06:33:10 <geekosaur> (and should not)
06:33:21 <ntnt_> what do you mena explicit preference?
06:33:28 <ntnt_> isn't Left = always error, Right = always value?
06:33:34 <geekosaur> no, it is not
06:33:46 <ntnt_> oh, Either doesn't ahve to used as a Monad
06:33:52 <ntnt_> it can just be "Either Lakers or Bulls"
06:33:55 <geekosaur> that's the *point*, that belief is false and misleading
06:34:01 <ntnt_> that's what you mena "no explicit preference" ?
06:34:07 <ntnt_> Either can *literally* just be Either a or b
06:34:12 <ntnt_> rahter than forcing Left to be error
06:34:22 <MichaelBurge> ntnt_: I believe the monad instance prefers Left
06:34:27 <geekosaur> that behavior belongs in Except. Either should not prefer Rights over Lefts by considering Left to be an exceptional condition
06:34:31 <ntnt_> whereas, Except is like: this is my error part, this is my value part
06:34:39 <merijn> Also, consider the behaviour of the Validation applicative vs the Either monad
06:35:26 <ntnt_> geekosaur: this all makes sense now; thanks!
06:36:45 * geekosaur kinda wishes that Either's constructors were not Left and Right, because culturally "left" is typically considered bad --- e.g. in many languages the word for "left" is related to the word for "evil" or "demon"
06:36:55 <Akii> so one should use Except for error handling instead of Either
06:37:35 <hpc> data Either a b = Sinister a | Righteous b
06:37:40 <Akii> :D
06:38:02 <sm> darn rightists
06:38:07 <hpc> | FILE_NOT_FOUND
06:38:16 <merijn> hpc: Did you see the "moral vigilance" hack for python? :)
06:38:21 <hpc> i haven't
06:38:53 <merijn> Oh wait, I'm misremembering, it's loosely based on python
06:38:56 <merijn> hpc: https://github.com/munificent/vigil
06:39:17 <merijn> "Infinitely more important than mere syntax and semantics are its addition of supreme moral vigilance. This is similar to contracts, but less legal and more medieval."
06:40:44 <sm> funny
06:41:03 * hpc reads
06:41:20 <sm> when it says code will be deleted.. does it mean from the running program, or the source file on disk ?
06:41:39 <hpc> oh, so it's basically carp
06:41:57 * merijn sighs
06:42:01 <hpc> ;)
06:42:51 <merijn> oh...dammit
06:43:15 <merijn> I was wondering why my "forever $ do {- pipes code here -}" wasn't working...
06:43:34 <merijn> Only to realise it can be simplified to "Pipes.Prelude.mapM"
06:43:41 <hpc> heh, nice
06:43:51 <merijn> Let's see if that solves it
06:44:04 * hpc has always been partial to forM instead
06:44:08 <merijn> I'm never quite sure whether "forever" is supposed to work with await
06:44:11 <hpc> but i am a filthy imperative peasant
06:44:36 <merijn> hpc: There is no forM in pipes? it also wouldn't make much sense?
06:44:41 <merijn> What type would it have...
06:45:20 <hpc> oh, i see
06:45:29 <hpc> it being a "prelude" module threw me
06:45:50 * hpc needs to properly pipes one of these days
06:46:36 <merijn> I like how things are orthogonal and the elegance of some problems. But it's...not always immediately obvious how to look at the problem from the right angle
06:48:51 <sm> aha, it means from the source file on disk. Excellent.
06:49:26 * sm wonders how much harder https://github.com/munificent/vigil/blob/master/vigil would be in haskell
06:51:22 <merijn> For some sad reason my supposedly never terminating pipeline, well, terminates immediately >.>
06:52:17 <geekosaur> write it in acme-php obviously :p
06:56:05 <ntnt_> should I be usin both throwError and throwE, or is one meant to be the replacement for another?
06:57:56 <Cheesegrater> hey! I'm trying to make a program that prints a welcome message to the console, then takes some user input. however, when run, the program accepts user input before the text is rendered, and then prints the text. why does that happen?
06:58:03 <Lovepon> Do you know what Haskell-tan is? A puresonification.
06:58:14 <Lovepon> Wow, that was a very shitty joke.
06:59:00 <hpc> Lovepon: if you'd like to put your talents to good use, acme-php is on github ;)
06:59:35 <Lovepon> > the safety of PHP. So basically, no safety?
06:59:36 <lambdabot>  <hint>:1:12: parse error on input ‘of’
06:59:44 <geekosaur> https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/System-IO.html#v:hSetBuffering on stdout
07:00:06 <puregreen> and http://stackoverflow.com/questions/13190314/haskell-do-monad-io-happens-out-of-order for more details
07:00:09 <geekosaur> oh sigh
07:00:11 <geekosaur> Cheesegrater, you need to turn off line buffering
07:00:17 <geekosaur> see https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/System-IO.html#v:hSetBuffering on stdout
07:00:37 <Cheesegrater> thanks!
07:00:41 <hpc> Cheesegrater: also click on the "BufferMode" type to see exactly what the buffering logic is
07:00:43 <Lovepon> GAHH
07:00:51 <Lovepon> Where's this personification of ghc that people are talking about!? >.<
07:00:53 <Freundlich> If I want to search for every function that uses a certain typeclass (e.g. Monoid) on Hoogle, how would I do it?
07:01:00 <Cheesegrater> reading right now :)
07:01:52 <Freundlich> Data.Monoid itself only offers mconcat besides the basic mempty and mappend functions. I want to see which functions make use of the fact that something is a Monoid.
07:03:21 <hexagoxel> Freundlich: with hayoo, this seems to get you "correct" results: http://hayoo.fh-wedel.de/?query=Monoid+m+%3D%3E+a
07:03:55 <Lovepon> Where i s it? 'w'
07:04:19 * hackagebot yesod-bin 1.4.18.1 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.18.1 (MichaelSnoyman)
07:04:20 * hackagebot yesod-test 1.5.1.1 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.5.1.1 (MichaelSnoyman)
07:04:22 * hackagebot yesod-core 1.4.20.2 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.20.2 (MichaelSnoyman)
07:04:24 <Lovepon> This reminds me. How the hell didn't I know about Haskell?
07:04:41 <Lovepon> Until like, 1 year ago.
07:05:13 <hpc> we're the illuminati
07:05:30 <Akii> how did I not know about FP one year ago
07:05:32 <Lovepon> hpc: Am I one of the cool kids now?
07:05:39 <hpc> also there's no "mainstream" languages in the ML family
07:05:41 <Lovepon> Akii: I've been FPing before Haskell. :P
07:05:48 <ntnt_> how did I not know buy bitcoin when it was 10^4 coins / dollar ?
07:05:58 <merijn> Man, why is debugging concurrent programs such a pain even in haskell? :\
07:06:00 <hpc> haskell is the largest, and it's gradually becoming more well known
07:06:04 <Akii> Lovepon: ok, doing FP and not knowing Haskell is a challenge :D
07:06:05 <Lovepon> But Haskell's FP is like, way different.
07:06:16 <Lovepon> Actually, no.
07:06:24 <Lovepon> Haskell's FP isn't too different.
07:06:27 <hpc> merijn: i swore off (traditional) tool-assisted debugging years ago
07:06:41 <merijn> hpc: Even without tools it's a pain
07:06:57 <hpc> merijn: i like that you said "even" and not "especially" ;)
07:07:03 <merijn> Somehow a thread is propagating an exception to the top level
07:07:10 <Lovepon> With the exceptions of evaluation.
07:07:17 <red-falcon> head is safe by default right?
07:07:21 <Freundlich> hexagoxel: Thank you!
07:07:22 <hpc> merijn: but yeah, writing code that can be reasoned about just by reading it is more important to me
07:07:26 <merijn> red-falcon: What does that mean?
07:07:32 <hpc> > head []
07:07:33 <lambdabot>  *Exception: Prelude.head: empty list
07:08:30 <red-falcon> merjin as in i shouldn't be able to  get an exception if I do V.head $ fromList []?
07:08:38 <red-falcon> where V is the alias for Data.Vector
07:08:51 <red-falcon> i'm asking because i'm not sure how to reason about
07:09:01 <red-falcon> the OverloadedLists extension
07:09:15 <red-falcon> the list head is unsafe by default, while the vector one is safe by default
07:09:23 <Peaker> merijn: have we officially given up on proper uninterruptible exception handling (in bracket finalizers, finally, catch, etc?)
07:09:40 <red-falcon> i think some of the generics trickery behind the scene means the vector head is unsafe though because with the extension on V.head []
07:09:48 <red-falcon> I get the error:
07:09:49 <red-falcon> *** Exception: ./Data/Vector/Generic.hs:235 ((!)): index out of bounds (0,0)
07:09:58 <merijn> Peaker: I started on the patch a while back and then got distracted by work and haven't gotten back to it >.>
07:10:11 <byorgey> red-falcon: vector head is just as unsafe as list head.  I'm not sure what "safe by default" means.
07:10:34 <red-falcon> byorgey in the Data.Vector docs there's head and unsafeHead
07:10:59 <merijn> red-falcon: I would double check which meaning of "safe" and "unsafe" they use
07:11:00 <red-falcon> unsafeHead is defined as : O(1) First element without checking if the vector is empty
07:11:13 <merijn> "unsafe" might very well be "this can segfault"
07:11:30 <byorgey> red-falcon: 'head' checks whether the vector is empty and throws an exception if it is.  'unsafeHead' doesn't check and just indexes into memory somewhere, and can segfault
07:11:37 <merijn> red-falcon: I suspect "unsafeHead" dereferences a pointer without checking it is actually a pointer to an array with size >0
07:11:52 <merijn> whoo, guessed right
07:12:03 <hpc> heh
07:12:19 <merijn> gah
07:12:21 <red-falcon> merjin byorgey yes I see
07:12:26 <ntnt_> if I'm combining RWS with Either, is EitherT RWS or RWST Either better ?
07:12:37 <merijn> ntnt_: They mean different things
07:12:42 <merijn> ntnt_: So "it depends"
07:12:50 <ntnt_> isn't one of them nonsense?
07:12:53 <red-falcon> so is there a Vector head that produces a maybe? (i know it's easy to define one)
07:12:57 <byorgey> ntnt_: it depends on the semantics you want.  One of them will forget the state on failure, the other preserves state across failures
07:13:09 <merijn> @unmtl EitherT e (RWST r w s m) a
07:13:09 <lambdabot> EitherT e (RWST r w s m) a
07:13:14 <merijn> eh
07:13:22 <merijn> I guess it doesn't have eitherT in it?
07:13:29 <merijn> @unmtl ExceptT e (RWST r w s m) a
07:13:29 <lambdabot> ExceptT e (RWST r w s m) a
07:13:34 <ntnt_> to preserve state across failure would be "RWST Either" ?
07:13:42 <byorgey> I think RWST Either is the one that forgets state upon failure, though off the top of my head I'm not 100% sure
07:13:55 <hpc> @unmtl RWST Either
07:13:55 <lambdabot> Plugin `unmtl' failed with: `RWST Either' is not applied to enough arguments, giving `/\A B C D. Either -> B -> C (D, B, A)'
07:14:14 <byorgey> @unmtl RWST (Either e) w s a
07:14:14 <lambdabot> Plugin `unmtl' failed with: `RWST (Either e) w s a' is not applied to enough arguments, giving `/\A. Either e -> s -> a (A, s, w)'
07:14:22 <byorgey> @unmtl RWST (Either e) r w s a
07:14:22 <lambdabot> Either e -> w -> s (a, w, r)
07:14:25 <red-falcon> should I just use !? 0
07:14:33 * hackagebot contravariant-extras 0.3.2 - Extras for the "contravariant" package  https://hackage.haskell.org/package/contravariant-extras-0.3.2 (NikitaVolkov)
07:14:44 <hpc> @unmtl RWST r w s (Either e) a
07:14:44 <lambdabot> r -> s -> Either e (a, s, w)
07:14:47 <hpc> there we go
07:14:49 <byorgey> ah, right
07:15:03 <merijn> Despite all my threads being forked using "forkFinally" somehow exceptions are leaking to stdout?
07:15:04 <hpc> @unmtl EitherT e (RWS r w s) a
07:15:04 <lambdabot> EitherT e (RWS r w s) a
07:15:08 <byorgey> so yes, that's the one that forgets the state on failure, since you just get a Left e  and no  s, w
07:15:11 <whoareyou> hello?
07:15:13 <hpc> @unmtl ErrorT e (RWS r w s) a
07:15:13 <lambdabot> r -> s -> (Either e a, s, w)
07:15:18 <hpc> aha
07:15:22 <merijn> Does 7.10 already support stacktraces?
07:15:26 <byorgey> and that one preserves state
07:15:34 <byorgey> hi whoareyou
07:15:59 <whoareyou> channel is hacker ?
07:16:13 <byorgey> whoareyou: this channel is for discussion of the Haskell programming language
07:16:21 <whoareyou> sorry bad english
07:16:25 <whoareyou> iam from indonesia
07:16:41 <byorgey> welcome
07:17:16 <whoareyou> i am newbie
07:19:33 * hackagebot rebase 0.5.3 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.5.3 (NikitaVolkov)
07:29:30 <red-falcon> hi all
07:29:38 * hackagebot hasql 0.19.11 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.11 (NikitaVolkov)
07:29:45 <red-falcon> could i get some feedback on this use of the maybe monad to unwrap json data from servant?
07:29:47 <red-falcon> http://lpaste.net/161400
07:30:13 <red-falcon> is there anything that could be done better?
07:30:35 <zomg> Doesn't servant use aeson or do I remember wrong?
07:30:50 <red-falcon> zomg yes it does
07:31:07 <ntnt_> in practice, why would I ever want "EitherT RWS ... "which would ahve type \r s -> (either e s, w)
07:31:08 <zomg> yeah so couldn't you use aeson to pull the json data into a data type you've defined for it?
07:31:14 <ntnt_> in practice, why would I ever want "EitherT RWS ... "which would ahve type \r s -> (either e a, s, w)
07:31:15 <merijn> %(&%(&# god...sometimes I hate programming...
07:31:22 <red-falcon> zomg however i'm working with Data.Map as a value to retain all the  data in the json
07:31:38 <merijn> One machine is convinced that socket is closed, despite the otherside of the socket not agreeing... :\
07:31:57 <red-falcon> zomg otherwise i woudl either have a massive type definition or only have access to the pieces of data i explicitly defined
07:32:21 <int-e> merijn: welcome to the wonderful world of TCP
07:32:40 <merijn> int-e: The wonderful world of "gah, why are my programs not talking to eachother? :("
07:33:53 <int-e> merijn: lambdabot used to have this problem... was a lot of fun to track down :)
07:34:47 <Akii> what's a good way of accessing the database in haskell?
07:34:54 <red-falcon> so any feedback on the use of Maybe http://lpaste.net/161400 ?
07:35:11 <red-falcon> is there a way to express this more concisely?
07:37:57 <scshunt> red-falcon: hard to say without knowing all the code
07:38:25 <scshunt> my intuition is that you're going to have trouble, because you're relying on a lot of extrinsic knowledge for that pattern matching
07:38:47 <red-falcon> scshunt that is all the code other than the servant client and imports
07:39:29 <scshunt> those seem relevant
07:40:01 <red-falcon> scshunt yeah but this is the thing i was learning yesterday. for actions within the maybe monad, Nothing propagates automatically, including for pattern mismatches.
07:40:27 <scshunt> yeah, if a pattern match fails in a do block, you get fail, which in Maybe is just Nothing
07:40:39 <red-falcon> or at least it seems like it, i haven't gotten this to crash with garbage inputs
07:41:42 <red-falcon> scshunt so that's good right?
07:42:03 <red-falcon> this was a revelation because i was previously unwrapping and re-wrapping Nothings line by line which sucked
07:42:14 <red-falcon> this is much better but i'm wondering if it could be still improved
07:42:27 <red-falcon> scshunt ok updated to include the servant client code http://lpaste.net/161400
07:42:27 <scshunt> red-falcon: yeah, that will work fine, as long as your expected behaviour is to get Nothing when a pattern match fail occurs
07:43:09 <scshunt> what is !?
07:43:32 <red-falcon> basically I want either the value at teh end of the extraction, or a Nothing
07:43:43 <red-falcon> scshunt Data.Vector safe indexing
07:43:46 <scshunt> ah ok
07:43:55 <red-falcon> I was looking for a safeHead but i didn't find it
07:44:09 <scshunt> well, that's easy enough
07:44:16 <scshunt> safeHead = (!? 0)
07:44:31 <scshunt> red-falcon: my only other comment I guess is that I would probably opt to make a datatype with the structure I wanted and implement FromJson rather than doing the unwrapping myself
07:44:42 <scshunt> but that might be overkill here
07:44:58 <red-falcon> scshunt yeah the problem is the number of fields is huge
07:45:06 <red-falcon> this is what everyone has been telling me
07:45:30 <red-falcon> but i don't want to 1) define a massive data type or 2) throw away the data
07:45:52 <red-falcon> for my work, i do a lot of exploratory data analsyes
07:46:02 <red-falcon> where it's useful to be able to look at things you don't necessarily use
07:46:30 <red-falcon> i think that's something i deal with that is uncommon for haskellers (who seem to work on projects with well-defined specs)
07:46:51 <red-falcon> so i'm working with everything as values
07:47:47 <red-falcon> it's a bit of an experiment to see if i can make this work or i'm going to have to slink back to dynamic typing land
07:48:24 <red-falcon> one question - is there a way to compress the imperative-style pattern matching to make it more concise and declarative?
07:48:47 <scshunt> red-falcon: not really
07:49:05 <scshunt> the pattern match -> fail behaviour is part of a do block
07:49:50 <scshunt> although I think for what you are doing
07:49:55 <scshunt> you might want to look at lenses
07:49:55 <red-falcon> scshunt that's unfortunate, it seems like it should be possible to do some sort of chaining thing since that's the intent
07:50:28 <scshunt> red-falcon: it is, but you need something to handle the matching failure which would add extra verbosity
07:50:54 <scshunt> lenses are capable of it but it's a very different approach to the problem
07:51:19 <red-falcon> I guess I could do something liek >>= \(Object x) -> ... >>= (Array arr) -> ... but that doesn't seem worth it
07:52:22 <metahumor> Hi! I'm trying to figure out how to get "deriving instance Data" to work for partially applied constructors
07:52:24 <scshunt> red-falcon: and that won't handle pattern match failure
07:52:44 <scshunt> you'll get a real error, not Nothing
07:52:58 <red-falcon> scshunt oh i see so you'd need \x -> case
07:53:09 <red-falcon> i guess this is as good as it gets without lenses
07:53:13 <scshunt> or the lambda case extension, yeah
07:53:28 <metahumor> Let's say I have "data Request a where Add :: Int -> Int -> Request Int". I can do "deriving instance Data (Request Int)", but would it be possible to do "deriving instance Data "Int -> Request Int"?
07:53:29 <scshunt> you could define helpers I suppose
07:53:52 <scshunt> e.g. objHelper f (Object o) = f o; objHelper f _ = Nothing
07:54:26 <red-falcon> scshunt eh that doesn't seem like it would be any more concise. would a lens approach be able to do the same effect of propogating Nothings for pattern mismatches?
07:54:56 <red-falcon> i don't know lenses well, but lenses probably wouldn't work unless i defined explicit record types for this value hierarchy right?
07:55:10 <scshunt> no, you could make lenses that operate directly on the Aeson types
07:55:21 <scshunt> in fact, there's a library for that: lens-aeson
07:56:30 <red-falcon> oh ok interesting. yeah i came across lens-aeson
07:56:42 <red-falcon> but i wanted to try to do this using things i somewhat understand /can reason about
07:57:35 <red-falcon> before a deeper dive into more haskell-learning procrastination
07:58:34 <scshunt> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
07:59:43 <red-falcon> scshunt have had that bookmarked for a while :D still digesting more basic stuff (and trying to get some work done)
08:00:37 <scshunt> red-falcon: lenses have a steep learning curve, but they can produce some fantastically clean code at the end
08:01:12 <red-falcon> scshunt i'm around chapter 20 of Chris's book and still digesting what i've learned so far
08:01:36 <red-falcon> trying to apply it to some work, but it's still a challenge for me to be productive
08:08:05 <Freundlich> Isn't this supposed to be fixed in cabal-1.22.8.0? https://github.com/haskell/cabal/pull/3039 - It doesn't seem to work with http://hackage.haskell.org/package/cheapskate-0.1.0.5/dependencies when dingus is set to false.
08:09:39 * hackagebot monad-log 0.1.1.0 - A simple and fast logging monad  https://hackage.haskell.org/package/monad-log-0.1.1.0 (winterland)
08:10:43 <ryantrinkle> what would cause a dictionary to survive the simplification phase even when there's an unambiguous instance in scope?
08:11:32 <sm> heh: http://classicprogrammerpaintings.com/post/143178891892/haskell-programmer-seeks-forgiveness-for-using
08:12:14 <scshunt> red-falcon: chris's book?
08:14:37 <sm> and out of respect for the creator, I should add https://en.wikipedia.org/wiki/The_Return_of_the_Prodigal_Son_(Rembrandt)
08:15:50 <red-falcon> scshunt chris and julie's i should say. you know, the one and only haskellbook
08:16:25 <scshunt> red-falcon: I wasn't aware that there was only one
08:17:07 <hguant> red-falcon: the one that's still being written?
08:17:13 <red-falcon> hguant yeah
08:17:37 <hguant> red-falcon: I'
08:17:39 <merijn> Is there a way to get stack traces in 7.10 or do I need to switch to the 8.0 RC?
08:17:50 <hguant> ve been bouncing between that and real world haskell
08:18:09 <red-falcon> scshunt pretty much =P
08:19:02 <red-falcon> hguant I was working through RWH before i started haskellbook. it's super out of date and things are presented in an order st you don't really get a solid foundation
08:19:06 <merijn> Oh...I suppose stack traces don't really let me inspect errors in other libraries that don't use the special stacktrace stuff
08:19:08 <red-falcon> still there are some topics that are not available anywhere else.
08:19:39 * hackagebot yesod-auth 1.4.13.2 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.13.2 (MichaelSnoyman)
08:20:07 <merijn> I'm having a "blocked indefinitely in an STM transaction" exception that, afaik, shouldn't be possible
08:20:26 <red-falcon> alright time for more work
08:20:32 <merijn> That is, afaict all the STM things I'm using are alive
08:20:36 <red-falcon> thanks for the help guys
08:22:50 <Cheesegrater> how would you write aeson instances for CInt? I got the ToJSON instance working, but I'm having trouble figuring out how the FromJSON instance should look
08:24:21 <hpc> Cheesegrater: a somewhat reductionist approach would be to parse a CInt from JSON, parse into something that can be converted to CInt first
08:24:56 * hackagebot yesod-auth-oauth 1.4.1.1 - OAuth Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-oauth-1.4.1.1 (MichaelSnoyman)
08:24:58 * hackagebot yesod-form 1.4.7.1 - Form handling support for Yesod Web Framework  https://hackage.haskell.org/package/yesod-form-1.4.7.1 (MichaelSnoyman)
08:25:00 * hackagebot yesod-persistent 1.4.0.5 - Some helpers for using Persistent from Yesod.  https://hackage.haskell.org/package/yesod-persistent-1.4.0.5 (MichaelSnoyman)
08:37:42 <Cheesegrater> hpc: thanks, I got it working by converting to Int first now :)
08:38:22 <mauke> http://hackage.haskell.org/package/aeson-0.11.1.4/docs/Data-Aeson-Types.html#t:FromJSON doesn't the example do almost exactly what you want?
08:40:11 <mauke> parseJSON (Number n) = maybe (fail "value out of range") pure (toBoundedInteger n)
08:40:21 <mauke> parseJSON wat = typeMismatch "CInt" wat
08:59:18 <tippenein> what would you recommend for streaming multiple files together? Do it in parallel explicitly or build  multiple streams and merge them together?
09:19:28 <forze> is there any built-in that merges two lists interleaving them, (eg like merge in mergesort does)?
09:19:43 <mtesseract> tippenein: As far as I know, conduit and pipes are built for this kind of streaming work.
09:24:58 * hackagebot RNAlien 1.1.3 - Unsupervized construction of RNA family models  https://hackage.haskell.org/package/RNAlien-1.1.3 (FlorianEggenhofer)
09:25:28 <cheater> hello
09:34:08 <__uu__> hi, In real world haskell, chapter 5, in the Json Library example, what is point of defining group :: Doc->Doc?
09:34:44 <__uu__> group is only used in softline, softline = group line, but why is group introduced in ?
09:37:16 <tippenein> mtesseract: I'm unclear of the terminology around this. Is it called "merging" if I want to combine streams?
09:40:24 <cheater> pusher have implemented raft in haskell, does anyone know if that's available online somewhere? i can't find anything
09:48:53 <zipper> Hey, what's stack called on arch?
09:49:01 <zipper> Like just to install stack only
09:49:53 <zipper> Not that huge package
09:51:01 <zipper> Oh stack
09:56:30 <cocreature> cheater: I don’t think it’s opensourced
10:11:34 <cheater> cocreature: ok, thanks
10:11:41 <cheater> i searched around before asking, and found nothing
10:12:04 <cheater> in fact i wasn't able to find any haskell made by pusher at all
10:16:09 <aregidor> hi
10:16:45 <cheater> hi
10:17:09 <aregidor> I have a problem with this code http://pastebin.com/bpSkM7En 
10:17:19 <aregidor> ghc asks for a type signature for the second function
10:17:21 <aregidor> why?
10:17:52 <aregidor> is it the monomorphism restriction?
10:17:57 <aregidor> how can I fix it?
10:18:44 <aregidor> prueba.hs:10:34:
10:18:46 <aregidor>     Ambiguous type variable `ty' in the constraint:
10:18:48 <aregidor>       `BufferType ty'
10:18:50 <aregidor>         arising from a use of `mkRequest' at prueba.hs:10:34-51
10:18:52 <aregidor>     Probable fix: add a type signature that fixes these type variable(s)
10:20:11 <cheater> @hoogle mkRequest
10:20:12 <lambdabot> Network.HTTP.Base mkRequest :: BufferType ty => RequestMethod -> URI -> Request ty
10:22:05 <aregidor> Request a is an HTTP request with body of type a (String or ByteString)
10:22:42 <cheater> aregidor: rqBody refers to a concrete type. try to use that type in the type sig for makeRequestBad.
10:23:43 <cheater> oh, wait
10:23:53 <aregidor> cheater: it's String or ByteString
10:23:55 <aregidor> http://hackage.haskell.org/package/HTTP-4000.0.9/docs/Network-HTTP-Base.html
10:24:34 <aregidor> I want to use both types, whenever possible
10:26:05 <infinity0> so i guess these days transformers >> mtl ?
10:26:16 <infinity0> and how does monadlib fit into all of this
10:26:54 <cheater> aregidor: try not using let, and instead do (blah blah) {rqBody = body}
10:27:06 <aregidor> it fails too
10:27:20 <Clint> infinity0: mtl is a layer on top of transformers now
10:29:42 <infinity0> ah i see, so i might as well just use transformers
10:30:01 * hackagebot ctrie 0.1.1.0 - Non-blocking concurrent map  https://hackage.haskell.org/package/ctrie-0.1.1.0 (MichaelSchroeder)
10:30:03 <cheater> aregidor: hmm
10:30:37 <cheater> aregidor: compiling the sandbox
10:30:38 <aregidor> cheater: i really don't understand why it happens...
10:30:42 <Clint> infinity0: unless you need the typeclasses from mtl
10:31:29 <cheater> me either which means i'm rusty or it's a funny problem :)
10:32:13 <aregidor> mmm maybe some odd syntax subtlety for record fields?
10:32:18 <lyxia> aregidor: because you're overwriting the rqbody field of a Request, the type of the original Request is not specified enough
10:32:38 <aregidor> lyxia: but all request have a rqBody
10:32:43 <aregidor> requests*
10:33:32 <lyxia> aregidor: If you have a Request b and put a value of type a in the rqBody, it becomes a Request a
10:34:00 <lyxia> aregidor: the problem is that ghc can't deduce what b to pick
10:34:05 <geekosaur> aregidor, as long as you do not explicitly reference it, it just uses what it has and knows the type. if you provide a new value, its type may change
10:34:17 <geekosaur> and you did not tell it how to determine the new type
10:34:27 <cheater> ok aregidor, here it shows a more verbose type error
10:34:39 <cheater> what ghc are you on?
10:34:48 <cheater> i'm on 7.10
10:34:51 <aregidor> 6.12.1
10:35:38 <geekosaur> btw I see pastebin now overrides ad block. for those of us who worry about watering hole attacks, this means pastebin *itself* is an active malware distributor. I'm blocking it from now on
10:35:54 <aregidor> lyxia: but the function's signature especifes that it's a Request a, and also that body is of type a
10:36:26 <cheater> http://sprunge.us/QQhG
10:36:34 <lyxia> aregidor: it specifies it for r {rqBody = body}, but that doesn't determine the type of r
10:37:00 <cheater> @hoogle mkRequest
10:37:00 <lambdabot> Network.HTTP.Base mkRequest :: BufferType ty => RequestMethod -> URI -> Request ty
10:38:11 <aregidor> lyxia: mmmm ok... it's seems a strange kind of type class ambiguity, i assume
10:38:18 <aregidor> it* seems
10:39:48 <cheater> ok well i think i know what your issue currently is
10:40:14 <cheater> you say makeRequestBad gets a which has BufferType and returns Request a
10:40:19 <aregidor> any idea how can i fix it without having to choose between String and ByteString?
10:40:24 <MichaelK> Hi, is there a way to have GHC emit an error or warning if any declaration doesn't have an explicit type sig? (including in instances) I want to enforce "everything has an explicit sig" for a project
10:40:26 <cheater> not yet
10:40:31 <cheater> let me continue
10:40:59 <cheater> in the body you do mkRequest which returns some Request b where b has BufferType
10:41:11 <cheater> and ghc can't figure out that a ~ b
10:41:16 <aregidor> yep
10:41:21 <lyxia> cheater: append `asTypeOf` r to your function
10:41:30 <lyxia> are
10:41:32 <lyxia> aregidor: 
10:41:36 <cheater> right that might work
10:41:42 <aregidor> lyxia: where?
10:41:58 <lyxia> r {rqBody = body} `asTypeOf` r
10:42:08 <lyxia> This ensures both have the same type
10:42:10 <aregidor> ok, let's try
10:43:00 <aregidor> oh, it worked!
10:43:08 <aregidor> thanks, lyxia and cheater !
10:43:28 <ntnt> let "t" be a monad transformer; and "m" a monad which implements typeclass "foo", does "t m" automatically implement typeclass "foo", or do I have to manually 'lift' every typeclass that "m" satisfies into "t m" ?
10:43:44 <lyxia> you have to lift it manually
10:44:42 <aregidor> ntnt: but it usually works for common transformers
10:45:13 <ntnt> yeah, I have a monad transformer T, and a "m" which implements MonadError, and I guess I now have ot lift it ot "t m
10:45:14 <ntnt> "
10:45:18 <aregidor> ntnt: for example, is m implements MonadIO, then ErrorT also implements it
10:45:25 <aregidor> ntnt: for example, is m implements MonadIO, then ErrorT m also implements it
10:45:33 <cheater> anyways, this works: makeRequestBad url body = (makeRequestGood url body) {rqBody = body}
10:45:40 <ntnt> aregidor: is this becuase the source code for ErrorT manually lifts it?
10:45:54 <aregidor> cheater: oh 
10:45:57 <cheater> only guessing but that's probably because makeRequestGood is monomorphic
10:46:12 <aregidor> ntnt: the library for ErrorT does it
10:46:43 <cheater> oh lyxia yeah that's nice that works too
10:47:28 <infinity0> does anyone have a concrete example to help me understand MMonad embed
10:48:17 <aregidor> ntnt: http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Error.html#v:ErrorT
10:48:58 <aregidor> ntnt: http://hackage.haskell.org/package/transformers-0.4.2.0/docs/Control-Monad-IO-Class.html#t:MonadIO
10:48:59 <aregidor> etc
10:49:25 <aregidor> the common transformers work well toghether, without having to lift them manually
10:49:38 <ntnt> aregidor: I appreciate the link, but I don't know the point you're driving at
10:49:47 <ntnt> can you tell me what statement you're trying to show with these links?
10:50:02 <ntnt> i.e. there's omething you're trying to pove to me, but you showed me the proof w/o showing me the statement
10:50:04 <aregidor> ntnt: see where it says "Instances"
10:50:32 <aregidor> (Error e, MonadIO m) => MonadIO (ErrorT e m)
10:50:47 <ntnt> ah, the "Instances" shows how to 'lift' the things the inner monad satisfies to the outer+inner
10:50:52 <ntnt> aregidor: I get it now; thanks!
10:50:56 <aregidor> (Error e, MonadIO m) => MonadIO (ErrorT e m) 
10:50:58 <aregidor> etc
10:51:05 <ntnt> aregidor++
10:51:11 <aregidor> ntnt: :)
10:57:25 <aregidor> lyxia++ cheater++
11:21:10 <dedgrant> In GHC 7.6.3.5. Overlapping Instances, "If all remaining candidates are incoherent, select an arbitary one." -- !!!  Yoiks. Not even first-parsed or other such order that may be visible to the programmer?  Does anyone rely on competition between incoherent instances remaining stable?
11:21:48 <dedgrant> (this must have been discussed to death in the past.. just stumbling on the docs for the first time)
11:22:04 <hpc> is that a ghc version number, or a location in the docs?
11:22:16 <dedgrant> I'm sorry, section in the docs. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#instance-overlap
11:22:18 <lyxia> probably the intent is that if there are multiple ones you are supposed to make them coherent
11:22:22 <hpc> ah, yeah
11:22:27 <hpc> and yes, that
11:22:36 <hpc> incoherent instances are as terrible as the name implies
11:23:18 <js_is_scheme> what do people prefer for serializing to files? cereal?
11:23:41 <js_is_scheme> is there a good example / tutorial that shows how to serialize data into files on disk?
11:26:14 <Zemyla> js_is_scheme: Data.Binary, often with Generics.
11:28:14 <lyxia> binary is lazy cereal is strict
11:28:44 <js_is_scheme> lyxia for my purpose, i'm looking for what's easier to use.
11:29:15 <lyxia> I think cereal is a fine default
11:30:30 <dedgrant> hpc: Right.. just wondering why there is a way to suppress the arbitrary incoherent instance selection. Unless I'm misreading?
11:31:01 <dedgrant> Sorry, I mean to suppress the errors regarding arbitrary selection
11:33:19 <geekosaur> there are rare cases when only IncoherentInstances and knowing exactly what you are doing will work; that's why the extension exists
11:33:26 <nmdanny> does anyone here know how to use parser combinators?
11:33:54 <js_is_scheme> mmdanny i know the basics of attoparsec and parsec but others here are probably pros
11:34:22 <kadoban> nmdanny: You should generally just assume the answer to that is yes and ask your followup.
11:34:23 <maerwald> @ask
11:34:23 <lambdabot> Who should I ask?
11:35:13 <nmdanny> Ok, how can I make a parser where each token depends on the previous one?
11:35:20 <maerwald> @where ask
11:35:20 <lambdabot> Don't ask to ask, just ask.
11:35:22 <maerwald> that was it
11:35:47 <maerwald> sounds like you need to work in the monad instance
11:36:18 <sjcj> I've done this by going through my tokens twice (since I did not want to use monadic parsers)
11:36:18 <nmdanny> For example, I want to make a parser for ascending digits
11:36:31 <nmdanny> or a parser for a repeated digit
11:37:08 <maerwald> monadic parsers are slower, but well
11:37:47 <sjcj> so for your example: tokenAndPrevious :: Maybe x -> [x] -> [(Maybe x,x)]
11:38:13 <js_is_scheme> before you ask to ask, ask about asking to ask ...
11:38:16 <sjcj> tokenAndPrevious v (a:as) = (v,a):tokenAndPrevious as
11:38:31 <hpc> > fix ("ask to "++)
11:38:33 <lambdabot>  "ask to ask to ask to ask to ask to ask to ask to ask to ask to ask to ask t...
11:38:40 <dedgrant> geekosaur: I see. Is there a favourite example? I'm having a tough time understanding how, if the selection is arbitrary-- shouldn't the selection then be ordered in some auditable way, no matter how obtuse?
11:39:31 <dedgrant> geekosaur: Is it just one of those concessions for implementation-specific capabilities?
11:39:53 <hpc> well, you're reading the implementation docs
11:40:02 <hpc> so i guess it's more that the implementation doesn't want you to know
11:40:11 <geekosaur> there are ways to ensure which one is picked if you have control over all the instances and where they are defined, iirc
11:40:22 <hpc> either it really is random, or it's deterministic and can change at any time, or whatever
11:40:34 <geekosaur> but for the instance to be usable, all the types must be exported, so someone could define their own instance and wreck your assumptions
11:41:05 <lpaste> sjcj pasted “doubleTokens” at http://lpaste.net/161423
11:41:31 <sjcj> nmdanny: does that help for your use-case?
11:44:02 <nmdanny> I'm trying to make it monadic since it seems simpler that way
11:44:45 <dedgrant> geekosaur: Quite the tangle.
11:45:53 <dedgrant> I can certainly see why overlapped instances are behind a pragma.
11:45:53 <sjcj> nmdanny: it usually is
11:48:09 <nmdanny> also stupid question, how can I flatten a parse result? e.g from Parser [[String] to Parser [String]
11:48:21 <maerwald> fmap concat?
11:48:33 <scshunt> yep
11:49:58 <o`connor> nmdanny: also, you might want to look at http://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Lazy-Builder.html
11:55:25 <canile365> ciao
11:55:47 <canile365> !list
11:57:05 <nmdanny> whats the monad that implements alternative? monadplus?
11:58:11 <nmdanny> nvm
11:58:17 <merijn> nmdanny: What's wrong with Alternative? :p
11:58:27 <merijn> Anything that has MonadPlus should have Alternative too
11:58:47 <nmdanny> I mean, i'm trying to parse multiple possibilities
11:59:07 <nmdanny> so instead of doing <|> <|>, I wonder if I can have a list of possibilities 
11:59:29 <maerwald> nmdanny: choice
11:59:43 <iamtheonly> Hi!
11:59:43 <hpc> :t choice
11:59:44 <lambdabot>     Not in scope: ‘choice’
11:59:44 <lambdabot>     Perhaps you meant ‘choose’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
11:59:50 <hpc> oh right
11:59:54 <nmdanny> yes except that I don't seem to find a 'choice' combinator in polyparse
11:59:54 <merijn> choice is a parsec/attoparsec/parsers thing
12:00:07 <merijn> nmdanny: Should be trivial to implement :)
12:00:17 <nmdanny> yes so I'm wondering how to implement it
12:00:18 <merijn> nmdanny: "foldr (<|>) empty"
12:00:41 <merijn> :t foldr (<|>) empty
12:00:43 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
12:00:50 <nmdanny> :t empty
12:00:51 <lambdabot> Alternative f => f a
12:01:00 <merijn> empty is the failing parser :)
12:02:43 <nmdanny> another thing, about how a parser tries different alternatives: if it fails matching the first, it doesn't backtrack unless I use 'try', right?
12:02:56 <merijn> nmdanny: Depends on your parsing library
12:03:07 <merijn> attoparsec always backtracks, parsec doesn't, etc.
12:03:39 <iamtheonly> hi, is there a way to merge two lists i.e [1,1,1] "aaa" -> [1a,1a,1a] ?
12:04:04 <hpc> what's 1a?
12:04:39 <iamtheonly> merged first element of both lists
12:04:48 <TheMystic> iamtheonly: lots of ways... what kind of merging are you looking for?
12:04:53 <TheMystic> looks kind of like a zip
12:05:05 <iamtheonly> mergexy (x:xs) (y:ys) = [x,y] ++ mergexy xs ys
12:05:08 <iamtheonly> this is what I have currently
12:05:26 <hpc> :t zip
12:05:27 <lambdabot> [a] -> [b] -> [(a, b)]
12:05:40 <_d0t> ohai. Is it possible to use lts haskell with the latest aeson version?
12:05:58 <iamtheonly> though it will work only for either [1,1,1] [2,2,2] which gives [1,2,1,2,1,2] or "aaa" "bbb" which gives "ababab"
12:06:16 <iamtheonly> what I want is [1,1,1] "aaa" to give [1a, 1a, 1a]
12:06:20 <Cale> > zip [1,1,1] "aaa"
12:06:22 <lambdabot>  [(1,'a'),(1,'a'),(1,'a')]
12:06:25 <Cale> like that?
12:06:30 <Cale> 1a isn't valid Haskell syntax
12:06:39 <Cale> Well, it is, but it doesn't mean anything like what you'd want
12:06:50 <iamtheonly> k I understand, thanks for the help ;)
12:07:27 <mnoonan> > zipWith (++) ["1", "1", "1"] ["a", "a", "a"]  -- maybe?
12:07:29 <lambdabot>  ["1a","1a","1a"]
12:07:40 <Boomerang> > zipWith ((++) . show) [1, 1, 1] ["a", "a", "a"]
12:07:42 <lambdabot>  ["1a","1a","1a"]
12:07:48 <iamtheonly> looks nice, thank you!
12:07:59 <Cale> > zipWith (\x y -> show x ++ [y]) [1,1,1] "aaa"
12:08:01 <lambdabot>  ["1a","1a","1a"]
12:08:27 <TheMystic> iamtheonly: if the _elements_ you're trying to zip over are of different types, then you need some further logic to tell how to combine them
12:08:42 <TheMystic> that's what the 'show' in the last few examples is for
12:14:00 <nitrix> You could always do some procession before, if it makes writing the comining function easier.
12:17:00 <nitrix> > zipWith (\x y -> show x ++ [y]) (map show [1,1,1]) "aaa"
12:17:02 <lambdabot>  ["\"1\"a","\"1\"a","\"1\"a"]
12:17:15 <nitrix> Whoops
12:17:20 <nitrix> > zipWith (\x y -> x ++ [y]) (map show [1,1,1]) "aaa"
12:17:21 <lambdabot>  ["1a","1a","1a"]
12:17:30 <nitrix> But I think it's bad style :/
12:18:15 <nitrix> (I also think the list is traversed twice)
12:20:13 <lambda-11235> If Either is like the logical exclusive or, what type would be a logical inclusive or?
12:20:57 <simpson> lambda-11235: These. One sec, lemme get a link.
12:21:08 <simpson> http://hackage.haskell.org/package/these
12:21:24 <simpson> data These a b = This a | That b | These a b -- IIRC this is the data type
12:22:47 <lambda-11235> simpson: Thanks.
12:23:42 <simpson> lambda-11235: Be sure to check out the Monad instance: http://hackage.haskell.org/package/these-0.6.2.1/docs/Control-Monad-Chronicle-Class.html
12:33:48 <pharaun> Hello, when the sockets interface gets put in a half-closed state (ie a client or server closes it) does this also cause the handle derieved from it to close as well?
12:34:26 <pharaun> because seem to keep on entering a half-alive state where half of the network is dead yet the code doesn't notice it. I unfortunately need to use handle so i can support ssl and non-ssl connections
12:35:05 * hackagebot ghcid 0.6.2 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.6.2 (NeilMitchell)
12:35:08 <aregidor> pharaun: why not use Network.Browser?
12:36:02 <pharaun> this isn't over http tho :)
12:36:29 <aregidor> ah, ok :)
12:36:32 <pharaun> its over regular tcp sockets and some server has tls connections
12:36:42 <pharaun> so i got forced into using handles
12:36:59 <pharaun> but i'm not sure and haven't been able to identify if the socket -> half closed state -> forwards it to handle
12:37:20 <pharaun> if it doesn't, then i might be a bit stuck cos i am not sure i have access to the raw sockets that is being wrapped by the tls library
12:38:58 <ryantrinkle> is there any way to get better info on the cost centers GHC adds with -auto-all?
12:39:23 <ryantrinkle> i've got >>= taking up a lot of time, but it's difficult to see which >>= it would be
12:59:46 <Gurkenglas> I've got multiple lines looking like "\DeclareMathOperator{\Maybe}{\mathtt{Maybe}}", can I do something like "\newcommand{\dec}[1]{\DeclareMathOperator{\#1}{\mathtt{#1}}}"?
13:00:03 <Gurkenglas> Whoops, wrong channel. (That was LaTeX.)
13:02:39 <john_deere> what do people use in place of nub for Data.Vector?
13:15:01 <athan> Anyone here know if HList has a (!!) operator for index lookups?
13:15:19 <athan> Or do I need to deconstruct Cons cells manually? :\
13:16:31 <athan> shoot, I wonder if there could even be a new Index type that at least includes type data for the index
13:17:06 <athan> like `data HIndex (x :: k) = HIndex { hIndexValue :: Int, hIndexType :: Proxy x }` or something
13:18:13 <Zemyla> athan: It'd need to be of type HIndex (n :: Nat) (x :: k).
13:18:42 <Zemyla> Or actually, just type HIndex (n :: Nat), and it pulls x out of the list.
13:19:00 <athan> and `(!!) :: (HMember x xs) => HList (xs :: [k]) -> HIndex (x :: k) -> Maybe someCrazyStuff`
13:19:04 <athan> Zemyla: hmm, okay
13:19:13 <athan> crap :\
13:19:19 <athan> friggin existentials
13:23:36 <jle`> anyone familiar with the ad library? is there any way i can turn a regular ol' (Double -> Double) into something that can be diff'd ?
13:24:07 <jle`> the naive approach, (toRational . f . auto) always gives a derivative of 0, for somewhat understandable reasons
13:24:18 <jle`> s/naive/"make the types work"
13:34:51 <Denommus> hey
13:36:18 <ski> jle` : i don't think `Double -> Double' will work at all
13:36:38 <ph88^> is ghc 8.0 out yet ?
13:36:59 <ski> jle` : either it should be polymorphic enough, so that AD can instantiate it to the type it wants, or you should make sure to use that type from the start
13:38:51 <jle`> ski: yeah, was just wondering if there was any hack to get a double -> double into the system
13:38:51 <hexagoxel> ph88^: rc3 binary and rc4 source distribution are out (i.e: no), afaik
13:39:00 <ski> jle` : the idea is to "compute with differentials" ("dual numbers") along with the normal results, so it's based on overloading the numeric operations
13:39:07 <jle`> ski: one thing you can do is pick an arbitrary epsilon and talk about derivatives in terms of that
13:39:11 <ski> jle` : i'd expect you can't
13:39:19 <jle`> that's what i used to do to "differentiate" arbitrary Doub -> Doub's back in the day
13:39:38 <jle`> you could get to arbitrary derivatives by layering levels of differences
13:39:52 <jle`> s/arbitrary nth
13:39:56 <ski> jle` : you could ask edwardk, though
13:40:43 <jle`> i'm writing a library that takes polymorphic functions that AD can use to do things, but i was wondering if i could provide an interface for my library users who are stuck with Doub -> Doub's
13:41:16 <jle`> before porting things to use ad, i would provide a function that approximated derivatives with finite differences at a small epsilon heh
13:42:21 <ski> well, the problem is how to pick the epsilon
13:42:27 <ski> not too small, not too large
13:42:42 <jle`> yeah, any solution is inherently imperfect
13:42:58 <jle`> but i was looking for some sort of hack for desperate library users.  or a way to provide an epsilon
13:44:31 <jle`> i guess i could actually just provide the *old* interface in that sense and not bother with going through AD at all
13:44:37 <jle`> as in, the old implementation
13:45:11 <jle`> there would be some duplicated logic though v.v
13:47:56 <Lokathor_> What, if any, would be the best way to use a ghc 8 release canidate with stack
13:52:01 <mgsloan> Lokathor_: Install ghc locally such that it's on your PATH.  Then, use "compiler: ghc-8.0" and "allow-newer: true" in your stack.yaml
13:52:02 <Zemyla> Okay, I have a question about Arrows and possible Arrow transformers.
13:52:28 <mgsloan> Lokathor_: Oh, and use HEAD of the stack repo (stack upgrade --git)
13:52:44 <Lokathor_> Cool. Sounds doable
13:53:02 <Lokathor_> Excwpt the last part might be tricky :P
13:53:55 <Lokathor_> Stack upgrade is mildly broken on windows, but its the fault of windows, so they cant really fix it
13:54:01 <Zemyla> So if p a b is the base arrow, then ArrowReader r p a b = ArrowReader (p (a, r) b) is analogous to the Reader Monad, ArrowWriter w p a b = ArrowWriter (p a (b, w)) is analogous to the Writer monad, and ArrowError e p a b = ArrowError (p a (Either e b)) is analogous to the Except monad.
13:54:08 <Lokathor_> But there is a workaround
13:54:15 <mgsloan> Lokathor_: Oh, huh, is there a github issue?
13:54:31 <Zemyla> But what would its dual Arrow??? d p a b = Arrow??? (p (Either d a) b) be?
13:55:28 <Lokathor_> No. Stack builds stack, then installs it to where your binaries go. But if the stack you're running is already there, the file is "in use" so cant be overwritten
13:55:32 <Zemyla> It doesn't seem like it could exist, since you couldn't even define id = Arrow??? (arr ???)
13:55:49 <Zemyla> It seems like an asymmetry.
13:56:10 <Lokathor_> On linux it works out, but windows doesnt let you overwrite a running program
13:58:23 <mgsloan> Lokathor_: Oh I see.  That should be something we can solve, though.  I'm surprised that's a problem, since we have quite a fewe resolved issues regarding windows + stack upgrade
13:58:59 <mgsloan> I'm imagining the solution would be to spawn another process that waits for stack to exit and then overwrites it
13:59:20 <Lokathor_> Im back on stack 1.0, perhaps it even has been solved since then
13:59:46 <Lokathor_> But its not too huge a deal, and few people are on windows
14:00:19 <mgsloan> Well it's certainly our goal to support it well
14:00:42 <mgsloan> Though that can be challenging when most of us primarily use linux / mac os
14:01:02 <jle`> ski: woo hoo i figured out how to do it
14:01:25 <jle`> at least for forward-mode
14:01:59 <Lokathor_> Mgsloan, thats how most of the coding world goes it seems
14:02:42 <jle`> the key is that forward-mode AD is completely numeric in the end, it doesn't actually do any symbolic differentiation.  it just calculates how to transform dx's, so all you have to do is encode the transformation on dx
14:02:42 <kadoban> It's been a long time since I used windows regularly, but I always remember the read/write locks on files being kind of unpredictable. Maybe it depends on the phase of the moon if it actually doesn't work?
14:02:58 <jle`> now to figure out how to do it for reverse mode
14:03:05 <Lokathor_> Could be that too
14:03:05 <kadoban> Which would just be an explanation for why nobody has noticed yet, at least enough to make a PR or whatever.
14:03:35 * ski thought no part of AD did symbolic differentiation
14:04:00 <jle`> yeah heh, it just feels magical at first
14:04:03 <nmdanny> I have a dumb question, how to initialize a State monad given an initial state and an initial value?
14:04:03 <Lokathor_> Ive used stack upgrade before on linux, but first time it failed on windows i realized why and just got the release off git manually
14:04:11 <jle`> not implying anything about your understanding :)
14:04:28 <Lokathor_> Nmdanny, runState action initialState
14:04:30 <Lokathor_> Usually
14:04:49 <jle`> so turning a (Double -> Double) into a (Forward Double -> Forward Double) is pretty straightforward, you just need to compute the resulting x and dx
14:04:50 <Lokathor_> Or runStateT perhaps
14:04:58 <ski> (btw, if you have the current position, velocity, and acceleration of an object, and update each of those in each frame by using the current value of the next one, i wonder how much that compares to AD)
14:05:13 <nmdanny> no, I don't want to unwrap a state, I want to create a state
14:05:34 <ski> (er, in case that was ambiguous, the current value of the next of those quantities, not of the next frame)
14:05:41 <jle`> ski: compare in what way?
14:06:02 <Lokathor_> :t state
14:06:04 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
14:06:09 <jle`> that sounds like an integration method, not a differentiation method
14:06:18 <ski> nmdanny : what Lokathor_ said about `runState'
14:06:19 <Lokathor_> Nmdanny like that?
14:06:50 <ski> nmdanny : also s/a State monad/a State monad action/
14:07:04 <maerwald> anyone knows if there's a library that does escaping of e.g. ByteStrings?
14:07:24 <ski> nmdanny : .. and i'm not sure what initial value you're talking about. perhaps a parameter to a function returning the state action ?
14:07:52 <nmdanny> I have the following function which operates with state:
14:07:56 <nmdanny> nodesAtHeightST :: Maybe (TreeNode a) -> State LevelInfo [TreeNode a]
14:08:10 <nmdanny> and I have the following pure function which should utilize the state:
14:08:18 <nmdanny> nodesAtHeight :: Maybe (TreeNode a) -> Int -> [TreeNode a]
14:08:39 <ski> nmdanny : what's the `Maybe' for ?
14:08:49 <nmdanny> thats just how my tree is represented
14:09:03 <nmdanny> I have the following variable in a let block inside nodesAtHeight :  initLevelInfo = LevelInfo { currentLevel = 0 , targetLevel = tgtLevel}
14:09:27 <nmdanny> which is of type LevelInfo, which is the 's' parameter of the state monad
14:09:49 <ski> nmdanny : so a `TreeNode a' can't express an empty tree, but you want to be able to also have an empty tree. is that right ?
14:10:58 <nmdanny> I represent empty trees as 'Nothing', whereas full trees are 'Jusst TreeNode ...'
14:10:59 <ski> nmdanny : do you care about the final state of the state-action computation ? or just throw it away ?
14:11:03 * ski nods
14:11:32 <nmdanny> just the computation value
14:11:49 <ski> nmdanny : if you care about it, then `runState' (or `execState' if you only want the final state, not the "monadic result"). otherwise, `evalState'
14:11:57 <ski>   nodesAtHeight t = evalState (nodesAtHeightST t) initLevelInfo
14:11:58 <nmdanny> nvm,
14:11:59 <ski>     where
14:12:01 <nmdanny> I figured out how to do this
14:12:02 <ski>     initLevelInfo = ...
14:12:08 <nmdanny>   let     initLevelInfo = LevelInfo { currentLevel = 0 , targetLevel = tgtLevel}   in     evalState (nodesAtHeightST root) initLevelInfo 
14:12:16 <ski> (you can also use `evalState' infix)
14:12:27 <ski> nmdanny : what i said :)
14:12:34 <nmdanny> yea I understand now, I was just confused on the flow of the state monad
14:13:14 <nmdanny> I thought I need to create a state type and feed it the 's' type param, but it was the inverse, I had a function which returns a state monad, and to unwrap it I give it the 's' variable.
14:13:35 <ski> a `State s a' action isn't a state itself, not does it contain a state. it could be thought of as a "state thread". when given an initial state, it will thread it through the computation (which possibly depends and updates the current state), 'til the end
14:13:43 <athan> mer, why can't we partially apply type families, but totally can with type classes? :(
14:14:14 <nmdanny> yes ski, I understand that now, thanks :d
14:14:24 <ski> nmdanny : don't say "I had a function which returns a state monad". `State s' itself is the monad. a value of type `State LevelInfo [TreeNode a]' is not a monad, it's a monadic action (a `State LevelInfo'-action, in this case)
14:15:26 <EvanR> is tri functor somehow redundant?
14:15:28 <ski> athan : type classes are like `data' types or `newtype's, in that regard
14:15:43 <ski> athan : `type' synonyms act more like macros. they aren't first-class
14:16:07 <athan> ski: Shoot. Is there a way to get that behaviour somehow, for type-level computation?
14:16:10 <athan> :\
14:16:17 <athan> or pray for a language extension haha
14:16:21 <ski> which behaviour ?
14:16:33 <athan> ski: partial application of type morphisms
14:16:43 <athan> instead of the macro behaviour
14:16:57 <ski> a function like `not' is a type morphism
14:17:03 <ski> probably you meant something else
14:17:30 <athan> how is `not` a type morphism? It's not manipulating `Bool` in any way
14:17:32 <athan> :t not
14:17:38 <lambdabot> Bool -> Bool
14:17:45 <athan> hm
14:17:59 <athan> I could see `not` as a value morphism
14:18:00 <ski> the term "morphism" comes from CT. a "metric space morphism" is a morphism between two metric spaces, e.g.
14:18:06 <athan> for the set of values in `Bool`
14:18:17 <ski> so, a "type morphism" must be a morphism between two types, in the category of types
14:18:27 <athan> yes I agree with that definition
14:18:41 <athan> thus a type family could be considered a type morphism
14:18:47 <athan> yet it doesn't follow composition laws
14:19:00 <ski> if you said "type function", then i'd understand that you meant a function which "operated on the type level", which takes a type as input, and returns a type
14:19:05 <ski> like e.g. `Maybe'
14:19:20 <athan> ski: Yes exactly! A type function is what I need
14:19:30 <athan> but specifically one that doesn't have inhabitants
14:19:33 <ski> `not' is a morphism from the type `Bool' to the type `Bool'
14:19:37 <athan> I'm trying to make a `Succ` type function for Nat
14:19:39 <ski> iow, it's a type morphism
14:19:53 <ski> and `listToMaybe' is a monad morphism, from `[]' to `Maybe'
14:20:03 <athan> and apply it (partially) via a type-level `fmap` for a type-level `'Maybe` via DataKinds :|
14:20:10 <athan> hmm
14:20:26 <ski> this doesn't mean that `listToMaybe' eats monads for breakfast. it means that the domain and codomain of it are monads
14:21:01 <athan> hmm okay
14:21:21 * athan should eat some parsers :|
14:21:51 <EvanR> i would like a burrito for breakfast though
14:22:25 <ski>   type family Succ (n :: Nat) :: Nat
14:22:35 <Gurkenglas> "## Report this to libraries@haskell.org ##" dun dun dun http://lpaste.net/5951937181688791040
14:22:37 <ski> hmm
14:22:51 <ski> well, i suppose you're not using a Peano representation for `Nat' ?
14:23:04 <athan> ski: precisely, no I'm using the built-in from TypeLits
14:23:16 <athan> but it shouldn't matter, I'm just making one definition (it's a closed family)
14:23:19 <athan> Succ n = 1 + n
14:23:25 <Gurkenglas> While following the instructions on http://www.haskellforall.com/2016/04/data-is-code.html , during "stack setup"
14:23:30 <athan> however, I still can't apply it through a Map
14:24:22 <athan> for instance: `type family MapOverMaybe (f :: k -> k') (mx :: Maybe k) :: Maybe k' where; MapOverMaybe f 'Nothing = 'Nothing; MapOverMaybe f ('Just x) = 'Just (f x)`
14:24:27 <athan> which  is a sound definition
14:24:40 <athan> but `MapOverMaybe Succ foo` fails because Succ is a macro, as you said
14:24:53 <ski> athan : well, it's a `type family'. not a `data family'
14:24:59 <athan> :O
14:25:01 <ski> the former aren't guaranteed to be injective
14:25:01 <Gurkenglas> (A type family would be a kind morphism. A type function would be a kind morphism of kind * -> *.)
14:25:08 <athan> ski: Yet :)
14:25:24 <ski> perhaps with closed ones, one could get derived injectivity ..
14:25:54 <athan> ski: That's a tricky situation, but with -XTypeFamilyDependencies in type C, I have hope
14:26:12 <athan> I also thought data families just use underlying data structures, don't they?
14:26:45 <ski> you have to declare a new type for each instance of a `data family'. either using `data' or `newtype'
14:26:52 <athan> closed data families? :|
14:27:00 <athan> hm :\
14:27:07 <ski> sorry ?
14:27:21 <athan> but it's still a worthless value, er really I _can't_ have inhabitants
14:27:24 <athan> thanks ski  :)
14:27:52 <ski> i thought you didn't want inhabitants
14:28:06 <athan> that's what I said :s
14:28:11 <ski> oh, i see
14:28:17 <athan> I thought data families force you to have inhabitants
14:28:35 <ski> hm, probably not with `EmptyDataDecls'
14:28:41 <athan> :o
14:28:43 <athan> holy beans
14:28:44 <athan> okay
14:28:58 <ski> but force it to be *inhabitable*, that's probably true
14:29:59 <athan> or I might use Proxy or something :s
14:30:14 <athan> every instance of a data family I see declares data constructors
14:30:15 <ski> well, that has an inhabitant
14:30:28 <athan> `data instance Foo Bar = FooCons ...`
14:30:48 <athan> hmm
14:31:16 <ski> perhaps if a `type family' was known to be injective, it could be partially applied .. hmm
14:31:49 <ski> btw, there's an extension that allows at least ordinary `type' synonyms to be partially applied, as long as they'll get fully applied "in the end" :)
14:32:01 <ski> athan : dunno whether that would help in your situation, though
14:32:15 <athan> hmm, that actually might help. What's the extension?
14:32:24 <ski> let me look it up again
14:33:10 <geekosaur> LiberalTypeSynonyms
14:33:29 <raek> is there an easy way to check if to types are equal in ghci? I known I can do this, for example: ":t id :: String -> [Char]" to verify that String and [Char] are the same...
14:33:31 <athan> thanks geekosaur :) and ski!!
14:33:38 <ski> it's `LiberalTypeSynonym', <http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#type-synonyms>
14:33:58 <ski> consider the example there :
14:34:00 <ski>   type Id x = x
14:34:07 <ski>   type Generic i o = forall x. i x -> o x
14:34:17 <ski> the kind signatures that we get for these are
14:34:23 <ski>   Id :: * -> *
14:34:37 <ski>   Generic :: (* -> *) -> (* -> *) -> *
14:34:57 <ski> now, let's modify this a bit, with some pseudo-Haskell annotations
14:35:29 <ski> in the ordinary way in which type synonyms work, `Id' always has to be fully applied
14:35:41 <ski> we could perhaps indicate this by a type signature like
14:35:49 <ski>   Id :: <*> -> <*>
14:36:01 <OnkelTem> Folks hi. I know I may look like a lazy ass, but how to use stack with PhpStorm + Haskell? It wants Cabal path and path to ghc-mod and ghc-modi. Can I configure it using stack?
14:36:39 <ski> where we think of `Id' as running at compile-time, which when meta-applied to a *value* representing a type *expression* (the `<...>' part of the kind), it generates another such type expression
14:36:46 <ski> for comparision, consider
14:37:02 <ski>   type MyMonad a = ReaderT MyEnv IO a
14:37:08 <ski> well, say
14:37:15 <ski>   type MyMonad t a = ReaderT (MyEnv t) IO a
14:37:19 <ski> to make it more interesting
14:37:26 <cheater> didn't ezyang show something like a type level lambda on his twitter recently
14:37:32 <cheater> you could use this
14:37:44 <ski> with the above convention for describing the "macroness" of a type synonym, its signature would be :
14:38:07 <ski>   MyMonad :: <T> -> <*> -> <*>
14:38:09 <ski> assuming
14:38:10 <athan> here's the mess of stuff I've been trying, this open type family still doesn't work with liberal type synonyms :\
14:38:13 <athan> http://lpaste.net/161427
14:38:22 <athan> hmm
14:38:36 <ski>   MyEnv :: <T -> *>  -- an ordinary datatype, say
14:38:44 <athan> cheater: well, type level lambdas work for newtypes and other type constructors
14:38:52 <ski> we can't partially apply `MyMonad'
14:38:57 <athan> do you happen to have the link though? Just so I'm not stepping on toes?
14:39:05 <ski> but, as you probably know, if we "eta-contract" the definition into
14:39:12 <ski>   type MyMonad t = ReaderT (MyEnv t) IO
14:39:20 <ski> then we don't have to supply the last argument
14:39:30 <athan> ski: yes! I've seen that! hmm
14:39:35 <ski> the corresponding type signature, under this "macro" explanation would be
14:39:38 <ski>   MyMonad :: <T> -> <*> -> <*>
14:39:40 <ski> er
14:39:44 <ski>   MyMonad :: <T> -> <* -> *>
14:39:54 <athan> ahh! wow hmm
14:40:08 <athan> where <..> are macro application demands
14:40:17 <ski> because you must meta-apply it to a type expression of kind `T', and then you'll already get back another type expression (of kind `* -> *')
14:40:36 <ski> as opposed to the earlier version, which demanded another type expression argument, before yielding back a complete type expression
14:40:45 <ski> athan : i hope the idea gets through
14:40:51 <athan> I think so
14:41:01 <ski> anyway, let's return to
14:41:02 <ski>   type Generic i o = forall x. i x -> o x
14:41:04 <athan> so I could do something like... hmm haha
14:41:05 <ski> in the example
14:41:13 <athan> rename `Succ` to `Succ'`
14:41:19 <athan> then just do `type Succ = Succ'`
14:41:20 <athan> lol
14:41:20 <ski> the type signature, using this idea, that we'd normally get for it would be
14:41:36 <ski>   Generic :: <* -> *> -> <* -> *> -> <*>
14:41:54 <athan> crap derp lol
14:41:59 <athan> must... lambda... stuff
14:42:03 <ski> iow, we must give it two type expressions, of kind `* -> *', and it will give us back a type expression of kind `*'
14:42:06 <ski> however, since
14:42:11 <ski>   Id :: <*> -> <*>
14:42:17 <ski> we can't do `Generic Id Id'
14:42:36 <cheater> athan: it's recent on his timeline.
14:42:41 <cheater> also recent on mine.
14:42:43 <ski> because `Id' is a "macro", that expects a type expression as argument before yielding a type expression. it's not itself a type expression
14:42:58 <athan> cheater: what's your handle?
14:43:03 <ski> however, with this *extension*, the effective type signature we get for `Generic' is :
14:43:23 <ski>   Generic :: (<*> -> <*>) -> (<*> -> <*>) -> <*>
14:43:39 <ski> iow, now `Generic' is a *higher-order* macro, taking two macros as arguments !
14:43:53 <ski> so `Generic Id Id' works
14:44:20 <ski> and the reason it works is that in the definition `type Generic i o = forall x. i x -> o x', `i' and `o' *is* (meta-)applied to type expressions (`x' and `x')
14:45:08 <athan> ski: holy crap, okay wow
14:45:15 <athan> thank you so much
14:45:41 <ski> anyway, here i've only used this extra annotations in the kind signatures of type synonyms. i've not added any syntax to explicitly distinguish meta-application of a macro to a type expression (or another macro) from ordinary application of a type function expression to another type expression
14:46:42 <ski> so, if we know `Foo :: <* -> *>', then we also know `Foo :: <*> -> <*>' .. we can treat a type expression as a macro .. but not vice versa
14:47:26 <ski> athan : if you want to, i could show how one could differentiate between meta-application and ordinary type-application, in syntax
14:47:40 <ski> might make it clearer how the different versions of e.g. `Generic' works here
14:48:53 <ski> athan : .. otherwise, i'm happy that this newthought (by me) explanation of this extension made any sense :)
14:49:24 <athan> ski: I think I'll be okay :) thank you though
14:49:42 <athan> I really like your syntax btw, I never really got why the type families never really worked this way
14:50:27 * hackagebot tardis 0.4.1.0 - Bidirectional state monad transformer  https://hackage.haskell.org/package/tardis-0.4.1.0 (DanBurton)
14:51:02 <ski> athan : hopefully this explains the "in the end" part of
14:51:04 <ski> <ski> btw, there's an extension that allows at least ordinary `type' synonyms to be partially applied, as long as they'll get fully applied "in the end" :)
14:51:07 <ski> though
14:54:59 <forker> Hey guys, do I want achieve a wrong thing here: http://lpaste.net/161326 . Can't wrap my head around why most of esqueleto's typeclasses are in *.Internal packages. Am I not supposed to use them? Then how am I supposed to declare constraints?
14:55:28 <athan> is it possible to use unsafeCoerce to.. uh... compensate for skolemization? :D
14:55:31 <ski> athan : fwiw, the idea was inspired by how macros in the lisps (e.g. Scheme) works. and also by how staged computation in MetaML/MetaOCaml works
14:55:53 <ski> (and i've read a paper on "MacroML", which used ideas similar to MetaML, to supply macros)
14:56:09 <ski> athan : compensate how ?
14:56:13 <athan> ski: :O holy crap, okay. More stuff I get to read :)
14:56:24 <athan> ski: obliterate the concept of a skolem variable being ambiguous
14:56:45 <athan> so if I have `data BlackBox = BlackBox (forall a. a)`
14:57:16 <athan> can I use `unsafeCoerce :: a1 -> b` to unify `a1` and `a`?
14:57:17 <athan> :s
14:57:52 <ski> athan : i wish TH was as fun as MetaML/MetaOCaml. when some TH code type-checks, you don't get a guarantee that the code it *generates* will type check. with MetaML/MetaOCaml, you *do* get such a guarantee (unless you specifically use a "dynamically typed expression" variant, for when it's hard to prove to the type system that you'll be generating type-correct code. if you don't, you'll get an exception at code-expansion-time)
14:58:24 <athan> hmm, that's an interesting property. I really dislike TH for that exact reason
14:58:33 <athan> it gives you too much power :\
14:59:33 <ski> (also, i'm not sure TH really is hygienic, at least by default (see macro systems in Scheme for hygiene))
14:59:45 <EvanR> forker: it is reexported
15:00:38 <ski> (short version : hygiene means that macros use lexical/static scope, instead of dynamic scope. so e.g. you can have a module exporting a macro which will expand into code referencing operations of that module which aren't exported)
15:01:27 <forker> EvanR: what do you mean? `From` typeclass is esqueleto's own definition..
15:01:37 <ski> (the code template in the macro, that will be instantiated on macro call, may reference locally defined identifiers, through static scope)
15:01:40 <EvanR> athan: at least the code still has to typecheck after TH
15:02:03 <ski> athan : a value of type `forall a. a' must be `_|_'
15:02:29 <ski> athan : but obviously you can use `unsafeCoerce' to convert between two different skolems, e.g.
15:02:33 <EvanR> forker: i mean is it reexported from whatever (esqueleto) module that uses the internal module
15:02:40 <EvanR> since youre looking at the code already
15:02:55 <ski> athan : it's hard to say more, since your example didn't make much sense to me
15:02:55 <EvanR> if so, just import that module
15:05:49 <HighZen_> Hi
15:06:03 <thoughtpolice> ski: Doesn't Typed Template Haskell change that a bit? You now have typed quotes, so you can't do something nonsensical like "[| not $x, length $x |] :: Q Exp", if you're using them.
15:06:29 <thoughtpolice> (Granted, most people still use the untyped variant, but now you can do some forms of type-safe runtime specialization, etc)
15:06:36 <ski> thoughtpolice : possibly. i haven't looked at it for some while
15:07:40 <ski> thoughtpolice : though it doesn't look like the result type of the generated expression appears in the type of the quotation ?
15:07:59 <forker> EvanR: that's the thing it is declared and exported by an *.Internal module. There is no re-export. Even when I ask PartialTypeSignatures it infers the same constraints (with Internal-s).
15:08:19 <ski> athan : afaiu, with my syntax above, your code would get signatures :
15:08:27 <Ohso_> Is there a good place to find haskell tutorials that use small real-world programs instead of isolated code snippets? I'm trying to learn haskell by writing a particular application that I've written in different languages as a learning tool. Typically when I run into a roadblock I just google for an example of how to do what I want, but that is proving frustratingly fruitless with haskell.
15:08:28 <ski>   Succ :: <Nat> -> <Nat>
15:09:22 <ski>   MapMaybe :: forall k0 k1. (<k0> -> <k1>) -> (<Maybe k0> -> <Maybe k1>)
15:09:48 <thoughtpolice> ski: You mean in my example? That's the old syntax, there's a separate syntax for the new form: http://gmainland.blogspot.com/2013/05/type-safe-runtime-code-generation-with.html
15:10:03 <ski>   IndexOf :: forall k. <k> -> <[k]> -> <Maybe Nat>
15:10:12 <nitrix> Is it possible to wait (blocking) on two MVar without using some async contraption?
15:10:31 <ski> which seems to make sense with the actual definition bodies as well, i think
15:11:02 <ski> athan : possibly it's just bad (or nonexisting) interaction between type families and liberalized type synonyms
15:11:31 <ski> thoughtpolice : oh, that looks better :)
15:11:45 <forker> EvanR: if you look here https://github.com/prowdsponsor/esqueleto/search?q=From . `From` is only exported by Database.Esqueleto.Internal.Language .
15:12:28 <thoughtpolice> nitrix: Not really, and using MVars for dealing with multiple values is generally frowned upon, since it's relatively error prone to race conditions (the actions themselves are atomic, but do not compose atomically). MVars are nicer than IORefs, but not by a huge amount.
15:12:57 <thoughtpolice> nitrix: The general recommendation is to use STM in those cases
15:13:21 <EvanR> forker: maybe you arent supposed to use this class?
15:14:22 <Lokathor> nitrix, you're describing one of the exact signs that you should switch from MVar to TVar
15:14:54 <nitrix> Lokathor: Almost but no.
15:14:58 <forker> EvanR: that's exactly what I'm thinking. But how am I supposed to describe constraints on wrapping function?
15:15:08 <Lokathor> nitrix, ?
15:15:25 <nitrix> Lokathor: https://github.com/nitrix/pstash/blob/master/src/Main.hs
15:16:00 <nitrix> Lokathor: I want to write a crawler, many crawlers actually, and have them write to an MVar that does the printing.
15:16:13 <EvanR> forker: sorry i dont know esquelto
15:16:22 <Lokathor> first question, why don't they just write straight to stdout?
15:16:36 <nitrix> Lokathor: Because otherwise the input is interleaved.
15:16:42 <nitrix> mixed or whatever.
15:16:44 <nitrix> *output
15:17:26 <Lokathor> nitrix, https://hackage.haskell.org/package/stm-containers-0.2.10/docs/STMContainers-Map.html
15:17:27 <nitrix> Lokathor: "aaaaaaaaaaaa" and "bbbbbbbbbbbb" would print as "aaaabbbaaababaabababa"
15:18:00 <Lokathor> have a (Map URL Output) value that everyone writes their results into
15:18:09 <nitrix> No.
15:19:00 <nitrix> There's not multiple crawlers per url, the only contended resource is the stdout.
15:19:05 <forker> EvanR: thanks for the help anyway :)
15:19:37 <nitrix> Lokathor: And I've solved this problem already, as this naive code demonstrate.
15:19:51 <thoughtpolice> nitrix: If you only need one reader on the stdout, then an MVar is fine (not sure where the second MVar you mentioned comes into play?) Multiple threads will (fairly) submit things into the MVar, as needed, so it's basically just a 1-place queue.
15:19:55 <Lokathor> nitrix, each crawler writes their data into the map via STM transactions, once they're all done you have your results and you can dump them to stdout or wherever
15:19:59 <thoughtpolice> Where does the second mvar come in you need to synchronize with?
15:20:21 <nitrix> Lokathor: But that means you have to wait for their result to print.
15:20:23 <ski> thoughtpolice : ok, i see they even reference MetaML in the link :)
15:20:52 <Lokathor> nitrix, well you could use a TChan then, if you want each complete result to print as soon as possible
15:21:14 <nitrix> Lokathor: MVar is fine. I wish you'd stop cutting me and let me explain what I'm trying to achieve.
15:21:17 <thoughtpolice> (Of course, you still need to be careful with the reader, because if an exception is thrown in the reading thread, you'll get a full deadlock.)
15:21:20 <nitrix> It's not concurrency the issue, it's GHCI.
15:22:21 <nitrix> I've solved part of it by bounding the printer to a physical OS thread so that GHCI's prompt doesn't mess up the output, giving me a blocking behavior for printing, yet the crawling itself is done async.
15:23:02 <nitrix> But I realise now it's pointless to explain what I want to achieve when I could just work on solving it.
15:23:19 <nitrix> Especially seeing how unproductive this has been so far.
15:23:45 <Lokathor> not trying to cut ya, just trying to give STM alternateives, because MVar is pretty error prone even for pros, and STM is far, far less error prone
15:24:18 <EvanR> different tools for different things
15:24:51 <athan> I wish we could add different constraints to an expression based on the code path we take at the value level :s
15:25:15 <athan> putrid constrainability :D
15:25:59 <Cale> athan: Are you basically just asking for dependent types?
15:27:51 <athan> ...or assisted deducability :D
15:28:01 <athan> Cale: Dependent... constraints :D
15:28:29 <EvanR> you could also just put a lambda calculus in the type checker
15:28:33 <EvanR> and be damned!
15:30:40 <athan> EvanR: :E
15:33:00 <maerwald> @hoogle Monad m => (a -> m Bool) -> [a] -> m [a]
15:33:02 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
15:33:02 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:33:02 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:33:16 <maerwald> weird there is no dropWhileM/takeWhileM?
15:33:29 <EvanR> monad-loops
15:34:38 <EvanR> so i tried pretty-show package to get a nice dump of a big nested data type
15:34:48 <EvanR> of the sort youd expect in whatever language
15:35:04 <EvanR> it works pretty well except ... its not that pretty :(
15:35:27 <EvanR> is thre a more obvious pretty show
15:36:30 <Lokathor> maerwald, some of the monad controls you'd like just don't happen to be in there :/
15:36:44 <EvanR> it formats pairs weird, it adds extra space on the left and right of every , and ( and [ and ] and )
15:36:53 <maerwald> already wrote a bunch myself, but seems monad-loops helps too
15:37:18 <EvanR> and { and }
15:37:20 <athan> http://stackoverflow.com/questions/36852281/overcoming-skolemization-via-unsafecoerce
15:37:28 <athan> some food :D
15:37:33 <Lokathor> whenM is one that I thought would've been obvious
15:37:43 <EvanR> what is whenM
15:37:55 <EvanR> :t guard
15:37:56 <lambdabot> Alternative f => Bool -> f ()
15:38:00 <Lokathor> whenM :: m Bool -> m a -> m ()
15:38:22 <Lokathor> like when, but it just unwraps it for you
15:38:42 <maerwald> whenM mb a = mb >>= (`when` a)
15:38:54 <Lokathor> yeah
15:38:55 <EvanR> (execute a monad action = unwrapping... still do not understand this)
15:39:24 <Lokathor> you don't understand why people think that?
15:39:33 <maerwald> he does, he just pretends he doesn't
15:39:43 <EvanR> is it that common?
15:40:01 <maerwald> executing a monad action can be thought of being wrong in the same sense as unwrapping is wrong
15:40:03 <EvanR> im into precise language, so unwrapping is standing out to me as really out of place
15:40:03 <maerwald> so there's no point
15:40:12 <Lokathor> i think the REAL answer is that "execute a monad action" is four words, and "unwrap" is one short word
15:40:24 <EvanR> well unwrapping at least has an intepretation and execute doesnt
15:40:24 <maerwald> and both are wrong if you go nitpicking anyway
15:40:29 <EvanR> and the interpetation is wrong
15:40:42 <EvanR> Lokathor: ok
15:41:31 <EvanR> maerwald: i had to refer to what unwrapping was referring to in some way that wasnt unwrapping
15:41:58 <maerwald> I have no idea what you are talking about or how it helps the discussion :P
15:42:00 <EvanR> binding doesnt mean much to me anyway
15:42:04 <athan> You know what we really "need"? `unsafeUnskolemize`
15:42:06 <Lokathor> when you use <- in a do block with an (m a) value, you get an a on the left hand side. The m context is temporarily "all aound you" in a sense, rather than "around" the 'a' as an "m a".
15:42:42 <maerwald> sometimes this haskell-style nitpicking can get annoying, but haskellers like to come off smart :P
15:42:48 <EvanR> ah unwrapping means remove from the type expression, not the value
15:43:17 <Lokathor> well i can't speak for everyone, but that's what i mean by it
15:43:17 <EvanR> maerwald: yes "i do not understand" comes off as smart
15:43:24 <Lokathor> it's a poetic meaning, not a highly technical one
15:43:37 <EvanR> only in the world of "oh, no matter how much nonsense you speak i get it, dont ask for details"
15:44:06 <maerwald> EvanR: just because someone says "I do not understand" doesn't mean he actually does not ;)
15:44:18 <EvanR> i actually did not now i learned something
15:45:28 <athan> or {-# UNSKOLEMIZE #-}, to basically rip apart any assumptions about type inference
15:45:45 <athan> so `data BlackBox = BlackBox {-# UNSKOLEMIZE #-} (forall a. a)`
15:46:00 <athan> and that would mean that `a` is _not_ just in this scope, but in the top level scope as wel
15:46:03 <athan> well*
15:46:32 <athan> so we I deconstruct `foo (BlackBox x) = ..`, `x :: a` in that this `a` does _not_ cause a fresh variable during unification
15:46:35 <athan> or some shit :S
15:48:07 * Lokathor begins muttering about how monads are the Force... they surround us, penetrate us, and bind all our expressions together...
15:48:26 <EvanR> gross
15:49:22 <maerwald> Lokathor: only if you implement them... it's just a class after all
15:49:30 <EvanR> @djinn IO Bool -> IO () -> IO ()
15:49:30 <lambdabot> Error: Undefined type IO
15:49:44 <EvanR> @djinn Monad m => m Bool -> m () -> m ()
15:49:44 <lambdabot> f _ a = a
15:50:12 <Lokathor> maerwald, well, within the context of GHC, main is an IO value, and IO implements Monad, so the joke holds up well enough
15:50:32 <EvanR> and hopefully you get out of IO as soon as possible
15:50:50 <Lokathor> I suppose some sort of haskell-like language could treat things differently... main :: [String] -> String or something
15:51:09 <maerwald> Lokathor: IO is a lie, it does nothing without an RTS
15:51:09 <EvanR> haskell used to be like that, lazy list IO
15:51:21 <EvanR> i heard it was awful
15:52:40 <maerwald> @hoogle (Monad m, Traversable t) => m (t a) -> (a -> m b) -> m (t b)
15:52:40 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
15:52:41 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:52:41 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
15:52:50 <maerwald> again, it's missing :/
15:53:09 <Lokathor> maerwald, you and I know that secret detail about tartarus, but within the world of haskell it's a forbidden secret that you have to play along with
15:53:36 <EvanR> basically youre all asking for a function that does a monad action before another
15:53:42 <maerwald> well, I could use mapM and feed it via =<<
15:53:48 <maerwald> yes
15:54:12 <Lokathor> maerwald, i'm not clear on what actions you want to have happen when
15:54:14 <EvanR> so come up with the type sig for THAT and implement it once and for all
15:54:26 <maerwald> ?
15:54:40 <EvanR> for a given monad-loop, make the first argument be the result of a monad action instead of "pure"
15:54:59 <maerwald> I've already implemented it. I don't know what you are talking about
15:55:12 <EvanR> what exactly?
15:55:59 <EvanR> i was talking about a combinator to solve all future requests of this form
15:56:15 <maerwald> @type \a f -> mapM f =<< a
15:56:17 <lambdabot> (Monad m, Traversable t) => m (t a) -> (a -> m b) -> m (t b)
15:56:19 <maerwald> there
15:56:36 <EvanR> i guess =<< is that combinator
15:57:22 <maerwald> but writing that explicitly sucks if the (a -> m b) thing is the longer one, so it makes sense to have forMA or something
15:57:54 <EvanR> a >>= mapM $ \x -> do
15:58:14 <EvanR> something
16:03:25 <Lokathor> i usually write it, forM [list expression] $ \iterationVars -> do
16:03:31 <Lokathor> but that's a differnet sort of action i suppose
16:05:59 * hackagebot th-reify-many 0.1.4.1 - Recurseively reify template haskell datatype info  https://hackage.haskell.org/package/th-reify-many-0.1.4.1 (MichaelSloan)
16:06:01 * hackagebot bond 0.4.0.2 - Bond schema compiler and code generator  https://hackage.haskell.org/package/bond-0.4.0.2 (chwarr)
16:06:39 <maerwald> Lokathor: it's 2 lines anyway because of the length, so do-notation is actually easier to understand here
16:07:35 <Lokathor> well i formatted it like this for example, https://github.com/Lokathor/ludolib/blob/f1f770241cb54861df83281f005ff50475c54443/src/Util/AutomataGen.hs#L172
16:07:57 <EvanR> GenericPretty looks better
16:08:07 <Lokathor> GenericPretty ?
16:08:16 <EvanR> for pretty printing nested values
16:08:21 <maerwald> Lokathor: it looks a little bit dense
16:08:29 <maerwald> [(x-1,y-1),(x-1,y),(x-1,y+1),(x,y-1),(x,y+1),(x+1,y-1),(x+1,y),(x+1,y+1)]
16:08:31 <maerwald> boy... :D
16:08:37 <maerwald> whitespace plz
16:08:43 <EvanR> 3x3 grid plz
16:08:47 <maerwald> or that
16:08:59 <Lokathor> yeah yeah i will get to some cleanup on that
16:09:13 <maerwald> do we have good code formatters for haskell that don't screw up?
16:09:25 <maerwald> I know good code formatters for C, but C syntax is ez
16:09:26 <Lokathor> but that and other changes got a 2s runtime down to like a 0.15s runtime
16:09:42 <Lokathor> and then i had hit a GHC bug by then and lost momentum
16:09:47 <mgsloan> maerwald: hindent does a pretty good job, but isn't perfect
16:10:05 <maerwald> mgsloan: is that what this vim plugin uses?
16:10:17 <Lokathor> maerwald, if you look at atRange1 for example, it's in 3d
16:10:27 <Lokathor> (line 278)
16:11:11 <maerwald> I use this https://github.com/neovimhaskell/haskell-vim but the autoindenting is simply horrible and often wrong
16:12:27 <maerwald> oh https://github.com/itchyny/vim-haskell-indent
16:13:20 <Denommus> guys
16:13:27 <Denommus> does anyone here work with hxt?
16:13:49 <Denommus> I'm confused about something
16:14:22 <Denommus> I have a XML Document that should produce a [Foo], where Foo = Foo { bar :: String, baz :: [Int] } (for instance
16:15:48 <Denommus> so, I'm doing something like `deep (isElem >>> hasName "foo") >>> proc x -> do { bar <- getData "bar"; baz <- ????; returnA -< Foo bar baz }`
16:16:09 <Denommus> where getData param = getText <<< getChildren <<< deep (hasName param)
16:16:27 <Denommus> I have no idea how to get the baz list, though
16:16:50 <EvanR> (isnt <<< just .)
16:17:06 <jle`> EvanR: for the (->) instance yes
16:17:11 <jle`> but, it also has different fixity
16:17:56 <EvanR> for a minute lambdabot had (.) :: Category a b c => ...
16:18:09 <jle`> ah yes that was a thing too for a while ._.
16:18:41 <Denommus> EvanR: yeah
16:18:42 <jle`> but yeah, (<<<) = (Control.Category..), except with a different fixity, so it's not necessarily always a drop-in replacement
16:18:42 <hpc> i miss uber-flip
16:18:44 <hpc> :t flip
16:18:45 <lambdabot> (a -> b -> c) -> b -> a -> c
16:18:56 <Denommus> but what about my doubt?
16:19:21 <EvanR> oh jeez, arrow notation
16:19:55 <hpc> :t fmap (flip ($))
16:19:56 <lambdabot> Functor f => f a -> f ((a -> c) -> c)
16:20:02 <hpc> no that wasn't it
16:21:09 <ClaudiusMaximus> :t strength  -- hpc, was it something like this?  seems to ring a faint bell in the back of my mind..
16:21:10 <lambdabot> Not in scope: ‘strength’
16:21:42 <ClaudiusMaximus> @hoogle strength
16:21:42 <lambdabot> No results found
16:22:29 <hpc> it was like
16:22:44 <hpc> Functor f => f (b -> c) -> b -> f c
16:22:57 <hpc> :t \fs a -> fmap ($ a) fs
16:22:58 <lambdabot> Functor f => f (a -> b) -> a -> f b
16:22:58 <hpc> aha
16:23:21 <hpc> and Prelude.flip = uberFlip{f = ((->) c)}
16:25:35 <ClaudiusMaximus> oh, looks like strength is something different anyway, to do with tuples
16:25:43 <hpc> ClaudiusMaximus: as in profunctors?
16:26:16 <hpc> those smell like better arrows
16:26:19 <ClaudiusMaximus> something like f(a,b) -> (a,f b) or so
16:26:40 <hpc> except not, heh
16:26:43 <hpc> just saw dimap
16:26:59 <ClaudiusMaximus> nope, the other way around, oops
16:56:01 * hackagebot yesod-auth-account 1.4.2 - An account authentication plugin for Yesod  https://hackage.haskell.org/package/yesod-auth-account-1.4.2 (JohnLenz)
16:57:03 <Lokathor> so with OverloadedStrings, does a declaration like foo = "hello" :: Text get computed at compile time and then the binary form of that data get put into the resulting executable's data section?
16:57:19 <Lokathor> or does the string get put in and then have fromString called on it?
16:58:10 <Axman6> I believe the latter
16:58:21 <Axman6> "foo" gets turned into fromString "foo"
16:58:35 <maerwald> what I'm not sure about it is whether it does funny encoding stuff or not, so I usually try to avoid it, at least for ByteString
16:58:53 <maerwald> and since it utterly "breaks" GlibString... 
16:58:55 <Axman6> but constant Strings are stored as C strings in the compiled binary anyway (you can run strings over it to verify)
16:59:44 <nitrix> Given `f :: String -> IO Bool`, and a `[String]`, how can I apply each computation, collect the results, but stop at the first `:: False` ?
17:00:28 <nitrix> traverse would inconditionally do all of them.
17:00:34 <Lokathor> so.. the results will be a list of trues, and possibly one false at the end?
17:01:00 <nitrix> Lokathor: Or in the middle, which, I want to be the end, yes.
17:01:03 <EvanR> writing your own control flow operators for fun and profot
17:01:15 <Lokathor> sounds like you want a lifted form of all
17:01:16 <EvanR> prifot
17:01:26 <nitrix> Lokathor: I'm not interested by the values themselves, the most important part is not carrying out the side effects past that False.
17:01:40 <Lokathor> yeah, custom loop sounds like the way to go
17:01:45 <EvanR> nitrix: this is sort of untilM
17:01:49 <nitrix> I looked at msum / MonadPlus / EitherT gizzmos...
17:01:51 <EvanR> or whileM
17:02:01 <nitrix> whileM might work.
17:02:58 <nitrix> I'm surprised this isn't more common.
17:03:29 <Lokathor> artisinal control flow can't just be put in some ~package~ man
17:03:43 <Lokathor> it's not some corporate thing, gotta let it run ~free~
17:12:38 <jle`> is there any way i can specify an inverse to a unidirectional pattern match?
17:12:52 <jle`> so i can use it as a constructor, as well?
17:13:37 <Lokathor> what is a unidirectional pattern match?
17:14:30 <nitrix> Lokathor: Does that mean that helper can't possible have the constraint Traversable?
17:14:46 <nitrix> Lokathor: Since sequence/traverse will bring back the same problem?
17:14:54 <Lokathor> think so
17:15:10 <nitrix> I'll try foldable.
17:15:12 <Lokathor> might be able to do it with a clever foldr
17:15:15 <EvanR> nitrix: re more common, all these looping strategies are actually very common
17:15:16 <Lokathor> yeah
17:15:22 <koomi> Lokathor: regarding your fromString question: looking at the core for a trivial example, at -O1 and 2 a constant Text object is generated
17:15:25 <EvanR> its just that theres too many different ones
17:15:28 <koomi> -O0 generates the fromString call
17:15:40 <Lokathor> koomi, sweet
17:15:54 <jle`> Lokathor: pattern (x :+ y) <- (x, (sqrt->y))
17:16:05 <jle`> but it'd also be nice to be able to use :+ as a constructor
17:16:08 <nitrix> EvanR: I'm looking for :: Foldable f => m Bool -> f a -> m ()
17:16:16 <nitrix> EvanR: Where it stops on the first False.
17:16:30 <jle`> @let pattern (x :+? y) <- (x, (sqrt->y))
17:16:30 <lambdabot>  Parse failed: TemplateHaskell is not enabled
17:16:32 <jle`> aw
17:16:58 <EvanR> untilM (forM_ xs ...) ?
17:17:03 <EvanR> hmm
17:17:32 <EvanR> whileM check (forM_ xs ...)
17:17:52 <EvanR> :t forM_
17:17:53 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
17:18:23 <nitrix> EvanR: Yeah but wont that run all the actions first if the monad's IO ?
17:18:39 <EvanR> oh
17:18:48 <EvanR> well i was just going by your latest sig
17:18:51 <nitrix> It's the side-effects that I'm worried about.
17:19:08 <nitrix> I want to lazily execute the `m`, which is honestly always going to be IO.
17:19:17 <EvanR> (a -> m Bool) -> t a -> m ()
17:19:19 <EvanR> i thought
17:19:34 <EvanR> also takeWhileM
17:19:34 <nitrix> Nah.
17:20:03 <nitrix> EvanR: The idea is > magicalFoo crawlPage [1..]
17:20:53 <ClaudiusMaximus> (forM_ xs $ \x -> do b <- x ; unless b $ throwIO MyException) `catch` \(e :: MyException) -> return ()
17:20:57 <nitrix> Where the crawling stops at the first unsuccessful page.
17:21:07 <nitrix> ClaudiusMaximus: Exceptions!?
17:21:24 <ClaudiusMaximus> why not?
17:21:27 <nitrix> ...
17:21:59 <Lokathor> nitrix, http://lpaste.net/161554
17:22:24 <Lokathor> the number you get back is the number of successful pages crawled
17:22:50 <nitrix> Yeah it's what I'll roll I think.
17:23:09 <nitrix> Lokathor: Except it's not to count, it's to use with the API's pagination system :)
17:23:37 <nitrix> Which is badly designed and doesn't tell you the amount of items, so you have to keep going until there's an error (yeah...)
17:23:45 <Lokathor> :(
17:29:25 <nitrix> EvanR: Oh damn, you're right.
17:29:41 <nitrix> EvanR: It is (a -> m Bool)
17:32:14 <nitrix> Domain is available....
17:32:17 <nitrix> ......
17:32:21 <nitrix> Whoops.
17:32:35 <nitrix> I'm all sorts of clumsy today.
17:32:46 <lpaste> infinity0 pasted “declaring MonadBase instance for ComposeT” at http://lpaste.net/161555
17:33:22 <infinity0> anyone? ^
17:34:54 <Gurkenglas> :t andM -- nitrix
17:34:55 <lambdabot> Monad m => [m Bool] -> m Bool
17:35:00 <infinity0> oh i got it, just have to add "Monad (f (g m))" to the list of constraints
17:35:09 <Gurkenglas> (from Control.Monad.Loops)
17:35:47 <nitrix> Gurkenglas: Does that short circuit on the first False, not executing the other actions?
17:36:16 <Gurkenglas> If it didn't, it'd be called "Applicative f => [f Bool] -> f Bool" :P
17:36:44 <infinity0> hm, why doesn't MonadTrans generically have a Monad instance?
17:37:15 <Gurkenglas> (Well, okay, it might be wrongly too specialized. But yea it shortcircuits)
17:40:31 <Gurkenglas> infinity0, because every term on the right side of the => of an instance declaration may only appear once, and what you want would look like "(Monad m, MonadTrans t) => Monad (t m)", locking out all other possible instances of monads that were constructed by type constructor
17:42:27 <Gurkenglas> :t allM -- Oh hey nitrix adjusted what type he wants
17:42:28 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m Bool
17:42:35 <infinity0> Gurkenglas: by "locking out", you mean it would make "(...) => Monad (x m)" impossible?
17:42:45 <infinity0> is this the "overlapping instances" thing
17:42:56 <Denommus> gosh, the list monad still confuses the hell out of me
17:42:59 <nitrix> Gurkenglas: Yup!
17:43:00 <Gurkenglas> Exactly. Also everything that has x or m replaced by anything
17:43:12 <nitrix> Gurkenglas: I used void . allM :P
17:43:36 <nitrix> Very cool stuff this monad-loops!
17:44:12 <Gurkenglas> Currently trying to make it obsolete with http://lpaste.net/150858 :D
17:44:48 <nitrix> desperately :P ?
17:44:51 <nitrix> Cute :)
17:45:13 <infinity0> Gurkenglas: cool ok thanks
17:45:54 <Gurkenglas> (All that boolean stuff doesn't fit too well with the library this is trying to become - perhaps I should use an iso between Bool and Maybe ())
17:46:48 <Gurkenglas> enlighten :: Bool -> Maybe (); blind :: Maybe () -> Bool
17:47:20 <Gurkenglas> (enlighten = guard, blind = isJust)
17:51:24 <Gurkenglas> :t (fmap . fmap) isJust . alaf MaybeT traverse_ . (fmap . fmap) guard
17:51:25 <lambdabot> (Monad n, Foldable t) => (a -> n Bool) -> t a -> n Bool
17:52:33 <Gurkenglas> :t fmap isJust . alaf MaybeT traverse_ (fmap guard)
17:52:34 <lambdabot> (Monad n, Foldable t) => t (n Bool) -> n Bool
17:53:52 <Gurkenglas> :t (au (mapping $ iso isJust guard) . alaf MaybeT) traverse_
17:53:54 <lambdabot> (Monad n, Foldable t) => t (n Bool) -> n Bool
18:00:50 <Gurkenglas> :t (under (mapping $ mapping $ iso isJust guard) . alaf MaybeT) traverse_
18:00:51 <lambdabot> (Monad n, Foldable t) => (a -> n Bool) -> t a -> n Bool
18:02:48 <Gurkenglas> :t void .: allM -- and nitrix meant this of course instead of void . allM
18:02:49 <lambdabot> Monad f => (a -> f Bool) -> [a] -> f ()
18:03:04 <nitrix> :t (.:)
18:03:05 <lambdabot> (b -> c) -> (t -> a -> b) -> t -> a -> c
18:03:18 <Gurkenglas> (f .: g) x = f . g x, compare (f . g) x = f $ g x
18:04:46 <nitrix> I think I wrote `void $ allM ...` x]
18:05:23 * nitrix not the best haskeller out there
18:15:45 <sm> how can I declare a type synonym when there are typeclass constraints ? I'm trying: type GenericParser = Stream [Char] m Char => ParsecT [Char] st m
18:19:39 <jle`> sm: the typical normal way is to parameterize your type synonym
18:19:51 <jle`> and then add the constraint where you use it
18:20:15 <sm> yeah I guess so.. there's no way to "embed" the typeclass constraints in the synonym
18:20:22 <jle`> so you'd have type GenericParser st m = ParcsecT [Char] st m
18:20:34 <jle`> and you'd use Stream [Char] m Char => GenericParser st m
18:20:57 <jle`> yeah, not quite.  it's also unclear how it'd really behave, too
18:21:20 <jle`> something that seems very similar but is actaully different is that you can use a RankN type
18:21:36 <jle`> type GenericParser st = forall m. Stream [Char] m Char => ParsecT [Char] st m
18:21:52 <jle`> which means that anything of type GenericParser st has to be able to work for *any* Stream [Char] m Char instance
18:22:00 <jle`> so you can only write it with functions polymorphic over all Stream [Char] m Char
18:22:07 <jle`> which actually might be what you originally have, anyway
18:22:51 <jle`> this would work for you if you never "touch" anything relating to 'm', for instance, other than things you know about it by virtue of it being a Stream [Char] m Char instance
18:23:41 <jle`> sometimes this is what you want
18:23:49 <jle`> but it might not be in your case
18:28:13 <sm> jle`: that's interesting. Yes I have some parsers like Stream [Char] m Char => ParsecT [Char] st m a 
18:29:20 <sm> knowing which ones fit together, and which can be run with which kind of state and monad, has become a problem. I'm trying to make things clear
18:29:47 <sm> er
18:29:58 <sm> thanks
18:33:09 <sm> and sometimes the type of m does matter, so I'd better not mess with forall
18:35:43 <sm> still.. naively it seems like I should be able to define an alias for Monad m => MyParser m
18:49:38 <athan> shoot, is there not an instance of `(Typeable a, Typeable b) => Typeable (a -> b)`? It seems like this class is empty :\
18:52:34 <geekosaur> athan. it's empty because all Typeable instances are generated on the fly
18:52:59 <athan> geekosaur: by on the fly, do you mean for each codebase?
18:53:07 <athan> choot :\
18:53:08 <geekosaur> ghc generates them as needed
18:53:15 <athan> :O woah
18:53:17 <geekosaur> internally
18:53:48 <athan> so it's safe to say that `typeRep (\x -> x)` will return a TypeRep?
18:54:03 <athan> :\ hmm, it's not working on my box
18:54:19 <geekosaur> if it's not polymorpjhuic, it should get a Typeable instance automatically. I know it worked before they made ghc generate them
18:55:08 <athan> oop, yes you're right. Is that a strict property of Typeable? That everything needs to be a concrete type?
18:55:12 <geekosaur> (basically, ghc internally relies on Typeable for typechecking, so allowing people to create their own instances is problematic because they might make one that doesn't do what ghc expects. so these days it generates them itself)
18:55:16 <geekosaur> currently, ytes
18:55:32 <geekosaur> there's ongoing work to make it polymorphic-capable; I don't think it's quite ready yet
18:55:51 <Zemyla> athan: If you want something with a polymorphic type to be Typeable, you need to wrap it in a newtype.
18:57:44 <athan> geekosaur: wow, so if it were polymorphic, wouldn't that entail compatability with rank-n unification capability too?
18:57:47 <athan> That's awesome!
18:58:00 <athan> Thanks Zemyla
18:58:11 <geekosaur> that's a bit above my pay grade, sorry >.>
18:58:37 <athan> hah, thanks :)
19:08:39 <MichaelBurge> Does anyone have any experience using HaXml?
19:32:00 <toph> is there a function with signature `m a -> b -> m (a,b)` ?
19:32:48 <toph> :t (\x -> c >>= (\_ -> return ((),x)))
19:32:49 <lambdabot>     Couldn't match expected type ‘m a0’ with actual type ‘Expr’
19:32:49 <lambdabot>     In the first argument of ‘(>>=)’, namely ‘c’
19:32:49 <lambdabot>     In the expression: c >>= (\ _ -> return ((), x))
19:33:24 <geekosaur> need to specify c somehow or you get the one from simple-reflect
19:33:29 <geekosaur> :t c
19:33:30 <lambdabot> Expr
19:33:31 <toph> :t (\c x -> c >>= (\_ -> return ((),x)))
19:33:32 <lambdabot> Monad m => m a -> t -> m ((), t)
19:35:13 <toph> :t (\c x -> c >>= (\y -> return (y,x)))
19:35:14 <lambdabot> Monad m => m t -> t1 -> m (t, t1)
19:37:53 <toph> is there an idiomatic way to do that?
19:42:55 <lethjakman-l> How do you pack an IsString?
19:43:20 <lethjakman-l> And by pack I mean convert it to a Text. 
19:44:02 <geekosaur> sounds like you're doing something wrong to me
19:44:19 <lethjakman-l> Hrm. 
19:44:21 <lethjakman-l> Probably. 
19:44:59 <lethjakman-l> I'm working with a quasiquoter and it's expecting a (Text, Text), but I've only constrained my input to ToMarkup and IsString. 
19:45:00 <geekosaur> IsString typeclass is about converting String literals to a preferred string-like type. normally you would do just tht and then work with the string-like type you want, not try to convert arbitrary IsString instances
19:45:06 <lethjakman-l> I was trying to make it more flexible. 
19:45:26 <geekosaur> there's no generic unpack mechanism, IsString only specifies fromString :: IsString s => String -> s
19:45:40 <geekosaur> IsString isn;t strong enough for that
19:45:58 <geekosaur> it's one way, String to your instance, it an't convert between different instances
19:46:05 <geekosaur> *can't
19:46:31 <lethjakman-l> Maybe I should just constraint to Text?
19:46:46 <geekosaur> that's what I'd do unless I really had a need to be polymorphic
19:47:09 <geekosaur> and I'd try hard to avoid that need because it can lead you to unexpectedly horrible performance
19:47:38 <lethjakman-l> Making it polymorphic?
19:47:40 <lethjakman-l> OK
19:47:42 <lethjakman-l> That's good to know
19:47:49 <geekosaur> (because something leads the compiler to believe it needs to consitantly convert between String and various IsString instances)
19:47:52 <lethjakman-l> Thank you, I'm still trying to get used to if things need to be generic or not.
19:48:03 <lethjakman-l> That seemed to work like a charm
19:48:06 <lethjakman-l> I made that way too hard on myself. 
19:48:25 <geekosaur> mono-traversable library has this problem, and it doesn't even try to do arbitrary conversions, just provide a generalized interface that can handle one IsString instance at a time
19:49:03 <geekosaur> yehh, trying to be overly polymorphic sounds like a good idea sometimes, but it's usually a mistake. if you don;t *need* the polymorphism, don't.
19:49:26 <lethjakman-l> Do you do a lot of type signatures that are like Text -> Int -> String or whatever?
19:50:00 <lethjakman-l> That's what I have a tendancy towards, but I remember hearing that that's bad at some point. 
19:50:24 <geekosaur> between having to drop type ascriptions in various palces to get the compiler to typecheck, and the compiler generating bad code to try to deal with the polymorphism, it is a good way to annoy future-you (or consumers of your library, if appropriate)
19:51:04 <lethjakman-l> You mean constraining things?
19:51:13 <geekosaur> I should say "bad" in scare quotes; it's not that it;s bad, it's that it can't optimize when it doesn't know what type will be used until runtime
19:52:02 <geekosaur> and it ends up making all calls via indirect lookups in typeclass dictionaries, etc.
19:52:55 <lethjakman-l> What is an ascription?
19:53:43 <geekosaur> e.g. having to add ":: Text" somewhere because otherwise you get a type error because it can't infer which IsString instance to use
20:05:54 <ntnt> why does https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-Error-Class.html#line-154 need undecidable instances to handle "MonadError e m => MonadError e (some transformer m)" ?
20:06:30 <ntnt> this all seems very much so decidable to me
20:07:13 <numberten> wrote a cute little function, wondering if there is a nicer representation (possibly w/o explicit recursion) http://lpaste.net/161581
20:07:40 <lethjakman-l> geekosaur: Thank you for explaining that. 
20:08:13 <dmj> ntnt: m is occurs more often in the instance head
20:08:44 <dmj`> ntnt: take 'instance Show b => Show Foo where show = const "Foo"'
20:08:52 <dmj`> b here isn't specified and there undecideable
20:08:56 <dmj`> therefore
20:09:01 <ntnt> dmj`: sorry, why is that undecidable
20:09:07 <ntnt> it seems like we don't care what b is, we also do the same op
20:09:28 <ntnt> is this "undecidable" as in "complexity theory undecidable" or just "undecidable due to impl of ghc" ?
20:09:43 <ntnt> the word "undecidable" brings back memories of halting problems
20:09:52 <ntnt> but I don't see how typeclasses can be used to simulate turing machines
20:11:46 <geekosaur> ghc insists on being able to resolve things to concrete types at some point. since b is not used there, it cannot fully resolve the type (that it's not used doesn't matter. see "phantom types" for why such things can be useful in certain circumstances)
20:12:15 <ntnt> geekosaur: this makes sense
20:12:47 <ntnt> geekosaur: is the following restatement correct? :: "behaviour of function = decidable", but "which type b is = undecidable" , and ghc requires all types be decidable
20:12:57 <ntnt> so "UndecidableInstances" is saying "some type var is undecidable"
20:13:02 <geekosaur> tl;dr: you can tag something with a type that is not used in the value, just to be able to keep unrelated things from being combined. simple units management libraries do this, for example, so you don;t try to add liters and cm together
20:13:44 <ntnt> okay, this doesn't sound nearly as bad
20:13:56 <ntnt> UndecidableINstances, initally sounded like compilatino could be infinitely long due ot ghc trying to solve the hlating problem
20:14:24 <geekosaur> in theory it could. in practice there's a limit where it throws an error instead; but there are ways to remove the limit and then compilation could sometimes never finish
20:17:04 <shachaf> Turning on UndecidableInstances doesn't allow *only* the instances that nonterminate.
20:17:19 <athan> Does the `Fingerprint` in `TypeRep` serialize the value supplied, too?
20:17:30 <athan> when using `typeOf`? Er.. wait... derp
20:17:31 <athan> shoot
20:17:33 <athan> hmm
20:17:53 <athan> Is there a way to serialize values and cast them to a type, dynamically?
20:18:12 * athan just saw `typeRep` taking in Proxy, derp
20:18:54 <o`connor> numberten: iterate_alternate f g a = a : f a : (iterate_alternate f g (g $ f a))
20:19:19 <athan> Herp, `toConstr` ><
20:19:22 <athan> sorry yall
20:19:39 <geekosaur> .oO { aeson? }
20:19:43 <numberten> o`connor: ah yes
20:20:33 <numberten> o`connor: i don't know why I didn't see that -- thanks :)
20:21:50 <pavonia> So for MonadError, what would an instance look like that does satisfy the coverage condition?
20:22:44 <pavonia> Ah wait, never mind
20:23:03 <o`connor> numberten: you're welcome :) 
20:29:31 <Aki-dono> :t fmap reverse getLine
20:29:32 <lambdabot> IO [Char]
21:41:14 <athan> Does Fingerprint in Data.Typeable properly serialize all the type data, to the degree that it's reasonably unique for any given type?
21:43:59 <athan> Likewise, is there a serializable key for given constructors of a type, like Constr?
21:44:11 <athan> I'm just worried that `Constr` might contain more data that necessary for indexing
21:44:59 <athan> and by indexing, I mean such that if I have some `Map Foo Constr`, what is a morphism `Constr -> Foo`, and likewise what is a Foo that is reasonably space efficient and low-level, like Int?
21:48:54 <athan> hmm, Fingerprint seems to uniquely identify types reasonably :)
22:00:14 <mgsloan> Note that Fingerprint includes package hashes
22:00:33 <mgsloan> So if any of the transitive deps set changes, your fingerprint changes
22:16:47 <nut> is Haskell list a build-in data type?
22:17:55 <liste> nut: the operators [] and : have some special rules, but you can define an equivalent type yourself
22:18:25 <liste> @let data MyList a = MyNil | MyCons a (MyList a)
22:18:26 <lambdabot>  Defined.
22:19:03 <nut> so these are equivalent in every sense?
22:19:03 <liste> MyNil is equivalent to [], and MyCons is equivalent to (:)
22:19:13 <nut> i mean in terms of performance for example
22:19:59 <nut> will they be translated into the same lower level c code ?
22:20:06 <liste> nut: yes, apart from GHC's fusion rules for some functions like map, filter etc..
22:23:24 <liste> but I think (?) you can implement them yourself too
22:25:39 <broma0> is there a typeclass somewhere for the super-general `a -> b -> c`? something like `class Apply a b where apply :: a -> b -> c`?
22:26:45 <broma0> is there a typeclass somewhere for the super-general `a -> b -> c`? something like `class Apply a b c where apply :: a -> b -> c`?
22:29:08 <EvanR> what sort of laws would Apply have 
22:29:31 <broma0> I dont know, the thought just popped into my head
22:31:16 <broma0> maybe the class should be called `Combine a b c` and read "combine an `a` and a `b` to produce a `c`"
22:32:12 <shachaf> How about the super-general class Thing a where thing :: a
22:32:47 <EvanR> https://hackage.haskell.org/package/acme-all-monad
22:33:48 <broma0> alright alright
22:35:04 <o`connor> broma0: maybe you could read about Arrow
22:35:06 <EvanR> class Java2 a where method :: Object -> Object -> IO Object
22:35:47 <o`connor> broma0: https://wiki.haskell.org/Typeclassopedia#Arrow
22:37:39 <broma0> o`connor: exactly what i was looking for. thanks
23:25:22 <akfp> The Except documentation in mtl refers to Control.Applicative.Lift.Errors when one wants to collect all errors.  Where can I find an example where Errors is used?
23:54:49 <leeJenks> Hello to all
23:55:19 <alecbrick> hi.
23:56:17 <leeJenks> trying to get a feel for the env, relatively new to irc 
23:56:17 <liste> hi leeJenks!
