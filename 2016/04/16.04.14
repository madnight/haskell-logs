01:15:02 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
01:15:02 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
01:15:02 --- names: list (clog bgamari sigma914 Mon_Ouie erikd osa1 vikraman ChongLi marr Gurkenglas oberstein simukis_ jack_rabbit pikhq paldepind no-n edwinvdgraaf jedws latk jre2 Ariadeno davl thetallguy Klumben Iskarlar terlar hk238 path[l] jgt1 prohobo pacak kolko lonokhov nomeata drdo t595 silver angerman wolfcub Moggle djapo numee krgn` hzjd laz oish mfukar madgen phanimahesh SenpaiSilver raichoo skarn solrize kvda BartAdv frangor wildsebastian Jonno_FTW albertid Freundlich)
01:15:02 --- names: list (jesuspv13 caumeslasal kilburn_ jesuspv mattyw DavidGuru nineonine rydgel ner0x652 leat1 chattered nbouscal cyphase __uu__ bartavelle jinblack Forkk tdammers cnr phuu grol Liskni_si esssing staffehn Xorlev sbauman alexlord ldbrandy NemesisD bitonic mno2 averell Arguggi micmus Kavec ps-auxw dented42 nille CurryWurst zipper mikeplus64 Draggor bananagram cyberlard happy0 rtur sparr julm cjwelborn sebbenbear kjnilsson darkf LordBrain cynick pyon mzf xacktm)
01:15:02 --- names: list (schjetne MK_FG hsyl20 geppettodivacin S11001001 ocharles_ ernst Reite gfixler wvdhaute sleblanc Raynes hbar TimWolla byorgey ryoia sbrg mt Chunlea nurupo tjbp Ranhir Gothmog_ andreass mnoonan magthe isocliff SolarAquarion hodapp castlelore icedev kurnevsky djanatyn Arch-TK dxld Xandaros toure wedify ralu RageD gthorslund chris2 valdyn Rodya Diabolik proteusguy lstrano m0li oherrala Skuzzzy JoshS srenatus solatis urdh metaf5 PierreM idupree MindlessDrone)
01:15:02 --- names: list (benl23 karls hiratara cdidd mirsal M-Quora Cerise spion_ quchen clion- Vbitz mounty lpsmith Morgawr uwap_ Frankablu_ Coldblackice adamCS jedavis edwardk t0mb0_ cschneid_ wolf_moz- themagician huonw_ Walther vin-ivar otulp sdx32 sLite_ carter-znc pi____ eyck_ FreeBird_ stass ]OLI[ sdboyer_ garphyx poga_ ploop_ mj12` ahihi horatiohb statusfa1led Sam___ andreas313 saiam_ slomo_ mceier mountain1 nobag_ optocoup1er brisbin_ amharc_ ayako jrp6_ jgornick_ luigy_)
01:15:02 --- names: list (mikecaruso monty Bigcheese_ jargon-_ flux badon Wizek SegFaultAX shangxiao NeverDie Khisanth danvet x77686d raduom edsko Apocalisp flyingfoxlee Wizek_ etabot jutaro Reshi xelxebar ztennix zoran119_ neoncontrails cgfbee pfeyz Nilabhra jhrcek marens kini supernullset slick justanotheruser eklavya sternenseemann godel igniting a3Dman sujeet Sonderblade _ashbreeze_ Jesin bind bencryption nisstyre Proteus_ pharaun d3lxa fingerzam1 mrlase ido yorick xaimus bydo)
01:15:02 --- names: list (mrshoe tnks rofer chu Yaiyan pavonia sword_smith CindyLinz majjoha pm52 ebzzry M2tias mjrosenb Zemyla brennie Spherica1Cow quicksilver Bez_ obadz Factionwars joof subfactorial1 horlicks vodkaInf1rno gdsx dmag_ texasmynsted_ cognominal_ staticfox DustyDingo fengshaun bsima watersoul_ apo__ vlatkoB keer4n AndreyG dan_f drbean hamishmack _sjs otto_s_ yusukesuzuki wto lkba bluepixel tzh roconnor_ Goplat Guest63808 Nimatek hexagoxel lspitzner exferenceBot)
01:15:02 --- names: list (andyhuzhill hucksy_ bhiliyam alunduil crank1988 herzmeister binaryplease vili_ avn Lemmata phileas Zekka inr Sgeo_ jix ross__ LnL rootnode zero_byte Rotaerk lyuha i-amd3 markus1189 predator217 connor_goodwolf Amnez777 monochrom Igloo telser zariuq ph88 plutoniix fkurkows1 niko nakal__ puregreen nesqi Quashie ibid Shou aarvar mauke Fullma Simson-san ype spacebug isenmann zymurgy kishar opios scopedTV mpereira gniourf maybekoo2 goodboy Jinxit coeus eldon)
01:15:02 --- names: list (whiteline Guest18995 Guest87374 andromeda-galaxy jbalint tetheno zerowidth Cathy bsmt whoops nont_ stelleg Maxdamantus SHODAN jaaket raek andrewsw pleiosaur zhulikas v_g Tourist dixie seagreen felher thunderrd_ Strout freekevin barrucadu Profpatsch tv a6a3uh LeaChim nkaretnikov tusj Nivim alx741 tristero danharaj m4lvin saml Belgarion0 uikkusu mjo ReinH Tesseraction wedens runde benzrf Willis Chobbes Natch martinbjeldbak cfloare doubling tomjaguarpaw arkeet)
01:15:02 --- names: list (swhalen fiddlerwoaroof BillyIII joehillen unsymbol_ __name__ joeytwiddle_ callumacrae Slush-_ maerwald_ simony octo_ ReyuZenfold kosmikus marmalod1 earthy_ rvncerr Marqin_ cmn_ nathanic AndroidVaan_ zyoung xplat_ mgaare_ mokus_ `0660_ cdk_ dino-_ pyrtsa funfun_ joshc angseus_ quuxman_ arrdem_ abby osfameron d-snp ski dalcde_ bjobjo kaol cheater leftylink dkibi_ bd__ Ralith_ benjamincrom chaptast- hydraz gridaphobe tuple_cat bob_vh noam_ fractalcat augur)
01:15:02 --- names: list (StoneToad lassulus dschoepe qz dtulig nicola tailgate Guest85557 spill dredozubov mw thimoteus gnusosa \u Kristler ClaudiusMaximus pfoetchen keft Voldenet bengt_ alphonse23_ l3france_ folsen m1dnight_ tarcwynne_ etcinit lacrosse infinity0 justicefries joedevivo Scorchin bgyss PotatoGim Kneiva reem Sornaensis WizJin acro mudfog edwtjo_ MichaelBurge_ pontus cursork Horv_ Reiser richi238 int-e tromp_ mathu_ kav_ alk ramatevish jstimpfl1 z-nexx_ jackhill dju)
01:15:02 --- names: list (kurnevsky2 mpark1_ lachenmayer shachaf notdan magicman_ kadoban radix s_e_ RayNbow` Bashmetim cross_ fmapE_ caconym moei mach mendez newsham dreamdust shwouchkster trevorriles xplat|work lexi-lambda nolrai2 sokoll mpickering thoughtpolice vmeson Tritlo dstockwell warc beckyconning_ M-davidar M-david M-mistake M-Illandan sewilton mankyKitty mbrcknl dkua Eagle_Erwin jorendorff m0rphism jroesch_ obiwahn buoto noctux dolio araujo levi zv kalloc carter ggherdov)
01:15:02 --- names: list (seanparsons tek0 mindos_cloud____ lurker6 jlyndon chriswk kaictl fuziontech eyenx dibblego chirpsalot ThePhoeron jonrh electrostat acomminos yamadapc spwhitt capicue adlan kmicu aaron7 shennyg hive-mind aleator sjl_ ppnkk Warrigal Guest31570 Guest68583 codebje smoose benonsoftware r0ry M-schmittlauch dmwit_ arw dedgrant undoall mlhmwglt josephle ricardo82 hegge noteventime earldouglas fryguybob viaken joelburget jtobin rwiggins ichor majoh Cetusx myme abrar_)
01:15:02 --- names: list (magbo geekosaur carlw2 aweinstock Athas anachrome Majiir stomp Vorpal sqrt2 noplamodo_ Saizan hyPiRion jotrk FUZxxl cow-orker zuz_ verement Desoxy zopsi Amadiro kfpratt goldfire1 tgeeky FreeFull sabalaba kakos JRHaigh mingc Lokathor _janne machinedgod linduxed Madars kevinyings lanodan Cale nathyong jdt_ klarrt thorkilnaur__ mitchty armlesshobo platz_ Schrostfutz_ sgronblo_ tokik_ zerokarmaleft sphaleri1e bitemyapp spaceshi1s ali_bush_ Wamanuz2 pdxleif koomi)
01:15:02 --- names: list (jud martingale theorbtwo catern k3d3 epta swistak35 CosmicRay hausdorff defanor fergusnoble iross alevy Guest34040 liyang heath koala_man Hafydd __rlp musha68k ziman cods agm_ Iceland_jack rossberg obcode_ zeroskil1or dh tinkyholloway ljhms bazzle ph88^ tumdedum kloeri jophish pmade Black-Wolf Boney ario Internet13 sz0 Laney shwouchk chrzyki cic kolmodin Meow-J avocado chlong jokester radge__ jcp etrepum adamh dwynwen_ddlleyw antoniy lyddonb Taneb tlevine)
01:15:02 --- names: list (peddie KorriX_ moredhel_ Biohazard luxbock_ Xnuk Kaini_ brassel Dykam_ taruti solidus-1iver rstone takeey_ vikram_________ kriztw_ niteria_ otterdam M-ou-se Taylor orion tobiasBora tristanp hackagebot gem bb010g jamiis gabiruh pelegreno elementalest guampa zzz` sykora Moyst jcurbo XMunkki akfp Polarina jgertm keemyb jokleinn djellemah equinox Pessimist Xack LoganG FledRebel irishsultan s4msung pranz shutdown_-h_now krgn Guest59435 leadingthenet briansmith)
01:15:02 --- names: list (zimp ninedotnine nshepperd MarcelineVQ sinopeus wolfcore ephess_ stevenxl srcerer Tehnix dalmahal Nik05 knyppeldynan lambdabot Ravana jle` FMJaguar timrs2998 Oxyd cantstanya amiri ephemeron mmaruseacph2 condy Baughn johnzorn Elision AntiSpamMeta negatratoron squimmy sevas cjh` acertain taksuyu lpvb Ewout DrCode Philonous emmanuel_erc derpderp meta-coder Bane^ logcat Lord_of_Life wtw albel727 __main__ catsup stoned keix meretrix xeno_ cYmen rbocquet)
01:15:02 --- names: list (fr33domlover besenwesen troydm Paks Plastefuchs Keikran dogui fangs124 chishiki emiliocobos FireFly sm dilinger ion bounb elgot dario greeny__ vic_ qnikst deavid zaquest ethercrow shadowdaemon jcreekmore heurist ljb bbee lhynes ortmage kantokomi askarpo ByronJohnson hvr suppi petercommand sekrit pikajude xintron impure_hate Axman6 AustinMatherne nwf phage KeelOfSteel luz1e padre_angolano codedmart amingoia arnihermann dcoutts geal kwantam wrengr_away zq)
01:15:02 --- names: list (zmanian__ amatecha jlewis gpampara nemesit|znc scshunt irclogger_com pchiusano qguv _flow_ orcus nyandoge caw teeteewhy klugez agrif pootler_ dmoon1221 carc Enigmagic rom1504 SLi AlainODea drewdavis acfoltzer integral lispy Tiktalik cocreature minsky wjm mikeizbicki jfokkan__ loopspace gcollins mephx quakestor Oejet tekacs jameseb spicydonuts shelling__ sisir_ Elsi incomprehensibly banjiewen kier codebam xcombelle nak stephe_ tomaw pdgwien- sohum Lutin_)
01:15:02 --- names: list (wizonesolutions abbe Ke sclv zph_ si14 henriquev ikke TabAtkins razi1 malthe haasn pydave6367 orzo micxjo atomi bsermons Ezku SoupEvil timvisher LordDeath arahael Ongy Adeon Cyrus omilu sanitypassing tumdum Maerten_ capisce ireniko sivs kungp vqrs nickforall rieper jessicah` frontendloader Thulsadum rotty TommyC jknick corne lujan sajith robogoat fionnan hpc burp selckin t0m0 dustinm killtheliterate sea-gull MaienM marko Ferdirand vigs ixian brixen_ abra0)
01:15:03 --- names: list (Deewiant mero sellout zudov dysfun dqd canta hansihe leather borkdude zpconn__________ max-m nitrix jrslepak wyvern Myrl-saki nkpart zrl kipd stqism _guios gsingh93 psacrifice numberten jzl tippenein Blkt Clint bernalex johnw x1n4u abh lukky513 sleezd usr gseitz Caelum shans_ Guest33283 marcel louispan tjpeden sephiap georgew andyo Boreeas tolt greymalkin fall__ magically Jaak_ ggVGc exio4 siddhu_ Eliel_ phadej dfranke ddima_ giraffe neobrain1 telmich)
01:15:03 --- names: list (seliopou gbarboza OutlawStar mimi_vx Sigyn icicled joeyh OliPicard thallera1 Fylwind arianvp maskd jstolarek joco42 gienah chelfi ent chipb lattenwald j0llyr0tten przembot dzackgarza opqdonut epitron mrd lokien MitchW sunfun stasku____ harmchop fabianvf bkolera kyagrd Eiam adarqui potatoe rikkus_ frelux Guest32455 mak` wagle cbm80 riscool Tamini Saimeidae dpn` bogdanteleaga pkogan_ aristid alpounet andreypopp__ johtso luite 18WAAH582 friden Xe DenSchub)
01:15:03 --- names: list (squisher eL_Bart0 Mandus gargawel brt1 Quintasan xnyhps myfreeweb nilOps comboy Ulrar codehero katymoe bigs Chousuke fyolnish Ashy Tene raid minad Jaxan ircbrowse lieven v45h PanicSkittle jkarni GGMethos liszt Kahva japesinator tych0 Jello_Raptor Ov3rload Tristan-Speccy tazjin GHCI robtaylor aatxe Atlanis dxtr CARAM__ d6e kryft posco YP-Cloud_ okek Adios Pucilowski yminsky luis deni tg prooftechnique gothos pieter cosban EvanR nyuszika7h glckr hiredman DDR)
01:15:03 --- names: list (woffy davean zenzike hanDerPeder [swift] kshannon lf94 dan64 monkeyiq tsani nekomune vincenz jimki_ tero- BigEndian mrowe RevJohnnyHealey julmac ft spinda runeks Geekingfrog kyren milessabin dicioccio Purlox hc {AS} yaknyasn ajmccluskey reynir theDon zomg asjo noexcept bedouin code_crimes alang lpaste caasih trig-ger solidsnack fboyer cstrahan avdi mattp_ bergmark xxpor karshan lancetw qnix naudiz ackthet case39 bcoppens knittl tomku ManiacTwister amontez)
01:15:03 --- names: list (_6a68 nopf srhb o`connor lenstr Niamkik demize saurik electrogeek vishesh dasmith91 owa brolin_empey jnoah shteou BrianHV DigitalKiwi nek0 keteim cbaines SuperTux88 alanz cin bjs ]|[ anoe xou Guest26166 mxf DANtheBEASTman Twey liste JPohlmann Erebe ndeine Ararat gratimax asm89 coddinkn lyxia kennyp larsen phaazon lnx solirc PHO Ankhers sleepynate davesilva cjay kipras`away fold4 KaneTW ironChicken low-profile isomorphismes MasseR kvieta Fubar^ Rembane yarou)
01:15:03 --- names: list (ahf froztbyte hongminhee bshelden honkfestival vifon stux|RC-only lokydor supki Drezil wting julienXX nikola kjanosz Watcher7 indiffernet yeltzooo Starfire aparent Ornedan arkarth c_wraith psyq maartenpi ebird eagleflo archaic RazorX| Edoxile jlouis RouxTheDay Shandy nexsja ec\ hemite wayne Speed Ring0` niluje Akii Vq so betawaffle eikke @ChanServ danieli xa0 relrod thomas)
01:16:27 <cocreature> rydgel: there is opencl/cuda and opengl has compute shaders
01:28:26 <rydgel> cocreature: will check that if my game have a CPU bottleneck
01:44:59 <jle`> cocreature: yeah, the most i'd do with linear is something like a 2d physics engine.  but i'd hardly call that linear algebra...that's more like linear arithmetic
01:45:11 <cocreature> jle`: yeah
01:45:49 <jle`> when people talk about computational linear algebra, they mean things like eigenvectors, SVD, PCA, finding nullspaces, etc.
01:46:03 <EvanR> 3d graphics works
01:46:10 <EvanR> you could get a quake with linear
01:46:28 <jle`> and the fact that linear doesn't even have a matrix type means that even things like basic matrix operations aren't really too great.  exponentiation, repeated multiplcation, etc.
01:46:46 <EvanR> it has 4x4 matrices, all youll ever need !
01:46:52 <jle`> yeah, still, things like physics engines i'd call vector arithmetic heh
01:47:07 <prohobo> math is tupid
01:47:11 <EvanR> yes its not a linear algebra suite
01:47:28 <cocreature> EvanR: it has vectors of vectors and a type alias :P
01:47:44 <jle`> linear : linear algebra :: Control.Category :: category theory
01:48:20 <jle`> "let's see if we can state these things as typeclasses" :)
01:48:58 <cocreature> to be fair you might be able to make instances for a “proper” linear algebra library
01:49:22 <jle`> it'd be nice if it was useful for that :)
01:49:53 <jle`> but ... Functor, Additive etc. are too polymorphic for most linear algebra libraries to use
01:50:00 <cocreature> yeah
01:50:08 <jle`> their operations are usually constrained to Storable or even specific types
01:50:20 <cocreature> I would like to have some specialization of datatypes like c++ templates
01:50:50 <jle`> but i really admire linear, it's a very nice formulation of linear algebra concepts in haskell types
01:51:33 <cocreature> who needs performance anyway
01:52:45 * Rembane raises hand
01:53:25 <jle`> you could probably wrap the real LA library types in free functors/kan extensions or something and get them to fit with linear typeclasses
01:54:19 <jle`> i mean, wouldn't help with performance, but it lets you use the pretty architecture of linear
01:58:39 <Myrl-saki> Aren't homomorphisms monoids?
01:58:48 <Myrl-saki> Err
01:58:54 <Myrl-saki> s/monoids/a monoid/
02:02:10 <jstar> I have a type:
02:02:11 <jstar> newtype Contract = Contract [C]
02:02:11 <jstar> and a function:
02:02:11 <jstar> mapC :: (C -> C) -> Contract -> Contract
02:02:14 <jstar> mapC f (Contract cs) = Contract (map f cs)
02:02:16 <jstar> I thought I could do this:
02:02:18 <jstar> instance Functor Contract where fmap = mapC
02:02:20 <jstar> But get the error: The first argument of ‘Functor’ should have kind ‘* -> *’, but ‘Contract’ has kind ‘*’
02:02:23 <jstar> Is there any way I can avoid having this custom mapC function and use fmap (or some other standard function?). I have other newtypes like this and it seems silly to have a separate mapping function for each of them.
02:05:12 <liste> jstar: you can do newtype Contract' a = Contract' [a], and type synonym "type Contract = Contract' C"
02:05:20 <liste> and then just export the synonym
02:07:03 <jstar> liste: thanks!
02:24:07 <viz> hey
02:32:38 <Itkovian> anybody can point me to the solution for installing cabal-helper using stack? the issues I see on github all seem to be closed, but I still get "Couldn't find executable cabal-helper-wrapper in directory /Users/ageorges/.stack/global/.stack-work/install/x86_64-osx/lts-5.10/7.10.3/bin/"
02:36:22 <zraffer> @pl \xs n -> take n xs ==> flip take
02:36:22 <lambdabot> flip flip (flip take) . ((==>) .) . flip take
02:38:05 <zraffer> @pl \op0 op2 -> \arg -> op2 op0 x
02:38:05 <lambdabot> (const .) . flip flip x . flip id
02:39:03 <zraffer> @pl \arg -> (+) 0 x
02:39:03 <lambdabot> const x
02:39:11 <zraffer> @pl \arg -> (+) 0 arg
02:39:11 <lambdabot> id
02:39:17 <zraffer> @pl \arg -> (+) a arg
02:39:17 <lambdabot> (a +)
02:39:34 <zraffer> @pl \arg -> op2 op0 arg
02:39:34 <lambdabot> op2 op0
02:40:02 <zraffer> @pl \arg -> Mul Id f
02:40:02 <lambdabot> const (Mul Id f)
02:40:08 <zraffer> @pl \f -> Mul Id f
02:40:08 <lambdabot> Mul Id
02:40:13 <zraffer> @pl \f -> Mul f Id
02:40:14 <lambdabot> flip Mul Id
02:40:48 <zraffer> @pl \ a b c -> Mul (Mul a b) c
02:40:48 <lambdabot> (Mul .) . Mul
02:41:02 <zraffer> @pl \ a b c -> Mul a (Mul b c)
02:41:02 <lambdabot> (. Mul) . (.) . Mul
02:43:14 <EvanR> so pointless
02:56:34 <dhex> Yuras! We were talking about you.
02:57:09 <Yuras> dhex: really?
02:57:19 <dhex> Yes
02:58:01 <Yuras> I see nothing in logs
02:59:34 <dhex> The logs are outdated.
02:59:45 <Rembane> There is no spoon.
03:00:08 <dhex> lethjakman! We were talking about you.
03:24:28 * hackagebot ip6addr 0.5.1.0 - Commandline tool to generate IPv6 address text representations  https://hackage.haskell.org/package/ip6addr-0.5.1.0 (MichelBoucey)
03:35:36 <Darwin226> Is there a way to put depended packages flags in the cabal file?
03:36:00 <Darwin226> like build-depends: hmatrix -openblas
03:39:43 * hackagebot sproxy 0.9.4 - HTTP proxy for authenticating users via Google OAuth2  https://hackage.haskell.org/package/sproxy-0.9.4 (ip1981)
04:26:53 <nomeata> https://wiki.haskell.org/Haskell_logos lists the grey logo as the official logo, but https://www.haskell.org/ uses purple. maybe someone should extend https://wiki.haskell.org/Thompson-Wheeler_logo and also add the color scheme to https://wiki.haskell.org/wikiupload/3/35/Haskelllogo.sty?
04:54:06 <Aruro> nomeata: gray version appeared in more places, i even have sticker. But purple is very nice too.
04:57:36 <Rembane> I want an equivalent but shorter line that does this: mapM join $ sequenceA $ Just [Just 7, Just 8, Just 9]
04:57:51 <Rembane> => Just [7,8,9]
04:58:45 <liste> :t fmap catMaybes
04:58:47 <lambdabot> Functor f => f [Maybe a] -> f [a]
04:59:12 <liste> > (fmap catMaybes) (Just [Just 7, Just 8, Just 9])
04:59:14 <lambdabot>  Just [7,8,9]
04:59:34 <liste> though I don't know how catMaybes generalizes
04:59:49 <puregreen> it should return Nothing if any element is Nothing
04:59:57 <liste> oh
05:00:45 <puregreen> okay, what about this
05:00:50 <puregreen> > sequenceA =<< Just [Just 7, Just 8, Just 9]
05:00:51 <lambdabot>  Just [7,8,9]
05:01:12 <puregreen> Rembane: &
05:01:13 <puregreen> * ^
05:01:26 <Akii> > sequenceA $ [Just 1, Just 2]
05:01:28 <lambdabot>  Just [1,2]
05:01:38 <Akii> ^^
05:02:04 <Akii> without $ of course
05:02:58 <Boomerang> :t sequenceA
05:02:59 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
05:03:03 <Boomerang> :t sequence
05:03:04 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
05:04:00 <Boomerang> > sequence =<< Just [Just 7, Just 8, Just 9]
05:04:01 <lambdabot>  Just [7,8,9]
05:04:49 <Akii> nice
05:05:54 <Rembane> puregreen, liste, Akii, Boomerang: Thank you! There is quite some beautiful programming there!
05:10:15 <Aruro> Rembane: join is beautiful too
05:11:10 <Rembane> Aruro: It is indeed, but less is more. 
05:13:19 <aleator> Hey, which is the best test-framework in 2016? Tasty?
05:15:21 <Aruro> is lambdabot private messaging on? does not seem to answer
05:15:38 <Jinxit> you still need >
05:15:55 <Aruro> Jinxit: tried, does not work
05:16:13 <Jinxit> works for me
05:16:17 <Aruro> hm
05:16:37 <Akii> works for me as well
05:18:44 <Aruro> irssi's /quety lambdabot does not work, starts session but bot is silent
05:19:45 <Jinxit> doing it on the right network?
05:19:56 <Aruro> Jinxit: freenode?
05:20:01 <Jinxit> yeah
05:20:05 <Kneiva> Aruro: you still need to use >
05:20:21 <Aruro> top name is: ~lambdabot@haskell/bot/lambdabot (freenode)
05:20:25 <Aruro> top bar
05:20:35 <Aruro> Kneiva: i do use it
05:20:37 <Kneiva> oh, that was said already
05:21:36 <Kneiva> "works on my machine" http://pastebin.com/csR1VHVe
05:23:29 <Aruro> Kneiva: ty, will try restart
05:30:16 <agocorona> Hi. when I use the library generated by cabal, my program memory fault. when I compile it with ghc, everithing is OK
05:31:04 <MichaelBurge_> agocorona: Cabal has a verbose option that will output the exact GHC command it is using
05:31:05 <agocorona> object files generated by cabal in the dist folder are almost double in size than the ones generated by ghc. Is it normal?
05:31:41 <agocorona> MichaelBurge_: Yes I saw the string. it is very long, but I can not figure out what happens
05:31:54 <dcoutts> agocorona: individual .o files or the total?
05:32:13 <agocorona> dcoutts:  individual
05:32:21 <dcoutts> agocorona: -O ?
05:32:57 <agocorona> i did not use -O in both cases
05:33:01 <maerwald> you are not using cabal sandbox are you?
05:33:09 <agocorona> no sandbox
05:33:35 <dcoutts> agocorona: ok, well Cabal uses -O by default
05:34:35 <dcoutts> agocorona: so either compare cabal build -O0 or when you compile directly with ghc use -O
05:38:19 <agocorona> with -O  the sizes are more close, but the ones of cabal are aprox.  20k bigger.
05:39:05 <dcoutts> agocorona: if you're interested in working it out, running cabal build -v2 shows the ghc command line, so you can experiment with the ghc command lines
05:44:36 <agocorona> I suspect that is some dependency.  How can I know which dependencies use ghc stand alone?
05:53:39 <agocorona> dcoutts: thanks
05:59:22 <agocorona> it happens in windows and linux
06:21:01 <bennofs> agocorona: I think ghc -v shows which packages are loaded
06:23:16 <agocorona> ok
06:29:52 <Peaker> How is ghcjs's performance, relative to ghc's native code?
06:30:06 <Peaker> Also, is the modern "gl" package supported via WebGL in ghcjs?
06:31:58 <srhb> Peaker: Are you asking how fast ghcjs compiles Haskell to js?
06:33:52 <Peaker> No no, about the compiled code's performance, e.g on V8/firefox, vs. native GHC compiled code
06:35:31 <srhb> Oh, I don't know if anyone has ever compared those, usually it's regular JS vs. ghcjs on those platforms, not ghcjs vs ghc. I don't know (but I'm guessing horrible.)
06:36:20 <Peaker> I am thinking of porting Lamdu to ghcjs -- but we have some performance critical stuff (like online type inference)
06:36:32 <Peaker> Maybe these things ought to happen server-side
06:52:35 <greg`> looking a chapter 10 in haskell book they assert that foldr const 0 [1..5] = (const 1(const 2 (const 3(const 4(const 5 0)))))
06:53:14 <greg`> however haskell is lazy so  i assume it would get passed const 1 _
06:53:47 <greg`> ie it wouldnt bother to make the further evaluations
06:56:59 <srhb> > const 1 undefined
06:57:00 <lambdabot>  1
06:58:18 <srhb> greg`: Note that there's no "passing _" -- the second argument is just never forced.
07:29:35 <Denommus> hello
07:30:12 <srhb> Denommus: Hello.
07:44:52 * hackagebot persistent-mongoDB 2.5 - Backend for the persistent library using mongoDB.  https://hackage.haskell.org/package/persistent-mongoDB-2.5 (GregWeber)
07:44:54 * hackagebot persistent 2.5 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.5 (GregWeber)
07:49:52 * hackagebot persistent-template 2.5 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5 (GregWeber)
07:49:54 * hackagebot persistent-mysql 2.5 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.5 (GregWeber)
07:49:56 * hackagebot persistent-postgresql 2.5 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.5 (GregWeber)
07:49:58 * hackagebot persistent-sqlite 2.5 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.5 (GregWeber)
08:15:14 <mjrosenb> is there something like mapM, but with its arguments reversed?
08:15:52 <byorgey> @type forM
08:15:54 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
08:15:57 <byorgey> mjrosenb: ^^^
08:16:27 <byorgey> in Haskell, a for loop is just a higher-order function =)
08:17:30 <Rony> Hey guys!
08:17:50 <Rony> I've heard this a very helpful IRC channel
08:18:02 <Rony> And I am looking for help
08:18:09 <Rony> ...well actually some advice
08:18:12 <dgpratt> lambdabot @hoogle (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
08:18:17 <dgpratt> err
08:18:28 <dgpratt> @hoogle (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
08:18:29 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
08:18:29 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
08:18:29 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
08:18:50 * dgpratt likes hoogle a whole lot
08:19:10 <Rony> I want to use IRC channels to promote my product
08:19:26 <Rony> Have you seen an innovative way of doing that, which you saw of late?
08:19:36 <mjrosenb> byorgey: ooh, thanks!
08:19:37 <dgpratt> how does your product relate to Haskell, Rony?
08:19:38 <Rony> Or have some suggestions for it?
08:20:11 <byorgey> Rony: this is indeed a helpful IRC channel, but only in relation to the Haskell programming language.
08:20:12 <Rony> Well it relates more to all developers
08:20:41 <Rony> Well the solution I am looking for isn't techincal in nature
08:20:54 <Rony> But since I heard this channel is full of helpful developers
08:21:06 <Rony> I thought might ask it
08:21:21 <byorgey> Rony: fair enough, but your question is not really on topic for this channel
08:22:15 <Rony> byorgey: Alright, thanks anyways
08:24:53 * hackagebot yaml 0.8.17.1 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.17.1 (MichaelSnoyman)
08:39:29 <orion> Will Control.Concurrent.Chan.getChanContents ever block?
08:42:22 <dcoutts> orion: no, but
08:42:41 <dcoutts> of course evaluating the list you get back can force you to block
08:43:10 <orion> dcoutts: Hmm, I see. That's precisely why this will fail, correct?: http://lpaste.net/2138990058114383872
08:43:42 <dcoutts> orion: presumably you find that it prints "foo", "bar" right?
08:43:59 <orion> No: "thread blocked indefinitely in an MVar operation"
08:44:34 <dcoutts> doesn't print anything first? ok
08:44:54 * hackagebot vulkan 1.7.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-1.7.0.0 (jophish)
08:44:56 <dcoutts> orion: these channel are not closable channels, so get contents is necessarily "infinite"
08:45:10 <cocreature> still it should start printing no?
08:45:40 <Cale> Is it smart enough to determine that l2 is garbage?
08:47:00 <orion> I need two buffers/chans/whatever which only get written to in another thread. After those threads have finished their work, I need to get back their contents. I suppose what I need are "closable" channels then?
08:47:15 <dcoutts> Cale: I think it's l1 that'd trigger the mvar excpetion, it can see that we're waiting on reading a the MVar, but there's no other thread that has access to the mvar to be able to write, so we're necessarily stuck
08:47:38 <dcoutts> orion: e.g. include a terminator, Chan (Maybe a)
08:47:50 <dcoutts> is a cheep and cheerful way of doing it
08:48:01 <orion> What's the expensive way? :)
08:48:02 <dcoutts> or make it a proper abstraction if you prefer
08:48:23 <Cale> dcoutts: Ah!
08:48:25 <dcoutts> orion: well, it's just that the interface doesn't fully reflect the usage
08:48:40 <orion> dcoutts: Is there a more appropriate one, other than Chan (Maybe a)
08:48:41 <Cale> Yeah, I was trying to explain why it might not print foo and bar first, but that's just line buffering
08:49:11 <Cale> If you change it to mapM_ print you can see that it does actually consume all of c1 before hitting the exception
08:49:16 <cocreature> ah line buffering I forgot about that
08:49:26 <dcoutts> Cale: ah ok, yes I was also expecting it to print the first ones
08:49:54 * hackagebot ekg-carbon 1.0.5 - An EKG backend to send statistics to Carbon (part of Graphite monitoring tools)  https://hackage.haskell.org/package/ekg-carbon-1.0.5 (OliverCharles)
08:51:03 <Cale> orion: Maybe just an Async that computes a list or other pure sequence type?
08:51:42 <Cale> The main reason to want to use Chan is that you're going to be consuming the items at the same time
08:53:05 <orion> Hm, yes. In this case I want the threads to have a write-only "logging" interface whose contents don't get consumed until the very end of the program, where the output is printed to stdout.
08:56:52 <orion> Unfortunately, I don't know when the thread is going to end, so I am unable to use Chan (Maybe a).
08:58:23 <orion> I might just have to use an MVar [a]
08:58:33 <Cale> Yeah maybe you want an IORef to keep track of each thread's log
08:58:50 <ertes> orion: you can use a second MVar (or more conveniently an Async) for signalling the end of the thread
09:00:38 <orion> Cale: What are the pros/cons of IORef and MVar in this particular case?
09:01:04 <Cale> You only use MVar if there's more than one thread interacting with it.
09:01:35 <Cale> If you're only accessing the mutable cell from one thread, then MVar just helps you get blocked indefinitely by mistake.
09:01:52 <hpc> a bit more specifically, (MVar a) is only distinct from (IORef (Maybe a)) in the case of concurrent modifications
09:02:34 <orion> Ah, I see.
09:02:41 <hpc> making it certainly not the ideal type to use if you really want (IORef a) in a non-concurrent environment
09:02:42 <Cale> hpc: Well, no, it is different, in that you can takeMVar twice
09:02:57 <Cale> which causes your thread to die :)
09:03:03 <hpc> heh
09:03:06 <Cale> (or putMVar twice)
09:03:50 <hpc> you can do that with IORef :. Maybe too, if you make a suitable definition of those functions ;)
09:04:43 <hpc> since in the Nothing case for IORef, take would be necessarily partial
09:04:48 <orion> Doesn't IORef support concurrency through it's atomic* operations?
09:04:54 <hpc> orion: it does but not as well
09:05:11 <hpc> the documentation for those operations explains it reasonably well
09:05:19 <ertes> MVar doesn't support idle blocking, fairness or segfaults
09:05:36 <ertes> s/MVar/IORef/
09:05:55 <hpc> segfaults?
09:06:29 <hpc> is that a cheeky way to say MVars can be empty? :P
09:06:30 <ertes> the regular reading/writing API of IORef isn't necessarily thread-safe at all
09:06:36 <hpc> ah
09:07:04 <ertes> and the atomic* operations use busy waiting
09:07:33 <ertes> in some rare cases that's what you want, but in all others MVar is the answer
09:07:35 <hpc> the way i keep track of it is IORef is as safe as regular old assignment in any other language
09:07:52 <hpc> and MVar is the same as writing about 50 lines of boilerplate thread-safety code around a single variable
09:08:07 <maerwald> or TVar
09:08:10 <tdammers> or TMVar
09:10:03 <Cale> ertes: Well, you'll never see a half-written IORef
09:10:13 <Cale> It's reasonably safe in that regard.
09:11:23 <Cale> It's just that if you have multiple threads reading and writing, you have to be very careful about how you manage an IORef because it's easy to lose updates.
09:15:09 <nitrix> I thought IORef managed concurrent operations too.
09:15:38 <nitrix> Not atomicModifyBlaBla, but the other one is apparently atomic so, or so I heard.
09:15:49 <nitrix> *too
09:15:58 <hpc> nitrix: check the documentation, concurrent IORef operations are safe from some kinds of interleaving/corruption but not others
09:16:27 <nitrix> hpc: I see. What about atomicModifyIORef, is that one always safe?
09:17:06 <hpc> This function is useful for using IORef in a safe way in a multithreaded program. If you only have one IORef, then using atomicModifyIORef to access and modify it will prevent race conditions.
09:17:10 <hpc> Extending the atomicity to multiple IORefs is problematic, so it is recommended that if you need to do anything more complicated then using MVar instead is a good idea.
09:18:25 <nitrix> Why would multiple IORef used atomically be problematic?
09:18:36 <nitrix> Lazyness / race conditions?
09:18:38 <Cale> Because you can't read from many IORefs all at once
09:18:42 <Cale> and then write to another
09:18:54 <nitrix> Right.
09:18:57 <Cale> with the guarantee that none of the inputs have changed in the meantime
09:19:08 <hpc> or in other words
09:19:23 <hpc> atomicallyFoo >> atomicallyFoo /= atomically (foo >> foo)
09:19:29 <nitrix> Got it.
09:20:32 <nitrix> So it's not inherently dangerous, just that, you need to assume the value you obtained is exactly at the moment you obtained it, it may still change before you update another IORef.
09:20:52 <nitrix> Unless the IORefs are closely related, not a major issue.
09:21:03 <hpc> essentially yes - MVars still have their own issues with multiple reads, but because of being able to take and "lock" an MVar they project a certain amount of atomicity
09:21:12 <hpc> if you have consistens use patterns everywhere
09:21:26 <hpc> a problem MVars have is if you lock them out of order, you can deadlock
09:21:37 <hpc> and that's just a traditional locking bug
09:21:40 <nitrix> Right, I've read that too.
09:22:01 <nitrix> Is lazy evaluation more prone to causing such deadlock?
09:22:22 <hpc> everything above has been at the level of execution
09:22:27 <hpc> lazy evaluation doesn't really come into it
09:22:35 <nitrix> Okay.
09:22:54 <hpc> though there's some fun laziness leaks you can read about as well
09:23:05 <nitrix> When you update an IORef, I assume it only changes the pointer to the new thunk?
09:23:13 <hpc> correct
09:23:54 <hpc> (for sufficiently abstract values of pointer, there's some GC funny business i haven't kept up on that makes mutation interesting in ghc)
09:24:52 <hpc> it's a fairly safe lie in any event
09:25:06 <nitrix> :)
09:25:45 <dolio> Mutation is always 'interesting' with respect to GC. :)
09:26:14 <hpc> yeah
09:26:36 <hpc> i remember reading about it a couple years ago and thinking "i guess that's really the only way to do it", but hell if i can remember what that way was
09:26:45 <hpc> i should go back and read the trac commentary again
09:26:58 <monochrom> so interesting that GC regards your program proper as "the mutator"
09:27:21 <nitrix> I had to dig into GHC yesterday and the codebase was intimidating.
09:27:34 <hpc> haha, i bet
09:27:39 <nitrix> No idea how you guys pull off such optimizations.
09:27:41 * hpc isn't that much of a badass yet
09:30:14 <nitrix> hpc: Channel your inner simonpj :P
09:30:28 <orion> Some of the people working on GHC are really young too.
09:30:56 <hpc> every night before i go to sleep i wish on a shooting star that i get visited by the bowtie fairy
09:31:34 <orion> hpc: That's disturbing.
09:31:43 <hpc> :P
09:32:22 <hpc> there was a photo of... the haskell98 authors or something along those lines
09:32:29 <hpc> the only people not wearing a bowtie were the women
09:32:50 <nitrix> He'll exchange your types for sorts.
09:37:00 <jophish> Is there a way of getting the transitive closure of the reverse dependencies of a package on Hackage?
09:37:27 <jophish> or could someone answer my question directly: How likely is it that a haskell program on Windows will depend on the Win32 package
09:37:50 <jophish> I think it's pretty likely given that `directory` depends on Win32
09:37:51 <hpc> jophish: some packages do "either unix or Win32" in their depends
09:38:13 <hpc> directory will depend on win32, yes
09:38:19 <hpc> which... adds a lot of stuff
09:38:46 <hpc> http://packdeps.haskellers.com/reverse/directory
09:39:06 <jophish> hpc: yeah, that's exactly what I'm looking at, but those are just direct dependencies
09:39:15 <hpc> yeah
09:39:34 <hpc> i was honestly surprised the other day when hackage didn't have that built-in either
09:39:43 <hpc> which was how i found packdeps.h.com in the first place
09:41:08 <hpc> anyway, the answer is "lots" it seems
09:41:24 <hpc> is that a problem for you?
09:41:27 <hpc> for WINE or something?
09:41:43 <jophish> hpc: https://github.com/expipiplus1/vulkan/issues/7#issuecomment-210026052
09:41:56 <jophish> someone is objecting to potentially depending on Win32 just for the HWND type
09:42:17 <jophish> I don't think it's a big deal, because it's certain to be included anyway for any large project
09:42:44 <rribeiro> Hi! Is there a way to do type level string concatenation using GHC.TypeLits.Symbol as a type level string representation?
09:44:16 <jophish> rribeiro: https://gist.github.com/sdiehl/b70d25b920a97f3002e8
09:44:44 <jophish> not exactly what you're looking for
09:44:47 <rribeiro> jophish: Thanks
09:45:24 <rribeiro> I've already found this on google, but I was thinking that there's a better way
09:45:32 <rribeiro> probably not :(
09:45:55 <jophish> rribeiro: I don't think there's any way to do it at the moment
09:46:15 <orion> When deriving NFData, how do you apply rnf to each field in a record type?
09:49:18 <ertesx> hpc: even with a single IORef the atomic* functions can cause races
09:49:30 <ertesx> as i noted earlier they use busy waiting and restarting
09:49:50 <ertesx> they effectively have the same properties as TVar, but more expensive
09:50:03 <jophish> orion: isn't that what the derived version will do anyway?
09:50:16 <Peaker> The docs don't say that forkOn creates a bound thread -- but since its bound to a capability, isn't it necessarily bound?
09:51:52 <Peaker> hmm, indeed "forkOn" doesn't create a bound thread. so I don't quite get it
09:53:15 <Peaker> What does it mean that a thread is "bound" but not "locked" to the capability?
09:54:00 <hpc> jophish: i am going to comment on that issue - even Cabal depends on Win32
09:54:56 * hackagebot stackage-curator 0.13.3 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.13.3 (MichaelSnoyman)
09:55:04 <orion> jophish: Ah true. I'm trying to derive an instance of NFData for a type family.
09:55:53 <dcoutts> Peaker: bound threads are about binding to a particular OS thread
09:55:58 <jophish> thanks, hpc 
09:56:25 <dcoutts> Peaker: so that all FFI calls will happen on that OS thread, hence have access to C thread local vars etc
09:56:30 <jophish> right, time to be off. I don't suppose anyone else is going to be at the Cambridge Haskell meetup tonight?
09:57:02 <Peaker> dcoutts: My main thread has the OpenGL context. I want to run some function in the same OpenGL context.  So I thought I could forkOn the capability of the main thread and run it there
09:57:21 <dcoutts> Peaker: capabilities are not OS threads
09:57:32 <Peaker> dcoutts: Isn't it a 1-to-1 mapping?
09:57:41 <dcoutts> different OS threads animate the capability at different times
09:57:56 <Peaker> dcoutts: Why do capabilities migrate between OS threads?
09:58:04 <dcoutts> Peaker: no, a capability is more like a resource
09:58:37 <dcoutts> Peaker: migration is the wrong way to think of it
09:58:43 <Peaker> dcoutts: so if I want to run an FFI call in the "main" OS thread context, how can I do that? (I'd rather not have to talk to the main Haskell thread)
09:58:52 <dcoutts> a capability does nothing until it is animated by an OS thread
09:59:10 <Peaker> dcoutts: What's the downside of the model where OS thread = capability ?
09:59:25 <orion> Anyone know how to derive NFData for this type?: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Cipher.hs#L25 -- I tried instance Generic (SymmetricKey a); instance NFData a => NFData (SymmetricKey a); but I get this error: Could not deduce (Control.DeepSeq.GNFData (Rep (SymmetricKey a))) arising from a use of ‘Control.DeepSeq.$gdmrnf’ from the context (NFData a)
09:59:38 <dcoutts> if I have a C FFI call into Haskell, how can that thread run Haskell code unless it can acquire the capability lock and execute the capability?
10:00:05 <dcoutts> Peaker: one OS thread at a time runs the capability, but it can be different threads at different times
10:00:17 <Peaker> dcoutts: what's the upside of that?
10:00:33 <dcoutts> Peaker: in calls for one thing
10:01:01 <Peaker> dcoutts: the C FFI call runs inside the Haskell thread, so inside the capability, so the capability should be able to handle calls from C at that point
10:01:30 <dcoutts> Peaker: a C thread that calls a Haskell function
10:01:54 <dcoutts> not necessarily within an existing (unsafe) Hs -> C call
10:01:56 <Peaker> dcoutts: ah, I guess the C thread would have to allocate its own capability to preserve the 1-to-1 mapping, and run it there
10:03:04 <Peaker> dcoutts: in any case -- is it possible to ask the rts to run code in the "main" OS thread context?
10:03:04 <dcoutts> Peaker: or for a safe out call, with the current approach the same OS thread can start running the C code. Under your model it'd have to find a new OS thread at that point to run the C call
10:03:17 <dcoutts> since a safe FFI call has to drop the capability lock
10:03:43 <dcoutts> Peaker: no, as far as I know it's not possible except in the single threaded RTS
10:04:03 <dcoutts> Peaker: bound threads do not help you with running multiple Haskell threads on one OS thread
10:04:16 <dcoutts> Peaker: we had this same issue with gtk+
10:04:44 <dcoutts> Peaker: your only real solution is to run the C ffi calls from a single bound thread
10:04:47 <Peaker> dcoutts: if I do "forkOn" on the capability of the main thread -- that won't work?
10:04:55 <dcoutts> not guaranteed
10:05:08 <dcoutts> since different OS threads can run the capability as we just discussed
10:05:44 <Peaker> Would a "forkBoundOn" work?
10:05:47 <dcoutts> indeed the main thread is bound, so actually you're guaranteed to run on a different OS thread I think
10:05:51 <Peaker> "forkOSOn" that is
10:06:13 <Peaker> Bound thread means that it occupies the entire OS thread by itself?
10:06:34 <dcoutts> Peaker: it means when that Haskell thread is ready to run, we switch to that OS thread to animate the capability
10:07:01 <dcoutts> ie no extra parallelism
10:08:10 <dcoutts> Peaker: your fundamental constraint is that you cannot bind multiple Haskell threads to the same OS thread
10:08:30 <Peaker> Well, I don't really need parallelism -- I have a drawing thread that animates -- needs to be super-responsive. I delegate work to an "event thread" -- that thread needs to do some small/cheap calls that have to use the main OS thread context
10:09:03 <dcoutts> Peaker: so those small/cheap calls have to run on that same OS thread
10:09:06 <Peaker> dcoutts: weird restriction! I'd expect multiple Haskell threads bound to same OS thread to work - just not parallelize
10:09:52 <Zemyla> :t id -- is lambdabot down?
10:10:01 <dcoutts> Peaker: well, from the pov of the RTS authors it's an odd thing to ask for, since it means that when one Haskell thread is running a safe FFI call, none of those other Haskell threads can run
10:10:05 <Zemyla> Sure looks like it.
10:10:31 <dcoutts> Peaker: I had this discussion when trying to solve a similar problem for gtk+
10:12:19 <dcoutts> Peaker: and you'll notice there's no API that would be able to express binding another Haskell thread to an existing OS thread
10:13:41 <dcoutts> Peaker: so you can post things back to the gui thread, and you can try your best to batch those, to save on thread switching
10:13:48 <hpc> dcoutts: so when maximally "bound" haskell threads bind to OS threads, which have an affinity for capabilities
10:14:12 <hpc> dcoutts: and when minimally bound, haskell threads bounce freely between OS threads that don't have any bound threads attached
10:14:21 <hpc> and OS threads bounce freely between capabilities as they are idle
10:14:24 <hpc> ?
10:14:51 * hpc couldn't help but get sucked in
10:14:59 <dcoutts> hpc: sorry, need slightly more precision, os vs hs threads
10:15:34 <hpc> does "that don't have any bound hs threads attached" help?
10:17:06 <hpc> (also nvm if this is distracting from helping Peaker, just interjecting ;))
10:17:46 <dcoutts> hpc: Haskell threads can either be bound to an OS thread, or can be unbound and constrained to run on a particular capability
10:18:04 <dcoutts> hpc: so only three states I tihnk
10:19:14 <hpc> so a haskell thread is always restricted to one of a particular OS thread, or a particular capability?
10:19:17 * hpc TIL
10:20:17 <adamvh> question: is it possible to use bang patterns to make a record field strict?
10:20:21 <dcoutts> hpc: 1. not bound, not limited to a cap, so can freely be migrated between caps. 2. not bound, limited to one cap. 3. bound to a particular OS thread
10:20:35 <hpc> ah
10:20:57 <dcoutts> hpc: in the bound case, I'm not sure that the thread is limited to running on one capability
10:21:16 <dcoutts> hpc: not totally sure about migrating bound threads
10:21:31 <hpc> and an OS thread is a literal OS thread
10:21:36 <dcoutts> yes
10:21:36 <hpc> as defined by POSIX or whatever
10:21:47 <hpc> at least i have that much correct ;)
10:21:55 <dcoutts> the RTS maintains a bit of extra state to keep track of it, but yes
10:23:25 <dcoutts> hpc: now I think each capability maintains its own pool of OS threads for running safe FFI calls, so they don't bounce around randomly
10:23:50 <dcoutts> but I'm not sure that has any impact on the model semantically
10:24:00 <dcoutts> it's just the obvious thing for performance
10:27:54 <Peaker> dcoutts: specifically, I need to get the font size of certain texts, and FTGL uses thread-local state to do that, it has to happen in the "draw" thread
10:28:03 <Peaker> dcoutts: doing a round-trip to the main thread for each font-size request sounds bad :(
10:28:15 <dcoutts> Peaker: can you not batch them?
10:28:18 <Peaker> (and will require an extra application-level thread synchronization mechanism)
10:28:35 <Peaker> dcoutts: I could, but it would require a big restructuring of the code :(
10:28:46 <dcoutts> Peaker: so here's the model I was thinking of for gtk, back when I used to maintain that
10:29:03 <dcoutts> a GUI monad and IO, GUI guaranteed that you were running in the right OS thread context
10:29:38 <dcoutts> switching IO -> GUI is the expensive one, and requires posting something to the gui thread
10:29:49 <dcoutts> liftIO :: IO a -> GUI a is cheap of course
10:29:58 <Peaker> dcoutts: In my case, getFontSize is behind unsafePerformIO (it is in fact pure)
10:30:45 <Peaker> so behind the unsafePerformIO there's gonna be the round-trip communication to the Haskell thread
10:31:02 <dcoutts> Peaker: so yes, you can in GUI liftIO forkIO and run things and post results back, but in that other thread making more GUI calls is expensive, and the types show you where, and encourage you to batch them
10:31:21 <dcoutts> Peaker: and those do really depend on being in the right OS thread?
10:31:31 <dcoutts> sounds like you should not make them pure then
10:31:34 <Peaker> dcoutts: unfortunately, in FTGL, they do (it's surely not inherent)
10:31:49 <Peaker> dcoutts: conceptually, asking the font what size certain text is -- should be a pure operation
10:32:07 <dcoutts> but the danger is you delay when it's evaluated, and then boom
10:32:22 <dcoutts> call executed in the wrong thread, wrong answer
10:32:27 <Peaker> dcoutts: unless the communication with the main thread is done inside the unsafePerformIO ?
10:32:39 <dcoutts> which as you say is pretty horrible
10:32:48 <dcoutts> and encourages a style with lots of switching
10:33:08 <Peaker> dcoutts: I can memoize it though, probably
10:33:40 <Peaker> I wonder if there's an existing LRU cache memoizer for Haskell functions
10:34:07 <dcoutts> Peaker: but presumably not all these things are pure
10:34:30 <dcoutts> you'll have this issue with all the little cheap but effectful accessors
10:34:36 <Peaker> dcoutts: I think in my case it's just font sizes
10:35:35 <dcoutts> Peaker: well, have fun
10:36:06 <Peaker> dcoutts: thanks for the help
10:36:14 <dcoutts> np, it's tricky stuff
10:39:28 <c_wraith> I thought bound threads were only required to make FFI calls from the same OS thread, not run on the same OS thread. 
10:42:22 <nitrix> Is it possible to make a newtype of kind :: * a bifunctor?
10:42:57 <c_wraith> no. the class requires two type arguments of kind *
10:44:32 <nitrix> What if it's a wrapper type of two things and I want those two things to be independently mapped?
10:45:36 <c_wraith> if they don't have type variables, does that mean they'll never change types? 
10:45:54 <nitrix> Correct, they'll always be the same inner type :/
10:46:01 <nitrix> Maybe that's the problem in my design?
10:46:05 <c_wraith> I'd recommend lenses
10:46:48 <nitrix> I use lenses.
10:47:32 <nitrix> I have lenses for each thing separatly, I guess I can add one for both
10:47:43 <nitrix> :t both
11:01:15 <Iceland_jack>     data Foo a = Poo
11:06:52 <matrium> hi, how can I "swap" an inner and an outer functor? I have a "Vertex3 (Behavior Double)" and need a "Behavior (Vertex3 Double)"
11:09:00 <Peaker> :t sequenceA
11:09:01 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
11:09:22 <Peaker> matrium: You can only do that if the outer functor is Traversable, and inner is Applicative, which is indeed your case
11:10:29 <Peaker> Maybe I can have a .cabal package that uses Setup.hs trickery to build FTGL's C++ code -- (i.e: ./configure/make/make-install) and then used as a Haskell dep.
11:11:44 <matrium> Peaker: thanks!
11:12:08 <InHale> Hey guys
11:12:53 <InHale> Anyone here?
11:14:15 <int-e> If anyone cares, according to the ISP they're investigating a switch failure that affects lambdabot...
11:15:01 <InHale> Thanks for the news
11:16:18 <InHale> Can anyone help me write a function in haskell?  I'm new to it and don't know exactly what to do
11:16:42 <kadoban> InHale: We can probably give it a shot. What kind of trouble are you running into? What should the function do?
11:16:54 <InHale> Ok, thank you!
11:17:18 <InHale> The function should take an integer
11:17:32 <InHale> and if it's positive it should split it up into individual integers in a list
11:17:45 <InHale> and if it's negative it should return an empty list
11:17:57 <ralu> digits
11:18:10 <InHale> digits?
11:18:15 <Peaker> InHale: What have you tried so far?
11:18:49 <InHale> I don't know where to begin.  I'm thinking that obviously first you need to accept the integer and check if it's positive
11:19:13 <InHale> then split the digits if it is positive and feed them into a list
11:19:30 <ntnt> is there a tutorial for dmap somewhere? I think it might be waht I want, but I have no idea until I understand it
11:20:02 <hello> hello, who can help me with RFID?
11:20:11 <Peaker> InHale: do you know how to define a function? How to use guards?
11:20:20 <ntnt> RFID -- probably not #haskell
11:20:24 <InHale> Yes
11:20:28 <EvanR> #electronics
11:20:51 <Peaker> InHale: http://learnyouahaskell.com/syntax-in-functions look at 'bmiTell'
11:21:26 <Boomerang> InHale to go from an integers to its digits try to div and mod by 10 until the number divided by 10 is 0 (if that makes any sense ^^)
11:22:23 <InHale> That does make sense but how do I apply that to each digit of the integer?
11:26:02 <Boomerang> > let f x | div x 10 > 0 = f (div x 10) ++ [mod x 10] | otherwise = [mod x 10] in f 12345
11:26:04 <lambdabot>  [1,2,3,4,5]
11:26:45 <Boomerang> guards are not easily readable as a one liner, but I believe this is half of your answer InHale :)
11:27:32 <ralu> > let f = map (read . return) . show in f 123 :: [Int]
11:27:34 <lambdabot>  [1,2,3]
11:27:48 <Boomerang> Yeah as a string works too ^
11:27:57 <InHale> Wow, you guys made that work pretty easily...
11:28:05 <InHale> I've got so much to learn lol
11:28:31 <Boomerang> If you have any questions about how we did that, don't hesitate :)
11:28:52 <InHale> Your solution, how would it handle negative int?
11:29:11 <mniip> poorly
11:29:19 <Boomerang> It doesn't, that's why I said it's only half of your answer, just add another guard
11:29:32 <InHale> Can I add a what if statement to check for negative?
11:29:34 <Boomerang> something like | x < 0 = []
11:29:35 <InHale> oh guard, ok
11:29:44 <InHale> Wow, thank you
11:31:16 <arianvp> I'm trying to install hdbi
11:31:20 <Boomerang> (add that guard before the other two)
11:31:25 <arianvp> but the package from hackage wont compile!
11:31:27 <arianvp> I get
11:31:43 <arianvp> hdbi/Database/HDBI/Parsers.hs:133:255: Not in scope: 'fromGregorianValid'
11:31:45 <arianvp> :/
11:32:45 <ralu> > let f x = [read (return v) :: Int | v <- show x , x > 0] in f 123
11:32:47 <lambdabot>  [1,2,3]
11:33:17 <Boomerang> arianvp: Make you have the right versions of the dependencies. If you're not using a sandbox yet try that
11:33:32 <arianvp> I tried in stack + adding some stuff in stack.yaml
11:33:36 <arianvp> trying in cabal sandbox now
11:33:52 <Boomerang> good luck :)
11:33:56 <arianvp> thanks :)
11:36:46 <arianvp> in sandbox I now get:
11:36:47 <InHale> How do I paste my code to share?
11:37:02 <monochrom> go to lpaste.net
11:37:11 <arianvp> Database/HDBI/PostgreSQL/Implementation.hs: Could not find Modules Database.PostgrSQL.Simple.BuiltinTypes
11:37:21 <arianvp> :/
11:37:54 <Boomerang> Since you changed from stack to cabal, have you done "cabal configure" and "cabal install --only-dependencies" ?
11:38:13 <arianvp> wtf
11:38:26 <arianvp> so apparently the dependency of  postgresql in postgresql-hdbi is wrong
11:38:28 <arianvp> or something
11:38:31 <arianvp> stuff seems broken
11:38:44 <Boomerang> :(
11:39:03 <arianvp> "last time uploaded: 2013"
11:39:25 <arianvp> oooh
11:39:32 <arianvp> I need HDBC, not hdbi :)
11:41:19 <InHale> I'm getting an error trying to compile the file now
11:41:33 <InHale> parse error on input '|'
11:42:34 <mjrosenb> InHale: can you pastebin it?
11:42:45 <InHale> the code or the error?
11:43:16 <Boomerang> the code
11:43:34 <lpaste> InHale pasted “InHale” at http://lpaste.net/159990
11:43:59 <InHale> Is it the toDigit x = x| part?
11:44:19 <Boomerang> remove "in f" that was for me to run the example here :)
11:44:38 <InHale> ohhh lol -_-
11:44:48 <Boomerang> and replace "f" by "toDigits"
11:45:44 <lpaste> InHale revised “InHale”: “No title” at http://lpaste.net/159990
11:46:09 <InHale> I keep getting the parse error
11:46:39 <lpaste> Boomerang revised “InHale”: “toDigits” at http://lpaste.net/159990
11:46:57 <geekosaur> InHale, lose the first =
11:46:58 <Iceland_jack> :t divMod
11:47:08 <geekosaur> toDigits x | x ...
11:47:54 <Iceland_jack> lambdabot, where on Earth are you
11:48:34 <Iceland_jack>     divMod :: Int -> Int -> (Int, Int)
11:48:42 <InHale> It's still not working -_-
11:49:00 <geekosaur> confused by all the netsplitting, likely
11:49:09 <lpaste> InHale annotated “InHale” with “InHale (annotation)” at http://lpaste.net/159990#a159993
11:49:48 <Iceland_jack> InHale: are you sure you expect a list as input?
11:49:48 <Iceland_jack>     toDigits :: [Integer] -> [Integer]
11:50:12 <InHale> No, just an integer as input
11:50:14 <InHale> list as output
11:50:27 <geekosaur> this looks generally confused type-wise, yeh
11:50:52 <InHale> Oh ok fixed it
11:50:57 <Boomerang> I corrected your type signature in my "revision" :)
11:50:57 <Iceland_jack> geekosaur: Fish swim through netsplits. --old saying
11:51:23 <InHale> I changed the [Integer] -> [Integer] to Integer -> [Integer]
11:51:29 <InHale> seems to work
11:52:00 <InHale> I love this channel
11:52:10 <InHale> I've never received more help from other language channels
11:52:16 <InHale> You guys are great
11:52:27 <Boomerang> :D
11:52:35 <InHale> Think I'm gonna stick with Haskel;
11:52:39 <InHale> Haskell*
11:52:46 <Iceland_jack> *score!*
11:52:49 <InHale> Lol
11:53:28 <Iceland_jack> InHale: Next thing is to think of a property your function satisfies and see that it does
11:53:38 <Iceland_jack> with QuickCheck
11:54:04 <Boomerang> Probably a bit advanced if InHale just started
11:54:06 <InHale> Oh I just noticed something
11:54:21 <InHale> If I feed it 0, it returns [0] instead of []
11:54:30 <spion_> What library would you recommend for using regular expressions on large amounts of Data.Text.Text ? :)
11:54:31 <Iceland_jack> Boomerang: Maybe so
11:54:41 <hpc> spion_: how large?
11:54:53 <Boomerang> InHale: change "x < 0" to "x <= 0"
11:55:07 <mauke> spion_: also, what kind of regex?
11:55:08 <spion_> hpc: ~ 50MB
11:55:10 <hpc> spion_: if it's ridiculously super-ultra large, maybe use perl ;)
11:55:20 <hpc> also what mauke said
11:55:28 <mauke> also, embed perl into your program
11:55:31 <InHale> Oh that worked...  I tried changing it to  < 1 and it still gave same output
11:55:36 <InHale> but <= 0 worked
11:55:39 <hpc> regexes in haskell are... weird
11:56:05 <hpc> substitutions are a pain, the libraries are all over the place in terms of quality and what interface they providde
11:56:10 <spion_> mauke: I'd say any regex dialect would probably do.. probably.
11:56:12 <Boomerang> "< 1" should worked too
11:56:18 <hpc> you may want to write a parser
11:56:19 <mauke> spion_: I'm not talking about the syntax
11:56:28 <InHale> I actually forgot to load it again -_- lol
11:56:31 <InHale> that's the problem
11:56:38 <InHale> Not used to doing the reloading all the time
11:56:39 <InHale> haha
11:56:48 <hpc> are you using :r in ghci?
11:56:51 <Boomerang> What are you writing haskel in?
11:56:59 <Boomerang> *Haskell
11:57:02 <ntnt> how does https://hackage.haskell.org/package/dependent-sum-0.3.2.1/docs/src/Data-Dependent-Sum.html#DSum work ?
11:57:02 <InHale> TextMate, and running it through terminal using ghci
11:57:09 <ntnt> how can I define things of the form "DSum Tag"
11:57:13 <ntnt> if the data is "DSum tag f"
11:57:23 <spion_> mauke: not sure what you mean by kind then. the regex is an input argument to the (command line) program
11:57:26 <spion_> :)
11:57:41 <mauke> spion_: and what does your program do with it?
11:57:52 <spion_> it filters entries that match it, then tries to find correlations
11:58:18 <mauke> ok, boolean results
11:58:34 <hpc> spion_: so you need the string-representation of regexes and matching but not substitution ;)
11:59:02 <spion_> hpc: I might also want splitRegex, but... I guess thats a pony :)
11:59:39 <InHale> Ok I have a question about another function
12:01:03 <mauke> ntnt: I don't understand the question
12:04:30 <InHale> Anyone here still?
12:04:35 <meoblast001> i have the common problem of not knowing how to convert between different floating or fractional types in haskell
12:04:43 <meoblast001> does anyone know how to go from Double -> Decimal?
12:05:05 <monochrom> realToFrac
12:05:26 <Iceland_jack> InHale: Post your function
12:06:26 <InHale> Ok 
12:06:51 <meoblast001> monochrom: thanks
12:07:30 <InHale> Ok so this function has 3 parts.  1 is to map all letters of a string into uppercase
12:09:14 <Iceland_jack> :t map toUpper
12:09:15 <lambdabot> [Char] -> [Char]
12:11:20 <InHale> What
12:11:25 <InHale> is the :t?
12:11:43 <monochrom> it tells you types
12:12:02 <Iceland_jack> :t (True, "hello")
12:12:03 <lambdabot> (Bool, [Char])
12:12:10 <Iceland_jack> > (True, toUpper "hello")
12:12:11 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
12:12:11 <lambdabot>      In the first argument of ‘toUpper’, namely ‘"hello"’
12:12:11 <lambdabot>      In the expression: toUpper "hello"
12:12:16 <Iceland_jack> > (True, map toUpper "hello")
12:12:18 <lambdabot>  (True,"HELLO")
12:12:45 <InHale> Lol, jeez you make this stuff look easy
12:14:34 <Iceland_jack> You'd be surprised :)
12:14:44 <InHale> Hope I get there eventually!
12:15:11 <nitrix> InHale: We've all be in yours shoes, and trust me, me wasn't very long ago :)
12:15:23 <InHale> That's encouraging
12:15:45 <nitrix> > toUpper <$> (True, "hello")
12:15:47 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
12:15:47 <lambdabot>      In the expression: "hello"
12:15:47 <lambdabot>      In the second argument of ‘(<$>)’, namely ‘(True, "hello")’
12:15:57 <nitrix> > map toUpper <$> (True, "hello")
12:15:59 <lambdabot>  (True,"HELLO")
12:16:54 <InHale> I feel like writing that into a function is messing me up
12:17:02 <InHale> is toUpper built in?
12:17:07 <Iceland_jack> InHale: It's from Data.Char
12:17:20 <Iceland_jack> I also sent you a PM InHale 
12:17:20 <InHale> ?
12:17:30 <nitrix> InHale: If it helps, you could define a helper, strToUpper = map toUpper
12:18:00 <nitrix> But I think understanding why this works is a better idea :)
12:18:05 <InHale> That's what I was trying to do
12:18:10 <InHale> with the helper
12:18:17 <Iceland_jack>     ghci> import Data.Char
12:18:17 <Iceland_jack>     ghci> let strToUpper = map toUpper
12:18:17 <Iceland_jack>     ghci> strToUpper "Hello!"
12:18:17 <Iceland_jack>     "HELLO!"
12:21:59 <lpaste> InHale revised “InHale”: “No title” at http://lpaste.net/159990
12:24:03 <Iceland_jack> InHale: http://lpaste.net/159990
12:24:19 <Iceland_jack> 'string' should be capitalised
12:24:28 <InHale> Oh ok
12:24:44 <InHale> It worked with Char, will there be a huge difference?
12:24:55 <matrium> is there something like an "Applicative p Traversable t => p (t (a -> b)) -> p (t a) -> p (t b)"? 
12:25:53 <hpc> that looks like some kind of (<*>) for Traversable
12:26:02 <hpc> smushed into an Applicative
12:26:34 <hpc> is t also an Applicative?
12:26:42 <Zemyla> matrium: No, the applicatuve instance for Compose requires two Applicatives.
12:26:59 <Zemyla> It doesn't require the Applicatives to be Traversable.
12:29:27 <Iceland_jack> InHale: String and [Char] are exactly the same thing :)
12:29:42 <Iceland_jack> @src String
12:29:42 <lambdabot> type String = [Char]
12:31:30 <matrium> Zemyla: is there any way to "Applicative p Traversable t => (a -> b -> c) -> p (t a) -> p (t b) -> p (t c)"?
12:31:36 <geekosaur> the "type" keyword in Haskell is a bit confusingly named, since it doesn't create a new type ("data" and "newtype" do that), it creates a synonym for an existing type
12:32:24 <Zemyla> matrium: Not on an arbitrary Traversable, because Traversable has no methods that take two values.
12:32:41 <mauke> (if you know C ==> "typedef")
12:41:56 <matrium> Zemyla: Ok, thank you!
12:51:37 <dolio> I'm not really sure why the way "type" works would be confusing in isolation.
12:51:55 <dolio> If you had a background in ML, it'd be confusing.
12:52:46 <java_ninja> hey guys
12:53:17 <java_ninja> what do people recommend for saving/reloading in-memory state (this is for data analysis)? cereal?
12:53:28 <lpaste> InHale annotated “InHale” with “InHale (annotation)” at http://lpaste.net/159990#a159998
12:56:28 <orion> Is there a standard function with type: [a] -> [a] -> [Bool] which compares the lists for equality?
12:56:42 <mauke> yes, (==)
12:56:44 <Iceland_jack> (==)
12:57:00 <EvanR> Eq a => [a] -> [a] -> Bool
12:57:19 <orion> No.
12:57:28 <cocreature> :t zipWith (==)
12:57:29 <lambdabot> Eq a => [a] -> [a] -> [Bool]
12:57:33 <orion> Yes.
12:57:34 <cocreature> ^ orion 
12:57:38 <orion> Thanks!
12:57:39 <mauke> cocreature: that's different
12:57:41 <mauke> er
12:57:44 <mauke> oops
12:57:48 <cocreature> mauke: that’s the type signature he provided
12:57:52 <geekosaur> that one will stop when it hits the end of one of the lists, anbd not tell you anything about following elements in the other
12:58:00 <mauke> indeed, but not the description he provided
12:58:09 <orion> hmm
12:58:26 <mauke> :t liftA2 (==)
12:58:28 <lambdabot> (Eq a, Applicative f) => f a -> f a -> f Bool
12:58:33 <mauke> while we're at it
12:59:37 <EvanR> @pl \xs ys -> (null xs) && (null ys)
12:59:37 <lambdabot> (. null) . (&&) . null
13:01:50 <orion> mauke: with liftA2 (==), will the lengths of all the lists be equal?
13:02:02 <orion> (Assuming the inputs have the same length)
13:02:31 <mauke> what lists
13:02:48 <orion> The inputs to the function you provided?
13:03:15 <dolio> Depends on which Applicative you use.
13:03:44 <mauke> assuming the inputs have the same length, the length of the lists will be equal, yes
13:03:52 <mauke> P => P
13:04:16 <EvanR> law of identity?
13:05:16 <orion> mauke: ghci disagrees.
13:05:41 <orion> let x = [1, 2, 3, 4]; let y = [1, 2, 3, 5]; liftA2 (==) x y; [True,False,False,False,False,True,False,False,False,False,True,False,False,False,False,False]
13:05:43 <mjrosenb> can haddock be used to document the type arguments to a type constructor?
13:06:26 <orion> I was hoping for [True, True, True, False]
13:06:42 <Iceland_jack> orion: You want ZipList then
13:06:48 <mauke> orion: [1,2,3,4] and [1,2,3,5] have the same length
13:06:56 <dolio> mjrosenb: Have you tried '-- ^ comment' after each parameter?
13:07:01 <Iceland_jack> > liftA2 (==) (ZipList [1..4]) (ZipList [1,2,3,5])
13:07:02 <lambdabot>  ZipList {getZipList = [True,True,True,False]}
13:07:19 <mjrosenb> dolio: nope, that was only mentioned for the data constructors.
13:07:20 <cocreature> > zipWith (==) [1..4] [1,2,3,5]
13:07:21 <lambdabot>  [True,True,True,False]
13:07:33 <dolio> mjrosenb: Worth a try, at least.
13:07:38 <Iceland_jack> (if you want to use the Applicative instance that is)
13:08:07 <orion> > zipWith (==) [1..4] [2, 2, 3, 4]
13:08:08 <lambdabot>  [False,True,True,True]
13:08:28 <mjrosenb> let factors x = filter (
13:08:29 <orion> > zipWith (==) [1..10] [2, 2, 3, 4]
13:08:30 <lambdabot>  [False,True,True,True]
13:08:33 <mjrosenb> gah
13:08:57 <Iceland_jack> InHale: 
13:08:58 <Iceland_jack> @pl sumOdd' xs = sum (map (^2) (filter odd xs))
13:08:58 <lambdabot> sumOdd' = sum . map (^ 2) . filter odd
13:09:22 <mjrosenb> > let factors x = filter (\f -> x `mod` f == 0) [1..x] in mapM factors [6..10]
13:09:24 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,5],[1,1,1,1,10],[1,1,1,3,1],[1,1,1,3,2],[1...
13:09:25 <InHale> :o
13:09:26 <dxtr> Do the "Once you go IO you never go back" apply to all monads?
13:09:32 <ertesx> mjrosenb: i haven't found a way to do it, so most of my type docs start with: "A value of type @T a b@ is ..."
13:09:38 <mjrosenb> there /really/ should be a use for that.
13:09:40 <Iceland_jack> dxtr: No
13:09:42 <mjrosenb> ertesx: good to know.
13:09:43 <orion> cocreature: Thanks
13:09:58 <Iceland_jack> dxtr: But that statement needs some caveats
13:10:10 <dxtr> Iceland_jack: So is it just IO that is special or are there others?
13:10:40 <mniip> dxtr, it's not a special case
13:10:51 <mniip> not any more of a special case than, say, the 'abs' function
13:10:55 <Iceland_jack> dxtr: Let me ask you back, is there such a function from lists? 
13:10:56 <ertesx> mjrosenb: especially useful for GADTs with unnamed type arguments:  data T :: * -> (* -> *) -> * where …
13:11:06 <mjrosenb> ertesx: I'd imagine.
13:12:02 <ertesx> dxtr: the statement is a bit misleading: all programs start from IO
13:12:11 <ertesx> it's more like you go from IO into the pure world and back
13:12:22 <ertesx> and you usually try to stay in pure world as long as possible
13:12:42 <mniip> ertesx, I think they mean how IO poisons the type signature
13:13:01 <ertesx> does it?
13:13:17 <mniip> if you have an IO value you can only make an another IO value from it
13:13:21 <mniip> unless you discard it completely
13:13:37 <ertesx> sure, but that's not really poisoning
13:13:44 <ertesx> you're computing programs from programs
13:14:18 <mniip> that's what the question is about, as I see it
13:14:29 <dxtr> I know you're probably sighing so hard right now but I am still trying to grasp some core concepts
13:15:08 <Iceland_jack> dxtr: What you're asking has a somewhat nuanced answer because it can be interpreted in a couple of ways :)
13:15:11 <ertesx> i think, this may be an instance of a common misconception: an "IO String" is not "a String tainted with side effects"
13:15:33 <ertesx> if it were, then it would make sense that you can't "untaint it"
13:15:49 <dxtr> ertesx: I am absolutely certain I am thinking about this in the wrong way and/or possibly over-complicating it
13:15:56 <mniip> that's just twisting words
13:15:58 <puregreen> dxtr: monads are just things that can be composed in a certain way; once you're in IO you can't get out, yeah, but e.g. Maybe is a monad too and you absolutely can unwrap it
13:16:10 <ertesx> dxtr: IO String is to String what /bin/ls is to a list of files
13:16:14 <ertesx> a program
13:16:19 <puregreen> dxtr: IO isn't special because it's easy to define other types that can't be unwrapped
13:16:34 <mniip> yeah e.g the Proxy monad
13:16:39 <ertesx> dxtr: f :: IO A -> IO B  -- this function takes a program and gives you a program back
13:16:55 <ertesx> dxtr: main :: IO ()  -- this is the program that runs, when you start your application
13:17:34 <puregreen> dxtr: for instance, if you define “data X a = Wrapper a” and then export X (the type) but not Wrapper (the constructor), then nobody would be able to do anything with an X (apart from some operations that you might provide)
13:17:57 <dxtr> puregreen: I think I just heard a slight click in my head when you mentioned that :)
13:18:32 <puregreen> yay
13:18:51 <dxtr> I think I'm getting closer :p
13:19:14 <ertesx> f :: IO a -> a  -- this function would effectively be an interpreter for its argument program
13:20:05 <EvanR> f :: IO a -> (a, Effects) ? ;)
13:20:28 <EvanR> (an operational semantics of C)
13:20:44 <ertesx> EvanR: that wouldn't work, because effects and evaluation are interleaved (remember (>>=))
13:21:04 <ertesx> unless you have a complete state of the universe within 'f' you can't write the function
13:21:13 <EvanR> better that IO a -> a ;)
13:21:59 <ertesx> the only way to interpret an IO program in a pure setting is to emulate a machine
13:22:09 <ertesx> and then you don't need Effects =)
13:22:12 <EvanR> and possible emulate physics
13:22:14 <puregreen> splitIO :: IO a -> (a, IO ())
13:22:15 <EvanR> possibly
13:25:04 <monochrom> you may like my http://www.vex.net/~trebla/photo/unorganized/IO-String.png
13:25:17 <EvanR> ertesx: theres a lot of ways to interpret IO, not necessarily by emulating a machine
13:26:06 <monochrom> actually I should improve its wording
13:26:07 <EvanR> right angle is the only thing i understand from that diagram
13:26:21 <ertesx> monochrom: i don't get it =/
13:26:37 <puregreen> I like the colors
13:26:43 <puregreen> but yeah, I don't get it either
13:26:53 <mniip> monochrom, nice pushout
13:27:12 <TimWolla> For a combinatorics exercise I am simulating a roll of five dice using the list monad like this: [ [a,b,c,d,e] | a <- [ 1..6 ], b <- [ 1..6 ], c <- [ 1..6 ], d <- [ 1..6 ], e <- [ 1..6 ] ]. Is it possible to write this more DRY (apart from things like let dice = [ 1.. 6 ])?
13:27:16 <monochrom> hehe. yeah, look for "pushout" from category theory
13:27:21 <ertesx> EvanR: IO is turing-complete, so you'll emulate a machine
13:27:23 <mniip> TimWolla, replicateM
13:27:25 <puregreen> was it basically a CT test that we all failed?
13:27:34 <puregreen> except for mniip
13:27:39 <mniip> well I don't get it either
13:27:41 <EvanR> ertesx: ehhhhh
13:27:44 <mniip> I've just seen the notation
13:27:48 <monochrom> in fact it's a basic CT test that you all failed :)
13:27:54 <EvanR> even asserting that it is turing complete first requires an interpretation
13:28:02 <Peaker> > [ a+b+c+d+e | [a,b,c,d,e] <- replicateM 5 [1..6] ]
13:28:04 <lambdabot>  [5,6,7,8,9,10,6,7,8,9,10,11,7,8,9,10,11,12,8,9,10,11,12,13,9,10,11,12,13,14,...
13:28:11 <ertesx> monochrom: i saw the structure, but i didn't get it anyway =)
13:28:20 <TimWolla> Thanks mniip and Peaker.
13:28:38 <monochrom> pushout and pullback don't get a lot of love from Haskell users. instead, they flock over to adjunction.
13:28:56 <TimWolla> I was sure I had seen it before, but could not find it.
13:28:57 <monochrom> and adjunction is where I'm very weak
13:29:02 <__jim__> Any suggestions on which JWT library to use? I see there are a few with somewhat active repositories.
13:29:04 <ertesx> TimWolla: note that replicateM on lists is slow and memory-hungry
13:29:08 <Iceland_jack> monochrom: Adjunctions are very weak in Haskell anyway..
13:29:11 <monochrom> so my skill is complementary to most Haskell users' skills.
13:30:00 <TimWolla> ertesx, it was a one-off exercise and the question was out of pure curiosity. Thanks for the information, though.
13:30:48 <monochrom> adjunction is more familiar because you need it for "free ___" being the left adjoint of a forgetful functor.
13:31:07 <mniip> monoids in the category of endofunctors
13:31:46 <monochrom> and I don't even have a Chinese-room level of understanding of that. I can't even recite the definition.
13:36:23 <dolio> monochrom: It's forgivable, because you can't do pushout and pullback in Haskell.
13:36:38 <dolio> At least in any good way.
13:40:49 <Cale> monochrom: One way to remember which is the left adjoint is to think about which arrows are equivalent. F is left adjoint to G means that a map F X -> Y is "the same thing as" a map X -> G Y
13:42:25 <Cale> monochrom: So for example, given a field K, providing a linear map from the free K-vector-space on a set X to any other vector space Y, is equivalent to providing a function from the set X to the underlying set of the vector space Y
13:43:33 <Cale> So the functor which constructs the free vector space of K-linear combinations of a set X is left adjoint to the functor which forgets the vector space structure and takes the underlying set.
13:43:44 <Cale> (left because it's on the left of the arrow in that equivalence)
13:46:36 <shachaf> Cale: Hmm, maybe a better name for adjoints would account for the fact that F is on the contravariant side of the hom functor and G is on the covariant side.
13:48:07 <Peaker> Does anyone know the status of FontyFruity? It doesn't seem to have kerning support?
14:00:04 * hackagebot lmonad-yesod 0.2.0.0 - LMonad for Yesod integrates LMonad's IFC with Yesod web applications.  https://hackage.haskell.org/package/lmonad-yesod-0.2.0.0 (jp_rider)
14:41:56 <Jinxit> who needs ke rning anyways?
14:42:19 <Cale> keming
14:43:22 <ntnt> is there a good "learn template haskell through 99 exercises" tutorial?
14:43:24 <orion> http://www.willamette.edu/~fruehr/haskell/evolution.html
14:43:28 <ntnt> I just want a list of more complicated TH practice problems
14:44:28 <Cale> ntnt: Good question, I haven't seen anything like that. Everything I know about TH, I learned right as I needed it from the Haddock documentation.
14:44:58 <ntnt> Cale: yeah, I guess I'm a bit greedy and have a soft spot for 'drills/exercises'
14:45:06 * hackagebot scotty-view 1.0.0 -   https://hackage.haskell.org/package/scotty-view-1.0.0 (Philemon)
14:45:11 <ntnt> i.e. mastering the fundamentals before doing stuff rather than learning it on the fly / just in time
14:45:20 <Cale> I usually prefer that myself.
14:45:31 <ntnt> the 'master the basics' or 'just in time' ?
14:45:31 <Cale> Actually, what I said isn't entirely true -- there was a paper
14:45:51 <ntnt> I think I'll start with http://dev.stephendiehl.com/hask/#template-haskell ; stephen diehl generally writes good stuff
14:45:52 <Cale> I usually prefer learning things thoroughly before just trying stuff
14:46:34 <Cale> http://research.microsoft.com/pubs/67015/meta-haskell.pdf
14:46:51 <Cale> This paper... probably isn't even totally correct anymore
14:46:55 <ntnt> simon peyton jones writes some good stuff too
14:47:14 <Cale> Wait, maybe there was a more recent one
14:47:15 <ntnt> well, it's SPJ , I don't mind learning the hsitory / evolution of TH
14:48:00 <Cale> ... maybe not :)
14:49:38 <Cale> They recently adjusted the way that TH works, adding a bit more type safety in some places where you want it, and a bit less in places where it's in the way.
14:49:41 <Cale> https://ghc.haskell.org/trac/ghc/wiki/TemplateHaskell/BlogPostChanges
14:49:49 <Cale> seems to describe things well enough
14:50:15 * hackagebot map-exts 0.1.0.0 - Extensions for Data.Map  https://hackage.haskell.org/package/map-exts-0.1.0.0 (coopercm)
14:50:54 <ggVGc> I was thinking today about how do make a diff system for records, automatically in some way. I think it would require TH? I.e if I have two values of a record, I'd like it to be stored in the value which fields have been modified, without having to compare them
14:51:45 <hiptobecubic> Template Haskell seems to be pretty widely disliked compared to, say, lisp macros, which people worship like some kind of arcane god. What gives?
14:51:46 <Cale> ggVGc: I'd be happy with just a systematic means of *representing* and applying the differences, let alone something which computes them.
14:52:10 <Peaker> hiptobecubic: Haskellers have their heads screwed on better? :)
14:52:20 <hiptobecubic> Peaker, that's just what I'm referring to :)
14:52:22 <Peaker> (and TH is painful)
14:52:23 <ggVGc> Cale: yeah. My use case is for easy implementation of network protocols
14:52:37 <Cale> hiptobecubic: Lazy evaluation weakens a lot of the use cases for macros.
14:52:38 <ggVGc> where you could get a delta for transmission without manual work
14:52:39 <ggVGc> would be nice
14:52:55 <hiptobecubic> Cale, has anyone written about that? Maybe with examples?
14:53:07 <ntnt> ggVGc: I need to solve this exact problem
14:53:19 <hiptobecubic> Cale, not template haskell itself, but why lazy evaluation makes it less marginally useful?
14:53:20 <ggVGc> ntnt: when you do, you should tell me!
14:53:21 <ntnt> ggVGc: (of "diffs" on haskell data types)
14:53:41 <ntnt> ggVGc: often times, I don't want v1, v2, v3, ..., vn
14:53:52 <ntnt> instead, I want v1, d(v2, v1), d(v3, v2), ..., d(vn, v(n-1))
14:53:58 <ntnt> and I don't wnat to ahve to diff the structures to get the patch
14:54:00 <Cale> hiptobecubic: Well, it's just that any time you'd need something which might not need its arguments in a strict setting, you either need to always wrap those arguments in lambdas (the body of a lambda won't be evaluated until it's applied), or else use a macro.
14:54:07 <ntnt> it'd be nice if there was some way to 'compute' on deltas
14:54:10 <hiptobecubic> wouldn't a reasonable diff type of any record just transform every field a to Maybe (a,a) ?
14:54:12 <Cale> hiptobecubic: So they use macros a lot for that kind of things
14:54:14 <Cale> -s
14:54:39 <ggVGc> ntnt: I was thinking that I'd just have all constructors hidden, and for each field there would be a counter, and then expose setter functions that increase the counter for each field. And then a diff algorithm can be implemented in terms of that
14:54:43 <ggVGc> dunno if that is reasonable
14:54:55 <Cale> hiptobecubic: Think about a record full of Maps, you'd probably want to push the Maybe into the values of the Map
14:55:11 <ntnt> hiptobecubic: if we have Map Int (Map K [Int]]), I want a 'diff' of the form "key = 2, Key = blah, 8th item" got updated to 23 .. automatically
14:55:36 <ntnt> ggVGc: the 'counter' is to keep track of versions?
14:56:25 <Cale> Yeah, ideally you also have a monoid instance to combine the differences
14:56:30 <hiptobecubic> that's a diff of maps, not records. Your function would return a (Just (mapDiff m0 m1)) instead of (Just ((,) m0 m1))
14:56:31 <ggVGc> ntnt: well, basically just to know if it changed. So instead of comparing a value you compare an int. 
14:56:42 <hiptobecubic> I smell a delicious, lawless type class?
14:56:48 <Cale> hiptobecubic: heh
14:56:51 <ggVGc> ntnt: but my idea would require implementing each container as a diffable one. so for a map you'd need a special DiffableMap
14:56:54 <ggVGc> etc.
14:57:02 <Cale> hiptobecubic: With some class associated types
14:57:22 <ntnt> ggVGc, no no, you can change (Map k v) to (Int, Map k (Int, v))
14:57:28 <ggVGc> ah, fair
14:57:32 <Cale> ntnt: What are the Ints?
14:57:35 <ggVGc> I don't know if it's a reasonable idea
14:57:41 <ggVGc> but it's the best I could come up with
14:57:42 <ntnt> ggVGc: they're 'version numbers' that ggVGc proposed
14:57:50 <Cale> ah
14:57:59 <ntnt> ggVGc: I'd still prefer to just 'transmit diffs' rather than "using ints to amke diffing cheaper"
14:58:01 <Cale> I wouldn't bother with version numbers, that doesn't seem so composable
14:58:10 <hiptobecubic> ggVGc, if all you need to know is whether or not it changed, you can look at the Maybe constructor, no?
14:58:31 <Cale> You also need a way to say when a key in the Map was deleted
14:58:56 <ntnt> Cale: yeah, good point
14:59:05 <ntnt> I do think this is a situation where "TH" might be the right answer unfortunately :-(
14:59:06 <Cale> data Modification a = New a | Modified (Delta a) | Deleted
14:59:07 <ggVGc> Cale: heh.. data DiffState = Exists Int | Gone
14:59:21 <Cale> Delta (Map k v) = Map k (Modification v)
14:59:38 <ggVGc> hiptobecubic: not sure I understand what you mean?
14:59:41 <hiptobecubic> Delta a seems like it is too restrictive
14:59:53 <Cale> hiptobecubic: Presumably it's a type family
14:59:56 <hiptobecubic> ggVGc, I mean are you just comparing v0 and v1 to see if they are equal? 
15:00:02 <ntnt> Cale: hmm, I was thinking "data DeltaMap_ k v = Deleted k | Update k v | Insert k v ; data DeltaMap = [DeltaMap_]"
15:00:03 <Cale> I didn't completely define what a Delta a was
15:00:14 <hiptobecubic> Cale, I'm still too ignorant to know what that implies.
15:00:24 <ggVGc> hiptobecubic: the point is that if I can say "the version doesn't match" I know that a whole tree of the record(if nested) is not changed
15:00:27 <ggVGc> without doing a comparison
15:00:47 <Cale> hiptobecubic: I only said what Delta was for Maps -- for other types it might be something different
15:01:03 <hiptobecubic> Cale, ohh i think I follow
15:01:05 <ggVGc> ntnt: what does "just transmit diffs" mean?
15:01:06 <ntnt> Cale: so the Cale way of learning TH is just reading https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH.html and https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Quote.html ?
15:01:15 <Cale> ntnt: Yeah
15:01:39 <ntnt> ggVGc : suppose I have a "Map k v" that is rendered to DOM -- instead of doing it in a REACT-way of sending a new "Map k v" every time, instead, I just send the DeltaMap k v's described above
15:01:50 <Cale> ntnt: and it's a big sprawling mess, but eventually you get the idea of what's going on
15:02:11 <ggVGc> ntnt: yeah, but to generate the diff you need a fucntion generating the diff, which is where I see the counter coming into play
15:02:16 <ntnt> Cale: well, I have a number of legal pads and V5's so this seems like a godd time as any other to read thoruhg this
15:02:28 <ntnt> ggVGc : no, I was thikning "diffs all the way down"
15:02:36 <Cale> ntnt: We've been working on such problems where I work, and solving them on a case-by-case basis, so I've been thinking about how to generalise the situation quite a bit recently.
15:02:37 <ggVGc> ah, yeah fair
15:02:41 <ggVGc> that's harder I uess
15:02:45 <ggVGc> I can't difure that out :(
15:02:50 <ggVGc> figure*
15:03:16 <Cale> ntnt: Oh, and don't forget the GHC user's guide
15:03:30 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html
15:03:35 <ggVGc> ntnt: but it's interesting. so instead, each setter would incrementally build up the diff essentially
15:03:41 <Cale> That's actually probably the best thing to start with
15:04:45 <ntnt> Cale: I read a number of Monad tutorials; nothign made sense, then one day, someone said "fuck it, go implement the Reader / State / Writer / List / Maybe monads -- and I did, and Monads made sense" ; similarly, TH 'tutorials' feel a bit the same (though nicer than Monad tutorials)
15:05:12 <Cale> ntnt: Even just *using* some monads is a good way to get a feel for it
15:05:22 <Cale> ntnt: *Especially* a Parser monad.
15:05:33 <ggVGc> "Oh, I think I wanna learn some haskell. Monad monad monad monad monad monad.. FML"
15:05:41 <ggVGc> "I'm jsut gonna write some text processing code"
15:05:41 <hpc> writing your first working parser feels absolutely incredible
15:05:45 <ntnt> Cale: I actually found Parsec very confusing until *after I impelmented a few mondas first*
15:05:52 <ntnt> it seemed too magical to udnerstand wtf was going on
15:05:57 <Cale> I don't think I really understood what Monad was about until I used Parsec.
15:06:00 <ntnt> I was constantly wondeirng "how is this not exponential time" ?
15:06:27 <ggVGc> dealing with Maybe is basically the only monadic operations I ever do in my code..
15:06:40 <hpc> my first time through parsec, i was thinking in terms of more naive CFG parsing and wondering why it doesn't automatically backtrack
15:07:02 <Welkin> ggVGc: use a web framework
15:07:15 <Welkin> then almlost everything is in IO of some kind
15:07:29 <ntnt> http://dev.stephendiehl.com/fun/002_parsers.html#nanoparsec <-- I didn't really get Parsec until this
15:07:29 <hpc> web frameworks tend to have a bit of magic in them as well
15:07:53 <hpc> though if you already know web stuff, it's a perfect starting point for just how concrete everything ends up being
15:07:54 <Welkin> sure, but you get to use a lot of monads
15:07:57 <Welkin> Yesod ftw
15:07:59 <hpc> "this is a url lookup thing"
15:08:00 <ggVGc> ntnt: I'm thinking, how do you implement "diffs all the way down" without losing type safety of your fields?
15:08:03 <hpc> "this is an html thing"
15:08:06 <hpc> "this is an http thing"
15:08:11 <Welkin> the key is to read the source
15:08:15 <Welkin> and understand how it works
15:08:25 <Welkin> at first, I just used YEsod without understanding it
15:08:31 <Welkin> then later, I took the time to understand it
15:08:32 <ntnt> ggVGc: I don't think you lose typesafety at all; why would you lose typesafety ?
15:08:49 <Cale> ntnt: Though those instances are so much more readable if you implement runParser and then use that everywhere instead of pattern matching.
15:08:54 <Cale> (perhaps surprisingly)
15:09:09 <ggVGc> ntnt: hm, yeah, I guess not. But what's the type of a "diff entry"?
15:09:22 <hpc> a lot of standard library things have more readable definitions that aren't used for some particular reason or another
15:09:25 <ggVGc> ntnt: the way I see it it'll be a start value with all fields set, and then a list of diffs
15:09:29 <ggVGc> but what type are those diffs
15:09:29 <ntnt> ggVGc: ah, you need a separate "diff entry type" for EVERY data type you define in haskell
15:09:45 <hpc> usually very very good reasons
15:10:10 <ntnt> ggVGc: so if we have "data Foo = { f1 :: t1, f2 :: t2, f3 :: t3 }" we need TH to generate "data FooDiff = F1Update t1 | F2Update t2 | F3Update t3"
15:10:20 <ggVGc> ntnt: yea, that's what I imagined
15:10:31 <ntnt> yeah, so we have type safety, but boy oh boy do we need TH
15:10:39 <ggVGc> ntnt: the reason I thought about my counter thing, is because it can be done by hand to test how it works, fairly easily
15:10:42 <ggVGc> before involving TH
15:11:15 <hpc> to some extent, TH is a language that compiles to haskell
15:11:17 <ntnt> I don't like (Int, Map k (Int, v)) -- because after you know that SOME ELEME of the map changed, how do you figure out WHICH ELEM changed? -- that would require linearly running through the map
15:11:26 <ntnt> ggVGc: ^ whereas, the diff gives it to you in O(1) time
15:11:27 <hpc> much as haskell compiles to core (which is also a typed language)
15:12:15 <ggVGc> ntnt: yeash, it's obviously not optimal, but it's better than diffing through equality
15:12:17 <ntnt> TH is "one day, in a bar, a lisp programmer said to a haskell programmer "lisp code can generate lisp code; you can't do that in haskell" and the haskell programmer said "oh yeah?""
15:12:49 <MichaelBurge_> Can you do a diff structure with Generics? I haven't used those much, but I see some libraries using them.
15:13:29 <ntnt> MichaelBurge_: I thought aboutit, but then got stuck on "can generics *DEFINE* a *NEW* data *TYPE* ?"
15:13:38 <ntnt> and afaik, I haven't seen any generics tutorials do that
15:14:08 <ggVGc> ntnt: either way, get on it
15:14:10 <ggVGc> I need it
15:14:18 <ggVGc> you better do it now ;)
15:14:33 <ggVGc> you're so smart and crafty, I'm sure you can do it quickly
15:14:37 <ggVGc> *wink*
15:14:50 <ntnt> ggVGc: here are the first line {-# LANGUAGE TemplateHaskell #-} -- I'll leave the next few lines to you
15:14:56 <hanky> Hi guys
15:17:06 <ntnt> Cale: can I think about the "Quasi Monad" in the following way? In general compiler writing, one tends to have a Compiler monad for keepnt track of randoms tuff like (counter for next fresh var; doing some IO when needing to read header files, structs processed so far, etc ...) -- is the Quasi Monad basically the same thing, but for quasi quoting?
15:18:22 <Cale> Yeah, the Q monad has access to things like reify, see the Quasi class at the top here https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html
15:18:49 <bsermons> I have an existing mongo app with a field that stores a unix timestamp as an int.  Is it possible to set up persistent to decode that into a `Day' type on the entity with some custom marshaling code or will I just have to keep it as an integer?
15:18:57 <Cale> It can get information about stuff which is defined and let you take apart the declarations
15:19:06 <ntnt> Cale: Yeah, I'm not asking about Q Monad yet -- still reading up on Quasi Monad -- with things like qNewName, qLookupName, it does seem to be like a "compiler monad" almost
15:19:18 <Peaker> What's the nicest package that has simple V1/V2/V3/.. types with the obvious instances?
15:19:21 <Cale> ntnt: Quasi isn't a monad
15:19:27 <Peaker> "linear" is brittle
15:19:30 <Cale> ntnt: It's just a type class
15:19:33 <ntnt> https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/src/Language.Haskell.TH.Syntax.html#Quasi ?
15:19:45 <ntnt> okay, you're right
15:19:51 <ntnt> it requires that m be a Monad, but Quasi is not a monad.
15:20:03 <Cale> ntnt: It has instances for Q and IO, but the instance for IO is fairly crippled
15:20:54 <Cale> as in, most of the Quasi methods won't really work in IO
15:21:08 <Cale> qNewName will though
15:21:13 <Cale> (but that's it)
15:21:25 <Cale> oh, and qReport
15:21:54 <Cale> and qRunIO, obviously
15:23:22 <Cale> ntnt: So the gist of it is that if you want to look up information about the things which have been declared, you need to do it from a Q action.
15:24:02 <ntnt> Is that the same as saying "if you want to look up info / create fresh vars", you need to do it from inside a Monad m, which also implements the Quasi typeclass ?
15:24:15 <ntnt> oh right, Q m implies "m is a monad" and "m implements QUasi"
15:24:17 <ntnt> okay, we're on the same page
15:24:24 <Cale> uhhh
15:24:28 <Cale> Q is itself a monad
15:24:32 <Cale> Quasi is the name of the class
15:24:41 <Cale> But really Q is the only good instance of Quasi
15:24:59 <Cale> I don't think I've ever meaningfully abstracted something over a choice of Quasi monad
15:25:07 <Cale> Basically, just use Q :)
15:25:16 <ntnt> Cale: sure
15:25:29 <Cale> There are non-generalised versions of all the things in that Quasi class which only apply to Q anyway
15:25:37 <ntnt> okay yeah, even in the code, it's 
15:25:38 <ntnt> -} newName :: String -> Q Name newName s = Q (qNewName s)
15:25:43 <Cale> and usually I'd just use those, e.g. reify, reifyInstances, etc.
15:25:46 <ntnt> which uses Q rather than Quasi
15:25:48 <Cale> yeah
15:26:00 <Cale> That class is a little bit silly, since it has only one good instance
15:26:15 <Cale> But I suppose it might be handy if you were to use monad transformers
15:26:25 <Cale> You could write a lifting instance for Quasi
15:26:31 <Cale> But bleh, who does that? :)
15:28:51 <Cale> ntnt: The main things to look over at first are Lit, Pat, Exp, Type, and Dec
15:29:16 <Cale> ntnt: They're the main data types which correspond to literals, patterns, expressions, types and declarations respectively
15:29:39 <Cale> and then if you're constructing something in particular, you can look up the types of whatever arguments you need to provide to fill things in
15:30:39 <Cale> e.g. you'll notice that Exp has a constructor CaseE Exp [Match], so if you look up Match, you'll find a type with the constructor Match Pat Body [Dec]
15:31:14 <Cale> and Body is a type with two constructors, GuardedB (when there are multiple guards for that pattern), and NormalB (when there are not)
15:31:15 <ntnt> okay, now that I have an intuition of Q, I'll lok into Lit / Pat / Exp / Type / Dec
15:31:28 <Cale> and the list of Dec is the where clause for that pattern
15:31:44 <ntnt> This basically corresponds to the Haskell AST right?
15:31:54 <Cale> yeah
15:32:03 <ntnt> so TH is "we're using the Q Monad to build a haskell AST which gets spliced in"
15:32:06 <Cale> yep
15:32:18 <Cale> That's basically all there is to it
15:32:37 <Cale> Obviously lots and lots of details corresponding to every bit of possible syntax
15:32:56 <Cale> and the name generation could be nicer, so sometimes you have to be very careful about that
15:33:53 <EvanR> is the monad just so that you can do IO
15:33:54 <Cale> (newName constructs a name which can't be captured, but which can capture other names... unfortunately, there doesn't appear to be a way to construct names which do neither)
15:34:08 <Cale> EvanR: The monad lets you reify information about things in scope
15:34:23 <Cale> reify :: Name -> Q Info
15:34:27 <Cale> https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info
15:34:49 <EvanR> ok
15:35:15 <Cale> (and also construct fresh names, though unfortunately not fresh enough sometimes)
15:36:09 <Cale> You can do IO, but usually won't.
15:36:30 <Cale> (loading files and generating code from their contents can be nice though)
15:36:33 <ggVGc> so fresh and almost clean?
15:36:55 <EvanR> downloading the latest leapsecond table ;)
15:37:06 <EvanR> time-varying semantics
15:37:06 <Cale> hah
15:37:26 <Cale> Yeah, usually if you care enough to use one of those, you don't want to bake it into the executable
15:37:33 <Cale> but sure :)
15:37:48 <EvanR> make a time level UTCTime
15:37:57 <EvanR> which is the timestamp of time of compilation
15:38:06 <EvanR> s/time level/type level/
15:38:18 <EvanR> so sometimes it will compile ;)
15:38:53 <ggVGc> is EvanR doing something insane again?
15:39:04 <EvanR> never
15:39:42 <hpc> someone should make an FRP interface to tzdata
15:40:09 <EvanR> wait... that kind of makes sense
15:40:33 <hpc> oh does it? whoops :P
15:40:49 <EvanR> the state of congress is a signal
15:41:04 <EvanR> when they change their mind all your data is automatically corrected
15:49:13 <rribeiro> How can I use a equality type xs :~: ys ++ zs in order to rewrite P xs to P (ys ++ zs)?
16:29:51 <ntnt> if I'm storing a bunch of (k,v) pairs where k = 512 bit hash; should I be using Map.Strict, HashMap.Strict, or IntMap ? // I don't need the storage to be 'ordered', I only need kv semantics
16:30:19 <ntnt> so I need a kv container where the keys are 512bit hashes
16:30:23 <ntnt> what is the ideal container to use?
16:30:33 <ntnt> I just need fast (1) insert, and (2) lookup by key
16:30:37 <ntnt> those are the only ops I care about
16:30:41 <ntnt> (and also delete + udpate by key)
16:33:43 <monochrom> I think HashMap.Strict is good.
16:34:45 <ntnt> yeah
16:34:50 <ntnt> but why do I need ot hash the keys again
16:34:54 <ntnt> given that my keys are already hashed
16:35:04 <ntnt> that just amkes it a bit weird and seems to create unnecessary potential collisions
16:35:34 <geekosaur> do you have control over the type of the key? if so then you could define your own Hashable instance whose hash function is id
16:35:38 <monochrom> IntMap's "Int key" is really Int, 64-bit likely, not enough for 512 bits
16:36:16 <ntnt> geekosaur: I have control over the type of both the key and the value
16:41:28 <geekosaur> hm, assuming that Hashable doesn't impose a hash size restriction
16:41:50 <monochrom> it does. Int.
16:42:58 <Cale> ntnt: Start with Map. Also note that Data.Map.Strict and Data.Map.Lazy export the same data structure, just different functions for working with that structure. More often than not, the operations in .Lazy are fine.
16:43:21 <monochrom> just wait 45 years for 512-bit CPUs to become fashionable :)
16:43:36 <ntnt> Cale: why Map instead of HashMap? it seems like in practice, just hashing + chaining is better than avl/rb treess in practice
16:43:52 <Cale> Well, you already have hashed keys, right?
16:43:52 <ntnt> monochrom: why isn't moore's laws giving me twice as many bits per int every 18 months !!!
16:43:58 <ntnt> Cale: yeah, I already do
16:44:06 <ntnt> Cale: it seems like ordering these hashed keys is just wasted computation
16:44:09 <ntnt> (which Map would do)
16:44:20 <Cale> Well, that's what HashMap is going to do internally
16:44:40 <ntnt> I don't believe HashMap uses avl/rb trees internally
16:44:41 <Cale> Well, it's more likely a Patricia trie
16:44:45 <ntnt> I think it's Hashing + chaining
16:45:05 <ntnt> patricia trie? https://www.youtube.com/watch?v=jXAHLqQthKw ? I've never heard of this dat astructure
16:45:25 <monochrom> "hash array mapped tries"
16:45:35 <monochrom> IntMap is Patricia
16:45:48 <shachaf> Also called "radix tree".
16:46:42 <Cale> monochrom: I figured it would just be Patricia on the hashes, but perhaps not.
16:46:42 <ntnt> ah, 'radix tree' I can find wikipedia entry for
16:47:15 <kadoban> Isn't a radix tree another name for a trie? Is that all IntMap is?
16:48:59 <ntnt> last 5 minutes: we have increased number of questions w/o increasing number of answers
16:49:00 <Cale> kadoban: Usually when people say "trie" I would think of something which branches by characters, rather than binary prefixes, but yeah, apart from that, they're the same thing.
16:49:00 <kadoban> Oh it's like an optimized trie. Interesting though … I actually understand what that is then, I thought it was some really bizarre thing, apparently not.
16:49:26 <Welkin> ntnt: vanity metric
16:50:09 <Cale> ntnt: But mostly, use Data.Map because it's simple and it will work, and then worry about whether it's actually a performance bottleneck
16:50:10 <ntnt> is HashMap just a hasing function + IntMap undernearth?
16:50:22 <ntnt> Cale: yeah, I'm way deep in permature optimization land
16:50:27 <monochrom> I don't think it's faster to predict from theory than to benchmark this.
16:50:28 <Cale> ntnt: Apparently not, though that's what I thought originally
16:50:46 <Cale> ntnt: I've had Data.Map beat Data.HashMap
16:50:54 <Cale> ntnt: Hashing is not free
16:50:56 <kadoban> Huh, I thought that's what they were too. Learning all kinds of weird stuff today.
16:51:16 <Cale> Computing a hash can easily be more expensive than doing a handful of order comparisons.
16:51:36 <ntnt> Cale: yeah, it's not the comparison that scares my premature-optimization mind, it's the memory-lookup cost that scares my pemature-optimizain mind
16:51:54 <Cale> Well, you'll be doing a bunch of memory lookups either way
16:52:02 <mgsloan> Yup, particularly true for small maps.  For really small maps, a completely unordered (Vector (key, value)) can also be good
16:52:10 <Cale> The constant factor is a little bit different, because HashMap has a slightly higher branching factor
16:52:26 <ntnt> Cale: for hashing? why? it's just (1) hash, (2) lookup place, (3) if there's collision, load everything up
16:52:27 <Welkin> I did my own comparison of Map vs HashMap
16:52:41 <Cale> ntnt: HashMap is a tree structure based on hashes
16:52:42 <Welkin> the Map performed better
16:52:45 <Welkin> for my small dataset
16:52:47 <mgsloan> If your map fits into a cacheline, flat assoc-list vector is actually pretty good
16:52:58 <Cale> Welkin: I had that result as well. I've also had it go the other way
16:53:21 <Cale> Really the only way to know which will win between Data.Map and Data.HashMap is to try both in your application and see
16:53:28 <ntnt> okay, I think the consensus is "ntnt should just write some code, worry about it when it becomes a performance benchmark, and stop complaining until then"
16:53:38 <Welkin> I like to keep everything simple though
16:53:40 <kadoban> ntnt: Sounds like a plan
16:53:44 <Welkin> I don't bother optimizing much
16:53:55 <Welkin> usually, I don't optimize at all
16:54:07 <Cale> ntnt: Most of the time, the answer is "it doesn't matter", in which case you'd prefer to be using Data.Map probably
16:54:21 <kadoban> Optimizing is kind of one of those "well, it's too slow, I guess I have to", for me. Not like … something I do just because.
16:56:29 <Cale> Mostly optimisation is about data structure choice, but the differences between all these Map types are small enough that usually it's not going to make or break something. The fact that you're using a Map at all vs. an association list is the kind of thing that will make something work vs. having broken performance.
17:04:18 <Cale> (btw, something that I really dislike about many introductory texts on data structures is that they count various operations on hashtables as being O(1) when they have no right to be, if asymptotic analysis is to be meaningful at all)
17:05:11 <Cale> In particular, any function whose range has n elements takes at least O(log n) time to compute, because it must examine at least that many bits of its input to distinguish between n cases.
17:20:20 * hackagebot fast-logger 2.4.4 - A fast logging system  https://hackage.haskell.org/package/fast-logger-2.4.4 (KazuYamamoto)
17:20:22 * hackagebot sarsi 0.0.2.0 - A universal quickfix toolkit and his protocol.  https://hackage.haskell.org/package/sarsi-0.0.2.0 (aloiscochard)
17:32:40 <sm_> dang.. an 11G ghc process out of nowhere, darn near killed my mac
17:33:07 <sm> started by ghcid perhaps
17:38:15 <Shou> /reload
18:18:11 <blogle__> is there some way I can do something like the following data GodObj where G :: Tabular t => t -> GodObj
18:18:14 <blogle__> class Tabular a where result :: a -> String
18:18:17 <blogle__> lift :: Tabular t => t -> GodObj
18:18:19 <blogle__> lift = G
18:18:22 <blogle__> pop :: Tabular t => GodObj -> t
18:18:24 <blogle__> pop (G t) = t
18:18:25 <EvanR> question, when is strict bytestring a better idea than lazy bytestring
18:20:39 <ggVGc> EvanR: when you want to make sure you don't get space leaks?
18:21:16 <EvanR> wouldnt lazy bytestrings fix space leaks?
18:21:31 <EvanR> or make them less 
18:21:41 <ggVGc> EvanR: well, if you have a lazy one, don't you run the risk of it building up without being evaluated?
18:22:01 <EvanR> in the case of builder, which only produces lazy
18:22:08 <EvanR> could happen
18:22:10 <EvanR> i guess
18:22:36 <geekosaur> I don't see how that'd be worse than strict though
18:22:39 <EvanR> but doing builder with strict would be really bad
18:22:40 <monochrom> a piece of data in memory, and deliberately purposefully intentionally in memory, is better off a strict bytestring.
18:22:54 <geekosaur> (building up unevaluated chunks that is)
18:23:29 <ggVGc> I dunno, I barely know how to deal with laziness at all
18:23:37 <ggVGc> I'm still doubting the value of it
18:23:43 <EvanR> heh
18:23:58 <EvanR> after trying to write idris code im like... 
18:24:01 <monochrom> a stream of data that should have only one bufferful in memory at all times is better off a lazy bytestring.
18:24:02 <ggVGc> I'm starting to see the tradeoffs more and more, and I'm not sure which side of the fence I'm on
18:24:07 <EvanR> i need my laziness
18:25:13 <monochrom> the two use cases are so mutually exclusive that one should not talk about fixing a space leak by switching.
18:25:46 <monochrom> (if switching fixes the leak, that means you were wrong about your use case to begin with. debug your mind, not your code.)
18:27:11 <jammin_java> hi all... would you say it's possible to get sufficiently good at haskell that you can be as productive as a python for short one-off scripts?
18:27:50 <ggVGc> jammin_java: probably not, since haskell forces you to consider all cases usually, which makes your code really robust. BUt is slower obviously than writing a quick hack that handles your specific case you need right now
18:28:41 <ggVGc> jammin_java: the othe rside of that coin is that almost no script is ever really a "one off script"
18:29:07 <jammin_java> ggVGc how close do you think one could get, 50%?
18:29:20 <jammin_java> i'm trying to force myself through the learning curve
18:29:35 <EvanR> i think a lot of people use haskell as a "scripting language"
18:29:42 <EvanR> if they use haskell at all
18:29:54 <EvanR> they just wont tell you what a scripting language is
18:30:03 <jammin_java> but, esp for data analysis work, I run into stuff where something like pandas has engineered a solution
18:30:09 <thimoteus> haskell + turtle = my favorite shell scripting language
18:30:21 <jammin_java> and in haskell i'm reinventing a crummy wheel from scratch
18:30:23 * hackagebot open-signals 0.1.0.0 - A mechanism similar to checked exceptions that integrates with MTL and  transformer stacks  https://hackage.haskell.org/package/open-signals-0.1.0.0 (darwin226)
18:30:37 <jammin_java> trying to bang together a few csv files with cassava or frames
18:31:06 <ggVGc> jammin_java: it has to do with other things than the language I reckon. THe ecosystem around haskell isn't as good as the one around python for doing a lot of the things people use python for
18:31:07 <jammin_java> or battling with hmatrix's warts and sub-par performance
18:31:50 <jammin_java> ggVGc yeah that's what's bumming me out. the other day i had to do a couple join-like operations
18:31:57 <monochrom> I disbelieve the "more productive in python" assertion. I believe that the truth is "faster prototyping in python". And then people mistake prototypes for products. You are supposed to throw away your prototypes, not ship them.
18:32:05 <ggVGc> jammin_java: but personally, I might be faster writing some things in haskell, because you usually can finish your whole "script" before even running it, and have it work out as you wanted
18:32:14 <jammin_java> and it's not like intractable, but the thing is it would've taken literally seconds with no thought in python or R
18:32:56 <EvanR> i would recommend running each part of your script in isolation until it works, with the help of the repl
18:33:06 <jammin_java> ggVGc i'm finding i'm run into barriers with "data munging" and performant code..
18:33:07 <ggVGc> jammin_java: depending on the operations you need the program to do, it might be a hassle to test run it, and then doing it in something rigid like haskell is really beneficial
18:33:31 <jammin_java> EvanR i'm already 100% repl driven. i've even written my own elisp to make it more practical (doing things like sending lines or blocks into the repl ala python/R)
18:34:20 <EvanR> as far as doing what you want with haskell, if you dont know how yet, it can probably hurt your development speed record
18:34:29 <EvanR> i personally cant do anything in python
18:34:49 <jammin_java> ggVGc i'm on board with testing and types are usually nice, except when the datasets get larger more complex and it becomes impractical or wasteful to hard code like 80 fields..
18:35:15 <EvanR> you might be using too much type safety, or not enough generator technology
18:35:28 <EvanR> theres an alternative to just [[String]] though
18:35:37 <jammin_java> EvanR i'm willing to take a big hit and I have, but ...
18:35:50 <jammin_java> EvanR I've tried to exploit generics & extensions
18:36:11 <jammin_java> i don't know all the tricks yet of course
18:36:13 <monochrom> you can use Haskell for scripting. but you have to learn Haskell.
18:36:26 <EvanR> more like RelSet YourDynamicType
18:36:59 <jammin_java> does anyone work with dynamic-y data? stuff like juggling a dozen CSVs around?
18:37:00 <ggVGc> EvanR: [[[CHar]]]!!!
18:37:05 <EvanR> or record of your dynamically typed fields
18:37:31 <EvanR> i just did a processor for csv streaming data, but i used types
18:37:38 <jammin_java> i am doing a lot of cassava, aeson (Value is a godsend), and some frames
18:37:39 <EvanR> invalid rows did not make it through
18:38:02 <ggVGc> I think maybe something like OCaml of F# would be more suitable for me, for the type of stuff I'd raditionally use python for
18:38:05 <jammin_java> but even those libraries have quirky corner cases that eat up hours at a time
18:38:11 <ggVGc> haskell is maybe a bit too rigid for me
18:38:15 <ggVGc> for those use cases
18:38:31 <EvanR> i can use ruby to process csv data pretty well, but i dont like it
18:38:32 <jammin_java> like the other day, i was perplexed that cassava's decodeOptions are not the same as the encodeOptions
18:38:48 <jammin_java> and quoting options are in encodeOptions only. wtf?
18:39:04 <EvanR> heh.. sounds like its already more advanced than csv processing in ruby
18:39:14 <EvanR> it has options ;)
18:39:48 <monochrom> that's a bit strange
18:39:49 <EvanR> except i dont want options i just want the dang data
18:39:52 <jammin_java> then I needed to do a join-like operation. even with Data.Vector it was slow .. at least compared to the battle-tested C++-optimized solutions in python and R
18:40:28 <EvanR> doing an N^2 loop through two vectors doesnt surprise me as slower than "something in c++"
18:40:31 <jammin_java> monochrom yeah, i don't get why cassava is written like htat. other things about it pretty well thought out
18:40:53 <ggVGc> what bothers me with haskell(relating to our laziness talk before) is that all of a sudden you might write a small unsuspicious function, and all of a sudden you messed up your performance by a magnitude
18:41:04 <jammin_java> EvanR yeah, well in retrospect i probably should have done it with some Data.Map key
18:41:24 <jammin_java> but the thing is, in python or R, it would have been literally 2 seconds of typing and working
18:41:41 <EvanR> yeah your data structure in python by default is not a vector
18:41:51 <EvanR> or a list
18:41:57 <EvanR> despite whatever they call it
18:41:59 <Cale> jammin_java: You absolutely can get sufficiently good at Haskell that it's better than Python for short one-off scripts.
18:42:07 <jammin_java> EvanR isn't the pandas dataframe basically a Vector of (dynamic) records
18:42:08 <ggVGc> is EvanR a vector or a map?
18:42:17 <EvanR> i dont know pandas
18:42:35 <jammin_java> data munging in python and r are built around data frames
18:42:39 <blogle__> pandas is essentially a dict of numpy arrays
18:42:56 <orion> Cale: ha, can Haskell replace this one-off script?: https://github.com/centromere/cacophony/blob/test-vectors/tools/convert_vectors.py
18:43:42 <jammin_java> orion is this a trick question? seems pretty doable
18:43:52 <Cale> orion: Well, I don't know whether there's a precise equivalent of jinja2 for Haskell, but you could use Heist pretty simply.
18:44:03 <orion> In 29 lines?
18:44:30 <Cale> Sure, I don't see why it would take much longer than that to load up a Heist template and fill in some splices.
18:44:31 <jammin_java> orion as far as python-like workflow so far it's the data merges that are killing me. filtering i think is not so bad
18:44:59 <Cale> orion: Unless there's something about the behaviour of this script that I don't understand
18:45:11 <jammin_java> that and when i need something computationally intensive and python or R have something that's hand-coded C++
18:45:38 <jammin_java> and in haskell i'm fumbling around with laziness + hoping learning repa will pay off..
18:46:48 <blogle__> jammin_java: sounds like you are happy with your existing workflow, any reason you want to use haskell?
18:47:02 <jammin_java> or putzing with the FFI and then ending up writing more C than haskell
18:47:04 <ggVGc> jammin_java: I think, maybe, for really quick small things if you want something fast to write, fairly fast to run(faster than python) and quick to get going, Go might be it
18:47:04 <Cale> jammin_java: Yeah, in cases where nobody's written any equivalent to the supporting libraries you'd like to use, there's definitely going to be more work to do, though that's not really a language-dependent thing.
18:47:24 <Cale> I mean, Go or any other language would have the exact same problem.
18:47:36 <Cale> If there exists a C or Fortran solution, you might just FFI to it.
18:47:48 <ggVGc> Cale: yeah, but Go has a much more active eco-system for real-world uses
18:47:52 <ggVGc> sicne lots more companies use it
18:47:53 <Cale> ggVGc: oh?
18:47:53 <jammin_java> biogie__ i'm not happy with python & r. they just happen to be efficient at this stuff, at least in the short term. i think haskell would be better if it had the ecosystem.
18:48:24 <jammin_java> it doesn't have the ecosystem (data analytics, math stuff, simulations), but i'm giving it a hard try to see if i can make it work somehow
18:48:50 <ggVGc> Cale: it also lets you be a bit more slack, which is maybe what you want when writing small tools and scripts
18:48:58 <blogle__> I agree, I just dont think haskell is targetting the data analytics ecosystem.. best I have seen is embedding R in haskell
18:48:59 <ggVGc> and has a an almost nonexistent learning curve
18:49:03 <Cale> ggVGc: somehow I'm not sure that's true (about the number of libraries)
18:49:09 <jammin_java> ultimately i'm dissatisfied with python and r though
18:49:31 <blogle__> you could try julia
18:49:43 <jammin_java> biogie__ the thought has crossed my mind
18:49:53 <ggVGc> yeah, julia seems the choice for this
18:50:06 <jammin_java> biogie__ however, even though it's better than python, my guess is it's not better enough to survive
18:50:21 <jammin_java> survive may be a bit harsh, it's not enough of an improvement to thrive
18:50:57 <jammin_java> it also has the same dynamic typing crap legacy from matlab/python, right?
18:50:57 <blogle__> I would like to see compile time errors, but otherwise its pretty solid.
18:50:59 <ggVGc> Cale: not number of libraries, but more battle tested in real-world use ones
18:51:07 <ggVGc> but yeah, maybe I'm wron
18:51:28 <jammin_java> at this point i think if i was going to give up and go with something more practical i'd just do python
18:51:36 <Cale> Yeah, I somehow doubt that the number of production users of go is even as large as the number of production users of Haskell, but I haven't seen stats.
18:51:53 <blogle__> I havent met a single user of go
18:52:14 <triliyn> I use Go at work
18:52:55 <blogle__> And an immediate counter example
18:53:27 <ggVGc> Cale: this list has a lot of the stuff I'd expect from an ecosystem replacing python, https://github.com/avelino/awesome-go
18:53:36 <jammin_java> go is always described as the most whitebread programming language
18:53:42 <jammin_java> for some reason
18:53:55 <blogle__> jammin_java maybe you should just write Fortran ;)
18:54:05 <jammin_java> i would be surprised, i know of 0 data scientists using go
18:54:19 <EvanR> ggVGc: re go or python being good for having libraries or being "in-use" ... imagine if PHP had lots of libraries and was very popular, i still would not want to use it ;)
18:54:43 <jammin_java> blogle__ that's in the wrong direction. at that point i might just go back to c++. at least c++14 is kinda cool if a bit disappointing
18:54:44 <EvanR> thats kind of the worst way to improve a language that sucks
18:55:01 <ggVGc> yeah, I dunno. I just think if you want the fast development speed of python, but want static typing and faster runtime speed, Go seems to fit the bill
18:55:25 <ggVGc> and the go compiler is essentially instant
18:55:42 * EvanR measures development speed of haskell and python by trying to develop something in them
18:55:45 <Cale> jammin_java: because it is -- you could tell someone who didn't know better that it was created in 1968 and if they didn't look it up, they'd never know better.
18:56:12 <triliyn> I've found the lack of parametric polymorphism REALLY annoying in go
18:56:30 <Cale> It basically ignores the last half-century of programming language research
18:56:31 <ggVGc> triliyn: yeah, but do you need toat for writing a backup sync script quickly?
18:56:32 <ggVGc> or similar
18:56:37 <ggVGc> that*
18:56:44 <triliyn> maybe not, I don't do a lot of scripting
18:56:57 <jammin_java> yeah. if i'm going to retreat from haskell with my tail between my legs, it's not going to be to learn an uninteresting new language.
18:57:14 <ggVGc> fair
18:57:25 <ggVGc> I thought it was a purely practical question
18:57:42 <jammin_java> i might try julia or rust. but practically it probably makes more sense to go back to the python / R / C++ combo
18:57:52 <ggVGc> rust for quick scripts?
18:57:53 <ggVGc> seems insane
18:58:01 <jammin_java> probably not rust
18:58:15 <jammin_java> (it has a repl though supposedly doesn't it?)
18:58:41 <ggVGc> jammin_java: I just don't know if dealing with lifetime declarations is what you want to be doing wen you want to crunch some numbers quickly
18:58:55 <jammin_java> i'd still prefer to crack puzzle with haskell
18:59:52 <jammin_java> but i have my doubts. just pandas & dplyr alone are a deep toolset with years of investment to replace
19:00:23 <EvanR> julia is pretty cool
19:00:35 <EvanR> i wish it had return type annotations
19:00:45 <jammin_java> what's cool about it? it seems like a fast, slightly more functional python to me
19:01:05 <EvanR> first, it has a type system
19:01:17 <EvanR> second you can ask it for the machine code of a function
19:01:25 <EvanR> thats about it ;)
19:01:38 <EvanR> (in the repl that is)
19:01:41 <jammin_java> how's the type system? i thought it was pretty much DT?
19:01:59 <EvanR> well theres two kinds of dynamically typed systems
19:02:08 <ggVGc> wonder if I should try doing some music generation experiments in julia
19:02:09 <EvanR> (at least)
19:02:09 <ggVGc> could be fun
19:02:34 <jammin_java> EvanR what do you mean?
19:03:12 <EvanR> julia has specializations based on the combination of argument classes (multimethods)
19:03:34 <EvanR> if the compiler knows what the classes are, it doesnt do a runtime check for dispatch
19:04:03 <ggVGc> EvanR: what have you written in julia?
19:04:10 <EvanR> its basically dynamically typed only as a fallback
19:04:34 <EvanR> instead of it being unavoidable overhead of a system you know wont fail after fixing all the bugs
19:04:36 <jammin_java> that gets you speed, but no type safety right?
19:05:14 <EvanR> if theres no such method for a given class it will error
19:05:55 <jammin_java> runtime right?
19:06:06 * EvanR boots up julia
19:06:23 <EvanR> ive only ever wrote the program through the repl
19:07:45 <Cale> Actually, I bet you could do a pretty decent typechecked version of this dataframe stuff using the same sort of scheme that DMap uses.
19:08:08 <jammin_java> Cale DMap?
19:08:10 <Cale> (maybe you could even get by just using DMap directly, but you'd probably want a few extra guarantees)
19:08:23 <Cale> http://hackage.haskell.org/package/dependent-map-0.2.1.0/docs/Data-Dependent-Map.html
19:09:04 <jammin_java> Cale i haven't caught onto the dependent typing bandwagon yet...
19:09:18 <Cale> This isn't proper dependent typing even
19:10:12 <Cale> It just gives you the equivalent of a Map (i.e. a (key,value) store), except your keys have a type parameter, and the values do too, and the parameters always match
19:10:27 <EvanR> jammin_java: well at least you can put type annotations, which does more than just do a runtime check and throw an error
19:10:31 <Cale> The examples in the documentation are actually a little out of date -- it used to be that the type parameter of your keys was the value type
19:10:42 <jammin_java> i've tried to get into acowley's Frames but i don't find it that enjoyable to use
19:11:00 <EvanR> you end up with a function that is either "generic" or specialized to the argument types
19:11:01 <Cale> But now that's the behaviour when you use Identity as the type-function giving the value types
19:12:56 <ggVGc> it always seems strange to me to do scientific computing in dynamic languages
19:13:15 <Cale> jammin_java: But basically, the reason why you want dependent typing here is that you want the type of an interior cell in the table to depend on the type of its column, which is itself part of the data.
19:13:18 <EvanR> yeah, julia claims to be competing with fortran
19:13:20 <ggVGc> wouldn't scientific studies want to be absolutely sure that their implementations of experiments/tests are correct?
19:13:28 <jammin_java> ggVGc i'm still convinced haskell would be a killer scientific computing language
19:13:34 <EvanR> ggVGc: with doubles? ;)
19:13:41 <Cale> jammin_java: Or to put it another way, the type of a cell depends on the value of its column header
19:14:03 <jammin_java> ggVGc oh god the state of software engineering in scientific computing is REALLY bad. this is part of the so-called replicability crisis
19:14:38 <EvanR> "science" has the same sort of "i need to get this done or else" constraints as not-science
19:15:02 <ggVGc> EvanR: does it really? Isn't science more concerned with correctness of process than most disciplines?
19:15:02 <EvanR> with the slight benefit of being done by scientists
19:15:16 <jammin_java> cale i always got the vague impression that dependent typing was some in-between zone between dynamic typing and vanilla static typing
19:15:21 <jammin_java> ggVGc it is not
19:15:22 <EvanR> seems like an idealization
19:15:38 <EvanR> "studies show..." is a great way to open a huge can of questions
19:15:38 <Cale> jammin_java: Dependent typing means that you can have types which are parameterised on values
19:15:40 <jxv> Are there any scientific libraries which are dependent on linear?
19:15:44 <jammin_java> ggVGc I distinguish science and the scientific method from the shit institutions that claim to practice it
19:15:52 <ggVGc> jammin_java: my grandfather was a chemist and physicist. He was very adamant about correct process during chemistry work when I hung out with him
19:15:58 <ggVGc> and talked about it a lot
19:15:58 <Cale> jammin_java: In Haskell, we have types which are parameterised on types, e.g. Maybe
19:16:30 <EvanR> ggVGc: funding is acquired and comes with limits and requirements in the same way
19:16:39 <ggVGc> like, it's actually important that a vial that you store a certain chemical in, only ever has that chemical in it
19:16:40 <jammin_java> Cale i kind of get that .. .how is it different than a sum type?
19:17:06 <EvanR> specifically numerical analysis isnt always very careful
19:17:07 <jammin_java> like a Num or String
19:17:10 <Cale> jammin_java: Well, (,) (the type constructor for pairs) is also parameterised on the types of its components
19:17:22 <EvanR> if its close enough to what people expect it may not be questioned
19:17:22 <Cale> jammin_java: and IO is parameterised on the type of the result of the IO actions
19:17:23 <ggVGc> EvanR: maybe I'd be a shit scientis
19:17:42 <Cale> jammin_java: It's not about Maybe being a sum, it's the fact that you have Maybe Integer, and Maybe String, and Maybe Double, etc.
19:17:57 <jammin_java> ggVGc the institutions of science have changed in the last 10 years. in the name of high-throughput measurements, it's degenerated into this brainless correlation-finding p-value machine.
19:18:18 <ggVGc> sounds crap
19:18:20 <ggVGc> and bad for all of us
19:18:41 <EvanR> time to buy stock in a company that does it the way you like ;)
19:19:05 <jammin_java> ggVGc it is. i'm in industry now and more often than not i have to beat up our academic collaborators because they aren't up to our scientific standards (which aren't even that high).
19:19:06 <ggVGc> jammin_java: `Just` and `Nothing` form the sum type of Maybe. But tye parameter decides what TYPE of `Just` you get.
19:19:38 <jammin_java> ggVGc does that mean Maybe is a dependent type?
19:19:48 <jammin_java> i thought dependent types were more esoteric than that..
19:19:53 <ggVGc> no not at all
19:19:59 <EvanR> Maybe is a type that depends on a type
19:20:00 <ggVGc> I was just trying to fill in what Cale was talking about
19:20:03 <Cale> jammin_java: Well, it's a type which depends on the choice of a type, which we usually don't use the term "dependent type" for
19:20:05 <EvanR> dependent types depends on a value
19:20:21 <Cale> jammin_java: "dependent type" is usually reserved for types which depend on the choice of a *value*
19:20:27 <jammin_java> then what's all the talk of compiler support? Maybe has been around forever..
19:20:34 <Cale> ...
19:20:42 <EvanR> i wish Maybe has been around forever...
19:20:56 <jammin_java> Cale oh ok so like if x < 10 then it's some type, if it's >= 10 then it's another?
19:20:57 <EvanR> in not haskell
19:21:01 <EvanR> or ML
19:21:07 <Cale> jammin_java: Sure
19:21:15 <LordBrain> its been around for a long time now tho
19:21:20 <Cale> jammin_java: Or a simpler example, perhaps just lists of length n
19:21:40 <jammin_java> evanr what do you mean maybe hasn't been around forever?
19:21:51 <ggVGc> jammin_java: I was trying to explain the concept of a type parameter, which I thought you were talking about. I.e that a parameterised type like Maybe isn't "complete" until it has had it's parameter filled with something, so it "depends" on another type, in the same way that a functions result depends on the value you pass to it. But "dependent types" refer to a type depending on a value, which is more com
19:21:57 <ggVGc> plicated
19:21:57 <EvanR> mainstream languages only recently started using maybe-like things
19:21:59 <ggVGc> also, I barely understand anything about dependent types
19:22:03 <LordBrain> its been around as long as i have been in the haskell world
19:22:05 <EvanR> like swifts "question mark types"
19:22:17 <Cale> jammin_java: Or, once you have dependent types, you can even do some really fun things, you can have a type Id such that for any type A, and any x and y of type A, there Id A x y  
19:22:19 <Cale> oops
19:22:25 <Cale> jammin_java: Or, once you have dependent types, you can even do some really fun things, you can have a type Id such that for any type A, and any x and y of type A, there's a type Id A x y
19:22:45 <Cale> and it has one data constructor:  Refl :: Id A x x
19:22:59 <Cale> and so a value of type Id A x y is like a proof that x and y are equal
19:23:11 <Cale> and this lets you encode proofs of properties about your programs in their types
19:23:25 <LordBrain> i don't think he was referring to non-haskell when he said "forever" there.
19:23:50 <EvanR> oh compiler support in ghc
19:23:52 <EvanR> for dependent types
19:23:53 <LordBrain> maybe seems pretty old in the haskell-verse
19:24:10 <jammin_java> i'm game and all... but being a working scientist, i just need something to replace my stupid data frame workflows in data science-y languages
19:24:43 <EvanR> you need to read your csv file into an OLAP cube ;)
19:24:54 <EvanR> two vectors doensnt sound like it will cut it
19:25:22 <Cale> jammin_java: I think Haskell's type system might stretch just close enough to being dependently typed that we could build you something reasonable that would let you manipulate tables whose columns have varying types.
19:25:24 <jammin_java> i like the type system and all, but type tricks just aren't my biggest pain point at the moment
19:25:29 <ggVGc> jammin_java: so, what I think is that if you're doing a lot of "short scripts" within the same domain and solving similar problems, haskell will start paying off becuase you'll develop a strong and easily reusable little library of functions for yourself
19:25:44 <ggVGc> jammin_java: but the startup cost is a bit high maybe
19:25:49 <Cale> jammin_java: If you don't even need the columns to have varying types, then the whole thing is way easier
19:26:14 <EvanR> yes jammin_java has already said that Aeson Value is working
19:26:40 <Cale> ggVGc: I suspect there are a bunch of data scientists who have such little libraries in Haskell, but I don't think they get to the point of feeling like sharing them.
19:26:49 <EvanR> you just need a nice way to wrangle a data analysis structure of some sort
19:26:49 <ggVGc> right
19:26:56 <jammin_java> ggVGc well that's what i had hoped, i've been making a concerted effort for about 6 months now. read most of chris's book
19:27:20 <ggVGc> jammin_java: code you write in haskell usually ends up much more reusable, often by accident, than in other languages
19:27:29 <ggVGc> which is good if you're doing a lot of small problems within a similar domain
19:27:41 <jammin_java> yeah i like it
19:27:54 <dwynwen_ddlleyw> Now I am curious as to what advantages Haskell has over Ada and vice versa 
19:28:03 <jammin_java> but i'm still finding when i try to force myself to do some productive work, it's like zeno's paradox of productivity
19:28:06 <ggVGc> jammin_java: but writing that code in the first place maybe takes 3-4 times as long, so if you don't reuse it more than 2 times it might not have been worth it, etc.
19:28:48 <ggVGc> jammin_java: I find though, that often haskell's type system and the compiler teaches me things about my problem before I've even finished writing the code
19:28:52 <ggVGc> which is real nice
19:28:57 <jammin_java> i've spent a decent amount of time rigging together my own interactive plotting system with spock+plotly
19:29:08 <Cale> dwynwen_ddlleyw: first class functions is a pretty big start
19:29:25 <dwynwen_ddlleyw> But is that an advantage 
19:29:26 <EvanR> i used to think that problems were either "obviously functional" and functional programming would be a good idea and easy, and otherwise it would not be a good fit. but now ....
19:29:43 <Cale> dwynwen_ddlleyw: That's an advantage that Haskell has over Ada, yeah.
19:29:47 <jammin_java> i wrote my own C FFI into GSL because hmatrix wasn't cutting it. but i'm still not there where i can get work done in a reasonable amount of time yet
19:29:48 <ggVGc> avn: now you're brainwashed and inthe deep end?
19:29:52 <ggVGc> EvanR: ^
19:30:02 <dwynwen_ddlleyw> I don't really see how that is advantageous really 
19:30:03 <sm> jammin_java: to reduce that pain, maybe identify your zone of fluency, and separate getting-stuff-done sessions (where you must stay within that) from growing-the-zone sessions
19:30:04 <Cale> dwynwen_ddlleyw: One that Ada has over Haskell I suppose would be that Ada has nice range types.
19:30:17 <dwynwen_ddlleyw> Since you can just call functions in Ada like you can in haskell
19:30:28 <ggVGc> Cale: aren't the range types in Ada runtime checked though?
19:30:31 <ggVGc> so not that sueful in practice
19:30:33 <ggVGc> ?
19:30:47 <Cale> dwynwen_ddlleyw: Ah, okay, so often you end up with two functions whose implementations look almost identical, except that there's some piece in the middle which is different
19:30:49 <jammin_java> sm maybe a good idea, i'm too optimistic
19:31:03 <EvanR> ggVGc: we just dont have the declarative language specialized to solve every problem yet, and we wont get there without getting good at making new ones (that dont suck)
19:31:07 <dwynwen_ddlleyw> Okay, I see now
19:31:30 <jammin_java> so i end up forcing myself to power through a project, only to fall back on python or r right before it's due
19:31:33 <EvanR> and making new languages in not haskell has been shit honestly
19:31:45 <jammin_java> luckily i'm super productive in those. unluckily i hate working in them
19:31:48 <Cale> dwynwen_ddlleyw: e.g. you're iterating over a bunch of items, and applying some function to each of them, and combining the results somehow, but the function you're applying, and the thing you're doing to combine the items is different. It would be nice to take those pieces as parameters to your function.
19:32:08 <Cale> dwynwen_ddlleyw: (and not have to write the same code twice, and fix the same bugs twice)
19:32:36 <LordBrain> i just learned of DMap now
19:32:39 <LordBrain> thanks Cale
19:32:42 <ggVGc> I find it pretty useful to create a list of functions, and map that list over a value to get a list of new values for each of those different functions
19:32:46 <Cale> LordBrain: :)
19:32:54 <Cale> LordBrain: don't miss out on DSum :)
19:33:03 <jammin_java> dumb semi-related question. has anyone tried extending aeson's Value type into a standalone way to do dynamic typing?
19:33:13 <Cale> jammin_java: in what way?
19:33:16 <EvanR> whats wrong with it as it is?
19:33:16 <ggVGc> eh, fold I meant
19:33:17 <ggVGc> not map
19:33:28 <Cale> jammin_java: It is effectively dynamic typing, restricted to JSON types
19:33:46 <Cale> jammin_java: Or you mean extend it to most Haskell types?
19:33:52 <geekosaur> I don't see what that would do that Data.Typeable doesn't, except add additional unnecessary restrictions
19:33:57 <jammin_java> Cale exactly ... but people use dynamic typing in contexts outside JSON
19:34:16 <geekosaur> and tbh I rarely have any reason to use Data.Typeable
19:34:17 <EvanR> Data.Dynamic (which uses Typeable) is kind of like the fixed point of that
19:34:21 <geekosaur> yeh
19:34:22 <Cale> jammin_java: We do have that -- there's a system for runtime type information in Data.Typeable, and Data.Dynamic is a trivial library which uses Data.Typeable to add dynamic types to Haskell
19:34:42 <ggVGc> ^which is pretty cool to read about
19:35:07 <Cale> Usually you don't actually want Data.Dynamic, and would prefer to use Typeable directly.
19:36:02 <jammin_java> Cale oh good to know
19:36:05 <jammin_java> i haven't tried those
19:36:05 <Cale> (because you don't really want something of *any* type, you want something of a restricted space of types which perhaps support certain operations, and you want the ability to recover which type of thing it was)
19:36:23 <LordBrain> ggVGc: map ($ value) [f1,f2,f3,f4]
19:36:26 <LordBrain> liek that?
19:36:26 <EvanR> Dynamic will let you put almost any value in a container with any other value in a not very nice way
19:36:38 <LordBrain> they'd all have to return the same type
19:36:42 <jammin_java> g2g for a bit
19:36:43 <EvanR> but you probably have a well defined universe of value dynamic types in mind already
19:36:50 <ggVGc> LordBrain: yes, but they can be different functions
19:37:01 <ggVGc> LordBrain: it was just an example of why first class functions are nice
19:37:30 <LordBrain> oh
19:37:39 <ggVGc> LordBrain: can for example be used for implementing a simple evaluator for a DSL
19:38:17 <ggVGc> LordBrain: also, I do it often in javascript, where they actually do not have to return the same tupe
19:38:29 <EvanR> ggVGc: or do they
19:38:31 <ggVGc> which is useful in other ways
19:38:39 <ggVGc> EvanR: they return the dynamic type!
19:38:45 <EvanR> javascripts 1 type
19:40:02 <LordBrain> if you make the type a sum type, DSum Tag, you could put any of a set of types really... but you'd have to then peel the tags off with a set of specialized functions like toString, toInt... and so on
19:40:32 <zRecursive> It seems GHC is still slow to build a bit bigger project especially in linking phase, isnot it ?
19:40:44 <EvanR> does ghc still use gnu linker?
19:40:51 <LordBrain> unless there is a nicer already packaged way to do that peeling.. 
19:41:33 <LordBrain> you know, that dependent-map package should add more examples to its haddock
19:41:44 <zRecursive> EvanR: it is gnu linker here
19:41:51 <EvanR> that explains it ;)
19:42:12 <LordBrain> if it did, it could become the go to for heterogeneous lists
19:42:20 <EvanR> theres probably a helluva lot of things to link
19:42:41 <EvanR> and that linker was made for C
19:43:39 <zRecursive> It is msys2+mingw, so i cannot use other linker instead of gnu linker ?
19:44:42 <ggVGc> has anyone here built an iOS app with haskell?
19:44:50 <ggVGc> suposedly GHC can cross compile?
19:45:09 <EvanR> supposedly it can
19:45:25 <ggVGc> I dislike supposedly..
19:45:39 <ggVGc> but I would like to put my sequencer on the iPad
19:46:30 <dwynwen_ddlleyw> Why not try it
19:47:04 <ggVGc> atm I have no mac at hand
19:47:39 <ggVGc> judging from this it seems quite doable, https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS
19:48:21 <Cale> ggVGc: I have, a long time ago
19:49:03 <ggVGc> Cale: how long?
19:49:14 <joe42> what's a good way to wrap my head around abandoning loops?  I don't know how to deal with arrays without thinking about loops.
19:49:30 <Cale> ggVGc: and yeah, that's where the cross compilation support in GHC came from, the company I was working for wanted to write an action RPG for iPhones in Haskell. Stephen Blackheath (blackh on IRC) added the support for us.
19:50:00 <ggVGc> sweet
19:50:05 <ggVGc> Cale: so you reckon it should be all good?
19:50:26 <Cale> ggVGc: well, it was 2012 when I last looked at it
19:50:39 <Cale> But yeah, give it a shot :)
19:51:14 <ggVGc> I'd hate to have to rewrite this to get it to run on iOS :(
19:52:01 <c_wraith> joe42, you're not abandoning loops. you're just working at a higher level. (most of the time). the loops are still there. and probably cleverly optimized. 
19:52:58 <Cale> joe42: Think in terms of collective operations on data, which are higher order functions. You can still write the loops directly with recursion.
19:53:03 <c_wraith> joe42, the more you can tell the compiler about what you're actually doing, the better it can optimize it. higher-order functions are an example of that at the library level. 
19:53:26 <joe42> I was under the impression haskell has no for loops, no while loops, no variables  (( if following functional rules, that is )) .......   Was that intro incorrect?
19:53:28 <c_wraith> joe42, for loops might as well be assembly, for all the details you have to go into. 
19:53:49 <EvanR> forM_ [0..n-1] $ \i -> do -- ;)
19:53:50 <Cale> joe42: It does have stuff like forM which is effectively a foreach loop
19:54:01 <ggVGc> Cale: worst case it's possible to run a webview running JS from GHCJS and putting a native view on top of it, and interoping between them....
19:54:04 <ggVGc> hah
19:54:05 <Cale> joe42: It's a library function rather than built in
19:54:07 * ggVGc cries
19:54:13 <zRecursive> @src forM_
19:54:13 <lambdabot> forM_ = flip mapM_
19:54:28 <EvanR> a lot of things haskell "doesnt have" are just libraries instead of built in
19:54:29 <c_wraith> joe42, a language without loops can't be Turing complete. :) haskell has loops. they're just not usually super low-level. 
19:54:50 <ggVGc> le't be honest, haskell does NOT have for loops on the syntax level
19:54:51 <geekosaur> also, it does not have explicitly written imperative loops
19:55:11 <geekosaur> if you've worked with ruby, you might think of forM and friends as #each
19:55:17 <EvanR> hmmmmm ... syntax level loops, what level are "loops" on anyway ;)
19:55:40 <Cale> ggVGc: Oh, there are also container applications which will basically give you a web application in a box.
19:55:56 <ggVGc> EvanR: a loop on the syntax level is not necessarily a loop at runtime.. and a non-loop syntax construct might be a loop at runtime..
19:55:58 <Cale> ggVGc: If it's already a web application, that's probably convenient.
19:56:16 <ggVGc> Cale: it is not, but I was suggesting it as a roundabout way of executing haskell code
19:56:19 <EvanR> ggVGc: im questioning whether loops are a thing at any time anywhere, except in programmer lore
19:56:22 <ggVGc> since the webview is a runtime for JS
19:56:36 <ggVGc> EvanR: it's turtles all the way donw
19:56:43 <joe42> Perhaps I should ask a different way. While reading the docs, I was looking for loops to understand haskell arrays a little better, but realize I was going about it wrong.....  What SHOULD one use to pull items from an array?
19:56:47 <dolio> Loops are an admission that recursion doesn't work properly in your language.
19:57:00 <c_wraith> joe42, want to know a secret? haskell lists are more useful as reified loops than data structures. :) 
19:57:09 <ggVGc> joe42: depends on what you mean by "pull". DO you want to filter out certain values?
19:57:26 <EvanR> yes, what do you want to do with the items in the array is the question
19:57:51 <dolio> Which is why Haskell doesn't have built-in loop constructs. Recursion works correctly.
19:57:53 <joe42> Yes, filter out certain values by name.  Example; pull one item from and xml doc or json doc.
19:57:58 <EvanR> "loop over them" isnt really a complete task
19:58:21 <LordBrain> you could toList and then filter...
19:58:25 <c_wraith> dolio, but there's fix! the goto of recursion! :) 
19:58:45 <geekosaur> I would have said Cont for that :p
19:58:51 <EvanR> joe42: so you want a find operation
19:58:54 <LordBrain> if that is what you mean by "pull" 
19:58:57 <EvanR> ex. 
19:58:58 <EvanR> :t find
19:58:59 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
19:59:14 <EvanR> find :: (a -> Bool) -> [a] -> Maybe a
19:59:45 <EvanR> find ((== "frank") . name) myRecords
19:59:52 <ggVGc> man, Applicative.Const is so weird to me
19:59:54 <c_wraith> I suppose I might look at fix more as comefrom than goto
20:00:06 <c_wraith> ggVGc, but it's really useful! 
20:00:18 <dolio> I don't think it's as bizarre as comefrom.
20:00:19 <ggVGc> c_wraith: I don't really kbow ow I would use it
20:00:23 <ggVGc> but I know applicative needs it
20:00:25 <ggVGc> somehow
20:00:48 <c_wraith> ggVGc, nah.. Applicative doesn't need it. 
20:00:58 <EvanR> have you ever found a language feature which you thought "this has to exist for a reason, let me find a way to use it" and regreted it?
20:01:01 <joe42> Is this a good source to get familiar with haskell functions and what they do?  I feel like I need to unlearn or relearn how to code stuff.
20:01:08 <joe42> Sorry, forgot link: https://www.haskell.org/hoogle/
20:01:21 <c_wraith> ggVGc, it's just a type that forms a particularly useful instance of Applicative
20:01:22 <ggVGc> joe42: that is exactly what you need to do!
20:01:23 <EvanR> hoogle is kind of incomplete
20:01:31 <EvanR> but can work
20:01:43 <EvanR> see also hayoo
20:01:57 <zRecursive> @hoogle concurrent
20:01:58 <lambdabot> package concurrent-barrier
20:01:58 <lambdabot> package concurrent-dns-cache
20:01:58 <lambdabot> package concurrent-extra
20:02:02 <ggVGc> c_wraith: why is it particularly useful
20:02:03 <ggVGc> ?
20:02:03 <LordBrain> its worthwhile to install hoogle locally and build its database to be huge
20:02:10 <ggVGc> c_wraith: does it relate to lenses?
20:02:10 <c_wraith> ggVGc, for instance, lens needs the Const applicative for get operations. 
20:02:12 <joe42> Okay, thanks all.  Sorry for any silly questions. 
20:02:15 <ggVGc> aha!
20:02:29 <ggVGc> that's where I first came in contact with it
20:02:32 <c_wraith> joe42, not silly at all! ask all you like whenever you like. 
20:02:34 <ggVGc> but I didn't completely follow the reasoning
20:02:37 <ggVGc> I have to study it again
20:02:39 <LordBrain> i have  40M .hoo file
20:02:53 <EvanR> joe42: you can probably use premade functions like find and map and filter in other languages too instead of doing loops
20:03:37 <ggVGc> joe42: everyone is essentially a newborn baby who can't walk or talk in the beginning of haskell. and no one in here judges so any question is all good
20:03:59 <c_wraith> joe42, haskell is really actually different from nearly everything else. it takes most everyone a while to catch on. took me months of serious study. :) 
20:04:06 <joe42> Is the map basically similar to map/reduce type functions in couchdb/mongodb?  Or is the name only similar?
20:04:17 <c_wraith> it's the same idea. 
20:04:20 <EvanR> map is like map, fold is like reduce
20:04:23 <ggVGc> c_wraith: do you have any good writeup dealing with Lens and Const?
20:04:28 <ggVGc> I'm really curious about COnst now
20:04:32 <Cale> > map (*2) [1,2,3,4,5]
20:04:34 <lambdabot>  [2,4,6,8,10]
20:04:43 <LordBrain> technically, i think it is quite similar to clean and miranda.. .but usually if you are workign with one of those.. you already did haskell i expect...
20:04:47 <joe42> Ok. It's starting to make sense..a little
20:04:47 <c_wraith> ggVGc, hmm. have you seen SPJ's lens video? 
20:04:50 <Cale> > map reverse ["here", "are", "some", "words"]
20:04:51 <lambdabot>  ["ereh","era","emos","sdrow"]
20:05:00 <ggVGc> c_wraith: I think so, a long time ago. Should watch it again
20:05:06 <dwynwen_ddlleyw> That's like a huge barrier to me, I can't really set aside months of time to study 
20:05:18 <ggVGc> dwynwen_ddlleyw: spread the months out over a year
20:05:29 <LordBrain> there's also a language called Curry, which is pretty much a haskell dialect
20:05:29 <dwynwen_ddlleyw> But haskell seems cool all the same
20:05:31 <c_wraith> ggVGc, I think it's the most accessible intro. SPJ is a fantastic speaker. 
20:05:48 <ggVGc> c_wraith: I am fairly comfortable with Lenses now. But not with how Const plays a part
20:06:02 <c_wraith> well, he does cover that part. 
20:06:06 <ggVGc> cool
20:06:12 <ggVGc> will watch it again
20:06:16 <ggVGc> c_wraith: the one on skillsmatter right?
20:06:29 <c_wraith> yes
20:06:51 <Cale> > sort "abracadabra"
20:06:53 <lambdabot>  "aaaaabbcdrr"
20:06:58 <Cale> > group (sort "abracadabra")
20:06:59 <lambdabot>  ["aaaaa","bb","c","d","rr"]
20:07:01 <ggVGc> when I read about Const before, it essentially seeemed like a type level hack
20:07:04 <ggVGc> that shouldn't work
20:07:04 <Cale> > map head (group (sort "abracadabra"))
20:07:05 <ggVGc> but does
20:07:06 <lambdabot>  "abcdr"
20:07:17 <Cale> > map (\x -> (head x, length x)) (group (sort "abracadabra"))
20:07:18 <lambdabot>  [('a',5),('b',2),('c',1),('d',1),('r',2)]
20:07:19 <EvanR> c_wraith: do you have a link to that video?
20:07:31 <c_wraith> ggVGc, it kind of is a clever type level trick. but it's not a hack one. 
20:07:38 <c_wraith> EvanR, not on my phone. 
20:08:34 <Cale> > Map.fromListWith (+) (zip "abracadabra" (repeat 1))
20:08:35 <lambdabot>      Not in scope: ‘Map.fromListWith’
20:08:36 <lambdabot>      Perhaps you meant one of these:
20:08:36 <lambdabot>        ‘M.fromListWith’ (imported from Data.Map),
20:08:38 <Cale> oops
20:08:38 <c_wraith> *hacky. tricky, yes. but it's founded on solid theory. :) 
20:08:41 <Cale> > M.fromListWith (+) (zip "abracadabra" (repeat 1))
20:08:42 <lambdabot>  fromList [('a',5),('b',2),('c',1),('d',1),('r',2)]
20:08:51 <ggVGc> c_wraith: yeah, that's what makes me curious in it. Because I can't see the part yet of why it's not invalid
20:09:35 <EvanR> ggVGc: do you have a link to this video?
20:10:20 <v937xjd> Has everyone given up on the llvm  backend or does it still have promise to it?
20:10:48 <dwynwen_ddlleyw> llvm?
20:10:58 <c_wraith> v937xjd, it's better for code involving certain kinds of tight loops. people still use it, when it helps. 
20:11:12 <Welkin> llouis vuttom
20:11:28 <c_wraith> v937xjd, but it isn't always faster, so it's not the default. 
20:12:26 <v937xjd> C wraith what about in conjunction with numeric stuff like repa
20:12:41 <v937xjd> Do they play well together
20:12:48 <dolio> I'd be suspicious of any intuitions about constant functions (or functors) being 'hacks,' since, for instance, it forms half of a universal combinator language.
20:13:28 <c_wraith> v937xjd, not sure. I haven't tried that combination. 
20:14:07 <c_wraith> EvanR, https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation I think
20:14:35 <EvanR> dang i dont have a login
20:15:15 <EvanR> the walls of this ivory tower are slick ;)
20:16:52 <Welkin> interesting
20:17:12 <Welkin> skillsmatter is a platform for hosting conference videos for programming?
20:18:15 <Cale> It's easy enough to sign up at least, but it is silly
20:18:42 <Cale> In many cases they didn't require a login to watch the videos at the time they were posted
20:18:45 <scshunt> anyone here know safe haskell?
20:19:10 <Cale> scshunt: Depends on what you mean by "know", but I get the idea
20:19:28 <dwynwen_ddlleyw> What's safe haskell?
20:19:48 <scshunt> Cale: Does every package require some sort of safety annotation to be considered safe, or does GHC ever figure it out on its own?
20:20:02 <Cale> It's an extension for marking modules as Safe, Unsafe, and Trustworthy
20:20:21 <LordBrain> it infers it, at least i've seen safe inferred in haddocks...
20:21:38 <scshunt> hrm
20:21:46 <Cale> Yeah, there's a recursive procedure which it uses to determine if you trust a module or not.
20:22:13 <scshunt> ok so then... hrm... trying to debug a problem with a change I made to lens that introduced a dependency on Control.Monad.Trans.Free, which it claims isn't safe
20:22:23 <Cale> er
20:22:25 <scshunt> but if I try to compile Control.Monad.Trans.Free with -XSafe, it doesn't complain
20:24:30 <Cale> scshunt: If a module was compiled with -XSafe and all of its direct imports are trusted, then it is trusted.
20:25:11 <drbean_> I'm getting 'cannot satisfy -package-id array-0.5.0.0- ... ' from ghc-mod-5.4.0.0, compiled by stack with ghc-7.10, which apparently has array-0.5.1.0.
20:25:13 <drbean_> What do I do about this?
20:25:36 <Cale> scshunt: there are some possibly useful descriptions of the mechanism here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe-haskell.html#idp46686530081056
20:26:16 <Cale> drbean_: That sounds like it's requesting to use the wrong version of array for that version of ghc
20:26:31 <ggVGc> why do some people dislike &?
20:26:33 <ggVGc> I use it all the time
20:26:37 <Cale> drbean_: Maybe its version constraints are mixed up?
20:26:38 <ggVGc> and find my code reads much easier
20:27:47 <Cale> ggVGc: Which (&) is that? Flipped application?
20:27:51 <ggVGc> yes
20:28:02 <ggVGc> tat's the only one I know
20:28:10 <Cale> Personally I avoid it because I like data to consistently flow right to left.
20:28:12 <LordBrain> :t (&)
20:28:22 <LordBrain> :t (&?)
20:28:45 <Cale> > 1
20:29:01 <Cale> I think lambdabot is disconnected temporarily
20:29:13 <Cale> There's been a lot of ping timeouts
20:29:13 <drbean_> Where does stack put the cabal files of global-projects/packages it installs?
20:29:14 <EvanR> call Oejetbot
20:29:14 <ggVGc> Cale: oh, I use * and >>> heavily because I like left to right
20:29:21 <ggVGc> eh & and >>>
20:29:52 <Cale> ggVGc: Well, ordinary function application and composition go right to left, and do-notation's <- goes right to left, and various other things.
20:29:53 <EvanR> f(g(h(x))) is this left to right ;)
20:30:08 <Cale> Well, the evaluation order is left to right
20:30:37 <EvanR> and computer science trees are upside down
20:30:45 <EvanR> why cant anyone get anything right
20:30:46 <Cale> If you have f . g . h $ x, it'll be f which is applied first (ignoring (.) and ($))
20:31:25 <Cale> It'll be applied to (g . h) x
20:31:49 <Cale> (not yet evaluated)
20:32:07 <LordBrain> i had a topology professor in college who reversed application
20:32:26 <LordBrain> there were audible groans, but he insisted
20:32:31 <LordBrain> :)
20:32:44 <LordBrain> so x f g meant g(f(x))
20:33:07 <ggVGc> wtf
20:33:27 <LordBrain> one of the irc servers detached from the network
20:33:40 <LordBrain> taking a lot of people with it
20:33:50 <ggVGc> I was referring to your professor
20:33:53 <LordBrain> oh
20:34:02 <ggVGc> taht looks terrible
20:34:47 <c_wraith> if you ever used a HP calculator, you're used to it. :) 
20:35:10 <LordBrain> there was a decent argument for the alternative notation, but i don't recall what it was
20:35:27 <EvanR> ggVGc: try lisp sometime ;)
20:35:27 <c_wraith> it's a really handy notation for interactive application. let's 
20:35:43 <LordBrain> he also had the less decent argument to accompany it which i do recall, and that is that "we shouldn't be so attached to notation"
20:35:51 <LordBrain> lol
20:35:56 <c_wraith> it let's you decide what do do after seeing the result, when done interactively. 
20:36:05 <c_wraith> *lets 
20:36:36 <EvanR> LordBrain: hmmm... that might be lisps argument too
20:36:39 <LordBrain> if you think of the function application as an action you are doing, then x f g has the advantage of saying the order you are doing things from left to right, just like english.
20:37:07 <LordBrain> start with x, apply f, then apply g... so on
20:38:31 <Cale> LordBrain: Apart from the fact that the Haskell evaluator actually works the other way
20:38:37 <LordBrain> i don't actually know recall if my topology instructor was eccentric, or if that notation is quite common among topologists... i do think the book used the same notation
20:38:51 <Cale> When you write f (g x) it first applies f to the (not yet evaluated) value (g x)
20:38:52 <c_wraith> push x onto the stack, apply f to the top element of the stack, apply g to the top element of the stack.. 
20:39:30 <geekosaur> it's not that odd for different branches of math to use the same notation in different ways
20:39:41 <geekosaur> or even different "schools" within the same branch doing so
20:39:46 <Cale> Only if f pattern matches on its argument will the evaluator actually compute (g x)
20:39:49 <ggVGc> in english I don't say "take x, apply g, then apply f to the result"
20:39:54 <ggVGc> I say "Apply f to g of x"
20:40:07 <Cale> (or of course, if f produces something depending on (g x) which is evaluated at a later point)
20:40:15 <ggVGc> stack based computing sucks for the human brain
20:40:23 <LordBrain> only because you learned it htat way ggVGc ... the convention could just as easily been selected the other way around...
20:40:28 <c_wraith> but yeah, Cale's point about haskell is good. evaluation order is actually left to right. 
20:40:49 <Cale> Yeah, Haskell evaluation is left-to-right with the standard convention.
20:40:57 * geekosaur considers the old joke about Germans and verb-at-the-end and wonders if they handle stacking better :p
20:41:02 <Cale> Well, outermost first, and then left to right
20:41:37 <monochrom> Japanese postfix likely is.
20:41:40 <LordBrain> i doubt the topologist knew any lazy evaluation... not his field
20:41:56 <LordBrain> nor would he find your argument persuasive
20:42:08 <ggVGc> my personal favourite way of thinking about computing is "streams". I.e taking a value and passing it through a series of transformations
20:42:13 <ggVGc> hence why I use >>> a lot
20:42:32 <ggVGc> so I much prefer x&(foo >>> bar >>> baz)
20:42:56 <LordBrain> then why get so upset with x g f ?
20:43:08 <hackrilege> could someone take a look at this datastructure for me? im just writing some instances for it now http://lpaste.net/160005
20:43:34 <ggVGc> LordBrain: because it doesn't read clearly. BUt sure, we shouldn't be so attached to notation :)
20:44:01 <LordBrain> actually it does read very clearly, much more clearly than the usual convention... x, then g, then f
20:44:31 <monochrom> sometimes group theory texts write "((x)f)g"
20:44:43 <LordBrain> probably for similar reasons
20:45:02 <c_wraith> it's kind of FORTH-y
20:45:19 <LordBrain> tho i havent seen the group theorists doing it, there is a lot of overlap
20:46:16 <LordBrain> the problem tho if you took it to haskell would be we would have to write function declarations backwards
20:46:51 <EvanR> the sumerians had it right all along, the order to swap every line to you dont have to "carriage return" all the way to the beginning
20:46:53 <monochrom> (x Just) isJust = True
20:47:04 <LordBrain> and our type signatures... what a mess... unless the whole thing was right-aligned... and the topology texts don't right align... so thats not hte same either
20:47:58 <monochrom> Bool <- a Maybe :: isJust
20:48:00 <Cale> monochrom: There are a few oddball category theorists who go that far (or at least flip the order of composition)
20:48:16 <Cale> and yeah, you could instead flip the direction of your arrows
20:48:17 <LordBrain> it'd be funny to have a {-# LANGUAGE BackwardsApplication #-}
20:48:23 <ggVGc> I like the oportunity of mix in haskell. Sometimes foo x reads better, sometimes x & (foo >>> bar) is better, imo
20:48:27 <ggVGc> there's no one true way
20:48:35 <ggVGc> I mix and match based on context
20:48:40 <Cale> f :: B <- A  perhaps makes more sense with the standard convention for application
20:49:06 <ggVGc> Just x is obviously better than (x Just)
20:49:07 <scshunt> Cale: I dislike it actually for one reason
20:49:07 <ggVGc> imo
20:49:19 <LordBrain> as long as we are left aligned, i do think the function name should come first followed by the ::
20:49:25 <scshunt> currying becomes far less intuitive
20:49:30 <Cale> scshunt: Yeah :D
20:49:33 <dolio> Cale: It doesn't, actually.
20:49:53 <monochrom> I know a text that keeps A->B and uses "f ; g" for flipped composition. It's ok because a new symbol ";" is chosen, no conflict.
20:50:01 <Cale> monochrom: yeah
20:50:08 <scshunt> f ; g is actually pretty solid
20:50:09 <dolio> (f :: (C <- B) <- A) (x :: A) (y :: B)
20:50:19 <Cale> dolio: right
20:51:02 <monochrom> besides, f and g are commands, this is a category of imperative commands, "f ; g" is exactly how you write an imperative program.
20:51:03 <LordBrain> you know, i think he mimght have had the ; in there, i do not recall
20:51:10 <LordBrain> its been so long
20:51:13 <ggVGc> I thought about something the other week. Given a type error, a tool could suggest a function from the current code base(and other imported modules) based on type signatures. WOuld that be useful?
20:51:33 <EvanR> ggVGc: yes "notation for notation notation" is really nice as just(x) or just(cons(x, cons(y, nil))), its not though that we dont have to use this for everything
20:51:57 <EvanR> its nice that we dont..
20:52:07 <drbean_> How would I find what version of array is used in what version of ghc?
20:52:08 * EvanR throws keyboard into woodchipper
20:52:56 <ggVGc> but it's not wood..
20:53:03 <monochrom> wait a second, do you hate the keyboard or do you hate the woodchipper? :)
20:53:20 <LordBrain> so, he'd write x;g;f
20:53:24 <LordBrain> maybe...
20:53:25 <monochrom> drbean_: "ghc-pkg list array"
20:53:27 <LordBrain> not sure
20:53:36 <LordBrain> i might have the book somewhere around here
20:54:27 <monochrom> if you have multiple ghc versions, "ghc-pkg-7.10.3 list array"
20:58:23 <Cale> drbean_: On my machine with 7.10.1, I have array-0.5.1.0
20:58:31 <LordBrain> cabal info array | grep inst
20:58:38 <LordBrain> its longer but it works in a sandbox..
20:58:45 <Cale> drbean_: Which suggests that you'd need 7.8.x to have array-0.5.0.0
20:59:53 <LordBrain> hmm
21:00:33 <LordBrain> is there a quick way to get a list of all packages bundled with ghc?
21:07:47 <EvanR> can i make ghci attach a type sig after each result like
21:07:52 <EvanR> > 2+2
21:07:57 <lambdabot>  4
21:07:57 <EvanR> 4 :: Integer
21:11:15 <EvanR> :set +t gives a list of bindings...
21:21:29 <LordBrain> well there is -ddump-tc
21:21:37 <LordBrain> maybe too much info tho
21:25:03 <LordBrain> i find that shows it on the line "Exported types" .. .but it doesnt show what it is defaulting to
21:26:21 <LordBrain> you'd think -ddump-types would be enough to get it, but that doesnt seem to work interactively
21:27:07 <EvanR> could have sworm there was a demo where this was activated maybe not
21:27:18 <LordBrain> i have a similar memory
21:27:22 <Cale> LordBrain: Oh, ghc-pkg list -- and look at what's in the global db, since you shouldn't be installing things there :)
21:27:30 <LordBrain> but also have recalled not being able to find it when i wanted to do it
21:28:06 <LordBrain> maybe we are remembering a hugs feature?
21:30:29 * hackagebot hipchat-hs 0.0.3 - Hipchat API bindings in Haskell  https://hackage.haskell.org/package/hipchat-hs-0.0.3 (oswynb)
21:30:35 <LordBrain> hugs understands +t and does exactly what you want EvanR, that is probably what we are both reclaling
21:30:54 <LordBrain> :set +t is the exact command even
21:31:04 <EvanR> maybe it was an old version of ghci
21:31:15 <LordBrain> did you ever use the hugs interpretter?
21:31:15 <Cale> Prelude> :set +t
21:31:16 <Cale> Prelude> 5
21:31:16 <Cale> 5
21:31:16 <Cale> it :: Num a => a
21:31:20 <Cale> Seems to work
21:31:21 <EvanR> ill go with remembering a feature from hugs despite never having used it
21:31:41 <Cale> It's in GHCi, try it?
21:32:07 <EvanR> Cale thats an extension of the show bindings feature, and while it works it kind of distracts from the simple result of 5 :: Num a => a
21:32:31 <Cale> oh
21:32:32 <EvanR> thought it does indicate that `it' exists which is useful
21:32:50 <EvanR> let x = 5
21:32:51 <Cale>     +t            print type after evaluation
21:32:55 <EvanR> x :: Num a => a
21:33:05 <Cale> I suspect that since it's documented like this, perhaps it used to work differently
21:33:12 <EvanR> i think it did
21:37:22 <bhiliyam> clear
21:38:09 <navaro1> Hey guys
21:38:16 <navaro1> I could really use your help and criticism :)
21:38:23 <navaro1> working on simple RPS game with simple AI
21:38:40 <navaro1> and I want to make it more `functional style`
21:39:32 <navaro1> so, could you help me:
21:39:32 <navaro1> https://github.com/navaro1/lyfe/blob/master/Haskell/RPS/Main.hs
21:39:42 <navaro1> and point to places, give advice what I should do next?
21:41:33 <Axman6> urgh, why would the Data.Bytestring.Internal module not be exported! this is madness!
21:42:22 <navaro1> I do not understand, could you explain?
21:42:23 <LordBrain> navaro1, pass the random values in to the functions, not have the functions call the random
21:42:40 <LordBrain> if you want to be more functional
21:42:51 <navaro1> I do, that's the whole point
21:42:58 <navaro1> could you care to explain why?
21:43:00 <Axman6> hmmm, maybe it is? but the docs aren't available on hackage >_<
21:43:09 <LordBrain> chooseBestHand for example can be completely pure
21:44:09 <LordBrain> that is, it neednt have the type IO Hand as the return value, it could be chooseBestHand :: Map Hand Int -> Hand -> Hand
21:44:26 <LordBrain> where the second parameter is the result of randomHand
21:45:38 <LordBrain> this is just a quick glance reaction btw, i didnt study the code too closely, but you asked how to make it more functional, and that's just a general principle of being functional
21:45:42 <EvanR> Axman6: sometimes docs are available but on in the table of contents
21:45:43 <LordBrain> cut down the number of IO functions
21:46:39 <LordBrain> in practice, it isn't always necessarily what you want, for practical reasons, but it is more functional
21:48:13 <LordBrain> with the exception of the functions which read/write to files and the ones which generate random values, and main itself, every other function in your program can be completely pure, at the expense of adding more arguments when you call them
21:48:14 <EvanR> replace the call to the RNG in the pure function with the number 4, guaranteed random number
21:48:23 <LordBrain> lol
21:48:50 <navaro1> @LordBrain: thank you
21:48:50 <lambdabot> Unknown command, try @list
21:48:58 <navaro1> LordBrain: thank you
21:49:03 <dwynwen_ddlleyw> Would haskell be a good language for ciphers?
21:50:07 <kadoban_> dwynwen_ddlleyw: Likely not really, if you're talking about actually secure ones. Some things you really want to be able to do are going to be … hard at the abstraction level haskell usually provides. Like preventing timing attacks for instance.
21:50:35 <dwynwen_ddlleyw> I want to do simple ciphers and stuff 
21:50:44 <Cale> Oh, well, those will be easy :)
21:50:44 <dwynwen_ddlleyw> Like ROT13 and that stuff
21:51:13 <kadoban_> dwynwen_ddlleyw: Yeah, it'd be perfect for playing around with that kind of stuff.
21:51:16 <LordBrain> navaro1, another fairly decent idiom, to consider, is to pass in a state type, which is essentiallly a record which  has a lot of common parameters in it... makes refactoring easier, and cuts the number of arguments down.
21:51:17 <Cale> There are people working on cryptosystems using Haskell, but they use it to construct and emit code which is usually in another language (or hardware layouts)
21:51:36 <Cale> Galois does a lot of that
21:51:41 <navaro1> LordBrain: so basically a state monad?
21:51:49 <LordBrain> no
21:51:57 <LordBrain> well, you could do that
21:52:43 <LordBrain> but that's not what i mean, per se, a state monad lets you sort of hide that you are passing the parameter, but i mean passing it explicitly, which is actually usually preferable
21:54:09 <LordBrain> but that "preferable" is more subjective than my other advice
21:54:27 <navaro1> okay
21:54:30 <navaro1> thank you :)
21:54:32 <LordBrain> so if you think state monads are cool, run with it, until it hurts you somehow
21:54:41 <navaro1> will refactor it and come back later
21:54:42 <ggVGc> I always end up with a fold instead of the state monad
21:56:15 <LordBrain> when i was first learning haskell, i made a bouncing ball program that was completely pure, and worked via a generator of an infinite list of positions, and a mapM_ displayIt on the list
21:57:34 <LordBrain> i did it in multiple ways, once using the classic State monad,and another using explicit parameters... i decided that the standard State monad was pretty much a useless toy. StateT is handy, but pretty much every experienced haskeller i know doesn't use the regular State monad for much of anything.
21:58:32 <hackrilege> http://lpaste.net/160066
21:58:43 <hackrilege> can anyone help me with this?
21:59:57 <dwynwen_ddlleyw> What the hell am I reading 
22:00:52 <hackrilege> are you reading my paste?
22:02:00 <dwynwen_ddlleyw> Yes
22:02:35 <hackrilege> this answers your question
22:02:37 <dwynwen_ddlleyw> What is this, this is like what I write when I am trying to write JS while having schizophrenic delusions 
22:03:05 <hackrilege> its haskell
22:03:39 <dwynwen_ddlleyw> What's a functor 
22:03:43 <dwynwen_ddlleyw> That sounds made up 
22:03:53 <hackrilege> omg
22:03:57 <hackrilege> http://stackoverflow.com/questions/13352205/what-are-free-monads
22:04:28 <hackrilege> a functor is a datastructure with an implentation of fmap
22:04:42 <hackrilege> satisfying da laws
22:04:59 <scshunt> hackrilege: help how?
22:05:07 <Cale> hackrilege: please be kind to the beginners :)
22:05:25 <hackrilege> i didnt realise
22:05:33 <Cale> also, what the hell am I reading? ;)
22:05:37 <hackrilege> ffs!
22:06:06 <dwynwen_ddlleyw> I can't read even that explanation 
22:06:07 <hackrilege> any idea how to update the neighbors?
22:06:16 <dwynwen_ddlleyw> It's like reading a big maths problem 
22:06:20 <dwynwen_ddlleyw> Which kills me inside
22:06:23 <scshunt> hackrilege: why are you trying to manually implement your own free functor?
22:06:30 <scshunt> dwynwen_ddlleyw: what brought you here?
22:06:37 <dwynwen_ddlleyw> Haskell
22:06:51 <hackrilege> you should read about functors
22:06:52 <scshunt> What specifically, though? Are you learning it for fun?
22:07:13 <hackrilege> i dont talk about why
22:07:16 <hackrilege> only how
22:07:24 <hackrilege> sry!
22:07:26 <EvanR> "i didnt come for the haskell"
22:07:37 <scshunt> hackrilege: it's relevant
22:07:49 <hackrilege> for scan
22:08:14 <Cale> dwynwen_ddlleyw: yeah, don't bother with that for now
22:08:16 <dwynwen_ddlleyw> Well I came first of all because the name is cool and since I am an idiot that's how I pick and choose things
22:08:21 <hackrilege> i want anaolgy to pattern matching on (:) for cyclic datatypes
22:08:27 <dwynwen_ddlleyw> And because it looked cool 
22:08:39 <Cale> dwynwen_ddlleyw: I can help you understand Functor at least :)
22:08:52 <Cale> Not sure I have time for more tonight... still working on stuff
22:08:55 <scshunt> hackrilege: why not write the functor instance on Node?
22:08:58 <dwynwen_ddlleyw> And the more I learn about it the less cool it seems. The more I read here the less sense things make 
22:09:12 <Cale> dwynwen_ddlleyw: Are you familiar with the map function on lists?
22:09:12 <hackrilege> > fmap (+1) [a|a<-[1..10],isEven a]
22:09:14 <lambdabot>  Not in scope: ‘isEven’
22:09:36 <dwynwen_ddlleyw> I know what a list is...
22:09:39 <hackrilege> scshunt, aha good idea
22:09:45 <dwynwen_ddlleyw> But not what the rest of what you said is
22:09:46 <hackrilege> a list is a functor
22:09:51 <scshunt> (your Free type, btw, is not actually a free functor if that's what you were going for)
22:09:53 <Cale> dwynwen_ddlleyw: Okay, so yeah, there's a bunch of stuff we should introduce first
22:10:22 <hackrilege> why is it not a free functor, what is?
22:10:42 <scshunt> the reason's a bit technical
22:10:42 <Cale> dwynwen_ddlleyw: In Haskell, we have data types (such as lists) which are parameterised by the type of elements they have
22:10:50 <dwynwen_ddlleyw> Is it like [1, 2, 3, 4, 5].each(function(i) { return i++; }) => [2, 3, 4, 5, 6]
22:10:51 <scshunt> but first observe that your type is isomorphic to a nonempty list
22:11:06 <hackrilege> data Free f a = Pure a | Roll (f (Free f a))
22:11:09 <Cale> dwynwen_ddlleyw: Yeah, that's roughly map (+1) [1,2,3,4,5]
22:11:15 <hackrilege> data Free f a = Nil | Roll (f (Free f a))
22:11:16 <dwynwen_ddlleyw> Okay 
22:11:26 <scshunt> where you wrap each element in an instance of f
22:11:28 <Cale> dwynwen_ddlleyw: So Functor, and fmap generalise this picture to data structures which are not lists
22:11:29 <dwynwen_ddlleyw> So map is just a set of things you use to operate on lists?
22:11:31 <hackrilege> your saying the latter is the correct version?
22:11:38 <scshunt> hackrilege: no, just pointing that out
22:11:45 <scshunt> hackrilege: so the reason is kind of technical
22:11:51 <Cale> map f xs will apply a function f to all elements of a list xs
22:11:51 <scshunt> oh wait I said that
22:11:56 <hackrilege> its not the free Monoid is that what you mean?
22:12:06 <scshunt> a free monad is a free algebra
22:12:12 <Cale> dwynwen_ddlleyw: But now imagine we have a Tree or something, maybe we want to apply a function to all its elements?
22:12:13 <scshunt> a free functor is something different
22:12:14 <hackrilege> okok
22:12:17 <dwynwen_ddlleyw> So it's sort of like vector programming 
22:12:24 <dwynwen_ddlleyw> But with more complex structures 
22:12:39 <Cale> dwynwen_ddlleyw: So Functor is a type class for types that let you apply a function to all their elements
22:12:39 <scshunt> actually hmm
22:12:41 <scshunt> nvm
22:12:47 <scshunt> that *is* the free monad, I misread
22:12:51 <scshunt> please ignore me?
22:12:52 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
22:13:08 <dwynwen_ddlleyw> I can't read that 
22:13:14 <hackrilege> scshunt, not at all, thanks for looking at my code
22:13:23 <dwynwen_ddlleyw> Wait let me try
22:13:26 <Cale> says "If f is a functor, then fmap is a function which takes a function of type (a -> b), and a data structure of type f a, and produces a data structure of type f b
22:13:28 <Cale> "
22:13:33 <scshunt> hackrilege: still, I'd recommend implementing your functor instance on Node
22:13:48 <dwynwen_ddlleyw> Okay but what is data structure f a
22:13:49 <scshunt> hackrilege: it's possible to still make a free monad if your underlying type isn't a functor, but it's easier if it is
22:13:56 <hackrilege> that says, fmap is a function which takes a function from a to b and a functor of a and returns a functor of b
22:13:59 <dwynwen_ddlleyw> And what is type a => b
22:14:05 <dwynwen_ddlleyw> a -> b*
22:14:21 <Cale> a -> b is the type of functions which accept an argument of type a, and produce a result of type b
22:14:24 <EvanR> > map (chr . (`mod` 26) . (+13) . ord) "fmap :: (Functor f) => (a -> b) -> f a -> f b"
22:14:25 <lambdabot>  "\v\DC2\ACK\NAK\DC3\DC3\DC3\DC3\SOH\ENQ\NUL\DC3\b\EM\DC4\ETB\DC3\v\STX\DC3\S...
22:14:37 <dwynwen_ddlleyw> So (a -> b) is what the functor does
22:14:40 <Cale> (this is polymorphic, so it works for any a and b you choose)
22:15:09 <hackrilege> ohhh i made a big error
22:15:12 <Cale> The function of type (a -> b) is what fmap is going to apply to all the elements of the data structure
22:15:18 <hackrilege> i have Free already in Node
22:15:24 <dwynwen_ddlleyw> And f a is calling the functor with a to produce the functor b?
22:15:25 <Cale> f is what we refer to as the functor
22:15:32 <hackrilege> okok, ill redo this
22:15:49 <Cale> It might, for example, be the brackets [] you see around list types, so then  f a = [a]
22:16:05 <Cale> Or it might be a type of binary trees: f a = BinTree a
22:16:07 <scshunt> Cale: I think you're going over his head
22:16:22 <dwynwen_ddlleyw> Does f a = [a] turn a into a list
22:16:45 <hackrilege> try this one instead http://lpaste.net/160005
22:16:47 <dwynwen_ddlleyw> I am a she by the way :P
22:16:48 <Cale> dwynwen_ddlleyw: I just mean it's possible, when we go to use fmap, for the f a in the type of fmap to be specialised to [a]
22:16:54 <scshunt> dwynwen_ddlleyw: My apologies!
22:16:59 <Cale> [a] is the type of lists of elements of type a
22:17:09 <Cale> e.g.  [1,2,3,4,5] :: [Integer]
22:17:14 <scshunt> dwynwen_ddlleyw: btw what language whas that where you did the .each()?
22:17:38 <dwynwen_ddlleyw> I want to understand what you are saying but you are saying it in such a way that seems to just be walking around what I think you mean 
22:17:44 <dwynwen_ddlleyw> scshunt: JS
22:17:48 <scshunt> ah ok
22:18:08 <Cale> dwynwen_ddlleyw: Well, let's define a binary tree type and make it into a functor -- examples help.
22:18:19 <scshunt> dwynwen_ddlleyw: are you confused by the syntax?
22:18:30 <dwynwen_ddlleyw> "[a] is the type of lists of elements of type a" => "[a] is the type of the list"
22:18:34 <dwynwen_ddlleyw> Is this correct
22:18:36 <Cale> yes
22:18:37 <hackrilege> am i doing this right? im trying to use Free to rewrite data Node g a = Node {parent :: Maybe (Node g a), contents :: a, next :: Node g a, neighbors :: g (Node g a)}
22:18:43 <hackrilege> data Node g a = Node {parent :: Maybe (Node g a), contents :: a, next :: Node g a, neighbors :: g (Node g a)}
22:18:49 <dwynwen_ddlleyw> You're saying things in a very verbose way 
22:19:09 <scshunt> dwynwen_ddlleyw: Cale is referring to the type itself
22:19:11 <dwynwen_ddlleyw> And my brain isn't parsing it right 
22:19:18 <scshunt> not to a specific object
22:19:35 <Cale> @let  data BinTree a = Tip | Branch a (Tree a) (Tree a)
22:19:36 <lambdabot>  Defined.
22:19:51 <dwynwen_ddlleyw> Here is how I thought of it 
22:19:53 <Cale> Here, I've defined a new type BinTree
22:20:13 <Cale> It is parameterised by the type of elements we're going to store in it, for example,  BinTree Integer  will be a type
22:20:24 <dwynwen_ddlleyw> if I make a = int then [int] is a list of things with a type of int 
22:20:28 <scshunt> hackrilege: I don't think so.
22:20:39 <dwynwen_ddlleyw> That's what I think you are saying 
22:20:48 <Cale> dwynwen_ddlleyw: [Int] is the type of lists of things whose type is Int
22:20:52 <scshunt> hackrilege: because where did the Maybe go?
22:20:58 <hackrilege> Pure a
22:20:59 <Cale> e.g. [1,2,3,4,5] :: [Int] would be fine
22:21:11 <scshunt> hackrilege: what if you want it to be Nothing?
22:21:16 <Cale> ["hello", "there", "world"] :: [String]
22:21:27 <scshunt> dwynwen_ddlleyw: [Int] is not a list though. It's a type.
22:21:44 <dwynwen_ddlleyw> "... is the type of lists ..." <- this wording is tripping me up 
22:21:55 <hackrilege> ok it needs the Maybe i updated the paste
22:22:06 <dwynwen_ddlleyw> "... is the list type ..." is how I end up reading it 
22:22:11 <Cale> dwynwen_ddlleyw: Yeah despite looking a bit like a list with one type in it, [Int] isn't itself a list
22:22:25 <Cale> Yeah, fair enough, it's the list type for lists whose elements have type Int
22:22:33 <dwynwen_ddlleyw> I know it's not A list but it is describing a type of list
22:22:36 <Cale> yeah
22:22:45 <scshunt> hackrilege: still seems wrong, because it doesn't have recursive structure
22:23:00 <scshunt> hackrilege: are you trying to understand something in particular, or just abstract your code?
22:23:11 <dwynwen_ddlleyw> I am not trying to say it's a list but I am trying to say that [int] describes a list whose members are of type int 
22:23:23 <Cale> That's correct
22:23:38 <hackrilege> the point is that if Node is defined recursivly i cant use Free
22:23:48 <hackrilege> i want to abstrct out the recursion
22:24:15 <Cale> (though specific types start with an uppercase letter in Haskell, so you probably want Int, while int would be a type variable which we could fill in with any other type)
22:25:11 <dwynwen_ddlleyw> I have a question about the mutability though 
22:25:23 <hackrilege> such as type List a = Free (a,)
22:25:25 <scshunt> hackrilege: I think you don't want free
22:25:26 <hackrilege> (is that right?)
22:25:38 <Cale> dwynwen_ddlleyw: I sort of wish for the purposes of this discussion that we didn't have the special syntax [Int] and instead wrote List Int, just because that makes it clearer what's going on when we substitute List for f
22:25:52 <scshunt> hackrilege: unless I misunderstand your data structure a lot
22:26:00 <Cale> dwynwen_ddlleyw: But it is possible to write [] Int in place of [Int] if you prefer in Haskell.
22:26:01 <dwynwen_ddlleyw> if a is declared as an array [1, 2, 3] could I then set a as the value of map (+)[1, 2, 3] or would I need to assign that to b
22:26:08 <scshunt> ohhh, you're trying to do that isomorphism. ok
22:26:19 <Cale> a and b in the type of maps are variables which stand for types
22:26:21 <Cale> er
22:26:24 <Cale> in the type of map
22:26:26 <scshunt> hackrilege: wait, then what is parent?
22:26:29 <hackrilege> the datastructure should basically be a linked list with some  extra data refering to neighbors
22:26:35 <Cale> map :: (a -> b) -> [a] -> [b]
22:26:38 <hackrilege> parent is left
22:26:43 <hackrilege> next is right
22:26:44 <Cale> For example, we could choose a = Int and b = String
22:26:46 <dwynwen_ddlleyw> I am just talking about variables though 
22:26:47 <scshunt> hackrilege: yeah, so you're going to need to get more clever here
22:26:48 <Cale> and then
22:26:57 <scshunt> because what you've got leads to an infinite data structure
22:26:57 <Cale> map :: (Int -> String) -> [Int] -> [String]
22:27:05 <dwynwen_ddlleyw> Okay let me try again 
22:27:08 <Cale> > map show [1,2,3,4,5]
22:27:10 <lambdabot>  ["1","2","3","4","5"]
22:27:19 <hackrilege> :t (map show)
22:27:20 <lambdabot> Show a => [a] -> [String]
22:27:23 <Cale> dwynwen_ddlleyw: Nothing is being mutated here
22:27:47 <Cale> dwynwen_ddlleyw: We're constructing a new list whose elements are the results of applying the given function to the elements of the given list
22:27:52 <Cale> @src map
22:27:53 <lambdabot> map _ []     = []
22:27:53 <lambdabot> map f (x:xs) = f x : map f xs
22:28:01 <dwynwen_ddlleyw> in js I can have: var a = [1, 2, 3]; a = a.each(function(i) { return i++; })
22:28:15 <Cale> right
22:28:19 <dwynwen_ddlleyw> Can I do that in haskell 
22:28:29 <EvanR> that js code doesnt do anything
22:28:34 <dwynwen_ddlleyw> Reassign a from [1, 2, 3] to [2, 3, 4]
22:28:43 <Cale> dwynwen_ddlleyw: You can't reassign variables while they remain in scope
22:29:07 <EvanR> it doesnt convert [1,2,3] to [2,3,4]
22:29:17 <dwynwen_ddlleyw> I know 
22:29:19 <Cale> dwynwen_ddlleyw: However, there are things like IORefs which represent mutable cells that can be read and written to explicitly -- wait until you understand more of the language for that though.
22:29:26 <dwynwen_ddlleyw> It's an example thing
22:29:55 <Cale> dwynwen_ddlleyw: do vs <- readIORef a; writeIORef a (map (+1) vs)
22:30:31 <hackrilege> scshunt, i had this http://lpaste.net/159376
22:30:36 <hackrilege> that was almost woring ok
22:30:42 <Cale> would be an action which, when executed, will read the contents of a :: IORef [Int], getting a list vs :: [Int], and then write (map (+1) vs) back to the IORef
22:31:01 <scshunt> hackrilege: ewwwww
22:31:17 <hackrilege> yeah sorry
22:31:29 <scshunt> this makes a bit more sense though
22:31:45 <Cale> dwynwen_ddlleyw: But that involves IO actions, which you might not want to get into so early :)
22:32:06 <hackrilege> i guess i was trying to introduce Free too soon
22:32:24 <scshunt> hackrilege: the problem you're going to run into with that is that your Functor instance, though technically correct, doesn't do what you want
22:32:43 <Cale> dwynwen_ddlleyw: There are other ways to discuss mutating things, but expression evaluation in Haskell doesn't ordinarily cause any visible mutation to occur. (It does cause some invisible mutation, as expressions are replaced with their values in memory)
22:32:54 <hackrilege> oh yeah
22:32:58 <hackrilege> i forgot about that
22:33:12 <hackrilege> i will make a synonym of Free
22:33:45 <Cale> dwynwen_ddlleyw: If you want to have a variable which takes on many different values, one thing you can do is to make the variable a parameter to a function, and have that function apply itself to new arguments according to how you'd like the variable to change.
22:34:10 <scshunt> hackrilege: well the whole problem is the TVar mess you're trying to use
22:34:18 <hackrilege> haha
22:34:28 <hackrilege> i didnt know how else to update
22:34:45 <hackrilege> but yeah i dont want to be confined to within the STM monad
22:35:37 <Cale> dwynwen_ddlleyw: One thing which I sometimes do when trying to read an obfuscated C program or something, is I'll take each point of control in the program (each place where you could be while executing the program), and turn it into a function, whose arguments are all the mutable variables in scope. Then I make the functions call each other according to where the program would go, with the updated values of the variab
22:35:37 <Cale> les.
22:35:43 <scshunt> hackrilege: I guess my first question is why you're trying to write a doubly-linked list at all?
22:36:08 <Cale> dwynwen_ddlleyw: This makes a mess, but it makes a mess consisting of equations, and so I can then simplify the program by doing highschool algebra -- substituting equals for equals.
22:37:05 <Cale> Each function computing the result of the whole program from the values of all the variables at a given point in it.
22:37:38 <Cale> I don't know if that makes any sense, it would probably help to have an example of that too
22:38:53 <LordBrain>  i think we drove him away
22:39:31 <LordBrain> he needs to be sold more on learning it,before he actually learns it
22:40:36 <Cale> her
22:40:37 <LordBrain> if all that brought him here was, hey thats a cool sounding name, then he might not be sufficiently motivated to bother with it
22:40:44 <LordBrain> oh her
22:40:48 <LordBrain> same thing tho
22:40:59 <Cale> yeah :)
22:41:12 <LordBrain> the intro page on haskell.org used to have a good motivating introduction
22:41:18 <LordBrain> probably still does
22:41:44 <srhb> The answer to the question was just "no, you can't do that" -- that's probably a lot less scary to any newcomer. :-)
22:41:52 <hackrilege> so that i can traverse locally
22:42:03 <hackrilege> pattern matching on the cpnstructor
22:42:05 <LordBrain> lol good point srhb 
22:42:10 <scshunt> hackrilege: if all you want is a list with an O(1) insertion, use a Zipper
22:42:13 <scshunt> *zipper
22:42:28 <hackrilege> in 2d
22:42:34 <hackrilege> a grid
22:43:08 <hackrilege> LZ a = ([a],a,[a]) , LZ2 a = LZ (LZ a)
22:50:55 <hackrilege> http://lpaste.net/160069
22:57:14 <hackrilege> scshunt, hows about this? (updated http://lpaste.net/160069)
22:57:51 <hackrilege> http://lpaste.net/160069
22:59:17 <hackrilege> its basically building the list zipper into the list
23:00:17 <hackrilege> left and right are now constructors
23:00:36 <hackrilege> they can be pattern matched on
23:02:58 <hackrilege> data BiDirectional a = BiDirectional {val :: a , left :: Maybe (BiDirectional a),right:: Maybe (BiDirectional a)}
23:03:05 <hackrilege> how can i rewrite that using Free?
23:04:04 <adarqui> anyone know off hand, of a lib that reads aeson ToJSON/FromJSON instances and generates something from it.
23:04:07 <adarqui> weird q.
23:04:23 <dwynwen_ddlleyw> Sorry 
23:04:29 <dwynwen_ddlleyw> I was busy reading something 
23:05:36 <adarqui> basically i'm trying to get an idea of how i can read my CUSTOM ToJSON/FromJSON instances, and output them in purescript.. basically using this code (modifying it perhaps) to not just read the records themselves, but, my custom ToJSON/FromJSON instances: https://github.com/pkamenarsky/purescript-interop/blob/master/src/Purescript/Interop.hs
23:06:33 <dwynwen_ddlleyw> What is purescript?
23:06:58 <adarqui> i could also do something simple though, like modify the prefix'ed field names and such, underscoring the camel case etc
23:07:01 <adarqui> that sounds better
23:07:21 <adarqui> dwynwen_ddlleyw: a dope haskell-like language which compiles to javascript for frontend/web programming
23:18:01 <dwynwen_ddlleyw> I am so proud of myself 
23:18:08 <dwynwen_ddlleyw> I beat a little mind game 
23:18:13 <dwynwen_ddlleyw> http://david-peter.de/parachuting-robots/
23:19:44 <dwynwen_ddlleyw> https://www.irccloud.com/pastebin/joqN2csZ/
23:31:13 <Cale> dwynwen_ddlleyw: nice!
23:37:04 <EvanR> natural numbers are the initial algebra of the Maybe functor
23:37:17 <EvanR> lists are the initial algebra of ...
23:37:42 <EvanR> Fix (Maybe (X,a)) ?
23:42:53 <hackrilege> List a =? Fix (Compose (a,) Maybe)
23:43:37 <hackrilege> List a =? Fix (Compose Maybe (a,))
23:43:38 <EvanR> alrighty then
23:43:59 <hackrilege> is that right?
23:44:04 <EvanR> im not sure
23:44:32 <hackrilege> Free = Fix (Compose (Either a) f)
23:44:52 <EvanR> im trying to understand the initial F-algebra relationship for lists
23:45:15 <EvanR> so lists being isomorphic to that functor is either obvious or completely wrong
23:46:05 <tosun> I have a happy+alex-related question, is anyone interested in helping?
23:46:52 <tosun> I've set up happy+alex with stack. I have a file Parser.y which exports the function `parseExpr`.
23:47:07 <tosun> I can use import this function and use it fine
23:47:22 <tosun> But I can't refer to it when I import the Parser module in ghci
23:47:27 <tosun> Nor does my haskell-mode recognize it
23:47:28 <EvanR> hackrilege: cant be right, not enough variables
23:47:37 <hackrilege> Fix (Compose Maybe (a,)) = Nil | Roll (Maybe . (a,(Maybe . (a,(Maybe . (a,(Maybe . (a,))))))))
23:47:40 <hackrilege> etc
23:47:47 <EvanR> List a takes zero, your Fix (Compose Maybe (a,)) takes 1
23:48:18 <hackrilege> no
23:48:35 <hackrilege> Fix f a, f kind * -> *
23:48:36 <EvanR> oh
23:48:46 <EvanR> nvm
23:49:24 <EvanR> well free monads probably not helping me at this point ;)
23:49:34 <hackrilege> hmmm the Maybe is redundant as Nil
23:49:55 <hackrilege> so List =? Fix (a,)
23:50:08 <EvanR> the question is what functor is the list the initial F-algebra of... what is F
23:50:13 <hackrilege> !?
23:50:20 <hackrilege> whats an f-algebra!?
23:52:31 <EvanR> its a functor f with a type X and an eval function :: f X -> X such that
23:53:17 <EvanR> thats it
23:54:02 <hackrilege> copure
23:54:19 <hackrilege> jk
23:54:23 <EvanR> however the initial f-algebra is the initial object in a category of f-algebras which requires defining the property satisfied by algebra homomorphism
23:54:48 <hackrilege> omg
23:54:49 <EvanR> which is jsut one of these f . eval = eval . fmap f
23:54:58 <cocreature> or if you prefer pictures https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/F_algebra.svg/188px-F_algebra.svg.png
23:55:02 <EvanR> (two different evals, one for each algebra)
23:55:32 <hackrilege> wait wait wait
23:55:38 <hackrilege> none of this makes any sense
23:55:42 <EvanR> yes that picture
23:55:55 <hackrilege> thats a square with some squiggles
23:56:19 <hackrilege> looks like applicative anyhow
23:56:23 <hackrilege> with that F(f)
23:56:42 <EvanR> functor
23:57:24 <hackrilege> hmm
23:57:29 <cocreature> α and β correspond to eval in EvanR’s equation
23:57:32 <hackrilege> fmap /= F(f)
23:57:45 <cocreature> f is some function A -> B
23:57:46 <EvanR> fmap f = F(f)
23:57:51 <cocreature> (or some arrow in general)
23:58:05 <hackrilege> :t fmap
23:58:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:58:48 <hackrilege> is not Functor f => (a -> b) -> f (a ->b)
23:59:06 <EvanR> what, thats coalgebra
23:59:11 <EvanR> or something
23:59:16 <hackrilege> :t (<$>)
23:59:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
