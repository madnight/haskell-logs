00:09:56 * hackagebot Earley 0.11.0.1 - Parsing all context-free grammars using Earley's algorithm.  https://hackage.haskell.org/package/Earley-0.11.0.1 (OlleFredriksson)
00:14:56 * hackagebot werewolf-slack 0.3.0.2 - A Slack chat client for playing werewolf  https://hackage.haskell.org/package/werewolf-slack-0.3.0.2 (hjwylde)
01:15:04 <numee> why are lens' fields for accessing tuple elements are 1-based (_1 for a first element) instead of 0-based?
01:16:02 <puregreen> numee: maybe because “fst” -> “first” -> “1st” -> “1”
01:21:15 <pand> So how about them fsociety?
01:25:29 <numee> puregreen: that might be ... but i believe every indices should be 0-based. it should be only when counting that a number starts from 1 rather than 0.
01:26:16 <adarqui> cool story.. sorry hehe
01:27:19 <puregreen> I don't think it's such a big deal
01:27:39 <puregreen> I could get used even to indexes starting from -2, I guess
01:28:48 <puregreen> and 1-based indexes are used in lots of places
01:30:24 <numee> yeah, many people make the mistake I think. but it's a huge problem to me and i suspect this is the primary reason why I've never used Lua.
01:31:03 <orion> Should libraries provide NFData instances for their types?
01:31:16 <puregreen> numee: well, the very fact that so many people make the mistake and live just fine with it suggests that it's not a problem for them :)
01:31:36 <puregreen> who knows, maybe their brains are wired differently
01:31:58 <supki> numee: I think Edward borrowed the _N convention from Scala
01:33:05 <puregreen> orion: Text and ByteString provide them
01:33:22 <puregreen> orion: so do things from containers
01:33:46 <puregreen> orion: so does aeson
01:33:59 <puregreen> however, I know that some things don't
01:34:09 <puregreen> so... I guess it's not mandatory but it still would be nice
01:36:10 <jle`> it's good practice to provide NFData, i think
01:36:16 <jle`> it's sort of expected from libraries
01:36:24 <jle`> it doesn't hurt because deepseq comes with GHC
01:40:13 * hackagebot werewolf-slack 0.3.0.2 - A Slack chat client for playing werewolf  https://hackage.haskell.org/package/werewolf-slack-0.3.0.2 (hjwylde)
01:40:13 * hackagebot hedis 0.8.0 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.8.0 (k_bx)
01:48:18 <Gurkenglas> Can finding the closure on an operation and a set be reduced to a graph problem?
01:48:54 <Gurkenglas> (Imagining something like finding a witness of an element being in that closure to finding a reachability witness in a graph)
01:50:50 <malade_mental> Hi everybody
01:55:34 <orion> Hi Dr. Nick!
01:55:37 * hackagebot servant 0.6 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.6 (SoenkeHahn)
01:55:39 * hackagebot servant-server 0.6 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.6 (SoenkeHahn)
01:55:41 * hackagebot servant-client 0.6 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.6 (SoenkeHahn)
01:55:43 * hackagebot servant-cassava 0.6 - Servant CSV content-type for cassava  https://hackage.haskell.org/package/servant-cassava-0.6 (SoenkeHahn)
01:55:45 * hackagebot servant-docs 0.6 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.6 (SoenkeHahn)
02:00:47 * hackagebot servant-foreign 0.6 - Helpers for generating clients for servant APIs in any programming language  https://hackage.haskell.org/package/servant-foreign-0.6 (SoenkeHahn)
02:00:49 * hackagebot servant-js 0.6 - Automatically derive javascript functions to query servant webservices.  https://hackage.haskell.org/package/servant-js-0.6 (SoenkeHahn)
02:00:51 * hackagebot servant-blaze 0.6 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.6 (SoenkeHahn)
02:00:53 * hackagebot servant-lucid 0.6 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.6 (SoenkeHahn)
02:00:55 * hackagebot servant-mock 0.6 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.6 (SoenkeHahn)
02:05:17 <lpaste> malade_mental pasted “recursive fibo try” at http://lpaste.net/158413
02:06:48 <malade_mental> I would know if it's possible to assume r1 = 0 and r2 = 1 ?
02:07:48 <jle`> well, you could define foo n = nthFibo n 0 1
02:08:01 <jle`> and have people call foo instead
02:08:24 <malade_mental> ok that's what I though jle` 
02:09:06 <lpaste> jle` annotated “recursive fibo try” with “recursive fibo try (annotation)” at http://lpaste.net/158413#a158414
02:09:31 <jle`> malade_mental: people often hide things like this as helper functions, like ^^
02:09:56 <lpaste> malade_mental pasted “recursive sum of even fibo try” at http://lpaste.net/158416
02:10:06 <jle`> oops, excuse my typo, that should be "go" on the last line
02:11:20 <malade_mental> oh yeah that's a nice way to do this
02:11:40 <malade_mental> now about the second paste I wrote. I know it's not the point of the channel but somebody may help
02:12:12 <malade_mental> I have good results until testing "problem2 92"
02:12:48 <malade_mental> oh sorry I got it
02:15:57 <orion> Ok, so if deriving NFData in your library is fine, what about Arbitrary?
02:28:27 <Gurkenglas> Does some library do efficient calculation of the closure of an operation?
02:28:36 <Gurkenglas> (and a set)
02:46:04 <malade_mental> http://lpaste.net/158417
02:46:46 <malade_mental> can somebody tell me if I'm doing right (the results are good but I'm wondering what I can improve in the syntax)
02:48:02 <malade_mental> (i'm a total noob in haskell programming though)
02:48:45 <Walther> maximum might be a function name
02:49:11 <Gurkenglas> First, you are doing a so-called left fold, where you carry an accumulator down through your recursive calls. You can turn that into a right fold, where you modify the result of a recursive call without it knowing what the current accumulator was, because it doesn't need to know
02:49:41 <Gurkenglas> maximum being a function name is fine, local names shadow global ones, unless you think that could cause confusion to readers
02:49:56 <Walther> huh, TIL
02:50:08 <bernalex> :t maximum
02:50:09 <lambdabot> (Ord a, Foldable t) => t a -> a
02:50:53 <Gurkenglas> second, lines 7 and 8 look almost identical, you could try factoring out some of that common code
02:51:40 <bernalex> it's just essentially foldr1 max. but it's a bad function, and you shouldn't use it.
02:52:07 <Gurkenglas> Why's it bad?
02:52:12 <malade_mental> Gurkenglas: thanks for your advice, I just don't understand how to turn this into a "right fold"
02:52:14 <bernalex> > foldr1 max []
02:52:16 <lambdabot>  *Exception: Prelude.foldr1: empty list
02:52:17 <bernalex> > maximum []
02:52:19 <lambdabot>  *Exception: Prelude.maximum: empty list
02:52:31 <malade_mental> I think I can remove the "n" variable though
02:52:55 <Gurkenglas> Oh right, didn't even notice, you never use it :D
02:53:32 <malade_mental> yes, and could I remove the "r" variable ?
02:53:36 <Gurkenglas> malade_mental, the recursive call doesn't need to know what the current sum is to figure out what to add to it. If you make it tell you what to add to the current sum, you can do the addition yourself
02:53:53 <malade_mental> yes that'ts exactly what I wanted
02:55:01 <Gurkenglas> So try writing go such that it returns the sum of the current fibonacci term up to 4000000, instead of what it currently does.
02:56:33 <malade_mental> yes but the problem is that it needs to avoid odd fibonacci numbers
02:56:41 <malade_mental> that's why I keep "r"
02:56:53 <Grisha> hi everyone
02:57:04 <liste> hi Grisha !
02:57:24 <Gurkenglas> Why do you need r to make go return the sum of the even fibonacci numbers between the current one and 4 million?
02:57:27 <Grisha> I've got a very strange problem with a two-line piece of code: sq x = x*x; s = sq
02:57:54 <Grisha> tye types of sq and s doesn't match, the type of s being forced to Integer -> Integer
02:57:54 <malade_mental> Gurkenglas: It's just an exercise from project euler
02:57:58 <Gurkenglas> I know
02:58:14 <malade_mental> ^^
02:58:14 <arahael> Grisha: Whats the type of sq?
02:58:27 <Gurkenglas> @where MMR
02:58:27 <lambdabot> https://wiki.haskell.org/Monomorphism_restriction
02:58:38 <Gurkenglas> Grisha, that
02:58:40 <Grisha> sq :: Num a => a -> a
02:59:48 <Grisha> Gurkenglas, thanks a lot
03:03:04 <malade_mental> Gurkenglas: http://lpaste.net/158420 that's what I wrote before writing problem2
03:03:15 <Grisha> Gurkenglas, that's indeed subtle
03:04:01 <Gurkenglas> malade_mental, once you tire of these incremental steps I can paste a short solution for problem 2 ^^
03:04:16 <malade_mental> ok ;)
03:04:22 <orb_> malade_mental: by the way, you can solve that problem with pen-and-paper and without any recursion / iteration.
03:04:36 <Gurkenglas> malade_mental, yep thats a right fold. You can modify this to fit for problem 2 without much trouble
03:04:55 <orb_> There's a closed form solution.
03:09:57 <malade_mental> Gurkenglas: what's a right fold?
03:10:23 <Gurkenglas> @src foldl
03:10:23 <lambdabot> foldl f z []     = z
03:10:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:10:26 <Gurkenglas> @src foldr
03:10:26 <lambdabot> foldr f z []     = z
03:10:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:10:27 <malade_mental> orb_: I already found the solution, what I want is to improve the syntax so I learn new techniques
03:10:38 <Gurkenglas> Notice how the l one has the recursive call on the outside.
03:10:45 * hackagebot hylogen 0.1.0.0 - glsl edsl  https://hackage.haskell.org/package/hylogen-0.1.0.0 (sleexyz)
03:11:22 <Gurkenglas> Want a hint about the modification for prob1 -> prob2?
03:11:26 <malade_mental> Gurkenglas: Oh yeah I read about this!
03:11:28 <malade_mental> no no
03:11:42 <malade_mental> It's like to avoid doing guards?
03:12:23 <Gurkenglas> If you told me to do the modification with as little change as possible, there wouldn't be any additional guards, though this sentence may strike you as deceiving if I showed you the modification
03:13:58 <Gurkenglas> The modification would consist of an adding of numberoftokens tokens to the code, where that is a variable lambdabot knows and you can look it up in /query lambdabot if you dont want me to know :P
03:13:59 <malade_mental> Gurkenglas: hehe, that's what I thought, that's why I'm learning step by step ^^
03:14:51 <Gurkenglas> (A token is a character sequence without whitespace in between.)
03:15:28 <malade_mental> about the folding, what means (x:xs) ??
03:16:54 <Gurkenglas> "foldr f z (x:xs) =" <- "If the third argument to foldr has the form (x:xs) [can be written as 'one value x, followed by a list of values xs'], then the result shall be defined as follows"
03:17:51 <malade_mental> ok so this doesn't really matter in the example
03:18:30 <malade_mental> and foldr and foldl do the same??
03:19:10 <Gurkenglas> > foldr f z [a, b, c, d, e, f]
03:19:12 <lambdabot>  f a (f b (f c (f d (f e (f f z)))))
03:19:14 <Gurkenglas> > foldl f z [a, b, c, d, e, f]
03:19:15 <lambdabot>  f (f (f (f (f (f z a) b) c) d) e) f
03:20:03 <malade_mental> ok I begin to get it ^^
03:24:31 <malade_mental> Gurkenglas: so you say I can modify the fiboSum function I wrote to fit problem 2 by changin left fold to right fold and by adding somes tokens?
03:24:43 <malade_mental> I think that's a big hint 
03:24:45 <malade_mental> ^^
03:25:27 <Gurkenglas> The difference between your problem 2 solution and the next incremental modification I would make is the direction of the fold, and the difference between your problem 1 solution and that is a few tokens
03:25:45 * hackagebot hylogen 0.1.0.1 - a tiny EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.1 (sleexyz)
03:26:50 <Gurkenglas> And now you can do "> modhint" in a lambdabot query to get a hint to that few-token modification, or "> length modhint" for a hint about the hint
03:26:53 <malade_mental> so in problem 1 I already have the fold to the right if I understand whel
03:26:56 <malade_mental> well*
03:27:22 <malade_mental> ok I'm gonna ask lambdabot 
03:27:56 <Gurkenglas> Gah, if you're gonna *tell* me that you're gonna ask lambdabot, you can just ask me, I told lambdabot to tell it to people who want to know it so you don't have to have me know you asked :D
03:29:12 <malade_mental> Gurkenglas: lol so I totally failed the test 
03:29:53 <ntnt> I know that I can do "data Foo a = Cat | Dog [a]" ... however, is it possible to do "data Foo = Cat | forall a. Dog [a]" ?
03:30:19 <Gurkenglas> It wasn't even a test! I just assumed you wouldn't fail :P
03:31:02 <liste> ntnt: you can have a "data Horse = forall a. Horse a" and "data Foo = Cat | [Horse]" -- though you can't do anything with Horses
03:31:04 <malade_mental> you underestimate some people skill for failure ;)
03:31:14 <maerwald> ntnt: {-# LANGUAGE ExistentialQuantification #-}
03:31:30 <ntnt> liste , maerwald: interesting, thanks
03:31:44 <Gurkenglas> Okay, so I'm free to speak of the hint now, right?
03:31:44 <liste> ntnt: maybe you can do the sum type you suggested too, haven't tried it
03:31:54 <liste> (both require ExistentialQuantification though)
03:32:30 <malade_mental> Gurkenglas: I just asked to lambdabot and now I get it better
03:32:55 <liste> ntnt: note that existentials aren't as useful as people seem to think
03:33:08 <ntnt> yeah
03:33:13 <ntnt> I'm starting to question why I want this at all
03:33:28 <maerwald> not everything that compiles is useful, yeah :P
03:33:51 <ntnt> maerwald: dynamic languages proved taht a long time ago
03:34:13 <maerwald> ntnt: that goes for any language though
03:35:17 <malade_mental> Gurkenglas: I'm gonna try to write that solution and will get back after this
03:36:52 <maerwald> EvanR: btw... I hit an interesting bug yesterday where my own 'realpath' binding didn't use any specific String encoding and messed up umlaut like ä. Now I use 'getFileSystemEncoding' from GHC.IO.Encoding, but I'm not sure how reliable that is
03:38:54 <EvanR> what manner of wizardry...
03:38:56 <Gurkenglas> Can finding the closure on an operation and a set be reduced to a graph problem?
03:39:10 <maerwald> I'm worried that I use reliable filepath manipulation if I switch to ByteString
03:48:11 <malade_mental> Gurkenglas: I found the solution of the Euler problems on the haskell wiki...
03:48:45 <malade_mental> they uses pretty techniques
03:48:59 <malade_mental> but I think I need to train more with the book
03:49:16 <Gurkenglas> Want my solution?
03:50:34 <malade_mental> yup 
03:51:03 <malade_mental> I began coding in haskell yesterday and am more used to things like PHP or JS... 
03:51:23 <Ongy> Hi I was reading through how the time stuff is implemented in haskell and notized this: https://hackage.haskell.org/package/time-1.6/docs/src/Data-Time-Format.html#line-163 how does this work? to my understanding the (formatCharacter c) should never first return Nothing and in the branch of the case/of Just x
03:51:24 <malade_mental> So any advice or guide to read is good ^^
03:51:30 <Gurkenglas> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum $ filter even $ takeWhile (<=4000000) fibs -- malade_mental 
03:51:32 <lambdabot>  4613732
03:53:09 <malade_mental> I would never find this 
03:54:33 <malade_mental> Thanks a lot for your time ;)
03:58:19 <srhb> Ongy: Uh, yes, that looks very strange.
03:59:23 <Ongy> the instance for ZonedTime does the same
04:00:46 * hackagebot tidal 0.7.1 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.7.1 (AlexMcLean)
04:01:26 <haskell885> ?src ($)
04:01:26 <lambdabot> f $ x = f x
04:03:01 <srhb> Ongy: The specific commit appears related to indentation fixing. Wonder if it's some sort of automatic mistake.
04:03:41 <srhb> Ongy: Oh, no, the line was just touched then. Derp.
04:04:31 <Peaker> > let fibs = map fst (iterate (\(cur, next) -> (next, cur+next)) (0, 1)) in sum $ filter even $ takeWhile (<=4000000) fibs -- no direct self-reference
04:04:32 <lambdabot>  4613732
04:15:51 * hackagebot hw-succinct 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.1 (newhoggy)
04:15:53 * hackagebot react-tutorial-haskell-server 1.0.0 - react-tutorial web server  https://hackage.haskell.org/package/react-tutorial-haskell-server-1.0.0 (alexander)
04:21:02 * hackagebot hylogen 0.1.0.2 - a tiny EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.2 (sleexyz)
04:28:49 <eikke> Hmh. I have some code which I parallellized using the `parallel-io` package, but now when I run a benchmark with -N1/2/4, the runtime is always +- the same, and checking with eventlog/threadscope does show all HECs are in 100% use during that timespan ^o) so somehow I need 2 or 4x the amount of CPU resources to get the same task done in the same timespan?!
04:30:52 <Peaker> hey merijn, what ever happened to the bracket debacle?
04:36:02 * hackagebot matcher 0.1.1.2 - A composable abstraction for checking or converting a context value  https://hackage.haskell.org/package/matcher-0.1.1.2 (NikitaVolkov)
04:46:38 * hackagebot interspersed 0.1.0.1 - An abstraction over interspersing monadic actions  https://hackage.haskell.org/package/interspersed-0.1.0.1 (NikitaVolkov)
04:46:40 * hackagebot supplemented 0.5.0.1 - Attoparsec extension for early termination  https://hackage.haskell.org/package/supplemented-0.5.0.1 (NikitaVolkov)
04:46:42 * hackagebot supplemented 0.5.0.2 - Early termination for monads  https://hackage.haskell.org/package/supplemented-0.5.0.2 (NikitaVolkov)
04:46:44 * hackagebot unsequential 0.5.0.2 - An extension removing the sequentiality from monads  https://hackage.haskell.org/package/unsequential-0.5.0.2 (NikitaVolkov)
04:51:38 * hackagebot json-incremental-decoder 0.1.0.3 - Incremental JSON parser with early termination and a declarative DSL  https://hackage.haskell.org/package/json-incremental-decoder-0.1.0.3 (NikitaVolkov)
04:51:40 * hackagebot solr 0.2.1.5 - A minimal Solr client library  https://hackage.haskell.org/package/solr-0.2.1.5 (NikitaVolkov)
05:08:44 <magthe> silly question, I need an answer to shut a friend up ;) how do I write `\ a b c d -> a + b + c + d` in a point free style?
05:09:44 <ahihi> @pl \ a b c d -> a + b + c + d
05:09:44 <lambdabot> ((((+) .) . (+)) .) . (+)
05:09:48 <ahihi> enjoy
05:10:08 <magthe> ahihi: thanks :)  I do see a pattern in there
05:10:48 <srhb> magthe: If you got rid of the sections it would looks slightly more structured. You could search for semantic editor combinators
05:16:55 * hackagebot json-encoder 0.1.6 - A direct-to-bytes single-pass JSON encoder with a declarative DSL  https://hackage.haskell.org/package/json-encoder-0.1.6 (NikitaVolkov)
05:17:58 <ertes> @pl \a b c d -> a + (b + (c + d))
05:17:58 <lambdabot> (. ((. (+)) . (.) . (+))) . (.) . (.) . (+)
05:18:55 <ertes> the thin line between pointfree and pointless
05:41:56 * hackagebot http-response-decoder 0.2.1.1 - Declarative DSL for parsing an HTTP response  https://hackage.haskell.org/package/http-response-decoder-0.2.1.1 (NikitaVolkov)
05:49:53 <Aruro> anybody had problem with ghc-mod complaining about getArgs? :) tells that System.Environment does not export getArgs :D
05:50:27 <ertes> i have an abstraction F that allows solutions to be built by composition…  it's not the abstraction itself that composes, but it provides composition…  is it correct to say that "F is compositional"?  or is "composable" the better adjective?
05:51:56 * hackagebot matcher 0.1.1.3 - A composable abstraction for checking or converting a context value  https://hackage.haskell.org/package/matcher-0.1.1.3 (NikitaVolkov)
05:52:19 <ertes> hehe…  well timed
05:52:53 <ertes> though i still think that "composable" is not quite the right word
05:53:57 <Aruro> for math composable is too broad term
05:54:14 <Aruro> thought composable word does exist 
05:55:01 <ertes> my understanding is that "F is composable" suggests that F composes, which is not what i want to imply
05:55:56 <ertes> example:  you have a monoid M, which doesn't give rise to any morphisms to other interesting monoids, so it would be misleading to call M "composable", i think…  but it is compositional in the sense that values of M are built by composition
05:56:02 <Aruro> composable is not used in any modern enciclopedia, they use composes and such
05:56:15 <Aruro> encyclopedia*
05:56:25 <ggVGc> is there a better way to write this?   >>> maybe Nothing (\z -> if endp z then Nothing else Just z)
05:56:46 <ertes> ggVGc: see 'guard'
05:56:49 <ertes> :t guard
05:56:50 <lambdabot> Alternative f => Bool -> f ()
05:57:19 <ertes> > do guard (2 > 3); Just "yeah"
05:57:21 <lambdabot>  Nothing
05:57:25 <ertes> > do guard (4 > 3); Just "yeah"
05:57:26 <lambdabot>  Just "yeah"
05:57:30 <Aruro> ertes: i would just put explanation of what u mean, u are forced to be confined just to one word?
05:58:27 <ertes> Aruro: this is for a package description, and the audience is a haskell programmer, so yeah, a well-understood buzzword should suffice ("read the module doc for more info")
05:58:57 <Aruro> ertes: i like big synopsis :)
05:59:54 <Aruro> above example of just posted lib to hackage was good example, what was composable there? i did not get.
06:00:08 <Aruro> because it was just one sentence of buz.
06:00:17 <ertes> Aruro: this is the current intro paragraph:  "This library provides compositional abstractions and primitives for constructing machine learning problems, and algorithms for solving them."
06:02:05 <ggVGc> ertes: hm, I'm not sure how to use it.. How would i rewrite this with guard? https://gist.github.com/e47a72a0c736eece01607347bb229c70
06:02:08 * hackagebot hasql-transaction 0.4.4 - A composable abstraction over the retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.4.4 (NikitaVolkov)
06:02:10 * hackagebot hasql-pool 0.4.1 - A pool of connections for Hasql  https://hackage.haskell.org/package/hasql-pool-0.4.1 (NikitaVolkov)
06:02:31 <Aruro> ertes: nice, i like it, thought im not sure composability is big need here, seems many haskell libs do that?
06:03:01 <Aruro> ertes: i mean in haskell ecosystem composability is something of granted? 
06:03:25 <Aruro> ertes: This library  provides compositional abstractions and primitives for  constructing machine learning problems, and algorithms for  solving them.
06:03:34 <ertes> ggVGc: oh, (>>>) was supposed to be an operator…
06:03:34 <ggVGc> Aruro: probably highly depends on what type of problem the library deals with
06:03:50 <Aruro> ertes: sry did not make edit
06:03:51 <ggVGc> some problem domains are inherently composable
06:03:54 <ggVGc> some reallya re not
06:05:18 <ertes> ggVGc: maybe Nothing (\x -> if p x then Nothing else Just x) = (>>= \x -> guard (not (p x)) >> pure x)
06:05:30 <ertes> :t \p -> (>>= \x -> guard (not (p x)) >> pure x)
06:05:31 <lambdabot> (Monad m, Alternative m) => (b -> Bool) -> m b -> m b
06:05:46 <Aruro> ertes: This library provides abstractions and primitives for constructing machine learning problems, and algorithms for solving them. (i would give few actual algorithms/concepts implemented)
06:06:04 <ertes> Aruro: i see composition patterns *within* machine learning primitives
06:06:51 <ertes> example:  you have a linear combination predictor (take the linear combination of a feature vector with a weight vector)
06:07:04 <ertes> stick on a logistic function, and you've got logistic regression
06:07:10 <ggVGc> ertes: cool, thanks
06:07:21 <ertes> stick on a softmax function, and you've got multinomial logistic regression
06:07:48 <ertes> stick on a logistic function and another linear layer, and you've got a neural network
06:07:51 <ggVGc> wha do I stick on to make my machine learn music production?
06:07:54 <ertes> etc.
06:08:16 <ertes> Aruro: also the hackage landscape of machine learning packages…  to put it gently…  sucks
06:08:50 <ertes> whenever i see another machine learning library that takes lists of lists as inputs i want to throw up
06:08:55 <ggVGc> Ive been wanting to use a neural network to generate interesting music samples from a user supploed pool of "good sounds"
06:09:02 <ggVGc> butr I have no idea where to start
06:09:20 <ertes> ggVGc: you'll probably have more luck with a markov-based model
06:09:23 <Aruro> ertes: This library uses composition patterns within/betwenn/on machine learning primitives? seems good sentence for syn
06:09:33 <ggVGc> ertes: why is that?
06:09:36 <Aruro> ertes: ? removed
06:09:37 <ggVGc> I mean, that makes sense
06:09:42 <ggVGc> but why do you think it would be better?
06:10:03 <ertes> Aruro: to train a neural network you need a measure of quality…  it's difficult to extract such a measure from music
06:10:31 <ggVGc> ertes: I was thinking it would be manually trained
06:11:10 <Aruro> ertes: This library uses composition patterns within/betwenn/on machine learning primitives to construct machine learning problems and provieds algorithms for solving them.
06:11:29 <ertes> ggVGc: then you're not really *learning* anything…  you're just using a formula with tweaked parameters =)
06:11:43 <ggVGc> yeah, fair
06:11:50 <ggVGc> so markov chains is maybe more reasonable
06:12:02 <ertes> ggVGc: you'd probably end up with a genetic algorithm or simulated annealing to produce anything useful with an ANN
06:12:14 <ggVGc> ertes: I was just inspired by that google experiment where eyes started appearing in pictures, and wanted to do something similar for music
06:12:33 <ertes> and you need to be very patient, because it i'd expect that it takes a long time to figure out how to train the ANN meaningfully
06:12:34 <ggVGc> not music really, but sounds
06:12:41 <ggVGc> abstract "cool sounding" samples
06:13:00 <ertes> ggVGc: that "eye" example has little to do with traditional neural networks
06:13:18 <ggVGc> how coould I do something similar with audio?
06:13:32 <ertes> they are using layers of restricted boltzmann machines for unsupervised learning
06:13:48 <ertes> it's a great technique, but takes time and patience to learn
06:14:10 <ertes> (searching for "deep learning" or even just "geoffrey hinton" usually gets you some useful results)
06:14:32 <ertes> you can apply the same technique to audio, if you can isolate the patterns
06:14:59 <ertes> Aruro: thanks for your help =)
06:15:25 <Aruro> ertes: np, nice that u are making new machine learning library
06:16:05 <ertes> ggVGc: the idea is actually very simple: you show such a network pictures of dogs, and nothing else…  so all the network understands is dogs
06:16:07 <ggVGc> ertes: do you know of any framework/tookit that has implementations for algorithms that would be useful to me in this? I obviously need to read up on theory to know what to build, but I'd rather not implement machine learning algorithms right now
06:16:39 <ertes> then you show a picture of a human…  the network tries to see dogs, because that's the only thing it understands…  and then you evaluate what the network "sees" ("dreams of")
06:16:45 <Aruro> ggVGc: maybe starting to implement algorithms is good idea :) u will get what it is
06:17:08 <ertes> with audio it would work like this:  you train it on many examples of rock music
06:17:10 * hackagebot json-pointer 0.1.2 - JSON Pointer parsing and interpretation utilities  https://hackage.haskell.org/package/json-pointer-0.1.2 (NikitaVolkov)
06:17:12 <ertes> then you show it hip-hop
06:17:24 <ggVGc> ertes: right, that's exactly what I wanted to do. I want to train the network on soudns that I find interesting. feed it arbitrary "boring" sounds and see what it extracts
06:17:44 <ertes> ggVGc: there are no ready-made haskell libraries for this
06:17:56 <ertes> and writing them will take a long time, a large amount of which will be learning
06:18:32 <ertes> also for audio in particular you probably need auxiliary libraries and knowledge as well, such as good FFT libraries
06:18:44 <ertes> (i believe there is a well maintained FFTW binding)
06:19:07 <ertes> i don't want to discourage you…  just be prepared to spend a long time to get there =)
06:19:53 <ggVGc> ertes: hm, this is the google experiment eh? https://github.com/google/deepdream
06:20:03 <ggVGc> think I could adapt it to audio easily?
06:21:17 <ertes> i think you can adapt it, but probably not *easily*
06:21:56 <ertes> machine learning is not a very formal field…  a lot of it is experimentation: "do this, see what happens"
06:22:01 <ertes> and most of the time nothing happens =)
06:22:10 * hackagebot json-pointer-hasql 0.1.1 - JSON Pointer extensions for Hasql  https://hackage.haskell.org/package/json-pointer-hasql-0.1.1 (NikitaVolkov)
06:23:04 <Aruro> ggVGc: to be honest there is not much variation in this art, same possibly can be achieved with simple filters
06:24:26 <ertes> i'm actually planning to implement RBMs together with their learning algorithm, but don't hold your breath…  currently simple linear models and feed-forward networks are the most useful predictors for me
06:25:01 <ertes> RBMs are mostly useful for classification of "organic" data like face detection and OCR
06:25:51 <ggVGc> Aruro: waht do you mean by that?
06:26:12 <Jinxit> we need a deep learning framework in haskell IMO
06:26:14 <Jinxit> :D
06:26:47 <rydgel> Jinxit: I'm not sure, won't we build Skynet by accident?
06:26:48 <ertes> Jinxit: i wouldn't mind if someone contributes the code…  it would fit nicely into the framework =)
06:27:05 <Jinxit> is yours public ertes?
06:27:22 <Aruro> ggVGc: i mean that there is just big funciton there which effectively is some sort of image modifier :)
06:27:29 <ertes> Jinxit: very soon…  probably tomorrow
06:27:39 <Jinxit> and what kind of models do you have?
06:27:39 <Aruro> ggVGc: not some big deep learning result
06:28:02 <ertes> rydgel: are you kidding?  we already have skynet, but we call it facebook and google
06:28:20 <Jinxit> the US military actually has a program called skynet lol
06:28:24 <ertes> they already decide who we meet and who we marry…  might as well contribute some of our own skynets =)
06:28:49 <ertes> and a few years later AM destroys the planet =)
06:28:56 <Gurkenglas> Can finding the closure on an operation and a set be reduced to a graph problem?
06:29:29 <Jinxit> isn't it a directed cyclic graph?
06:30:03 <ertes> Jinxit: the first models are linear combination, logistic and softmax along with horizontal and vertical composition
06:30:23 <Jinxit> horizontal and vertical composition?
06:30:31 <ertes> Jinxit: that gives you linear regression, (binary/multinomial) logistic regression and neural networks
06:30:34 <Jinxit> regardless; send me a ping when you go public, I'd love to check it out
06:31:01 <ertes> Jinxit: often you want to have two side-by-side layers in a neural network, for example when doing NLP
06:31:48 <Jinxit> ah yes, like (a . b) . (c . d)
06:32:09 <ertes> more like vertical and horizontal composition in diagrams
06:32:23 <Jinxit> well
06:32:24 <ggVGc> Aruro: well, it's easy to say in retrospect that "I can produce that image with a filter". But the whole point is that it's hard coming up with the image in the first place. What that network is doig is taking something learnt, and seeing which parts of that learning show up within something else unrelated
06:32:28 <Jinxit> they don't necessarily align, do they?
06:32:46 <ggVGc> i.e a building shows up for a tree and a bird shows up for a leaf
06:33:08 <ggVGc> so I want to do that with sounds. If I train a network on raindrops and metal slams, and then give it some classical music
06:33:11 <ggVGc> what do I get?
06:33:35 <ggVGc> maybe a metallic biolin sample
06:33:37 <ggVGc> violin*
06:34:05 <ggVGc> and after I ave heard it, of couse I can reproduce it. But that's only true because we can generate almost any sound given enough inspiration and time
06:34:22 <ggVGc> but that's not interesting since we first have to come up with what to generate
06:37:40 * hackagebot chatty-utils 0.7.3.3 - Some utilities every serious chatty-based application may need.  https://hackage.haskell.org/package/chatty-utils-0.7.3.3 (implementation)
06:37:42 * hackagebot xml-query 0.9.1 - A parser-agnostic declarative API for querying XML-documents  https://hackage.haskell.org/package/xml-query-0.9.1 (NikitaVolkov)
06:37:44 * hackagebot xml-query-xml-conduit 0.3.1 - A binding for the "xml-query" and "xml-conduit" libraries  https://hackage.haskell.org/package/xml-query-xml-conduit-0.3.1 (NikitaVolkov)
06:37:46 * hackagebot xml-query-xml-types 0.4.1 - An interpreter of "xml-query" queries for the "xml-types" documents  https://hackage.haskell.org/package/xml-query-xml-types-0.4.1 (NikitaVolkov)
06:37:48 * hackagebot html-entities 1.1.1 - A codec library for HTML-escaped text and HTML-entities  https://hackage.haskell.org/package/html-entities-1.1.1 (NikitaVolkov)
06:37:54 <xa0> ...
06:38:17 <rydgel> Well Facebook AIs are still pretty dumb for now, we are safe
06:39:36 <Gurkenglas> Jinxit, cyclic? How so?
06:40:52 <Jinxit> a group can have cycles, no?
06:40:54 <Gurkenglas> The difficulty with the naive way of reducing it to reachability is that you need two elements from the set to make a third one, and you can't require both two nodes in a graph to be reachable to get to a third
06:41:07 <Gurkenglas> Jinxit, we are talking about the closure thing right?
06:41:17 <Jinxit> yes, maybe I'm misunderstanding it
06:41:53 <Gurkenglas> We have a set and an operation on that set, and a subset, and want to see what elements of the set can be written in terms of that subset and that operation
06:42:13 <Jinxit> given a single element, find the subset?
06:42:18 <Gurkenglas> sure why not
06:42:39 <Gurkenglas> Like, if the operation is (+) on the naturals and the element is 2, its all the positive even numbers
06:42:41 * hackagebot html-entities 1.1.1.1 - A codec library for HTML-escaped text and HTML-entities  https://hackage.haskell.org/package/html-entities-1.1.1.1 (NikitaVolkov)
06:42:55 <Gurkenglas> (Except that I'm ok with solving it on finite sets)
06:43:15 <Jinxit> (yeah I sorta assumed that)
06:43:21 <Jinxit> let me think, this is pretty interesting
06:44:44 <Jinxit> do you know any small closures in a larger group off-hand?
06:44:50 <ski> Gurkenglas : generated subgroup ?
06:45:12 <Gurkenglas> ski, sure, except that I dont require the operation to satisfy group laws
06:45:54 <ski> but it's a binary operation ?
06:45:59 <mnoonan> It's just graph reachability for a unary operation, so you could always take the union of the edges you get for each partial application of your operator
06:46:18 <Gurkenglas> yep
06:46:29 <Gurkenglas> @ski
06:46:29 <lambdabot> Maybe you meant: wiki src ask
06:46:41 <bennofs> isn't this just fix $ \s -> zip operation s s, where s is a Set?
06:47:01 * ski blinks
06:47:34 <ski> bennofs : don't you mean s/zip/liftM2/ ?
06:47:41 * hackagebot scotty-params-parser 0.5.1 - HTTP-request's query parameters parser abstraction for "scotty"  https://hackage.haskell.org/package/scotty-params-parser-0.5.1 (NikitaVolkov)
06:47:42 <Gurkenglas> I think he means zipWith
06:47:43 <ski> (or something like that)
06:47:46 <bennofs> ski: oh yes
06:48:04 <ski> (there is no `zip'/`zipWith' on sets, no inherent ordering)
06:49:01 <Gurkenglas> But that's not as efficient as good implementations of REACH, so I was hoping to reduce it to a graph problem or something
06:49:07 <Gurkenglas> -s
06:49:32 <Gurkenglas> Also that fix never halts
06:49:47 <Gurkenglas> Because the empty set is a fixpoint and so is the full set
06:52:20 <ski> @type \f s0 s1 -> (S.unions . S.toList) (S.map (\x1 -> S.map (f x1) s0) s1)
06:52:21 <lambdabot> Ord a => (a1 -> a2 -> a) -> S.Set a2 -> S.Set a1 -> S.Set a
06:52:40 <ski> Gurkenglas : yes, you'd have to start with the given subset
06:52:41 * hackagebot hasql-th 0.2.1 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.2.1 (NikitaVolkov)
06:52:43 * hackagebot hasql-optparse-applicative 0.1.1 - "optparse-applicative" parsers for "hasql"  https://hackage.haskell.org/package/hasql-optparse-applicative-0.1.1 (NikitaVolkov)
06:54:46 <Gurkenglas> :t over (_Wrapping S.fromList) . join . liftA2
06:54:47 <lambdabot> (Ord a', Ord a'1) => (a'1 -> a'1 -> a') -> S.Set a'1 -> S.Set a'
06:55:01 <unsafe_forever> in spock is there a way to have an endpoint that returns javascript that's in a text variable instead of a file?
06:55:55 <ski> hm, i wonder why that's not as generic
06:56:30 <ski> (not the extra `Ord' constraint, i mean)
06:57:51 * hackagebot ghc-imported-from 0.3.0.3 - Find the Haddock documentation for a symbol.  https://hackage.haskell.org/package/ghc-imported-from-0.3.0.3 (CarloHamalainen)
06:57:55 <srhb> unsafe_forever: Take a look at the definitions of html, json, etc. and you can just write your own. :)
06:58:20 <unsafe_forever> srhb i was looking for something like html, but with javascript as the content type
06:58:35 <unsafe_forever> it looks like the closest thing is "bytes"?
06:59:08 <srhb> unsafe_forever: Yes, exactly. Just write your own like html, but with the correct content type.
06:59:44 <srhb> unsafe_forever: bytes, json, html... They're all pretty similar. YOu shouldn't be using a ByteString for texty things though.
07:00:16 <unsafe_forever> i'm not sure how to write my own
07:00:25 <unsafe_forever> should i look at the code for html?
07:00:54 <srhb> unsafe_forever: Yep.
07:01:07 <srhb> unsafe_forever: Basically copy its definition and change the content type and name.
07:01:27 <devries> I am trying to convert a Vector Bool to an image with friday (https://github.com/RaphaelJ/friday), but am struggling with the types/instances. 
07:01:38 <unsafe_forever> seems like javascript should be something that's supported already, no?
07:03:04 <srhb> unsafe_forever: I tend to not have an answer for that when the implementation is trivial. I'm more surprised that there isn't a more generic function for sending some Text as some Content type.
07:03:11 <srhb> unsafe_forever: making the js version a oneliner
07:03:42 <unsafe_forever> there's text...but that's for plain
07:03:56 <unsafe_forever> hmm.. maybe i should be using scotty
07:04:27 <srhb> unsafe_forever: Er, based on this?
07:04:36 <unsafe_forever> i avoided servant because i figured being in data-land would be more beginner friendly
07:04:54 <unsafe_forever> srhb well and the general new-ness of spock
07:05:20 <unsafe_forever> scotty has been around a bit longer with more tutorials and examples
07:05:30 <srhb> I guess. :)
07:05:32 <unsafe_forever> spock has been pretty pleasant to use and mostly self explanatory
07:05:45 <srhb> Yes, I think so too.
07:06:15 <unsafe_forever> but i'm learning/using this for work, so i need to have some sense of when i will run into roadblocks
07:06:43 <unsafe_forever> do you know where the html / json / definitions are in the spock source tree? i'm poking around now..
07:08:33 * hackagebot chatty 0.7.0.0 - Some monad transformers and typeclasses for abstraction of global dependencies.  https://hackage.haskell.org/package/chatty-0.7.0.0 (implementation)
07:08:34 <unsafe_forever> oh nevermind think i found it in CoreAction.hs
07:08:59 <unsafe_forever> ah here i'll copy paste Text
07:11:16 <srhb> unsafe_forever: Yeah, exactly. It's trivial to add like that. :)
07:12:06 <unsafe_forever> i find it a bit awkward to structure these additions in a codebase. should i just have it in applicaiton code? as a dedicated module? or fork the whole package?
07:13:15 <devries> anyone has experience with writing Vectors/Lists/Arrays to an image with Haskell. stuff on google and SO is very outdated
07:15:17 <unsafe_forever> it's particularly weird if the "patch" code needs some structure internal to a moduel
07:18:29 <maerwald> what's the best way to create a Word8 literal?
07:18:39 <unsafe_forever> like here i need "setHeaderUnsafe" which is internal to spock
07:21:41 <Gurkenglas> ski, because it combines one set with itself, so there can only be one type in the arguments of the operation
07:22:18 <ski> oops, didn't notice there was only one input set
07:23:14 <unsafe_forever> is there a good way to pull out "internal" functions in a package for external use?
07:25:31 <maerwald> is this safe to convert '/' to Word8?: fromIntegral (ord '/')
07:30:00 <unsafe_forever> srhb hmm copy-pasting this one-liner is leading to a chain of internal dependencies. should i be forking spock instead?
07:33:37 * hackagebot antisplice 0.17.1.1 - An engine for text-based dungeons.  https://hackage.haskell.org/package/antisplice-0.17.1.1 (implementation)
07:33:39 * hackagebot prometheus 0.3.2 - Prometheus Haskell Client  https://hackage.haskell.org/package/prometheus-0.3.2 (LukeHoersten)
07:40:13 <geppettodivacin> maerwald: That looks about right to me. Note that if you give it a character greater than 256 it'll just modulate around 256.
07:42:18 <geppettodivacin> maerwald: However, if you're going to convert a list of Chars to Word8, you might want to consider using the Data.ByteString.Char8 module.
07:43:34 <maerwald> geppettodivacin: I just need the literal
07:43:44 <maerwald> there's no runtime conversion whatsoever
07:44:00 <geppettodivacin> Ah. Well, that'll do it, then.
07:44:35 <nclarke> @pl \x -> (fst x,) <$> snd x
07:44:36 <lambdabot> (line 1, column 13):
07:44:36 <lambdabot> unexpected ","
07:44:36 <lambdabot> expecting variable, "(", operator or ")"
07:45:27 <nclarke> @pl \x -> (\y -> fst x,y) <$> snd x
07:45:27 <lambdabot> uncurry ((<$>) . flip (,) y . const)
07:46:42 <nclarke> @pl \x -> (\y -> (fst x,y)) <$> snd x
07:46:42 <lambdabot> uncurry ((<$>) . (,))
07:48:01 <maerwald> meh, how can I do ByteString in template haskell... the closest I get is StringPrimL, but that is [Word8]
07:48:37 * hackagebot ironforge 0.1.0.36 - A technical demo for Antisplice.  https://hackage.haskell.org/package/ironforge-0.1.0.36 (implementation)
07:55:16 <ertes> Data.ByteString.Char8, the most subtly dangerous module
07:55:33 <geppettodivacin> nclarke: /whois ertes 
07:55:42 <geppettodivacin> Oops.
07:55:43 <maerwald> I don't use Char8
07:55:50 <Jinxit> geppettodivacin: awkward
07:55:58 <ertes> i don't mind =)
07:56:31 <ertes> change to the network window/buffer in the future to avoid that ;)
07:56:37 <geppettodivacin> Tab completion is a weird thing sometimes, especially when combined with odd twitches of the pinky on the right side.
07:57:06 <geppettodivacin> Both were supposed to be in a different buffer on a different network. :P
07:57:12 <nclarke> geppettodivacin: ertes is Ertugrul Söylemez :-)
07:57:37 <Xnuk> Is there any replacement of neco-ghc in vim? 
07:59:44 <Xnuk> It's heavy slow when *.cabal file exists.
08:02:02 <geppettodivacin> nclarke: Thank you! Your services are much appreciated.
08:03:38 * hackagebot antagonist 0.1.0.30 - A web interface to Antisplice dungeons.  https://hackage.haskell.org/package/antagonist-0.1.0.30 (implementation)
08:03:54 <unsafe_forever> anyone able to get julius javascript-based syntax highlighting in emacs haskell-mode?
08:05:56 <nobag> Is anyone here deeply familiar with FRP?
08:09:09 <unsafe_forever> nobag no, only superficially :P
08:10:57 <ertes> nobag: shoot
08:11:19 <Cale> nobag: I'm reasonably familiar, but you'll have to wait, I'm in a meeting
08:11:54 <Tuplanolla> I'd like to be. Does that count?
08:13:25 <hpc> nobag: have you tried asking in #haskell-deeply-familiar-with-frp?
08:13:45 <unsafe_forever> lol
08:13:58 <unsafe_forever> there aren't enough channels for our 100 person community!
08:14:43 <hpc> it's true
08:14:59 <hpc> we actually use #haskell as an encoding for 16 channels, everyone gets 16 sockpuppets and joins here
08:15:07 <hpc> i have all the three-letter nicks
08:15:45 <hpc> #haskell is the largest 100-person channel on freenode
08:15:54 <nitrix> Some accounts are shared, like Cale. This is how he appear so brilliant.
08:16:02 <Cale> haha
08:16:39 <unsafe_forever> i claim all the unclaimed nicks. anytime there's a nick that hasn't been seen before it's me.
08:18:09 <ertes> if only everybody who wrote an "FRP library" would have been "deeply familiar with FRP"
08:18:49 <StoneToad> ertes: isn't that true for all libraries?
08:19:11 <unsafe_forever> ertes aren't we all converging on reflex now?
08:19:36 <nobag> ertes: Cale: I was wondering if any FRP implementations besides Fran have timeTransform. I'm working on functions from Event a -> Event a (changing times in the process), but I didn't find any performant systems actually implementing this
08:20:39 <ertes> nobag: i'm not familiar with that function…  what does it do semantically?
08:21:03 <ertes> (and what would be its type, assuming Event and Behaviour as * -> *?)
08:21:12 <nobag> it's a function on behaviours
08:21:43 <nitrix> Is Netwire an FRP library too? What's the main requirement for FRP; time-varying values?
08:21:56 <nobag> IIRC timeTransform :: Behaviour a -> Behaviour t -> Behaviour a
08:22:23 <nobag> timeTransform ba bt = \t -> ba (bt t)
08:22:25 <ertes> nitrix: the latest version yes, and the requirement is continuous time semantics and discrete event semantics plus first class events (to some degree)
08:22:53 <ertes> nobag: that doesn't look like a function that would be efficient to implement
08:23:02 <nitrix> ertes: Is there a known library that'd just be message-passing? No concept of time but with a similar interface to wires?
08:23:41 <ertes> nitrix: would any of the stream processing libraries be what you're looking for?  conduit, machines, pipes, …
08:23:51 <ertes> or even just FreeT
08:23:56 <Jinxit> nitrix: maybe auto?
08:24:21 <nobag> ertes: indeed, but it can be implemented "efficiently" in "discrete FRP"
08:24:53 <ertes> nobag: how can that be?  it seems like this function requires arbitrary look-back as well as arbitrary look-forward
08:25:10 <nobag> and possibly in real FRP, but I'm just not familiar enough with it
08:25:56 <ertes> nobag: in most FRP systems, at least those that can talk to the real world via IO, behaviours don't use the nice function formula
08:25:56 <unsafe_forever> trying to write lightweight webapps without splitting up the codebase into frontend backend. So far sortof it's sortof working with a Julius + Spock combo...
08:26:39 <ertes> nobag: they behave more like automata, and there is no way to ask for past values unless you specifically keep them around
08:26:54 <nobag> ertes: yes, that's what I've found
08:26:58 <ertes> and to ask for future values you would actually have to wait for that point in time to be reached
08:27:15 <nitrix> ertes: Great, I'll have a look :)
08:27:34 <ertes> nobag: so while FRP semantics allows that combinator, it's very unlikely that you'll find a library that implements it
08:27:58 <nobag> ertes: I'm giving access to Time, but you cannot create your own values of Time
08:28:34 <nobag> ertes: that way the runtime knows which values to keep around
08:29:45 <ertes> nobag: yeah, you can do that, though i wouldn't build it into the framework…  that's a recipe for inefficiency
08:29:47 <nitrix> GHC 8.0 april 15th! :]
08:30:05 <nitrix> So hyped up. They did some amazing work.
08:30:17 <ertes> nobag: instead you could perhaps achieve this with a different kind of combinator…  something more ad hoc
08:31:08 <ertes> withPast :: Behaviour a -> Behaviour (a, Time -> a)  -- something like that, but engineered in such a way that the combinator knows which values to keep
08:32:31 <nobag> ertes: I'm not sure I understand the semantics of withPast
08:33:28 <ski>   withPast b t = (b t,b)  -- ?
08:33:48 <ertes> nobag: semantically:  withPast b = \t -> (b t, \t' -> b (t' - t))  -- something like that
08:34:29 <ski> hm, so should be s/Time/TimeDiff/ ?
08:34:58 <ski> hm, no, doesn't make sense either
08:35:07 <ertes> something like that…  in most cases you wouldn't have an absolute notion of time internally anyway
08:35:30 <unsafe_forever> has anyone considered a purescript quasiquoter for haskell? would that be too confusingly insane?
08:35:41 <ski> well, time differences are absolute :)
08:36:07 <ertes> ski: yeah, and those can be implemented without forcing absolute time =)
08:36:10 <nobag> ertes: the system I'm implementing actually breaks causality
08:36:27 <ertes> nobag: as in looking into the future?
08:36:34 <ski> ertes : yes. my point is that it's probably a good idea to distinguish relative and absolute time
08:36:48 <nobag> ertes: we came up with it for use cases which require reordering events
08:36:52 <ertes> ski: fair
08:37:23 <ski> (where, confusingly, it's the relative time which is absolute ;)
08:37:58 <nobag> ertes: indeed
08:38:12 <unsafe_forever> oh man composable monadic route specs in Spock are really handy
08:38:57 <ertes> nobag: well, you can get away with that, as long as you never need to *run* the system =)
08:39:21 <nobag> ertes: haha
08:39:24 <ertes> it totally works for computing events and such with no relation to physical time
08:39:50 <ertes> and in those cases you can probably just use the functional FRP model:  type Behaviour = (->) Time
08:39:54 <nobag> ertes: the system does actually run, but if you depend on future values your output changes when these suddenly become available
08:40:09 * ski . o O ( "simulations" )
08:40:34 <ertes> nobag: uhm…  in the sense that you get e.g. Nothing until the point in time has been reached?
08:40:37 <nobag> ertes: which is a bit messy but I think there are ways to deal with this
08:41:53 <nobag> ertes: not exactly
08:42:12 <ertes> nobag: netwire allows signal "inhibition" in that it simply doesn't produce, and it can even switch systems based on that…  "exception intervals" in a sense
08:42:17 <ertes> but don't use netwire
08:42:56 <ertes> feel free to take inspiration for your own project, but currently i don't recommend its usage
08:44:13 <nobag> consider foo :: Event Int -> Event Int, foo es = if (member 3 $ map snd es) then [(1,99)] else []
08:44:55 <EvanR> ertes: agreed causality is boring
08:45:11 <nobag> ertes: and then you use (wonkyEvent = foo otherEvent) in your program
08:46:41 <EvanR> signals being conceptually streams of Nothing punctuated by Just never really made sense to me
08:47:52 <nobag> ertes: our system recomputes the value at "now" in case wonkyEvent suddenly changes, e.g. due to a value at t < now in otherEvent becoming available and being equal to 3, making the output of the program change
08:47:56 <MarcelineVQ> How about a Either with stream of something and a bool to let you know if it's okay to observe the something? :>
08:48:54 <EvanR> nobag: i wonder how practical that is relative to "acausality error"
08:50:07 <ski> MarcelineVQ : oh, the bool announces the arrival of the value in the next frame ? clever
08:53:19 <ertes> nobag: i'm not sure that's semantically correct, because an event doesn't "change"
08:53:42 <ertes> maybe it's useful, but it doesn't sound like FRP
08:53:49 <EvanR> events / signals / behaviors these are all the same thing to many libraries now
08:53:56 <EvanR> in a vague way
08:54:16 <EvanR> and its annoying to not only sound wrong but use up 3 different words in the process
08:54:38 <ertes> nobag: i wonder if such a behaviour can be achieved with simple switching in a semantically consistent way
08:54:51 <MarcelineVQ> make up a better word, I'll start: shangles
08:55:01 <EvanR> i support this
08:55:59 <ertes> real FRP has no notion of "signals"…  it has behaviours and events, and they are truly separate…  that's actually the main feature of it
08:56:39 <ertes> "discrete-time FRP" (as in: "negative natural numbers") mashes them together for implementation simplicity
08:58:32 <EvanR> you hear explanations involving "when an event changes" and "being notified when a behavior happens" D:
08:58:40 <EvanR> haha
08:59:28 * ski . o O ( "in the event of a change, ..." )
08:59:30 <EvanR> signal on behavior update, update on event signaling, behaving when signal eventing
09:00:08 <ertes> i'll admit that "discrete-time FRP" is much much much better than what most people do:  event handler spaghetti
09:00:09 <ski> EvanR : where ?
09:00:10 <EvanR> all of the confusion boils down to people just using mutable variables 
09:00:19 <ertes> but you don't get all the advantages of real FRP
09:00:23 <EvanR> and attaching event handlers to them
09:01:16 <EvanR> ski: theres countless js "frp" libraries now
09:01:32 <ski> sad
09:01:42 <EvanR> whose docs randomly use these words in various permutations, nonsensically
09:02:00 <ertes> you can do real FRP with bacon.js, and the rather outdated flapjax library actually does it properly
09:02:28 <ertes> the former is faster and probably has better browser support (due to popularity), but you can get it wrong, if you don't pay attention
09:02:59 <EvanR> is theres a lib with time varying values?
09:03:20 <ertes> flapjax and in no explicit sense bacon.js
09:03:50 <ertes> you can trivially build a limited form of behaviours from events, and that's what bacon does
09:04:27 <ertes> hold :: a -> Event a -> Behaviour a
09:05:15 <ertes> basically reactive-banana does the same, but actually differentiates between events and behaviours in its API, which bacon doesn't do
09:05:48 <EvanR> what about ... time vary values ;)
09:05:54 <EvanR> varying*
09:06:13 <ertes> they are time-varying values, but you can't model them as functions
09:06:16 <EvanR> rather than a variable holding the previous event value
09:06:36 <EvanR> what i mean is, they changing only due to time passing rather than events happening
09:06:36 <Cale> To return to nobag's question, the main reason at least the FRP systems I've worked on don't have time distortion (and in fact have very little in the way of assumptions regarding the structure of time which are internal to the FRP system), is for the sake of performance and interactivity. If you have a way to slow down the passage of time in a behaviour, it means you have to remember an ever increasing portion of its 
09:06:37 <Cale> past values, which means you have a space leak (or potentially anyway). If you can speed up a behaviour, that might be fine in some cases, but for anything that is dependent on interactive input, you can't know its future, and depending on the future results in a disaster where the system can't really proceed until that input is available.
09:06:56 <EvanR> time passing isnt an event
09:07:38 * ski . o O ( integration )
09:07:38 <ertes> EvanR: you can't have those…  those "held event" behaviours are only a special case of general behaviours
09:07:58 <Cale> Even if you can just delay an event by a certain amount, that's an operation you sort of need to be careful about.
09:08:22 <ertes> EvanR: but virtually all libraries do that internally…  be it due to being inherently time-framed (netwire, yampa) or their signalling-based nature (reactive-banana, sodium)
09:08:23 <EvanR> ertes: er... can't? if held event behaviors are special case, whats a different special case
09:09:10 <ertes> EvanR: here is a simple behaviour you can't have in most systems in its full glory:  time t = t
09:09:16 <ertes> time :: Behaviour Time
09:09:20 <EvanR> really?
09:09:24 <ertes> yeah
09:09:27 <EvanR> o_O
09:09:31 <ertes> you get approximations of it
09:09:38 <Cale> One way to think about it is that the occurrences of an event which is an input to a system represent permission for that system to do computation.
09:09:38 <ertes> but mostly in the time-framed frameworks
09:10:33 <EvanR> well that example is kind of orthogonal to my question
09:10:55 <EvanR> i didnt mean that there would be some global clock that you have a value of that youre tracking
09:11:09 <unsafe_forever> in spock is there a way to get a list of routes?
09:11:10 <EvanR> but just that you have a value which is changing
09:11:39 <EvanR> not necessarily tied to a wall clock or simulation clock
09:12:06 <EvanR> i think you could create an algebra of these sorts of entities
09:12:33 <ertesx> disconnected…
09:12:38 <ertesx> signalling-based frameworks want you to implement it through a custom signalling hack, e.g. by holding a time-ticker event
09:12:59 <EvanR> yeah that sounds hacky
09:13:06 <ertesx> EvanR: think about it: that global clock has to be *measured*
09:13:27 <ertesx> you can either measure it frame by frame (AFRP), or you can use a time-ticker (reactive-banana/sodium)
09:14:01 <EvanR> Cale: at first i thought delays would be nice to implement certain time-out-like elements of a gui, however i think its too brittle. if youve ever tried to do this manually in JS with setTimeout, you know the hell of cancelling these timeouts when something causes them to no longer matter
09:14:06 <ertesx> technically there is no way you can have a nice, smooth function for it
09:14:18 <EvanR> so a GUI needs some kind of "scoped scheduling" of events
09:14:57 <ertesx> that's part of what i meant earlier when i said: "if your FRP system needs to talk to the real world"
09:15:03 <EvanR> ertesx: agree on the first half, but not the second half
09:15:56 <EvanR> ertesx: "measurables" or "queryable" or "pollable" things dont have to be measured periodically or ever
09:16:20 <ertesx> EvanR: they aren't in non-A FRP
09:16:21 <EvanR> the time could be measured only when you want to display an animating thing
09:16:32 <EvanR> A=arrow?
09:16:45 <ertesx> yeah, that's the time-ticker thing or any other event you come up with
09:16:51 <ertesx> a "clock changed" event if you will
09:17:01 <EvanR> uhg no!
09:17:03 <ertesx> A = arrow or applicative
09:17:16 <EvanR> another thing is that in JS world you dont have the notion of vsync
09:17:25 <EvanR> so people come up with these "time has changed events"
09:17:39 <EvanR> vsync is a driver for querying
09:17:54 <EvanR> it is an external source that will read your simulation
09:18:01 <ertesx> there is some limited form of vsync…  except that it's not necessarily "vsync"
09:18:04 <EvanR> so is an audio callback
09:18:21 <ertesx> i forgot what it's called:  renderAnimationFrame or something like that
09:18:26 <EvanR> these are the other side of the coin from input events, unix signals, fd readable 
09:18:41 <EvanR> which are sources of event occurrences
09:19:13 <ertesx> happy to discuss this further, but i've gotta go now…  see you later =)
09:19:14 <EvanR> cron job activation, file system notifications
09:24:14 <Cale> EvanR: There certainly is a place for having the ability to delay an event, but I think in many cases you don't really want a strict delay by a very specific amount, you just want the shortest delay possible longer than x.
09:25:06 <EvanR> ... well yeah
09:25:13 <Cale> and our experience has been that it's always possible to add that separate from the fundamental FRP system, as part of the I/O driver around it
09:25:16 * ski . o O ( infinitesimal delays in VHDL )
09:25:57 <EvanR> its always possible to add anything as part of an IO driver around something
09:28:45 <EvanR> when you naturally explain the rules of a real time game, sometimes you may say that (within some context) something lasts N seconds or happens N seconds later. but this doesnt apply if that context doesnt apply. like a glow effect around a unit naturally goes away, but some implementation of that will be confounded if the entire game is switched to the credits or something
09:29:15 <EvanR> may be confounded*
09:29:35 <EvanR> *before the glow effect ends
09:32:09 * ski nods
09:36:26 <Cale> EvanR: Oh, well what I mean there is that as long as you don't need very exact semantics for the delay, it can be moved out to just be an operation that creates new input to the system in a less principled fashion. The fundamental things which the FRP system is doing for you are caching and managing state and determining what things need to be computed. Those things are hard to separate out to be part of the I/O driver
09:36:27 <Cale>  without compromising the whole thing.
09:37:32 <agocorona> the problem of FRP is how to make composable components. If I have component A that let's say watch for cron and exception inputs compose with anoter FRP component that watch for network requests
09:38:34 <nobag> EvanR: just so I'm clear, I'm not talking about "when an event changes" and such
09:40:54 <Gurkenglas> Can finding the closure on an operation and a set be reduced to a graph problem?
09:41:33 <bsima> omg this haskell code https://github.com/mthom/shentong/blob/master/Shentong/Backend/Core.hs
09:42:16 <Cale> bsima: That was clearly machine generated
09:44:04 <EvanR> agocorona: so... I have a thing that does that
09:44:37 <bsima> Cale: i sure hope so
09:44:55 <agocorona> EvanR:  I have another. What is yours?
09:45:17 <mfukar> Gurkenglas: yes, maxflow - see Picard, 1976, "Maximal closure of a graph and applications to combinatorial problems"
09:45:51 <Cale> One way of thinking about the reason we have both Behaviour and Event is that you might require communication between parts of a system that are operating at very different frequencies. One part of the network doing audio processing might have access to a 44100 Hz event, and thus has the right to do some computation that often, while another part of the system is operating at 60Hz, and shouldn't have the ability to com
09:45:52 <Cale> pute more frequently than that.
09:46:04 <EvanR> agocorona: if you have component cron [E ()] ~> xs and another one for network [E ByteString] ~> ys then you "monoid" them together and get [E (), E ByteString] ~> xs ++ ys
09:47:11 <Cale> So while it's perfectly okay for a Behaviour to go from the audio side to the video side (e.g. you might want a Behaviour which gives an FFT of recent audio), it's not okay for an Event to pass in that direction.
09:47:26 <EvanR> the result is two non-interacting components, but you could put something to the right of the xs++ys  with (>>>)
09:48:17 <agocorona> EvanR It would be better if the reactive component is first class , I means if it can be combined with any standar operation
09:48:40 <EvanR> it is
09:49:03 <EvanR> map :: (a -> b) -> [E a] ~> [E b]
09:49:10 <EvanR> among other things
09:49:32 <agocorona> what  ~> means?
09:49:39 <EvanR> its a type ctor
09:49:44 <agocorona> ah, ok
09:50:25 <EvanR> Cale: ... but surely this model isnt based on everything having a fixed frequency right
09:50:38 <EvanR> youre just using this as an example of systems that are changing at different speeds
09:51:27 <EvanR> (the focus of "speed of change" is probably not good generally)
09:51:28 <Gurkenglas> mfukar, by closure on an operation and a set I mean the smallest superset of that set which is closed under that operation, not the no-outgoing-adges thing https://en.wikipedia.org/wiki/Closure_problem talks about, unless those subtly mean the same thing?
09:52:13 <agocorona> the problem with these constructors is that they are not the real monoid and the real map
09:52:45 <EvanR> correct ~> is another category haskell doesnt nicely jive with, so i have to use other names in the actual lib
09:53:03 <EvanR> but i do use <> and >>>
09:53:06 <agocorona> EvanR: nice
09:53:09 <dolio> Make a graph where there is an edge from x to y if your operation maps x to y.
09:53:46 <Gurkenglas> Right, operations are not binary by default in English. I meant binary operation.
09:54:29 <agocorona> I have transient, that  compose reactive components with the standard combinators
09:54:39 <ski> Cale : unapropos, do you know a good term for a minimal subset whose closure (e.g. upper closure) is a given closed (sub)set ?
09:54:57 <EvanR> agocorona: not that monoid functor etc generally have very much generic support that needs to be rewritten in case it technically cant be instances of those classes
09:54:57 <mfukar> Gurkenglas: binary operators create a graph from two input ones. Apply maxflow to the union of these two graphs.
09:55:22 <EvanR> monad does but this is not monads
09:55:48 <agocorona> EvanR:  I`m not sure to understand you :(
09:55:55 <agocorona> what do you mean?
09:56:33 <EvanR> agocorona: responding to "the problem is they cant use the standard type classes" there isnt really any generic support i would gain besides being able to use the word fmap without conflicts
09:56:59 <agocorona> ah, ok
09:57:25 <EvanR> and fmap is a silly word anyway! ;)
09:57:46 * ski . o O ( "better rename it to `flip'" )
09:58:02 <Gurkenglas> mfukar, if x and y combine to z via the operation, wouldn't that consider z in the closure if even only one of x and y is already considered to be in it?
09:58:14 <EvanR> i think people would feel more comfortable encountered haskell if it was called map, because it would make them think (people who are already familiar with list map from other languages)
09:58:18 <nitrix> Personally, map should be removed and fmap should become map :)
09:58:34 <EvanR> "map huh, i know this"
09:58:44 <EvanR> fmap is a barrier
09:58:46 <agocorona> EvanR:  Honestly I think that I found the holy grail of programming. ( laughling permitted)
09:59:03 <EvanR> orly
09:59:10 <dolio> Haskell 1.4 did it right.
09:59:20 <johnw> EvanR: you can pronounce <$> as "map" :)
09:59:29 <mfukar> No, because by definition you apply the operator to the set you want to find the closure of, i.e. if you're applying the operator to an element outside your set, you're in error
09:59:32 <agocorona> I made a cloud monad
10:00:00 <jle`> fmap was actually called map back in the day
10:00:17 <jle`> until the they added lists, and took the name for lists.
10:00:22 <jle`>   ^ (that part is not true)
10:00:24 <EvanR> lol
10:00:37 <EvanR> Haskell 1.5, now with lists
10:00:53 <kartrel> so... I'm completely new to haskell, I've installed haskell platform for windows, where to get an actual gui for creating program files and whatnot?
10:00:57 <agocorona> the holy grail is a monad where everithing compose , even in the presence of multithreading, events, cloud computing, parsing etc
10:01:25 <EvanR> "everything can compose" is at least better than "everything has an address / name"
10:01:40 <agocorona> EvanR:  certainly
10:02:02 <EvanR> content addressable content addressable content addressable ... paradigm
10:03:03 <croben> this is my assignment: 'write "factorials:: [Integer]" that is an infinite list of all factorial numbers'
10:03:22 <croben> can i do this without writing a function for factorials?
10:03:43 <Tuplanolla> Yes.
10:04:13 <croben> Tuplanolla, thanks
10:04:31 <EvanR> agocorona: somehow I am skeptical though that a holy grail will involve a monad
10:04:37 <ski> kartrel : use a text editor. perhaps Notepad, if you don't have access to something better
10:04:48 <EvanR> purely without justification
10:05:27 <EvanR> maybe it will be an infinity groupoid!
10:05:49 <kartrel> if the best choice for coding haskell is using notepad I'd probably be better of choosing some other course instead
10:05:50 <ski> kartrel : iirc there are Haskell plugins for stuff like VisualStudio, if you're into that kind of thing
10:06:02 * ski would use Emacs
10:06:05 <agocorona> EvanR: when I mean a monad, I mean monad, applicative, monoid, alternative etc
10:06:08 * Tuplanolla would use Vim.
10:06:39 <EvanR> kartrel: notepad++ ?
10:06:43 <EvanR> sublime
10:06:45 <EvanR> etc
10:07:12 <EvanR> agocorona: a "full stack" monad ;)
10:07:17 <ski> kartrel : languages, and concepts, are more important than development environments. tastes differ a lot on the latter anyway
10:07:19 <agocorona> for example this works:       (,) <
10:07:24 <agocorona> sorry
10:07:35 <Tuplanolla> There are plugins for IntelliJ and Eclipse too.
10:07:43 <Tuplanolla> However I haven't tried them.
10:08:55 <agocorona> this works:     runAt server1  (return "hello " ) <> runAt  server2 (return "world)    === "hello world"
10:09:42 <MarcelineVQ> what happens when server2 is down?
10:10:04 <EvanR> sounds like cloud haskell
10:10:37 <maerwald> any1 good with TH? I'm looking for something like: byteStringL :: ByteString -> Lit
10:10:39 <agocorona> MarcelineVQ:  I can invoque two or three servers using <|> and get the first response
10:11:29 <agocorona> MarcelineVQ:   runAt server1  (return "hello " ) <> (runAt  server2 (return "world)   <|> runAt server3 (return "world")  === "hello world"
10:11:59 <agocorona> well in reality it produces two  hello world's
10:12:01 <EvanR> maerwald: well there is overloaded strings and \xFF
10:12:30 <maerwald> EvanR: I cannot follow
10:12:35 * ski hands agocorona a pair of brackets
10:12:53 <frontendloader> kartrel: sadly, haskell doesn't have anything comprable to visual studio/eclipse/intellij available
10:13:00 <EvanR> let bs = "\x00\xff\x00\xff" in
10:13:02 <maerwald> frontendloader: leksah
10:13:05 <EvanR> will be a 4 byte bytestring
10:13:08 <frontendloader> no
10:13:08 <Tuplanolla> How are those plugins by the way?
10:13:23 <maerwald> EvanR: I don't see how I can utilize that
10:13:42 <dsub> maerwald: are leksah any good? I've heard it's buggy?
10:13:48 <frontendloader> ^
10:13:53 <maerwald> dsub: if you find a bug, fix it
10:13:57 <EvanR> maerwald: it lets you define bytestrings with a literal
10:14:04 <maerwald> EvanR: https://github.com/chrisdone/path/blob/master/src/Path.hs#L193
10:14:15 <maerwald> I know, I already use overloaded strings etc
10:14:20 <maerwald> but I don't see how that helps me here
10:14:28 <kartrel> frontendloader, too bad. I'm simply stuck at command window where I can run one line of code at a time and have no idea how to create these code.hs files
10:14:36 <agocorona> ski thanks
10:14:50 <EvanR> what is your actual problem
10:15:10 <maerwald> EvanR: the line I showed you uses FilePath, I converted everything to ByteString, except for the TH crap
10:15:12 <Tuplanolla> How do you normally create files, kartrel?
10:15:43 <maerwald> there's no function to create a Lit with bytestring
10:16:05 <EvanR> is it because its wanting a String ?
10:16:13 <maerwald> yes, StringL expects a string
10:16:19 <EvanR> you can show a bytestring to get something that works
10:16:31 <maerwald> wat?
10:16:34 <EvanR> show bs
10:16:39 <EvanR> show :: ByteString -> String
10:16:47 <maerwald> that won't typecheck either
10:16:53 <kartrel> Tuplanolla, no idea how i'd just simply create a .hs file (using windows 7)
10:17:02 <maerwald> I need a ByteString
10:17:04 <EvanR> it wants a String... but String wont work?
10:17:13 <maerwald> no, it wants a ByteString
10:17:14 <EvanR> i thought you needed a Lit
10:17:21 <maerwald> see the code
10:17:37 <EvanR> i see it
10:17:39 <maerwald> "str" has to be a ByteString
10:17:42 <maerwald> it cannot be anything else
10:18:00 <EvanR> StringL (show str)
10:18:14 <Tuplanolla> You open up a text editor (any editor will do), write things, hit "Save As..." and give the file a name with ".hs" at the end, kartrel.
10:18:23 <kartrel> ok
10:18:42 <maerwald> EvanR: I don't feel comfortable to use show that way
10:18:51 <EvanR> hahaha why?
10:19:01 <maerwald> uhm, because it's not meant for that kind of thing?
10:19:06 <ski> save as "plain text" or something like that, if there's an option
10:19:11 <EvanR> show is *the* way to convert things to a string
10:19:16 <kartrel> thanks
10:19:36 <EvanR> and in this case it gives you the exact thing youre trying to get, a bytestring literal
10:19:37 <maerwald> this is about filepaths and the fact that they must NOT be converted
10:19:53 <EvanR> they wont be
10:19:55 <Tuplanolla> In fact, assuming your editor is good enough, that's how you create any kind of file, kartrel.
10:20:08 <kartrel> ok, good to know
10:20:09 <EvanR> the literal you get is equivalent to the bytes
10:20:24 <EvanR> when the literal is reinterpreted later with overloaded strings, it will be the original bytestring
10:20:26 <agocorona> wormhole remotenode $  local (waitEvents  getLine) >> teleport  >>= local . liftIO . print        -- print text entered in my console in the console of a remote node
10:24:34 <EvanR> dont go chasing wormholes stick to the FIFOs and the semaphores that youre used to
10:26:34 <kartrel> quick question: I'm supposed to create a function which takes in two lists of any size, what's the syntax for that?
10:26:56 <maerwald> EvanR: I don't think the Show instance has any particular guarantees except that you can use it for debugging
10:27:36 <EvanR> in particular cases the pair of Show and Read instances for a type are inverses
10:28:27 <EvanR> stringification of bytestrings and strings themselves is one of these cases
10:29:08 <EvanR> ByteStrings are even simpler because youll never get characters over 255
10:31:13 <agocorona> EvanR:  wormhole and teleport is a necessary complication in order to have bidirectional streaming
10:32:51 <EvanR> bidirectional streaming! sounds like old haskell I/O
10:33:03 <agocorona> and composability.  I can combine the code above with any other
10:33:25 <EvanR> an intereseting question about distributed I/O stuff is guarantees
10:33:43 * hackagebot informative 0.1.0.27 - A yesod subsite serving a wiki.  https://hackage.haskell.org/package/informative-0.1.0.27 (implementation)
10:33:43 <EvanR> you can write a nice declarative thing about N distributed processes but what does it mean
10:33:59 <EvanR> is there any exception safety
10:34:10 <agocorona> wormhole server $ liftIO (print "hello") >> teleport >> print "world" >> teleport >> print "hello again.....
10:34:10 <EvanR> what does consistency even mean
10:34:30 <agocorona> print the string alternatively in the local and the remote node
10:37:22 <agocorona> the computatin migrates from a node to the other and back using the same connection
10:37:39 <EvanR> heh. teleport moves a cursor to another machine?
10:38:40 <agocorona> I said that i found the holy grail.
10:38:44 <agocorona> ;)
10:38:57 <agocorona> EvanR:  what do you mean by a cursor?
10:39:32 <EvanR> the imperative executor spirit thing
10:40:04 <agocorona> it recover the closure (execution state) in a remote node
10:41:08 <agocorona> serializes the variables and recover with them the state
10:42:26 <EvanR> wacky
10:47:43 <Enigmagic> agocorona: which package is this
10:48:50 * hackagebot bifunctors 5.3 - Bifunctors  https://hackage.haskell.org/package/bifunctors-5.3 (ryanglscott)
10:48:53 <agocorona> Enigmagic:  it is transient. the ghcjs branch is the most recent:  https://github.com/agocorona/transient/tree/ghcjs
10:49:58 <agocorona> I don´t know how I did it. It has been a matter of trying many ideas
10:50:48 <agocorona> The last branch integrates browser programs that can call server nodes with the same primitives
10:52:07 <agocorona> for example this works:     inputString `fire` OnKeyUp >>= runAt server  . query  >>= \ res -> H1 ("result: " ++ res)
10:52:37 <agocorona> sorry: rawHtml h1 ("result "++ res)
10:53:24 <agocorona> each time the user enter changes the text box, it perform a query in the server and send the result back to the browser
10:54:04 <agocorona> There is a video with a demo in the README.md
10:54:10 <Enigmagic> agocorona: how are you serializing arbitrary closures?
10:55:07 <agocorona> Enigmagic: The cloud monad serialize the variables
10:56:02 <scshunt> win 26
10:56:17 <agocorona>  true code:    local (inputString `fire` OnKeyUp) >>= runAt server  . query  >>= \ res ->  local . render (H1 ("result: " ++ res))
10:56:24 <Enigmagic> oh this is just for ghcjs?
10:56:24 <agocorona> local serialize the result
10:57:21 <agocorona> Enigmagic:  now it runs compiling the code both in ghcjs and ghc.  the server program will serve the JS to the browser with a small initialization code
10:58:13 <agocorona> The complete example is  here: https://github.com/agocorona/transient/blob/ghcjs/examples/webapp.hs  
10:59:05 <agocorona> have three examples of  three different widgets, composed with <|> that run client and server code each one
10:59:43 <Enigmagic> this is all i was trying to find out: https://github.com/agocorona/transient/blob/7f2e9a54f6128bf507f83f009b08fe22134ff7fa/src/Transient/Logged.hs#L25-L26
10:59:56 <Enigmagic> assuming i read that right
11:00:03 <agocorona> yes that is the logging mechanism
11:00:21 <kartrel> http://lpaste.net/158439 something here is not working and i have no idea what
11:01:56 <agocorona> I have to go. see you
11:08:43 <kartrel>  this programming language is actually worse than java, and that's saying a lot. I've now been trying to fix my program (which is extremely simple) for 30 minutes with no progress
11:09:13 <EvanR> in some ways you can compare haskell and java, just not in the languag earea
11:09:22 <dmj> EvanR: o/
11:09:41 <geekosaur> kartrel, what is insert_at_start supposed to do? it seems a bit weird to me
11:10:20 <kartrel> geekosaur, basically, append something to the start of a list
11:10:40 <cocreature> so (:)?
11:10:42 <EvanR> theres an operator for that already
11:10:46 <EvanR> foo : bar
11:10:50 <kartrel> what the program is supposed to do is to sum the two lists into one list, example: [2,3,4] and [3,1,2] becomes [5,4,6]
11:10:52 <seishun> this channel is way too tolerant. if someone said C++ is worse than java in ##c++, they'd get ridiculed in the best case
11:11:39 <geekosaur> insert_at_start item (front : rest) = front item     <-- this tells me that to insert an item at the front of the list (front:rest), you call front as a function on the item?
11:12:42 <kartrel> geekosaur, here's the current version which still isn't working http://lpaste.net/158440
11:12:57 <monochrom> kartrel: what if the two lists have different lengths?
11:13:03 <EvanR> kartrel: so you should also include the error messages you are getting
11:13:06 <Jinxit> seishun: I'm too much in the ##c++ mindset to speak up and help here
11:13:12 <merijn> EvanR: He's using ++ instead of :
11:13:27 <EvanR> and + instead of whatever
11:13:27 <merijn> seishun: To be fair, ##c++ is a bunch of unhelpful mean curmudgeons
11:13:49 <EvanR> oh + looks right now, just saying "doesnt work" is not a good way to get help
11:13:51 <merijn> seishun: Every 2 months or so I forget that and try to get help there, and usually regret it within minutes...
11:13:56 <Jinxit> nah we're helpful when the question is well-posed and on topic
11:14:02 <Jinxit> which is much more narrow than #haskell
11:14:14 <kartrel> EvanR, the error message doesn't say anything either so can't say much about the whole thing
11:14:21 <EvanR> it doesnt say anything?
11:14:48 <monochrom> kartrel, but you can show the error message for them to explain to you
11:14:52 <desophos> #haskell is incredibly patient; that haskell939 person who was in here a few days ago was incredibly frustrating and i was only reading, not even helping :P
11:15:03 <geekosaur> the type error is ... interesting
11:15:12 <merijn> geekosaur: What's it say?
11:15:45 <geekosaur> Non type-variable argument in the constraint: Num [a] When checking that ‘summa’ has the inferred type summa :: forall a. Num [a] => [[a]] -> [[a]] -> [a] -> [a]
11:15:50 <cocreature> if you’re new to haskell, trying to write programs without type signatures is … usually not a very good idea
11:15:58 <geekosaur> not exactly ghc's most pellucid error for a newcomer
11:16:11 <kartrel> non type-variable argument in the constraint: Num [A] <Use FlexibleContexts to permit this> When checking that 'summa' has the inferred type summa :: forall s. Num [a] => [[a]] -> [[a]] -> [a] -> [a] Failed, modules loaded: none.
11:16:44 <geekosaur> kartrel, so what that is telling you is you tried to add two lists together
11:17:07 <EvanR> would that error be better if you had put a top level type signature
11:17:28 <EvanR> i dont have much experience dealing with type errors where top level type sigs are just missing
11:17:55 <geekosaur> it would notice the mismatch, yes
11:18:08 <geekosaur> and probably not let type inference lead it down the Num [a] rabbit hole
11:19:51 <kartrel> so basically ++ is not used when combining lists, instead i should use : ?
11:20:14 <monochrom> basically ++ is when combining lists.
11:20:14 <cocreature> ++ appends two lists, : prepends a single element to a list
11:20:41 <kartrel> ok
11:20:43 <merijn> cocreature: Writing programs without type signatures if never a good idea :)
11:20:48 <monochrom> and basically you are using ++ to combine a nonlist to a list
11:21:37 <monochrom> you are basically saying "45 ++ [2,4,6]" it is not going to fly
11:21:56 <monochrom> even if it would fly in PHP
11:22:15 <kartrel> deadline in ten hours, half out of five tasks done, might have to get drunk in order to survive this
11:22:21 <cocreature> merijn: ofc, but later you can at least make somewhat sense of the errors or know that the first thing you should try is adding a type signature. I’m in a course that teaches some haskell and I stopped counting how often I had to explain to people that they should add type signatures because the course explicitely says that type inference is so great and you don’t need to write them.
11:23:02 <monochrom> no, statistics shows that getting drunk causes more elementary type errors like this, not fewer
11:23:17 <cocreature> and judging by the amount of people that get here with some coursework without type signatures that doesn’t seem uncommon
11:23:53 <obadz> I'm glad that there are people getting to do haskell coursework at all :-)
11:24:08 <monochrom> if you get drunk you will be stuck thinking "True / "xyz" makes sense, why is it a type error??!!!" in no time
11:24:16 * geekosaur wishes they'd include the important proviso "once you're familiar with Haskell's type system"
11:24:58 <EvanR> otoh giving up drinking right before needing to do something critical is probably not smart
11:25:10 <kartrel> monochrom, being drunk helps me tolerate the programming language itself. From experience I can tell you that I'm somewhat good at programming even though I'd be piss drunk :D
11:25:40 <monochrom> sure. but the programming language doesn't tolerate drunkards.
11:25:42 <EvanR> which language are you good at while piss drunk?
11:25:50 <cocreature> php
11:25:53 <EvanR> genuinely curious
11:26:00 <kartrel> EvanR, c++ and python
11:26:08 <EvanR> python i can believ
11:26:26 <kartrel> and also ahk but that's not a programming language per say
11:26:30 <eze> I am trying to understand Day convolution, can you point me good material to start?
11:27:30 <monochrom> well, drunkards and type cavaliers. when someone thinks that "True / "xyz"" makes sense, it is indistinguishable whether they are drunk or cavalier
11:28:09 <EvanR> > True / "xyz"
11:28:10 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
11:28:10 <lambdabot>      In the second argument of ‘(/)’, namely ‘"xyz"’
11:28:10 <lambdabot>      In the expression: True / "xyz"
11:28:23 <kartrel> I'm somewhat certain that haskell will be the same for me as mysql was: first you just want to stop using the language but after having used it for a couple of weeks you'll suddenly understand it in a whole different level and actually think the language is ok
11:28:24 <hpc> how drunk do you have to be to change your mind about something so ridiculous
11:28:26 <cocreature> monochrom: that’s easy you just need to enable overloadedstrings, add an instance for Bool and add a num instance for Bool
11:28:41 <EvanR> heh its problem is that the types arent the same
11:28:54 <EvanR> the first thing i notice is division makes no sense for either
11:29:07 <hpc> cocreature: submit a pull request for acme-php and i will merge it
11:29:38 <cocreature> hpc: sry I don’t like orphans :)
11:29:47 <hpc> it's okay i define my own Bool
11:30:13 <cocreature> eze: there is an ncatlab page https://ncatlab.org/nlab/show/Day+convolution but last time I tried to understand that I gave up so I’m not sure I would call it good starting material.
11:30:28 <kartrel> is haskell actually turing complete?
11:30:37 <cocreature> ofc
11:30:39 <hpc> haskell is church complete
11:30:39 <ski> of course
11:31:00 <monochrom> next time I'm going to try "f a = a ++ a / a && a `shiftL` a"
11:31:07 <cocreature> hpc: heh, in that case I’ll make a pr hopefully in the near future
11:31:20 <hpc> cocreature: make it as terrible as you can!
11:31:57 <cocreature> monochrom: that’s a tricky one
11:32:02 <EvanR> its not php without an implied hierarchy of output buffers do you have that?
11:32:32 <monochrom> Haskell has one level of output buffer. is that enough?
11:32:41 <EvanR> nope
11:32:46 <eze> cocreature: Thanks, I read that but I found it a little bit too advanced. I was looking for something with more gradual explanations 
11:33:01 <cocreature> eze: if you find that please tell me :)
11:34:14 <kartrel> what i've understood is that everything has to be done in recursion, so how can you eg. make something similar to an object in haskell? As in would creating an actual game be possible with haskell or is everything just about writing solutions to mathematical problems in an 'understandable' way?
11:34:37 <sinelaw> Hey, can anyone recommend a library that parses and pretty prints from the same spec?
11:34:41 <obadz> kartrel: what's an object?
11:34:49 <merijn> Those are two orthogonal questions
11:34:59 <merijn> Actually three
11:35:04 <sinelaw> kartrel: games are created in haskell
11:35:05 <obadz> sinelaw: Read/Show? Aeson?
11:35:07 <cocreature> the answer to can you make a game is “yes”
11:35:17 <merijn> 1) can you do objects, 2) can you do games, 3) can you do games using objects
11:36:02 <obadz> merijn: hmmm it's unlikely that 3 would not be 1 && 2 imho…
11:36:22 <monochrom> my http://lpaste.net/52480 is a simple game. what object?
11:36:23 <eze> cocreature: hahaha, if I am lucky enough I will :)
11:36:24 <Cale> kartrel: You can do what I consider to be the essence of object oriented programming quite nicely in Haskell
11:36:25 <sinelaw> obadz: Forgot about Aeson, I'll take another look to see if it can handle the syntax I want
11:36:33 <kartrel> i understand that haskell is not an object oriented language but i'd think that if it's turing complete, you could actually program something similar to the class/object system in haskell?
11:36:38 <obadz> sinelaw: Aeson is for Json syntax
11:36:50 <sinelaw> obadz: I think it's more flexible than that
11:37:36 <ski> kartrel : "this programming language is actually worse than java, and that's saying a lot." -- suggests to me that you just haven't encountered functional programming before. learning a different programming paradigm is more akin to learning to program from scratch all over again (not quite, but that's a good mindset to have at the outset). learning a different programming language in a known paradigm is comparatively easier
11:37:37 <Cale> kartrel: Just by making records of functions (possibly producing IO actions), for the types of your objects, and then functions which build those records in various ways. The parameters to those functions (along with any locally defined things they might construct) are essentially the "private" data.
11:37:41 <obadz> sinelaw: if that's the case I don't know about it
11:38:17 <sinelaw> obadz: I just heard it, maybe I'm wrong.
11:38:38 <cocreature> monochrom: I give up I can’t get that to typecheck
11:38:49 <ski> kartrel : i would say that that SQL comparision is appropriate (except that SQL has hideous concrete syntax, several design flaws, and common implementations doesn't implement the whole language, forcing you to play compiler yourself, or use atrocious workarounds ..)
11:39:06 <monochrom> cocreature: it is meant to be an example of "makes sense when you're drunk"
11:39:19 <cocreature> sure :)
11:39:20 <Cale> kartrel: You don't get subtyping like this, but you also need it a whole lot less. Most of the purpose of subtyping in typed OO languages is because they've tied the method implementations to the types of the objects.
11:39:29 <hpc> is sql even turing complete? it can't emulate java's object system
11:39:29 <kartrel> ski, most of what i wrote was because of the frustration that this is completely new, everything i know about programming is thrown away because all of the syntax is completely different, and the logic
11:39:37 * hpc ducks
11:39:49 <monochrom> I have both ++ and && somewhere there, so you will run into a contradiction between [a] and Bool
11:39:49 <johnw> eze: http://bartoszmilewski.com/2016/01/ has a section on Day Convolution
11:40:03 <johnw> eze: and there is more relevance to Haskell here https://www.reddit.com/r/haskell/comments/2lompe/where_do_the_applicative_laws_come_from/
11:40:03 <cocreature> monochrom: yeah and shiftL forces it to be int
11:40:12 <monochrom> but just for fun let's throw in Num and Bit there
11:40:36 <Cale> kartrel: So, if you don't have that restriction, and can arbitrarily define new objects of the same type just by providing different method implementations, it tends to work out just fine.
11:40:48 <monochrom> actually I used / so it's Fractional or something
11:41:00 <ski> kartrel : *nods*, it's completely understandable. i'm just saying that you shouldn't expect to be able to carry over that much working knowledge from Java,C,Python,Smalltalk,Ruby,PHP,Ada,Pascal,COBOL,Fortran,C++,C#,Eiffel,Self,Perl,&c.
11:41:02 <hpc> :t (/)
11:41:03 <lambdabot> Fractional a => a -> a -> a
11:41:24 <sinelaw> obadz: I guess I'm wrong
11:41:44 <obadz> sinelaw: ;-)
11:41:54 <ski> kartrel : try to view this as an opportunity to learn about a different approach to what programming may be about, not "more of the same old"
11:42:06 <Cale> kartrel: Yeah, it took me about 2 months to get to the point where I actually felt like I could use Haskell for practical things, and about a year to be comfortable, but even before I was really comfortable, it was my most productive language by far.
11:42:49 <hpc> and until you get comfortable, it'll be breaking assumptions you had about programming pretty much the whole time
11:43:17 <hpc> but keep pushing and you'll come out the other end a better programmer
11:43:48 <exio4> and when you get too comfortable with Haskell, you'll lose proficiency at writing workarounds? :P 
11:44:08 <Tuplanolla> I'd also like to point out that Turing completeness is not a very good criterion for languages.
11:44:38 <kartrel> ski, yup, although I'd be a lot more eager to learn if the documentation would be of the same level as eg. java. I'm now trying to find how to += something
11:44:45 <hpc> fun fact: make is turing complete, css is turing complete, registerless x86 is turing complete, and x86 interrupts are turing complete
11:44:46 <Tuplanolla> There are useful languages like Alloy or Coq that are not Turing complete.
11:44:55 <Cale> kartrel: How to += what kind of thing?
11:45:06 <Cale> kartrel: An IORef?
11:45:35 <eze> johnw: Thanks, I will read that and see if it helps
11:45:37 <Hafydd> Make is turing complete, e.g. by calling a turing machine simulator inside a recipe.
11:46:04 <Cale> kartrel: Every bound variable in Haskell will maintain the same value the entire time it remains in scope.
11:46:10 <hpc> Hafydd: no, http://okmij.org/ftp/Computation/#Makefile-functional
11:46:15 <kartrel> Cale, basically the same as the earlier problem but now i'd have to go through the product and then sum it as one like this: [1,2,3] [2,3,4] = 1*2+2*3+3*4 = 20
11:46:44 <kartrel> would this work? produkt (front1:rest1) (front2:rest2) prodd = produkt rest1 rest2 (prodd += (front1*front2))
11:46:47 <monochrom> "front1 + front2" is already your += there
11:46:49 <sinelaw> obadz: looks like roundtrip does it http://hackage.haskell.org/package/roundtrip
11:47:05 <Cale> Ah, okay, so you want to take the product of corresponding pairs of elements of the lists, and then sum the results?
11:47:13 <kartrel> yeah
11:47:22 <Cale> kartrel: zipWith is useful for this
11:47:27 <Cale> :t zipWith
11:47:28 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:47:34 <ski> Cale : i think kartrel wants to do it directly
11:47:38 <sinelaw> looks kinda dead
11:47:41 <Jinxit> kartrel: it would really be beneficial to actually learn the language from the ground up instead of just trying to pattern match documentation against your problem
11:47:43 <sinelaw> (unmaintained)
11:47:45 <Cale> Well, you could also write it recursively
11:47:51 <ptek> kartel, what may also help is joining a local haskell meetup, if there is any in your area, and try to ask someone to show you basic things. Like how to understand types, documentation, how to get the knowledge.
11:47:58 <ski> kartrel : what is `prodd' there ? a list ? a number ?
11:48:06 * ski assumes a number
11:48:09 <ptek> kartrel, sorry, mispelled your name there
11:48:27 <kartrel> prodd is the sum of the products as in : [1,2,3] [2,3,4] = 1*2+2*3+3*4 = 20
11:48:31 * ptek does not know how to type
11:48:33 <ski> ok
11:48:40 <Cale> kartrel: So just +, not +=
11:48:56 <Cale> kartrel: and then in the empty list case, that will be your result, yeah?
11:48:59 <kartrel> Cale, ah of course
11:49:05 <kartrel> yeah
11:49:20 <kartrel> now this was just me being stupid
11:49:21 <ski> kartrel : `prodd' is an argument of `produkt'. the role it's playing is sometimes called "accumulator", since we're using it to accumulate the result so far. in the end, will hold the final result
11:49:42 <kartrel> ski, yeah i was thinking of using prodd as an accumulator
11:49:53 <kartrel> btw, is it possible to have more than one accumulator?
11:49:53 <Cale> > sum (zipWith (*) [1,2,3] [2,3,4])
11:49:54 <lambdabot>  20
11:49:58 <Cale> sure
11:50:07 <ski> kartrel : yes
11:50:14 <monochrom> just use more parameters
11:50:21 <ski> kartrel : so in `produkt rest1 rest2 (prodd += (front1*front2))' you want to pass to this recursive call to `produckt' the next version of the sum-of-products-so-far
11:50:35 <ski> (s/produckt/product/)
11:51:57 <ski> kartrel : you know how a list `[2,3,5,7]' is really syntactic sugar for `2 : [3,5,7]', which is syntactic sugar for `2 : 3 : 5 : 7 : []' (meaning `2 : (3 : (5 : (7 : [])))'), right ?
11:53:19 <kartrel> ski, probably :D
11:53:32 <ski> let's assume that we could actually write
11:53:34 <ski>   produkt (front1:rest1) (front2:rest2) prodd = produkt rest1 rest2 (prodd += (front1*front2))
11:54:01 <ski> and consider how something like `produkt [1,2,3] [2,3,4] 0' (starting with `0' as the initial value for the accumulator) would then run :
11:54:08 <ski>      produkt [1,2,3] [2,3,4] 0
11:54:39 <ski>   =  produkt (1:2:3:[]) (2:3:4:[]) 0   -- desugaring
11:54:54 <kartrel> i'll compile it and then test it and finally link the code here if you want
11:55:10 <ski>   =  produkt (2:3:[]) (3:4:[]) (0 += (1*2))   -- using the recursive defining equation above
11:55:25 <ski>   =  produkt (3:[]) (4:[]) ((0 += (1*2)) += (2*3))   -- using the recursive defining equation above, again
11:55:43 <ski>   =  produkt [] [] (((0 += (1*2)) += (2*3)) += (3*4))   -- using the recursive defining equation above, once again
11:56:09 <ski>   =  ((0 += (1*2)) += (2*3)) += (3*4)   -- presumably the final value of the accumulator is just returned in this case
11:56:20 <ski> this isn't quite right, though
11:56:24 <ski> can you see how to fix it ?
11:56:54 <ski> what to change, to make `((0 += (1*2)) += (2*3)) += (3*4)' into an *expression* that will compute the desired result here ?
11:58:10 <kartrel> http://lpaste.net/158441 this doesn't compile for some odd reason
11:58:29 <ski> kartrel : do you want to consider what i asked above ?
11:59:00 * ski notes `produkt [] [] prodd = prodd', which indeed says that "the final value of the accumulator is just returned in this case"
11:59:06 <monochrom> it compiles for me
11:59:26 <Cale> kartrel: are you sure that's the code you're compiling?
11:59:51 <kartrel> that plus the old code for the sum that already worked
12:00:05 <ski> kartrel : that code looks right
12:00:19 <kartrel> http://lpaste.net/158442 all in all this
12:00:57 <ski> kartrel : vtw, fyi, if you use the "Annotate" button on the paste, then the update will appear on the same page, for easier comparision
12:01:01 <Cale> yeah, that code looks okay, what error are you getting?
12:01:09 <monochrom> you have a typo. a "summ" should be "summa"
12:01:21 <monochrom> no, that's not it
12:01:36 <Cale> summ is the name of the accumulator there
12:01:37 <kartrel> Occurs check: cannot construct the infinite type: a ~ [a]
12:01:57 <Cale> on which line? Can you paste the whole error in an annotation?
12:02:02 <monochrom> "summ : (front1+front2)" vs "(front1+front2) : summ"
12:02:07 <ski> `summ : (front1+front2)' should be `summ ++ [front1+front2]'
12:02:09 <Cale> oh!
12:02:10 <Cale> yeah
12:02:11 <Cale> haha
12:02:13 <ski> or what monochrom said
12:02:20 <ski> (but then you get the opposite ordering)
12:02:21 <monochrom> for summande you do not want to use an accumulator at all
12:02:39 <ski> one step at a time :)
12:03:12 <kartrel> in the summa i'm after [1,2,3] [2,3,4] becoming [3,5,7]
12:03:35 <ski> `:' adds a list element to the *left* (of `:') in front of a list to the *right* (of `:')
12:03:55 <ski> so `summ : (front1+front2)' won't work since you have the list to the left, and the list element to the right
12:04:17 <kartrel> i changed : into ++ and now i get Non type-variable argument in the constraint: Num [a] and so forthg
12:04:19 <kartrel> forth*
12:04:52 <ski> kartrel : right. so either you use an accumulator, adding elements to the end as you wanted to do. or you use an accumulator, but add to the start (a la monochrom), and then do a *final* reverse. or you don't use an accumulator at all, instead computing the result "directly"
12:05:18 <ski> kartrel : note i also changed the `(',`)'s around the element into `[',`]'s
12:05:25 <kartrel> could i do
12:05:26 <kartrel> summa (front1:rest1) (front2:rest2) summ = summa rest1 rest2 (summ : [(front1+front2)])
12:05:45 <ski> yes (but the inner pair of round brackets there are redundant)
12:06:00 <ski> well, you still need `++' ..
12:06:39 <ski> (`summ' is a list. `[front1+front2]' is also a list, of one element. `++' can combine them into a new list)
12:07:21 <kartrel> no matter what i do with the fourth row, it still keeps on giving errors
12:08:04 <ski> you haven't tried the right combination of things yet
12:08:27 <kartrel> finding the right combination seems to be in the order of NP :(
12:11:35 * ski suggests taking a step back, and think things through
12:11:41 <ski> you've got the basic idea right
12:11:41 <Cale> kartrel: be careful about the type of (:)
12:12:03 <ski> `:' wants an *element* to the left and a *list* to the right
12:12:10 <ski> `++' wants two lists
12:12:20 <ski> `front1+front2' is a number, not a list
12:12:22 <kartrel> summa (front1:rest1) (front2:rest2) summ = summa rest1 rest2 (summ ++ (front1+front2)) didn't work and neither did summa (front1:rest1) (front2:rest2) summ = summa rest1 rest2 (summ : (front1+front2)) and neither did both with [(front1+front2)]
12:12:32 <ski> `[front1+front2]', otoh, is a list
12:12:47 <Cale> summ here is presumably a list
12:12:51 <ski> yes
12:12:52 <monochrom> writing a correct program is beyond NP-hard. it's uncomputable.
12:13:04 <Cale> So, summ ++ [front1 + front2] is also a list
12:13:40 <Cale> summa rest1 rest2 (summ ++ [front1 + front2]) should typecheck
12:14:06 <kartrel> understanding the thought process in haskell seems to be in EXPSPACE
12:14:27 <Cale> kartrel: It's not really, you just learn to pay close attention to the type of everything
12:14:35 <Cale> kartrel: and then there are very few options
12:16:15 <merijn> @quote everything.is.hard
12:16:15 <lambdabot> roconnor says: writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in haskell ;) <kmc> that's a pretty good summary
12:17:29 <kartrel> Cale, ok, got it working with that
12:18:00 <ski> merijn : nice one :)
12:18:21 <Cale> kartrel: Okay, now we might want to address the rather severe performance issue that this function will have: computing xs ++ ys takes O(length xs) steps, so your function is pretty much quadratic time.
12:18:54 <Cale> (it depends on how many elements of the result you eventually need, but assuming the answer is "all of them", then it is quadratic time)
12:19:08 <Cale> We can do much better by changing the way that the recursion happens
12:19:39 <Cale> Instead of accumulating a list to which we add elements to the end, instead, produce a list directly, giving its first element, and recursing to determine the tail
12:20:08 <kartrel> Cale, if we had eg. 10 in the list -> [a,b,c,d,e,f,g,h,i,j] [a2,b2,c2...] shouldn't it just be n instead of n² ?
12:20:31 <kartrel> or is it because of append to the end of the list?
12:20:32 <ski> kartrel : *repeatedly* adding to the end of a list is quadratic
12:20:42 <ski> lists are single-linked, in Haskell
12:20:46 <kartrel> ah
12:20:56 <ski> the only way to get to the end is to traverse all the way to it, from the start
12:21:24 <kartrel> so a->b->c and so on in a list
12:21:40 <ski> here monochrom's trick helps
12:21:57 <kartrel> shouldn't the best option then be to use a method for a list where you could access any location at O(1) ?
12:22:51 <Cale> kartrel: Well, lists can be infinitely long, and the element you want might not even be in memory, so O(1) is out of the question
12:23:24 <Cale> kartrel: Lists in Haskell aren't really used as a container for data so much as they're a way of expressing that you're going to iterate over a sequence of things in order.
12:23:41 <Cale> We have arrays and other data structures too
12:23:43 <merijn> kartrel: Lists in haskell are linked lists (ala lisp, etc.) not relocating vectors ala C++/python
12:23:55 <merijn> kartrel: If you want direct indexing you'd use a vector/array datatype
12:24:02 <Cale> Lists are fundamental in Haskell for much the same reason as loops are fundamental in imperative programming
12:24:05 <kartrel> everything, and especially everything must be completely different from object oriented languages, doesn't it :(
12:24:28 <cocreature> it’s great you can learn new things!
12:24:29 <monochrom> we usually use Haskell list as a control structure (think Python generator), not a container, except for toys
12:24:34 <Cale> Just as a loop either might have zero iterations (because its precondition isn't met, for instance), or it consists of an iteration followed by another loop
12:24:48 <monochrom> "x : yyy" is "yield x; yyy"
12:24:48 <Cale> A list is either [], the empty list, or it is (x:xs), an element followed by another list
12:25:00 <Cale> > [1..]
12:25:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:25:14 <sinelaw> anyone else having problems with latest haskell-mode? (#haskell-emacs is not very active atm)
12:25:16 <kartrel> is ; for documenting? or // or #?
12:25:23 <mauke> kartrel: --
12:25:24 <mauke> like SQL
12:25:30 <Cale> -- makes a comment until the end of line
12:25:36 <kartrel> ok
12:25:38 <monochrom> therefore summande should be doing "yield (front1 + front2); summande rest1 rest2". you would do that verbatim in Python, wouldn't you?
12:25:41 <mauke> ; is syntax, // and # are operators
12:25:42 <Cale> {- makes a block comment {- and they can be nested -} -}
12:25:54 <mauke> "nested comments" is an oxymoron
12:26:12 <Cale> I don't want to hear it mauke :D
12:26:16 <Cale> hahaha
12:27:03 <kartrel> now i'll need vodka to survive this :/
12:27:27 <monochrom> sinelaw: I'm using 13.18 and the only problem is "data X = L" "| R" indents sub-ideally.
12:27:37 <Cale> kartrel: So yeah, consider  summande [] [] = []; summande (x:xs) (y:ys) = (x+y) : summande xs ys
12:27:56 <Cale> (and the other two cases can be errors still if you like)
12:28:28 <ski> Cale : spoilsport
12:29:02 <Cale> kartrel: This is better because we always evaluate things to pattern match on them, and so if we were trying to pattern match the expression summande [1,2,3] [4,5,6] say, against the pattern (z:zs)
12:29:30 <Cale> then what would happen is we would apply the rule there, and obtain (x+y) : (summande xs ys)
12:29:41 <kartrel> okay, let's say that i'm quite confused by that cale, but i'll add it as comments to the program
12:29:56 <Cale> and evaluation would stop there -- z would be matched against x+y, and zs would be matched against summande xs ys
12:30:22 <Cale> and only if we needed to match zs against another pattern would the recursion continue
12:31:06 <Cale> kartrel: You can think of what the Haskell evaluator is doing as replacing expressions with other expressions according to the equations you've given it.
12:31:20 <Cale> and it does this in an outermost-first way
12:31:56 <kartrel> okay
12:31:57 <Cale> So when you have f (g (h x)) for example, it's f which will be applied first, to the not-yet-evaluated expression g (h x)
12:32:15 <Cale> and if f pattern matches on its argument, then g (h x) will need to be evaluated
12:32:19 <Cale> (if and when)
12:32:35 <monochrom> and only as much as that pattern needs
12:33:46 <kartrel> couldn't i use snoc to append to the end of the list too?
12:34:27 <monochrom> yes, it will be Ω(n)
12:34:39 <Cale> kartrel: Well, snoc isn't efficient on lists -- you could define a new list type which was efficient in the other direction
12:34:53 <kartrel> ok
12:34:54 <monochrom> every computable thing can be done at a suitable cost
12:35:38 <Cale> It's not (++)'s fault for being poorly implemented or something, it's doing the best it can -- it's just the nature of what a list is which creates the problem.
12:35:39 <monochrom> for uncomputable things maybe you can try selling your soul
12:36:10 <Cale> Oh, maybe I should show you the function trick :)
12:36:24 <monochrom> but I am not sure whether it buys you as much as Π3 or you are stuck at Σ1
12:36:32 <Cale> It might be a little too early for this, but we'll try :)
12:36:47 <kartrel> function trick?
12:37:02 <Cale> So, if appending lists is slow, maybe we can change to another representation where appending is fast
12:37:12 <Cale> So, instead of using the list type [a]
12:37:25 <Cale> We'll use functions [a] -> [a] which add elements to the beginning of another list
12:37:35 <Cale> So instead of the empty list, we'll use the identity function
12:37:43 <Cale> (it adds no elements)
12:38:01 <Cale> and instead of a singleton list [x], we'll use the function (x:) which adds x to the beginning of whatever list you give it
12:38:21 <Cale> and, this is the key part, instead of using (++), we get to use function composition (.)
12:38:34 <Cale> (f . g) = (\x -> f (g x))
12:38:42 <Cale> is O(1), no matter what the functions are
12:39:08 <Cale> and at the end, once we've constructed our function [a] -> [a], we can apply it to an empty list to get the final result
12:39:30 <Cale> and since this turns an O(n) operation into an O(1) operation, it will make the whole thing linear instead of quadratic
12:39:44 <kartrel> interesting
12:41:03 <kartrel> i'll probably have to go thorugh function composition in order to understand that completely
12:41:46 <Cale> summa [] [] summ = summ; summa (x:xs) (y:ys) summ = summa xs ys (summ . ((x+y) :)) -- well, this is kind of a funny example... but you see here we accumulate a function
12:41:51 <Cale> and then
12:42:01 <Cale> summande xs ys = summa xs ys id []
12:42:33 <Cale> we pass in the identity function as our initial accumulator, and then summa xs ys id will result in a function, which we apply to the empty list to get the final result
12:42:49 <Cale> Perhaps a better example is tree traversals
12:42:59 <Cale> If we have this binary tree type:
12:43:10 <Cale> data Tree = Tip | Branch (Tree a) a (Tree a)
12:43:18 <Cale> oops
12:43:20 <Cale> data Tree a = Tip | Branch (Tree a) a (Tree a)
12:44:01 <Cale> i.e. every value of type Tree a is either the constant Tip, or it is Branch l x r where l and r have type Tree a, and x has type a
12:44:20 <Cale> e.g. Branch (Branch Tip 1 Tip) 2 (Branch Tip 3 Tip)
12:44:24 <Cale> :: Tree Integer
12:44:37 <Cale> We might want to write an in-order traversal on this tree:
12:44:42 <Cale> inorder :: Tree a -> [a]
12:44:48 <Cale> inorder Tip = []
12:45:01 <Cale> inorder (Branch l x r) = inorder l ++ [x] ++ inorder r
12:45:24 <Cale> simple enough, but again, quadratic because xs ++ ys is O(length xs) time, so on left-leaning trees, it will be slow
12:45:51 <Cale> Applying the trick of passing from constructing a list of type [a] to a function [a] -> [a]:
12:45:59 <Cale> inorder' :: Tree a -> [a] -> [a]
12:46:02 <Cale> inorder' Tip = id
12:46:14 <Cale> inorder' (Branch l x r) = inorder' l . (x:) . inorder' r
12:46:18 <Cale> and then we can write
12:46:22 <Cale> inorder :: Tree a -> [a]
12:46:28 <Cale> inorder t = inorder' t []
12:46:38 <Cale> and now it's linear time
12:47:14 <Cale> kartrel: I realise that's probably pretty quick... feel free to ask questions about anything :)
12:47:54 <kartrel> i've saved your explanation so that I can go through it when I haven't takes in me ten portions of alcohol
12:48:04 <Cale> haha
12:50:30 <dmj`> Cale: sounds like a candidate for http://accidentallyquadratic.tumblr.com/
12:59:04 <monochrom> haha there are 3 Haskell incidents
13:01:20 <monochrom> my friend told me a case of accidentally linear (when log should do). a program that searches a list of names is observed to search faster if the name is alphabetically near "A", and slower if alphabetically near "Z". my friend concluded that the program must be storing the list sorted but still does linear search.
13:02:20 <opqdonut> taht's more like accidentally exponential :)
13:02:46 <monochrom> true!
13:03:55 * hackagebot prometheus 0.3.2.1 - Prometheus Haskell Client  https://hackage.haskell.org/package/prometheus-0.3.2.1 (LukeHoersten)
13:04:25 <kartrel> accidentially grahams
13:04:32 <aaakfp`> what's the latest ghc arm status?
13:06:44 <nitrix> In a Rank 2 function, the polymorphic function that's passed, let's say (forall a. a -> a), is that included implicitly in the universal quantification as well or not? Stretching the example further, what if I had multiple types for said functions (forall a. a -> a), could I have a ... "rank 2" type variable that's quantitified?
13:07:04 <johnw> nitrix: not sure I follow
13:07:07 <nitrix> Not sure if managed to put my question down in a readable manner.
13:07:13 <nitrix> Apparently not :P
13:07:36 <johnw> what does "included implicitly in the universal quantification as well" mean?
13:08:56 <monochrom> nitrix: it is useful to write down an example rank-2 type and then discuss it
13:09:24 <monochrom> (I have a feeling that as a result you realize that what you're thinking vanishes)
13:09:39 <nitrix> I'll do so in a minute, just need to fix an emergency first apparently.
13:09:55 <kartrel> basic int list -> get last in list, basic int list -> get all except last in list
13:10:11 <ski> > init "abcd"
13:10:12 <lambdabot>  "abc"
13:10:14 <ski> > last "abcd"
13:10:16 <lambdabot>  'd'
13:10:59 <kartrel> thanks ski :)
13:11:32 <ski> note that repeatedly applying `init' isn't a good idea
13:11:46 <ski> better then to once `reverse' the list, and take elements of the head/front of it
13:12:02 <ski> kartrel ^
13:12:21 <kartrel> init is most probably O(n) ?
13:12:43 <kartrel> or, of course it is
13:12:50 <kartrel> stupid me asking stupid questions
13:15:27 <ski> yep. np
13:16:00 * ski . o O ( "there are no stupid questions, only stupid people ;)" )
13:16:14 <LearnerGuy> I have a question regarding binding operators.
13:16:29 <kartrel> hmm: Ambiguous occurrence `last' It could refer to eithert `Main.last', defined at temps.hs:23:1 or `Prelude.last' imported from `Prelude' at temps.hs:1:1 <and originally defined in `GHC.List')
13:16:40 <kartrel> even though i wrote only Main.last
13:17:41 <ski> kartrel : `import Prelude hiding (last)'
13:18:01 <ski> you add that near the top of your source file
13:18:31 <ski> if you don't import `Prelude' explicitly, then it's implicitly imported
13:18:45 <kartrel> at least something is similar to python :D, but thanks ski :)
13:18:50 <ski> by importing it explicitly, you can omit importing some things
13:18:57 <sleblanc> Hmm, looks like the Yesod site is down: http://www.yesodweb.com/
13:18:59 <ski> of course you can also rename your `last', if you prefer
13:19:10 <kartrel> hm, it gives the same error message still
13:21:02 <kartrel> http://lpaste.net/158449
13:21:34 <ski> what about it ?
13:22:04 <kartrel> no matter what I do about the last, it still gives a compilation error
13:22:34 <kartrel> Not in scope: `last'
13:23:12 <kartrel> ok now I got it to work
13:24:33 <kartrel> oh, this'll be fun to code
13:24:44 <kartrel> although i'll need some more alchohol before i start
13:24:53 <ski> if you don't import `last' from `Prelude', then you need to define it yourself (or import from somewhere else, i suppose)
13:25:08 <LearnerGuy> Quick question: Suppose we have the following program:
13:25:13 <LearnerGuy> main = do
13:25:14 <LearnerGuy>           userInput <- getLine
13:25:14 <LearnerGuy>           putStrLn $ "The number of uppercase letters is " ++ show (countUpper userInput) ++ ".\n"
13:25:45 <LearnerGuy> where countUpper :: String -> Int and it works and the program works
13:26:30 <LearnerGuy> Is there a way to use sorta point free using binding operators the same functionality without introducing the "userInput" variable?
13:27:21 <hpc> @undo do {userInput <- getLine; putStrLn $ "The number of uppercase letters is " ++ show (countUpper userInput) ++ ".\n"}
13:27:21 <lambdabot> getLine >>= \ userInput -> putStrLn $ "The number of uppercase letters is " ++ show (countUpper userInput) ++ ".\n"
13:27:26 <hpc> @pl getLine >>= \ userInput -> putStrLn $ "The number of uppercase letters is " ++ show (countUpper userInput) ++ ".\n"
13:27:27 <lambdabot> putStrLn . ("The number of uppercase letters is " ++) . (++ ".\n") . show . countUpper =<< getLine
13:27:53 <hpc> LearnerGuy: or to put it more succinctly, "there is but you don't want to use it"
13:27:54 <ski> .. that's probably what i'd write, if i were to pointless it
13:28:16 <ski> (that's actually fairly readable, unlike what `pointless' commonly delivers)
13:28:41 <hpc> pointless only really explodes on terms that don't typecheck
13:28:55 * hackagebot hapstone 0.1.0.0 - Capstone bindings for Haskell  https://hackage.haskell.org/package/hapstone-0.1.0.0 (ibabushkin)
13:28:58 <hpc> anyway, i would use printf if i was forced to make that better
13:29:06 <hpc> i would be fairly happy with it as is
13:29:12 <LearnerGuy> hmm, thanks for the code, I'll try to understand it because I need to understand statements like that
13:29:28 <sleblanc> LearnerGuy, I find this site pretty useful once in a while: https://blunt.herokuapp.com/#input=printMyInput%20%3D%20getLine%20%3E%3E%3D%20\s%20-%3E%20putStrLn%20%24%20%22The%20number%20of%20uppercase%20letters%20is%20%22%20%2B%2B%20show%20%28countUpper%20s%29%20%2B%2B%20%22.\n%22
13:30:02 <sleblanc> You have to re-write your stuff in the format of a function (easy if you use lambdas)
13:30:15 <kartrel> http://lpaste.net/158452 look at that :D I actually completed this task (give a list and return the largest value in that list) without any compilation errors. I'm starting to understand how this language works
13:31:07 <kartrel> even though I'm quite drunk already :D
13:31:08 <LearnerGuy> Thanks for the heads up sleblanc :)
13:31:24 <wedify> LearnerGuy: I believe in Idris you can prefix with '!' to get the behavior you want. pity haskell doesn't have something similar
13:31:40 <LearnerGuy> WOuld it need it though?
13:31:48 <wedify> it'd be nice
13:31:59 <wedify> i hate extraneous variables
13:32:45 <ski> kartrel : you can factor the body of the recursive defining equation into `largest rest1 (if front1 >= biggest then front1 else biggest)'
13:33:06 <ski> kartrel : and then there's a nice way to rewrite that `if'-expression into something nicer :)
13:33:24 <ski> wedify : how does that work ?
13:34:14 <LearnerGuy> Yeah, I would think ? and : are in the spirit of the language
13:34:30 <sleblanc> LearnerGuy, there's a function that will return the larger of its two parts
13:35:00 <wedify> ski: putStrLn $ "the number of upper is" ++ show !getline
13:35:16 <geekosaur> eww
13:35:23 <sleblanc> :< this makes me sad
13:35:28 <wedify> er, show (countUpper !getLine)
13:35:45 <sleblanc> wedify, what if there are multiple IO actions? in what order are they evaluated?
13:36:27 <sleblanc> e.g. putStrLn $ "the number of uppers are " ++ show !getline ++ " and " ++ show !getline
13:37:23 <ski> presumably in the order they appear, textually
13:37:32 <ski> at least that's what my reflective syntax does
13:37:43 <kartrel> growingorder (front1:rest1) = if front1 <= (rest1 one's front) how'd I do that? (the question is that i'd have to say true or false whether a specific list is growing, as in [1,1,4,6,8,9] would equal true and [1,2,4,1,8,9] would equal false
13:38:01 <rindolf> Hi all! I wish to translate this Perl 5 code I wrote to GHC/Haskell (in order to try to make it run faster that way) - https://metacpan.org/release/Games-Solitaire-Verify . Now, the program itself maintains an active solitaire board layout (the Games::Solitaire::Verify::State class) and applies moves on it. Should I do it as a monad? Should I reuse an existing monad (e.g: the Haskell State monad)? Or should I just accept an old 
13:38:02 <rindolf> solitaire layout and return a new one (plus possibly other stuff)?
13:38:20 <ski> kartrel : you can say `growingorder (front1:front2:rest) = ...'
13:38:38 <ski> kartrel : be sure to handle all cases, though
13:38:43 <sleblanc> kartrel, watch out though for the last element of the list
13:38:50 <sleblanc> what ski said
13:39:19 <kartrel> is front1:front2:rest as in [1,2,3,4,5,6,7] -> front1=1, front2=2, rest=3,4,5,6,7 ?
13:39:48 <ski> kartrel : also, if you care for it, you could consider my above comments for improvement regarding `largest'
13:39:49 <wedify> sleblanc: i'm not sure how idris does it. I just saw the notation in one of the tutorials
13:40:02 <ski> kartrel : yep, modulo syntax errors
13:40:17 <ski> > let front1:front2:rest = [1,2,3,4,5,6,7] in (front1,front2,rest)
13:40:19 <lambdabot>  (1,2,[3,4,5,6,7])
13:40:22 <kartrel> well that's really useful :D thanks ski. sleblanc does that mean i'd have do use a try, except clause too?
13:40:54 <ski> kartrel : we express the ability to say `front1:front2:rest' here as : patterns nest/compose
13:41:12 <sleblanc> kartrel, it depends on your definition of growing; you can consider a singleton list as undefined in its growth
13:41:16 <ski> kartrel : no "try, except" thing. just cover all cases
13:41:32 <ski> sleblanc : clearly `[1]' is a growing list
13:41:50 <ski> there is no instance of a latter element being less than an earlier element
13:41:52 <sleblanc> ski, prove it
13:41:57 <ski> there ^
13:42:07 <sleblanc> Then that is your definition
13:42:10 <ski> (ahead of you :)
13:42:13 <kartrel> ski, but if we have a list of just one item, that would still be growing (let's not go philosophical into this question) but using front1:front2:end would cause an error?
13:42:42 <sleblanc> If my definition is that for all items in the list, the preceding item is either smaller or equal to the current item, then this definition is incompatible with single-item lists
13:43:21 <ski> sleblanc : definition would be : `xs' is growing iff, for any indices `i' and `j' (for which `xs !! i' and `xs !! j' are defined) : if `i <= j', then `(xs !! i) <= (xs !! j)'
13:43:56 <ski> sleblanc : i think this adheres quite well to the usual definition of "increasing function". the function here is the function `(xs !!)' you get by indexing the list
13:44:15 <sleblanc> ski, that's a definition I would agree with
13:44:49 <ski> note that with this definition, singleton lists are growing
13:45:15 <ski> the only applicable index is `0', and `0 <= 0', and `(xs !! 0) <= (xs !! 0)' as well
13:45:20 <kartrel> the question in question (no pun intended) is that you'd give a list, and you'd tell if it's in a rising order (integers), where you can have several of the same integer in a row (example: [1,1,1,1,1,2,3] would be in a rising order)
13:45:32 <fabian___> Cale: Hi again
13:45:41 <ski> kartrel : *nod*
13:45:56 <ski> (that agrees with my definition)
13:46:42 <kartrel> I'm just somewhat peculiar about what happens in a list of just one value when you use front1:front2:end for that?
13:46:47 <ski> sleblanc : in your terms : for any adjacent pair, the latter element is at least as "high" as the former one
13:47:11 <ski> sleblanc : in the case of singleton list, there's no adjacent pair, so then the "for any adjacent pair, ..." holds trivially, so it's true also then
13:47:19 <ski> (i hope that helps)
13:47:32 <jpfuentes2> does anyone know if there's an easy way to circumvent the tag modifier when encoding/decoding sum types via Aeson?
13:47:43 <nitrix> monochrom: Still here?
13:47:57 <EvanR> jpfuentes2: you can implement your own instances
13:47:59 <ski> kartrel : "if we have a list of just one item, ... but using front1:front2:end would cause an error?" -- yes, that's what i mean by you having to conver all cases
13:48:13 <jpfuentes2> EvanR: yep, i was hoping for something less pedestrian
13:48:14 <jpfuentes2> :(
13:48:22 <EvanR> thats kind of what theyre for
13:48:32 <jpfuentes2> thx
13:48:34 <Cale> fabian___: hello
13:48:34 <ski> kartrel : or rather, *just* using `front1:front2:end' would cause an error
13:48:43 <nitrix> monochrom: So my original question was, given a rank-1 polymorphic function, foo :: forall a. a -> a
13:49:09 <kartrel> ski, yeah -> i was initially talking about using some sort of try/catch or try/except but apparently there's no such thing in haskell?
13:49:22 <EvanR> :t try
13:49:22 <ski> kartrel : there is, but there's no need for that here
13:49:23 <lambdabot> Exception e => IO a -> IO (Either e a)
13:49:25 <sleblanc> ski, thanks. I'm always looking to further my sense of logic.
13:49:37 <sleblanc> (learning Haskell is good for this, IMO)
13:49:49 <nitrix> monochrom: What would a rank-2 function (more specifically the universal quantification) look like? bar :: forall z. (forall z. z) -> x
13:50:26 <ski> sleblanc : you should be able to work out for yourself what result the empty list should yield, from the definition. (but please refrain from mentioning it here now. kartrel is still writing their function)
13:50:30 <sleblanc> jpfuentes2, or you could write a functor that maps from one to the other
13:50:33 <nitrix> This is me abstracting the polymorphic function behind its own type.
13:50:47 <EvanR> forall x . (forall z. z) -> x ?
13:50:52 <nitrix> Pyon mentioned Impredicative Types and System F, I'm a little lost.
13:50:55 <merijn> kartrel: We do have exceptions in GHC, but, they're never used for "control-flow", becayse that's better handled using Maybe/Either/lists. They're really pretty much only used for unchecked exceptions (i.e. filesystem errors, network disconnects, that sorta stuff)
13:51:12 <kartrel> ski, but if we still need to check with: largest (front1:front2:rest) biggest = if front1 >= front2 then largest rest1 front 1 else largest rest 1 biggest ?
13:51:17 <sleblanc> jpfuentes2, that is, rewrite the tag and contents keys to something else, if applicable
13:51:23 <nitrix> EvanR: Is `z` in this allowed to be (forall a. a -> a) ?
13:51:28 <ski> nitrix : `bar :: forall x. (forall z. z) -> x' (note the fix !) would be a signature for a rank-2 function
13:51:31 <merijn> nitrix: I have a good example :)
13:51:48 <EvanR> nitrix: z needs to be provided some concrete type, i believe. 
13:51:49 <ski> nitrix : `bar2 :: (forall z. z) -> Int' would be another rank-2 function
13:51:52 <jpfuentes2> thanks sleblanc 
13:51:57 <merijn> nitrix: Rank2 example: https://gist.github.com/merijn/77e3fa9757658e59b01d
13:52:02 <kartrel> as far as i've understood, what i just have shown would work, except once it gets to a 1 int list
13:52:03 <rindolf> Can anyone answer my question?
13:52:15 <merijn> nitrix: Including an example where it's required :)
13:52:22 <EvanR> nitrix: so Char -> Char would work
13:52:37 <ski> merijn : nice :)
13:52:45 <sleblanc> Aw. So the day I am trying out Yesod, the site mysteriously stops functioning
13:52:46 <nitrix> merijn: I haven't clicked yet, but the rank 2 I grasp. The fact that the polymorphic function that's accepted as an argument can be hidden behind its own type throws me off.
13:52:52 <merijn> ski: Simplest possible example I could find that made sense
13:53:02 <ski> kartrel : yep
13:53:04 <nitrix> merijn: Suddently, do you have rank-2 type variables :P ?
13:53:13 <dolio> What does "hidden behind its own type" mean?
13:53:23 <merijn> nitrix: With Rank2 the question is "Who picks the instantiations of a type variable"
13:53:23 <EvanR> sounds like youre thinking of it as more complex than it is
13:53:25 * ski hides behind the type of someone else
13:53:25 <nitrix> dolio: type Wrapper = a -> a
13:53:46 <ski> that's bad code
13:54:04 <merijn> nitrix: The first example in my gist has the caller pick 'a', which is why it allows "Int -> Int" as argument, which won't work (for hopefully obvious versions)
13:54:06 <fabian___> merijn: I think you know this kind of stuff :) Cale wrote me a nice typeclass for casting existentials with a type parameter, similar to Data.Dynamic. However, im struggeling to figure out how to extend that to be able to cast STRefs in the same way
13:54:15 <ski> (well, iirc GHC will expand it to `type Wrapper = forall a. a -> a', which is ok, with extensions)
13:54:29 * ski doesn't like this implicit expansion
13:54:33 <merijn> nitrix: The Rank2 version let's the callee decide the value of 'a', which means the argument function MUST be "Num a => a -> a" (i.e. work for all a's)
13:54:42 <nitrix> Obviously, I'm just pushing to the extreme of what I know (this is how you learn).
13:54:55 <nitrix> And someone pointed at impredicative types.
13:55:02 <merijn> But it's bed time for me, instead of discussing time :)
13:55:17 <nitrix> merijn: Checking
13:55:22 <kartrel> so what would then be the best choice here? I'm getting, let's say, somewhat confused about how this should be implemented since what i've described should work once it has a try/except thing added to it (and I don't know really how to do it without one)
13:55:28 <dolio> nitrix: I don't know how that answers my question. :)
13:55:34 <ski> nitrix : i'm not seeing how impredicative types are relevant here
13:56:44 <EvanR> nitrix: i think to get rank 2 you really need to internalize rank 1, i.e. where foralls make sense normally and what they mean at compile time. foralls are like simple type lambdas, and they need to be provided a type before they can be used for something
13:56:52 <pyon> Don't impredicative variables let you instantiate “a” in “Foo = forall a. Bar a” with “Foo” itself?
13:57:04 <EvanR> but when you use rank 2, you can pass such functions in as arguments prior to their types being decided
13:57:12 <ski> kartrel : consider your earlier <http://lpaste.net/158452> (which you btw hasn't shown that you've read my additional advice for). here you have two "defining equations" for `largest', two cases which together define `largest', handling different possible "shapes" of the input list, together handling all cases
13:57:12 <pyon> impredicative types*
13:57:14 <EvanR> and then they are decided later
13:57:28 <Cale> pyon: Impredicative types are things like Maybe (forall a. [a] -> [a])
13:57:33 <dolio> pyon: Yes.
13:57:50 <ski> kartrel : in your `growingorder' you similarly just need to cover all possible cases. no need to think in terms of "try, catch"
13:57:52 <Cale> pyon: instantiating a type parameter with a polymorphic type
13:57:58 <pyon> Ah.
13:58:11 <dolio> That's not the real definition of impredicativity. It's the bastardized GHC definition.
13:58:18 <nitrix> If there's so Wrapper type, you'd need it, though, no?
13:58:22 <EvanR> nitrix: but in the end, before any polymorphically typed function can be used rank 1 or 2 or whateevr, that type has to be "instantiated" with some "monotype" (not polymorphic type)
13:58:22 <nitrix> Oh :/
13:58:40 <kartrel> ski, so basically, go through the ones that can't have any errors happening and after that the ones that can create errors?
13:58:45 <EvanR> rank 2 lets you defer the choice
13:59:03 <EvanR> its confusing because you dont ever do this instantiation explicitly
13:59:07 <EvanR> so its kind of invisible
13:59:10 <nitrix> How do you guys learn these things baffles me.
13:59:11 <kartrel> although, for that i'd need to know if the list has exactly 2 elements in it
13:59:20 <kartrel> so should i go for a if clause?
13:59:20 <EvanR> i had to learn all this from the mailing list
13:59:52 <fabian___> Cale: hello
13:59:55 <ski> kartrel : don't think in terms of "can create errors". think in terms of "covering all possible cases". your `growingorder (front1:front2:rest) = ...' defining equation will only handle lists of length at least two (can you see why ?)
13:59:56 <pyon> EvanR: It would be a lot less confusing if Haskell separated second-class (ML-style, implicit) polymorphism from first-class polymorphism (explicitly applying functions of types).
14:00:00 <sleblanc> kartrel, a function can match multiple list items: f (x1:x2:xs) = ...
14:00:03 <nitrix> EvanR: I feel like I'm learning most of Haskell's type system from remembering by heart, rather than building an understanding and observing its natural conclusion.
14:00:09 <ski> kartrel : you also need to handle lists of different lengths
14:00:16 <Cale> fabian___: ask a question
14:00:25 <Cale> :D
14:00:32 <EvanR> nitrix: there sort of is an explanation of rank 2 in the GHC manual ...
14:00:32 <ski> sleblanc : yes, we've got that far :)
14:00:58 <Cale> dolio: right.
14:00:59 <fabian___> Cale: You wrote me that nice Entity typeclass a week ago (sort of like Dynamic) I want to extend it to work with STRefs
14:01:22 <kartrel> ski, so far I know only how to exactly go through lists with 2 or more items in them, so i'd need to do some sort of 'exception' or thing before that for lists with exactly two items
14:01:46 <ski> kartrel : remember you wrote
14:01:48 <ski>   largest [] biggest = biggest
14:01:52 <ski> kartrel : earlier ?
14:02:04 <kartrel> yup
14:02:09 <fabian___> Cale: http://lpaste.net/6487756427996692480
14:02:15 <ski> kartrel : that is exactly "some sort of 'exception' or thing"
14:02:44 <kartrel> but that's only for a list with 0 in it? I'd still need to check the lists with just 1 in it?
14:02:49 <EvanR> pyon: on one hand, this stuff is helluva confusing... but on the other hand it really does indicate common classes of ways you would consider dynamic code as "working in any situation" which were not used to really understanding on any real level (in a dynamic language with functions)
14:02:59 <Cale> fabian___: right
14:03:01 <ski> kartrel : in that case, that defining equation handles lists of length zero, while the other defining equation there (`largest (front1:rest1) biggest = ...') handled lists of length at least one
14:03:18 <Cale> fabian___: Well, STRefs of a fixed type of value would be a reasonable instance.
14:03:21 <ski> kartrel : together, these to make `largest' able to handle lists of any length
14:03:27 <Cale> fabian___: but you'd need to newtype that
14:03:34 <Cale> because the arguments are in the wrong order
14:03:35 <EvanR> just one way that haskells type system helped me understand new ways to think about dynamic code
14:03:49 <ski> kartrel : the situation with your `growingorder' here is exactly analogous. except that you have more than two different cases
14:03:57 <pyon> EvanR: What I'm saying is that rank-2 and rank-N polymorphism should be done by explicitly applying functions of types, as in System F-omega.
14:05:03 <dolio> That isn't always the way System F(_omega) is presented, though.
14:05:19 <kartrel> in [0,1,2,3,4] in order to know that 0 is of the type growingorder i'd need to check 1, so in order to use this type (as in front1:front2:rest) i'd need to know that there's at least 2 in the list
14:05:30 <EvanR> pyon: it should at least be an option, that really helps in idris to see the type being passed in as the implement argument... explicitly
14:05:39 <EvanR> the implicit*
14:06:35 <dolio> Also, there are intuitions behind the implicit version that are interesting and fundamental to understand.
14:07:34 <EvanR> nitrix: one notation that helped me is... instead of forall you have....  /\a . a -> a
14:08:10 <nitrix> That's the same thing ._.
14:08:14 <EvanR> and in one use case you may have id "used at Char" and itd look like `id Char 'x'` evals to 'x'
14:08:26 <EvanR> id Int 'x' is a type error
14:08:30 <EvanR> and id 'x' is a type error
14:08:47 <sleblanc> kartrel, try to find a recursive definition of a growing list
14:09:24 <nitrix> EvanR: I'm not sure how the latter would be a type error.
14:09:27 <sleblanc> kartrel, in terms similar to "... if the first two items <something something> and this condition holds for the rest of the list"
14:09:47 <nitrix> EvanR: Does your notation /\a changes the meaning of forall ?
14:10:10 <EvanR> nitrix: so the final type is like (t:Type) -> t -> t
14:10:13 <EvanR> it has 2 arguments not 1
14:10:32 <EvanR> 'x' isnt a Type so
14:11:01 <nitrix> How is it helpful though?
14:11:20 <maerwald> mh, I forgot how you properly convert ByteString to String, there was a library with encoding crap for that, no?
14:11:25 <EvanR> because you know that some type must be chosen at some point, this makes the rank 2 argument make sense
14:11:46 <EvanR> maerwald: do you mean decode? or encode the bytestring into a string form
14:11:59 <nitrix> It seems like a mental overhead to me. The type must always be specialized at some point.
14:12:28 <EvanR> nitrix: right
14:12:31 <nitrix> The idea of an "implicit type argument" seems more confusing to me :/
14:12:55 <dolio> In some styles it's not implicit.
14:13:23 <dolio> Presumably in EvanR's, which is why it's a type error. You provided a char where a type was expected.
14:13:36 <ski> kartrel : as you remove elements from the front of the list, eventually you'll reach a list with less than two elements. so if you don't handle that case, your recursion will fail
14:14:19 <EvanR> nitrix: this stuff is actually going on invisibly, so if you think its more natural to ignore it, ok. but it sounds like its more confusing to pretend its not there ;)
14:14:21 <ski> kartrel : iow, "in order to use this type (as in front1:front2:rest) i'd need to know that there's at least 2 in the list" is correct, but you also need to consider the remaining kinds of lists, to have a working definition
14:14:59 <nitrix> EvanR: So, you're saying, I should think of universal quantification as a type parameter?
14:15:18 <dolio> EvanR: But it's important to also understand that it's not going on invisibly in some views. It's not going on at all.
14:15:44 <EvanR> im say you could think of it like that in order to pretend poly types are normal types
14:15:53 <EvanR> which helps me understand rank 2
14:16:04 <EvanR> dolio: in what ways/styles is it not happening at all?
14:16:16 <dolio> Curry-style.
14:16:36 <dolio> What you are describing is Church-style, where everything is fundamentally typed from the start.
14:16:42 <kartrel> ski, but the following is not possible http://lpaste.net/158455 ?
14:17:16 <EvanR> intriguing, id like to really know the difference
14:17:21 <dolio> But the Curry-style view takes the untyped lambda terms as a starting point, and defines types as collections of untyped terms.
14:17:54 <EvanR> which way do you think haskell is?
14:18:25 <dolio> And the type 'forall a. a -> a' describes the intersection of all the collections A -> A for all choices of A.
14:19:12 <EvanR> eh......
14:19:15 <dolio> And terms of type 'forall a. a -> a' can be used at any particular 'A -> A' because they are guaranteed to also exist in that type. But there is no passing the types around.
14:19:47 <EvanR> now that confuses me
14:19:56 <pyon> dolio: Is that POV really tenable, considering type reconstruction is undecidable for System F(-omega)?
14:19:56 <dolio> This is the view taken by things like PER and realizability models.
14:20:02 <EvanR> if something takes (A -> A) as argument, how can you use a forall a . a -> a
14:20:36 <EvanR> if the forall a . a -> a term might be a Char -> Char
14:20:40 <dolio> pyon: Reconstruction is another topic.
14:21:19 <dolio> The type `forall a. a -> a` is the intersection of `Char -> Char` and `Int -> Int` and ....
14:21:37 <EvanR> how is that not an empty intersection...
14:21:42 <pyon> EvanR: id?
14:21:49 <dolio> Because the identity function is in all of those.
14:21:53 <EvanR> oh
14:22:01 <EvanR> its "the same function"
14:22:10 <pyon> EvanR: It's the same untyped term.
14:22:11 <dolio> Yes. It is an untyped lambda term that can be given all those types.
14:22:17 <pyon> EvanR: “\x -> x”
14:22:27 <EvanR> why does this weird me out
14:22:39 <dolio> Anyhow, you asked which I think Haskell is.
14:22:43 <dolio> And that's not an easy question.
14:22:56 <EvanR> because id arrows on each object are not the same
14:22:59 <dolio> Because it's like both in some ways.
14:23:08 <pyon> dolio: If you're explicitly type-annotating definitions, then you aren't really programming in a Curry-style System F-omega. It's not really honest to say you can program in a Curry-style System F-omega.
14:23:13 <dolio> [] :: forall a. [a]
14:23:36 <EvanR> well, at runtime theres one []
14:23:43 <dolio> This is kind of like Curry style, because it gets compiled to a single [] that works for all a.
14:23:52 <EvanR> but ignoring that you can say there is one [] for each type
14:23:55 <dolio> [1] :: forall a. Num a => [a]
14:24:10 <ski> kartrel : it's possible, but unnecessary
14:24:15 <dolio> This is kind of like Church-style, because it's a different [1] for each a.
14:24:28 <nitrix> EvanR: I'm ignoring the noise because I need to focus and I like your view, although it's unatural to me. So you're suggesting me to think of function application as if `id Char 5` was doing some sort of `forall a. (TYPE -> a -> a)` to `(Char -> Char)` conversion?
14:24:35 <kartrel> okay
14:24:57 <ski> kartrel : if `length (front:end) == 1' (not `=') is `True', then that means that `end = []', and so you could say instead `growingorder (front:[]) = ...'
14:24:59 <nitrix> EvanR: Or sorry, more like, the forall _itself_ is an argument?
14:25:00 <dolio> EvanR: You can say that, but then you have missed out on understanding something interesting. :)
14:25:09 <ski> kartrel : or shorter, `growingorder [front] = ...'
14:25:17 <EvanR> nitrix: the a is the argument and the forall is the lambda
14:25:18 <pyon> dolio: And I'm not even sure the intuition of “forall as intersection” and “exists as union” would work when you move to higher-rank types.
14:25:31 <dolio> pyon: It does.
14:25:34 <EvanR> dolio: i retroactively did understand this view, which is how lisp works
14:25:48 <EvanR> so i reject it as a basis for understanding haskell ;)
14:26:30 <EvanR> and types-as-set theory is annoying!
14:26:32 <ski> kartrel : if you insist on checking explicitly, then you can say
14:26:35 <ski>   growingorder [] = True
14:26:41 <ski>   growingorder (front:end)
14:26:49 <ski>     | length (front:end) == 1  = True
14:26:57 <ski>   growingorder (front1:front2:end) = ...
14:26:58 <EvanR> rather sets as type theory
14:27:03 <dolio> The intersection-union stuff also gives a subtyping relationship via inclusion, which is the same one given by instantiation.
14:27:09 <pyon> EvanR: Types as sets is okay, as long as you're working with structural sets, not material sets.
14:27:27 <EvanR> this is all really using material sets
14:27:47 <dolio> EvanR: You can't use sets anyway, because higher-rank, impredicative types admit constructions that don't work out in sets.
14:27:53 <dolio> At least naively.
14:27:57 <ski> kartrel : the `| ...' part here is called a "guard". that defining equation only applies in case the guard expression evaluates to `True'. it's possible to attach more than one guard to a defining equation. they're tried in order. if the last guard fails, then the next defining equation (if any) is tried
14:28:11 <EvanR> dolio: yes.. i suspect this from time to time and can never prove it when i need to
14:28:45 <nitrix> EvanR: So to think of `forall a. a -> a` as some kind of `\a -> (a -> a)` ?
14:28:55 <nitrix> EvanR: If there was such thing as type lambdas?
14:28:56 <EvanR> whats an example of a higher rank impredicative types?
14:28:58 <pyon> nitrix: Errr, no.
14:29:10 <dolio> Actually, that's kind of a problem only for the Church-style model, where you'd naively expect `forall a. a -> a` to be a product over all types.
14:29:11 <EvanR> nitrix: thats mixing types and terms...
14:29:17 <dolio> Products are too big.
14:29:23 <ski> kartrel : however, `length list == 1' can better be expressed as `not (null list) && null list'. in this case, since `list' is `front:end', the latter would become just `null end' (`null' checks whether a list is empty)
14:29:29 <ski> kartrel : the point is that `length' computes the length of the whole list, which is unnecessary (and wasteful) to do everytime we're checking whether we're done yet
14:29:29 <dolio> But thinking about it as an intersection makes it small.
14:29:37 <nitrix> pyon: EvanR Well there's no syntax that exist for what we want to describe, does it?
14:29:52 <EvanR> nitrix: i suggested id :: (t:Type) -> t -> t
14:30:06 <EvanR> which is mixing dependent types and haskell, so sorry about that ;)
14:30:12 <nitrix> EvanR: We agree that it's just pattern substitution?
14:30:26 <pyon> nitrix: I had no objection to your syntax. I understood “\a -> (a -> a)” to be a (confusing) made-up notation for a type lambda notation that maps “a” to “a -> a”.
14:30:37 <EvanR> when you instantiate a polytype, its substituting the type variables with some type
14:30:39 <pyon> nitrix: But “forall a. a -> a” isn't the same thing as “lambda a. a -> a”.
14:30:41 <ski> kartrel : however, in this case, i'd go for the guard-less version (just using pattern-matching, `growingorder [front] = ...'). it's simpler ..
14:30:56 <nitrix> pyon: Oh I see were you're coming from.
14:31:10 <EvanR> nitrix: /\a . a -> a, you see this sometimes instead of forall, thats a capital lambda
14:31:20 <pyon> nitrix: They don't even have the same kind. “forall a. a -> a” has kind *, whereas “lambda a. a -> a” has kind “* -> *”.
14:31:20 <EvanR> its on a different level from value-lambdas
14:31:24 <nitrix> I see.
14:31:44 <nitrix> I always thought lambda meant abstractions (substitutions).
14:31:45 <EvanR> pyon: forall a . a -> a has kind * for all a
14:31:52 <EvanR> nitrix: yes thats what this is
14:31:57 <nitrix> Regardless of it being a value or a type, I thought it'd still be applicable.
14:31:58 <kartrel> ski, i'll need something to work with, growingorder [] = true is still the starting point, growingorder (front1:front2:end) or growingorder (front:end) the next one?
14:32:05 <pyon> EvanR: Your “for all a” is unnecessary.
14:32:05 <EvanR> preparation for substitution
14:32:14 <pyon> EvanR: “forall a. a -> a” has kind *, period.
14:32:19 <ski> nitrix : a value of type `forall a. a -> a' would then be `/\ a -> \(x :: a) -> x'. here `/\' is a type-lambda
14:32:23 <EvanR> pyon: its not.. according to me because forall a . a -> a isnt a particular type
14:32:35 <pyon> EvanR: System F-omega disagrees.
14:32:42 <pyon> EvanR: “forall a. a -> a” is a very specific type.
14:32:52 <EvanR> ok... its not a object of Hask ;)
14:32:52 <ski> kartrel : the ordering doesn't matter here. since there is no overlap between the cases
14:32:58 <nitrix> ski: I didn't know there was such thing as type lambda.
14:32:59 <pyon> EvanR: The type of functions that map types (of kind *) to their identity functions.
14:33:01 <EvanR> were talking about different kinds of types here
14:33:07 <ski> nitrix : there isn't in Haskell
14:33:08 <kartrel> ok
14:33:13 <EvanR> which is probably annoying everyone
14:33:39 <kartrel> so it doesn't cause an error if i'd have growingorder (front1:front2:end) before (front:end) ?
14:34:07 <EvanR> system F terms-at-the-type-level vs haskell has a collection of (mono)types and functions between them
14:34:16 <ski> kartrel : er, sorry. `front:end' does in fact overlap with `front1:front2:end' .. i was thinking you said `front:[]' instead of the former
14:34:34 <ski> kartrel : if you use the `front:end' version, then ordering does matter
14:34:48 <ski> (more specific cases should come before less specific ones)
14:34:59 <dolio> pyon: Anyhow, type reconstruction is kind of ancillary to the calculus. If you're presenting type theory super formally, it's going to be with typing derivations. Reconstruction is a separate issue.
14:35:16 <monochrom> order matters. but "wrong" order is not a compile-time error. you may get wrong answers, that's all.
14:35:21 <ski> yes
14:35:51 <dolio> And the difference is like `G |- (/\a. \(x:a) -> x) : forall a. a -> a` Church style vs. `G |- (\x -> x) : forall a. a -> a` Curry style.
14:36:45 <pyon> dolio: In practice people write programs, and the type checker has to figure out the (most general) typing derivation. Or at least that's how I'd like things to work.
14:36:54 <EvanR> im really glad that there are more than 1 ways to think of this stuff, yet another evidence contradicting the common understanding of the stereotypical haskell nerd who refuses to see things any other way but 1
14:38:07 <pyon> dolio: If I have to write the typing derivation myself, then I'm using a different programming language, in which what you call a “typing derivation” is the program itself.
14:38:57 <dolio> Yes, but convenient machine tooling is a separate issue from two separate ways of fundamentally thinking about the syntax and semantics of the formal system.
14:39:21 <maerwald> EvanR: I'm struggling with GlibString, which is a weird typeclass that doesn't work well with ByteString
14:39:24 <EvanR> maybe sometimes we get too preoccupied with programming and doing anything useful to appreciate the pure math ;)
14:40:02 <EvanR> maerwald: wth is GlibString
14:40:13 <maerwald> from the glib library
14:40:30 <dolio> EvanR: But it has implications for practical matters, like the list examples.
14:40:41 <maerwald> the conversion from String to ByteString broke a few gui functions 
14:40:59 <maerwald> these are not critical, but they are for... well, showing filepaths in the gui
14:40:59 <EvanR> it looks like GlibString is mainly concerned with CStrings
14:41:07 <EvanR> youll need to use the FFI i guess
14:41:15 <kartrel> what I've understood is that people use haskell because the code is so easy to understand?
14:41:16 <maerwald> that won't work properly
14:41:22 <EvanR> readCString :: CString -> IO String
14:41:29 <maerwald> yes, that won't work
14:41:33 <EvanR> heh
14:42:03 <maerwald> those are glib bindings and I don't have enough control over callbacks to stuff in monad computation there
14:42:07 <EvanR> FilePath issues sounds like a hornets nest 
14:43:19 <maerwald> EvanR: https://hackage.haskell.org/package/gtk-0.14.2/docs/Graphics-UI-Gtk-ModelView-CustomStore.html#v:treeModelSetColumn the third argument cannot be "row -> IO String"
14:43:46 <maerwald> and I'm not going to use unsafePerformIO
14:44:18 <EvanR> takes a row and computes a ty
14:44:27 <maerwald> yes, ty cannot be "IO String"
14:44:37 <EvanR> why does it need to be
14:44:58 <maerwald> ty is basically of type "GlibString ty => ty"
14:45:26 <EvanR> oh, so you need to create a GlibString , not convert one into something
14:45:26 <maerwald> that is defined earlier via other glib functions, and there's no way to define it in another way
14:45:59 <EvanR> Text and String are both instances of GlibString
14:46:06 <maerwald> ByteString not :D
14:46:19 <EvanR> which makes sense
14:46:31 <EvanR> because its not a text type
14:46:38 <EvanR> but you can implement the instance anyway
14:47:27 <EvanR> or implement the instance for your new FilePath newtype
14:48:00 <orion> Is there a more idiomatic way of converting a pair of Word8s to a single BE Word16 in Attoparsec?
14:48:04 <EvanR> or dont use FilePaths as text values in GTK, convert to a String
14:48:14 <fabian___> Cale: hmm
14:48:33 <EvanR> w1 `shiftL` 8 .|. w2
14:48:40 <orion> shift (fromIntegral l0) 8 + fromIntegral l1 :: Word16 <-- What I'm doing currently.
14:48:43 <fabian___> Cale: http://lpaste.net/3073907479566876672
14:49:26 <EvanR> you can put the fromIntegrals on another two lines or rename fromIntegral to `fI' or something locally
14:49:58 <EvanR> or parse a Word16 BE in the first place if possible
14:50:20 <talzs> Can Haskell's type system express equality between two type variables? For instance, (++) has a type [a] -> [a] -> [a], but is there a way to express the type as [a] -> [b] -> [b] by telling Haskell that b is equivalent to a? I know it's not particularly useful, I'm just curious is all
14:50:42 <orion> EvanR: I didn't see a function to do that in the docs.
14:50:49 <dmj`> a ~ b
14:51:30 <Cale> fabian___: btw, you already could have made EnvironmentRef an instance of Entity, even if it used STRef
14:51:49 <Cale> (similarly with EntityRef etc.)
14:52:34 <Cale> fabian___: Also, what's with the unsafePerformIO?
14:53:02 <Cale> fabian___: You definitely don't want to be doing that in the long term
14:53:19 <dmj`> @def g :: a ~ b => [a] -> [b]; g = undefined
14:53:20 <lambdabot>  Defined.
14:53:40 <dmj`> @typ (g (undefined :: [Int]) :: [String])
14:53:42 <lambdabot>     Ambiguous occurrence ‘g’
14:53:42 <lambdabot>     It could refer to either ‘L.g’,
14:53:42 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:154:1
14:53:53 <fabian___> Cale: I just wanted to interleave IO and ST in an easy way
14:53:56 <EvanR> orion: me neither, at the very least you can write a word16BE parser yourself and reuse it
14:54:19 <Cale> fabian___: If something needs to do IO, then it should be an IO action, not an ST action.
14:54:36 <orion> EvanR: True
14:54:40 <Cale> You can run ST actions from IO actions, but the other way around will get you into trouble
14:54:46 <fabian___> Cale: right :) but if you want interleaved monads you  want a transformer stack right?
14:54:51 <dmj`> @def ggg :: a ~ b => [a] -> [a] -> [b]; g = undefined
14:54:52 <lambdabot>  .L.hs:156:1:
14:54:52 <lambdabot>      The type signature for ‘ggg’ lacks an accompanying binding
14:54:52 <lambdabot>  
14:54:52 <Cale> huh?
14:55:00 <dmj`> @def ggg :: a ~ b => [a] -> [a] -> [b]; ggg = undefined
14:55:01 <lambdabot>  Defined.
14:55:06 <Cale> fabian___: I don't understand exactly what you mean by "interleaved" I think.
14:55:23 <EvanR> orion: sometimes there are packages with a bunch of these parsers already written, to go with parsec or attoparsec or something else... but i didnt see one for this
14:55:28 <dmj`> @typ ggg (undefined :: [String]) (undefined :: [Int])
14:55:29 <lambdabot>     Couldn't match type ‘Int’ with ‘[Char]’
14:55:30 <lambdabot>     Expected type: [String]
14:55:30 <lambdabot>       Actual type: [Int]
14:55:35 <dmj`> @talzs: ^
14:55:35 <lambdabot> Unknown command, try @list
14:55:46 <fabian___> Cale: like humanSentientAct, it goes like ST -> IO -> ST
14:55:48 <dmj`> talzs: ^
14:56:19 <Cale> fabian___: Except it doesn't really, it's morally an IO action which is being disguised as an ST action.
14:56:46 <fabian___> Cale: Ill do it the right way in a bit :)
14:57:05 <Cale> fabian___: which will sort of work, but now you're at the whim of the compiler's optimiser with respect to when/if the IO actually occurs and such.
14:57:25 <kartrel> isSorted xs = and $ zipWith (<=) xs (tail xs), could someone explain how and and $ works in this case?
14:57:38 <Cale> unsafePerformIO basically should never be used unless you understand precisely what the compiler is going to do with it
14:58:11 <Cale> (and it's basically a last resort for cases where you'd otherwise modify the compiler to add features to the evaluation mechanism)
14:58:40 <Cale> kartrel: f $ x = f x
14:58:49 <Cale> kartrel: but $ has low operator precedence
14:58:50 <EvanR> unsafePerformIO is unsounds to use as a "quick a dirty hack that i will fix later" because you will probably spend a significant time trying to get it to work how you think it should work, and fixing weirdness it causes
14:59:01 <Cale> kartrel: So it's like writing  and (zipWith (<=) xs (tail xs))
14:59:21 <Cale> only, you don't have to remember to close the paren
15:00:00 <kartrel> ok
15:00:13 <Cale> kartrel: Whenever you have something like f (g (h x)) in Haskell, and the parens start to get annoying, you can consider replacing it with something like f . g . h $ x
15:00:38 <Cale> where you compose a bunch of functions with (.) and then apply the result to an argument with ($)
15:01:09 <kartrel> ok
15:02:38 <fabian___> Cale: I cant get the Entity instance to work. instance Entity (TSRef (Door s)) complains that s has no Typeable instance
15:02:45 <Cale> right
15:02:50 <ski> kartrel : "people use haskell because the code is so easy to understand?" -- that's part of it. it's also easier to *reason* about
15:03:14 <Cale> fabian___: actually, that's totally correct, you can't do that
15:03:22 <ski> kartrel : this is turn mean that people can tackle harder problems, while still being able to keep track of them
15:03:40 <Cale> fabian___: Why did we want an Entity instance for STRef in the first place?
15:04:02 <fabian___> Cale: well you told me I could :) should I rewrite TSRef to: newtype TSRef a s = TSRef (STRef s (a s))
15:04:05 <kartrel> ok, I was somewhat uncertain about stuff being easier to understand with haskell (as shown in the last thing I asked about)
15:04:23 <fabian___> Cale: To cast STRefs
15:04:23 <ski> kartrel : it doesn't help if your programming language is super powerful, if you can't make sense of existing code written in it. reasoning laws help with refactoring and otherwise analyzing existing programs, modifying them
15:04:35 <Cale> fabian___: Yeah, that'll work whenever a is Typeable (and doesn't have the s type parameter in particular)
15:04:44 <Cale> fabian___: But I still don't know why we really want it
15:04:45 <Cale> ah
15:04:50 <Cale> Why not just write an operation for that?
15:05:44 <fabian___> Say I have an EntityRef and want to check if references a Door, then pass that reference to a function that takes a Door reference
15:06:02 <Cale> readSTRefEntity :: Entity e => STRef s (SomeEntity s) -> ST s (e s)
15:06:10 <Cale> er
15:06:11 <Cale> sorry
15:06:17 <Cale> readSTRefEntity :: Entity e => STRef s (SomeEntity s) -> ST s (Maybe (e s))
15:06:19 <ski> kartrel : in Haskell, you can reason by "equational reasoning" ("replace equals for equals"). this is partly because every function always give the same result, when given the same input
15:06:39 <ski> kartrel : it also helps to have few exceptions and special cases
15:06:45 <Cale> readSTRefEntity r = fromEntity <$> readSTRef r
15:07:20 <fabian___> But you loose the Reference
15:07:28 <Cale> huh?
15:09:14 <Cale> fabian___: Can you give me an example of the problem?
15:09:17 <fabian___> I want to check if the EntityRef is a Door Reference (STRef s (Door s)), and if it is, pass it to a function unlock :: STRef s (Door s) -> ST s ()
15:10:03 <ntnt> i'm using vim. is ther ea way to make all lines that contain "::" to be colored in light grey? i.e. I want all type signatures to be in light grey (entire line)
15:10:18 <Cale> do v <- fromEntity <$> readSTRef r; case v of Nothing -> ... do something else ...; Just d -> unlock r
15:10:57 <Cale> oh, I see what you mean, sorry
15:11:07 <Cale> Yeah, you can't change the type of the reference like that
15:11:12 <fabian___> r is not a STRef s (Door s) ;)
15:11:20 <Cale> Without making some new reference or something.
15:11:45 <Cale> I suppose you could store a reference along with functions which translate back and forth between its actual type and some other type
15:12:24 <Cale> ntnt: ew... but they're the most important part of the code
15:12:53 <ntnt> Cale: do you use emacs ?
15:12:58 <Cale> ntnt: I think I'd rather make all the rest of the code grey before I did that :D
15:13:12 <Cale> I have used it in the past... for some value of used
15:13:25 <ntnt> I think of type sigs as compiler verified comments
15:13:29 <Cale> I generally don't get much out of text editors which one couldn't get out of, say, gedit.
15:13:37 <ntnt> they help me understnd the code, but don't actually do anything
15:14:10 <Cale> ntnt: They are like that, except the fact that they're compiler verified makes them a lot more important than textual comments.
15:14:27 <Cale> Also, you can't generally remove them from Haskell code while retaining the meaning.
15:14:41 <Cale> The type signature of something can affect its behaviour
15:14:46 <Cale> (due to type classes)
15:14:53 <kartrel> argh, http://lpaste.net/158458 compilation error: Couldn't match expected type a] -> t' with actual type `[t0]'
15:15:29 <Cale> kartrel: On the first line, you're using listleft as a function
15:15:42 <Cale> kartrel: but later, you use it as a list
15:16:18 <kartrel> so, how would i tell haskell to return two lists?
15:16:32 <Cale> kartrel: You could form a pair, like  (listleft, listright)
15:16:39 <kartrel> ah ok
15:16:41 <kartrel> thanks
15:17:12 <fabian___> Cale: Could I use some coerce hack?
15:17:20 <kartrel> at some point i'll actually start to understand the syntax :D
15:17:23 <Cale> fabian___: I wouldn't.
15:18:26 <Cale> fabian___: Yeah, that actually wouldn't work
15:18:32 <ski> kartrel : `x y' means the function `x' applied to the argument `y'
15:18:48 <Cale> fabian___: The runtime representation of SomeEntity d is different from the runtime representation of d
15:19:06 <ski> kartrel : i'd probably use guards for the last two cases of `split' there :
15:19:07 <ski>   split val (front:end) listleft listright
15:19:21 <ski>   | front >= val   =  split val end listleft (listright ++ [front])
15:19:23 <Cale> fabian___: So if you did coerce, you'd end up mangling the memory somehow, and would probably end up jumping somewhere random and hopefully segfaulting
15:19:34 <ski>   | otherwise      =  split val end (listleft ++ [front]) listright
15:19:49 <ski> kartrel : sorry, the `|'s should be indented more (e.g. two spaces more)
15:20:22 <ski> kartrel : also, i'd consider defining `split' locally to `actualsplit' (and rename them to perhaps `splitHelper' and `split' ?)
15:20:27 <Cale> fabian___: SomeEntity stores the type class dictionary for Entity alongside the value that it wraps, which comes packed along with a type class dictionary for Typeable, which contains the runtime type information we're using to do fromEntity.
15:20:33 <kartrel> ski, the goal is that the code should appear to be made by me ;) so all the higher level stuff is of course interesting and useful but I simply cannot use them in the actual answers
15:21:45 <ski> kartrel : btw, one can define `split' directly here, without accumulators
15:26:17 <ski> kartrel : fwiw, the goal, from my POV, is to teach you concepts, so that the code *would* be (possible to be) made by you ..
15:27:02 <fabian___> Cale: I might prove you wrong :)
15:28:05 <Cale> fabian___: I mean, it's possible you end up jumping into almost-the-right code and not segfaulting and maybe even getting nearly sensible behaviour sometimes, and then the next version of GHC comes out and suddenly your unsafeCoerce doesn't work any longer.
15:28:39 <Cale> fabian___: So don't do it.
15:28:46 <fabian___> Cale: not using coerce
15:29:01 <fabian___> Cale: writing Entity instances
15:29:01 * hackagebot heist 0.14.1.3 - An Haskell template system supporting both HTML5 and XML.  https://hackage.haskell.org/package/heist-0.14.1.3 (DougBeardsley)
15:30:00 <kartrel> ski, your guidance so far has been quite useful, I've learned lots of things. You see, anything that's 'higher course stuff' is useful of course, but our teacher will think that I would have copied that directly from some website. Haskell may (I cannot say for sure) be something that I'll still be using after I've finished this course so the extra information can be useful and I will be saving it in a text file to go through when I really need it
15:30:20 <fabian___> Cale: did it :)
15:30:31 <maerwald> EvanR: I've already forked 2 libraries, rewritten half of filepath and added orphaned instances for random glib classes just to get ByteString working -.-
15:30:33 <Cale> fabian___: fromEntity should give you Nothing in that case, right?
15:30:33 <maerwald> meh
15:30:43 <Cale> fabian___: If I understand what you mean to do.
15:30:48 <fabian___> Cale: newtype TSRef a s = TSRef (STRef s (a s))
15:30:49 <fabian___>                   deriving (Eq)
15:30:57 <fabian___> instance Entity e => Entity (TSRef e) where
15:31:07 <fabian___> and then it compiled
15:31:21 <Cale> yeah, that'll work
15:31:53 <Cale> But note that  TSRef Door  and  TSRef SomeEntity  are distinct.
15:32:35 <fabian___> and all referenced types need to take s as a parameter
15:32:39 <fabian___> but I can live with that
15:33:01 <Cale> So if you apply toEntity to a TSRef SomeEntity s  to obtain a  SomeEntity s, and then apply fromEntity hoping to get back a TSRef Door s, then you'll get Nothing
15:33:20 <Cale> Because the type doesn't match
15:34:17 <fabian___> I  follow
15:34:28 <fabian___> but I wont use TSRef SomeEntity I think
15:35:52 <ski> (kartrel : cut off near ".. so the extra information can be useful and I will be saving it in a text file to go through when I really need it" ?)
15:36:30 <kartrel> yeah
15:47:49 <orion> How do people normally encode the logic of command line argument validation after they've been parsed? For example, "the -l and -g flags can not be used together, but the -l and -p flags can, but only if -x is specified".
15:47:56 <jrcharney> Installing cabel from source since I successfully did so wth Haskell on Raspberry Pi.  I completed the `ghc -threaded --make Setup` step, then I tried running `./Setup configure` and got a Segmentation Fault.
15:47:57 <maerwald> it compiles :D
15:48:01 <orion> I'm envisioning a massive case block with tons of pattern matching.
15:48:36 <ski> orion : i'd suppose a declarative specification of the constraints could be helpful ..
15:49:32 <ski> kartrel : in case it was cut off, what was the remaining part ?
15:53:20 <kartrel> the last part was: but still, otherwise the information has been useful and has made me understand haskell a bit more in depth, so thank you for that
15:53:35 <Darwin226> Hey guys. I have a project that uses the text-icu library. I've downloaded the lib and placed the files in my include and lib folders and the text-icu builds correctly
15:53:51 <Darwin226> however, the executable of my project doesn't run because it claims it can't find the library
15:54:01 <Darwin226> how do I force it to link statically with all it needs?
15:54:40 <Darwin226> I've even removed the .dll files from the lib folder so the .lib files are all that's there and the build still passes, but the executable still can't find the .dlls
15:54:59 <Darwin226> I've tried putting ghc-options:         -optl-static  into my cabal file but it doesn't make a difference
15:55:50 <ski> kartrel : ok, ty
15:55:51 <Darwin226> ldd of the executable only mentions things like KERNEL32.dll, but running the executable says it can't find icuuc40.dll
15:59:04 <kartrel> learing about several different programming languages may help with trying to solve some difficult problems due to having a wide arrangement of ways of trying to solve the problem
16:01:52 <DotKite> getting the following error *** Exception: ex_ch2.hs:2:1-57: Non-exhaustive patterns in function lastButOne    for the following func  lastButOne xs = if length xs <= 2 then xs else lastButOne (tail xs)
16:02:17 <DotKite> nvm 
16:02:29 <DotKite> i think i just realized whats wrong
16:02:58 <maerwald> kartrel: that depends... just because you know C#, Java, C, C++, Perl, Python and so on doesn't mean your algorithm solving skills have improved. I think it's more about learning different paradigms, not just languages.
16:03:59 <kcsongor> DotKite: that's weird!
16:04:02 * hackagebot register-machine-typelevel 0.1.0.0 - A computationally universal register machine implementation at the type-level  https://hackage.haskell.org/package/register-machine-typelevel-0.1.0.0 (kcsongor)
16:04:12 <pomeroy> hi! i'm writing a strategy game, and I'm wondering what kind of datatype I should store the entities of my game in. there will be a lot of them, and I'd like to be flexible when it comes to sorting and filtering and the likes. I'm quite new to the different datatypes, all I know is a regular list is probably not going to cut it 
16:05:04 <kcsongor> pomeroy: by sorting you mean sort by distance from the player?
16:05:25 <pomeroy> yes, for example
16:05:53 <kcsongor> I'd look at k-d trees and finger trees
16:05:58 <DotKite> kcsongor it actually should be   lastButOne xs = if length xs <= 2 then head xs else lastButOne (tail xs)
16:06:17 <DotKite> I do not know why that exception is getting raised
16:06:22 <kcsongor> DotKite now that wouldn't work
16:06:42 <DotKite> hmmm ok
16:06:56 <kcsongor> on empty lists, length is 0, and you call head
16:07:07 <kcsongor> your previous definition seemed to be ok though
16:07:25 <DotKite> yeah for that i have lastButOne [] = error "..."
16:07:52 <DotKite> i get that other error for a list like [1,2,3]
16:08:32 <kcsongor> DotKite: does it happen when you try it in a fresh GHCI session?
16:08:49 <DotKite> ill check
16:09:53 <DotKite> yes it does. although I am using cloud 9 and not my actual computer
16:10:23 <kcsongor> let lastButOne xs = if length xs <= 2 then xs else lastButOne (tail xs)
16:10:33 <kcsongor> calling this breaks?
16:10:57 <kcsongor> which ghc version?
16:11:10 <DotKite> 7.6.3
16:12:05 * ski idly wonders whether kcsongor has saved the file, is loading the right file, &c.
16:12:09 <DotKite> i checked what you just defined and that seems to work
16:12:39 <kcsongor> DotKite: that's the one you originally posted!
16:12:41 <ski> er .. DotKite' rather
16:14:28 <DotKite> Ok i figured out the problem
16:14:29 <kcsongor> DotKite: either way, doing it this way doesn't seem like a very good idea: length means a traversal of the list every time, you'd get away much cheaper (and safer) with pattern matching
16:15:22 <DotKite> I know it's probably not the best, just starting out with Haskell.  Going through real world haskell
16:15:25 <orion> Why is this not possible?: data Foo a = Foo { x :: a, y :: a }; parseFile :: FilePath -> IO a; a <- parseFile "a.txt"; b <- parseFile "b.txt"; if something then doThing (Foo { x = a, y = b } :: Bar) else doThing (Foo { x = a, y = b } :: Baz) ?
16:17:38 <kcsongor> DotKite: I see, good luck then!
16:18:07 <ski> orion : what's `Bar' and `Baz' ?
16:18:32 <kcsongor> orion: what's the type `a` in parseFile?
16:18:58 <orion> I think I'll paste my real code rather than continue with this contrived examples.
16:19:01 <orion> example
16:19:07 <ski> might be better
16:19:21 <ski> @paste
16:19:21 <lambdabot> Haskell pastebin: http://lpaste.net/
16:22:45 <orion> ski / kcsongor: http://lpaste.net/3696179959367204864
16:23:56 <ski> orion : is `KeyPair' covariant ?
16:24:24 <orion> What do you mean?
16:24:47 <ski> is `KeyPair' an instance of `Functor' ? or could it be one ?
16:25:00 <orion> https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Curve.hs#L52
16:25:01 <ski> what's the type of `optKeyType' ?
16:25:34 <orion> optKeyType :: KeyType, data KeyType = Curve25519 | Curve448
16:25:39 <ski> hm, presumably it's not a functor, then
16:25:58 <ski> where does `optKeyType' come from, in the pasted snippet ?
16:26:38 <ski> hm
16:26:47 <orion> It's a command line argument. I.e, if you pass "-t curve25519" to the application then optKeyType will be Curve25519, and the same for Curve448.
16:28:21 <ski> i think you'd need `readKey :: FilePath -> IO (forall d. Curve d => KeyPair d)' for that to work, directly
16:29:13 <ski> an alternative is to break the `readKey's and the `let so = ...' into a helper, and call it in the two branches
16:29:53 <ski> (since presumably `readKey' will have to actually know which kind of curve to use, to read the key correctly ?)
16:30:34 <ski> orion : the main problem is that `<-' bindings in `do' are monomorphic, afaiui
16:31:38 <orion> readKey is able to be polymorphic on the KeyPair because it completely relies on `curveBytesToPair' to parse correctly, which is a function belonging to the Curve class.
16:33:34 <orion> Unfortunately, readKey :: Curve d => FilePath -> IO (forall d. Curve d => KeyPair d) did not work.
16:33:46 <kcsongor> where is so defined again?
16:34:02 <ski> orion : i would also consider `data KeyType :: * -> * where Curve25519 :: KeyType Crypto.Noise.Curve.Curve25519.Curve25519; Curve448 :: KeyType Crypto.Noise.Curve.Curve448.Curve448'
16:34:17 <kiko_> hallo i want help with a peoblem in haskell
16:34:21 <ski> orion : you'd need `ImpredicativeTypes' for that one
16:34:25 <kcsongor> onion: is `so` passed in as an argument to the function?
16:34:38 <ski> kcsongor : `so' is defined by the `let'
16:34:47 <orion> kcsongor: `so' is passed as an argument to startServer
16:34:50 <ski> hello kiko_
16:35:00 <kiko_> hello
16:35:07 <orion> ski: What exactly is that?
16:35:15 <ski> orion : a language extension
16:35:24 <orion> ha, I meant, why is it useful?
16:35:38 <ski> orion : `Foo (forall a. ..a..)' isn't legal without it
16:36:03 <orion> Is it safe?
16:36:04 <kiko_> i want to get a string as input as " i want help" and give me a string list with "i","want","help"
16:36:11 <kcsongor> orion: sorry, I meant what the "somewhere else" context means
16:36:17 <ski> orion : anyway, i think the other approach i sketches is the simpler version
16:36:24 <ski> orion : should be safe
16:36:55 <kcsongor> kiko_: words
16:37:03 <ski> kiko_ : do you want to write a function that does that ?
16:37:08 <kiko_> yes
16:37:24 <orion> ski: You mean define two separate readKeys?
16:37:29 <ski> kiko_ : strings are lists. use recursion
16:37:35 <ski> orion : no
16:37:53 <kiko_> yes i use recursion but i can't figure out what to revursive
16:38:06 <kiko_> thsi is what i have come up
16:38:07 <kiko_> wordList :: String->[String]  wordList (h:t)  			| h == ' ' =  wordList t 			|otherwise =  "h" : "wordList t" 
16:39:06 <ski> orion : i mean define a (possibly local) `makeServerOpts :: Curve d => FilePath -> FilePath -> IO (ServerOpts d)' (or "hardcode" the two paths into this, if you prefer)
16:39:31 <ski> orion : then call `makeServerOpts' in each of the two branches
16:40:29 <ski> kiko_ : remove the double quotes
16:40:37 <kiko_> yes without it
16:40:41 <kiko_> its not working
16:41:05 <ski> @let wordList :: String -> [String];  wordList (h:t)     | h == ' ' =  wordList t   |otherwise = h : wordList t
16:41:06 <lambdabot>  .L.hs:165:17:
16:41:06 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
16:41:06 <lambdabot>      Expected type: String
16:41:20 <kiko_> yes this is my error
16:41:42 <ski> kiko_ : `wordList t' is supposed to be a list of strings, but `h' is a single `Char'. `:' combines a list element with a list
16:42:10 <ski> since `wordList t' isn't a list of the same kind of element that `h' is, this doesn't work
16:42:30 <orion> ski: I see.
16:42:39 <kiko_> how i can fix this... i am struggling for 4 hours now
16:42:42 <ski> > 'a' : ["bc","","d"]
16:42:43 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
16:42:43 <lambdabot>      In the expression: "bc"
16:42:43 <lambdabot>      In the second argument of ‘(:)’, namely ‘["bc", "", "d"]’
16:42:52 <ski> > 'a' : ['b','d']
16:42:54 <lambdabot>  "abd"
16:42:57 <ski> > ['a'] : ["bc","","d"]
16:42:59 <lambdabot>  ["a","bc","","d"]
16:43:42 <ski> kiko_ : either make sure that the argument to the right of `:' is a list of `Char's, or make sure that the argument to the left of `:' is a `String', or change `:' into something else (appropriate)
16:44:11 <ski> (hint : some of those alternatives may not be appropriate in your case)
16:44:38 <kiko_> yes i found on the inrnet many solutions but they are not appropiate for my cade
16:44:54 <ski> orion : btw, i'm assuming that the key files themselves doesn't tell the format of the key
16:44:55 <kiko_> i ca;t figure out how to combine these to
16:45:05 <orion> ski: Correct.
16:45:17 <orion> The user needs to tell the program what the format is.
16:45:37 <ski> orion : .. since otherwise, another type would be more appropriate for `readKey'
16:46:30 <ski> (something like `readKey :: FilePath -> IO (exists d. Curve d *> KeyPair d)')
16:47:12 <ski> (btw, note that `readKey :: Curve d => FilePath -> IO (forall d. Curve d => KeyPair d' isn't exactly what i suggested a bit above .. not that it matters much)
16:48:41 <ski> kiko_ : assuming you don't want to change the right argument (`wordList t'), then you need to provide a `String' (iow a *list* of `Char's) as the left argument
16:48:48 <ski> kiko_ : `h' is a single `Char', not a list of them
16:49:02 <monochrom> kiko_: I suggestion solving a less ambitious problem, then use it as a helper. Write a function that splits "xxx yyy zzzz" into ("xxx", "yyy zzzz"). So just split at the 1st space seen.  If the input has no space, e.g., "xxxyyyzzzz", then the answer is ("xxxyyyzzzz", "")
16:49:04 <ski> kiko_ : how can you convert a single `Char' into a list of them ?
16:50:06 <monochrom> there is also a question of what happens to "xxx           yyy zzzz", but you decide what's most sensible.
16:50:28 <monochrom> and a million other cases I haven't mentioned
16:50:39 <kiko_> i can't figure out how to convert a single cahr to a list of them
16:50:41 <monochrom> it's your helper, you decide what you want
16:53:08 <ski> kiko_ : what other list-involving operations have you already defined/understood ?
16:53:10 <monochrom> it seems that one significant difficulty when transitioning from imperative mindsets to Haskell is in shoehorning the complete problem into one single recursion because you would use one single loop for the whole thing when in imperative languages.
16:53:35 <ski> monochrom, opssible
16:54:08 <monochrom> but no, Haskell wants you to solve a subproblem by one recursion, then call that helper in yet another recursion. or compose two functions, each its own recursion. etc etc
16:54:22 <maerwald> or just write a regular loop in haskell :P
16:55:02 <ski> maerwald : a "regular loop in haskell" *is* recursion :)
16:55:16 <maerwald> that's not what I meant
16:55:19 <ski> (i know)
16:55:21 <kiko_> i have solved a problem with list of tuples that gives me 5 int uotput with revursive calls
16:55:57 <ski> can you give an example call of it, and the corresponding result ?
16:56:00 <EvanR> forM_ [0..L-1] $ \i -> do
16:56:04 <monochrom> it is possible to use one single recursion, but it is advanced, not basic. and it is not just advanced Haskell. it is advanced imperative programming too.
16:56:38 <monochrom> if you don't have a PhD in Java, you don't know how to translate Java to Haskell verbatim.
16:56:56 * ski 'll have to remember that one
16:57:02 <ski> in fact ..
16:57:03 <maerwald> I like this old post http://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html ... don't be afraid to to imperative-style programming if it makes sense
16:57:11 <ski> @remember monochrom if you don't have a PhD in Java, you don't know how to translate Java to Haskell verbatim.
16:57:11 <lambdabot> I will never forget.
16:57:34 <baweaver> PhD in Java? Sounds dreadful. 
16:57:49 <maerwald> they have lambdas now...
16:58:02 <ski> maerwald : *nod*
16:59:01 <monochrom> baweaver: now consider the problem of translating PHP to Haskell verbatim :)
16:59:27 <baweaver> I'm no masochist monochrom
16:59:43 <EvanR> assoc arrays / maps whatever they are having an implicit mutable cursor 
16:59:48 <EvanR> fun
17:00:23 <hpc> monochrom: there is that one package
17:00:39 <Axman6> IORef (Map (Either Int String) (IORef Any))
17:00:52 <Axman6> universal object for all your language translation needs
17:01:33 * ski . o O ( "loop in C , recursion in haskell" by Simon Marlow in 2004-03-24 at <https://mail.haskell.org/pipermail/haskell-cafe/2004-March/005939.html< )
17:01:36 <ski> maerwald ^
17:02:41 <maerwald> "Ignore David, he's pulling your leg" -- haha
17:12:28 <kiko_> this is what i came up
17:12:36 <kiko_> but i cant add any other element in the list
17:12:36 <kiko_> wordList :: String->[String] wordList [] = [] wordList (h:t)  			| h == '\n' =  wordList t 			|otherwise =  [h] : wordList t
17:13:45 <ski> @let wordList :: String -> [String]; wordList [] = []; wordList (h:t)     | h == '\n' = wordList t    | otherwise = [h] : wordList t
17:13:46 <lambdabot>  Defined.
17:14:00 <ski> > wordList "abc\nde\n"
17:14:01 <lambdabot>  ["a","b","c","d","e"]
17:14:48 <ski> all elements you "add" to the output list are of the shape `[h]', iow *singleton* lists
17:15:07 <kiko_> how add more elemtns into this?
17:15:11 <ski> you never add any longer list. also you never extend any singleton list into a longer list
17:15:27 <ski> extending would be one way to solve this
17:15:58 <kiko_> how can i extend this list?
17:16:16 <ski> let's consider the recursion
17:16:26 <ski> let's say you have a call
17:16:33 <ski>   wordList "abc\nde\n"
17:16:55 <ski> presumably, this is going to call itself recursively like
17:17:01 <ski>   wordList "bc\nde\n"
17:17:15 <ski> (since you're calling `wordList t', where `t' is the tail of the current list)
17:17:31 <kiko_> yes this is good so far
17:17:34 <ski> now, let's say you wanted the original call here to yield the result
17:17:41 <ski>   ["abc","de"]
17:18:17 <ski> then, what would be the corresponding result you'd expect (iow *want*) the recursive call above to yield ?
17:19:24 * ski looks at kiko_
17:20:35 <kiko_> the recurcive call tha i wrote?
17:20:45 <ski> no, the concrete one i mentioned
17:20:56 <ski> (which is a concrete version of the one you wrote)
17:21:21 <kiko_> ok so i want to add the elents to the single list
17:21:38 * ski is still waiting for kiko_ to answer the question
17:22:14 * ski is attempting to check that kiko_ is paying attention ..
17:22:16 <orion> grr... using the type system really hinders your ability to make changes at runtime.
17:22:25 <kiko_> the result would be ["abc", "de"]
17:22:32 <kiko_> the result that i want to give
17:22:42 <kiko_> when i am typing "abcde"
17:22:49 <ski> that'd be the expected result for `wordList "abc\nde\n"'
17:22:54 <kiko_> wronf "abc de"
17:23:04 <ski> however, i was asking for the expected result for the recursive call above
17:23:08 <ski> <ski> presumably, this is going to call itself recursively like
17:23:10 <ski> <ski>   wordList "bc\nde\n"
17:23:13 <ski> <ski> (since you're calling `wordList t', where `t' is the tail of the current list)
17:23:54 <ski> (also note that ` ' is different from `\n'. since you wrote the latter in your definition, i'm going with that for the moment)
17:25:11 * ski idly wonders what problem orion is hitting
17:25:18 <ski> kiko_ : so ?
17:26:22 <kiko_> the result would be ["b","c","", "d", "e " ""]
17:26:45 <ski> kiko_ : no. not what the result *would* be. what the result *should* be
17:27:04 <ski> ("expected". not "actual")
17:27:09 <kiko_> the result shoud be ["bc","de"]
17:27:16 <ski> yes. thank you
17:27:35 <ski> so, you *want* to get
17:27:45 <ski>   wordList "abc\nde\n" = ["abc","de"]
17:28:05 <kiko_> yes
17:28:09 <ski> and, *assuming* the recursive call does what it should (just trust it blindly for the moment), then it will give you
17:28:15 <ski>   wordList "bc\nde\n" = ["bc","de"]
17:28:30 <kiko_> yes
17:29:15 <ski> your task is to piece together the (*desired*) result of the recursive call, iow `["bc","de"]', with other relevant information (h = 'a'; t = "bc\nde\n") into the desired result `["abc","de"]'
17:29:35 <ski> what is the difference between the (desired) recursive result, and the (desired) result of the current call ?
17:29:41 <ski> how to close the gap ?
17:30:00 <blogle> I have a whole slew of functions that I want to expose to C using the FFI. Is there someway I can define a combinator that modifies all my input args to StablePtr's and my output to IO StablePtr? for instance if I have f :: a -> b -> c can I define (g . f) :: StablePtr a -> StablePtr b -> IO (StablePtr c)? 
17:30:49 <monochrom> I think you should aim for "g f" rather than "g . f"
17:30:57 <ski> blogle : you can perhaps do some class trickery for that
17:31:14 <kiko_> i think we need one more fuction that take the h and tail and make the list unti the \n is found
17:31:20 <blogle> monochrome: right I noticed right as I hit enter my mistake
17:31:39 <ski> kiko_ : i didn't understand the "make the list unti the \n is found" part
17:31:58 <blogle> ski: thats what I was thinking, but it sounds clunky
17:32:05 <kiko_> the problem now is that  i can't add more letters to a single list 
17:32:11 <ski> blogle : or maybe TH ..
17:32:20 <ski> kiko_ : why not ?
17:32:44 <ski> kiko_ : can you write a function `addToFirst' such that
17:33:05 <ski>   addToFirst 'a' "bc\nde\n" ["bc","de"]  =  ["abc","de"]
17:33:07 <ski> holds ?
17:33:23 <blogle> ski: I was hoping there was some other magic I just wasn't aware of, but I suppose not
17:33:32 <ski> (if so, you could call it like `addToFirst h t (wordList t)')
17:33:57 <ski> blogle : i'm not aware of any
17:34:28 <blogle> ski: thanks anyhow, I suppose I will look to TH
17:36:04 <bill__> .
17:36:10 <kiko_> how the function addtoFirst works?
17:36:13 <ski>    ?
17:36:21 <ski> kiko_ : that's for you to figure out
17:36:41 <kiko_> any tips?
17:37:17 <ski> it get's passed the "relevant information" (iow `h',`t',`wordList t' (the "recursive result")), and should compute the desired result for the current call to `wordList' (namely `wordList (h:t)')
17:37:39 <ski> <ski> your task is to piece together the (*desired*) result of the recursive call, iow `["bc","de"]', with other relevant information (h = 'a'; t = "bc\nde\n") into the desired result `["abc","de"]'
17:37:45 <ski> <ski> what is the difference between the (desired) recursive result, and the (desired) result of the current call ?
17:37:48 <ski> <ski> how to close the gap ?
17:37:56 <ski> kiko_ : tip, answer those two questions
17:45:17 <kiko_> the (desired) recurcive result is ["abe", "de"] and the result of the current call is to add a at the list
17:46:16 <ski> by "(desired) recursive result", i mean the (desired) result from the recursive call (iow `wordList t' in your case)
17:47:08 <ski> well, concretely, for the case `wordList "abc\nde\n"', the recursive call would be `wordList "bc\nde\n"'
17:47:33 <ski> and then the (desired) recursive result is `["be","de"]' (not `["abe","de"]')
17:47:45 <bill__> wordList :: String->[String] wordList (h:t) = [h] : wordList t
17:47:59 <bill__> wordList :: String->[String]                                                                                                                                  wordList (h:t) = [h] : wordList t
17:48:07 <bill__> wordList :: String->[String]                                                                    wordList (h:t) = [h] : wordList t
17:48:19 <Welkin> bill cosby!?
17:48:23 <ski> by "(desired) result of the current call", i mean the (desired) result of the call in question to `wordList' that we're considering as an example, iow the (desired) result to `wordList "abc\nde\n"', which should be `["abe","de"]'
17:48:24 <Welkin> wtf are you doing in here?
17:48:34 <bill__> input "HAZEL" 
17:48:52 <Welkin> what's with the spam by bill cosby?
17:49:17 <kiko_> this is what you ment? After evrey recutrice call an elemnt is going into list the rest of the tail is goind to the next recurive
17:49:18 * ski idly wonders what Welkin is referring to
17:49:33 <Welkin> he's definitely a rapist
17:50:53 <ski> kiko_ : is that a quote from your text ?
17:51:19 <kiko_> which text?
17:51:29 <ski> i don't know
17:51:43 <ski> "the rest of the tail is goind to the next recurive" seems to be describing the `wordList t' part of `wordList (h:t) = ..(wordList t)..'
17:54:05 * hackagebot mondo 0.3.0.0 - Haskell bindings for the Mondo API  https://hackage.haskell.org/package/mondo-0.3.0.0 (mbg)
17:55:46 <kiko_> yes this is what i describe
17:57:23 <pikajude> hey, what is GHC complaining about here? http://lpaste.net/158465
17:57:47 <ski> kiko_ : "an elemnt is going into list", which list ?
17:57:47 <Welkin> missing a pattern for [x]
17:58:05 <pikajude> no i'm not
17:58:07 <pikajude> (x:xs) covers [x]
17:58:13 <kiko_> is the list we want the result to be
17:58:34 <Welkin> hm, you are right pikajude 
17:58:43 <Welkin> I read it as [x:xs]
17:59:00 <pikajude> i have OverloadedLists enabled. might that be it?
17:59:01 <Welkin> scratch that, I don't know what I am saying any more
17:59:02 <Welkin> haha
17:59:22 <Welkin> hm
17:59:27 <Welkin> never used overloadedList
18:00:42 <pikajude> yeah, I guess GHC can't do the exhaustiveness check with OverloadedLists turned on for some reason
18:00:57 <ski> kiko_ : yes, the head element need to (somehow) go into list that you return
18:01:52 <pikajude> nope. that's not it
18:01:55 <ski> kiko_ : however, i'm still missing you saying what's the difference between the recursive and the direct result, in the particular concrete example call to `wordList' that i suggested
18:03:49 <ertes> pomeroy: you can define game objects not in terms of data, but rather supported operations
18:03:49 <ertes> data Object = Object { objDraw :: IO (), ... }
18:04:01 <ertes> oh, too late
18:05:28 <ski> ertes : i suppose there's `@tell' ..
18:06:14 <ertes> i just saw that it was two hours ago…  i'm still getting used to ERC
18:10:11 * ski notices kiko_ also disappeared. oh, well
18:10:20 <Welkin> it's a conspiracy
18:10:29 <Welkin> kiko is working with bill cosby
18:25:35 <greg`> so whos going to lambdaconf then?
18:26:08 <Welkin> not me
18:26:26 <Welkin> I'd love to go to a haskell conference at some point though
18:46:05 <benzrf> i went to lambdajam, it was p fun
18:46:20 <benzrf> (not strictly a *haskell* conference
18:46:22 <benzrf> )
18:46:51 <Welkin> benzrf: and you got drunk?
18:47:08 <benzrf> im underage, Welkin
18:47:13 <benzrf> (for drunk)
18:47:17 <Welkin> that doesn't matter at conferences
18:47:21 <Welkin> at least the ones I have been to
18:47:25 <Welkin> open bar, no one asks
18:47:37 <benzrf> i don't *want* to get drunk
18:47:39 <Welkin> champagne, wine, beer, har drinks
18:47:44 <Welkin> hard*
18:47:58 <benzrf> im pretty sure i would not have a very good constitution for drinking
18:48:05 <benzrf> based on the fact that i dont have a good constitution for anything ever
18:48:33 <Welkin> 2 or 3 glasses of wine or champagne over the night is great
18:48:41 <Welkin> I don't drink much
18:48:46 <Welkin> one beer or glass of wine is enough for me
18:48:57 <Welkin> then have another later
18:49:33 <Welkin> it does make the party more fun, because you are more loose with your words
18:49:45 <Welkin> add in some whiteboards and you have a party
18:50:18 <benzrf> ive heard stories about programming while drunk
18:50:25 <benzrf> i wonder if they apply to math aswell
18:50:27 <Welkin> yeah, it sucks
18:50:29 <arahael> Balmer peak.
18:50:29 <Welkin> I tried it
18:50:36 <Welkin> balmer peak is a myth
18:50:37 <arahael> Must've missed the peak.
18:50:45 <Welkin> one beer and I can't program for shit
18:50:51 <arahael> Just because you can't find the peak doesn't mean it doesn't exist!
18:51:19 <benzrf> ballmer peak is at 0.1337
18:51:36 <Welkin> you would be dead
18:52:04 <benzrf> percent
18:52:31 <benzrf> its true, look https://xkcd.com/323/
18:54:25 <huSh> Hey guys
18:54:30 <huSh> Anyone on?
18:54:44 <Welkin> on what?
18:54:56 <huSh> On here, and paying attention lol
18:55:35 <huSh> I have a couple questions and wanted to see if anyone could give me some guidance or something
18:56:12 <Welkin> just ask
18:56:17 <Welkin> someone might answer
18:56:24 <huSh> ok
18:56:50 <huSh> I'm trying to work on some practice problems
18:57:32 <huSh> and it says "write a function that accepts a list of integers as the parameter
18:57:57 <huSh> Would I be right in doing myList :: [Integer] -> [Integer]
18:58:12 <Welkin> only if the output is a list of Integer
18:58:26 <huSh> The output is a list of integers that are divisible by 3
18:58:32 <Welkin> then yes
18:58:36 <huSh> Ok awesome
18:58:44 <huSh> but I'm confused how the list is generated
18:58:57 <Welkin> you build it
18:58:58 <huSh> Will it accept input through command line?
18:59:03 <Welkin> oh
18:59:05 <Welkin> you mean the input
18:59:11 <huSh> yes
18:59:14 <Welkin> you can input it any way you like
18:59:19 <Welkin> try it out in ghci
18:59:36 <huSh> That's what I'm using, but how do I actually give it input though?
18:59:50 <huSh> I do :l program.hs 
18:59:54 <huSh> then myList
18:59:59 <huSh> but it's empty so...
19:00:57 <huSh> The whole code block looks like this so far
19:00:58 <huSh> module Main where     myList :: [Integer] -> [Integer]     myList [1,2,3,4,5,6] = []
19:01:17 <Welkin> @define filterIntegerListDivisibleBy3 = filter (\x -> (x `mod` 3) == 0)
19:01:18 <lambdabot>  Defined.
19:01:18 <arahael> Rather than call it "myList", I'd call it "myTransform".
19:01:32 <Welkin> > filterIntegerListDivisibleBy3 [1..6]
19:01:34 <lambdabot>  [3,6]
19:02:03 <huSh> ok thank you, but I'm still confused on how to give it input
19:02:09 <Welkin> just run it
19:02:14 <Welkin> like I did
19:02:26 <Welkin> <function name> <input>
19:02:41 <huSh> does it have to be in list form? like [1..6]?
19:02:51 <Welkin> yes
19:02:54 <huSh> oh ok
19:02:55 <Welkin> because your input is a list
19:03:08 <Welkin> > filterIntegerListDivisibleBy3 (1,2,3)
19:03:10 <lambdabot>      Couldn't match expected type ‘[a]’
19:03:10 <lambdabot>                  with actual type ‘(Integer, Integer, Integer)’
19:03:10 <lambdabot>      In the first argument of ‘filterIntegerListDivisibleBy3’, namely
19:03:16 <Welkin> that is the wrong type
19:03:23 <huSh> so the user cant do :l program.hs then makeList 1,2,3,4,5,6,7 or something?
19:03:29 <Welkin> it says it expected a list of something
19:03:38 <Sornaensis> > [1..6]
19:03:40 <lambdabot>  [1,2,3,4,5,6]
19:03:48 <Welkin> huSh: you can do that if you want to
19:03:57 <Welkin> but then you need to write the code to accept input from the cli
19:04:03 <Welkin> and parse it
19:04:06 <huSh> oh ok
19:04:07 * hackagebot hylogen 0.1.0.3 - a tiny EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.3 (sleexyz)
19:04:11 <huSh> thanks!
19:04:15 <Welkin> just use ghci to test your functions
19:04:17 <huSh> Let me try what you did
19:04:20 <huSh> brb
19:04:41 <Sornaensis> > [1..10] >>= \x -> guard (even x) >> return x
19:04:43 <lambdabot>  [2,4,6,8,10]
19:05:55 <huSh> Wow, that worked perfectly
19:05:57 <huSh> awesome 
19:06:03 <huSh> What does the filter do?
19:06:37 <ski> huSh : "does it have to be in list form? like [1..6]?" -- it has to be an expression which results in a list. `[1..6]' is one example of such an expression
19:07:06 <ski> huSh : `filter' filters a list, according to a condition
19:07:08 <huSh> It has to print the elements of the initial list that are divisible by 3
19:07:11 <huSh> ski
19:07:23 <ski> huSh : however, presumable you're supposed to write a recursive solution
19:07:26 <Welkin> huSh: read the definition for `filter` in the source
19:07:37 <Welkin> it's the best way to learn how to program haskell
19:07:38 * ski imagines huSh is a newbie
19:07:43 <Welkin> try to write your own `filter`
19:07:44 <monochrom> or try a few examples in a repl
19:07:44 <huSh> I am... lol
19:08:07 <huSh> will do
19:08:22 <ski> huSh : have you written anny recursions yet ?
19:08:26 <ski> s/anny/any/
19:08:34 <ski> seen any at all ?
19:08:36 <huSh> No, I wanted to this to be a recursive one
19:08:38 <Welkin> huSh: the best place to start is going to be this resource
19:08:41 <Welkin> @where learnhaskell
19:08:41 <lambdabot> https://github.com/bitemyapp/learnhaskell
19:08:52 <huSh> thanks, i'll check it out
19:08:57 <Welkin> go through the UPenn course
19:09:03 <Welkin> and join #haskell-beginners
19:09:12 * hackagebot fast-logger 2.4.2 - A fast logging system  https://hackage.haskell.org/package/fast-logger-2.4.2 (KazuYamamoto)
19:09:56 <huSh> ok thanks guys
19:09:58 <ski> huSh : a recursion on a list will commonly be expressed as handling two cases : (a) handling the empty list; (b) handling non-empty lists
19:10:41 <huSh> ski : so how would you write that then?
19:10:49 <ski> in your case, in case your function is called `myTransform' (as suggested by arahael), you could start with something like
19:11:03 <ski>   myTransform :: [Integer] -> [Integer]
19:11:09 <ski>   myTransform ns = ..ns..
19:11:25 <huSh> What's ..ns.. do?
19:11:29 <ski> where `..ns..' symbolizes code yet to be written, than possibly may use `ns'
19:11:34 <huSh> oh ok
19:12:12 <ski> however, assuming we decide to approach `myTransform' according to the two cases above, we'd quickly refine this into
19:12:23 <ski>   myTransform [    ] = ...
19:12:32 <ski>   myTransform (n:ns) = ..n..ns..
19:12:47 <ski> (i'm not repeating the type signature every time here. it doesn't change)
19:13:06 <Welkin> I almost forgot how fun haskell is :D
19:13:12 <huSh> Lol
19:13:19 <huSh> Thanks ski
19:13:21 <Welkin> I haven't programmed in 2 months
19:13:58 <ski> this defines `myTransform' by considering what a call to it should return in case (a) `[]' (the empty list) is passed, and (b) what it should return in case `n:ns' (a non-empty list starting with the element `n', and continuing with the "remainder" list `ns') is passed
19:14:35 <ski> huSh : however, since this will probably need recursion, we'll need (at least one) recursive call to `myTransform', somewhere
19:14:51 <ski> the empty list case (the base case), will probably not need any recursion
19:15:19 <ski> however, in the non-empty list case, chances are that we will need to use recursion to process the whole input list
19:15:51 <ski> most commonly, with recursion, you're calling "yourself" (here the function `myTransform') on a (in some sense) "smaller" input
19:16:33 <ski> in this case, the most likely candidate for a smaller input (as compared to the given input `n:ns' in the non-empty case, the recursive case) is a recursive call `myTransform ns'
19:16:47 <ski> huSh : therefore, we change the "template" for the recursive case into
19:16:59 <ski>   myTransform (n:ns) = ..n..ns..(myTransform ns)..
19:17:14 <ski> to indicate that we're probably going to need to use `myTransform ns' in there
19:17:40 <ski> so, if you need to do recursion on a list, chances are that the pattern
19:17:45 <ski>   myTransform [    ] = ...
19:17:48 <ski>   myTransform (n:ns) = ..n..ns..(myTransform ns)..
19:17:53 <ski> will be a good starting point
19:18:09 <ski> huSh : ok, so far ?
19:18:18 <huSh> so I did myList :: [Integer] -> [Integer]     myList [] = []     myList (h:t) = if x 'mod' 3 == 0 then h:myList else myList t
19:18:26 <huSh> Does that make sense at all?
19:18:33 <ski> yes it does
19:18:34 <ski> good
19:18:44 <ski> but you need back-single-quotes around `mod'
19:18:49 <ski> > 11 `mod` 3'
19:18:50 <ski> er
19:18:51 <lambdabot>  <hint>:1:12:
19:18:51 <lambdabot>      lexical error in string/character literal at end of input
19:18:53 <ski> > 11 `mod` 3
19:18:54 <ski> rather
19:18:54 <lambdabot>  2
19:18:57 <huSh> oh ok
19:19:16 <ski> note that you could also use a "guard" here, instead of an `if'-expression
19:19:28 <huSh> How would I do that?
19:19:38 <ski>   myList [   ] = [      ]
19:19:46 <ski>   myList (h:t)
19:19:59 <ski>     | x `mod` 3 == 0 = h:myList
19:19:59 <huSh> Isn't that what I did?
19:20:02 <huSh> oh ok
19:20:07 <huSh> not the last bit, got it
19:20:07 <ski>     | otherwise      =   myList
19:20:48 <shanemikel> when specifying dependencies in your .cabal file in a stack project, do you guys add version constraints, or is it better to not specify constraints and rely on the stack resolver
19:21:44 <huSh> so would it be myList (h:t) = | x `mod`
19:21:54 <ski> no `=' before the `|'
19:22:13 <huSh> Just myList (h:t) x `mod`
19:22:14 <huSh> ?
19:22:43 <Welkin> shanemikel: for stack I don't, because stackage takes care of that
19:23:06 <ski> huSh : a `|' before the guard expression, as i indicated. then a `=', and then the "body" expression
19:23:19 <ski> huSh : repeat for additional guards attaching to the defining equation
19:24:33 <huSh> so I dont go to the next line for the otherwise statement?
19:25:03 <monochrom> you can go to the next line
19:25:40 <monochrom> it still doesn't mean you will write "= | otherwise myList"
19:25:53 <huSh> and what is the part after myList?
19:26:08 <monochrom> there is no part after myList
19:26:09 <huSh> errm I mean after otherwise
19:26:34 <monochrom> " | otherwise = myList". didn't you see ski already said that?
19:26:56 <huSh> Ya I see what it says but what does otherwise = myList do?
19:27:04 <huSh> if the original condition isnt met, then what?
19:27:24 <monochrom> "otherwise" is always met. it's an alias of True
19:27:35 <huSh> oh
19:27:38 <huSh> Thanks!
19:27:45 <huSh> Let me see if this compiles now
19:27:46 <huSh> brb
19:28:20 <huSh> x not in scope?
19:28:26 <huSh> Where's that coming from?? lol
19:28:38 <ski> huSh : sorry, you said `myList t' in the `else' branch. i only copied `myList'
19:29:10 <ski> huSh : yes, that's what the compiler is wondering. "where is that `x' coming from ?" :)
19:29:23 <huSh> oh, so I should change the x to...  h?
19:29:31 <ski> if that's what you mean to say
19:30:05 <huSh> uh oh
19:30:13 <huSh> now it's giving me all kinds of errors lol
19:30:38 <ski> yes. you're missing something in the case above the `otherwise'/`else' branch
19:30:57 <huSh> module Main where     myList :: [Integer] -> [Integer]     myList [] = []     myList (h:t) | h `mod` 3 == 0 = h:myList | otherwise  = myList t     
19:31:31 <monochrom> that should compile
19:31:38 <ski> there's a small problem
19:31:47 <ski> (but important)
19:31:48 <huSh> At least it's small lol
19:31:52 <huSh> hmm
19:32:01 * ski figures a typo or thinko
19:32:49 <monochrom> "h:myList" -> "h:myList t"
19:32:56 <huSh> Should the h `mod` be h `mod` 3 == 0
19:33:01 <huSh> (h `mod` 3 == 0)
19:33:10 <monochrom> that is unnecessary
19:33:44 <huSh> h:myList" -> "h:myList t ? Where does that go?
19:33:48 <Welkin> huSh: use @lpaste to share you code
19:33:58 <ski> it goes in the indicated place
19:34:00 <Welkin> your*
19:34:02 <Welkin> @lpaste
19:34:02 <lambdabot> Haskell pastebin: http://lpaste.net/
19:34:11 <huSh> @lpaste
19:34:12 <lambdabot> Haskell pastebin: http://lpaste.net/
19:34:24 * ski smiles
19:34:33 <huSh> How do I link back to the code?
19:34:33 <huSh> lol
19:34:44 <ski> it does that automatically, if allowed
19:35:15 <Cale> huSh: You should be sent to the resulting URL when you submit the paste regardless, so you can just copy/paste from your web browser's location bar
19:35:25 <ski> (you have to select #haskell as the channel)
19:35:41 <ski> otherwise, what Cale said
19:35:54 <lpaste> huSh pasted “list” at http://lpaste.net/158481
19:36:45 <ski> huSh : also note that when you want to paste an update, use the "Annotate" button on the original paste, and the update will appear on the same page, for easier comparision
19:36:47 <monochrom> you see "h:myList" in your code? you need to change it to "h:myList t"
19:37:09 <monochrom> it's line 4 column 30ish
19:37:14 <lpaste> huSh annotated “list” with “list (annotation)” at http://lpaste.net/158481#a158482
19:37:28 <huSh> Like that?
19:37:32 <monochrom> now it's good
19:37:33 <Welkin> lpaste bot is spying on you!
19:37:40 <ski> yes
19:38:15 <huSh> It works!
19:38:24 <huSh> tears of joy
19:38:28 <huSh> lol, thank you guys
19:38:47 <lpaste> ski annotated “list” with “indented differently” at http://lpaste.net/158481#a158483
19:38:51 <ski> huSh ^
19:39:13 <huSh> Is that the better coding guidelines of doing it?
19:39:26 <ski> that's how i personally would do it
19:39:31 <huSh> Ok cool
19:39:33 <huSh> Looks better
19:39:54 <monochrom> that is a really big empty list
19:40:01 <ski> yep :)
19:40:06 <monochrom> too big to be a set
19:40:24 <Welkin> a big empty list?
19:40:31 <Welkin> that is an oxymoron
19:41:15 <huSh> I'm so happy this works now lol
19:41:18 <huSh> Thanks again
19:41:22 <ski> no problem
19:41:26 <monochrom> you're welcome
19:41:43 <huSh> You guys are the friendliest bunch, I tried IO programming and nobody talked all day lol
19:42:12 <Welkin> IO programming?
19:42:18 <huSh> Yeah, IO language
19:42:25 * ski would still consider renaming `myList' to something else. like e.g. `myTransform' or `multiplesOf3' or something
19:42:27 <Welkin> yeah, haskell has the best online community I have ever found
19:42:35 <huSh> Io
19:42:50 <Welkin> I learned everything I know about haskell from this channel and reading the materials they recommended
19:42:57 <ski> @where Io
19:42:57 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede' - (perhaps you were looking for `@wiki Introduction to IO' ?)
19:42:58 <Welkin> huSh: the planet? :P
19:43:03 <Welkin> er, the moon?*
19:43:11 <ski> Welkin : clearly that ^ one
19:43:13 <huSh> Lol
19:43:31 <huSh> It's so obscure, I didn't really like it
19:43:40 <huSh> Syntax is easy to learn.  Took 15 minutes
19:43:48 <huSh> But the language is meh
19:43:50 <huSh> Imo
19:43:53 * ski . o O ( "obscure me harder" )
19:43:56 <Welkin> I like the moon better
19:44:01 <huSh> lol
19:44:04 <Welkin> rofl
19:44:09 <Welkin> all these languages named after moons
19:44:14 <Welkin> Ganymede too!
19:44:22 <ski> that's an implementation, not a language
19:44:28 <ski> @where Ganymede
19:44:28 <lambdabot> Implementation by BMeph of the (continuation-based) `Io' language at <http://hackage.haskell.org/package/Ganymede>
19:44:40 <Welkin> a derivative!
19:44:42 * Welkin gasps
19:44:50 * ski hasn't seen BMeph for some while here
19:44:50 <Welkin> stop ruining my moons!
19:45:12 * ski idly wonders what the derivative of a continuation type would be
19:45:15 <monochrom> I can ruin a dwarf planet instead if you like
19:46:44 <huSh> Since I'm dealing with lists.  Is there an easy way to generate a random list?
19:48:27 <ski> for generating random inputs for testing, you might like QuickCheck ("property-based random testing")
19:48:43 <huSh> Uhh, sorry I worded that wrong
19:48:53 <huSh> Can I generate a random list of integers?
19:49:08 <huSh> Well, I found a way to do that but I can't store them as a list
19:49:13 * hackagebot digit 0.2.6 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.2.6 (TonyMorris)
19:49:35 <huSh> @lpaste
19:49:35 <lambdabot> Haskell pastebin: http://lpaste.net/
19:49:56 <lpaste> huSh pasted “random list” at http://lpaste.net/158487
19:50:14 <huSh> It prints 10 random integers, like I want
19:50:19 <ski> > (`evalState` mkStdGen 1234) (replicateM 10 (state (randomR (0,9))))
19:50:21 <lambdabot>  [7,5,1,6,1,2,1,9,1,5]
19:51:05 * ski forgot about `randomIO'
19:51:13 <ski> @type randomRIO
19:51:14 <lambdabot> Random a => (a, a) -> IO a
19:51:29 <ski> that gives a random value, given lower and upper bounds
19:52:06 <huSh> will that then be stored as a variable?
19:52:12 <ski> huSh : "but I can't store them as a list" -- you can store them in a variable
19:52:27 <huSh> Because I want to generate a random list and store it, and then print it in reverse
19:52:37 <ski> in GHCi, you can say :
19:52:50 <ski>   myRandomList <- makeList
19:52:58 <ski> well, if you remove the `>>= print' part, i.e.
19:53:21 <ski> or just
19:53:22 <huSh> So I don't need to import the library?
19:53:29 <ski>   myRandomList <- replicateM 10 (randomIO :: IO Integer)
19:53:39 <ski> or perhaps
19:54:09 <ski>   myRandomList <- do n <- randomRIO (0,9); replicateM n (randomIO :: IO Integer)
19:54:23 <huSh> I'm confused a bit now :(
19:54:29 <ski> (to also randomize the number of elements in the list, between `0' and `9')
19:54:49 <ski> you need `Control.Monad' for `replicateM'
19:54:54 <ski> @indes randomIO
19:54:54 <lambdabot> bzzt
19:54:57 <ski> @index randomIO
19:54:58 <lambdabot> bzzt
19:55:04 <ski> bah
19:55:11 <ski> @hoogle randomIO
19:55:11 <lambdabot> System.Random randomIO :: Random a => IO a
19:55:16 <ski> there we go
19:55:18 <huSh> lol
19:55:28 <huSh> ok so based on my code that I pasted
19:56:04 <lpaste> huSh annotated “random list” with “random list (annotation)” at http://lpaste.net/158487#a158505
19:56:23 <huSh> Or wait, no, that's terminal input ya?
19:56:29 <ski> you can't write `myRandomList <- replicateM 10 (randomIO :: IO Integer)' directly in a source file like that
19:56:35 <ski> it has to be inside a `do'-expression
19:56:56 <ski> however, GHCi acts (roughly) like what you're typing is inside a `do'
19:57:08 <ski> you can say something like
19:57:10 <ski>   main = do
19:57:15 <ski>     myRandomList <- replicateM 10 (randomIO :: IO Integer)
19:57:20 <ski>     ..myRandomList..
19:57:29 <ski> where that latter part presumably involves `print'
19:57:52 <huSh> I have to have main = do?
19:57:58 <ski> you have to name it something
19:58:16 <ski> `main' is just an example name
19:58:19 <huSh> why do I need a do expression here and not in the last program you helped?
19:58:24 <ski> you could add parameters too, if you like
19:58:39 <ski> because `<-' is for `do'-expressions
19:58:49 <zoran119> after importing Data.Map, i try to do this: main = print Map.empty
19:58:56 <ski> (and for list comprehensions, but that doesn't help here. also for pattern guards, which also doesn't help?
19:59:05 <zoran119> compiler says k0 is ambiguous
19:59:14 <zoran119> why is that? and how can i print my empty map?
19:59:30 <ski> huSh : `IO' is a "monad". the most direct way to use it for newbies would be to use the `do' syntax
19:59:44 <huSh> Ok cool
19:59:46 <huSh> thanks
19:59:59 <kadoban> zoran119: You have to tell it what type of Data.Map it should be (what the keys and values are), otherwise it doesn't know how.
20:00:15 <ski> huSh : note that `randomRIO' doesn't return a random number. it returns a *description* of actions to perform, to obtain a random number
20:00:17 <kadoban> zoran119: Usually context would do that fine, but here there's no context. All it knows is that it's an empty Map of … some type.
20:00:46 <huSh> Yeah I read that earlier, but it is still what I need
20:00:49 <ski> huSh : all functions (in Haskell) returns the same (or equal) result, if you give them the same (or equal) inputs
20:01:18 <balinkingofmoria> zoran119: like (Map.empty :: Map ...), no?
20:01:24 <ski> huSh : given the bounds `(0,9)', `randomRIO' will always return the same result, namely the same *description* of how to obtain a random number between `0' and `9'
20:01:34 <huSh> Oh ok
20:01:55 <ski> huSh : actually *executing* that description, performing it, to obtain a random number, will of course usually give you a different random number each time
20:02:06 <zoran119> kadoban: how obvious, thanks!
20:02:30 <huSh> Let me try to put something together then I'll paste it
20:02:43 <ski> huSh : think of the action, the "description of how to obtain ..." as a recipe. the recipe is not the cake. if you execute the recipe another time, perhaps the cake won't turn up quite the same. the recipe is still the same
20:03:29 <huSh> That does make sense
20:03:33 <huSh> But I'm still drawing a blank 
20:04:00 <ski> huSh : because randomness is about (usually) getting a different result each time, we use actions to handle that. that way we don't pollute the normal way that functions work in Haskell (namely always giving the same result, given the same inputs)
20:04:27 <huSh> Yea, I understand that.  But now I am confused about writing my program lol
20:04:29 * ski isn't quite sure atm what huSh is currently trying to do
20:04:36 <huSh> Oh
20:04:57 <huSh> Well I'm still trying to have a list of 10 elements randomly generated
20:05:14 <ski> in GHCi, or in a source file ?
20:05:17 <balinkingofmoria> if IO is a recipe, what does IO () mean?
20:05:21 <huSh> Source file
20:05:34 <balinkingofmoria> where's the recipe information stored?
20:05:35 <huSh> and then store in variable
20:05:44 <balinkingofmoria> is it hidden in the IO type constructor that we can't see?
20:05:51 <ski> balinkingofmoria : a recipe that (presumably) has some side-effects (messing up the baking table ?), but yields no observable direct result
20:05:58 <ski> it's hidden, yes
20:06:05 <roboguy`> balinkingofmoria: IO () is a recipe that gives back the () value (aka unit)
20:06:37 <ski> (perhaps the recipe includes your brother eating all of the cake before you get to see it. you can only see the side-effects)
20:06:47 <roboguy`> > [(), (), ()]
20:06:49 <lambdabot>  [(),(),()]
20:06:58 <balinkingofmoria> yes, but is the recipe itself hidden from our view (since the type that we see doesn't signify what's happening)
20:07:20 <roboguy`> balinkingofmoria: in the case of IO, it always is, not just for IO (). IO Int is also hiddden
20:07:30 <ski> huSh : "Source file","and then store in variable" -- in current Haskell, this means that you have to do it *inside* another definition (like `main' or whatever)
20:07:52 <ski> huSh : so the random thing will be generated every time that other action is executed
20:08:29 <ski> huSh : currently¸ there's no way to have an action get executed when a module is loaded or something like that
20:08:43 <huSh> So I can't do what I want my program to?
20:08:49 <ski> in practice, this is seldom an issue
20:09:02 <ski> huSh : depends. i don't know exactly what you want it to do
20:09:23 <huSh> So the whole program should generate a list of 10 random integers and then print it in reverse
20:09:26 <huSh> that's all
20:09:50 <roboguy`> huSh: you can compile it into an executable and then run it
20:09:51 <ski> huSh : the normal way to do that would be to define `main', and then compile that into an executable
20:10:09 <ski> huSh : when a compiled executable is started, the system begins by executing `main'
20:10:10 <huSh> I know how to print lists in reverse, but I can't get my randomly generated list to store in variable
20:10:29 <ski>   main = do
20:10:32 <ski>     myRandomList <- replicateM 10 (randomIO :: IO Integer)
20:10:45 <ski>     let reversedRandomList = reverse myRandomList
20:10:47 <huSh> in the source file?
20:11:00 <ski>     putStrLn ("The list : " ++ show myRandomList)
20:11:07 <tippenein> What are my options as far as generating html forms? digestive-functors? I'd like to convert a data type to an html representation
20:11:07 <ski>     putStrLn ("The reversed list : " ++ show reversedRandomList)
20:11:10 <ski> huSh : yep
20:11:38 <ski> huSh : if you want to try it out in GHCi, just load the file, and type `main' (or `:main') into GHCi
20:12:32 <ski> huSh : anyway, that ^ is how you "get my randomly generated list to store in variable" (namely `myRandomList'. also `reversedRandomList' is the reversed list, stored in a variable)
20:12:36 <roboguy`> huSh: you can also use "runghc" on the file instead of ghci, to run it immediately
20:13:00 <huSh> ok one sec, let me try this
20:13:11 <ski> @src print
20:13:11 <lambdabot> print x = putStrLn (show x)
20:13:23 <ski> `print' is a wrapper around `putStrLn' and `show'
20:13:39 <ski> i used the latter two above, since i wanted to add a "header" message to each of the two lines
20:14:09 <ski> `show' converts to a string (in the format of a Haskell expression that would evaluate to the original value)
20:14:33 <ski> `putStrLn' returns an action that, when executed, will output the chars in the string, and additionally a newline
20:14:43 <ski> @type putStrLn
20:14:44 <lambdabot> String -> IO ()
20:15:14 <ski> (it also yields a result of type `()' when executed, but that's uninteresting. we ignore it above)
20:16:10 <huSh> Should putStrLn ("The list : " ++ show myRandomList) be ++ show reversedList?
20:16:32 <ski> huSh : note how i used `result <- action' to name the `result' of executing the `action'. while i used `let name = expression' to `name' the (value of the) `expression' itself
20:16:53 <ski> huSh : nope. i wanted to first show the original, unreversed, random list
20:17:15 <Gurkenglas> (I like to see it as "No IO in the .hs is run at all; the definition of main just lets the compiler calculate what the compiled executable should behave like.")
20:17:24 * ski nods
20:17:44 <huSh> I'm getting an error because of the "import"
20:18:17 <huSh> should the import be outside of the main = do?
20:18:26 <ski> no
20:18:29 <ski> er
20:18:32 <ski> yes, i mean
20:18:40 <ski> it should not be inside of the `do'
20:19:37 <huSh> How do I limit the integers so they don't print 23423423423?
20:19:38 <huSh> lol
20:19:53 <ski> use `randomRIO (low,high)' instead of `randomIO'
20:20:17 <ski> (where `low' and `high' are, respectively, your desired lower and upper bounds)
20:20:35 <ski> @type randomIO
20:20:37 <lambdabot> Random a => IO a
20:20:37 <ski> @type randomRIO
20:20:39 <lambdabot> Random a => (a, a) -> IO a
20:21:04 <ski> you could also use something like
20:21:12 <huSh> omg it works
20:21:14 <ski>   n <- randomRIO (0,9)
20:21:15 <huSh> IT WORKS!
20:21:32 <ski> and then `replicateM n (...)' instead of `replicateM 10 (...)', to also randomize the length of the list
20:21:37 <lpaste> huSh annotated “random list” with “random list (annotation) (annotation)” at http://lpaste.net/158487#a158526
20:21:55 <huSh> Check that out
20:22:01 <huSh> It works, omg I'm so happy lol
20:22:22 <Gurkenglas> wait how could that possibly work the do block isnt indented
20:22:28 <ski> you should indent the lines belonging to `main', after the `do', more
20:22:35 <zoran119> is there something like Data.Map but that keeps keys in the insertion order?
20:22:41 <ski> (otherwise you can't define top-level things after `main')
20:22:52 <ski> Gurkenglas : flexible indentation rule
20:23:19 * ski forgots the exact name
20:23:36 <lpaste> huSh annotated “random list” with “random list (annotation)” at http://lpaste.net/158487#a158527
20:23:42 <huSh> Like that?
20:24:07 <ski> except that `main' should still start in the same column as the `import ...' declarations
20:24:17 <ski> otherwise, yes
20:24:21 <huSh> Ok cool
20:24:26 <roboguy`> you don't need to indent the entire file after "module Main where ..."
20:24:28 <huSh> Man, you have been a huge help
20:24:33 <Gurkenglas> zoran119, you mean keys that are inserted later should be further left if you do toAscList?
20:24:40 <ski> roboguy` : i usually do, anyway :)
20:24:46 <Gurkenglas> *that are inserted earlier <.<
20:25:12 <balinkingofmoria> huSh: why not use $ more?
20:25:26 <roboguy`> ski: huh. I've never seen a module like that. I usually try to keep things as far to the left as possible so it's easier to fit more on the screen, but I guess it's just a style thing
20:25:38 <zoran119> Gurkenglas: i'm just printing my map to the console atm, but yes, when i print it i'd like the keys i inserted earlier to be printed first
20:25:40 <Gurkenglas> Oh so that rule is how the "module Main where" part without everything else being indented makes sense
20:25:42 <huSh> Idk what $ does...
20:25:47 <zoran119> Gurkenglas: i hope that makes sense...
20:26:04 <balinkingofmoria> huSh: it's called the function application operator
20:26:07 <ski> balinkingofmoria : why use `$' if there's no call for it ?
20:26:18 <huSh> What's it do?
20:26:26 * ski wouldn't use `$' anywhere in that paste
20:26:37 <balinkingofmoria> for the record, I am a newbie
20:26:43 <balinkingofmoria> should $ only be used in certain situations?
20:26:59 <arahael> huSh: $ is a function.  it's mainly used to avoid needing parenthesis in some situations.
20:27:01 <balinkingofmoria> I guess I figured that it's useful whenever it doesn't confuse things and there's parentheses
20:27:07 <ski> zoran119 : how about `fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a' ?
20:27:09 <huSh> Oh ok
20:27:19 <balinkingofmoria> f $ x = f x
20:28:01 <orion> If you have a function runThing :: (Foo a, Bar b, Baz c) => SomeType a b c -> IO (SomeOtherThing c), what is the best way to have a, b, and c determined at runtime?
20:28:04 <balinkingofmoria> ski : when would one use `$'?
20:28:07 <ski> zoran119 : you could start with `[(0,"a"),(1,"b"),(0,"c")]', which only gets you two associations. which order do you want ?
20:28:09 <Gurkenglas> zoran119, you could use M.size to keep each key's seniority with it in the map, because that information is usually discarded, and then sort by that after the toList
20:28:29 <balinkingofmoria> origin : wouldn't they be inferred at compile time?
20:28:44 <ski> balinkingofmoria : usually only directly before `\'. sometimes in other cases, but not too often
20:28:52 * ski things `$' is way overused
20:28:56 <ski> s/things/thinks/
20:29:58 <ski> Gurkenglas : "Oh so that rule is how .." -- hm, i think that worked even without the relaxed indentation rule
20:30:19 <Gurkenglas> shh I have new headcanon
20:30:29 <ski> orion : perhaps to use GADTs
20:31:35 <ski> orion : `data KeyType :: * -> * where KTCurve25519 :: KeyType Curve25519; KTCurve448 :: KeyType Curve448' would be an example
20:31:46 <ski> orion : you'd also need existentials
20:31:58 <Gurkenglas> You should be allowed to have the only thing in a .hs file be a giant do block without a do in front that is treated as the main
20:32:17 <ski> Gurkenglas : perhaps :)
20:33:27 <ski> orion : the GADTs aren't strictly necessary, but something tells me that you possible want to use them here as well
20:33:43 <ski> orion : existentials are necessary, though
20:34:04 <Gurkenglas> Only modern haskell requires language extensions and those would clutter that dream of pythonesque scripts of minimized token count
20:34:19 <orion> ski: After the GADTs are defined, what is the next step?
20:35:25 <ski> orion : start by determining the function(s) that introduce the new types into the type signature, without them being mentioned in the argument types
20:36:24 <ski> orion : if your `readKey :: Curve d => FilePath -> IO (KeyPair d)' actually instead wanted to read the curve type from the file, then this would be a candidate for that
20:36:53 <orion> ski: I've moved away from the readKey problem.
20:37:11 <ski> orion : GADTs should be used, if called for. i don't know whether that's the case in your situation
20:38:29 <orion> The new problem is thus: I'm able to successfully read four bytes from a socket indicating four different parameters for how the rest of the code should operate (handshake type, cipher, curve, hash).
20:38:30 <ski> orion : presumably you have some ideas about where "have a, b, and c determined at runtime" would happen in your code ?
20:38:46 * ski nods
20:39:01 <orion> The function I want to call, runHandshake, is defined here: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/HandshakeState.hs#L173
20:40:12 <orion> At this point I can figure out what the remote peer wants, but I don't know how to deliver it -- I don't know how to call runHandshake.
20:40:26 <orion> Do you think GADTs are a good candidate for this?
20:41:18 <ski> i think existentials could be a good candidate for being able to call `runHandshake'
20:41:24 <ski> dunno about GADTs yet
20:41:58 <ski> `HandshakeState c d h' and `HandshakeCallbacks d' here comes from (or are computed from) ht initial four bytes read ?
20:42:07 <ski> s/ht/the/
20:42:44 <ski> do you have some attempt of code computing these ?
20:42:50 <orion> Given those four choices, a (HandshakeState c d h) can be delivered.
20:43:03 <orion> (HandshakeCallbacks d) can be delivered too.
20:43:29 <ski> but the types `c',`d',`h' presumably depends on the actual values of those four bytes ?
20:43:40 <huSh> Hey Ski, another quick question
20:44:00 <ski> are you reading these four bytes in one go, or do you want to break it up somewhat more ?
20:44:08 <ski> (not that those are exclusive alternatives)
20:44:14 <orion> ski: There is a 1:1 relationship between what those bytes are and the types to which they map.
20:44:18 <ski> good
20:44:24 <huSh> I had a program that I compile using "ghc -o program1 program1.hs " and then doing "./program1
20:44:32 <huSh> but it says not in scope for everything
20:44:40 <ski> do you have types for encoding the allowed values of these bytes ?
20:44:51 <huSh> Well it worked before
20:44:55 <huSh> I havent changed anythin
20:44:57 <huSh> g*
20:45:10 <ski> huSh : paste it ?
20:45:19 <huSh> The error?
20:45:34 <orion> ski: This is what I have so far: http://lpaste.net/6438269234991595520
20:45:51 <huSh> @lpaste
20:45:51 <lambdabot> Haskell pastebin: http://lpaste.net/
20:45:57 <ski> huSh : oh, you're talking about the last program at <http://lpaste.net/158487> (sans fixing the indentation) ?
20:46:17 <lpaste> huSh pasted “random” at http://lpaste.net/158548
20:46:25 <huSh> No, this one
20:46:31 <huSh> It's just a hello world
20:46:49 <huSh> But I wanted to generate a file
20:47:10 <huSh> Using the -o command, which worked...  But now it wont
20:47:11 <huSh> idk why
20:47:29 <ski> huSh : that should work, (though perhaps you wanted `putStrLn' instead of `print'. not that that should matter for being able to compile it)
20:48:00 <ski> huSh : can you annotate the compilation error ?
20:48:55 <lpaste> huSh annotated “random” with “random (annotation)” at http://lpaste.net/158548#a158549
20:49:31 <shanemikel> so, how does the stack global project work?
20:49:39 <ski> orion : ok, let's look at `curveByteToType' first, since you changed `CurveType' along the GADT lines i suggested
20:49:41 <shanemikel> does it contaminate other stack projects?
20:49:54 <mgsloan> Nope
20:50:11 <mgsloan> It works the same as any other stack project, it's just a fallback default if there is no project
20:50:13 <ski> huSh : `ghc' isn't a GHCi command. run it in your shell, not inside GHCi
20:50:26 <huSh> oh jeez... lol thank you
20:50:30 <orion> ski: Ok, I'm looking at it.
20:50:41 <ski> huSh : if you insist, do `:!ghc ...'
20:51:08 <shanemikel> wheres the cabal file for it?
20:51:14 <huSh> That works!
20:51:14 <ski> to a first approximation, you want something like
20:51:15 <shanemikel> how do I add libraries to it?
20:51:16 <huSh> Thanks man, so much
20:51:17 <ski>   curveByteToType :: Word8 -> CurveType a
20:51:32 <ski> orion : since `CurveType' now expects an argument
20:52:04 <ski> however, this won't work exactly, since that would really mean
20:52:08 <ski>   curveByteToType :: forall a. Word8 -> CurveType a
20:52:14 <orion> ski: One thing to point out, that GADT doesn't work because there is no data constructor for 'Curve25519'.
20:52:33 <ski> which is promising to return a value of type `CurveType a', for every `a' the *caller* wants
20:52:57 <ski> orion : oh, that. just change to `curveByteToType 0 = CTCurve25519',&c.
20:53:13 <orion> ah
20:53:22 <ski> orion : anyway, i hope you're seeing the above point with `forall'
20:53:58 <ski> the point here is to let `curveByteToType' itself determine what type `a' to use. the caller doesn't get to pick it
20:54:03 <ski> agree ?
20:54:05 <MarcelineVQ> shanemikel: you shouldn't want to do that typically, are you perhaps trying to install an executable and it wants extra libraries from hackage? you put the names (including the version) of the packages it asks for into the extra-deps section of your stack.yaml in that case
20:54:08 <orion> ski: I'm with you.
20:54:17 <ski> so, this suggests (conceptually) :
20:54:25 <ski>   curveByteToType :: Word8 -> exists a. CurveType a
20:55:18 <ski> however, looking at `runHandshake', we probably also need to know that `a' is an instance of the type class `Curve', so we change this into
20:55:23 <ski>   curveByteToType :: Word8 -> exists a. Curve a *> CurveType a
20:55:33 <shanemikel> no, it's not a big deal, just that I'll sometimes follow a tutorial or something and be too impatient to start a project, and if stack global doesn't leak into the other projects, it seems like that'd be fine
20:55:45 <mgsloan> MarcelineVQ: One nice invocation with the global project is "stack ghci --package lens" - e.g. I want to load ghci and make sure it has lens
20:56:04 <ski> this means that, `curveByteToType', when given a `Word8', will pick some type `a', that is an instance of `Curve', and return a value of type `CurveType a'
20:56:14 <orion> The *> notation is new to me.
20:56:28 <MarcelineVQ> shanemikel: it's a really good habbit to make a new project for new things, alternatively you could make one project that houses multiple tutorials
20:56:44 <MarcelineVQ> mgsloan: I'll have to remember that
20:57:12 <ski> (since you're using GADTs here, the `Curve a *> ' isn't strictly necessary .. but then to recover the `Curve a' part where needed, we'd need to pattern-match on all the different cases of `CurveType' .. so it seems simpler to just bundle this information from the start here)
20:57:15 <shanemikel> yeah, I'm thinking of doing that.  but I still would like to know how to manage which modules are available to the global project
20:57:21 <shanemikel> err packages
20:57:54 <ski> orion : a value of type `cxt *> t' means that you both *get* evidence that `cxt' holds, and in addition a value of type `t'
20:58:13 <mgsloan> shanemikel: Well, it's really any of the ones you install.  Since the global project doesn't have any cabal packages, you can't really build code in an isolated env that demands a specific set of deps
20:58:21 <ski> orion : a value of type `cxt => t' means that *if* you can provide evidence that `cxt' holds, *then* you get a value of type `t'
20:58:33 <ski> orion : `*>' usually goes with `exists'. `=>' usually with `forall'
20:58:42 <orion> ski: I see.
20:58:44 <mgsloan> So if you do "stack exec ghci" or "stack runghc" with the global project, any packages that happen to be installed are available
20:59:12 <mgsloan> (same with normal projects too of course.  Pretty much everything is the same with normal projects, just a different location and usually you have packages)
20:59:54 <orion> ski: I have the following now: curveByteToType :: Word8 -> exists a. Curve *> CurveType a; curveByteToType 0 = CTCurve25519; and I get this compiler error: Illegal symbol '.' in type Perhaps you intended to use RankNTypes or a similar language extension. I have the following language extensions enabled: OverloadedStrings, RankNTypes, RecordWildCards, KindSignatures, GADTs
20:59:57 <ski> orion : `*>' is syntax i use to describe this concept. it's not implemented. `exists' isn't really implemented either (it's in LHC, but only in function argument type position, which doesn't add any extra power over `forall', only convenience (hiding things in type synonyms). we need the extra power here)
21:00:58 <ski> orion : however, i think it's useful to conceptually make it clear to oneself *what* one wants to express, using `exists' and `*>' pseudo-Haskell, before *encoding* it in existing Haskell (with extensions) (there's two different ways to encode it)
21:01:11 <shachaf> @let data k *> a = k => Foo a
21:01:12 <lambdabot>  Defined.
21:01:17 * ski smiles
21:02:20 <ski> orion : so, what we're going to do, is to make a new datatype, that *encodes* `exists a. Curve a *> CurveType a' (you forgot one `a' there)
21:02:42 <ski> orion : this entails auxilary wrapping and unwrapping data constructors
21:03:08 <ski> you define it like
21:03:30 <ski>   data SomeCurveType = forall a. Curve a => WrapCurveType (CurveType a)
21:03:39 <ski> or, alternatively, using GADT syntax
21:03:43 <ski>   data SomeCurveType
21:03:44 <ski>     where
21:03:59 <ski>     WrapCurveType :: forall a. Curve a => CurveType a -> SomeCurveType
21:04:20 <ski> conceptually, the type signature for the data constructor `WrapCurveType' here is equivalent to
21:04:30 <ski>   WrapCurveType :: (exists a. Curve a *> CurveType a) -> SomeCurveType
21:04:33 <ski> which is what we want
21:05:10 <ski> when `WrapCurveType' is applied to a value of type `CurveType a', for any `a', we get something of type `SomeCurveType', not mentioning `a'
21:05:16 <ski> `a' is hidden/forgotten
21:05:46 <ski> (well, not for any old `a', it must be an `a' in `Curve', of course)
21:06:28 <ski> therefore when we have a value of type `SomeCurveType', and match it with a pattern `WrapCurveType ct', we know that `ct :: CurveType a', and we know that this `a' is in `Curve', but we know *nothing* else about `a'
21:06:46 <ski> orion : does that make sense ?
21:07:14 * orion ponders
21:07:40 <ski> in general, the type `a' couldn't be recovered at all, when pattern-matching
21:08:06 <ski> in *this* particular case, it can actually be recovered. by pattern-matching further on the GADT value `ct'
21:08:40 <ski> but that's because the data constructors of `CurveType a' *enumerate* *explicitly* the corresponding type that `a' is in each case
21:10:16 <ski> orion : so the plan is : instead of having something like `curveTypeParser :: Parser (exists c. Curve c *> CurveType c)', which would be idea, we could instead use `curveTypeParser :: Parser SomeCurveType'
21:10:39 <ski> orion : then, the caller of `curveTypeParser' will have to manually unwrap the `WrapCurveType' data constructor
21:11:28 <ski> (oh, i suppose you used `d' for the curve type tag ..)
21:12:08 <ski> orion : well, you now have `headerParser :: Parser (HandshakeType, CipherType, CurveType, HashType)'
21:12:37 <ski> orion : in case you wanted to use the same curve type variable `d' in there, you'd need to make a bigger "wrapping type"
21:12:52 <ski> orion : but, iiuc, you don't need to do that in this case
21:13:31 <ski> orion : if you want to have similar existentials for `HandshakeType',`CipherType',`HashType', then you do the same for them
21:13:47 <orion> ski: I'm going to paste updated code in a moment.
21:13:51 * ski nods
21:14:13 <ski> s/would be idea/would be ideal/
21:15:21 * ski suspects that at least `CipherType' could gainfullt be made into a GADT, here
21:18:52 <ski> orion : the alternative *encoding* to using an "existential data type (constructor)" as above would be to introduce a callback. in terms of `curveTypeParser', i suppose this would be
21:19:59 <ski>   curveTypeParserWith :: (forall c. Curve c => CurveType c -> Parser o) -> Parser o
21:20:12 <ski> though i suppose that'd be less useful in this case
21:20:44 <orion> ski: This code compiled successfully. Is it what you intended?: http://lpaste.net/7669689096658223104
21:20:49 <ski> (that requires the `Rank2Types' extension. the previous alternative requires `ExistentialQuantification' (imho a misnomer))
21:21:32 <ski> orion : yep
21:22:42 <ski> when you constructs the `HandshakeState c d h' for `runHandshake', you need to unpack the `WrapCurveType' to recover the `Curve d' constraint
21:23:09 <orion> By unpack do you mean pattern match?
21:23:41 <ski> orion : the `:: * -> *' part (`KindSignatures') isn't strictly necessary. however i think it's nicer than writing `data CurveType a where ...' there
21:23:45 <ski> orion : yes
21:25:03 <ski> (because the `a' name is in that case useless. because the data constructors will name the specific value anyway)
21:25:16 <orion> hmm
21:25:31 <ski> that's just cosmetics
21:27:20 <orion> So let me see if I understand correctly.
21:28:15 <orion> The next step is to write a function, say, mkHandshake :: (Cipher c, Curve d, Hash h) => SomeCipherType -> SomeCurveType -> SomeHashType -> Handshake c d h correct?
21:28:39 <ski> minus the `(Cipher c, Curve d, Hash h) => 'part
21:29:11 <ski> a value of type `SomeCurveType' carries inside it already a `Curve d' constraint, and a value of type `CurveType d', for *some* (unknown) `d'
21:29:17 <orion> Is it true that I will need to write a separate function/pattern match for each permutation?
21:29:43 <orion> i.e.: num cipher types * num curve types * num hash types
21:30:07 <ski> so, to express the result type correctly here, you'd also need to make a `SomeHandshake', encoding `exists c d h. (Cipher c,Curve d,Hash h) *> Handshake c d h'
21:30:10 <ski> and then you get
21:30:20 <ski>   mkHandshake :: SomeCipherType -> SomeCurveType -> SomeHashType -> SomeHandshake
21:30:24 <ski> encoding
21:31:18 <ski>   mkHandshake :: (exists c. Cipher c *> CipherType c) -> (exists d. Curve d *> CurveType d) -> (exists h. Hash h *> HashType h) -> (exists c d h. (Cipher c,Curve d,Hash h) *> Handshake c d h)
21:31:26 <ski> however ..
21:31:38 <ski> it might be simpler to just use here
21:32:00 <ski> mkHandshake :: (Cipher c, Curve d, Hash h) => CipherType c -> CurveType d -> HashType h -> Handshake c d h
21:32:20 <ski> (that type signature is also slightly more powerful, promises more. though that probably doesn't matter in your case)
21:32:51 <ski> using this version, you'd unpack the `SomeCipherType',`SomeCurveType',`SomeHashType's before calling `mkHandshake'
21:33:06 <ski> means you get less existential-data-constructor wrapping and unwrapping, which is good
21:33:13 <ski> (less bother)
21:33:35 <orion> Like this?: mkHandshake (WrapCipherType c) (WrapCurveType d) (WrapHashType h) = ...
21:33:56 <ski> that's what it would look like, with the first alternative, yes
21:34:17 * hackagebot ghc-imported-from 0.3.0.4 - Find the Haddock documentation for a symbol.  https://hackage.haskell.org/package/ghc-imported-from-0.3.0.4 (CarloHamalainen)
21:34:44 <orion> But, I'm not sure how the values (not types) c, d, and h help me.
21:35:18 <ski> you can pattern-match on `d', to determine whether it's `CTCurve25519' or `CTCurve448'
21:35:41 <ski> presumably that will help to determine which `Handshake c d h' value to return, no ?
21:37:06 <orion> hmm
21:37:50 <ski> (btw, by `Handshake', you really mean `HandshakeState', no ?)
21:37:57 <orion> yes
21:38:01 * ski looks at the definition of `HandshakeState'
21:38:17 <ski> how is the `SymmetricState c h' computed ?
21:38:39 <orion> https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/SymmetricState.hs#L49
21:39:10 <ski> ok
21:39:12 <ski>   symmetricState :: forall c h. (Cipher c, Hash h) => ScrubbedBytes -> SymmetricState c h
21:39:29 <ski> so you don't need to match on the (value) `c' and `h' for this
21:39:58 <orion> I never call symmetricState, it's an internal library function.
21:39:59 <ski> (because we thought to include the `Cipher' and `Hash' constraints in `SomeCipherType' and `SomeHashType'. otherwise we'd had to do that)
21:40:20 <ski> hm, ok
21:40:40 <ski> well, it's exported from the module
21:40:46 <ski> who is (to) call it ?
21:40:53 <orion> https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/HandshakeState.hs#L129
21:41:50 <ski> ok. now i'm looking for who calls `handshakeState' :)
21:42:04 <orion> Me.
21:42:36 <orion> The README has an example of how to use the library: https://github.com/centromere/cacophony
21:44:21 <ski> orion> :t noiseIK
21:46:04 <orion> https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/HandshakePatterns.hs#L280
21:46:19 <orion> https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/HandshakePattern.hs#L52
21:47:16 <ski> orion : iiuc, whoever (directly or indirectly) calls `headerParser' will want to compute matching `HandshakePattern c' (and possibly `KeyPair d' and `PublicKey d') values for `HandshakeStateParams c d', for calling `handshakeState'
21:48:21 <ski> orion : `noiseIK :: HandshakePattern c' works for any cipher `c' ?
21:48:53 <ski> oh, i think i see
21:49:14 <ski> hm
21:49:56 <orion> ski: HandshakePatterns are mini programs (DSL -- free monad style) that spit out symmetric keys parameterized by the cipher.
21:50:20 <ski> (yes or no ? :)
21:50:44 <orion> noiseIK works for any Cipher c, guaranteed.
21:51:36 <ski> ok, good
21:51:58 <orion> Although, I don't have a class constraint on c.
21:52:18 <ski> how about any of the other producers of `HandshakePattern c' ? also polymorphic in `c' ?
21:52:47 <orion> Are you referring to everything in HandshakePatterns.hs?
21:53:02 <orion> noiseNN, noiseKN, etc.
21:53:07 <ski> yeah
21:53:19 <orion> Every single one of those is guaranteed to work with any Cipher c.
21:53:29 <ski> just wanting to check that there aren't any of them that don't work for any `c'
21:53:32 <ski> good
21:54:01 <orion> Maybe there should be a class constraint on them?
21:54:34 <ski> if it's not forced by the type system, then it'd leave it out, if there isn't a conceptual reason for it to be present
21:55:03 <orion> ok
21:55:34 <ski> (i don't understand the details of how a `HandshakePattern c' works, so i can't determine that. i see that it involves a `CipherState c', including a `SymmetricKey c' and a `Nonce c', though
21:55:45 <ski> )
21:55:58 <orion> https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Cipher.hs#L25
21:56:19 <ski> how about the key fields of `HandshakeStateParams c d', though ?
21:57:21 <ski> ok, you're using associated types. that's akin to using GADTs, in this context
21:57:25 <orion> hsp{Local|Remote}{Static|Ephemeral}Key work for all Curve d.
21:57:55 <ski> ok
21:59:27 <ski> orion : anyway. whoever calls `handshakeState' will have to provide evidence for `(Cipher c,Curve d,Hash h)'. in the case of using `headerParser', this will come from opening the respective existentials
22:00:29 <orion> headerParser is wrapping, not unwrapping.
22:01:05 <ski> yes. but whoever calls that, and wants to call `handshakeState' using the results of the former, will need to unwrap the former
22:02:11 <ski> the first four bytes parsed determines which cipher type, curve type, and hash type to use
22:02:21 <orion> Yes.
22:03:21 <ski> to make the `Cipher c',`Curve d',`Hash h' evidence hidden inside `SomeCipherType',`SomeCurveType',`SomeHashType' available for use by e.g. `handshakeState', you will need to unwrap the former
22:05:49 <ski> if all the fields of `HandshakeStateParams c d' that you use are polymorphic in `c' and `d', you may need to use `ScopedTypeVariables' to force the use of the particular `c' and `d' that you get from `headerParser'
22:06:06 <tiensonqin> ?src ($)
22:06:06 <lambdabot> f $ x = f x
22:06:14 <tiensonqin> ?src (map)
22:06:15 <lambdabot> Source not found. Are you on drugs?
22:06:20 <tiensonqin> ?src map
22:06:20 <lambdabot> map _ []     = []
22:06:20 <lambdabot> map f (x:xs) = f x : map f xs
22:06:24 <ski> and seeing how the argument doesn't mention `h', you would probably need to do that for `h' anyway
22:10:01 <orion> ski: I am unwrapping a value. Where am I passing that value?
22:10:42 <ski> nowhere, if you don't need to
22:10:57 <tiensonqin> ?src foldl
22:10:58 <lambdabot> foldl f z []     = z
22:10:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:11:10 <tiensonqin> ?src foldr
22:11:10 <lambdabot> foldr f z []     = z
22:11:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:11:20 <ski> the constraint evidence gets propagated automatically where it needs to go (assuming the system sees where it must go. hence you may need an explicit type annotation)
22:11:23 <orion> Oh right, the value is opaque, right?
22:11:46 <ski> if you want to transmit the plain `CurveType c' value somewhere, you may do so
22:12:04 <ski> but if you only here need the `Curve c' constraint evidence, then there's no need to
22:12:18 <ski> the pattern-match should be sufficient to bring the constraint into scope
22:13:03 <ski> "if you want to transmit the plain `CurveType c' value somewhere" -- iow, if someone wants to know the specific curve type, as opposed to what can be determined from the `Curve c' instance for it
22:13:10 <ski> (s/c/d/)
22:13:13 <orion> Here's the thing though
22:14:02 <orion> There are 13 handshake types * 2 cipher types * 2 curve types * 4 hash types = 208 possible combinations
22:14:07 <jle`> tiensonqin: did you know that you can use lambdabot in pm? :)
22:14:22 <orion> Does this imply that I will need 208 pattern matches?
22:14:40 <ski> depends on whether you can factor it better than this
22:14:53 <ski> possibly there's some independence
22:15:51 <ski> "factor it" meaning factor the construction of the `HandshakeStateParams c d', e.g.
22:16:48 <lifter> Haskell FTW!
22:16:52 <ski> your <https://github.com/centromere/cacophony> only has two examples, so i don't see how different combinations of these four types would look
22:17:51 <ski> `local_static_key' and `remote_static_key' determines `d'
22:19:18 * hackagebot quiver-groups 0.1.0.0 - Group and chunk values within a Quiver  https://hackage.haskell.org/package/quiver-groups-0.1.0.0 (IvanMiljenovic)
22:20:11 <orion> ski: Eventually you must force a c and h on HandshakeState.
22:21:08 <ski> assuming `_hsSymmetricState' and `_hsPattern' doesn't fix them, yes
22:21:26 <ski> (`hspPattern' in the case of `HandshakeStateParams')
22:21:27 <orion> (They don't)
22:21:50 <ski> anyway, say you're enabling `ScopedTypeVariables'
22:21:58 <ski> then, say you have
22:22:10 <ski>   case (someCipherType,...) of
22:22:13 <orion> If you did "let responderState = handshakeState ... :: HandshakeState AESGCM Curve25519 SHA512" then those cryptographic primitives would be used for the handshake.
22:22:26 <ski>     (WrapCipherType (_ :: c),...) ->
22:22:42 <ski> then you can use the type variable `c' to force it
22:23:09 <ski> er, actually `_ :: CipherType c' there
22:23:39 <ski> then you could use `let responderState = handshakeState ... :: HandshakeState c ...'
22:23:58 <ski> orion : ok ?
22:24:53 <orion> Makes sense.
22:25:56 <ski> see the part about "existential data constructors" at <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#pattern-type-sigs> for info on this
22:26:26 <orion> I appreciate all your help tonight.
22:26:41 <ski> i hope it's starting to come together a bit in your mind, now
22:27:27 <ski> if i'm not missing something important in what you're doing, i believe it's just a "matter of programming" now
22:28:01 <orion> I think so too. I am actively trying to make progress.
22:28:49 <ski> anyway, this is a nice example of using existentials (and GADTs) in practice :)
22:29:19 * hackagebot poppler 0.14 - Binding to the Poppler.  https://hackage.haskell.org/package/poppler-0.14 (IanWooKim)
22:30:01 <orion> I should write a blog post about it.
22:30:22 <Axman6> yes please
22:31:08 <orion> I'll need one or two reviewers before I publish it though. I'm not qualified to teach what I've just learned tonight to someone else in an authoritative capacity.
22:33:12 <ski> (i think the use of the GADTs here is, atm, mostly convenience)
22:34:03 <ski> instead of `WrapCurveType :: forall d. Curve d => CurveType d -> SomeCurveType', you could probably use instead `WrapCurveType :: forall d. Curve d => d -> SomeCurveType', with no `CurveType' at all
22:34:39 <ski> orion : btw, fyi, the `forall d.' part in the constructor signature here is optional, as usual
22:35:21 <ski> (i mostly mentioned it previously, for emphasis, and contrast with `exists')
22:36:03 <ski> orion : you should note the logical law that `(exists a. ..a..) -> ...' is equivalent to `forall a. (..a.. -> ...)' (where `...' doesn't mention `a' freely)
22:36:17 <ski>   length :: forall a. [a] -> Int
22:36:20 <ski> means the same as
22:36:28 <ski>   length :: (exists a. [a]) -> Int
22:36:48 <ski> the former says that, for any type `a', `length' can be called on a `[a]', yielding an `Int'
22:37:18 <ski> the latter says that, if there's an `a' such that the argument has type `[a]', then `length' can be called on that, yielding an `Int'
22:37:29 <ski> these are just two different ways of saying the same thing
22:38:05 <ski> analogously, `(cxt *> ...) -> ...' is equivalent to `cxt => ... -> ...'
22:38:28 <orion> This is closely related to ∃ and ∀
22:38:34 <ski> yes
22:39:05 <ski> `forall' and `exists' *are* the universal and existential quantifiers, in types
22:39:38 <ski> the `(cxt *> ...) -> ...' vs. `cxt => ... -> ...' situation is comparable to currying `(A,B) -> C' into `A -> B -> C'
22:40:00 <ski> (and `(exists a. ..a..) -> ...' vs. `forall a. (..a.. -> ...)' is also comparable to that currying)
22:42:34 <shanemikel> is there a stack  channel?
22:42:53 <kadoban> #haskell-stack
22:44:19 * hackagebot hylogen 0.1.0.4 - a tiny EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.4 (sleexyz)
22:46:19 <NeverDie> How do I pull data from an API with Haskell?
22:47:11 <ski> ok, actually you have no data constructor in `data Curve25519'. so with the `WrapCurveType :: Curve d => d -> SomeCurveType', you'd then have to say `WrapCurveType (undefined :: Curve25519)', rather than say `WrapCurveType MkCurve25519'
22:47:28 <ski> the former feels a little bit uncomfortable, but that's the difference, as compared to the current `WrapCurveType CTCurve25519')
22:47:31 <NeverDie> JSON data that is.
22:47:50 <cocreature>  NeverDie you can use @hackage wreq
22:47:56 <cocreature> @hackage wreq
22:47:56 <lambdabot> http://hackage.haskell.org/package/wreq
22:48:37 <ski> the difference with not using a GADT `CurveType' here is that you can't recover the specific `d' for which `Curve d' holds (unless the `Curve' type class admits a way to do that, which i doubt. at least i doubt it doing it in a way that the type-system understands)
22:48:44 <ski> orion : fwiw ^
22:50:33 <tippenein> is there a `nub` for Vectors?
22:52:15 <NeverDie> Do I grab modules from hackage with Cabal?
22:53:17 <liste> NeverDie: usually you add the dependencies of your project to the project's .cabal file and then do "cabal install --only-dependencies" (or "stack build" if you're using Stack)
22:53:20 <cocreature>   tippenein I don’t think there is but vectors are also a bad data structure for that. it’s probably a better idea to convert to a list, nub (note that the nub in Data.List is crap) and then go back to a vector
22:53:36 <NeverDie> liste: Should I use stack for all of my projects?
22:53:52 <liste> NeverDie: depends. it certainly is the easier route
22:54:06 <cocreature> it’s harder to screw up with stack, so if you are a beginner it’s probably a good idea
22:54:48 <tippenein> cocreature: well, to be more clear, I want to deduplicate values in a csv row. Is it still advisable to convert to a list first?
22:55:00 <tippenein> in a csv _column_*
22:55:15 <NeverDie> Do I do `stack new PROJECT` or `stack new PROJECT simple`?
22:55:37 <cocreature> tippenein: the problem with vectors is that everytime you want to remove something in the middle you need to copy the whole vector. with a list removing something is cheap
22:55:49 <cocreature> tippenein: so yeah I think converting to a list is the right thing to do here
22:56:23 <cocreature> tippenein: you could also just insert all values into a set, then allocate a vector with the right size and put them in there. that might be a bit faster
22:56:26 <kadoban> NeverDie: Depends which template you want to use. You can set a default so you don't need to specify in the future.
22:56:32 <ski> tippenein : with luck (?), you may get list fusion
22:56:41 <NeverDie> kadoban: I don't have any defaults, this would be the first time I do this.
22:56:47 <NeverDie> What would you recommend?
22:56:47 <tippenein> yeah, makes sense. I was thinking about folding a new vector, but it would be a lot of searching through
22:56:56 <NeverDie> I just plan on making a simple currency converter for now.
22:57:20 <kadoban> NeverDie: Well, using what it picks by default wouldn't be a bad place to start then, so just don't specify a template and see if you like the one it uses.
22:57:37 <tippenein> cocreature: Ultimately I want them in a list anyway. I was trying to be efficient about it. List is the ticket
22:58:23 <NeverDie> kadoban: Alright I plan on using the default settings.
23:02:45 <NeverDie> Is there a command to initialize the project or somethign?
23:02:48 <NeverDie> Something* 
23:03:41 <kadoban> NeverDie: An already existing cabal project? stack init is probably what you're looking for
23:04:01 <NeverDie> kadoban: All I did was stack new project-name
23:04:06 <NeverDie> So now I just do stack init within the directory?
23:04:33 <kadoban> NeverDie: It's not needed after stack new.
23:04:49 <NeverDie> kadoban: So then I just run the Main.hs file?
23:04:49 <kadoban> NeverDie: Perhaps you're looking for 'stack build' then? I'm not sure what you mean by initialize … you just start coding.
23:05:04 <NeverDie> Yeah I'm just trying to get a feel for how the whole process works.
23:06:34 <kadoban> NeverDie: For a new project, I 'stack new whatever', with my default template which I've messed with how I like. Then I open the .cabal file and the library and app and test .hs files, and then soon after I 'stack build' or whatever is appropriate. (usually 'stack test' is where I start actually, because I write tests really early, but it depends)
23:07:04 <NeverDie> kadoban: How do I include modules into the folder?
23:07:07 <NeverDie> Or packages w/e.
23:07:46 <kadoban> NeverDie: You put packages in the build-deps section of the .cabal file for the section that's going to use them (library or executable or test-suite), and then import them in the correct .hs file(s)
23:08:08 <NeverDie> kadoban: All I see is the stack.yaml file.
23:08:20 <NeverDie> Oh, and the project-name.cabal.
23:08:25 <kadoban> NeverDie: 'stack build' will then build them when it needs to. If it needs you to specify more about where to get the dependency, it'll let you know (doesn't come up much).
23:08:49 <kadoban> NeverDie: Yes, that'd be the one. In directories there should be .hs files, but you'll want to add your own as well eventually.
23:09:06 <NeverDie> kadoban: How would I install this one then? http://www.serpentine.com/wreq/
23:09:30 * hackagebot hylogen 0.1.0.5 - a tiny EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.5 (sleexyz)
23:09:35 <kadoban> NeverDie: You put packages in the build-deps section of the .cabal file for the section that's going to use them (library or executable or test-suite), and then import them in the correct .hs file(s). wreq is a package.
23:09:36 <cocreature> add wreq to the build-depends in your cabal file
23:12:01 <NeverDie> cocreature: Is there a way to auto install it?
23:12:21 <NeverDie> Like when you do pacman package or w/e.
23:12:38 <kadoban> NeverDie: You add one line to one file. That's not auto enough?
23:13:12 <orion> ski: I seem to be stuck: http://lpaste.net/7314825339450949632
23:13:24 <cocreature> you can do 'stack build wreq' which will install it but you still can’t use it in your project until you add it to the build-depends so that’s not that useful
23:13:49 <orion> ski: Oddly enough, the compiler only complains about Hash.
23:14:10 <cocreature> orion: add a type signature to hs
23:14:11 <NeverDie> cocreature: So there's nothing like npm install <module>?
23:14:18 <ski> possibly it finds them one at a time
23:14:26 <ski> anyway, the type signature is wrong (can't work)
23:14:35 <ski> should be either
23:15:06 <ski>   mkHandshake :: ServerOpts -> HandshakeType -> SomeCipherType -> SomeCurveType -> SomeHashType -> SomeHandshakeState
23:15:10 <ski> or (preferably)
23:15:49 <ski>   mkHandshake :: (Cipher c, Curve d, Hash h) => ServerOpts -> HandshakeType -> CipherType c -> CurveType d -> HashType h -> HandshakeState c d h
23:16:10 <ski> (i mentioned this issue above, i think)
23:17:08 <ski> no need to introduce `SomeXXX', unless needed
23:17:35 <ski> in this case, you could probably (looking at the definition) simplify it to
23:17:37 <cocreature> I usually only start using SomeXXX things when I need to put things in a monomorphic container such as Data.Map
23:17:49 <ski>   mkHandshake :: (Cipher c, Curve d, Hash h) => ServerOpts -> HandshakeType -> HandshakeState c d h
23:18:33 <ski> at the cost of (possibly) having to annotate a call of `mkHandshake' with appropriate type variable, ala `ScopedTypeVariables', as indicated a bit above
23:18:39 <cocreature> NeverDie: not that I know of
23:19:29 <kadoban> NeverDie: It wouldn't really make sense the way cabal-install and stack work, unless it just edited the file for you. Which would be somewhat nice, but not that different.
23:19:35 <ski> cocreature : in this case, it's to be able to say `curveTypeParser :: Parser (exists d. Curve d *> CurveType d)', where which curve `d' is used depends on what is parsed
23:19:55 <NeverDie> kadoban: I just did cabal install -j --disable-tests wreq
23:20:13 <cocreature> ski: what is *> in a type signature doing?
23:20:43 <ski> cocreature : `*>' is to `=>' what `exists' is to `forall', and what `(,)' is to `->'
23:20:48 <kadoban> NeverDie: Well, that's fine (maybe? I dunno cabal-install anymore) if you want to use cabal-install. It won't do anything for stack though.
23:21:17 <cocreature> ski: so it’s just some notation but not actually haskell?
23:21:22 <ski> cocreature : it expresses that the parser will return a value of type `CurveType d', for some type `d' which we know nothing about, *except* that we know also `Curve d'
23:21:27 <ski> cocreature : yes
23:21:33 <cocreature> k
23:21:57 <zipper> I WILL KILL YOU!!!!!!!
23:22:06 <cocreature> zipper: good morning
23:22:17 <NeverDie> kadoban: What do you do then?
23:22:47 <ski> cocreature : it's to be able to talk clearly about what type behaviour is desired, without having to beat around the bush by defining an "existential data type", and using that .. or alternatively using the other *encoding* of existentials
23:22:55 <kadoban> NeverDie: I mentioned above. You add it to the .cabal file in the build-depends section. That's it. Next time you build the package, it'll build the dependency if it needs to.
23:23:07 <cocreature> ski: fair enough
23:23:10 <NeverDie> Ohh. Interesting. 
23:23:22 <NeverDie> I thought I had to manually download it/install it/build it.
23:23:53 <kadoban> Naw, not at all. That's almost always all you have to do.
23:24:01 <NeverDie> kadoban: I see the stack.yaml file that has a packages section.
23:24:13 <NeverDie> I ignore that completely?
23:24:53 <kadoban> NeverDie: Yes, that's for more complicated setups. When you want to use a package that stack already knows all about (it's in hackage and the resolver), you don't need to mess with the stack.yaml file at all really.
23:25:22 <ski> orion : you may ask why i said "the type signature is wrong (can't work)" -- well, presumably the intention was that the `c',`d',`h' in the return type `HandshakeState c d h' should be the same as the `c',`d',`h' "hidden" inside the arguments of types `SomeCipherType',`SomeCurveType',`SomeHashType'
23:25:23 <mgsloan> Yeah, many projects can use a stack.yaml file that's just "resolver: lts-5.11" or something like that
23:26:30 <ski> orion : however, with the type signature in the paste, you're promising to return something of type `HandshakeState c d h', for whatever `c',`d',`h' (in the corresponding classes) the *caller* wants, regardless of whether that's the same as the corresponding hidden types in the arguments
23:27:33 <ski> orion : this doesn't work. it'd work if you replaced the `forall c d h.' by `exists c d h.', and the `=>' by `*>', and further moved those *after* the argument types (so that they can *depend* on the values of those argument types)
23:27:40 <ski> but
23:28:07 <ski>   mkHandshake :: ServerOpts -> HandshakeType -> SomeCipherType -> SomeCurveType -> SomeHashType -> exists c d h. (Cipher c,Curve d,Hash h) *> HandshakeState c d h
23:28:13 <ski> is the same thing as
23:28:18 <ski>   mkHandshake :: ServerOpts -> HandshakeType -> SomeCipherType -> SomeCurveType -> SomeHashType -> SomeHandshakeState
23:28:40 <ski> still, i suggest the other variant mentioned above
23:29:09 <zipper> mgsloan: Hey, how are you.
23:29:44 <lpaste> tippenein pasted “mapping over csv columns” at http://lpaste.net/158591
23:30:00 <mgsloan> zipper: I'm good, yourself?
23:30:26 <zipper> mgsloan: Hey, I want to work on https://github.com/fpco/ide-backend/issues/313 this weekend where would you say I should start? 
23:30:38 <zipper> mgsloan: Doing good, writing clojure for work.
23:30:52 <zipper> mgsloan: Can we go to #haskell-blah?
23:30:57 <mgsloan> sure
23:31:17 * zipper waits
23:31:22 <mgsloan> Why the heck does haskell-blah require ssl
23:31:39 * ski . o O ( #haskell-offtopic )
23:31:44 <mgsloan> The #nossl channel is full of haskell people, lol
23:31:55 <mgsloan> Err ##nosssl
23:32:21 <cocreature> mgsloan: we also have #haskell-offtopic specifically for people who don’t want ssl :P
23:32:50 <zipper> It require SSL?
23:33:01 <mgsloan> Yeah, ssl is a bit of a pain in irssi
23:33:12 <zipper> Okay uh mgsloan sorry, I use weechat.
23:33:12 <Axman6> really? works fine here
23:33:27 <zipper> Okay where can we talk then? PM?
23:34:24 <ski> mgsloan : ask Oejet
23:34:39 <ski> zipper : also, someone made #haskell-offtopic
23:34:56 <ski> (also #haskell-superfluous)
23:40:34 <mgsloan> Not really that big of a deal, I stopped paying attention to #haskell-blah as soon as I got real busy :-)
23:44:49 <thimoteus> #haskell-offtopic
23:44:55 <thimoteus> hmm
23:45:13 <ahihi> three different off-topic channels? lovely
23:47:32 <MathuSumMut> Hi
23:47:49 <runeks> Is there a simple way to create a new data type which is an existing data type with one of the fields set? Eg. I have this data type: "data PublicKey = PublicKey PubKeyAlgo B.ByteString" (PubKeyAlgo = RSA | EC | Schnorr). Then I would like to define a new type: "type RSAPublicKey = PublicKey RSA", which is basically PublicKey with RSA as the first argument.
23:47:49 <runeks> Is this possible, or something similar/better?
23:48:56 <ski> runeks : it would be possible to do something like that, with GADTs
23:49:10 <ski> runeks : .. however, it's not obvious that it's a gain to do so
23:50:31 <ski> orion : oh, i forgot to say before. at <https://github.com/centromere/cacophony> you have "Ensure that you provide the keys which are required by the handshake pattern you choose. For example, the Noise_IK pattern requires that the initiator provides a local static key and a remote static key." -- it might be possible to express such constraints statically, e.g. with GADTs
23:50:54 <ski> runeks : namely, you could say :
23:51:10 <ski>   data PubKeyAlgo pka
23:51:13 <ski>     where
23:51:25 <ski>     PKA_RSA :: PubKeyAlgo RSA
23:51:30 <ski>     PKA_EC :: PubKeyAlgo EC
23:51:41 <ski>     PKA_Schnorr :: PubKeyAlgo Schnorr
23:52:06 <ski>   data PublicKey pka = PublicKey (PubKeyAlgo pka) B.ByteString
23:52:24 <ski> runeks : then your `RSAPublicKey' is `PublicKey RSA'
23:52:48 <runeks> ski: Thanks! Reading up on GADTs now.
23:52:58 <ski> you still have to explicitly give the argument of type `PubKeyAlgo RSA' to the data constructor `PublicKey', but it can only be `PKA_RSA'
23:53:21 <ski> runeks : you'd also need to define types `RSA',`EC',`Schnorr', e.g. like
23:53:22 <Gurkenglas> mfukar, can you explain how "What numbers in [1..100] can be expressed in terms of 7, 13 and (+)?" can be expressed as a maxflow problem in a graph?
23:53:26 <ski>   data RSA
23:53:27 <ski>   data EC
23:53:30 <ski>   data Schnorr
23:53:47 <ski> runeks : alternatively, using `DataKinds', you can say
23:53:58 <ski>   data PKA = RSA | EC | Schnorr
23:54:17 <ski> runeks : and then instead of `data PubKeyAlgo pka' you can say `data PubKeyAlgo :: PKA -> *'
23:54:32 <ski> (using `KindSignatures'. this last part is optional)
23:56:40 <MathuSumMut> Quick question: Consider the application:
23:56:40 <MathuSumMut> main = do x <- [1,2,3]
23:56:40 <MathuSumMut>    y <- [1,2,3]
23:56:40 <MathuSumMut>    True <- return (x /= y)
23:56:40 <MathuSumMut>    return (x,y)
23:57:12 <runeks> ski: Do you mean "data PublicKey :: PKA -> *"? Else I don't understand...
23:57:18 <MathuSumMut> What does the line "True <- return (x /= y) do?
23:57:33 <MathuSumMut> *" do?
23:57:54 <Gurkenglas> mfukar, a better question would be how to express it as a closure problem in a graph, since I accept that those are reducible to maxflow, and you seemed to think calculating the closure of an operation and a set reducible to a closure problem on a graph
23:58:03 <ski> runeks : you could do that as well, but then i think you'd need to declare `PublicKey' with the GADT-style `data' type declaration as well
23:58:29 <zRecursive> > [(x,y)|x<-[1,2,3],y<-[1,2,3]]
23:58:31 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
23:58:50 <zRecursive> True <- return (x /= y) ?
23:59:00 <MathuSumMut> yeah
23:59:01 <kadoban> MathuSumMut: It calls 'fail' because of the incomplete pattern match if x == y, IIUC.
23:59:19 <liste> > fail :: []
23:59:20 <lambdabot>      Expecting one more argument to ‘[]’
23:59:21 <liste> > fail :: [a]
23:59:22 <lambdabot>      Expected a type, but ‘[]’ has kind ‘* -> *’
23:59:24 <lambdabot>      In an expression type signature: []
23:59:26 <lambdabot>      Couldn't match expected type ‘[a1]’
23:59:28 <lambdabot>                  with actual type ‘String -> m0 a0’
23:59:30 <lambdabot>      Probable cause: ‘fail’ is applied to too few arguments
23:59:31 <MathuSumMut> and does assigning to True mean something per se?
23:59:37 <ski> MathuSumMut : it could be written `True <- [x /= y]' as well
23:59:53 <zRecursive> > :t True
23:59:54 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:59:56 <Ferdirand> :t guard
23:59:57 <lambdabot> Alternative f => Bool -> f ()
