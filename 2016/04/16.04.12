00:14:53 <ertesx> sm, ryantrinkle: yes, i'm the author of netwire, and i'm still into (A?)FRP implementation‚Ä¶  however, i no longer recommend using netwire
00:15:27 <ertesx> for the specific application domain in which AFRP is currently the better choice (games/simulations) i currently recommend yampa
00:16:58 <ertesx> i'm playing with a new abstraction that has a very interesting language for events, and that will turn into a library at some point‚Ä¶  but i don't know when, and i'm not making any promises right now
00:17:23 <ertesx> i've been playing with reflex and having a very positive experience‚Ä¶  it has pretty much already replaced reactive-banana for me
00:20:05 * hackagebot binary-tagged 0.1.4.0 - Tagged binary serialisation.  https://hackage.haskell.org/package/binary-tagged-0.1.4.0 (phadej)
00:20:47 <ertesx> see you later =)
00:21:45 <kadoban> Okay, I know there must be a :: IO UTCTime somewhere, but I can't seem to find it and hoogle/hayoo are failing me. Someone help me out?
00:23:10 <Lokathor> uhm
00:23:11 <Lokathor> getCurrentTime
00:23:22 <Lokathor> Data.Time.Clock, i think
00:23:27 <kadoban> Thanks
00:23:39 <Lokathor> or Data.Time.LocalTime ?
00:23:41 <Lokathor> i dunno
00:24:04 <kadoban> .Clock apparently, was hiding at the end. Not sure why hoogle and hayoo couldn't find it for me, I even had the type exactly right ‚Ä¶
00:24:39 <Lokathor> have you checked out the ~latest~ in timekeeping modules? https://github.com/Lokathor/ireniko/blob/master/src/Data/Time/Discordian.hs :3
00:25:05 * hackagebot rebase 0.5.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.5.2 (NikitaVolkov)
00:25:09 <kadoban> hail eris?
00:25:14 <Lokathor> quite
00:25:21 <kadoban> Nice
00:39:19 <dysfun> i have some data stored in json of records ordered by one of the fields. I need to satisfy range queries quickly. I'm thinking binary search over vector or using a Map. Any ideas?
00:44:14 <kadoban> dysfun: Map should be the least effort way, I think it provides enough for you to do that.
00:44:46 <dysfun> yeah that's what i was thinking. i'm a bit mystified vector doesn't provide such a function
00:46:34 <kadoban> I would assume there's a binary search package out there somewhere, but I dunno.
00:49:26 <catsup> https://hackage.haskell.org/package/binary-search
00:53:34 <Guest71042> @type map
00:53:35 <lambdabot> (a -> b) -> [a] -> [b]
00:53:52 <Guest71042> @src map
00:53:52 <lambdabot> map _ []     = []
00:53:52 <lambdabot> map f (x:xs) = f x : map f xs
00:54:38 <Guest71042> @src quot
00:54:38 <lambdabot> Source not found. Abort, Retry, Panic?
00:55:00 <Guest71042> @src fmap
00:55:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:55:37 <catsup> wow lambdabot 
00:56:07 <catsup> you're a bit overconfident
00:56:22 <catsup> that last one was your limitation, not a typo
00:57:40 <haskell791> hi
00:57:54 <haskell791> how can you get a list up to an element?
00:58:10 <haskell791> [1,2,3,12,4,5] i want [1,2,3,12]
00:58:51 <Guest59435> take 4 list
00:58:56 <laz> takeWhile (/= 4)
00:59:40 <Guest59435> PS: the 4 in "take 4 list" is unrelated to the element 4
01:00:22 <haskell791> ok but if I have two conditions like I want to take when either 8 or 12 are encountered?
01:00:40 <haskell791> i tried takeWhile with || but it doesn't work
01:02:16 <jack_rabbit> Do you have code to show?
01:02:26 <cocreature> > takeWhile (\x -> (x/=8) || (x/=12)) [1,2,8,13]
01:02:28 <lambdabot>  [1,2,8,13]
01:02:39 <cocreature> > takeWhile (\x -> (x/=8) && (x/=12)) [1,2,8,13]
01:02:41 <lambdabot>  [1,2]
01:02:44 <Guest59435> cocreature: that predicate is always true
01:02:47 <cocreature> you need an &&
01:02:57 <Guest59435> every number x is always !=8 or !=12 !
01:03:05 <cocreature> Guest59435: yeah it‚Äôs too early :P
01:03:23 * Guest59435 offers some coffee
01:03:33 <haskell791> sounds great but I want the condition character(8 or 12) to be included also
01:03:57 <cocreature> Guest59435: thx :)
01:03:58 <jack_rabbit> maybe a reduce?
01:04:03 <jack_rabbit> haskell791^
01:04:08 <jack_rabbit> fold, rather.
01:04:13 <hjulle> Is there something like ByteString for (more or less) arbitrary types?
01:04:18 <haskell791> how could I have it so [1,2,8] be the result?
01:04:38 <lyxia> hjulle: what do you mean?
01:05:19 <haskell791> in cocreature's example [1,2,8,13] I want [1,2,8]
01:05:24 <haskell791> but the list can be longer
01:05:27 <haskell791> even infinite
01:06:46 <lyxia> > takeWhile (< 13) (1 : 2 : 8 : [13 ..])
01:06:47 <hjulle> lyxia: I mean a Lazy.ByteString, but containing other stuff than bytes. Something that handles data as a list of chunks.
01:06:48 <lambdabot>  [1,2,8]
01:07:13 <lyxia> hjulle: so... a list?
01:07:14 <rydgel> hjulle: Vector YourData?
01:07:33 <rydgel> ByteString is a Vector or Word8 or something similar
01:07:39 <rydgel> s/or/of*
01:07:53 <haskell791> yes I have an infinte list that I have created with iterate and when I want to take everything before the first 8 or 12
01:08:09 <haskell791> including the 8 or 12
01:08:20 <cocreature> haskell791: I don‚Äôt think there is a combinator for that (at least not in base) so you‚Äôll have to write it yourself
01:08:31 <hjulle> rydgel: Yes, but Lazy.ByteString is a list of Vectors (more or less).
01:09:03 <hjulle> *Data.ByteString.Lazy
01:09:42 <dmtd> hi everyone! In haskell, what is it called (and what is the significance) of a period? Especially like V.isLower, etc
01:10:28 <f-a> dmtd: in that case it is (basically) "let's use function isLower from module aliased V"
01:10:42 <f-a> where on the top of your file.hs you have something like
01:10:51 <f-a> import qualified Data.Char as V
01:11:11 <dmtd> ah yes! there is an import Data.Char at the top
01:11:11 <hjulle> Where the sub-vectors are automatically sized in (what the library author guesses is) an appropirate size for the cache.
01:11:25 <f-a> don't confuse that with function composition operator dmtd 
01:11:30 <f-a> they are two distinct things
01:11:50 <cocreature> haskell791: you can write it pretty easily using foldr
01:12:02 <rydgel> hjulle: hum. I don't know anything that does the same for arbitrary data type then..
01:12:25 <haskell791> how?
01:13:23 <dmtd> f-a: great thanks. So how does V get associated with Data.Char?
01:13:46 <hjulle> rydgel: Ok
01:14:23 <hjulle> thanks anyways
01:15:05 <f-a> dmtd: there should be a `import <something> as V` on the top of your .hs file. is there?
01:15:39 <f-a> if not, please paste the code somewhere
01:16:13 <dmtd> ah yes, import qualified Data.Char as V
01:16:34 <dmtd> ok that makes much more sense
01:16:45 <dmtd> thank you!
01:17:11 <f-a> dmtd: one last thing
01:17:19 <f-a> import qualified Data.Chas as V
01:17:39 <dmtd> also what does the "qualified" mean?
01:17:56 <f-a> it means if you want to use a function from Data.Char you *have* to prepend V.
01:18:27 <f-a> if you don't use qualified, you can use it as you prefer and place the V. only when there is ambiguity
01:18:29 <dmtd> so if I don't include qualified, and I don't say "as V" at the end, I can just call those library functions anywhere?
01:18:54 <dmtd> without the V?
01:18:57 <f-a> import Data.Char <-- call them anywhere
01:19:04 <dmtd> awesome
01:19:06 <dmtd> thank you!!
01:19:09 <dmtd> this is so cool
01:19:12 <f-a> import Data.Char as V <-- call them anywhere, V. can be used to resolve ambiguities
01:19:18 <dmtd> got it
01:19:24 <dmtd> and with qualified means V must be used
01:19:28 <f-a> yyyyyyyyyyyep
01:19:37 <dmtd> sweet! thanks a million!
01:20:02 <f-a> yw \o/
01:24:22 <jophish> DanC: still here?
01:31:04 <lpaste> jack_rabbit pasted ‚Äúbad,bad,bad‚Äù at http://lpaste.net/159650
01:31:15 <jack_rabbit> haskell791^
01:31:24 <jack_rabbit> Anyone want to improve on that quick hack?
01:31:24 <jophish> EvanR: thanks for plugging exact-real :)
01:32:12 <jophish> DanC: for (d-1)/d use something like `let d' = fromInteger d in (d' - 1) / d'`
01:32:13 <cocreature> jack_rabbit: http://lpaste.net/159651
01:32:14 <W4RH4WK> hey, is there a way to compile a shared library via stack (or cabal) without a package key in its name. Or can get the resulting package key before compilation somehow. (Need this for cmake integration)
01:33:59 <jophish> If you're going to be doing a lot of further processing of that number (it will be at the bottom of a big expression tree) then use: let d' = fromInteger d in (d' - 1) *. recipBounded d'
01:34:58 <jophish> (*.) requires the argument on the right to be in [-1..1] and recipBounded required its argument to not be in (-1..1)
01:35:54 <jophish> Please let me know if there's anything else I can help you with in using exact-real
01:36:37 <jack_rabbit> cocreature, Couldn't match expected type ‚Äòa -> Bool‚Äô with actual type ‚Äò[Integer]‚Äô
01:36:45 <jack_rabbit> cocreature, but I get what you were going for. Much better.
01:36:55 <cocreature> jack_rabbit: works for me?
01:37:15 <jack_rabbit> I think it's in the not $ p x
01:37:16 <cocreature> jack_rabbit: you still need to pass a predicate
01:37:27 <cocreature> takeWhile' (\x -> x /= 8 && x /= 12) $ [1,2,12,13]
01:37:28 <jack_rabbit> ohhhh, I see.
01:37:36 <jack_rabbit> Right, that makes much more sense.
01:37:41 <cocreature> hardcoding the predicate doesn‚Äôt make sense
01:38:02 <jack_rabbit> cocreature, right. I should've just looked at the predicate.
01:38:09 <jack_rabbit> s/predicate/type signature/
01:38:26 <jack_rabbit> It's been a while since I touched haskell.
01:39:57 <cocreature> time to change that :)
01:45:19 <jack_rabbit> :)
02:12:38 <dmtd> Hi all, I keep getting ""*** Exception: Prelude.head: empty list" But I'm not taking a head off anywhere. What would cause this?
02:13:13 <Gurkenglas> dmtd, saved your code? Ctrl-F "head"? Are you using something that uses head? Paste code on lpaste.net
02:23:01 <dmtd> found the head but I'm really not sure why it would be empty
02:23:02 <dmtd> http://pastebin.com/RGc0fKVM
02:23:39 <dmtd> Gurkenglas: here is the pastebin
02:23:49 <Gurkenglas> thats not lpaste.net but ok
02:24:27 <dmtd> ah sorry I'll use lpaste next time, force of habit
02:24:48 <Gurkenglas> btw in positions you can just do zip xs [0..], zip truncates at the shorter list
02:25:06 <dmtd> oh ok
02:26:40 <lyxia> pastebin's Haskell highlighting is so bad
02:26:45 <Gurkenglas> Also I would use _ there instead of x' because you don't use it
02:26:47 <Gurkenglas> :t elemIndices -- Also Data.List already provides this
02:26:48 <lambdabot> Eq a => a -> [a] -> [Int]
02:27:48 <dmtd> lyxia: looking at it now I agree
02:27:55 <aarvar> dmtd: the existence of head is a bug
02:28:33 <Gurkenglas> oh wait you do use x' ._.
02:28:51 <aarvar> if you know the list isn't empty then that should be encoded in the type system
02:28:58 <Gurkenglas> Although I think you could write [i | (i, x) <- zip [0..] xs] there
02:29:19 <lyxia> I don't see how this head could fail either
02:29:52 <Gurkenglas> Is this everything of your code?
02:30:09 <dmtd> gurkenglas: yes, minus the import Data.Char at the very top
02:30:15 <apsod> dmtd: When does it fail?
02:30:18 <verement> dmtd: the use of (==) with floating point numbers is a bad idea, and possibly the source of your problem
02:30:23 <dmtd> when you call crack
02:30:38 <apsod> on what?
02:30:44 <Gurkenglas> Try "snd $ minimumOn fst $ zip [0..] chitab"
02:31:08 <Gurkenglas> verement, (==) isn't reflexive on Float!?
02:31:19 <dmtd> apsod: if I say crack "MJQQT" I should get HELLO
02:31:36 <dmtd> apsod: instead I get "*** Exception: Prelude.head: empty list
02:31:41 <apsod> Ah, isn't that because you only treat lowercase characters?
02:31:44 <dmtd> encode works just fine though
02:31:51 <dmtd> I want to treat uppercase though
02:31:55 <Gurkenglas> Umm of course I mean "fst $ minimumOn snd $ zip [0..] chitab" :D
02:32:00 <dmtd> I'm modifying this to support upper case
02:32:08 <liste> > (1/1e400) == (2/1e400)
02:32:09 <dmtd> I thought I had fixed everything
02:32:09 <lambdabot>  True
02:32:56 <apsod> your freqs is wrong
02:33:05 <lyxia> oh yeah looks like you have a NaN
02:33:06 <Gurkenglas> Also wait, minimumOn doesn't exist?
02:34:41 <Gurkenglas> "factor = fst $ minimumBy (comparing snd) $ zip [0..] chitab" then, I guess
02:34:42 <dmtd> apsod: should I put guards in on freqs to account for upper case then?
02:35:03 <Gurkenglas> dmtd, try this?
02:35:50 <dmtd> Gurkenglas:     Not in scope: ‚ÄòminimumBy‚Äô
02:35:50 <dmtd>     Perhaps you meant ‚Äòminimum‚Äô (imported from Prelude)
02:36:05 <dmtd> that's what happens when I try to load
02:36:07 <Gurkenglas> Import it from Data.List or Data.Foldable <.<
02:36:56 <ntnt> how close is 8.0 to being usable? I want all the strictness awesomeness
02:37:04 <ntnt> if I'm using stack/cabal, is there a quick/safe way to try out 8.0 ?
02:38:18 <dmtd> gurkenglas: imported those but still getting Not in scope: ‚Äòcomparing‚Äô
02:38:52 <Gurkenglas> That, you can import from Data.Ord. (my fault for not adding that to the last remark)
02:39:39 <dmtd> it no longer fails
02:39:59 <dmtd> but now it doesn't crack properly. MJQQT should be hello, but now it is OLSSV
02:42:57 <dmtd> gurkenglas: could it be the freqs like apsod said?
02:43:38 <Gurkenglas> Could be it, haven't looked there, was trying to help from the other end :D
02:44:22 <ntnt> is there a way to tell stcak
02:44:25 <ntnt> to install 8.0 
02:44:30 <ntnt> I want to try 8.90
02:44:37 <verement> > 0.3 - 0.1 == 0.2  -- Gurkenglas
02:44:39 <lambdabot>  False
02:44:46 <ggVGc> could someone help me finish this Traversal' ? https://gist.github.com/238625bc95dd069a4e294e70ebd78dba
02:45:11 <ggVGc> I'm not sure how to do the last part since the index could be valid or not
02:45:16 <Gurkenglas> Try importing Debug.Trace and replacing "chitab =" with "chitab = trace"
02:45:16 <ggVGc> how do I indicate that the traversal missed?
02:45:27 <verement> > let x = 0.0 / 0.0 :: Float in x == x  -- Gurkenglas
02:45:29 <lambdabot>  False
02:48:32 <Gurkenglas> You can refactor the definitions of factor and chitab into "factor = minimumBy (comparing $ \n -> chisqr (rotate n table) table) [1..25], by the way - except that this preserves the actual number from [1..25], instead of the indices starting at 0
02:48:57 <Gurkenglas> (Umm, with the first table replaced by table')
02:50:10 * hackagebot hylogen 0.1.0.6 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.6 (sleexyz)
02:52:48 <Gurkenglas> (The general lesson being, the shorter you make your code by using library function, the less places there are for you to introduce mistakes :D)
02:52:56 <Gurkenglas> *functions
02:53:30 <dmtd> gurkenglas: fair point. Ok, again still working but wrong output
02:53:33 <dmtd> crack "MJQQT YMJWJ"
02:53:34 <dmtd> "GDKKN SGDQD"
02:56:36 <Gurkenglas> Try "factor = minimumBy (comparing $ \n -> let r = chisqr (rotate n table') table in trace (n, r) r) [1..25]" and importing Debug.Trace - this won't change the computation, but will unsafely output some info to the console that we might use for debugging
02:57:35 <Gurkenglas> (Namely the pairs of how far we shift and how well that shift scores)
02:58:49 <dmtd> gurkenglas: it's complaining about a lot of type errors, mainly couldn't match int, float with [char]
03:01:05 <Athas> Man, the trickiest part of migrating to Stack is ditching the libraries that are not there...
03:02:06 <liste> Athas: you don't need to ditch them
03:02:19 <liste> Athas: just do stack solver
03:03:11 <liste> it'll add the non-stackage/lts dependencies (on Hackage) into extra-deps and determine the correct versions for them
03:04:05 <Athas> liste: I've tried that, but it seems that it just stuffs every single dependency into extra-deps.
03:04:31 <dmtd> gurkenglas: maybe just convert all letters to lower case and then back to upper case?
03:05:08 <Athas> liste: oh, wait, something else seems to be happening now.
03:05:11 * hackagebot werewolf 0.5.4.0 - A game engine for playing werewolf within a chat client  https://hackage.haskell.org/package/werewolf-0.5.4.0 (hjwylde)
03:07:16 <Gurkenglas> dmtd, that level of reasoning is on your end :P. "factor = minimumBy (comparing $ \n -> let r = chisqr (rotate n table') table in trace (n, r) r) [1..25]" really throws type errors where "factor = minimumBy (comparing $ \n -> chisqr (rotate n table') table) [1..25]" doesn't?
03:08:28 <Gurkenglas> Ah, of course, put traceShow there instead of trace ._.
03:08:59 <ggVGc> how do I rewrite this nicer using Applicative? https://gist.github.com/992a6f77a64b20b2e7bdd443421722b4
03:09:04 <liste> Athas: do you have versions specified in your .cabal file?
03:09:13 <Athas> liste: lower bounds, yes.
03:09:42 <Athas> But I have a problem where 'stack solver' fails.  Maybe I should select another snapshot...
03:11:28 <Gurkenglas> ggVGc, first off you can factor out the model: maybeInd & maybe pure (\ind -> triggerSeqs $ ix (ind^._1) f) $ model
03:13:36 <liste> Athas: what snapshot are you using?
03:14:13 <ggVGc> Gurkenglas: yeah, but I'm trying to figure out how to use applicative to avoid the explicit `pure`
03:14:20 <ggVGc> I need to get into using applicative more
03:14:37 <Gurkenglas> Yea I'm looking at that, hmm
03:15:26 <ntnt> https://hackage.haskell.org/package/dlist-0.7.1.2/docs/src/Data-DList.html#DList <-- why is haskell impl's of DList just [a] -> [a] ... instead of storing everything in a tree ?
03:15:55 <ggVGc> Gurkenglas: this is the whole thing, https://gist.github.com/3bdc2d1d67b71ef938fae1fb2a27655d
03:16:58 <Gurkenglas> How about "foldrM (\ind -> triggerSeqs $ ix (ind^._1) f) model maybeInd"
03:17:13 <Gurkenglas> That's using monads, not applicatives, but maybe that's the thing to use here
03:17:24 <ggVGc> mkay, thanks
03:17:41 <ggVGc> when do I use applicative? I hear/see a lot of people saying we mostly shouldn't use monads but rather applicative
03:17:51 <ggVGc> but I can never seem to identify when I can use applicative
03:17:56 <Gurkenglas> You want to do either 0 or 1 monadic computations, and variable numbers of monadic computations, depending on input data, sound like monad rather than applicative
03:18:15 <Gurkenglas> applicative happens to be able to do 0 in addition to 1, but it can't do 2
03:18:16 <ggVGc> a lot of my code where I use monads is where I depend on the result of previous value, almost always it's dealing with Maybe
03:18:22 <ggVGc> so applicative never works out there
03:18:27 <ggVGc> maybe when I'm working with lists?
03:18:35 <Gurkenglas> And Maybe just happens to be a Foldable that can't have 2, but you shouldn't rely on that
03:19:08 <ggVGc> dunno if that foldrM is clearer than what I've got
03:20:08 <Gurkenglas> In terms of token count you won't get better than it I think :P
03:20:25 <ggVGc> yeah, but I am chasing logical clarity rather than text count
03:20:31 <ggVGc> I thought I was supposed to use applicative here
03:20:36 <ggVGc> but this is all I could come up with
03:20:41 <ggVGc> maybe the explicit pure is reasonable
03:21:19 <ggVGc> implementing Traversal's for use with Lens has kicked my haskell knowledge in the butt
03:21:34 <ggVGc> but it's pretty convenient writing a setter and a getter in one
03:21:42 <ggVGc> at least when it's done..
03:21:48 <ggVGc> but I'm still struggling almost every time
03:21:59 <Athas> liste: lts-5.12.
03:23:09 <Athas> When I do 'stack solve', I get an error about not being able to find a version for the constraints library, apparently because there is a global constraint that requires version 0.8, but one of my dependencies wants exactly 0.4.
03:23:22 <Athas> Oh, constraints-0.8 is from lts-5.12.  Hm.
03:23:53 <Gurkenglas> ggVGc, imagine having a list of two entries instead of a Maybe with one entry, and now you have to process both
03:24:29 <Gurkenglas> The result of the first would be the argument of the second, and that's clearly monadic
03:24:41 <ggVGc> yep fair
03:24:50 <ggVGc> thanks
03:25:31 <ggVGc> god, reading Lens docs is just frustrating
03:25:44 <ggVGc> it requires knowing pretty much all of haskells type system it seems
03:25:48 <ggVGc> which I don't...
03:26:04 <ggVGc> tried understanding the type of `ix`. Apparently I now need to know type families
03:30:22 <quicksilver> what is there to know about type families?
03:30:38 <quicksilver> if you understand typeclasses you understand associated types
03:31:35 <ggVGc> I've only actively been writing haskell for a few months really
03:31:38 <quicksilver> a plain typeclass says 'for each instance you need to define these functions'
03:31:48 <quicksilver> one with an associated type says 'and you also need to define these types'
03:31:51 <ggVGc> I'm sure type families are not that complicated. I just haven't read any about it
03:31:57 <quicksilver> "supply" is probably a better word than "define"
03:32:13 <quicksilver> and typeclass methods need not actually be functons but that is the familiar word.
03:33:58 <quicksilver> anyhow, the type families "Index" and "IxValue" let you generalise indexing to types which are not standard parametric containers.
03:35:09 <ggVGc> quicksilver: my issue is that I just wrote this second function `curTriggerSeq`, and struggled a bit because I'd never written a Traversal' not using `ix` in the way I did above, https://gist.github.com/6394af6d1aabcb892c4b73325d1a7d8e
03:35:29 <ggVGc> but now I'm not completely sure how the `  in track&trackEntries (ix ind f )
03:35:33 <ggVGc> line works
03:35:47 <ggVGc> sicne I don't completely understand how `ix` works
03:35:55 <ggVGc> glguy in here just told me that's how I'd write it, and it worked
03:35:58 <ggVGc> but now I want to grok it
03:36:37 <quicksilver> it's not a very familiar operation to write traversals out longhand
03:36:43 <quicksilver> normally we build them out of other traversals
03:36:51 <ggVGc> how would I do that in this case?
03:38:24 <quicksilver> glguy told you to write it that way? normally he hates &
03:38:30 <ggVGc> oh, I did that
03:38:42 <ggVGc> I was referring to the custom Traversal, calling `ix` like that
03:38:47 <quicksilver> I'm very surprised he didn't tell you do write `trackEntries (ix ind f) track`
03:38:51 <ggVGc> which I would never have figured out myself
03:38:57 <ggVGc> so I'm trying to understand how I would have known
03:39:27 <ggVGc> because I've been using foo^?ix(...) but I don't completely understand it fully
03:39:28 <quicksilver> well I'm lacking lots of background as to your types
03:39:44 <quicksilver> but ix is simple enough:
03:40:02 <quicksilver> > ['a','b','c'] ^? ix 1
03:40:04 <lambdabot>  Just 'b'
03:40:06 <quicksilver> > ['a','b','c'] ^? ix 5
03:40:08 <lambdabot>  Nothing
03:40:12 <ggVGc> quicksilver: the issue for me when I wanted to write `curTrackEntry` is that it first needs to get the index from the track, and then go into a list using that index
03:40:18 <ggVGc> I couldn't figure out how to do that
03:40:39 <quicksilver> yep
03:40:51 <quicksilver> and that's why it makes sense to write it longhand this time
03:41:04 <ggVGc> I know how to use ^?ix, but I don't grasp it in the context of ((ix ind f) lens) foo
03:41:05 <quicksilver> but that's a conceptual leap if you've previous always built traversals by composition
03:41:13 <ggVGc> right
03:41:22 <ggVGc> which is what I'm trying to grasp now, because I find it incredibly useful
03:41:39 <ggVGc> IO also think I might be writing very bad haskell since I feel the need to define these complex traversals
03:41:49 <ggVGc> but not sure how to do it differently
03:42:03 <ggVGc> I've said before, but I'm really hung up on using nested records to represent my program state
03:42:12 <ggVGc> which I guess isn't very idiomatic in haskell[5~
03:42:45 <quicksilver> I think nested records are pertty natural, and the fact they're painflu to use is why we people wrote lens.
03:42:46 <ggVGc> And lens solves a lot for me, but it seems wrong I'd need an advanced tool like Lens and custom Traversals to make my code bearable
03:43:01 <quicksilver> it's not really an advanced tool
03:43:08 <quicksilver> it's just understand how traversals really work :)
03:43:11 <ggVGc> it's pretty difficult to get into, imo
03:43:16 <quicksilver> it is that
03:43:35 <ggVGc> using the predefined combinators is fairly easy, but now that I'm trying to extend thigns and tweak it to my data model, it's becoming very theory heavy
03:43:51 <ggVGc> and, well, as many other have said, the types don't make much sense
03:44:27 <ggVGc> but I'm glad I kind of understand how to make my own traverals now, and that their type signatures are actually easy
03:44:44 <ggVGc> I had so many manual getters and setters before
03:45:12 * hackagebot bytestring-tree-builder 0.2.6 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.6 (NikitaVolkov)
03:45:13 <ggVGc> hundreds of lines of essentially duplicated code with slight differences to reach into and modify my records
03:45:23 <quicksilver> the 'trick' about traversals and lens is the way they are type-class polymorphic
03:45:37 <quicksilver> so the caller gets to choose the type of the Functor 
03:45:44 <quicksilver> if you run them with a couple of example functors
03:45:45 <ggVGc> yeah, that's real nice
03:45:54 <quicksilver> you see how some Functors 'exhibit' the getter-type behaviour
03:46:00 <quicksilver> and other Functors 'exhibit' the setter-type
03:46:19 <ggVGc> I'm fairly impressed by the implementation of Lens
03:46:26 <quicksilver> it is a surprising thiing. Or it surprised me. But the edges join up into a surprisingly neat thing.
03:46:50 <quicksilver> did you ever write a Traversable instance?
03:46:54 <ggVGc> half the time I write lens expressions it essentially feels liek magic to me
03:46:56 <quicksilver> by providing the 'traverse' function?
03:46:58 <ggVGc> but then I think about it and it makes sense
03:47:13 <quicksilver> writing a Traversal longhand is exactly like writing 'traverse'.
03:47:19 <ggVGc> no, I haven't really dealt with Traversable or traverse, so that's also why this is hard for me :)
03:47:28 <quicksilver> ok so you skipped a step
03:47:29 <quicksilver> :)
03:48:14 <ggVGc> I feel I've skipped many steps in haskell, but I'll get to pick them up whenever they show up
03:48:21 <ggVGc> at least I'm able to write actual useful software now
03:49:09 <ggVGc> I've also now realised how crap LYAH is for actually understanding how to use haskell
03:49:21 <ggVGc> it feels more relevant to read now that I kind of understand most of the basics
03:49:28 <ggVGc> from usage
03:50:33 <ggVGc> quicksilver: why is it not so common to write custom traversals longhand? It feels like something you'd stumble upon very quickly when using lens
03:50:38 <ggVGc> took me a few days of usage before I had to do it
03:50:43 <ggVGc> but maybe it's because of my data model
04:11:13 <FUZxxl> Gurkenglas: http://crypto.stanford.edu/~blynn/haskell/jfh.html
04:11:21 <FUZxxl> ^ interesting read
04:18:52 <quicksilver> ggVGc: I have no profound answer to taht
04:19:03 <quicksilver> the compositional style is cute and lots of examples are written that way?
04:19:11 <quicksilver> I mean, composable things are good. We like composing.
04:20:08 <ggVGc> quicksilver: I just meant that for my use case there isn't a way to do it without writing a custom Traversal' as far as I understand? And it seems like a scenario that would come up fairly often
04:27:33 <ntnt> are tuples strict or lazy by default?
04:29:01 <quicksilver> for sure if you were writing a good textbook style manual for lens, ggVGc 
04:29:12 <quicksilver> then you'd carefully cover the xplicit as well as compositional style
04:29:18 <quicksilver> but no such thing exists :)
04:29:27 <quicksilver> we learn lens from fragmentary tutorials and IRC examples
04:29:29 <quicksilver> ntnt: lazy
04:29:40 <ggVGc> this experience has kind of made me want to write a blog post about this thing
04:29:47 <ggVGc> writint custom Traversal√§s
04:29:54 <ntnt> quicksilver: there's really no way to chagne this is there, since tuples is a ghc base builtin
04:29:59 <ggVGc> because it's really useful but I could never have figured it out..
04:30:05 <quicksilver> correct ntnt
04:30:36 <srhb> ntnt: You can always make your own tuples.
04:32:05 <haskell977> Hi how can you get a list up to a certain element and get that element also eg: [1,2,4,12,5,6,3] I want to get [1,2,4,12]. The list is random so I don't know what is after the element where I want to stop
04:32:30 <MasseR> haskell977: dropWhile?
04:32:49 <MasseR> > dropWhile (/= 2) [1,1,1,2,3,4]
04:32:51 <lambdabot>  [2,3,4]
04:34:06 <xenon-> @hoogle takeUntil
04:34:07 <lambdabot> No results found
04:34:18 <haskell977> but dropwhile gives me the list after the condition element I want the list before it with it in
04:34:35 <MasseR> haskell977: sorry, misunderstood
04:34:53 <MasseR> > takeWhile (/= 2) [1,1,1,2,3,4]
04:34:55 <lambdabot>  [1,1,1]
04:34:58 <hjulle> someFunction 12 [1,2,4,12,5,6,3] ==  [1,2,4,12]
04:35:05 <MasseR> but that drops the 2 as well
04:35:08 <xenon-> this function is usually named takeUntil, but I forgot where it is located. takeWhile is similar but it won't give you the element that failed on the predicate
04:35:39 <MasseR> Not that it would be difficult to implement that yourself
04:35:48 <MasseR> @src takeWhile
04:35:48 <lambdabot> takeWhile _ []                 = []
04:35:48 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
04:35:48 <lambdabot>                    | otherwise = []
04:36:19 <MasseR> Just replace the last clause
04:36:59 <haskell977> I know its not hard to implement but I spent hours on it and can't figure it
04:37:24 <pavonia> haskell977: Show us what you have so far
04:37:42 <haskell977> terminatePath :: Path -> Path terminatePath p = takeWhile (\x -> x /= 8 && x /= 12) p
04:38:05 <haskell977> but this doesn't give me the 8 or 12 which I need at the end of the list
04:38:19 <MasseR> haskell977: check the takeWhile implementation above
04:38:31 <MasseR> Do you notice how you could the last clause to that it would also return the last value?
04:38:57 <haskell977> change the otherwise to [x]?
04:39:02 <MasseR> Ding :)
04:39:03 <xenon-> yes!
04:39:18 <ntnt> srhb: yeah, but definign my own tuples loses GHC syntax
04:39:29 <ntnt> unless () / , become programmable parts of syntax
04:40:00 <ggVGc> ntnt: I'd define a `StrictTuple` for my needs, and supply toTuple and fromTuple
04:40:04 <ggVGc> to interface with the rest of haskell
04:40:29 <ggVGc> but yaeh, that's not useful
04:40:31 <ggVGc> since you want the syntax
04:40:43 <ggVGc> ntnt: templater haskell then I guess!
04:40:47 <ggVGc> template*
04:40:57 <ntnt> no
04:40:59 <ntnt> no templat ehaskell
04:41:05 <srhb> I think it would be rather confusing to suddenly use the same name for the data constructor of a strict tuple type anyway.
04:41:13 <srhb> StrictTuple is much nicer
04:41:53 <haskell977> @src takeWhile
04:41:53 <lambdabot> takeWhile _ []                 = []
04:41:53 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
04:41:53 <lambdabot>                    | otherwise = []
04:41:54 <ggVGc> ntnt: you did ask about programmable ()/ syntax, and it is programmable.. with TH
04:42:25 <ntnt> ggVGc: were you a lawyer pre haskell ?
04:42:37 <ggVGc> no, I am fairly uneducated :(
04:42:43 <ggVGc> but people have said I should be a politician
04:42:54 <ggVGc> which I think is probably not a good idea
04:43:11 <hackrilege> Cale: I found this in my bag off old references so I must have been trying to do it like this before (the stencil stuff it's right at the bottom) https://www.cl.cam.ac.uk/~dao29/ixmonad/ixmonad-fita14.pdf
04:45:59 <hackrilege> Also this https://github.com/dorchard/stencil-specs?files=1
04:47:20 <haskell977> it worked thanks
04:50:37 <hackrilege> Looks like I need to understand Reader better...
04:51:19 <hackrilege> Stencils in Haskell are non trivial!
05:08:17 <ggVGc> quicksilver: sorry to bother you, but do you know how I would do this? I'd like to give out the found index too, since I want to write another Treverasl' in terms of this one, that needs to refer to the second value of the tuple `SeqIndex`, https://gist.github.com/55ca4f8ba9adfb21a5dcee1a7edb810f
05:08:25 <ggVGc> but I'm again not sure how to work with `ix`
05:08:50 <ggVGc> that code obviously doesn't type check
05:20:49 <Athas> hackrilege: array programming in general is nontrivial in Haskell.
05:30:22 <riaqn> data Mytype a =
05:30:22 <riaqn> Mycons1 Int |
05:30:23 <riaqn> Mycons2 ((Mytype b) ->(Mytype b))
05:30:24 <riaqn>  
05:30:34 <riaqn> How I say that Mycons2 accept a polymorphic type?
05:39:00 <Athas> What makes a package disappear from a Stackage LTS snapshot?
05:39:07 <pamu> resources to learn yesod ?
05:39:17 <Athas> For example, I see that language-c-quote is in lts-3.22, but it is gone in 4.1.
05:40:02 <pamu> Do any one think that there is a lack of documentation for yesod ?
05:40:20 <riaqn> There is a lack of doc for all haskell packages.
05:42:24 <Lisa1157> hi i am trying to write a quick check property that checks for removal of an element from a binaryTree. as quickCheck test for an empty list, I am try to escape that case with a && clause. But it still keeps coming up.. https://dpaste.de/Ssd9 
05:43:20 <Lisa1157> sorry correct link is: https://dpaste.de/VQD7
05:54:38 <ClaudiusMaximus> Lisa1157: what does deleteFunction do?  maybe "deleteFunction (Branch 1 Leaf Leaf) 0" doesn't delete anything because 0 /= 1 ?  "escaping" cases in quickcheck is better done with ==> afaik
05:55:15 <hackrilege> pamu, yes, the documentation is horrible
05:55:52 <hackrilege> I prefer to use the things it's built on or other things built on those
05:56:19 <ClaudiusMaximus> Lisa1157: oops, looked at the wrong link - you should use  ==>  like   length (...) > 0 ==> ... == ...
05:56:24 <hackrilege> Check out http-simple and conduit
05:56:54 <Lisa1157> ClaudiusMaximus: I am to assume that deleteFunctionBehaves as required for this exersize. Okay, thanks ill try what you suggested with ==>
06:00:17 * hackagebot protocol-buffers 2.3.1 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.3.1 (k_bx)
06:00:19 * hackagebot protocol-buffers-descriptor 2.3.1 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.3.1 (k_bx)
06:00:21 * hackagebot hprotoc 2.3.1 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.3.1 (k_bx)
06:08:58 <Lisa1157> ClaudiusMaximus: thx for the help, am now getting this error: https://dpaste.de/JK1f
06:15:27 * hackagebot authenticate 1.3.3.1 - Authentication methods for Haskell web applications.  https://hackage.haskell.org/package/authenticate-1.3.3.1 (MichaelSnoyman)
06:33:19 <squall> anyone got a good reference for deriving zippers by differentiation?
06:34:51 <aweinstock> squall: https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types/
06:35:24 <squall> pdf?
06:35:28 <squall> thanks though
06:36:01 <squall> i thought maybe there were some cornerstone journal publications
06:43:25 <dinnu93> I installed Haskell through Stack 
06:44:15 <dinnu93> I'm trying to run a program which has "import Control.Monad.State" line inside it 
06:44:52 <dinnu93> and when I'm trying to load the file in ghci I'm getting a Module not found error for Control.Monad.State
06:45:05 <dinnu93> I did "stack install mtl" also 
06:45:32 <rydgel> dinnu93: did you add the "mtl" package to your .cabal file?
06:45:37 <dinnu93> but the problem is that the module is not visible even after being installed
06:46:02 <geekosaur> dinnu93, use "stack ghci" instead of plain ghci
06:46:14 <dinnu93> geekosaur: I did
06:47:04 <{AS}> I am trying to understand coarbitrary
06:47:10 <{AS}> How does it generate meaningful functions?
06:47:33 <dinnu93> rydgel: Where should I put my .cabal file
06:47:34 <dinnu93> ?
06:48:24 <dinnu93> rydgel: I'm new to Haskell and I'm currently doingh CIS194 lectures and exercises writing toy programs
06:49:06 <rydgel> dinnu93: you should make a CIS194 stack project, that way you won't install global package and pollute everything
06:49:44 <rydgel> dinnu93: you can do `stack new CIS194` and it will create a cabal and a stack file and some files for a starting point
06:49:50 <dinnu93> rydgel: What stack-template should I use
06:49:56 <rydgel> rydgel: then you can open the cabal file and add the dependencies you want
06:50:05 <rydgel> dinnu93: none, default one
06:50:37 <dinnu93> rydgel: Thanks I'll try that
06:51:13 <rydgel> dinnu93: and you can `stack build` your project and all dependencies will be automatically installed and your project will get build
06:51:36 <dinnu93> rydgel: ok
06:51:41 <rydgel> dinnu93: then `stack exec yourproject" to run it 
06:53:38 <dinnu93> rydgel: ok
06:59:48 <ntnt> M36 looks like it's going to be the next greatest project
07:10:29 * hackagebot ginger 0.2.2.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.2.2.0 (TobiasDammers)
07:11:29 <jophish> @tell merijn is transformers-supply usable?
07:11:29 <lambdabot> Consider it noted.
07:13:01 <Profpatsch> Is there a generalized version of take?
07:13:14 <Profpatsch> I‚Äôd guess it would be in Foldable or Traversable.
07:13:19 <{AS}> Profpatsch: you mean that works on any foldable?
07:13:50 <Profpatsch> If that is possible
07:13:51 <{AS}> you could use  \n x -> take n (toList x) I would guess
07:14:15 <{AS}> > :t \n x -> take n (toList x)
07:14:16 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
07:14:17 <Profpatsch> take probably doesn‚Äôt appear that often in practice.
07:14:21 <{AS}> :t \n x -> take n (toList x)
07:14:22 <lambdabot>     Ambiguous occurrence ‚ÄòtoList‚Äô
07:14:22 <lambdabot>     It could refer to either ‚ÄòData.Foldable.toList‚Äô,
07:14:22 <lambdabot>                              imported from ‚ÄòData.Foldable‚Äô at /home/lambda/.lambdabot/State/L.hs:86:1-20
07:14:35 <{AS}> :t \n x -> take n (Data.Foldable.toList x)
07:14:36 <lambdabot> Foldable t => Int -> t a -> [a]
07:14:57 <{AS}> Profpatsch: or do you want the result to be a Foldable as well?
07:15:05 <{AS}> That might be a bit harder :)
07:16:06 <{AS}> :t \n x -> fromList $ take n (Data.Foldable.toList x)
07:16:07 <lambdabot> (IsList l, Foldable t) => Int -> t (Item l) -> l
07:16:28 <{AS}> The problem is that this might not be structure preserving
07:18:52 <Peaker> I run my criterion benches with "| git notes add -f -F -" (after committing) -- so much nicer to have a record of the perf. of each commit right there in "git log"
07:19:03 <Profpatsch> {AS}: Probably not, yes.
07:19:26 <Profpatsch> It can probably be done with lenses
07:19:51 <Profpatsch> if you have a hammer ‚Ä¶
07:21:33 <Peaker> @type taking
07:21:35 <lambdabot> (Applicative f, Conjoined p) => Int -> Traversing p f s t a a -> Over p f s t a a
07:22:08 <{AS}> Peaker: thanks, I would not have been able to come with that myself :)
07:23:23 <Peaker> > [[1..5], [100..110]] ^.. taking 8 (traverse . traverse)
07:23:25 <lambdabot>  [1,2,3,4,5,100,101,102]
07:24:09 <Profpatsch> I wonder how fast you can code once you are fluid in lens 
07:24:57 <Profpatsch> That is you think of a transformation and are able to write it down correctly on the first try (or debug the type errors in O(1)).
07:25:20 <Profpatsch> O(1), but the constant factor is 1d ‚Ä¶
07:27:06 <{AS}> Profpatsch: I can do it in O(1) with a constant factor of 1 bio. years :)
07:27:21 <ntnt> pedantic
07:28:59 <{AS}> It was just a bad joke :)
07:31:28 <Peaker> Profpatsch: For most lens I can just write them on the first try. Rarely I do stare at lens type errors for full minutes
07:32:24 <Lokathor> HashSet requires Ord just like the noraml Set does. Is HashSet faster on average? or, why would you use it if you're not at least able to get around the Ord limitation?
07:33:34 <kadoban> Ord is probably just for inside the buckets or something?
07:33:44 <kadoban> (aka if there's collisions)
07:34:17 <Lokathor> right, that's what the docs say
07:34:37 <Lokathor> so there's a speed gain to be had by using hashset perhaps?
07:35:52 <Profpatsch> Lokathor: I had the same question a few minutes ago, but it‚Äôs kind of obvious.
07:36:05 <Profpatsch> HashSet has a Hashable Constraint. 
07:36:06 <kadoban> Would make sense I guess, at least on average. I'm not really 100% clear how you do a hash table in haskell though. Maybe it's based on IntMap or something odd?
07:36:35 <Lokathor> kadoban, yeah it's an IntMap to a Set of values with that hash value
07:36:45 <kadoban> Ah, kind of interesting.
07:36:47 <Lokathor> Profpatsch, I'm not sure if that's good or bad?
07:36:48 <Peaker> HashSet isn't a hash table, I don't think. IIUC, it just uses the hash as a key in something like an IntMap (a trie)
07:37:24 <Peaker> hash tables are not good persistent data structures -- they're very good ephemeral structures though
07:37:43 <kadoban> Then as long as the hashing function is quick, it's probably got lower constants at least for most simple uses? I haven't really ever benched that kind of stuff, but IntMap at least seems pretty quick anecdotally.
07:37:44 <Profpatsch> HashMap is the hash table.
07:38:33 <Lokathor> I've got a function that builds up a Set as it computes things. I thought I could go faster by building an ordered list and then converting it to a set once at the end, but that was like 10x slower
07:38:45 <Peaker> Profpatsch: IntMap is not a hash table, and a HashMap is not a hash table. Hash tables use arrays
07:38:59 <Lokathor> so I'll check HashSet later I suppose, maybe it'll do better
07:39:17 <Peaker> Lokathor: what do you mean by "ordered" list?
07:39:36 <Lokathor> well, like every time i inserted into the list i kept it ordered
07:39:47 <Profpatsch> Oh, the Hashable Constraints in HashMap are per function. Interesting.
07:39:58 <Profpatsch> Right, because you w
07:40:07 <Profpatsch> shouldn‚Äôt have constraints on data types.
07:40:42 <Profpatsch> Lokathor: Generally (or at least I‚Äôm pretty sure): The more constraints you have on the interface, the faster the implementation can be.
07:41:11 <Profpatsch> Because the implementation can use more details to find shortcuts.
07:41:53 <Profpatsch> And it‚Äôs a lot faster to look up Hashes (e.g. with a prefix-tree) than to look up arbitrary keys (where you need a slower tree).
07:42:13 <Lokathor> alright i'll check it out
07:42:26 <Lokathor> after work
07:42:38 <Peaker> Lokathor: how did you "keep it ordered"? By scanning the list? If so, that explains the slowness
07:42:40 <kadoban> Lokathor: An ordered linked list is kind of a really bad implementation of a set though, because it requires O(n) time to add a value
07:42:40 <Profpatsch> Both are O(log n), but the Coefficients should be wildly different in practice (for big data structures)
07:43:10 <Lokathor> well I know that ~now~
07:43:15 <Lokathor> but at 1am it was less obvious
07:43:21 <kadoban> Hehe, yeah.
07:43:32 <Profpatsch> Whether you need it is of course (as always) a matter of benchmarking. ;)
07:44:08 <Lokathor> yeah the benchmarks went from 8ms to 717ms in the faster case
07:58:51 <Lokathor> "This [Location] based recursion compiles to something that's faster than a self-written Int# based for loop. Thanks GHC."
08:00:21 <kadoban> Heh, what's that from?
08:00:41 <Lokathor> me. I had to write myself some notes about what to not try again in the future
08:01:02 <kadoban> Ahh
08:01:47 <Lokathor> as much as i try, sometimes the haskell version ends up slower than the Java version, and then I really start to stare hard and try to see if i'm making any sort of mistakes
08:02:47 <Profpatsch> How would you pass command line arguments to a GUI that is started with a function IO a -> IO ()?
08:03:19 <Profpatsch> My idea is to put them in a Reader [String]
08:03:32 <Profpatsch> And that in an IORef
08:03:51 <Profpatsch> Ah, but that‚Äôs mutable.
08:04:48 <Profpatsch> Is there an immutable Ref?
08:05:31 <lyxia> simple variables
08:05:43 <Cale> Profpatsch: Can they just be captured by the definition of the IO a action you're passing in?
08:05:58 <Profpatsch> Cale: Oh, you are right!
08:06:11 <Profpatsch> IO (env -> a) -> IO ()
08:06:30 <geekosaur> and the IO a can't just do getArgs?
08:06:34 <Profpatsch> That‚Äôs way too easy. :)
08:06:57 <Profpatsch> geekosaur: Yes, of course, but I want to separate these.
08:07:02 <geekosaur> (and if you need to override those, withArgs [...] theIOAction
08:08:59 <Gurkenglas_> Is there a way to use the contents of one lens to make an argument for another? Namely, if a record contains a list and an Int refering to a position in that list, is there a single lens that'll access whatever position that int points to?
08:10:12 <Gurkenglas_> It even sounds like it wouldnt break lens laws as long as the pointed and the values accessible via the pointer don't overlap
08:12:17 <lyxia> I'm sure you can define it by hand, or are you looking for some composition of common lenses?
08:12:35 <Gurkenglas_> Yep
08:13:10 <Gurkenglas_> (Actually this was someone else's question on stackoverflow, but when reading it I realized I also wanted that a few times.
08:13:12 <Gurkenglas_> *)
08:15:44 * hackagebot ghc-imported-from 0.3.0.5 - Find the Haddock documentation for a symbol.  https://hackage.haskell.org/package/ghc-imported-from-0.3.0.5 (CarloHamalainen)
08:15:55 <Profpatsch> aaaaaand ‚Äî he‚Äôs gone
09:14:45 <Aruro> how big is github's haskell repo? did someone try to make dump?
09:15:21 <johnw> what is "github's haskell repo"?
09:15:24 --- mode: johnw set -o johnw
09:16:16 <kaictl_work> there's a haskell github organization...maybe that's what they're looking for.
09:19:59 <nitrix> Aruro: "Big" could be answered by manic metrics. What are you interested into?
09:20:14 <nitrix> *nany
09:20:16 <nitrix> *many
09:22:58 <nitrix> Aruro: The Haskell group on Github has a few popular tools and libraries community made (e.g. cabal, containers, network, bytestring), but GHC is on https://ghc.haskell.org/trac/ghc. See https://ghc.haskell.org/trac/ghc/wiki/Repositories.
09:29:44 <nitrix> Aruro: Typically, people that asks strange questions like yours find interest in meaningless metrics like lines of code, so, I pulled out GHC stats. The compiler and the libraries needed for it to work sums up to 32k lines of Haskell.
09:30:38 <Aruro> nitrix: its not strange quesion, was away
09:30:41 <nitrix> Aruro: The whole git repo (including history) takes 393M on my machine.
09:30:44 <Aruro> nitrix: i want to back it up
09:31:03 <Aruro> nitrix: lol :D who is strange now? :)
09:31:11 <Aruro> ghc is on github btw
09:31:39 <nitrix> It isn't. It's a mirror.
09:31:39 <Aruro> nitrix: its only haskell projects right?
09:31:46 <nitrix> "btw".
09:31:56 <Aruro> nitrix: i care about code , not process
09:32:49 <Aruro> nitrix: i wish there would be two torrents with complete hackage base and github
09:33:23 <nitrix> Torrents are inefective ways to do version control.
09:33:48 <Aruro> nitrix: i want to back up the full code database, im not interested in version control
09:34:01 <nitrix> Cloning the git repository does effectively that.
09:34:32 <Aruro> nitrix: so is there way to clone every git repo marked haskell?
09:34:47 <Aruro> nitrix: there is a way to language search
09:35:25 <Aruro> nitrix: i know there is some hackage packages to mirror hackage, but no single torrent so far
09:35:46 <nitrix> Well, I don't think there's an easy way to download all repositories that exists with an Haskell codebase, although you could crawl Github and check the estimation provided by Github.
09:36:29 <nitrix> But you certainly can clone GHC; and/or; mirror hackage/stackage.
09:40:19 <Aruro> nitrix: arent these all haskell repos ? https://github.com/search?p=1&q=language%3AHaskell&ref=searchresults&type=Repositories&utf8=%E2%9C%93
09:42:28 <Aruro> nitrix: hm, but only 1000 repos actually shown, ghub claims there is 47000 haskell repos
09:43:28 <sqrt2> they're probably trying to keep you from using the search function as a starting point for scraping their entire website
09:44:05 <crough> did they mean open source? cause we have 10 or so private repos at work
09:44:35 <nitrix> Aruro: I'm not sure what your goal is.
09:44:37 <Aruro> crough: yes maybe that is factor, but still wierd that exactly 1000 repos are shown
09:44:55 <nitrix> Aruro: You can't just crawl everything; some of them are licensed and stuff.
09:45:10 <Aruro> nitrix: so i can not backup them?
09:45:15 <nitrix> Because it's open-source doesn't mean it can be redistributed or whatever.
09:45:21 <Aruro> nitrix: they are open to public no?
09:45:22 <nitrix> I don't know. Depends on the licenses.
09:45:39 <nitrix> Aruro: That's not how it works, and this discussion isn't about Haskell really.
09:46:08 <Aruro> nitrix: links on how it works please. Tomorrow github is down and we have nothing :D
09:46:24 <subfactorial> newbie here.  I'm trying to build a DSL where I'd like source positions and other annotations after parsing is done.  So that's one problem, all my googling leads to 'use cofree comonads!'.  Now i have two problems. :)  The thing I'm dealing with now is that fmap works over the annotations.  If i want to run some function over the underlying functor I find have to write something like http://lpaste.net/159665 with open coded recursion.  is there a mo
09:46:50 <Aruro> nitrix: stackexchange made their data dumps public, google.
09:46:51 <nitrix> Aruro: You're confused. Stackage exists to have reproducible builds that are guaranteed to keep working.
09:47:06 <nitrix> You don't have to aggressively backup everything.
09:47:31 <Fernandos> Hi
09:49:14 <Fernandos> How do you seperate concerns like the application model, from the rest of the application without using a framework in a functional way? 
09:49:56 <crough> Fernandos: don't worry about that too much. Worry more about seperating impure from pure code.
09:50:20 <Cale> Fernandos: I don't really understand that question. Could you be more specific?
09:50:23 <crough> Functional patterns tend to be highly different from OO ones.
09:50:44 <Aruro> nitrix: since u are master of how it works , read here : http://ghtorrent.org/
09:50:46 <Cale> subfactorial: your line got cut off at "is there a m"
09:50:48 <Fernandos> crough: I worry about that, because I'm currently trying to solve so called "database migrations" in a functional way that I think should be more tightly integrated into the database. 
09:50:51 <nitrix> Fernandos: If you could elaborate or give examples on what "application model" and "rest of the application" means, I can give it a shot.
09:50:54 <Aruro> nitrix: notice names on the left
09:50:59 <EvanR> _|_ is called bottom and is used to talk about the "value" of a program that never produces a value. its also said that such a computation "never terminates"... which i just realized is confusing since the program often instantly aborts (terminates) if _|_ happens
09:51:21 <subfactorial> .... is there a more idiomatic way of doing this?
09:51:27 <Cale> EvanR: well,  let x = x+1 in x also has value _|_
09:51:32 <Cale> EvanR: it may not terminate
09:51:56 <Cale> EvanR: It's just that we turn the evaluation of certain detectable _|_-valued expressions into exceptions
09:52:05 <nitrix> Aruro: Is GHTorrent your project?
09:52:13 <Cale> (so they don't terminate, quickly)
09:52:28 <nitrix> Aruro: You'll face many problems trying to do this for Haskell.
09:52:37 <Aruro> nitrix: no, thats what i was asking
09:53:08 <Fernandos> crough: database re-engineering/migrations the way it is done at the moment is flawed in many ways and rollbacks aren't even guarenteed to be possible for all states. 
09:53:26 <EvanR> and _|_ is also called false, and a proof of false is sometimes called abort, which suggests termination ;)
09:55:34 <EvanR> _|_ is also a partial value at the bottom of a definedness hierarchy
09:55:45 <EvanR> in which case termination isnt really involved
09:55:48 <Fernandos> crough: I'm not an expert in Haskell and I don't know which type information ghc creates that I could utilize in order to do "infer" the application model. Unlike active record, it should be type safe. 
09:56:16 <EvanR> overloaded symbols!
09:56:58 <crough> Fernandos: My advice is to try not to infer schema from types. I've had nothing but problems with that, unfortunately. I have no advice there
09:57:39 <EvanR> infer types from a schema!
09:57:59 <crough> EvanR: Opaleye! It's wonderful.
09:58:07 <crough> Types are schema are types.
09:58:12 <ggVGc> man, I'm so lost in the world of Lenses
09:58:13 <crough> ugh that library is so pretty
09:58:17 <Fernandos> crough: Do you think it's possible to infer the schema safely without extra annotations, nor active record like implmentations?
09:58:18 <ggVGc> I don't even know what I'm doing anymore
09:58:43 <EvanR> Fernandos: that seems like the backwards way
09:59:53 <crough> Fernandos: No, because of having to migrate. You can never be completely safe with that imo. Databases are much pickier than your PL.
10:04:12 <Fernandos> crough: exactly. I also think that the problem is at the DB side and I would need to create at least a new db-driver or create a new storage-backend. Alternatively I could create a meta-database (or database database) that describes the db, just like a compiler compiler
10:05:39 <crough> I mean, yes, but this is a lot of work that can be solved with "don't couple your schema with your PL rep"
10:06:33 <cocreature> @quote merijn problem
10:06:34 <lambdabot> merijn says: If you have a problem and you think "I know, I'll use lenses!", you now have morphisms in the category of problems :P
10:06:37 <cocreature> ^ ggVGc 
10:06:41 <Fernandos> That would result in a schema generator and software defined data repopulation..
10:07:11 <Fernandos> crough: what does "rep" stand for in PL rep?
10:07:50 <crough> representation
10:08:01 <crough> sorry, I abbreviate unneccesarily
10:09:12 <Fernandos> unneccary compression is a sign of laziness, which is a sign of intelligence ;)
10:09:20 <mmachenry> crough: I abrv. uneces. 2
10:09:24 <Fernandos> meh grammar...spelling
10:10:06 <ggVGc> how do I write the type signature for this as a Traversal' ? https://gist.github.com/205785a111cf9e81f87d93c5697c4446
10:10:16 <ggVGc> It's essentially the same as `ix` I guess?
10:10:35 <ggVGc> but I'm not sure how to express a "parameterised traversal" in the Lens way
10:10:57 <hjulle> What's the difference between the parsers "type Parser a = StateT String [] a" and "type Parser a = StateT String Maybe a"? (Where "char :: Parser Char; char = do x:xs <- get; put xs; return x" gets a token, and mfilter + Alternative provides the other primitives.)
10:11:02 <lyxia> ggVGc: SeqIndex -> Traversal' something something
10:11:11 <Fernandos> crough: would you agree that the problem is that the programming language isn't more tightly integrated with the database, meaning it doesn't dynamically bind to all db-internals, but is rather limited to an "abstract interface"?
10:11:58 <crough> I would agree that's the problem that you're trying to solve, but I would disagree that it's a problem :)
10:12:04 <ggVGc> lyxia: says I need to enable RankNTypes. Why is that?
10:12:25 <cocreature> ggVGc: because the f in the traversal needs to be polymorphic
10:12:35 <cocreature> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t 
10:13:21 <Fernandos> crough: don't you think that the way database migrations are done is  totally flawed and unreliable?
10:13:24 <ggVGc> cocreature: so why is it fine with my original tye declaration with only Applicative? Is it not general enough to be used as other traversals?
10:13:46 <lyxia> hjulle: you can put more results in a list than a Maybe
10:14:16 <hjulle> ggVGc: Using the type synonym moves the forall f. Applicative f => constraint to the right.
10:14:20 <cocreature> ggVGc: because in that case you have the forall around the complete expression
10:14:55 <crough> Fernandos: Yes, but my solution is to awknowledge the divide and embrace its shortcomings and advantages rather than to unite the two layers.
10:15:11 <ggVGc> argh, this is above my head :( very frustrating
10:15:11 <hjulle> ggVGc: The new code would be: SeqIndex -> (forall f. Applicative f => (TriggerSeq -> f TriggerSeq) -> SeqModel -> f SeqModel)
10:15:13 <ggVGc> thanks though
10:15:42 <ggVGc> I need to read up on the uses of forall
10:15:46 <crough> Fernandos: I'm not trying to shut you down, by the way, I just am one of the people who enjoys SQL and prefers the divide :)
10:15:47 <ggVGc> I have no grasp of it at all
10:15:48 * hackagebot polyparse 1.12 - A variety of alternative parser combinator libraries.  https://hackage.haskell.org/package/polyparse-1.12 (MalcolmWallace)
10:20:07 <ggVGc> cocreature: so, when defined with my orifingal type signature, without forall, is the function/traversal now useable in less situations?
10:20:14 <ggVGc> in that case, which situations does it not cover?
10:20:22 <hjulle> ggVGc: Every time there is a free type variable in a type signature, there is an implicit "forall a." added to the beginning of the signature. And it basically means what it sounds like: "For all types a, satisfying the constraints, this type looks as follows", where the variable is replaced by a concrete value whenever the function (or value) is used.
10:21:28 <cocreature> ggVGc: afaik there is no difference in this case, because a -> (forall f. b) is equivalent to forall f. a -> b if f is not free in a
10:21:29 <ggVGc> ah, yeah, right, I knew that actually. But in thsi case I'm still confused how I can have one type signature that's valid for the same function while another requires RankNTypes to be valid
10:21:41 <ggVGc> alright
10:21:48 <cocreature> ggVGc: the type synonym itself requires the rank n types
10:21:53 <ggVGc> it's just that the Traversal' is more general than my specific case?
10:22:07 <cocreature> ggVGc: because it uses f on the right but it‚Äôs not a type parameter
10:23:29 <cocreature> ggVGc: the difference is more obvious when you want to use it as a parameter to some other function, then the forall is really necessary
10:23:43 <hjulle> I believe that RankNTypes is required whenever forall is used, regardless of if it is equivalent to some type where the forall is implicit.
10:24:00 <hjulle> (please correct me if I'm wrong)
10:24:22 <xa0> ExplicitForAll would also do fine in those situtations
10:24:24 <cocreature> hjulle: unless it‚Äôs an existential :P
10:25:13 <EvanR> ggVGc: forall is like a limited form of type level lambda 
10:25:34 <ggVGc> I've had too much type theory today I think
10:25:35 <hpc> in fact, it /is/ a limited form of type level lambda
10:25:36 <cocreature> ggVGc: iirc https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html is a pretty good introduction
10:25:41 <ggVGc> and i feel like an infant :((
10:25:52 <ggVGc> I'm surpried I can make any haskell compile at all
10:25:56 <cocreature> don‚Äôt worry we‚Äôve all been there :)
10:25:59 <EvanR> just one of those days
10:26:02 <ggVGc> cocreature: thanks
10:26:02 <hpc> very limited, and there are othe things that are differently limited type level lambdas
10:26:05 <hpc> but it is nonetheless
10:26:24 * EvanR tries to understand in what way it is limited
10:26:31 <xa0> there was a really nice guide that I read on rankntypes...
10:26:36 <ggVGc> I realised today I have almost no intuition or understanding at all of even Applicative
10:26:46 <ggVGc> by readig things trying to understand how Lenses came about
10:26:56 <ggVGc> but now I kind of see how they are fundamentally based on Applicative
10:26:58 <xa0> https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
10:27:09 <ggVGc> and why my custom Traversal' needs applicative
10:27:51 <cocreature> xa0: I literally posted that 2 minutes ago :)
10:28:01 <xa0> oh!
10:28:03 <xa0> haha
10:28:04 <xa0> sorry
10:28:19 <hpc> have you read https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html yet? :P
10:28:35 <ggVGc> no, but I just started reading this one, https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
10:28:35 <xa0> hpc: I literally posted that 2 minutes ago :)
10:31:20 <mitchty> if i cabal sandbox init, is there a way to specify the prefix key for install-dirs straight away?
10:33:21 <Zemyla> Is there a simple name for the construct "forall x. c x => exists y. d y => F x y"?
10:33:27 <mitchty> nevermind think i figured it out
10:35:11 * ggVGc crawls back to a simple concrete type system
10:35:40 <nitrix> ggVGc: It's not as bad as it looks.
10:35:53 <nitrix> ggVGc: It will take a few attempts to fully grasp it though.
10:36:45 <ggVGc> nitrix: hey, I'm still trying to get an intuition for Applicative and Traversable
10:37:11 <nitrix> I can also probably explain lenses; in a very poorly layman manner.
10:40:25 <nitrix> Imo, I think lenses can be understood with just proper knowledge of functors and record update syntax.
10:40:36 <ertesx> (Map k (Seq a)) and (Map k (Set a)) are so useful, i seem to be reinventing an API for them a lot
10:41:38 <ggVGc> nitrix: I mostly understand lenses conceptually, and I've been using them a lot the past week. But the past days I've been needing to create my own Traversal's which has led to a great deal of confusion and experimentation
10:41:55 <ggVGc> and today I got stuck and decided I needed to get some more understanding of how Lenses actually work under the hood
10:42:02 <ggVGc> now at least I kind of understand the link with Applicative
10:42:15 <ggVGc> but Applicative.Const makes no sense to me right now, and seems like a crazy hack
10:42:16 <ertesx> if you want to understand lenses, i'm not sure if reading about RankNTypes is a good first step
10:42:34 <ertesx> note: you can understand lenses without ever touching higher-rank types
10:43:03 <EvanR> ggVGc: without polymorphism, you have to reimplement the list data structure for list of every type, like C. It's pretty bad
10:43:27 <ggVGc> EvanR: but on the other hand I don't end up spending an entire day reading things I understand 40% of?
10:43:30 <ggVGc> dunno, tradeoff
10:43:35 <ggVGc> in C I just smash code all day
10:43:38 <ggVGc> and then fix bugs for a week
10:43:40 <EvanR> especially because the implementation doesnt depend on the type at all
10:43:58 <EvanR> ggVGc: true, in haskell you spend more time thinking than coding (ideally)
10:44:04 <EvanR> and then you spend less time refactoring
10:44:17 <ertesx> ggVGc: the difficulty of understanding how to *write* lenses doesn't have much to do with polymorphism
10:45:26 <c_wraith> lenses really aren't hard to write. if you start with the appropriate type signature, you quickly discover there's an easy pattern. 
10:46:44 <ggVGc> c_wraith: well, this is the first thing that stopped me a few days ago, that glguy helped me with, https://gist.github.com/fe622dfd0e82752f9b2f1465df85a175
10:46:52 <ggVGc> I would never have figured out how to use `ix` like that
10:47:04 <ggVGc> because I didn't really understand the function itself
10:47:17 <ggVGc> just how to use it in a chain of composed lenses
10:47:46 <ertesx> ggVGc: do you know how to write a lens by hand?
10:47:58 <ertesx> not using a convenience combinator
10:48:24 <ertesx> (not a traversal, just a lens)
10:48:42 <ggVGc> kind of, although I haven't written one myself, just read
10:48:45 <ggVGc> so probably not really
10:48:53 <ertesx> then you should do that
10:49:24 <ertesx> write a "left" lens:  left :: (Functor f) => (a -> f b) -> (a, c) -> f (b, c)
10:49:33 <ggVGc> I was also struggling with this today, this last function `curTriggerSeq`. Seems like I'm missing a trick, https://gist.github.com/be6d5a901f32bce7091138fb4fcd8d0f
10:49:36 <ggVGc> ertesx: yeah, agreed
10:49:44 <ggVGc> thanks
10:50:46 <ertesx> ggVGc: if you have trouble with that, we can write it interactively, but try yourself first‚Ä¶  note that it's mostly an exercise of looking at the types
10:51:30 <ggVGc> ertesx: yeah, I'll give it a crack :)
10:52:13 <ertesx> ggVGc: feel free to highlight me, when you're done‚Ä¶  i won't be monitoring the channel
10:52:22 <ertesx> (or when you need help)
10:57:46 <nitrix> I personally would recommend implementing a :: lens'
10:57:57 <nitrix> The Lens' type (which is simplified)
10:58:19 <nitrix> And using typed holes _ to assist you building the implementation.
10:58:38 <cocreature> it‚Äôs harder to get lens wrong than lens' :)
10:58:45 <ertesx> i wouldn't‚Ä¶  a full Lens is actually more difficult to get wrong
10:59:55 <nitrix> Alright.
11:00:15 <ertesx> given an ordered property of the elements of a Seq, is there a package for binary search?
11:00:53 <ertesx> like this:  split :: (Ord b) => (a -> b) -> Seq a -> (Seq a, Seq a)
11:01:29 <ertesx> doing `Map b (Seq a)` feels like a waste of code and memory
11:03:20 <ryantrinkle> ertesx: it *wasn't* CSE!
11:03:27 <ryantrinkle> it was far crazier than that
11:03:30 <ryantrinkle> does anyone have a suggestion for how to do profiling that includes the impact of finalizers?
11:03:37 <ryantrinkle> i.e., when i call mkWeakPtr, it takes a certain amount of time
11:03:41 <ryantrinkle> but it also has an amortized cost, i.e. the extra cost of finalizing the weak ptr when it gets garbage collected
11:03:51 <ryantrinkle> i'm not sure how to measure that cost
11:04:20 <ggVGc> ertesx: this eh? https://gist.github.com/a725b524792e48bc1ec2a3ecf737a6ed
11:04:25 <ggVGc> yeah, that's pretty easy
11:04:32 <ggVGc> and also, I read it before but it didn't really stick
11:04:50 <ggVGc> it's neat, applying a function(which can be identity for getter)
11:04:53 <ggVGc> simple and elegant
11:05:11 <ertesx> ryantrinkle: that's weird, since -fno-cse had fixed it earlier
11:05:11 <EvanR> i implement left as shown above, now what do i do with it ;)
11:05:35 <ertesx> ggVGc: there you go‚Ä¶  are you confident that you could do the same for a record field?
11:05:43 <ertesx> ggVGc: if not, make a simple record type and try it
11:05:47 <ryantrinkle> ertesx: yep, what it appears to me now is that the strange behavior was due to the memory allocated by the test being a very precise amount
11:05:57 <ryantrinkle> which was, i think, very close to the allocation block size
11:06:41 <ryantrinkle> if i gave +RTS -A500k instead of the default of 512k, the effect went away
11:06:42 <ggVGc> ertesx: yeah, I compeltely understand it. It's just a matter of mapping a modification over a focused value and returning the modified value, which for `id` becomes a getter
11:06:48 <ryantrinkle> or if i gave it 520k
11:07:04 <ryantrinkle> so, my suspicion is that the timing was bimodal in whether a block needed to be allocated or not
11:07:07 <ggVGc> ertesx: I think the reason I've been struggling with writing my Traversals is that I'm lacking fundamental haskell knowledge in the realm of Applicative and Traversable
11:07:27 <ggVGc> anyway, thanks for making me implement this :) Now it'll stick more
11:07:59 <ertesx> ggVGc: exactly‚Ä¶  now let's look at a simple traversal and just pretend that it's actually a lens:  both :: (Functor f) => (a -> f b) -> (a, a) -> f (b, b)
11:08:08 <EvanR> left ((:[]) . ord) ('a', 'b')
11:08:13 <EvanR> [(97, 'b')]
11:08:21 <EvanR> funky
11:09:32 <ertesx> ggVGc: here is an incorrect way to do it:  both l (x, y) = fmap (\y -> (y, y)) (l x)
11:10:03 <ertesx> ggVGc: both l (x1, x2) = fmap (\y1 -> (y1, y1)) (l x1)
11:10:19 <ggVGc> ertesx: yeah, it has to be recursive eh?
11:10:24 <ertesx> nope
11:10:31 <ertesx> the trouble is that there is no way to write it at all
11:10:36 <ggVGc> ah, right
11:10:43 <ertesx> because Functor is not expressive enough to cover *both* fields
11:10:53 <ggVGc> ah right, and this is why we need Applicative
11:10:58 <ertesx> yeah
11:11:01 <ggVGc> yeah, this is what I gathered from my studies today
11:11:07 <ggVGc> but not in details that I can remember off hand
11:11:09 <ggVGc> but it clicked a bit
11:11:16 <ertesx> now try to write `both` with Applicative instead of Functor
11:11:21 <ggVGc> why functor wasn't enough, and why my Traversal' definition had Applicative in tem
11:11:39 <ggVGc> ertesx: this is my issue since I've never used Applicative in my own code before
11:11:42 <ggVGc> I need to brush up on it
11:11:57 <ertesx> look at the following two types:
11:12:21 <ggVGc> where can I find good haskell excersices btw? For situiations like this where I feel I want to grok some certain topic or type class
11:12:33 <ertesx> fmap :: (a -> b) -> F a -> F b  -- take one, map, give one
11:12:47 <ertesx> liftA2 :: (a -> b -> c) -> F a -> F b -> F c  -- take two, map, give one
11:12:50 <xa0> @pl (\x -> tail $ tail . (<$> x) . (*) <$> x)
11:12:51 <lambdabot> tail . ((<$>) =<< (tail .) . (. (*)) . flip (<$>))
11:13:02 <ggVGc> ah, right, now I remember
11:13:11 <ggVGc> yeah, it's easy to implement a `both` using liftA2
11:13:18 <ertesx> then go ahead =)
11:13:26 <ggVGc> yep, sec
11:14:08 <Akii> what does fmap stand for, functor map?
11:14:32 <EvanR> it stands for mapping operations on f where f is the functor
11:14:46 <hpc> or to put it another way, yes
11:14:57 <Akii> thx :D
11:15:06 <EvanR> ex. f = Maybe could be called "Maybemap"
11:15:27 <ertesx> Akii: funky map, fuzzy map, whatever sounds best to you =)
11:15:32 <ertesx> it's really just "map"
11:15:35 <hpc> frabjous map
11:15:39 <ertesx> but "map" was already taken
11:15:54 <sm> hey all
11:16:03 <Akii> so, mmap is for monads then? ^^
11:16:16 <ertesx> fmap is for monads
11:16:26 <sm> when including non-HTML docs such as README, CHANGES, or nroff man pages in a cabal package, would you use other-doc-files ? or other-source-files ?
11:16:27 <Akii> because monads are functors, makes sense
11:16:32 <EvanR> the reasoning fmap isnt called map is due to a lack of cojones
11:16:51 <ggVGc> fatmap
11:16:58 <hpc> the categorical dual of jones
11:16:59 <ggVGc> ferocious map
11:17:09 <ertesx> sm: i currently use extra-source-files
11:17:32 <xa0> i actually like it as fmap, keeps it separate from list map in my head
11:17:33 <ertesx> not even familiar with the ones you mentioned =)
11:17:36 <xa0> even though they're the same, i know
11:17:44 <EvanR> Akii: there is liftM but fmap is the same thing and has a convenient infix operator
11:17:51 <EvanR> <$>
11:18:11 <Akii> not understanding the lift stuff yet
11:18:20 <EvanR> this doesnt have anything to do with lifting really
11:18:28 <ertesx> Akii: liftM is literally just fmap
11:18:40 <ertesx> :t liftM
11:18:42 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
11:18:50 <hpc> it's mathematically impossible for liftM to not equal fmap
11:19:15 <ertesx> @src liftM
11:19:15 <lambdabot> liftM f m1 = do
11:19:15 <lambdabot>     x1 <- m1
11:19:15 <lambdabot>     return (f x1)
11:19:20 <cocreature> who cares about this mathematics thing anyway
11:19:22 <ggVGc> ertesx: argh, it wasn't so easy. I'm missing something
11:19:24 <hpc> (for types that are Monad)
11:19:34 <Akii> ye math sucks!!11 sry
11:19:46 <Akii> hm the @src thing is cool
11:20:01 <Akii> but why the naming liftM then
11:20:03 <EvanR> @src windows10
11:20:04 <lambdabot> Source not found. You type like i drive.
11:20:07 <ertesx> ggVGc: both l (x1, y2) = _result  -- you can definitely apply 'l' to both x1 and x2, right?
11:20:18 <Akii> so it's "lifting" the context of m1 into m2
11:20:32 <hpc> Akii: for a very long time, Monad didn't imply Functor
11:20:33 <EvanR> theres only 1 m
11:20:38 <ertesx> ggVGc: s/y2/x2/
11:20:41 <Akii> and by doing so converting what's inside m1 to something that can be inside m2
11:20:45 <hpc> so you had monads that were not also functors and liftM would be defined but not fmap
11:20:59 <ggVGc> ertesx: yeah
11:21:14 <Akii> okay, so it really just is map now
11:21:29 <ertesx> ggVGc: both l (x1, x2) = _result  where c1 = l x1; c2 = l x2  -- what are the types of c1 and c2?
11:21:34 <EvanR> when f = [ ] fmap = map
11:22:05 <ertesx> ggVGc: where both :: (Applicative f) => (a -> f b) -> (a, a) -> f (b, b)
11:22:28 <ggVGc> ertesx: they're both `f b`
11:22:29 <ggVGc> ?
11:22:33 <ertesx> correct
11:22:39 <ggVGc> yeah, I got that far
11:22:48 <ggVGc> but now I don't exactly know how to make it f(b,b)
11:22:52 <ggVGc> I thought I knew how to lift
11:23:02 <ertesx> one of them holds the result for x1, the other one for x2
11:24:00 <ertesx> so you need to combine them‚Ä¶  listen: you need to take the two that you have, map a combination function, and give one back
11:24:25 <ggVGc> ah, gimme a sec
11:27:54 <ggVGc> aha!
11:27:54 <ggVGc> both l (x,y) = (liftA2 (,)) (l x) (l y)
11:28:00 <ggVGc> ?
11:28:02 <ertesx> there you go =)
11:28:11 <ggVGc> alright, cool
11:28:14 <ggVGc> thanks, that helps a lot
11:28:29 <ggVGc> I know it's simple and I understand it intuitively, but this helps me get at the details
11:28:59 <ggVGc> I still really need to get comfortable with applicative though
11:29:04 <ertesx> ggVGc: there are two last things to understand for traversals:  zeroes and quantities that aren't statically known
11:29:12 <ertesx> it will help you with Applicative itself, too
11:29:28 <ggVGc> yeah, I the "traversal that misses" is what caused a problem for me earlier today
11:29:33 <ertesx> write this one:  none :: (Applicative f) => (a -> f b) -> c -> f b
11:29:41 <hpc> ggVGc: you should take that definition and manually expand liftA2 and make it look nice
11:29:50 <hpc> (in addition to writing none)
11:29:59 <ggVGc> alright
11:30:05 <hpc> ggVGc: it might make it a bit more clear what "applicative style" is
11:30:40 <Fernandos> crough: I think I solved it, but it requires a model generator interfacing for each language required. Which is not drama, but the underlying reference management is quite complex. I think I'll look at how ZFS solves that issue :P
11:30:57 <ertesx> ggVGc: if you have trouble writing 'none', look at the Applicative class‚Ä¶  while (<*>), the underlying function of liftA2, denotes "two", there is something that denotes "zero"
11:31:57 <Fernandos> hi ertesx :)
11:32:16 <ertesx> hi Fernandos
11:32:55 <Fernandos> hope you're doing well :) it's been a while
11:33:50 <Zemyla> ertesx: I can't even write that. Where is b supposed to come from?
11:34:16 <ertesx> Fernandos: i am, thanks!
11:34:28 <ertesx> ggVGc, Zemyla:  oops!
11:34:45 <ertesx> none :: (Applicative f) => (a -> f b) -> c -> f c
11:34:49 <ertesx> sorry, my bad =/
11:35:40 <ggVGc> ertesx: yeah.. I am failing. I thought I'd use empty
11:35:43 <ggVGc> or something
11:35:48 <ggVGc> but I'm missing a piece
11:35:59 <ertesx> ggVGc: check the type‚Ä¶  the earlier one was wrong
11:36:32 <ggVGc> ah, it looked a bit strange
11:36:46 <ertesx> can you write it with the new type?
11:37:32 <jle`> hm, how do typeclass constraints work with curry-howard isomorphism?  is there a meaningful interpretation other than just an Eq a => being equivalent to an (a -> a -> Bool), etc. ?
11:37:49 <jle`> * Eq a => ~ (a -> a -> Bool) ->    , ie, the naive interpretation
11:38:47 <jle`> or maybe something more meaningful would be like `KnownNat n =>` being equivalent to `Integer ->`.  but is there any more insight to viewing typeclass constraints as something in and of themselves?
11:40:13 <ertesx> jle`: not in the usual interpretation‚Ä¶  in fact Constraint becomes *
11:40:33 <ggVGc> ertesx: only thing that type checks for me is none _ x = pure x, but that's not correct..
11:40:47 <ertesx> ggVGc: what makes you think that it isn't?
11:41:39 <ggVGc> oh, wait, yes it is, because it ignores the applied function
11:41:51 <ggVGc> well, no
11:41:54 <ggVGc> damn, I don't know
11:42:14 <ggVGc> it's a lens that always misses, but this is supposed to be a Traversal and should give back no results
11:42:18 <ggVGc> it doesn't make sense
11:42:38 <ertesx> ggVGc: look at this pattern:
11:42:39 <ertesx> liftA2 :: (a -> b -> c) -> F a -> F b -> F c
11:42:39 <ertesx> fmap   :: (     b -> c)        -> F b -> F c
11:42:40 <ertesx> pure   :: (          c)               -> F c
11:42:49 <ertesx> two, one, zero =)
11:43:12 <ggVGc> hm, okay, yeah fair
11:43:18 <ggVGc> I was thinking in terms of Maybe I think
11:43:23 <ggVGc> for no valid reason
11:43:30 <ertesx> there is nothing to traverse, so you traverse zero
11:43:37 <ertesx> well, do a traversal for Maybe
11:43:42 <ggVGc> right, yeah, makes sense now
11:44:03 <ertesx> traverseMaybe :: (Applicative f) => (a -> f b) -> Maybe a -> f (Maybe b)
11:44:14 <ggVGc> yep
11:45:23 <ertesx> once you see how traverseMaybe is implemented, the final exercise is:  traverseList :: (Applicative f) => (a -> f b) -> [a] -> f [b]
11:45:53 <ertesx> if you can do that one, you've pretty much mastered traversals (and also recursive applicative style)
11:46:19 <ggVGc> cool, thanks
11:46:27 <xa0> ertesx: so pretty... 
11:54:20 <Gal3rielol> Hi, I want to use cabal run to execute binary, how should I pass command line params to the binary?
11:54:41 <mettekou> Gal3rielol: cabal run -- the params here
11:55:52 * hackagebot ghcjs-hplay 0.2 - monadic, reactive Formlets running in the Web browser  https://hackage.haskell.org/package/ghcjs-hplay-0.2 (AlbertoCorona)
11:55:54 * hackagebot transient 0.3 - Making composable programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.3 (AlbertoCorona)
11:55:57 <Gal3rielol> thx!
11:56:17 <ggVGc> ertesx: hm... I tried going down this path, but I think it's wrong? https://gist.github.com/afdf35aa4876a9fd76857803a5b1ce7c
11:56:30 <Darwin226> Hey guys. Silly question. How do I convert the first letter of a Text to lower case?
11:56:57 <johnw> Data.Text.toLower
11:57:10 <Darwin226> that converts all the letters
11:57:11 <johnw> you may need to split and rejoin
11:57:37 <Darwin226> oh, ok. So I'm not missing something obvious
11:57:47 <johnw> i don't know of any such method
11:57:56 <johnw> lens would be another way to "focus" on the first letter and lower it
11:59:17 <ertesx> ggVGc: do the cases individually
11:59:36 <ertesx> ggVGc: traverseMaybe l Nothing = _nothingCase
11:59:39 <ertesx> etc.
11:59:54 <sm> maybe [] (\(x, xs) -> toLower x : xs) $  uncons l
12:00:01 <sm> uh yeah, not that
12:00:16 <jle`> Darwin226: if you already have a lens dependency, lens has _Cons
12:01:02 <jle`> er, i mean, _head
12:01:11 <jle`> > over _head toUpper "hello"
12:01:16 <lambdabot>  "Hello"
12:01:30 <jackhill> :t over
12:01:31 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
12:02:07 <jle`> over "unpacks" the setter inside the prism, _head
12:02:08 <sm> map toLower (take 1 l) ++ drop 1 l
12:02:13 <ggVGc> ertesx: ah! https://gist.github.com/fd78adde1da508d9a07c1ae740d34757
12:02:14 <ggVGc> thanks
12:02:16 <jle`> s/prism/traversal
12:02:30 <jackhill> jle`: thanks!
12:03:10 <jle`> in this specific case, it's over :: Traversal' Text Char -> (Char -> Char) -> (Text -> Text)
12:03:11 <ertesx> ggVGc: right‚Ä¶  and use fmap instead of liftA (even though it doesn't make a difference in this particular case)
12:03:23 <ggVGc> ah yeah, that's better
12:03:28 <ertesx> ggVGc: you can see how this would be a proper lens, if it weren't for the Nothing Case
12:03:35 <jle`> jackhill: you're giving it a Traversal' Text Char, and it unpacks it to give you the (Char -> Char) -> (Text -> Text) that it encodes
12:03:52 <johnw> (pack "Hello") & unpacked._head %~ Data.Char.toLower
12:03:53 <jle`> you can think of "over foo" as a generalized fmap of sorts
12:03:53 <dolio> Can you correctly lower case the first letter of a Text by only looking at one Char?
12:03:59 <ggVGc> ertesx: yeah
12:04:04 <ertesx> ggVGc: a lens is a traversal that uses only 'fmap' (one) and thus has a weaker constraint
12:04:21 <ertesx> ggVGc: now for the real brain-teaser: traverseList =)
12:04:23 <ggVGc> and this is technically a Prism right?
12:04:37 <dolio> My guess is, "no."
12:04:56 <jle`> lenses are over Functors, which mean there is always exactly one item -- you can only use fmap (one).
12:04:56 <ggVGc> oh wait, it's a traversal obviously
12:05:11 <jle`> over Applicatives, you have can have 0, 1, 2, etc....any number of items.  so it's a Traversal
12:05:27 <jle`> yeah, the hint is that ertesx called it traverseMaybe and traverseList 
12:05:30 <johnw> we should have Travenses: 1 or more
12:05:37 <ertesx> ggVGc: a prism offers more than just traversing‚Ä¶  it could *construct* a case, while traversals can only destruct
12:06:08 <jle`> johnw: possible with the Apply typeclass, i suppose!  i wonder why those optics were never explored
12:06:09 <ertesx> ggVGc: take your time with traverseList‚Ä¶  it's a bit more difficult than the traversals you have written so far
12:07:03 <jle`> type Travense s t a b = forall f. Apply f => (a -> f b) -> (s -> f t)
12:07:14 <johnw> right
12:07:37 <johnw> needing only a semigroupoid
12:07:43 <dolio> They were, but Apply is a crappy name, and it's not going to be available as ubiquitously any time soon.
12:07:51 <jle`> it's fun to pick different f constraints and see what they imply
12:08:14 <dolio> So they're not in the library.
12:08:21 <jle`> or i guess for optics in genera p a (f b) -> p s (f t)
12:08:41 <jle`> with p ~ (->) and f ~ Functor, you get Lens, for p ~ (->) and f ~ Applicative, you get Traversal, etc.
12:08:58 <jle`> pick a few out of a box and see what you get :D
12:09:11 <ggVGc> ertesx: yep, might have to wait until tomorrow
12:09:22 <jle`> er, f constrained on Functor, constrained on Applicative, i mean
12:09:29 <ggVGc> it's getting very late and UI have to run around bangkok playing waterfight wth the whole city tomorrow :)
12:09:44 <ertesx> ggVGc: it's not *that* difficult, but it is difficult =)
12:09:44 <ggVGc> ertesx: thanks a lot, really. THis was gold for me
12:11:07 * hackagebot transient-universe 0.2 - remote execution and map-reduce: distributed computing for transient  https://hackage.haskell.org/package/transient-universe-0.2 (AlbertoCorona)
12:11:35 <dwynwen_ddlleyw> I have a very vague question and I was wondering if anyone could provide some insight. I know a bit of Javascript and PHP and I was looking to perhaps learn another language. I was going to go with C++ or Java but I wanted to maybe try something different so Haskell was suggested to me. In going from JS to HS what are some things I am most likely g
12:11:36 <dwynwen_ddlleyw> oing to fumble with?
12:12:01 <ggVGc> everything
12:12:04 <ggVGc> literally
12:12:12 <ggVGc> exactly 0 tings will make sense
12:12:37 <ggVGc> dwynwen_ddlleyw: I think it's probably good to start looking at haskell, but you should treat it as starting from scratch in programming
12:12:52 <jle`> dwynwen_ddlleyw: you'll likely mostly stumble when trying to apply what intuition you learned in JS to haskell
12:12:58 <dwynwen_ddlleyw> That sounds less than ideal. I was hoping that I would be able to tie in things I have learned before
12:13:01 <jle`> that's the biggest stumbling point for most beginners, i think
12:13:18 <ggVGc> dwynwen_ddlleyw: you should expect to be at the level of "I'm not sure what a variable is" when you were learning JS
12:13:34 <ggVGc> but you'll get into it fairly quickly if you start writing some simple programs
12:13:37 <jle`> they try to apply the intuition they gained from other languages and it ends up being counterproductive unfortunately
12:13:51 <dolio> Everything you have learned until now has been wrong, though. :)
12:13:57 <ggVGc> ^
12:14:20 <jle`> there's a sense of vertigo too when you're in the middle of learning and trying to link what you know to things you've done in the past
12:14:24 <ggVGc> dwynwen_ddlleyw: it's not to scare you or say "haskell is super hard". BUt it's suer different, and if you don't treat it as starting from scratch, you'll be frustrated
12:14:29 <jle`> and that cognitive mismatch can be dizzying
12:14:46 <dwynwen_ddlleyw> Perhaps Haskell is not the right language for me then
12:15:13 <ggVGc> dwynwen_ddlleyw: if you want to broaden your programming mindset, it definitely is. If you want to be producrtive and write programs fast in it, then no
12:15:18 <EvanR> haskell is a good language to start with, if you have the right book i think
12:15:30 <ggVGc> (hint, EvanR is the right book)
12:15:31 <EvanR> but its hard to start with PHP and then unlearn PHP
12:15:43 <EvanR> but you really should
12:15:51 <dwynwen_ddlleyw> I started with JS about a month ago I think
12:16:07 <dwynwen_ddlleyw> That was my first ever programming
12:16:29 <sm> dwynwen_ddlleyw: go for it! Haskell for Mac is great, if you have one of those
12:16:43 <dwynwen_ddlleyw> I do not have one
12:16:43 <EvanR> when i first heard about haskell, i was programming in C. and the advice was "if you really want to blow your mind, try haskell"
12:17:08 <ggVGc> dwynwen_ddlleyw: imo, you should try getting into haskell. But you should revert your mind to a month ago when you'd never done any programming, and actively try to never draw any similarities between yous JS learning experience and your hasjell one
12:17:17 <ggVGc> and it'll be great
12:17:24 <sm> just follow a good book. No problem
12:17:37 <jle`> people tried to sell me into the "blowing your mind" "helping you become a better programmer" angle, but for me, the greatest benefit of haskell ended up being that i learned a useful language that's great for programming in
12:17:37 <dwynwen_ddlleyw> That's not something that is so easily done I am afraid
12:17:42 <dmj> EvanR: "tired of blowing the stack? blow your mind with haskell"
12:17:42 <jle`> and building real-world applications
12:18:00 <jle`> with safety, reliability, high performance, and maintainability
12:18:18 <dmj`> and concurrency, w/o sacrificing readability
12:18:19 <dwynwen_ddlleyw> I am sort of learning all of this more or less for fun
12:18:22 <ertesx> dwynwen_ddlleyw: it's not just not easy, it's usually impossible‚Ä¶  but don't worry, it's not as bad as it sounds, and most of us went through it at some point =)
12:18:25 <ggVGc> jle`: yeah, but it definitely does take longer to start building real world applications in haskell than in i.e PHP. Even if the work is smoother after you're at that level
12:18:42 <ertesx> dwynwen_ddlleyw: one warning though: learning haskell will likely ruin both JS and PHP for you
12:18:48 <ertesx> and probably all other mainstream languages as well
12:18:51 <EvanR> yes the advice should have been, in retrospec "if you want to write better programs easier, learn haskell"
12:18:59 <jle`> see http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
12:19:17 <ggVGc> EvanR: and in the meantime get 60% of a CS reseatch degree without the diploma
12:19:24 <jle`> although they unfortunately lump haskell into python, what the?
12:19:36 <EvanR> ggVGc: having spent 2 years trying to build a program in PHP... i question this
12:19:42 <EvanR> i think it still does not fully work
12:19:51 <ggVGc> EvanR: but it's a real world running application
12:20:00 <EvanR> people think it works, which i guess is the key
12:20:04 <ggVGc> my first 10 lines of haskell that ran and did something I wanted took me 2 days to write
12:20:15 <ggVGc> 2 full days of active work
12:20:29 <EvanR> i spent way more than 2 full days of active work debugging many things in PHP
12:20:33 <ggVGc> fair
12:20:40 <EvanR> for the stupidest possible reasons
12:20:58 <dwynwen_ddlleyw> My first day of javascript I think I was writing something to turn a CSV file into an html table
12:20:59 <hpc> try drupal sometime
12:21:12 <ggVGc> EvanR: the point is I guess that with most languages you can very quickly get a program up and running that does 60% of what it should do correctly. With haskell you spend a lot more time but get a program that does 99% of what it should do
12:21:14 <hpc> 2 days to figure out how to change one piece of text on the sidebar of the homepage
12:21:28 <EvanR> ggVGc: if youre starting from zero, yeah
12:21:29 <ertesx> EvanR: that's nothing‚Ä¶  i had to write a TYPO3 extension once
12:21:30 <Welkin> lol wtf is this?
12:21:42 <Welkin> off topic you mofos
12:22:11 <Akii> ertesx: I'm a typo3 certified whatever
12:22:23 <Akii> let's get a room of our own and cry a lot
12:22:24 <EvanR> what is a TYPO3 extension... nevermind dont answer that
12:22:51 <Akii> how did we end up with typo3 exactly?
12:22:52 <ania123> can one help me to get this paper:
12:22:57 <Akii> this is a haskell room, right?
12:22:58 <ania123> On the strong differentiation of integrals of functions from h√∂lder classes
12:22:59 <kadoban> typo3 is a big old cms
12:23:32 <ertesx> EvanR: a TYPO3 extension can be summarised as this:  IO Dynamic
12:23:35 <ggVGc> ertesx: my first commercial job was to somehow port 1500 interactive animations from Director to Flash. I ended uop writing an exporter in JS in Director, using a lot of uncodumented and wrongly documented functionality that I had to dig up from random forum corners of the internet, and implementing a runtime for the needed functionality in Flash, essentially simulating a large part of the directory runtime
12:23:41 <ggVGc>  in it, along with implementations of the 
12:23:44 <ggVGc>  custom interactive elements
12:23:47 <EvanR> ggVGc: now imagine a PHP-like system which just wasnt using PHP as the language, and used haskell. and the culture was to write what appears to be nonsense to a beginner into a file, which is in the document root, and navigate to the page until its not a white screen
12:23:51 <ggVGc> after a few months it actually ran and all the interactive things worked
12:23:53 <ggVGc> I was stoked
12:24:16 <hpc> EvanR: have i got the library for you
12:24:24 <EvanR> lol
12:24:29 <sm> hpc: do tell!
12:24:34 <EvanR> acme-php
12:24:39 <hpc> http://hackage.haskell.org/package/acme-php
12:24:56 <Akii> ertesx: a TYPO3 extension is just crap within crap limited by crap
12:24:59 <dpk-atk> hey, I was wondering if there was any way to have unexported methods visible in REPL
12:25:11 <ertesx> Akii: "limited"?
12:25:30 <sm> does that actually work ? It comes with the well-known "Haskeller's documentation" I see..
12:25:35 <Akii> ertesx: well limited by php, then limited by the cms itself, then limited by the framwork built inside the cms
12:26:17 <EvanR> haskells documentation is at least better than rubyers documentation
12:26:30 <hpc> sm: it's one of those acme packages that's best appreciated in source form
12:26:33 <sm> dpk-atk: :m +*TheModule
12:26:38 <hpc> in fact i consider hackage's documentation a bit of a spoiler
12:26:53 <ertesx> Akii: it's crap‚Ä¶  not even within crap, but more like just flat crap:  a giant pile of global variables and inconsistent‚Ä¶  you know what‚Ä¶  i'm sensing a dangerous fixed point, so i'll stop here =)
12:27:12 <sm> I very much want a PHP-like system for haskell, and if there were docs I would actually spend effort trying it :)
12:27:18 <Akii> ertesx: the worst part of this is that I'm making a living off of it
12:27:19 <EvanR> a miserable little pile of global variables
12:27:43 <Akii> which makes me miserable, according to referential integrity
12:27:45 <hpc> sm: the part where you can mix html and source within a single document?
12:28:02 <hpc> i remember some stuff that does that, but am totally blanking on the name
12:28:13 <Akii> but well, here I am trying to excape just that
12:28:18 <hpc> it's not super great, i would rather use blaze or a templating system
12:28:22 <EvanR> ggVGc: sm: i think my point was that theres language design and also culture at work and its not necessarily inseparable
12:28:23 <sm> yeah, and the actual ease of whipping up web content generally
12:28:40 <sm> "scripting" for web apps
12:28:51 <ggVGc> EvanR: definitely. Javascript could have been fairly okay, but the culture around it is making it a lot worse than it should be
12:29:04 <ggVGc> personally I haven't been in PHP culture much
12:29:09 <ggVGc> somehow I've managed to not have PHP jobs
12:29:26 <ertesx> dwynwen_ddlleyw: btw, that's what i meant by: haskell ruins you for JS and PHP =)
12:29:27 <Akii> too much hipsters within JS
12:29:36 <sm> hpc: there's hsx, which is undocumented but actually kind of great
12:29:53 <Akii> ertesx: I'm at a point where I have difficulties writing PHP code actually
12:30:04 <sm> darcs hub uses it
12:30:24 <Akii> so yes, I fully agree. Learning about Haskell did damage my programming skills in PHP
12:30:29 <hpc> that's actually what i was thinking of
12:30:37 <ertesx> Akii: my last commercial experience with PHP involved reinventing iteratees
12:30:45 <hpc> except hsx2hs which supercedes it
12:30:49 <sm> hsx2hs now, right
12:30:55 <ggVGc> Akii: doesn't haskell have it's fair share of hipster mentality too?>
12:30:56 <EvanR> i can write PHP, but only in a form that infuriates PHP programmers
12:31:02 <charcoal_> Given Cont2 a { runCont2 :: forall r. (a->r)->r }, is it possible to write callCC2 :: ((a -> Cont2 b) -> Cont2 a) -> Cont2 a?
12:31:05 <dwynwen_ddlleyw> I don't want to ruin my JS ability
12:31:11 <dwynwen_ddlleyw> I have spent a month on it already
12:31:16 <hpc> wait no it isn't
12:31:20 <Akii> ggVGc: I think the major hipster wave is yet to come and I'm sort of the beginning
12:31:22 <hpc> i like this better actually
12:31:30 <hpc> the one i was thinking of was weird and undelimited
12:31:30 <EvanR> dwynwen_ddlleyw: youll get better at JS in the process, JS has enough functional features to be not horrible
12:31:35 <Akii> ppl are hitting FP hard right now
12:31:40 <hpc> this runs in a QQ and is much less terrifying
12:32:00 <sm> hpc: I think it can, or it can use a preprocessor
12:32:01 <ggVGc> when I wrote java I refuses to make class hierarchies and used a lot of anonymous classes(since lambdas weren't a thing). It wasn't really accepted
12:32:11 <EvanR> right
12:32:12 <ggVGc> but my code seems to have been about a third in length of comparable other java code
12:32:29 <EvanR> you were that guy
12:32:32 <hpc> ggVGc: but it wasn't enterprise ready
12:32:40 <sm> like http://hub.darcs.net/simon/darcsden/browse/src/DarcsDen/Pages/RepoPages.hs#105
12:32:50 <ertesx> dwynwen_ddlleyw: you will be completely ruined for PHP after learning haskell, but JS could probably work to some degree, at least the newer versions of the language standard ECMA‚Ä¶  if all else fails you do what many of us do: you write haskell and compile it to JS =)
12:32:56 <EvanR> youre the reason they dont hire functional programmers
12:32:58 <EvanR> lol
12:33:06 <hpc> haskell made me a really good javascript programmer
12:33:16 <TheSuperGeek> hello
12:33:38 <hpc> at least until i had to deal with js frameworks that undo all the functional expressiveness
12:33:40 <sm> I do PHP by day and haskell by.. uh day and night.. it's no problem. You actually start to see some of PHP's strengths :)
12:34:17 <ggVGc> EvanR: it wasn't in a team though really. It was for a contract gig, writing a blackberry OS 8 application, which runs Java SE...
12:34:33 <EvanR> by analogy to typing, learning dvorak will not make you unable to type on a qwerty keyboard, but you might hate it
12:34:39 <ggVGc> so I was the only one really in that java code base. But anytime I asked anything about java and showed someone my code, they basically bullied me
12:35:11 <dwynwen_ddlleyw> I like anonymous functions in JS
12:35:27 <EvanR> yes, they are the bomb
12:35:30 <dwynwen_ddlleyw> It's also cool how you can pass them to other functions like regular variables
12:35:35 <ggVGc> there technically aren't non-anonymous functions in JS.. to be strict
12:35:38 <EvanR> you can do a lot with them
12:35:43 <ertesx> i like anonymous functions in ES 6
12:35:56 <ggVGc> I don't use functions. All my programs are type level from now on
12:35:59 <hpc> ggVGc: there are, by... weird quirks
12:36:08 * hackagebot conversion 1.2.1 - Universal converter between values of different types  https://hackage.haskell.org/package/conversion-1.2.1 (NikitaVolkov)
12:36:10 * hackagebot conversion-bytestring 1.0.1 - "Conversion" instances for the "bytestring" library  https://hackage.haskell.org/package/conversion-bytestring-1.0.1 (NikitaVolkov)
12:36:11 <kadoban> Yeah, JS functions are quite nice, the closure stuff turns out super useful once you wrap your head around it.
12:36:12 * hackagebot conversion-text 1.0.1 - "Conversion" instances for the "text" library  https://hackage.haskell.org/package/conversion-text-1.0.1 (NikitaVolkov)
12:36:14 * hackagebot postgresql-binary 0.9 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.9 (NikitaVolkov)
12:36:16 * hackagebot hasql 0.19.10 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.10 (NikitaVolkov)
12:36:29 <ggVGc> kadoban: I heard haskell has decent closures also[5~
12:36:31 <dwynwen_ddlleyw> I don't understand => though
12:36:34 <hpc> function foo(){} is nearly the same as foo = function(){}, but there's some weirdness with where variables are declared and defined
12:36:34 <ertesx> and then you realise that most JS interpreters don't eliminate tail calls‚Ä¶
12:36:39 <EvanR> dwynwen_ddlleyw: functions turn out to be able to reproduce a lot of functionality traditionally considered a special case design pattern in corporate OOP theory
12:36:44 <dwynwen_ddlleyw> Whenever I try to use arrow functions it gives me syntax errors
12:36:50 <ggVGc> hpc: really? I thought they were exactly equivalent
12:37:04 <ertesx> dwynwen_ddlleyw: it doesn't work in most browsers‚Ä¶  it's ES 6 syntax
12:37:05 <ggVGc> dwynwen_ddlleyw: => implies bind
12:37:06 <kadoban> ggVGc: Well, closures in haskell are kind of so good they're boring. Variables don't change, so whatever you refer to is just ‚Ä¶ what it always was.
12:37:15 <ggVGc> it's not just a function with a closure
12:37:35 <hpc> ggVGc: you can test it with function f(){g()}; function g(){} iirc
12:37:38 <kadoban> IOW they barely seem like closures, because closures don't mean as much to me in haskell, they're just ‚Ä¶ functions that work perfectly.
12:38:02 <ggVGc> kadoban: if we removed the environment from functions in haskell, I'm sure you'd notice
12:38:05 <ggVGc> quickly
12:38:17 <hpc> kadoban: that... perfectly describes my problems with learning closures in lisp after haskell
12:38:18 <EvanR> thats a result of lexical scoping
12:38:36 <EvanR> closure is really not something you need to think about
12:38:40 <ggVGc> yeah, fair
12:38:49 <ertesx> "closures" are an implementation detail
12:38:54 <EvanR> if you removed the scope, youd notice ;)
12:38:59 <EvanR> because the code would look different
12:39:03 <hpc> scope is for babies
12:39:05 <hpc> elisp 4 lyf
12:39:21 <kadoban> ggVGc: Right
12:39:55 <Welkin> no scope babies?
12:40:00 <ggVGc> hpc: if emacs was a real editor the script language would have been APL
12:40:02 <ggVGc> or at least forth
12:40:20 <Welkin> o teri bahan di
12:40:26 <ggVGc> one day I'll learn APL
12:40:29 <ggVGc> I sincerely want to use it
12:40:35 <dwynwen_ddlleyw> What is APL?
12:40:45 <ggVGc> dwynwen_ddlleyw: literally "Array programming language"
12:40:48 <ggVGc> but it's great
12:40:49 <ertesx> > let baby scope = "r√§√§√§√§√§√§h!"; for = flip id in scope `for` baby
12:40:50 <lambdabot>  Not in scope: ‚Äòscope‚Äô
12:40:53 <hpc> i hear elisp is going to be the scripting language of microsoft's hosted office
12:41:02 <hpc> they're rebranding it as office 360 noscope
12:41:23 <ggVGc> dwynwen_ddlleyw: it has the little quirk that every function and operaion is a special unicode character thoug
12:41:35 <dwynwen_ddlleyw> I see
12:41:37 <ggVGc> dwynwen_ddlleyw: so back in the day when it was actually used commercially you needed a special keyboard for it
12:42:08 <EvanR> APL predates unicode
12:42:12 <Clint> it sure does
12:42:17 <dwynwen_ddlleyw> This computer stuff sometimes just makes me wonder why
12:42:28 <dwynwen_ddlleyw> It also gives me a bit of a headache
12:42:29 <dwynwen_ddlleyw> >.<
12:42:53 <EvanR> so you could say "unicode has the quirk that it contains APL operators"
12:42:55 <sm> dwynwen_ddlleyw: for a quick intro, you might like http://www.happylearnhaskelltutorial.com ?
12:42:57 <hpc> programming isn't about why, it's about why not!
12:43:04 <Welkin> dwynwen_ddlleyw: computers suck
12:43:04 <hpc> why not marry type safety if you love it so much :P
12:43:31 <EvanR> dwynwen_ddlleyw: youll get used to the headaches
12:43:32 <dwynwen_ddlleyw> What is type safety
12:43:40 <ertesx> > 1 + False
12:43:41 <Welkin> it's called using a condom
12:43:42 <lambdabot>      No instance for (Num Bool) arising from a use of ‚Äò+‚Äô
12:43:42 <lambdabot>      In the expression: 1 + False
12:43:50 <Welkin> so you don't have an "uh-oh"
12:43:51 <ertesx> dwynwen_ddlleyw: that's type-safety
12:43:55 <dwynwen_ddlleyw> Oh
12:43:57 <dwynwen_ddlleyw> Alright
12:44:02 <EvanR> = 1 or True depending on your mood
12:44:09 <ggVGc> dwynwen_ddlleyw: an APL keyboard, http://www.wickensonline.co.uk/apl/union-large.png
12:44:18 <hpc> EvanR: i am personally fond of "1True"
12:44:26 <EvanR> = type error if you like sanity
12:44:41 <ertesx> EvanR: i wanted to avoid instance errors, but i suck today =)
12:44:42 <ggVGc> dwynwen_ddlleyw: game of life in APL, life‚Üê{‚Üë1 ‚çµ‚à®.‚àß3 4=+/,¬Ø1 0 1‚àò.‚äñ¬Ø1 0 1‚àò.‚åΩ‚äÇ‚çµ}
12:44:52 <EvanR> > 1 ++ False
12:44:53 <lambdabot>      Couldn't match expected type ‚Äò[a]‚Äô with actual type ‚ÄòBool‚Äô
12:44:54 <lambdabot>      In the second argument of ‚Äò(++)‚Äô, namely ‚ÄòFalse‚Äô
12:44:54 <lambdabot>      In the expression: 1 ++ False
12:45:03 <hpc> man, most of that doesn't render in my terminal
12:45:11 <sm> ggVGc: seriously ?
12:45:15 <sm> APL is awesome :)
12:45:24 <EvanR> APL has infinite 2D arrays?
12:45:32 <ggVGc> I sincerely think APL is amazing
12:45:34 <ggVGc> and wish to learn it
12:45:38 <ggVGc> I've even set up my vim for it
12:45:43 <ggVGc> but it's a project..
12:45:50 <EvanR> theres K
12:46:02 <sm> and J
12:46:08 <ertesx> ggVGc: that code would be much longer in haskell‚Ä¶  but i'm pretty sure it would still be the same code
12:46:09 <ggVGc> J is just Forth bascially though?
12:46:13 <ggVGc> nothing is as cool as APL
12:46:30 <hpc> the best way i can describe APL is the freakiest of class instances for [] but cranked up to 11
12:46:48 <dwynwen_ddlleyw> In highschool I was made to learn FORTRAN by my... less than tolerable professor
12:46:50 <ggVGc> I seriously think you can write great programs in APL with few bugs. but the barrier of entry and understanding is a bit high
12:46:52 <EvanR> dwynwen_ddlleyw: whatever happens, this channel is one of the best places on freenode to learn programming lore of one form or another
12:46:57 <ertesx> ggVGc: i mean, same paradigm, just much longer identifiers and noisier syntax
12:47:19 <dwynwen_ddlleyw> I think that's when I abandoned all hope with computers
12:47:19 <hpc> EvanR: which makes it one of the best places period
12:47:32 <hpc> with freenode being the programmer's irc network, and irc being the programmer's social network
12:47:48 <dwynwen_ddlleyw> But now my university has me in this "women in code class" with a bunch more intolerable people learning JS and PHP
12:48:12 <EvanR> APL is well typed? or is there only 1 type 
12:48:19 <ertesx> ggVGc: with APL i'd be more worried about the other people who read my code:  my teammates, the newbie in the team, and myself in six months
12:48:29 <dolio> I think J is more like APL than like Forth.
12:48:38 <EvanR> hpc: ... except a lot of what im going to call brogrammers are now on slack
12:48:45 <ggVGc> ertesx: yep, but at least your commercial code base would only be 200 lines long after 5 years of work
12:49:01 <hpc> brogrammers wouldn't know programmer lore if they lived through it themselves
12:49:10 <ertesx> ggVGc: i'd rather reinvent APL's useful patterns in haskell =)
12:49:16 <ggVGc> ertesx: fair
12:49:22 <sm> in haskell, FP goes up to 7. In APL, it goes to 11.
12:49:23 <dolio> Which makes sense, because the same guy worked on both.
12:49:25 <EvanR> dwynwen_ddlleyw: yeah thats becoming common now, women need to program, so give them PHP
12:49:51 <EvanR> women used to use cobol and punchcards so i guess it makes sense
12:49:57 <hpc> if i was just learning to code and someone handed me php, i would have become a lawyer
12:50:06 <ggVGc> my first programmer teacher was a woman... with a loooonng cobol background
12:50:10 <Welkin> lol
12:50:11 <ggVGc> stupid stereotypes
12:50:14 <hpc> fun history: programming used to be a woman's profession
12:50:18 <dwynwen_ddlleyw> It's kind of irritating to be rather honest
12:50:24 <Welkin> the whole idea behind "learning to code to start the next facebook" is just terrible
12:50:31 <hpc> men thought it was beneath them to do data entry, so they'd write the algorithms at an abstract level and hand it off
12:50:36 <dwynwen_ddlleyw> I don't want to program and I'll never use it in a job but they make me
12:50:39 <Welkin> it's the gold rush, and guess who is making the money?
12:50:42 <Welkin> the people selling shovels
12:50:44 <dwynwen_ddlleyw> Because they need enough women in the class
12:50:57 <Welkin> programming is not a necessary skill O.o
12:51:04 <hpc> ^
12:51:06 <ggVGc> dwynwen_ddlleyw: if not for any othr reason, the community in this channel is pretty amazing actually for a programmer group, so that's reason enough to start poking at haskell
12:51:16 <dwynwen_ddlleyw> I am a musician >.<
12:51:18 <Welkin> "you have a vagina, join this class, we need more people with vaginas"
12:51:23 <dwynwen_ddlleyw> ^
12:51:24 <dwynwen_ddlleyw> This
12:51:35 <dwynwen_ddlleyw> This is how I got enrolled in programming classes
12:51:44 <Welkin> entrolled
12:51:50 <EvanR> haskell has some pretty awesome music stuff
12:51:52 <ertesx> dwynwen_ddlleyw: question: do you enjoy programming?
12:51:53 <dwynwen_ddlleyw> But I will bite my tongue and try haskell
12:52:01 <ggVGc> I think learning programming is a great thing. But I think most classes teaching programming actually don't teach programmibg
12:52:04 <dwynwen_ddlleyw> It's fun in my down time
12:52:15 <hpc> dwynwen_ddlleyw: as long as it's fun or useful go for it
12:52:18 <ertesx> dwynwen_ddlleyw: then you should learn haskell during that time
12:52:22 <ggVGc> hangin out in haskell and trying to write a recursive function is programming
12:52:24 <hpc> don't shove it down your own throat just because you have to
12:52:27 <Welkin> I actually hate programming in general...
12:52:28 <dwynwen_ddlleyw> I sort of like going through my book and doing the exercises
12:52:35 <Welkin> and the whole culture surrounding it
12:52:36 <Welkin> and the people
12:52:37 <hpc> down that way lies people who hate the great gatsby because they read it in high school
12:52:51 <ggVGc> Welkin: why do you hate us?
12:52:52 <Welkin> the only exception is haskell and this community
12:52:56 <ggVGc> oh
12:52:58 <EvanR> as a rule you have to hate everything you did in high school
12:53:02 <ggVGc> but haskell is maybe the only real programming?
12:53:05 <ggVGc> it's all definitions!
12:53:25 <ggVGc> EvanR: I played shitloads of music with my friends during breaks(and during lessons..). I didn't hate a single moment of it
12:53:31 <ggVGc> but I also didn't get grades fo rit
12:53:33 <ertesx> dwynwen_ddlleyw: haskell is not just fun for the thing you produce in the end, but for the actual production process itself‚Ä¶  i'm a haskell programmer since around 2007, and i'm still learning new things, and they still manage to fascinate me every time
12:53:33 <dwynwen_ddlleyw> I have this program I wrote in ADA...
12:53:47 <Welkin> dwynwen_ddlleyw: lovelace
12:53:48 <ggVGc> dwynwen_ddlleyw: did you write it in ADA just because you have a vagina>
12:53:58 <dwynwen_ddlleyw> No
12:54:01 <Welkin> dwynwen_ddlleyw: have you tried C+=?
12:54:03 <johnw> ggVGc: inappropriate
12:54:03 <hpc> TIL ada is still in use
12:54:09 <dwynwen_ddlleyw> I did it because it looks like fortran
12:54:15 <ggVGc> sorry, it was meant as a sarcastic statement
12:54:32 <johnw> even if sarcastic, it can make other members of the channel feel uncomfortable
12:54:34 <Welkin> mfukar: is that short for "motherfucker"?
12:54:38 <ggVGc> yeah, sorry
12:54:44 <mfukar> Welkin: no
12:54:47 <Welkin> haha
12:54:49 <johnw> ggVGc: k, thx
12:55:02 <dwynwen_ddlleyw> TIL ADA is named after a woman
12:55:10 <ertesx> can we please return to a clean tone?
12:55:18 <hpc> ada was the first programmer
12:55:27 <ggVGc> EvanR: K ooks interesting, but doesn't tickle my historical nerves as much
12:55:31 <hpc> she wrote algorithms for babbage's analytical engine
12:55:31 <dwynwen_ddlleyw> http://pastebin.com/wf6JuDit
12:55:33 <hpc> which never got built
12:55:33 <EvanR> euclidian algorithm?
12:55:38 <hpc> here's one of her algorithms: https://upload.wikimedia.org/wikipedia/commons/c/cf/Diagram_for_the_computation_of_Bernoulli_numbers.jpg
12:55:44 <dwynwen_ddlleyw> There is the program I wrote
12:55:46 <EvanR> it runs on sticks in the sand
12:55:52 <sinelaw> hey, I need help understanding something in the HMF paper
12:56:03 <johnw> HMF?
12:56:08 <hpc> i believe it was eventually found that her code had a bug in it, but nothing works the first time :D
12:56:36 <ggVGc> dwynwen_ddlleyw: I think you'll do great picking up haskell, and this channel is always helpful, no matter how "stupid" the question might be
12:56:37 <kadoban> Having only one bug doesn't sound too bad, especially without being able to actually run it.
12:56:44 <sinelaw> johnw: http://research.microsoft.com/apps/pubs/default.aspx?id=132621
12:56:45 <hpc> yeah
12:57:02 <hpc> the first list sorting function was written in 1955, the first correct sorting function was written in 1959
12:57:07 <hpc> and that was with machines to run it on
12:57:35 <ertesx> i remember when i wrote pages of haskell code before i first compiled‚Ä¶  it wasn't out of overconfidence, but rather because the first full cabal build would take ages‚Ä¶  amazingly enough it usually worked
12:57:41 <kadoban> Haha, yeah. If you look at the history of binary search, it's pretty hilarious how many wrong implementations you can do.
12:57:42 <ggVGc> dwynwen_ddlleyw: you seem to have a fundamental grasp of functions/procedures, and that's basically the main thing you need. Haskell is all about functions, and most of the syntax is actually simple things that you can ignore in the beginning
12:57:44 <ertesx> haskell-interactive-mode ruined that experience =/
12:58:17 <dwynwen_ddlleyw> I will be honest though
12:58:22 <dwynwen_ddlleyw> I do like ADA
12:58:30 <ggVGc> ada is a pretty decent language
12:58:34 <Welkin> the American Dental Association?
12:58:35 <EvanR> cough
12:58:37 <dwynwen_ddlleyw> And I have several problems I have written out in it
12:58:39 <dolio> You can work for the US government, then.
12:58:52 <kadoban> I like the idea of ada, but I haven't learned it yet, it appeals to me for some reason I'm not sure of.
12:59:06 <dwynwen_ddlleyw> It's like FORTRAN but not as mathy
12:59:08 <EvanR> its super imeprative
12:59:12 <hpc> i would skip it just because it's a pretty basic language
12:59:13 <EvanR> and imperative
12:59:21 <ggVGc> kadoban: maybe the historical nerve, same thing tickling me about APL
12:59:23 <hpc> you'd spend 5 minutes on syntax and already know all the rest
12:59:30 <kadoban> ggVGc: Probably something like that
12:59:31 <jophish> sinelaw: thanks for the link to that paper, it's exactly what I'm looking for!
12:59:51 <hpc> but it's still fairly notable for being without any huge gaping "let's make fun of this language" misfeatures
13:00:01 <dolio> sinelaw: We're not going to be able to help you unless you say what you need help with.
13:00:06 <ggVGc> hpc: which even askell has..
13:00:37 <hpc> haskell's huge gaping misfeatures are at least difficult to make fun of ;)
13:00:42 <EvanR> its now tomorrow UTC
13:00:56 <ertesx> hpc: are you sure?
13:00:59 <hpc> i honestly don't know how i would have handled the module system for instance
13:01:00 <ertesx> > let 2 + 2 = 5 in 2 + 2
13:01:02 <lambdabot>  5
13:01:06 <ggVGc> ahahahaha
13:01:09 <ggVGc> :((((
13:01:09 * hackagebot uu-parsinglib 2.9.1.1 - Fast, online, error-correcting, monadic, applicative, merging, permuting, interleaving, idiomatic parser combinators.  https://hackage.haskell.org/package/uu-parsinglib-2.9.1.1 (DoaitseSwierstra)
13:01:12 <EvanR> no one understands module systems
13:01:16 <jle`> there's a bug in fix, it doesn't fix errors properly
13:01:18 <jle`> > fix error
13:01:20 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:01:21 <EvanR> -- feynman
13:01:25 <ggVGc> hpc: have you used records in haskell by any chance?
13:01:31 <ertesx> hah, nice one
13:01:32 <hpc> ggVGc: i wrote acme-php
13:01:39 <dwynwen_ddlleyw> My favorite online ADA compiler went down though so I can't write ADA anymore
13:01:55 <ertesx> i wrote acme-schoenfinkel
13:01:57 <ggVGc> dwynwen_ddlleyw: why don't you run a local one?
13:02:01 <dwynwen_ddlleyw> I can't
13:02:07 <dwynwen_ddlleyw> I have a chromebook
13:02:07 <kadoban> dwynwen_ddlleyw: That's unfortunate. Aren't there compilers for most platforms though?
13:02:09 <EvanR> ggVGc: theyre not a misfeature, just a very basic feature
13:02:10 <kadoban> Oh
13:02:15 <hpc> ertesx: you're a comic genius, hasslich is funnier than anything i have ever written
13:02:32 <ggVGc> EvanR: I'll have to think a long time about if I agree with that
13:02:32 <ertesx> generalises and renames curry and uncurry to sch√∂n and unsch√∂n (alias h√§sslich)
13:02:34 <ggVGc> but yeah, maybe
13:02:34 <geppettodivacin> You can totally run Linux on a Chromebook.
13:02:41 <ggVGc> but it should have been fixed by now
13:02:42 <ertesx> hpc: not in scope
13:02:51 <geppettodivacin> Linux might not work for the use case, though.
13:02:52 <dwynwen_ddlleyw> But I don't want to mess up my only computer
13:02:53 <EvanR> ggVGc: imagine if you used python or something and you could only throw strings
13:02:55 <dwynwen_ddlleyw> Ever
13:02:57 <ertesx> hpc: interestingly h√§sslich is actually contributed by someone else =)
13:03:04 <EvanR> the exception mechanism isnt a misfeature
13:03:08 <EvanR> just could be better
13:03:26 <geppettodivacin> dwynwen_ddlleyw: Does your university have a server that you can use?
13:03:30 <ggVGc> I have a grea idea
13:03:34 <EvanR> you dont want to remove exceptions (despite many contemporary feelings on exceptions)
13:03:37 <ggVGc> dwynwen_ddlleyw: why don't you write an ada compiler in haskell
13:03:42 <sinelaw> jophish: it is? what are you up to?
13:03:46 <dwynwen_ddlleyw> I go to a music school
13:03:49 <dwynwen_ddlleyw> So probably not
13:04:11 <sinelaw> Peaker: hey
13:04:17 <ertesx> dwynwen_ddlleyw: we have music frameworks in haskell‚Ä¶  you write music in haskell
13:04:28 <hpc> oh man, i forgot about those
13:04:44 <ertesx> dwynwen_ddlleyw: https://hackage.haskell.org/package/Euterpea
13:04:45 <hpc> i still want to try out one of those for audio synth
13:04:51 <ggVGc> I don't think there are any really nice haskell music libraries tbh
13:05:02 <ggVGc> I'm also very much a musician, and I've played around with music in haskell
13:05:04 <dwynwen_ddlleyw> I would rather throw myself out of a window...
13:05:09 <ggVGc> but nothing really fell into my taste for making actual music
13:05:35 <ertesx> ggVGc: was it because of the code aspect?  or was it simply not the way you would have designed it?
13:05:41 <dwynwen_ddlleyw> https://hackage.haskell.org/package/Euterpea-1.1.1/docs/src/Euterpea-Examples-Additive.html#bell1
13:05:45 <EvanR> i wish we didnt need DAWs to make music
13:05:46 <dwynwen_ddlleyw> What is this
13:06:08 <dwynwen_ddlleyw> This hurts my poor little eyes
13:06:19 <ggVGc> ertesx: it's because music is not something you program for me. It's a creative process that's more dynamic than the mindset I have when I create logical rigid constructs as in programming work
13:06:24 <ertesx> dwynwen_ddlleyw: i think there is a nice tutorial on the how and why of euterpea somewhere on youtube
13:06:31 <Peaker> sinelaw: yo
13:06:32 <ggVGc> ertesx: writing music in code is decent for notation
13:06:36 <ggVGc> but not for composition
13:06:37 <ggVGc> imo
13:06:46 <EvanR> ggVGc: i think theres potential for synthesis here... programming should be more like that 
13:07:03 <ggVGc> EvanR: this is one of the reasons I want that embeddable functional language.
13:07:06 <ertesx> ggVGc: i tend to split music into two major groups:  synthetic and "natural" (for lack of a better word)
13:07:13 <ggVGc> to build a more creative musci environment
13:07:31 <ertesx> ggVGc: synthetic music i can totally see myself "writing" as in "coding"
13:07:49 <ggVGc> ertesx: I think this is more personal for me though. Everyone has their way of workign on their art. I can't do it in the programming mindset at all. It doesn't channel my creativity at all
13:07:53 <ggVGc> it shuts it down rather
13:08:06 <ggVGc> some people love trackers. Those people I think would do great making music in haskell
13:08:08 <ertesx> but at the same time i'm a jazz bass player, and i can't imagine doing jazz on my computer at all
13:08:25 <Welkin> you can do anything on your computer
13:08:29 <Welkin> hook up your instrument
13:08:29 <EvanR> theres a huge UI gap
13:08:35 <jle`> it's hard for me to imagine producing music or mixing/synthesizing with a text editor
13:08:36 <ertesx> (i can't even imagine doing it alone to begin with)
13:08:51 <jle`> there's a lot of visual cues that aid you in the process
13:09:00 <jle`> vertical and horizontal alignment is a big one
13:09:16 <ggVGc> for me the randomness is missibg
13:09:21 <ertesx> Welkin: if i hook up my bass guitar in a way that reproduces the experience of playing bass, i'm not gaining anything except the ability to record
13:09:21 <ggVGc> and the possibility of good mistakes
13:09:27 <EvanR> this is one place where text editing looks very inappropriate but really... 
13:09:31 <ggVGc> all my best melodies and hooks have come from accidents
13:09:32 <EvanR> what IS it appropriate...
13:09:33 <EvanR> when*
13:09:36 <jle`> but manipulating plugins might be nicer in  a programming environment
13:10:50 <ggVGc> jle`: my current haskell project is actually a quirky midi sequencer specifically built to be used with 3 ableton launchpads. I intend to make the routing of it programmable in text, while the main creative and arrangement interface is on the hardware as LEDs
13:10:52 <ertesx> my point is:  regardless of whether it's haskell or not (there are non-haskell things like csound and supercollider), these "music programming languages" are great for what you would typically do with them
13:11:01 <ggVGc> I@ve already started using it so make some music
13:11:08 <ertesx> but jazz and classic rock aren't among them =)
13:11:16 <ggVGc> but I need to figure out the generalisations of the routings before I can make that programmable
13:12:03 <ggVGc> ertesx: yeah, for sound generation programming is great I reckon. For composition and experimentation with arrangement and melodic content, not so mucjh
13:12:28 <ggVGc> the issue for me is when programmign I figure out what I want, then I write it. With music I fiddle some things, listen, feel, and see where it goes
13:12:32 <ggVGc> I can't do that with a programming language
13:12:32 <dwynwen_ddlleyw> I like how you guys make Haskell sound 
13:12:51 <ertesx> ggVGc: it's really good for that‚Ä¶  in a sense you can get your usual "rapid prototyping" experience
13:13:24 <ertesx> ggVGc: when creating music you usually write stuff into the interpreter‚Ä¶  i think i've seen a live performance using haskell at some point
13:13:24 <Rembane> We need a fiddling module in Haskell!
13:13:30 <ertesx> s/haskell/haskore/
13:13:47 <EvanR> Rembane: agreed
13:13:53 <Rembane> ertesx, ggVGc: This? http://toplap.org/tidal/
13:14:03 <EvanR> i want to see haskell run in real time with a visualization
13:14:09 <EvanR> of the data structures
13:14:33 <Rembane> EvanR: That shouldn't be too hard...
13:14:37 <EvanR> heh
13:14:39 <ggVGc> ertesx: sure, but my mental wiring doesn't resonate with that kind of workflow. as I said, I think it's very personal. I know it's theoretically useful and is an interesting paradigm of music creation. But it doesn't work for me
13:14:52 <ggVGc> the less visual feedback I have, the better
13:15:01 <ggVGc> and if I need to write stuff, I get locked into the rigidness
13:15:07 <ggVGc> and my creative flow stops
13:15:12 <ertesx> Rembane: not sure, i believe it was haskore, but i could be wrong‚Ä¶  it was a few years ago
13:15:26 <EvanR> you need one or more AI band mates
13:15:27 <ggVGc> I've looked at almost everythign I think. tidal is interesting
13:15:30 <ertesx> ggVGc: yeah, it's definitely not for everyone
13:15:33 <ggVGc> I liked ChuCK also
13:16:00 <Rembane> ertesx: Cool!
13:16:16 <ggVGc> ertesx: I think the tracker comparison is good. I could never get into using trackers, and I tried a lot. BUt some people love it and make amazing stuff with them. I think those people do great with creative programming
13:16:20 <ggVGc> and i'm on the other side
13:17:19 <dwynwen_ddlleyw> What's a tracker?
13:17:37 <ggVGc> ertesx: also, I'm much more a traditional musician, been playing drums and piano all my life and dabbled in various flutes, horns and other percussive instruments over the years. I always found it hard to go into "writing" mode, rather than improvisation and musician mode
13:17:48 <EvanR> ggVGc: i never had luck with trackers... though sunvox is pretty cool for making instruments, and has an easier tracker interface
13:17:54 <Peaker> Why does GHC not use HMF for higher-ranked types? GHC's higher-ranked types suck
13:18:01 <ggVGc> so the whole music with a compuer thing has always been a struggle, even though I live electronic sound work
13:18:30 <ggVGc> dwynwen_ddlleyw: a tracker is a vertical sequencer, rather than a hoirizontal one like Cubase for example
13:18:43 <Cale> Peaker: What's wrong with GHC's higher ranked types?
13:18:52 <dwynwen_ddlleyw> I don't know what that is either but I won't ask you to explain it
13:18:59 <ggVGc> dwynwen_ddlleyw:  and you enter numbers for each note with your keyboard, and various effects etc. All old video game music is made with trackers
13:19:05 <ertesx> ggVGc: yeah, i understand that‚Ä¶  that's why i split music into those two groups
13:19:11 <Rembane> And the music for Deus Ex!
13:19:19 <EvanR> ggVGc: amiga yeah but not consoles
13:19:47 <EvanR> (except jaguar which was basically from the amiga/c64/atari camp)
13:20:05 <ggVGc> dwynwen_ddlleyw: https://youtu.be/N2s04YYO0Wg?t=581
13:20:09 <ggVGc> that's a tracker
13:20:16 <ggVGc> each vertical line is a track of the song
13:20:18 <ggVGc> each number is a note
13:21:34 <Peaker> Cale: the ($) hack (which breaks if I even use lens-style & instead! or if I want to use (.))
13:21:38 <ertesx> ggVGc: at one point i tried to reproduce what i did with my bass synthetically‚Ä¶  it's impossible‚Ä¶  all the intentional glitches and harmonics are missing
13:21:46 <Cale> Peaker: Oh, yeah, those hacks ought to be removed
13:21:59 <ggVGc> ertesx: right, which is the randomness I was talking about, that is crucial for my musical creativity
13:22:01 <Peaker> Cale: for that, the higher-ranked support must cease to suck :)
13:22:08 <ggVGc> accidentally touching some button or slider or note etc.
13:22:13 <Cale> Peaker: Not really...
13:22:25 <ertesx> ggVGc: *but* i can make synthetic music, as long as i never mix up the two groups of music
13:22:27 <Rembane> Un-quantize generated music.
13:22:36 <Peaker> Cale: in HMF: runST . forever $ do   would type-check.  In GHC it doesn't
13:22:41 <Cale> Peaker: You could just say "don't use ($) with higher ranked functions"
13:22:49 <dwynwen_ddlleyw> I am a cellist 
13:23:01 <dwynwen_ddlleyw> So producing artificial music seems unnatural >.<
13:23:06 <ggVGc> ertesx: the best kick drum I ever had in a song came about because I accidentally hit my computer while the sound was routed wrong and I had record monitoring on, so it recorded from my internal laptop mic. I thought it sounded amazing, so I hit record and banged my laptop a bit
13:23:21 <ggVGc> ertesx: best, deepest and most full kick drum sample I've ever had
13:23:34 <Cale> Peaker: which is how things used to be, and I thought it was fine :P
13:23:40 <Peaker> Cale: that is very annoying, it basically makes abstractions unusable
13:23:41 <ggVGc> that would never appen if I programmer my music
13:24:20 <ertesx> dwynwen_ddlleyw: it *is* unnatural
13:24:27 <dwynwen_ddlleyw> Burn it
13:24:28 <Cale> Peaker: Well, it's a little annoying, but for the most part it's a syntactical inconvenience rather than something which really gets in the way
13:24:40 <ertesx> dwynwen_ddlleyw: but that doesn't make it *not music* =)
13:24:46 <ggVGc> the point of electronic music is to be unnatural
13:24:48 <ggVGc> that's why we love it
13:24:51 <dwynwen_ddlleyw> I know that 
13:24:54 <dwynwen_ddlleyw> :P
13:25:17 <ggVGc> dwynwen_ddlleyw: also, cello with digital transformations and effects is great
13:25:27 <dwynwen_ddlleyw> There is one exception to my artificial music dislike 
13:25:34 <dwynwen_ddlleyw> That one AI that plays the piano 
13:25:44 <Peaker> Cale: well, HMF seems to do much better, so my question is why GHC prefers the much-more-complex algorithm instead? I assume it's because of other type-sys features?
13:25:46 <dwynwen_ddlleyw> I like that one 
13:26:13 <ertesx> ggVGc: i like your way of thinking =)
13:26:34 <Peaker> Cale: http://research.microsoft.com/pubs/64591/tr-2007-118.pdf
13:27:44 <Cale> Peaker: Well, the main thing is type class and type equality constraints...
13:28:14 <Cale> I don't know whether or not it's easy to extend HMF to handle those
13:28:25 <ertesx> isn't this weird in a sense?  we use and enjoy one of the most formal languages on the market‚Ä¶  yet at the same time we improvise music with intentional glitches‚Ä¶  in one performance victor wooten had a string break, and he kept playing‚Ä¶  he made the broken string part of the performance
13:28:26 <Peaker> Cale: Type-class constraints sound orthogonal. Fundeps/type equalities -- no idea :)
13:28:38 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf
13:28:55 <Cale> has a lot of discussion involving design decisions
13:29:05 <ggVGc> ertesx: the nice kick comes in at 0:18, https://soundcloud.com/inferred/fillra
13:29:08 <ggVGc> the track is not very good..
13:29:10 <ggVGc> but yeah
13:29:40 <Cale> Though hmm, it doesn't look like it has much about higher rank types
13:29:45 <sinelaw> is there no foldA?
13:29:52 <benzrf> :t traverse -- sinelaw
13:29:53 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:29:57 <benzrf> oh wait, that's mapA
13:30:07 <Peaker> :t foldM
13:30:09 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
13:30:12 <flummz> hi guys, i have a function composition problem with specified signatures, maybe someone could give me a hint:
13:30:20 <ggVGc> ertesx: the atmpspheric stuff in the background is how the whole song came about. I was sitting outside our class rooms and this girl was shaking a yoghurt. So I recorded it and said I would make it into a song. SO that's what that sample is. Stretched with effects over the whole song as background ambience
13:30:25 <johnw> traverse is not mapA
13:30:27 <flummz> http://codepad.org/LLaIHTEM
13:30:32 <EvanR> ertesx: thats great, but classical music, pop music, and computer music are all expressions of a math "pure form" of music in some way which seems very haskell
13:30:38 <johnw> traverse would be "sequenceA . mapA", if anything
13:30:39 <EvanR> i think
13:30:50 <johnw> oh, wait
13:30:54 <johnw> n/m, I'm being dumb, it is mapA
13:31:23 <ertesx> ggVGc: so you do make synth music =)
13:31:40 <EvanR> shaking a yoghurt, is this some swedish thing
13:31:53 <sinelaw> :t mapA
13:31:54 <lambdabot>     Not in scope: ‚ÄòmapA‚Äô
13:31:55 <lambdabot>     Perhaps you meant one of these:
13:31:55 <lambdabot>       ‚ÄòmapM‚Äô (imported from Data.Traversable),
13:32:05 <johnw> well, what mapA would be
13:32:10 <ertesx> ggVGc: just not with code, i guess
13:32:12 <johnw> (mapM with an applicative constraint)
13:32:24 <Peaker> :src foldM
13:32:30 <ertesx> : traverse
13:32:36 <Peaker> @src foldM
13:32:36 <lambdabot> foldM _ a []     = return a
13:32:36 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
13:32:49 <sinelaw> was just about to question whether foldA can exist
13:32:58 <Peaker> each effect depends on the result of the previous effect, so I don't think it can
13:33:02 <sinelaw> right
13:33:12 <ggVGc> ertesx: of course. But I can't program it. I just record everything "live" for a long time, sometimes up to an hour. Then I cut pieces I liked, sometimes re-record them, then I edit some mistakes or adjust things to see how it sounds, and usually add some nice samples I've gotten in contact with in that near timeframe
13:33:20 <ggVGc> then play with effects and mix it until it feels nice
13:33:46 <ertesx> EvanR: i see what you mean, and i'm inclined to agree, but from a neuro standpoint i'm not sure if that's really accurate
13:34:38 <ertesx> when i listen to music, i don't usually see fourier-transformed wave functions‚Ä¶  i feel emotions
13:35:27 <EvanR> ertesx: no... not fourier at all
13:35:41 <EvanR> theres an algebra of abstract notes
13:35:44 <fr33domlover> Q: How can I `stack install` a package with a modified datadir? I want the executable to look for data files in ./data, not in /home/joe/.stack/.../.../.../.../.../data
13:36:04 <ggVGc> wen I listen to music I've made, I recall the feelings and thoughts of when I created it,because that all added up into the expression that became the song. I don't know how I would capture that if I was programming my music in code
13:36:13 <ggVGc> I'd be too focused on my structure of my song
13:36:17 <ggVGc> rather than how it felt/sounded
13:37:02 <ggVGc> EvanR: the way I see it, the musical end result is often mathematically matching some common motdel. But the process leading up to it is very unique for each peice of music. 
13:37:08 <ggVGc> and that's what matters for me when I make music
13:37:29 <EvanR> yeah im only thinking of some music
13:37:33 <ggVGc> I never want to make the music that I can figure out beforehand
13:37:45 <EvanR> but i see this not just in western music
13:38:07 <ggVGc> fundamentally humans like certain things, and that's how our music ends up being
13:38:18 <Peaker> fr33domlover: https://github.com/commercialhaskell/stack/issues/548 :-(
13:38:18 <ggVGc> probably very affected by nature
13:38:43 <EvanR> i havent even thought about why people make this kind of music, interesting ;)
13:39:11 <EvanR> fractals or something
13:39:13 <ggVGc> once I was walking around in south mexico and I heard a bird singing, and I felt "man that's a chord". SO I took up my flute and played the notes, and sure enough, it was D minor, my favourite chord
13:39:33 <ggVGc> I think we're pretty conditioned musically by thousands of years in nature
13:39:37 <ggVGc> ehh, hundreds of thousands
13:40:12 <fr33domlover> Peaker, that's a `stack test` issue though
13:40:19 <fr33domlover> I just want to `stack install`
13:40:26 <EvanR> are we conditioned for "tens of thousands" of years to do math?
13:40:39 <EvanR> or hundreds
13:40:49 <Peaker> fr33domlover: IME it doesn't support it in 'stack install' either
13:40:55 <ertesx> ggVGc: a few weeks ago i tried to make music in rosegarden, an open source synthesizer‚Ä¶  here's the result: https://archive.org/download/ertes-midi/room-groove.ogg
13:41:16 <ertesx> ggVGc: i don't like it‚Ä¶  it *unintentionally* sounds like old video game music
13:41:28 <ertesx> it's MIDI, so it's not that surprising, but still
13:41:30 <fr33domlover> Peaker, `stack build` does put the data files in the datadir
13:41:42 <fr33domlover> the problem is, i want to specify a different datadir path
13:41:47 <fr33domlover> in place of the default
13:42:23 <ggVGc> EvanR: probably, but not in the same way I mean with music. I think sound is such a fundamental thing to all life. It's the essence of communication, and for signaling of danger or happiness etc. And it's deeply connected with dance, which is also a fundamental biological thing with all mammals. SO it's not surprising to me that we prefer certain rhythms, certain repetitions, certain lengths of repetition
13:42:33 <ggVGc> EvanR: and that those often match the sounds in nature, such as bird song
13:42:40 <Peaker> fr33domlover: I mean it puts the data files in the sandbox
13:43:03 <sinelaw> Peaker: you can have a (kind of) foldA if it's also traversable
13:43:26 <fr33domlover> ah yes, even with `stack install` datadir is the same
13:43:32 <fr33domlover> all it does it copy binaries
13:43:48 <ggVGc> ertesx: haham, this is funky. BUt it needs some better sounds and it'll be sweet funky stuff
13:43:56 <ertesx> ggVGc: doing it *should* have felt more natural than code, but it really just felt like: "i could be done faster with this crap, if i'd do it in code, and the result would turn out exactly the same"
13:44:04 <EvanR> #haskell-music
13:44:11 <Peaker> fr33domlover: https://github.com/commercialhaskell/stack/issues/848
13:44:28 <Peaker> fr33domlover: I guess you're supposed to give a --prefix manually
13:44:53 <ggVGc> ertesx: I can tell you've been playing live bass though ;)
13:45:16 <ertesx> ggVGc: thanks, and yeah, we're getting off topic a bit =)
13:47:39 <websocked> Hi folks, I am trying to use the https://hackage.haskell.org/package/websockets package, but the connection keeps dying for no apparent reason.
13:48:00 <websocked> Are there alternative packages? Are there tricks to work around this?
13:48:15 <websocked> Does anyone have experience with this package in general?
13:52:24 <EvanR> ggVGc: the birds around here cant sing for shit ;)
13:53:57 <fr33domlover> ah, I found a way
13:54:07 <dwynwen_ddlleyw> https://hackage.haskell.org/package/websockets-0.9.6.1/docs/src/Network-WebSockets-Connection.html#receiveDataMessage
13:54:08 <fr33domlover> datadir can be overriden using an env variable
13:54:11 <fr33domlover> good enough for mw
13:54:12 <dwynwen_ddlleyw> This code looks nice
13:54:21 <websocked> Okay, different question then. When using the websockets library, is it necessary to use sendPing to keep it alive?
13:55:30 <c_wraith> websocked, depends on innumerable factors. but it can't hurt. 
13:56:01 <c_wraith> .. unless you make the server flood itself, I guess. 
13:56:11 * hackagebot git-annex 6.20160412 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160412 (JoeyHess)
13:57:11 <spoing> hello! does Data.Vector have anything like the (:) from list?
13:57:26 <EvanR> theres <>
13:57:36 <EvanR> which is more like ++ from list
13:57:41 <c_wraith> spoing, not in terms of asymptotics 
13:57:47 <Gurkenglas> Does anything allow you to eta-reduce case matches?
13:58:09 <Gurkenglas> (It probably wouldn't have any of the inlining performance gains, but would still look nicely pointfree)
13:58:11 <c_wraith> Gurkenglas, the lambdacase extension 
13:58:41 <Gurkenglas> Like, replacing "Foo bar -> baz bar" with "Foo -> baz"
13:58:53 <c_wraith> Oh. nope. 
13:59:53 <spoing> ok, so if I want to build a vector of predefined elements?
14:00:07 <spoing> something like 1 : 2 : 3 : []
14:00:09 <Welkin> spoing: Vector.fromList
14:00:17 <spoing> okay, yeah
14:00:36 <EvanR> i wonder if its possible to do the trick where a Vector was preallocated with space before and (:) would mutate the unused section before and a new slice would be created over the larger region
14:00:47 <EvanR> spoing: fromList
14:01:17 <ertesx> spoing: if you can create it in one go
14:01:26 <spoing> i can! :) thanks.
14:01:45 <c_wraith> EvanR, one of the vector construction functions does the opposite.. it gives you the existing prefix to build the next element. 
14:02:00 <ertesx> c_wraith: construct*
14:02:00 <c_wraith> EvanR, just throw a reverse in.. 
14:02:13 <spoing> is vector worth using as a general replacement for lists? or are there use cases where a list would be just as good?
14:02:19 <Welkin> no
14:02:24 <Welkin> vector is an array
14:02:41 <Welkin> it is meant for data that does not change, but you need random access to it
14:02:42 <EvanR> c_wraith: its implemented by mutating space?
14:02:56 <Welkin> lists are for data that gets built up over time, or that you only need to read sequentially
14:03:14 <ertesx> spoing: it depends on your use case‚Ä¶  due to its fusing API you can get very close to doing list-like things, but ultimately it doesn't replace lists
14:03:28 <c_wraith> EvanR, constructN takes O(n) time, so it has to use mutation. 
14:03:57 <EvanR> er then it sounds like a copy
14:04:03 <ertesx> spoing: most notably in general vectors are strict in the structure, so you need to rely on fusion to get good space behaviour, if you compose vector transforms
14:04:46 <spoing> okay. i'm building a small game to get a more solid feel for this language (only using java at school), and i don't know much about different data structures yet, but I read somewhere that vectors were like more efficient lists
14:04:47 <c_wraith> EvanR, look at constructN. if I understood what you wanted, that's it, except prefix oriented instead of suffix oriented. 
14:04:52 <ertesx> EvanR: it's basically Mutable.generateM with unsafeFreeze
14:05:23 <spoing> but then I guess I'd rather keep the entities in my game state in a list rather than a vector? since the number of entities keep changing?
14:05:28 <c_wraith> EvanR, Oh. constructrN is exactly what I think you want. 
14:05:34 <ertesx> spoing: that's a misrepresentation‚Ä¶  at least in haskell
14:05:42 <EvanR> i was thinking more along the lines that you have "half constructed" vectors floating around normally and sometimes a snoc or cons can secretly mutate space that was already there
14:06:18 <ertesx> spoing: but note that haskell lists are different in nature from most other languages
14:06:24 <c_wraith> EvanR, yes, that's what the constructN functions do. except you can't do it piecemeal. it all has to be done up front. 
14:06:26 <EvanR> i see these construction functions are optimized which is cool but 
14:06:29 <EvanR> right
14:06:43 <EvanR> you cant exit the construction and resume later
14:07:49 <ertesx> EvanR: you can probably get some of that behaviour by using 'modify' and 'grow' (?)
14:08:05 <ertesx> but i'm pretty sure that's going to be horribly inefficient
14:08:06 <EvanR> interesting
14:08:19 <spoing> okay, thanks :)
14:08:24 <EvanR> whats grow
14:08:32 <c_wraith> you just need a monadic variant, then you can throw it inside a continuation monad. :) 
14:09:07 <ertesx> c_wraith: rather a Free
14:09:19 <c_wraith> it'd do the job too. 
14:09:29 <ertesx> EvanR: https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Generic-Mutable.html#g:8
14:09:43 <EvanR> i heard that old perl used this trick to optimize prepending
14:09:48 <c_wraith> ok. just need constructrNM to be added :) 
14:09:57 <EvanR> i guess vector wanted to keep things simple though
14:10:26 <spoing> one more question. what about Text vs String? can I use Text wherever I'd normally use a String? (for printing info to the game screen, mostly)
14:10:29 <c_wraith> well, you could hack it in, with vector's internals. 
14:10:35 <EvanR> (uhg i can barely read the type sigs for mutable vectors)
14:10:48 <ertesx> Free/FreeT would work much better than ContT in this case
14:10:56 <c_wraith> since the vector representation is a slice-based representation. 
14:11:47 <c_wraith> but it'd be really unsafe without some sort of cleverness about length tracking. 
14:12:32 <EvanR> spoing: Text is good for a lot of text, String is a list of characters so its almost the same question as before
14:12:54 <EvanR> think of [a] has a stack, and Vector / Text as an array
14:14:32 <EvanR> we would probably be better off replacing String with Text and renaming it to String but...
14:15:17 <EvanR> theres this "what it looks like when you show beginners something with lambdabot" effect
14:15:48 <ertesx> almost‚Ä¶  Text does have other complexities than Vector due to its encoding
14:15:55 <EvanR> yes
14:16:14 <spoing> ok, so if I understood correctly, I'll use Text wherever I have a lot of static text, as in my use case? (please excuse my stupidity, I've never looked at datatypes and performance before)
14:16:19 <EvanR> but you can think of it as an array of unicode characters
14:16:41 <ertesx> spoing: usually you'd use Text for Text and String when you have to deal with APIs that use String
14:16:51 <EvanR> spoing: its good for text processing
14:16:53 <ertesx> spoing: if you need lazy text, there is Data.Text.Lazy as well
14:17:18 <EvanR> you can also use Text for APIs that use String wrong
14:17:28 <EvanR> by unpacking at the last possible moment
14:17:44 <c_wraith> does vector have accursedUnutterablePerformIO? 
14:17:45 <ertesx> spoing: in the usually rare case that you do sequential char-by-char processing of text in such a way that you could benefit from rapid GC, then String is the better option
14:17:50 <ertesx> and it's just as rare as it sounds =)
14:18:19 <spoing> okay :) I'll stick with Text over String then :)
14:18:34 <ggVGc> speaking of language warts haskell has...
14:18:37 <ggVGc> [Char] eh
14:18:46 <ggVGc> (turns out it wasn't such a great idea)
14:18:55 <ertesx> c_wraith: you mean like the unsafe functions in Data.Vector.Storable?
14:18:57 <EvanR> it good for party tricks
14:19:35 <c_wraith> ertesx, I mean like the function of that exact name in bytestring's internal modules. 
14:19:49 <geekosaur> well, the main reason Text doesn't replace String is there are pathological cases (if something along the line of a stream that does per-character processing can't be fused, it turns unto unpack->slow [Char] processing->pack and can end up slower than if you'd just used String)
14:19:52 <EvanR> c_wraith: i think it might be deprecated
14:20:18 <spoing> well, thanks a lot guys!
14:20:21 <ertesx> > filterM (pure [False ..]) "party"
14:20:23 <lambdabot>  ["","y","t","ty","r","ry","rt","rty","a","ay","at","aty","ar","ary","art","a...
14:21:06 <c_wraith> I still claim the existence of the showList hack should have proven [Char] was a bad idea before haskell made it to the '98 spec 
14:21:48 <EvanR> you could make [Char] an instance of IsString
14:21:57 <EvanR> party tricks will be preserved
14:22:06 <ggVGc> would it be so bad to just reimplement the String API over Text, replace String with Text by reaming it, and force use of toList when you really want the String as a list
14:22:11 <ggVGc> how much would it really break?
14:22:25 <EvanR> probably everything
14:22:32 <ggVGc> might be worth it??
14:22:47 <EvanR> haha
14:22:49 <c_wraith> seriously, the amount of contortion necessary to make show "work" for String really should have hinted it was a bad choice. 
14:23:29 <ggVGc> why is it that essentially every language ever failed at implementing a decent stadndard string type
14:23:48 <c_wraith> because there's no such thing. 
14:24:03 <EvanR> javascript
14:24:07 <ggVGc> alright, scerw it then. who deals with text anyway
14:24:14 <c_wraith> I think rust got it as right as possible with its 5 or so standard string types. 
14:24:29 <ggVGc> C did a good job eh!
14:24:30 <Rembane> The string type in Python 3 is quite useful
14:24:35 <EvanR> ...
14:24:36 <ggVGc> "ANything ending with a null byte"
14:24:39 <ggVGc> fair
14:24:43 <Rembane> Or maybe the three string types... hm...
14:25:01 <geekosaur> perl 6's Str is not terrible (and there's ways to get at various more-"raw" forms if needed)
14:25:28 <geekosaur> ..sadly it says something about the mess that is "strings" that such things as multiple string types are still neede
14:25:28 <EvanR> how about C++'s 100 at least string libraries
14:25:34 <c_wraith> a lot of the issue is that things people think are obviously strings mean different things. 
14:26:13 <c_wraith> are http headers strings? are file paths? 
14:26:23 <EvanR> no, no
14:26:39 <dwynwen_ddlleyw> yes yes
14:26:42 <ggVGc> so, what you're sayibg is that after about 70 years of compuer language stuff we've got one 6th iteration of a language that has an okay string type and one language that has some good ones but has 5 of them?
14:26:54 <EvanR> Text is pretty good
14:26:58 <EvanR> its just not called String
14:27:04 <ertesx> haskell has its fair share of string libraries, too
14:27:14 <ertesx> what it doesn't have is "byte string by default"
14:27:15 <ggVGc> EvanR: my point was about the standard string type of the language beig not crap
14:27:22 <ggVGc> EvanR: i.e the one that you have nice syntax for
14:27:29 <c_wraith> ggVGc, it's like asking why there isn't just a number type. "number" can mean too many different things. 
14:27:31 <EvanR> theres nice syntax for Text
14:27:44 <ggVGc> but if I do let foo = "hello" I don't get text
14:27:53 <EvanR> i do!
14:28:06 <ggVGc> EvanR: only if you know to remember to enable it
14:28:22 <EvanR> i have almost a page of standard pragmas and imports to paste in ;)
14:28:23 <ggVGc> which makes every new user of the language end up using the crap one
14:28:28 <ertesx> we have base, bytestring, containers, text, utf8-string, vector, ‚Ä¶
14:28:46 <EvanR> ggVGc: well... yes back to the "what a beginner thinks and does" effect
14:29:08 <EvanR> which might be solved by having a beginner version of the language!
14:29:20 <ggVGc> I just tink it's reasonable that when using a string in a programming language as a beginner, it should be reasonable to use that string type
14:29:25 <ggVGc> not "always avoid it"
14:29:28 <EvanR> ertesx: IsAscii
14:29:45 <EvanR> ggVGc: [Char] does work... 
14:29:52 <ggVGc> but it's never the correct answe
14:29:52 <EvanR> sometimes ;)
14:30:21 <ertesx> we even have special libraries for concatenating strings‚Ä¶  and not as a joke‚Ä¶
14:30:23 <ggVGc> either way, I should have been sleeping hours ago
14:30:25 <ggVGc> thanks guys
14:30:27 <ggVGc> :(((
14:30:30 <c_wraith> ggVGc, String is fine most of the time. unless you need raw performance for some reason. most programs don't. 
14:30:56 <ggVGc> c_wraith: but what do you gain from using [Char] rather than Text even if you don't need performence
14:31:03 <EvanR> c_wraith: actually one of my first config file programs i wrote in haskell regularly blew up using String
14:31:14 <EvanR> stack overflow
14:31:29 <EvanR> though i was probably procesing the string in a dumb way
14:31:47 <ggVGc> what? didn't you write perfect haskell from the start?
14:31:58 <EvanR> no i ran into all the problems you described
14:32:19 <c_wraith> ggVGc, I'm not saying it should be the default. I'm just saying that "never use the default" is bad advice. most of the time, it doesn't hurt anything. 
14:32:30 <ggVGc> to be fair, look at what happened to python when they tried fixing their string type...
14:32:42 <EvanR> id rather not honestly ;)
14:32:45 <sm> look at what happened to php
14:32:56 <ggVGc> EvanR: do you know a single person using python 3 for anything?
14:33:01 <ggVGc> everyone just stayed on 2.x
14:33:08 <ggVGc> because it was too much breakage
14:33:23 <EvanR> honestly i have no idea what happened when python3 came out
14:33:28 <ggVGc> nothing
14:33:32 <flummz>  and because python kiddies tend to be not very bright to begin with
14:33:32 <EvanR> i had left python land by that point
14:33:34 <ggVGc> that's the issue
14:33:48 <ertesx> one thing that really bothers me about our mentality in general is that we don't seem to associate RAM with a cost
14:34:09 <ggVGc> EvanR: my point is, there's a high likelyhood that if haskell fixed string to be text, there would just end up beign tweo haskell, where no one uses the new better one
14:34:21 <EvanR> right
14:34:35 <EvanR> so things are stuck the way they are and thats that, until the next language like haskell comes along
14:34:40 <ertesx> FilePath = String  -- this is crazy‚Ä¶  it's basically wasted RAM, and RAM has a cost, even if we like to deny it
14:34:42 <ggVGc> when is that?
14:34:44 <ggVGc> are you making it?
14:34:49 <EvanR> 2088 maybe
14:34:53 <ggVGc> dam
14:35:08 <ggVGc> really hope I do not need to care about haskell or proramming at all by then
14:36:05 <EvanR> ertesx: FilePath = Text this is crazy, how to interpret anything in the file system as unicode text...
14:36:30 <geekosaur> actually Text is correct for Windows and arguably OS X
14:36:44 <Rembane> And FilePath = ByteString would be insane in some context too...
14:36:45 <geekosaur> ByteString is correct for most Unixlikes
14:37:03 <ggVGc> FIlePath = Int?
14:37:20 <EvanR> FilePath = PlatonicSlashDelimitedForm
14:37:35 * geekosaur waits fort the resurgence of openvms :p
14:38:08 <ggVGc> Rembane: in which contexts is it insane?
14:38:19 <ggVGc> surely bytes can represent any file path
14:38:27 <EvanR> bytes can represent anything
14:38:30 <EvanR> ANYTHING
14:38:32 <Rembane> ggVGc: I have no clue. I was hoping somebody would mention one.
14:38:36 <geekosaur> ByteString can also represent things that are illegal on Windows
14:38:56 <geekosaur> and on OS X which wants normalized UTF8
14:39:15 <EvanR> this is specific to that one filesystem on osx?
14:39:32 <EvanR> it does support others
14:39:37 <ggVGc> alright here we go again, data FilePath = WinPath Text | NixPath ByteString | EvanOS PlatonicSlashDelimitedForm
14:40:05 <geekosaur> it "supports" others. installing on anything but case independent hfs+ is not supported, for example
14:40:07 <dolio> People do associate RAM with a cost. Frequently they overweight its cost relative to other costs. So they write all their code in C, and it has buffer overflows and whatnot.
14:40:11 <ggVGc> OSXPath SpecialCaseByteString
14:40:18 <dolio> Which costs people in general way more than buying more RAM.
14:40:30 <EvanR> FilePaths are propositions whose truth values come from True | False | FileNotFound
14:41:05 <ggVGc> FilePath = undefined -- don't do it
14:41:06 <dwynwen_ddlleyw> How do I tell how much memory my program uses?
14:41:13 <EvanR> geekosaur: i mean, you can read from a usb thumbdrive without issues
14:41:20 <flummz> people write C++ for speed, not for manual memory management
14:41:23 <geekosaur> also, sadly, system utilities assume that HFS+'s rules hold everywhere (this is a large part of why installing the OS is only supported on HFS+)
14:41:50 <geekosaur> you can make system apps dump core by feeding them names that aren't normalized UTF8, or trick them into opening the wrong thing
14:41:54 <ggVGc> flummz: peractically all speed benefit of C++ is from manual memory management
14:41:56 <ggVGc> and layout
14:42:02 <ggVGc> that's the sole reason
14:42:10 <ggVGc> and C
14:42:21 <xnil> and you usually shouldn't do manual memory management in C++
14:42:30 <flummz> everyone i know only uses smart/automatic pointers etc
14:42:34 <xnil> yep
14:42:40 <dolio> I don't think that's true. There's also orders of magnitude more work put in on writing optimizing compilers for them.
14:42:51 <xnil> ^
14:42:56 <EvanR> manual memory management in c++ seems like it would just make things slower
14:43:01 <xnil> it tends to
14:43:05 <ggVGc> sure, and most people using C++ for speed use it in a way that loses the points of using it from the beginning
14:43:27 <pikhq> C++'s semantics *permit* high speed code, but certainly don't make it fast.
14:43:36 <xnil> ggVGc: i'd take that a bit further and say that most people using C++ should find a better hobby
14:43:40 <ggVGc> EvanR: from my time in games the only reason for useing C or C++ was to control memory layout
14:43:41 <pikhq> People like thinking it magically makes things fast.
14:43:59 <EvanR> ggVGc: ... i think it was fear of GC delay ;)
14:44:04 <ertesx> dwynwen_ddlleyw: one way is to use GHC's builtin facilities: run your program with the argument "+RTS -s"
14:44:21 <ertesx> dwynwen_ddlleyw: if you use a unix-like system, another way is to prepend "time" to your command line
14:44:24 <arahael> for games, directx imposes a few extra restrictions involving memory.
14:44:25 <ggVGc> EvanR: I was never in contact with a GC during those days :(
14:44:38 <ertesx> dwynwen_ddlleyw: like: "time ./myprogram"
14:44:50 <EvanR> also back when c++ was the best game in town, the alternative was java
14:44:52 <dwynwen_ddlleyw> How about JS?
14:44:53 <EvanR> so fear of java
14:45:24 <ertesx> dwynwen_ddlleyw: the "time" thing applies to everything, so you could write "time node myprogram.js"
14:45:32 <dwynwen_ddlleyw> Node?
14:45:40 <ggVGc> me and my collegue were at a conference where they spoke about improving animation performence by keeping transormation data linear in memory. We made a small test and it ran a magnitude faster than a "traditional" game animation graph, which usually uses linked lists/trees
14:45:47 <ggVGc> that's a reason to use C++
14:45:58 <ertesx> dwynwen_ddlleyw: node.js is a platform interpreter for javascript‚Ä¶  you can run JS programs on your command line with it
14:46:06 <EvanR> imagine how much faster it would be if you just programmed the GPU directly
14:46:19 <EvanR> in proprietary machine code
14:46:28 <ggVGc> EvanR: I wrote an entire pong game in only shaders! It ran super fast
14:46:35 <ggVGc> but also rendered about 5 primitives
14:47:59 <ggVGc> honestly the best part of C++ Is that the template system is turing complete, so you can write a high level program to generate your super fast low level program for you
14:48:02 <ggVGc> right?
14:48:10 <dolio> You don't have to use C++, though. You could write Haskell that generates the code you want, but is still nicer to work with.
14:48:11 * ggVGc glances at Boost
14:48:13 <EvanR> so why youd use c++ has probably changed drastically since the pre-java era, the fear of java era, the embracing of java era, and today
14:48:22 <Lokathor> but haskell's type system was also shown to be turing complete recently
14:48:23 <dolio> I saw a presentation on that a year or two ago.
14:48:46 <Rembane> Does Haskell's type system pass the Turing test?
14:48:51 <ggVGc> Lokathor: obvously, https://github.com/saasbook/typo
14:48:58 <ggVGc> Rembane: ^
14:49:08 <EvanR> there needs to be a core wars of some sort between haskells type system and c++'s type system
14:49:09 <ggVGc> eh, crap
14:49:10 <Rembane> ggVGc: Oooooooh
14:49:19 <ggVGc> Rembane: https://github.com/seliopou/typo
14:49:24 <ggVGc> Lokathor: ^
14:49:32 <ertesx> even HTML5+CSS3 is turing-complete‚Ä¶  it's nothing special these days =)
14:49:36 <Rembane> ggVGc: ^^
14:49:47 <Rembane> ggVGc: Nice!
14:50:23 <dolio> They ran similar programs via an interpreter to Haskell, and one that generated code that told the GPU to store some 2D data as an image instead of data, which is faster, because you can tell the GPU to lay out the image in Morton order, but can't tell it to do that for arbitrary data for some reason.
14:50:39 <ertesx> so if you ever feel tempted to nitpick that "HTML is not a programming language!", be warned: you may be wrong =)
14:50:50 <dolio> Or rather, they had one program and multiple compilers of that program to different formats.
14:51:28 <ggVGc> ertesx: please write a haskell compiler in html so we can embed our programs on the web
14:51:38 <ggVGc> also runtime
14:51:58 <ertesx> ggVGc: we have GHCJS‚Ä¶  what do you need?  GHCHTML5?
14:52:11 <ggVGc> yes, some people disable JS and I want to reach them with my haskell!
14:52:44 <ggVGc> also I need to be able to compile my haskell on the web page
14:52:46 <ggVGc> with JS disabled
14:52:46 <Lokathor> ggVGc, what should i be seeing here?
14:52:49 <arahael> nitpick: HTML5 includes javascript.
14:52:59 <ertesx> you won't be changing DOM elements or running HTTP queries though
14:53:11 <ggVGc> Lokathor: the first link was wrong. It's a language that compiles into code that executes in the haskell type system
14:53:13 <Rembane> So you cannot write a brainfuck implementation with just html tags?
14:53:15 <ggVGc> so you compile it to run it
14:53:25 <Enigmagic> CSS is turing complete
14:53:28 <Lokathor> oh my
14:53:28 <sm> would someone please write a haskell RTS that runs in curses
14:53:30 <acowley> Anyone playing with agcorona's transient yet?
14:53:42 <ertesx> so the turing-completeness of HTML5+CSS3 (without JS) is not that useful‚Ä¶  it's really just interesting
14:53:50 <Lokathor> ertesx, GHCJS is pretty hard to get working right; I'd settle for GHCJS moving to stack :P
14:54:08 <ggVGc> I've recently built a small game with ghcjs and stack
14:54:10 <ggVGc> it was smooth
14:54:13 <ggVGc> well, fairly
14:54:16 <ggVGc> compoared to last year
14:54:26 <sm> ggVGc: got a demo ?
14:54:27 <Lokathor> ha, i last tried 4 months ago now, maybe it's gotten better
14:54:27 <ertesx> Lokathor: it's trivial with nix:  --argstr compiler ghcjs
14:54:39 <Lokathor> ertesx, well if only we were all so fancy
14:54:54 <ggVGc> sm: heh, it's very small, and not finished. It's just a multiplayer card game. I don't have a server up with it atm though
14:54:59 <Lokathor> sm, when you say "runs in curses", i'm not sure what you mean, but i don't think that's possible because of memory limits
14:55:05 <ertesx> Lokathor: you can become fancy =)
14:55:17 <sm> Lokathor: I'm being silly, but hey there's a probably a way to encode it
14:55:21 <ertesx> Lokathor: but i think it has become better in general
14:55:22 <ggVGc> but it uses ghcjs for the frontend, and websockets for talking to the server and runs real nice. Was a good experience
14:55:26 <acowley> TIL Installing nix is also known as bedazzling
14:55:26 <kadoban> Lokathor: You can do ghcjs in stack really easy with just a copied stack.yaml, I can give you mine if it helps.
14:55:27 <ggVGc> and has all the parts of a solid web game
14:55:50 <ertesx> Lokathor: usually all you need is to Setup/cabal configure with --ghcjs
14:55:53 <Lokathor> ertesx, this machine will run Win 7 until the hardware dies or The Witcher 3 gets a linux patch, and then i'll move back to debian. That's my current forecast
14:55:59 <kadoban> Actually figuring out GHCJS takes a bit though, the documentation isn't amazing yet.
14:56:07 <ggVGc> oh yeah that part..
14:56:10 <sm> in science fiction, the AIs are always embedding downgraded copies of themselves in crazy unexpected mediums
14:56:10 <ggVGc> is not great at all
14:56:18 <ggVGc> kadoban: figuring out the FFI was such a pain
14:56:33 <kadoban> ggVGc: Heh, yeah. I still have to just copy from my older projects when I need to do it more XD
14:56:57 <Lokathor> sm, well the typical screen is 24x80, and each character cell holds what haskell would call a CULong
14:56:58 <kadoban> It's not that bad though, for what you get out of it.
14:57:07 <ertesx> Lokathor: i don't know how easy it is to install on windows‚Ä¶  if all else fails you can fire up a small VM
14:57:51 <Lokathor> GHCJS effectively is a non-starter on widows last i checked. It assumes a few helper programs, and i don't want to cygwin things. I don't even need to make any web pages :P I was just trying it out at the time
14:58:39 <arahael> Lokathor: the latest windows build can natively run ubunto bjnaries, apparently.
14:58:54 <arahael> *ubuntu binaroes.  what's wrong with my typing?
14:59:04 <thimoteus> binaries?
14:59:13 <ertesx> binary's
14:59:15 <arahael> *binaries. damn it, thanks thimoteus.
14:59:34 <Lokathor> arahael, but that would involve being on windows 10
15:00:00 <arahael> Lokathor: the best windows yet.
15:00:26 <Lokathor> win7 until this machine dies, then back to debian for the next cycle at least for me
15:00:34 <Lokathor> all my top games run on linux these days anyway
15:00:47 <arahael> Lokathor: then give up on windows entirely?
15:01:06 <mgsloan> Lokathor: Should work ok with stack.  Main problem is running into MAX_PATH issues when building some dependencies
15:01:16 <ertesx> has debian become haskell-friendly by now?
15:01:34 <ertesx> or do we nowadays just 'stack' everything?
15:01:36 <ggVGc> my 4gb memory laptop frequencly runs out of memory when building askell packafges
15:01:40 <ggVGc> especially with ghcjs
15:01:40 <EvanR> as friendly as any other linux
15:02:01 <EvanR> i.e. how i learned to stop worrying and ignore the package manager
15:02:06 <Lokathor> arahael, correct
15:02:27 <mgsloan> Yeah, GHCJS is amazing awesomesauce, but it is rather slow
15:02:33 <arahael> ertesx: haskell incorrectly claimed to work with debian 6 a few years ago, but since then boh got much better.
15:02:36 <mgsloan> (compilation)
15:02:43 <ggVGc> arahael: ghc*
15:02:58 <arahael> ggVGc: yep.
15:03:01 <EvanR> you might have to close firefox when compiling 
15:03:08 <ertesx> i see
15:03:14 <ggVGc> hahaha... I always have to kill chrome when compiling with ghcjs...
15:03:19 <ggVGc> otherwise my whole machine just freezes
15:03:30 <sm> yikes
15:03:37 <Lokathor> I'll stick to GHC :3
15:03:40 <ggVGc> I have 4gb memory and no swap
15:03:44 <Lokathor> only uses like 1GB most ofthe time
15:03:48 <EvanR> we clearly need 16G of ram... nevermind that would just result in even more wasteful programs, lets go back to 1G
15:03:54 <Lokathor> better setup some swap i think
15:09:05 <ertesx> GHC 11.0 change log: no longer compiles locally, but uses the Glasgow Haskell Cloud
15:09:25 <ggVGc> ^ not even a joke in robably less than 5 years
15:09:35 <ggVGc> well, okay, maybe 10
15:12:07 <EvanR> uploads your ObjC code to Apple and C# code to microsoft for "verification" 
15:12:14 <EvanR> they return to you binaries
15:12:43 <EvanR> its really a lot more convenient that way
15:12:47 <ggVGc> wonder when apple wil start forcing everyone to just sent in source builds
15:14:11 <geekosaur> if you've looked at what Microsoft is doing, they're clearly headed in that direction...
15:15:15 <Lokathor> i can't imagine a corp would be happy with that
15:15:20 <EvanR> not only does it require less resources on your part, they will add in extra features for free
15:15:39 <kadoban> Like 2x the ads?
15:16:04 <Lokathor> yeah, but they want the IP security, i imagine
15:16:14 <EvanR> the benefit of not being ms certified is you get embedded ads
15:16:16 <EvanR> lol
15:17:04 <ggVGc> see, this is why we need to learn APL
15:17:48 <EvanR> is the compiler one line of code and runs in constant space?
15:18:18 <ggVGc> how long can the line be?
15:19:38 <ertesx> how to compile APL: read the source code‚Ä¶  once you really understand it, you've effectively acted as an interpreter, making the compiler unnecessary
15:21:29 <kadoban> Haha
15:22:03 <kadoban> How to run APL: read the source code, run away?
15:25:44 <levi> APL is not terribly far from point-free Haskell code; J is even closer. They're interesting languages to learn, even if you don't use them much.
15:25:56 <erisco> is there a companion to inits which is the reversed prefixes?
15:26:40 <EvanR> > inits (reverse "hello world")
15:26:42 <lambdabot>  ["","d","dl","dlr","dlro","dlrow","dlrow ","dlrow o","dlrow ol","dlrow oll",...
15:26:53 <erisco> that is O(n) rather than O(n^2) ?
15:27:40 <Lokathor> > map reverse (inits "hello") -- ?
15:27:41 <lambdabot>  ["","h","eh","leh","lleh","olleh"]
15:27:48 <erisco> no no no XD
15:28:05 <ertesx> levi: i'm always interested in learning new languages, but really i can't read/memorise symbols that well
15:28:43 <EvanR> how many symbols can there be ;)
15:33:31 <acertain> is there a fast way to store a mutable int?
15:33:35 <Lokathor> well, String is a [Char] so...
15:34:00 <EvanR> a mutable int, like you can change the value of 3 to 4?
15:34:02 <Lokathor> acertain, usually what you store a mutable thing in depends on the mutability context, not the fact that you want fact
15:34:04 <Lokathor> fast*
15:34:18 <levi> Well, J uses all ASCII characters, so at least you don't have to figure out how to type the APL symbols on a standard keyboard.
15:34:35 <acertain> like a `MutVar# s Int`, that is, but without the extra indirection
15:34:41 <ertesx> acertain: do you need an actual mutable memory cell, or do you just need state?
15:34:42 <Gurkenglas> acertain, not doing that is the entire point. You wanting to do that is a hint to look for a better way
15:34:46 <Lokathor> IORef for IO, STRef for ST, TVar for STM (which finalizes in IO), etc
15:35:05 <levi> And the single-character-ness makes it easier to fit stuff on cheat-sheets, at least. ;)
15:35:29 <acertain> I need a mutable field in an AST
15:35:48 <EvanR> are you suuuuure?
15:35:50 <Gurkenglas> acertain, what for?
15:35:55 <ertesx> acertain: there are many ways to do it, depending on what you need it for
15:36:15 * hackagebot GLUtil 0.9.0 - Miscellaneous OpenGL utilities.  https://hackage.haskell.org/package/GLUtil-0.9.0 (AnthonyCowley)
15:36:30 <ertesx> acertain: from the lowest level via the 'primitive' library to a very high level like TVar
15:36:48 <Lokathor> acertain, let's start with a simple question: Do you already have a working version that doesn't use special mutability stuff right now?
15:37:28 <Lokathor> because until you've tried that and seen how fast it runs, and have a working version for comparison as you make changes, you should avoid the crazy speed stuff
15:37:52 <ertesx> acertain: you should only ever need that when interfacing with a foreign library or when doing concurrency though‚Ä¶  to achieve statefulness there are better ways that don't require explicitly mutable memory
15:37:54 <Lokathor> and I say this as a person who applied ST and unboxed Ints to a module to make it faster, but only after I made the plain version
15:38:19 <acertain> i don't know if this algorithm can even be done without mutation
15:38:26 <acertain> i'll think more about it
15:38:32 <Gurkenglas> Using mutable variables is like using a turing machine instead of a regular grammar. Suddenly all the interesting analysis problems are undecidable and surprisingly often you wouldn't have needed the power
15:38:37 <ertesx> acertain: all algorithms can be done without mutation
15:38:49 <EvanR> but it might not be worth it to do it without mutation ;)
15:38:53 <Gurkenglas> ertesx, wait, is that like a theorem?
15:38:54 <ggVGc> EvanR: a few... https://en.wikipedia.org/wiki/APL_syntax_and_symbols
15:39:20 <EvanR> heh ‚ç®
15:39:46 <ertesx> Gurkenglas: yeah, the isomorphicness of lambda calculus and turing machines
15:39:54 <Lokathor> acertain, if you give us more info about what's going on we might be able to provide some more insight
15:40:30 <Lokathor> ertesx, there are occasional memory limits to consider as well (probably not here, but you know)
15:41:28 <Gurkenglas> ertesx, that doesn't give a one-to-one-correspondence of theta classes - I had assumed "all algorithms can be done without mutation" to mean "the problem can be solved in the same O-time without mutation"
15:41:40 <ertesx> anyway, even if mutation is necessary for speed/memory efficiency, there is usually a nice way to keep mutation local
15:41:42 <dwynwen_ddlleyw> My room mate gave me his old desktop :3
15:41:56 <kadoban> Gurkenglas: You should be able to get within a log factor at least, I'd think.
15:42:07 <kadoban> Asymptotically of course.
15:42:36 <ertesx> putting mutable variables into a data structure is seldomly a good idea
15:42:44 <Lokathor> speaking of which, if any speed geeks would like to try and make something faster, I'm open to ideas: https://github.com/Lokathor/ludolib/blob/master/src/Util/PPFOV.hs
15:43:01 <Gurkenglas> Sounds reasonable. Lets emulate a TM without mutation at a log slowdown.
15:43:03 <ertesx> but i'll let you people have fun with it‚Ä¶  good night =)
15:43:15 <Lokathor> I might have hit the effective limit of the algorithm though
15:44:23 <hackrilege> where is; http:comonad.comreader2011monads-from-comonads
15:44:27 <hackrilege> :(
15:44:29 <hackrilege> ?
15:44:54 <Lokathor> all your slashes got eaten up!
15:45:10 <hackrilege> lol thnx
15:45:31 <hackrilege> from; http://hackage.haskell.org/package/kan-extensions-3.1.1/docs/Control-Monad-Co.html
15:46:30 <erisco> okay here is the function I am looking for http://lpaste.net/159680 isn't there a fold for that? hm
15:47:54 <erisco> the reason you want is this because now  zippers = zip3 <$> heads <*> id <*> tail . tails
15:48:11 <hackrilege> basically; CoT k >>= f = CoT (k . extend (\wa a -> runCoT (f a) wa))
15:48:21 <hackrilege> where
15:48:21 <hackrilege> newtype CoT w m a = CoT { runCoT :: forall r. w (a -> m r) -> m r }
15:48:40 <Gurkenglas> :t inits
15:48:42 <lambdabot> [a] -> [[a]]
15:48:42 <Gurkenglas> @src inits
15:48:43 <lambdabot> inits []     = [[]]
15:48:43 <lambdabot> inits (x:xs) = [[]] ++ map (x:) (inits xs)
15:48:55 <erisco> inits and heads do not do the same thing
15:49:46 <Gurkenglas> oh yea, they differ by map reverse dont they
15:50:07 <Lokathor> i thought that the [[]] was a non-printing unicode until i looked clsoer
15:50:11 <erisco> semantically, yes
15:51:04 <Gurkenglas> :t scanl (flip (:)) [] -- heads
15:51:05 <erisco> but inits is O(n^2) time and space whereas heads is O(1) time and space
15:51:05 <lambdabot> [a] -> [[a]]
15:51:13 <EvanR> [‚éï]
15:51:18 <Gurkenglas> O(1) time!?
15:51:24 <erisco> sorry, O(n) time and O(n^2) space
15:51:41 <erisco> sorry
15:51:45 <erisco> O(n) time and O(n) space
15:51:54 <erisco> one of these times I'll type the right thing :P
15:51:58 <EvanR> O(-inf)
15:52:20 <Gurkenglas> "scanl (flip (:)) []" (passed to lambdabot above) what you looking for, erisco?
15:52:48 <erisco> ah, a scan, good idea
15:54:10 <Gurkenglas> scanl' is better here, right? Because it'll unflippity the flipflip
15:54:29 <hackrilege> > inits [1,2,3]
15:54:31 <lambdabot>  [[],[1],[1,2],[1,2,3]]
15:54:37 <erisco> here we go again XD
15:54:58 <hackrilege> wow sorry
15:55:37 <hackrilege> oh yeh Cale had that great combination of inits and heads to give splits or something
15:56:04 <Gurkenglas> It's called zip
15:56:19 <hackrilege> @src zip
15:56:19 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
15:56:19 <lambdabot> zip _      _      = []
15:56:38 <erisco> hackagebot, splits? maybe like  zip3 <$> heads <*> id <*> tail . tails ?
15:57:22 <Gurkenglas> nah, just zip <$> inits <*> tails
15:57:31 <hackrilege> whats wrong with \x zip (heads x) (tails x)
15:57:42 <Gurkenglas> the point
15:57:46 <hackrilege> kk
15:58:16 <Gurkenglas> (also it's got the heads the zipper-way round)
15:58:37 <erisco> with ([a],[a]) you can be positioned on an empty list, whereas with ([a],a,[a]) you cannot
15:58:58 <erisco> however with [([a],a,[a])] it is simple to say there are no zippers
15:59:40 <EvanR> ([a], [a]) doesnt seem to be positioned anywhere in particular
15:59:54 <erisco> you need some convention for where the point goes
16:00:05 <erisco> ([a], Maybe a, [a]) would be clearer
16:00:24 <EvanR> ... such as "if the first list is not empty, that head, else if the second list if not empty that head, else..."
16:00:24 <hackrilege> > iterate (\(l,z,(y:ys)) -> (z:l , y , ys)) [1,2,3,4,5]
16:00:27 <lambdabot>      Couldn't match expected type ‚Äò([a], a, [a])‚Äô
16:00:27 <lambdabot>                  with actual type ‚Äò[Integer]‚Äô
16:00:27 <lambdabot>      In the second argument of ‚Äòiterate‚Äô, namely ‚Äò[1, 2, 3, 4, ....]‚Äô
16:00:28 <EvanR> seems complicated
16:00:33 <Gurkenglas> Eh, that'd leave more degrees of freedom than necessary - how about Maybe ([a], a, [a])
16:01:29 <hackrilege> > iterate (\(l,z,(y:ys)) -> (z:l , y , ys)) ([],0,[1..5])
16:01:31 <lambdabot>  [([],0,[1,2,3,4,5]),([0],1,[2,3,4,5]),([1,0],2,[3,4,5]),([2,1,0],3,[4,5]),([...
16:02:46 <Gurkenglas> (No Control.Lens.Zipper on lambdabot :( )
16:04:02 <hackrilege> what is infix snoc?
16:04:10 <hackrilege> can i pattern match like that?
16:04:26 <hackrilege> what is the (:<) operator?
16:04:30 <Cale> On which type?
16:04:33 <Cale> Seq?
16:04:46 <hackrilege> used to define CoFree
16:05:00 <mgsloan> j
16:05:08 <Gurkenglas> Defined by the definition of Cofree. Compare (:) for lists
16:05:45 <Cale> Ah, data CofreeF f a b = a :< f b -- it's the data constructor
16:05:48 <Gurkenglas> > unsnoc [1..5] -- case unsnoc xs of Nothing -> foo; Just (xs', x) -> bar
16:05:50 <lambdabot>  Just ([1,2,3,4],5)
16:06:48 <acertain> (:<) is also a pattern synonym in Control.Lens.Cons
16:07:28 <acertain> (:>) is the snoc version
16:07:29 <hackrilege> what is Cofree doing!?
16:07:42 <hackrilege> [] :> 0
16:07:58 <hackrilege> > [] :> 0
16:08:00 <lambdabot>      Not in scope: data constructor ‚Äò:>‚Äô
16:08:00 <lambdabot>      Perhaps you meant one of these:
16:08:00 <lambdabot>        ‚ÄòSeq.:>‚Äô (imported from Data.Sequence),
16:08:11 <hackrilege> hrmpf
16:08:26 <Gurkenglas> @let import Control.Comonad.Cofree
16:08:28 <lambdabot>  Defined.
16:08:32 <Gurkenglas> > 0 :< []
16:08:34 <lambdabot>  0 :< []
16:08:38 <Gurkenglas> :t 0 :< []
16:08:39 <lambdabot> Num a => Cofree [] a
16:08:49 <Peaker> names I prefer: "CoFree" -> "Annotate", "fix" -> "recursively"
16:08:58 <Gurkenglas> Imagine [] wherever Cofree says f, and you'll have trees and as much intuition about Cofree as most.
16:09:00 <hackrilege> its just a list!?
16:09:43 <Peaker> Cofree is like "Fix" but it tuples up an annotation at each (recursive) node
16:09:46 <Cale> Cofree Maybe is like a list
16:09:51 <Cale> (a nonempty list)
16:10:01 <Cale> type
16:10:03 <Cale> heh
16:10:12 <hackrilege> List is Free (:), correct?
16:10:31 <hackrilege> [a] = (Free []) a
16:10:39 <Cale> no
16:10:40 <Gurkenglas> > toList $ 0 :< [1 :< [], 10 :< [5 :< [0 :< []], 3 :< []]] -- in-order tree flattening
16:10:42 <lambdabot>      Ambiguous occurrence ‚ÄòtoList‚Äô
16:10:42 <lambdabot>      It could refer to either ‚ÄòData.Foldable.toList‚Äô,
16:10:42 <lambdabot>                               imported from ‚ÄòData.Foldable‚Äô at /tmp/mueval164...
16:10:43 <hackrilege> [a] = (Free :) a
16:10:46 <Gurkenglas> *pre i mean ._.
16:10:47 <Cale> what?
16:11:00 <Cale> hackrilege: That doesn't even make sense, you're mixing up types and terms
16:11:15 <Gurkenglas> > F.toList $ 0 :< [1 :< [], 10 :< [5 :< [0 :< []], 3 :< []]] -- preorder tree flattening, also dang you miss the lambdabot-query-test one time
16:11:17 <lambdabot>  [0,1,10,5,0,3]
16:12:11 <Gurkenglas> http://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html does give four examples after "For instance,"
16:12:32 <hackrilege> [a] = (f Free x) a -- what is x, what is f?
16:13:03 <Gurkenglas> If f is to be chosen by us, there is no need to supply a choice for x
16:14:07 <hackrilege> i thought you might like to use the dataconstructor
16:14:07 <hackrilege> i guess its global though...
16:16:56 <hackrilege> ok, a binary tree is data BinaryTree =  Free Pair, where data Pair a = Pair a a
16:17:21 <Gurkenglas> Depending on how you see a binary tree - you might also call Cofree Pair that
16:17:41 <hackrilege> aha
16:17:42 <hackrilege> wft
16:17:42 <Gurkenglas> (Well, except that those would be always infinite)
16:17:45 <hackrilege> how?
16:17:54 <hackrilege> hmmmm
16:18:18 <Gurkenglas> Well every Cofree Pair a would be an a and two more values of Cofree Pair a
16:18:30 <hackrilege> does Free Pair = Free Pair?
16:18:42 <Gurkenglas> sure, equality is reflexive
16:18:46 <hackrilege> CoFree*
16:18:51 <hackrilege> lol
16:19:07 <Gurkenglas> Well every Free Pair a would be an a or two more values of Free Pair a
16:19:08 <hackrilege> does Free Pair = CoFree Pair?
16:19:22 <Gurkenglas> notice the and/or difference
16:19:31 <hackrilege> riiight
16:20:10 <Iceland_jack> no, you have no way of representing a single value (Pure)
16:20:41 <Gurkenglas> (He's saying how there's a Free Pair a which there is no equivalent to in Cofree Pair a)
16:22:49 <zzz`> What's the best way to do `thFunction ''(Parameterized a)`? (<- doesn't work)
16:23:40 <Iceland_jack> To make what Gurkenglas said more visual
16:23:40 <Iceland_jack>       Free f a = f + f   (Free f a)
16:23:40 <Iceland_jack>     Cofree f a = f √ó f (Cofree f a)
16:23:51 <Iceland_jack> oops
16:23:55 <Iceland_jack>       Free f a = a + f   (Free f a)
16:23:55 <Iceland_jack>     Cofree f a = a √ó f (Cofree f a)
16:23:55 <erisco> zzz`, can you rephrase the question? I don't understand all the symbols
16:25:16 <zzz`> Ordinarily, you'd pass a `Name` to the template haskell function. That works with concrete types like `Int`. But it doesn't work with parameterized types like `Maybe a`. What's the best way to pass parameterized types to a TH function?
16:27:40 <Iceland_jack> zzz`: You can try builting the type application yourself
16:27:41 <hackrilege> how are the + and x defined above??
16:27:42 <erisco> ah, good question. I have only worked with TH for values
16:28:00 <Iceland_jack> hackrilege: Sum (is +) and (,) (is √ó)
16:28:14 <Iceland_jack> I usually wouldn't use that notation, but it's much clearer than the Haskell notation
16:28:14 <Cale> zzz`: [t| forall a. Maybe a |]
16:28:15 <Cale> ?
16:28:54 <Iceland_jack> hackrilege: 
16:28:54 <Iceland_jack>     data Free f a = Pure a | Free (f (Free f a))
16:28:54 <Iceland_jack> doesn't show the contrast to 
16:28:54 <Iceland_jack>     data Cofree f a = a :< f (Cofree f a)
16:28:57 <Iceland_jack> as well
16:29:29 <Iceland_jack> Perhaps
16:29:29 <Iceland_jack>     data Cofree f a = Cofree a (f (Cofree f a))
16:29:29 <Iceland_jack> would? Depends on the reader I suppose
16:29:44 <augur_> hey peeps, how do we get lambdabot to join a channel
16:30:16 <Cale> augur_: Permanently or temporarily?
16:30:22 <simony> AFAIK lambdabot does not respond to invites?
16:30:27 <hackrilege> :t coreturn
16:30:29 <lambdabot>     Not in scope: ‚Äòcoreturn‚Äô
16:30:29 <lambdabot>     Perhaps you meant ‚Äòreturn‚Äô (imported from Control.Monad.Writer)
16:30:29 <Cale> I can do temporarily
16:30:33 <augur_> Cale: preferably permanently but temporarily will do for now
16:30:39 <Cale> But for permanently you'll have to ask int-e
16:31:05 <Cale> Which channel?
16:31:15 <zzz`> thanks all
16:31:15 <augur_> Cale: ##narrative-ai
16:31:20 <SomeNone> Hey there sorry this is a fairly intensely noob question but does anyone know if I should install 32 bit or 64 bit Haskell? I only ask because I know that some languages have really crappy/absent 64 bit libraries
16:31:21 <Cale> @join ##narrative-ai
16:31:34 <hackrilege> 64 for sure
16:31:36 <augur_> woo! thanks Cale! :D
16:31:40 <SomeNone> ok thanks
16:31:42 <Cale> SomeNone: You should install whichever compiler matches your OS
16:31:57 <SomeNone> yeah that's what I would default to of course but I have been bitten before
16:32:39 <simony> I wish there was slightly better documentation for setting up lambdabot
16:33:15 <hackrilege> this is melting my brain
16:34:05 <Iceland_jack> I had a rant about Free/Cofree on #haskell-beginners, I've been meaning to put it into blogpost form
16:34:09 <hackrilege> its Fix?
16:34:37 <johnw> Iceland_jack: a rant of what nature?
16:34:42 <hackrilege> newtype Fix f = Fix (f (Fix f))
16:34:52 <Cale> Iceland_jack: can you summarize it? :)
16:34:53 <hackrilege> matches
16:34:54 <hackrilege> data Cofree f a = Cofree a (f (Cofree f a))
16:35:08 <Iceland_jack> I call everything I say online longer than 20 words a rant, it was just an explanation
16:35:59 <Iceland_jack> Cale: I was discussing in what ways Functor is "broken" in Haskell, and that lead me to this function
16:35:59 <Iceland_jack>     hoistFree :: Functor f => :: (forall x. f x -> f' x) -> (forall b. Free f b -> Free f' b)
16:36:17 <Iceland_jack> which lead to a question on how Free works
16:36:56 <Iceland_jack> I mentioned the relationship between 'Pair a = (a, a)' and Tree 
16:37:35 <Iceland_jack> and the relationship between a 3-tree and 'Triple a = (a, a, a)' and how you could use 'hoistFree' to convert between them
16:38:25 <Iceland_jack> And how you can treat those two data types as templates for a data type, where you get all these functions and instance (like Monad, mtl, ...) for free
16:38:52 <hackrilege> isnt Cofree f a = Fix (a,\x f x)?
16:40:29 <Iceland_jack> It's more the fixed point of 'CofreeF f a r = a √ó f r'
16:41:33 <johnw> Free = Fix (Compose (Either a) f), Cofree = Fix (Compose ((,) a) f)
16:41:45 <johnw> products vs. coproducts
16:42:02 <johnw> made convenient by Fix being both inductive and co-inductive in Haskell
16:43:46 <hackrilege> sorry dropped the line
16:44:42 <hackrilege> i dont really get the Sum type, whats coerce?
16:45:14 <hackrilege> :t coerce
16:45:16 <lambdabot> (Functor f, Contravariant f) => f a -> f b
16:45:42 <hackrilege> > coerce [0]
16:45:44 <lambdabot>      No instance for (Contravariant []) arising from a use of ‚Äòcoerce‚Äô
16:45:44 <lambdabot>      In the expression: coerce [0]
16:46:23 <hackrilege> damn
16:46:47 <dwynwen_ddlleyw> I found the Ada channel on freenode :D
16:47:00 <Iceland_jack> hackrilege: If you are Functor and Cofunctor you really can't "contain" any values
16:47:08 <Iceland_jack> that's why the mapping 'f a -> f a' makes sense
16:47:12 <Iceland_jack> *f b
16:47:42 <Iceland_jack> *Contravariant, before anyone gets on my ass
16:47:53 <Zekka|Sigfig> an example of a type that‚Äôs both contrafunctor and functor is data Fun a =Fun (a -> a), right?
16:48:03 <Zekka|Sigfig> wait
16:48:06 <Zekka|Sigfig> nope! It‚Äôs not, never mind
16:48:06 <Iceland_jack> Zekka|Sigfig: Actually, the opposite
16:48:09 <Iceland_jack> it's neither :)
16:48:20 <Zekka|Sigfig> Yeah, composing on one side doesn‚Äôt affect the other
16:48:35 <Zekka|Sigfig> I was trying to figure out if I could finagle being both of those things out of starting from ‚Äúit‚Äôs a profunctor‚Äù
16:49:01 <levi> dwynwen_ddlleyw: I didn't know there was one. What is it?
16:49:14 <Zekka|Sigfig> Maybe something interesting happens if you require whatever‚Äôs being mapped to be a pair (a -> b) and (b -> a), but I don‚Äôt know what that thing is
16:49:19 <dwynwen_ddlleyw> #ada
16:49:31 <hackrilege> why cant a contravariant functor contain values?
16:49:32 <levi> Heh, makes sense.
16:50:03 <Iceland_jack> hackrilege: It can't if it is BOTH 
16:50:11 <erisco> Zekka|Sigfig, aren't you just as stuck with the pair?
16:50:16 <Iceland_jack> For example, Const is both Contravariant and Functor
16:50:27 <hackrilege> cofmap :: (b -> a) -> f a -> f b
16:50:50 <Iceland_jack>     data Const a b = Const a
16:50:50 <Iceland_jack> it doesn't contain anything of type 'b', it's a phantom type
16:50:52 <hackrilege> how is that supposed to work!?
16:50:54 <Zekka|Sigfig> erisco: Well, with (a -> b) and (b -> a), you can get a (b -> b) out of an (a -> a) and an (a -> a) out of a (b -> b)
16:51:16 <hackrilege> cofunctors suck?
16:51:31 <Iceland_jack> Cofunctors are not contravariant functors :)
16:51:41 <Iceland_jack> In fact cofunctors and functors are the same thing
16:51:57 <Zekka|Sigfig> cofunctors are an interesting math object, there‚Äôs an acme package for them on hackage
16:51:58 <hackrilege> class Cofunctor f whereSource
16:51:58 <hackrilege> DEPRECATED: please use the "contravariant" package
16:52:18 <Zekka|Sigfig> https://hackage.haskell.org/package/acme-cofunctor <- here it is
16:52:48 <Iceland_jack> hackrilege: If 'fmap' changes the "output", 'contramap' change the "input"
16:53:07 <hackrilege> lol
16:53:39 <hackrilege> the output is what you get as a result of changing the input
16:53:56 <Iceland_jack> Things like orderings
16:53:56 <Iceland_jack>     a -> a -> Ordering
16:53:56 <Iceland_jack> and predicates
16:53:56 <Iceland_jack>     a -> Bool
16:53:59 <Iceland_jack> are Contravariant
16:54:50 <hackrilege> because given an ordering and an element i can return you elements safisffying this applying (-)
16:55:07 <hackrilege> (satisfy the ordering)
16:55:18 <hackrilege> is that right?
16:55:44 <Iceland_jack> hackrilege: That's the reason why one of the arrows is "backwards", because that's how it works when you apply it to the input
16:56:28 <Iceland_jack> So if you have a predicate that checks if a String is valid
16:56:28 <Iceland_jack>     String -> Bool
16:57:21 <hackrilege> what is the kind * -> * thing?
16:57:28 <hackrilege> 'f'
16:57:33 <Iceland_jack> then you can make that work on numbers but using 'show @Int :: Int -> String' magically gives you something to check numbers
16:57:33 <Iceland_jack>     Int -> Bool
16:57:46 <Iceland_jack> hackrilege: The difference between "Int" and "Maybe"
16:58:00 <Iceland_jack> you probably have some intuition how they're different
16:58:12 <Iceland_jack> You can write "Maybe Bool" but you can't write "Int Bool"
16:58:19 <hackrilege> sorry
16:58:22 <hackrilege> i know what kind means
16:58:29 <Iceland_jack> ah
16:58:53 <hackrilege> what is the object of kind * -> * which you refer to as f?
16:59:03 <hackrilege> sorry
16:59:10 <Iceland_jack> For 'coerce'?
16:59:18 <hackrilege> not you, the type of cofmap
16:59:39 <Iceland_jack> any contravariant functor
16:59:59 <Iceland_jack> Like 'Predicate' from 'newtype Predicate a = Pred (a -> Bool)'
17:04:22 <hackrilege> sorry, bad connection, anyway i dont want this discussion to overrun, but thanks for the introduction to Contravariant
17:04:57 <hackrilege> ok so the question wass why Contravarient functors cannot contain elements!
17:04:59 <hackrilege> ?
17:05:33 <Iceland_jack> Look at the definition of 'phantom' https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#v:phantom
17:05:59 <Iceland_jack>     phantom x = () <$ x $< ()
17:06:01 <Iceland_jack> Interesting! :)
17:06:24 <hackrilege> thanks for this btw johnw
17:06:27 <hackrilege> johnw
17:06:27 <hackrilege> Free = Fix (Compose (Either a) f), Cofree = Fix (Compose ((,) a) f)
17:08:42 <Iceland_jack> hackrilege: Here's a hint with Functor you get
17:08:42 <Iceland_jack>          fmap (const ()) :: Functor        f => f a -> f ()
17:08:42 <Iceland_jack> and with Contravariant
17:08:42 <Iceland_jack>     contramap (const ()) :: Constravariant f => f () -> f a
17:09:06 <hackrilege> phantom x = () <$ x $< ()
17:09:23 <hackrilege> oh yeah, so whats <$
17:09:28 <v937xjd> Hello
17:09:47 <Iceland_jack> hackrilege: 'fmap . const' and 'contramap . const'
17:10:57 <Iceland_jack>     (() <$) :: Functor        f => f a  -> f ()
17:10:57 <Iceland_jack>     ($< ()) :: Constravariant f => f () -> f a
17:10:59 <hackrilege> some useless nonesense, ok ill make sure i never try and make a contravarient functor. strange way to say the set of lawful contravarient functors is empty
17:12:45 <Iceland_jack> There are more useful concepts than Contravariant
17:12:57 <hackrilege> so the difference between Free and CoFree is the difference between either and (,), apparently this is also the same as the difference between and and or and also the difference between Sum and Product
17:13:51 <hackrilege> its the choice about if the set is infinite or not
17:14:09 <hackrilege> i cant think of many things id like to use CoFree for
17:14:37 <hackrilege> strictly infinite things...
17:14:46 <Iceland_jack> That's not true
17:14:57 <hackrilege> ok so whats my missunderstanding?
17:15:00 <Iceland_jack> 'Cofree Maybe' includes
17:15:01 <Iceland_jack>     a <: Nothing
17:15:08 <Iceland_jack> So it's non-empty lists
17:15:09 <hackrilege> oooh
17:15:20 <Iceland_jack> *a :< Nothing
17:15:49 <Iceland_jack>     [a]     = a :< Nothing
17:15:50 <Iceland_jack>     [a,b]   = a <: Just (b <: Nothing)
17:15:50 <Iceland_jack>     [a,b,c] = a <: Just (b <: Just (c <: Nothing))
17:15:50 <Iceland_jack>     ‚Ä¶
17:16:51 <hackrilege> yeah
17:17:17 <hackrilege> isnt List = Free Maybe?
17:17:19 <Iceland_jack> So you can automatically duplicate your non-empty lists, no code needs to be written
17:17:47 <Iceland_jack> hackrilege: Not quite, try writing it out
17:17:59 <hackrilege> no Maybe = Free Maybe
17:18:13 <Iceland_jack> Almost
17:20:18 <hackrilege> can i write List using Free??
17:20:53 <Apocalisp> hackrilege: Free (a,) ()
17:20:58 <Iceland_jack> Not how you'd want it
17:21:03 <Iceland_jack> what Apocalisp said
17:21:21 <hackrilege> thats good, not sure about the () at the end though
17:21:35 <Apocalisp> that's not the list monad though
17:21:44 <hackrilege> :(
17:22:01 <hackrilege> no return
17:22:16 <Iceland_jack> You can represent
17:22:17 <Iceland_jack>     []    = Pure ()
17:22:17 <Iceland_jack>     [a]   = Free (a, Pure ())
17:22:17 <Iceland_jack>     [a,b] = Free (a, Free (b, Pure ()))
17:22:17 <hackrilege> oh i get the () now
17:22:19 <hackrilege> its the base case
17:22:20 <Apocalisp> sure, but the bind appends
17:22:42 <Iceland_jack> hackrilege: toList will aways return [()]
17:22:50 <hackrilege> nooo
17:22:59 <Iceland_jack> :)
17:23:05 <Iceland_jack> I love breaking bad news
17:24:04 <dwynwen_ddlleyw> [()] = EyeOfMordor -> Text
17:24:18 <benzrf> lol
17:24:51 <Apocalisp> You could do List = Free Pair
17:25:21 <hackrilege> List a = Free (Pair a) ()
17:25:31 <Apocalisp> but that's too big
17:26:04 <hackrilege> huh? you gave Free something of the wrong kind
17:26:40 <hackrilege> oh no
17:26:41 <hackrilege> ok
17:27:09 <Apocalisp> were Pair a = (a, a)
17:27:40 <Apocalisp> up to associativity, free pair is list
17:27:56 <hackrilege> [] = ?
17:28:21 <hackrilege> oh thats the empty dataconstructor of Free
17:28:31 <hackrilege> great
17:29:02 <hackrilege> List = Free Pair = CoFree Maybe
17:29:25 <Iceland_jack> Cofree Maybe is the non-empty list
17:30:04 <hackrilege> so because there is a Maybe written into the datatype definition of Free, but not CoFree, okok i get it
17:30:43 <hackrilege> isnt Nothing = repeat Nothing?
17:31:13 <hackrilege> its not the empty list, but the infinitly populated list of Nothing...
17:32:14 <hackrilege> oh its the a :< Nothing thats the problem ok
17:35:40 <hackrilege> CoFree f a= Free (Free f) a?
17:35:50 <hackrilege> oh idk
17:38:47 <hackrilege> isnt there a more systematic way to do this?
17:39:33 <Apocalisp> do what?
17:40:33 <hackrilege> eg = Free a = Fix (Maybe a)
17:40:35 <hackrilege> i dont know if thats right
17:41:10 <hackrilege> basically start with Fix, use it to write Cofree, use Cfree to write Free etc
17:41:18 <hackrilege> i say etc, i dont know what you would do then
17:41:35 <Apocalisp> I don't think you can write Free as a Cofree comonad
17:43:18 <Apocalisp> Free f a = Fix (\x -> Either a (f x))
17:43:43 <Apocalisp> Cofree f a = Fix (\x -> (a, f x))
17:43:47 <hackrilege> Free f a= Maybe (CoFree f (. id .))
17:44:35 <Apocalisp> (. id .) ?
17:44:45 <hackrilege> lol
17:44:51 <hackrilege> id
17:45:14 <hackrilege> :t (. id .)
17:45:16 <lambdabot> parse error on input ‚Äò)‚Äô
17:45:18 <Apocalisp> that doesn't look right
17:45:32 <hackrilege> :t \a b -> (a. id .b)
17:45:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:45:39 <hackrilege> :t id
17:45:40 <lambdabot> a -> a
17:46:36 <hackrilege> data Cofree f a = a :< f (Cofree f a)
17:47:01 <shachaf> Apocalisp: I think that in general Free is supposed to be Mu and Cofree is supposed to be Nu, right?
17:47:08 <shachaf> Not that it matters that much in Haskell.
17:47:21 <Apocalisp> yeah, I suppose so
17:47:28 <hackrilege> require a :< f (a :< f (....)) = f (f (f ....
17:47:53 <hackrilege> basically a = id or f
17:48:10 <hackrilege> the identity of :<
17:48:14 <hackrilege> oh no
17:48:33 <Apocalisp> id being the identity functor?
17:49:01 <Apocalisp> That's not kind checking in my mind
17:49:21 <hackrilege> something is very wrong here
17:49:36 <hackrilege> it requires someone who knows what they are talking about
17:49:47 <Apocalisp> Free is not Maybe anything
17:51:17 <hackrilege> oh its Either yeh
17:51:18 <hackrilege> data Free f a = Pure a | Roll (f (Free f a))
17:51:25 <hackrilege> i thought it was Nil
17:51:29 <hackrilege> but thats Fix
17:51:32 <Apocalisp> right
17:52:10 <hackrilege> no
17:52:10 <hackrilege> its list
17:53:19 <Apocalisp> [] is the free monoid, Free is the free monad
17:55:00 <hackrilege> ok so its fine i dont have a mempty
17:55:05 <hackrilege> thanks
17:55:49 <Apocalisp> any time
17:57:07 <hackrilege> what is data ? f a = Nil | Pure a | Roll (f (? f a))
17:57:37 <hackrilege> redundant
17:57:38 <hackrilege> ok
17:58:07 <hackrilege> what is data ? f a = Nil | Pure a | Roll (? a) (f (? f a))
17:58:49 <EvanR> what do you called the free functor
17:58:53 <hackrilege> what is data ? f a = Nil | Pure a | Roll (? f a) (f (? f a))
17:58:56 <hackrilege> sorry the first one had a typo
17:59:05 <hackrilege> EvanR?
17:59:21 <EvanR> name of the free functor type ctor
18:00:03 <Apocalisp> hackrilege: Maybe . (Free f)
18:03:03 <hackrilege> i never know how much i missed
18:03:34 <hackrilege> im sure data ? f a = Nil | Pure a | Roll (? f a) (f (? f a))  /=  Maybe . (Free f)
18:03:54 <hackrilege> its a tree of some kind
18:04:16 <lethjakman> (~/= TagOpen "" [("id","pnlResultList")])
18:04:26 <lethjakman> I keep having issues with "" Not benig an instance if IsString. 
18:04:35 <lethjakman> I think it's because TagOpen doesn't specify a specific type of string. 
18:04:50 <lethjakman> also tried adding a :: String after ""
18:05:00 <lethjakman> Is there a good way to make sure it looks at "" as a String?
18:05:05 <lethjakman> Also, I have overloaded strings on.
18:05:20 <Apocalisp> hackrilege: Oh I see, misread the Roll
18:06:00 <hackrilege> cant you write IsString' a = if isEmpty a then True else IsString a
18:06:12 <lethjakman> MAYBE
18:06:14 <lethjakman> Whoops
18:06:16 <lethjakman> Maybe
18:06:25 <hackrilege> aha, but then [] is a string
18:06:49 <geekosaur> > [] :: String
18:06:49 <hackrilege> is the point that you cant distinguish between types contained within an empty Monad?
18:06:50 <lambdabot>  ""
18:06:55 <geekosaur> it is anyway...
18:07:15 <hackrilege> thats good!
18:07:29 <hackrilege> is there a name for Monads which can be empty in this sense?
18:07:30 <geekosaur> also ("" :: String) should do it. did you forget the parens?
18:07:46 <hackrilege> > IsString []
18:07:48 <lambdabot>  Not in scope: data constructor ‚ÄòIsString‚Äô
18:07:49 <EvanR> "the monad" isnt empty
18:07:58 <geekosaur> hackrilege, it's not a function, it's a typeclass
18:08:04 <hackrilege> the monad here being list
18:08:15 <hackrilege> oh yeah! oops
18:08:25 <hackrilege> thought it was a function for some reason sorry
18:08:26 <EvanR> the list type ctor isnt empty, neither is the list type for any given [a]
18:09:08 <hackrilege> Nil
18:09:12 <EvanR> what you can say is the value [] is polymorphic, it works for any a
18:09:16 <hackrilege> looks like an empty ctor to me
18:09:18 <lethjakman> Why do I have to do that?
18:09:23 <lethjakman> You're totally right in the ()'s
18:09:36 <lethjakman> And I only have to do it for the empty ""
18:09:39 <EvanR> but the value [] isnt a monad
18:09:51 <hackrilege> > "" == []
18:09:53 <lambdabot>  True
18:10:40 <hackrilege> [] = Nil. List a = Nil | Cons a (List a)
18:11:07 <hackrilege> aha, so [] is both a value and a ctor
18:11:20 <hackrilege> sugary
18:11:27 <EvanR> its the name of a value (ctor) and a type ctor
18:11:28 <geekosaur> I have no idea why it would matter, unless you also have OverloadedLists on and something is "overthinking" [Char] as an IsList...
18:12:15 <geekosaur> althogh no, that shouldn't be it either, that would require you said [] because that is polymorphic. "" is not...
18:13:37 <EvanR> "" :: IsString a => a
18:14:00 <Zemyla> You know one of the big things I dislike about Text?
18:15:48 <geekosaur> EvanR, as I understand it, the question is why that happens for "" but not, say, "2"
18:17:12 <lethjakman> Thank you :)
18:17:32 <lethjakman> And yes, I was just confused why "" needs to be defined as some sort of string...
18:18:34 <Zemyla> "index" and "length" are O(n).
18:18:50 <Zemyla> There's no excuse for that if it's an array.
18:19:29 <Hafydd> Zemyla: I believe that because of the way Unicode is encoded, it can't be avoided.
18:19:31 <Axman6> yes there is
18:20:15 <Axman6> Unicode has code points which modify other characters, sych as the modifier to make an e into √©
18:20:38 <geekosaur> Zemyla, even in Text a character could be 2 units (low and high surrogates for a non-BMP char)
18:21:19 <Zemyla> geekosaur: Why is it in UTF-16? It seems like it gets the worst of speed and space efficiency.
18:21:21 <Ralith> Zemyla: if you're not writing very low level typesetting code, you probably shouldn't be working in terms of glyphs anyway...
18:21:59 <geekosaur> Zemyla, you could check logs from the last time this was discussed, but it came down to people expect to be able to do things that require the icu library... which is essentially designed for Java
18:22:03 <geekosaur> thus UTF16
18:22:16 <Ralith> geekosaur: 'designed for java'?
18:22:33 <geekosaur> UTF8 turned out to be faster if you could avoid that --- but only slightly
18:23:06 <geekosaur> Ralith, in terms of "optimized to work with Java-style strings, whuch are UTF16"
18:23:22 <EvanR> Zemyla: at some point i thought the choice was made based on performance
18:23:35 <EvanR> it ended up being faster than utf8, but i guess not
18:23:50 <Ralith> geekosaur: ah.
18:23:50 <geekosaur> there are utf8 entrypoints but IIRC the existing haskell bindings and libraries using them can't easily be retrofitted
18:23:50 <EvanR> in neither case can you use "arrayness" to accelerate length
18:24:21 <EvanR> (but when is length not cached as part of the chunk)
18:24:25 <EvanR> but why*
18:25:12 <geekosaur> hm, lemme find the page linked last time that discussed this stuff
18:25:55 <Zemyla> Actually, I know how index and length could be accelerated even if you keep strings being single UTF-16 arrays.
18:25:59 <EvanR> "" and "2" literals get the same polymorphic type in my ghci
18:26:47 <EvanR> i would opt for a utf8 based design just because i dont feel like index is a common operation on strings
18:26:59 <EvanR> and you have less friction at boundaries
18:27:06 <lethjakman> So, another potentially dumb overloaded strings question
18:27:15 <lethjakman> I have a method with this signature:
18:27:17 <lethjakman> getMethodType :: (ToMarkup a, IsString a) => HttpMethod -> a
18:27:27 <lethjakman> But when I call it, I have to clal it like this:
18:27:28 <lethjakman>   let method = (getMethodType methodType) :: String
18:27:40 <lethjakman> If I don't specify :: String I get an IsString deduction error. 
18:27:48 <EvanR> unless there is more context to know you wanted a String, yes
18:27:51 <lethjakman> Shouldn't the IsString thing restrict it to that?
18:28:00 <EvanR> like using method somewhere where a String is required
18:28:07 <EvanR> or using a top level type annotation
18:28:13 <lethjakman> It is...but it's in a whamlet file. 
18:28:27 <lethjakman> So I think that may be what's throwing it off. 
18:28:31 <EvanR> IsString is whats *un*restricting a to be whatever has an IsString instance
18:28:36 <Zemyla> EvanR: What you add is a fingertree that tracks chunks of 1-word and 2-word characters.
18:28:50 <Hafydd> lethjakman: why would an IsString a constraint restrict a to be String?
18:28:57 <EvanR> Zemyla: right... this is where i was told that they had measurements of performance of various ways to do it
18:29:01 <lethjakman> Well there are several things that work. 
18:29:12 <geekosaur> https://jaspervdj.be/posts/2011-08-19-text-utf8-the-aftermath.html
18:29:26 <lethjakman> I thought the whamlet file would force it to whatever it needs to be (string, text, whatever)
18:29:30 <lethjakman> But...I guess that makes sense. 
18:29:34 <lethjakman> It would have to make a decision in there. 
18:29:53 <geekosaur> see "The results' for analysis wrt ICU etc.
18:30:06 <Zemyla> But basically what you're saying is that uncons is the most common operation on a Text you're consuming, and index is far less common?
18:30:24 <EvanR> index to get a single Char is definitely not common
18:30:33 <EvanR> i dont know whats most common
18:31:50 <dpk-atk> hey, this is probably a dumb question but I was wondering if there was any sort of abstraction for a unary operation 
18:31:52 <dolio> It has a bunch of fusion stuff, and repeated indexing is definitely not going to work well with that.
18:32:18 <dpk-atk> like how semigroups are the set S and some associative operation 
18:32:26 <dolio> All of that is designed for stream processing characters.
18:32:42 <dpk-atk> is there an abstraction thats like the Set S and some unary operation
18:32:47 <Zemyla> Well, it should still at least cache the length in characters.
18:33:01 <EvanR> yes i want to know what the issues with that would be
18:34:07 <Hijiri> dpk-atk: Num has negate, I guess
18:34:08 <Zemyla> Because length is extremely common, and it being O(n) is inexcusable.
18:34:12 <dolio> length isn't a good streaming operation, either, unless it's the only thing you're computing, or you know it a priori.
18:34:21 <Hijiri> I can't think of any typeclasses with only a unary operator though
18:34:32 <Hijiri> operation
18:34:46 <Hijiri> or is it operator
18:34:58 <geekosaur> we were just discussing one, actually. IsString
18:35:11 <EvanR> Zemyla: interesting... Text values take 6 words plus the payload, according to the above link. so for many small Text values like in a markup generator adding another word for a pointer or a 64bit number would increases memory usage even more
18:35:16 <geekosaur> its only method is fromString
18:35:24 <Hijiri> oh right
18:35:37 <Zemyla> I think dpk-atk was talking about a unary operation a -> a.
18:36:01 <Hijiri> with no laws?
18:36:06 <Hijiri> oh
18:36:09 <Hijiri> ok nevermind
18:36:11 <Hijiri> I see what you meant
18:36:27 <Hijiri> And that's what I meant earlier too, just I forgot
18:37:20 <EvanR> Zemyla: you can also wrap Text to include your own length as your own optimization to make the tradeoff explicit
18:37:29 <EvanR> if that would help
18:37:33 <dolio> Just a unary operation is probably too general for anyone to care about.
18:37:47 <dolio> Like, is it op . op = id? op . op = op?
18:37:58 <EvanR> op . op = 2op
18:37:59 <dolio> Or no equations at all?
18:38:34 <Hijiri> maybe Endo?
18:38:42 <Zemyla> That's not a typeclass.
18:38:50 <Hijiri> they just asked for an abstraction
18:39:08 <EvanR> "a set of values with an operation a -> a" is just ... A -> A
18:39:19 <EvanR> or Endo A
18:39:25 <dpk-atk> i figured it was too general
18:39:34 <dpk-atk> but it would be nice to have some sort of generalized Not fucntion
18:39:37 <EvanR> its certainly useful
18:39:39 <dpk-atk> like there is a generalized id function
18:39:50 <EvanR> but its already easily identified as something that we already have
18:40:22 <Zemyla> dpk-atk: It has to be "not" in relation to some binary relation.
18:40:43 <Hijiri> it could just be involutive
18:40:49 <Hijiri> depending on how general of a not it has to be
18:40:54 <EvanR> dpk-atk: so... op . op = id ?
18:41:18 <Hijiri> oh, I guess an involutive would be not in relation to equality
18:41:41 <dpk-atk> given some dictionary {a, b} not a -> b, not b -> a
18:41:47 <dpk-atk> and u can even take it further
18:41:51 <dpk-atk> with things like inc and dec
18:41:56 <dpk-atk> so {a, b, c}
18:41:58 <dpk-atk> inc a -> b
18:42:05 <dpk-atk> so on and so forth
18:42:12 <EvanR> im lost
18:42:18 <Hijiri> what do you mean by dictionary
18:42:32 <Hijiri> and by the arrows do you mean =
18:42:37 <Hijiri> or something else
18:42:42 <dpk-atk> data mytype = a | b
18:42:45 <dpk-atk> and yeah
18:42:49 <dpk-atk> = by arrows
18:43:07 <EvanR> this seems like a set or cyclic order
18:43:11 <Hijiri> it's still not clear what laws it should have in general to me
18:43:11 <dpk-atk> its just that I wanna write "not mytype"
18:43:18 <dpk-atk> and i dont want conflicts with bool
18:43:55 <Hijiri> I didn't know wuzzy went on #haskell
18:44:11 <Hijiri> or if I did, I forgot
18:44:13 <dpk-atk> not so much laws but just an interface to generalize some commonly stolen function names :O
18:44:15 <geekosaur> I think an IsBool has been proposed a few times, but Bool is already given the side eye a lot (see "boolean blindness")
18:44:22 <dpk-atk> yeah exactly
18:44:24 <dpk-atk> IsBool
18:44:30 <dpk-atk> thats exactly what im looking for
18:44:34 <geekosaur> that said, dependoing on what you are doing you might be able to fake it with a method on Enum
18:44:37 <dpk-atk> i guess there isn't such a thing
18:44:37 <Hijiri> PureScript has a typeclass for boolean algebras
18:44:42 <EvanR> how is this Bool-like at all
18:44:45 <Hijiri> but I think the only nontrivial instance there is Bool
18:45:06 <EvanR> Hijiri: i thought that was for doing javascript operations on anything
18:45:14 <EvanR> like && and ~
18:45:16 <EvanR> like && and !
18:45:26 <Hijiri> I thought they just wanted to generalize Bool
18:45:36 <Hijiri> I don't actually know that much about PureScript though
18:46:04 <thimoteus> https://pursuit.purescript.org/packages/purescript-prelude/0.1.4/docs/Prelude#t:BooleanAlgebra
18:46:28 <dpk-atk> wat if you had a unary operator in some typeclass like inc
18:46:31 <EvanR> oh its a lot different now
18:46:42 <dpk-atk> couldn't u generalize iterating out all the types then
18:46:46 <EvanR> dpk-atk: we already have increment, its called succ
18:46:55 <Hijiri> I didn't know there was the a -> b instance
18:47:00 <Hijiri> though that makes sense
18:47:17 <EvanR> > succ 'x'
18:47:18 <Hijiri> since you could encode "subsets of a" as a -> Bool
18:47:19 <lambdabot>  'y'
18:47:24 <dpk-atk> ohhhhh
18:47:26 <dpk-atk> i can use enum
18:47:32 <dpk-atk> to sort of do the not thing
18:47:34 <dpk-atk> alright thank
18:47:36 <dpk-atk> s
18:47:36 <Hijiri> succ doesn't wrap though
18:47:44 <dpk-atk> oh it doesn't
18:47:46 <dpk-atk> hmm nvm
18:47:47 <EvanR> you may be thinking of a cyclic order
18:47:53 <dpk-atk> yea
18:48:43 <EvanR> class Eq a => Cyclic a where
18:49:00 <Zemyla> I wish Enum had a succMaybe function.
18:49:04 <EvanR>   cyclicCompare :: a -> a -> a -> ?
18:49:32 <EvanR> ? = Bool i guess
18:49:35 <geekosaur> make it on Bounded
18:49:48 <Zemyla> succMaybe, predMaybe, toEnumMaybe, fromEnumMaybe.
18:49:51 <geekosaur> you can then fake it by checking for maxBound and cycling to minBound
18:50:06 <dpk-atk> yeah
18:50:08 <dpk-atk> that sounds about right
18:50:16 <dpk-atk> but too complicated for my usecase ^^
18:50:21 <EvanR> Zemyla: theres a package.. https://hackage.haskell.org/package/prelude-safeenum-0.1.1.2/docs/Prelude-SafeEnum.html
18:50:41 <Iceland_jack> Zemyla: 
18:50:41 <Iceland_jack>     succMaybe n =
18:50:41 <Iceland_jack>       case succ n of
18:50:41 <Iceland_jack>         IsUndefined -> Nothing
18:50:45 <Iceland_jack>         m           -> Just m
18:50:48 <Iceland_jack> :)
18:50:51 <EvanR> lol
18:50:53 <Iceland_jack> <Iceland_jack> isUndefined x = unsafePerformIO $ catch ((unsafeCoerce x :: IO ()) >> return False) (const $ return True :: SomeException -> IO Bool)
18:50:57 <Iceland_jack> <Iceland_jack> pattern IsUndefined <- (isUndefined -> True)
18:51:11 * EvanR uploads this to haskell wiki
18:51:45 <Zemyla> Iceland_jack: Why the unsafeCoerce? That sounds bad.
18:51:53 <Iceland_jack> Joking
18:51:55 <Zemyla> Why not just evaluate?
18:53:14 <Iceland_jack> We need /more/ unsafe* functions
18:54:21 <EvanR> two unsafes make a safe
18:54:32 <Iceland_jack> Hot dog, EvanR's right
18:54:52 <geekosaur> Zemyla, there's s omething of a running joke about unsafeCoerce trickery
18:55:04 <Zemyla> I've actually created a type before which was a wrapper which detected whether a value had been evaluated.
18:58:59 <EvanR> dpk-atk: if you figure out how to say what you want with some combination of existing classes like Enum and Bounded and Eq, you could use constraint kinds to make a synonym for the combination of these three...
18:59:20 <EvanR> and the utilities to work with types like that can be regular functions
19:07:12 <Zemyla> So what happens if you get and use setjmp/longjmp as FFI functions in Haskell?
19:07:39 <EvanR> hilarity ensues
19:08:24 <nineonine> hi everyone
19:08:24 <nineonine> data OptionalParams = forall a. Show a, ToJSON a => OP T.Text a
19:08:24 <nineonine> gives me error
19:08:24 <nineonine> Parse error: ,
19:08:24 <nineonine> how can I fix it ?
19:08:38 <EvanR> if you jump into code that was garbage collected, anything could happen
19:08:54 <LordBrain> put parenthesis around Show a, ToJSON a
19:09:08 <nineonine> thanks :3
19:10:14 <EvanR> ... actually i have no idea, since setjmp seems to assume C environment
19:10:47 <pikhq> The answer is probably "things break in an interesting way".
19:11:19 <scshunt> or possibly not that interesting
19:12:47 <EvanR> the sentence from the man page "Some kind of subtle or unsubtle chaos is sure to result." could be copied and pasted as the description of the majority of things you can do in C
19:12:59 <geekosaur> they're asking for trouble anyway, setcontext/getcontext are (slightly) better
19:14:25 <geekosaur> ...but I note they were removed because they basically existed to cover the (ab)use case of setjmp/longjmp to implement green threads manually
19:17:05 <hackrilege> ok i understand the definition CoFree now, but i dont understand why it is the dual of Free
19:17:39 <hackrilege> Free = Fix (Compose (Either a) f)
19:17:40 <hackrilege> Cofree = Fix (Compose ((,) a) f)
19:17:58 <Iceland_jack> First you must understand how Either is dual to (,)
19:18:04 <hackrilege> aha
19:18:21 <Iceland_jack>     fst :: (a, b) -> a
19:18:21 <Iceland_jack>     snd :: (a, b) -> b
19:18:21 <Iceland_jack> vs
19:18:24 <Iceland_jack>     Left  :: a -> Either a b
19:18:27 <Iceland_jack>     Right :: b -> Either a b
19:18:51 <hackrilege> the later returns the same type
19:18:57 <hackrilege> from different arguments
19:19:05 <hackrilege> the former is the converse
19:19:09 <Iceland_jack> flip the arrows, type Pair = (,)
19:19:26 <Iceland_jack>     fst  :: a <- Pair   a b
19:19:26 <Iceland_jack>     Left :: a -> Either a b
19:19:35 <Iceland_jack> vs
19:19:35 <Iceland_jack>     snd   :: b <- Pair   a b
19:19:35 <Iceland_jack>     Right :: b -> Either a b
19:19:45 <hackrilege> ok
19:19:59 <hackrilege> but Pair and Either are different
19:20:09 <hackrilege> data Pair a = Pair a a
19:20:23 <hackrilege> data Either a b = Left a | Right b
19:20:29 <EvanR> data Pair a b = MkPair a b
19:20:31 <Iceland_jack> hackrilege: Imagine I wrote
19:20:32 <Iceland_jack>     type Pair a b = (a, b)
19:20:32 <Iceland_jack> forget 'Pair a = P a a' for now
19:21:17 <hackrilege> thats a nice convention for disambiguating the Constructor from the datatype for newtypes written using data thanks EvanR
19:21:25 <juanca_> Hi everyone, i was wondering if there's something like ">>" for applicative
19:21:34 <Ralith> geekosaur: you mean makecontext/swapcontext?
19:21:34 <Iceland_jack> juanca_: (*>)
19:21:36 <Iceland_jack> :t (*>)
19:21:37 <lambdabot> Applicative f => f a -> f b -> f b
19:21:59 <geekosaur> I guess those are the latest iteration, yes
19:22:00 <juanca_> Iceland_jack: thank you, newbie mistake
19:22:03 <hackrilege> A a | B b ==== (a,b)
19:22:05 <hackrilege> ?
19:22:28 <LordBrain> juanca_, yeah there is *> and <*
19:22:41 <LordBrain> :type (<*)
19:22:58 <LordBrain> hmm maybe i don't know how to use lambdabot
19:23:10 <geekosaur> just :t
19:23:11 <geekosaur> or @type
19:23:15 <thimoteus>  :t (<*)
19:23:19 <thimoteus> :t (<*)
19:23:20 <lambdabot> Applicative f => f a -> f b -> f a
19:23:22 <LordBrain> oh
19:23:22 <thimoteus> well, without the space ;)
19:23:34 <juanca_> and for >>=
19:23:35 <hackrilege> while Either and (,) have the same kind, one can be constructed when provided only one argument of either type
19:23:39 <Iceland_jack> hackrilege: Not sure what you're asking, I shouldn't have re-used the word Pair
19:23:39 <juanca_> and applicatives?
19:23:42 <Apocalisp> hackrilege: (,) is the product of two types, and Either is their coproduct
19:23:44 <geekosaur> anyway I haven't looked closely at those functions since I ported jnos/linux to solaris... real threads are so much easier >.>
19:24:06 <hackrilege> coAnd = or ?
19:24:07 <Apocalisp> hackrilege: Product and coproduct are duals in a precise sense
19:24:44 <hackrilege> what is the precise sense of product and coproduct?
19:25:03 <Iceland_jack> hackrilege: Are you familiar with (,) and Either? :)
19:25:10 <hackrilege> yes
19:25:27 <Iceland_jack> that's it to a first approximation
19:25:31 <Apocalisp> hackrilege: The product of two types A and B is a type T such that you can go T -> A as well as T -> B (satisfying a universal property).
19:26:06 <Iceland_jack> What Apocalisp is saying means that
19:26:06 <Iceland_jack>     data Foo a b = Foo Int a b
19:26:06 <Iceland_jack> is *not* a product of a & b
19:26:11 <Apocalisp> hackrilege: The coproduct of two types A and B is a type T such that you can go A -> T as well as B -> T (satisfying a universal property).
19:26:23 <hackrilege> A x B = [(a,b)|a<-A,b<-B]
19:26:45 <Apocalisp> yes, the product is the cartesian product
19:27:22 <hackrilege> A + B = [(a or b)|a<-A,b<-B]
19:27:23 <LordBrain> satisfying a univeral property is a nice concise way to put it, if only it really were communicative to those who don't already understand
19:27:46 <hackrilege> A + B = A ++ B
19:27:51 <Apocalisp> LordBrain: it's not really important to the discussion at this point
19:27:54 <hackrilege> if you get my pseudosyntax
19:27:57 <Lisa1157> Hi, im trying to write a quick check property with an extra condition, but keep getting this error Im not sure how to correct: https://dpaste.de/p3iQ#L9 
19:28:31 <LordBrain> its the reason Iceland_jack's example isn't a product
19:28:47 <hackrilege> its not bad t point out that this universal property thing went over my head, and that i should defer it until lter
19:28:58 <Iceland_jack> LordBrain: It's not so difficult to explain if you start slow
19:29:29 <Iceland_jack> Lisa1157: try parens around (count_ints_in_tree integer $ deleteFunction integer tree == (count_ints_in_tree integer tree) -1)?
19:30:15 <Apocalisp> hackrilege: We can go into it later, but for now you can just keep in mind that not every such type is a product
19:30:41 <Apocalisp> e.g. A x B x C is not the product of A and B 
19:31:00 <hackrilege> right, i wouldnt have expected it to be...
19:31:09 <hackrilege> (a,b,c) /= (a,b)
19:31:23 <Iceland_jack> You did ask for the precise sense ;)
19:31:31 <Iceland_jack> For example, is (b, a) a product of a and bd
19:31:33 <Iceland_jack> *b
19:31:48 <hackrilege> its reflexive
19:32:00 <Lisa1157> Iceland_jack: still get the same error with parens
19:32:11 <hackrilege> no
19:32:11 <Apocalisp> ok, let's go into it :)
19:32:31 <hackrilege> A x B x C is not the product of A and B and C
19:32:37 <Apocalisp> hackrilege: Again, the coproduct of two types A and B is a type T such that you can go A -> T as well as B -> T. And...
19:32:38 <hackrilege> is that what you meant?
19:33:40 <hackrilege> ok left and right adjoined
19:33:41 <Apocalisp> hackrilege: For every other type Z for which you can go A -> Z and B -> Z, there is a unique function Z -> T
19:34:16 <hackrilege> a bijection
19:34:32 <Apocalisp> not a bijection
19:34:50 <Hijiri> not T -> Z ?
19:34:53 <hackrilege> (z,t) for all z in Z and t in T
19:35:02 <hackrilege> T <-> Z
19:35:08 <Hijiri> or are we still in product land
19:35:16 <hackrilege> yes
19:35:22 <nitrix> Can someone give me a simple enough example of MonadState in use?
19:35:35 <nitrix> (Not StateT or State)
19:36:02 <shachaf> Another perspective: "P is the product of A and B" means that pairs of functions : E -> A and E -> B are in natural correspondence with functions : E -> P
19:36:03 <LordBrain> niteria, MonadState is the type class which is meant to unify all monads which have the State interface
19:36:28 <LordBrain> so for example, any monad transformer stack which include StateT somewhere in the stack
19:36:44 <shachaf> "S is the coproduct of A and B" means that pairs of functions : A -> E and B -> E are in natural correspondence with functions : S -> E
19:36:55 <LordBrain> as well as State, and some random monad that happens to have the get and put interface
19:37:09 <nitrix> LordBrain: How does it knows how to pull out the StateT from the stack?
19:37:09 <geekosaur> nitrix, think deriving (MonadState Foo)
19:37:13 <hackrilege> going afk for 5 mins, hope i dont lose conection
19:37:14 <nitrix> Oh, nevermind, the instance does.
19:37:23 <geekosaur> newtype deriving, that is
19:37:23 <Apocalisp> hackrilege: If you flip all the arrows in the definition of product, you get coproduct
19:37:37 <geekosaur> and yes, that's exactly what newtype deriving does is work out how to do that
19:37:58 <nitrix> I didn't even know you could derive MonadState instances.
19:38:04 <nitrix> Sounds useful :P
19:38:05 <LordBrain> nitrix, MonadState m in the constraint, means its not only a monad, but it also has the get and put functions
19:39:14 <geekosaur> and newtype deriving MonadState is exactly what makes MonadState useful, because it means you can apply get and put to not only actual StateT but derivations of it
19:39:32 <nitrix> Right.
19:39:35 <geekosaur> (I ignore State because these days it's StateT over Identity)
19:39:47 <nitrix> Mhm.
19:39:57 <nitrix> Well, I prefer StateT myself.
19:40:19 <EvanR> i prefer ReaderT!
19:40:26 <LordBrain> State is almost useless, except maybe as a simpler thing to learn before StateT
19:40:37 <EvanR> State is good for party tricks
19:40:54 <nitrix> EvanR: ReaderT as states... mhh?
19:41:01 <EvanR> yeah, ReaderT IO ;)
19:41:18 <nitrix> I guess you could recursively call a ReaderT with ehm... uses of `local` or passing the new state.
19:41:26 <Hijiri> ReaderT IORef IO ?
19:41:36 <nitrix> EvanR: Isn't that defeating the purpose :P ?
19:41:38 <EvanR> ReaderT GlobalJunk IO
19:42:03 <LordBrain> remember, all these transformers are just a shortcut for writing your own monad, which sometimes is better
19:42:33 <nitrix> Agreed. I've actually thought about that a few times.
19:42:43 <LordBrain> but borrowing the interfaces that every haskeller knows, is going to help readability of course
19:42:53 <nitrix> I'm just always scared to screw up the laws.
19:42:56 <EvanR> nitrix: well if GlobalJunk is a mixture of variables, drivers, loggers, whatevers, then its strictly a pain in the ass to arbitrarily take some of those and put them in another layer of transformer just because its called State
19:44:01 <nitrix> Tracking down bugs because of a unlawful Monad implementation sounds terrible.
19:44:01 <EvanR> and deal with requisite helpers to modify some of the variables
19:44:27 <LordBrain> the nice thing about the transformers, is you can make a type synonym defining your monad stack as a single monad, and if you decide later on to actually write a custom monad instead, you might be able to get more efficiency or whatever and you don't have to touch all the type signatures which use the synonym.
19:44:53 <nitrix> Right.
19:45:26 <EvanR> jargon question is "inference rule" the same thing as "deduction rule"
19:45:34 <nitrix> So far I was staking transformers, and manually accessing each depths depending on the operation I needed to do.
19:45:42 <nitrix> But I didn't know I could derive MonadState.
19:45:50 <nitrix> Brilliant (:
19:46:42 <nitrix> LordBrain: geekosaur EvanR Thanks.
19:46:44 <LordBrain> you dont necessarily have to use a monad, since we have rebindable syntax, i actually like the "indexed monad" approach, but there isn't as much library support for that route...
19:47:25 <Monster2016> Hello :-)
19:47:29 <LordBrain> to see what i mean, look at the effect-monad package, its cool
19:48:01 <LordBrain> the only real issue is the whole haskell ecosystem is built around regular monads..
19:48:55 <LordBrain> but if you want to make the library support, you can help with that little chicken and the egg problem. ;)
19:50:01 <EvanR> indexed monads are pretty cool, but ive heard pushback
19:50:21 <dwynwen_ddlleyw> Every time I check this channel I am slapped with words I don't know 
19:50:23 <auwooo> WELCOME TO ##hacker , WE ARE THE MINT HACKER GROUP CHANNEL ... .OFFICIAL WEBSITE FOR MINT  HTTP://MINT.COM AND http://THEHACKERNEWS.COM ... .
19:51:01 --- mode: ChanServ set +o geekosaur
19:51:19 --- mode: geekosaur set +b *!*auwooo@*unaffiliated/skraito-0x71
19:51:21 <LordBrain> EvanR, pushback besides the library support?
19:51:21 --- kick: auwooo was kicked by geekosaur (auwooo)
19:51:38 <LordBrain> what are the downsides?
19:52:27 <geekosaur> guess I need to copy my support stuff onto the laptop if I'm going to be stuck using it as the reliable connection :/
19:52:28 <EvanR> control flow can be weird
19:52:38 <EvanR> loops
19:52:51 <EvanR> you cant do a loop unless you end in the same "index state" you started
19:52:57 <EvanR> so it kind of cant do anything
19:53:30 --- mode: geekosaur set -o geekosaur
19:53:31 <EvanR> (as far as the index goes)
19:54:10 <EvanR> you cant do a conditional update to the index
19:58:43 <LordBrain> you can do loops which don't change the index tho, and so, if your index is just used for things like storing variable names and access rights and so forth, that is fine.
19:59:30 <EvanR> specifically, each iteration of the loop must enter and leave in the same state the whole loop started in
20:00:17 <LordBrain> no, the same index... you can still have state like a regular monad tho, you don't put hte state in the index, just your access to the state... like whether it is rw or read only...
20:00:18 <EvanR> then it will work
20:00:28 <EvanR> yes, the part that is represented in the index
20:00:49 <EvanR> i was thinking about parts of OpenGL could go in there, but even then thats so much
20:00:55 <LordBrain> right, but this is true of regular monads too, its just that the index is always ()
20:00:56 <EvanR> and its still not the whole thing
20:01:16 <LordBrain> you haven't lost any power of the regular monad
20:01:38 <EvanR> no but you added complexity and so it better be worth it ;)
20:01:48 <LordBrain> fair enough
20:01:55 <LordBrain> i think it can be worth it
20:02:07 <LordBrain> but of course, that always has  to be it depends...
20:02:23 <EvanR> a simple `when' like thing cant modify the index
20:02:32 <zv> where is the constructor in a statment like this: `data QueryParam (sym :: Symbol) a`?
20:02:55 <EvanR> it might end up being not complex *enough* to express what the rules of the language are ;)
20:02:56 <zv> I see them all the time
20:03:01 <geekosaur> zv, there isn't one
20:03:13 <zv> what is their meaning?
20:03:22 <LordBrain> the inability to modify the index is part of what makes the index useful tho... i mean if you could simply change to readwrite in the middle of a readonly routine it wouldn't be any static check about readonly-ness at all
20:03:52 <geekosaur> the point of that one is the (sym :: Symbol); that's a kind (the "type" of a type)
20:04:36 <EvanR> LordBrain: in that specific case it makes sense
20:04:43 <zv> thank you geekosaur 
20:04:58 <EvanR> but if you wanted to write a function that did it for some reason, and expose it as a primitive, you couldnt
20:05:14 <EvanR> youll be forced to take 2 branches as lambdas and then make sure they both end up in the same final index
20:05:25 <geekosaur> it's used with stuff that works at type level; you could think of this as being like `data QueryParam a = QueryParam Symbol a` but at the type level instead of the value level
20:05:35 <geekosaur> so it doesn;t have values, it has types
20:09:51 <LordBrain> ok, but if you are to implement a restricted monad, what approach do you prefer? this approach seems to me the most natural.
20:10:47 <LordBrain> or you think its better to just avoid restricted monads at all costs?
20:11:30 <EvanR> no i thought indexed monads are pretty cool if they fit
20:12:00 <EvanR> more ways to easily compute with the index type would help
20:12:02 <LordBrain> i have seen at least one other approach, but i cant even recall it off the top of my head
20:12:45 <EvanR> like if you want an index type which is a bag of tokens, and you can only do something if a particular token is in the bag, at any position
20:13:13 <EvanR> and you dont need to do a bubble sort explicitly to show where it is
20:13:40 <LordBrain> i think the killer app for indexed-monad would be regions, but nobody has implemented that yet, and it will be a while before i ever get aroudn to it
20:15:39 <LordBrain> i'm shy, otherwise i would put in a feature request
20:15:45 <LordBrain> to the effect-monad package
20:16:29 <LordBrain> i don't like to do requests or bug reports generally without providing some code as well, i don't trust people to take it right
20:16:57 <LordBrain> its not like i'm paying for it after all
20:17:03 <EvanR> a real program that uses indexed monads and doesnt feel painful would be nice evidence
20:17:15 <hackrilege> im going to do that
20:18:31 <hackrilege> comparing the indexed monads of atkey mcbride and orchard
20:19:10 <hackrilege> compare; https://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Indexed.html
20:19:10 <hackrilege> to https://hackage.haskell.org/package/ixmonad-0.57/docs/Control-Effect-Monad.html
20:20:45 <LordBrain> hackrilege, that's fine, but just so you know, i'm talking about the "parametric effect monad" version of indexed monads, as in the effect-monad package
20:21:10 <LordBrain> i guess i shouldn't use the word indexed monad for this... :/
20:21:22 <LordBrain> or should i?
20:21:29 <hackrilege> thats the version i chose based on the number of superclasses being excessive in the Lens library
20:23:21 <LordBrain> i'm not that familiar with the lens version
20:23:29 <hackrilege> https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf
20:23:55 <hackrilege> type Atkey m i j a = m (a :={j}) {i}
20:24:38 <hackrilege> not surre what the angular braces are about, probably ignore them
20:25:12 <hackrilege> (>>=)::m {i} {j} a ‚Üí (a ‚Üí m {j} {k} b) ‚Üí m {i} {k} b
20:25:25 <hackrilege> here notice the j
20:26:38 <hackrilege> not quite sure why exactly there are 2 indexes, but im guessing its something like, you might want to change the index type as well as the contents type
20:27:22 <hackrilege> anyway, it seems that orchards way you can dispense of the additional index
20:27:51 <LordBrain> i call those curly braces, angular are <>
20:27:52 <hackrilege> mcbride presents the rigorous equivilance but it boils down to :=
20:27:53 <EvanR> you need two indexes
20:28:04 <hackrilege> not so
20:28:22 <EvanR> indexedBind :: m i j a -> (a -> m j k b) -> m i k b
20:28:30 <hackrilege> see http://stackoverflow.com/questions/28690448/what-is-indexed-monad
20:28:51 <EvanR> each action takes the index from foo to bar
20:28:58 <EvanR> so you know what the preconditions and postconditions are
20:29:49 <LordBrain> the effect-moand gets buy wiht only one index, but has a Plus type operator that facilitates the hoare logic like effect
20:30:05 <EvanR> this is why indexMap :: [a] -> (a -> m i i b) -> m i i [b] cant change the indexes
20:30:24 <hackrilege> type a ~> b = forall i. a i -> b i
20:30:28 <LordBrain> https://hackage.haskell.org/package/effect-monad-0.6.1/docs/Control-Effect.html
20:30:34 <hackrilege> ireturn :: a ~> m a
20:30:42 <hackrilege> ibind :: (a ~> m b) -> (m a ~> m b)
20:30:48 <EvanR> yeah so this is strictly different from effect systems
20:31:15 <hackrilege> please would you elaborate on this difference
20:31:53 <EvanR> https://hackage.haskell.org/package/category-extras-0.52.1/docs/Control-Monad-Indexed.html this is the kind of indexed monad i was describing
20:31:59 <EvanR> you dont seem to be ;)
20:32:47 <LordBrain> yeah, my fault, the word indexed monad was used in two different ways historically, and the effect-monad author has abandoned the term for parametric effect monad instead
20:33:21 <hackrilege> i thought i covered both types, that of mcbride (1 index parameter, with ~> and :=) and atkey (2 parameters, the one i think you mean EvanR, but not the one prefered by LordBrain)
20:34:06 <LordBrain> i wish paremetric effect monad were a shorter phrase...
20:34:27 <hackrilege> if i can get away with only one index id prefer that so i think i will choose the mcbride version
20:34:48 <LordBrain> i don't quite understand the other ways
20:34:54 <LordBrain> i understand the two index thing
20:35:09 <LordBrain> what is the difference between mcbride's and effect-monad tho?
20:35:10 <EvanR> the two index thing seems easy to reason about i dont see how 1 index is equivalent
20:35:11 <hackrilege> we should investigate ~> and :=
20:36:10 <hackrilege> data (:=) :: a i j where
20:36:10 <hackrilege>    V :: a -> (a := i) i
20:36:36 <EvanR> err ....
20:36:42 <EvanR> a i j -> * ?
20:36:52 <EvanR> something -> a i j
20:36:54 <EvanR> huh
20:37:06 <EvanR> a -> i -> j -> * ?
20:38:10 <LordBrain> does V have a fancy name other than the letter?
20:38:11 <hackrilege> http://stackoverflow.com/questions/28690448/what-is-indexed-monad
20:38:11 <hackrilege> im following that
20:38:17 <hackrilege> also check this
20:38:18 <hackrilege> https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf
20:40:47 <EvanR> the accepted answer just made my head explode
20:41:41 <LordBrain> i'm still at CommandIxMonad
20:42:43 <EvanR> ah IxMonad vs MonadIx ....
20:42:56 <hackrilege> this thing EvanR? type f :-> g = forall state. f state -> g state
20:43:44 <hackrilege> it seems to me thats how the additional index is contracted, but i dont get how
20:43:45 <EvanR> that form of index monad, yes, the one in the same box
20:43:47 <LordBrain> the stuff can be difficult to digest at first, but i have a feeling that there is a pay off once mastered
20:43:59 <LordBrain> not to pretend i am there tho
20:44:10 <EvanR> i got f :-> g in isolation
20:44:24 <jdt> how do I access a specific field in a Persistent record? e.g., for: "S.html $ (markdownToHtml $ show (findArticle :: Maybe Article))" I just want to show the "content" field in the "article", not the whole record.
20:44:52 <jdt> I'm sure it's really basic syntax - my Google fu is failing me, though.
20:45:05 <LordBrain> use the content accessor, you can fmap it over the maybe
20:45:11 <EvanR> fmap content findArticle ?
20:45:19 <jdt> okay, thx. I'll run with that.
20:45:28 <EvanR> (findArticle isnt IO ?)
20:46:10 <LordBrain> it has to be...
20:46:18 <LordBrain> he didnt give it any parameter even
20:46:35 <jdt> findArticle <- inHandlerDb $ get (toSqlKey (read articleId))
20:46:41 <LordBrain> oh
20:46:48 <EvanR> without knowing a damn thing about the situation i'd suggest passing the (non-maybe) article into the template as an argument
20:46:52 <hackrilege> so mcbride <-> MonadIx and atkey = IxMonad?
20:47:06 <hackrilege> and Orchard = https://hackage.haskell.org/package/ixmonad-0.57/docs/Control-Effect-Monad.html
20:47:19 <EvanR> prior to that, not finding the article, show a 404
20:47:34 <LordBrain> and according to this answer, effect-monad <-> Katsumata
20:47:40 <hackrilege> is that correct?
20:47:55 <jdt> I know that's frustrating - here's a gist for context: https://gist.github.com/justindthomas/c4b6d891d948f42ad9cefe87d0927b62
20:48:07 <jdt> I'll research fmap, though and see if I can figure that out.
20:48:35 <LordBrain> which is an interesting thing for him to say, because the hackage page credits Orchard and Petricek
20:48:51 <LordBrain> but made no mention of Katsumata
20:50:18 <LordBrain> considering this, it is possible that there are two different variations of "parametric effect monad" as well...
20:50:48 <EvanR> a maze of twisty little passages all alike
20:52:22 <hackrilege> http://www.kurims.kyoto-u.ac.jp/~sinya/index-e.html
20:52:42 <hackrilege> http://dl.acm.org/citation.cfm?id=2535846
20:53:00 <EvanR> ok so with the :-> version you model an "unspecified" precondition
20:53:13 <briansmith> Is there a register allocation library available that models the register set as types, so as to statically guarantee the correctness of allocation?
20:53:16 <EvanR> i blinked when the switch was made
20:53:57 <hackrilege> here is orchard and petricek http://www.doc.ic.ac.uk/~dorchard/publ/haskell14-effects.pdf
20:54:41 <briansmith> e.g. do { counter <- reserve rcx; this_will_fail_to_typecheck <- reserve rcx; }
20:56:24 <EvanR> heh "parametric coeffect comonads"
20:56:48 <EvanR> briansmith: you might want an indexed monad
20:57:01 <LordBrain> i think you could use these approaches to implement regions in an awesome way, you could have a nice static gaurantee for example, if you go lowlevel, about what registers can and cannot be touched by a bit of code, and how much memory can be used.
20:57:06 <EvanR> where the indexed type is a bag of registers
20:57:15 <EvanR> (a type bag)
20:57:25 <LordBrain> oh wow, i didnt even read before typing, but we are all on the same page
20:57:35 <LordBrain> :)
20:57:38 <LordBrain> someone do it!
20:57:43 <LordBrain> lol
20:57:43 <briansmith> Yes, like using type-level-sets, right?
20:57:50 <EvanR> right...
20:57:56 <LordBrain> that's orchard's approach exactly 
20:59:03 <briansmith> I see. I didn't realize the link to orchard was in response to my question.
20:59:15 <EvanR> coincidence i think
20:59:19 <LordBrain> it wasn't, just a coincidence
21:01:09 <LordBrain> So.. alright, since there are four of us now interested in this technology... we should make a communal effort at it
21:02:36 <LordBrain> we only need to tweak this slightly i think https://hackage.haskell.org/package/effect-monad-0.6.1/docs/Control-Effect-State.html
21:03:37 <hackrilege> what!? i just need something like (!!) lol
21:03:38 <LordBrain> he already lets you store the existence of arbitrary varables in and read/write permissions on them in the "index"
21:03:49 <briansmith> So, what's the practical difference between that and the type-level-sets package?
21:04:14 <LordBrain> so that basically gives you the registers, you just name them "rcx" "rdx" so on...
21:04:38 <LordBrain> but this would be far cooler if there were 1) a register allocator
21:04:50 <briansmith> You would build the allocator on top of this.
21:04:55 <hackrilege> i cant see even how you are working on the same thing now
21:05:22 <LordBrain> so instead of just being able to name specific registers, you could say this function needs two general purpose registers with read/write access...
21:05:33 <briansmith> I think there are two use cases.
21:05:46 <briansmith> One would be to embed assembly language code as an EDSL in Haskell.
21:05:52 <briansmith> The second would be to do automatic allocation.
21:05:55 <LordBrain> no
21:06:01 <LordBrain> you can go way further than that even
21:06:06 <EvanR> briansmith: i know there is a package about type level sets, which you could use as a phantom to do what were talking about. and rebindable syntax to get do notation...
21:06:14 <LordBrain> you can build haskell in it
21:06:18 <EvanR> though when i looked at type level sets package it was kind of nuts
21:06:39 <hackrilege> if there was a way to do it i could understand that would be awesome
21:06:46 <hackrilege> like, what about, lose the effects?
21:06:53 <hackrilege> im using Monads as containers
21:07:01 <hackrilege> not as computations
21:07:01 <LordBrain> the embeded assembly is just a beggining.. you could go from there to platform independent "intrinsics"... portable assembly, and from there on up, until finally you have a high level language
21:07:13 <EvanR> indexed containers...
21:07:19 <EvanR> indexed by a container
21:07:23 <EvanR> in your containers
21:07:53 <hackrilege> basically, there is a thin like between Monads and Monoids, and im going with Monoids. your effect environments cannot be Monoids, so lose the effects
21:08:08 <LordBrain> you could write an entire operating system, drivers, memory page allocators, and garbage collectors, everything.
21:08:22 <EvanR> yes but why would you want to ;)
21:08:37 <LordBrain> in a nice gradual latter like gradient from as low level as you want to be, to as high level. IT would Kill C. finally.
21:09:08 <EvanR> index monads are cool *if* it fits ;)
21:09:49 <hackrilege> do you think the presentation of indexed monads could be made more simple if infact we instead talk about indexed Monoids?
21:09:53 <EvanR> the mythological language feature which lets you naturally easily safely rewrite the entire operating system .... dunno
21:09:58 <LordBrain> why would you want to kill c? well... i can think of a few reasons, but one of them that is less practical is the glory of it, so many have tried for so many years.
21:10:38 <EvanR> and implement all algorithms ever
21:10:40 <EvanR> skeptical
21:10:57 <hackrilege> its a simple comonad
21:11:06 <hackrilege> anyway
21:11:09 <EvanR> hackrilege: i dont have an issue understanding indexed monads
21:11:14 <hackrilege> i do
21:11:15 <LordBrain> you'd not only kill c, you'd kill all the attempted c killers too, rust, ats, some others i cant recall at the moment
21:11:17 <EvanR> but yes assembly language instructions are a monoid
21:11:26 <EvanR> er, programs
21:11:30 <EvanR> its a list of instructions
21:11:52 <LordBrain> why on earth would we not want to do this?
21:12:17 <EvanR> i sort of cant stand thinking about even more difficult low level code than usual
21:12:19 <LordBrain> other than the time and effort involved i mean
21:12:29 <hackrilege> because it involves effects and is therefore beyond the specification as a Monoid
21:12:48 <EvanR> not exactly
21:12:49 <LordBrain> hmm hackrilege , i lost track of your thread
21:12:58 <hackrilege> dont go deeper EvanR
21:13:03 <hackrilege> come back
21:13:18 <hackrilege> i want a * more simple * approach
21:13:34 <EvanR> then dont try to program the computer, program math
21:13:38 <EvanR> love the gc
21:13:41 <hackrilege> so lose the effects, and we have Indexed CoMonoids
21:14:08 <hackrilege> and hopefully that tricky extra parameter
21:14:13 <briansmith> Basically, I want to implement a typed x86-64 EDSL, with proper scoping for register allocation.
21:14:34 <hackrilege> also you could explain to me how the mcbride MonadIx manages with fiewer parameters
21:14:41 <LordBrain> why shouldn't the gc be written in a more strongly typed language? 
21:14:48 <EvanR> hackrilege: it doesnt
21:14:51 <briansmith> And then, like LordBrain said, I want to do the same for other assembly languages, and then write a higher-level EDSL that then gets translated into these type assembly languages.
21:14:59 <hackrilege> that makes sense
21:15:07 <LordBrain> ok, i am with you BrianHV 
21:15:08 <hackrilege> it looked like trickery
21:15:10 <LordBrain> briansmith, 
21:15:13 <LordBrain> sorry tab completion
21:15:27 <LordBrain> i already started on it actually, i have a private repo, its a mess tho
21:15:51 <LordBrain> seriously
21:15:58 <hackrilege> in which case what is gained with this fancy sugar?
21:16:05 <LordBrain> i will open it up, and we can join forces
21:16:06 <briansmith> In particular, I'm making an EDSL for crypto primitives that implement arithmetic in prime fields.
21:16:10 <EvanR> hackrilege: that monad is presented in kleisli form, so its just like not providing the initial action
21:16:22 <EvanR> like f . g instead f (g a)
21:16:28 * hackagebot language-c-quote 0.11.6 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.6 (GeoffreyMainland)
21:16:57 <LordBrain> briansmith, i have been gathering all the assembly info into a computer readable form
21:17:00 <LordBrain> for intel
21:17:03 <hackrilege> but this! https://hackage.haskell.org/package/ixmonad-0.57/docs/Control-Effect-Monad.html
21:17:04 <EvanR> so theres 1 fewer parameter, 2 instead of 3 because its not talking about the argument
21:17:31 <briansmith> LordBrain: Have you tried this?: https://intoverflow.wordpress.com/2010/05/21/announcing-potential-x86-64-assembler-as-a-haskell-edsl/
21:17:34 <LordBrain> its a bit of a mess tho, in fact, i called the repo mess
21:17:46 <briansmith> I was thinking about hacking on it, to add the register reservation to it.
21:17:50 <EvanR> and to program with it youd need to write the whole thing in compositional form
21:18:02 <EvanR> which can be awesome or sucky ;)
21:18:25 <LordBrain> is that your blog briansmith ?
21:18:35 <briansmith> No.
21:18:44 <briansmith> I found it using a think called "Google"
21:18:48 <briansmith> it's like email.
21:19:10 <EvanR> is your crypto language going to guarantee constant time operations?
21:19:20 <ntnt> what are good resources for doing declarative / logic / prolog-ish programmin gin haskell ?
21:19:52 <LordBrain> i searched for similar projects, but did not find any, except for nintendo assembly
21:20:12 <LordBrain> maybe google didn't want me to know
21:20:32 <adelbertc> is there an existing type class that abstracts over sum types? something like http://lpaste.net/814520391404879872
21:20:49 <hackrilege> if you have a zipper you dont need an index for your monad right?
21:21:18 <EvanR> its probably better for you to just use Either instead
21:21:21 <LordBrain> https://github.com/blitzcode/neskell
21:22:50 <briansmith> EvanR: Yes, my goal is actually to have it automatically handle several kinds of side channels.
21:22:54 <EvanR> neskell looks kind of awesome
21:23:17 <hackrilege> sorry dropped connection
21:23:17 <hackrilege> if you have a zipper you dont need an index for your monad right?
21:23:17 <adelbertc> EvanR: fair - the one use case I've had is abstracting over Either and something like https://hackage.haskell.org/package/Validation 
21:23:51 <EvanR> indexed zipper
21:23:56 <EvanR> indexed index
21:24:00 <EvanR> fix indexed
21:24:16 <briansmith> Actually, the constant-timeness aspect is relatively easy as the techniques for high-performance constant-time crypto are pretty well-known.
21:24:32 <EvanR> briansmith: is there a name for this project, i want to mention it at my rescheduled-because-no-one-showed-up meetup about crypto
21:25:01 <LordBrain> actually, this is version of neskell i meant to link to, https://github.com/quietfanatic/neskell
21:25:11 <briansmith> EvanR: Where is your meetup?
21:25:22 <LordBrain> it might be less awesome in finished quality, but i liked his asm primitives
21:26:02 <briansmith> EvanR: I am working on https://github.com/briansmith/ring and this is related to that.
21:26:16 <briansmith> Whether it will be its own project or part of *ring* is still up in the air, as is the nature of *ring* itself.
21:26:49 <briansmith> You might be interested in my initial notes for the project at https://briansmith.org/GFp-0
21:29:00 <LordBrain> my brother and i have a rewrite of NSS, in haskell, to be released soon
21:29:15 <EvanR> briansmith: new orleans
21:29:21 <LordBrain> its part of the samizdat project
21:29:29 <briansmith> LordBrain: Interesting. I used to work quite a bit on NSS.
21:29:45 <EvanR> awesome 
21:29:49 <briansmith> I am curious as to why you would start with NSS instead of...anything else.
21:30:08 <LordBrain> we even made the tools like certutil and crlutil so that we could share the testsuite
21:30:25 <briansmith> Wow.
21:30:48 <briansmith> When I rewrote Firefox's certificate validation, I didn't even do that.
21:31:16 <LordBrain> well, that was his decision, and it made some sense at the time, as there were security concerns floating about openssl and gnutls, but also because he wanted somethign that worked the same exact way as firefox due to what we were using it for, but it grew from there..
21:31:31 <geekosaur> "anything" else? (openssl api's a sewer. the openbsd folks who did libressl must have cast iron stomachs...)
21:31:55 <briansmith> Each library has its pros and cons.
21:31:56 <LordBrain> it was important to us to very closely mimic certain aspects of nss's behavior
21:32:12 <briansmith> LordBrain: Did you re-implement mozilla::pkix in Haskell ?
21:32:17 <LordBrain> yes
21:32:21 <briansmith> Wow!
21:32:35 <briansmith> I would have helped you.
21:32:55 <LordBrain> well we're almost done now, but i suppose if you want to be a late comer, we'll welcome you in
21:33:00 <briansmith> (I started re-implementing it in Rust at https://github.com/briansmith/webpki)
21:33:13 <briansmith> LordBrain: What is the goal of your project?
21:33:23 <briansmith> Why did you want it to be so close to Firefox/NSS?
21:35:09 <LordBrain> because the way it is being used is as a plugin to a proxy server that is running locally, we wanted things that work in firefox to just work out of hte box with this setup. The idea of the local proxy is because we're 1) going to implement dnsec there, and 2) implement an extension to dns that makes it more peer to peer and allows therefore for there to be multiple dns-roots as opposed to merely ICANN
21:35:25 <briansmith> geekosaur: I am not fond of the PKCS#11 stuff and the wrappers around PKCS#11 or any of the certificate stuff in NSS.
21:35:30 <hackrilege> brarg
21:35:34 <hackrilege> ciao
21:35:43 <LordBrain> briansmith, join #samizdat
21:42:19 <EvanR> pfenning video lecture 2 for proof theory foundations... we are instantly talking about monads
21:42:55 <EvanR> haskell style... is this really a foundation of proof theory
21:50:39 <EvanR> at least its interesting that the monad laws can be proved
21:58:42 <EvanR> ... and he mentions parametric effect mondas
21:58:52 <EvanR> confluence
22:56:31 * hackagebot kanji 2.0.0 - Perform "Wö (Japan Kanji Aptitude Test) level analysis on Japanese Kanji.  https://hackage.haskell.org/package/kanji-2.0.0 (fosskers)
23:01:31 * hackagebot nanq 3.0.1 - Performs "Wö (Japan Kanji Aptitude Test) level analysis on given Kanji.  https://hackage.haskell.org/package/nanq-3.0.1 (fosskers)
23:26:32 * hackagebot stackage-curator 0.13.2 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.13.2 (MichaelSnoyman)
23:41:40 <fr33domlover> How to I convert an Html value into a Widget (in yesod)? This seems to work: [whamlet|#{myHtml}|] but how do I do this without the QQ?
23:45:39 <ntnt> given a (Map Int v), is there a (log n) operation for "smallest unused key" ?
23:49:27 <fr33domlover> ntnt, i don't know any, but if you keep track of the smallest unused key you could perhaps get that in O(1)
23:49:39 <ntnt> yeah, but then after I do an insert with that key
23:49:48 <ntnt> I need to find the next smallest, and that's not going to work
23:50:55 <jack_rabbit> Why not? That should be pretty easy.
23:50:57 <kadoban> ntnt: You could probably do it based on splitRoot and whatever the name of the functions are that find the min and max in a Map.
23:51:04 <liste> fr33domlover: there's https://hackage.haskell.org/package/yesod-core-1.4.20.1/docs/Yesod-Core-Widget.html#t:ToWidget
23:51:20 <fr33domlover> liste, thanks :)
23:51:38 <fr33domlover> looks like there's an instance for Html, cool
23:52:59 <kadoban> ntnt: (You find out if there's any missing elements in the less of the Map's given by splitRoot, by checking the minimum/maximum elements of it against the size of it, and then recurse either into it or to the other Maps at the same level, depending)
23:53:25 <ntnt> this is O(log n^2) right ?
23:53:26 <ollef> ntnt: use `findMin`?
23:53:40 <ntnt> ollef: find smallest key that is *NOT* used
23:54:20 <ollef> ntnt: so it should return minBound if that's not used?
23:54:41 <ntnt> it's Map Int v
23:54:47 <ntnt> so like -2^63+1 or something
23:55:41 <kadoban> ntnt: Oh, yeah maybe. It's uhm ‚Ä¶ T(n) = 2 Œò(lg n) + T(n/2) or something, which yeah should be O(lg n lg n)
23:56:18 <kadoban> I kinda suspect you can't do it in O(lg n), not sure though.
23:56:33 * hackagebot StateVar 1.1.0.4 - State variables  https://hackage.haskell.org/package/StateVar-1.1.0.4 (SvenPanne)
23:57:41 <ntnt> kadoban: I'm thinking, for the alg you described, it's O(d) to go from "depth d -> depth d - 1", because the split + find min + find max takes O(d) time, and this operation lets us "pick left half or pick right half, decreasing depth by 1"
23:57:56 <ntnt> so it ends up being O(d + (d-1) + (d-2) + ... + 1) = O(d^2)
23:58:07 <ntnt> I think it is do-able in O(log n), but it requires rewriting map
23:58:42 <ntnt> basically, data Map v = Null | Inner Bool v (Map v) (Map v)
23:58:49 <ntnt> where the Bool indicates whether this particular subtree is "full"
23:58:55 <ntnt> where full means "all the keys from min to max are used"
23:59:15 <ntnt> then, to find the min unused in O(log n) time, we just march down the tree, where the Bool is false ... until we find a key
