00:00:10 <YellowOnion> %GC     time      50.7%  (52.2% elapsed)
00:03:15 <Zemyla> You probably want to sort it in some kind of vector instead. Sorting as a list produces and consumes lots of cons cells.
00:07:40 * hackagebot freer 0.2.2.6 - Implementation of the Freer Monad  https://hackage.haskell.org/package/freer-0.2.2.6 (alcabrera)
00:07:40 * hackagebot hopenpgp-tools 0.18 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.18 (ClintAdams)
00:09:27 <YellowOnion> Zemyla, I figured there was a way to use strictness to keep it constant space, mergesort is actually fine for working with lists.
00:10:15 <Zemyla> YellowOnion: Yes, but it still causes a bunch of cons cells to be garbage collected.
00:17:06 <YellowOnion> Zemyla, Yeah I'm just not worried about that at the moment, I want to grasp how to keep memory usage down.
00:19:09 <Zemyla> Split it into large mutable vectors, sort those, and then merge them into a list.
00:20:34 <Zemyla> Also, divide the list into ascending and descending runs instead of splitting it all the way down to 1.
00:27:13 <Zemyla> Anyways, goodnight.
00:27:48 * hackagebot rss-conduit 0.2.0.1 - Streaming parser/renderer for the RSS 2.0 standard.  https://hackage.haskell.org/package/rss-conduit-0.2.0.1 (koral)
01:09:24 <maybefbi> an arrow has a way to lift a (a -> b) to it, but there is no way to lift (Monad m) => (a -> m b). there is also no way to un-arrow the arrow to its inner function. how are arrows used if that is the case.
01:10:48 <Cale> maybefbi: Just like with monads, it depends on the arrow
01:11:47 <maybefbi> Cale, ok. so the definer of the arrow must define a way to use an arrow?
01:12:15 <Cale> maybefbi: Sure -- also, there will be lots of other stuff that will typically be defined along with it.
01:13:47 <maybefbi> Cale, understood
01:13:47 <maybefbi> i know hxt has runX. so runX is the way to use an arrow correct?
01:13:47 <maybefbi> use something like f :: (Arrow a) => a Xmltree XmlTree
01:16:19 <Cale> maybefbi: yeah, I think that was it
01:18:15 <Cale> maybefbi: hxt is a pretty terrible example of an Arrow instance unfortunately -- it's really a monad, the author just decided they liked Arrow notation.
01:20:48 <maybefbi> Cale, ok
01:22:03 <ntnt> is there a way to auto derive something like 'show', but it does a -> StrictByteString
01:22:36 <ntnt> I don't want show, which is too slow
01:23:51 <Tangerine> where should I be placing a .ghci file such that it will work?
01:24:07 <Tangerine> i tried putting it in ~ but that didn't seem to work...
01:24:10 <maybefbi> ntnt, why don't you make your show.
01:24:21 <ntnt> it's too much work
01:24:28 <ntnt> I want to just write "derive ShowByteString"
01:24:31 <ntnt> and have it all work magically for me
01:24:44 <maybefbi> Tangerine, When it starts, unless the -ignore-dot-ghci flag is given, GHCi reads and executes commands from the following files, in this order, if they exist:
01:24:44 <maybefbi> ./.ghci
01:24:44 <maybefbi> appdata/ghc/ghci.conf, where appdata depends on your system, but is usually something like C:/Documents and Settings/user/Application Data
01:24:44 <maybefbi> On Unix: $HOME/.ghc/ghci.conf
01:24:45 <maybefbi> $HOME/.ghci
01:25:06 * hackagebot rss-conduit 0.2.0.1 - Streaming parser/renderer for the RSS 2.0 standard.  https://hackage.haskell.org/package/rss-conduit-0.2.0.1 (koral)
01:25:06 * hackagebot hip 1.0.1.2 - Haskell Image Processing (HIP) Library.  https://hackage.haskell.org/package/hip-1.0.1.2 (lehins)
01:25:06 <Tangerine> $HOME/.ghci is the same as ~/.gchi in linux right?
01:26:36 <maybefbi> ntnt, make sure ShowByteString needs a (Show a) =>, and then convert the output of show into bytestring
01:26:46 <maybefbi> Tangerine, yes
01:26:49 <ntnt> that doesn't get around show being slow
01:27:26 <maybefbi> ntnt, there are ways to auto derive type classes you need to look into those
01:27:34 <Tangerine> strange. I'm doing "vim ~/.ghci", throwing in ":set -W" then saving and quitting
01:27:53 <Tangerine> then when testing with "let f(x:xs) = x" (which should give errors) is not giving errors
01:27:59 <maybefbi> Tangerine, do you start your ghci using stack?
01:28:13 <Tangerine> i start with the command ghci in bash
01:30:43 <maybefbi> Tangerine, which directory in bash do you run ghci from, does that directory have .ghci ?
01:30:54 <Tangerine> im running from ~
01:31:29 <Oejet> Tangerine: Odd, I get the warning in GHCi with your ~/.ghci.
01:31:48 <maybefbi> try putting some simpler ghci like --info and make that work
01:32:01 <maybefbi> or --version
01:32:27 <maybefbi> put that in .ghci
01:32:57 <Tangerine> no difference
01:33:23 <Oejet> Tangerine: Perhaps try putting 'foo' in .ghci. It should say `Not in scope: ‚Äòfoo‚Äô`, when running ghci.
01:33:58 <Tangerine> oh
01:34:02 <Tangerine> i need to chmod it
01:34:08 <maybefbi> ok
01:34:16 <ntnt> is there a builtin / nice way to get the sha512 of an arbitrary haskell data structure via just "derive Sha512Hash" ?
01:35:23 <Tangerine> ahhh
01:35:34 <Tekkkz> Hello! I wanna print the last line of a handle, but ¬ªhGetLine hout¬´ is printing the first ... how to get the last?
01:35:36 <Tangerine> chmoding the .ghci file worked
01:35:48 <Tangerine> what is go-w anyways?
01:36:23 <maybefbi> ntnt, read this https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/deriving.html and this https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/type-class-extensions.html
01:36:33 <maybefbi> ntnt, there are many ways to go about it
01:36:55 <Tangerine> thanks for the help maybefbi
01:36:56 <ntnt> maybefbi: interesting; thanks
01:37:13 <Guest54008> ?src (run)
01:37:14 <lambdabot> Source not found. It can only be attributed to human error.
01:37:14 <maybefbi> Tangerine, ntnt anytime
01:37:37 <Tangerine> also does lambdabot do haskell?
01:39:03 <maybefbi> Tangerine, yes it does. but not sure how. i do not use it much
01:39:57 <Oejet> Tangerine: Did you get the `*** WARNING: /home/user/.ghci is writable by someone else, IGNORING!` when starting ghci?
01:40:15 <Tangerine> Oejet: yes. a CHMOD fixed it
01:45:22 <Oejet> Tangerine: It means that other users on your system could be able to write to .ghci, which would allow them to load arbitrary code into your ghci environment.
01:48:09 <Oejet> Tangerine: So GHCi complaining, and ignoring .ghci is the generally most useful default for this case.
01:49:15 <Tangerine> what does -> mean in this context?
01:49:27 <Tangerine> (+*) :: Integer -> Integer -> Integer
01:49:49 <Tangerine> from what I understand, this means that (+*) is an operator that takes two things and outputs an integer
01:50:58 <Tangerine> but why is it -> from one argument to another argument, and then finally to some output
01:51:59 <Walther> Tangerine: because they're kinda not really arguments as it stands
01:52:22 <Walther> you have a function that will operate on one number, and returns a function that will operate on another number, that will return a number
01:52:25 <Oejet> Tangerine: It's because it's actually not two arguments, but a function which returns a function. Parse the type like this: (+*) :: Integer -> (Integer -> Integer)
01:52:52 <Walther> because it is perfectly valid to have "half-made" functions
01:52:58 <Guest92093> hey! how do int overflows work i haskell? do they just wrap around to negative when they reach the limit of what they can hold?
01:53:09 <Walther> > let add2 = (+) 2
01:53:11 <lambdabot>  <no location info>: not an expression: ‚Äòlet add2 = (+) 2‚Äô
01:53:20 <Walther> > let add2 = (+) 2 in add2 3
01:53:21 <lambdabot>  5
01:53:25 <Oejet> :t (+1)
01:53:26 <lambdabot> Num a => a -> a
01:55:03 <Oejet> > (+) 1 ((+1) 2)
01:55:04 <lambdabot>  4
01:55:32 <liste> > 128 :: Int8 -- Guest92093 
01:55:34 <lambdabot>  -128
01:55:45 <liste> note that Integer can't overflow, it's arbitrary-precision
01:56:26 <liste> > (127 :: Int8) + 1
01:56:28 <lambdabot>  -128
01:57:47 <Guest92093> thanks!
01:58:05 <Guest92093> is Int8 a lot more performant than a regular Int?
01:58:25 <liste> Guest92093: no. I just used it as an example because I can't remember the other limits by heart
01:58:34 <Guest92093> okay :)
02:04:27 <Cale> Guest92093: Int is chosen based on the machine word size, so whichever size it is ought to be the fast one, generally.
02:05:01 * hackagebot cndict 0.7.4 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.7.4 (DavidHimmelstrup)
02:06:48 <Oejet> > (2^31, 2^63) :: (Int, Int)
02:06:51 <lambdabot>  (2147483648,-9223372036854775808)
02:08:18 <str0ngasfck> (2^31, 2^63) :: (Int, Int)
02:08:56 <str0ngasfck> Oejet: haha how to interact with the bot?
02:09:36 <Pessimist> > putStrLn "hi"
02:09:38 <lambdabot>  <IO ()>
02:12:12 <Oejet> str0ngasfck: Prefix the expression with `> `
02:16:50 <str0ngasfck> Oejet: Thanks
02:22:46 <str0ngasfck> > product [4,5,6,7]
02:22:47 <lambdabot>  840
02:22:51 <str0ngasfck> > product [4,5,6,7]
02:22:53 <lambdabot>  840
02:59:48 <guest786> 2016-04-17 15:29 *** tumdedum_ QUIT Read error: Connection reset by peer
03:01:14 <guest786> I have read the SO post about why seq breaks monad laws when used along with undefined, and I understand it may have theoretical implications, but is that a problem even practically?
03:02:38 <guest786> I mean is it bad to use a strict state monad, and maybe to combine it with a seq to say strictify the state (because Strict State is only strict on the pair)?
03:05:02 <Maxdaman1us> That seems like a weird statement.
03:07:12 <Maxdamantus> It should be an issue of partial correctness, not really something to do with monads.
03:07:24 <guest786> Maxdamantus, I mean why is there so much of a big deal made about monad laws being broken in the presence of seq when all those examples use undefined
03:07:47 <guest786> I mean I am unable to see any practical implication of that. I wonder if the problem is merely theoretical
03:07:53 <Maxdamantus> Dunno, but it shouldn't be restricted to `undefined` either.
03:08:21 <Maxdamantus> evaluating `undefined` should be considered the same as evaluating an infinite loop.
03:08:28 <Maxdamantus> let a = a in a
03:09:32 <guest786> So is it possible to even have a state monad in another language which follows the laws precisely?
03:10:03 * hackagebot kyotocabinet 0.1.4 - Mid level bindings to Kyoto Cabinet  https://hackage.haskell.org/package/kyotocabinet-0.1.4 (YurasShumovich)
03:10:16 <Maxdamantus> You would need a language that proves total correctness (like Agda or Idris), not only partial correctness (as Haskell pretty much does).
03:10:34 <Maxdamantus> but it seems weird associating all of this with monad laws.
03:12:03 <guest786> So languages such as ML, Scala etc also cannot implement the state monad in a way that completely obeys all the laws?
03:12:19 <Maxdamantus> I'd say they still obey all the laws.
03:12:30 <guest786> you mean even in Haskell?
03:12:35 <Maxdamantus> Yes.
03:13:16 <guest786> I mean yeah, why cant one say that it follows all the laws except when you use seq along with an non-terminating thing and then these are the exceptions
03:13:21 <guest786> ?
03:13:40 <guest786> I mean we know exactly what happens in those circumstances too
03:13:44 <Maxdamantus> Because the `seq` stuff is still only a special case.
03:13:56 <Maxdamantus> Again, the issue is about using things that are not total.
03:18:21 <mounty> It seems that with Database.{HSQL,HDBC} there is no way to obtain the rowId of rows read from tables.  Is that really so?
03:20:40 <`Guest00000> what does "global constraint requires installed instance" mean? it's an error that cabal gives
03:23:51 <pavonia> mounty: Doesn't getFieldValue work for the ID column?
03:24:42 <Tangerine> is there an more compact way to do pattern matching like this?
03:24:52 <Tangerine> foo _ [] _ = []
03:24:59 <Tangerine> foo _ _ [] = []
03:25:28 <Tangerine> note that foo [] _ _ should not return []
03:26:02 <mounty> pavonia:  I haven't tried that but in psql, "select id from mytable;" doesn't work.
03:27:29 <mounty> Tangerine:  I think you have to re-think your patterns because _ matches []
03:27:48 <Tangerine> well, what I mean is "does not necessarily"
03:28:28 <mounty> Tangerine:  to match a non-null list, use (_:_)
03:28:50 <lyxia> Tangerine: if you have another clause "foo _ (_ : _) (_ : _)", you can follow it with "foo _ _ _" which would match the two cases you mention.
03:28:57 <mounty> Tangerine:  it's not what you mean;  it's how the compiler takes it.  ;-)
03:30:01 <Tangerine> lyxia: I see. In the sense of readability, would you do that?
03:30:04 * hackagebot array 0.5.1.1 - Mutable and immutable arrays  https://hackage.haskell.org/package/array-0.5.1.1 (HerbertValerioRiedel)
03:30:35 <Tangerine> also, is there a quintessential haskell style guide to follow?
03:30:58 <Rembane> There are many.
03:31:05 <Rembane> And some tools to help you.
03:31:34 <Rembane> Tangerine: http://chrisdone.com/posts/hindent and https://wiki.haskell.org/Programming_guidelines
03:44:13 <lyxia> Tangerine: I would in this specific case, but I don't have a clear rule.
03:53:50 <Tangerine> TIL haskell can use unicode operators
03:53:54 <Tangerine> glorious
03:54:25 <maybefbi> our dear leaders have chosen wisely
03:57:53 <Tangerine> Tried to implement a trinary operator map function. Can i simply just take line 5 and use _ _ _ _ to pattern match if any of the lists are empty?
03:57:56 <Tangerine> https://gist.github.com/TangerineCat/c054f23ce711c1eb56dbe9e97583c6a3
03:58:03 <Tangerine> actually, why am I asking, I should jsut try it
04:00:17 <Maxdamantus> @src zipWith 3
04:00:17 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:00:19 <Maxdamantus> er
04:00:21 <Maxdamantus> @src zipWith3
04:00:21 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:00:27 <Maxdamantus> meh.
04:00:31 <Tangerine> the goal is to do it wihout zipWith
04:01:07 <Maxdamantus> Well, the function you have is zipWith3.
04:01:44 <Maxdamantus> so the answer to your question might simply be in an already-written implementation of that function.
04:02:31 <Tangerine> I guess what I'm trying to do is to implement zipWith3 in Haskell for practice
04:04:53 <Maxdamantus> hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.List.html#zipWith3
04:06:14 <Tangerine> ok yay!
04:06:27 <Tangerine> thats exactly what I have now
04:10:09 <runeks> Using Pipes.Network.TCP as PN, why would this make the pipe exit when it yields?
04:10:11 <runeks> connectionEffect sock = PN.fromSocket sock 1024 >-> messageDeserializerPipe >-> messageAwaitAndYieldPipe >-> messageSerializerPipe >-> PN.toSocket sock
04:12:45 <runeks> I want messageAwaitAndYieldPipe to be able to send messages to the remote end by yield'ing a message and receive messages by await'ing them.
04:28:28 <Tangerine> why is (sum .) . zipWith (*) a b equivalent to sum (zipWith (*) a b)?
04:28:40 <Tangerine> and not sum . zipWth (*) a b
04:29:22 <int-index> You probably mean ((sum .) . zipWith (*)) a b
04:29:37 <Tangerine> oops forgot parentheses, but yes
04:29:43 <int-index> That's because you have two parameters to zipWith, not one. Composition deals with one parameter.
04:31:25 <Tangerine>  so as written, is 
04:31:43 <Tangerine> sum . zipWith (*) a b
04:31:49 <Tangerine> trying to make some function sum . zipWith
04:31:55 <Tangerine> and applying it to (*)
04:32:02 <Tangerine> then making some function and then applying that to a
04:40:50 <cocreature> (sum . zipWith(*) a b) x y is the same as sum (zipWith (*) a b x) y
04:47:23 <ntnt> what does extQ of http://hackage.haskell.org/package/syb-0.6/docs/Data-Generics-Aliases.html#v:extQ do ?
04:50:47 <lyxia> ntnt: If an "a" can be cast to a "b" then apply the "b -> q", otherwise apply the "a -> q".
04:52:47 <ntnt> lyxia: ah, that makes so much sense now
04:52:50 <ntnt> even the source code looked weird
04:52:55 <ntnt> but yeah; this makes eense
04:52:56 <ntnt> lyxia++
04:54:07 <ntnt> lyxia: did you somehow know that, or did you just read the source http://hackage.haskell.org/package/syb-0.6/docs/src/Data-Generics-Aliases.html#extQ ?
04:56:26 <lyxia> I read the source :D
05:10:08 * hackagebot sproxy 0.9.5 - HTTP proxy for authenticating users via Google OAuth2  https://hackage.haskell.org/package/sproxy-0.9.5 (ip1981)
05:19:19 <ntnt> what is the consensurs on DeriveGeneric vs DeriveDataTypeable
05:19:55 <telmich> good day
05:20:04 <telmich> where's the right place to report broken links in the documentation?
05:20:36 <telmich> On http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html the link "Generalising Monads to Arrows, John Hughes (http://www.math.chalmers.se/~rjmh/), November 1998:" is broken
05:22:23 <adakr> telmich: report it to the package owner. in this case, the code seems to be hosted on github, so you can make an issue
07:01:00 * hackagebot eventloop 0.8.0.0 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.8.0.0 (sebaslafleur)
07:06:00 * hackagebot twentefp-eventloop-trees 0.1.2.3 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and RedBlackTree  https://hackage.haskell.org/package/twentefp-eventloop-trees-0.1.2.3 (sebaslafleur)
07:06:02 * hackagebot applicative-splice 0.0.0.0 - Write applicative programs in direct style (generalizes idiom brackets).  https://hackage.haskell.org/package/applicative-splice-0.0.0.0 (AkioTakano)
07:09:25 <broma0> which of these FRP libraries currently has the most backing and/or stability? I'm looking to port a webapp i wrote using ghcjs-vdom to a FRP lib
07:43:09 <gromak> Question about parsec: I have a parser which has non-trivial user state. In some cases this parser may consume empty string and yield a result (depending on the state). However, it's guaranteed that this parser can't loop indefinitely. The problem arises when I want to use `many` combinator, because it prohibits parsers that may accept empty string. It there an elegant way to circumvent this restriction?
07:47:42 <heatsink> You could write your own many combinator that allows empty strings
07:47:52 <heatsink> allows parsers to accept empty strings
07:51:35 <gromak> Yes, but ParsecT constructor is private, so the only way I see to achieve it is to copy-paste the whole parsec library. Fortubatelly, I've just found a better solution: use manyTill combinator
08:00:27 <hjulle> Is there a way to see (in GHCi) how much of a list that has been evaluated (without evaluating more)?
08:01:53 <monochrom> I think :print does
08:05:36 <bernalex> monochrom: no
08:05:38 <ertes-t6v> hjulle: :sprint
08:05:46 <bernalex> print and info will show you how much is evaluated on type level
08:05:53 <bernalex> sprint won't be any good either
08:06:08 <bernalex> > let xsxsxs = [1..]
08:06:10 <lambdabot>  <no location info>: not an expression: ‚Äòlet xsxsxs = [1..]‚Äô
08:06:15 <bernalex> @let xsxsxs = [1..]
08:06:16 <lambdabot>  Defined.
08:06:28 <bernalex> > take 3 xsxsxs
08:06:29 <lambdabot>  [1,2,3]
08:06:31 <bernalex> :sprint xsxsxs
08:06:34 <bernalex> :print xsxsxs
08:06:36 <bernalex> oh.
08:06:39 <bernalex> :info xsxsxs
08:06:43 <bernalex> @info xsxsxs
08:06:43 <lambdabot> xsxsxs
08:06:47 <bernalex> @print xsxsxs
08:06:47 <lambdabot> Not enough privileges
08:06:52 <bernalex> ok be that way, lambdabot.
08:07:00 <ertes-t6v> bernalex: your list is too simple
08:07:12 <bernalex> ertes-t6v: ?
08:07:26 <bernalex> there should be a way to show that it's a list of [1, 2, 3, _]
08:07:40 <bernalex> and that it's Enum/Num t => [t]
08:07:41 <ertes-t6v> firstly write a type signature, secondly map a function over it
08:07:48 <ertes-t6v> no
08:07:59 <bernalex> mapping a funcon over it will evaluate the full list (or fail to terminate)
08:08:31 <ertes-t6v> try this:  let xs = map (^2) [1..] :: [Integer]; take 5 xs; :sprint xs
08:08:32 <bernalex> hjulle asked to see "how much has been evaluated", so I assume they meant that an example like mine.
08:09:05 <bernalex> ah that will indeed work. neat.
08:09:20 <bernalex> I don't see why it shouldn't work with my example too though
08:09:29 <MarcelineVQ> Num throws it off
08:10:16 <ertes-t6v> bernalex: because GHC is too smart
08:12:47 <ertes-t6v> bernalex: firstly if the type is too loose, it won't use sharing, because it will consider the list a function
08:13:10 <monochrom> type-class polymorphism keeps xsxsxs :: Num t => [t] as a function that awaits a dictionary before any evaluation can happen.
08:13:13 <ertes-t6v> that happens when it is polymorphic with a context (or when it's actually a function)
08:13:34 <monochrom> it is why the monomorphism restriction was added
08:14:08 <ertes-t6v> secondly GHC seems to see through the "triviality" of a list like [1..]
08:14:21 <monochrom> this is why I stay away from numeric examples when I create examples. I use Char and Bool and () instead.
08:14:50 <monochrom> 1 is not concrete enough.
08:15:29 <ertes-t6v> oh, interesting‚Ä¶  it actually works without the map
08:15:46 <ertes-t6v> i remember a case when it wouldn't work without it
08:16:09 <ertes-t6v> let xs = [1..] :: [Integer]; take 5 xs; :sprint xs
08:30:44 <anxys> j3
08:32:50 <tippenei1> does anyone have a good example of amazon-ka usage?
08:33:03 <osfameron> is Perl still required to build ghc?  e.g. as per https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/Tools
08:36:10 <geekosaur> isn't the "boot" script perl?
08:36:24 * hackagebot tttool 1.6.1 - Working with files for the TiptoiÆ pen  https://hackage.haskell.org/package/tttool-1.6.1 (JoachimBreitner)
08:38:41 <geekosaur> https://github.com/ghc/ghc/blob/master/boot#L1 -- yes
08:39:28 <geekosaur> (minimally updated perl 4, even :p )
08:39:46 <osfameron> great, thanks
08:40:26 <osfameron> gosh yes, that's not very modern Perl :-)
08:41:07 <monochrom> no one wants to update it. I wouldn't want to.
08:41:25 <bernalex> does shake use the perl boot script?
08:42:04 <bernalex> in all fairness, the perl script is only maybe 100 SLOC or something, so it shouldn't be too difficult to update
08:42:25 <monochrom> even "add a command to display haddock in ghci" is a more appetizing project than "update that perl script"
08:42:28 <geekosaur> given that you need ghc to build ghc anyway, maybe it should be rewritten in haskell
08:42:46 <orion> Is there an analogue of "undefined" at the type level?
08:43:05 <monochrom> FSOV of "analogue", Void
08:43:08 <geekosaur> in what sense?
08:43:39 <monochrom> and FSVO2 of "analogue", ()
08:43:52 <orion> "I can stick it anywhere and it will type check"
08:44:04 <monochrom> but perhaps you should go digital, not analogue
08:44:07 <geekosaur> and _ (partial type signatures in ghc8)covers others
08:44:14 <geekosaur> specifically that one
08:44:27 <geekosaur> note "in ghc8"
08:44:34 <orion> I see.
08:45:44 <monochrom> if _ at the term level is a typed hole, is _ at the type level a kinded hole?
08:46:47 <geekosaur> monochrom, how does PolyKinds affect that? >.>
08:47:21 <geekosaur> orion, I think if you want to achieve that pre-ghc8, you need to omit the type signature and provide "hints" for the parts you do know
08:48:02 <geekosaur> e.g. foo x | False = (expression with explicit types where they are known) | otherwise = (actual expression)
08:48:38 <monochrom> "a kinded hole _ :: a0 is found at line 30 column 15. a0 is a rigid kind variable bound at line 15 column 10..."
08:48:59 <geekosaur> also ghc8's unification of the type and kind levels
08:49:15 <geekosaur> (that may actually answer your question, come to think of it...)
08:51:58 <orion> I see.
08:52:15 <orion> So should I be expecting ghc8 any day now?
08:52:46 <geekosaur> not quite. an issue was found in ghc8.0.1rc3 so an rc4 is on the way
08:53:32 <orion> ah
08:53:38 <geekosaur> so hopefully 1-2 weeks. but with this release cycle, who knows...
08:54:07 <geekosaur> (I had a feeling it was going to be significantly delayed when rc1 turned out to have severe issues)
08:56:50 <broma0> anyone ever get errors like "cannoy satisfy -package-id <mypackage>-inplace with `stack build` ?
09:00:49 <fr33domlover> are multi line strings broken using \ new in haskell 2010?
09:04:41 <geekosaur> fr33domlover, no, they were in haskell98
09:05:38 <fr33domlover> geekosaur, for some reason they don't work in my code. I'm editing a Pandoc source file (whose copyright line says 2009) and trying to split a string with \ causes compiler errors
09:05:54 <fr33domlover> oops i mean a Gitit source file
09:07:59 * fr33domlover is trying to move the same string to toplevel
09:09:06 <geekosaur> actually they're also in the 1.4 language report (checking earlier versions is annoying)
09:12:22 <fr33domlover> http://paste.rel4tion.org/334
09:12:25 <fr33domlover> geekosaur, ^
09:12:35 <fr33domlover> am I making a syntax error there?
09:13:08 <geekosaur> hm
09:13:11 <geekosaur> someone reported seeing that in atom's syntax checking yesterday, but not directly in compiling
09:15:47 <tippenein> how do ppl work around the hamlet syntax messing up hlint?
09:16:07 <tippenein> the $forall is causing a parse error, and it blocks all checking
09:17:42 <fr33domlover> tippenein, personally I used hlint long before I started using Yesod and TH :P
09:18:07 <fr33domlover> by that time I think i learned most of the beginner mistakes hlint finds
09:18:22 <tippenein> your suggestion is to stop using hlint?
09:18:33 <fr33domlover> tippenein, depends on why you need it, i suppose
09:18:43 <fr33domlover> i used it to find bad practices in my code
09:19:03 <fr33domlover> i found many, learned a lot until i already knew what hlint was looking for
09:19:09 <fr33domlover> so i didn't need it anymore
09:20:38 <ertesx> note that hlint is entirely subjective, and i don't always agree with its suggestions
09:21:05 <tippenein> ertesx: yeah, that's fine, but I can't even get suggestions because it breaks on parsing
09:21:21 <ertesx> i guess it doesn't support quasiquotes
09:21:35 <ertesx> or perhaps it wants you to have the LANGUAGE pragma enabling it explicitly
09:21:42 <tippenein> quasiquote usually contain valid haskell, but not in the case of hamlet
09:21:57 <ertesx> try with the explicit pragma
09:22:20 <adakr> what is the etymology of "monomorphism restriction"? does it relate to monomorphism in category theory?
09:22:24 <ertesx> {-# LANGUAGE QuasiQuotes #-}
09:22:29 <tippenein> ertesx: yisss, thanks
09:22:36 <ertesx> tippenein: did it work?
09:22:41 <tippenein> it did
09:23:01 <int-e> adakr: no, it derives from monomorphic types
09:23:22 <int-e> (an antonym of polymorphic)
09:23:27 <adakr> int-e: ah, got it :)
09:23:28 <adakr> thanks
09:23:34 <ertesx> tippenein: i started to use pragmas everywhere, because hlint is not the only tool that has trouble without them
09:23:55 <ertesx> most notably haskell-interactive-mode really wants you to use pragmas =)
09:24:12 <fr33domlover> maybe those tools should start reading the cabal file too :P
09:24:52 <ertesx> fr33domlover: note sure‚Ä¶  i don't even mind using those pragmas anymore, because they make my code self-contained
09:25:00 <ertesx> and locality is always a good thing
09:30:27 <fr33domlover> ertesx, i generally agree, but imagine a project like a yesod app with many many extensions everywhere, there are advantages to keeping them listed in the cabal file. But tbh I never tried keeping them in the source files in a yesod app so maybe even in that case you're right :)
09:30:40 <fr33domlover> (i'm working on my first yesod app atm)
09:32:26 <hjulle> Thanks for the help 1.5 hours ago. (was afk)
09:38:15 <ertesx> fr33domlover: yeah, yesod is a beast, but a working haskell-interactive-mode is so important to me that i'd do it anyway
09:39:29 <ertesx> also i'm sure that you can get along with very few extensions in most source files‚Ä¶  the ones that go crazy are the ones containing routes and shakespeare
09:46:31 <ggVGc> what's the easiest way for me to build a 32bit version of this program, using stack and it's currently building as 64bit
09:46:36 <ggVGc> on arch if that matters
09:48:46 <monochrom> run a 32-bit ghc one way or another. (I would use a separate computer or a virtual machine)
09:49:01 <ggVGc> oh :(
09:49:12 <ggVGc> I was hoping I could add something in stack.yaml
09:49:18 <monochrom> (the separate computer or virtual machine is for running a 32-bit linux so 32-bit ghc is riskless there)
09:49:51 <monochrom> OTOH 32-bit ghc for windows runs fine on 64-bit windows
09:50:19 <ggVGc> well, then I might as well set up stack and build it on the server I am trying to deploy to
09:50:25 <ggVGc> since that's a 32bit arch system
09:51:49 <monochrom> in principle, linux has gone multi-arch so that you can also run 32-bit programs on 64-bit linux. but you have to tell your package manager to install 32-bit libc etc first.
09:56:59 <osfameron> how do you import a package when running `ghc -e` ?
10:03:24 <matt-> I've been using Data.Yaml.Parser because I need a yaml parser that supports anchors. It seems to be in a rather experimental and undocumented state. I've been having trouble with it, which in a way is my fault since I'm not familiar with haskell parsers. I've been trying to work from JSON parsing examples and work by analogy. I'm trying to code up a minimal working example of the situation which is problematic for me, but in the
10:03:24 <matt-> meantime, am I missing some other library that is more mature?
10:08:02 <ertes> ggVGc: there is a reasonably easy way with nix
10:09:23 <ertes> in your project root:  cabal2nix --shell ./. > shell.nix && nix-build shell.nix --arg nixpkgs 'import <nixpkgs> { system = "i686-linux"; }'
10:09:26 <ertes> that should do it
10:09:49 <ertes> then you can deploy it directly with nix-copy-closure
10:12:06 <matt-> One of the subissues I'm having is that parseJSON takes parameter Object, which has the single data constructor Object = HashMap Text Value. fromYaml takes parameter YamlValue, which has four data constructors, and I'm having trouble wrapping my brain around them. I was using withMapping to skirt the issue in my actual application.
10:15:07 <lpaste> matt pasted ‚ÄúYamlParser‚Äù at http://lpaste.net/160257
10:17:24 <matt-> I am not using Data.Yaml because I do not believe it supports anchors, but I could be wrong about that as well.
10:19:00 <matt-> Actually, it seems that it may very well support anchors. I didn't realize that "alias" was another name for "anchor".
10:19:32 <matt-> Text.Libyaml may also work for me‚Ä¶
10:24:20 <ertes> ggVGc: just confirmed it works
10:30:12 <matt-> I'm not bothered at all if nobody has input for my YAML parsing issues, but I'm a bit worries that text isn't making it to this channel. Can I get an ACK please?
10:30:37 <ertes> matt-: ACK
10:30:43 <matt-> ertes: ty
10:31:05 <Gurkenglas_> Anyone know a code competition that allows Haskell?
10:31:55 <bizarrefish> Hi all
10:32:39 <Hafydd> Gurkenglas_: the ICFP programming contest.
10:32:44 <Oejet> Gurkenglas_: http://www.icfpconference.org/contest.html is an obvious one.
10:35:49 <Gurkenglas_> I now realize my question was too general. One online one that is open continously, where you can measure up against other solutions. http://theaigames.com/competitions/ai-block-battle is an example, except they only have the Haskell Platform installed :|
10:35:54 <bizarrefish> I'm trying to make the next step into understanding programs and computer science and such. I have grounding in set theory, I 'get' monads and such. I'm curious and read a lot, but when I start coming across words like 'category theory' and 'endofunctors' I struggle. i feel like i'm missing something; like need to force myself away from doing the 1-person equivalent of smiling and nodding. I push thro
10:36:00 <bizarrefish> ugh and sometimes I get some understanding, but I feel I'm missing the bigger picture. What should I study?
10:36:26 <ertes> matt-: i'm not sure what your problem is (maybe missed a bit of backlog), but aeson's type classes don't parse/render text, they parse/render a YAML AST
10:36:28 * hackagebot bloomfilter-redis 0.1.0.1 - Distributed bloom filters on Redis (using the Hedis client).  https://hackage.haskell.org/package/bloomfilter-redis-0.1.0.1 (hesiod)
10:37:20 <ertes> bizarrefish: this seems a bit weird as monads are actually built on endofunctors‚Ä¶  or do you mean monads as in the special case of "monads for programmers"?
10:38:11 <ertes> bizarrefish: to answer your question: you should first have a goal, whether it's understanding something very specific or getting a very specific project done
10:38:17 <ertes> (in my opinion)
10:38:50 <bizarrefish> ertes: I mean I understand monads from a programming perspective; I can implement bind operators, I can read a definition like the continuation monad and understand it 'inductively'.
10:39:08 <matt-> ertes: Yes, I seem to be making a bit of progress. aeson parses JSON, and Data.Yaml seems to convert YAML to JSON and then depend on aeson for further processing. Rubber ducking this definitely helped.
10:39:43 <bizarrefish> But I feel very much a programmer/engineer, when there seems to be a whole world I barely know the language for.
10:39:44 <ertes> matt-: oh yeah, i mixed it up a bit:  yaml actually parses and renders JSON ASTs
10:40:00 <ertes> it takes aeson's types and builds YAML parsers/renderers on them
10:40:10 <ertes> because the formats are similar
10:40:21 <bizarrefish> Understanding such a world, I presume, would expand my mind, and allow me to reason about real world things is less biased ways.
10:40:41 <bizarrefish> Uncovering the true structure of a problem and its solution, etc, yada yada
10:40:59 <matt-> Yeah. The fromJSON type class is a little disconcerting. Am I correct that that would be better called fromYaml in the context if typeclass aliases were supported?
10:41:51 <ertes> bizarrefish: this may be a philosophical point, but maybe there is no "bigger picture" to begin with‚Ä¶  the "bigger picture" has two main subsets of many smaller and more meaningful "pictures":  the subset that makes your transistors heat up, and the subset that deals with statements and proofs
10:42:23 <ertes> bizarrefish: that's why i think you should have a *problem* first
10:42:38 <bizarrefish> I guess it's not so much uncovering a bigger picture that would provide a benefit, rather, looking at more smaller pictures/perspectives.
10:43:11 <adamCS> matt:  Yes, I think so.  I don't know anything about yaml but used Data.Yaml just to be able to write some Haskell data (which were instance of To/FromJSON) as Yaml and then parse it back to Haskell.  For which it worked fine.  But I don't know how any features of Yaml specifically are or aren't supported.
10:43:23 <bizarrefish> My problem is I want to write malleable code, and I believe this can be achieved through the use of optimal abstractions.
10:43:45 <bizarrefish> malleable, as in, code which doesn't lose readability so quickly, as it gains responsibility.
10:44:14 <bezirg> hi, e.g. i have an action :: a -> b -> c -> IO d  , and a bunch of arguments: IO a , IO b, IO c . The obvious way to apply it is  (a >>= (\ a' -> b >>= \ b' >>= c  >>= \ c' >>= action a' b' c')). How can I achieve the same in a "point-free" style? i.e. without coming up with distinct parameter names
10:44:15 <matt-> adamCS: Well, I'm soon to find out. I've also learned a bit by migrating this from Data.Yaml.Parser to Data.Yaml, so I should be able to make it work in Data.Yaml.Parser again if I need to.
10:44:15 <ertes> bizarrefish: in haskell we use algebraic abstractions to achieve that
10:44:39 <ertes> bezirg: liftA3, then join
10:44:46 <bizarrefish> ertes: It seems a lot of these abstractions require the same grounding which I lack. Perhaps that is incorrect, and a result of my being an outsider.
10:44:53 <ertes> bezirg: join (liftA3 action c1 c2 c3)
10:45:16 <matt-> I may lose connection for the next two minutes. Please do not respond to mattpi- until I say "back".
10:45:33 <bezirg> ertes: thanks. does `join` incur performance overhead?
10:45:37 <ertes> bizarrefish: most of them assume some basic group theory or category theory
10:45:43 <bizarrefish> But I see the same kinds of words come up when people talk about a new abstraction in haskell, and I guess I don't know what they mean.
10:45:58 <bizarrefish> So, i need a text in category/group theory
10:46:05 <bizarrefish> hmm
10:46:08 <ertes> bezirg: difficult to answer‚Ä¶  likely it won't, but there may be cases when it does
10:46:11 <bezirg> ertes: also what about an arbitrary number of parameters?
10:46:24 <bezirg> ertes: because I am generating code
10:46:29 * hackagebot bloomfilter-redis 0.1.0.2 - Distributed bloom filters on Redis (using the Hedis client).  https://hackage.haskell.org/package/bloomfilter-redis-0.1.0.2 (hesiod)
10:46:44 <ertes> bezirg: in that case you'd probably use the more general applicative style:
10:46:54 <ertes> join (action <$> c1 <*> c2 <*> c3 <*> c4)
10:47:15 <bezirg> ertes: that looks better, thank you very much!
10:47:32 <ertes> bizarrefish: personally i learned mostly by doing, picking up the necessary concepts as i went
10:47:34 <Gurkenglas_> traverse is to traverse_ as _Left is to?
10:47:53 <monochrom> _Left_ ?
10:47:55 <maerwald> @hoogle m (t a) -> (a -> m b) -> m b
10:48:00 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
10:48:01 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
10:48:01 <lambdabot> GHC.Conc.Sync withMVar :: MVar a -> (a -> IO b) -> IO b
10:48:10 <ertes> bizarrefish: also a lot by reinventing
10:48:12 <Gurkenglas_> (Well, void . _Left, but does lens provide a two-token term for this?
10:48:15 <Gurkenglas_> *)
10:48:27 <Gurkenglas_> void .: _Left I mean
10:48:52 <monochrom> @type _Left
10:48:53 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
10:48:58 <Zemyla> :t void
10:49:00 <lambdabot> Functor f => f a -> f ()
10:49:07 <matt-> back
10:49:08 <bizarrefish> ertes: I guess that's what I tell programmers when I'm educating them
10:49:14 <Gurkenglas_> > traverse putStrLn
10:49:16 <lambdabot>      No instance for (Typeable t0)
10:49:16 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
10:49:16 <lambdabot>        arising from a use of ‚Äòshow_M671554594722535021422821‚Äô
10:49:16 <Gurkenglas_> :t traverse putStrLn
10:49:17 <lambdabot> Traversable t => t String -> IO (t ())
10:49:20 <Gurkenglas_> :t _Left putStrLn
10:49:21 <lambdabot> Either String c -> IO (Either () c)
10:49:21 <bizarrefish> Learn by doing, etc
10:49:26 <Gurkenglas_> :t traverse_ putStrLn
10:49:27 <lambdabot> Foldable t => t String -> IO ()
10:49:33 <ertes> bizarrefish: time to listen to your own advice, i guess =)
10:49:35 <bizarrefish> I got the impression that such an approach was quite limited in the context of this
10:49:42 <bizarrefish> heh
10:49:51 <monochrom> @type _fst
10:49:52 <lambdabot>     Found hole ‚Äò_fst‚Äô with type: t
10:49:52 <lambdabot>     Where: ‚Äòt‚Äô is a rigid type variable bound by
10:49:52 <lambdabot>                the inferred type of it :: t at <interactive>:1:1
10:50:00 <ertes> bizarrefish: it isn't‚Ä¶  i really think what you really lack is not understanding, but problems to solve
10:50:01 <monochrom> is it called _1?
10:50:04 <monochrom> @type _1
10:50:05 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
10:50:06 <Gurkenglas_> :t void . _Left putStrLn
10:50:07 <lambdabot> Either String c -> IO ()
10:51:04 <Gurkenglas_> Traversal s t a b -> Traversal s () a b
10:51:18 <Gurkenglas_> (Of course "Traversal s t a b -> Traversal s () a ()" would make more sense)
10:53:15 <Gurkenglas_> :t (void .:)
10:53:16 <lambdabot> Functor f => (t -> a -> f a1) -> t -> a -> f ()
10:55:55 <Gurkenglas_> Whenever "stack install x" tells me to run "stack solver", that doesn't seem to help. Is there something obvious for me to be doing wrong?
10:57:10 <Gurkenglas_> Among the things it tells me is that there's no .cabal file in ., so I could imagine that I ought to be running "stack solver x" instead, but that works even less
10:57:44 <Gurkenglas_> Here's an example: http://lpaste.net/2292169847682891776
11:01:09 <radix> Gurkenglas_: those messages in stack output aren't very good, they're assuming that you're working on a project when really you're just trying to install lambdabot
11:02:12 <radix> Gurkenglas_: so, you shouldn't be modifying your global stack.yaml and you shouldn't be running solver. however, I'm not really sure there is a good option for you...
11:02:18 <radix> it doesn't seem install takes any --extra-dep arg or anything like that
11:04:12 <eatsfoobars> Gurkenglas_: Perhaps you want to use cabal-install directly. stack is (IMO) more suitable for projects.
11:04:46 <Gurkenglas_> Sure. "cabal install lambdabot", right? Won't that land me in cabal hell after a few such commands?
11:05:39 <radix> perhaps :)
11:05:57 <radix> Gurkenglas_: I filed a bug about this against stack : https://github.com/commercialhaskell/stack/issues/2039
11:05:57 <lpaste> matt revised ‚ÄúYamlParser‚Äù: ‚ÄúYamlParser‚Äù at http://lpaste.net/160257
11:06:30 <ertes> if you don't have to deal with windows, you can go the nix route instead‚Ä¶  it seems to handle things better than stack
11:06:40 <matt-> Yeah, I'm definitely missing something here, becuase I'm pretty sure (Object v) is supposed to refer to a JSON object.
11:08:26 <adamCS> Gurkenglas: you could make a directory, do stack unpack lambdabot and then stack init and then work from there?
11:10:39 <ertes> Gurkenglas: if you don't have to deal with windows, you can go the nix route instead‚Ä¶  it seems to handle things better than stack
11:11:15 <ertes> i wouldn't be surprised if stack is actually inspired by nix, but was designed to be a more "out of the box" experience with an easier learning curve that also works on windows
11:11:55 <Welkin> people use haskell on windows?
11:12:00 <adamCS> ertes: not an expert in either but stack and nix solve different problems though they def overlap.
11:12:25 <adamCS> and yes, stack is easier out of the box
11:12:48 <adamCS> and now that nix has the snapshots, I guess they are getting closer.
11:12:49 <ertes> adamCS: as far as i've seen and understood from the little introduction to stack, it's basically a special case
11:13:05 <ertes> adamCS: "now that nix has the snapshots"?
11:14:32 <adamCS> ertes: the various curated package sets.  I guess you could get the same in nix but it would be harder to go back to an old one, right?  
11:15:07 <adamCS> I know thats only part of stack but it's where it started.
11:15:35 <ertes> ah, to be honest i don't even think it does‚Ä¶  you could do it and basically even write your own custom package sets, but to my knowledge there aren't any ready-made ones
11:15:51 <ertes> i remember reading that it can use stackage, but never tried it myself
11:16:29 <adamCS> Also, stack can use nix for external (non-haskell) deps.  Which is kinda nice.
11:16:30 * hackagebot haskeline 0.7.2.3 - A command-line interface for user input, written in Haskell.  https://hackage.haskell.org/package/haskeline-0.7.2.3 (JudahJacobson)
11:18:10 <adamCS> ertes: This lays out one way of thinking about it: http://www.tweag.io/blog/stack-nix-portable-reproducible-builds
11:18:12 <ertes> yeah, it makes sense for them to be similar‚Ä¶  both are deployment managers, and both deal with dependencies
11:19:06 <adamCS> yeah
11:19:10 <ertes> oh, and both give you reproducibility, except that nix actually enforces it
11:20:30 <adamCS> Nix also seems, to me, less portable.  Other people may not want to install nix just to get your package to build.
11:20:49 <adamCS> but stack is pretty small footprint.
11:21:35 <adamCS> but nix is also much more reproducible.  Which matters!
11:21:36 <ertes> yes, it's definitely less portable
11:21:56 <ertes> it works on most unix-likes, but notably it doesn't work on windows
11:22:21 <adamCS> and it's...touchy on osx
11:22:34 <adamCS> which is apple's fault
11:22:40 <ertes> i don't know, but i've seen people having problems there
11:22:45 <adamCS> but still annoying.
11:23:54 <Gurkenglas> Welkin, better than using something else on Windows. radix, thanks for that filing. adamCS, thanks, that seems to be working.
11:24:06 <lyxia> matt-: your ex.yaml file starts with an array at the root
11:24:08 <adamCS> great!
11:24:19 <ertes> so far i've been fortunate enough not to have to deal with anything other than linux
11:24:37 <ggVGc> I was fairly impressed a few weeks ago. I'd been building this project on linux for a month, then I opened it on windows, ran stack build, and it just worked
11:24:40 <ggVGc> it was amazing
11:24:43 <ertes> not that i like linux that much (i don't), but it surely is the best development and deployment platform, especially for haskell
11:24:57 <matt-> lyxia: Yes indeed. I've just realized that I've been nesting things incorrectly.
11:26:10 <Gurkenglas> Nevermind, install aborted at installing network. Wasn't stack based on getting network to work?
11:27:10 <Gurkenglas> http://lpaste.net/8021145750798860288 <- scrollback shorter than I would have linked
11:27:11 <Gurkenglas> *liked
11:29:41 <Gurkenglas> Can I install lambdabot without network by replacing any calls to something from network with error?
11:30:41 <ertes> adamCS: btw, nix' footprint is small, but it will pull GHC when you compile for the first time, along with all its dependencies‚Ä¶  the full closure of a small haskell package i wrote is 1.3 GiB, 1 GiB of which is GHC (that's not the network traffic, but the unpacked size on the disk)
11:31:33 <ertes> of course most of that will be shared between multiple packages, but it completely ignores stuff that is already on your system
11:36:30 * hackagebot yesod-job-queue 0.1.0.0 - Background jobs library for Yesod. contains management API and web interface. Queue backend is Redis.  https://hackage.haskell.org/package/yesod-job-queue-0.1.0.0 (nakaji_dayo)
11:41:36 <broma0> anyone around here using ghcjs with stack? have you seen this error before: "Could not find package ghcjs-base in known packages"
11:42:38 <geekosaur> stack wasn't about network; minghc was
11:51:07 <matt-> Oof. I'm able to decode a top-level yaml list, but not a nested list.
11:52:02 <ertes> matt-: perhaps you should start with JSON/aeson‚Ä¶  once you've got that working, you can change it to YAML almost trivially
11:52:43 <matt-> ertes: That's a good idea.
11:56:16 <ggVGc> ghcjs uses hilarious amounts of ram √ñ-
11:56:18 <ggVGc> :/
11:59:19 <systemfault> Just curious, define: "hilarious"
12:01:10 <orion> If you have records within records within records, is there any benefit to pulling values out of the deep records and putting them in the top level if none of the other fields will be used?
12:02:53 <orion> For example, if you are performing calculations and the nested records store intermediate values, but your final value is contained within some deep record, if you pull that out and put it in the top level record, would that allow the GC to free up much more memory than otherwise?
12:07:07 <monochrom> Sounds yes, but no guarantee that your code corresponds to your words.
12:09:34 <ertes> orion: GHC won't GC anything referenced from a record that is still alive
12:10:16 <ertes> all you get from pulling it out is less indirection, unless your record structure is flattened by unboxing
12:23:23 <ertes> is there a library with "generic" UI events that would work across various UI frameworks?  like a sort of lowest common denominator between gloss, GTK+, vty, etc.
12:23:44 <maerwald> X bindings? :o
12:24:10 <ertes> maerwald: too specific (vty would be out)
12:24:56 <ertes> actually keyboard events for editors would suffice:  "left", "home", "insert 'a'", etc.
12:26:05 <ertes> background: i need to write a framework-agnostic mini-editor like the ones you find in chat/IM UIs, emacs mini-buffer or an HTML <input>
12:37:20 <ggVGc> does anyone know what this could mean? https://gist.github.com/29b0198ddc5126c6190593f8ef564d0b
12:37:27 <ggVGc> using ghcjs
12:40:27 <Habib> I would love some feedback on my first ‚Äúserious‚Äù Haskell project (you can find it at http://code.alaminium.me/habibalamin/snake/tree/master). I know some stuff would have been better with do notation, but I deliberately tried to avoid it, so I could actually understand how everything can be done with functions.
12:41:02 <Habib> It's still incomplete, but running it gets a little dot on the screen that you can control. Planning to add pills for the snake to eat, plus death when they collide with the walls.
12:41:15 <Habib> Plus growth when they eat a pill
12:41:40 <ggVGc> I don't think you're gonna get many people to sign up for an account there just to check your code, I'm afraid
12:41:46 <ggVGc> could you post it somewhere else?
12:41:53 <Habib> Oh crap, it's private. My bad.
12:42:03 <Habib> Thanks for the heads up.
12:42:12 <Habib> Ok, try now?
12:43:32 <Habib> ggVGc, is that visible to you now?
12:43:40 <lyxia> it is
12:43:47 <Habib> Cool, thanks.
12:44:14 <Habib> Is this a good place to get feedback, or does anyone know a better place
12:44:15 <Habib> ?
12:46:16 <byorgey> Habib: sure, this is a fine place to ask
12:46:24 <byorgey> you can also try posting on the Haskell subreddit
12:46:31 <Habib> Great, good to know, thanks.
12:46:38 <byorgey> Habib: most of the .hs files there give me a 500 error when I try to click on them
12:46:43 <zomg> Habib: I tried to look at the files and it crashes the server :)
12:46:52 <ertes> Habib: i get error 500 when i try to visit a certain file
12:46:56 <Habib> Oh, great \s
12:47:00 <ertes> Habib: tried to view snake.cabal
12:47:10 <Habib> Migrated my GitLab server recently, and getting all sorts of problems.
12:47:19 <Habib> Hidden until least expected.
12:47:26 <ertes> hehe, as usual
12:47:29 <lyxia> heh it worked a minute ago
12:47:32 <Habib> Let me just put it up on GitHub.
12:47:48 <ggVGc> maybe this internet thing isn't really working out
12:47:53 <ggVGc> might be time to give up
12:47:56 <ggVGc> and go back to the old days
12:47:58 <Habib> Well, I moved to a smaller server, as I felt I wasn't using my resources, but if it falls over with just a few people, might need to pay for more.
12:48:02 <Habib> haha
12:48:08 <zomg> ggVGc: editing files in production over FTP ftw
12:48:14 <Habib> lol
12:48:17 <ggVGc> zomg: that's still itnernet
12:48:38 <ggVGc> also, yes, been there done that :(
12:48:44 <zomg> editing files in production over... a phone line through a BBS?
12:48:46 <ertes> everybody says: "decentralise!", and when you actually attempt to do it, this happens
12:48:48 <zomg> :p
12:49:28 <ertes> github should really be called gitcentral or something
12:50:04 <Habib> Okay, here we go, https://github.com/habibalamin/snake
12:51:19 <ertes> Habib: first comment: you probably want to use vty if you want to do something graphical on the console (unless it has to run on windows, in which case you're basically screwed)
12:51:39 <Habib> Yeah, I was trying to do everything with as minimal dependencie as possible.
12:51:44 <Habib> It's just something I do when learning.
12:51:49 <Habib> Try to do everything myself.
12:52:09 <Habib> And no, Windows support is not a priority for me.
12:52:40 <ertes> Habib: next comment: you did not list all your source files in your cabal file‚Ä¶  hackage would reject your package
12:52:50 <Habib> Oh, go on?
12:52:55 <Habib> Ah, I see.
12:53:05 <ertes> you need to list all your source files for executables in 'other-modules'
12:53:15 <hpc> "reject" is a bit strong for what it does
12:53:22 <Habib> I completely forgot about that field.
12:53:28 <ertes> other-modules: Movement Snake Terminal World
12:53:40 <hpc> it was perfectly happy accepting a package of mine that ended up being totally empty
12:53:59 <byorgey> Habib: the Ord instance for Coords can be written as  (y `compare` b) <> (x `compare` a)
12:54:13 <Habib> Nice, thanks.
12:54:21 <lyxia> you get warnings when you cabal sdist and when you upload anyway
12:54:32 <byorgey> the Monoid instance for Ordering is defined to let you do lexicographic things like this
12:56:33 * hackagebot printf-mauke 0.7.0 - A Perl printf like formatter.  https://hackage.haskell.org/package/printf-mauke-0.7.0 (LukasMai)
12:56:35 <Habib> Okay. I've not learnt much about Monoids, but I see it pop up a lot. Seems like RWH might be my next stop (right after I finish the last few chapters of LYAH that I'm procrastinating).
12:56:56 <ertes> Habib: style note: i think your code is too horizontal and that you underused do-notation a bit
12:57:02 <ggVGc> Habib: imo RWH is way more useful to read
12:57:08 <ertes> if you're going to use (>>=) with a lambda, might as well use do-notation
12:57:16 <monochrom> "cabal sdist" is a good test. complete the test by untar-ing the tarball and see what's not inside.
12:57:28 <Habib> ertes: yeah, as mentioned, I tried to avoid do notation to try to understand better how everything is purely functional.
12:57:53 <byorgey> Habib: nah, don't bother with the last few chapters of LYAH.
12:58:25 <Habib> Any reason? I start to feel like a completionist when I'm almost done anyway.
12:58:27 <byorgey> there's nothing particularly wrong with them, but they are not critical, and if you are procrastinating anyway, move on to something else
12:59:19 <Habib> Cool.
12:59:38 <Habib> I'll probably skim through it anyway, but not something to pay too much attention to.
12:59:39 <systemfault> Habib: You might not like RWH, if so... try the cis194 haskell course
12:59:51 <ertes> Habib: reconsider this style:  (,) <$> action1 <*> action2 >>= \(x1, x2) -> ...  -- i think it doesn't buy you anything‚Ä¶  i'd write them on separate lines
13:00:19 <Habib> ertes: will do next time, thanks.
13:00:29 <ertes> Habib: background: you have two actions and you're going to name each result anyway, so i think it's better to keep action with result name together
13:00:47 <Cale> do x1 <- action1; x2 <- action2; ...
13:01:22 <lpaste> tippenein pasted ‚Äúyesod and S3 question‚Äù at http://lpaste.net/160263
13:01:33 * hackagebot aeson-prefix 0.1.0.0 - Hiearchical prefixing for aeson  https://hackage.haskell.org/package/aeson-prefix-0.1.0.0 (JiriMarsicek)
13:01:48 <tippenein> ^ a question about posting to S3 the contents of a file upload form in yesod
13:02:59 <ertes> Habib: but yeah, most comments are about style and little toolchain-related mistakes‚Ä¶  i think your next step is to start using abstractions and libraries
13:03:42 <ertes> Habib: oh, and start using haddock‚Ä¶  it helps both your readers and yourself in six months =)
13:04:45 <Habib> Brilliant. That's good to hear. So RWH, and if I find that not to my tastes, then cis194 haskell. Start getting familiar with the ecosystem/libraries/toolchain + abstractions. Does that sound like some good next steps?
13:05:17 <ertes> not sure about RWH (haven't read it), but the rest sounds like a good plan to me
13:06:07 <Habib> Thanks for all the feedback, guys. :)
13:07:38 <ertes> Habib: as always i recommend reading The Book at some point: http://chimera.labs.oreilly.com/books/1230000000929/
13:07:38 <ertes> it gives you a lot of very useful information related to real-world programming, especially the part about concurrency
13:08:20 <Habib> ‚ÄúThe Book‚Äù sounds very important. All capitalised, and ‚Äúthe‚Äù'd.
13:09:16 <ertes> i call it The Book, because so far it's the best practical engineering resource in book format i've read so far =)
13:10:08 <Habib> Well, that sounds like I should start reading it ASAP. Thanks.
13:10:55 <ertes> Habib: if you're comfortable enough with the basics of haskell, yeah‚Ä¶  you don't need to read the parallelism chapters right now, but basic concurrency will definitely be beneficial
13:11:46 <ertes> chapters 7 through 13 specifically
13:15:42 <Habib> Anyway, once again, thanks for all the feedback & recommendations. I have to go now and actually get some clothes ready for my Ruby job tomorrow before I find myself waking up with no clean clothes.
13:15:48 <Habib> I'll see you next time.
13:16:00 <zomg> No clothes for Ruby job = free to get a Haskell job
13:16:00 <zomg> ;)
13:16:33 * hackagebot aeson-flatten 0.1.0.0 - JSON flatten for Aeson  https://hackage.haskell.org/package/aeson-flatten-0.1.0.0 (JiriMarsicek)
13:16:35 * hackagebot aeson-flatten 0.1.0.1 - JSON flatten for Aeson  https://hackage.haskell.org/package/aeson-flatten-0.1.0.1 (JiriMarsicek)
13:19:49 <erisco> where am I missing NonEmpty a -> NonEmpty a -> NonEmpty a in Data.List.NonEmpty from semigroups?
13:20:35 <erisco> i.e. ++ for NonEmpty
13:25:34 <ertes> erisco: probably `mappend`
13:25:40 <ertes> or (<>) if you import Data.Monoid
13:25:48 <erisco> NonEmpty is not a Monoid
13:26:00 <ertes> oh, of course‚Ä¶  (<>) from Data.Semigroup
13:26:46 <erisco> ah ha :)
13:27:02 <xa0> Semigroups has a lot of useful things
13:27:03 <xa0> Thanks ed
13:31:06 <ertes> there should be an SMP: Semigroup-Monoid-Proposal
13:31:27 <byorgey> ertes: there is.
13:31:34 * hackagebot aeson-prefix 0.1.0.1 - Hiearchical prefixing for aeson  https://hackage.haskell.org/package/aeson-prefix-0.1.0.1 (JiriMarsicek)
13:31:47 <byorgey> ertes: https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
13:33:16 <erisco> hmm can you list comprehend on NotEmpty? I imagine there is an extension for that
13:33:44 <ertes> thanks
13:33:45 <erisco> I ultimately want catMaybes for NotEmpty
13:33:57 <int-index> erisco, MonadComprehensions
13:34:08 <int-index> NonEmpty is a Monad, so...
13:34:31 <johnw> erisco: catMaybes . toList; NonEmpty should be Foldable
13:35:00 <erisco> but then I want a NonEmpty again
13:35:00 <cgrs> hi everyone!
13:35:06 <erisco> boxing and unboxing is such a pain :P
13:35:12 <johnw> erisco: you can't have that
13:35:27 <johnw> erisco: what about a NonEmpty full of Nothings?  You can't get a NonEmpty from that
13:35:45 <cgrs> i'm practising with the 99 haskell problems, and i'm little confused about one of the solutions of the 8th problem
13:36:32 <cgrs> the 2nd solution (the 'alternative' one) https://wiki.haskell.org/99_questions/Solutions/8 : why do i have to write at the end that definition?
13:36:34 <erisco> johnw, yes that's right, thanks
13:36:51 <cgrs> (compress ys = ys )?
13:37:53 <enthropy> cgrs: because the first equation won't match an empty list
13:38:03 <enthropy> or one with 2 elements
13:38:16 <cgrs> enthropy: and what about using it on the guard definition?
13:38:58 <enthropy> cgrs: using what?
13:39:26 <cgrs> enthropy: you're right, i can't think anything possible
13:39:33 <cgrs> enthropy: thanks :D
13:41:39 * hackagebot aeson-prefix 0.1.0.2 - Hiearchical prefixing for aeson  https://hackage.haskell.org/package/aeson-prefix-0.1.0.2 (JiriMarsicek)
13:46:10 <ertes> is there a small type-class for length and splitAt?  i'd like not to depend on mono-traversable and its "highly experimental" Data.Sequences module
13:46:20 <erisco> is there an identifier for Infinity and -Infinity?
13:46:27 <erisco> I am just using 1/0 and -1/0 right now
13:46:50 <ertes> erisco: no, and i'd use (recip 0) and (-recip 0) respectively
13:53:21 <erisco> I also expect a function such as foldr :: (a -> b) -> (a -> b -> b) -> NonEmpty a -> b
13:54:46 <erisco> which is quite easily \g f -> foldr f (g(NE.head xs)) (NE.tail xs)
13:55:29 <int-index> erisco, use `foldr` from Data.Foldable
13:55:39 <erisco> that doesn't have the same type
13:56:14 <int-index> oh, I see
13:59:03 <ertes> erisco: recursion-schemes provides generic catamorphisms
13:59:52 <ertes> but NonEmpty is not an instance unfortunately
14:08:10 <johnw> I have a module that uses Template Haskell to generate a recursor for regular types
14:08:28 <johnw> it could build you a fold function for NonEmpty, although I'm not sure it's not easier just to write your own
14:15:12 <athan> There's Foldable1 from semigroupoids
14:21:40 * hackagebot data-default-instances-base 0.1.0 - Default instances for types in base  https://hackage.haskell.org/package/data-default-instances-base-0.1.0 (LukasMai)
14:21:42 * hackagebot data-default 0.6.0 - A class for types with a default value  https://hackage.haskell.org/package/data-default-0.6.0 (LukasMai)
14:43:13 <Lokathor> so, unboxed vectors of bool are about twice as fast as boxed vectors of bools
14:43:31 <Lokathor> i wouldn't have expected that boxed or unboxed for bool would make as much of a difference
14:44:24 <hpc> i am not looking forward to the day i have to wrestle with boxing
14:44:33 <hpc> pun 100% intended
14:47:26 <Lokathor> import Data.Vector (Vector) --> import Data.Vector.Unboxed (Vector)
14:47:27 <Lokathor> bam
14:47:41 <Lokathor> that was the entire conversion process, in this situation
14:50:36 <ertesx> Lokathor: note that unboxed vectors of Bool are not compact
14:51:42 <ertesx> they use one byte per bit‚Ä¶  for many algorithms you can get a huge speedup by using vectors of Word and doing the bit operations yourself
14:51:45 <Lokathor> 1) could you elaborate on that? (2) benchmark says it runs twice as fast though
14:52:02 <Lokathor> ah, hmm
14:52:19 <hexagoxel> edwardk: github.io lens index leads to (/defaults to) lens-4.11.1. intended? needs doc refresh?
14:53:10 <Lokathor> ertesx, well i need to access all around the vector in a not-quite uniform sort of way
14:53:15 <Lokathor> it's for a cellular automata deal
14:53:25 <ertesx> Lokathor: i attribute most of the speedup to better cache behaviour, because purely from an algorithmic standpoint you'd actually get worse behaviour
14:53:29 <Lokathor> so i'm looking "around" (in a 2d sense) each location on a regular basis
14:54:29 <ertesx> Lokathor: here is my old sieve of eratosthenes code using a compact representation: http://lpaste.net/101980
14:54:58 <ClaudiusMaximus> @hackage bitwise -- my library for bitpacked bool arrays with fast aggregate operations
14:54:58 <lambdabot> http://hackage.haskell.org/package/bitwise -- my library for bitpacked bool arrays with fast aggregate operations
14:56:05 <Lokathor> hmm
14:56:26 <Lokathor> well, this is what i have so far, https://github.com/Lokathor/ludolib/blob/master/src/Util/AutomataGen.hs
14:57:09 <Lokathor> i think the biggest slowdown might even be the initial randomization of the vector, since it requires 1 RNG use per cell of the vector, which is relatively costly compared to the bool stuff i'd bet
14:58:25 <ertesx> note: if you're going for speed, do not use the bitvec library‚Ä¶  for some reason it actually performs worse than Vector Bool, even though it would save memory
14:58:50 <Lokathor> well, I'd prefer speed over space, so i guess i'll stick to vector
14:59:16 <ertesx> you could give ClaudiusMaximus' library a shot
14:59:35 <ertesx> if all else fails a Vector/MVector of Word will most likely give you the best possible performance
14:59:50 <ertesx> interesting note: my SoE implementation above outperforms the equivalent C implementation
15:00:08 <ertesx> both with GCC and Clang
15:01:58 <ertesx> also check out store comonads‚Ä¶  they give you a sort of "double-buffering" along with a nice API, while keeping the speed‚Ä¶  you can even implement parallelisation without polluting your code
15:02:20 <Lokathor> so why would Word and looking for 0 and not-0 be better than Bool?
15:03:02 <ertesx> because Vector Bool is not compact, so you will get a lot of unnecessary cache misses
15:04:34 <Lokathor> alright let's give this a try
15:04:44 <ertesx> cache misses are expensive:  typically a read from the innermost cache will take half a cycle with outer layers becoming progressively worse, until you actually need to do a RAM lookup, at which point you could take tens or hundreds of cycles per read
15:08:09 <ertesx> Lokathor: if you've got an hour to waste, this guy knows what he's talking about (it's about C++, but applies to haskell, too): https://www.youtube.com/watch?v=fHNmRkzxHWs
15:09:15 <Lokathor> i have NOTHING BUT hours to waste
15:09:16 <Lokathor> but
15:09:23 <Lokathor> first i wanna do the thing with Word
15:09:51 <Lokathor> converting the initially randomized Vector Bool into MVector Word seems to be the trickiest part
15:11:45 <ertesx> Lokathor: you don't necessarily need MVector, if you're only doing bulk operations
15:12:22 <Lokathor> uhmmm
15:12:25 <Lokathor> define "bulk"
15:13:05 <Lokathor> http://lpaste.net/160266 this is the main operation, with a flood fill at the end which i expect is also somewhat costly
15:15:39 <athan> Hey yall... I know this is a newb question, but what's the name of the function that tries to group elements of a list by a given _size_?
15:15:49 <athan> S.t. `theFunction :: Int -> [a] -> [[a]]`
15:15:55 <athan> and that
15:16:11 <ertesx> Lokathor: if you do small writes all over the place, then a mutable vector is better, but if you do filter-like operations (e.g. computing the bit in the next time frame from its neighbours in the current frame), then you probably don't lose much efficiency from an immutable Vector, because you're basically doing double-buffering
15:16:13 <athan> `theFunction 2 [1,2,3,4] == [[1,2],[3,4]]`
15:17:02 <ertesx> athan: it's not predefined, but in libraries it's often called 'chunk' or 'chunks'
15:17:19 <Lokathor> well, i only use it as MVector during the ST part where I do all the cellular automata stuff once
15:17:26 <ertesx> @let chunk n = takeWhile (not . null) . map (take n) . iterate (drop n)
15:17:28 <lambdabot>  Defined.
15:17:32 <ertesx> > chunk 2 "abcdefg"
15:17:34 <lambdabot>      Ambiguous occurrence ‚Äòchunk‚Äô
15:17:34 <lambdabot>      It could refer to either ‚ÄòL.chunk‚Äô,
15:17:34 <lambdabot>                               defined at /tmp/mueval1850952926437116466.hs:155:1
15:17:38 <ertesx> oh
15:17:44 <ertesx> @undef
15:17:45 <lambdabot> Undefined.
15:17:52 <ertesx> > chunk 2 "abcdefg"
15:17:53 <lambdabot>  ["ab","cd","ef","g"]
15:18:01 <geekosaur> @index chunksOf
15:18:01 <lambdabot> bzzt
15:18:30 <geekosaur> :t chunksOf
15:18:31 <lambdabot> Int -> [e] -> [[e]]
15:18:36 <geekosaur> (Data.List.Split)
15:18:46 <ertesx> Lokathor: can you express that algorithm as a bulk operation?  i mean: can you do all the updates at once?
15:18:46 <athan> ahh, thank you ertesx 
15:18:52 <hexagoxel> athan: http://hayoo.fh-wedel.de/?query=Int+-%3E+[a]+-%3E+[[a]]
15:20:01 <ertesx> Lokathor: another way to ask the same question: can you express the operation as a comonadic 'extend' on a Store Location Bool?
15:20:05 <Lokathor> ertesx, well, yes. I mean, each cell in the "next frame" is based on the last frame, and you compute one whole frame at once
15:20:32 <Lokathor> i have no idea what a comonadic thing is at all, but i've heard people mention it before with cellular automata
15:20:59 <Lokathor> and right now, yes, i'm doing the double buffering of it all "by hand", so to speak
15:21:41 <ertesx> Lokathor: then go to pure vectors and use store comonads: as a first step they simply abstract away the underlying representation of your array
15:22:01 <ertesx> in other words: you go from Vector to (->)
15:22:19 <Lokathor> but i don't know what a store comonad is >_<
15:23:24 <ertesx> Lokathor: do you see how an array can be represented as a function from positions to items?  Vector Bool ~ Int -> Bool
15:24:09 <Lokathor> well sure
15:26:03 <ertesx> Lokathor: first step to understand stores: the idea is that you write your update algorithm as a pointwise algorithm:  nextFrame :: Frame -> Position -> Bool  -- where the first argument is just the current frame (the bool-vector), the function calculates the next frame's boolean at the given position
15:26:10 <ertesx> (i should really write this up somewhere)
15:28:02 <ertesx> makes sense so far?
15:28:20 <Lokathor> well, Word takes about 6/7ths the time as Bool did
15:28:59 <Lokathor> okay, yes, compute each position of the next frame from the last frame and a position
15:29:13 <ertesx> 6/7 as in ~0.86 or as in "6 or 7"?  i'd expect the latter
15:29:28 <Lokathor> 690ms down to 608ms
15:30:10 <ertesx> better than nothing, but you can probably optimise it further =)
15:30:17 <ertesx> anyway, second step:  you write a function that applies this pointwise algorithm to *all* points:  frameExtend :: (Frame -> Position -> Bool) -> Frame -> Frame
15:30:31 <Lokathor> yes, that's about how it works now
15:30:33 <Lokathor> using forM_
15:31:19 <ertesx> now you express Frame not in terms of a Vector of Bool, but instead as a function from the right position type to Bool
15:31:37 <ertesx> type Frame = Position -> Bool
15:31:48 <ertesx> (this forces you to handle borders properly, btw)
15:32:06 <Lokathor> i alraady do that in fact, the bounds checking that is
15:33:02 <ertesx> third step:  if you add a "current position" to each frame, you get a way to ask for the boolean at the current position
15:33:17 <ertesx> data Frame = Frame (Position -> Bool) Position  -- a frame buffer together with a current position
15:33:40 <Lokathor> o... kay..
15:34:08 <ertesx> you change:  nextFrame :: Frame -> Bool
15:34:21 <ertesx> and frameExtend :: (Frame -> Bool) -> Frame -> Frame
15:35:25 <ertesx> Lokathor: still makes sense?
15:35:32 <Lokathor> nextFrame :: Frame -> Bool ?
15:35:48 <ertesx> yeah, it used to be Frame -> Position -> Bool, but now the position is embedded in Frame itself
15:36:20 <Lokathor> oh so nextFrame says.. if the same position should be on or not in the next frame?
15:36:29 <ertesx> exactly
15:37:03 <Lokathor> alright
15:37:15 <ertesx> does everything make sense so far?
15:37:26 <Lokathor> and then frameExtend also updates the position?
15:38:25 <ertesx> frameExtend f (Frame pic p) = Frame _updatedPic p
15:38:32 <ertesx> _updatedPic is your exercise
15:38:50 <Lokathor> so.. the position never changes?
15:39:27 <ertesx> you give f different positions, but the final frame will have the same position as before
15:40:12 <Lokathor> but you said the type became frameExtend :: (Frame -> Bool) -> Frame -> Frame
15:40:17 <Lokathor> so where's the changing positions there?
15:41:51 <ertesx> frameExtend f (Frame pic p0) = Frame (\p -> _x) p0  -- _x is of type Bool, and it should be the new boolean at position 'p'
15:42:18 <flummz> hi guys, i've got a rookie question, i want to take three parameters and return three modified parameters, and my signature is wrong:
15:42:21 <ertesx> to compute it you need to give 'f' the original frame, but with position 'p'
15:42:21 <flummz> transform :: Int -> Char -> Bool -> (Int -> Char -> Bool)
15:42:24 <flummz> transform 1 'a' True = 2 'b' False
15:42:46 <Lokathor> flummz, (Int,Char,Bool)
15:42:53 <ertesx> flummz: this type corresponds to a function with five arguments that returns a Bool
15:42:54 <flummz> Lokathor: not with tuples
15:42:56 <Lokathor> (2,'b',False)
15:43:09 <flummz> Lokathor: i want to avoid uncurried functions
15:43:34 <ertesx> flummz: the way to do it without tuples is to use continuation passing style:  transform :: A -> B -> C -> (A -> B -> C -> r) -> r
15:43:34 <Lokathor> flummz, the return type has to be a tuple, or other other value that combines what you want into a single value
15:43:59 <Lokathor> ah, or that i guess
15:44:06 <flummz> thinking
15:44:15 <flummz> thanks ertesx
15:45:44 <ertesx> Lokathor: frameExtend is a very small function, btw‚Ä¶  the types almost force you into the right direction =)
15:45:53 <Lokathor> right
15:46:21 <Lokathor> so, what's the type of 'pic'
15:46:30 <ertesx> Position -> Bool
15:46:35 <ertesx> "pic" as in "picture"
15:46:54 <Lokathor> alright, so that's the lookup
15:47:11 <ertesx> yeah, you represent arrays in terms of their indexing function
15:47:21 <Lokathor> and this... is faster?
15:47:34 <ertesx> no speed difference, but more convenient API
15:47:50 <ntnt> haskell is defnitely 'pass by reference', not 'pass by value', and the reference ist to an unevaluated thunk right?
15:48:07 <Rembane> Or evaluated
15:48:11 <Lokathor> you could.. imagine it that way
15:48:14 <Lokathor> ertesx, >_>
15:48:26 <Rembane> But then it doesn't have to be evaluated again so it's cool
15:48:34 <ertesx> ntnt: *if* you get thunks, then yes, there is that kind of indirection
15:49:40 <ertesx> Lokathor: frameExtend f (Frame pic p0) = Frame (f . Frame pic) p0
15:50:08 <ertesx> that's the function that extends your pointwise update to a whole frame update
15:50:20 <Lokathor> but i don't want a better API if it's not faster >_>
15:50:31 <Lokathor> the whole api will be hidden in the back anyway
15:50:54 <ertesx> one thing the API will give you is transparent parallelism
15:51:05 <ertesx> but not at that point; at a later point in your operation chain
15:52:00 <ertesx> at this point all you get is smaller and more readable code (once you make the transition to stores)
15:52:48 <Lokathor> well the constants aren't there for parallelism, like 1000 elements tops
15:52:55 <Lokathor> the overhead would just kill it
15:53:52 <Lokathor> whoops dropped a 0, 10k elements tops
15:54:00 <Lokathor> more like 2k most of the time
15:54:36 <ertesx> then at least you get to write your algorithms pointwise (and if you ever have more elements to work with or many frames to go through, you can easily add parallelism later)
15:55:13 <ertesx> one interesting thing you get is to do 100 frames in one go using parallelism
15:55:24 <Lokathor> well, the number of elements is based on the size of the map. This is for roguelikes, so generally the map won't be wider or taller, there'll just be more floors to go between
15:55:46 <Lokathor> and i only need specifically 5 frames computed
15:55:53 <ertesx> anyway, are you interested?  because we're only one final step away from Store =)
15:56:14 <Lokathor> well, go on I suppose, though i haven't written too much down
15:56:22 <Lokathor> you should write a big blog thing about like like you suggested to yourself
15:56:45 <ertesx> the type signature of frameExtend is a special case of:  extend :: (Comonad w) => (w a -> b) -> w a -> w b
15:57:00 <flummz> ertesx: i don't understand the wikibooks/Haskell/Continuation_passing_style article, should i try to read up on monads first?
15:57:00 <ertesx> and Frame is just Store
15:57:23 <ertesx> Lokathor: data Store s a = Store (s -> a) s
15:58:58 <ertesx> you only write 'nextFrame :: Store Position Bool -> Bool', and then you apply 'extend' to it:  extend nextFrame :: Store Position Bool -> Store Position Bool
15:59:31 <ertesx> flummz: basic CPS is rather simple:  instead of returning a result, you take a continuation function and pass the result to it
15:59:38 <ertesx> squareNonCps x = x*x
15:59:44 <ertesx> squareCps x k = k (x*x)
16:01:06 <flummz> ertesx: and how do i print the result of squareCps 6 ?
16:01:23 <flummz> *CompositionTest> sqareCps 4 print
16:01:24 <flummz> 16
16:01:26 <flummz> okay :)
16:01:34 <ertesx> =)
16:01:38 <flummz> tnx
16:14:04 <ntnt> you know, TH, in practice is alot less cool than TH, in theory
16:14:53 <Squarism> say i have a "data" type MyData. Can i define a variable to be that type (not an instance of the type)
16:15:04 <Squarism> ..like Class c = this.getClass in java
16:15:22 <lyxia> what would you want to do with that
16:15:23 <Squarism> MyData.class
16:16:03 <Sornaensis> what does your data definition look like and what are you trying to accomplish
16:16:05 <Squarism> lyxia, really what i want to store is a "legalCommand" 
16:16:32 <Squarism> So i can match next command with legalCommand 
16:16:36 <Squarism> to see if its legit
16:17:10 <lyxia> In haskell we prefer to do it so that we can know at runtime whether something is legit
16:17:17 <lyxia> at compile time
16:17:26 * lyxia facepalms.
16:18:43 <Squarism> really its a command driven boardgame.. for each command given to "TheGame", i want to be able to return a new state of TheGame where i tell what the next legal command is 
16:19:08 <Sornaensis> Squarism: it sounds like you want to do pattern matching on commands 
16:19:20 <Squarism> yep
16:19:38 <Sornaensis> so just do that :P
16:20:13 <Squarism> well each new  state of TheGame will have new legit patterns
16:21:02 <Squarism> so instead of saving the command i save a pattern matcher? 
16:21:19 <Squarism> ..in the returned state of TheGame
16:21:39 <Squarism> sounds sane?
16:21:42 <Sornaensis> are you determining valid commands from the game state
16:21:45 <Sornaensis> or the previous command
16:22:10 <Squarism> TheGameState (that will be prepared by the previous command)
16:22:31 <Squarism> so yes
16:22:49 <Squarism> on both really
16:22:57 <tippenein> anyone have comments for me on this code: http://lpaste.net/160263
16:23:29 <Squarism> newGameState :: (Command, GameState ) -> GameState
16:24:06 <Squarism> Command being a "subtype"
16:24:11 <tippenein> how can I sequence the operations and keep it in the Maybe mnonad
16:25:15 <lyxia> tippenein: You can't do IO in Maybe
16:28:01 <lyxia> Squarism: that's still quite vague. Maybe apply the command to a GameState and if something's wrong then you know it's not valid?
16:28:16 <tippenein> sure, that makes sense, but how can I post to S3 on successful form submission?
16:29:16 <lyxia> tippenein: what's that Handler type?
16:30:18 <ertesx> Squarism: you have a command language, but after each command the set of valid commands changes?
16:30:40 <ertesx> and you can only check at run-time whether a command is currently valid?
16:30:44 <Squarism> ertesx, yeah i guess that is what im ding
16:31:08 <tippenein> lyxia: it's the Yesod  Handler monad
16:31:36 <Squarism> ertesx, "valid" depends on values of GAmeState 
16:32:06 <ertesx> Squarism: there are countless ways to do it: one way is to actually change the state type, if there is a small set of valid command *sets*:  for example if two players take turns and there is a different command set per player, you can model that with two state types
16:33:07 <Squarism> You mean like PlayerAMove, PlayberBMove? 
16:33:21 <Squarism> or (PlayerId,CommandType)
16:34:05 <ertesx> more like GameStateA, GameStateB, most likely with a common GameState that includes turn-agnostic data
16:34:16 <ertesx> commandThatOnlyPlayerACanRun :: GameStateA -> GameStateA
16:34:31 <ertesx> commandThatChangesToTheOtherPlayer :: GameStateA -> GameStateB
16:34:35 <lyxia> tippenein: isn't it defined by you using their HandlerT transformer?
16:35:33 <Squarism> ertesx, i would prefer to have TheGameState { nextPlayer :: Faction }
16:35:36 <tippenein> I honestly don't know. This is the first time I've touched Yesod and certain things are still "magical" at this point
16:36:12 <Squarism> or TheGameState { nextPlayer :: Faction, legalCommand:[Command] }
16:36:28 <Squarism>  legalCommand :: [Command] 
16:36:50 <ertesx> Squarism: why?  (i'm asking because such preferences often come from experience in imperative languages and how you solve problems there)
16:37:07 <Squarism> im probebly guilty of that
16:37:09 <Squarism> yes
16:37:22 <Squarism> so you mean i should think differently?
16:38:20 <ertesx> Squarism: yeah, i think you should allow yourself that‚Ä¶  such a type mostly makes sense when the set of commands changes dynamically in more chaotic ways, like commands get added or removed by player actions
16:38:38 <lpaste> lyxia revised ‚Äúyesod and S3 question‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/160263
16:38:45 <lyxia> tippenein: ^ perhaps?
16:39:09 <ertesx> Squarism: if you can partition the available commands into fixed sets, you should go with multiple types
16:39:37 <Squarism> ertesx, ok
16:39:48 <ertesx> Squarism: (there are ways to do it with a single type statically, but that's more advanced and probably not appropriate at this point)
16:41:13 <tippenein> lyxia: thanks! that compiles. I have some other issues, but this is progress 
16:41:22 <Squarism> ertesx, im a quite seasoned programmer. Just quite new to 100% FP
16:41:39 <ertesx> Squarism: another way to do it, which i like to use, is not to explain state, but operations in the first place
16:42:01 <Squarism> like return a partial function?
16:42:20 <ertesx> Squarism: data Hangman = InGame [Maybe Char] (Char -> Maybe Hangman) | Lost String | Won String
16:42:53 <ertesx> a value of type Hangman is a game‚Ä¶  if it's InGame, you get a function to supply a guess that gives you a new, updated game
16:43:25 <ertesx> sorry, it should be:  data Hangman = InGame [Maybe Char] (Char -> Hangman) | Lost String | Won String
16:44:04 <Squarism> ertesx, yeah i actually though along those lines
16:44:55 <Squarism> but shouldnt you pass in a "Hangman" also?
16:45:16 <ertesx> a game like yours would look like this:  data Game = PlayerA'sTurn PresentationData (PlayerAMove -> Game) | PlayerB'sTurn PresentationData (PlayerBMove -> Game) | Finished EndPresentationData
16:45:29 <ertesx> nope
16:45:38 <ertesx> the state is not represented in the type
16:46:30 <Squarism> where is the state then?
16:46:52 <ertesx> it's implicit in the code that constructs a value of this type
16:47:50 <Squarism> ah ok
16:48:42 <ertesx> example:
16:48:43 <ertesx> singleCharHangman char = InGame [Nothing] (\playerGuess -> if playerGuess == char then Won [char] else singleCharHangman char)
16:50:12 <ertesx> when the player guesses correctly, the game switches to Won, otherwise the "new"/"updated"/"next frame" game is just the initial game‚Ä¶  that's how you encode state
16:50:32 <Zemyla> Hmm. You'd need to use an indexed monad to enforce the constraint that a move must be for a specific board, yes?
16:50:51 <Zemyla> Like, you can't take a move you would make on move 1, save it, and try to make that move on turn 30?
16:51:18 <ertesx> with this type the distinction must be encoded in the presentation code (the user interface)
16:51:30 <scshunt> ertesx is describing what is known as continuation passing style.
16:51:47 <scshunt> err wait, no
16:51:51 <scshunt> I have it backwards again
16:52:04 <ertesx> scshunt: no, it is in fact CPS =)
16:52:33 <scshunt> ertesx: wouldn't CPS require that singleCharHangman take a continuation as a parameter?
16:54:04 <ertesx> the user of a Game/Hangman has to supply a continuation function
16:54:31 <ertesx> but you really need to stretch the definition of CPS to view this as an instance of it
16:55:09 <tippenein> anyone know where amazonka expects the auth keys? I don't see it documented anywhere
16:55:13 <monochrom> PlayerXMove -> Game is a continuation.
16:55:29 <monochrom> but I think I'm stretching CPS, yes
16:55:47 <monochrom> then again I think a lot of famous people do too, so I'm safe. :)
16:57:14 <Axman6> tippenein: ~/.aws/config, it uses the same files that awscli does
16:57:22 <ertesx> it's not the kind of nicely composable CPS that is related to chaining operations, but it is CPS on some level
16:57:39 <tippenein> Axman6: thanks
16:57:39 <Squarism> ertesx, ok.. think i got what you mean. so char is the game state in this example
16:57:39 <Axman6> tippenein: so it can use anything awscli can (it can get them from the environment too, for example)
16:57:58 <ertesx> Squarism: yeah
16:58:05 <Axman6> tippenein: oops, that should be ~/.aws/credentials
16:58:18 <Squarism> ill try this approach
17:01:26 <Peaker> I wonder why bindings-DSL generates Haskell lazy fields for records representing C data types
17:01:34 <Peaker> (would make more sense for them to be strict/unpacked)
17:03:06 <ntnt> where can I read up about using [d| ... |] together with an inner $(....)
17:03:12 <ntnt> this is sorta like , and ` in lisp macros right?
17:03:15 <ntnt> to quote/unquote parts
17:06:07 <monochrom> yes, look for docs and tutorials on "template haskell"
17:07:09 <monochrom> but it takes a while to learn
17:21:54 <ntnt> how do I put a new line in a quasiquote?
17:22:02 <ntnt> i.e. [d| f :: Int -> Int \n f x = x + 1 |]
17:22:09 <ntnt> I'm having problem with the \n being interpreted as a newline
17:22:49 <scshunt> ntnt: you need to use a literal newline
17:22:53 <scshunt> there are no escape sequences in quasiquotes
17:23:31 <ntnt> hmm; I'm getting parsing errors
17:23:48 <ntnt> oh wait
17:23:49 <ntnt> it works now
17:23:51 <ntnt> thanks!
17:24:31 <Lokathor> ertesx, i'm getting around to that video
17:24:42 <Lokathor> his first big advice is "avoid linked lists"
17:24:44 <Lokathor> i chuckled
17:27:38 <monochrom> avoid linked lists for what purposes?
17:27:52 <ntnt> https://gist.github.com/33a88ba06ed75966df7d4162a9cd3942
17:27:57 <ntnt> why does the $fname not expand to an "f" ?
17:28:06 <ntnt> does [d| ... |] disallow slicing ?
17:28:40 <scshunt> ntnt: yes
17:28:51 <ntnt> scshunt: so what is the next best thing I can do ?
17:29:00 <ntnt> I want to define a function with the particular name of f
17:29:03 <ntnt> not f_some_random_number
17:29:07 <scshunt> ntnt: build the expression tree yourself
17:29:13 <scshunt> or take the quasi-quote and change the name
17:29:20 <alexashka> basic question: I'd like to do a guard, but inside a do block. So I have a Reader and I'd like to fetch the environment and then have a bunch of guards based on the values in that environment. What's a good way to go about achieving that?
17:29:43 <monochrom> multi-way if
17:30:13 <alexashka> the nested if's look yuck :(
17:30:14 <Lokathor> monochrom, video is about performance (https://www.youtube.com/watch?v=fHNmRkzxHWs), and specifically avoiding linked lists for data locality purposes
17:31:18 <scshunt> alexashka: case
17:32:07 <alexashka> cases afaik are for matching against data type - not so much a > 5, b < 3
17:32:19 <monochrom> the sentence "you want no more linked lists after GHC optimizes your code" is true. but that's different from "you want no linked list in source code"
17:32:42 <Lokathor> right, he's talking about std::list, which is a double linked list i guess
17:33:28 <monochrom> because linked list is a great control structure (for-loop, generator) that reads nice at source code level and can be optimized away and is very performant afterwards
17:34:22 <Lokathor> well i guess C++ does less transformation
17:34:22 <monochrom> of course you want to limit yourself to the standard Prelude list functions that are known to fuse, ensuring disappearance.
17:35:16 <Lokathor> today is all about Vectors
17:35:19 <Lokathor> and MVectors
17:35:44 <Lokathor> and cellular automata with said vectors and mvectors
17:37:21 <Lokathor> https://github.com/Lokathor/ludolib/blob/master/src/Util/AutomataGen.hs
17:38:11 <Peaker> monochrom: I think explicit laziness - and distinguishing lazy streams from linked lists - could help (the former is useful, the latter less so)
17:38:32 <Peaker> (though that's not really usable in a Haskell context, it's the direction we're taking in Lamdu)
17:42:08 <Tangerine> say you have a function that generates an infinite number of primes
17:42:19 <Tangerine> what exactly is it in terms of Haskell?
17:42:35 <Lokathor> allPrimes :: [Integer]
17:42:47 <Lokathor> or like, what's the actual code you mean?
17:43:11 <Tangerine> so what does allPrimes :: [Integer]
17:43:21 <Tangerine> its a function that doesn't take any arguments?
17:43:28 <flummz> it "generates an infinite stream of primes"
17:43:40 <flummz> the type of allPrimes is a constant (and infinite) list
17:44:09 <Sornaensis> > let strip (x:xs) = x : strip [z | z <- xs, z`mod`x/=0] in take 20 $ strip [2..]
17:44:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
17:44:12 <Lokathor> well, sure. if you wanted something that takes an input, like "give the first X primes", that's different
17:44:51 <monochrom> any reason you say "function" to begin with?
17:44:59 <flummz> allNs :: [Integer]
17:44:59 <flummz> allNs = [0,1..]
17:45:06 <flummz> > take 10 allNs
17:45:08 <godfreygyz> can somebody tell me how to use randoms in System.Random? I want to get a list a random Int and pass it to one of my function in main. thx
17:45:08 <lambdabot>  Not in scope: ‚ÄòallNs‚Äô
17:45:09 <flummz> [0,1,2,3,4,5,6,7,8,9]
17:46:09 <Tangerine> oh no
17:46:23 <Tangerine> i think I tried computin gsomething that doesn't work and now my vm is frozen 
17:46:24 <Lokathor> godfreygyz, gen <- newStdGen; let myRandomList = randoms gen; ...
17:46:45 <flummz> Tangerine: ghci/hugs can use up all ram very quickly :)
17:46:48 <Lokathor> Tangerine, try Ctrl+C
17:46:54 <Tangerine> didn't work :(
17:46:59 <Lokathor> might have to hit it a few times ?
17:47:01 <Tangerine> its ok its a vm so I can just restart
17:47:05 <Lokathor> fair
17:47:07 <flummz> Tangerine: is your system trashing because it's ram is used up?
17:47:13 <Tangerine> flummz I think so
17:47:23 <godfreygyz> thanks Lokathor
17:47:24 <flummz> it takes very long for the Out Of Memory killer to kill ghci
17:47:28 <flummz> if you have linux
17:47:31 <Tangerine> yeah
17:48:04 <flummz> i think there are some possibilities to set resource limits on the command line
17:48:10 <flummz> but i forgot how to do that
17:51:15 <flummz> $ apropos ulimit
17:51:18 <flummz> ulimit (3)           - get and set user limits
17:51:42 <flummz> For the shell command ulimit(), see bash(1).
17:52:10 <flummz> Manual page bash(1) 
17:52:13 <flummz>        ulimit [-HSTabcdefilmnpqrstuvx [limit]]
17:52:27 <flummz>               -d     The maximum size of a process's data segment
17:52:37 <monochrom> I think most default kernels ignore that ulimit setting.
17:52:42 <flummz> okay
17:53:00 <monochrom> instead, run your executable with +RTS -M500M to limit heap to 500MB
17:53:09 <RRSchulz> monochrom: I doubt that greatly‚Ä¶ Many distros have defaults that are unlimited.
17:54:38 <monochrom> RRSchulz, "man malloc" and look for the text "By  default, Linux follows an optimistic memory allocation strategy.  This means"
17:55:41 <marchelzo> hi
17:56:26 <marchelzo> when you run 'cabal configure' or 'cabal build', why doesn't it install dependencies instead of just saying that there are missing dependencies?
17:56:38 <marchelzo> is there a way to get it to install all of the missing ones automatically?
17:56:59 <joneshf-laptop> Is `Cont r` `Foldable`? My gut says no, but I don't know how to prove that you can't write an instance.
17:57:04 <geppettodivacin> marchelzo: cabal install --only-dependencies
17:57:39 <monochrom> actually, I may be wrong, malloc may be irrelevant
17:57:44 <marchelzo> geppettodivacin: thanks. I wonder why it doesn't do that by default.
17:58:22 <marchelzo> or at least say, ' here are the missing dependencies: ..., run cabal install --dependencies-only to install them'
17:58:31 <ntnt> if I find myself needing to specify multi line blocks inside [d| .. |] or [e| ... |], or [t| ... |], am I doing something wrong?
17:58:39 <ntnt> or should I somehow specify these multiline templates elsewhere, and just 'include' them in ?
17:59:01 <joneshf-laptop> which sort of raises deeper questions. How do you prove that a type can't implement an instance of some type class?
17:59:20 <Lokathor> joneshf-laptop, kind mismatch, for one
17:59:37 <monochrom> but I think I once observed ulimit having no effect on a memory hog, written in Haskell too
17:59:48 <joneshf-laptop> Lokathor, assuming you can write the type signature. :)
18:00:13 <flummz> $ ulimit -d 50 -m 50 -s 50
18:00:17 <flummz> $ ghci
18:00:17 <Lokathor> oh, i give up then
18:00:20 <flummz> /bin/bash: xmalloc: .././make_cmd.c:76: cannot allocate 480 bytes (0 bytes allocated)
18:00:28 <monochrom> ah good
18:00:45 <monochrom> but why is it bash, not ghci?
18:00:56 <flummz> :S
18:01:03 <monochrom> oh, ghci is a shell script
18:01:14 <flummz> hehe
18:01:56 <flummz> $ ulimit -d 50000 -m 5000 -s 5000 -v 5000
18:02:02 <flummz> $ ghci
18:02:02 <flummz> /bin/bash: error while loading shared libraries: libdl.so.2: failed to map segment from shared object
18:02:43 <monochrom> to be fair you just want to limit -d
18:04:51 <flummz> i belive -d might not work
18:04:57 <flummz> maybe only -v is working as expected
18:06:13 <flummz> ulimit -v 500000
18:06:24 <flummz> > countSetBits(-1,0)
18:06:24 <flummz> <interactive>: out of memory (requested 2097152 bytes)
18:06:25 <lambdabot>  Not in scope: ‚ÄòcountSetBits‚Äô
18:06:47 <monochrom> ok that's good
18:08:18 <flummz> with -d 500000 countSetBits ate all my 16 GiB of ram
18:08:23 <flummz> so -v works
18:08:25 <flummz> -d not
18:08:33 <Shou> What about: ghci +RTS -M1024m
18:08:37 <flummz> didnt stop it
18:08:46 <flummz> ate all the ram
18:09:02 <Axman6> sound like there's a problem in the code...
18:09:02 <flummz> maybe user error, retrying
18:09:48 <Axman6> what does countSetBits do? does it count the number of bits which are on in the number?
18:09:57 <flummz> Axman6: yes
18:10:11 <Axman6> technically there's an infinite number of 1 bits in -1
18:10:14 <flummz> +RTS -M1024m seems to work, actually
18:10:25 <flummz> that's why im using it
18:10:30 <flummz> countSetBits :: (NaturalNumber, PrevNrSetBits) -> (HalvedNaturalNumber, NewNrSetBits)
18:10:35 <flummz> countSetBits(0, setCount) = (0, setCount)
18:10:35 <flummz> countSetBits(n, setCount) =  countSetBits(shifted, setCount + remainder)
18:10:35 <flummz>   where shifted     = n `div` 2
18:10:36 <flummz>         remainder   = n `mod` 2
18:11:08 <Axman6> you can use dovMod to do those at the same time btw
18:11:25 <Axman6> > divMod 15 2
18:11:27 <lambdabot>  (7,1)
18:12:25 <Axman6> is there any reason for that function to be uncurried? it looks a lot like C when it doesn't need to =)
18:12:26 <flummz> with +RTS -M1024m ghci stays within the constraint and does not terminate
18:12:38 <flummz> the reason is i'm a bloody rookie :)
18:13:12 <flummz> but i cherish this function because it is my only one that trashes
18:13:39 <flummz> ghci +RTS -M1024m does not react to ^C s
18:13:52 <monochrom> tuples also help eat memory
18:13:57 <Axman6> try `countSetBits n setCount =  countSetBits shifted (setCount + remainder)
18:13:57 <flummz> hehe
18:14:30 <Axman6> with type countSetBits :: NaturalNumber -> PrevNrSetBits -> (HalvedNaturalNumber, NewNrSetBits)
18:15:04 <tippenein> I have to pull down the entire amazonka repo so that I can figure out how to turn a Lazy bytestring into a RqBody
18:15:23 <flummz> Axman6: i believe countSetBits was for an assignment that specified "use only basic arithmetic functions"
18:15:35 <flummz> well, shifting is very basic
18:16:10 <Axman6> I don't think I suggested you should do anything that isn't a basic maths function
18:16:15 <Axman6> but using divMod is more efficient
18:16:23 <flummz> that's what i observed when i said well
18:16:27 <Axman6> s/is/may be
18:18:05 <tippenein> that didn't seem to help. How would i convert a Lazy ByteString to a RqBody for amazonka to consume
18:18:38 <Axman6> flummz: anyway, that function will never terminate with negative input
18:18:49 <flummz> that's the reason i keep it
18:21:34 <Axman6> tippenein: you should be able to use something yield (toStrict lbs) or mapM_ yield (toChunks lbs) as the _chunkedSource
18:23:16 <Axman6> tippenein: hmm, ignore that, there must be a better way
18:23:38 <tippenein> heh, I hope so. I was digging deeper into that answer
18:24:05 <Axman6> tippenein: what are you actually trying to do? high level
18:24:17 <flummz> going to read some space opera, good night Axman6
18:24:26 <Axman6> g'night
18:25:14 <Axman6> tippenein: oh, there's a ToBody class, which has both bytestrings as instance toBody :: ToBody a => a -> RqBody
18:25:29 <Axman6> tippenein: bottom of http://hackage.haskell.org/package/amazonka-core-1.4.0/docs/Network-AWS-Data-Body.html#t:RqBody
18:28:52 * ebookclic < - www.ebooksclickbanks.tk - >
18:29:04 --- mode: ChanServ set +o monochrom
18:29:08 --- mode: monochrom set +b *!*@78.191.149.170
18:29:08 --- kick: ebookclic was kicked by monochrom (ebookclic)
18:29:27 --- mode: monochrom set -o monochrom
18:32:56 <tippenein> Axman6: interesting. I tried `toBody` on the LBS, but I got some type errors. I'll put an lpaste up
18:36:33 <ertesx> Lokathor, monochrom: he's talking about actual linked lists as a data structure, so it doesn't apply to haskell lists that much
18:39:09 <ertesx> remember that this talk is to a C++ audience, so there is a clear separation between data structures and control structures
18:45:50 <infandum> In Turtle, can I filter a Shell Text stream, i.e., filter :: (Text -> Bool) -> Shell Text -> Shell Text
18:46:51 <Axman6> tippenein: I'm surprised that you need to use a RqBody at all, usually the specific AWS request types have the necessary constructors/lenses
18:52:50 <orion> "Lift a monad homomorphism from m to n into a monad homomorphism from FT f m to FT f n" -- http://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free-Church.html <-- when would I want to use this?
18:53:00 <orion> hoistFT
18:58:51 <Lokathor> ertesx, right, it just made me giggle, with how many LLs there are in haskell
19:18:22 <Peaker> I'm trying to use 'stack' to refer to a git repo with submodules. But "stack" does not use "clone --recursive" :(
19:19:21 <ertesx> orion: whenever you need to change the underlying monad, like when you want to reduce an FT MyF (ReaderT A IO) R to an A -> FT MyF IO R
19:24:00 <Peaker> I see it was fixed upstream
19:24:31 <Peaker> On the bright side, my freetype-gl bindings seem to work :)  They're quite low-level, so need some wrapping, but I can finally get nice looking text in OpenGL!
19:24:57 <Peaker> (FTGL text looks terrible. Using cairo/pango/etc requires the Gtk build chain and is much more complex)
19:26:55 <infandum> Nevermind, Shell has an instance of MonadPlus in which filterM can be used
19:26:57 <infandum> er
19:26:59 <infandum> mfilter
19:35:26 <orion> ertesx: So, I have this: type FooMonad r = Coroutine (Request ByteString r) (State FooState) r -- and a small "program" of type: FT FooF Identity () Are you saying that hoistFT can help me use that small program with the FooMonad monad transformer?
19:36:30 <orion> (Given that I can't use it directly since the inner monads don't agree (State FooState /= Identity)
19:37:24 <TheMystic> So I'm working on a little program that does a bunch of async requests to the GitHub API to get all the pull requests across a bunch of repos.
19:38:10 <TheMystic> So far so good, but with about 250 repos, it does a bunch of the requests fine and eventually throws an exception: FailedConnectionException2 "api.github.com" 443 True getAddrInfo: does not exist (nodename nor servname provided, or not known)
19:39:50 <TheMystic> now clearly that's a specious error, since it managed to look up "api.github.com" several hundred times before it bails out
19:40:50 <TheMystic> my question is: is there a way I can catch that exception, and/or structure the code to issue fewer requests at a time?
19:45:00 <geekosaur> TheMystic, by any chance are you on a machine that uses nss_resolve? switch it to use glibc's nss_dns module for DNS. it's a bug in nss_resolve's use of dbus libraries without guarding against itimers, and that means it's a bit painful to deal with from Haskell because the C library doesn't recover properly :/
19:45:25 <geekosaur> (I reported it upstream and a fix is in the works)
19:47:50 <geekosaur> (even if you do catch it, the next lookup you make might get the result of the one that incorrectly failed)
19:51:31 <geekosaur> alternatively compile with -rtsopts and run with +RTS -v0 -RTS
19:52:35 <orion> ertesx: I am reading the Control.Monad.Morph tutorial now. Pretty cool stuff!
19:53:04 <geekosaur> (note that that will prevent profiling and may change thread switching and garbage collection behavior)
19:55:19 <TheMystic> geekosaur: this is an OS X machine, so it's Apple's resolver I guess
19:55:26 <geekosaur> interesting
19:56:13 <geekosaur> you could still try the +RTS -v0 and see if it goes away
19:56:14 <TheMystic> yeah, it's apparently a problem outside of Haskell, it's just that Async gave me enough leverage to exercise it :)
19:56:25 <geekosaur> sorry, I mean +RTS --V0
19:56:27 <geekosaur> er
19:56:33 <geekosaur> \+RTS -V0
19:56:35 <geekosaur> sigh
19:56:41 <geekosaur> can't type apparently :/
19:56:50 * nitrix gives geekosaur a warm chocolate chip cookie.
19:57:25 <Clint> sinister
19:57:56 <geekosaur> if that makes the spurious failures go away then it's an apple resolver bug (apple does some weirdshit all its own); unfortunately they're not so good at responding to bug reports these days :(
19:58:58 <TheMystic> oh, here's another interesting thing: compiling it and then running it, instead of using runghc, makes the failure... less likely
20:00:04 <geekosaur> in any case, the exception is http://hackage.haskell.org/package/http-client-0.4.28/docs/Network-HTTP-Client-Internal.html#v:FailedConnectionException2
20:03:45 <TheMystic> geekosaur: thanks :)
20:03:55 <geekosaur> which is a constructor of the type http://hackage.haskell.org/package/http-client-0.4.28/docs/Network-HTTP-Client-Internal.html#t:HttpException 
20:04:02 <TheMystic> bug still appears with +RTS -V0 ... well, different exception actually
20:04:14 <geekosaur> (sigh, network is being craptacular here)
20:04:19 <TheMystic> but one that I'm also seeing (sometimes) without the RTS option
20:04:46 <geekosaur> both of those argue for it being timing related, I think
20:04:48 <TheMystic> now it's: TlsExceptionHostPort (HandshakeFailed (Error_Packet_unexpected "Alert [(AlertLevel_Fatal,BadRecordMac)]" " expected: change cipher")) "api.github.com" 443
20:04:56 <TheMystic> yeah, I think so too
20:05:34 <geekosaur> o.O that would not be related
20:08:53 <TheMystic> my suspicion is that the underlying network stack is getting confused which packets belong to which threads
20:09:05 <benzrf> TheMystic: what
20:09:13 <zxtx> hi, is there anyway in haskell to check if stdin is empty and immediately close the pipe if it is 
20:10:27 <zxtx> I'm writing a command-line tool which can take input on stdin, but I want a usage screen to come up if that buffer is empty
20:11:58 <geekosaur> zxtx, it'd make more sense to check if it's a terminal (http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-Terminal.html#v:queryTerminal)
20:12:04 <Sornaensis> you probably want to do option parsing
20:12:53 <geekosaur> otherwise you'll get spurious failures if the program on the other side of the pipe takes some time to generate its output
20:13:39 <zxtx> well assuming I check that, how else can I check
20:15:02 <geekosaur> how exactly do you check that?
20:15:28 <geekosaur> since the only way you can do it is check whether the buffer is empty, which is what you want to mean something else
20:16:23 <zxtx> I mean assuming I use queryTerminal, and I know if I am at a tty, how does that get me closer to knowing if I have an empty buffer on stdin
20:16:51 <geekosaur> why do you insist an empty buffer on stdin means an error?
20:17:06 <Sornaensis> yea an empty buffer just means waiting for input
20:17:07 <geekosaur> or did you mean it has EOF? in that case, just read from it and see if you get nothing back
20:18:24 <zxtx> Sornaensis, yes I would like to check if it is waiting for input
20:19:04 <geekosaur> and yet you think that you can check that it's an actual connected pipe to a slow program
20:19:17 <zxtx> when I try to read from it and check if nothing came back, I have to call Ctrl-D to get the usage string
20:19:31 <geekosaur> ...
20:19:43 <geekosaur> that is why you want to check if it is a terminal, not check if it is empty
20:20:08 <zxtx> ok
20:22:17 <geekosaur> and I have no idea what you thgink ":call Ctrl-D" is
20:22:39 <geekosaur> but it sounds like confusion to me
20:22:46 <zxtx> Ctrl-D explicitly sends EOF on stdin
20:22:53 <geekosaur> yes
20:22:55 <geekosaur> and?
20:22:59 <geekosaur> so uypou are absolutely obligated to read first?
20:23:13 <geekosaur> who put this obligation on you?
20:23:21 <zxtx> I'm not obligated to do so
20:23:23 <geekosaur> you check if the Handle is a terminal and *don't waste time reading it*
20:23:31 <zxtx> ah ok
20:23:33 <geekosaur> you cannot simulate a control-d
20:23:46 <geekosaur> just check if it's a tty and if so output your message
20:23:59 <zxtx> technically I can simulate it, but that solution is certainly the wrong one
20:24:11 <geekosaur> closing it isn't really simulating ctrl-d]
20:24:26 <geekosaur> techniczlly you could TIOCSTI a ctrl-D but that makes no sense here
20:24:32 <zxtx> right
20:24:36 <geekosaur> (if you can find some binding to ioctl(TIOCSTI)
20:25:28 <zxtx> now that I understand your suggestion, let me go try it. Thanks!
20:34:58 <ntnt> does anyone have a nice Haskell binding for either (1) ominfocus, (2) osx reminders, or (3) any other todo app? When I'm writing haskell code, I like to write out typesigs with the func def being  undefined -- I'd like a way to auto sync these as TODO list items somehow
20:47:47 <marchelzo> ntnt: why do you need haskell bindings to do that?
20:48:43 <ntnt> actually, I guess I don't I just need a way to go from a makefile to generating these
20:50:20 <geekosaur> ntnt, perhaps you would like http://hackage.haskell.org/package/lentil, or to make something based on it that can feed something else
20:50:28 <marchelzo> you could probably do it with a shell script, or just have a key binging to do it from your text editor whenever you create a new function stub
20:50:37 <marchelzo> binding*
20:57:15 <ntnt> in TH, '' passes a Type as a Name
20:57:20 <ntnt> is there a way to pass a Type as a Type ?
21:01:01 <Hafydd> ntnt: you can obtain a Q Type by using [t|...|], in case you don't know.
21:15:15 <Tangerine> if a haskell evaluation results in some redex with "0 * f(x)" where f(x) is a non terminating recursive function that evaluates to Integer, is Haskell smart enough to evaluate it to 0?
21:16:20 <dolio> It's smart enough to not evaluate it to 0.
21:16:28 <Hafydd> Tangerine: it depends on the type of *, of course.
21:16:41 <Tangerine> suppose this is typed as Integer
21:16:42 <Hafydd> Oh, wait, I didn't see part of that.
21:16:49 <Hafydd> No, it isn't.
21:17:02 <verement> > 0 * undefined
21:17:04 <lambdabot>  *Exception: Prelude.undefined
21:17:09 <verement> > undefined * 0
21:17:10 <lambdabot>  0
21:17:24 <Hafydd> But it would be more accurate to say that Integer is not smart enough to do that.
21:17:29 <Tangerine> interesting
21:17:41 <Hafydd> (There could be a type which is.)
21:18:13 <ntnt> it appears to me that Language.Haskell.TH.Name and Language.Haskell.TH.Syntax.Name are two DIFFERENT data types. What's going on?
21:18:36 <Tangerine> so for example, suppose you take the product of all possible Int (not integer) from smallest to largest
21:18:52 <Tangerine> Haskell would NOT terminate early when it sees 0 * (blah)
21:20:08 <dolio> Multiplication on Int is not defined that way, either.
21:21:30 <ntnt> hmm, they link to the same source line, so maye they are the same data type
21:22:17 <Hafydd> ntnt: how did you suppose they are distinct?
21:22:25 <ntnt> they were in different HTML files
21:22:30 <Hafydd> ...
21:22:32 <ntnt> I didn't see they linked to the same *.hs file
21:22:36 <ntnt> in sort, I was an idiot
21:23:20 <Hafydd> TH.hs has a re-export line of TH.Syntax.hs. (In fact, it only re-exports from other modules.)
21:23:44 <Hafydd> I mean: it has a re-export of Name, and it imports TH.Syntax.
21:27:04 <Tangerine> what does Haskell do when an evaluation will not terminate?
21:27:14 <Tangerine> Last time I tried this my entire VM ran out of memory and just died
21:30:00 <Hafydd> Tangerine: obviously, Haskell itself will sometimes fail to terminate. Sometimes (rarely) it will detect then non-termination and terminate with an error.
21:30:43 <Hafydd> And when it does fail to terminate, it might well also consume unbounded memory, depending on the nature of the computation.
21:30:48 <Tangerine> I see. So the typical line of action is to try to ctrl-c it right?
21:30:56 <Cale> right
21:31:10 <Hafydd> Not necessarily. Non-termination is a desirable behaviour in many programs.
21:32:14 <Cale> Well, if you'd prefer the program to stop rather than to continue doing what it's doing. :)
21:35:53 <ntnt> In TH, when do I use '' and when do I use ', is '' for types and ' for var/func names ?
21:53:58 <Axman6> ntnt: IIRC yes
21:54:41 <Axman6> ntnt: see https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/template-haskell.html
21:55:29 <ntnt> Axman6: found it in docs; thanks!
21:56:56 * hackagebot ether 0.4.0.1 - Monad transformers and classes  https://hackage.haskell.org/package/ether-0.4.0.1 (int_index)
21:57:05 <Zemyla> Found out the hard way that my first pull request fails on older versions of GHC. I need to figure out a way to test it on those before submitting.
22:00:40 <Axman6> Zemyla: stack makes testing other GHCs very easy, just have a different stack.yaml for each GHC version, and then use stack --stack-yaml=stack-7.8.yaml build/test/whatever
22:05:01 <Zemyla> Axman6: Okay, but I don't have those at the moment. Is there a way I can submit my branch to Travis directly and have it tested on the same configurations the original is?
22:06:01 <Zemyla> Oh, I see how.
22:36:16 <Tangerine> Am i understanding this correctly? Right associative means a ++ b ++ c is the same as (a ++ b) ++ c
22:36:27 <tippenein> I'm trying to see the objects in a bucket. via amazonka - https://github.com/brendanhay/amazonka/blob/develop/amazonka-s3/gen/Network/AWS/S3/ListObjects.hs
22:37:07 <EvanR> thats left assoc
22:37:22 <lpaste> tippenein pasted ‚Äúamazonka lens‚Äù at http://lpaste.net/160381
22:37:42 <Tangerine> ooh oops
22:47:02 <ntnt> in TH, how do I get the Type of a Var?
22:47:07 <ntnt> I searched for "Name -> Type"
22:47:15 <ntnt> but I got varT / conT, which is not what I want
22:48:23 <lyxia> ntnt: reify
22:48:44 <ntnt> lyxia: ah, Name -> Q Info, no wonder I didn't think of it
22:51:57 * hackagebot wai-logger 2.2.7 - A logging system for WAI  https://hackage.haskell.org/package/wai-logger-2.2.7 (KazuYamamoto)
23:22:38 <lpaste> tippenein pasted ‚Äúhelp reading a type error‚Äù at http://lpaste.net/160383
23:24:15 <liste> tippenein: you're using a monadic action where a pure value is expected
23:28:17 <tippenein> "view" being the monadic action?
23:29:31 <tippenein> I'm confused at what I get out of the "send"
23:29:32 <tippenein> send :: (AWSConstraint r m, AWSRequest a) => a -> m (Rs a)
23:33:19 <Zemyla> Woo, I finally got a pull request to not break the build!
23:37:14 <liste> tippenein: (view lorsContents) <$> send $ ...
23:37:28 <liste> it's probably just an associativity issue
23:40:37 <tippenein> unfortunately, same error
