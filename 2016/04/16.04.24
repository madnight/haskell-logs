00:17:21 <ski> shanemikel : use something like `foreign import ccall "wrapper" mkCallback :: (CInt -> IO ()) -> IO (FunPtr (CInt -> IO ()))' to be able to pass a Haskell `CInt -> IO ()' to C (via a `FunPtr (...)')
00:18:05 <liangzan> hello, can i ask a beginner question here? had no response in beginners
00:18:20 <liangzan> i‚Äôm trying parsec
00:18:24 <liangzan> then i saw this http://lpaste.net/161320
00:18:37 <liangzan> why is there no arrows in the function signature?
00:18:58 <shachaf> There are no arrows in the type signature because it's not a function.
00:19:03 <ski> shanemikel : iirc, this will allocate a block of memory, and dynamically generate some machine code in it so that if C calls a function pointer to it, it will in turn call the correct Haskell function/action, with the correct closure environment
00:19:09 <liangzan> oh
00:19:27 <ski> (the closure environment being why you need to generate code in the first place)
00:19:44 <liangzan> sorry, can i know what is it?
00:20:18 <ski> liangzan : it's a parser action
00:20:42 <liangzan> hmm ok, let me find out more about it
00:20:44 <liangzan> thanks!
00:21:17 <ski> `parseString' is a `Parser'-action that when executed/run will yield a value/result of type `LispVal'
00:21:35 <ski> just like `getLine' is an `IO'-action that when executed/run will yield a value/result of type `String'
00:21:43 <ski> @hoogle getLine
00:21:45 <lambdabot> Prelude getLine :: IO String
00:21:45 <lambdabot> System.IO getLine :: IO String
00:21:45 <lambdabot> Data.ByteString getLine :: IO ByteString
00:23:51 <ski> shanemikel : anyway, this `foreign' declaration will not by itself import or export anything into Haskell from C or from Haskell into C. (so one could perhaps consider the `import' part a little bit misleading)
00:24:38 <ski> shanemikel : however, it will make `mkCallback' available to Haskell, so in that sense, it's an import. but what is imported is fully generated by the FFI, it doesn't come from the C side
00:26:03 <ski> shanemikel : then, when you *call* `mkCallback' (and execute the resulting `IO'-action), *that* will effectively dynamically *export* your Haskell operation into a C operation, providing it in the form of a function pointer, which you can then pass to C, and which C can call
00:28:46 <ski> shanemikel : aside, for comparision, if you replace `wrapper' with `dynamic', like `foreign import ccall "dynamic" mkFun :: FunPtr (CInt -> IO ()) -> (CInt -> IO ())', then the FFI still generates code that will now be imported into Haskell as `mkFun'. but this time, calling it will convert a function pointer (presumably coming from C) into a corresponding Haskell function/action
00:32:25 <ski> shanemikel : oh, also : after you're finished with the `FunPtr (...)' that `mkCallback' will generate for you (obviously you can rename `mkCallback' and `mkFun' to whatever name you like), you should free the allocated function pointer block by passing it to `Foreign.Ptr.freeHaskellFunPtr :: FunPtr a -> IO ()'
00:33:48 <shanemikel> I'm gonna have to read that with fresh eyes
00:33:58 <shanemikel> I'm saving the log though
00:35:22 <shanemikel> ski: any thoughts on dealing with exceptions in c code? (guile has it's own continuation mechanism)
00:39:53 <shanemikel> .. somehow I feel like I've read about "dynamic" and "wrapper" in the manual, but it was lost on me
00:40:40 <shanemikel> if it's any consolation, I did finally get a haskell type and corresponding c wrapper to import my primitive types
00:42:05 <ggVGc> that's pretty consoling for me
00:42:06 <ggVGc> thanks
00:47:04 <shanemikel> ski: and I got it to work with the cpp and consts, not function calls :O)
00:48:48 <shanemikel> ggVGc: It was just a way of expressing appreciation.  what better compensation can a person get for their charity than utility?
00:49:43 <ggVGc> I know, I just wanted to involved myself :(
00:52:24 <ski> shanemikel : i assume you also used `peek' and `unsafePerformIO' to avoid axposing the `Ptr' in your interface
00:52:30 <shanemikel> yes
00:52:46 <shanemikel> and I seriously wouldn't have had the courage to do that without you
00:54:11 <shanemikel> the thing that was throwing me off was the value I'm receiving should essentially be stored in a Ptr (), so the second degree of indirection was frightening me
00:54:32 <shanemikel> (it's not actually a *void)
00:54:59 <shanemikel> but has an unstable binary representation that should only be handled with the c api
00:56:14 <toph> can someone give me a hint what the signature for "mystuff" would be if i could uncomment the "putStrLn" line? http://lpaste.net/7786123671482925056
00:56:56 <toph> without changing `myfun`
00:56:58 <lyxia> it wouldn't typecheck
00:57:28 <toph> i know i would have to change the definition in the body, but the type signature to achieve the desired effect?
00:57:44 <lyxia> putStrLn "BANG" has type IO (), but Just x >>= ... has some type Maybe a, so there's a conflict
00:58:10 <ski> shanemikel : well, i think you can actually use `unsafeDupablePerformIO' instead of `unsafePerformIO', to `peek' the `Ptr'. it should be ok, since the mutable cell is `const'. using this may be more efficient, per the docs
00:58:15 <lyxia> toph: what is the desired effect
00:58:43 <toph> to print every iteration of the recursive call, and still have the computation 'exit' when 'Nothing' is in the Maybe
00:59:14 <ski> shanemikel : "second degree of indirection
00:59:25 <ski> shanemikel : " -- ? are you using pointers to pointers ?
00:59:58 <lyxia> toph: IO (Maybe Double). IO to print stuff. Maybe because you can "exit" as you say.
01:00:51 <shanemikel> yeah.. well kind of.. this library uses it's own incarnation of pointers to a managed heap and using a garbage collector provided as another library
01:01:04 <ski> shanemikel : btw, instead of `Ptr ()', i think you can possibly use `Ptr Dummy', where `Dummy' is a dummy Haskell type you declare in Haskell to represent the abstract C type
01:01:33 <ski> shanemikel : compare e.g. with `CJmpBuf' to represent a C `jmp_buf', at <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.2.0/src/Foreign-C-Types.html#CJmpBuf>
01:02:03 <toph> i can get this, but it expects the recursive 'mystuff' to be Double -> Maybe (Maybe Double) http://lpaste.net/2224269223641743360
01:03:05 <ski> toph : perhaps consider using `MaybeT IO'
01:03:55 <ski>   mystuff :: Double -> IO (Maybe Double)
01:03:57 <ski>   mystuff x = do
01:04:03 <ski>     putStrLn "BANG"
01:04:30 <shanemikel> yeah, actually I wouldn't use Ptr Dummy, but just Dummy = Ptr (), because I shouldn't actually use it as a pointer like I was saying.. I was just using Ptr because that by design is the size of the value
01:05:05 <shanemikel> and it was the default for my c2hs code
01:06:25 <ski>     case Just x >>= myfun of
01:06:30 <ski>       Nothing -> return Nothing
01:06:31 <ski>       Just y  -> mystuff y
01:06:50 <ski> toph : note that `Just x >>= myfun' can be simpler written as `myfun x'
01:08:19 <ski> toph : also note that `mystuff' will never yield a `Just (...)' as result. presumably, you're going to fix that by adding another terminating condition ?
01:08:22 <lyxia> "Nothing -> return Nothing" mapM is our friend!
01:08:49 <lyxia> or MaybeT as you said
01:08:57 <ski> toph : or perhaps you want it to terminate only when you get a `Nothing' internally ? in that case, i suggest using `mystuff :: Double -> IO ()' instead of `mystuff :: Double -> IO (Maybe Double)'
01:09:09 <ski> lyxia : we're getting in that direction :)
01:10:34 <ski> shanemikel : oh, it's not even really a pointer to an (abstract) C data type, but just an abstract C data type ?
01:10:44 <shanemikel> yeah
01:10:48 <toph> ski: i wanted it to terminate when it gets 'Nothing', as the first version of the function without IO
01:11:23 <toph> give it a negative integer, it will terminate eventually, give anything else it will loop forever
01:11:46 <ski> toph : so why not `mystuff :: Double -> IO ()', then ?
01:12:14 <ski> toph : anyway, for illustration, here's the `MaybeT IO' version :
01:12:25 <ski>   mystuff :: Double -> MaybeT IO Double
01:12:25 <toph> ski: i know i could do explicit handling of the maybe, but i wanted to combine Maybe and IO monads
01:12:32 <ski>   mystuff x = do
01:13:15 <ski>     lift (putStrLn "BANG")  -- or `liftIO'
01:14:04 <Lovepon> Cale: I was away, sorry. I'm trying to understand it right now.
01:14:39 <ski>     y <- (MaybeT . return) (Just x >>= myfun)
01:14:45 <ski>     mystuff y
01:15:05 <ski> (`Just x >>= myfun' is still simpler written as `myfun x')
01:15:42 * ski tries to recall if there was a nicer way to go from `Maybe' to `MaybeT m' for any monad `m', apart from `MaybeT . return'
01:16:28 <ski> toph : the nice thing about `MaybeT' is that it will hide the `case' and the `Nothing -> return Nothing' branch for you, and hide the extraction of `y' out of `Just y'
01:17:41 <ski> `lift' will convert any `m a' into a `MaybeT m a' (that will actually never fail in `MaybeT') (assuming `m' is a monad)
01:18:54 <ski> (`liftIO' also works, and might be nicer here. it will convert any `IO a' into `MaybeT IO a'. but if you want to convert into instead e.g. `StateT Foo (MaybeT IO) a', `liftIO' still works. with `lift', you'd have to use `lift . lift' here, since it's two levels of lifting. `liftIO' lifts `IO' all the required number of levels)
01:19:02 <toph> ski: http://lpaste.net/3212094753780793344 that works perfectly :) i will ponder this 
01:20:40 <ski> toph : still, i think the `MaybeT . return' part looks slightly ugly. there is probably some operation somewhere that can be used to convert a "pure" `Maybe a' into a `MaybeT m a' (that will actually not do any `m'-effects). and similarly for `State s a' to `StateT s m a', &c.
01:22:20 <lpaste> gfixler pasted ‚ÄúCan't install pointfree through stack‚Äù at http://lpaste.net/4908517646409924608
01:22:29 <gfixler> what do?
01:31:17 <Squarism> should i be able to just do :m Text.Regex.PCRE 
01:31:19 <Squarism> in ghci?
01:31:43 <Squarism> i get
01:31:45 <Squarism> <no location info>:
01:31:45 <Squarism>     Could not find module ëText.Regex.PCREí
01:31:45 <Squarism>     It is not a module in the current program, or in any known package.
01:32:03 <ski> toph : anyway .. your current code could just as well use the signature `mystuff :: Double -> MaybeT IO a', since you'll never monadically return in `MaybeT IO'. you'll either loop infinitely, or you'll abort the computation (when you reach `Nothing' internally)
01:32:25 <ski> toph : which was why i was suggesting to consider using `mystuff :: Double -> IO ()' instead
01:33:25 <ski> toph : however, if you're interfacing this to other code that also may do `IO', and that you also want to be able to abort early, but which may also terminate normally with a result, then using `MaybeT IO' here wouldn't be a needless complication
01:34:30 <ski> toph : of course, you can write a general transformation of type `forall m. Monad m => MaybeT m Void -> m ()', that runs the argument until it aborts
01:34:33 * hackagebot geniplate-mirror 0.7.3 - Use Template Haskell to generate Uniplate-like functions.  https://hackage.haskell.org/package/geniplate-mirror-0.7.3 (DanRosen)
01:34:35 * hackagebot geniplate-mirror 0.7.4 - Use Template Haskell to generate Uniplate-like functions.  https://hackage.haskell.org/package/geniplate-mirror-0.7.4 (DanRosen)
01:36:28 <ski> @type liftM (maybe () Data.Void.absurd) . runMaybeT  -- there you go
01:36:29 <lambdabot> Monad m => MaybeT m Data.Void.Void -> m ()
01:37:16 <ski> @type liftM (maybe () Data.Void.absurd) . runMaybeT . forever  -- and this runs the argument "forever", until it decides to abort
01:37:17 <lambdabot> Monad m => MaybeT m a -> m ()
01:37:26 <toph> O_o i will have to sleep on that one
01:38:01 <ski> (well, in some monads, even running it "forever", without aborting, could be useful. e.g. `Writer w', or some tree monad. you could extract information out of the infinite result)
01:38:09 <Gurkenglas> If you would only use MaybeT once, you can use mapM/traverse/for instead:
01:38:17 <Gurkenglas> mystuff x = do
01:38:22 <Gurkenglas>   putStrLn "BANG"
01:38:31 <ski> i'm just using `Void' here to express that the action won't terminate normally, when executed
01:38:48 <Gurkenglas>   traverse mystuff $ Just x >>= myfun
01:39:30 <Gurkenglas> On the other hand, using MaybeT allows you to use Control.Monad.Loops to tighten the recursion:
01:39:35 <ski> yes, good point (i suppose lyxia meant this as well)
01:39:52 <Gurkenglas> mystuff x = runMaybeT $ iterateM_ $ do
01:40:05 <Gurkenglas>   liftIO $ putStrLn "BANG"
01:40:20 <Gurkenglas>   MaybeT . return $ Just x >>= myfun
01:41:00 <ski>   forM (myfun x) $ \y -> do
01:41:03 <ski>     mystuff y
01:41:16 <ski> (variant expression of the `traverse' above)
01:41:30 <Gurkenglas> (the M is superfluous)
01:41:43 <ski> running the body for every element (zero or one of them) of `myfun x'
01:42:00 <ski> Gurkenglas : old habit :)
01:43:15 <ski> toph : these latter versions use your original signature `mystuff :: Double -> IO (Maybe Double)' (where you could still replace the latter `Double' by a generic `a')
01:44:23 <shanemikel> still, requiring the &w_bool_t :: Ptr SCM is troubling me, given the c definition, I would expect to be able to use w_bool_t :: SCM http://lpaste.net/7931078731823579136 http://lpaste.net/3580870494175363072
01:44:25 <ski> (also, since you mentioned both `traverse' and `mapM', i thought i'd mention the missing counterpart to `for')
01:45:01 <shanemikel> minus the peeks, that is
01:47:48 <ski>   It should be noted that a static foreign declaration that does not import an address (i.e., where `&' is not used in the specification of the external entity) always refers to a C function, even if the Haskell type is non-functional. For example,
01:47:52 <ski>     foreign import ccall foo :: CInt
01:48:24 <ski>   refers to a pure C function foo with no arguments that returns an integer value. Similarly, if the type is `IO CInt', the declaration refers to an impure nullary function. If a Haskell program needs to access a C variable `bar' of integer type,
01:48:28 <ski>     foreign import ccall "&" bar :: Ptr CInt
01:48:39 <Gurkenglas> :t runMaybeT .: iterateM_ $ \x -> MaybeT . return $ Just x >>= ?myfun -- Oh, the Control.Monad.Loops example was wrong: x must be local.
01:48:40 <lambdabot> (Monad m, ?myfun::a1 -> Maybe a1) => a1 -> m (Maybe a)
01:48:42 <ski>   must be used to obtain a pointer referring to the variable. The variable can be read and updated using the routines provided by the module `Foreign.Storable' (cf. Section 37).
01:49:22 <Hiro`> Hey everyone. I'm trying to follow along with the Servant tutorial "Write a client library for any web API in 5 minutes". When I come to build the project with Stack, I get errors from the calls to `run`. This function seems to be related to the functions automatically derived from the HackageAPI type. Can anyone help?
01:49:27 <ski> shanemikel : so, if you use `w_bool_t :: SCM', then it'd expect `SCM w_bool_t();' on the C side
01:49:47 <shanemikel> where are you reading that?
01:50:12 <Hiro`> shanemikel: moi?
01:51:31 <shanemikel> moi?
01:51:38 <shanemikel> I guess it's time to read the report lol
01:51:53 <Hiro`> ah, I see that you're in the middle of a conversation. Here's the link to the tutorial if anyone else feels they could shed some light on it though. https://haskell-servant.github.io/client-in-5-minutes.html
01:52:12 <ski> shanemikel : <https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1620008.5.1>
01:52:56 <Gurkenglas> :t let mystuff x = traverse_ mystuff $ Just x >>= ?myfun in mystuff -- The traverse and for examples were also wrong, because we add a Maybe layer at each recursive step. The _ versions get rid of them.
01:52:57 <lambdabot> (Applicative f, ?myfun::a -> Maybe a) => a -> f ()
01:53:49 <ski> Gurkenglas : hm, or `join' them ?
01:54:44 <ski> (which would be better in the case that we can actually also terminate normally, i think)
01:54:50 <Gurkenglas> ski, that would leave the fixed points undefined and Nothing, so we should, as discussed yesterday, default to Nothing, which means throw away the Maybe layers :D
01:55:29 <ski> "as discussed yesterday" ? you mean the "find not quite least fixed point" ?
01:55:32 <Gurkenglas> yep
01:56:11 * ski didn't fully grok the situation that Gurkenglas were in there, only associated it to the discussion in that cycamore paper
01:57:01 <Gurkenglas> When we produce Maybe Void, we should instead produce ().
01:57:04 <ski> Gurkenglas : anyway, if you add a case for normal termination, you could also get `Just's, so then there'd be a point
01:57:14 <shanemikel> okay, gn everybody
01:57:18 <ski> (obviously `iterateM_' couldn't be used in this case)
01:57:30 <ski> night shanemikel
01:58:01 <ski> Gurkenglas : yes. but if we really get a sensible `Maybe Double', then not
01:58:07 <Gurkenglas> Thats fair, and sounds more of a case for MaybeT :D
01:58:19 <Gurkenglas> (Because it handles the joining part)
01:58:50 <ski> (it wasn't clear whether toph wanted to extend `mystuff' to be able to terminate normally, ior alternatively to interface with code which did that)
01:59:26 <ski> @type liftM (maybe () Data.Void.absurd) . runMaybeT
01:59:27 <ski> @type liftM (maybe () Data.Void.absurd) . runMaybeT . forever
01:59:27 <lambdabot> Not in scope: ‚ÄòrunMaybeT‚Äô
01:59:28 <lambdabot> Not in scope: ‚ÄòrunMaybeT‚Äô
01:59:36 <ski> er
02:00:25 <ski> @let import Control.Monad.Trans.Maybe
02:00:27 <lambdabot>  Defined.
02:00:32 <ski> @type liftM (maybe () Data.Void.absurd) . runMaybeT
02:00:33 <lambdabot> Monad m => MaybeT m Data.Void.Void -> m ()
02:00:33 <ski> @type liftM (maybe () Data.Void.absurd) . runMaybeT . forever
02:00:35 <lambdabot> Monad m => MaybeT m a -> m ()
02:01:18 <Gurkenglas> Way ahead of ya http://ircbrowse.net/browse/haskell?id=21424862&timestamp=1442201016#t1442201016 :D
02:01:38 <ski> (those were intended as possibly relevant ways to interface such `MaybeT'-using code with normal `m'-using code, `m = IO' here)
02:02:21 <ski> Gurkenglas : that's nice :)
02:04:11 <ski> there should also be a standard operation of type `State sr a -> Reader sr [a]', and `StateT sr m a -> ReaderT sr m Void' (or `b' instead of `Void', since it's covariant position)
02:04:52 <ski> (i suppose also `StateT sr Maybe a -> Reader sr [a]')
02:07:09 <Gurkenglas> :t manyLazy :: StateT sr Maybe a -> State sr [a] -- why read-only?
02:07:10 <lambdabot> StateT sr Maybe a -> State sr [a]
02:07:25 <Gurkenglas> (uses http://lpaste.net/150858 )
02:08:42 <Gurkenglas> (the state afterwards is the state before the application that returned Nothing)
02:09:05 <ski> well, i was going to say because there's no sensible final state
02:09:35 <ski> this would especially hold in the `State sr a -> Reader sr [a]' case, since here we have an infinite list
02:10:09 <ski> (reverting to the last existing state could also be useful, but isn't what i had in mind here)
02:10:58 <Gurkenglas> (Imagine a parser that might read a digit from the beginning of a string, leaving the rest. Reading many numbers should leave the string after many numbers were read, but before we failed to read another. Also it's what naturally comes out of the definition, surely that must mean something :> )
02:12:33 <ski> (you can think of `State sr a' as a subtype of `Reader sr a'. any action in the former can be converted into one in the latter, by throwing away the final state. at some point, i also considered a variant of `(>>=)' of type `m a -> (a -> n b) -> n b'. here `m' could be `State sr' and `n' be `Reader sr')
02:13:15 <ski> Gurkenglas : yes, i'm not disputing that's useful. it's just not what i had in mind :)
02:13:30 <Gurkenglas> State sr a throws away the initial state instead, so its not a subtype
02:13:49 <ski> ?
02:14:21 <Gurkenglas> The monad instance of State sr a passes the final state to the next action, the one of Reader sr a passes the initial state
02:14:34 * hackagebot midi-music-box 0.0.0.1 - Convert MIDI file to music box punch tape  https://hackage.haskell.org/package/midi-music-box-0.0.0.1 (HenningThielemann)
02:15:10 <ski> @type let project :: State sr a -> Reader sr a; project = reader . evalState in project
02:15:12 <lambdabot> State sr a -> Reader sr a
02:15:43 <ski> Gurkenglas : "the one of Reader sr a passes the initial state", only if you use `(>>=)' on `Reader sr' (and i wasn't considering doing that here)
02:16:38 <ski> (i only wanted to use an `Reader sr'-action as the *last* action in a "chain" of (otherwise) `State sr'-actions)
02:17:03 <ski> (talking about the variant of `(>>=)' above, here)
02:17:24 <Gurkenglas> (Ooh another way of saying my thing is that project is not a monad homomorphism)
02:17:51 <ski> (the `State sr a -> Reader sr [a]' would be another, related, operation for relating `State' to `Reader'. you could possibly use it as the last action in such a chain as above)
02:18:26 <ski> Gurkenglas : hm. good point
02:19:22 <ski> i suppose it makes sense, since i wasn't here interested in sequencing multiple `Reader sr'-actions together
02:19:46 <ski> but it's a good observation. ty
02:21:51 * ski wanders off for a bit
02:22:02 <MichaelBurge> What's the right way to write this one-liner expression in ghci? let f x = do { let y = x ; y }
02:25:04 <int-e> MichaelBurge: the "let" inside the "do" has its own code block: let f x = do { let { y = x }; y }
02:25:47 <MichaelBurge> int-e: Oh nice - thanks.
02:26:42 <gfixler> are there supposed to be 2 author name fields in ~/.stack/config.yaml?
02:28:34 <lpaste> gfixler pasted ‚ÄúShould there be two author name fields in ~/.stack/config.yaml?‚Äù at http://lpaste.net/3806660098906914816
02:28:59 <gfixler> should authorName be in there?
02:29:40 <MichaelBurge> gfixler: My configuration doesn't have authorName. I'm guessing they renamed the variable at some point, and there are traces of it for compatibility reasons?
02:30:45 <gfixler> MichaelBurge: oh, that might be it
02:34:23 <gfixler> strange, I've done a stack upgrade, and removed authorName, but I'm getting a warning now that I should include it
02:34:29 <gfixler> so my stack still wants authorName
02:34:40 <gfixler> MichaelBurge: are you using nightly?
02:35:15 <gfixler> ah, I think it's the template (new-template) that's looking for these params
02:37:23 <gfixler> yep, stack upgrade/update seems to have fixed it
02:54:50 * hackagebot servant-csharp 0.0.7.1 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.7.1 (KatsutoshiItoh)
02:59:59 <MichaelBurge> I noticed that TemplateHaskell quotations let you splice expressions into them with $(), which is convenient. It makes me curious though: How would one write a quoted splice expression?
03:05:59 <lyxia> MichaelBurge: what do you mean
03:06:20 <lyxia> Isn't it simply an expression of type Q Exp
03:07:34 <MichaelBurge> lyxia: The quoted type of "5" is "LitE (IntegerL 5)". What is the quoted type of "$(x)"?
03:08:19 <lyxia> it's whatever the type of 5 is in this context
03:08:35 <lyxia> aahh no nvm I missed your point
03:11:32 <troydm> I'm creating a process using forkIO how do I wait for a process to finish?
03:13:28 <lyxia> http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html troydm this says you have to program it yourself using MVars for instance
03:13:42 <troydm> lyxia: hmm, ic
03:17:01 <lyxia> MichaelBurge: this doesn't seem possible, nor very useful as you can use Q as a monad to use quoted expressions within another quoted expression
03:21:12 <MichaelBurge> lyxia: I guess the only use I can think of is if you don't have an expression on hand, but expect one to be in scope by the time the topmost splice runs?
03:22:09 <lyxia> you can write a function in that case, and pass the expression once it is within scope
03:22:47 <Lovepon> Guys, before you learned the best language, were you exposed to imperative programming?
03:23:17 <Lovepon> If not, how did you learn about  Haskell?
03:23:54 <MichaelBurge> Lovepon: C was my first programming language. lcc-win32 was my first compiler for it.
03:24:58 <Lovepon> MichaelBurge: I C.
03:25:42 <Oejet> Lovepon: Pascal made my head hurt, because it didn't have line numbers. I learned about Haskell through SML, and a general interest in programming languages.
03:25:57 <Lovepon> Oejet: It didn't have line numbers?
03:27:34 <Oejet> Lovepon: Oh, and this paper: http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html. No, not like BASIC did.
03:28:08 <Lovepon> Oejet: Add a space between the sentence-ending period. :P
03:28:42 <Boomerang> I learned Haskell in my first year of Uni :)
03:28:52 <Lovepon> Oejet: I like how the paper dates back to 1984.
03:28:58 <Lovepon> Oejet: Checking rn.
03:35:03 <Lovepon> Boomerang: Did you knowprogramming even before?
03:35:44 <Boomerang> Not much ^^ Bit of BASIC and html/css (which isn't programming I guess)
03:36:10 <Boomerang> But I've learned a lot about programming since my first year of Uni
03:36:17 <Lovepon> Boomerang: CSS can be Turing complete with an auto clicker. :P
03:36:32 <Boomerang> I didn't know that at the time ^^
03:36:47 <Boomerang> What was your first language?
03:36:56 <Lovepon> Boomerang: What's your favorite language to this date?
03:37:02 <Lovepon> Boomerang: Lua, then C, then Haskell.
03:37:14 <troydm> I'm using streaming-commons runTCPClient, from inside function that has AppData -> IO ()  how can I check if connection is closed or not?
03:38:16 <Boomerang> Haskell is definitely my favourite! :)
03:48:29 <troydm> is there equivalent function to forver from Control.Monad but one that takes condition?
03:48:43 <troydm> something like while cond action
03:49:34 <lyxia> troydm: see the monad-loops package
03:54:35 <Boomerang> let while cond action = when cond $ do action; while cond action
04:10:03 <troydm> I'm using streaming-commons and runTCPClient 
04:10:12 <troydm> how can I detect if connection was closed?
04:10:38 <troydm> I can take socket object out of AppData and check it that way but I'm not sure if it's correct way to do that
04:28:17 <runeks> How would I go about generalizing an operation that needs to compare many "Maybe a" values, where a is different for each value so I can't use a list combined with map/fmap.
04:28:35 <runeks> I'm trying to generalize operations on the Optional fields in this protobuf message:
04:28:44 <runeks> https://www.irccloud.com/pastebin/Qre1AVQF/protobuf%20
04:29:54 <xa0> runeks: applicative, presumably
04:30:15 <xa0> compare <$> maybeA <*> maybeB
04:31:38 <runeks> xa0: What would the type signature of "compare" be? The same list of Optional fields as that in TwoWayChannelMessage?
04:32:33 <xa0> runeks: a -> b -> result -- whatever the comparison would do without maybe
04:32:45 <xa0> i haven't read the paste, can't right now
04:33:02 <magneticduck> runeks: (compare <$> maybeA) <*> maybeB
04:33:12 <magneticduck> @type <*>
04:33:13 <lambdabot> parse error on input ‚Äò<*>‚Äô
04:33:17 <magneticduck> @type (<*>)
04:33:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:33:37 <xa0> magneticduck: that's what i said :p
04:34:01 <magneticduck> yeah I saw what you wrote
04:34:03 <runeks> But I need to compare 6 items. Not two. How would I do that?
04:34:40 <xa0> add more <*>s for each extra argument
04:34:59 <xa0> compare3 <$> maybeA <*> maybeB <*> maybeC
04:35:18 <magneticduck> of course, you'll probably want to do a fold
04:35:30 <runeks> xa0: And then I would have to define compare27 if I need to compare 27 items?
04:35:45 <magneticduck> finding an appropriate accumulator function with ap and fmap is left as an exercise to the student
04:35:51 <xa0> you don't have to define anything, i just changed the name because it's a different function
04:36:08 <magneticduck> runeks: I assume you know what a fold is?
04:36:30 <magneticduck> or are you actually going to make a function with 27 arguments of different types
04:36:41 <runeks> magneticduck: I do. But how do I put different types in the list I fold?
04:36:44 <maerwald> xa0: that doesn't typecheck
04:36:57 <xa0> which?
04:37:14 <maerwald> > compare <$> (Just 1) <*> (Just 2) <*> (Just 3)
04:37:16 <lambdabot>      Couldn't match type ‚ÄòOrdering‚Äô with ‚ÄòInteger -> b‚Äô
04:37:16 <lambdabot>      Expected type: Integer -> Integer -> Integer -> b
04:37:16 <lambdabot>        Actual type: Integer -> Integer -> Ordering
04:37:34 <runeks> It would be more like
04:37:42 <xa0> because i was using 'compare' as a placeholder
04:37:58 <magneticduck> > let f = (undefined :: a -> b -> a)
04:37:59 <lambdabot>  <no location info>:
04:37:59 <lambdabot>      not an expression: ‚Äòlet f = (undefined :: a -> b -> a)‚Äô
04:37:59 <maerwald> xa0: then as was already said you have to define a new function
04:38:19 <xa0> i think i said that :p
04:38:21 <runeks> > compare <$> Just 2 <*> Just 'a' <*> Just True <*> Just 1.25
04:38:22 <maerwald> for that specific number of arguments
04:38:23 <lambdabot>      Couldn't match type ‚ÄòOrdering‚Äô with ‚ÄòBool -> Double -> b‚Äô
04:38:23 <lambdabot>      Expected type: Char -> Char -> Bool -> Double -> b
04:38:23 <lambdabot>        Actual type: Char -> Char -> Ordering
04:38:33 <magneticduck> runeks: what.. are you trying to do?
04:38:36 <maerwald> xa0: you said "you don't have to define anything"
04:38:46 <xa0> i'm assuming runeks has a function that compares these items without Maybe
04:38:57 <xa0> and wants to now compare them with Maybe
04:39:00 <xa0> correct me if i am wrong
04:39:22 <runeks> magneticduck: Generalize a comparison of many values that all reduce to a "Maybe a", where "a" is different for each value.
04:39:53 <magneticduck> runeks: 'reduce'?
04:40:08 <magneticduck> anyway, the answer has already been given
04:40:09 <xa0> runeks: define "comparison"
04:40:15 <magneticduck> if you want point-free:
04:40:27 <magneticduck> @pl (\x y -> f <$> x <*> y)
04:40:28 <lambdabot> ((f <$>) .) . (<*>)
04:40:28 <runeks> Ok. Let me be more specific (gimme a minute)
04:40:35 <magneticduck> @pl (\x y x -> f <$> x <*> y <*> z)
04:40:35 <lambdabot> const (((f <$>) .) . flip flip z . ((<*>) .) . flip (<*>))
04:40:50 <xa0> magneticduck: christ
04:40:54 <lyxia> If you have a function f :: A -> B -> C -> ... -> Z, and 25 values a :: Maybe Y, ..., y :: Maybe Y you can write f <$> a <*> b <*> c <*> ... <*> y :: Maybe Z
04:40:58 <maerwald> pointless not pointfree ;)
04:41:15 <magneticduck> xa0: well he wants to be general, I imagine he wouldn't want particular symbol bindings cluttering his code up
04:41:23 <magneticduck>  /s
04:41:27 <xa0> lol
04:41:31 <maerwald> how is poinfree more general?
04:41:47 <maerwald> same semantics
04:41:55 <Gurkenglas> Perhaps "one-edged" or "round"
04:42:21 <Gurkenglas> :t liftA3 -- magneticduck
04:42:22 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
04:42:26 <xa0> :t liftA23
04:42:28 <lambdabot>     Not in scope: ‚ÄòliftA23‚Äô
04:42:28 <lambdabot>     Perhaps you meant one of these:
04:42:28 <lambdabot>       ‚ÄòliftA2‚Äô (imported from Control.Applicative),
04:43:28 <Gurkenglas> If your function has 23 arguments it has no right to look good, or it transcends ekmetts arcanery by like 15 levels
04:44:04 <lyxia> good. Mine has 25.
04:44:25 <xa0> :t liftA14
04:44:26 <lambdabot>     Not in scope: ‚ÄòliftA14‚Äô
04:44:27 <lambdabot>     Perhaps you meant one of these:
04:44:27 <lambdabot>       ‚ÄòliftA‚Äô (imported from Control.Applicative),
04:44:55 <magneticduck> runeks: anyway if you're doing a huge amount of work in Maybe, just use its Monad instance and your code will be nice and clear with do notation
04:45:22 <magneticduck> do { readValue <- something; otherValue <- something; createValue readValue other value; }
04:45:35 <magneticduck> I promise nobody's going to look at you funny
04:45:39 <Gurkenglas> dont forget ApplicativeDo
04:45:46 <Peaker> is there a nice tool to update a bunch of git hashes in a stack.yaml according to local file system clones?
04:45:46 <magneticduck> oh right
04:46:54 <runeks> Let's say you have a set of values of type "Maybe <something>" (Maybe Int, Maybe Char, Maybe Float, etc.) and you want to check whether only a single of these values are a "Just", such that the rest are Nothing. How would I do that? I can't use a fold because a list can't contain different types.
04:47:34 <magneticduck> length . filter isJust $ [fmap (const undefined) x, fmap (const undefined) y]
04:47:39 <magneticduck> I feel so dirty
04:47:48 <magneticduck> oh also that might not type check because of the ambiguous type variable
04:47:59 <Gurkenglas> Where do the values come from? Sounds like you want to involve "data Foo = FooInt Int | FooChar Char | FooFloat Float | etc."
04:48:11 <lyxia> magneticduck: void is your friend
04:48:18 <magneticduck> lyxia: riight
04:48:24 <magneticduck> my Haskell is rusty I think
04:48:43 <magneticduck> but that's also a bit of a silly way of writing it, fmap (const ()) could just be isJust
04:48:43 <xa0> yeah i don't think this is a thing that should need to be done
04:48:44 <runeks> Gurkenglas: They are the Optional field in this data structure: https://www.irccloud.com/pastebin/Qre1AVQF/protobuf%20
04:50:32 <runeks> fieldS
04:52:45 <Gurkenglas> runeks, you want to return a boolean that says whether there is exactly one just value, or you want to combine all/the first just value(s) in some way?
04:53:40 <Gurkenglas> *combine all just values/extra the first just value
04:57:39 <runeks> Gurkenglas: I just want to know that there is exactly one.
04:59:58 <Gurkenglas> f a b c d e f = (== 1) $ length $ filter id [isJust a, isJust b, isJust c, isJust d, isJust e, isJust f] is fine given that specification (which hints that the specification smells). Why do you want that boolean?
05:02:57 <orb> runeks: what do you need that function for?
05:03:25 <xa0> :t any
05:03:27 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
05:03:34 <orb> firstJust :: [Maybe a] -> Just a
05:03:40 <xa0> Also yes
05:04:06 <xa0> Wait no, that wouldn't work because it needs polymorphism in a
05:04:11 <runeks> Gurkenglas: Because only one of the optional fields can be set in order for it to be a valid message. I guess you're right, it's the specification that's the problem. I just thought there would be a simple way to generalize it.
05:04:28 <magneticduck> Gurkenglas: in some unholy languages, sum types aren't a native language feature
05:04:38 <magneticduck> they're implemented like this
05:04:40 <magneticduck> it's horrifying
05:05:33 <Gurkenglas> Well then I guess write a library that interfaces with those languages by first converting such types to sum types, I guess.
05:05:47 <orb> runeks: yuck.
05:06:08 <orb> runeks: are you doing protobufs?
05:06:20 <runeks> orb: Yup
05:06:34 <xa0> Even C has sum types :(
05:06:41 <orb> runeks: do you happen to work at Google?  We have a bunch of internal Haskell libraries for that, by now.
05:06:46 <magneticduck> xa0: no it doesn't
05:06:52 <magneticduck> you're thinking of unions
05:06:58 <magneticduck> unions are not sum types, tagged unions are
05:07:16 <xa0> Okay, but they're close
05:07:22 <magneticduck> and unions have their own set of horrifying problems
05:07:27 <orb> runeks: on the wire format, I think the last message wins?
05:07:30 <runeks> orb: No I do not. But please get someone to release those libraries if you do.
05:07:36 <orb> Ie when your oneof has multiple things set, the last one wins?
05:07:39 <magneticduck> in C++ you can't even use them as sum types because they don't hold non-POD members
05:08:01 <Freundlich> magneticduck: That's not true.
05:08:04 <troydm> suggest good command line parsing library
05:08:18 <cocreature> troydm: optparse-applicative
05:08:29 <Freundlich> magneticduck: You can build an either around unions just fine. The details are ugly but the end result is pretty usable.
05:08:30 <troydm> cocreature: k, thx
05:08:31 <orb> runeks: (if what I said earlier is true,) it might be a good idea to instead write a `normalizing' function, and not a validator.
05:08:47 <orb> Freundlich: your compiler doesn't help you there, though?
05:08:57 <magneticduck> Freundlich: unions cannot hold non-POD types
05:09:01 <Freundlich> orb: You have to call constructors/destructors yourself.
05:09:12 <magneticduck> and since the language doesn't give you any sort of help with it anyway, you might as well use two optional<> fields
05:09:22 <magneticduck> because at least like that, you can't accidentally read corrupted data
05:09:48 <runeks> orb: I wan't aware there was a "oneof" keyword for protocol buffers. I should probably gem them to merge such a change if it's as simple as that.
05:09:55 <orb> protobufs could have been nice.  But they have to play to the lowest common denominator of Go, C++ and Java..
05:10:11 <Freundlich> magneticduck: As I said, it's not true. It holds for C++03 but not for newer versions of the language.
05:10:19 <orb> https://developers.google.com/protocol-buffers/docs/proto#oneof
05:10:31 <magneticduck> Freundlich: I wasn't aware of that
05:10:41 <magneticduck> (I wasn't sure what part of my statement you were saying was false, previously)
05:11:14 <orb> It's really bad that the newer versions of protobuf push you to not distinguish between an number that's zero vs not set.
05:11:23 <orb> (Even though the wire format is perfectly able to express that.)
05:12:05 <Freundlich> magneticduck: Writing an either is very doable. If you add a match function you are pretty much set. It's a shame that C++ doesn't offer these things on its own.
05:12:20 <runeks> orb: Perfect! I will try that out.
05:12:41 <orb> They have Either in boost or so?
05:14:07 <xa0> Boost::variant
05:14:14 <xa0> Also, https://github.com/solodon4/Mach7
05:14:57 <magneticduck> Freundlich: there's also boost::variant
05:15:13 <xa0> ...
05:15:18 <magneticduck> lol
05:17:05 <Freundlich> magneticduck: I know but that's not implemented using unions.
05:17:48 <runeks> orb: Looks like the Haskell library I'm using (Data.ProtocolBuffers) doesn't support "oneof" :\
05:18:22 <orb> runeks: do they accept contributions? ;)
05:18:53 <runeks> orb: They do, but I have no idea how to implement it.
05:19:10 <orb> runeks: are you using https://hackage.haskell.org/package/protocol-buffers ?
05:19:42 <runeks> orb: I'm using https://hackage.haskell.org/package/protobuf
05:20:45 <orb> runeks: in any case, if you have the time, you could offer to implement it for them, in exchange for some hints on how to.
05:21:11 <orb> runeks: a short email often works wonders.  they probably already have an idea, but not enough time (or motivation).
05:21:32 <runeks> orb: That may be the end of it.
05:21:37 <troydm> is there a way to have integer option using optapplicative ?
05:22:02 <orb> runeks: is yours a hobby project or for money?
05:22:19 <lyxia> troydm: you mean optparse-applicative?
05:22:20 <cocreature> troydm: yep, use auto
05:22:34 <troydm> lyxia: yes
05:22:38 <cocreature> :t option auto
05:22:40 <lambdabot>     Not in scope: ‚Äòoption‚Äô
05:22:40 <lambdabot>     Perhaps you meant ‚Äòoptional‚Äô (imported from Control.Applicative)
05:22:40 <lambdabot> Not in scope: ‚Äòauto‚Äô
05:23:23 <cocreature> option auto (long "integer-option") -- that should work
05:28:39 <ntnt> i need to implement a new function "genUniqueName :: m String" which returns me a fresh, new string every time I call it (think renaming)
05:28:47 <ntnt> it can't be :: String since it has to return different values across calls
05:28:53 <guillaum3> Hello. I'm a bit lost with Shake build system, especially the difference between `(&%>)` and `(|%>)`.
05:28:56 <ntnt> I'd prefer it not be :: IO String since IO is "throws up hands / we give up"
05:28:59 <ntnt> what is the best I can do?
05:29:04 <troydm> cocreature: well I tried this : auto (long "port" <> short 'p' <> help "proxy port")
05:29:26 <troydm> and it says: 
05:29:31 <cocreature> troydm: that doesn‚Äôt typecheck, you need the option before it
05:30:11 <troydm> cocreature: ahh, right thx
05:30:35 <troydm> how do I specify default values?
05:30:57 <cocreature> using value
05:31:11 <cocreature> option auto (long "port" <> value 1234)
05:31:39 <lyxia> ntnt: add a state in your monad, e.g. using StateT.
05:31:43 <troydm> cocreature: thx
05:31:47 <ntnt> but then all my code whihc uses this
05:31:51 <ntnt> has to be aprt of this State Monad ?
05:31:53 <mmercer2> ntnt MonadRandom?
05:32:46 <lyxia> ntnt: yes you have to carry the state everywhere you use it
05:36:18 <ntnt> is there any situation where splitRoot ( https://hackage.haskell.org/package/containers-0.5.7.1/docs/src/Data.Set.Base.html#splitRoot ) *guarantees* that each of the pieces is atleast a constant fraction of the size of the set?
05:36:30 <ntnt> it seems that for it ti be O(log n) for most ops, there must be some gaurantees on the size of l/r, relative to the original set
05:38:26 <runeks> orb: It's a hobby project that will hopefully turn into something profitable.
05:39:02 <ntnt> is there something slightly stronger than "Ord" which says "not only can you compare two of these things, but you can also increment it to get the *next* one" ,i.e. Int would satisfy, but Rat / Real would not satisfy
05:39:07 <lyxia> ntnt: You can have a logarithmic number of levels where the split is very unbalanced.
05:39:20 <ntnt> lyxia: true
05:39:24 <apriori> hello guys. is there a list of the meaning of the cryptic haskell "exitfailure" codes?
05:39:38 <ntnt> lyxia: I want, in O(log n) time, to find "smallest unused" key; I thikn splitRoot can help me
05:39:51 <ntnt> it can waste atmost O(log n) unbalanced levels, other levels have to be sorta balanced (i.e. atleast >= 1/5 in one of them)
05:39:57 <ntnt> so I only have to do O(log n) levels ttl
05:40:57 <runeks> orb: In the long run at least. To begin with, it's just implementing Bitcoin payment channels in a Haskell library.
05:42:08 <lyxia> ntnt: I don't think you can do this in logarithmic time
05:42:15 <ntnt> lyxia: yeah, it's O(log^2 n) time
05:42:28 <ntnt> it's O(log n) time to get smallest/largest of a set
05:42:42 <ntnt> so each time, to descend a level, I need O(log n) time to decide whether ot go left or right
05:42:43 <linc> Hello, can someone explain to me why the compiler can't deduce (a ~ [a]) and what that even means? small code and full error is here: http://pastebin.com/nQ5Ze5Nq
05:42:49 <ntnt> then I have to go O(log n)_ levels, so O(log^2 n) time
05:43:03 <lyxia> ntnt: how does splitRoot help
05:43:50 <opqdonut> linc: a ~ [a] means that the type "a" would need to be the same as the type "[a]", which is impossible
05:44:00 <ntnt> lyxia: I use splitRoot to, in O(1) time get left/right subsets
05:44:03 <int-e> ntnt: With the current implementation, in the Bin case, the l and r piece sizes are supposed to be within a factor of 3 of each other, provided that they're not empty.
05:44:19 <ntnt> int-e: yeah, that's enough, even if O(log n) levels are unbalanced, that's fine
05:44:26 <opqdonut> linc: as the compiler says, "Expected type: [[a]] Actual type: [a]"
05:44:35 <ntnt> the ttl level has to be O(log n) for insert/delete to be O(log n); so I'm fine
05:44:46 <linc> opqdonut: ah, okay. I'll try to wrap my head around that. Thanks
05:44:56 <opqdonut> linc: so allproducts took in xs and ys both of type [a]
05:45:10 <cocreature> linc: you are passing ys which has type [a] to aux as the second argument which has to have type [[a]], so the compiler tries to figure out why [a] and [[a]] are the same and gets stuck because a and [a] are not the same
05:45:13 <opqdonut> linc: and now you're trying to call "aux xs ys" but the second argument of aux has type [[a]]
05:45:25 <xa0> Why can't we construct infinite types though, I sort of want to just to be stubborn
05:46:03 <opqdonut> xa0: well, the infinite type t=[t] would be pretty useless
05:46:09 <linc> opqdonut: oh, right! what a dumb mistake :) thanks a lot
05:46:18 <xa0> I know, but I want to be stubborn :p
05:49:05 <ph88^> can someone explain what liquidhaskell is ?
05:49:17 <ntnt> (I'm trying to figure out if this thing is going to overflow a js number, since I am using ghcjs). JS can represent numbers up to 2^53 -1 accurately. Now, for my id counter -- my machine can do at most 10^9 ops / second, * 60 seconds / minute * 60 minutes / hour * 24 hours / day * 365 days / hear * 10 years / decade < 2^64 -- so a 64bit counter should *never* flow, even if my haskell program does nothing but increment it --- right?
05:50:55 <ntnt> okay ; for the bytestring package, is there an 'incrmeent' function, which gives us the next smallest bytestring (larger than the current one)
05:51:20 <hfish> has anybody worked with Network.SocketIO ?
05:51:45 <cocreature> ntnt: the next smallest bytestring that‚Äôs larger than the current one? that doesn‚Äôt make any sense
05:51:56 <ntnt> the *smallest* bytestring larger than the current one
05:52:00 <ntnt> as dfined by the Ord operator on bytestrings
05:52:04 <ntnt> cocreature: ^
05:52:05 <hfish> I'm looking at the current api and see no way how I could broadcast to all clients from another thread
05:52:58 <cocreature> ntnt: ah, I don‚Äôt think that exists. what are you trying to do? if you just want arbitrary precision integers, use Integer
05:53:15 <ntnt> cocreature: good call, I am solving XY problem
05:53:27 <ntnt> are Integers's stored as efficeinty as Bytestrings ?
05:53:52 <cocreature> not sure about ghcjs, ghc uses gmp for Integers which is a pretty efficient c library
05:54:06 <hfish> because the initialize handler is called whenever a new connection needs to be handled and otherwise I see no way to access the underling EngineIO
05:54:37 <cocreature> but I would assume they‚Äôre stored efficiently
05:54:51 <cocreature> there is no reason why a bytestring should be better, otherwise you could just replace the implementation of Integer
05:57:02 <fr33domlover> Is there a version of foldr/foldl which supports stopping the loop in the middle depending on some condition (e.g the first parameter is of type a -> b -> Maybe b) ?
05:57:26 <fr33domlover> is it this something to always do using recursion?
05:57:37 <ntnt> cocreature: it's possible that bytestring is slightly better becuase it doesn't ahve to deal with computation
05:57:46 <ntnt> I suspect Integer is optimzied for +-*/ ; whereas bytestring is just optimized for storage
05:58:50 <ntnt> I don't even need Integer
05:58:51 <cocreature> ntnt: fair enough, but I doubt that difference is significant. also if you want the next larger integer , you are basically doing addition
05:58:59 <ntnt> I'd be happy with a 128bit Int
05:59:00 <lyxia> fr33domlover: foldr doesn't traverse the whole list if it doesn't need to
05:59:04 <ntnt> cocreature: well, it's only adding 1
05:59:11 <ntnt> which I think is simpler than adding two arbitrary bytestrings
05:59:40 <ARM9> fr33domlover, you could compose a fold with takeWhile or such
05:59:44 <lyxia> fr33domlover: but that is specific to cons lists I believe. snoc lists behave the other way around
06:01:29 <fr33domlover> ARM9, lyxia, thanks
06:02:17 <ARM9> won't work with strict containers though
06:02:38 <ntnt> does anyone know if ghcjs compiles ghc Ints to Ints or JS Doubles ?
06:02:46 <ntnt> does ghcjs do its own work to ensure that Ints stay with Int semantics?
06:05:28 <the_java_guru> hello
06:06:04 <ARM9> haven't used ghcjs but it should just have to generate |0 or >>0 etc., check the output
06:10:15 <mtesseract> Hi
06:17:42 <ertes> fr33domlover: foldr can stop the recursion
06:18:08 <the_java_guru> is there a way to create a map from a vector without converting to a list first?
06:18:18 <ertes> > foldr (\x xs -> if x < 10 then x : xs else []) [] [2..]
06:18:20 <lambdabot>  [2,3,4,5,6,7,8,9]
06:18:38 <the_java_guru> ertes i tried the :m to unload/reload a module yesterday, but it didn't seem to reload the code
06:18:50 <ertes> but the condition for stopping has to follow from a single element
06:19:51 <ertes> the_java_guru: hmm, i see‚Ä¶  well, then you need to improve your data reader and/or use the other suggestions
06:20:45 <the_java_guru> ertes well Foreign.Store can sort of be a workaround
06:21:08 <ertes> the_java_guru: what's that?
06:21:43 <the_java_guru> ertes https://stackoverflow.com/questions/29752557/automatically-reloading-variable-state-into-ghci-when-re-loading-a-file
06:22:21 <the_java_guru> ertes the main downside is that you have to do save/load state manually. it's also kind of a bummer to have to specify the type to reload state.
06:23:00 <the_java_guru> so i end up littering my code with these monadic functions meant to be evaluated interactively
06:23:15 <the_java_guru> kind of a cool trick and better than nothing though
06:26:13 <the_java_guru> pretty neat eh?
06:32:26 <apriori> did anyone have an ExitFailure(-11) error yet and found the solution?
06:32:57 <apriori> (in cabal of course, offending package accelerate-llvm from git). cause is  llvm-general
06:34:30 <ertes> the_java_guru: ah, i see
06:34:53 <ertes> the_java_guru: nice workaround, but it would be better to improve your loader
06:34:57 * hackagebot streaming-commons 0.1.15.4 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.15.4 (MichaelSnoyman)
06:34:59 * hackagebot shakespeare 2.0.8.2 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.8.2 (MichaelSnoyman)
06:36:41 <zigschots20> ntnt: what do you mean throw hands up and give up?
06:37:35 <the_java_guru> ertes for my current analysisi'm mostly loading large-ish csv and json files (~ 300 MB). there's not all that much to do.
06:38:21 <the_java_guru> pretty much a straight lazy bytestring readFile followed by decodeByNameWith using cassava
06:39:01 <zigschots20> oops, think my irc was massivley lagging
06:39:25 <the_java_guru> it would be a non-issue issue if I was just running this once as a batch job, but iterating on code changes kind of sucks.
06:41:23 <ntnt> in haskell, how do I check if Int + Int is about to overflow ?
06:42:00 <hvr> ntnt: "about to"?
06:42:09 <ntnt> a, b are valid ints
06:42:12 <ntnt> but a + b overflows
06:42:23 <ntnt> how do I detect the case?
06:42:29 <hvr> ok, so "about to" was redundant in there :-)
06:42:44 <Sornaensis> > maxInt
06:42:46 <lambdabot>  Not in scope: ‚ÄòmaxInt‚Äô
06:42:58 <hvr> ntnt: there's a generic way that works for all languages
06:42:58 <Sornaensis> > maxBound :: Int
06:43:00 <lambdabot>  9223372036854775807
06:43:08 <Sornaensis> > maxBound + 20 :: Int
06:43:10 <lambdabot>  -9223372036854775789
06:43:11 <the_java_guru> is there a way to get some text coloring of error messages for Interactive-Haskell mode in spacemacs? the wall of text noise gets pretty taxing to parse
06:43:18 <ntnt> yeah, but I can't do if (a + b > maxBound)
06:43:23 <ntnt> so what is the idiomatic way to check?
06:43:37 <hvr> ntnt: i.e. you make case-analysis on the input arguments and compare where the result falls into
06:44:01 <ntnt> suppose I have 0 <= a < maxBOunt, 0 <= b < maxBound
06:44:07 <ntnt> I can just check if (a+b <0) right?
06:44:29 <fr33domlover> > maxBound :: Int + maxBound
06:44:30 <lambdabot>  Not in scope: type constructor or class ‚Äò+‚Äô
06:44:37 <fr33domlover> > (maxBound :: Int) + maxBound
06:44:38 <lambdabot>  -2
06:45:34 <Sornaensis> you can check whether the sign changes and you're adding two numbers with the same sign
06:45:44 <hvr> ntnt: let c = a + b; if c < 0 then a > b else a < b
06:45:54 <ntnt> okay, this makes sense:
06:45:59 <ntnt> diff signs => adding can't overflow
06:46:06 <ntnt> same signs => result diff sign => either over or underflow
06:46:41 <hvr> ntnt: that works too
06:46:56 <ntnt> nice; thanks for everyone's patience in explaining this to me
06:47:12 <hvr> ntnt: the important thing is that it's mostly language independent
06:48:08 <hvr> ntnt: if you have time, it'd be useful to think about how to detect overflow for unsigned bounded integer types
06:48:24 <hvr> (it's also quite easy )
06:48:28 <ntnt> hvr: if c < a or c < b
06:48:30 <ntnt> then we overflowed
06:48:39 <ntnt> hvr: anything more than that? :-)
06:48:44 <hvr> nah :)
06:49:03 <ntnt> hvr: clearly you deserve some teaching award :-)
06:49:20 <hvr> virtual beer suffices :)
06:49:24 <portnov> @pl \n m -> n m
06:49:24 <lambdabot> id
06:51:53 <saurabhnanda> is it alright as a haskell newbie to be completely stumped by error/exception handling?
06:52:03 <saurabhnanda> I wrapped by head around ExceptT only to read Snoyman's blog post about it being an anti-pattern
06:52:25 <saurabhnanda> what is the recommended way of dealing with errors/exceptions in Haskell?
06:53:15 <hvr> saurabhnanda: It depends on what the inner monad to ExceptT is; it's not always an anti-pattern
06:55:00 <saurabhnanda> hvr: my inner monad is NwApp, which is basically SqlPeristT (from yesod/persistent library). Also, I don't want to think so much for such a commonly occurring & trivial programming task. So, is there a way to deal with errors/exceptions which works 95% of the time?
06:55:44 <saurabhnanda> right now I'm looking at Control.Monad.Catch and Control.Monad.Except and wondering which to use when?
07:08:26 <ntnt> should Doubly Linked List be named as DLL or Dll ?
07:08:49 <quxbam> Is there a function which does:  either (const x) id (f x) ?
07:09:32 <Gadget3000> If pattern matching is performed on each pattern in order, why are functions that loop through a list often written with the empty list pattern first? Surely it's the least likely case so matching against empty list then non-empty list for every element is slower than the other way around?
07:10:03 <saurabhnanda> I'm using stack and have added 'exceptions' to 'build-depends', but neither 'stack build' nor 'stack solver' seems to be detecting this new dependency. What gives?
07:10:16 <Gadget3000> Or is my thinking of how pattern matching works once compiled incorrect
07:10:34 <quxbam> Gadget3000: if you match on xs, [] will be as well matched
07:13:19 <ARM9> Gadget3000, when iterating a list in C you'd first check if the next item is a null pointer, no?
07:13:51 <quxbam> Gadget3000: Pattern matching is tried in order, so you *have* to begin with the most specific case
07:14:24 <OS-19514_>  /msg NickServ SETPASS OS-19514 ajmcmmyvfzkl Miami55Dolphins!!!
07:14:27 <Gadget3000> Sorry I meant in the case where you match against (x:xs) then []
07:14:51 <quxbam> Well, I don't know, but I would suggest to benchmark it with criterion
07:15:45 <quxbam> But it would be at the very least an unusual style and dangerous, because you have to change order when you decide later on to match only on the entire list or the empty list
07:15:46 <ggVGc> Gadget3000: [] and (x:xs) match different cases
07:15:51 <ggVGc> it doesn't matter which order they are in
07:16:10 <quxbam> ggVGc: he asked if the order has got performance implications
07:16:14 <ggVGc> oh, okay
07:16:36 <quxbam> use criterion, it's really good
07:17:07 <ARM9> compilers are pretty good at reordering code these days
07:17:11 <ARM9> ymmv
07:17:35 <ARM9> if you're worried about performance I really must question your decision to use linked lists in the first place
07:18:18 <quxbam> linked lists can be used in high perf situations
07:18:32 <quxbam> if you don't use them to store data, but as control structure
07:19:27 <hpc> or in a performance context, linked lists encode O(n) time, not O(n) space
07:19:33 <Gadget3000> quxbam: Thanks. I'm looking up a tutorial on how to use it now ;)
07:20:57 <quxbam> Gadget3000: You're welcome.  But anyway I'd recommend against moving the empty match at the last position...
07:21:42 <quxbam> Has anyone a clue if theres somewhere a function which does  either (const x) id (f x)?
07:23:22 <ntnt> when things that are 'impossible' happens -- i.e.  a data structure breaks an invariant -- is it better to (1) just call error or (2) have some type of error handling and try to recover ?
07:24:50 <quxbam> ntnt: depends on the app
07:24:57 <exio4> ntnt: I would use error - it's supposed to be impossible, isn't it? 
07:25:10 <ntnt> quxbam: it's a webapp via ghcjs; it's not running in a fighter jet or anything
07:25:24 <quxbam> if it's some kind of web facing stuff, I wouldn't let it crash
07:25:33 <ntnt> exio4: yeah, it's like "this key is supposed to exist in the map"
07:25:43 <ntnt> and if it doesn't, what should I do
07:25:51 <exio4> ntnt: you better make sure the impossible doesn't happen then 
07:29:34 <t7> @hoogle filterM
07:29:36 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
07:29:36 <lambdabot> Data.Graph.Inductive.Graph gfiltermap :: DynGraph gr => (Context a b -> MContext c d) -> gr a b -> gr c d
07:29:36 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
07:33:22 <ertes> ntnt: (1)
07:33:53 <ertes> unless the invariant is only about performance‚Ä¶  if it's a semantics invariant, definitely error
08:30:48 <hsk3> > runStateT get 8
08:30:50 <lambdabot>      No instance for (Show (m0 (a0, a0)))
08:30:50 <lambdabot>        arising from a use of ‚Äòshow_M83111024766472335446793‚Äô
08:30:50 <lambdabot>      The type variables ‚Äòm0‚Äô, ‚Äòa0‚Äô are ambiguous
08:31:07 <hsk3> Why does this work in my GHCi?
08:31:23 <hsk3> It looks like GHCi is in my case defaulting to the IO monad. Is this what it should do?
08:34:17 <geekosaur> yes
08:35:16 <Kwoth> Hello, I'm just starting haskell, can i ask some very stupid questions? I'm trying to solve problems right away
08:35:44 <Kwoth> Managed to do the first Project Euler, stuck at second one now.
08:36:12 <Kwoth> fibb l = fibb (l ++ [((head l) + (head (tail l)))]) am i even on the right track?
08:36:53 <Kwoth> I thought haskell laziness will let me do this but nope, it wants to return the whole list
08:37:23 <lyxia> this will never return anything as fibb keeps calling itself with a larger and larger argument
08:38:06 <hsk3> geekosaur: but isn't lambdabot just GHCi?
08:38:16 <geekosaur> it is not
08:38:20 <hsk3> ah ok
08:38:39 <hsk3> geekosaur: where is this defaulting to IO monad documented?
08:38:44 <geekosaur> it's very different internally. ghci pretends to be the inside of a "do" in IO. mueval only handles pure expressions
08:38:59 <hsk3> ah ok!
08:39:01 <hsk3> it all makes sense now
08:39:07 <hsk3> GHCi is ALREADY IN IO MONAD
08:39:12 <hsk3> that's why it goes into IO monad
08:39:30 <geekosaur> (and if you use apure expression in ghci, it wraps it in `print`)
08:41:50 <hsk3> thanks
08:42:59 <monochrom> even that explanation is only approximate. it doesn't explain why "data X = XXX" is allowed.
08:43:33 <monochrom> the logical conclusion is that ghci is a unique power-morphing beast.
08:48:25 <geekosaur> yeh. it's had a lot of stuff hacked in to break the original model. things like "import" (vs. the old ":m +") and "data" are recent additions
08:48:50 <Lovepon> @src (&&)
08:48:50 <lambdabot> True  && x = x
08:48:51 <lambdabot> False && _ = False
08:48:54 <Lovepon> Hmmm
08:49:02 <Lovepon> &src (flip (&&))
08:49:06 <Lovepon> @src (flip (&&))
08:49:06 <lambdabot> Source not found. Abort, Retry, Panic?
08:49:11 <Lovepon> Okay, that was stupid.
08:49:23 <Lovepon> If I (flip (&&)), the order of testing would change, right?
08:49:34 <Lovepon> Actually, why the hell would I flip (&&)?
08:49:41 <Lovepon> When I can just do y && x
08:49:45 <Lovepon> I'm stupid. Thanks.
09:05:15 * hackagebot hspec-slow 0.1.0.0 - Find slow test cases  https://hackage.haskell.org/package/hspec-slow-0.1.0.0 (boblong)
09:08:48 <freeside> moo.
09:17:15 <freeside> /h/elp
09:17:22 <freeside> sorry, keyboard issues.
09:21:36 <Lovepon> Guys.
09:21:43 <Lovepon> So...
09:22:01 <Lovepon> On a scale of 10 to 10, how stupid am I for comparing the result of mod to a negative number?
09:22:53 <freeside> ouch.
09:23:10 <Lovepon> 2 hours.
09:23:12 <Lovepon> I spent 2 hours.
09:23:15 <Lovepon> Probably even more.
09:23:23 <Lovepon> Before realizing that.
09:23:39 <freeside> Prelude> mod (10) (-4)
09:23:39 <freeside> -2
09:23:52 <Lovepon> freeside: Both are positive.
09:23:54 <Lovepon> In my case.
09:24:25 <Lovepon> Anyways
09:24:29 <hpc> Lovepon: in your defense, numeric code is a cespool of everything being the same type and having to always know every formula perfectly
09:24:56 <freeside> this is why mathematicians are allowed to be bad at arithmetic.
09:24:57 <Lovepon> I was complaining why it wasn't represented as x = p - 1 (mod p)
09:25:09 <Lovepon> Then I realized that that would really just be x = -1 to make it cleaner.
09:25:23 <Lovepon> So, why didn't they make it x+1 = 0 (mod p)?
09:25:23 <hpc> i once typed 9 instead of 0
09:25:31 <hpc> because they're right next to each other
09:25:34 <Lovepon> That would have been like way less problematic code.
09:25:38 <freeside> two hours of your life you'll never get back, eh.
09:25:51 <hpc> lesson learned in any event
09:25:56 <Lovepon> hpc: lol
09:26:00 <Lovepon> So.
09:26:03 <hpc> (the lesson is that numeric bugs take forever to find)
09:26:07 <freeside> there's got to be a list of Top Ten Dumbest Bugs To Check
09:26:12 <Lovepon> On the bright side, I just implemented https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test
09:26:19 <freeside> it would probably be Top One Hundred
09:26:50 <hpc> okay that's a pretty neat algorithm
09:27:11 <Lovepon> I think I did it pretty clean too.
09:27:14 <freeside> can i see your code?
09:27:58 <hpc> i like the complexity of the deterministic version: Œò(log n log log n)
09:28:54 <Lovepon> I'm going to release this open source, sooner or later.
09:29:09 <Lovepon> A Haskell-only alternative to arithmoi! Nah, who am I kidding lol.
09:29:15 <Lovepon> hpc: freeside: https://gist.github.com/Myrl/310fbdf05c23f8ecb243f4e8e60851a1
09:29:33 <Lovepon> Also, it's not exactly clean.
09:29:57 <Lovepon> By "clean" I meant that it should be fast.
09:29:59 <Lovepon> Should be...
09:30:43 <Lovepon> hpc: freeside: Assumptions assumptions. If all arithmetic operations are O(1), wouldn't this be O(log n)?
09:30:43 <freeside> what would you do to make it faster?
09:31:24 <Lovepon> Hmmm...
09:31:29 <Lovepon> It's not as fast as I expected. I wonder why.
09:34:20 <Lovepon> freeside: hpc My computer just crashed. Lol.
09:34:49 <freeside> orly.
09:34:57 <Lovepon> freeside: Yep.
09:36:42 <freeside> hmm. have you tried with even p?
09:36:44 <cocreature> Lovepon: there might be a spaceleak in generatesd' because you are accumulating succ(succ(succ(‚Ä¶a)))
09:37:11 <Lovepon> freeside: With even p, it's an error.
09:37:25 <cocreature> the strictness analysis will probably save you if you compile with optimizations, but it‚Äôs somewhat risky to rely on it
09:37:46 <Lovepon> cocreature: Right. I'm testing it out with -O2 just for interest.
09:39:00 <Lovepon> Yep.
09:39:07 <Lovepon> Even with O2.
09:39:27 <Lovepon> Hmmm
09:40:04 <Lovepon> cocreature: I need your opinion on this.
09:40:21 <Lovepon> cocreature: I can already build the list even at generatesd'
09:40:55 <Lovepon> cocreature: The question is, would it be worse to modulo large numbers, or would it be worse to rebuild the list by repeated multiplication?
09:41:35 <cocreature> Lovepon: the only good answer to that is: benchmark
09:41:41 <Lovepon> cocreature: Right.
09:43:03 <Lovepon> Oh cool.
09:45:05 <Lovepon> Wow.
09:45:09 <Lovepon> This was almost instant.
09:45:17 <Lovepon> WTF?
09:45:41 <freeside> what was?
09:45:55 <freeside> the modulo?
09:46:02 <Lovepon> Hmmm
09:46:06 <Lovepon> It's also wrong.
09:46:08 <Lovepon> Lol.
09:46:30 <cocreature> who cares about correctness anyway, the important thing is that it‚Äôs fast!
09:46:35 <Lovepon> cocreature: LOL
09:47:43 <freeside> fail fast! pivot!
09:49:33 <Lovepon> Awww yiss
09:49:41 <Lovepon> According to my new code, all even numbers are prime!
09:49:49 <Lovepon> Heck, *everything* is prime.
09:49:55 <Lovepon> This simplifies everythin!
09:51:02 <gfixler> isPrime :: Int -> Bool; isPrime _ = True
09:51:04 <gfixler> omg
09:51:05 <xa0> Rip
09:52:31 <Lovepon> xa0: I don't see how instruction pointers have to do with anything.
09:52:47 <xa0> :D
09:53:30 <monochrom> because instruction pointers are prime numbers, too.
09:53:59 <maxcozzetti> Hi everyone
09:54:03 <maerwald> man, OverloadedStrings doesn't work well with Gtk+ bindings :P
09:54:36 <maxcozzetti> Ok, i'll change my nickname
09:55:07 <Lovepon> Oh.
09:55:09 <Lovepon> I'm stupid.
09:55:19 <maxcozzetti> Hi everyone again
09:55:34 <monochrom> nick name not changed. is that alright?
09:55:53 <maxcozzetti> I'll try again
09:56:03 <Lovepon> Hmmm
09:56:44 <maxcozzetti> Is that alright?
09:56:52 <monochrom> still the same nick
09:57:03 <quxbam> You applied id
09:57:49 <maxcozzetti> i see "maximo_cozzetti" instead of "maximoCozz". What do you see? 
09:57:51 <freeside> ego _ = id
09:57:53 <Lovepon> Wow.
09:57:57 <monochrom> maxcozzetti
09:57:58 <Lovepon> This bug went undetected. Lol.
09:58:28 <maxcozzetti> and is there a problem with "maxcozzetti"?
09:58:41 <monochrom> no
09:58:46 <quxbam> why should your name be a problem?
09:59:05 <geekosaur> I was wondering if nickserv told them the nick was registered, but ns info says not
09:59:35 <geekosaur> ("the "Ok, I'll change my nickname" looked like a response to something, btu said something wasn;t in channel...)
10:00:08 <maxcozzetti> I misread something then. I thought that "thisTypeofNames" caused a problem or weren't allowed
10:01:24 * Lovepon sighs
10:01:40 <maxcozzetti> I have a question about how to develop a very simple haskell app. I have too choose bewteen using a local database, or read-and-load/save a text file with a representation of a ADT
10:01:49 <maxcozzetti> (to choose) *
10:02:06 <Walther> > putStrLn $ "foo" ++ "bar"
10:02:07 <lambdabot>  <IO ()>
10:02:08 <Lovepon> How am I so stupid lol
10:02:16 <Walther> > putStrLn . "foo" ++ "bar"
10:02:17 <lambdabot>      Couldn't match expected type ‚Äò[Char]‚Äô
10:02:17 <lambdabot>                  with actual type ‚Äòa0 -> IO ()‚Äô
10:02:17 <lambdabot>      In the first argument of ‚Äò(++)‚Äô, namely ‚ÄòputStrLn . "foo"‚Äô
10:02:19 <quxbam> maxcozzetti: acid-state ?
10:02:35 <Walther> > putStrLn . (++) "foo" "bar"
10:02:37 <lambdabot>      Couldn't match expected type ‚Äòa -> String‚Äô
10:02:37 <lambdabot>                  with actual type ‚Äò[Char]‚Äô
10:02:37 <lambdabot>      Possible cause: ‚Äò(++)‚Äô is applied to too many arguments
10:02:56 <Walther> i use $ quite a lot, but i'm still not quite grasping when/how to use . 
10:02:58 <maxcozzetti> I don't know what acid-state is. What is that for?
10:03:20 <Lovepon> So.
10:03:29 <Lovepon> This one actually requires sqrt.
10:03:34 <monochrom> acid-state does the load/save for you.
10:03:45 <quxbam> maxcozzetti: It's a db in haskell, which can save arbitrary haskell types
10:04:03 <monochrom> It does more. But I am vague on what more.
10:04:29 <maxcozzetti> wow, that is great. Exactly what I wanted
10:04:31 <quxbam> it's atomic and offers remote server stuff
10:05:05 <quxbam> it's perhaps a bit complicated for a "simple" app
10:06:22 <maxcozzetti> I am looking for the most simple example
10:06:31 <Big_G> What is the canonical way to have a pure, non-monadic function that takes multiple arguments while some but not all of the input you have are monadic so liftM can't work
10:06:39 <geekosaur> the "acid" part refers to database transaction guarantees. atomicity, consistency, isolation, durability (basically, guaranteeing that any change you make "sticks" even when other threads/processes/machines are acting on the same state)
10:06:46 <Lovepon> I wonder why vim doesn't have recover and delete...
10:07:01 <geekosaur> ?
10:07:13 <Lovepon> That was so out of context. Lol.
10:07:19 <Lovepon> And out of topic too.
10:07:23 <apriori> can I hide instances on import?
10:07:29 <Lovepon> apriori: Yes.
10:07:34 <Lovepon> Oh wait
10:07:36 <Lovepon> Instances?
10:07:36 <geekosaur> nope, instances are always imported and always global
10:07:44 <apriori> hm, ok
10:07:52 <geekosaur> typechecking relies on this
10:07:59 <cocreature> Big_G: I would use do notation in that case, otherwise it gets unreadable if you have more than two or three arguments
10:08:06 <geekosaur> otherwise you can violate invariants of some types
10:08:08 <apriori> ok then. was just lazy on properly using overlapping/ovrlaps
10:08:27 <apriori> guess, I must not be lazy :)
10:08:30 <Lovepon> geekosaur: There are no things that only make sense in a module, and not on its exported interface?
10:08:39 <Big_G> cocreature, I'm mainly talking about just two or three? I've thought about just wrapping the non-monadic values in a return but that seems hackish
10:08:55 <Big_G> cocreature, Just three, not anymore
10:09:16 <geekosaur> Lovepon, there can be, but in those cases you're not exporting the types the instance applies to either so it's irrelevant
10:10:47 <quxbam> geekosaur: but with orphan instances...
10:11:23 <Lovepon> I can think of many ways to optimize this, but it'll be ugly. Lol.
10:11:43 <geekosaur> actually that "either" didn't belong there as it implied that you have control over export
10:12:04 <quxbam> apriori:  using haskell, it is quite normal to be lazy
10:12:21 <apriori> quxbam, hehe :D
10:12:21 <geekosaur> quxbam, the problem with orphans only comes up with types you can "reach". if a type is not exported in any way, you can't reach it and orphans can't exist
10:12:36 <cocreature> Big_G: I think I would still go with do notation or with pure, doing some flip tricks or throwing in lambdas really doesn‚Äôt help
10:13:19 <geekosaur> and if it is exprted then it's not "only make sense in a module and not on its exported interface"
10:13:20 <quxbam> geekosaur: but you can write instance declarations albeit the author would wish to use a class only intern
10:16:03 <maxcozzetti> What is more convenient: acid-state, Persistent, or some other tool that convert the info into Json format?
10:16:25 <Lovepon> Well...
10:16:41 <quxbam> I would say acid-state
10:16:41 <maxcozzetti> I would like the json option, since in the future I could  that same info in another app
10:16:55 <quxbam> json is independent
10:16:59 <Lovepon> How did this just happen lol
10:17:02 <Walther> > "foo" ++ "bar" >>= putStrLn
10:17:03 <quxbam> you can always use aeson
10:17:03 <lambdabot>      Couldn't match type ‚ÄòIO‚Äô with ‚Äò[]‚Äô
10:17:03 <lambdabot>      Expected type: Char -> [()]
10:17:03 <lambdabot>        Actual type: String -> IO ()
10:17:43 <geekosaur> depends on what you are doing with it
10:17:54 <lunrar> I wish haskell could fold my clothes 
10:18:06 <geekosaur> acid-state is exactly what you need for some things and pointless complexity for others
10:18:19 <Lovepon> My MRPT fails at 9..
10:18:40 <maxcozzetti> It's very likely that I would use this data in my computer, always locally
10:19:17 <Lovepon> Computing it by hand also agrees that it will fail.
10:20:04 <quxbam> maxcozzetti: acid-state is especially good if you want to save rich types or if you want to rely only on haskell and not on other software
10:20:50 <maxcozzetti> perfect. I'll take acid-state then. Can I save recursive data types too?
10:21:36 <quxbam> I think yes
10:22:12 <maxcozzetti> Ok. Thank you very much!
10:22:35 <Lovepon> @src notElem
10:22:35 <lambdabot> notElem x = all (/= x)
10:22:40 <Lovepon> @src elem
10:22:40 <lambdabot> elem x = any (== x)
10:22:49 <quxbam> but you know that acid-state is all in memory, so don't use it on huge data
10:23:35 <maxcozzetti> Ok, good to know. I'll keep that in mind
10:25:41 <apriori> does anyone maybe have an idea how I would solve such an overlapping instance issue (on use site?): https://gist.github.com/apriori/50f78152b89c3c2d50d11e098c354995
10:28:57 <hpc> acid-state can save list values, which are a recursive data type, so that's absolutely yes
10:30:03 <geekosaur> I would wonder if they mean recursive, or self-referencing?
10:31:18 <cocreature> apriori: does adding an OVERLAPPING pragma to that instance help?
10:31:24 <cocreature> seems like it should
10:34:20 <apriori> cocreature, overlaps did
10:34:48 <cocreature> apriori: that‚Äôs the same
10:34:58 <cocreature> well it‚Äôs more general
10:35:04 <cocreature> but OVERLAPPING should work here to
10:35:17 <apriori> but it didnt :(
10:35:24 <cocreature> hm does overlappable work?
10:35:47 <apriori> cocreature, yes
10:35:53 <cocreature> ah I misread the docs
10:36:00 <cocreature> I can never remember which one does what
10:36:14 <apriori> now I got a similar issue somewhere else. this time both instances are in library, code, though :(
10:36:20 <apriori> me neither :(
10:44:33 <Lovepon> I have no idea what the hell I'm doing wrong.
10:57:03 <Lovepon> Everything's messed up. :D
10:59:18 <Lovepon> I wonder what the hell is wrong.
10:59:55 <Lovepon> Oh. I see what's wrong.
11:04:16 <Walther> > putStrLn $ "foo" ++ "bar"
11:04:17 <lambdabot>  <IO ()>
11:04:27 <Walther> > "foo" ++ "bar" >>= putStrLn
11:04:29 <lambdabot>      Couldn't match type ‚ÄòIO‚Äô with ‚Äò[]‚Äô
11:04:29 <lambdabot>      Expected type: Char -> [()]
11:04:29 <lambdabot>        Actual type: String -> IO ()
11:05:19 <Walther> ^Anyone care to explain how to achieve something like a left-to-right unix pipe behavior (in contrast to $ which is almost like a unix pipe in reverse reading order)
11:06:10 <int-e> Walther: "..." ++ "..." is a string; return ("..." ++ "...") >>= putStrLn   would work.
11:06:18 <int-e> :t return "abc" :: IO String
11:06:20 <lambdabot> IO String
11:06:22 <int-e> :t return "abc"
11:06:24 <lambdabot> Monad m => m [Char]
11:06:27 <cocreature> :t (&)
11:06:28 <lambdabot> a -> (a -> b) -> b
11:06:35 <cocreature> Walther: that might be what you‚Äôre looking for
11:06:38 <int-e> oh.
11:07:10 <cocreature> > "foo" & length & (+1)
11:07:12 <lambdabot>  4
11:07:34 <Walther> neat!
11:07:42 <Walther> > "foo" ++ "bar" & putStrLn
11:07:43 <cocreature> it‚Äôs in data.function iirc
11:07:44 <lambdabot>  <IO ()>
11:17:28 <ralu> is there any stream library that works over applicative, but don't requre monad under?
11:20:52 <geekosaur> is that even meaningful?
11:21:01 <geekosaur> (they're I/O streams after all)
11:22:24 <ralu> I dont have IO stream
11:23:08 <simpson> ralu: What are you building?
11:25:15 <geekosaur> if you mean stream fusion, while there have been libraries for them, they were testing grounds for changes ultimately made to ghc; this kind of stream (stream fusion) isn't so much a library thing as a code generation thing, with the libraries using RULES to substitute manually stream-fused implementations
11:25:48 <ralu> bidirectioal push-pull pipes for use over Signal . That is unidirectional stream that is applicative, but not monad. It is like ZipList iguess
11:31:45 <benzrf> http://i3.kym-cdn.com/photos/images/original/001/053/542/9bc.png
11:31:49 <benzrf> crap wrong channel
11:36:43 <Lovepon> Hmmm
11:36:48 <Lovepon> I think I got it.
11:37:06 <Lovepon> Miller-Rabin's primality test.
11:37:18 <ralu> that is nice
11:37:22 <xa0> benzrf: lmao
11:38:00 <Lovepon> So
11:38:19 <Lovepon> Miller-Rabin's primality test only checks for Fermat pseudoprimes?
11:38:41 <Lovepon> Because if I use base 2, and 9 as input, it says it's prime.
11:39:14 <Lovepon> Doing it on paper agrees with me too.
11:40:21 <Cale> Lovepon: You must choose p > 2
11:40:34 <Lovepon> Cale: Right.
11:40:40 <Lovepon> Cale: In this case, b = 2, p = 9.
11:40:47 <Cale> 9 isn't prime
11:40:51 <Lovepon> Cale: Exactly.
11:41:13 <Cale> Er, I'm talking about the finite field you're working over
11:41:19 <Cale> Z/2Z doesn't work, iirc
11:42:01 <Lovepon> Cale: Isn't it Z/pZ? in this case, 9?
11:42:11 <simpson> Yeah, 2 doesn't work: https://en.wikipedia.org/wiki/Miller‚ÄìRabin_primality_test
11:42:59 <maerwald> hmm, is there something like show/read, except using ByteString?
11:43:12 <Lovepon> simpson: Right, but I'm working on Z/pZ here, am I not? In this case, 9.
11:44:43 <simpson> Lovepon: Huh. Maybe 2 is a strong liar for 9? I haven't looked at this algorithm in a while.
11:45:15 <Lovepon> simpson: According to wikipedia, the smallest number that 2 is a strong liar of is 2047.
11:46:17 <Lovepon> simpson: My hunch is that this si for strong primality checking.
11:46:20 <Lovepon> is*
11:46:24 <Lovepon> Err
11:47:14 <ralu> Lovepon: I guess there is bug in implementaion
11:47:46 <Lovepon> ralu: I'll double that, but I've reimplemented this thrice already, all different methods.
11:47:53 <Lovepon> s/double/second/
11:48:57 <Lovepon> Okay. This might be the stupidest question I'm asking.
11:49:01 <Vtec234> Hello, so I'm coming from the world of C++ into that of Haskell, and have a question regarding memory and cache. Expressions in Haskell are inherently immutable, but does that mean they actually immutable in-memory, that is the compiled code will copy e.g. a list if it gets modified and the returned expression will be a newly allocated piece of memory or can it optimize and see that the input is no longer needed, hence modifying 
11:49:01 <Vtec234> memory in-place?
11:49:10 <Lovepon> Is it erquired to check
11:49:12 <Lovepon> a^{n-1} \equiv 1\pmod{n}.
11:49:14 <Lovepon> ?
11:49:38 <Lovepon> Err
11:49:38 <monochrom> yes
11:49:49 <Lovepon> monochrom: Is that a yes to me or to Vtec234?
11:50:02 <monochrom> you. fermat's little theorem
11:50:10 <Lovepon> monochrom: Right.
11:50:21 <Lovepon> monochrom: So, I need to check *3* equalities then?
11:50:53 <david__M> Hey, I'm getting a really weird error when I try to compile some code, it says VineWhip (Bulbasaur a) doesn't match b when b is defined as Move b => b. Info on the type class Move shows that the instance Move (VineWhip a) exists. I'm not sure what I'm doing wrong. Thanks for any help
11:50:54 <monochrom> I haven't been following. I don't know what other two you already checked. But a^{n-1} \equiv 1\pmod{n} is a must.
11:50:55 <Cale> Lovepon: Okay with n = 9, we have n-1 = 2^3 * 1, so s = 3, d = 1. If we pick a = 3, then we have a^d = 3^1 = 3 which is not 1 modulo 9, and we check a^(2^r*d) for 0 <= r <= s-1, so 3^(2^0) = 3, 3^(2^1) = 0, and 3^(2^2) = 0 are all not equal to -1 modulo 9. So 9 isn't prime.
11:51:34 <monochrom> Because IIRC the rest of the Rabin-Miller congruences to check, even if they pass, do not imply the Fermat check will pass.
11:51:46 <Lovepon> Cale: I need it to be a = 2 though,since I want to follow Baillie‚ÄìPSW.
11:52:00 <Cale> Well, fair enough, let's check a = 2
11:52:07 <simpson> Vtec234: It depends on the compiler, but generally things like lists are not structured as the vectors that you know from C++; instead, they're actually stored as linked lists in memory.
11:52:28 <monochrom> anyway, yeah, Cale's explains why 9 is a prime :)
11:52:34 <Vtec234> wait, are you serious? linked lists are the slowest structure ever
11:52:42 <Lovepon> monochrom: Not for a=2.
11:52:42 <Cale> er, oops
11:53:02 <Lovepon> Vtec234: Horrible misconception is horrible.
11:53:07 <Vtec234> then, are there vectors with constant lookup time in Haskell?
11:53:23 <simpson> Vtec234: Yeah, there's a few specialized array libraries.
11:53:36 <Cale> Lovepon: Usually a is selected randomly
11:53:40 <Lovepon> Vtec234: IIRC, for purely pure, there can't be constant everythings.
11:53:40 <Vtec234> Lovepon: list lookup is always chasing something, pointers or else if the compiler does its own referencing
11:53:48 <david__M> @Vtec234 yup, Data.Vector is a good one
11:53:49 <lambdabot> Unknown command, try @list
11:54:03 <Lovepon> david__M: Isn't Vector O(log n)?
11:54:06 <simpson> Vtec234: You'd be surprised how rare things like (!!), the indexing function, really are.
11:54:17 <Lovepon> simpson: ++
11:54:26 <simpson> Lovepon: Good point.
11:54:39 <simpson> Data.Seq is a thing, if that's your problem.
11:54:51 <Lovepon> There are also random access lists.
11:55:06 <Lovepon> I love random access lists. 'w'
11:55:13 <Lovepon> They're liek lists... but better.
11:55:25 <david__M> @lovepon yea my bad but if memory serves me right log has a very large base, so it's not a very big problem. Clojure does their vector implementation in such a way that it has a lookup complexity of log32(x)
11:55:25 <lambdabot> Unknown command, try @list
11:56:03 <Lovepon> david__M: Not trying to sound rude or anything, but your tab completion's not working well in this channel. <.<
11:56:09 <Cale> Vtec234: Well, technically speaking, there can't be an array datastructure with n arbitrary elements in which lookup is any faster than O(log n) -- any faster and you don't have time enough to read the entire index.
11:56:19 <monochrom> I think the @ was entered manually.
11:56:41 <david__M> monochrom yea force of habit from my usual IRC client
11:57:04 <Vtec234> Cale: if the element size is known, it's just a memory offset provided that it's contiguously stored, so O(1)
11:57:18 <Cale> Vtec234: Yeah, well, even pointer indirection is really O(log n)
11:57:19 <david__M> can anyone help me with my problem, it's been slowly driving me mad all day?
11:57:52 <Cale> (well, really it's more like O(sqrt n), but we can lie to ourselves about physical constraints)
11:58:26 <simpson> Cale: Where n is the number of different memory arenas to search?
11:58:36 <Vtec234> Cale: are you talking about hardware-level memory lookup? begin_address + size * n isn't O(log n) :P
11:58:49 <geekosaur> in any case, the reason we use linked lists a lot is that they're the natural representation of a loop in functional programming. and purity lets the compiler often optimize the list away, producing a tight loop with no list or pointers in sight
11:58:57 <Cale> simpson: Yeah, if you're storing n elements
11:59:41 <monochrom> linked list is a fast control structure.
11:59:42 <geekosaur> (because with purity the compiler can know with certainty that nothing is holding onto a pointer from the list, so no pointer needs to exist)
12:00:24 <Cale> Vtec234: Yeah, I'm accounting for the hardware implementation there -- you can't examine all the bits of an address in less than O(log n) time. To put it another way, any function whose range has n elements must take at least O(log n) time, so as to be able to examine enough bits of its input to distinguish between n possibilities.
12:00:27 <geekosaur> (or else it knows exactly *what* is holdoing into it, and can make arrangements to deal with it)
12:00:32 <simpson> Vtec234: At any rate, rest assured that the `array` package exists and is quite standard: http://hackage.haskell.org/package/array
12:00:32 <Lovepon> Should I be killed if I do bit twiddling hacks in Haskell?
12:00:56 <Cale> (But yeah, there's Array and Vector)
12:01:02 <Lovepon> Or is bit twiddling slow for Integer?
12:01:04 <monochrom> no, but you should use Data.Bits for that.
12:01:10 <Lovepon> monochrom: Of course.
12:01:16 <monochrom> I think it's a good idea.
12:01:27 <simpson> Cale, Vtec234: Oh! This is a practical application of the joke-theorem that Data.IntSet has O(1) access because it has O(lg n) access and n has an upper bound.
12:01:43 <monochrom> but I haven't measured how fast these bit-ops are on Integer.
12:02:14 <Cale> simpson: yeah, that's exactly the thing people are doing when they say memory access is O(1)
12:02:36 <Cale> They're assuming they have some fixed amount of memory -- which throws asymptotic analysis out the window
12:03:05 <Lovepon> monochrom: Hmmm
12:03:21 <Lovepon> monochrom: bitSize is Nothing for Integers.
12:03:52 <Lovepon> I wonder why.
12:03:58 <monochrom> yeah, bitSize refers to word size of the type.
12:03:59 <Cale> Lovepon: Because they're arbitrarily large
12:04:05 <Lovepon> Cale: Right.
12:04:08 <Vtec234> i see, i don't know crap about functional, so you're most likely right linked lists are the best here. anyway, my idea for a learning-haskell project is to implement a subsystem for a c++ thing I have. the subsystem accepts a _large_ data structure and modifies it in place + outputs indices of elements it modified. of course immutability, but what i'll do is simply output the change list, without modifying the data. and now my 
12:04:08 <Vtec234> question is, is it possible to define a haskell function that has a C ABI and can accept a C structure?
12:04:19 <Lovepon> Cale: But why not return the bit size that's used by the stored number?
12:04:33 <Cale> Vtec234: Oh, I'm not arguing that linked lists are better :)
12:04:36 <simpson> Vtec234: Yes, GHC can produce shared objects with C linkage.
12:05:07 <Cale> Vtec234: You'll want to use Data.Array.Storable or Data.Vector.Storable
12:05:46 <Cale> Vtec234: It uses the Storable instances from the FFI library to store the array elements, which puts things in the format that C will expect.
12:05:52 <Vtec234> ideally, i'd want to convert the C++ vectors contained in the structure to Haskell [SomeKindOfVectorType], is that possible?
12:06:07 <hackrilege> hmmm certainly my ghci wants me to write an Alternative instance, it says it is a superclass of MonadPlus http://lpaste.net/161329
12:06:36 <monochrom> Lovepon: people have debated this before. The correct conclusion is that we need two methods, one for maximum bit length possible, the other for how many bits in an actual value. But the latter has not been implemented.
12:06:49 <ertes> Vtec234: not easily‚Ä¶  you'll likely go through a serialisation/deserialisation cycle
12:06:54 <Lovepon> monochrom: But it has been considered, right?
12:06:56 <Vtec234> not necessarily directly, just that I have an int* and a size_t and want to obtain a Data.Vector.Storable
12:06:58 <Cale> Uhh, I have no recollection of how a C++ vector is laid out in memory, as it's been well over a decade since I last wrote any C++, but theoretically perhaps you can parse it.
12:06:59 <Lovepon> monochrom: If so, that's good enough for me.
12:07:24 <Vtec234> Cale: it's just a flat memory blob containing n * type_size bytes
12:07:39 <Cale> ah, in that case, it's easy
12:07:50 <monochrom> I hesitate to say it's good enough, since the discussion happened several years ago, and nothing has still happened.
12:07:51 <geekosaur> re linked lists, the point is more that it's easy and "onbvious" to write such code --- and with a language like Haskell, the compiler has enough information to turn it into something sane. (not that it always does, but it's fairly good at it at this point)
12:08:16 <geekosaur> I should say "natural" instead of "obvious"
12:08:19 <Cale> Vtec234: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-340005.9
12:08:23 <geekosaur> make the compiler do the work
12:08:26 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-320005.7
12:09:12 <Cale> Well, we use lists more as a control structure mechanism than as containers.
12:09:13 <ertes> Vtec234: in general haskell and C++ prefer to talk to each other through files, pipes, sockets and perhaps shared memory‚Ä¶  though i've never done it myself, you can send file descriptors through a unix socket (and fall back to actual data transfers on systems that don't support them)
12:09:43 <Vtec234> ertes: shared memory in haskell? :<
12:09:46 <Cale> If a C++ library is usable from C, then it'll be usable from Haskell via FFI.
12:09:51 <ertes> Vtec234: so shm and mmap could work on unix-likes
12:09:52 <geekosaur> right, that's like thr first thing I said about it (that a linked list is the natural representation of a loop)
12:09:54 <ertes> Vtec234: sure
12:09:58 <Athas> geekosaur: do you have an example of where the compiler does something clever with lists?
12:10:13 <geekosaur> Athas, it's called "list fusion"
12:10:30 <Cale> Athas: There's a bunch of list fusion stuff. If you write map f . map g, the compiler will rewrite it into map (f . g)
12:10:33 <geekosaur> that term should give you plenty of references. it's hard to demonstrate in a few lines on IRC though
12:10:38 <Athas> That doesn't really solve the representation problem, though.
12:10:48 <Vtec234> well, i don't really want the haskell code to do any memory reading, ideally it'd just be a function that is called from C++, so as to not have any of those nasty monadic side effects
12:11:00 <Cale> Athas: it's able to eliminate a lot of the intermediate lists which would otherwise be constructed
12:11:04 <ertes> Vtec234: if you really want to *link* haskell and C++, the FFI is your friend, but be prepared to go through a lot of learning of low-level knowledge you probably don't want to care about as a beginner
12:11:49 <Vtec234> alright, thanks for all the tips, i'll check out the FFI libs and maybe write something easier before :P
12:11:56 <simpson> Vtec234: Hopefully you'll be working in the IO monad, precisely for the side effects!
12:12:13 <ertes> Vtec234: the FFI is not a library, but a language feature‚Ä¶  you need it to link to foreign code
12:12:38 <Vtec234> there are libs pertaining to FFI though, like the C memory marshalling features
12:12:47 <Vtec234> i know what FFI is btw :P
12:12:49 <Athas> Cale: that's not quite as important in a lazy language as in a strict one, though.
12:13:08 <ertes> Vtec234: haskell calling C functions is usually somewhat painless, but C calling haskell can be a major headache (because of haskell's concurrent runtime design and GC)‚Ä¶  C++ adds another layer of complexity to the mix
12:13:22 <Cale> Athas: true -- but taking pressure off the GC can do nice things for performance
12:13:37 <Athas> I was thinking more that GHC might end up doing something like this: http://www.cs.cmu.edu/~rwh/papers/iolambda-cacm/cacm.pdf (Cache-efficient list representations.)
12:13:47 <maerwald> ertes: what? how can you even read files without calling C functions O.o
12:13:48 <Vtec234> oh, so that's the problem. yeah, i guess I could have haskell call a int* read_memory_blob_thing in my main app
12:14:25 <ertes> maerwald: "C calling haskell" = "calling haskell from C"
12:14:31 <ertes> i.e. callbacks into haskell
12:14:35 <simpson> Vtec234: https://wiki.haskell.org/Calling_Haskell_from_C
12:14:59 <ertes> maerwald: or even main program in C/C++, subsystems in haskell (which is what i understand Vtec234 wants)
12:15:23 <Zemyla> Athas: I did an example by hand of list fusion, using the rules in GHC.List, and found that foldl' (+) 0 $ take 10000000 $ repeat 5 turned into:
12:15:23 <monochrom> Ah, the irony. A lazy language incurs the overhead of allowing "Just bottom" without aborting the program. An eager language incurs the overhead of evaluating your whole list just to make sure it's finite. The only way to win is not to play.
12:16:37 <Lovepon> ...
12:16:38 <ertes> haskell sure doesn't like to be submissive =)
12:16:41 <Vtec234> "now compile your C code with GHC".. what
12:16:44 <Lovepon> Wow, I think I *am* having a stroke.
12:16:56 <Zemyla> let xs !m !z = case m of { 1 -> z + 5; _ -> xs (m - 1) (z + 5) } in xs 10000000 0.
12:17:17 <Lovepon> How did I make such a mistake
12:17:19 <geekosaur> Vtec234, ghc will see you gave it a *.c and invoke the C compiler with the appropriate options for C code to interface with Haskell
12:17:28 <ertes> Vtec234: 99.999% of FFI usage is about a main program in haskell calling out to foreign code, in which case GHC calls out to GCC for you
12:17:45 <geekosaur> rather than making you figure thoise options out (including appropriate header files etc.) yourself
12:17:53 <benzrf> ertes: "a main program"?
12:17:58 <simpson> Vtec234: There's ways to produce shared objects with Haskell, too, but those are trickier.
12:18:42 <ertes> benzrf: "the program"
12:18:56 <benzrf> ertes: er... what else would ffi mean?
12:19:08 <benzrf> oh... other languages calling into haskell?
12:19:15 <ertes> benzrf: yeah
12:20:42 <Lovepon> Well.
12:21:04 <Athas> I'd really think twice before doing that.
12:21:12 <monochrom> Lovepon: what mistake did you make?
12:21:14 <Athas> It is easy to call out from Haskell.  The other direction is not so easy.
12:21:37 <Lovepon> monochrom: I multiplied it by base instead of squaring.
12:21:54 <monochrom> oh heh
12:22:55 <Lovepon> Hmmm
12:23:06 <Lovepon> I wonder what's leaking.
12:23:25 <ertes> :t fix . (>=>)
12:23:26 <lambdabot> Monad m => (b -> m b) -> b -> m c
12:25:37 <Lovepon> Reimplementing the fourth time now.. lol.
12:25:55 <ertes> :t \f -> fix (\again -> f >=> either pure again)
12:25:56 <lambdabot> Monad m => (b -> m (Either c b)) -> b -> m c
12:26:23 <monochrom> @type again
12:26:25 <lambdabot> Not in scope: ‚Äòagain‚Äô
12:26:32 <monochrom> oh, nevermind
12:27:00 <Lovepon> monochrom: LOL
12:27:04 <Lovepon> Sorry, caps.
12:27:08 <ertes> might be a C-haskell trampoline, if you really need most of your program in C/C++
12:27:38 <Lovepon> I guess I'll do bit twiddling hacks for this one.
12:27:59 <ertes> main = fix (\again -> cppPart >=> either pure again) startState
12:28:38 <ertes> probably better than calling haskell from C
12:28:39 <Lovepon> Guys, guess what this does.
12:28:53 <monochrom> it computes fibonacci
12:29:02 <Lovepon> popcount $ (x&(-x)) - 1
12:29:17 <monochrom> I think I know that one
12:29:22 <ralu> me2
12:29:38 <ertes> Lovepon: not in scope: (&)
12:29:47 <ertes> (.&.)?
12:29:55 <Lovepon> Yeah
12:30:01 <Lovepon> That was transliterated from C.
12:30:59 <ARM9> how would you add release/debug build settings to a project with cabal? say using cabal build --debug sets ghc flags to -O and cabal build -O2
12:31:37 <ertes> ARM9: you can do that with flags
12:31:46 <ertes> cabal configure -fdevelopment
12:31:53 <Lovepon> monochrom: Wanna know? :3
12:32:13 <monochrom> yes
12:32:19 <Lovepon> monochrom: trailingZeroes.
12:32:22 <ertes> ARM9: see the example here: https://www.haskell.org/cabal/users-guide/developing-packages.html#configurations
12:32:33 <Lovepon> monochrom: x .&. (-x) gets the least significant one bit.
12:32:33 <ARM9> ah nice ertes
12:32:34 <monochrom> ha nice
12:33:08 <Lovepon> monochrom:  -1 converts the least significant one bit to..
12:33:13 <Lovepon> Actually
12:33:57 <portnov> hi all
12:34:00 <Lovepon> monochrom: oh, right, -1 toggles bits 0 to the least significant one bits.
12:34:04 <clojure_is_best_> is there a way to use this sort of syntax, but to pattern match?  let (Just (Object response)) = lookup "response" vals
12:34:09 <portnov> Q: how to get "short" GHC version
12:34:10 <portnov> ?
12:34:11 <clojure_is_best_> hi portnov
12:34:20 <clojure_is_best_> portnov what do you mean by short?
12:34:27 <portnov> smth like "ghc --version", but I want only "7.10.3" string
12:34:32 <Lovepon> monochrom: Basically, `popcount $ x - 1` is a way to do log for powers of 2.
12:34:34 <portnov> not that thing about gloriousness
12:34:36 <ertes> clojure_is_best_: looks like a valid pattern to me
12:34:37 <lyxia> portnov: --numeric-version
12:34:38 <Vtec234> ertes: i have no idea what you typed there, but it's probably useful so i'll write it down for later :)
12:34:49 <ertes> Vtec234: don't =)
12:34:52 <portnov> lyxia: thanks!
12:35:04 <clojure_is_best_> ertes yeah, but it's effectively a partial function
12:35:13 <Lovepon> monochrom: So, what do you think? :D
12:35:18 <simpson> clojure_is_best_: So, it depends on whether or not you're in a do-block.
12:35:20 <monochrom> neat
12:35:40 <clojure_is_best_> simpson suppose i am
12:35:42 <ertes> clojure_is_best_: it *is* a partial function, but that's not really related‚Ä¶  the result of the pattern match would be a function then
12:35:43 <simpson> > do { let (Just x) = Nothing; return 42 } :: Maybe Int
12:35:45 <lambdabot>  <hint>:1:40: parse error on input ‚Äò}‚Äô
12:35:46 <lyxia> clojure_is_best_: pattern matching is normally done with case
12:36:17 <clojure_is_best_> lyxia is there a way to use case with let?
12:36:20 <simpson> > do { let (Just x) = Nothing; Just 42 }
12:36:21 <lambdabot>  <hint>:1:38: parse error on input ‚Äò}‚Äô
12:36:23 <Lovepon> monochrom: I wonder how popcount works for unsigned ints...
12:36:23 <monochrom> oh! # of trailing zeros is important for number theory algorithms, isn't it?
12:36:27 <Lovepon> monochrom: signed ints*
12:36:34 <simpson> Okay, I've forgotten Haskell syntax. Never mind.
12:36:54 <Lovepon> monochrom: I'm not exactly sure, but arithmoi has a dedicated function to convert evens to odds.
12:37:02 <Lovepon> monochrom: This is my approach to doing that.
12:37:19 <ertes> clojure_is_best_: you can give it a name
12:37:36 <Lovepon> monochrom: I hope popcount's implementation is sane fast.
12:37:38 <lyxia> clojure_is_best_: what do you mean?
12:37:40 <clojure_is_best_> ertes what do you mean?
12:38:05 <ertes> let x = case lookup "response" vals of Just (Object response) -> response; _ -> somethingElse
12:38:15 <ertes> clojure_is_best_: is that what you mean?
12:38:28 <clojure_is_best_> lyxia well i can do this shorthand for defining a function let (Just x) = y
12:38:54 <clojure_is_best_> lyxia i haven't broken out a function, the partial function is just implicit in the let... ooh wait i guess
12:39:06 <clojure_is_best_> well yeah it's implicit in the let
12:39:14 <maerwald> wonder why the show/read classes don't have a bytestring variant :(
12:39:35 <Welkin> maerwald: not all codepoints are showable
12:39:40 <clojure_is_best_> lyxia now x is in scope for the rest of the monad
12:39:42 <Welkin> like beeps
12:39:45 <maerwald> Welkin: wat?
12:39:47 <Welkin> and whitespace
12:39:54 <ertes> clojure_is_best_: with the definition above you're effectively defining something called 'response' that might crash at run-time (because it turned out not to be Just (Object _))
12:40:12 <maerwald> I cannot follow
12:40:12 <clojure_is_best_> ertes yes indeed
12:40:19 <Welkin> maerwald: bytestring is just bits
12:40:23 <maerwald> yes
12:40:28 <Lovepon> I have to ask.
12:40:30 <Welkin> maerwald: not all of them correspond to a character that can be shown on screen
12:40:34 <maerwald> I know
12:40:34 <Lovepon> Is there an unsigned integer in haskell?
12:40:38 <maerwald> where's the problem?
12:40:40 <hsk3> Is there a reverse of >> in monads  just like <* is a reverse of *> in applicative?
12:40:41 <Welkin> Lovepon: Word
12:40:42 <ARM9> Lovepon, Data.Word
12:40:44 <clojure_is_best_> ertes i'm asking can i use that syntax to effectively define implicit total functions?
12:40:56 <maerwald> Welkin: you get back ByteString, not String
12:40:56 <Welkin> hsk3: no
12:41:06 <Lovepon> Welkin: ARM9: I mean arbitrary precision.
12:41:07 <ertes> clojure_is_best_: an example might help
12:41:12 <maerwald> if you want to show it on screen, you are going to do encoding stuff anyway
12:41:18 <Lovepon> Oh, Natural.
12:41:25 <monochrom> Lovepon: If you're at GHC 7.10, there is Natural
12:41:26 <simpson> maerwald: Oh! Well, the main reason is that Show and Read are not intended for much beyond debugging purposes.
12:41:35 <clojure_is_best_> ertes this is the example, say i'm in a monadic block. I can do let (Just x) = y
12:41:40 <Lovepon> monochrom: Is Natural slower or faster than Integer?
12:41:51 <monochrom> I don't know. I bet same.
12:41:51 <maerwald> simpson: but the read instance already has a lot of parsing logic I wanted to reuse
12:41:54 <Cale> clojure_is_best_: Are you looking for case expressions?
12:41:58 <maerwald> e.g. for escaped characters etc
12:41:59 <Lovepon> monochrom: I'm guessing slower, since there's no sane way to check for underflows.
12:42:01 <clojure_is_best_> that may result in a runtime exception, or it unrolls x if it does not
12:42:03 <Cale> case y of Just x -> ...; Nothing -> ...
12:42:04 <lyxia> clojure_is_best_: http://lpaste.net/161332
12:42:10 <Lovepon> monochrom: Err
12:42:10 <sphinxo> Any advice/guides for migrating from string to text?
12:42:14 <maerwald> now I have to reinvent the wheel
12:42:14 <simpson> clojure_is_best_: Actually, it depends on the Monad that you're in!
12:42:19 <Welkin> clojure_is_best_: god your name is distracting
12:42:24 <Lovepon> monochrom: There's no sane way to handle underflows, except for checking it and throwing an exception*
12:42:24 <monochrom> To be honest, I am just betting.
12:42:25 <ertes> clojure_is_best_: to handle all cases you can use a 'case' within your do-block
12:42:31 <Welkin> it's an entire phrase
12:42:36 <simpson> clojure_is_best_: When that pattern fails in a do-block, it will actually call fail.
12:42:37 <simpson> :t fail
12:42:38 <lambdabot> Monad m => String -> m a
12:42:45 <monochrom> You should take measurements.
12:42:45 <ertes> clojure_is_best_: or you can give the result a name:  let x = case y of Just x' -> x; Nothing -> someDefault
12:42:49 <Lovepon> monochrom: I think I need sleep lol, I'm barely forming coherent sentences.
12:43:01 <monochrom> Sleep is always a good idea.
12:43:13 <Welkin> jinmugenfu: champloo
12:43:28 <ertes> clojure_is_best_: with the syntax you used you did a combined match-and-define, using the pattern variable as the actual name of what you defined
12:43:29 <xa0> Not another one fallen prey to from just...
12:43:30 <simpson> And different instances do different things. IO's fail throws an exception in IO. Maybe returns Nothing. List returns an empty list, IIRC.
12:43:30 <jinmugenfu> @Welkin yes
12:43:30 <lambdabot> Unknown command, try @list
12:43:45 <hsk3> Welkin: lol nice terse answer
12:43:45 <clojure_is_best_> ertes i think you mean Just x' -> x' ?
12:43:53 <ertes> clojure_is_best_: sorry, yeah
12:43:54 <hsk3> Welkin: any ideas why?
12:44:49 <Welkin> hsk3: I remember talking about this a while back
12:45:11 <Cale> clojure_is_best_: There's also the maybe function:  maybe n j Nothing = n; maybe n j (Just x) = j x
12:45:11 <Welkin> hsk3: you can make your own <<, but the order of evaluation is not the same as <*
12:45:27 <Cale> clojure_is_best_: But usually I find just pattern matching is fine
12:45:38 <hsk3> Welkin: because monads and applicatives are fundamentally different beasts right?
12:46:33 <Gurkenglas> > map (*2) $ replicate 100 (500000 :: Natural)
12:46:37 <lambdabot>  mueval-core: Time limit exceeded
12:46:40 <Gurkenglas> > map (*2) $ replicate 100 (500000 :: Integer)
12:46:42 <lambdabot>  [1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,1000000,100...
12:46:53 <Lovepon> Gurkenglas: LOL. Nice.
12:47:14 <Lovepon> Gurkenglas: Thanks.
12:47:29 <clojure_is_best_> Cale maybe is handy i haven't used that. i guess either is used in the same way right
12:47:37 <Cale> yeah
12:47:45 <Cale> and foldr actually fits into the same family in a way
12:48:15 <Lovepon> I wonder to what extent should I use bit twiddling hacks.
12:48:19 <clojure_is_best_> ertes so is combined match-and-define always an antipattern? or is there a way to use it that defines total functions? this was my question..
12:48:25 <Cale> (foldr f z xs replaces every occurrence of (:) in xs with f, and the [] at the end, if any, with z)
12:48:46 <Lovepon> (Bits a) => a -> [a] when!?
12:48:59 <Cale> clojure_is_best_: What are you trying to write?
12:49:00 <Lovepon> Or [Bool]?
12:49:11 <ertes> clojure_is_best_: it can be useful, if you have a mathematical invariant that is difficult to communicate in types
12:49:21 <Welkin> Lovepon: lol, I only used bits when I was doing encryption/decryption exercises
12:49:23 <Welkin> it was fun
12:49:38 <Cale> Oh, yeah, you might know for sure that the thing is Just x, in which case, using let like that is fine.
12:50:01 <Cale> But if there's any chance of the match failing, then it's usually a bad idea.
12:50:20 <ertes> clojure_is_best_: let Just xi = 7 `inverseMod` 100  -- you know that the inverse exists, but inverseMod :: Integer -> Integer -> Maybe Integer
12:51:05 <clojure_is_best_> Cale basically within a monad i want to bind the contents of a maybe or either and use it in a computation
12:51:13 <Lovepon> Guys, what do you think of the reader monad? Use or nope?
12:51:25 <ertes> clojure_is_best_: can the pattern-match fail?
12:51:44 <ertes> Lovepon: i tend not to use it
12:51:50 <Cale> Lovepon: Usually nope, except as part of a larger plan in which it won't be obvious that I'm using it.
12:51:51 <Welkin> Lovepon: for configuration information, yes
12:52:06 <Lovepon> ertes: Cale: I see, thanks!
12:52:07 <Cale> Just passing function parameters is really not so bad
12:52:13 <clojure_is_best_> ertes yeah. what i was asking was that is there a way to do combined match-and-define but pattern match alternative outcomes. it sounds like the solution is just to use case on the rhs or either/maybe for special cases
12:52:18 <o`connor> how do I make a regex tdfa in ghci?
12:52:49 <ertes> Lovepon: sometimes i use ReaderT as an underlying monad to another abstraction that doesn't allow me to communicate via arguments
12:52:55 <ertes> Lovepon: other than that i prefer to avoid it
12:52:58 <JonReed> Hi, is there some neat way to flip argument from first place in the function to the last place? E.g., `flip map [1..10] (+ 5)`, but more general which would work for more arguments (e.g. foldr)? The reason is because I often like to put lambda in the last place like `someFunc arg1 arg2 $ \i -> do`
12:53:25 <Lovepon> ertes: Cale: How about for recursive helper functions?
12:53:30 <Cale> JonReed: Just use lambda for that
12:53:40 <Lovepon> You know, those kinds of things where you do `f = f' 0`
12:53:46 <Cale> JonReed: There are points-free ways to write those flips, but they get stupidly unreadable quickly
12:53:52 <ertes> clojure_is_best_: is the purpose of that that your code layout doesn't run to the right more and more?
12:53:58 <Cale> @pl (\f x y z -> f z y x)
12:53:58 <lambdabot> flip . (flip .) . flip
12:54:16 <Lovepon> JonReed: Errr
12:54:17 <Cale> @pl (\f x y z w -> f w x y z)
12:54:17 <lambdabot> (((flip .) . flip) .) . flip
12:54:22 <ertes> Lovepon: let helper x = go; where go y = ... go ...
12:54:27 <JonReed> Yeah that sucks, but flipA2 probably will be readable? No?
12:54:37 <JonReed> Specialized versions of flips
12:54:42 <Lovepon> JonReed: Oh.
12:54:54 <Cale> JonReed: I honestly think that flip on its own is already not very readable, and usually prefer just writing the lambda
12:55:32 <Welkin> unless you are a perl programmer and like to write code that no one can read
12:55:42 <JonReed> Cale: But then arguments are going to be pushed after a lambda and if it's big it's as readable as if arguments are in front
12:55:44 <clojure_is_best_> ertes sort of, also the repl interaction is to deal with using one-liner evaluations  than multi-line evaluations. bad reason i know
12:55:58 <ertes> clojure_is_best_: Maybe is a monad
12:56:09 <ertes> > do x <- Just 3; y <- Just 4; pure (x + y)
12:56:10 <lambdabot>  Just 7
12:56:34 <Cale> JonReed: Sometimes it's worth defining a specially-flipped version of someFunc with its own name
12:56:46 <Cale> JonReed: Analogously to mapM vs. forM
12:57:27 <clojure_is_best_> ertes I don't think that works
12:57:34 <ertes> clojure_is_best_: doesn't help you too much with interactive, unless you use the "define, then combine" interaction style
12:58:14 <ertes> clojure_is_best_: let mx = ... {- define -}; let my = ... {- define -}; do x <- mx; y <- my; pure (x + y)  {- combine -}
12:58:38 <Lovepon> expMod x n m = x^n `mod` m; or expMod n m x = x^n `mod` m?
12:58:40 <ertes> define all the Maybe things without matching, then use Maybe as a monad at the end
12:59:18 <ertes> Lovepon: expMod modulus base exponent
12:59:19 <Lovepon> The latter allows composability. The former preserves the order.
12:59:33 <Lovepon> ertes: Why not exponent base?
12:59:52 <ertes> Lovepon: if the base is what changes most frequently, use that one
13:00:02 <ertes> but the modulus probably changes least frequently
13:00:06 <Lovepon> ertes: Yeah.
13:00:32 <ertes> Lovepon: i like to use reflection for that case
13:00:40 <Lovepon> ertes: reflection?
13:00:50 <ertes> Lovepon: communicate the modulus through types, not values
13:01:18 <clojure_is_best_> ok i'm doing this now:
13:01:18 <clojure_is_best_> let vals = either (\_ -> M.fromList []) (\x -> x) result
13:01:23 <Lovepon> ertes: How does that work? The thing that's going into my mind is dependent types like Fin.
13:02:00 <ertes> Lovepon: no dependent types involved:  newtype Mod n = Mod Integer  -- the type argument reflects the modulus through a type class
13:02:09 <clojure_is_best_> little golfing ... : let vals = either (\_ -> M.empty) id result
13:02:56 <ertes> Lovepon: the naive, fast approach is to define certain types that can be used as 'n' and a type class:  class Modulus n where modulus :: mod n -> Integer
13:03:10 <ertes> Lovepon: the naive, slow approach is to use type-level naturals, so every modulus is possible
13:03:12 <clojure_is_best_> anything better i can do than that?
13:03:23 <Lovepon> ertes: I see.
13:03:24 <ertes> Lovepon: the modern, fast approach is to use the 'reflection' library
13:03:44 <Lovepon> ertes: I'll bookmark it. :D
13:03:51 <Lovepon> This sounds interesting.
13:04:10 <ertes> Lovepon: i always use reflection for things that are in principle type-bound rather than value-bound
13:05:06 <ertes> clojure_is_best_: doesn't look too bad to me
13:05:45 <ertes> clojure_is_best_: if you're not going to use the Left result anyway, you could just use Maybe (unless most of the functions you use give you Either anyway)
13:06:05 <ertes> anyway, anyway, anyway, anyway, ‚Ä¶
13:06:16 <Lovepon> ertes: I wonder how long it'd take me to reach arithmoi level.
13:06:26 <ertes> Lovepon: in terms of?
13:06:27 <lpaste> tippenein pasted ‚Äúmzero is like nil ?‚Äù at http://lpaste.net/161333
13:06:50 <Lovepon> ertes: As of current, compatibility.
13:06:59 <clojure_is_best_> ertes well it's a runEitherT from a servant client
13:07:12 <Lovepon> ertes: Rather, coverage.
13:07:22 <hsk3> When parsing something, do people normally only use one parsing library at the same time?For example, do they pick one of parsec, attoparsec, megaparsec, aeson, cassava, trifecta, etc.   and stick to that one?
13:07:22 <hsk3> Or do they sometimes pick two and "combine" those in some way? Does such combination make any sense?
13:07:32 <clojure_is_best_> so it's not my own code - is there a runMaybeT way of running a servant client?
13:07:38 <hsk3> (It's a noob question. Wondering how things fit together)
13:07:41 <tippenein> I'm confused about how mzero casting is supposed to act
13:08:06 <ertes> Lovepon: coverage is easy enough, but speed is a different story‚Ä¶  arithmoi is on GMP level
13:08:07 <clojure_is_best_> now i'm unwrapping the inner layer maybe like this:
13:08:10 <c_wraith> hsk3: combining generally doesn't really work at that level.
13:08:13 <clojure_is_best_> let response = maybe Null id (M.lookup "response" vals)
13:08:13 <Lovepon> ertes: True.
13:08:34 <Welkin> hsk3: if you need to parse CSVs, use cassava, JSON or yaml, use aeson
13:08:38 * clojure_is_best_ clumsily unpacking stuff from servant json clients
13:08:39 <Welkin> hsk3: for a custom parser, use parsec
13:08:45 <Lovepon> ertes: I'm aiming for this to be portable though.
13:09:15 <Lovepon> ertes: Arithmoi's not building for my 32-bit laptop, and it doesn't seem to build for ghcjs too.
13:09:20 <hsk3> Welkin: ok thanks. That answers my question. So when people talk about combining in the context of parsing in Haskell, they usually mean combining with >>, <*, *>, etc. with stuff from *within the same library*. Correct?
13:09:25 <Welkin> hsk3: attoparsec is only if you really need the extra speed
13:09:41 <clojure_is_best_> this is weird, unwrapping all these aeson maps...  layer after layer of dynamic typing-like code.
13:09:45 <Welkin> the errors from it are horribly confusing
13:10:45 <Welkin> hsk3: I am not sure since I have never heard anyone talk about "combining parsers" unless you mean building smaller parsers and composing them together to create more complex parsers
13:10:57 <Welkin> which is the basis of functional programming itself
13:11:27 <Welkin> hsk3: if you go through the Upenn haskell course, it covers parsers
13:11:28 <ertesx> Lovepon: well, you're going to build everything on standard Integer functions then‚Ä¶  in principle you can implement the most naive brute-force algorithm everywhere to get coverage quickly, then start to replace them with better algorithms
13:12:11 <EvanR> clojure_is_best_: this is where the aeson Parser monad helps
13:12:13 <Lovepon> ertesx: Hahaha, I'll probably be implementing stuff according to "if I can do it efficiently enough" :P
13:12:27 <hsk3> Welkin: but when you build smaller parsers and compose them into complex parsers, you're usually creating small [parsec or aeson] parser and composing them into complex [parsec or aeson] parser aren't you? You're never creating small parsec parsers and combining them into aeson parsers are you? That doesn't even make any sense does it?
13:12:31 <clojure_is_best_> welkin i'm not sure i agree. for beginners attoparsec types are much easier to deal with
13:12:34 <clojure_is_best_> than parsec
13:13:27 <clojure_is_best_> EvanR you mean defining fromJSON instances? these json data are a beast
13:13:28 <Zemyla> Is there a pure Haskell PCRE library?
13:13:57 <Lovepon> ertesx: What open source license can I use that allows one to use this ocde in closed source? (This library is being used to make a closed source program.)
13:14:00 <ertesx> Lovepon: http://lpaste.net/161334
13:14:24 <Welkin> hsk3: no, it doesn't make sense
13:14:32 <ertesx> modular arithmetic using reflection‚Ä¶  a module i've written for experiments
13:14:35 <clojure_is_best_> like hundreds of fields. maps seem to be preferable to record types for this right? the rpoblem is there's a lot of data "unrolling" to deal with for maps
13:14:36 <hsk3> Welkin: ok thanks
13:14:41 <hsk3> good to know
13:14:43 <ertesx> Lovepon: i use the apache license, but BSD3 will work as well
13:14:57 <Lovepon> ertesx: I see, thanks.
13:14:59 <EvanR> clojure_is_best_: not necessarily
13:15:03 <ertesx> Lovepon: apache v2 to be specific‚Ä¶  it's a bit stricter than BSD3 in that it has some patent-related stuff
13:15:32 <ertesx> it's recommended by the FSF as a permissive license
13:15:32 * hackagebot annah 1.0.0 - Medium-level language that desugars to Morte  https://hackage.haskell.org/package/annah-1.0.0 (GabrielGonzalez)
13:15:59 <clojure_is_best_> EvanR how else should one do it, given the json data has hundreds of fields?
13:15:59 <Lovepon> ertesx: I'm kinda lost. Where is `n` in data Mod n being used?
13:16:01 <alpha44> How fast are the Haskell bindings for Z3 ( Z3 Monad)
13:16:05 <EvanR> clojure_is_best_: parse :: (a -> Parser b) -> a -> Result b so you can use a parser directly if you want
13:16:15 <alpha44> Will they be faster than the Python bindings?
13:16:41 <ertesx> Lovepon: pretend that the 'modulus' field does not exist‚Ä¶  it is only used to get a slight boost in performance (but it's really minimal)
13:16:41 <clojure_is_best_> EvanR where is parse defined? is there an example of this?
13:16:46 <alpha44> Also, best functional language with fastest bindings for Z3
13:16:52 <ertesx> Lovepon: see the implementation of 'fromInteger'
13:17:00 <EvanR> clojure_is_best_: did you look at the stuff on hackage, there is source links there
13:17:02 <zv> alpha44: OCaml has the fastest bindings
13:17:19 <ryantrinkle> when I have a name like caG_info, how can i determine where it came from in the Haskell source?
13:17:27 <ertesx> Lovepon: because 'fromInteger' doesn't receive the modulus, it uses 'reflect' to get it from the type 'n'
13:17:34 <Cale> alpha44: I would usually expect the solver to take long enough than any marshalling or whatever needed to be done at the interface to be trivial in comparison.
13:17:37 <Lovepon> ertesx: I see.
13:17:47 <nitrix> Hi, I have a quick question.
13:17:48 <EvanR> clojure_is_best_: but youd typically use FromJSON 
13:17:56 <Lovepon> ertesx: What makes this different from Dependent Types?
13:17:58 <Cale> ugh, that sentence was mangled
13:18:02 <mauke> I have a quick but useless answer
13:18:09 <ertesx> Lovepon: it's‚Ä¶  well‚Ä¶  not dependent =)
13:18:12 <Lovepon> ertesx: Actually, ignore that question.
13:18:13 <ryantrinkle> (the name is coming from perf/gdb)
13:18:19 <nitrix> When using GHCI and concurrent threads, when I interactively run a function async, something its output gets interleaved with GHCI's prompt.
13:18:38 <nitrix> The program is using MVar and works fine concurrently, minor the GHCI glitch.
13:18:41 <nitrix> Any way to fix that?
13:18:47 <ertesx> Lovepon: it is a very simple case of "lightweight dependent types"
13:18:48 <haskell646> Why do we have closed type families but not closed data families?
13:18:55 <clojure_is_best_> EvanR most examples deal with pretty tiny records though
13:18:55 <EvanR> theres a package that claims to fix the interleaving of stdout
13:19:01 <Lovepon> ertesx: I see.
13:19:05 <ertesx> Lovepon: simple enough that it's realistic to use in real code
13:19:20 <clojure_is_best_> EvanR is it that I can exclude fields I'm not using in the parseJSON definition?
13:19:26 <ertesx> "real" as in: not toy code
13:19:27 <clojure_is_best_> i haven't tried to do that before
13:19:29 <Lovepon> ertesx: What do you think of refinement types?
13:19:36 <EvanR> you dont have to use everything in the object
13:19:36 <clojure_is_best_> but i suppose that would kind of solve things
13:19:41 <ertesx> Lovepon: as in GADT pattern-matches?
13:19:59 <haskell646> Anyone?
13:19:59 <ertesx> "type refinement"?
13:20:00 <Lovepon> ertesx: Hmmm, I'm not exactly sure.
13:20:13 <clojure_is_best_> EvanR so what happens if i exclude a bunch of fields that are there in the JSON data? aeson is okay with that?
13:20:17 <ertesx> Lovepon: i don't know what "refinement types" are, sorry
13:20:19 <Lovepon> ertesx: Wait, let me check my logs, my friend sent me an example.. declaration?
13:20:41 <EvanR> clojure_is_best_: FromJSON is for converting any json to some type, how is up to you
13:20:45 <Lovepon> ertesx: "e.g., { x : Nat | x < 10 }"
13:20:55 <Cale> ryantrinkle: that looks like maybe a GHC-generated variable name? Can you -ddump-simpl and -ddump-to-file?
13:20:55 <EvanR> objects arent specifically records, thats just a common way to convert
13:20:57 <ertesx> ah
13:21:22 <Lovepon> ertesx: From what I understand, this has a benefit that it's still Nat, just more constrained.
13:21:39 <Lovepon> pyon: Ping.
13:21:44 <Cale> nitrix: Only do printing from the main thread?
13:21:57 <clojure_is_best_> EvanR i use the applicative sugar magic, so i'm not that confident as to what i can get away with
13:22:09 <ertesx> Lovepon: i wouldn't know where to use them
13:22:47 <ertesx> Lovepon: but a refinement type 'ConstraintNat' is then really just a family of types, one for each bound
13:22:59 <ertesx> so we can define them in haskell, too
13:23:07 <EvanR> clojure_is_best_: if you are trying to convert to T {a :: A, b :: B} then you would just do T <$> someParserA <*> someParserB
13:23:13 <Cale> haskell646: Isn't that just a GADT?
13:23:14 <ertesx> Lovepon: in fact, i'd do that with reflection =)
13:23:25 <EvanR> someParser may not even be looking for object fields
13:24:15 <Lovepon> ertesx: I'm not exactly sure, since I haven't tried it out myself, but maybe this can be used to prevent type casting.
13:24:19 <Lovepon> ertesx: Rather, reduce.
13:24:44 <Lovepon> ertesx: One problem I have with Haskell is with `f :: Integral a => a -> a -> a`
13:24:56 <EvanR> but if converting from some object to T, then you can just use two fields and ignore the others 
13:24:59 <EvanR> as parsers
13:25:45 <Lovepon> ertesx: Having a whole lot of type casting IMO distracts you from the code itself.
13:26:08 <Lovepon> ertesx: For example, IMO, it's totally sane to add Int32 and Int8 together.
13:26:14 <xa0> Lovepon: you sound like you want liquidhaskell
13:26:24 <Lovepon> xa0: :P
13:26:41 <Lovepon> xa0: When I get the time.
13:26:53 <xa0> :D
13:27:04 <Lovepon> xa0: I'll have to make a decision whether to check thato r Idris.
13:27:17 <ertesx> Lovepon: i don't mind type-casting too much, and indeed i would mind being able to add Int32 and Int8, because if i could, that would be a type system "peculiarity" i'd have to memorise‚Ä¶  does that make sense?
13:27:32 <ertesx> Lovepon: if you really want to add Int8 and Int32, what you really need is a different Num class
13:28:03 <ertesx> like VectorSpace
13:28:17 <EvanR> AnyInt = I8 Int8 | I16 Int16 | I32 ...
13:28:39 <EvanR> Lovepon: it would only make sense if you decide how the conversion should work
13:28:40 <zv> alpha44: I am writing Javascript bindings as well that are very quick, but I doubt you would be interested in those.
13:28:46 <ertesx> or even just: class NumDoWhatIMean d a where add :: d -> a -> a
13:28:55 <Lovepon> ertesx: Hmmm...
13:28:55 <EvanR> which you can do
13:30:23 <EvanR> ertesx: or a sum type
13:30:33 * hackagebot arb-fft 0.3.0.0 - Pure Haskell arbitrary length FFT library  https://hackage.haskell.org/package/arb-fft-0.3.0.0 (IanRoss)
13:30:48 <Lovepon> ...
13:30:52 <Lovepon> yolandivisser: you're... here..
13:31:13 <Lovepon> yolandivisser: oh my god you're everywher
13:31:21 <ertesx> EvanR: if you want to introduce dynamic typing at the same time, yeah, but there is no reason that a type-casting addition has to be dynamically typed
13:31:23 <EvanR> youre basically hitting on auto conversion of some sort
13:31:35 <EvanR> Lovepon
13:31:51 <EvanR> so MPTC can do that
13:31:56 <Lovepon> ertesx: I'm quite curious, how is it peculiar?
13:32:25 <Lovepon> ertesx: It's been 1 or so year since I started using Haskell, so I still have quite of a C mindset.
13:32:51 <ertesx> Lovepon: if ((+) :: (Num a) => a -> a -> a) and (w8 :: Word8) and (w32 :: Word32), then w8 + w32 is a type error in my mind‚Ä¶  it must be a type error
13:33:00 <ertesx> implicit casting means that this wouldn't be a type error
13:33:03 <int-e> Hmpf, e-mail is too hard for me.
13:33:23 <ertesx> so it would be a peculiarity‚Ä¶  something that doesn't make sense, unless my understanding of the type system is incomplete
13:33:38 <ertesx> what i love about haskell's type system is that it's *simple*
13:33:44 <ertesx> (not *easy*, but *simple*)
13:33:44 <Lovepon> ertesx: I see, I get what you mean.
13:33:49 <EvanR> implicitly truncating the word32 to word8 ? ;)
13:35:35 <ertesx> Lovepon: you can still get your implicit casting, but need either dynamic typing (EvanR's sum type) or a different (+)/Num
13:35:56 <Lovepon> ertesx: Yeah.
13:36:06 <ertesx> in fact Integer is dynamically typed that way
13:36:18 <ertesx> it uses Int, when it fits
13:36:26 <Lovepon> ertesx: :o I didn't know that.
13:36:39 <Lovepon> ertesx: How about for when it doesn't fit?
13:37:03 <ertesx> then what it uses depends on the selected integer library =)
13:37:09 <yolandivisser> Lovepon: murda murda murda
13:37:10 <ertesx> with regular GHC you would get GMP
13:37:12 <EvanR> Lovepon: its a lot easier if you just use one type throughout, like Int32
13:37:18 <EvanR> or Word32
13:37:27 <Cheesegrater> hey, anyone here managed to install openAL on windows?
13:37:29 <Lovepon> ertesx: Ah.
13:37:33 <EvanR> (which i really think are good as separate types)
13:38:06 <EvanR> and at the boundaries of the code project your IntWhatevers to Int32
13:38:23 <EvanR> with fromIntegral
13:38:23 <nshepperd> one reason also that you don't want such implicit casting is because it throws information away in type inference
13:38:42 <nshepperd> '(2 + 3) :: Int' would be ambiguous
13:39:10 <EvanR> cough defaulting
13:39:12 <ertesx> VectorSpace-style implicit "casting" is pretty safe there
13:39:20 <ertesx> add :: Scalar -> Vector -> Vector
13:39:26 <maerwald> wondering why attoparsec does not use MonadThrow
13:39:36 <Lovepon> Thanks.
13:39:39 <nshepperd> bah, defaulting
13:39:39 <EvanR> or MonadErrorOfTheWeek?
13:39:43 <maerwald> instead it just provides two specific functions for Maybe and Either
13:40:06 <ertesx> maerwald: history
13:40:25 <ertesx> attoparsec is older than both exceptions and monad-control
13:40:27 <maerwald> that's an explanation, not an argument :P
13:40:55 <ertesx> scratch the latter =)
13:41:24 <Lovepon> If I want to follow arithmoi, I should really have test cases. Lo.
13:41:29 <acertain> why not `instance (KnownNat n, KnownNat m) => KnownNat (n + m)`, etc?
13:41:32 <clojure_is_best_> what determines wheter aeson packs a value in a Data.Map or Data.HashMap?
13:41:34 <Lovepon> Lol.
13:42:02 <EvanR> clojure_is_best_: object (a value) is always HashMap
13:42:11 <ertesx> clojure_is_best_: i don't think it uses Map at all, does it?
13:42:28 <EvanR> but you can convert it all to a Map using the standard FromJSON instances
13:42:52 <clojure_is_best_> ertesx well maybe i was confused. using servant the top level structure is a Map because i specified it to be
13:42:54 <nshepperd> acertain: I think there some plan to do that sort of thing with a type checker plugin in ghc next
13:42:59 <clojure_is_best_> i guess the inner layer values are all hashmaps
13:43:18 <EvanR> you choose how to view the json
13:43:26 <EvanR> value with hashmap is just one way
13:44:16 <nshepperd> acertain: just writing that instance right now doesn't work, because you can't write instances for type synonyms or families
13:44:22 <t7> is there a function to skip n items form a list
13:44:29 <t7> tail $ tail $ ....
13:44:44 <nshepperd> and it would be overlapping and ambiguous and things, or something like that
13:44:45 <acertain> ah that makes sense :|
13:45:06 <clojure_is_best_> EvanR can I make the values Data.Map instead of Data.HashMap?
13:45:17 <geekosaur> > drop 3 [1..10]
13:45:18 <lambdabot>  [4,5,6,7,8,9,10]
13:45:49 <EvanR> you parse the json into a Data.Map instead of a Value
13:45:53 <nshepperd> acertain: for now you can use https://hackage.haskell.org/package/typelits-witnesses and pull the instance you need into scope manually
13:45:58 <EvanR> or HashMap or whatever
13:46:10 <EvanR> bbl
13:46:25 <acertain> yep, that's what i'm doing
13:57:30 <haskell563> Howdy! I've got a Constants.hs that I'm exporting set values to test with, and it's reading some of my values as Integer rather than Int - is there a way I can treat all data values as Int?
13:57:41 <haskell563> (All my functions work on Int and not Integer)
13:58:58 <lyxia> add some type signatures
13:59:29 <t7> anyone know a not-dog-slow regex package that can handle unicode?
14:11:45 <haskell799> hi can I ask question
14:12:50 <jomg> haskell799, most certainly :)
14:12:57 <haskell799> ƒ± want to create relational family tree in haskell.
14:13:11 <haskell799> could you send example to make this ?
14:13:30 <haskell799> I could not find any document or code example
14:14:31 <t7> haskell regex is sooo slooooow
14:14:48 <t7> maybe bytestring will speed it up
14:15:06 <lyxia> use Text for text
14:17:49 <Lovepon> Wow.
14:17:59 <Lovepon> This is *way* *way* faster than I expected.
14:18:39 <haskell799> Can somebody help me create family tree in haskell , I am newbie
14:18:53 <ertesx> t7: regex-tdfa*
14:19:04 <t7> its mega slow with Strings
14:19:20 <ertesx> t7: use Text
14:19:22 <t7> cant find a Text interface
14:19:30 <ertesx> t7: regex-tdfa-text
14:19:40 <t7> ah different package, my bad!
14:20:37 <nitrix> Is there a unicode character for => ?
14:20:47 <pavonia> haskell799: What do you need help with?
14:22:05 <geekosaur> nitrix, ‚áí U+21D2
14:22:07 <pavonia> nitrix: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html
14:22:23 <haskell799> pavonia: I could not figure how I can make , I need some code example to create
14:22:39 <haskell799> But I dont find maybe send me
14:23:13 <pavonia> What is your exact aim? A "family tree" is a bit vague
14:24:51 <haskell799> Simple family tree user should add somebody as father mother or child, 
14:25:18 <haskell799> And finally If I want to show relational any two person
14:25:45 <haskell799> Program prints out the result
14:25:51 <t7> is T.unpack really slow or something?
14:27:01 <kadoban> t7: Not particularly. It's a lot slower that ... not doing it though.
14:27:14 <t7> maybe its just a ghci thing
14:28:08 <t7> http://lpaste.net/161337 <- half a million lines
14:28:15 <t7> taking forever
14:28:26 <ertesx> haskell799: what's your level of haskell experience?
14:28:29 <pavonia> haskell799: Maybe start with the data types. Think of how you could represent the tree as a data structure, then try to express this in Haskell data types
14:28:45 <kadoban> t7: There's no other way than T.unpack? O.o That sounds not amazing.
14:28:58 <t7> i got rid of string
14:29:01 <t7> and its still slow
14:29:10 <haskell799> ertesx : ƒ± am newbie , I only take this course -> http://www.shuklan.com/haskell/
14:30:39 <ertesx> t7: which part is slow?
14:30:58 <t7> parseDump ... >>= Map.size
14:31:10 <ertesx> t7: on a first glance i notice that you use Map, when you'd better use HashMap
14:31:28 <ertesx> (Map Text) is almost bound to be slow
14:31:35 <ertesx> at least much slower than HashMap Text
14:31:39 <haskell799> pavonia: Okey. I got it. And last question , Is there any advantage to make tihs project with Haskell ? Is there more shorter than python ?
14:33:11 <ertesx> haskell799: haskell doesn't always give you shorter code‚Ä¶  for small things it will probably even be longer
14:33:26 <ertesx> but it does give you easy refactoring, correctness, speed and scalability
14:33:52 <Rembane> And monads!
14:33:55 * Rembane ducks
14:33:56 <ertesx> it gives you the the ability to abstract in more useful ways than "wrap in a class"
14:34:36 <Rembane> And it's imo easier and gives shorter code to handle errors when you need to.
14:34:58 <t7> still slow with hashmap :o i think the intensive processing stuff might aswel not be in haskell anyway
14:35:17 <haskell799> ertesx: okey thanks. As you understood, this is school project. Proffessor give a chance to make this python or haskell
14:36:07 <ertesx> t7: you should see which part of it is slow‚Ä¶  regex is slow in general, when there are cleverer ways to parse
14:36:13 <haskell799> ertesx: but I do not find any material internet to make this project could you send any code for example ?
14:36:23 <t7> ertesx: just weird that javascript can do this in seconds
14:36:43 <maerwald> Rembane: you have monads in python even
14:36:47 <maerwald> not that unique to haskell
14:36:48 <ertesx> t7: i could probably do that in haskell, too
14:36:57 <t7> ertesx: please show me
14:37:43 <ertesx> haskell799: i prefer not to give you code, but help you to write it yourself instead
14:37:58 <Rembane> maerwald: Indeed. That's cool!
14:38:54 <tippenein> haskell799: yeah, we could help you write functions around a basic data type. Give the `data Family` implementation a shot and go from there
14:39:02 <ertesx> t7: if you explain the application, i can tell you how i would do it‚Ä¶  in particular: what's the data format?  (i'm terrible at reading regex)  and what operations do you need on the data, once it's parsed?
14:39:40 <t7> so regex will never be as performant as javascript?
14:40:11 <hpc> ?
14:40:23 <haskell799> tippenein: erikd  Okey . Maybe you can draw path to make this project . and maybe send webpage or material ?
14:40:31 <ertesx> t7: i don't know‚Ä¶  other than the occasional 'grep' i never use regex
14:40:43 <haskell799> I realy want to this project in haskell
14:41:37 <hpc> i detect a bit of confusion in this regex conversation
14:41:54 <hpc> so, regexes are a family of languages, and don't really have an inherent performance characteristic
14:42:11 <hpc> they express finite state automata, and some implementations are ridiculously fast
14:42:56 <hpc> at least, relative to other implementations and using reference patterns
14:43:26 <hpc> you can write your own implementation of whatever a given regex would match, and its performance would depend on a few things
14:43:30 <ertesx> haskell799: since you're a haskell newbie, i suggest learning its basics first: https://github.com/bitemyapp/learnhaskell
14:43:51 <geekosaur> I thought the complaint was that the only canned regex implementation that is fully utf8 aware is the slow in-haskell one (regex-tdfa)
14:44:02 <hpc> oh, i see
14:44:22 <hpc> that was way up there
14:44:28 <ertesx> is regex-tdfa* slow?
14:44:39 <geekosaur> compared to the other regex backends, yes
14:44:46 <ertesx> i see
14:44:54 <geekosaur> (note that those two issues are related)
14:45:02 <ertesx> well, i don't use regex in code
14:45:08 <hpc> that actually makes this much easier
14:45:16 <hpc> regexes in haskell are generally rather garbage
14:45:23 <hpc> in the sense that you should be using parser combinators instead
14:45:38 <haskell799> ertesx: thanks , After I look, I come here again :)
14:45:42 <ertesx> i think regexes are garbage in general except for a few edge cases
14:45:49 <ertesx> practically speaking
14:45:52 <hpc> an appropriatel chosen parser combinator library is both faster and more expressive
14:46:00 <ertesx> haskell799: you're welcome‚Ä¶  good luck!
14:46:06 <hpc> i very much like regexes, but haskell isn't the language for them
14:46:08 <geekosaur> (that is, utf8 is *hard* to support in regex, and most regex engines don't try or only try partially to avoid the speed penalties)
14:46:11 <cpa> hi guys! I remember reading a few months ago about some kind auto-aeson that can take a json as input and output a haskell module that parses that json, using aeson. I need it and now I can't find it. Any pointers?
14:46:12 <maerwald> hpc: that's not always the same
14:46:20 <maerwald> err, ertesx
14:47:04 <hpc> the greatest strength of regexes is as a reification of extremely simple match/parse logic
14:47:11 <ertesx> cpa: https://hackage.haskell.org/package/aeson-0.11.1.4/docs/Data-Aeson-TH.html
14:47:23 <hpc> you can read a string from a file and build a regex and poof! parser
14:48:45 <JonReed> One thing I like about regex is that you can somewhere like https://regex101.com/ and prototype an expression pretty fast.
14:49:26 <Lovepon> @pl \p -> f p . g
14:49:26 <lambdabot> (. g) . f
14:49:30 <cpa> ertesx: thanks, but that's not what I'm looking for; I'm looking for a standalone bin that takes json as input and output a haskell file. I have a very large json and just rewriting the corresponding datatype would be quite cumbersome
14:49:34 <Lovepon> ew. bo. lol.
14:49:37 <Lovepon> no*
14:49:45 <ertesx> i don't know: "abcde" *> many (anyOf "xy")  -- hypothetical parser combinator library
14:49:59 <ertesx> is that really that much more awkward than 'abcde[xy]*'?
14:50:14 <ertesx> cpa: ah, sorry
14:54:15 <JonReed> cpa: Something like this https://hackage.haskell.org/package/json-autotype ? It was mentioned here http://conscientiousprogrammer.com/blog/2015/12/12/24-days-of-hackage-2015-day-12-json-autotype-inferring-types-from-data/
14:57:56 <hackrilege> is there a version of the ghci source written in c++ or java?
14:59:17 <Cale> hackrilege: what?
15:00:10 <Cale> hackrilege: There are no Haskell implementations in C++ or Java, at all.
15:00:21 <hackrilege> is it written in haskell?
15:00:24 <hackrilege> ghci
15:00:26 <Cale> yes.
15:00:35 <Cale> GHC is written in Haskell
15:00:41 <Cale> and that includes GHCi
15:01:10 <Lovepon> Cale: How does that work for`source-based distros btw? Get bins, use bins to build source?
15:01:31 <hackrilege> can i use hs2java or hs2c++, (whatever these tools are called) to get this?
15:02:23 <Cale> Lovepon: Yeah, you need a binary of the compiler if you want to compile it. I don't know why you would build the compiler from source without modification, having just downloaded a binary of it, but you're free to do so if you want to contribute to the heat death of the universe or something.
15:02:36 <_th_> hackrilege: i don't know what you're trying to achieve but maybe https://github.com/Frege/frege is what you are looking for
15:02:38 <Cale> hackrilege: huh?
15:02:48 <Lovepon> Cale: lol.
15:02:54 <Cale> hackrilege: "whatever these tools are called"?
15:03:07 <Cale> hackrilege: What the heck are you talking about?
15:03:16 <montanonic> So I'm getting a "could not parse ISO-8601 date" from a call to fromJson on http://hackage.haskell.org/package/gogol-apps-calendar-0.0.1/docs/Network-Google-AppsCalendar-Types.html#g:25 . The "could not parse ISO-8601 date" issue has a SO topic, but that topic is specifically for UTCTime at the top-level, whereas in this case the time value is nested, and I don't understand why there's the issue, or how to go about fixing it.
15:03:37 <hackrilege> i dont know what you call the haskell to java compiler
15:03:41 <hackrilege> or the one for c++
15:03:54 <hackrilege> but cant i use them to compile ghc to c++ or java?
15:04:02 <rofer> Is it possible to have a typeclass constraint on an output? eg. A function of type: Bar b => Foo -> b
15:04:02 <Lovepon> Should p and q both be randomly generated, or is  either fine? RSA?
15:04:14 <_th_> why would you want to?
15:04:29 <hackrilege> wow frefe
15:04:32 <hackrilege> frege*
15:04:38 <hackrilege> to compile to RISK
15:04:41 <hackrilege> ARM
15:04:47 <rofer> _th_: Was that directed at me?
15:04:50 <kadoban> rofer: Sure
15:04:56 <hackrilege> using a c++ compiler or a java compiler for ARM
15:05:17 <_th_> rofer: sry i meant hackrilege
15:05:29 <rofer> np
15:05:31 <rofer> kadoban: thanks
15:06:00 <hackrilege> no?
15:06:02 <kadoban> :t const $ fromInteger 2 -- for instance
15:06:04 <lambdabot> Num r => b -> r
15:06:30 <_th_> hackrilege: https://wiki.haskell.org/ARM
15:07:43 <hackrilege> awesome thanks!
15:07:44 <rofer> kadoban: Ah! I couldn't think of an easy way to test with the repl, but that's just what I was hoping to see
15:07:58 <hackrilege> i want to get haskell apps to the play store
15:08:46 <JonReed> hackrilege: One option is to compile to JS using GHCJS and then use cordova to build the app.
15:09:09 <_th_> hackrilege: maybe you also wanna read this: https://wiki.haskell.org/Android
15:09:44 <kadoban> Yeah, through javascript is likely the way to go for mobile currently.
15:09:54 <kadoban> That way you can target more than just android too.
15:12:14 <Lovepon> Hmmm
15:12:37 <Lovepon> I need some help with prime numbers. :s
15:13:31 <Lovepon> I'm generating RSA ps and qs.
15:13:53 <Lovepon> How do I make it as close to the minimum keysize as possible?
15:15:17 <kadoban> Lovepon: Don't you usually just generate a random n-bit number and then find the next (probable) prime bigger than the random number you generated? The chance of it needing n+1 bits is ... extremely tiny for large n.
15:15:30 <Lovepon> kadoban: Oh.
15:15:47 <Lovepon> kadoban: You'll probably cringe at my implementation..
15:16:16 <kadoban> I more cringe when people implement crypto at all ...
15:16:21 <Lovepon> kadoban: Let's just say I have this line. generateFilterR p = iterateUntil p . getRandomR
15:16:44 <Lovepon> kadoban: Lol.
15:16:51 <Lovepon> kadoban: I'm bored. :c
15:17:07 <kadoban> Lovepon: Well, that should work too, just yeah you're generating a lot of random numbers that aren't necessary.
15:17:29 <Lovepon> kadoban: Yeeeahhhh it took me about 20 seconds to generate a keypair of 2048 bits.
15:19:02 <kadoban> Well that's not really a deal-breaker, but when generators take that long hopefully they're spending most of it generating extra entropy instead.
15:19:16 <EvanR> the prime test is the slow part
15:19:30 <EvanR> you could be doing 1 per core
15:20:06 <Lovepon> Hmm
15:22:30 <Lovepon> Oh.
15:22:41 <Lovepon> So that's what happened.
15:22:58 <Lovepon> I generated a 12k bits key.
15:23:21 <Lovepon> Oh wait
15:23:35 <Lovepon> I'm stupid. Ignore.
15:23:44 <Lovepon> I forgot how to math.
15:24:30 <EvanR> folklore says that if you use a too huge key then decrypting will take longer and make timing analysis easier
15:27:04 <montanonic> http://stackoverflow.com/questions/19423533/parsing-utctime-with-aeson
15:27:16 <montanonic> http://hackage.haskell.org/package/gogol-apps-calendar-0.0.1/docs/Network-Google-AppsCalendar-Types.html#g:25
15:27:57 <ertesx> Lovepon: to generate an b-bits prime number, you generate a prime between 2^(b - 1) and 2^b - 1
15:28:02 <montanonic> From what I understand from that SO post, "could not parse ISO-8601 date" shouldn't come up when parsing an Object or Array
15:28:29 <montanonic> The type I'm trying to parse into is definitely an Object, so I don't see why aeson should be throwing that error.
15:29:11 <ertesx> Lovepon: generate a random number, apply a small sieve as a first test, then use a probabilistic test as the second test
15:29:14 <Lovepon> ertesx: I need to generate 2 prime numbers, p-bits and q-bits such that q*q >= n.
15:29:21 <montanonic> `Events` has a fromJSON instance defined, but I still get a "could not parse ISO-8601 date" when I try using it; I haven't been able to figure out what's going wrong so far
15:29:50 <ertesx> Lovepon: no, you want p*q < 2^b‚Ä¶  the formula i gave you will guarantee that
15:30:12 <Lovepon> p*q >= n* woops
15:30:23 <Lovepon> ertesx: Hmm
15:30:53 <ertesx> Lovepon: a 2*b bits RSA modulus is a product of two b bits prime numbers
15:31:02 <Lovepon> ertesx: I see what you mean.
15:31:03 <ertesx> Lovepon: are you implementing RSA yourself?
15:31:09 <Lovepon> ertesx: For fun, yaeh.
15:31:20 <ertesx> Lovepon: good‚Ä¶  leave it at fun, though =)
15:32:02 <ertesx> Lovepon: a fast primality test first does a small sieve test to get rid of most composites
15:32:13 <Lovepon> ertesx: Is it guaranteed that there is a prime in [2^(b-1),2^b)?
15:32:35 <ertesx> Lovepon: i don't think it's guaranteed, but it's likely enough
15:32:40 <Lovepon> ertesx: Ah.
15:34:23 <EvanR> (is there a power of two 2^k such that there is no prime between 2^k and 2^k+1
15:34:31 <EvanR> ( )
15:34:37 <EvanR> )
15:34:42 <Lovepon> EvanR: lisp
15:35:28 <kadoban> EvanR: No, unless I'm doing an off by one and you're talking about like ... k=0 or something.
15:35:34 <EvanR> no
15:35:52 <EvanR> proof?
15:36:09 <ertesx> statistically speaking: the density of primes likely decreases slower than the range [2^k; 2^(k + 1) - 1] grows with k
15:37:04 <Lovepon> EvanR: Yes. (2^k,2^k+1) = {}. :P
15:37:15 <EvanR> yes i know its super probably true because of that
15:37:34 <kadoban> https://en.wikipedia.org/wiki/Bertrand's_postulate
15:40:10 <EvanR> nice
15:40:27 <ertesx> so it is guaranteed
15:40:48 <EvanR> that puts some sort of bound on how long a linear search for a prime will take
15:41:33 <kadoban> Yep, though a pretty high one. You can get closer to how long you'll expect it to take with the better estimates of prime density, not just the upper-bound.
15:41:45 <kadoban> isn't it something like 1/ln(n) numbers are prime, near n?
15:42:17 <Lovepon> Sooooo does that mean that there are infinite number of primes
15:42:23 <ertesx> kadoban: there are better estimates, but it's close enough to display a progress bar
15:42:38 <kadoban> Lovepon: Well there's a much cuter proof that there are an infinite number of primes, but yes there are.
15:42:46 <kadoban> ertesx: True
15:42:50 <ertesx> Lovepon: there are infinitely many primes, but no
15:43:00 <ertesx> well, actually it does
15:43:10 <Lovepon> kadoban: When was this proved?
15:43:18 <Lovepon> proven*
15:43:23 <kadoban> Lovepon: Which, the infinite number of primes?
15:43:26 <Lovepon> Yeah
15:43:28 <exio4> a long time ago?
15:43:42 <kadoban> Couple thousand years or so?
15:43:50 <Lovepon> Oh.
15:44:01 <Lovepon> I should really verify everything I hear lol.
15:44:17 <Lovepon> IIRC, I heard someone say that it's still unsure. I lived believing that until now.
15:44:19 <Lovepon> '_'
15:44:24 <ertesx> Lovepon: you might question whether it's proven at all, if you want to get into some foundational arguments =)
15:48:07 <EvanR> come on
15:48:32 <EvanR> thats like earth is flat prove me wrong
15:49:14 <Lovepon> Bruh.
15:50:02 <ertesx> EvanR: if you'd question that one, you would question pretty much all of physics, so who knows
15:50:04 <Lovepon> It's not my fault that I'm a clueless teenager. :Y
15:50:38 * hackagebot casadi-bindings-internal 0.1.4.0 - low level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-internal-0.1.4.0 (GregHorn)
15:50:40 * hackagebot casadi-bindings-core 3.0.0.0 - autogenerated low level bindings to casadi  https://hackage.haskell.org/package/casadi-bindings-core-3.0.0.0 (GregHorn)
15:50:42 * hackagebot casadi-bindings 3.0.0.0 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-3.0.0.0 (GregHorn)
15:50:56 <kadoban> Lovepon: Look up Euclid's proof if you didn't already. It's quite short and hard to argue with, at least without weird formalisms that I wouldn't understand anyway probably.
15:52:03 <mauke> assume there's a finite number of primes. multiply them all, then add 1
15:52:13 <mauke> 2. ???
15:52:15 <mauke> 3. contradiction
15:52:23 <kadoban> Yep
15:52:30 <Lovepon> Oh.
15:53:16 <ertesx> 2. use the fundamental theorem of arithmetic and euclid's algorithm to show that you did not use the primes in step 1
15:53:22 <Lovepon> Wait...
15:53:32 <Lovepon> What's the proof to that one?
15:53:52 <Lovepon> "multiply them all, then add 1"
15:53:52 <ertesx> s/the primes/all the primes/
15:54:02 <Lovepon> I'm assuming that results in another prime?
15:54:07 <mauke> Lovepon: not necessarily
15:54:22 <mauke> Lovepon: the point is that it's not divisible by any known prime
15:54:24 <ski> mauke : no need to do the first assumption
15:54:36 <Lovepon> mauke: I see
15:54:37 <mauke> so it's either a new prime, or it's divisible by a new prime
15:54:44 <mauke> which contradicts the assumption
15:54:54 <ertesx> back to 1. add the missing primes, back to 2. find that you didn't use all, back to 1. etc. ‚Üí you constructed absurdity (an infinite loop) from an assumption ("there are finitely many primes")
15:55:05 <ski> (no need to do proof-by-contradiction here)
15:59:24 <ski> Lovepon : anyway, we can define a list of infinitely many primes (with no prime occuring more than once) as : the prime at index `n' is defined to be the smallest prime factor in : one plus the product of all the primes at indices less than `n'
15:59:34 <ski> (this is a recursive definition)
16:01:34 <nshepperd> Lovepon: the person you heard that from might have misexplained. it's known that there are an infinite number of primes; I believe the part that is still an open question is whether there is any "simple" pattern to them
16:02:15 <nshepperd> which is really multiple open questions, depend how "pattern" is cashed out
16:03:18 <Lovepon> nshepperd: Ah
16:03:23 <mauke> what about prime pairs?
16:03:29 <mauke> is that still unsolved?
16:03:44 <ertesx> mauke: if you mean twin primes, then yes
16:03:55 <mauke> (p and p+2 both being prime)
16:06:10 <Lovepon> ...
16:06:14 <Lovepon> What the hell did I just write
16:06:17 <Lovepon> 4 + 4 = 10
16:06:30 <Lovepon> Wtf is this? Octal?
16:06:34 <geekosaur> yep
16:06:55 <ertesx> mauke: if you allow p, p + 2*k, then there are proofs for some k, but not for k = 1 yet
16:06:58 <Lovepon> Having no sleep does things to your brain. Lol.
16:07:17 <ertesx> > let 4 + 4 = 10 in 4 + 4
16:07:19 <lambdabot>  10
16:07:36 <mauke> "k"
16:08:01 <ertesx> ‚àà ‚Ñï, > 0
16:08:16 <hpc> in base 8, everything's fine!
16:08:25 <Lovepon> hpc: base eight*
16:08:44 <Lovepon> Welp. I'm ost.
16:08:46 <Lovepon> lost*
16:09:04 <Lovepon> How do I calculate (x + y)^n - (x - y)^n
16:09:44 <ertesx> Lovepon: that's valid haskell code
16:10:01 <Lovepon> Err, I need to provide more context lol.
16:10:38 <Lovepon> How do I calculate the nth fibonacci, in "constant"(assuming that exponentiation is constant) time, without doing the sqrt(5) thingy?
16:10:48 * hackagebot HaskellNet-SSL 0.3.3.0 - Helpers to connect to SSL/TLS mail servers with HaskellNet  https://hackage.haskell.org/package/HaskellNet-SSL-0.3.3.0 (lemol)
16:11:27 <Lovepon> Because I don't want to taint my glorious code with floating point.
16:12:37 <ertesx> Lovepon: i don't know the formula, but you can use a number field with sqrt(5) in it
16:12:51 <Lovepon> ertesx: A number field?
16:13:27 <ertesx> Lovepon: take the set of all integers, add sqrt(5) to it, then add all the possible combinations of sqrt(5) with other numbers
16:13:42 <ertesx> you will find that you can write all of them using two components:  a + b*sqrt(5)
16:13:56 <Lovepon> Hmm
16:16:01 <ertesx> sorry, you need three components:  a + b*sqrt(5)^c
16:16:07 <tromp__> > 18^2
16:16:09 <lambdabot>  324
16:18:41 <ertesx> Lovepon: i'm stupid‚Ä¶  no, two components are enough
16:20:41 <Lovepon> I think I'm close to having something worthwhile.
16:21:38 <Lovepon> > let f n = ((1 + sqrt 5) ** n + 2**(n-1)*sqrt 5)/2**(n-1)*sqrt 5
16:21:39 <lambdabot>  <no location info>:
16:21:39 <lambdabot>      not an expression: ‚Äòlet f n = ((1 + sqrt 5) ** n + 2**(n-1)*sqrt 5)/2**(...
16:21:48 <Lovepon> > let f n = ((1 + sqrt 5) ** n + 2**(n-1)*sqrt 5)/2**(n-1)*sqrt 5 in f 1
16:21:50 <lambdabot>  12.236067977499792
16:22:42 <Lovepon> > let f n = (((1 + sqrt 5)/2)**n/sqrt 5) + 0.5
16:22:44 <lambdabot>  <no location info>:
16:22:44 <lambdabot>      not an expression: ‚Äòlet f n = (((1 + sqrt 5)/2)**n/sqrt 5) + 0.5‚Äô
16:22:46 <Lovepon> > let f n = (((1 + sqrt 5)/2)**n/sqrt 5) + 0.5 in f 1
16:22:48 <lambdabot>  1.223606797749979
16:23:01 <Lovepon> Hmmm
16:23:11 <Lovepon> How did that become times 10
16:25:40 <Lovepon> I can use the matrix multiplication one I guess.
16:25:43 <hjljo> how do i open a file for writing as long as it doesn't currently exist?
16:25:51 <toph_> :t (.:)
16:25:53 <lambdabot>     Not in scope: ‚Äò.:‚Äô
16:25:53 <lambdabot>     Perhaps you meant one of these:
16:25:53 <lambdabot>       ‚Äò.‚Äô (imported from Data.Function),
16:26:22 <toph_> :i (.:)
16:26:47 <Lovepon> Oh my God.
16:27:02 <Lovepon> I forgot why I was dealing with Fibonacci numbers until about a minute ago.
16:27:02 <toph_> is .: part of some language extension?
16:27:21 <shachaf> No, just a function.
16:27:35 <geekosaur> toph_, just provided by a library that's not part of a basic ghc installation
16:29:24 <hjljo> it kinda sucks that openFile both creates a new file and opens an existing file when they are two quite different things
16:30:32 <athan> hjljo: I swore it failed when it doesn't exist
16:30:38 <athan> maybe that's with a handle or something :s
16:30:55 <athan> There's also System.Directory to see if a file exists, pretty sure that's the module anyway
16:31:02 <hjljo> athan, i'll check again, but it's not the behaviour that i've been observing
16:31:36 <geekosaur> hard to do portably, I think; the System.Posix version lets you specify behavior
16:31:50 <geekosaur> and I presume Win32 has something similar
16:31:51 <hjljo> athan, checking if a file exists beforehand is futile because it doesn't mean it hasn't been created between checking if it exists and then openFile
16:31:57 <geekosaur> (but making a common interface...)(
16:38:09 <toph_> is there a language extension that adds a `?` prefix?
16:38:31 <Lovepon> This... this is becoming way and way harder than I expected.
16:38:41 <Lovepon> Sweet jesus.
16:39:35 <hjljo> atomically opening a new file for writing seems like something so obvious that there would be a standard way to do it :(
16:39:39 <geekosaur> toph_, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#implicit-parameters
16:39:49 <toph_> ty
16:42:07 <Lovepon> I'll go take a shower.
16:46:00 <athan> Would local data declarations like Idris be feasible in Haskell ever, you think?
16:46:24 <ski> interaction with type classes would have to be resolved
16:46:53 <athan> ski: For writing instances you mean?
16:47:01 <athan> ahh yeah I could see how that would hamper
17:00:17 <ertesx> Lovepon: http://lpaste.net/161348
17:00:59 <ertesx> calculating fibonacci through a number field
17:01:30 <idris_elba> hi
17:01:52 <Lovepon> ertesx: I should really read on reflection.
17:01:53 <ertesx> Lovepon: i haven't benchmarked this, but i seriously doubt that this is going to be much faster than just using the iterative formula
17:02:18 <ertesx> Lovepon: whenever you see "r", read it as "5"
17:02:25 <Lovepon> ertesx: Ah.
17:02:31 <ertesx> sqrtR = "sqrt 5"
17:02:44 <idris_elba> does it seem to anyone else like the package interface barrier gets in the way of extensibility?
17:02:52 <ertesx> Lovepon: and read "NF a b" as "a + b*sqrt(5)"
17:03:05 <Lovepon> Okay.
17:03:17 <idris_elba> what do people do if you want to add functionality to a library or have a modified version of a package function?
17:03:36 <idris_elba> the problem writing something external to the library is all the internal types and functions are inaccessible.
17:03:36 <hjljo> i'm not sure what utility a procedure has that both creates a new file and truncates an existing file is
17:03:39 <Lovepon> ertesx: You seem to be enjoying this. :P
17:03:46 <ertesx> Lovepon: i am =)
17:04:08 <Lovepon> ertesx: You're tempting me more and more. '_'
17:04:10 <hjljo> i mean how often to you want that functionality vs throwing an ioexception if the file already exists
17:05:03 <Lovepon> ertesx: I have a feeling that I must really use reflection.
17:05:12 <Lovepon> ertesx: On some of my code.
17:05:33 <idris_elba> usually reflection is not so great for safety & reasoning no?
17:05:54 <idris_elba> seems to be something DT languages tend to be better at
17:06:01 <ertesx> Lovepon: it's particularly useful in cases like this:  there is a number field for every integer r:  numbers of the form a + sqrt(r)
17:06:14 <ertesx> whoops
17:06:18 <ertesx> a + b*sqrt(r)
17:07:10 <ertesx> Lovepon: in fact when r reflects -1, NF r Double is equivalent to Complex Double
17:07:23 <hjljo> i guess i got to write a library myself if i want any sort of sane IO
17:07:26 <Lovepon> ertesx: Holy cow.
17:07:30 <Lovepon> ertesx: Dammmnnn
17:09:01 <Lovepon>             phi = (1 + sqrtR) / 2
17:09:26 <Lovepon> How?
17:09:44 <ertesx> how what?
17:10:05 <Lovepon> ertesx: How does that typecheck?
17:10:13 <Lovepon> 1 and sqrtR
17:10:25 <Lovepon> Oh wait.
17:10:31 <Lovepon> Is 1 being converted to NF 1 0?
17:10:35 <ertesx> yeah
17:10:46 <Lovepon> Okay.
17:10:51 * hackagebot vcatt 0.1 - Recursively check that a directory is under version control.  https://hackage.haskell.org/package/vcatt-0.1 (bergey)
17:10:56 <ertesx> 1 = fromInteger 1 = NF 1 0
17:11:41 <Lovepon> ertesx: I wonder if there's a way to get through without using Rational.
17:12:23 <ertesx> Lovepon: this number field trick (representing an algebraic number as two rationals)‚Ä¶
17:12:34 <ertesx> Rational is the same with integers =)
17:13:03 <hackrilege> is there a power of two 2^k such that there is no prime between 2^k and 2^k+1
17:13:15 <ertesx> Lovepon: the ratio trick: representing rational numbers as two integers =)
17:13:21 <Lovepon> ertesx: Right, but requires one to repeat operatinos,
17:13:25 <Lovepon> operations*
17:13:30 <Lovepon> ertesx: Yeah, that's what I mean.
17:14:14 <ertesx> since sqrtR ends up in the denominator, you would need to restructure the formula
17:14:22 <Lovepon> ertesx: In this case, we're dealing with 5 numbers. 4 Integers for the Rational type, and 1 for the reflection(is that the term for it?) type.
17:14:40 <ertesx> perhaps you'd find a way to get along with the sqrt(5)-number field over the half-integers
17:15:27 <ertesx> in general don't worry‚Ä¶  Rational is almost as fast as Integer when the denominator is 1
17:16:22 <geekosaur> hjljo, in some sense you can't do it sanely outside of Haskell either. most languages follow the POSIX spec... which leads to some weird corner cases on Windows, although it does what you expect maybe 95% of the time
17:16:25 <Lovepon> Hmmm
17:16:50 <geekosaur> that is, you get something equivalent to C's fopen() considered the portable interface
17:17:17 <geekosaur> but fopen is a Unix-originated API, and Windows doesn't map 100% to it
17:17:39 <ertesx> Lovepon: even in GHCi 'fib 5000000' hardly takes a second
17:17:49 <ertesx> Lovepon: and this is a netbook =)
17:17:49 <Lovepon> ertesx: Wait.
17:18:06 <Lovepon> Hmmm
17:18:21 <Lovepon> ertesx: There's soemthing I want to say, but I can't quite say it. Lol.
17:18:38 <Lovepon> Ah.
17:19:07 <Lovepon> ertesx: We can define (^) :: NF r a -> NF r a -> NF r a
17:19:15 <Lovepon> Actually, no.
17:19:27 <Lovepon> ertesx: We can define nfSquare :: NF r a -> NF r a
17:20:04 <Lovepon> Err
17:20:26 <ertesx> :t (^^)
17:20:28 <lambdabot> (Fractional a, Integral b) => a -> b -> a
17:21:07 <hackrilege> very very frustrated by the status of haskell on arm
17:21:12 <hjljo> geekosaur, yeah i'm not really angry at Haskell here, it's just something that seems it should be straightforward in general but isn't :|
17:21:22 <geekosaur> portabi;ity never is, sadly
17:21:26 <Lovepon> ertesx: I think I got it.
17:21:35 <hackrilege> hey, can someone check this code for me? http://lpaste.net/161329
17:21:45 <geekosaur> it's a hell of bizarre edge cases even for stuff thatr looks like it "ought to" work
17:21:49 <hackrilege> i get that MonadPlus requires Alternative as an error
17:22:15 <Lovepon> ertesx: We can define an Integral instance of this, can we not//
17:22:21 <ertesx> idris_elba: missed your question: reflection in haskell has nothing to do with reflection in other languages
17:22:49 <ertesx> idris_elba: it allows a type to communicate a certain value (rather than the name of the type)
17:23:15 <ertesx> Lovepon: not quite‚Ä¶  Integral has toInteger
17:23:24 <Lovepon> ertesx: Hmmm
17:23:39 <ertesx> Lovepon: toInteger (NF 0 1) = ?  -- that's not an integer by definition
17:23:57 <Lovepon> ertesx: Ah, I did not know about toInteger.
17:24:30 <Lovepon> ertesx: Oh, I know, toInteger = error "jk"
17:24:52 <ertesx> but you can go crazy, if you define a *proper* Ord instance (which isn't straightforward to do)
17:24:56 <Gurkenglas> hackrilege, you can add "instance Alternative List where (<|>) = mplus; empty = mzero"
17:25:16 <ertesx> Lovepon: Mod n (NF r Rational)  -- modular arithmetic over a number field over the rationals‚Ä¶
17:25:31 <Lovepon> ertesx: Actually, that's exactly what I was thinking.
17:25:34 <Gurkenglas> (Alternative is a superclass of MonadPlus and has to be defined as well if you want it to be MonadPlus.)
17:25:48 <Lovepon> ertesx: Since I'll be needing to work with stuff like that.
17:26:15 <ertesx> Lovepon: the Mod code i posted earlier is Integer-specific, but you can easily generalise to any‚Ä¶
17:26:20 <ertesx> :t Data.Fixed.mod'
17:26:21 <lambdabot> Real a => a -> a -> a
17:26:28 <ertesx> Lovepon: to any Real
17:26:29 <Lovepon> Wait. Wut
17:26:36 <hackrilege> Gurkenglas, thats not the point, Alternative should not be a superclass to MonadPlus
17:26:38 <Lovepon> > Data.Fixed.Mod 2.5 2
17:26:39 <lambdabot>      Not in scope: data constructor ‚ÄòData.Fixed.Mod‚Äô
17:26:40 <lambdabot>      Perhaps you meant one of these:
17:26:40 <lambdabot>        variable ‚ÄòData.Fixed.mod'‚Äô (imported from Data.Fixed),
17:26:46 <Lovepon> > Data.Fixed.mod 2.5 2
17:26:47 <lambdabot>      Not in scope: ‚ÄòData.Fixed.mod‚Äô
17:26:47 <lambdabot>      Perhaps you meant one of these:
17:26:47 <lambdabot>        ‚ÄòData.Fixed.mod'‚Äô (imported from Data.Fixed),
17:26:55 <Lovepon> Wait, what?
17:27:00 <Lovepon> Oh.
17:27:04 <Lovepon> > Data.Fixed.mod 2.5 2
17:27:06 <lambdabot>      Not in scope: ‚ÄòData.Fixed.mod‚Äô
17:27:06 <lambdabot>      Perhaps you meant one of these:
17:27:06 <lambdabot>        ‚ÄòData.Fixed.mod'‚Äô (imported from Data.Fixed),
17:27:07 <Lovepon> Shit
17:27:09 <Gurkenglas> hackrilege, why not? Do you also think Applicative should not be a superclass to Monad?
17:27:11 <Lovepon> > Data.Fixed.mod' 2.5 2
17:27:13 <lambdabot>  0.5
17:27:17 <Lovepon> I see.
17:27:20 <Lovepon> > Data.Fixed.mod' 2.5 2.1
17:27:23 <lambdabot>  0.3999999999999999
17:27:30 <Lovepon> Oh, right, floating point.
17:27:33 <Gurkenglas> Alternative and Monad combine in such a way that you don't even to define anything else to get from the two of them to MonadPlus
17:27:36 <hackrilege> Alternative, not Applicative
17:27:40 <Gurkenglas> *even need to
17:27:43 <hackrilege> no
17:27:46 <hackrilege> its not right
17:27:52 <hackrilege> thats not the point of Alternative
17:27:58 <ertesx> Lovepon: unfortunately NF is not Real, because it's not rational‚Ä¶  if that sounds stupid, don't blame me
17:27:58 <Gurkenglas> sure is
17:28:00 <hackrilege> there is only one Monad
17:28:14 <Lovepon> ertesx: Wait, what?
17:28:17 <ertesx> Lovepon: i didn't invent Real where toRational :: (Real a) => a -> Rational =)
17:28:24 <Lovepon> WTF
17:28:28 <hackrilege> Alternative is any other associative operator and identity
17:28:35 <ertesx> Lovepon: a type is Real when it can be converted to Rational =)
17:28:37 <hackrilege> im getting told different things from day to day here
17:28:48 <Lovepon> ertesx: Sweet...
17:28:58 <Lovepon> ertesx: Why. Lol.
17:29:12 <ertesx> you need *some* WATs in your language‚Ä¶
17:29:14 <Lovepon> Hahahaha
17:29:17 <Gurkenglas> It looks like http://sketchtoy.com/66928978
17:29:29 <Lovepon> ertesx: You need some WATs to power your language. :P
17:29:36 <ertesx> and the broken 'fix' function isn't enough
17:29:39 <ertesx> > fix error
17:29:40 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
17:29:49 <Gurkenglas> https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#t:MonadPlus says class (Alternative m, Monad m) => MonadPlus m where
17:29:50 <Lovepon> LOL
17:30:18 <hackrilege> and the conclusion was that by necessity, the Alternative functions should not be the same as MonadPlus
17:30:39 <hackrilege> Alternative giving means to express a non monadic alternative
17:30:46 <Lovepon> ertesx: Question. If Haskell decides to adapt parallel/concurrent execution of cases, how many programs would break?
17:31:09 <ertesx> Lovepon: cases?
17:31:22 <Lovepon> Err
17:31:24 <Lovepon> Patterns.
17:31:31 <Lovepon> @src (&&)
17:31:31 <lambdabot> True  && x = x
17:31:31 <lambdabot> False && _ = False
17:31:38 <Lovepon> Hmmm
17:31:53 <Lovepon> Not exactly what I was looking for.
17:32:01 <hackrilege> Gurkenglas, i was arguing as you are, but i was told i was wrong...
17:32:03 <augur> what are you looking for, Lovepon
17:32:18 <dfeuer> Lovepon, changing pattern matching semantics in any way whatsoever will be highly likely to break a large amount of code, often in subtle ways.
17:32:19 <Gurkenglas> "<ski>	hackrilege : well, `Alternative' isn't a superclass of `MonadPlus'" u w0t m8 - see above link, or what do you mean by "this ghc version"?
17:32:46 <hackrilege> yeah that
17:33:06 <dfeuer> Are there any performance gurus lying around here? I have a question about partial application of constructors with unpacked fields.
17:33:31 <Lovepon> dfeuer: It will only make some infinite loop expressions.. non-infinite.
17:33:57 <ertesx> dfeuer: shoot
17:33:59 <dfeuer> Lovepon, how?
17:34:24 <Lovepon> dfeuer: Actually, you're right.
17:34:39 <hackrilege> https://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html#MonadPlus
17:34:57 <Lovepon> Hmmm
17:35:13 <Lovepon> Does Haskell or GHC have a notion of commutativity?
17:35:24 <athan> Lovepon: I made a really shitty one lol
17:35:26 <hackrilege> directed to that from https://hackage.haskell.org/package/monadplus-1.4.2/docs/Control-Monad-Plus.html
17:35:28 <athan> @hackage commutative
17:35:28 <lambdabot> http://hackage.haskell.org/package/commutative
17:35:46 <athan> Lovepon: It's honestly better to _not_ have it, for... reasons
17:35:53 <hackrilege> i guess thats the source of the confusion
17:35:54 <ertesx> Lovepon: what kind of commutativity?
17:35:59 <dfeuer> ertesx, Data.Sequence has  data Node a = Node2 !Int a a | Node3 !Int a a a, and also data FingerTree a = Empty | Single a | Deep !Int !(Digit a) (FingerTree (Node a)) !(Digit a). A few bits of code (traverse, traverseWithIndex, and applicativeTree) partially apply a Node2, Node3, or Deep constructor.
17:36:01 <athan> idk there's applications where performance is gained, but it's not something deducible, i think
17:36:01 <dfeuer> BRB.
17:36:10 <Lovepon> ertesx: Rewrite according to some rules, etc. etc.
17:36:25 <athan> there's fusion :s
17:36:45 <athan> but that's like an integrated understanding of the commute for that rewrite IIRC
17:38:14 <ertesx> Lovepon: but what?  or for what purpose?
17:38:46 <Lovepon> > let (h:_) = take s [1..] in (\s p -> s /= 0 && p h) 0 (== 1)
17:38:47 <lambdabot>      Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚ÄòExpr‚Äô
17:38:48 <lambdabot>      In the first argument of ‚Äòtake‚Äô, namely ‚Äòs‚Äô
17:38:48 <lambdabot>      In the expression: take s [1 .. ]
17:38:52 <Lovepon> Eh
17:39:11 <Lovepon> ertesx: I'm curious about short circuiting and stuff.
17:39:28 <Lovepon> > (\s p -> let (h:_) = take s [1..] in s /= 0 && p h) 0 (== 1)
17:39:30 <lambdabot>  False
17:39:38 <Lovepon> > (\s p -> let (h:_) = take s [1..] in s /= 0 && p h) 1 (== 1)
17:39:39 <lambdabot>  True
17:39:58 <Lovepon> Because of constructs like that.
17:40:24 <ertesx> Lovepon: i think strictness is more relevant
17:40:58 <Lovepon> This reminds me, why is it _ * 0 = 0
17:41:04 <Lovepon> And why is it True && x = x
17:41:11 <Lovepon> Err
17:41:14 <Lovepon> False && _ = False
17:41:35 <ertesx> (&&) is strict; (True &&) is strict, but (False &&) is non-strict
17:41:49 <ertesx> (*) is strict in both arguments‚Ä¶  always
17:41:57 <ertesx> at least for all standard types
17:42:55 <Lovepon> >fix (*0)
17:43:04 <Lovepon> > fix (*0)
17:43:06 <lambdabot>  0
17:43:08 <Lovepon> ertesx: ^
17:43:20 <ertesx> huh?!
17:43:27 <ertesx> > undefined * 0
17:43:29 <lambdabot>  0
17:43:47 <dfeuer> ertesx, so what seems to happen (based on -ddump-simpl) is that the size argument gets *boxed* to pass to the strict constructor. I was thinking it would be better to eta-expand (\pr m sf -> Deep n pr m sf) to avoid boxing the size field. What do you think?
17:43:55 <ertesx> that must be a rewrite rule or something
17:44:17 <idris_elba> ertesx interesting
17:44:24 <idris_elba> haven't delved into that aspect of the language at all
17:44:41 <dfeuer> Lovepon, ertesx, the *0 thing is a GHC 10-only "feature". It's now been removed.
17:44:42 <Lovepon> > 0 * undefined
17:44:43 <lambdabot>  *Exception: Prelude.undefined
17:44:59 <Lovepon> dfeuer: Ah.
17:45:04 <dfeuer> ertesx, any thoughts about my question?
17:45:36 <dfeuer> er..
17:45:40 <dfeuer> I meant 7.10-only.
17:47:17 <ertesx> dfeuer: let's use a simpler example:  data Pos = Pos !Int !Int;  map (Pos 0)
17:47:35 <ertesx> dfeuer: are you suggesting to rewrite that to (map (\x -> Pos 0 x))?
17:47:48 <dfeuer> ertesx, yeah, exactly.
17:48:21 <ertesx> dfeuer: i'm pretty sure GHC will reduce it back
17:48:42 <idris_elba> how do i extract Object contents from an aeson Value ?
17:49:18 <idris_elba> I can pattern match, but i'm wondering if there's a function similar to "either" or "maybe"
17:49:23 <dfeuer> ertesx, well, I'm not certain of exactly that, but using deep' !n = \pr m sf -> Deep n pr m sf, GHC seems to do what I intend. The question is whether that's better or worse.
17:49:28 <idris_elba> i can use instead of defining a new function
17:50:11 <shanemikel> having trouble defining a default marshaler for c2hs
17:50:13 <dfeuer> idris_elba, yes, there is. Let me find it...
17:50:46 <idris_elba> hmm lens-aeson maybe I should be using this instead of extracting layers and layers of types to get at a value :(
17:50:55 <ertesx> dfeuer: then i wonder if your problem is actually related to forcing‚Ä¶  for example i've used this pattern sometimes:  f x = \y -> ...; where !z = ...
17:51:06 <dfeuer> idris_elba, you may want to look at withObject :: String -> (Object -> Parser a) -> Value -> Parser a 
17:51:40 <idris_elba> dfeuer i have to construct a parser? =P
17:52:19 <ertesx> dfeuer: in any case the main problem is that GHC can't really create a partial value, so it has to create a full-blown closure (or whatever it's called in GHC)
17:52:45 <dfeuer> idris_elba, that's what aeson is largely about. They're only "parsers" in a very loose sense though.
17:53:19 <idris_elba> dfeuer i feel like i'm using aeson wrong
17:53:28 <dfeuer> ertesx, right, but what I'm *imagining* is that a closure holding an *unboxed* Int will be a bit smaller than a closure holding a *boxed* one.
17:53:51 <idris_elba> i started off writing fromJSON toJSON instances, then realized for a lot of the clients i'm writing the data is way to hairy and complicated
17:54:02 <dfeuer> idris_elba, I don't really care for the design of aeson, TBH, but it is what it is and it's certainly the most popular and well-supported library for the job.
17:54:13 <ertesx> dfeuer: the box may disappear at a later stage, so i'm not sure
17:54:15 <idris_elba> switched to pulling Data.Maps of the data
17:54:41 <dfeuer> ertesx, going to STG or C-- or something? I find that stuff horribly hairy to read.
17:54:53 <idris_elba> but now with this map structure i'm traversing up and down this deep type nesting to pull values out
17:54:56 <idris_elba> and it's super klunky
17:55:35 <idris_elba> hm lens-aeson has 0 documentation. guess i won't be using that.
17:55:46 <idris_elba> oh wait nevermind yes it does
17:56:08 <ertesx> dfeuer: it is, but it could reveal that the box disappears
17:56:11 <dfeuer> idris_elba, that's another popular library.
17:56:36 <ertesx> dfeuer: if not, then your best bet is to delay the construction of the full data value to the consumption phase, if there is any
17:57:15 <idris_elba> maybe i should be using lenses... trying to stick with what i know though :(
17:57:19 <ertesx> dfeuer: like: calculate y in the unfold phase, create Pos 0 y in the fold phase
17:58:06 <ertesx> dfeuer: alternatively, if your algorithm allows it, don't use Seq
17:58:29 <ertesx> an unboxed vector may be faster, sometimes even when your algorithm complexity suggests otherwise
17:58:29 <dfeuer> ertesx, I'm currently co-maintaining the containers package, and the one primarily in charge of Seq. I'm inclined to eta expand unless there's some good reason not to. :-)
17:58:49 <ertesx> there is no good reason other than coding style =)
17:59:05 <dfeuer> Coding style is a relatively low priority.
17:59:20 <dfeuer> But if there's some efficiency problem with it that I'm not thinking about, that would be a concern.
17:59:33 <ertesx> if it helps, do it, perhaps with a comment why you did it
17:59:38 <ublubu> hello, all. how might i use a typeclass to do something like: (forall a. a -> t a) -> (x, y) -> (t x, t y) and similar for (x, y, z) -> (t x, t y, t z) etc?
17:59:46 <ertesx> dfeuer: there can be
17:59:47 <dfeuer> ertesx, said comment is already written :P
17:59:47 <shanemikel> http://lpaste.net/1997161197094305792 <- the SCM type ends up as Ptr ().. and c2hs says there's no default marshaling for Scm and SCM
17:59:56 <dfeuer> ertesx, example?
18:00:21 <ertesx> dfeuer: that's why i mentioned the pattern earlier:  f x = \y -> ...; where !z = ...
18:00:31 <ertesx> dfeuer: map (f 0)  -- benefits from sharing
18:00:39 <ertesx> map (\y -> f 0 y)  -- does not
18:00:52 * hackagebot turtle 1.2.7 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.2.7 (GabrielGonzalez)
18:01:13 <dfeuer> ertesx, can you expand your example slightly? I'm not seeing enough to get your point.
18:01:59 <dfeuer> Back later.
18:02:25 <shanemikel> everything was working before, and my in/out marshalling for Scm and SCM was just id.. but I didn't want it to be explicit for every function, and I wanted to change Scm (which was a Ptr ()), to a newtype wrapped version
18:02:43 <ertesx> dfeuer: f is a function of two arguments, where an expensive intermediate value depends only on the first argument
18:03:21 <ertesx> dfeuer: so you force it upon receiving the first argument and give it a name‚Ä¶  that allows it to be shared across the whole map
18:04:18 <ertesx> dfeuer: if you eta-expand here, then GHC no longer sees the opportunity to share
18:05:41 <dfeuer> ertesx, I don't see how that applies to the case where what I'm eta-expanding is a constructor.
18:06:46 <ertesx> dfeuer: if that's the only case, it shouldn't apply
18:07:30 <dfeuer> ertesx, I'm really *only* talking about eta-expanding constructors whose first arguments are small strict (thus unpacked) fields.
18:07:48 <dfeuer> Well,
18:07:57 <dfeuer> I guess what I'm doing isn't actually eta-expansion.
18:07:58 <dfeuer> Sorry.
18:08:11 <dfeuer> Although that would probably have the same effect.
18:08:18 <dfeuer> Whatever.
18:08:23 <dfeuer> Brain blip.
18:09:21 <ertesx> dfeuer: i'd just benchmark both cases at different sizes
18:10:25 <ertesx> in particular below and above the various CPU cache sizes
18:10:58 <dfeuer> ertesx, yeah, that would probably be best. Not sure how cache size comes into this particular one though.
18:15:02 <shanemikel> okay.. so the error I'm getting isn't very helpful.. something along the lines of "internal type error! something went wrong"
18:16:10 <dfeuer> shanemikel, that sounds bad.
18:18:35 <dfeuer> ertesx, to make things extra annoying, it looks like the current containers benchmark doesn't even exercise the relevant functions! Ugh!
18:18:42 <dfeuer> Bye for now; dinner time. Thanks!
18:33:19 <fizbin> man, there are times when I really wish Haskell had inheritance.
18:33:55 <fizbin> Which might be a clue that I'm factoring this wrong, so let me think about how to ask this...
18:37:52 <fizbin> So I've got this code that takes input data, chomps on it for a while, and produces some output data. Now, in addition to the input data it also takes a whole slew of parameters that tweak how it should do that conversion.
18:39:48 <fizbin> I expose this code through two different main methods: one that implements a command line utility (with a bunch of options), and one that implements a web service (it accepts a json dictionary, the contents of which look remarkably similar to the possible command-line options)
18:42:57 <fizbin> I have a routine in the one main that parses an array of strings into a ComputationConfig structure, and a routine in the other main that parses an incoming json dictionary into that same structure, and then my main code was of the type:  runProgram :: (Monad m) => ComputationConfig m -> m B.ByteString
18:45:03 <fizbin> But I've just added an option to ComputationConfig and modified "runProgram" so that if that (boolean) option is set it returns m (Map Foo Bar, B.ByteString). (Well, it returns that anyway, but if the option isn't set the first member of the tuple is M.empty)
18:46:24 <shanemikel> actually, doesn't look like I'm the only one with this problem https://github.com/haskell/c2hs
18:46:29 <fizbin> Now, in the command-line version I want to accept a flag that says "write the Foo->Bar map out to a file", but in the web service I'll just take a simple true/false on input, and add an extra key to the output if the option's given.
18:46:48 <ntnt> for error handling, is (1) either monad or (2) cont monad better? the former seems to "give the caller the choice of how to handle the error" whereas the latter seems to "give the thing which generates the error the choice of how to handle it"
18:48:02 <fizbin> I find myself wanting to be able to subtype ComputationConfig and have different implementations in the two mains. (the way I could in an OO language)
18:48:45 <hpc> ntnt: "it depends", with the additional elaboration of what you just said ;)
18:49:05 <ntnt> hpc: I have seen people use (1) the either monad quite a lot
18:49:15 <ntnt> I haven't seen any of (2) -- the cont monad, in practice, for error handling
18:49:26 <fizbin> Because otherwise, I need to add to common code stuff that isn't really common (the web service doesn't need a config slot for "place to output the Foo->Bar map"), or I need to repeat a ton of boilerplate in both places if I make ComputationConfig a class.
18:49:44 <hpc> i like Either a lot for not being especially difficult to reason about
18:50:00 <hpc> you have seen CPS in error-handling in practice i bet, just not explicitly Cont-based
18:50:03 <hpc> :t bracket
18:50:04 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:50:25 <hpc> :t bracket undefined undefined -- that smells a lot like Cont
18:50:27 <lambdabot> (a -> IO c) -> IO c
18:51:09 <hpc> ntnt: i suggest going with what feels right, and if it stops feeling right try the other
18:51:17 <hpc> both approaches are valid and can be quite powerful
18:51:38 <ntnt> hpc: can you suggest a poject that uses the ContT way? I'm curious how it looks like in practice
18:51:47 <ntnt> I'm a bit ehsistant, as it's like using a chainsaw to cut a piece of paper
18:52:10 <hpc> not off the top of my head
18:52:11 <hpc> hmm
18:52:40 <ntnt> yeah, so no one uses it in practice for some reason :-/
18:53:12 <hpc> i don't really see Either that much either (hehe), at least overtly
18:53:21 <ntnt> it's used in Parsec
18:53:29 <ntnt> either String SucessfulParse
18:54:02 <hpc> that's at the API level
18:54:08 <hpc> internally it uses CPS - http://hackage.haskell.org/package/parsec-3.1.9/docs/src/Text-Parsec-Prim.html#ParsecT
18:54:31 <ntnt> ooh
18:54:33 <hpc> 4 continuations, consumed ok, consumed err, empty ok, empty err
18:54:52 <hpc> we both seemed to have had the same idea, i was hoogling it when you mentioned it
18:54:56 <ntnt> no wonder why parsec was (1) so hard to learn and (2) seemed so magical after learning it
18:55:56 <hpc> there might be a more penetrable example of it out there somewhere, but if you know parsec it shouldn't be so bad
18:56:29 <fizbin> What's the name of the syntax I'm using when I say: variableOfRecordType { _oneFieldName = newValue, _anotherField = otherNewVal }    ?
18:56:38 <hpc> it also takes a State action for some reason
18:56:49 <fizbin> (I'm trying to google for it, and can't get anything)
18:57:00 <hpc> oh right, context sensitive parsers
18:57:11 <ntnt> fizbin: record update
18:57:43 <hpc> yeah
18:58:29 <hpc> when you're doing foo {bar = baz}, you're denoting a value with the same constructor and fields as foo, except for bar which has been assigned the value of baz
18:59:21 <hpc> you frequently find this used in the form of defaultOptions {whatsahoozle = True, reticulateSplines = False}
18:59:51 <shanemikel> what is CPS?
18:59:53 <fizbin> ntnt: That gets me more, thanks. But I still can't find an actual formal definition of that syntax. The search results are all clogged with people answering near-identical stack overflow questions.
19:00:00 <hpc> CPS is continuation passing style
19:00:20 <hpc> it's late here but the chapter on the wikibook shows how it works
19:00:23 <hpc> @where wikibook
19:00:23 <lambdabot> http://en.wikibooks.org/wiki/Haskell
19:00:26 <fizbin> (And blog posts complaining about different aspects of Haskell's record syntax)
19:00:43 <shanemikel> that sounds scary
19:00:58 <shanemikel> continuations are already scary to me... in haskell.. wow
19:01:02 <ntnt> fizbin: is https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#traditional-record-syntax what you want?
19:01:04 <hpc> it's a bit scary, but very powerful and fun to get your head wrapped around
19:01:31 <ntnt> "haskell record update" also gave me a bunch of SO results, so I googled "ghc language spec haskell record update"
19:01:33 <hpc> shanemikel: the most basic example of CPS is flip ($)
19:01:41 <hpc> :t ($ False)
19:01:42 <lambdabot> (Bool -> b) -> b
19:02:14 <hpc> it's basically the same as just writing False, but you're yielding control of the False to whatever is going to end up using it
19:02:16 <shanemikel> yeah, I've used that
19:02:35 <fizbin> ntnt: That's closer, but the entirety of it is one line. I want to know when I use an update expression, how is it getting parsed and typed?
19:02:38 <hpc> then you're well on your way
19:03:03 <hpc> read the wikibook, and it's a bit dense so you'll need to keep ghci open to follow along
19:04:01 <ntnt> hpc: which wiki book is this? I want to take a gander too
19:04:07 <shanemikel> thanks a lot for this. it will probably help me implement the bindings I'm working on (to a c library that implements continuations and exceptions)
19:04:08 <hpc> @where wikibook
19:04:08 <lambdabot> http://en.wikibooks.org/wiki/Haskell
19:04:28 <shanemikel> just in time
19:04:40 <hpc> and now i need to be off
19:04:42 <ntnt> hpc: nice, thanks!
19:04:48 <ntnt> hpc: enjoyed our discussion on either vs continuation / parsec
19:04:55 <hpc> ta
19:05:02 <fizbin> Because it looks like the {} becomes some sort of RecordType->RecordType function, that is then applied to the expression that preceded it. This is so out of the ordinary Haskell flow that I want to know what the deal is.
19:06:25 <geekosaur> it's a special case
19:07:01 <geekosaur> it's not first class, it's not quite in line with the rest of the language, and this leads to shortcomings that in turn led to the development of lens libraries (not just ekmett's lens, but earlier things like fclabels)
19:08:05 <leftylink> let's say I have two  a -> Bool functions f1 and f2, and now I would like to have a function that is `\x -> f1 x && f2 x`. Would you say that this is the idiomatic way to do it? it is certainly the most straightforward. It's been pointed out to me that I can use `liftA2 (&&) f1 f2` as well
19:09:16 <leftylink> the one using liftA2 was not as clear to me, I had to think for a bit to figure out that `a ->` was the applicative
19:09:48 <fizbin> geekosaur: Is record update part of Haskell 98?
19:10:00 <geekosaur> yes
19:10:51 <fizbin> Indeed. Just found the spot in the 98 report.
19:10:53 <geekosaur> I did not say it was an extension. I said it was a special case, meaning that it doesn;t behave like other things in Haskell (for example, you;d expect to be able to use a record update without a referent as if it were a lambda, but you can't)
19:12:16 <fizbin> Right.
19:13:53 <nitrix> Is there a page that lists the difference between 98 and 10 ?
19:15:09 <shanemikel> leftylink: whatever floats your boat.. I prefer the applicative syntax `(&&) <$> f1 <*> f2`, and using it will make it more comfortable looking to you
19:16:27 <shanemikel> but they both take up about the same amount of space, and the lambda is plain and simple
19:21:36 <idris_elba> so this aeson value extraction code is super janky and unsafe http://lpaste.net/161356
19:21:40 <idris_elba> how can i fix it?
19:22:20 <idris_elba> i know i'm abusing let...
19:22:57 <idris_elba> but it would be super verbose if i had to write total pattern matched function for each layer of extraction
19:23:47 <shanemikel> why don't you use a single let, and indent the following bindings?
19:24:12 <idris_elba> shanemikel i could compress those lets into a bunch of nested parenthesis
19:24:31 <idris_elba> but it would have the same problems
19:24:36 <idris_elba> just slightly more concise
19:24:44 <shanemikel> why don't you write a function that takes result
19:24:49 <shanemikel> a pure function
19:25:28 <idris_elba> let me see if i understand
19:25:36 <idris_elba> and then for any other result just lump that into _
19:25:37 <idris_elba> ?
19:26:06 <nitrix> shanemikel: Just pointing out "why don't you" might be the wrong approach considering this person is also on #haskell-beginners.
19:26:25 <shanemikel> idris_elba: http://lpaste.net/7272450964475346944
19:27:07 <idris_elba> how does that make it a pure function?
19:27:23 <shanemikel> that was an example of multiple lets indented
19:27:39 <nitrix> All functions in Haskell are pure, by design.
19:28:41 <idris_elba> shanemikel sure that cleans up the syntax
19:28:51 <idris_elba> but the implicit partial functions introduced by the lets are still a problem
19:29:36 <idris_elba> shanemikel claned it up now http://lpaste.net/161356
19:29:39 <shanemikel> http://lpaste.net/6708027356235169792
19:30:54 <Clint> idris_elba: why don't you do it in a FromJSON instance
19:31:10 <idris_elba> the problem isn't really the multiple steps though (i know they could go into a where), it's the partial functions induced by the let bindings
19:31:28 <nitrix> maybe undefined id... V.head... maybe Null id, ew.
19:31:36 <nitrix> idris_elba: Have you learned functors yet?
19:32:09 <idris_elba> Clint there's many more fields. just because i don't happen to use them here i may need them elsewhere. it would be like hundreds of lines for fromJSON
19:32:48 <shanemikel> it seems like most of that should be in a Maybe monad, and you can handle the single Just/Nothing result in your io monad with a case block
19:32:50 <idris_elba> nitrix yeah although i'm i'm not sure exactly how about applying them here
19:33:22 <idris_elba> nitrix i realize it's "ew" that's why i'm asking for advice...
19:33:37 <shanemikel> idris_elba: move those lines into the maybe monad
19:34:22 <nitrix> idris_elba: Look at fromMaybe
19:34:34 <Cale> Yeah, this is pretty much exactly what Maybe's monad instance is for
19:34:39 <nitrix> idris_elba: Coincidally, these could all be the maybe monad.
19:34:43 <montanonic> idris_elba: the lines in that last lpast of yours are off by one
19:35:41 <shanemikel> You should do that for now, and later use a lens-like interface to access objects in deeply nested regular structures
19:35:50 <montanonic> oh, wait
19:35:52 <shanemikel> after you're more comfortable with haskell
19:35:55 <montanonic> idris_elba: I'm mistaken, you're fine
19:36:55 <idris_elba> trying this out
19:37:06 <idris_elba> is there a built-in function defined as \_ -> Nothing
19:37:33 <MichaelBurge> idris_elba: const Nothing
19:38:33 <idris_elba> what about (\x -> Just x) ?
19:38:42 <nitrix> Just
19:38:44 <MichaelBurge> idris_elba: Just
19:38:48 <shanemikel> :)
19:39:32 <MichaelBurge> > map Just [1,2,3,4]
19:39:34 <lambdabot>  [Just 1,Just 2,Just 3,Just 4]
19:40:13 <shanemikel> > map (const Nothing) [1,2,3]
19:40:14 <lambdabot>  [Nothing,Nothing,Nothing]
19:40:29 <nitrix> > sequence $ map Just [1,2,3,4]
19:40:31 <lambdabot>  Just [1,2,3,4]
19:40:55 <nitrix> idris_elba: By the way, a cool tool if you have similar questions:
19:41:00 <nitrix> @pl \x -> Nothing
19:41:01 <lambdabot> const Nothing
19:41:05 <nitrix> @pl \x -> Just x
19:41:05 <lambdabot> Just
19:41:21 <idris_elba> nitrix woah cool :)
19:41:34 <idris_elba> ok trying maybe wrapping
19:41:57 <MichaelBurge> @pl f a b c d = f d $ c b a
19:41:57 <lambdabot> f = fix ((. flip (flip . flip id)) . (.) . (.) . flip)
19:41:57 <idris_elba> in the second layer, do I use fmap? that ends up with layers of maybes..
19:42:26 <nitrix> MichaelBurge: Withe the `fix`, that's very pretty.
19:42:41 <nitrix> :P
19:43:00 <idris_elba> so at the top i ahve: let vals = either (\_ -> M.empty) id result
19:43:16 <EvanR> what, pl will use fix? groovy
19:43:58 <idris_elba> ah wait i think this works so the second layer is unwrapped with
19:44:08 <idris_elba> let resp             = (maybe Nothing id (M.lookup "response" <$> vals))
19:44:11 <idris_elba> is that right?
19:45:14 <MichaelBurge> @pf resp vals = (maybe Nothing id (Data.Map.lookup "response" <$> vals))
19:45:14 <lambdabot> Maybe you meant: pl bf
19:45:18 <MichaelBurge> @pl resp vals = (maybe Nothing id (Data.Map.lookup "response" <$> vals))
19:45:19 <lambdabot> resp = maybe Nothing id . (Data.Map.lookup "response" <$>)
19:46:17 <MichaelBurge> idris_elba: Do you have a "Maybe (Maybe a)"?
19:46:31 <idris_elba> MichaelBurge not when I write it this way
19:46:43 <idris_elba> because the "maybe" function unwraps it
19:47:13 <MichaelBurge> Oh wait, in the Maybe monad, is maybe == join?
19:47:15 <idris_elba> so at each layer i unwrap and repackage so it's always one layer of Maybe
19:47:26 <idris_elba> I don't know how to use join (or have forgotten) ...
19:47:30 <nitrix> MichaelBurge: Almost.
19:47:34 <idris_elba> i still have a feeling i'm doing this the hard way
19:48:00 <nitrix> idris_elba: I have a feeling you skipped a lot of steps before getting into this ;)
19:48:05 <MichaelBurge> idris_elba: You're writing lots of Aeson instances right?
19:48:27 <idris_elba> MichaelBurge well I started off writing Aeson instances
19:48:55 <idris_elba> but the json structure is too large and unwieldy, so i'm leaving it as Maps
19:49:21 <idris_elba> but now to get some data... i'm unwrapping the Value s to get to a piece of information
19:49:24 <idris_elba> that's where i'm at...
19:49:37 <EvanR> you need aeson lenses
19:49:41 <idris_elba> i think i'm close to getting this working with Maybe
19:49:45 <MichaelBurge> idris_elba: Chances are your JSON has lots of little nested types inside of it, so you can write To/FromJSON instances for the smaller types and build up the bigger ones
19:49:46 <EvanR> https://hackage.haskell.org/package/lens-aeson
19:49:59 <EvanR> maybe...
19:50:12 <nitrix> Are forkIO green threads?
19:50:42 <EvanR> sure
19:50:43 <nitrix> Is there a scheduler in the runtime system for them or will the host want to die with a thousand of them?
19:50:47 <idris_elba> EvanR i guessed so, but i'm trying to do this with things reasonably with things i have knowledge of. which goes up to basic Functor/Appicative/Monads...
19:50:47 <montanonic> Does anyone know what date format this is: "{\"dateTime\": \"2016-04-23T09:00:00-07:00\" }"
19:51:07 <nitrix> EvanR: I guess my question is if they're as cheap as Go's goroutines.
19:51:11 <MichaelBurge> montanonic: It looks like a timestamp with a time zone offset
19:51:12 <EvanR> idris_elba: you could write your own lens-like thing
19:51:19 <montanonic> It's not exactly UTCTime, so I'm trying to figure out what format it is so I can write a conversion function between them
19:51:32 <EvanR> nitrix: ive heard anecdotes that they are cheaper than erlang processes
19:51:41 <nitrix> EvanR: Or Erlang's threads..
19:51:44 <nitrix> Oh there you go :P
19:51:48 <nitrix> Thanks.
19:52:05 <EvanR> im not sure how it compares with goroutines, or what goroutines are
19:52:05 <idris_elba> EvanR i don't know where to start. i can use lens syntax as an end user and i understand what they're for, but i really don't understand them.
19:52:17 <montanonic> MichaelBurge: okay, thanks, I'll look into how to convert the offset into the UTC standard
19:52:17 <EvanR> idris_elba: are you trying to get or set something?
19:52:48 <idris_elba> EvanR get
19:52:53 <EvanR> then it should be easy
19:53:04 <EvanR> (setting should also be easy but its different)
19:53:43 <EvanR> if you have a bunch of Value -> Maybe Value then you can compose them directly with >=>
19:53:55 <EvanR> :t (>=>)
19:53:57 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:54:14 <Cale> idris_elba: pls make more episodes of Luther
19:54:34 <EvanR> like like
19:54:34 * Clint claps.
19:55:10 <EvanR> so like... (field "foo" >=> index 13 >=> field "bar" >=> field "blub") value
19:55:22 <EvanR> would be Nothing or Just the value at value.foo[13].bar.blub
19:55:48 <EvanR> but i may have this backwards
19:56:32 <ggVGc> main :: Nothing
19:56:35 <ggVGc> my program is done
19:56:37 <EvanR> the kicker here is that Maybe's monad instance does shortcircuiting to Nothing on the first Nothing, if any
19:56:45 <EvanR> Nothing isnt a type!
19:56:51 <EvanR> unless DataKinds
19:56:53 <ggVGc> EvanR: I'm using TH
19:56:55 <ggVGc> maybe
19:57:11 <ggVGc> but okay, main = Nothing
19:57:19 <shanemikel> yeah, idris_elba you should probably find a book like haskellbook, lyah, or something and read about maybe, either, and monads.. don't forget you can use syntactic constructs like case, and break your procedures down into smaller pieces.. Really, Maybe and Either are meant to be grouped together for implicit error handling in monadic blocks.  You have to deal with them at some point, but If you CAN organize things in a way that
19:57:19 <shanemikel> it makes sense, group them together in a monad.. when you must deal with them, case is pretty readable http://lpaste.net/161356
19:58:06 <ggVGc> Maybe is almost the only monad instance I use
19:58:21 <ggVGc> exactly for chaining computations
19:58:33 <ggVGc> in the way EvanR showed
19:58:42 <idris_elba> shanemikel i've read ~20 chapters of haskellbook (up to around monads). but haven't had much practice beyond exercises
19:59:11 <shanemikel> well, you should keep pushing and read monads, you won't be sorry
19:59:12 <idris_elba> Cale next season i hunt down purescript
20:00:07 <Cale> lol
20:00:54 <idris_elba> shanemikel i have read monads. i need more practice applying it though. i'm up to the traversals chapter.
20:02:31 <montanonic> What's GHC telling me to do here? http://lpaste.net/7189657468320874496 . ZonedTime is from the `time` package, but it doesn't have an instance for equality
20:02:43 <idris_elba> i'm working out this maybe chaining here. lots of effort for pulling out one value (would take 20 seconds in a dynamically typed language but i guess that's how it is)...
20:03:10 <montanonic> idris_elba: the "pulling out the value part" is error handling
20:03:21 <montanonic> so yes, it takes more effort, because it forces you to do error handling
20:03:54 <ggVGc> idris_elba: yeah but in the dynamic language you now have no idea if you're handling all the failure cases
20:04:01 <ggVGc> or even if you have a typo
20:04:40 <shanemikel> yeah, exceptions are the same way here, but luckily they're not used too much
20:05:28 <hackrilege> why is [[]] kind *->*->*->* ??
20:05:29 <hackrilege> http://lpaste.net/161360
20:05:41 <hackrilege> i cant get my zipper thing to work...
20:05:44 <montanonic> anytime a value *may* be empty, fail, or whatever thing/action that would semantically correspond to "Nothing", then you have to tell Haskell how to resolve that case, no matter how minute the chance. 
20:05:50 <ggVGc> idris_elba: if I have foo.bar.baz somewhere in my code, and at the time I write it bar always exists. But then at some point I change the foo value to not always having a bar. And now there si a failure case in foo.bar.baz that you'ere not handling unless you remembered to go back and put in a null check there, ad all of a sudden it's not a clean "foo.bar.baz" anymore, but more like, x = foo.bar; if(x){x.ba
20:05:52 <Cale> :k [[]]
20:05:54 <lambdabot>     Expecting one more argument to ‚Äò[]‚Äô
20:05:54 <lambdabot>     Expected kind ‚Äò*‚Äô, but ‚Äò[]‚Äô has kind ‚Äò* -> *‚Äô
20:05:54 <montanonic> idris_elba: if you don't want to handle errors though, just use http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:fromJust
20:05:54 <lambdabot>     In a type in a GHCi command: [[]]
20:05:56 <ggVGc> z}
20:06:07 <Cale> hackrilege: [[]] isn't even a type
20:06:23 <hackrilege> id expect to be able to apply it to a as i do []
20:06:31 <hackrilege> to 'a'
20:06:46 <shanemikel> fromJust will crash your program in the event of a Nothing value, because in the absense of dependent types it can't be typed to disallow Nothing
20:08:05 <idris_elba> there must be a way to do this without explicit re-wrapping at each step though
20:08:06 <idris_elba> hm
20:08:25 <hackrilege> List a = Nil | Cons a (List a). List List = Nil | Cons a (List (Nil | Cons a (List a)))
20:08:33 <hackrilege> ... ?
20:08:41 <Cale> what? That's... not Haskell syntax
20:09:19 <shanemikel> re-wrapping?
20:09:22 <hackrilege> type List2 a = List2 [[a]]
20:09:29 <Cale> But if we have  data List a = Nil | Cons a (List a)
20:09:33 <Cale> then List List is a kind error
20:09:38 <Cale> Because List :: * -> *
20:09:49 <Cale> and so can't be an argument to itself
20:10:13 <hackrilege> so how to compose kinds st :k List <?> List = * -> *
20:10:48 <hackrilege> data Compose a b c = Compose a (b c) ??
20:11:06 <hackrilege> type List2 ?= Compose List List
20:12:11 <hackrilege> is that right?
20:13:17 <hackrilege> i dont even know if what im trying to do is ill posed
20:13:37 <EvanR> idris_elba: the way i showed doesnt have explicit rewrapping
20:13:38 <Cale> Yeah, you can use the Compose newtype
20:14:08 <hackrilege> thanks
20:14:11 <idris_elba> EvanR aeson lenses?
20:14:16 <EvanR> no
20:14:39 <Cale> hackrilege: It's in Data.Functor.Compose
20:14:51 <hackrilege> its a one liner...
20:14:52 <EvanR> to "get" all you need to do is compose getters of the form Value -> Maybe Value
20:15:32 <EvanR> in this case the compose operator is >=> because you want to short circuit using Maybe
20:15:42 <Cale> https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html
20:15:47 <Cale> hackrilege: all the instances aren't...
20:16:23 <shanemikel> idris_elba:   let (Object respObj) = resp
20:16:23 <shanemikel>   let (Array aVal)     = maybe undefined id $ H.lookup "docs" respObj
20:16:24 <shanemikel>   let (Object aHead)   = V.head aVal
20:16:24 <shanemikel>   let (Array gf)       = maybe "None" id $ H.lookup "gene_family" aHead
20:16:24 <shanemikel>   let (String s)       = V.head gf
20:16:25 <hackrilege> how can you have instances of a datatype?
20:16:28 <shanemikel> these lines are key
20:16:35 <idris_elba> does x:xs syntax not work with OverLoadedLists turned on?
20:17:01 <c_wraith> OverloadedLists only applies to [foo,bar] syntax
20:17:16 <idris_elba> shanemikel what do you mean those lines are key? they're the ones i'm fixing into Maybe's
20:17:36 <idris_elba> c_wraith thanks, no wonder i'm getting type errors... is there a substitute for x:xs that works with Vectors?
20:18:06 <hackrilege> oh lol it instantiates some classes
20:18:31 <shanemikel> it should be obvious that with some tools you can traverse structures like this with a syntax like oop accessors .. i.e.: resp["docs"][0]["gene_family"][0]
20:18:33 <idris_elba> i need something i can pattern match for a case operation
20:19:11 <shanemikel> and if you wanted to write that all on one line you would usually put it in a try block that catches "Index out of bounds" errors
20:19:15 <EvanR> idris_elba: you can make a view type for vectors 
20:19:26 <idris_elba> shanemikel yeah but how? are lenses the only way? exceptions?
20:19:49 <EvanR> which is Empty for empty vectors, and Cons x v for non empty
20:20:02 <EvanR> then you can pattern match
20:20:18 <c_wraith> view pattern + pattern synonym.
20:20:23 <c_wraith> Don't even need your own type, then
20:20:27 <shanemikel> idris_elba: afaik, aeson has it's own lenses for json data
20:20:37 <hackrilege> argh now it wants me to write a Stack function for Stack f => Compose f f
20:20:44 <EvanR> oh nice
20:20:45 <hackrilege> Stack instance*
20:20:55 <shanemikel> though I haven't used aeson.. also the `lens` library has a more generic implementation that you can automatically derive for your own haskell data types
20:21:23 <EvanR> shanemikel: i think idris_elba is trying to use Value as-is and not do any custom data types
20:21:27 <idris_elba> shanemikel being beginner-ish i'm trying to stay within things i somewhat understand or can at least reason about... which is up to about monads
20:21:37 <hackrilege> Cale,EvanR, im stuck i cant understand this step.
20:21:46 <EvanR> shanemikel: also i dont think aeson comes with lenses?
20:21:54 <idris_elba> ther'es aeson-lens
20:21:57 <c_wraith> idris_elba: nothing in lens is more complex than Traversable
20:22:10 <c_wraith> At least in terms of using it.
20:22:12 <idris_elba> c_wraith no way
20:22:31 <idris_elba> there's like how many operators?
20:22:49 <c_wraith> The operators follow like 4 patterns.  Learn 4 things, and you know them all.
20:23:07 <idris_elba> if lens is the only way to do this that doesn't suck, i'll try it. but i'm trying to get something done using things i know
20:23:17 <EvanR> idris_elba: its not the only way... 
20:23:20 <EvanR> as ive been saying
20:23:54 <idris_elba> i'm not familiar with view types yet, is that some generalization of pattern matching methods like x:xs ?
20:23:54 <EvanR> Maybe monads is kind of important for writing non horrible haskell code, learn that 
20:23:55 <shanemikel> idris_elba: well it just so happens that dealing json data isn't very fun without help
20:24:15 <shanemikel> so, you can do it, but it is gonna feel verbose and annoying
20:25:00 <ertesx> idris_elba: is the tl;dr that you're trying to handle aeson's Value type without going mad?
20:25:10 <idris_elba> shanemikel good to know. unfortunately it's a really useful thing to do. the problem as a beginner is i don't know what i don't know, which is why i'm asking
20:25:46 <EvanR> we listed at least 2 things that you dont know, so at least you now know more things you dont know
20:25:47 <idris_elba> ertesx yeah. i think i have enough info to do a sequence of maybe checks. not pretty but at least i'm not doing partial function let bindings
20:26:19 <idris_elba> i'm not sure if json values are supposed to be a pita or i'm just missing something obvious
20:26:30 <EvanR> am i on ignore?
20:26:54 <EvanR> > Just 3 >> Just 'c' >> Just False
20:26:55 <Clint> EvanR: yes, i have you on ignore
20:26:56 <lambdabot>  Just False
20:27:03 <EvanR> > Just 3 >> Nothing >> Just False
20:27:05 <lambdabot>  Nothing
20:27:11 <hackrilege> im on ignore...
20:27:20 <EvanR> sequence of maybe checks
20:27:31 <nitrix> EvanR: How would you have multiple forkIO print to the main OS thread's stdout?
20:27:38 <idris_elba> EvanR thanks i might have missed it, been switching between code and irc
20:27:44 <nitrix> EvanR: And wait for those forkIO + the printing to finish before terminating?
20:28:00 <hackrilege> if anyone could help me get my head round this problem id be stoaked! http://lpaste.net/161360
20:28:06 <ertesx> idris_elba: solution: don't‚Ä¶  Value is the ultimate in dynamic typing, and you're basically doing what you hate PHP for, for doing it implicitly‚Ä¶  go away from Value as soon as possible, go back to Value as late as possible
20:28:09 <EvanR> nitrix: a simple plan is to write instead to a Chan and some thread is in charge of printing the messages without interleaving
20:28:22 <nitrix> EvanR: I've do that so far.
20:28:24 <nitrix> *done
20:28:40 <hackrilege> its at the point where ghc is complaining so hard i dont know what i have done wrong any more but i know its really fundamental
20:28:40 <nitrix> EvanR: The problem is that the printer :: IO (), runs inside a `forever`.
20:28:43 <EvanR> nitrix: to wait for a thread to finish, you can rig of up some nice MVars or use the async package
20:28:46 <nitrix> EvanR: I'm not sure how it'd terminate.
20:28:54 <nitrix> EvanR: I'm using async :)
20:28:57 <EvanR> it doesnt need to terminate
20:29:08 <nitrix> EvanR: How do you know you printed everything?
20:29:19 <EvanR> huh
20:29:28 <EvanR> read from the chan forever, if nothing else needs to be printed, it blocks
20:29:31 <nitrix> If all the other threads are terminated AND the printer's mvar is empty?
20:29:34 <idris_elba> ertesx well, there's a huge number of fields in the data though, so it seems to lend itself to some sort of dynamic-ish map. otherwise i'm going to spend my time writing 400 line record type definitions and fromJSON parsers
20:29:45 <nitrix> EvanR: It's okay that it blocks, it's not what I'm asking.
20:29:53 <EvanR> nitrix: if the main thread is dead, the program is over
20:30:00 <ertesx> idris_elba: are the types of the fields static?
20:30:13 <nitrix> EvanR: I want to print in the main thread.
20:30:15 <EvanR> idris_elba: or just use the Value type
20:30:23 <nitrix> EvanR: To avoid issues with GHCI's repl.
20:30:34 <EvanR> that sucks
20:30:52 <hackrilege> ah well im here all night if you get bored enough to figure out what im doing wrong here
20:31:08 <idris_elba> ertesx approximately static but no guarantees it's a servant json client
20:31:12 <EvanR> ghci strikes again
20:33:21 <nitrix> I'll figure it out myself I guess.
20:33:24 <nitrix> EvanR: Thanks.
20:33:47 <ertesx> idris_elba: are you actually using all those fields or just passing them on to something else?
20:33:51 <hackrilege> i need to take the square root of [[]]
20:33:56 <hackrilege> :(
20:34:12 <shanemikel> okay, so this is how you do it with the maybe monad
20:34:14 <shanemikel> http://lpaste.net/161356
20:34:24 <EvanR> hackrilege: type error
20:34:51 <ertesx> instance Floating [[]] ‚Ä¶
20:34:54 <hackrilege> unCompose $ Compose [] []
20:35:06 <shanemikel> and any of the lines in processRes that result in Nothing, make it so no further lines are evaluated and the whole procedure returns Nothing, otherwise return will put the actual value in a Just
20:35:24 <hackrilege> im sooooo stuck!
20:35:29 <idris_elba> ertesx haven't settled on the interface yet, but the use case is that i will want to extend things over time to extract fields i might not be using now
20:35:58 <idris_elba> shanemikel thank you! i'm going to try to see if i can figure this out in the next few mins before i check your solution
20:35:59 <shanemikel> actually, that should have been `print $ processRes res`
20:36:12 <idris_elba> i'm a bit stuck pattern matching x:xs for a Vector atm
20:36:15 <hackrilege> data GridZipper (Compose s1 s2) a = GridZipper (Zipper s1 (Zipper s2 a))
20:36:16 <ertesx> idris_elba: i'm asking because there is no need for your type to be exhaustive‚Ä¶  you could as well get the fields you need and just keep the remaining fields in a reduced Value
20:36:22 <EvanR> print (processRes res) 
20:36:47 <idris_elba> and i haven't learned the view type approach everyone is referencing
20:36:50 <ertesx> idris_elba: alternatively you can write a smaller type and a traversal from Value to it
20:37:39 <EvanR> idris_elba: can you go ahead and learn one of these things then?
20:37:41 <shanemikel> and you should get in the habit of writing type annotations for your monadic procedures
20:38:01 <EvanR> answering every answer with "ok but i dont know that" is not productive
20:38:09 <idris_elba> ertesx i could probably write a partial fromJSON instance i think. even then the nesting with layers of arrays and values and arrays and values is kind of messy.
20:38:43 <EvanR> nesting is not a problem
20:39:00 <hackrilege> it is for me!
20:39:01 <ertesx> idris_elba: start by writing a type that represents the information that you are going to process
20:39:27 <ertesx> idris_elba: that's the minimum, if you want to take the principled approach
20:39:31 <idris_elba> EvanR believe me I'm trying. every bit of haskell productivity up to now has involve going way deeper than intended. last time I wanted to do some math and plotting and ended up learning how to connect a C FFI backend to a Spock plotting interface frontend.
20:39:38 <shanemikel> one day, you'll be using fancy tricks to automatically generate data types and json related instances and lenses/traversals all from a json spec
20:39:50 <shanemikel> automagically
20:40:55 <shanemikel> err.. json schema
20:41:07 <ertesx> idris_elba: that's a symptom of overengineering‚Ä¶  one reason why we use haskell is that refactoring is easy, so there is no reason to be afraid of evolution
20:41:14 <ertesx> idris_elba: so start with a type
20:41:19 <idris_elba> EvanR i'll eventually try to get to all this, and like i said if lenses or whatever are the _only_ solution i will use it. but for the sake of making progress i need to make some attempt to focus
20:41:45 <shanemikel> idris_elba: did you read my paste yet using maybe monad?
20:42:16 <EvanR> idris_elba: its not the only solution </repeat>
20:42:25 <idris_elba> shanemikel not yet, i need to stop chatting on irc for a few mins and work on my code. then i'll have a look
20:42:53 <shanemikel> it actually uses your code, not  a made up thing with made-up names
20:43:12 <ertesx> idris_elba: let me tell you the secret of tripling your productivity
20:43:18 <ertesx> idris_elba: /part #haskell
20:43:20 <ertesx> ;)
20:44:49 <Zemyla> @remember ertesx <ertesx> idris_elba: let me tell you the secret of tripling your productivity <ertesx> idris_elba: /part #haskell
20:44:49 <lambdabot> Good to know.
20:45:22 <juanca_> Hi people, does anyone knows id it is worth to transform a regular haskell list [] to Data.Vector?, i mean because of the time it'd take
20:45:55 <idris_elba> shanemikel woah this is way different from the solution i was writing up. clearly i have not internalized the essence of continuation passing style...
20:46:22 <idris_elba> shanemikel i was doing something like:
20:46:22 <Zemyla> juanca_: First, is the list finite or infinite?
20:46:25 <idris_elba> let vals             = either (const Nothing) Just result
20:46:29 <idris_elba> let resp             = maybe Nothing id (M.lookup "response" <$> vals)
20:46:45 <idris_elba> which works, but is not nearly as clean...
20:46:48 <juanca_> Zemyla: finite and around 5000 bytestring elements
20:47:19 <Zemyla> Do you know the length of the list ahead of time?
20:47:40 <idris_elba> now let me check though
20:47:56 <EvanR> maybe Nothing id ?
20:47:58 <shanemikel> that is not continuation passing.. it's plain old pattern matching + maybe monad
20:48:18 <shanemikel> the continuation stuff is much more sophisticated
20:48:47 <idris_elba> do those pattern matched <- not lead to partial functions?
20:48:55 <idris_elba> let me see what happens...
20:49:19 <shanemikel> idris_elba: like I said, in the maybe monad, handling of Nothing is implicit
20:49:25 <shanemikel> read up on it
20:49:27 <Zemyla> juanca_: You are generally going to want to have it be a vector.
20:49:28 <ertesx> idris_elba: (do x <- mx; y x) = maybe Nothing y mx
20:50:57 <shanemikel> idris_elba: they don't lead to partial functions so long as you know your (Something a) <- getSomething can only be Just (Something a) or Nothing
20:53:05 <juanca_> Zemyla: will it be justified to pend the memory and resources as strictly as the Vector would do
20:53:13 <idris_elba> shanemikel ok i did not get that. need to re-read the monad chapter. there's a type error here with H.lookup "gene family" though
20:53:33 <Zemyla> juanca_: Are you going to have all of them in memory at once?
20:53:49 <juanca_> Zemyla: indeed
20:53:57 <Zemyla> Then it's worth it.
20:54:16 <ertesx> idris_elba: the Maybe monad is just implicit pattern-matching with Nothing short-circuiting
20:54:29 <ertesx> > do x <- Just 5; y <- Just 7; pure (x + y)
20:54:30 <lambdabot>  Just 12
20:54:34 <ertesx> > do x <- Just 5; y <- Nothing; pure (x + y)
20:54:36 <lambdabot>  Nothing
20:54:38 <shanemikel> okay, well you're gonna have to sort that out.
20:54:45 <juanca_> Zemyla: do you have any preference about the vector flavours the data.vector offers?
20:55:16 <idris_elba> ertesx in that context it's obvious
20:55:30 <ertesx> juanca_: best: Unboxed, second best: Storable, worst: Vector, generic (for abstractions): Generic
20:55:47 <ertesx> juanca_: use the best possible
20:55:48 <idris_elba> ertesx i wasn't as sure what would happen in these cases with these non-numerical types
20:55:58 <idris_elba> like: (Array arr) <- H.lookup "docs" res
20:56:03 <shanemikel> not important for you right now, but if you want more type safety (to guarantee that "docs" is an array, for example) you need to encode the expected json structure as a haskell datatype, which, unless it's a regular recursive structure, or very small, you generally would generate from a schema published by the api developer
20:56:06 <idris_elba> but i suppose it still works
20:56:17 <EvanR> (hehe, Num instance for Value)
20:56:28 <Zemyla> juanca_: You probably can't do Unboxed because there's no way to unbox a ByteArray.
20:57:24 <nitrix> Theorically, is an IORef immutable? Not the content, but the handle itself?
20:57:27 <juanca_> Zemyla: why is that?
20:57:33 <nitrix> Can it be safely placed in a rader monad and used?
20:57:35 <EvanR> nitrix: yeah
20:57:43 <nitrix> *reader
20:57:49 <ertesx> juanca_: one feature regular Vector (Data.Vector) has that the others don't: boxed elements‚Ä¶  sometimes you want that
20:57:51 <EvanR> all data is immutable
20:58:14 <Zemyla> juanca_: Because ByteArrays use ForeignPtrs, which are tracked to make sure the data in them is garbage collected.
20:58:32 <Zemyla> ForeignPtrs can't be unboxed.
20:58:55 <juanca_> Zemyla: ertesx: so i should use data vector
20:58:56 <EvanR> nitrix: which is why ReaderT with a bunch of IORefs is more convenient than StateT for the same purpose, i think
20:59:01 <juanca_> thanks dudes
20:59:13 <EvanR> well its not why, but its also a thing 
21:00:12 <Zemyla> Yes.
21:01:30 <Zemyla> If ByteString used ByteArray# then they could be unboxed into ArrayArray#s.
21:07:04 <Zemyla> But yeah, use Data.Vector.
21:11:00 <nitrix> EvanR: Oh sorry, they're MVar's, but yeah I get the idea. I think I have a sane use case for them.
21:11:13 <nitrix> EvanR: I got the concurret printing prototype to work btw :)
21:12:10 <nitrix> I'm pondering how to turn it into some monad transformer. It's not very pretty otherwise.
21:13:05 <hackrilege> http://lpaste.net/161362
21:13:35 <EvanR> nitrix: i kept getting thrown off by calling the problem "how to concurrent print" but the actual problem is how to not mix up output with ghci output
21:13:52 <nitrix> EvanR: Right.
21:13:53 <EvanR> i know how to concurrent print
21:13:53 <hackrilege> can anyone see what im trying to do and if the way im trying to do it is going to work?
21:14:07 <hackrilege> from that paste
21:14:14 <EvanR> how do you not mix up ghci output?
21:14:14 <nitrix> EvanR: It'd be impossible if I had to interleave user input as well, but I don't need to.
21:14:37 <nitrix> EvanR: The printer IO is bound to the main thread.
21:14:53 <nitrix> And it doesn't return until it's done printing everything.
21:15:21 <nitrix> Thus I get only a prompt before and after the program is done executing - but whatever its executing is still async.
21:16:05 <EvanR> ok
21:16:58 <nitrix> It's probably trivial, but it got me scratch my head and I don't want to figure it out everytime I need to do this :P
21:17:15 <nitrix> And I firmly believe in writing my own libraries to make my life easier :)
21:18:00 <EvanR> reusable code is at least... usable once!
21:18:10 <nitrix> o:
21:18:25 <EvanR> otherwise itd be unusable ;)
21:19:01 <nitrix> Re-unusable, heh.
21:19:31 <ntnt> is there a good doc anywhere on 'cont monad' vs 'either monad' for error handling?
21:19:55 <nitrix> ntnt: You mostly want Either for error passing.
21:20:10 <ntnt> nitrix: I was hoping to read a detailed analysis
21:20:16 <ntnt> not a single line decision :-)
21:20:19 <ntnt> i.e. the 'why' behind the decision
21:20:57 <nitrix> Well, first the Either monad embed the concept of computations that may fail.
21:21:40 <nitrix> Cont on the other hand, gives you a form of continuity that can be paused and resumed.
21:22:35 <nitrix> e.g. if I were implementing an interpreter, chances are I'd have some form of Either for the lexer, and some Cont for the runtime execution.
21:23:07 <nitrix> I wish I could find a decent article though :/
21:23:21 <ntnt> suppose I have a call graph of f -> g -> h -> i -> j -> k
21:23:32 <ntnt> it seems like either forces each layer to 'know about the error'
21:23:41 <ntnt> whereas with a continuation, f can just define a handler, that k uses
21:23:53 <nitrix> Right, if there's an error at any stage, it'd bubble-up.
21:24:01 <nitrix> (For either)
21:24:08 <ntnt> but the bubble-up logic is mixed together with "normal behavior logic"
21:24:13 <EvanR> its not to know that something can fail in the type
21:24:20 <EvanR> its nice to know
21:24:22 <ntnt> it seems like "error handling logic" and "normal behavior logic" is now mixed
21:24:35 <EvanR> Cont hides all "goto"-like behavior
21:24:47 <ntnt> whereas, with continuations, I can focus on the normal behaior logic, and hand it a 'blackhole for error handling'
21:24:54 <ntnt> EvanR: you're syaing Cont makes control flow harder to understand?
21:24:57 <EvanR> and isnt limited to exception-like stuff
21:25:15 <EvanR> i was saying Cont just doesnt tell you as much in the type about what youre trying to do
21:25:23 <EvanR> (exceptions)
21:25:35 <ntnt> EvanR: that is true; Cont just says "this function takes a bunch of continuationsa nd uses one of them"
21:25:36 <EvanR> neither does IO
21:25:46 <EvanR> no 
21:25:51 <ntnt> Either does say "either we get a csuccess of type a, or an error of blah"
21:26:26 <gestone> Hey guys, I was wondering if someone could explain to me this simple error I'm getting
21:26:40 <ntnt> gestone: sure, please gist the code and the ghc error
21:26:49 <nitrix> Just to correct myself, `Maybe` are computations that may fail, `Either` are computations that may fail _with a meaningful error_.
21:26:55 <gestone> So here I'm trying to get directory contents:
21:26:57 <gestone>   allDirs <- getDirectoryContents "submissions"
21:27:06 <gestone> but I'm getting the error:
21:27:10 <gestone> Couldn't match type ‚ÄòIO‚Äô with ‚Äò[]‚Äô
21:27:13 <gestone> Expected type: [[FilePath]] Actual type: IO [FilePath]
21:27:20 <dfeuer> You're just *getting* an error. I *am* an error.
21:27:33 <ntnt> gestone: gist the entire function
21:27:43 <nitrix> gestone: We're going to need more context :)
21:27:59 <gestone> Sure thing
21:28:10 <EvanR> Cont r a is a cps-style computation that returns an r, but requires a continuation that takes an a to run
21:28:14 <dfeuer> gestone, either https://gist.github.com/ or lpaste.net
21:28:16 <EvanR> not a bunch of continuations
21:29:04 <gestone> https://gist.github.com/gestone/8f531598726e315c42c8e71eabf6c988
21:29:33 <ntnt> nitrix: you can handle this
21:29:39 <ntnt> this looks like a fun explainatino of [] vs IO monad
21:30:09 <ntnt> gatherFeedback :: IO [(String, String)], add a 'return' on last line
21:30:10 <ntnt> should fix it
21:30:34 <nitrix> ntnt: I think a first observation is that `gatherFeedback` is having the side effect of contacting the filesystem to know about the file structure.
21:30:40 <nitrix> gestone: ^
21:31:03 <gestone> Oh, so the type signature should be wrapped in an IO monad?
21:31:27 <gestone> Since this function should be marked as 'impure'
21:31:35 <nitrix> gestone: If `gatherFeedback` uses a function that results in an `IO`, such as `getDirectoryContents`, this function will have to reflect that.
21:32:21 <nitrix> gestone: That's an o-kay way to understand it for now, but as your understanding of monads depends, you'd understand why.
21:33:00 <nitrix> gestone: What the `do` notation does is an implicit (>>=) or (>>) operation in between each expressions.
21:33:26 <nitrix> :t (>>=)
21:33:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:33:49 <EvanR> gestone: of course, its still not impure
21:34:00 <EvanR> its just that IO actions are first class
21:34:09 <EvanR> and arent functions
21:34:32 <nitrix> gestone: If we replace the type variables there, it specializes as :: IO () -> (() -> IO [(String, String)]) -> IO [(String, String)]
21:35:00 <nitrix> gestone: Seems not intuitive, but it really is when you take the time to learn monads :)
21:35:25 <nitrix> gestone: Notice how the IO is unavoidable in the result :]
21:35:43 <gestone> Yeah, I've only read bits Learn You a Haskell with Monads, it's confusing to get my head around
21:36:00 <rhovland> gestone: do you really want gatherFeedback to be getting directory listings? you may want to have gatherFeedback :: [[FilePath]] -> [(String,String)], and do the getDirectoryContents in whatever is _calling_ gatherFeedback
21:36:10 <nitrix> gestone: If I'm honest, LYAH is a great book to get you curious about Haskell, but it's not a good teaching material.
21:37:21 <gestone> rhovland: That's a good suggestion, I think I'll end up doing that instead in main
21:37:31 <gestone> nitrix: What would you suggest then?
21:37:45 <gestone> I think RWH is also outdated from what I've read
21:38:07 <gestone> so I'm trying to find some new material that I can grasp on to learn
21:38:37 <nitrix> gestone: I think my best recommendation at the moment is http://haskellbook.com, but it's a little expensive. Of course, there are still tutorials online and we're here to help.
21:39:02 <rhovland> gestone: then you can do something like feedback <- gatherFeedback <$> getDirectoryContents "submissions"
21:39:02 <EvanR> theres the haskell wikibook
21:39:45 <gestone> EvanR: I've tried reading bits of that and it still feels pretty obscure to me
21:39:57 <EvanR> ok, i havent checked it out much
21:40:20 <gestone> nitrix: Oh thanks, I haven't stumbled upon this resource yet. I'll consider buying it, I really want to learn
21:41:21 <nitrix> gestone: It's a really good book. Tons of work went in it and as far as I can tell, the readers that comes here to ask questions seems a lot less confused that traditionally.
21:41:32 <EvanR> gestone: for curiositys sake, what kind of background do you have to come at haskell with
21:41:44 <EvanR> programmer in normal languages?
21:42:04 <gestone> rhovland: Ohh interesting, I hadn't thought about it that way. What does the <$> operator do in this case? I remember stumbling upon in reading up on Applicatives
21:42:35 <nitrix> gestone: Simplified, it lets you apply a transformation inside of a container type.
21:42:49 <EvanR> gestone: https://github.com/haskellcats/haskell-operators ;)
21:42:50 <gestone> EvanR: Yeah, I actually learned about Haskell through a PL class I took in college and we wrote a meta-scheme interpreter and I've been in love with it since
21:43:08 <EvanR> <$> = fmap
21:43:27 <hackrilege> i have managed to massage the code into a meaningful error, http://lpaste.net/161364
21:44:22 <gestone> EvanR: Ah, and IO is a Functor, so fmap works in this case
21:44:26 <rhovland> gestone: gDC comes back with a IO [FilePath], the <$> applies gatherFeedback inside the IO (which means, (gatherFeedback <$> gDC) :: IO [(String,String)]) 
21:44:35 <EvanR> gestone: yeah
21:44:52 <EvanR> handy
21:45:06 <gestone> that's awesome
21:45:33 <nitrix> rhovland: Except the type signature of gatherFeedback doesn't suggest that's how it's intented to be used, but considered the amount of lines of code written, I'm assuming there's not much set in stone yet :)
21:45:43 <nitrix> *considering
21:45:54 <EvanR> <$> is useful when you want to chain a bunch of applicative "actions" and apply a "pure" function to the results, while doing the effects
21:45:59 <gestone> nitrix: I'll definitely make the investment then. My goal is to be able to write some medium sized project in Haskell
21:46:23 <EvanR> f <$> actX <*> actY <*> actZ, where f :: X -> Y -> Z -> W
21:46:36 <EvanR> otherwise i like fmap
21:47:02 <hackrilege> gestone, medium sized projects in haskell can be a single line!
21:47:03 <nitrix> gestone: The book authors are also active on here, despite seemingly busy :)
21:47:09 <Cale> hackrilege: lol, come on :D
21:47:25 <montanonic> Does Lens make it more efficient to select multiple fields at once from a record type? For example, say I have: data Thing = Thing { ta :: a, tb :: b, tc :: c, td :: d, .... fifty more times }. And then say I have, things = [Thing], and I want to get all the ta, tb, tc, and td from things
21:47:54 <montanonic> The naive way I'd do that is: (ta <$> things, tb <$> things, tc <$> things, td <$> things)
21:47:57 <hackrilege> im trying to derive scan2d and its really hard
21:48:01 <montanonic> which seems *really* inefficient 
21:48:02 <nitrix> montanonic: I think that'd be prisms.
21:48:12 <nitrix> montanonic: Don't quote me on that.
21:48:21 <EvanR> no prisms is for sum types
21:48:40 <nitrix> Ah, you're right actually.
21:48:56 <hackrilege> Cale, im super stupmed with my work at this point i could really do with some insight into the error im getting
21:49:01 <Cale> montanonic: [(x, y, z, w) | Thing { ta = x, tb = y, tc = z, td = w } <- things] ?
21:49:04 <gestone> EvenR: So is it wrong to think of it as the <*> operator as sort of an `unboxing` of a pure value from its datatype?
21:49:06 <c_wraith> montanonic: if you want to select multiple fields at once efficiently, you probably should write your own lens.
21:49:12 <EvanR> gestone: yeah
21:49:13 <rhovland> gestone: super-useful. and you can compose things. e.g. "ns<-map read . words <$> getContents"
21:49:13 <nitrix> montanonic: It feels like some sort of Enum.
21:49:25 <Cale> montanonic: Of course, that doesn't give you four separate lists...
21:49:36 <EvanR> gestone: <*> applies a function to an argument, but doing "effects" in the process
21:49:38 <c_wraith> montanonic: There's no horizontal composition of lenses like that because it's not correct in the general case.
21:49:45 <Cale> montanonic: But then, perhaps the computation you're doing can do in place of that 4-tuple constructor...
21:49:56 <EvanR> gestone: (<*>) :: IO (a -> b) -> IO a -> IO b, for example
21:49:57 <montanonic> Cale: okay, I like that though, because it doesn't traverse the list multiple times, which is what made my previous code inefficient 
21:50:05 <montanonic> Cale: that's really helpful, I'll start from there
21:50:32 <montanonic> I didn't realize you could pattern match on multiple fields like that
21:50:49 <Cale> montanonic: Yeah, and you can leave out fields that you don't need that way
21:51:03 <montanonic> awesome
21:51:07 <montanonic> that's exactly what I needed
21:51:24 <nitrix> gestone: Here's the thing, you're not really wrapping and unwrapping things with those operators. They have type classes to respect, and its the types that implement those type classes that can peek in the abstraction and wrap and unwrap the constructors. What you're doing is passing a function to that implementation so it gets applied.
21:51:40 <hackrilege> can anyone make sense of this error? http://lpaste.net/161364
21:51:50 <nitrix> gestone: More or less like a callback system.
21:52:25 <gestone> ohh I see
21:52:36 <EvanR> eh...
21:52:44 <Cale> hackrilege: wait, what? It's giving you an error on a line that's a comment?
21:52:45 <EvanR> what
21:53:04 <Cale> hackrilege: Are those line numbers correct?
21:53:18 <hackrilege> nope
21:53:25 <hackrilege> ill rectify that sorry
21:53:41 <EvanR> gestone: does my explanation make sense for <*>
21:53:56 <EvanR> theres no wrapping and unwrapping of IO
21:54:42 <gestone> EvanR: Yeah, it does. It'll just execute the effects correct?
21:55:00 <nitrix> almost :P
21:55:33 <EvanR> in this case, the IO b is an action which will execute the IO (a -> b), then the IO a, and return the application of the function to the argument
21:55:51 <EvanR> or freeze up, or crash
21:56:14 <rhovland> mostly I remember the analogy "f a b" is like "f <$> a <*> b", although that's sort of hard to explain
21:56:16 <EvanR> (in IO, not just normally)
21:57:14 <nitrix> gestone: The effects are combined, but I'd lie if I say it executes the effects, since Haskell is lazyly evaluation. Evaluating something doesn't means its effects are carried out necessarily.
21:57:25 <nitrix> *lazyly evaluated.
21:57:33 <nitrix> lazily? How do you write that :P
21:57:34 <gestone> :rhovland so like... (++) "hi" "bar" vs (++) <$> Just "hi" <*> Just "bar"
21:57:41 <EvanR> the resulting action is one that will execute two other actions
21:57:46 <EvanR> if executed
21:57:53 <EvanR> you make new actions out of old
21:58:20 <EvanR> > (++) <$> Just "hi" <*> Just "bar"
21:58:22 <lambdabot>  Just "hibar"
21:58:28 <EvanR> > (++) <$> Nothing <*> Just "bar"
21:58:30 <lambdabot>  Nothing
21:59:05 <hackrilege> ok the error is on the correct line now
21:59:05 <hackrilege> http://lpaste.net/161364
21:59:05 <EvanR> in this case, Maybe, you can also understand it in terms of the implementation
21:59:40 <EvanR> which only involves unwrapping because you have to inspect value, its not really the core meaning of Applicative
22:00:15 <EvanR> but wed rather not have to check the implementation to understand something! ;)
22:00:39 <hackrilege> can you make sense of it Cale?
22:01:08 <gestone> Yeah, I've just been confused about Applicative since LYAH
22:01:36 <EvanR> its kind of Monad-lite
22:01:37 <hackrilege> :tliftA2
22:01:41 <hackrilege> :t liftA2
22:01:42 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
22:01:43 <rhovland> also you can do something like (zip <*> tail) [1,2,3,4,5]... I'm still pretty confused about it, but I figure if I know enough idioms it'll make sense
22:01:59 <nitrix> > (+1) <$> Just 5
22:02:01 <lambdabot>  Just 6
22:02:06 <nitrix> > Just (+1) <*> Just 5
22:02:08 <lambdabot>  Just 6
22:02:30 <EvanR> Just=pure
22:02:32 <rhovland> oh, that's a very good way to look at it
22:02:40 <Cale> hackrilege: What are Control.Monad.Plus and Control.Applicative.Alternative?
22:02:42 <EvanR> f <$> x = pure f <*> x
22:02:43 <nitrix> gestone: Applicative functors are functors that can be applied :P ?
22:03:19 <Cale> hackrilege: Okay, I imported Control.Monad and Control.Applicative and got the errors you're seeing, let me see
22:03:53 <EvanR> gestone: im kind of curious what LYAH says about it...
22:03:54 <gestone> Functors that can be applied... since you can have functions inside of the functor itself yes? And it can be applied to other Applicatives
22:04:08 <nitrix> gestone: Mhm.
22:04:30 <hackrilege> Cale, they give additional structure to Monads and Applicatives respectively to include an associative operator and identity to form a monoid
22:04:37 <gestone> They give an example of Applicatives with the Maybe type class and lists
22:04:53 <EvanR> Maybe isn't a type class!
22:05:04 <Cale> hackrilege: uh, I was asking about the modules
22:05:11 <EvanR> Maybe is a type constructor
22:05:12 <gestone> oops not type class
22:05:25 <Cale> hackrilege: Control.Monad.Plus isn't in base or anywhere that I'm aware of
22:05:31 <Cale> hackrilege: but whatever
22:05:37 <nitrix> gestone: `Maybe a` is a type class, `Maybe` is a type constructor :)
22:05:48 <EvanR> Maybe a isnt even a type class!
22:05:53 <nitrix> gestone: I normally wouldn't nitpick in casual chat, but the distinction is important if you're starting :)
22:06:00 <nitrix> EvanR: Oh really o: ?
22:06:06 <nitrix> EvanR: Does it has to be concrete?
22:06:26 <EvanR> Maybe a is a type
22:06:32 <hackrilege> cabal install monadplus
22:06:52 <nitrix> EvanR: I see where you're getting at.
22:07:01 <rhovland> I don't think you can do "Maybe a => a->Int" or something
22:07:02 <hackrilege> probably depreciated, documentation certainly is
22:07:21 <Cale> hackrilege: Well, just adding those Zipable (Compose s) s constraints to the respective instance heads makes it stop complaining...
22:07:22 <EvanR> yes Maybe a does go on the left of =>, its not defined with class Maybe a where
22:07:37 <EvanR> does NOT go on the left of =>
22:07:37 <nitrix> :t fromJust
22:07:39 <lambdabot> Maybe a -> a
22:07:39 <nitrix> rhovland: ^
22:08:06 <hackrilege> wtf is a Zipable (Compose s) s
22:08:09 <nitrix> rhovland: It's do-able. Also quite unsafe.
22:08:14 <ski> `->' is not `=>'
22:08:46 <hackrilege> i mean seriously, this bug is deep, something went wrong
22:09:06 <ski> @type let foo :: Maybe a => a -> Int; foo = undefined in foo  -- testing
22:09:07 <lambdabot>     Expected a constraint, but ‚ÄòMaybe a‚Äô has kind ‚Äò*‚Äô
22:09:07 <lambdabot>     In the type signature for ‚Äòfoo‚Äô: foo :: Maybe a => a -> Int
22:09:07 <lambdabot>     In the expression:
22:10:05 <EvanR> im afraid with two people learning haskell they might be horrible confused by now ;)
22:10:24 <gestone> indeed, I'm going to go buy that book
22:10:33 <nitrix> Oh that's what you meant.
22:10:57 <EvanR> type class is a weird way to say typeclass, maybe thats what you were mixing up ;)
22:11:44 <nitrix> EvanR: Rude.
22:12:00 <nitrix> EvanR: So to be considered a typeclass, it has to be a Constraint?
22:12:18 <EvanR> it has to be introduced with a `class' at the very least
22:12:25 <nitrix> EvanR: How would want talk about the "class Maybe a" then?
22:12:35 <nitrix> s/want/one/
22:12:48 <EvanR> its just theres no class Maybe a in the stdlib
22:12:57 <nitrix> Oh my...
22:13:03 <nitrix> Where did my brain go.
22:13:07 <EvanR> what are the operations even ;)
22:13:25 <nitrix> Oh my gosh.
22:13:28 <nitrix> I need sleep.
22:13:28 <hackrilege> Cale, its not that i wanted to make it stop complaining, its that im not going to be able to complete those instances and i dont know why the compiler seems to think it wants me to write them
22:13:32 <Cale> hackrilege: OHHHH
22:13:41 <Cale> There are all kinds of incoherent instances in this
22:13:50 <gestone> so you guys might be biased, but what do you guys think of implementing TOR in Haskell?
22:14:00 <hackrilege> all kinds of i dont know what
22:14:01 <EvanR> dont
22:14:02 <Cale> > instance (Zipable z s,Stack s) => Foldable (z s) where
22:14:02 <Cale> >  foldMap f = (foldMap f).fromZipper
22:14:04 <lambdabot>  <hint>:1:1: parse error on input ‚Äòinstance‚Äô
22:14:04 <lambdabot>  <hint>:1:11: parse error on input ‚Äò=‚Äô
22:14:15 <Cale> (sorry for lambdabot spam)
22:14:18 <gestone> not that i will, i'm just wondering since i saw an open source implementation of it
22:14:23 <Cale> That instance there is causing all sorts of problems
22:14:35 <ski> overlapping (as i mentioned earlier)
22:14:44 <EvanR> folklore says haskell is not great for directly implementing crypto
22:14:59 * ski . o O ( Cryptol )
22:15:18 <EvanR> but you could write a DSL that outputs specially crafted crypto machine code that avoids side channels
22:15:32 <hackrilege> i like that instance and i dont see whats wrong with it
22:15:50 <EvanR> yeah cryptol looks awesome
22:16:43 <Cale> hackrilege: okay, so let's follow the logic of the GHC typechecker. According to the definition of the Zipable type class, in order to have an instance Zipable z s, we must have instances (MonadPlus (z s), Stack s)
22:16:51 <hackrilege> a Stack is foldable, a zipable is basically just a synonym of a Stack, so why shouldnt all Zipable things be foldable? i can just use the implementation over the underlying Stack
22:17:38 <Cale> So in order to have an instance (Zipable GridZipper (Compose s s)), we must have instances MonadPlus (GridZipper (Compose s s)) and Stack (Compose s s), yeah?
22:18:03 <MichaelBurge> A let binding makes a local value alias. Is there a way to make a local type alias?
22:18:06 <hackrilege> yes, Zipable things have a MonadPlus instance, its reasonable to demand it as a constraint since its methods are used in the default methods of this class
22:18:22 <hackrilege> yes
22:18:28 <hackrilege> to your question
22:18:50 <Cale> and in order to have Stack (Compose s s), we must have Foldable (Compose s s), because of the class declaration of Stack
22:18:58 <hackrilege> yes
22:19:13 <Cale> instance (Zipable z s,Stack s) => Foldable (z s) where
22:19:19 <Cale> this instance matches, with z = Compose s
22:19:22 <gestone> alright all, thanks for the help, I'll be sure to lurk more on this channel more often
22:19:32 <Cale> So now we need Zipable (Compose s) s, and Stack s
22:19:40 <hackrilege> noooo
22:19:44 <hackrilege> thats bad
22:19:55 <Cale> Yeah, that's why that instance is bad
22:20:14 <Cale> Instances of type classes which don't pattern match on type constructors are bad.
22:20:59 <Cale> and that's why you need to turn on 80 kajillion language extensions to allow them, to indicate that you actually know what you're doing
22:21:04 <hackrilege> but in this case i have toZipper and fromZipper
22:21:13 <hackrilege> so i dont need to patern match
22:21:40 <Cale> I'm talking about pattern matching at the type level
22:22:00 <ggVGc> this is probably haskell telling you that you're solving your problem incorrectly
22:22:04 <Cale> Yeah, it is.
22:22:12 <ggVGc> haskell often tells me that :(
22:22:16 <hackrilege> as in fmap f Zipper a b = Zipper (fmap f a ...
22:22:27 <hackrilege> i know something is wrong
22:22:32 <hackrilege> i cant get my head round it
22:22:44 <Cale> hackrilege: Step 1: Turn off IncoherentInstances and UndecidableInstances
22:22:45 <hackrilege> this type error is awful
22:23:05 <hackrilege> i needed them waay back
22:23:19 <hackrilege> for all that stuff you dont like that i want this to do thats giving me this error
22:23:35 <Cale> hackrilege: Step 2: rewrite these instances so that they actually have the type constructors you care about in them -- if this means duplicating the instance, so be it
22:24:22 <hackrilege> ok
22:24:36 <hackrilege> what i want to do is good, but its just ruining the debuging
22:24:41 <hackrilege> i can turn it back on later
22:25:24 <hackrilege> i will rewrite these to contain Zipper and GridZipper explicitly
22:25:28 <hackrilege> but then the error remains
22:25:37 <hackrilege> something is messed up about how im trying to do this
22:25:42 <Cale> Let's see your new code
22:25:47 <hackrilege> the error is always going to be there
22:25:52 <hackrilege> ok ill do that one sec
22:25:56 <Cale> Instances which only have variables in the instance head are *bad* because they match too often -- remember that GHC's instance resolver has to actually figure out which instance applies
22:26:13 <Cale> hackrilege: Oh, something else you should know!
22:26:36 <MichaelBurge> There should be a -XYesIKnowWhatI'mDoing language extension that just turns off all language limitations. In the case of any ambiguity, it can just pick any possibility since the user is assumed to know what he's doing.
22:26:42 <Cale> hackrilege: When looking for an instance that matches, GHC isn't allowed to consider whether the constraints on the instance will be satisfied before committing to it
22:26:51 <Cale> hackrilege: So when you write instance (Zipable z s,Stack s) => Monad (z s) where
22:27:00 <EvanR> -XProgramDirectlyInCore
22:27:19 <montanonic> The time package isn't exactly the most friendly for doing Diff calculations. Like, if I have two UTCTimes, I just want to be able to find the hours and minutes that passed between them, but I'm stuck with a DiffTime value that I can't unwrap if I use the time package
22:27:22 <Cale> hackrilege: to the part of the instance resolution algorithm which is trying to decide which instance to commit to, this looks like instance Monad (z s) where
22:27:47 <EvanR> montanonic: NominalDiffTime, first of all, not DiffTime
22:27:50 <montanonic> There's 1 unwrap function, diffTimeToPicoseconds, but it's not in the current LTS
22:28:00 <Cale> hackrilege: and *only after* committing to selecting that instance will it go check and see if it can find instances of Zipable z s and Stack s
22:28:01 <EvanR> secondly, NominalDiffTime is a Num and Fractional
22:28:15 <EvanR> it works like a number (of seconds)
22:28:27 <montanonic> EvanR: I work with utctDayTime, so just DiffTime
22:28:31 <Cale> hackrilege: The reason for this has to do with separate compilation -- we wouldn't want future modules to affect the meaning of previously compiled code
22:28:53 <montanonic> hmm, okay, you're right
22:28:58 <EvanR> montanonic: ehm... DiffTime is inconvenient because you need a leap second table
22:28:58 <montanonic> let me play around with those instances
22:29:05 <Cale> hackrilege: and if the instance selected is allowed to depend on which instances are present, then future modules can affect which instance ought to have been selected.
22:29:14 <montanonic> EvanR: oh, really? that sounds yuck; I'll stick to difftime then
22:29:19 <montanonic> EvanR: ty
22:29:42 <c_wraith> It's NominalDiffTime that doesn't need the leap second table
22:29:56 <Cale> hackrilege: So there's really nothing for it but to ensure that each instance is for a specific type.
22:30:08 <hackrilege> http://lpaste.net/161368
22:30:13 <montanonic> right, yes, I meant NominalDiff
22:31:08 <Cale> hackrilege: Okay, so the first one at 53, maybe you want to add a Comonad constraint to zmap itself
22:31:23 <Cale> hackrilege: or maybe you want to add it as a superclass of Zipable
22:31:59 <Cale> hackrilege: btw, your comonad class is weird looking -- why the extra parameter?
22:32:05 <hackrilege> !!!
22:32:11 <hackrilege> thats the WHOLE POINT
22:32:21 <hackrilege> its messing everything up
22:32:47 <hackrilege> i just cant get this Zipable thing down
22:35:09 <hackrilege> :type (fromZipper ((Zipable z s ,Stack s) =>z::Zipable (Compose s s) a)) = Stack s => Compose s s a
22:36:06 <hackrilege> coreturn :: z s a -> s a
22:36:09 <Cale> hackrilege: You realise that if you wrote Comonad the usual way, you could still have an instance for (Zipper s)?
22:36:36 <Cale> errrr
22:36:38 <hackrilege> fromZipper would then what to return 'a' rather than 's a'
22:37:02 <Cale> But that's not what your existing class does
22:37:08 <hackrilege> exactly
22:37:17 <hackrilege> hmm?
22:37:18 <hackrilege> no
22:37:22 <Cale> If it was coreturn :: c m a -> m a, well, that's different from the standard Comonad
22:37:26 <montanonic> EvanR: wow, it actually works like a dream. Though, it takes a bit of awareness of the typeclasses, which I feel is hard for people who are still getting used to the haskell ecosystem. Anyways, I use `truncate` on it, because all that precision goes unused by me, and then I have Integral seconds
22:37:44 <montanonic> which is exactly what I needed
22:37:44 <Cale> Your Comonad is just a restriction of the usual one, requiring something with an additional type parameter that isn't interacted with
22:37:45 <montanonic> yay
22:37:45 <hackrilege> it is different, hence my different comonad class!
22:37:54 <Cale> look at your code
22:38:01 <Cale> You have  coreturn :: c m a -> a
22:38:08 <EvanR> montanonic: right... Data.Time is kind of hard to get for beginners i think because they arent used to looking for instances and the modulars are all separated
22:38:12 <Cale> not  coreturn :: c m a -> m a
22:38:16 <EvanR> montanonic: i have this https://github.com/evanrinehart/time-diagram
22:38:32 <hackrilege> what!?
22:38:34 <montanonic> EvanR: which was exactly my problem; and I just remembered that truncate was a function
22:38:49 <hackrilege> hmm thats bad! thanks for spotting it
22:38:54 <EvanR> floor or ceil or whatever is one way, or you can use realToFrac to get a Double
22:38:55 <montanonic> EvanR: oh, that's really nice looking; thanks for the link
22:39:20 <EvanR> or separate it into whole part (integral, and fractional part)
22:39:27 <hackrilege> ohhh yeah
22:39:31 <EvanR> with parens fixed
22:39:33 <hackrilege> no its ok like that
22:39:49 <Cale> hackrilege: In that case, you have the luxury of not having to define your own Comonad class
22:39:51 <montanonic> indeed, awesome; now that I understand how it uses the typeclasses, it's actually incredibly versatile
22:40:10 <Cale> hackrilege: and just using the usual one, with an instance ... => Comonad (Zipper s)
22:40:10 <hackrilege> still not sure it would work
22:40:42 <Cale> Your instance does look a little janky with the fromJust though...
22:40:57 <hackrilege> janky indeed
22:41:59 <hackrilege> its a shame you cant realy see what im trying to do just from the type error
22:42:40 <hackrilege> if you can see more clearly whats going on can you tell if its completely broken to try and do what im trying to do?
22:42:43 <EvanR> montanonic: a large blink tag that says basically "use Day for dates, UTCTime for timestamps, ignore AbsoluteTime and DiffTime, use NominalDiffTimes instead which is a numeric type, and for real timezone support see timezone-series package" would be nice
22:43:32 <montanonic> EvanR: I'm going to just write that down...
22:43:36 <EvanR> also "LocalTime is useful because it corresponds to DateTimes (or whatever you call them) in SQL"
22:43:56 <EvanR> i.e. date + time (no timezone implied)
22:43:57 <montanonic> EvanR: I needed to use ZonedTime to work with google API
22:44:13 <EvanR> ... yeah so timezone-series is a must
22:44:22 <EvanR> it deals with ZonedTimess
22:44:27 <montanonic> The gogol library uses UTCTime, which lead me down hours of parse errors that I couldn't understand
22:44:28 <montanonic> yay
22:44:59 <EvanR> UTCTime would probably be a lot simpler
22:45:10 <Cale> hackrilege: I can't really say I fully understand what's going on here
22:45:51 <Cale> hackrilege: It is either suspicious or auspicious to have something which is both a Monad and Comonad instance.
22:45:59 <Cale> Such things are a little bit rare.
22:47:02 <c_wraith> There are crazy things like Cofree's Monad instance.
22:47:16 <EvanR> montanonic: note that TimeZone is really an offset and means piss-all when talking about past or future mappings between utc and localtime
22:48:00 <scshunt> is there a Haskell library for time zone database stuff?
22:48:17 <Cale> http://hackage.haskell.org/package/tzdata
22:48:25 <EvanR> timezone-olsen
22:48:48 <Cale> oh, right, that one
22:48:51 <Cale> http://hackage.haskell.org/package/timezone-olson
22:48:58 <EvanR> olson
22:50:07 <scshunt> ahh, sweet
22:50:16 <scshunt> why is time so complete bullshit :(
22:50:37 <EvanR> blame railroads
22:50:52 <EvanR> or forget timezones exist ;)
22:51:04 <dolio> We should have switched to internet time back in '98.
22:51:06 <hackrilege> the point im trying to achieve is an instance Stack s => Zipable (ComposeFree s) (Free (Zipper []))
22:51:57 <hackrilege> instance Stack s => Zipable (Free (Zipper [])) (ComposeFree s)
22:51:59 <hackrilege> rather
22:52:05 <EvanR> 285.beats
22:52:55 <hackrilege> or even instance (Zipable (z s),Stack s) => Zipable (Free (z s)) (Free s)
22:53:43 <hackrilege> can you see the starts of this with my attempt at an extension to 2d?
22:54:05 <hackrilege> i need to get the framework set up so that i can make this extension to write the Free instance
22:54:48 <hackrilege> at the moment it seems to break for 2d, but if it works, then the generalisation should be easy
22:54:58 <hackrilege> having done the base case and inductive step
22:55:50 <Hafydd> Surely it should be spelt "Zippable."
22:55:57 <hackrilege> thanks
22:56:10 <hackrilege> i have a problem with those sorts of thing
23:00:56 <EvanR> the rare and elusive Zipe operation
23:06:09 <ntnt> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html <-- why does callCC require a monad? why can't it work without a monad ?
23:07:32 <EvanR> not just any monad
23:07:42 <EvanR> MonadCont, such as Cont
23:07:54 <EvanR> callCC :: ((a -> Cont b) -> Cont a) -> Cont a
23:08:03 <EvanR> callCC is really a Cont operation
23:08:17 <Cale> ntnt: Well, if you think you can write a function ((a -> b) -> a) -> a, perhaps you should try :)
23:09:05 <EvanR> er
23:09:18 <EvanR> callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
23:09:26 <ntnt> Cale++
23:10:16 <EvanR> does MonadCont have any laws?
23:10:37 <ntnt> law 0: thou shalt never use MonadCont
23:10:55 <Cale> EvanR: very good question
23:11:08 <Cale> EvanR: I don't know what the laws ought to be, but there probably should be some
23:12:29 <EvanR> it mentions something about being equivalent to "using return"
23:17:51 <Tangerine> Say that I have a tree defined in record syntax
23:18:54 <Tangerine> so, "data Tree = Leaf | Node { value::int, left::Tree, right::Tree}"
23:19:48 <Tangerine> how would I write an "accessor" for the value of a given tree? (i.e. value::Tree -> Int)
23:20:02 <Tangerine> or is this written for me?
23:20:26 <MasseR> Tangerine :t value
23:21:58 <EvanR> Tangerine: value :: Tree -> Int, however if used on a Leaf it will crash
23:22:13 <EvanR> so this style kind of sucks
23:22:27 <Tangerine> so should I not use record syntax?
23:22:38 <EvanR> imo no, not in a sum type
23:22:56 <Tangerine> and do data Tree = Leaf | (Int Tree Tree) ?
23:23:06 <EvanR> the second case needs a constructor
23:23:19 <EvanR> Node
23:23:24 <dolio> Sometimes you have a sum where every case has a field, in which case it won't crash.
23:23:25 <Tangerine> oh right
23:23:38 <Tangerine> data Tree = Leaf | Node (Int Tree Tree)
23:24:08 <Tangerine> so would a function value::Tree->Int be simply
23:24:21 <dolio> Also, if you skip using the Haskell generated field accessors, and derive lenses with lens, you'll get traversals for the things that aren't in every constructor.
23:24:33 <Tangerine> value (a _ _) = a?
23:24:38 <EvanR> nice
23:24:42 <ntnt> anyone here managed to scrape zillow.com with haskell? I need a way to sort the listings by something that zillow does not offer (i.e. by # of days listed), so I need to somehow remash the data
23:24:48 <EvanR> Tangerine: that has the same issue as before
23:25:10 <EvanR> you didnt define what happens for value Leaf = ?
23:25:43 <Tangerine> what if it shouldn't be called on a Leaf?
23:25:48 <Tangerine> or rather, has no meaning when you call it on a leaf?
23:25:55 <Tangerine> or is that simply bad design
23:25:59 <Lovepon> Urgh
23:26:04 <EvanR> you can put undefined and it will crash
23:26:07 <Lovepon> How do I even sqrt
23:27:01 <EvanR> Tangerine: in real life, your tree algorithms probably do a pattern match to decide what to do based on Node or Leaf, and the issue wont come up (you dont use a value function)
23:27:42 <EvanR> but in some cases the type system just cant guarantee you wont call the function wrong
23:27:58 <EvanR> at least not in a sane way
23:28:10 <Tangerine> Well, I was thinking for a min-heap
23:28:21 <EvanR> in that case you can use error
23:28:29 <EvanR> > error "the impossible has occurred"
23:28:31 <lambdabot>  *Exception: the impossible has occurred
23:28:37 <EvanR> :t error
23:28:39 <lambdabot> [Char] -> a
23:44:24 <metahumor> Hey everyone! I'm trying to figure out whether it is possible to `deriving instance Data (->)`
23:44:55 <metahumor> I'd like to serialize partial functions, but can't figure out how to derive Data for partially applied constructs
23:44:59 <metahumor> *constructors
23:45:23 <orb> metahumor: what do you mean by partial function?
23:45:51 <orb> From your context it seems like you mean a partially applied function?  (Usually, by partial function we mean a function that is undefined/looping/crashing on some inputs.)
23:46:02 <orb> As opposed to a total function.
23:46:05 <metahumor> lets say I have "data Request a where Add :: Int -> Int -> Request Int"
23:46:14 <metahumor> yes, sorry, I meant a partially applied function
23:46:21 <orb> No worries.
23:46:30 <metahumor> I can do a "deriving instance Data (Request Int)"
23:46:38 <orb> Sorry, I don't have enough knowledge (or time) to answer your actual question.
23:46:45 <orb> I guess only the Australians and Asians are awake right now?
23:46:53 <metahumor> which will allow me to serialize an "Add 1 2" object
23:47:10 <metahumor> but I'd like to also serialize an "Add 1" object
23:47:21 <metahumor> orb: That's alright, I'll try again during normal hours
23:56:31 <MichaelBurge> Is there a way to get GHC to spit out a better error than 'parse error'?
