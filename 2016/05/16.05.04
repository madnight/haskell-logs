00:00:20 <ralu> I get this
00:00:59 <montanonic> Ashy: I mean, wouldn't that just mean writing compilers to Java and Swift
00:01:00 <simpson> It's my biggest gripe with Haskell; it outlines the limits of the type system's expressiveness in a very clear way.
00:01:31 <montanonic> Ashy: which sounds... like it would be awesome, but also, like a fuckload of work
00:02:48 <Cale> simpson: Well... Set also isn't really a monad on the category of Haskell types.
00:04:12 <thoughtpolice> There are already ports of GHC to both Android and iOS. They're just not shrink-wrapped bullet-proof things.
00:04:23 <thoughtpolice> Which is like, most of the work, probably.
00:04:27 <simpson> Cale: Right. I agree with the conclusion that Set can't be a Monad as-is; it's just, for me, a stark example of the limits of Haskell's type system.
00:07:33 <Ashy> montanonic: Yeah it would be awesome, hence why I'm asking SWIM to do it haha
00:08:05 <Ashy> thoughtpolice: Yeah it's the shrink wrapping that will pull in the new developers
00:15:14 <koz_> What the hell is an 'unticked promoted constructor'?
00:23:56 <Cale> koz_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html#promotion-syntax
00:24:53 <koz_> Ah, thanks Cale.
00:25:03 <koz_> Also, I'm having a bit of trouble making sense of GADT-generated constructors.
00:25:26 <koz_> @paste
00:25:26 <lambdabot> Haskell pastebin: http://lpaste.net/
00:26:24 <koz_> Specifically, here's my code and question: http://lpaste.net/162402
00:26:47 <koz_> My idea is that Internal should have fields for its data, and its two children.
00:26:54 <koz_> (or at least, that's what I care about)
00:29:59 <ocramz> morning all
00:30:08 <koz_> ocramz: Hihi!
00:30:13 <koz_> (although it's evening here)
00:30:36 <ocramz> koz_ : where do you type from? I'm in Sweden atm
00:30:48 <koz_> ocramz: New Zealand.
00:30:54 <koz_> (GMT+12 or so)
00:31:48 <ocramz> And sink vortices spinning in the other direction
00:31:55 <koz_> Also, ocramz, can you help me with a GADT-related question?
00:32:00 <ocramz> ugh, try me
00:32:35 <koz_> http://lpaste.net/162402 <-- question and relevant code is here
00:34:07 <koz_> My *intention* is that Internals have a value (of type b), a type-level height marker (of type Nat) and a reference to each of their children.
00:34:21 <koz_> But I'm *completely* not sure which, if any, of these, my GADT declaration gives me.
00:34:23 <koz_> (and in what order)
00:38:41 <Cale> koz_: You didn't include the value of type b on the Internal nodes
00:38:43 <koz_> ocramz: Never mind, I think I figured it out myself.
00:38:50 <koz_> Cale: I *just* realized this very thing.
00:39:44 <koz_> Cale: I'm still learning how to work with GADTs and ... well, the rest of the stuff that makes this scheme tick.
00:39:55 <koz_> (I only got the ideas while busing home today, or so I thought...)
00:43:55 <koz_> Cale: I have a height marker embedded into my GADT (in the form of 'Succ (Succ ... (Succ Zero) ... )'). I wanna implement a more efficient 'length' method for its Foldable instance based on this type-level height marker. Can I even?
00:44:59 <koz_> Cale: http://lpaste.net/162402 <-- type definition if it matters
00:48:21 * hackagebot haskell-neo4j-client 0.3.2.2 - A Haskell neo4j client  https://hackage.haskell.org/package/haskell-neo4j-client-0.3.2.2 (asilvestre)
00:50:08 <suppi> a question regarding serialization, why does the encoding of int is different in haskell than c?
00:50:22 <suppi> for example, 1 in haskell is 0001
00:50:32 <suppi> and in c it's 1000
00:50:51 <koz_> suppi: Are you asking about endianness?
00:50:52 <suppi> where each digit represent a byte
00:51:01 <suppi> koz_ i guess
00:51:11 <koz_> suppi: AFAIK, C doesn't require any endianness.
00:51:34 <suppi> encoding 1 using cereal does not give 1 in c
00:51:38 <koz_> Heck, C doesn't even place a hard requirement on *size*.
00:51:53 <koz_> Since some platforms have 16-bit ints, and others have 32-bit ones.
00:52:20 <koz_> (I think the standard prescribes *boundaries*, but not exact values, for the sizes of the primitive number types)
00:52:28 <merijn> suppi: The usual standard for encoding numbers in serialisation is to us network byte order
00:52:49 <merijn> The host byte order on MOST modern machines is the opposite of network byte order
00:53:00 <merijn> I though network byte order was big endian, but not 100% sure
00:53:05 <suppi> www.ideone.com/RYKIE1
00:53:16 <koz_> merijn: Even if that were the case, C doesn't mandate a byte order AFAIK.
00:53:24 <koz_> Heck, for ints, it doesn't even mandate an exact size.
00:53:29 <suppi> merijn, what do you mean?
00:53:51 <merijn> suppi: The standard for serialised data, e.g. for network transfer is to use big endian
00:53:58 <merijn> Most machines nowadays are little endian
00:54:09 <Freundlich> You can access individual bytes of an int in C and inspect them but I'm pretty sure there is no meaning behind them.
00:54:17 <merijn> I think C endiannes is implementation defined
00:54:37 <merijn> koz_: But a bit hazy, ask mauke if you wanna be sure about C standard details :p
00:55:05 <merijn> I checked, network byte order was big endian, yeah
00:55:17 <Freundlich> C mandates certain interactions between the bit string and artihmetics but not between bits and bytes.
00:55:22 <koz_> merijn: I think not. C is meant to run on all kinds of machines, and I'm pretty confident *some* of those aren't big-endian (or little-endian).
00:55:26 <merijn> suppi: As for C interoperability you'd want hton and ntoh
00:55:52 <suppi> merijn, thanks!
00:55:54 <merijn> Freundlich: C doesn't even specify the size of bytes :)
00:56:01 <koz_> Freundlich: First-off, that's an awesome IRC nick. Secondly, yeah, that seems right.
00:56:10 <koz_> Although my knowledge of the C standard is spotty at best.
00:56:23 <Freundlich> merijn: Not sure about C, but in C++ the definition of the size of a byte is 1.
00:56:53 <suppi> merijn, what if i can't touch the C code, anyway to do that in haskell?
00:56:54 <merijn> Freundlich: Well, I suppose C never talks about bytes at all. Since "char" is the smallest addressible unit
00:57:12 <suppi> i guess cereal encode and then reverse will work
00:57:16 <merijn> suppi: Manual serialisation using the right endianness
00:57:46 <merijn> suppi: The Put module of cereal has different operators for big endian and little endian output
00:57:58 <merijn> i.e. putWord32be vs putWord32le
00:58:10 <Freundlich> What I mean is: In order for "endianness" to make any sense, you have to talk about a connection between the bit string and the byte string of an object, which C never does anywhere. So an implementation could even behave neither like big nor little endian.
00:58:35 <suppi> alright. thank you merijn
00:58:40 <suppi> thanks all!
00:58:59 <merijn> suppi: Note that on other machines the C implementation might actually be big endian
00:59:33 <merijn> suppi: Hence the "right" way of doing things is to pick an explicit endianness (usually network byte order, as that's expected) and convert from/to that as cereal is doing
00:59:58 <koz_> Also, could someone help me with this GADT question? http://lpaste.net/162402 <-- question and code
01:00:13 <suppi> merijn, alright. thank you :)
01:00:35 <merijn> koz_: Split out into two instances
01:00:56 <koz_> merijn: Sorry, but I don't follow.
01:01:36 <lpaste> merijn annotated “No title” with “Should work” at http://lpaste.net/162402#a162407
01:01:43 <merijn> koz_: Like that
01:03:05 <koz_> merijn: Oh, ok. So how would I implement length for the second instance exactly? I'm still not sure how to get at the necessary information to convert a Natural at the type level into a number in a variable.
01:03:18 <koz_> (the first one is easy because length is a constant function for those)
01:03:41 <merijn> koz_: You'd have to recurse or use singletons to turn your type level Nat into a value
01:04:25 <koz_> merijn: Alrighty, I'll give this a try using your scheme and see how I go.
01:05:26 <koz_> merijn: Also, the compiler does *not* seem to like 'instance Foldable (Node Zero)'...
01:05:45 <merijn> koz_: FlexibleInstances complaint?
01:05:51 <koz_> merijn: Yup.
01:06:06 <merijn> koz_: Haskell98/2010 are overly conservative in the instances they allow
01:06:20 <koz_> Alrighty, so I guess I'm grabbing FlexibleInstances too.
01:06:23 <merijn> koz_: FlexibleInstances is pretty harmless
01:07:14 <merijn> koz_: Basically according to the report you're only allowed to define instances for types "C a b..." where C is a type constructor and everything else is type variables (and Zero is not a type variable)
01:07:24 <merijn> But there's no real good reason to not allow "Node Zero"
01:07:32 <koz_> merijn: Ah, I get it.
01:07:50 <koz_> I'm just very new to all this, hence my concern.
01:08:58 <koz_> Seems I need FlexibleContexts too...
01:10:02 <merijn> Yeah, those two usually go hand in hand
01:10:26 <koz_> merijn: Well, now I'm up to like, 6 extensions, lol. :P
01:12:57 <koz_> merijn: Well, I can implement length on the second instance by recursion, but that requires logarithmic stepping. I guess it's kinda inevitable though.
01:13:02 <merijn> koz_: The stuff you're trying to do with GADTs and type levels Nats I wouldn't be surprised if it's up to 12 before long :p
01:13:15 <koz_> merijn: Lol, all I wanted was a type-level balance guarantee.
01:13:16 <srhb> Plus some type checker plugins!
01:13:26 <koz_> srhb: Like Liquid Haskell or something? :P
01:13:43 <merijn> koz_: Something similar I did: https://gist.github.com/merijn/39dc86e345e87276c523
01:13:51 <srhb> I was thinking more like one of the plugins that makes the type checker understand algebra better. :-)
01:14:10 <merijn> koz_: The problem is that reifying type level constants to values is a bit painful and the reverse is FAR worse
01:14:33 <merijn> koz_: tbh, if you like playing with dependent stuff like this I'd probably recommend having a look at Idris/Agda
01:14:43 <merijn> Because stuff like this becomes trivial there :)
01:14:52 <toph> why am i forced to choose an indent mode for emacs haskell-mode?
01:15:00 <merijn> But if you insist on haskell have a look at the Hasochism paper/talk
01:15:09 <srhb> toph: Someone decided it was a good idea.
01:15:16 <koz_> merijn: I'm seeing this now.
01:15:31 <koz_> Hasochism ... lol.
01:15:59 <merijn> koz_: Also the singletons library and paper (which are also discussed in the Hasochism one, afaik)
01:16:42 <koz_> merijn: http://lpaste.net/162402#a162408 <-- is this the right idea?
01:17:25 <toph> srhb: i removed the hook, which works fine for 'return', but when lines auto-wrap (truncate-lines i think) get the annoying pop-up that haskell-mode-hook is nil
01:17:56 <merijn> koz_: Should work, yeah
01:18:07 <srhb> toph: Yeah.. Try #haskell-emacs
01:18:27 <koz_> merijn: Is this the best way to do this, or is there another alternative I should know?
01:18:30 <toph> ty
01:18:34 <merijn> koz_: You could try to use singletons to reify the height value directly from the type, but I think that has the same complexity
01:18:48 <merijn> koz_: Since converting a peano numeral to an integer would be linear :)
01:18:51 <koz_> merijn: Well, if that's the case, then I'll just leave it like this. It makes sense to me.
01:18:55 <srhb> toph: But haskell-mode is generally painfully inflexible and brittle.
01:18:59 <merijn> koz_: i.e. the same number of recursive steps as recursing down the height
01:19:08 <koz_> merijn: Yeah, that makes sense. Oh well. :(
01:19:19 <koz_> This next one is more philosophical.
01:19:35 <merijn> koz_: You could try to use the built-in Nat type of GHC, but it's facilities are...rudimentary
01:19:54 <koz_> I noticed that certain Foldable Monoids have partial 'minimum' and 'maximum' functions. I can choose to make my current structure a Monoid at that cost. Should I?
01:19:56 <merijn> koz_: In theory that'd allow more efficient reification, but I'm not sure you can actually get the GADT to work nicely that way :)
01:20:05 <koz_> I heard that partiality is generally not a Good Thing.
01:20:23 <merijn> koz_: Partiality is bad, minimum/maximum are a bit nasty in that sense
01:20:45 <merijn> koz_: You could add a dependency on semigroups and make it a semigroup
01:20:56 <koz_> merijn: I suspect that's a better idea.
01:21:04 <merijn> Actually...I'm not sure you can :)
01:21:15 <koz_> merijn: Yeah - that typelevel marker.
01:21:22 <merijn> Since "(<>) :: a -> a -> a" which doesn't work with the type level marker :)
01:21:31 <koz_> Oh well. :(
01:21:45 <koz_> Guess that answers *that*, because if they can't be a Semigroup, they can't be a Monoid either.
01:23:05 <koz_> Although I'm pretty happy that this stuff is starting to make sense to me, yay!
01:23:34 <merijn> koz_: :)
01:26:44 <koz_> merijn: OK, is hlint just not smart enough, or did I miss something here: http://lpaste.net/162409
01:27:33 <koz_> The whole point of me defining this elaborate scheme was to typelevel-guarantee that people don't try fusing together Nodes of different heights.
01:29:25 <merijn> koz_: Hlint is dumb and *certainly* doesn't deal well with GADTs
01:29:43 <merijn> Hell, GHC itself is bad at dealing with GADTs and exhaustiveness :p (Should be better in 8.0)
01:30:02 <koz_> merijn: OK, well, luckily I could redraft that problem away.
01:31:00 <koz_> Although that *seems* to be OK for some other functions and hlint.
01:31:02 <koz_> Weird.
01:33:07 <koz_> merijn: Sorry to keep harassing you, but I'd like some advice here: http://lpaste.net/162410
01:33:13 <koz_> (the title says it all really)
01:34:06 <merijn> koz_: Not really
01:34:13 <koz_> merijn: Sadface.
01:34:29 <merijn> At least, not without the generalisation costing you more effort and code than the duplication :p
01:35:02 <koz_> merijn: I had the feeling that was the case. However, Haskell's pretty magical, so I wanted to check anyway.
01:35:03 <lyxia> xor the condition with a Bool argument
01:35:23 <lyxia> return an ordered pair
01:35:49 <koz_> lyxia: Didn't think of an ordered pair actually - thanks!
01:36:03 <lyxia> yw
01:36:14 <jophish> Be sure to consider if saving a small amount of duplication over two lines is actually making things clearer/easier to maintain than just keeping it as is
01:36:31 <koz_> Also, merijn: Do I understand correctly that I can't put a (Node Zero) and a (Node (Succ Zero)) into a list together?
01:37:04 <hackrilege> Cale, I did what you suggested, but im having trouble writing the instance, here is the bug now http://lpaste.net/
01:37:23 <hackrilege> http://lpaste.net/162411
01:39:22 <paolino_> koz_,  Zero and (Succ Zero) must have same type
01:39:48 <hackrilege> if i insert the necessary constraint, it complains that it cant see that [] has a Stack instance...
01:39:55 <koz_> paolino_: They do - Natural. So I'd need a list of (Node Natural)s, then?
01:39:57 <koz_> OK, that helps.
01:40:12 <hackrilege> No instance for (Zipable Free (Zipper []))
01:40:40 <hackrilege> > instance (Stack s,Zipable z s,Zipable Free (z s)) => Zipable ZipperN s where
01:40:43 <lambdabot>  <hint>:1:1: parse error on input ‘instance’
01:41:23 <koz_> Also, when I export a type from a module, do its instances go with it?
01:41:37 <koz_> (I assume they do, but I wanted to check)
01:42:36 <merijn> koz_: Instances are always exported, even if you don't export a type
01:42:46 <merijn> koz_: Instances are global
01:42:56 <koz_> merijn: OK, that's nice to know.
01:44:16 <merijn> Semi-off-topic, but since this place is usually my most reliable source. What's a good survey of/intro to relational calculus?
01:48:04 <koz_> merijn: I'm trying to write 'data List a = List [Maybe (Node Natural a)]', but I get a kind error that makes zero sense.
01:49:34 <merijn> Natural is wrong for your current Node type
01:49:42 <koz_> merijn: Oh?
01:49:51 <merijn> Natural is the *kind* of types your Node type takes as argument
01:50:05 <koz_> merijn: So what should it be?
01:50:07 <merijn> So it'd be more like "data List n a = List [Maybe (Node n a)]
01:50:33 <merijn> Or you'd have to use some sort of existential (for which, consult the Hasochism paper, I believer they have an example using red-black trees)
01:50:35 <koz_> Oh, so I have to feed the type marker to anything I wrap these with too?
01:51:30 <merijn> koz_: Yes
01:51:40 <koz_> merijn: That's ... actually a *good* thing.
01:51:40 <merijn> Unless you take an existential approach to hide it
01:52:59 <mathu> i'm using do notation and i want to do some non-monadic computation with intermediate results. is there a way other than e.g. `outcomes <- return (zipWith (-) aRolls dRolls)` ?
01:53:20 <koz_> mathu: Use let.
01:53:31 <koz_> That means you don't have to monadically wrap whatever pure thing you did.
01:54:30 <mathu> koz_: aRolls and dRolls here were left-arrow-assigned, would computations with them still be pure?
01:54:42 <Lovepon> mathu: Good afternoon, onii-chan. :3
01:55:01 <Lovepon> 'w'
01:55:11 <Lovepon> mathu: Yes, they're still pure.
01:55:29 <amnn> mathu, just use a let binding
01:55:39 <mathu> alright
01:55:48 <mathu> i had that earlier but it looks ugly haha
01:55:49 <sinelaw> hey, how can I find who imported an instance?
01:55:52 <amnn> `let outcomes = zipWith (-) aRolls dRolls` exactly where you would have put the line you gave
01:56:46 <koz_> merijn: Sorry I keep harassing you with questions. Here's a description so as not to chan-flood: http://lpaste.net/162412
01:58:14 <Lovepon> mathu: Also, it's a special case(?) that in do-notation, you don't have to have a corresponding `in` for a `let`.
01:59:52 <mathu> amnn: somewhere where aRolls and dRolls are in scope haha
02:01:31 <mathu> amnn: because where clauses are out, i was using outcomes <- return $ zipWith...
02:01:39 <mathu> amnn: but a let is much better
02:02:28 <merijn> mathu: Everything is pure in haskell. Calling monadic code "impure" is a common misconception.
02:02:46 <amnn> mathu, just to be clear, I mean a let binding like this: http://lpaste.net/162413
02:02:53 <merijn> The entire point of haskell is that it's impossible to write impure code (well...barring the use of unsafePerformIO...)
02:03:06 <amnn> note, no `in`, as  Lovepon said
02:03:38 <merijn> koz_: Maybe this provides some inspiration? https://gist.github.com/merijn/dc00bc7cebd6df012c5e
02:03:48 <merijn> koz_: You can define weird GADT lists too :)
02:04:29 <koz_> merijn: What is '[*] -> *' even?
02:04:52 <amnn> koz_ type level list
02:04:59 <merijn> koz_: Taking a type level list of types and returning a type :)
02:05:00 <mathu> merijn: yeah, i typically only here it in reference to IO() and such, but somebody said "monadically wrapping my pure thing" so i just used their terminology
02:05:03 <mathu> merijn: thank you for correcting
02:05:13 <mathu> s/here/hear/ wow it's 5am already
02:06:02 <koz_> Ah, I see.
02:06:14 <koz_> I think what I wanna do is quite similar to this, but this is making my brain hurt.
02:06:22 <merijn> :)
02:06:36 <koz_> merijn: My main question is how to set up my weird list's equivalent of Nil.
02:06:52 <koz_> Since that'd need a type marker, but Zero would be taken right at the start.
02:07:01 <koz_> So would I need a Nil of *every* type marker?
02:07:39 <merijn> koz_: You could have "Nill :: MyList (n :: Natural)", i.e. Nil works for any natural type
02:08:10 <koz_> Would that basically be 'a Nil of every type marker' as above?
02:08:27 <amnn> what happens if you cons a new element on at the beginning?
02:08:32 <amnn> then the type of the Nil changes
02:08:39 <merijn> koz_: Yeah
02:08:45 <koz_> amnn: The type of *everything* would need to cascadingly change.
02:08:47 <merijn> amnn: oh, good point
02:08:50 <merijn> That's painful
02:09:03 <merijn> koz_: It would be easier to sort your list in reverse, i.e. have 0 at the end
02:09:06 <koz_> (however, I plan to only add elements at the *end*)
02:09:18 <koz_> Or that.
02:09:29 <merijn> Then your problem becomes trivial :)
02:09:31 <amnn> yes, having zero at the Nil end is the best bet
02:09:39 <amnn> GADTs can deal with that for you
02:10:31 <koz_> merijn and amnn: I basically plan for this weirdo-list to 'grow' only by appends, not conses.
02:10:45 <koz_> So the idea is that things get stuck on the *end*, not the beginning.
02:10:56 <koz_> (at least, that's the way it'll get used)
02:11:19 <amnn> koz_, if you only add to one "side", then what difference does it make whether it's the beginning or the end?
02:11:40 <koz_> amnn: You make a valid point - I assume doing so at the beginning is more sanity-preserving?
02:11:56 <amnn> indeed, plus more efficient at runtime too
02:12:52 <koz_> amnn: OK. I guess I can cheat this by having Nil be Zero'd, and then have (Maybe Node n a)s live in the (Succ n) 'position'?
02:16:51 <ocramz> how do I point ghc-mod to a different GHC path?
02:18:17 <koz_> amnn and merijn: http://lpaste.net/162412 <-- what did I forget here?
02:19:08 <ocramz> I've just compiled the latest version with the GHC of interest, restarted Emacs, but when I fire up an interactive session ghc-mod still uses the previous GHC
02:19:29 <srhb> ocramz: Doesn't it just use the one on path?
02:20:02 <ocramz> srhb : that's what I also thought; the new GHC is on path but seemingly it uses a hardcoded one
02:20:59 <merijn> ocramz: ghc-mod is using GHC-as-a-library
02:21:10 <merijn> ocramz: You can't point it at a different GHC as ghc is built into it
02:21:18 <lyxia> koz_: you declared the IndexList type to have two parameters, but you gave it only one
02:21:35 <ocramz> merijn: uhm ok good to know, thanks
02:22:04 <koz_> lyxia: But isn't the normal List defined something like 'Nil | Cons a (List a)'? I was trying to go for something similar, but I think I failed someplace.
02:23:14 <lyxia> koz_: The first line declares "IndexList a b", but then you use it like "IndexList a"
02:24:02 <koz_> lyxia: How would I go about writing something similar to a normal list's 'Nil' then in this case?
02:24:06 <koz_> Because I'm not sure.
02:25:04 <lpaste> lyxia revised “No title”: “Fixed for koz_” at http://lpaste.net/162412
02:25:32 <koz_> lyxia: Thanks!
02:25:43 <koz_> Oh, *derp*. Thank you!
02:26:29 <lyxia> yw
02:26:43 <koz_> Also, this is probably *the* hardest Haskell I've yet written. Am I insane?
02:27:17 <lyxia> not yet
02:27:25 <amnn> it's not a trivial concept, nor does haskell make it particularly easy, so I think you're fine
02:28:25 <koz_> amnn: Well, let's hope I learn something from this, then.
02:28:31 <koz_> (although I feel like I have learned something)
02:28:45 * koz_ is listening to Final Fantasy battle themes while doing this.
02:29:13 <merijn> koz_: This moving into fairly advanced type level voodoo, so if it's the first time you attempt it then utter confusion is to be expected :)
02:29:48 <koz_> merijn: If anything, I'm surprised how *un*confused I am.
02:30:00 <koz_> Like, the stuff does make sense - I just have to think about it slowly.
02:31:17 <merijn> koz_: That's because most of the design of haskell and extensions is surprisingly sensible and well thought out :)
02:31:45 <merijn> Once you've managed to twist your brain into the right perspective :)
02:32:36 <koz_> merijn: I'm sure it is - my brain just can't handle its sensibility and well-designedness sometimes. :P
02:37:07 * koz_ just had to use fmap . fmap for the first time in non-trivial code.
02:38:24 * hackagebot stack 1.1.0 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.1.0 (borsboom)
02:42:34 <_abp> localMaxima' :: [Integer] -> [Integer]
02:42:35 <_abp> localMaxima' (x:y:z:zs)
02:42:36 <_abp>   | x < y && y > z = y : localMaxima' (y:z:zs)
02:42:37 <_abp>   | otherwise      = localMaxima' (y:z:zs)
02:42:38 <_abp> localMaxima' _ = []
02:43:17 <koz_> :t foldr
02:43:18 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
02:43:37 <_abp> if localMaxima’ [1,2,3,4,5,6] is called, then x, y, z and zs match to 1,2,3 and [4,5,6] respectively
02:44:11 <_abp> then it will proceed to otherwise guard, so localMaxima’ (y:z:zs) is matched, but how does this work now?
02:45:23 <_abp> ie. localMaxima’ (2:3:[4,5,6]) wouldn’t match onto localMaxima’ (x:y:z:zs)?
02:46:50 <mpickering> yes it does
02:46:53 <lyxia> [a,b,c...] is just sugar for a:b:c:...
02:47:07 <ski> > 2:3:[4,5,6]
02:47:09 <lambdabot>  [2,3,4,5,6]
02:47:09 <mpickering> x=2, y=3, z=4, zs=[5,6]
02:47:15 <lyxia> 2:3:[4,5,6] = 2:3:4:5:6:[]
02:48:24 <_abp> Oh I see now
02:48:30 <ski> _abp : instead of `x:y:z:zs', you could say `x:ys@(y:z:_)', and then say `ys' instead of `y:z:zs'
02:50:04 <ski> _abp : that would be a hint to an implementation to not reallocate the two manifest cons cells in `y:z:zs'
02:51:24 <ski> but you can also think of it in terms of readability, abbreviating away a repeated expression, by providing an explicit name for the pattern identical to them
02:52:48 <_abp> ski: what do you mean ‘not reallocate the two manifest cons cells’?
02:53:40 <merijn> Operational details :)
02:54:02 <ski> a naive implementation would reallocate the two `:' cons cells in `y:z:zs', in your recursive calls, instead of simply reusing the `y:z:zs' part of the input, which should behave the same way
02:54:24 <ski> (a non-naive implementation could perhaps also reallocate, depending ..)
03:23:36 <hackrilege> wow this bug totally sucks, can anyone give me any clues!? i have never seen anything like it
03:23:37 <hackrilege> http://lpaste.net/162418
03:26:41 <hackrilege> its a coersion error in NewTypeDeriving
03:28:26 <EvanR> just looked at your error
03:29:07 <EvanR> but i dont know generalized newtype deriving, so my head exploded
03:31:39 <bennofs> hackrilege: can you reduce the example so that there is less unnecessary code?
03:33:13 <hackrilege> erm... not quickly
03:33:54 <hackrilege> im not sure really why the Comonad instance throws an error but the others dont...
03:38:17 <hackrilege> because so many various instances are required id go so far as to say most of this code is necessary to find this bug... if it really is particular to Comonad anyway..
03:39:11 <hackrilege> coersion of representational to nominal?
03:39:23 <hackrilege> anyone seen or heard of that before?
03:40:12 * ski idly wonders why "representational" wasn't called "structural"
03:45:52 <hackrilege> ski, any idea why this deriving Comonad is going wrong?
03:46:06 <hackrilege> http://lpaste.net/162418
03:49:59 <dibblego> Free is not a Comonad by the way
03:50:06 <dibblego> Cofree is
03:52:03 <dominik_> is there any benefit of defining lists as a fixpoint of functors (e.g., as data ListF a r = NilF r | ConsF a r) instead of a standard recursive datatype?
03:52:35 <dominik_> in other words, defining lists via such a general recursion scheme, what are the goddies?
03:52:49 <bennofs> dominik_: you get some functions, such as folding, for free (they can be defined in general for all fixedpoints of any functor)
03:53:21 <dominik_> bennofs: which one's in particular?
03:53:27 * hackagebot hpc 0.6.0.3 - Code Coverage Library for Haskell  https://hackage.haskell.org/package/hpc-0.6.0.3 (HerbertValerioRiedel)
03:53:39 <dominik_> and is there any particular source I could read up on fixedpoints of functors?
03:54:26 <sebben> hey, I'm going through GADTs, and I can't find much info on :::, are there any good resources on this?
03:54:33 <bennofs> dominik_: http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/ is good IMO
03:55:09 <bennofs> sebben: (:::) is not specific to GADTs. Some libraries define it though. Which library are you using?
03:55:48 <sebben> Each of these: LANGUAGE GADTs, EmptyDataDecls, TypeFamilies, TypeOperators, DataKinds, FlexibleInstances
03:56:00 <sebben> I think it has something to do with cons, lists?
03:56:03 <lyxia> hackrilege: perhaps you can add some role annotations to make the second parameter of Zipper representational
03:56:30 <bennofs> sebben: those are language pragmas. What are your imports?
03:56:51 <bennofs> sebben: (:::) is a symbol that is imported from some library, it is not provided by language pragmas 
03:57:09 <sebben> what's that? if you don't mind me asking
03:57:18 <sebben> These pragmas
03:57:34 <sebben> Still unfamiliar with all the terminology
03:58:03 <bennofs> sebben: that's the things you just listed: GADTs, EmptyDataDecls, TypeFamilies, ... are all called "language pragmas" (because you enable them with {-# LANGUAGE ... #-}) 
03:58:09 <sebben> Also, do you have any tips for googling haskell terms? It sounds kind of basic but I really can't manage to find what I need
03:58:18 <sebben> oh, I see
03:58:20 <bennofs> sebben: try http://hayoo.fh-wedel.de/
03:58:41 <bennofs> sebben: for example, there's several definitions of (:::): http://hayoo.fh-wedel.de/?query=%28%3A%3A%3A%29
03:58:44 <hackrilege> thans lyxia, i can get some good referencec material with those keywords
04:00:26 <lyxia> hackrilege: I just read about it here https://ghc.haskell.org/trac/ghc/wiki/Roles I haven't looked elsewhere
04:01:31 <hackrilege> omg!
04:01:33 <sebben> Do you know of any beginner friendly search engines for haskell? Hayoo and Hoogle both don't really make much sense to me at the moment :/
04:01:39 <hackrilege> GADTs!!!
04:02:07 <hackrilege> nooo, run away!
04:02:55 <hackrilege> sebben, Hackage is good, google will direct you to the Modules hosted there
04:04:10 <hackrilege> what do you want to do with the search engine? its useful to be able to search by type, no?
04:05:48 <sebben> I just keep running into syntax and operators which don't quite make sense. I guess more concrete examples might help, so I could cross reference and understand it better?
04:06:23 <sebben> I've been reading learn haskell for great good, but there's a lot of things that aren't covered in it
04:06:24 <bergmark> sebben: stackage's hoogle has a lot more packages than normal hoogle: https://www.stackage.org/lts-5.15/hoogle?q=%s
04:07:54 <sebben> Ah! this one looks a lot more promising, thank you! I'll have a look
04:08:44 <bergmark> ... and assuming you are using a stackage snapshot you will also get matching versions there
04:21:09 <cocreature> there is also hoogle5 http://hoogle.haskell.org/ which indexes all of stackage
04:24:44 <ralu> is this hoogle updated?
04:52:51 <paolino_> anyone has an idea to refactor the repeated "combineDynWith" block, to make it more readable ? http://lpaste.net/162419
05:01:08 <amnn> paolino_, make it an applicative instance?
05:01:39 <amnn> it's not immediately obvious what `combineDynWith` is doing
05:02:30 <paolino_> amnn, combineDyn  :: (Reflex t, MonadHold t m) =>     (a -> b -> c) -> Dynamic t a -> Dynamic t b -> m (Dynamic t c)
05:03:34 <paolino_> Dynamic is not a functor if that matters
05:04:07 <amnn> paolino_, is it the case that it's not a Functor *yet*, or is there no legal definition?
05:05:10 <paolino_> don't know, I think there is a technical problem in reevaluation or something
05:06:06 <amnn> ah, this is Typeable's Dynamic
05:06:19 <paolino_> no
05:06:26 <amnn> oh...
05:06:31 <paolino_> it's from Reflex package
05:08:29 * hackagebot http-proxy 0.1.0.1 - A library for writing HTTP and HTTPS proxies  https://hackage.haskell.org/package/http-proxy-0.1.0.1 (ErikDeCastroLopo)
05:11:43 <bblfish> just read this very nice article on sums and products of monoids (in Scala) http://blog.higher-order.com/blog/2014/03/19/monoid-morphisms-products-coproducts/
05:12:22 <bblfish> It's a really good example, as monoids are such a simple structure, that seeing the difference between sums and products in sets and monoids is really enlightening.
05:13:00 <bblfish> It's kind of weird that products in monoids are very similar to products in sets - their just pairs - whereas they are quite different for sums.
05:13:11 <StarsC> what is best structure to keep large text files in memory? we are talking 100M text file.
05:13:33 <bblfish> Any good example of sums of monoids in the real world?
05:15:44 <StarsC> monoid sums, whole structure is monoid
05:15:53 <StarsC> not each element
05:16:59 <c_wraith> StarsC, do you need to operate on it as text, or just store and forward? 
05:17:52 <bblfish> SrarstC, yes Runar represents the sum of a monoid as a List of Eithers' with some folding operation.
05:18:16 <bblfish> I meant StarsC 
05:18:30 * hackagebot leveldb-haskell 0.6.4 - Haskell bindings to LevelDB  https://hackage.haskell.org/package/leveldb-haskell-0.6.4 (KimAltintop)
05:20:17 <c_wraith> StarsC: if you're just storing the data to output again, treating it as a binary blob and using Bytestring is a good approach.
05:21:01 <c_wraith> StarsC: if you are doing other operations, you might want to store it as Text, or maybe a rope of Text objects, or several other possibilities, depending on what operations you want to be fast.
05:27:02 <StarsC> c_wraith: ty, im trying to store it as a sequence of Text => Data.Sequence+Data.Text, is it bad approach?
05:27:22 <StarsC> c_wraith: yes i would like to manipulate it
05:27:34 <StarsC> c_wraith: my current result is 900mb of memory
05:27:43 <c_wraith> StarsC: Data.Sequence isn't the most memory-friendly.  That's fine if the number of blocks is small, but if you end up with hundreds or thousands of blocks, it gets bad.
05:28:12 <StarsC> c_wraith: i have 2 million Text elements, average length 35
05:28:34 <bblfish> Ah I see the Haskell version of sums of monoids is structured similarly https://hackage.haskell.org/package/monoid-extras-0.4.0.4/docs/Data-Monoid-Coproduct.html
05:28:36 <c_wraith> StarsC: also, be aware that Data.Text uses UTF-16 internally.  So a 100mb ascii source becomes 200mb of RAM
05:28:52 <dominik_> bennofs: belated thanks for your pointer!
05:29:03 <c_wraith> StarsC: Ok, at an average length of 35 characters, Data.Sequence isn't great. :)
05:29:09 <StarsC> c_wraith: im storing FilePathes can i swithc to utf8? somehow?
05:29:30 <c_wraith> StarsC: heh.  depends on the OS.  windows file paths are UTF-16
05:29:32 <StarsC> c_wraith: but i got the feeling list is even worse
05:29:59 <c_wraith> StarsC: unix file paths are..  umm..  a sequence of bytes, not in any encoding.
05:30:04 <StarsC> c_wraith: im currently on linux
05:30:28 <StarsC> c_wraith: yes i looked into Posix.Files.Bytestring
05:30:37 <StarsC> c_wraith: to understand better how its stored
05:30:37 <c_wraith> The shell might treat them as being in an encoding, but the file system itself does not
05:31:08 <StarsC> c_wraith: so what is my choice if not Data.Sequence? something very shallow on memory
05:31:28 <c_wraith> I think the real issue you're trying to solve is that you have 2 million independent pieces of small data.
05:31:38 <StarsC> im fine with 200mb initial size because of Text
05:32:00 <StarsC> c_wraith: yes , i had idea to fuse them in one blob of text :)is it naive?
05:32:25 <StarsC> then search filter probably will be pain.
05:32:34 <c_wraith> StarsC: Eh, if you need to keep an index of where things are for fast lookup, it's just as bad
05:32:38 <fr33domlover> Looking for advice: I'm writing a web app, which among other things shows files and history of darcs repos. The darcs package can do these things but all the functions there change the working dir to the repo and operate from there. Is it safe in a concurrent context like a web app? What if 2 handlers serve 2 different darcs repo view pages at the same time etc.? DarcsDen does this and seems fine but... i
05:32:40 <fr33domlover> dunno, sounds dangerous :P
05:33:24 <c_wraith> StarsC: What is the use case with these file paths?  What operations are you doing on the aggregate?
05:34:49 <maerwald> fr33domlover: no, it's not safe
05:34:59 <maerwald> and that's also the reason darcsden sometimes throws weird errors
05:35:38 <StarsC> c_wraith: use case is various filtering and IO actions, like quering for size and last modification date
05:35:40 <maerwald> the solution is to use absolute filepaths everywhere in darcs, but that's pretty much a major change deep into the codebase
05:35:43 <fr33domlover> maerwald, would it make sense to ask darcs to fix it or make a patch? it's quite a big change, the entire codebase seems to rely on the working dir being the repo
05:35:44 <maerwald> so not sure if that will happen
05:35:49 <maerwald> I already asked them
05:36:13 <fr33domlover> maerwald, what did they say?
05:36:19 <maerwald> what you just said :P
05:36:27 <c_wraith> StarsC: what operations do you need to be fast?  Checking for the presence of a value?
05:36:29 <maerwald> major change, not priority, patches plz
05:37:21 <fr33domlover> hmmmm i see
05:37:42 <fr33domlover> i'll try to look into it, but... it's probably too huge to be worth it for me right now :P
05:37:53 <maerwald> darcs codebase is odd, good luck :P
05:38:06 <fr33domlover> i'm using 'hashed-storage' and 'process' as a workaround for now
05:38:33 <StarsC> c_wraith: yes
05:38:41 <fr33domlover> darcs codebase also uses String a lot where it could use ByteString and Text... :P
05:38:45 <c_wraith> StarsC: anything else?
05:38:50 <StarsC> c_wraith: for startes i just want to understand how to put structure of this size in memory
05:39:41 <StarsC> c_wraith: some estimates say that u get rather big overhead per element in lists
05:40:09 <c_wraith> StarsC: ok.  Minimal memory overhead would be a Data.Vector of values.  But individual Text or Bytestring values have enough overhead to be painful when there are millions of them, too.
05:40:31 <c_wraith> Both support O(1) slicing, which means that they keep two extra pointers around per value.
05:40:33 <StarsC> c_wraith: Vector of Vectors?
05:41:09 <StarsC> c_wraith: ty, u reminded me, one more thing is that this structure has to be foldable and traversable
05:41:39 <StarsC> maybe Vector is
05:41:58 <merijn> How to put structures this size in memory? Good file format + mmap :p
05:42:02 <c_wraith> Is that an absolute requirement, or would Traversals from the lens package do the job?
05:43:01 <StarsC> c_wraith: i guess traversable alone is good
05:43:14 <StarsC> c_wraith: i would neet to do filterM on it, thats why
05:43:32 <StarsC> merijn: file is text
05:43:32 <c_wraith> Well, Traversable is a superset of Foldable, so that's not really a loosening. :)
05:43:43 <StarsC> :D
05:44:38 <merijn> StarsC: Doesn't stop you from mmap'ing as bytestring, it just makes your life more difficult for text operations :p
05:44:53 <StarsC> c_wraith: if it helps there can be nesting, well repeating directory structure, so concat is used, thus structure can become nested
05:45:46 <c_wraith> StarsC: In that case, you might be able to save a good chunk of memory by using a Trie - shared prefixes would only be stored once.
05:47:18 <c_wraith> Still, at 2 million entries, the pointers are going to add up.
05:48:02 <StarsC> c_wraith: isnt Data.Sequence a tree?
05:48:13 <c_wraith> StarsC: Tree and Trie are not the same. :)
05:48:24 <StarsC> c_wraith: ups, sorry :)
05:48:47 <c_wraith> (despite officially being pronounced the same - one of the weirdest decisions ever)
05:49:00 <StarsC> c_wraith: can u suggest library for Trie type? i would upgrade to it from Data.Sequence, lets see if it helps
05:49:30 <StarsC> so at this rates decision to store each element as Text is also bad, right?
05:49:34 <StarsC> these*
05:51:00 <c_wraith> Unfortunately, the overhead on Text is significant at that point.  On a 64-bit build of GHC, each Text value has like 32 bytes of overhead
05:52:14 <infinity0> suppose I have a main that does a getLine inside itself, how do I write another main' that cats a string "xxx" into main?
05:52:16 <StarsC> so its just 64 mb overhead, not so bad
05:52:27 <infinity0> (i can't change the source code of the original main)
05:52:27 <StarsC> if trying to reduce from 1gb :)
05:52:30 <c_wraith> I suppose that's not so bad.
05:53:38 <c_wraith> My suggestion, then, is to try storing in a sorted Vector, and using a binary search from the vector-algorithms package for lookups
05:54:17 <c_wraith> There's something to be said for just flattening things as much as possible.
05:54:17 <mattro> infinity0: do you just want to putStrLn? that writes a string to stdout
05:54:43 <infinity0> mattro: no i have a 'main :: IO' that i want to putStrLn into, as opposed to putStrLn going to /dev/stdout
05:55:07 <infinity0> like `echo "xxx" | main` in shell script
05:55:23 <infinity0> i was wondering if that's possible in haskell. yes if i controlled "main" i would just use "pipes" instead of IO
05:55:58 <mattro> infinity0: hPutStr stdin, is maybe what you want
05:56:04 <StarsC> c_wraith: ty for your help, was useful, i will try vector
05:56:22 <merijn> infinity0: Sounds like you just want a pipe
05:56:56 <merijn> infinity0: Basically you have two programs and want one's output to be the input of the other?
05:57:14 <merijn> Should be fairly simple using the process library
05:57:57 <infinity0> ah i was hoping there would be something more lightweight, but ok i'll have a look thanks
05:58:20 <infinity0> yes Pipes would indeed be better if that was an option, but i can't change one of the IOs
05:59:18 <bblfish> In the scala akka library there are some really interesting constructs that use streams with backpressure for web services
05:59:38 <infinity0> mattro: can't write to stdin, it just gives me an exception
06:00:23 <merijn> Well duh, stdin is read only :)
06:00:53 <mattro> infinity0: what exactly are you trying to do, what library / program are you trying to interact with?
06:05:31 <infinity0> i have an IO that i'm trying to test via doctest, which doesn't let you give input to an IO ... but it's ok, i realised i can refactor the getLine out of that, and do something like "main = main' getLine", but "main2 = main' (return "some input")" in my doctest
06:06:02 <infinity0> (i can change it, i just didn't want to change it so much to use pipes becuase that would defeat the point of the example code)
06:06:06 <c_wraith> StarsC: vector-algorithms might not be useful, since it only works with mutable vectors.  But I'd check out a sorted vector for memory use, just the same.
06:06:21 <StarsC> c_wraith: ty!
06:30:36 <kantokomi> Are there any books or other good resources for learning haskell? Assuming I have studied a lot of category theory before and know my maths very well.
06:31:38 <kantokomi> I can find a lot of resources going the other way. Category theory for programmers etc, but that's not what I'm looking for
06:31:58 <merijn> kantokomi: The category theory will basically be zero help. Math might help if you did logics and lambda calculus and type theory (I suppose a bit of algebra helps)
06:33:19 <merijn> And the good books for learning haskell would be the same as for others. I heard bitemyapp's haskell book is finally complete and getting ready for the final edit
06:33:31 <merijn> kantokomi: https://github.com/bitemyapp/learnhaskell for resources
06:33:43 <hpc> @where rwh
06:33:44 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:33:58 <hpc> for another resource
06:35:03 <kantokomi> I've studied lambda calculus some years ago, and have been studying algebra for about 4 years. Thanks for the suggestions.
06:36:16 <kantokomi> I was hoping there was some resources on haskell where most of it is explained through categories, but such resources might not exist
06:36:23 <hpc> by "studying algebra", i assume you mean in the hardcore math "what are the implications of the algebraic laws" sense and not in the high-school "here's how to solve equations" sense?
06:36:43 <hpc> oh, you do
06:36:47 * hpc lrns2scrollback
06:36:48 <kantokomi> Yes, category theory, representation theory etc
06:37:22 <hpc> what other programming do you know?
06:37:49 <kantokomi> I've mostly programmed in C, but also Python
06:37:57 <kantokomi> C++ lately
06:38:10 <hpc> ah nice
06:39:53 <hpc> you should be fine then, since you know some programming already as well as some theory
06:40:08 <hpc> and lambda calculus which is in some ways in-between
06:42:01 <gpyh> hi
06:42:26 <hpc> ooh, that github page is very thorough
06:45:01 <chattered> My brother's been struggling to learn Haskell, and I'm still not sure what to recommend him. He's only done Python, before, but mostly uses it for simple structured programming.
06:45:31 <srhb> chattered: What about the learnhaskell resources?
06:45:56 <chattered> He interacts a bit with bitemyapp on twitter, and I think his next plan is the Haskell book.
06:46:15 <hpc> chattered: this channel is a great place to get specific help, if he already is going through another resource and still having trouble
06:46:28 <srhb> chattered: Sounds like there's no problem then :-)
06:46:57 <chattered> srhb: Well, he gave up on LYAH, which I don't think is particularly well pitched for beginners.
06:47:05 <chattered> Hopefully, HB is better.
06:47:52 <srhb> chattered: Definitely.
06:48:36 <hpc> it took me a month to get through LYAH when i was learning
06:52:21 <tpsinnem> hm, i don't immediately understand what's going on with createProcess from System.Process. I'm passing it a 'proc foo bar' as the CreateProcess argument, which uses 'Inherit' for its stdin, stderr etc. but the return value has a 'Nothing' for its stderr component (i haven't checked stdin or stdout)
06:52:52 <tpsinnem> which suggests that i've misunderstood what it means here to 'inherit' the handles from the parent process
06:53:29 <tpsinnem> the calling process has a 'stderr', does it not?
06:53:56 <geekosaur> tpsinnem, it has the same stderr that you already have as your stderr
06:53:59 <tpsinnem> so why do i get a Nothing instead of a Just err
06:54:01 <geekosaur> why should it be reyirned?
06:54:07 <geekosaur> *returned
06:54:21 <merijn> tpsinnem: "Inherit" means "the child writes to the same stdin/stdout as the parent"
06:54:45 <merijn> tpsinnem: It only returns newly created handles, i.e. CreatePipe
06:54:49 <tpsinnem> ok
06:54:52 <geekosaur> more to the point: it returns a handle if that handle is connected to a pipe for you to read from. in this case it is writing to the same destination that your stderr handle does; you cannot intercept this
06:55:16 <hpc> and even if it did return stderr it wouldn't be usable - the output is already being consumed
06:55:25 <tpsinnem> ok thanks geekosaur merijn and hpc
06:55:26 <merijn> tpsinnem: Additionally a process can't read from it's own stdout/stderr
06:55:48 <geekosaur> "usually"
06:55:50 <merijn> tpsinnem: If you process has to parse/deal with output from the child process, use CreatePipe
06:56:13 <geekosaur> (and the ones that can, don't do what you might think)
06:56:24 <hpc> (this explanation is pretty much 2/3 of a POSIX IO tutorial)
06:56:49 <merijn> geekosaur: You're thinking of a socket as stdout?
06:57:28 <geekosaur> (1) controlling tty is opened O_RDWR as fd 0 and dup()ed to 1 and 2; so you can "read" from stderr but you're actually reading stdin
06:57:45 <hpc> wait what
06:58:11 <merijn> That's a detail of tty's I didn't know, but which makes sense (for some value of sense) in hindsight
06:58:28 <merijn> hpc: ttys are just like sockets bidirectional endpoints (and voodoo)
06:58:31 <geekosaur> (2) systems that use socketpairs for pipes (the *BSDs mostly) actually have bidirectional ipes. usually there's nothing there to read for stderr, but a very few programs (like freebsd's dump) actually use bidirectional socketpairs
06:58:33 <gpyh> I am having trouble understanding how I can use DataKinds
06:58:53 <gpyh> defining types is OK, but using function that return them is beyong my understanding
06:59:11 <gpyh> I've written a full-fledged question here: https://gist.github.com/gpyh/a47a09fa05f47767e7dcc05cd41b29cb
06:59:11 <merijn> gpyh: Functions can't return types defined using datakinds
06:59:29 <merijn> gpyh: Functions can only return values and values ALWAYS have types of kind * in haskell
06:59:44 <gpyh> I know this
06:59:50 <gpyh> I don't want to return a type
07:00:00 <gpyh> I want to return a value, but of unknown type
07:00:07 <merijn> Oh
07:00:13 <merijn> Yeah, that requires dependent types
07:00:17 <merijn> Haskell doesn't have those
07:00:24 <hpc> yet
07:00:32 <merijn> You can use extremely painful existential hacks to work around it or give up
07:00:40 <merijn> gpyh: Consult the Hasochism paper for details
07:01:06 <gpyh> I don't know if I should laugh of be frightened by that name :p
07:01:08 <hpc> or if you haven't tried a DT'd language yet, i recommend taking a detour to agda or idris sometime
07:01:16 <gpyh> I did some Idris
07:01:27 <gpyh> some I am doing a real life project
07:01:33 <hpc> ooh nice
07:01:42 <gpyh> s/some/but
07:01:59 <gpyh> It's a TFTP server, so I need sockets and bytestrings
07:02:17 <gpyh> I fear that Idris libraries will be harder to learn and prone to bugs
07:02:29 <hpc> oh i see
07:02:29 <gpyh> thanks anyway!
07:03:12 <hpc> don't let it scare you away from idris permanently though, it has an FFI to haskell
07:03:35 <hpc> (also you get to be that guy who calls haskell low-level)
07:03:50 <gpyh> That's tempting
07:03:51 <geekosaur> heh
07:11:06 <geekosaur> huh. OS X has socketpair, but implements traditional pipes instead of using socketpairs
07:11:19 <geekosaur> (or at least claims so)
07:17:54 <ocramz> so, at last I decided to update my setup from 7.8.3 to 7.10.3 . I hose .cabal, .stack and .local/bin/ , `stack install ghc-mod`. Total Emacs breakage as a result (I'm using GHC for OSX btw). What is this `cabal-helper` and `cabal-helper-wrapper` thing? 
07:18:19 <ocramz> Is there a sane procedure for this?
07:19:01 <mpickering> cabal-helper is a bit weird
07:19:14 <mpickering> the idea is that it isolates the differences between different Cabal versions
07:20:22 <mpickering> why do you need to delete .cabal as well, there's no need to do that
07:21:05 <mpickering> in fact, you don't need to delete anything but too late now
07:21:10 <ocramz> Old stuff, gained some 4GB. I figured the best way is to rebuild all on a need basis
07:21:49 <mpickering> is the real question, how to get ghc-mod to work?
07:22:10 <ocramz> Yes, indeed.
07:22:26 <mpickering> What is the error?
07:24:20 <ocramz> ghc-mod not found, whereas it is in $PATH
07:24:58 <mpickering> ok, so the problem is emacs not finding the executable?
07:27:42 <infinity0> "class (StM m a ~ a) => Pure m a" -- what does the ~ mean
07:28:14 <geekosaur> type equality
07:29:01 <geekosaur> in this case, I think it's used to get around compiler complaints if you were to say Pure m (StM m a)
07:29:05 <geekosaur> (multiple uses of m)
07:29:30 <KaneTW> or StM could be a type family
07:30:10 <infinity0> hm ok i think i probably need to do more bg research, thanks for the pointers
07:30:14 <infinity0> i'm looking at this btw https://hackage.haskell.org/package/lifted-async-0.8.0.1/docs/Control-Concurrent-Async-Lifted-Safe.html
07:30:24 <hpc> what's StM?
07:30:37 <hpc> imo it's uncomfortably close to STM
07:30:45 <infinity0> it's defined on that page as "Monadic state of m."
07:31:14 <hpc> ah
07:32:46 <KaneTW> so yeah, it's a type fam
07:33:56 <hpc> i don't know if i am being bader-meinhoffed but i have been seeing type families everywhere recently
07:34:15 <ocramz> mpickering, I'm not sure anymore. I started by trying to update the `ghc-mod` Emacs package, but before re-compiling the corresponding one from Hackage. Clearly, compiler mismatch, `ghc-debug` complained. IDEA: delete all libraries, setup new compiler (ghc for OSX), and `stack install ghc-mod`. At this point, Emacs not only doesn't find ghc-mod (though it is in path), but also complains about a minor version mismatch (It must store
07:34:16 <ocramz> internally the GHC version used to build some parts). I am about to pull my hair out
07:34:50 <mpickering> I don't know sorry but you could ask in #ghc-mod
07:35:07 <ocramz> Sorry to bother you and thanks anyway
07:36:47 <ocramz> I just need working tools, not asking for much. Anyone got a Docker container with a working setup to share?
07:37:06 <ocramz> If that's what it takes..
07:56:01 <Mateon1> Hi, I'm having dependency issues with cabal. Namely, conflicts with old installed packages. I'm trying to install ghc-mod, but v5.5.0.0 has some conflict with installed transformers-0.5.0.0. I'm probably not even reading the output correctly to be honest... How can I fix it? (Paste with my console session: http://paste.ofcode.org/dqFHWJPwXxZ8j3szsnTsNq )
07:57:05 <maerwald> if you just need the binary, install it in a cabal sandbox
07:57:13 <maerwald> then make sure it's in your PATH
07:57:38 <Mateon1> maerwald: How does a sandbox work, in cabal?
07:58:14 <maerwald> Mateon1: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
07:58:37 <Mateon1> maerwald: Thanks
08:04:41 <Mateon1> I'm either not understanding sandboxes from what I skimmed over the article (quite likely), or something isn't working. "cd ~" "cabal sandbox init" "cabal install ghc-mod-5.5.0.0" yields the same issue. Is it necessary to edit the sandbox config file?
08:05:26 <geekosaur> Mateon1, sandboxes can't protect you from conflicting packages installed in the global package registry
08:05:33 <geekosaur> (yet)
08:05:55 <geekosaur> stack can do this, mostly by beating ghc over the head with a lead pipe >.>
08:06:00 <Mateon1> Honestly, I'm lost as to what I can do.
08:06:23 <Mateon1> geekosaur: I was using stack for a while, but it doesn't integrate nicely with an existing MSYS installation.
08:06:43 <c_wraith> Mateon1: sandboxes are really designed to be used with a single project at a time, not your whole user directory
08:07:21 <maerwald> c_wraith: correct and that's not what I was suggesting
08:07:21 <c_wraith> Mateon1: I understand your goal, but it wasn't a design goal of the sandbox system.
08:07:32 <maerwald> Mateon1: that link is for linux you have to adjust the commands for windows
08:07:37 <maerwald> probably
08:08:09 <maerwald> c_wraith: that's not his goal, he wants to install ghc-mod, which is perfectly fine in its own sandbox if you only need the binary
08:09:55 <Mateon1> I'm confused, should I fetch the contents of ghc-mod and try to hammer my way through the sandboxes, or ... ?
08:10:30 <maerwald> clone the ghc-mod repo, and make a sandbox in THAT directory
08:10:35 <maerwald> and install it within
08:11:20 <maerwald> but I can't give windows support, so no idea how you do that there
08:11:58 <Mateon1> The same as on linux, I have git on my box
08:13:15 <Mateon1> Gah, now it isn't transformers and ghc-boot, now it's monad-journal
08:14:07 <Mateon1> Does that mean that ghc-mod has inconsistent dependencies?..
08:23:36 <Mateon1> What are the fields in a cabal.config file? "constraints" isn't one, which the blog linked suggests using
08:24:22 <Mateon1> Nevermind, I typo'ed
08:31:34 <Mateon1> Apparently ghc-mod doesn't like ghc 8.1...
08:32:54 <geekosaur> for a prerelease compiler, and for something that needs to hook into it (yes, this means ghc-mod), you should expect to need an unreleased version and that even that may not be working yet
08:35:38 <Mateon1> I just wish that my current ghc-mod from stack would integrate with Syntastic in vim under msys properly.
08:53:37 * hackagebot ghcjs-ajax 0.1.0.0 - Crossbrowser AJAX Bindings for GHCJS  https://hackage.haskell.org/package/ghcjs-ajax-0.1.0.0 (AlexanderThiemann)
08:59:48 <simpson> Hi! I have a library that I want to build both on NixOS and also with the Haskell Platform + whatever's current on Hackage. (Or I could use this "Stack" thing that's getting popular.) What's the best practices look like for packaging that library?
09:10:36 <zipper> Hey, can I specify a function to be run in my .ghci file?
09:13:33 <pavonia> zipper: Yes, just put it on an extra line in that file
09:17:21 <jophish> What's the reason behing this error message https://gist.github.com/expipiplus1/460b4a15cdac1ebf335293dcd1e74f55
09:17:47 <jophish> Requiring an ordering between variables where variables are used as both types and kinds
09:17:51 <jophish> this is with TypeInType
09:22:16 <zipper> pavonia: Awesome
09:22:39 <simpson> Hi! In GHC, and possibly in general, are there limits on how many constructors a data type can have? Are there soft limits beyond which performance suffers or gets asymptotically worse?
09:23:52 <monochrom> w00t, Haskell Prime 2020 Committee
09:24:14 <ddwantsstuff> Well Im board
09:24:36 <ddwantsstuff> Anyone online
09:24:40 <ddwantsstuff> Seriously
09:25:02 <asmodeo> No
09:25:09 <monochrom> hrm, this committee looks more practical and teaching than research
09:25:15 <ddwantsstuff> asmodeo: do you like minecraft?
09:25:19 <aarvar> simpson: maybe 2 ^ 64 or something?
09:25:59 <ddwantsstuff> Cake is a lie
09:26:00 <simpson> aarvar: Well, ISTR that it's a tagged-union scheme, so I'd expect that the first 255 constructors are "free", and then the next mark is 65535.
09:26:02 <geekosaur> ddwantsstuff, this channel is about the Haskell programming language. if you're looking for general chat, try #defocus
09:26:02 <asmodeo> ddwantsstuff: nope. 
09:26:29 <ddwantsstuff> asmodeo: do you want to help create a control panel for hosting
09:26:40 --- mode: ChanServ set +o monochrom
09:26:49 <monochrom> ddwantsstuff, I now ask you to leave.
09:27:02 <ddwantsstuff> It is about haskel
09:28:26 <asmodeo> ddwantsstuff: I don't think I have required skill. 
09:28:47 --- mode: monochrom set +b *!*@65.113.255.173.bc.googleusercontent.com
09:28:48 <t0by> I'm sorry for the stupid question, but has ddddddwantsstuff just been kicked?
09:29:03 <monochrom> good question. yes.
09:29:06 <aarvar> simpson: why 255 and not 256?
09:29:13 <t0by> Because my client prints that he "left, upon monochrom's request".
09:29:17 <t0by> That would be GNOME Polari.
09:29:37 <hpc> t0by: so does mine
09:29:41 <monochrom> I used a freenode-special "remove" command instead of "kick"
09:29:56 <t0by> ew.
09:30:09 <t0by> ah, okay. nevermind, sorry.
09:30:10 <simpson> aarvar: One of the byte patterns has to code for "there are more than 255 possible patterns". The most efficient encoding possible gives you 255 constructors and 1 constructor-is-two-bytes-and-starts-next-byte.
09:30:13 <hpc> monochrom: so you "escorted him from the channel"
09:30:17 <monochrom> it means that irc servers emulate the target's "/leave"
09:30:46 <simpson> aarvar: I suppose that there's also the more classic varint encoding, which gives you 127 for free and then scales better to subsequent bytes.
09:31:05 <aarvar> ah, well idk
09:31:21 --- mode: monochrom set -o monochrom
09:31:37 <simpson> I don't know either, and I haven't been able to find the information in GHC docs or any slides from the Simons.
09:32:51 <pavonia> Wow, that kick was pretty harsh
09:34:39 <simpson> Found it: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/PointerTagging
09:35:03 <simpson> Maximum of 3 on 32-bit pointers, or 7 on 64-bit pointers, before falling back to the slower case.
09:35:30 <simpson> Oh, but the slow case isn't especially slow. So it's not a biggie. No limit, which is nice.
09:42:44 <t0by> pavonia: nah. whoever mentions "minecraft" is kick-worthy anywhere, anytime.
09:42:50 <t0by> including #minecraft
09:47:12 <asmodeo> t0by: you did it twice.
09:47:33 <t0by> :(
09:48:01 <monochrom> this is where Russell would say: it's a meta-sentence, so it doesn't count.
09:49:09 <monochrom> there is some relation between Russell's "split into 2 or multiple levels" idea and predicative vs impredicative types
09:49:38 <monochrom> to a large extent, Haskell goes with predicative. it means: ...
09:50:40 <monochrom> Suppose you have written a function f :: a -> [a]. You can now use it as Int -> [Int], Bool -> [Bool], (Char -> Bool) -> [Char -> Bool], ...
09:51:07 <monochrom> but you cannot use it as (forall a. a -> a) -> [forall a. a -> a].
09:51:29 <StarsC> is there Bool transformer? :) i want  (IO Bool && IO Bool && IO Bool) in one line :)
09:51:34 <monochrom> predicative type means you cannot plug a forall-type into a type variable 
09:52:22 <EvanR> i want to mention this functional data structure, without actually having checked to see if its not bollocks https://github.com/datacrypt-project/hitchhiker-tree
09:52:38 <monochrom> StarsC: there can be about 7 of them, depending on: suppose the first action answers False, do you still want to perform the 2nd action? the 3rd action?
09:52:50 <EvanR> its clojure + redis though so not sure 
09:52:52 <StarsC> no its and
09:53:03 <StarsC> monochrom: if one false its overall IO False
09:53:17 <dmwit> ?unmtl MaybeT (Writer All) a
09:53:17 <lambdabot> (Maybe a, All)
09:53:17 <monochrom> anyway, so predicative type is kind of splitting types into two levels, those without type variables and those with.
09:53:19 <StarsC> its exact copy of Maybe, just without annoying just :)
09:53:31 <dmwit> ?unmtl WriterT All Maybe a
09:53:31 <lambdabot> Maybe (a, All)
09:53:59 <StarsC> i want to write chaining of IO Bool conditions in one line
09:54:11 <StarsC> not to use do for that
09:54:50 <monochrom> then use liftA2 (&&)
09:55:21 <StarsC> ah! ty! :) only liftA2 or liftM2 ?
09:55:37 <monochrom> define your own (^&&^) = liftA2 (&&). now you can write xxx ^&&^ yyy ^&&^ zzz
09:55:53 <StarsC> monochrom: yes precisely my wish, ty
09:56:13 <EvanR> wing-ed &&
09:56:14 <StarsC> i have 7.8.4 should be liftM2 no?
09:56:24 <monochrom> sure
09:57:16 <monochrom> now, I said "to a large extent" because you can circumvent the restriction.
09:57:52 <monochrom> you can't use f as (forall a. a -> a) -> [forall a. a -> a] verbatim. But you can go through a newtype wrapper
09:58:18 <monochrom> "newtype X = X(forall a. a -> a)" now you can ask for f :: X -> [X]
10:08:12 <Denommus> can GHCJS export a function through Node's module system? (That is, exports.handler = <some JavaScript function that calls into Haskell>)
10:10:15 <kadoban> Denommus: Should be able to, sure. You'll want to use the stuff from GHCJS.Foreign.Callback, and a FFI thing that actually sets it
10:12:08 <Denommus> I'm considering if I use pure node or if I piss off my coworkers with a Haskell code XD
10:12:22 <kadoban> Denommus: Haha
10:13:42 <EvanR> recommend piss off coworkers
10:24:25 <ksj> can aeson serialize disjoint unions into json strings? and are there some good resources for using aeson?
10:25:26 <greg> hello does anyone know of a library that allows me to make cyclical 3d graphs?
10:25:27 <monochrom> almost everything I know about aeson I learned from the beginning examples in the doc
10:28:56 <kadoban> There's a ToJSON/FromJSON instance for Either a b, with the right contexts and stuff. You could do the same for a different type I'm sure.
10:31:04 <monochrom> ah, disjoint union. aeson gives you a lot of options to choose how to encode it. (it chooses one for Either, but you can choose something else for yours)
10:33:16 <monochrom> look for the type "Option" and encoders that use it. This is where you specify how to encode your sum type. especially the field "sumEncoding"
10:33:51 <monochrom> start with "defaultOptions" and customize
10:34:33 <ksj> monochrom, thanks will take a look at Option
10:38:40 * hackagebot telegram-api 0.3.0.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.3.0.0 (klappvisor)
10:46:48 <mikail_> Hi, please can you help with the following example: http://lpaste.net/162433. I am trying to create a type class and want to constrain the type of type-class parameter to only take types of type Animal. How do I do that? Secondly am I approaching this correctly? Thanks
10:47:31 <shachaf> There are no types of type Animal. Dog and Cat are values, not types.
10:48:02 <shachaf> You can write: someFunc :: Animal -> String; someFunc Dog = ...; someFunc Cat = ...
10:48:06 <Tritlo> anyone familiar with stack docker here?
10:48:10 <shachaf> No type class, just a function.
10:48:22 <mikail_> thanks shachaf
10:59:57 <nitrix> Looking at base; it seems so many of the definions are avoiding the naive implementations because it could lead to mutually recursive definitions.
11:00:13 <nitrix> Has anyone thought of solving that problem in more elegant ways before?
11:02:19 <machinedgod> Hi all. I have few questions about monad transformers (from transformers) package. I'm trying to learn how to use them, and I might be misunderstanding few things. Anyone available to provide some guidance?
11:03:16 <hpc> just ask and someone who can help will answer
11:04:00 <machinedgod> Okay. So, I am trying to use State monad inside StateT of the same state type, "mixed" with IO
11:04:38 <Zekka|Sigfig> machinedgod: So your goal is to keep track of two states and do IO?
11:05:20 <machinedgod> So, I was under the impression that I can simply apply State monad actions within StateT, without lifting or something special, but it seems I was wrong
11:05:46 <machinedgod> Zekka|Sigfig, no, I wanted to keep the actual State pure, and just mix it with IO in one place...
11:06:14 <Zekka|Sigfig> Oh, OK, so your type is something like StateT s IO a?
11:06:36 <machinedgod> Yes, precisely!
11:06:56 <machinedgod> The 'mixture' function is... the state action I'm trying to call inside it is of type State s a
11:07:21 <Zekka|Sigfig> Hm, so you’re trying to run some State s a code as StateT s IO a code?
11:07:46 <machinedgod> Err... yes... but now when you put it this way, i see it makes no sense
11:07:59 <Zekka|Sigfig> IIRC State s a is defined as StateT s Identity a — so in that case you’re going to need to define a mapping from StateT s Identity a to StateT s IO a
11:08:12 <Zekka|Sigfig> there’s a library that does this which is called mmorph, but you can also probably do it yourself
11:08:25 <Zekka|Sigfig> or you can write your State s a action as Monad m => StateT s m a
11:08:43 <Zekka|Sigfig> (There might be yet more ways to do this.)
11:09:55 <machinedgod> I think I understand my confusion now
11:10:22 <machinedgod> I assumed that StateT would somehow superseed the State, and State could be normally used inside StateT (but not vice versa)
11:11:16 <Zekka|Sigfig> machinedgod: That’s basically what Monad m => StateT s m a says
11:11:35 <Zekka|Sigfig> “I don’t use m so I can be used no matter what StateT modifies”
11:12:27 <machinedgod> Okay, then I am doing something wrong in the code
11:13:00 <machinedgod> Would it be a drag if I put the code somewhere in some paste site, and you check it out? its maybe 10 lines in total
11:13:08 <Zekka|Sigfig> If you give it type State s a, I think you’re saying “I do care what StateT modifies: it has to be Identity"
11:13:15 <Zekka|Sigfig> I wouldn’t mind if you did that
11:14:15 <monochrom> please post on lpaste.net. yes, we prefer seeing actual code to lossy human description
11:14:23 <monochrom> or at least, I prefer.
11:14:45 <machinedgod> Okay, one second :-0
11:14:46 <maerwald> well, code is lossy human description too, in a sense :P
11:15:14 <monochrom> I am a "how do I reproduce your experiment" scientist, not an ESP palm reader, unlike most programmers who think they are.
11:15:52 <machinedgod> I don't mind sharing code, I'm just a bit ashamed because its really... uhm... prototypy... 
11:15:55 <machinedgod> here it is: http://lpaste.net/162437
11:17:28 <monochrom> yes, I think your best option is "updateGame :: Monad m => Command -> StateT Game m String"
11:18:17 <monochrom> it is the balance point between "it is compatible with another monad" and "but I am not relying on that another monad"
11:18:59 <machinedgod> Gotcha. I think my original assumption was off (Zekka cleared it out by pointing out that State is actually StateT with Identity)
11:19:43 <machinedgod> if, for example, I'd say that I'm not able to modify updateGame for some reason... is there any possible solutions except running the state explicitly within StateT?
11:21:07 <dolio> It all would have worked out if you left off the type signature on updateGame. :)
11:21:14 <dolio> But that's not really recommended.
11:21:40 <monochrom> @type \u -> StateT (return . runState u)
11:21:41 <lambdabot> Monad m => State s a -> StateT s m a
11:22:04 <dolio> @type state . runState
11:22:06 <lambdabot> MonadState s m => State s a -> m a
11:22:11 <monochrom> "StateT (return . runState updateGame)" will convert updateGame to StateT
11:22:41 <machinedgod> Guys - thank you so much. You're the best.
11:24:16 <monochrom> @type state
11:24:17 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
11:24:21 <zennist> does someone if there is a datatype like `data Fst a b = Fst a b` such that its Eq and Ord instances are implemented only by comparing the first field?
11:24:31 <monochrom> oh! state does most of what I did.
11:24:44 <monochrom> I didn't know that "state" was general
11:24:51 <dolio> In transformers it does exactly what you did.
11:25:00 <dolio> That's the mtl one that is fancy.
11:25:27 <zennist> there must be some smart way of having equality test between items with a key and some payload - but I don't know..
11:26:02 <scshunt> zennist: I'd be worried about making an Ord instance, in particular, like that
11:26:16 <scshunt> what's your use case?
11:26:51 <zennist> yes - my initial impression is that it might break something - but maybe it doesn't i.e. when compare a b == EQ, a does equal to b according to Eq instance
11:27:11 <scshunt> if your Ord and Eq don't agree, things like Map will break
11:27:38 <zennist> my use case is a bit involved, but it basically boils down to having a map interface which I have no hope of changing - and it only allows retrieval of K
11:28:02 <zennist> yeah - but as I said it seems to agree
11:29:01 <zennist> I can easily write it myself but just wondering if there's already such a thing
11:29:05 <OnkelTem> Hi all. What Haskell web framework you'd recommend to check out?
11:29:11 <OnkelTem> I'm total newbie
11:29:15 <zennist> OnkelTem: reflex-dom
11:29:34 <zennist> if you are talking about client-side :)
11:30:32 <zennist> for server side I haven't done much - but have heard a lot of people using 'servant'
11:30:43 <OnkelTem> zennist: I'm not sure. I think I want to build a simple REST service which generates examples for a math gym which I'm gonna write in js :)
11:30:54 <OnkelTem> s/examples/tasks/
11:30:59 <zennist> ah okay that's server side
11:31:01 <OnkelTem> i.e. problems to solve
11:31:11 <zennist> maybe look into 'servant'
11:31:21 <zennist> but there should be tons of choices out there
11:31:40 <zennist> https://wiki.haskell.org/Web/Frameworks
11:31:53 <montanonic> OnkelTem: http://haskelliseasy.readthedocs.io/en/latest/#web-frameworks
11:33:02 <montanonic> ^ I'd trust haskelliseasy, since its author has a really good intuition for learning and using Haskell in a way that won't make you feel like an idiot.
11:33:03 <OnkelTem> zennist: that page is what I was reading a thought came to my mind: ain't they all outdated? :)
11:33:13 <OnkelTem> then+
11:33:16 <montanonic> OnkelTem: IMO, yes. 
11:34:03 <zennist> you could check out those with github homepages - those ones are usually more up to date
11:34:19 <zennist> servant latest update this month
11:35:07 <montanonic> OnkelTem: Yesod is the big web framework, but I wouldn't recommend it until you're really comfortable with Haskell. Scotty seems like a good place to start. Are you familiar with web development in general already? How are your Haskell skills/knowledge? Have you read/are reading HaskellBook?
11:36:13 <maerwald> OnkelTem: Snap
11:37:01 <maerwald> here's an interesting presentation about it https://vimeo.com/59109358
11:38:01 <OnkelTem> montanonic: yeah, I'm good in web development (php/Drupal, js/AngularJS), but know almost nothing about Haskell and [still] reading a book - Learh You a Haskell
11:38:12 <maerwald> ditch it
11:38:42 <maerwald> see https://github.com/bitemyapp/learnhaskell#how-should-i-learn-haskell
11:38:57 <montanonic> OnkelTem: You will not learn Haskell from LYAH. http://haskellbook.com/ if you are serious. Also the link maerwald posted above is second-best.
11:39:21 <montanonic> OnkelTem: http://bitemyapp.com/posts/2015-08-23-why-we-dont-chuck-readers-into-web-apps.html
11:39:24 <EvanR> LYAH haterade ;)
11:39:34 <OnkelTem> Many thanks folks! I didn't know that
11:39:49 <Zekka|Sigfig> FWIW I liked lyah but apparently no one else does
11:39:52 <nitrix> EvanR: It's a harsh world out there :)
11:39:52 <OnkelTem> I just picked a first pretty book from an internet shelf
11:39:56 <maerwald> I don't see any hate
11:40:11 <montanonic> OnkelTem: not to discourage you, but you will hate Haskell if you jump into trying to use a web framework before you have a feel for the language. It is too different from basically every other mainstream language.
11:40:28 <nitrix> I think LYAH is a cute and good introductory book if you're coming from another language. It wont teach much though.
11:40:41 <montanonic> I agree, it got me interested, but not much else.
11:40:42 <Zekka|Sigfig> The problems in it really aren’t too good
11:40:59 <EvanR> the semantic clarity of web programming plus the flexibility and ease of haskell
11:41:00 <bollu> I want to learn something cool in Haskell, and I know the usual typeclasses other than Arrow, and I don't grok continuations. What do I learn, any ideas people?
11:41:09 <maerwald> it's full of distracting anecdotal explanations of things that can be said in one sentence
11:41:09 <EvanR> recipe for disaster !
11:41:24 <nitrix> bollu: RankNTypes?
11:41:41 <nitrix> bollu: Universal and existantial quantification :)
11:41:43 <bollu> nitrix: I vaguely know how they work, but not properly. How do you start learning / using them?
11:41:44 <shachaf> bollu: Continuations.
11:41:50 <nitrix> bollu: Learn lenses :D
11:41:56 <Zekka|Sigfig> It’s been a pretty long time since I read lyah so I don’t want to defend it — but heads up, when you ask “how do I learn x,” you’re going to get a lot of different answers
11:42:09 <bollu> shachaf: I've implemented them thrice from scratch, but I _still_ can't put the damn types together for a continuation
11:42:17 <maerwald> bollu: extensible effects
11:42:21 <shachaf> Good, then it's a learning opportunity.
11:42:27 <bollu> shachaf: I find myself simply "type plumbing" without getting what's going on
11:42:37 <bollu> shachaf: could you guide me through them?
11:42:38 <Zekka|Sigfig> most people think how they learned x is pretty authoritative, because you can usually only learn a thing once, so they only have the experience of learning it one way
11:42:39 <montanonic> I think though that there's community consensus on http://haskellbook.com/ being pretty much the go-to resource.
11:42:39 <shachaf> That's not so bad.
11:42:41 <OnkelTem> montanonic: oh my... Lectures! I feel really excited! Seriously
11:42:41 <maerwald> bollu: see http://okmij.org/ftp/Haskell/extensible/exteff.pdf and the extensible-effect package on hackage
11:43:20 <maerwald> to hell with monad transformers, plz ;)
11:43:22 <montanonic> bollu: oh, I know something: Free Monads
11:43:26 <Zekka|Sigfig> I like the parts of haskellbook I’ve read but bear in mind that a lot of the people praising it are people who already know haskell pretty well
11:43:35 <OnkelTem> maerwald: ^^ was for your
11:43:38 <montanonic> bollu: those are fascinating, but you have to actually play around with them to learn
11:43:46 <OnkelTem> you*
11:43:49 <bollu> montanonic: I know free monads + cofree comonads + how they form interpreters. Awesome as hell structures
11:43:51 <maerwald> OnkelTem: yes, the lectures are very nice from cis
11:43:55 <maerwald> but they are also hard
11:43:55 <montanonic> bollu: awesome :D
11:44:07 <montanonic> bollu: I've yet to get into Cofree Comonads
11:44:08 <bollu> shachaf: any place I can pick up continuations?
11:44:35 <shachaf> Probably?
11:44:39 <bollu> montanonic: They're damn cool :) I loved Haskell so much more after seeing those adorably epic things.
11:44:44 <shachaf> Control.Monad.Cont, I guess.
11:44:45 <bollu> shachaf: I was hoping for referrencds
11:44:54 <shachaf> And look at Codensity while you're at it.
11:45:23 <montanonic> Zekka|Sigfig: that's true; I started using it when I was at the threshold of beginner to intermediate, and it was particularly helpful to have a structured order for learning things, and made me more comfortable using outside resources on particular topics. So, I'm pretty hype about it. But you're right.
11:45:42 <Zekka|Sigfig> montanonic: Yeah, being clear I’m definitely not saying “most of those people who feel that way are wrong"
11:45:47 <Zekka|Sigfig> I’m saying “most of the people who feel that way are right"
11:46:04 <montanonic> bollu: https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
11:46:16 <Zekka|Sigfig> where “feel that way” ==> “think they have a good way to learn something"
11:47:38 <monochrom> bollu: I think you may like to learn continuations. But there are other choices, and perhaps they are what you need before tackling continuations. Certainly rank-n types. Böhm-Berarducci encoding which uses rank-2 types (http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html)
11:48:29 <bollu> monochrom: ohh, thank you :)
11:48:38 <bollu> montanonic: ty!
11:48:57 <montanonic> bollu: np!
11:49:31 <monochrom> I am much interested in Böhm-Berarducci because I was trying to write down induction for BB-encoded naturals. (In the end, I got more: I got parametricity.)
11:50:19 <monochrom> And I'm interesting in induction for BB naturals because I'm interested in BB-encoded free monads and why two implementations of the same function are equivalent.
11:55:46 <johnw> monochrom: I have a TH library for generating BB encoding
11:57:12 <monochrom> what I need is a template-agda library that generates the free theorems and goes on to prove all they corollaries :)
11:58:20 <monochrom> but have you pondered on the following beast:
11:58:50 <dolio> There's an agda library for generating parametricity statements, so you can postulate them.
11:59:25 <monochrom> BB peano natural, (forall r. r -> (r -> r) -> r), can be rewritten as (forall r. (Maybe r -> r) -> r)
12:00:04 <monochrom> but if you use data-Maybe there, you're deviating from BB's ideal of sticking to just lambdas, no data.
12:00:40 <monochrom> so how about (forall r. ((forall w. w -> (r -> w) -> w) -> r) -> r) !!!
12:03:38 <johnw> monochrom: you can prove parametricity theorems in Agda?
12:03:44 <johnw> monochrom: in Coq I can only axiomatize them
12:04:15 <dolio> You have to postulate them in Agda, too.
12:04:21 <monochrom> I don't know. but perhaps a hypothetical template-agda can
12:04:32 <infinity0> is there an "unlift" function? I have what is roughly a "State [m] m" and i'm trying to apply a transformer t to it so it becomes a "State [t m] (t m)"
12:05:12 <infinity0> but going through the derivation, it appears i need something like a "unlift :: t m -> m" to "unwrap" the input state
12:06:50 <djbeau> infinity0: hoist perhaps?
12:07:15 <watChmeFly> hey guys
12:07:17 <djbeau> or some variation thereof
12:08:01 <puregreen> isn't “unlift” for State just “runState”?
12:08:16 <nitrix> :t unlift
12:08:17 <lambdabot>     Not in scope: ‘unlift’
12:08:17 <lambdabot>     Perhaps you meant ‘lift’ (imported from Control.Monad.Writer)
12:08:22 <nitrix> What's unlift from?
12:08:30 <puregreen> otherwise it's unclear how exactly you're supposed to unwrap the input state without having a state
12:09:12 <watChmeFly> Does anyone here have experience with Scala?
12:09:26 <watChmeFly> I tried the channel, but the one person that helps me isn't there lol.
12:09:39 <maerwald> this is not a Scala channel
12:09:51 <watChmeFly> I know
12:10:14 <watChmeFly> But haskell people have been more helpful to me than any other channel, so was just wondering.
12:10:25 <infinity0> i need unlift not for State, but for the arbitrary t that forms part of the input state to the State transition
12:10:27 <monochrom> it is ok to try to find that person here and ask him to go to #scala. But apart from that, I would rather you not talk more.
12:10:28 <shachaf> This is not the channel for Scala questions.
12:10:56 <watChmeFly> That's why I asked if anyone here is familiar with scala
12:11:09 <maerwald> the problem is that it somewhat breaks the topic of the channel if people suddenly start to talk about your favoritate language XY, just because more people are here
12:11:24 <Akii> watChmeFly: you're not even in #scala
12:11:25 <infinity0> more generally, i have a transformer ContextT m which is roughly StateT [m] m, i.e. the inner monad is part of the state
12:11:26 <monochrom> but you did not explicitly say "please come to #scala to help me".
12:11:49 <monochrom> therefore the objective observable conclusion is you want to continue right here.
12:11:58 <infinity0> and i'm trying to define a MFunctor instance for it, i.e. hoist :: (forall a. m a -> n a) -> Context m a -> Context n a
12:12:02 <watChmeFly> I would have messaged the person, but ok.
12:12:05 <watChmeFly> thanks!
12:12:16 <Akii> just switch to the superior language, then you can ask here :D
12:13:10 <Akii> no watChmeFly, direct messaging is not the thing you do next
12:13:25 <maerwald> do haskellers still use purescript or is everyone doing ghc2js now?
12:16:08 <hiptobecubic> It's just "ghcjs" and no. plenty of people are using other things apparently
12:18:33 <maerwald> hiptobecubic: any personal preference? I'm a bit undecided where to go, purescript almost looks like "unhyped"
12:18:43 <geekosaur> ghcjs is still new, tooling hasn't settled down yet, etc.
12:18:46 <jle`> maerwald: both are at the moment suitable for very different domains
12:19:01 <geekosaur> also it's heavier than the others
12:19:34 <geekosaur> if you need the full power of ghc, ghcjs is the only thing that will give it to you, but at a price
12:22:12 <Cale> If you want to save yourself a bunch of time compiling ghcjs, there's a repository here https://github.com/reflex-frp/reflex-platform with a try-reflex script that will use nix to download everything you need and put you in an environment where you can easily try out ghcjs (and reflex/reflex-dom).
12:26:59 <adarqui> i've been using purescript.. absolutely love it. biggest issue is sharing 'types' and json instances etc between haskell.. if you have lots of types, can get brutal.. also having to write redundant functions in both languages
12:27:03 <adarqui> can be a pain
12:27:57 <maerwald> adarqui: in what way do you share types with haskell?
12:28:12 <scshunt> adarqui: aeson-lens?
12:29:06 <adarqui> maerwald: well you can't unless you use some third party tool.. i actually ended up writing a tool to take my haskell types and generate equiv purescript types, and json instances for both etc
12:29:24 <adarqui> eventually that will be supported from purescript (i think).. i think it's on their road map
12:29:34 <adarqui> there's also things like yesod-purescript and such
12:30:21 <adarqui> so people have written various tools to help make it easier.. because eventually it just becomes a big issue.. you just can't write another type + json + client side api handlers 'twice'
12:31:06 <adarqui> there's also stuff for servant i'm pretty sure.. servant-purescript and such. I know servant can generate client side api routines and such for various frameworks/languages
12:31:42 <maerwald> my idea was rather have the frontend be a mix of purescript and direct js and the backend pure haskell (e.g. snap) without any code interaction between the two
12:32:16 <adarqui> oh, well, i'm doing that as well. but.. I still have to serialize types between the two
12:32:22 <maerwald> why?
12:32:30 <adarqui> haskell data type <-> json <-> purescript data type
12:32:48 <maerwald> yeah, but that's not an issue really is it
12:33:13 <adarqui> well you have to write types on both sides and the code to serialize those types
12:33:33 <dmj`> type sharing ftw
12:33:39 <maerwald> if you use mongodb you already get json from the db queries 
12:33:53 <adarqui> sure, but you have to turn that into a type no?
12:34:00 <maerwald> not on the backend
12:34:05 <adarqui> if you're using haskell/purescript
12:34:10 <adarqui> so you'll just access that via a Map ?
12:34:14 <adarqui> lookup "key" etc?
12:34:25 <maerwald> it's pretty much: db -> json -> purescript-type
12:35:05 <adarqui> oh ok sure if you don't need those types declared in your haskell backend, in that instance you'd only have to write them once
12:35:06 <maerwald> probably depends on the database, I haven't tried the json stuff from postgres yet
12:35:11 <adarqui> in my setup, i have types on both ends which need to match
12:35:19 <adarqui> im using a few data stores.. postgres, redis, etc
12:35:34 <adarqui> and my backend does alot of work with the actual types so
12:35:34 <maerwald> I mean postgres has native json support too no?
12:35:41 <adarqui> for me i had to serialize into actual types I can play with
12:36:02 <maerwald> well, afaik you can store json directly in postgres
12:36:29 <adarqui> ya.. i don't do any direct stuff with postgres tho i'm using persistent "ORM"
12:37:16 <adarqui> i starred a project recently but forgot what it is, some dsl for writing types and compiling them to various languages.. sounds like a good project
12:37:34 <adarqui> eventually i want to generate my types for other langs like go/js/etc .. so i can have some interop with those langs
12:38:24 <adarqui> but ya if i was using ghcjs, i wouldn't have the redundancy problem (I think).. but my experience with purescript has been so positive that i've just worked around it
12:38:29 <adarqui> my 2cents
12:39:08 <Akii> there is also Elm
12:39:59 <fakedrake> hello
12:40:41 <fakedrake> I am trying to install haskell on a windows server that only has about 400M of disk space left, is there a package with ghc and cabal that can fit in that space?
12:41:17 <hiptobecubic> fakedrake, you want to compile haskell programs there? You're going to run out of immediately space anyway
12:41:18 <selckin> free some space, wtf
12:41:22 <montanonic> Akii: Elm is much lower level than PureScript
12:41:25 <hiptobecubic> space immediately*
12:41:32 <dcoutts> fakedrake: unlikely, my ghc-7.10.3 alone takes ~800M
12:41:47 <montanonic> adarqui: what types of things do you do with PureScript on the front-end?
12:42:03 <montanonic> adarqui: are you building an app-like interface, or just adding basic/simple behaviors?
12:42:16 <adarqui> montanonic: not much just simple stuff.. i'm not really a front-end guy so, this has been my first real journey with front end.. i'm writing a forum in purescript/haskell
12:42:32 <adarqui> ya writing an app. basically re-doing my forum that i have which is some public PHP software
12:42:52 <scshunt> adarqui: with what framework?
12:42:54 <montanonic> adarqui: ah, okay, cool. 
12:42:58 <montanonic> Snap it seems
12:42:59 <fakedrake> why is ghc SO large?
12:43:30 <dmj`> @google why is ghc so large?
12:43:32 <lambdabot> http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
12:43:32 <lambdabot> Title: haskell - Why is GHC so large/big? - Stack Overflow
12:43:41 <adarqui> scshunt: haskell = yesod + persistent + hedis, frontend = purescript + halogen + halogen boostrap3 etc
12:43:49 <scshunt> cool
12:44:11 <adarqui> i'm not really using yesod like a typical user would, ie, i'm making a single page app.. so technically I could be using something like servant.. but yesod had some nice auth plugins that I wanted right out of the box
12:44:17 <adarqui> and some other nice stuff so, using that for now
12:44:56 <fakedrake> 113MB is an order of magntude less that what I seem to be dealing with
12:45:29 <scshunt> adarqui: are you using yesod to write the API?
12:45:34 <dmj`> adarqui: servant has auth
12:45:54 <scshunt> adarqui: what's the difference between purescript and, say, GHCJS
12:45:54 <adarqui> dmj`: ya i know but when i needed it a year ago, was tricky/unsettled so i used yesod instead
12:46:00 <adarqui> scshunt: ya
12:46:15 <scshunt> adarqui: I'd be interested in hearing about your experiences with that
12:46:22 <dmj`> scshunt: you get to share types
12:46:41 <adarqui> scshunt: purescript is strict & not haskell.. ghcjs gives you haskell for the frontend. so ghcjs is also 'lazy' afaik, actual haskell.
12:46:48 <adarqui> ya
12:46:52 <adarqui> and you can share code/types
12:46:54 <adarqui> with ghcj
12:46:55 <adarqui> s
12:46:57 <dmj`> scshunt: o/w you have to resort to social contract, rather than compile time guarantees that your code is correct
12:47:55 <adarqui> purescript has several other differences: https://github.com/purescript/purescript/wiki/Differences-from-Haskell
12:48:21 <puregreen> we have text-show as a replacement of Show for Text. What's the alternative to Read?
12:48:25 <adarqui> for a haskeller, it's really easy to switch between the too.. im a beginner haskeller but I can seamlessly switch between the two
12:50:13 <montanonic> GHCJS is awesome but also solving a harder problem than PureScript is. PureScript has used Haskell everywhere it's made sense, improved it in ways, and opted for different ways of doing things where it would work better (arrays by default, not lists; strict by default; extensible effects).
12:50:18 <Cale> With ghcjs, most of the stuff on hackage which you could reasonably expect to work (i.e. it's not a binding to a C library), actually will work, which is quite nice.
12:50:40 <bitemyapp> I'd say things like forkIO are at least as important as Hackage itself for GHCJS.
12:50:47 <maerwald> haskell also has extensible effects, it's just that people don't use them and rather use monad transformers (sadly)
12:50:49 <bitemyapp> I _like_ being able to use the existing concurrency primitives.
12:51:14 <Cale> ah, yeah, that's pretty nice as well -- you get a better concurrency system than you could otherwise obtain through JS.
12:51:37 <montanonic> Wait, how does Haskell's concurrency even translate to compiled JS?
12:51:43 <lpaste> infinity0 pasted “Deriving MFunctor for a StateT-based MonadTrans where the inner monad is also present in the state” at http://lpaste.net/162439
12:51:45 <dmj`> montanonic: it's like the single threaded runtime
12:51:59 <dmj`> you'd get with ghci
12:52:03 <Cale> montanonic: The whole runtime system is translated to JS too (though most of that by hand)
12:52:10 <montanonic> okay; that's so fascinating
12:52:15 <scshunt> is GHCJS implemented via LLVM?
12:52:17 <infinity0> so i'm wondering if there's a way i can do it differently, without the "unapply"
12:52:19 <Cale> scshunt: yes
12:52:26 <dmj`> montanonic: it's probably one of the only implementations of stm in javascript
12:52:34 <infinity0> or define the "unapply", even... but that seems impossible to me
12:52:40 <montanonic> bitemyapp: you use purescript yourself though, right? Dabble much with GHCJS?
12:52:42 <scshunt> where are the GHCJS libraries?
12:52:51 <Cale> Basically, if you look at the javascript code, it looks just like a javascript version of the assembly code which GHC normally outputs.
12:53:01 <dmj`> scshunt: on github.com/ghcjs
12:53:22 <Cale> https://github.com/ghcjs/ghcjs-dom
12:53:24 <bitemyapp> montanonic: define use
12:53:28 <dmj`> scshunt: ghcjs-base gives you websockets, ghcjs-dom gives you a typed interface to the DOM
12:53:33 <Cale> and some other things, yeah
12:53:39 <bitemyapp> montanonic: I have a coworker that uses purescript. I wasn't going to dictate someone else's work to them.
12:53:43 <montanonic> bitemyapp: I've seen you contribute/comment on Github and am making presumptions that you write purescript
12:53:48 <dmj`> Cale: yea, among other things
12:53:59 <montanonic> bitemyapp: I see. Okay.
12:54:02 <bitemyapp> montanonic: you mean the fucking modules thread? You don't need to know much about PureScript to weigh in on that.
12:54:35 <bitemyapp> montanonic: you can know more than 90% of the commenters in that thread by, 1. Understanding typeclasses and their pros/cons 2. Understanding implicits and their pros/cons 3. Having used at least one ML with real modules.
12:54:42 <bitemyapp> boom, you're now an expert. Have fun.
12:55:22 <montanonic> I see, okay. I misread how involved you were in the language; I agree that the thread was not domain-specific to PureScript
12:55:38 <montanonic> I don't browse GH too much, I just saw activity at one point and was like "Oh, Chris uses PureScript"
12:55:42 <bitemyapp> I've piped up in other places re: PureScript
12:55:56 <bitemyapp> but I don't use it much and mostly observe other people using it.
12:56:02 <montanonic> I see. Makes sense.
12:56:12 <bitemyapp> my current main irritation with our frontend kit is webpack.
12:56:35 <bitemyapp> montanonic: did all this work: http://bitemyapp.com/posts/2016-03-28-speeding-up-builds.html now webpack is like 50% of our build time. fuckers.
12:56:41 <Cale> montanonic: oh, another thing I think is very much worth pointing out, is that the ghcjs-dom library (as well as reflex-dom) also build in ghc, and will give you corresponding native webkit applications
12:56:56 <montanonic> Cale: woah, now that's really interesting
12:57:39 <montanonic> bitemyapp: Yeah I read through that one. I'm not familiar with webpack though (been focusing on Backend stuff w/ Yesod); I'll have to research.
12:58:12 <bitemyapp> I've been backend/ops only for awhile, but slow CI forced me to act.
12:58:33 <Cale> It's not 100% perfect yet -- there are some Javascript FFI things you can do which will throw the native support off, and of course, there are things you can do with native applications which just won't translate well to running in the browser, but for the most part, it's quite good.
12:59:32 <montanonic> Cale: I haven't given it a shot, but now that it's in Stack I want to try.
13:00:11 <Cale> Maybe give reflex-platform a shot -- it's quite easy and puts you in a shell where you'll have everything you need.
13:00:21 <montanonic> Cale: Would it be a mistake to use GHCJS to do relatively simple JS things, like really, just some basic DOM/VDOM stuff, just for the sake of not having to write actual javascript?
13:00:37 <montanonic> or would the performance hit be too much given how basic the JS functions would be
13:00:48 <montanonic> Cale: I'll check it out; ty
13:00:57 <Cale> I don't think it would be a mistake. Perhaps it's a mistake if you really care about the size of your JS (though Google's closure compiler can help a lot there)
13:01:12 <Cale> But the performance is really very reasonable
13:01:35 <Cale> It's like maybe 3 times slower than running the native code last I checked?
13:02:08 <montanonic> Cale: that's not too bad. Sounds like it'll be no problem for the types of things I'd do with it.
13:02:27 <ra1u> is there library with type similar to Either a a ?
13:03:00 <shachaf> base has ((,) Bool)
13:03:53 <kadoban> (Though you should likely make your own ADT instead of Bool, so they have meaning, unless True and False are obviously mapped to your usage)
13:06:33 <scshunt> shachaf: is there an iso for that?
13:06:58 <shachaf> scshunt: I don't think so.
13:07:10 <shachaf> There's chosen, which traverses one side or the other of the Either.
13:08:20 <sphinxo> Could anyone please give me some feedback on this? http://lpaste.net/2212458750772510720
13:08:46 <sphinxo> looking for anything really
13:14:13 <scshunt> sphinxo: err, what sort of feedback
13:14:25 <sphinxo> scshunt: Anything - really
13:14:39 <sphinxo> how could i make it more idiomatic?
13:14:49 <athan> sphinxo: Why are types denoted as Val?
13:14:53 <sphinxo> more concise?
13:15:03 <athan> er derp nevermind, those are values
13:15:06 <athan> sorry im rusty haha
13:15:19 <sphinxo> ^^ ( more concise is not the answer )
13:15:43 <athan> sphinxo: Maybe allow runtime errors in an error monad?
13:15:58 <athan> and ambiguate the evaluation monad a bit, so you can expand functionality later?
13:16:03 <sphinxo> ExceptT
13:16:10 <sphinxo> ?
13:16:13 <athan> Or just MonadThrow
13:16:27 <athan> idk, I like mtl for monads
13:16:31 <athan> it lets you change your stack later
13:17:13 <athan> I also think you should do a typechecking reduction before evaluation
13:17:16 <athan> like a separate phase
13:17:26 <athan> that way you can cheat and be partial with `eval` :D
13:17:35 <athan> also, you should just use liquid haskell
13:17:43 <athan> actually, implement this in idris :|
13:17:48 <sphinxo> tell me more :)
13:18:41 <sphinxo> ( about implementing it in idris )
13:20:08 <athan> sphinxo: In your `eval` function, you could specify that only _correct_ expressions are allowable
13:20:40 <athan> and in your typechecker, you morph your flexible syntax to a (constructively) correct AST
13:21:07 <athan> check out Richard Eisenberg's GADT lambda calculus thing :)
13:21:38 <sphinxo> glambda?
13:21:46 <athan> yes! That's it, sorry
13:21:53 <sphinxo> cool
13:22:09 <athan> mad props though
13:22:11 <athan> it looks cool :)
13:22:54 <scshunt> GADTs are the best
13:23:20 <sphinxo> scshunt: I had trouble parsing into a gadt
13:24:15 <sphinxo> I guess in retrospect i'd have needed some untyped version that I converted into the gadt datatype
13:25:07 <scshunt> sphinxo: if you were using GADTs for typing, yeah
13:25:08 <athan> sphinxo: That's the essence of it
13:25:16 <athan> it would be like a type correct typechecker if you could
13:29:05 <sphinxo> athan: what did you mean for runtime errors?
13:29:23 <shapr> byorgey: wait, you don't have a twitter account?
13:29:37 <sphinxo> and did you mean something like this for eval: 
13:29:41 <sphinxo> type Eval a = Reader Env a; eval :: Expr -> Eval Val
13:30:26 <byorgey> shapr: nope
13:30:47 <shapr> byorgey: well ok then
13:31:24 <shapr> byorgey: I was just wondering if diagrams has any explicit category theory support
13:31:37 <byorgey> shapr: like for drawing commuting diagrams? not yet
13:31:49 <shapr> byorgey: ok, thanks!
13:32:21 <byorgey> we totally should.  But more generally we first need a better story for putting labels on things
13:32:28 <byorgey> e.g. on arrows
13:47:54 <lyxia> Using criterion, how can I benchmark the application of some (f :: a -> IO b)? (f a) uses values computed from a, and I'd like criterion to recompute them. nf only applies to pure functions (a -> b), nfIO to simple actions (IO b), and would not reapply f to a for every sample.
13:50:42 <hiptobecubic> not sure I follow. (f a) :: IO b is a value representing a computation. It can be run as many times as you like
13:52:35 <Saizan_> hiptobecubic: the problem is the 'a' getting shared between the various runs
13:52:56 <hiptobecubic> but a is a pure value
13:53:12 <hiptobecubic> what's wrong with sharing it? You're benchmarking the computation of b from a
13:53:43 <puregreen> hiptobecubic: if you have e.g. something like «f a = let n = expensiveComputation a in replicateM_ n (putStrLn "hi")», will expensiveComputation run every time you run the resulting IO ()?
13:54:21 <lyxia> currently (evaluate a >>= f) seems to work but that looks fragile.
13:54:44 <hiptobecubic> No, but if you want to be benchmarking `expensiveComputation` then that's what you should benchmark, no?
13:55:01 <hiptobecubic> Or maybe yes
13:55:26 <hiptobecubic> actually I think yes
13:56:12 <puregreen> hm
13:56:30 <hiptobecubic> someone who actually knows should chime in, but I'd expect yet
13:56:31 <hiptobecubic> yes*
13:56:41 <puregreen> lyxia: so your 'a' is not in NF either?
13:56:48 <puregreen> and you don't want it to get shared?
13:59:29 <hiptobecubic> it does get recomputed, it's part of the IO value
14:06:21 <lyxia> no the argument's not part of the computation I want to measure. There is some IO interleaved in the expensive computation but now that you mention it, hiptobecubic, I might be able to move it out in my case.
14:30:41 <hiptobecubic> lyxia, I would just move it out
14:36:26 <EvanR> language question... how do you describe the "variable" that State has
14:36:51 <EvanR> i started writing "mutable state"
14:37:03 <EvanR> realized i have no idea how to describe it
14:37:38 <EvanR> even State seems like a bad name for this thing
14:38:10 <geekosaur> it's a simulation of state :)
14:38:27 <EvanR> runState is stateless...
14:38:35 <EvanR> paradoxically
14:38:55 <adarqui> immutably threaded value ;f
14:39:09 <EvanR> im trying to distinguish it from Reader
14:39:53 <adarqui> immutably threaded updateable value
14:40:06 * EvanR scratch head
14:40:09 <c_wraith> EvanR, maybe a metaphor with a relay race - a state baton
14:40:44 <adarqui> ha, nice.. the penn relays just happened a few days ago, good timing
14:41:09 <EvanR> "State is a type for running a computation that uses a _"
14:41:15 <EvanR> ... state baton?
14:41:40 <c_wraith> that passes around a state baton. or something. :) 
14:42:05 <Lokathor> speaking of state, the function that I think I'm looking for is something like: runStateWithIORef :: MonadState s m => m a -> IORef s -> IO a
14:42:07 <EvanR> from the perspective of the programmer you think of it as a global variable or something
14:42:18 <EvanR> not what its implemented as
14:42:31 <quxbam> Can somebody explain me the planned dynamic typing in ghc 8?
14:42:53 <Lokathor> but is that a sane sort of function to write, or should there also be a MonadIO constraint on the m?
14:43:04 <c_wraith> EvanR, maybe just.. it has a slot for one value? 
14:43:13 <quxbam> It sounds a bit weird to me, because at the same time we're moving to dependent types...
14:43:15 <EvanR> slot, ok
14:43:46 <Cale> quxbam: Dynamic typing? I haven't heard of anything related to dynamic types in GHC 8...
14:44:21 <c_wraith> well, I think Data.Dynamic got an update.. 
14:44:29 <jophish> edwardk: thanks for letting me know. I might resend my proposal about the default definition for `fromRational`
14:44:29 <c_wraith> but that hardly seems relevant. 
14:45:08 <quxbam> Cale: https://www.cis.upenn.edu/~sweirich/talks/compose16.pdf
14:46:10 <Cale> oh, right
14:46:17 <Cale> TypeRep is getting a type parameter
14:46:30 <Cale> I was actually at this talk, I just forgot completely :D
14:46:40 <quxbam> :)
14:48:54 <Cale> It is more of a change to Typeable than to Dynamic though
14:49:08 <Cale> Dynamic still looks and works the same way from the outside, iirc.
14:49:27 <Denommus> one of my colleagues went crazy with this: https://gist.github.com/Denommus/3d838ba14b4748d11a33
14:49:42 <quxbam> I've seen Dynamic first in this slide, so I'm a bit surprised about it's existence.
14:49:52 <EvanR> type reps are changing? seems like thatll breka stuff
14:50:20 <koz_> Is there some built-in in existence which will take (for example) [1, 2, 3] and give me [1/1, 1+2/2, 1+2+3/3]?
14:50:26 <koz_> (or help me get there at least)
14:50:32 <Cale> quxbam: Oh, it's been around for years
14:50:32 <Zemyla> How do you compare type parameters, then?
14:50:43 <EvanR> haskell supports dynamic typing in several ways, all of which entails crashing due to miserable mistakes as usual
14:50:48 <tomleb_> Can anyone give me a small pointer on how to use sessions with the Spock framework ?
14:51:05 <Zemyla> Like, if I have a and b I'm trying to unify, how am I supposed to do that?
14:51:20 <EvanR> i bet theres a cast
14:51:22 <kadoban> koz_: Probably not a built-in, but scanl and zipWith should get you there without a lot of typing
14:51:25 <lyxia> match on eqT
14:51:31 <Cale> Zemyla: eqT :: TypeRep a -> TypeRep b -> Maybe (a :~: b)
14:51:40 <Zemyla> Makes sense.
14:51:51 <koz_> kadoban: Thanks!
14:52:05 <koz_> kadoban: I'm guessing its type should be 'something -> [Double]' at the end of the day?
14:52:22 <Cale> quxbam: Dynamic itself doesn't tend to be so useful, but it's a trivial application of the Typeable machinery, which tends to be much more useful.
14:52:28 <kadoban> koz_: Well, depends how you need to use it, but sounds likely.
14:53:14 <koz_> kadoban: Alrighty, I'll look up scanl and zipWith.
14:53:59 <quxbam> Is there any work on #9557 in sight?  I've got a lib with about 300 types wich takes 20 min to compile...
14:54:08 <quxbam> Cale: thanks for the pointer
14:54:53 <Cale> quxbam: Usually you don't just want *any* sort of Typeable thing, but there are cases where you want to generalise over a bunch of things of various types, and be able to recover the actual type later (such as what goes on with Control.Exception), and Typeable is quite useful there.
14:57:30 <koz_> When I'm :m-ing in GHCi, is there a way to import only one function from a module instead of the whole thing?
14:57:47 <Cale> koz_: Not with :m, but you can use import declaration syntax
14:57:48 <koz_> Kinda like the 'import Foo.Chips (vinegar)' you can use in .hs files.
14:57:59 <glguy> koz_: Yeah, do that
14:58:01 <Cale> You can just write that
14:58:10 <koz_> OK, neat! Thanks.
14:59:29 * koz_ believes that Haskell is sorely missing a 'Chips' module.
15:00:10 <quxbam> Chips.crunch -> Yummy
15:04:46 <koz_> OK, my function is complaining about types. How do I go from [Integer] to [Double]?
15:04:50 <koz_> fmap fromIntegral ?
15:05:14 <lyxia> yes
15:05:18 <koz_> lyxia: Thanks.
15:06:36 <tomleb_> Why is there so little documentation on Spock ?
15:07:17 <quxbam> tomleb_: It isn't that popular
15:08:10 <tomleb_> quxbam: Damn it, I can't figure out the basic things and there's no resource anywhere
15:10:33 <quxbam> tomleb_: Out of curiosity, why spock?
15:12:56 <tomleb_> quxbam: It seemed simple, I thought I could understand it, even though I almost never used haskell. Seems like I can't, and now I don't know if I should switch or not. Which one would you recommend ?
15:13:01 <montanonic> tomleb_: Haskell web dev is small enough to where it makes sense to gravitate to the more popular frameworks: Scotty (small, straightforward), Servant (complex type system), or Yesod (lots and lots of stuff and idioms that you need to learn, but has a whole book)
15:13:46 <tomleb_> montanonic: Scotty is more popular ? I thought Spock was, guess I mixed them up.
15:13:50 <montanonic> tomleb_: http://bitemyapp.com/posts/2015-08-23-why-we-dont-chuck-readers-into-web-apps.html
15:14:00 <puregreen> isn't Scotty just like Spock but without some features?
15:14:03 <montanonic> tomleb_: I get them mixed up too; I forget which is more popular; I meant one or the other
15:14:20 <montanonic> puregreen: that's roughly what I've heard; just don't remember which has more/less features
15:16:04 <tomleb_> montanonic: So I should just stick to something else than haskell for web dev then ?
15:16:21 <tomleb_> Since I'm not familiar with most features
15:16:43 <montanonic> tomleb_: You shouldn't try using Haskell for web dev unless you want to learn Haskell.
15:16:59 <montanonic> tomleb_: if you want to learn Haskell, it's awesome.
15:17:37 <Iceland_jack> Second that
15:17:55 <quxbam> tomleb_: I recommend starting with yesod, it has got the best docs and is the most popular
15:18:11 <tomleb_> montanonic: I do want to learn Haskell, that's for sure. I have a small website due in 2 weeks, but I'm having trouble doing anything with the Spock framework.
15:18:13 <quxbam> Later on, rejoice on servant
15:18:20 <montanonic> tomleb_: is it due in Haskell?
15:18:28 <tomleb_> montanonic: Nah
15:18:49 <montanonic> tomleb_: you should probably use another language you're more comfortable with for the project
15:18:52 <kadoban> 2 weeks is pretty quick to learn this stuff, if it's a hard deadline. Depends what "small" means I guess too.
15:19:43 <tomleb_> Well, the website is almost already done, there's no database or anything, no interaction, it's only static webpages for the most part, with some templating.
15:19:55 <montanonic> tomleb_: then look into Hakyll
15:19:59 <koz_> I have 'sequence (fmap putStrLn y)', where y is [String]. However, its type ends up being 'IO [()]', and I need 'IO ()' (this is in main). What did I miss?
15:20:05 <adarqui> finding example projects on github should be a big help.. you try looking for spock projects on gh? if not, do that
15:20:12 <montanonic> tomleb_: or Yesod if you need it to be a bit more dynamic
15:20:24 <quxbam> koz_: sequence_
15:20:38 <koz_> quxbam: Derp, of course. I don't need the values.
15:20:40 <adarqui> static pages, check out https://jaspervdj.be/hakyll/
15:20:44 <quxbam> :)
15:20:51 <adarqui> then just figure out how to serve them from scotty/spock
15:20:56 <quxbam> or void sequence
15:21:14 <koz_> I'm still getting used to my new understanding of several Haskell things.
15:21:23 <quxbam> me too
15:21:33 <montanonic> tomleb_: Yesod comes pre-loaded with a scaffold that will work. It also has a book. It also was extremely hard for me to use until I actually knew what a Monad Transformer was. Your mileage may vary.
15:21:50 <quxbam> it's like the gold rush, each day until late night I'm learning
15:22:08 <tomleb_> Humm
15:22:15 <montanonic> quxbam: fun feeling, huh?
15:22:28 <quxbam> for a static site, you don't have to know anything about monad transformers in yesod
15:22:29 <koz_> HOLY SHIT IT RAN!
15:22:31 <koz_> Ahem.
15:22:34 <tomleb_> I'll see if I can find other project using Spock, else I might switch for something else
15:22:35 <koz_> Sorry about that.
15:22:48 <quxbam> montanonic: it's an addiction
15:23:01 <quxbam> at the moment, i'm in type level stuff
15:23:31 <quxbam> wouldn't it take so extremely long to compile, i wouldn't sleep anymore ;)
15:23:50 <tomleb_> It's the documentation that I find hard to read, like how types match together, with stuff like ActionCtxT ctx sess sql st () and all other weird variants lol
15:23:57 <montanonic> tomleb_: I just don't want you to hate Haskell, which is something that usually happens when people dive into the deep and then try to solve things the way they would in other languages, and then that doesn't work.
15:24:22 <Iceland_jack> <koz_> HOLY SHIT IT RAN!
15:24:22 <Iceland_jack> https://hackage.haskell.org/package/kan-extensions-5.0.1/docs/Data-Functor-Kan-Ran.html ?
15:24:22 <montanonic> tomleb_: yes, and it takes a while to get to the point where the types are useful, and arguably, it's extremely hard to do significant work until you get to that point
15:24:33 <tomleb_> montanonic: I would've quit when I was following a course on edx if I didn't like it :p
15:24:53 <montanonic> tomleb_: http://haskellbook.com/ will boost you through the things you need to know
15:24:54 <koz_> Iceland_jack: Lolwut?
15:25:15 <quxbam> tomleb_: or Learn You a Haskell for Great Good
15:25:18 <montanonic> tomleb_: better than anything else. You can contact the authors for a discount if you don't have many resources. 
15:25:33 <quxbam> You can read and understand it without problems in a weekend
15:25:58 <montanonic> quxbam: but there's no way you can comfortably use most libraries after reading it
15:26:07 <tomleb_> quxbam: I always come back to LYAH
15:26:27 <tomleb_> montanonic: true, it's easy to read but then I can't figure out how to use anything lol
15:26:46 <quxbam> montanonic: well, for most libraries you've to use them to learn them
15:27:00 <montanonic> quxbam: and read their source code, too
15:27:01 <quxbam> for example conduit-xml
15:27:16 <montanonic> (sometimes)
15:27:18 <tomleb_> montanonic: Haskellbook seems like a really good book, there's always someone mentionning it, guess I'll have to spend a bit, but it currently is not possible for me :p
15:27:27 <quxbam> before actually using it, it was totally intransparent to me
15:27:29 <koz_> I'm fond of the Haskell Wikibook myself.
15:27:41 <quxbam> koz_: yeah, it's good
15:27:43 <koz_> It actually has some *excellent* coverage of certain key ideas.
15:27:51 <montanonic> tomleb_: which is why you should contact one of the authors and briefly explain why you can't afford it and why you want it and they will make it work out for you.
15:27:57 <koz_> I also quite strongly recommend the Typeclassopedia.
15:28:05 <koz_> That thing is an *awesome* learning resource.
15:28:22 <montanonic> tomleb_: if you're not going to go for that though, the two resources koz_ just mentioned are much more thorough than LYAH
15:28:23 <shachaf> My recommendation would be not to read it.
15:28:35 <quxbam> And if someone feels academic, the git-annex from ocharles is worth a read
15:30:00 <quxbam> shachaf: learn you a haskell?  Why?
15:30:04 <tomleb_> quxbam: Oh, I know that name, I'm looking at his spock demo on darcs.com from his talk.
15:30:22 <shachaf> quxbam: No, the other book.
15:30:26 <quxbam> He's well known in haskell world
15:30:29 <quxbam> ahh
15:31:19 <quxbam> And in nix world
15:32:50 <quxbam> tomleb_: Have you already done some project euler? That was my first written haskell
15:34:34 <tomleb_> quxbam: Nope, only had a course on functional programming, which was in haskell so I had to touch a bit of haskell for it
15:34:53 <quxbam> go for it
15:35:06 <quxbam> you'll have to write a bit to feel comfortable
15:35:18 <quxbam> especially with the entire toolchain
15:35:32 <quxbam> cabal, ghcmod, ghc, stack ...
15:35:45 <koz_> :t (//)
15:35:46 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
15:35:59 <koz_> OK, is there an 'integer division' operator in the house?
15:36:04 <quxbam> div
15:36:05 <Iceland_jack> :t div
15:36:06 <lambdabot> Integral a => a -> a -> a
15:36:08 <koz_> quxbam: Thanks!
15:36:10 <tomleb_> `div`
15:36:14 <quxbam> your welcome
15:36:16 <tomleb_> yay I knew that
15:36:30 <tomleb_> *happy dance*
15:36:31 <quxbam> albeit it's not an operator
15:37:05 <Cale> There are actually two kinds of integer division, there's div and mod which go together, and then quot and rem
15:37:19 <Cale> They differ in terms of convention with respect to handling the sign
15:37:32 <Cale> > (-2) `mod` 5
15:37:34 <lambdabot>  3
15:37:40 <Cale> > (-2) `rem` 5
15:37:42 <lambdabot>  -2
15:37:53 <Cale> > (-2) `div` 5
15:37:55 <lambdabot>  -1
15:37:59 <Cale> > (-2) `quot` 5
15:38:00 <lambdabot>  0
15:38:39 <Cale> Usually div/mod are the ones you want, but quot/rem are what typically gets implemented in hardware because it's a few transistors cheaper
15:38:50 * hackagebot UTFTConverter 0.1.0.1 - Processing popular picture formats into .c or .raw format in RGB565  https://hackage.haskell.org/package/UTFTConverter-0.1.0.1 (cirquit)
15:39:19 <koz_> Cale: Thanks for that explanation.
15:40:26 <quxbam> The finest thing of the haskell channel is that people enjoy to teach and to learn.
15:41:18 <koz_> quxbam: And are Freundlich.
15:41:27 <koz_> (in the German sense of the word)
15:41:43 <maerwald> helpful is more important 
15:41:54 <quxbam> is there another sense than the German one?
15:42:09 <koz_> maerwald: Agreed, but having both helpfulness *and* friendliness is best.
15:42:17 <koz_> quxbam: The 'someone's IRC nick' sense?
15:42:30 <koz_> In the German sense, the intended meaning is 'and are friendly'.
15:42:48 <koz_> In the IRC nick sense, the resulting meaning would be 'and happen to be clones of the user named Freundlich'.
15:43:13 <quxbam> koz_: Do we have anyone here which is called Freundlich?
15:43:21 <koz_> quxbam: Yes.
15:43:24 <quxbam> Oh
15:43:44 <quxbam> He must be a nice guy
15:45:00 * EvanR imagining clones of krieger
15:47:35 <StarsC> is it possible to write import A,B,C like in LANG pragma?
15:47:50 <StarsC> too many imports :)
15:48:48 <EvanR> put all the imports in a single module and just import that everywhere! ;)
15:49:31 <Cale> EvanR: if only that would actually work for qualified imports
15:49:58 <StarsC> EvanR: :D
15:50:04 <EvanR> time for a new programming language to manage imports
15:50:09 <StarsC> yeah
15:50:25 <EvanR> and have it spawn an entire branch of mathematics
15:50:33 <EvanR> of module references
15:50:34 <StarsC> but comma for starters could really help
15:51:04 <StarsC> maybe somebody should propose it for upcoming summer of code? :)
15:51:35 <StarsC> any TH approaches to subject?
15:51:48 <quxbam> Oh, a sledge hammer
15:51:55 <StarsC> :)
15:52:27 <StarsC> when imports become longer than program u start to think 
15:52:48 <EvanR> the reason why the programs are so small though 
15:52:51 <greg> can anyone tell me why i might be inserting a space at the begining of
15:52:51 <greg>        a line whenever i sp-slurp/barf in haskell mode #emacs
15:53:03 <EvanR> because you dont have to typeOutAHugeDisambiguatingName everywhere
15:53:23 <EvanR> unlike the current sensibilities in elixir!
16:00:36 <hexagoxel> StarsC: if you already consider TH: if you use CPP, there is https://github.com/lspitzner/qualified-prelude
16:16:51 <newsham> is cat theory day yet? http://cdn.shopify.com/s/files/1/0537/4221/products/t-shirts-jose-gato-1_grande.jpg?v=1450295451
16:32:27 <koz_> :t elem
16:32:28 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
17:22:52 <tommd> Is there a good library implementing Gill's 'Observable Sharing' work (2009)?
17:23:53 * hackagebot tubes 2.0.0.0 - Write stream processing computations with side effects in a series of  tubes.  https://hackage.haskell.org/package/tubes-2.0.0.0 (gatlin)
17:24:50 <Iceland_jack> @hackage data-reify
17:24:50 <lambdabot> http://hackage.haskell.org/package/data-reify
17:25:55 <tommd> Iceland_jack: Yay, one maintained by Andy himself.  Thanks!
17:29:33 <Iceland_jack> Godspeed tommd :) it's a fun library
17:32:59 <miscyb> does anyone know if gtk2hs has support for gtk 3 stack/stack switcher?
17:33:26 <miscyb> i don't see it in there, but i'm not sure how it's laid out
18:24:05 <ElMoloko> whoa #haskell has been silent for almost an hour?
18:24:43 <ElMoloko> Could anyone tell me
18:24:54 * Clint squints.
18:25:25 <Axman6> echo...
18:25:38 <ElMoloko> I have a class
18:25:39 <ElMoloko> class ShowT where ...
18:26:21 <ElMoloko> Can I make an instance of ShowT dependent on any type being a member of another class?
18:26:32 <ElMoloko> Is this that dependent type stuff I have to 'fake'?
18:28:03 <Axman6> I don;t understand what you we're after, can you give an excample of what you'd like to have?
18:28:30 <ElMoloko> say, I have newtype Foo = Foo Text
18:29:15 <ElMoloko> and class ShowT foo where; showT a = (something)
18:29:29 <ElMoloko> and instance ShowT Foo ...
18:29:41 <ElMoloko> is there any way to have, like
18:30:14 <ElMoloko> instance (ShowT a) => Show a where ...
18:30:16 <ElMoloko> ?
18:30:28 <puregreen> hm, maybe you're looking for Show1
18:30:45 <puregreen> or not, nevermind
18:31:19 <ElMoloko> I can't remember the details totally
18:31:19 <linman32> hi, have error related to using GeneralizedNewTypeDeriving
18:31:20 <linman32> http://lpaste.net/162445
18:31:29 <ElMoloko> It's on my work machine
18:31:53 <ElMoloko> I keep getting an expected kind *, but got kind GHC.Prim.Constraint
18:31:59 <linman32> the code and error are pasted to lpaste above
18:32:09 <ElMoloko> And I can't figuer out why the GHC.Prim.Constraint
18:32:53 <acertain> maybe https://hackage.haskell.org/package/constraints-0.6/docs/Data-Constraint-Forall.html is useful?
18:33:32 <puregreen> or maybe ElMoloko just was an overlapping “ShowT a => Show a” instance
18:34:04 <puregreen> ElMoloko: you want to say “if a type is in class ShowT, I want it to automatically get a Show instance”?
18:34:12 <ElMoloko> Yeah
18:34:47 <ElMoloko> Sorry, I'm not quite at the level of fully understanding all the type stuff yet I guess...
18:35:28 <geekosaur> [05 01:29] <ElMoloko> instance (ShowT a) => Show a where ...
18:35:32 <ElMoloko> This link seems promising though
18:35:34 <geekosaur> note that that will overlap every other instance of Show
18:35:50 <geekosaur> even if you get it to work
18:36:19 <ElMoloko> What do you mean exactly?  Won't it just apply for all types that are instances of ShowT?
18:36:29 <geekosaur> no
18:36:36 <geekosaur> the context is applied *after* instance selection
18:36:52 <geekosaur> newcomers always want it to happen before, but there are good reasons for it to work the way it does
18:37:25 <ElMoloko> Oh whoa, awesome.  I had no idea.  All my research, I didn't figure that out...
18:37:37 <ElMoloko> So much to learn!
18:39:23 <ElMoloko> Anyway, I can just rewrite my code...
18:40:02 <ElMoloko> So, I can't find documentation on the kind GHC.Prim.Constraint
18:40:47 <geekosaur> Constraint is the kind (which is the "type" of a type) of the thing on the left of => in a signature
18:40:55 <ElMoloko> Is it for the constrained contexts which you are describing?
18:41:02 <ElMoloko> oh!
18:41:17 <geekosaur> usually errors involving it mean you enabled DataKinds or a related extension, and have confused which level you're working on
18:41:54 <ElMoloko> I made sure that DataKinds wasn't enabled :)  also I got the same error when it was
18:42:09 <geekosaur> hm, actually now I wonder if ShowT was a type instead of a class, and when you tried to use it as a constraint it promoted it and then became confused
18:42:16 <geekosaur> where is theis ShowT defined?
18:42:18 <scshunt> ElMoloko: you need UndecidableInstances for what you're describing
18:42:29 <ElMoloko> that sounds....scary
18:42:44 <scshunt> ElMoloko: in standard Haskell, the typeclass resolver is guaranteed to resolve
18:42:45 <geekosaur> (sometimes ghc will "helpfully" suggest you enable kind level stuff when it sees such confusion)
18:42:49 <adamCS> ElMoloko: Not sure if it will help but there are some examples of trying to accomplish the sort of overlap you may be trying to do: https://wiki.haskell.org/GHC/AdvancedOverlap
18:43:02 <ElMoloko> on another note, how to get GHCi to set language pragmas from :load?
18:43:11 <ElMoloko> ShowT was definitely a typeclass
18:43:25 <scshunt> one of the ways this is guaranteed is by requiring that you always tighten the levels of constraints
18:43:28 <ElMoloko> Thanks for the link
18:43:33 <adamCS> yep
18:43:34 <scshunt> you can't do things like instance (Foo a) => Bar a
18:43:57 <scshunt> if you allow that, and you have instance (Bar a) => Foo a, bad things happen
18:44:05 <scshunt> and more generally, you can create undecidable resolution problems
18:44:18 <scshunt> it turns out that these sorts of instances are incredibly useful, however, so it's very common to turn them on (see: mtl)
18:44:32 <geekosaur> linman32, I'm looking at your issue, but as far as I know anything that exports ReaderT also exports MonadReader
18:44:46 <scshunt> (in fact, I'd go so far as to argue that because of mtl, it's the single most important language extension)
18:44:56 <scshunt> geekosaur: not true
18:45:07 <ElMoloko> I don't like bad things happening :P  I'm trying to accomplish my goal without enabling anything that can result in more ambiguity.
18:45:16 <scshunt> geekosaur: mtl does, transformers doesn't
18:45:28 <geekosaur> linman32, ^^
18:45:45 <scshunt> transformers is basically mtl minus UndecidableInstances
18:45:57 <geekosaur> you didn't provide much context, so guessing...
18:45:57 <linman32> geekosaur, scshunt: thx
18:46:37 <scshunt> ElMoloko: honestly, just be careful what you do
18:46:44 <geekosaur> linman32, if you *are* using transformers then you can't use those instances (unless you implement your own)
18:46:46 <scshunt> unless you're writing orphans, it shouldn't be a big problem anyway
18:46:56 <ElMoloko> I know how to rewrite my code though, in a more sensible way, though.  Probably save a few hundred LOC too (I did get it working eventually, but with lots of what i can only describe as 'unnecessary glu)
18:46:58 <geekosaur> so of course you can't derive them
18:47:05 <ElMoloko> Thanks all
18:47:34 <ElMoloko> (also without those overlapping instances)
18:48:05 <linman32> ok, this seems to work though: import Control.Monad.Reader.Class (MonadReader)
18:48:14 <scshunt> linman32: yep, that's the mtl
18:48:23 <scshunt> Control.Monad.* and Control.Monad.*.Class are mtl
18:48:29 <scshunt> Control.Monad.Trans.* is transformers
18:49:02 <geekosaur> scshunt, to be honest I was not thinkling of transformers because people using that instead of mtl *usually* know what they are doing
18:49:12 <geekosaur> instead of trying to use mtl classes with it
18:49:30 <geekosaur> (you know, like using mtl classes kinda implies you're using mtl)
18:49:55 <scshunt> geekosaur: yeah, but it's fairly easy to juse use Control.Monad.* and not realize how mtl and transformers interact
18:50:03 <scshunt> *just
18:52:28 <kadoban> I always forget how mtl and transformers are related xD
19:23:25 <dusan> Hi there! Has anyone managed to use the System.KQueue module successfully? If so, what is the first argument to the kevent call when retrieving events please?
19:29:26 <Axman6> dusan: it's the shared KQueue that you create by calling kqueue :: IO KQueue (at the top of the haddocks)
19:30:03 <dusan> Axman6: oh, sorry, I meant the second one
19:30:23 <dusan> forgot the obvious KQueue as the first one
19:40:45 <geekosaur>        -> [KEvent]              -- ^ The list of events to start monitoring, or changes to retrieve.
19:41:31 <geekosaur> basically, each time you call kevent, you can set or change the list of events the kqueue watches for
19:41:53 <geekosaur> see `man kqueue`
19:44:14 <dusan> geekosaur: I have been using kqueue in C a lot, so I get the basic idea
19:44:59 <dusan> the issue seems to be that I am getting exceptions (the kevent returned -1) and I am not sure why is that
19:45:21 <dusan> if I provide an empty list [] as the the second argument, is that OK?
19:45:31 <geekosaur> only on the second call
19:45:34 <geekosaur> and later
19:45:44 <geekosaur> the first should specify what events the queue should look for
19:45:47 <dusan> exactly
19:46:08 <dusan> so is it OK to call it with [] on second and further calls?
19:46:21 <geekosaur> it should be? I haven't used the haskell kqueue binding
19:46:35 <geekosaur> (no longer have any freebsd boxes, and don't use kqueue on the os x box)
19:47:04 <dusan> https://github.com/hesselink/kqueue/blob/master/src/System/KQueue.chs#L200
19:47:14 <dusan> would you mind making your best guess based on the code here?
19:48:46 <geekosaur> looks like it's doing the right thing to me. what's the errno you get back? (KQueueException looks to be an IOException, so it should have an errno)
19:49:13 <geekosaur> (although maybe they don't have that glued in correctly, in which case you get to truss your program to see what the syscall is actually doing)
19:50:27 <dusan> I was thinking whether the second argument does not have to be a list of KEvents that gets "overwritten" in a C style
19:50:59 <dusan> but that sure does not sound very Haskelly
19:51:34 <dusan> i am not getting any errno from the code
19:52:17 <geekosaur> the C interface doesn't even do that; second and third parameters (pointer to event change list, and its size) are "in", 4th is "out" (ptr to matching event array), 5th is "in" (max size of the previous array)
19:52:38 <dusan> yep, my bad
19:52:42 <geekosaur> um. if kqueue is returning -1 then errno should be being set
19:53:17 <geekosaur> although I wonder now if you're doing things that require kevent64, but this binding only uses kevent?
19:55:30 <dusan> its a i386 system
19:55:40 <dusan> so the 32bit kevent should be fine
19:55:59 <dusan> so, running truss on the executable, where exactly do I find the errno in the output please?
19:56:13 <dusan> i can see the two kevent calls (one adding, one querying)
19:56:55 <geekosaur> sigh. I can't even check how truss output looks and it's been too long. thought it usually put the errno after the -1 error return
19:57:35 <geekosaur> and os x doesnt use truss and is completely different (it uses dtruss and the dtrace implementation is ... undersized for usefulness)
19:58:04 <geekosaur> you could lpaste the relevant part of the truss output though
19:58:05 <dusan> its written there "ERR#4 Interrupted system call"
19:58:05 <geekosaur> @paste
19:58:05 <lambdabot> Haskell pastebin: http://lpaste.net/
19:58:09 <geekosaur> ohhh
19:58:33 <geekosaur> try compiling your program with -rtsopts and running with +RTS -V0
19:58:54 <geekosaur> and if that works then you get to compile a bug report against the kqueue package :)
19:59:23 <geekosaur> (they're binding it wrong and it's getting interrupted by the RTS timer tick)
19:59:39 <monochrom> how to bind it right?
19:59:59 <geekosaur> doesn't "safe" do that?
20:00:25 <geekosaur> hm, guess not. but pretty much every binding to a syscall including the RTS's own would fail without some way to do that
20:00:39 <geekosaur> like, the network package manages to work
20:01:04 <monochrom> interesting
20:01:05 <geekosaur> and I don't think it uses wrappers that disable itimers
20:01:13 <geekosaur> it just uses the normal FFI mechanisms
20:01:20 <dusan> so
20:01:29 <dusan> it helped to the point that its not failing :)
20:01:36 <geekosaur> yes that was the idea
20:01:55 <geekosaur> -V0 told the RTS to not regiter its itimer, if that stopped the -1/errno=4 then that was the cause of your problem
20:04:15 <dusan> thank you very much :)
20:04:50 <dusan> do you have any idea how to fix that in the library? so that maybe I can create a pull request for that
20:06:03 <geekosaur> unfortunately I don't; it's using c2hs, and I'm not really familar with how you configure its bindings. I'm more used to hsc2hs
20:06:40 <geekosaur> oh wait, it's a normal foreign import. and they forgot to specify
20:09:33 <dusan> thats a terrible cliffhanger :D what did they forgot?
20:09:42 * geekosaur is reading FFI spec to make certain
20:10:00 <monochrom> if you don't say either "safe" or "unsafe", the default is "safe"
20:10:11 <geekosaur> but the default is "safe" and that "should" shut off the itimer while in C, since it is not to be expected that random C functions expect itimers to go off on them
20:11:02 <geekosaur> ...
20:11:29 <geekosaur> h2010 does not include the stuff about unsafe not being allowed to allocate memory or etc., just says it can't re-enter.
20:11:40 <geekosaur> wonder if that means unsafe is actually correct for this
20:12:11 <geekosaur> (h98 FFI extension conflated two different meanings for "safe")
20:12:24 <monochrom> GHC adds a lot more semantics to "safe" and "unsafe" than Haskell 2010 does.
20:12:38 <geekosaur> yes, and I checked the ghc manual first; it doesn't seem to specify :
20:12:40 <geekosaur> :/
20:13:55 <geekosaur> ghc also adds "interruptible" which is related but not this issue (and implementation implies that, if it did apply, the default would be correct)
20:14:18 <geekosaur> might have to ask in #ghc or on the glasgow-haskell-users list :/
20:14:40 <geekosaur> or dig into the source for the network package to see how they protect e.g. "listen"
20:14:49 <geekosaur> er, not listen. accept
20:15:01 <dusan> something blocking you mean
20:15:02 <geekosaur> ...wait, they don't.
20:15:13 <EvanR> network doesnt use ffi does it
20:15:24 <geekosaur> they hand it to the I/O manager to do. but you can't do that here Ithink; kqueue is not a normal file descriptor
20:15:34 <geekosaur> it ffi-s to the socket system calls
20:15:49 <dusan> kqueue is a normal file descriptor
20:15:55 <dusan> C code: int kq = kqueue();
20:15:58 <geekosaur> but this part it uses the I/O manager for, because sockets are normal file descriptors (on unix at least)
20:16:12 <geekosaur> dusan, can you epoll() on a kqueue?
20:16:17 <geekosaur> with default flags?
20:16:34 <dusan> i am quite sure that epoll is a linux thing
20:16:40 <dusan> and kqueue a BSD thing
20:17:01 <geekosaur> I thought fbsd had something equivalent; "epoll" is just what ghc calls the general mechanism for something that isn't select() and isn't as limited as the original SVID poll()
20:17:03 <dusan> but you can add kqueue to a kqueue
20:17:13 <geekosaur> never mind, I should not have asked you
20:17:28 <dusan> thats kqueue exactly
20:17:32 <geekosaur> ...
20:17:52 <dusan> epoll + inotify == kqueue
20:17:53 <geekosaur> dusan, are you assertingt hat ghc's IO manager uses kqueue internally then?
20:18:05 <geekosaur> or do you even see my point here?
20:18:38 <dusan> I have no knowledge of the ghc internals
20:19:02 <dusan> but kqueue is definitely the BSD alternative to epoll
20:19:11 <geekosaur> then you are not seeing my point
20:19:21 <dusan> sorry
20:19:48 <geekosaur> and perhaps you should just take the basic question of how to deal with a syscall via FFI that would be interrupted by the runtime itimer to #ghc
20:20:09 <dusan> sure, will do :)
20:20:13 <geekosaur> or better to the mailing list since the channel isn't always active
20:20:41 <geekosaur> the point here is whether ghcs IO manager can deal with a kqueue. since it needs special support for most other special file descriptors, my guess is "no"
20:21:44 <geekosaur> special here means: can you treat it as a thing you can call read() or write() on, or use the polling facilities on it as if it were such a thing
20:22:06 <geekosaur> it needs special support for fifos, and various other things that don't act like disk files or sockets
20:22:27 <geekosaur> since you don't call read() or write() on a kqueue, I expect special handling to be needed
20:22:31 <dusan> oh
20:22:37 <dusan> now i get your point
20:22:44 <dusan> didnt know about the special support needed
20:22:57 <dusan> i wish there was a book on the GHC internals: is there one?
20:22:59 <geekosaur> an id you just do like network does and call into the IO manager to wait for the kqueue to be ready, you may get unexpected results
20:23:05 <geekosaur> no, there isn't
20:23:16 <geekosaur> what I know I got by reading through the source. I gather that's true for most people
20:23:25 <geekosaur> who've had any direct inv olvement with ghc
20:23:45 <rahulmutt> The source code for the IO Manager is in base in GHC.Event 
20:23:56 <EvanR> from what i heard ghc uses kqueue or epoll
20:24:02 <rahulmutt> It uses kqueue/epoll based on the platform
20:24:02 <EvanR> "depending"
20:24:09 <rahulmutt> (Conditional compilation)
20:24:16 <geekosaur> oh, it does use kqueue? then it's possible there is support for kqueue fds
20:24:41 <geekosaur> and the direct binding used by this module needs to be wrapped in an IO manager call to wait for the kqueue to become ready
20:25:08 <rahulmutt> https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Event/Manager.hs
20:25:20 <rahulmutt> #if defined(HAVE_KQUEUE)
20:25:20 <rahulmutt> import qualified GHC.Event.KQueue as KQueue
20:25:20 <rahulmutt> #elif defined(HAVE_EPOLL)
20:25:20 <rahulmutt> import qualified GHC.Event.EPoll  as EPoll
20:25:20 <rahulmutt> #elif defined(HAVE_POLL)
20:25:20 <rahulmutt> import qualified GHC.Event.Poll   as Poll
20:25:20 <rahulmutt> #else
20:25:21 <rahulmutt> # error not implemented for this operating system
20:25:21 <rahulmutt> #endif
20:26:07 <dusan> so does this help the itimer situation in any way?
20:26:38 <geekosaur> [05 03:24] <geekosaur> and the direct binding used by this module needs to be wrapped in an IO manager call to wait for the kqueue to become ready
20:27:29 <geekosaur> trying to recall where the IO manager foo lives
20:28:12 <geekosaur> https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/GHC-Conc-IO.html#v:threadWaitRead
20:28:18 <hackrilege> hi, i have reduced my bug down to the most simple form, but i still am having trouble defining an instance for a Free datastructure; http://lpaste.net/162448
20:28:18 <geekosaur> and threadWaitWrite
20:29:40 <geekosaur> so this way your thread blocks until kevent can return events without blocking, and then you do a non-blocking kevent call when it returns ready
20:30:18 <geekosaur> the simple-minded binding that is there blocks instead of usingt he IO manager, and so it gets interrupted by the timer tick. it should have the IO manager do the blocking instead
20:30:29 <geekosaur> which is what threadWaitRead and threadWaitWrite are for
20:30:42 <geekosaur> I *think* threadWaitRead is correct for this...
20:31:10 <geekosaur> see also closeFdWith in the same module
20:31:39 <geekosaur> if you are sharing this kqueue between thrreads then you need that call to make sure any other threads know that you are closing the kqueue fd
20:32:58 <geekosaur> in the meantime +RTS -V0 should get you going; it's less efficient than the normal mode, but unless you were planning to do profiling it's not harmful
20:33:36 <geekosaur> oh, and multiple threads may not work well because kevent() is blocking
20:33:44 <geekosaur> (this is why the IO manager exists and should be used)
20:34:12 <dusan> thank you :)
20:34:25 <dusan> i will need to educate myself on the ghc topics you mentioned here
20:35:39 <kadoban> How does one figure out what packages depend on a given on on hackage? I thought there was a way, but I'm not seeing it.
20:35:47 <kadoban> s/on on/one on/
20:36:05 <hackrilege> is it impossible to write a cojoin for Free f?
20:36:07 <hackrilege> http://lpaste.net/162448
20:37:00 <hackrilege> :t duplicate
20:37:01 <lambdabot>     Not in scope: ‘duplicate’
20:37:01 <lambdabot>     Perhaps you meant one of these:
20:37:01 <lambdabot>       ‘replicate’ (imported from Data.List),
20:37:15 <hackrilege> :t Data.Comonad.duplicate
20:37:16 <lambdabot> Not in scope: ‘Data.Comonad.duplicate’
20:37:20 <geekosaur> kadoban, http://packdeps.haskellers.com/reverse
20:37:26 <hackrilege> :t Control.Comonad.duplicate
20:37:27 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
20:37:54 <hackrilege> but Free f a = Free f (Free f a)!!
20:37:57 <kadoban> geekosaur: Thanks. Apparently … not much for my queried package, heh.
20:38:04 <hackrilege> its driving me nuts!
20:40:03 <hackrilege> any ideas?
20:40:47 <athan> anyone ever run into a "premature end of compression stream" error when building with cabal?
20:41:50 <hackrilege> it would be useful if someone could confirm that i cant do what im trying to do here http://lpaste.net/162448
20:42:27 <geekosaur> athan, usually means something went wrong with the download --- cabal doesn't save to disk before unpacking, it unpacks as it comes in
20:43:05 <athan> geekosaur: hmm that's weird, I keep trying and it's still borking. I'm going to update cabal and see if that helps. Thank you!
20:43:20 <geekosaur> (very occasionally it means that the Haskell gzip library doesn't understand something in the compressed data, doesn't happen often)
20:43:35 <athan> I think it's from psqueues :s
20:43:51 <geekosaur> (since for cabal it uses a pure Haskell impl instead of a gzip binding, so it doesn't need extra C dependencies)
20:43:57 <athan> psqueues-0.2.2.1 THAT IS
20:44:00 <athan> gah caps
20:44:34 <athan> actually hold on let me pin this down
20:45:16 <athan> agh what the heck, both of the libraries it was downloading are installing fine when issued isolated
20:46:01 <hackrilege> i think cabal might be wounded
20:46:04 <athan> interesting, now it's saying default-instances-base-0.1.0 doesn't exist
20:46:23 <hackrilege> geekosaur, athan, do you know if its possible to write an instance for Comonad (Free f)?
20:46:33 <geekosaur> hackrilege, no idea
20:46:53 <geekosaur> haven't looked at comonads much
20:47:04 <montanonic> hackrilege: not sure. I know you can write an instance for CoFree though
20:47:36 <athan> how would you deconstruct the functor?
20:48:14 <athan> I think `Comonad f => Comonad (Free f)` might work
20:48:17 <geekosaur> athan, that makes me think the thing ti was failing to decompress was the package list? try cabal update
20:48:39 <athan> yeah in a fresh cabal sandbox it ran into the same issue, will do :)
20:49:06 <athan> aie karumba, it's still not working
20:49:29 <geekosaur> odd.
20:49:43 <geekosaur> might ask in #hackage to see if there are any current known issues
20:49:48 <athan> data-default-instances-base is causing it
20:50:04 <athan> It's just not able to find a directory
20:50:12 <athan> a simple log directory :s
20:50:52 <scshunt> hrm
20:51:00 <scshunt> I really need to sort out what order I want my transformer stack to be in
20:51:20 <Cale> hackrilege: That Free isn't a comonad so far as I know.
20:51:42 <athan> scshunt: why?
20:51:57 <dibblego> @src (.)
20:51:57 <lambdabot> (f . g) x = f (g x)
20:52:10 <scshunt> athan: because I can't decide how short-circuity my errors should be
20:52:18 <athan> ooh :o good point
20:53:08 <hackrilege> the problem is that when writing cojoin :: w (w a) with w = (Free f), Free f a = Free f (Free f a)
20:53:11 <scshunt> especially the way they interact with another class I have
20:53:15 <dibblego> @pf \x -> f (g x)
20:53:16 <lambdabot> Maybe you meant: pl bf
20:53:27 <dibblego> @pl \x -> f (g x)
20:53:28 <lambdabot> f . g
20:53:29 <Cale> hackrilege: Consider  empty :: Free [] a; empty = Recurse [] -- what value of type a should extract give when applied to this?
20:53:36 <athan> point-less? :P
20:53:42 <dibblego> @pointful (.)
20:53:43 <lambdabot> (\ a b c -> a (b c))
20:53:57 <hackrilege> extract empty fails as does head
20:54:03 <scshunt> I think, in order to do what I really want, I need to put the ExceptT on the outside
20:54:50 <Cale> hackrilege: Yeah, so what you really want is something known as Cofree
20:54:51 <scshunt> or maybe not...
20:54:51 <scshunt> hrm
20:55:02 <Cale> hackrilege: http://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html
20:55:12 <scshunt> basically what I want is
20:55:15 <hackrilege> i know Cofree, but i didnt think thats what i was after
20:55:55 <Cale> Well, I don't know what you're trying to do, but if you want to extend a functor freely into a comonad, then Cofree is the way to do it.
20:56:03 <scshunt> hmm no wait, I definitely want ExceptT on the outside I think?
20:56:28 <scshunt> or, hrm
20:57:07 <scshunt> athan: basically I'm making a user interaction, and if an error occurs, it should abort out and return control to the user with the previous state.
20:57:49 <athan> scshunt: So then your error should be inside state, shouldn't it?
20:57:49 <hackrilege> for Cofree f => Free f a = f (Free f a) so i can use the Cofree instance of f directly
20:57:52 <Cale> (well, cofreely)
20:58:08 <athan> because effects bubble out?
20:58:10 <hackrilege> Comonad*
20:58:19 <athan> er, man
20:58:22 <athan> it's been a long time :S
20:58:42 <scshunt> athan: yeah see this is where it gets confusing
20:58:50 <athan> You should have `ExceptT Errors (StateT State m) a`
20:59:01 <scshunt> right
20:59:07 <scshunt> ok
20:59:12 <athan> that isn't to say that it will revert all mutations though
20:59:22 <athan> `do {somethingStateful; throwsError}`
20:59:23 <scshunt> right, I'd need to take steps to do that myself
20:59:28 <athan> will still apply `somethingStateful`
20:59:28 <hackrilege> Cale, your problem with Free [] stems from the problem with the Comonad instance of Free
20:59:43 <athan> That's actually an interesting property scshunt
20:59:52 <hackrilege> i should have a Comonad constraint in my paste sorry ill amend it
20:59:57 <athan> something something delimited continuations o_o
21:00:49 <athan> like a "commitable" state or something
21:01:24 <scshunt> athan: atomically computation = do { s <- get; atomically `catchError` (\e -> put s; throwError e) }
21:02:01 <athan> where it's a modification to StateT, such that `get` and `put` can be done in their own thread, but `runStateT` still has the original state unless there's a call to `commit` made
21:02:07 <athan> scshunt: hmm....
21:02:11 <athan> good eye :)
21:02:19 <scshunt> err
21:02:26 <scshunt> replace the second atomically with computation
21:02:29 <scshunt> other than that, yeah
21:02:48 <athan> scshunt: I'm going to hack on something myself, but I will let you know what I come up with
21:03:24 <scshunt> athan: I also have at least one thing between the ExceptT and StateT but I don't think it changes this really
21:03:31 <athan> it will probably be drasically lazy like WriterT
21:03:53 <athan> scshunt: Yeah I think you're right
21:04:08 <athan> if you issue `commit` in your success path, then it should be fine
21:04:38 <athan> like `do {somethingStateful; possiblyErroneous}`, where `commit` is issued in the success path in `possiblyErroneous`
21:08:15 <scshunt> athan: commit?
21:08:28 <athan> scshunt: I'll define laws once it's ready :)
21:08:31 <scshunt> athan: oh, sure
21:08:42 <scshunt> yes, if you're writing something new, that will work
21:08:58 * hackagebot nested-routes 7.1.0 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-7.1.0 (athanclark)
21:12:29 <augur> Worldly Type Systems by Conor McBride / pigworker : https://www.youtube.com/watch?v=9v4_FQm-b4I
21:14:35 <hackrilege> Cale, is this better? http://lpaste.net/162448
21:17:24 <hackrilege> if any one else can see how to fix that bug i would be very happy
21:21:59 <hackrilege> in
21:21:59 <hackrilege> Actual type: Free (G s) (G s (Free (G s) a))
21:22:22 <hackrilege> i cant figure out where the unwanted G s is coming from...
21:24:35 <scshunt> hackrilege: duplicate a
21:24:55 <scshunt> a is a G s (Free (G s) a)
21:27:57 <hackrilege> what about it?
21:29:00 <hackrilege> here, i put the type of duplicate a for clarity...
21:29:00 <hackrilege> http://lpaste.net/162448
21:31:22 <hackrilege> duplicate a ::  G s (G s (Free (G s) a))
21:32:06 <hackrilege> to which i apply Recurse . (fmap Basecase)
21:32:44 <hackrilege> :: Free (G s) (Free (G s) (Free (G s) a))
21:32:59 <hackrilege> = Free (G s) (Free (G s) a)
21:33:16 <hackrilege> i dont know how that goes wrong...
22:00:01 <fatex> is AMD FX-Series FX-8320 (3.50GHz) + 8GB of RAM a decent setup for ghc, or do I need something faster?
22:00:12 <fatex> (I heard ghc can be slow and is memory hungry)
22:01:04 <kadoban> I don't know processors, but should be fine. I use a lot of crappy hardware for GHC and the only thing that really is annoying is low RAM (4GB or below, when something else is using a lot of it goes … badly).
22:01:56 <fatex> alright, so I don't need dual xeons ? :-)
22:02:13 <kadoban> No, but on the other hand I wouldn't turn them down ;)
22:02:33 <kadoban> Tooling can help too, you want to use something like stack that tries to avoid compiling the same stuff over and over.
22:02:58 <kadoban> Most of the annoyingly long compile times are just dependencies, not my actual code.
22:04:34 <zomg> fyi low RAM situations can be somewhat alleviated by mapping additional swap temporarily
22:04:49 <zomg> especially useful if you try to compile big stuff on low ram VPS servers like me =)
22:05:01 <fatex> ok, so basically upgrade RAM, not CPU
22:05:03 <fatex> got it
22:05:24 <fatex> maybe throw in a SSD too
22:05:45 <kadoban> Yeah, if I was going to upgrade anything personally it'd be RAM. Though 8GB should be enough. Though RAM is cheap, if you're buying now, might as well throw in more IMO. It's nice to be able to run VMs and such if nothing else.
22:06:16 <fatex> I think the MB supports up to 32 GB
22:06:22 <fatex> Amazon quotes 32GB at ~150.00
22:06:23 <kadoban> zomg: Doesn't really seem to help in my setups, though I'm not sure why not either. Might have something to do with hard drive encryption, that's the only really non-standard thing I do.
22:06:30 <fatex> 32 GB should be enough for most GHC tasks ?
22:06:52 <kadoban> 8GB is going to be enough for GHC tasks I would think, I have 4GB and I get by fine unless I'm doing a ton of other stuff.
22:07:34 <kadoban> But if it were me I'd get more anyway just because other stuff I do would be … easier with it. Like VMs.
22:08:57 <fatex> I only need to support 2 things: ghc and deep learning
22:08:59 <fatex> no VMs for me
22:09:42 <cheater> hey guys
22:10:10 <cheater> what's a generic way of traversing data structures, e.g. trees, maps, etc?
22:10:44 <pavonia> :t traverse
22:10:45 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:10:54 <kadoban> cheater: Foldable and Traversable come to mind
22:11:19 <cheater> sorry what i meant was not exactly traversing
22:11:33 <cheater> instead i meant pointing to a specific element in the (possibly nested) structure
22:11:49 <kadoban> zippers, possibly?
22:11:50 <cheater> would you say a zipper is what i'm looking for?
22:11:54 <cheater> mhm
22:11:55 <cheater> yeah
22:12:09 <cheater> what do zippers work for? i know nary trees, but what else?
22:13:05 <jle`> i wonder if people use zippers directly irl
22:13:28 <jle`> i feel like most zipper applications were supplanted by generic comonadic interfaces
22:14:00 <cheater> i'm working on a dsp library that would be using something like zippers directly
22:14:08 <EvanR> whats a generic comonadic interface
22:14:28 <cheater> in a zipper, the context is the same context you'd have in a comonad
22:14:48 <cheater> so you can just have a comonad created by generics and you can do the same stuff most of the time
22:14:50 <fatex> Zipper is only a single 'pointer/cursor' right? what if I want more than one ?
22:14:57 <cheater> then you have two zippers
22:15:09 <EvanR> a generic comonad cant do anything except what functor can do
22:15:22 <EvanR> or are we talking about Generics
22:15:40 <jle`> EvanR: generic as in interfaces polymorphic over comonads in general or things implemented on top of unspecialized comonads like Store
22:15:49 <jle`> yeah, by generic i mean polymorphic
22:15:49 <cheater> not sure what you base your statement about Functor on
22:15:55 <EvanR> the later might make more sense
22:16:05 <EvanR> but polymorphic in all comonads seems kind of useless
22:16:30 <jle`> yeah, i guess i meant more general-purpose comands than specialized zippers
22:16:33 <jle`> *comonads
22:16:45 <jle`> but, i don't know enough to say for sure about the evolution of this trend
22:16:53 <cheater> anyways,
22:17:17 <cheater> the idea in my library is to use well known dsp concepts as control structures
22:17:18 <EvanR> which is why the comonad package has no utility functions for them
22:17:43 <dibblego> @src Show []
22:17:43 <lambdabot> Source not found. You untyped fool!
22:17:47 <dibblego> @src [] Show
22:17:47 <lambdabot> Source not found. Just try something else.
22:18:36 <cheater> for example, the low pass filter (lpf): if you have a single tree, and you have a stream of "cursors" or zippers pointing to specific nodes, but those change too quickly, and you'd like a slowly moving "average" of those
22:18:52 <dibblego> @src show
22:18:53 <lambdabot> show x = shows x ""
22:18:56 <dibblego> @src show
22:18:56 <lambdabot> show x = shows x ""
22:18:56 <dibblego> @src shows
22:18:57 <lambdabot> Source not found. Wrong!  You cheating scum!
22:19:08 <cheater> or the high pass filter: again you have a tree, but now you have a stream of cursors that barely change, and you want to know only when the cursors do actually change in a significant way
22:19:25 <kadoban> dibblego: You can play with lambdabot by /msg'ing it
22:20:04 <kadoban> dibblego: Also @src usually kind of sucks. I generally just find whatever I'm looking for on hackage and then look at the source there.
22:20:14 <cocreature> jle`: do you have some example of using comonads as a replacement for zippers? I don’t think I’ve seen that before
22:20:30 <cheater> also, i've already written a thing that generalizes convolution, (f)map, scanl and scanr.
22:20:38 <cheater> in one function.
22:21:29 <jle`> cocreature: i know that traditional zipper examples like spreadsheets/infinite streams are often implemented using Store now
22:21:42 <cheater> what's Store?
22:21:55 <cheater> @hoogle Store
22:21:57 <lambdabot> package binary-store
22:21:57 <lambdabot> package data-store
22:21:57 <lambdabot> package eventstore
22:21:59 <jle`> data Store s a = Store s (s -> a)
22:22:09 <EvanR> its a comonad for a container and a pointer into the container
22:22:21 <dibblego> @src intercalate
22:22:21 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
22:22:29 <dibblego> @src intersperse
22:22:30 <lambdabot> intersperse _   []     = []
22:22:30 <lambdabot> intersperse _   [x]    = [x]
22:22:30 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
22:27:01 <cocreature> jle`: ok, I’ll search around for that
22:27:38 <jle`> i could be wrong ><
22:27:46 <dibblego> @pl \r e -> Cons e r
22:27:46 <lambdabot> flip Cons
22:28:19 <cocreature> comonad-extras has https://hackage.haskell.org/package/comonad-extras-4.0/docs/Control-Comonad-Store-Zipper.html so you are right at least in some way :)
22:28:44 <Xnuk> @hoogle f -> Array i a -> Array i b
22:28:45 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
22:28:45 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
22:28:45 <lambdabot> Data.Graph.Inductive.Graph subgraph :: DynGraph gr => [Node] -> gr a b -> gr a b
22:29:01 * hackagebot resourcet 1.1.7.4 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.7.4 (MichaelSnoyman)
22:29:04 <jle`> i guess i should be saying ComonadStore-based interfaces then
22:29:11 <jle`> instead of Store directly?
22:29:17 <Xnuk> @hoogle (a -> b) -> Array i a -> Array i b
22:29:18 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
22:29:18 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
22:29:18 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
22:29:36 <jle`> Xnuk: are you looking for fmap?
22:29:57 <Xnuk> jle`: Can I use it for Array?
22:30:11 <cocreature> yep
22:30:12 <jle`> unboxed instances have a Functor instnace
22:30:14 <jle`> you can check on the docs :)
22:30:19 <jle`> http://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array.html
22:30:24 <jle`> *boxed instances
22:30:24 <hackrilege> :t fmap id (a::Array Int Double)
22:30:26 <lambdabot>     Couldn't match expected type ‘Array Int Double’
22:30:26 <lambdabot>                 with actual type ‘Expr’
22:30:26 <lambdabot>     In the second argument of ‘fmap’, namely ‘(a :: Array Int Double)’
22:30:37 <cocreature> jle`: isn’t it the other way around? the boxed ones have a functor instance?
22:30:40 <Xnuk> Thank you
22:30:42 <jle`> yeah heh
22:32:03 <hackrilege> still hoping for some help with http://lpaste.net/162448
22:33:36 <EvanR> where the heck did arrows come from anyway
22:33:45 <EvanR> they seem to be not as popular nowadays, why were they ever
22:33:51 <kadoban> bows, usually
22:34:01 * hackagebot conduit 1.2.6.5 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.6.5 (MichaelSnoyman)
22:34:03 * hackagebot socks 0.5.5 - Socks proxy (version 5) implementation.  https://hackage.haskell.org/package/socks-0.5.5 (VincentHanquez)
22:34:20 <jle`> EvanR: most domains that Arrows were proposed to help for have now been supplanted by Applicative interfaces
22:34:28 <jle`> um, that was grammar'd weird
22:34:50 <cocreature> hackagebot: I don’t think you can write a comonad instance for free.
22:35:10 <hackrilege> why?
22:35:20 <jle`> but yeah, for the most part, Applicative-based interfaces have supplanted Arrow-based interfaces for most applications
22:35:26 <hackrilege> i just map return
22:35:32 <jle`> they were a promising start from before Applicative was invented
22:35:47 <hackrilege> just on the outer layer which is a Comonad
22:35:59 <EvanR> really? arrow is a huge surface
22:36:17 <hackrilege> (after duplicate is applied)
22:36:29 <jle`> it's sometimes crazy to think about how new Applicative is
22:36:42 <jle`> and at the same time, how natural
22:36:44 <hackrilege> i dont like Applicative at all
22:36:49 <kadoban> Is it that new? I never looked at the date on the paper for it or anything
22:37:02 <hackrilege> i never instantiate <*> as for my datastructures it is unnatural
22:37:26 <jle`> Applicative is from around 2008ish and cemented into common idioms around 2010 i think?
22:37:34 <hackrilege> yet they are often monads
22:37:35 <jle`> hackrilege: <*> isn't necessarily natural, but Applicative-based interfaces are pretty natural
22:37:37 <kadoban> Ah, hmm. Yeah that is pretty new.
22:37:51 <EvanR> i prefer applicative to monads if possible
22:38:03 <jle`> yeah, i have a lot of Applicatives that i regularly use that aren't monads
22:38:28 <jle`> Applicative interfaces are pretty smooth to use, especially with the new ApplicativeDo coming out
22:39:09 <jle`> and their monoid-ness fits pretty well in the theory of optics
22:39:13 <kadoban> I'm not sure ApplicativeDo will affect me much, pretty much all of the times I use Applicative it's also a Monad. But it's still neat.
22:39:56 <hackrilege> at the outermost nesting, after the constructor is removed, Comonad s => (Free s) can have duplicate applied, i can then apply the Free Constructors to the result to rebuild my output for dulpicate over Free s
22:40:02 <hackrilege> i really cant see why i fail
22:40:09 <hackrilege> http://lpaste.net/162448
22:40:25 <jle`> hackrilege: the types might work, but `fmap return` is almost always not a lawful implementation of duplicate
22:41:23 <hackrilege> it works well for Zippers
22:41:32 <hackrilege> to do iterate left
22:42:04 <hackrilege> Free Zippers use the fmap return over these duplicated Zippers, i dont get the type error.. i cant get it to go away
22:45:13 <hackrilege> i dont mind giving this a name other than duplicate if its unlawful but i want to get the types to work out...
22:45:47 <hackrilege> but Free s (Free s a) keeps contracting to (Free s a)
22:49:04 <cocreature> hackrilege: if you just want the types to work out "fmap Basecase $ Recurse $ fmap Recurse x" whether that does what you want is a whole different story :)
22:49:22 <hackrilege> YEES!!!
22:49:24 <hackrilege> thanks
22:49:26 <hackrilege> ill check
22:49:31 <hackrilege> its been driving me mad
22:49:33 <cocreature> "fmap Basecase $ Recurse $ a" also typechecks
22:49:46 <hackrilege> cheers
22:51:18 <hackrilege> you mean (duplicate a)?
22:52:27 <hackrilege> ok nvm
22:52:34 <cocreature> to typecheck you don’t need duplicate a
22:54:44 <hackrilege> true, but the top one uses the same approach and works ok!
22:55:18 <hackrilege> i dont have a test suite so ill just go ahead and try it with the zippers and see if it goes badly wrong...
22:55:23 <hackrilege> thanks
22:55:51 <hackrilege> i think i would have seen it if i hadnt confused myself about Free...
22:56:00 <hackrilege> thats kind of why i was asking
22:56:56 <cocreature> I like using typed holes to help you when writing such instances
22:57:37 <hackrilege> just putting a polymorphic type and seeing how it complains?
22:58:16 <cocreature> no I use holes and than gradually try to make them smaller until I finally have all holes filled in
22:58:46 <hackrilege> reference?
22:59:00 <cocreature> https://wiki.haskell.org/GHC/Typed_holes
22:59:03 <hackrilege> thanks
22:59:07 <cocreature> or https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/typed-holes.html
22:59:40 <hackrilege> ohhhh i never knew that thats cool
22:59:52 <hackrilege> looks super helpful
23:00:01 <kadoban> It really is
23:00:54 <cocreature> it’s probably my favorite feature since 7.8 or whatever the release that first added this was called
23:00:56 <hackrilege> this is one of those, hw did i not know that omg my life expectancy would be better if id known about that in the past moments
23:01:13 <chattered> I've come to rely on typed holes so much that I really struggle in Scala, now.
23:01:36 <chattered> I wonder if they've made my brain really lazy when it comes to figuring out types.
23:02:14 <hackrilege> people have been saying things about go being better than haskell which make me sad and i dont know any other languages so i dont knw what im missing or how to defend haskell by comparison
23:02:43 <hackrilege> i feel scared about how hard it is for me to do this thing whit zippers, and so is my prof!
23:02:51 <hackrilege> i guess i could have used Map....
23:03:25 <hackrilege> my argument is based on performance so i sure hope it works out being better...
23:04:32 <hackrilege> basically if every element will be changed depending on local traversals starting from those elements, you should map over the duplicated zipper, which is a zipper of the zipper in each of its configurations
23:04:37 <hackrilege> sorry zipper...
23:07:20 <hackrilege> also i want to ask about my observation that all Stacks have zippers. i dont need duplicate or join from Monad and Comonad, or <*> and cobind from applicative and CoApplicative, is there a class containing just return and extract?
23:08:22 <hackrilege> anyway, thats all you need for a zipper, so then you have a natural duplicate
23:08:48 <zipper> Hello hackrilege :)
23:09:16 <zipper> Is @ndmitchell from github ever in this channel?
23:09:23 <cocreature> zipper: I don’t think so
23:09:25 <zipper> or anyone involved in ghcid ?
23:09:37 <zipper> cocreature: Hello
23:10:46 <zipper> Trying to make something based on ghcid but I don't know how to pass ghci the function name and module without going through the .ghci file.
23:14:33 <hackrilege> sorry, you dont just need return and extend for a zipper, you also need <|> and something that is the opposite (dual) of (\ a b -> (return a) <|> b)
23:15:06 <hackrilege> the deconstructor...
23:15:46 <hackrilege> can be defined by pattern matching on the constructor
23:18:03 <hackrilege> i dont know how Applicative can be used in application of functions to a Graph. if the Graph of functions has different shape (connectivity) to the Graph of values, how should this be handled?
23:18:34 <EvanR> you could do a cross product maybe
23:18:52 <EvanR> and get a much more complex result
23:19:05 <EvanR> or say its invalid unless the graphs have the same structure, and make it a zip 
23:19:26 <cocreature> if you want to be fancy you can probably enforce that at the typelevel
23:19:30 <hackrilege> so the graph of functions applied to every value of a graph
23:19:32 <cocreature> I think I did that once for rosetrees
23:20:40 <hackrilege> hmm the zip way sounds good, i can construct the Graph functions by mapping over the Graph of values to get a Graph of the correct connectivity
23:22:22 <hackrilege> i think my datatype is BranchedList a = BranchedList [Either a (BranchedList a)]
23:22:58 <hackrilege> has this got a more common name or implementation?
23:24:29 <hackrilege> has anyone considered it or seen it before?
23:25:09 <Axman6> well, it's a slightly weird form of rose tree
23:26:18 <hackrilege> isnt everything!?
23:26:30 <hackrilege> i guess it is though yes
23:27:37 <hackrilege> its less branchy and more listy though
23:29:03 * hackagebot mandrill 0.5.2.1 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.5.2.1 (AlfredoDiNapoli)
23:29:28 <hackrilege> many branches at a node requiring nesting, one or zero branches being simple, anyway i guess ill play around with it
23:29:46 <hackrilege> for sparse graphs...
23:31:49 <hackrilege> do these various equivalent representations have different speeds for access etc? i feel like they should all be the same...
23:34:13 <hackrilege> perhaps by storing a commonly used path to commonly accessed data like im doing with zippers at type level makes lazy evaluation fast?
23:35:21 <linman32> hi, is there a way to hide prelude? trying out BasicPrelude
23:35:37 <hackrilege> i fear that if i try to discover via benchmarking, i will always perform poorly because of not consideration boxed values or whatever it is that makes haskell fast and that i wont really be able to make comparisons
23:36:06 <Axman6> linman32: NoImplicitPrelude
23:36:14 <cocreature> or "import Prelude ()"
23:36:50 <Axman6> it's probably worth reading the docs for NoImplicitPrelude to find out what implications those two options have
23:38:12 <linman32> thanks
23:38:28 <linman32> trying to use CorePrelude and show, but   show is not a (visible) method of class Show
23:38:54 <Axman6> yeah show isn't actually defined in the Show class
23:39:00 <Axman6> @src Show
23:39:00 <lambdabot> class Show a where
23:39:00 <lambdabot>     showsPrec :: Int -> a -> ShowS
23:39:00 <lambdabot>     show      :: a -> String
23:39:00 <lambdabot>     showList  :: [a] -> ShowS
23:39:08 <Axman6> hmm, perhaps I'm wrong!
23:39:16 <Axman6> maybe I was thinking of read
23:39:35 <linman32> showsPrec | show
23:39:41 <linman32> that is min compelte definiton
23:39:48 <linman32> does that mean either or both?
23:42:08 <hackrilege> either,
23:42:22 <hackrilege> they are given defaults defined it terms of each other
23:42:36 <Lokathor> so
23:42:43 <Lokathor> should IORef be a Functor?
23:43:52 <shachaf> No.
23:44:01 <pavonia> Lokathor: Updating the ref would involve IO, no?
23:44:20 <EvanR> Lokathor: however a Future...
23:44:29 <Lokathor> well.... maybe it would?
23:44:57 <Lokathor> i guess fmap would need to generate new IORef values, so yes
23:45:00 <EvanR> a Future is a Functor
23:45:10 <EvanR> and is kind of like IORef
23:45:13 <EvanR> and updating is ok
23:45:18 <hackrilege> you cannot guarantee that fmap g . fmap f = fmap (g . f)  as interations could change the value between the applications of fmap in the former. is that correct?
23:45:33 <shachaf> If you want to make it into a Functor you can use something like Coyoneda -- (exists x. (IORef x, x -> a))
23:46:14 <Lokathor> what i've really been wanting to write for the past few minutes
23:46:16 <Lokathor> runStateWithIORef :: (MonadState s m, MonadIO io) => m a -> IORef s -> io a
23:46:22 <Lokathor> is something like that, i think
23:46:48 <Lokathor> basically, kinda like stToIO, but for MonadState
23:47:11 <Lokathor> and maybe you'd have to restrict it to StateT instead?
23:47:49 <Cale> Lokathor: Well, that's certainly not possible, but State s a -> IORef s -> IO a, for sure
23:48:01 <Cale> Consider StateT s [] a
23:48:11 <Cale> What would it mean to apply such a thing to an IORef?
23:49:06 <Lokathor> well the idea would be something like, instead of (runState foo initialState) it'd be (runStateWithIORef foo ref)
23:49:13 <Lokathor> and reads and writes to the state would become reads and writes to the IORef
23:50:52 <linman32> does anyone know how to resolve the ol' show/Show class error? http://lpaste.net/162453
23:51:19 <Cale> Lokathor: Of course, forall s. (forall m. MonadState s m => m a) -> IORef s -> IO a is doable
23:52:02 <Lokathor> that rank2 type there makes me think that it's beyond my current skills to write >_<
23:52:44 <Cale> It's pretty easy: your implementation gets to pick the monad, so just pick State s for m
23:54:16 <Cale> Lokathor: Oh, here's something to consider
23:54:53 <Cale> Lokathor: Suppose we have a data type  data StateOps s m = SO { get :: m s; put :: s -> m () }
23:55:19 <Cale> Then we can write polymorphic functions whose types look like  (Monad m) => StateOps s m -> ... -> m a
23:56:08 <Cale> and then we could supply a StateOps record whose get and put fields are the get and put of some State monad, or StateT
23:56:20 <Lokathor> yeah that's also part of what i was thinking. MonadState really only cares about get and put being available, so it should be possible to run it using other kinds of "place" to get and put from
23:56:21 <Cale> Or we could fill them with readIORef and writeIORef
23:56:29 <Cale> for some particular IORef s
23:56:34 <Lokathor> IORef, TVar, and such
23:58:22 <Cale> So, the next thing you can do is to formalise that pattern of working with functions of a record of operations, abstracted over an arbitrary choice of monad
23:58:22 <Lokathor> and then MonadRandom is essentially MonadState, but with extra funcitonality since the state is limited to always being RandomGen
23:58:59 <Cale> newtype FreeVL ops a = FreeVL { runFreeVL :: forall m. Monad m => ops m -> m a }
23:59:12 <Lokathor> FreeVL?
23:59:22 <Lokathor> i'm not too familiar with the free/freeer stuff
