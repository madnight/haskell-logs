00:03:08 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
00:03:08 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
00:10:15 <jle`> type Proxy = Const ()
00:15:07 <EvanR> i mean the f in the type of Lens
00:18:44 <jle`> i think there aren't any instances of both Contravariant and Functor besides Const b
00:18:54 <jle`> for some b
00:22:53 <EvanR> heh
00:23:27 <EvanR> Identity ?
00:25:18 <EvanR> phantom :: (Functor f, Contravariant f) => f a -> f b
00:25:19 <EvanR> heh
00:25:23 <EvanR> guess not
00:50:13 <cocreature> identity is not contravariant
00:53:19 <ocramz> morning all
01:04:33 <Mutter> Hi....
01:04:48 <aeryndunham> Hi
01:18:36 <ken> hi all
01:19:04 <Guest33987> I post Haskell question 
01:19:06 <Guest33987> http://stackoverflow.com/questions/37293422/a-true-frp-principle-and-reactivebanana-code
01:19:15 <Guest33987> Can anyone answer for me
01:21:36 <gabbiel> (a, b) is in normal form only if  a and b are in normal form?
01:22:01 <athan> gabbiel: yes
01:22:02 <Mutter> Hi...
01:22:21 <athan> gabbiel: Have you seen the deepseq library?
01:22:21 <Mutter> Hi gabbiel 
01:22:28 <EvanR> Guest33987: from the looks of things, you are right
01:22:29 <gabbiel> no
01:22:32 <Mutter> For 
01:22:32 <athan> Hi Mutter
01:22:38 <gabbiel> hi Mutter
01:22:47 <Mutter> Hi athan... 
01:22:50 <EvanR> Guest33987: also i think you mean pure function, not referentially transparent function
01:22:59 <Mutter> Add me...
01:23:17 <athan> :T
01:23:33 <gabbiel> (a,b) `seq` something will evaluate (a,b) to head normal form, but (a,b) will be normal form only if a and b are too?
01:23:51 <Guest33987> EvanR: so the presented code is nothing to do with the so-called "true FRP principle" as he claims, you agree?
01:23:52 <EvanR> > (undefined, undefined) `seq` 3
01:23:53 <lambdabot>  3
01:24:11 <EvanR> > force (undefined, undefined) `seq` 3
01:24:13 <lambdabot>  Not in scope: ‘force’
01:24:17 <EvanR> :t force
01:24:18 <lambdabot> Not in scope: ‘force’
01:24:21 <EvanR> :(
01:24:22 <Mutter> Hi...
01:24:23 <athan> :v
01:24:31 <gabbiel> so, in this code, strict fold does nothing?
01:24:34 <oherrala> can you use BangPatterns to make (a,b) strickter, by !(a,b) or (!a,!b)?
01:24:35 <gabbiel> give me a sec
01:25:10 <gabbiel> here, https://0x0.st/qjR.png
01:25:11 <EvanR> Guest33987: yes, and i also dont necessarily agree that that is even the true frp principle
01:25:58 <athan> oherrala: !(a,b) is already evaluated :)
01:26:02 <Guest33987> EvanR: right I do agree with you in that sense, too; thanks a lot!!
01:26:08 <athan> so the bang has no use
01:26:20 <EvanR> gabbiel: yeah where f (!s, !l) x would probably help
01:26:29 <gabbiel> also, with BangPatterns, can I do, "where f (s, l) = (!s + x, !l + 1)
01:26:35 <EvanR> no
01:26:45 <EvanR> s + x isnt a pattern
01:27:02 <gabbiel> yeah, the pattern in BangPatterns make sense now, thanks
01:27:16 <Guest33987> EvanR: if you have stackoverflow account, can you post the answer? copy-paste your post here is enough. I will check the accepted answer, so
01:27:21 <EvanR> i do not
01:27:35 <Guest33987> oh sorry
01:27:37 <Mutter> Hi.....
01:27:39 <EvanR> in any case id like to see what people say if anything
01:28:21 <gabbiel> evan, post ur github
01:28:42 <EvanR> wut
01:28:49 <athan> we want you evan
01:29:00 <athan> sorry going back to my cage
01:30:46 <Mutter> Hi...
01:30:55 <Mutter> How's life doin
01:30:55 <gabbiel> Mutter, you a bot?
01:31:07 <Mutter> Hi gabbiel 
01:31:09 <athan> Mutter:  This time it's does
01:31:20 <Mutter> U sound nice
01:31:22 <gabbiel> yup, Mutter's a bot trying to scam
01:31:35 <Mutter> gabbiel: hi...
01:32:09 * athan still somehow psychologically traumatizes it
01:32:37 <moltalk101> Who is @Mutter?
01:32:45 <gabbiel> a bot
01:32:47 <gabbiel> probably
01:33:04 <gabbiel> @src length
01:33:04 <lambdabot> Source not found. Where did you learn to type?
01:33:08 <moltalk101> can it write code 200 lines a minute?
01:33:22 <gabbiel> it's probably get b&
01:33:55 <Mutter> Hi Mutter 
01:34:13 <gabbiel> hi yourself
01:34:13 <Mutter> Hi moltalk101 
01:34:34 <Mutter> Rude
01:34:44 <Mutter> Just wanna greet
01:34:48 <athan> > getSum $ foldMap (const $ Sum 1) ["ayy", "sup", "lawl"]
01:34:50 <lambdabot>  3
01:35:30 <gabbiel> > 9
01:35:32 <lambdabot>  9
01:36:17 <Mutter> Hi...
01:36:31 <gabbiel> >hi
01:36:32 <Mutter> Hello
01:37:27 * ski idly wonders whether Mutter has any Haskell-related questions/comments
01:37:55 <gabbiel> >:show modules
01:39:35 <jophish> Is anyone here familiar with spj's paper on inference for higher rank types? http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/putting.pdf
01:40:04 <athan> not yet >:D
01:40:31 <jophish> I'm wondering why 'skolemise' isn't called on 'arg_ty' in the equation for Rule PRFUN at the beginning of page 55
01:40:33 <EvanR> can Bifunctor be derived
01:41:12 <jophish> EvanR: the genifunctors package can do it with template haskell
01:41:21 <EvanR> nice
01:41:28 <Mutter> Hi....
01:41:46 <Mutter> Hi....
01:42:16 <gabbiel> let kick "Mutter" = True
01:43:18 <athan> jophish: It looks like they're just redefining it
01:43:25 <athan> for deep skolemization, right?
01:43:47 <athan> sorry, I just skiped ahead so that might be absurdly obvious
01:44:01 <jophish> athan: yes, but as far as I can tell it'll only skolemises the rightmost result type
01:44:17 <athan> oh wait derp one sec I misread your question
01:44:50 <jophish> for example given the type: (forall a. a -> a) -> (forall b. b -> b). it'll return (forall a. a -> a) -> (b' -> b')
01:45:08 <jophish> with skolem type mappings b:b'
01:45:47 <Mutter> Hi athan 
01:45:58 <jophish> athan: it is actually doing the same thing as the PRFUN rule on page 23
01:46:29 <jophish> so I'm pretty sure I'm just misunderstanding slightly what it's supposed to be doing
01:49:26 <fred-fri> is the use of pragmas a non issue or something that people have opinions on?
01:51:46 <athan> jophish: I /think/ it's following the nature of prenex polymorphism
01:52:12 <athan> just like how `forall a b. a -> (b -> c)` ~ `forall a. a -> (forall b. b -> c)`
01:52:36 <merijn> Are those equal?
01:52:42 <merijn> I'm not 100% sure?
01:53:24 <athan> same :s
01:53:34 <athan> on page 23 it's a dream haha
01:55:01 <merijn> I think they are equally expressive, but not sure if they're the same
01:55:53 <jophish> athan: ah, I understand now, time to give section 4 another read
01:56:02 <Xnuk> Does the library exist which parses both JSON and JS object literal and is good to use with Aeson?
01:56:18 <athan> I wish I was cool enough to space math ._.
01:57:20 <athan> Xnuk: JS object literals are poo
01:57:24 <merijn> athan: Step 1) Buy TaPL, Step 2) read TaPL, Step 3) read papers until you get stuck, Step 4) go to step 2 :p
01:58:18 <Xnuk> I know ._.
01:58:33 <athan> merijn: I really need to get into barendregt... and this... and friggin... prove the universe as an unsound logic or something
01:58:52 <athan> Xnuk: aeson can parse json though haha
01:58:53 <EvanR> https://hackage.haskell.org/package/js-good-parts-0.0.7/docs/Language-JavaScript-AST.html ?
01:59:17 <EvanR> https://hackage.haskell.org/package/WebBits-2.2/docs/BrownPLT-JavaScript-Parser.html
01:59:20 <EvanR> ?
01:59:21 <athan> > EvanR `hyperexponential` 12
01:59:23 <lambdabot>  Not in scope: data constructor ‘EvanR’Not in scope: ‘hyperexponential’
01:59:28 <EvanR> zzz
01:59:28 <athan> for karma I mean
01:59:49 <merijn> athan: Barendregt's lambdacube paper is actually fairly simple
02:02:35 <Mutter> Hi....
02:02:46 <Mutter> Wanna try
02:02:59 <athan> ._.
02:03:12 <athan> Mutter: That's what javascript said! ayooo
02:03:19 <Mutter> Ay oo
02:03:44 <tzaeru> i
02:03:47 <tzaeru> oops
02:04:45 <Xnuk> um should I play with JavaScript AST?
02:05:26 <Rembane> Xnuk: YES!
02:05:55 <Mutter> Hi...
02:06:16 * ski looks at Mutter
02:06:22 <Xnuk> Rembane: Oh..
02:07:18 <Mutter> Hi ski 
02:07:32 <Mutter> Anyone care to help me....
02:07:40 <athan> choo need Mutter?
02:07:42 <Mutter> I'm looking for a fren
02:07:55 <Mutter> Athan yes
02:07:55 <ski> Mutter : help you with a Haskell-related problem ?
02:07:57 <Mutter> Hin
02:08:16 <Mutter> How can I change my name
02:08:28 <ski> /nick NewName
02:15:08 <Mutter> Hi....
02:15:51 * ski idly wonders whether Mutter figures out the name-changing
02:18:27 * hackagebot sscript 0.1.0.0 - Formats Strings with subscript or superscript characters  https://hackage.haskell.org/package/sscript-0.1.0.0 (capncanuck)
02:18:29 * hackagebot gi-atk 0.2.18.15 - Atk bindings  https://hackage.haskell.org/package/gi-atk-0.2.18.15 (inaki)
02:18:31 * hackagebot gi-cairo 0.1.14.15 - cairo bindings  https://hackage.haskell.org/package/gi-cairo-0.1.14.15 (inaki)
02:18:33 * hackagebot gi-gdk 0.3.18.15 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-0.3.18.15 (inaki)
02:18:35 * hackagebot gi-gdkpixbuf 0.2.32.15 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-0.2.32.15 (inaki)
02:23:37 <Mutter> Hi....
02:23:37 * hackagebot gi-gio 0.2.46.15 - Gio bindings  https://hackage.haskell.org/package/gi-gio-0.2.46.15 (inaki)
02:23:39 * hackagebot gi-girepository 0.1.46.15 - GIRepository bindings  https://hackage.haskell.org/package/gi-girepository-0.1.46.15 (inaki)
02:23:41 * hackagebot gi-glib 0.2.46.15 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.2.46.15 (inaki)
02:23:43 * hackagebot gi-gobject 0.2.46.15 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-0.2.46.15 (inaki)
02:23:45 * hackagebot gi-gtk 0.3.18.15 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-0.3.18.15 (inaki)
02:28:47 * hackagebot gi-gtksource 0.3.18.15 - GtkSource bindings  https://hackage.haskell.org/package/gi-gtksource-0.3.18.15 (inaki)
02:28:49 * hackagebot gi-javascriptcore 0.2.4.15 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.4.15 (inaki)
02:28:51 * hackagebot gi-javascriptcore 0.2.12.15 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.12.15 (inaki)
02:28:53 * hackagebot gi-notify 0.2.32.15 - Notify bindings  https://hackage.haskell.org/package/gi-notify-0.2.32.15 (inaki)
02:28:55 * hackagebot gi-pango 0.1.38.15 - Pango bindings  https://hackage.haskell.org/package/gi-pango-0.1.38.15 (inaki)
02:29:57 <Nnotm> what is up with hackagebot
02:30:20 <ski> someone's uploading packages
02:30:25 <Nnotm> I seee
02:30:29 <Nnotm> see*
02:33:57 * hackagebot gi-pangocairo 0.1.38.15 - PangoCairo bindings  https://hackage.haskell.org/package/gi-pangocairo-0.1.38.15 (inaki)
02:33:59 * hackagebot gi-poppler 0.0.34.15 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.0.34.15 (inaki)
02:34:01 * hackagebot gi-soup 0.2.52.15 - Soup bindings  https://hackage.haskell.org/package/gi-soup-0.2.52.15 (inaki)
02:34:03 * hackagebot gi-vte 0.0.42.15 - Vte bindings  https://hackage.haskell.org/package/gi-vte-0.0.42.15 (inaki)
02:34:05 * hackagebot gi-webkit2 0.2.12.15 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-0.2.12.15 (inaki)
02:34:16 <ski> la la la
02:36:51 <idev> (_, _, a) -> a
02:36:54 <idev> is there a builtin for this function?
02:38:30 <liste> idev: depends on what "builtin" is
02:38:57 <liste> > (1,2,3) ^. _3
02:39:02 <lambdabot>  3
02:39:07 * hackagebot gi-webkit2webextension 0.2.12.15 - WebKit2WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-0.2.12.15 (inaki)
02:39:09 * hackagebot gi-webkit 0.2.4.15 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-0.2.4.15 (inaki)
02:39:11 * hackagebot sscript 0.1.0.1 - Formats Strings with subscript or superscript characters  https://hackage.haskell.org/package/sscript-0.1.0.1 (capncanuck)
02:39:13 * hackagebot automotive-cse 0.1.7.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.7.0 (KeiHibino)
02:39:35 <opqdonut> there's also:
02:39:43 <opqdonut> :t thd3
02:39:44 <lambdabot> Not in scope: ‘thd3’
02:39:47 <opqdonut> oh well
02:39:51 <opqdonut> https://hackage.haskell.org/package/MissingH-1.3.0.2/docs/Data-Tuple-Utils.html
02:39:54 <opqdonut> from MissingH
02:40:15 <opqdonut> or from extra:
02:40:16 <opqdonut> https://hackage.haskell.org/package/extra-1.4.6/docs/Data-Tuple-Extra.html
03:16:09 <DriveByShitpost> LOL U MAD? XD
03:45:28 <koz_> Could someone give me a clue as to wtf I'm missing here? http://lpaste.net/163769
03:46:16 <koz_> My goal is 'first, compare by length, then as normal for Sets'.
03:49:08 <puregreen> koz_: `on` has lower precedence than <>
03:49:09 <ski> @type \a b -> compare `on` a <> compare `on` b
03:49:10 <ski> @type \a b -> comparing a <> comparing b
03:49:11 <lambdabot> (Ord b, Ord (b -> Ordering)) => (b -> b -> Ordering) -> (a -> b) -> a -> a -> Ordering
03:49:12 <lambdabot> (Ord a, Ord a1) => (b -> a) -> (b -> a1) -> b -> b -> Ordering
03:49:31 <koz_> puregreen: Argh.
03:49:35 <puregreen> so either use brackets or use comparing, yeah
03:49:40 <koz_> I keep having the precedence checker step on me.
03:49:47 <koz_> :t comparing
03:49:49 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
03:50:00 <ski> @src comparing
03:50:00 <lambdabot> comparing p x y = compare (p x) (p y)
03:50:09 <ski>   comparing p = compare `on` p
03:50:23 <koz_> Thanks ski and puregreen, I'll give it a shot.
03:51:26 <koz_> OK, comparing makes it look better..
03:52:27 <zoran119> if i have a list of Maybe a, how can i filter this list for Just a (remove all Nothings from it)?
03:52:52 <lyxia> filter isJust
03:53:11 <puregreen> or catMaybes if you want [a] instead of [Maybe a]
03:53:12 <byorgey> zoran119: catMaybes
03:53:28 <ski> @src catMaybes
03:53:29 <lambdabot> catMaybes ls = [x | Just x <- ls]
03:53:50 <zoran119> any way of doing it using stuff from prelude?
03:54:26 <Akii> :t catMaybes
03:54:27 <lambdabot> [Maybe a] -> [a]
03:54:30 <Akii> ah cool
03:55:03 <lyxia> inline the definition of catmaybe
03:56:41 <ski> @type foldr (maybe id (:)) []   :: [Maybe a] -> [a]
03:56:43 <lambdabot> [Maybe a] -> [a]
03:57:17 <zoran119> definition of catMaybes should work, thanks
03:58:32 <ski> @check \mas -> foldr (maybe id (:)) [] mas == catMaybes mas
03:58:35 <lambdabot>  +++ OK, passed 100 tests.
04:07:44 <koz_> Does lambdabot have QuickCheck built in?
04:12:32 <liste> koz_: yes, you just witnessed it
04:12:44 <koz_> liste: Cool!
04:13:17 <liste> it has a lot of things, try /q lambdabot @listmodules
04:13:25 <koz_> Also, I'm having a bit of difficulty understanding the proper use of Traversables.
04:15:30 <merijn> koz_: What's the problem?
04:16:11 <koz_> merijn: Basically, I'm having trouble grasping the intuition behind Traversable. Like, I basically don't really get what the traverse function *does*.
04:16:34 <merijn> koz_: You you understand sequence?
04:16:56 <merijn> :t sequence `asAppliedTo` ([] :: [m a])
04:16:58 <lambdabot> Monad m => [m a] -> m [a]
04:17:33 <koz_> OK, that part I get - it's basically how we combine IO actions into one big IO action.
04:17:44 <koz_> (at least that's how I've seen it and used it myself)
04:17:53 <merijn> koz_: Sure, but not just IO
04:17:58 <merijn> :t sequence `asAppliedTo` ([] :: [Maybe a])
04:18:00 <lambdabot> [Maybe a] -> Maybe [a]
04:18:04 <koz_> So wait a sec.
04:18:07 <merijn> :t sequence `asAppliedTo` ([] :: [Either Bool a])
04:18:08 <lambdabot> [Either Bool a] -> Either Bool [a]
04:18:25 <koz_> Using sequence with Maybe means that we'd get Just a list if they're all Justs, and Nothing otherwise?
04:18:32 <merijn> koz_: Correct
04:19:17 <koz_> And with Either, we'd get Right of the list if they're all Rights, but what of if we have a Left in there?
04:19:27 <koz_> Would it just give us the first Left it finds?
04:19:29 <merijn> koz_: You get the first Left
04:19:52 <koz_> It looks oddly like a fold.
04:20:17 <merijn> koz_: A fold that rebuilds the exact same list after getting the results from each action, yes
04:20:33 <koz_> OK...
04:20:54 <merijn> :t foldr (liftA2 (:)) (return []) -- lemme see if I got this right
04:20:56 <lambdabot> (Monad f, Foldable t) => t (f a) -> f [a]
04:21:22 <merijn> :t foldr (liftA2 (:)) (return []) `asAppliedTo` [] -- let's specialise to lists
04:21:24 <lambdabot> Monad f => [f a] -> f [a]
04:21:40 <merijn> As you can see, sequence is, in fact, a fold with "liftA2 (:)"
04:21:45 <merijn> :t liftA2 (:)
04:21:46 <lambdabot> Applicative f => f a -> f [a] -> f [a]
04:22:04 <merijn> koz_: Anyway, once we "get" sequence we can have a look at
04:22:13 <merijn> :t \f -> sequence . map f
04:22:14 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
04:22:50 <merijn> So we map "a -> m b" over a list to get "[m b]" and then use sequence to turn it into "m [b]"
04:23:01 <koz_> And *that* is traverse?
04:23:25 <merijn> But what if we wanted to generalise from lists? All we need to be able to do to sequence is "rebuild" a data structure with the Monad lifted out
04:23:32 * hackagebot automotive-cse 0.1.8.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.8.0 (KeiHibino)
04:23:37 <merijn> koz_: Compare the last type with:
04:23:39 <merijn> :t traverse
04:23:40 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
04:24:02 <merijn> koz_: It's slightly generalised, since sequence really only needs Applicative instead of Monad
04:24:09 <koz_> Yeah, was about to say.
04:24:36 <merijn> koz_: So we have some traversable thing 't' which is a "rebuildable" data structure en lift out all the Applicative effects to outside the structure, rebuilding it
04:24:40 <merijn> :t sequence
04:24:41 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
04:24:49 <merijn> :t sequenceA
04:24:51 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
04:25:03 <merijn> sequence vs sequenceA is a bit of a historical accident
04:25:10 <koz_> In what sense?
04:26:05 <merijn> koz_: Applicative was not a superclass of Monad in the past so it wouldn't always accept what you wanted, despite being logically the same
04:26:13 <koz_> Ah, OK. That makes sense.
04:26:42 <koz_> Alrighty, I think I'll practice using Traversables by defining stuff with [], and seeing if I can generalize it.
04:26:56 <merijn> koz_: So traversable boils down to "data structures that can be traversed (in some unspecified order) and have their contents rebuild with the same outer structure and the effects lifted out"
04:27:32 <merijn> koz_: Pay attention to the laws in the docs to understand why it must be possible to rebuild
04:27:42 <rhehta> Guys how do you do code
04:27:50 <merijn> koz_: For example, it clearly makes sense to have
04:28:00 <koz_> rhehta: In what sense?
04:28:06 <merijn> :t sequence `asAppliedTo` (undefined :: Map k (m v))
04:28:07 <lambdabot>     Not in scope: type constructor or class ‘Map’
04:28:08 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
04:28:09 <Blote> hoi
04:28:10 <Blote> hoi
04:28:10 <Blote> hoi
04:28:11 <merijn> eh, whoops
04:28:13 <Blote> hoi
04:28:14 <Blote> hoi
04:28:15 <Blote> hoi
04:28:18 <merijn> :t sequence `asAppliedTo` (undefined :: M.Map k (m v))
04:28:23 <lambdabot> Monad m => M.Map k (m a) -> m (M.Map k a)
04:28:45 <merijn> koz_: You simply traverse all the values in the map and lift out the effects :)
04:29:21 <koz_> merijn: Yeah, I think it's starting to form in my head.
04:29:33 <koz_> I just need to practice the use of Traversables a bit and I think I'll get it.
04:29:49 <koz_> But thanks for that explanation - it actually helped a lot.
04:30:10 <merijn> koz_: Also compare Traversable with Foldable
04:30:21 <merijn> Foldable being "Traversable for things that can't be rebuilt"
04:30:24 <merijn> :t sequence_
04:30:27 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
04:30:28 <merijn> :t sequence
04:30:31 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
04:41:04 <koz_> Are zip and friends *only* defined for lists?
04:42:19 <Taneb> koz_, they can (sort of) be defined for any Applicative
04:42:27 <Taneb> Only the one you get for lists isn't what you expect
04:42:34 <Taneb> There's also Control.Monad.Zip
04:42:46 <koz_> Taneb: What do you mean it's not what you expect for lists?
04:42:46 <merijn> Taneb: The one you get for lists could be what you expect
04:42:56 <merijn> koz_: There's two lawful Applicatives for list :)
04:42:56 <Taneb> merijn, not for a function called "zip"
04:43:04 <Taneb> :t ZipList
04:43:05 <lambdabot> [a] -> ZipList a
04:43:13 <koz_> merijn: Yeah, ZipList and [].
04:43:29 <koz_> One is for 'structural' lists and the other is for 'nondeterminism' lists, right?
04:43:30 <Taneb> > let zipA = liftA2 (,) in zipA "abc" [1,2,3]"
04:43:32 <lambdabot>  <hint>:1:45:
04:43:32 <lambdabot>      lexical error in string/character literal at end of input
04:43:34 <Taneb> > let zipA = liftA2 (,) in zipA "abc" [1,2,3]
04:43:36 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
04:43:42 <merijn> > (,) <$> ZipList [1..5] <*> ZipList [6..10] -- looks like zip to me :)
04:43:44 <lambdabot>  ZipList {getZipList = [(1,6),(2,7),(3,8),(4,9),(5,10)]}
04:43:50 <Taneb> > let zipA = liftA2 (,) in zipA (ZipList "abc") (ZipList [1,2,3])
04:43:52 <lambdabot>  ZipList {getZipList = [('a',1),('b',2),('c',3)]}
04:44:08 <Taneb> merijn, my point is, you have to use a newtype wrapper for lists
04:44:26 <merijn> That's only a detail of the CURRENT choice of applicative for lists
04:44:49 <Taneb> Which is unlikely to change, as it's the one that corresponds with the monad instane
04:44:51 <Taneb> instance
04:44:53 <koz_> Where can I find the Applicative-based definitions of zip and friends?
04:45:33 <Taneb> koz_, Control.Applictive.liftA2 ~ zipWith :)
04:45:52 <Taneb> liftA3 ~ zipWith3 etc
04:45:59 <koz_> Taneb: Wait, for realz?
04:46:05 <koz_> :t liftA2
04:46:11 <Taneb> koz_, yeah
04:46:22 <Taneb> > liftA2 (+) [1,2,3] [4,5,6]
04:46:28 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:46:28 <lambdabot>  [5,6,7,6,7,8,7,8,9]
04:46:41 <Taneb> > liftA2 (+) (ZipList [1,2,3]) (ZipList [4,5,6])
04:46:43 <lambdabot>  ZipList {getZipList = [5,7,9]}
04:46:56 <koz_> I just had a 'Woah' moment.
04:47:11 <Taneb> You've got to watch out for the two different Applicatives for [], though
04:47:11 <Taneb> Nice :D
04:47:29 <koz_> > (+) <$> [1, 2, 3] <*> [4, 5, 6]
04:47:31 <lambdabot>  [5,6,7,6,7,8,7,8,9]
04:47:42 <koz_> Goddamn my mind just got fucking *blown*.
04:47:58 <koz_> So wait, wait.
04:48:12 <koz_> > (,) <$> [1, 2, 3] <*> [4, 5, 6]
04:48:14 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
04:48:19 <koz_> Zomg wow.
04:48:33 <Boomerang> > (,) <$> Just 1 <*> Just 2
04:48:33 * hackagebot idris 0.11.2 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.11.2 (EdwinBrady)
04:48:34 <lambdabot>  Just (1,2)
04:48:35 <zomg> such amaze
04:48:42 <Boomerang> > (,) <$> Just 1 <*> Nothing
04:48:44 <lambdabot>  Nothing
04:48:46 <koz_> zomg: very mindblow
04:50:06 <koz_> *How* did I *not* see this before?
04:50:06 <Taneb> > LiftA2 (,) ("Hello,", 1) (" world!", True)
04:50:06 <lambdabot>      Not in scope: data constructor ‘LiftA2’
04:50:06 <lambdabot>      Perhaps you meant one of these:
04:50:06 <lambdabot>        variable ‘liftA2’ (imported from Control.Applicative),
04:50:06 <Taneb> > liftA2 (,) ("Hello,", 1) (" world!", True)
04:50:06 <lambdabot>  ("Hello, world!",(1,True))
04:50:06 <koz_> Isn't liftA stuff redundant if we have <$> and <*>
04:50:06 <koz_> ?
04:50:06 <merijn> koz_: Yes
04:50:20 <Taneb> koz_, sometimes it's more convenient
04:50:28 <koz_> OK, I now have an intuition for Applicatives like never before.
04:50:32 <merijn> koz_: Applicative/Monad have lots of redundant functions due to the historical Applicative/Monad split and just convenience
04:50:38 <merijn> koz_: Whoo! :)
04:51:13 <koz_> Now for a slightly weird thing - could we define zip for two Traversables?
04:51:40 <merijn> koz_: Not in general, because the laws for Traversable don't guarantee enough to do that
04:51:52 <koz_> merijn: What are we missing for this?
04:52:21 <merijn> koz_: Although, do note that there is "newtype Compose f g a = Compose { runCompose :: f (g a) }" and the composition of two Applicatives is also an Applicative
04:52:43 <koz_> Isn't Compose just ... well, function composition?
04:52:55 <merijn> So I suppose if you combine Compose + lifting of liftA2 and your Traversable is Applicative too you could approximate it
04:53:02 <merijn> koz_: At the type level
04:53:20 <koz_> Are there non-Applicative Traversables?
04:53:30 <merijn> koz_: I dunno of the top of my head :)
04:53:54 <Taneb> koz_, "(,) a" is Traversable but only Applicative when a is a Monoid
04:54:06 <Taneb> Ditto for "Const a"
04:54:14 <Boomerang> > (,) <$> ([1,2], [3,4]) <*> ([5,6],[7,8]) -- what is happening here? Why does it concat on fst?
04:54:16 <lambdabot>  ([1,2,5,6],([3,4],[7,8]))
04:54:45 <koz_> Taneb: *Just* spotted that one now.
04:54:47 <koz_> Thanks.
04:54:53 <merijn> Boomerang: Because "(,) a" is only a lawful Applicative if a is a Monoid
04:55:39 <koz_> merijn: In fact, that's the point that Taneb just raised.
04:55:41 <merijn> Boomerang: Have a look at the laws of Applicative and try to figure out what happens if it DIDN'T mappend
04:56:08 <Boomerang> Mmhm, I think I understand. It's similar to this then?
04:56:14 <Boomerang> > sequence (1, Just 2)
04:56:16 <lambdabot>  Just (1,2)
04:56:22 <Boomerang> > sequence (Just 1, Just 2)
04:56:24 <lambdabot>  Just (Just 1,2)
04:56:25 <merijn> Boomerang: For example, what would "pure :: a -> (e, a) do :)
04:57:01 <merijn> Boomerang: As an exercise write down the type of sequence and figure out what the type variables turn into in your example
04:57:04 <merijn> :t sequence
04:57:05 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
04:57:20 <merijn> Boomerang: i.e., what's the type 't' and 'm' in your example :)
04:57:50 <merijn> (Hint: It helps to write the tuple type in prefix notation, e.g. "(,) a b" instead of "(a,b)")
04:58:29 <Boomerang> Alright, thanks! Is that the case for bigger tuples? (,,) seems to fail sequence
04:58:44 <merijn> Boomerang: Currently bigger tuples don't have Traversable instances
04:58:57 <merijn> But there was a big argument on the libraries mailing list to add instances for bigger tuples too
04:59:24 <Boomerang> What is the argument against making it available in bigger tuples?
04:59:36 <merijn> Boomerang: "it's confusing that length returns 1!"
04:59:42 <merijn> > length (1,2)
04:59:44 <lambdabot>  1
04:59:52 <merijn> :t length
04:59:54 <lambdabot> Foldable t => t a -> Int
05:00:27 <koz_> I've been caught out by that merijn.
05:00:32 <Boomerang> That is confusing, but at the same time I'm not sure what I expected
05:00:34 <koz_> (to my *great* surprise)
05:01:00 <merijn> Boomerang: Well, it makes sense with 't = (,) Int' and 'a = Int' :)
05:01:17 <merijn> > toList (1,2)
05:01:19 <lambdabot>      Ambiguous occurrence ‘toList’
05:01:19 <lambdabot>      It could refer to either ‘Data.Foldable.toList’,
05:01:19 <lambdabot>                               imported from ‘Data.Foldable’ at /tmp/mueval995...
05:01:26 <merijn> > Data.Foldable.toList (1,2)
05:01:28 <lambdabot>  [2]
05:03:43 <koz_> Is there a less-wordy way to write that lambda in there? 'toAtoms xs = (\b i -> (if b then Confirmation else Negation) i) <$> xs <*> [1..]'
05:04:28 <koz_> (Confirmation and Negation are both constructors for the same type)
05:05:14 <chipf0rk> koz_: you can replace the whole lambda with (bool Confirmation Negation)
05:05:18 <chipf0rk> bool from Data.Bool
05:05:39 <koz_> chipf0rk: Wow, second mindblow in one night.
05:05:43 <koz_> :t bool
05:05:43 <Boomerang> bool Negation Confirmation
05:05:43 <chipf0rk> you can also kick out the lambda and replace it with just the inner if
05:05:45 <lambdabot> a -> a -> Bool -> a
05:05:55 <chipf0rk> whatever you deem more readable. i prefer ifs
05:06:06 <Boomerang> > bool 1 2 True
05:06:11 <koz_> I'd use Bool, but I didn't know you could use if that way.
05:06:11 <lambdabot>  2
05:06:13 <koz_> Thanks!
05:06:22 <chipf0rk> you're using `bool`, not `Bool`, careful :)
05:06:30 <chipf0rk> it's just a function from the Data.Bool module
05:07:06 <Boomerang> it's the same as either or maybe but for Bool instead of Either and Maybe
05:07:34 <koz_> chipf0rk: Derp, I meant 'bool'.
05:08:11 <koz_> chipf0rk: I think you've saved me a *lot* of future typing.
05:08:32 <chipf0rk> koz_: don't mind the latter comment, you actually can't throw out the lambda completely with just the if ;) just the i parameter and application with i
05:08:34 <chipf0rk> koz_: cool!
05:08:37 <merijn> eh
05:09:00 <merijn> koz_: Anyway, this sort of playing is the best way to learn :)
05:09:11 <koz_> merijn: That's why I'm doing it!
05:09:30 <koz_> Thanks to 'this sort of playing', as you call it, I have a *much* stronger intuition for Applicatives.
05:09:49 <merijn> koz_: Also a good exercise: Try implementing Functor/Applicative/Monad for "data Const k a = Const k" what can be implemented? What can't? Why not? (which laws does it break), do you need any class constraints to implement them?
05:10:41 <koz_> merijn: Hmmm. I might well give that a go actually - it seems interesting.
05:13:34 * hackagebot hpath 0.7.0 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.7.0 (maerwald)
05:13:36 * hackagebot fast-builder 0.0.0.5 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.0.0.5 (AkioTakano)
06:07:51 <maerwald> uh, does nixos automatically build all hackage?
06:08:30 <cocreature> maerwald: yep
06:08:48 <cocreature> but not all versions iirc
06:20:59 <HairyDude> Is there a standard function maxBy :: Ord b => (a -> b) -> a -> a -> a ?
06:21:35 <puregreen> :t \f -> max `on` f
06:21:36 <lambdabot> Ord c => (a -> c) -> a -> a -> c
06:21:49 <HairyDude> that returns whatever you projected from a, not a
06:21:50 <puregreen> hm, no
06:22:03 <HairyDude> that was my first instinct too :)
06:23:38 <merijn> :t \f -> snd $ max `on` (\x -> (x, f x))
06:23:40 <lambdabot>     Precedence parsing error
06:23:40 <lambdabot>         cannot mix ‘$’ [infixr 0] and ‘on’ [infixl 0] in the same infix expression
06:23:44 <merijn> eh
06:23:54 <merijn> :t \f y z -> snd $ max `on` (\x -> (x, f x)) y z
06:23:56 <lambdabot>     Precedence parsing error
06:23:57 <lambdabot>         cannot mix ‘$’ [infixr 0] and ‘on’ [infixl 0] in the same infix expression
06:24:17 <HairyDude> :t \f y z -> snd (max `on` (\x -> (x, f x)) y z
06:24:18 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
06:24:27 <HairyDude> :t \f y z -> snd (max `on` (\x -> (x, f x)) y z)
06:24:29 <lambdabot>     Couldn't match expected type ‘(a0, b)’
06:24:29 <lambdabot>                 with actual type ‘a1 -> a1 -> ()’
06:24:29 <lambdabot>     In the first argument of ‘snd’, namely
06:24:34 <merijn> :t \f y z -> snd ((max `on` (\x -> (x, f x)) y z)
06:24:35 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
06:24:41 <merijn> I fail at this, apparently
06:24:50 <merijn> :t \f y z -> snd ((max `on` (\x -> (x, f x))) y z)
06:24:52 <lambdabot> (Ord a, Ord b) => (a -> b) -> a -> a -> b
06:24:58 <merijn> eh
06:25:03 <merijn> :t \f y z -> fst ((max `on` (\x -> (x, f x))) y z)
06:25:04 <lambdabot> (Ord a, Ord b) => (a -> b) -> a -> a -> a
06:25:28 <HairyDude> @djinn Ord b => (a -> b) -> a -> a -> a
06:25:29 <lambdabot> Error: Class not found: Ord
06:25:38 <HairyDude> ah, djinn must be borked.
06:26:13 <puregreen> :t \f a b -> maximumBy (comparing f) [a, b]
06:26:15 <lambdabot> Ord a => (b -> a) -> b -> b -> b
06:26:25 <puregreen> cheating, yeah
06:26:40 <HairyDude> I would prefer maximumBy defined in terms of maxBy, not vice versa :)
06:26:55 <ClaudiusMaximus> merijn: more like  fst ((max `on` snd) `on` (\x -> (x, f x)))  to avoid comparing x directly
06:27:09 <ClaudiusMaximus> wait that won't work because on
06:27:13 * ClaudiusMaximus gives up
06:27:34 <HairyDude> you keep using that function, I do not think it does what you think it does
06:56:51 <pavonia> Is the solution to the puzzle at the bottom of http://www.vex.net/~trebla/haskell/module.xhtml "Everything the Prelude re-exports from Data.Maybe"?
07:02:42 <HairyDude> pavonia: that only answers the what, not the why ;)
07:03:13 <pavonia> Yes, that's the part I'm interested in
07:04:06 <pavonia> I mean the why is pretty much answered by the whole article
07:06:19 <ocramz> question on typeclass constraints and type families: `class (Ring (Scalar v)) => VectorSpace v where type Scalar v :: *` means that we restrict the members of the class `VectorSpace` to those for which the type `Scalar v` is an instance of `Ring`?
07:08:14 <merijn> ocramz: Yes
07:09:03 <ocramz> merijn: thanks
07:09:33 <ocramz> but since the type is local to the class, how are instances declared?
07:10:40 <merijn> ocramz: The type isn't local to the class
07:11:19 <merijn> ocramz: associated types end up just defining a regular type family instance for the type you're implementing for the class
07:11:46 <HairyDude> ocramz: the ones for which the type Scalar v (not v itself) is an instance of Ring
07:13:33 <HairyDude> not sure what a constraint over an associated type in the class head means
07:13:59 <HairyDude> oh, I misread your question
07:13:59 <merijn> HairyDude: It's just a regular constraint
07:14:36 <HairyDude> thought it was asking if v had to be a Ring.
07:15:42 <HairyDude> is there a version of System.FilePath that uses Text instead of String?
07:16:00 <HairyDude> or failing that, ByteString
07:16:42 <ocramz> so let me get this right: I don't see instances of the associated type `Scalar v`, even though the constraint requires `Ring (Scalar v)`. I don't get it
07:16:43 <merijn> HairyDude: Have a look at System.Posix from the unix package
07:16:51 <ocramz> Is the instance written automagically?
07:16:57 <merijn> ocramz: No
07:17:20 <merijn> ocramz: Suppose I have "Vector Int" with "type Scalar (Vector Int) = Int"
07:17:41 <merijn> ocramz: Then the constraint says "Vector Int" can only be a VectorSpace if "Int" is an instance of Ring
07:17:54 <merijn> Since "Scalar (Vector Int) ~ Int"
07:18:30 <merijn> Because "class (Ring (Scalar (Vector Int))) => VectorSpace (Vector Int)" simplifies to
07:18:44 <merijn> "class (Ring Int) => VectorSpace (Vector Int)"
07:18:44 <HairyDude> merijn: I want something portable, specifically that will work on windows
07:19:08 <ocramz> merijn: sure; so there must be an `instance Ring Int` somewhere
07:19:09 <geekosaur> portable is Difficult here
07:19:10 <merijn> HairyDude: Not possible, windows filepaths unicode, whereas unix are arbitrary bytes
07:19:19 <merijn> ocramz: Yes
07:19:27 <merijn> ocramz: Which means someone has to write it, yes
07:19:33 <merijn> ocramz: Else it won't compile
07:19:54 <ocramz> right; thanks merijn, it was just a sanity check
07:20:03 <merijn> HairyDude: There's unix-compat, maybe you can combine that with unix and platform flags in cabal
07:20:12 <turiya> hi
07:20:37 <ocramz> hi turiya
07:20:49 <HairyDude> merijn: you mean Text-based FilePath doesn't make sense because the encoding of Unix paths is undefined?
07:21:36 <turiya> i am trying to use gnuplot and have trouble compiling a simple example
07:21:43 <geekosaur> yes, and you can get things from exceptions to potential security issues (from opening the wrong file) if you try to pretend Unix paths are always Unicode
07:21:54 <merijn> HairyDude: Yes
07:22:03 <HairyDude> merijn: ok, what about ByteString?
07:22:11 <merijn> HairyDude: That doesn't make sense on windows
07:22:14 <turiya> the error i get is Could not find module `Graphics.Gnuplot.Execute'
07:22:18 <merijn> HairyDude: Since windows MUST be utf-16
07:22:47 <HairyDude> merijn: so we fall back on the lowest common denominator... ick
07:22:48 <geekosaur> there. at least, it is safe to use ByteString + utf8 though
07:22:50 <merijn> HairyDude: The sanest solution would be to write a tiny compat shim to hide the platform difference and conditionally use the windows or unix code in your package
07:23:08 <geekosaur> but you need to add that conversion step conditionally by platform, ick
07:23:08 <HairyDude> merijn: hm, I already do that to work around a ghc bug, so that's not a bad idea
07:23:38 * hackagebot hidapi 0.1.4 - Haskell bindings to HIDAPI  https://hackage.haskell.org/package/hidapi-0.1.4 (NiklasHambuechen)
07:23:47 <merijn> HairyDude: You can use CPP to conditionally import "Files.Windows" or "Files.Unix" and have both export the same functions implemented platform dependently
07:24:05 <merijn> Or, I suppose, one module and keep the CPP internal, probably nicer
07:24:44 <HairyDude> merijn: I don't want to use CPP and I don't think it's necessary, I'm currently using if os(windows): etc. in the .cabal file
07:25:19 <puregreen> > imapM_ (\i x -> if i==x then Just i else Nothing) [0..9]
07:25:22 <lambdabot>  Just *Exception: Sequenced: value used
07:25:31 <maerwald> merijn: that breaks haddock source links though
07:25:44 <maerwald> if I understand what you are suggesting
07:26:03 <puregreen> hm, apparently it's a bug in lens
07:26:31 <maerwald> e.g. https://hackage.haskell.org/package/filepath-1.4.1.0/docs/src/System.FilePath.Posix.html#pathSeparators
07:28:04 <puregreen> > imapM_ (\i x -> Just True) []
07:28:06 <lambdabot>  Just *Exception: Sequenced: value used
07:32:50 <turiya> anyone used gnuplot?
07:36:27 <jophish> turiya: I don't know what you're trying to do, but chart is pretty handy
07:36:28 <jophish> https://github.com/timbod7/haskell-chart/wiki
07:38:38 <turiya> jophish: i see. i thought gnuplot should be very powerful so am trying some examples
07:39:15 <turiya> how does one give module path to ghc
07:39:52 <turiya> in ghci if I use the -i option then ghci seems forget its standard path
07:40:37 <geekosaur> don't use a space
07:41:19 <geekosaur> "-i/path" adds /path. "-i /path" clears the path and then tries to load /path as source
07:41:54 <turiya> i see. thanks
07:43:18 <mnoonan> I'd like to understand (mostly out of curiosity) the recursion scheme corresponding to this pattern: compute some value :: b for each N-sized window in a list, getting a [b] from a [a], when the thing you're computing can be worked out from the current window's result, the value being evicted, and the value being added (so an a -> a -> b -> b)
07:43:44 <mnoonan> a rolling average probably being the most common example
07:50:21 <yak> how does one convert between two numeric types? right now i will just do
07:50:21 <yak>       a read.show :: Double
07:52:34 <ski> yak : which numeric types ?
07:52:51 <jophish> EvanR: there is also Data.Bifunctor.TH
07:53:05 <ski> yak : `fromIntegral' will convert from `Int',`Integer',`Word',...
07:53:40 <pavonia> yak: https://wiki.haskell.org/Converting_numbers
07:53:48 <ski> yak : `realToFrac' will convert from `Rational',`Float',`Double',...
07:58:07 <cheater> @hoogle Iso
07:58:08 <lambdabot> Data.Char isOctDigit :: Char -> Bool
07:58:09 <lambdabot> package iso3166-country-codes
07:58:09 <lambdabot> package iso639
08:02:13 <cheater> @hoogle (a -> b) -> (b -> a) -> (b -> b) -> a -> a
08:02:13 <lambdabot> No results found
08:02:16 <jle`> yak: don't do read.show :P
08:02:21 <cheater> why is there no common function of this type?
08:02:33 <jle`> cheater: what does it do?
08:02:38 <cheater> it would seem to me like the ability to quickly put a computation in another space would be of advantage
08:02:48 <cheater> e.g. sum stuff in another monoid
08:03:22 <cheater> e.g. perform float computation on two integers
08:03:31 <jle`> there's 'over' i suppose
08:03:39 <cheater> @type over
08:03:41 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
08:03:48 <ski> @let infixr 5 (~>); (~>) :: (a1 -> a0) -> (b0 -> b0) -> ((a0 -> b0) -> (a1 -> b1)); (f ~> h) g = h . g . f
08:03:48 <lambdabot>  Parse failed: Parse error: (
08:04:03 <ski> er, right
08:04:06 <ski> @let infixr 5 ~>; (~>) :: (a1 -> a0) -> (b0 -> b0) -> ((a0 -> b0) -> (a1 -> b1)); (f ~> h) g = h . g . f
08:04:08 <lambdabot>  .L.hs:192:14:
08:04:08 <lambdabot>      Couldn't match type ‘b0’ with ‘b1’
08:04:10 <lambdabot>        ‘b0’ is a rigid type variable bound by
08:04:22 <ski> @let infixr 5 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (f ~> h) g = h . g . f
08:04:23 <cheater> what's a Profunctor?
08:04:24 <lambdabot>  Defined.
08:04:27 <jle`> > over hex (*2) "123"
08:04:29 <lambdabot>  "246"
08:04:39 <cheater> @type hex
08:04:41 <lambdabot> (Integral a, Applicative f, Choice p) => p a (f a) -> p String (f String)
08:05:02 <ski> @type words ~> unwords
08:05:05 <lambdabot> ([String] -> [String]) -> String -> String
08:05:14 <yak> jle`: i got my answer in the beginners room. i promise i will be a good haskeller from now on
08:05:32 <ski> > ((words ~> unwords) . map) reverse "This is a dream"
08:05:35 <lambdabot>  "sihT si a maerd"
08:05:55 <jle`> cheater: in our case the instance we're using for p is (->)
08:06:13 <jle`> so it's over :: Setting (->) s t a b -> (a -> b) -> (s -> t)
08:06:24 <jle`> give it a setter and it lifts a (a -> b) to an (s -> t)
08:06:24 <cheater> i don't trust this
08:06:38 <cheater> because you somehow have to get back from b to a
08:06:51 <cheater> oh
08:06:53 <jle`> yeah, for our case, a and b are the same
08:07:25 <jle`> so it'd really be Setting (->) a a b b -> (b -> b) -> (a -> a)
08:07:25 <zack0> Hi! I have two lists ["A","B"] and ["C","D"]. I have to get IO () output of all possible combinations: A C, AD, BC and BD. What would be the easiest way to do it?
08:07:40 <jle`> cheater: you can think of Setting (->) a a b b as equivalent to (a -> b, b -> a)
08:07:55 <jle`> so a Setting is just a box containing the (a -> b) and (b -> a)
08:08:12 <ski> > sequence [["A","B"],["C","D"]]
08:08:14 <lambdabot>  [["A","C"],["A","D"],["B","C"],["B","D"]]
08:08:31 <jle`> so it's the same as your function, (a -> b, b -> a) -> (b -> b) -> a -> a
08:08:40 * hackagebot buffer-builder 0.2.4.2 - Library for efficiently building up buffers, one piece at a time  https://hackage.haskell.org/package/buffer-builder-0.2.4.2 (chadaustin)
08:08:50 <jle`> but yeah it might be nice to have something like this in base,
08:09:18 <ski> zack0 : another way is to use two `forM_' calls, one for each list
08:09:35 <jle`> > over (iso runIdentity Identity) (*2) (Identity 10)
08:09:37 <lambdabot>  Identity 20
08:09:58 <jle`> > over (iso fromIntegral round) (/2) 15
08:10:04 <lambdabot>  8
08:10:50 <jle`> > over (iso round fromInteger) (`mod` 6) 16.8
08:10:52 <lambdabot>  5
08:12:05 <zack0> ski : how could I output it as IO () though?.. so every pair would be on a separate line
08:13:02 <ski> > let select = ContT . forM_ in execWriter . (`runContT` return) $ do [x,y] <- mapM select [["A","B"],["C","D"]]; lift (tell [[x,y]])
08:13:03 <jle`> you can mapM_ print or mapM_ putStrLn to create an IO () that prints out every item in a list
08:13:04 <lambdabot>  [["A","C"],["A","D"],["B","C"],["B","D"]]
08:13:25 <jle`> mapM_ putStrLn $ sequence [["A","B"],["C","D"]]
08:13:31 <ski> ^ that uses two `forM_' calls, one for each list
08:13:36 <ski> (my version)
08:13:52 <zack0> thank you ski & jle`
08:14:41 <jle`> @let cheaterFunc f g h = over (iso f g) h
08:14:41 <ski> > execWriter $ forM_ ["A","B"] $ \x -> forM_ ["C","D"] $ \y -> tell [[x,y]]
08:14:43 <lambdabot>  [["A","C"],["A","D"],["B","C"],["B","D"]]
08:14:44 <lambdabot>  Defined.
08:14:47 <jle`> :t cheaterFunc
08:14:48 <lambdabot> (s -> a) -> (b -> t) -> (a -> b) -> s -> t
08:14:52 <ski> ^ that's the simpler way to do it
08:15:02 <ski> you just use `IO' instead of `Writer'
08:15:11 <zack0> thx
08:15:28 <jle`> > cheaterFunc fromIntegral round (/2) 15
08:15:28 <ski> @type tell
08:15:30 <lambdabot> MonadWriter w m => w -> m ()
08:15:30 <lambdabot>  8
08:15:32 <cheater> @type iso
08:15:32 <ski> @type putStrLn
08:15:33 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
08:15:35 <lambdabot> String -> IO ()
08:15:58 <jle`> cheater: it "packs up" the (a -> b) and (b -> a) into a Setting (->) a a b b that you can use with 'over'
08:17:55 <cheater> interesting
08:17:58 <cheater> @type Setting
08:18:00 <lambdabot>     Not in scope: data constructor ‘Setting’
08:18:01 <lambdabot>     Perhaps you meant variable ‘setting’ (imported from Control.Lens)
08:18:07 <cheater> @info Setting
08:18:08 <lambdabot> Setting
08:18:15 <bmuk> when using wreq, how can I convert the JSON in the response body to a haskell type all at once? I see the ^.. responseBody . key "foo" . values will give me all values under the key foo
08:18:21 <cheater> wait, how do i get the info of what Setting is?
08:18:23 <jle`> iso :: (a -> b) -> (b -> a) -> Iso a a b b, which is a polymorphic/general type that unifies with Setting (->) a a b b
08:18:25 <Boomerang> > let func f g h a = g . h . f $ a in func fromIntegral round (/2) 15
08:18:27 <lambdabot>  8
08:18:48 <jle`> or i should say iso :: (a -> b) -> (b -> a) -> Iso a a b b, which unifies with Setter a a b b
08:18:51 <geekosaur> cheater, use ghci or the lens documentation. lambdabot doesn't do :info
08:18:53 <jle`> which is what 'over' takes
08:18:57 <cheater> :(
08:19:08 <cheater> bad lambdabot!
08:19:09 <jle`> over :: Setter a a b b -> (b -> b) -> (a -> a)
08:19:23 <jle`> to be fair, what would you expect lambdabot to do with :info?
08:19:34 <cheater> print it out
08:19:49 <ski> there is no `info' command in lambdabot
08:20:06 <jle`> cheater: print what out?
08:20:28 <cheater> the same thing as :i in ghci
08:20:35 <jle`> you mean the 20+ lines?
08:20:39 <cheater> sure
08:20:48 <jle`> yeah, probably not a good feature for an IRC bot :)
08:20:49 <ski> would be spamming the channel
08:20:54 <cheater> it's not like we're about to run out of paper
08:21:10 <cheater> the other outputs from lamdbabot get limited too iirc
08:21:19 <cheater> plus i could use it in query
08:21:23 <geekosaur> spamming the channe; and either gets the bot kicked for flooding, or makes it rate limit to 1/second
08:21:37 <jle`> they get limited, but the 'first few lines' of :info usually aren't what you're looking for
08:21:58 <cheater> there's surely a smart way to show the most interesting bit
08:22:12 <geekosaur> um
08:22:33 <geekosaur> "@info Monoid" --- given what lb has loaded, which bit is the interesting one?
08:22:49 <cheater> lb?
08:22:56 <geekosaur> lambdabot
08:23:30 <cheater> oh. i don't know. Monoid is a class, I was looking at a type.
08:23:30 <jle`> cheater: every part is the interseting part, that's the point of :info
08:23:58 <jle`> it just dumps out a bunch of stuff
08:24:06 <jle`> it'd probably make more sense to have apsecific commands to ask specific questions
08:24:11 <jle`> instead of the barf that is info :)
08:24:36 <cheater> dunno i'd like just the whole barf
08:24:49 <cheater> it's fine if the bot floods me in query
08:25:23 <cheater> with barf
08:27:46 <geekosaur> some of those do exist; cf. @instances / @instances-importing
08:28:20 <geekosaur> (but not the other direction iirc)
08:31:44 <puregreen> the problem is of discoverability
08:31:54 <puregreen> people can guess to use “:info”, but nobody will ever guess to use “@instances”
08:32:43 <cheater> I wish type notation were more expressive than SomeBarf a b c d e f g -> x -> y
08:32:48 <geekosaur> so add the different commnds and then catch :i and print a message
08:32:58 <cheater> because SomeBarf has certainly got a specific shape with regards to a b c d e f and g
08:33:09 <cheater> and that would tell me everything I need, most likely
08:33:35 <cheater> if I look at Setter and Setting all I see is "random string of characters" though
08:33:52 * geekosaur could wish that descriptive names were the norm in type specifications...
08:34:24 <cheater> it's not really about the names. I wish it was something like, a small drawing of the things that SomeBarf contains, like a graph over its type arguments
08:34:26 <dolio> Maybe you should stop using an IRC bot as your only programming assistance, and cluttering this channel with complaints about it.
08:34:47 <cheater> dolio: i'm not complaining about lambdabot - i wish Haskell notation was more expressive
08:43:53 <lyxia> what kind of "graph" are you thinking of
08:46:29 <cheater> well for example Setter was said to contain a -> b and b -> a
08:48:23 <lyxia> most lens types are quite similar with the same order of type variables
08:48:57 <cheater> it's true that i mostly see this issue with lens types
08:49:32 <cheater> maybe i should learn those by heart
08:58:35 <Xnuk> @hoogle makeIs
08:58:35 <lambdabot> No results found
08:59:28 <phadej> Xnuk: https://www.stackage.org/lts-5.17/hoogle?q=makeIs
09:00:02 <Xnuk> phadej: thanks!
09:25:51 <mikail_> Hi, I have  a list of Doubles. I tried to map over this list as follows: map (\x -> max 0.0 (100.0 - x)) xs.
09:26:13 <mikail_> but I get these errors: <interactive>:72:16:                                                                                                                                                                                             No instance for (Fractional [Double])                                                                                                                                                                          arisin
09:26:31 <mikail_> how can I fix this
09:27:13 <scshunt> :t max
09:27:14 <lambdabot> Ord a => a -> a -> a
09:27:18 <monochrm> > map (\x -> max 0.0 (100.0 - x)) [1.2, 2.3, 3.4, 3.14159]
09:27:20 <lambdabot>  [98.8,97.7,96.6,96.85841]
09:27:23 <scshunt> :t 0.0
09:27:24 <monochrm> worksforme
09:27:24 <lambdabot> Fractional a => a
09:27:28 <scshunt> ^ that's why
09:27:39 <scshunt> 0.0 is a Fractional constant, and Double is not Fractional
09:27:59 <monochrm> > map (\x -> max 0.0 (100.0 - x)) [1.2 :: Double, 2.3, 3.4, 3.14159]
09:28:01 <lambdabot>  [98.8,97.7,96.6,96.85841]
09:28:09 <monochrm> Double is totally a Fractional
09:28:26 <monochrm> the cause is elsewhere
09:28:36 <monochrm> http://www.vex.net/~trebla/humour/tautologies.html #4
09:28:43 * hackagebot ip 0.3 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.3 (andrewthad)
09:29:13 <hpc> monochrm: that's a pretty good one
09:29:15 <scshunt> oh wait
09:29:16 <scshunt> yeah
09:29:17 <scshunt> misread
09:29:27 <scshunt> mikail_: looks like you're trying to map over a list of lists
09:30:12 <mikail_> xs :: PrimMonad m => m [Double]
09:30:17 <mikail_> that's the type of my list
09:30:33 <monochrm> then you have two errors, not one.
09:30:53 <monochrm> you need an extra fmap for the m, and it should be at the outside.
09:31:01 <scshunt> yeah, that's the problem
09:31:07 <monochrm> fmap (map  (\x -> max 0.0 (100.0 - x)) ) xs 
09:31:07 <scshunt> map applies to a list
09:31:18 <scshunt> monochrm: or just map (...) <$> xs
09:31:29 <mikail_> oh
09:31:31 <scshunt> what was happening was that when you applied map to an m [Double]
09:31:35 <mikail_> let me try
09:31:35 <scshunt> it was unifying m with []
09:31:40 <scshunt> so you were mapping over [[Double]]
09:31:46 <mikail_> oh ok
09:32:49 <mikail_> thanks guys
09:32:52 <mikail_> works
09:35:10 <jle`> any reason why there can't be a 'partitionMonotonic' for Data.Set, which is an O(log n) version of partition where the projection function is assumed to be monotonic?
09:38:25 <ggVGc> I've got a collection which is indexed by some other things, but I want to be able to reorganize the collection while keeping the references. What's my best option for structuring that?
09:39:29 <ggVGc> a Map Int a with an increasing index for new entries, and a separate list for the ordering?
09:39:32 <ggVGc> that doesn't seem cool
09:39:37 <ggVGc> but I don't really know how to do it
09:40:09 <ggVGc> I don't want to re-update all the references every time I reorganize the collection
09:40:40 <int-e> jle`: fun one... it's essentially the same as split/splitMember.
09:40:51 <jackhill> Hi, I have a function with type String -> IO Bool, and I have a [String]. I would like to end up with a IO [String], where the list is filtered using the function. Does that operation make sense? How do I do it?
09:41:09 <deni> if i do "stack haddock" will that build all the documentation for all the packages I'm using locally?
09:41:15 <deni> where is that documentation stored?
09:41:32 <monochrm> @type filterM
09:41:34 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
09:41:44 <monochrm> jackhill: I think filterM may do that
09:41:45 <jackhill> martingale: perfect
09:41:54 <jackhill> (I think)
09:42:02 <jackhill> er and that should have been monochrm 
09:43:06 <int-e> jle`: so no, there is no reason why such a function couldn't exist. it's unclear how useful it would be in practice.
09:44:09 <int-e> jle`: I can think of problems like "I have this set of rationals and I want to split it into those that are smaller than sqrt(2) and the rest" but it's rather artificial.
09:44:36 <Cale> I needed such a thing the other day.
09:45:32 <Cale> Actually, is that what I needed? hm
09:45:40 <monochrm> haha
09:46:05 <Cale> I was partitioning on the key, but split was sort of annoying
09:47:18 <Cale> Right, if I hadn't been using our additionally indexed map structures, I would have needed that operation :)
09:48:13 <ggVGc> I think I have to invent a data type that's a map with an ordering of the keys
09:48:26 <ggVGc> is there such a thing?
09:48:44 * hackagebot cloben 0.1.0.1 - Clone and benchmark Haskell cabal projects  https://hackage.haskell.org/package/cloben-0.1.0.1 (sgraf812)
09:49:54 <Cale> ggVGc: A pair of maps perhaps?
09:51:04 <geekosaur> seems conceptually related to priority search queues, although I don't think those are directly the answer (it depends)
09:51:45 <ggVGc> Cale: what would the second map hold?
09:52:57 <Cale> Well, e.g. you might have  Map UTCTime k, and then Map k a
09:58:58 <byorgey> ggVGc: what exactly do you mean by "a map with an ordering of the keys"? can you give an example?
10:01:46 <ggVGc> byorgey: I have a list of things, that I care about the order of, and it is sometimes re-ordered. But I also have other values referncing slots in this list, currently by index. But this obviously doesn't work when it's reordered. So I'd like a structure that lets me re-order it, while not losing the relations
10:01:51 <ggVGc> oh, da,n
10:01:57 <ggVGc> it's just [(Int, a)]
10:01:59 <ggVGc> hah, I'm dumb
10:02:10 <ggVGc> thanks for being my rubber duck
10:04:22 <byorgey> ggVGc: for more efficiency you could also use  ([a], Map Int a), i.e. store the order and the mapping separately
10:04:42 <ggVGc> yeah, but it doesn't matter in this case. The list is always max 20 items or so
10:04:50 <ggVGc> thanks
10:04:52 <byorgey> fair enough, [(Int, a)] it is =)
10:48:15 <ggVGc> man, reading this, I have no idea when I would use any of this, https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Plated.html
10:48:21 <ggVGc> but it seems like stuff I should be using
10:53:30 <Cale> ggVGc: maybe start by using uniplate
10:53:37 <Cale> http://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate.html
10:56:14 <ggVGc> for now I'm wondering how I can get a lens to target a value in a [(a,b)], like the lookup function in Data.List
10:56:25 <ggVGc> Cale: is Lens.Plated what I want?
10:56:32 <ggVGc> or what should I be looking for
10:57:13 <c_wraith> filtered
10:57:18 <Cale> Maybe Control.Lens.Indexed?
10:57:44 <Cale> I don't know if that works on association lists in any way
10:58:00 <Cale> There's at
10:58:00 <c_wraith> :t filtered ((==1).fst)
10:58:02 <lambdabot> (Eq b, Num b, Applicative f, Choice p) => Optic' p f (b, b1) (b, b1)
10:58:16 <Cale> Is that a lens though?
10:58:31 <c_wraith> it's an unlawful traversal 
10:58:43 <Cale> at will give you a lens to a particular element of a list, by index
10:58:59 <ggVGc> yeah, adn that's what I currently have.
10:59:32 <ggVGc> I have this, https://gist.github.com/7cd9bd2dc188a915a25ea0efced1e0fc but trigGroupSeqs is now [(Int, TriggerSeq)] rather than [TriggerSeq]
10:59:36 <Karab> whats up
10:59:42 <ggVGc> I guess filtered is what I want
11:02:43 <ggVGc> htm
11:02:45 <ggVGc> not that simple
11:10:38 <glguy> Prelude Control.Lens> let assoced = traverse . itraversed :: IndexedTraversal' k [(k,v)] v
11:10:38 <glguy> Prelude Control.Lens> set (assoced . index 'c') 10 (zip "abc" [0..])
11:10:39 <glguy> [('a',0),('b',1),('c',10)]
11:12:20 <ggVGc> wow, thanks
11:12:33 <ggVGc> glguy: I need to wrap my head around that, but it made my code compile
11:12:34 <ggVGc> cheers
11:12:49 <ggVGc> one day I'll actually know how to write these lenses without struggling for hours..
11:13:40 <ggVGc> lenses are pretty amazing
11:20:19 <Myrl-saki> What do you guys use as your general purpose computation tool?
11:20:26 <ggVGc> python
11:20:28 <ggVGc> :(
11:20:32 <Myrl-saki> ggVGc: :P
11:20:37 <inkjetunito> same
11:20:42 <simpson> Myrl-saki: Python or Monte.
11:20:58 <glguy> Haskell
11:21:09 <Myrl-saki> ggVGc: The only reason why I start the python interpreter is because it starts faster than ghci. <.<
11:21:16 <puregreen> Haskell or Mathematica
11:21:35 <simpson> Myrl-saki: Note that that's largely a function of age and background; somebody could just as easily answer "Perl" if they're a 90s sysadmin.
11:21:45 <Myrl-saki> Not even joking. "Meh, I just need to add these 2 numbers together, aaand ghci's taking 5 minutes."
11:21:54 <ggVGc> 5 minutes?
11:22:04 <glguy> Time for a PC refresh
11:22:12 <Myrl-saki> ggVGc: Not really, there are times when it does reach 1 minute though.
11:22:14 <ggVGc> can't tell a difference between ghci and pythin startup time
11:22:22 <ggVGc> what?
11:22:22 <puregreen> wait, so my idea of a “ghci daemon” wasn't actually that useless?
11:22:25 <ggVGc> ghci si instant for me
11:22:45 <simpson> Myrl-saki: Guessing you preload a lot of stuff?
11:22:51 <Myrl-saki> simpson: Most likely.
11:23:00 <simpson> ghci is fast for me, but then I have to :m + Control.Monad Control.Lens ...
11:23:14 <Myrl-saki> simpson: That, or my hard drive is borked.
11:23:35 <exio4> ghci is <1s on my FX - I avoid loading too much though.
11:23:37 <Myrl-saki> It takes like 3 minutes to load up urxvt, dmenu and firefox simultaneously.
11:24:02 <exio4> or you are running everything on a i386
11:24:05 <monochrm> I use my laptop for my general puspoe computational tool. how old am I?
11:24:16 <Myrl-saki> monochrm: Dang, I should follow your ways.
11:24:55 <ggVGc> `I don't do computation
11:24:56 <monochrm> but I have a desktop for general purpose gaming tool
11:24:57 <simpson> monochrm: I need to know 9 ^^ 5 (tetration). Or, rather, I need the last six digits. What tool do *you* reach for when that kind of question comes up?
11:25:13 <ggVGc> python..
11:25:16 <JustinHitla> hi, how to make that string "1,2,200-202,7-5" into "1,2,5,6,7,200,201,202" ?
11:25:34 <ggVGc> python is way better as a calculator imo
11:25:47 <Myrl-saki> JustinHitla: 7-5"
11:25:48 <Myrl-saki> ?
11:25:52 <ggVGc> since you don't care about your program being rigid and you just want the answer quickly. And you see easily if it's not a reasonable answer
11:26:00 <ggVGc> and if you want to format it, it's way easier in pythion than haskell
11:26:01 <monochrm> the trouble is, though, that I put my laptop on my desk, and my desktop under the desk.
11:26:17 <monochrm> but at least, I don't put my desktop on my lap.
11:26:26 <glguy> JustinHitla: You'll write a function to parse that into a set of ranges and then a function to turn ranges into lists and then concatenate those and sort
11:26:42 <Myrl-saki> monochrm: they're called notebooks now, be politically correct please.
11:27:03 <ggVGc> as a person who does not usually take notes on my laptop, I am offended by that definition
11:27:14 <monochrm> but it is not a book, and I don't take notes on it. I take notes on my iPod Touch.
11:27:21 <ggVGc> ^^^
11:27:27 <ggVGc> Myrl-saki: be socially correct please
11:27:34 <ggVGc> there are other people than you using computers
11:27:37 <Myrl-saki> ITT: rich ppl
11:28:24 <ggVGc> also, as a representative for all the actual notebooks out there, which are actual books with notes in them, I am offended on their behalf
11:29:01 <Myrl-saki> ggVGc: Why not a list of ranges to a set?
11:29:12 <Myrl-saki> to a set of integers*
11:30:01 <ggVGc> instead of [(Int, a)]?
11:30:12 <ggVGc> I don't see how that makes sense for my use case, but I might misunderstand
11:30:37 <Myrl-saki> ggVGc: I meant on your reply to JustinHitla.
11:31:15 <ggVGc> oh, I didn't reply to that. There's some confusion going on
11:31:25 <Myrl-saki> Woops.
11:32:17 <glguy> Myrl-saki: I don't think the important part is set or list; the point is that there's going to be a few stages of process to get from start to finish
11:32:17 <Myrl-saki> ggVGc: Sorry, you and glguy both appear green to me.
11:32:40 <Myrl-saki> glguy: Right.
11:33:36 <Myrl-saki> JustinHitla: Also, how are overlaps hadled?
11:33:39 <Myrl-saki> handled*
11:34:03 <ggVGc> glguy: could you write me one quick sentence on what's actually going on with `treverse.itraversed.index`. It's not clicking for me :(
11:34:12 <ggVGc> if it's not too much hassle
11:34:38 <glguy> the first 'traverse' applies our operation to each element of the list (the elements having type (k,v))
11:35:08 <glguy> the itraversed uses the fact that there's an instance of TraversableWithIndex that treats a 2-tuple as an index and value
11:35:26 <glguy> so itraversed applies our operation to the second element of a tuple while remembering the first as a key
11:35:43 <ggVGc> ah yeah, okay ,so before itraversed was the missing piece I was looking for
11:35:44 <ggVGc> thanks
11:35:47 <ggVGc> makes sense now
11:35:52 <Myrl-saki> :t traverse
11:35:54 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:36:17 <ggVGc> glguy: makes me feel like assoced should be a defined function though
11:36:21 <ggVGc> it seems very generally useful
11:36:23 <Myrl-saki> Oh, right. Is this the (sequence .). map?
11:36:28 <ggVGc> and it wasn't obvious to me how to construct it
11:36:41 <Myrl-saki> :t (sequence .) . map
11:36:42 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
11:37:08 <Myrl-saki> :t (sequence .) . fmap
11:37:09 <lambdabot> (Monad m, Traversable t) => (a1 -> m a) -> t a1 -> m (t a)
11:37:52 <Myrl-saki> :D
11:37:58 <jle`> int-e: i wanted to maintain a BST of my event type, and be able to split the tree before and after a given time
11:38:13 <jle`> int-e: the Ord instance already has them naturally sorted by time
11:38:41 <jle`> but to use split, i'd have to conjure up a dummy event with just the time i wanted to split on
11:38:50 <jle`> it'd make more sense to just be able to ask to partition/split on the time itself
11:39:18 <jle`> not sure if this use case is too specialized, but i don't think it'd be too uncommon
11:41:24 <jle`> but the `do x <- y; return (f x)` pattern is just fmap f y
11:41:35 <jle`> oops, wrong window
11:43:17 <monochrm> I wonder if you should use "Map Time Event" instead of "Set Event". then you will not conjure up a blank Event record.
11:45:00 <jle`> perhaps, but it feels like the wrong interface to work with something like this
11:45:17 <monochrm> to be sure, splitA gives you (Map Time Event, Maybe Event, Map Time Event), which is not exactly a 2-partition, you have to post-process it.
11:45:18 <jle`> i could abstract over it to implement a pseudo Set Event that way
11:45:24 <monochrm> s/splitA/splitLookup
11:45:55 <exio4> .
11:45:59 <jle`> because it's not really supposed to be events indexed by a time, but rather a bag of events that have a time
11:46:17 <jle`> (and times are potentially non-unique)
11:46:47 <jle`> i could probably implement it as a Map Time [Event], and write some abstraction over it
11:46:47 <lpaste_> glguy pasted “"1,2,200-202,7-5" into "1,2,5,6,7,200,201,202"” at http://lpaste.net/163810
11:48:33 <jle`> is safecopy still recommended for usage for new projects these days?
11:49:59 <jle`> it uses cereal and TH instead of the modern binary and ghc generics
12:01:33 <jophish> I have an instance declaration where for all member functions foo in the class the instance has: lift . lift . foo; is there a tool to derive this for me?
12:08:29 <Unode> Hi everyone.
12:08:37 <seyt> Hey Unode 
12:09:25 <Unode> I'm trying to compile something globally with stack and installing it. Is there any way to specify another install location other than ~/.local/bin ? Ideally something I can put in some config file so future installs use this.
12:12:35 <idev> is there a builtin for m a -> (a -> b) -> m b ?
12:12:36 <sm> Unode: in stack --help I see --local-bin-path
12:14:19 <monochrom> idev: it's fmap with a different argument order
12:14:31 <verement> :t flip fmap
12:14:32 <lambdabot> Functor f => f a -> (a -> b) -> f b
12:15:22 <jle`> idev: the lens package offers <&>, if you already have that dependency
12:15:33 <jle`> i think there is some complications with moving it into base because it's not clear what the fixity should be
12:16:49 <jle`> but i do find myself using flip fmap pretty often
12:16:53 <idev> monochrom , jle` : nice, thanks
12:17:25 <jle`> > [1,2,3] <&> \x -> x * 2 + 3
12:17:27 <lambdabot>  [5,7,9]
12:20:31 <Unode> sm thanks for the hint. I had seen it but couldn't figure out how to set it since "stack config set local-bin-path ~/bin" gives me "stack: parse stack config set field: only set resolver is implemented"
12:21:01 <Unode> I could edit the yaml file directly but I haven't found an example yet so I have have a guideline for syntax.
12:34:15 * dfeuer stabs whoever came up with the stupid aspects of the Data.Map API that he now must be consistent with.
12:34:56 <scshunt> dfeuer: such as?
12:36:16 <dfeuer> scshunt, alter, update, adjust, insertWith, etc., etc., all take their arguments in a stupid order, different from what pretty much anyone else does. Which means I have to make the new alterF do the same stupid thing and annoy all future users, because otherwise other people will be justifiably annoyed and confused by the inconsistency.
12:36:45 <srhb> :t M.update
12:36:46 <lambdabot> Ord k => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
12:37:56 <srhb> dfeuer: Well, this obviously calls for YourModule.Flipped
12:39:26 <dfeuer> srhb, yes, I'm thinking about that. But If I'm going to start a new module, it's going to be a fresher start than that. Strip down the API some, make things more modern, add things very conservatively....
12:39:29 <scshunt> dfeuer: that seems like a sensible ordering
12:39:56 <scshunt> the container always goes last because of currying
12:39:59 <dfeuer> scshunt, it may seem that way, but in practice it's usually better to put the key first.
12:40:10 <scshunt> dfeuer: oh, you mean key before function?
12:40:15 <scshunt> hmm... yeah, ok
12:40:22 <scshunt> at least that is sliceable
12:40:26 <scshunt> (`M.update` k)
12:40:28 <Rembane> We need a Data.Map2.
12:40:40 <dfeuer> Yes. That would make it compatible with the functions from lens, and also make it easier to write manually.
12:40:46 <jle`> let's just have named arguments
12:40:51 <scshunt> dfeuer: Just make lens your only interface
12:40:51 <scshunt> done
12:41:13 <dfeuer> scshunt, there are efficiency problems with that approach.
12:42:08 <Maxdamantus> data MapUpdateConfigurationBuilderStrategyFactory
12:42:38 <dfeuer> But there are some functions we might be able to do without, once we have alterF.
12:42:48 <dolio> I don't think it's better to put the key first, unless the only user is lens.
12:43:51 <dolio> Or lens usage.
12:44:04 <dolio> That's the case for alterF, but not update.
12:44:12 <dfeuer> dolio, I really like key-first because I really like small-argument-first. The key is very likely to be a variable, while the function is likely to be written out.
12:45:02 <dfeuer> But it doesn't much matter for now; Wren and I both agree that consistency wins in spite of ergonomics.
12:45:34 <dolio> update is designed so that you can, for instance, update a list of keys in a consistent way using foldr.
12:45:59 <dolio> Because the function is the first thing you partially apply.
12:46:42 <dfeuer> dolio, I guess that makes sense.
12:49:24 <dfeuer> dolio, OTOH, I don't see why you couldn't use alterF that way if you wanted, with an applicative functor.
12:49:43 <dfeuer> But I haven't thought it through.
12:50:39 <dolio> You could, but no one has really been asking for it. The entire motivation for alterF was someone commenting that it'd be nice for lens.
12:50:47 <dolio> If I understand correctly.
12:50:56 <dolio> But it doesn't really matter what order the arguments go in.
12:51:11 <dolio> Because lens will just flip it, and alterF is a bad name for the lens that it is.
12:52:14 <dfeuer> I guess that's fair. It would be nice to be able to export something that can be used directly as an `at` lens, giving nicer type errors than using the generic `at`. But I guess that's for another time.
12:57:03 <dfeuer> Could someone remind me how to squash some git commits together?
13:02:24 <cocreature> dfeuer: git rebase -i and then select squash
13:02:36 <jle`> push to github and use their gui squasher
13:02:46 <dfeuer> Er ... okay.....
13:02:52 <dfeuer> Thanks.
13:02:55 <cocreature> jle`: that exists?
13:03:34 <jle`> oh wait maybe not >_>
13:03:49 <dfeuer> Oh well.
13:03:50 * hackagebot hylogen 0.1.1.0 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.1.0 (sleexyz)
13:34:03 <tiny_test> why Enum doesn't have the law `toEnum . fromEnum = id` ?
13:34:26 <jle`> > (toEnum . fromEnum) 2.5
13:34:29 <lambdabot>  *Exception: Prelude.Enum.().toEnum: bad argument
13:34:34 <jle`> > (toEnum . fromEnum) 2.5 :: Double
13:34:36 <lambdabot>  2.0
13:35:06 <geekosaur> someone thought it would be a good idea to have Enum instances for Float and Double, Cantor be damned
13:35:10 <tiny_test> Double shouldn't be an Enum
13:35:20 <tiny_test> huh
13:35:35 <geekosaur> (ctually those types *cou;d* have Enum instances, but they wouldn't do what people "expect")
13:35:36 <twanvl> > (toEnum . fromEnum) 12345678901234567890 :: Integer
13:35:37 <lambdabot>  -6101065172474983726
13:35:40 <Aruro> > (fromEnum . toEnum) 2.5
13:35:42 <lambdabot>      No instance for (Enum a0) arising from a use of ‘fromEnum’
13:35:43 <lambdabot>      The type variable ‘a0’ is ambiguous
13:35:43 <lambdabot>      Note: there are several potential instances:
13:35:48 <Aruro> > (fromEnum . toEnum) 2.5 :: Double
13:35:50 <lambdabot>      Couldn't match expected type ‘Double’ with actual type ‘Int’
13:35:50 <lambdabot>      In the expression: (fromEnum . toEnum) 2.5 :: Double
13:36:07 <Aruro> > (fromEnum . toEnum) 2.5 :: Int
13:36:09 <lambdabot>      No instance for (Enum a0) arising from a use of ‘fromEnum’
13:36:09 <lambdabot>      The type variable ‘a0’ is ambiguous
13:36:09 <lambdabot>      Note: there are several potential instances:
13:36:32 <Aruro> > (fromEnum . toEnum) 'a' :: Char
13:36:34 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘Int’
13:36:34 <lambdabot>      In the expression: (fromEnum . toEnum) 'a' :: Char    Couldn't match exp...
13:36:34 <lambdabot>      In the first argument of ‘fromEnum . toEnum’, namely ‘'a'’
13:36:51 <tiny_test> so that means if I use a double for a function that expects an Enum I'll get bad results
13:37:06 <Aruro> > ((fromEnum . toEnum) 'a') :: Char
13:37:08 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘Int’
13:37:08 <lambdabot>      In the expression: ((fromEnum . toEnum) 'a') :: Char    Couldn't match e...
13:37:09 <lambdabot>      In the first argument of ‘fromEnum . toEnum’, namely ‘'a'’
13:37:11 <tiny_test> is Enum instance of Float/Double useful for anything?
13:37:15 <tiny_test> Aruro: can you please stop
13:37:30 <Aruro> tiny_test: yeah i gave up :D
13:37:58 <twanvl> > [1.0..5.0] -- why there is an instance Enum Double 
13:38:00 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
13:38:11 <tiny_test> > [1.1 .. 5.1]
13:38:13 <lambdabot>  [1.1,2.1,3.1,4.1,5.1]
13:38:20 <tiny_test> wait, how did that work?
13:38:36 <tiny_test> can lambdabot desugar?
13:39:01 <twanvl> [a..b] desugars to enumFromTo a b
13:39:43 <Aruro> names are misleading, why toEnum is Int->a, shouldnt be otherwise?
13:40:21 <dolio> a is the enumerable type being given in the Enum instance.
13:40:41 <tiny_test> Aruro: I agree that's also confusing. the idea is that type itself is Enum, not Int
13:40:48 <tiny_test> although Int is also an Enum :p
13:41:45 <tiny_test> I guess we could have `newtype Enum = Enum Int` and make toEnum `Enum a => a -> Enum` fromEnum `Enum a => Enum -> a` etc.
13:42:02 <dolio> Double is not the only type that creates problems with the identity law, though.
13:42:19 <tiny_test> dolio: what else?
13:42:24 <dolio> Integer.
13:42:33 <tiny_test> right, it's bigger than Int
13:42:39 <tiny_test> well, everything bigger than Int is a problem
13:42:43 <dolio> Yes.
13:43:13 <tiny_test> maybe Enum should use Integer then. what would be a sensible definition of Enum instance for Double in that case?
13:43:23 <dolio> Also Word, I suspect, even though it's the same size.
13:43:52 * hackagebot hylogen 0.1.1.1 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.1.1 (sleexyz)
13:43:53 <tiny_test> why Word? you can use negative Ints for some Words?
13:44:03 <dolio> Yeah, but it might just blow up.
13:44:14 <hpc> clearly Enum should use Nat
13:44:21 <Aruro> > (toEnum . fromEnum) 'a' :: Char
13:44:22 <lambdabot>  'a'
13:44:30 <twanvl> The Enum class does two things: enumFromTo/enumFromThenTo for desugaring , as well as toEnum/fromEnum. Double can reasonably do the former, but not the latter
13:44:52 <hpc> perhaps enum should be a single-method type class
13:45:04 <tiny_test> maybe we should have a special typeclass for enumFromTo/enumFromThenTo ?
13:45:15 <hpc> nextStep :: Enum a => a -> a -> (Int, a)
13:45:23 <dolio> > fromEnum (2^63 :: Word)
13:45:26 <lambdabot>  *Exception: Enum.fromEnum{Word}: value (9223372036854775808) is outside of I...
13:45:41 <hpc> er, Maybe a -> a -> ...
13:46:01 <hpc> use Nothing for enumerating without a step size
13:46:16 <tiny_test> is it possible to "rebind" [a .. b] syntax?
13:47:26 <hpc> tiny_test: rebind it to something that doesn't match enumFromTo's type?
13:48:33 <tiny_test> hpc: [a .. b] = enumFromTo a b, right? I want it to be `foo a b` instead
13:48:39 <Unode> If I want runhaskell to find libraries/dependencies installed via stack, how do I go about doing that? (Already tried googling for a while but I'm not going anywhere). I see runhaskell -v listing ~/.cabal/... but no ~/.stack .
13:48:41 <buttons840> Should I prefer using a TQueue over a TChan? it looks like TChan has a few extra features that i don't need
13:49:10 <twanvl> I think that with RebindableSyntax ghc will use the enumFromTo that is in scope
13:49:37 <monochrom> I wonder if they use the same data structure internally, so that there is no efficiency difference for you
13:50:08 <monochrom> because TChan simply uses a TVar of ([a], [a]) and does the immutable queue thing
13:50:25 <geekosaur> Unode, use stack exec --- or better, stack runghc
13:51:29 <tiny_test> twanvl: it seems like [a .. b] is not desugared to fromEnumTo .. I'm getting `fromIntegral not in scope` errors when I use it with RebindableSyntax
13:51:45 <tiny_test> twanvl: sorry, fromInteger, not fromIntegral
13:52:15 <twanvl> numbers are desugared to (fromInteger 123), so fromInteger must also be in scope
13:52:15 <tiny_test> is there a -ddump parameter to see what it's desugared into ?
13:52:21 <tiny_test> ah
13:53:08 <hpc> tiny_test: the location of an error includes the column number as well as the line number btw
13:53:28 <hpc> so even though the error message might not be easy to read, you can always find the start of the problem
13:54:43 <texasmynsted> anybody use pp?  http://www.cdsoft.fr/pp/index.html#installation
13:54:54 <texasmynsted> I am wondering if there is a way to install it with stack or something.
13:54:58 <tiny_test> I still don't think that syntax is desugard to fromEnumTo. I only have this import: import Prelude (fromInteger, print) and that code works
13:55:07 <tiny_test> by that code I mean `print [1 .. 5]`
13:56:13 <monochrom> that is not the only possible explanation of your observation.
13:56:18 <c_wraith> tiny_test, the code generated by desugaring can refer to names that aren't imported
13:56:44 <c_wraith> tiny_test, try with -XNoImplicitPrelude
13:56:54 <texasmynsted> hmm is there any preprocessor that I should look at that can help me create graphviz docs, like a haskell app or something.  pandoc comes to mind.
13:57:53 <monochrom> indeed if you read deeply about "import" in the Haskell report, you get the feeling that "import" is only for you to mention names explicitly, not to forbid the compiler from using names implicitly and/or behind your back.
13:57:57 <tiny_test> monochrom: well I had to import fromInteger explicitly
13:58:21 <geekosaur> tiny_test, https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-400003.10
13:59:06 <monochrom> you have not ruled out the possibility that the numerical literal story is different from the [..] story.
13:59:28 <monochrom> in fact at the rate I wouldn't extrapolate any current finding to do-notation either.
14:00:36 <tiny_test> OK, how do you explain this: http://lpaste.net/163822
14:00:48 <tiny_test> ahhh
14:00:50 <tiny_test> ignore pls
14:01:17 <tiny_test> oh no never mind. even if I add `fromEnumTo = undefined` it works
14:01:18 <monochrom> and then I don't know the full story of RebindableSyntax either.
14:01:25 <texasmynsted> Is there a haskell macro processor like m4?
14:01:34 <monochrom> no, there isn't
14:01:41 <texasmynsted> ok
14:01:52 <c_wraith> tiny_test, what happens if you disable implicit Prelude? 
14:01:53 <geekosaur> RebindableSyntax is a bit of a hack, actually
14:01:55 <hpc> is there anything like m4?
14:02:12 <texasmynsted> there is m4
14:02:15 <monochrom> MI5 is like m4
14:02:25 <texasmynsted> mi5?
14:02:29 <tiny_test> c_wraith: it works @_@
14:02:29 <hpc> dnl james bond
14:02:52 <texasmynsted> like military intelligence, mi5? 
14:02:53 <monochrom> to see how: MI5, replace "5" by Roman "V", MIV. But then IV is 4.
14:02:59 <buttons840> how can I monitor the memory and cpu usage of a process in haskell?
14:03:24 <c_wraith> tiny_test, the impression I get is that rebindable syntax works way better with the implicit Prelude disabled. 
14:03:27 <verement> monochrom: well done
14:03:47 <hpc> buttons840: as you would in any other language, i expect
14:03:47 <c_wraith> tiny_test, not that I've seriously used either. 
14:04:00 * geekosaur suggests: echo 'main = print [1..3]
14:04:02 <geekosaur> er
14:04:03 <twanvl> looking at the docs for RebindableSyntax, enumFromTo is not actually mentioned there (https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#rebindable-syntax)
14:04:10 <tiny_test> c_wraith: in this case it seems like it's not working even with NoImplicitPrelude
14:04:12 * geekosaur suggests: echo 'main = print [1..3]' >foo.hs; ghc -ddump-ds foo.hs
14:04:17 <hpc> i don't know of any libraries specifically for it in any language, you'll just need to IO it yourself
14:04:30 <buttons840> hpc: in python i would install a library with an easy to use api and documentation -- any haskell libraries i should look at?
14:04:31 <dolio> Can't you use m4 to preprocess Haskell?
14:04:56 <geekosaur> which features:    (enumFromTo @ Integer GHC.Enum.$fEnumInteger (__integer 1) (__integer 3))
14:05:41 <geekosaur> dolio, at minimum I htink you need a wrapper to satisfy ghc's expectations of what options and parameters a preprocessor should take
14:06:31 <tiny_test> OK so RebindableSyntax is a hack and doesn't allow overriding every desugared syntax
14:06:47 <hpc> geekosaur: what's that '$' there?
14:07:00 <hpc> is it like MagicHash?
14:07:32 <geekosaur> iirc names $fSomething are the names ghc uses for its generated typeclass dictionaries
14:07:37 <geekosaur> so yes, MagicHash-like
14:07:42 <hpc> ah, cool
14:08:08 <Peaker> buttons840, ekg is pretty cool (http://blog.johantibell.com/2011/12/remotely-monitor-any-haskell.html)
14:08:29 <geekosaur> also I suspect I could have found a compile flag that dumps before typeclasses get desugared to dictionary passing
14:09:59 <buttons840> Peaker: that's the best place to start I've seen, but it looks to heavy weight: i want to monitor the memory and cpu usage of a subprocess, I don't need to use the network
14:10:33 <geekosaur> mm, actually it looks like not
14:10:51 <geekosaur> ds pass does both of them
14:11:37 <jle`> oh neat, ghc 8.0 finally has the Monad instance for (,) w
14:12:23 <Peaker> buttons840, don't know such APIs then -- perhaps something needs to be bound with FFI
14:14:10 <buttons840> Peaker: yeah, I'm sure there are OS level calls to answer these questions, but I'm not familiar with them -- if no such thing exists in haskell that's fine, at least I know now, I'll look at how ekg does it; thank you
14:14:36 <Peaker> buttons840, I don't think it does it for children
14:14:37 <jacereda`> given a record containing subrecords, how would you implement something like 'showField :: (Data a) -> a -> [String] -> String', used like 'showField root ["rootFoo", "fooBar", "barBaz"]' ?
14:14:43 <Peaker> buttons840, it gets GHC stats, not sure what else
14:15:09 <geekosaur> at the OS level there is getrusage(2) but it won't know anything about e.g. ghc heap stats
14:15:22 <geekosaur> (POSIX; Windows has its own tools)
14:15:29 <jacereda> I'm aware of SYB's gshow, but I was looking for alternatives
14:15:55 <buttons840> well, the subprocess i want to monitor isn't necissarily haskell, so OS level stats are fine
14:16:14 <geekosaur> in fact, on Windows just go to sysinternals and get process explorer
14:16:59 <buttons840> i'm trying to create a glorified cron as a learning project, I want to be able to run custom system commands on a schedule and then see stats about what they did and monitor them in real time
14:17:52 <buttons840> it sounds like I'll have to do some FFI to the OS, if anyone has a better idea let me know
14:19:07 <geekosaur> unfortunately there's a large gap between getrusage()-level and the next level, which is ptrace() or /proc level stuff and usually means implementing most of the guts of a debugger in your monitoring app
14:19:22 <geekosaur> ...or punting it to gdb/lldb/whatever
14:20:31 <jacereda`> buttons840: do you know ETW?
14:27:52 <buttons840> jacereda`: no, what is that?
14:29:36 <jacereda`> buttons840: https://blogs.msdn.microsoft.com/ntdebugging/2009/08/27/part-1-etw-introduction-and-overview/
14:31:49 <buttons840> https://pypi.python.org/pypi/psutil i was hoping something like Python's psutil would exist in haskell; this is somewhat unfamiliar teritory for me, but I think we might be talking about different levels of granularity, I'm looking for status that could probably all be provided by `ps` at the command line
14:33:05 <buttons840> i would be interested in building a similar library in haskell
14:34:16 <geekosaur> that's just stuff in /proc
14:37:18 <puregreen> dfeuer: is there any way to avoid extra comparisons in this deleteAt? (once we have found a matching index, we don't have to do comparisons anymore, right?) http://lpaste.net/163824
14:38:40 <dfeuer> puregreen, I don't understand what that code is doing at all.
14:38:58 <dfeuer> What is it for?
14:39:15 <puregreen> deleteAt :: Int -> [a] -> [a]  -- delete an element at the index
14:40:02 <puregreen> here's a version without RULEs: http://lpaste.net/163825
14:40:55 <dfeuer> puregreen, similar functions that "drop" things from a list preserving some tail tend to have performance problems when implemented with folds. I'm not really sure why, but I gather there's some semi-deep reason for it.
14:41:16 <dfeuer> It may work great in some cases, but then be cruddy in others.
14:42:58 <puregreen> hm-m. Is there any place I could read about it? (or example benchmarks, or anything like that)
14:43:29 <puregreen> (and by the way, sorry that I'm bothering you with fusion-related stuff! I just noticed that you were writing optimised versions of functions in Data.Sequence at al. and thought that you'd be able to answer the questions easily. If it's bothersome, I'll be asking #haskell instead :)
14:47:26 <geekosaur> (you already are)
14:48:12 <puregreen> (well, when I'm addressing dfeuer directly I expect that many people would just gloss over the question even if it's asked publicly)
15:08:12 <glguy> ((we need to go deeper))
15:13:55 <buttons840> if I have a ProcessHandle from System.Process, can I get the pid of that process?
15:16:07 <monochrom> have you looked at the doc of System.Process.Internals?
15:16:55 <glguy> If you dive into internals you'll lose portability
15:17:00 <glguy> in this case in particular
15:17:32 <monochrom> true, I don't know the Windows story
15:19:23 <geekosaur> buttons840 is looking for rusage information. portability is already lost
15:19:54 <geekosaur> (even POSIX-ish getrusage is dubiously portable as many OSes / versions of those OSes/kernels only implement part of it)
15:20:58 <monochrom> we have to go deeper and splitter. use System.Process.Internals, but have a lot of #ifdefs for both the unix kind of System.Process.Internals and the Windows kind of System.Process.Internals
15:21:05 <buttons840> geekosaur: I see the ProcessHandle contains an Int32 a few layers down
15:21:22 <buttons840> geekosaur: sorry, that wasn't directed at you specifically
15:21:26 <geekosaur> it might however make more sense to just use System.Posix.Process
15:22:11 <geekosaur> since System.Process does a fair amount of DWIMmery and that tends to mean nasty surprises when you need more control
15:22:51 <monochrom> I use naïve statistics to justify prioritizing the unix side. I use ubuntu. I have two sisters, one uses macosx, the other uses windows. unix is the clear majority :)
15:26:33 <buttons840> glguy: when you say i'd lose portability; do you mean my haskell code wouldn't work with other haskell compilers?
15:26:47 <glguy> different OSs
15:27:07 <glguy> but it sounds like that doesn't matter here
15:27:23 <buttons840> maybe
15:27:27 <geekosaur> glguy was worrying about windows portability. you already lost that, though, if this is related to your request for process stats/resource usage; that is inherently nonportable and gets worse the deeper you dig
15:27:44 <buttons840> System.Process.Internals is only applicable to unix or what?
15:28:05 <geekosaur> there's a completely different System.Process.Internals for Unix vs. Win32
15:28:26 <geekosaur> (the online references will only show yu the Unix one because doc building is done as part of a test compile and the compile farm is Linux)
15:28:36 <buttons840> geekosaur: i see
15:28:51 <geekosaur> (specifically, it has to catch the typechecker output from a compile to build the docs)
15:28:54 <monochrom> this is why you read docs locally, not from the Internet.
15:31:05 <EvanR> dependent docs
15:31:38 <geekosaur> especially for an internals module for something like process control, the internal types are going to be completely different; a windows process handle is not a POSIX pid
15:46:27 <dd21> I'm copying code out of a book and ghci won't accept it on load no matter what I try.  Does anyone know what I'm doing wrong? http://pastebin.com/Xf6DmAvA
15:47:00 <glguy> dd21: sideArea and topArea don't appear to line up
15:47:28 <glguy> (and they should)
15:47:50 <monochrom> in fact, that is also exactly what the compiler sees: misalignment
15:47:53 <dd21> glguy: I'm using Komodo edit and they line up guess it's time to switch editors
15:48:11 <geekosaur> tabs are unreliable
15:48:14 <monochrom> the compiler sees what a pastebin sees (pastebins are honest). most editors lie.
15:48:15 <mikail_> Hi, is stream-fusion already in 7.10.3?
15:49:00 * geekosaur is not sure how to answer that question
15:49:09 <monochrom> stream fusion is coded or not coded in libraries, not in the compiler
15:49:17 <dd21> any top recommended that lie the least?  I use Sublime Text on the other comp is it more reliable?
15:49:30 <dd21> or is it really just down to setting tabs/spaces correctly?
15:49:38 <monochrom> in fact list fusion is, too. unless list comprehension is involved.
15:49:39 <mikail_> sorry I meant in the Prelude
15:50:35 <monochrom> the most honest editor is ed. but you won't like it.
15:50:45 <geekosaur> dd21, any editor will be reliable if you configure it to convert tabs to spaces. otherwise, tabs should go to the column that is the next multiple of 8 (0-based)
15:50:52 <monochrom> so it's just setting the editor to be honest. (defaults lie.)
15:51:26 <geekosaur> most editors can be configures to convert their idea of a tab to an appropriate number of speces, specifically because there is no real agreement on what a "tab" is in general
15:51:32 <mikail_> I tried to bring the library into my stack project but getting problems:         Ambiguous occurrence ‘MonadPlus’         It could refer to either ‘Control.Monad.Stream.MonadPlus’,                                  defined at Control/Monad/Stream.hs:124:1                               or ‘GHC.Base.MonadPlus’,                                  imported from ‘GHC.Base’ at Control/Monad/Stream.hs:80:1-15      
15:51:37 <dd21> Ok, thanks for the input.
15:51:43 <monochrom> list fusion is coded in a lot of "RULES" pragmas in Data.List
15:52:49 <geekosaur> mikail_, that says nothing abotu whether stream fusion is around or not, it means you have two things named MonadPlus in the same scope
15:53:15 <geekosaur> MonadPlus is not specific to whatever stream package you are working with, it has been in Haskell for several decades
15:53:18 <mgsloan> mikail_: That project hasn't been updated in 4 years, it probably doesn't work with newer base
15:54:11 <barrucadu> mikail_: stream-fusion defines its own MonadPlus, which is different to the standard one.
15:54:15 <mikail_> ok thanks - it's just that I coded this simulation program and it is running very slowly so I thought I could try to optimise it by using stream-fusion
15:54:16 <geekosaur> (and hayoo tells me that "stream-fusion" here is the name of a package, not the concept that is usually discussed)
15:54:32 <geekosaur> oh
15:54:38 <geekosaur> it won't help you
15:54:55 <geekosaur> thjat package was the testbed for list fusion. that is now in the standard libraries, yes
15:55:05 <mikail_> oh right
15:55:09 <geekosaur> and in fact a bit more advanced since then
15:55:43 <mikail_> can someone point me in the right direction on how to profile a haskell program?
15:55:55 <mikail_> website/tutorial etc
15:56:07 <geekosaur> (and these days we distinguish between list fusion and fusion of various other kinds of streams --- which will be dependent on the kind of stream you're working with)
15:57:00 <mikail_> i've written a monte carlo simulator - it works but it is very slow so I am looking to speed it up
15:57:37 <mikail_> the first thing I came across via googling was stream fusion
15:57:51 <geekosaur> https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/profiling.html is the main reference
15:58:30 <mikail_> that looks great - thank you
15:59:19 <mgsloan> Note with stack you pretty much just do "stack build --profile"
15:59:36 <mgsloan> It'll also run tests and benchmarks with "+RTS -p"
15:59:45 <mikail_> great
16:12:06 <JustinHitla> http://stackoverflow.com/questions/6964392/speed-comparison-with-project-euler-c-vs-python-vs-erlang-vs-haskell
16:14:57 <JustinHitla> wrong channel I guess
16:15:15 <Welkin> Love Hina Hitler?
16:15:25 <Welkin> a superluminal anime hitler?
16:16:44 <verement> why is `rem` faster than `mod`?
16:19:10 <kadoban> verement: One is probably exactly the crappy x86 instruction and one is probably not.
16:21:42 <puregreen> what's the rationale for Data.Map.adjust having the argument order “function → key → map →” and not “key → function → map →”?
16:21:52 <Tehnix_> verement: they are also a bit different - you might be interested in https://wiki.haskell.org/Haskell_programming_tips#Forget_about_quot_and_rem and http://stackoverflow.com/a/28027235/701940
16:27:00 <Welkin> puregreen: for partial application
16:27:13 <Welkin> most likely
16:49:41 <dusan> Hi. If my type is an instance of ToJSON class, I can use Data.Aeson and Data.Yaml to encode it to JSON and YAML respectively. Is there any library out there that accepts a ToJSON instance and outputs XML?
16:52:46 <c_wraith> you could write one in like 20 lines if there isn't. :) 
16:53:49 <c_wraith> unless you try to go crazy with stemming when trying to figure out how to represent arrays in xml
16:53:58 * hackagebot sifflet 2.3.0 - Simple, visual, functional language for learning about recursion.  https://hackage.haskell.org/package/sifflet-2.3.0 (GregoryWeber)
16:55:09 <dusan> well, i guess something like: type called X, array of X is <xs> </xs> with <x /> inside 
16:55:37 <c_wraith> see, then you're getting into linguistic analysis, and.. ewww. :) 
16:57:10 <dusan> so what would be a sane choice there?
16:57:25 <dusan> also, is there a reason why no such library exists?
16:57:53 <c_wraith> my best answer is "don't use xml", as far as sane choices. if it's an option. 
16:58:32 <Welkin> hahaha
16:58:38 <c_wraith> and I suspect that if no such library exists, it's because potential authors agree that "don't use xml" is the best choice. 
16:58:41 <Welkin> someone who wants to use xml?
16:59:34 <Rotaerk> is there an appropriate forum for discussing/suggesting changes to packages?  the package maintainer doesn't seem particularly keen on discussing directly through email
16:59:55 <johnw> GitHub tickets perhaps?
17:00:06 <Rotaerk> hmm k
17:00:22 <Welkin> Rotaerk: pitch it to Oprah and get on her show
17:00:37 <Rotaerk> good idea Welkin; I'll try that
17:00:40 <Rotaerk> >_>
17:05:04 <Rotaerk> hmm, though I guess I may as well give up at trying to convince Snoyman to change his host names from ByteString to Text
17:05:21 <Rotaerk> seems dead set on the notion that semantically host names are bytes
17:06:35 <sm> yeah, that is likely to be a tough argument to win
17:07:06 <sm> Rotaerk: got a link ?
17:08:41 <toph> can anyone shed some light on how `retry` for STM transactions works? it doesn't take any arguments, how does it get the transaction to re-run? some kind of continuation?
17:09:50 <Rotaerk> sm, I'll link the last email I sent, which he didn't respond to, but it represents my best understanding of things after all the reading and conversation I'd done on the subject after I ran into the issue, and an argument for why I think it should be Text/String
17:09:58 <sm> https://en.wikipedia.org/wiki/Internationalized_domain_name seems to back him up
17:10:28 <sm> I was just curious which lib/API you were talking about
17:11:37 <sm> I would thing that package's issue tracker would be the best place, the discussion will move visible and long-lasting
17:11:55 <Ohso_> Hello.   How would I go about creating something that behaves like an Int, but is a distinct type?
17:11:57 <sm> s/move/be more/,  sheesh
17:12:08 <Rotaerk> sm, the package I'm talking about is conduit, particularly the network parts of it
17:12:26 <Rotaerk> http-conduit package, as well as the network-conduit-tls
17:12:37 <Rotaerk> and here's my argument: http://lpaste.net/3281108418596700160
17:12:45 <Welkin> just use pipes
17:12:47 <Welkin> problem solved :D
17:12:55 <Welkin> I like pipes better than conduit
17:13:00 <zennist> how can I convert a `f (FreeT f m a)` to `FreeT f m a`?
17:13:18 <zennist> I know I can do `FreeT . return . Free`, but is there any function around?
17:15:16 <Rotaerk> does someone see a flaw in my understanding?
17:15:38 <Tehnix`> You can't do unicode in a bytestring?
17:15:55 <Tehnix`> (question, not a statement)
17:16:28 <Rotaerk> Tehnix`, a bytestring is a sequence of bytes.  unicode is a character set.  you can use a unicode encoding, such as UTF8, to convert a unicode string into bytes
17:16:58 <Tehnix`> Rotaerk: didn't a `pack` suffice with the conversion? IIRC that's all I usually need to convert it
17:17:06 <Rotaerk> but the consumer of those bytes must know to decode it using the same thing
17:17:42 <Rotaerk> Tehnix`, ByteString.Char8's pack?
17:17:48 <Tehnix`> ye
17:18:15 <Rotaerk> that's not appropriate if the target encoding is, say, UTF16
17:18:29 <Rotaerk> it's also a String -> ByteString conversion, but the results are different
17:18:54 <Rotaerk> the type signature of pack is correct, but it isn't necessarily appropriate
17:19:05 <pavonia> Char8.pack just silently truncates everything > 255
17:19:52 <Rotaerk> yea if the goal is to convert to ASCII, which seems to be the case according to RFC 20, then pack or encodeUtf8 work *IF* you first validate that the string only contains ASCII characters (i.e. 0-127)
17:20:25 <Rotaerk> in the case of hostnames, the character set is constrained further... must be alphanumerics, -, or .
17:21:12 <Tehnix`> if the valid hostname characters is a subset of the supported characters of ByteString, then I don't see any problem with the conversion
17:22:09 <Tehnix`> I mean, there is little purpose to support UTF-8 for hostnames, no?
17:22:29 <Rotaerk> UTF8 is equivalent to ASCII, for the characters in the ASCII set
17:22:46 <Rotaerk> for ASCII characters, encodeUtf8 and pack do the same thing
17:23:33 <Rotaerk> anyway, the main problem I have with the API is that I had to think about this at all
17:23:46 <Rotaerk> why did I have to worry about what encoding is needed according to the RFCs
17:23:53 <Rotaerk> that detail should be handled within the library...
17:23:58 <Tehnix`> I guess I'm arguing: if it only supports ASCII anyway, there is little point in having it a Text when ByteString is sufficient. Furthermore, ByteString is probably also what is used underneath, and instead of anything magically getting converted, it just accepts what is used
17:23:59 * hackagebot sscript 0.1.0.2 - Formats Strings with subscript or superscript characters  https://hackage.haskell.org/package/sscript-0.1.0.2 (capncanuck)
17:24:00 <Rotaerk> and the interface can just take a String or Text
17:25:03 <Tehnix`> I honestly don't think you needed to have read any RFC at all - have you run into any actual issues with having a random String/Text that would be a valid hostname, and having some problems with converting it to ByteString with pack?
17:25:23 <Rotaerk> Tehnix`, there are certainly valid IDN names that can't be converted with pack
17:25:39 <Rotaerk> but valid ... classic names should all work with pack
17:25:57 <Ohso_> I need a type that acts like a number (Int) but is distinct to prevent incorrect uses. Surely there's a way to do this?
17:26:01 <Tehnix`> Rotaerk: but if the lower layers also use ByteString, then at some point it still has to do the conversion
17:26:21 <Tehnix`> Would you rather this happened in a black-box kind of way, or that you were aware of the conversion?
17:26:21 <Rotaerk> Tehnix`, yes, ultimately it needs a ByteString; my point is that that's an implementation detail I shouldn't have to worry about
17:26:35 <Rotaerk> the packing/encoding is something I shouldn't have to research how to do
17:26:47 <Rotaerk> from the user's perspective, a host name is simply a string/text
17:26:54 <Rotaerk> and bytestrings aren't characters
17:27:02 <Rotaerk> they're just a sequence of 0-255 numbers
17:27:11 <Rotaerk> err numbers from 0-255
17:27:32 <MichaelBurge_> Is there an equivalent to $ at the type level? Like 'StateT MyState IO $ Maybe Int'
17:27:37 <Tehnix`> The alternative would be that the lib would use pack internally?
17:28:13 <Rotaerk> yes, exactly; I'm suggesting that it *should* do any packing/encoding that's needed
17:29:05 <Rotaerk> I am not a fan of the term 'pack', in this case, or the semantics of Data.ByteString.Char8; it's ambiguous)
17:29:49 <Rotaerk> it says that it treats the byte strings as being in the subset of Unicode covered by code-points 0-255, but it says nothing of the encoding used
17:30:04 <c_wraith> it doesn't use an encoding. 
17:30:23 <c_wraith> unless you count mod 256 as an encoding 
17:30:24 <Rotaerk> you can't get bytes from characters without encoding
17:31:13 <Rotaerk> even if it's a trivial encoding
17:31:36 <Rotaerk> ASCII is both a character set *and* an encoding, whereas Unicode is just a character set
17:31:46 <Rotaerk> and then UTF8, UTF16, etc are encodings for Unicode
17:32:28 <Rotaerk> the trivial encoding is to store the codepoint numbers directly into the bytes, one-to-one
17:32:34 <Rotaerk> like what ascii does
17:32:56 <c_wraith> well, I already told you want it does. 
17:33:09 <Rotaerk> which Char8 seems like it does, it just isn't explicit about the fact that this is what it's doing
17:33:27 <Rotaerk> i.e. it doesn't say that it stores the code points into the bytes
17:33:38 <Tehnix`> From ByteString: "Byte vectors are encoded as strict Word8" and from Word8 " Word8 is encoded in Latin-1 (ISO-8859-1)"
17:34:15 <geekosaur> and the missing link there is that Unicode defines the first 255 codepoints to be the same as ISO-8859-1
17:34:36 <Rotaerk> geekosaur, yes, but it's just the character set that it's talking about
17:34:40 <Rotaerk> not the encoding
17:34:47 <Rotaerk> since Unicode is just the former
17:35:33 <Rotaerk> Tehnix`, what do you mean? Word8 is just an 8-bit number;  ISO-8859-1 is a character set and a mapping from the character set to 8-bit numbers
17:35:43 <Rotaerk> Word8 is not inherently ISO-8859-1
17:35:52 <Rotaerk> Word8 is also used for, say, UTF8...
17:35:58 <geekosaur> oh, you're still on your pedantic kick. hate to tell you but thius stuff all comes from backward compatibilityt when programmers did not want to think about such things
17:36:14 <geekosaur> s/compatibilityt/compatibility to/
17:36:43 <geekosaur> so yes, it's all loosely specified and DWIM, not formal
17:37:09 <geekosaur> and more or less defined by "do older programs still work?"
17:37:14 <MichaelBurge_> Rotaerk: I always figured the Char8 modules were just for compatibility with old-school C code that passed around char* everywhere and didn't really care what the encoding was
17:37:19 <geekosaur> ^
17:37:24 <Rotaerk> so people discuss it sloppily/informally; that's fine I suppose; but I don't see why that means ByteString is appropriate as the type for host name
17:37:55 <MichaelBurge_> Rotaerk: It's appropriate if host name is being passed to one of the POSIX or kernel functions that demands a char* like you see in old-school C code.
17:38:12 <Rotaerk> MichaelBurge_, C chars are not characters, they're just bytes; the char *literals* are characters, but the numbers they map to depends on the encoding chosen by the compiler
17:38:25 <Rotaerk> most in practice use ASCII as the encoding
17:38:32 <Tehnix`> Rotaerk: I still think that answer goes back to: it's what's used underneath and it's not a good thing to magically convert encodings. Much like Python moved to Unicode and Byte conversions now being explicit rather than implicit
17:38:36 <Rotaerk> but byte doesn't automatically imply ASCII
17:39:05 <Rotaerk> i.e. 'A' == 65 isn't necessarily true in C
17:39:35 <pikhq> Though in practice nearly everything uses ASCII, and several common implementations use UTF-8 for everything.
17:39:49 <pikhq> (that said, I have seen EBCDIC C)
17:40:13 <Tehnix`> Rotaerk: but how would you, as a library maintainer, guarentee 100% that when people interfaced with your function that takes Text, that the conversion afterwards left everything intended as the user of the API wanted?
17:40:42 <Tehnix`> Mind you it still needs to do the conversion to ByteString at some point
17:40:54 <MichaelBurge_> Rotaerk: Which API specifically are you talking about that concerns you?
17:41:28 <Tehnix`> I guess I'm arguing for, that I'd personally rather that the conversion be explicit rather than implicit.
17:41:43 <Tehnix`> Not that all this string juggling doesn't get tedious <.<
17:42:05 <Rotaerk> Tehnix`, I think pretty much any user thinks of host names as something like "haskell.org", they don't think of it as a byte string, such as: 104-97-115-107-101-108-108-46-111-114-103
17:42:12 <jle`> is there any way to get the Zippy applicative for Data.Vector's vector?
17:42:33 <Rotaerk> Tehnix`, I don't see why you should have to provide the latter, i.e. a ByteString
17:42:35 <jle`> besides just writing a custom newtype wrapper?
17:42:39 <jle`> a one-off
17:42:40 <Tehnix`> Rotaerk: Data.ByteString.pack "haskell.org" ?
17:42:45 <Rotaerk> MichaelBurge_, conduit network
17:42:55 <Rotaerk> Tehnix`, that converts "haskell.org" into the numbers
17:42:57 <Tehnix`> Rotaerk: it most likely interfaces with a C library
17:43:10 <Tehnix`> Rotaerk: you *always* need bytes for network communication
17:43:17 <pavonia> Tehnix`: I think the point is that passing a Text value and letting the library do the proper encoding/decoding is more safe than relying on the user passing a properly encoded string of bytes
17:43:19 <Tehnix`> There is no "sending characters" there
17:43:36 <MichaelBurge_> Rotaerk: I knew someone who bought a chinese domain name, and whenever he wanted to tell people to visit it he'd say something like, "Oh go to shift-7, t,x, % . com" and it encoded to the chinese characters.
17:43:50 <Rotaerk> Tehnix`, what pavonia said is what I mean.  what if the user passed:  encodeUtf16 "haskell.org"
17:44:16 <Rotaerk> that will then be decoded as though it's ascii, and become something very different
17:44:18 <Tehnix`> Are DNS servers able to read UTF16?
17:44:43 <geekosaur> no
17:44:50 <Rotaerk> Tehnix`, but when using conduit-nework, you're not talking to DNS servers... you're talking to conduit-network
17:44:55 <Tehnix`> I guess its two viewpoints: "URLs are strings" and "Everything you do on the network is bytes"
17:45:00 <Rotaerk> there's no telling WHAT it's doing with the bytestring under the hood
17:45:02 <hpc> DNS can't do anything but ascii
17:45:07 <MichaelBurge_> Tehnix`: I think we concluded that it was stored using some simple set of characters, but it rendered as Chinese characters in the browser
17:45:11 <hpc> and you REALLY don't want to know how it encodes unicode
17:45:22 <pikhq> Punycode is kinda an amazing hack.
17:45:25 <hpc> it's one of the ugliest things i have ever seen
17:45:45 <Rotaerk> MichaelBurge_, the chinese domain name is probably IDN, which is converted to the classic hostname format first, before encoding to ascii
17:45:56 <Rotaerk> but I'm guessing you can also just refer to it directly as the ascii form
17:46:07 <mgsloan> Wut, punycode is terrifying
17:46:30 <Ohso_> ok, I'm giving up. There doesn't seem to be a way to do what I want. Can't find any examples via google.
17:46:31 <geekosaur> hpc, technically false; DNS labels can contain any octet except NUL, and de facto '.' because that's how labels get separated in their user-presented form. the spec even left room for expansion that could have been used with ISO8859-1 or UTF8
17:46:45 <MichaelBurge_> Oh yeah, I see a punycode converter. I think that was it.
17:46:46 <geekosaur> but the host requirements RFC stuck with ASCII
17:46:55 <Rotaerk> geekosaur, according to RFC 952, it's limited to letters, numbers, dots, and dashes
17:46:55 <Tehnix`> Ohso_: looked into newtypes?
17:46:57 <geekosaur> so now we have Punycode to map them down
17:47:10 <Tehnix`> Ohso_: (or probably more details on "behaves like an Int")
17:47:11 <Rotaerk> hostnames, that is
17:47:26 <geekosaur> that's the host requirements RFC, not the DNS protocol RFC
17:47:31 <Rotaerk> ah k
17:47:33 <Ohso_> yes, but can't figure out how to duplicate an existing numeric type in all but name.
17:47:41 <geekosaur> but I feel like we're rehashing the same thing all over again
17:47:44 <pikhq> RFC 1032 has the same requirement.
17:47:50 <MichaelBurge_> Rotaerk: See, that raises the question of what you want to do when you find a Chinese character in a Text value like I think you're proposing. Should it be automatically run through Punycode?
17:47:53 <geekosaur> and you still don't like the answer and ask again and again in hopes it will change
17:47:54 <Tehnix`> Ohso_: oh, so basically duplicating all the instances of it, etc?
17:48:19 <pikhq> RFC 1032 is a normative introduction to the Domain Name System.
17:48:39 <Rotaerk> MichaelBurge_, the API that takes text should specify whether it accepts a classic host name, or an IDN; if the former, simply fail if it contains chinese
17:48:57 <Ohso_> Yes, the type is to be used to indicate a memory address, but I wanted some type safety to prevent other numbers getting used as addresses.
17:48:57 <Rotaerk> geekosaur, I'm not asking the same thing over and over; I'm trying to pin down what the problem with my argument is
17:49:04 <Rotaerk> and so far I haven't heard anyone directly address it
17:49:17 <dolio> No one here is going to change the library you're using.
17:49:25 <Tehnix`> Ohso_: I guess you could make the type an instance of Num or something (http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Num.html#Num)
17:49:28 <Rotaerk> I'm not asking anyone here to do so, dolio 
17:49:28 <pikhq> RFC 1035, the implementation spec, merely says that the labels SHOULD be valid host names, though...
17:50:01 <Rotaerk> what exactly is a host name if not a superset of DNS names and IP addresses
17:50:12 <Tehnix`> Ohso_: and this one http://stackoverflow.com/questions/10645137/haskell-num-instance-of-non-concrete-type might also interest you
17:50:20 <pikhq> Rotaerk: "Host name" was a defined term prior to DNS existing.
17:50:27 <Rotaerk> "haskell.org" -- dns name; "192.168.1.1" -- ip address;  both are host names
17:50:38 <Tehnix`> Rotaerk: hostname is this context of networking is a URL
17:50:51 <Tehnix`> or, part of it rather
17:51:08 <Tehnix`> or... scracth that, that sounds a bit wrongly put
17:51:29 <pikhq> Before DNS, the host name syntax existed and the host name mappings were described in the HOSTS file which was distributed by Stanford.
17:52:00 <pikhq> DNS was replacing that, so it of course recommended you be compatible with the existing convention.
17:52:05 <Tehnix`> Rotaerk: with your proposal you've stepped into hostname sanitation and such, which should really not be the job os the networking library, but of some other library
17:52:06 <Rotaerk> k
17:52:07 <geekosaur> (hands up, who remembers SRI-NIC?)
17:52:47 <Rotaerk> Tehnix`, err, why shouldn't the network library validate its input?
17:53:21 <geekosaur> oh, and the hostname scheme we're now stuck with originated from the subset of ASCII representable in SIXBIT for DEC mainframes
17:53:28 <Rotaerk> Tehnix`, that's really an independent question though; you don't have to validate the host name, regardless of if you take Text or ByteString
17:53:45 <Tehnix`> Rotaerk: does it need to? that's not really the purpose of it, it just needs a byte string, and if you have some custom resolver that'll resolve that name it gets in whatever format, that is not something the library should worry about
17:53:49 <pikhq> geekosaur: Good ol' legacy requirements.
17:54:06 <Tehnix`> And also, I've literally never run into an issue with Data.ByteStrings pack not being a sufficient conversion
17:54:21 <Rotaerk> Tehnix`, have you ever used an IDN host name?
17:54:23 <Rotaerk> it wouldn't work then
17:54:26 <Tehnix`> Unless you are taking in arbitrary input in unspecified encodings
17:54:46 <Tehnix`> Rotaerk: I have not, no. Have you tested it with an IDN hostname?
17:55:08 <Rotaerk> Tehnix`, nope; but it wouldn't work since IDN host names contain characters outside the 0-255 range
17:55:21 <Rotaerk> you have to first convert from that to the ASCII representation
17:55:30 <Rotaerk> and then encode that using pack
17:55:32 <Tehnix`> I would have to try that before agreeing that it won't work
17:55:43 <Ohso_> Hmm, making an instance of Num looks to be a bit beyond what I can do just yet. I was hoping for something simple like "newtype Address = Address Int deriving(--magic stuff here--)".  I really thought that'd be a common use case. Oh well. :p
17:56:09 <Rotaerk> I really would just like to know what you lose by taking text instead of bytestring
17:56:23 <MichaelBurge_> Ohso_: Add a {-# LANGUAGE GeneralizedNewTypeDeriving #-} at the top of your file, then you can do 'deriving (Num)'.
17:56:40 <Tehnix`> Ahhhh, ofc, there's deriving num... <.<
17:57:13 <Rotaerk> it's going to have to be encoded either way; it's just a question of whether it's done inside the library or outside
17:57:43 <Rotaerk> and the reason you'd force it to be done outside is if there are things you can represent as raw byte strings that you can't represent as text
17:57:46 <Rotaerk> and there isn't
17:57:50 <geekosaur> Rotaerk, possibly if Punycode had already been a standard when these libraries and the libraries under them were being written, Text might have been considered.
17:57:56 <geekosaur> Punycode is very recent
17:58:24 <Rotaerk> punycode is irrelevant though; if you replaced ByteString with Text in these libraries, it would *still* just take the classic hostnames
17:58:48 <Rotaerk> you would still have to use something else to convert from IDNA to the classic format using punycode, in the calling code
17:58:50 <Ohso_> What does it mean that GeneralizedNewTypeDeriving is not safe? I've seen mention of some things in Haskell being safe and others not, but I don't pretend to understand what it's all about.
17:59:36 <Rotaerk> for IDN names, there are two conversions... Unicode -> ASCII character set, and then encode that to bytes
17:59:37 <Tehnix`> Rotaerk: there's a lib for that https://hackage.haskell.org/package/gnuidn-0.2.2/docs/Data-Text-IDN-IDNA.html
17:59:48 <johnw> Ohso_: it used to be somewhat broken, before 7.8
17:59:57 <Rotaerk> I'm only suggesting that the encoding to bytes should be captured within the implementation
18:00:22 <Rotaerk> it *could* take IDNs, and do the punycode internally, if it wanted to, but it should specify that in the docs
18:00:32 <Tehnix`> I'd rather that it focuses on its main job, and that the maintainer doesn't also need to worry about supporting IDNs all of the sudden
18:00:34 <dolio> Ohso_: It would allow you to write things that were not type sound.
18:00:46 <dolio> Similar to unsafeCoerce.
18:00:46 <Rotaerk> Tehnix`, yea, I'm inclined towards that as well
18:00:57 <Rotaerk> but the conversion to bytes should be their job
18:01:02 <geekosaur> Ohso_, that's a fairly complex question, but see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/roles.html
18:01:10 <Rotaerk> there's no benefit to making the user do it, because it leaves ambiguity as to HOW to convert to bytes
18:01:17 <Tehnix`> From the IDNA thing, it has `toASCII :: Flags -> Text -> Either Error ByteString`
18:01:46 <Ohso_> Hah, that's newer than the 7.6.3 included in Debian stable.  :P
18:01:50 <Tehnix`> I guess he could add that lib as a dependency, but that's not really something to take lightly in a minimal lib
18:01:57 <Rotaerk> Tehnix`, looks like that converts to ASCII *and* to bytes all in one step
18:02:16 <Rotaerk> https://hackage.haskell.org/package/idna-0.3.0/docs/Text-IDNA.html
18:02:22 <Rotaerk> this one does it differently
18:02:22 <Tehnix`> yep, which means it's ready for use with the conduit package :)
18:02:39 <Rotaerk> toASCII converts from Text to Text, as it should
18:03:19 <Tehnix`> Well, seeing as most packages use host names as ByteStrings (no?) then I'd rather have it converted to that, since it's gonna be in that representation anyways
18:03:34 <Rotaerk> it's conceptually incorrect though
18:03:51 <Tehnix`> That doesn't really matter unless they rewrite all the underlying libraries as well
18:04:17 <Rotaerk> and I have known how to use the existing library since before today's conversation; this has all been about criticism of the library's design, because it's design caused confusion when I first got to it
18:04:18 <Tehnix`> ....and even then it *still* needs to be converted to bytes before it can traverse the network
18:05:02 <Rotaerk> Tehnix`, it doesn't just need bytes...
18:05:03 <Ohso_> Thanks for the advice. I guess I'm going to do some reading before I move on with my project.
18:05:09 <Rotaerk> it needs bytes *in a particular encoding*
18:05:25 <Rotaerk> an implicit requirement not captured by the type signature, nor specified in the documentation
18:06:04 <Rotaerk> because if I use the wrong encoding, I get the wrong result
18:06:48 <Tehnix`> which is only relevant for the case of IDNA, which there is a library for the conversion 
18:07:44 <Rotaerk> Tehnix`, how is it just relevant for IDNA?  an ASCII string can still be encoded incorrectly
18:09:50 <Tehnix`> How is the library supposed to know if it's dealing with UTF-8, UTF-16, UTF-32?
18:09:56 <zRecursive> :t threadDelay
18:09:57 <lambdabot> Not in scope: ‘threadDelay’
18:10:04 <Tehnix`> From it's view, all it can ever know is that it has a Text type
18:10:07 <Tehnix`> its*
18:10:33 <zRecursive> :t Control.Concurrent.threadDelay
18:10:35 <lambdabot> Int -> IO ()
18:10:50 <Rotaerk> Tehnix`, UTF-8, UTF-16, UTF-32 are effectively functions of type:  Char -> ByteString
18:11:06 <Cale> (or at least Text -> ByteString)
18:11:12 <Tehnix`> ^ 
18:11:27 <Cale> Text is supposed to be encoding independent
18:11:47 <Tehnix`> Rotaerk: I cannot know how to handle the encoding of anything without inspecting the data and then trying to guess somehow
18:11:50 <Tehnix`> it*
18:12:01 <Rotaerk> Tehnix`, the library knows what encoding is needed, because it's a network library... so it's implemented with network specs in mind (e.g. the RFCs)
18:12:08 <Tehnix`> So, it leaves it to the user to encode it to a ByteString properly
18:12:14 <Rotaerk> so *it* should be responsible for encoding Text according to the appropriate one
18:12:27 <Tehnix`> Rotaerk: yes, it knows what is *needed* but not what is *supplied*
18:12:41 <Rotaerk> Tehnix`, it doesn't know what's supplied if it takes a ByteString
18:12:52 <Rotaerk> if it takes a Text, it doesn't need to know, because it's not already encoded
18:12:57 <Rotaerk> Text is pre-encoding
18:13:07 <Tehnix`> Yes it does - you just e.g. used `encodeUtf32BE` to get a `Text -> ByteString`
18:13:14 <mgsloan> (internally UTF16 ;) )
18:13:19 <Tehnix`> it doesn't need more than that, the rest just works
18:13:41 <Rotaerk> mgsloan, haskell's Char type as least is defined as unicode code points, not any specific encoding
18:13:49 <Rotaerk> not sure about Text, though
18:13:54 <mgsloan> Yes, Text is UTF16
18:14:11 <zRecursive> what does ' '"-with-rtsopts="-N" ' mean ?
18:14:35 <mgsloan> zRecursive: It means "Spin up as many hardware threads as I have CPUs" 
18:14:40 <Rotaerk> Tehnix`, if you take a bytestring, it could be the result of utf8, utf16, utf32, or made-up-encoding
18:15:08 <zRecursive> mgsloan: then N can be specified explicitly ?
18:15:20 <mgsloan> Yup, "-N2" or whatnot
18:15:30 <zRecursive> ths
18:15:35 <zRecursive> thanks
18:15:39 <Tehnix`> If you do `let a = encodeUtf8 "hey"` and then `decodeUtf8 a` you have the same exact string again
18:15:49 <geekosaur> at some point, the answer to this is going to come down to "that's what they decided to do"
18:16:15 <geekosaur> and likely "if you don't like it, write your own that does it the way you think it should work"
18:16:27 <Rotaerk> Tehnix`, if the library expects ascii, it may use decodeUtf8 on the provided bytestring.  how does it know that you used encodeUtf8?
18:16:38 <Rotaerk> geekosaur, yea if it comes down to that, I'll just accept the way it is
18:16:47 <Tehnix`> Not really - it's a very valid point that the underlying representation is a ByteString, and the library has no way of know what encoding you are using (that information is not in the type), so it leaves it to the user to convert it properly
18:16:48 <Rotaerk> and/or write my own >_>
18:17:16 <Rotaerk> Tehnix`, the encoding is not arbitrary; the library requires it to be ASCII encoded
18:17:17 <Tehnix`> Rotaerk: it won't do a decodeUTF8? It'll just hand you a ByteString back
18:18:33 <Rotaerk> Tehnix`, "the library" is the conduit-network library which takes a ByteString as a parameter, with the implicit expectation that it's ASCII
18:18:52 <Rotaerk> yet it doesn't tell you that in the documentation, so the user might do encodeUtf32
18:18:55 <Rotaerk> which is simply wrong
18:19:10 <mgsloan> Dunno if this is relevant, but descending into pedantry, Text actually does not wrap something compatible with ByteString.  It uses a Array, which wraps a ByteArray#, whereas ByteString is based on ForeignPtr.  The difference is that Text values get moved around by the Haskell GC whereas ByteString values do not
18:19:20 <geekosaur> and a lot of this is straight-up "that's how it's always been done", not "how should we do this right?"
18:19:51 <geekosaur> yes., there's an assumption ByteString gets used with C/FFI a lot and Text doesn't
18:19:55 <Tehnix`> Rotaerk: have you actually tried testing it?
18:20:19 <Tehnix`> (I don't have any short test using Network.Data.Conduit lying around unfortunately)
18:20:54 <Rotaerk> geekosaur, well, the "it's always been done this way" is frustrating to someone who wasn't around when it was done that way, and can only rely on specifications/documentation/standards
18:20:54 <Tehnix`> 1) Have a valid hostname 2) Convert it to bytestring with encodeUTF8 3) check if it still works... etc
18:21:30 <pavonia> Tehnix`: You can pass it an arbitrarily encoded text, it can't know all of the encodings out there
18:21:38 <Rotaerk> Tehnix`, yes, of course that works, because encodeUtf8 produces ASCII-encoded characters (for the subset of characters that are allowed)
18:21:56 <Rotaerk> Tehnix`, the problem is that, looking at the API, I don't know I'm supposed to use encodeUtf8
18:22:04 <Rotaerk> I might guess encodeUtf16 or something
18:22:18 <Rotaerk> or worse, something that's almost right but not quite
18:22:19 <Tehnix`> Rotaerk: how else would you convert your UTF-8 string to a ByteString?
18:22:34 <Rotaerk> Tehnix`, there's no such thing as a "UTF8 string"
18:22:38 <Tehnix`> You could also use encodeUtf16, if you had a UTF-16 string to begin with
18:22:44 <Tehnix`> UTF-8 encoded string...
18:22:50 <Tehnix`> You get the point
18:23:46 <Rotaerk> Tehnix`, encodeUtf16 is not used on a UTF-16 string.  it's used on a string (Text), which encodes it to UTF-16
18:23:52 <Rotaerk> the string doesn't start out UTF-16
18:23:57 <Rotaerk> it starts out encoding-agnostic
18:24:01 * hackagebot cron 0.4.1 - Cron datatypes and Attoparsec parser  https://hackage.haskell.org/package/cron-0.4.1 (MichaelXavier)
18:24:08 <Rotaerk> (even if Text may be under the hood represented as UTF16)
18:24:15 <Tehnix`> ahhh, yeah sorry
18:24:49 <Rotaerk> Tehnix`, the problem is that I don't know which encoding I need to use, so I have to figure it out by reading RFCs, talking to people about it, etc
18:25:03 <Rotaerk> if it simply took Text ... I wouldn't have to care
18:25:23 <Rotaerk> like most other sane libraries do
18:26:04 <Tehnix`> Ugh, I was about to test with https://hackage.haskell.org/package/http-conduit-2.1.10.1/docs/Network-HTTP-Conduit.html .... but it just takes in a String <.<
18:26:21 <mgsloan> String is isomorphic to Text
18:26:38 <mgsloan> (especially lazy Text ;) )
18:26:39 <dolio> I don't think that's true.
18:26:45 <mgsloan> Really??
18:26:49 <geekosaur> apparently Tetx is now to be considered The Blessed String-Like Type. stop the presses, rewrite all the libraries
18:27:02 <dolio> I think String has too many things.
18:27:26 <mgsloan> Yeah, Text is quite nice.  I do wonder whether UTF-16 is a good choice though
18:27:35 <dolio> Perhaps not, I'm not 100% sure.
18:27:41 <mgsloan> It reminds me of the decision the binary library makes to use big endian encoding
18:28:16 <Tehnix`> Rotaerk: Digging a bit, the conduit package uses parseURL from Network.HTTP.Client, which just does a Data.ByteString.Char8.pack on the string (after having done slight validation)
18:28:17 <Rotaerk> the idea that Text is a better replacement for String suggests that libraries could be improved going forward by using Text instead... but the idea of exposing ByteString instead of String/Text is an inherent design issue (IMO) regardless of improvements to the language/ecosystem
18:28:19 <mgsloan> Most content we deal with seems to be utf-8 encoded.  Could save a lot of overhead by making 'encodeUtf8' / 'decodeUtf8' O(1) or an O(n) memcpy
18:28:32 <Tehnix`> Which means, have a string? Convert it to a ByteString and done
18:28:50 <Tehnix`> But, anywho, I reeeeally gotta bounce, it's 03:28 by now already <.<
18:28:55 <Rotaerk> Tehnix`, lol, "convert to byte string" is ambiguous though
18:29:09 <mgsloan> I think the UTF-16 choice made sense for some of the algorithms themselves, but real world appplications would probably benefit from UTF8
18:29:12 <Rotaerk> there are many ways of doing that, each with different resulting byte strings
18:29:16 <Rotaerk> anyway, good night, Tehnix` 
18:29:29 <dolio> Someone tried it, and it didn't.
18:29:39 <mgsloan> On some applications.
18:29:44 <mgsloan> That's interesting, though!
18:29:46 <Tehnix`> I'm asusming the String implementation and the Text implementation always internally use the same encoding, so converting from String -> ByteString would always yield the same result, no?
18:30:13 <mgsloan> No, String uses [Char], and Char is basically UTF32
18:30:15 <Rotaerk> Tehnix`, internal encoding is irrelevant; it's only relevant to the implementations of the encode/decode functions written in terms of those types
18:30:17 <Tehnix`> (not that String and Text use the same, just that they have *a* encoding each)
18:30:20 <pavonia> Expecting a String parameter and using Char8.pack for internal conversion is even worse than having a ByteString parameter in the first place
18:30:55 <Tehnix`> But yeah, nigths! :)
18:31:10 <Rotaerk> you don't need to think of Text as UTF16-encoded; just think of it as an un-encoded string limited to the subset of Unicode that *can* be encoded with UTF-16
18:31:19 <Rotaerk> "encoded" strings are ByteStrings
18:31:26 <mgsloan> Yup, it is definitely better to think of Text as abstract unicode
18:31:39 <mgsloan> You can only see that it is UTF16 via the internal APIs
18:32:07 <mgsloan> Wait wait, UTF-16 is a subset?  Not as far as I know
18:32:14 <Rotaerk> I am hedging for ignorance
18:32:18 <mgsloan> Ah
18:32:23 <Rotaerk> I don't know if it is or not
18:32:34 <mgsloan> Yeah, the encodings all work for the full unicode set
18:32:38 <Rotaerk> k
18:33:22 <verement> UTF-16 can't encode surrogate code points
18:33:41 <verement> whereas e.g. [Char] can
18:34:38 <mgsloan> UTF-16 uses surrogate code points in its encoding, so I don't think that's correct.
18:34:47 <Rotaerk> anyway, I still haven't seen any arguments for why I'm wrong; I still think String or Text would've been better for the interfaces of those libraries; but....
18:35:05 <Rotaerk> I think I'm just going to give up
18:35:16 <Rotaerk> not likely to be changed anyway
18:35:20 <verement> mgsloan: exactly because it uses surrogates in the encoding, it can't encode them
18:35:21 * mgsloan hasn't even followed the debate XD
18:35:32 <verement> Rotaerk: I don't think you're wrong
18:35:38 <mgsloan> verement: Ahh gotcha, but they should be isomorphic when interpreted as uncicode
18:36:39 <mgsloan> That is indeed a case where [Char] has more discernable values for a unicode string than Text, though 
18:42:20 <hpc> "Isolated surrogate code points have no general interpretation; consequently, no character code charts or names lists are provided for this range. In the Python programming language, individual surrogate codes are used to embed undecodable bytes in Unicode strings"
18:42:30 <hpc> so it doesn't usually matter
18:44:12 <geekosaur> Rotaerk, pretty much every network API is in one way or another based on the original 4BSD network APIs --- from a time when programmers got whiny if you made them think about ISO8859, and Unicode didn't even exist. and those APIs have been duplicated and extended upon without changing their basic nature because that was what everyone else did.
18:44:23 <hpc> oh wait, that's UCS
18:44:46 <hpc> UTF-16's surrogates are bit fields, not codepoints
18:44:53 <geekosaur> *Maybe* you can start a revolution and modernize the basis of network APIs. I wouldn't hold my breath though; laziness usually wins when it comes to programmers
18:45:25 <geekosaur> and I don't mean Haskell-style laziness
18:45:27 <hpc> multiple surrogates represent a character in the supplementary planes, and correct support is required for a UTF-16 implementation to be correct
18:46:23 <hpc> so there's not really a concept of surrogates in unicode other than "you are now using more memory"
18:47:02 <hpc> and Text and Char both support the same range
18:47:07 <hpc> which is to say, all of it
18:48:06 <mgsloan> dolio: So is Text iso to String?
18:48:28 <dolio> Not if what people have been saying about surrogate codepoints is true.
18:48:52 <mgsloan> Ja, and I only just saw that you said not 100% sure about it
18:49:16 <dolio> Yeah, I don't understand the intricacies of unicode that well.
18:49:22 <mgsloan> I think the conclusion is effectively iso, would be curious if there were observable differences
18:49:25 <mgsloan> Me either
18:49:29 <dolio> Nor remember all the technical definitions of everything.
18:52:20 <verement> lambdabot doesn't seem to import Data.Text, or I would show an example
18:52:22 <nshepperd_> I think I would personally treat surrogate codepoints as illegal reserved values and be done with it
18:52:57 <mgsloan> They can be handy for "decodeUtf8Lenient"
18:53:11 <nshepperd_> since the only time you should see them is when you're writing a utf-16 decoder
18:53:33 <mgsloan> Err maybe I'm wrong about it being useful for that
18:53:59 <verement> Surrogates aren't legal Unicode characters; they exist only to support the UTF-16 encoding. The fact that they are allowed in Char I think was a compromise for pragmatism.
18:54:08 <mgsloan> Yeah, "decodeUtf8Lenient" just uses a dummy char for undecodable stuff
18:55:09 <mgsloan> Well I'm glad #haskell can put together how unicode works ^_^
18:55:23 <mgsloan> (roughly speaking)
18:57:13 <dolio> At some point unicode came up before, and I went and looked at all the specs for the UTF encodings and other stuff, and if you read those, I think it becomes clear that lists of codepoints don't exactly line up with UTF-N strings (even relaxing them to infinite versions) in possibly multiple ways.
18:57:25 <dolio> But I forgot all the details.
18:57:58 <Rotaerk> geekosaur, yea, I'll give up at trying to fight history; if I ever make my own library, I'll do it my way, but I'll just put up with the existing libraries the way they are
18:58:31 <mgsloan> Yeah, there's that stuff that lets you combine multiple codepoints into one symbol and such
18:58:38 <mgsloan> (or at least add various annotations)
18:58:43 <mgsloan> Gets messy real quick
18:59:30 <dolio> Yeah. Like, even if they represented 'the same strings,' it might actually be impossible to write an isomorphism.
18:59:56 <dolio> Because going through one of the encodings turns two codepoints into one equivalent codepoint or something.
19:00:04 <dolio> And not necessarily just surrogates.
19:00:09 <dolio> But I don't remember.
19:00:14 <verement> you're talking about normal forms
19:01:31 <verement> probably getting off-topic for #haskell
19:03:59 <Myrl-saki> I should really make a "Days since last map/fmap confusion."
19:04:20 <mgsloan> "Days since monad was defined metaphorically"
19:04:28 <zRecursive> cabal on windows seems still having encode probelm. If LC_ALL is set to "*.UTF8", `cabal configure` will report "byte error". But when LC_ALL="", all works.
19:05:36 <Myrl-saki> Hmmm
19:05:55 <Myrl-saki> Man. Type juggling is hard.
19:06:40 <Rotaerk> does "monads are like monads" count as metaphorical
19:07:10 <Myrl-saki> I'm quite tempted to just fromJust this... lol
19:07:10 <mgsloan> Only if the 2nd monads isn't haskell monads :)
19:07:35 <mgsloan> Because it's certainly true that haskell's Monad isn't quite the same as categorical monads
19:07:54 <dolio> No, it never counts as metaphorical. Because it was a simile.
19:08:05 <Myrl-saki> monads are monads then.
19:08:08 <Rotaerk> >_>
19:09:00 <Myrl-saki> This might sound stupid, but how do I use Maybe values in MaybeT?
19:09:04 <mgsloan> dolio: similes `isSubsetOf` metaphors
19:10:02 <Myrl-saki> This is what I have so far. http://ix.io/G4T
19:10:07 <nitrix> 22:14:17         Rotaerk | >_>
19:10:08 <nitrix> >=>
19:10:15 <Myrl-saki> getInfo :: IO (Maybe n)
19:10:18 <kadoban> Myrl-saki: So you have a Maybe a  and you want a  MaybeT m a  or whatever?
19:10:51 <Myrl-saki> kadoban: Yeah.
19:10:55 <nitrix> :t runMaybeT
19:10:56 <lambdabot> Not in scope: ‘runMaybeT’
19:11:11 <kadoban> Isn't that just 'pure' or am I confuzzed?
19:11:23 <Myrl-saki> kadoban: I'm thinking of putting all these in MaybeT
19:11:25 <Myrl-saki> :t pure
19:11:27 <lambdabot> Applicative f => a -> f a
19:11:33 <Myrl-saki> Hmm
19:11:54 <kadoban> Er wait that's missing a wrapper *looks up the types*
19:11:59 <nitrix> Myrl-saki: runMaybeT :: MaybeT m a -> m (Maybe a)
19:12:07 <Myrl-saki> nitrix: Right.
19:12:24 <nitrix> Then you use the m as a monad/applicative/functor, whatever.
19:12:43 <Myrl-saki> Basically, what I want to do is... get x. parse x. get n from x, repeat next action n times.
19:13:23 <MichaelBurge_> Is inet_ntoa in Network.Socket safe to wrap an unsafePerformIO around?
19:13:26 <Myrl-saki> I was thinking of encapsulating everything in a runMaybeT, since all of them have types :: IO (Maybe a)
19:13:34 <nitrix> :t replicateM
19:13:36 <lambdabot> Monad m => Int -> m a -> m [a]
19:13:43 <Myrl-saki> :t lift
19:13:45 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
19:13:50 <Myrl-saki> Yeah... I'm stupid.
19:14:11 <Myrl-saki> Okay... back to the drawing board.
19:14:22 <nitrix> If they are all IO (Maybe a), yeah it'd make sense.
19:15:21 <nitrix> It's easier to chain/compose the operations (>>= and >=>).
19:16:03 <geekosaur> MichaelBurge_, theoretically. in practice it depends on whether you trust the author of the libc in question to have implemented it correctly (an incorrect implementation in terms of getaddrinfo() might not in fact be pure)
19:16:19 * geekosaur looks sternly in the direction of glibc
19:16:28 <nitrix> Myrl-saki: The replicateM does the "repeat next action n times".
19:16:44 <nitrix> Myrl-saki: I don't have much information but you could surely put those pieces together.
19:17:34 <nitrix> The get x, parse x, get n from x, sounds like  n <- parse <$> get x
19:20:19 <Myrl-saki> I messed up.
19:21:09 <Myrl-saki> What I want. :: (Monad m, Monad n) => m (n a) -> (a -> m (n b)) -> m (n b)
19:21:13 <emmanuel_erc> Hello there. I am trying to install a library (which is essentially a wrapper to a C library) and I am able to install it, however whenever I run the command 'cabal repl' I get an error about a temp shared object that can't be loaded because of an undefined symbol. This error report also includes a recommendation to file a bug report to haskell.org/ghc/reportabug. Has anyone here run into this sort of issue before?
19:21:23 <emmanuel_erc> *sorry for the long message*
19:21:43 <geekosaur> emmanuel_erc, what ghc version?
19:22:12 <Myrl-saki> Actually, no.
19:22:29 <nitrix> Myrl-saki: Find the type, we'll figure out the implementation.
19:23:09 <Myrl-saki> nitrix: I don't think lift is appropiate for this.
19:23:23 <emmanuel_erc> geekosaur: I am using ghc version 7.10.3.
19:25:09 <Myrl-saki> nitrix: I'm quite positive that if I want to proceed using transformers, I need an :: m (Maybe a) -> MaybeT m a
19:25:21 <Myrl-saki> nitrix: MaybeT seems to provide that.
19:25:36 <nitrix> Right. That's MaybeT.
19:25:43 <geekosaur> emmanuel_erc, I *think* a couple of bugs of that general nature got fixed in 8.0.1 (source was released, binary builds are still in progress)
19:26:12 <nitrix> Myrl-saki: mapMaybeT :: (m (Maybe a) -> n (Maybe b)) -> MaybeT m a -> MaybeT n b
19:26:13 <emmanuel_erc> So should just upgrade to 8.0.1 or just go back down to 7.10.2?
19:26:50 <nitrix> Myrl-saki: Was that was you wanted? Seems very close.
19:27:00 <Myrl-saki> nitrix: Hmmm, it's possible.
19:27:06 <geekosaur> I don't know offhand what versions have the issue, I'm trying to find the relevant bug(s)
19:27:08 <Myrl-saki> nitrix: It's indeed very close.
19:27:42 <emmanuel_erc> hmm ...
19:29:12 <Myrl-saki> nitrix: Okay, I got it to semi-work.
19:29:23 <geekosaur> in any case you probably want to ask in #ghc as they're more likely to have useful information whereas I have to rely on memory of stuff I've seen discussed
19:29:38 <Myrl-saki> nitrix: http://ix.io/G56
19:29:54 <Myrl-saki> nitrix: The fact that I escaped from Maybe is Ugly for me though.
19:30:09 <emmanuel_erc> I didn't realize there was a channel dedicated to just talking about the compiler. Thanks geekosaur!!
19:30:54 <Myrl-saki> I'm not exactly sure if I want to have a type of `Maybe [Maybe a]` though.
19:31:41 <Myrl-saki> > sequence Nothing :: [Maybe Int]
19:31:43 <lambdabot>  [Nothing]
19:31:55 <Myrl-saki> I see
19:32:51 <nitrix> Myrl-saki: maybe 0 id == fromMaybe 0
19:33:23 <Myrl-saki> nitrix: Ah, thanks.
19:33:31 <Myrl-saki> nitrix: I really really need to get a linter. Lol.
19:33:52 <nitrix> What's the type of blocks?
19:34:21 <Myrl-saki> nitrix: Int.
19:34:25 <nitrix> Info -> Int ?
19:34:46 <Myrl-saki> nitrix: Yeah.
19:35:14 <nitrix> Oh sorry, the definitions are above.
19:35:24 <Myrl-saki> nitrix: It's fine. :P
19:36:14 <nitrix> Myrl-saki: All of this could happen in a `MaybeT IO` I feel.
19:37:55 <Myrl-saki> nitrix: It can, but I'd have to lift the second one.
19:38:02 <Myrl-saki> the forM part.
19:38:22 <Myrl-saki> nitrix: Hence why I'm not exactly sure if I want to have a type of `Maybe [Maybe a`
19:38:55 <nitrix> Yeah, but it'd avoid the    `fmap x <$>` stuff everywhere.
19:39:12 <nitrix> That's what MaybeT does for >>= (more or less).
19:40:00 <Myrl-saki> nitrix: It's more of an "I want to get this to work" kinda thing.
19:40:08 * nitrix nods
19:40:39 <Myrl-saki> nitrix: I think MaybeT (fmap f <$> m) == f <$> MaybeT m
19:41:16 <nitrix> That'd be one of the law I think. To confirm.
19:42:24 <nitrix> Myrl-saki: Can't be worse than my first "just want to get this to work" ever project written in Haskell: https://github.com/nitrix/sourcetree-vm-hack/blob/master/git.hs
19:42:52 <nitrix> You don't even want to know what it does.
19:43:07 <gfixler> if you catch my meaning
19:43:32 <gfixler> oh crap, my window was scrolled like 80 pages up - sorry
19:43:37 <Myrl-saki> nitrix: I have worse. One was for a thesis, another one was to finish a job filter disguised as an anime game.
19:43:53 <Myrl-saki> nitrix: Let's just say I used !! everywhere for the latter.
19:44:20 <Myrl-saki> nitrix: For the former, 100 character lines were uncommon.
19:45:09 <Myrl-saki> nitrix: That's what happens if the deadline's like exactly the day after lol. Interestingly, most of my code was kept Safe.
19:45:39 <m-renaud> I believe it is caused by this foldl' (https://github.com/m-renaud/ML/blob/master/src/ML/NN.hs#L238), but I thought it was strict in the accumulator so I don't know how that would happen.
19:46:25 <nitrix> m-renaud: Mind describing the problem first? Are you getting a stack overflow?
19:46:36 <m-renaud> https://drive.google.com/file/d/0B5lU2e-cHB9XYnRSVmtlMXhKNWc/view?usp=sharing
19:46:56 <m-renaud> Yeah, sorry, It's using significantly more memory than it should be
19:47:58 <m-renaud> It's a simple neural network implementation with stochastic gradient descent
19:48:44 <Myrl-saki> nitrix: I tried it out and it built. I guess it's fine.
19:48:55 <m-renaud> sgd works as follows: You have n training epochs (rounds of training), for each epoch you break the input into chunks (mini_batches), and you train the network using the mini batch.
19:49:10 <nitrix> m-renaud: Have you tried compiling the application instead of running it in GHCi ?
19:49:18 <nitrix> m-renaud: Just to confirm a theory.
19:49:27 <m-renaud> Once you have processed the mini-batch the network should be updated.
19:50:06 <m-renaud> nitrix: Yup, stack build --executable-profiling && time stack exec test -- +RTS -hy -p -xt -i0.01
19:51:15 <m-renaud> What I expect to happen is to only need memory to perform gradient descent on the mini-batch (size 10 for the linked profile), after which the memory should be released.
19:51:56 <m-renaud> What I see instead is a gradual climb in memory over the first epoch as all the mini-batches are processed (which takes quite a long time), then the memory growth stops when the 2nd+ epochs are performed.
19:52:51 <m-renaud> So it appears that during the course of one epoch of sgd, all of the memory for each of the mini-batches is held onto
19:53:10 <nitrix> I think the issue is vChunksOf, checking.
19:55:31 <m-renaud> Also note that the memory growth and time is linear in the trainingData input size.
19:55:39 <nitrix> splitAt uses G.splitAt (Data.Vector.Generic) which uses unsafeSlice, which "O(1) Yield a slice of the vector without copying."
19:56:06 <nitrix> m-renaud: All the slices are sharing the same vector, so as long as a slice is in use, the entire vector cannot be deallocated.
19:56:58 <m-renaud> Hmm, that makes sense, but I wouldn't have expected the slices to use that much memory :/
19:58:20 <nitrix> m-renaud: I'm definitely not the best person to ask, but just for fun, you could try to use `force` (from Data.Vector on the slices created).
19:58:59 <m-renaud> Sure, I'll try that out, thanks :)
19:59:06 <nitrix> Trying to give alternatives until more knowledgeable people shows up. Personally, that foldl' looks fine.
20:09:35 <zRecursive> :t foldl'
20:09:36 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
20:10:19 <zRecursive> @src foldl'
20:10:19 <lambdabot> foldl' f a []     = a
20:10:19 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:13:06 <m-renaud> I just wrote my old foldl' with print statements and confirmed that the memory growth happens on each recursive foldl' call.
20:14:16 <nitrix> m-renaud: Did you try the `force` on the slice created?
20:15:35 <m-renaud> nitrix: Yup, no change to memory growth
20:15:41 <nitrix> :(
20:16:17 <m-renaud> I wonder... ! patterns don't do full normalization do they?
20:16:52 <m-renaud> Do I need to deepseq something?
20:19:04 * hackagebot language-c-quote 0.11.6.2 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.6.2 (GeoffreyMainland)
20:31:31 <nitrix> m-renaud: What if it's the shuffling that causes it? I'm downloading your project and testing on mnist.dat my idea :)
20:31:38 <nitrix> m-renaud: Btw, hardcoded paths are evil :P
20:36:47 <m-renaud> Haha, yes hardcoded paths are evil :P
20:37:39 <m-renaud> nitrix: It may be the shuffling to be honest
20:38:01 <Myrl-saki>     return = lift . return
20:38:02 <Myrl-saki> wat
20:38:02 <m-renaud> The training data isn't used after sgd so I would have /hoped/ that there wouldn't be a copy of everything made
20:38:11 <Myrl-saki> I don't get it.
20:38:28 <m-renaud> Myrl-saki: Is that from a monad transformer?
20:38:31 <Myrl-saki> Does that recurse, or am I missing something?
20:38:33 <Myrl-saki> m-renaud: Yep.
20:38:35 <nitrix> m-renaud: MaybeT
20:38:48 <Myrl-saki> That looks like lift . lift . lift... to me.
20:39:01 <Myrl-saki> Or is there something that I'm missing?
20:43:16 <nitrix> Myrl-saki: It's doing `return` on a different type, no?
20:43:29 <nitrix> Myrl-saki: So it shouldn't be recursive, it'll use that type' return instance.
20:43:32 <geekosaur> Myrl-saki, the return is happening in the monad you lift-ed ot
20:43:36 <geekosaur> *to
20:44:04 <m-renaud> Another question I have, in profiler output you sometimes see foo.(...), what does that mean?
20:44:05 * hackagebot werewolf 1.2.0.0 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.2.0.0 (hjwylde)
20:44:07 * hackagebot werewolf-slack 1.0.1.2 - A chat interface for playing werewolf in Slack  https://hackage.haskell.org/package/werewolf-slack-1.0.1.2 (hjwylde)
20:45:51 <m-renaud> It says that 54% of the time is in main.(...) :/ But all that main does is parse the input and then invoke sgd.
20:46:49 <Myrl-saki> geekosaur: Ohhh, I see.
20:49:43 <geekosaur> this makes a bit more sense if you look at the generated Core; it shows that typeclass dictionaries are passed around, and the function "return" just calls a function in the typeclass dictionary it's passed. so in effect it "changes type" as needed and does something different for each type
20:51:29 <geekosaur> which is a littler confusing in an expression like the one you showed, because it doesn't look like typeclassDictionary['return] = lift . anotherTypeclassDictionary['return]
20:52:02 <geekosaur> unless you look at the Core (well, Core represents it differently than I did)
21:13:08 <m-renaud> nitrix: You can get the mnist data file at http://www.filedropper.com/mnist_1 (the validation and test sets are wrong, but don't worry about that) :P
21:24:06 * hackagebot apiary 2.0.2 - Simple and type safe web framework that generate web API documentation.  https://hackage.haskell.org/package/apiary-2.0.2 (winterland)
21:47:35 <codedmart> Can I set a resolver in ~/.stack/config.yaml?
21:51:30 <codedmart> Nvm
21:58:24 <pyon> Is there ever a situation where implementing (==) in terms of compare can be slower than implementing it directly?
21:58:51 <pyon> (Assuming I can't use the deriving mechanism.)
22:06:25 <codedmart> anyone here use atom, stack, ghc-mod?
22:19:33 <Axman6> codedmart: yes
22:19:44 <Axman6> can't claim to be an expert though
22:20:42 <codedmart> Axman6: do you have any issues? I keep getting an error that ghc-mod 5.4 is deprecated, yet I have 5.5 installed. Also it starts 8 different ghc all using 100% cpu.
22:21:34 <Axman6> have you set the path to ghc-mod? I believe that's a thing you can do...
22:22:46 <codedmart> Axman6: OK that removes the deprecated error, but I still get a number of ghc started running up 100% cpu
22:22:55 <codedmart> Are you not seeing that problem?
22:22:59 <Axman6> yeah no idea about that one
22:23:00 <Axman6> nope
22:25:18 <codedmart> Lame, thanks anyways.
22:26:08 <Axman6> occasionally it uses a lot of CPU, but usually stops
22:32:11 <jle`> just realized you can use (curry . curry) print to get 'print' to work for multiple arities
22:32:30 <EvanR> :t (curry . curry) print
22:32:31 <lambdabot> (Show a, Show b, Show b1) => a -> b -> b1 -> IO ()
22:32:42 <jle`> > (curry . curry . curry $ show) 1 2 3 4
22:32:44 <lambdabot>  "(((1,2),3),4)"
22:32:47 <jle`> hehe
22:33:07 <EvanR> variadic functions eat your heart out
22:33:10 <jle`> > (curry . curry . curry . curry . curry $ show) 1 2 3 4 5 6
22:33:12 <lambdabot>  "(((((1,2),3),4),5),6)"
22:33:17 <jle`> who needs printf
22:33:31 <jle`> when you have  ... curry
22:33:43 <EvanR> :t (curry . curry)
22:33:44 <lambdabot> (((a, b), b1) -> c) -> a -> b -> b1 -> c
22:34:34 * EvanR imagines almost anyone familiar with variadic functions laughing politely at this
22:35:01 <Rotaerk> so much curry... making me hungry
22:37:00 <kzhang> Question about the diagrams package: Is it possible to set the "z-index" for certain object?
22:37:10 <kzhang> I want some objects to be in the front so that they won't be covered by others.
22:43:25 <Axman6> kzhang: it's definitely possible, use atop
22:47:05 <kzhang> Axman6: But I need to rearrange the objects and then apply the "atop". The sounds not a idea solution.
22:48:39 <kzhang> Axman6: I have a bunch of objects. What I want is to set the z-indices for them, and diagrams should assign the correct order and apply "atop" for me.
22:50:35 <kzhang> Axman6: I definitely can do: mconcat $ sortBy (comapring snd) [(shape1, z1), (shape2, z2), (shape3, z3)]
22:50:53 <kzhang> Axman6: Just a little bit inconvenient
23:01:35 <texasmynsted> I tried to install haskell-awk with stack install haskell-awk  
23:04:44 <shafox> I have experience with Java,PHP and some python. I want to learn algorithm and data structure cause I am not from a computer science background. I would like to use Haskell for this learning so that I can learn both. Is there any tutorial/blog/course that I can take ?
23:07:25 <srhb> shafox: I would recommend learning Haskell, at least the basics, first, and then algorithms and data structures. Otherwise it will probably be quite daunting to keep a focus.
23:08:05 <shafox> srhb, yes I have the same plan as you suggested. Basics of Haskell then move to algorithms and data structures. 
23:08:24 <srhb> shafox: Perhaps these resources can be of help: https://github.com/bitemyapp/learnhaskell/
23:08:28 <shafox> Is there any course that uses Haskell for learning purposes ? 
23:09:05 <texasmynsted> oh works via stack exec hawk
23:09:48 <Axman6> shafox: you should know that the algorithms and data structures in Haskell differ a lot from more "traditional" (ie, imperative) algorithms and datastructures
23:09:59 <texasmynsted> https://github.com/NICTA/course
23:10:25 <shafox> Axman6, Can you explain a bit ? 
23:10:46 <srhb> Axman6: Nonsense, imperative is a subset of functional. ;-)
23:11:23 <srhb> shafox: A simple example is that we almost never use the kind of loops imperative programmers are used to.
23:11:27 <srhb> shafox: ie while, for, ...
23:11:38 <dibblego> here is gcd written with a while loop, in haskell, https://gist.github.com/tonymorris/5607151
23:14:56 <Nnotm> I remember reading that due to laziness, Haskell evaluates everything at most once. Shouldn't that mean that "let b 0 = 1; b n = 0.5 * (b (n - 1) + 2 / b (n - 1))" should be equivalent to "let b 0 = 1; b n = 0.5 * (b (n - 1) + 2 / b (n - 1))"? I'm asking because at least in ghci, the second one is significantly faster (i.e. O(n) instead of O(2^n), I suppose)
23:16:52 <shafox> srhb, Ok. 
23:17:30 <scshunt> Nnotm: Haskell does not automatically memoize except in certain limited circumstances
23:17:38 <Nnotm> I see
23:18:27 <dibblego> those two are the same
23:18:35 <dibblego> haskell never memoises, GHC does sharing
23:19:04 <Nnotm> err, did I copy the wrong one?
23:19:20 <Nnotm> I meant "let b 0 = 1; b n = let bnm = b (n - 1) in 0.5 * (bnm + 2 / bnm)"
23:19:33 <dibblego> right, that is sharing
23:20:21 <Nnotm> so, are you saying GHC would optimize the first version? (if this weren't inside ghci)
23:20:31 <dibblego> i.e. bnm is shared (sharing by the identifier name)
23:20:39 <EvanR> [6~[6~[6~[6~
