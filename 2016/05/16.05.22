00:00:46 <EvanR> nice instances for 24-tuples
00:04:13 <KemyLand_> Does anyone know what is the package necessary for using `ghc -prof` in Fedora? I don't seem to find it...
00:04:55 <athan> is it terminfo or something?
00:05:58 <KemyLand_> no, i mean, when using `ghc -prof`, a "Could not find module `Prelude`" appears on screen
00:06:23 <KemyLand_> ghc points out that this may be because some special packages are not installed
00:06:45 <KemyLand_> This it what is prints:
00:06:47 <KemyLand_> `
00:06:48 <KemyLand_>     Could not find module ‚ÄòPrelude‚Äô     Perhaps you haven't installed the "p_dyn" libraries for package ‚Äòbase‚Äô?     Use -v to see a list of the files searched for.
00:06:50 <KemyLand_> `
00:07:40 <srhb> KemyLand_: Looks like you need a version of base with profiling enabled.
00:08:06 <KemyLand_> yes, it seems like so
00:08:21 <KemyLand_> however, i already installed the `ghc-prof` package with dnf
00:08:34 * hackagebot hasql 0.19.12 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.12 (NikitaVolkov)
00:08:37 <KemyLand_> srhb: Yet the same error appears
00:09:30 <KemyLand_> srhb: Also, there's no `ghc-base-prof` or stuff of the like
00:09:58 <srhb> KemyLand_: base is usually bundled with GHC. You might be getting the wrong package database?
00:10:08 <srhb> KemyLand_: Managing these things with OS package managers is usually messy.
00:10:22 <KemyLand_> shrb: I'm using the vanilla Fedora repos
00:11:30 <KemyLand_> shrb: I can compile stuff without `-prof`. That means that the non-prof version of ghc-base is there. Yet, I can't find the prof-specific one.
00:12:32 <srhb> KemyLand_: Are you sure it's not an entirely different ghc?
00:12:36 <srhb> KemyLand_: (ie. try removing the other one)
00:14:23 <KemyLand_> srhb: From what I can see in dnf's logs, only libraries were installed from `ghc-prof`, and no ghc itself
00:15:14 <KemyLand_> srhb: Commands such as `sudo dnf search ghc | egrep 'dyn|prof'` give no output, btw
00:33:36 * hackagebot gconf 0.13.1.0 - Binding to the GNOME configuration database system.  https://hackage.haskell.org/package/gconf-0.13.1.0 (HamishMackenzie)
00:33:38 * hackagebot webkitgtk3 0.14.2.0 - Binding to the Webkit library.  https://hackage.haskell.org/package/webkitgtk3-0.14.2.0 (HamishMackenzie)
00:33:40 * hackagebot webkit 0.14.2.0 - Binding to the Webkit library.  https://hackage.haskell.org/package/webkit-0.14.2.0 (HamishMackenzie)
00:36:40 <maybefbi> why doesn't haskell define monad in terms of (>=>) and return. why does it define in terms of (>>=) and return?
00:36:50 <srhb> maybefbi: Hysterical raisins.
00:36:56 <srhb> maybefbi: It could be the other way.
00:37:07 <EvanR> how about join and return
00:37:13 <srhb> maybefbi: One could argue that since do notation is defined in terms of (>>=), it makes sense.
00:37:20 <EvanR> at least add join to the class and let it be an option
00:37:20 <srhb> maybefbi: You could argue any other way, too.
00:37:41 <maybefbi> ok
00:37:50 <maybefbi> (>=>) makes sense acctually
00:37:57 <srhb> maybefbi: They all make sense.
00:38:03 <maybefbi> its just composition for kliesi arrows
00:38:14 <maybefbi> (>>=) doesnt seem like anything
00:38:20 <jle`> it's bind :)
00:38:22 <srhb> maybefbi: That's very subjective.
00:38:23 <EvanR> (<=<) makes sense ;)
00:38:33 <jle`> 'join' makes sense too
00:38:48 <jle`> they're all theoretically/mathematically significant :D
00:39:11 <maybefbi> may be the preference is cultural. im a brown man in singapore.
00:39:37 <maybefbi> ;)
00:39:40 <srhb> :)
00:42:23 <thimoteus> i prefer <=<
00:42:38 <maybefbi> we gotta do a survey
00:42:50 <maybefbi> its like asking what is your favorite color
00:43:00 <thimoteus> green
00:43:11 <maybefbi> im a blue master race
00:43:22 <thimoteus> youre blue on my weechat, too
00:43:40 <maybefbi> am i own wechat?
00:43:43 <maybefbi> *on
00:43:55 <thimoteus> just the name of an irc client
00:44:25 <maybefbi> oh ok
00:45:19 <Hijiri> you're purple for me, on my weechat
01:06:11 <tsahyt> Hello everyone! I'm using an RWST in a monad stack and use the writer component to do logging and tracing of what's going on. So far I've only been able to get the log printed after execution (successful execution to be precise). This makes debugging a bit of a pain at the moment, and I was wondering whether there's a way to write the log on the fly with this setup, e.g. print messages to stderr whenever
01:06:12 <tsahyt> they get logged instead of having an accumulated message afterwards.
01:09:04 <jle`> tsahyt: yeah, that use case really isn't a good one for Writer :)
01:09:16 <jle`> there are a lot of logging contexts you cann use for things like that
01:09:37 <jle`> like monad-logger
01:10:17 <jle`> pipes also provides a nice way to handle this
01:10:25 <tsahyt> I'll look into it. I might have to rewrite my transformer stack
01:10:42 <tsahyt> what is a good use case for Writer btw?
01:10:43 <jle`> if anything, abandon programming towards "transformer stacks" altogether :)
01:11:01 <tsahyt> I try to avoid them most of the time
01:11:23 <jle`> if you want to manage multiple effects, write polymorphic code over typeclasses
01:11:24 <tsahyt> but in this case I need to carry some state and have access to a limited subset of IO actions
01:11:26 <jle`> like MonadState
01:11:28 <jle`> MonadIO
01:11:32 <jle`> MonadReader, etc.
01:11:46 <jle`> that way you're actually programming to the logic you're trying to describe
01:12:01 <jle`> instead of a fragile specific implementation
01:12:11 <tsahyt> fragile in what way?
01:12:39 <jle`> well, in this case, you have to rewrite a lot of your code just to get the right behavior for logging
01:13:04 <jle`> but if you program polymorphically, you only need to change the code that specifically requires logging
01:13:13 <tsahyt> "a lot" being roughly 20 lines at the moment
01:13:15 <tsahyt> but yeah I get your point
01:13:29 <jle`> yeah, it gets more complicated with larger projects :)
01:13:36 <jle`> if your codebase is only 20 lines, feel free to do whatever you want :P
01:13:44 <tsahyt> the thing is that every interesting function operating in the resulting monad needs access to its state, IO capabilities, readonly state, etc anyhow
01:14:15 <jle`> you might notice the opportunity to factor out your logic
01:14:24 <tsahyt> turns out that for some reason the logging function that I've wrapped around the Writer is written polymorphically anyhow
01:15:00 <jle`> transformer stacks also compose in weird ways, so you'll have to keep in mind the order of the stacking, etc., when you're writing your logic
01:15:32 <jle`> but in general, it's also kind of weird mixing your actual application  logic with low-level implementation details
01:16:28 <jle`> if you have the chance to separate your actual logic from implementation concerns, it usually leads to more maintainible and understandable code
01:17:08 <jle`> also, when you write polymorphic code, you get to leverage safety benefits from parametric polymorphism
01:17:25 <tsahyt> I'll look into it
01:18:33 <jle`> new ghc version also warns redundant constraints, too, so if you write a helper function/action that doesn't need *all* of the effects you are describing, GHC will warn you
01:18:48 <tsahyt> GHC 8 that is?
01:18:58 <jle`> and you can remove the constraint, and now your code is more polymorphic, so you have greater safety and ability to reasona bout your code :)
01:19:07 <tsahyt> Unfortunately I'm locked to 7.8 for this project :/
01:19:12 <jle`> mhm, but the benefits of being able to remove constraints is useful in 7.8 as well
01:20:12 <tsahyt> hmm, but since I've wrapped a newtype around IO to restrict it to only a few actions, I'd have to write a class for those as well, right?
01:21:36 <jle`> it depends on how you are using it.  but, if you're trying to work with an IO type with only a few specific actions, you might be better off just implementing it as an ADT instead
01:21:44 <jle`> and, in that case, you get a typeclass for free
01:21:49 <jle`> to lift actions into it
01:22:06 <tsahyt> what would that look like?
01:23:03 <jle`> if you encode your list of actions as an ADT, Foo, then you get (MonadFree Foo m) => m ... that you can use
01:23:08 <jle`> from the 'free' library
01:23:19 <tsahyt> ah right, I still haven't bothered to look into free monads
01:23:24 <tsahyt> Seems like I should
01:23:24 <jle`> and that gives you 'liftIO'-type lifting actions
01:23:42 <jle`> so you can embed your ADT's actions into any MonadFree Foo m => m ...
01:23:51 <jle`> like how you can lift any IO action into a MonadIO m => ...
01:24:07 <jle`> actually, i don't think you even need to implement a custom ADT, you might just be able to use your pre-existing restricted IO type...
01:24:17 <jle`> MonadFree RestrictedIO m => m ... should already do the trick
01:24:43 <tsahyt> at the cost of another dependency though
01:25:17 <jle`> sure, but dependencies usually don't cost that much :)
01:25:42 <tsahyt> I'll have to somehow end up building a shared library that has all the haskell libraries statically compiled into it, including the runtime system and base
01:25:48 <tsahyt> which means that I'll eventually have to recompile GHC for it
01:26:06 <tsahyt> in that case I'd rather limit the amount of dependencies
01:26:45 <tsahyt> in case you're wondering, the use case for this is to provide a plugin to a C++ project
01:26:54 <tsahyt> without having to write C++
01:27:22 <jle`> sounds like you might be looking at a case of premature optimizations --- it might be hard to know exactly what the real costs are, and you might spend too much time optimizing for the small costs that don't matter in the big picture :)
01:27:55 <jle`> in any case, you can implement the functionality of MonadFree within like 10 lines of code, if oyu one day decide that the dependency is too heavy
01:28:05 <jle`> so you can keep your logic and expressiveness, without the cost of the dependency :)
01:28:38 * hackagebot webkitgtk3-javascriptcore 0.14.1.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.14.1.0 (HamishMackenzie)
01:28:40 * hackagebot webkit-javascriptcore 0.14.1.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkit-javascriptcore-0.14.1.0 (HamishMackenzie)
01:31:01 <tsahyt> on a related note, at the end of the day I need some concrete monad to run the code, so even with polymorphic code I'll have to settle on some stack that satisfies the class constraints. Now that I have no more use for Writer because of MonadLogger, would it be considered better style to ditch RWST in favor of a Reader and a State?
01:32:03 <jle`> yeah, or you can also write your own monad that has Reader and State functionality
01:32:52 <jle`> data RS a = RS (Int -> Bool -> (a, Bool))
01:33:06 <jle`> for a type that has a read-only Int and a Bool state
01:33:38 * hackagebot memory 0.13 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.13 (VincentHanquez)
01:33:40 * hackagebot webkitgtk3-javascriptcore 0.13.2.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.13.2.0 (HamishMackenzie)
01:33:42 * hackagebot webkit-javascriptcore 0.13.2.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkit-javascriptcore-0.13.2.0 (HamishMackenzie)
01:33:44 <jle`> there are many ways to get monads that give you the functionality you want (and sometimes get the instances for free) without using transformers
01:33:56 <tsahyt> but what's wrong with using them?
01:34:21 <tsahyt> it's just a matter of newtyping and deriving the instances
01:34:44 <jle`> yeah, it's a little less flexible, but if you can find the right transformers to get you the monad you want, there's nothing wrong with using them
01:34:58 <jle`> i consider making monads using transformers to be a quick-hack sort of way of getting your monad
01:35:15 <jle`> might not scale in the long run, but they're useful in a pinch
01:36:06 <tsahyt> as I said I tend to avoid complicated stacks and I'd rather redesign the system to avoid mingling of effects so I'm lacking experience here, but how would rolling your own monad scale better than building it out of reusable components via transformers>
01:36:12 <tsahyt> s/>/?
01:38:37 <jle`> hm, yeah, i guess making your own types by hand in the way i described might cause some problems with scaling.  i just think it's more flexible, but if the transformers you have at hand already do the work, there might not be a good reason to prefer it
01:39:07 <Hafydd> It's at least instructive to write your own monads a few times, even if you don't necessarily use them.
01:50:01 <lambdafan> greetings
01:50:32 <lambdafan> I've got a question concerning the octree package
01:50:47 <lambdafan> say I have two Vector3 values
01:50:53 <lambdafan> call them foo and bar
01:51:07 <lambdafan> they represent points in non-continuous space
01:51:20 <lambdafan> foo is a space-station, bar is a ship trying to fly to foo
01:51:36 <lambdafan> rather foo and bar are there locations in this space
01:51:41 <lambdafan> their
01:52:44 <lambdafan> I'm trying to emulate movement such that bar's distance from foo decrements by say 10 each "moment"
01:53:27 <lambdafan> they best idea I could come up with is to calculate the ordered set of Vector3s in-between foo and bar, and go from there
01:53:50 <lambdafan> does that make sense, is thee a nbetter way?
02:18:40 * hackagebot uncertain 0.3.1.0 - Manipulating numbers with inherent experimental/measurement uncertainty  https://hackage.haskell.org/package/uncertain-0.3.1.0 (jle)
02:38:41 * hackagebot gtksourceview3 0.13.3.0 - Binding to the GtkSourceView library.  https://hackage.haskell.org/package/gtksourceview3-0.13.3.0 (HamishMackenzie)
02:38:43 * hackagebot gtksourceview2 0.13.3.0 - Binding to the GtkSourceView library.  https://hackage.haskell.org/package/gtksourceview2-0.13.3.0 (HamishMackenzie)
02:53:41 * hackagebot users-persistent 0.5.0.2 - A persistent backend for the users package  https://hackage.haskell.org/package/users-persistent-0.5.0.2 (AlexanderThiemann)
02:53:43 * hackagebot users-postgresql-simple 0.5.0.2 - A PostgreSQL backend for the users package  https://hackage.haskell.org/package/users-postgresql-simple-0.5.0.2 (AlexanderThiemann)
02:53:45 * hackagebot users-test 0.5.0.1 - Library to test backends for the users library  https://hackage.haskell.org/package/users-test-0.5.0.1 (AlexanderThiemann)
03:18:42 * hackagebot svgcairo 0.13.1.0 - Binding to the libsvg-cairo library.  https://hackage.haskell.org/package/svgcairo-0.13.1.0 (HamishMackenzie)
03:29:28 <mauke> I'd like to register a complaint
03:29:44 <mauke> why does the PVP have such a weird ungoogleable name?
03:30:16 <mauke> and why does it specify three data fields to convey two pieces of information
03:32:46 <newcomer> is there a function application operator of following signature: a -> (a -> b) -> b?
03:32:54 <cocreature> :t flip ($)
03:32:56 <lambdabot> a -> (a -> c) -> c
03:33:08 <cocreature> :t (&)
03:33:10 <lambdabot> a -> (a -> b) -> b
03:33:25 <cocreature> & is in Data.Function iirc
03:33:48 <newcomer> cocreature, yes, tried flipping $, but it didn't have the required (low) precedence.
03:34:04 <newcomer> cocreature, will try &
03:37:28 <newcomer> cocreature, http://lpaste.net/164173
03:37:41 <newcomer> cocreature, it doesn't show in Hoogle either.
03:37:52 <cocreature> newcomer: which version of ghc are you using?
03:37:58 <cocreature> I think it‚Äôs only there from 7.10 onward
03:38:15 <cocreature> and at least the new hoogle does show it http://hoogle.haskell.org/?hoogle=(%26)
03:38:44 <newcomer> cocreature, Oh yea, I'm using 7.8.
03:38:57 <cocreature> just define it yourself
03:38:59 <newcomer> cocreature, Thank's, will upgrade.
03:39:39 <newcomer> cocreature, what precedence number should it take?
03:39:59 <cocreature> the one in Data.Function has infixl 1
03:40:32 <dito> Hi guys. Is it possible to have a `do` block for list monad and then do stuff inside `do` monad for IO ?
03:40:51 <dito> *inside do for IO monad
03:43:38 <bonsairoot> Hi I'm new to haskell. Can anybody explain to me why http://lpaste.net/164174 doesn't work?
03:44:04 <Rembane> bonsairoot: Do you get a type error or get a weird result?
03:44:18 <dito> like this:
03:44:24 <bonsairoot> Rembane, type error
03:44:25 <dito>  drawLinesBetween :: [V4 Float] -> IO () 
03:44:26 <dito> drawLinesBetween dots' = dots' >>= \d1 -> dots' >>= \d2 -> dotToVert d1 >> dotToVert d2
03:44:40 <dito> dotToVert :: V4 Float -> IO ()
03:44:57 <mpickering> bonsairoot: Please can you add the type error to the pastebin?
03:45:37 <Rembane> bonsairoot: Does this work better? http://lpaste.net/164174
03:46:20 <cocreature> bonsairoot: you‚Äôre missing a comma in your list
03:47:10 <bonsairoot> o my god the shame. I am sorry. Thanks everyone
03:47:54 <Gurkenglas> Why doesn't lambdabot have Control.Lens.Zipper?
03:53:44 * hackagebot network-multicast 0.1.1 - Simple multicast library  https://hackage.haskell.org/package/network-multicast-0.1.1 (AudreyTang)
03:58:44 * hackagebot hvect 0.3.1.0 - Simple strict heterogeneous lists  https://hackage.haskell.org/package/hvect-0.3.1.0 (AlexanderThiemann)
03:58:46 * hackagebot subwordgraph 1.0.0 - Subword graph implementation  https://hackage.haskell.org/package/subwordgraph-1.0.0 (adambak)
03:58:48 * hackagebot elm-bridge 0.3.0.0 - Derive Elm types from Haskell types  https://hackage.haskell.org/package/elm-bridge-0.3.0.0 (AlexanderThiemann)
04:03:04 <puregreen> int-e: do you want help with maintaining lambdabot? I've got lots of free time that I could spend on various non-code-related issues (adding modules to Pristine.hs, making sure things build on Travis, writing docs, keeping the freenode instance in sync with master, etc) (and maybe with time I'll have enough understanding of the codebase that I'd be able to make bigger changes with your permission)
04:11:44 <newcomer> What's wroing with this? http://lpaste.net/164179
04:12:30 <puregreen> newcomer: it should be ‚Äúflip ($)‚Äù
04:12:31 <mauke> ($)
04:12:40 <newcomer> oh
04:12:43 <newcomer> my bad
04:12:51 <puregreen> (and by the way, @@ already exists in Data.Function and is called (&))
04:13:22 <newcomer> puregreen, Yes, I have an older version of GHC. Besides, I'm doing this for purely educational reasons :)
04:13:28 <puregreen> ah, 'kay
04:15:44 <obadz> newcomer: also have a look at https://gist.github.com/obadz/9f322df8ba6c8a9767683d2f86af8589 :)
04:18:45 * hackagebot base-prelude 1.0.1.1 - The most complete prelude formed solely from the "base" package  https://hackage.haskell.org/package/base-prelude-1.0.1.1 (NikitaVolkov)
04:22:42 <newcomer> obadz, Yes, this is exactly what I want to do. Not to use it for anything, but for educational reasons.
04:23:45 * hackagebot monad-peel 0.2.1 - Lift control operations like exception catching through monad transformers  https://hackage.haskell.org/package/monad-peel-0.2.1 (SergeyAlirzaev)
04:24:00 <obadz> newcomer: I've come to the point where I actually want to use it :)
04:24:46 <newcomer> obadz, I'm using Control.Arrow's (>>>) operator. But it has (infixr 1) and it's not playing well with my (@@):: a -> (a->b)->b operator.
04:25:14 <obadz> yes gotta be careful for all of them to have the same fixity
04:25:44 <obadz> I believe >>> is from Control.Category
04:25:46 <newcomer> I've got this error: cannot mix ë@@í [infixl 1] and ë>>>í [infixr 1] in the same infix expression
04:26:27 <obadz> right
04:26:41 <obadz> you either need to change fixity or add parens
04:27:22 <obadz> I have all my 'pointed to the right' operators infixl so they can be chained
04:28:15 <newcomer> obadz, so the problem is the left/right associativity or the precedence?
04:28:45 * hackagebot vtegtk3 0.13.1.0 - Binding to the VTE library.  https://hackage.haskell.org/package/vtegtk3-0.13.1.0 (HamishMackenzie)
04:28:47 * hackagebot vte 0.13.1.0 - Binding to the VTE library.  https://hackage.haskell.org/package/vte-0.13.1.0 (HamishMackenzie)
04:28:51 <obadz> newcomer: either/or
04:29:02 <obadz> newcomer: you have to change one I believe
04:29:05 <newcomer> obadz, let me contemplate on that for a minute.
04:38:18 <babelchips> Good morning.  I‚Äôm looking for some help with getting sdl2 and sdl2-image cabal packages installed.  Can someone help please?
04:39:50 <mpickering> what problems are you having
04:41:03 <babelchips> the sdl2 package has downloaded and installed fine (lots of dependencies) but looks good.  But ‚Äòcabal install sdl2-image‚Äô is failing with: Failed to install sdl2-image-0.1.3.2
04:41:21 <babelchips> then the error further down: 'SDL2_image' version >=2.0.0 is required but it could not be found.
04:41:55 <babelchips> Why would the installation of a package complain about itself anyway?
04:42:39 <cocreature> that‚Äôs probably the corresponding C library
04:42:53 <mpickering> can you paste the whole log please?
04:43:16 <cocreature> yep it is, https://github.com/ccll/hs-sdl2-image/blob/master/sdl2-image.cabal has a dependency on SDL2_image in the pkgconfig-depends section
04:43:41 <babelchips> Warning: cannot determine version of /usr/local/bin/cpphs :
04:43:41 <babelchips> ""
04:43:43 <babelchips> Resolving dependencies...
04:43:44 <babelchips> Downloading sdl2-1.3.1...
04:43:46 <babelchips> Configuring sdl2-1.3.1...
04:43:47 <babelchips> Building sdl2-1.3.1...
04:43:49 <babelchips> Installed sdl2-1.3.1
04:43:50 <hexagoxel> @where paste
04:43:50 <lambdabot> Haskell pastebin: http://lpaste.net/
04:43:50 <babelchips> Downloading sdl2-image-0.1.3.2...
04:43:52 <babelchips> Configuring sdl2-image-0.1.3.2...
04:43:53 <babelchips> Failed to install sdl2-image-0.1.3.2
04:43:55 <babelchips> Build log ( /Users/admin/.cabal/logs/sdl2-image-0.1.3.2.log ):
04:43:55 <maerwald> babelchips: stop
04:43:56 <babelchips> Configuring sdl2-image-0.1.3.2...
04:43:58 <babelchips> setup-Simple-Cabal-1.22.5.0-x86_64-osx-ghc-7.10.3: The pkg-config package
04:43:59 <babelchips> 'SDL2_image' version >=2.0.0 is required but it could not be found.
04:44:01 <babelchips> Updating documentation index
04:44:04 <babelchips> cabal: Error: some packages failed to install:
04:44:05 <babelchips> sdl2-image-0.1.3.2 failed during the configure step. The exception was:
04:44:06 <maerwald> can someone kick him?
04:44:07 <babelchips> ExitFailure 1
04:44:08 <babelchips> ChrisMBP:~ admin$ cabal install SDL2_image
04:44:08 <babelchips> cabal: The file does not exist 'SDL2_image'.
04:44:26 <maerwald> babelchips: plz use a pastebin, this is spamming the channel
04:44:29 <babelchips> Sorry.  What is the correct method?
04:44:43 <babelchips> OK.  Apologies.
04:45:10 <cocreature> anyway the solution is to install the SDL2_image c library. no idea how that works on os x
04:45:27 <ggVGc> I have come to the conclusion my entire current haskell code base is essentially unacceptable
04:45:30 <ggVGc> bit sad
04:46:04 <ahihi> homebrew has sdl2_image, I'm sure macports does as well
04:46:13 <ggVGc> yeah, but don't use ports..
04:46:19 <ggVGc> it's insanely crappy
04:46:28 <babelchips> Ok.
04:46:28 <EvanR> haskell code has a way of getting rewritten 
04:46:40 <ahihi> I tend to agree, but some people prefer it over brew :)
04:46:41 <EvanR> a lot
04:46:45 <ggVGc> EvanR: yeah, that's the reddeming part. I can see how all of it could be refactored into acceptableness
04:46:53 <ggVGc> but I'm sad it became like this in the first place
04:46:54 <babelchips> sdl2_image from brew will give me the original c libs then?
04:46:58 <ggVGc> but it's my first real project so it's okay
04:47:11 <EvanR> well youll do it, and see yet another improvemnt
04:47:28 <maerwald> ggVGc: yes, haskell does not guide you to write nice code, although a lot of people think that. It's just that refactoring is much more easy.
04:47:52 <ggVGc> EvanR: the interesting part is how the code is completely insane and lacks any form of design mostly, but the software itself runs very well and I only have a few minor bugs that are a result of incorrect implementations. everything else is super solid
04:47:56 <babelchips> so the clue is the name SDL2_image ‚Ä¶
04:47:56 <ggVGc> never had that situation in any other language
04:48:04 <EvanR> my current code has been more or less automatically guided by the types
04:48:13 <babelchips> I assumed that was the internal name in the cabal package but its actually the main c lib.
04:48:46 * hackagebot Hoed 0.3.6 - Lightweight algorithmic debugging.  https://hackage.haskell.org/package/Hoed-0.3.6 (faddegon)
04:48:56 <ggVGc> maerwald: what I've noticed is that while it does not lead me to write clean implementations for functions, it has led me to have a very solid data design at the core of my software
04:49:00 <ahihi> another clue is the version number; the C library is on 2.0.* while the haskell bindings are 0.1.*
04:49:45 <cocreature> babelchips: the clu is that it says ‚Äúthe pkg-config package‚Äù pkg-config is for C libs
04:50:46 <maerwald> ggVGc: I actually ended up removing data type abstractions for _some_ of my implementations, because they were too naive and caused problems with IO code
04:51:00 <maerwald> but that was a rather specific problem
04:51:09 <maerwald> I had tears in my eyes when I removed them, though
04:51:30 <babelchips> Okay.  brew install sdl2_image done and now cabal install sdl2-image is good.  Thank you!
04:52:38 <ggVGc> maerwald: what I really enjoy in haskell is that if I have a piece of code and I spend an hour refactoring it completely and get it to compile, it's very unlikely I accidentally changed the behaviour of it
04:52:45 <ggVGc> which I can not say for any other language I've worked in
04:53:15 <maerwald> well, as long as the behavior is mapped to the types somehow
04:53:35 <ggVGc> yeah, but even if not, it doesn't take much mental effort to not mess it up
04:53:40 <ggVGc> compared to what I've worked with before
04:54:52 <ggVGc> I'm still waiting for the moment I feel the need for a monad transformer, so I can understand why we have them
04:55:15 <maerwald> ggVGc: basically because we don't have a proper effect system (minus a few exceptions like continuation monad)
04:55:18 <ggVGc> I've never used them, and I don't compeltely understand their use cases, since I've never had a situation pop up yet where I've bumped into needing them
04:55:41 <ggVGc> I probably have a lot of code that could use them
04:55:48 <maerwald> try to avoid them
04:55:59 <ggVGc> right, that's why I haven't dug into it
04:56:18 <ggVGc> maerwald: at some point I'll hit some kind of roadblock, and then I'll try to find a solution, and one day the solution will be monad transformers
04:56:21 <ggVGc> and then I'll get it
04:57:18 <maaarcocr_> I know that there is a lot of entu
04:57:46 <maaarcocr_> enthusiasm* about the new GHC, but does anyone know when the Summer of Haskell results will be released?
05:01:53 <HaskellNode> hello
05:02:45 <HaskellNode> is the Parallel Haskell official?
05:03:09 <maerwald> ggVGc: well, imagine you want to have a pure environment (e.g. a database connection, as in: the meta-info for that), but also be able to run IO actions in that context. Now you could do everything within IO, but then you somewhat lose composability. Instead you could use a modified version of the Reader monad. E.g https://hackage.haskell.org/package/mongoDB-2.0.10/docs/Database-MongoDB-Query.html
05:03:27 <maerwald> see the Action type
05:03:45 <HaskellNode> good answer
05:03:47 * hackagebot stack-prism 0.1.5 - Stack prisms  https://hackage.haskell.org/package/stack-prism-0.1.5 (MartijnVanSteenbergen)
05:03:51 <maerwald> this allows more nice composability of actions, compared to just doing plain IO everywhere
05:04:54 <maerwald> similarly, some people want pure state (as in State monad), but also have access to true IO... then you'll also go with some StateT thing
05:05:06 <ggVGc> hm, yeah
05:05:10 <HaskellNode> I also want t ask
05:05:23 <HaskellNode> ask to professional about
05:05:27 <ggVGc> maerwald: I might just rewrite it though to be separate
05:05:32 <ggVGc> because it's less mental baggage
05:05:38 <maerwald> that might work too
05:05:46 <maerwald> I think transformers are overused
05:06:17 <ggVGc> maerwald: my reasoning is by not using monad transformers until I stumble upon a situation where I'm reallky stuck, my code will be simpler and easier to manage
05:06:43 <HaskellNode> in parallel haskell does it make operating system native thread for exploiting multicore cpus?
05:06:54 <ggVGc> HaskellNode: haskell threads are not OS threeads no
05:06:57 <ggVGc> unless you use forkOS
05:07:03 <ggVGc> which is almost never what you want to do
05:07:32 <jasonmason> but they do take advantage of multiple cores if you compile with right flags
05:07:38 <ggVGc> HaskellNode: haskell threasds are much lighter weight than what's involved for spawning a real OS thread, which gives better concurrency
05:07:50 <ggVGc> but less parallellism, which usually doesn't matter
05:08:01 <ggVGc> jasonmason: yeah but the point is to not manage that yourself afaik
05:08:14 <ggVGc> the runtime does it bette
05:08:15 <ggVGc> r
05:08:36 <jasonmason> the point of his question seemed to have been whether multiple cores are being utilized
05:08:42 <ggVGc> ah, right
05:08:50 <HaskellNode> i mean does it make kernel mode thread?
05:08:51 <HaskellNode> both in windows and linux?
05:08:51 <HaskellNode> can someone answer if one knows about both operating system quite well?
05:08:52 <HaskellNode> as well as haskell parallel inner working?
05:09:55 <HaskellNode> ok haskell threads are sort of user threads from that i can assuming
05:10:12 <puregreen> I believe that if you do forkIO, you create a new green thread, which will be assigned to one of the actual threads (if the program is compiled with -threaded and run with -N)
05:10:25 <maerwald> yeah
05:10:37 <puregreen> e.g. if you run it with -N4, then 4 threads will be created and each will be running some number of green threads
05:10:43 <maerwald> also see https://stackoverflow.com/questions/5847642/haskell-lightweight-threads-overhead-and-use-on-multicores
05:10:51 <puregreen> if you do forkOS, an actual ‚Äúkernel thread‚Äù will be created, yeah
05:11:00 <ggVGc> HaskellNode: there are multiple layers. Even if you create an OS thread from C, you can't be sure that you got an actual hardware thread from the kernel
05:11:13 <ggVGc> so no, haskell can not assure you you are getting kernel threads
05:11:15 <ggVGc> afaik
05:11:26 <ggVGc> OS threads are also not mapped directly to hardware ones
05:12:02 <HaskellNode> in case of calling parallel 
05:12:02 <HaskellNode> in the case, does haskell spawn os thread?
05:12:03 <HaskellNode> maybe you're talking for the case of that haskell is spawning normal ordinary threads.
05:13:06 <HaskellNode> but what about the case of the later one? when  it's spawning using parallel functionality?
05:13:11 <puregreen> actually, wait. What's a hardware thread? In fact, out of ‚Äúhardware thread, kernel thread, OS thread, thread created by forkOS‚Äù, how many of these are actual things and how many of these are different names for the same thing?
05:13:39 <ggVGc> puregreen: kernel thread and OS thread would be the same thing imo
05:13:50 <ggVGc> hardware thread would be what's running on an actual core
05:13:59 <ggVGc> of which you probably only have 2-8
05:14:04 <ggVGc> which is why we need OS threads
05:14:08 <ggVGc> and a scheduler
05:14:24 <ggVGc> but then afaik haskell also has it's own scheduler and lightweight threads, which are in turn mapped to OS threads as needed
05:14:36 <ggVGc> but getting an actual hardware thread explicitly from any OS seems hard
05:14:50 <ggVGc> pretty sure all OS'es take the liberty to control that completely
05:17:00 <ggVGc> HaskellNode: why is this important to you?
05:17:33 <HaskellNode> oh my point is exactly about multicore usage of haskell
05:17:46 <HaskellNode> I should have been talking about my point first
05:17:49 <ggVGc> HaskellNode: why is it important which hardware cores are being used?
05:18:37 <HaskellNode> my point is that 
05:18:57 <ggVGc> HaskellNode: ther's a difference between concurrency and parallellism. Parallellism is "things actually running at the same time, on different hardware cores", while concurrency is "THings running concurrently, but not necessarly all at once". Usually we only really care about the latter since it gives us the same end result
05:19:11 <HaskellNode> I know already about it
05:19:27 <ggVGc> haskell is very good at concurrency, and has a great scheduler and very lightweight threads. But it might not run on more than one core anyway
05:19:34 <HaskellNode> i mean does haskell exploit operating system multicore scheduling
05:19:38 <ggVGc> yes
05:19:44 <HaskellNode> yes right?
05:20:27 <ggVGc> HaskellNode: when compiling you can set how many cores you want to use, or have the runtime decide it, using "-threaded -rtsopts -with-rtsopts=-N"
05:20:33 <ggVGc> I think that's the correct flags
05:20:58 <HaskellNode> i see
05:21:05 <ggVGc> HaskellNode: and then the lightweight threads will be put onto those OS threads as neede by haskells scheduler
05:21:07 <HaskellNode> thank u for answer :)
05:21:29 <ggVGc> HaskellNode: you can also force haskell to put something on an OS thread using forkOS, but as I said that's almost never a good idea
05:21:36 <HaskellNode> <puregreen> e.g. if you run it with -N4, then 4 threads will be created and each will be running some number of green threads <-- best answer too
05:21:40 <ggVGc> since haskell does a better job at putting things where they should run
05:21:49 <HaskellNode> I was in bad connection saw it too late :)
05:22:19 <HaskellNode> 4 threads are maybe os threads
05:22:33 <ggVGc> HaskellNode: but I think erlang has better parallellism than haskell, if that's what's iumportant to you
05:22:34 <HaskellNode> and green threads are for vm of haskell
05:22:40 <ggVGc> i.e if you had 100 cores, I think an erlang program would run better
05:22:50 <ggVGc> if it's highly concurrent
05:23:25 <ggVGc> HaskellNode: exactly, but it's better to use the green threads, since haskell will then manage which OS threads they should run on based on their resource usage
05:23:31 <ggVGc> which is better than you managing that manually
05:24:44 <HaskellNode> hmm concurrent module for parallel operation is coming out not long ago  
05:24:44 <HaskellNode> it took 2 days for understanding underlying concept :)
05:25:21 <HaskellNode> erlang, i haven't considered
05:26:16 <ggVGc> HaskellNode: if you have a piece of software that's essentially a bunch of small modules running at the same time and occasionally exhanging data, then erlang is probably a better choide than haskell
05:26:21 <ggVGc> at least today
05:26:42 <HaskellNode> I just want to rely on operating system kernel threads scheduling to exploit multi cores
05:26:58 <ggVGc> by the design of erlang a program will scale from 5 cores to 500 essentially linearly
05:27:05 <ggVGc> I don't think that's stru for haskell
05:27:41 <ggVGc> but for high concurrency on smaller amount of cpu's, I think haskell is bette
05:27:45 <HaskellNode> haskell and elrang are same from the point of view
05:27:56 <ggVGc> how so?
05:28:01 <HaskellNode> because,
05:28:02 <ggVGc> they have vastly different concurrency models
05:28:39 <HaskellNode> it is because i'm talking about concurrency model that exploits multi core cpus
05:28:45 <HaskellNode> from that point of view,
05:28:47 * hackagebot lifted-async 0.9.0 - Run lifted IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/lifted-async-0.9.0 (MitsutoshiAoe)
05:28:54 <HaskellNode> all must rely on operating system
05:29:37 <HaskellNode> so in my opinion performance of multi threading using every cores of cpu is 
05:29:45 <HaskellNode> all the same from
05:29:49 <HaskellNode> haskell and erlang
05:30:20 <HaskellNode> because i think it rely on operating system totally
05:32:28 <HaskellNode> so haskell seems to use operating system scheduling for threading that uses all cores of a cpu
05:33:48 * hackagebot JsonGrammar 1.0.4 - Combinators for bidirectional JSON parsing  https://hackage.haskell.org/package/JsonGrammar-1.0.4 (MartijnVanSteenbergen)
05:34:50 <HaskellNode>  green thread is user thread
05:38:48 * hackagebot haskell-gi 0.17.2 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.17.2 (inaki)
05:41:36 <HaskellNode> but for high concurrency on smaller amount of cpu's, <- give credit for this
05:42:31 <HaskellNode> Haskell's threads (the ones spawned by forkIO) mapped to OS threads.
05:45:21 <HaskellNode> if this is true, parallelism of haskell is possible by forkIO running threads in parallel using full cores of a cpu.
05:45:52 <puregreen> HaskellNode: what exactly are you arguing for?
05:46:16 <HaskellNode> about
05:47:04 <HaskellNode> explicit automatic parallel module and its grammar in haskell language like java8 parallel stream does !
05:47:45 <HaskellNode> and using all cores in parallel 
05:48:47 <HaskellNode> https://wiki.haskell.org/Haskell_for_multicores but i found good info from wiki already
05:50:16 <HaskellNode> i was too psyco geeky for last one week and I started to learn haskell, it's the most elegant functional language i have found so far
05:50:39 <HaskellNode> i considered scala but it was not good choice.
05:51:54 <hodapp> be fair to Scala... it tries to solve a really ugly problem.
05:51:58 <HaskellNode> scala is to verbose and java8 already do better
05:52:25 <HaskellNode> scala is good from its mixture of concepts
05:52:32 <hodapp> I found it nowhere near as verbose as Java
05:52:33 <HaskellNode> however too verbose 
05:53:18 <HaskellNode> but in case of java the most of people were using from the past
05:53:38 <HaskellNode> so people used to be, so it's not hard learning java 8 
05:53:58 <HaskellNode> java is considered to be almost nearly close to c++ nowadays
05:54:06 <hodapp> by... who?
05:54:57 <hodapp> whoa, people use GObject in conjunction with Haskell?
05:56:20 <HaskellNode> haskell has possibility for gaining popularity from people
05:56:20 <HaskellNode> because of its elegance of haskell .. 
05:56:58 <hodapp> this might be the sort of thing to take to #haskell-blah
05:56:58 <HaskellNode> by the most of ... users on the net?
05:57:32 <HaskellNode> right :)
06:00:42 <HaskellNode> askell implementations have a light-weight thread system that schedules logical threads on the available operating system threads <-- i found haskell threading is different i should study more
06:02:58 <Aruro> how do i create unique file names in haskell? suppose i want to store tons of pictures, and make a database out of it.
06:03:11 <hodapp> HaskellNode: perhaps read http://community.haskell.org/~simonmar/papers/multicore-ghc.pdf
06:03:24 <HaskellNode> thanks for help
06:03:31 <HaskellNode> helpful
06:04:34 <HaskellNode> this is what is was looking for
06:05:32 <hodapp> good
06:09:10 <hodapp> Aruro: well, you can always construct them from timestamps or random numbers or a combination
06:09:25 <hodapp> or use a StateT in some fashion to just generate sequential numbers
06:09:32 <HaskellNode> so philosophy of haskell is more on concurrency on one core, -> not more on parallelism... 
06:10:57 <hpc> huh?
06:12:12 <HaskellNode> no cancel this then all language goes in this way then.. sry
06:12:41 <hpc> so basically, concurrency is about semantics
06:12:55 <hpc> something like node which has async semantics in a single thread is concurrent
06:13:05 <HaskellNode> concurrency software and is algorithm on one cpu
06:13:11 <HaskellNode> time sharing
06:13:16 <hpc> something like par/pseq which has your usual semantics with multiple simultaneous computations is parallelism
06:13:25 <hpc> most traditional uses of either also has the other
06:13:28 <hpc> like fork()
06:13:30 <HaskellNode> wow yes that
06:13:39 <HaskellNode> par/ pose thing 
06:13:58 <hpc> where haskell departs from most languages is in the variety and power of its concurrency/parallelism primitives
06:14:06 <hpc> and their interaction with the language features in favorable ways
06:14:12 <HaskellNode> what i learn from is forksos and forkio()
06:14:19 <hpc> such as trivial information sharing between threads thanks to immutability
06:14:47 <HaskellNode> yes
06:15:36 <hpc> ghc's implementation uses a bunch of levels of indirection between what you will most commonly interact with as a "thread" and a POSIX (or OS) thread
06:15:44 <HaskellNode> power of its concurrency/parallelism primitives <-- i didn't understand cleary i would like to hear more details
06:16:11 <hpc> lightweight threads get automatically mapped between capabilities which get automatically mapped to OS threads which get automatically mapped to processor cores
06:16:14 <hpc> or something like that
06:16:35 <HaskellNode> wow!!! this is it
06:16:47 <HaskellNode> thank you
06:16:51 <hpc> don't quote me on that part, i don't understand it as well as some others do
06:16:58 <hpc> so, for primitives
06:17:05 <HaskellNode> yes
06:17:18 <hpc> there's par/pseq, which you will find in https://hackage.haskell.org/package/parallel-3.2.1.0/docs/Control-Parallel.html#v:par
06:17:35 <HaskellNode> ok
06:17:52 <hpc> those attach parallel operational semantics to pure denotational semantics (to put it in big words)
06:18:07 <hpc> to put it in little words, it computes pure values in parallel without having to resort to IO
06:18:24 <HaskellNode> elegant one
06:18:39 <hpc> it's very specific and narrow in what it does, so you get a lot of guarantees out of it
06:18:56 <hpc> on the other end of primitives, you have https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent-MVar.html
06:19:10 <hpc> which to put it simply is a mutable thread-safe Maybe
06:19:11 <HaskellNode> ok
06:19:25 <hpc> to manipulate an MVar, you take the value in it (leaving it empty)
06:19:29 <hpc> do some work to it, then put it back
06:19:36 <hpc> taking blocks when the MVar is empty
06:19:41 <hpc> and putting blocks when the MVar is full
06:20:04 <HaskellNode> good to hear
06:20:06 <hpc> so it behaves as a locking mechanism without the boolean blindness of "there's a value in here, oh and also it's locked"
06:20:14 <hpc> either there's something there to manipulate, or there isn't
06:20:33 <hpc> which is much easier to reason about and stops bugs when people bypass the api
06:20:35 <HaskellNode> locking is too old
06:20:40 <hpc> (because there is no bypass)
06:20:55 <hpc> there's also STM, or software transactional memory
06:21:14 <hpc> instead of locking and blocking, everything tries to happen at once and when a transaction fails it gets retried
06:21:17 <HaskellNode> i don't know about it i just start to look
06:21:30 <hpc> transactions have to be pure, or retrying will have side effects
06:21:55 <HaskellNode> is it like something in sql ?
06:21:56 <hpc> STM is here: https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM.html
06:22:06 <hpc> it's like SQL's transactions, yes
06:22:11 <HaskellNode> i see
06:22:19 <hpc> transactions are a general concept which both relational databases and STM use
06:22:36 <hpc> although it's complicated for SQL because sometimes there is some locking going on
06:22:37 <HaskellNode> thank u by the way
06:22:41 <hpc> relational engines are complicated
06:23:16 <hpc> so on top of both MVar and TVar are Chan and TChan
06:23:21 <hpc> which are threadsafe queues of values
06:23:30 <hpc> putting never blocks, and just adds it to the queue
06:23:39 <hpc> taking never blocks, except for when the queue is empty
06:23:56 <hpc> so you can define concurrent / parallel computational pipelines very easily
06:24:15 <HaskellNode> that's good one also
06:24:17 <hpc> i have used Chan in the past for thread pooling and work stealing
06:24:17 <int-e> puregreen: thanks, I'll think about it. ironically I spent several hours yesterday on lambdabot's travis configuration...
06:24:28 <hpc> one thread pushes (IO ()) jobs, and multiple threads consume them
06:24:48 <hpc> and those are the basics
06:24:56 <HaskellNode> i might look at it :)
06:25:55 <hpc> i recommend looking at the whole concurrency/parallelism sections on hackage
06:26:05 <hpc> as there's a lot more there, and it's very well documented
06:26:10 <HaskellNode> ok
06:26:50 <cocreature> there is also the excellent book ‚Äúparallel and concurrent programming in haskell‚Äù
06:26:58 <cocreature> it‚Äôs available online for free
06:27:05 <hpc> ooh neat
06:27:18 <cocreature> @where parallel
06:27:18 <lambdabot> http://www.haskell.org/haskellwiki/Parallel
06:27:32 <cocreature> nope that‚Äôs not it
06:27:34 <cocreature> here it is http://chimera.labs.oreilly.com/books/1230000000929/index.html
06:27:54 <HaskellNode> https://wiki.haskell.org/Haskell_for_multicores this is best place to start
06:29:28 <cocreature> I‚Äôm slightly cautious when it comes to the wiki. often things are out of date or at least slightly weird
06:30:10 <HaskellNode> good info :)
06:42:14 <Haskeller> so haskell seems to run light thread on all cores by default?
06:43:16 <Haskeller> by default does haskell spawn several os thread on top and spawn light threads under the root os os threads. what i understood is right?
06:50:34 <chris__> Wohoo managed to connect to this! Hello haskellers! :)
06:50:46 <Haskeller> hello
06:50:58 <Haskeller> are you computer?
06:52:00 <chris__> As in a bot? No. Not yet!
06:52:19 <Haskeller> your not bot?
06:53:15 <chris__> No I'm not a bot!
06:53:16 <chris__> Are you?
06:53:44 <smart_water> hi chris__
06:53:47 <Haskeller> n
06:53:57 <pavonia> Not yet? Do you plan to become a bot one day? :)
06:54:19 * puregreen would very much like to become a bot if the alternative is dying from old age
06:55:07 <Haskeller> does haskell spawn several os threads by default when it run light threads?
06:55:15 <chris__> No plans yet but I need to leave room for the potential! :P
06:55:55 <puregreen> Haskeller: it only spawns several OS threads if you compile with -threaded and run with -N (or -N<number>)
06:56:06 <Haskeller> then
06:57:10 <Haskeller> if i don't give the option then it spawns several os threads only on one core?
06:57:28 <puregreen> if you don't give the option, it doesn't spawn threads at all
06:57:45 <puregreen> and threads are distributed between the cores by OS, not by Haskell's RTS
06:57:59 <Haskeller> then haskell just spawns light threads
06:58:24 <Haskeller> i know that fact
06:58:52 * hackagebot hills 0.1.2.2 - Generate STL models from SRTM elevation data.  https://hackage.haskell.org/package/hills-0.1.2.2 (djf)
06:58:57 <puregreen> by the way, I just found out that if you do +RTS -qa, then the OS threads can be pinned to CPU cores
06:59:06 <Haskeller> hmm
06:59:36 <chris__> Cheers everyone! Thanks for being awesome!
06:59:37 <chris__> :q
07:01:12 <puregreen> Haskeller: light threads are managed by Haskell's RTS. You can always spawn light threads, even if you haven't used -threaded and there's only one OS thread. If you have used -threaded and there are several OS threads, then light threads are distributed between OS threads by Haskell's RTS. The OS doesn't know anything about light threads. OS threads are distributed between cores by the OS, and usually you don't care about how
07:01:12 <puregreen> it happens or whether several threads are run on one core or not.
07:01:47 <Haskeller> yes this is what i would like to know
07:01:55 <Haskeller> rts...
07:02:25 <scshunt> run-time system
07:02:31 <Haskeller> then it is
07:03:31 <Haskeller> in other words, one single os thread of haskell's rts spawns other light threads if there's any given options and by default right? 
07:03:52 * hackagebot testbench 0.1.0.0 - Create tests and benchmarks together  https://hackage.haskell.org/package/testbench-0.1.0.0 (IvanMiljenovic)
07:05:00 <Haskeller> puregreen/ how do you know about haskell so very well, amazing. good to ask
07:07:44 <Haskeller> there's -> there isn't
07:33:07 <Stanfarmer> even c-- unknown language is used for haskell runtime
07:35:35 <newcomer> obadz, you said that, and I'm paraphrasing, when you implement operators "pointing to the right" you make them left associative.  This makes something like "arg $ f >>> g" not work properly if $ and >>> are left associative. right? 
07:47:00 <obadz> newcomer: $ 'points to the left'
07:48:55 * hackagebot gstreamer 0.12.8 - Binding to the GStreamer open source multimedia framework.  https://hackage.haskell.org/package/gstreamer-0.12.8 (HamishMackenzie)
07:53:16 <newcomer> obadz, now I'm confused as to the meaning of "pointing" left or right.
07:53:40 <obadz> newcomer: it's not super well defined but I mean direction of data flow
07:53:48 <obadz> newcomer: in my ops, $  is the same as <<|
07:54:04 <obadz> newcomer: (in ML that operator is <|)
07:54:38 <Stanfarmer> i do not find good papers about hugs runtime system
07:55:07 <obadz> Stanfarmer: any particular reason not to look at ghc?
07:55:41 <geekosaur> apparently C-- is unhallowed and not permissible
07:56:13 <Stanfarmer> hog runtime and gcc are different story
07:56:18 <Stanfarmer> ghc
07:58:02 <newcomer> Oh, I've been asking the wrong question all along. I meant "arg & f >>> g" not "arg $ f >>> g".
08:01:09 <geekosaur> and I don't quite see where C-- comes into it since it's just a compiler intermediate / "high level assembler" and the only things written in it directly are glue routines
08:02:02 <pavonia> Is there a cleverer way to get the list of all strings that can be made of the characters A to Z than concatMap (\i -> sequence $ replicate i ['A' .. 'Z']) [1..]?
08:03:55 <Stanfarmer> i don't even understand what is c-- it's full of microwaves :(
08:04:29 <geekosaur> o.O
08:05:52 <Stanfarmer> it os not language c--
08:06:59 <ClaudiusMaximus> > let pavonia = "" : [ c : cs | cs <- pavonia, c <- ['A'..'C'] ] in unwords pavonia -- different ordering though
08:07:01 <lambdabot>  " A B C AA BA CA AB BB CB AC BC CC AAA BAA CAA ABA BBA CBA ACA BCA CCA AAB B...
08:07:42 <pavonia> The ordering is important in my case
08:09:04 <ClaudiusMaximus> pavonia: Control.Monad.replicateM is sequence combined with replicate, saves a few chars
08:11:02 <pavonia> Okay, thanks
08:19:18 <int-e> > unwords $ [1..] >>= flip replicateM "ABC"
08:19:20 <lambdabot>  "A B C AA AB AC BA BB BC CA CB CC AAA AAB AAC ABA ABB ABC ACA ACB ACC BAA BA...
08:23:51 <Stanfarmer> is lambdabot a bot made in haskell?
08:24:04 <srhb> Stanfarmer: Yes.
08:24:16 <Stanfarmer> give plus
08:25:08 <puregreen> lambdabot++
08:25:10 <Stanfarmer> i had made ping pong with python long tim ago
08:25:31 <Stanfarmer> now learning haskell
08:25:40 <alexv11> Is there IRC channel for stack?
08:25:55 <srhb> alexv11: #haskell-stack
08:47:00 <nmattia> hi guys, it is possible to link a single haskell module against a package in order to load it with `loadObj`?
08:47:49 <nmattia> ghc docs says that when building with `ghc -package <my-package> Foo.hs` Foo.o will be linked against <my-package>, unfortunately in my case nm shows there are unresolved symbols
08:48:57 <geekosaur> you forgot -c to prevent final link
08:49:02 * hackagebot cmark 0.5.2.1 - Fast, accurate CommonMark (Markdown) parser and renderer  https://hackage.haskell.org/package/cmark-0.5.2.1 (JohnMacFarlane)
08:49:51 <nmattia> doesn't -c make the compilation stop before the linker step?
08:50:13 <geekosaur> although in that case you may not be able to do it at all (insufficient control over linking), in which case you would need to attempt the link with -v to see what link line it's building, and then do that manually without the other libraries and adding -r 
08:50:16 <nmattia> in my case `Foo.hs` doesn't have a main, so should be compiled as an executable
08:51:21 <nmattia> didn't even think of turning verbose on; the linking step is bypassed because there is no (main) exported
08:51:27 <nmattia> thanks a lot
08:52:41 <geekosaur> (C is actually no better in this regard; you have to resort to running ld directly)
08:53:16 <hardmath123> Hi, I have a question about Diehl's article http://dev.stephendiehl.com/fun/006_hindley_milner.html#substitution
08:53:36 <hardmath123> He defines a function "fresh" that returns a fresh variable name each time.
08:53:38 <geekosaur> come to think of it, you could use ghc-pkg to extract the link info for the package, then "ghc -c -package" and "ld -r -o"
08:53:42 <hardmath123> Can someone please explain how that works?
08:53:45 <sgt_sniff> is there an easy way to toggle ghc-mod inside (spac)emacs? I have to turn it off to get emacs to load ghcjs compiled files without crashing 
08:54:40 <ertes> hi there
08:54:43 <AdituV> hi
08:55:15 <AdituV> is it possible to have a local copy of the haddock for a dependency under stack?  In my case, I'd like a local copy of the Turtle docs
08:55:36 <ertes> is there a way to check whether an IOException corresponds to a unix error and, if yes, extract the errno?
08:56:38 <hsk3> I am supposed to write lift for StateT myself in an exercise:
08:56:39 <hsk3> instance MonadTrans (StateT s) where
08:56:40 <hsk3>    lift = ...
08:56:41 <hsk3> The problem is, I have done "import Control.Monad.Trans.State" and "import Control.Monad.Trans.Class" which means that instance is already available.
08:56:42 <hsk3> Can I do "import Control.Monad.Trans.Class" without that particular instance?
08:56:46 <ertes> background: i'm writing a library for programming smarter error responses, like: if there was a network timeout, don't die, but retry after a short delay‚Ä¶  unfortunately the information i need is not reflected by IOException, unless i do something very dirty: string matching
08:57:28 <geekosaur> hsk3, no, instances are always imported, you cannot prevent it
08:59:16 <geekosaur> ertes, not in the public interface, but if you import GHC.IO.Exception then you can get at IOError {ioe_errno :: Maybe CInt}
08:59:46 <ertes> geekosaur: thanks, is that portable across the major operating systems?
09:00:30 <geekosaur> I think so? errno is ANSI C
09:00:45 <ertes> i'll try that‚Ä¶  thanks a lot!
09:02:04 <geekosaur> that said, if you're doing network stuff then you may have issues because networking itself is not portable in its lower level APIs. but for this purpose I think it should be good enough (read: network errors should be exposed to ghc the same way)
09:04:33 <geekosaur> hsk3, I think you're supposed to be reimplementing the whole thing yourself; previous exercises should have had you implement the pieces you need, work from those instead of the predefined ones
09:04:42 <nmattia> geekosaur: that did the trick, thanks. took some time to figure out where stack hides the packages though.
09:04:43 <hsk3> geekosaur: yeah you're right.
09:04:45 <hsk3> thank you
09:05:28 <nmattia> geekosaur++
09:05:31 <nmattia> is that a thing?
09:05:36 <geekosaur> not really, here
09:05:41 <ertes> geekosaur: unfortunately i see no better way to do it‚Ä¶  even the full IOErrorType from GHC.IO.Exception is too vague to be useful here
09:06:47 <geekosaur> (I mean, if we tracked karma, it'd just be a game of the haves and the have-nots and Id have an artificially high karma just because I'm often around and have some free time when others are busy >.> )
09:08:50 <monochrom> @karma geekosaur
09:08:51 <lambdabot> geekosaur has a karma of 31
09:09:04 <monochrom> @karma monochrom
09:09:05 <lambdabot> You have a karma of 116
09:09:14 <ertes> (FWIW IIRC lambdabot does track karma, but i'm not a big fan of that feature‚Ä¶  it turns IRC into the same kind of role-playing game that is stackoverflow)
09:09:26 <geekosaur> nobody does ++ to speak of. I think if I dug in channel hiustory I'd find most of those are back to 2009 or so :p
09:09:40 <nitrix> I prefer Thank You.
09:09:48 <geekosaur> and yes, that's pretty much what I meant about game of the haves and have-nots
09:10:23 <puregreen> I prefer ‚Äú++‚Äù, it's fun and it feels like it's more sincere than ‚Äúthank you‚Äù (maybe because I see ‚Äúthank you‚Äù being used way too often)
09:10:37 <hexagoxel> @karma+ lambdabot
09:10:37 <lambdabot> lambdabot's karma raised to 31.
09:10:54 <nitrix> Only 31?! Boot him.
09:11:01 <nitrix> We don't need peons.
09:11:39 <puregreen> @karma nitrix
09:11:40 <lambdabot> nitrix has a karma of 8
09:11:45 <nitrix> ;-;
09:11:52 <nmattia> oh well, thanks anyway :)
09:12:41 <ertes> > karma ertes
09:12:43 <lambdabot>  Who cares!
09:12:43 <monochrom> it is ok to use ++ whether you care about the @karma record or not. it is a common idiom over all IRC
09:12:49 <jasonmason> @karma jasonmason
09:12:49 <lambdabot> You have a karma of 0
09:13:05 <jasonmason> at least it isn't negative
09:13:32 <nitrix> monochrom: I wish it'd pick up nick++ not just @karma++
09:13:40 <monochrom> it does
09:14:05 <hardmath123> beep boop, i think my question got buried
09:14:11 <AdituV> @karma- AdituV
09:14:11 <lambdabot> You can't change your own karma, silly.
09:14:15 <hardmath123>  http://dev.stephendiehl.com/fun/006_hindley_milner.html#substitution <-- how does the "fresh" variable name generation work?
09:14:16 <geekosaur> actually I'm composing an answer, please hold
09:14:18 <ertes> @karma ertes
09:14:18 <AdituV> .
09:14:19 <lambdabot> You have a karma of -5
09:14:26 <hardmath123> oh thanks geekosaur 
09:14:43 <geekosaur> hardmath123, a TVar here is just an entry in a map. unique variables are generated by means of a State with a counter in it, which is incremented for each new variable needed
09:15:43 <geekosaur> the map lives in a TypeEnv
09:16:09 <hardmath123> yeah, i guess the part i really don't understand is how the unique-variable-generation-with-the-counter works
09:16:28 <hsk3> I know monad transformers can sometimes be quite deep, i.e., composed of lots of other monad transformers and monads.
09:16:28 <hsk3> But isn't it true in 99% of real-world use cases that: (1) Once these thing have been constructed, the programmer doesn't have to worry much about it anymore, and (2) things "just work" exactly as intuitively makes sense anyway.
09:16:29 <hsk3> ?
09:16:35 <monochrom> it uses State.
09:16:43 <hardmath123> geekosaur: for example, what does s{count = count s + 1} do?
09:16:53 <monochrom> yes hsk3
09:17:04 <hardmath123> because "count" isn't actually defined above that
09:17:14 <ertes> hsk3: ideally you use some something like effect classes, so the only part where you need to worry is the part where you actually run* the different layers
09:17:39 <hsk3> monochrom: ok thanks
09:17:41 <ertes> hsk3: like this:  myAction :: (MonadState S m) => A -> B -> m C
09:17:41 <geekosaur> that's a record update. `s` is a record with a field named count. `s { count = count s + 1}` might be written in another language as: new_s = s; new_s.count = s.count + 1
09:17:58 <hsk3> cool
09:18:05 <hsk3> my confidence is boosted again
09:18:11 <ertes> hsk3: that's what mtl adds to transformers
09:18:11 <hsk3> well, no
09:18:14 <hsk3> it's LIFTED lol
09:18:33 <ertes> ;)
09:18:43 <hardmath123> oooh, i see that makes sense
09:19:08 <monochrom> haha
09:19:40 <geekosaur> and the definition actually comes later
09:19:55 <geekosaur> data InferState = InferState { count :: Int }
09:20:06 <hardmath123> hmm
09:20:06 <monochrom> except there is no Unique
09:20:20 <geekosaur> imn the section "Constraint Generation"
09:20:52 <geekosaur> likewise Infer is defined there despite being used earlier
09:21:14 <monochrom> because in this section we're seeing "State Unique". but Unique doesn't exist.
09:21:43 <hardmath123> mmm, this is pretty clever
09:21:49 <monochrom> and worse, it is flip-flopping from "type Infer a = ExceptT TypeError (State Unique) a" to "type Infer a = RWST etc etc"
09:22:10 <hardmath123> i'm trying to do something similar in a purely-functional subset of Racket
09:22:21 <hardmath123> and i thought looking at a haskell implementation would help
09:23:31 <geekosaur> I am not sure I'd have followed that logic. then again, if you went to the source you'd be looking at the Prolog implementation, which almost certainly would not be an improvement >.>
09:24:03 * hackagebot git 0.1 - Git operations in haskell  https://hackage.haskell.org/package/git-0.1 (VincentHanquez)
09:24:52 <hardmath123> i wouldn't have minded a prolog implementation, actually
09:25:56 <AdituV> I'd like a local copy of the haddocks to turtle.  It's a dependency for my project under stack; is there any way I can access them directly like that?
09:26:11 <hardmath123> i'm just trying to find a way to avoid passing around a "fresh-variable-counter" parameter in every single function
09:26:29 <geekosaur> right, that's what the State monad is for
09:26:49 <geekosaur> and it's buried in the Infer monad, wjhich also carries around the typechecking environment
09:27:23 <ertes> hardmath123: not sure if you can do that nicely in racket though, because the convenience of state monads depends a lot on syntactic features of haskell
09:27:28 <hardmath123> this is very cool. i'm wondering if it's feasible to implement this machinery in Racket without too mcuh trouble.
09:27:49 <hardmath123> ertes: presumably racket-macros are advanced enough to model some of that convenience?
09:28:12 <ertes> hardmath123: since state monads are just a thin layer around ordinary functions, you can definitely implement it
09:28:32 <geekosaur> well, you have to carry around the typechecking environment anyway and the unique counter is just stored in that
09:29:22 <ertes> hardmath123: not sure‚Ä¶  if you can "linearise" your code, such that you don't keep opening parentheses with every monadic bind, then it should be nice enough
09:29:33 <ertes> macros probably allow you to do that
09:30:50 <ertes> hardmath123: if you can't do that nicely, there is another model to generate fresh names that isn't stateful:  you introduce a hierarchy of names
09:32:16 <hardmath123> ertes: hmm, a hierarchy? in what sense?
09:32:40 <ertes> func ns = ... subfunc1 (1 : ns) ... subfunc2 (2 : ns) ...  -- where ns is a list of integers, such that 'func' can freely generate new variable names as long as they are suffixed by ns
09:33:06 <ertes> like domain names, basically
09:33:57 <ertes> and it can pass subdomains to other functions, so those can freely generate names in their subdomains
09:35:01 <ertes> disadvantage: depending on your level of nesting/recursion the names can get very long‚Ä¶  to fix that you can use a post-processing step that renames every existing variable name to a single number
09:35:53 <hardmath123> ah, okay, this is what i had earlier -- a "variable name" was actually just a list of all the parameters to the function that requires the variable name, with the hope that this would be a unique fingerprint
09:35:59 <hardmath123> which is obviously very, very ugly
09:36:36 <ertes> if you need to expose those raw names to users, then yes, it's ugly‚Ä¶  you really need post-processing, if you do that
09:36:50 <hardmath123> in this case, however, these variable names will be processed symbolically, so you get a big performance hit
09:37:22 <hardmath123> because then the symbolic execution generates ridiculous formulas trying to compare long lists
09:37:29 <ertes> well, one thing you can do is to 'flatten' at certain key points
09:38:32 <ertes> flatten :: [[Int]] -> HashMap [Int] Int  -- given a list of qualified names, construct a mapping from each qualified name to a simple name
09:39:16 <ertes> given a.x.y, k.b.x.y, l.b.x.y, c.x.y, it would rename those to 1.x.y, 2.x.y, 3.x.y, 4.x.y
09:40:07 <ertes> the state monad is a lot simpler, but if you can't make them nice with macros, this is what i would do ‚Äì probably
09:40:28 <ertes> s/monad is/monads are/
09:40:29 <hardmath123> i'm going to try the state monad; if nothing else, i'll learn a bunch about monads.
09:43:45 <ertes> hardmath123: you can't avoid global names altogether?
09:43:51 <ertes> as in de bruijn indices?
09:45:31 <hardmath123> ertes: sorry, what's a de bruijn index?
09:49:15 <ertes> hardmath123: you have a language with name binders, and you refer to those names
09:49:52 <ertes> but most of the time your binders are hiararchial, so instead of naming the variables, you refer to them by numbers, where 0 is the name of the variable from the innermost binder
09:50:00 <ertes> hierarchial
09:50:37 <ertes> binder: (binder: 0 + 1) + 0 ~ \x -> (\y -> y + x) + x
09:52:12 <hardmath123> hmm
09:53:20 <hardmath123> so this eliminates names in the lambda-expressions, but presumably you still need to spawn fresh names for H-M inference?
09:53:57 <ertes> i don't know how the H-M algorithm works, but since it's nominal, you probably do
09:54:45 <hardmath123> for H-M, you essentially assign a name for each thing-to-be-typed, and then solve constraints between those names through unification
09:54:45 <ertes> also for better UX you'd want to keep track of original names, too, but only as annotations, so you can show more sensible names to users
09:55:18 <ertes> indices only make programming the AST easier
09:55:47 <ertes> in particular most AST manipulation functions become stateless
09:57:19 <hardmath123> mm that sounds very nice. is there any literature on this style that you could recommend?
09:58:23 <ertes> for the basic de bruijn indices i found the wikipedia article good enough‚Ä¶  if you want to go all the way to an approach we call "locally nameless", search for "i'm not a number, i'm a free variable"
09:59:30 <ertes> it's the de-luxe method of handling binders and names =)
10:00:43 <geekosaur> (why did I know this was going to end up at de Bruijn indices? :p )
10:01:06 <ertes> geekosaur: because you knew you would do it that way ;)
10:01:20 <monochrom> because de Bruijn is a common way to avoid variable capture
10:01:36 <monochrom> and variable capture makes baby jesus cry
10:02:07 <dolio> de Bruijn doesn't prevent variable capture, though, it just has a different sort of variable capture you have to worry about.
10:02:28 <ertes> and locally nameless is a common way to avoid renumbering (the trade-off of de bruijn indices)‚Ä¶  renumbering makes adult jesus cry
10:02:39 <monochrom> haha
10:09:05 * hackagebot telegram-api 0.4.2.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.4.2.0 (klappvisor)
10:15:59 <lambdafan> can anyone point me to a project implementing the r*-tree and operations?
10:16:11 <int-e> :t Data.Generics.extM
10:16:12 <lambdabot> (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
10:16:57 <int-e> (I'm wondering why this has a Monad constraint)
10:19:57 <ertes> int-e: does it use 'fail' perhaps?
10:22:03 <dolio> What other constraint would it have?
10:23:53 <int-e> dolio: none
10:24:01 <dolio> So it works for any m?
10:24:06 <int-e> yes.
10:24:13 <int-e> :t Data.Generics.ext0
10:24:14 <lambdabot> (Typeable a, Typeable b) => c a -> c b -> c a
10:24:17 <int-e> it's built from that.
10:25:14 <int-e> using a newtype for c, newtype M m x = M { unM :: x -> m x }
10:26:05 <dolio> Dunno, then.
10:27:14 <dolio> If it's just doing casting, there's no reason, other than the comment says it's for 'monadic transformations'.
10:35:12 <davidkart> hi . I have some trouble in writing this function : possible w l= all( map (\x-> elem x l) w )
10:35:12 <davidkart> It is meant to check if every letter of w String is also in l String. It doesn't give the expected result though.
10:35:27 <davidkart> > possible w l= all( map (\x-> elem x l) w )
10:35:28 <lambdabot>  <hint>:1:13: parse error on input ‚Äò=‚Äô
10:35:34 <davidkart> let possible w l= all( map (\x-> elem x l) w )
10:35:45 <davidkart> > let possible w l= all( map (\x-> elem x l) w )
10:35:47 <lambdabot>  <no location info>:
10:35:47 <lambdabot>      not an expression: ‚Äòlet possible w l= all( map (\x-> elem x l) w )‚Äô
10:37:34 <AdituV> you don't need the map.  "all" is already a fold, going over the whole list of characters
10:38:02 <AdituV> so `all (\x -> elem x l) w` would do
10:38:45 <davidkart> thank you AdituV
10:42:26 <wardaft> So with GHC 8, what module does Type live? It's not in scope, even with TypeInType, and I can't find anything talking about it, since type is kind-of a heavily used word.
10:43:55 <jmcarthur> wardaft: Type is called *
10:44:14 <jmcarthur> wardaft: Int :: *
10:44:50 <AdituV> but in GHC8 isn't Type an alias for *?
10:44:57 <jmcarthur> Oh, it is?
10:44:59 <jmcarthur> I didn't know that.
10:45:10 <wardaft> It was supposed to be.
10:45:26 <AdituV> Yeah, I saw the announcement it would be but don't know the answer to the question, sorry
10:46:20 <wardaft> Aha, found it! It's in Data.Kind. And both * and Type do work.
10:47:16 <jmcarthur> Neat.
10:51:03 <jmcarthur> Found it in the manual. "The kind * classifies ordinary types. Without -XTypeInType, this identifier is always in scope when writing a kind. However, with -XTypeInType, a user may wish to use * in a type or a type operator * in a kind. To make this all more manageable, * becomes an (almost) ordinary name with -XTypeInType enabled. So as not to cause naming collisions, it is not imported by default; you must
10:51:05 <jmcarthur> import Data.Kind to get * (but only with -XTypeInType enabled)."
10:51:27 <jmcarthur> Doesn't mention Type, but it does say * isn't in scope by default with TypeInType enabled, which is interesting...
10:52:10 <jmcarthur> Ah, here: "The Data.Kind module also exports Type as a synonym for *. Now that type synonyms work in kinds, it is conceivable that we will deprecate * when there is a good migration story for everyone to use Type."
10:53:19 <scuttle_toes> \quit
10:56:46 <ggVGc> you guys ever get frustrated by matching up type signatures with parameter names in your head?
10:57:02 <jle`> how so?
10:57:08 <jmcarthur> ggVGc: I usually try to keep the number of arguments to a function low enough that that is never a problem.
10:57:28 <ggVGc> jmcarthur: yeah.. but sometimes it goes out of hand, and it's too much effort at the time to design away from it
10:57:39 <ggVGc> or the types are long
10:57:47 <ggVGc> especially when I deal with higher order functions
10:57:52 <jmcarthur> ggVGc: If I'm afraid of mixing them up, I use newtypes to label the arguments or use a record type to collect them all with names and reduce the number of arguments that way.
10:58:02 <ggVGc> hm, yeah, okay
10:58:07 <ggVGc> I should probably do that
10:58:27 <ggVGc> jmcarthur: mostly when it's a higher order function with more than one function being passed as an argument, I get lost occarionsally
10:58:48 <jmcarthur> I think it is generally worth the effort to make a function easy to understand, even if it seems annoying at the time.
11:00:21 <monochrom> there are haddock notation for commenting on each parameter type
11:00:56 <monochrom> even without haddock, you can do the same thing
11:01:24 <monochrom> you can break the type sig into multiple lines, one line per parameter type, and add a comment per line
11:01:40 <monochrom> inside the comment, you can mention the parameter name you will use
11:02:01 <monochrom> there are a million ways to document your code
11:02:37 <monochrom> because the comment mechanism is free form
11:02:55 <monochrom> only your imagination limits your explanation
11:03:17 <monochrom> but programmers tend to be the worst explainers indeed
11:03:50 <monochrom> good explainers tend to be recruited to better careers
11:04:42 <magneticduck> "programming" is a bad career, and good explainers are recruited away from it?
11:04:47 <magneticduck> maybe a certain definition of programming
11:05:59 <monochrom> you can also ask about my definition of "better"
11:06:28 <monochrom> there are a million ways you can rationalize disbelieving it if you want to disbelieve it.
11:06:51 <monochrom> all the same, programs are poorly documented, empirically
11:06:59 <monochrom> not only that
11:07:13 <ggVGc> I think it's fair to say programming is essentially a craft of love
11:07:18 <ggVGc> it's essentially masochism
11:07:21 <monochrom> you sit in this channel and see that questions and problem descriptions are poorly written too, empirically
11:07:26 <ggVGc> but we can't stop ourselves
11:07:45 <monochrom> programmers can't even write their problem specifications. so nevermind explaining solutions.
11:08:03 <ggVGc> monochrom: this is not a case of programmers as much as humans in general though. And oviously it's especially hard to formulate a question about something you don't already understand
11:08:11 <ggVGc> formulating good questions require a lot of practice
11:08:40 <magneticduck> perhaps monochrom is suggesting that people with those skills find other crafts
11:14:08 * hackagebot haskell-gi 0.17.3 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.17.3 (inaki)
11:17:50 <ggVGc> how would I write this more efficiently? https://gist.github.com/83a8e321c58a75e8fe968fb991b64f58
11:18:40 <jmcarthur> ggVGc: performance-wise or code-wise?
11:18:58 <ggVGc> jmcarthur: both/either
11:19:43 <dfeuer> ggVGc, I'd start with "perspicaciously". That code is very unclear.
11:19:56 <ggVGc> dfeuer: is it really?
11:20:00 <dfeuer> Uh-huh.
11:20:01 <jmcarthur> ggVGc: So you're trying to get the kth smallest result?
11:20:05 <ggVGc> I think it's very straightforward :(
11:20:10 <kadoban> ggVGc: You're sorting and then taking the ‚Ä¶ biggest? You should just take the maximum value instead
11:20:11 <dfeuer> You are wrong about that.
11:20:11 <ggVGc> jmcarthur: yeah
11:20:20 <ggVGc> dfeuer: what's unclear about it?
11:20:40 <jmcarthur> ggVGc: It's weird that m and i are not variables passed to that function.
11:20:46 <dfeuer> It's quite unclear what is what at any given time.
11:20:51 <kadoban> :t maximumBy
11:20:54 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
11:20:58 <dolio> Isn't the takeWhile pointless, if you just reverse the result and then get the first element in the reversed thing?
11:21:07 <dolio> Which is also the last element in the non-reversed thing?
11:21:09 <dfeuer> And I'd say `map third` is a bit scary.
11:21:14 <ggVGc> dfeuer: oh it was a piece taken out of context, sorry
11:21:37 <dfeuer> ggVGc, no, it's not the lack of context; it's the lack of names.
11:22:48 <jmcarthur> .... Is there really no total alternative to (!!) in Data.List?
11:23:13 <dolio> There really isn't.
11:23:19 <jmcarthur> Amazing.
11:24:44 <jxv> atMay from Safe is the closest
11:25:03 <ggVGc> dfeuer: Yeah. I think a lot in "pipes", hence why writing things like this is intuitive to me maybe
11:25:11 <ggVGc> or I'm just being a bit crap
11:25:35 <dolio> It doesn't seem hard to understand to me.
11:25:39 <ggVGc> kadoban: not sure how maximumBy will help me so much here?
11:25:41 <dolio> It's just a bunch of steps in order.
11:26:11 <jmcarthur> ggVGc: I don't think your compositional, point-free-ish style is the problem. It's things like "m", "i", "third", instead of meaningful names.
11:26:20 <ggVGc> dolio: maybe the takewhile is pointless, but I'm not sure. I am taking the largest elemnt in the list, that is also smallest than i
11:26:28 <jmcarthur> ggVGc: "i" is maybe okay, but "m" and "third" are pretty annoying.
11:26:38 <ggVGc> jmcarthur: but third is just the same as fst and snd which is used all over the plac?
11:26:41 <ggVGc> place?
11:26:46 <dolio> ggVGc: Right, but you could test afterwards, too.
11:26:47 <jmcarthur> ggVGc: I don't like fst and snd either
11:26:58 <dolio> Instead of testing every element.
11:27:06 <jmcarthur> ggVGc: They give you no indication as to what you are reaching into or what you are pulling out of it in this context.
11:27:25 <jmcarthur> ggVGc: Maybe if this had also been the context in which you had constructed the tuples in the first place it would be okay.
11:27:41 <ggVGc> jmcarthur: yeah, but then that's an issue with getCurActiveLaneNotes, which returns a tuple. in your opinion it should return a record then?
11:27:42 <dolio> Oh wait.
11:27:48 <dolio> I was thinking dropWhile.
11:28:09 <jmcarthur> ggVGc: Maybe. That would certainly be more clear in this function.
11:28:30 <dolio> ggVGc: Anyhow, what about sorting in reverse, then dropWhile (>i).
11:28:31 <ggVGc> dolio: actually, using dropWhile would save me reversing the list I think
11:28:32 <ggVGc> that's good
11:28:36 <jmcarthur> ggVGc: It is difficult to say what getCurActiveLaneNotes should do without knowing what it even is, which is the problem we're taking about in the first place.
11:29:12 <jmcarthur> ggVGc: I'd go one further than dolio's suggestion and just filter the values and take the maximum of what's left. No sorting.
11:29:24 <dfeuer> ggVGc, no, I'd expect `third` to be like `first` and `second` from Data.Bifunctor, except for trifunctors!
11:29:35 <dolio> Yeah, that's good, too.
11:29:36 <dfeuer> I'd expect the analogue of fst and snd to be something like thrd.
11:29:49 <ggVGc> jmcarthur: it's pretty specific to my software though. I wasn't expecting anyone to really care about that. I was more interested in how to do the "get biggest element in list, smaller than i"
11:30:02 <jmcarthur> ggVGc: Ah, then I just gave my answer. :)
11:30:06 <ggVGc> yep
11:30:08 <ggVGc> cheers, thanks
11:30:34 <dolio> The problem with maximumBy is that it's not total.
11:30:38 <jmcarthur> :(
11:30:44 <jmcarthur> silly partiality
11:31:04 <dfeuer> A very merry unbirthday to you! To you! A very merry unbirthday to you.
11:31:05 <dolio> You could add the (-1) into the list first, though.
11:31:07 <jmcarthur> http://hackage.haskell.org/package/safe-0.3.9/docs/Safe.html ftw
11:31:09 <ggVGc> jmcarthur: for completeness sake I will tell you that what it does is give me a list of the active notes in a sequencer lane, as a tuple for each entry, where the third value is the original index in the sequence
11:31:14 <dolio> Then (-1) is the maximum if the list is empty.
11:31:28 <dolio> Assuming the list can't have anything less than -1.
11:31:58 <ggVGc> dolio: yeah, that's an okay assumption in this case, but it's also a bit fishy :(
11:32:01 <ggVGc> but I might do that
11:32:17 <monochrom> is it important to have -1?
11:32:28 <jmcarthur> Use the safe package. It is your friend.
11:32:34 <monochrom> it seems to be displayInd :: Maybe Int is better
11:32:35 <ggVGc> yeah, I'll use Safe instead
11:32:49 <monochrom> it seems to be that -1 is a C-ism.
11:32:50 <dolio> Or use lens.
11:33:07 <dolio> This is probably a lens.
11:33:08 <davidkart> hello. I textbook question I suppose, but a little push would help.
11:33:15 <ggVGc> monochrom: yes, it was just me being lazy because the line just under this one which uses displayInd checks if it's between 0 and n, and does nothing if it is not
11:33:32 <davidkart> I have a list of thing, and a "score" function that takes a thing and output an integer. 
11:33:42 <jmcarthur> ggVGc: That sounds like a detail of that function rather than this one.
11:33:53 <davidkart> How can I sort this list according to the rating given by the "score" function ?
11:34:07 <jmcarthur> :t sortOn
11:34:08 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
11:34:11 <jmcarthur> davidkart: ^^
11:34:11 <ggVGc> jmcarthur: they are two statements of the same function, but yeah, it was just laziness
11:34:19 <jxv> :t fmap maximum . (\xs -> case xs of [] -> Nothing; _ -> Just xs)
11:34:21 <lambdabot> Ord b => [b] -> Maybe b
11:34:34 <jmcarthur> @src sortOn
11:34:34 <lambdabot> Source not found. You untyped fool!
11:34:37 <jmcarthur> meh
11:34:49 <dolio> @type \v i -> v & maximumByOf (traverse . filtered (<= i))
11:34:50 <lambdabot> (Ord a, Traversable t) => (a -> a -> Ordering) -> a -> t a -> Maybe a
11:34:58 <ggVGc> really wish there wasn't so much partialness in the prelude
11:35:14 <jmcarthur> Join the club.
11:35:55 <dolio> Oh, just maximumOf, actually.
11:36:11 <dolio> And you can do other parts with lens, too.
11:36:47 <dolio> @type \i -> maximumOf (_Just . traverse . _3 . filtered (<= i))
11:36:49 <lambdabot> (Ord b, Traversable t, Field3 a a b b) => b -> Maybe (t a) -> Maybe b
11:36:49 <davidkart> jmcarthur: that's not working
11:37:44 <jmcarthur> davidkart: Could you give more information than "not working"?
11:37:57 <ggVGc> dolio: thanks, that's great!
11:38:05 <ggVGc> I need to start thinking in lenses more
11:38:55 <davidkart> jmcarthur
11:39:02 <davidkart> I don't know what's not working
11:39:21 <ggVGc> dolio: although.. why is it Maybe (t a)
11:39:22 <monochrom> sure, but you can describe your procedure and your observation
11:39:24 <ggVGc> rather than t a
11:39:40 <monochrom> ELICSYS = explain like I can't see your screen
11:39:46 <davidkart> Couldn't match type ‚ÄòChar‚Äô with ‚Äò[Char]‚Äô
11:39:51 <dolio> That's what the _Just is doing. Isn't that what you're doing with fromMaybe [] at the beginning?
11:40:06 <ggVGc> dolio: ah, right, fair
11:40:07 <ggVGc> thanks
11:40:08 <monochrom> and what exact code did you write?
11:40:23 <monochrom> ELINT = explain like I am not telepathic
11:40:43 <dolio> You could double traverse, since traverse on Maybe traverses the thing in the Just.
11:40:59 <davidkart> http://lpaste.net/164201
11:41:03 <dolio> Anyhow.
11:41:12 <ggVGc> great, dolio just turnd 7 lines into 1
11:41:20 <ggVGc> I feel ashamed but educated
11:41:43 <nitrix> Lenses :)
11:41:49 <nitrix> _Just is a prism I think ?
11:41:53 <dolio> Well, you might write your traversals on multiple lines, if it gets really long.
11:42:37 <jmcarthur> davidkart: It would help both of us if you would give type signatures for your top level definitions.
11:43:01 <jmcarthur> davidkart: Is the type of score :: String -> Int?
11:43:07 <dolio> ggVGc: Mine is like 5 lines if you break it up as much as your original.
11:43:13 <davidkart> jmcarthur: I'm not really good at it... What Can I do if my type definition doesn't really match the function ? Am I going to be yelled at ?
11:43:27 <jmcarthur> davidkart: Yeah, the compiler would tell you it's wrong.
11:43:34 <ggVGc> what about this part? https://gist.github.com/d74cd6e2494a9d730332145255e157ac
11:43:34 <jmcarthur> davidkart: Which is informative for you.
11:43:37 <monochrom> are you aware that your scorel is String->Int not Char->Int?
11:43:40 <davidkart> jmcarthur: actually it should, but I wrot everything like a String is a list of Char
11:43:46 <jmcarthur> davidkart: Right.
11:43:55 <davidkart> I supposed it should work the same.
11:43:57 <monochrom> and therefore its problem is magnified by score, possible_words, etc
11:43:57 <ggVGc> sorry, the \> is &
11:43:59 <jmcarthur> davidkart: Okay, so the problem is that you are trying to apply putStrLn to a [String]
11:44:01 <ggVGc> I should stop using it I guess
11:44:09 * hackagebot record 0.4.1.1 - Anonymous records  https://hackage.haskell.org/package/record-0.4.1.1 (NikitaVolkov)
11:44:18 <nitrix> davidkart: All those lambda could just be partial infix functions.
11:44:21 <davidkart> jmcarthur: but I just want the fist element
11:44:29 <jmcarthur> davidkart: Then you didn't mean to use tail
11:44:37 <jmcarthur> davidkart: Perhaps you meant head?
11:44:45 <davidkart> nitrix: yeah I saw the warning as well. I wonder if infix is better and why ?
11:44:50 <nitrix> davidkart: e.g. (\x -> possible x letters) into (`possible` letters)
11:45:00 <davidkart> jmcarthur: nono I meant tail I want the highest scored element.
11:45:03 <ggVGc> oh, I can just use when
11:45:08 <davidkart> nitrix: I did that already.
11:45:10 <jmcarthur> davidkart: Then you want last, not tail
11:45:20 <nitrix> davidkart: I just find the lambda very noisy.
11:45:22 <davidkart> jmcarthur: ok
11:45:25 <jmcarthur> davidkart: tail just gives you everything in the list except for the first element
11:45:30 <ggVGc> hm, maybe not
11:45:39 <jmcarthur> davidkart: tail :: [a] -> [a]
11:45:44 <jmcarthur> davidkart: last :: [a] -> a
11:45:48 <davidkart> ha ok
11:45:55 <davidkart> that's what it was not working
11:46:26 <davidkart> but it's still not working apparently
11:46:26 <ggVGc> is there some monadic function that can help me not write stuff like "if foo then Just x else Nothing"?
11:46:44 <jmcarthur> ggVGc: guard foo >> pure x
11:46:51 <jmcarthur> ggVGc: x <$ guard foo
11:47:24 <davidkart> jmcarthur: the problem is that I am using strings exactly like lists
11:47:27 <davidkart> is it wrong ?
11:47:34 <jmcarthur> davidkart: strings are lists.
11:47:35 <dolio> ggVGc: [ setCellColor funcs ... | Just ind <- displayInd, ind >= 0, ind < viewWidth funcs ]
11:47:41 <davidkart> Is it considered bad definition
11:47:42 <jmcarthur> davidkart: So that aspect of all this is fine.
11:47:44 <davidkart> :t String
11:47:46 <lambdabot>     Not in scope: data constructor ‚ÄòString‚Äô
11:47:46 <lambdabot>     Perhaps you meant one of these:
11:47:46 <lambdabot>       variable ‚Äòtrying‚Äô (imported from Control.Exception.Lens),
11:47:53 <dolio> Oh wait.
11:47:57 <jmcarthur> davidkart: Yeah, we generally consider the fact that String = [Char] to be a wart.
11:48:04 <dolio> That's not quite right.
11:48:08 <jmcarthur> davidkart: But since it's already defined that way, might as well take advantage of it.
11:48:14 <davidkart> I still have this problem : couldn't match type 'Char' with '[char]'
11:48:16 <dolio> pure displayInd would work.
11:48:28 <monochrom> jmcarthur: time to look at what I said :)
11:48:29 <Clint> davidkart: "a" is not a Char
11:48:36 <jmcarthur> davidkart: Could you paste your new code, preferably with type signatures for each top level definition?
11:48:42 <monochrom> or what Clint just said
11:48:50 <jmcarthur> ah
11:48:52 <jmcarthur> bah
11:48:56 <davidkart> jmcarthur: I'll try
11:49:10 <jmcarthur> davidkart: How about ignoring me and reading other peoples' answers, actually. :)
11:49:11 <monochrom> hard to notice but I actually loaded the code in my ghci to see
11:49:30 <dolio> ggVGc: Your use of & in this only causes more parentheses. :)
11:50:07 <ggVGc> yeah, but it reads better to me.. I'm not haskellized yet
11:50:14 <ggVGc> dolio, jmcarthur, thanks both
11:51:11 <dolio> I guess instead of 'Just ind <- pure displayInd' you can also just do 'ind <- listToMaybe displayInd'.
11:51:25 <dolio> Er, maybeTolist or something.
11:51:50 <dolio> Or just toList.
11:57:05 <davidkart> jmcarthur: thanks, it really helped to type the signature type of the functions.
11:57:20 <davidkart> I found the error right away, the compiler assumes "b"=['b']
11:57:46 <jmcarthur> davidkart: Awesome! Glad I helped.
11:58:45 <davidkart> I have only one remaining problem : the sortOn function is not found where I call the program.
11:58:51 <davidkart> Did I miss some import ?
11:59:17 <ggVGc> dolio: hm, what gives? https://gist.github.com/3b281cb93f16b1146d5fe6f0e36c42be
11:59:58 <ggVGc> oh, I forgot a pure
12:01:22 <monochrom> you have already imported Data.List, and it already gives you sortOn
12:01:53 <monochrom> you have also imported Control.Monad twice
12:14:10 * hackagebot extra 1.4.7 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.7 (NeilMitchell)
12:24:08 <sgt_sniff> what editor do you use to develop ghcjs stuff?
12:24:56 <nineonine> hey there !
12:25:02 <nineonine> so i installed new ghc
12:25:08 <kadoban> vim. In another life I could also probably have used emacs, sublime, atom, or a couple of other 1/2way decent editors.
12:25:12 <kadoban> sgt_sniff: ^
12:25:16 <nineonine> but when im going in my project
12:25:25 <nineonine> it still uses 7.10.2
12:25:34 <nineonine> how can i make cabal switch to new ghc ?
12:25:54 <nineonine> i didn't find anything related to that in .cabal project file
12:26:04 <sgt_sniff> kadoban: does vim use ghc-mod? cause when trying to load files using the ghcjs compiler emacs just freezes when trying to load ghc-mod. 
12:26:32 <kadoban> sgt_sniff: Not unless you set it up to (which I don't, ghc-mod is IMO not worth the trouble)
12:26:53 <sgt_sniff> kadoban: I guess it's time to drop spacemacs then.
12:27:20 <sgt_sniff> kadoban: doesn't really let me edit stuff like that, just uses ghc-mod by default
12:27:55 <kadoban> My list of required stuff is quite short. I need syntax highlighting (which could even be optional if you want), autocomplete (which doesn't need to be language-specific), and I like having snippets for boilerplate. Other than that I just use stack in another terminal window, and I heavily use typed holes and such features.
12:28:09 <nineonine> anyone help ?
12:28:12 <nineonine> 8)
12:29:32 <Rotaerk> hmm can I make one stack project build multiple exe's?
12:29:47 <kadoban> Rotaerk: Add more 'executable' sections to the cabal file
12:29:54 <Rotaerk> ah k, thanks
12:29:59 <kadoban> nineonine: What are you using to build, just cabal-install?
12:30:59 <nineonine> i downloaded the distribution package
12:31:01 <nineonine> and did 
12:31:03 <nineonine> make install
12:31:06 <nineonine> updated PATH
12:31:18 <nineonine> and now it works OK in global scope
12:31:27 <nineonine> but when im on my cabalized project
12:31:32 <nineonine> it still uses older version
12:31:57 <kadoban> I forget how cabal chooses, someone else should know eventually. In stack it chooses based on the stack.yaml, you're not using stack though I assume?
12:32:06 <nineonine> no
12:32:08 <nineonine> just cabal
12:32:37 <nineonine> btw is it OK to start using stack now ?
12:32:38 <hexagoxel> nineonine: have you configure'd? clean'ed ?
12:32:55 <nineonine> hexagoxel: no !
12:33:14 <nineonine> will try now
12:33:27 <hexagoxel> `cabal configure` alone should do, i'd guess.
12:34:06 <nineonine> tried configure / clean
12:34:09 <nineonine> still on older version
12:34:17 <hvr> nineonine: there's an example on http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/
12:34:33 <hvr> nineonine: specifically: "with-compiler: /opt/ghc/8.0.1/bin/ghc"
12:34:47 <nineonine> hvr: thank you !
12:35:38 <hexagoxel> hvr: but.. it is on path; -w should not be necessary.
12:36:05 <hvr> nineonine: otoh, that's a new facility; I thought you mean 'cabal.project', whereas you actually said '.cabal project'
12:36:48 <nineonine> yeah i meant project-name.cabal file
12:38:07 <hvr> nineonine: yeah, for that setting a compiler makes little sense; a .cabal file is meant to declare things in a more flexible way
12:38:50 <hvr> nineonine: that's why we have the old per-project cabal.config files, and in future the cabal.project file
12:39:11 * hackagebot github-backup 1.20160522 - backs up everything github knows about a repository, to the repository  https://hackage.haskell.org/package/github-backup-1.20160522 (JoeyHess)
12:39:17 <hexagoxel> nineonine: are you sure the console where you try to build is refreshed in terms of PATH?
12:39:36 <hexagoxel> i.e. is it an older session?
12:40:06 <davidkart> hello
12:40:12 <davidkart> I'm stuck with this : http://lpaste.net/164204
12:41:17 <davidkart> I don't know really well how to compare y and x
12:41:32 <davidkart>  No instance for (Eq a) arising from a use of ‚Äò==‚Äô <- I've got this error
12:41:50 <nineonine> hexagoxel: not sure ! will try it as well now
12:41:53 <davidkart> So i replaced == with `Eq`
12:42:20 <davidkart> This time I need a little push with the Ordering type
12:42:29 <nineonine> ha ! you were right !
12:42:39 <nineonine> that was just an old console window
12:42:47 <nineonine> thanks hexagoxel !
12:42:54 <Cale> davidkart: You need delFirstEq :: (Eq a) => a -> [a] -> [a]
12:43:12 <Cale> davidkart: The idea being that 'a' can't really be just any type, it needs to be a type which supports equality testing
12:43:33 <nineonine> but now ghc-mod crashes in my editor :\
12:43:38 <nineonine> im using Atom
12:43:53 <Cale> Types such as function types, or IO actions, for example, can't readily be tested for equality, so the "(Eq a) => " constrains the types over which 'a' is allowed to range
12:44:10 <Cale> davidkart: and then you'll be allowed to use ==
12:44:11 * hackagebot js-jquery 1.12.4 - Obtain minified jQuery code  https://hackage.haskell.org/package/js-jquery-1.12.4 (NeilMitchell)
12:44:32 <davidkart> Thanks Cale, by the way if you see any standard function that could do this job, I'd be glad to hear it. Again, thank you very much. It makes sense and it deepens my understanding to have your response.
12:44:59 <Cale> :t delete
12:45:00 <lambdabot> Eq a => a -> [a] -> [a]
12:45:21 <Cale> > delete 'b' "abracadabra"
12:45:23 <lambdabot>  "aracadabra"
12:45:33 <davidkart> ok :)
12:45:59 <davidkart> is there an identity function ?
12:46:07 <davidkart> I'd like to apply all to a list of bool
12:46:34 <hexagoxel> nineonine: my guess would be that you need to update ghc-mod (or at least: compile with your new compiler).
12:46:38 <davidkart> :t all
12:46:40 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:46:41 <hexagoxel> nineonine: maybe it is time to try stack after all :D
12:46:47 <simpson> :t and
12:46:48 <lambdabot> Foldable t => t Bool -> Bool
12:46:53 <simpson> davidkart: ^^^
12:46:54 <nineonine> haha i agree :)
12:47:04 <nineonine> is it ok if i start using it now ?
12:47:12 <nineonine> after a while working on a project ?
12:50:13 <hexagoxel> nineonine: sure; after all stack still uses Cabal as a lib and reads your foo.cabal.
12:50:16 <kadoban> nineonine: You can, but I don't know if it's necessary for the problem you described above. It's likely not going to help you make ghc-mod sane.
12:52:00 <nineonine> i see ...
12:52:35 <kadoban> (I personally essentially gave up on ghc-mod, it's not worth my time to get/keep working)
12:53:09 <nineonine> so im getting this error
12:53:12 <nineonine> .cabal-sandbox/x86_64-osx-ghc-8.0.1-packages.conf.d: getDirectoryContents: does not exist (No such file or directory)
12:53:52 <nineonine> maybe I have to recreate new sandbox after I switched to new ghc ver ?
12:58:13 <davidkart> :hey ya a little algorithmic question for you fellow ; how can we find the maximum score of a list of items, and return the first occurence of that max item in the list ? It seems to me that I have to build this in kind of a procedural fashion, not functional. First step, compute the maximum score of the items in the list, second, iterate over the list and return the first item whose score is equal to that maximum
12:58:13 <davidkart> hear
12:59:07 <davidkart> The problem is that the brevious construct has side effects, like, for example, try to find the first matching item for a score that isn't even on the list.
12:59:22 <davidkart> it will have to return naught, and I am not sure this is allowed with Haskell.
13:03:29 <kadoban> davidkart: What is a score? Some function of an item in the list?
13:03:36 <davidkart> Basically, the question has some interest, because --- Let me hask you :) who wants to see its program written like this : a(b(c(d(e))))
13:03:39 <davidkart> yes
13:03:51 <davidkart> score::a->Int
13:05:05 <davidkart> yes
13:05:30 <davidkart> basically imagine the function height::Human->Int
13:06:03 <davidkart> What would it make : maximumBy (compare `on` height) [h1,h2,h3]
13:06:38 <kadoban> Yes, that's pretty close to what I was going to suggest, maximumBy
13:06:51 <kadoban> davidkart: Are you ‚Ä¶ asking how it's written, or are you having some trouble using it, or?
13:07:42 <davidkart> We'd like to have a data type Human with a field "height" and a function that takes a human and then return the height. We 'd like the maximumBy function to return the first human that has the maximum Height for example.
13:07:49 <davidkart> kadoban: both
13:08:19 <kadoban> :t maximumBy (comparing fst)
13:08:21 <lambdabot> (Ord a, Foldable t) => t (a, b) -> (a, b)
13:08:36 <kadoban> So that's how you'd do what you're asking, with 'fst' instead of 'height', if that helps.
13:10:59 <davidkart> so for example let humans be [albert,franck, thomas] and their size be [1.70,1.80,1.80]
13:11:09 <davidkart> I'd like my program to return "franck"
13:11:15 <davidkart> (not Thomas)
13:11:35 <davidkart> are you sure that's doing the trick kadoban ?
13:11:58 <kadoban> Ah. I'm not sure which maximumBy does, I'd have to check the docs. But if you want it to always give you the first one, you can certainly just reimplement it, if nothing else.
13:12:07 <davidkart> :t fst
13:12:09 <lambdabot> (a, b) -> a
13:12:11 <Cale> davidkart: Well, if you have a function height :: Human -> Double, then you can maximumBy (comparing height)
13:12:38 <Cale> oh, and yeah, I believe it does give the first one...
13:12:48 <Cale> But if not, then you could write
13:12:52 <davidkart> are you sure ?
13:12:57 <puregreen> > maximumBy (comparing fst) [(1,2),(1,3)]
13:12:59 <lambdabot>  (1,3)
13:13:05 <Cale> oh, okay then
13:13:25 <Cale> snd . maximumBy (comparing (height . snd) <> comparing fst) . zip [0..]
13:13:52 <davidkart> sorry your answer is cryptic
13:14:07 <davidkart> (.) is for function composition ?
13:14:10 <Cale> yep
13:14:12 * hackagebot propellor 3.0.4 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.0.4 (JoeyHess)
13:14:29 <Cale> So, height . snd is the function which gets the height of the human which is the second component of our pair
13:14:45 <davidkart> you can just call it snd
13:14:48 <kadoban> davidkart: What it's doing is annotating each element of the list with what the index of that element is. Then it's doing maximumBy and checking the height, and for equal heights it's checking the index.
13:14:52 <Cale> zip [0..] is the function which pairs up the elements of a list with their indices
13:15:02 <Cale> > zip [0..] "hello"
13:15:04 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
13:15:14 <davidkart> I know that one
13:15:19 <davidkart> the more confusing part is <>
13:15:23 <Cale> Now, to understand this, you also need to know something about orderings
13:15:45 <Cale> So, we have this abstraction in Haskell called Monoid
13:16:21 <Cale> A type M is a monoid whenever we have an associative binary operation with an identity element for it, and we write an instance of the Monoid type class for it
13:16:22 <davidkart> Teach me :)
13:16:34 <Cale> i.e. there is a class
13:16:38 <Cale> class Monoid m where
13:16:45 <Cale>   mempty :: m
13:16:51 <Cale>   mappend :: m -> m -> m
13:16:54 <verement> > mempty :: Ordering
13:16:56 <lambdabot>  EQ
13:17:00 <davidkart> ¬´ associative binary operation ¬ª (you mean a->b ?)
13:17:13 <Cale> (<>) is shorthand for mappend
13:17:22 <Cale> associative means
13:17:28 <Cale> a <> (b <> c) = (a <> b) <> c
13:17:32 <davidkart> Mathematically (a*b)*c=a*(b*c)
13:17:41 <davidkart> yes, that is associativity.
13:17:42 <Cale> for any a, b, c :: m
13:17:43 <Cale> yeah
13:17:54 <davidkart> You mean a,b,c of type m ?
13:17:58 <Cale> yeah
13:18:10 <Cale> and "has an identity" means that  mempty <> a = a  and  a <> mempty = a, for any a :: m
13:18:32 <Cale> We have a type Ordering for the results of comparisons
13:18:39 <davidkart> So what is <> ? The identity ?
13:18:41 <Cale> data Ordering = LT | EQ | GT
13:18:49 <davidkart> yes, I heard about this one.
13:18:49 <Cale> <> is the combining operation
13:19:07 <davidkart> It is neither greater than neither lesser than ?
13:19:22 <mauke> > "hello" <> "world"
13:19:24 <lambdabot>  "helloworld"
13:19:25 <Cale> LT means "less than", EQ means "equal" and GT means "greater than"
13:19:52 <Cale> Now, the <> for Ordering combines two comparisons by picking the left one if it's LT or GT
13:20:02 <Cale> but if the first comparison is EQ, then it takes the second one
13:20:06 <Cale> i.e.
13:20:15 <Cale> EQ <> b = b
13:20:17 <sandys> Hello
13:20:21 <kadoban> davidkart: It's just a symbol, it's not related to greater or less than.
13:20:21 <sandys> I am new here 
13:20:21 <Cale> a <> b = a -- otherwise
13:20:24 <sandys> !!!
13:20:30 <kadoban> sandys: Welcome
13:20:39 <Cale> sandys: Welcome! Feel free to ask any questions you might have about Haskell :)
13:21:06 <sandys> Okay 
13:21:12 <sandys> What's this channel upto ?
13:21:34 <davidkart> what Cale your explication is brilliant.
13:21:37 <Cale> sandys: It's a channel for discussion of the functional programming language called Haskell.
13:21:53 <davidkart> But I don't know (don't understand in fact) what "a" would be.
13:22:04 <davidkart> You said EQ <> b=a
13:22:08 <sandys> Cale: okay !!! 
13:22:10 <davidkart> then a<>b=b
13:22:11 <Cale> davidkart: Well, it's one of LT, or GT
13:22:19 <davidkart> ok
13:22:26 <Cale> We could write it out in full:
13:22:30 <Cale> EQ <> b = b
13:22:31 <davidkart> yes
13:22:32 <sandys> I am also new to IRC .... Can you help me out with those 
13:22:36 <Cale> LT <> b = LT
13:22:39 <sandys> Basic stuffs
13:22:40 <Cale> GT <> b = GT
13:22:50 <davidkart> but a cannot be of type b ?
13:23:01 <Cale> a and b are both Ordering values here
13:23:13 <davidkart> ok
13:23:14 <Cale> :t (<>)
13:23:16 <lambdabot> Monoid m => m -> m -> m
13:23:31 <Cale> In general, it's however we've specified to combine elements of type m
13:24:03 <davidkart> it sounds interesting. But what are the real use of this ? That sounds kind of abstract and mathematical.
13:24:15 <Cale> Well, it's about to get quite practical
13:24:23 <Cale> But there's one other thing we need to know
13:24:32 <Cale> There's also an instance of Monoid for function types, whenever the codomain of the function type is a monoid. i.e.
13:24:39 <Cale> instance Monoid b => Monoid (a -> b) where
13:25:09 <Cale>   mempty x = mempty -- here, we use the mempty :: b, in order to define the mempty :: a -> b
13:25:28 <Cale>   (mappend f g) x = mappend (f x) (g x)
13:25:44 <Cale> We combine functions pointwise
13:26:03 <Cale> So, this means that from the fact that we have an instance Monoid Ordering
13:26:21 <Cale> we get an instance of Monoid for a -> Ordering (for any type a)
13:26:39 <Cale> and then an instance of Monoid for a -> (a -> Ordering)
13:26:44 <Cale> i.e. a -> a -> Ordering
13:27:00 <Cale> which is the type of function that sortBy/maximumBy/etc. want as an argument
13:27:12 <davidkart> gu I'm afraid you lost me.
13:27:22 <davidkart> Nevermind I'll try to catch later.
13:27:26 <Cale> Well, basically what it means
13:27:55 <davidkart> I don't know what you mean by ¬´ codomain ¬ª
13:27:57 <mauke> we can do this manually. assume you want to sort a list by two criteria, foo and bar
13:28:04 <Cale> So, first of all, a -> a -> Ordering is the type of functions which compare two values of type a, and tell you whether to consider the first to be less than, equal to, or greater than the second
13:28:08 <Cale> Oh!
13:28:14 <Cale> If  f :: a -> b
13:28:19 <Cale> then a is called the domain of f
13:28:24 <Cale> and b is called the codomain of f
13:28:27 <davidkart> ok
13:28:33 <mauke> you could write it like this: sortBy (\x y -> case foo x y of { LT -> LT; EQ -> bar x y; GT -> GT })
13:28:59 <mauke> that is, compare two elements x, y using foo first. if they're unequal, use that result
13:29:07 <mauke> if they're equal according to foo, compare them using bar
13:29:13 <davidkart> yeah that's more obvious this way.
13:29:21 <mauke> now we can simplify
13:29:46 <mauke> the first part is that we want to keep LT/GT from foo x y but use some other value if it's EQ
13:29:55 <mauke> there's a function for that, and it's called <>
13:30:03 <mauke> sortBy (\x y -> foo x y <> bar x y)
13:30:18 <davidkart> ok
13:30:26 <davidkart> so <> is _not_ commutative
13:30:29 <mauke> indeed
13:30:30 <Cale> right
13:30:44 <Cale> At least, it doesn't need to be, and in this case, it certainly isn't.
13:30:59 <mauke> a <> b <> c <> d <> ... goes from left to right and picks the first non-EQ value it finds
13:31:15 <davidkart> So what's the Mono√Ød about ? -- basically I mean ?
13:31:21 <rhovland> Cale: so for e.g. string monoids, if you have functions like getName and getCity that both return strings, you can do (getName <> getCity)?
13:31:46 <mauke> davidkart: monoid is a common interface for things that have an associative operation and a neutral element
13:31:54 <Cale> rhovland: yes, for the monoid of functions which produce Strings
13:32:07 <doubling> )) <> (( ...
13:32:34 <mauke> ( Õ°¬∞ Õú ñ Õ°¬∞)
13:32:41 <Cale> rhovland: That will result in the name and city being concatenated.
13:32:49 <davidkart> Very much interesting thanks.
13:33:04 <mauke> anyway, the next step is to automate the forwarding of x and y
13:33:07 <rhovland> Cale: right, like same as (getName myThing) <> (getCity myThing)
13:33:14 <Cale> rhovland: right
13:33:15 <davidkart> Cale:you went on the theoretical side of the game I didn't understood really what you meant.
13:33:27 <Cale> davidkart: Yeah, that was possibly a bit quick :)
13:33:29 <davidkart> or at least it was really challenging to follow you.
13:33:39 <mauke> as it is right now, you have to write a lambda that takes two parameters (x and y) and forwards them to each comparison (and then you can combine the results with <>)
13:34:02 <mauke> it would be nicer if you wouldn't have to pass x and y manually
13:34:10 <mauke> there's a function for that, and it's also called <>
13:34:10 <kadoban> All you really need to know for using (<>) for comparison is that if the thing on the left is EQ, it continues to check what's on the right. Otherwise it doesn't bother.
13:34:13 <kadoban> > EQ <> LT
13:34:15 <lambdabot>  LT
13:34:16 <davidkart> mauke: that would be indeed very functional. Like it 
13:34:17 <mauke> sortBy (foo <> bar)
13:34:19 <kadoban> > GT <> LT
13:34:21 <lambdabot>  GT
13:34:43 <davidkart> kadoban: yes, I understood this part. It is useful for chaining operators in fact.
13:34:49 <kadoban> So (<>) is one nice way of building up chains of "and then compare by blah if they're equal ‚Ä¶ and then compare by foobar if they're equal, and then compare by ‚Ä¶"
13:34:50 <Cale> > sortBy (comparing length <> compare) (words "here is a bunch of words to sort first by length and then alphabetically")
13:34:52 <lambdabot>  ["a","by","is","of","to","and","here","sort","then","bunch","first","words",...
13:35:21 <Cale> cool?
13:35:26 <davidkart> really
13:35:34 <Cale> comparing p x y = compare (p x) (p y) -- by the way
13:35:52 <monochrom> primary_comparison <> tie_breaker
13:36:01 <Cale> right, that's the idea
13:36:32 <mauke> we have two steps of simplification and they're both called <>, due to shenanigans
13:37:00 <mauke> the <> for functions is defined in terms of <> on the results of the functions
13:37:02 <Cale> Well, it might be three steps if not for the shenanigans
13:37:08 <monochrom> but I like the shenanigans. they are why I went from OCaml to Haskell
13:37:25 <mauke> and because of currying it works for "two argument" functions
13:37:30 <Cale> There's also, in between the Monoid instance for a -> a -> Ordering, an instance for a -> Ordering
13:37:41 <Cale> er, in between that instance and the one for Ordering
13:38:43 <monochrom> several differences between MLs and Haskell are why I went from SML and OCaml to Haskell. but they are also why at the end I conclude that Haskell is a bit harder to learn.
13:38:53 <mauke> when you have comparisons foo, bar and you write foo <> bar, it goes: oh, you're using <> on functions; that's \x -> foo x <> bar x
13:39:04 <Cale> So yeah, this is a little display of the value that's present in recognising this mathematical structure that things have when we see it -- we don't have to write the function for combining two-argument comparison functions directly
13:39:13 <mauke> but foo x is also a function (of a single argument, returning Ordering)
13:39:31 <mauke> so the process repeats and you get: \x -> (\y -> (foo x) y <> (foo x) y)
13:39:45 <Cale> We get it for free because there's an instance of Monoid for Ordering (the ultimate result type), and an instance for function types generally, whenever there's an instance for the codomain.
13:39:49 <mauke> which is the same as \x y -> foo x y <> bar x y
13:40:05 <mauke> (if you replace the second 'foo' above by 'bar', which is a typo I made. grr.)
13:41:32 <Cale> (foo <> bar) x y = (foo x <> bar x) y = (foo x y <> bar x y)
13:43:35 <verement> what is the relationship between the codomain and the range of a function? are they the same?
13:44:19 <lowryder> verement: the codomain is a subset of the range, consisting of those things that are actually the image of something in the domain
13:44:59 <Cale> > zip [0..] (words "here are some words for which we want the first word with more chars than the rest")
13:44:59 <dolio> That's backwards.
13:45:01 <lambdabot>  [(0,"here"),(1,"are"),(2,"some"),(3,"words"),(4,"for"),(5,"which"),(6,"we"),...
13:45:52 <dolio> Or maybe it isn't backwards, but that's not what the codomain is.
13:46:10 <dolio> I forget if people use 'range' to mean image or codomain.
13:46:19 <Cale> > maximumBy (comparing (length . snd) <> flip (comparing fst)) (zip [0..] (words "here are some words for which we want the first word with more chars than the rest"))
13:46:21 <lambdabot>  (3,"words")
13:46:30 <Cale> > snd . maximumBy (comparing (length . snd) <> flip (comparing fst)) (zip [0..] (words "here are some words for which we want the first word with more chars than the rest"))
13:46:32 <lambdabot>      Couldn't match type ‚Äòa -> (a0, c)‚Äô with ‚Äò(a2, t0 a1)‚Äô
13:46:32 <lambdabot>      Expected type: (a -> (a0, c)) -> t0 a1
13:46:32 <lambdabot>        Actual type: (a2, t0 a1) -> t0 a1
13:46:37 <Hijiri> I thought range was image
13:46:37 <Cale> oops
13:46:38 <Cale> hah
13:46:42 <Cale> > snd (maximumBy (comparing (length . snd) <> flip (comparing fst)) (zip [0..] (words "here are some words for which we want the first word with more chars than the rest")))
13:46:44 <lambdabot>  "words"
13:46:49 <Cale> not used to actually writing the parens :)
13:47:03 <Cale> > snd . maximumBy (comparing (length . snd) <> flip (comparing fst)) . zip [0..] $ words "here are some words for which we want the first word with more chars than the rest"
13:47:05 <lambdabot>  "words"
13:47:24 <mauke> > maximumBy (comparing length) (words "here are some words for which we want the first word with more chars than the rest")
13:47:26 <lambdabot>  "chars"
13:47:36 <mauke> interesting
13:48:27 <Cale> Note that I have to flip the index comparison, because it's maximumBy, and we want to prefer smaller indices
13:48:32 <quchen_> Does anyone know a program to render Doc (as in the pprint package family) to PNG? I can of course render it in my terminal and screenshot that, but it's very unclean. (I need it only once, so there's no need for a lot of automation, if that matters.)
13:48:37 <mauke> > maximumBy (comparing (fmap length)) (zip [0 ..] (words "here are some words for which we want the first word with more chars than the rest"))
13:48:39 <lambdabot>  (16,"rest")
13:49:06 <mauke> > maximumBy (comparing (first length)) (flip zip [0 ..] (words "here are some words for which we want the first word with more chars than the rest"))
13:49:08 <lambdabot>  ("chars",13)
13:49:28 <quchen_> The manual screenshot-terminal version won't give me transparent background though. :-|
13:49:32 <mauke> > maximumBy (comparing (first length)) (flip zip [0, -1 ..] (words "here are some words for which we want the first word with more chars than the rest"))
13:49:33 <puregreen> quchen_: maybe you could use diagrams
13:49:35 <lambdabot>  ("words",-3)
13:49:37 <mauke> heh
13:49:39 <Cale> heh
13:50:37 <puregreen> quchen_: no, wait, you have colored text, right?
13:50:54 <quchen_> puregreen: Right, text with ANSI codes in it
13:50:59 <quchen_> Such as bold, green, background black
13:51:27 <davidkart> I wrot this : putStrLn  fst . maximumBy (comparing (score.fst) <> comparing (snd) )  (zip (filter(`possible` letters) word_list) [0..])
13:51:58 <davidkart> I have this error :  Not in scope: ‚Äò<>‚Äô
13:52:44 <mauke> @hoogle (<>)
13:52:46 <lambdabot> Data.Text.Internal.Builder.Functions (<>) :: Builder -> Builder -> Builder
13:52:47 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
13:52:47 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
13:52:54 <mauke> terrible
13:53:07 <mauke> I bet it's in Data.Monoid
13:53:14 <Hafydd> Yes.
13:53:15 <monochrom> yeah, import from Data.Monoid
13:53:41 <puregreen> quchen_: https://github.com/ansilove/ansilove
13:53:54 <monochrom> yes, practical Haskell begins with 20 import lines
13:54:00 <puregreen> you could save output with ANSI codes to a file and then render it with this
13:54:02 <quchen_> puregreen: Thanks, I'll have a look at that :-)
13:54:08 <mauke> and that can be simplified to maximumBy (comparing (first score))
13:54:13 * hackagebot gi-atk 2.0.3 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.3 (inaki)
13:54:14 <puregreen> and it supports transparent background, it would seem
13:54:15 <monochrom> and advanced practical Haskell begins with 10 extensions before 20 import lines
13:54:15 * hackagebot gi-cairo 1.0.3 - Cairo bindings  https://hackage.haskell.org/package/gi-cairo-1.0.3 (inaki)
13:54:17 <mauke> but then you'd have to import 'first'
13:54:17 * hackagebot gi-gdk 3.0.3 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-3.0.3 (inaki)
13:54:19 * hackagebot gi-gdkpixbuf 2.0.3 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-2.0.3 (inaki)
13:54:21 * hackagebot gi-gio 2.0.3 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.3 (inaki)
13:54:38 <mauke> at which point it would be easier to write (comparing (\(x, y) -> (score x, y)))
13:55:13 <monochrom> then again, practical Java begins with 20 import lines, too
13:55:46 <monochrom> or at least practical Java according to guidelines that frown upon "import java.util.*"
13:56:17 <davidkart> it compiled, forgot to import Data.Monoids
13:59:23 * hackagebot gi-girepository 1.0.3 - GIRepository (gobject-introspection) bindings  https://hackage.haskell.org/package/gi-girepository-1.0.3 (inaki)
13:59:25 * hackagebot gi-glib 2.0.3 - GLib bindings  https://hackage.haskell.org/package/gi-glib-2.0.3 (inaki)
13:59:27 * hackagebot gi-gobject 2.0.3 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-2.0.3 (inaki)
13:59:29 * hackagebot gi-gst 1.0.3 - GStreamer bindings  https://hackage.haskell.org/package/gi-gst-1.0.3 (inaki)
13:59:31 * hackagebot gi-gstaudio 1.0.3 - GStreamerAudio bindings  https://hackage.haskell.org/package/gi-gstaudio-1.0.3 (inaki)
14:04:33 * hackagebot gi-gstbase 1.0.3 - GStreamerBase bindings  https://hackage.haskell.org/package/gi-gstbase-1.0.3 (inaki)
14:04:36 * hackagebot gi-gstvideo 1.0.3 - GStreamerVideo bindings  https://hackage.haskell.org/package/gi-gstvideo-1.0.3 (inaki)
14:04:38 * hackagebot gi-gtk 3.0.3 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.3 (inaki)
14:04:40 * hackagebot gi-gtksource 3.0.3 - GtkSource bindings  https://hackage.haskell.org/package/gi-gtksource-3.0.3 (inaki)
14:04:42 * hackagebot gi-javascriptcore 3.0.3 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-3.0.3 (inaki)
14:07:11 <bazzle> I would want to executables in one .cabal file, one compiled with ghc, the other with ghcjs
14:07:35 <bazzle> any resources to help me with that? Is it even possible? Should I use two cabal files (and two sandboxes?)
14:09:44 * hackagebot gi-javascriptcore 4.0.3 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-4.0.3 (inaki)
14:09:46 * hackagebot gi-notify 0.7.3 - Libnotify bindings  https://hackage.haskell.org/package/gi-notify-0.7.3 (inaki)
14:09:48 * hackagebot gi-pango 1.0.3 - Pango bindings  https://hackage.haskell.org/package/gi-pango-1.0.3 (inaki)
14:09:50 * hackagebot gi-pangocairo 1.0.3 - PangoCairo bindings  https://hackage.haskell.org/package/gi-pangocairo-1.0.3 (inaki)
14:09:52 * hackagebot gi-poppler 0.18.3 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.18.3 (inaki)
14:11:29 <davidkart> Really useful discussion
14:12:33 <davidkart> I think I almost understood the part about mono√Ød
14:12:46 <davidkart> And I found the tutorial to be extremely useful as well
14:14:54 * hackagebot gi-soup 2.4.3 - Libsoup bindings  https://hackage.haskell.org/package/gi-soup-2.4.3 (inaki)
14:14:56 * hackagebot gi-vte 2.91.3 - Vte bindings  https://hackage.haskell.org/package/gi-vte-2.91.3 (inaki)
14:14:58 * hackagebot gi-webkit2 4.0.3 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-4.0.3 (inaki)
14:15:00 * hackagebot gi-webkit2webextension 4.0.3 - WebKit2-WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-4.0.3 (inaki)
14:15:02 * hackagebot gi-webkit 3.0.3 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-3.0.3 (inaki)
14:20:04 * hackagebot system-test 0.1.2 - Runs system tests of applications.  https://hackage.haskell.org/package/system-test-0.1.2 (ExcaliburZero)
14:21:32 <monad_cat> nice amount of hackagebot spam xD
14:22:25 <monochrom> normally it would be ok. but what's wrong this time is that this gi series has been uploading 3 times for the past 4 days
14:23:11 <monochrom> you go to hackage and you see it's like a release on May 19. then a release again on May 21. then a release again just now.
14:23:28 <monochrom> it starts to get old and it gets you thinking "are you done now?"
14:23:40 <kadoban> Yeah I usually just ignore hackagebot honestly. I realized that I don't actually care what it's talking about basically ever.
14:24:25 <kadoban> Once in a while it used to be "oh cool, that got updated", but ‚Ä¶ I never act on that information.
14:24:42 <monochrom> this case caught my attention because dolio was silencing hackagebot whenever this gi series showed up. so it got me to wonder why. and today, by the 3rd release in 4 days, I see why.
14:26:22 <pharaun> wow that was lots of package uploaded
14:26:54 <simpson> Happens.
14:29:44 <kadoban> Yeah the ones that used to annoy me were the amazonka ones or whatever, like 20ish packages all updated at once, fairly often.
14:30:19 <lpsmith> hmm, isn't there a way to define a type class synonym,  say like  type FooClass a = (BarClass a, BazClass a) 
14:30:46 <obadz> lpsmith: just make it inherit the other 2 classes and add no methods?
14:30:49 <lpsmith> Then instead of writing (BarClass a, BazClass a) => ... you could write (FooClass a) => ...
14:31:02 <lpsmith> hmm
14:31:06 <puregreen> I think this is exactly what's possible with ConstraintKinds or something
14:31:18 <lpsmith> that's not _quite_ the same
14:31:33 <merijn> ConstraintKinds allows this, yes
14:31:45 <merijn> The downside you need ConstraintKinds enabled in every module using it too
14:31:54 <lpsmith> ahh,  good to know
14:31:58 <obadz> lpsmith: class Fooclass where
14:32:18 <obadz> lpsmith: instance (BarClass a, BazClass a) => Fooclass a where
14:32:44 <obadz> lpsmith: if your constraint is FooClass a, I think that proves BarClass+BazClass? 
14:33:14 <hpc> perhaps as a middle ground, when a bunch of "foo-bar" which all have the same foo get updated in the same interval, list them on one line with no links
14:33:14 <lpsmith> obadz,  yeah,  but then you can't write   instance FooClass ... where
14:33:33 <hpc> a bit less hackagebot spam and you can still see when a series of packages updates
14:34:09 <lpsmith> ok,  what I really want to do,   is have  class Applicative m => ApplicativeReader r m | m -> r where {ask, listen, reader}
14:34:13 <kadoban> hpc: I'm not sure though, is it easy to write an actual rule for these cases? Seems like it'd be pretty flaky.
14:34:46 <puregreen> packages could be grouped by uploader
14:34:54 <lpsmith> and then have type MonadReader m = (Monad m, ApplicativeReader m) 
14:35:05 <lpsmith> and not break anybody's code
14:35:15 <lpsmith> That's probably too much to ask for, but...
14:35:35 <lpsmith> The Monad superclass of MonadReader is really a small bit of a problem for me.
14:37:12 <obadz> lpsmith: this typechecks ‚áí https://gist.github.com/obadz/fe5814d922b19823daaad7b29c475cdd
14:38:45 <lpsmith> obadz, right, that's not _quite_ what I'm after
14:39:15 * hackagebot brick 0.6.4 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.6.4 (JonathanDaugherty)
14:41:45 <jdreaver> I'm late to this convo, but this doesn't work? type FooClass a = (BarClass a, BazClass a)
14:43:00 <jdreaver> We do something similar: type LogIO m = (MonadLogger m, ControlIO m)
14:46:20 <jdreaver> Ah yeah we have ConstraintKinds enabled globally, that's why it works :/
14:49:16 * hackagebot Plot-ho-matic 0.9.0.8 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.8 (GregHorn)
15:17:39 <lpsmith> obadz, https://github.com/ekmett/mtl/issues/35
15:17:47 <YellowOnion> Is there a lens to take a Text and convert it to a Integral, and then back maintaining length?
15:22:21 <hpc> kadoban: i was thinking literally decide it by what preceeds the first hypen
15:23:25 <YellowOnion> currently have an 'ugly' > iso read (printf "%02d")
15:28:29 <numberten> is there a way to tell if a value is a function.. at runtime?
15:28:53 <numberten> as a thought experiment I'm trying to saturate the arguments to a function with 'undefined'
15:29:12 <numberten> but obviously the number of undefined necessary depends on the number of arguments to the function
15:30:10 <kadoban> YellowOnion: That sounds ugly even in principle. Wouldn't it have to be making assumptions about Text's internal encoding?
15:30:32 <Cale> numberten: You should know this statically, so you can just write True or False as appropriate.
15:31:01 <Cale> numberten: If a value is a function, its type says this, and nothing which isn't a function could end up in its place.
15:31:12 <numberten> Cale: but i'm trying to write a function over functions of every arity
15:31:41 <numberten> i guess that's what my questions boils down to
15:31:50 <geekosaur> you pretty much can't do that without typeclass hackery (see Text.Printf)
15:31:58 <numberten> noted
15:32:11 <Cale> numberten: The tricky thing that you have to sidestep here is that there isn't really a well-defined notion of arity. All functions in Haskell really have exactly one parameter.
15:32:20 <Cale> Consider for example, foldr
15:32:35 <Cale> > foldr (\x xs -> x + xs) 0 [1..10]
15:32:36 <lambdabot>  55
15:32:52 <YellowOnion> ahh, I thought it might be a bit weird without some way of saving the length of the digit
15:32:52 <Cale> > foldr (\x xs s -> s + xs (s + x)) (const 0) [1..10] 0
15:32:54 <lambdabot>  165
15:33:11 <Cale> > foldr (\x xs s t -> s*t + xs (s + x) (t+x)) (const 0) [1..10] 0 1
15:33:13 <lambdabot>      No instance for (Show a0)
15:33:13 <lambdabot>        arising from a use of ‚Äòshow_M750706116793660578519509‚Äô
15:33:13 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
15:33:19 <Cale> > foldr (\x xs s t -> s*t + xs (s + x) (t+x)) (const (const 0)) [1..10] 0 1
15:33:21 <lambdabot>  5082
15:33:30 <Cale> What is the arity of foldr? :)
15:33:54 <Cale> Since it has a polymorphic result type, it can potentially take any number of arguments
15:34:44 <numberten> true
15:35:19 <Cale> numberten: So, just about any approach to this kind of thing will depend on that ability to deal with the result type of a function polymorphically
15:36:30 <Cale> I wrote a typesafe printf library recently which makes use of some fancy mathematics, but where the basic idea is not terribly hard: http://hackage.haskell.org/package/category-printf-0.1.1.0/docs/Control-Category-Printf.html
15:36:52 <Gurkenglas> I'm writing a bachelor's thesis about Alternative's some and many being too strict. Is writing an email to Ross Paterson, who wrote the relevant lines ( https://github.com/ghc/packages-base/commit/0b592d6ef91420812f5443cdbf2a817212bde69b ), to ask about his reasoning behind/the origin of those lines, a reasonable thing to do?
15:37:52 <Cale> The idea is that the type of a formatter (the first argument to printf) has type arguments which express how it affects the type of printf
15:38:32 <Gurkenglas> (For more stuff to write into the thesis. Or should I write a proposal to change those lines over the official channels, and see if he comments, or should I write the thesis before making a proposal out of it, etc)
15:39:13 <numberten> Cale: i'll take a look
15:39:14 <numberten> thank you!
15:39:38 <Cale> For example, the s formatter, which displays anything showable, has type (Show t) => Format String a (t -> a), because if the type of the printf before using it was a, then the type of printf afterward is t -> a, where t is some instance of Show
15:39:56 <Cale> (actually the type is more general than that, but it's just abstracted over the String type)
15:41:12 <Cale> Gurkenglas: Are you sure there's enough content for a thesis in that? :)  Also, in what way are they too strict? They seem to be exactly what's required for most types of parsers.
15:42:03 <Gurkenglas> Right, many can apply to more than parsers
15:42:14 <Gurkenglas> > many (Just 2)
15:42:18 <lambdabot>  mueval-core: Time limit exceeded
15:42:42 <Gurkenglas> @letlpaste 150858
15:42:44 <lambdabot>  Defined.
15:42:50 <Gurkenglas> > manyLazy (Just 2)
15:42:51 <lambdabot>  Identity [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
15:43:12 <Cale> Wait, Identity?
15:43:18 <Cale> :t manyLazy
15:43:19 <lambdabot> PointedAlternative f g => f a -> g [a]
15:43:30 <Gurkenglas> Coz it can't fail
15:44:05 <Gurkenglas> (The maximum list of applications that doesn't fail... doesn't fail.)
15:44:21 <Gurkenglas> http://lpaste.net/150858
15:45:48 <Gurkenglas> > (`evalStateT` [0..]) $ many $ StateT uncons
15:45:50 <lambdabot>  *Exception: stack overflow
15:46:03 <Gurkenglas> > (`evalState` [0..]) $ manyLazy $ StateT uncons
15:46:04 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
15:46:16 <Gurkenglas> And then I'm gonna explore how far this can go in replacing Control.Monad.Loops
15:48:55 <Cale> I suppose that's reasonable. The reason that many and some don't work that way is that their definition has to work with whichever type f happens to be -- the actual Alternative class doesn't have the additional type parameter.
15:49:23 <Cale> (and yet they're something you want for many instances of Alternative)
15:49:36 <Gurkenglas> Right, but you could do this without adding the extra parameter
15:50:29 <Gurkenglas> Just define many manually for Maybe and [], and perhaps add some extra Alternative-defined names to make the whole thing liftable through transformers
15:51:04 <Cale> ah, perhaps the instances there could be improved, sure
15:56:20 <YellowOnion> has anyone on windows experienced spacemacs locking up and using a bunch of CPU?
15:56:21 <Gurkenglas> (This would violate the law that many and some be the least defined fixpoints of those equations. I say that specification is wrong, because the set of fixpoints without undefined might still have a minimum and then that should be the chosen one)
15:57:22 <Cale> Gurkenglas: Yeah, I can agree with that :)
15:58:02 <Cale> Gurkenglas: It should be *some* fixed point of those equations, not necessarily the least one.
15:58:15 <Cale> Or just: it should satisfy those equations.
16:00:16 <Gurkenglas> Hmm, I would have said that it should be lesser or greater to each fixpoint, going up in definedness when there's more than one possible way sounds like it violates that conservative-send-liberal-receive thing
16:03:44 <Gurkenglas> (Well, the greatest one that is "lesser or greater to each" (http://sketchtoy.com/66510198), but I'm not sure that's possible in the general case - the set of "lesser or greater to each" fixpoints might not have a computable maximum)
16:04:39 <maerwald> latest GHC gives weird "Redundant constraint" warnings, which are more or less nonsense
16:04:59 <maerwald> e.g. if you want to force constraints in your API
16:06:00 <Rotaerk> huh, hadn't heard of sketchtoy before; that's neat
16:24:19 * hackagebot typelits-witnesses 0.2.2.0 - Existential witnesses, singletons, and classes for operations on GHC TypeLits  https://hackage.haskell.org/package/typelits-witnesses-0.2.2.0 (jle)
16:44:20 * hackagebot invertible 0.1.1 - bidirectional arrows, bijective functions, and invariant functors  https://hackage.haskell.org/package/invertible-0.1.1 (DylanSimon)
16:47:19 <wedify> in class constraints what is '~'?
16:47:26 <hpc> type equality
16:48:04 <hpc> it usually appears in manipulations of GADTs
16:48:34 <hpc> if you have data Foo a where Bar :: Foo Bool; Baz :: Foo Int
16:48:49 <hpc> when you write runFoo :: Foo a -> a
16:49:02 <Mutter> Hi....
16:49:13 <hpc> runFoo Foo = False will typecheck because the pattern match introduces (a ~ Bool)
16:50:12 <orb> Do we have a built-in for this:
16:50:13 <orb> asum
16:50:15 <orb> oops,
16:50:30 <orb> Applicative f, Monoid m => (a -> f m) -> [a] -> f m
16:50:45 <orb> Ie monadic foldMap or so?
17:00:18 <Hafydd> This is (fmap fold .) . traverse, but I'm not aware of any standard name for it.
17:00:33 <MichaelBurge> orb: That looks like a Traversal
17:01:17 <orb> Thanks.  I've gone with \f l -> fmap mconcat (traverse f l) so far.
17:01:53 <ggVGc> is there a function in Data.Map that I'm missing that lets me find a value for a certain key?
17:02:07 <orb> Though it did look like something already defined, should work.  Eg it's easy to make a Monoid instance for Monoid m, Applicative a => m a
17:02:08 <ggVGc> or do I turn it into an assoc list and use find?
17:02:23 <orb> ggVGc: Data.Map.lookup?
17:02:36 <orb> ggVGc: You want to be looking in Data.Map.Strict and Data.Map.Lazy, I think.
17:02:43 <orb> That's where the meat of this module went.
17:02:54 <ggVGc> orb: o, opposite
17:02:56 <ggVGc> no*
17:03:06 <ggVGc> I need a reverse lookup
17:03:09 <orb> Oh, you want to go from value to key?
17:03:14 <ggVGc> yeah
17:03:16 <orb> Do you want to do that often or only once?
17:03:34 <MichaelBurge> ggVGc: There's Data.Bimap in the bimap package
17:03:41 <orb> If often, you should keep a pair around of (Map a b, Map b a)
17:03:46 <orb> or use the Data.Bimap. :)
17:04:23 <EvanR> ggVGc: an index... Map a [k]
17:04:40 <orb> Bimap is even implemented like the pair: data Bimap a b = MkBimap !(M.Map a b) !(M.Map b a)
17:04:55 <EvanR> or Map a (Set k)
17:05:34 <orb> EvanR: what problem is Map a (Set k) supposed to solve here?  (I know that this combination is often really useful.  I just don't see the connection.)
17:05:52 <EvanR> to what, i only have about 20 lines of scrollback ;)
17:06:21 <EvanR> generally from value to key is a multivalued function
17:06:36 <orb> EvanR: "ggVGc: an index... Map a [k] or Map a (Set k"
17:07:01 <orb> EvanR: Oh, you mean when you invert your Map.  Sure.
17:25:24 <idev> randomTakeOne :: RandomGen g => Rand g a -> [Rand g a] -> Rand g a
17:25:27 <idev> please help me implement above
17:25:41 <idev> I want to randomly take one from the non-empty list
17:25:51 <idev> (the first element ensures that the list is non empty)
17:33:22 <pavonia> idev: Take a random number n from [1 .. length of the list], choose the n-th element from that list
17:34:10 <jasonmason> what is Rand?
18:05:32 <Tehnix`> idev: could you give a little more info on what you're doing? :/
18:06:23 <jle`> idev: what is the first argument for?
18:06:43 <jle`> oh i see
18:15:46 <zRecursive> It is annoying to see "Warning: If linking fails, consider installing KB2533623." , how to suppress it ?
18:16:02 <monad_cat> is there a list of preprocessor macros I can use with CPP anywhere?
18:16:14 <monad_cat> nothing I can find on google
18:18:51 <zoran119> can someone give me an example of chaining applicatives using multiple <*>? (my terminology might be off here)
18:19:14 <zoran119> so add an extra <*> to something like this: Just (+1) <*> Just 1
18:19:21 <dibblego> > (+) <$> Just 7 <*> Just 8
18:19:22 <lambdabot>  Just 15
18:19:49 <jasonmason> > Just (+) <*> Just 1 <*> Just 1
18:19:51 <lambdabot>  Just 2
18:19:55 <Tehnix`> monad_cat: hmm, best I've been able to find is https://downloads.haskell.org/~ghc/7.0-latest/docs/html/users_guide/options-phases.html#c-pre-processor
18:20:15 <maerwald> > (,) <$> return 1 <*> return 2
18:20:16 <lambdabot>      No instance for (Show (f0 (a1, a0)))
18:20:17 <lambdabot>        arising from a use of ‚Äòshow_M19529704964493845722491‚Äô
18:20:17 <lambdabot>      The type variables ‚Äòf0‚Äô, ‚Äòa0‚Äô, ‚Äòa1‚Äô are ambiguous
18:20:31 <maerwald> meh, works in my ghci
18:20:54 <dibblego> because of defaulting
18:21:01 <maerwald> yes
18:21:06 <jasonmason> only I provided an extra <*>! and I even used his example to do it
18:21:14 <maerwald> but lambdabot also has defaulting afaik
18:21:18 <jasonmason> so I win
18:21:20 * geekosaur wonders if that alternatuive Applicative is still loaded
18:21:23 <monad_cat> thanks Tehnix`, but I'm looking for an exhaustive list. Good pointer though :)
18:21:59 <geekosaur> that may be the exhaustive list. note that cabal/stack add more macros based on the libraries they select for the build
18:22:23 <Tehnix`> monad_cat: It would actually be quite helpful to have - worth asking on /r/haskell if you are on there :) (seems a bit better place than here for a more thorough outreach)
18:22:52 <monad_cat> good idea Tehnix`, I'll do that
18:23:10 <monad_cat> or maybe there's a way of passing variables from .cabal files
18:23:43 <monad_cat> I basically want to check if `impl(ghcjs)` and I don't want to remodel the library I'm changing extensively :)
18:26:19 <geekosaur> you could have something in the cabal file like:   if impl(ghcjs)\n  ghc-options: -DUSING_GHCJS
18:27:05 <Tehnix`> monad_cat: dunno if there is any relevant info here, but it seems to have been discussed before http://ircbrowse.net/browse/ghcjs?q=cpp
18:29:21 <Tehnix`> monad_cat: yeah, it seems `#ifdef ghcjs_HOST_OS` is probably what you're looking for? used in ghcjs at least https://github.com/ghcjs/ghcjs-boot/blob/master/patches/process-1.2.0.0.patch
18:30:18 <monad_cat> Tehnix`: seems like it, thanks again :) Here's the /r/haskell post by me: https://www.reddit.com/r/haskell/comments/4kll1x/exhaustive_list_of_all_cpp_macros/
18:32:36 <dfeuer> athan?
18:48:44 <koz_> OK, I'm a bit confused. I wanna do [[Bool]] -> Maybe [Bool] -> Maybe [([Bool], Bool)] (basically a zip), but I'm not sure how to write it.
18:48:58 <EvanR> heh... ghci is funny
18:49:25 * hackagebot publicsuffix 0.20160522 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160522 (wereHamster)
18:49:32 <EvanR> let x = 1/60, let y = realToFrac x :: Pico, x - y ==> 0
18:49:43 <EvanR> instead of type error
18:51:01 <geekosaur> that should work given modern ghci has the DMR disabled
18:51:39 <EvanR> and when you type x, it gives what looks like a Double
18:52:56 <geekosaur> right, with MR disabled, it will default it for that only as Double; but the type pf x should still be something like Fractional a => a
18:53:00 <parsnipM_> if i add something to `build-depends:`, in a directories cabal file, but then it is missing from a cabal file in a parent directory, i think ghc thinks module is "hidden". 
18:53:02 <jasonmason> koz_ what would [[True, True], [False]] Just True give you?
18:53:16 <jasonmason> Just [True] *
18:53:48 <koz_> jasonmason: Assume that there's an equal number of inner lists and elements inside the Maybe.
18:54:25 <koz_> So something like [[True, True]] and Just [True] should give Just [([True, True], True)].
18:55:15 <jasonmason> > fmap (zip [[True, True]]) (Just [True])
18:55:17 <lambdabot>  Just [([True,True],True)]
18:55:40 <geekosaur> yep, x :: Fractional a => a
18:55:47 <geekosaur> so the stuff for y was pointless
18:55:48 <jasonmason> or if you prefer:
18:55:49 <jasonmason> > zip [[True, True]] <$> Just [True]
18:55:51 <lambdabot>  Just [([True,True],True)]
18:56:00 <koz_> jasonmason: Thanks!
18:56:05 <jasonmason> np
18:57:56 <jasonmason> :t fmap . zip
18:57:58 <lambdabot> Functor f => [a] -> f [b] -> f [(a, b)]
18:58:13 <geekosaur> well, no, y would have been Pico, but obviously Pico has a Fractional instance or realToFrac would have been a type error, so (x - y) is doing the realToFrac thing to get x' :: Pico then (x' - y)
19:28:19 <lpaste_> koz_ pasted ‚ÄúQuestion about lenses‚Äù at http://lpaste.net/164223
19:28:33 <koz_> If anyone could advise me, that would be very nice ^.
19:34:01 <lpaste_> Cale annotated ‚ÄúQuestion about lenses‚Äù with ‚ÄúQuestion about lenses (annotation)‚Äù at http://lpaste.net/164223#a164225
19:34:07 <Cale> koz_: ^^
19:34:21 <koz_> Cale: Wait what?
19:34:25 <Cale> koz_: Then traverse is such a Traversal
19:34:25 <koz_> How does that even?
19:35:12 <koz_> Cale: I always underestimate the intellect behind GHC. Thanks.
19:36:46 <lpaste_> koz_ annotated ‚ÄúQuestion about lenses‚Äù with ‚ÄúQuestion about lenses (annotation) (annotation)‚Äù at http://lpaste.net/164223#a164227
19:37:42 <EvanR> ggVGc: heh... trying to be cute here and its not working. x & f = f x. i have a record r with a function a -> b in it at field m. r & m x fails, wrong grouping
19:38:08 <koz_> Cale: Any chance you could have a look at my amended question?
19:38:57 <koz_> Or anyone else, really... that one obviously won't work with auto-derived Traversable instances.
19:39:27 * hackagebot roundRobin 0.1.0.0 - A simple round-robin data type  https://hackage.haskell.org/package/roundRobin-0.1.0.0 (winterland)
19:53:00 <koz_> Never mind - just wrote the damn thing by hand.
20:11:38 <dibblego> I think you want Traversal1 for that.
20:26:08 <athan> Yall got any of them GHC 8.0.1 stackage snapshots?
21:30:28 <jasonmason> feminist put in her place. https://www.youtube.com/watch?v=R3HvI5dJuzo
21:32:04 * EvanR puts jasonmason in another place, besides #haskell
21:59:49 <jlengyel> Has anyone tried building the yesod scaffolded site with the 8.0.1 release?
22:01:22 <jlengyel> It currently causes a panic when find_tycon can't find the Block type constructor from Text.Css
22:30:00 <mdibaiee> Hey, is there a function like JavaScript's `toFixed` in haskell which limits floating point's precision? e.g. I want to get 0.123 from a 0.12345 input. 
22:30:44 <parsnipM_> wouldn't that just be multiply by 1000, truncate and divide? 
22:31:41 <parsnipM_> > truncate 123.45
22:31:44 <lambdabot>  123
22:31:48 <Cale> There are a bunch of types which represent fixed point precision numbers
22:32:00 <Cale> see Data.Fixed
22:32:59 <mdibaiee> parsnipM_ yep, you're right! that works, thanks
22:35:12 <edwinpeguero> why is it that this won‚Äôt execute: putStrLn . ("You Said: "++) <$> getLine
22:35:31 <edwinpeguero> as in: main = putStrLn . ("You Said: "++) <$> getLine
22:35:44 <jasonmason> types don't match. <$> is fmap
22:35:59 <edwinpeguero> there is no type problem
22:36:07 <edwinpeguero> it compiles in ghc
22:36:09 <enthropy> main :: IO (IO ()) is off
22:36:13 <jasonmason> :t putStrLn . ("You Said: "++) <$> getLine
22:36:14 <lambdabot> IO (IO ())
22:36:15 <edwinpeguero> ah, I see
22:36:20 <edwinpeguero> thanks :)
22:36:42 <edwinpeguero> So it does execute, but it only constructs an IO ()
22:36:43 <jasonmason> sequence will fix it. or better yet use =<<
22:37:55 <edwinpeguero> awesome; thanks a lot :)
22:38:28 <Cale> you mean join?
22:38:38 <jasonmason> ops yeah
22:38:47 <Cale> But yeah, =<< in place of <$> here is what was really intended
22:39:00 <Cale> Or of course, you can just use do-notation
22:39:21 <Cale> do x <- getLine; putStrLn ("You Said: " ++ x)
