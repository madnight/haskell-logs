00:00:07 <EvanR> you dont want to duplicate it
00:00:50 <EvanR> > let !x = undefined in fst (3, x) -- nicer than seq when you have let imo
00:00:52 <lambdabot>  *Exception: Prelude.undefined
00:01:13 <EvanR> whatever x is will be evaluated before the body of the let, if you use !
00:01:30 <gabbiel> i see, thats a nice pragma
00:01:55 <EvanR> you can also go the other way and add even more laziness
00:02:31 <EvanR> > let ~(x:xs) = undefined in fst (3,x)
00:02:32 <lambdabot>  3
00:02:41 <EvanR> > let (x:xs) = undefined in fst (3,x) -- without ~
00:02:42 <lambdabot>  3
00:02:51 <EvanR> hmm, well there you go ;)
00:03:12 <gabbiel> so whats the point of ~ if both are lazy
00:03:19 <EvanR> i didnt give a good example
00:04:13 <EvanR> when you use ~, it wont actually make sure the right constructor is there, it will assume. later on it would crash if your assumption is wrong, which is bad, so you need to be extra sure the assumption is right
00:04:21 <EvanR> ~ will let you do some crazy time travel
00:04:41 <gabbiel> wait, to get it clear, thunk size is proportional to literal length in code?
00:04:51 <EvanR> its a good rule of thumb
00:04:56 <gabbiel> e.g. 54 is bigger than 5, but 4 and 5 have same thunk size?
00:05:18 <EvanR> 5 + 4 is bigger than 5 and 4 and 9
00:05:36 <gabbiel> because it has more characters to remember?
00:05:39 <cocreature> 54, 5 and 4 can all be stored as an Int so they take up the same size
00:05:53 <cocreature> the number of characters is not a good indication
00:05:56 <EvanR> because 5 + 4 is the expression (+) 5 4
00:06:02 <cocreature> e.g. the length of variablenames doesn’t matter
00:06:03 <EvanR> three nodes
00:06:09 <cocreature> it’s more like the number of expressions
00:06:13 <gabbiel> its more to what its defined then?
00:08:42 <EvanR> to clarify its not size of code, its size of abstract expressions during runtime, which may not appear in code
00:08:45 <EvanR> like this
00:08:52 <EvanR> > let ones = 1:ones in ones
00:08:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:09:07 <EvanR> if you made that into a normal form, it would take up infinite memory
00:09:22 <EvanR> but ones starts out quite small
00:10:02 <gabbiel> ~ is a little bit confusing, how can it ignore constructors and yet pattern match against them?
00:10:15 <EvanR> but if you were consume ones, it wouldnt take up much space
00:10:19 <cocreature> gabbiel: it delays the pattern match until one of the variables bound in the pattern is used
00:10:48 <EvanR> > let ~(x:xs) = [] in fst (3, x)
00:10:50 <lambdabot>  3
00:10:54 <EvanR> > let ~(x:xs) = [] in snd (3, x)
00:10:55 <lambdabot>  *Exception: <interactive>:3:5-16: Irrefutable pattern failed for pattern (x ...
00:11:14 <EvanR> though the difference doesnt appear without a case
00:12:10 <gabbiel> yeah, I'll have to get more into that, for now, I'm happy with !
00:12:26 <cocreature> I don’t think I’ve ever needed to use ~
00:12:35 <EvanR> yeah ! is convenient
00:12:53 <EvanR> ~ is necessary if youre trying to do something very tricky with recursion
00:13:40 <gabbiel> wish I had a better brain so I could understand all this FP concepts nice and easily
00:14:10 <gabbiel> the pragma is BangPatterns, right?
00:14:14 <EvanR> yes
00:15:41 <gabbiel> thanks EvanR
00:17:12 <EvanR> cocreature: maybe the most common case would be if you were using a pair as the state of a recursive algorithm, by putting (x,y) in a pattern you might cause an infinite loop even if you dont use x and y yet
00:17:35 <EvanR> so you put ~(x,y) and do what needs to be done to make x and y available, then use them
00:18:00 <EvanR> it would loop just to check that it is a tuple, which is obvious
00:18:36 <EvanR> splitting it into two variables would also work
00:18:39 <EvanR> if possible
00:21:11 <gabbiel> how do I make sure my functional is strict, should the bytes used be 0?
00:21:16 <gabbiel> function*
00:23:18 <EvanR> f is strict in its first argument if
00:23:23 <EvanR> f undefined = undefined
00:23:40 <EvanR> if f undefined = something else, then its non-strict
00:23:41 <gabbiel> sorry, forgot
00:25:14 <cocreature> EvanR: yeah I wasn’t trying to say that there are no cases where you need it. I just haven’t found the need for it personally
00:25:31 <gabbiel> wow, my strict factorial was faster than product [1..n]
00:25:45 <EvanR> @src product
00:25:46 <lambdabot> product = foldl (*) 1
00:26:00 <EvanR> > foldl (*) 1 [1..100]
00:26:02 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
00:26:04 <EvanR> > foldl (*) 1 [1..10000]
00:26:06 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
00:26:11 <EvanR> > foldl (*) 1 [1..10^10]
00:26:17 <lambdabot>  mueval-core: Time limit exceeded
00:26:20 <gabbiel> why isn't the default strict foldl?
00:26:22 <EvanR> > foldl' (*) 1 [1..10^10]
00:26:26 <lambdabot>  mueval-core: Time limit exceeded
00:26:29 <EvanR> heh
00:26:52 <EvanR> gabbiel: well, @src isn't looking up ghc's implementations
00:27:11 <gabbiel> @src seq
00:27:11 <lambdabot> Source not found. :(
00:27:12 <EvanR> so dont go by that
00:27:17 <EvanR> seq is a primitive
00:27:25 <gabbiel> i know, i just wanted to try
00:27:39 <cocreature> “product = getProduct #. foldMap Product” that’s ghc’s implementation of product
00:27:52 <cocreature> well the default one if you don’t provide a custom implementation
00:28:00 <EvanR> #. ?
00:28:04 <gabbiel> ghc implementation of anything is hard to understand
00:28:27 <EvanR> as long as it acts like the brochure, im ok with them doing whatever for performance
00:29:11 <gabbiel> ghc implementation of id is probably more archaic than foldl version of reverse
00:29:45 <cocreature> EvanR: I have no idea what #. does
00:29:54 <EvanR> dont look up clojures implementations ;)
00:29:54 <cocreature> well it’s obviously some sort of composition
00:30:00 <opqdonut> sounds like unboxed . or something
00:30:04 <gabbiel> probably some preprocessor thing
00:30:54 <gabbiel> but here, I just want to make sure I did it right, https://0x0.st/qmd.png
00:31:41 <EvanR> the optimizer might get rid of that tuple, but using two variables isnt that bad anyway
00:31:48 <opqdonut> .# is not listed on https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-prim-0.4.0.0/GHC-Prim.html
00:32:03 <opqdonut> oh it was #.
00:32:30 <opqdonut> well anyway, it's not there
00:32:38 <cocreature> hoogle doesn’t find it either
00:33:01 <gabbiel> @src group
00:33:01 <lambdabot> group = groupBy (==)
00:33:07 <gabbiel> @src groupBy
00:33:07 <lambdabot> groupBy _  []     = []
00:33:08 <lambdabot> groupBy eq (x:xs) = (x:ys) : groupBy eq zs
00:33:08 <lambdabot>     where (ys, zs) = span (eq x) xs
00:33:17 <EvanR> gabbiel: also try without ! and with -O2
00:33:28 <cocreature> ah it’s coerce
00:33:42 <opqdonut> it's in the same file
00:33:43 <opqdonut> yeah
00:33:44 <opqdonut> (#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)
00:33:44 <opqdonut> (#.) _f = coerce
00:33:48 <cocreature> const coerce
00:34:13 <opqdonut> so it's "don't really apply this function"
00:34:34 <EvanR> hmm
00:34:58 <EvanR> woulda thought newtypes were like this anyway
00:35:06 <opqdonut> indeed
00:35:17 <gabbiel> let rev = foldr (flip const)[]
00:35:33 <gabbiel> let rev = foldr (flip const)[] in rev [1..3]
00:36:14 <gabbiel> test
00:36:29 <cocreature> you need > at the beginning of your message to get lambdabot to evaluate it
00:36:52 <gabbiel> i see
00:39:36 <gabbiel> brb
01:01:18 <hsnoob_> hello
01:05:09 <hsnoob_> Question: Is a >>= b >>= c is evaluated as ((a >>= b) >>= c)?
01:08:44 <dredozubov> it associates this way, yes
01:09:28 <dredozubov> but it's lazily evaluated, so it's guided by the data dependencies binded in the second arguments of binds
01:10:44 <hsnoob_> @dredozubov, so is that why Just 4 >>= \x -> Just 5 >>= \y -> Just (x, y) works
01:10:44 <lambdabot> Unknown command, try @list
01:10:45 <EvanR> except for IO
01:11:02 <hsnoob_> because of lazy eval
01:11:27 <hsnoob_> or else the parenthesis doesn't make sense
01:11:38 <dredozubov> first of all, you'll need two returns for it to work
01:11:47 <dredozubov> it's the issue with scoping
01:12:12 <dredozubov> not really related to the evaluation order
01:12:13 <EvanR> ((x >>= y) >>= z) = (x >>= (y >>= z)) btw
01:12:37 <EvanR> so if order matters the monad is broken
01:12:43 <tsahyt> is there a simple way to construct a restricted version of the IO monad? In particular I want to restrict the possible actions to readChan and writeChan.
01:13:05 <opqdonut> just create your own newtype
01:13:05 <hsnoob_> so i think i confusing evaluation order with scoping then
01:13:08 <opqdonut> and hide the constructor
01:13:23 <dredozubov> tsahyt: i would suggest to create your own wrapper
01:14:25 <tsahyt> so, newtype IOChan a = IOChan (IO a) basically and then implement readChan' :: Chan a -> IOChan a etc? 
01:15:01 <opqdonut> tsahyt: yes, and the monad instance
01:15:22 <tsahyt> but I can still use this at the bottom of a transformer stack, just like I could use IO?
01:15:32 <sbrg> tsahyt: that is one way of going about it. you can also roll a monad that has your chan as state and only implement those functions for your monad. 
01:15:49 <sbrg> tsahyt: sure
01:15:59 <dredozubov> tsahyt: you'll have to derive some instances with GND and you're good to go
01:16:01 <EvanR> liftIO wont (shouldnt) work though
01:16:02 <ahihi> EvanR: what's the type of your y? ;)
01:16:08 <tsahyt> sbrg: the chan is carried around in an RWS in the stack
01:16:20 <dredozubov> EvanR: there is liftBase and Control.Monad.Base for that
01:16:32 <tsahyt> okay thanks! unrestricted IO makes me uneasy
01:16:52 <EvanR> ahihi: oops i messed up the laws
01:17:59 <opqdonut> yeah you need some lambdas in there
01:18:01 <opqdonut> or >=>
01:18:09 <ahihi> (x >>= y) >>= z = x >>= (\a -> y a >>= z)
01:18:16 <tsahyt> :t >=>
01:18:17 <lambdabot> parse error on input ‘>=>’
01:18:23 <opqdonut> :t (>=>)
01:18:25 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
01:18:42 <EvanR> what ahihi said
01:19:00 <tsahyt> so >=> is basically . for monadic functions?
01:19:17 <EvanR> yes
01:19:26 <EvanR> actually <=< is
01:19:56 <hsnoob_> thanks dredozubov and evanr
01:32:31 <fr33domlover> TH question: In a Q computation I get a UTCTime value via runIO. I want my TH splice to define a UTCTime value. Is there a way to lift the UTCTime into Q or should I pick its fields and make primitive literals for them etc.?
01:34:26 <lonokhov> does record update syntax desugars into strict or lazy pattern match on original record? `\(C _ _) -> ` or `\~(C _ _) ->`?
01:35:09 <EvanR> fr33domlover: having flashbacks about having PHP write out valid javascript
01:35:25 <EvanR> you can output a string rep of the UTCTime and a parse command
01:36:27 <EvanR> or read show pair
01:37:25 <tsahyt> so how do I use this restricted IO monad as a base in the transformer stack? I can't do liftIO anymore obviously, but using lift results in a type error. The stack is newtyped itself, maybe I'm missing some deriving clause?
01:38:35 <tsahyt> nvm I forgot wrapping the whole thing in the newtype constructor
01:41:09 <fr33domlover> EvanR, but I already have a function that returns a UTCTime. 'show'ing it in the TH just to parse it in the TH-generated code feels weird :P
01:41:31 <fr33domlover> I prefer to just generate a UTCTime and let the user choose what they want to do with it and how they want to format it
01:42:11 <EvanR> oh, well then Q UTCTime
01:43:15 <fr33domlover> EvanR, I want to return Q Exp :P I suppose the way is to use RecConE and get Lit values from the fields (utctDay and utctDiffTime or whatever they were)
01:43:31 <fr33domlover> I was just wondering if GHC lets this be automated using reification
01:43:57 <fr33domlover> Since technically GHC could reify the UTCTime type and automatically generate the RecConE for me
01:44:27 * fr33domlover is writing his first TH splices
01:45:52 <EvanR> fr33domlover: eh... Exp is what i suggested first ;)
01:46:23 <EvanR> yes UTCTime is just a 2 component record
01:46:28 <EvanR> you can use it directly
01:47:28 <fr33domlover> EvanR, the question is: Can GHC take my UTCTime and give me an Exp, or do I need to do this: RecConE (mkName "UTCTime", [(mkName "utctDay", .......
01:48:47 <fr33domlover> I'm just curious whether it's possible in TH because it would be a valuable shortcut
01:49:43 <EvanR> try [| myUtcTime |]
02:03:22 <fr33domlover> EvanR, hmmm seems to work in GHCi
02:03:27 <fr33domlover> but how does it work?
02:03:36 <fr33domlover> how do I do the same without the QQ
02:03:43 <fr33domlover> (or, what does the QQ do?)
02:06:45 <EvanR> fr33domlover: i thought [foo| ... |] was a quasi quoter
02:06:51 <EvanR> which requires an extension
02:07:16 <EvanR> [| ... |] is a Q Exp afaict
02:07:51 <tsahyt> what's the fastest graph library for haskell? fgl is nice to use but rather slow.
02:08:38 <fr33domlover> tsahyt, perhaps depend on what you want to do
02:08:46 <fr33domlover> I use fgl and it's fast enough for me for now
02:09:41 <fr33domlover> I doubt there can be an inductive graph library much faster than fgl. You can use the monadic interface to make it faster
02:09:50 <tsahyt>  build a graph, traverse it to determine reachability, partition nodes into several sets, select edges going between two of those sets as a cut, and this is repeated several times per step for lots of lots of steps
02:09:52 <fr33domlover> (then it's somewhat like mutable graphs in other languages)
02:11:31 <fr33domlover> tsahyt, then fgl has a graph monad, try to rewrite your code using it. But note that there's a good chance it will look uglier :P but worth it if you /need/ speed, and perhaps will also look closer to the style imperative algorithms and pseudocode are often writte
02:11:34 <fr33domlover> *written
02:12:49 <fr33domlover> (btw I didn't check how the graph monad works, iirc it uses a mutable node array but not sure, check how it works before using because a Gr in a StateT won't give you any speed boost :P)
02:12:54 <tsahyt> does fgl require me to work in IO for this or is there an ST version?
02:13:14 <fr33domlover> @hackage fgl
02:13:14 <lambdabot> http://hackage.haskell.org/package/fgl
02:13:18 <fr33domlover> tsahyt, take a look ^
02:14:10 <fr33domlover> whatever the monad module offers is your options
02:14:23 <tsahyt> for the class yes, but the implementation is bound to IO :/
02:14:42 <tsahyt> http://hackage.haskell.org/package/fgl-5.5.2.3/docs/src/Data-Graph-Inductive-Monad-IOArray.html
02:14:57 <tsahyt> then again it shouldn't be too hard to implement this for ST I suppose
02:15:19 <fr33domlover> tsahyt, perhaps you have a not-yet-covered use case then. Go over the other graph libraries, see if they offer ST
02:15:47 <fr33domlover> i don't remember any, maybe this is time for a patch to 'fgl' :P
02:16:00 <fr33domlover> (if you have enough motivation etc.)
02:16:23 <fr33domlover> EvanR, what does the QQ do though?
02:16:41 <tsahyt> there's not exactly an abundance of graph libraries for haskell though
02:16:56 <tsahyt> I could implement an ST based version of the monadic interface of fgl though
02:17:16 <fr33domlover> I mean clearly "t <- getCurrentTime; x = [|t|]" gives me x :: Q Exp and $x :: UTCTime
02:17:26 <fr33domlover> but I don't know /why/ this works
02:17:42 <fr33domlover> s/x =/let x =/
02:25:34 <EvanR> fr33domlover: [| expression |] gives you a Q Exp for expression
02:25:44 <EvanR> no need to question it ;)
02:25:59 <fr33domlover> EvanR, ah then it won't help me
02:26:08 <EvanR> no?
02:26:12 <fr33domlover> I mean, it can help a little
02:26:29 <fr33domlover> Instead of RecConE I can use a "UTCTime day diff"
02:26:35 <fr33domlover> which is more readable
02:26:54 <EvanR> who is reading this
02:26:55 <fr33domlover> but not the same as converting a UTCTime value represented as a variable
02:27:26 <fr33domlover> EvanR, whoever learns from the code or checks how it works or modifies it :P
02:27:26 <EvanR> the [| |] makes the TH more clear imo
02:27:46 <EvanR> easier than building Exps manually
02:27:48 <fr33domlover> EvanR, yeah it's definitely an improvement over my current code with RecConE
02:28:33 <EvanR> in other news i just realized this syntax exists
02:28:44 <fr33domlover> I want to use it but I hate to use things I don't understand :P I do use [whamlet| ... |]in my yesod app etc. but no QQs otherwise
02:29:05 <EvanR> thats a quasi quoter, [| ... |] is something else
02:29:47 * fr33domlover will continue to read the new TH intro in the Haskell Wiki then
02:29:53 <EvanR> data P where
02:30:13 <EvanR>   MkP :: {x :: X, y :: Y, z :: Z w} -> P
02:30:36 <EvanR> GADT record, where w is polymorphic and not a parameter to P
02:30:43 <EvanR> mind blown
02:31:49 <fr33domlover> ah I think I found it: Language.Haskell.TH.Quote.dataToExpQ
02:32:04 <fr33domlover> this seems to be what implements the [| ... |}
02:32:05 <EvanR> its a quote
02:32:08 <EvanR> yeah
02:32:15 <EvanR> $() is dequote
02:32:56 <fr33domlover> ah so it's like the `'` in scheme
02:34:57 <EvanR> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html
02:35:05 <EvanR> [| ... |], or [e| ... |], where the "..." is an expression; the quotation has type Q Exp.
02:36:43 <EvanR> [varid| ... |] on the other hand is a quasi quoter and uses a parser contained in varid, depending on where its used
02:36:54 <EvanR> there are 4 different kinds of parsers that could be invoked, i believe
02:44:17 <fr33domlover> EvanR, can I insert values into the quote? e.g. [|f x|] is an AppE (VarE ...) (VarE ...) but instead of "x" I want to insert its value there
02:44:51 <fr33domlover> i.e. Appe (VarE ...) (LitE ...)
02:48:24 * hackagebot cloben 0.1.0.0 - Clone and benchmark Haskell cabal projects  https://hackage.haskell.org/package/cloben-0.1.0.0 (sgraf812)
02:50:55 <tsahyt> okay so assuming some suitable representation for a bipartite graph containing nodes with labels of type a or b, I want a successor function that given an a returns a [b] and given a b returns a [a]. Is it possible to write a function that is constrained like this or would I need dependent types for that?
02:55:21 <ski> tsahyt : you want a single function, rather than two separate ones ?
02:56:10 <ski> EvanR : .. `w' isn't polymorphic. `MkP' is
02:57:43 <tsahyt> ski: it's more of an academic question to be honest
02:57:56 <tsahyt> I'd probably have ended up implementing two separate functions in terms of this one
02:59:10 <ski> tsahyt : perhaps you could do it, with overloading
02:59:31 <EvanR> fr33domlover: try [| f $(x) |]
03:00:06 <EvanR> (using TH inside of TH)
03:00:31 <EvanR> you cant actually work with values at this point, this is all syntax
03:00:44 * ski would think `[| .. [| ... |] ... |]' would be using TH inside of TH ..
03:01:08 <EvanR> $( ) is TH too
03:01:34 <EvanR> MkP is polymorphic right
03:01:41 <ski> yes, but that's a normal unquote
03:01:56 <EvanR> this is funny because i remember getting errors when trying to make a data type like
03:02:03 <ski> i'd say that's how `$(...)' is normally used
03:02:04 <EvanR> data A a = A a b
03:02:17 <fr33domlover> EvanR, it says can't match Integer with ExpQ. I think $() inside there just lets you insert ExpQ values or something
03:02:20 <ski> (the `[| f $(x) |]' one, i.e.)
03:02:25 <EvanR> fr33domlover: right
03:02:30 <ski> fr33domlover : yes
03:02:46 <ski> you'd need to lift in some way, if you have a value
03:03:11 <fr33domlover> ski, hmmm right, I can using litT $ IntegerL
03:03:45 * ski nods
03:05:07 <fr33domlover> let x = 1 :: Integer, xt = litE (IntegerL x), t = [| f $(x) |]
03:07:56 <EvanR> is it that forall b is not implied in the case of data A a = A a b
03:08:29 <EvanR> and whats the diff between forall b . A a b and the GADT version with no forall, which i assume is relying on RankN
03:08:52 <ski>   MkP :: {x :: X, y :: Y, z :: Z w} -> P
03:08:53 <ski> means
03:08:59 <ski>   MkP :: forall w. {x :: X, y :: Y, z :: Z w} -> P
03:09:11 <ski> because `w' wasn't already bound, and this is a type signature
03:10:32 <EvanR> is that record syntax in a signature only allowed within a GADT definition
03:10:48 <EvanR> because i can see it coming in handy for regular functions
03:23:25 * hackagebot automotive-cse 0.1.3.1 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.3.1 (KeiHibino)
03:59:17 <puregreen> is there a way to stop criterion from printing mean and std dev times?
03:59:58 <puregreen> (and tree-like output would be even better)
04:05:16 <tsahyt> Is a HashMap from unordered-containers faster than a Map for keys of type Text?
04:15:26 <EvanR> tsahyt: supposedly why aeson uses it for that now
04:15:54 <EvanR> not sure why it would be faster though
04:16:17 <EvanR> except Int is a lot smaller than a short Text
04:16:25 <tsahyt> The API is basically identical though, so I can run a benchmark later on by just swapping a few things out
04:16:45 <randomclown> HashMaps have amoralised O(1) for access
04:17:04 <EvanR> lol
04:17:15 <xa0> amoralised, haha
04:17:17 <EvanR> HashMaps are log
04:17:21 <kritzcreek> stop demoralizing your maps!
04:17:24 <kritzcreek> poor things
04:17:30 <randomclown> lol autocorrect
04:17:38 <Taneb> It's log(n) access where n is the number of members
04:17:44 <Taneb> Assuming few hash collisions
04:17:57 <tsahyt> how is that faster than the old hashmap then?
04:18:13 <EvanR> the Texts arent stored in the tree
04:18:19 <EvanR> is the only thing i can think of
04:18:21 <Taneb> Because comparing Text is O(n) over the length
04:18:27 <Taneb> But comparing hashes is O(1)
04:18:35 <EvanR> you still have to recompute a hash each time
04:18:53 <Taneb> EvanR, wouldn't the hashes be stored?
04:18:56 <tsahyt> ah right, the hidden cost of hash tables that no one talks about in CS classes
04:19:04 <EvanR> in what, a Map Text Int?
04:19:11 <tsahyt> that'd make it worse I guess
04:19:15 <Taneb> Alongside the text
04:19:25 <Taneb> So it's like Map (Hash, Text) a
04:19:34 <EvanR> no
04:19:42 <Taneb> Huh
04:19:46 <Taneb> That's how I'd do it
04:19:48 <EvanR> why would that help
04:19:57 <Taneb> Saves recomputing the hash
04:20:11 <Taneb> log(n) times per lookup
04:20:18 <EvanR> ... how are you going to find the hash given the text any other way
04:21:06 <Taneb> I'm not sure what you mean
04:21:18 <EvanR> the goal is to make a structure for mapping Text to something
04:21:23 <tsahyt> you wouldn't recompute it log(n) times per lookup. You're given the Text, then compute the hash once and then go to some kind of Map Hash a and look for that hash
04:21:32 <EvanR> right
04:21:41 <tsahyt> or IntMap a as in the old hashmap implementation
04:21:43 <EvanR> but you do have to recompute a hash each lookup
04:21:49 <Taneb> Why
04:21:56 <EvanR> and thats proportional to the length of the string
04:21:56 <tsahyt> because that's the fundamental idea behind hash tables
04:22:04 <Taneb> Well, for the thing you're looking up
04:22:11 <Taneb> Not for every other string in the map
04:22:11 <EvanR> yes
04:22:15 <EvanR> no, of course not
04:22:20 <Taneb> Which is what saving the hash gets you
04:22:30 <EvanR> youre not saving a hash, the hash is the key
04:22:35 <EvanR> thats all there is
04:22:43 <Taneb> You need to have the key in the tree
04:22:56 <EvanR> it .. is the key
04:23:36 <EvanR> anyway, computing the hash for a short Text seems to be performant enough to be good enough for aeson, according to the docs
04:24:13 <EvanR> and for many large Text, i can see it helping memory performance 
04:24:20 <EvanR> since you dont have them in the tree
04:24:23 <xa0> isn't the idea that "Hashable a => HashMap a b" is actually "IntMap [(a,b)]" or something like that, under the hood, so you get amortized O(1) 
04:25:08 <EvanR> oh, you do have them in the tree
04:25:28 <EvanR> its still not O(1) in any way
04:25:52 <Taneb> EvanR, looking at the implementation it seems in some cases it optimizes it to arrays
04:25:57 <xa0> amortized, if there are forgivingly few hash collisions
04:25:58 <Taneb> Which would give you O(1) sometimes
04:26:00 <marcx> [(a,b)] is even worse
04:26:11 <Taneb> xa0, you're thinking of hashtables, which are an entirely different beast
04:26:13 <Taneb> I think
04:26:21 <xa0> oh, right, my bad
04:26:37 <marcx> [] is a linked list, you'd get O(n) lookup
04:27:12 <Taneb> In either case, if you have a terrible hashing function where everything collides, lookup deteriorates to O(n) I think
04:27:13 <EvanR> IntMap is O(min(n, 64))
04:27:35 <marcx> Taneb yep
04:28:39 <tsahyt> O(min(n, 64)) is basically constant time for any reasonably large map though
04:28:45 <EvanR> so, misleadingly linear up to a pretty big number of elements
04:28:54 <tsahyt> 64 is a big number of elements?
04:29:06 <EvanR> for the number of things in a json object usually, its not applicable
04:29:11 <tsahyt> ah right
04:29:45 <EvanR> in which case we arent talking about asymptotics
04:29:51 <tsahyt> but in general, 64 elements is roughly the cut off point for any structure like this to start making sense over just having a [(a,b)] and using lookup from Data.List
04:31:18 <EvanR> O(n) O(64) and (log n) where n = 64 is kind of a useless comparison
04:31:43 <EvanR> because reality matters
04:33:27 * hackagebot intero 0.1.8 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.8 (ChrisDone)
04:58:28 * hackagebot network-msg 0.8 - Recvmsg and sendmsg bindings.  https://hackage.haskell.org/package/network-msg-0.8 (sickmind)
05:25:28 <jophish> Ugh, no instance for MonadFix for Q
05:27:08 <jakub> Hi, I have a piece of code that compiles fine with ghc8 but not ghc7.10 and I do not know why, can anyone help? ( http://stackoverflow.com/questions/36197795/missing-instance-of-monadreader )
05:28:30 * hackagebot pandoc-lens 0.6 - Lenses for Pandoc documents  https://hackage.haskell.org/package/pandoc-lens-0.6 (BenGamari)
05:31:32 <puregreen> jakub: I've seen this problem before, a sec
05:31:43 <puregreen> (by the way, it'll go away if you replace view with ^.)
05:34:35 <jakub> puregreen: thanks, I am going to try (^.) (after I read up on it)... I am really curious what the problem is
05:35:51 <puregreen> jakub: the previous time this came up: http://lpaste.net/raw/3284699183054848000
05:38:14 <jakub> puregreen: thanks for the work around and the related piece of conversation :)
05:38:39 <jakub> can this be considered a "bug" in ghc<8 ?
05:40:20 <puregreen> eh, I'm not sure where the line between “this is a bug” and “this is how GHC does things at the moment and yeah it's not very smart and we'll try to make it smarter in the next release” lies
05:40:49 <puregreen> I'd say it's a bug but who knows
05:41:01 <Gurkenglas> Does https://github.com/ghc/packages-base/blame/52c0b09036c36f1ed928663abb2f295fd36a88bb/Control/Applicative.hs reflect the actual authors of each line or are those shadowed by the mirror?
05:41:11 <puregreen> (well, GHC Trac probably knows but I can't find the relevant issue)
05:41:33 <hpc> if it's considered bad instead of wrong, it's an opportunity for an enhancement-severity ticket
05:41:35 <jakub> the truth is that ghc8 works fine in this respect
05:43:03 <aleator> A quick question. I have GADT of style `Exp (t::IRType)` which has constructor `Let ::  String -> Exp b -> Exp a -> Exp a`. When I pattern match on `Let`, how do I get a witness for IRType of the two subexpressions?
05:43:30 <aleator> I can make a local function with type declaration, but is there a better way?
05:59:40 <darthron> Hi
06:00:07 <shapr> howdy darthron
06:00:10 <shapr> How's code?
06:00:43 <darthron> Well, I've just read an article about lazy programming, trying to figur out how a certain function works
06:00:54 <darthron> I hope I got it. May I check it with you?
06:01:06 <shapr> You can ask, but I'm at work, I don't have much time.
06:01:16 <shapr> darthron: lazy programming is fun
06:01:26 <shapr> > let ones = 1 : ones in take 11 ones
06:01:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1]
06:02:29 <shapr> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 11 fibs
06:02:30 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89]
06:02:46 <darthron> That's the function I focused on
06:02:54 <darthron> With the fibs
06:03:50 <darthron> Does the first call look like this?  0 : 1 : (zipWith (+) [0,1,undefined] [1, undefined]), which becomes 0:1:1: (zipWith (+) fibs (tail fibs))
06:04:09 <darthron> undefined being the bottom symbol
06:04:30 <shapr> darthron: in case it's important, those are lazily constructed lists, rather than lazy functions, but there's no use of undefined, there are thunks
06:04:54 <shapr> a thunk is pretty much a pointer to some code that hasn't happened yet
06:05:14 <darthron> and the compiler doesn't check it until it needs to, right?
06:05:32 <shapr> darthron: it might be easier to look at the ones list above, where the first element of the list is the number 1, and the rest of the list is something else that gets looked up when it's needed
06:05:48 <shapr> that thing that gets looked up just happens to be the ones list itself, so the next element is also 1, and then on forever
06:06:06 <shapr> darthron: well, the runtime system is the part that doesn't check, but yes
06:06:17 <shapr> For example, it's easy to play with infinite lists because of that
06:06:29 <shapr> > take 15 [1..]
06:06:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
06:07:15 <darthron> What does zipWith do with that thunk
06:07:19 <darthron> that is what bothers me
06:07:22 <icydoge> Since a nullary function is a first class value in Haskell, it can be expressed as part of the list without the compiler checking first by evaluating
06:07:52 <icydoge> ah, to the previous question
06:08:29 <darthron> because the list becomes 0:1: (zipWith (+) [0,1, zipWith..] [1,zipWith..])
06:08:34 <shapr> darthron: zipWith takes an operator and two lists, further elements in the list aren't built/evaluated until they're required
06:08:55 <shapr> A not so lazy use of zipWith is
06:08:55 <darthron> oh, ok, so it just leaves it as it is
06:09:14 <shapr> > take 5 ( zipWith (+) [1..] [1..] )
06:09:16 <lambdabot>  [2,4,6,8,10]
06:09:48 <shapr> > let ones = 1 : ones in take 12 (zipWith (+) ones ones)
06:09:50 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2]
06:09:54 <shapr> darthron: does that make sense?
06:10:41 <darthron> So that take 5 simply makes 5 takes of 1?
06:10:48 <darthron> So that zipWith knows how many elements
06:10:56 <darthron> to compute?
06:11:42 <darthron> zipWith (+) [1..] [1..] = (1+1) : zipWith (+) [2..] [2..] and so on?
06:11:47 <shapr> darthron: sort of, the take 5 asks for five elements, and then a bunch of thunks get to dance around until there are five elements, zipWith and everything else is lazy
06:11:53 <shapr> @src zipWith
06:11:53 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
06:11:54 <lambdabot> zipWith _ _      _      = []
06:12:15 <shapr> darthron: yes exactly that!
06:13:28 <shapr> darthron: so now that you understand zipWith, can you figure out how the fibonacci list gets built?
06:13:30 <tsahyt> If I have [a] and say two (or more) functions a -> b, a -> c, and I want to calculate ([b],[c]), is there a clean way to do this that traverses the list only once?
06:14:01 <tsahyt> with clean I mean "not explicitly rolling my own"
06:14:48 <shapr> tsahyt: if nothing else, there's a function or two in Control.Arrow that does that
06:14:59 <shapr> tsahyt: have you tried to ask Hoogle for that?
06:16:07 <tsahyt> Hoogle returns no results for me
06:16:25 <hpc> tsahyt: as silly as it sounds, that's going to depend more on how you consume your ([b], [c]) value than on how you create it
06:16:28 <shapr> tsahyt: I've seen at least one function in Control.Arrow that applies two functions to the same input
06:16:46 <hpc> tsahyt: assuming an implementation that isn't outright terrible ;)
06:17:28 <tsahyt> hpc: the elements of the tuple (it's actually a three tuple) get passed to the same function where two get stored in a data structure and the third one gets converted to edges for a graph
06:18:11 <tsahyt> shapr: I'm not sure how well Control.Arrow generalizes to more than 2-tuples though
06:18:18 <darthron> shapr: Oh, so if I have take 2 of that fibs, fibs = 0:1: zipWith (+) [0,1,zipWith (+) fibs (tail fibs)] (tail [0,1,zipWith(+) fibs (tail fibs)), it solves the innermost zipWith with the current fibs being [0,1,thunk], then replaces fibs with [0,1,1,thunk]?
06:20:03 <darthron> shapr: I meant take 3
06:28:20 <tsahyt> Have there been any plans of including nubOrd in base?
06:28:31 * hackagebot numtype-dk 0.5.0.1 - Type-level integers, using TypeNats, Data  Kinds, and Closed Type Families.  https://hackage.haskell.org/package/numtype-dk-0.5.0.1 (dmcclean)
06:31:04 <lpaste> icydoge pasted “applyTwo” at http://lpaste.net/163518
06:31:11 <Aruro_> just substitute it, it basically does substitution
06:31:19 <icydoge> tsahyt: you want something like http://lpaste.net/163518?
06:31:24 <shapr> darthron_: yes, I think you've got it
06:31:27 <Aruro_> darthron_: ^
06:32:19 <icydoge> *Main> applyTwo [1,2,3] ([], []) (\a -> a + 1) (\a -> a + 2)
06:32:20 <icydoge> ([2,3,4],[3,4,5])
06:33:16 <darthron_> shapr: Thank you! This is my first time on any channel and I really like it. Is there any way to reward you? Are there points that I can give?
06:35:47 <darthron_> shapr++
06:35:53 <shapr> @karma shapr
06:35:54 <lambdabot> You have a karma of 13
06:35:56 <shapr> yay!
06:36:11 <shapr> darthron_: it's okay, saying that you like this channel is nice, since I started it some years ago :-)
06:36:41 <darthron_> shapr: Whaa, that's very cool. Nice job!
06:37:07 <shapr> darthron_: the cool people here make it awesome
06:37:11 <shapr> @karma Cale
06:37:13 <lambdabot> Cale has a karma of 71
06:37:30 <Aruro> shapr: u created it at 7:42? :) early morning person?
06:37:33 <shapr> darthron_: laziness and pure functional programming is a really cool thing to learn
06:37:47 <tsahyt> icydoge: yes
06:37:58 <icydoge> although that would be rolling own ones
06:38:00 <shapr> Aruro: I created it while living in Sweden, no clue about time of day
06:38:03 <tsahyt> although I would use (:) over (++)
06:38:32 * hackagebot exact-pi 0.4.1.2 - Exact rational multiples of pi (and integer powers of pi)  https://hackage.haskell.org/package/exact-pi-0.4.1.2 (dmcclean)
06:38:37 <tsahyt> i.e. (ab x) : bs instead of bs ++ [(ab x)]. Order doesn't matter in my case anyhow
06:39:02 <icydoge> ah, well, either way, my Haskell is too rusty to help
06:39:14 <tsahyt> icydoge: I'll do it the stupid way for now and if it turns out to be a bottleneck I'll roll my own
06:39:26 <tsahyt> the stupid way being just processing the list multiple times
06:39:44 <shapr> darthron_: Are you reading Learn You a Haskell? or perhaps Haskell Book?
06:40:17 <darthron_> shapr: I am working through CIS 194, from 2013
06:41:07 <darthron_> shapr: I didn't quite like Learn You Haskell. I've read the first 6 chapters of Learn You Haskell
06:41:09 <shapr> darthron_: oh that's a good choice, byorgey wrote that and it's popular!
06:41:20 <shapr> er, byorgey wrote cis 194 from 2013
06:41:54 <shapr> darthron_: once you get more into Haskell byorgey wrote more cool stuff: http://projects.haskell.org/diagrams/gallery.html
06:41:57 <darthron_> shapr: I felt like it wasn't thorough enough
06:42:19 <darthron_> shapr: I was planning on buying Haskell Book. Do you consider it is worth it?
06:42:20 <shapr> darthron_: different intros work better for different people, it's good you've found something that works for you
06:42:31 <shapr> darthron_: I bought Haskell Book and I've enjoyed it.
06:42:51 <shapr> I have most of the Haskell books published, and I've read most of them.
06:43:03 <darthron_> shapr: Unfortunately, for some reason, I have to pay 15$ more for it
06:43:35 <darthron_> shapr: I don't know why Romania asks for VTA for a book that has been written somewhere else
06:44:40 <darthron_> shapr: Do you use Haskell at work?
06:44:41 <shapr> darthron_: that's frustrating, but at least you can get started with free resources and see if you want to pay money for something more thorough, right?
06:45:07 <shapr> darthron_: I've had some Haskell jobs, but at the moment I get paid to work on a Python codebase. I still get to write Haskell for one shot tools though.
06:45:47 <shapr> There are lots more Haskell jobs than there were when #haskell started
06:45:49 <darthron_> sharp: Yes, that's what I am going to do. I think I'll buy it though. I've watched some of Allen's talks and I liked him
06:46:45 <shapr> Haskell Book covers many things, I forget how many pages it is at the moment, but it was 600 pages a few months back
06:47:27 <shapr> darthron_: do you write any other programming languages?
06:48:49 <Aruro> shapr: its more than 1000 pages
06:49:11 <Aruro> darthron_: why do u need to pay when there is so much free good stuff? did u see wikibook?
06:49:36 <darthron_> C, C++, some Assembly
06:50:08 <shapr> darthron_: oh, I think you'll like Haskell's datatypes if you've done anything in C++
06:50:26 <darthron_> Aruro: well, the problem with so many resources is that things are too scattered
06:50:49 <Aruro> darthron_: https://en.wikibooks.org/wiki/Haskell
06:51:12 <Aruro> darthron_: huge amount of stuff in one place
06:51:46 <darthron_> Aruro: Thank you! I'll take a look
06:51:50 <Aruro> darthron_: another : http://book.realworldhaskell.org/read/
06:52:16 <Aruro> darthron_: no need to pay for something that is there, donate i can probably understand.
06:52:47 <mikail_> Hi, I'm having some trouble trying to calculate the cumulative probability of a normally distributed random variable. I installed the random-fu library and did cdf normal 0.213 where let normal = Normal (0:Double) 1.
06:53:06 <mikail_> However, I got this No instance for (Real t0) arising from a use of ‘cdf’
06:54:03 <mikail_> I should get N(-0.213) = 0.4157
06:54:12 <mikail_> How can I do this in Haskell? Thanks
06:55:09 <shapr> darthron_: any other questions?
06:56:37 <JackIsJack> Hi there
06:56:45 <shapr> hi jack, how's code?
06:56:56 <JackIsJack> shapr: not so bad !
06:57:22 <JackIsJack> shapr: regex mode =)
06:57:39 <shapr> you're writing a regex compiler in Haskell? ;-)
06:58:11 <JackIsJack> shapr: in fact, this is my first time here, i don't know where i am
06:58:32 * hackagebot purescript-bridge 0.4.0.0 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.4.0.0 (eskimo)
06:58:50 <JackIsJack> ok Haskell is a language.
06:59:19 <JackIsJack> (i learn fast)
06:59:44 <shapr> JackIsJack: yes! Haskell is a really fun programming language!
06:59:59 <shapr> JackIsJack: one popular introduction is http://www.cis.upenn.edu/~cis194/spring13/
07:00:16 <JackIsJack> shapr: thanks you
07:00:18 <shapr> JackIsJack: there's also http://learnyouahaskell.com/chapters
07:00:28 <hpc> JackIsJack: out of curiosity, how did you find this channel?
07:00:50 <hpc> usually people know what haskell is and seek out the channel based on that
07:00:55 <shapr> yeah, I want to know too!
07:00:55 <rom1504> I was about to ask the same thing :d
07:01:00 <JackIsJack> hpc: I googled 'best irc channel for programming'
07:01:04 <JackIsJack> :):):)
07:01:06 <hpc> haaaaaaa
07:01:09 <shapr> well that's cool
07:01:20 <JackIsJack> and this : https://news.ycombinator.com/item?id=7161236
07:01:26 <JackIsJack> leads me to here.
07:02:18 <shapr> hpc: we're famous!
07:03:36 <hpc> i was already independently famous from acme-php
07:03:47 <shapr> hpc: tell me more
07:04:05 <hpc> i was invited to the white house
07:04:11 <shapr> impressive!
07:04:12 <hpc> but when i got there it was beige and shaped like a minivan
07:04:21 * shapr blinks
07:06:20 <shapr> JackIsJack: so, got any questions?
07:06:47 <JackIsJack> shapr: Why the universe is black ?
07:07:06 <shapr> JackIsJack: I don't know that, but you can ask in #haskell-offtopic, maybe they'll know?
07:07:09 <JackIsJack> just kiddin'
07:07:17 <bblfish> here's a full beginner question, about Category Theory. Two facts:
07:07:17 <bblfish> 1) In Set the product of two objects A, B is A x B, ie any possible A with any possible B combined. And the co-product, the sum of A and B is either A or B.
07:07:17 <bblfish> 2) in the category of sets ordered by inclusion SetIncl, the product of two objects A and B is the intersection, and the sum of two objects A, B is their non disjoint union.
07:07:18 <bblfish> So the notion of product in these two cases is extensionally extreemly different. In the case of Set the product is a much bigger thing than the constituent parts in the case of SetIncl it is smaller.
07:07:18 <bblfish> I am just wondering how these two things are similar apart from them being products as defined in CT, or how that they are products actually helps.
07:08:05 <JackIsJack> shapr: I am here to find people who enjoy programming (whatever the language...)
07:09:08 <swilde> hi *, I'm having trouble with current git master of emacs haskell-mode: I'm using haskell-doc minor mode, which works fine, but once I start interactive-haskell-mode (C-c C-z) the echo area gets cluttered with "async" messages, which obscure the output of haskell-doc-mode... 
07:09:49 <swilde> *: ^ any one else having the same problem?  Any suggestions on solutions/workarounds?
07:10:26 <shapr> swilde: there's the #haskell-emacs channel that's specific to haskell-mode
07:10:50 <swilde> shapr: oh, thanks for the hint and sorry for the noise...
07:11:01 <shapr> swilde: no worries, your question may get answered here as well
07:16:02 <JackIsJack> I am new to IRC as well... I find hard to read, because all the text is the same color.
07:16:43 <JackIsJack> is there a trick ?
07:21:01 <JackIsJack> And I am not a native english speaker. 
07:23:33 * hackagebot email-validate-json 0.1.0.0 - Aeson instances for email-validate  https://hackage.haskell.org/package/email-validate-json-0.1.0.0 (MarkWotton)
07:34:20 <JackIsJack> and suddently, silence.
07:34:54 <geekosaur> I think the only suggestion anyone here can make is to try a real client instead of freenode's minimal webchat
07:35:18 <geekosaur> there are other webchat clients that are more featureful (kiwiirc, irccloud, etc.) and there are dedicated clients
07:35:42 * geekosaur uses hexchat
07:36:13 <geekosaur> not sure if #freenode channel can help you with client selection or not (I suspect not aside from pointing you to the FAQ which isn't very helpful)
07:38:42 <JackIsJack> geekosaur: thanks you !
07:39:08 <JackIsJack> geekosaur: so, you are using hexchat here ?
07:40:50 <geekosaur> yes (and in some 20 other channels)
07:42:08 <darthron_> I am trying to write a Monoid instance for Bool, OR, but I don't know how to write the instance part. This is what I have written: instance Bool => Monoid (OR a), but I get an error saying that Bool is of kind '*' and more constraint are needed
07:44:57 <Cale> darthron_: Well, the thing before the => should be a type class constraint, if you put anything there at all
07:45:01 <Cale> darthron_: How is the type OR defined?
07:45:23 <darthron_> newtype OR a = OR {getOR :: a}
07:46:40 <Cale> Okay, well, maybe you want to use a Bits instance for a?
07:46:55 <Cale> instance Bits a => Monoid (OR a) where ...
07:47:22 <Cale> You don't necessarily have a Bool there
07:47:56 <darthron_> Cale: But what if I want to do that with a BOOL?
07:47:57 <JackIsJack_> ok
07:48:18 <Cale> Well, if you had  newtype OR = OR { getOR :: Bool }
07:48:19 <JackIsJack_> hexchat installed
07:48:30 <Cale> then you'd just write  instance Monoid OR where ...
07:50:18 <darthron_> Cale: Hmm. What I am trying to do is make a type OR that holds a Boolean, so I'd have OR True, OR a. How would I do that?
07:50:49 <Cale> What type is a?
07:51:08 <darthron_> Cale: Boolean
07:51:25 <Cale> Yeah, so I mean, what's the point of the type parameter?
07:52:49 <darthron_> Cale: I am only a beginner and I may get things wrong, but how would I use OR without a parameter? Will I be able to do OR True <> OR False <> OR var?
07:53:07 <Cale> Yeah, the data constructor for OR will still have a parameter
07:53:12 <Cale> The type constructor won't
07:59:43 <darthron_> Cale: I think you meant it the other way round. newtype OR a = OR {getOR :: Bool} worked for me. instance Monoid (OR a) where..
08:00:10 <Cale> Well, okay, now you have a type parameter which doesn't do anything
08:00:26 <Cale> Which is fine, maybe you could put it to use elsewhere
08:01:54 <darthron_> Cale: I am reading about Monoid from Haskell Wiki and there's an exercise which says that I should implement a Monoid for a Bool. Have I done what it asked?
08:02:10 <bennofs> darthron_: you can have newtype OR = OR { getOR :: Bool }
08:02:25 <bennofs> oh, that is what Cale wrote, didn't check backlog, sry
08:02:46 <darthron_> bennofs: And how would the instance of Monoid look?
08:03:01 <bennofs> darthron_: instance Monoid OR where mappend (OR a) (OR b) = OR (a || b)
08:03:15 <bennofs> mempty = OR True
08:03:25 <bennofs> eh mempty = OR False ofc
08:03:52 <darthron_> bennofs: That's what I've done, but I though I needed to provide a parameter for the new type
08:04:09 <darthron_> bennofs: Thank you!
08:04:23 <darthron_> bennofs++
08:08:07 <JackIsJack> I think it's ok now...
08:08:29 <JackIsJack> Hexchat + 'Solarized Dark Theme' = new life.
08:11:45 <JackIsJack> So, next question, why should i use Haskell...
08:12:18 <shapr> JackIsJack: it's a good choice to learn about *programming* which is a separate skill from a particular language
08:13:35 * hackagebot cryptohash-md5 0.11.100.0 - Fast, pure and practical MD5 implementation  https://hackage.haskell.org/package/cryptohash-md5-0.11.100.0 (HerbertValerioRiedel)
08:13:43 <JackIsJack> shapr: Ok, but I am 28, and i am used to program since... i have 13
08:14:02 <JackIsJack> shapr: I guess it's too late 
08:14:36 <shapr> JackIsJack: nah, jump in and learn!
08:16:02 <nitrix> JackIsJack: Regardless of age and experience, Haskell will be like learning to program from scratch again.
08:16:12 <nitrix> JackIsJack: There's no ideal starting point other than to start.
08:16:37 <JackIsJack> nitrix: Nice speech
08:17:08 <JackIsJack> nitrix: But I need a concrete GOAL in order to learn. I do not learn just for learning.
08:18:16 <JackIsJack> nitrix: I do a lot of stuff with .NET languages. 
08:18:35 <lc_> The goal is to learn it
08:18:38 <JackIsJack> haha
08:19:19 <lc_> maybe complete project euler
08:19:35 <lc_> if you start now you could maybe finish it in, say fifteen years
08:19:40 <JackIsJack> is there a famous software written with Haskell ?
08:19:53 <lc_> pandoc is pretty famous
08:20:09 <ClaudiusMaximus> darcs too
08:20:33 <geekosaur> I'd say the most visible ones are pandoc and git-annex
08:21:37 <Clint> xmonad is oddly popular with people who don't know haskell
08:22:18 <geekosaur> to some extent, yes. but tiling window manager are a smallish niche
08:22:23 <geekosaur> *managers
08:23:06 <geekosaur> (and a surprisingly fragmented niche at that)
08:23:35 * hackagebot brick 0.6.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.6.1 (JonathanDaugherty)
08:23:40 <JackIsJack> Ok. it looks it-people-oriented
08:24:06 <JackIsJack> , technical use : converting file, managing version
08:25:42 <monochrom> I started learning Haskell when I was 30. And without any goal. And with "The Gentle Introduction".
08:27:29 <monochrom> But I was able to solve some ACM programming contest problems in Haskell soon.
08:29:26 <nitrix> JackIsJack: My opinion doesn't reflect that of others here, but in my experience, Haskell is fairly underground and programs written in it doesn't often get much fame for one reason; they just work.
08:29:35 <sm> it's a bit sad we don't have more famous (to non-haskellers) haskell software yet
08:29:51 <lc_> lets write one now
08:30:05 <sm> nitrix: I guess facebook's spam detection system is a good example of that
08:31:29 <sm> JackIsJack: ^ that's the most famous use of haskell on servers, where it is used more often
08:31:50 <JackIsJack> :) ok, it's interesting
08:32:18 <nitrix> JackIsJack: The friends that initiated me to Haskell use it to solve actual real problem they have in their company.... the program works, there's too little maintenance to do, so they eventually get switched to another product a the software is forgoteen.
08:32:34 <nitrix> JackIsJack: It's one of those "it's works, so we don't really touch it" kind of deal.
08:32:59 <monochrom> corollary: the best langauges are the most low-profile langauges
08:33:06 <nitrix> But that's just my experience.
08:33:30 <monochrom> the analogue is known to be true in sysadmin land. the busiest sysadmins are the worst ones.
08:33:56 <nitrix> It's the point I was trying to make.
08:34:19 <nitrix> It's still very possible to develop large systems in Haskell; I'm personally working on a game :)
08:38:19 <JackIsJack> nitrix: a game ! Do you have some screenshot to share ? =) (demo)
08:38:52 <nitrix> The engine is tedious a little; the community is still figuring out the best way to approach game development, but I'd say it's been smooth sailing after that.
08:38:58 <hpc> haskell is to some extent uniquely suited for large and complex systems, just from how much programmer-controllable restrictive power is built into the language
08:39:35 <nitrix> JackIsJack: The graphics wouldn't give justice to the physics and what's going on behind the scenes. (It's a space simulation/survival/rts) in an open-world.
08:39:43 <nitrix> JackIsJack: But yeah, it's getting there :P
08:39:55 <seyt> 13He4ll8o 9.
08:40:55 <byorgey> hi seyt 
08:43:17 <JackIsJack> my personal project involve a video player
08:44:01 <JackIsJack> and the ability to show/write subtitle on it
08:47:28 <JackIsJack> - no. not possible. too bad because community here looks positive
08:48:36 * hackagebot vinyl-plus 0.1.1 - Vinyl records utilities  https://hackage.haskell.org/package/vinyl-plus-0.1.1 (andrewthad)
08:48:38 * hackagebot operational-extra 0.4 - Interpretation functions and simple instruction sets for operational  https://hackage.haskell.org/package/operational-extra-0.4 (andrewthad)
08:48:40 * hackagebot vinyl-operational 0.1.1 - Initial project template from stack  https://hackage.haskell.org/package/vinyl-operational-0.1.1 (andrewthad)
08:52:12 <Gurkenglas> Does https://github.com/ghc/packages-base/blame/52c0b09036c36f1ed928663abb2f295fd36a88bb/Control/Applicative.hs reflect the actual authors of each line or are those shadowed by the mirror?
08:53:09 <byorgey> Gurkenglas: looks like the actual authors to me
08:53:17 <Gurkenglas> kthx
09:10:08 <Zemyla> Could there be a Data.Vector.Safe export, which only exports the safe functions in Data.Vector?
09:10:21 <Zemyla> And is marked as Safe Haskell?
09:18:37 * hackagebot geojson-types 0.1 - GeoJSON data types including JSON/BSON conversion.  https://hackage.haskell.org/package/geojson-types-0.1 (alios)
09:23:14 <robstewartUK> In a stack.yaml file, can I specify a git location to be a local directory? E.g. rather than git: https://github.com/me/project1 , say git: /home/me/proj1/
09:23:15 <robstewartUK> ?
09:23:37 * hackagebot geojson-types 0.1.1 - GeoJSON data types including JSON/BSON conversion.  https://hackage.haskell.org/package/geojson-types-0.1.1 (alios)
09:24:05 <luigy_> robstewartUK yes... instead of using git.. just do location: path
09:27:28 <robstewartUK> luigy_: so.. - location: - git: /home/me/proj1 ?
09:27:38 <robstewartUK> or -location: /home/me/proj1 ?
09:27:43 <luigy_> second one
09:27:52 <luigy_> did you post a linking errors recently as well?
09:38:38 * hackagebot cryptohash-sha256 0.11.100.0 - Fast, pure and practical SHA-256 implementation  https://hackage.haskell.org/package/cryptohash-sha256-0.11.100.0 (HerbertValerioRiedel)
09:43:12 <catau> Hi, was this bug (https://ghc.haskell.org/trac/ghc/ticket/10568) fixed in 7.10.3? I'm still getting a "user error (unknown GLUT entry glutInit)" error in OSX El Capitan with a simple gloss example (https://github.com/benl23x5/gloss/blob/master/gloss-examples/picture/Easy/Main.hs) on osx
09:44:36 <catau> this comment suggests reinstalling GLUT with different cabal flags https://github.com/haskell-opengl/GLUT/issues/19#issuecomment-158131434 but I am unfortunately a newbie and don't know how to reinstall without deleting my whole ~/.stack/ directory...
09:47:36 <luigy_> catau `stack exec -- ghc-pkg unregister PKG_IN_QUESTION`
09:47:48 <catau> luigy_ thanks!
09:49:24 <luigy_> catau you welcome
09:53:15 <catau> same problem after running: stack build GLUT --ghc-options="-optl-Wl,-framework,GLUT"
09:53:38 * hackagebot geojson-types 0.1.2 - GeoJSON data types including JSON/BSON conversion.  https://hackage.haskell.org/package/geojson-types-0.1.2 (alios)
09:56:58 <catau> does gloss work for others on OSX with 7.10.3?
09:58:34 <Xnuk> Is it disallowed in Wreq to use `params` with `param` or other `params`?
10:00:21 <Xnuk> ex> let options = defaults & param "q" .~ "foo" in options & params .~ [("foo", "bar"), ("baz", "qux")]
10:03:57 <ggVGc> sometimes I wish haskell allowed local mutable variables without it showing up in the type signature
10:04:34 <ggVGc> I am not convinced complete immutability is actually the best tradeoff for strong type safety
10:04:45 <ggVGc> global immutability and referential transparency with local mutability seems fine to me
10:04:53 <ggVGc> but I've never had an environment to test it
10:04:56 <ggVGc> :(
10:05:01 <catau> ggVGc: I thought it does allow for that pretty easily... like with vector, I feel like I use that feature all the time
10:05:15 <kadoban> ggVGc: It does allow that. Use a local State or ST or whatever and runState or runST or whatever at the end.
10:08:33 <bmuk> I'm trying to run the servant template in a docker container. Here is my dockerfile: https://gist.github.com/bmuk/c9fb8c65e3e44ffdee3dcbdb823ab378
10:08:58 <bmuk> The stack exec message-service-exe command works perfectly outside the container
10:10:02 <Xnuk> Never mind my question. It's solved using (%~)
10:11:24 <bmuk> just realized there's a servant-docker template. I'll see what's different about it
10:20:48 <bmuk> the servant-docker template doesn't have a Dockerfile? It just has a Docker-compose.yml file
10:31:40 <saurabhnanda> is there a way to write one line in my module and get a bunch of pre-defined imports, where some imports are qualified by pre-determined namespaces, eg. Data.Text as T, Data.Map as M, etc.?
10:33:04 <nitrix> Like some import alias / rewrite rule?
10:33:10 <nitrix> Not that I'm aware.
10:33:39 * hackagebot snap-routes 0.0.1 - Typesafe URLs for Snap applications.  https://hackage.haskell.org/package/snap-routes-0.0.1 (AnupamJain)
10:33:44 <nitrix> saurabhnanda: As annoying as it may seem, think of the poor person trying to find where a function comes from.
10:33:45 <shapr> saurabhnanda: you could have all that in a separate module and then import that module
10:34:06 <nitrix> shapr: Can you re-export qualified names?
10:34:13 <shapr> er
10:34:16 <shapr> I don't know
10:34:21 <nitrix> That's the question.
10:34:23 <shapr> I don't think so
10:34:27 <aweinstock> saurabhnanda: you can probably do {-# LANGUAGE CPP #-} #include "my_imports.h"
10:34:28 <shapr> nitrix: good point
10:35:08 <saurabhnanda> aweinstock: hmm, good old text-based macros?
10:35:18 <nitrix> I'm not sure about the "good".
10:35:22 <aweinstock> yup, C preprocessor
10:35:28 <saurabhnanda> heh, true, nitrix
10:35:51 <aweinstock> I don't that TH can expand into import declarations
10:36:18 <saurabhnanda> so, best that one can do is to have a custom prelude and import that in without qualification or in a single namespace
10:36:40 <nitrix> Or the CPP hack.
10:37:01 <nitrix> saurabhnanda: There's also one more solution; explicitly listing the imports.
10:37:26 <nitrix> Think of the users trying to find where a function comes from; the imports helps give a good mental model.
10:37:35 <aweinstock> this is where I'd expect it to be if TH could do it, and it's not there: https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH.html#t:Dec
10:37:43 <nitrix> I'd argue that if you have too many imports, maybe your code needs more separation of concern.
10:38:11 <nitrix> On large projects, I find 10~15 common and manageable.
10:38:45 <maerwald> nitrix: haha and that leads to more imports for others
10:39:06 <saurabhnanda> nitrix: 37 lines of import
10:39:44 <exio4> pack it into somehow related modules
10:39:44 <saurabhnanda> is there a way to identify un-used imports?
10:40:02 <saurabhnanda> like in most Java IDEs -- unused imports?
10:40:07 <maerwald> saurabhnanda: ghc-mod warns about it I think
10:40:11 <nitrix> saurabhnanda: Enable warnings.
10:40:21 <saurabhnanda> emacs should underline it then?
10:40:25 <saurabhnanda> via cabal?
10:40:33 <maerwald> no idea, my vim does it at least and I think it's via ghc-mod
10:40:38 <nitrix> emacs is a text editor, it has nothing to do with the haskell toolsuite.
10:40:52 <nitrix> ghc, ghci or ghc-mod would catch that.
10:40:55 <maerwald> emacs is an operating system, not a text editor :o
10:41:06 <maerwald> nano is a text editor
10:41:13 <Clint> barely
10:41:22 <rom1504> what about cat and echo
10:42:04 <nitrix> saurabhnanda: -Wall
10:42:34 <saurabhnanda> nitrix: any idea how to turn them on in spacemacs?
10:42:49 <saurabhnanda> shall I try via ghc-options in my .cabal file?
10:43:19 <sbrg> I think you just need to turn on -fwarn-unused-imports
10:43:22 <sbrg> or maybe it's even default
10:43:37 <nitrix> saurabhnanda: That's typically where project config goes.
10:43:40 <sbrg> yep, looks like I turn it off in muy ~/.ghci
10:43:43 <dcoutts> saurabhnanda: it's generally better to do that kind of thing as extra args to cabal, rather than in the .cabal file.
10:44:04 <nitrix> dcoutts: Why?
10:44:09 <dcoutts> saurabhnanda: ie distinguishing between project config and package config
10:44:17 <saurabhnanda> dcoutts: I've had a hard time getting spacemacs working -- Let's pick the easiest thing here :)
10:44:35 <dcoutts> since packages get distributed and used by other people 
10:44:41 <saurabhnanda> okay, added -Wall to .cabal file -- let's see
10:44:48 <maerwald> spacemacs is basically broken IMO
10:44:49 <dcoutts> saurabhnanda: it'd probably be as easy as adding ghc-options in the cabal.config file
10:45:01 <saurabhnanda> dcoutts: just did that
10:45:23 <dcoutts> cabal.config vs yourpkg.cabal file
10:45:25 <saurabhnanda> a related question -- sometimes spacemacs seems to auto-compile every time I save. Sometimes not. What controls this?
10:45:35 <saurabhnanda> yourpkg.cabal
10:45:42 <saurabhnanda> dcoutts: yourpkg.cabal
10:45:50 <dcoutts> saurabhnanda: right, that was my point
10:46:34 <dcoutts> saurabhnanda: anyway, if that works, then you can try moving it into the cabal.config file instead (or the stack.yml if you use stack)
10:46:39 <saurabhnanda> dcoutts: I'll change it later. Need to get back to writing Haskell rather than struggling with config. Have only under an hour before I need to sleep.
10:46:59 <dcoutts> sure, just pointing out best practice :-)
10:47:35 <nitrix> If you've hinted to a best one, I missed it.
10:47:46 <fhmgufs> Would you (objectively) say that Haskell is the best programming language to use?
10:48:03 <nitrix> fhmgufs: We're not here to convince you; do your homeworks.
10:48:15 <fhmgufs> Which homeworks?
10:48:40 * hackagebot ip 0.1 - Initial project template from stack  https://hackage.haskell.org/package/ip-0.1 (andrewthad)
10:48:43 <simpson> fhmgufs: No.
10:48:47 <fhmgufs> I'm just in a don't-know-which-language-to-use phase.
10:48:47 <nitrix> fhmgufs: If you're frustrated by the existing languages and you see potential and have the interest to learn Haskell, then do it.
10:48:49 <saurabhnanda> fhmgufs: objectively NOTHING in life is best. It's always subject to some context and value-system.
10:49:07 <simpson> fhmgufs: Do you know a bunch of languages already?
10:49:17 <fhmgufs> Yeah
10:49:18 <nitrix> fhmgufs: I'll still answer the question, no, Haskell isn't the best programming language.
10:49:30 <fhmgufs> Why not?
10:49:36 <simpson> fhmgufs: Then surely you know that they all have their strengths and weaknesses.
10:49:48 <simpson> We really only know which languages *aren't* good.
10:49:50 <nitrix> fhmgufs: It has various shortcomings when compared to various other languages.
10:51:01 <fhmgufs> Let's say I wanted to program a very big and revolutionizing whatsoever - would you recommend to use Haskell for it?
10:51:11 <fhmgufs> That's the question I meant.
10:51:15 <exio4> no language is perfect 
10:51:18 <simpson> No. I wouldn't recommend building anything big and revolutionizing.
10:51:20 <exio4> some are least perfect than others
10:51:30 <simpson> Build either something big and boring, or something small and revolutionary.
10:52:10 <nitrix> fhmgufs: I think using Haskell is better than not having anything at all. If your task is to write a program, surely having Haskell available is better than no having it.
10:52:11 <simpson> fhmgufs: At any rate, learn Haskell, and *then* decide whether to build something with it.
10:52:17 <nitrix> fhmgufs: I think the question is ill-phrased.
10:52:22 <simpson> fhmgufs: You absolutely should learn Haskell! It's a good language to learn.
10:52:23 <fhmgufs> simpson: Just an example situation I gave where you can totally independently decide which language to use.
10:52:33 <simpson> fhmgufs: Oh! Well, then I recommend ANS FORTH.
10:53:30 <nitrix> fhmgufs: Your question was if you should use Haskell for a project; my answer is using Haskell is probably a better idea than not using Haskell. Your primary objective should be to get the project done.
10:53:38 <xa0> simpson: what's wrong with forth :p
10:53:43 <nitrix> fhmgufs: If you have alternatives, then weight the alternatives, but that'd be a different questions.
10:54:14 <fhmgufs> So would you use Haskell for that project then?
10:54:19 <fhmgufs> *would*
10:54:26 <simpson> xa0: ANS dialect requires CONSTANT YELLING; the memory and type models are really wimpy and you'll have to build a meta-layer; double cells are stupid.
10:54:32 <fhmgufs> I don't know why my question wasn't understandable.
10:54:40 <nitrix> fhmgufs: Can't answer with the information given so far.
10:54:42 <xa0> heh, fair enough
10:54:43 <nitrix> What is the project about?
10:54:47 <simpson> fhmgufs: Well, what's the project's main components? What kind of performance and security targets do you have?
10:57:30 <fhmgufs> simpson: I don't actually have a project. Just imagine you had the chance
10:57:31 <fhmgufs> to develop sth totally from scratch without any requirements.
10:57:31 <fhmgufs> Then you would use the language, that is all-in-all the "best", right?
10:57:45 <fhmgufs> Would that be Haskell then?
10:57:49 <nitrix> "without any requirements".
10:57:58 <nitrix> Then you don't need Haskell. The project's done.
10:58:28 <johnw> fhmgufs: I can't think of a project that I wouldn't use Haskell for in some way, unless I'm deciding on writing a kernel device driver, or my deployment environment had extremely special needs
10:58:32 <fhmgufs> nitrix: without any implementation preconditions.
10:58:50 <nitrix> fhmgufs: You're missing the point.
10:59:11 <nitrix> fhmgufs: Haskell sure is a good language, but approaching it because you want the "best" is falacious.
10:59:51 <fhmgufs> nitrix: But there must be a best, and I thought people here think that's Haskell.
11:00:06 <nitrix> It's not miracoulous. It doesn't magically work, doesn't magically make things perfect, and on time, nor fast, nor simple, nor any of what you could associate with "best".
11:00:17 <nitrix> fhmgufs: No. Computer Science is always a trade-off.
11:00:41 <fhmgufs> So you would create a new language then, or what?
11:01:05 <Aruro> fhmgufs: its problem of math, some languages are good to write others are good to run. haskell is first. it easy to write haskell but difficult to debug and make super fast/efficient. assembler on the other end of spectrum is difficult to write but best to run.
11:01:13 <nitrix> fhmgufs: I'd rather trust smarter people to do that.
11:02:02 <Aruro> fhmgufs: in between there are languages like haskell, ocaml for example
11:02:19 <Aruro> fhmgufs: lisp, just to start. 
11:03:00 <fhmgufs> Aruro: Yeah, Scheme is great! Maybe I'll stick with that, people here are way to strange.
11:03:20 <Aruro> fhmgufs: no, they are just too pedantic :) your question was very clear.
11:03:39 <fhmgufs> Aruro: Thanks, and you're right.
11:03:41 * hackagebot geojson-types 0.1.3 - GeoJSON data types including JSON/BSON conversion.  https://hackage.haskell.org/package/geojson-types-0.1.3 (alios)
11:03:59 <Aruro> fhmgufs: haskell Concept wise is not much more far than scheme, i would suggest understanding scheme.
11:03:59 <mizu_no_oto_work> fhmgufs: I think the point that people were trying to make is that there are some projects that Haskell would be the best choice for, and some projects that it wouldn't be the best choice for
11:04:52 <fhmgufs> Aruro: At the moment I'm using Scheme a lot and like it.
11:05:35 <Aruro> fhmgufs: then u probably dont need haskell :) 
11:05:44 <fhmgufs> Yep, I think so.
11:06:14 <fhmgufs> Just wanted to ask here. Maybe I could have also asked whether Haskell is better than Scheme.
11:06:15 <Aruro> fhmgufs: unless u got free time of course :), then definitely investigate and compare
11:07:03 <Aruro> fhmgufs: its not better, just different
11:07:18 <Aruro> fhmgufs: take a look at real world exapmles and just get the feeling if u like it
11:07:32 <Aruro> fhmgufs: i mean look at code.
11:07:51 <Aruro> fhmgufs: can start here: https://en.wikibooks.org/wiki/Haskell
11:07:57 <fhmgufs> Yes, I'll do. Thanks for your tips.
11:08:08 <Aruro> fhmgufs: but better first master scheme :) dont waste time on two fronts
11:08:27 <mizu_no_oto_work> fhmgufs: or abandon scheme entirely and go to Haskell
11:08:33 <Aruro> :)
11:09:11 <Aruro> fhmgufs: i guess if u like scheme u probably should like Haskell too.
11:09:55 <Aruro> fhmgufs: but again we are just talking about "Me enjoing writing my program" , not about part "Me being proud of my program being efficient"
11:11:00 <mizu_no_oto_work> Does Scheme have a good repository of libraries online, similar to Hackage?  That's one consideration for real-world projects
11:11:19 <fhmgufs> Aruro: I think "Me enjoing writing the program" is more important (and "Me being proud of the nice look of my code"
11:11:38 <Aruro> fhmgufs: k, then give haskell a try :)
11:11:42 <fhmgufs> oh, missing parenthesis :)
11:18:18 <Aruro> mizu_no_oto_work: i could not google one fast.
11:20:05 <mizu_no_oto_work> fhmgufs: Additionally, the type system in Haskell is nice.  While, for example, Java's tends to get in your way, Haskell's actively aids you much of the time.
11:21:21 <mizu_no_oto_work> In Haskell, the value of a term can depend on the type that's ascribed to it, which is interesting
11:21:40 <mizu_no_oto_work> > (readMay "1") :: Int
11:21:42 <lambdabot>  Not in scope: ‘readMay’
11:21:46 <xa0> be
11:21:52 <mizu_no_oto_work> > (read "1") :: Int
11:21:53 <lambdabot>  1
11:21:58 <simpson> fhmgufs: I have to be honest: To do what you're describing, I wrote a completely new language, and I'm building my projects in *that*.
11:21:59 <mizu_no_oto_work> > (read "1") :: Double
11:22:00 <lambdabot>  1.0
11:23:02 <Tertain> When dealing with the ffi, is it possible to create a pointer in Haskell that will be passed to a C function, with memory being dynamically allocated by C? Or is a thin wrapper necessary?
11:23:14 <monochrom> Java's type system doesn't get into my way. Because I code to Haskell's high standard.
11:23:40 <monochrom> It requires more type annotations, but I don't resent that.
11:23:46 <fhmgufs> simpson: Wow, is it available somewhere (just curious)?
11:24:06 <monochrom> But it doesn't illegalize what's legal in Haskell.
11:24:11 <simpson> fhmgufs: http://monte.readthedocs.io/en/latest/
11:25:01 <monochrom> well, ok, I forgot Haskell's type classes and higher kinds.
11:25:48 <saurabhnanda> if I have a bunch of [DB(), DB(), DB()] actions -- how do I run them in a single runDb transsaction?
11:25:58 <simpson> saurabhnanda: sequence?
11:26:08 <monochrom> sequence_
11:26:22 <saurabhnanda> simpson: every runDb invocation will result in a new DB TRANSACTION, right?
11:26:29 <saurabhnanda> :t sequence
11:26:31 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:26:34 <simpson> saurabhnanda: I don't know the Monad that you're working in, sorry.
11:26:36 <monochrom> but I probably don't know DB or runDb
11:26:37 <saurabhnanda> ah okay
11:26:47 <saurabhnanda> didn't even know this existed
11:26:50 <geekosaur> Tertain, I think you want something like Ptr (Ptr ()) --- first Ptr is passed via the FFI and receives an address back that will be treated by Haskell as Ptr () (roughly equivalent to (void *) in C)
11:26:59 <saurabhnanda> it's actually SqlPersistT (yesod/persistent)
11:31:14 <dcz> hello everyone
11:31:46 <web2k17> http://espedito.homepc.it/ OnePostX...)
11:32:53 <monochrom> That is one bloody megabyte.
11:33:28 <monochrom> and is clearly spam
11:33:30 --- mode: ChanServ set +o monochrom
11:33:44 --- mode: monochrom set -o monochrom
11:33:46 <monochrom> I'm too late
11:33:53 <xa0> why is there blood on your megabyte
11:34:50 <Tertain> geekosaur: Thanks, I hadn't thought of that!
11:47:27 <gfixler> newtype Fix f = Fx (f (Fix f))
11:47:41 <gfixler> how is it that the f is allowed to change type in the recursion?
11:47:55 <scshunt>  what do you mean "change type"?
11:48:09 <gfixler> scshunt: that's part of the question - not sure it is :)
11:48:32 <scshunt> gfixler: f is a type, it's not a value
11:48:32 <platzhirsch> What's a good one-sentence definiton of lifting? :)
11:48:35 <scshunt> it doesn't have a type
11:48:41 <scshunt> (and it has kind * -> *)
11:48:49 <scshunt> platzhirsch: moving something to a higher altitude
11:48:51 <monochrom> f does not change. f's kind does not change either.
11:49:12 <gfixler> monochrom: is Fix changing?
11:49:30 <gfixler> something changing
11:49:53 <hpc> let's write it as a GADT
11:49:57 <gfixler> from a Bartosz writup: The fractally recursive structure of Expr can be generated by repeatedly applying ExprF to itself, as in ExprF (ExprF (ExprF a))), etc. 
11:50:06 <gfixler> the innermost ExprF has an a
11:50:09 <hpc> newtype Fix :: (* -> *) -> * where
11:50:15 <gfixler> the next one up's a is (ExprF a)
11:50:19 <hpc> Fx :: f (Fix f) -> Fix f
11:50:50 <gfixler> I'm not sure my shaky understanding of GADTs is going to be much help here
11:51:06 <hpc> it's not really a GADT here, just using the syntax
11:51:14 <platzhirsch> scshunt: haha:)
11:51:20 <hpc> the important thing is it says what the kind of Fix is, and what the true type of Fx is
11:51:28 <hpc> and not just glomming the parameters' types together
11:51:34 <gfixler> platzhirsch: I think of lifting as take something into some greater context
11:51:59 <dcz> https://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf, i am trying Excercise 2 there, http://lpaste.net/163534, my code and error in lpaste. can anybody help me ?
11:52:16 <gfixler> hpc: yes, Bartosz also shows f (Fix f) -> Fix f
11:52:25 <hpc> gfixler: also i highly recommend getting comfortable with GADTs
11:52:32 <hpc> they're the gateway drug to other type system extensions
11:52:32 <gfixler> hpc: working on that, too
11:52:49 <gfixler> hpc: sweet - I'm already addicted :)
11:53:24 <monochrom> Fix does not change.
11:53:42 <gfixler> hpc: my latest insight there was that GADTs add varying result types to ADTs
11:53:47 <monochrom> you don't even have a mutable variable here. what can change?
11:53:47 <gfixler> hpc: if that's right
11:53:55 <geekosaur> dcz, the _s in the pattern are things that are not captured. you cannot use _s after the = to refer to them
11:54:08 <hpc> gfixler: that's right
11:54:20 <geekosaur> (and ghc is treating them as "typed holes" aka "I don't know what this is; can the compiler tell me its type at least?"
11:54:27 <gfixler> hpc: wish anyone had said that in the year I spent not understanding GADTs at all
11:54:39 <gfixler> monochrom: per Bartosz: "The fractally recursive structure of Expr can be generated by repeatedly applying ExprF to itself, as in ExprF (ExprF (ExprF a)))"
11:54:53 <hpc> gfixler: they probably were saying it, or something like it
11:54:54 <gfixler> I feel that each ExprF has a different a here - am I mistaken?
11:55:06 <gfixler> hpc: well, sure, but not so simply and straightforwardly
11:55:07 <geekosaur> dcz, if you want to actually use one of the things in a Node, you have to give it a name instead of _ and then use that name
11:55:10 <hpc> gfixler: you just need some other context and to get in the right state of mind to understand it
11:55:13 <jle`> gfixler: they all just have eachother
11:55:16 <gfixler> hpc: and I've gone back and watched talks and such since, and in those, they haven't said it
11:55:25 <jle`> it's ExprF (ExprF (ExprF ... forever and ever ))
11:55:32 <jle`> there's no 'a' at the end
11:55:49 <gfixler> jle`: that's what I was wondering - is it just because they all have 'to infinity!' in the type
11:55:49 <hpc> gfixler: learning GADTs (after quite some effort) and watching others have similar trouble, has convinced me that GADTSyntax needs to be a default extension
11:56:10 <gfixler> hpc: I've also felt like I wish it was just part of normal life in Haskell, and not exotic
11:56:11 <jle`> gfixler: is what because?
11:56:14 <hpc> imo, just the syntax is enough to put people in the GADT mindset right from the start
11:56:22 <gfixler> jle`: they all have the same type, because it's infinite
11:56:27 <jle`> normal data type syntax makes more selse for pattern matching, though
11:56:35 <hpc> data Maybe :: * -> * where Nothing :: Maybe a; Just :: a -> Maybe a
11:56:40 <monochrom> gfixler, I won't comment on what others say. But suppose I want to compute 5 to the power 8. I write "((5^2)^2)^2". does "^2" change?
11:56:42 <jle`> seeing data Maybe a = Nothing | Just a makes 'case x of Just y -> ...' make more sense
11:56:57 <hpc> jle`: ah right, that's true
11:57:00 <gfixler> monochrom: no, but I guess I'm not seeing it that way yet
11:57:18 <gfixler> jle`: true
11:57:21 <hpc> the funny thing about GADT syntax is that it actually creates a scenario where NOT having GADTs is weirder than having them
11:57:27 <jle`> i don't have a strong final opinion though, it's just that the pattern matching/deconstructing aspect is what is keeping me from making the change completely in my teaching
11:57:34 <hpc> "why does Just's type have to have the type variable?"
11:57:41 <hpc> "what if i want JustInt :: Int -> Maybe Int?"
11:57:58 <hpc> well have we got the language extension for you!
11:58:05 <gfixler> hpc: I spent way too long not really grokking why type parameters were a thing
11:58:40 <gfixler> let me see if I can shed light on my confusion
11:58:53 <gfixler> ExprF a - not sure what a is, but it's a type
11:59:10 <gfixler> ExprF (ExprF a) - the outer one now seems to me to have a different type
11:59:15 <gfixler> it's not a now, it's ExprF a
11:59:22 <geekosaur> a is a placeholder
11:59:25 <gfixler> so my question was "are they the same, because it's an infinite recursion?"
11:59:32 <geekosaur> it asserts nothing about what it's holding the place of
11:59:44 <gfixler> geekosaur: but once the type is resolved, then it wouldn't match
11:59:46 <jle`> you can think of it as the difference between [a] and [[a]] ?
11:59:48 <geekosaur> in ExprF (ExprF a), that is a *different* a
12:00:03 <gfixler> jle`: right - those are different types, no?'
12:00:13 <monochrom> data MyWorld = Bieber | Justin Int
12:00:17 <jle`> forall a. [a] and forall a. [[a]] are pretty different, yeah
12:00:27 <gfixler> geekosaur: so now a is (ExprF a)?
12:00:35 <gfixler> jle`: that's what I'm struggling against here
12:00:52 <geekosaur> gfixler, think of it as a refinement. a has been refined into (ExprF a) which can be refined into ExprF (ExprF a) which can be refined into...
12:01:11 <gfixler> geekosaur: that's what I was meaning by "does it work because it's infinite?"
12:01:15 <geekosaur> and this doesn't bottom out; that's the *essence* of Fix
12:01:18 <gfixler> we never get to fully resolve it, so it never disagrees
12:01:31 <hpc> it depends on what notion of sameness you are using
12:01:43 <geekosaur> but you have to use a trick like Fix (or Mu) to express that in Haskell's type system, because otherwise it would complain about an infinite type
12:01:45 <hpc> [a] and [[b]] will unify to a = [b]
12:01:50 <gfixler> hpc: oh great, I have to define equality now?
12:02:11 <hpc> [a] and [[a]] will fail to unify with a = [a]
12:02:12 <gfixler> hpc: yes, that's the essence of my confusion
12:02:17 <gfixler> hpc: exactly
12:02:23 <gfixler> hpc: so my questions make sense now?
12:02:36 <gfixler> I have 2 competing notions in my head currently
12:02:38 <hpc> but if you say "these are two different examples that happen to use 'a'", they unify again
12:03:09 <gfixler> ExprF (ExprF (ExprF a)) - either each is a separate ExprF, with its own, unrelated a
12:03:10 <hpc> they're not the exact same type, in any event
12:03:19 <gfixler> or a is always another ExprF a
12:03:39 <hpc> right
12:03:43 * hackagebot hakyll 4.8.3.1 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.8.3.1 (JasperVanDerJeugt)
12:03:44 <gfixler> hpc: ha - which one?
12:03:49 <geekosaur> in a sense they're both true. that's the trick that lets us say this in Haskell
12:03:54 <gfixler> or "right" that either has to be the case?
12:03:59 <gfixler> interesting
12:04:02 <geekosaur> because if the compiler caught that a ~ ExprF a then it would error out
12:04:07 <gfixler> right
12:04:25 <geekosaur> so it's split into two steps, in which it is not obvious that that is true, so as far as ghc is concerned they are different a-s
12:04:47 <hpc> that split happens on the data/type constructors
12:05:01 <Profpatsch> What do against long linking times
12:05:19 <hpc> Profpatsch: refactoring, or using gold instead of ld
12:05:20 <Profpatsch> incremental development is no fun this way.
12:05:22 <geekosaur> Profpatsch, use gold instead of binutils ld if it's available. give it lots of RAM
12:05:42 <hpc> linking doesn't really have a make-it-go-fast solution
12:05:49 <Profpatsch> geekosaur: What do I have to change in order to use gold?
12:06:06 <gfixler> what's the holdup in linking? searching for something?
12:06:14 <hpc> use your package manager to install gold and it will automatically replace ld on your path
12:06:18 <geekosaur> depends. on Debian it's just a matter of installing it, and the alternatives systm will make /usrbin/ld point to it
12:06:21 <gfixler> some kind of backtracking? (I don't know how linking works)
12:06:25 <geekosaur> otherwise, consult distribution documentation
12:07:11 <hpc> gfixler: i know enough to not want to know, but not enough to know either
12:07:18 <geekosaur> gfixler, just having to resolve lots of symbol references across lots of object files and shared and posibly static libraries
12:07:19 <hpc> it's just one of those can't-be-made-parallel things
12:07:30 <gfixler> hpc: :)
12:07:32 <hpc> afaict
12:07:39 <geekosaur> basically, mutable updates to a *very* large symbol table
12:08:03 <gfixler> geekosaur: circular dep issues as well?
12:08:04 <hpc> gold does a better job of tracking all the data for the particular pathological case of ghc output
12:08:08 <geekosaur> you can reduce the time needed by building ghc without split-objs, but the price you pay for that is much larger programs
12:08:52 <geekosaur> because it ends up dragging in a bunch of crap you don't need that happens to be lumped in with what you do need
12:11:11 <geekosaur> gfixler, potentially. but the main issue is that ghc by default splits stuff up so you only pull in what you need --- which means the linker is working with a large number of small objects instead of a smaller number of large objects, and current linkers don't handle that very well
12:11:58 <geekosaur> gold handles it better but ghc is in general much better at splitting things up (most languages, one source file is one object file; ghc will create potentially many objects from one source file in split-objs mode)
12:12:05 <geekosaur> ...much netter than most other compilers for any language, I mean
12:12:25 <gfixler> geekosaur: I don't know enough to have any idea if it makes sense, but I have a feeling that if everything just existed in a DAG at all times, i.e. in memory, then compiling, linking, and keeping only what you cared about would just be a single tree traversal, and super fast
12:12:32 <geekosaur> so ghc is stressing the linker in ways you rarely see in other languages, ecept in the largest of projects
12:12:46 <geekosaur> gfixler, in theory yes
12:12:59 <geekosaur> in practice, well, ghc used to do its own linker. this KILLS portability
12:13:01 <gfixler> geekosaur: totally in theory - I have the vaguest notion(s) of any of this :)
12:13:16 <gfixler> oh wait, so linking is farmed out somewhere/how?
12:13:40 <geekosaur> ?
12:13:42 <monochrom> the Fix type is just another recursive data type. similarly, the "fix" value is just another recursive program.
12:13:46 <geekosaur> we use the system linker /usr/bin/ld
12:13:51 <gfixler> is that where binutils came up earlier?
12:13:53 <geekosaur> yes
12:13:58 <gfixler> ah, interesting
12:14:02 <geekosaur> GNU binutils
12:14:18 <gfixler> I've been coding for 25 years, but never in compiled languages
12:14:23 <geekosaur> or Google's gold linker, which is the incremental linker they wrote to speed up Chrome development
12:14:25 <gfixler> there's a huge aspect of coding I'm dumb to
12:14:37 <geekosaur> (and only works on ELF-based systems)
12:14:46 <monochrom> every question you can raise about Fix's self-reference is already answer by every recursive data type's self-reference.
12:14:53 <monochrom> does [] bottom out, too?
12:15:25 <gfixler> monochrom: interesting, need to ponder that one for a bit
12:15:35 <geekosaur> thus excluding Windows, OS X, and many commercial Unixes that use COFF/ECOFF/some other object format, or those that use ELF in odd ways (ARM likes to do this)\
12:16:13 <monochrom> note that [] does not have to be Haskell's lazy []. it can just as well be SML's finite []. does that bottom out? does it ever puzzle you?
12:16:42 <gfixler> monochrom: no, which itself now puzzles me, hence the pondering
12:17:48 <johnw> could you say that Fix is "reifying the recursion", so that "Fix f" is no longer recursive at the type level, but at the value level
12:19:07 <monochrom> could you say that "data N = Z | S N" is non-recursive at the type level, just recursive at the value level?
12:19:53 <monochrom> note that I have N on both sides of =, just like we have Fix on both sides of =
12:20:30 <gfixler> I wish type things didn't always feel like riddles and tavern puzzles to me
12:20:36 <gfixler> it always takes a while to finally click
12:21:35 <monochrom> I have my own answers. But if you ask, you should certainly think about my question first, and detect and eliminate all cognitive dissonance you have until now.
12:21:49 <monochrom> i.e., N is unmysterious but somehow Fix is.
12:22:05 <gfixler> monochrom: yep - always fighting compartmentalized understandings with FP stuff
12:22:07 <monochrom> N has just as much mystery as Fix.
12:22:22 <julianleviston> What is N?
12:22:27 <gfixler> monochrom: I would argue that N is all by itself on the right there
12:22:32 <gfixler> N is Nat
12:22:35 <julianleviston> oh ok
12:23:01 <julianleviston> gfixler: did you ever do the Idris tutorial?
12:23:10 <gfixler> julianleviston: which one?
12:23:21 <monochrom> in fact, if you now conclude that you don't understand N, [], or any recursive data type at all, that is progress.
12:23:33 <johnw> monochrom: I guess I'd say N is recursive, as much as I'd call the implementation of "plus" recursive in terms of that recursion
12:23:41 <julianleviston> gfixler: the one I was thinking of was the one on the Idris site that Edwin wrote
12:23:47 <monochrom> becaucse the denotational semantics of recursive data is even more difficult than the denotational semantics of recursive programs.
12:23:52 <gfixler> julianleviston: I have Edwin's MEAP, but have fallen far behind
12:23:57 <gfixler> julianleviston: spread too thin atm
12:24:02 <julianleviston> yeah I understand.
12:24:15 <monochrom> it was such a big deal that they had to declare "set theory is unsuitable"
12:24:20 <gfixler> monochrom: I'm getting there (to admitting that)
12:24:53 <monochrom> or rather, set theory is inadequate. they needed partial orders.
12:25:15 <monochrom> no, it's worse. they needed a whole category.
12:25:33 <monochrom> they needed to combine partial order theory with category theory. yes it's that bad.
12:25:41 <gfixler> sheesh
12:25:58 <monochrom> compare with recursive programs: they just needed partial orders within set theory.
12:26:11 <julianleviston> monochrom: what’s a partial order?
12:26:34 <monochrom> reflexive transitive anti-symmetric relation
12:26:41 <gfixler> I've asked about this before, forgetting to what it pertained http://ircbrowse.net/browse/haskell?id=22694723&timestamp=1461931276#t1461931276
12:26:42 <julianleviston> monochrom: ah ok
12:26:52 <gfixler> i.e. asked about types changing in the recursion
12:27:00 <gfixler> I think I was thinking about things like Fix
12:28:25 <gfixler> I'll have to pick this up later - need to go - thanks all!
12:35:21 <dcz> ski : are you here ? :D
12:38:01 <monochrom> johnw: Operationally, but are recursive. To consume a value of type N, you may find that it's S n with n:N again. To compute n `plus` m, you may find that you run into plus again.
12:38:07 <monochrom> s/both/
12:38:11 <monochrom> err, s/but/both/
12:38:38 <monochrom> Denotationally, well, denotational semantics is in the business of removing recursion (only to move it to the meta-level).
12:39:42 <monochrom> A certain least fixed point exists somewhere, and it is the denotation of N. Another least fixed point exists somewhere else, and it's the denotational of plus.
12:42:47 <monochrom> you probably say I haven't answered "is N recursive, at the type level?"
12:43:06 <monochrom> because if I speak of "consume a value of type N" that's just value level.
12:44:21 <monochrom> but here is a way to see it. if I really need a least fixed point denotationally, then I know it is really recursive.
12:45:53 <monochrom> denotationally, proving that "a certain poset exists to be the container of all values of N" requires a least fixed point too. yes, least fixed point to obtain a set (poset rather), not just least fixed point to obtain an element of a poset.
12:46:22 <monochrom> so it's recursive at the type level too.
12:48:27 <monochrom> and here is where you bring in category theory. because now you're asking the question "I have a whole family of posets. do they have a colimit?"  and then suddenly you don't want to worry about whether that family is small enough to be a set.
12:50:26 <monochrom> data is too hard. let's go programming.
12:51:51 <bblfish> Great blog post on Comonads and graph decomposition (in Scala ok, but very nicely illustrated) http://blog.higher-order.com/blog/2016/04/02/a-comonad-of-graph-decompositions/
12:52:23 <bblfish> I have dropped a few links at the end of it to research in Category Theory and the Graphs as explained in the Semantic Web.
12:54:42 <parsnipM_> can i get stack to install a stack.yaml in a repo that just has a *.cabal file? 
12:55:55 <parsnipM_> ah, `stack init' seems to have done it
12:56:38 <geekosaur> parsnipM_, there is also #haskell-stack
12:56:49 <geekosaur> (especially when this channel gets busy)
12:59:14 <parsnipM_> geekosaur: ah, thanks
13:00:59 <jackhill> Hi, how do I do STARTTLS with the LDAP <http://hackage.haskell.org/package/LDAP> package?
13:25:00 <bmuk> Where does startApp come from (or rather, what port does it listen on by default?)
13:27:21 <bmuk> nevermind -_- I just realized it's defined in Lib.hs
13:27:54 <bmuk> so it's running on 8080 (and the app works locally), but when I try to run it inside docker I can't reach the service
13:29:06 <jle`> how would i go about submitting a patch to `base` ?
13:32:10 <haskell509> Hey ....can anyone help? ...I am just starting to learn Haskell and was writing a program in which I had to define a data type mountain with attributes height and name. I then had to define another data type called mountain range which took three mountain types. In the final two questions I had to write a function which output the height of the highest mountain in a mountain range and another which told you the name of the highest
13:33:24 <jle`> haskell509: did you have a specific question? :)
13:33:37 <jle`> what part is giving you trouble?
13:35:46 <haskell509> I'm not sure how to access the attributes of one type through another? i have defined the data types and i could output the height/name of a mountain but not the highest in a range because i'm not sure how to work with the Mountain attributes through the mountain Range type 
13:36:06 <Rembane> haskell509: By pattern matching!
13:39:29 <haskell509> I have used this method to work with just Mountain and output height: "getHeight (Mountain _ h _ _ )= h" ....but if i pass type mountainRange to a function how do i then access each mountain in the range and then specifically height..
13:42:23 <byorgey> haskell509: for example, map getHeight mountainRange  will give you a list of all the heights in the range
13:43:02 <gfixler> byorgey: MountainRange seems to take 3 Mountains, not a list
13:43:11 <byorgey> ah, sorry
13:43:20 <gfixler> haskell509: is that right? is your data type something like MountainRange Mountain Mountain Mountain?
13:43:56 <haskell509> yes mountainRange takes three mountain types 
13:44:07 <byorgey> what Rembane said makes sense then.  You can nest patterns arbitrarily, e.g.   tallest (MountainRange (Mountain _ h1 _ _) (Mountain _ h2 _ _) ...)
13:44:59 <Rembane> haskell509: You can also create helper functions for accessing specific attributes of a data type.
13:47:21 <haskell509> thank you! I will try work with the nested patterns! hadn't seen it done like that. Thanks
13:47:33 <Rembane> haskell509: No worries, good luck!
13:47:49 <julianleviston> haskell509: This might help! :) http://happylearnhaskelltutorial.com 
14:07:34 <eacamero_> Is there a trick to tell stack to install ghc-mod in a project- or snapshot- specific location so my editor will always use the right ghc-mod across projects?
14:28:47 * hackagebot th-desugar 1.6 - Functions to desugar Template Haskell  https://hackage.haskell.org/package/th-desugar-1.6 (RichardEisenberg)
14:28:49 * hackagebot singletons 2.1 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.1 (RichardEisenberg)
14:58:48 * hackagebot stratosphere 0.1.1 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.1.1 (jdreaver)
15:07:41 <sm> eacamero_: 1. be in the project directory when you stack install it, then 2. make sure your editor looks in ./.stack-work/install/ARCH/SNAPSHOT/GHCVER/bin before other locations
15:08:45 <eacamero_> sm: thanks. I discovered that. Except stack install always seems to put it in ~/.local/bin. But `stack build` puts it where you said
15:08:49 * hackagebot ip 0.2 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.2 (andrewthad)
15:08:55 <sm> ah, true
15:11:20 <Welkin> eacamero_: `install` with "install" it
15:18:49 * hackagebot MissingH 1.3.0.2 - Large utility library  https://hackage.haskell.org/package/MissingH-1.3.0.2 (davean)
15:29:52 <Hijiri> :t (`elem`0
15:29:53 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:29:55 <Hijiri> :t (`elem`)
15:29:57 <lambdabot> parse error on input ‘)’
15:30:55 <jle`> :t `(`elem`)`
15:30:56 <lambdabot> parse error on input ‘`’
15:41:27 <EvanR> so type compose... this looks interesting
15:43:40 <EvanR> type App = (Feature1 `O` Feature2 `O` Feature3) :$ Basicc
15:44:17 <koz_> EvanR: It's on my to-read list.
15:49:34 <pyon> Is it a sign of bad design if I need to plumb data along lots of canonical isomorphisms? (e.g., “assoc :: ((a,b),c) -> (a,(b,c))”)
15:49:49 <jle`> pyon: maybe consider making a custom data type?
15:58:57 <EvanR> pyon: i had this issue with microtubes which uses a monoidal category
15:59:37 <EvanR> i made a quasi quoter which solves a goal of the form x x y -> z y x w , and outputs a network of swaps copies and merges
15:59:47 <EvanR> which corresponds to the assoc thing in arrow
16:08:46 <pyon> EvanR: Well, I'm not doing something *that* high-level. I'm just abstracting over the balancing strategy of search trees.
16:18:35 <int-e> I'm probably not the first to play with this kind of pattern synonym for Typeable / generics:  pattern X t <- (cast -> Just t)  ... is there a standard name for it?
16:20:38 <Denommus> is there a specific channel for megaparsec?
16:21:23 <jacereda> hmmm, looks like 'syb' fails on negative numbers...   gread $ gshow $ (-42)::Int fails to parse back the number
16:21:58 <jacereda> but I'm unable to figure out if it's gread or gshow the broken one
16:23:08 <Denommus> I wish megaparsec had a tutorial on making a parser and a lexer on two different phases
16:28:27 <int-e> jacereda: gread relies on `hsLex` to parse a constructor name, but -10 is to haskell tokens...
16:29:36 <jacereda> int-e: gread "(-42)" fails, but gread "((-42))" is ok
16:30:31 <jacereda> int-e: the problem is that gshow will return "(-42)" I think
16:30:44 <int-e> > readConstr (dataTypeOf (1 :: Int)) "-10" >>= fromConstrM undefined :: Maybe Int
16:30:47 <lambdabot>  Just (-10)
16:32:01 <int-e> jacereda: no, that's fine.
16:32:04 <int-e> > (gread :: ReadS Int) "(10)"
16:32:06 <lambdabot>      Not in scope: ‘gread’
16:32:06 <lambdabot>      Perhaps you meant ‘read’ (imported from Prelude)
16:32:40 <int-e> ah right, unsafe module.
16:33:06 <int-e> jacereda: anyway, gread "(10)" :: Int  works... the parentheses really aren't the issue.
16:33:15 <gabbiel> why is [e | x <- xs, p x, y <- ys] more efficient than [e | x -< xs, y <- ys, p x]?
16:34:03 <jacereda> int-e: yes, my problem is parsing back negative numbers serialized in a record serialized via gread
16:35:39 <int-e> > ([e | x <- [1], even x, y <- 1:2:3:undefined], [e | x <- [1], y <- 1:2:3:undefined, even x])
16:35:43 <lambdabot>  ([],*Exception: Prelude.undefined
16:35:49 <kadoban> gabbiel: I'm not sure it necessarily has to be. But practically, it's testing 'p x' for every pair of x and y in the second one. In the first one, it's only testing it for every x.
16:36:53 <int-e> (that example shows that a compiler that optimizes this would potentially be changing bottoms to defined values, something that it usually tries hard to avoid.)
16:36:59 <jacereda> int-e: (gread $ gshow (10::Int)) :: [(Int,String)] is ok, (gread $ gshow (-10::Int)) :: [(Int,String)] isn't
16:37:54 <int-e> jacereda: expanding what I wrote above: gread relies on `hsLex` to parse a constructor name [as a single token!], but -10 is two [not one!] haskell tokens...
16:37:57 <gabbiel> i see
16:38:23 <jacereda> int-e: so the problem is in gshow: gshow ((-10)::Int) -> "(-10)"
16:38:33 <jacereda> int-e: it should have returned "((-10))"
16:40:13 <int-e> jacereda: uh, I see what you're saying, but no. I think the fact that ((-10)) is parsed successfully is an accident; -10 is treated as an infix operator there.
16:40:34 <jacereda> int-e: so, am I wrong thinking that gread . gshow should be id?
16:40:58 <int-e> jacereda: no that is supposed to work... but I'm blaming gread for it, not gshow.
16:41:39 <jacereda> int-e: ok, I'll open a ticket tomorrow... thanks for your help
16:42:15 <geekosaur> jacereda, the point is that negative numbers are a wart in Haskell, and create lots of weird edge cases. you just tripped over one
16:42:23 <int-e> jacereda: -10 is supposed to be the constructor name for the Int value -10. And gshow represents values as (ConstructorName arg1 arg2 arg3...).
16:42:25 <geekosaur> negative literals that is
16:43:26 <int-e> jacereda: that's why I think that gshow is the correct one of the broken (gshow, gread) pair.
16:44:18 <int-e> Let me ask this once more: I'm probably not the first to play with this kind of pattern synonym for Typeable / generics:  pattern X t <- (cast -> Just t)  ... is there a standard name for it?
16:51:15 <gabbiel> @src Nat
16:51:15 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:15:52 <Squarism> cant you do "map f anMaybeValue"
17:15:58 <Squarism> ?
17:16:39 <mauke> no, but you can fmap
17:18:10 <Squarism> hmm.. in scala map on list and maybe just applies f to each element
17:18:51 <Squarism> isnt Maybe seen as a list of sorts in haskell? 
17:19:02 <mauke> no
17:19:06 <geekosaur> the haskell 98 committee decided it would be too confusing for map to be polymorphic like that so we're stuck with fmap :/
17:20:11 <Squarism> ok
17:22:36 <geekosaur> Squarism, the Foldable typeclass does act like that, in effect. but Maybe is not implemented as a list; it's a distinct type that happens to be isomorphic to a list that can have 0 or 1 elements
17:24:26 <Squarism> funny, i learned the word isomorphic this weekend when i, out of curiosity, watched a talk of a Fields price medalist. Im a math amatuer
17:24:59 <geekosaur> "like", with some math formalism attached
17:25:25 <geekosaur> (or, literally, "same shape")
17:25:52 <parsnipM_> maps that go back and forth, that respect the spaces operations
17:27:59 <nilof> That feel when you start thinking fluently in terms of pattern matching when writing recursive functions
17:28:09 <parsnipM_> so like, if it were groups, the group operations are respected, so phi(a⊕b) = phi(a) ⊙ phi(b)
17:28:14 <nilof> a.k.a "why doesn't every language have this?"
17:29:09 <Squarism> parsnip, i get it
17:29:17 <nilof> oo, are you talking about homomorphisms?
17:30:53 <parsnipM_> precisely. and so when it is a bijection (one-to-one and onto) then it is a isomorphsim, IIRC. And homomorphisms generalize to the term "morphism", IIRC> 
17:32:02 <parsnipM_> according to that structure, they are pretty much the same. 
17:33:59 <parsnipM_> for example, S_3, the permutations of 3 things, is isomorphic to D_3, the operations on a triangle that leav vertices at vertices. 
17:34:10 <parsnipM_> "IIRC"
17:34:33 <parsnipM_> that's a special case, in general, S_n is not isomorphic to D_n
17:35:08 * parsnipM_ scurries after relating his complete knowledge of the world. 
17:35:14 <parsnipM_> *scurries off
17:40:07 <Squarism> ive bought "Programming in haskell" and "Real World Haskell". Any thoughts on these?
17:40:39 <julianleviston> Squarism: They’re really out of date
17:40:50 <Squarism> gah
17:40:51 <julianleviston> Squarism: good content, though!
17:41:01 <Clint> you should recycle RWH immediately
17:41:13 <julianleviston> Clint: c’mon it has a lot of good stuff in it.
17:41:20 <eer> in the context of Maybe a -> MaybeT m a, is there a canonical name for `maybe mzero return` ?
17:41:27 <Welkin> lol
17:41:29 <Clint> julianleviston: i found it to be worse than nothing
17:41:35 <parsnipM_> when i understand haskell better, i was thinking i might taking a stab at working through RWH looking for where to modify it. 
17:41:38 <julianleviston> Clint: holy bananas!
17:41:43 <Squarism> i feel stupid
17:41:48 <Squarism> maybe i can return them
17:41:57 <julianleviston> Squarism: RWH is free online to read anyway
17:42:08 <Squarism> i want paper books for summer
17:42:12 <julianleviston> ah
17:42:18 <Welkin> kindling?
17:42:26 <julianleviston> The hutton one is good
17:42:30 <Squarism> so what is better books? 
17:42:32 <Squarism> are
17:42:34 <Welkin> bon fires on the beach?
17:42:39 <Squarism> ...for a half noob
17:42:44 <parsnipM_> i'm working through Haskell Programming
17:42:53 <parsnipM_> cis194 is mentioned a lot too
17:43:00 <Welkin> Squarism: there are not very many beginner haskell books
17:43:09 <Welkin> luckily, you can cover the basics with pretty much anything
17:43:09 <julianleviston> I’m gonna be massively biased and say our tutorial :)
17:43:22 <julianleviston> Squarism: http://happylearnhaskelltutorial.com
17:43:22 <Welkin> then move on to reading some of the amazing papers written by SPJ
17:43:27 <Welkin> and the typeclassopedia
17:43:33 <Welkin> @where learnhaskell
17:43:33 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:43:35 <Welkin> there too
17:43:45 <Welkin> you will not find a single book that ahs it all
17:43:58 <Welkin> there is haskellbook.com though
17:44:05 <Welkin> I have heard good things about it
17:44:11 <Squarism> ok ok
17:44:29 <julianleviston> and the haskell wiki book isn’t half bad
17:44:44 <julianleviston> it had some pretty awfully dense places, too, but yeah, it’s quite good.
17:45:11 <Squarism> parsnip, cis194?
17:45:15 <Welkin> Squarism: http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
17:45:18 <parsnipM_> LYAH is nice for brief introduction, you can copy the code into your own prompt, but it lacks real exercises. 
17:45:21 <Welkin> it' a goldmine
17:45:22 <julianleviston> @where cis194
17:45:22 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
17:45:39 <Welkin> especially read "Lazy Functional State Threads" to learn how IO in Haskell works
17:45:48 <Welkin> it was the most eye-opening paper so far for me
17:45:52 <idev> while in ghci, is there a command to type which does the same as typing "cabal build" outside of ghci ?
17:45:56 <Welkin> very easy to understand too
17:46:02 <julianleviston> I think concurrent and parrallel programming in Haskell is excellent...
17:46:04 <idev> I knowthere's :reload, but it's not clear that it builds a binary insgtead of just reloading it in place
17:46:07 <Squarism> parsnipM_, i foudn that to be very ghci centric
17:46:18 <julianleviston> Squarism: http://chimera.labs.oreilly.com/books/1230000000929
17:46:39 <julianleviston> idev: it doesn’t build a binary… 
17:46:53 <Squarism> julianleviston, if i have no interrest in parallell and concurrant?
17:46:58 <Squarism> =D
17:47:05 <sm> idev: :!cabal build
17:47:06 <idev> julianleviston: is there a way to make it build a binary?
17:47:06 <Welkin> after you learn the basics, just ask questions here, read source code, and read lots of papers
17:47:07 <julianleviston> Squarism: it’s just good for learning Haskell
17:47:10 <Welkin> like the ones I linked
17:47:24 <Welkin> and start on a project of your own
17:47:25 <julianleviston> idev: I don’t know. Why do you want to?
17:47:35 <idev> julianleviston: I'm using ghcjs
17:47:43 <idev> julianleviston: "cabal build" with ghcjs is slow, but ghcjsi is fast
17:47:44 <julianleviston> idev: oh I have no clue sorry
17:47:46 <Squarism> Welkin, ok.. im on it
17:47:53 <idev> if I can get my ghcjs builds to be as fast as ":reload" in ghcjsi, I'd be so hapy
17:47:57 <idev> it'd increase my productivity
17:48:01 <idev> save puppies
17:48:05 <idev> hold back climate change, etc ...
17:48:26 <julianleviston> idev: I think the people doing work on that reactive framework were superkeen on getting that working faster… hmmm
17:48:36 <sm> probably cabal build -O0 --ghc-options=-fno-object or some such goes faster
17:48:46 <julianleviston> I can’t for the life of me remember the name of it right now. In fact, I nver can… reflux? reflex?
17:48:53 <idev> reflex-frp
17:48:57 <Welkin> reflex-dom
17:48:58 <julianleviston> oh yeah https://hackage.haskell.org/package/reflex-dom
17:49:00 <zeawee> what about learnyouhaskell?
17:49:24 <Welkin> zeawee: it is okay as a gateay to ease people into haskell, but it is not enough to really learn the basics well
17:49:31 <Welkin> gateway*
17:49:35 <Welkin> that is how I used it
17:50:39 <julianleviston> idev: halogen is supposed to be really fast at compiling… but it’s in purescript…
17:50:56 <julianleviston> idev: sorry what a silly thing to say
17:51:13 <zeawee> oh... I am about to finish the book, (I'm on monoids now) and not very easy to understand at the moment tho..
17:51:36 <idev> julianleviston:I'd prefer haskell on client + server side
17:51:38 <idev> so I can use aeson
17:51:59 <julianleviston> zeawee: I found the latter chapters of learnyouahaskell really hard to understand even when I actually knew what was going on!
17:52:10 <Welkin> yes
17:52:17 <Welkin> near the end it turns into a jumbled mess
17:52:22 <julianleviston> also found myself going to sleep
17:52:28 <Welkin> use the UPenn course instead
17:52:32 <Welkin> and the typeclassopedia
17:52:46 <Welkin> and a few good essays, like the monoid one from apfelmus
17:52:57 <Welkin> and the "you could have invented monads" essay
17:53:03 <julianleviston> ugh
17:53:28 <julianleviston> Welkin: people seem to love that, but wasn’t really my cup of tea
17:53:32 <Welkin> haha
17:53:44 <Welkin> I use every resource I can get my hands on
17:53:50 <julianleviston> yeah :)
17:53:54 <Welkin> I studied widely to really grasp the concepts
17:54:01 <Welkin> it wasn't one magic book or paper
17:54:04 <julianleviston> I love neighborhood of infinity for other things
17:54:18 <Welkin> asking questions in here and tinkering on my own was most beneficial of all
17:54:21 <zeawee> I finished reading applicative functors in 2 days lol
17:54:36 <zeawee> was hard to get the examples...
17:54:50 <julianleviston> reading is substantially different from being able to use, though… which is where “LYAH” falls down
17:54:52 <Welkin> yeah, it sounds like it's time to drop LYAH
17:54:57 <Welkin> and get some better resources
17:56:09 <zeawee> I really want to do phd in FPLs :/
17:56:36 <zeawee> cant think of anything else in last couple of months
17:56:51 <Welkin> why?
17:58:16 <Welkin> hello atan
18:01:23 <zeawee> because I have a feeling like I cant ever find a job / convince people to use FPLs in industry, and people around me have no clue what I am talking about when I start talking about PLs... so it feels like I will keep reading things to myself... so academics seems to be the only way to go.. quite depressed in these days
18:01:41 <julianleviston> There are jobs
18:01:56 <Welkin> that's a horrible reason to chase a PhD O.o
18:03:28 <zeawee> and I LOVE it ofc... want to improve stuff in PL world. I feel like I can dedicate my life on it
18:04:24 <maerwald> Welkin: how's that a horrible reason? If there is true dedication, then it's always a good reason, no matter where that dedication comes from.
18:04:37 <Welkin> if you enjoy something, then just do it
18:04:48 <Welkin> but there is no reason to put yourself through a PhD
18:04:51 <Welkin> what's the point?
18:04:54 <Welkin> if you like it, then study it
18:05:07 <maerwald> he just explained it
18:05:09 <zeawee> it's better than sitting at home...
18:05:10 <Welkin> a PhD is it's own crappy job
18:05:17 <zeawee> yep, indeed
18:05:18 <Welkin> my PhD friends always complain about it
18:05:31 <zeawee> mine too
18:06:07 <zeawee> but I don't have so many options really
18:06:19 <Welkin> everyone has options
18:06:32 <Welkin> it's a mistake to think that you need to get paid to do something you love
18:07:09 <zeawee> there are different parameters as society, make your living, etc..
18:07:10 <Welkin> think about what you can do for other people, not about what you want
18:07:22 <Welkin> that is what will bring in money
18:07:28 <Welkin> and then you can do anything you want
18:07:41 <maerwald> or not
18:08:03 <Welkin> that is how it works
18:08:10 <Welkin> an exchange of services for payment
18:08:26 <Welkin> no one cares what you want and they won't pay you for it
18:08:32 <Welkin> they will only pay you for what they want
18:08:36 <zeawee> that's what I'm doing at the moment
18:08:43 <zeawee> and I find it quite depressing
18:08:45 <maerwald> this seems offtopic, can you continue at #haskell-offtopic?
18:08:55 <Welkin> maerwald: I'm banned from there
18:08:55 <zeawee> oh, so sorry yea.
18:09:02 <maerwald> Welkin: what?
18:09:16 <maerwald> Welkin: I don't mean #haskell-blah
18:09:21 <Welkin> oh
18:18:56 * hackagebot tn 4.1.0.0 - A simple daily journal program  https://hackage.haskell.org/package/tn-4.1.0.0 (pharpend)
18:18:58 * hackagebot influxdb 0.10.0 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-0.10.0 (MitsutoshiAoe)
18:47:39 <pavonia> Is there a package similar to aeson but for XML, i.e. with a parser that can convert XML to arbitrary datatypes and vice versa?
18:53:24 <java_pro> hi
18:53:34 <marcx> hi
18:54:33 <java_pro> hello marcx
19:03:04 <julianleviston> pavonia: I wonder if this is still around… https://wiki.haskell.org/HXT
19:03:48 <julianleviston> pavonia: then there’s this snoyman package… his stuff is usually really well maintained: https://hackage.haskell.org/package/xml-conduit
19:04:05 <vctr> julianleviston didn't lens borrow a lot of hxt functionality?
19:04:22 <julianleviston> vctr: oh, did it?! I didn’t know that.
19:05:04 <vctr> julianleviston actually i think i was just remembering this https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
19:05:26 <vctr> so it may not have been influenced at all, just having some overlapping functionality
19:05:45 <julianleviston> Yeah, for sure. Lens overlaps with anything that pulls data out of things pretty much
19:06:57 <julianleviston> Was reading the source for it a couple days ago. wow… got me all curiousy like… :) nice to know I understand loads more Haskell now though compared to the first time I looked at it and went “What th…?”
19:07:33 <scshunt> heh, yes
19:08:05 <julianleviston> It’s actually not that crazy, really. Just lots of type variables, type synonyms and loads of operators make things seem insane.
19:08:16 <julianleviston> and the fact that it’s super-duper general
19:08:19 <pavonia> Hhm, I already had a look at xml-conduit but it's probbly not what I want
19:08:25 <julianleviston> aw
19:08:39 <vctr> seems like pipes has more mindshare
19:08:43 <pavonia> hxt seems to be huge
19:09:30 <julianleviston> pipes for XML parsing? wha!?
19:09:37 <julianleviston> isn’t pipes to do with CSP style things?
19:10:07 <vctr> my impression was that pipes and conduits were almost interchangeable
19:10:41 <julianleviston> oh this is xml-conduit - bit different
19:11:12 <julianleviston> (I think)
19:11:37 <vctr> not analogous to something like https://hackage.haskell.org/package/xml-pipe ?
19:11:55 <julianleviston> I have no idea
19:12:11 <vctr> heh docs aren't confidence inspiring
19:12:19 <vctr> "This package process subset of XML and is still far from perfect, now."
19:13:51 <Cale> It probably depends somewhat on what the application was, but I think the first library I'd consider if I had to deal with some XML format would be hexpat-pickle
19:14:27 <julianleviston> oh wow I’ve never even heard of that
19:14:54 <julianleviston> Cale: that’s so cool! :)
19:15:08 <vctr> let's see what haskelliseasy says
19:15:17 <vctr> xml-conduit, taggy, taggy-lens
19:15:32 <vctr> thankfully i don't have to deal with xml at the moment
19:16:36 <julianleviston> Oh there’s just this https://hackage.haskell.org/package/xml
19:19:26 <EvilMachine> So Typeable allows me to cast in a safe way for input values, but what if I want my result value to be generic too? (As in: Do something special if an unhandled type is requested.)
19:20:30 <idev> is there anything like meteor/derby for haskell ?
19:20:37 <idev> I'd like the power of meteor/derby, but I want it typed
19:21:16 <pavonia> "XML pickler," what a weird name
19:21:30 <julianleviston> What about purescript? Doesn’t that have pretty good JS interop? In which case you could just use that and use meteor
19:21:59 <pavonia> Cale: hexpat-pickle looks like a small package for what I need, thanks
19:23:48 <EvilMachine> idev: With WebAssembly and the general utter insanity of WhatWG, I replaced the goal of “the best oil lamp” with “a quantum dot LED lamp”, and went straight to building a normal application, to run in the browser via WebAssembly & OpenGL, etc :)
19:24:11 <vctr> EvilMachine have you made any progress?
19:24:20 <vctr> it seems like WebAssembly is still many years out
19:24:28 <idev> EvilMachine: what's WhatWG ? what are you talking about ?
19:24:44 <vctr> and C++ will be first in line to get first class support
19:24:51 <julianleviston> idev: they’re the web working group
19:24:55 <EvilMachine> vctr: Well, for games, which is my main thing, I just use Godot, which will have both WebAssembly (and already uses Emscripten), and Vulcan.
19:25:07 <idev> julianleviston: thanks
19:25:11 <EvilMachine> vctr: But my dream is to rewrite Godot in Haskell. :)
19:25:17 <vctr> evilmachine oh so you aren't using haskell
19:25:19 <idev> EvilMachine: so basically you're saying f*ck javascript; just compile to web asembly?
19:25:25 <idev> EvilMachine: what is the haskell -> webassembly tool chain like ?
19:25:28 <EvilMachine> idev: Yep. :D
19:25:40 <EvilMachine> idev: I doesn’t exist yet, I think.
19:25:42 <Adeon> despite the name webassembly, wasn't it a bit higher level
19:25:46 <Adeon> like AST type thing
19:25:51 <Adeon> would haskell compile to that easily?
19:25:53 <vctr> why godot? i was looking into a bunch of engines a while back
19:25:56 <EvilMachine> Adeon: Maybe you mean asm.js…?
19:26:02 <Adeon> no I mean webassembly
19:26:17 <marcx> AST? lispy?
19:26:25 <vctr> including godot but most seemed like a chore to work with
19:26:43 <vctr> unity and unreal seem like unweildy monoliths
19:26:47 <vctr> c4 is like years behind
19:26:54 <Adeon> yeah webassembly appears to use an AST instead of a low-level machine
19:26:59 <Adeon> that is
19:27:02 <Adeon> like actual assembly
19:27:07 <EvilMachine> vctr: Godot is very elegant and pretty in design. The main developer is really smart, and you can tell. It is very easy to modify and completely FLOSS.
19:27:24 <EvilMachine> vctr: And it got good graphics. Even 2D real-time global illumination.
19:27:36 <vctr> there's some neat looking open source ones like urho and godot, what's that other purescript-python one? but it's really hard to decide which horse to bet on
19:27:51 <EvilMachine> vctr: The developer’s plan is to put CryEngine and UE4 to shame. And I have no doubt that he will get there. :)
19:28:02 <vctr> given that learning an engine is a non-trivial time & effort investment
19:28:09 <EvilMachine> vctr: We may be off-topic here. :)
19:28:24 <vctr> slightly . well i'd love to see haskell leapfrog its way somehow
19:28:34 <EvilMachine> vctr: Godot now has a user-editable wiki, and the tutorials are nice.
19:28:43 <idev> http://www.godotengine.org/features does look pretty impressive
19:28:45 <vctr> i'd be happy if someone even wrote haskell-unity bindings or something
19:29:15 <EvilMachine> vctr: Godot is trying to be an open Unity with no compromises.
19:29:38 <vctr> evilmachine is anyone trying to write haskell bindings? you?
19:29:42 <EvilMachine> vctr: Its scripting language is basically an adapted (improved) Python
19:29:46 <vctr> anything to move past that helm embarassment :P
19:29:54 <EvilMachine> vctr: Maybe… )
19:30:42 <vctr> a python-ish dsl just for a game engine is exactly the kind of learning investment i want to avoid with my limited spare/self-enrichment time
19:30:54 <vctr> if i can :P
19:31:12 <EvilMachine> vctr: Head over to #godotengine, and ask the main developer what you like. I found him very responsive. (He’s in Argentinia, so remember the time zones any holidays.)
19:31:41 <EvilMachine> vctr: It’s not python-ish. If you can write python, there’s not really anything to learn.
19:31:43 <vctr> how is the enscripten build process? it always scared me a bit. that and it seems like previous "native web" efforts have been misguided
19:32:08 <marcx> right click on cmd.exe or powershell icon or executable and click run as admin. then do yer thing
19:32:18 <marcx> woops
19:32:20 <marcx> :)
19:33:28 <EvilMachine> vctr: I have set up an emscripten thing once. And Godot uses it too. So you could look inside its build instructions. I currently write normal desktop software mainly.
19:34:05 <vctr> alright i should get back to work
19:34:08 <EvilMachine> vctr: It is not that hard. I just blindly followed the instructions.
19:34:22 <vctr> gotta be up early tomorrow :(
19:34:36 <EvilMachine> Btw, my original question was: So Typeable allows me to cast in a safe way for input values, but what if I want my result value to be generic too? (As in: Do something special if an unhandled type is requested.)
19:34:44 <EvilMachine> vctr: sleep well
19:36:16 <vctr> EvilMachine curious how your haskell-y game efforts go. ecosystem desperately needs progress on that front
19:37:25 <hpc> as silly as it sounds, i think the largest stumbling block at the moment is using ffi on windows against stuff like glfw
19:37:36 <EvilMachine> vctr: Long way to go… I’m currently implementing a very generic data management library that I will use in my future software, including games. And it’s a mind-melter. So it will take a while. :)
19:38:40 <vctr> haskell project ambitions are always on a 10 years in the future timeline ;)
19:39:35 <EvilMachine> lol. yeah, the language is very close to the cutting edge of research. and everyone wants to use all the hot new stuff. so…
19:40:13 <EvilMachine> … Haskell attracts people who want to shoot beyond the stars. :)
19:41:17 <vctr> "managers hate her"
19:49:05 <GrumpyMachine> good
20:02:00 <zoran119> i have a class like this: Tree a = Node (Tree a) a (Tree a) | Leaf a
20:02:13 <zoran119> i'd like to write an instance of Show for it
20:02:31 <zoran119> so i try this: show (Leaf a) = show a
20:02:39 <tgeeky> is there a !seen in here?
20:03:16 <zoran119> but 'show a' is confusing ghc: No instance for (Show a) arising from a use of ‘show’
20:03:42 <zoran119> how can i just call 'show' for a on the right hand side?
20:04:02 <Reshi> zoran119: Are you writing this under: instance Show Tree where...
20:05:05 <zoran119> Reshi: yes
20:05:25 <zoran119> Reshi: actually instance Show (Tree a) where
20:05:34 <zoran119> Reshi: not sure if that is the right way to do it...
20:07:25 <Reshi> zoran119: It would be `instance Show a => Show (Tree a) where`
20:08:06 <Reshi> zoran119: You have to say that the type which will take a's place will also be an instance of Show since you are using `show a`.
20:09:16 <zoran119> Reshi: makes perfect sense, thank you
20:10:21 <Reshi> zoran119: you're welcome!
20:18:00 <Aspecting> l
20:32:59 <EvilMachine> Does anyone know how to make (f x :: (Blah b) => Either Int Bool -> b; instance Blah Special) return a (Special) when called with (f (Left True) :: Special), and (throw NotRepresentableException) when called with any other requested return type?
20:36:54 <pavonia> Not sure you can. What if you'd add instance Blah AlsoSpecial?
20:39:09 <EvilMachine> I can take input values with Typeable instances and reify them from generic to concrete. I like to return a specific instance that belongs to the return class if requested, and fail otherwise.
20:55:23 <EvanR> EvilMachine: "what are you really trying to do"
20:56:24 <EvilMachine> EvanR: This: http://pastebin.com/DYRStfqk
20:57:14 <EvilMachine> Something like this.
20:57:22 <EvilMachine> But this doesn’t work.
20:58:23 <EvilMachine> Even though I think it should be clear to GHC that f will call error when the type is not A, and otherwise, if A was requested, A is an instance of SomeClass, so it should be fine.
20:58:35 <EvanR> you want to be polymorphic in a class, but also detect what the type is at runtime
20:58:41 <EvanR> you could just use typeable by itself
20:59:10 <EvanR> no this code is not valid
20:59:10 <EvilMachine> EvanR: yes. what does that mean, “use typeable by itself“
20:59:35 <EvilMachine> I know it is not valid. :)
20:59:39 <EvanR> oh i see, f is not a function
20:59:50 <EvilMachine> it isn’t?
20:59:56 <EvanR> no
21:00:15 <EvilMachine> Ah, well, my actual function has more parameters, but you are right.
21:00:54 <EvanR> so what are you really trying to do?
21:01:23 <EvanR> also to do undefined :: b you need scoped type variables extension
21:02:41 <Cale> :t cast
21:02:42 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
21:02:45 <EvilMachine> Please stop that stupid meme. If I ask how to drive to somewhere, people ask “what are you really trying to do”, expecting me to tell them the exact car model and time and everything. No! The whole point is to get a generic solution that works, no matter what I try to do with it. That meme is just pseudo-intelligent!
21:02:52 <Cale> ^^ pattern match on the result of cast
21:03:17 <Cale> If you need a chain of several, remember that pattern guards are a thing
21:03:26 <EvilMachine> Hmm, GHC did not complain on the undefined :: b
21:03:36 <EvanR> its not the same b without ScopedTypeVariables
21:03:48 <EvilMachine> EvanR: Aah? Woah
21:04:00 <EvilMachine> EvanR: Thanks! 
21:04:03 <EvilMachine> :)
21:04:50 <EvilMachine> Cale: The actual functions has 3 levels of case, so I can’t use pattern guards. Otherwise thanks. :)
21:05:17 <Cale> I think you can though?
21:05:26 <EvanR> i said that because typeable+typeclass polymorphism tricks is often a warning sign to me that theres a better way
21:05:34 <Cale> Well, depending on what you mean -- pattern guards are allowed to do more than one match
21:05:57 <Cale> (you can separate them with commas)
21:07:24 <EvilMachine> EvanR: Ok. Nevermind then. I am very aware of that warning sign. This is an actual case where it is needed though. :)
21:07:36 <EvilMachine> At least I am pretty sure. :)
21:07:53 <EvilMachine> Cale: Now I don’t know what you mean anymore… 
21:09:12 <fred-fri> i finally figured out how to set up a sane, productive haskell environment. any corrections or pointers would be greatly appreciated: https://gist.github.com/androidfred/a2bef54310c847f263343c529d32acd8
21:09:19 <pavonia> EvilMachine: It's not a stupid meme. People, especially beginners, often try to solve problems by making bad/not idiomatic design decisions which may lead to overly complicated problems they are faced with. So it usually makes sense to ask for the exact use case to see if there's a better way to solve the original problem
21:11:22 <EvilMachine> This fails too: http://pastebin.com/VudjqNPZ
21:11:59 <EvanR> Typeable lets you do what you want as-is
21:12:04 <pavonia> The two cs are still different types
21:12:07 <EvanR> "if x has type A then foo else bar
21:12:08 <EvanR> "
21:13:14 <Cale> fred-fri: Would it be too glib to just suggest the following process? 1) Choose any text editor you like on the basis that you're comfortable editing text with it. 2) Configure it to convert tabs to spaces automatically. It probably already has Haskell syntax highlighting. 3) Write a few definitions and save them. 4) Open the file in GHCi and try the definitions, check types, etc., whenever you save new ones, :r will reload.
21:14:09 <EvilMachine> pavonia: I agree. That is not the stupid part though. The stupid part is people not wanting to solve the problem in a generic way at all, even when one specifically asked for a generic solution. As in: It being the whole point. … Not that anyone is forced to solve any problem he doesn’t like. But this meme ruins the option to ask for a generic solution, even though generic solutions are the optimum when programming.
21:14:40 <Cale> I guess if your intention is to work longer term on a large project, eventually stack or nix will be useful to you.
21:14:42 <EvanR> typeable isnt a very good generic solution
21:14:57 <EvilMachine> pavonia: How do I make them the same type?
21:15:03 <Cale> But for getting started learning the language, or playing around on a daily basis, it doesn't seem necessary to me.
21:15:47 <pavonia> EvilMachine: You need an explicit forall c in the type signature of f
21:16:14 <Cale> EvilMachine: Well, one thing is to figure out what you're going to do with the eventual result
21:16:30 <EvilMachine> pavonia: Ah… Damn. I think I had that already in an old experimental prototype… 
21:17:04 <Cale> EvilMachine: Capture *that* and make a record type with fields corresponding to the operations you would have performed on whatever values you got.
21:18:17 <EvanR> when you hear / hear yourself saying "man i really want totally different types here" often the answer is you actually want a uniform interface for something, a record is one way that could work
21:19:24 <Evi1M4chine> hmm, got disconnected
21:19:42 <EvanR> when you actually do need different types then it gets hairier, forcing you to develop pseudo-dependent types and figure out logic
21:19:59 <EvanR> or deal with dynamic typing failures
21:20:06 <fred-fri> Cale, for a lot of people what you suggest is enough, but for someone like me who has gotten used to coding in a proper IDE it simply isnt enough
21:21:08 <Rotaerk> fred-fri, I use visual studio at work all the time
21:21:42 <Rotaerk> I don't think I miss much with vim and a few extensions for that
21:21:51 <fred-fri> whatever floats your boat
21:22:05 <Rotaerk> I've got my go-to-definition from tags, I've got my show-me-the-type-of-this-expression with an extension
21:22:14 <marcx> Cale fields of operations being functions or actions?
21:22:26 <Cale> marcx: typically, yeah
21:22:44 <Cale> marcx: They might just be values you would have computed from whatever thing it was that the record is replacing
21:22:46 <Rotaerk> debugger isn't going to be present in vim (i think?) but debugging is a little different in haskell anyway...
21:23:20 <Rotaerk> fred-fri, is there something in particular that you miss from an IDE?
21:24:06 <fred-fri> im a professional java dev and ive always used intellij, thats all there is to it really
21:24:15 <Cale> While I totally understand the allure of debuggers and IDEs with fancy autocompletion, and I have used them a bunch, I also totally hate what they end up doing to the code due to the fact that they let you be lazy in certain ways.
21:24:56 <fred-fri> laziness is a virtue =)
21:25:02 <Cale> Especially interactive debuggers in imperative languages -- they let you take code which is already beyond your ability to understand, and extend it into a larger mess.
21:25:36 <Cale> Rather than being stuck with "oh, I can't understand this anymore, let's work on making it easier to understand first"
21:25:37 <EvanR> NamesOfStuffCanBeAsLongAsYouWantWithAutocomplete
21:26:04 <marcx> you can get autocomplete in emacs. not sure about vim
21:26:13 <EvanR> control N is autocomplete in vim ;)
21:26:22 <Cale> and indeed, even without IDEs, I work with a team of people with fancy vim setups that autocomplete and it kinda drives me crazy. :)
21:26:24 <marcx> intelligent autocomplete, that takes into account included modules, etc
21:26:24 <simpson> Cale: I'm going to have to think on this for a bit.
21:26:36 <Rotaerk> I like like being able to type "something." and get a list of members, but I'm not sure where that'd be useful in haskell
21:26:42 <Rotaerk> -like*
21:26:49 <EvanR> power of the dot
21:27:00 <fred-fri> in my java projects i have static code checkers that fail the build if you write veryLongVariableNames or do other stupid stuff
21:27:05 <EvanR> https://ghc.haskell.org/trac/ghc/wiki/Records/DeclaredOverloadedRecordFields/DotPostfix
21:27:19 <Evi1M4chine> EvanR: How about this slightly less condensed version of what I’m trying to do: http://pastebin.com/0NH6NtAA
21:27:27 <fred-fri> not all OO code is terrible. most OO code isnt even OO.
21:27:46 <Rotaerk> you mean "OO"-language code?
21:27:47 <julianleviston> fred-fri: that reminds me of the last team I worked in, where we had a “sentinel” that had to run before you could check your code in to make sure all our methods were no longer than 5 lines long! !!!
21:27:51 <Rotaerk> OO is too ambiguous
21:28:02 <julianleviston> fred-fri: amidst other “style requirements"
21:28:09 <fred-fri> i do java for a living so i come across the atrocities that are ubiquitous in java on a daily basis
21:28:20 <Cale> fred-fri: Actually, in another thread of conversation just a couple minutes ago, I proposed what is essentially an OO solution
21:29:01 <fred-fri> giant "POJOs" that are not even real classes, just a data container that completely exposes internals
21:29:02 <Evi1M4chine> julianleviston: But no less than 256 chars long, chaining dots, yes? :D
21:29:24 <julianleviston> Evi1M4chine: lol… lines 80 chars.
21:29:29 <fred-fri> verby ControllER, VerifiER, SendER, HelpER etc classes everywhere that operate procedurally on the POJOs 
21:29:30 <Rotaerk> I tend to prefer and encourage veryLongVariableNames, unless it's very obvious or not very interesting what it actually is
21:29:49 <julianleviston> Evi1M4chine: I think it had a thing for method calls too… the idea was to get you to split your methods into tiny ones. Guh.
21:29:54 <Rotaerk> they're self-documenting
21:29:55 <EvanR> Evi1M4chine: seems like you want a multi param typeclass for converting between two things
21:29:58 <Cale> You can do OO design perfectly well in Haskell because you can build records of functions and actions and other values which provide an abstract interface to something which is captured in the scope of the definition of the record.
21:30:20 * Evi1M4chine sings „Livin’ my line lengths like it’s 1981!“ (@julianleviston)
21:30:25 <Rotaerk> I feel like learning haskell allowed me to get a different, greater perspective on what OO even is
21:30:46 <EvanR> veryLongIOActionName :: IO ()
21:30:54 <fred-fri> i used to use veryLongVariableNames but these days i lean towards more than one capital variable names being a code smell
21:31:04 <EvanR> either :: (a -> c) -> (b -> c) -> Either a b -> c
21:31:05 <julianleviston> Rotaerk: definitely!
21:31:19 <marcx> Cale not sure I would call that OO? how do you simulate inheritance for example (leaving out the discussing whether inheritance is something one should want or not)
21:31:26 <Evi1M4chine> EvanR: I already had those. I nearly fully got rid of them thanks to Typeable. But you might be right.
21:31:29 <julianleviston> Rotaerk: I feel like before I’d studied monads I didn’t *really* understand what computationw as.
21:31:35 <julianleviston> computation was *
21:31:49 <EvanR> Evi1M4chine: which already exists by the way, Convertible
21:32:03 <fred-fri> actually inheritance is discouraged in favor of composition even in OO languages these days
21:32:12 <fred-fri> its just that 95% of devs havent got the message
21:32:15 <EvanR> marcx: for code reuse, you can share code in the implementations
21:32:18 <Rotaerk> julianleviston, hmm, isn't computation what occurs during any evaluation of expressions? not just monads?
21:32:20 <EvanR> using functional programming
21:32:24 <marcx> fred-fri what do you mean by composition in this context?
21:32:43 <julianleviston> Rotaerk: computation is many things! :-)
21:32:44 <EvanR> for "overriding" you can do record field update
21:32:55 <Evi1M4chine> fred-fri: One-letter variables are just code obfuscation and have zero descriptivity. The philosophy I learned, is that the length of the name should be based on the size of the scope. :)
21:33:24 <julianleviston> Rotaerk: consider evaluating a chain of maybe… I used to do that all the time and not realise I was doing it, it was just “something you had to do”.
21:33:25 <fred-fri> Evi1M4chine, im not advocating one letter variables, the build should fail on one letter variables
21:33:36 <Rotaerk> fred-fri, inheritance serves one particular purpose very well, but it's a purpose that you really shouldn't need very often
21:33:41 <Evi1M4chine> fred-fri: One-letter variables are the main reason I found it so unbearably hard to learn certain parts of Haskell.
21:33:48 <Rotaerk> i.e. taking an implementation of an interface, and tweaking/overriding it
21:33:49 <julianleviston> Rotaerk: like… not realise the actual shape of the context I was writing code within, I mean.
21:34:00 <EvanR> Rotaerk: which still doesnt require inheritance
21:34:13 <Rotaerk> no, inheritance is mostly a sugar/shorthand for it
21:34:17 <Evi1M4chine> EvanR: Never heard of Convertible. Have to look into it.
21:34:29 <Evi1M4chine> EvanR: Thank you, btw. :)
21:34:38 <Cale_> Sorry, lost my connection to FreeNode there.
21:34:50 <Rotaerk> people tend to look at the inheritance mechanism and try to use it to build taxonomies into their code
21:35:11 <Evi1M4chine> fred-fri: Hierarichal structuring is one of the big problems I have with the way classes, file systems etc are designed… :)
21:35:12 <Rotaerk> "a terrier is a dog is an animal, so that's a three-tier inheritance tree !"
21:35:32 <Cale> marcx: Well, you don't get inheritance, but in my mind inheritance and subtyping were always red herrings brought on by the mistake of tying method implementations to types.
21:36:02 <Rotaerk> the key to implementing interfaces, and thus inheritance, is to recognize that it's not about conceptual taxonomies
21:36:08 <Rotaerk> it's about liskov substitutability
21:36:18 <Cale> marcx: With this approach, yeah, all your objects need to have the same interface, fair enough, but usually that's fine so long as they can implement all the methods differently.
21:36:37 <Rotaerk> i.e. it must guarantee no less, and must require no more than the interface it implements
21:36:43 <Cale> and if you really want, you can break it up into smaller parts and such, how you'd normally refactor types
21:36:48 <EvanR> subtyping is the technology of implicit conversion, but which conversion
21:36:57 <EvanR> quotient, or injection
21:36:59 <EvanR> or other
21:37:17 <Evi1M4chine> Rotaerk: can you translate liskov substitutability for someone who’s not a CS professor? Sounds like something I should learn.
21:37:44 <Rotaerk> Evi1M4chine, it's just the name of one of those SOLID principles of OO
21:37:47 <EvanR> id be interested in a formal definition as well
21:37:54 <Rotaerk> they're not confined to OO though, in principle
21:38:12 <Evi1M4chine> Rotaerk: So if I google “SOLID principles of OO”, I will find it?
21:38:13 <Rotaerk> https://en.wikipedia.org/wiki/Liskov_substitution_principle
21:38:20 <Evi1M4chine> Ah, thanks.
21:38:41 <EvanR> the phrase "liskov substitutability is undecidable in general" makes me think somebody has precisely defined it
21:39:01 <Rotaerk> I think this is where I originally learned of SOLID:  http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
21:39:14 <Rotaerk> probably my first foray into "wait, there's actually a such thing as 'good' design?"
21:39:16 <Evi1M4chine> Rotaerk: Ah, I knew that! Maybe I should go to bed. 06:38 (AM) here, and I’m still up.
21:40:12 * julianleviston hugs Evi1M4chine 
21:40:27 <Evi1M4chine> :) 
21:40:41 <Evi1M4chine> julianleviston: Thank you.
21:41:05 <Rotaerk> a common example of why liskov substitution is more important than conceptual taxonomy is rectangles and squares
21:41:13 <Rotaerk> conceptually, squares are rectangles
21:41:16 <Evi1M4chine> Rotaerk: We’ve come a long way from BASIC… :D
21:41:45 <Rotaerk> but that doesn't automatically mean you can implement a rectangle interface with a square
21:41:46 <Cale> Early typed OO languages made it so that classes are the same thing as types, and they're defined along with the method implementations. I suspect this was because implementations of languages with first class procedures weren't very good at the time.
21:41:50 <Evi1M4chine> Rotaerk: if you define squares as very low-res rectangles? :D
21:41:55 <Rotaerk> it really depends on what that rectangle interface guarantees/requires
21:42:14 <Evi1M4chine> Rotaerk: oh, nevermind. I thought you said circles
21:42:15 <EvanR> circle ellipse is solved with immutable data
21:42:20 <Rotaerk> if the rectangle interface allows you to adjust the width/length, then that's not something the square can support
21:42:35 <Cale> But then all the other typed OO languages cargo-culted that decision of having the method implementations correspond directly to the type of the object.
21:42:52 <EvanR> Rotaerk: a square which has its dimension adjusted becomes an ellipse ;)
21:42:58 <EvanR> i mean, rect
21:43:24 <Rotaerk> yes, but its inherent type is square :P and it becomes an invalid one
21:43:39 <EvanR> eh...
21:43:50 <Rotaerk> in this example that is; not necessarily in all ways of representing squares and rectangles
21:44:28 * EvanR ignores anything anyone says, and says that an object type is the interface, and an object can have many types
21:44:36 <EvanR> it has no inherent type
21:45:09 <Rotaerk> that's fine, then in this example, the square implements both a rectangle interface *and* a square interface
21:45:09 <EvanR> and an object type can have many implementations
21:45:14 <julianleviston> EvanR: Ooh that reminds me of that awesome Entity-Relationship-Tagging way of writing games
21:45:35 <julianleviston> EvanR: Entity-Components or somethign? I can’t rememeber. Unity uses it.
21:45:37 <Rotaerk> if you adjust the width and length of the square through the rectangle interface, and then someone else looks at it through the square interface, it is no longer valid
21:45:42 <EvanR> its not that awesome, but its a good fallback
21:45:48 <EvanR> julianleviston: EAV ?
21:45:50 <julianleviston> oh :(
21:46:06 <EvanR> where V has a dynamic type
21:46:09 <julianleviston> entity-component-system I think...
21:46:25 <EvanR> its pretty much the same thing
21:46:29 <julianleviston> ah ok
21:46:43 <julianleviston> you have blank objects and you can tag them and attach chunks of functionality to them as you need
21:46:46 <EvanR> Rotaerk: ignoring the concept of mutating objects ;)
21:47:43 <Rotaerk> yes, if your rectangle interface is immutable, a square can satisfy liskov substitution
21:47:47 <EvanR> Circle.setW :: Circle -> Ellipse
21:47:53 <EvanR> Ellipse.setW :: Ellipse -> Ellipse
21:48:05 <EvanR> cast :: Circle -> Ellipse
21:48:35 <EvanR> i forgot the adjustment values oh well
21:49:19 <Rotaerk> I'm interested in trying out an entity-component system where I define an abstract entity... which has no data, just identity; and then different subsystems have their own indexes mapping the entities to values (i.e. attributes attached to the entities)
21:49:56 <EvanR> im trying to avoid it much as possible, before it ends up being like a DOM
21:49:58 <Rotaerk> so if you want to know, say, the color of an entity, you ask the color subsystem (maybe something a little bigger than that) if it even has a color, and if so, what it is
21:50:10 <Rotaerk> instead of asking the entity itself what its color is
21:50:35 <EvanR> with EAV you ask the AV -> [E] index
21:50:50 <EvanR> ("color", "blue") -> results
21:50:54 <Rotaerk> hmm never heard of EAV
21:51:10 <Rotaerk> looking at the wiki page...
21:51:26 <EvanR> the trending EAV database is datomic
21:51:45 <Rotaerk> you said you're trying to avoid it
21:51:51 <Rotaerk> suggesting you don't approve of EAV?
21:52:01 <EvanR> no i was trying to avoid a DOM-like thing with many ways of searching
21:52:11 <EvanR> by id, by class, by attributes
21:52:18 <EvanR> xpath
21:52:35 <EvanR> on the topic of EAV it has all the issues of dynamic typing
21:52:54 <EvanR> mainly the V
21:53:30 <EvanR> which you can solve in haskell by having many instances of the EAV database, one for each type of V
21:53:31 <Rotaerk> hmm I don't see how that is, yet
21:54:39 <EvanR> a given class of entities is expected to have certain attributes, but nothing guarantees that all of them will have all of them
21:54:49 <EvanR> a bug could render the database invalid
21:55:18 <Rotaerk> I'm not sure if I even have the code anymore, but I started toying with this a while back (when I was putting off actually being productive)
21:55:32 <Rotaerk> not EAV in particular, just an "entity-component"-like idea
21:56:15 <Rotaerk> every entity can participate in a variety of subsystems, but it doesn't own the data pertinent to any of those systems
21:56:29 <Rotaerk> the systems own all data pertinent to themselves, it just indexes it by entity
21:56:41 <Rotaerk> they just index the data by entity *
21:57:12 <EvanR> id like to see how that turns out, on someone elses time ;)
21:57:22 <EvanR> i dont have a good feeling about it
21:57:49 <Rotaerk> for instance, an entity may have location on a map, but the entity doesn't contain a location property; instead the map subsystem keeps both an index from entityId -> location, as well as an efficient location -> Maybe entityId data structure
21:57:56 <EvanR> for a more structured version of this, you can do structural set theory
21:58:17 <EvanR> instead of one giant set of entities, you have separate sets and relations between pairs of sets
21:58:30 <EvanR> and indexes into particular sets
21:58:46 <Rotaerk> yea, it's possible I would want different groups of entities, but I didn't get that far
21:58:52 <Rotaerk> maybe "world entities" and "UI entities" or something
21:59:10 <Rotaerk> though I'm not sure I would want to break the world entities into smaller partitions
21:59:26 <EvanR> for a property on a subset of two different sets, thats a property about a sum
22:00:17 <EvanR> Rotaerk: if you break it even that far, might as well talk about specific entity types
22:00:44 <Rotaerk> EvanR, I'm not sure yet why you would need to type the entities
22:00:45 <EvanR> Person, Account, Vehicle, Animal
22:01:16 <EvanR> worksFor :: Relation Person Person
22:02:17 <Rotaerk> EvanR, hmm, under this approach to modeling, you could represent that by having a Person subsystem, which contain a list of entities that are people
22:02:35 <Rotaerk> EvanR, and then an employment system that maintains employment relationships between people (with a dependency on the person subsystem)
22:03:02 <EvanR> without more information, it seems like replacing functions in haskell with the function system
22:03:19 <EvanR> you access the function system to construct and apply functions
22:03:46 <Rotaerk> EvanR, I wouldn't represent all values as "entities" though :P
22:03:59 <Rotaerk> it's just that entities are, say, game world objects
22:04:24 <EvanR> i replace the person system with the person set, and the employee system with the employee-employer relation
22:04:32 <EvanR> and number of systems can access these
22:05:09 <Rotaerk> the reason for this idea was ... games are often about rapid prototyping; trying out new ideas and finding what's fun, what works
22:05:13 <EvanR> the relationship here ensures you dont screw up and assign a person to an animal or vice versa (under employment)
22:05:26 <Rotaerk> and I wanted to make adding and removing game concepts easy enough by isolating them to one place
22:05:44 <EvanR> yeah you should be able to add new sets and relations quickly
22:06:05 <Rotaerk> for instance, if I have a fog of war concept, I want to be able to remove one module, and any modules that depend upon it, in order to remove the fog of war entirely
22:06:13 <EvanR> but when i use javascript i find myself spending lots of time during prototyping finding out why my prototype cant even compiled
22:06:16 <Rotaerk> rather than having a bunch of places throughout the codebase to tweak to eliminate the concept
22:06:54 <EvanR> yeah that would be the dream
22:34:55 <lpaste> EvilMachine pasted “Waaait a minute…” at http://lpaste.net/163554
22:35:23 <EvilMachine> I may be too tired, but… Why in the world is this not working?
22:35:47 <EvilMachine> A is an instance of SomeClass. And f is defined as giving back a instance of SomeClass.
22:35:59 <EvilMachine> Yet it fails.
22:36:09 <EvilMachine> EvanR: ↑
22:36:20 <srhb> EvilMachine: It doesn't produce a SomeClass a => a, it produces an A
22:36:49 <HoloIRCUser4> Hello 
22:36:52 <srhb> EvilMachine: Or rather, f :: A
22:37:27 <srhb> EvilMachine: Though I'm a little confused whether you meant to include the data definition in the class etc., in which case, indentation matters
22:37:36 <EvilMachine> srhb: But A is an instance of SomeClass!
22:38:19 <EvilMachine> srhb: No, no intention. I just forgot to take out the where
22:38:28 <srhb> EvilMachine: It doesn't matter, you're producing an A, not a SomeClass a => a. Imagine that you had another instance of that class, for say B. Would f then return a B? No, the right-hand side is clearly an A still.
22:39:35 <EvilMachine> srhb: What do you mean with ”Imagine that you had another instance of that class”? Like when someone calls (f :: B), requesting a B?
22:39:40 <EvilMachine> Ah, so it has to handle ALL types
22:39:47 <EvilMachine> Obviously
22:39:49 <srhb> EvilMachine: Yes.
22:39:52 <srhb> EvilMachine: :)
22:40:01 <EvilMachine> Yeah. Duh. I’m too tired. ^^
22:40:04 <EvilMachine> srhb: Thanks.
22:40:49 <srhb> EvilMachine: With not a single method in the class, I think the only possible solution for an f with that signature is in fact undefined (or an equivalent)
22:41:39 <srhb> EvilMachine: Though I haven't had enough coffee to justify that. :-)
22:42:01 <EvilMachine> srhb: So what if I want to define f = error "Nope", UNLESS someone calls (f :: A). Then I want f = A "Yup".
22:42:35 <srhb> EvilMachine: Just make it a class method.
22:42:39 <EvilMachine> srhb: In reality, there are of course useful methods in the class. :)
22:43:01 <EvilMachine> srhb: Lol. in reality, it is. I just did this to see how simple I could make it and still have it fail.
22:43:10 <EvilMachine> srhb: I’ll do it.
22:44:25 <srhb> EvilMachine: Class SomeClass c where f :: c; f = error "argh"; instance SomeClass A where f = A "foo" -- should do
22:44:31 <srhb> EvilMachine: Anyway, I need to go to work, have fun. :)
22:44:51 <srhb> (You still need to have instances, of course. *dashes*
22:46:01 <EvilMachine> srhb: That’s what I just did. :) Thanks! :)
22:49:19 <shanemikel> is there a simple zipper tree on hackage or in base?
22:49:45 <shanemikel> that isn't involved with lens
22:50:14 <shanemikel> Binary Tree, that is
23:19:06 * hackagebot type-list 0.3.0.3 - Operations on type-level lists and tuples.  https://hackage.haskell.org/package/type-list-0.3.0.3 (mjmrotek)
23:32:19 <aleator> A quick question. I have GADT of style `Exp (t::IRType)` which has constructor `Let ::  String -> Exp b -> Exp a -> Exp a`. When I pattern match on `Let`, how do I get a witness for IRType of the two subexpressions? Any other way than making a separate function with a type-sig?
23:37:46 <Cale> aleator: Well, Let discards the b type of the first Exp b argument
23:38:11 <Cale> aleator: But you might hope to reconstruct that through further pattern matching
23:38:55 <Cale> Basically, as you pattern match Exp constructors, the types ought to specialise for you, inside the branches of the case expression.
23:42:47 <aleator> Cale, yeah, the problem is that I need a Proxy of the contained type, which I can't bring to scope with a case (can I?)
23:45:22 <lvo> {-# LANGUAGE ScopedTypeVariables #-} ?
23:45:29 <Cale> Well, you can do something like  (Let s (e :: Exp b) (e' :: Exp a)) -> ... (Proxy :: Proxy b) ...
23:50:49 <aleator> Cale: Oh Right. I forgot I could add local type signatures to cases. Thank you!
23:59:07 * hackagebot automotive-cse 0.1.4.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.4.0 (KeiHibino)
