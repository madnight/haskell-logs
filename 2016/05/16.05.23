00:01:15 <humanoyd> When writing a library, does it make sense to include `lens` as a dependency when all I do is basically `over _Left`? If not, what would be a lightweight alternative?
00:04:20 <koz_> humanoyd: Check out microlens.
00:04:32 <koz_> That doesn't depend on (almost) anything, and gives you 'over _Left' just fine.
00:04:58 <Jinxit> what does microlens not include?
00:06:20 <kadoban> I'm not super familiar with lens, but couldn't that be replaced with a usage of first from Bifunctor, which is in base already?
00:06:59 <koz_> Jinxit: Anything depending on profunctor, which mostly removes Iso and Prism and friends.
00:07:10 <humanoyd> koz_: Thanks, it seems that's what I'm looking for
00:07:17 <koz_> Microlens also separates out the TH parts, the monad transformer parts and the instances for Map and friends from the rest.
00:07:29 <koz_> (although you can use microlens-platform to get them all if that's your dealio)
00:07:37 * hackagebot publicsuffix 0.20160522 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160522 (wereHamster)
00:07:37 * hackagebot roundRobin 0.1.0.0 - A simple round-robin data type  https://hackage.haskell.org/package/roundRobin-0.1.0.0 (winterland)
00:08:07 <koz_> kadoban: I guess you could? I'd say it's a matter of taste which of these you use. 
00:09:08 <kadoban> Just seems like if that's the only thing from lens you're using, it's an easy replacement.
00:09:22 <koz_> kadoban: True - if it's *really* the only thing.
00:11:28 <humanoyd> kadoban: koz_ Yes, the example I gave was oversimplified :)
00:15:19 <koz_> humanoyd: I'd say that if you're not doing funky lens magic, microlens should be enough. If you need *some* funky lens magic, but not too much, microlens-platform should have you covered.
00:17:12 <koz_> However, please take that with a small salt mine, since I'm a Haskell noob.
00:17:18 <koz_> (and a lens noob as well)
00:28:17 <lpaste_> koz_ pasted “Unsure how to write this (if possible)” at http://lpaste.net/164260
00:28:39 <koz_> ^ Any and all help very appreciated. :)
00:28:46 <koz_> (I'm trying to flex my lens muscles a bit)
00:29:31 <Cale> koz_: Start by just writing the function that you want.
00:30:04 <Cale> There is a function iso which can be used to build an Iso from a pair of inverse functions.
00:31:07 <lpaste_> koz_ revised “Unsure how to write this (if possible)”: “Unsure how to write this (if possible)” at http://lpaste.net/164260
00:31:18 <koz_> Cale: ^
00:32:00 <koz_> So to make that an Iso, would it just be 'iso negate negate'?
00:32:08 <Cale> yes
00:32:14 <koz_> Cale: Wow, that easy huh.
00:32:20 <koz_> I guess I was overthinking it. Thanks!
00:33:31 <koz_> And the type of the result is 'Iso' Atom Atom', right?
00:34:04 <Cale> yeah
00:34:17 <koz_> Cale: OK, that makes sense. Thank you - you're very knowledgeable.
00:34:25 <koz_> How long have you been Haskelling anyway?
00:36:10 <Cale> about 15 years
00:36:44 <koz_> Cale: I have a while to go then...
00:39:33 * koz_ is really happy that he can write stuff like 'to $ (:) <$> _f <*> _r' and actually understand what it does.
00:39:51 <Cale> heh
00:40:26 <koz_> Cale: This would have been a mystery to me even a week ago.
00:40:39 <Cale> I don't really use the lens stuff very much unless it's really the best way to do things. There are a lot of cases where it applies but isn't really any better than something which is more straightforward.
00:40:53 <koz_> Cale: I'm doing this mostly for my own enlightenment.
00:41:06 <koz_> I kinda wanna get an intuitive grip on all the stuff lens does in case I ever *do* need it.
00:41:20 <Cale> yeah
00:41:25 <koz_> I find I get that best through practice, even if it's a bit overkill for the situation at hand.
00:41:58 <koz_> And this seems like a good enough opportunity (this is for my PhD implementation work, where I understand the problem reasonably well).
00:57:51 <koz_> Does GHCi not understand 'import Foo hiding (cheese)'?
00:59:03 <koz_> Never mind - I'm just retarded.
01:22:23 <Off2k18> http://espedito.homepc.it/ OnePostX....
01:26:22 <dredozubov> https://gist.github.com/dredozubov/7c6ec34ba4a0716abe5e93e58ef7356b i'm building my project with stack and get this. Isn't stackage supposed to fix this kind of problems?
01:26:32 <dredozubov> extremely frustrated right now
01:29:42 <Cale> dredozubov: I don't think it can help cases where somehow files go missing... I'm not sure how that happened.
01:33:54 <Athas> Does anyone know why GHC uses this graph approach in its AST: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/TyingTheKnot ?
01:34:13 <Athas> It looks very complicated to work with.
01:41:14 <mgsloan> dredozubov: You can force it to rebuild that package by doing "stack exec -- ghc-pkg unregister byteable"
01:47:36 * hackagebot monad-peel 0.2.1.1 - Lift control operations like exception catching through monad transformers  https://hackage.haskell.org/package/monad-peel-0.2.1.1 (SergeyAlirzaev)
01:47:38 * hackagebot type-list 0.3.0.4 - Operations on type-level lists and tuples.  https://hackage.haskell.org/package/type-list-0.3.0.4 (mjmrotek)
01:52:52 <Xandaros> I feel like there should be a better way do define my ‘identifier’ parser: http://hastebin.com/fatehajohe.hs ... Any ideas?
01:57:36 * hackagebot vinyl-utils 0.2.0.4 - Utilities for vinyl  https://hackage.haskell.org/package/vinyl-utils-0.2.0.4 (mjmrotek)
02:01:50 <puregreen> Xandaros: I don't think there's a better way
02:02:36 * hackagebot apiary-http-client 0.1.2.0 - A http client for Apiary.  https://hackage.haskell.org/package/apiary-http-client-0.1.2.0 (winterland)
02:04:43 <Xandaros> puregreen: Hmm, that's too bad. The whole ‘firstChar’, ‘otherChars’ thing feels kinda dirty to me
02:06:08 <puregreen> you can use “liftA2 (:)” to get rid of explicit names
02:07:27 <Xandaros> Ah, yes. That's a good point. While I'd like to get rid of explicit names, I don't think that's terribly readable, though, so I'm just going to leave it as it is. It's not horrendous, just slightly unsightly :D
02:10:20 <koz_> You can also use (:) <$> instead of liftA2.
02:10:51 <puregreen> hm, is it going to interact well with <$> that goes after T.pack?
02:11:00 <puregreen> I forgot what the fixity of <$> is
02:11:18 <koz_> puregreen: I have no clue.
02:11:29 <koz_> You can always bracket to fix.
02:11:29 <lyxia> infixl 4
02:12:06 <puregreen> okay, apparently brackets or something like “fmap T.pack $” would be needed
02:13:56 <koz_> puregreen: <$> *is* fmap.
02:15:00 <Xandaros> Which is why he used fmap. The point was to change associativity :P
02:16:00 <puregreen> http://lpaste.net/164266
02:16:21 <puregreen> with a bonus cheating option
02:17:17 <koz_> puregreen: Are you allergic to where or something?
02:17:43 <puregreen> hm, why'd I be allergic to where / what do you mean?
02:18:38 <puregreen> (you can only accuse me of being allergic to wrapping blocks of code into parentheses, and yeah, I'm allergic to that)
02:18:51 <koz_> puregreen: You write the stuff you wanna pack into a where statement using <$> and <*> and then 'Text.pack <$>' that.
02:19:15 <koz_> I am also allergic to parenthesising unnecessarily.
02:21:29 <Xandaros> Hmm, maybe I should just parse strings and pack them when I actually insert them into the data structure. That would at least fix that problem
02:22:49 <puregreen> koz_: in this case, a variant with “where” looks worse to me. Especially since I can't easily think of a good variable name.
02:23:15 <koz_> puregreen: Point taken.
02:28:34 <martinvlk> Hi, is there a way when building a project with stack/cabal to have some files copied from A to B as part of the process?
02:29:16 <martinvlk> or perhaps have a script run that could do the copying
02:30:12 <martinvlk> or do I have to wrap the call to stack/cabal into a script to do that? 
02:35:07 <lyxia> martinvlk: is the data-files field not flexible enough?
02:36:14 <martinvlk> for my purposes, it'
02:36:18 <martinvlk> it's not
02:37:30 <martinvlk> I need to be able to copy files at build time 
02:38:13 <martinvlk> I can do that in a separate script, but I wondered if there is possibly support for specifying such operations in .cabal/stack.yml
02:38:27 <martinvlk> doesn't look like there is
02:38:46 <lyxia> I have no idea, sorry.
02:47:03 <idev> what's agood name for State + history that generates the state, i.e. a (State, [Cmd])
02:47:35 <usr> Stistory 
02:48:42 <idev> usr: brilliant, guarnteed to not conflict with english words
02:48:42 <Ferdirand> Fold ?
02:49:33 <usr> lol glad I could elp 
02:49:34 <MichaelBurge> idev: That's a zipper of some kind, isn't it?
02:49:53 <idev> it is actually a fold
02:50:09 <idev> where in (State, [Cmd]), we do have state = fold emptyState cmds
02:56:38 <Myrl-saki> Going to Idris, I'm now starting to appreciate the monad laws..
03:00:25 <pikajude> is there any haskell library that can do semver comparison like node's semver library?
03:02:39 * hackagebot vinyl-utils 0.3.0.0 - Utilities for vinyl  https://hackage.haskell.org/package/vinyl-utils-0.3.0.0 (mjmrotek)
03:07:39 * hackagebot focus 0.1.5 - A general abstraction for manipulating elements of container data structures  https://hackage.haskell.org/package/focus-0.1.5 (NikitaVolkov)
03:07:54 <pikajude> semver-range?? nice
03:08:30 <pikajude> ugh but it uses classy-prelude
03:08:39 <pikajude> so a tiny version parsing library ends up having 40 dependencies
03:17:18 <Ashley-ny> Download here the porno videgame for windows https://drive.google.com/file/d/0BwtJCiKQEiQbdW1XTXR0Wm9rWUU/view
03:23:50 <pikajude> no thanks
03:47:40 * hackagebot xmonad-wallpaper 0.0.1.3 - xmonad wallpaper extension  https://hackage.haskell.org/package/xmonad-wallpaper-0.0.1.3 (yeyan)
03:52:41 * hackagebot vado 0.0.7 - Runs commands on remote machines using ssh  https://hackage.haskell.org/package/vado-0.0.7 (HamishMackenzie)
03:57:41 * hackagebot gll 0.3.0.9 - GLL parser with simple combinator interface  https://hackage.haskell.org/package/gll-0.3.0.9 (ltvanbinsbergen)
04:03:25 <HaskellNode> hallo
04:03:49 <liste> hi HaskellNode 
04:04:49 <HaskellNode> c# thread pool exposes lots of microwaves for me so i came here ~_~
04:15:38 <HaskellNode> i requests haskell thread pool details 
04:20:51 <mikeplus32> is there some trick to getting ghc-mod working with stack? it just keeps trying cabal despite there being a stack.yaml
04:20:54 <mikeplus32> (using ghc-mod 5.5)
04:21:13 <mikeplus32> i thought it was built-in as of quite a while but maybe not
04:26:08 <sgt_sniff> mikeplus32: try running stack exec emacs (swap emacs for whatever editor you're using)
04:27:27 <Axman6> HaskellNode: what do you need to know?
04:35:09 <mikeplus32> sgt_sniff: ah, that's clever... but no dice. i'll give hdevtools a go
04:38:57 <cocreature> mikeplus32: do you have a dist directory? if you do remove it
04:41:54 <Xandaros> There doesn't happen to be a standard function to read binary and hexadecimal doubles, is there? … (e.g. 1011.011)
04:42:01 <sgt_sniff> mikeplus32: also, did you install ghc-mod globally?
04:42:48 <mikeplus32> sgt_sniff: nah it's in the stack dir
04:42:57 <mikeplus32> cocreature: very good guess, it seems like that's worked
04:43:37 <mikeplus32> it looks like ghc-mod is somehow using cabal though, it's going through a long build process for packages already in .stack-work... but it's working so that's nice
05:05:53 <dredozubov> > You can force it to rebuild that package by doing "stack exec -- ghc-pkg unregister byteable"
05:05:54 <lambdabot>  Not in scope: data constructor ‘You’    Not in scope: ‘can’
05:05:55 <lambdabot>      Perhaps you meant one of these:
05:05:55 <lambdabot>        ‘tan’ (imported from Prelude),
05:06:15 <dredozubov> mgsloan: nope, still broken
05:06:40 <dredozubov> lambdabot: i srsly hate your quote handling, dude
05:07:43 <volhovm> Hi! If i have `A = A { _a :: B }` and `B = B { _c :: Bool }`, how can I modify the value inside B while having `MonadState A m a` type? I'd like to do something like `(a ^. c) %= foo`, but it doesn't work.
05:08:14 <scshunt> volhovm: you want (a . c)
05:08:22 <volhovm> Ah, that easy :)
05:08:27 <scshunt> volhovm: you need to compose the lenses
05:08:32 <volhovm> Will try, thanks. 
05:12:23 <volhovm> scshunt: thanks it works. Another silly question: what is the monadic variant of %=? I want the argument to be `a -> m ()`
05:12:42 <scshunt> huh?
05:12:47 <scshunt> %= is monadi
05:12:50 <scshunt> *monadic
05:12:52 <scshunt> what do you mean?
05:13:37 <liste> :t (_1 %=)
05:13:39 <lambdabot> (Field1 s s a b, MonadState s m) => (a -> b) -> m ()
05:14:05 <volhovm> scshunt: let me check, i thought it accepts `a -> a` type only...
05:14:08 <liste> :t (_1 .=)
05:14:09 <lambdabot> (Field1 s s a b, MonadState s m) => b -> m ()
05:14:23 <volhovm> :t (%=)
05:14:23 <Jinxit> %= is update with a function, .= is set
05:14:24 <lambdabot> (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
05:14:45 <volhovm> it returns m (), while second argument should be p a b, that's not a monad.
05:14:47 <volhovm> i suppose...
05:15:21 <Jinxit> (a . c) .= 5 should work iirc
05:15:44 <volhovm> The basic situation is: i have element `a` and function `a -> m ()`. Extended situation is me having `MonadState something m`, from where i can get a. And i still have `a -> m ()`.
05:16:18 <volhovm> So i want to retrieve element from monadstate context and then apply `a -> m ()` on it. I can do it with view, but that's too verbose.
05:16:30 <scshunt> volhovm: ah
05:16:54 <volhovm> `do {e <- view a; foo e}` like that
05:16:57 <Jinxit> zoom?
05:17:31 <Jinxit> something like zoom (a . c) func
05:17:33 <scshunt> it appears that (%=) no longer accepts profunctors
05:17:39 <Jinxit> I forget exactly how it works
05:18:56 <scshunt> volhovm: it appears that support for having %= do that was removed in august
05:19:04 <scshunt> you could file an issue against lens
05:19:16 <scshunt> it was this commit: https://github.com/ekmett/lens/commit/04f90fc4a0ae6c621cb095221dcea958b096acff
05:20:48 <HaskellNoob> Some help with this? http://lpaste.net/164285
05:21:00 <volhovm> scshunt: got it, but maybe there's just another way to do it.
05:21:23 <scshunt> volhovm: well, you could just copy (%=) and restore the profunctor constraint :P
05:22:00 <scshunt> then it would be l %= (Kleisli f)
05:22:50 <volhovm> Ah, ok, i understand. But it's a strange approach.
05:22:52 <scshunt> actually I'm going to file that issue
05:22:57 <volhovm> Okay, cool.
05:26:45 <scshunt> volhovm: actually wait
05:26:49 <scshunt> why is it a -> m ()
05:27:00 <scshunt> how is that supposed to produce a new b to update the state with?
05:28:22 <ggVGc> man, I love lambdacase
05:29:04 <scshunt> volhovm: do you not have a -> m b
05:29:05 <scshunt> ?
05:29:33 <volhovm> I'd like to perform action on `m`, cause `m` is `IO` in my case :)
05:29:37 <HaskellNode> no pain no gain
05:29:47 <volhovm> Like, i'm getting some GUI element and updating it -- exact case.
05:30:12 <volhovm> So there's a function `updateElem :: a -> IO ()`
05:30:33 <volhovm> scshunt ^
05:30:59 <scshunt> volhovm: But IO is not a MonadState
05:31:14 <volhovm> `StateT MyGUI IO a`
05:31:21 <volhovm> I'd use `liftIO $ updateElem`
05:31:35 <scshunt> still raises the question
05:31:48 <scshunt> look at %= again
05:31:50 <scshunt> :t (%=)
05:31:52 <lambdabot> (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
05:31:59 <volhovm> It's old type, isn't it?
05:32:09 <scshunt> err, right, this is the hard-to-read polymorphic type
05:32:24 <scshunt> (MonadState s m) => Setter s s a b -> (a -> b) -> m ()
05:32:41 <scshunt> your update function yields ()
05:32:54 <scshunt> so you'd end up with something like Setter s s a () -> (a -> m ()) -> m ()
05:33:03 <scshunt> basically saying "replace the a with ()" which is not what you want
05:33:07 <scshunt> (and not lawful)
05:33:17 <volhovm> Yes, ok, it doesn't make sense. What does?
05:33:18 <scshunt> perhaps you want zoom instead?
05:33:31 <volhovm> I've never heard of it.
05:34:25 <scshunt> or use
05:34:26 <scshunt> :t use
05:34:28 <lambdabot> MonadState s m => Getting a s a -> m a
05:34:36 <scshunt> use l >>= liftIO update
05:34:52 <volhovm> I used `use` already, yes.
05:34:58 <qaz> hi
05:35:35 <qaz> how do i put a comment line in haskell?
05:35:36 <Jinxit> use and zoom both work on State though
05:35:40 <Jinxit> qaz: --
05:36:01 <qaz> Thanks
05:36:17 <volhovm> cshunt: zoom -- you mean ^. ?
05:36:23 <volhovm> scshunt* ^
05:36:33 <chipf0rk> Hi everyone :) Can someone tell me what makes difference lists faster? I don't mean just in terms of construction, that's rather obvious, but when actually using the list in the end. I mean, isn't it just a deferred computation, basically?
05:36:37 <Jinxit> zoom is something else
05:36:46 <Jinxit> but his use l >>= liftIO update should work, no?
05:36:47 <chipf0rk> are we getting the performance gains because we're not walking a list multiple times?
05:36:54 <chipf0rk> for appending
05:37:07 <scshunt> volhovm: no
05:37:34 <Jinxit> volhovm: https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Zoom.html#v:zoom
05:37:42 <volhovm> Jinxit: it works, i just thought it can be done easier. Thanks.
05:38:15 <Jinxit> I think the lift solution is pretty neat actually
05:38:19 <Jinxit> separates the IO from the getting
05:38:59 <labbe> > pl \f g x y -> f (g x y)
05:39:01 <lambdabot>  <hint>:1:4: parse error on input ‘\’
05:39:11 <scshunt> labbe: it's @pl
05:39:20 <scshunt> @pl \f g x y -> f (g x y)
05:39:21 <lambdabot> (.) . (.)
05:39:28 <labbe> Ooh thanks
05:43:20 <labbe> @pl \f g x y z -> f (g x y z)
05:43:21 <lambdabot> (.) . (.) . (.)
05:43:34 <labbe> @pl \f g x y z a -> f (g x y z a)
05:43:34 <lambdabot> (.) . (.) . (.) . (.)
05:44:21 <maerwald> I wish @pl would be removed from lambdabot 
05:45:09 <labbe> sorry, can I whisper @pl?
05:45:23 <maerwald> you can whisper lambdabot yes
05:45:34 <maerwald> pl is also available as a standalone program
05:45:45 <maerwald> @hackage pointfree
05:45:45 <lambdabot> http://hackage.haskell.org/package/pointfree
05:45:51 <liste> maerwald: for spreading worst practices?
05:46:14 <maerwald> liste: hm?
05:46:31 <liste> maerwald: do you want it removed because it usually produces unreadable code?
05:46:36 <maerwald> that too
05:47:04 <maerwald> if you can't come up with a pointfree version yourself, you shouldn't use any for the function in question
05:47:08 <maerwald> pretty simple imo
05:47:34 <maerwald> chances are the next guy looking at it will have to use "pointful" to un-obfuscate it
05:48:22 <ij> Would I be right to say that the only function fit for "a -> a" is `id'?
05:48:34 <labbe> yes
05:54:02 <quchen> ij: The only useful function, yes.
05:54:17 <hpc> ij: in haskell there are two more inhabitants of the type (a -> a), but they're not tremendously useful
05:54:28 <hpc> they are \_ -> undefined and undefined
05:54:44 <hpc> which can be differentiated in the presence of seq, but neither have any useful properties
05:55:37 <ij> Myeah... but I had a gut feeling that it would be sensical that I could check whether the type's Int — if so, then \x -> x + 1, else id.
05:56:21 <ij> I'm pretty sure you can't write this in haskell, is that also true in type theory?
05:56:25 <quchen> There is no "type-level case" in Haskell.
05:56:39 <hpc> yeah, you can't do that
05:56:48 <hpc> the absence of that ability is what makes parametricity work
05:56:49 <quchen> That would break parametricity, and as a result you'd lose most of the guarantees the type system provides you with.
05:56:56 <tmobile> chipf0rk: What you said is essentially correct. The advantage is appending in constant time.
05:56:58 <hpc> and parametricity gives you free theorems
05:57:49 <chipf0rk> tmobile: alright, but since haskell is heavily lazy, couldn't this be optimised like this for normal lists and (++)?
05:57:55 <hpc> there's only one case in regular haskell of anything remotely resembling type-case and that's the showList trick
05:57:58 <hpc> which is excruciating
05:58:02 <hpc> @src Show
05:58:03 <lambdabot> class Show a where
05:58:03 <lambdabot>     showsPrec :: Int -> a -> ShowS
05:58:03 <lambdabot>     show      :: a -> String
05:58:03 <lambdabot>     showList  :: [a] -> ShowS
05:58:50 <hpc> if you feel up to it, you can try and work out what that does on your own
05:59:05 <tmobile> chipf0rk: Look at the defintion of (++)
05:59:30 <hpc> ij: a hint, look at the instances for [a], Char, and ()
05:59:46 <hpc> but that's getting away from the original question ;)
05:59:49 <e3fjk2as> hi
05:59:52 <e3fjk2as> :D all
06:00:44 <tmobile> The problem is that repeated applications of (++) will walk the list you're accumulating multiple times.
06:01:05 <e3fjk2as> tmobile: interesting username
06:01:14 <e4fg3a3> hi
06:01:14 <maerwald> tmobile: tht probably depends on optimization
06:01:40 <hpc> maybe some cases of unfavorable (++) can be optimized, but not all of them
06:01:49 <yowassupdude> hi
06:01:53 <hpc> not automatically
06:02:11 <yowassupdude> hpc: can haskell make money?
06:02:35 <maerwald> predicting how good or bad list operations are is pretty difficult in haskell since it depends heavily on laziness and optimization tricks of GHC 
06:02:54 <chipf0rk> maerwald: tmobile: hpc: that's what i mean. i'm not able to think about this very clearly, but it seems odd to me that something as simple as a newtype wrapper for what is a deferred computation on a list is more efficient than whatever optimisation tricks GHC can pull out of its hat
06:03:31 <tmobile> chipf0rk: (barring optimizations) If I do (([1,2,3] ++ [4,5,6]) ++ [7,8,9]), the first (++) walks the list [1,2,3], then the second (++) walks the list [1,2,3,4,5,6].
06:03:38 <yowassupdude> HELLO IS aNYONE ONLINE OR AM I MUTED????
06:03:50 <chipf0rk> tmobile: alright, that much is clear to me now, thanks :)
06:03:55 <yowassupdude> HELLO IS aNYONE ONLINE OR AM I MUTED????
06:03:56 <yowassupdude> HELLO IS aNYONE ONLINE OR AM I MUTED????
06:04:02 <hexagoxel> not yet
06:04:07 <maerwald> :D
06:04:07 <yowassupdude> ok
06:04:10 <yowassupdude> good
06:04:19 <groovy2shoes> yowassupdude, WHY THE HELL ARE YOU TYPING IN ALL CAPS
06:04:35 <yowassupdude> MY pC keyboard is broken
06:04:43 <yowassupdude> Let me fix that
06:04:47 <yowassupdude> better
06:04:49 <yowassupdude> ??
06:05:01 <labbe> yes
06:05:01 <groovy2shoes> yeah :D
06:05:47 <e4fg3a3> Fre sha va ca do
06:06:24 <groovy2shoes> do ma see ca rim
06:06:46 <yowassupdude> hahahahahahgahahhahahahahahhha!!!!!
06:06:54 <groovy2shoes> te lo ne sha va!
06:06:59 <e4fg3a3> fre ma va ca do
06:07:13 <e4fg3a3> fre na ki sha di
06:07:23 --- mode: ChanServ set +o byorgey
06:07:34 <chipf0rk> ...what
06:07:37 <tmobile> I've never witnessed GHC apply any optimization that makes something like "foldl (++) [] (map (:[]) [1..1000000])" OK to do.
06:07:40 <yowassupdude> 11 23 75 23 09 23 87 23 64 12 96 43
06:07:41 --- kick: e4fg3a3 was kicked by byorgey (e4fg3a3)
06:07:42 <groovy2shoes> I dunno?
06:07:46 --- kick: groovy2shoes was kicked by byorgey (groovy2shoes)
06:07:51 --- kick: yowassupdude was kicked by byorgey (yowassupdude)
06:08:07 --- mode: ChanServ set -o byorgey
06:08:17 <tmobile> byorgey: Hey, you're the Diagrams dude.
06:08:36 <byorgey> hey tmobile, that's me =)
06:08:43 <chipf0rk> tmobile: well, the question for me is, why not
06:08:48 <chipf0rk> not that i could write that, but...
06:08:56 <hpc> tmobile: a lot of people here are the something-on-hackage dudes ;)
06:09:05 <hpc> you too someday!
06:10:19 <oherrala> byorgey: I listened the Haskellcast you were in. Did you play Eve Online while appearing in podcast? :D
06:11:12 <byorgey> oherrala: sorry, if that's supposed to be a joke, I don't get it =)
06:11:18 <byorgey> (the answer is no)
06:11:28 <oherrala> byorgey: not a joke :)
06:11:52 <byorgey> why would I play Eve Online while appearing in a podcast?
06:12:05 <tmobile> byorgey: We use diagrams a lot at work. There are FDA filing documents with Diagrams diagrams in them.
06:12:15 <byorgey> woah, sweet!!
06:12:28 <oherrala> byorgey: I just picked up some background noises and those sound familiar :)
06:13:11 <byorgey> oherrala: sounds like they might be *too* familiar...  so familiar that you hear them in places where they aren't =)
06:13:44 <byorgey> tmobile: got any examples you're allowed to share with us?
06:14:43 <tmobile> I'm not exactly sure what happens to all the filing documents a drug company submits. I'd imagine they become public domain at some point.
06:18:30 <tmobile> Well, I can definitely say that we use it for generating process flow diagrams.
06:19:09 <byorgey> tmobile: cool
06:20:03 <selckin> git stauts
06:22:47 * hackagebot pipes-key-value-csv 0.1.0.0 - Streaming processing of CSV files preceded by key-value pairs.  https://hackage.haskell.org/package/pipes-key-value-csv-0.1.0.0 (mjmrotek)
06:22:48 <foobarz> hi guys
06:22:54 <foobarz> having some trouble with julius splicing
06:23:23 <foobarz> seems like most built in types can't be spliced? the only way I can get anything to compile is rawJS http://lpaste.net/164297
06:25:43 <tmobile> chipf0rk: It's because of the definition of (++). There's not really any magic in the list type, as far as the definition is concerned it's structurally as plain as a singly-linked list can be.
06:26:10 <tmobile> And (in general) the only way to append two such lists is to walk to the end of the leading list.
06:26:46 <tmobile> Contrast this with difference lists, where the append operation is just function composition.
06:27:01 <fr33domlover> foobarz, I never used Julius but you can go to the shakespeare library's docs and see which types have a convert-to-JS instance etc.
06:27:53 <tmobile> When you append one difference list to another, informally you're saying "make this edit, then this edit"
06:28:11 <tmobile> You can put two such list edits together "for free."
06:28:49 <tmobile> But you have to perform them to inspect them later.
06:28:54 <ski> hpc : that `showList' thing is a bit similar to a trick ("pattern") sometimes used in OO ..
06:30:35 <qaz> hello, what is Enum in haskell?
06:31:08 <scshunt> qaz: it's a typeclass which represents things that can be enumerated (that is, you can go over every value)
06:31:25 <foobarz> fr33domlover it's weird in the examples it seems like standard types just splice automagically
06:31:28 <ski> @src Enum
06:31:28 <lambdabot> class Enum a where
06:31:29 <lambdabot>     succ, pred               :: a -> a
06:31:30 <lambdabot>     toEnum                   :: Int -> a
06:31:32 <lambdabot>     fromEnum                 :: a -> Int
06:31:34 <lambdabot>     enumFrom                 :: a -> [a]
06:31:36 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
06:31:38 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
06:31:55 <foobarz> but then again there's a mix of hamlet and julius examples... maybe there's automatic splicing for hamlet but not julius? that would be pretty confusing
06:32:12 <ski>   [lo ..] = enumFrom lo
06:32:19 <ski>   [lo .. hi] = enumFromTo lo hi
06:32:19 <qaz> im confussed now 0.0
06:32:31 <ski>   [lo,next ..] = enumFromThen lo next
06:32:34 <mikeplus32> hm, is there a dupTMVar?
06:32:36 <ski>   [lo,next .. hi] = enumFromThen lo next hi
06:32:47 * hackagebot list-t 0.4.7 - ListT done right  https://hackage.haskell.org/package/list-t-0.4.7 (NikitaVolkov)
06:33:11 <bernalex> qaz: what are you trying to ask? Enum is a typeclass.
06:33:13 <fr33domlover> foobarz, sorry I have no idea. Try asking in #yesod too
06:33:31 <fr33domlover> I've used only Hamlet and Cassius
06:33:46 <bernalex> for a second I assumed you guys were talking about theatre.
06:33:54 * ski idly wonders whether there's a package with description "ListT done wrong"
06:34:19 <ski> (if not, perhaps someone should make one)
06:34:26 <foobarz> doh maybe i should fall back on jmacro
06:34:32 <hpc> i could always make a minor release of acme-php with that description
06:34:36 <ggVGc> I noticed I started using an idiom of returing functions that modify an object, rather than taking a value and returing a modified one
06:34:46 <qaz> cause it came up in a haskell book, not sure if its often use in the code or not
06:34:53 <ggVGc> is that common? or is it dumb in some way?
06:34:57 <hpc> and then immediately change it back, confusing everyone
06:35:04 <ggVGc> I like it since the return alue of everything becomes a delta function essentially
06:35:08 <ggVGc> which is more generally useful
06:35:16 <ski> ggVGc : what is the difference ?
06:35:25 <qaz> succ and pred is also from Enum, right?
06:35:34 <ski> qaz : yes, see above
06:35:50 <qaz> ok, thanks a lot!
06:35:56 <ggVGc> ski: ah, yeah.. there isn't one I just realised, hah
06:35:59 <ggVGc> I'm dumb
06:36:24 <ski> ggVGc : might be a difference if you let the initial function be non-trivial
06:37:26 <ggVGc> ski: I have one case where there's a difference currently I think. I have a function that returns a tuple of a "transformer function" and a flag indicating how the transformation should be applied
06:38:08 <ggVGc> the flag is essentialyl a selector, used later to pick values from a collection that should be modified by it
06:39:41 <ski> ggVGc : *nod*, that's another way in which it may differ
06:41:28 <qaz> what doesnt the function fromIntegral actally do? it seems to give out the exact same value
06:42:04 <hpc> :t fromIntegral
06:42:06 <lambdabot> (Integral a, Num b) => a -> b
06:42:24 <qaz> i check :t still dont understand
06:42:48 * hackagebot zoom-refs 0.0.0.1 - Zoom (~ Functor) and pairing (~ Applicative) for mutable references.  https://hackage.haskell.org/package/zoom-refs-0.0.0.1 (mjmrotek)
06:42:48 <hpc> it takes a value of some type that is Integral (ie, something that represents integers)
06:42:50 * hackagebot extended-reals 0.2.2.0 - Extension of real numbers with positive/negative infinities  https://hackage.haskell.org/package/extended-reals-0.2.2.0 (MasahiroSakai)
06:43:11 <hpc> and produces a value of some type that is Num (ie, something that represents numbers)
06:43:29 <hpc> > fromIntegral (15 :: Int) :: Double
06:43:31 <lambdabot>  15.0
06:43:40 <hpc> > (15 :: Int) / pi
06:43:42 <lambdabot>      No instance for (Fractional Int) arising from a use of ‘/’
06:43:42 <lambdabot>      In the expression: (15 :: Int) / pi    No instance for (Floating Int) ar...
06:43:42 <lambdabot>      In the second argument of ‘(/)’, namely ‘pi’
06:43:47 <hpc> > fromIntegral (15 :: Int) / pi
06:43:49 <lambdabot>  4.7746482927568605
06:44:01 <hpc> > 15 / pi
06:44:03 <lambdabot>  4.7746482927568605
06:44:32 <qaz> 15 :: Double
06:44:33 <geekosaur> this won't be obvious with numeric literals because they have fromInteger wrapped around them implicitly
06:45:01 <geekosaur> (or fromRational if they have a decimal point)
06:45:07 <qaz> could you maybe make a example using it?
06:45:25 <hpc> i just showed a few examples
06:45:53 <qaz> yes but 15/ pi works just fine, why use fromIntegral
06:46:09 <hpc> :t let x = 15; y = 15 / pi in 15
06:46:11 <lambdabot> Num a => a
06:46:12 <hpc> :t let x = 15; y = 15 / pi in x
06:46:13 <lambdabot> Num a => a
06:46:20 <hpc> o.O
06:46:33 <hpc> 15 is polymorphic
06:46:34 <sdx23> qaz: try to implement a function that calculates the average of a list. You will see that you need it there.
06:46:49 <hpc> when you just do (15 / pi), it's cherry-picking a type for 15 that will be suitable
06:46:52 <geekosaur> qaz, numeric *literals* are polymorphic
06:46:54 <hpc> but you don't always have the right type
06:47:00 <geekosaur> :t length
06:47:02 <lambdabot> Foldable t => t a -> Int
06:47:07 <hpc> > (length "bananas") / 2.6
06:47:09 <lambdabot>      No instance for (Fractional Int) arising from a use of ‘/’
06:47:09 <lambdabot>      In the expression: (length "bananas") / 2.6
06:47:24 <hpc> so you need to convert it to something suitable
06:47:28 <qaz> ok, i kinda get the idea
06:47:37 <hpc> in other languages this would be invisible
06:47:53 <qaz> so if something is fixed to be Int it would free it to be more flexible?
06:48:15 <hpc> and you'd either be wondering why 5/2 = 2 and not 2.5, or you would simply end up with a floating point value instead of an integery value
06:48:17 <qaz> (15 :: Int) / pi
06:48:42 <geekosaur> (and tbh the implicit polymorphism of numeric literals often causes more confusion than it's worth
06:48:56 <qaz> but if i type 5/2 in the ghci i get 2.5
06:48:59 <hpc> (int/int) -> float, which can cause major problems if you are using an api that cares
06:49:20 <qaz> api?
06:49:22 <hpc> qaz: both 5 and 2 are polymorphic, and get given a type suitable for (/)
06:49:28 <qaz> oh
06:50:06 <qaz> (5 :: Int) / (2 :: Int)
06:50:19 <hpc> > (5 :: Int) / (2 :: Int)
06:50:21 <lambdabot>      No instance for (Fractional Int) arising from a use of ‘/’
06:50:21 <lambdabot>      In the expression: (5 :: Int) / (2 :: Int)
06:50:46 <hpc> > (5 :: Int) `div` (2 :: Int) -- using integer-y division
06:50:48 <lambdabot>  2
06:51:01 <hpc> > (fromIntegral (5 :: Int)) / (fromIntegral (2 :: Int))
06:51:03 <lambdabot>  2.5
06:51:15 <qaz> WAT
06:51:24 <qaz> `div` and / is different?
06:51:34 <hpc> :t div
06:51:36 <lambdabot> Integral a => a -> a -> a
06:51:37 <hpc> :t (/)
06:51:38 <lambdabot> Fractional a => a -> a -> a
06:51:43 <hpc> yep
06:51:50 <qaz> good to know lol
06:52:15 <qaz> Thanks a lot man
06:54:08 <ozgura> can I ask someone on a mac (and with ghc-8.0.1) to test something please? split-objs seems to fail for me
06:54:20 <ozgura> just run the following in an empty directory: cabal sandbox init ; cabal install --enable-split-objs Diff-0.3.4
06:54:39 <ozgura> it works without the split-objs flag
07:03:17 <Hakey> hi
07:06:37 <tmobile> This is probably wishful thinking.
07:07:00 <tmobile> But is anyone aware of a Haddock-style literate programming framework that's OK with C-like languages?
07:07:27 <tmobile> i.e. virtually no configuration necessary, all documentation is read from source annotations.
07:09:27 <tmobile> I'm aware of Doxygen, but it requires a lot of extra information.
07:10:33 <fr33domlover> tmobile, if you copy the relevant config and Makefile snippet from an existing project, it won't require much
07:10:57 <fr33domlover> tmobile, also you have gtk-doc
07:11:47 <tmobile> Ah, I didn't realize gtk-doc was a stand-alone thing.
07:17:49 * hackagebot ip 0.5 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.5 (andrewthad)
07:30:52 <maerwald> great, can't install bytestring>=0.10.8.0, because GHC locks it
07:32:50 <bergmark> maerwald: why not? i can
07:33:14 <maerwald> bergmark: http://lpaste.net/164311
07:34:27 <bergmark> oh because you depend on the ghc package, no way around that
07:35:05 <phadej> downside of using e.g. doctest
07:39:36 <maerwald> broken haskell dependency crap
07:42:50 * hackagebot yesod-ip 0.2 - Code for using the ip package with yesod  https://hackage.haskell.org/package/yesod-ip-0.2 (andrewthad)
07:49:20 <ironChicken> to use the detailed-0.9 TestSuite interface, do i need Cabal >= 1.9.2? and is that the appropriate constraint to put in my foo.cabal file for the "cabal-version:" option?
07:50:13 <bergmark> ironChicken: `cabal check' will tell you if our lower bound is too low
07:53:05 <bbear> hello
07:53:09 <bbear> what's wrong with this ?
07:53:10 <bbear> http://lpaste.net/164314
07:53:29 <ironChicken> bergmark: thanks. it doesn't seem unhappy with it
07:55:34 <bbear> I mean, the lpaste doesn't report any error but there is one at compile time
07:56:16 <geekosaur> lpaste is not a compiler, it has a heuristic style checker built into it
07:56:19 <bbear> here you go : http://lpaste.net/164315
07:56:22 <geekosaur> and you should include the full error message
07:57:03 <bbear> http://lpaste.net/164315
07:57:25 <geekosaur> (tail l) is a list of Int, (head l) is an Int
07:57:31 <geekosaur> :t (:)
07:57:33 <lambdabot> a -> [a] -> [a]
07:57:46 <bbear> :T (:)
07:57:50 <bbear> :t (:)
07:57:51 <lambdabot> a -> [a] -> [a]
07:57:58 <bbear> yes
07:58:09 <bbear> I thought that : was commutative operator
07:58:14 <geekosaur> no, it is not
07:58:29 <bbear> Actually I'd like to put the head of the list at the end of the list.
07:58:30 <geekosaur> if it were, the type would be [a] -> [a] -> [a]
07:58:39 <bbear> geekosaur: indeed 
07:58:45 <bbear> geekosaur: I have been mistaken.
07:58:52 <bbear> (I learn everyday)
07:59:01 <bbear> Any idea on how to do this properly ?
07:59:33 <sdx23> @hoogle [a] -> [a] -> [a]
07:59:34 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
07:59:35 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
07:59:35 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:59:38 <bbear> One could always goes with reverse (x:reverse xs)
08:00:06 <bbear> that's not very clean although.
08:00:19 <bbear> @hoogle [a]->a->[a]
08:00:20 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
08:00:20 <lambdabot> Data.Text.Internal.Functions intersperse :: a -> [a] -> [a]
08:00:20 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
08:00:59 <bbear> although pattern matching makes a lot more sense to me now.
08:01:12 <bbear> you have my thanks.
08:01:12 <sdx23> bbear: nah, you want (++). And at some point think about your algorithm, because (++) is not a very good choice.
08:01:32 <bbear> sdx23: the algorithm is plain
08:01:49 <bbear> if the operator is not good that's not really the user which is faulty
08:02:07 <bbear> I mean ... It should be the symmetric operator to : (It should exist probably)
08:02:42 <bbear> I mean appending an elem at the end of a list is likely to have the same complexity than appending an elem at the beginning of the list.
08:02:49 <bbear> (at least « should »)
08:03:04 <bbear> well I don't mean trolling but anyway any suggestion is interesting.
08:03:43 <sdx23> bbear: the point is, you should avoid appending elements to lists. It is O(n), compared to O(1) for (:). Don't do it.
08:04:44 <sdx23> either implement the algorithm in a more appropriate way or use another data structure.
08:05:34 <bbear> so (reverse (x:reverse xs))
08:05:55 <bbear> anyway that's not the point
08:06:05 <sdx23> nah, this is O(n) too.
08:06:19 <bbear> ok
08:06:38 <bbear> I'll thought of it.
08:07:51 * hackagebot word-vector 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/word-vector-0.1.0.0 (andrewthad)
08:08:24 <bbear> how would you just repeat n times an operation over a list ?
08:09:39 <bbear> map f zip (repeat l) [1..n] ... nah
08:09:51 <bbear> I have to chain over the list
08:10:22 <bbear> Let's say f::[Int]->[Int]
08:14:07 <ggVGc> is ther a lens for sub-lists?
08:14:19 <ggVGc> i.e if I want to set all the values between index a and b
08:14:58 <bbear> how 
08:15:20 <bbear> let say f::a->a
08:15:42 <bbear> how would you apply f "n times" to produce f^n(a) ?
08:16:27 <sdx23> @hoogle (a->a) -> Int -> a -> a
08:16:28 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
08:16:28 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
08:16:28 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
08:17:45 <sdx23> (guess you'd rather `iterate`)
08:18:36 <ggVGc> yeah, drop, iterate, take i guess is what I need
08:18:47 <ggVGc> thanks
08:18:58 <ggVGc> wait, no
08:19:06 <ggVGc> just drop map take
08:21:32 <nitrix> Hi, I have to get the log_4 of very very large Integer; logBase is giving me Infinity.
08:21:40 <nitrix> Would anyone have a recommended library?
08:24:52 <ocramz> hi there
08:25:29 <ocramz> where may I find a `filterMap` for Vector? i.e. `(a -> Bool) -> (a -> b) -> V.Vector a -> V.Vector b`
08:25:41 <geekosaur> hm, I thought there was a more complete binding to gmp somewhere
08:25:45 <ocramz> I mean an efficient one
08:25:55 <geekosaur> which is about all that will help if you have a number that's overflowing the exponent of machine Double-s
08:26:18 <jle`> bbear: iterate and !! works too :)
08:26:29 <jle`> if you want the nth item
08:27:52 * hackagebot web-inv-route 0.1 - Composable, reversible, efficient web routing based on invertible invariants and bijections  https://hackage.haskell.org/package/web-inv-route-0.1 (DylanSimon)
08:30:17 <bbear> If I have a function that returns a tuple, how can I do to use the return values of the function inside another function ? I mean I would be obliged to do let (a,b)=accessory_function
08:30:31 <bbear> Is that correct or bad practice ? (ie imperative programming)
08:30:50 <geekosaur> that's not imperative, it's just pattern matching which is good practice
08:31:20 <merijn> Also, imperative programming isn't inherently bad
08:31:27 <merijn> I love me some imperative Haskell :D
08:31:35 <bbear> are you sure that this let (a,b)=blah then use a and b separately would do the trick ?
08:31:41 <geekosaur> yep
08:31:57 <bbear> I mean as soon as there is a succession of instruction with « assignment like », I consider that is imperative.
08:32:48 <bbear> can you show me an example ?
08:32:58 <geekosaur> but that's not assignment, it's binding. it creates new "a" and "b" unrelated to any others (provided they aren't also to the right of the "=", in which case you're going to find out the hard way how it is not assignment :)
08:33:16 <bbear> ha, maybe with a where statement
08:33:21 <bbear> it should do the trick
08:34:19 <geekosaur> where isn't a statement... and it turns into a let
08:34:38 <bbear> Im shacky on vocabulary
08:35:09 <bbear> If it turns into a let so be it, I wish I follow good programming guidelines and where seems to fit the bill right here. BTW what exactly a statement ?
08:35:37 <monochrom> you can also use case t of (a,b) -> ...
08:36:16 <monochrom> in fact it is preferred to "let" 90% of the time because stricter
08:36:48 <bbear> I'll show you my code, you'll show me the improved version.
08:36:57 <bbear> I'm not quite sure how to use let at this time.
08:37:51 <lambda-11235> nitrix: If you don't mind waiting for a year you could always use CReal. :)
08:38:41 <geekosaur> if the result is large enough to overflow a Double then you may also need a larger swap disk :p
08:39:19 <monochrom> use a Quadruple
08:47:53 * hackagebot Yampa 0.10.5 - Library for programming hybrid systems.  https://hackage.haskell.org/package/Yampa-0.10.5 (IvanPerez)
08:54:23 <jle`> ooh a Yampa update
08:56:10 <hahahahahahahaha> test
08:57:06 <hahahahahahahaha> ok
08:57:09 <flaretechno> flaretechno, welcome to channel #haskell. This robot was created by Tecflare Corporation. Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@Help, !@Build
08:57:12 <flaretechno> rembo10, welcome to channel #haskell. This robot was created by Tecflare Corporation. Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@Help, !@Build
08:57:36 <bbear> mmh
08:57:44 <flaretechno> Nilabhra, welcome to channel #haskell. This robot was created by Tecflare Corporation. Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@Help, !@Build
08:57:45 <hahahahahahahaha> It works
08:57:51 <hahahahahahahaha> I built out out of haskell
08:57:53 <bbear> so the Haskell so called « list » are only stacks I presume.
08:58:12 <hahahahahahahaha> !@Build
08:58:13 <flaretechno> You may view all builds at https://circleci.com/gh/WebParakeet/webp-installer/
08:58:17 <bbear> There's no queue what so ever ?
08:58:31 <hahahahahahahaha> It WORKS!!!!
08:58:46 <Nilabhra> seems it does :)
08:58:56 <flaretechno> L8D, welcome to channel #haskell. This robot was created by Tecflare Corporation. Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@Help, !@Build
08:58:56 <liste> bbear: what do you mean?
08:58:59 <hahahahahahahaha> Try a command
08:59:04 <liste> bbear: they're singly linked lists
08:59:10 <Nilabhra> !@Ip
08:59:10 <flaretechno> Your IP is: 45.249.69.54
08:59:20 <Nilabhra> !@Topic
08:59:30 <flaretechno> , welcome to channel #haskell. This robot was created by Tecflare Corporation. Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@Help, !@Build
08:59:31 <flaretechno> chipf0rk, welcome to channel #haskell. This robot was created by Tecflare Corporation. Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@Help, !@Build
08:59:40 <bbear> because one told me that the only O(1) operation for Haskell linked list are appending at the begining of the list.
08:59:42 <hahahahahahahaha> !@Imdb
08:59:42 <flaretechno> Error: illegal amount of arguments. For help, use !@help Imdb
08:59:46 <liste> flaretechno: your bot is nice, but please move it to a different channel
08:59:47 <bergmark> please kill this thing
08:59:56 <hahahahahahahaha> I cant!!!!
09:00:10 <flaretechno> fr33domlover, welcome to channel #haskell. This robot was created by Tecflare Corporation. Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@Help, !@Build
09:00:16 <bbear> move it to #test
09:00:20 <hahahahahahahaha> ok
09:00:39 <greg`> whats the difference between the Constant and Identity Functors
09:01:16 <athan> hahahahahahahaha: Your name made me laugh a lot while reading it. Thank you ;_;
09:01:26 <athan> greg`: well what's the difference between the functions?
09:01:35 <greg`> Functors
09:01:40 <athan> it's practically identical
09:01:42 <athan> I know
09:01:49 <athan> :t Identitiy
09:01:50 <lambdabot>     Not in scope: data constructor ‘Identitiy’
09:01:50 <lambdabot>     Perhaps you meant one of these:
09:01:50 <lambdabot>       ‘Identity’ (imported from Control.Monad.Identity),
09:01:53 <liste> bbear: that applies to all linked lists, if you can't modify the contents of nodes
09:02:00 <athan> :t Identity -- >_>
09:02:01 <liste> singly-linked lists*
09:02:02 <lambdabot> a -> Identity a
09:02:12 <athan> :t Constant
09:02:14 <lambdabot> Not in scope: data constructor ‘Constant’
09:02:19 <athan> ><
09:02:25 <greg`> lol
09:02:28 <athan> @djinn a -> b -> a
09:02:28 <lambdabot> f a _ = a
09:02:38 <greg`> oooh i forgot about djinn
09:02:39 <athan> ^ greg` 
09:02:39 <bbear> liste: basically I just imagined the concept of ringed linked list
09:02:50 <athan> it's the same for the functor
09:02:52 <greg`> athan thanks
09:02:57 <athan> :)
09:03:02 <athan> or wait, cripes...
09:03:05 <bbear> That would a structure that keeps head pointer
09:03:13 <athan> the constant functor is the lamest functor in existence then maybe
09:03:18 <greg`> lol
09:03:19 <athan> I never use it :s
09:03:35 <greg`> its just for padding 
09:03:42 <greg`> just want to get my head around it
09:03:52 <tnks> I think that's a little akin to saying zero is the lamest number.
09:04:01 <liste> > let ringedList = 1 : ringedList in ringedList -- bear
09:04:03 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:04:10 <athan> tnks: very good point :)
09:04:20 <athan> is it the 0 element over some monoid or something?
09:04:30 <athan> Like through abstraciton or something
09:05:29 <athan> over profunctors maybe :|
09:05:35 * athan splodes
09:09:28 <athan> So how about that GHC 8.0 though?! :D
09:09:42 <athan> Is `Fail : String -> Constraint` freaking sweet or what eh?
09:11:31 <adamCS> greg`: const functor has uses though, at least its use in Lens.  It is sort of a functor that ignores fmap.  So it allows view to work with a Van Laarhoven lens.
09:14:29 <GLM> Has anyone used a tool like Wreq inside of your quickcheck code?
09:15:50 <Aruro> does anybody know any papers similar to this one : http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/spigot.pdf 
09:16:34 <Aruro> some initeresting usage of haskell + interesting math
09:18:58 <weissi> hi there, I want to generate some Lua. On Hackage however there's two packages language-lua and language-lua2. Any opinions on which one to use?
09:19:13 <greg`> if i was using wreq with quickcheck i might consider turning off shrinking
09:21:45 <mpickering> Does anyone have a good reference for the problems you face in a language where the types are first-class?
09:22:32 <weissi> just realising lang-lua2 is in Stackage and lang-lua isn't so will go with lang-lua2...
09:24:17 <sm> morning all
09:24:30 <sm> how would you report the memory foot print of values, eg in GHCI ?
09:25:27 <greg`> when is stack going to support ghc8?
09:26:17 <mpickering> there is a post on reddit about it
09:26:41 <greg`> mpickering: is it recent?
09:26:43 <sm> https://www.reddit.com/r/haskell/comments/4kmgp1/stackage_lts_and_ghc_80/
09:30:07 <flaretechno> flaretechno, welcome to channel #haskell. This robot was created by Tecflare Corporation. Type !@About for more info or type !@help for details.  Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@About, !@Help, !@Build
09:31:04 <flaretechno> slaytaner, welcome to channel #haskell. This robot was created by Tecflare Corporation. Type !@About for more info or type !@help for details.  Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@About, !@Help, !@Build
09:31:33 <flaretechno> cita, welcome to channel #haskell. This robot was created by Tecflare Corporation. Type !@About for more info or type !@help for details.  Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@About, !@Help, !@Build
09:31:55 <flaretechno> pfurla, welcome to channel #haskell. This robot was created by Tecflare Corporation. Type !@About for more info or type !@help for details.  Here are some commands: !@Say, !@Weather, !@Ip, !@Imdb, !@Poke, !@Topic, !@Part, !@Timeout, !@About, !@Help, !@Build
09:33:03 --- mode: ChanServ set +o Cale
09:33:07 --- mode: Cale set +b *!*@112.50.148.146.bc.googleusercontent.com
09:33:07 --- kick: flaretechno was kicked by Cale (flaretechno)
09:33:15 --- mode: Cale set -o Cale
09:34:21 <hahahahahahahaha> hi
09:34:36 <hahahahahahahaha> did you kick my bot??
09:35:52 <Cale> hahahahahahahaha: I kicked *a* bot, it was spamming the same message to every user who joined the channel, which is extremely inappropriate in a channel with 1500 users
09:40:27 <hahahahahahahaha> ok
09:40:42 <jedai> hahahahahahahaha: Your bot was writing the "welcome message" to everyone, not sending a private message to an entering user... That would soon overflow anything useful in the channel
09:40:45 <hahahahahahahaha> can you unkick it so I can fix it pls
09:40:53 <Rotaerk> it shouldn't PM either
09:41:01 <Rotaerk> it should just not greet at all
09:41:27 <jedai> Rotaerk: Right but as it is it was really flagrant
09:41:38 <Akii> how can I use a locally build lib as a dependency in stack?
09:41:44 <liste> that bot has nothing to do with #haskell
09:41:47 <sm> hahahahahahahaha you are funny :)
09:42:03 <hahahahahahahaha> ikr
09:42:23 <liste> Akii: http://docs.haskellstack.org/en/stable/faq/#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
09:42:45 <liste> Akii: also the question before that one
09:43:00 <Akii> nice thanks!
09:47:22 <Akii> now the only problem is that it just "copies" the files as source files
09:47:36 <Akii> ideall I'd just build my lib and then have it as dependency
09:47:40 <Akii> ideally*
09:48:06 <Akii> now I've the same probem as before where certain language extensions are interferring with the lib
09:48:23 <Akii> in this case NoImplicitPrelude
09:51:06 <monochrom> I am not going to allow everyone's bot and their pet.
09:52:48 <monochrom> to be sure, I would not know that a bot exists until it spams
09:53:13 <monochrom> but definitely I am not going to allow everyone's spambot and their spampet
09:56:36 <Akii> okay wat - it builds but stack ghci fails :D
09:56:45 <Akii> stack what are you doing
10:03:12 <Akii> got it :D
10:03:19 <Akii> http://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
10:03:21 <Akii> cool stuff
10:03:58 <Akii> wow to think of how much time I've wasted with sbt
10:11:33 <idev> (i :: Int, f :: a -> m a) -- is there a way to say f applied i times ?
10:16:24 <Igloo> idev: \x -> iterate (>>= f) (return x) !! i  ?
10:31:21 <compman> Can anyone suggest me some good AI projects?
10:34:49 <Aruro> compman: there is no AI, there is computer vision,hearing and other stuff.
10:35:25 <compman> Aruro: Like I mean a c 
10:35:26 <Aruro> compman: computer reading, writing, composing
10:35:35 <compman> chess engine or something
10:36:41 <Aruro> compman: "deep" "learning" is a new buzzword, maybe u will be interested in that
10:45:40 <anks> hi, i want to achieve something like this: i've got a parseSomething :: Parser Something, which obviously may fail (as monads do), but i want the fail not to be propagated and stop it with transforming it to something like :: Parser (Either Jump Something). Is it possible?
10:47:31 <sm> anks: I'm not sure if this is the best way, but I've done that by mixing in the Exception monad to my parser, then throwError terminates parsing
10:49:53 <sm> this also handles other reasons for parser termination (eg from IO)
10:50:19 <anks> its not that i want it to terminate
10:50:23 <geekosaur> most parse failures are not exceptions, though. and this is a case where it is useful to remember that parsers are Applicatives
10:51:14 <geekosaur> and, more to the point, Alternatives
10:51:28 <anks> yikes
10:51:51 <anks> obviously, thanks!
10:52:14 <sm> was that to anks or me ?
10:55:10 <shapr> sm: GOOD AFTERNOON!
10:55:12 <sm> to anks, I think. When I parse an attempt at some syntax that is unambiguously wrong, I want to end parsing and show a useful error, hence the exception - if I'm missing a better way, please let me know
10:55:23 <sm> good afternoon to you shapr!
10:56:27 <shapr> I know this is older, but I really enjoyed reading it: https://byorgey.wordpress.com/2012/11/05/foldr-is-made-of-monoids/
10:57:12 <anks> sm: i have probably misexplained my issue, as what I really wanted was to skip some number of bytes, should the parser fails.. (instead of propagating fail, to the combinators)
10:57:23 <shapr> byorgey: great post, thanks!
10:57:38 <anks> thanks for your time though :]
10:57:53 <sm> anks: I see, different needs.np
11:30:09 <bbear> anybody has experience into semantic extraction ?
11:36:00 <davidkart> hello
11:36:05 <davidkart> I have a very naïve question
11:36:28 <davidkart> I would like to know exactly what's an algorithm, and what is the link between functional programming and algorithsm.
11:36:53 <shapr> howdy davidkart, how's code?
11:37:37 <shapr> davidkart: it's the same connection between imperative or logic programming and algorithms, though I'm not sure I have a clear definition of an algorithm.
11:37:43 <simpson> davidkart: An algorithm is just a sequence of steps to do some computation. The precise meaning of pretty much every word in that sentence is up for debate, but that's the general idea.
11:38:00 <simpson> davidkart: Functional programming is linked to algorithms because all programming is linked to algorithms.
11:38:23 <davidkart> for example I can think of functional constructs : 
11:38:27 <davidkart> > let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
11:38:28 <lambdabot>  <no location info>:
11:38:28 <lambdabot>      not an expression: ‘let rightTriangles' = [ (a,b,c) | c <- [1..10], b <-...
11:38:32 <nitrix> Is it possible to have something akind to :: Just a -> Nothing? I have some kind of "promotion" to do between data constructors where a leaf becomes a node and they do not have dedicated types.
11:38:43 <nitrix> Am I screwed or I can hack something?
11:39:58 <shapr> davidkart: I'd say the biggest difference between FP and imperative is the evaluation strategy.
11:40:21 <shapr> nitrix: const?
11:40:28 <geekosaur> nitrix, I'm not sure what you are asking?
11:40:46 <davidkart> shapr: well What I was asking was more or less that « a haskell program compiled is just a sequence of steps, so in the end functional programming is just high level imperative programming » ?
11:41:00 <monochrom> an algorithm is a lambda expression. a lambda expression is a functional program.
11:41:01 <MichaelBurge> nitrix: I think you want something like 'f :: Nothing :: (Maybe k0) -> Nothing :: (Maybe k1)', where k0 and k1 are kinds and Nothing is enabled by DataKinds?
11:41:02 <nitrix> geekosaur: Notice that `Just a` and `Nothing` aren't types.
11:41:06 <shapr> davidkart: yeah, but from that viewpoint, imperative programming is high level functional programming :-)
11:41:16 <simpson> davidkart: In the end, all computation is Turing-equivalent or weaker, unless somebody builds something stronger.
11:41:19 <shapr> right
11:41:57 <MichaelBurge> nitrix: The new GHC 8 is supposed to unify kinds and types, so it might be worth looking at TypeInType
11:42:00 <shapr> davidkart: also, do you have those nifty quotes directly on your keyboard? I want some of those.
11:42:05 <nitrix> MichaelBurge: It's almost like DataKinds, but as in, DataTypes... if that was a thing.
11:42:49 <simpson> shapr: If you have a Compose key set up, the combos "<<" and ">>" code for « and » in many locales.
11:43:02 <nitrix> data Node = MkNode k (Quad k v)
11:43:05 <nitrix> data Grid k v = GridNode Node
11:43:11 <nitrix> Otherwise I have to use something like this :/
11:43:27 <shapr> hm, I'll have to see where the compose key is setup in my ergodox layout
11:43:32 <nitrix> Just to get a :: Leaf -> Node function.
11:43:32 <davidkart> shapr: I am using this keyboard layout : https://bepo.fr/wiki/Accueil 
11:43:57 <davidkart> I, for a long time, looked for a mapping that would allow for mathematical symbols.
11:43:57 <nitrix> Whoops, kind errors in there.
11:44:15 <shapr> davidkart: c'est chouette! :-)
11:44:43 <shapr> looks like a french dvorak flavor at first glance
11:44:50 <monochrom> nitrix: it is possible for "Just a" and "Nothing to be types, of kind "Maybe a". but then, it is not possible to have a type "Just a -> Nothing". the type constructor (->) wants one parameter (I forgot which) to be of kind *. 
11:45:03 <davidkart> « » <- actually this is french quotes
11:45:03 <nitrix> Gotcha.
11:45:40 <davidkart> “ ” “ ” <- this is english quotes IINM
11:45:51 <geekosaur> aka guillemets
11:46:19 <shapr> davidkart: have you read about https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_name ?
11:46:58 <nitrix> Do `data` types have an overhead if they are product types?
11:47:23 <nitrix> As in; being tagged or something like a sum type would?
11:47:23 <monochrom> yes
11:47:34 <shapr> next time I write a programming language, I'll use either french or german quotes, because it'll be easier and more fun to have different begin and end quotes.
11:47:44 <monochrom> "data" always has tag overhead
11:48:47 <davidkart> shapr: reading, really interesting.
11:48:47 <monochrom> what are German quotes?
11:49:29 <inkjetunito> monochrom: die Anführungszeichen
11:49:57 <shapr> monochrom: german has up and down double quotes: http://german.stackexchange.com/a/127
11:51:13 <shapr> inkjetunito: I like your answer better :-)
11:51:38 <merijn> shapr: So, have you got a decent setup for Haskell + CUDA yet? :)
11:53:02 <shapr> merijn: I got accelerate-cuda to build with a bunch of extra-deps , but accelerate-examples is being difficult. Have you been able to build accelerate-examples with stack?
11:53:23 <monochrom> nitrix: I lied a bit. by GHC 8, (->) wants each of its parameters to be of a runtime-representation kind. * is one such kind, for types like Int and [Int]. there is another kind for types like Array#. there is another kind for the Int# type.
11:53:36 <shapr> I suspect accelerate-examples really wants all of the other accelerate backend libs, but I only want to play with accelerate-cuda, so maybe I should file out the examples myself.
11:54:14 <merijn> shapr: I've not really used accelerate because it's not low level enough for me :)
11:54:39 <shapr> so what do you use for Haskell + CUDA ?
11:54:51 <merijn> shapr: C++ >.>
11:54:54 <monochrom> overall, (->) wants each parameter to be a type that has a runtime representation. something that captures the intuition of "datum". but the types "Just a" and "Nothing" do not qualify.
11:54:55 <davidkart> Basically, functional constructs does not seem that magic
11:55:11 <merijn> shapr: I couldn't find a good enough CUDA library for me to use haskell, but I'd like too
11:55:14 <shapr> davidkart: there isn't any magic, or maybe it's all magic.
11:55:16 <davidkart> I would like to learn many languages because it would provide me with a great insight into the programming word.
11:55:27 <shapr> I agree
11:55:40 <davidkart> shapr: yes, that's it.(word->world)
11:55:41 <shapr> davidkart: wait till you get to evaluation strategies in Prolog, that blew my mind :-)
11:56:04 <shapr> davidkart: also, stack based languages are fun, I had a blast writing some PostScript and Joy
11:56:10 <merijn> shapr: And I don't have time to implement my own CUDA library, also I'm worried about haskell execution being to unpredictable (i.e. introducing too much jitter) for my benchmarks
11:56:51 <shapr> I just want to use the surprisingly decent graphics card in this laptop to make my Haskell even more awesome than before!
11:58:45 <shapr> davidkart: when you're bored with all the other languages, check out WvO's stuff http://strlen.com/programming-languages
11:59:22 <davidkart> yes, I wondered if 3D/gl with haskell is fun.
11:59:35 <merijn> davidkart: 3D/gl is never fun
11:59:46 <merijn> davidkart: So it's also not fun with haskell ;)
12:03:23 <merijn> Or rather, the results are fun, but coding/debugging it never is :p
12:03:49 <byorgey> shapr: glad you enjoyed it!
12:08:17 <quxbam> My program runs ~20% in gc, is that normal?
12:10:03 <merijn> quxbam: "It Depends"
12:10:10 <merijn> quxbam: You could try increasing the heap size
12:10:39 <merijn> That will delay GC frequency (and thus runtime), but increase the memory usage
12:10:55 <quxbam> merijn: I'll try it, thanks
12:13:01 * hackagebot ip 0.6.0 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.6.0 (andrewthad)
12:16:10 <Aruro> is it possible to define own infix type constructors like (:) ?
12:16:26 <Aruro> like data Time = Int : Int
12:16:33 <NatureShade> think so
12:16:37 <Akii> sure
12:16:41 <NatureShade> just like you did
12:16:53 <Aruro> mm
12:16:58 <Aruro> it does not work like that :)
12:17:08 <Akii> nvm, thought you meant operators
12:17:15 <Cale> 1) You can't name it :, but otherwise anything starting with : will work
12:17:23 <Cale> 2) That's a data constructor, not a type constructor
12:17:37 <Aruro> Cale: why annoying : ?
12:17:55 <Cale> : is a built-in infix data constructor for lists
12:18:16 <Aruro> well, lets say data Time = Int + Int
12:18:27 <dolio> That doesn't begin with a colon.
12:18:29 <hjljo> data Example = Int :+ Char
12:18:29 <Cale> data Time = Int :+ Int will work
12:18:38 <quxbam> Well, Int + Int works
12:18:39 <NatureShade> couldn't you just do import Prelude hiding ((:))
12:18:48 <Aruro> can i hide : from prelude?
12:18:56 <NatureShade> not sure
12:18:58 <Aruro> and use data Time = Int : Int ?
12:18:59 <quxbam> But you'll need some pragmas
12:19:07 <Cale> I don't think you can...
12:19:13 <Cale> But I haven't tried it
12:19:20 <Aruro> NatureShade: yes , that :)
12:19:31 <dolio> It doesn't matter if you hide list's (:), you still don't get to use it for your own type, as I recall.
12:19:38 <Cale> The syntax of the language was originally written in such a way that it required a nonempty sequence of symbol characters after the :
12:20:02 <obadz> Illegal binding of built-in syntax: :
12:20:06 <Cale> yeah
12:20:12 <Aruro> Cale: this would be much more usefull than useless extension TypeOperators :)
12:20:14 <obadz> Wonder why it had to be a builting
12:20:55 <n_blownapart> hi I'm having trouble installing the haskell-ghc-mod on atom. noob here. getting a big red error box in upper right. It seems to properly install using apm. any hints? thanks
12:21:00 <quxbam> Aruro: Why do you consider TypeOperators useless?
12:21:08 <Aruro> then u can very easily expand usefullness of Show,Read deriving
12:21:22 <geekosaur> obadz, probably because [a,b,c] list syntax desugars to it, so it has to be wired-in
12:21:42 <n_blownapart> ^this is latest stable version of atom, 1.7.4
12:22:33 <Aruro> suppose i wanted to parse time 12:00, then i would just write data Time = Int : Int deriving (Show,Read) . perfect.
12:22:36 <obadz> geekosaur: do-notation desugars to (>>=), does that mean I can't hide & redefine it?
12:22:50 <geekosaur> I did not say do notation, I said [a,b,c]
12:23:01 <obadz> right but isn't that the same thing?
12:23:04 <geekosaur> no
12:23:04 <dolio> I think type operators are considerably more useful than defining your own time type that happens to look like some notations for time.
12:23:15 <geekosaur> you maybe thinking of list comprehensions
12:23:16 <obadz> why not?
12:23:17 <monochrom> "data [a] = [] | a:[a]" has to be built-in as a whole, even if ":" alone does not need to. how else could you support the syntax "[]"?
12:23:21 <Aruro> dolio: its not about time ,its about read
12:23:44 <obadz> X desugars into Y, therefore cannot touch/alter Y
12:23:46 <quxbam> Aruro: Why would you want to use read for anything?
12:23:48 <Aruro> dolio: freedom in data constructors expands its usefulness
12:23:58 <geekosaur> I am talking about [1,3,5] desugaring to 1:3:5:[]
12:24:00 <Aruro> quxbam: why is there read?
12:24:09 <obadz> (X, Y) = ( [,], : ) vs (X, Y) = (do, (>>=))
12:24:11 <Hijiri> I think it pretty marginally expands its usefulness
12:24:12 <obadz> what's the diference?
12:24:25 <mizu_no_oto_work> Aruro: historical mistakes in API design.
12:24:25 <quxbam> Aruro: I don't know, but it's dangerous and not performant
12:24:33 <Hijiri> it's only useful in the case you have something that is written with a : in the middle
12:24:37 <Aruro> Hijiri: your example of parsing time easier than that?
12:25:01 <Hijiri> It's not about ease, it's just that Read isn't meant for actual parsing use
12:25:02 <Aruro> quxbam: there is readMaybe, which is quite fine i think
12:25:17 <quxbam> yes
12:25:18 <Hijiri> except maybe in debug cases?
12:25:22 <quxbam> readMay
12:25:50 <monochrom> you don't have to use "readMaybe" as the name of your parser.
12:25:50 <Aruro> Hijiri: its usefulness you underestimate
12:25:53 <Hijiri> Also my point wasn't that it isn't easier
12:25:58 <Hijiri> Just that it's only useful in this one case
12:25:59 <MichaelBurge> obadz: I think you can't actually override (>>=), but someone put in the effort to write the RebindableSyntax extension to do that.
12:26:20 <xa0> Hijiribe ruri
12:26:34 <Hijiri> is that an anime character?
12:26:37 <obadz> MichaelBurge: huh?
12:26:39 <xa0> Yep
12:26:54 <obadz> > let (>>=) = (+) in 3 >>= 1
12:26:56 <lambdabot>  4
12:27:03 <Aruro> is there way similar in ease to deriving read to parse stuff?
12:27:08 <mizu_no_oto_work> Aruro: you can manually define both Read and Show if you want it to look nice (e.g. rendering a 2-tuple as 123:321)
12:27:10 <obadz> > let (:) = (+) in 3 : 1
12:27:12 <lambdabot>      Constructor ‘:’ should have 2 arguments, but has been given none
12:27:12 <lambdabot>      In the pattern: (:)
12:27:12 <lambdabot>      In a pattern binding: (:) = (+)
12:27:26 <MichaelBurge> obadz: I mean, you can define a function called (>>=), but it won't do what you think it does with respect to do notation.
12:27:33 <obadz> > let (+) = (,) in 3 + 1
12:27:34 <lambdabot>  (3,1)
12:28:02 * hackagebot yesod-ip 0.3 - Code for using the ip package with yesod  https://hackage.haskell.org/package/yesod-ip-0.3 (andrewthad)
12:28:19 <obadz> MichaelBurge: I would think it wouldn't be in scope to what do-notation desugars into. Is that what it does?
12:28:37 <pikajude> is there anything better than optparse-applicative these days?
12:28:39 <pikajude> is "options" good?
12:28:45 <quxbam> Aruro: You can do that with typeclasses and generalizenewtypederiving
12:29:10 <MichaelBurge> obadz: RebindableSyntax makes it desugar into the overridden (>>=). I guess yours is a little different, since you just want a symbol called (:) that doesn't affect [1,2,3]
12:29:27 <Aruro> quxbam: is there any examples?
12:29:32 <obadz> MichaelBurge: but if I overload (:), I still want to [1,2,3] use the non-overriden one…
12:29:34 <MichaelBurge> obadz: There's probably no technical reason it couldn't be done, except that parsing might be a little harder and you'd need an extension for it.
12:30:13 <quxbam> Aruro: I'm writing atm an inhouse optimizer using such stuff technique and generics, but it's rather complicated
12:30:23 <obadz> In otherwords, I understand the exception for [], but don't think (:) should be anymore special than (>>=)
12:30:24 <monochrom> pikajude: options looks much simpler than optparse-applicative, but has the same spirit. perhaps it's a good starting point. (when I started, options didn't exist.)
12:30:25 <Aruro> for example read gives out of the box rather arbitrary config file parsing
12:30:34 <pikajude> i'll do options then
12:30:39 <Aruro> quxbam: i mean some tutorials
12:30:48 <obadz> MichaelBurge: an extension for what? looks like what I want to do with >>= is already doable.
12:30:51 <nmattia> pikajude: I've personally been dying to try optparse-generic
12:31:10 <nmattia> if you've had fun with aeson and other generic goodness
12:31:26 <pikajude> it does flags only
12:31:29 <pikajude> I need positional arguments as well
12:31:39 <nmattia> oh that's a shame
12:31:43 <quxbam> Aruro: not that I'm aware of, but I really recommend atto-parsec
12:31:44 <monochrom> ah, optparse-applicative has positional arguments
12:32:14 <Aruro> nmattia: there was package before optparse-generic, there is even presentation on youtube
12:32:52 <pikajude> plus options has that whole "plural noun" thing going on
12:33:02 <pikajude> it'll go well with containers and parsers
12:33:38 <nmattia> Aruro: do you mean there was a package called package? I'm not sure I understand what you mean
12:33:53 <Aruro> quxbam: i wish i could do data Time = Time Int Int deriving Parsec :)
12:34:10 <pikajude> whoops, i spoke too soon. options doesn't have positional arguments either
12:34:22 <Aruro> nmattia: optparse-generics appeared after this idea was already on hackage
12:34:44 <Aruro> nmattia: it was called somethink like Generics-Args or something
12:34:57 <quxbam> Aruro: generics
12:35:04 <neptuneslayer> hello
12:35:32 <nmattia> is it getopts-generics?
12:35:44 <nmattia> never seen it before, thanks
12:35:58 <quxbam> Aruro: for example you could write newtype Time = Time (Int,Int)
12:36:19 <quxbam> so you can use generalizednewtypederiving
12:36:56 <quxbam> class Parsable a where
12:37:04 <quxbam>   parser :: Parser a
12:37:21 <quxbam> and then write instances for basic stuff like int
12:37:33 <quxbam> afterwards, everything works automatic
12:39:16 <Aruro> nmattia: yes that one, it was first to do generic arguments
12:39:31 <piyushsr> @hoogle [a] -> [a]
12:39:34 <lambdabot> Prelude cycle :: [a] -> [a]
12:39:34 <lambdabot> Data.List cycle :: [a] -> [a]
12:39:34 <lambdabot> Prelude init :: [a] -> [a]
12:39:50 <quxbam> id
12:40:52 <piyushsr> @help
12:40:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:40:59 <piyushsr> @list
12:40:59 <lambdabot> What module?  Try @listmodules for some ideas.
12:41:09 <piyushsr> @listmodules
12:41:09 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
12:41:19 <piyushsr> @list eval
12:41:19 <lambdabot> eval provides: run let define letlpaste undefine
12:41:20 <maerwald> piyushsr: you can pm lambdabot
12:41:22 <maerwald> plz do that
12:48:32 <Kpovoc> Hello
12:50:39 <Kpovoc> I'm new to Haskell, and I am working my way through "Learn you a Haskell for Great Good!" and I've found that I really like the theme used for the syntax-highlighting in the examples. Does anyone know the name of that theme?
12:51:56 <MichaelBurge> Kpovoc: It looks like some custom CSS: http://learnyouahaskell.com/sh/Styles/SyntaxHighlighter.css
12:52:37 <MichaelBurge> Then again, the bottom says "Language specific styles", which would be weird to put in for a custom Haskell highlighter
12:53:11 <Kpovoc> MichaelBurge: Well thanks for the link, it's definitely a start.
13:03:04 * hackagebot yesod-ip 0.4 - Code for using the ip package with yesod  https://hackage.haskell.org/package/yesod-ip-0.4 (andrewthad)
13:05:22 <davidkart> Last night I thought about scientific programming with Haskell
13:05:29 <davidkart> would it be efficient ?
13:06:04 <davidkart> Some remarks about it : usually scientific programming is made with matlab/octave like languages. They are not compiled. Haskell however is compiled.
13:06:39 <MichaelBurge> davidkart: Those languages tend to outsource the work to compiled libraries, though.
13:06:43 <davidkart> But is really expressive, so gain of time to write function, gain of speed because the compilation.
13:06:48 <hpc> you usually don't do large jobs directly in matlab
13:07:00 <davidkart> hpc: Actually I do
13:07:02 <hpc> you prototype it, and then have some undergrads write it in fortran or c
13:07:16 <davidkart> Well, it could be
13:07:19 <MichaelBurge> My gut is that people doing exploratory work wouldn't benefit too much from the type system, which mainly helps when a codebase needs to be production-ready
13:07:36 <hpc> (somehow fortran has retained a niche in numerical code)
13:07:53 <davidkart> Well, is there some scientific libs for Haskell ? It would be killing
13:08:01 <hpc> there are several
13:08:13 <MichaelBurge> There's Repa for matrix and array calculations
13:08:27 <MichaelBurge> And some GPU libraries
13:08:29 <hpc> the type system has the potential to help quite a bit, if you can get it to exclude the right operations in your favor
13:08:48 <davidkart> hpc: not really getting wat you said.
13:08:55 <hpc> it can be easy to make a mistake and find out you did something totally wrong only after an hour or two into the job
13:09:09 <davidkart> ah yes talking to MichaelBurge
13:09:16 <hpc> yeah
13:09:30 <MichaelBurge> hpc: That abstractly sounds plausible, especially for an experienced Haskell programmer. But I'm thinking specifically of the people that I know that write R and Matlab code
13:09:34 <davidkart> well -- As a beginner in Haskell having written 3-4 little programs,
13:09:37 <MichaelBurge> hpc: Those people it probably wouldn't help much
13:09:48 <hpc> ah yeah, they'd probably struggle a bit
13:10:26 <davidkart> I can tell the following : a Haskell program just do what I intended to write (even if it takes a little longer, in the end, it runs fine without border case, forgotten incrementation of variable, etc)
13:10:48 <hpc> figuring out an entirely new language of "you need to use a different multiplication for different types of vector math" and whatnot
13:11:11 <davidkart> Honestly I ought to think that Haskell deserves a lot of recognition for numerical computations.
13:11:25 <davidkart> and I was really upset at the language one week ago w
13:11:32 <davidkart> when I started to learn.
13:11:52 <davidkart> I'm a living publicity for Haskell
13:11:57 <davidkart> hell
13:12:17 <davidkart> but I still go back and forth with python
13:12:38 <hpc> god help you when you start going back and python with forth
13:12:42 <davidkart> that last seems sooo messy/dirty after writing clean code in Haskell :p
13:13:03 <Rembane> davidkart: You need itertools, functools and operator. :)
13:13:29 <jophish> When using explicit type signatures and TypeInType why isn't it necessary to annotate kinds too
13:13:48 <jophish> for example: this works: let foo :: forall f a. f a; foo = foo
13:14:32 <jophish> and GHC infers: foo :: forall k (f :: k -> *) (a :: k)
13:16:21 <jophish> I imagine that this is purely a convenience
13:18:16 <shapr> MichaelBurge: I benefit from doing type driven development, have you tried it?
13:18:40 <shapr> davidkart: you like Haskell now? :-)
13:20:09 <MichaelBurge> shapr: There's a book I keep seeing that I'll probably end up buying that mentions that: https://www.manning.com/books/type-driven-development-with-idris
13:20:25 <MichaelBurge> shapr: How is type-driven development different from the Haskell that most people write?
13:20:50 <shapr> I can write code in any direction?
13:21:08 <shapr> rather than top down or bottom up, I can do both at the same time and throw in type holes to figure out what I need next
13:21:31 <EvanR> type driven development = haskell
13:21:39 <EvanR> how would you do anything any other way
13:21:57 <monochrom> "any direction" is a tall order :)
13:22:03 <MichaelBurge> shapr: Oh, sort of like when you use a theorem-prover and you just admit lemmas when they're a distraction?
13:22:05 <L8D> MichaelBurge: it also emphasizes the use of type-driven libraries that make you focus on defining types and implementing type classes instead of implement programs and making technical decisions yourself
13:22:15 <shapr> MichaelBurge: if I did that, sure :-)
13:22:15 <L8D> implementing*
13:22:28 <monochrom> can I write from in front of the screen to behind the screen? :)
13:22:45 <shapr> L8D: yeah, I mostly write Python in my day job, and that's all about writing the code and then fixing it when it breaks.
13:23:19 <shapr> also, Python is much about using dict/list/etc to fake 'real' data structures.
13:23:22 <mauke> hmm. does python even have warnings?
13:23:29 <shapr> mauke: yeah, it's on the box ;-)
13:23:48 <mauke> I mean the interpreter notifying you when it sees something that's not technically illegal but dubious
13:23:53 <monochrom> haha
13:24:10 <shapr> mauke: no, that requires flake8 or pylint or something
13:24:22 <mauke> are those static?
13:24:23 <monochrom> I think the most important warnings are in "coding style guides"
13:24:31 <glguy> Warning: Python is known by the State of California to cause cancer?
13:24:50 <jophish> "For backward compatibility and convenience, kind variables may be implicitly quantified, just like today." I see
13:24:54 <dibblego> @remember monochrom I think the most important warnings are in "coding style guides"
13:24:55 <lambdabot> I will never forget.
13:25:06 <shapr> mauke: they're preprocessors that look for common problems, but many of the problems are syntactic. They can find syntax errors before runtime, but otherwise you find them at runtime.
13:25:20 <shapr> @remember glguy Warning: Python is known by the State of California to cause cancer?
13:25:20 <lambdabot> Done.
13:25:41 <dolio> Finding syntax errors at runtime is the worst, so that's better than nothing.
13:25:53 <mauke> I'm pretty sure python finds syntax errors at compile time
13:25:54 <shapr> I really enjoyed byorgey's "foldr is full of monoid" blog post, but I can't think of any way to make that work in Python :-(
13:26:13 <dolio> JavaScript doesn't. You need a linter for that. :)
13:26:22 <mauke> javascript does
13:27:11 <shapr> MichaelBurge: upon further thought, yes! a type hole sounds like what I think is the meaning of "admitting a lemma"
13:27:15 <dolio> I just wrote a bunch, and it doesn't.
13:27:16 <simpson> Most Python code is really straightforward to statically analyze. I get the same sorts of hints in my IDE about Python code as I do about Haskell code.
13:27:30 <monochrom> shapr: I think the obstacle is lack of "list of functions", even "generator of functions". functions are castrated in python.
13:27:58 <mauke> monochrom: eh? you can do all of those in python
13:28:03 <shapr> You can sort of generate functions in Python, but that takes away much of the ability to do static analysis
13:28:31 <mauke> dolio: alert("hi");  {] syntax error here   // this doesn't execute the alert
13:29:01 <dolio> That example isn't complicated enough to be convincing.
13:29:17 <Rembane> mauke: Python doesn't find all typos during compile time.
13:29:34 <merijn> Rembane: Python doesn't even find all typos during runtime
13:30:04 <EvanR> dynamic typos
13:30:17 <Rembane> merijn: Indeed, only the ones executed.
13:30:18 <mauke> dolio: ok, put 1000 lines of arbitrary code in between those two things
13:30:28 <dolio> mauke: No, that still is worthless.
13:30:29 <mauke> Rembane: not even then
13:30:35 <mauke> dolio: why?
13:31:18 <mauke> Rembane: if you typo a variable name in an assignment, you may just get wrong results
13:31:33 <merijn> mauke: to be fair, you can have typos undetected in haskell too :)
13:32:03 <mauke> that's why you don't name your variables x' and x''
13:32:41 <EvanR> yes, use myLongVariable and myLongVariable' instead!
13:33:20 <EvanR> actually whats a better idea
13:33:35 <mauke> my point is, python will create new variables behind your back at the slightest provocation :-)
13:33:46 <mauke> and even when it doesn't, you get a runtime error at best
13:33:53 <merijn> EvanR: I use "newX" usually
13:33:56 <mauke> that's a bit harder to achieve in haskell
13:34:40 <shapr> MichaelBurge: so now I want to buy that idris book
13:34:59 <dolio> mauke: Because it doesn't show that, e.g. a syntax error inside a function that isn't called will be caught.
13:36:01 <mauke> dolio: I'm not sure that concept makes sense
13:36:14 <mauke> if it has a syntax error, it's not a function definition
13:36:21 <mauke> it's an error
13:36:27 <davidkart> simpson: if it was the case, then why no efficient compiler would have been written for python ?
13:37:41 <EvanR> "efficient compilers for languages despite themselves"
13:37:55 <Rembane> mauke: Yes, depending a bit on the name of the variable and the typo.
13:38:10 <shapr> Mind you, I'd consider Self more dynamic than Python, and it sort of has an efficient compiler (poly inline caching)
13:38:28 <Rembane> mauke: OTOH, this is really nice: NameError: name 'typo' is not defined
13:38:48 <mauke> Rembane: is that a runtime error?
13:39:23 <Rembane> mauke: Probably yes. I checked it in the REPL.
13:39:51 <mauke> not nice, then :-(
13:41:15 <dolio> Maybe your point is that all things JavaScript defines as syntax errors are caught at compile time.
13:41:18 <EvanR> can i get a stack overflow doing ... let x = recurse "foo" in y = recurse x in "bar"
13:41:34 <EvanR> i.e. if the first recurse keeps recursing, maybe forever
13:41:34 <dolio> The problem then is that some things that are syntax errors are not defined as syntax errors.
13:41:48 <dolio> Which is just as bad.
13:41:53 <mauke> dolio: example?
13:42:04 <merijn> EvanR: recurse is never called in that code?
13:42:14 <merijn> EvanR: Or did you mean "recurse "bar""?
13:42:18 <EvanR> can i get a stack overflow doing ... let x = recurse "foo" in y = recurse x in bar x y
13:42:26 <dolio> Returning the value of a variable that doesn't exist.
13:42:52 <mauke> dolio: yeah, I wouldn't classify that as a syntax error
13:42:59 <dolio> It is in a good language.
13:42:59 <merijn> EvanR: "Compile error: recurse undefined"?
13:43:10 <EvanR> its in the ...
13:43:19 <EvanR> this is in the definition of recurse
13:43:20 <mauke> dolio: I don't think it's a syntax error in any language
13:43:35 <merijn> EvanR: Insufficient information to say anything
13:43:49 <EvanR> do you have an example where it doesnt overflow?
13:44:04 <merijn> EvanR: Trivial counter-example: "bar x y = ()"
13:44:25 <MichaelBurge> mauke: C is an example of a language that throws a compile error if you return a non-existent variable.
13:44:30 <EvanR> bar = (++)
13:44:32 <mauke> MichaelBurge: yes, but not a syntax error
13:44:39 <merijn> MichaelBurge: Compile error /= syntax error
13:44:51 <EvanR> bar = (+)
13:45:02 <mauke> but I really don't understand why JS 'use strict' throws runtime errors
13:45:15 <merijn> EvanR: Then it depends on recurse still, consider when "recurse "foo"" has it's own pattern
13:45:24 <mauke> also depends on the Num instance
13:45:36 <merijn> Returning an undefined variable isn't a syntax error in any sane language
13:45:54 <merijn> If it was you'd need to keep track of all names in scope to parse said language
13:46:03 <EvanR> any tips on avoiding stack overflows, or why stack overflows are not a problem when doing a 2-way recursion?
13:46:07 <merijn> More of a context analysis answer
13:46:22 <mauke> merijn: sounds like lisp :-)
13:46:36 <mauke> (reader macros)
13:47:21 <merijn> mauke: To be fair, you actually DO need an interpreter to properly implement the reader/parser for lisp :)
13:47:43 <EvanR> i remember doing a breadth first search of an infinite 9-way tree, it took up more and more memory, but didnt stack overflow
13:48:12 <merijn> EvanR: Stack overflows come from continuously pushing pattern matches without ever resolving them
13:48:25 <merijn> EvanR: Actually, I thought modern GHCs couldn't stack overflow anymore
13:48:31 <EvanR> o_O
13:48:32 <merijn> EvanR: So: Add more strictness
13:49:00 <dolio> The default stack limit is set very large.
13:49:09 <dolio> Like 1/4 of your memory or something.
13:49:18 <EvanR> oh geez
13:49:24 <mauke> anyway, I was curious about warnings in python because we use perl (an older version) at work, and I recently ran our test suite with the latest perl
13:49:29 <merijn> dolio: Modern GHCs dynamically grow the stack, no?
13:49:30 <EvanR> so there could be a bug and it just looks like a memory leak
13:49:35 <mauke> it has improved warnings and found like half a dozen bugs
13:49:48 <merijn> EvanR: That's rather likely, yes
13:50:19 <EvanR> can you explain what pushing patterns matches without resolving them is
13:50:32 <dolio> merijn: Yes. I'm not sure if it ever didn't grow the stack. But the limit isn't gone, I think. Just very large.
13:50:44 <dolio> It used to be pretty small in the grand scheme of things.
13:51:44 <dolio> Oh, I was way off.
13:51:55 <dolio> Default stack limit is 80% of physical memory.
13:52:01 <EvanR> O_o
13:52:39 <EvanR> maybe that explains the blogosphere common sense fact "haskell leaks memory like sieve"
13:52:51 <dolio> Doubt it.
13:53:12 <EvanR> i.e. if you dont know what youre doing it looks like a memory leak
13:53:45 <dolio> It's only been that way for a couple GHC versions.
13:53:51 <EvanR> oh
13:54:06 <EvanR> then it may have been a prophecy 
13:54:54 <merijn> EvanR: This only happens if you have a space leak due to insufficient strictness OR you have an infinite loop that allocates
13:55:13 <dolio> No, this is stack usage.
13:56:41 <merijn> dolio: Eh, I guess allocate is the wrong word
13:56:53 <monochrom> indeed, the folklore sieve algorithm leaks memory
13:57:04 <EvanR> can you tell what is stack usage and what is just lots of thunks by imagining the expression tree being "reduced"
13:57:04 <merijn> I meant infinite loop that pushes new pattern matches without ever getting to evaluate them
13:57:52 <merijn> EvanR: Whenever you do case-of you push the continuation (i.e. the different branches) on the stack and start evaluating the expression in the case
13:57:56 <mauke> EvanR: imagine you're at the top of the expression tree and it's a pattern match: case ... of Foo -> ...
13:57:56 <monochrom> "the folklore sieve algorithm leaks memory like a sieve" is a fun tautology
13:58:12 <merijn> EvanR: When the evaluation is done you look at the continuation, pick which branch to execute, pop it and continue
13:58:16 <mauke> EvanR: so now you have to force the value to decide which branch to take
13:58:32 <mauke> EvanR: but that value might be a thunk containing another case/of, and so on
13:58:35 <merijn> EvanR: So if your case expression pushes another case on the stack during it's evaluation
13:58:59 <merijn> EvanR: So if your expression never returns and just keeps pushing new case expressions you overflow the stack, eventually
13:59:37 <mauke> > foldl (+) z [1 .. 100]
13:59:39 <lambdabot>  z + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 1...
13:59:50 <mauke> well, that doesn't show the nesting very clearly
13:59:54 <mauke> > foldr (+) z [1 .. 100]
13:59:56 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (1...
14:00:20 <mauke> the top level is 1 + (...)
14:00:26 <EvanR> is it enough that the expr in the case evaluates to a (_,_) or (_:_), and stackoverflow would only be if the expr was _|_
14:00:38 <mauke> but + is strict, so it needs to evaluate both arguments
14:00:55 <mauke> the right argument is another +, with another thunk as an argument
14:00:57 <mauke> and so on
14:01:24 <mauke> this uses stack to recurse down the RHS until it can finally start by reducing 100 + z
14:01:36 <EvanR> hmm + seems to be a different category of issues than case
14:01:42 <shapr> @quote
14:01:43 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
14:01:46 <mauke> nah, same thing
14:02:06 <dolio> GHC has extensions so that (+) can be implemented with case on the usual types.
14:02:11 <dolio> Instead of being magic.
14:02:21 <mauke> (+) on Int is probably defined like (I# x) + (I# y) = ...
14:02:26 <EvanR> how to understand + in terms of the case explanation from earlier
14:02:35 <mauke> which is pattern matching
14:02:46 <merijn> mauke: It is
14:02:51 <EvanR> ah, 1 branch case
14:03:07 <EvanR> and this applies to function definitions too
14:03:08 <mauke> EvanR: in addition to pattern matching it's also function application
14:03:21 <mauke> to evaluate f x, you have to evaluate f to a lambda first
14:03:21 <merijn> "add x y = case x of (Int# i) -> case y of (Int# j) -> Int# (add# i j)"
14:03:30 <EvanR> so application may immediately lead to a case-like use of stack
14:03:54 <merijn> EvanR: Application of functions with patterns translates to case of
14:04:26 <monochrom> the exciting part is that foldl (+) gives you ((...) + 99) + 100. the top level is (...)+100. you are none the wiser.
14:04:46 <merijn> "foo (Just x) = {- ... -}; foo Nothing = {- ... -}" translates to "foo = \newName -> case newName of (Just x) -> {- ... -}; Nothing -> {- ... -}"
14:05:05 <shapr> 99 foldls on the wall 99 foldls! take one down, eval the thunk, 98 foldls on the wall!
14:07:04 <EvanR> so in my example since im not doing pattern matching i would just create a bunch of thunks, its not going stack overflow
14:08:16 <EvanR> let x = recurse in let y = recurse in x <> y
14:08:39 <EvanR> does this translate to a case...
14:08:54 <merijn> EvanR: What's the type of 'x'?
14:09:07 <EvanR> list of a
14:09:20 <mauke> @src (++)
14:09:20 <lambdabot> []     ++ ys = ys
14:09:21 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:09:21 <lambdabot> -- OR
14:09:21 <lambdabot> xs ++ ys = foldr (:) ys xs
14:09:28 <merijn> EvanR: Then <> is just ++, which pattern matches
14:09:34 <mauke> ... on the left arg
14:09:40 <EvanR> oh right, its evaluating the body first
14:10:04 <merijn> EvanR: Which will call recurse, which pushes the exact same pattern again, etc.
14:10:22 <merijn> Assuming this let is the return value of recurse
14:10:38 <merijn> Which means you are, indeed, infinitely pushing case matches on the stack :)
14:10:54 <merijn> Presumably because your stop-condition on recurse is broken
14:10:56 <EvanR> gross
14:10:59 <Ohso_> I'm looking for some help taking a concept in C# and implementing it in Haskell.  I have a class in a library that takes an interface with one method during construction. When a certain state exists in the library, the interface method is called and some IO is performed. I want to keep the library totally ignorant of any concrete IO implementation. How would I accomplish this in Haskell without contaminating my library with IO all over the place
14:11:29 <merijn> Ohso_: What kind of IO are you performing?
14:11:57 <merijn> Ohso_: For example, is it like "an IO operation that reads a string from some source" (socket, file, stdin, etc.)
14:12:34 <Ohso_> Could be file or screen output...I don't want the library to care it it is a console app, grpahical, web based, or even just ignoring the IO.
14:13:17 <dmj`> sounds like you want a DSL
14:13:22 <merijn> Ohso_: So...why not simply take "IO String" as argument when initialising?
14:13:39 <merijn> Or "IO whateber"
14:14:04 <merijn> Ohso_: The use can just pass "readLine" as input, or "readSocket someSocket" or....
14:14:16 <merijn> Ohso_: Remember, IO is a first class value in Haskell :)
14:15:29 <thomasd> hey guys, quick question, what's the diff between Control.Monad.<module> and Control.Monad.Trans.<module> ?
14:15:43 <thomasd> for instance, Control.Monad.Trans.Except vs Control.Monad.Except
14:15:53 <Clint> could be mtl vs. transformers
14:15:55 <Clint> could be something else
14:15:58 <monochrom> this does not have a quick answer.
14:16:07 <thomasd> ok, well, what is better to use
14:16:08 <monochrom> but one has a type class, another doesn't.
14:16:09 <thomasd> or does it matter
14:16:33 <hsk3> In this image: https://s3.amazonaws.com/f.cl.ly/items/0m1y1I0Q1U0A0r0n1w01/pic.png?v=ed34185c
14:16:34 <hsk3> I don't understand (lift . lift). Why are we lifting twice?
14:16:35 <hsk3> What are the types of those two lift functions?
14:16:35 <merijn> thomasd: The .Trans. versions are from transformers, the ones without are from mtl
14:17:01 <hsk3> In general, we have lift :: (Monad m, MonadTrans t) => m a -> t m a
14:17:07 <merijn> thomasd: mtl is a wrapper library that performs auto-lifting for the things in Transformers
14:17:13 <merijn> :t lift . lift
14:17:15 <lambdabot> (Monad m, Monad (t1 m), MonadTrans t, MonadTrans t1) => m a -> t (t1 m) a
14:17:40 <merijn> thomasd: So mtl is re-exporting transformers and adding some typeclasses for "magic" lifting
14:18:01 <merijn> thomasd: So if you don't use that, use the .Trans. versions, so you only depend on transformers and not mtl
14:18:18 <hsk3> merijn: I'm confused because that code is run within the second do-block, which is only for the MaybeT ActionM monad. Can't I view that block in isolation?
14:18:31 <hsk3> And only MaybeT is the monad transformer
14:18:34 <monochrom> hsk3: it seems one is for MaybeT, another is for scotty. and one liftIO could replace the two at once.
14:18:34 <hsk3> there is no other monad transformer..
14:18:36 <simpson> davidkart: Sorry, I was busy. Anyway, PyPy exists and is a thing. It is quite speedy.
14:19:14 <monochrom> if you ask me why the author writes like that, answer: I am neither the author nor telepathic.
14:19:22 <thomasd> ok, so is it basically a difference in style?
14:19:34 <hsk3> monochrom: well he does liftIO above. It's just demonstration purposes i guess. I'm just trying to understand the types that's all..
14:19:35 <merijn> thomasd: double lift instead of liftIO is dumb
14:19:53 <merijn> thomasd: liftIO is just a typeclass that automagically figures out how many lifts you need
14:20:04 <thomasd> yeah I agree
14:20:08 <Cale> (assuming that you're transforming IO)
14:20:14 <merijn> thomasd: One lift to go from IO to "ActionM" and one to go from that to "MaybeT ActionM"
14:20:18 <merijn> Cale: Obviously :)
14:20:37 <hsk3> merijn: but ActionM is not a transformer. it's a monad..
14:20:38 <dolio> It can also lift into things that aren't bare transformers.
14:20:42 <hsk3> oh
14:20:45 <merijn> hsk3: Are you sure?
14:20:47 <Clint> hsk3: type ActionM = ActionT Text IO
14:20:48 <MichaelBurge> hsk3: Look in Web.Scotty.Trans
14:20:57 <thomasd> so with mtl you have to use as many lifts to get to the right monad in your stack, and with trans you can just do "lift" and it'll figure it out?
14:20:57 <thomasd> or no
14:21:05 <Cale> Also you might actually have some monad which supports liftIO but which is not defined using a monad transformer, so you couldn't use lift then.
14:21:25 <Cale> e.g. if you rewrote your monad directly rather than in terms of transformers
14:21:26 <merijn> thomasd: Other way around, and not so much "lift" but things like "get :: MonadState s m => m s"
14:21:43 <merijn> thomasd: Which basically does "{- some number of lifts -} $ get"
14:21:46 <thomasd> ok cool
14:21:53 <thomasd> so transformers has magic
14:21:57 <thomasd> typeclass magic
14:22:00 <Clint> no, mtl does
14:22:01 <merijn> thomasd: No, mtl has the magic typeclasses
14:22:03 <thomasd> dammit
14:22:09 <merijn> thomasd: Transformers just has newtypes
14:22:09 <thomasd> right
14:22:19 <thomasd> ok, so mtl for less code 
14:22:32 <thomasd> and less explicit lifting
14:22:58 <thomasd> thanks for all the help!
14:23:03 <hsk3> ok I get it now
14:23:04 <hsk3> thanks guys
14:23:12 <hsk3> ActionT Text is the transformer
14:23:18 <hsk3> that is lifted over first
14:23:20 <hsk3> then MaybeT
14:24:09 <hsk3> Do Haskell programmers usually know these things intuitively, or is it more the case that they just use liftIO without worrying about it too much?
14:24:35 <monochrom> neither. I look at the types.
14:24:46 <merijn> hsk3: Well, it's just a matter of "lift only works work for transformers, so "ActionM" *must* be a transformer"
14:24:48 <Ohso_> Hmm, Not sure how to implement that. In C# my library just calls a void method with some argument (not always a string) and moves on. If I pass an IO String into my library, how does that call anything?
14:25:05 <merijn> hsk3: It doesn't LOOK like a transformer, conclusion: It must be a type alias
14:25:28 <monochrom> all false-dichotomy questions can be answered by a trichotomy answer.
14:25:38 <merijn> hsk3: Then you look at the haddocks and see what it is :)
14:25:51 <Cale> Ohso_: sorry, what?
14:26:24 <Cale> hsk3: liftIO always turns an IO action into whatever monad you happen to be using (supposing that it's actually an instance of MonadIO)
14:26:46 <lpaste_> tippenein pasted “getting Pipes type sigs correct” at http://lpaste.net/164400
14:26:46 <Cale> hsk3: There's usually exactly one way to do that, so you usually don't worry about the details.
14:27:07 <Cale> into an action of whatever monad you're using*
14:27:29 <hsk3> yeah
14:27:32 <tippenein> I'm looking for some Pipe's tips for the type sigs.  I think the functions are close
14:27:59 <hsk3> Thanks guys
14:28:18 <Cale> Ohso_: Is a "void method" one which returns void?
14:28:26 <merijn> tippenein: What's the problem?
14:29:24 <tippenein> I'll edit it with the type errors I'm getting, one sec
14:29:37 <Cale> Ohso_: If you pass an IO String action as an argument to some function, an IO action which that function constructs may or may not execute the action, and may execute it as many times as it likes.
14:29:40 <Ohso_> It's like this:  I have an exceutable that references a library. The executable is the UI and handles all IO, while the library is the logic. I have a method in the exe that I pass to the library as a delegate basically to say "Let me know when 'X' happens".  When that happens the exe decides what to do with it, print something, write something to disk, make a sound, whatever. The library should not know anything about IO at all.
14:30:19 <Ohso_> void returns nothing
14:30:21 <merijn> Ohso_: I usually have a Chan where I have the UI "post" events and the backend blocking until the Chan gets an event
14:30:35 <lpaste_> tippenein revised “getting Pipes type sigs correct”: “getting Pipes type sigs correct (/w errors)” at http://lpaste.net/164400
14:31:07 <Cale> Ohso_: Well, if there's no IO, there's effectively no notion of "when"
14:31:12 <hsk3> came across this. not for me. maybe some of you guys: https://careers.bloomberg.com/job/detail/49844
14:31:13 <tippenein> merijn: basically, I wrote the types out as I expected them to be, and I've been shuffling them around based on what the type checker is telling me it thinks it should be
14:31:22 <Cale> Ohso_: Or, you would need to impose some notion of what time means.
14:31:30 <tippenein> it seems like an unsolvable rubiks
14:31:40 <tippenein> but that's just because I don't know what I'm doing
14:33:03 <merijn> tippenein: I think you have an error on line 22
14:33:10 * hackagebot microlens 0.4.4.0 - A tiny part of the lens library with no dependencies  https://hackage.haskell.org/package/microlens-0.4.4.0 (Artyom)
14:33:19 <merijn> tippenein: I don't see how second could possibly work there
14:33:32 <Cale> Ohso_: Pure Haskell evaluation basically reduces expressions to the values which they represent, and it obtains the same result independently of which order it's carried out in. That order is not normally observable, though there are sneaky things you can do to spy on the runtime system.
14:33:46 <merijn> :t second . T.split ((==) '\t')
14:33:47 <lambdabot>     Not in scope: ‘T.split’
14:33:47 <lambdabot>     Perhaps you meant one of these:
14:33:47 <lambdabot>       ‘S.split’ (imported from Data.Set),
14:33:55 <merijn> :t second . Data.Text.split ((==) '\t')
14:33:56 <lambdabot>     Couldn't match type ‘[]’ with ‘a b’
14:33:56 <lambdabot>     Expected type: Data.Text.Internal.Text
14:33:56 <lambdabot>                    -> a b Data.Text.Internal.Text
14:34:14 <Cale> Ohso_: On the other hand, execution of IO actions has a definite order to it, and is carried out in steps.
14:35:06 <merijn> tippenein: mapper takes Text as inputs and maps "second . T.split ((==) '\t')" over those, but that function doesn't take Text as input?
14:35:20 <Cale> Ohso_: One thing you can do if you want the library to express that there are a bunch of steps, but that there really aren't any meaningful I/O effects is to produce an action of an arbitrary monad m
14:35:41 <Cale> i.e. (Monad m) => m () -> m Result
14:35:55 <Cale> where the m () is your "callback"
14:36:06 <tippenein> merijn: actually that's one of the pieces that does work. If I do getInputFiles >-> mapper >-> Text.stdout  I get a valid stream of Text
14:36:38 <Cale> Or (String -> m ()) or whatever
14:37:13 <Cale> Then your IO-using executable can pass in something like putStrLn to print things out
14:37:14 <merijn> tippenein: Well, colour me completely confused how that works, then
14:37:22 <monochrom> it is an excellent exercise in applying free theorems to prove that a thing of type "(Monad m) => m () -> m Result" is going to be equivalent to "return x" for some x::Result.
14:37:43 <Cale> monochrom: That's not true.
14:37:45 <hpc> well
14:37:56 <merijn> tippenein: oooh...duh
14:37:56 <hpc> foo m = m >> m >> m >> m >> return x
14:37:57 <Ohso_> I'm really new to Haskell and trying to do things without resorting to "do" everywhere to imitate what I'd write in C#, but I'm afraid my choice of a first program is a doozy of a collection of mutable state, IO operations, and bit twiddling. I've been writing what I think is a pretty clean library so far (haven't gotten to the hard bits yet), but now I see horrific images of IO having to be applied all over the place and to virtually every func
14:37:59 <Ohso_> tion.  :(
14:38:07 <monochrom> oh, I see.
14:38:16 <merijn> Ohso_: Don't worry, IO isn't necessarily bad
14:38:22 <hpc> if you just had Monad m => m Result though...
14:38:33 <merijn> Ohso_: I write lots of server code, which is basically all imperative code with IO everywhere
14:38:40 <merijn> Ohso_: Some problems are just like that
14:38:42 <tippenein> second . T.split ((==) '\t') :: Text -> Text
14:39:01 <merijn> Ohso_: UI is also just naturally IO heavy
14:39:13 <Cale> Ohso_: Well, anything whose job is actually pure should probably be pure, or at least have a pure function associated with it (which you can then wrap in something which additionally writes to a log file or does one of these I/O callback-y type things if you like)
14:39:18 <merijn> Ohso_: Don't try to avoid IO at all cost
14:39:29 <hpc> Ohso_: basically, write things as you normally would and if a thing has to interact with the world so be it
14:39:34 <monochrom> well then, it is an excellent exercise to prove that it is equivalent to "replicateM_ n m >> return x" for some n, for some x.
14:39:45 <Cale> monochrom: right :)
14:39:55 <monochrom> however, x is going to be constant
14:40:12 <merijn> Ohso_: And actually writing IO heavy code in haskell is actually pretty nice, hence why people say "Haskell is my favourite imperative language" :)
14:40:25 <hpc> i say that!
14:40:34 <Cale> I do as well
14:40:35 <merijn> Me too :p
14:40:45 <hpc> i also say perl is my favorite functional language though
14:41:20 <monochrom> Haskell is my favorite Haskell language
14:41:32 * Clint claps.
14:41:36 <Cale> GHC is my favourite Haskell language
14:43:11 * hackagebot microlens-ghc 0.4.4.0 - microlens + array, bytestring, containers, transformers  https://hackage.haskell.org/package/microlens-ghc-0.4.4.0 (Artyom)
14:43:13 <hpc> javascript is my favorite lisp
14:43:30 <Clint> LOGO
14:44:13 <Ohso_> I just don't see how to avoid the IO ending up on virtually every single method, even the ones not doing any IO, simply because they really need to be in a collection of functions with the same signature.
14:44:17 <Cale> javascript is my favourite assembler
14:44:39 <Cale> Ohso_: Well, IO-things can use non-IO-things just fine
14:44:44 <merijn> Ohso_: Can you give an example of a function that you have this problem with?
14:46:17 <Cale> Yeah, it would help to have some more concrete information about the problem :)
14:46:28 <Ohso_> It's a bytecode interpreter. Opcodes are implemented as functions and are grouped by the number of operands thay take. Some of them do IO, other don't. Some handle input, some output, some both, and some neither.
14:46:47 <merijn> Ohso_: Can you lpaste some examples?
14:48:09 <Ohso_> Not really. Still in the early stages of writing it. Only have the vm' memory working, but my initial foray into opcodes has hit this wall. In C#, the opcodes are all of type void and just call any callbacks on the UI as needed.
14:48:11 * hackagebot microlens-platform 0.3.1.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.3.1.0 (Artyom)
14:48:26 <hpc> Ohso_: in that case, it might be convenient to have the actions for every opcode have the same type
14:49:28 <Ohso_> have them all have the same type? What would that look like?
14:49:38 <hpc> maybe like
14:49:44 <merijn> Ohso_: That's hard to say without some example opcodes :)
14:49:52 <hpc> data Opcode = Print String | Add Int Int | ...
14:50:01 <hpc> and then execute :: Opcode -> IO something
14:50:10 <hpc> as an extremely basic example
14:52:45 <Ohso_> Hmm, maybe. Is it realistic to think that this unified type might have 100 unique constructors? Is that reasonable?
14:53:20 <hpc> possibly
14:53:47 <hpc> maybe some of your vm opcodes would translate to some combination of the others
14:54:14 <hpc> this is a pretty common technique, even intel does it on their processors now
14:54:39 <Ohso_> I can think of around 50 off the top of my head that would have no overlap.
14:55:10 <hpc> in any event there's not a technical limit you would bump into, and it might make sense that way
14:55:21 <hpc> i can think of a few types with many more constructors
14:55:44 <Ohso_> ok, cool. Wasn't sure if that would run into a limit of some kind.
14:56:00 <Cale> You can always factor the type a bunch into smaller types that have to do with specific subunits or whatever.
14:56:11 <hpc> you might find yourself very quickly wanting to define a set api for your opcodes, so you don't have to write 50 lines for every manipulation
14:56:16 <hpc> but then that's just good design anyway :D
14:56:39 <merijn> hpc: Uh...
14:56:50 <Cale> It's generally a good idea to avoid types which either have too many constructors or too many record fields if possible.
14:56:57 <merijn> hpc: There's a technical limit in that GHC doesn't really handle HUGE datatypes well :p
14:57:08 <Cale> If you have any way of structuring things further in a logical way, it's probably a good idea.
14:57:19 <hpc> my understanding was that huge = more than 3 constructors?
14:57:38 <hpc> or if not that, some number that 50-100 is less than
14:58:13 <Cale> I *have* actually worked with a data type for PPC/Altivec operations, and it went okay, but if I did it again today, I'd probably break it up into smaller types.
14:58:20 <hpc> but yeah, factoring out parts of the instruction set anyway is a good idea
14:58:25 <carter> You probably should use some sort of ... Data structure like an array or map once you have more than 20-30 fields, and even that's on the big side
14:58:55 <carter> But some codes definitely fall over in terms of how deriving works
14:59:42 <carter> Cale: probably more importantly : never use read instances for any data type with infix constructors
14:59:57 <thoughtpolice> hpc: The '3' value probably refers to the amount of tag bits GHC can use for picking the constructor. On a 32-bit machine, pointers are aligned on a word size, so you only get two bits, and thus 3 possible states you can use. But separately from that there are some compile-time problems GHC has with very-super-large data types.
15:00:09 <Cale> carter: Because you'll have to think about how readsPrec works?
15:00:16 <thoughtpolice> Unrelated to whatever pointer tagging nonsense is going on.
15:00:46 <carter> Cale because there's a quadratic bug in read for infix constructors currently :(
15:00:52 <Cale> oh, fun
15:01:05 <carter> thoughtpolice: where's the ticket for that ?
15:01:14 <carter> I'm derped atm
15:01:39 <carter> Also my brain is full with ideas for better ssl and aws libs atm
15:01:44 <thoughtpolice> Well, it's more like there are some vague corner cases that are exacerbated by really large data types. For users the edge cases might be so common as to appear indistinguishable, though.
15:01:58 <thoughtpolice> Like the Read thing, which is known to generate stupid amounts of code and take stupid amounts of time.
15:02:26 <obadz> let { !(I# x#) = maxBound :: Int; !(I# y#) = 1 :: Int } in addIntC# x# y#
15:02:29 <thoughtpolice> Or this Generic thing that has proven to be quite problematic with some kind of quadratic explosion in the number of constructors, somehow compounded by dictionaries not being eliminated, etc.
15:02:33 <obadz> getting: Illegal unboxed tuple type as function argument: (# Int#, Int# #)
15:02:55 <merijn> obadz: Add a space before the closing ) ?
15:03:19 <merijn> obadz: I thik it's parsing #) as closing for an unboxed tuple, instead of "x#" followed by )
15:03:43 <merijn> obadz: Or simply use x/y instead of x# and y# as names
15:04:34 <obadz> merijn: still getting same error. attempted both.
15:04:52 <merijn> obadz: Paste the exact code on lpaste?
15:05:00 <obadz> that is the exact code
15:05:02 <obadz> (am in repl)
15:05:11 <obadz> let { !(I# x)  = maxBound :: Int; !(I# y) = 1 :: Int } in addIntC# x y
15:05:24 <merijn> obadz: Did you enable MagicHash?
15:05:26 <obadz> yes
15:05:37 <obadz> and imported GHC.Types, GHC.Prim, GHC.Num
15:06:35 <merijn> obadz: Oh
15:06:58 <hpc> have you tried turning it off and on again?
15:07:08 <merijn> addIntC returns an unboxed tuple which is only legal if you immediately unpack it using let
15:07:23 <obadz> ah
15:07:25 <obadz> thanks :)
15:07:30 <merijn> λ :t addIntC#
15:07:31 <merijn> addIntC# :: Int# -> Int# -> (# Int#, Int# #)
15:07:48 <merijn> That returns an unboxed tuple (as it says), but unboxed tuples aren't "real" values
15:07:53 <thoughtpolice> In GHCi that's probably because it's trying to 'print' the result of that expression and failing because the result of addIntC# is an unboxed tuple. So you have to re-box it.
15:08:00 <thoughtpolice> Also you can't use unboxed types in GHCi
15:08:14 <thoughtpolice> A compiling example would be something like: let { !(I# x#) = maxBound; !(I# y#) = 1; } in case addIntC# x# y# of (# nx#, ny# #) -> ( I# nx#, I# ny# )
15:08:30 <thoughtpolice> Which has type (Int, Int)
15:09:00 <obadz> thoughtpolice: do I need to import something to get (# #) ?
15:09:10 <thoughtpolice> Use -XUnboxedTuples
15:09:39 <thoughtpolice> Er, also, I misspoke earlier.
15:09:50 <obadz> ok thx, yeah doesn't work in ghci
15:09:51 <thoughtpolice> GHCi can handle unboxed types of several kinds. But it cannot handle unboxed tuples specifically.
15:10:00 <thoughtpolice> So, anything using unboxed tuples there is off limits (because reasons)
15:10:03 <obadz> Error: bytecode compiler can't handle unboxed tuples.
15:10:22 <merijn> obadz: He just said that :)
15:10:32 <hpc> man, we have got to come up with another word for "classification of things" that isn't type, kind, or sort
15:10:43 <hpc> because my immediate first thought was "all unboxed types are of kind #"
15:11:00 <merijn> hpc: All types of unboxed values are of kind #
15:11:09 <hpc> er, that
15:11:14 <merijn> Well, I guess that's not actually true in GHC 8? :p
15:11:20 <hpc> :k Int#
15:11:21 <lambdabot>     Not in scope: type constructor or class ‘Int#’
15:11:21 <lambdabot>     Perhaps you meant one of these:
15:11:21 <lambdabot>       ‘Int’ (imported from Data.Int), ‘Int8’ (imported from Data.Int)
15:11:26 <merijn> levity polymorphism, etc.
15:11:26 <hpc> ah right
15:11:48 <hpc> i only just got truly comfortable with type families too lol
15:11:56 * hpc is so far behind the curve
15:12:18 <merijn> hpc: levity polymorphism isn't too hard
15:12:57 <merijn> hpc: It's just "boxed-ness polymorphic kinds" for non-return types of functions (contravariant types? I dunno)
15:13:44 <hpc> http://stackoverflow.com/questions/35318562/what-is-levity-polymorphism/35320729
15:13:52 <hpc> not too bad i think
15:15:10 <merijn> hpc: When you get comfortable with kinds (and a basic bit of type families) levity polymorphism is actually pretty obvious, imo :)
15:15:12 <hpc> it feels kind of agda-y
15:15:36 <hpc> yeah, i am quite comfortable with kinds
15:16:09 <merijn> hpc: I meant "you" as unspecified person trying to understand them, not YOU specifically ;)
15:16:15 <hpc> :P
15:16:57 <obadz> thx thoughtpolice 
15:23:40 <maerwald> merijn: isn't it also common in english to say "one" instead of "you" in that case?
15:24:24 <geekosaur> sadly there is not a lot of consistency there 
15:24:32 <geekosaur> (well, of course, it's english)
15:24:41 <geekosaur> generic :you" is fairly common
15:25:13 <EvanR> dude... gloss rotate function is in degrees, and rotates clockwise. 
15:25:19 <EvanR> and i have a rotation matrix
15:26:06 <EvanR> acos dot, and asin cross.z arent enough to get this angle
15:26:50 <EvanR> maybe i can combine them
15:28:13 * hackagebot hdocs 0.5.0.0 - Haskell docs tool  https://hackage.haskell.org/package/hdocs-0.5.0.0 (AlexandrRuchkin)
15:28:15 * hackagebot simple-log 0.4.0 - Simple log for Haskell  https://hackage.haskell.org/package/simple-log-0.4.0 (AlexandrRuchkin)
15:33:13 * hackagebot hformat 0.1.0.1 - Simple Haskell formatting  https://hackage.haskell.org/package/hformat-0.1.0.1 (AlexandrRuchkin)
15:33:15 * hackagebot text-region 0.1.0.1 - Marking text regions  https://hackage.haskell.org/package/text-region-0.1.0.1 (AlexandrRuchkin)
15:39:07 <EvanR> alpha = acos (u `dot` v), beta = asin (k (u `cross` v)), if signum beta is zero then alpha else alpha * signum beta
15:39:25 <EvanR> or just let me use a rotation matrix D:
15:44:07 <monochrom> I support rotation matrices
15:54:39 <Jinxit> yes homo
15:54:47 <Jinxit> geneous
16:00:38 <thoughtpolice> gridaphobe: Is there any interactive place to discuss Liquid Haskell stuff? I have a weird question I'm not sure how to answer.
16:01:54 <gridaphobe> thoughtpolice: there's #liquidhaskell. it's pretty quiet, but i'm there :)
16:02:45 <thoughtpolice> Thanks, will ask there.
16:08:35 <pavonia> When you have an attoparsec parser like "foo <|> foobar" where foo is a prefix parser of foobar, is there another way of making the parser accept the longer input than rearranging the order of the parser alternatives?
16:10:19 <kadoban> You could do  foo >> optional bar  I guess?
16:11:38 <glguy> pavonia: attoparsec doesn't backtrack once one of the alternatives succeeds. I don't think you can force it to
16:12:32 <pavonia> Okay. Factoring looks like a good idea, though
16:16:59 <dfeuer> GRRRRRRR
16:17:23 <dfeuer> I'm fighting the bloody inliner *all the way*. I removed an "irrelevant" function, and that totally screwed up performance.
16:17:47 <dfeuer> I could really use some help.
16:23:15 * hackagebot hsdev 0.2.0.0 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.2.0.0 (AlexandrRuchkin)
16:31:58 <rfw> hi, is it possible to have a list of items of a given typeclass (easily)?
16:32:11 <rfw> i know you can funge around with GADTs and ExistentialQuantification but is there a less clunky way?
16:32:38 <rfw> (as in, data Fooable where Foo a => a -> Fooable or something)
16:33:21 <geekosaur> not really and it's "cllunky" for a reason
16:33:28 <rfw> :(
16:33:43 <geekosaur> remember that the only things you could do with it are things available via the typeclass
16:33:55 <rfw> does it mean i'm solving my problem in the wrong way?
16:34:53 <geekosaur> sometimes. sometimes it's the only real option and for that case there's things like HList (but if you think existential wrappers are clunky...)
16:36:41 <S11001001> geekosaur speaks the truth rfw, srsly
16:37:27 <rfw> ah, it turns out existential wrappers don't even do what i want to do, since i can't derive Eq for the wrapper
16:37:32 <rfw> which makes sense
16:53:46 <newcomer> So I have a question about undefined and error. Can I think of them as data constructors summed (as in sum type) to every type in existence?
16:54:14 <newcomer> can I think of bool as "data Bool = True | False | undefined | error String"?
16:55:18 <monochrom> for some purposes yes
16:55:36 <monochrom> for some other purposes you would not distinguish undefined from error "xxx"
16:55:45 <monochrom> and for some yet other purposes no.
16:56:02 <geekosaur> and, undefined is not something you can test for
16:57:34 <newcomer> so why aren't they capitalized? are they nullary constructors or nullary functions?
16:58:05 <monochrom> because of the "no" purposes.
16:58:23 <geekosaur> they are neither
16:58:38 <newcomer> what are they then?!
16:58:39 <geekosaur> they are non-values
16:58:59 <monochrom> now that gets philosophical
16:59:04 <kadoban> :t undefined
16:59:05 <lambdabot> t
16:59:32 <geekosaur> they are some form of nontermination. some of those are things you can catch (e.g. error and *explicit* undefined throw exceptions which you can catch in IO), some of them are not...
16:59:37 <geekosaur> :t let a = a in a
16:59:39 <lambdabot> t
16:59:47 <geekosaur> ^ this never terminates
17:00:08 <geekosaur> you can't catch that, *some* kinds of infinite loops can be detected, many cannot
17:01:11 <newcomer> is there a significance in calling the type variable "t" as opposed to "a"?
17:01:18 <geekosaur> nope
17:02:26 <geekosaur> the only relevant thing about it is that it is a type variable that's not in use, indicating that it can have any type... because it never produces a result
17:05:52 <newcomer> I'm more confused now than before coming in :) But that's OK. You thankfully tried to explain.
17:08:43 <newcomer> I have a technical question about behavior differences between ghci and runhaskell.
17:09:07 <newcomer> in ghci I can just "let g = liftA2 (+)".
17:09:25 <newcomer> for some reason, runhaskell won't let me do that.
17:10:48 <newcomer> It complains about not knowing how to infer the type of "liftA2 (+)" from all the instances of Applicative.
17:11:22 <newcomer> shouldn't it give me a polymorphic function with Applicative type constraint?
17:12:07 <kadoban> newcomer: It only does that if you give it a type signature that says so. If it can infer exactly what Applicative you mean, it'll do that instead.
17:12:47 <newcomer> kadoban, so if I give it a polymorphic type signature it'll accept it?
17:13:10 <kadoban> newcomer: Yep
17:13:48 <newcomer> kadoban, oh, thanks, that worked.
17:14:29 <newcomer> but yet again, I had ghci help me figure out the type signature.
17:14:43 <newcomer> why is that runhaskell behaves as such?
17:16:12 <kadoban> newcomer: IIUC it doesn't like guessing that things are too polymorphic, because it turns out that for performance reasons that's a really bad default. So unless it can tell what monomorphic type it should be (either by context or by defaulting rules), it bails out and you have to tell it.
17:23:26 <newcomer> kadoban, OK, that makes sense. Thanks.
17:25:42 <fishythefish> newcomer: note also that some versions of GHC will also complain (my server at work only has 7.6.3 on it at the moment)
17:25:57 <fishythefish> e.g. 'No instance for (Applicative f0) arising from a use of `liftA2''
17:26:43 <newcomer> fishythefish, yeah, my 7.8.4 doesn't complain.
17:27:06 <fishythefish> newcomer: yeah, that sounds right
17:27:08 <newcomer> I guess if performance was the reason, allowing it in the REPL is not a big deal.
17:28:14 <newcomer> fishythefish, are you the guy behind the fishy monad tutorial? :)
17:29:39 <fishythefish> newcomer: nope :)
17:29:44 <fishythefish> wasn't aware that was a thing until you mentioned it
17:29:51 <fishythefish> but there are so many analogies for monads out there
17:30:06 <newcomer> yes, burritos being one of them :)
17:30:13 <fishythefish> that one's my favorite ;)
17:30:40 <newcomer> Now that monads are mentioned. I have a question about functors, applicative and monads.
17:30:48 <fishythefish> Go for it
17:32:10 <newcomer> I understand that all applicatives are functors and that you can define fmap using <*>. I'm still to find the connection between monads and applicatives. can you define <*> using >>=?
17:32:50 <fishythefish> Yeah, you can define the applicative interface using just the monad interface, and define functor in terms of applicative
17:32:58 <fishythefish> (it's a good exercise)
17:33:29 <monochrom> mf <*> mx = mf >>= \f -> mx >>= \x -> return (f x)
17:33:48 <fishythefish> or wait for someone to answer, I suppose :P
17:33:51 <newcomer> monochrom, let me copy that and contemplate on it :)
17:34:21 <fishythefish> Note that monads necessarily define return, not just >>=
17:34:44 <monochrom> I need either return or fmap
17:34:54 <newcomer> fishythefish, oh yes, and applicative defines pure not just <*>.
17:35:23 <fishythefish> monochrom: yeah, but I think he's focusing on going from monad to applicative, so I'd go with the implementation you wrote above
17:36:38 <orb_> Is there an existing data type like this (with all the instances etc defined): data AddBound a = LowerBound | Value a | UpperBound deriving (Ord) ?
17:38:34 <tomleb> I'm getting this error when trying to `cabal build`. Compilation works, the linking itself doesn't.undefined reference to `bmShazu94Iqa29WhGH3S03JkODmLw_Api_User_static_info'
17:38:37 <tomleb> collect2: error: ld returned 1 exit status
17:38:53 <newcomer> monochrom, now that was easy. Thanks for choosing sensible parameter names.
17:39:07 <monochrom> :)
17:39:30 <newcomer> every monad tutorial should include the transition from monad to applicative and from applicative to functors.
17:39:56 <newcomer> I guess now that I barely scratched the surface of monads I'll go write myself a tutorial :)
17:40:21 <fishythefish> newcomer: I take it you've heard the words "monad tutorial fallacy" already?
17:40:29 <newcomer> fishythefish, sure :)
17:40:31 <roboguy`> tomleb: Are you using a library that you made?
17:40:44 <maerwald> the best monad tutorials are the ones that are not tutorials, but just explain the _class_
17:41:22 <monochrom> you need a fairly recent book or tutorial for that. since Applicative is a fairly recent addition. (approx 5-7 years. but you know how slowly authors catch up.)
17:41:44 <monochrom> (in fact you know how most books and tutorials finished writing 7 years ago)
17:41:52 <fishythefish> monochrom: older ones will likely still point out that you can derive functor from monad
17:42:15 <tomleb> roboguy`: Yeah
17:42:48 <roboguy`> tomleb: In that library, do you have all of your modules exposed in the exposed-modules section of the .cabal file?
17:43:00 <newcomer> so that's why Applicative has Functor as type constraint while Monad doesn't have Applicative in it's type constraint?
17:43:10 <roboguy`> In my experience, that error is usually caused by missing modules in that section
17:43:11 <EvanR> when i went looking for monad tutorials, i really needed to understand ADTs and type classes in general
17:43:14 <fishythefish> orb_: unsure, but is the Bounded typeclass insufficient for you?
17:43:22 <monochrom> right. except for recent base.
17:43:23 <fishythefish> newcomer: it does now
17:43:25 <tomleb> roboguy`: Oh, no I don't think I have
17:43:29 <tomleb> roboguy`: I'll try this
17:43:31 <fishythefish> that's the AMP (applicative monad proposal)
17:43:36 <orb_> For artificial / free lowerbounds I use: Maybe a.
17:43:46 <orb_> (And Nothing compares LT to any Just.)
17:43:56 <orb_> I wanted something that has dummy elements in both directions.
17:44:11 <fishythefish> orb_: ah, I see
17:44:20 <fishythefish> orb_: can't think of anything off the top of my head
17:44:35 <orb_> OK.  I'll just introduce it myself, then.
17:44:42 <fishythefish> newcomer: basically, functors were known about for a long time, then monads were added to make IO work (with functor as a constraint)
17:44:53 <fishythefish> newcomer: it wasn't until later that it was pointed out that applicatives could fit in between
17:45:01 <orb_> fishythefish: basically, this constructs a `free' Bounded for any type.
17:45:14 <monochrom> No, actually Monad did not have a Functor assumption for a long time.
17:45:16 <EvanR> eh, monads were added at the same time as IO ?
17:45:28 <fishythefish> monochrom: didn't know that, but not surprised
17:45:30 <EvanR> imagine haskell without monads ;)
17:45:41 <EvanR> (please)
17:45:42 <roboguy`> orb_: I don't think there's anything in the standard library but that lattices package has that
17:45:45 <geekosaur> main :: Response -> Request
17:45:45 <roboguy`> https://hackage.haskell.org/package/lattices-1.5.0/docs/Algebra-Lattice-Levitated.html#t:Levitated
17:45:48 <maerwald> EvanR: pretty ez, just more work
17:45:51 <nitrix> Afaik, before monads, IO was some kind of Request / Reponse mechanism.
17:45:52 <orb_> fishythefish: newcomer: People also tried arrows as another thing sor-of inbetween.  But they turned out less generally useful than Applicatives.
17:45:52 <geekosaur> er
17:46:00 <geekosaur> main :: [Response] -> [Request]
17:46:03 <monochrom> and yeah, there was a non-Monad story of IO before.
17:46:08 <geekosaur> monads are an *improvement*
17:46:13 <EvanR> right but no monads at all?
17:46:19 <monochrom> but of course Monad is lovely too
17:46:26 <fishythefish> orb_: yeah, I know about arrows, but I've only used some of the combinators as a convenience occasionally
17:46:30 <maerwald> EvanR: why is that so hard to imagine?
17:46:40 <orb_> The Clean language (talk about hard to Google!) tried linear types for IO.  That also sort-of works.
17:46:52 <monochrom> look for "Haskell 1.2" or something
17:46:58 <EvanR> maerwald: today, many people hear haskell and think monads
17:47:04 <orb_> fishythefish: everyone only ever uses &&& and *** to muck around with tuples. :)
17:47:05 <maerwald> *shrug*
17:47:09 <EvanR> out of fear or doubt
17:47:12 <fishythefish> orb_: yup, those are the ones ;)
17:47:22 <maerwald> monads are not what makes haskell a functional language
17:47:26 <orb_> EvanR: what happened to the warm fuzzy thing rebranding?
17:47:49 <orb_> People have monads in JavaScript and C++ these days.
17:47:54 <orb_> And lots of other languages.
17:48:18 <nitrix> Can you guys confirm I'm using UNPACK and ! correctly? https://github.com/nitrix/lspace/blob/master/src/Grid.hs#L16
17:48:26 <nitrix> For those three types.
17:48:31 <orb_> Or rather, they have instances of Monads, but I don't know whether they can make the compiler / interpreter recognize their similarities.  (Whenever you read flatMap somewhere, think monadic bind.)
17:49:16 <monochrom> nitrix: it is a legal use. I don't know about correct, since I don't know your requirement. but I can tell you the effect.
17:49:44 <monochrom> the effect is you get "data Leaf k v = MkLeaf (Region k) k k [v]"
17:49:48 <tomleb> roboguy`: Yup that did it, thank you a lot !
17:50:07 <roboguy`> tomleb: no problem! Hopefully they can make a more clear error message for that some day...
17:50:28 <nitrix> monochrom: Will they all end up in Grid?
17:50:43 <nitrix> monochrom: I broke it down just to keep my sanity; but I don't want the extra cost :/
17:51:04 <tomleb> roboguy`: Yeah, I don't understand most of them lol.. I instead look at the line numbers and try to figure out what's wrong most of the time
17:51:21 <monochrom> ah, they all end up in Grid, yes.
17:51:56 <roboguy`> tomleb: yeah, this isn't a ghc error message though. It's an error message from the linker (which I think is usually ld, something unaffiliated with ghc or haskell in general)
17:52:17 <monochrom> it would be nice if you could read Core. because then you have strong evidence, in addition to theory.
17:52:49 <nitrix> monochrom: I can train myself; it's something I'm definitely interested into, if I knew how to generate it easily.
17:53:12 <nitrix> monochrom: I'd be the kind the write scripts and stuff to make sure some optimizations I'm e
17:53:30 <nitrix> monochrom: -- expecting aren't disabled accidently and so on.
17:53:32 <newcomer> why is it that Applicative was recently added? wasn't it know from category theory long ago?
17:53:39 <roboguy`> HERMIT might be able to help with Core. It has a pretty printer for Core that makes in easier to read, in my opinion
17:54:24 <nitrix> roboguy`: Hermit being? A package?
17:55:17 <roboguy`> nitrix: it's a package and executable on Hackage. It's primary use is program transformation and equational reasoning
17:56:02 <roboguy`> But you can also just use it to pretty print Core
17:58:02 <fishythefish> newcomer: afaik, Applicative was introduced by http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf
17:58:13 <fishythefish> which was popularized after Monad was already in use
17:58:30 <hpc> applicative was definitely after monad
17:58:32 <fishythefish> and adding the constraint after the fact had to be done carefully to minimize breaking existing code
17:59:00 <hpc> that's correct as well
17:59:11 <roboguy`> nitrix: if you're interested and you have questions you can let me know and I can try to answer. I'm one of the people that works on HERMIT, actually
17:59:27 <hpc> the specific issue being when a type was made an instance of Monad but not Applicative
17:59:29 <nitrix> roboguy`: Noted. Very appreciated.
17:59:34 <roboguy`> Sure!
18:00:03 <hpc> there used to be a rarely used trick using a wrapper type
18:00:18 <hpc> which would rather verbosely let you use Applicative with a Monad that didn't have it
18:00:34 <hpc> all you had to do was wrap and unwrap it everywhere
18:03:19 * hackagebot simple-sendfile 0.2.24 - Cross platform library for the sendfile system call  https://hackage.haskell.org/package/simple-sendfile-0.2.24 (KazuYamamoto)
18:04:54 <roboguy`> :t 7 :: (Int :: (* :: *))
18:04:55 <lambdabot> parse error on input ‘::’
18:10:38 <monochrom> nitrix: "ghc -O -ddump-simpl -ddump-to-file -dsuppress-all Grid.hs", then look for file Grid.dump-simpl
18:11:03 <monochrom> it will be overwhelming at first. for more overwhelming, omit "-dsuppress-all"
18:11:45 <nitrix> monochrom: I'm alright with that. I've bootstrapped a programming language written in an esoteric OISC (RSSB).
18:12:08 <nitrix> Can't be worse than that :P
18:12:38 <monochrom> if you know where to look, you will see that GridLeaf, for example, takes 4 parameters, rather than 1 or 2. this is evidence that the unpacking is successful.
18:13:10 <EvanR> is there a hack somewhere to debug print anything regardless of Show instances existing or not
18:13:20 * hackagebot s-cargot 0.1.1.0 - A flexible, extensible s-expression library.  https://hackage.haskell.org/package/s-cargot-0.1.1.0 (gdritter)
18:16:46 <EvanR> i made stuff too polymorphic and suddenly i cant debug print stuff from certain places
18:17:03 <nitrix> monochrom: $WGridLeaf = @ k_a50h @ v_a50i dt_a56x ->
18:17:19 <nitrix> monochrom: I'll learn eventually :)
18:17:23 <EvanR> i guess it would work to put Show constraint on the interface data type, but thats not in vogue anymore ;)
18:18:23 <nitrix> monochrom: Oh wait,  $WMkLeaf = @ k_a50l @ v_a50m dt_a55C dt_a55D -> there you go, four.
18:18:52 <monochrom> nitrix: no no, it is not that simple.
18:19:19 <nitrix> I'm assuming the suppress-all is what's removing most of the type signatures?
18:19:29 <monochrom> if you unpack things, GHC will have to produce two versions of your constructor. why?
18:19:55 <geekosaur> EvanR, dummy Show instance that overlaps everything, and hope ghc does the right thing? (may require IncoherentInstances)
18:20:11 <dolio> Yes, why?
18:20:30 <monochrom> because nominally GridLeaf should be just as good as a function of type "Leaf k v -> Grid k v", so that "map GridLeaf [a list of Leaf's here]" is possible
18:20:54 <monochrom> so GHC needs to produce one version for that. That's $WGridLeaf
18:21:15 <monochrom> in this version, "@ k_a50h @ v_a50i" refers to the type variables k and v.
18:21:31 <monochrom> and then, there needs a second version that reflects the unpacking.
18:22:04 <nitrix> Oh!
18:22:14 <EvanR> geekosaur: interesting
18:22:49 <monochrom> so you will find and see a second version that goes "GridLeaf @k @v <4 parameters here>"
18:23:06 <nitrix> monochrom: This is obviously not that helpful yet for me, as it is very overwhelming, but I like that the name of things, including type variables, gets preserved.
18:23:17 <geekosaur> probably also requires the old OverlappingInstances extension, since almost certainly nothing is tagged {-# OVERLAPPABLE #-}
18:23:23 <geekosaur> or whatever the pragma is
18:23:25 <monochrom> in fact, $WGridLeaf calls GridLeaf. that's where you can see the 2nd version manifested
18:25:05 <monochrom> on this note, I heard a secret about SML. "map GridLeaf [a list of Leaf's here]" is not allowed. they don't auto-generate "functions that stand for data constructors"
18:25:23 <monochrom> is it SML or OCaml or some other ML? I forgot.
18:28:20 * hackagebot s-cargot 0.1.1.1 - A flexible, extensible s-expression library.  https://hackage.haskell.org/package/s-cargot-0.1.1.1 (gdritter)
18:29:19 <nshepperd_> EvanR: I would make a custom DebugPrintable class that overlaps rather than messing with Show, to prevent silliness from happening in other code that uses Show
18:32:29 <EvanR> nshepperd_: ok, and how does this thing work
18:34:05 <nshepperd_> class DebugPrintable a where { debug :: a -> String }; instance DebugPrintable a where { debug _ = "(unknown)" }
18:34:28 <nshepperd_> and then add a bunch of instances where debug = show for whatever types you need to be printing
18:37:30 <nshepperd_> but yeah this still need IncoherentInstances
18:37:33 <koz_> What Haskell library should I use to interact with an SQLite database? There's like a billion of them and I'm not sure which one I should use.
18:38:30 <nshepperd_> and you'll get the useless unknown instance if your call site is insufficiently inlined so it doesn't know what the type is
18:39:58 <sm> I think it'd be easier to ensure your types have Show instances
18:40:22 <sm> you can then use things like pretty-show, also
18:41:20 <tomleb> Why is it that sometimes I can't access module on hackage ? Let's say I'm here: http://hackage.haskell.org/package/persistent-postgresql How do I access the module's stuff ?
18:42:28 <koz_> tomleb: No documentation.
18:42:35 <koz_> (specifically, no Haddock documentation IIRC)
18:43:12 <tomleb> koz_: That is so annoying, how am I supposed to know what is inside a package ?
18:43:32 <geekosaur> tomleb, it means the documentation build failed. unfortunately, documentation is built as part of building the package normally (so it can get exact type information), and this will fail if, for example, the buildbot doesn't have necessary external libraries installed
18:44:00 <koz_> tomleb: You can read the source code from wherever it's hosted. It's a pain, admittedly, but there's not much anyone can do about that.
18:44:08 <geekosaur> In this case, either you build it locally with haddock documentation enabled, or you contact the package maintainer and ask them to build and upload the documentation separately
18:45:25 <maerwald> meh, the redundant-constraint warnings in ghc-8.0.1 are really annoying and often wrong
18:45:54 <nitrix> Is it possible to get rid of the warning generated for nearestPowerOfFour?
18:45:56 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Grid.hs#L87
18:46:04 <nitrix> Warning: Defaulting the following constraint(s) to type ‘Integer`
18:46:53 <nitrix> (Enum a0) in sequence 0.. , Integral a0 in the use of ^, Num a0 in the use of 0.
18:47:14 <monochrom> @type (^)
18:47:16 <lambdabot> (Integral b, Num a) => a -> b -> a
18:47:18 <nitrix> I'm not following. The type signature is there, it's polymorphic, it should just use whatever it's applied on.
18:47:39 <monochrom> the type of 4 is unspecified
18:48:11 <monochrom> no, the type of [0..] is unspecified
18:48:33 <monochrom> the type of 4 is nailed to the type k by inference
18:48:36 <nitrix> If I do :: [k], I get cannot deduce.
18:48:45 <nitrix> (to powers)
18:49:11 <nitrix> As if the two k's were different (which is possible because it's a where clause).
18:49:12 <EvanR> did you use forall k to bind k anwith ScopedTypeVariables
18:49:15 <monochrom> I think it's better to nail [0..] to [Int] or [Integer]
18:49:18 <nitrix> I tried ScopedTypeVariables with no success.
18:49:26 <nitrix> But I didn't have a forall, so maybe that's the issue?
18:49:41 <EvanR> yes forall is necessary to get the variables to be scoped
18:49:51 <EvanR> otherwiseit is a different k
18:49:57 <monochrom> in fact, it is best to not use "map (4^) [0..]" at all.
18:50:14 <monochrom> instead, use "iterate (4*) 1"
18:51:59 <maerwald> wow, and cabal is lying to me again
18:52:01 <nitrix> Fixed. Wee!
18:52:10 <nitrix> EvanR: A simple `forall k.` fixed it.
18:52:23 <nitrix> EvanR: Thank you <3
18:52:26 <EvanR> sucks when that is necessray but yeah
18:52:29 <monochrom> software usually lies. it's what they do.
18:53:31 <nitrix> EvanR: I'm comforting myself with the idea that it'll eventually be moved into its own library and the uglyness hidden away from the user c:
18:53:37 <nitrix> That's the spirit (:
18:53:43 <monochrom> after experiencing how editors let you "configure" the semantics of tab and come into conflict with Haskell, you ought to know
18:53:54 <maerwald> http://lpaste.net/164409 I don't see how that makes any sense
18:54:04 <maerwald> probably cabal just throwing broken error messages again
18:56:00 <monochrom> there is a chance "cabal haddock -v" may tell you more
18:56:09 <nshepperd_> oh, this doesn't seem to work, it just always picks the default instance regardless of inlining
18:56:12 <monochrom> but if it doesn't, I don't know what to do.
18:57:11 <monochrom> in theory, there is a factor you should consider. but I doubt that it matters for real.
18:57:42 <monochrom> "cabal haddock" calls up whichever haddock is found during the time of "cabal configure". not whichever haddock is found here-and-now.
18:58:22 <maerwald> yeah, I'll try clean and re-sandbox
18:58:23 <monochrom> similarly "cabal build" etc
18:58:40 <nitrix> monochrom: thanks for the iterate. Didn't know it performed better.
18:59:32 <EvanR> ^ is exponentiation by squaring by default
18:59:35 <maerwald> yeah, clean+resandbox seems to have worked
18:59:42 <EvanR> so lots of * vs one *
18:59:49 <monochrom> yeah, if you need consecutive powers, it's better to build the (n+1)th upon the nth, instead of re-computing from scratch everyone
19:00:04 <nitrix> Makes sense.
19:00:13 <nitrix> Does this gets memoized?
19:00:23 <monochrom> but if you only need a few, (^) is good
19:00:34 <nitrix> Of course I'm accessing it very naively, but would it have to recompute the list everytime throughout the program execution?
19:01:02 <monochrom> I think the list gets recomputed the next time you need the list
19:01:43 <monochrom> but during the time one such list is in use, it has internal sharing
19:02:23 <monochrom> I should actually ask GHC and read Core
19:02:45 <orb> GHC would be free to re-use the old lists.  (But problaby doesn't.)  Yeah, ask GHC.
19:03:19 <nitrix> monochrom: I feel like this would be very nice for that quadtree; it it was some kind of 'static' shared throughout the program lifetime.
19:03:22 * hackagebot unbound-generics 0.3.1 - Support for programming with names and binders using GHC Generics  https://hackage.haskell.org/package/unbound-generics-0.3.1 (AlekseyKliger)
19:03:45 <EvanR> arent CAFs shared
19:04:01 <EvanR> you can also pass the list around
19:04:09 <nitrix> Really not a big deal though. It's only computed when the datastructure grows.
19:04:42 <nitrix> EvanR: It's more of a lookup table. I don't really need to "keep it" :/
19:05:50 <nitrix> I could very well turn it into a Vector lookup for small known indices, and compute only the bigger ones if needed.
19:05:57 <nitrix> Kinda what arithmoi does.
19:07:37 <nshepperd_> my guess would be that the powers list probably isn't even stored
19:09:04 <nshepperd_> I don't really know but 'head . dropWhile f . iterate g' seems like something that could fuse
19:11:10 <nitrix> nshepperd_: The `g` is constant, only `f` changes.
19:11:42 <newcomer> liftM seems to be there for historical reasons when Applicative was not a superclass for Monad. right?
19:11:52 <nitrix> Anyway, I was just curious. It's far, far, from being a bottleneck at the moment.
19:13:22 * hackagebot roundRobin 0.1.0.1 - A simple round-robin data type  https://hackage.haskell.org/package/roundRobin-0.1.0.1 (winterland)
19:14:58 <nitrix> newcomer: Maybe there are cases where someone would want necessarily a Monad and not just an Applicative?
19:19:57 <geekosaur> newcomer, or compatibility with older versions of ghc
19:20:31 <geekosaur> (some Linux distributions are well known for slow updates...)
19:20:50 <geekosaur> but yes, it is recommended that newer code use Applicative instead
19:53:24 * hackagebot wai 3.2.1.1 - Web Application Interface.  https://hackage.haskell.org/package/wai-3.2.1.1 (MichaelSnoyman)
19:58:24 * hackagebot generic-trie 0.3.0.2 - A map, where the keys may be complex structured data.  https://hackage.haskell.org/package/generic-trie-0.3.0.2 (EricMertens)
20:15:33 <AK-47_> hi all for overclocking join ##securify and press f9 and for interpol channel go to ##beyondtime and for governor and UNITED NATIONS GO TO ##un.org , for SU FEDORA OS COME TO ##su.os
20:16:09 <Tehnix`> ?
20:16:16 --- mode: ChanServ set +o geekosaur
20:16:30 --- mode: geekosaur set +b *!*AK-47@unaffiliated/skraito-0x71
20:16:48 <geekosaur> sigh, client
20:16:55 <Tehnix`> ty, although that was a rather weird spam? 
20:17:00 --- mode: geekosaur set +b *!*@unaffiliated/skraito-0x71
20:17:24 --- kick: AK-47_ was kicked by geekosaur (AK-47_)
20:17:35 --- mode: geekosaur set -b *!*AK-47@unaffiliated/skraito-0x71
20:17:41 <Pastaf> skraito's been spamming multiple networks for quite some time now, strange guy
20:18:07 --- mode: geekosaur set -o geekosaur
20:23:25 * hackagebot servius 1.2.0.2 - Warp web server with template rendering  https://hackage.haskell.org/package/servius-1.2.0.2 (MichaelSnoyman)
20:26:30 <Buzzo> ?
20:38:26 * hackagebot fast-builder 0.0.0.6 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.0.0.6 (AkioTakano)
20:38:28 * hackagebot store 0.1.0.0 - Fast binary serialization  https://hackage.haskell.org/package/store-0.1.0.0 (MichaelSloan)
20:52:23 <orb> I had an interesting problem to solve just now: for a source code pretty printer we want to re-order lines in a source file.  We have a function that gives us a `score' for any line, lower score == earlier in the file.  Now, to make it interesting add the additional restriction that comment lines shall stay in front of the `normal' line they precede. (And multiple comment lines preceding shall stay in order.)
20:52:56 <orb> I ended up using sortBy and comparing on the tails.
20:53:26 * hackagebot edit-distance-vector 1.0.0.4 - Calculate edit distances and edit scripts between vectors.  https://hackage.haskell.org/package/edit-distance-vector-1.0.0.4 (ThomasSutton)
20:56:30 <pavonia> orb: What factors determine if a function has a low or high score?
20:56:57 <orb> Stuff like "is this an import statement?"  (They come first.)
20:57:05 <orb> I just took the scoring as given.
20:57:22 <orb> We had the system running before without comments, so I was just looking for a small change.
20:58:36 <orb> my coworker suggested something along the lines of: \a b -> if isComment a || isComment b then EQ else <re-use old compare logic>
20:58:50 <merijn> orb: Why not parse as chunks and order chunks
20:59:05 <merijn> orb: Where a chunk could be comments + line or a line?
20:59:15 <orb> That happened to work on a bunch of example he could come up with, but of course breaks when you have something like lineA > lineB, but also lineA === commenLine === lineB.
20:59:44 <orb> merijn: Yes, that would have been possible.  And we indeed do some of that chunking elsewhere.  (I was considering that, but didn't want to muck around with the data types here.)
21:01:20 <orb> I went with something like: map snd $ sortBy (comparing newScore) (zip (tails list) list); newScore = maybeToList . dropWhile isComment
21:01:48 <orb> Oops: newScore = fmap oldScoringFunction . maybeToList . droWhile isComment
21:02:28 <orb> (Only that instead of maybeToList I used: foldr (const . UpperBound) Value; with data AddUpperBound a = Value a | Upper
21:02:59 <orb> (In order to make comments at the end of file stay there.  Normal Nothing compares LT to any Just.)
21:15:50 <nut> in ghci, how to list all the packages currently loaded?
21:15:59 <DotKite> Trying to use Maybe type in a value constructor.  I keep getting errors.  Here is my code http://lpaste.net/164413
21:16:06 <DotKite> any help would be cool
21:16:32 <merijn> DotKite: Your tree type doesn't have any type parameters
21:16:38 <merijn> DotKite: Specifically, no 'a'
21:16:48 <DotKite> oh duh
21:16:49 <merijn> DotKite: Presumably you mean "data Tree a = "
21:17:01 <DotKite> thanks merijin
21:17:05 <dfeuer> LOADING. LOADING
21:20:43 <dfeuer> Yee haw! Yet another Data.Sequence.zipWith speedup!
21:24:08 <scshunt> what on earth
21:28:57 <jle`> congrats
21:29:34 <EvanR> Data.Sequence gains another level
21:29:58 <EvanR> its title is now Hallowed Adept Data.Sequence
21:30:29 <bitemyapp> @karma+ dfeuer
21:30:29 <lambdabot> dfeuer's karma raised to 5.
21:30:51 <Hrk> Could someone please suggest a way how to traverse data structure like the following JSAST? http://haddock.stackage.org/nightly-2016-05-23/language-javascript-0.6.0.4/Language-JavaScript-Parser-AST.html#t:JSAST Example user story: I'd like to be able to get All JSDecimal literals in a piece of parsed javascript code..
21:31:57 <dfeuer> bitemyapp, thanks. This iteration is purely about making nice to GHC by pulling local functions to the top level, marking them inline, and eta-expanding in one spot.
21:32:23 <dfeuer> The previous iteration was improvements to splitAt, which zipWith is the heaviest user of.
21:32:38 <dfeuer> The one *before* that was the interesting one.
21:32:55 <bitemyapp> dfeuer: those sound like fairly standard but useful things
21:33:10 <bitemyapp> dfeuer: I love what a thrill you get from doing this :)
21:34:26 <dfeuer> bitemyapp, It's an addiction, I think.
21:35:08 <dfeuer> bitemyapp, the last iteration, with the splitAt improvements, also made the code easier to follow, in my opinion.
21:35:11 <hackrilege> wooot wooot it works finally!!! check it out!!! http://lpaste.net/
21:35:21 <hackrilege> http://lpaste.net/164415
21:35:28 <dfeuer> (compared to the release on Hackage)
21:40:40 <hackrilege> anyone have any comments?
21:42:38 <dfeuer> hackrilege, sorry, I should really be doing something utterly unrelated to Haskell at the moment :-/
21:42:47 <dfeuer> You're distracting me from my distraction.
21:43:23 <dfeuer> hackrilege, I doubt your Foldable instance is right though.
21:44:29 <dfeuer> hackrilege, you should test that Foldable instance with a non-commutative monoid, like [].
21:44:47 <hackrilege> aha
21:44:49 <hackrilege> i see thanks
21:44:53 <hackrilege> two basecases
21:44:53 <dfeuer> Or with something like  foldr (++) [] your_non_trivial_zipper
21:45:19 <dfeuer> Not sure what you mean about base cases.
21:45:24 <hackrilege> nono its fine
21:45:38 <bitemyapp> dfeuer: if you get can get perf and something more understandable in one go, then that's an unalloyed good right?
21:45:44 <hackrilege> it folds up one and supplys it as the basecase for the other
21:45:47 <hackrilege> seems natural
21:45:55 <dfeuer> hackrilege, the problem is that one of them is supposed to be *backwards*.
21:46:07 <hackrilege> so i should fold it backwards?
21:46:14 <hackrilege> foldl foldr?
21:46:16 <dfeuer> bitemyapp, well, not *quite*, because the source code size went way up.
21:46:52 <dfeuer> hackrilege, something like that. The forwards one gets foldr; the backwards one gets foldl.
21:46:57 <dfeuer> Or so.
21:47:02 <dfeuer> I haven't worked out the details!
21:47:02 <hackrilege> awesome, thanks
21:47:09 <hackrilege> i wouldnt have spotted that
21:47:27 <dfeuer> You can/should learn to use QuickCheck. It's awesome.
21:47:38 <hackrilege> thing is Free [] seems to be equivalent to most datastructures
21:48:06 <dfeuer> ?
21:48:16 <hackrilege> i guess ill generalise it shortly
21:48:38 <dfeuer> Free [] is approximately a rose tree, I believe.
21:48:41 <hackrilege> whats QuickCheck?
21:49:04 <hackrilege> what isnt?
21:49:10 <dfeuer> Free [] a = Pure a | Wrap [Free [] a]
21:49:37 <dfeuer> So it's actually not *quite* a rose tree.
21:49:47 <hackrilege> ok sorry, what Monad m => Free m is not like Free []
21:50:01 <dfeuer> ....
21:50:17 <dfeuer> Most of them, probably, but I'm no expert.
21:50:30 <dfeuer> I don't think there's anything particularly distinctive about Free [].
21:50:36 <hackrilege> Free (,) looks like a list, so it looks like Free []
21:50:43 <hackrilege> as it contains itself
21:50:51 <dfeuer> ?
21:51:06 <dfeuer> I should go, but that doesn't make sense.
21:51:18 <johnw> Free (,) does not type-check
21:51:24 <johnw> did you mean, Free ((,) a)?
21:52:08 <hackrilege> perhaps Free Pair, data Pair = Pair a a
21:52:30 <hackrilege> yeh thats better
21:52:34 <johnw> what was the original question, hackrilege ?
21:52:36 <hackrilege> i think Free [] is isomorphic to all Free Monads...
21:52:59 <hackrilege> at least
21:53:04 <johnw> Free [] is most definitely not isomorphic to all Free Monads
21:53:16 <hackrilege> counterexample?
21:53:27 <johnw> Free [] a is even isomorphic to Functor f => Free f a
21:53:29 <johnw> not even*
21:53:38 <hackrilege> oh yeah
21:53:38 <johnw> you've simply fixed f to []
21:53:51 <johnw> and lost the possible structures arising from every other choice of f
21:54:12 <hackrilege> but im saying most of them would be the same anyway, so it matters not that their lost
21:54:33 <johnw> I have no idea what you'd be saying that
21:55:12 <johnw> data Foo a = Foo Int a
21:55:35 <johnw> Free Foo a can contain a whole bunch of numbers, which would have no existence in Free [] a
21:55:37 <hackrilege> its something like once you have used Free to create a datastructure, since Free m (Free m a) is isomorphic to Free m a, making a Free datastructure from this is redundant.
21:56:13 <johnw> wait, who said it was isomorphic?
21:56:25 <hackrilege> its the definition
21:56:35 <merijn> hackrilege: huh?
21:57:36 <hackrilege> except one nesting of Roll, which is symbolic
21:58:14 <hackrilege> Free m a = Basecase a | Recurse (m (Free m a)
21:58:22 <hackrilege> with Monad m =>
21:58:29 <johnw> for Free m (Free m a) -> Free m a to work (which isn't necessarily a bijection!), I believe 'm' would need to be a Monad, not just a Functor, which the Free monad does not require.  I think you need to test some of these assumptions in code.
21:58:47 <hackrilege> so that return can be used to take the Basecase a -> Recurse (return a)
21:59:12 <hackrilege> but not back again
21:59:26 <hackrilege> ok its not an isomorphism fine
22:00:07 <hackrilege> so, im not sure in what way Free [] captures a large number of possible datastructures, but it totally does
22:01:08 <hackrilege> johnw, my code was here, i was wanting someone to have a look, it is working finally after many bugs. but i cant understand why i must use descend.descend as it bugs out without that
22:01:08 <hackrilege> http://lpaste.net/164415
22:01:26 <hackrilege> on line 68
22:02:22 <hackrilege> the idea is that this is the zipper in n dimensions accessed at each of its possible configurations, which has the same shape as the original nd zipper
22:02:39 <hackrilege> it can be mapped over with functions performing local navigations
22:03:07 <hackrilege> to give speed hopefully
22:03:35 <hackrilege> rather than trying to gather data all in one traversal or scan
22:03:59 * EvanR gives hackrilege speed
22:04:10 <johnw> well, I was able to write Functor m => Free m (Free m a) <-> Free m a, so you might be right about that one, though I haven't checked the laws
22:04:58 <hackrilege> EvanR http://goldenfrogpress.com/images/101118-Underground_comix_postcards/FatFreddyPostCardSpeedKills-240.jpg
22:06:02 <hackrilege> johnw, once you have forgotern where the midway basecase was i guess you would have trouble getting it back in the right plave
22:06:04 <hackrilege> place*
22:07:00 <hackrilege> i have yet to coax a guess from anyone as to if they think this will actually give a speed boost
22:07:31 <hackrilege> though someone did offhand mention that it was known as a granularity problem
22:07:46 <jle`> what exception type should i catch to catch a segfault?
22:07:58 <johnw> you could catch IOException
22:08:08 <jle`> ty
22:08:10 <johnw> or I think AsyncException
22:08:47 <jle`> i'll try both
22:08:55 <hackrilege> i should take a vote, if you do think this will give a performance enhancement, say nothing
22:08:56 <jle`> or maybe i'll catch SomeException and do typeOf to check
22:09:09 <EvanR> segfaults throw exceptions?
22:09:11 <johnw> signals are received by your Haskell programs as asynchronous IO exceptions
22:09:40 <johnw> hackrilege: a vote is fairly useless; try criterion
22:09:55 <hackrilege> unanimous, thanks for the support
22:09:56 <EvanR> hackrilege: nothing
22:10:02 <hackrilege> yes ill do the benchmark johnw
22:10:22 <hackrilege> EvanR is ruin my vote
22:11:31 <hackrilege> ill just (=<<) that Nothing, wait here
22:18:48 <rfw> is there any way to automatically derive serialization for an existential type?
22:18:55 <dreamaddict> ?faq
22:18:55 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:26:05 <MichaelBurge> rfw: Serializing seems doable without any tricks. For unserializing, you could probably do something with Template Haskell.
22:26:21 <rfw> MichaelBurge: hm i hoped it wouldn't come to that
22:26:40 <rfw> i can see why in the general case it's not doable with deriving Typeable but i wish it was :)
22:26:46 <rfw> er, s/Typeable/REad
22:28:13 <MichaelBurge> Even with read though, nothing stops someone from making their own type B that can be deserialized from every string that some other type A accepts
22:36:10 <koz_> If I wanted to use SQLite from Haskell, what's the best choice of library? There seem to be a lot of options and I dunno which one is good.
22:38:40 <Adeon> I would probably go with sqlite-simple
22:38:43 <MichaelBurge> koz_: This one is maintained by Brian O'Sullivan, so I'd probably use it: https://hackage.haskell.org/package/sqlite-simple
22:39:00 <MichaelBurge> koz_: It's structured similarly to postgresql-simple, which I've used before
22:39:00 <Adeon> looks like I'm not the only one
22:39:12 <Adeon> yeah there's also one for mysql/mariadb
22:39:28 <koz_> MichaelBurge: Thanks - that sounds good!
22:39:46 <Adeon> you still write 'raw' SQL with these libraries but they give you safe substitution and some conveniences when you match results from the db or feed them in
22:40:39 <Adeon> I think there are some higher-level libraries like persistent and its backends to various dbs but I haven't used them
22:40:42 <Adeon> not sure how they compare
22:43:31 * hackagebot mtl-prelude 2.0.3 - Reexports of most definitions from "mtl" and "transformers"  https://hackage.haskell.org/package/mtl-prelude-2.0.3 (NikitaVolkov)
22:49:57 <jle`> hm i couldn't catch the segfaults
22:51:47 <jle`> i guess i need to use System.Posix.Signals ?
22:52:04 <jle`> it might not even make sense to recover from segfaults
22:52:17 <jle`> i'm assuming it means the runtime has been fubar'd
22:53:08 <MichaelBurge> jle`: I guess it depends on where the segfault originated. If it's from the RTS itself, I don't know what you'd do. If it's from your own unsafe IO code, it could.
22:53:25 <cocreature> catching segfaults sounds like a terrible idea
22:53:32 * hackagebot hoauth2 0.5.3.1 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.3.1 (HaishengWu)
22:53:35 <jle`> it's probably from a library i'm using that is pretty FFI-heavy
22:53:47 <jle`> that's my best guess
22:54:08 <cocreature> I’ve never been able to get any useful backtrace for segfaulting ffi bindings
22:55:54 <jle`> ah well
22:56:20 <cocreature> maybe that’s possible and I’ve just not figured it out
22:56:51 <MichaelBurge> jle`: If it's FFI code, you should be able to attach gdb and get a backtrace at least in the C code. I've done that before when using an LZO library.
22:57:29 <MichaelBurge> jle`: You just set a breakpoint on any symbol in the C code's object file.
22:58:08 <MichaelBurge> jle`: Actually, the new GHC 8 DWARF debugging might make that easier. I haven't tried it yet myself.
22:58:09 <jle`> hm, i'm not familiar enough with the library i'm using to be able to make any sense of this
22:58:33 * hackagebot stm-containers 0.2.13 - Containers for STM  https://hackage.haskell.org/package/stm-containers-0.2.13 (NikitaVolkov)
22:58:35 * hackagebot mtl-prelude 2.0.3.1 - Reexports of most definitions from "mtl" and "transformers"  https://hackage.haskell.org/package/mtl-prelude-2.0.3.1 (NikitaVolkov)
23:18:34 * hackagebot farmhash 0.1.0.5 - Fast hash functions.  https://hackage.haskell.org/package/farmhash-0.1.0.5 (abhinav)
23:49:14 <jhrcek> Is there any comparison between Typeable/Data approach and GHC.Generics approach to generic programming? Are they for the same purpose? Is one simpler/recommended?
23:55:43 <jle`> Typeable is not related
23:55:51 <jle`> Data and Generic are probably more overlapping
23:56:04 <jle`> or do you mean Typeable + Data together vs. Generics
23:56:58 <jhrcek> jle: why I'm asking: I'd like to be able to traverse this javascript AST and am not sure what's the best way to do that
23:57:11 <MichaelBurge> jhrcek: I found Template Haskell easier to work with than Generics, for my specific case. As a user, I prefer Generics.
23:57:30 <jhrcek> jle: http://hackage.haskell.org/package/language-javascript-0.6.0.4/docs/Language-JavaScript-Parser-AST.html#t:JSAST
23:57:32 <jle`> jhrcek: what is your AST's data type?
23:57:34 <jle`> ah
23:57:36 <MichaelBurge> jhrcek: Are you saying you'd like to derive a Traversable instance for your AST?
23:58:04 <jle`> what do you want to do?
23:58:23 <jhrcek> example use case: extract all JSFunction declarations
23:58:36 * hackagebot pinch 0.2.0.1 - An alternative implementation of Thrift for Haskell.  https://hackage.haskell.org/package/pinch-0.2.0.1 (abhinav)
23:58:50 <jle`> probably just straight recursion would be the nicest way
23:59:30 <jle`> it'd be nice if the library offered recursion combinators to make it easier to work with
23:59:37 <MichaelBurge> jhrcek: You don't need generic programming at all for that. Just define a function 'extractFunctions :: JSAST -> [JSStatement]'
