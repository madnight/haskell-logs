00:05:57 * EvanR forgets theassociated  type synonym syntax yet again
00:07:41 * hackagebot uhc-util 0.1.6.6 - UHC utilities  https://hackage.haskell.org/package/uhc-util-0.1.6.6 (AtzeDijkstra)
00:07:41 * hackagebot uhc-light 1.1.9.4 - Part of UHC packaged as cabal/hackage installable library  https://hackage.haskell.org/package/uhc-light-1.1.9.4 (AtzeDijkstra)
00:35:18 <gracjan> hi, question
00:35:25 <gracjan> how many packages are ther on hackage now?
00:41:59 <Rotaerk> gracjan, looks like 9719
00:42:24 <gracjan> Rotaerk: thanks
00:42:37 * hackagebot wikicfp-scraper 0.1.0.0 - Scrape WikiCFP web site  https://hackage.haskell.org/package/wikicfp-scraper-0.1.0.0 (debugito)
00:48:32 <EvanR> heres a type
00:49:16 <EvanR> doRequest :: TimeoutValue -> IO a -> (Either SomeException a -> m ()) -> m ()
00:49:42 <EvanR> is this SomeException appropriate? is it possible that the callback can usefully distinguish which exception happened
00:52:49 <ski> hm, an alternative might be `doRequest :: TimeoutValue -> IO a -> (forall e. Exception e => Either e a -> m ()) -> m ()'
00:56:30 <EvanR> hmm for some reason i thought a standard function actually returned SomeException
00:56:36 <EvanR> i see theyre polymorphic 
00:57:31 <EvanR> if the provided callback doesnt want the particular exception that happens, what happens?
00:57:40 <EvanR> referring to the rank 2 one
01:06:55 <ski> it's conceptually equivalent to `doRequest :: TimeoutValue -> IO a -> exists e. Exception e *> m (Either e a)', so the callback doesn't get to choose
01:07:57 <ski> the callback is polymorphic. the callback must be able to handle any exception in `e' that's an instance of `Exception', in case of a `Left' input
01:08:08 <ski> EvanR ^
01:08:31 <EvanR> how would it do that in practice?
01:08:37 <EvanR> using the Exception class?
01:08:45 <ski> yes
01:08:49 <EvanR> i see
01:09:31 <EvanR> gnarly
01:09:48 <ski> `doRequest :: TimeoutValue -> IO a -> forall e. Exception e => m (Either e a)' would allow the caller (~ the callback) to decide which exception type `e' they wanted to handle
01:10:20 <ski> (that would normally be written as `doRequest :: forall e. Exception e => TimeoutValue -> IO a -> m (Either e a)', of course)
01:12:11 <EvanR> because of magic?
01:12:43 <EvanR> i.e. im not providing the exception, the runtime is
01:12:57 * ski isn't following
01:13:41 * ski ponders how one would show the equivalence, possibly using `CoDensity' ..
01:13:55 <EvanR> actually im not following, your last type sig isnt for a callback 
01:14:10 <EvanR> it looks like a synchronous call
01:14:57 <ski> i was assuming the original version was also synchronous
01:15:12 <EvanR> no, thats why theres a handler passed
01:15:52 <ski> well, a handler/callback is often used in such cases, solely to avoid having to wrap in a new `data' type
01:16:14 <ski> (it's one of the two ways in which to encode `exists' in GHC)
01:17:20 <EvanR> well doRequest should emit an async job to get the a from the IO a, and later on either execute the callback with the answer, or with some reason why theres no answer
01:17:36 <EvanR> and return () immediately to the caller
01:17:48 <ski> ok
01:18:10 <EvanR> and forall e . Exception e => Left e a seems like the most flexible
01:18:18 <EvanR> er Either e a
01:18:31 <ski> s// -> m ()/
01:18:55 <EvanR> yeah
01:19:09 <EvanR> that substitution would be interesting
01:34:42 <EvanR> so far so good
01:42:39 * hackagebot integer-gmp 1.0.0.1 - Integer library based on GMP  https://hackage.haskell.org/package/integer-gmp-1.0.0.1 (HerbertValerioRiedel)
01:50:39 <blackadder> wow, these many people use haskell ?
01:51:24 <ski> no, we're all robots, pretending to socialize
01:51:34 <ski> (you're also a robot)
01:52:15 <blackadder> ʘ‿ʘ
01:52:26 <ggVGc> which of these would you guys prefer? https://gist.github.com/b56a01c6e8f6ebfc46fcd099f501b4c4
01:54:07 <chipf0rk> ggVGc: 2, readable + more flexible than 3
01:54:23 <ski> i suppose the last one (it doesn't contain `$')
01:54:23 <ggVGc> yeah, fair
01:54:36 <ggVGc> ski: what about the 2nd but with parentheses?
01:55:02 <ski> it's not clear whether `RowPos' is the only constructor
01:55:17 <ski> (and ditto for `Top')
01:56:22 <ggVGc> they're not
01:56:49 <ggVGc> ski: https://gist.github.com/59a467ec0917425a84ac38c0c79d0a64
01:57:23 <ski> ok
01:57:32 * ski would perhaps also avoid `&'
01:58:05 <ggVGc> yeah, that's a personal maybe crappy idiom of mine
01:58:15 <ggVGc> but I've decided I don't care if my haskell is idiomatic for now
01:59:04 <ski> personally, i'd say that's the right attitude .. as long as you're informed about the reasons for various idioms
01:59:30 <ggVGc> not sure I am :(
02:00:24 <ski> `&' may sometimes help readability (ordering). e.g. if lenses are used
02:00:28 <ggVGc> ski: I use & when I have functions that are essentially some kind of "self" referencing. Where conceptually I think about it as "run this function with this value as self"
02:00:43 <ggVGc> whcih is probably the wrong atitude for haskell
02:01:00 <ski> `$' may sometimes help avoid a long sequence of closing brackets, or a closing bracket many lines down
02:01:16 <ggVGc> yeah, I've started using $ a lot less now though
02:01:20 <ggVGc> starting to like parenthese a lot more
02:01:46 <ski> if i could type a lambda/`do'/... directly after an expression, then that would get rid of most of my uses of `$'
02:01:57 <ski> brackets are nothing to be afraid of
02:02:09 <ggVGc> yeah, that's my main use case of $ also
02:03:03 <ski> i suppose by "self" referencing, you mean some kind of OO-thinking
02:03:54 * ski thinks the whole situation with record fields and selectors is unfortunate
02:05:13 <ski> if we have `data Frob = MkFrob { foo :: Int , bar :: Int -> IO Frob }', then clearly `foo' is an `Int'. imho it makes no sense at all to have `foo :: Frob -> Int'
02:05:43 <ski> iow, the selector functions ought to be syntactically distinguished from the field names
02:06:04 <ggVGc> ski: sure, and that's what Elm and Purescript do afaik
02:06:05 <ski> in SML, the selector function would be `#foo', while the field itself is still `foo'
02:06:16 <ggVGc> at least elm has pretty nice record semantics
02:06:44 <ggVGc> ski: but it also has some interesting benefits, like what I'm doing now with the treating the last argument as the `self` and the rest as arguments to the function
02:06:58 <ggVGc> to me it makes for better readbiity because it's left to right
02:07:24 <EvanR> what the heck does this do...
02:07:27 <EvanR> :t deleteBy
02:07:29 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
02:07:53 <ggVGc> ski: basically I always use bar&foo x y if the type of foo is a -> b -> state -> state
02:08:17 <ggVGc> because conceptually for me that's a "state updating" function that deals with a self value
02:08:31 <ski> @let equating :: Eq a => (b -> a) -> (b -> b -> Bool); equating f = (==) `on` f
02:08:32 <lambdabot>  Defined.
02:09:35 <ggVGc> ski: I've also aliased & as \> in the instances I use it as a piping operator, which is probably frowned upon by haskellers
02:09:48 <ggVGc> but it reads much nicer to me
02:10:21 <EvanR> |> is known as the pipe operator in elixir
02:10:30 <EvanR> which is reverse function composition
02:10:42 <ggVGc> EvanR: yeah, but in haskell |> is taken by Seq
02:10:47 <EvanR> it looks like a right facing eq-triangle to me
02:11:00 <ski> > (map fst . deleteBy (equating snd) (undefined,'b') . zip [0 ..]) "abacabad"
02:11:02 <lambdabot>  [0,2,3,4,5,6,7]
02:11:05 <EvanR> or possibly a toblerone facing onwards
02:11:12 <EvanR> im going with that
02:11:29 <ski> EvanR : example ^
02:12:30 <mauke> that should have type deleteBy :: (a -> Bool) -> [a] -> [a]
02:12:31 <ski> EvanR : so, it takes an equivalence relation as argument
02:12:40 * hackagebot base 4.9.0.0 - Basic libraries  https://hackage.haskell.org/package/base-4.9.0.0 (HerbertValerioRiedel)
02:12:42 * hackagebot template-haskell 2.11.0.0 - Support library for Template Haskell  https://hackage.haskell.org/package/template-haskell-2.11.0.0 (HerbertValerioRiedel)
02:12:54 <EvanR> yes i was looking for deleteBy :: (a -> Bool) -> [a] -> [a]
02:13:27 <ski> @type filter . (not .)  -- ?
02:13:29 <lambdabot> (a -> Bool) -> [a] -> [a]
02:14:19 <ggVGc> why can't we use where clauses anywhere we can use let..in?
02:14:27 <ggVGc> like, in a lambda for example
02:15:32 <ski> `where' attaches to a defining equation
02:15:42 <ski> `let'-`in' forms an expression
02:15:54 <ski> (`where' also attaches to `case' branches, btw)
02:16:22 <ski> (unfortunately lambdas aren't by default `\case')
02:17:41 * hackagebot ghc-boot-th 8.0.1 - Shared functionality between GHC and the @template-haskell@  library  https://hackage.haskell.org/package/ghc-boot-th-8.0.1 (HerbertValerioRiedel)
02:18:53 <ggVGc> it's a bit annoying
02:19:06 <EvanR> what are some interesting ways to report a number between 0 and 1
02:19:24 <ski> report ?
02:19:26 <ggVGc> ski: like, I would have wanted to be able to write this, https://gist.github.com/287f9698ead2c75859000b8629b90c72
02:19:46 <EvanR> like log scale is useful for numbers greater than zero that have a wide range
02:19:57 <EvanR> but [0,1] 
02:20:06 <ski> ggVGc : you could try using `\case' there, i suppose
02:20:32 <ggVGc> ski: waht extension do I need for that?
02:20:36 <EvanR> top uses "loaded average" which is something else
02:20:40 <EvanR> load average
02:20:41 <ggVGc> lamdacase?
02:21:04 <ski> `LambdaCase', yes
02:21:13 <EvanR> i guess percent
02:22:20 * ski . o O ( `‰' )
02:22:41 * hackagebot ghc-boot 8.0.1 - Shared functionality between GHC and its boot libraries  https://hackage.haskell.org/package/ghc-boot-8.0.1 (HerbertValerioRiedel)
02:22:43 * hackagebot dead-code-detection 0.7 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.7 (SoenkeHahn)
02:22:45 * hackagebot ghci 8.0.1 - The library supporting GHC's interactive interpreter  https://hackage.haskell.org/package/ghci-8.0.1 (HerbertValerioRiedel)
02:23:52 <EvanR> permil
02:25:54 <ski> what do you call it if you divide by `10^0' ?, just "per" ?
02:26:43 <EvanR> i dont know ancient words for 1
02:26:49 <EvanR> maybe they didnt invent it yet
02:28:45 <ggVGc> just out of curiosity, is there any way I could implement these operators to make this work? https://gist.github.com/29f0e94a301818235ed936c0791caad5
02:32:36 * ski thinks no
02:32:51 <ski> lambda is greedy on the body side
02:33:06 <ggVGc> yep, I reckon that too
02:33:12 <ggVGc> also, it's not a good idea wnyayanyway
02:33:14 <ggVGc> was just curious
02:44:40 <m0rphism> hi, assuming a language has both polymorphic recursive functions and data types, is it possible to monomorphize both? For the examples I've created it works, allthough it may create an unholy amount of monomorphic versions, but I'm not sure on the general case. Is there some literature?
02:46:10 <mauke> do you have type classes?
02:46:47 <m0rphism> mauke: that would have been the next question ;) (what happens when I add type classes to the picture)
02:46:58 <ski> > let polyLength :: [a] -> Int; polyLength [] = 0; polyLength (x:xs) = 1 + polyLength (map (: []) xs)  in  polyLength [0,1,2,3]
02:47:00 <lambdabot>  4
02:47:03 <ggVGc> I'm so confused when I need RankN(2)Types
02:47:13 <ggVGc> if GHC didn't tell me I'd never know
02:47:33 <ski> ggVGc : whenever you want a polymorphic argument, or an argument which has a polymorphic argument, or ...
02:48:11 <ggVGc> oh, wait, a place where I thought it wasn't needed actually had it
02:48:15 <ggVGc> now I'm not so confused
02:48:25 <ski> m0rphism : how would you monomorphize that `polyLength' ?
02:48:27 <m0rphism> mauke: I remember, there was some problem in the context of type classes prevent static resolution of dictionaries, but I can't remember the post/example
02:48:40 <ski> (or perhaps you'd prefer a less silly example ?)
02:49:46 <m0rphism> ski: I want to monomorphize as a whole program optimization, so the idea was that there is already a monomorphic type at each callsite.
02:50:02 <ski> (m0rphism : btw, it's not clear if any of the qualifiers "polymorphic recursive" were meant to apply also to "data types")
02:50:29 <ski> m0rphism : doesn't matter. the number of monomorphized versions you'd need here depends on the length of the list
02:50:40 <mauke> m0rphism: the monomorphic callsite type is polyLength :: [Integer] -> Int
02:51:25 <m0rphism> consider for example the classic example   data Nested a = a :<: (Nested [a]) | Epsilon
02:52:24 <m0rphism> with function a length function of type  Nested a -> Int
02:54:38 * ski waits for m0rphism to continue
02:55:41 <m0rphism> ski: sorry for the wait, i think i just found my error of thinking ^^
02:58:03 <m0rphism> ski: the misconception i had, was that I failed to construct a function which could generate a `Nested a` where the nesting level depends on a runtime value, but this is obviously not the case as a simple conditional seems to suffice
02:58:33 <ski> ok
02:59:23 <m0rphism> ski: mauke: thanks for putting up with my nonsense ;)
02:59:37 <ski> no worry
03:00:35 <trxie> i just used cabal to install a package for the first time but when I try to import it says it can't find the module, which is Graphics.HGL what am i doing wrong
03:01:59 <lyxia> trxie: are you running ghc with "cabal ghc"
03:02:34 <lyxia> hmm no that's not the right command in cabal
03:02:47 <mauke> trxie: what did you install?
03:02:58 <trxie> Graphics.HGL
03:03:12 <trxie> HGL
03:03:44 <mauke> what does 'ghc-pkg list' say?
03:04:19 <trxie> neither terminal nor ghc are accepting that command
03:04:33 <mauke> define "accepting"
03:04:38 <mauke> especially the ghc part
03:05:51 <trxie> http://pastebin.com/tYG2rRYT
03:06:18 <mauke> ... that's ghci
03:06:43 <trxie> ahh k yeah thats the problem i guess i don't know what I'm doing
03:06:59 <trxie> I'm reading a book and havent had to install a package before
03:07:47 <lyxia> cabal exec ghc myfile.hs will give ghc access to your packages installed with cabal
03:08:04 <EvanR> ggVGc: .. funny everything im doing with . is now suddenly backwards and im trying to figure out why
03:09:40 <trxie> does that apply to ghci?
03:23:21 <chenyu> hello, would you help me? I'm using stack. In src folder, I have two files: Log.hs, and Lib.hs. It seems that the class defined in Log.hs is not in scope of Lib.hs. Do I have to use 'import' in Lib.hs even the Log.hs is in the save folder?
03:23:43 <lyxia> yes you have to import every module you use in a file
03:24:53 <chenyu> Alright, thanks a lot!
03:29:45 <EvanR> i beg your pardon, is the lens library just completely backwards wrt (.) usual ordering
03:29:57 <Axman6> yes
03:30:03 <Axman6> but also not realy
03:30:05 <EvanR> on purpose or is there a reason?
03:30:11 <Axman6> for a resons
03:30:36 <Axman6> lenses are functions of type (a -> f b) -> (a -> f t), which does strange things when you compose them
03:30:57 <Axman6> but has the nice side effect that the syntax looks a lot like OOP accessors (for some definition of nice)
03:31:04 <EvanR> im having a hard time getting a category of that form to work
03:31:17 <EvanR> it works, but backwards
03:31:32 <EvanR> and i want it to be forwards
03:31:42 <EvanR> lol
03:32:27 <EvanR> type Edit s a = (a -> a) -> (s -> s)
03:32:36 <EvanR> these compose the OOP order with .
03:32:55 <EvanR> but the type variables seem to be in the wrong places...
03:33:29 <ski> @type fmap . map . mapMaybe  -- also "backwards"
03:33:31 <lambdabot> Functor f => (a -> Maybe b) -> f [[a]] -> f [[b]]
03:33:47 <Axman6> you could always swap the type parameters, assuming you're wriing Edit
03:33:55 <EvanR> i tried that
03:34:13 <EvanR> it looks like Editor Int (Huge (Structure ...)))
03:34:19 <EvanR> and THATs backwards (to me)
03:34:19 <ski> (`fmap' accesses the outermost `f' layer. then `map' the middle list layer, then `mapMaybe' the innermost list layer)
03:35:17 <EvanR> this is curiously confounding
03:36:52 <EvanR> :t mapMaybe
03:36:53 <lambdabot> (a -> Maybe b) -> [a] -> [b]
03:38:11 <EvanR> >>> is kind of uninspiring
03:38:39 * EvanR wonders about ggVGc's \> operator
03:41:31 <EvanR> s a is the correct order, as in s -> a if you were to get it
03:41:44 <EvanR> so oop be damned
03:42:27 <EvanR> alternatively this type sig be damned :: (b -> c) -> (a -> b) -> (a -> c)
03:42:47 <EvanR> (a -> b) -> (b -> c) -> (a -> c) may have been "correct" all a long
03:54:06 <ggVGc> EvanR: I use >>> a lot, and \> when I also need to reference the object
03:54:09 <ggVGc> both are piping to me
03:54:14 <ggVGc> and they fit my mental model well
03:54:41 <ski> EvanR : clearly `(a <- c) <- (b <- c) <- (a <- b)' is better
03:55:38 <ggVGc> EvanR: I usually use >>> or \>(which is just alias for &) when I want to model "flow" of data through transformers, and I use function composition with (.) for chained constructors or lenses
03:55:48 <ggVGc> because those read left to right to me
03:56:44 <ggVGc> like, Just . Foo . Bar $ x
03:57:20 <ggVGc> so, (Just . Foo . Bar $ x) \> transform \> print
03:57:24 <ggVGc> is what I would do
03:57:35 <EvanR> left to right dataflow works... unless youre arab
03:57:56 <ski>   (print . transform . Just . Foo . Bar) x
03:58:24 <EvanR> yeah you got it all mixed up
03:59:59 <ggVGc> I also do stuff like, x&( (*) 2 >>> Just . Foo)
04:00:09 <ggVGc> but I think my haskell might be unacceptable for everyone else
04:00:15 <ggVGc> but I'm okay with that, for my own projects
04:01:32 <ggVGc> ski: yeah, I just conceptually prefer "Data flows through these transforms" rather than "I am applying this function to these arguments"
04:01:44 <ggVGc> even if they are semantically the same
04:01:58 <EvanR> youre not actually applying anything
04:01:59 * ski doesn't see the difference
04:02:02 <EvanR> its composition
04:02:31 <EvanR> what it does vs what it is
04:02:55 <ggVGc> ski: the only difference is left to right vs right to left really
04:03:09 <ggVGc> I'm probably influenced by my first functional programming being in F#
04:03:42 <EvanR> composition is more than shorthand for doing f(g(h(x(y(z(...
04:03:53 <ggVGc> I know
04:04:00 <ggVGc> EvanR: but I prefer to do composition with >>> rather than (.)
04:04:16 <EvanR> its like how associativity of + means you dont have to care where the parens are
04:04:18 <ski> well, in your version, you had : start at the far right, go left for a bit, then jump to the far left, and proceed to the middle
04:04:22 <ggVGc> and I prefer putting the argument to the left with & rather than after
04:04:33 <EvanR> the grouping isnt an essential part of the subject
04:04:43 <kr36> a13ph one, the first article about buffer overflow for ever
04:04:58 <EvanR> ggVGc: right, ideally you dont worry about "the argument"
04:05:06 <a13ph> til
04:05:07 <kr36> right a13ph?
04:05:20 <ggVGc> EvanR: yeah, but sometimes the transformers need to reference it
04:05:21 <kr36> til what?
04:05:24 <ggVGc> at least in my code
04:05:27 * ski noticed yesterday (again) how you normally don't think of grouping in `m (m (m a))'
04:05:32 <EvanR> if you moved the composition away, then in section 17 where you actually use it for something youd probably not be too keen on x & f
04:05:35 <a13ph> til = Today I Learned
04:05:42 <ski> (as opposed to `((m . m) . m) a' vs. `(m . (m . m)) a')
04:06:13 <ggVGc> either way I'm still taking baby steps in haskell so you guys will just have to forgive me
04:06:17 <ggVGc> I'll see the light eventually
04:06:49 <EvanR> well, in the fervor im basically doing everything backwards, oh well
04:07:04 <EvanR> at least the type sig goes left to right
04:07:30 * ski would often prefer the type signature going the other way around
04:07:47 <ski> (wrt function types)
04:08:01 <ggVGc> EvanR: this is a pretty good example of how I often structure my code, https://gist.github.com/c71aaba70ed71f61502aaeed1d2d4b78
04:08:05 <ggVGc> imo it makes it very easy to edit
04:08:21 <ggVGc> sicne I can just remove a line starting with >>> with no extra editing
04:08:24 <EvanR> i think we could learn from the sumerians, whos writing switched from -> to <- and back every carriage return
04:08:27 <ggVGc> or add another transofmration without extra work
04:09:07 <EvanR> and then you have people who refuse to acknowledge that -> indicates "right"
04:09:29 <EvanR> clearly it points just as much left!
04:10:01 <ggVGc> ski: I think if we both started from scratch we would design pretty much opposite languages
04:10:12 <ggVGc> would be interesting
04:10:23 <EvanR> banish application completely ;)
04:10:32 <EvanR> quite pesky
04:10:35 <ggVGc> skarn: do you find my last paste obnoxious in style?
04:11:31 <ggVGc> eh, sorry
04:11:33 <ggVGc> ski: ^
04:13:46 <ski> EvanR : yes. Charity has morphism expressions
04:14:13 <ggVGc> EvanR: btw, one day we must meet for a coffee or a beer
04:14:19 <ggVGc> weäve known eachother online for too long now
04:15:05 <EvanR> why not both coffee and beer in one of those awful helmets at the same time
04:15:09 <ski> ggVGc : "obnoxious" is a strong word. it looks a bit .. strange, to my eyes
04:15:28 <ggVGc> EvanR: maybe we can find a compromise..
04:16:03 <ggVGc> ski: I'm still experimenting with how I want to write my haskell
04:16:05 * ski suggests a linear logic "both coffee or beer"
04:16:52 <ggVGc> I've started wondering if lenses lead me to writing worse code
04:17:06 <ggVGc> or rather, worse data design
04:19:24 <EvanR> in clojure i think the common wisdom is to keep everything in the program in one huge nest of maps and arrays
04:19:51 <EvanR> in an "atom" (MVar which can only swap, not be empty)
04:20:15 <EvanR> so you basically need something like lenses
04:21:30 <ggVGc> EvanR: one thing I've really enjoyed with lenses is that now I can write code that references elements of tuples, and if I add another value to the tuple type, I don't have to change pattern matches all ove rmy code base
04:21:35 <ggVGc> because of _1, _2 etc.
04:22:01 <ggVGc> on the other hand, maybe that is a complete anti-pattern
04:22:52 <EvanR> all you need is tuples
04:23:16 <ggVGc> I really wish we could pattern match on records with tuple syntax sometimes
04:24:32 * ski thinks `_1',`_2',... is off-by-one
04:25:25 <EvanR> we really ought to start counting from omega down
04:28:56 <ggVGc> ski: yeah same
04:29:04 <ggVGc> man, lambdacase is great
04:29:08 <ggVGc> wonder why I never used it before
04:29:10 <ggVGc> I knew about it
04:32:41 <EvanR> heh, i just used unary - probably for the first time ever (other than literals)
04:33:11 <EvanR> otoh i have to use subtract alot
04:37:47 * hackagebot haskell-gi 0.17.1 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.17.1 (inaki)
04:38:09 * ski thinks "unary" is a silly name
04:41:16 <ggVGc> EvanR: is this terrible? https://gist.github.com/004dee53aacc2f90f4934d88ce6bee55
04:42:02 <EvanR> yes because its exactly as long as my screen, so auto opening somehow tacks on the next lines timestamp
04:42:37 <EvanR> wow, look at all the lambdas
04:42:48 <lyxia> why \case {key ->
04:42:56 <ggVGc> lyxia: because I want to use where
04:43:01 <ggVGc> ski taight me the trick today
04:43:04 <ggVGc> maybe that wasn't good
04:43:12 <EvanR> i like to put everything in one rectangular where if possible
04:43:34 <EvanR> otherwise i get cold sweats flashingbacking to 11 8-space PHP indents
04:44:21 <ggVGc> EvanR: but in this case the where clause references values from the innermost lambda, so if I put it outside I'd instead have arguments to pass around
04:44:25 <ggVGc> which to me is more confusing
04:45:13 <EvanR> there can be inner wheres of functions defined in the where
04:46:31 <EvanR> so i just hit a style roadblocks... i want to do "if foo is Nothing || t < foo then"
04:46:39 <EvanR> but i cant compare t to foo
04:46:50 <EvanR> what do i do
04:47:09 <scshunt> EvanR: of course you can't
04:47:18 <EvanR> i know, and i can expand it into cases but
04:47:29 <scshunt> EvanR: use maybe
04:47:32 <ggVGc> is this a job for multiwayif?
04:47:33 <EvanR> what i just wrote is much shorter and how it would go in a crappy language
04:47:47 * hackagebot haddock 2.17.2 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-2.17.2 (BenGamari)
04:47:49 * hackagebot haddock-api 2.17.2 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-api-2.17.2 (BenGamari)
04:47:51 * hackagebot haddock-library 1.4.1 - Library exposing some functionality of Haddock.  https://hackage.haskell.org/package/haddock-library-1.4.1 (BenGamari)
04:47:55 <EvanR> ok
04:48:07 <EvanR> :t maybe
04:48:08 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:48:19 <ggVGc> if (foo&maybe False (\x->t<x))
04:48:22 <ggVGc> is what I would do
04:48:24 <ggVGc> probaby
04:48:25 <EvanR> :t maybe False (5 <)
04:48:26 <lambdabot> (Num a, Ord a) => Maybe a -> Bool
04:48:31 <EvanR> yeesh... ok
04:48:49 <EvanR> its even shorter than the crappy language but still
04:50:58 <EvanR> ive been working on this for like 15 hours i need a break
04:53:31 <ski> EvanR : what's the type of the branches ?
04:58:07 <Axman6> :t (^. non False . to (< 5))
04:58:08 <lambdabot>     No instance for (Num Bool) arising from the literal ‘5’
04:58:09 <lambdabot>     In the second argument of ‘(<)’, namely ‘5’
04:58:09 <lambdabot>     In the first argument of ‘to’, namely ‘(< 5)’
04:58:18 <Axman6> bleh
04:59:26 <ggVGc> EvanR: this is as good as I can do, https://gist.github.com/eb94934c1211ccc1c095fee383e7c443
05:06:52 <Axman6> :t over
05:06:54 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
05:14:54 <EvanR> ski: nothing to do with Maybe
05:15:35 <EvanR> its all Definitely from there on out
05:18:01 <ski> EvanR : but perhaps it's an idiomatic or monadic action ?
05:18:41 <EvanR> its a record update function
05:19:17 <EvanR> i could do it with runState, but that would be extra complex and cause extra copying of the record
05:19:19 <ski> ok
05:19:41 <EvanR> = if ... then sim { } else sim { }
05:20:14 <zennist> to get the indices for a list of items, we could do 'zipWith const [1..] list'or '[1..length list]', but which one would perform better?
05:21:05 <EvanR> :t scanl
05:21:06 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
05:21:23 <EvanR> > scanl (+) 0 "who dunnit"
05:21:24 <lambdabot>      No instance for (Num Char) arising from a use of ‘+’
05:21:25 <lambdabot>      In the first argument of ‘scanl’, namely ‘(+)’
05:21:25 <lambdabot>      In the expression: scanl (+) 0 "who dunnit"
05:21:54 <EvanR> > scanl (flip const (+1)) 0 "who dunnit"
05:21:55 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ Char -> a
05:21:56 <lambdabot>      Expected type: a -> (Integer -> Integer) -> Char -> a
05:21:56 <lambdabot>        Actual type: (Char -> a) -> (Integer -> Integer) -> Char -> a
05:21:59 * EvanR explodes
05:22:45 <zennist> I think you want: scanl (const . (+1)) 0 
05:23:06 <EvanR> > scanl (const . (+1)) 0 "who dunnit"
05:23:07 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
05:23:26 <zennist> but this gives an extra element - have to call tail
05:23:35 <EvanR> well thats cheap
05:24:07 <EvanR> though i dont understand what the extra element is
05:24:14 <zennist> it's certainly an interesting take - didn't think of doing this way
05:24:30 <zennist> there are only 10 characters in your input
05:24:41 <ski> > scanl (+) 0 [a,b,c]
05:24:42 <lambdabot>  [0,0 + a,0 + a + b,0 + a + b + c]
05:24:48 <zennist> the initial state is included in your output
05:24:58 <EvanR> the initial state is supposed to be
05:25:09 <ski> > length (scanl (+) 0 [a,b,c])
05:25:11 <lambdabot>  4
05:25:23 <zennist> yeah - but I wanted the indices which should be of the same length
05:25:25 <EvanR> so its going too far
05:25:44 <EvanR> so back to my original suggestion to write a recursive function specifically for it that looks ahead 1
05:26:38 <EvanR> though zip [0..] seems more practical since you probably care about the elements
05:26:47 <zennist> and I'm inclined to think 'scanl' would have similar performance with 'zipWith const [1..]'
05:27:28 <zennist> essentially you have to pay for two costs: 1. stepping the input list until the end element; 2. incrementally adding number starting from 1
05:27:44 <zennist> therefore it seems that all the solutions tend towards the same cost
05:28:29 <EvanR> a function specifically building a list of numbers has gotta be better than zipWith const and map fst [1.. length
05:28:52 <EvanR> @src unfoldr
05:28:52 <lambdabot> unfoldr f b = case f b of
05:28:53 <lambdabot>     Just (a, b') -> a : unfoldr f b'
05:28:53 <lambdabot>     Nothing      -> []
05:29:09 <zennist> well, zipWith looks at the head element of both lists at each step, apply a function and puts that into the output
05:29:26 <zennist> since it's lazy [1..] doesn't really consume anything
05:30:16 <EvanR> > let f _ [] = []; f i (x:xs) = i : f (i+1) xs in f 0 "who dunnit"
05:30:17 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
05:30:19 <zennist> so you ONLY paid for stepping through the length of the shorter list of the two, and the incrementing cost in enumFrom
05:31:48 <EvanR> > let f _ [] = []; f !i (x:xs) = i : f (i+1) xs in f 0 "who dunnit"
05:31:49 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
05:31:52 <EvanR> for good measure
05:32:50 <Wizziee> what is a type of a range? I want to have an associative list from a range to string, but I have no idea how to declare it ;)
05:33:21 <EvanR> there is the Ix class and a pair of numbers
05:34:16 <EvanR> > Data.Map.fromList [((0,1),"foo"),((3,7),"bar")]
05:34:18 <lambdabot>  Not in scope: ‘Data.Map.fromList’
05:34:41 <Wizziee> maybe a pair of numbers is enough, thanks ;)
05:36:57 <EvanR> > lookup (3,7) [((0,1),"foo"),((3,7),"bar")]
05:36:59 <lambdabot>  Just "bar"
06:12:51 * hackagebot ghc-prim 0.5.0.0 - GHC primitives  https://hackage.haskell.org/package/ghc-prim-0.5.0.0 (HerbertValerioRiedel)
06:14:15 <ggVGc> haskell has taught me that Maps are the answer for any situation where you want a sparse array
06:14:29 <EvanR> IntMaps
06:14:30 <ggVGc> well, almost any
06:14:34 <ggVGc> EvanR: yeah
06:14:59 <ggVGc> I uswed to have Vector(Maybe a), since I switched to Map Int a everything is way better
06:15:45 <EvanR> i heard you like IntMap, so i made a 2D sparse array with IntMap (IntMap a)
06:17:51 * hackagebot integer-simple 0.1.1.1 - Simple Integer library  https://hackage.haskell.org/package/integer-simple-0.1.1.1 (HerbertValerioRiedel)
06:18:53 <pavonia> EvanR: Is this what you would recommend for sparse matrices? I have to represent a spreadsheet-like structure where only small blocks of cells are populated with values in a huge matrix of empty cells, and not yet sure about what would be the best data type for that
06:20:38 <mniip> you could use a list of blocks
06:20:57 <alanz> ph88^, ping
06:21:16 <mniip> but then you have to deal with a lot of stuff like edge cases, merging blocks or not merging blocks etc
06:23:50 <ph88^> sup alanz  ?
06:24:48 <alanz> ph88^, I saw a conversation yesterday about parsing and reproducing source. 
06:24:54 <ph88^> yes
06:24:58 <pavonia> mniip: The blocks would be matrices theirselves
06:25:05 <alanz> what are you trying to do?
06:25:40 <EvanR> pavonia: id say its a good first try
06:26:04 <EvanR> ideally you can make an interface and change out the implementation later, but...
06:26:09 <ph88^> alanz, i want to parse source code (vhdl) and be able to reprint it (based on the syntax tree) but keep the exact same formatting as the input file. Later i want also apply formatting on some parts.
06:26:23 <ph88^> with formatting i mean here only change whitespace and line endings
06:26:34 <pavonia> EvanR: Would there be an advantage of a nested IntMap over e.g. Map (Int, Int)?
06:26:36 <alanz> ok
06:26:41 <ph88^> you can keep the same whitespace/lineendings but uppercase all the keywords for example
06:27:12 <ph88^> any ideas ?
06:27:17 <alanz> ph88^, ok, I wrote ghc-exactprint, and it is quite a tricky process. For haskell anyway
06:27:31 <ph88^> it was suggested to me for inspiration only
06:27:49 <alanz> The general approach is to make sure the lexer/parser actually give you the original format of everything
06:28:04 <ph88^> tbh i think it will be too complicated for me and i'm better of writing a parser first and then figure out later up to preserve whitespace .. but actually that might mean change the parser a lot :/
06:28:35 <alanz> And then ghc-exactprint transforms the absolute positions into relative ones (relative to prior output), so you can edit the AST then spit it out again
06:28:52 <ph88^> "give you the original format"  .. well i expect to get a syntax tree back .. the original format is a file :/
06:29:15 <cocreature> most parser libraries allow you to get a srcspan, that you can throw directly in your ast or store somewhere separately. an example is spanned in trifecta https://hackage.haskell.org/package/trifecta-1.5.2/docs/Text-Trifecta-Combinators.html#v:spanned
06:29:35 <ph88^> alanz, example ?
06:29:40 <alanz> What I mean is if the syntax tree has a string in it which had escape chars in it, you can't just print out the internal string, you need to know how the original was entered
06:30:30 <Mutter> Hi..
06:30:40 <Mutter> Anyone care to chat
06:30:44 <Mutter> I'm single
06:30:51 <alanz> ph88^, a trivial example is an integer entered as 04. The ast will not have the leading zero
06:31:02 <Mutter> Call me 
06:31:56 <ph88^> alanz, you mean keep the original as string and also keep it as Int ?
06:32:02 <alanz> yes
06:32:20 <alanz> you need both if you want to reproduce the original source
06:32:30 <alanz> from the ast/annotations
06:32:50 <ph88^> ok good point
06:32:57 <ph88^> you also save the line number and position on line ?
06:33:10 <EvanR> pavonia: well, the advantage is performance
06:33:17 <alanz> and you need to make sure the parser actually gives you locations of all the keywords
06:33:28 <EvanR> but Map (Int,Int) may have advantage over convenience
06:33:30 <alanz> ph88^, yes, you need positions of everything
06:33:58 <Mutter> Hi can I open my enemies Facebook
06:34:03 <ph88^> alanz, how can i safe these info while parsing with parsec/attoparsec ?
06:34:14 <alanz> ph88^, if you have "if x then 1 else 2", you need to know exactly where the "if", "then" and "else" are too, not just an AST element for an if statement
06:34:27 <ph88^> yup
06:35:06 <Mutter> What is this about
06:35:10 <alanz> ph88^, short answer is I don't know. If you are defining your own AST to represent the VHDL you can build it in to the structure, and make sure you have what you need
06:35:36 <alanz> but that was not an option for ghc so we have a more complex arrangement, of indexing via SrcSpan
06:35:48 <ph88^> eh ok
06:36:00 <ph88^> do you have any advice on source code transformations as well ?
06:36:13 <hexagoxel> rrah i need DynFlags to prettyprint a RdrName? Wth, GHC API.
06:36:15 <ph88^> for example i never figured out how to do multiple passes without them biting each other
06:36:42 <alanz> Well, I found with HaRe the key is to make sure that the AST can be exactprinted, then transformations become much simpler
06:37:00 <ph88^> should a transformation be an applicative ?
06:37:35 <mpickering> hexagoxel: Yes, unfortunately
06:37:41 <alanz> ph88^, if you do transformations one at a time in a pure structure it should be fine
06:37:52 <mpickering> You can use unsafeGlobalDynFlags but it is risky
06:38:05 <alanz> mpickering, hexagoxel it is not risky for that case
06:38:19 <alanz> thats why that one exists
06:38:26 <mpickering> are you sure alanz? 
06:38:31 <ph88^> thx alanz 
06:38:33 <alanz> yes
06:38:48 <hexagoxel> mpickering, alanz: thanks.
06:38:58 <alanz> the problem is dynflags is a kitchen sink
06:39:18 <alanz> ph88^, np. Shout if you want more discussion
06:39:22 <mpickering> Someone is working on refactoring it so that you don't need a DynFlags to pretty print fwiw
06:39:23 <ph88^> ok
06:39:57 <Mutter> Need help
06:40:01 <Mutter> How can I open my frenz account
06:42:00 <Axman6> I don't know what that is but this isn't the right channel to get the answers you want
06:42:51 <ph88^> Mutter, take a look here http://www.haskell.org/
06:43:29 <pavonia> He's just posting nonsense, not for the first time here
06:49:48 <Mutter> What is that ph88^ 
06:51:21 <Mutter> Hello
07:01:18 <davidkart> When hi
07:13:40 <Mutter> Hi david..
07:17:35 <davidkart> how are you friend ?
07:17:53 * hackagebot bench 1.0.1 - Command-line benchmark tool  https://hackage.haskell.org/package/bench-1.0.1 (GabrielGonzalez)
07:28:32 <davidkart> since I speak english I found this language funny
07:28:44 <davidkart> There is a lot of word-play that can be done with it.
07:29:06 <davidkart> friend/fiend
07:29:11 <davidkart> haha :p
07:32:25 <JuanDaugherty> fiend won't work for those knowing no german
07:32:40 <JuanDaugherty> *feind
07:33:20 <davidkart> I still have trouble with grammar and tenses I think.
07:33:30 <JuanDaugherty> lol forgot about fiend, as in monster
07:33:35 <vctr> i'm looking to model something like a sum type, but with structure in it
07:33:55 <vctr> basically a type can be one of 3 values, each of those values has a function f which is defined differently
07:34:18 <vctr> how might i model that?
07:34:55 <davidkart> vctr: you sound unclear. Can you provide with a piece of code that mimic what you are trying to do ? Or be more plain about it ?
07:35:27 <vctr> davidkart the basic issue is, i could model this as a record
07:35:51 <davidkart> you want kind of an « enumeration » type with three possible values ?
07:36:25 <vctr> so here's an example
07:36:59 <davidkart> data Fruit = Apple |Pear |Cherry deriving (Show)
07:37:01 <vctr> data Foo = Foo { name :: Text, fun :: Int -> Int }
07:37:08 <vctr> well okay
07:37:14 <vctr> data Foo = Foo { name :: Fruit, fun :: Int -> Int }
07:37:18 <vctr> using your sum type there
07:37:26 <vctr> the problem with Foo as it's defined
07:37:34 <davidkart> what's a « sum » type ? sum is an operation as far I know (sorry)
07:37:47 <vctr> is that I want Apple to be associated with one and only one possible of fun
07:37:57 <davidkart> well, a function then
07:38:00 <vctr> and I want PEar to be associated with one and only one possible other value of fun
07:38:39 <davidkart> It sounds to me that you are looking for more complicated than it should be.
07:38:49 <vctr> i guess i could implement this as a function that pattern matches on a Fruit and returns the fun associated with it
07:39:00 <exio4> data Foo = Con1 (Int -> Bool) | Con2 (String -> Int) |... ?
07:39:15 <davidkart> why would you return a function and not an integer ?
07:39:20 <vctr> exio yeah maybe something like that,
07:39:46 <vctr> davidkart huh? i want the value to be a function
07:39:52 <exio4> I don't understand what you exactly want
07:40:05 <vctr> here's a use case
07:40:29 <vctr> in my code there's various places where i want to call a function. the identity of that function is dependent on the value instance of Fruit
07:40:46 <vctr> for each Fruit value there should be one and only one value of the function
07:40:57 <davidkart> ok yeah of course. But why don't you use guards ?
07:41:02 <ocramz> hi there
07:41:22 <vctr> davidkart I could use guards and pattern match on Fruit
07:41:25 <hjljo> if the function is determined by Fruit, just have an f :: Fruit -> (X -> Y)
07:41:35 <hjljo> if i understand correctly
07:41:40 <vctr> hjijo yes that may be the best solution i'm thinking
07:41:47 <hjljo> any other type is going to be "too big"
07:42:05 <vctr> i was wondering if there is a way of representing that in the data
07:42:12 <vctr> but maybe i should just do this as a function
07:43:29 <davidkart> vctr: let f x=case x of Apple ->g x;case x of Pear ->h x; case x of Cherry -> l x
07:43:35 <davidkart> wonder if it would work though
07:43:58 <davidkart> vctr: no need I think.
07:53:27 <amnn> vctr, just a note on syntax, you need (and can only have) the first "case x of", the rest will cause a parse error
08:08:06 <Facon> Excuse me, can someone explain me why this is wrong?: https://gist.github.com/Facon/9f535f73ca3b1e4f8895502084be70c9
08:08:59 <simpson> Facon: Yeah, your first branch in your case doesn't have the right type. It appears to be IO Int instead of Int.
08:09:20 <Facon> yes, that's what the compiler says
08:10:07 <simpson> Do you know the difference between IO Int and Int?
08:10:10 <Facon> Can't I transform IO Int to Int or Is necessary to contaminate?
08:10:21 <Facon> IO Int is a Wrapper for Int
08:10:37 <simpson> I'm afraid that that's not true.
08:10:42 <simpson> @quote /bin/ls
08:10:42 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
08:11:00 <JuanDaugherty> monads is not wrappers?
08:11:14 <Rotaerk> a monad is like a burrito !
08:11:19 * Rotaerk ducks.
08:11:30 <simpson> Monads aren't wrappers. Some Monads are structures that look like wrappers, and some aren't.
08:11:54 <Rotaerk> Facon, one of the benefits of how IO is designed is that you *can't* go from IO x to x
08:12:06 <maerwald> :t unsafePerformIO
08:12:08 <lambdabot> Not in scope: ‘unsafePerformIO’
08:12:15 <maerwald> you can
08:12:17 <Facon> So I have to contaminate all my source code :(
08:12:18 <Rotaerk> well disregarding that wart
08:12:20 <simpson> Facon: Your safe choices are either to make both branches (and the entire function) return IO Int, or to use Debug.Trace to do your debugging, or to remove the debugging statement entirely.
08:12:23 <maerwald> it's not a wart
08:12:32 <simpson> Facon: What do you mean "contaminate"? IO is pretty common.
08:14:06 <hjljo> vctr: here's a way to do it using an abstract data type and viewpatterns https://gist.github.com/hjljo/0b3105810b6b5b74513f5d7c4113852f
08:14:26 <nitrix> data T = ∀ t. TC t => T t
08:14:57 <hjljo> vctr: not sure that it really buys anything over just using a function, but at least you can pattern match directly using a viewpattern
08:15:01 <nitrix> I understand the use of existantials but I don't grasp how it's possible to create those out of `forall`.
08:15:21 <nitrix> Can someone help me clear this up?
08:15:54 <nitrix> We don't have an `exists` keywork, do we?
08:18:53 <geekosaur> nitrix, do you know about de Morgan's rule?
08:19:29 <nitrix> geekosaur: Nope.
08:19:59 <nitrix> Not familiar with it; althought I can guess what it's about.
08:20:30 <JuanDaugherty> it's basic logic/computer science
08:20:45 <nitrix> Conjonction and disjunction.
08:20:50 <simpson> If everybody satisfies some rule, then there doesn't exist anybody that doesn't satisfy the rule.
08:20:54 <simpson> And vice versa.
08:21:00 <nitrix> Right.
08:21:50 <nitrix> GHC 8.0.1 just got released :)
08:22:32 <hjljo> nice
08:25:06 <nitrix> So this reads as, forall types `t`, there exists a type such as TC t => T t ?
08:25:55 <nitrix> Or, forall types `t` constrained to TC t, we have a type T t
08:25:57 <asthasr> niIt didn't
08:26:02 <asthasr> nitrix, It didn't
08:26:02 <nitrix> (So supposedly it exists)
08:26:07 <nitrix> asthasr: :(
08:26:26 <asthasr> nitrix, If you see the r/haskell post, that blog post is a draft
08:26:42 <RyanGlScott> Reports of GHC 8.0.1's birth have been greatly exaggerated.
08:26:43 <nitrix> I'm reading on morgan's law btw. Seems very nice, but I doubt I can transpose it to Haskell's syntax easily.
08:27:52 <nitrix> asthasr: What do you mean? It's on the mailinglist and I'm also on #ghc...
08:28:08 <hjljo> https://mail.haskell.org/pipermail/ghc-devs/2016-May/012098.html
08:28:19 <asthasr> nitrix, ah, okay :)
08:28:26 <asthasr> misinformation on reddit? how can it be
08:29:31 <hjljo> it got announced twice on /r/haskell in 30mins, but the second announcement is legit :p
08:33:44 <RyanGlScott> OK, _now_ it's born :)
08:43:25 <ocramz> (x-posted from #haskell-stack) : I'm building my library within a docker container, using stack. Since Docker has a very dumb caching mechanism, what can stack do to separate the dependency building phase from building the library proper ? I thought `stack setup` builds the dependencies but I was wrong problem is that docker doesn't know what might have changed (e.g. a code repository, as in my case), and what hasn't. It either rebuilds
08:43:25 <ocramz> all or nothing. It could learn a thing or two from the ghc runtime ..
08:46:01 <lambdafan> I am not sure how I have broken the type system, but ghc is complaining that I am trying to make the second tuple have kind * -> *
08:46:26 <lambdafan> I mean the second value in a tuple
08:46:54 <lambdafan> that doesn't see right at all, shouldn't we be able to have values of kind * -> * as the second value in a tuple?
08:47:21 <ocramz> lambdafan: what's the exact error message and what ghc are you using?
08:47:34 <lambdafan> Expecting one more argument to ‘AID’
08:47:34 <lambdafan>     The second argument of a tuple should have kind ‘*’,
08:47:35 <lambdafan>       but ‘AID’ has kind ‘* -> *’
08:47:35 <lambdafan>     In the type ‘[(Orbit, AID)]’
08:47:57 * hackagebot webapp 0.3.5 - Haskell web app framework based on WAI & Warp  https://hackage.haskell.org/package/webapp-0.3.5 (natesymer)
08:48:02 <lambdafan> uh I am using stack I am not sure what ghc I am using hold on
08:49:01 <ocramz> lambdafan: that error simply means you forgot to pass a type parameter
08:49:14 <lambdafan> oh okay I can do that thanks
08:59:28 <ski> nitrix : first, let's rename to ⌜data T = ∀ t. TC t ⇒ MkT t⌝. then it reads as : for all types ⌜t⌝, satisfying ⌜TC t⌝, the data constructor ⌜MkT⌝ will accept an argument of type ⌜t⌝ (and yield a value of type ⌜T⌝)
09:00:14 <nitrix> ski: Love it.
09:00:44 <Zemyla> Okay, question. If I came up with a way to sort any Traversable, not just lists, would that be something that would go into base to replace the old sort/sortBy?
09:01:35 <ski>   MkT ∷ ∀ t. TC t ⇒ t → T
09:01:42 <haskellguy> Haskell is so awesome!!!
09:01:45 <ski> is the type signature, for the polymorphic ⌜MkT⌝
09:02:23 <ski>   MkT ∷ (∃ t. TC t ×> t) → T
09:02:30 <ski> is an equivalent type signature
09:03:15 * ski stares at haskellguy
09:03:32 <ocramz> Zemyla : plz show! :)
09:03:50 <haskellguy> ski : Why?
09:03:55 <lambdafan> :info haskellguy
09:03:58 <ski> why not ?
09:04:02 <Zemyla> Okay, lemme type it out.
09:04:04 <lambdafan> heh
09:04:27 <haskellguy> lambdafan :  :info??
09:04:55 <ski> /msg NickServ info haskellguy
09:05:00 <ski> i presume lambdafan meant
09:05:08 <lambdafan> haskellguy : I was just curious about you and had forgotten some things about irc
09:05:29 <monochrom> haskellguy meets lambdafan.
09:05:34 <haskellguy> Haha
09:05:37 <hjljo> cute
09:05:41 <ski> (or perhaps lambdafan was curious about the precedence level and fixity of haskellguy ..)
09:05:50 <lambdafan> ski yes that too
09:05:53 <haskellguy> Lol
09:06:04 <haskellguy> Haskell is awesome, that's all I have to say
09:06:16 <lambdafan> haskellguy: go buikd something cool then :)
09:07:26 <lpaste_> Facon pasted “How do I wrap 0 to IO Int?” at http://lpaste.net/164108
09:07:58 * hackagebot pqueue 1.3.1.1 - Reliable, persistent, fast priority queues.  https://hackage.haskell.org/package/pqueue-1.3.1.1 (lspitzner)
09:08:19 <simpson> Facon: return
09:08:34 <ski> Facon> :t enumerate
09:08:46 <ski> Facon> :t readWithMaybe
09:08:53 <ski> Facon> :t getNumberOrError
09:09:17 <ocramz> sumStrings :: [String] -> IO Int , THEHORRORRRR 
09:09:32 <Facon> I post the whole code
09:09:38 <lpaste_> lambdafan pasted “A conversation from haskell-cafe” at http://lpaste.net/164109
09:09:40 <ski> @type (<$> (+))
09:09:41 <lambdabot> Num a => ((a -> a) -> b) -> a -> b
09:11:02 <lpaste_> Facon revised “How do I wrap 0 to IO Int?”: “How do I wrap 0 to IO Int? COMPLETE!” at http://lpaste.net/164108
09:12:47 <ski>   putStrLn (show (sumStrings originalList))
09:12:49 <ski> should be
09:13:06 <ski>   putStrLn . show =<< sumStrings originalList
09:13:09 <ski> or, shorter
09:13:13 <ski>   print =<< sumStrings originalList
09:13:16 <ski> @src print
09:13:16 <lambdabot> print x = putStrLn (show x)
09:14:30 <ski> @type foldM
09:14:31 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
09:14:32 <ski> @type foldM (\acc mi -> do i <- mi; return (acc + i)) 0
09:14:33 <lambdabot> (Monad m, Num b, Foldable t) => t (m b) -> m b
09:14:51 <ski> i think would work in your case, since you're building a list of `IO'-actions
09:15:28 <ski> an alternative would be to use `mapM getNumberOrError', instead of `map getNumberOrError', then you'd just have a regular list of `Int's
09:15:46 <simpson> Facon: Another big improvement would be Debug.Trace, so that you don't have to have everything in IO.
09:16:19 <ski> @type foldM ((<$>) . (+)) 0
09:16:20 <lambdabot> (Monad m, Num b, Foldable t) => t (m b) -> m b
09:16:32 <ski> Facon : ok, so you were missing a `.' in there
09:16:58 <ski> (use just `0', not `return 0', here)
09:17:29 <Facon> and with that I suppose it works with as IO Int
09:17:49 * ski can't parse "it works with as IO Int"
09:18:40 <Clint> needs more prepositions
09:21:00 <Facon> @ski, It works!, thx
09:21:00 <lambdabot> Unknown command, try @list
09:21:37 <ski> Facon : is there are reason you're building a list of `IO'-actions, rather than just a list of `Int's ?
09:22:44 <Facon> ski : unawareness, so no, there's no reason just struggling learning haskell
09:22:59 * hackagebot iridium 0.1.5.4 - Automated Testing and Package Uploading  https://hackage.haskell.org/package/iridium-0.1.5.4 (lspitzner)
09:23:10 <ski> Facon : then i suggest using `mapM getNumberOrError' instead of `map getNumberOrError'
09:23:17 <lambdafan> Facon: What resources are you using to learn haskell?
09:23:28 <ski> as result you'll get `IO [Int]', rather than `[IO Int]'
09:23:42 <ski> the former is an action that will compute a list of `Int's when executed
09:24:02 <ski> the latter is a list of actions, where each will compute a single `Int' for you when executed
09:24:03 <Facon> I have been learning from LYAH and from a local workshop here in Madrid
09:24:24 <lambdafan> Facon, I have a link for you. You may find it helpful. One moment
09:24:36 <ski> in the latter case, you have the option of executing the actions in the list in another order, or executing some of them more than once, and perhaps others not at all
09:24:51 <maerwald> Facon: lyah sucks, use a programming course like https://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:25:00 <ski> with the `IO [Int]', you have already decided to execute each action once, and to execute them in order from start to end
09:25:11 <lambdafan> Facon: https://github.com/bitemyapp/learnhaskell
09:25:31 <lambdafan> Facon: The problem with LYAH is it gives you no challenges to test your progress.
09:25:55 <ski> Facon : so, unless you intend to allow executing in different orders, or each list action many times or perhaps not at all, i suggest just using the `IO [Int]' version
09:26:12 <Facon> I'm waiting for buying Haskell book when they release it in printed format
09:26:30 <lambdafan> Facon: You don't *need* to wait.
09:26:49 <lambdafan> you can make much progress without that book
09:27:10 <lambdafan> the website I gave you has a nice structure to it
09:28:03 <Facon> lambdafan : thx for the website ;)
09:28:38 <lambdafan> Facon: I found it useful :)
09:30:40 <ski> Facon : is it clear what i said about executing actions in possibly differing order ?
09:32:59 * hackagebot brick 0.6.3 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.6.3 (JonathanDaugherty)
09:33:45 <Facon> ski : Trying to adapt to mapM right now wait until I make it works
09:34:19 <lambdafan> Facon: listen to ski.
09:37:47 * ski listens to lambdafan
09:38:13 <Facon> from what I can understand when doing [IO int], you're following the list and doing as much IO actions as int are in the list, in the second case IO [Int], you're wrapping the whole computation to 1 action
09:39:24 <Facon> In the 1º case it follows and order and in the second case the compiler may change the order?
09:42:08 <hpc> almost
09:42:33 <hpc> [IO Int] is a list of actions that will produce Ints when executed
09:42:45 <hpc> IO [Int] is an action that will produce an [Int] when executed
09:43:05 <hpc> there's not really any reordering that can happen
09:44:03 <hpc> however you can manipulate the lists yourself
09:44:19 <ski> in the `[IO Int]', you have a list of recipes, each of which you can execute individually, as many times as you like, in whatever interleaved order you like
09:44:39 <ski> in the `IO [Int]', there's just a single recipe, which will always give you a list of `Int's
09:44:53 <ski> you can execute it more than once, and perhaps you'll get a different list next time
09:46:08 <Facon> ok, I kind of understand the idea
09:47:22 <lpaste_> Zemyla pasted “Traversable sort (unoptimized)” at http://lpaste.net/164112
09:48:14 <Zemyla> ocramz: There you go.
09:48:46 <Zemyla> If it were optimized, it would take runs into account, though, and also probably figure out where things can be strict instead of lazy.
09:50:37 <Zemyla> So would a function for sorting a generic Traversable be useful?
09:53:21 <merijn> Zemyla: No, because you can't sort using only Traversable
09:53:36 <Zemyla> merijn: Except I just did.
09:53:57 <merijn> Zemyla: Show me :)
09:54:07 <Zemyla> I literally just did.
09:54:31 <Zemyla> The lpaste bot announced it less than 10 minutes ago.
09:54:33 <merijn> Zemyla: I just joined, so I missed everything more than like 1 minute ago :)
09:54:38 <puregreen> http://lpaste.net/164112
09:55:00 <Zemyla> Oh, okay.
09:56:15 <ski> Zemyla : oh, you're tying the knot .. interesting
09:56:28 <merijn> @karma+ Zemyla 
09:56:28 <lambdabot> Zemyla's karma raised to 4.
09:56:49 <merijn> Zemyla: You get a cookie for craziest/insane abuse of lazy time-travelling I've seen in a while
09:57:40 <maerwald> I consider tying-the-knot an anti-pattern. People should use a proper graph-library instead.
09:57:43 <merijn> This is right up there with reverse state
09:57:49 * ski once tied knots with `mfix' to get something like logic variables
09:58:11 <merijn> maerwald: Heh, those two have almost nothing to do with eachother
09:58:17 <maerwald> ?
09:58:24 <Zemyla> maerwald: I'm doing this with just base, so it can be in the Prelude.
09:58:32 <merijn> maerwald: knot-tying is rarely used for graphs and graph libraries can't replace arbitrary uses of knot-tying
09:58:50 <maerwald> I think "rarely" is not really accurate
09:58:57 <merijn> Graph libraries only make sense if you have graph data structures, not for graph control flow
09:59:12 <merijn> maerwald: So you oppose "let ones = 1 : ones" too?
09:59:26 <maerwald> I don't consider that tying the knot
09:59:29 <ski> @src cycle
09:59:29 <lambdabot> cycle [] = undefined
09:59:29 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:59:34 <maerwald> maybe we have different definitions there
09:59:36 <merijn> maerwald: I've never seen knot-tying used for graph like data structures
09:59:46 <maerwald> I have
10:00:14 <merijn> Well, I guess I did once as a simplistic explanation of some thing, but not in "real" code
10:00:29 <merijn> maerwald: Anything self-referential (such as the ones example) uses knot-tying
10:00:39 <merijn> As does anything using fix (because knot-tying is what fix does)
10:00:45 <maerwald> I was rather talking about doing things like doubly-linked lists and so on
10:00:46 <hpc> @src fix
10:00:46 <lambdabot> fix f = let x = f x in x
10:00:57 <hpc> contrast with fix f = f (fix f) which is not knot-tying
10:01:07 <merijn> maerwald: Did you look at his sort code?
10:01:36 <Zemyla> maerwald: This isn't a doubly-linked list. This is traversing a data structure and producing the sorted values at the same time as it collects the values to be sorted.
10:01:38 <merijn> maerwald: He's passing the result of his function as argument to the function generating said result. You can't trivially replace that self-reference with a graph library
10:19:47 <dolio> The original example is a function that replaces all values in a tree with the minimum value, in one pass.
10:19:50 <dolio> By Richard Bird.
10:21:39 <dolio> Not all things really end up being one pass, though, even if they look like one pass in the code.
10:23:18 <Zemyla> Yeah. I'm only doing it in one pass as a sort of guarantee that it'll produce the same number of values as it consumes.
10:32:28 <obadz> I've switched from ghc-mod to intero (ghci-ng) for type information in emacs, and now company hangs my emacs session all the time. Any ideas?
10:37:54 <monochrom> Bird's one-pass example is only superficially one-pass. it builds a different tree (the huge addition expression) and walks it. it performs two traversals. just on different trees at different times.
10:38:40 <fycth> @obadz I played with intero yesterday and have no success with it: spacemacs can't evaluate some var and can't start
10:38:40 <lambdabot> Unknown command, try @list
10:38:51 <fycth> obadz I played with intero yesterday and have no success with it: spacemacs can't evaluate some var and can't start
10:38:52 <obadz> fycth: :-(
10:39:32 <fycth> spent some time on investigating, re-downloaded/re-compiled elpa - no success :(
10:39:44 <ski> monochrom : addition ?
10:40:04 <mauke> `max`
10:41:11 <monochrom> oops, yeah, max.
10:41:24 <monochrom> because I use addition in my example :)
10:42:24 <monochrom> I wrote https://wiki.haskell.org/MonadFix#Lazy_algorithm_interleaved_with_effects
10:48:03 * hackagebot webapp 0.3.6 - Haskell web app framework based on WAI & Warp  https://hackage.haskell.org/package/webapp-0.3.6 (natesymer)
10:50:08 <Zemyla> monochrom: Yeah, it is two-pass in practice, but it being conceptually one-pass makes it easier to ensure that invariants are kept.
10:58:02 <obadz> cabal repl --with-ghc=intero does NOT start intero when there is no .cabal file preset
10:58:08 <obadz> (works fine when there is)
10:58:12 <obadz> is that meant to be?
11:03:03 * hackagebot ip 0.4 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.4 (andrewthad)
11:05:30 <tomleb> Hey guys, do I absolutely need s3 to use haskell-on-heroku / halcyon ? I can't figure out how to deploy my application. I tried with / without a cabal sandbox, played with halcyon parameters, etc.
11:06:35 <tomleb> It tries to find a build of my package / sandbox at https://halcyon.somethingsomething, but it can't (obviously).
11:12:36 <Welkin> tomleb: try asking in #halcyon
11:17:21 <tomleb> Welkin: No one is in #halcyon
11:17:38 <ski> > map (`minth` [2,8,5,7,1,4]) [0 .. 5]
11:17:40 <lambdabot>  [1,2,4,5,7,8]
11:17:41 <ski> > map (`maxth` [2,8,5,7,1,4]) [0 .. 5]
11:17:43 <lambdabot>  [8,7,5,4,2,1]
11:17:57 <dolio> monochrom: Adding everything up isn't a problem, either.
11:18:14 <dolio> You don't need to build an addition tree to do repSum.
11:19:58 <dolio> Although if you don't, you probably won't be producing the result tree lazily, I suppose.
11:20:52 <Dimitri_> what is this?
11:21:47 <Dimitri_> anyone here?
11:21:50 <ski> noone is here
11:22:28 <ski> if you have (and state) a (Haskell-related) question, someone might perhaps turn up
11:23:11 <monochrom> my computer's BIOS has a wake-on-haskell-question-lan feature
11:23:51 <dolio> monochrom: Unless you meant summing up the output tree. That's the problem. Bird's program works when you want to traverse a tree to get a new tree. But if you want to traverse a tree to get a new tree, and then add up all the things in the new tree, doing something like Bird's thing won't avoid building a new tree like it might appear.
11:24:15 <dolio> It doesn't do deforestation like that.
11:27:52 <Dimitri_> how would I simulate flipping a coin?
11:28:14 <ski> > minth 2 [a,b,c,d]
11:28:16 <lambdabot>  min (min (min (max (max a b) c) (max (max a b) d)) (max (max a c) d)) (max (...
11:28:19 <magneticduck> Dimitri_: can you approximate for newtonian physics?
11:29:05 <magneticduck> do you know both the position and the angular / linear momentum of the coin?
11:29:06 <dolio> magneticduck: No. Need to take general relativity into account.
11:29:11 <magneticduck> how about the temperature of the coin?
11:29:37 <magneticduck> there are a lot of variables in play
11:29:46 <Dimitri_> Wind is the only factor
11:29:50 <lambdafan> how is the coin feeling that day?
11:29:54 <Dimitri_> everything else a constant
11:30:04 <magneticduck> right, but you have to define the constants for the simulation
11:30:12 <magneticduck> they're factors, even if they aren't variable
11:30:13 <Dimitri_> given
11:30:14 <monochrom> the constant is "head"
11:30:30 <Dimitri_> ok, not variable
11:30:39 <Dimitri_> they are given
11:30:40 <ski> > fst (random (mkStdGen 12345678)) :: Bool  -- agrees with monochrom
11:30:42 <lambdabot>  True
11:30:43 <monochrom> and wind is modelled by a boolean parameter
11:31:08 <mauke> https://ghc.haskell.org/trac/ghc/blog/ghc-8.0.1-released
11:31:13 <magneticduck> Dimitri_: arguably, you probably want an algorithm which is indistinguishable with the result of a random coin flip
11:31:19 <magneticduck> perhaps in some way, this is a "simulation"
11:31:23 <monochrom> the boolean parameter is lifted. if it's bottom, the coin lands on its edge.
11:31:34 <magneticduck> since a simulation is the application model that seems indistinguishable to reality 
11:31:44 <magneticduck> s/to/from
11:32:12 <magneticduck> (s/model/of a model/)
11:32:15 <Dimitri_> So you think I should just do a simple boolean grab?
11:32:43 <Dimitri_> I don't really think that's what he's looking for
11:32:50 <magneticduck> a boolean grab?
11:32:52 <monochrom> who is he?
11:33:13 <monochrom> is he the flying spaghetti monster?
11:33:31 <Dimitri_> basically, I'm trying to predict the outcome of a coin flip
11:33:38 <erisco> heads
11:33:42 <Dimitri_> given speed, height, rotation, wind
11:33:43 <magneticduck> tails
11:33:47 <magneticduck> 5 dollars on tails
11:34:07 <erisco> @roll d2
11:34:07 <lambdabot> erisco: 1
11:34:09 <mfukar> It's heads or tails. Can I have your funding now? :)
11:34:10 <monochrom> that's too hard for me
11:34:16 <erisco> I argue 1 means heads
11:34:34 <magneticduck> Dimitri_: you do realise the whole meaning of flipping a coin is to run a process that is *unpredictable* even if you know the input factors to a high accuracy, right? 
11:34:36 <monochrom> or at least, that's too hard for a free consultation.
11:34:45 <Rembane>     
11:34:49 <magneticduck> are you trying to find patterns in the data from a coin toss?
11:35:24 <simpson> Kind of surprised that the Mythbusters haven't built a coin-flipping machine.
11:35:42 <dolio> magneticduck: Doesn't that mean that pseudorandom generators can't model coin tosses?
11:35:45 <Dimitri_> well, given input factors with enough significant figures, the flip should not be unpredictable
11:35:56 <monochrom> and you still haven't answered who is he.
11:36:15 <magneticduck> Dimitri_: sure, but you need very high accuracy
11:36:18 <Dimitri_> but I am using a large data set
11:36:21 <monochrom> it seems that whenever you are asked a question, you change subject.
11:36:57 <magneticduck> dolio: a coin toss is a very bad pseudorandom generator, but its seed is chosen well
11:37:06 <magneticduck> all it does is magnify a seed
11:37:54 <monochrom> wait a second, I thought that was a criterion for a good pseudorandom generator.
11:38:16 <dolio> But pseudorandom generators are easy to predict from their seed. They're generally only hard to predict (if at all) from their output.
11:38:25 <magneticduck> the criterion for a good pseudorandom generator is to, given a seed, produce a sequence of numbers with no predictable structure
11:38:52 <magneticduck> all a coin toss does is take some variables and put them together in what I imagine is actually a fairly simple way to reach a result
11:39:36 <magneticduck> (but the variables are hard to replicate or measure by a human)
11:39:50 <enthropy> how does it matter whether or not the process is deterministic if you have no hope of knowing those variables well enough?
11:40:06 <magneticduck> enthropy: in practice, it doesn't
11:40:07 <monochrom> I suggest #haskell-offtopic
11:40:15 <Zemyla> dolio: I'm kind of wondering if I should have an additional traversal function as a parameter, so that traversals from Control.Lens can be used as well.
11:40:16 <magneticduck> but yeeah, I almost forgot this is #haskell
11:43:05 <Dimitri_> It's for a class in chaos. So this is just the beginning of learning how everything is deterministic given accurate enough parameters. Things that can be used to predict weather, natural disasters, traffic, or the double pendulum
11:43:20 <Dimitri_> thanks for the input
11:43:39 <begriffs> I'm using a setting for ghc-options that seems to confuse `cabal check`: -threaded -rtsopts -with-rtsopts="-N -I2" 
11:43:49 <magneticduck> Dimitri_: you probably chose the wrong channel
11:44:02 <begriffs> It doesn't realize that I2 is one of the RTS options... "Instead of 'ghc-options: -I2"' use 'include-dirs: 2"'
11:44:08 <simpson> Dimitri_: So you're writing this in Haskell, right?
11:44:13 <Dimitri_> yea
11:44:22 <begriffs> It says Hackage will not accept my package...not sure what to do since this garbage collection setting is kind of crucial. :(
11:44:45 <monochrom> ooohhh, it doesn't know that " is special
11:44:57 <monochrom> OTOH is " supposed to work there?
11:45:23 <Dimitri_> i'm thinking about switching over to python and theano 
11:45:30 <Zemyla> So that I can sort a tuple using each.
11:49:13 <begriffs> monochrom: I better look more closely at the cabal docs
11:50:38 <dfeuer> Let's see how I broke it this time.
11:50:51 <dfeuer> Dee dee dee dee dee dee dee dee......
11:52:44 <Zemyla> Or sort a Vector using a traversal function of some kind.
11:53:04 <Zemyla> The vector package doesn't have generalized traversals?
11:54:33 <enthropy> Zemyla: doesn't it have mapM?
11:55:16 <Zemyla> enthropy: Yes, but why does it not have traverse?
11:56:35 <enthropy> Zemyla: I dunno, but lens defines a Data.Vector.Generic.Lens.vectorTraverse
11:57:39 <AK-47> hi all , ##securify is open for public with Our OS -= SU FEDORA OS =- ##SU.OS , just come in ... . is for public ... .
11:58:20 <Clint> Zemyla: i see a Traversable instance
11:58:23 <monochrom> please don't spam
11:58:52 <Zemyla> Clint: That's not for Data.Vector.Generic.
11:58:56 <Clint> oh
12:03:57 <begriffs> Looks like I need to quote the entire with-rtsopts section like in Nikita's example https://nikita-volkov.github.io/profiling-cabal-projects/
12:06:18 <monochrom> does cabal check understand this convention too?
12:07:46 <monochrom> ah, "token" can be a quoted string in Haskell 98 lexical syntax
12:08:12 <monochrom> but yeah you want the whole -rtsopts=... as one token
12:08:36 <monochrom> because the grammar is "token list" not "a string with some double-quotes"
12:24:48 <begriffs> Is there a way to verify that my RTS option set in the cabal file is in effect in the generated binary?
12:26:11 <monochrom> "--with-rtsopts=-N1 -M1M" and watch the program says "out of heap" quickly :)
12:26:20 <monochrom> -M1M means 1MB heap
12:26:33 <monochrom> in fact -M1K is even better :)
12:29:30 <bennofs> or --with-rtsopts=-s and check if it outputs gc stats to stderr on exit?
12:46:45 <mauke> https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html#hsc2hs <- hah!
12:46:49 <mauke> my claim to fame
12:48:07 * hackagebot craze 0.1.2.0 - HTTP Racing Library  https://hackage.haskell.org/package/craze-0.1.2.0 (etcinit)
12:59:42 <nolrai> So does it make sense even theoreticly to apply fmap to a dependent function?
13:01:32 <knz> hi guys
13:02:00 <deech> Is there a CPP macro with the Cabal version made available to the setup script?
13:02:06 <knz> hi guys, I'm a teacher at a university (and incidentally the author of "haskell for ocaml programmers") and I'd like to sponsor a small research by one of my students on a new git tool -- something to improve how a new programmer learns a large code base when they join a new project (like new Haskell contributors!). I'd love it if you could support this by filling this small research questionnaire for him: ht
13:02:12 <knz> tps://docs.google.com/forms/d/1oDBqxqf6AmyRpG07P3QgIMDSQwowoxRo-yBEdxORWXk/viewform
13:02:32 <knz> https://docs.google.com/forms/d/1oDBqxqf6AmyRpG07P3QgIMDSQwowoxRo-yBEdxORWXk/viewform
13:03:08 * hackagebot hatex-guide 1.3.1.2 - HaTeX User's Guide.  https://hackage.haskell.org/package/hatex-guide-1.3.1.2 (DanielDiaz)
13:04:58 <mauke> "Scenario's
13:05:00 <mauke> "
13:05:04 <mauke> disgusting.jpg
13:05:17 <mauke> argh, it repeats three times
13:05:27 <nolrai> Hm?
13:05:53 <nolrai> Oh. Yeah, thats a bad typo. >.<
13:06:09 <ski> nolrai : dependent in which sense ?
13:06:20 <mauke> then one "scenarios", only to punch you in the face with another "scenario's" afterwards
13:08:59 <mauke> knz: I don't understand the questions
13:09:02 <mauke> this thing makes no sense
13:10:32 <byorgey> knz: I am filling out the questionnaire, but I have to say it is rather confusing
13:10:39 <knz> thanks for the feedback.
13:10:46 <byorgey> I really don't understand what the questions are asking, especially the second part
13:11:01 <mauke> in particular, the four scenarios (or "scenario's") are just questions, not scenarios
13:11:14 <knz> the essence is to gather "how important is each sources of information for each scenario?" (assuming you don't use the same sources with the same importance for all scenarios)
13:11:25 <rootnode> cd
13:11:36 <rootnode> argh, sorry
13:11:39 <knz> well for example, to decide the "age" of a piece of code you usually do not need to gather too much from the commit messages
13:11:41 <mauke> you're obviously using a non-standard definition of "scenario", so a glossary would be good
13:12:08 <knz> ok, good point
13:12:08 <byorgey> knz: do you mean "how important is each source of information in helping you answer certain questions about the code"?
13:13:13 <mauke> byorgey: if so, it would make sense to transpose the questions
13:13:15 <a13ph>  
13:13:15 <a13ph> "how often do you need each data point", i guess? or some user-friendly synonym of "data point"
13:13:46 <mauke> from "here's a source of information. in what situation would you use this?" to "you want to figure out X. what sources of information would you use?"
13:14:03 <knz> mauke: great, thanks, that's useful
13:14:04 <byorgey> yes, I agree, that would be much clearer
13:14:21 <a13ph> oh. now it does make more sense
13:16:09 <a13ph> I'll fill this out after it gets reworded better (I assume link won't change?). Definitely love the direction of this research/development
13:16:27 <knz> thanks!
13:18:20 * ski idly notes knz doesn't appear to be in #ocaml
13:19:01 <nolrai> ski: In the type theory sense, which I guess doesn't really quite work with how Haskell does things, well, hmm. With Type in Type and Data Kinds and such you should beable to to say take a list of Ints to a list of proofs they are even, no?
13:19:05 <enthropy> knz: maybe you're already doing this, but I think "what should an IDE do" is a better-explored version the same problem you might compare with
13:19:21 <nolrai> But the types get weird.
13:19:52 <knz> I forwarded your suggestions to the student
13:20:00 <ski> nolrai : what would the type of the mapped function be ?
13:20:27 <knz> enthropy: surprusingly IDEs are not well-versed in exploring history
13:20:53 <knz> (as opposed to the current version) -- IDEs are good at horizontal exploration but not time travel
13:22:25 <Zekka> knz: Which IDEs do you mean? IntelliJ has a lot of features for this but they're limited by having to interop with version control
13:22:52 <Zekka> for a given version control system you can view the historical state of one file for a lot of different points in the past, but you can't actually see a historical version of the code without moving your real working coppy to that version
13:23:08 * hackagebot hatex-guide 1.3.1.3 - HaTeX User's Guide.  https://hackage.haskell.org/package/hatex-guide-1.3.1.3 (DanielDiaz)
13:23:21 <EvanR> and IDE that uses patch theory, hmm
13:23:26 <knz> Zekka: yeah and then furthermore, if you look back at one file it's hard to look at the state of the other files around it at the same revision
13:24:04 <Zekka> Yeah, that's the real big limitation imho
13:24:04 <nolrai> Yes, that is somewhat the problem. (Using agda like notation) Possibly: "dep_fmap : (f : (x : A) -> B x) -> F A -> fmap B A"? 
13:24:21 <Zekka> I guess the problem is probably implementing this functionality without doing something surprising given the version control system the user's already using
13:24:35 <ski> nolrai : i meant the type of `f', in your particular example with even integers
13:24:49 <nolrai> No, that doesn't type check.
13:24:57 <knz> Zekka: indeed. And that's a challenge that is largely independent of whether you are using an IDE or a simple text editor
13:25:45 <Zekka> If you just say "don't worry, we save the existing state and switch to the old one" then you've reimplemnted a big part of git
13:25:50 <Zekka> and also a big part of subversion (done a different way)
13:25:54 <Zekka> and a big part of darcs and hg to boot!
13:25:55 * ski . o O ( .. clearly changing the history version shouldn't be a global state operation )
13:26:03 <Zekka> They don't all agree on exactly what that means!
13:26:32 * ski idly ponders lenses into other versions
13:26:53 <Zekka> Clearly we need a new source control system that unites all the common usecases for other source control systems
13:26:57 <Zekka> and also does our opinionated crap!
13:28:17 <nolrai> ski: f would just be "Even : nat -> Type" wouldn't it?
13:28:52 <ski> oh, you meant the evenness predicate
13:29:16 <ski> but then you don't get a list of proofs. you get a list of propositions
13:29:16 <nolrai> Though that would give us a list of types, which isn't actually a Type.
13:29:22 <ski> (or types, as the case may be)
13:29:26 <nolrai> Right.
13:30:03 <ski> i'm thinking the dependent `fmap' may need "abstract indices" of some kind
13:30:41 <ski> that may be problematic in case `F' is `Bag', e.g.
13:30:54 <nolrai> Yeah. Hmm. I think the original value works though.
13:31:02 <ski> "original value" ?
13:31:22 <nolrai> For container like things anyway.
13:31:46 <ski> (perhaps you mean naperian functors)
13:32:39 * ski . o O ( "What is a Naperian container?" <http://sneezy.cs.nott.ac.uk/containers/blog/?p=14> )
13:33:18 <nolrai> Not quite, because Bags work, but I'm not sure arbitrary Reader does?
13:33:59 <ski> why not ?
13:34:20 <ski> (bags don't have position)
13:35:02 <nolrai> Well okay, so you have (MkRead
13:35:04 <zennist> :t scanl
13:35:06 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
13:35:28 <dolio> But why did they invent another name for 'representable'?
13:36:00 <nolrai> Well okay, so you have (MkReader r) and a f, oh, yeah fmap is just concat. Duh.
13:36:02 <EvanR> er can i not do data Foo a = Foo !a ?
13:36:10 <EvanR> "unexpected strictness annotation"
13:37:09 <dolio> Are you sure that's what you wrote?
13:37:32 <nolrai> Ah, I think I see the issue. dep_fmap needs a "dependant functor". 
13:37:42 <ski>   fmap : ((x :) A -> B x) -> (as :) (R -> A) -> ((r :) R -> B (as r))    -- hm ?
13:38:25 <nolrai> Yeah, I think that looks right.
13:38:53 <nolrai> Thanks!
13:39:44 <ski> it's only the environment case
13:39:50 <EvanR> in fact it is not
13:41:56 <raf1> quit
13:45:09 <nolrai> Or does using "fmap : ((x:) A -> B x) -> (F A) -> (F ((x:A), B x)" work? You lose information...but I think unless the Functor's type side knows how to deal with heterogenious values, I think thats the best you can do?
13:48:41 <ski> i'm not quite sure what you mean by "the Functor's type side knows how to deal with heterogenious values"
13:49:26 <ski> but yes, given `(x :) A -> B x', you can get to `A -> (x :) A * B x'
13:56:06 <EvanR> what is better style, strict field or using bang patterns to construct the thing always
13:56:28 <EvanR> i guess with bang patterns you could choose laziness at some point without messing things up
13:57:15 <idev> is it eash to do a 'refresahble term' ?
13:57:17 <idev> something like
13:57:20 <idev> progress = 0/100
13:57:23 <idev> progress = 1/100
13:57:26 <idev> progress = 2/100
13:57:31 <idev> but instead of having new lines, having the 1 overwrite the 0
13:57:34 <idev> and the 2 overwrite the 1
13:57:35 <EvanR> theres at least one progress bar package
13:57:50 <idev> I was hoping something term level
13:57:54 <idev> where instead of just putStrLn
13:57:57 <EvanR> yes, terminal
13:58:03 <idev> I can say: write char c to location (x,y)
13:58:40 <hjljo> ansi-terminal, maybe?
13:59:04 <hjljo> http://hackage.haskell.org/package/ansi-terminal-0.6.2.3/docs/System-Console-ANSI.html
13:59:05 <EvanR> oh nice, theres also (Foo $!)
13:59:11 <idev> hmm, https://hackage.haskell.org/package/ansi-terminal looks nice
13:59:12 <idev> thanks!
14:11:16 <dolio> EvanR: If you can't unpack the field, I'm not sure it makes much difference.
14:12:16 <dolio> Unless you do the non-strict field, and accidentally take things out of something, and then re-strictify it to put it back in.
14:12:52 <dolio> Although I'm not 100% sure GHC will figure out that it doesn't have to re-strictify in the strict field case. It seems more likely, though.
14:15:30 <nineonine> yo
14:15:34 <nineonine> noob question
14:15:50 <nineonine> whats the easiest way to update ghc ?
14:15:54 <nineonine> to 8.0 ?
14:15:57 <nineonine> 8)
14:16:16 <monochrom> delete old ghc. install new ghc.
14:16:55 <nineonine> :)
14:16:57 <nineonine> thanks !
14:17:00 <nineonine> hehe
14:17:56 <mauke> use arch linux and wait until ghc 8 hits the repos
14:18:00 <dolio> I have all my GHCs installed in separate directories. If you do that, you don't even need the first step.
14:18:08 <idev> why is random testing better than rute force besting?
14:18:14 <idev> is it that brute force testing gets sstuck in a particular space
14:18:20 <idev> and never tests the full system ?
14:18:31 <idev> that somehow random sampling 'covers' the space better than brute force search ?
14:19:15 <dolio> What's "brute force" mean?
14:19:47 <dolio> Test every possible input?
14:20:26 <idev> yeah
14:20:29 <idev> a for loop over all possible inputs
14:20:45 <monochrom> random testing is not better. but random testing gives you an incentive to write down a specification.
14:20:56 <monochrom> writing specifications is better than not writing specifications.
14:21:02 <dolio> What if my input is an Int? That's 2^64 inputs you have to test for a single, one-argument function.
14:21:31 <idev> dolio: yeah; it mgiht take a while
14:21:41 <byorgey> what if the input is Integer?
14:21:55 <oherrala> Testing finite space with random cases have faster change to hit problems than more exhaustive brute force
14:24:53 <dolio> A single Int input is a very small search space. So if it already takes a very long time, how is exhaustive testing going to work for things that aren't nearly that trivial?
14:26:01 <mauke> let's test a C compiler!
14:26:08 <mauke> just iterate through all possible C programs
14:28:12 * hackagebot servant-router 0.7.1 - Servant router for non-server applications.  https://hackage.haskell.org/package/servant-router-0.7.1 (willfancher)
14:32:27 <idev> mauke: and see if said c programs halt
14:32:50 <mauke> #include __FILE__
14:33:12 * hackagebot np-extras 0.3.1.1 - NumericPrelude extras  https://hackage.haskell.org/package/np-extras-0.3.1.1 (BrentYorgey)
14:36:00 <EvanR> oherrala: hmmm... a faster chance ;)
14:36:15 <EvanR> what is the speed of an unladen probability distribution
14:41:29 <idev> is https://hackage.haskell.org/package/random-1.1/docs/System-Random.html the standard way to do random number generation in haskell
14:41:34 <idev> or is there some other library I should be using>
14:42:40 <dmj`> idev: there's also mwc-random, probably more performant
14:42:44 <dmj`> @package mwc-random
14:42:45 <lambdabot> http://hackage.haskell.org/package/mwc-random
14:43:15 * hackagebot ottparse-pretty 0.1.2.6 - Pretty-printer for Ott parse trees  https://hackage.haskell.org/package/ottparse-pretty-0.1.2.6 (BrentYorgey)
14:45:04 <idev> dmj`: is this Bryan o Sullivan guy trustworthy? has he has writen any other libraries? :-)
14:45:35 <idev> what does mwc stand for?
14:45:39 <geekosaur> >.>
14:46:14 <monochrom> yes, he is trustworthy
14:46:21 <dmj`> idev: I'd say so :) 
14:46:23 <djapo> hello world, im interested in building a new codec for video. i want to make a vector video codec. i know it has been done in the past but i have a new idea that i want to test
14:46:46 <geekosaur> multiply-with-carry, referring to the algorithm ("Marsaglia's MWC256 (also known as MWC8222) multiply-with-carry generator")
14:46:55 <monochrom> but am I trustworthy?
14:47:18 <djapo> are there any python libraries that can analyze a video frame by frame, i want to divide the video into segments to be encoded differently
14:47:21 <idev> can anyone here besides BOS certify that monochrom is brustworthy?
14:47:35 <idev> *trustworthy*
14:47:36 <dmj`> djapo: python? 
14:47:58 <djapo> i know those things are usually written in c or c++ but im not interested in speed
14:48:00 <geekosaur> (can you trust "reflections on trusting trust"?)
14:48:01 <ski> idev : are you trustworthy ?
14:48:08 <djapo> i want a quick turn around 
14:48:10 <idev> ski: I don't trust myself
14:48:12 <jle`> idev: is the concept of trustworthiness trustworthy?
14:48:12 * hackagebot vector-space-points 0.2.1.2 - A type for points, as distinct from vectors.  https://hackage.haskell.org/package/vector-space-points-0.2.1.2 (BrentYorgey)
14:48:33 <idev> ski: in fact, I ddefinitely don't turst code past me has written; and future me is going to be pissed off at the code I write today
14:48:57 <jle`> as a serious answer, System.Random and its utilities in the MonadRandom package are common, mwc-random is known to be a bit more performant i believe, but neither are suitable for cryptographic purposes
14:49:00 <geekosaur> djapo, asking about python libs in a haskell channel may not get you the turn-around you want...
14:49:06 <dmj`> trustworthiness you can trust in
14:49:19 <idev> jle`: noted; thanks
14:49:25 <dmj`> jle`: o/ 
14:49:34 <jle`> they should, however, be okay for scientific purposes i believe
14:49:38 <djapo> oh, lol wrong chanell sorry, tiny font :/
14:49:42 <jle`> but 'split' hasn't been rigorously looked at
14:49:49 <jle`> dmj`: \o
14:49:59 <ski> geekosaur : fyi, "Fully Countering Trusting Trust through Diverse Double-Compiling (DDC) - Countering Trojan Horse attacks on Compilers" by David A. Wheeler in 2009 at <http://www.dwheeler.com/trusting-trust/>
14:50:55 <geekosaur> ski: yep. was just going meta-silly on the trustworthiness discussion...
14:51:38 <idev> haskell's rule 34: you can start with anything, on topic or off topic, and the discussion ends up talking about research papers
14:52:20 <Hafydd> Isn't that more like Haskell's Godwin's Law?
14:52:33 * ski . o O ( "People who think they are trustworthy are not trustworthy." )
14:52:51 <Hafydd> Rule 34: If it exists, there is a research paper about it.
14:52:57 <idev> we now need someone to post a research paper about 34 / godwin's law
14:53:12 <idev> there's got to be something on arxiv
14:53:33 <monochrom> but it is not going to be a Haskell paper
15:00:23 <la_croix> hi all. for relatively small functions (~ 15 lines), how do you decide between case within the function vs. pattern matching the function?
15:00:38 <mauke> case/of is pattern matching
15:00:49 <maerwald> la_croix: usually depends whether I need a where-clause, which sucks on pattern  matching
15:01:09 <maerwald> mauke: you know what he means, stop nitpicking ;)
15:01:38 <la_croix> i know, it's more of an aesthetic thing
15:01:54 <la_croix> maerwald i don't need a where clause
15:01:54 <maerwald> it's not, when you need/want a where clause
15:01:57 <mauke> it might reduce future confusion
15:01:59 <maerwald> ok, then it doesn't matter
15:02:04 <maerwald> mauke: no, you're confusing
15:02:27 <mauke> present confusion, then
15:02:40 <la_croix> with case there's a little bit of structure that gets reused
15:02:41 <la_croix> like 3 lines
15:02:41 <hjljo> i like to use case if the alternative is repeat the fn name over many lines, looks neater to me
15:03:13 * hackagebot yesod-ip 0.1 - Code for using the ip package with yesod  https://hackage.haskell.org/package/yesod-ip-0.1 (andrewthad)
15:03:37 <maerwald> la_croix: well, pattern-matching on function input level also has the advantage that a potential reader catches it more easily without reading the whole function implementation
15:04:10 <maerwald> but that's rather minor
15:07:01 <urbank> I'm confused about something
15:07:18 <urbank> are type variables treated differently for datatypes and for functions?
15:07:34 <urbank> since in Maybe a = Just a | Nothing
15:07:44 <urbank> a can also be a function
15:07:59 <ski> hjljo : .. to me, that's an argument for repeating the name
15:08:25 <geekosaur> urbank, I'm not sure what you are asking.
15:08:38 <geekosaur> ("can also be a function"? that is also true for functions)
15:08:55 <geekosaur> you can however say that in `data Foo a = ...`, Foo is a function *at type level*
15:09:05 <ski> urbank : any type variable can be instantiated to a function type, if that's what you meant
15:09:57 <urbank> so why cant (x + y) be of type 'a'?  
15:10:05 <ski> maerwald : fwiw, i'd prefer they didn't stop nitpicking about such things
15:10:12 <urbank> f x y = x + y :: a
15:10:13 <monochrom> in "id :: a -> a", "a" can be a function too.
15:10:19 <maerwald> ski: I prefer they did
15:10:27 <mauke> urbank: because of the type of (+)
15:10:29 <geekosaur> urbank: because (+) plays a part in type resolution as well
15:10:32 <geekosaur> :t (+)
15:10:33 <lambdabot> Num a => a -> a -> a
15:10:33 <ski> @type let x = 0; y = 1 in x + y
15:10:35 <lambdabot> Num a => a
15:10:59 <geekosaur> so now you require a constraint Num a to make it possible to use (+)
15:11:46 <urbank> ah right (+) has a type which has to match 
15:12:18 <geekosaur> likewise, if you used == then you would be required to specify an Eq constraint
15:13:06 <geekosaur> equivalently: (+) and (==) require an additional parameter to be passed, telling it which instance of Num or Eq respectively to use
15:13:24 <geekosaur> we specify that as part of the type, not as a value
15:13:43 <hjljo> ski: why?  if you're just switching over a large enumeration, repeating the name of the function looks quite ugly
15:13:43 <tgeeky> anyone know if lambdabot is going to support GHC8 in the near future, or the medium-far future?
15:13:56 <geekosaur> @version
15:13:56 <lambdabot> lambdabot 5.0.3
15:13:56 <lambdabot> git clone https://github.com/lambdabot/lambdabot
15:14:07 <geekosaur> oh, right, the ghc version isn't in there any more :(
15:14:24 <geekosaur> anyway it's up to whoever's (a) maintaining lambdabot (b) running this instance of it
15:14:47 <monochrom> I think it is in the medium-far future
15:14:59 <tgeeky> yeah, ok.
15:15:01 <Clint> tgeeky: https://github.com/lambdabot/lambdabot/issues/139#issuecomment-219519010 suggests maybe
15:15:17 <tgeeky> Clint: thanks
15:15:18 <ski> hjljo : separate declarations can be reasoned about separately
15:16:19 <mauke> can, but also have to
15:17:20 <int-e> tgeeky: usually it takes a while for some of the more lambdabot dependencies (mueval in particular, but also some other packages that depend on template haskell) to catch up... I'll have a look at it
15:17:38 <int-e> some of the more *obscure*
15:18:12 <tgeeky> yeah. That is really what I was getting at: someone who knows how the deps are going to transition. Plus, there is the changing of code due to applicativedo, and other changes...
15:18:25 <tgeeky> I built lambdabot once. Once.
15:22:13 <ph88^> wooohooo https://ghc.haskell.org/trac/ghc/blog/ghc-8.0.1-released
15:22:43 <hexagoxel> does diffing in the history on pages haskellwiki simply not work?
15:22:48 <hexagoxel> or am i stupid?
15:23:59 <hjljo> ski: i don't understand the difference.  declarations are order dependant, just as case expression are
15:24:18 * hexagoxel won't d/l old source and new source just to run a diff on them. grr.
15:25:48 <ski> hjljo : the same difference as between `f x = ..x..' and `f = \x -> ..x..'
15:31:23 <hjljo> ski: sorry, i don't understand
15:31:35 <geekosaur> hexagoxel, diffing works but not via the compare button which seems to just show that version with diff info at the top. the cur/prev links do show diffs
15:34:06 <ski> hjljo : the difference isn't between expressiveness, but between presentation. with `case', i'm thinking about a compound `case' expression. with multiple defining equations, i'm thinking about separate equalities
15:38:43 <hexagoxel> geekosaur: thanks, but after trying every button/link it still only seems to display the equivalent of `git log --oneline a..b`, not an actual diff.
15:39:20 * hexagoxel won't waste any more time trying.
15:41:31 <Geff22_> Hi. I can't understand how vector working. Does it use IO operations during creation/destruction? If yes, how haskell know when they should perform IO destruction?
15:42:06 <ski> "vector" being ?
15:42:28 <mauke> http://hackage.haskell.org/package/vector ?
15:42:35 <Geff22_> yes
15:42:57 <dmj`> Geff22_: depends on what kind of vector you're using, there's trade offs
15:43:20 <dmj`> Geff22_: this is a good article on that, https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/vector.md
15:43:23 <hjljo> ski: ok, though they're very visually similar so i prefer the less redundant version. they're both still compound in the sense that the order matters, as you know of course
15:46:50 <hjljo> it's purely a matter of taste, i just don't get the reasoning about declarations separately part :p
15:53:15 * hackagebot midi-util 0.2 - Utility functions for processing MIDI files  https://hackage.haskell.org/package/midi-util-0.2 (mtolly)
15:53:46 <DanielDiaz> is there a way to get DEPRECATED warnings to work for class instances? I am going to remove an instance for a type, but I would like to warn in advance
15:56:33 <mauke> DanielDiaz: doesn't seem like it
15:56:59 <DanielDiaz> mauke: :(
15:57:52 <thomie> DanielDiaz: there's some discussion in https://ghc.haskell.org/trac/ghc/ticket/10071
15:59:25 <DanielDiaz> thomie: that looks more for deprecating type class methods, but no instances of those methods
16:01:44 <ryantrinkle> is there a datastructure like Data.Map, but with an ordering that is determined not by the keys, but by using special primitives, e.g. a way of inserting before another key?
16:02:22 * Clint squints.
16:03:09 <ryantrinkle> Clint: basically, a way of maintaining and editing a permutation, with persistent cursors over it
16:03:18 <ryantrinkle> (assuming you're squinting at me :P)
16:03:44 * Clint nods at ryantrinkle
16:04:09 <ryantrinkle> i guess my use case is a lot like what you'd use a a doubly-linked-list for in a mutable environment
16:04:41 <ryantrinkle> i kinda get the impression that a fingertree can do it, but i can't quite see my way there yet
16:09:30 <thomie> DanielDiaz: ok, this one then: https://ghc.haskell.org/trac/ghc/ticket/12014
16:10:39 <obadz> grrrrr wouldn't it make sense for (>=>) to be infixl 1 rather than infixr1 ?
16:12:35 <jmcarthur> ryantrinkle: Does your data have any structure that might somehow help find the key you want to insert before?
16:13:16 <ryantrinkle> jmcarthur: hmm, well, the keys can be chosen by the structure
16:13:22 <ryantrinkle> i don't actually care what they are
16:13:44 <ryantrinkle> so perhaps that helps?
16:13:57 <jmcarthur> I think so. This explains what you meant by doubly linked lists.
16:14:10 <ryantrinkle> yeah
16:14:36 <ryantrinkle> basically, i need to be able to insert something before/after something else that i have a reference to
16:14:37 <ryantrinkle> and delete things from it
16:14:40 <jmcarthur> There's always the old standby of simulating pointers with Ints and IntMaps. Not sure if you need to be concerned about garbage collecting with your use case.
16:14:46 <jmcarthur> Ah, deleting.
16:15:00 <jmcarthur> Explicit deletion is probably not so bad.
16:15:00 <ryantrinkle> yeah, that's true
16:15:40 <jmcarthur> Int and IntMap might seem inelegant, but it's pretty workable.
16:15:48 <ryantrinkle> yeah, i guess i could just build a linked list from intmap
16:17:28 <EvanR> TRIE LIFE
16:18:07 <jmcarthur> ryantrinkle: Do you need to support an arbitrary, dynamic number of cursors? Obviously if it's a statically knowable number you could make some sort of zipper.
16:18:54 <ryantrinkle> jmcarthur: yeah, unfortunately; need to have pretty much one cursor per item
16:19:13 <ryantrinkle> (each item will eventually be deleted)
16:19:27 <jmcarthur> Yeah, I think the IntMap thing is the best purely functional implementation I know of for this.
16:20:34 <ryantrinkle> jmcarthur: it looks like there's a discussion here: https://www.reddit.com/r/haskell/comments/2nepr0/implementing_doubly_linked_lists_in_haskell/
16:20:41 <ryantrinkle> involving "fingered catenable deques"
16:21:40 <Geff22_> Hm...So back to my question, does Vector use IO for creation? If does, how can implement something like that (in c++ I can use RAII for that)? 
16:24:12 <jmcarthur> ryantrinkle: It looks like that is basically meant to be a zipper with a static number of k cursors, where the cursors can be removed in O(k).
16:24:23 <ryantrinkle> jmcarthur: yeah
16:24:41 <ryantrinkle> i think the focus on O(1) makes that discussion not quite as useful for my specific use case
16:24:55 <ryantrinkle> i know i won't be getting any better than O(log(n)) here
16:25:06 <ryantrinkle> i just want to figure out how to do that :)
16:25:18 <ryantrinkle> the intmap thing will definitely work, but it feels like a very big hammer :P
16:25:27 <ski> Geff22_ : looks like some operations give you a monadic action, yes
16:27:01 <Geff22_> So, if I want something like RAII in C++, but in haskell, I should use monads?
16:28:00 <ryantrinkle> Geff22_: usually RAII-like stuff is done about like this in Haskell: https://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#v:withFile
16:28:05 <ryantrinkle> you write something like:
16:28:32 <pharaun> with<> can be a lil frustrating sometime
16:28:36 <pharaun> but its overall a good pattern
16:28:40 <ryantrinkle> withFile "someFile.txt" ReadMode $ \h -> doStuffWithTheFile h
16:29:14 <jmcarthur> Geff22_: Generally you'd use functions that under the hood use Control.Exception.bracket. The withFile function that ryantrinkle is talking about is an example of such a function.
16:30:20 <ski> @type Control.Exception.bracket
16:30:21 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:31:12 <Geff22_> Hm. Vector use IO for allocate/free memory?
16:31:14 <ski>   bracket setup teardown body
16:33:16 <alexv11> Geff22_: IO or ST monads
16:34:42 <Geff22_> I think that Vector use IO under hood when working with pointers. Or I'm wrong?
16:36:23 <EvanR> FFI may or may not require use of IO
16:36:36 <EvanR> if you are accessing foreign functions that are pure they dont need IO
16:37:01 <EvanR> Vector has an immutable and a mutable interface
16:37:27 <EvanR> you need IO or ST to mutate vectors
16:38:09 <EvanR> or some monad based on IO
16:41:33 <Geff22_> I found that Vector use Array# from ghc-prim. So it's handle by ghc.
16:43:22 <Geff22_> So it's impossible create something like Vector without using ghc-prim?
16:44:54 <alexv11> Geff22_: Vector.Storable uses http://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-ForeignPtr.html#v:mallocForeignPtrBytes
16:45:29 <EvanR> a Vector isnt exactly algebraic, in the sense of product, sum, function, and units
16:45:48 <EvanR> people want their O(1) indexing
16:46:48 <EvanR> but there is IntMap our lord and savior
16:46:58 * obadz taking a little poll
16:47:11 <obadz> I can't take the right-to-left stuff anymore
16:47:25 <obadz> what do you guys think of the ML-style operators here? https://gist.github.com/obadz/9f322df8ba6c8a9767683d2f86af8589#file-directionalops-hs-L81
16:47:51 <obadz> enables you to chain functions/functors/applicatives/monads relatively seamlessly
16:48:05 <obadz> infixity is key
16:48:09 <Geff22_> Thank you guys for your help.
16:48:37 <dalastboss> Hey, question: I am writing a compiler right now, and I have this problem where if compilation fails for some reason the target file is still opened and nothing is written to it
16:49:03 <Zemyla> dalastboss: That's what happens when you open a file in writing mode.
16:49:16 <Zemyla> Don't open the output file until compilation is successful.
16:49:40 <ski> obadz : that "right-to-left" `example' is hard to read, i think. nicer would be it goine left-to-right
16:49:52 <dalastboss> Right, makes sense. I'm having trouble getting the sequencing to work though
16:50:01 <obadz> ski: it goes left to right, that is top to bottom
16:50:24 <ski> obadz : i have to start reading that at the bottom, to see what happens
16:50:59 <obadz> ski: the transformations are applied to the input from top to bottom
16:51:17 <dalastboss> this is the relevant code if anyone could help
16:51:17 <dalastboss> http://pastebin.com/1qJiurbn
16:51:27 <dalastboss> about 15 lines
16:51:29 <obadz> ski: if you start reading at the bottom, all you know is that the penultimate intermediate result was multiplied by 3
16:51:54 * ski initially thought obadz was complaining about type operators in the MLs being written to the right of their type operands
16:52:11 <ski> obadz : yes, obviously you have to read it all
16:53:22 <ski> obadz : anyway, i think your code is hard to read, because i have to read it backwards
16:53:55 <obadz> ski: I'm just very surprised that you read it backward. I guess Haskell is very ingrained in you :)
16:54:31 <obadz> x1 = f1(x0); x2 = f2(x1); x3 = f3(x2) ⇒ do you seriously look at f3 first, then f2, then f1?
16:55:04 <ski> `f3' determines whether `x2' will be computed
16:55:38 <ski> comprehension order may differ
16:56:03 <obadz> our minds are wired differently :)
16:57:04 <ski> (one may try to help comprehension order by lifting out pieces with `let' and `where')
16:58:22 <obadz> sure, but doesn't change the fact that do/>>= flows in different direction than ./<$>/<*>
16:58:51 <EvanR> obadz: in foo `f` bar, the f happens first, not the foo
16:59:07 <EvanR> so left to right is kind of misleading
16:59:31 <EvanR> in f(g(x)) the f happens first
16:59:59 <obadz> only because the language is lazy
17:00:03 <EvanR> right
17:00:08 <obadz> that's try of >>= too
17:00:15 <obadz> s/try/true/
17:00:16 <EvanR> so "execution" could abort before it gets to the right
17:00:31 <EvanR> so its already left to right ;)
17:00:54 <obadz> yes >>= I'm fine with
17:01:09 <maerwald> what "happens" first is rather hard to say anyway, since optimization might do weird things to you in IO-free code
17:01:11 <EvanR> same with .
17:01:11 <obadz> I just want a nicer name for & and equivalents for flip <$> and flip <*>
17:01:52 <EvanR> <&> = flip (<*>)
17:01:55 <obadz> forget what happens when, but what do you want to read first when you look at code
17:01:58 <maerwald> and it _shouldn't_ matter
17:01:59 <EvanR> er
17:02:01 <EvanR> <&> = flip (<&>)
17:02:03 <EvanR> er
17:02:05 <EvanR> <&> = flip (<$>)
17:02:30 <obadz> I find & visually very unappealing in this role
17:02:51 <EvanR> obadz: im writing some combinators where the outer most wrapper takes precedence, so i have to look at a chain of . from top to bottom
17:02:53 <benzrf> @hoogle f (a -> b) -> a -> f b
17:02:53 <obadz> also I've deliverately picked 3 character long operator names so that they'll line up easily like in the example
17:02:54 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
17:02:54 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
17:02:54 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
17:03:00 <benzrf> smdh
17:04:02 <Rotaerk> when you read procedural code from top to bottom, which is what most programmers are used to, it's kind of like building up to the purpose of the function from the ground up... details first, and then you eventually tie them together by the end
17:04:04 <EvanR> like i was saying yesterday, the problem is application, toss it out 
17:04:38 <EvanR> Rotaerk: yeah ive been writing javascript upside down, the punchline first, then the gritty details below
17:04:49 <EvanR> thanks to the scoping rules
17:05:00 <Rotaerk> expression-based programming tends to be the reverse... you get a better idea of the goal up-front
17:05:02 <Rotaerk> yea
17:05:07 <obadz> :t flip (fmap . flip id) -- benzrf 
17:05:09 <lambdabot> Functor f => f (b1 -> b) -> b1 -> f b
17:05:24 <benzrf> obadz: yeah but i not infrequently find myself wanting to do this concisely
17:05:57 <maerwald> Rotaerk: I think it's just more random, it might be any way around
17:06:11 <Rotaerk> maerwald, what's more random?
17:06:13 <maerwald> also depending on the preferences of the programmer
17:06:24 <EvanR> define foo as bar baz quux where
17:06:27 <EvanR>   ...
17:06:28 <maerwald> how to _read_ code... can be upside down, left-to-right, right-to-left, random jumping
17:06:29 <EvanR>    ...
17:06:30 <jmcarthur> I like to read left-to-right, so I use (.). ;)
17:06:31 <maerwald> whatnot
17:06:49 <EvanR> the order of ... isnt that important
17:06:52 <lpaste_> tippenein pasted “Stream fold into Map” at http://lpaste.net/164124
17:06:59 <jmcarthur> That was tongue-in cheek. Really I just mean to say that the order you read in doesn't matter and you should just write code to be clear.
17:07:08 <nitrix> class Ord k => Gridable p where extractX :: p -> k
17:07:16 <nitrix> I'm getting an error that k isn't in scope.
17:07:34 <EvanR> maybe you need ScopedTypeVars?
17:07:40 <tippenein> anyone point me in the right direction with the above problem - streaming fold into a Map
17:07:48 <EvanR> nevermind you shouldnt
17:07:59 <nitrix> EvanR: Is this a case of functional dependency?
17:08:04 <ski>   class Gridable p where extract :: Ord k => p -> k  -- ?
17:08:13 <nitrix> Oh.
17:08:14 <EvanR> nitrix: oh, you didnt include k in the head
17:08:21 <EvanR> or that
17:08:24 <nitrix> ski: There's two extract, extractX and extractY
17:08:27 <dfeuer> EvanR, I disagree. ScopedTypeVariables is an always thing.
17:08:33 <jmcarthur> tippenein: Do you know how you would do it with foldl?
17:08:36 <nitrix> ski: Both must have the same type Ord k => k
17:08:52 <dfeuer> Except when I have my containers-comaintainer hat on, and care overly much about hypothetical portability.
17:09:06 <ski> nitrix : `p' determines `k' ?
17:09:23 <nitrix> ski: yes.
17:09:30 <ski> nitrix : either add `k' as an argument to `Gridable', or change `k' into an associated type
17:09:45 <nitrix> I can probably do that.
17:09:49 <ski> nitrix : in either case, keep the `Ord' superclass
17:10:15 <ski> nitrix : in the extra argument case, also add the FD
17:10:59 <nitrix> It compiled, but it's very minimal so far.  class Ord k => Gridable p k where extractX :: p -> k;  extractY :: p -> k
17:11:07 <nitrix> With MultiParamTypeClasses.
17:11:32 <ski> yeah, s/Gridable p k/Gridable p k | p -> k/
17:11:34 <tippenein> jmcarthur: foldl (\t -> Map.insertWith (+) t 1) initialMap id
17:11:50 <nitrix> ski: I know about those, but I don't understand them well yet.
17:11:55 <nitrix> ski: Why is it not complaining?
17:12:05 <ski> `p -> k' there means : `p' determines `k'
17:12:14 <nitrix> Oh, it'll complain when I'l have an instance.
17:12:19 <nitrix> More than one most likely.
17:12:26 <ski> without it, you're allowing multiple instances for the same `p', but different `k's
17:12:39 <jmcarthur> tippenein: Well, foldl wouldn't have the id, but it looks like you have the idea for Pipe.fold already.
17:12:45 <ski> with it, you'll get less ambiguity
17:12:47 <nitrix> ski: What if it's possible?
17:12:49 <tippenein> I believe the `m b` returned should be a SafeT Map.Map Text Int
17:13:01 <ski> nitrix : then `p' doesn't determine `k'. so leave the FD out
17:13:17 <nitrix> ski: Someone could have a Gridable Point3D Integer and, or a Gridable2D Double if they want to.
17:13:18 <tippenein> jmcarthur: I appreciate the sanity check
17:13:24 <nitrix> Whoops
17:13:25 <ski> nitrix : and you're in luck, since both methods mention both `p' and `k'
17:13:37 <nitrix> Gridable Point2D Double was the second example.
17:13:38 <ski> nitrix : that's fine
17:13:45 <ski> as long as you make up your mind
17:14:03 <ski> hm, well
17:14:21 <jmcarthur> tippenein: I don't think that return type looks like. I would expect it to have a type more like (SafeT IO (Map.Map Text Int)).
17:14:37 <ski> if you have the FD, then `Gridable Point3D Integer' and `Gridable Point3D Double' wouldn't be allowed at the same time
17:14:39 <jmcarthur> *looks right
17:14:57 <ski> regardless of the FD, `Gridable Point3D Integer' and `Gridable Point2D Double' would be allowed at the same time
17:14:58 <nitrix> ski: Yeah gotcha.
17:15:15 <nitrix> My example was bad. I do not think I'll have the overlapping instance case yet.
17:15:39 <nitrix> So I'll put the FD, but meh. How bad is it if I don't ?
17:15:42 <EvanR> i feel like associated type synonym would work better
17:16:05 <ski> EvanR : that implies that `k' is determined by `p'
17:16:15 <ski> EvanR : .. which now it seems that nitrix don't want
17:16:18 <EvanR> if you add the argument
17:16:25 <EvanR> then it is, and its a variable
17:16:47 <tippenein> jmcarthur: ah yes. you're right. Forgot about reading the files in
17:17:03 * ski isn't following EvanR
17:17:22 <EvanR> p :: * -> *
17:17:32 <EvanR> type PointType (p x) = x
17:18:05 <EvanR> or more -> * if this is a container
17:18:33 <nitrix> I'm okay for now.
17:18:42 <nitrix> I'll ask when things actually stop to typecheck :)
17:18:43 <ski> nitrix : it can be good to try to think about whether some of the parameters determine some of the others, before writing code which may depend on it
17:18:56 <nitrix> ski: Good advice.
17:19:10 <ski> EvanR : i think in nitrix' case, both `p' and `k' had kind `*'
17:19:16 <nitrix> Correct.
17:19:29 <EvanR> why not parameterize the structure by the k
17:19:46 <nitrix> I am doing just that.
17:20:09 <EvanR> then the associated type should work great
17:20:18 <nitrix> I'm just scared because it's not my first time trying to implement this KdTree variant and failed miserably.
17:20:28 <nitrix> Mhm. I'll ask when I have a more concrete problem.
17:20:35 <ski> ok
17:20:56 <ski> EvanR : ok, i see what you mean
17:22:20 * ski doesn't really like defining that associated type for every `p', though
17:23:06 <ski> (.. and, i'm not seeing how to keep the `Ord' superclass, with that approach)
17:23:22 <EvanR> i just did something like this
17:24:03 <EvanR> http://lpaste.net/164125
17:27:11 <ski> that doesn't have something like `type PointType (p x) = x'
17:28:28 <EvanR> i updated the paste with an instance
17:29:49 <ski> oh. that has a associated type for the particular `Plan', not for every `p' (of appropriate kind)
17:29:58 <EvanR> right
17:30:14 <EvanR> so maybe it will work with a fundep instead
17:30:28 <ski> no objection then :)
17:30:41 <EvanR> it makes more sense to me with type families
17:30:43 <ski> yeah, MPTC&FD would also work
17:31:00 <EvanR> this is a one parameter type class in my head
17:31:38 * ski recalls a paper proposing adding type classes that are functions rather than predicates
17:32:27 * EvanR boggles
17:33:28 <ski> (something like `class PrintfType (a :: *) :: * where printf :: String -> PrintfType a', iirc)
17:38:19 * hackagebot gtk2hs-buildtools 0.13.1.0 - Tools to build the Gtk2Hs suite of User Interface libraries.  https://hackage.haskell.org/package/gtk2hs-buildtools-0.13.1.0 (HamishMackenzie)
17:41:15 <lpaste_> tippenein pasted “Couldn't match type ‘Text.Text’ with ‘X’” at http://lpaste.net/164128
17:47:00 <lpaste_> tippenein revised “Stream fold into Map”: “Stream fold into Map” at http://lpaste.net/164124
17:47:28 <tippenein> it seems close now. Never seen the couldn't match Text with X error before
17:47:55 <Rotaerk> tippenein, what line is it referring to
17:48:21 <tippenein> the last line in hoodProducer
17:48:24 <tippenein> the >-> mapper
17:48:49 <Rotaerk> getInputFiles is what type?
17:49:32 <tippenein> not sure the exact type, but it's a Stream of Text
17:50:13 <Rotaerk> the X in that position means that it's expecting a Proxy that produces nothing; a consumer I think; but you provided it a pipe
17:50:48 <Rotaerk> yea that's why; you're using runEffect... which requires an effect
17:51:12 <Rotaerk> but your pipeline ends with something that produces
17:51:51 <Rotaerk> tippenein, basically, mapper is producing data, but you're not consuming/using it
17:51:54 <tippenein> the pipeline should be consumed by `foldIntoMap`
17:52:12 <tippenein> so, I'm using runEffect and such incorrectly?
17:52:31 <Rotaerk> runEffect is supposed to take a completed pipeline, one that doesn't have any inputs or outputs...
17:52:38 <Rotaerk> it's the last thing you call, basically
17:52:54 <Rotaerk> have you looked at the pipes tutorial?
17:53:08 <Rotaerk> (incidentally I just learned that today...)
17:53:15 <tippenein> I have.
17:53:22 <tippenein> Not well enough apparently
17:54:27 <tippenein> hmm, this will mess up my assumptions about the types I think
17:55:24 <tippenein> and I'll get ambiguous type errors if I don't specify
17:55:47 <Rotaerk> time to figure out pipes-network...
17:56:16 <Rotaerk> pipes-concurrency is nice; I'll have trouble deciding what to use from that and what to use from haskell-distributed
17:56:17 <tippenein> never looked at that one
17:56:36 <tippenein> just pipes-text and the main one
17:58:19 * hackagebot hobbits 1.2.2 - A library for canonically representing terms with binding  https://hackage.haskell.org/package/hobbits-1.2.2 (EddyWestbrook)
18:00:11 <Rotaerk> heh, hobbits
18:00:53 <Rotaerk> I have no idea what it does though; the package description is greek to me
18:13:35 <dfeuer> Whyyyyyyy
18:13:38 <dfeuer> This does not make sense.
18:13:40 <dfeuer> UGH.
18:14:20 * dfeuer curses the inliner some more. I don't really know if it's at fault but it's always the first thing I blame.
18:20:19 <athan> Hi everyone. So I've been seeing some buzz going around about substructural type systems; what's the reason for this? Is it true that a linear expression (i.e. one that strictly uses the variables it abstracts _once_) can memory details, for instance with copying the values applied to it?
18:26:23 <dfeuer> Ffff
18:28:21 * hackagebot glib 0.13.3.0 - Binding to the GLIB library for Gtk2Hs.  https://hackage.haskell.org/package/glib-0.13.3.0 (HamishMackenzie)
18:30:11 <jmcarthur> athan: "can memory details"?
18:31:47 <JuanDaugherty> memoize prolly
18:35:10 <dfeuer> Huhhhhh...
18:35:14 <dfeuer> So touchy.
18:35:29 <dfeuer> If I don't do things just right, Ints get boxed.
18:35:54 <dfeuer> WHYYYYY
18:43:21 * hackagebot cairo 0.13.2.0 - Binding to the Cairo library.  https://hackage.haskell.org/package/cairo-0.13.2.0 (HamishMackenzie)
18:44:52 <obadz> :t (=<<) . flip flip ([]) . (<*| return) . (if' .) -- the value of type signatures…
18:44:53 <lambdabot>     Not in scope: ‘<*|’
18:44:53 <lambdabot>     Perhaps you meant one of these:
18:44:53 <lambdabot>       ‘<*’ (imported from Control.Applicative),
18:45:00 <obadz> oops
18:45:23 <obadz> :t (=<<) . flip flip ([]) . (<*> return) . (if' .) -- the value of type signatures…
18:45:24 <lambdabot>     Not in scope: ‘if'’
18:45:25 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
18:45:31 * obadz gives up
18:48:22 * hackagebot pango 0.13.2.0 - Binding to the Pango text rendering engine.  https://hackage.haskell.org/package/pango-0.13.2.0 (HamishMackenzie)
18:48:24 * hackagebot gio 0.13.2.0 - Binding to GIO  https://hackage.haskell.org/package/gio-0.13.2.0 (HamishMackenzie)
18:48:26 * hackagebot gtk3 0.14.3 - Binding to the Gtk+ 3 graphical user interface library  https://hackage.haskell.org/package/gtk3-0.14.3 (HamishMackenzie)
18:48:28 * hackagebot gtk 0.14.3 - Binding to the Gtk+ graphical user interface library.  https://hackage.haskell.org/package/gtk-0.14.3 (HamishMackenzie)
19:00:57 <dfeuer> Is there a bit hack to take   max 0 x, when x is an Int?
19:04:48 <EvanR> hmm .oO x - x = 0
19:05:04 <EvanR> whether or not x is negative ;)
19:05:54 <EvanR> you can multiply by the complement of the sign bit
19:06:45 <athan> jmcarthur: I don't know why I typed that, I meant "can evade memory copying" ><
19:06:52 <dfeuer> EvanR, I found one that uses subtractio and a shift.
19:07:00 <dfeuer> On the big bit hacks page.
19:07:03 <athan> like if I did `(\x -> x) 7`, I can just redirect a pointer
19:07:19 <athan> while with `(\x -> x + x) 7`, I need to copy `7` before computing
19:07:21 <athan> or soemthing
19:07:25 <dfeuer> But then I realized that's probably not quite what I need.
19:08:05 <EvanR> athan: blasphemy... add can refer to the same place for both args ;)
19:08:22 * hackagebot fold-debounce 0.2.0.2 - Fold multiple events that happen in a given period of time.  https://hackage.haskell.org/package/fold-debounce-0.2.0.2 (debugito)
19:09:18 <athan> EvanR: Could that be also stated for something like `(\f x -> f x x)`?
19:10:18 <athan> where `f = \a b -> ... `, where `a` and `b` might be used multiple times throughout the body?
19:11:52 <EvanR> well i think the point is to avoid alias references
19:14:06 <dfeuer> Grrrrrrr! Why is this stuff so absurdly touchy?
19:15:02 <ski> @type let if' :: Bool -> a -> a -> a; if' = undefined in (=<<) . flip flip ([]) . (<*> return) . (if' .)  -- obadz
19:15:03 <lambdabot> (a -> Bool) -> [a] -> [a]
19:21:42 <Rotaerk> hmm, I wonder why pipes-network's "safe" module includes a fromConnect (Producer') and toConnect (Consumer'), but not a bi-directional connection of type (Client')
19:23:29 <athan> EvanR: Alias references?
19:27:05 <ryantrinkle> are there any Data.Map-like datastructures where `union` is better than linear?
19:27:21 <ryantrinkle> (is that even possible?)
19:29:06 <simpson> ryantrinkle: There's several ways to phrase the typical suspects so that the union operation is basically lazy and doesn't do any of the actual union work.
19:29:15 <simpson> But that's probably not what you were looking for.
19:31:54 <ryantrinkle> simpson: hmm, well, i'm not completely sure
19:32:51 <ryantrinkle> i guess the issue is that the running times aren't quite descriptive enough
19:33:10 <ryantrinkle> e.g. Map.union Map.empty x is surely O(1), regardless of the size of x
19:38:24 * hackagebot fold-debounce-conduit 0.1.0.2 - Regulate input traffic from conduit Source with Control.FoldDebounce  https://hackage.haskell.org/package/fold-debounce-conduit-0.1.0.2 (debugito)
19:43:24 * hackagebot stopwatch 0.1.0.2 - A simple stopwatch utility  https://hackage.haskell.org/package/stopwatch-0.1.0.2 (debugito)
19:45:58 <dfeuer> GHC's join point stuff is seriously annoying me right now.
19:46:46 <athan> Is there a preorder for how unified two terms are?
19:47:02 <athan> where the top element is "unified"?
19:47:03 <ryantrinkle> simpson: so, one way of stating what i'm looking for is: a finger tree where I can efficiently find a particular element
19:47:17 <ryantrinkle> (to remove it, insert before it, etc.)
19:47:43 <ryantrinkle> it seems like i can use a Set as (part of) the measure monoid
19:47:58 <ryantrinkle> but set unions may be slow enough to make that approach very bad
19:48:59 <Rotaerk> darn... looks like pipes-network is incomplete and not really being supported
19:49:08 <scshunt> what on earth?
19:49:20 <scshunt> does newtype deriving not automatically derive base classes?
19:49:25 <dfeuer> ryantrinkle, you certainly can have a fingery search tree, but I don't think it's going to give you what you want.
19:50:09 <ryantrinkle> dfeuer: what i'm hoping to achieve is something like a doubly-linked-list, except not based on mutation, and also with a monoidal summary that can be efficiently rebuilt
19:50:33 <dfeuer> ryantrinkle, can you be more specific about what operations you need?
19:51:37 <ryantrinkle> dfeuer: sure! i need to be able to hold "pointers to nodes" of some kind, that give me (reasonably) efficient "delete this node" and "insert a new node before this node (and give me back the pointer to it)"
19:51:59 <ryantrinkle> i don't care too much what structure the pointers have - they can be totally opaque
19:52:31 <geekosaur> scshunt, I'm not sure what you're asking. you have to name what is to be derived, and there *are* some limitations (for example it can't deal with existentials, and therefore also has problems with GADTs)
19:52:33 <ryantrinkle> if i didn't need "insert before", i might just use an IntMap and then delete stuff from it
19:52:39 <ryantrinkle> (although that doesn't give me the monoidal summaries)
19:52:43 <ski> scshunt : nope
19:53:11 <ski> geekosaur : presumably they want to only name `Monad', and having `Applicative' and `Functor' be implied, or somesuch
19:54:05 <ryantrinkle> dfeuer: does that description make sense?
19:54:07 <geekosaur> ah. right, not that either. it does seem like a reasonable extension, and not one that people would have thought of before really
19:54:24 <dfeuer> ryantrinkle, I think so. I'm thinking. I might have the beginning of an idea...
19:54:26 <geekosaur> in other words, propose it! :)
19:55:08 <dfeuer> ryantrinkle, actually, I do have an idea, but I'm not sure you're going to like it :P
19:55:19 <geekosaur> it's not the sort of extension that is likely to cause problems of any kind (hopefully including backward compatibility)
19:55:29 <ryantrinkle> dfeuer: haha, what's that?
19:55:37 <dfeuer> What if you use (something like) Data.Map, with Rational keys?
19:55:50 <ryantrinkle> dfeuer: huh, that's a very interesting idea
19:55:54 <dfeuer> You can ask Data.Map for information about keys right before and right after some spot,
19:55:58 <dfeuer> and average them.
19:56:03 <dfeuer> Er..
19:56:09 <dfeuer> That's not what I mean.
19:56:13 <geekosaur> what happens when your Rational can be normalized?
19:56:24 <dfeuer> Brain still churning.
19:56:31 <dfeuer> Nope, no good.
19:56:34 <ryantrinkle> hmm, after a string of insertBefore
19:56:35 <dfeuer> Forget that idea.
19:56:45 <dfeuer> I'm searching wrong.
19:56:45 <ryantrinkle> nbd :)
19:56:58 <dfeuer> You want to be able to find the thing by node value.
19:57:04 <ryantrinkle> right
19:57:07 <dfeuer> Hrmf.
19:58:16 <zRecursive> In ghc-8.0.1, why do i get "Warning: If linking fails, consider installing KB2533623." ?
19:58:40 <ryantrinkle> i think the "using an IntSet for searching the fingertree" thing will *work*, but it seems like there should be more structure i can exploit
19:59:19 <geekosaur> zRecursive, that sounds like a Windows knowledge base article id. and indeed: https://support.microsoft.com/en-us/kb/2533623
20:00:13 <zRecursive> geekosaur: there seems no linking fails
20:00:17 <EvanR> ryantrinkle: what sort of sacrifices are allowed for your structure
20:00:35 <geekosaur> it can't know beforehand if it's going to run into that problem, most likely
20:00:36 <EvanR> to go along with all the things it can do well
20:00:41 <ryantrinkle> EvanR: well, i don't care at all about the structure of the keys; I don't think i even need Eq on them
20:00:54 <ryantrinkle> the structure issues them, and i later use them for insertBefore and delete
20:01:04 <EvanR> whats insertBefore 
20:01:17 <ryantrinkle> just like on a mutable doubly-linked list
20:01:30 <EvanR> so a reference can go the next and previous thing
20:01:33 <dfeuer> ryantrinkle, what happens to a key whose value has been removed? 
20:01:54 <dfeuer> Do we have to know that it's invalid and avoid issuing it again?
20:01:55 <EvanR> Data.Sequence ?
20:02:07 <ryantrinkle> EvanR: i don't need to be able to traverse from there, but i do need to be able to insert it, and get the pointer to the new node
20:02:24 <EvanR> ryantrinkle: then how would anyone observe that it was actually put before?
20:02:28 <ryantrinkle> dfeuer: no, i think i can guarantee that keys are used in the correct order themselves
20:02:47 <EvanR> using toList or fold
20:03:13 <geekosaur> zRecursive, so it can't check beforehand to see if you have the necessary secure-linking APIs added to your Windows installation, therefore it warns you that linking may fail if it needs to use them
20:03:24 <ryantrinkle> EvanR: yeah, basically
20:03:35 <geekosaur> and if that happens then you need to install the update from that KB article for your Windows
20:03:45 <dfeuer> ryantrinkle, the "putBefore" thing doesn't make much sense to me. How can you observe the relationship between the values? 
20:03:47 <EvanR> ryantrinkle: maybe you can use a Data.Trie, and insertBefore some ByteString effectively uses that ByteString with an additional zero byte on the end
20:04:06 <ryantrinkle> well, i just mean that you don't need to be able to start any kind of traversal from the pointers
20:04:09 <EvanR> or some way of tricking the trie into doing what you want
20:04:14 <ryantrinkle> there does need to be an overall traversal
20:04:23 <dfeuer> ah.
20:04:32 <ryantrinkle> (actually, a monoidal summary, but i don't want to complicate things any further just yet)
20:04:55 <dfeuer> Monoidal summary ~= toList, so whatever.
20:04:59 <ryantrinkle> right
20:05:13 <EvanR> insertBefore is to append 0 to the key, insertAfter is to append 1 to the key
20:05:20 <EvanR> the first thing uses empty string as the key
20:05:53 <ryantrinkle> EvanR: yeah, data.trie would work, although there's still a key allocation issue
20:06:03 <ryantrinkle> it sort of just pushes the unbalancedness down
20:06:07 <EvanR> thats determined by the strategy here
20:06:24 <ryantrinkle> yeah, makes sense
20:06:39 <ryantrinkle> one thing i need to be able to handle is a huge number of insertBefore followed by deletions
20:06:46 <ryantrinkle> like, insert something, delete it, repeat
20:06:52 <geekosaur> zRecursive, looks like it should only issue that warning on win7 or vista, since it can't determine if those OSes have the API patch. (later OSes came with it)
20:07:00 <EvanR> im doing "huge number of deletions" using a difference of maps
20:07:09 <geekosaur> https://ghc.haskell.org/trac/ghc/ticket/10955
20:08:10 <EvanR> ryantrinkle: what about storing in whatever data structure with a rational priority, then sorting when you do the summary, i guess not efficient enough
20:08:53 <zRecursive> geekosaur: From void warnMissingKBLibraryPaths( void ) { \n  static HsBool missing_update_warn = HS_BOOL_FALSE; \n    if (!missing_update_warn) {\n        debugBelch("Warning: If linking fails, consider installing KB2533623.\n");\n        missing_update_warn = HS_BOOL_TRUE;\n    }} in rts/Linker.c, it seems ghc will always report such a warning ?
20:08:54 <ryantrinkle> EvanR: yeah, i was thinking of that
20:09:03 <ryantrinkle> i wonder if there's some sort of kd-tree-like approach
20:09:23 <ryantrinkle> that interleaves the "lookup by key" concept with the "things are in a particular order" concept
20:09:36 <geekosaur> zRecursive, at this point I send you to #ghc. I am not a ghc dev
20:09:44 <geekosaur> nor a Windows dev
20:10:35 <zRecursive> geekosaur: ok, it is not serious problem.
20:16:07 <ryantrinkle> dfeuer, EvanR: perhaps another angle is the idea that this thing is just a Map combined with a permutation on the keys
20:16:19 <ryantrinkle> are there decent persistent datastructures for storing permutations?
20:16:29 <ryantrinkle> (that you can delete from, and such)
20:22:53 <EvanR> hmm http://www.itu.dk/research/theory/bpl/doc/ml/doc/kernel/SigPERMUTATION.html
20:23:20 <EvanR> "bigraph permutations" ...
20:23:25 * hackagebot pusher-ws 0.1.0.0 - Implementation of the Pusher WebSocket protocol  https://hackage.haskell.org/package/pusher-ws-0.1.0.0 (barrucadu)
20:23:43 <EvanR> https://hackage.haskell.org/package/permutation-0.5.0.5/docs/Data-Permute.html
20:24:02 <ryantrinkle> EvanR: i was just looking at that :)
20:24:11 <ryantrinkle> however, it seems to use an array as the way of storing the permutation
20:24:18 <ryantrinkle> there's no real deletion or insertion available, afaict
20:24:28 <EvanR> yes it cant delete, also, what would that mean
20:24:40 <ryantrinkle> haha yep, good question
20:30:13 <Rotaerk> hmm in pipes, is there something like await, but for going upstream
20:30:34 <Rotaerk> particularly, with the Server' type, I see a respond function, but I don't see how to receive requests from downstream
20:33:48 <Rotaerk> respond seems to mean the same thing as yield (but works on bidirectional communication); request is basically the same except in the opposite direction...
20:34:03 <Rotaerk> but I see nothing akin to await
20:39:13 <scshunt> I officially dislike operational, sigh
20:39:31 <Rotaerk> hmm maybe for TCP I should just have two separate proxies for the same connection... a consumer and a producer... looks like the two-way communication is actually a request-and-block-until-reply, both "respond" *and* "request" do this
20:42:20 <la_croix> how do i go from [IO Double] to working with [Double]?
20:42:49 <scshunt> la_croix: 
20:42:51 <scshunt> :t sequenceM
20:42:53 <lambdabot>     Not in scope: ‘sequenceM’
20:42:53 <lambdabot>     Perhaps you meant one of these:
20:42:53 <lambdabot>       ‘sequence_’ (imported from Data.Foldable),
20:42:58 <scshunt> err
20:43:14 <Rotaerk> :t sequence
20:43:15 <scshunt> :t sequence :: [IO a] -> IO [a]
20:43:16 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
20:43:16 <lambdabot> [IO a] -> IO [a]
20:43:46 <la_croix> ah
20:43:50 <Rotaerk> it doesn't get you [Double], but it gets you IO [Double]
20:44:30 <la_croix> that's what i was looking for thanks
20:47:08 <EvanR> :t sequence `asAppliedTo` [return 3.14]
20:47:09 <lambdabot> (Fractional a, Monad m) => [m a] -> m [a]
20:52:03 <Rotaerk> :t asAppliedTo
20:52:04 <lambdabot> (a -> b) -> a -> a -> b
21:02:13 <EvanR> :t const `asAppliedTo` (undefined :: a -> b)
21:02:14 <lambdabot> (a -> b1) -> b -> a -> b1
21:02:54 <EvanR> :t asAppliedTo `asAppliedTo` asAppliedTo
21:02:55 <lambdabot> ((a -> b) -> a -> a -> b) -> (a -> b) -> (a -> b) -> a -> a -> b
21:03:27 * hackagebot network-multicast 0.0.12 - Simple multicast library  https://hackage.haskell.org/package/network-multicast-0.0.12 (AudreyTang)
21:03:43 <EvanR> :t (fix (`asAppliedTo` "foo"))
21:03:44 <lambdabot> [Char] -> b
21:04:06 <EvanR> :t (fix (`asAppliedTo` asAppliedTo))
21:04:07 <lambdabot> ((a -> b1) -> a -> a -> b1) -> b
21:25:20 <idev> how does System.Random and MonadRandom relate?
21:28:57 <EvanR> its basically a state monad to use System.Random rngs
21:33:28 * hackagebot wai-handler-launch 3.0.2.1 - Launch a web app in the default browser.  https://hackage.haskell.org/package/wai-handler-launch-3.0.2.1 (MichaelSnoyman)
21:36:54 <la_croix> what function should i be using for linear interpolation
21:37:10 <la_croix> to get something like [0, 0.1, 0.2, 0.3, ... 0.8]
21:37:40 <la_croix> ah nevermind the regular list notation does it
21:37:45 <EvanR> > [0,0.1..0.8] :: [Deci]
21:37:47 <lambdabot>  [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8]
21:37:55 <EvanR> > [0,0.1..0.8] :: [Double]
21:37:56 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600...
21:38:01 <EvanR> yuck yuck
21:39:10 <EvanR> ski_: interesting, with the -> (forall e . Exception e => Either e a -> IO ()) way of doing a call back, it wont accept a Right value... saying e is ambiguous
21:39:30 <EvanR> im getting around it with a (handler `asAppliedTo` (Left dummyException)) (Right x)
21:40:05 <EvanR> which is insane
21:40:20 <EvanR> guess i can try scopedTypeVariables
21:41:51 <EvanR> when i encountered this sort of issue with exceptions a long time ago as a haskell beginner i was flabbergasted
21:44:26 <Rotaerk> bleh, not sure how to do this with pipes
22:39:11 <jle`> whoa, data instances can be newtypes or GADT's now
22:39:55 <jle`> but are data instances still useful now that we have injective type families?
22:42:51 <EvanR> does injective type families imply that errors of the form "type function may not be injective" go away?
22:43:18 <jle`> EvanR: only if the type family is explicitly declared to be injective
22:43:27 <EvanR> sweet
22:43:34 <jle`> (and of course, that it *is* injective)
22:43:40 <jle`> (but ghc should catch if it isn't, now)
22:44:34 <jle`> hm, it looks like the new 'undefined' and 'error' in Prelude uses the ?callStack stuff, does that affect performance at all if it's accidentally left in production?
22:45:05 <EvanR> or intentionallu
22:45:25 <jle`> also, replicateM's name is now a little confusing
22:45:27 <jle`> heh
22:45:36 <jle`> and zipWithM too
22:45:37 <EvanR> huh
22:45:43 <jle`> but i guess there isn't really a way around that
22:45:55 <jle`> replicateM :: Applicative m => Int -> m a -> m [a]
22:46:00 <EvanR> lol
22:48:10 <ski> should be `replicateA', no ?
22:48:26 <ski> @type liftM
22:48:27 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
22:48:28 <ski> @type liftA
22:48:30 <lambdabot> Applicative f => (a -> b) -> f a -> f b
22:50:56 <EvanR> :t replicateA
22:50:57 <lambdabot>     Not in scope: ‘replicateA’
22:50:57 <lambdabot>     Perhaps you meant one of these:
22:50:57 <lambdabot>       ‘Seq.replicateA’ (imported from Data.Sequence),
23:12:29 <idev> anyone here tried frege just for the Java eco system
23:18:20 <bramantio> hi all
23:18:28 <srhb> bramantio: Hi
23:18:32 * hackagebot base-prelude 1.0.1 - The most complete prelude formed from only the "base" package  https://hackage.haskell.org/package/base-prelude-1.0.1 (NikitaVolkov)
23:22:30 <EvanR> idev: i tried the haskell package java-bridge just for the ecosystem
23:32:07 <EvanR> gotta love it when a hole reports that it needs a type which is exactly listed in the bindings below, but using that in the place of the hole doesnt work
23:36:26 <Rotaerk> with pipes, they've got a pipes-safe package that lets a pipe own a resource, and then clean it up reliably when the pipe ends
23:36:53 <jle`> ski: base 4.9 has no replicateA, but replicateM is implemented for all Applicatives, heh
23:36:54 <Rotaerk> the problem I'm facing is ... how do I handle a case where I need two separate pipelines to have access to this resource
23:36:57 <jle`> oh well
23:37:50 <Athas> What is the simplest way to get a list of all files in a directory (i.e. the haskell equivalent of 'find dir -type f')?  Using the directory-tree library?
23:38:33 * hackagebot gtk3-mac-integration 0.3.3.0 - Bindings for the Gtk/OS X integration library.  https://hackage.haskell.org/package/gtk3-mac-integration-0.3.3.0 (HamishMackenzie)
23:38:35 * hackagebot gtk-mac-integration 0.3.3.0 - Bindings for the Gtk/OS X integration library.  https://hackage.haskell.org/package/gtk-mac-integration-0.3.3.0 (HamishMackenzie)
23:38:51 <Rotaerk> e.g. a TCP connection in which I need receipt of data to be pushed downstream through a pipeline, and then I have another pipeline where some a stream of events result in sending messages across that socket
23:39:04 <Rotaerk> I think those would be two separate threads
23:39:07 <EvanR> Rotaerk: hmm i seem to have heard that conduit has an advantage in this department, but maybe not
23:39:53 <EvanR> then the two threads dont really own the resource (individually)
23:40:00 <Rotaerk> true
23:40:04 <cocreature> Rotaerk: what behavior are your looking for if one thread exits?
23:40:10 <EvanR> they never did anyway, since it can be closed by remote host any time
23:40:32 <Rotaerk> yea I suppose I'll do the cleanup in the context that creates the connection and hooks up the pipelines to it
23:40:58 <srhb> Athas: Looks like you can flatten it and filter on the File constructor
23:41:22 <Athas> srhb: yes, it doesn't look too bad, but if someone else had already written the code...
23:41:42 <srhb> Athas: Sorry. :-)
23:53:34 * hackagebot record 0.4.1 - Anonymous records  https://hackage.haskell.org/package/record-0.4.1 (NikitaVolkov)
