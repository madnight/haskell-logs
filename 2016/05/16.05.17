00:07:38 * hackagebot type-list 0.3.0.3 - Operations on type-level lists and tuples.  https://hackage.haskell.org/package/type-list-0.3.0.3 (mjmrotek)
00:07:38 * hackagebot automotive-cse 0.1.4.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.4.0 (KeiHibino)
01:27:35 * hackagebot cabal-helper 0.7.1.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.7.1.0 (DanielG)
01:29:36 <fr33domlover> Is ApplicativeDo available in GHC releases?
01:30:15 <fr33domlover> it can be very useful for writing parsers without so many *>
01:30:41 <fr33domlover> (in a way that doesn't require Monad unnecessarily)
01:30:43 <cocreature> fr33domlover: it’s available in 8.0. the src for that is already released the binary tarballs and an official announcement should be released soon
01:31:04 <fr33domlover> cocreature, cool thanks!
01:50:36 <shanemikel> Dead link <- https://wiki.haskell.org/Zipper_monad/TravelTree
01:50:54 <shanemikel> err.. does anybody know where the code might be?
01:52:37 * hackagebot carray 0.1.6.4 - A C-compatible array library.  https://hackage.haskell.org/package/carray-0.1.6.4 (HenningThielemann)
02:01:56 <tsahyt> I'm working on an algorithm that iterates over a table until no changes are left to be made (much like bellman-ford). My first thought was to represent the table as an IntMap but then I realized that the indices are contiguous starting from 0, so a Vector would equally make sense. So my question is which would be more idiomatic haskell, and whether using a vector and mutation from the get go should be
02:01:58 <tsahyt> considered premature optimization.
02:02:58 <fr33domlover> tsahyt, vector would probably make sense here
02:03:23 <fr33domlover> especially if it's a low level algorithm, someone could be using it for high performance needs :P
02:03:43 <fr33domlover> an array could work too, if you don't need to change the size
02:03:49 <tsahyt> performance needs are high indeed, it turned out to be the bottleneck of my mockup implementation
02:03:50 <fr33domlover> (check out the array package)
02:04:08 <tsahyt> Vector does fusion though, so I might get away with writing code without explicit mutation
02:04:54 <fr33domlover> tsahyt, if you're into fine tuning, try several implementations (with arrays, mutable arrays, vectors etc.) and compare
02:05:04 <fr33domlover> then publish a graph and a blog post about it ;)
02:06:26 <merijn> tsahyt: Sounds like a graph algorithm, which one? :)
02:06:36 <merijn> <- collects "real world" algorithms
02:06:39 <tsahyt> merijn: computing the h-max heuristic for a STRIPS planning problem
02:06:59 <tsahyt> basically it's a generalized bellman-ford algorithm
02:07:43 <tsahyt> probably not the most efficient way to do it, but it's a starting point, and there are very limited resources on how to compute this stuff. all the papers just say "well yeah, it's polynomial" and that's about it.
02:08:18 <merijn> tbh, my intuition says haskell isn't too great at most graph algorithms efficiently for non-trivial graphs
02:08:49 <tsahyt> I'd say it depends on implementation. Graph algorithms are hard to do in idiomatic Haskell
02:09:35 <merijn> I read some of the existing papers, including the stuff Data.Graph is based on. They're pretty ingenious, but I don't see them scaling to medium size graphs, let alone big ones
02:10:19 <tsahyt> merijn: You mean Data.Graph.Inductive?
02:10:42 <tsahyt> i.e. the fgl
02:11:16 <merijn> yeah
02:11:18 <tsahyt> I keep forgetting that there's a Data.Graph in containers
02:12:12 <tsahyt> I find the idea behind fgl to be very elegant though. It's very nice to work with too. I haven't looked into the implementation though or done any benchmarks on big graphs.
02:13:17 <merijn> tsahyt: How big are the graphs you're working with?
02:13:45 <tsahyt> not extremely large. I'd have to do some counting to give you a number
02:14:29 <tsahyt> a couple of hundred nodes, maybe a few thousand at most
02:14:31 <merijn> Ballpark? 100s of vertices, 10,000s of vertices?
02:15:12 <tsahyt> at the point where we're talking tens of thousands of propositions in a planning problem, PSPACE-hardness kills all hope of solving it most of the time anyhow
02:20:10 <muzzle`> hi, I've got a question about aeson object creation. So normally I would do something like object ["a" .= a, "b" .= b] which works fine as long as I have values for every key. But what do I do if my values are (Maybe a) and I don't want the key in the object at all if i have value Nothing ? Is there some sort of shorthand or do i have to write it out (fairly tedious).
02:20:19 <tsahyt> is there any advantage to using iterate from Data.Vector over the one in Prelude when all I need is the last element that satisfies some criterion?
02:23:33 <pavonia> muzzle`: Object is simply a synonym for a special HashMap, so you can use the functions from that type to build a value
02:24:23 <pavonia> HashMap Text Value, in particular
02:29:17 <EvanR> muzzle`: isnt there something like .=?
02:30:42 <EvanR> question about RankN (i think), i can do ... -> forall a . (X, a -> F a) but not ... -> (X, forall . a -> F a), and i dont see why
02:31:15 <EvanR> forall a inside the tuple, typo
02:32:05 <merijn> EvanR: That's ImpredicativePolymorphism and the answer is basically "no one's really figured out the theory for typechecking that"
02:32:38 <EvanR> what exactly is impredicative about it
02:32:55 <merijn> EvanR: I would STRONGLY urge you to avoid the ImpredicativePolymorphism extension because it's prone to breakage and no one really knows how it should work (including SPJ)
02:33:08 <merijn> EvanR: A forall'ed type as argument to a type constructor
02:33:18 <EvanR> i see
02:33:39 <merijn> EvanR: I guess function arrows are also type constructors, but that part is well understood, hence why RankN exists
02:33:47 <EvanR> ImpredicativePolymorphism sounds interesting
02:33:52 <merijn> EvanR: The usuall solution is to use an existentially quantified newtype wrapper
02:34:14 <EvanR> the first way to write my function works fine
02:34:30 <EvanR> guess im lucky
02:34:37 <merijn> EvanR: I know, I really want it, but it's broken and using it leads to a path of tears and misery :\
02:35:26 <EvanR> it sounds interesting for being an extension which is not well understood ;)
02:35:27 <merijn> Impredicativity would also allow e.g. "Maybe (forall a. Foo a)"
02:35:31 <EvanR> i.e. what does it do?
02:35:37 <EvanR> does anyone know
02:35:53 <merijn> EvanR: Just that "allow forall'ed types as arguments to type constructors other than ->"
02:36:22 <EvanR> and... what happens?
02:36:37 <EvanR> it allows ill typed code?
02:37:23 <merijn> EvanR: There is no solid theory on how it should be typechecked/work, so no one really knows how it SHOULD compile
02:37:36 <merijn> GHC does *something*, but no one knows it that thing is theoretically sound
02:38:41 <EvanR> so ... -> (X, forall a . a -> a) should work
02:39:00 <EvanR> without the extension
02:39:10 <merijn> EvanR: No, because (,) is a type constructor
02:39:20 <merijn> EvanR: And you're passing a forall'ed type as second argument
02:39:30 <EvanR> not directly
02:39:54 <merijn> tbh, I'm also not 100% sure exactly when it'll work :)
02:54:28 <orion> Is it possible to use a guard on a record field?
02:55:24 <orion> Given a function foo which takes a record R { someByteString :: ByteString }, can I guard against "length someByteString != 32" ?
02:56:26 <tsahyt> orion: you can bring someByteString into scope with RecordWildcards
02:56:38 <tsahyt> or you could just use length (someByteString myRecord) != 32
02:57:25 <pavonia> foo R { someByteString = bs } | length bs != 32 should also work without extensions
03:00:53 <orion> Thanks.
03:31:24 <guillaum2> http://lpaste.net/163563 why does this gives me a type error "No instance for (Ord a0) arising from a use of 'isSorted'" ?
03:31:57 <guillaum2> if I'm explicitly add the type "sort :: Ord t => [t] -> [t]" the error disapears
03:32:26 <guillaum2> or if I'm explicitely add the parameter such as "sort l = .... l", the error also disapears.
03:32:57 <srhb> guillaum2: Monomorphism restriction
03:33:23 <srhb> guillaum2: https://wiki.haskell.org/Monomorphism_restriction
03:33:53 <guillaum2> srhb: I'm reading, thank you.
03:36:38 <tsahyt> @djinn (a -> b) -> [a] -> [(a,b)]
03:36:39 <lambdabot> Error: Undefined type []
03:37:05 <hpc> lambdabot's djinn doesn't do recursive types
03:38:30 <hpc> :t zipWith (id &&& ($))
03:38:31 <lambdabot>     Couldn't match type ‘(a -> b1, a -> b1)’ with ‘b -> c’
03:38:32 <lambdabot>     Expected type: (a -> b1) -> b -> c
03:38:32 <lambdabot>       Actual type: (a -> b1) -> (a -> b1, a -> b1)
03:38:37 <tsahyt> :t ap zip . map
03:38:38 <lambdabot> (a -> b) -> [a] -> [(a, b)]
03:38:42 <tsahyt> that looks about right
03:38:49 <hpc> yeah
03:39:46 <hexagoxel> :exf "(a -> b) -> [a] -> [(a,b)]"
03:39:47 <exferenceBot> \ f1 bs -> zip bs (fmap f1 bs)
03:39:47 <EvanR> what was that ap zip aztec god of recursion
03:40:03 <tsahyt> what's :exf doing?
03:40:21 <merijn> Presumably the opposite of inference :)
03:40:54 <EvanR> @pl \ f1 bs -> zip bs (fmap f1 bs)
03:40:54 <lambdabot> ap zip . fmap
03:41:08 <EvanR> huzzah
03:41:14 <tsahyt> ah so it stands for "exference"?
03:41:36 <tsahyt> interesting that it'd use fmap though
03:41:42 <tsahyt> :t ap zip . fmap
03:41:44 <lambdabot> (a -> b) -> [a] -> [(a, b)]
03:41:51 <tsahyt> oh wait, zip forces it back to lists
03:42:10 <hexagoxel> it is like djinn but understands more types.
03:42:44 <hexagoxel> yeah, i have only the more general versions of stuff in exference's dictionary.
03:43:17 <tsahyt> hexagoxel: how does it work?
03:44:35 <hexagoxel> tsahyt: https://github.com/lspitzner/exference/
03:46:41 <hexagoxel> tsahyt: it incrementally builds terms that are type-correct (as far as they are built).
03:47:21 <hexagoxel> that construction gives you some search-tree, and on that it performs a best-first search.
03:48:13 <tsahyt> so given enough time it should find some function satsifying any non-empty type?
03:50:05 <hexagoxel> uh yes, in theory. but the search space grows exponentially.
03:51:36 <hexagoxel> where djinn promises to terminate, exference is an attempt to keep the constant factors small and see how far it gets :D
03:52:17 <tsahyt> Is there any heuristic being used to guide the search?
03:58:33 <hexagoxel> tsahyt: sure, it takes into account a number of different things.
03:59:10 <hexagoxel> the number of "holes" still in the partial expression constructed so far; a weight associated to the members of the environment/dictionary used so far,
04:00:13 <hexagoxel> how many type class constraints need to be resolved; how many (unused) variable bindings are in the partial expression etc.
04:03:04 <hexagoxel> tsahyt: the most important part are the ratings for certain elements of the environment. see https://github.com/lspitzner/exference/blob/master/environment/all.ratings
04:03:40 <tsahyt> hexagoxel: so functions with a high rating are preferred?
04:04:06 <hexagoxel> high in that document means "higher cost", so lower will be preferred.
04:04:35 <tsahyt> why is the cost for Just so high?
04:05:02 <tsahyt> is that just to make it prefer pure instead?
04:05:28 <hexagoxel> yes.
04:05:41 <tsahyt> :exf a -> Maybe a
04:05:41 <exferenceBot> parse error: more than one input
04:05:51 <hexagoxel> :exf "a -> Maybe a"
04:05:52 <exferenceBot> pure
04:05:58 <Nnotm> Hi. I have a custom print function in my ghci.conf and use :set -interactive-print=myPrint inside it. This works great, but unfortunately stops working once I load in a source file into ghci. I assume this is because the let binding of the print function doesn't exist anymore once I load in a file. Is there a way around that?
04:06:09 <tsahyt> :exf "IO a -> a"
04:06:25 <tsahyt> either I crashed it or it just refuses to do unsafe things
04:06:32 <exferenceBot> \ i1 ->
04:06:33 <exferenceBot>   let (Cont f5)
04:06:33 <exferenceBot>         = Cont (\ f6 -> fmap (fmap (\ q -> q /= Nothing) . f6) i1)
04:06:33 <exferenceBot>     in f5 id
04:06:39 <tsahyt> wat
04:07:22 * hexagoxel has not seen that solution before
04:08:54 <aleator> Ghc just spat out "Couldn't match type ‘'Bool’ with ‘'Num; Expected type: Operand t;   Actual type: Operand 'Num". Does this make sense to anyone or should I report a bug?
04:09:55 <tsahyt> aleator: for what code?
04:11:07 <tsahyt> hexagoxel: afaik the Cont data cosntructor is not exported anywhere, so this piece of code is not implementable anyhow
04:11:28 <aleator> tsahyt: Long and complex (with all the extensions) at this point...
04:12:17 <tsahyt> I don't think anyone will be able to comment on the error without any further information
04:12:55 <aleator> No I mean, just look at that. It claims that two types are incompatible,  and then reports different expected tyoe than what it just said
04:13:17 <merijn> tsahyt: Cont is exported in places, but don't see how that code could match on IO
04:13:56 <tsahyt> hexagoxel: is it possible that the bot just gave up at that point and spat out the last thing it looked at?
04:13:58 <fr33domlover> aleator, Num or 'Num? they are not the same thing :
04:14:01 <fr33domlover> :P
04:14:39 <fr33domlover> Num is a typeclass, while 'Num is a value of type Name (from TH)
04:15:16 <aleator> fr33domlover: There are ':s on both of those..
04:15:35 <aleator> Why is replacing 'Bool with t?
04:16:02 <hexagoxel> tsahyt: no, it certainly only prints out solutions, and this certainly looks like some bug.
04:16:16 <tsahyt> welp. I did break it then
04:20:22 <hexagoxel> :p i bet this was introduced as part of rankntype-support. meh. i will look into that later.
04:32:42 * hackagebot avers-server 0.0.5 - Server implementation of the Avers API  https://hackage.haskell.org/package/avers-server-0.0.5 (wereHamster)
04:35:53 <tsahyt> is there a way to keep ghci from complaining about "illegal foreign declarations" when using cabal repl on a library that exports a C API?
04:36:31 <dcoutts> tsahyt: -fobjec-code?
04:36:42 <dcoutts>  -fobject-code
04:37:30 <tsahyt> that works, thanks!
04:48:05 <epsilonhalbe> hey I am trying to upload my first project on hackage, i have an account and tried to upload a package candidate. But before uploading the full package, i wonder how do I get the beautiful documentation (locally it works) but the links on the package preview were missing
04:53:02 <lyxia> it is normally built automatically
04:53:44 <magthe> it's been reported that it sometimes takes a LONG time before the docs are built though
04:54:10 <magthe> and there is a way to upload docs yourself if you feel particularly benevolent
04:55:04 <epsilonhalbe> I just found a few typos in the readme - i'll fix them and will upload the package hoping for automatic building of documentation
04:55:27 <epsilonhalbe> I will definitely upload the docs if it does not work - 
04:55:52 <epsilonhalbe> i like having neat docs
04:56:01 <magthe> I think we all do :)
05:02:43 * hackagebot accelerate-typelits 0.1.0.0 - a typesafe way encode accelerate matrices and vectors  https://hackage.haskell.org/package/accelerate-typelits-0.1.0.0 (epsilonhalbe)
05:07:43 * hackagebot ring-buffer 0.2.0 - A concurrent, mutable ring-buffer  https://hackage.haskell.org/package/ring-buffer-0.2.0 (BenGamari)
05:42:56 <idev> where is sample codefor producer / consumer in haskell?
05:43:31 <lyxia> in what context? Are you talking about conduits?
05:43:43 <Axman6> or pipes?
05:43:47 <idev> https://wiki.haskell.org/Concurrency_demos/Simple_producer_and_consumer
05:43:49 <idev> I guess channels
05:43:53 <idev> should I be using conduits / pipes instead ?
05:43:54 <Axman6> or iteratees? those were the days
05:44:12 <Axman6> well we have no idea what you want to do, so... maybe? =)
05:44:57 <idev> I don't know either.
05:45:38 <Axman6> what about a producer which produces URLs and a consumer which downloads them
05:46:06 <Axman6> you could even make that consumer a producer of URL contents, which could be passed to another consumer which saves them
05:48:57 <lyxia> you can write this type of concurrent programs pretty nicely with conduit
05:49:28 <Axman6> pipes too
06:29:21 <Karlodun> hello, working on some homework now, and we have to create two functions with types: ([a], a->a->a->b)->b
06:29:45 <Karlodun> and (a->b) -> c -> (c -> a) -> b
06:30:19 <Axman6> that first one is a pretty weird type
06:30:27 <Karlodun> as far as I understood both versions would need some kind of compilatioin of different functions
06:30:58 <Karlodun> both are confusing for me
06:31:27 <Karlodun> the second looks much like the type of (.)
06:31:31 <Axman6> there's only one way to write the second one, but the first one there are many (actually infinite) ways, is there some information about what the result should be?
06:31:45 <Axman6> yeah the second one is very close to (.)
06:32:00 <Axman6> you can use it to implement a function with that type
06:32:04 <Karlodun> nope, we just need any function, that will have those types
06:32:59 <Karlodun> the first task was simple: Char -> [Bool]
06:33:03 <Axman6> so what are your thoughts on the first one? how might you do it?
06:34:03 <Karlodun> I tried some pattern matching - nope
06:34:15 <Axman6> what patterns?
06:35:06 <Karlodun> let ff ([a], b,c,d,e) = e
06:35:31 <Karlodun> ([t4], t, t1, t2, t3) -> t3
06:35:41 <Axman6> but the type you wrote said it's only a 2-tuple, taking a list, and a function of type a->a->a->b
06:35:54 <Axman6> why're you matching on a 4-tuple? =)
06:36:54 <Karlodun> so I would need something like ff ([a], (tt b c d)) = d?
06:37:17 <Karlodun> the scripts and lections of my prof are not really helpfull
06:37:42 <Karlodun> and I could not find a good book on haskell till yesterday night
06:37:44 <Axman6> more like ff ([a], g) where g :: a->a->a->b
06:38:33 <Pennyw95> Hi...could you help me understand of part of this exercise? it's on the LYAH book, just before the "Making Monads" chapter  http://learnyouahaskell.com/for-a-few-monads-more#useful-monadic-functions
06:38:42 <Pennyw95> a part of*
06:38:47 <Axman6> remember, that type says that ff is being given a tuple containing a list of a's, and a function of type a->a->a->b, and you need to return a b somehow
06:39:11 <Boomerang> What is the link between the a in the list and the a in the function? Are you supposed to take the first 3 elements? what if the list is empty?
06:39:25 <Axman6> Karlodun: I'd love to help more but my battery is about to die and I need to go to bed. I'm sure someone else will be able to help though
06:39:48 <Pennyw95> basically I don't get why there's a need to add return between foldr (<=<) and (replicate x moveKnight)...shouldn't replicate give some like [moveKnight, moveKnight..]
06:39:50 <mpickering> Does anyone have tips for debugging lhs2tex when it hangs?
06:40:05 <nitrix> Karlodun: I've α-converted the second function with type variables that makes more sense. Hopefully it helps: (b -> c) -> a -> (a -> b) -> c
06:40:11 <Pennyw95> so I guess returns wraps the list of functions in another list? what for?
06:41:18 <Karlodun> trying out....
06:41:24 <Boomerang> :t (\f a g -> f . g $ a)
06:41:26 <lambdabot> (b -> c) -> r -> (r -> b) -> c
06:42:02 <kishar>  
06:42:08 <nitrix> Karlodun: Looks correct.
06:42:24 <quxbam> Am I right that I can't declare a cabal dependency on a system executable like R?
06:42:34 <lyxia> Pennyw95: return just initializes the accumulator
06:42:40 <nitrix> Boomerang: Oh wait, you solved it for him.
06:42:47 <nitrix> Boomerang: That's not super helpful.
06:43:00 <merijn> quxbam: Correct
06:43:04 <Boomerang> Oh :/ I didn't see it was an assignment, sorry about that
06:43:14 <merijn> quxbam: Although you can write a custom Setup.hs that checks whether it exists
06:43:18 <Pennyw95> lyxia: oh, so I could just put [] instead of it?
06:44:06 <merijn> quxbam: https://github.com/merijn/SNet2.0/blob/master/Setup.hs consult the Cabal library docs for details
06:44:08 <lyxia> Pennyw95: [] is not a function. (:[]) is.
06:44:08 <Pennyw95> I didn't know return could also take no parameters
06:44:08 <quxbam> merijn: Ok, thanks.  
06:44:13 <Boomerang> Maybe Karlodun could try to make it not a lambda but yes very similar answer, sorry
06:44:16 <geekosaur> it's not
06:44:26 <geekosaur> Pennyw95, a function is a perfectly acceptable value
06:45:07 <nitrix> Pennyw95: Functions in Haskell are first-class citizens. They are values and can be passed to other functions.
06:45:21 <Pennyw95> so, foldr (<=<) return (replicate n move) = foldr (<=<) [] [move,move,move..]?
06:45:32 <geekosaur> no
06:45:37 <nitrix> Not quite.
06:45:49 <Pennyw95> so return is still waiting for a parameter?
06:45:57 <kosmikus> mpickering: why / when does lhs2tex hang?
06:46:20 <geekosaur> yes. the result of the foldr is a function taking a parameter, just as its seed is a function taking a parameter (return)
06:46:30 <mpickering> kosmikus: I couldn't work out exactly why but when I removed a formatting directive, it stopped hanging
06:46:35 <Karlodun> either I receive a wrong type, or parse error
06:46:38 <Karlodun> *Main> let ff ([a], (yee b c d)) = yee b c d where yee e f g = (g,f,e)
06:46:48 <kosmikus> mpickering: might be a self-recursive formatting directive then?
06:46:59 <mpickering> It was "%format b^2"
06:47:08 <Pennyw95> and then it gets 'return start'
06:47:27 <Pennyw95> geekosaur: which is taking (x,y) and wrapping it in [(x,y)], correct?
06:47:47 * hackagebot atomic-write 0.2.0.5 - Atomically write to a file  https://hackage.haskell.org/package/atomic-write-0.2.0.5 (jsl)
06:49:06 <kosmikus> mpickering: hmm. that's not a legal formatting directive, I think (without any rhs).
06:49:26 <kosmikus> mpickering: well, even with one, it isn't ...
06:49:57 <mpickering> ok thanks, that explains it 
06:50:04 <kosmikus> mpickering: still strange that it would hang, though
06:50:11 <kosmikus> mpickering: I cannot reproduce this easily
06:50:40 <kosmikus> mpickering: ah, never mind. I just did.
06:50:41 <geekosaur> Pennyw95, did you read up in that LYAH page? where it shows: let f = foldr (.) id [(+1),(*100),(+1)]
06:51:54 <kosmikus> mpickering: interesting.
06:52:13 <Pennyw95> Ah, now I understand! I hadn't though about that hard enough... thank you :)
06:52:51 <kosmikus> mpickering: so even just "%format b" alone loops
06:53:42 <kosmikus> mpickering: I'm surprised that I never noticed this. I think this is the code that's handling stuff like "%format b2" or "format b_2" turning this into a self-recursive directive for b
06:53:49 <geekosaur> sorry, I am not intimately familiar with LYAH (I predate it a bit, never had a reason to read it) and had to figure out the context of the moveKnight etc,
06:55:26 <mpickering> that makes sense, I'm also surprised that no one else has run into it, thanks for looking
06:55:34 <Pennyw95> geekosaur: one more thing though... writing foldr (.) id [(+1),(*100),(+5)] 1 returns 601 as I expected
06:55:57 <Pennyw95> but I use foldl instead, I still get 601 instead of 205?
06:57:07 <nitrix> foldl (flip (.)) id [(+1), (*100), (+5)] 1
06:57:11 <nitrix> > foldl (flip (.)) id [(+1), (*100), (+5)] 1
06:57:12 <lambdabot>  205
06:57:14 <kosmikus> mpickering: it's quite possible that people have run into it, but didn't complain
06:57:47 <geekosaur> > foldr (.) id [(+1),(*100),(+5)] a
06:57:47 * hackagebot extensible 0.3.7 - Extensible, efficient, optics-friendly data types  https://hackage.haskell.org/package/extensible-0.3.7 (FumiakiKinoshita)
06:57:49 <lambdabot>  (a + 5) * 100 + 1
06:57:56 <geekosaur> > foldl (.) id [(+1),(*100),(+5)] a
06:57:58 <lambdabot>  (a + 5) * 100 + 1
06:58:10 <geekosaur> > foldl (flip (.)) id [(+1), (*100), (+5)] a
06:58:13 <lambdabot>  (a + 1) * 100 + 5
06:58:35 <Pennyw95> but should folding from the left flip the order?
06:58:55 <nitrix> That's not an easy one to explain.
06:59:05 <lyxia> foldl (.) id [f, g, h] = ((id . f) . g) . h = f . (g . (h . id)) = foldr (.) id [f, g, h]
07:00:16 <Boomerang> > foldl (&) 1 [(+1), (*100), (+5)]
07:00:18 <lambdabot>  205
07:01:20 <Pennyw95> is that associativity?
07:01:34 <Boomerang> :t (&)
07:01:35 <lambdabot> a -> (a -> b) -> b
07:01:42 <Boomerang> :t ($)
07:01:43 <nitrix> & is flipped $
07:01:44 <lambdabot> (a -> b) -> a -> b
07:02:16 <Pennyw95> oh, cool
07:02:27 <Boomerang> It's part of Data.Function I think
07:03:17 <nitrix> Yeah. You can `foldr ($)` or `foldl (&)` to get the two behaviors you'd expect.
07:03:57 <Pennyw95> with $ automatically imported and & in Data.Function
07:04:01 <geekosaur> well, except not quite since you start with the input value instead of id
07:04:10 <nitrix> Right.
07:04:23 <geekosaur> because $ and & are application, not composition
07:04:55 <nitrix> With (.) as a folding function, you'll always get the "problem" he seen.
07:05:31 <nitrix> Pennyw95: Unless you flip it. I think lyxia's example demonstrated it very nicely.
07:07:00 <Pennyw95> that is surely the best choice
07:07:11 <Pennyw95> I get it.. thank you all for your help :D
07:30:56 <jackhill> Hi, I'm having a problem with IO actions being ordered in a way that I don't expect: http://lpaste.net/163582
07:31:03 <Sparhawk> yo
07:31:24 <jackhill> The behavior I see in ghci is what I expect, but when I build a run the executable, the order seems to be reversed.
07:31:25 <Sparhawk> is this channel functional
07:31:47 <merijn> jackhill: That' not ordering :)
07:31:55 <merijn> jackhill: You didn't disable buffering
07:32:05 <jackhill> merijn: oooh
07:32:24 <merijn> jackhill: By default stdout is line buffered, so it only flushes when you output a newline
07:32:28 <jackhill> merijn: is there a better way to "promp user for input"?
07:32:43 <merijn> jackhill: Use an explicit "hFlush stdout" or disable buffering using "hSetBuffering"
07:34:05 <merijn> jackhill: Try my version: http://lpaste.net/163582
07:34:07 <jackhill> merijn: perfect, thanks!!
07:36:37 <Mutter> pacak: 
07:36:40 <Mutter> pacak: 
07:37:13 <Mutter> Hello
07:40:37 <Tritlo> is this a horrible horrible thing?
07:40:58 <Tritlo> instance {-# OVERLAPPABLE #-} Data a => Hashable a where hashWithSalt s k = hashWithSalt s (constrIndex $ toConstr k, gmapQ toConstr k)
07:41:43 <Mutter> Hi..
07:42:06 <Mutter> Hi tritium
07:42:09 <Tritlo> With highlighting https://www.irccloud.com/pastebin/HHUZMhd1/Overlappable%20data
07:42:09 <Tritlo> With highlighting https://www.irccloud.com/pastebin/wvjD0Hdn/Overlappable%20data
07:42:30 <Mutter> Hi tritio.. 
07:42:46 <Mutter> Hi tritio.... 
07:43:14 <tippenein> mapper :: Proxy () Data.Text.Internal.Text () Data.Text.Internal.Text (SafeT IO) r
07:43:19 <tippenein> Producer :: * -> (* -> *) -> * -> *
07:43:24 <bennofs> Tritlo: considering that with GHC generics, you can write data Foo = Foo ... deriving Generic; instance Hashable Foo to get a Hashable instance for Foo, i would not recommend that
07:43:35 <tippenein> to my understanding mapper here is a Text Producer
07:43:40 <deni> ocharles_: hey man you around?
07:43:51 <deni> ocharles_: question about your example here: https://github.com/ocharles/engine.io/blob/master/examples/chat/MainSnap.hs
07:44:21 <deni> ocharles_: how would one go about and squeezing wrapCORS inthere somewhere...I can't really seem to figure out the difference between the example on github and the blog post
07:45:48 <ocharles_> deni: you want CORS enabled for /socket-io?
07:46:50 <ocharles_> deni: I would import Snap.CORS from http://hackage.haskell.org/package/snap-cors-1.2.9/docs/Snap-CORS.html, and then I think line 23 can change from ("/socket.io", socketIoHandler) to ("/socket.io", applyCORS defaultOptions socketIoHandler)
07:46:53 <tippenein> ghci also says this about a Producer: type Producer b = Proxy X () () b 
07:47:27 <deni> ocharles_: yeah I'm serving the html from a different domain...and am only connecting to socket-io. I found snap-cors but can't really get it to work with the example I linked above
07:47:34 <deni> and the example on the blog post doesn'g compile for me
07:47:48 <deni> hmm..let me check
07:47:54 <ocharles_> which is the blog post?
07:48:31 <Tritlo> bennofs: ah, but I'm fiddling with Haxl. The current use is: https://www.irccloud.com/pastebin/jnLwU5Xl/
07:48:39 <deni> ocharles_: https://ocharles.org.uk/blog/posts/2014-07-13-announcing-socket-io-for-haskell.html
07:49:08 <deni> ocharles_: I could have sworn I tried that and got an obscure error message that I couldn't parse.... It seem the only error here is me needing more coffee :D
07:49:17 <deni> ocharles_: thanks for your help this seems to be working now
07:50:35 <ocharles_> woohoo!
07:50:44 <ocharles_> glad it's working for you :)
07:50:54 <deni> ocharles_: awesome libraries. thank you for those! :)
07:51:02 <ocharles_> :)
08:07:18 <Xnuk> Can I disable Wreq's automatically-uncompressing-gzipped-response feature?
08:15:01 <lpaste> tippenein pasted “trying to get a type for a runEffect” at http://lpaste.net/163586
08:16:47 <tippenein> ok.. so basically I have to finish the pipe to get back a type. :t runEffect $ whatever >-> Text.stdout
08:21:29 <tippenein> I'm finding it really difficult to deal with the Pipes library's types
08:22:50 * hackagebot persistent-template 2.5.1.3 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5.1.3 (GregWeber)
08:23:33 <lpaste> tippenein pasted “consume a producer with a fold” at http://lpaste.net/163587
08:40:41 <cheater> hello
08:40:46 <uman> cheater: hi
08:40:54 <cheater> is there a review of tools for optimizing haskell and measuring performance?
08:47:42 <thirax> hi!
08:50:53 <srhb> thirax: Hi.
08:52:52 * hackagebot generic-random 0.1.0.0 - Generic random generators  https://hackage.haskell.org/package/generic-random-0.1.0.0 (lyxia)
08:55:33 <nemeci> hi
08:58:23 <haskell829> What is the difference between ErrorT and ExceptT? They look very similar and have similar purpose https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Error.html#t:ErrorT https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html#t:ExceptT
08:59:16 <srhb> haskell829: http://stackoverflow.com/questions/25820294/transition-from-errort-to-exceptt might be helpful
09:00:14 <lyxia> haskell829: functions for ErrorT have an Error constraint on the error type, whereas ExceptT has no constraint
09:00:29 <srhb> haskell829: Also the note here: https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-Error.html
09:02:55 <haskell829> thanks
09:04:05 <glguy> Xnuk: You can modify the Request wreq will use using wreq's prepare. you'll have to change the decompress field
09:04:11 <glguy> http://hackage.haskell.org/package/http-client-0.4.28/docs/Network-HTTP-Client.html#t:Request
09:04:37 <glguy> that might be an Internal only thing, though
09:06:28 <glguy> Yeah, wreq doesn't actually seem to export the module you'd need access to to be able to set that
09:12:52 * hackagebot cabal-dependency-licenses 0.1.2.0 - Compose a list of a project's transitive dependencies with their licenses  https://hackage.haskell.org/package/cabal-dependency-licenses-0.1.2.0 (JasperVanDerJeugt)
09:19:51 <vctr> is there a get to get an fmap-able Data.Vector?
09:20:09 <haskell717> hello, I need a sample function, which has two arguments, one should be a vector and another a function, with type: ([a], a -> a -> a -> b) -> b
09:20:23 <lyxia> vctr: what's a "get"?
09:20:41 <vctr> lyxia to be able to use <$> on a vector for starters
09:21:00 <lyxia> Data.Vector's Vector is a functor
09:21:03 <vctr> lyxia i could write my own instance, but it seems like orphan instances are generally a bad practice
09:21:35 <Boomerang> haskell717: someone else has the same question earlier, is this for an assignement? :)
09:21:46 <lyxia> vctr: the instance already exists
09:21:54 <Boomerang> *had
09:22:12 <lyxia> vctr: it's even an instance of Monad
09:22:33 <vctr> lyxia huh... doesn't seem to be working for me.. wonder if this is some hmatrix weirdness
09:22:38 <Karlodun> hello, I need a sample function, which has two arguments, one should be a vector and another a function, with type: ([a], a -> a -> a -> b) -> b
09:22:47 <hpc> Karlodun: very funny
09:22:48 <lyxia> vctr: hmatrix uses Storable
09:22:57 <byorgey> Karlodun: we are not going to do your homework for you
09:23:11 <vctr> so storable vectors are not functors
09:23:12 <lyxia> vctr: And Data.Vector.Storable.Vector is indeed not a Functor, and cannot be.
09:23:25 <vctr> lyxia why can't it be a funtor?
09:23:35 <vctr> because the types are fixed?
09:23:38 <lyxia> because it only stores values of Storable types
09:24:07 <vctr> why can't fmap be well defined even if only a subset of types is supported?
09:24:22 <Karlodun> I need any example, where a function receives a list and another function as arguments
09:24:32 <Boomerang> Karlodun: Can it be any function as long as it has that type signature? Can it fail (on empty list, or list too small for example)?
09:24:34 <Karlodun> xD
09:24:43 <Karlodun> yes
09:24:57 <hpc> Karlodun: why do you need this?
09:25:03 <lyxia> vctr: the signature of fmap is too general for that
09:25:09 <Boomerang> Then it shouldn't be too difficult, try to apply the function to the first 3 elements of the list
09:25:11 <Karlodun> university, we are learning types
09:25:41 <Karlodun> hmmmm
09:25:49 <Karlodun> ty Boom, I'll try
09:26:01 <Karlodun> brb
09:26:28 * byorgey just realized it is impossible to write a total function with Karlodun's type
09:26:36 <byorgey> tell your instructor this is not a good exercise =P
09:26:53 <Boomerang> here's a hint, you can pattern match on the list (x:xs) or (x:y:xs) and so on...
09:26:58 <hpc> byorgey: you didn't notice immediately? ;)
09:27:05 <Boomerang> byorgey: that's why I asked if it could fail
09:27:11 <byorgey> hpc: no, because I wasn't really paying attention
09:27:16 <hpc> lol, good reason
09:27:16 <lyxia> vctr: fmap :: (a -> b) -> Vector a -> Vector b would imply that you can construct a Vector b for any b without restriction
09:27:53 * hackagebot serpentine 0.2 - Simple project template from stack  https://hackage.haskell.org/package/serpentine-0.2 (andrewthad)
09:27:59 <Karlodun> it can fail, it just needs this type, and yes - I totally support you, that this is not a good exercise, especially if his scripts and lections do not really cover typisation
09:28:01 <jer_gib> @free fmap :: (a -> b) -> (F a -> F b)
09:28:02 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
09:28:36 <jer_gib> @free dimap :: (a' -> a) -> (b -> b') -> (P a b -> P a' b')
09:28:36 <lambdabot> Plugin `free' failed with: src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:(202,1)-(291,24): Non-exhaustive patterns in function freeTheorem'
09:28:45 <vctr> lyxia makes sense
09:28:52 <vctr> is there a storable fmap?
09:28:54 <Karlodun> I tried several pattern matches before, but hgci refused them ^^
09:29:09 <Boomerang> show us what you tried, maybe we can help
09:29:31 <jer_gib> @free fmap :: (a -> b) -> (F b -> F a)
09:29:31 <lambdabot> g . h = k . f => $map_F f . fmap h = fmap k . $map_F g
09:29:45 <glguy> jer_gib: You can play with lambdabot in /msg
09:29:48 <dfeuer> @pl \mres nres -> mf mres (nf nres)
09:29:48 <lambdabot> (. nf) . mf
09:30:35 <Karlodun> ok, give me few minutes, need to explain other task to comrade
09:32:12 <jer_gib> dfeuer: ta!
09:32:22 <dfeuer> jer_gib, hi?
09:32:40 <dfeuer> jer_gib, your nick is not familiar; do I know you?
09:32:50 <jer_gib> dfeuer: oops, wrong message
09:32:54 <dfeuer> Ha.
09:32:58 <jer_gib> glguy: ta! :-)
09:35:06 <Karlodun> it will take more, then 20 minutes, but I will come back, sorry
09:43:59 <Mateon1> Hi, I have a question
09:44:15 <Mateon1> > let 4 = 5 in 4
09:44:17 <lambdabot>  4
09:44:20 <Mateon1> Why does this even compile?
09:45:03 <hpc> > let (x, 5) = (y, x) in y
09:45:05 <lambdabot>  y
09:45:15 <hpc> er
09:45:23 <hpc> > let (x, 5) = (y, y) in x
09:45:24 <lambdabot>  *Exception: <interactive>:3:5-19: Irrefutable pattern failed for pattern (x, 5)
09:46:05 <hpc> oh right, it adds a guard for the thing in that position being equal to that number
09:46:11 <hpc> so you can do
09:46:14 <hpc> fact 0 = 1
09:46:21 <hpc> fact n = n * fact (n - 1)
09:46:49 <hpc> so when you do let 4 = 5 in ..., that's a pattern that would fail if forced
09:47:13 <hpc> but it doesn't get forced because haskell is non-strict, and you get 4
09:48:55 <m0rphism> is it possible to disable a warning in the scope of a single declaration?
09:49:27 <glguy> Mateon1: Keep in mind that  let 4 = 5 in ... isn't redefining 4, in that context 4 is a pattern binding
09:49:32 <m0rphism> I'm playing with pattern synonyms, which aren't checkable yet, but don't want to disable exhaustiveness checks for the whole module
09:49:46 <merijn> m0rphism: Sadly, no
09:49:58 <merijn> m0rphism: GHC8.0 should have a better exhaustiveness checker
09:50:18 <hpc> m0rphism: just don't -Werror and bask in the ghc noise ;)
09:51:06 <m0rphism> merijn: Thanks, then I add an explicit _ case until then :)
09:51:57 <m0rphism> hpc: I'm still trying to parse your response ;)
09:52:54 <m0rphism> I hope my brain is total
09:54:23 <m0rphism> ahh, now it terminated successful :D
09:56:06 <m0rphism> merijn: I just realized, the explicit _ case is actually a better solution for my specific case ^^
09:57:00 <m0rphism> merijn: Because then I probably also get notified about an unreachable match once the exhaustiveness checker has improved :)
09:57:39 <merijn> m0rphism: Don't forget to add "error "can't happen!"" to that clause for debugging ease ;)
10:02:57 <cocreature> sadly ghc 8.0 still doesn’t check exhaustiveness for pattern synonyms afaik
10:04:11 <jackhill> Hi, how do I do STARTTLS with http://hackage.haskell.org/package/LDAP ?
10:04:21 <v937xjd> What's the best way to get the index of true values in a Boolean vector?
10:04:21 <jackhill> would ldap-client be better?
10:04:48 <srhb> v937xjd: map them with their index, filter on True?
10:05:22 <srhb> v937xjd: Depends what you mean by "best" I guess.
10:05:47 <v937xjd> srhb: simplicity and clarity of intent
10:06:00 <srhb> v937xjd: Sounds about right.
10:06:11 <jackhill> when I try to use ldaps, I get *** Exception: ldap_1result: LDAPException LdapServerDown(-1): Can't contact LDAP server
10:07:13 <lpaste> jackhill pasted “LDAP bind help” at http://lpaste.net/163597
10:08:05 <jackhill> Comments about improving the code in general even if they don't help me with my ldap problem are also welcome
10:08:54 <v937xjd> srhb filter (\idx boolvec!! idx) idxs  
10:09:26 <v937xjd> Right? Seems like something that might have a built in function. 
10:11:20 <glguy> jackhill: http://hackage.haskell.org/package/LDAP-0.6.10/docs/LDAP-Init.html talks about using ldaps schemas in ldapInitialize, maybe try that route?
10:11:20 <srhb> v937xjd: Take a look at ifoldr and friends
10:11:42 <Karlodun> hmmm....
10:11:52 <Karlodun> *Main> let ff ([a:b:c:xs], yee) = take 3 (map (yee) a) where yee = (+1)
10:11:54 <Karlodun> *Main> :t ff ff :: Num a => ([[[a]]], t) -> [a]
10:12:02 <Karlodun> doesn't look like what I need
10:12:16 <jackhill> glguy: definitely worth a try
10:13:40 <srhb> v937xjd: (ifoldr (curry (:)) should basically be what you want)
10:14:07 <Karlodun> we just finished "calculating" the type of "(.) (foldr1 seq) (map fst)"
10:14:13 <jackhill> glguy: Indeed, I have made progress. Now I get a certificate error \o/. I guess before it was trying to do ldap to the ldaps ports.
10:15:12 <v937xjd> Srhb how about conditional list comprehension?
10:15:27 <jackhill> I wonder if there is a why to specify which CACert bundle to use. I use the LDAPTLS_CACERT env var when using the ldapsearch cli utility. I bet that won't work here.
10:16:00 <srhb> v937xjd: Basically the same as filter (==True) . ifoldr (curry (:)) []
10:16:21 <srhb> v937xjd: But yes, you can use the resulting list in just the same way.
10:17:14 <v937xjd> Looks a bit cryptic to me compared to list comp but maybe that's just mek42 
10:17:41 <v937xjd> Argh autocomplete in this client is on crack
10:17:43 <srhb> v937xjd: Well filter (==True) is what you asked for
10:17:59 <srhb> v937xjd: The rest is the conversion from a Vector to a list with the indices.
10:20:24 <v937xjd> Srhb is there a built in library function? Python has where and r has which that do similar things 
10:21:17 <v937xjd> No big deal of course but this seems like a wheel that's been done many times over
10:21:41 <jackhill> oh, I guess in my case it is the C library that does the checking, so I can still set the same env var
10:21:44 <srhb> v937xjd: Often times, no, because the available functions are so general and simple to put together.
10:21:49 <srhb> v937xjd: Perhaps it helps if I expand it a bit
10:22:07 <jackhill> glguy: thanks!!
10:22:17 <srhb> v937xjd: ifoldr (\index element list -> (index,element):list) [] yourVector
10:22:59 <m0rphism> cocreature: Maybe merijn was referring to this proposal: https://ghc.haskell.org/trac/ghc/ticket/8779
10:23:11 <srhb> v937xjd: And we almost have no builtins at all, favoring libraries. :)
10:23:23 <Zemyla> You know, Perl has a comprehensive list of possible compiler errors and what they mean. Maybe GHC should have that as well.
10:23:28 <v937xjd> Well a library in standard use would be fine
10:23:33 <srhb> v937xjd: *nods*
10:24:04 <hpc> Zemyla: to be fair, perl's specification is also an implementation so they kinda have to have it
10:24:07 <simpson> Zemyla: Fields like "Short example code which provokes the error" would be sweet.
10:24:17 <hpc> but yes, it would be a good idea
10:24:19 <srhb> v937xjd: There might be one. You can try searching for the type signature on Stackage's Hoogle. But you should be able to make do just fine with ifoldr and filter. :)
10:24:37 <v937xjd> Yeah 
10:25:21 <v937xjd> No biggie. It's more of an optimizing my development flow issue than a how do I do it issue
10:26:03 <sshine> hi srhb!
10:26:06 <sm> Zemyla: great idea
10:26:07 <srhb> sshine: o/
10:30:34 <Boomerang> Karlodun: Why do you take 3 and map? now that you have access to a, b and c you could just apply your function yee to a, b and c
10:32:33 <Zemyla> Also, what should this function (similar to monadic "when") be called?
10:32:34 <glguy> Karlodun: The pattern [a:b:c:xs] matches a single list of a list with at least 3 elements
10:32:36 <Boomerang> Karlodun: also the pattern matching is wrong, use parenthesis instead.
10:32:43 <glguy> Karlodun: (a:b:c:xs) matches a list of at least 3 elements
10:32:48 <Boomerang> ^
10:33:09 <Zemyla> ??? :: (Monoid m) => Bool -> m -> m; ??? False = const mempty; ??? True = id
10:33:21 <glguy> The [] syntax is for matching complete lists: [a,b,c] matches a list with exactly 3 elements
10:33:55 <Boomerang> In this case you don't even need xs so you could do (a:b:c:_)
10:34:42 <Zemyla> I guess it is true, that naming things is one of the two hardest problems programmers face.
10:35:14 <Sparhawk> ehm does someone here happen to know about a language-independent functional programming irc channel?
10:35:16 <cocreature> m0rphism: oh I know it’s planned, I was just pointing out that it’s not available in 8.0
10:36:35 <hpc> Sparhawk: #haskell-offtopic ;)
10:36:40 <Zemyla> (The other hard problem is cache invalidation and off-by-one errors.)
10:37:05 <hpc> Zemyla: http://thecodelesscode.com/case/220
10:37:28 <Zemyla> hpc: Coincidentally, I was already there.
10:37:37 <hpc> :D
10:58:24 <Karlodun> OK! I have a solution!!!!
10:58:37 <Karlodun> *Main> let gg(x1:x2:x3:xs, f) = f x1 x2 x3                       *Main> :t gg                               gg :: ([t1], t1 -> t1 -> t1 -> t) -> t
10:58:40 <Karlodun> ^^
10:59:16 <Karlodun> now I need the next: (a->b) -> c -> (c->a) ->b
11:01:07 <m0rphism> cocreature: Ah, I see. Thanks for the addendum :)
11:03:01 <lyxia> Karlodun: yes!
11:03:05 <ertesx> hi there
11:03:13 <Boomerang> Well done Karlodun :) For the other one we already mentioned looking into function composition (.)
11:03:28 <Boomerang> :t (.)
11:03:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:04:29 <ertesx> snap framework question: is there a standard/good way to handle different resource types as per the Accept header?
11:04:40 <ElMoloko> sudo chroot / `which ghci`
11:05:01 <Boomerang> ElMoloko: probably wrong terminal ^^
11:08:17 <Karlodun> I'll continue in few hours
11:12:57 * hackagebot wai-websockets 3.0.0.9 - Provide a bridge between WAI and the websockets package.  https://hackage.haskell.org/package/wai-websockets-3.0.0.9 (MichaelSnoyman)
11:52:59 * hackagebot config-value-getopt 0.1.0.0 - Interface between config-value and System.GetOpt  https://hackage.haskell.org/package/config-value-getopt-0.1.0.0 (EricMertens)
11:53:47 <ElMoloko> I really want to have some sort of haskell shell
11:54:12 <dmj`> @package hell
11:54:13 <lambdabot> http://hackage.haskell.org/package/hell
11:55:48 <idev> what is the function StrictByteString -> LazyByteString ?
11:56:15 <dolio> fromChunks?
11:56:42 <idev> fromtrict
12:02:04 <ElMoloko> hell seems pretty nice
12:17:34 <maerwald> ElMoloko: startHell :: Config -> IO () -- Go to hell.
12:17:35 <maerwald> lol
12:17:53 <maerwald> not sure I'd call that useful documentation :P
12:25:36 <obadz> …unless you're writing a Doom implementation
12:30:12 <ElMoloko> This is really cooool
12:30:21 <maerwald> obadz: wrong language :P
12:41:27 <lyxia> raiseHell
12:44:05 <seyt> 13he4ll8o 9pe11op12le
12:47:49 <bitemyapp> seyt: hi
12:48:03 <idev> why is there no blinking tag ?
12:49:48 <idev> (context: server side for handling websockets); question: is there a way to say "forever $ ... but if this websocket ever dies, kill this tread" ?
12:50:06 <Karlodun> back home
12:50:07 <idev> the standard pattern is "forever $ read from ws, do thign ... " ... howeer, if the ws ever closes, I don't want this forever loop; I wnat it to die
12:50:36 <seyt> hi bitemyapp 
12:52:08 <Karlodun> the problem with our "home assignement" persissts
12:52:12 <dfeuer> dmwit, if you would prefer, I can write to the libraries list about your foldTree thing. Either way is fine.
12:52:30 * dfeuer bytes someone's app.
12:53:20 <Boomerang> :t until
12:53:21 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
12:53:35 <geekosaur> not very 'appy, then?
12:54:08 <puregreen> dfeuer: I'm writing a library with indexed versions of functions from Data.List; what is going to happen if I don't rewrite definitions-with-build back to definitions without build? e.g. if I leave the definition of ‘imap’ like this, is it alright? https://github.com/aelve/ilist/blob/master/lib/Data/List/Index.hs#L104
12:54:55 <Karlodun> I am still testing things out like: " let gg f g = g (f g) . (f)" to get my " (a->b) -> c -> (c -> a) ->b" type
12:56:21 <dfeuer> puregreen, mostly code duplication, I think. Things can get inlined without any benefit. One sort of exception is unfoldr, which really sucks if it's not inlined.
12:56:28 <Boomerang> Karlodun: you don't need to use (.) just look at how it works
12:56:31 <Boomerang> @src (.)
12:56:31 <lambdabot> (f . g) x = f (g x)
12:56:52 <Boomerang> :t (.)
12:56:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:57:14 <dfeuer> puregreen, it's also possible that in some cases the implementation using build might be slower (when it doesn't fuse with foldr) than a more direct implementation.
12:59:12 <puregreen> okay, thank
12:59:13 <puregreen> *s
13:01:38 <klowry> that's a cool bot
13:01:49 <klowry> did one of you make it?
13:01:58 <Karlodun> oh, thanks for the tips
13:02:10 <Karlodun> give me some time
13:02:21 <cheater> why does unfoldr suck if it's not inlined?
13:03:35 <dfeuer> cheater, because the function passed to it produces Maybe values. Unless that function is fairly pricy, the cost of allocating and garbage collecting all the Justs can be pretty important. When unfoldr and the function passed in are inlined together, those tend to go away.
13:05:04 <cheater> ah, so you mean inlining the argument to unfoldr
13:05:08 <cheater> i understand now
13:08:01 * hackagebot lua-bc 0.1 - Lua bytecode parser  https://hackage.haskell.org/package/lua-bc-0.1 (EricMertens)
13:08:13 <geppettodivacin> Does GHC usually optimize unfoldr usage that to be inlined? Or do you have to specify that manually?
13:10:39 <dfeuer> cheater, both of them, really. unfoldr and its argument mash together with constructor specialization and a worker/wrapper transform and magic happens. I don't understand all the details, but it's lovely.
13:13:30 <cheater> that sounds really cool
13:16:35 <Karlodun> I have some weird stuff:
13:16:38 <Karlodun> :t zz f g x = x g (f x)
13:16:39 <lambdabot> parse error on input ‘=’
13:16:50 * Sparhawk pokes Cale
13:18:01 * hackagebot enumerate 0.2.1 - enumerate all the values in a finite type (automatically)  https://hackage.haskell.org/package/enumerate-0.2.1 (sboo)
13:18:09 <Karlodun> let zz f g x = x g (f x)
13:18:10 <geekosaur> :t let zz f g x = x g (f x) in zz
13:18:11 <lambdabot> ((t1 -> t2 -> t) -> t2) -> t1 -> (t1 -> t2 -> t) -> t
13:18:23 <Karlodun> thanks ^^
13:19:03 <Karlodun> I am testing out different combinations, but actually it is try and error run right now, I do not really understand what I am doing
13:19:49 <Cale> Sparhawk: Right, I was going to explain the (->) e / Reader monad...
13:20:06 <Sparhawk> yes please:p
13:20:21 <Sparhawk> but basically it seems to be a shared input-environment?
13:20:27 <Sparhawk> while read is the output equivalent?
13:20:29 <Karlodun> and I got the answer from my comrade: f x g = f (g x)
13:20:32 <Sparhawk> err writer
13:20:38 <Boomerang> Karlodun: you're getting close, maybe focus on your inputs first, get them in the same order as the type signature. Then look at how you are applying the function f and g, think about the order
13:20:44 <Karlodun> :t let f x g = f (g x)
13:20:45 <lambdabot> <no location info>: not an expression: ‘let f x g = f (g x)’
13:21:09 <lyxia> :t let f x g = f (g x) in f
13:21:10 <lambdabot>     Occurs check: cannot construct the infinite type:
13:21:10 <lambdabot>       t2 ~ (t3 -> t3) -> t2
13:21:10 <lambdabot>     Relevant bindings include
13:21:27 <lyxia> :t let myfun f x g = f (g x) in myfun
13:21:28 <lambdabot> (t1 -> t) -> t2 -> (t2 -> t1) -> t
13:21:42 <Boomerang> Karlodun: alright not that you've kind of got it, checkout this cool lambdabot trick:
13:21:49 <Boomerang> @djinn (a -> b) -> c -> (c -> a) -> b
13:21:49 <lambdabot> f a b c = a (c b)
13:22:02 <lyxia> heh :D
13:22:13 <Boomerang> :)
13:22:22 <Karlodun> woooooow
13:22:26 <hpc> it's called djinn because it's pretty much magic
13:22:38 <Boomerang> I love it!
13:22:39 <hpc> and possibly for other reasons
13:23:01 * hackagebot ioref-stable 0.1.1.0 - iorefs with a unique stable index  https://hackage.haskell.org/package/ioref-stable-0.1.1.0 (cocreature)
13:23:03 * hackagebot hothasktags 0.3.6 - Generates ctags for Haskell, incorporating import lists and qualified imports  https://hackage.haskell.org/package/hothasktags-0.3.6 (LukePalmer)
13:23:10 <hpc> when you're a bad enough dude, i suggest reading the paper "theorems for free"
13:23:42 <Cale> Sparhawk: Yeah, Writer m, where m is a monoid, gives you an operation 'tell' which takes an value of type m, and, over the course of the computation, all the values given to tell are collected up and multiplied/concatenated together using the monoid operation
13:24:08 <Karlodun> thanks a lot
13:24:26 <Karlodun> hopefully the book will help me and I'll ask fewer questions later
13:24:39 <Boomerang> hpc: one of my lecturers wrote it :D I'll definitely read that when I have the time
13:25:25 <Sparhawk> and the monoid operation can be what exactly? anything?
13:25:35 <Cale> Any associative operation with an identity element
13:25:37 <ElMoloko> Is there a way to...change what's a valid identifier?  some low-level GHC hook or something?  so I can have infix operators like |a
13:26:29 <hpc> ElMoloko: not in anything approaching a generalized way
13:26:38 <Cale> i.e. you need (a <> b) <> c = a <> (b <> c) for every a, b, c :: m, and you need some mempty :: m such that mempty <> a = a and a <> mempty = a for every a :: m
13:26:43 <Karlodun> had to realize that @src does not work in normall ghci
13:26:54 <hpc> ElMoloko: there's the magic hash language extension which is the closest thing to what you are imagining
13:26:55 <xa0> "any associative operation with an identity element" so a monoidal operation :p
13:27:07 <Sparhawk> Cale: okay I am on a totally different level here:p
13:27:07 <Cale> (where <> here is our monoid operation, also written mappend)
13:27:27 <hpc> ElMoloko: but honestly you don't really want that kind of syntax anyway ;)
13:27:29 <geekosaur> ElMoloko, no. and in general it's a bad idea anyway; you'd lose valid syntax
13:28:00 <Shou> Why is repeat defined as "repeat x = xs where xs = x : xs" rather than "repeat x = x : repeat x"?
13:28:12 <Sparhawk> my question was really about functional programming and side effects, what exactly one should consider as "part of the function" and not
13:28:21 <Cale> So for example, we might have m = [a], the type of lists of elements of some type a, in which case (<>) = (++), i.e. list appending, and mempty = []
13:28:23 <ElMoloko> Haha, ok guys.  Thanks.  I'm gonna look a this magic hash thing anyway.  Just wanna see what...I can do
13:28:26 <hpc> ElMoloko: if you want to go a bit outside haskell, TH can do something like it but you'd have a hell of a time doing it
13:28:39 <ElMoloko> hpc: TH?
13:28:39 <hpc> and it still wouldn't be good enough
13:28:42 <hpc> template haskell
13:28:43 <ElMoloko> oh templatehaskell
13:29:36 <Cale> Sparhawk: Well, a function f: A -> B should be possible to think of as providing, for each value x of type A, exactly one value f x of type B.
13:29:43 <Cale> Sparhawk: No more and no less.
13:30:02 <ElMoloko> remember that person who made the Basic monad or whatever where the line numbers were functions?
13:30:08 <ElMoloko> how was that done?
13:30:39 <ElMoloko> I don't have a link, it's on my other computer
13:30:43 <Sparhawk> Cale: let me put it like this I am a dude from a C/asm background doing fun functional stuff in Lua I understand very little of what you are saying unfortunately
13:30:51 <Cale> Any additional information which all functions A -> B in the language carry is considered a "side-effect".
13:31:03 <hpc> ElMoloko: a custom Num instance
13:31:11 <Cale> Sparhawk: Well, take off your programmer hat for a moment and think about functions in the math class sense :)
13:31:28 <Sparhawk> you mean as in lambda?
13:31:31 <hpc> ElMoloko: basically, numeric literals place an implicit fromIntegral in the code during compilation
13:31:33 <Cale> nope
13:31:41 <hpc> er, fromInteger
13:31:43 <hpc> :t fromInteger
13:31:44 <Cale> (though that might actually be another approach to explaining this)
13:31:45 <lambdabot> Num a => Integer -> a
13:32:03 <ElMoloko> hpc: wow that makes a lot of sense actually
13:32:13 <hpc> or if it's a decimal number, a similar element of the... RealFrac type class?
13:32:19 <hpc> or possibly Floating, i forget
13:32:37 <geekosaur> Shou, I think it generates better code because it doesn't need a parameter any more?
13:32:49 <ElMoloko> hpc: I know what you're talking about, yeah.  I made instances of them for peano numbers
13:32:55 <hpc> ElMoloko: for a pair of particularly ridiculous Num instances, i recommend looking at acme-microwave and acme-php
13:33:02 <Cale> Sparhawk: In classical mathematics, if we have two sets A and B, then a function f: A -> B consists of a triple (A,B,G), where G, the "graph" of the function, is a set of pairs (a,b) with a in A and b in B, and where for each a in A, there is exactly one b in B such that (a,b) is in G.
13:33:16 <hpc> ElMoloko: the basic trick i expect is just an instance for functions
13:33:18 <Cale> When (a,b) is in the graph G, we write f(a) = b
13:33:38 <ElMoloko> hpc: huh, cool.  I'll do that
13:33:57 <Cale> and the symbol f(a) is unambiguous because there's exactly one b which we can be referring to
13:34:33 <Cale> For the sake of notation, A is called the domain of f, while B is called the codomain of f
13:34:45 <Sparhawk> is this more like formal logic?
13:35:06 <EvanR> this. is. HASKELLLLL
13:35:07 <Cale> This is the approach usually taken to define functions in terms of set theory
13:35:08 <ElMoloko> hpc: Wow microwave math! I was just having a debate with a friend about this.  Cool
13:35:16 <Cale> Well, the thing I'm describing isn't Haskell
13:35:35 <Sparhawk> pretend I don't know set theory
13:35:35 <Cale> In Haskell or other functional programming languages, functions are actually more restricted than this
13:35:39 <EvanR> haskell entails diverting into a variety of topics 
13:35:41 <Sparhawk> well no need to pretend (I don't)
13:35:59 <Cale> Well, I was hoping you might have some vague idea of what a set is -- for our purposes, it's just a collection of things
13:36:03 <hpc> ElMoloko: lol
13:36:09 <Cale> and I don't need to be much more precise than that
13:36:32 <Cale> It has elements which belong to it, and we can ask whether any given thing belongs to the set.
13:36:34 <Sparhawk> well that I understand
13:36:51 * Sparhawk sub set/list
13:37:04 <Cale> So for example, when we define a function by saying, e.g. f: R -> R such that f(x) = x^2 + x + 1
13:37:31 <Cale> We mean that f is the triple (R, R, {(x,x^2 + x + 1) : x in R})
13:38:59 <Cale> If you're unfamiliar with that notation, {form : condition} basically means the set of all things of the given form which satisfy the condition, i.e. that {(x,x^2 + x + 1) : x in R} means the set of all pairs (x, x^2 + x + 1) where x is an arbitrary real number.
13:39:37 <EvanR> (what is the use of the set in this construction if youre ok with triples and pairs, isnt there a more natural similar thing to just invoke for describing a function)
13:40:25 <Cale> EvanR: Well, we could use lambda, but that's a different approach to it, and it actually gets us a more restricted picture of what functions are.
13:40:36 <Sparhawk> I feel I am kinda wasting your time here and should go read set theory first. I honestly don't understand much here.
13:40:38 <EvanR> no lambda is something else
13:40:44 <Cale> Sparhawk: Okay, let's try a different approach
13:41:22 <Cale> Well, okay, let me be a bit less formal. The idea I'm trying to convey here is that a function consists of three things:
13:41:33 <Cale> 1) The collection of arguments which it might accept
13:41:51 <Cale> 2) The collection of results it might produce (but isn't required to produce -- this is like the result type)
13:42:15 <Cale> 3) For each argument it might accept, some corresponding result.
13:42:28 <Sparhawk> hey that I understand:p
13:42:51 <Cale> The function *is* precisely these data, taken as a whole
13:43:02 <Sparhawk> so arg(s), return value(s) and the operation(s) leading to a result?
13:43:08 <Sparhawk> or is the operations not included there
13:43:17 <Cale> Not operations, merely (input, output) pairs
13:43:25 <Sparhawk> mhm
13:43:45 <EvanR> the kicker being that theres only one one output for a given input
13:43:48 <Sparhawk> so the body is "invisible" here?
13:44:11 <Cale> Yeah, two functions which produce the same outputs for the same inputs are the same function, as far as we're concerned
13:44:26 <Sparhawk> oh I see
13:44:27 <Cale> and this information about how inputs are paired with outputs is all that a function is
13:44:39 <Sparhawk> kinda like encapsulation I guess
13:44:44 <Sparhawk> interface vs. implementation?
13:44:46 <Cale> anything else is a "side effect"
13:44:58 <EvanR> or that there is no body at all
13:45:07 <EvanR> all that matters is the interface
13:45:31 <Sparhawk> and a input-output isomorphism, unless I am totally abusing terms here
13:45:48 <dmwit> dfeuer: That would suit me just fine. I've dropped maintainership on several projects because of how unfun the associated tasks are for me.
13:46:01 <Cale> If there's anything more about our "function" than which inputs go with which outputs that we could potentially care about, then what we have is actually something more than just a function.
13:46:24 <Cale> Now, in practice we *at least* care about time and space performance
13:46:36 <dfeuer> dmwit, no problem. Associated tasks suck. As does deciding on the argument order for Data.Map.alterF. *headshake*
13:46:57 <Cale> But for the purposes of determining what a program means, we usually ignore those two things, even though they are ultimately important.
13:47:54 <dolio> We ignore it for some sorts of meaning, and not for other sorts.
13:47:58 <Cale> yeah
13:48:32 <danza> interesting, i never thought of performance as a side effect :)
13:48:49 <Sparhawk> well then I guess my question is what exactly constitutes input and what constitutes output
13:49:21 <EvanR> input is the a in (a,b) and b is the output
13:49:35 <EvanR> if there is only one a for a given b, then the function is reversible
13:49:50 <Sparhawk> well I mean in an actual function program implementation
13:49:50 <Cale> Or to put it another way, if you write y = f x, the x is our "input" and the y is our "output"
13:49:51 <EvanR> then you could think of either as either
13:50:22 <Cale> If f :: A -> B, then the input has type A, and the output has type B
13:51:01 <Sparhawk> but what must A be in a function? only what is in its argument?
13:51:10 <Cale> yep
13:51:16 <Sparhawk> what about upvalues
13:51:18 <Sparhawk> well, closures
13:51:26 <Sparhawk> not sure upvalues is a common term outside of Lua
13:51:41 <Cale> Closures are an implementation detail of one way we might implement functions
13:52:10 <EvanR> closure helps define a function, if you generate a function with a different context, then its just a different function
13:52:12 <Sparhawk> ergo, upvalues are fine?:p
13:52:46 <EvanR> context is used in math definition of functions all the time
13:52:47 <dmwit> Perhaps it would be worthwhile to introduce some terms to differentiate between "functions as mathematical objects, i.e. triples of domain, codomain, graph" and "functions as programming language constructs".
13:52:52 <Cale> I don't know what upvalues are -- it's a term in mathematica, but I don't know if it means what it does in Lua
13:53:28 <Sparhawk> in Lua an upvalue is a value in a closure which is "inserted" from the "up" function which defines it
13:53:51 <EvanR> Sparhawk: an equivalent way to think of this is if you have a function A -> B -> C, once you apply this to an A, you get a B -> C, which one depends on the A you passed in, and is no longer visible 
13:55:09 <EvanR> the A is trapped in the B -> C object
13:55:14 <danza> well you can have values, in an Haskell function, which are defined in the parent scope, right?
13:55:30 <Cale> So, the idea with closures is that we're going to represent functions at runtime as pairs, consisting of 1) some code which will take the argument to the function and compute the result, and 2) a finite map which assigns to each of the free variables in the definition of the function, some value, which will be the value that variable had when the function was being defined
13:55:51 <Sparhawk> http://pastebin.com/R2UwN51b "called" here being an upvalue
13:55:55 <Cale> The code in the first part of the pair may refer to the values in the mapping in the second part
13:56:33 <Cale> Sparhawk: Okay, so this involves mutation, which already goes beyond what a function is.
13:57:07 <Cale> This function does not just accept an argument and produce a value, it also alters the value of a location in memory.
13:57:10 <EvanR> Sparhawk: a function that has some fixed environment is just part of the definition of a function, its not an input really
13:57:38 <Cale> However, yeah, suppose we did something a little different:
13:57:55 <Sparhawk> Cale: well yeah but it is located in the function
13:58:25 <Cale> To use something more like the notation you're using, but with braces, suppose we have  function add(a) { return function(b) { return (a + b) } }
13:58:32 <dolio> No, your example _isn't_ a function.
13:58:39 <danza> Sparhawk, check what referential transparency and purity are
13:58:46 <dmwit> so many definitions of "function" floating around
13:58:50 <dolio> In the sense off mathematics.
13:58:58 <EvanR> so many 5-letter d-names
13:59:05 <Cale> Sparhawk: it's confusing because Lua and many other languages abuse the term "function" when they really mean "procedure"
13:59:23 <dmwit> dmwolianza
13:59:41 <Cale> Sparhawk: anyway, with this example
13:59:45 <Sparhawk> well then I obviously only mean function in the sense of procedure
13:59:47 <icicled> Does anyone know of companies where they hire intermediate Haskell programmers?
13:59:49 <Cale> Sparhawk: this really does correspond to a function
14:00:06 <Cale> It's the function which accepts a number as its input
14:00:19 <icicled> The ones I saw on the reddit thread this morning all seem to want advanced/seasoned/experienced Haskell programmers w/prior experience
14:00:21 <Cale> and produces as its result a function which accepts a number, and produces a number
14:00:25 <bmuk> Where does the Handler monad come from in Servant? I'm trying to separate my servant code into Lib while keeping the wai/warp stuff in Main
14:00:59 <Sparhawk> Cale: good point about function vs. procedure though, will keep that in mind;)
14:01:11 <Sparhawk> Cale: yeah I am familair with add
14:01:40 <Cale> Sparhawk: Here, the function in the body of the definition, the one we're returning,  function(b) { return (a + b) }
14:01:47 <bmuk> icicled: I know this isn't really an answer but you could either write a small project in haskell at your current job, or start building something on the side and turn that into a company
14:01:56 <Cale> includes a variable which is not bound in that expression
14:02:01 <Cale> namely, a
14:02:01 <Sparhawk> yes, a closure
14:02:02 <bmuk> Depending on your work situation, of course
14:02:10 <Cale> No, the variable isn't a closure
14:02:17 <Cale> and the function itself isn't a closure
14:02:32 <Cale> But we might use a closure as a mechanism to represent the function at runtime
14:02:54 <mizu_no_oto_work> icicled: where do you live?  What kind of background do you have?
14:03:02 <Sparhawk> well 'a' would be the upvalue
14:03:04 <Cale> We might also take a very different approach to implementing the language
14:03:10 <Sparhawk> and yeah closure is an implementation detail I guess+
14:03:15 <Sparhawk> guess?*
14:04:12 <Cale> We might actually not form a closure, but instead, construct a new copy of the code for the function, with the value of a substituted in place. It would behave identically in terms of the result of the program, but it wouldn't involve a closure.
14:05:34 <Sparhawk> you mean just creating function(b) return a + b end and toss add out of the...equation?;)
14:05:38 <Cale> Or we might be using some sort of graph reduction evaluator where we're rewriting expression graphs, and there's nothing necessarily which looks like a closure then
14:05:55 <Cale> I mean, say we apply  add(5)
14:06:17 <Cale> then we might just form in memory  function (b) { return (5 + b) }
14:06:29 <Cale> We might even just compile that code in place
14:07:08 <bmuk> Here is the relevant stacktrace and source files: https://gist.github.com/bmuk/46c18ea74481eb0ab6539c3115417d18
14:07:31 <Cale> Rather than what a closure looks like, which would be something like (function (b) { return (a + b) }, [a => 5])
14:07:33 <Sparhawk> yeah well it works as long as you can simply insert it, obviously
14:07:42 <Cale> (to arbitrarily choose a notation for mappings)
14:08:06 <Sparhawk> but if you want a fun hot *procedure* like "once" it doesn't do as well does it
14:08:07 <Cale> The thing about closures is that all our closures which came from the same definition can refer to the same code in memory, saving some space
14:08:19 <Cale> Well, it may do just as well
14:08:45 <Sparhawk> but where to put "called" then?
14:08:49 <Cale> You have to be cautious about how the effects interact with your implementation of procedures
14:08:59 <icicled> bmuk: typically at current jobs they have a set stack - it's very hard to convince folks to use a new language especially if you're the only one who knows it (what happens when you leave, etc)
14:09:00 <Cale> But there's no reason to assume that closures are the only way
14:09:20 <Sparhawk> for the recrod what you describe above may actually be how Lua implements add()
14:09:21 <icicled> bmuk: the second option I am working on but realistically it will fail :P
14:09:36 <icicled> rather, the odds are stacked against me
14:09:47 <bmuk> by the time you fail you will be a seasoned haskell programmer, by definition :p
14:09:50 <Cale> In particular, you might allocate 'called' on the heap, and build a copy of the function which directly contains a pointer to the space you allocated, rather than storing that reference separately
14:10:40 <icicled> mizu_no_oto_work: in the usa - my background is mostly in java & python - I've been doing fun projects on and off in Haskell for the last couple of years
14:10:53 <Sparhawk> well that may actually be how Lua implements it
14:11:01 <Cale> Like, do you store the code, along with a mapping [called => 0x4738c8bf] from the variable name to the pointer
14:11:10 <jacereda> is it possible to get something like gshow using uniplate? What I need is to select a deeply nested field in a record (given its location as [String]) and show it
14:11:15 <Cale> or do you build a copy of the function with the pointer directly included in it
14:11:17 <Sparhawk> I only know that the function created by once() does not depend on once() being "alive"
14:11:31 <Cale> In the first case, you have a closure, in the second, you don't.
14:11:49 <Cale> Closures aren't really a language-level feature at all, they're an implementation-level feature
14:12:14 <Cale> Knowing about them might be necessary to understand the space performance of your programs, for instance
14:12:56 <Cale> but if they're being used to properly implement abstract procedures or functions, there's no way you could know for sure as a programmer that they're being used, without digging into the output of your compiler
14:13:02 <Sparhawk> "Because of the lexical scoping rules, local variables can be freely accessed by functions defined inside their scope. A local variable used by an inner function is called an upvalue, or external local variable, inside the inner function."
14:13:07 <mizu_no_oto_work> icicled: try sending your resume to https://www.greathorn.com/careers/  They're a Boston based startup, with some infrastructure in Haskell, node and (iirc) python.
14:13:20 <Sparhawk> that's all I know that's all I really care about
14:13:29 <Cale> Sparhawk: right :)
14:13:53 <Cale> Usually we refer to such variables as "free variables"
14:14:25 <Cale> The formal parameters to a function, i.e. the 'b' in  function (b) { ... } are considered "bound"
14:15:02 <Cale> and variables which aren't introduced like that by any of the constructs in an expression, are considered "free"
14:15:02 <Sparhawk> right this suddenly feels familiar somehow
14:15:04 <Sparhawk> bound and free
14:15:32 <icicled> mizu_no_oto_work: do they happen to allow remote work? I'm not on the east coast =\
14:15:49 <Sparhawk> scope deciding what the free name is bound to
14:15:59 <mizu_no_oto_work> I don't know if they do or not.
14:16:09 <Sparhawk> like in human language:)
14:16:10 <Sparhawk> context
14:16:11 <icicled> thakns mizu_no_oto_work, I'll check it out
14:16:17 <Cale> In the presence of variables which refer to mutable cells, you always have the question of whether or not to carry along the current value of the mutable cell, or the reference to the cell.
14:16:32 <Cale> free variables which do so
14:16:56 <Cale> This is an ambiguity caused by the fact that reads and writes to mutable variables are implicit in such languages
14:17:03 <Cale> Well, moreso the reads
14:17:09 <mizu_no_oto_work> Are you located in a major tech hub?  I'd talk to some local recruiters; there are various small startups who use some amount of Haskell that you'd primarily hear about via word-of-mouth
14:17:41 <Cale> You can write things like  x + 5  where x is not actually an integer, but a memory location where an integer is stored, and the language will compile code which looks up the value at the memory location and adds 5 to it.
14:17:45 <Sparhawk> also in Lua this is a bit more complicated by the fact that there is only 1 really "free" name which everything not bound "locally" is bound to:p
14:18:23 <Cale> If your reads are explicit, then the distinction becomes much more apparent
14:18:23 <Sparhawk> which is a set I guess
14:18:28 <Sparhawk> an environmnet set
14:19:13 <Cale> For example, in Haskell, we have IORefs, which are mutable cells which can be read and written to by IO actions, and if I have, say, some  IORef Integer  in scope
14:19:25 <Sparhawk> hmm this is about mutability right?
14:19:35 <Cale> well, let's write an equivalent to your Lua
14:20:52 <icicled> I am in a tech hub, it just happens to be all Java, .Net, or JS, w/other dynamic languages sprinkled around
14:21:02 <icicled> I think my only luck would be moving to either coast
14:21:14 <icicled> or remote which would work
14:24:11 <lpaste> Cale pasted “once” at http://lpaste.net/163605
14:24:15 <Cale> Sparhawk: ^^
14:24:49 <Cale> Here, it's clear just from the types of everything involved, that the thing we're capturing is an IORef Bool
14:24:54 <Cale> and not a Bool
14:25:05 <Cale> We could write a broken version of this...
14:25:51 <lpaste> Cale annotated “once” with “once (broken because the read is moved outward)” at http://lpaste.net/163605#a163606
14:26:17 <Sparhawk> a second trying to understand the first version:p haven't actually read Haskell before
14:26:22 <Cale> okay
14:26:45 <Cale> So executing  newIORef False  constructs a new mutable cell whose initial value is False
14:27:06 <Cale> and  called :: IORef Bool  is the result of that
14:27:21 <Sparhawk> so language constructs are immutable, except those mutable cells?
14:27:42 <Cale> yeah, all the variables themselves don't change what they're referring to while they remain in scope in Haskell
14:28:13 <EvanR> mutable cells arent part of the language proper, they are runtime objects and haskell just juggles references to them
14:28:27 <EvanR> the references are immutable (and abstract)
14:28:30 <Cale> I would say that IORef is part of Haskell...
14:28:40 <EvanR> IORef the type ? ;)
14:28:48 <Cale> The type and the operations which act on it.
14:28:55 <EvanR> i was talking about the mutable cells
14:29:04 <Cale> IO actions are part of Haskell. :)
14:29:14 <EvanR> mutable cells arent IO actions!
14:29:39 <EvanR> you cant type a mutable cell into the code
14:29:45 <Cale> Well, okay, the IORef is represented at runtime by a pointer to allocated memory :P
14:29:51 <Cale> fair enough
14:30:06 <EvanR> yeah its a pointer
14:30:16 <EvanR> not to be confused with the object that can be mutated
14:30:21 <maerwald> when nitpicking becomes trolling... it's a thin line my friends :P
14:30:31 <Cale> Well, I sort of think referring to IORefs as "mutable cells" is fine.
14:30:45 <Sparhawk> and if you did not use this IORef that function would not be possible to write in Haskell?
14:30:52 <EvanR> informally yes, but Sparhawk almost got confused about what is and isnt immutable in haskell
14:31:05 <EvanR> the answer is everything is immutable
14:31:27 <c_wraith> well. all name bindings are immutable. 
14:31:35 <EvanR> maerwald: we havent even begun, wait until the meaning of the word "variable" comes into question!
14:31:35 <Cale> Sparhawk: correct -- well, there would be a bunch of other options available to us, but they'd all be at least as explicit about allocating some memory and that some sort of explicit effect was occurring
14:32:07 <c_wraith> and global values are name bindings, too! 
14:32:16 <Cale> (Haskell ironically has more types of mutable variables and arrays than most imperative languages)
14:32:26 <Sparhawk> so, everything immutable by default
14:32:30 <EvanR> c_wraith: and values are immutable
14:32:38 <Cale> right, and not only by default
14:32:43 <maerwald> EvanR: it'll end up in a discussion about language itself and Wittgensteins theories
14:33:04 <Cale> but for example, this variable 'called' is the name of a thing, and 'called' itself can't change which IORef it's referring to.
14:33:19 <Sparhawk> and you basically have to explicitly allocate writeable cells for mutable data?
14:33:21 <Cale> We can, via writeIORef, change the value stored in that IORef
14:33:34 <c_wraith> EvanR, I don't think that's consistent with reference values. they really do change. but the name bindings don't. 
14:33:44 <Cale> But that doesn't change which IORef 'called' is
14:33:45 <EvanR> c_wraith: the IORef doesnt change
14:33:52 <EvanR> the "Ref"
14:34:22 <Cale> Sparhawk: yeah -- of course, we don't do a whole ton of this, because we have a whole other style of programming without much mutation in the first place
14:34:47 <Cale> Sparhawk: but when we *do* need it, it's kind of nice that everything is explicit regarding the order in which things occur
14:34:48 <c_wraith> EvanR, if you're talking about the name, yes it's still the same name. if you're talking about the value itself - it is a pointer that does actually change. 
14:35:14 <EvanR> the value itself, is the name
14:35:33 <Cale> It can be very hard trying to figure out what an imperative program might do where you have an expression like f(g(x),h(y)), and the g and h might have effects that interfere with one another
14:35:42 <c_wraith> I don't consider that viewpoint to be a useful abstraction. 
14:35:43 <Sparhawk> so the variable holds a reference, which is modified via IORef
14:36:20 <EvanR> it explains why you can pass an IORef around and its always pointing at the same cell
14:36:22 <Sparhawk> but I assume one can easily change what a variable references?
14:36:33 <Cale> called is simply a name for the IORef which we got by executing newIORef
14:37:02 <EvanR> you dont store the contents of the cell is a struct, its the reference
14:37:32 <Cale> Sparhawk: Every variable retains the same value throughout its scope.
14:37:33 <Sparhawk> I mean "var = 5" followed by "var = 6" or whatever
14:37:44 <Cale> Doing something like that would result in shadowing.
14:38:26 <Sparhawk> so the second statement just creates a new variable?
14:38:26 <Cale> They wouldn't be the same var -- the compiler might warn you that you've shadowed a variable which was already in scope, and none of the things whose definitions involved the original var would be affected.
14:38:29 <Cale> yeah
14:38:53 <Sparhawk> "var = var + 1" is legit?
14:39:00 <Cale> That'll be a recursive definition
14:39:03 <maerwald> :o
14:39:04 <EvanR> > let var = var + 1 in var
14:39:06 <Cale> and will probably result in an infinite loop
14:39:08 <lambdabot>  mueval-core: Time limit exceeded
14:39:26 <Cale> > let ones = 1 : ones in ones
14:39:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:39:34 <EvanR> @let var = var + 1
14:39:35 <Cale> ^^ useful for building infinite lists
14:39:35 <lambdabot>  .L.hs:154:7:
14:39:36 <lambdabot>      Ambiguous occurrence ‘var’
14:39:36 <lambdabot>      It could refer to either ‘L.var’, defined at .L.hs:154:1
14:39:56 <Cale> :t var
14:39:58 <lambdabot> String -> Expr
14:40:00 <Cale> huh
14:40:06 <Sparhawk> let itisoverninethousand = 1 : itisoverninethousand in itisoverninethousand
14:40:10 <Sparhawk> :|
14:40:18 <Sparhawk> err
14:40:20 <Sparhawk> 9001*
14:40:21 <Sparhawk> whatever
14:40:22 <EvanR> @let bomb = bomb + 1
14:40:23 <lambdabot>  Defined.
14:40:27 <EvanR> :t bomb
14:40:28 <lambdabot> Num a => a
14:40:32 <Sparhawk> shadowing instead of mutation
14:40:52 <EvanR> Sparhawk: some languages dont let you shadow, and its really annoying
14:41:06 <Cale> But yeah, at the top level, it won't generally let you shadow like that, it's only if you have nested 'let's or subsequent lines in a do-expression
14:41:21 <Sparhawk> and let does what?
14:41:33 <Cale> let <declarations> in <expression>
14:41:54 <Cale> is an expression form which locally introduces the given declarations, and allows you to use them in the expression part
14:41:57 <Sparhawk> it re-declares?
14:42:19 <Cale> > let { x = 3; y = 4 } in x^2 + y^2
14:42:21 <lambdabot>  25
14:42:35 <Cale> > let f x = x^2 + x + 1 in map f [1..10]
14:42:36 <lambdabot>  [3,7,13,21,31,43,57,73,91,111]
14:43:00 <Maria1> .help
14:43:11 <Cale> Maria1: What can we help you with?
14:43:33 <Maria1> (sorry I typed "/help" too quickly haha)
14:43:38 <Cale> Sparhawk: So if we have nested lets...
14:43:55 <Cale> > let x = 5 in let x = 6 in x + x
14:43:57 <lambdabot>  12
14:44:06 <Cale> It just uses the innermost definition
14:44:08 <Maria1> otherwise that would've been the worst request ever
14:44:19 <Sparhawk> Cale: actually I think you have convinced me well enough to stay far away from Haskell:p
14:44:29 <Cale> Sparhawk: why?
14:44:34 <EvanR> i so wish other languages had "let"
14:44:47 <Cale> Sparhawk: This might seem weird at first, but it makes programs easier to understand.
14:45:04 <Sparhawk> it seems a very contrived way to do everything
14:45:08 <Sparhawk> not weird, contrived
14:45:27 <EvanR> Sparhawk: a more common way to bind variables is with a where clause
14:45:31 <Cale> Sparhawk: The fact that a variable never changes what it's referring to means that you don't have to go through the entire program code looking for all the things which might have altered it.
14:45:33 <EvanR> its equivalent to using lets though
14:45:48 <Cale> Sparhawk: You only have to find where it's introduced, and this tells you what the variable means.
14:46:10 <Cale> If it's a function parameter, it might take on different values each time the function is applied
14:46:33 <Cale> But if it's introduced locally, it will have some meaning in terms of the things already in scope, and that meaning will not change.
14:46:41 <eperzhand> Hello, guys! Does anyone know what is "meomorphism"?
14:46:43 <Cale> --> you don't need a debugger to understand wtf is going on
14:47:06 <jle`> morphism involving a cat?
14:47:08 <Cale> eperzhand: A typo of some sort perhaps? I've never seen that one before.
14:47:11 <jle`> but this gets into cat theory
14:47:15 <jle`> which i'm not too good at
14:47:39 <Cale> It might be drop 2 "homeomorphism"
14:47:40 <posi> [art
14:47:42 <Maria1> "homeomorphism"?
14:47:43 <eperzhand> jle`: now meoworphism
14:47:45 <eperzhand> not
14:47:45 <Sparhawk> eh I dunno
14:48:08 <Sparhawk> anyway I would need a big nice fat referencem manual to understand the other 90% of what you guys were saying
14:48:11 <EvanR> Sparhawk: before discounting it, it helps to try it
14:48:14 <Cale> Homeomorphisms are isomorphisms of topological spaces.
14:48:33 <eperzhand> Cale: me too, but heard today that there is such thing as a meomorphism
14:48:51 <Cale> meromorphism?
14:48:52 <eperzhand> Nope, certainly not a "homeomorphism"
14:49:15 <Cale> (Though "meromorphism" is unusual, you'd more often hear "meromorphic function"
14:49:16 <Cale> )
14:49:41 <EvanR> Sparhawk: before learning haskell i had a head start, the book SICP (based on scheme) covers a lot of really good programming concepts, and when haskell was invented it took all that and ramped it up to 11
14:50:27 <Cale> Sparhawk: Haskell certainly requires a bit of effort to learn, because it's not essentially a reskinning of a language you already know.
14:50:36 <EvanR> skills you learn here can help in real life programming in more dysfunctional systems
14:50:44 <Cale> Sparhawk: But I don't think it's any worse than learning your first programming language.
14:50:51 <maerwald> EvanR: wat?
14:50:59 <maerwald> haskell made me a worse programmer
14:51:19 <EvanR> not i, now i have a body proofs in my head at all times when defensively writing js or ruby
14:51:22 <lambdafan> Given data Foo a = Foo { .. }, is it possible to have something like a List such that I can have a [Foo Bar, Foo Baz]. Doesn
14:51:34 <lambdafan> doesn't need to be a list, just something mappable
14:51:45 <maerwald> I get into code and think I can understand the code by looking at it
14:51:52 <maerwald> then I realize no... I can't, because this is not haskell
14:51:55 <Sparhawk> well again I didn't really come here to learn Haskell
14:52:05 <Cale> I think Haskell made me a better programmer in imperative languages, but it also made me hate what I was doing a whole lot more. It makes you acutely aware of all the potential problems in typical imperative code.
14:52:11 <EvanR> yes you have to backtrack and do a huge audit to understand any piece of code, thats just how it is
14:52:14 <EvanR> at least now you know
14:52:30 <maerwald> I knew before already, haskell just made me develop bad expectations
14:52:30 <Cale> Sparhawk: Like, did you examine that "broken" version of the once example?
14:52:54 <Cale> Sparhawk: Even though it's "broken" with respect to the function we're writing, that's certainly a behaviour you might want in some cases!
14:53:00 <EvanR> maerwald: bad expectations?
14:53:04 * hackagebot hablog 0.4.0 - A blog system  https://hackage.haskell.org/package/hablog-0.4.0 (gilmi)
14:53:05 <maerwald> yes
14:53:11 <EvanR> i dont understand
14:53:26 <EvanR> unmet good expectations?
14:53:40 <Cale> Sparhawk: The fact that there's an explicit difference between a name for a mutable cell, and a name for its value means that we get to say which of those two things we mean
14:53:51 <Cale> Rather than just hoping that the language has the right semantics
14:54:06 <Cale> (and then getting frustrated when it doesn't)
14:54:12 <maerwald> expecting anything to be remotely sane and idiomatic is a bad expectation if you are dealing with real world code, so "bad" is correct
14:54:16 <Sparhawk> Cale: you made "b" false so the if will always fail?
14:54:26 <Cale> Sparhawk: right, in this case
14:54:37 <EvanR> haskell doesnt have "expect everything to be like haskell" as a principle to learn ;)
14:54:49 <Cale> Sparhawk: But we might actually want to read a mutable cell, and produce something based on its value at the time that the function was defined
14:54:56 <maerwald> I don't understand what that means
14:54:58 <EvanR> a side effect is that , no not everything is, now i know
14:55:09 <Sparhawk> but you have just written to that cell
14:55:15 <Cale> Sparhawk: rather than giving the function/action a reference to the cell which it can read later, and potentially edit
14:55:15 <Sparhawk> will it ever return not False?
14:55:34 <Cale> I mean, in this particular program, it will only ever have b = False
14:55:46 <EvanR> maerwald: i learned haskell basically last in sequence, so i guess maybe thats why i didnt get bad expectations
14:55:49 <Cale> But in general, we might've got the IORef from somewhere else
14:55:58 <Sparhawk> but what if someone uses it
14:56:01 <maerwald> EvanR: I don't think that is related
14:56:11 <Cale> Well, the IORef doesn't escape the scope of this function
14:56:15 <EvanR> i still expect java to be like java, even after haskell
14:56:21 <Cale> So nobody else can use it
14:56:36 <EvanR> you dont expect qwerty to be like dvorak or whatever ;)
14:57:08 <Sparhawk> oh it does not escape
14:57:08 <Cale> Sparhawk: But yeah, we might've taken an IORef Bool from the rest of the program, and wanted to construct a function based on its current value
14:57:22 <Sparhawk> so "if b" does the ioRead?
14:57:33 <Cale> nope, the readIORef does that
14:57:48 <Cale> b is just a Bool
14:58:04 <Cale> i.e. it's either True, or it's False, and it's not ever going to change on us
14:58:30 <Cale> Whether we do the readIORef inside the action being returned, or from outside it
14:58:41 <Cale> makes a big difference to how the program behaves
14:58:57 <Cale> Most imperative languages with lambdas don't let you express this difference clearly
14:59:04 <maerwald> EvanR: I am pretty sure one cannot just "disable" expectations, even if he knows logically better. Especially when he's done one thing for a long time and then switches to another.
14:59:05 <Cale> They just pick one of the two conventions
14:59:37 <Sparhawk> I sitll don't understand the difference
14:59:51 <Sparhawk> will both versions only do the call once?
14:59:54 <EvanR> maybe instead of expectations, i should construe this to mean higher standards
15:00:04 <Cale> The second version will do it every time
15:00:14 <EvanR> i prefer not to use crap systems because the features are not up to snuff
15:00:35 <EvanR> so then im a worse programmer
15:01:06 <Cale> In the second one, we define b to be the result of reading the IORef immediately after we just created it, with the initial value False
15:01:12 <Cale> So b will always be False in that version
15:01:35 <Cale> In the first version, we make the readIORef part of the action that we're returning
15:01:43 <Sparhawk> that was what I asked and I thought I got a different answer than what you just said
15:01:45 <maerwald> it's an actual problem if you are set back into inferior languages with not only a different paradigm, but also completely different mindset... both in the sense that you get less done than others and in the sense that you need longer to understand that utter crap, because the way you read haskell is so different
15:01:57 <Cale> So, b will be True or False depending on whether we've updated the IORef yet
15:02:37 <EvanR> maerwald: so youre saying, its not like riding a bike
15:02:44 <EvanR> in the never forget sense
15:02:45 <Sparhawk> well yes then I understand, any mutable data requires explicit alloc/read/write
15:02:45 <Cale> Whether we do the read inside the body of the action being returned, or before we return the action, is a huge difference then, right?
15:02:57 <Sparhawk> you have taken immutable state as far as possible, good job
15:03:00 <Cale> But most imperative languages hide this from you
15:03:18 <Cale> They let you just refer to called, and there's some convention about when called gets read.
15:03:38 <Cale> Do we capture a reference to the mutable variable itself, or do we capture the value of the mutable variable?
15:04:17 <EvanR> Sparhawk: in purely functional programming, there is no state. its anarchy!
15:04:47 <maerwald> EvanR: well, you don't forget how to _write_ another language (as in rules), but you forget how to _think_ in another language. The latter is something that needs to be maintained via practice. Just like any craft.
15:05:17 <EvanR> you could also, maybe inaccurately, make an analogy to forgetting how to speak english after learning a foreign language
15:05:24 <EvanR> (if english is your native language)
15:05:26 <Sparhawk> well I am not discounting this Haskell paradigm entirely I just feel my hairs rise seeing it
15:05:29 <maerwald> And the degeneration process is very hard when you get into haskell, because it's really THAT different to the rest of the imperative world.
15:05:43 <maerwald> so if you want to be a good programmer, don't learn haskell :P
15:06:14 <Sparhawk> but then I am kinda deep into a multi-paradigm language here:p
15:06:20 <EvanR> Sparhawk: certain problem domains are very ammenable to functional programming, for example the classic web handler that returns a page
15:06:32 <EvanR> and many other things
15:06:41 <Cale> Sparhawk: Well, you might be scared about the verbosity of this, to which I can reply with the fact that it's possible to define operators and shorthands for doing any combination of these things.
15:06:44 <EvanR> some more or less embracing functional and some not
15:06:54 <Cale> I'm just being very explicit on purpose here.
15:07:11 <EvanR> yes being able to easily factor out repetative code is FP 101
15:07:52 <Sparhawk> let's say I am more into functionall programming that goes quite this far
15:07:55 <Cale> Sparhawk: But you shouldn't be too scared about the meaning of the program -- surely, it's clearer in Haskell's case than in Lua's -- at least once you get over the syntax of things.
15:08:39 <Sparhawk> what if the Lua code is perfectly clear and explicit as well
15:09:09 <Cale> Well, it is clear, but something which matters about the order in which things are done is being decided by an arbitrary convention
15:09:20 <EvanR> the lua code for coming maps is a lot more verbose, and that makes it less to clear to me
15:09:26 <EvanR> from composing maps*
15:09:34 <Cale> In this case, it's clear what the convention does, and the situation is simple enough for us to check that it's right
15:09:50 <Sparhawk> Cale: which arbitrary convention?
15:09:54 <Sparhawk> EvanR: which code?
15:09:58 <Cale> But in more complicated situations, it's very easy for a mutable variable to get captured when you meant to capture its value
15:10:06 <glguy> What's the Lua code being discussed? (is specific code being discussed?)
15:10:12 <Cale> http://pastebin.com/R2UwN51b
15:10:30 <Cale> glguy: Standard "run once" code which captures a mutable variable
15:10:40 <glguy> Thanks!
15:11:19 <jacereda> how are things like "fn :: (Show a, Data a) => a -> String" implemented? are there two implicit parameters beign passed to 'fn' with sort of vtables containing the 'methods' for Show and Data?
15:11:28 <Cale> jacereda: That's right.
15:11:37 <Sparhawk> it should actually memoize the result as well but I tore out the WIP code
15:12:11 <Cale> actually, that would make the Haskell version clearer perhaps
15:12:43 <EvanR> Sparhawk: map (f . g . h) xs
15:12:57 <EvanR> with 5 lines of iterators this is ridiculous
15:12:58 <jacereda> Cale: so, can very long chains of (Foo a, Bar a ...) hurt performance? Or is the compiler smart enough?
15:13:15 <Sparhawk> EvanR: huh?
15:13:33 <lpaste> Cale pasted “making a cache” at http://lpaste.net/163612
15:13:34 <Sparhawk> "it's very easy for a mutable variable to get captured when you meant to capture its value" you mean |local capture = called| ?
15:13:46 <Cale> jacereda: They could, to some small extent
15:14:00 <Cale> jacereda: But usually function parameters are not insanely expensive
15:14:09 <jacereda> Cale: ok, thanks
15:14:41 <Cale> Sparhawk: Suppose we have some mutable variable x = 5
15:15:09 <Cale> and we define a function f (a) { return x + a } in the middle of our procedure
15:15:19 <Cale> and then we go on to use f below that
15:15:30 <Cale> Perhaps x gets updated in between
15:15:37 <Cale> Which function is f?
15:16:08 <Cale> Does it use the new value of x, or the value that x had when we defined f?
15:16:33 <Cale> It's very easy to make a mistake.
15:16:50 <EvanR> ... wait, what value does it use?
15:17:03 <Cale> Turns out it uses the new value of x, in Lua.
15:17:03 <Sparhawk> I have actually noted this "problem" before and know how to fix it
15:17:05 <Sparhawk> well in Lua
15:17:13 <Sparhawk> or other languages
15:17:24 <EvanR> ok
15:17:36 <Sparhawk> just distinguish between primitive values and references to primitive values
15:17:45 <EvanR> it could go either way, conceptually
15:17:54 <Cale> When your reads are explicit, it's obvious which is which because you either have an explicit read before defining the procedure, or an explicit read inside the procedure.
15:17:56 <Sparhawk> and implement references by wrapping primitive valus inside objects
15:18:12 <EvanR> Sparhawk: thats whats nice about haskell is that "value" means "value"
15:18:24 <EvanR> no arguing, earlier discussion notwithstanding
15:18:26 <Cale> Sparhawk: Yeah, that's exactly what we're doing in Haskell with IORef.
15:18:42 <Sparhawk> letting one have both immutable state and references to values
15:18:56 <Cale> You can also have an IORef (IORef String) or whatever
15:19:13 <EvanR> IORef is such an object
15:19:15 <Sparhawk> if I wrote something like that in Lua I would be lynched I am afraid
15:19:23 <Sparhawk> but you made me realise the value of primitive objects
15:19:30 <Sparhawk> referencing
15:20:10 <c_wraith> I like that "value objects" are a hit new fad in some languages. :) 
15:20:15 <Cale> haha
15:20:25 <EvanR> luckily we dont have a culture of wanting to modify values of integer yet
15:20:35 <EvanR> let 5 = 3 in ...
15:20:40 <Sparhawk> value objects is a thing?
15:20:59 <Sparhawk> oh wow it is
15:21:06 <Sparhawk> and I came up with it all by myself
15:21:08 <Cale> > let 5 = 3 in 5 + 5
15:21:09 <Sparhawk> gjhf
15:21:10 <lambdabot>  10
15:21:15 <Cale> heh
15:21:29 <EvanR> Sparhawk: numbers, characters, bools arent special. you often want to treat custom data types just like them, they arent objects, they are just values
15:21:32 <Cale> (*this* one is an obscure peculiarity of the Haskell syntax)
15:22:07 <jacereda> is it possible to implement gshow with uniplate?
15:22:13 <Sparhawk> please no more Haskell I am confused enough already
15:22:17 <Cale> It's just that numbers can be used as patterns which only match the given number, and when you define something you're allowed to pattern match, but that means you can pattern match and bind no variables with a number.
15:22:18 <c_wraith> Cale, is there some reason a compiler can't say "I see this binding doesn't bind anything.. error!"? 
15:22:32 <Cale> c_wraith: Not any particularly good reason.
15:22:40 <Cale> Probably it should at least be a warning
15:22:40 <EvanR> > let [1] = [] in 5
15:22:42 <lambdabot>  5
15:22:46 <EvanR> that is weird
15:23:03 <EvanR> why isnt that a pattern match failure
15:23:13 <c_wraith> laziness 
15:23:15 <Cale> Because pattern bindings are lazy
15:23:26 <puregreen> > let ![1] = [] in 5
15:23:28 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in pattern binding
15:23:30 <EvanR> nice
15:23:52 <EvanR> > let !5 = 3 in 5+5
15:23:54 <lambdabot>  *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
15:23:57 <EvanR> > let !5 = 5 in 5+5
15:23:59 <lambdabot>  10
15:24:06 <Cale> > case 3 of 5 -> 5 + 5
15:24:07 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
15:24:38 <EvanR> Sparhawk: before you leave, my advice is that learning more kinds of programming topics will help you no matter what
15:26:04 <Cale> I *was* going to introduce the reader monad at one point... Maybe that should be saved for when Sparhawk inevitably gets hooked and wants to see some examples of monads.
15:27:00 <Cale> (because his initial line of questioning was about whether 'this' counts as an effect)
15:27:02 <EvanR> no more haskell, lets you become addicted to the feel
15:27:33 <hpc> look down, look up, this channel is now #rust
15:28:21 <Cale> Actually, I've never thought to do it, but you *could* use the (->) e monad with e being some object-style record type containing a bunch of methods...
15:28:40 <Cale> Oh, but that doesn't quite work, because the parameters are in the wrong order
15:28:57 <Cale> Fixable problem, but not automatically a really nice syntax for working with objects :)
15:29:16 <EvanR> implicit parameters!
15:29:28 <Cale> I often use RecordWildCards
15:29:51 <Cale> mkFoo args = Foo {..}
15:30:01 <Cale>   where ... define methods here...
15:30:24 <hpc> i am sure you could do something with lens to make a js-like or lisp-like OO system
15:31:06 <Boomerang> I prefer NamedFieldPuns to RecordWildCards, because at least you know where the variables comes from :)
15:31:17 <Cale> Boomerang: That is a good point
15:31:39 <Sparhawk> EvanR: well right now I am stealing ideas from programming paradigms left and right
15:31:49 <Boomerang> But you can always use both if a function needs a lot of fields in a record
15:32:33 <Sparhawk> because in a multiparadigm language such as Lua I can actually implement most language features I care for
15:32:41 <EvanR> Sparhawk: believe it or not, the book types and programming languages covers a lot of different phenomena in programming, not just functional programming
15:32:53 <Boomerang> What do you guys think of the record syntax in Elm? :) It's pretty cool!
15:33:32 <EvanR> and it uses a better syntax than lua
15:33:49 <Sparhawk> which the book?
15:33:55 <EvanR> yes
15:34:19 <EvanR> 70% of my repetitive stress injuries are from writing lua
15:34:30 <EvanR> (without an IDE)
15:34:43 <Sparhawk> do I smell a fellow notepad++-er?
15:34:44 <dolio> Are there IDEs?
15:34:53 <Sparhawk> ZeroBrane is pretty nice
15:35:04 <Cale> Boomerang: It's quite similar to some things which were in Hugs and other early Haskell implementations. That kind of thing can work out pretty well.
15:35:05 <Sparhawk> also written entirely in Lua and uses Lua as its configuration format
15:35:13 <Sparhawk> i am not sure how to make it more Lua
15:35:41 <Sparhawk> but yeah I gave up Notepad++ pretty quick;o
15:35:42 <Cale> Boomerang: Ermine does it even better, by giving you constraints on your row variables which let you express that some row can be partitioned into two parts
15:35:57 <Sparhawk> also found the book
15:36:14 * Sparhawk hands EvanR most obtuse sentence of the month award
15:36:27 <EvanR> for what
15:36:37 <Sparhawk> <EvanR> Sparhawk: believe it or not, the book types and programming languages covers a lot of different phenomena in programming, not just functional programming
15:36:44 <maerwald> EvanR: http://www.workrave.org/
15:36:45 <Boomerang> Cale: I've never heard of Ermine, will look into that! I like Elm's dot notation to access fields (a bit like lenses).
15:37:22 <Cale> Boomerang: I actually can't stand that, because in my head, dot means composition.
15:37:30 <maerwald> any spacemacs users here? https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/haskell#ghc-mod-users this doesn't seem to work, it's still trying to use GHCi-ng crap
15:38:06 * hackagebot monad-journal 0.7.2 - Pure logger typeclass and monad transformer  https://hackage.haskell.org/package/monad-journal-0.7.2 (DimitriSabadie)
15:39:07 <Cale> Boomerang: So, the constraint a <- (b,c) in Ermine means that the fields in the row type a can be partitioned into disjoint sets of fields b and c
15:39:35 <Boomerang> Cale: yeah that is fair enough, switching from haskell to elm back and forth is not that easy... Have you seen how record types can be built using other ones (at the bottom of this page: elm-lang.org/docs/records). I find that very interesting and brings some OO concepts like inheritance
15:40:06 <Cale> So for example,  join : (d <- (a,b), e <- (b,c), f <- (a,b,c)) => [..d] -> [..e] -> [..f] is the type of something which basically does a database join on lists of records.
15:40:22 <Boomerang> * http://elm-lang.org/docs/records
15:40:49 <dolio> [] are actually database relations. List is List.
15:40:55 <Cale> oh, right
15:41:09 <exio4> Boomerang: you mean like subtyping? :P
15:41:18 <Sparhawk> anyway I will leave you to your Haskell and go back to my Lua:)
15:41:45 <Boomerang> Yes (it's late). I guess Haskell can do similar things using classes anyway :)
15:41:49 <Cale> Sparhawk: Feel free to come and ask lots of questions here if you ever decide to learn Haskell :)
15:42:05 <Sparhawk> sure will do:P
15:42:10 <Sparhawk> oh one more thing
15:42:22 <Sparhawk> does "this" count actually count as a side effect?:P
15:42:42 <Cale> Sparhawk: Sort of -- it's implementable using pure functions, but it's not something that pure functions have.
15:43:11 <Sparhawk> the main idea there is sort of to bridge OOP with FP
15:43:16 <Cale> Sparhawk: In Haskell, we have a monad which basically gives you the effect of "this", locally, by passing a parameter along implicitly.
15:43:53 <Sparhawk> and it reads/writes to a shared environment?
15:43:59 <Cale> Just reads from
15:44:03 <hpc> Sparhawk: "this" is context-sensitive
15:44:17 <Cale> There's a different monad which lets you write as well.
15:44:23 <hpc> Sparhawk: as a result, (f x) == (f x) might not hold, depending on how you got to f
15:44:26 <Sparhawk> yes, context, function context
15:44:46 <Sparhawk> well it holds when called in the same context
15:45:16 <hpc> indeed, and with Reader that context is implemented as a function parameter
15:45:35 <hpc> which you can do explicitly, in which event it's no longer this
15:46:06 <Cale> Sparhawk: So if you want to think of 'this' as simply an additional function parameter, then sure, you have honest functions without side effects.
15:46:12 <hpc> or implicitly, in which case it's put behind (>>=) and such, and therefore a side effect
15:46:28 <Cale> The only "effect", if you want to call it that, is making the parameter passing implicit.
15:47:25 <Cale> Well, there's also a certain amount of recursion which is involved, usually, since you're referring to the object which you are presently defining.
15:47:41 <hpc> and yeah, we're using a very particular meaning of "side effect" that's based on how functionality is presented
15:47:42 <Cale> (but we don't consider such recursion an effect here, usually)
15:48:13 <Cale> In Haskell, we might define a record data type like
15:49:00 <Cale> data Object = MkObject { display :: IO (), timeStep :: DeltaTime -> Object, ... }
15:49:36 <Cale> and then what might be subclasses in an OO setting we'd typically just render as functions which construct values of that type
15:49:42 <Sparhawk> so |function(this, arg) this.field = arg end| and |_ENV.this = this; function(arg) this.field = arg end| are really considered the same then?
15:50:05 <Cale> and if we wanted to use something akin to 'this' inside the definitions, we'd have to use recursion
15:50:41 <EvanR> exio4: Boomerang extensible records with scoped labels for the win (msresearch paper)
15:51:06 <Sparhawk> (_ENV here is Lua's only free name, the this.field is lexically scoped to _ENV.this.field)
15:52:05 <EvanR> i heard you like metatables, so i made a metatable for metatables
15:52:18 <Sparhawk> ...you can actually do that
15:52:23 <hpc> i never metatable i didn't like
15:52:38 <Sparhawk> how can one now like metatables
15:52:55 <EvanR> ruby is meta table taken to its logical extreme
15:52:58 <EvanR> and it aint pretty
15:53:07 <Sparhawk> what does it do?
15:53:25 <EvanR> nicer syntax for doing basically meta tables
15:53:25 <hpc> you should try dereferencing a string sometime in php
15:56:03 <Boomerang> exio4: in the case of Elm's extensible records isn't it as much inheritance as it is subtyping? I know they're both very similar but I think I understand the difference. I just want to know why you think it's subtyping in this case :)
15:57:28 <EvanR> its more useful for subtyping to be a think completely unrelated to inheritance
15:57:57 <EvanR> subtyping applies more generally as a relation between two types, and inheritance is an ad hoc code reuse feature
15:58:07 * hackagebot pandoc-crossref 0.2.1.3 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.2.1.3 (lierdakil)
15:58:18 <EvanR> and some languages combine them into the same concept with detrimental results
15:59:53 <Boomerang> I see, that makes sense. What would be an haskell equivalent to these extensible records? Would it be implemented with classes?
16:00:33 <EvanR> theres vinyl
16:00:38 <Boomerang> By the EvanR you're not evancz, right?
16:00:42 <EvanR> no
16:00:45 <Boomerang> ok :)
16:01:21 <Boomerang> Oh vinyls look nice, thanks!
16:04:08 <jle`> EvanR: are you evanrelf
16:05:28 <dedgrant> I wish the error of believing (class) inheritance is subtyping was more commonly understood in C++ and Java circles. It is deeply problematic because algebraic properties of subtyping are not enforced.
16:09:44 <Sparhawk> dedgrant: do elaborate?
16:11:48 <dedgrant> Sparhawk: Oleg covered it quite well with examples: http://okmij.org/ftp/Computation/Subtyping/
16:15:55 <josephle> probably better to read the papers he cited: https://pdfs.semanticscholar.org/a850/7025bfa3b29d1efee53011d6ae4d76f4c325.pdf
16:17:52 <dedgrant> Ah, thank you! Also puts a point on the time line.
16:18:26 <Sparhawk> 1990
16:18:38 <Sparhawk> almost the best year ever
16:19:08 <josephle> refer to section 3 specifically
16:19:39 <josephle> tl;dr if you do the obvious thing and represent objects as recursive records, inheritance and subtyping begin to diverge
16:19:54 <Boomerang> Thanks for the links! :)
16:20:13 <Sparhawk> recursive records?
16:20:34 <orion> My program is exiting with "read failed". What is the best procedure to track this down?
16:21:00 <josephle> Sparhawk, hmm, the best way to put it is records that refer to themselves
16:21:18 <josephle> to represent the "self/this" reference in OOP
16:21:40 <Boomerang> Sparhawk: data Tree a = Empty | Node { value :: a, left :: Tree a, right :: Tree a}
16:23:47 <Sparhawk> mhm
16:26:51 <slack1256> is the only front-end for reflex the reflex-dom package?
16:27:03 <slack1256> is there something that targets more traditional desktop targets?
16:27:22 <maerwald> nothing useful afaik
16:28:34 <slack1256> :-(
16:31:48 <shanemikel> @help
16:31:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:31:53 <shanemikel> @list
16:31:54 <lambdabot> What module?  Try @listmodules for some ideas.
16:31:56 <shanemikel> @listmodules
16:31:56 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
16:32:50 <Sparhawk> thanks for the subtype/subclass stuff very interesting
16:33:05 <Sparhawk> am doing some basic OOP implementation myself, that will sure come handy...
16:35:11 <shanemikel> ehh.. what was the other code generator, the slightly less terminating one?
16:35:51 <slack1256> The C backend? I thought it was deprecated except for porting GHC
16:36:56 <Boomerang> shanemikel: maybe djinn? you can also experiment with lambdabot as much as you want using /msg lambdabot
16:37:16 <orion> hmm
16:37:23 <shanemikel> found it. exference
16:37:36 <Boomerang> alright, didn't know that one :)
16:39:31 <shanemikel> how do I lift up two levels in the transformer stack?
16:40:28 <slack1256> lift . lift (dumb i know)
16:40:30 <slack1256> or use mtl
16:42:45 <shanemikel> what does mtl do differently?  you mean the specialized functions like liftIO, etc?
16:43:09 <orion> So, within a State Monad I have the line "hs <- get". If that line occurs /before/ a certain line, the whole program crashes with the error "read failed". If it's /after/ that certain line, it does not crash.
16:43:29 <orion> Does this sound like a GHC or RTS bug?
16:43:38 <orion> I'm not in IO.
16:44:14 <glguy> it sounds like the line that you're moving the get around is changing the returned value of get from something that evaluates to an error to something that doesn't
16:44:36 <orion> https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/NoiseState.hs#L111 <-- if that line is put above the "x <- ..." line, I get a crash, if it's directly beneath it it works.
16:45:52 <nineonine> hi there !
16:46:08 <nineonine> im reexporting my all types
16:46:15 <nineonine> through 1 module
16:46:17 <nineonine> for haddock
16:46:34 <nineonine> but i get conflicting exports
16:46:47 <nineonine> is ther a way to deal wit hit without renaming record fields ?
16:47:42 <orion> glguy: On that source file I linked to... line 107./
16:48:10 <orion> How could that single line of code alter the "hs" variable when it never mentions/uses hs?
16:48:16 <shanemikel> that's a big messy program to expect somebody here to trace through
16:48:31 <Cale> eh, I'll have a quick look
16:48:41 <orion> so: Suggestions welcome.
16:49:30 <Cale> Well, where might you be using read in this code?
16:49:50 <glguy> orion: each line in the do-notation used with StateT can alter the result of executing "get"
16:49:59 <shanemikel> the `resume . runHandshake ...' line is another state monad
16:50:02 <glguy> so it's not surprising that moving the line around would change the result
16:50:04 <jle`> ~,
16:50:06 <jle`> ~
16:50:08 <jle`> ~,
16:50:24 <Cale> shanemikel: ... action.
16:50:30 <shanemikel> state changing is implicit, and it's likely you have a lazy bottom
16:50:45 <Cale> jle`: ?
16:50:48 <jle`> sorry
16:50:52 <jle`> was trying to quit out of ssh
16:50:55 <Cale> ah
16:51:27 <Cale> orion: Which way around is it that the exception occurs?
16:51:36 <Cale> orion: and what is the exact text of the exception?
16:52:36 <shanemikel> is this your code?
16:52:51 <Cale> orion: also, where are you applying this function, and what is the ns parameter set to there?
16:53:46 <orion> shanemikel: yes
16:53:47 <Cale> I see the usages in writeMessage/readMessage
16:54:04 <Cale> But they're passing along an ns from somewhere else
16:54:15 <orion> Cale: The exception occurs if "hs <- get" is above line 107.
16:54:36 <orion> $ ./dist/build/vectors/vectors
16:54:36 <orion> vectors: read failed
16:54:51 <Cale> oh, interesting
16:55:03 <Cale> I wonder what library throws that
16:55:12 <orion> Is there a way to find out?
16:55:51 <Cale> orion: What's the initialisation of the NoiseState parameter look like in your program?
16:56:08 <Cale> It comes in as an argument here, and is passed down through a couple other things
16:56:24 <EvanR> random exceptions with no indication of where they came from... i guess haskell isnt the best imperative language ;)
16:57:23 <orion> Cale: https://github.com/centromere/cacophony/blob/master/tests/vectors/Handshakes.hs#L29
16:57:35 <Cale> Well, that's kind of the point of exceptions that you don't need to specify which types of exceptions you're throwing, otherwise you might as well use Either or ExceptT or something.
16:57:39 <simpson> EvanR: Useful stack information for debugging has been a weak point of GHC for a long time. :c
16:57:55 <Cale> Yeah, I guess it doesn't help that there's no such thing as a call stack
16:59:07 <EvanR> the power of the stack that everyone somehow understands exists in other languages
16:59:33 <EvanR> maybe theres a way to fake it in haskell
17:00:11 <EvanR> instead of a call stack, its a path to the source code where the call was defined
17:00:19 <EvanR> the throw
17:00:31 <dolio> GHC 8 has that.
17:00:37 <dolio> Everyone was complaining about it when they found out.
17:00:50 <Cale> orion: https://github.com/centromere/cacophony/blob/31875ed5a5a4cbbe38d2cab5fc4e178609761844/benchmarks/bench.hs#L96
17:00:51 <EvanR> really?
17:00:55 <dolio> Yes.
17:01:02 <glguy> but really?
17:01:03 <EvanR> complaining why
17:01:04 <dolio> Because it shows up in the type.
17:01:08 <EvanR> oh
17:01:14 <orion> Cale: Oh crap
17:01:17 <orion> Now I feel stupid. :(
17:01:18 <Cale> orion: No idea if that code is even potentially running, but it sure looks suspicious
17:01:37 <Cale> orion: It's a good idea to include at least the function name in your error messages
17:01:43 <Cale> also, don't use error for this :P
17:01:58 <orion> Cale: Well, it should "never happen
17:01:59 <orion> "
17:02:12 <orion> actually
17:02:19 <orion> bench.hs isn't the program I'm running.
17:02:26 <Cale> right...
17:02:45 <dolio> GHC 7.10 has some kind of stack traces, too, but you have to turn on profiling.
17:02:47 <Cale> Are you running Generate?
17:02:50 <orion> yup
17:02:54 <orion> Just saw that line there.
17:02:57 <Cale> https://github.com/centromere/cacophony/blob/31875ed5a5a4cbbe38d2cab5fc4e178609761844/tests/vectors/Generate.hs#L85
17:05:14 <orion> Thank you.
17:05:30 <Cale> orion: perhaps try  (error . ("genMessages: read failed " ++) . show)
17:06:31 <Cale> orion: You'd also get the error sooner if you were using case rather than let
17:06:51 <Cale> because it would force the evaluation of the pair, causing the error to happen right away
17:07:18 <orion> Cale: Indeed, that should prove helpful.
17:32:49 <zennist> this might be an old question - is there a `fmod` function around?
17:33:54 <EvanR> hmm
17:34:20 <EvanR> > properFraction (1337.7 / 10)
17:34:21 <lambdabot>  (133,0.7700000000000102)
17:34:44 <EvanR> nope
17:34:47 <zennist> yeah some thread led me to look at that function too - I'm currently implementing one using that, but is dreading about the efficiency
17:35:00 <EvanR> i just wrote
17:35:16 <EvanR> fmod x y = x = y * realToFrac floor (x / y)
17:35:28 <EvanR> fmod x y = x - y * realToFrac floor (x / y)
17:35:37 <EvanR> which is probably broken for negatives
17:36:45 <zennist> why do you need the realToFrac?
17:37:01 <EvanR> > floor 3.14 :: Double
17:37:02 <lambdabot>      No instance for (Integral Double) arising from a use of ‘floor’
17:37:03 <lambdabot>      In the expression: floor 3.14 :: Double
17:37:19 <EvanR> you can also FFI into the C Math library
17:37:22 <zennist> ah right
17:38:52 <dolio> What's fmod?
17:39:17 <EvanR> x - y * floor(x/y), at least for positive numbers
17:40:24 <EvanR> the remainder of x not fittable in integer number of y's
17:40:38 <dolio> > (1/2) `mod'` (1/3)
17:40:40 <lambdabot>  0.16666666666666669
17:40:43 <dolio> Is it that?
17:40:57 <EvanR> > 100 `mod'` 9
17:40:59 <lambdabot>  1
17:41:08 <EvanR> :t mod'
17:41:09 <lambdabot> Real a => a -> a -> a
17:41:17 <EvanR> o_O
17:41:54 <Xnuk> :t mod
17:41:55 <lambdabot> Integral a => a -> a -> a
17:42:00 * EvanR looks for mod'
17:42:30 <Nnotm> > mod' pi 1
17:42:31 <zennist> Data.Fixed
17:42:31 <lambdabot>  0.14159265358979312
17:42:54 <Xnuk> > 100 `mod'` pi
17:42:57 <lambdabot>  2.610627738716417
17:42:57 <EvanR> sweet
17:43:33 <Nnotm> (I suppose floor would be faster for what I wrote...)
17:44:03 <Nnotm> ah wait
17:44:09 <Nnotm> I just read the previous discussion
17:44:13 <Nnotm> looks like it could be useful after all
17:45:06 <EvanR> looking at the code for mod' and div' im not sure what would be faster
17:45:35 <EvanR> fastest for Double -> Double -> Double i would guess is math.h
17:50:53 <zennist> is there any performance difference between: let .... in do {...} vs do { let ....; ...} ?
17:52:37 <Zemyla> The transformers-base package sounds like it's describing Metroplex or Trypticon.
17:53:04 <zennist> I somehow always have the weird belief that the former is 'better' - yet maybe they are the same
17:54:04 <Nnotm> I haven't thought too much about it, but wouldn't desugaring both of those result in pretty much exactly the same code?
17:54:06 <sqrt2> zennist: iirc there's a step in optimisation that ghc does where it moves let bindings as far inwards as possible
17:54:27 <sqrt2> so i'd say let the compiler worry about it
17:54:49 <EvanR> when you doubt the compiler, you compile your doubt
17:54:59 <Rotaerk> IMO you should move the let bindings inward anyway, not as an optimization, but to make it more readable
17:54:59 <Nnotm> such deep wisdom
17:55:05 <EvanR> lol
17:55:29 <Rotaerk> i.e. if the let binding is further out, you have more code to go through to track how it's used
17:55:49 <zennist> this sounds like a memory wise optimization - but, is it actually always good?
17:56:03 <sqrt2> http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz
17:56:15 <sqrt2> this is the paper that describes the reasoning behind -ffloat-in
17:56:19 <sqrt2> (i haven't read it)
17:56:46 <zennist> say your monad vary its effect from time to time depending on different invocations - but the let bindings are pure functions with pure results, wouldn't it actually be better just to store those results across different invocations..
17:57:12 <EvanR> zennist: even then it might not be stored...
17:57:32 <EvanR> depending on how you structure it or how you invoke it
17:58:40 <EvanR> lazy evaluation isnt memoization
17:59:53 <dolio> Part of the definition of do desugaring is 'do { let .... ; ... } = let .... in do { ... }'
17:59:56 <zennist> yeah - somehow I'm always having hard time connecting my brain to how the machine actually thinks when it runs my code...*especially* with the way the 'let' bindings work
18:00:24 <zennist> i.e. the way it acts as a sort of variable to some extent but not always
18:00:57 <EvanR> graph reduction, lambda cloning, etc
18:01:06 <EvanR> instantiation of lambdas
18:01:26 <sqrt2> dolio: how can that be true? i can define let bindings in a do block using values that were bound only by a previous bind operator
18:01:31 <EvanR> it wont reuse any work from previous call
18:01:57 <dolio> There are no previous bind operators.
18:02:11 <Nnotm> sqrt2: do {let ... ; ...} = let ... in do { ... } only if the `let' is the first line in the do block
18:02:27 <sqrt2> Nnotm: right
18:02:45 <sqrt2> so a let deeper inside a do block lets you do things that a let outside doesn't
18:03:02 <Nnotm> I would suppose so
18:04:14 <EvanR> it would be cool if a function could start evaluating even if it doesnt have all arguments yet, up to the point you need to argument
18:04:20 <EvanR> sort of like a coroutine
18:04:48 <zennist> need to perform free variable analysis
18:05:00 <zennist> and maybe take in the concept of constexpr as in c++
18:05:02 <dolio> But it can.
18:05:07 <dolio> Using par.
18:05:16 <EvanR> interesting
18:05:51 <EvanR> i should have said, a function starts without having its 1 argument, up to the point it needs that argument
18:06:08 <EvanR> and thats the final form of the function as such
18:06:37 <EvanR> but it might be even harder to predict memory usage
18:06:49 <zennist> I'm always under the impression that - the big performance challenge of haskell *is* memory, yet if we can assume infinite memory, it has so much more potential to be faster
18:10:13 <geekosaur> not really. gc affects latency more than outright performance. the question is whether you're using laziness and strictness correctly, or wastefully building up thunks (even with infinite memory, this can mean taking twice as long to do something)
18:10:21 <geekosaur> (or worse)
18:10:39 <zennist> and all the problems with gc pauses... I hope one day someone can implement a memory architecture on the hardware level designed for functional languages (and take advantage of functional language's properties on a lower-level)
18:11:08 <zennist> yes, you are right
18:13:48 <EvanR> either way i hope one day someone implements infinite memory
18:13:53 <EvanR> i take what i can get
18:15:42 <EvanR> (maybe this way, a compression algorithm that either fits what you need into memory you have, or takes so long to work that by the time it gives you the answer, you have bought enough extra memory to fit it)
18:26:20 <jakeehrlich> Does anyone have a recommendation on how I could render individual pixels to a window? Is there a lighter weight way to do this?
18:27:05 <EvanR> gloss can do that
18:27:24 <EvanR> with very small squares, but it wont be efficient
18:27:46 <EvanR> SDL can do that
18:28:36 <dolio> Very small triangles is probably better than squares.
18:28:56 <jakeehrlich> looking into gloss now
18:29:05 <EvanR> thats probably what gloss is using for squares
18:29:33 <dolio> Yeah, but it might draw two very small triangles per very small square.
18:29:48 <EvanR> yes, otherwise it wont be the right color
18:30:04 <EvanR> because FSAA
18:30:10 <EvanR> or multisampling
18:30:25 <koz_> I have a type 'data X = Foo Int | Bar Int', and I wanna write a function that compares X's 'inner Ints' and returns a Bool based on that comparison. How would I write this without having to write 4 comparisons?
18:30:39 <koz_> (said function would have signature X -> X -> Bool)
18:31:28 <EvanR> f compare x y = intOf x `compare` intOf y
18:31:44 <koz_> intOf?
18:31:55 <EvanR> intOf (Foo i) = i
18:32:00 <EvanR> intOf (Bar i) = i
18:32:01 <koz_> Ah, OK.
18:32:06 <koz_> Makes sense now, thanks EvanR.
18:33:21 <shanemikel> is #stack the right place to go with build failure?
18:33:26 <jakeehrlich> so Gloss was super easy to setup. had to compile to run unfortuentlly but that was a very solid recomendation
18:33:33 <shanemikel> (of a stackage package)
18:33:53 <EvanR> jakeehrlich: i had the same experience
18:34:09 <koz_> Is Data.Set an ordered set?
18:34:26 <dolio> Just like some people do ray tracing in fragment shaders by making two triangles that cover the screen, but edwardk told me it's better to make one triangle that can obscure the whole screen.
18:34:26 <byorgey> jakeehrlich: make sure you take a look at gloss-raster
18:34:50 <EvanR> if its bigger than the screen, i can see how that would work
18:35:51 <EvanR> i guess you can make a triangle bigger than a pixel and then use a specially crafted shader
18:36:12 <jakeehrlich> byorgey: That might just be what I want actully. I don't need to add these pixels in real time just display images so this might really work out well
18:36:22 <byorgey> koz_: yes, in the sense that it requires the elements to have an ordering, for efficiency
18:36:31 <koz_> byorgey: That's what I was after, thanks!
18:36:32 <byorgey> koz_: and you can efficiently get the sorted list of elements out
18:38:13 <troydm> is there inverted arguments monad bind function?
18:38:26 <byorgey> troydm: yes, (=<<)
18:38:35 <troydm> ohh yeah right
18:38:35 <koz_> troydm: byorgey beat me to it.
18:38:43 <troydm> byorgey: thx
18:38:45 <koz_> Also, byorgey, thanks *so much* for the Typeclassopedia.
18:38:52 <byorgey> troydm: sure
18:38:54 <koz_> I think I thanked you once before, but I'm not sure if you saw it.
18:39:08 <byorgey> koz_: you're welcome, glad you find it helpful =)
18:39:28 <shanemikel> very helpful, indeed
18:39:50 <shanemikel> best article on the wiki
18:39:56 <koz_> Agreed shanemikel.
18:40:01 <koz_> Very very helpful.
18:40:17 <koz_> Although I still have to admit I don't *quite* understand how comonads == OO.
18:40:31 <koz_> I read the blogpost on this topic, but I'm not sure I'm smart enough to get the correspondence.
18:40:50 <EvanR> hah i remember that
18:41:16 <EvanR> also existential types == OO
18:41:30 <jakeehrlich> man thanks guys. gloss is amazing to get started with and seems like it should work preety well for my applications
18:42:00 <EvanR> if you can get it to load images tell me how you did it ;)
18:42:00 <koz_> EvanR: *That* one I get a little more.
18:42:30 <EvanR> also jquery == a monad
18:42:35 <byorgey> koz_: comonads == OO?  wait, is that in the Typeclassopedia?  I don't remember that one
18:42:46 <koz_> byorgey: It links to a blogpost on that topic.
18:42:56 <koz_> (from the Comonad section obviously)
18:42:57 <byorgey> ah
18:44:27 <jle`> i'm not sure if even Tekmo (the original blog post writer) still believes that comonads == OO
18:44:45 <koz_> jle`: What makes you say that?
18:44:58 <jle`> the blog post is a bit dismissive of comonads as a concept
18:45:04 <koz_> I'm kinda trying to understand the logic behind the statement, and despite multiple re-reads of that blogpost, I still don't get it.
18:45:13 <jle`> but i think when he talks about it now, he's a bit more respectful/appreciative of comonads
18:45:50 <jle`> i know he's recanted some of his statements about the utility of operators
18:46:08 <jle`> i'm not sure i believe half of the things i blogged about two years ago heh
18:46:10 <jle`> s/two/three
18:46:16 <EvanR> comonads are functors first, so first step is to see how OO can be a functor
18:46:38 <EvanR> if at all
18:47:23 <EvanR> i would be interested in a blog post about THAt ;)
18:47:57 <shanemikel> you talkin' about this? http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
18:51:24 <shanemikel> It looks like I'm on my way to nesting StateT monads. any wisdom, libraries, what-have-you?
18:52:58 * EvanR tries to stop shanemikel but is too late
18:54:11 <thimoteus> i've never done so out of sheer terror, but i wish you luck!
18:55:26 <shanemikel> also, I'd like to abstract over states, so I can, say specify that the state is type 'a such that is has a field 'someField (does lens do this?)
18:56:48 <scshunt> shanemikel: my advice is a) don't, b) what exactly are you trying to actually do?
18:57:03 <byorgey> shanemikel: look at http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-TH.html#v:makeClassy
18:57:23 <scshunt> you may also find Control.Lens.Zoom useful
18:58:41 <byorgey> shanemikel: instead of having two StateTs, just combine the two states into a single state, and use tools from lens (like Zoom that scshunt linked to) to deal with it
18:58:42 <shanemikel> Oh, wow.  that's exactly it.  thanks
18:59:23 <shanemikel> I wonder if he wears a cape...
19:04:01 <shanemikel> a bit suspicious since watching some Wadler presentations
19:26:29 <carter> Woot, my ghc Mac build for 8.0.1 is good to go! Mwhahahaha
19:40:51 <Zemyla> byorgey: Actually, I can see a case where you'd need two different StateTs.
19:41:15 <Zemyla> StateT s (MaybeT (State s')).
19:48:14 <Fare> Hi.
19:48:34 <Fare> I'm looking for a public to rehearse my presentation at BostonHaskell tomorrow.
19:49:02 <Fare> It takes a bit over an hour
19:56:02 <MichaelK> Hi, is there any way to control the internal representation of a data type? (I'm thinking Data.Type.Natural sort of thing here)
19:59:54 <geekosaur> only some limited things like -funbox-strict-fields, or using Foreign.Storable (i.e. accessing things like C structs)
20:00:06 <geekosaur> anything else likely requires modifying ghc
20:00:10 <geekosaur> 's runtime
20:01:13 <shirt> what is the "Args" parameter in Cabal UserHooks? https://www.haskell.org/cabal/release/latest/doc/API/Cabal/Distribution-Simple.html#t:UserHooks
20:02:34 <MichaelK> geekosaur: could using a wrapper type work? i.e. newtype NatInt = NatInt Nat Int? Then shouldn't it still be protected by the typechecker and laziness allow the nat to never be calculated at runtime?
20:03:09 <MichaelK> (supposing you never put one into a strict function)
20:03:26 <geekosaur> hm. that I wouldn't know offhand
20:03:40 <nitrix> MichaelK: The definition is just above defaultMainWithHooksArgs :: UserHooks -> [String] -> IO ()
20:03:41 <geekosaur> oh, I think that won
20:04:06 <geekosaur> ... never mind, thinking about it wrong. (getting late here)
20:04:06 <nitrix> MichaelK: I'm guessing it's a convenience type `Args = [String]` to represent the program arguments.
20:04:56 <MichaelK> nitrix: what?
20:05:17 <nitrix> MichaelK: ./foo -x
20:05:17 <geekosaur> nitrix confused you with shurt
20:05:20 <geekosaur> shirt
20:05:23 <nitrix> MichaelK: An argument.
20:05:40 <MichaelK> ah
20:05:47 <nitrix> Oh, whoops.
20:06:04 <geekosaur> ...that typo. I must be tired...
20:06:09 <MichaelK> nitrix: no worries
20:06:12 <nitrix> We're all :P
20:06:16 <nitrix> shirt: ^ see above
20:06:19 <shirt> nitrix: but which arguments? and how do i set them? it is always an empty list. and there is no documentation anywhere
20:07:45 <nitrix> shirt: getArgs >>= defaultMainWithHooksArgs yourHook
20:07:51 <nitrix> shirt: import System.Environment (getArgs)
20:11:11 <nitrix> You could leave it empty with: `defaultMainWithHooksArgs hooks []` or just use the one that implicitly uses getArgs, defaultMainWithHooks.
20:11:40 <nitrix> Let me pull it out from the sources...
20:11:42 <nitrix> defaultMainWithHooks :: UserHooks -> IO ()
20:11:44 <nitrix> defaultMainWithHooks hooks = getArgs >>= defaultMainHelper hooks
20:13:55 <shirt> nitrix: right i see that, but how does the user pass in Args that will eventually be delivered to preBuild?
20:14:19 <shirt> nitrix: i'm using defaultMainWithHooks
20:15:05 <byorgey> Zemyla: good point.
20:15:45 <Zemyla> byorgey: But I think at that point, you'd want to define it yourself, instead of using transformers.
20:15:51 <MichaelK> geekosaur: I think it works, are you interested?
20:16:08 <parsnipM_> what does `cabal sandbox add-source ../hello-haskell' do? i don't see any changes in directories after this command. 
20:16:52 <nitrix> shirt: defaultMainWithHooks uses defaultMainHelper, which uses buildAction which eventually setups preBuild with the arguments passed to it.
20:17:08 <Welkin> it adds it as a source for imports
20:17:21 <Welkin> so you can import the modules from it
20:17:27 <nitrix> shirt: Leap of fate, you can just trust that it'll do its thing if you can't be bothered to look at the code; or paste your Setup.hs file if it doesn't work.
20:18:01 <parsnipM_> Welkin: trying to troubleshoot, thought i might look for some change in a file or directory after the command. 
20:18:16 * hackagebot automotive-cse 0.1.5.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.5.0 (KeiHibino)
20:18:20 <shirt> nitrix: thanks for your help, but i still don't understand. are the "Args" supposed to be the command line arguments that the user added to the "cabal build" command?
20:18:22 <Welkin> the comonad
20:18:55 <nitrix> shirt: I think "build" is an arg.
20:19:42 <nitrix> I haven't touched it in a few months; if you had something to share, I could look at it too :)
20:19:57 <shirt> nitrix: hm... I'm seeing just empty list [] for Args
20:29:19 <nitrix> shirt: Maybe I'm wrong, maybe those are arguments for the command being run.
20:29:35 <nitrix> shirt: I'm not sure what are the extra things you can do with `build`.
20:30:12 * geekosaur is thinking that question should maybe be asked in #ghc
20:31:12 <shirt> nitrix: ok thanks. i'm trying to figure out the best way to allow the user to set a configuration option for my custom preBuild step
20:32:45 <nitrix> I think you're supposed to have program specific options, like --myapp-options="--with-sparkles"
20:33:06 <Welkin> "I liek sparkles!"
20:33:21 <Mutter> Hi...
20:33:22 <nitrix> shirt: I've never used any of it, I'm just a sponge trying to give you things to lookup :)
20:33:30 <Welkin> Mutter: WHERE IS VATER!?
20:33:35 <Mutter> Hi...mutter
20:33:53 <Mutter> Anyone from from Asia
20:34:19 <Welkin> nein
20:34:32 <geekosaur> I think this user is completely unfamiliar with what they've just gotten into...
20:34:40 <Mutter> Hi Welkin 
20:34:53 <Mutter> Hi geekosaur 
20:35:22 <geekosaur> (Mutter is a web irc client. apparently it, or the user, just picked the top visible chatroom...)
20:35:31 <Welkin> lol
20:35:47 <nitrix> shirt: Check on github how people use it in their code, it might help: https://github.com/qxjit/polygod/blob/e9e5ff573ecd2e4ff60bac460f88caf6da073f16/Setup.hs
20:35:50 <Mutter> Hi Welkin 
20:35:51 <monochrom> don't answer to answer. just don't answer.
20:36:10 * monochrom is a great dualist
20:36:18 <Mutter> Hello is Hillary Clinton winning 
20:36:22 <monochrom> or dualizer. I don't know
20:36:30 <Welkin> Mutter: Mutter haben Sie unter dem Wohnzimmertisch Scheiße?
20:36:42 <Mutter> Hallo senior
20:37:04 <EvanR> "For the code examples in this section, it is tempting to write . . . $ do . . ., but that would not work with our control-channel implementation of backtracking in Section 5.2, because the type of the computation passed to that runL must be polymorphic, which the “predicative” rank-2 polymorphism in Haskell [19] does not allow in an argument to $."
20:37:16 <EvanR> this paper's footnote says, but i thought $ was magic?
20:37:20 <nitrix> shirt: This one sets up a main with `hooks`, replacing runTests with this custo runTests' function, ehm... which someone builds the application to run it with multiple flags. Here's a good usecase of that ["build"] args I think.
20:37:23 <Mutter> Hello
20:37:37 <Mutter> Hello
20:37:39 <Mutter> Hello
20:37:44 <nitrix> shirt: Maybe there are better examples in the wild.
20:37:46 <monochrom> EvanR: right, that sentence was probably written a long time ago
20:37:57 <geekosaur> also it's magic but may not be magic *enough*
20:38:05 <Mutter> Hello
20:38:07 <geekosaur> it's kind of a specific hack
20:38:10 <Welkin> Mutter: goodbye goodbye
20:38:11 <Mutter> Can I be ur fren
20:38:20 <Mutter> Welkin: 
20:38:30 <Mutter> Don't go Welkin 
20:39:53 <geekosaur> oh, not webirc, it's an iThing client
20:40:11 <monochrom> what is an iThing?
20:40:13 <EvanR> how i learned to stop worrying and love $ magic: see more use cases for monads that use higher ranked types
20:40:21 <geekosaur> Mutter, I'm not sure how much you understand of this, but this channel is specifically about the programming language Haskell. If you're looking for a general chat channel, try #defocus; if you're looking for help with IRC, try #freenode
20:40:37 <geekosaur> monochrom, whatever Apple says it is
20:40:49 <monochrom> iSee  <duck>
20:41:26 <Mutter> Hello
20:41:40 <Mutter> How can i join
20:41:55 <Welkin> Mutter: 闭嘴
20:42:13 <Mutter> Anyone from Asia
20:42:16 <Mutter> Well
20:42:19 <nitrix> ASM reports 3 k-lines, 2 bans, 1 kick, 1 quiet in 3 months.
20:43:09 <dibblego> what is ASM?
20:43:17 * hackagebot managed 1.0.4 - A monad for managed values  https://hackage.haskell.org/package/managed-1.0.4 (GabrielGonzalez)
20:44:01 <geekosaur> dibblego, AntiSpamMeta bot
20:44:06 <geekosaur> I presume from the report
20:50:59 <Welkin> you hurt mummy's feelings
20:51:05 <Welkin> mutter left
20:52:24 <nitrix> He doesn't wants to get k-lined again, but I've still raised the issue with the staff.
20:52:28 <nitrix> Poor thing :(
20:53:01 <Welkin> lol what? again?
20:53:19 <nitrix> #haskell's not the most interesting playground - for a troll.
20:54:10 <Welkin> nitrix: what if it's *on the internet* though?
20:56:01 <geekosaur> I still think they don't grok irc and picked the top channel in a list sorted reverse by size
20:56:32 <Welkin> it would have been better if someone named Vater entered too
20:56:36 <Welkin> and they had a fight
20:56:37 <geekosaur> which would possibly be on whoever made that app to provide slightly more information to newcomers
20:57:00 * geekosaur did visit mutterirc.com but has no particular interest in walled-garden programs
20:57:18 <Welkin> urbanslug: we know it's you zipper!
20:57:31 <Welkin> we can smell you from 1 AU away
20:57:51 <Welkin> geekosaur: is it german?
21:00:25 <geekosaur> doesn't look it, but not really enough info to tell
21:00:41 <geekosaur> and whois on mutterirc.com says "private registration"
21:01:13 <Welkin> so not "mutter" as in "mother", but rather "to mutter insults under your breath"
21:01:24 <geekosaur> yeh
21:01:34 <Welkin> toob ad
21:01:45 <Welkin> I should make an irc client named Vater
21:02:09 <geekosaur> ...and everyone not German will think you misspelled "Vader" :p
21:02:13 <monochrom> "whois 180.193.86.155" says a Philipine ISP
21:02:19 <Welkin> and a torrent client named Schwester
21:08:36 <emmanuel_erc> Hello there. I'm starting to realize as I write more Haskell, that it may be better to place behaviors about my datatypes into respective instances (and perhaps defining classes if necessary). Is this standard practice?
21:10:28 <geekosaur> emmanuel_erc, only if classes/instances are needed to do it. otherwise it smells like trying to do OO with typeclasses
21:10:40 <Welkin> lol
21:10:45 <geekosaur> I think more often records get used for behaviors?
21:10:51 <Welkin> I see that a lot with people
21:10:52 <Welkin> hahaha
21:11:09 <EvanR> records should be used more often for interfaces
21:11:14 <Welkin> "I feel like there is a better way to do this. I know! I'll use OO!"
21:11:39 <emmanuel_erc> Well, I suppose it seems like I am describing OO.
21:12:09 <Welkin> that's one reason people avoid introducing typeclasses to new haskell users
21:12:12 <Welkin> they go nuts with them
21:12:23 <EvanR> and if the point of subtyping is to do implicit conversion, this is trivially supportable in haskell either by doing an explicit conversion, or using something like Convertible
21:12:34 <emmanuel_erc> I just found that it was getting tedious to write a particular behavior about a particular datatype and my life got easier after just creating a Num instance (and perhaps others) for that datatype.
21:12:54 <Welkin> oh yes, using instances of existing typeclasses is good
21:12:56 <EvanR> Num for number types makes sense
21:13:02 <Welkin> everyone does that
21:13:22 <Welkin> but creating completely new typeclasses is rare
21:13:27 <geekosaur> yep. it's designing classes of your own that you should stop and think if that's really the appropriate solution
21:14:14 <emmanuel_erc> I see. I would imagine that creating your own custom classes would require a great deal of care. And it already seems like the Haskell libraries cover a lot of ground.
21:14:42 <EvanR> and if the point of implementation inheritance is to get reuse out of common code, then functional programming has great ways to do that without inheritance. and the logical extreme of this is a combinator DSL
21:17:45 <nitrix> emmanuel_erc: You should see typeclasses more like "extending the language" and try to use it sparingly.
21:18:41 <emmanuel_erc> nitrix: Understood.
21:20:01 <nitrix> emmanuel_erc: It's more normally done in libraries to generalize the operations on a group of types and make the library more convenient/powerful/usable in a variety of contexes; not really to mimick OOP because it's the only mental model you know ;)
21:20:10 <nitrix> Although you totally can, but you'll see it's limited.
21:21:17 <emmanuel_erc> I wasn't really trying to do OOP programming in Haskell. But I could perhaps see why I would want to be wary of such thinking.
21:21:34 <emmanuel_erc> Thanks for the words nitrix, Welkin, and geekosaur.
21:21:41 <emmanuel_erc> and EvanR.
21:21:59 <nitrix> e.g. [a] requiring a concrete type, you end up having a wrapper type for the typeclass because you can't do `TypeClass t => [t]` for the majority of the stuff in base.
21:22:14 <nitrix> At least that was my experience when I tried it.
21:22:16 <EvanR> i would like to see a comparison of basic typeclasses with modern java interfaces, closure protocols, whatever go does, and see why its not the same things really, or what causes typeclasses to not be able to do that stuff, or if that stuff is equally crippled
21:22:50 <carter> Oddly enough, coinductive data types often wind up resembling a functional generalization of some of the nicer bits of oo
21:23:01 <EvanR> haskell experience reflecting on standard language features sort of thing
21:23:19 <nitrix> carter: I think it's a side-effect of having first-class citizen functions.
21:23:40 <carter> Nitrix not quite
21:24:00 <carter> You need at minum gadts to simulate coinductives
21:24:02 <EvanR> doesnt even have to be functions ;) data Obj a { payload :: a, next :: Obj a }
21:24:18 <carter> Nah. That's got the wrong memory semantics
21:24:29 <carter> Space leak city :)
21:24:48 <EvanR> i was under the impression ADTs were inductive and coinductive by default
21:24:54 <EvanR> in haskell
21:25:17 <emmanuel_erc> EvanR: Do you mean Recursive ADTs?
21:25:21 <EvanR> yes
21:25:30 <emmanuel_erc> Ok gotcha.
21:25:40 <monochrom> . o O ( Time flies like an arrow. Space leaks like a pointer. )
21:28:30 <Welkin> monochrom: da fux?
21:29:02 <monochrom> you know how fruit flies like a banana, no?
21:29:46 <EvanR> Open flies show your banana
21:42:04 <adarqui> i thought for sure i've been able to do import Blah as A hiding (something) .. can you do that? i'm getting errors at 'as'
21:42:34 <EvanR> import qualified Blah as A hiding (something)
21:43:05 <adarqui> ah so qualified is the key here.. i have a bunch of modules I import as A then export them in a module, ie a Prelude
21:43:08 <adarqui> ok will try, thanks EvanR 
21:49:56 <adarqui> if i do it using qualified, and re-export it, it's missing everything in that module.. as opposed to: module Blah ( module A ) where import SomeModule as A
21:50:42 <monochrom> adarqui: see my http://www.vex.net/~trebla/haskell/module.xhtml . you may find some surprising facts.
21:50:58 <adarqui> module Blah ( module A ) where import qualified SomeModule as A ... doesn't seem to export the module like the variation without 'qualified'
21:51:21 <adarqui> monochrom: checking, thanks
21:56:35 <EvanR> heh your question is alpha equivalent to the puzzle at the bottom
