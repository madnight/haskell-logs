00:00:02 <kosmikus> dfeuer: getting a stupid GHC warning (at least with 7.10) that the RULE might never fire, but according to GHC and looking at Core, it apparently does
00:00:12 <dfeuer> kosmikus, I'm *confident* you can get rid of the dictionaries. No doubt at all. Make two copies of adjustTree with different names to specialize them. Only one will be recursive and it will only deal with Nodes.
00:00:13 <koz_> GhiOm: http://learnyouahaskell.com/for-a-few-monads-more <-- from the 'Tasteful stateful computations' heading onward.
00:00:48 <kosmikus> dfeuer: https://github.com/kosmikus/containers/commit/279cc16859390a179b1b209dfe37109f977e2cd3
00:00:51 <GhiOm> thanks koz_, I'll look into it
00:00:59 <kosmikus> dfeuer: yes, sure. that's the extreme option.
00:01:20 <lpaste> tr_istan pasted â€œA nicer way to write thisâ€ at http://lpaste.net/164501
00:01:46 <lpaste> tr_istan revised â€œA nicer way to write thisâ€: â€œA nicer way to write this?â€ at http://lpaste.net/164501
00:02:05 <dfeuer> kosmikus, nah; it's not that big, and it *should* only affect the source code... I've done similar elsewhere in Data.Sequence, to specialize out Sized when there's some other context floating around.
00:03:44 <dfeuer> kosmikus, I see RULES as a much more extreme option in general, because getting them wrong leads to hard-to-track bugs.
00:04:06 <kosmikus> in this case, the RULE is just like SPECIALIZE, and you use that as well
00:04:21 <kosmikus> SPECIALIZE translates into a copy of the function and a rewrite rule
00:04:37 <kosmikus> here, I provide the copy of the constructor manually and just give the rewrite rule
00:04:47 <dfeuer> kosmikus, sure, but you're using RULES to change one constructor for another!
00:04:59 <dfeuer> This seems ... non-obvious.
00:05:27 <kosmikus> dfeuer: the only thing you can do with the constructors is to pass them to the "run..." function, which has the same definition for all of them
00:05:36 <kosmikus> dfeuer: but yes, if you prefer, one can spell it all out
00:05:54 <kosmikus> dfeuer: but then you're at a point where you might really be better off to just use Int#
00:06:03 <dfeuer> I would prefer, in this case. This is confusing enough to me without that. My brain is very limited.
00:06:13 <dfeuer> :P
00:06:57 <dfeuer> kosmikus, yeah, that's another option. I could benchmark both. GADTs are hypothetically maybe more portable.....
00:07:38 <kosmikus> dfeuer: more portable than unboxed integers?
00:07:41 * hackagebot withdependencies 0.2.3 - Run computations that depend on one or more elements in a stream.  https://hackage.haskell.org/package/withdependencies-0.2.3 (SimonMarechal)
00:07:41 * hackagebot yesod-bin 1.4.18.2 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.18.2 (MichaelSnoyman)
00:07:58 <kosmikus> dfeuer: I think that's very hypothetical :)
00:08:06 <dfeuer> kosmikus, more portable than GHC's particular types and constructors for unboxed integers.
00:08:13 <dfeuer> But all very very hypothetical.
00:09:28 <kosmikus> dfeuer: hmm, there may be yet another option ...
00:09:33 * kosmikus tries ...
00:11:00 <dfeuer> I really, really, really need to go to sleep. As fascinating as I find this stuff. It's currently even more confusing than it would be if I were awake. Speaking of confusing things, if you can find a way to make the Applicative Seq instance I wrote simple enough for me to understand more than one piece at a time and more than one day at a time, that'd be great too.
00:12:19 <dfeuer> But now I'm stuck waiting for kosmikus to come up with his other option, because I'm an addict.
00:14:02 <kosmikus> dfeuer: no, don't wait for it. what I just thought does not work, at least not easily.
00:14:09 <kosmikus> dfeuer: have a good night.
00:14:15 <dfeuer> NIGHT. 
00:14:18 <dfeuer> And thanks!
00:14:33 <kosmikus> you're welcome. not sure if it was worth anything anyway.
00:14:47 <dfeuer> Eh, new ideas are always valuable.
00:14:55 <dfeuer> Even if I have to wait for some other situation to use them.
00:20:00 <mtesseract> Hi
01:37:59 <lemonxah> good morning
01:38:14 <lemonxah> i am new to haskell and i have type issue that i dont understand why
01:38:15 <lemonxah> http://lpaste.net/6592183790385233920
01:38:41 <liste> lemonxah: what's the error message, and what line?
01:38:55 <lemonxah> on line 19 when i return acc it says expected type is a and the actual type is [a]
01:39:09 <lemonxah> i want it to be [a]
01:39:14 <lemonxah> that is why i am returning acc
01:39:41 <lemonxah> but isn't that what the signature is on line 17?
01:40:01 <lemonxah> it takes a Matrix 'a and 'a and [a] and then returns [a] ?
01:40:02 <liste> lemonxah: what's the type of `return' on line 19?
01:40:09 <liste> the specific type
01:40:24 <lemonxah> [Int]
01:40:30 <lemonxah> when its run
01:40:38 <lemonxah> but this is a compile error so [a]
01:40:41 <liste> I don't mean the whole expression, I mean just the function `return'
01:40:55 <liste> :t return -- this is the generic type
01:40:56 <lemonxah> oh i have no idea sorry
01:40:56 <lambdabot> Monad m => a -> m a
01:41:25 <lemonxah> how do you return something from a recursive funtion
01:41:34 <lemonxah> actually how do you return something from a function?
01:41:41 <Akii> just "| row <= 0 = acc"
01:41:44 <lemonxah> is it just the last expression or do you have to use a keyword
01:41:51 <lemonxah> ah ok thank you
01:41:53 <Akii> return acc lifts your list into another list
01:41:54 <liste> lemonxah: no keyword. it's the only expression
01:42:28 <liste> lemonxah: note that `return' is not a keyword, it's a function
01:42:38 <lemonxah> ok that makes sense thank you
01:42:38 <liste> (a method of Monad, to be exact)
01:42:41 <Akii> I find the compile error message a bit missleading :(
01:42:44 <lemonxah> didn't understand what was happening 
01:43:18 <lemonxah> it was a bit misleading also for me cause the expected type should be [a] and the actual type should be [a] for my method
01:43:20 <lemonxah> but
01:43:34 <lemonxah> it was moaning cause return requires a and not [a]
01:43:37 <lemonxah> i understand now
01:44:42 <liste> @src [] return -- lemonxah
01:44:42 <lambdabot> Source not found. :(
01:44:50 <liste> @src [] return
01:44:50 <lambdabot> return x = [x]
01:45:08 <liste> that's the `return' implementation for []
01:45:14 <liste> that's why you got the type error
01:45:37 <Akii> liste: can you explain why the compiler says that it expects an `a` and was given an `[a]` instead of saying I expect `[a]` but you gave me `[[a]]`
01:45:43 <lemonxah> yeah :) i understand that now thanks
01:46:02 <ertesx> from where is Data.Matrix?
01:46:02 <lemonxah> i am finding haskell a bit hard to get going
01:46:13 <liste> Akii: a is [a] (of diffent `a`) in this case
01:46:20 <lemonxah> matrix hackage
01:46:26 <ertesx> lemonxah: if you have a background in other mainstream languages, then it's true
01:46:33 <lemonxah> yes 
01:46:55 <lemonxah> i did C# for 10 years then i started dabling in F# for about a year and have been doing scala now for 2 years
01:47:02 <lemonxah> and i am trying to transition to haskell
01:47:03 <ertesx> lemonxah: if you pretend that this is your first time programming, and you have no idea how programming works, it makes things easier =)
01:47:30 <lemonxah> ertesx, its hard to tank 14 years of work experience
01:47:40 <Akii> liste: ah ok, thanks
01:47:43 <ertesx> don't tank it, just suspend it
01:47:47 <lemonxah> its not hte concepts getting me down i am finding it hard to get a project going 
01:48:03 <Akii> it's hard to build the stuff you're used to right away
01:48:07 <lemonxah> having 1 .hs file and running that is easy now but like what build files and stuff .. but i will get there
01:48:41 <Akii> look into haskell stack
01:49:08 <ertesx> lemonxah: when i went from C++ to haskell i had the same issueâ€¦  i solved it by forcing myself to program haskell, and mainly by accepting that i won't be doing OOP or any other C++ conceptâ€¦  took a few months to really click, but it paid off
01:49:43 <lemonxah> ertesx, i undestand the concepts so i haven't done OOP or stuff like that in over 2 years 
01:49:46 <ertesx> lemonxah: haskell modules and cabal actually isn't really much different from C# class files, if you pretend that classes can only be static
01:50:24 <ertesx> that part is easy enough to get intoâ€¦  become friends with "cabal init" for your first few projects
01:50:26 <lemonxah> what is getting me down is the stack like how to get my ide running and compiling multiple files into an executable
01:50:35 <ertesx> after that you will build your personal project skeleton anyway â€“ most people do
01:51:35 <liste> lemonxah: the `stack' makes building executables a breeze
01:51:41 <liste> `stack' program*
01:52:20 <ertesx> lemonxah: or stack, if you use it
01:52:32 <ertesx> stack probably makes it even easier
01:52:39 <lemonxah> which ide do you use? 
01:52:47 <lemonxah> well i say ide but i mean file editor
01:53:00 <lemonxah> was using vim and trying out atom now
01:53:13 <ertesx> i use emacs with haskell-mode and haskell-interactive-mode, which is basically a full haskell IDE
01:53:16 <liste> lemonxah: emacs has probably the best Haskell support (haskell-mode), but Vim works OK for me with a bunch of plugins
01:53:29 <ertesx> i hear that vim's haskell support is great, too
01:53:54 <ertesx> someone mentioned that you need to use some extra stuff to get the interactive experience, like ghc-mod
01:53:56 <liste> Atom has gotten some Haskell love recently
01:55:49 <ertesx> lemonxah: BTW, to compile multiple files, really all you need to do is to import themâ€¦  GHC takes care of module dependencies for you
01:56:04 <ertesx> ghc -O -o myexec Main.hs
01:57:45 <lemonxah> cool
01:57:47 <lemonxah> :)
01:58:19 <lemonxah> if i can code in haskell then i would undestand more about functional programming than now
01:58:34 <lemonxah> i am doind this so that i dont have the ease of just doing something with an object
01:58:46 <lemonxah> as i understand the only "classes" in haskell is type classes?
01:58:48 <ertesx> lemonxah: you may want to learn about exports and imports when using multiple modules
01:58:55 <ertesx> yeah
01:59:20 <EvanR> imagine if every term in the DSL had to just be an object
01:59:25 <EvanR> it would get old fast
01:59:32 <jle`> lemonxah: typeclasses in haskell are sort of unrelated to classes in OOP
01:59:39 <jle`> they just happen to have the same five letters
01:59:40 <lemonxah> yeah i know
01:59:43 <EvanR> new PlusSign(new Number(3), ...
01:59:44 <ertesx> but IMO there is FP and there is "haskell FP"â€¦  because of the laziness and our generally algebraic approach, our code tends to be composed differently from, say, scheme code
02:00:10 <ertesx> or, more relevantly, F# code
02:00:51 <lemonxah> i want to do haskell FP to better understand monads and why i want to use them
02:00:55 <ski> lemonxah : also "polymorphism" in FP commonly refers to something different than in OO
02:01:15 <ski> (parametric polymorphism, vs. subtyping polymorphism)
02:01:52 <ertesx> lemonxah: i think your goal shouldn't be to understand monads, but to build an application
02:03:12 <EvanR> or ad hoc polymorphism
02:07:39 * hackagebot jsaddle 0.4.0.1 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.4.0.1 (HamishMackenzie)
02:08:35 <liste> OO (C#/Java) people call parametric polymorphism "generics"
02:09:24 <liste> and ad hoc polymorphism "overloading"
02:09:59 <Akii> liste: or interfaces?
02:10:05 <Akii> the ad-hoc thing
02:11:27 <lemonxah> ertesx, it is :) i am going to do my new microservices in haskell
02:12:39 * hackagebot jsaddle-dom 0.1.0.1 - DOM library that uses jsaddle to support both GHCJS and WebKitGTK  https://hackage.haskell.org/package/jsaddle-dom-0.1.0.1 (HamishMackenzie)
02:13:14 <Tehnix> Akii: aren't interfaces more akin to typeclasses?
02:13:31 <Akii> Tehnix: and type classes enable ad-hoc polymorphism
02:13:32 <Tehnix> (which I guess is related to ad hoc polymorphism also :)..)
02:13:36 <Tehnix> yeah
02:17:39 * hackagebot ghcjs-dom 0.3.0.1 - DOM library that supports both GHCJS and WebKitGTK  https://hackage.haskell.org/package/ghcjs-dom-0.3.0.1 (HamishMackenzie)
02:19:30 <phz_> hey, I cannot upgrade my account on hackage as my credentials donâ€™t seem to work
02:19:34 <phz_> any idea whatâ€™s causing that issue?
02:20:27 <Tehnix> phz_: you exist on https://hackage.haskell.org/users/?
02:20:36 <phz_> DimitriSabadie
02:23:45 <Tehnix> phz_: Hmm, I can't seem to login through the upgrade either, and I just did a reset of my password :/
02:23:59 <phz_> I cannot upload any packages anymore
02:24:01 <phz_> that sucks
02:24:44 <Tehnix> phz_: I'd suggest contacting them "For issues with accounts or permissions please contact the administrators by email at admin@hackage.haskell.org"
02:25:04 <phz_> yeah, Iâ€™ll do that, thanks
02:26:05 <Tehnix> phz_: Let me know what you figure out! :) I suspect I might be affected too, haven't uploaded anything in ages
02:26:35 <phz_> Tehnix: sure
02:27:49 <m1dnight_> Is there a cleaner/shorter syntax for `case x of (Foo x) -> ... ; _ -> return ()` ?
02:30:16 <lyxia> m1dnight_: nothing standard. you'll have to write a wrapper function.
02:31:43 <ski> m1dnight_ : `forM_ [x | Foo x <- [x]] $ \x -> ...'
02:33:43 <int-index> makePrisms and then `_Foo $ \x -> ...`
02:50:31 <akegalj> I would like to have some hackage/stackage documentation offline. How can I get, for example, gtk3 html documentation offline
02:52:40 * hackagebot som 9.0.1 - Self-Organising Maps.  https://hackage.haskell.org/package/som-9.0.1 (AmyDeBuitleir)
02:54:55 <oherrala> akegalj: one solution is to build the docs yourself
02:55:52 <oherrala> akegalj: https://stackoverflow.com/questions/1587635/haddock-for-cabal-installed-modules
02:57:12 <puregreen> akegalj: if you don't want to reinstall it, I think you can do â€œcabal unpack gtk3; cd gtk3; cabal haddockâ€
02:57:41 * hackagebot creatur 5.9.12 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.12 (AmyDeBuitleir)
02:59:51 <bergmark> akegalj: with stack you can run `stack haddock' inside your project and it will build documentation for all packages you are using
03:02:41 <Akii> bergmark: that's awesome, thanks
03:02:54 <gromak> Hello, everyone. We are benchmarking a program on two different machines: one is my home computer with 4 cores and up to 4500 MHz and another one is a server with 40 cores and up to 2900 MHz (as reported by lscpu). For some strange reason it takes 10 times less time on my 4-cores machine than on server with 40 cores. We did some experiments with RTS options (e. g. -gq, -A1G), they improve perfomance but give the same benefit on both machines, so the differe
03:02:54 <gromak> nce is still 10x. Isn't it strange? What may be the reason?
03:04:32 <zomg> I'm by no means an expert on this but your results would seem to indicate your code isn't taking advantage of the parallel processing
03:05:29 <zomg> There can be a number of reasons for that, ranging from IO performance to algorithms
03:05:42 <defanor> or even that more threads make it slower somehow. you're compiling it with -threaded option, right?
03:06:37 <oherrala> build with -threaded and then run benchmarks with +RTS -N1, +RTS -N2 and so on
03:06:42 <mikeplus32> @pl id
03:06:42 <lambdabot> id
03:07:24 <mikeplus32> @pl foldr (liftM2 (++)) (return [])
03:07:24 <lambdabot> foldr (liftM2 (++)) (return [])
03:08:17 <defanor> oherrala: so, it's 10x slower on the server, with -N1 on both machines?
03:08:21 <ski> @type liftM concat . sequence
03:08:22 <lambdabot> (Monad m, Traversable t) => t (m [a]) -> m [a]
03:08:28 <ski> @type foldr (liftM2 (++)) (return [])
03:08:29 <lambdabot> (Monad m, Foldable t) => t (m [a]) -> m [a]
03:08:52 <defanor> oherrala: ouch, sorry
03:08:59 <defanor> oherrala: thought you're gromak
03:10:14 <ski> oh, i see ..
03:10:33 * ski was wondering why one got a more general type signature than the other
03:10:43 <ggVGc> what's the most efficient way (and which data type should I use) for splicing?
03:10:52 <ggVGc> I am using Vector atm, with take and drop
03:11:00 <ggVGc> but I'm pretty sure that's not the best way
03:16:44 <ggVGc> Ã¤ta farfars bajs
03:18:07 * ski tittar pÃ¥ ggVGc
03:21:29 <ertesx> is DataKinds promotion generally impossible with type families?
03:23:23 <ertesx> (i'm trying to implement a static security model using singletons, but that model is a class and the member types are associated types, so any implementation of the security model can do anything it wants internally)
03:23:29 <int-index> You'd need kind families. Should be possible in GHC 8.
03:23:39 <ertesx> ah, ok
03:24:07 <defanor> ggVGc: vector is about as fast as it gets, since it uses unsafe functions defined in C. probably some cpu ticks can still be saved with other approaches though
03:24:18 <padre_angolano> fan ta dig!
03:24:35 <defanor> ggVGc: Data.Sequence is nice if you want those to be relatively fast and pure
03:24:52 <defanor> (but should be slower than Vector)
03:25:32 <puregreen> ggVGc: I think take and drop are O(1) for Vector because they don't do copying
03:25:54 <ertesx> perhaps someone has done something like this?  here is the basic idea:  userLogin :: Sing uid -> String -> IO (Session uid)  -- give a session witness or throw an exceptionâ€¦  a value of type Session uid is a proof that the code was able to login as 'uid'
03:27:42 * hackagebot vcswrapper 0.1.3 - Wrapper for source code management systems  https://hackage.haskell.org/package/vcswrapper-0.1.3 (HamishMackenzie)
03:27:54 <ertesx> postDelete :: Session uid -> Sing postId -> WriteAccess uid postId -> IO ()  -- the third argument is a witness that the given user has write access to the given post
03:28:45 <ertesx> what i was trying to do was to abstract all of this, so it all lives in a Model type class that only specifies types and semantics
03:29:01 <ertesx> will i have to wait for GHC 8 to do that?  or is there some hacky way of doing it right now?
03:29:36 <gromak> Well, yes, it's built with -threaded. Briefly, our program is a ditributed system consisting of different enitites. In benchmark we run all these entities in different threads (forkIO). Numbers of entities are parameters of benchmark. Some entites may spawn multiple threads (there are entities which serve requests from other entities). In the simplest case we run 4 entities and I expect them to use from 4 to 10 threads simultaneously. On both machines the b
03:29:37 <gromak> est perfomance is achieved with approximately -N4. And the difference is now only 4 times approximately (it was 10x when I ran everything with -N without number). So now it's not so strange for me, I can belive that my cores are 4 times faster than cores on server.
03:29:42 <gromak> However, if I run 12 entities instead of 4 and use `-N10` on both machines, then difference is still 4x. And it seems strange.
03:31:40 <ertesx> ggVGc: Vector is a good way, if splicing is all you need, because the underlying vector is shared
03:32:04 <ertesx> like bytestring and text, vector does not copy unless necessary
03:33:17 <ggVGc> ski1: hahaha, wrong window, that was in relation to something completely different :)
03:33:59 <defanor> gromak: maybe something else slows it down? did you check which resources are actually used on those machines while it's working?
03:34:35 <defanor> oh, and profiling may be helpful
03:34:43 <ski> ski1 is someone else, it seems
03:35:18 <ggVGc> ertesx: the way I do it now is concat (take n original), newVector, (drop n (length newVector) original)]
03:35:22 <ggVGc> is that reasonable?
03:35:41 <ggVGc> sorry missed opening [
03:36:06 <ggVGc> also, missed a +
03:36:52 <ggVGc> this, https://gist.github.com/8698d637d05a7817ea955a15c40bdd6d
03:39:19 <gromak> defanor: regarding resources, there are two resources used: disk and network communication with 127.0.0.1 (if it may be called resource). We tried running everything in memory (we use acid-state, so we just switched to memory mode) and there wasn't much difference (no more than 10%). And communiction with 127.0.0.1 should be almost the same on these machines and shouldn't be bottleneck I think. Also I looked at htop, and there were no processes in uninterru
03:39:19 <gromak> ptible sleep. So I don't think resources are the main source of slow down
03:40:49 <gromak> We did some profiling, but didn't find it very useful. It reports much less time than was actually spent. It was much more useful to do some experiments with RTS options. Ok, we'll try to do more profiling
03:44:55 <ertesx> ggVGc: note that concat is linearâ€¦  it actually needs to construct a new vector
03:45:04 <ggVGc> ertesx: yeah, tat's why I am asking
03:45:09 <ggVGc> I don't know how to write it better
03:45:40 <ertesx> ggVGc: appending, prepending and changing are expensive with vectorâ€¦  to make everything cheap i would use a finger-tree of vectors
03:45:40 <ggVGc> it's weird Vector doesn't have a splice function
03:45:50 <ertesx> it does:  slice =)
03:46:26 <ertesx> ggVGc: well, *mapping* a vector is actually cheap, especially in composition with other vector operations (stream fusion)
03:46:31 <Tehnix> gromak: for profiling, you might find the 3-part series from pusher.com interesting - http://blog.pusher.com/top-tips-and-tools-for-optimising-haskell/ https://blog.pusher.com/memory-profiling-in-haskell/ and https://blog.pusher.com/making-efficient-use-of-memory-in-haskell/ (they don't link to each other, so linked all 3 here)
03:46:46 <ertesx> ggVGc: the finger-tree of vectors is sometimes called a "rope"
03:46:52 <ggVGc> ertesx: yeah, but I meant for inserting a sub-vector within it. Maybe splice is the wrong term
03:46:57 <Tehnix> Or, the last one linked to the earlier one... ohwell
03:47:00 <ggVGc> ah, alright, I'll look at that. thanks
03:47:18 <gromak> Tehnix: thx
03:47:38 <ertesx> ggVGc: usually ropes are done with binary trees rather than finger-treesâ€¦  but finger-trees give you better asymptotics at the edges
03:48:03 <ggVGc> ertesx: maybe I'll just use a Map Int a instead..
03:48:11 <ggVGc> hm, but that won't be good either
03:48:12 <ertesx> ggVGc: no, don't do that
03:48:19 <ertesx> ggVGc: see the fingertree package
03:48:24 <ggVGc> alright, thanks
03:48:54 <ertesx> it's basically Data.Sequence, but allows you to use a subsequence type (like Vector) together with a monoid (length)
03:49:09 <ertesx> that way you get the best of vector and sequence
03:52:44 <ertesx> a finger-tree of vectors makes *all* operations cheap, even changing a single value in the middle of a vector
03:53:11 <ertesx> that's why these "ropes" are often used in text editing
03:57:59 <ggVGc> why isn't everything a finger tree?
03:59:46 <ertesx> a finger tree can't have holes in the same way a binary tree (Map) or a radix tree (IntMap, HashMap) can
03:59:56 <ertesx> a finger-tree is essentially a *sequence* type
04:00:12 <defanor> https://cdn.meme.am/instances/500x/68525397.jpg
04:00:21 <ertesx> it's Data.Sequence with a custom measure of "length"
04:00:57 <gromak> By the way, our benchmark runs for 20 secs (wall time), but profiler says that total time is 1.04 secs. What does it mean?
04:02:52 <defanor> gromak: i don't know, but maybe it only measures "user" time. what does `time` say?
04:03:13 <ggVGc> GHC's profiling helped me a lot yesterday!
04:03:18 <ggVGc> but the output is a bit confusing, I agree
04:03:25 <ggVGc> first time I used it though
04:05:13 <gromak> 4.17s user 1.45s system 30% cpu 18.684 total
04:06:08 <defanor> looks like something else slows it down, not cpu
04:07:18 <gromak> Well, with -pa it reports total time which is much closer to actual wall time
04:08:17 <gromak> There are some threadDelays needed to initialize system. Our benchmark does some initialization (which does threadDelay) and then starts timer and runs some actions.
04:09:23 <defanor> and what's the `time` output on your machine? might be useful to compare its parts on both
04:13:13 <gromak> Home computer: 2.09s user 3.26s system 28% cpu 18.639 total, server: 8.62user 3.78system 0:23.66elapsed 52%CPU
04:13:46 <gromak> Btw, using `-pa` instead of `-p` makes profiler report total time which is very close to wall time actually passed
04:19:34 <defanor> so the difference in total time is approximately the same as in "user" time, then it should be cpu indeed. but the "user" time should be the sum of all the time from all the cores, and it'd match that way only if you were running it on a single core (at a time). isn't there anything in the code that may block most of the threads?
04:19:50 <defanor> hm, no, doesn't make much sense. still strange
04:20:22 <defanor> or it does. can you confirm that all the cpu cores are loaded on the server while it's working?
04:22:44 * hackagebot hid 0.2.2 - Interface to hidapi library  https://hackage.haskell.org/package/hid-0.2.2 (DimitriSabadie)
04:25:13 <gromak> Hmm, with -N10 http://i.imgur.com/0uGCq49.png
04:29:32 <gromak> Also -s shows that: Productivity  94.7% of total user, 87.2% of total elapsed
04:30:32 <greg`> how can i see haskell source code?
04:30:45 <maerwald> usually by looking at it
04:31:07 <cocreature> make sure to turn your screen on or print it
04:31:48 <liste> greg` : source code of what program exactly?
04:32:41 <greg`> i would like to see the applicative instance of List
04:32:44 * hackagebot zero 0.1.4 - Semigroups with absorption  https://hackage.haskell.org/package/zero-0.1.4 (DimitriSabadie)
04:33:52 <liste> greg` : there's a Source link in hackage
04:34:14 <liste> greg` also, https://github.com/ghc/ghc/tree/master/libraries/base
04:34:25 <greg`> from Control.Applicative or from Data.List?
04:34:32 <greg`> thanks
04:35:15 <liste> lambdabot's @src can also show some "reference" (=not actual) implementations
04:35:31 <liste> @src [] (<*>)
04:35:31 <lambdabot> (<*>) = ap
04:35:35 <liste> @src [] pure
04:35:35 <lambdabot> pure = return
04:35:55 <liste> (not *necessarily* actual)
04:36:22 <cocreature> the haddockâ€™s (usually) also have source links next to each definition
04:38:30 <ClaudiusMaximus> unless things changed it didn't have source links for instances, which makes finding the definitions a bit more awkward
04:38:54 <greg`> ClaudiusMaximus: I noticed , its not there for list
04:38:58 <greg`> where should i look?
04:40:48 <ClaudiusMaximus> ah, things have indeed changed
04:41:14 <ClaudiusMaximus> go to Control.Applicative documentation, scroll down to list of instances, click source to the right of Applicative []
04:41:34 <liste> greg` https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Base.hs#L739
04:41:51 <liste> GHC.Base has a lot of that stuff
04:42:19 <Akii> what's this INLINE stuff doing?
04:42:33 <liste> Akii: hints for optimization
04:43:09 <ClaudiusMaximus> greg`: the documentation page is here http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html
04:43:46 <Akii> ah ok
04:45:33 <ertesx> is there any trick to promote Integer?
04:46:05 <liste> ertesx: to type level?
04:46:09 <ertesx> yeah
04:47:23 <ertesx> i need an efficient natural number typeâ€¦  i mean *really* efficient, not list-of-bools-efficient
04:47:45 <ertesx> ideally it would act like peano Nat on the type-level, but like Integer on the value level
04:48:00 <cocreature> GHC.TypeLits?
04:48:37 <cocreature> not entirely sure how Nat is implemented, but I assume itâ€™s builtin magic so that in can be fast
04:48:39 <greg`> doesnt help, specifically i want to know if the Applicative instance of Data.List uses a Monoid constraint
04:49:43 <ertesx> cocreature: could workâ€¦  the KnownNat machinery is a bit awkward, but let me try
04:49:45 <cocreature> greg`: it does help, the required constraints are shown in the haddocks
04:49:53 <cocreature> yeah itâ€™s not exactly pleasant to use
04:50:02 <ClaudiusMaximus> greg`: what's the problem, it's shown in the docs and in hte source http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-739 no constraints
04:50:03 <cocreature> but itâ€™s the best we have atm afaik
04:50:59 <ertesx> ah, there is SomeNat
04:51:43 <ertesx> hmm, but no promotion for it =/
04:51:47 <NatureShade> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-739
04:52:02 <NatureShade> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-739
04:52:10 <greg`> ClaudiusMaximus: thanks i think i missed it
04:52:17 <greg`> i see it now
04:52:21 <NatureShade> opps, forgot to scroll down
04:53:43 <greg`> in a list comprehension i guess <- works on all traversables?
04:53:53 <greg`> or is it foldable?
04:54:26 <lyxia> isn't it just lists
04:54:48 <cocreature> itâ€™s just lists or with MonadComprehensions arbitrary monads
04:54:57 <lyxia> > [a | a <- Nothing]
04:54:58 <lambdabot>      Couldn't match expected type â€˜[t]â€™ with actual type â€˜Maybe a0â€™
04:54:59 <lambdabot>      In the expression: Nothing
04:54:59 <lambdabot>      In a stmt of a list comprehension: a <- Nothing
04:55:36 <lyxia> a0 is ambiguous but this at least shows that it expects a list
04:56:03 <bbear> hello
04:56:39 <ertesx> cocreature: Nat from GHC.TypeLits doesn't seem to cooperate with the singletons library
04:57:33 <int-index> ertesx, you'll have to choose between efficiency and inductive reasoning
04:57:41 <greg`> thanks all
04:57:45 * hackagebot tellbot 0.6.1 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.1 (DimitriSabadie)
04:57:49 <cocreature> ertesx: there is at least a Sing instance for it
04:58:04 <int-index> cocreature, which is of no use, because you can't pattern match on it
04:58:45 <cocreature> int-index: it reflects the value back using KnowNat so you can pattern match on it
04:58:56 <int-index> cocreature, good luck pattern matching on `KnownNat`
04:59:18 <ertesx> int-index: all i need is unificationâ€¦  not even full equality
04:59:18 <cocreature> int-index: are you talking about pattern matching at the type level or value level?
04:59:42 <int-index> cocreature, I talk about getting information to type level by pattern matching on value level (GADT-style)
04:59:54 <cocreature> ah yeah that doesnâ€™t work
05:00:01 <ertesx> cocreature: the trouble is that i can't create any promotable type that includes value-level information about the number
05:00:11 <ertesx> cocreature: in particular SomeNat can't be promoted
05:00:37 <cocreature> yeah I think I ran into similar problems with Symbol at some point
05:00:49 <ertesx> cocreature: how did you fix it?
05:00:56 <cocreature> I didnâ€™t :(
05:00:57 <ertesx> by not using Symbol?
05:01:01 <ertesx> i see =/
05:01:32 <ertesx> so i guess i'll go with lists-of-bools and perhaps find a hack to convert to and from them quickly
05:01:49 <int-index> by "list of bools" I hope you mean the inductive definition of Nat
05:01:59 <int-index> i.e. data Nat = Z | S Nat
05:02:00 <ertesx> int-index: no, the digital variant
05:02:09 <int-index> ah, the binary encoding
05:02:14 <ertesx> so indeed lists of bools with the constraint that they are either zero or start with a 1
05:02:21 <int-index> I see.
05:02:51 <int-index> Why don't you simply use Nat? It's uninhabited at value level, but you can convert it into `Integer` using `KnownNat`
05:03:25 <ertesx> int-index: because i need singletons, and i can't figure out how to do that with Nat
05:03:43 <ertesx> my initial thought was to dispense with singletons altogether and use reflection
05:03:59 <ertesx> but that got very awkward very quickly
05:05:10 <int-index> basically use `SNat`
05:06:18 <ertesx> int-index: newtype UserId = UserId ...?
05:06:32 <ertesx> normally i would write Int or Integerâ€¦  what do i write to keep UserId promotable?
05:07:41 <int-index> all my ideas depend on features from GHC 8
05:07:52 <ertesx> Sing and SomeSing are edges of promotion unfortunately
05:10:39 <int-index> I suppose binary encoding is the best way in this case.
05:10:51 <ertesx> lists of bools it is =)
05:11:01 <ertesx> thanks for your help, int-index and cocreature 
05:12:52 <ertesx> i hope we get -XDependentTypes at some pointâ€¦  singletons are awkward in so many ways
05:13:46 <ertesx> every time i type "KProxy", i feel a brain cell of mine die out of embarrassment
05:31:12 <greg`> why isnt the infix for mappend '<+>'
05:31:19 <greg`> makes more sense to me
05:32:04 <ski> > getProduct (2 <> 3)
05:32:05 <lambdabot>  6
05:32:28 <hamid> *magic*
05:33:59 <lyxia> I don't know, but + has the connotation of being commutative.
05:34:14 <EvanR> <++>
05:34:21 <EvanR> <> is easier to type
05:34:41 <EvanR> and has a cool diamond symbol in unicode or latex
05:35:13 <lyxia> it's approximately a circle
05:35:31 <ski> (the diamond symbol is commonly used for "possibly" in modal logic)
05:36:08 <EvanR> i suppose <> is more like a rhombus in most fonts
05:36:41 <EvanR> the salmiakki operator
05:37:04 <srhb> EvanR: mmmmm :3
05:37:21 <srhb> Isn't the generic binary operation usually * in maths?
05:38:14 <EvanR> asterisk? ;)
05:38:22 <mfukar> lyxia: from what I see in the relevant discussions, it was a matter of majority preference
05:38:51 <mikeplus32> an asterisk being a x and a + overlayed probably makes it the most appropriate
05:38:56 <mikeplus32> too bad it's already multiplication
05:39:29 <EvanR> + doesnt seem very specifically monoids
05:39:30 <ski> `*' is normally depicted with six rays, not eight
05:39:48 * mikeplus32 squints
05:39:53 <mikeplus32> darn
05:40:05 <EvanR> it would be like calling the monoid operation return ... oh wait
05:40:36 <EvanR> btw has anyone had success getting gloss's built-in BMP support to work?
05:43:47 <EvanR> i see no reference to my experience of it only showing white rectangles on OSX, even for the example programs
05:55:39 <zq> if i have a gadt type (T a), how could i show a list [forall a. T a]?
05:55:59 <zq> without -XImpredicativeTypes
05:56:26 <EvanR> with a (forall a . T a -> String)
05:56:40 <ski> `[forall a. T a]' isn't valid without `ImpredicativeTypes'
05:56:44 <int-index> data Some t where { Some :: t a -> Some t }
05:56:59 <int-index> Then use [Some T] instead of [forall a. T a]
05:57:20 <zq> so convert the impredicativity into existentialquant?
05:57:21 * ski thinks int-index is assuming `[exists a. T a]' was meant in place of `[forall a. T a]'
05:57:48 <zq> ski: so how does one even express a list of heterogenous gadts values?
05:57:51 <int-index> ski is correct
05:58:14 <int-index> I'm thinking about \exists, not \forall
05:58:21 <ski> (`[Some T]' corresponds to `[exists a. T a]', not to `[forall a. T a]'. quite possibly you meant the former, rather than the latter)
05:58:30 <zq> exists isn't a keyword in hs
05:58:36 <ski> zq : can you confirm/deny ?
05:58:43 <ski> (doesn't matter)
05:58:53 <zq> This 'exists' keyword (which isn't present in Haskell) is, as you may guess, a union of types, so that [exists a. a]
05:58:59 <zq> https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
05:59:51 <ski> zq : "how does one even express a list of heterogenous gadts values?" sounds like you want existentials, yes
06:00:13 <zq> anyway, i have no other choice besides 1) manually calling show on each gadt value or 2) mapping it into an existential type before showing
06:00:16 <zq> ?
06:00:34 <zq> kinda clunky, oh well
06:00:43 <ski> CPS-encoding of existentials might also be an option
06:00:49 <ski> but probably you don't want that here
06:01:01 * ski would go for 1)
06:01:28 <zq> ski: so. much. typings.
06:01:30 <ski> (if that's the only thing you want to be able to do)
06:02:29 <ski> @let data Some t = forall a. Wrap (t a)
06:02:30 <lambdabot>  Defined.
06:02:36 <EvanR> exists doesnt seem like a union 
06:03:09 <EvanR> its an unknown but valid type
06:03:31 <EvanR> only stuff inside the binder can use it
06:04:29 <ski> @type let infixr 5 #:; x #: xs = Wrap x : xs in [0,1,2] #: [False,True] #: []
06:04:30 <lambdabot> [Some []]
06:04:33 <zq> oh wow derive Show doesn't  work on existentials man
06:04:39 <ski> of course not
06:05:33 <ski> @let data SomeShow t = forall a. Show a => WrapSS (t a)
06:05:35 <lambdabot>  Defined.
06:05:41 <ski> could perhaps be helpful (or not)
06:05:50 <ski> hm
06:06:01 <ski> do you have `instance Show (T a) where ...' ?
06:06:36 <ski> (well, or that derived, instead of manually written out)
06:14:43 <Akii> how does "deriving" work internally?
06:16:11 <ski> some hardcoded stuff, i believe
06:16:19 <zq> ski: i derived Show manually for the wrapper existential type. no biggie. thanks.
06:16:37 <Akii> http://dreixel.net/research/pdf/gdmh.pdf
06:16:41 <Akii> looks interesting
06:16:42 <ski> zq : derived, or wrote the instance manually ?
06:17:50 <zq> ski: `instance Show Wrapper where show (Wrapper insides) = show insides`
06:18:01 <ski> that's wrong
06:18:12 <zq> how so?
06:18:29 <ski> (a) you're not outputting `"Wrapper"'; (b) you're not defining `showsPrec'
06:18:44 <zq> huh what
06:18:58 <zq> what's 'showsPrec'? what do you mean by "outputting 'wrapper'"?
06:19:39 <zq> i just want to be able to print a homogenous bunch of gadts. so i manually wrap each in Wrapper before calling map show on them. fun.
06:19:51 <ski>   instance Show Wrapper
06:19:53 <ski>     where
06:19:58 <ski>     showsPrec p (Wrapper insides) = showParen (p > 10)
06:20:02 <ski>                                   $ showString "Wrapper "
06:20:04 <ski>                                   . showsPrec 11 insides
06:20:07 <zq> what the heck is showsPrec
06:20:08 <ski> that's the correct way to do it
06:20:11 <ski> @src Show
06:20:12 <zq> :t showsPrec
06:20:12 <lambdabot> class Show a where
06:20:12 <lambdabot>     showsPrec :: Int -> a -> ShowS
06:20:12 <lambdabot>     show      :: a -> String
06:20:12 <lambdabot>     showList  :: [a] -> ShowS
06:20:13 <lambdabot> Show a => Int -> a -> ShowS
06:20:21 <zq> are you trolling me
06:20:24 <ski> `showsPrec' takes precedence into account
06:20:28 <ski> not at all
06:21:13 <ski> the above is what the derived instance would have done, if it had worked correctly
06:21:25 <ski> (perhaps actually a `deriving instance Show Wrapper' would work in your case)
06:21:38 <ski> (you could try, if you wish to)
06:21:45 <zq> ski: why do i want showsPrec?
06:21:52 <ertesx> given (type Bit = Bool; pattern B0 = False; pattern B1 = True), when i pattern-match on Bit using the pattern synonyms, GHC tells me that my pattern-matches are not exhaustiveâ€¦  why is that?
06:21:56 <ski> because it correctly handles brackets
06:22:33 <zq> > showsPrec 3 "asdf" ""
06:22:34 <lambdabot>  "\"asdf\""
06:22:41 <ski> if you evaluate `show (Just (Wrapper ...))' you want `"Just (Wrapper ...)"', not just `"Just Wrapper ..."'
06:22:52 <zq> ah, i see
06:22:54 <ski> the latter would be a type error
06:23:06 <ski> > showsPrec 0 (-2)
06:23:08 <ski> > showsPrec 0 (-2) ""
06:23:08 <lambdabot>  <[Char] -> [Char]>
06:23:09 <lambdabot>  "-2"
06:23:14 <ski> > showsPrec 8 (-2) ""
06:23:16 <lambdabot>  "(-2)"
06:23:42 <ski> the first argument to `showsPrec' is the precedence level of the context of the value to show
06:23:47 <zq> ski: doe sshow have a default impl that calls showsPrec?
06:24:00 <ski> `showsPrec' will then decide, usually using `showParen', whether to wrap in brackets or not
06:24:03 <ski> yes
06:24:08 <ski> @src show
06:24:08 <lambdabot> show x = shows x ""
06:24:09 <ski> @src shows
06:24:09 <lambdabot> Source not found. That's something I cannot allow to happen.
06:24:12 <ski> well
06:24:18 <ski>   shows x = showsPrec 0 x
06:26:15 <ski> for defining `Read' instances manually, you similarly define `readsPrec', usually by using `readParen',`lex',...
06:27:03 <ski> zq : "what do you mean by "outputting 'wrapper'"?" -- you forgot to mention (the data constructor) `Wrapper' in the string generated by `show'
06:27:28 <ski> if i call `show' on a value of type `T', then i expect to get a valid Haskell expression of type `T', not of some other type
06:27:30 <zq> ski: to be honest, all i'm doing is trying to print a gadt-structured tree
06:28:03 <zq> ski: and i'm hijacking `show` to get a string representation (not necessarily a `read`-able one) of the tree
06:30:12 <zq> maybe i'll switch to "print" later on to be more conformant to the expectations of `show` impls
06:32:49 * hackagebot table-layout 0.6.0.1 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.6.0.1 (muesli4)
06:35:57 <ski> zq : in that case, why make a `Show' instance at all ? why not just make a `displayWrapper :: Wrapper -> String' ?
06:38:52 <zq> ski: i totally should and will, promise. cross my heart.
06:41:10 <zq> man, i miss all the type-level voodoo haskell enables
06:54:15 <aleator> Are there any work on concolic testing of haskell programs?
06:56:51 <benzrf> what kinds of tools are there for reasoning about ASTs and ABTs using "paths"?
06:58:00 <benzrf> if i want to be able to do things like take a specified subterm of a larger term, and another subterm of the larger term, and find the "relationship" between the two subterms - for example, if they're both arguments to the same function call, or something
07:27:51 * hackagebot eventloop 0.8.1.2 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.8.1.2 (sebaslafleur)
07:30:32 <nitrix> @let infixr 0 foo; foo = undefined;
07:30:32 <lambdabot>  Parse failed: Parse error: foo
07:30:58 <ski> @let infixr 0 `foo`; foo = undefined
07:30:59 <lambdabot>  .L.hs:162:1:
07:30:59 <lambdabot>      Multiple declarations of â€˜fooâ€™
07:30:59 <lambdabot>      Declared at: .L.hs:149:1
07:31:00 <merijn> nitrix: needs backticks
07:31:07 <ski> @type L.foo
07:31:08 <lambdabot> a -> a -> a
07:31:20 <int-index> @info L.foo
07:31:20 <lambdabot> L.foo
07:31:28 <ski> there is no `info' command in lambdabot
07:31:29 <nitrix> @let infixr 0 $$$; $$$ = undefined;
07:31:29 <lambdabot>  Parse failed: Parse error: $$$
07:31:29 <merijn> There is no @info
07:31:42 <merijn> I need to setup a bot for when people type @info
07:31:44 <nitrix> That's mildly annoying. Of well.
07:31:47 <ski> @let infixr 0 $$$; ($$$) = undefined;
07:31:48 <lambdabot>  Defined.
07:31:51 <merijn> nitrix: lern2haskell ;)
07:32:06 <ski> merijn : would be nice :)
07:33:58 <nitrix> merijn: Can't we just extent lambdabot ?
07:34:23 <nitrix> Dumb question, the thing's impossible to get it to work :/
07:37:12 <int-e> nitrix: I tried my hand on @info once but mostly I just learned what an awful hack @type is...
07:38:43 <int-e> (the problem isn't to capture :info output... the problem is to extract the important bits of information so that lambdabot doesn't end up spamming everybody... uncontrolled :info output can become *very* long)
07:39:26 <nitrix> @instances Functor
07:39:30 <lambdabot> Alt f, Array i, Blind, Control.Exception.Handler, ErrorT e m, ExceptT e m, First, Gen, IO, Identity, Lambdabot.Plugin.Haskell.Eval.Trusted.Fixed, Large, Last, Maybe, NonEmptyList, NonNegative, NonZero, OrderedList, Positive, Proxy, ReaderT r m, SCC, Seq.Seq, Seq.ViewL, Seq.ViewR, Shrink2, Small, Smart, StateT s m, Tree, WrappedMonad m, WriterT w
07:39:30 <lambdabot> m, ZipList, []
07:39:50 <nitrix> merijn: I find @instances good enough for most purposes.
07:40:07 <mniip> @instances Eq
07:40:09 <lambdabot> (), (Seq.Seq a), (Seq.ViewL a), (Seq.ViewR a), (Shrink2 a), (a, b), (a, b, c), All, Any, ArithException, Array i e, ArrayException, AsyncException, Blind a, Bool, CReal, Char, Complex a, Const a b, Constr, ConstrRep, DataRep, Debug.SimpleReflect.Associativity, DefName, Double, Down a, Dual a, Either a b, ErrorCall, Expr, First a, Fixity, Float,
07:40:09 <lambdabot> GeneralCategory, IOException, Identity a, Int, Int16, Int32, Int64, Int8, Integer, Interval a, Large a, Last a, Level i a, MaskingState, Maybe a, Natural, NonEmptyList a, NonNegative a, NonZero a, OrderedList a, Ordering, Positive a, Product a, Ratio a, Small a, Sum a, Sym a, Tree a, TyCon, TypeRep, Word, Word16, Word32, Word64, Word8, ZipList a,
07:40:09 <lambdabot> [a]
07:40:36 <shapr> Double Down?
07:40:44 <nitrix> Maybe some filter or an additional one to lookup the class definition itself, but meh.
07:41:31 <shapr> howdy dysinger, how's code?
07:54:46 <byorgey> hi shapr!
08:02:17 <want2lern> hi guise
08:02:23 <want2lern> i want to learn haskell can someone tell me what is monad
08:02:30 <want2lern> ?
08:03:12 <int-index> want2lern, Monad is a type class in Haskell. You don't need to know what it is to learn Haskell.
08:03:34 <nitrix> Monad is the typeclass for types that allow an effectful operation to be chained together.
08:03:47 <nixnothing> any exp w/ funtional
08:03:49 <nixnothing> ?
08:04:11 <want2lern> i've read about it a little. but am unfamiliar with this type can someone elaborate?
08:04:15 <want2lern> is it like a bool ?
08:04:16 <monochrom> I'm pretty sure you have to learn the basic of Haskell first before you're ready for any answer about monad.
08:04:30 <pavonia> nixnothing: What does that mean?
08:07:02 <JuanDaugherty> want2lern, it's a pretensious name for handling state in haskell which is a "pure" functional language, what nixnothing was asking if you were familiar with
08:07:15 <JuanDaugherty> *pretentious
08:07:40 * ski idly notes that it's not only for handling state
08:07:54 <JuanDaugherty> state and io
08:07:59 <ski> no
08:08:08 <mniip> still no
08:08:19 <mniip> how much state is there in Reader? Writer?
08:08:27 <pavonia> or Maybe
08:08:32 <mniip> yeah that
08:08:43 <ski> also nondeterminism, exceptions, continuations, and e.g. more advanced stuff like parsers
08:08:59 <JuanDaugherty> anyway you can indeed proceed without getting bogged down and there is a surfeit of expository material on it
08:09:45 <Tehnix> want2lern: there are plenty of monad tutorials around, but to really understand it, you have to use them (monads that is)
08:10:11 <JuanDaugherty> want2lern, i recommend learn you a haskell, real world haskell, and craft of functional programming
08:12:56 <hpc> want2lern: to go a bit around the direct answers you're getting, Monad is near the top of a rather linear chain of concepts
08:13:32 <hpc> want2lern: metaphorically speaking, i recommend learning addition before multiplication
08:13:55 <hpc> want2lern: you should start with type classes in general, things like Show, Read, Eq, Ord
08:14:00 <hpc> want2lern: then Functor, then Applicative
08:14:13 <JuanDaugherty> also I should have added the spec for the lang, if you're so inclined
08:14:51 <hpc> a beginner probably won't get much out of the spec, but it's at least a reasonable preview of what's to come
08:15:08 <hpc> maybe scan through it without expecting to understand anything, and periodically revisit it to gauge your progress
08:15:09 * ski idly waits to see whether want2lern will add anything more
08:15:24 <hpc> heh
08:16:30 <shapr> byorgey: howdy! How's code?
08:17:52 * hackagebot ginger 0.2.5.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.2.5.0 (TobiasDammers)
08:20:29 <byorgey> shapr: good, you?
08:20:47 <byorgey> shapr: I'm enjoying the first summer in a while when I haven't been moving across the country and/or writing a dissertation
08:20:48 <JuanDaugherty> so the only login at hackage is when you upload a pkg?
08:21:00 <shapr> byorgey: so much spare time? writing more blog posts with all that time?
08:21:19 <shapr> I keep starting the diagrams tutorial and then getting distracted by something else Haskelly
08:21:33 <byorgey> hehe
08:22:02 <shapr> byorgey: I really want a slack plugin that does diagrams
08:22:10 <byorgey> yes, writing blog posts, writing papers, travelling to conferences and for pleasure... the usual sorts of things =)
08:22:21 <byorgey> shapr: that would be really cool
08:22:36 <shapr> I built lambdabot-slack but then got distracted yet again
08:23:05 <byorgey> a while ago I was working on a plugin for lambdabot that would compile diagrams code and paste the output somewhere, but I never really got it off the ground
08:23:36 <shapr> Most recently, I joined the board of directors of my local makerspace, and they want integration with the meetup.com api, so I've been slowly learning servant so I can try servant-client
08:24:27 <shapr> byorgey: too bad, that's exactly the kind of thing I want
08:24:34 <shapr> does that mean diagrams fits into SafeHaskell ?
08:25:11 * shapr checks
08:25:54 <byorgey> shapr: I really doubt it
08:27:54 <shapr> ah, too bad
08:56:33 <ChineseHackerChi> hi
08:58:04 <ChineseHackerChi> .Ì·Ì¨Ì¡Ì¡Ì¡Ì§Ì§Ì¡Ì¢Ì›ÌÌ«Ì©ÌÌ®Í™Ì«Ì£Ì£ÍšÌ¦Ì¤Ì©ÍˆÌ Ì­Ì™Ì±Ì¬Ì¹Í•Ì—Ì¦ÍšÍ“Ì»Ì—Ì©Ì™Í‡ÍˆÍšÍ‰ÍˆÌ¼ÌŸÌÌ¼ÌœÍ‰Ì¦Ì£Ì±Ì¼Ì±Ì Ì¬ÌÍ–ÌÌ¬Ì­Ì¹Ì­Ì¼Ì—Í•Ì¤ÍÌ¬Ì¤Ì³Ì»Ì¬Ì­ÌŸÍ”Ì­Í‡Í”Ì–Ì Ì¹ÌªÌ¦ÌºÍˆÌ³Ì©Ì­Ì¹Ì³Ì°Ì±Í™ÌÌ¾Í—ÍÌŒÌ‘ÌÍ‚Í—ÌÍ‚Ì€Ì„ÌÌˆÌÍ—Ì†ÌŠÌ€Ì‹ÌŒÌ‰Ì‚Ì…Í’Ì’Ì’Ì¿Ì”Ì¿Í’ÍŠÌ‹ÌÌ“Ì‘Í›Ì½Ì€ÌÌ“Ì‚Ì…ÌŒÌ“ÌˆÌƒÌˆÍ‘ÌƒÌŒÌÍ›ÍŒÍ‚ÌÌÌÌ‹Í’Ì€Ì‡ÍŠÌ”Ì“Ì†Ì†Ì“ÌƒÌ¾Í—Ì¿Ì€Ì…Ì†Ì€Ì‡Ì“ÌÌŠÍ†ÍŠÌ¾ÌÌ‚Ì‹ÌƒÍ˜Í˜ÌšÍ˜ÌšÍœÍœÍœÍœÍœÍÍÍÍÍÍÍÍ…Í….Ì·Ì§Ì¡Ì§Ì¢Ì§Ì¨Ì§Ì§Ì
08:58:50 <ChineseHackerChi> hi
08:58:51 <ChineseHackerChi> .Ì·Ì¨Ì¡Ì¡Ì¡Ì§Ì§Ì¡Ì¢Ì›ÌÌ«Ì©ÌÌ®Í™Ì«Ì£Ì£ÍšÌ¦Ì¤Ì©ÍˆÌ Ì­Ì™Ì±Ì¬Ì¹Í•Ì—Ì¦ÍšÍ“Ì»Ì—Ì©Ì™Í‡ÍˆÍšÍ‰ÍˆÌ¼ÌŸÌÌ¼ÌœÍ‰Ì¦Ì£Ì±Ì¼Ì±Ì Ì¬ÌÍ–ÌÌ¬Ì­Ì¹Ì­Ì¼Ì—Í•Ì¤ÍÌ¬Ì¤Ì³Ì»Ì¬Ì­ÌŸÍ”Ì­Í‡Í”Ì–Ì Ì¹ÌªÌ¦ÌºÍˆÌ³Ì©Ì­Ì¹Ì³Ì°Ì±Í™ÌÌ¾Í—ÍÌŒÌ‘ÌÍ‚Í—ÌÍ‚Ì€Ì„ÌÌˆÌÍ—Ì†ÌŠÌ€Ì‹ÌŒÌ‰Ì‚Ì…Í’Ì’Ì’Ì¿Ì”Ì¿Í’ÍŠÌ‹ÌÌ“Ì‘Í›Ì½Ì€ÌÌ“Ì‚Ì…ÌŒÌ“ÌˆÌƒÌˆÍ‘ÌƒÌŒÌÍ›ÍŒÍ‚ÌÌÌÌ‹Í’Ì€Ì‡ÍŠÌ”Ì“Ì†Ì†Ì“ÌƒÌ¾Í—Ì¿Ì€Ì…Ì†Ì€Ì‡Ì“ÌÌŠÍ†ÍŠÌ¾ÌÌ‚Ì‹ÌƒÍ˜Í˜ÌšÍ˜ÌšÍœÍœÍœÍœÍœÍÍÍÍÍÍÍÍ…Í….Ì·Ì§Ì¡Ì§Ì¢Ì§Ì¨Ì§Ì§Ì
08:58:52 <ChineseHackerChi> .Ì·Ì¨Ì¡Ì¡Ì¡Ì§Ì§Ì¡Ì¢Ì›ÌÌ«Ì©ÌÌ®Í™Ì«Ì£Ì£ÍšÌ¦Ì¤Ì©ÍˆÌ Ì­Ì™Ì±Ì¬Ì¹Í•Ì—Ì¦ÍšÍ“Ì»Ì—Ì©Ì™Í‡ÍˆÍšÍ‰ÍˆÌ¼ÌŸÌÌ¼ÌœÍ‰Ì¦Ì£Ì±Ì¼Ì±Ì Ì¬ÌÍ–ÌÌ¬Ì­Ì¹Ì­Ì¼Ì—Í•Ì¤ÍÌ¬Ì¤Ì³Ì»Ì¬Ì­ÌŸÍ”Ì­Í‡Í”Ì–Ì Ì¹ÌªÌ¦ÌºÍˆÌ³Ì©Ì­Ì¹Ì³Ì°Ì±Í™ÌÌ¾Í—ÍÌŒÌ‘ÌÍ‚Í—ÌÍ‚Ì€Ì„ÌÌˆÌÍ—Ì†ÌŠÌ€Ì‹ÌŒÌ‰Ì‚Ì…Í’Ì’Ì’Ì¿Ì”Ì¿Í’ÍŠÌ‹ÌÌ“Ì‘Í›Ì½Ì€ÌÌ“Ì‚Ì…ÌŒÌ“ÌˆÌƒÌˆÍ‘ÌƒÌŒÌÍ›ÍŒÍ‚ÌÌÌÌ‹Í’Ì€Ì‡ÍŠÌ”Ì“Ì†Ì†Ì“ÌƒÌ¾Í—Ì¿Ì€Ì…Ì†Ì€Ì‡Ì“ÌÌŠÍ†ÍŠÌ¾ÌÌ‚Ì‹ÌƒÍ˜Í˜ÌšÍ˜ÌšÍœÍœÍœÍœÍœÍÍÍÍÍÍÍÍ…Í….Ì·Ì§Ì¡Ì§Ì¢Ì§Ì¨Ì§Ì§Ì
08:58:52 <ChineseHackerChi> .Ì·Ì¨Ì¡Ì¡Ì¡Ì§Ì§Ì¡Ì¢Ì›ÌÌ«Ì©ÌÌ®Í™Ì«Ì£Ì£ÍšÌ¦Ì¤Ì©ÍˆÌ Ì­Ì™Ì±Ì¬Ì¹Í•Ì—Ì¦ÍšÍ“Ì»Ì—Ì©Ì™Í‡ÍˆÍšÍ‰ÍˆÌ¼ÌŸÌÌ¼ÌœÍ‰Ì¦Ì£Ì±Ì¼Ì±Ì Ì¬ÌÍ–ÌÌ¬Ì­Ì¹Ì­Ì¼Ì—Í•Ì¤ÍÌ¬Ì¤Ì³Ì»Ì¬Ì­ÌŸÍ”Ì­Í‡Í”Ì–Ì Ì¹ÌªÌ¦ÌºÍˆÌ³Ì©Ì­Ì¹Ì³Ì°Ì±Í™ÌÌ¾Í—ÍÌŒÌ‘ÌÍ‚Í—ÌÍ‚Ì€Ì„ÌÌˆÌÍ—Ì†ÌŠÌ€Ì‹ÌŒÌ‰Ì‚Ì…Í’Ì’Ì’Ì¿Ì”Ì¿Í’ÍŠÌ‹ÌÌ“Ì‘Í›Ì½Ì€ÌÌ“Ì‚Ì…ÌŒÌ“ÌˆÌƒÌˆÍ‘ÌƒÌŒÌÍ›ÍŒÍ‚ÌÌÌÌ‹Í’Ì€Ì‡ÍŠÌ”Ì“Ì†Ì†Ì“ÌƒÌ¾Í—Ì¿Ì€Ì…Ì†Ì€Ì‡Ì“ÌÌŠÍ†ÍŠÌ¾ÌÌ‚Ì‹ÌƒÍ˜Í˜ÌšÍ˜ÌšÍœÍœÍœÍœÍœÍÍÍÍÍÍÍÍ…Í….Ì·Ì§Ì¡Ì§Ì¢Ì§Ì¨Ì§Ì§Ì
08:58:52 <ChineseHackerChi> .Ì·Ì¨Ì¡Ì¡Ì¡Ì§Ì§Ì¡Ì¢Ì›ÌÌ«Ì©ÌÌ®Í™Ì«Ì£Ì£ÍšÌ¦Ì¤Ì©ÍˆÌ Ì­Ì™Ì±Ì¬Ì¹Í•Ì—Ì¦ÍšÍ“Ì»Ì—Ì©Ì™Í‡ÍˆÍšÍ‰ÍˆÌ¼ÌŸÌÌ¼ÌœÍ‰Ì¦Ì£Ì±Ì¼Ì±Ì Ì¬ÌÍ–ÌÌ¬Ì­Ì¹Ì­Ì¼Ì—Í•Ì¤ÍÌ¬Ì¤Ì³Ì»Ì¬Ì­ÌŸÍ”Ì­Í‡Í”Ì–Ì Ì¹ÌªÌ¦ÌºÍˆÌ³Ì©Ì­Ì¹Ì³Ì°Ì±Í™ÌÌ¾Í—ÍÌŒÌ‘ÌÍ‚Í—ÌÍ‚Ì€Ì„ÌÌˆÌÍ—Ì†ÌŠÌ€Ì‹ÌŒÌ‰Ì‚Ì…Í’Ì’Ì’Ì¿Ì”Ì¿Í’ÍŠÌ‹ÌÌ“Ì‘Í›Ì½Ì€ÌÌ“Ì‚Ì…ÌŒÌ“ÌˆÌƒÌˆÍ‘ÌƒÌŒÌÍ›ÍŒÍ‚ÌÌÌÌ‹Í’Ì€Ì‡ÍŠÌ”Ì“Ì†Ì†Ì“ÌƒÌ¾Í—Ì¿Ì€Ì…Ì†Ì€Ì‡Ì“ÌÌŠÍ†ÍŠÌ¾ÌÌ‚Ì‹ÌƒÍ˜Í˜ÌšÍ˜ÌšÍœÍœÍœÍœÍœÍÍÍÍÍÍÍÍ…Í….Ì·Ì§Ì¡Ì§Ì¢Ì§Ì¨Ì§Ì§Ì
08:58:52 <ChineseHackerChi> .Ì·Ì¨Ì¡Ì¡Ì¡Ì§Ì§Ì¡Ì¢Ì›ÌÌ«Ì©ÌÌ®Í™Ì«Ì£Ì£ÍšÌ¦Ì¤Ì©ÍˆÌ Ì­Ì™Ì±Ì¬Ì¹Í•Ì—Ì¦ÍšÍ“Ì»Ì—Ì©Ì™Í‡ÍˆÍšÍ‰ÍˆÌ¼ÌŸÌÌ¼ÌœÍ‰Ì¦Ì£Ì±Ì¼Ì±Ì Ì¬ÌÍ–ÌÌ¬Ì­Ì¹Ì­Ì¼Ì—Í•Ì¤ÍÌ¬Ì¤Ì³Ì»Ì¬Ì­ÌŸÍ”Ì­Í‡Í”Ì–Ì Ì¹ÌªÌ¦ÌºÍˆÌ³Ì©Ì­Ì¹Ì³Ì°Ì±Í™ÌÌ¾Í—ÍÌŒÌ‘ÌÍ‚Í—ÌÍ‚Ì€Ì„ÌÌˆÌÍ—Ì†ÌŠÌ€Ì‹ÌŒÌ‰Ì‚Ì…Í’Ì’Ì’Ì¿Ì”Ì¿Í’ÍŠÌ‹ÌÌ“Ì‘Í›Ì½Ì€ÌÌ“Ì‚Ì…ÌŒÌ“ÌˆÌƒÌˆÍ‘ÌƒÌŒÌÍ›ÍŒÍ‚ÌÌÌÌ‹Í’Ì€Ì‡ÍŠÌ”Ì“Ì†Ì†Ì“ÌƒÌ¾Í—Ì¿Ì€Ì…Ì†Ì€Ì‡Ì“ÌÌŠÍ†ÍŠÌ¾ÌÌ‚Ì‹ÌƒÍ˜Í˜ÌšÍ˜ÌšÍœÍœÍœÍœÍœÍÍÍÍÍÍÍÍ…Í….Ì·Ì§Ì¡Ì§Ì¢Ì§Ì¨Ì§Ì§Ì
08:59:06 <TheMystic> yay for unicode abuse
09:01:49 <shapr> geez
09:01:56 <bernalex> shapr: hi!
09:02:07 <shapr> er, HI bernalex! How's code?
09:02:18 <bernalex> shapr: it's lua. so bad! how's code over there?
09:02:38 <shapr> It's Python submitted by a prospective candidated and it doesn't work at all! argh!
09:02:48 <bernalex> D:
09:03:01 <lin> Guess they'll stay prospective
09:03:27 <shapr> bernalex: oh hey, really cool interview question came up yesterday "some jerk did chmod 000 chmod, how to fix?"
09:03:32 <shapr> oh, we should move this to #haskell-offtopic
09:18:57 <sm> woah, what is that unicode doing to my terminal
09:23:18 <geekosaur> sm, here it tried to render as iso8859. possibly it's big5 or utf16 instead of utf8?
09:23:44 <glguy> It's not quite valid UTF-8, but you can see it as UTF-8 if you visit the log file and force your browser to render it as such
09:24:12 <glguy> In that case it draws a vertical line of garbage on the screen
09:25:31 <merijn> It's invalid UTF-8, because my terminal renders UTF-8 fine and I get the question mark in a square error sign
09:26:20 <glguy> I think that it's probably invalid because it was truncated by the message length limit
09:27:55 * hackagebot octane 0.5.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.0 (fozworth)
09:27:57 * hackagebot pointful 1.0.8 - Pointful refactoring tool  https://hackage.haskell.org/package/pointful-1.0.8 (MikhailGlushenkov)
09:28:30 <geekosaur> yeh, that would do it, this client doesn't try to diagnose much less fix utf8 decode errors, it just falls back to iso8859-1
09:29:14 <glguy> My client falls back to iso8859-1 when utf-8 decoding fails because XChat will attempt to send a mix of iso8859-1 and utf-8 depending on whether or not it can cram the message into iso8859 or not
09:30:20 <glguy> http://xchat.org/encoding/#hybrid
09:30:23 <sm> here (erc buffer in text-mode emacs in iterm2) I get almost full-screen-height vertical lines of junk. Kind of surprising
09:30:42 <Zemyla> Why is ArrayArray not in the primitive package?
09:30:57 * sm mutters wouldn't happen with haskell software
09:31:04 <johnw> sm: same
09:40:41 <sm> how's life johnw ? still working with haskell ?
09:41:18 <johnw> I use Haskell right now as a test bed mainly
09:41:29 <johnw> a way of extracting and executing Coq code to test it
09:41:38 <sm> aha
09:42:55 * hackagebot hsimport 0.7.1 - A command line program for extending the import list of a Haskell source file.  https://hackage.haskell.org/package/hsimport-0.7.1 (DanielTrstenjak)
09:42:59 <sm> I'm looking at your ledger4 right now to see if its types are more space-efficient than hledger's
09:44:02 <johnw> sm: just fyi, I hadn't started thinking about efficiency yet
09:44:33 <sm> I figure.. I've just started trying to reduce memory usage
09:44:50 <johnw> the first round of doing that is always the most fun :)
09:44:57 <sm> roughly speaking, 100 transactions in memory seems to cost about a megabyte right now, which is not ideal
09:45:13 <johnw> whoa, 1K per transaction, nice
09:45:22 <johnw> no, 10K!
09:45:24 <sm> yeah
09:45:54 <sm> that's the back of the envelope estimate I made last time, I need to get ghc-datasize working & measure it properly
09:46:43 <sm> I finally converted from String to Text, which helped a little 
09:49:07 <sm> (it increased allocation, but decreased maximum residency)
09:50:21 <johnw> is this for the commodity names?
09:50:51 <sm> yes, pretty much all the other text fields - account names, description etc.
09:50:57 <johnw> ah
09:51:00 <sm> as well
09:51:04 <johnw> did you switch to strict text or lazy?
09:51:24 <sm> good question.. strict. I'll try lazy too
09:51:35 <johnw> I bet lazy is almost the same as String
09:52:18 <johnw> also, if you end up with a thunk containing [pack "Hello"], you've saved nothing 
09:52:31 <johnw> so you'll need to be sure that your Strings are not being kept on the heap
09:53:32 <sm> johnw: interesting, that's something I was worried about. There is still a lot of string conversion at the edges
09:55:53 <sm> right now processing a 100k-txn file allocates 35G, is 70% productive, requires 1G and takes 18s
09:56:08 <johnw> oh yeah, we can definitely do better :)
09:56:30 <sm> yay, good to hear :)
09:57:34 <sm> I'm still planning to add your ledger4 parser, soon as I get a round tuit
10:01:58 <johnw> sm: sweet!  that might prompt me to spend a little more time in ledger4 again
10:03:06 <sm> hope so!
10:04:12 <johnw> in fact..... there are certain algorithms within Ledger that I'd prefer to implement in the Coq system I'm using now, with extraction to optimized Haskell... that could be very motivating :)
10:07:24 <sm> for the record: the old String-based version allocates 30G, is 60% productive, and requires 1.4G and 19s
10:08:22 <johnw> can you send me a full profile of the application?
10:08:26 <sm> and was a delight to code.. free of pack/unpack noise..
10:08:51 <johnw> you should be able to eliminate a lot of the packing/unpacking
10:08:57 <johnw> with OverloadedStrings, and using a Text-based Parsec
10:09:16 <johnw> the only real reason to need pack/unpack is for compatibility with libraries that only accept String
10:09:31 <sm> I'm doing those.. but yes given time hopefully things will get cleaner
10:10:24 <sm> johnw: sure, let me paste one
10:15:03 * sm rebuilds the world
10:23:03 <turiya> hi
10:23:44 <turiya> i am trying to use repa and i get very bad performance
10:24:57 <turiya> the same code in C seems to run much faster
10:25:46 <t7> welcome to the world of haskell
10:26:16 <lpaste> turiya pasted â€œrepaâ€ at http://lpaste.net/6985647655632240640
10:26:17 <lpaste> turiya pasted â€œrepaâ€ at http://lpaste.net/164527
10:29:09 <dolio> That's a lot of lists.
10:31:05 <dolio> Your main computation that you're showing looks like it does all the work building a list, and then puts it in an array just to print it out.
10:31:41 <turiya> yes
10:31:51 <turiya> i dont know how else to do this
10:38:12 <hpc> maybe use fromFunction and operate on (Array D) instead?
10:39:23 <hpc> and then using repa's reduction functions instead of list comprehensions
10:40:15 <sm> https://gist.github.com/simonmichael/641d6fdc80a0d5557f17be1ceeca3a0b, johnw
10:40:40 <hpc> or, hmm
10:46:12 <turiya> hpc, i will check what reduction functions are. I probably missed any earlier comments as I got logged out
10:48:44 <turiya> reduction seems to be fold operations, not sure how to use them in my code
11:02:58 * hackagebot ffmpeg-light 0.11.0 - Minimal bindings to the FFmpeg library.  https://hackage.haskell.org/package/ffmpeg-light-0.11.0 (AnthonyCowley)
11:07:58 * hackagebot text-conversions 0.2.0 - Safe conversions between textual types  https://hackage.haskell.org/package/text-conversions-0.2.0 (lexi_lambda)
11:19:40 <nitrix> Hi
11:19:42 <nitrix> https://github.com/nitrix/lspace/blob/29606effb30931e4027342b863f9153856056107/src/Grid.hs#L97
11:20:26 <nitrix> How do I check that each members of the Quad record are all GridLeafEmpty?
11:20:34 <pikajude> how do I resolve an ambiguous occurrence of an identifier in a record update?
11:20:40 <pikajude> the type of the record being updated is known
11:21:22 <nitrix> (It's a quad tree, this is done on removals to merge quad nodes into empty leaves to avoid leaving unecessary levels)
11:21:36 <nitrix> Nested pattern matching doesn't seem right.
11:25:03 <fishythefish> nitrix: perhaps just have isEmpty for Grid, similar to isJust/isNothing?
11:25:21 <dolio> pikajude: You're using record update syntax, and it can't figure it out?
11:25:25 <pikajude> right
11:25:30 <pikajude> I have two records with a field named match
11:25:41 <nitrix> fishythefish: And then && isEmpty on each quadrant. Yeah I think I'll do that.
11:25:43 <dolio> Bummer.
11:25:47 <nitrix> fishythefish: Or write a prism. Thanks
11:27:59 * hackagebot JuicyPixels-extra 0.1.0 - Efficiently scale, crop, flip images with JuicyPixels  https://hackage.haskell.org/package/JuicyPixels-extra-0.1.0 (mrkkrp)
11:29:09 <nitrix> fishythefish: Or write a prism. Thanks
11:29:12 <nitrix> Whoops
11:29:16 <fishythefish> np :)
11:29:30 <nitrix> Too used to switching windows and :r -ing :P
11:33:25 <dolio> pikajude: When you say 'the type ... is known' what do you mean?
11:33:59 <pikajude> it's return (thingToUpdate :: Foo) { match = ... }
11:34:06 <pikajude> so presumably the compiler knows the type of thingToUpdate
11:34:21 <dolio> Okay. So that's verbatim one of the examples.
11:34:27 <pikajude> no, sorry
11:34:41 <pikajude> verbatim it's return (spec :: PackageSpec) { match = match { source = Just src } }
11:34:59 <dolio> Is source ambiguous?
11:35:14 <pikajude> no, only one record with a `source` field
11:35:21 <dolio> Huh.
11:35:42 <dolio> Anyhow, I meant putting a signature on the record value is verbatim one of the ways of disambiguating in the user guide.
11:35:55 <pikajude> on the record value, okay
11:36:00 <dolio> So if it isn't working, I don't know.
11:36:07 <pikajude> oh, that's what I did
11:36:12 <pikajude> whatever, I'll just write a helper function for it
11:36:19 <dolio> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-updates
11:37:58 <erisco> what is the cabal command to build the haddock docks? I never remember it oO
11:38:13 <dcoutts> erisco: cabal haddock
11:38:19 <dcoutts> erisco: see also  cabal --help
11:39:21 <erisco> thanks
11:40:00 <nitrix> Is there nicer than if p then f x else x ?
11:41:34 <erisco> :t guard p $> f
11:41:35 <lambdabot>     Couldn't match expected type â€˜Boolâ€™ with actual type â€˜Exprâ€™
11:41:35 <lambdabot>     In the first argument of â€˜guardâ€™, namely â€˜pâ€™
11:41:35 <lambdabot>     In the first argument of â€˜($>)â€™, namely â€˜guard pâ€™
11:41:44 <erisco> didn't capture my variables! but, that
11:42:30 <erisco> ah but where is the 'else x', hm
11:44:20 <nitrix> :t guard
11:44:21 <lambdabot> Alternative f => Bool -> f ()
11:44:43 <nitrix> What a peculiar type.
11:45:15 <nitrix> I feel like the only implementation possible is pure ()
11:45:25 <nitrix> @djinn Alternative f => Bool -> f ()
11:45:26 <lambdabot> Error: Class not found: Alternative
11:45:39 <nitrix> Oh, Alternative, not Applicative.
11:45:41 <erisco> :t \p f x -> maybe x f (guard p $> x) -- an option
11:45:43 <lambdabot> Bool -> (a -> a) -> a -> a
11:45:54 <erisco> are you looking for pointless?
11:46:22 <nitrix> I'm looking for anything really.
11:46:34 <fishythefish> nitrix: guard True = pure (); guard False = empty :P
11:46:35 <erisco> well, 'if p then f x else x' is already short and simple
11:47:11 <erisco> so I don't know how to qualify something as "nicer" unless you can say what you're looking for
11:48:13 <nitrix> if isEmpty g then GridLeafEmpty y else g
11:48:25 <nitrix> It just feels repetitive sence it's given to both the predicate and the else case.
11:48:37 <erisco> btw, using guard is just to convert the Bool to Maybe, because while there is 'maybe' i.e. case analysis on Maybe there is not a definition for case analysis on Bool
11:49:01 <erisco> you can define   bool a b True = a; bool a b False = b;   bool (f x) x p
11:49:03 <fishythefish> not that it's hard to define, just not included in the prelude by default
11:49:25 <nitrix> I was just trying to get rid of two guard functions with | otherwise into maybe a nicer conditional.
11:50:42 <erisco> which is also  (bool .)  for pointless
11:51:03 <erisco> er, not quite, doesn't dup the 'x' for you
11:51:37 <crough> bool is in Data.Bool in base since 4.8
11:53:04 <nitrix> bool doesn't quite meet the criteria afaik.
11:53:08 <erisco> :t (flip bool <*>)
11:53:09 <lambdabot> (a -> a) -> a -> Bool -> a
11:53:17 <haasn> So what's the hip and trendy way of executing raw x86_64 code at runtime? I tried out harpy but it doesn't work for 64 bit :(
11:54:28 <erisco> > let f = (flip bool <*>) (+1) 3 in (f True, f False)
11:54:29 <lambdabot>  (3,4)
11:55:06 <erisco> oh, the bool in Data.Bool has the cases reversed
11:55:14 <erisco> so just don't flip and you're good
11:55:32 <erisco> > let f = (bool <*>) (+1) 3 in (f True, f False)
11:55:34 <lambdabot>  (4,3)
11:55:44 <erisco> not getting any simpler than that! :)
11:57:00 <amf> does cabal have a way to control the version from outside (process, file, etc)? i want maven (yes i know it sounds odd) to be the dictator of the version number
11:58:19 <amf> i have a feeling the answer is "no, and what sort of maniac would want that"
11:58:21 <erisco> equivalently you can use   ap bool
11:58:40 <geekosaur> amf, --constraint
11:59:06 <geekosaur> e.g. --constraint='process == 1.1.0.1' or whatever
11:59:15 <nitrix> Meh.
11:59:17 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Grid.hs
11:59:25 <nitrix> It's getting frenkenstein-ish but it's still readable.
11:59:45 <nitrix> I just feel like it needs a few lenses for those record updates.
11:59:57 <amf> geekosaur: i meant the value stored after "version:" in the .cabal
12:00:11 <hexagoxel> amf: the .cabal _is_ a file :p
12:00:37 <geekosaur> amf, at that point I think you want to generate the .cabal on the fly from a template
12:01:07 <geekosaur> as the version of the package described by the cabal file is part of its identity, it makes little sense for it to be a variable
12:01:08 <amf> thats looking like the direction i have to take, even if its just sed
12:01:29 <amf> was hoping someone had a workaround for the practice of stuffing the git revision in there
12:02:51 <geekosaur> generally one uses a version that is higher than any released one, and finds somewhere else to stuff the git describe output
12:03:44 <geekosaur> although, for development or rolling-release type stuff, it might be nice if it supported 'version: git' and used 'git describe
12:04:24 <geekosaur> ' to construct an actual revision, or something.
12:04:39 <hexagoxel> amf: is it important that the package version changes "from outside"? you can instead have some other module auto-generated (instead of Paths_foo.hs)
12:05:42 <dxtr> Good evening
12:05:46 <amf> that is an option, maybe a makefile to support my workflow and keep cabal happy, but the ${what-ever-maven-wants} as the version value
12:05:46 <hexagoxel> if the purpose for that number is to be available at runtime, that is.
12:06:12 <hexagoxel> custom Setup.hs can do that.
12:12:54 <amf> hexagoxel: ill check out what Setup.hs can do as ive never explored that area
12:15:37 <hexagoxel> amf: if you need, i have a Setup.hs for some simple build number.
12:18:01 * hackagebot incremental-maps 0.0.0.0 - Package for doing incremental computations on maps  https://hackage.haskell.org/package/incremental-maps-0.0.0.0 (jelken)
12:24:37 <hexagoxel> can you define fixities for type operators?
12:24:50 <merijn> hexagoxel: ooh...
12:24:52 <merijn> good question
12:24:56 <merijn> hexagoxel: Try it? :)
12:25:23 <jle`> scientific method ftw
12:25:36 <Cale> I vaguely recall someone saying the usual infix declarations worked
12:26:11 <dolio> Yeah, it's just the same fixity working at both term an type levels.
12:29:10 <sm> amf: just remember that cabal version numbers are fairly limited.. no letters
12:32:13 <hexagoxel> so.. you can define fixities. next question: was is the precedence of (->) ?
12:32:22 <hexagoxel> s/was/what/
12:32:53 <Cale> I expect it to bind more weakly than anything else.
12:33:07 <Zemyla> Yeah, it's probably 0 or less.
12:33:31 <fizruk> , binds weaker
12:33:39 <fizruk> I think
12:34:07 <Cale> Yeah, if you mean for tuples, but it isn't an infix thing on its own though...
12:34:35 <Zemyla> Yeah, tuples have explicit parentheses around them.
12:34:35 <fizruk> -> isn't infix on its own either, no?
12:34:44 <hexagoxel> indeed, 2010 report says "type 	â†’ 	btype [-> type]"
12:34:53 <fizruk> like you have to use \
12:34:57 <byorgey> fizruk: sure it is.
12:35:07 <byorgey> fizruk: we are talking about in a *type*
12:35:15 <hexagoxel> which would put it somewhere below 0.
12:35:17 <byorgey> not -> in the syntax of lambda abstractions
12:35:19 <fizruk> ah, sorry then
12:39:33 <shanemikel> building something with stack I'm getting a bunch of complaints about "no packages found which provide ..." which is a build-tool dep
12:39:57 <shanemikel> if I have these installed globally, and on my path, how do I tell stack to stop complianing
12:43:54 <jle`> are they libraries?
12:43:59 <jle`> it might be best to just install them with stack
12:44:45 <geekosaur> "build-tool" sounds like not?
12:48:02 * hackagebot data-function-meld 0.1.1.0 - Map the arguments and return value of functions.  https://hackage.haskell.org/package/data-function-meld-0.1.1.0 (erisco)
12:51:25 <shanemikel> gtk2hs
12:51:39 <shanemikel> but AFAIK, it only needs to be on my path
12:51:48 <shanemikel> (not used as a lib)
12:53:11 <geekosaur> gtk2hs doesn;t have any build tools. did you intend gtk2hsc2hs?
12:53:21 <shanemikel> yeah
12:53:23 <geekosaur> (which is a build tool and dependency of gtk2hs)
12:54:03 <shanemikel> that's funny, hsc2hs is listed to, but isn't that provided with ghc?
12:54:08 <shanemikel> *too*
12:54:32 <sm> when would one use a boxed vector rather than a list ?
12:54:55 <merijn> shanemikel: Maybe, but consider that cabal supports compilers OTHER than GHC too, so those might not have hsc2hs shipped
12:55:04 <erisco> when you're worried about performance
12:55:06 <geekosaur> shanemikel, it's provided if you install ghc from a bindist or via stack. if you get it from OS packages, it may well be separate
13:04:53 <shanemikel> so what's the equivalent of adding local sources in stack like I would with a cabal sandbox?
13:05:09 <sm> erisco: since the docs say that an *unboxed* vector can be stored in consecutive memory slots, I assume that a boxed vector can't, and if so I wonder how it is different from a list
13:05:42 <merijn> sm: A boxed vector is, essentially a "void *" array :)
13:05:46 <kadoban> shanemikel: You can add local directories in the stack.yaml as extra dependencies. You can also use git repos online, which is convenient (tied to a specific commit or tag or whatever)
13:05:51 <merijn> sm: But with type checking to make it safe
13:06:00 <erisco> sm, indexing, and whatever operations you can just do on a box are relevant (I think that includes pattern matching)
13:06:23 <merijn> sm: (Boxing makes all values the same type to ease generating polymorphic code, but it makes accessing boxed values slower (1 indirection) and ruins cache locality
13:06:37 <sm> merijn: like a list, right
13:06:39 <dolio> sm: A boxed vector stores pointers consecutively in memory.
13:06:41 <merijn> sm: So an unboxed array gets you cache locality because the actual values are densely packed
13:06:45 <merijn> sm: No, lists are worse
13:06:58 <sm> lists have one more level of indirection eh
13:06:59 <erisco> lists are not contiguous in memory, unless accidentally so thanks to GC
13:07:02 <merijn> sm: Lists are pointers to boxes (i.e. pointers)
13:07:29 <merijn> Incidentally, this is why String has such a ridiculous memory footprint on x64 machines :)
13:07:29 <tdammers> lists have other advantages
13:07:30 <erisco> but you can't overlook indexing!
13:07:31 <shanemikel> I have a repo with submodules, and they're listed in stack.yaml under 'packages'.. but they aren't stack projects themselves.  building wasn't working, but something's happening now that I've done 'stack install vendor/localPackage'
13:07:36 <dolio> sm: It's like foo** vs a linked list of foo*.
13:08:05 <shanemikel> is this still safe even though they aren't stack projects? and do I need to manually rebuild them if they're changed?
13:08:09 <sm> ok, thanks all
13:08:37 <kadoban> shanemikel: You might need the 'subdirs' configuration thing in stack.yaml. 'stack install' is likely not correct if you're trying to use them as dependencies. Or at least it's not a necessary step.
13:08:54 <kadoban> Or I think it's called subdirs, I dunno, I'd have to look it up.
13:09:07 <sm> merijn: I'm not seeing a huge improvement in footprint after converting to String to Text. I think the different is small if you have many short strings ?
13:09:28 <merijn> sm: How many short strings?
13:09:40 <sm> a couple of thousand
13:09:47 <merijn> a couple thousand is small anyway
13:11:02 <merijn> But String can take 24 byte per char on x64 (8 bytes for pointer to list constructor, 8 bytes for pointer to character and 8 bytes for the character), vs 2 (average) - 4 (max) bytes per character plus like 16 bytes overhead per several kilobyte chunk for Text
13:12:34 <dolio> I think the overhead is more than 16 bytes.
13:12:37 <sm> every Text also has a minimum size, right ?
13:13:08 <dolio> Because for very small strings, it loses to String, I thought.
13:13:30 <sm> that was my recollection too. But I don't know where I read it
13:13:31 <dolio> Unless that's specific to 32-bit for some reason.
13:14:18 <merijn> So, say we have 10 character pieces of text, then we have 1,000 * (10*2 + 16) = 36,000 bytes = 36 kB VS 1,000 * (10 * 24) = 240,000 bytes = 240 kB
13:14:42 <merijn> So, like 200 kB difference if you have 1000 strings
13:14:56 <merijn> dolio: 32bit does half the size of strings
13:15:16 <merijn> dolio: You might be right, it might be 24 bytes overhead?
13:15:30 <dolio> I think it's more than that, even.
13:15:31 <merijn> 8 bytes pointer to buffer, 8 byte pointer to next chunk, 8 byte size?
13:15:36 <dolio> 16 bytes would just be the 2 Ints.
13:15:48 <dolio> But there's also a tag, and the array itself has some overhead.
13:16:08 <merijn> Which tag?
13:16:16 <dolio> Constructor tag.
13:16:40 <pikajude> is there a hackage package that can do git cloning? i don't want to rely on both the git command line tool and gitlib
13:16:43 <merijn> dolio: That's only once though and String has that too
13:17:08 <dolio> Right, but you have to count it in the overhead still.
13:17:25 <merijn> dolio: That's not overhead per few kb, though
13:17:26 <dolio> It's not per character, it's per chunk.
13:17:50 <merijn> Actually strict Text is indeed exactly 24 bytes overhead
13:17:53 <greg`> whats the defacto channel for pasting code here?
13:18:04 <greg`> lpaste, hpaste , pastebin?
13:18:04 <sm> isn't there also a minimum chunk size ? but I guess only lazy Text uses chunks
13:18:13 <tdammers> greg`: see /topic. lpaste.
13:18:14 <dolio> No, it's still more than 24.
13:18:28 <greg`> tdammers: thanks
13:18:35 <merijn> sm: Why would there be a minimum chunk size?
13:18:44 <greg`> /topic. lpaste
13:18:52 <sm> I don't know
13:19:12 <sm> I assumed some efficiency reason
13:19:37 <merijn> How does having a minimum size improve efficiency? :p
13:19:40 <dolio> You can get the size of a ByteArray# for instance, so it presumably has 8 bytes of overhead itself.
13:19:47 <dolio> At least.
13:19:54 <sm> it's pretty common in other contexts. But never mind
13:22:24 <sm> speaking of getting the size.. if https://github.com/nomeata/ghc-heap-view/issues/3 were fixed, we could measure it and find out for sure
13:22:47 <sm> ghc-heap-view (and ghc-datasize) needs updating for 7.10/8.0 I think
13:23:03 * hackagebot webdriver 0.8.3 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.8.3 (AdamCurtis)
13:27:52 <shanemikel> okay, so I've added the subdirs as `location` entries in stack.yaml's packages, and so far it seems to be building them properly.  one of the deps is only required by a certain build flag, but the cabal file will determine this, right? stack.yaml shouldn't be aware of this
13:27:58 <shanemikel> err stack
13:29:37 <kadoban> shanemikel: Yeah you can have dependencies in stack.yaml that don't get used, or only get used under certain circumstances, stack doesn't care.
13:29:53 <shanemikel> the key was to add them under packages as locations with extra-dep=true
13:30:30 <kadoban> Ah yeah, that's commonly left out. It's a bit unintuitive. I think there's a plan to refactor a lot of that so it makes more sense, dunno though.
13:33:02 <shanemikel> in what situation would you have other package directories that aren't dependencies, but part of the project?
13:37:14 <pikajude> I have a Chan that I send IO actions to (for ansi-terminal colored printing) cause my program is multithreaded
13:37:23 <pikajude> what's the best way to print an error and exit?
13:37:49 <pikajude> if I have some operation that fails, I send an error message to the Chan, but then I just need to wait in the current thread for that action to be executed
13:37:50 <pikajude> and the nexit
13:37:53 <pikajude> then* exit
13:39:12 <merijn> pikajude: Is the plan to exit when that happens?
13:39:18 <pikajude> yeah
13:39:31 <merijn> pikajude: i.e. the thread that reads the chan should just stop immediately, print an error and exit, yeah?
13:39:36 <pikajude> right
13:39:42 <pikajude> and the thread sending messages to the Chan should stop doing anything
13:39:46 <pikajude> since there's no way to properly continue
13:39:46 <merijn> pikajude: Why not throw an exception to the reading thread?
13:39:59 <pikajude> but what should the task sending the message do in the meantime?
13:40:17 <merijn> pikajude: No, I mean from the sending thread
13:40:22 <pikajude> Right
13:40:30 <pikajude> does that block until it's received?
13:40:35 <merijn> pikajude: We have async exceptions, so you can throw an exception from the sending thread to the reading one and interrupt it
13:40:39 <merijn> pikajude: Yes
13:40:44 <pikajude> ok
13:40:50 <pikajude> so I need to send some messages, then throw an exception
13:40:54 <pikajude> to make sure the messages are printed for the user
13:51:44 <gajus> why Haskell is non-existent in top-tier paying contract job ads?
13:52:06 <gajus> e.g. you can easily find a lot of JavaScript contracts that pay USD 1000/ day, but I cannot find a single Haskell contract in that range
13:52:25 <gajus> This is not meant to critisize Haskell in any way
13:53:04 * hackagebot wordpass 1.0.0.5 - Dictionary-based password generator  https://hackage.haskell.org/package/wordpass-1.0.0.5 (MichalGajda)
13:53:30 <merijn> gajus: Because those contracts are desperate "I quickly need something hacked into my site and I don't care about how" jobs
13:53:39 <gajus> er. No.
13:53:41 <merijn> gajus: Whereas most haskell people are working longer term
13:54:03 <merijn> gajus: Can you find such contracts for C++ and Java?
13:54:06 <merijn> (or C)
13:54:09 <scshunt> merijn: follow up from yesterday. Do you have an opinion about using ifcxt in real code? Is it a sign of bad design or a necessary evil?
13:54:19 <gajus> I work for one of the top 5 IBs and assure you that our projects are not "we need this done yesterday, do something quick"
13:54:22 <merijn> scshunt: "It Depends (TM)" :)
13:54:31 <Rembane> gajus: Where do youd find those Javascript-work? I'm in need of more hours. :D
13:54:33 <scshunt> merijn: heh. I'm looking for opinions, so what on?
13:54:36 <gajus> merijn: C++ or Java in that range? Sure.
13:54:57 <kadoban> gajus: Haskell isn't as well know/used in industry as a bunch of other languages. It seems to be becoming more popular somewhat rapidly to me, but I dunno.
13:54:57 <gajus> Rembane Any contract-orientent job website.
13:55:04 <merijn> gajus: I dunno what IB even means
13:55:09 <gajus> Investment Bank
13:55:14 <gajus> sorry
13:55:36 <merijn> Plenty of banks/investment firms using Haskell, pretty sure they pay comparable
13:56:13 <gajus> I do like everything I see about Haskell: it feels like if I removed everything from JavaScript that I don't like, it would become similar to Haskell
13:56:14 <merijn> gajus: It could just be that haskell jobs aren't advertised on websites you're looking. Most haskell jobs I see come by are going on reddit, IRC, mailing list, twitter
13:56:29 <gajus> That could be the case.
13:56:37 <Rembane> gajus: Cool. Thanks.
13:56:37 <gajus> I am looking at jobserve.com
13:56:45 <tmobile> Anyone hear any rumblings of Stackage snapshots targeting 8.0.1?
13:56:50 <gajus> Rembane, thats for you
13:56:53 <merijn> gajus: I know that Standard Chartered Bank is almost always hiring, for example
13:56:54 <dolio> Or if it's contract work, they could go directly to one of multiple known Haskell contracting companies.
13:57:17 <gajus> dolio the same applies for JavaScript though
13:57:19 <merijn> gajus: So is Jane Street (Ocaml instead of haskell, but they're happy to interview haskell people and retrain them for ocaml)
13:57:31 <Rembane> gajus: Nice!
13:58:32 <gajus> merijn Would you say it is realistic then to find a contract paying USD 1k~ range for Haskell developer?
13:58:50 <merijn> No clue what various banks are paying
13:59:11 <shanemikel> Haskell is REALLY far from JS.  A statement like that really doesn't make any sense.  Unless you meant to say that "anything you don't like" includes the entire design of the language.
13:59:43 <merijn> shanemikel: Sounds like my opinion of JS :)
13:59:47 <tmobile> gajus: There are simply fewer large systems implemented in Haskell. Haskell contracts are rarer, but they're out there. My company have hired Haskell contractors before.
14:00:23 <gajus> shanemikel Okay. True. I am saying this primarily because we are using JS in strictly FP env, as much as that is possible.
14:00:48 <gajus> tmobile any website you'd recommend to subscribe for job ads?
14:01:11 <tmobile> Theres FunctionalWorks.
14:01:13 <tmobile> http://functionalworks.com/
14:01:16 <merijn> gajus: haskellers.com, haskell-cafe mailing list, haskell reddit
14:02:44 <gajus> Okay. I can see some jobs that pay 200k/ year. Thats roughly eqv. to USD 1k/ day contracts.
14:02:47 <gajus> Interesting.
14:03:08 <gajus> Thank you for the links, merijn, tmobile
14:03:36 <dolio> I'm not sure looking at any website is the best way to go about being a contractor in something like Haskell.
14:03:38 <merijn> gajus: Also, if you're willing to relocate Standard Chartered Bank are frequently hiring people in Singapore (and less frequently London)
14:03:50 <dolio> I suspect it's more about getting yourself well known so people contact you directly.
14:03:59 <dolio> But I haven't done it, so I may be wrong.
14:04:00 <{AS}> defining fmap xs = [] satisfies the functor laws right?
14:04:08 <merijn> {AS}: No
14:04:13 <{AS}> fmap f xs = []
14:04:17 <merijn> {AS}: "fmap id x == id x"
14:04:25 <{AS}> merijn: Ah yes, thanks!
14:04:54 <merijn> {AS}: In fact, there's EXACTLY one possible lawful implementation for any functor :)
14:05:05 <{AS}> merijn:  Ah cool :)
14:05:29 <merijn> {AS}: And "fmap id x == id x" is the only law you need, the second functor law is a free theorem in haskell
14:05:56 <{AS}> So we could theoretically prove that forall (F, G : Functor (List a)) F.fmap f xs = G.fmap f xs ?
14:06:29 <merijn> {AS}: Assuming F.fmap and G.fmap are lawful? Yes
14:06:38 <{AS}> merijn: Thanks
14:06:59 <merijn> {AS}: If you're interested in learning how to prove stuff like this, check out the (free!) book Software Foundations
14:07:02 <merijn> @where sf
14:07:02 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,SjÃ¶berg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
14:07:02 <lambdabot> assistant."
14:07:26 <{AS}> merijn: Thanks
14:13:05 * hackagebot BlogLiterately 0.8.3 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.3 (BrentYorgey)
14:36:32 <Ohso_> I'm wondering: Is there a way to consolidate the two calls to doThing in the following? http://pastebin.com/FAVDzsUP
14:37:27 <merijn> Ohso_: Yes, using the magic of...pattern guards!
14:38:24 <merijn> Ohso_: http://lpaste.net/164552
14:40:26 <Ohso_> Yeah, I don't understand that syntax at all. lol  :p
14:40:50 <merijn> Ohso_: the , in the guard introduces a second guard
14:40:59 <Ohso_> Is the lookup performed in all cases, or will the test of the constant short circuit it?
14:41:00 <merijn> Ohso_: A pattern guard is just a pattern match
14:41:14 <merijn> Ohso_: The constant test will shortcircuit it
14:41:43 <merijn> Ohso_: And if the "Just value <- M.lookup x aMap" pattern match fails, it falls through just like a regular guard
14:42:04 <merijn> Ohso_: Basically pattern guards let you do arbitrary pattern matches in guards, and if they fail they fall through to the next guard :)
14:42:55 <Ohso_> Interesting. That would seem to be what I need. Do you know what it would correspond to without the syntactic sugar?
14:43:00 <Ohso_> Just curious
14:43:56 <merijn> Ohso_: Nested cases
14:44:07 <Ohso_> Or is there no way to do that without pattern guards?
14:44:15 <merijn> Ohso_: See this (old) documentation on pattern guards: https://downloads.haskell.org/~ghc/5.02/docs/set/pattern-guards.html
14:44:19 <glguy> it would correspond to the thing that you wrote originally
14:44:25 <geekosaur> the desugaring for pattern guards is specified in the haskell2010 report
14:44:28 <zq> is it possible to programmatically access the commentary of a .lhs?
14:44:30 <merijn> (pattern guards used to be an extension, but it's standard in haskell2010)
14:44:36 <Ohso_> Hmm. So the nested cases would required the duplicated call? No way around it?
14:45:09 <glguy> Ohso_: You can name the duplicated thing in a where clause
14:45:44 <Ohso_> You'd still have to call the name twice though, right?
14:46:01 <EvanR> let x = oneThing in (x,x)
14:46:08 <EvanR> used in two places
14:47:12 <Ohso_> I tried adding a where clause, but couldn't figure out how to write it in a way that didn't require the name be used twice. Looks like pattern guards are the way to go.
14:48:04 <Ohso_> I don't really get the <- syntax in the pattern guard.
14:49:52 <Ohso_> Just learning haskell and it's confusing when to use =  or  <-  or  -> in the various contexts.
14:50:16 <merijn> Ohso_: It's like "pat <- expr" in a guard basically says "try to match expression expr with pattern pat", if it fails, the guard fails
14:51:21 <EvanR> :t fromMaybe
14:51:23 <lambdabot> a -> Maybe a -> a
14:51:36 <EvanR> Ohso_: http://lpaste.net/164553
14:51:37 <quchen_> Ohso_: f | pat <- expr = stuff   ===   f | patMatches = stuff where patMatches pat = True; patMatches _ = False
14:51:50 <quchen_> Something along those lines.
14:52:10 <quchen_> (The pattern can bind variables, which is quite handy.)
14:52:14 <EvanR> notice i used fromMaybe to reduce the number of lines
14:52:25 <EvanR> in a comment
14:53:16 <EvanR> you can get a lot of traction out of just putting the entire function in a where clause by beginning with = answer where
14:53:39 <EvanR> when necessary you can use inner wheres
15:02:36 <dibblego> @type maybe mzero pure -- does this exist anywhere?
15:02:38 <lambdabot> MonadPlus m => Maybe a -> m a
15:03:05 <dibblego> s/mzero/empty
15:05:40 <glguy> :t mfilter
15:05:42 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
15:05:45 <glguy> close...
15:05:58 <dibblego> ah yeah cheers
15:06:34 <glguy> msum is close, too: Maybe (m a) -> m a...
15:09:06 <zq> is there a type-level map already defined in some standard package
15:12:52 <jle`> i use the one from type-combinators
15:15:35 <fishythefish> Suppose I want to express `data Foo = Foo { bar :: ??? , baz :: Int }` where bar must be bar :: C a => Foo -> a for some typeclass C. What's the best way to do this?
15:16:09 <fishythefish> (For a concrete foo :: Foo, I don't care what the type of `bar foo` is beyond that I can use the C interface.)
15:17:09 <zq> if you're trying to parameterize by typeclass, then you can add a Constraint kind as a type argument to foo
15:17:57 <fishythefish> C is fixed
15:18:42 <merijn> fishythefish: You probably want "data Foo = Foo { bar :: C a => a, baz :: Int }" works, assuming you enable RankNTypes
15:18:43 <fishythefish> e.g. you can assume C is Functor everywhere
15:19:18 <merijn> "data Foo = Foo { bar :: Num a => a, baz :: Int }" with RankN produces "bar :: Num a => Foo -> a"
15:20:11 <fishythefish> merijn: and the constructor/setter will require that value to be Num a => a as well?
15:20:30 <merijn> fishythefish: Yes
15:20:39 <fishythefish> Okay, great!
15:20:39 <merijn> well actually
15:20:45 <merijn> It will require it can be ANY 'a'
15:21:16 <fishythefish> er
15:21:28 <Cale> You probably want an existential, by the sounds of it
15:21:45 <merijn> Perhaps
15:21:48 <merijn> Depends on the class :p
15:21:52 <EvanR> hold the phone... i hit :r to reload and it worked, then when i tried toevaluate something it gave a type error
15:21:55 <Cale> data Foo = forall a. C a => Foo { bar :: a, baz :: Int }
15:22:14 <merijn> Cale: This version would work well if you want to do "Foo { bar :: Bounded a => a }" Foo { bar = minBound }
15:22:34 <sm> EvanR: -fdefer-type-errors ?
15:22:38 <EvanR> ah what i typed had a type error
15:22:43 <EvanR> duh
15:22:49 <fishythefish> Cale: what's the difference between yours and merijn's?
15:23:33 <Cale> With mine, when you apply the Foo data constructor, the precise type of the bar field is forgotten, and you may use a value of any particular type which is an instance of C there
15:24:11 <fishythefish> But it'll only typecheck if the type is an instance of C, right?
15:24:16 <Cale> right
15:24:27 <fishythefish> And the type of bar becomes C a => Foo -> a?
15:24:51 <Cale> With merijn's, you're required to apply the Foo constructor to something which is polymorphic, and you get to use the resulting field as an arbitrary type which is an instance of the typeclass C.
15:25:40 <fishythefish> Ah, right.
15:25:55 <Cale> i.e. with mine, when you make a Foo, you can use any type which is an instance of C, and when you take it apart, you don't know what type that was
15:26:07 <fishythefish> Yours sounds like what I want, then.
15:26:34 <fishythefish> Is there a specific language extension for that?
15:26:37 <Cale> and with his, when you make a Foo, it has to be undetermined what the type is, and the person who takes the Foo apart gets to decide
15:27:07 <Cale> ExistentialQuantification
15:28:49 <fishythefish> Thanks
15:29:25 <fishythefish> Basically, I want the data constructor/record setter to enforce at the type level that the type of bar is an instance of C
15:29:34 <fishythefish> but when I retrieve that field, I only plan to use the C interface
15:29:43 <fishythefish> so I don't care about remembering the original type
15:30:04 <fishythefish> just that it is an instance of C
15:35:50 <Cale> fishythefish: yep, that's what existentials do
15:36:04 <fishythefish> Awesome, thanks for the help :)
15:36:35 <Cale> fishythefish: Often, if you're designing the C type class at the same time, you should consider making the type class itself into a data type though
15:37:01 <fishythefish> Cale: hm, I am doing that
15:37:20 <fishythefish> I want users of my code to be able to add their own instances of the typeclass, though
15:38:19 <fishythefish> e.g. the typeclass serves as an interface for probability distributions
15:38:44 <fishythefish> and users may wish to define their own
15:40:35 <fishythefish> Cale: is there a cleaner way to set this up?
15:41:44 <Cale> hmm, what are the class methods?
15:42:49 <fishythefish> suppose there's just one, mapping x values to y values
15:44:00 <fishythefish> (actually, it's more like mapping x, y, z to w values)
15:44:16 <fishythefish> This interface could grow in the future
15:46:36 <fishythefish> I guess I could use a (product of) function types instead of a typeclass?
15:46:47 <Cale> Yeah
15:47:15 <Cale> I would attempt a translation, but I'd need to know what the types of the class methods were
15:47:49 <fishythefish> Cale: it's okay, I have the idea
15:48:13 <Cale> Sometimes you want to use a recursive type, depending on what the methods are exactly.
15:49:43 <EvanR> the incredible growing interface
15:50:19 * fishythefish shrug
15:50:53 <EvanR> for a reimplementable interface, it might be better to have multiple smaller ones
15:51:16 <EvanR> otherwise it may become unreimplementable
15:51:48 <EvanR> like the classic java method "canDoX" where "doX" crashes otherwise
15:52:17 <fishythefish> EvanR: yeah, I've been keeping an eye on that
15:52:41 <EvanR> or worse returns null!
15:52:55 <fishythefish> it's more like the interface might gain a function during the development phase rather than during use
15:59:08 <zq> is there syntax for defining field accessors to a gadt?
15:59:43 <pavonia> The standard syntax should work
15:59:49 <zq> something like `data D a where { A :: { get_string_a :: String } -> D String; }`
15:59:57 <zq> pavonia: what's the standard syntax?
16:00:06 <pavonia> That ^
16:01:03 <idonutunderstand> hey all
16:01:17 <idonutunderstand> I'm just getting started with haskell
16:01:32 <fishythefish> welcome :)
16:02:03 <idonutunderstand> I'm pretty excited
16:02:20 <idonutunderstand> to learn to think in a new way
16:02:29 <zq> > data D a where { A :: { get_string_a :: String } -> { get_int :: Int } -> D String; }
16:02:31 <lambdabot>  <hint>:1:1: parse error on input â€˜dataâ€™
16:02:36 <zq> @let data D a where { A :: { get_string_a :: String } -> { get_int :: Int } -> D String; }
16:02:36 <lambdabot>  Parse failed: Parse error: {
16:03:00 <zq> pavonia: for the above, ghci complains: "Record syntax is illegal here: {get_int :: Int}"
16:03:24 <pavonia> Yes, you can only have one group with accessors, I think
16:03:30 <zq> asdf
16:04:26 <Ohso_> I think I found a way to do what I was trying without using pattern guards and without repeating the function or name in two places:  http://pastebin.com/kk86dien
16:05:21 <EvanR> opinion poll: if you have a rectangular grid with cell coords (n,m), are the rows number increasing up or increasing down
16:05:34 <EvanR> obv cols are numbered increasing left to right ;)
16:05:45 <Ohso_> Not saying it's better. Just trying to figure out what's possible.  :)
16:05:46 <EvanR> Ohso_: i pasted a way to do that
16:05:54 <Ohso_> Really? Didn't see that.
16:06:44 <EvanR> http://lpaste.net/164553
16:06:50 <EvanR> it doesnt use pattern guards
16:07:02 <fishythefish> EvanR: depends on context
16:07:04 <EvanR> er... maybe it does
16:07:19 <EvanR> fishythefish: heh, well this is a blank context
16:07:22 <EvanR> which is why im asking
16:07:29 <fishythefish> oh boy
16:08:03 <Ohso_> But f x is repated twice there - once in the fromMaybe expression and once in the otherwise.
16:08:09 * hackagebot gi-gtk-hs 0.2.0.0 - A wrapper for gi-gtk, adding a few more idiomatic API parts on top  https://hackage.haskell.org/package/gi-gtk-hs-0.2.0.0 (HamishMackenzie)
16:08:12 <fishythefish> EvanR: by default, I guess I'd say upward
16:08:24 <EvanR> Ohso_: x is different in each situation
16:08:43 <EvanR> oh is it not?
16:09:02 <Ohso_> No it isn't
16:09:23 <EvanR> Ohso_: http://lpaste.net/164553
16:09:37 <idonutunderstand> what does the "f a" signify in the type "fmap :: (a -> b) -> f a -> f b"? according to http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux  it is a "box with an a (or several of them) inside" but what does that mean?
16:10:58 <nitrix> idonutunderstand: That's not the full type signature.
16:11:13 <nitrix> idonutunderstand: It should read as  fmap :: Functor f => (a -> b) -> f a -> f b
16:11:19 <fishythefish> idonutunderstand: the full signature is fmap :: (Functor f) => (a -> b) -> f a -> f b
16:11:20 <fishythefish> ninja'd
16:11:21 <EvanR> Ohso_: another way is to use Maybe throughout and use dontRepeatThis as the final default value
16:11:27 <EvanR> :t guard 
16:11:28 <Cale> idonutunderstand: It could be just about any type which has a type parameter, and for which you could write such a function
16:11:28 <lambdabot> Alternative f => Bool -> f ()
16:11:49 <fishythefish> idonutunderstand: how comfortable would you say you are with the notion of a functor at this point?
16:12:22 <Cale> idonutunderstand: For example, a library for working with parsers might provide a type Parser t representing a parser which will try to eat the beginning of a string in order to produce a value of type t
16:12:30 <nitrix> idonutunderstand: Where `f` is any type that has an instance implementation for the typeclass Functor. Knowing typeclasses or having seen a few examples of functors being used generally helps putting pieces together.
16:12:44 <Cale> idonutunderstand: It might provide an instance of Functor, which would then specify the operation fmap :: (a -> b) -> Parser a -> Parser b
16:13:05 <fishythefish> similarly, fmap for lists has the type (a -> b) -> [a] -> [b] and is just the function map
16:13:38 <nitrix> Here's another common you've probably seen, specialized to Maybe :   (a -> b) -> Maybe a -> Maybe b
16:13:48 <Cale> which, given a function a -> b, and a parser for values of type a, produces a parser for values of type b, presumably by applying the function to the result of the given parser
16:14:22 <fishythefish> in other words, when you declare that the type Foo is a functor, you provide an implementation of fmap specialized to (a -> b) -> Foo a -> Foo b
16:14:34 <fishythefish> what this implementation is depends on what the type Foo is
16:14:44 <EvanR> idonutunderstand: i think no one has mentioned yet that when you see something like `f a' f is a type constructor applied to a type, both of which are variables
16:14:57 <Ohso_> I was trying to avoid writing it twice, not avoid running it twice.
16:14:59 <fishythefish> s/type/type constructor
16:15:11 <EvanR> in this case f is a Functor but thats just this case
16:15:19 <Cale> It's correct to refer to f as a type, even if it has a parameter
16:15:29 <EvanR> fishythefish: a is a type
16:15:49 <Cale> f is a type of kind * -> *
16:15:51 <fishythefish> EvanR: oh, did I say something else?
16:15:58 <EvanR> nvm
16:16:56 <nitrix> What about we wait for a sign of life ;)
16:17:05 <Cale> In order to write the instance of Functor, there will need to be a type constructor involved though (a type whose name starts with an uppercase letter, and which the algorithm which selects which instance of the type class to use can pattern match on)
16:17:06 <fishythefish> nitrix: was thinking that myself :P
16:17:21 <Cale> Ah, * idonutunderstand has quit (Ping timeout: 250 seconds)
16:17:36 <EvanR> life signs terminated
16:17:36 <fishythefish> RIP
16:17:42 <fishythefish> press [f] to pay respects
16:17:48 <Cale> But yeah, if we're being nitpicky, Integer is a type constructor too
16:17:51 <nitrix> Insert coin.
16:18:09 * hackagebot gi-gtk-hs 0.2.0.1 - A wrapper for gi-gtk, adding a few more idiomatic API parts on top  https://hackage.haskell.org/package/gi-gtk-hs-0.2.0.1 (HamishMackenzie)
16:18:25 <EvanR> nitpicky in this case means destroying any meaning to the word type and type constructor
16:18:41 <fishythefish> ^
16:18:42 <EvanR> the nitpick is that they "can" both mean either, which is less useful
16:18:55 <EvanR> so its like anti nitpicking
16:19:24 <fishythefish> nitplacing
16:19:27 <Cale> The meaning in the Report is that a type constructor is something whose name starts with an uppercase letter, and which gets introduced by a data or newtype declaration (or is a handful of built in things, like (->) and [])
16:20:01 <Cale> and the relevance of that is that when you write instances, they have to pattern match on type constructors
16:20:26 <EvanR> i understand how `f a' in a type can be mysterious to someone who is paying attention
16:20:30 <EvanR> and new
16:20:36 <Cale> But yeah, types have kinds, and type constructor doesn't necessarily mean a type of kind * -> *
16:20:37 <EvanR> so i think there needs to be actual words for it
16:20:50 <scshunt> Cale: also symbols that start with a colon
16:20:56 <Cale> scshunt: indeed
16:21:09 <Cale> and other ones too now :(
16:21:14 <scshunt> oh?
16:21:16 <nitrix> EvanR: My first question as a beginner was, is `f a` a thing of its own or `f` wrapping `a`, or any other weird variations. The space was the culprit I think.
16:21:20 <scshunt> oh right, GHC overloads them, doesn't it
16:21:26 <Cale> There once was a time that ~> could be used as a type variable
16:21:32 <scshunt> O_o
16:21:35 <fishythefish> ._.
16:21:44 <Cale> which was really nice with the Arrow type class
16:21:59 <Cale> arr :: (Arrow (~>)) => (a -> b) -> (a ~> b)
16:22:01 <EvanR> nitrix: overloaded whitespace!
16:22:01 <nitrix> Cale: Isn't Arrow being discouraged right now?
16:22:20 <scshunt> oh right, I've seen that
16:22:22 <Cale> nitrix: I dunno. It's not like it's actively discouraged
16:22:35 <fishythefish> idonutunderstand: welcome back!
16:22:40 <EvanR> it does its own discouraging ;)
16:23:19 <nitrix> idonutunderstand: You had plentiful of answers, maybe too many answers while you were gone. Feel free to say a word and we'll try to walk you through again. Stop us at any time.
16:23:26 <fishythefish> +1
16:23:27 <Cale> nitrix: It's that it's not ideally structured to handle the niche of libraries which it would otherwise be good for. It's really close to the definition of a symmetric monoidal category, but it's missing some stuff that it needs, and arr would be best off in its own class...
16:25:32 <Cale> nitrix: Oh, and it's missing a law -- the original paper eschewed the law that (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k), because it would mean that the Kleisli category wouldn't be a lawful instance (unless the monad is commutative)
16:25:44 <Cale> But without that law, programming with arrows is bizarre and hard to get right.
16:26:02 <Cale> You don't get the nice diagrammatic language you ought to have
16:26:07 <nitrix> Does it matter in Haskell's case? Laws aren't enforced.
16:26:24 <Cale> Well, it does matter from the perspective of being able to understand what your programs mean.
16:26:28 <idonutunderstand> okay thanks
16:26:51 <Cale> It also matters when translating the proc/do syntax
16:27:07 <idonutunderstand> nitrix: what's the answer to that question?
16:27:20 <nitrix> idonutunderstand: The first observation made was that the type of `fmap` you gave wasn't the complete one. It should be fmap :: Functor f => (a -> b) -> f a -> f b.
16:27:32 <Cale> idonutunderstand: The real answer is that you should look at examples :)
16:27:54 <fishythefish> idonutunderstand, nitrix: #haskell-beginners could be a useful channel here
16:28:14 <nitrix> It sure would be less noisy to show various examples.
16:28:15 <Cale> idonutunderstand: Many libraries will provide data types which have a type parameter
16:28:57 <fishythefish> idonutunderstand: for instance, have you worked with the C++ STL or Java containers or something similar?
16:29:23 <idonutunderstand> so much information so fast :)
16:29:28 <nitrix> idonutunderstand: The second thing if I try to condense all the good answers was that, the `f` here is a type variable with the same role as the other type variables. It gets substitued by a type, but the constraint on the left of => imposes that that type most have an instance definition for Functor.
16:29:29 <Cale> idonutunderstand: For example, a library which defines parsers might define a type (Parser t) which would be the type of parsers whose result is a value of type t
16:30:16 <Cale> That library might define an instance of the Functor type class, which means it would specify a function  (a -> b) -> Parser a -> Parser b
16:30:41 <Cale> So, what fmap actually means depends on the choice of the type f
16:32:01 <Cale> A different library which defined a type for binary trees labelled with values of type t, say BinTree t, might have an instance with  fmap :: (a -> b) -> BinTree a -> BinTree b
16:32:15 <Cale> (which would apply the function to all the values in the tree)
16:32:48 <Cale> > fmap (*2) [1..10] -- it works for lists
16:32:50 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
16:32:59 <Cale> > fmap (*2) (Just 5) -- it works for Maybe
16:33:00 <lambdabot>  Just 10
16:33:10 <Cale> It also works for IO actions, if you know about those.
16:33:53 <Cale> (producing an action which runs the given action and applies the given function to its result)
16:34:23 <nitrix> Cale: Functor is very early in LYAH, so no, he probably doesn't know and probably very confused, as you'd expect from the readers of that book.
16:34:46 <fishythefish> idonutunderstand: did any of that make sense?
16:34:47 <Cale> Well, I have no idea what it is that he's seen :)
16:34:58 <fishythefish> Cale: he linked to the relevant chapter from LYAH
16:35:03 <fishythefish> and said he's new to haskell
16:35:16 <fishythefish> so it's likely that he's following the book
16:35:41 <fishythefish> and timing out, apparently
16:36:17 <nitrix> I think I'll just direct him to #haskell-beginners and see what happens from there.
16:36:26 <fishythefish> nitrix: I did try :P
16:37:10 <nitrix> Where we can actually take the time to assess what he knows and understands well before continuing.
16:37:29 <nitrix> It's sad LYAH works for some, for others, it confused the hell out of them.
16:38:01 <nitrix> s/fused/fuses/
16:38:17 <nitrix> I liked the cutesy illustrations (:
16:38:48 <fishythefish> nitrix: I liked it too, but it moves along fairly quickly
16:38:58 <fishythefish> the examples in the book alone probably aren't sufficient for many people
16:40:26 * EvanR imagines #haskell as the village whose inhabitants want to form a pitchfork mob and march up to castle LYAH
16:40:53 <idonutunderstand> sorry all, internet connection here is too spotty. i will return :)
16:41:01 <fishythefish> no worries
16:41:11 <fishythefish> we're happy to help you in #haskell-beginners as well
16:41:20 <fishythefish> it might be easier to talk there
16:41:21 <idonutunderstand> roger
16:41:49 <nitrix> Gonna have to use SYN-ACK systems :P
16:42:20 <RyanGlScott> Is there a technique for saying "this constraint entails another constraint" in an instance?
16:42:39 <RyanGlScott> For example, if you have data ConstrId c a where ConstrId :: c => a -> ConstrId c a
16:43:01 <RyanGlScott> Can you say: instance (c `Entails` Eq a) => Eq (ConstrId c a) where ... ?
16:43:30 <tippenein> any suggestions on speeding this up? https://github.com/tippenein/etl-language-comparison/blob/haskell-implementation/haskell/src/MapReduce.hs#L45-L47
16:45:19 <tippenein> Also, is ByteString or Text particularly different for streaming?
16:45:27 <tippenein> (speed-wise)
16:46:03 <nitrix> Text has the notion of encodings to it.
16:46:39 <nitrix> ByteString is probably faster/more convenient; assuming you don't manipulate textual data with various encodings.
16:47:41 <hpc> Text is encoding-agnostic
16:48:10 <hpc> Data.ByteString.Char8 is bytes that represent text in some mysterious encoding that's beyond the type system's knowledge
16:48:35 <tippenein> I'm assuming Pipes.filter .. >-> Pipes.map ... is my bottleneck, but I'm not really sure
16:48:37 <hpc> so basically, do you like BOMs and encodings and conversions and inconvenience?
16:48:52 <nitrix> tippenein: Profile it.
16:49:44 <tippenein> I tried benchmarking with criterion, but it never terminated with nfIO https://github.com/tippenein/etl-language-comparison/blob/haskell-implementation/haskell/bench/bench.hs
16:50:25 <tippenein> and whnf finished in seconds.. which is wrong
16:50:36 <EvanR> charset="terribly-mysterious"
16:57:22 <maerwald> My docs don't seem to build on hackage for over a day now. Does someone have a nice travis script that generated docs and pushes it to your github.io page?
17:05:06 <RyanGlScott> maerwald, dunno about github.io, but you can upload documentation to Hackage directly as of cabal-install-1.24
17:05:15 <RyanGlScott> cabal upload -d
17:10:27 <zq> hm
17:10:48 <zq> did we jump from 7.10.x to 8.0? was 7.12.x ever released?
17:17:19 <RyanGlScott> zq: We did jump. Richard Eisenberg proposed making the version after 7.10 be 8.0.
17:17:32 <RyanGlScott> So that we can say: Use GHC 8. It's great!
17:17:41 <obadz> sounds sensible!
17:17:56 <RyanGlScott> (Also, it has a truckload of new features, so a major version bump seemed warranted.)
17:31:40 <sbrg> how much hassle is it to use ghc8 with stack? can I use the nightly snapshots with it fine?
17:32:13 <geekosaur> it's released now. I would expect stack has 8.0.1 directly supported by now
17:32:25 <geekosaur> although there may not be a non-nightly resolver for it yet
17:32:59 <RyanGlScott> There's not even a nightly for it yet: https://github.com/fpco/stackage/issues/1476#issuecomment-221533368
17:33:07 <mgsloan> A nightly resolver is in the works, but yeah, it's pretty straightforward to use ghc 8 atop a nightly
17:33:34 <mgsloan> Yeah it'll probably be a little while before all the packages get updated
17:34:02 <nitrix> What's the best way to test hundreds of insertions and deletions from a data structure to make sure it's not getting all sorts of messed up corrupted?
17:34:36 <mgsloan> For example, stack has a fair number of dependencies.  Here's how stack gets built with ghc-8: https://github.com/commercialhaskell/stack/blob/master/stack-8.0.yaml
17:37:53 <obadz> Wouldn't it be nice to be able to specific multiple default implementations for typeclass members (based on increasingly broad constraints) :-/
17:53:13 * hackagebot octane 0.5.1 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.1 (fozworth)
17:57:17 <categoryTheoreti> Hello, can anyone tell me how to specify the signiture for a function that accepts a UArray of type A, variable p and returns type B? 
17:57:28 <categoryTheoreti> I seem to be missing the syntax
17:58:19 <pavonia> A UArray takes two arguments
18:00:27 <categoryTheoreti> arguments referring to what?
18:00:30 <categoryTheoreti> pointsToSet :: UArray SkeletonPoint p -> SkeletonSet
18:00:59 <pavonia> The first argument is the index type, the second the elemnt type
18:01:42 <categoryTheoreti> so like this? :  pointsToSet :: UArray Int SkeletonPoint p -> SkeletonSet
18:02:54 <pavonia> That are three arguments. It really depends on what your function is meant to do
18:03:29 <pavonia> What does your UArray store, and how do you index it?
18:03:58 <categoryTheoreti> Ok, so, the function takes and array of SkeletonPoints p and returns a SkeletonSet.  As far as I know, it's indexed by integers, no?
18:04:20 <Tril> nitrix: look at QuickCheck
18:05:11 <pavonia> categoryTheoreti: You choose the index type, you should know ;)
18:05:32 <lpaste> tippenein pasted â€œgetInputFiles bottleneckâ€ at http://lpaste.net/164561
18:05:34 <pavonia> "UArray SomeIndexType (SkeletonPoint p) -> SkeletonSet" perhaps
18:05:38 <tippenein> oddly enough, the getInputFiles portion is 60% of the runtime..
18:07:02 <carterhinsley> Is there a good reference on getting started with writing Haskell bindings for C/C++ libraries, or a best practices reference?
18:07:35 <carterhinsley> i've written bindings in other settings before but would like to make sure i get this as right as possible the first time around
18:07:58 <carterhinsley> Examples of good codebases are welcome too.
18:22:04 <tippenein> > map ((: [])) ['a'..'m']
18:22:08 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m"]
18:22:31 <tippenein> ^ something less idiomatic ?
18:27:04 <hpc> > ["a" .. "m"]
18:27:06 <lambdabot>      No instance for (Enum [Char])
18:27:06 <lambdabot>        arising from the arithmetic sequence â€˜"a" .. "m"â€™
18:27:06 <lambdabot>      In the expression: ["a" .. "m"]
18:27:08 <hpc> :(
18:27:54 <EvanR> you could make one which is convenient for the application
18:28:07 <EvanR> like "y" "z" "aa" "ab" or some nonsense
18:28:22 <hpc> carterhinsley: perhaps glfw-b and bindings-glfw for an example
18:29:20 <EvanR> carterhinsley: https://hackage.haskell.org/package/mikmod bindings to libmikmod ;)
18:32:05 <Sinestro> Are there functions already to turn an Int`n` into the Word`n` containing the two's compliment representation of the number? It's not exactly tough to write but bit fiddling isn't exactly fun. ;)
18:32:36 <EvanR> no there arent
18:33:09 <EvanR> also Words are still conceptually numbers, not twos complement bit arrays
18:33:21 <EvanR> they do have a Bits interface, like many other things
18:33:50 <Sinestro> I know that it's not 'semantically' right, but I'm mostly trying to puke it out into a file in little endian format with `binary`, and that seems like it's probably the easiest.
18:34:16 <EvanR> with Binary, maybe you can make a newtype for doing that
18:34:20 <EvanR> and give it a Binary instance
18:34:40 <michaelt> tippenein: getInputFiles is doing all the IO, so it's not surprising its the slowest bit, no? 
18:34:52 <EvanR> (the existing Binary instance may already be doing exactly that for Int)
18:36:32 <Sinestro> I checked, it's all big endian, sadly. 
18:37:09 <EvanR> then, a newtype which does byte reverse?
18:37:56 <EvanR> newtype LittleEndian a = LittleEndian { unLE :: a }
18:38:22 <EvanR> instance Binary a => LittleEndian a where
18:38:43 <EvanR> encode the payload, bytereverse, put
18:48:15 * hackagebot postgresql-simple 0.5.2.0 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.2.0 (LeonSmith)
18:48:56 <thoughtpolice> Sinestro: use fromIntegral to convert a signed Int to a Word properly (and back, e.g. `fromIntegral (negate 126 :: Int8) :: Word8 == 130` as expected). Data.Binary.Put has functions for encoding specifically sized Word values as little endian values, too: http://hackage.haskell.org/package/binary-0.8.3.0/docs/Data-Binary-Put.html#g:5
18:49:11 <thoughtpolice> Sinestro: So you should not need anything more special than what you get out of the box.
18:50:17 <Sinestro> Oh, I was basically asking to find out if there is something like what fromIntegral does there; I don't know what else I was expecting it to do.
18:50:26 <thoughtpolice> e.g. 'toLE64 :: Word64 -> ByteString; toLE64 x = runPut (putWord64le x) -- outputs an 8 byte ByteString`
18:50:38 <Sinestro> I got it just fine, thanks
18:50:43 <thoughtpolice> cool
18:51:52 <jknight> Hi
18:52:01 <tomleb> Hey guys I'm getting this error when trying to generate javascript from servant: No instance for (GenerateList
18:52:04 <tomleb>                        ()
18:52:07 <tomleb>                        (http-types-0.9:Network.HTTP.Types.Method.Method
18:52:10 <tomleb>                         -> Servant.Foreign.Internal.Req ()))
18:52:22 <tomleb>       (maybe you haven't applied enough arguments to a function?)I'm using this line of code: writeJSForAPI api vanillaJS "./assets/api.js"
18:52:31 <tomleb> which is exactly the same as in staackage
18:52:46 <jknight> I was told this was a programming channel and was wanting some advice.
18:55:56 <tomleb> Nevermind, fixed it
18:56:20 <michaelt> hi jknight 
18:56:44 <jknight> hello
18:58:49 <jknight> I'm super new to programming but I wanna learn to do some cool stuff but outside of learning to make simple games I don't know much.
19:03:30 <pavonia> There's a lot of cool stuff to learn in Haskell
19:07:50 <scshunt> jknight: this is indeed a programming channel, but it's specifically about the Haskell programming language
19:07:53 <scshunt> Haskell can be quite the ride :)
19:08:01 <jknight> aw crap
19:08:16 * hackagebot minimal-configuration 0.1.3 - Minimal ini like configuration library with a few extras  https://hackage.haskell.org/package/minimal-configuration-0.1.3 (MariusGhita)
19:08:33 <jknight> Is it anything like c programming?
19:08:39 <jknight> Or javascript?
19:08:47 <scshunt> Not really like C at all
19:08:53 <scshunt> Depending on what sort of javascript, sort of
19:09:08 <scshunt> if you're using a lot of callbacks, then that would be familiar
19:09:11 <jknight> like "if statements", booleans, semicolons?
19:09:24 <scshunt> no, yes, optionally but generally not, in that order
19:09:37 <jknight> It doesn't use if statements?
19:10:01 <jknight> And no semicolons?
19:10:11 <scshunt> nope!
19:10:11 <EvanR> if have if statements, bools, and semicolons
19:10:28 <EvanR> they are in the bargain bin
19:10:38 <jknight> I was taught to always use semicolons because lots of languages use it
19:10:45 <EvanR> s/if have/we have/
19:10:52 <scshunt> Haskell is a functional programming language, where control flow is primarily managed by calling functions rather than conditionals and loops
19:11:05 <michaelt> > do {x <- [1..3]; y <- show x; return y}
19:11:06 <lambdabot>  "123"
19:11:08 <EvanR> haskell has programmable semicolons!
19:11:23 <scshunt> Haskell does have an if expression "if 2 < 3 then foo else bar", but it's fairly uncommonly used
19:11:29 <jknight> that sounds cool but im a noob at programming
19:11:38 <scshunt> As for semicolons, Haskell uses indendation-based parsing
19:11:58 <scshunt> you can use semicolons as in michaelt's example, but most of the time you just use new lines and indentation rather than semicolons and braces
19:12:03 <scshunt> (except on IRC when you need a one-liner)
19:12:28 <scshunt> jknight: it is very cool
19:12:35 <jknight> you don't use braces either? man this language is way different than what i learned
19:12:44 <scshunt> jknight: python doesn't either
19:13:04 <jknight> please tell me you use 2 equal signs when you compare stuff at least
19:13:12 <michaelt> > 1 == 3
19:13:14 <lambdabot>  False
19:13:17 <scshunt> jknight: yep
19:13:25 <jknight> okay at least not everything has changed
19:13:48 <scshunt> the function call syntax is different
19:13:53 <jknight> Building games is fun but it takes alot of code and art
19:13:54 <scshunt> > sum [1, 2, 3]
19:13:55 <lambdabot>  6
19:14:10 <jknight> what is sum used for?
19:14:14 <scshunt> to sum a list
19:14:15 <Cale> jknight: If those are the biggest differences from what you already know, then you'll have a very easy time ;)
19:14:33 <michaelt> jknight: to sum the elements of a sequence, in that case a list
19:14:35 <scshunt> jknight: http://haskellbook.com/ is generally recommended here if you're interested
19:14:47 <jknight> So its sort of like a switch statement or enum?
19:14:56 <scshunt> if you don't want to pay, there are other resources too
19:15:03 <Cale> jknight: What is?
19:15:11 <jknight> the sum function
19:15:14 <scshunt> jknight: nope, it's just a function which, given a sequence, adds it up
19:15:21 <Cale> uh, I wouldn't make that comparison... :)
19:15:21 <jknight> ah ok
19:15:28 <scshunt> :t sum
19:15:29 <lambdabot> (Num a, Foldable t) => t a -> a
19:15:32 <Cale> case expressions are sort of like switch statements
19:15:34 <scshunt> ugh
19:15:41 <scshunt> typeclasses ruin evertyhing
19:15:50 <jknight> like switch "this" case 1 case 2, etc
19:15:54 <scshunt> yeah
19:16:15 <scshunt> > case (1 + 1) of { 1 -> "wrong"; 2 -> "right" }
19:16:16 <lambdabot>  "right"
19:16:17 <jknight> Has anyone ever made a game in your language?
19:16:20 <scshunt> yep!
19:16:24 <jknight> Really?
19:16:26 <scshunt> my current hobby project is a game
19:16:37 <jknight> How long you been working on it?
19:16:53 <EvanR> there is an IRC channel dedicated to haskell video gaming
19:16:56 <michaelt> > let jknight n = case n of 15 -> 10000000; _ -> n in map jknight [10..20]
19:16:57 <lambdabot>  [10,11,12,13,14,10000000,16,17,18,19,20]
19:17:08 <scshunt> About four months, here and there.
19:17:09 <EvanR> since it needs one ;)
19:17:22 <jknight> I'm so lost lol
19:17:29 <scshunt> Mostly I've been working on the infrastructure
19:18:05 <scshunt> jknight: so, functional programming is built a lot around using functions as values, which you see a lot in modern JavaScript and very rarely in C
19:18:07 <jknight> Im torn, I started coding to make games only to have my dreams become stalled because I suck at coding lol
19:18:39 <jknight> I mean I know a little lingo but I haven't really mastered it
19:18:40 <scshunt> jknight: the map function applies a function to each element of a list and produces a new list, it's one of the simplest functions that do this
19:18:50 <scshunt> > map (+ 3) [1, 3, 5, 7]
19:18:52 <lambdabot>  [4,6,8,10]
19:19:03 <jknight> a function that gives stuff other functions and makes a list?
19:19:22 <scshunt> It takes a function and a list and produces a new list
19:19:33 <michaelt> jknight: if its given a list it gives a new list back, but applies the function
19:19:40 <jknight> Ah oj
19:19:46 <jknight> it converts it with the function
19:19:46 <nitrix> jknight: Think of a group of elements of type `f`, it applies a transformation from `a` to `b`to those, so you get the same group but transformed into `b`'s.
19:19:50 <scshunt> exactly
19:20:02 <michaelt> > map reverse ["hello", "world"]
19:20:04 <lambdabot>  ["olleh","dlrow"]
19:20:04 <nitrix> Err, replace `f` by `a`, typo.
19:20:15 <michaelt> > reverse ["hello", "world"]
19:20:17 <lambdabot>  ["world","hello"]
19:20:17 <jknight> hahaha thats cool
19:20:22 <jknight> it makes sense
19:20:42 <EvanR> its that easy (tm)
19:20:44 <jknight> ohhh and it doesn't just reverse the order of the words
19:20:47 <jknight> but the letters too
19:20:52 <jknight> haha
19:21:02 <scshunt> In Haskell, strings are just lists of characters
19:21:16 <scshunt> so list functions work as well on them as on any other list
19:21:32 <EvanR> > map chr [40,50,60,70]
19:21:33 <lambdabot>  "(2<F"
19:21:54 <jknight> I worked a tiny bit with strings in a game I built but it was only for the menu
19:21:55 <EvanR> > map ord "fruit"
19:21:56 <lambdabot>  [102,114,117,105,116]
19:22:08 <scshunt> Programming using higher-order functions like this is a lot of fun and produces concise code, but it can be challenging at first
19:22:26 <EvanR> it really helps factoring out repetitive code
19:22:38 <nitrix> jknight: I'm working on a game in Haskell, but if you're serious about Haskell, try investing time into learning it properly.
19:22:57 <EvanR> "things i wish i knew before trying to write a game in haskell"
19:23:08 <scshunt> With any programming language, really the only thing that can be said is to dig into it and learn to use it
19:23:17 <nitrix> jknight: If you always go for the short-term gratification of "I need this for my game, my game, the game, game", you'll just turn a really good opportunity into a bad experience.
19:23:28 <jknight> True
19:23:48 <EvanR> alternatively you can get caught up in a framework or engine and never end up making the game
19:24:01 <scshunt> jknight: What sort of game do you want to be able to make? 3D or 2D? Real-time or turn-based?
19:24:02 <jknight> I hear engines take forever to make
19:24:12 <jknight> 2D like final fantasy 6
19:24:22 <EvanR> in C gaming i always recommend keeping enginey stuff to a minimum
19:24:31 <EvanR> do the game
19:24:53 <EvanR> but thats because C
19:25:15 <scshunt> jknight: 3D engines take forever
19:25:42 <nitrix> jknight: I'm not saying this to discourage you; I'm myself writing a game in Haskell; but that project was born after I had already some basics I knew I'd use this to challenge me further.
19:25:53 <jknight> Well I just want a decent 2D one and true
19:26:21 <EvanR> gloss is a library for haskell that can get you started with a game with graphics and input really fast
19:26:40 <nitrix> EvanR: I'm not claiming otherwise.
19:26:43 <jknight> Could it do something like "collisions"?
19:26:48 <nitrix> I think I'm explaining my point wrong.
19:26:57 <EvanR> i was just informing jknight about gloss
19:27:07 <EvanR> jknight: nope, just graphics and input
19:27:12 <scshunt> jknight: depending on what you want, you might want take a look at http://learnyouahaskell.com/. it's a very fast introduction to the language, but it's not very hands-on
19:27:32 <EvanR> there are fuller game engines available but im not sure about their reliability
19:27:56 <scshunt> http://book.realworldhaskell.org/ is also good; it's more about building real applications
19:27:58 <Sinestro> Well, there're two different philosophies about learning a language... Either read something like LYAH that'll help you get the very basics down and then dive into the weeds of a project, or a slower, more involved process of learning before you start a 'real' project
19:28:01 <EvanR> speaking of hands on
19:28:03 <EvanR> jknight: https://tryhaskell.org/
19:28:07 <jknight> Wait so C isn't a "functional" programming language?
19:28:30 <nitrix> Sinestro: Would you recommend anyone to rush learning Haskell to jump into game development?
19:28:40 <scshunt> jknight: No. It's an imperative programming language.
19:29:07 <scshunt> jknight: A functional programming language is primarily defined by its reliance on small, lightweight functions passed around to perform computations
19:29:14 <Sinestro> If they are willing to adjust their expectations on how long it'll take to get started and how many mistakes they'll go back and fix once they know better, sure!
19:29:17 <nitrix> scshunt: No.
19:29:22 <scshunt> nitrix: no?
19:29:32 <nitrix> scshunt: It's defined by first-class functions. That is all.
19:29:55 <EvanR> FP is not really "defined"
19:29:58 <scshunt> nitrix: I disagree, but I don't want to sidetrack the conversation right now :)
19:29:59 <nitrix> It's the only definiton of functional. People attached ideologies to it, but it doesn't fit the definition.
19:30:01 <jknight> I'm willing to invest some time but I wanna know what I could do after learning this and I was told to be a good game dev I need trigonometry
19:30:22 <EvanR> no one agrees on the definition, its like OOP ;)
19:30:36 <EvanR> only better
19:30:37 <scshunt> jknight: it depends on exactly what you want to do with your engine, really. But any amount of computer programming requires math at a point.
19:31:11 <jknight> Is functional programming better for making games?
19:31:12 <nitrix> I'll gladly argue in private with anyone that is willing to contredict that FP isn't about first-class functions.
19:31:23 <nitrix> I'll dedicate my night to them.
19:31:24 <Sinestro> In some ways.
19:31:26 <scshunt> jknight: I think it really depends on the sort of game.
19:31:27 <Sinestro> It's worse in others.
19:31:27 <slack1256> A functional of a space X is a function of type (X -> R) -> R, I mainly take this as to functions that take function
19:31:34 <jknight> An rpg
19:31:49 <jknight> that has calculations, item stats, etc.
19:31:53 <EvanR> jknight: here is some example code for doing game related math, it solves for when a point crosses a moving line segment, with notes http://lpaste.net/164565
19:32:02 <EvanR> its not really trig, more like vector math
19:32:07 <EvanR> and basic algebra
19:32:18 <Sinestro> Really, the best way to do anything that involves input over time is going to at least look pretty functional, and games have a lot of that in them
19:32:26 <Cale> I think that functional reactive programming will eventually be regarded as essential to game development.
19:32:28 <Rotaerk> with stack, is there some quicker way to build-and-run my program besides:  stack build && stack exec <executable>
19:32:34 <scshunt> Functional programming has the advantage that the flow can more closely reflect the abstract steps you do to process things
19:32:41 <Rotaerk> well, more concise
19:32:42 <jknight> holy crap I only get the very bottom part of that code
19:32:52 <scshunt> jknight: first bit's all comments
19:32:55 <scshunt> -- is a comment line
19:33:00 <jknight> and i don't know which is a function and which is the variable
19:33:28 <Rotaerk> the only variables are the parameters of functions :P
19:33:35 <Sinestro> Well, that's what you have to learn to read, but once you start to break your brain into the right shape, it'll all click into place.
19:33:35 <jknight> are the green ones functions?
19:33:36 <Rotaerk> and type args
19:33:46 <scshunt> The big disadvantage to functional programming, in my opinion, is that it abstracts you away from the computer. If what you're doing requires working close to the computer (highly performance sensitive, need to interact with hardware, or the like), then it's more difficult
19:34:00 <scshunt> jknight: the lines with the double colon :: are type annotations
19:34:04 <EvanR> jknight: blue is functions
19:34:10 <Rotaerk> fortunately haskell can do imperative stuff too
19:34:14 <jknight> would a game be classified in that scshunt?
19:34:32 <Sinestro> But it's pretty easy to call out to C from Haskell, so it's not hard to have the 'core' of the game engine in C and make Haskell tell it what to do
19:34:38 <scshunt> jknight: It depends on the game, I think. In my case, I'm implementing a board game so there's a lot of processing logic and not much interface
19:34:41 <jknight> this is a very mathy piece of code
19:34:48 <scshunt> but I wouldn't personally want to write a 3D game engine in Haskell
19:35:00 <scshunt> (so I probably would to challenge myself :P)
19:35:04 <EvanR> jknight: right, but no sin or cos in sight ;)
19:35:07 <Sinestro> I'm writing a 3D engine from absolute scratch (pretty much nothing but Prelude and a few basic libraries, but nothing really on topic) and it's been quite interesting and illuminating
19:35:26 <jknight> all of the stuff i learned in my last math class.....useless
19:35:34 <Sinestro> no, it's far from useless
19:35:36 <jknight> stupid triangles
19:35:41 <Sinestro> it's just not universal
19:35:54 <Sinestro> although you don't really need all the identities and shit
19:35:57 <EvanR> you need to understand trig
19:36:06 <Sinestro> you just need to 'get' it
19:36:18 <Sinestro> CAS can do the rest ;)
19:36:32 <jknight> what is cas?
19:36:39 <Sinestro> Computer Algebra System
19:36:41 <jknight> oh
19:36:47 <Sinestro> WolframAlpha is probably the easiest one to use
19:36:49 <EvanR> from trig you can get to vector math, which is much better ;)
19:36:52 <scshunt> Sinestro: I guess I should be more clear. I'd be happy to do the math bit in Haskell. I don't want to have to interact with the GPU
19:37:10 <jknight> why do you not like the gpu?
19:37:27 <Sinestro> Because it's very much not like the (fictional) model of computation that Haskell uses.
19:37:31 <scshunt> ^
19:37:45 <Sinestro> But you can deal with it through nicer interfaces, like OpenGL
19:38:11 <Sinestro> And bindings for that are part of the Platform (not that anyone cares about that any more)
19:38:11 <jknight> This deals with graphics right?
19:38:13 <Sinestro> Yeah
19:38:35 <scshunt> jknight: that code he linked is to solve collision detection for uniform (that is, unchanging) motion
19:38:37 <Sinestro> I'd suggest trying to do it all in Haskell in software without leveraging the GPU first, so you get how it works
19:38:41 <scshunt> specifically between a point and a line
19:39:04 <Sinestro> But then again, I'm a computing masochist
19:39:06 <jknight> wait it can do collision checks? like if i say in haskall "thats a wall" it'll be like "okay don't go past it"?
19:39:16 <EvanR> thats what the code is for
19:39:20 <Sinestro> Once you tell it what a wall is and what going past it is, sure!
19:39:37 <Sinestro> Also tell it what you want to happen when it tries, of course
19:39:41 <scshunt> the comments explain the math behind it
19:39:43 <jknight> that sounds strangely easier but i have a feeling telling it what it is aint easy
19:39:58 <merijn> Sinestro: lol
19:40:07 <merijn> Sinestro: "nicer interfaces" "OpenGL"
19:40:14 <EvanR> a wall is a line segment, and going past it is when that thing returns something besides NoSolutino ;)
19:40:31 <scshunt> EvanR: is a NoSolutino some sort of elementary geometric particle? :P
19:40:35 <EvanR> yes
19:40:37 <jknight> NoSol? 
19:40:37 <Sinestro> Nicer than trying to reverse engineer the interface
19:40:46 <scshunt> jknight: look at line 66
19:40:58 <zq> aw hell yeah overloadedrecordfields
19:41:00 <scshunt> it defines a new type called Solution
19:41:31 <scshunt> NoSolution, OneSolution, and TwoSolutions are what we call "data constructors". Basically they are names for the values that exist in the type.
19:41:56 <jknight> the type would be the data type?
19:42:03 <scshunt> yeah
19:42:11 <jknight> sorta like bools and floaters
19:42:14 <scshunt> yep
19:42:16 <jknight> and strings
19:42:16 <scshunt> @src Bool
19:42:16 <lambdabot> data Bool = False | True deriving (Eq, Ord)
19:42:28 <jknight> hahah now that makes sense at least the first half
19:42:53 <categoryTheoreti> Does anyone know how I could add cloned git repo as a dependancy to a project in stack?
19:42:55 <scshunt> the second half says that it is an instance of Eq, so you can compare Bool for equality, and Ord, so you can do order comparisons like <=
19:43:08 <EvanR> Solutions 3 cases written this way is more convenient thant something like {"oneSolution":3.14} in javascript
19:43:17 * hackagebot concurrent-machines 0.2.3 - Concurrent networked stream transducers  https://hackage.haskell.org/package/concurrent-machines-0.2.3 (AnthonyCowley)
19:43:19 <scshunt> jknight: a more complicated example might be something like
19:43:21 <scshunt> @src Maybe
19:43:22 <lambdabot> data Maybe a = Nothing | Just a
19:43:22 <EvanR> or {"twoSolutions":[3,14, 1.59]}
19:43:45 <scshunt> Maybe has a type parameter a
19:43:55 <jknight> oh
19:43:59 <scshunt> so Maybe isn't a type; you need to add another type to it like Int to make Maybe Int
19:44:28 <scshunt> Nothing has no arguments, so Nothing is just Nothing (no pun intended). But Just has an argument of type a, so it includes a value
19:44:31 <scshunt> e.g.
19:44:34 <scshunt> > Just 4 :: Maybe Int
19:44:35 <lambdabot>  Just 4
19:44:40 <scshunt> > Nothing :: Maybe Int
19:44:41 <lambdabot>  Nothing
19:44:58 <scshunt> (a :: t) is "value a with type t"
19:44:59 <Sinestro> It's kind of like Maybe<T> in C++/C#/Java
19:45:34 <EvanR> {"just":4} {"nothing":null}
19:45:52 <EvanR> (poor mans algebraic data types)
19:46:00 <jknight> just returns 4 nothing returns null?
19:46:10 <EvanR> no thats json
19:46:14 <EvanR> off topic
19:46:19 <EvanR> i thought you knew js
19:46:31 <jknight> not really
19:46:36 <jknight> only a tiny bit
19:46:38 <scshunt> jknight: Maybe is used like nullable types
19:46:50 <scshunt> since it's either a value or Nothing
19:47:21 <scshunt> Haskell's type system enforces that you can't have a value of a different type, so you always have to be explicit about whether or not you'll accept a Maybe
19:47:29 <scshunt> if I try to break that, I get a compiler error:
19:47:32 <scshunt> > Nothing + 4
19:47:33 <lambdabot>      No instance for (Show a0)
19:47:33 <lambdabot>        arising from a use of â€˜show_M60766980362041690903482â€™
19:47:33 <lambdabot>      The type variable â€˜a0â€™ is ambiguous
19:47:47 <scshunt> ... normally a better compiler error than that
19:47:56 <EvanR> > Nothing + 4 :: Int
19:47:57 <lambdabot>      Couldn't match expected type â€˜Intâ€™ with actual type â€˜Maybe a0â€™
19:47:57 <lambdabot>      In the first argument of â€˜(+)â€™, namely â€˜Nothingâ€™
19:47:57 <lambdabot>      In the expression: Nothing + 4 :: Int
19:48:38 <EvanR> type inference determined that your wrote an expression that is both a Maybe t for some t and Int
19:48:41 <EvanR> which is impossible
19:49:14 <scshunt> jknight: My best suggestion for writing any sort of thing is start out small
19:49:19 <scshunt> Don't try to write a complete RPG from the get-go
19:49:33 <scshunt> Try to pick something nontrivial but still interesting, like maybe a basic battle system for instance
19:49:43 <jknight> A battle system sounds fun
19:49:52 <scshunt> once you're done, you'll almost certainly want to scrap it and rewrite it, no matter what you wrote it in
19:50:13 <scshunt> (this is pretty much true of any time you start working with a new tool)
19:50:16 <jknight> How many programming languages should I learn?
19:50:31 <carterhinsley> none
19:50:36 <carterhinsley> get what you need to get done, done
19:50:42 <carterhinsley> stop worrying about irrelevant questions
19:51:05 <scshunt> If you want to write a game, just the one you use to write it. I like learning new languages for the fun of it, but it's really up to you
19:51:13 <scshunt> But I rarely finish any coding projects
19:51:17 <carterhinsley> focus on your personal finances instead
19:51:56 <carterhinsley> by knowing a language you're no better than anyone else; just do what makes you happy
19:52:20 <scshunt> ^
19:52:24 <EvanR> when jupiter enters leo pay special attention to your relationship
19:52:36 <carterhinsley> lol
19:52:48 <merijn> What if being better than others makes you happy?
19:52:53 <carterhinsley> im pretty sure if jupiter entered leo we'd be /inside/ jupiter
19:52:53 <scshunt> especially since it sounds like you have some time to go before you might be considering a job in programming
19:53:03 <EvanR> merijn: NoSolution
19:53:32 <scshunt> jknight: I'd link some of my game code, except it's all very abstract and there's very little actual logic in it
19:53:45 <carterhinsley> merijn: then either seek therapy or expect to get shanked in prison after your sociopathy fully develops
19:53:56 <EvanR> theres never any logic in game programming
19:54:06 <jknight> I'm not trying to be better than anyone else but I want to learn more about programming
19:54:26 <scshunt> EvanR: try prolog
19:54:36 <EvanR> game programming in prolog
19:54:38 <carterhinsley> jknight: then what's important can be conveyed by more explicit questions
19:54:52 <scshunt> best way to get better at programming is to code
19:54:56 <carterhinsley> not "how many languages should i learn" but rather "what languages provide interesting or good ways to solve problems like X?"
19:55:20 <carterhinsley> best way to get better at programming is to gain experience and develop the habit of reading books
19:55:31 <carterhinsley> also get into competitions, make a career, get a mentor
19:55:36 <scshunt> reading books is pretty sweet
19:55:39 <scshunt> I also recommend learning math
19:55:48 <carterhinsley> this is the secret to life
19:55:48 <carterhinsley> enjoy
19:55:53 <scshunt> real math, not the approximation that they throw you into in high school
19:56:11 <jknight> You mean trigonometry and vector?
19:56:23 <carterhinsley> all maths
19:56:24 <EvanR> hell yeah, and quaternions!
19:56:40 <carterhinsley> most fields of mathematics are applicable to most areas of life
19:56:42 <EvanR> youll get sucked into abstract algebra
19:57:00 <scshunt> jknight: Mathematical proof, in particular.
19:57:00 <jknight> Alright then I'll do it
19:57:03 <doubling> im a hilbert space
19:57:07 <doubling> suck my compact balls
19:57:17 <scshunt> jknight: do you like problem-solving?
19:57:25 <jknight> Yes
19:57:50 <scshunt> have you ever seen Euclid's proof that there are infinitely many prime numbers?
19:57:58 <jknight> No
19:58:07 <jknight> I've heard of a Euclid
19:58:52 <scshunt> Suppose that there aren't, that there are only finitely many. Then you could multiply them all together and you'd get a really big number. But if you added one to that number, then it wouldn't be divisible by any of those numbers.
19:59:20 <scshunt> because a*b + 1 is not divisible by a or b (if a and are at least 2)
19:59:23 <carterhinsley> jknight: there are good historical fiction books about math that can give you some nice perspective
19:59:28 <carterhinsley> Logicomix is great
19:59:49 <scshunt> this new number isn't divisible by any prime number... but that makes it prime! That's a contradiction!
19:59:57 <carterhinsley> i'd recommend that first, then you can have sort of an emotional connection to the various mathematicians from the 19th/20th centuries
19:59:58 <scshunt> So there are actually infinitely many prime numbers.
20:00:08 <carterhinsley> so you won't feel so lost
20:00:55 <doubling> scshunt: what do you mean, a completed infinity or a potential infinity
20:01:14 <scshunt> doubling: âŠ¥
20:01:48 <Rotaerk> hmm, in C#, if you catch (Exception ex) { throw ex; }, it wipes the stack trace and makes it look like THAT is the origin of the exception, whereas if you use { throw; } it doesn't...
20:01:56 <doubling> and just because you get a contradiction from "finite primes" doesn't mean you get infinitely many primes
20:02:00 <Rotaerk> is there a similar distinction for any two throwing options in haskell?
20:02:13 <EvanR> thats the classical argument
20:02:25 <doubling> classical "logic" is illogical
20:02:32 <EvanR> all you need to do is construct a bijection between the primes and the naturals
20:03:08 <scshunt> doubling: it does in ZFC, taking the law of the excluded middle
20:03:48 <scshunt> every set has a cardinality, prime numbers are a set, they don't have finite cardinality, therefore they have an infinite one.
20:03:53 <EvanR> or an injection from the primes to a proper subset of itself
20:04:02 <carterhinsley> Since TensorFlow only exposes a C++ API, should I need to write a C 'glue' wrapper for it in order to write a binding for Haskell?
20:04:13 * carterhinsley has not played with the Haskell FFI much
20:04:20 <scshunt> EvanR: my personal favourite is proving that \sum_{p prime} 1/p is divergent
20:04:53 <scshunt> the proof is rather contrived
20:04:55 <EvanR> i guess that would do it
20:05:08 <geekosaur> carterhinsley, yes
20:05:55 <geekosaur> while there is finally a standard of sorts for C++ binding, it doesn't help  much when a binding includes templates. so you still need to map the API down to something that C can handle
20:06:26 <carterhinsley> Hrm. I've heard that TensorFlow is very usable from C, but can't find any explicit information on it
20:06:33 <scshunt> jknight: anyway
20:06:46 <jknight> yes
20:06:48 <carterhinsley> search engines being unable to differentiate C vs C++ is really shitty.
20:06:50 <scshunt> jknight: if you find any of this math conversation remotely interesting, you should definitely look at real math :)
20:07:05 <geekosaur> that may mean it already exports a C-compatible interface, in which case you can use FFI with that
20:07:08 <scshunt> carterhinsley: that's why Google special-cases trailing +
20:07:09 <EvanR> or discrete math
20:07:22 <carterhinsley> jknight: if you find it stupid and pretentious, you should also look at real math
20:07:26 <scshunt> hahaha
20:07:27 <jknight> It is interesting but I need to study to understand it
20:07:30 <scshunt> definitely
20:07:42 <doubling> scshunt: lol you use an inconsistent theory to prove a false thm
20:07:53 <carterhinsley> (because yes it's circle-jerking and yes it's annoying to outside observers whether they understand it or not)
20:07:55 <scshunt> doubling: you're asserting that ZFC is inconsistent now?
20:08:04 <carterhinsley> (but it's very useful knowledge)
20:08:07 <jknight> Its both lol
20:08:18 * hackagebot Frames 0.1.3 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.1.3 (AnthonyCowley)
20:08:26 <scshunt> hmm
20:08:28 <carterhinsley> make a habit of reading though
20:08:40 <scshunt> jknight: have you worked with matrices at all?
20:08:44 <EvanR> math is awesome for exactitudity
20:08:51 <jknight> Nope haven't even heard of a matrice
20:09:04 <merijn> jknight: singular of matrices is matrix
20:09:12 <jknight> awesome movie
20:09:34 <jknight> So its the plural
20:09:35 <scshunt> hmm
20:09:42 <scshunt> trying to think of good resources for getting into math
20:09:44 <jknight> 1 matrix many matrices
20:09:50 <EvanR> [1 0
20:09:52 <EvanR>  0 1]
20:09:55 <carterhinsley> scshunt: Logicomix
20:09:59 <mniip> just imagine a linear transofrmation in a fixed basis
20:10:01 <mniip> *leaves*
20:10:07 <carterhinsley> Khan Academy
20:10:26 <scshunt> Khan academy is probably a good idea, especially if you prefer videos to reading
20:10:43 <carterhinsley> reading math prose is not fun
20:10:59 <scshunt> I agree, but I know some who prefer it
20:11:12 <carterhinsley> unless the author is talented. and usually, given the bureaucratic nature of publishers/editors, that talent either isn't there or gets stunted
20:11:31 <carterhinsley> there's much more to learn from reading because of the amount of written information compared to video content
20:11:49 <carterhinsley> but khan academy will keep you occupied and might foster a love for the subject
20:12:09 <scshunt> I don't know which Khan Academy videos are good introduction to real math and not just high school math though
20:12:12 <EvanR> and the speed of video delivery
20:12:23 <scshunt> Axler and Spivak are both great introductions to their respective subjects, but they are probably a bit more specific than I'd recommend
20:12:43 <scshunt> (http://linear.axler.net/ and http://www.amazon.com/Calculus-4th-Michael-Spivak/dp/0914098918, respectively)
20:13:16 <EvanR> jknight there is also a book available, Mathematics for 3D Game Programming and Computer Graphics, Third Edition
20:13:18 <jknight> Linear Algebra and Calculus
20:13:25 <jknight> I want that one
20:13:27 <jknight> well
20:13:29 <jknight> yea i do
20:13:35 <EvanR> it has a badass skeleton on the cover so it must be good
20:13:46 <jknight> lol haha
20:13:52 <jknight> don't judge a book by its cover
20:13:59 <jknight> I understand that
20:14:32 <scshunt> I liked the 3rd edition of Spivak better. It had a coin on the cover
20:14:52 <Cale> My 3rd edition is plain grey
20:15:23 <jknight> ill do khan for now
20:15:34 <buttons840> Spivak? is that a calculus book?
20:15:42 <jknight> but i will get to reading too
20:15:45 * buttons840 joined half way through conversation
20:16:00 <scshunt> buttons840: yes
20:16:04 <scshunt> mine has cover http://ecx.images-amazon.com/images/I/51Yga3QmJWL._SX258_BO1,204,203,200_.jpg
20:16:20 <scshunt> jknight: maybe try the "Math for fun and glory" section
20:16:34 <buttons840> well, if I can't do calculus, at least I can know the authors of the texts books :)
20:18:38 <jknight> If you were in my shoes which would you learn first objectively speaking. Calculus or Trigonometry?
20:20:06 <scshunt> Calculus
20:20:35 <EvanR> Geometry
20:21:36 <scshunt> All the really interesting stuff you can do with trigonometry comes about with calculus. If you do actual problem-solving with geometry that is cool and a nice, light introduction
20:22:00 <jknight> well then calculus
20:22:08 <jknight> time to get acquaint
20:22:12 <jknight> acquianted
20:22:13 <scshunt> but imo the high school stuff that they teach for trig specifically is just crap
20:22:16 <buttons840> jknight: what is your goal?
20:22:37 <scshunt> it's eventually useful, but knowing all your trig identities isn't much use early on
20:23:23 <jknight> Originally just to make a cool rpg 2d dungeon crawler game and I thought it wouldn't be super difficult early on but man was i wrong.
20:23:42 <EvanR> trig is good when vector math starts through random sins and cosines at you, you will be familiar
20:23:50 <EvanR> sin 0 = 0, cos 0 = 1
20:24:02 <EvanR> sin 45deg = 0.707
20:24:10 <EvanR> throwing*
20:24:27 <jknight> I'm gonna do calculus since it seems like a good starting point
20:24:28 <rfw> i know this sounds weird, but is there a version of foldr where i can change the list it's folding over?
20:24:34 <rfw> while it's doing the fold, i mean
20:24:42 <scshunt> jknight: I can assure you you don't directly need calculus for a game engine :)
20:25:14 <scshunt> But if you learn calculus from a very good treatment like Spivak, then what it teaches you about thinking is invaluable both in math and programming
20:25:21 <EvanR> i just dug this up yesterday: you can read how sonic the hedgehog works, its not really calculus http://info.sonicretro.org/Sonic_Physics_Guide
20:25:23 <jknight> Ughhh but you said it helps with trig
20:25:35 <rfw> i guess what i mean is, a version of fold where i can pick the next list to continue folding for
20:25:42 <jknight> Gotta go fast.....
20:26:39 <scshunt> jknight: You don't need too much trigonometry for a 2d engine
20:26:48 <jknight> oh
20:26:55 <scshunt> it's more pure geometry
20:27:07 <scshunt> (though that invariably will involve some trig)
20:27:27 <scshunt> I'm a math major, and trigonometry isn't even a discipline of math
20:27:46 <scshunt> the trig they teach you in high school is just a bunch of techniques to solve equations that involve the trig functions
20:28:15 <jknight> Well I'm sorta out of highschool I'm going to college
20:28:19 * hackagebot roundRobin 0.1.1.0 - A simple round-robin data type  https://hackage.haskell.org/package/roundRobin-0.1.1.0 (winterland)
20:28:37 <scshunt> jknight: ah, cool. Wasn't sure, but it sounded like you haven't taken a college class yet
20:28:46 <jknight> I haven't actually lol
20:28:49 <scshunt> :)
20:28:51 <jknight> I start this summer
20:29:06 <scshunt> high school math is depressingly consistently poor :P
20:29:17 <scshunt> let's move to PM if that's all right?
20:29:24 <scshunt> I think the others would like to get back to haskell :P
20:29:32 <jknight> After learning how to make a small short simple game with really simple code I got interested in programming
20:29:38 <jknight> oh ok
20:29:39 <jknight> sorry
20:35:43 <vcxr> man i wish either or both ghcjs or purescript were about 5 years further along in development
20:48:20 * hackagebot pseudo-boolean 0.1.5.0 - Reading/Writing OPB/WBO files used in pseudo boolean competition  https://hackage.haskell.org/package/pseudo-boolean-0.1.5.0 (MasahiroSakai)
20:49:27 <slack1256> I thought the deal with types is that they lived on levels that didn't interact with each others
20:49:40 <slack1256> otherwise it was Set theory and the usual paradoxes apply
20:49:58 <slack1256> So for my dependent type look weird. Where is my misconception?
20:50:29 <slack1256> I kind of understand pi-types and stuff, but I also see it coming full cicle
20:56:29 <EvanR> slack1256: yeah, theres no type of all types
20:56:43 <EvanR> including itself
20:56:51 <EvanR> unless you do -XTypeInType
20:57:15 <geekosaur> "uh oh"
20:58:09 <johnw> slack1256: there are also impredicative types, which can contain themselves
20:58:14 <merijn> slack1256: Calculus of Constructions (the usual basis for dependent types) has an infinite hierarchy of types
20:58:58 <slack1256> merijn: yep, but doesn't each level n can only be refered by the level n + 1?
20:59:32 <johnw> each level n can be contained by a type > n, for the usual predicative types
20:59:34 <slack1256> a dependent function affects from the level n the level n + 1, so it's kind of destroying my misconception of type hierarchy as structural sets
21:01:12 <johnw> slack1256: what is the actual question?
21:02:05 <slack1256> how are compatible the notion of "hierarchy of level that referee to the levels below only" and "function that affect the upper level" compatible
21:02:23 <johnw> what do you mean by "function that affect the upper level"?
21:02:28 <slack1256> sorry, I don't know how to put it more succintly, I am kind of confused because I don't know the formalism
21:02:42 <slack1256> "function that affect the upper level" -> a dependent function
21:02:59 <johnw> are you asking how pi-types fit into the scheme of type universes?
21:03:33 <slack1256> yes (you put it better :-D )
21:03:52 <johnw> if you turn on explicit universes in Agda, this should all become clear by writing a few sample functions
21:06:32 <slack1256> Cool, I will launch a nix-shell then
21:07:05 <johnw> this is one specific thing that Agda is much better at than Coq; although Coq has universes, and you can even print them, you can't interact with them directly the way you can with Agda
21:15:34 <geppettodivacin> I'm working with conduits, and I ran into a strange case that required Rank2Types. I'm not sure why adding an argument would make this extension required. Any ideas? http://lpaste.net/164568
21:17:20 <geppettodivacin> I know I'm not using the Handle yet, but I wanted to figure out the types first.
21:17:50 <codebje> the second type in the sig likely has a quantifier
21:18:09 <codebje> http://haddock.stackage.org/lts-5.15/conduit-1.2.6.4/src/Data-Conduit-Internal-Conduit.html#Producer
21:18:14 <codebje> :t Producer
21:18:16 <lambdabot>     Not in scope: data constructor â€˜Producerâ€™
21:18:16 <lambdabot>     Perhaps you meant â€˜Productâ€™ (imported from Data.Monoid)
21:18:21 <codebje> :t Data.Conduit.Producer
21:18:22 <lambdabot>     Not in scope: data constructor â€˜Data.Conduit.Producerâ€™
21:18:27 <codebje> type Producer m o = forall i. ConduitM i o m ()
21:18:38 <geppettodivacin> Oh, OK. I didn't realize that it was so general.
21:19:15 <codebje> I have heard a critique of conduit that it's more general than the problem space seems to require
21:19:27 <codebje> but I'm not really able to judge that critique terribly well myself :-)
21:20:07 <geppettodivacin> It works pretty well for the messing around I'm doing right now. :-P
21:21:24 <geppettodivacin> Also, while I've got that piece of code out there, is there a better way to use binary and ByteString IO to pull in only the bytes I need to decode as opposed to using hGetContents and (semantically) pulling in the entire file?
21:21:54 <EvanR> pipes, conduit, iteratee
21:22:15 <EvanR> a damn forkIO thread doing C in any language
21:22:38 <geppettodivacin> I'm already using conduit, but I don't know how to make it efficient.
21:22:56 <codebje> Data.Conduit.Binary.sourceHandle ?
21:22:59 <geppettodivacin> I figure I could pull a byte at a time until bytes stop being requested, but that doesn't sound very efficient.
21:23:18 <geppettodivacin> codebje: Let me look at that real quick.
21:24:39 <geppettodivacin> Yeah, actually those look like exactly what I was trying to hack together myself. Thanks!
21:26:05 <codebje> there's a more general variant in conduit-combinators
21:26:38 <EvanR> instead of 1 Byte ByteString at a time, you could change it to 1 Word8 at a time
21:27:04 <johnw> Producer is the general form
21:27:11 <johnw> I believe that Source is the concrete form
21:27:19 <geppettodivacin> Yeah, it is.
21:27:29 <johnw> because a Producer could also be the output end of a Conduit
21:28:22 * hackagebot wai-routes 0.9.8 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.8 (AnupamJain)
21:28:52 <geppettodivacin> johnw: Is there any reason you would *want* a Producer at the end of a Conduit?
21:29:26 <johnw> so that you can use it with $=
21:29:32 <johnw> to make another Conduit
21:29:51 <geppettodivacin> That would just ignore all of its input, right?
21:30:06 <johnw> it would be a Conduit that would expect another Producer to be joined to it
21:30:13 <johnw> think puzzle pieces here
21:30:22 <johnw> a Source and a Conduit both have a similarly shaped connecty end
21:30:28 <johnw> as do a Sink and a Conduit
21:30:39 <johnw> hence, Producer and Consumer
21:30:47 <johnw> pipes does this exact same trick
21:31:52 <geppettodivacin> So, But what would something like "producer1 $= producer2 $= sink" even do with the output generated from producer1?
21:32:14 <johnw> i think we disconnected somewhere
21:32:19 <codebje> geppettodivacin, the forall. in the type means it can't vary behaviour based on the _type_ of the input, but it could count input, filter input based on position in stream, etc
21:32:25 <johnw> in that case, producer2 could be a conduit
21:32:42 <johnw> I'm pretty sure =$= is an optional thing these days
21:33:36 <geppettodivacin> Hmm. codebje, would the second producer have to yield in order to count them? Since it's a Conduit, I suppose it technically could.
21:34:51 <geppettodivacin> Although at the point that I would use a Producer to count something from upstream, I would just turn it into a normal Conduit.
21:35:05 <johnw> but if you're a library writer, and a not a user, you'd want generality
21:35:13 <johnw> to avoid having to write the same thing twice for the two use cases
21:35:38 <scshunt> codebje: you can totally vary behaviour based on the type of input
21:35:47 <geppettodivacin> Hmm. I might look more into that tomorrow. I think I should probably get some sleep before I think too hard on this.
21:35:55 <geppettodivacin> Thanks, guys!
21:38:57 <codebje> scshunt, in a Producer?
23:18:59 <mucky> nice to meet everyone
23:21:08 <srhb> mucky: o/
23:25:24 <liste> mucky: nice to meet you
23:26:08 <mucky> liste: how are you
23:27:35 <liste> mucky: fine, thank you.
23:27:58 <mucky> how long have you been learning haskell?
23:28:19 <simpson> Years.
23:29:04 <liste> a few years
23:29:09 * EvanR looks at tickmarks etched into the wall
23:29:56 <mucky> ah, i've been learning for a day, it's my first language
23:30:24 <liste> mucky: great! how's it been?
23:31:21 <mucky> pretty enjoyable so far, i haven't actually been able to do anything with it yet but I'm enjoying it more than that time I tried to learn C++
23:32:01 <mucky> and by try to learn i mean i picked up a book on it at a bookstore and put it back on the shelf
23:34:41 <liste> mucky: what's your background?
23:36:01 <mucky> i made a bunch of video games in middle school, became reinterested in programming because i'm a 19 year old community college student that thinks that if i'm going to spend most of my time at a computer, it might as well be something useful
23:36:23 <simpson> Don't worry about "useful". Do what you want to do.
23:46:04 <ssmith> Apparently I cant rename files? `renameFile: unsupported operation (Invalid cross-device link)`
23:46:52 <ssmith> PS; My home directory is in another partition to /tmp
23:48:53 * selckin renames his file to ssmith harddrive over magic
