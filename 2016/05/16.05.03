00:00:31 <M2tias> >(0/0)
00:00:42 <M2tias> > (0/0)
00:00:43 <lambdabot>  NaN
00:00:48 <M2tias> > (1/0)
00:00:49 <lambdabot>  Infinity
00:00:58 <Zemyla> > 5.0 > (0/0 :: Rational)
00:01:00 <lambdabot>  *Exception: Ratio has zero denominator
00:01:30 <M2tias> > (1/(1/0))
00:01:31 <lambdabot>  0.0
00:02:04 <zRecursive> weird
00:07:39 * hackagebot monad-unlift-ref 0.2.0 - Typeclasses for representing monad transformer unlifting  https://hackage.haskell.org/package/monad-unlift-ref-0.2.0 (MichaelSnoyman)
00:07:39 * hackagebot yesod-job-queue 0.2.0.1 - Background jobs library for Yesod.  https://hackage.haskell.org/package/yesod-job-queue-0.2.0.1 (nakaji_dayo)
00:12:56 <hubleBee> hmmm that exposes the implementation of min
00:13:07 <hubleBee> re min (0/0) (5.0)
00:13:30 <Axman6> I think it might expose the strictness of min
00:13:53 <hubleBee> well it depends on how you write the comparison function is what i mean
00:14:52 <hubleBee> (0/0) <(5.0) and (5,0) < (0.0) are both false, but min assumes one or the other or they are equal
00:15:18 <Zemyla> > compare (0/0) 5.0
00:15:19 <lambdabot>  GT
00:15:27 <hubleBee> since they are equal it gave us either one.. which happened to be the one on the left
00:15:33 <Zemyla> > compare 5.0 (0/0)
00:15:34 <lambdabot>  GT
00:15:44 <cocreature> yeah it’s kinda weird that min is not commutatitve in that case 
00:15:48 <hubleBee> er happened to be the one on the right, but could just as easily been the one on the left
00:16:07 <kadoban> hubleBee: Well, they're not really equal, just neither is less or greater than the other.
00:16:12 <kadoban> Fun.
00:16:16 <EvanR> Ord is broken for this type
00:16:20 <hubleBee> i know...
00:16:23 <EvanR> so all bets are off
00:17:16 <hubleBee> yeah, its really the Ord instance that is broken, but i suppose that is justifiable somewhat in the presence of nan
00:17:36 <Zemyla> I think EvanR really doesn't like Doubles.
00:18:16 <cocreature> I think EvanR just hates all numbers
00:18:21 <kadoban> Well, it's a hard question, but … Float and Double just kind of lie, but they're common enough that people have to put up with them I guess? It's ugly.
00:18:27 <EvanR> eh?
00:19:13 <hubleBee> well we could have arbitrary hardcoded something to make the ord work... like nan < everything else or something
00:19:39 <hubleBee> thin min would give the expected nan, but max would'nt
00:19:48 <ski> would probably disagree with the IEEE
00:19:49 <hubleBee> but at least it would be transitive
00:20:30 <Zemyla> Actually, I'm pretty sure EvanR doesn't mind the Peano naturals as much.
00:20:59 <hubleBee> we could write the ord expression to throw an exception if either parameter is a nan
00:21:29 <EvanR> what you can do is define Ord in such a way that makes sense, and have a separate operation to obey ieee
00:21:43 <EvanR> if its that important
00:21:44 <hubleBee> yeah
00:21:48 <hubleBee> IEEEOrd
00:21:50 <hubleBee> heh
00:22:13 <EvanR> then min would be fixed
00:23:18 <hubleBee> what do yout hink is the better way to go, fixing nan to be a new bottom for floats and doubles, or throwing an exception?
00:23:47 <EvanR> whether NaN is an exception or not is configurable 
00:23:48 <hubleBee> or a new top
00:24:29 <EvanR> maybe comparison of nan with anything could be an exception
00:24:38 <hubleBee> yeah thats what i meant
00:24:59 <hubleBee> alternatively we could just arbitrarily fix it to be == 0
00:25:06 <hubleBee> heh
00:25:23 <hubleBee> that sounds a little bug prone to me tho
00:26:11 <kadoban> Hehe, yeah == 0 would be not good
00:27:05 <hubleBee> should -NaN == NaN ?
00:27:27 <hubleBee> > 0 - (0/0)
00:27:28 <lambdabot>  NaN
00:27:40 <hubleBee> i guess that question is well decided then
00:28:28 <EvanR> based on the idea that its "not a number" you shouldnt be able to do anything with it
00:29:05 <hubleBee> then maybe we should just use bottom
00:29:09 <hubleBee> instead of nan
00:29:40 <hubleBee> > 0 - (undefined)
00:29:42 <lambdabot>  *Exception: Prelude.undefined
00:30:04 <hubleBee> > 0 - (error "NaN")
00:30:06 <lambdabot>  *Exception: NaN
00:30:15 <EvanR> you could have an answer be nan but be unable to operate on it
00:30:38 <EvanR> > sin (1/0)
00:30:39 <lambdabot>  NaN
00:30:59 <hubleBee> yeah i guess they made the right call not using bottom
00:31:51 <hubleBee> > sin (1/0) == (0/0)
00:31:53 <lambdabot>  False
00:32:04 <hubleBee> uh.. hmmm now i'm not so sure
00:32:10 <EvanR> NaN == NaN ==> FileNotFound
00:32:44 <kadoban> EvanR: Indeed
00:33:41 <Axman6> did I stray into #php?
00:35:23 <hubleBee> i don't know, part of me thinks we should make it first class, and just pattern match on it and everything
00:36:23 <hubleBee> > sin (1/0) == sin (1/0)
00:36:25 <lambdabot>  False
00:37:09 <hubleBee> the easy thing to do would just to be to equate all nans, if we did that
00:37:13 <kadoban> hubleBee: There's basically no way to make it make sense as long as both (==) works on it and NaN is a value of the type, I don't think.
00:37:24 <hubleBee> which is arguably wrong semantically.. but you know
00:37:28 <kadoban> hubleBee: NaN == NaN is pretty evil in practice. Yeah
00:38:18 <hubleBee> well if we want to get all hackery and clever, we could actually have some compiler support and say two nans are only equal if the exact same thunk produced them
00:38:54 <hubleBee> that is going to be fragile with optimizations and stuff tho
00:39:37 <zRecursive> Maybe it just need to report error as CL does: (> 5.0 (/ 1.0 0)) => > Error: DIVISION-BY-ZERO detected
00:42:38 <hubleBee> :t isNaN
00:42:40 <lambdabot> RealFloat a => a -> Bool
00:44:32 <hubleBee> min x y = if isNan x || isNan y then error "min: Not a number" else ...
00:44:50 <hubleBee> could fix it there
00:44:53 <hubleBee> but then...
00:45:04 <hubleBee> that doesnt work with all Num
00:48:43 <zRecursive> Why do you think it need to work with all Num ?  */0 is illegal any way.
00:49:24 <hubleBee> it would be sucky that min didnt work on integer and int tho
00:49:42 <hubleBee> :t isNan
00:49:43 <lambdabot>     Not in scope: ‘isNan’
00:49:43 <lambdabot>     Perhaps you meant ‘isNaN’ (imported from Prelude)
00:49:47 <hubleBee> :t isNaN
00:49:48 <lambdabot> RealFloat a => a -> Bool
00:49:56 <Zemyla> Anyways, I need sleep.
00:50:11 <zRecursive> .zZ
00:51:05 <Zemyla> I might catch some recursive zs.
00:51:08 <hubleBee> (1 `div` 0)
00:51:17 <hubleBee> > (1 `div` 0)
00:51:18 <lambdabot>  *Exception: divide by zero
00:52:10 <hubleBee> sine integral types throw exceptions, the isNan thing i suppose they figured would only apply to rational types
00:53:08 <Zemyla> @let pattern NaN <- (isNaN -> True) where NaN = 0/0
00:53:08 <lambdabot>  Parse failed: TemplateHaskell is not enabled
00:53:22 <Zemyla> Failure.
00:53:42 <EvanR> isNaN is for "floating" (ieee-like) types
00:53:52 <EvanR> er, RealFloat
00:56:13 <hubleBee> we could restrict min to Integral, and add a min' for RealFloat
00:56:25 <EvanR> :t min
00:56:26 <lambdabot> Ord a => a -> a -> a
00:56:29 <EvanR> Ord
00:56:56 <hubleBee> oh well
00:57:28 <hubleBee> we could add min to the ord class
00:57:39 <hubleBee> and give a special definition for realfloat types
00:58:14 <hubleBee> thats probably the way to do it
00:58:32 <hubleBee> if we want min NaN _ to give NaN
00:58:57 <hubleBee> oh 
00:59:00 <hubleBee> a slow burn of a netsplit
00:59:29 <hubleBee> what exactly causes this?
01:03:52 <M-Quora> ?
01:05:57 <Tekkkz> Hello! Following https://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html I get an error at »decode "{\"name\":\"Joe\",\"age\":12}" :: Maybe Person« following error: http://ix.io/zFV
01:06:04 <Tekkkz> how to fix that?
01:07:02 <lyxia> {-# LANGUAGE OverloadedStrings #-}
01:07:28 <lyxia> Tekkkz: you need that ^ at the top of your program
01:07:41 <Tekkkz> I have ... o.O
01:08:54 <lyxia> check the spelling :) otherwise can you put your code on lpaste?
01:09:14 <Tekkkz> http://ix.io/zFZ
01:09:47 <Tekkkz> here. and loading this in ghci and doing json <- readFile jsonPath , then: decode json is failing with this error i just have mentioned
01:10:14 <lyxia> Oh, that's because OverloadedStrings only affects literal strings
01:10:30 <Tekkkz> ahh and what is json after reading from file?
01:10:39 <lyxia> a String, I suppose
01:10:48 <merijn> Depends how you read it
01:10:56 <Tekkkz> yes string
01:10:58 <lyxia> you can use the ByteString version of readFile
01:11:09 <Tekkkz> hm this solves it?
01:13:05 <maerwald> why is it even String?
01:13:07 <maerwald> file a bug report
01:13:44 <merijn> Why would readFile not be String? That's the way it's defined in System.IO
01:13:59 <maerwald> because it's wrong, file a bug for base 
01:16:56 <Tekkkz> wut? what should it be?
01:18:17 <EvanR> readFile uses the locale to decide how to decode ?
01:26:57 <merijn> maerwald: Not happening
01:27:17 <merijn> While agree that most operations on files SHOULD be Text/ByteString there's too much legacy code it won't change
01:28:45 <Tekkkz> please someone try to do this tutorial: https://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html 
01:28:49 <maerwald> merijn: yeah, I still consider it a bug though... we could still start with deprecation phase and think 10 years from now on or so
01:28:58 <Tekkkz> the encoding instance also full of errors
01:29:06 <Tekkkz> please rework this article or add "not working"
01:29:10 <Tekkkz> this is eally stupid
01:29:34 <kadoban> Tekkkz: ? what part isn't working?
01:29:55 <Tekkkz> try to code the ToJSON instance
01:30:07 <Tekkkz> on the top of the page. after some other stuff
01:30:36 <Tekkkz> http://ix.io/zGh
01:30:37 <kadoban> I'd prefer not to. Can't you summarize what's wrong instead?
01:31:08 <Tekkkz> at pasting was something wrong, the line is "ToJSON (ToDo id time title desc done)"
01:31:09 <maerwald> Tekkkz: did you miss quotes?
01:31:12 <lyxia> you wrote ToJSON
01:31:22 <Tekkkz> oh
01:31:23 <Tekkkz> sory
01:31:24 <Tekkkz> xD
01:31:26 <maerwald> ...
01:32:36 <EvanR> wouldnt Text have the same issue as String
01:32:46 <EvanR> the issue really being the automatic choice of encoding
01:32:56 <kadoban> Yeah
01:33:06 <maerwald> EvanR: that's why ByteString (or similar low-level representations) are the only useful _default_ choice
01:33:09 <maerwald> which belongs in base
01:33:18 <maerwald> convenience functions can be anything, including String
01:33:21 <maerwald> but not in base
01:33:41 <maerwald> it just hides the problems and makes people lazy
01:37:11 <maerwald> it's one of those false "high-level" approaches that are a common plague in haskell
01:37:27 <hubleBee> why not just optimize string
01:37:42 <maerwald> it's not really about performance
01:37:46 <maerwald> well it is too
01:37:49 <merijn> hubleBee: String is literally [Char] you can't optimise it more than lists in general
01:37:59 <maerwald> if you read an 8gb file strictly into String... good luck with your memory lawl
01:38:00 <hubleBee> you can optimize lists in general
01:38:14 <merijn> hubleBee: Not really more than they already are
01:38:17 <hubleBee> of fixed size memory
01:38:33 <hubleBee> ha!
01:38:35 <merijn> No such thing
01:38:47 <hubleBee> what do you mean no such thing as what?
01:38:56 <merijn> As "list of fixed size"
01:38:57 <hubleBee> i mean types like char which have a fixed width
01:39:16 <EvanR> hubleBee: were talking about the fact that file contents are conceptually a bunch of bytes with no encoding explicitly given
01:39:45 <EvanR> when you read it into a String or Text an encoding must be chosen, and with standard functions its not chosen by you
01:39:56 <hubleBee> i was afk when this started so i didnt kknow we meant file io in particular
01:40:19 <merijn> EvanR: Actually, you can set the standard encoding
01:40:37 <hubleBee> but in general, you can take a list of elements of fixed width and vectorize it up to some buffer size
01:40:53 <Lovepon> Is there a lbirary which provides a Map that returns mempty instead of Nothing(for functions like lookup)?
01:41:01 <merijn> EvanR: "hSetEncoding :: Handle -> TextEncoding -> IO ()"
01:41:09 <merijn> hubleBee: Then it's no longer a list
01:41:33 <merijn> hubleBee: Not a haskell list, anyway. And it'd be fundamentally incompatible with haskell as we have it now
01:41:41 <maerwald> except you can't use Handles properly in haskell anyway :P
01:41:43 <merijn> Lovepon: Just compose lookup with fromMaybe?
01:41:48 <merijn> maerwald: How so?
01:41:49 <hubleBee> well its  arguably a list semantically, if the behavior is still bounded by list
01:41:52 <Lovepon> merijn: Yaeh, that's what I was thinking.
01:42:01 <maerwald> merijn: because the filepaths of all those functions are String ;)
01:42:09 <maerwald> which is the same problem
01:42:18 <merijn> maerwald: You can't really do anything more portable
01:42:23 <maerwald> yes you can
01:42:27 <merijn> maerwald: Oh?
01:42:34 <maerwald> https://ghc.haskell.org/trac/ghc/wiki/Proposal/AbstractFilePath
01:42:36 <merijn> maerwald: What is more portable, then?
01:43:03 <EvanR> Handles have not much to do with FilePaths
01:43:12 <maerwald> EvanR: but you obtain them via filepaths
01:43:19 <EvanR> its not the only way
01:43:34 <maerwald> if you go any other way, it's just a lot of API war for you
01:43:40 <EvanR> ... no
01:43:43 <maerwald> erm, sure
01:43:46 <EvanR> Handle is used for any FD
01:43:46 <maerwald> I tried
01:43:51 <hubleBee> the compiler in theory could get smart enough to detect when the usage of the list of constant size type would be better transformed into a vector
01:43:55 <merijn> maerwald: Not really, there's lots of way to get Handles from source that are not files
01:44:10 <EvanR> stdin, sockets, etc
01:44:15 <maerwald> that's not what I meant, but anyway
01:44:25 <EvanR> sending fds through a socket, from another process
01:44:30 <merijn> hubleBee: As someone who works on compilers: I don't think you know quite how impossible what you just suggested is :)
01:44:33 <EvanR> making up fds out of nowhere
01:44:36 <hubleBee> to be conservative one could start out with [Char] and various kinds of Strings, and have the compiler exchange them in and out depending on usage pattern
01:45:07 <hubleBee> i think you use the word impossible way too easily
01:45:22 <EvanR> for the use cases where lists are better, it wouldnt make much sense to make them into a vector
01:45:35 <hubleBee> of course
01:45:46 <EvanR> namely generating and consuming data in constant space
01:46:10 <hubleBee> the trick is to have a set of heuristics to figure out when it makes sense, you can have a certain amount of ticky type measurements happening at run time to help.
01:46:38 <maerwald> EvanR: https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle-FD.html
01:46:43 <maerwald> everything is full of FilePath
01:47:00 <merijn> maerwald: Yeah, but don't expect much change there in the short term
01:47:02 <maerwald> so yes, you can obtain them differently, but it still sucks
01:47:18 <maerwald> which is why I use unix Fd instead of handles
01:48:02 <maerwald> merijn: well, if the abstract filepath proposal moves forward, there is a chance
01:48:09 <EvanR> maerwald: handles can be constructed from FDs
01:48:19 <maerwald> EvanR: dude, I told your 3 times now that I know
01:48:22 <EvanR> you dont have to use filepath, or it might be impossible because it makse no sense
01:48:50 <EvanR> im just saying FilePath's issues shouldnt be renamed to Handle issues
01:48:57 <maerwald> I did not
01:49:00 <EvanR> nothing wrong with Handles
01:49:11 <maerwald> but with the API that provides handles
01:49:38 <EvanR> handles are involves in the APIs youre talking about, among other types, but its the FilePAth that is the issue
01:49:56 <EvanR> you wont fix Handle by fixing FilePath, because Handle is not broken
01:50:01 <maerwald> not sure what we are arguing about here
01:50:12 <maerwald> you seem to misunderstand my point
01:50:17 <EvanR> i think you are sure
01:52:08 <hubleBee> there should be a word for this
01:52:17 <hubleBee> ego-banter
01:53:08 <maerwald> hubleBee: the word is called "trolling" ;)
01:53:10 <hubleBee> if god punished us the way christians think, it is probalby by inventing these endless circles of ego-banter
01:53:53 <hubleBee> i don't think so, i don't think that accurately captures what just happened
01:53:53 <EvanR> were not even arguing, just cut it out
01:58:56 <hubleBee> i uninstalled my browser
01:59:22 <hubleBee> it was somehow causing my system to crash
02:00:20 <hubleBee> maybe people are making stuff less secure now since they figure people have things like apparmour
02:01:39 <hubleBee> it is sad, to live in the age of the internet, and yet no browser i can trust
02:02:12 <EvanR> time to start your own browser project!
02:02:12 <hubleBee> i use w3m now
02:04:18 <hubleBee> too much already on my plate for that
02:07:54 <hubleBee> if a webbrowser crashes my system so bad i have to cold boot, do i blame the browser or the linux kernel or something else?
02:08:20 <EvanR> sounds like a hardware issue
02:08:40 <hubleBee> i've had the same hardware for years tho and its been working uuntil i went to this one page and enabled javascript
02:09:24 <hubleBee> and... its been working fine since i quit the browser
02:10:12 <hubleBee> so, we can blame the lower layers, hardware and os kernel and such, in a security sense... but really there is some issue with firefox
02:10:25 <quicksilver> whatever the cause, it seems a bit off-topic for here.
02:17:28 <Aruro> why there is no filterM in Data.Sequence, Data.Foldable, Data.Traversable ? its very usefull function.
02:19:41 <merijn> Aruro: Because filterM requires some form of "reconstruction"
02:19:56 <merijn> Aruro: And Foldable/Traversable don't guarantee the data structure is "reconstructible"
02:20:15 <merijn> There is a Witherable class on hackage for "reconstructible" data structure, which has a filter
02:21:03 <merijn> Aruro: Consider "data Trivial a = Trivial a" <- this can clearly be Foldable/Traversible
02:21:11 <merijn> Aruro: But what would "filterM" return?
02:25:15 <Aruro> merijn: yes but filter for Data.Sequence is easy, why its not in?
02:25:29 <Aruro> merijn: in library itself
02:26:03 <merijn> Aruro: No clue, possible no one needed it yet/thought of it?
02:29:25 <obadz> GHCI question: if I create a :command in ghci that takes module name as an arg, how do I tell GHCI to perform completion accordingly?
02:50:29 <mpickering> I don't think you can
02:52:24 <merijn> Is there a library (preferably haskell, but any language will do) for webscraping that lets me deal with JS/AJAX heavy sites?
02:54:24 <zomg> merijn: sounds like you'd need something that's actually a browser automation tool or something like that
02:54:34 <merijn> Pretty much
02:54:36 <zomg> phantomjs might do the job
02:54:46 <zomg> basically headless webkit
03:03:00 <osa1> merijn: I used casperjs and phantomjs in the past for that, with some JS generated using Fay IIRC (or was it GHCJS? I can't remember)
03:06:23 <ertes> hi there…  is there a postgresql-supporting library that can do *only* schema installations and migrations?
03:27:41 * hackagebot decimal-arithmetic 0.1.0.0 - An implementation of Mike Cowlishaw's  General Decimal Arithmetic Specification  https://hackage.haskell.org/package/decimal-arithmetic-0.1.0.0 (RobLeslie)
04:35:58 <arahael> merijn: is pdf an option?
04:37:14 <arahael> merijn: if so, wkhtmltopdf.
04:37:29 <arahael> then you coild scrape that.
04:37:40 <arahael> well, you could.
04:37:43 * hackagebot hackage-processing 0.0 - Process 00-index.tar.gz from Hackage  https://hackage.haskell.org/package/hackage-processing-0.0 (HenningThielemann)
04:42:46 <merijn> arahael: That's not interactive. I need to script the AJAX portion of said website
04:43:34 <arahael> merijn: then i suggest embdedding webkit, gecko, or cef. 
04:44:18 <arahael> merijn: or failing that, you *could* do something with node.js, perhaps via ghcjs.
04:47:14 <magthe> is there a name for the set that has 1, and if n is in the set, then 2n+1 and 3n+1 are also in the set?
04:51:15 <lyxia> magthe: http://oeis.org/A002977 doesn't seem to have a special name
04:51:52 <magthe> lyxia: thanks
04:52:41 <ski> magthe : you could think of it as an inductive family
04:53:14 <ski> magthe : <https://en.wikipedia.org/wiki/Additive_number_theory> is probably also relevant
04:57:55 * ski . o O ( ⌜data P : ℕ → ⋆ where UnoGood : P 1; DoublePlus : ∀ n → P n → P (2·n + 1); TriplePlus : ∀ n → P n → P (3·n + 1)⌝ )
05:12:44 * hackagebot stackage-curator 0.14.0 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.14.0 (MichaelSnoyman)
05:27:44 * hackagebot tar 0.5.0.3 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-0.5.0.3 (DuncanCoutts)
05:27:46 * hackagebot stopwatch 0.1.0.1 - A simple stopwatch utility  https://hackage.haskell.org/package/stopwatch-0.1.0.1 (debugito)
05:52:45 * hackagebot d3d11binding 0.0.0.4 - A raw binding for the directX 11  https://hackage.haskell.org/package/d3d11binding-0.0.0.4 (jwvg0425)
06:22:11 <Aruro> is it possible to have two import declarations in one line?
06:23:20 <mpickering> yes, separate them with a semi colon 
06:23:30 <Aruro> complaining
06:23:34 <mpickering> You can do the same in ghci as well
06:24:29 <Aruro> sorry it works,ty
06:24:57 <Iceland_jack> Aruro: also with :m Data.Text Data.List ...
06:33:37 <Mateon1> Iceland_jack: You don't need the + in :m + Module?
06:34:01 <Mateon1> Good to know, it's annoying to type to be honest
06:35:37 <lyxia> Using the + form of the module commands adds modules to the current scope, and - removes them. Without either + or -, the current scope is replaced by the set of modules specified.
06:36:01 <lyxia> It's from the ghc user guide
06:36:31 <Mateon1> User guide? Seems like I need to do some googling
06:40:23 <lyxia> you might have it installed under /usr/share/doc/ghc/html/users_guide. Otherwise it's online https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/index.html
06:46:27 <Mateon1> lyxia: I'm on Windows, so not exactly. Anyway, thank you
07:18:50 <STUDYORBREAK> hi guys, really noob question but here it goes. so i have this function (commonDivisor' x y = [temp | temp <- [1..x], x `mod` temp == 0 ]
07:18:51 <STUDYORBREAK> ) inside a file. how could i save it on an array afterwards?
07:22:43 <m1dnight_> I'm trying to install editline (`cabal install editline`) but I get the error "Could not find module GHC.Handle. I googled all over the place but could not find anything remotely helpful.
07:22:46 <m1dnight_> Any tips?
07:22:57 <m1dnight_> Im on GHC 7.10.2
07:23:25 <merijn> Package was last updated 4 years ago
07:23:28 <merijn> Probably bitrotted
07:24:06 <m1dnight_> https://www.refheap.com/118605 <- full error if that helps.
07:24:20 <m1dnight_> :> You must be kidding, no?
07:24:37 * m1dnight_ never ever can tell sarcasm on the interwebs.
07:25:00 <Akii> no sarcasm detected
07:25:11 * Akii is a sarcasm-o-meter
07:25:43 <merijn> m1dnight_: No, I'm serious. editline hackage pages shows "uploaded 2012"
07:26:04 <merijn> If you need a line editor consider haskeline?
07:26:08 <MichaelBurge> m1dnight_: A lot of people use Haskeline, which might work for you.
07:26:10 <geekosaur> m1dnight_, anything in the GHC package namespace is by definition unstable because it's poking at internal details
07:26:12 <merijn> That was last updated a few days ago
07:27:15 <m1dnight_> Oh. Yes I just need superbasic line editing. Haskeline it is!
07:27:26 <m1dnight_> By internal details you mean platform dependent, right?
07:27:31 <geekosaur> (in this particular case, you *may* be able to change it to import GHC.IO.Handle
07:28:03 <geekosaur> no, implementation dependent stuff not intended to be visible to ordinary user programs. in this case, it's implementation details of ghc's runtime
07:28:37 <geekosaur> the user visible interfaces are fixed; the internals may change. the GHC.* module hierarchy is access to the internals
07:41:49 <chattered> Can anyone recommend me a source as to how to apply the Codensity's improve to sort out the complexity of uses of stuff like sequence with Free monads? Or is there some other approach I should be going with?
07:42:49 * hackagebot biohazard 0.6.5 - bioinformatics support library  https://hackage.haskell.org/package/biohazard-0.6.5 (ustenzel)
07:45:18 <mpickering> chattered: Is this an abstract concern or something that is causing you problems in practice?
07:45:43 <chattered> mpickering: Causing me horrible problems in practice.
07:45:53 <mpickering> What is your current setup?
07:45:54 <chattered> I'm getting quadratic time on stuff that should be linear.
07:46:47 <mpickering> Have you rolled the free monad yourself? Which package are you using?
07:47:01 <mpickering> what kinds of programs are you building?
07:47:18 <chattered> I'm using the free package, and just a Free monad with a simple functor for an imperative DSL.
07:47:58 <chattered> ("imperative" as in, it gets interpreted one-to-one as IO actions).
07:48:32 <mpickering> Maybe try "Control.Monad.Free.Church" first
07:48:53 <chattered> mpickering: Cool. Will do.
07:48:54 <STUDYORBREAK> hi guys, quick noob question. so i have created a functions for solving common divisors and outputs an array. so how can I store the output into a variable? im wondering if i could use it like this: variablename = commonDivisor x y
07:48:56 <STUDYORBREAK> https://gist.github.com/anonymous/0ae9af00bc896b79a41b74b0d01b7e8a
07:51:17 <STUDYORBREAK> hi guys, quick noob question. so i have created a functions for solving common divisors and outputs an array. so how can I store the output into a variable? im wondering if i could use it like this: variablename = commonDivisor x y
07:51:18 <STUDYORBREAK> https://gist.github.com/anonymous/0ae9af00bc896b79a41b74b0d01b7e8a
07:51:50 <mpickering> STUDYORBREAK: Your question doesn't really make sense as you don't really "store things in variables" in haskell
07:51:56 <mpickering> what are you actually trying to do
07:52:34 <Ferdirand> your function discards its second argument
07:53:32 <STUDYORBREAK> ow, im so sorry, been trying haskell and i thought i could do it like this test = function (x, y)
07:53:50 <STUDYORBREAK> varname = functionname(x,y)
07:54:23 <Ferdirand> you would do varname = functionname x y
07:54:23 <mpickering> yes but when you say that you are defining varname to be equal to functionname x y
07:54:32 <mpickering> and it will never equal anything else
07:54:39 <mpickering> but what is the problem you are trying to solve?
07:54:53 <Ferdirand> so we do not call it storing, we call it creating a binding
07:55:49 <Boomerang> There are no "variables" in haskell, everything is immutable, so you're just giving a name to a function applied to two arguments
07:56:35 <Iceland_jack> They are variables though
07:56:49 <Boomerang> functionname(x,y) would work with (x, y) being one argument, a pair
07:56:56 <Iceland_jack> They aren't “mutable references” a la C
07:57:10 <STUDYORBREAK> good gracious, i should really dwell in haskell
07:57:21 <mpickering> STUDYORBREAK: What is the actual problem you are trying to solve
07:58:04 <STUDYORBREAK> mpickering: more like the varname x y = functionname x y
07:58:11 <Boomerang> why call them variables then Iceland_jack ? In languages like Scala you clear see when something is mutable, var vs val. Instead of calling the bindings variables we could call them values
07:58:34 <Boomerang> *clearly
07:58:50 <Ferdirand> we do not have mutable variables so there is no need to introduce a distinction
07:59:03 <Ferdirand> beyond calling mvars what they are
07:59:04 <exio4> we have references though
07:59:19 <Iceland_jack> Boomerang: They're called variables in mathematics
07:59:35 <Iceland_jack> Boomerang: Values are different
08:00:12 <STUDYORBREAK> im trying to solve some common divisors, i think i got it now. https://gist.github.com/anonymous/d3750c87ab167ff0b1394105e32bc842
08:01:41 <TheMystic> Boomerang: they are properly called variables, because variables don't always have a binding in Haskell code
08:01:48 <STUDYORBREAK> thanks guys! and kudos to all
08:01:50 <TheMystic> i.e. we make the distinction between bound and free variables
08:01:54 <Boomerang> Iceland_jack: yeah you're right, I went too far in what I was saying. I do call them variables too! I just thought making a clear distinction for beginners would make more sense...
08:02:43 <TheMystic> like AFAIU function parameters aren't "bindings" until the function is applied to some arguments -- in the fn definition, they're free variables
08:02:49 * hackagebot haskell-src-meta 0.6.0.14 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.6.0.14 (GeoffreyMainland)
08:02:52 <Ferdirand> STUDYORBREAK: your commonDivisorX and commonDivisorY are the same function
08:03:15 <Ferdirand> and it should be named "divisors"
08:04:01 <STUDYORBREAK> yeah, thanks Ferdirand.
08:04:03 <Ferdirand> and elem has linear complexity in its second argument, so you can easily rewrite that to do better
08:09:19 <STUDYORBREAK> wow, great. thanks man, i never knew there more ways to do things efficintly
08:17:50 * hackagebot string-conv 0.1.1 - Standardized conversion between string types  https://hackage.haskell.org/package/string-conv-0.1.1 (MichaelXavier)
08:32:50 * hackagebot d3d11binding 0.0.0.5 - A raw binding for the directX 11  https://hackage.haskell.org/package/d3d11binding-0.0.0.5 (jwvg0425)
08:52:51 * hackagebot retry 0.7.2 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.7.2 (MichaelXavier)
09:07:12 <bbear> hey
09:09:51 <anxys> hiya
09:12:33 <Iceland_jack> hey
09:13:44 <burp> :t sourceCmdWithConsumer
09:13:45 <lambdabot> Not in scope: ‘sourceCmdWithConsumer’
09:15:31 <burp> sourceCmdWithConsumer :: MonadIO m => String -> Consumer ByteString m a -> m (ExitCode, a)
09:15:39 <burp> sourceCmdWithConsumer "ls" (Data.Conduit.List.mapM_ Data.ByteString.putStrLn)
09:15:54 <davidkart> I am digging into haskell right now and I would like to see the end of the voyage.
09:15:57 <burp> can someone point out why this doesn't typecheck?
09:16:10 <burp> Couldn't match expected type ‘conduit-1.2.6.1:Data.Conduit.Internal.Conduit.ConduitM BS.ByteString o IO a0’ with actual type ‘ConduitM BS.ByteString o0 IO ()’
09:19:02 <monochrom> looks like you have two versions of conduit, and both are being used, which is prone to contradictions like this
09:21:05 <geppettodivacin> davidkart: What do you mean by the end of the voyage?
09:21:57 <burp> monochrom: might entirely possible, though I thought stack would fix/prohibit such things via "stack exec ghc -- --make test.hs"
09:24:47 <burp> monochrom: and you are right :)
09:25:08 <geekosaur> burp, I think it can't block stuff in the global package database that way; it needs to invoke ghc itself to do that
09:25:40 <burp> yea, I just noticed my distro has a global conduit package
09:25:49 <monochrom> onoes
09:26:13 <geekosaur> ...also it may not be able to resolve some other issues with stack exec vs. actually buliding a project, most it can do is expose its package database and hope something else is smart enough to deal
09:32:01 <anxys> I'm doing a project on mutation testing and I was wondering if anyone knew of any possible programmer mistakes that the compiler wouldn't catch...?
09:32:24 <simpson> anxys: Yes, there's a lot of them.
09:33:01 <maerwald> the question is asked the wrong way around
09:33:26 <anxys> ?
09:33:29 <davidkart> geppettodivacin: I mean to be really good at it.
09:33:57 <davidkart> I am working on a code contest and I fell I would be much more productive with a functional language like Haskell.
09:34:27 <anxys> simpson: Do you have any examples?
09:34:32 <davidkart> However it lasts just one damn week, I wont have enough time to fix all my errors.
09:34:40 <maerwald> davidkart: productivity in haskell starts at an extremely low level, which can be rather frustating
09:34:48 <acertain> does anyone know of any incremental unification work?
09:34:52 <davidkart> But I am carrying it to the end.
09:34:54 <geppettodivacin> davidkart: You might be, but it takes some time to get used to it. It's like relearning how to code.
09:35:08 <davidkart> well, actually it's like learning how to code.
09:35:18 <geppettodivacin> But it's a fun journey, and in my opinion, definitely wroth it.
09:35:20 <davidkart> I feel python is way more clumsy when you are using functional programming.
09:35:28 <maerwald> anxys: maybe I didn't understand your question well enough... you asked about "any possible programmer mistake that the compiler wouldn't catch".. which is basically an insane amount 
09:35:50 <geppettodivacin> davidkart: How are you going about learning Haskell?
09:35:56 <davidkart> Well enough chit chat. I must carry it to the efnd. Time to work effectively.
09:36:16 <davidkart> geppettodivacin: to be true, I never saw the real interest until I started doing some real math.
09:36:25 <davidkart> I am doing the haskell tutorial.
09:36:35 <maerwald> @cis
09:36:35 <lambdabot> Maybe you meant: oeis list id cide bid
09:36:54 <monochrom> I prefer to argue over what counts as mistakes. Suppose your program prints "Your PC is stoned" infinitely many times and refuses to stop. Is that a mistake or is it a feature? Compilers certainly won't ban it.
09:36:57 <davidkart> But I tried like 2 times to get through. The third time, I stayed until 2 am to run all the examples in the tutorial and have some fun with it.
09:37:47 <monochrom> (In fact, there was a widely spread program that did exactly that. It was not a bug. It was a virus.)
09:37:54 <simpson> anxys: addOne :: Int -> Int; addOne x = x - 1
09:38:01 <anxys> maerwald: I meant things along the lines of having a literal 2 which should have been a 1
09:38:39 <maerwald> > let pi = 0.0
09:38:40 <lambdabot>  <no location info>: not an expression: ‘let pi = 0.0’
09:38:51 <monochrom> which brings us to an interesting question: should the compiler flag your program as erroneous if your program is a virus?
09:38:53 <maerwald> typechecks perfectly
09:38:58 <maerwald> monochrom: lol
09:39:15 <simpson> monochrom: Clearly your compiler should refuse to compile viruses.
09:39:35 <maerwald> that would be bad for microsoft, how would they compile the windows kernel?
09:39:37 <monochrom> Fortunately, the Stoned virus was not written in Haskell.
09:39:54 <puregreen> if anybody ever ends up programming self-replicating nanobots, I hope they do use a compiler that requires a proof that self-replication will be finite
09:40:01 <simpson> maerwald: Oh, I was being cold serious. Capabilities, yo.
09:40:36 <anxys> monochrom: I am mostly interested in common mistakes that can get passed the compiler. I'm not really focused on what the compiler should consider wrong or not.
09:40:59 <monochrom> ok, what is your difference between "mistake" and "wrong" then?
09:41:05 <nitrix> anxys: Re-read yourself.
09:41:47 <maerwald> I think he wants a specific "error domain", but I don't understand which one
09:42:01 <maerwald> "common" is not really specific
09:42:12 <mfukar> Valid programs with logic errors, maybe?
09:42:16 <maerwald> logical errors are common and get past pretty much any compiler including Prolog
09:43:32 <nitrix> Correct programs; incorrectly solving a problem.
09:43:40 <anxys> Hmm. Well, with mutation testing I'm interested in modifying a program so that it looks like a fault an actual programmer could make.
09:43:52 <puregreen> anxys: here's one very common one that GHC doesn't catch
09:43:53 <puregreen> http://lpaste.net/162353
09:44:06 <puregreen> not sure whether it should be classified as a mistake or not
09:44:07 <anxys> So that I could then use that mutated program to see how well the test suite performs.
09:44:50 <simpson> anxys: Actual programmers can make literally any mistake that the compiler accepts as well-formed.
09:45:03 <maerwald> I think there's no angle to solve that problem 
09:45:20 <hpc> puregreen: of all the ways for the world to end, i would have never imagined it would be grey goo via someone postulating lem
09:46:02 <puregreen> hpc: what's lem?
09:46:08 <hpc> law of excluded middle
09:47:00 <monochrom> How could LEM lead to grey goo?
09:47:33 <monochrom> Unless you're saying the ghost of Boole spills grey goo.
09:47:56 <hpc> because it can be used to prove false in constructive logic, which can fool a self-replication checker ;)
09:48:39 <monochrom> I don't think LEM proves false in constructive logic.
09:50:50 <anxys> simpson: Yeah, I know that but I was looking for examples similar to someone accidentally putting a "-" which should have been a "+".
09:51:00 <monochrom> And I need to finish my joke. Let me put it all in one sentence.
09:52:19 <hpc> heh
09:52:23 <monochrom> How could LEM lead to grey goo? Unless you're saying the ghost of Boole spills grey goo. And the Ghostbusters can't capture him because you can't hold him in the middle of two beams (LEM).
09:52:48 <monochrom> s/sentence/line
09:52:59 <simpson> anxys: You mean, like the example that I wrote earlier?
09:53:03 <hpc> what does lem lose you then? just compilation termination?
09:53:07 <simpson> addOne :: Int -> Int; addOne x = x - 1
09:53:38 <monochrom> LEM loses computability, i.e., with LEM, provable things are not necessarily computable.
09:54:02 <anxys> simpson: Yeah, stuff like that.
09:54:11 <hpc> ah right
09:54:44 <hpc> so you could use a proof of self-replication termination that uses the property of all programs terminating, then use lem to create a non-terminating program and grey goo
09:54:48 <hpc> or something
09:54:54 <hpc> this is getting very silly and non-haskell
09:55:26 <monochrom> I prefer my Ghostbuster LEM joke :)
09:55:30 <hpc> yeah
09:57:28 <ertes> is there a postgresql-supporting library for schema generation and migration?  not a complete DSL, i still want to write SQL (or relational algebra combinators, if supported)
09:58:09 <ertes> as in: add missing columns with a specified default, etc.
09:59:47 <anxys> simpson: Another more complicated example would be messing up the order of pattern matches. I know it's a broad question but asking to find out if anyone has seen simple mistakes like that.
10:01:55 <simpson> anxys: Yes, those mistakes definitely have happened before.
10:02:30 <bblfish> hi
10:03:12 <bblfish> I read in this very nice blog on monoids ( http://blog.higher-order.com/blog/2014/03/19/monoid-morphisms-products-coproducts/  for Scala readers ) but also elswhere that 
10:03:12 <bblfish> "The underlying set of a monoid A is just the type A without the monoid structure. "
10:04:13 <bblfish> so if I take the monoid of Integers. What is the unerlying set there? Is it just 0 and 1, because all the numbers can be taken from there by appending 1?
10:04:33 <bblfish> or is it the set of all integers? But if so how can one have the set of integers and loose their structure?
10:04:51 <simpson> bblfish: Which monoid of integers? There's several.
10:05:17 <bblfish> let's take the simplest. I am just trying to make sure I understand.
10:05:21 <tdammers> A monoid is a set (Integer), a binary operation (e.g. +), and a neutral element (0)
10:05:37 <simpson> Or a set (Integer), a binary operation (*), and an identity element (1).
10:05:44 <bblfish> ah yes. Of course there could be two monoids on integer.
10:05:52 <bblfish> + and *
10:05:54 <tdammers> there could be more
10:06:37 <bblfish> That's the weird thing about category theory is to think of numbers + operations together...
10:06:52 <hpc> . o O ( type Word = [Char] )
10:07:31 <tdammers> well, the thing that defines the monoid is the three of them combined
10:07:41 <infinity0> i basically only use %%~ from the lens package, is there a smaller package i can depend on instead?
10:08:17 <bblfish> yes, so I suppose that's why it's different from OO where you usually have the methods tied together with the objects. Here you can have the objects apear in different categories.
10:08:20 <hpc> what's (%%~)?
10:08:33 <hpc> it might be simple enough to write yourself
10:09:22 <infinity0> lol, (%%~) = id
10:09:40 <infinity0> hmm but i need to construct the lens in the first place as well
10:10:55 <bblfish> well I suppose that's not quite true. One could wrap the internal object into a type and provide some methods on it. case class PlusMonoid(i: Int). Then i is the underlying object.
10:11:12 <lyxia> infinity0: there's microlens or lens-simple which are lighter alternatives to lens
10:11:48 <bblfish> tdammers, simpson thanks for the help there... can keep reading the article. :-)
10:13:43 <TallerGhostWalt> anyone else having trouble getting :kind!  to evaluate a type synomym
10:13:52 <TallerGhostWalt> type Foo = Int 
10:14:20 <TallerGhostWalt> :kind! Foo  => Foo :: *
10:14:21 <TallerGhostWalt> = Foo
10:14:39 <TallerGhostWalt> instead of : Foo :: * , Int 
10:16:24 <monochrom> is ":kind!" supposed to do that?
10:16:56 <TallerGhostWalt> From the manual: If you specify the optional "!", GHC will in addition normalise the type by expanding out type synonyms and evaluating type-function applications, and display the normalised result.
10:17:04 <TallerGhostWalt> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-commands.html
10:17:19 <TallerGhostWalt> monochrom: so it seems like it should
10:17:32 <monochrom> does your GHC version match the manual version?
10:17:53 * hackagebot irc-client 0.3.0.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.3.0.0 (barrucadu)
10:18:10 <hpc> i have a feeling it has to do with the type synonym being to the left of the (::)
10:19:45 <TallerGhostWalt> monochrom: 7.10.3 is what I am using 
10:19:49 <TallerGhostWalt> and that is the manual version 
10:19:56 <TallerGhostWalt> hpc: what do you mean?
10:20:40 <hpc> oh hmm, nvm
10:20:55 <hpc> i was imagining it behaving something like ":type!", which it seems doesn't exist
10:21:06 <hpc> doing something like getLine :: IO [Char] instead of IO String
10:21:15 <hpc> ignore me
10:21:26 <monochrom> ok, I don't know why, but certainly ":kind! String" says "= String" too.
10:22:05 <TallerGhostWalt> sigh
10:23:05 <TallerGhostWalt> It says "fully evaluate" so maybe a star name pairing with know function left is considered fully evaluated 
10:23:18 <hpc> TallerGhostWalt: you can try asking in #ghc and someone more involved might notice your question that way
10:23:27 <TallerGhostWalt> hpc: k
10:23:42 <hpc> or if nothing else, it being a surprising behavior might make it worth an enhancement bug report on the trac
10:35:18 <MichaelK> Hi, currently, if I have a function like `update :: (a -> Maybe a) -> a -> a` in a project, I'll put it in something like `Data.Maybe.Aux` if several modules use it. Is this a good practice for organizing modules?
10:37:07 <puregreen> MichaelK: yep: https://jaspervdj.be/posts/2015-01-20-haskell-design-patterns-extended-modules.html
10:37:21 <puregreen> it's been proposed before and IIRC people on Reddit loved it
10:38:15 <MichaelK> puregreen: awesome, thanks :)
10:38:29 <saurabhnanda> is there a reason why Haskell isn't big on promises (aka JS). Does some language feature make them pretty-much redundant?
10:39:01 <merijn> saurabhnanda: Yes, the fact that we have good lightweight threading means you just write blocking code
10:39:26 <saurabhnanda> hmm
10:39:50 <simpson> saurabhnanda: Haskell doesn't have builtin transparent forwarding or any kind, so it's hard to make *promises* in particular. There's things like the Async type from the async package.
10:40:12 <saurabhnanda> merijn: how about, when you're dealing with an external system, which is event driven. Eg JSON RPC over a websocket?
10:40:23 <merijn> How is that a problem?
10:40:34 <saurabhnanda> simpson: what do you mean by "transparent forwarding"?
10:40:34 <merijn> Have one thread talk to the socket while blocking
10:40:46 <merijn> saurabhnanda: Do everything else in another thread
10:40:55 <merijn> saurabhnanda: i.e. you just have 1 thread (or more) per socket
10:41:21 <saurabhnanda> merijn: current problem I"m stick with. Make request to jsonRpcOverWebsocket, but it won't give back a response. The response will come back as an incoming notification. How do I make this work like a blocking request/response cycle?
10:41:40 <simpson> saurabhnanda: Well, JS promises are built on this idea going all the way back to Smalltalk of "transparent" objects that proxy all received messages to another object.
10:41:56 <simpson> saurabhnanda: And, from that, stuff like objects that *become* other objects, or objects that *promise* to be other objects, were born.
10:42:10 <simpson> saurabhnanda: But Haskell is not an object-based language.
10:42:22 <ertes> MichaelK: the .Extended stuff sounds nice, if you actually have an *extension* (dependency-wise)…  for self-contained utilities there is a convention to use a separate utility module, and the most common name i've seen and use myself is .Utils
10:42:51 <simpson> saurabhnanda: Ah! You need *multiplexing*. You need an object that will manage callbacks for you when messages are *completed*. This can be tricky and I don't have anything to immediately show you, except for Async.
10:42:59 <simpson> saurabhnanda: http://hackage.haskell.org/package/async
10:43:29 <saurabhnanda> simpson: right, I'm trying to hack together something with async, but wanted to check promises. Cuz that'll make it slightly easier to build on top of.
10:43:37 <saurabhnanda> I think...
10:43:49 <MichaelK> ertes: what do you mean dependency wise?
10:44:27 <saurabhnanda> also reading https://www.reddit.com/r/haskell/comments/sijsg/what_is_the_haskell_equivalent_to_javascript/c4ebhsh
10:44:51 <saurabhnanda> what's the difference between MVar and TMVar?
10:45:00 <Cale> ertes: So I realised that when reflex-dom gets an Applicative instance for Dynamic soon, we'll be able to lift Monoid instances through Dynamic, and so we'll be able to have printfWith dynText -- a printf where the inputs are dynamically changing values. :)
10:45:01 <ertes> MichaelK: mapSomthing :: (Int -> Int) -> A -> A  -- if A is and should be defined in My.Module, then the module that contains this function would be called My.Module.Extended
10:45:20 <Cale> saurabhnanda: TMVar is manipulable from within an STM transation
10:45:24 <Cale> transaction*
10:45:56 <ertes> MichaelK: letter :: (Functor f) => (Char -> f Char) -> Char -> f Char  -- this one is an independent utility and doesn't extend anything within the library it's contained in
10:46:07 <ertes> s/Functor/Applicative/
10:46:41 <ertes> Cale: cool =)
10:46:49 <Cale> saurabhnanda: So if you start with one TMVar which is full and another empty, you can transactionally pull an item from the first TMVar and put it in the second, for instance, without the possibility of taking the item, and then having some other thread write to the second MVar before you can
10:48:00 <MichaelK> ertes: ah, ok. So something like `Text -> Text -> Text` would go in Data.Text.Utils while `MyData -> Int -> MyData` would go in something like Data.MyData.Extended?
10:48:09 <saurabhnanda> Cale: got it
10:48:22 <saurabhnanda> Cale: but can't both the TMVars be combined into a single MVar, which is anyways modified atomically?
10:48:25 <ertes> Cale: wait…  Alternative?  does it union the change events?
10:48:39 <ertes> Cale: no, can't be…  there would be no 'empty'
10:48:40 <Cale> saurabhnanda: Yeah, you could do something like that, in some cases.
10:49:10 <Cale> saurabhnanda: But STM is more general -- your transactions can interact with any number of things in a way which guarantees that everything happens, or none of it does.
10:49:58 <saurabhnanda> Cale: I wonder how it's implemented under the hood
10:49:59 <ertes> MichaelK: yeah
10:50:30 <MichaelK> ertes: makes sense, thanks
10:51:57 <ertes> saurabhnanda: in essence it's MaybeT IO with a transaction log…  you probably don't want to look into its implementation
10:52:43 <Cale> saurabhnanda: Well, the present implementation is that when an STM transaction runs, it logs all the reads and writes to memory that it's doing. Reads are real, but writes only go to the log at first. Then, once the code for the transaction has finished (i.e. the action you've given to 'atomically'), it takes a global lock and runs through the transaction log, making sure that all the read TVars still have the values that were read befo
10:52:43 <Cale> re, and if so, actually writing the written-to variables.
10:53:36 <Cale> If the values have changed, it runs the transaction again.
10:53:37 <ertes> Cale: is the lock actually global?  i think that unrelated transactions can often be committed simultaneously
10:54:20 <saurabhnanda> funky stuff... I would've never thought about it ... just use an SQL DB and let it handle transactions
10:54:36 <Cale> ertes: hmmm :)
10:54:51 <Cale> ertes: There might have been further optimisations done to the mechanism since I last read about it
10:55:06 <Cale> There's certainly plenty of opportunity to provide the same semantics in more efficient ways
10:55:12 <ertes> saurabhnanda: STM gives you memory transactions, very similar to a transactional database…  but its most useful feature you probably won't find in databases: "orElse"
10:55:59 <ertes> saurabhnanda: transaction1 <|> transaction2  -- what happens depends on which of the two transactions commits first, and individual transactions can be waiting ("retrying")
10:56:48 <Cale> Right, that's yet another thing that I have to remember when I finally get fed up with the databases we're using
10:58:01 <ertes> saurabhnanda: example:  one transaction waits for a TVar Bool to become True (readTVar >>= check), while the other transaction waits for a message from a TBQueue to come in
10:59:09 <fryguybob> The default STM implementation has a lock for every TVar.
10:59:29 <Cale> fryguybob: Oh, that's interesting and good to know.
11:00:57 <hpc> orElse: a literal race condition
11:01:28 <Cale> hpc: kind of...
11:01:51 <hpc> (because the two actions are racing to commit first, in a sense)
11:02:15 <Cale> Well, the first one executes first, and if it's successful, the whole thing is done
11:02:23 <hpc> oh, i see
11:02:43 <Cale> But often, under some condition, it will be designed to retry explicitly
11:02:59 * hpc retracts his amazing joke
11:03:00 <Cale> which will trigger the execution of the second transaction
11:04:09 <Cale> We do have a literal race condition in the async library, race :: IO a -> IO b -> IO (Either a b)
11:04:16 <xa0> hahaha
11:04:28 <xa0> delightfully darwinian
11:04:34 <Cale> Useful for implementing timeouts
11:04:40 <xa0> yeah
11:06:25 <hpc> does the loser action still execute to completion?
11:09:01 <kadoban> Cale: Heh, I hadn't seen that one before, that's quite cute.
11:09:38 <Iceland_jack> "Run two IO actions concurrently, and return the first to finish. The loser of the race is cancelled."
11:09:45 <hpc> ah
11:09:59 * hpc is honestly not sure which method would be better
11:10:22 <Iceland_jack> You can use 'concurrently' for the other
11:10:33 <hpc> ah
11:10:35 <Iceland_jack>     concurrently :: IO a -> IO b -> IO (a, b)
11:10:51 <nitrix> :t mapConcurrently
11:10:52 <lambdabot> Not in scope: ‘mapConcurrently’
11:10:54 <hpc> well, you lose which finishes first
11:11:15 <Iceland_jack> true
11:11:48 <hpc> if you're racing something that consumes resources, you might want to make sure they are freed or something
11:11:51 <fryguybob> hpc: You can have an action at the end of both threads that updates who one.
11:11:54 <fryguybob> *won
11:12:50 <hpc> orderedConcurrently :: IO a -> IO b -> IO (Chan (Either a b))?
11:12:57 <hpc> that's kinda icky though
11:13:39 <hpc> (but you can read from it asynchronously too!)
11:14:14 <fryguybob> hpc: You can hide everything and get the same signature as race.
11:14:41 <hpc> well i was thinking maybe you want the results of both plus ordering
11:14:43 <hpc> or something like that
11:14:46 <hpc> but yeah
11:15:06 <hpc> clearly the right way is Either (a, b) (b, a)
11:15:56 <fryguybob> hpc: Where touching the second part of the pair could be *really* slow :P
11:16:09 <hpc> hah
11:17:06 <hpc> man, i really need a reason to do more concurrent programming
11:17:09 <fryguybob> Oh, I guess concurrently waits, so ... yeah.
11:17:11 <hpc> it's fun
11:35:09 <watChmeFly> Hey guys
11:35:41 <watChmeFly> Could someone point in the direction of how to split a list of integers and then add those split integers?
11:36:08 <lyxia> how do you want them split
11:36:24 <watChmeFly> Would filter be a reasonable choice?
11:38:09 <lyxia> watChmeFly: what you're trying to do is not clear
11:38:42 <watChmeFly> ok so the user input is a list of integers
11:38:55 <watChmeFly> [12,45,3]
11:39:07 <watChmeFly> the outpush should be the sum of each integer
11:39:09 <watChmeFly> so 15
11:39:19 <watChmeFly> 1+2+3+4+5
11:39:25 <Zekka|Sigfig> Oh yeah, the sum of the digits?
11:39:29 <watChmeFly> Yes
11:39:35 <Zekka|Sigfig> You’re probably going to want to start by figuring out how to split an integer up like that
11:39:42 <watChmeFly> Correct
11:40:02 <Zekka|Sigfig> one way is to take the last digit, then shift all digits over one, until getting 0
11:40:30 <Zekka|Sigfig> another is just to convert it to a string and then convert every character of the string to an integer (don’t ask me what happens with negative integers!)
11:40:42 <watChmeFly> Hmmm ok
11:41:10 <Zekka|Sigfig> So to do the last one, you can use show :: Int -> [Char], then figure out how to define Char -> Int, and use map with show to get Int -> [Int]
11:41:30 <ertes> hpc: if you don't find applications for concurrency, you're a lucky person
11:43:19 <watChmeFly> @lpaste
11:43:19 <lambdabot> Haskell pastebin: http://lpaste.net/
11:43:30 <ertes> hpc: to give you some inspiration: most end-user applications SUCK, because they don't use concurrency (probably because their language doesn't support it (very well))
11:44:31 <ertes> let me give you a specific example: youtube-dl downloads, then recodes, then downloads, then recodes…  and when the connection stalls, the progress display doesn't update
11:44:37 <ertes> this is terrible UX
11:45:11 <samba11> Can anyone help me getting ghc-mod working with stack? I did stack install ghc-mod, but when I run stack exec -- ghc-mod check I get errors about depdencies missing (they're not, they're installed by stack) as well as "ghc-mod: readCreateProcess: cabal "configure" "--with-ghc=ghc" "--flags" "" (exit 1): failed"
11:45:18 <samba11> I have ghc-mod version 5.5.0.0 compiled by GHC 7.10.3
11:48:01 <ARM9> did you mean: stack exec ghc-mod -- check
11:48:37 <samba11> Yes, maybe. Either gives me the same
11:49:27 <ARM9> that's unfortunate, OS?
11:49:58 <samba11> 3.19.0-43-generic #49~14.04.1-Ubuntu
11:56:11 <watChmeFly> Hey another question
11:56:31 <watChmeFly> Can I use filter to get the sum of the list?
11:56:58 <lyxia> filter is for filtering
11:56:59 <dmj`> watChmeFly: no
11:57:21 <watChmeFly> What exactly can it all filter? odd, even?
11:57:24 <watChmeFly> what else?
11:57:31 <samba11> :t filter
11:57:32 <lambdabot> (a -> Bool) -> [a] -> [a]
11:57:36 <dmj`> watChmeFly: Any predicate you provide
11:58:02 <watChmeFly> gotcha
11:58:03 <watChmeFly> thanks
12:04:39 <lpaste> watChmeFly pasted “code” at http://lpaste.net/162358
12:05:00 <watChmeFly> Would someone look at that and tell me why I'm getting errors with the "mod n 10"?
12:05:40 <Zekka|Sigfig> watChmeFly: Hm, are you sure addDigits is [Integer] -> [Integer}?
12:05:56 <Zekka|Sigfig> Looks like your code expects a to be a number, not a list
12:06:09 <watChmeFly> Well no the output should be an integer, not a list.  But then I was getting an error saying it's expecting -> [integer]
12:06:14 <Zekka|Sigfig> to me it looks more like Integer -> [Integer]
12:06:27 <Zekka|Sigfig> I’m guessing that’s because you used ++, which concats two lists, in line 7
12:06:41 <watChmeFly> Wouldnt it be [Integer] -> Integer?
12:06:47 <ARM9> (div a 10) is also not a list, you'd want : to cons
12:06:49 <ertes> watChmeFly: sounds like you're trying to write one function, but thinking of another one
12:07:00 <watChmeFly> List is the input, the output is an integer
12:07:03 <Zekka|Sigfig> Your code pretty much typechecks with Integer -> [Integer] afaict, but it sounds like you want Integer -> Integer
12:07:15 <watChmeFly> hmm
12:07:17 <watChmeFly> ok brb
12:07:20 <Zekka|Sigfig> you don’t seem to be handling the input as a list, but as a single integer
12:07:24 <ertes> watChmeFly: write two functions: one that figures out the digits, and one that adds them
12:07:42 <ertes> the former goes from Integer to [Integer]  -- an integer to a list of digits
12:07:49 <ertes> the latter goes from [Integer] back to Integer
12:07:55 <ertes> so overall you go from Integer to Integer
12:07:57 * hackagebot hackage-processing 0.0.0.1 - Process 00-index.tar.gz from Hackage  https://hackage.haskell.org/package/hackage-processing-0.0.0.1 (HenningThielemann)
12:07:59 * hackagebot derive 2.5.25 - A program and library to derive instances for data types  https://hackage.haskell.org/package/derive-2.5.25 (NeilMitchell)
12:08:00 <watChmeFly> Oh ok
12:08:22 <ertes> watChmeFly: the divMod function is useful
12:08:27 <ertes> > divMod 123 10
12:08:29 <lambdabot>  (12,3)
12:08:50 <watChmeFly> divMod 12 10
12:09:02 <watChmeFly> How do you split the 12 then?
12:09:07 <ertes> > divMod 12 10
12:09:09 <lambdabot>  (1,2)
12:09:15 <ertes> it just does div and mod in one go
12:09:22 <watChmeFly> Why didn't it work for me lol
12:09:30 <ertes> you forgot the ">" for lambdabot =)
12:09:34 <watChmeFly> -_-
12:09:35 <geekosaur> the "> " tells the bot to act on it
12:09:36 <watChmeFly> thanks lol
12:09:41 <watChmeFly> > divMod 12 10
12:09:43 <lambdabot>  (1,2)
12:09:47 <watChmeFly> hmm
12:11:23 <ertes> watChmeFly: if you're brave, you can write the first function in terms of 'unfoldr'…  if not, just use regular recursion
12:11:30 <ertes> :t unfoldr
12:11:31 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:12:15 <watChmeFly> Why do I need to be brave? Is it complicated?
12:12:35 <ertes> watChmeFly: no, just a new API =)
12:12:40 <watChmeFly> Oh ok
12:13:04 <watChmeFly> I keep getting errors for Integer -> Integer...
12:13:17 <watChmeFly> There has to be a list involved somewhere, the user input is a list
12:13:18 <ertes> it's less complicated, once you know how to do it, but i think you're already learning multiple things at the same time
12:13:36 <ertes> where does the user input come from?
12:13:42 <watChmeFly> command line
12:13:47 <ertes> getArgs?
12:14:24 <watChmeFly> I just do :l program.hs and then addClass[1,2,3]
12:14:37 <ertes> ah, so you give it integers to begin with
12:14:41 <watChmeFly> Yes
12:15:09 <ertes> now let's say you have: digits :: Integer -> [Integer]
12:15:18 <watChmeFly> Errors
12:15:33 <ertes> you can 'map' that function over your list:  map digits args
12:15:41 <ertes> this, of course, results in a list of lists of integers
12:15:54 <watChmeFly> But the output should be an integer
12:16:04 <ertes> do it step by step
12:16:21 <ertes> 'digits' converts a single integer to a list of its digits
12:16:30 <ertes> it should do that and nothing else
12:16:44 <watChmeFly> Well it shouldn't create multiple lists though
12:16:49 <watChmeFly> just add to the same one
12:16:52 <ertes> digits 12345 = [5,4,3,2,1]  -- the way i would do it
12:17:03 <ertes> be patient, you'll get there
12:17:06 <passy> I seem to be misunderstanding something about Parsec backtracking. I would expect this here to match, but it doesn't: `parse (try (string "h") <|> (string "help") >> eof) "" "help"`. The error is "unexpected 'e', expecting end of input". What am I missing here?
12:17:08 <watChmeFly> oh ok
12:17:57 * hackagebot table-layout 0.5.2.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.5.2.0 (muesli4)
12:18:43 <ertes> watChmeFly: i've secretly added a definition for 'digits', so you can still try to write it yourself, but i can show you how you would use it
12:19:01 <ertes> @let input = [123, 45, 678]
12:19:02 <lambdabot>  Defined.
12:19:13 <ertes> > digits 1234567
12:19:15 <lambdabot>  [7,6,5,4,3,2,1]
12:19:21 <watChmeFly> :0
12:19:22 <infinity0> in cabal files the Category: has not been well specified yet, is it frowned upon if i just spam it with random related words?
12:19:26 <watChmeFly> How'd that happen?? lol
12:19:32 <infinity0> i was thinking "Category: Control, Schedule, Cron, Later, After, Delay, Timer, Timeout"
12:19:40 <jle`> passy: which <|> are you using?
12:19:58 <passy> jle`: Control.Applicative.(<|>)
12:20:12 <ertes> watChmeFly: i've /msg-ed lambdabot my definition of 'digits' in order not to spoil it =)
12:20:23 <ertes> watChmeFly: writing 'digits' is still an exercise
12:20:24 <watChmeFly> Oh ok lol
12:20:45 <ertes> but once you have it, you can apply it to the input list, which would give you a list of lists:
12:20:54 <ertes> > map digits [123, 45, 678]
12:20:55 <jle`> passy: in that case, it binds tighter tha >>
12:20:56 <lambdabot>  [[3,2,1],[5,4],[8,7,6]]
12:21:07 <jle`> passy: so you're actually doing (try foo <|> bar) >> eof
12:21:13 <passy> jle`: Oh interesting!
12:21:22 <jle`> passy: the (try (string "h") <|> string "hello") succeeds with just "h"
12:21:24 <ertes> watChmeFly: then you can just flatten that list using 'concat', or because it's such a common operation, you can use the predefined concatMap function
12:21:24 <watChmeFly> And then how will it add those?
12:21:25 <jle`> and moves on to expect an eof
12:21:27 <Zekka|Sigfig> this is clearly the best way to do it
12:21:36 <watChmeFly> Oh ok
12:21:42 <ertes> > concatMap digits [123, 45, 678]
12:21:43 <lambdabot>  [3,2,1,5,4,8,7,6]
12:21:45 <Zekka|Sigfig> @let digitsOf = sum . unfoldr (\x -> swap (divMod x 10) <$ guard (x > 0))
12:21:46 <lambdabot>  Defined.
12:21:52 <Zekka|Sigfig> er
12:21:56 <jle`> passy: i think the Text.Parsec.<|> has the fixity to make it work like you think ... but i'd rather rely on explicit parentheses than fixity games, heh
12:21:59 <Zekka|Sigfig> @let digitsOf = reverse . unfoldr (\x -> swap (divMod x 10) <$ guard (x > 0))
12:22:00 <lambdabot>  .L.hs:154:1:
12:22:01 <lambdabot>      Multiple declarations of ‘digitsOf’
12:22:01 <lambdabot>      Declared at: .L.hs:152:1
12:22:11 <ertes> watChmeFly: as the final step you write a function that adds those lists
12:22:13 <Zekka|Sigfig> @let digitsOf’ = reverse . unfoldr (\x -> swap (divMod x 10) <$ guard (x > 0))
12:22:13 <lambdabot>  Parse failed: Parse error: =
12:22:19 <Zekka|Sigfig> screw me and my irc client!
12:22:22 <jle`> lol
12:22:22 <passy> jle`: Yeah, I'd also rather be explicit there. Thank you!
12:22:23 <Zekka|Sigfig> I was going to show off the most horrible way
12:22:39 <watChmeFly> lol
12:22:41 <jle`> passy: np!
12:22:44 <ertes> watChmeFly: and please try to ignore Zekka|Sigfig's implementation…  i don't know why the hell people love to spoil the learning process here
12:23:03 <Zekka|Sigfig> ertes: You are correct — nobody should write it the way I did
12:23:05 <watChmeFly> Honestly, I don't know wehre to begin...
12:23:17 <ertes> watChmeFly: write digits
12:24:04 <watChmeFly> digits [1,2,3,4,5,6]
12:24:15 <watChmeFly> > digits [1,2,3,4,5,6]
12:24:16 <lambdabot>      No instance for (Show t0)
12:24:16 <lambdabot>        arising from a use of ‘show_M209426011321853297412779’
12:24:16 <lambdabot>      The type variable ‘t0’ is ambiguous
12:24:25 <ertes> watChmeFly: digits :: Integer -> [Integer]
12:24:49 <watChmeFly> > digits 1,2,3,4,5,6
12:24:50 <lambdabot>  <hint>:1:9: parse error on input ‘,’
12:24:58 <ertes> > digits 12345
12:24:58 <watChmeFly> > digits 123456
12:25:00 <lambdabot>  [5,4,3,2,1]
12:25:00 <lambdabot>  [6,5,4,3,2,1]
12:25:05 <ertes> ;)
12:25:18 <watChmeFly> That took longer than it should have lol
12:25:53 <ertes> watChmeFly: writing this function is your first step…  it's the first piece of the puzzle =)
12:26:58 <ertes> watChmeFly: remember: this function *only* converts an integer to a list of digits, and nothing else…  if you're tempted to use (+), you're already one step ahead
12:27:34 <watChmeFly> So would filter come in handy here?
12:27:51 <ertes> can't think of a reason to use it
12:27:58 * hackagebot aeson-flatten 0.1.0.2 - JSON flatten for Aeson  https://hackage.haskell.org/package/aeson-flatten-0.1.0.2 (JiriMarsicek)
12:27:58 <watChmeFly> oh
12:29:12 <ertes> watChmeFly: as your first implementation i would just write it recursively
12:31:23 <watChmeFly> Did you by chance us a sort function?
12:31:27 <watChmeFly> use*
12:31:50 <ertes> watChmeFly: nope…  let me give you a template
12:31:54 <ertes> digits 0 = ?
12:32:21 <watChmeFly> [] empty list
12:32:24 <ertes> yeah
12:32:41 <ertes> digits 123 = _xs  -- is _xs the empty list?
12:33:32 <watChmeFly> no, because the input is larger than 0
12:33:36 <suppi> what do i do if i want to install software not on stackage using stack?
12:33:55 <ertes> watChmeFly: digits 123 = _h : _t  -- so it is of this shape…  what is _h?
12:34:09 <watChmeFly> 1
12:34:19 <kadoban> suppi: 'stack install the-software' boom, done.
12:34:31 <ertes> watChmeFly: let's say it's 3 (otherwise the implementation will get more complicated)
12:34:42 <suppi> kadoban, The following target packages were not found: bnfc
12:35:11 <watChmeFly> ok
12:35:15 <ertes> watChmeFly: digits 123 = 3 : _t  -- what is the rest of the list?  can you perhaps express the remaining digits in terms of 'digits' itself?
12:35:20 <kadoban> suppi: BNFC? It's case sensitive.
12:35:21 <suppi> kadoban, oh, i think i should have written BNFC instead
12:35:32 <kadoban> Right, that might be it
12:35:35 <suppi> suppi, thanks. it works now :)
12:35:43 <kadoban> Sure, anytime
12:35:44 <watChmeFly> if head is 3, then the tail would be 2 and 1 no?
12:36:27 <ertes> watChmeFly: yeah:  digits 123 = 3 : (2 : (1 : []))  -- but the tail looks suspiciously like 'digits' applied to a certain value, right?
12:36:53 <watChmeFly> What do you mean?
12:37:17 <Zemyla> I wonder if there's a way to turn sort into a good producer and consumer.
12:37:31 <ertes> watChmeFly: could (2 : (1 : [])), which is of course just [2, 1], be the result of 'digits' applied to a certain value?
12:37:59 <ertes> watChmeFly: in other words, can you solve the equation digits v = [2, 1] for v?
12:38:25 <watChmeFly> well if 3 is not included, im assuming v =3?
12:38:34 <ertes> digits 3 = [3]
12:38:36 <ertes> so no
12:38:55 <ertes> you're looking for v such that:  digits v = [2, 1]
12:40:29 <watChmeFly> What type is v?
12:40:38 <ertes> look at the type of digits
12:40:42 <ertes> and tell me =)
12:41:00 <watChmeFly> well, the input is integers, the output is a list
12:41:15 <watChmeFly> so v is a list?
12:41:31 <ertes> listen:  1. digits takes an argument of type Integer and returns a value of type [Integer]
12:41:38 <ertes> 2. v is an argument to digits
12:41:48 <ertes> conclusion: v is of type …?
12:42:35 <ertes> now use logical reasoning to come up with the answer
12:43:03 <watChmeFly> Whoa
12:43:08 <watChmeFly> what was that?
12:43:43 <ertes> watChmeFly: which part didn't make sense?
12:43:55 <watChmeFly> If digits takes a method of type integer, then v is integer
12:44:08 <watChmeFly> argument*
12:44:12 <ertes> there you go =)
12:44:12 <watChmeFly> not method
12:44:52 <watChmeFly> so digits:: Integer -> [Integer]
12:44:58 <ertes> yeah
12:45:03 <watChmeFly> Lol well I have that part
12:45:16 <watChmeFly> I'm sorry I didn't relate your question to that 
12:45:20 <ertes> digits is also a two-clause function, and you have the first clause:
12:45:26 <ertes> digits 0 = []
12:45:44 <ertes> to find the non-zero clause we're looking at an example
12:46:14 <ertes> digits 123 = 3 : [2, 1]  -- that's how we want the function to behave for this specific example
12:47:02 <watChmeFly> @lpaste
12:47:02 <lambdabot> Haskell pastebin: http://lpaste.net/
12:47:11 <lpaste> watChmeFly pasted “No title” at http://lpaste.net/162362
12:47:12 <ertes> watChmeFly: does that make sense so far?
12:47:22 <watChmeFly> Yes
12:47:26 <watChmeFly> Is that what you mean?
12:47:53 <ertes> yeah, that's one way to write it
12:48:14 <watChmeFly> so then |otherwise ...
12:48:23 <watChmeFly> let me think for a sec
12:48:53 <lpaste> ertes annotated “No title” with “Template” at http://lpaste.net/162362#a162363
12:49:13 <ertes> watChmeFly: but i suggest you write the multi-clause version instead…  i've added a template to the paste
12:49:29 <watChmeFly> ok
12:49:45 <ertes> watChmeFly: observe: digits 123 = 3 : [2, 1]
12:49:51 <jle`> any reason why we don't have  'type State s a = forall m. Monad m => StateT s m a' ?
12:50:01 <ertes> now [2, 1] would be the result of 'digits 12', right?  digits 12 = [2, 1]
12:50:35 <paolino_> is there a way to derive (a -> Bool) based on matching constructors ?
12:51:01 <watChmeFly> Question about the 0 = []
12:51:03 <jle`> paolino_: the lens library lets you auto-derive prisms that can be use dfor that
12:51:06 <watChmeFly> That doesn't include negatives
12:51:08 <watChmeFly> right?
12:51:13 <jle`> > has _Just (Just 10)
12:51:15 <lambdabot>  True
12:51:21 <jle`> > has _Just Nothing
12:51:22 <lambdabot>  False
12:51:23 <ertes> watChmeFly: right…  don't worry about it just yet though
12:51:30 <watChmeFly> ok
12:51:35 <ertes> watChmeFly: if (digits 123 = 3 : [2, 1]) and (digits 12 = [2, 1]), then:  digits 123 = 3 : digits 12
12:51:54 <ertes> watChmeFly: does that logic make sense?  it's equational reasoning
12:51:57 <paolino_> jle`, thanks 
12:52:33 <jle`> np!
12:52:50 <ertes> watChmeFly: (in haskell we're lucky enough that "=" actually means "equals")
12:52:51 <watChmeFly> Actually that does not make sense to me
12:53:05 <watChmeFly> It just looks recursive to me
12:53:10 <ertes> watChmeFly: it is recursive
12:53:14 <watChmeFly> oh
12:53:43 <watChmeFly> so it takes head, then applies digits recursively to tail?
12:53:57 <ertes> math example:  4! = 4 * (3 * 2 * 1); 3 * 2 * 1 = 3!; therefore 4! = 4 * 3!
12:54:09 <ertes> we're using exactly the same logic here
12:54:10 <paolino_> jle`, is the _ prefix added to constructor names ?
12:54:17 <watChmeFly> ok
12:54:27 <jle`> paolino_: that's the convention that the lens library's template haskell uses when it generates its prisms, yes
12:54:40 <ertes> watChmeFly: there is only one step that is missing to make this a full definition
12:54:44 <jle`> paolino_: but you can also provide custom name functions too
12:55:03 <paolino_> and has makes the (a -> Bool) out of them
12:55:04 <jle`> er, as in, custom ways of making identifiers from constructor names
12:55:07 <jle`> yeah
12:55:17 <watChmeFly> hmm
12:55:19 <ertes> watChmeFly: digits 123 = 3 : digits 12  -- can you express 3 sensibly as something applied to 123?
12:55:46 <jle`> paolino_: at the bigger picture, you can think of review as making a (a -> Maybe (the things inside the constructor)) out of them
12:55:52 <jle`> paolino_: 'has' is just review and an isJust
12:56:00 <jle`> and hasn't is a 'review' and a isNothing
12:56:05 <jle`> > hasn't _Just (Just 10)
12:56:07 <lambdabot>  False
12:56:15 <shachaf> ertes, watChmeFly: You should probably take this conversation to #haskell-overflow at this point.
12:56:43 <watChmeFly> ertes, can I message you?
12:56:47 <ertes> watChmeFly: i've joined #haskell-overflow…  join me
12:57:03 <jle`> > [review _Left (Right 10), review _Left (Left 4)]
12:57:05 <lambdabot>  [Left (Right 10),Left (Left 4)]
12:57:12 <jle`> oops
12:57:38 <jle`> i meant 'preview'
12:57:44 <jle`> > [preview _Left (Right 10), preview _Left (Left 4)]
12:57:46 <lambdabot>  [Nothing,Just 4]
12:58:01 <jle`> so has and hasn't are just 'preview' with an extra isNothing/isJust at the end, essentially
12:58:28 <Darwin226> Hey guys, what's the easiest way to get all the modules (names only) from all the packages on hackage?
12:58:31 <sphinxo> When should I use Control.Monad.Trans.Error vs Control.Monad.Trans.Except?
12:58:39 <sphinxo> oh wait nvm
12:58:58 <sphinxo> Error is deprecated
13:00:35 <chelfi> lisa monet
13:00:43 <chelfi> oops
13:00:47 <chelfi> wrong channel
13:03:06 <suppi> how do i do `cabal run` with stack?
13:03:45 <suppi> oh, never mind :)
13:08:06 <jle`> suppi: i use stack-run :)  it makes sure everything is rebuilt appropriately if there are changes
13:08:52 <suppi> jle`, stack exec <app-name> is not good enough?
13:09:03 <jle`> suppi: yeah, it won't rebuild things as needed
13:10:08 <suppi> jle`, i see. thanks :)
13:10:14 <sphinxo> Could someone help me understand why this error is happening? http://lpaste.net/4971872318151196672
13:10:27 <sphinxo> ( on ask )
13:11:43 <jle`> sphinxo: wrong lookup
13:11:45 <jle`> :t lookup
13:11:46 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
13:12:03 <jle`> :t M.lookup
13:12:05 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
13:12:09 <sphinxo> ahh
13:12:54 <sphinxo> Thanks jle` , any other feedback anyone could give me?
13:13:59 <dmj`> sphinxo: I'd remove 'undefined' in line 38
13:15:14 <sphinxo> And replace it with some implementation I presume?
13:26:00 <xa0> what's this called 
13:26:04 <xa0> m (a -> b) -> a -> m b 
13:26:41 <tdammers> a type signature?
13:26:54 <xa0> smartass :p
13:27:01 <xa0> i mean is it a standard function?
13:27:03 <Rembane> It looks like somekind of mix between applicative and functor.
13:27:08 <Rembane> xa0: Ask hoogle!
13:27:17 <Rembane> xa0: You can type that type signature into hoogle and it will tell you.
13:27:21 <xa0> ah
13:27:23 <xa0> true
13:32:05 <paolino_> is it possible to derive "fmap afield . xxxxx (has _Field)"   from "data A = Field {afield :: AField} | ......."  with a makeFilter ''A ?
13:32:39 <paolino_> using template haskell
13:36:27 <infinity0> is there a way i can embed code examples in docstrings but then compile and run it, to check that it actually works?
13:36:52 <numberten> i'm trying to abstract over partitioning a list of ADTs by their value constructors
13:36:58 <numberten> this is the closest I've gotten: http://lpaste.net/162364
13:37:23 <numberten> but obviously it doesn't work because you have to explicitly annotate undefined with a type
13:37:41 <numberten> is there anyway to do this and if so am I on a sane path? :)
13:38:17 <jle`> xa0: it looks like just \f x -> fmap ($x) f, i don't think it is too special
13:38:22 <jle`> xa0: or \x f -> f <*> pure x
13:38:26 <Guest60387> Hello, what is simplest way to split camel case string (always starting with capital letter, without spaces) like "AFooBar" to list like ["A", "Foo", "Bar"]?
13:38:48 <xa0> jle`: yeah, fair enough
13:39:06 <jle`> in any case it doens't require Monad
13:39:21 <jle`> i guess it's some weird form of 'ap'
13:39:33 <tdammers> Guest60387: there's a few libraries for that on hackage
13:40:11 <tdammers> Guest60387: or rather, there are libraries to convert between casing conventions, but if you look at the source code, you can derive a split-to-list function easily
13:42:33 <enthropy> infinity0: you've seen the haskell-doctest which doesn't do that exactly, but the end result can be the same if your cabal file describes how to call doctest?
13:42:54 <infinity0> enthropy: ah i didn't know about doctest, i'll take a look thanks!
13:48:00 * hackagebot decimal-arithmetic 0.1.0.1 - An implementation of Mike Cowlishaw's  General Decimal Arithmetic Specification  https://hackage.haskell.org/package/decimal-arithmetic-0.1.0.1 (RobLeslie)
13:54:17 <quchen> +1 for doctest
13:54:29 <quchen> Sadly it doesn't integrate well with ordinary testsuites :-|
13:54:56 <glguy> > groupBy (const isLower) "NotAGreatIdea"
13:54:58 <lambdabot>  ["Not","A","Great","Idea"]
13:57:01 <verement> quchen: can you give me a reference so I can improve it
13:57:20 <quchen> verement: The README on Github is all I needed to get started
13:57:49 <quchen> verement: main = doctest ["src"] is what I use as my testsuite main file to run it
13:58:04 <quchen> That and the README is really all you need :-)
13:58:19 <quchen> verement: https://github.com/sol/doctest#readme
13:58:40 <verement> quchen: thanks
14:18:34 <sphinxo> What is does liftA2 (,) do?
14:19:25 <sphinxo> is there something if I want to do liftA3 like so.
14:19:38 <sphinxo> liftA3 (,) (t) (eval lhs) (eval rhs) >>= \case
14:19:46 <Welkin> <$> <*> <*> ...
14:19:55 <geekosaur> liftA2 x y z    is the same as     x <$> y <*> z
14:19:59 <Welkin> add as many <*> as you need
14:20:02 <geekosaur> but you can extend it with more <*> ... at the end
14:20:10 <koala_man> what was SPJ's talk about using different implementations for different types, so that e.g. Vector (a,b) could be efficiently stored as a pair of vectors instead of a vector of pairs?
14:21:28 <geekosaur> sphinxo, note that the first thing has to take that many params; (,) only takes 2, if you want 3 then it probably wants to be (,,)
14:22:42 <sphinxo> Thanks y'all
14:27:34 <koala_man> ah, the paper was Associated Types with Class
14:29:43 <fizbin> Is there some way to define a "local to this where clause" type alias?
14:29:53 <geekosaur> fizbin, no
14:30:05 <geekosaur> I think there's an open proposal though
14:33:37 <infinity0> hm, is there a version of doctest that doesn't require ghci mode input?
14:33:58 <infinity0> i have a multi-line example and i only really just want to make sure it type checks
14:35:51 <infinity0> oh, basically like this https://stackoverflow.com/questions/5603715/haddock-cabal-how-to-include-source-code-examples
14:36:00 <infinity0> i guess there's no easy way yet :(
14:40:50 <sphinxo> How can I remove all the duplication in the eval method? 
14:40:53 <sphinxo> eval (Arith Sub e e')  = liftA2 (,) (eval e) (eval e')  >>= \case
14:40:55 <sphinxo>                               (TInt x, TInt y) -> return (TInt (x - y))
14:40:57 <sphinxo>                               _                -> return (Error TypeError)
14:40:59 <sphinxo> eval (Arith Mul e e')  = liftA2 (,) (eval e) (eval e')  >>= \case
14:41:00 <sphinxo>                                 (TInt x, TInt y) -> return (TInt (x * y))
14:41:02 <sphinxo>                                 _                -> return (Error TypeError)
14:41:05 <sphinxo> eval (Arith LtEq e e')  = liftA2 (,) (eval e) (eval e')  >>= \case
14:41:07 <sphinxo>                                 (TInt x, TInt y) -> return (TBool (x <= y))
14:41:08 <sphinxo>                                 _                -> return (Error TypeError)
14:41:10 <sphinxo> eval (Arith GtEq e e')  = liftA2 (,) (eval e) (eval e')  >>= \case
14:42:02 <arahael> heh.
14:44:35 <geekosaur> guess that ends that... that wasn't a kick, it was a kline
14:45:58 <sphinxo> After that brief interlude ( being banned ) does anyone have any advice?
14:46:24 <geekosaur> first biut of advice is: use a pastebin next time
14:46:34 <sphinxo> I shall be more careful in the future http://lpaste.net/3298150191697231872
14:46:57 <sphinxo> I made one :) just forgot to copy the url and had the code in my clipboard
14:47:18 <sphinxo> so my silly irc client posts it line by line
14:47:32 <lyxia> sphinxo: pattern match after evaluating e and e'
14:48:24 <arahael> sphinxo: most of the good clients warn you if you're about to send a paste.
14:48:35 <arahael> sphinxo: consider switching :)
14:48:47 <sphinxo> arahael: offtopic, but what would you recommend?
14:48:55 <sphinxo> i'd prefer cli if possible
14:49:02 <sphinxo> currently using weechat
14:49:35 <sphinxo> which is "supposed" to warn me ( I think - obviously i'm doing something wrong )
14:49:43 <arahael> sphinxo: it does.
14:50:15 <lpaste> lyxia annotated “No title” with “sphinxo (annotation)” at http://lpaste.net/3298150191697231872#a162365
14:51:23 <sphinxo> ooh cool, that's much cleaner - thanks lyxia 
14:51:40 <arahael> sphinxo: it is probably configurable, ask the #weechat folks.
14:51:45 <lyxia> and since these are all returns...
14:51:56 <lpaste> lyxia revised “sphinxo (annotation)”: “sphinxo (annotation)” at http://lpaste.net/162365
14:53:07 <sphinxo> Thanks - that's really neat
14:54:00 <lyxia> yw
14:54:43 <lpaste> geekosaur annotated “No title” with “No title (annotation)” at http://lpaste.net/3298150191697231872#a4164318857621667840
14:55:34 <geekosaur> mrr, no, mine is wrong, need the TBool vs. TInt in the result :/
14:55:49 <geekosaur> still doable, with a little refactoring
14:56:17 <geekosaur> but yes, you can make most of the boilerplate go away
14:56:54 <geekosaur> (or is it? I think it'd want to be polymorphic in a difficult place?)
14:57:39 <sphinxo> @hoogle on
14:57:42 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:57:43 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
14:57:43 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
14:58:24 <ayylmao> ayy
14:58:25 <ayylmao> I need some help
14:58:44 <ayylmao> I'm using aeson to parse json
14:58:50 <ayylmao> and no matter what I do it returns nothing
14:59:14 <Clint> ayylmao: if you use eitherDecode it might help you track down the problem a little bit better
14:59:41 <ayylmao> yes
14:59:47 <ayylmao> the errors dont make sense
14:59:58 <ayylmao> eitherDecode $ BS.pack "[1,2,3]" -> Left "Error in $: Expected an empty array"
15:00:19 <ayylmao> what does that even mean?
15:01:04 <ayylmao> eitherDecode $ BS.pack "{}" -> Left "Error in $: expected (), encountered Object"
15:01:13 <emmanuel_erc> Hello there, is it sensible to think about using a zipper to speed up traversals in the Map data structure?
15:01:47 <ayylmao> Clint: do you know what these errors could mean?
15:02:17 <Clint> ayylmao: what type are you telling eitherDecode to return?
15:02:31 <ayylmao> Im just executing the expression in ghci
15:02:58 <Clint> ayylmao: try eitherDecode $ BS.pack "[1,2,3]" :: Either String [Int]
15:03:18 <ayylmao> that works
15:03:21 <ayylmao> thanks
15:07:47 <ayylmao> wait clint
15:08:04 <ayylmao> how can the return value of the function change with the type signature I give it?
15:08:15 <Clint> ayylmao: polymorphism
15:09:49 <magneticduck1> I'm trying really hard to convince myself I should use Haskell for this part of my game
15:10:18 <magneticduck1> essentially it's the .. well, modding API, somewhat
15:10:53 <magneticduck1> logic that attaches to the server to add mechanics 
15:11:35 <magneticduck1> it's important to have fast iteration and good performance
15:17:20 <Hijiri> How are you planning to embed Haskell in your game? Unless the game is already mostly Haskell
15:18:03 * hackagebot hw-conduit 0.0.0.9 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-conduit-0.0.0.9 (haskellworks)
15:18:42 <magneticduck1> Hijiri: 'embed' is a bit of a loose term
15:18:42 <montanonic> magneticduck1: do it if you want to get better at Haskell and make yourself more likely to use Haskell in projects in the future. Don't do it if you know a quicker way and are comfortable with that, and if getting the game out there with modding is high enough priority where you wouldn't enjoy having to go slow sometimes while you learn the necessary Haskell techniques/libraries.
15:19:17 <magneticduck1> I'm already quite comfortable with Haskell
15:19:55 <montanonic> magneticduck1: I make progress in the Haskell projects I'm working on because refining my Haskell knowledge is about as enjoyable as finishing a new feature. So sometimes it's slow, but I still enjoy it.
15:20:28 * montanonic mostly works with Yesod
15:20:32 <magneticduck1> the only reason the game is not itself written in Haskell is because I wasn't totally comfortable with the available libraries / performance concerns I would face / distance I'd be putting between myself and the well trodden road
15:21:12 <arahael> magneticduck1: but you are now?
15:21:29 <magneticduck1> but with the core / client written in C++, I'd love to find a way to integrate Haskell to fulfill the more abstract task of expressing game mechanics 
15:22:31 <magneticduck1> I'm actually more comfortable with Haskell than C++
15:22:54 <magneticduck1> and I'm feeling the OOP blues...
15:23:04 <montanonic> magneticduck1: I'm going to ask you a slightly off-topic question: did you consider using Rust to write the game? Are you just experienced enough with C++ that it wouldn't be worth using it, and/or does C++'s ubiquity as a programming language for games just make it much more viable for fast development due to existing infrastructure/libraries?
15:23:30 <magneticduck1> montanonic: I didn't particularly consider rust, no
15:23:36 <magneticduck1> but there were very, very many things to consider
15:23:55 <magneticduck1> before coming to my current state with C++, I'd tried javascript and haxe in the past
15:24:25 <magneticduck1> they both put some .. annoying shackles on me, performance-related especially 
15:24:39 <magneticduck1> so I just threw up my hands and took an option I knew was pragmatic
15:25:13 <magneticduck1> (also I secretly wanted to know what C++ was all about)
15:25:59 <montanonic> interesting; how do you find C++ at this point?
15:26:07 <montanonic> you said OOP-blues, but can you elaborate?
15:26:12 <magneticduck1> heh heh
15:26:28 <magneticduck1> I've grown to respect C++
15:26:48 <montanonic> also, to answer your question: it sounds like you really want to write the server modding-logic add-on API whatever, in Haskell, so write it in Haskell and be happy :)
15:27:14 <magneticduck1> yeah that's probably going to be my solution, I hope I can make it work out
15:29:32 <magneticduck1> montanonic: most of the OOP blues I'm having currently stem from how difficult it is to come anywhere near to ideal design patterns
15:30:07 <comstar> 'ideal design patterns' at some level this is influenced or hindered by your familiarity with developing those patterns in the paradigm you're faced with
15:30:14 <montanonic> I see; do you have an intuition for how you would design things in Haskell?
15:30:28 <magneticduck1> comstar: sure, ideal is relative
15:30:29 <comstar> if haskell better suits the way you want to write software, and would work for what you're trying to write (is adequate or appropriate) then just use it
15:30:40 <Sornaensis> haskell is bae
15:30:54 <comstar> I'd say more subjective, as it has to do more with the past experiences of the developer than their relative position
15:30:54 <magneticduck1> what I'm trying to say is..
15:30:58 <comstar> but that's semantics
15:31:22 <magneticduck1> when I write C++, I'm constantly flicking off the voice on my shoulder that says I should express what I'm doing in simpler terms
15:31:38 <magneticduck1> I have to constantly compromise with my ideals
15:32:05 <scshunt> magneticduck1: I think that's somewhat true in Haskell too
15:32:13 <magneticduck1> well it's true in all languages
15:32:23 <magneticduck1> compromising with your ideals is an aspect of all programming
15:32:53 <magneticduck1> but in C++ it happens way too much
15:33:11 <magneticduck1> maybe I can think of an example
15:33:40 <scshunt> C++, moreso than many languages, offers you multiple ways to do the same thing
15:33:55 <scshunt> on the plus side, it can do a lot built-in, but some things get really ugly
15:34:43 <comstar> magneticduck1: are you talking about doing things concisely?  that's generally the territory of higher level langauges compared to C++
15:35:36 <comstar> like C++ is still very much C, ++, even if it has a few nuanced syntactic differences, and C is a very involved paradigm (on purpose)
15:35:48 <magneticduck1> the central aspect that I miss most is that central mantra of pure FP -- if every step is a clear, simple construction, the result will do what you think it will do 
15:36:00 <magneticduck1> comstar: C++ is definitely not C with a ++ tail added on
15:36:00 <comstar> ah, I can relate to that
15:36:10 <magneticduck1> C++ is definitely a high level language
15:36:15 <comstar> not really
15:36:18 <johnw> "C++ is still very much C" -- I'm not even sure what that means, but here isn't the place to find out
15:36:25 <magneticduck1> but everything in C++ is so complex
15:36:37 * ReinH checks the name of the channel he's in
15:36:51 <magneticduck1> in Haskell I can sit down and write "tick :: Time -> State -> State" and I'm totally sure I know what that does
15:37:06 <ReinH> magneticduck1: it ignores the time and returns the state unchanged, right?
15:37:22 <johnw> magneticduck1: and you know unsafePerformIO isn't being used from the type? :)
15:38:11 <Cale> johnw: haha
15:38:14 <bergey> That's what grep is for =)
15:38:33 <magneticduck1> johnw: pre-commit script that electrocutes the user if `cat $(find src/) | grep unsafePerformIO` returns non-zero
15:39:48 <magneticduck1> s/non-zero/non-empty
15:39:50 <comstar> magneticduck1: why not just grep -r unsafePerformIO src/
15:39:51 <ReinH> *cough* useless use of cat *cough*
15:40:35 <ReinH> even if you are somehow using a grep without -r, you still don't need to cat and doing so is probably harmful.
15:40:50 <johnw> guess not enough Haskell problems in the world today :)
15:41:27 <magneticduck1> ReinH: this way I can control the files being searched with less looking around grep's man page
15:41:30 <geekosaur> only ham there is grep can't tell you which file it's found in
15:41:31 <scshunt> actually using cat there is bad
15:41:33 <geekosaur> *harm
15:41:38 <ReinH> magneticduck1: you still don't need cat for that.
15:41:38 <magneticduck1> scshunt: why?
15:41:42 <shachaf> "cat x | cmd" is great.
15:41:46 <magneticduck1> okay, what do I use?
15:41:52 <ReinH> geekosaur: files can contain newlines.
15:42:03 <ReinH> *file names
15:42:06 <shachaf> I wish there was a command for writing into a file so I could write "read in | cmd | write out"
15:42:10 <scshunt> what ReinH said
15:42:20 <scshunt> and also commands can only have so many parameters. In a large enough directory, that will fail
15:42:25 <ReinH> cating the results of find is as bad as piping ls
15:42:29 <scshunt> shachaf: tee?
15:42:43 <ReinH> the whole point of find is that you don't need to use cat to manipulate the found files, and that you can do so in a safe way
15:42:46 <shachaf> scshunt: tee kind of accidentally supports that.
15:42:48 <geekosaur> that's not an argument against cat, it's an argument against $(find src/) (which you could have done just as well directly to grep, same problerm and no cats in sight)
15:42:53 <scshunt> ^
15:42:59 <johnw> find src -name '*.hs' -print0 | xargs -0 -P2 egrep -nH unsafePerformIO  # now can we move on?
15:43:01 <scshunt> you should just use grep -r
15:43:03 * hackagebot bytestring 0.10.8.0 - Fast, compact, strict and lazy byte strings with a list interface  https://hackage.haskell.org/package/bytestring-0.10.8.0 (DuncanCoutts)
15:43:12 <ReinH> geekosaur: $(find src/) was necessitated by the useless use of cat, or vice versa
15:43:29 <Enigmagic> but we all know that ag is better than grep by now, right? :-)
15:43:38 <ReinH> find src/ -exec grep unsafePerformIO {} \; if you must.
15:43:41 <Enigmagic> it even has --haskell
15:44:03 <ReinH> Enigmagic: what? No it doesn't.
15:44:26 <Enigmagic> ReinH: mine does... maybe you have an old version :p
15:44:58 <Enigmagic> ReinH: https://github.com/ggreer/the_silver_searcher/blob/9fc8924c0b3d9c8ab088a56c528f3a9bf1875836/src/lang.c#L36
15:45:23 <magneticduck1> anyway, I guess an objective question might be more reasonable here
15:45:30 <ReinH> huh
15:45:35 <thoughtpolice> Enigmagic: Aye, confirmed that in ubuntu 14.04
15:45:36 <thoughtpolice> TIL
15:45:37 <magneticduck1> what's that thingy runhaskell does to get from code to process so quick?
15:45:50 <ReinH> magneticduck1: interpret it?
15:46:02 <magneticduck1> right, that thing
15:46:18 <thoughtpolice> Enigmagic: I sometimes wonder how many keystrokes I saved with 'ag', in total.
15:46:29 <bsjsjd> @lambdabot asq
15:46:29 <lambdabot> Unknown command, try @list
15:46:37 <thoughtpolice> I used ack before, so the overall gains are clearly incredible in the long run.
15:47:16 <bsjsjd> What are lenses?
15:47:30 <Enigmagic> thoughtpolice: i measure mine in keyboards saved
15:47:39 <ReinH> thoughtpolice: alias a=ag for 100% fewer characters.
15:47:52 * Enigmagic mashes keys furiously
15:47:59 <shachaf> 50%
15:48:05 <magneticduck1> bsjsjd: space burritos
15:48:08 <thoughtpolice> ReinH: omg I'm going so fucking fast fffffff---
15:48:11 <ReinH> 50% as many, 100% fewer.
15:48:19 <bsjsjd> :O
15:48:22 <MichaelK> Hi, I have a library with only a few things that lenses seem good for. would including lenses be overkill? maybe microlens instead?
15:48:32 <geekosaur> (run csh, alias shell=ag, 100% fewer :p )
15:48:44 <ReinH> bsjsjd: https://github.com/ekmett/lens/wiki/FAQ
15:49:01 <mpickering> MichaelK: There is nothing wrong with including lens if it's the right tool for the job
15:49:09 <geekosaur> (no, it doesn't quite work that way in practice)
15:49:14 <bsjsjd> @reinH thanks
15:49:14 <lambdabot> Unknown command, try @list
15:49:33 <ReinH> bsjsjd: @ triggers lambdabot, so you should probably use a postfix : instead.
15:49:37 <mpickering> if you need prisms and isomorphisms then microlens doesn't provide them
15:49:58 <ReinH> MichaelK: do you want to expose lenses for your library?
15:50:02 <geekosaur> ...if it even works in modern csh, since that was a hack to enable running scripts in arbitrary interpreters before #! became ubiquitous
15:50:03 <ReinH> You can do so without incurring a lens dependency
15:50:05 <magneticduck1> ReinH: not finding a lot of information on interpreted haskell, I'm curious what the differential is performance-wise
15:50:29 <geekosaur> magneticduck1, a lot. "bytecode backend" might be a better search phrase
15:50:30 <MichaelK> mpickering: I don't think I need either. so then microlens could be good?
15:50:45 <geekosaur> (applied to "haskell" or "ghc")
15:50:49 <MichaelK> ReinH: I want to use them in the library
15:51:04 <mpickering> yes but you're saying that you have no newtypes nor sum types in your program :) ?
15:51:14 <ReinH> MichaelK: Well, the likelihood that any haskeller already has lens installed quickly approaches 1
15:51:19 <geekosaur> for one, ghc's bytecode backend doesn't optimize. at all.
15:51:37 <MichaelK> ReinH: ah, I see
15:52:26 <MichaelK> mpickering: not really ones I'd expect to use lenses with, but I suppose the "when you're holding a hammer, everything looks like a nail" principle could end up applying
15:52:40 <geekosaur> yes, but lens is the ultimate hammer :p
15:53:04 <MichaelK> geekosaur: so you're telling me you have a handful of lenses?
15:53:18 <Zekka|Sigfig> lens solves problems you don’t have in addition to problems you don’t have, in addition to problems you have
15:53:25 <Zekka|Sigfig> watch out!!!!
15:53:34 <geekosaur> (note, it is worth distinguishing the concept of lenses from ekmett's lens library, which is one (large) realization of the concept. there are others, some quite compact and focused)
15:54:11 <Zekka|Sigfig> I liked microlens pretty much — it’s possible all you need is a -> (b -> a, b) though, without a lot of the crazy polymorphism
15:54:14 <magneticduck1> geekosaur ReinH this page in the ghc user guide doesn't seem to have anything on the bytecode backend in a list of backends: https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/code-generators.html 
15:54:32 <magneticduck1> wonder why
15:54:48 <geekosaur> because it's special
15:54:55 <MichaelK> is there a good rundown comparing the different implementations?
15:55:03 <geekosaur> for one thing, it's impossible to save (or load) bytecode
15:55:17 <geekosaur> all it can do is generate into memory
15:55:24 <geekosaur> so it's not a backend in the normal sense
15:55:39 <mpickering> well as far as I'm concerned lens is by far the best
15:58:14 <MichaelK> mpickering: are there "classy" lenses? or am I missing how they work?
15:58:52 <mpickering> what do you mean exactly?
15:59:46 <MichaelK> I guess I answered my own question: just define a lens with constraints
16:03:15 <scshunt> MichaelK: you may find mkClassy helpful
16:03:27 <scshunt> err
16:03:47 <Zekka|Sigfig> MichaelK: Do you mean like turning Int -> a into Integral i => i -> a?
16:03:52 <scshunt> makeClassy
16:04:49 <Zekka|Sigfig> There’s nothing stopping you from writing a lens (Integral i, Functor f) => (i -> f i) -> a -> f a or something
16:04:51 <MichaelK> <Zekka|Sigfig> yes
16:04:58 <MichaelK> ok
16:06:29 <scshunt> MichaelK: yeah, what s/he said
17:03:06 * hackagebot quickterm 0.1.0.0 - An interface for describing and executing terminal applications  https://hackage.haskell.org/package/quickterm-0.1.0.0 (sgschlesinger)
17:03:30 <tomleb_> I can't figure out how the function spock works in the Spock framework. I'm able to use it like so 'spock (defaultSpockCfg defaultSessionCfg PCNoDatabase ()) $ do ..." 
17:03:59 <tomleb_> I'm also able to replace defaultSessionCfg by "defaultSessionCfg ()"
17:04:21 <tomleb_> But I don't actually understnad any of it
17:04:43 <tomleb_> Could anybody guide me on how to read the documentation ?
17:16:07 <olzhas> How to tell ghc to produce only the executable (without outputting .o or .hi files) ? 
17:16:56 <kadoban> olzhas: I'd probably just get away from running GHC manually. stack or in a pinch cabal-install are better options in any case I've run into.
17:17:17 <kadoban> olzhas: If you just want to run the thing, you can use just runhaskell instead of compiling it too.
17:17:40 <olzhas> kadoban: Can runhaskell do with optimization?
17:18:35 <kadoban> Dunno, I've never run anything with it that I cared how quickly it ran really.
17:19:09 <kadoban> 'stack' has nice ways to just run code, and can do optimizations or whatever you tell it to. You'll have to learn how to do it though a tad.
17:21:22 <olzhas> 'runghc -O2' says its conflicting with '--interactive'
17:22:04 <mgsloan> Yeah, runhaskell uses the interpreter, the code it is applied to is not optimized (deps are tho)
17:23:06 * hackagebot ddc-core-llvm 0.4.2.2 - Disciplined Disciple Compiler LLVM code generator.  https://hackage.haskell.org/package/ddc-core-llvm-0.4.2.2 (BenLippmeier)
17:23:08 * hackagebot ddc-build 0.4.2.2 - Disciplined Disciple Compiler build framework.  https://hackage.haskell.org/package/ddc-build-0.4.2.2 (BenLippmeier)
17:23:10 * hackagebot ddc-driver 0.4.2.2 - Disciplined Disciple Compiler top-level driver.  https://hackage.haskell.org/package/ddc-driver-0.4.2.2 (BenLippmeier)
17:23:12 * hackagebot ddc-tools 0.4.2.2 - Disciplined Disciple Compiler command line tools.  https://hackage.haskell.org/package/ddc-tools-0.4.2.2 (BenLippmeier)
17:32:41 <olzhas> mgsloan: Found the trick : ghc -hidir /tmp -odir /tmp
17:33:04 <olzhas> Thanks for answering folks!
17:34:07 <olzhas> leave
17:34:13 <olzhas> #leave
17:50:47 <watChmeFly> hey guys
17:50:52 <emmanuel_erc> hello watChmeFly
17:51:04 <watChmeFly> How would I go about manipulating a list?
17:51:18 <johnw> first, discover its weaknesses
17:51:20 <watChmeFly> basically user inputs a list of integers and I have to sum those integers
17:51:24 <watChmeFly> lmao
17:51:52 <johnw> :t sum
17:51:53 <lambdabot> (Num a, Foldable t) => t a -> a
17:52:02 <johnw> given a list of integers, that will give you the sum
17:52:15 <watChmeFly> They are comma separated, and I need to break them down if they are multi-digits
17:52:28 <johnw> oh, you need to parse them
17:52:49 <watChmeFly> How would I go about doing that?
17:54:22 <johnw> there are several options, but Parsec is a good place to start
17:54:42 <watChmeFly> ok
17:54:49 <johnw> in fact, there's probably a Parsec tutorial on the web that does something quite similar
17:55:01 <watChmeFly> I'm gonna look into it, I'm sure I'll be back with questions lol
17:55:03 <watChmeFly> thank you
17:55:28 <pavonia> > readMaybe . (\s -> "[" ++ s ++ "]") $ "1, -2, 3, -4" :: Maybe [Int]  -- the lazy man's version
17:55:30 <lambdabot>  Not in scope: ‘readMaybe’
17:55:52 <watChmeFly> Oo
17:59:19 <watChmeFly> Is there a more basic way of doing this?
17:59:24 <watChmeFly> Like traversing the list?
17:59:26 <Lovepon> pavonia: lol
17:59:43 <tomleb_> Anybody familiar with the spock framework ?
17:59:53 <Lovepon> > map read . init . tail $ "1, 2, 3, 4"
17:59:55 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
17:59:55 <lambdabot>      Expected type: [String]
17:59:55 <lambdabot>        Actual type: [Char]
18:00:03 <Lovepon> tomleb_: I kinda am, what about it?
18:00:08 <Lovepon> > map read . init . words $ "1, 2, 3, 4"
18:00:10 <lambdabot>  [*Exception: Prelude.read: no parse
18:00:13 <Lovepon> WHAT?
18:00:16 <Lovepon> Oh, right. The last one.
18:00:17 <watChmeFly> Oo
18:00:54 <Lovepon> Hmmmm
18:00:59 <Lovepon> :t readInt
18:01:00 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
18:01:06 <Lovepon> Hmmm, not that.
18:01:13 <tomleb_> Lovepon: I am having trouble understanding the documentation. All the SpockActionT and ActionCtxT and other variant
18:01:36 <tomleb_> Lovepon: I can't seem to figure out how to put them together, what type my functions should return, etc
18:01:52 <Lovepon> tomleb_: Oh.
18:02:06 <Lovepon> tomleb_: Sorry, can't help with that.
18:02:40 <tomleb_> Lovepon: Alright then .. Thanks
18:03:52 <pavonia> watChmeFly: You could also use functions from Data.List.Split to first get a list of integer strings, and process that in the second step
18:04:40 <watChmeFly> Someone was helping me earlier so I think I have a good chunk done, but the input is a list.  And I don't know how to change that from what I have
18:05:29 <pavonia> Well, what do you have? And what exactly is missing?
18:08:34 <koz_> I have a data structure which is Foldable. If I know that the thing it holds is an Ord, I can implement elem very efficiently. Near-as-I-can-tell, I can either force the Foldable instance to be Ord-constrained (which makes no goddamn sense), or not have that efficient instance at all. Can I have my cake and eat it too in this case?
18:09:07 <Lovepon> I swear, this drawing perfectly depicts howI feel like every time I pull an allnighter. http://eroing.net/img/2016/03/20160121_111_009-757x1024.jpg
18:09:25 <koz_> Lovepon: Not enough bags under the eyes.
18:09:34 <koz_> (and needs more drool)
18:09:40 <Lovepon> watChmeFly: Actually, I know exactly what you need.
18:09:57 <Lovepon> watChmeFly: There was something using unfold, reads, and tails.
18:10:04 <Lovepon> watChmeFly: I forgot the code.
18:12:21 <Lovepon> watChmeFly: I know it exists, but I forgot about it. :|
18:12:54 <watChmeFly> Lovepon, can you look at my code?  I'm having a problem compiling it
18:13:01 <Lovepon> watChmeFly: Sure.
18:13:05 <watChmeFly> Thanks!
18:13:08 * hackagebot category-printf 0.1.0.1 - Highbrow approach to type-safe printf format specifications.  https://hackage.haskell.org/package/category-printf-0.1.0.1 (CaleGibbard)
18:13:18 <watChmeFly> @lpaste
18:13:19 <lambdabot> Haskell pastebin: http://lpaste.net/
18:14:15 <lpaste> watChmeFly pasted “code” at http://lpaste.net/162368
18:16:35 <geekosaur> watChmeFly,you need a condition on line 7, not just the thing to do if line 6 didn't match
18:16:43 <geekosaur> | otherwise = ...
18:16:54 <tomleb_> Lovepon: There's something I'm not sure, does "type HVectElim ([] *) a = a" means that I can just return a and still get a HVectElim something ?
18:17:33 <watChmeFly> -_- thanks lol
18:17:43 <Hijiri> koz_: elem an existing function that isn't an instance method of Foldable, would you be naming this something else?
18:17:52 <Hijiri> If so, just put constraint on your new function
18:18:21 <Lovepon> tomleb_: I'm not an expert or anything, but I think that has something to do with [Path] and generating a corresponding function.
18:18:22 <Hijiri> oh, my bad
18:18:28 <Hijiri> It is an instance method, I didn't know
18:18:34 <tomleb_> Like I'm passing a "(ActionCtxT m ())" but the function wants a HVectElim xs (ActionCtxT m ())
18:18:49 <tomleb_> and it still compiles
18:18:52 <Hijiri> Maybe you could just provide a separate elem function then
18:18:57 <koz_> Hijiri: I'm trying to provide a more efficient implementation of elem than the one that comes by default from Foldable, but I can *only* do it if my a's are instances of Ord.
18:19:15 <lpaste> watChmeFly annotated “code” with “code (annotation)” at http://lpaste.net/162368#a162369
18:19:20 <koz_> What I wanna be able to do is define an elem that uses the efficient one if whatever's in my container happens to be an Ord, and the non-efficient one otherwise.
18:19:27 <Hijiri> I don't think you can do that
18:19:28 <watChmeFly> So how do I make it accept a list now?
18:19:29 <Lovepon> tomleb_: Lol. I know exactly what you mean. That was very very confusing for me, I just accepted it.
18:19:37 <Hijiri> unless you want to add a Typeable constraint, maybe
18:19:38 <Lovepon> tomleb_: Actually, I think I got it.
18:19:40 <koz_> Hijiri: I didn't think so either, but I figured I'd ask first.
18:19:47 <koz_> Hijiri: How would a Typeable constraint help here?
18:19:56 <geekosaur> tomleb_, a `type` is just an alias. it looks to me like it's eliminating a kind tag? in any case, it does assert that (HVecElim whatever a) is the same as a
18:20:18 <Hijiri> I think there is some way with generics or something to do something if it's an instance of a class
18:20:19 <Hijiri> I'm not sure though
18:20:28 <koz_> Hijiri: Would anyone in this chan know?
18:20:31 <koz_> Or be likely to know?
18:20:36 <koz_> I'd love to learn how to do that if it can be done.
18:20:36 <Hijiri> I don't know
18:20:42 <tomleb_> geekosaur: Alright, so that' explains why I can simply return "a" instead of "HVect xs a".
18:20:54 <Lovepon> geekosaur: tomleb_: I'm 80% sure this blog is relevant. http://www.spock.li/2015/04/19/type-safe_routing.html 
18:20:59 <tomleb_> geekosaur: I get confused reading the documentation
18:21:02 <geekosaur> it's eliminating a type-level list as I read it
18:21:55 <Lovepon> geekosaur: tomleb_: `HVectElim '[a,b,c,d] x ≡ a -> (b -> (c -> (d -> x)))`
18:22:27 <hackrilege> http://lpaste.net/162370
18:22:31 <ElMoloko> @watChmeFly according to the type signature, 'a' should be a list, but you're using (<= 0), which requires 'a' to e an instance of Num and Ord
18:22:31 <lambdabot> Unknown command, try @list
18:22:35 <tomleb_> Lovepon: Yeah, I have no idea what that means :/
18:22:40 <linoge> I have Functor A holding an operation that will produce some data through side-effects. What's the best way of running multiple unrelated functions which depend upon the result value of that operation?
18:22:54 <Lovepon> tomleb_: Basically, it's making a list of kinds into a function that returns a.
18:22:55 <Lovepon> Or something.
18:23:21 <hackrilege> ccan someone check my paste? im not sure about associated types or if im doing something really wrong. ot sure if my Free structures can convert to one another...
18:23:23 <geekosaur> watChmeFly, you declare [Integer] -> [Integer] but you're using the parameter a as if it were a number
18:23:25 <watChmeFly> ElMoloko, so how do I change that it checks a is positive
18:23:28 <geekosaur> do you want a number or a list?
18:23:33 <watChmeFly> list
18:23:35 <hackrilege> brb
18:23:42 <koz_> Also, if I have a typical binary tree type, is there a way I can enforce at the type level that for *my* type, its subtrees have to have equal heights?
18:23:51 <koz_> Like, what would the approach be if I wanted to do this?
18:23:59 <ElMoloko> What is 'a' supposed to be, a list or the head of the list?  
18:24:00 <geekosaur> and if a list, in what way did you want to split it into elements and use those elements?
18:24:10 <tomleb_> Lovepon: Humm
18:24:47 <watChmeFly> I wanted to split the integers into individual digits in the list a user inputs
18:24:49 <hackrilege> you could use tuples instead of lists if you want to enforce length?
18:24:50 <tomleb_> Lovepon: Is there any documentation on this ? Lol, I'd need some more explanation because I don't fully understand the concept, and I'm pretty sure it's going to be useful later
18:25:04 <hackrilege> :t (1,(2,(3,())))
18:25:05 <lambdabot> (Num t, Num t1, Num t2) => (t, (t1, (t2, ())))
18:25:13 <Lovepon> tomleb_: Don't have any, sorry.
18:25:38 <tomleb_> Lovepon: Alright, thanks that was useful still, at least I know where to look now
18:25:44 <Hijiri> koz_: So a fully filled binary tree?
18:26:00 <koz_> Hijiri: Basically a perfect tree.
18:26:15 <koz_> I.e. if I have an internal node of height x, its two children must have height x-1.
18:26:20 <ElMoloko> if the latter, doing addDigits a:as, so the head of the list is bound to 'a', and the rest to 'as'
18:26:34 <koz_> (and it must have exactly two)
18:26:59 <Lovepon> tomleb_: Good luck. :)
18:27:14 <watChmeFly> ElMoloko, a is a list
18:27:43 <tomleb_> Lovepon: Yeah, seems I'll need some lol, it's harder than what I anticipated.
18:28:18 <koz_> Also, it seems that for my specialized elem instance, the SPECIALIZE pragma of GHC might work: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html
18:28:22 <koz_> I'll give that a go and see.
18:28:28 <Hijiri> @let data Tree a where { Leaf :: a -> Tree a, Node (Tree a) (Tree a) -> Tree (a,a) }
18:28:28 <lambdabot>  Parse failed: Parse error: ,
18:28:34 <Hijiri> @let data Tree a where { Leaf :: a -> Tree a; Node (Tree a) (Tree a) -> Tree (a,a) }
18:28:35 <lambdabot>  Parse failed: Parse error: (
18:28:45 <Lovepon> tomleb_: Yes, yes it is. :P
18:28:52 <koz_> Hijiri: Are you trying to GADT it up?
18:28:55 <Lovepon> Hijiri: Node ::
18:28:57 <Hijiri> Yeah
18:29:06 <Hijiri> @let data Tree a where { Leaf :: a -> Tree a; Node :: (Tree a) -> (Tree a) -> Tree (a,a) }
18:29:07 <lambdabot>  .L.hs:156:22:
18:29:07 <lambdabot>      Ambiguous occurrence ‘Tree’
18:29:07 <lambdabot>      It could refer to either ‘L.Tree’, defined at .L.hs:155:1
18:29:08 <Hijiri> thanks Lovepon 
18:29:39 <Hijiri> Actually it would probably be better to do something other than pairs
18:29:53 <Hijiri> maybe a Nat-ish type
18:30:16 <emmanuel_erc> Hello there!
18:30:23 <ElMoloko> right, a is a list.  so a <= 0 won't typecheck
18:30:31 <koz_> Hijiri: You mean the type-level natural numbers thing?
18:30:34 <ElMoloko> do (head a) <= 0
18:31:14 <Hijiri> koz_: yeah
18:31:28 <Hijiri> @letlpaste 162371
18:31:30 <lambdabot>  Defined.
18:31:38 <koz_> Hijiri: How would you write something like that into the data definition? I'm a bit unsure of *that* part mainly.
18:31:49 <Hijiri> I posted it here: http://lpaste.net/162371
18:31:58 <Hijiri> :t Leaf
18:31:58 <koz_> Ah, thanks.
18:31:59 <lambdabot> PTree 'Z
18:32:10 <koz_> Does this need GADTs enabled?
18:32:12 <Hijiri> :t Node Leaf Leaf
18:32:13 <lambdabot>     Ambiguous occurrence ‘Node’
18:32:13 <lambdabot>     It could refer to either ‘L.Node’,
18:32:13 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:160:9
18:32:13 <Hijiri> YEah
18:32:18 <Hijiri> Also DataKinds
18:32:22 <koz_> Hijiri: I see.
18:32:25 <Hijiri> :t L.Node Leaf Leaf
18:32:26 <lambdabot> PTree ('S 'Z)
18:32:26 <koz_> I'll giv eit a go, thanks.
18:32:35 <Hijiri> :t L.Node Leaf (L.Node Leaf Leaf)
18:32:36 <lambdabot>     Couldn't match type ‘'S 'Z’ with ‘'Z’
18:32:37 <lambdabot>     Expected type: PTree 'Z
18:32:37 <lambdabot>       Actual type: PTree ('S 'Z)
18:32:45 <Hijiri> so it breaks if it's uneven
18:32:54 <watChmeFly> ElMoloko do you mind jumpting to #haskell-overflow?
18:32:56 <koz_> Hijiri: That's excellent, thank you!
18:33:06 <ElMoloko> ok
18:33:25 <hackrilege> is there a function to convert between Free Monads :: (Monad a,Monad b) => (a x -> b x) -> Free a x -> Free b x
18:33:25 <hackrilege> ?
18:33:38 <koz_> hackrilege: Isn't that just fmap?
18:33:42 <tomleb_> How do I get a kind of [*] ? The first argument of ‘HVectElim’ should have kind ‘[*]’,
18:33:45 <tomleb_>       but ‘[]’ has kind ‘* -> *’
18:34:10 <koz_> (I assume Free is a functor)
18:34:18 <Hijiri> hackrilege: I think that may need to be (forall x. a x -> b x)
18:34:25 <egg_> \python
18:34:29 <egg_> \join python
18:34:35 <egg_> join python
18:34:38 <montanonic> koz_: no, that's a natural transformation
18:34:50 <Lovepon> tomleb_: I'm guessing it's how Haskell works and that they actually got lists correct in type-level.
18:34:53 <hackrilege> not fma koz_, fmap :: Monad a => (a x -> a y) -> Free a x -> Free a y
18:34:53 <Lovepon> egg_: /join pythong
18:34:55 <Lovepon> egg_: /join python *
18:35:11 <koz_> hackrilege: Ah, yes, I see. Sorry about that, I'm still a noob. :(
18:35:16 <Lovepon> tomleb_: [] * probably means construct a list of elements kinded *
18:35:37 <Hijiri> tomleb_: '[] maybe?
18:35:42 <Hijiri> :k '[]
18:35:43 <lambdabot> [k]
18:35:53 <Enigmagic> tomleb_: '[Int] has kind [*]
18:36:08 <Enigmagic> as does '[Int, Int]
18:38:07 <hackrilege> monatonic, am i correct in thinking the bug in http://lpaste.net/162079 is because its trying to do something like (Recurse::(Stack s=>s a -> Free s a)) . (Recurse::(s' a -> Free s' a))
18:38:07 <hackrilege> ?
18:39:00 <tomleb_> Hijiri: Yeah that worked, although I had to add the DataKinds extension. I think I'll just not explicitly write "HVectElim '[] a" and will just write "a" instead."
18:39:42 <hackrilege> i didnt quite get that correct, but basically trying to construct one Free s out of Free s1 and Free s2
18:41:06 <hackrilege> analogous to trying to change list elements from type 'a' to 'b' one at a time, forcing the list to contain two types simultaniously
18:41:41 <hackrilege> i guess i cant just fmap inside the way i was trying, im not sure, is that the bug?
18:41:56 <hackrilege> i cant really understand the types in the error...
18:43:27 <hackrilege> ooops
18:43:27 <hackrilege> http://lpaste.net/162370
18:43:40 <hackrilege> in that one rather
18:45:59 <hackrilege> actually my attempt to cast Free f1 a -> Free f2 a is pretty poor...
18:46:18 <hackrilege> any idea how to define f :: (Monad a,Monad b) => (a x -> b x) -> Free a x -> Free b x
18:46:19 <hackrilege> ?
18:47:12 <aaron> Hey guys
18:47:40 <koz_> Hijiri: The PTree definition you gave me complaints that 'Nat' is an illegal kind signature.
18:48:09 * hackagebot fast-tagsoup 1.0.10 - Fast parser for tagsoup package  https://hackage.haskell.org/package/fast-tagsoup-1.0.10 (VladimirShabanov)
18:48:12 <Guest45348> I have some trouble with my xmonad.hs. Does somebody have time to give me a hint
18:48:16 <Guest45348> ?
18:48:32 <koz_> Guest45348: Just ask. If someone knows and/or has time, they'll answer.
18:49:18 <Hijiri> koz_: You need the KindSignatures extension turned on too
18:49:27 <Hijiri> I think you can also omit the signature
18:49:36 <koz_> Hijiri: Ah, OK.
18:50:30 <geekosaur> Guest45348, there is also #xmonad
18:51:16 <Guest45348> When I start my xsession with xmonad, I get some errors after I updated my Debian stable
18:51:59 <Guest45348> Saying that I am using deprecated packages
18:52:25 <geekosaur> those are warnings, and many of them can be ignored
18:52:30 <koz_> Guest45348: I suspect that this is a Debian stable issue, not an XMonad one.
18:52:42 <koz_> Debian stable *really* takes conservatism in package updates to a new level.
18:52:59 <geekosaur> some things are there because xmonad uses older packages for backward compatibility, since there are still some people using it on older systems with older ghc
18:53:28 <geekosaur> there's also a new (and to my mind highly misguided) deprecation of various defaults in favor of the badly behaved Data.Default mechanism
18:53:54 <geekosaur> so it whines if you talk about defaultConfig, defaultPP, etc. that were the way you did things before 0.10
18:54:14 <Guest45348> Oh, that sounds exactly like the problem I have
18:54:19 <Clint> geekosaur: how does Data.Default behave badly?
18:55:38 <geekosaur> (1) you lose an element of type safety, since if you say `def` you get whatever one works there --- which may not be the one you expected if you have a typo somewhere else and don't specify type signatures religiously
18:55:48 <Guest45348> @geekosaur It sounds like you have experience with that, do you know a way to solve problems of this kind?
18:55:48 <lambdabot> Unknown command, try @list
18:55:58 <geekosaur> (2) `def` for types like Int has a value that may or may not make sense as a default
18:56:50 <geekosaur> Guest45348, are you actually seeing an *error*? the deprecation messages are all warnings; if you have an actual error, focus on that first
18:57:17 <geekosaur> look in ~/.xmonad/xmonad.errors for compile time errors, ~/.xsession-errors for anything failing at runtime
18:57:30 <Guest45348> Alright, I'll be back
18:57:54 <Guest45348>  
18:57:55 <Guest45348> xmonad.hs:111:13: Warning:
18:57:55 <Guest45348>     In the use of `defaultTheme'
18:57:55 <Guest45348>     (imported from XMonad.Layout.Tabbed, but defined in XMonad.Layout.Decoration):
18:57:58 <Guest45348>     Deprecated: "Use def (from Data.Default, and re-exported by XMonad.Layout.Decoration) instead."
18:58:03 <Guest45348>  
18:58:06 <Guest45348> xmonad.hs:366:12: Warning:
18:58:09 <Guest45348>     In the use of `defaultConfig'
18:58:09 <Guest45348>     (imported from XMonad, but defined in XMonad.Config):
18:58:10 <geekosaur> (1) please use a pastebin
18:58:12 <Guest45348>     Deprecated: "Use def (from Data.Default, and re-exported by XMonad and XMonad.Config) instead."
18:58:15 <Guest45348> /usr/bin/ld: cannot find -lXinerama
18:58:19 <Guest45348> /usr/bin/ld: cannot find -lXrandr
18:58:22 <Guest45348> collect2: error: ld returned 1 exit status
18:58:25 <Guest45348>  
18:58:28 <Clint> well those would be important
18:58:40 <geekosaur> the ones from /usr/bin/ld are the actual errors
18:58:49 <geekosaur> also please don't paste that into the channel, use a pastebin
18:59:03 <geekosaur> there's a spambot that has already klined someone today for a large paste...
18:59:31 <Guest45348> oh, thanks for telling me
18:59:49 <Clint> Guest45348: do you not have libghc-xmonad-dev installed?
19:00:25 <geekosaur> that's not the problem
19:00:29 <geekosaur> those are X11 devel libraries
19:00:39 <geekosaur> I'm looking for the package names on my ubuntu
19:01:26 <Clint> geekosaur: libghc-xmonad-dev should depend on libxinerama-dev
19:01:28 <Guest45348> Is there a way to use pastebins from the commandline?
19:01:32 <Clint> though not libxrandr-dev, apparently
19:01:51 <geekosaur> Clint, what if they installed from cabal to get something mreo recent than the ancient xmonad debian packages?
19:02:17 <Clint> geekosaur: well then the answer to my question would be "no"
19:02:21 <geekosaur> Guest45348, sudo apt-get install libxinerama-dev libxrandr-dev
19:03:13 <geekosaur> and there's a pastebinit package. plase don't use pastebin.com though, it's blocked where I am (and many other places)
19:04:16 <Guest45348> Obviously I did not have these packages, so we will see in a few second if that works
19:04:55 <Guest45348> Wow, it works.
19:05:27 <Guest45348> Thanks a lot geekosaur, you saved me many hours of searching
19:05:40 <Guest45348> And thanks to all the others for discussing as well
19:06:29 <Guest45348> I will have a look at the pastebinit package in case I need help in this channel again!
19:08:09 * hackagebot category-printf 0.1.0.2 - Highbrow approach to type-safe printf format specifications.  https://hackage.haskell.org/package/category-printf-0.1.0.2 (CaleGibbard)
19:16:26 <hackrilege> i have started writing castFree here
19:16:26 <hackrilege> http://lpaste.net/162380
19:17:05 <hackrilege> currently it does not use f
19:30:40 <hackrilege> i have encountered the error again
19:30:40 <hackrilege> http://lpaste.net/162380
19:31:16 <hackrilege> can somebody help explain this error/
19:31:16 <hackrilege> ?
19:33:05 <hackrilege> i cant understand what went wrong, castFree works fine with f in global scope, but whe its supplied as an argument it breaks...
19:37:06 <hackrilege> this bug has me stumped; http://lpaste.net/162380 its a minimal paste i wrote especially.
19:43:48 <hackrilege> anyone
19:43:49 <hackrilege> ?
19:44:44 <hackrilege> i cant see why the version in comments breaks but the other one works...
19:44:45 <hackrilege> data Free f a = Basecase a | Recurse (f (Free f a)) 
19:44:46 <hackrilege> instance (Foldable f,Show a) => Show (Free f a) where
19:44:46 <hackrilege>  show (Basecase a) = show a
19:44:46 <hackrilege>  show (Recurse  a) = concatMap show a
19:44:46 <hackrilege> data List1 a = List1 [a]
19:44:46 <hackrilege> data List2 a = List2 [a]
19:45:48 <hackrilege> woah! sorry, i didnt know that was what was in my clipboard....
19:47:10 <pavonia> hackrilege: I think the problem is that f is more general than the value you apply it to
19:47:45 <ClaudiusMaximus> hackrilege: http://lpaste.net/162380#a162384
19:54:48 <hackrilege> thanks ClaudiusMaximus!!
19:57:11 <ClaudiusMaximus> hackrilege: the issue was that you used f twice, at different types each time - one :: x a -> y a, the other :: x (Free x a) -> y (Free y a)
20:01:16 <emmanuel_erc> Hello there. Is anyone here familiar with using Zippers on Maps (from Data.Map)
20:02:08 <hackrilege> aha
20:03:10 <hackrilege> ClaudiusMaximus, any idea how i should get it to work in this instance?
20:03:10 <hackrilege> http://lpaste.net/162385
20:03:23 <hackrilege> similar problem with different defaults of toZipper perhaps?
20:06:46 <ClaudiusMaximus> hackrilege: maybe a missing constraint - it needs Zipable, right?
20:07:42 <hackrilege> hmmm
20:07:50 <hackrilege> im not sure its that
20:08:04 <hackrilege> also im not sure how the f's had different type in the previous paste..
20:08:14 <ClaudiusMaximus> maybe i'm confused, late here
20:10:38 <yogurt_melt> does anyone else have issues with haskell-mode syntax highlighting failing when using long quasiquote blocks?
20:12:22 <hackrilege> i think the compiler agrees with you, its me thats confused
20:27:04 <geekosaur> yogurt_melt, lots of things confuse editors' syntax highlighting
20:27:30 <Mateon1> I have a quick question, where does cabal install binaries to? It isn't on my Windows PATH
20:28:03 <geekosaur> quasiquotes wouldn't surprise me; anything that "changes the rules" in the middle generally confuses editor syntax highlighting (standalone syntax highlighting can use an actual parser, editors fake it and it shows)
20:28:40 <hackrilege> am i forced to define an infinite number of functions of type e.g. [a] -> Free [] a, [[a]] -> Free [] a,[[[a]]] -> Free [] a e.t.c.....
20:28:42 <hackrilege> ?
20:29:53 <hackrilege> pretty sure i am, just want a second opinion
20:33:03 <geekosaur> Mateon1, %APPDATA%\cabal\bin
20:34:08 <Mateon1> geekosaur: Thank you, odd that my msys built cabal installs to the windows directory, though.
20:34:21 <erisco> can I  | Just x <- m && f x   somehow?
20:34:26 <geekosaur> some googling suggests that's actually somewhat common
20:34:49 <geekosaur> the path is set based on "I'm on Windows" without regard to msys, is my guess
20:36:02 <hackrilege> isnt there a language pragma which could allow me to "construct the infinite type: a ~ [a]"
20:36:02 <hackrilege> ?
20:36:02 <hackrilege> so that i could write;
20:36:02 <hackrilege> data Free f a = Basecase a | Recurse (f (Free f a))
20:36:02 <hackrilege>  list' 0 l = (Recurse.(map Basecase)) l
20:36:02 <hackrilege>  list' n l = foldr (mplus. (list' (n-1))) empty l
20:36:03 <geekosaur> erisco, not like that I suspect. ```Just x <- fmap f m``` maybe?
20:36:26 <geekosaur> hackrilege, no, there is no pragma for that
20:37:11 <hackrilege> so how am i supposed to work in high dimensions!?
20:38:09 <hackrilege> i mean, to convert from eg [[[[[[[[[[[[[[[[a]]]]]]]]]]]]]]]] -> Free [] a
20:38:41 <hackrilege> no integer paramatrised types in haskell...
20:38:53 <hackrilege> my approach is dead
20:39:08 <Hijiri> if a ~ [a], then a would have to be a list too
20:39:20 <geekosaur> erisco, actually it looks like: | Just x <- m, f x
20:39:21 <hackrilege> a is Free x a
20:39:36 <geekosaur> (maybe)
20:40:01 <hackrilege> Basecase a :: Free _ a
20:40:27 <yogurt_melt> geekosaur shouldn't haskell-mode it be able to identify the [blah| and |] pattern and ignore everything in between?
20:40:33 <geekosaur> scratch the maybe, the summary actually says that is valid
20:40:44 <yogurt_melt> don't see how it's different than a multi-line comment
20:41:19 <geekosaur> yogurt_melt, no. editors don't parse. they typically use regexes, and the regex that matches that *and isn't confused by stuff in the middle* either doesn't exist or is too expensive to consider using
20:41:25 <geekosaur> one regex for start, one for end.
20:41:43 <geekosaur> and yes certain kinds of multiline comments confuse editors too (the ones that allow nesting)
20:41:45 <ClaudiusMaximus> hackrilege: one trouble with   class Freeify a where freeify :: [a] -> Free [] a  ; instance Freeify a where freeify = base case ; instance Freeify [a] where freeify = recursive case  is that it all overlaps terribly.. and doesn't know when to stop if you don't want to unwrap all list constructors, and i don't know if it'd work at all
20:42:10 <geekosaur> yogurt_melt, editors are *dumb* about syntax highlighting
20:42:26 <geekosaur> (they have to be, they need to get it done quickly so users don't complain.)
20:42:48 <yogurt_melt> geekosaur this is kind of bumming me out on the power of DSLs :/
20:43:12 * hackagebot monad-ste 0.1.0.0 - ST monad with efficient explicit errors  https://hackage.haskell.org/package/monad-ste-0.1.0.0 (CarterSchonwald)
20:43:26 <ClaudiusMaximus> hackrilege: oops second instance needs a Freeify a =>
20:43:40 <hackrilege> awesome ill try it it looks good thanks
20:43:58 <yogurt_melt> what good is an expressive DSL if the productivity is negated by a cumbersome programmer interface?
20:44:49 <erisco> geekosaur, thanks
20:47:22 <hackrilege> Basecase :: a -> Free _ a
20:47:33 <ClaudiusMaximus> hackrilege: i don't recommend it, really - maybe as a quick hack to get something working, but really writing functions for each type would be preferable (or possibly using type level natural numbers to control nesting depth, maybe with reflection package to allow nesting depth to be specified from an Int or similar
20:47:52 <hackrilege> oooh type level natural numbers lets do that
20:48:13 * hackagebot network-conduit-tls 1.2.1 - Create TLS-aware network code with conduits  https://hackage.haskell.org/package/network-conduit-tls-1.2.1 (MichaelSnoyman)
20:48:13 <ClaudiusMaximus> hackrilege: but that gets deep into RankN hackery which sorta forces CPS-ing all the things (unless i've been doing it wrong)
20:48:33 <hackrilege> i need to do this reflection package thing unfortunately
20:48:52 <hackrilege> CPS-ing?
20:49:24 <ClaudiusMaximus> instead of foo :: a -> b, you have foo :: a -> (b -> r) -> r  or similar
20:50:00 <ClaudiusMaximus> and you can't just supply id because the skolems escape
20:50:14 <hackrilege> argh my mind, i just looked at Data.Reflect
20:50:16 <hackrilege> sad times
20:57:27 <hackrilege> @let data Free f a = Basecase a | Recurse (f (Free f a))
20:57:28 <lambdabot>  Defined.
20:58:26 <hackrilege> @let myInt n a = if n == 0 then Basecase a else Recurse (myInt (n-1) a))
20:58:26 <lambdabot>  Parse failed: Parse error: )
20:58:31 <hackrilege> @let myInt n a = if n == 0 then Basecase a else Recurse (myInt (n-1) a)
20:58:32 <lambdabot>  .L.hs:169:45:
20:58:33 <lambdabot>      Occurs check: cannot construct the infinite type: f ~ Free f
20:58:33 <lambdabot>      Expected type: f (Free f a1)
21:05:05 <hackrilege> @let myInt n a = if n == 0 then Basecase a else Recurse [myInt (n-1) a]
21:05:07 <lambdabot>  Defined.
21:05:22 <hackrilege> > myInt 2 '2'
21:05:24 <lambdabot>      No instance for (Show (Free [] Char))
21:05:24 <lambdabot>        arising from a use of ‘show_M321020677096104062623219’
21:05:24 <lambdabot>      In the expression:
21:05:30 <hackrilege> nvm
21:11:22 <hackrilege> foo 13 = foo13
21:14:51 <hackrilege> import Hack.Foo13
21:15:42 <krmine> hey so you know how a lot of smartphones can be bought thru a single carrier or unlocked
21:16:18 <krmine> if you buy it through a single carrier like verizon then will the phone come preinstalled with bloatware from verizon
21:16:34 <hackrilege> what has that got to do with haskell?
21:16:37 <shachaf> krmine: This is not the channel for that.
21:17:02 <krmine> does anyone know an IRC to ask this lol
21:17:19 <hackrilege> also not a haskell issue sorry
21:17:46 <hackrilege> its literally impossible for us to consider anything else...
21:18:23 <hackrilege> i would need to uninstall ghci from my brain its taking up too much ram
21:18:52 <MichaelK> Hi, how do I combine a `Getter s a` and a `Setter s t a b` into a `Lens s t a b`? (I'm not sure I have the parameters right). I know of `lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b` but I'm not sure it's the best/most efficient?
21:19:29 <shachaf> That is an odd operation.
21:19:42 <shachaf> Typically you would write the lens yourself directly, not out of those pieces.
21:21:46 <MichaelK> shachaf: hmm. I began with code that split cleanly into getter and setter so that's how I ended up here
21:22:14 <jle`> yeah, it might be worth refactoring your code to write the lens itself, and get the getter and setter for free
21:23:32 <MichaelK> jle` well the getter and setter each have their own class, with fundeps. I've tried combining (before I decided to convert it to a lens), but ghc seems to get picky about the types
21:24:58 <jle`> if we don't know anything more about the type itself, using the 'lens' function (or, equivalently, inlining the definition of 'lens') is probably close to as good as one can suggest without any more information.
21:25:55 <MichaelK> one sec..
21:27:09 <lpaste> MichaelK pasted “class example” at http://lpaste.net/162396
21:27:24 <MichaelK> jle` that's the relevant snippet
21:34:25 <hackrilege> i think these are having trouble resolving instances, can anyone help, i dont know the syntax to resolve the toZipper, i think thats why it freezes... http://lpaste.net/162397
21:35:44 <Cale>  instance Freeify a where 
21:35:44 <Cale>   freeify = Basecase
21:35:49 <Cale> ^^ that instance is bad
21:37:15 <MichaelK> Cale: looks like a good use for https://ghc.haskell.org/trac/ghc/ticket/9334 (instance chains)
21:38:48 <hackrilege> its in comments Cale its just old dead code.. shouldnt be there sorry
21:39:08 <Cale> Oh, I see, you're using literate haskell
21:41:11 <hackrilege> im slightly closer having rewritten ZipperN in terms of Free, just having problems, dont know why it jams...
21:42:27 <hackrilege> is it because the instances are bare?
21:43:30 <Cale> oh, well, the Show instance is missing, yeah
21:44:07 <Cale> You gave it an empty instance, which will just cause show to loop, because it's defined recursively in a way that expects you to make a definition and break the cycle.
21:44:16 <hackrilege> BRAAARG
21:44:22 <hackrilege> so dumb
21:44:24 <hackrilege> !!
21:44:34 <hackrilege> thanks
21:44:52 <Cale> If you use newtype, you can probably derive all those instances you want
21:44:59 <hackrilege> hmmm
21:45:19 <hackrilege> i was wondering about those redundant constructors...
21:46:07 <hackrilege> can i get rid of them with newtype also?
21:46:29 <hackrilege> im using type now if i remember to avoid such excess Constructors
21:47:48 <Cale> You still have to write data constructors with newtype in your code, but they don't exist at runtime
21:48:03 <hackrilege> riiigh
21:48:04 <hackrilege> t
21:48:34 <hackrilege> so why can i derive over newtype but not data?
21:49:05 <hackrilege> nooo the problem with deriving Free
21:49:09 <yogurt_melt> geekosaur hmm atom seems to grok quasiquotes fine where emacs haskell-mode seems to choke
21:49:14 <hackrilege> is with*
21:50:08 <hackrilege> eg data (Show (f (Free f a)),Show a) =>
21:50:17 <hackrilege> recursive
21:50:52 <hackrilege> cant quite remember... what were you surgesting?
21:51:03 <Cale> hackrilege: Because GeneralizedNewtypeDeriving just applies the instance for the underlying type
21:51:28 <hackrilege> oh i see
21:51:32 <Cale> newtypes are guaranteed to have only one field with one constructor, and are guaranteed to behave in a perfectly isomorphic way to the original type
21:51:33 <hackrilege> ok thats brilliant
21:51:56 <hackrilege> where was this in my code? ZipperN?
21:52:12 <Cale> yeah
21:52:23 <Cale> really, you just want a newtype of Free
21:52:30 <hackrilege> yes
21:52:53 <hackrilege> thanks that saves a lot of syntax
21:57:30 <hackrilege> all my instances are over Free []
21:59:22 <hackrilege> im tempted to write heavily overlapping instances for Free s
22:01:26 <hackrilege> thats not a bad idea surely?
22:02:04 <hackrilege> its basically a simple extension to newtype deriving...
22:03:14 <apricity> what's a good haskell book other than learn you a haskell for great good?
22:03:48 <hackrilege> the craft of functional programming
22:04:50 <hackrilege> http://www.cin.ufpe.br/~jml/haskell-the-craft-of-functional-programming-2nd-edition.9780201342758.23997.pdf
22:05:43 <KaneTW> haskellbook.com is real good
22:05:55 <hackrilege> i would be sure all this Free deriving stuff would have been covered before...
22:06:41 <Cale> apricity: these lectures are reasonable http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html and there's http://haskellbook.com/
22:08:08 <shachaf> Cale: Have you read it?
22:27:27 <moplove> what's the recommended way to do small amounts of text parsing these days? Last time I was interested in regexes, the conventional wisdom was to use Parsec instead.
22:30:34 <zRecursive> @where attrparsec
22:30:35 <lambdabot> I know nothing about attrparsec.
22:32:45 <kadoban> moplove: Pretty much the same story now. There's other ones, like attoparsec, trifecta, and I think megaparsec? I don't really know much about the differences between them, except attoparsec is kind of a lower level parsec with worse error messages but generally better performance if you don't need the advanced features of parsec.
22:33:52 <moplove> awesome, thanks for the info!
22:34:09 <moplove> so if I don't care about performance, would Parsec be the recommended way to go, then?
22:34:26 <moplove> I've seen that some packages use attoparsec, but don't know anything about it, and haven't heard of the others, myself
22:38:12 <kadoban> moplove: parsec is the one I've used. I haven't used the other ones enough to know really. I'd avoid attoparsec if you aren't optimizing for performance, but other than that …
22:39:38 <moplove> cool. Yeah I've used Parsec some and while I wouldn't say I know it that well, I do like a lot of the features it has that I've dealt with so far
22:40:46 <kadoban> Yeah I'd say it's not a bad choice to keep using it then, unless someone more knowledgeable about the alternatives pipes up.
22:43:17 * hackagebot riak 1.0.1.1 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-1.0.1.1 (lambda_foo)
22:45:58 <moplove> kadoban: thanks for the advice ^_^
22:46:27 <kadoban> Sure :)
22:51:51 <geekosaur> megaparsec is parsec with bug fixes and better errors
22:52:34 <kadoban> geekosaur: Is it pretty much just better than parsec then?
22:52:43 <geekosaur> yes
22:53:05 <geekosaur> should be 100% compatible aside from different module names
22:53:06 <joehillen> megaparsec is better than parsec for sure
22:53:15 <kadoban> Ah, good to know. moplove ^
22:53:16 <moplove> I'll check out megaparsec, then
22:53:38 <joehillen> megaparsec has different parser names 
22:54:00 <geekosaur> oh, they are different? sigh. was advertised as drop-in...
22:54:46 <joehillen> they're improvements, like "some" instead of "many1"
22:55:09 <geekosaur> ah. I was thinking types. no backward compatibility names?
22:55:33 <joehillen> it's just minor stuff. it's not a big deal to migrate
22:55:40 <geekosaur> I could easily see someone wanting to swap from parsec, making it harder to do that seems pointless
22:55:52 <Cale> shachaf: I haven't
22:56:14 <joehillen> it's not pointless
22:58:42 <moplove> I definitely see the point of improving the names of things, especially in a language like Haskell tbh
23:00:18 <joehillen> I recently learned about hspec-megaparsec which is handy
23:00:49 <moplove> that's another thing I need to learn, hspec or hunit (though at the moment I'm leaning towards hspec)
23:02:54 <joehillen> I didn't like Spec-style testing when I did imperative, but I prefer it in FP. Feels natural.
23:03:18 * hackagebot snaplet-riak 0.2.1.0 - A Snaplet for the Riak database  https://hackage.haskell.org/package/snaplet-riak-0.2.1.0 (lambda_foo)
23:03:33 <geekosaur> I didn't say renaming was pointless. I said no backward compatibility was
23:03:57 <geekosaur> stick 'em in a Compat module if they offend you, but provide the option at least
23:04:52 <joehillen> I don't get why everyone is so hung up on backwards compatibility in Haskell. We have the compiler to tell you what to change, just fix the errors.
23:05:48 <Hijiri> educational materials could become out-of-date when large library/language changes happen
23:05:59 <Hijiri> that usually takes longer to fix
23:06:09 <joehillen> that's true of all documentation
23:06:17 <moplove> geekosaur: that renaming is pointless is a consequence of your claim that no backwards compatability is pointless, because the point of the no backwards compatability was better names
23:06:23 <joehillen> which is why doctests are essential
23:06:40 <joehillen> rust will give you a warning if you don't have doctests :)
23:28:48 <chester> how do I turn off join / quit notifications?
23:28:55 <thimoteus> depends on your client
23:29:17 <chester> I am using this on chrome
23:30:09 <Ashy> qwebirc according to ctcp: http://wiki.xkcd.com/irc/Hide_join_part_messages#qwebirc
23:30:12 <chester> first time using webchat, excuse me
23:30:36 <Ashy> (that should work regardless of the fact you're not on the xkcd server)
23:32:07 <apricity> is vim or emacs more generally used for haskell dev
23:32:28 <chester> thank you
23:33:22 <kadoban> apricity: I hear of people using both. I don't know that anyone has done a poll.
23:35:06 <bheet> haskell is awesome
23:42:17 <zRecursive> Why haskell sucks ? https://dl.dropboxusercontent.com/u/40457956/haskell_sucks.pdf
23:44:43 <simpson> zRecursive: Don't worry about it; plenty of things suck.
23:45:21 <zRecursive> simpson: sure
23:45:53 <zRecursive> In fact, i really donot know what "sucks" means.
23:46:37 <zRecursive> The author said he likes haskell too
23:47:15 <simpson> zRecursive: It's an American English-specific usage; it means that something is considered poor or unfit for use.
23:47:53 <zRecursive> yeah
23:57:55 <Ashy> haskell sucks because there's no framework to get up and running writing native android/ios apps currently
23:58:23 <Ashy> it'd be awesome if someone could write/fund a framework for that
23:58:38 <Ashy> (not just a compile to js and run in a webview thing either)
23:58:41 <ralu> TL:DR: haskell sux, because it uses mondas and is lazy
23:59:27 <simpson> Set is not a Monad.
