00:25:57 <Tekkkz> I try to build Cabal and cabal-install from sources. In Cabal dir, I do »make install« with following error: http://ix.io/Ll4 But in ghci, i can load these libraries. What went wrong?
00:31:06 <Cale> Tekkkz: it's trying to do a profiling build for some reason, and mysteriously the profiling libraries for base (which are meant to come with GHC) are not installed.
00:31:07 <oherrala> ssmith: you can't rename files to another partition?
00:31:15 <oherrala> ssmith: you probably need to move it
00:33:47 <lpaste> koz_ pasted “A question about Applicative” at http://lpaste.net/164578
00:35:34 <Cale> koz_: you're using the Applicative instance for (->) Clause
00:35:51 <Cale> i.e. f t = Clause -> t
00:36:08 <koz_> Cale: Ah, OK.
00:36:13 <koz_> Reader Monad, right?
00:36:19 <Cale> yeah
00:36:27 <koz_> That's pretty cool.
00:36:47 <koz_> It's weird - I could 'downgrade' it to Applicative from Monad without really knowing what I was working with.
00:38:06 <hc> hi
00:38:16 <koz_> hc: Sup?
00:38:41 <hc> I have a long running application. If I compile it with profiling and run it with +RTS -p -RTS, memory and cpu usage will stay constant for weeks
00:39:07 <hc> If, however, I compile it without profiling, memory usage will grow slightly, but CPU usage will increase dramatically, like sometimes needing 30% CPU when the application is idle
00:39:17 <hc> It is a Warp WAI server... not open source, however
00:39:28 <hc> I was wondering if you could give me some hints as to where to look
00:39:48 <koz_> hc: Are you compiling with or without optimizations?
00:39:54 <hc> -O2
00:40:48 <hc> -O2 -threaded -rtsopts -with-rtsopts=-N
00:43:07 <hc> build system is stack, with lts-5.17
00:43:33 <hc> the application stays responsive all the time
00:43:40 <hc> even when it uses a lot of cpu when idle
00:43:52 <hc> it also doesn't seem to be directly related to the number of requests it receives
00:44:06 <hc> no global state is kept, other than a database pool...
00:55:12 <Tekkkz> Cale, what should i do?
00:57:05 <EvanR> haskell's real killer app... colored ghci
01:05:52 <hamishmack> hvr: Hi
01:06:13 <hamishmack> Should I split the library component out of gtk2hs-buildtools?
01:20:58 <Cale> Tekkkz: I'm not really sure. How did you install GHC? Perhaps there's a different way to get it?
01:33:32 * hackagebot xdot 0.3.0.1 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  https://hackage.haskell.org/package/xdot-0.3.0.1 (DennisFelsing)
01:42:19 <tsahyt> Hello, I have a question about returning a C array via a function exported through the FFI. If I allocate storage on the heap in Haskell using an appropriate function (from Foreign.Marshal.Alloc), can I use free on the C side without running into problems?
01:43:32 * hackagebot stratux 0.0.1 - A library for stratux  https://hackage.haskell.org/package/stratux-0.0.1 (TonyMorris)
01:43:32 <tsahyt> actually Foreign.Marshal.Array has functions that look more like what I need, but anyway the question remains
01:45:49 <Lisa1157> I am looking at the following SO post http://stackoverflow.com/questions/16459484/how-to-solve-logical-formulas-in-haskell and cant figure out what 'any (satisfiable . f . Con) xs' does..?
01:47:00 <EvanR> tsahyt: no you cant
01:47:18 <tsahyt> EvanR: so how can I ever return an array without creating a memory leak?
01:47:32 <EvanR> allocate memory on the C side and return a pointer
01:47:39 <tsahyt> I don't know the size in advance
01:47:47 <EvanR> or allocate memory on the haskell side, pass the pointer to C, and then free in in haskell
01:47:56 <EvanR> using allocaArray
01:47:59 <tsahyt> why does this not work?
01:48:13 <EvanR> its two different runtime systems
01:48:24 <EvanR> your array lives in one or the other
01:48:30 <tsahyt> but the FFI just calls malloc underneath
01:48:35 <tsahyt> at least as far as I can tell
01:48:35 <EvanR> no
01:48:59 <EvanR> can you explain again why both of my suggestions wont work?
01:49:56 <tsahyt> I can't allocate in C and pass it to haskell because the size is unknown at that point. And I can't free it in Haskell without starting to keep track of internal state on the haskell side which starts getting majorly painful at that point
01:50:09 <tsahyt> tbh I'd rather have the thing just leak memory instead
01:50:20 <EvanR> you usually allocate, use, then free in one bracket pattern on the haskell side
01:50:31 <EvanR> after you get it out of the array and into a normal value
01:50:53 <tsahyt> That's what I'd do if I was calling C from Haskell, yes
01:50:58 <EvanR> im still not clear when you *do* know how big it needs to be
01:51:02 <tsahyt> but I'm calling Haskell from C
01:51:12 <tsahyt> I
01:51:38 <tsahyt> I know it inside of the haskell function, which is getting called from C. So I can't allocate the array in advance.
01:51:55 <EvanR> then you can use a ForeignPtr 
01:53:29 <EvanR> maybe not
01:55:31 <tsahyt> I'm still not sure in which way the Haskell RTS manages Ptrs that are created by the functions in Foreign.Marshal.Alloc. Internally, the appropriate C functions from stdlib.h are called. There's not much more magic to that.
01:55:43 <EvanR> one thing you can do is provide haskell with a callback to allocate memory on your side, and use that to return the pointer to your own memory
01:55:44 <Lisa1157> Where can I find info on the dot operator in the following code 'any (satisfiable . f . Con) xs' ? http://stackoverflow.com/questions/16459484/how-to-solve-logical-formulas-in-haskell 
01:56:43 <tsahyt> the value of the Ptr itself is managed, but the memory region on the heap that it points to doesn't seem to be. Otherwise the whole concept of manual allocation would be worthless anyhow
01:57:15 <tsahyt> http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Foreign.Marshal.Alloc.html#malloc See bottom of this page
01:58:31 <lyxia> Lisa1157: it's just function composition: any (\x -> satisfiable (f (Con x))) xs
01:58:56 <EvanR> tsahyt: youre right... `malloc' just calls malloc. 
01:59:13 <tsahyt> so if I understand this right, I should be able to just free it in C then
01:59:14 <EvanR> it gives you a pointer to memory not managed by GHC
01:59:56 <EvanR> i guess you cant, but thats still not too typical to do 
02:00:01 <EvanR> er i guess you can
02:00:18 <EvanR> when you get a pointer back from a library who has allocated memory, you usually have a corresponding library free
02:00:29 <EvanR> even if it would work to just free it with free
02:00:41 <tsahyt> just to give you some context for this insanity, I'm implementing a plugin for an application written in C++ using Haskell. Plugins are shared objects implementing a certain C style API, and this API needs to work for languages other than Haskell too.
02:01:10 <EvanR> so it sounds safer to include a "library free" endpoint for your plugin api
02:01:24 <tsahyt> I guess that'd be an option yes
02:01:35 <EvanR> in haskell it would just use Foreign.Marshal.Alloc `free'
02:02:06 <EvanR> this would allow you to handle objects returned from languages that cant use direct malloc
02:02:59 <EvanR> maybe not since they might GC your object before you get a chance to use it
02:03:31 <EvanR> in which case you need a protocol like, heres a buffer, if its not big enough return -1 so i can expand and try again
02:04:32 <tsahyt> I think I'll tighten the requirement to "languages that can behave like C when necessary"
02:04:53 <tsahyt> there's a separate plugin API for interpreted languages anyhow
02:05:12 <tsahyt> which works somewhat differently because it runs the interpreter from C++ and then just calls functions in the supplied script
02:06:27 <koz_> Why does HLint warn me about orphan instances?
02:07:08 <EvanR> because you didnt disable that warning
02:07:18 <koz_> EvanR: Is this a warning I should care about?
02:07:31 <EvanR> orphaned instances in a application are OK
02:07:54 <EvanR> but cause problems if they are defined in a library
02:08:18 <tsahyt> except for when it's a library with the purpose of providing orphan instances
02:08:29 <tsahyt> vector-instances for example
02:08:52 <koz_> EvanR: Why are orphaned instances problematic in a library?
02:11:13 <tsahyt> koz_: when you have two libraries exporting orphan instances you can end up with multiple instances, say Monoid Int under addition and Monoid Int with multiplication. you can't specify which one you want either and instances are always exported from a module. this can lead to some headaches.
02:13:14 <koz_> tsahyt: Oh, right.
02:13:17 <koz_> That makes sense, thanks.
02:16:29 <hexagoxel> is there any code around making use of indexed monads?
02:17:31 <lemonxah> how to divide 2 Ints and get a Fractional Int from it?
02:17:42 <lemonxah> No instance for (Fractional Int) arising from a use of ‘/’
02:18:33 * hackagebot NetSNMP 0.3.2.2 - Bindings for net-snmp's C API for clients  https://hackage.haskell.org/package/NetSNMP-0.3.2.2 (PavloKerestey)
02:19:50 <EvanR> what is a fractional Int
02:20:00 <EvanR> > divMod 77 13
02:20:02 <lambdabot>  (5,12)
02:20:17 <EvanR> > 77 % 13
02:20:19 <lambdabot>  77 % 13
02:20:47 <EvanR> > (realToFrac 77) / (realToFrac 13)
02:20:49 <lambdabot>  5.923076923076923
02:21:41 <EvanR> > :t let x // y = realToFrac x / realToFrac y in (//)
02:21:43 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:21:48 <EvanR> :t let x // y = realToFrac x / realToFrac y in (//)
02:21:49 <lambdabot> (Fractional a, Real a1, Real a2) => a1 -> a2 -> a
02:22:21 <EvanR> let x // y = realToFrac x / realToFrac y in (77::Int) // (13::Int)
02:22:23 <EvanR> > let x // y = realToFrac x / realToFrac y in (77::Int) // (13::Int)
02:22:25 <lambdabot>  5.923076923076923
02:22:44 <EvanR> boffo
02:22:53 <lemonxah> yes thank you i ended up using fromIntegral
02:22:55 <tsahyt> > 77 % 13
02:22:57 <lambdabot>  77 % 13
02:23:03 <tsahyt> :t 77 % 13
02:23:06 <lambdabot> Integral a => Ratio a
02:23:27 <tsahyt> if you really want fractions, there's still Data.Ratio
02:27:36 <lemonxah> i am trying to google this but i am not finding anything usefull for it
02:27:39 <lemonxah> what i am trying to do is 
02:28:04 <lemonxah> make a new char array of length 5 and fill it with 'x' s
02:29:32 <tsahyt> array as in Data.Array?
02:29:38 <lemonxah> a string really 
02:29:46 <lemonxah> char array 
02:29:56 <tsahyt> So you want a [Char]?
02:30:02 <lemonxah> sorry i am learning haskell still so i dont know which
02:30:03 <lemonxah> yes
02:30:19 <tsahyt> a list of characters then
02:30:21 <tsahyt> :t replicate
02:30:22 <lambdabot> Int -> a -> [a]
02:30:25 <tsahyt> This should help
02:30:44 <lemonxah> thank you
02:30:48 <tsahyt> but be aware that a string is not an array!
02:31:05 <tsahyt> it's a linked list, and has different performance characteristics than strings in C for example
02:31:52 <lemonxah> i am doing some hackerrank.com challenges to help learn haskell and i have to print out steps so i really just want a way to make a string with x #'s in it
02:31:54 <ahihi> also, Char is a unicode code point rather than a byte
02:32:32 <tsahyt> > replicate 5 '#'
02:32:34 <lambdabot>  "#####"
02:32:44 <lemonxah> yeah i got that from what you said earlier
02:32:55 <lemonxah> was just explaining why i dont mind it being a string
02:33:03 <lemonxah> the type info gave me everything i needed :)\
02:33:44 <tsahyt> just fyi, when you're working with text, there's the text package which provides a better representation. i.e. it performs better for common string manipulation tasks
02:37:14 <mtesseract> Hi
02:38:30 <EvanR> type ClassicString = ByteString ;)
02:38:47 <liste> hi mtesseract 
03:08:13 <chenyu> Hello, could you help me? What does it mean if I have a function definition like this "parseLine :: Parser [Int]"?
03:08:36 * hackagebot cabal-sort 0.0.5.3 - Topologically sort cabal packages  https://hackage.haskell.org/package/cabal-sort-0.0.5.3 (HenningThielemann)
03:09:45 <chenyu> It looks bizarre because there is no "->"
03:10:28 <tsahyt> chenyu: it's a parser that creates an [Int]
03:10:37 <tsahyt> probably, depending on how Parser is defined
03:12:50 <chenyu> It also happens here "id :: Category cat => cat a a"
03:13:18 <chenyu> I mean, I don't see the input in this definition.
03:13:59 <tsahyt> it's hidden in the Parser or cat
03:14:05 <tsahyt> :i Category
03:14:09 <tsahyt> ah right, lambdabot doesn't do info
03:14:21 <chenyu> lol
03:14:33 <tsahyt> anyhow, (->) is an instance of Category
03:15:06 <tsahyt> so for the case of (->), Category cat => cat a a is really the same as a -> a
03:15:54 <tsahyt> I don't know how Parser is defined in your case, but to gain some understanding you might want to read up on how the Reader monad works. That will give you some intution how the input is "hidden" there
03:17:22 <ski> chenyu : `parseLine' there is not a function
03:20:17 <tsahyt> ski: why would it not be a function?
03:20:47 <chenyu> tsahyt: That's very helpful! That where I was confused "Why the (->) missing"
03:21:24 <ski> tsahyt : there's no `->' in its type
03:22:22 <chenyu> ski: is there another thing can be defined with (::)?
03:22:29 <ski> chenyu : `parseLine' is a "parser action", or just "parser", for short
03:23:31 <ski> @type Data.Set.empty
03:23:32 <lambdabot> S.Set a
03:23:37 <ski> chenyu : how about that ?
03:24:04 <ski> (also, you don't define things with `::'. you declare their types)
03:24:38 <ski> functions are those things which can be passed arguments
03:26:20 <ski> chenyu : a parser action is a description of how you'd like to parse some hypothetical future input, in order to compute some kind of result (often, but not necessarily, some kind of parse tree, or abstract syntax tree)
03:27:11 <tsahyt> ski: I'd say in the case of a parser that's very much debatable. conceptually it's a function taking a parser state to some output and a new parser state. and even without that, I'd argue that say 3 :: Int is still a function, albeit one with no arguments.
03:27:13 <vinothkumar> I am reading FRAN from conal elliot
03:27:22 <ski> chenyu : then to actually *use* a parser action on some input data, you'd pass both the action and the input data to a separate function which actually applies the parsing instructions to the input data, executing it, and generating a result (or parse failure)
03:27:37 <tsahyt> either way, wrapping a newtype around a function doesn't make it less of a function in my opinion
03:27:38 <vinothkumar> But got stuck on the part where he implements Time, on which u can do bound calculations
03:28:06 <vinothkumar> Can some one explain me how do u go about implementing Time ?
03:28:18 <ski> tsahyt : second point first, no `3 :: Int' is not a function. there is no "functions with no arguments" in Haskell. strictly speaking, every function always takes exactly one argument
03:28:40 <vinothkumar> I mean i dont understand how he does lazy comparison on the Event which hasnt even occured
03:29:31 <hpc> tsahyt: a function is defined in haskell as a value whose type has (->) at its root
03:29:32 <EvanR> Fran does that? i thought that was a Reactive innovation
03:29:55 <hpc> tsahyt: other definitions muddle what can be considered a function too much for it to be useful
03:30:09 <EvanR> vinothkumar: in reactive, you can compare event times using futures, it will give an answer if either happens first, if ever
03:30:23 <EvanR> thats in the reactive implementation
03:30:27 <ski> tsahyt : first point, as you say it's debatable, but (a) it's very possible to make the implementation of a parser type so that it doesn't contain functions internally; and (b) i argue that the view that "it's a function taking a parser state to some output and a new parser state", while possibly useful as a stepping stone, is actually a bit bad
03:30:49 <hpc> tsahyt: calling it a mathematical function you run into trouble too, even though it has a far more flexible definition - what's the domain and codomain of 3 :: Int?
03:30:53 <vinothkumar> Yea i understand it does that, but i am curious as to how do u implement Future in pure functional way
03:30:56 <ski> tsahyt : hm, finally i dispute "wrapping a newtype around a function doesn't make it less of a function in my opinion" :)
03:31:26 <hpc> tsahyt: if anything, i would call a parser a computation, or transformation, or pipeline, or something like that
03:31:40 <vinothkumar> I can do it with a value which is first unset and set it when it got realized in a imperative fashion, but how do u do it immutably
03:31:41 * ski likes the term "action"
03:31:53 <hpc> or action
03:32:10 <hpc> https://hackage.haskell.org/package/parsec-3.1.10/docs/src/Text-Parsec-Prim.html#ParsecT - i count a bunch of proper (->) functions used in this definition
03:32:20 <hpc> which one is the function that a parser is?
03:33:00 <vinothkumar> Fran has this definition of untilB
03:33:06 <EvanR> vinothkumar: it uses unsafePerformIO behind the scenes, if getting the Future doesnt have any side effects, it works
03:33:23 <hpc> see also, http://conal.net/blog/posts/everything-is-a-function-in-haskell
03:33:27 <chenyu> ski: That's very interesting. But what actually does this kind of declaration do if it doesn't declare a function?
03:33:29 <EvanR> its like you waiting until it came in on IO and then passed it into a pure function at some point
03:33:35 <EvanR> see also unsafeInterleaveIO
03:33:35 <vinothkumar> Ok, so usually that Future part is written not in pure haskell?
03:33:59 <EvanR> give or take whther unsafePerformIO is pure haskell
03:34:14 <ski> chenyu : it declares (the type of) the operation (be it a function, or something else). declaration is not the same as definition
03:34:46 <EvanR> vinothkumar: semantically, whatever that future value is, is that value. you cant continue without waiting for it to materialize, so its still the same thing
03:34:53 <EvanR> if it never materializes, its like _|_
03:35:55 <vinothkumar> So this comparison on time would be more like if the time is less than current time and future not realised make it as false sort?
03:36:06 <ski> chenyu : a definition of `parseLine' would look like `parseLine = ...'. note the `=' in there
03:36:11 <chenyu> ski: And I can understand Data.Set.empty outputs an empty Set without input. But look at "id :: Category cat => cat a a", id really takes an input (I think), but I don't see it declared
03:36:43 <ski> chenyu : "id really takes an input" is wrong
03:36:50 <EvanR> vinothkumar: the introduction of a race or comparison on which materializes first does modify things somewhat, i think
03:36:55 <ski> chenyu : it does so, in a specific case (`cat' being `(->)')
03:37:08 <EvanR> then you have to assuming there is a time associated with each value
03:37:36 <ski> chenyu : if you define `data Foo a a = MkFoo' and then `instance Category Foo where id = MkFoo; ...', then this `id' takes no input at all
03:37:40 <vinothkumar> I really thought there is some lazy trick to implement this time
03:37:45 <EvanR> no
03:37:58 <EvanR> you might be thinking of lazy IO
03:38:02 <EvanR> which is what this is
03:38:20 <EvanR> only its not suppose to be doing side effects
03:38:46 <vinothkumar> SO is there any simple FRP library code that i can look into, both reactive-banana and reactive does too many things to understand how it does what it does
03:39:14 <EvanR> you mean the interface is too crazy ?
03:39:52 <vinothkumar> No not the interface, i am interested in how do they implement it
03:40:04 <EvanR> each one is different i think
03:40:15 <EvanR> and so are the interfaces
03:40:24 <EvanR> and so are the semantics, if they exist
03:40:32 <vinothkumar> I mean one which closely resembles FRAN paper
03:40:37 <chenyu> ski: Thanks a lot, I need to digest ...
03:40:41 <EvanR> FRAN is the only one
03:40:57 <EvanR> grapefruit and reactive came later and are similar, i think
03:41:07 <vinothkumar> :( It has broken link on some microsoft 
03:41:08 <EvanR> maybe you should upgrade to the reactive paper
03:41:22 <ski> chenyu : i'd rephrase "Data.Set.empty outputs an empty Set without input" as `Data.Set.empty' *is* an (actually *the*) empty `Set a'
03:41:22 <vinothkumar> Sorry, is there one?
03:41:27 <ski> chenyu : no "without input"
03:41:34 <EvanR> yes thats the sequel to fran
03:41:35 <vinothkumar> Can you please give me a link?
03:42:21 <ski> chenyu : anyway, i don't really think `id' from `Category' is really that helpful here (but tsahyt mentioned it, so i had to explain it ..)
03:42:43 <tsahyt> ski: I only answered the second question that was asked
03:42:59 <tsahyt> or tried to anyhow
03:43:19 <EvanR> vinothkumar: http://conal.net/papers/push-pull-frp/
03:43:39 <vinothkumar> Thanks a lot @EvanR
03:45:27 <chenyu> ski, tsahyt: Anyway, you both helped me a lot :D
03:45:44 <hexagoxel> vinothkumar: maybe helpful: https://hackage.haskell.org/package/reactive-banana-1.1.0.0/docs/Reactive-Banana-Model.html
03:47:03 <hexagoxel> vinothkumar: although the purpose of that module might be focused on explaining the interface rather than approaching the actual implementation.
03:47:36 <vinothkumar> Yea, Implementing Event as List of Maybe values might be really wasteful
03:47:47 <vinothkumar> Like say if we have never event
03:47:58 <vinothkumar> It would be a infinite list of None 
03:48:40 <ski> tsahyt : yeah, sorry. on rechecking, i see chenyu mentioned it first
03:49:12 <ski> tsahyt : i don't mean to discourage you from helping
03:51:14 <tsahyt> so is there actually anything wrong conceptually with viewing values (i.e. non-functions) as functions of no arguments, or even functions from a one-element type?
03:52:03 <ski> tsahyt : it makes the whole concept of "function" useless, since now everything is a function
03:52:42 <tsahyt> I don't think it does make it useless, rather that it simplifies other things
03:53:05 <ski> it's similar to "everything is a vector/matrix/tensor" (matlab)
03:53:21 <ski> or "everything is an object" (slogan in some OO systems)
03:53:38 * hackagebot homplexity 0.4.3.2 - Haskell code quality tool  https://hackage.haskell.org/package/homplexity-0.4.3.2 (MichalGajda)
03:54:24 <tsahyt> so basically just because I *could* model everything as a function, I don't necessarily should
03:54:27 <ski> what is wrong with "functions are things you can apply to an argument" ?
03:54:32 <Sinestro> How bad is it going to hurt to make Ix (a, a) row-by-row instead of column-by-column? 
03:55:12 <ski> tsahyt : yes
03:55:24 <tsahyt> ski: nothing as such, it's after all how I view functions in general. I'm just considering the edge cases here. For example let data I = I. Now I can rewrite any a to I -> a without really changing the semantics
03:55:34 <EvanR> tsahyt: the more things that are all the same, the less specific things you can express, and also less things the compiler can catch because "welp that nonsense is technically valid"
03:56:00 <tsahyt> that's a good point
03:56:10 <EvanR> like what is wrong with being about to + anything in js
03:56:18 <EvanR> able to*
03:56:58 <ahihi> I -> a may be isomorphic to a, but it's not the same thing
03:57:37 <ski> tsahyt : sure, and you can rewrite a function of type `a -> b -> c' into one of type `(a,b) -> c', and vice versa. but claiming one is (e.g.) injective is very different from claiming the other is injective
03:57:51 <ski> tsahyt : the "point-of-view" does matter !
03:58:58 <tsahyt> that is true indeed
04:03:38 * hackagebot bitwise 0.1.1.1 - fast multi-dimensional unboxed bit packed Bool arrays  https://hackage.haskell.org/package/bitwise-0.1.1.1 (ClaudeHeilandAllen)
04:13:38 * hackagebot both 0.1.1.0 - Like Maybe, but with a different Monoid instance.  https://hackage.haskell.org/package/both-0.1.1.0 (barrucadu)
04:43:40 * hackagebot cases 0.1.3.1 - A converter for spinal, snake and camel cases  https://hackage.haskell.org/package/cases-0.1.3.1 (NikitaVolkov)
05:09:37 <phz_> I’d love Haskell to have a linear type system to get rid of the GC…
05:09:43 <phz_> introduce the Drop trait
05:09:45 <phz_> like in Rust
05:09:47 <phz_> and tada
05:09:55 <phz_> but it would require it to have scopes
05:09:59 <phz_> which it doesn’t really have
05:10:14 * ski idly wonders whether phz_ means s/linear/uniqueness/
05:10:32 <ski> (also, Clean and Mercury do have GC as well)
05:10:48 <phz_> ski: well, I mean something like Rust’s nice memory system
05:11:04 <phz_> I’m using Rust on a daily-basis now, while I’ve been using Haskell for years
05:11:09 <phz_> but it’s just better at handling memory
05:11:10 <phz_> (Rust)
05:11:58 <bjz> phz_: Rust suffers a great deal in how things compose together because of its type system
05:12:11 <bjz> which is part of what makes haskell nice
05:12:30 <phz_> what do you mean?
05:12:45 <phz_> are you bjz from crates.io?
05:13:13 <bjz> having to deal with references vs by-value, and different pointer types for example
05:13:19 <phz_> what I’m a bit afraid of in Haskell is the fact that it rapes the RAM
05:13:36 <bjz> yep, that's me
05:13:41 * hackagebot hw-prim 0.0.2.0 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.2.0 (haskellworks)
05:13:48 <phz_> hm, yeah, I see what you mean, but we have the same issue in Haskell as well (laziness for instance)
05:15:25 <bjz> doesn't laziness keep going the other way too, in terms of making apis more composable without sacrificing performance, at the expense of having predictable performance?
05:15:46 <phz_> maybe
05:15:59 <phz_> but laziness shouldn’t be the default
05:16:02 <phz_> Idris has this right
05:16:22 <phz_> bjz: you can still have those in Rust with boxed values
05:16:59 <phz_> I love Haskell and I’ll still use it for a long time
05:17:10 <phz_> but I feel a bit afraid of how it rapes the memory
05:17:31 <bjz> could you define 'rape' in this context?
05:18:09 <phz_> bjz: take a lot of memory
05:18:22 <bjz> ok, that is clearer
05:18:26 <phz_> if you have several typicall Haskell programs running at the same time on your computer
05:18:31 <phz_> you end up with a few free space
05:18:45 <bjz> yeah
05:18:57 <phz_> and I don’t like that
05:19:08 <phz_> that’s the reason why I’m investing my time into Rust
05:19:16 <phz_> because it’s less powerful than Haskell, but it has memory control
05:19:20 <phz_> and performance prediction
05:19:26 <phz_> which is more important to me than elegance
05:19:34 <phz_> even though I really miss Haskell’s syntax :(
05:20:08 <bjz> I would like to see an elegant language that is curried by default, with nice composability, with a similar memory management story to Rust. But I have a feeling that is five, if not ten years away
05:20:15 <phz_> I just don’t like the idea of “ok, I’ll take a huge pool of memory some programs would require, to waste thunks in there”
05:20:33 <phz_> bjz: well Idris seems very promising
05:20:44 <phz_> they’re implementing LT to get rid of the GC
05:20:48 <phz_> it has dependent types
05:20:50 <bjz> It's not really ever going to be that language
05:20:52 <phz_> same syntax than Haskell
05:20:58 <phz_> why is that so?
05:21:02 <phz_> (strict by default btw)
05:21:30 <bjz> they have uniqueness types, but afaik it's not for getting away from the GC
05:21:40 <phz_> hm?
05:21:41 <bjz> unless they are changing curse
05:21:46 <bjz> *course
05:21:47 <phz_> what is the difference between uniqueness types and LT?
05:22:03 <Freundlich> How do you use linear types to get rid of managing memory?
05:22:04 <phz_> bjz: I guess I can write my own “meta” language
05:22:08 <phz_> that outputs Rust code or C
05:22:11 <phz_> and that’s it :D
05:22:21 <phz_> Freundlich: LT + lifetimes, in Rust
05:22:23 <bjz> http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html
05:22:34 <phz_> thanks for the link
05:23:09 <bjz> ah, interesting, they have a `Borrowed` type now
05:24:18 <bjz> seems like they are moving in that direction
05:24:28 <phz_> :)
05:24:32 <phz_> Idris is way too young
05:24:40 <phz_> Rust is the incoming language, especially in the industry
05:24:48 <phz_> I think it’s worth it to learn it :)
05:24:55 <phz_> and I’m happy I have
05:25:02 <phz_> especially because I know Haskell pretty well
05:25:13 <Freundlich> phz_: I'm a bit puzzled about this because the reason FP languages use a GC is because of closures. I don't see how linear types would help here. Is there a paper about this stuff I can read?
05:28:36 <Freundlich> As far as I am aware, linear typing means to have typing rules that ensure you use every premise exactly once. Therefore it encodes things like the bracket function into a type system.
05:29:17 <quchen> Freundlich: "Because of closures"? You mean because the liveness of an object can be given (extended) to another object?
05:29:34 <bjz> Freundlich: in 'Rust speak', a closure can take ownership over some piece of data, and releases it when it goes out of scope. Note that due to ownership and borrowing rules, Rust has three types of closures, depending on how the environment is consumed.
05:31:21 <Freundlich> bjz: I see.
05:31:34 <bjz> Freundlich: https://doc.rust-lang.org/book/closures.html#closures-and-their-environment
05:32:44 <Freundlich> quchen: I thought that having functions (closures) as result types was the reason that FP languages use GCs because it's hard to manage their limetimes in a different way.
05:32:57 <bjz> As you can imagine, it makes apis more clunky than if you just had a single function type constructor, (a -> b)
05:33:57 <bjz> It's not a huge deal in normal Rust usage, because Rust code isn't very functional, but it would be nice to see a language that makes it easier to do FP without a GC
05:35:10 <quchen> Freundlich: I don't know why FP languages use GC, but I too heard that other forms of memory management are hard. I'm really interested in that because I'm toying around with my own garbage collectors for the STG.
05:35:28 <quchen> But I haven't looked at why I have GC in the first place.
05:35:40 <quchen> (As opposed to other memory management techniques)
05:37:59 <ski> quchen : if you haven't already, you should probably take a look at <https://en.wikipedia.org/wiki/Region-based_memory_management> (as in the ML Kit, e.g.)
05:38:25 <quchen> ski: I have not, thank you!
05:39:22 <phz_> Freundlich: well
05:39:30 <phz_> I don’t think it’s the reason FP has GC
05:39:31 <quchen> ski: Ah, that looks like putting small heaps on the stack
05:39:43 <phz_> FP languages have GC because of impredictability
05:39:57 <phz_> Rust has closures as well and handle them without GC pretty well
05:39:59 <phz_> handles*
05:40:09 <quchen> phz_: Impredictability?
05:40:31 <phz_> quchen: you don’t know the lifetime of an object as you don’t really have scopes
05:40:50 <bjz> quchen: do take a chance to play around with Rust too
05:41:02 <phz_> by tagging object with lifetimes – what Rust does – you can statically follow the allocations
05:41:06 <phz_> which is very great
05:41:10 <ski> (extent doesn't follow scope)
05:41:24 <phz_> yeah
05:41:33 <phz_> I’ve been a Haskeller for more than 4 years now
05:41:34 <quchen> bjz: It's been on my to-look-at list for quite some time, I read the Rust book, but then I lost focus … :-|
05:41:41 <phz_> and I’ve been doing Rust for two months or three
05:41:51 <phz_> and I think I’ve been switching to Rust
05:41:59 <phz_> because of how great it handles memory and performance
05:42:04 <phz_> I just miss HKT :D
05:42:12 <bjz> quchen: you really have to spend some time with the type checker to see how it works
05:42:31 <bjz> quchen: especially if you are interested from a language design perspective
05:42:35 <phz_> bjz: Rust type system is interesting, especially the borrow part
05:42:42 <quchen> Yes, I agree. Just reading about it won't give me a lot of insight.
05:43:26 <bjz> there is still tons of work that needs to be built on to make this stuff easier to use (it's good at the moment, but it could be much, much better)
05:43:46 <phz_> bjz: what do you mean?
05:43:58 <phz_> something that’s not that good in Rust is boxed closures
05:44:01 <phz_> they just suck.
05:44:04 <phz_> they need to be fixed
05:44:04 <bjz> yep
05:44:13 <phz_> especially those you can run only once
05:44:23 <phz_> Box<FnOnce(_) -> _>
05:44:36 <phz_> vs. FnBox
05:45:02 <bjz> how are you going to write fp-style code without a good closure story?
05:45:18 <phz_> bjz: well, Rust already has
05:45:25 <phz_> it just needs to be fixed :D
05:45:34 <phz_> (I like the “iterator adapters” stuff)
05:47:33 <quchen> Is Rust good at FP at all? I get that it has lambdas, but from a language saying "supports FP" I expect to be able to use them pervasively, and not just to implement "map". In Java 8 for example, lambdas have terrible performance, and only serve to put a nice label on the "supports X" list on Wikipedia.
05:47:45 <gromak> Hello everyone. I am profiling a ditributed system. Now I am launching one client which sends request to two servers (roughly speaking). All three applications run on different computers. So two servers basically just serve requests from client and client just sends requests one by one. Unfortunatelly, it works very slowly, much slower than if I run everything from a single process using forkIO. Profiler shows that all three applications spend more than 99%
05:47:45 <gromak>  of time in IDLE state. What may be the reason? I can understand why servers are mostly idle, it may happen because client is slow. But I can't understand why client is idle for 99% of time :(
05:47:54 <phz_> quchen: well
05:47:55 <quchen> (Terrible at compile time, at least. During runtime they're alright.)
05:47:56 <phz_> in Rust
05:48:00 <phz_> lambdas are just trait implementations
05:48:08 <phz_> like if lambdas were typeclass instances
05:48:24 <phz_> lambdas are just syntactic sugar over trait methods call :)
05:48:40 <gromak> strace shows that between network communication there are a lot of futexes and SIGVTALRMs on client
05:48:50 <bjz> quchen: Rust's closures can be optimised very well,  but beyond using them in things like maps and folds, they can be temperamental things to deal with 
05:48:52 <phz_> a lambda defining arguments, like three arguments, will be desugared to a structure with three fields passed to the call() method of the corresponding trait
05:49:15 <phz_> quchen: you can have higher-order functions in Rust
05:49:18 <phz_> I do that all the time
05:49:21 <phz_> (with move closures)
05:49:22 <quchen> Ah, so a Rust lambda is an anonymous object that implements the call trait and takes N arguments?
05:49:33 <sdx23> gromak: network latency is huge, you thought about that?
05:49:37 <bjz> yup!
05:49:46 <phz_> exactly
05:49:59 <phz_> and it doesn’t even end up with dynamic dispatch
05:50:02 <phz_> (I don’t think so)
05:50:17 <phz_> but I guess it would if you box a closure
05:50:22 <phz_> to return it for instance
05:50:26 <quchen> What's a box?
05:50:31 <bjz> and the difference beween the closure traits is the how that object is referenced
05:50:34 <phz_> exactly the same thing than Haskell’s boxes
05:50:38 <quchen> Ah.
05:50:53 <bjz> quchen: like unique_ptr in c++
05:51:10 <gromak> Well, ping reports 43 ms, is it huge latency?
05:51:14 <phz_> it’s like a pointer having ownership 
05:51:27 <phz_> and you cannot copy that pointer
05:51:34 <phz_> you clone it though, but it clones its content
05:51:37 <phz_> like in Haskell :)
05:52:16 <sdx23> gromak: depends on your implementation, whether that matters.
05:53:17 <quchen> "Like in Haskell"? Haskell has no pointers, and I'm not sure GHC allows cloning of objects via its API.
05:53:28 <phz_> quchen: it has
05:53:30 <quchen> (Why would I want to clone an immutable value?)
05:53:40 <phz_> > let a = "hello" ++ "foo"
05:53:41 <lambdabot>  <no location info>: not an expression: ‘let a = "hello" ++ "foo"’
05:54:04 <phz_> well
05:54:09 <phz_> a is like a pointer
05:54:11 <phz_> you can share it
05:54:29 <phz_> quchen: well imagine you have a vector of things
05:54:44 <phz_> and you want to create a new vector of things mapped with a function (.map)
05:54:47 <quchen> That's an implementation detail of GHC. The Report only mentions pointers in the sections about the FFI, that's why I meant that Haskell has no pointers.
05:54:49 <phz_> you need to clone the whole vector
05:54:53 <phz_> even though it’s immutable
05:55:08 <phz_> quchen: it has no visible pointers
05:55:13 <phz_> but the semantics are exactly the same
05:55:26 <phz_> bindings are immutable adresses 
05:55:41 <phz_> Rust just make that appear in the interface
05:55:52 * ski thinks phz_ is still talking about a particular implementation strategy
05:56:06 <phz_> I’m talking about GHC at least
05:59:37 <chenyu`> ski: How did you post a line like "* ski thinks ......"?
05:59:44 <phz_>  /me
05:59:45 <newcomer> is this wikipedia entry wrong? It claims that an Applicative is a Monad without join. isn't that wrong? https://en.wikipedia.org/wiki/Applicative_functor
05:59:49 * phz_ says hi
05:59:58 <ski> /me looks at chenyu`
06:00:01 * chenyu`
06:00:15 <phz_>  /me your message
06:00:17 * chenyu` is laughing
06:00:20 <phz_> :)
06:00:26 <hpc> newcomer: it's correct-ish
06:00:35 <hpc> newcomer: i would never ever say it that way, but i know what the page means
06:00:52 <ski> defining a structure as another structure "without X" is problematic
06:01:03 <newcomer> hpc, can one define <*> using fmap and return only (without join)?
06:01:05 <quchen> phz_: GHC is free to overwrite things in memory with updated versions, I'm not sure it does this for vectors though. But the (GHC) STG has three different update flags: reentrant, single entry, updatable.
06:01:08 <ski> (because it's presentation-dependent)
06:01:31 <quchen> So if the old vector wasn't used later, it would be fine to overwrite it with the mapped version.
06:01:39 <ski> newcomer : no, `(<
06:01:51 <ski> newcomer : no, `(<*>)' can't be defined solely in terms of `fmap' and `return'
06:02:09 <hpc> newcomer: what it means is given Applicative, you can also get Monad just by defining join
06:02:25 <ski> (*if* you can define a (sensible) `join')
06:02:26 <phz_> quchen: hm… what?!
06:02:33 <phz_> that cannot work
06:02:36 <quchen> newcomer: Monad is an Applicative with join. But taking join away from Monad takes away too much. :-)
06:02:37 <hpc> newcomer: in other words, it's phrased entirely backwards
06:02:49 <phz_> because of sizes
06:03:04 <phz_> if the elements’ types have the same binary sizes, ok, it can
06:03:08 <ggVGc> I always use foldl' whenever I need to have state while iterating, and only used the State monad once in my life. But I'm starting to think maybe state monad makes things more readable?
06:03:15 <phz_> but otherwise it really cannot “reuse” the same vector to get the mapped version
06:03:17 <ggVGc> at least with do notation
06:03:22 <ggVGc> but I find folds easier to write now
06:03:26 <quchen> phz_: Are we talking about unboxed vectors? Two vectors of the same length should have identical memory footprints, no? That won't hold for unboxed ones of course
06:03:37 <ggVGc> do you guys use the state monad often?
06:03:43 <ggVGc> or stick with folds?
06:03:45 <phz_> quchen: yeah
06:03:53 <ggVGc> or, what cases is one preferable/
06:03:57 <hpc> ggVGc: sometimes
06:04:00 <phz_> the memory footprint of Vector Int is cleary not the same than Vector (Maybe Int)
06:04:07 <phz_> same as*
06:04:09 <ggVGc> hpc: how do you decide which to go  with?
06:04:13 <quchen> phz_: Why not?
06:04:26 <phz_> because:
06:04:31 <phz_> :t sizeOf
06:04:31 <quchen> A vector is an Int (length) with a list of pointers (values)
06:04:32 <lambdabot>     Not in scope: ‘sizeOf’
06:04:32 <lambdabot>     Perhaps you meant one of these:
06:04:32 <lambdabot>       ‘IM.size’ (imported from Data.IntMap),
06:04:33 <hpc> ggVGc: if you have something that requires carrying around a global "mutable" state, State is pretty much an exact match
06:04:34 <phz_> dammit
06:04:41 <sdx23> Freundlich: jhc didn't have a garbage collector. So I guess the "FP needs GC" point isn't true.
06:04:43 <phz_> :t Foreign.Storable.sizeOf
06:04:45 <lambdabot> Foreign.Storable.Storable a => a -> Int
06:04:54 <hpc> ggVGc: see Random
06:04:57 <ggVGc> hpc: yeah, which is why I think me using foldl' is maybe mostly the wrong choice
06:05:02 <phz_> > Foreign.Storable.sizeOf (undefined :: Int) == Foreign.Storable.sizeOf (undefined :: Maybe Int)
06:05:03 <lambdabot>  Not in scope: ‘Foreign.Storable.sizeOf’Not in scope: ‘Foreign.Storable.sizeOf’
06:05:05 <ggVGc> but it's easier for me to write a fold than using state :/
06:05:19 <ggVGc> but I'm finding it might make thins harder to read afterwards
06:05:22 <hpc> personally i prefer local state
06:05:25 <hpc> which means ST
06:05:34 <phz_> > Foreign.Storable.sizeOf (undefined :: Int) == Foreign.Storable.sizeOf (undefined :: Maybe Int)
06:05:35 <lambdabot>  Not in scope: ‘Foreign.Storable.sizeOf’Not in scope: ‘Foreign.Storable.sizeOf’
06:05:38 <ggVGc> oh, I don't think I know the difference
06:05:38 <phz_> what the actual fuck
06:05:49 <hpc> or expressing things purely, which means something more suitable like folds and stuff
06:05:49 <ski> ggVGc : `State' could be nicer, if you need to traverse a tree, threading the state around
06:06:11 <quchen> phz_: I don't think Lambdabot has FFI stuff in scope.
06:06:24 <phz_> > Foreign.Storable.sizeOf (undefined :: Int)
06:06:25 <lambdabot>  Not in scope: ‘Foreign.Storable.sizeOf’
06:06:29 <phz_> yeah…
06:06:31 <phz_> @let import Foreign
06:06:33 <lambdabot>  Defined.
06:06:34 <phz_> > Foreign.Storable.sizeOf (undefined :: MInt)
06:06:36 <ggVGc> ski: oh, wait, ST is impure?
06:06:36 <lambdabot>  Not in scope: ‘Foreign.Storable.sizeOf’    Not in scope: type constructor or...
06:06:36 <lambdabot>      Perhaps you meant ‘Int’ (imported from Foreign)
06:06:37 <phz_> > Foreign.Storable.sizeOf (undefined :: Int)
06:06:37 <hpc> ggVGc: ST is IO minus both the I and the O
06:06:39 <lambdabot>  Not in scope: ‘Foreign.Storable.sizeOf’
06:06:40 <ggVGc> or, rather, actually mutable?
06:06:45 <hpc> ggVGc: basically it's nothing but IORef
06:06:46 <phz_> ok fuck it :)))
06:06:51 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad-ST.html
06:07:02 <hpc> it looks rather weird at the type level as a result
06:07:02 <quchen> phz_: Sure, for unboxed vectors that's not a valid optimization. (Unboxed vectors aren't really Haskell anyway since they make heavy use of external definitions.)
06:07:20 <ski> ggVGc : `ST' is pure, as is `IO'
06:07:21 <hpc> there's some cleverness going on with runST to ensure mutable data can't escape the computation
06:07:21 <quchen> phz_: FWIW (Maybe a) isn't even Storable
06:07:29 <hpc> which is what keeps it pure
06:07:32 <phz_> well ok, compare with Bool then
06:07:37 <phz_> but yeah
06:07:42 <phz_> boxed vectors should have the same representation though
06:07:46 <phz_> because they store pointers
06:07:52 <phz_> which are either 4 or 8 bytes
06:07:59 <phz_> for any types you put in the vectors
06:08:01 <ggVGc> hpc: so, using ST is always going to generate faster code than a fold eh
06:08:04 <ggVGc> I should start using ST
06:08:10 <hpc> i didn't say that
06:08:22 <ggVGc> it sounds like it, if ST is actually mutable state
06:08:31 <ggVGc> either way, why ever use State then?
06:08:32 <hpc> it will in all likelyhood be slower, i would expect
06:08:36 <ggVGc> ST seems like a better fit always
06:08:42 * hackagebot dpor 0.1.0.1 - A generic implementation of dynamic partial-order reduction (DPOR) for testing arbitrary models of concurrency.  https://hackage.haskell.org/package/dpor-0.1.0.1 (barrucadu)
06:08:44 * hackagebot dejafu 0.3.1.1 - Overloadable primitives for testable, potentially non-deterministic, concurrency.  https://hackage.haskell.org/package/dejafu-0.3.1.1 (barrucadu)
06:08:46 * hackagebot async-dejafu 0.1.2.2 - Run MonadConc operations asynchronously and wait for their results.  https://hackage.haskell.org/package/async-dejafu-0.1.2.2 (barrucadu)
06:08:48 * hackagebot hunit-dejafu 0.3.0.1 - Deja Fu support for the HUnit test framework.  https://hackage.haskell.org/package/hunit-dejafu-0.3.0.1 (barrucadu)
06:08:50 * hackagebot tasty-dejafu 0.3.0.1 - Deja Fu support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-dejafu-0.3.0.1 (barrucadu)
06:08:52 <hpc> ghc has some absolutely wizardly techniques it can apply to pure code, which ST breaks
06:08:52 <ski> ggVGc : `ST' is useful when you need references to mutable locations. especially if you need to dynamically allocate them
06:09:09 <scshunt> yeah, ST breaks optimizations in pure code
06:09:15 <scshunt> also things like laziness
06:09:50 <ggVGc> ah, wait, I get it now
06:10:03 <ggVGc> State only has one single "state" that you get/put, while ST has multiple refs
06:10:08 <hpc> yep
06:10:10 <ggVGc> so ST is more explicit in a sense
06:10:10 <Philonous> Is there a best practice for parsing command line arguments? GetOpt used to work well, but it's pretty clunky 
06:10:35 <ggVGc> hpc: it seems to me though, that State could easily be implemented in terms of ST
06:10:53 <newcomer> If a Monad can be thought of as fmap, return and join; and adding join to an Applicative gives you a Monad, how come an Applicative isn't just fmap and return?
06:11:20 <hpc> Philonous: there's cmdargs, which acts like gnu's getopt
06:11:34 <hpc> Philonous: and optparse-applicative, which is pretty cool
06:11:49 <nshepperd> phz_: @let import Foreign.Storable
06:11:57 <Philonous> hpc, Thanks, I'll look into them
06:12:14 <hpc> ggVGc: perhaps, but it doesn't need to be and is much simpler without it
06:13:00 * hpc personally doesn't get annoyed enough by GetOpt to add a dependency
06:14:22 <ggVGc> anyway, cool, that clears it up for me
06:14:28 <ggVGc> and I should stop writing folds as much I think
06:14:32 <ggVGc> and use State or ST instead
06:14:34 <nshepperd> you can also implement a pure version of ST in State
06:14:42 <ggVGc> nshepperd: yeah, fair
06:15:04 <nshepperd> with an IntMap and gadts and unsafeCoerce :)
06:15:08 <ski> newcomer : `Applicative' is intermediate in power between `fmap'&`return', and `fmap'&`return'&`join' (also considering the laws, which we didn't mention here)
06:15:15 <hpc> ggVGc: the only times i ever need to resort to mutable state, i am dealing with something concurrent-ish and the order of the day is MVar or Chan or TVar
06:15:19 <ggVGc> I can't really decide on why to chose ST over State or vice versa though. It seems more like a stylistic choice to me
06:15:46 * ski has used `STRef's for logic variables
06:15:53 <ggVGc> hpc: maybe I'm just solving problems in the wrong way then 
06:15:59 <hpc> ST for when an algorithm is genuinely easier to express as mutations of state and it would be a nightmare to write functionally
06:16:03 <ggVGc> I'm still developing my functional mindset
06:16:15 <nshepperd> State is usually faster, and plays better with monad transformers
06:16:17 <hpc> State for when you have a single global state to thread through a series of computations
06:16:37 <ggVGc> yeah, so that second case is when I usually use foldl'
06:17:15 <hpc> some people like using (ReaderT (IORef s) IO) instead, at least when they're already in IO
06:17:29 <hpc> one global state still, and a bit less worrying about thunk buildup
06:18:01 <ggVGc> I've never used ReaderT, or any other transformer, yet
06:18:11 <ggVGc> I've never used Reader either
06:18:15 <ggVGc> and don't completely get it :(
06:18:36 <Philonous> hpc, Wait, cmdargs seems to be doing something fishy. "Values created with annotations are not pure"
06:18:57 <ggVGc> when would you use Reder(not T)
06:19:03 <ggVGc> reader*
06:19:05 <nshepperd> I would normally only use ST for doing things with mutable arrays
06:19:12 <hpc> when you have some global environment that never changes
06:19:18 <Philonous> It's using unsafePerformIO? Goodness 
06:19:22 <ski> (or only changes locally)
06:19:34 <hpc> such as HTTP information on a web server, or environment variables
06:19:34 <ggVGc> hm, I don't know how to put that in practical terms
06:19:41 <ggVGc> i.e I don't know how to identify those environments I gess
06:19:43 <ggVGc> gues*
06:19:46 <ggVGc> damn
06:20:00 <hpc> eh, you'll start seeing the patterns eventually
06:20:04 <ggVGc> yep
06:20:12 <ggVGc> haskell, one monad at a time
06:22:58 <ggVGc> ah, I think I get it now
06:23:04 <ggVGc> right, Reader is just a one-way State
06:23:06 <ggVGc> easy
06:23:16 <ggVGc> dunno why it didn't click before
06:23:25 <ggVGc> but also don't know how many of those situations I've had actually
06:23:34 <ski> @type local
06:23:35 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
06:26:29 <ggVGc> oh, I just realised I have lots of Reader instances in one of my main modules
06:26:34 <ggVGc> and someone pointed it out the other day
06:26:37 <ggVGc> and I didn't get it :(
06:26:40 <ggVGc> but now I do!
06:26:41 <ggVGc> thanks
06:27:37 <ggVGc> so Reader (IO s) t is just a way to constrain an IO operation to only reading
06:27:43 <ggVGc> didn't click initially
06:27:54 <ggVGc> feel a bit dumb now
06:28:19 <nshepperd> hmm?
06:28:23 <ggVGc> wait, that type sig is wrong
06:28:37 <ggVGc> I meant this, (ReaderT (IORef s) IO)
06:28:54 <ggVGc> actually, no, ignore me
06:28:56 <ggVGc> :(
06:29:27 <nshepperd> well, ReaderT (IORef s) IO is certainly useful
06:29:45 <ski> it can't change the reference (except locally), but it can still change what's stored in the I/O state reference cell referenced by that reference
06:29:48 <nshepperd> that's an IO operation with access to a single "global" variable
06:30:36 <ggVGc> what I see now is that Reader is essentially the pure version of a callback
06:30:46 <ggVGc> bbut maybe that intuition is also wrong
06:30:49 <nshepperd> ReaderT AppConfig IO is a pretty common pattern, where AppConfig is some record with configuration for you program loaded at startup
06:31:03 <ggVGc> yeah, I get tat
06:31:38 * ski isn't sure what ggVGc means by "the pure version of a callback"
06:31:42 <nshepperd> Reader r a = r -> a, so you can use it anywhere you'd use a function, really
06:32:30 <nshepperd> mostly it pays off when you have many recursive calls passing the same r
06:32:40 <ski> the implicit "plumbing" of the environment monad is to distribute the given environment out "down" every branch of the (monadic) computation
06:33:22 <ski> the effects are (a) checking the current environment; and (b) *locally* shadowing the environment
06:35:57 <ggVGc> so, I found this on SO as an example or Reader use, but it seems to me you could just use a function here? https://gist.github.com/39d0aaf2818c1ab71dcc9a1ab85259ea
06:36:03 <ggVGc> why is Reader useful in this example?
06:36:34 <ski> > let act = do x <- (* 2); y <- (^ 2); return (x + y) in (do a <- act; b <- local (1 +) act; return (a,b)) 3
06:36:36 <lambdabot>  (15,24)
06:39:39 <ski> ggVGc : not sure whether it's terribly useful in that case ..
06:41:23 <nshepperd> then the monad handles the /url gist
06:41:29 <nshepperd> bah
06:41:36 <vx1r> anyone use servant?
06:41:51 <vx1r> i'm trying to figure out how to get a plaintext client working
06:46:16 <nshepperd> ggVGc: doesn't seem like it would make much difference there, but the Reader means you don't have to explicitly pass the Game around
06:48:03 <vx1r> trying to understand how servant expects plain text clients to be declared
06:48:36 <vx1r> http://lpaste.net/164588 code runs but result is Left (UnspupportedContentType {responseContentType = text/plain;charset=ISO...
06:48:39 <vx1r> any ideas?
06:51:16 <ggVGc> okay, so I also found this explanation, https://gist.github.com/7894396f878a8a31179c0ed0ab3c6daa from this SO post http://stackoverflow.com/questions/14178889/reader-monad-purpose/14206724#14206724 and that sounds like a partial function to me
06:53:25 <geekosaur> did you mean "partial", or "partially applied"?
06:53:54 <ggVGc> partially applied, sorry
06:53:56 <ggVGc> not partial
06:54:41 <geekosaur> because "partially applied" is indeed the point; Reader carries around an "implicit" parameter for you
06:55:13 <ggVGc> yeah, but I don't grasp when I would use reader instead of a partially applied function
06:55:29 <ggVGc> I know there is a point to it, but I can't put it into practical terms for myself :*(
06:56:00 <geekosaur> mostly for syntactic convenience. the newtype is never necessary
06:56:24 <geekosaur> and neither are the helpers 'ask', 'asks', 'local' --- but they can be easier to read than the alternatives
06:57:14 <nshepperd> you'd use it when it makes your code shorter/clearer
06:57:42 <mnoonan> It's like the difference between defining a function f(x,y) and a family of functions f_x(y)  (which is to say: no difference, except they might express different intents / purposes for x and y)
07:43:46 * hackagebot data-lens-light 0.1.2.2 - Simple lenses, minimum dependencies  https://hackage.haskell.org/package/data-lens-light-0.1.2.2 (RomanCheplyaka)
07:48:47 * hackagebot nonlinear-optimization-ad 0.2.2 - Wrapper of nonlinear-optimization package for using with AD package  https://hackage.haskell.org/package/nonlinear-optimization-ad-0.2.2 (MasahiroSakai)
07:49:09 <merijn> Anyone know if ICFP travel grants cover student volunteers too, or just students presenting a paper
08:18:31 <tippenein> looking for tips on parallelizing (or generally speeding up) this code: https://github.com/tippenein/etl-language-comparison/blob/haskell-implementation/haskell/src/MapReduce.hs
08:18:45 <tippenein> I profiled it here: http://lpaste.net/164562
08:19:09 <nitrix> tippenein: https://hackage.haskell.org/package/async-2.1.0/docs/Control-Concurrent-Async.html
08:19:17 <nitrix> tippenein: Have yuo looked at mapConcurrently and similar?
08:20:34 <tippenein> I did briefly. I should try that. I'm not quite sure how it works with Pipes, but worth a try
08:20:35 <nitrix> Concurrency could be another way to improve performance if you run out of optimizations.
08:21:23 <tippenein> it's only running on one core at the moment, but I don't think it should take ~50 seconds regardless
08:24:07 <nitrix> tippenein: for (each globbed) Text.readFileLn
08:24:17 <tippenein> mapConcurrently looks like the ticket
08:24:18 <nitrix> tippenein: Line #43 is what I'd love to see done concurrently.
08:24:25 <tippenein> ^ yes!
08:24:50 <tippenein> I'm excited
08:24:51 <nitrix> I don't know. If you're not in a hurry or anything, it could be a fun thing to play with and figure out regardless :)
08:25:08 <tippenein> I'm in no hurry. I want to profile everything at each step
08:25:18 <nitrix> Let me know :P
08:25:29 <tippenein> you know anything about criterion>
08:25:38 <tippenein> because I can't get my benchmarks to terminate
08:25:51 <tippenein> (using nfIO anyway)
08:26:33 <nitrix> I don't. I have yet to check out even QuickCheck. Heard lots of good things.
08:28:48 * hackagebot traverse-with-class 0.2.0.4 - Generic applicative traversals  https://hackage.haskell.org/package/traverse-with-class-0.2.0.4 (RomanCheplyaka)
08:28:50 * hackagebot relational-record-examples 0.3.1.1 - Examples of Haskell Relationa Record  https://hackage.haskell.org/package/relational-record-examples-0.3.1.1 (KeiHibino)
08:31:02 <carterhinsley> Houston, we have a problem.
08:31:28 <carterhinsley> Configuring cpython-3.4.0...setup-Simple-Cabal-1.22.5.0-ghc-7.10.3: The pkg-config package 'python-3.4' is required but it could not be found.
08:32:07 <carterhinsley> I have python 3.4.3 installed on my system. I'm a tad bit confused by why cabal/stack can't find this package, and what I can do to help.
08:32:39 <dcoutts> carterhinsley: "pkg-config package 'python-3.4'"
08:32:49 <dcoutts> so not merely python installed
08:33:32 <dcoutts> but the development files needed to compile C code against the python c api
08:33:49 * hackagebot relational-record 0.1.5.0 - Meta package of Relational Record  https://hackage.haskell.org/package/relational-record-0.1.5.0 (KeiHibino)
08:34:05 <dcoutts> pkg-config being the standard(ish) C config system for working out what C compiler flags to use etc
08:34:26 <maerwald> dcoutts: 'package'?
08:34:39 <maerwald> you probably mean --libs/--cflags etc
08:34:51 <dcoutts> carterhinsley: ie use your system package manager to install python-dev/devel
08:35:13 <dcoutts> maerwald: iirc pkg-config calls them packages
08:36:21 <maerwald> dcoutts: so you meant "pkg-config <package>"?
08:37:38 <dcoutts> maerwald: the current error message is phrased as so:  The pkg-config package 'python-3.4' is required but it could not be found.
08:37:56 <dcoutts> it's trying to say, the thing 'wot pkg-config calls 'python-3.4' is missing
08:38:00 <maerwald> oh, I thought you gave a command example
08:38:09 <dcoutts> I was quoting from the error message
08:39:27 <maerwald> I'm not even sure if the python .pc filenames are standardized
08:42:57 <maerwald> seems it is, upstream names it python-$(VERSION).pc, yeah
08:43:12 <infinity0> what's the property called if f x x = x for all x?
08:43:26 <ski> idempotency
08:43:46 <infinity0> ahh ok thanks
08:44:08 <ski> (`f' is idempotent)
08:45:37 <infinity0> is binary idempotence at all related to unary idempotence?
08:45:59 <ski> not sure what you mean by either
08:46:43 <ski> hm, oh i see
08:46:43 <infinity0> sorry, so reading it on wikipedia, "a binary operator f is idempotent" is what we just talked about
08:46:58 <infinity0> "a unary operator f is idempotent" means f (f x) = x for all x
08:47:23 <infinity0> er sorry no, f (f x) = f x for all x
08:48:01 <nitrix> infinity0: The Unary / Binary just refers to the arity of the operator.
08:48:02 <ski> `(*)' being idempotent, where `(*)'d usually be associative in practice, or at least power-associative, means that `forall x. x * x = x', which could be phrased as `forall x. x^2 = x^1'
08:48:10 <infinity0> ahhh ok wikipedia says, "The defining property of unary idempotence, f(f(x)) = f(x) for x in the domain of f, can equivalently be rewritten as f ∘ f = f, "
08:48:16 <nitrix> infinity0: It's not related to idempotency per se.
08:48:21 <ski> nitrix : no, it's not just that
08:48:25 <infinity0> " Thus, the statement that f is an idempotent unary operation on S is equivalent to the statement that f is an idempotent element with respect to the function composition operation ∘ on functions from S to S."
08:48:40 <nitrix> ski: What piece am I missing?
08:48:42 <infinity0> ok makes sense now, it is ok in some sense to use the same word for both concepts since they are related in that way
08:48:54 <ski> infinity0 : yes, so in that case, `x' becomes `f', and `*' becomes `∘', and we drop the `forall' and instead talk about a specific `x'/`f'
08:49:42 <ski> there are some similar cases where you use the same term for somewhat related things like this
08:50:42 <ski> e.g. if we have an element `c' in a group, for which `c * g = g * c' for every `g', then we can say that `c' commutes with everything (cf. with how `*' would be commutative in an abelian/commutative group)
08:51:13 <infinity0> understood, thanks
08:51:22 <ski> or the (square) matrix `M0' commutes with `M1' in case `M0 * M1 = M1 * M0'
08:51:35 <ski> or `f' commutes with `g' in case `f ∘ g = g ∘ f'
08:51:53 <nitrix> ski: Please when you're done, I'd like to know what piece am I missing with arity and idempotence.
08:53:42 <ski> nitrix : in both cases, we have something like `x * x = x'
08:53:52 <ski> nitrix : in the "binary" case, we have that for all `x', and say that `*' is idempotent
08:54:36 <ski> nitrix : in the "unary" case, we're implicitly talking about some specific `*' (usually composition), and also (explicitly) about some specific `x', and say that `x' is idempotent
08:54:46 <infinity0> nitrix: i understood what "unary" vs "binary" meant, that wasn't what i was asking
08:54:58 <nitrix> ski: How does arity affects the definition of idempotence?
08:55:17 <ski> i think that's the wrong way to think about it
08:55:27 <ski> iow, arity doesn't affect it
08:55:34 <nitrix> You said the opposite earlier.
08:55:52 <infinity0> nitrix: you're misunderstanding the previous conversation
08:55:53 <ski> where ?
08:56:19 <nitrix> I made a statement about arity and also idempotence and got pointed out those were wrong.
08:56:32 <nitrix> So I'd like to know how one correlate with the other that results in me being wrong.
08:56:50 <nitrix> Or, maybe which part is the wrong part.
08:56:53 <infinity0> nobody said you were wrong, when ski said "no" he meant that it was not relevant to the thread we were saying at the time
08:57:12 <infinity0> he didn't realise you misunderstood our thread of conversation, but it's clear now to both of us
08:57:49 <nitrix> Well, how come I misunderstood arity and idempotence then?
08:57:59 <nitrix> Does it has one than one definition?
08:58:10 <nitrix> *more
08:58:21 <infinity0> indeed yes, https://en.wikipedia.org/wiki/Idempotence
08:58:49 <infinity0> coming from impure languages one often hears "function f is idempotent" to mean if you mutable x with f twice it's the same as if you do it once
08:58:55 <nitrix> I always find it rude when people refer me to links when I ask them directly.
08:59:06 <infinity0> it's not rude, i just have other things to do
08:59:10 <nitrix> Alright, I'll read the page and come back later.
08:59:24 * geekosaur finds it rude when asked to read a web page to someone
08:59:46 <ski> nitrix : to me, "The Unary / Binary just refers to the arity of the operator." suggests that you think that there's one general definition, of which the "unary" and "binary" operation are two special cases, at different arities. but that's not the case
09:00:18 * carterhinsley finds it rude when people can't chop their own wood
09:01:14 <merijn> nitrix: The entire reason I often write gists and link them to people is because typing the same explanation into IRC when people ask common questions gets boring/old quick
09:01:23 <ski> s/operation/version of "idempotence"/
09:01:34 <merijn> nitrix: Take into account that the person linking you a page has probably explained whatever they're linking a 100 times already
09:01:47 * monochrom refers people to web pages all the time and gets a lot of gratitude and compliment. the trick is that he wrote those web pages. :)
09:02:10 <nitrix> ski: How are they special cases and special cases of what? Isn't it just a relation on the domain?
09:02:22 * carterhinsley finds it rude when it rudes him find
09:02:59 <ski> nitrix : they are not special cases
09:03:17 <nitrix> ski: I don't see how it affects idempotence. Does the property of being idempotent changes if the function arity change?
09:03:45 <nitrix> ski: I know they aren't. That's what I'm debating from the begining.
09:03:49 * hackagebot codex 0.5.0.0 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.5.0.0 (aloiscochard)
09:03:50 <ski> nitrix : no. the name "idempotent" is overloaded between two somewhat related, but different, concepts
09:04:07 <nitrix> ski: Does one of those concepts include arity?
09:04:13 <ski> no
09:04:19 <nitrix> Then I'm wasting my time.
09:05:11 <carterhinsley> so... for tensorflow the C++ api does not at all have anything to do with graph construction so i am having to wrap the python API in haskell to be able to do anything of any real use here ( ͡° ͜ʖ ͡°)
09:05:32 <carterhinsley> i almost kind of regret this fact
09:06:29 <carterhinsley> if i write a library and wish that it be referred to from the top level as Tensor, should i name submodules Tensor.Foo, Tensor.Bar, etc., or just Foo, Bar?
09:06:38 <carterhinsley> referred to externally, that is
09:07:27 <carterhinsley> if i'm not mistaken the package name has nothing to do with the module names, no?
09:07:47 <Hijiri> it doesn't
09:07:57 <hpc> the package name is what people "cabal install"
09:07:58 <carterhinsley> excellent
09:08:01 <hpc> the module names are what people import
09:08:04 <Hijiri> which is why you should do Tensor.Foo, so you don't clash with someone else who named something Foo
09:08:11 <hpc> ^
09:08:37 <hpc> though depending on what the purpose of this library, you might want Data.Tensor.Foo or something
09:08:53 <hpc> to follow the module naming convention
09:09:06 <carterhinsley> is there a reference on such naming conventions?
09:09:20 <hpc> probably somewhere, but i don't remember offhand
09:09:29 <hpc> mostly you can get by just following what other modules do
09:09:53 <carterhinsley> i specifically mean, for choosing a top-level module name
09:10:10 <carterhinsley> such as Data or System or what have you (i don't know all of the standard ones, which is why i ask)
09:10:32 <hexagoxel> <joke>just look at what ghc itself does in regards to module naming</joke>
09:10:48 <carterhinsley> the joke is on you my friendola ( ͡° ͜ʖ ͡°)
09:11:27 <carterhinsley> i prefer to write haskell on BBQ napkins with a bit of brunswick stew stained into them before hand-compiling, rather than using GHC
09:11:31 <hpc> carterhinsley: look through hackage for anything similar to what you're doing
09:11:35 <monochrom> pretty sure no one will clash on Foo and Bar literally
09:11:37 <carterhinsley> mmk
09:12:00 <hpc> usually things go in Data by default
09:12:14 <hexagoxel> carterhinsley: might be interesting: https://gist.github.com/lspitzner/43443ec2cb395c6bb244
09:12:16 <carterhinsley> gotcha
09:12:22 <hpc> things dealing with the physical reality of being on a computer go in System, control flow things in Control, etc
09:12:27 <carterhinsley> AHOY
09:12:34 <carterhinsley> Bindings. might that be the one?
09:12:42 <hpc> ah, maybe
09:12:45 <merijn> carterhinsley: I would ignore the existing top levels things
09:12:50 <merijn> carterhinsley: Data/Control are stupid
09:12:59 * carterhinsley likes the way merijn thinks
09:13:10 <merijn> carterhinsley: I would follow pipes' example (depending on what you're doing) and use the library as top level module
09:13:21 <merijn> carterhinsley: pipes switched from Control.Pipes to just "Pipes"
09:13:23 <carterhinsley> indeedydoody
09:13:34 <carterhinsley> it does seem redundant
09:13:43 <carterhinsley> especially when the cabal file can just contain the category just the same
09:13:45 <merijn> carterhinsley: But make sure you don't squat any common/generic module name, since you can't use the same module name twice in the same program
09:13:51 <carterhinsley> definitely not
09:13:56 <hpc> merijn: in what way are they stupid?
09:14:02 <carterhinsley> the actual TLM is TensorFlow
09:14:05 <merijn> hpc: They add zero value, just adds more typing
09:14:12 <hpc> ah, fair enough
09:14:13 <carterhinsley> which i highly doubt will be used anywhere
09:14:24 <merijn> carterhinsley: I think just using "TensorFlow" as top level module is fine
09:14:33 <carterhinsley> agree +1 ( ͡° ͜ʖ ͡°)
09:14:57 <carterhinsley> i might name it Jeffrey though
09:15:02 <carterhinsley> just to be defiant
09:15:02 <merijn> hpc: I mean, I doubt you're going to argue "Control.Pipe" was better than just "Pipes" :)
09:15:16 <carterhinsley> the first one looks more javalike
09:15:23 <carterhinsley> robust enterprise systems and whatnot
09:15:27 <carterhinsley> makes my MBA tingle
09:15:45 <merijn> I mean, it makes sense for some things, i.e. "Text.Encoding" instead of "Encoding" seems sensible
09:15:55 <merijn> But having Data.Text instead of Text seems dumb in retrospect
09:15:59 <carterhinsley> i like it for standard language features
09:16:02 <carterhinsley> such as Data.Text
09:16:03 <carterhinsley> :^)
09:16:21 <carterhinsley> being able to qualify names makes that seem a lil better
09:17:06 <carterhinsley> but yeah merijn it makes sense and i can see omitting the Data TLM
09:18:18 <merijn> Extra bonus: The problem of "which should I pick" is now also gone ;)
09:18:32 <carterhinsley> almost
09:18:36 <carterhinsley> still got .cabal files
09:19:11 <carterhinsley> by the way, does leksah have a hoogle-esque type signature search feature?
09:21:33 <carterhinsley> or emacs
09:21:40 * carterhinsley rolls his eyes
09:21:43 <maerwald> pretty sure both emacs and vim have it
09:21:48 <carterhinsley> VIM DOES?!
09:22:05 <merijn> carterhinsley: Hoogle has a command line interface that you can easily integrate into whatever editor?
09:22:05 * carterhinsley outstretches his arm to the search engine
09:22:12 <carterhinsley> oh
09:22:16 <carterhinsley> hrm
09:22:19 <merijn> carterhinsley: So you can just install Hoogle locally
09:22:29 <carterhinsley> i kinda meant for local code
09:22:31 <merijn> I actually heard Hoogle5 is insanely fast
09:22:41 <osa1> which package is hoogle command line interface?
09:22:44 <merijn> carterhinsley: Hoogle can index your local code
09:22:49 <merijn> osa1: The same as the server :p
09:23:11 * carterhinsley weeps as a tchaikovsky choir crescendos
09:23:50 * hackagebot hjsonpointer 0.3.0.1 - JSON Pointer library  https://hackage.haskell.org/package/hjsonpointer-0.3.0.1 (seagreen)
09:25:49 <osa1> what's wrong with 1.24? it downloads a package in 10 minutes that downloads in an instant when I click on the tar.gz link on Hackage
09:25:54 <osa1> Cabal 1.24*
09:26:58 <hexagoxel> (uh.. secure connection overhead?)
09:27:20 <hexagoxel> wild guessing as usual :D
09:28:28 <carterhinsley> ♬ohhhh... pajamas, pajamas♬♬♬ how i hate pajamas ♬ they make me type slower and fall back to sleep and 6 hours later i havent committed anything stilllll:) ♬♬♬
09:37:03 <geekosaur> osa1, iirc secure connections ended up being a horrid hack because of bootstrapping issues. that said, 10 minutes does seem excessive
10:18:52 * hackagebot hjsonschema 0.10.0.2 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.10.0.2 (seagreen)
10:33:28 <EvilMachine> Is it possible, to have a type class, that treats one instance specially, and all others in a generic way?
10:34:10 <johnw> I don't know what you mean by specially and generic in this context
10:36:15 <EvilMachine> johnw: Similar to multi-param type classes, but have a one instance with two rigid parameters, and a second instance with the second parameter being a type variable, that gets used in all other cases.
10:36:48 <ski> EvilMachine : that's `OverlappingInstances'
10:37:04 <johnw> yeah, you just enable that, then specify one with specific parameters, and the other with type variables
10:37:05 * ski would try to avoid it
10:37:11 <EvilMachine> ski: Ah. Is there a rule for whet it uses which instance?
10:37:12 <johnw> but as ski says, it's considered bad form
10:37:20 <ski> EvilMachine : most specific
10:37:21 <EvilMachine> ski: Yes, I would like to avoid dirty code too. :)
10:37:50 <ski> EvilMachine : perhaps you could try the `showList' trick instead ..
10:38:29 <ski> (not sure if it's really that much better. probably worse under some metric)
10:39:56 <geekosaur> seems to always be unambiguous to me? whereas, typeclasses being open (normally), you get into trouble if a more specific instance doesn't live in the same module as the general one
10:40:10 <geekosaur> because then which one gets used depends on what has been imported, possibly transitively
10:45:57 <EvilMachine> trying to be more specific: I have a data source that can only store strings, with one native purpose (names). I store all kinds of identifiers in there, but names get stored unchanged for backwards compatibility, and all other identifiers get serialized as URLs. now i have a function that can return a subset of those identifiers. depending on the return type given by the caller. so if that type is stored as an identifier, I 
10:45:57 <EvilMachine> want to deserialize the URLs , but if the type is a name, i want ot just pass it back as-is.
10:46:04 <EvilMachine> how do I do that?
10:46:47 <EvilMachine> (actually, there are multiple data sources, that each have one native type, and a type instance to handle things.)
10:48:09 <EvilMachine> if the native types didn’t exist, I’d just serialize everything to URLs. But as it is, I have no clue how to treat things differently if the type is native and doesn’t need deserialization.
10:53:53 * hackagebot concurrent-machines 0.2.3.1 - Concurrent networked stream transducers  https://hackage.haskell.org/package/concurrent-machines-0.2.3.1 (AnthonyCowley)
10:57:38 <dolio> Why do you need a type class for this?
11:00:15 <johnw> that's pretty much a universally fair design question, at any point in time
11:00:42 <puregreen> does anyone know how to work around this haddock error? https://travis-ci.org/aelve/microlens/jobs/133171039#L303
11:01:05 <puregreen> I found some issues on haddock's github but it's not clear to me how they help
11:02:29 <thoughtpolice> puregreen: It was just fixed in upstream Haddock like a day ago, I think
11:02:40 <thoughtpolice> https://github.com/haskell/haddock/commit/7290bf9d00ee40d0e4ab2fb0bf045a5bea86d823
11:03:10 <thoughtpolice> A new stable release will hopefully come out soon, so the workaround would be to 'install new haddock in Travis' first. 8.0.2 will also have that fix presumably.
11:04:06 <puregreen> thoughtpolice: installing new Haddock won't help because I think the version of Haddock that Stackage uses is fixed
11:04:20 <sm> tweak that class's haddock locally until you avoid the bug ?
11:05:26 <puregreen> sm: yeah, that's what I'm going to do, I just hoped that someone had a ready workaround
11:05:47 <thoughtpolice> puregreen: I'm not sure how Stackage handles point releases of Haddock, but in that case I guess your Haddock users would have to wait for the next LTS/nightly to include it. :/
11:05:57 <thoughtpolice> Er, microlens users
11:06:26 <puregreen> I care about all 7 of my microlens users too dearly to betray them like that
11:07:52 <puregreen> okay, thanks everyone
11:07:53 <sm> right on! :)
11:08:55 * hackagebot blosum 0.1.1.1 - BLOSUM generator  https://hackage.haskell.org/package/blosum-0.1.1.1 (GregorySchwartz)
11:13:47 <hsk3> Here I was thinking Haskell dealt with immutable structures.
11:13:47 <hsk3> Then I come across IORef. Here is a thing that sits in memory and mutable.
11:13:49 <hsk3> What the hell?
11:14:31 <oherrala> yes?
11:14:33 <simpson> hsk3: To quote glyph, "Haskell has mutability! They're just ashamed of it."
11:14:34 <hsk3> What's the thinking behind this.
11:14:59 <Athas> hsk3: it is sometimes useful for performance reasons.
11:15:15 <Athas> Also MVar, the concurrency-enabled cousin to IORef.
11:15:25 <Athas> It is definitely a low-level construct, not something you would use often.
11:15:31 <simpson> hsk3: Well, mutability isn't bad on its own. What's bad is losing purity, referential transparency, etc.; those are the tools that empower us with equational reasoning.
11:15:57 <hsk3> simpson: so with IORef we lose those things don't we?
11:16:16 <hsk3> i mean lol IORef is a way to create global variables
11:16:16 <Athas> hsk3: IORefs can only be accessed in the IO monad, so the type of the function tells you that it is impure.
11:16:19 <hsk3> ah ok
11:16:27 <puregreen> you already lose them when you read/write to files
11:16:39 <puregreen> think of an IORef as a handle to a file
11:16:46 <hsk3> simpson: are you the algorithmic trading guy, by any chance?
11:17:09 <simpson> hsk3: Nope, I'm just some random person.
11:17:15 <hsk3> ok never mind
11:17:22 <simpson> hsk3: Anyway, no, the danger is not with IORef, but with unsafePerformIO.
11:18:40 <hsk3> simpson: and neither IO nor IORef involves unsafePerformIO do they
11:19:27 <simpson> hsk3: IO's definition is opaque; unsafePerformIO is a tool for altering that opacity, but it's not necessary.
11:19:30 <geekosaur> yep. pretty much anything goes in IO, so IORef is fine. (and STRef avoids IO, but doesn't let you leak them outside your evaluation context, so it still retains purity). it's when you decide it'd be convenient to get at those from elsewhere and use "backdoors" like unsafePerformIO that you get in trouble
11:20:20 <hsk3> i see
11:22:26 <hsk3> very nice
11:22:39 <ski> puregreen : you don't "lose them when you read/write to files", no
11:23:43 <ski> hsk3 : the important part is declaring explicitly in the interface (the type), that you're expressing effects
11:24:01 <ski> that means that it's not a side-effect, but just an effect
11:24:18 <puregreen> ski: I should've said “IORefs make you lose as much purity/referential transparency as files do”, I guess (unless that's not true either?)
11:24:33 <sinelaw> is Arbitrary suchThat prone to infinite loops?
11:24:42 <ski> puregreen : they make you lose it as much yes .. which is not at all
11:25:17 <puregreen> yep, the intended meaning was “if you're scared of IORefs you should be equally scared of files” :)
11:25:22 <ski> ok
11:26:05 <dolio> Files are worse than IORef, probably.
11:27:04 <dolio> In multiple ways.
11:30:07 <ski> (yes. mutable stuff, and files, &c. are just as problematic as before. but the gain here is that you don't have to check all the time that every library operation you call might do side-effects behind your back)
11:31:14 <dolio> Files could probably be better than IORef, but we're hamstrung by legacy systems.
11:36:22 <eacameron> Does MonadBaseControl have an effect on performance vs just plain IO?
11:55:20 <tippenein> is there something like (Traversable a) => IO (t a) -> Producer a  ?
11:56:02 <tippenein> basically, a mapConcurrently readFileLn someFiles as a bunch of producers
11:56:14 <tippenein> or am I thinking about it wrong
11:58:16 <tippenein> or [Producer a m ()] 
11:59:07 <maroth_> Can someone please help me grasp exercise 2.32 in SICP? It's making no sense at all and I can't manage to organize all of my thoughts when trying to solve it. I'm starting to think I'm not cut out for this programming thing. Any help?
12:00:09 <tippenein> the set of all subsets problem?
12:00:10 <Tekkkz> how to avoid the "maybe you havent installed the profiling libraries for package xxx" when i have the libraries ? i can load them in my ghci
12:00:23 <maroth_> tippenein: Yep.
12:00:34 <tippenein> Tekkkz: you have to build the binary with some flags iirc
12:01:00 <Tekkkz> how?
12:01:17 <tippenein> stack build --executable-profiling --library-profiling --ghc-options="-fprof-auto -rtsopts"
12:01:24 <maroth_> If I can't solve this exercise, I'm not cut out for programming, IMO.
12:01:25 <tippenein> are you using stack?
12:01:34 <ski> maroth_ : it's representing sets as lists, yes ?
12:01:44 <Tekkkz> no i want to build cabal and cabal-install from sources
12:01:44 <ski> maroth_ : recursion may take some while getting used to
12:03:03 <ski> maroth_ : the key part is to be able to recognize, when thinking about how to solve a "larger" recursive problem, smaller instances (or just one of them) of the same kind of recursive problem
12:03:14 <tippenein> Tekkkz: maybe cabal run your-exe -- +RTS -p
12:03:22 <tippenein> not quite sure with cabal.
12:03:30 <Tekkkz> nono i dont have cabal yet
12:03:46 <ski> maroth_ : i assume you're already seen how to (recursively) compute the length of a list, the sum of a list of numbers, and so ?
12:04:14 <maroth_> ski: Yeah.
12:04:23 <puregreen> is there any way to say “#ifndef __HADDOCK__” or something?
12:04:29 <tippenein> Tekkkz: I'm confused. what gave you the "maybe you haven't installed" message?
12:04:38 * ski . o O ( <https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.32> )
12:05:12 <Tekkkz> ./bootstrap.sh --no-doc
12:05:15 <ski> maroth_ : so, when computing `(subsets (list 1 2 3))', what would the appropriate "smaller instance of the same problem" be ?
12:05:20 <Tekkkz> from inside cabal-install
12:05:50 <ski> maroth_ : a guess would be fine
12:05:53 <tippenein> ah, sorry. can't help you there.
12:06:00 <puregreen> hm, “#ifndef __HADDOCK__” actually should work but it seems not to
12:06:28 <maroth_> ski: Uh, '(subsets (list 2 3))'?
12:06:59 <geekosaur> note that ghci does not normally use the profiling libraries
12:07:23 <geekosaur> they are actually different libraries from the normal ones
12:07:32 <Tekkkz> geekosaur: please tell me. what are profiling stuff?
12:08:31 <geekosaur> they include extra code to track when functions and profiling annotation points ("SCCs") are evaluated, among other things
12:09:04 <Tekkkz> geekosaur: i need to get cabal working, so how can i build it then?
12:10:04 <maroth_> ski: I guess I guessed wrong... I suck at this.
12:10:09 <geekosaur> this sounds to me like you have a ghc without the profiling libs, so you'd need to disable the build of profiling libs for cabal *or* install ghc's profiling libs
12:10:24 <geekosaur> (in particular the profiling version of HSbase)
12:10:24 <Tekkkz> how to isntall ghc's profiling libs?
12:10:37 <geekosaur> ... I don't know how you installed ghc so I can't answer that
12:11:02 <Tekkkz> i installed it from debian repo
12:11:40 <ski> maroth_ : no `(subsets (list 2 3))' is good
12:12:38 <ski> maroth_ : the next task is to figure out what the *intended* result for that *ought* to be (not what your current code would give for it)
12:13:14 <ski> maroth_ : and then figure out how to, programattically, get from that intended recursive result, to the intended result for the main call `(subsets (list 1 2 3))'
12:13:52 <geekosaur> hrr, I can't even see those because it's shadowed by hvr's ppa >.>
12:14:05 <Tekkkz> http://ftp.de.debian.org/debian/pool/main/g/ghc/ghc_8.0.1-1_arm64.deb
12:14:10 <hvr> geekosaur: ?
12:14:33 <geekosaur> sorry, didn't mean to ping you. trying to see debian's ghc packages when I have yours installed >.>
12:14:49 <hvr> geekosaur: my ghc packages shouldn't collide with debian's
12:14:56 <maroth_> ski: So... start small with problems like these?
12:15:18 <hvr> geekosaur: unless debian started naming them in the same way
12:15:30 <geekosaur> hm, wonder why this didn't show up then
12:15:38 <geekosaur> Tekkkz, sudo apt-get install ghc-prof
12:17:06 <Tekkkz> wait a moment. i am not on debian system, just using their prebuilt packages, wait pls
12:18:10 <geekosaur> so it should be something like ghc-prof-8.0.1_1-arm64.deb
12:18:13 <geekosaur> er
12:18:14 <Tekkkz> yup
12:18:19 <geekosaur> so it should be something like ghc-prof-8.0.1-1_arm64.deb
12:18:27 <geekosaur> swapped - and _
12:18:38 <ski> maroth_ : yes. though i'd say `subsets' is probably a bit difficult, for beginners
12:18:45 <Tekkkz> i already found the link. i am currently installing it
12:18:50 <geekosaur> and that should get you the profiling bootlibs, so the profiling build should work after that
12:18:57 * hackagebot fixed-vector-hetero 0.3.1.1 - Generic heterogeneous vectors  https://hackage.haskell.org/package/fixed-vector-hetero-0.3.1.1 (AlexeyKhudyakov)
12:18:59 * hackagebot VKHS 1.6.2 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-1.6.2 (SergeyMironov)
12:20:04 <ski> maroth_ : you could try defining `tails' and `heads'
12:20:21 <ski> er, actually s/heads/inits/
12:20:28 <ski> maroth_ : `(tails (list 0 1 2))' should give the same result as `(list (list 0 1 2) (list 1 2) (list 2) (list))'
12:20:43 <oherrala> haskell-src-exts and happy seem to be always some kind of issue :/
12:21:03 <ski> maroth_ : `(inits (list 0 1 2))' should give the same result as `(list (list) (list 0) (list 0 1) (list 0 1 2))'
12:21:24 <ski> maroth_ : `tails' will probably be easier than `inits'
12:21:31 <oherrala> I'm trying to set up Travis CI and everything goes smoothly until haskell-src-exts which can't find happy (which is installed)
12:22:28 <ski> maroth_ : it might help to use `map' here, if you've learned how to use it. though it can be done without `map' as well
12:25:28 <Tekkkz> geekosaur: i compile cabal again now, maybe it works. ill tell you when i finish
12:29:37 <sinelaw> How can I derive Generic for: data Fix f = Fix (f (Fix f))
12:30:25 <ski> try `deriving instance Generic (f (Fix f)) => Generic (Fix f)' with `StandaloneDeriving' ?
12:30:49 <ski> (obviously also `DeriveGeneric')
12:31:02 <ski> (also that ought to be a `newtype', no ?)
12:31:54 <sinelaw> uh yeah, it is newtype (in my code)
12:33:21 <sinelaw> yeah, that worked
12:38:40 <sinelaw> quickcheck doesn't seem to be shrinking stuff
12:39:10 <sinelaw> is the default shrink implementation = [] ?
12:39:25 <sinelaw> (when not deriving)
12:42:32 <lyxia> yes
12:43:58 * hackagebot extra 1.4.8 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.8 (NeilMitchell)
12:56:09 <EvilMachine> hey, what is the *idiomatic* Haskell way, of returning a list of things that all have the same interface of functions? (considering SomeClass c => [c] isn’t a valid return type)
12:56:33 <EvilMachine> And if it is considered generally bad in some way, why exactly?
12:56:56 <nagyf> hey all! I'm trying to use sdl2 module in haskell. Everything is installed and configured, but in the examples there are a Paths_sdl2 module
12:56:57 <EvilMachine> Is is just due to the MonomorphismRestriction, or are there other reasons?
12:57:11 <nagyf> I can't find it anywhere. what is this Paths_sdl2 module?
12:57:11 <ski> (`SomeClass c => [c]' is not what you want, for at least two reasons)
12:57:37 <merijn> nagyf: Paths_ modules are auto generated by cabal
12:58:03 <ski> EvilMachine : sounds like you want `[exists c. SomeClass c *> c]' .. which you'll have to encode, one way or another, in GHC
12:58:11 <ski> (EvilMachine : not sure about idiomatic)
12:58:21 <maroth_> ski: This seems to work for tails appropriately - http://pastebin.com/mGJSBQYi
12:58:26 <ski> EvilMachine : and you should already have read
12:58:36 <ski> @where existential-antipattern
12:58:36 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
12:58:49 <nagyf> merijn, thanks. I've installed sdl2 with stack, and when I try to build one of the examples i get an error that it can't find Paths_sdl2
12:58:59 * hackagebot LambdaDB 0.0.0.5 - On-memory Database using Lambda Function environment.  https://hackage.haskell.org/package/LambdaDB-0.0.0.5 (Ailrun)
12:59:02 <maroth_> ski: You said 'init' is the one that will likely require map, right?
12:59:08 <nagyf> merijn, where does it generated to? I'm on linux, arch
12:59:29 <EvilMachine> ski: well, then you should already have told me about it. it’s not like people are just born with it, or a guy randomly comes in and holds up a big sign. :))
12:59:35 <ski> maroth_ : yeah, that `tails' is correct
12:59:40 <EvilMachine> ski: Thanks btw
12:59:43 <ski> maroth_ : `inits', yes
13:00:36 <ski> EvilMachine : i mean should you have read that, because going off and try doing something nontrivial with existentials
13:00:39 <ski> :)
13:01:11 <ski> EvilMachine : do you want a short explanation of `exists' ?
13:01:25 <EvilMachine> ski: The problem is, that people always assume all types that could be part of that class are known at development time or compile time. While the whole point here is, that the types managed by the interface are open to new implementations by other people in the future.
13:01:33 <maroth_> ski: So, skipping 2.32 (I'll try to implement 'tails', though) won't heavily damage me or impede my learning in the long-run, will it? Because, atm, I just can't with that problem.
13:01:34 <mikail_> Hi,I need your advices. What is the most efficient way to sum over a big but finite list?
13:01:50 <EvilMachine> ski: Don’t worry. I’ll fully read it today.
13:02:01 <johnw> mikail_: I had thought that "sum" was pretty efficient these days
13:02:18 <ski> maroth_ : as long as you come back to it (or something similar), i wouldn't worry about skipping it
13:02:18 <mikail_> I'm a newbie johnw
13:02:40 <mikail_> if that is the way to go then that is fine for me
13:02:41 <EvilMachine> ski: I think I kinda understand `exists`, but if you want, you probably have a more intuitive one. :)
13:02:47 <johnw> I'd start there
13:02:55 <johnw> worry about its efficiency if it becomes a problem
13:02:56 <ski> EvilMachine : iirc, that post doesn't really explain existentials, but explains common abuses of it
13:03:11 <mikail_> i am have written a monte carlo simulator and when i have 30000 doubles, summing takes some time
13:03:21 <johnw> it may not be the summing that is slow
13:03:26 <EvilMachine> ski: So there are cases that aren’t abuses… yes?
13:03:31 <mikail_> so i need to profile
13:03:34 <johnw> with Haskell, speed has be a complex thing
13:03:36 <johnw> can be*
13:03:37 <ski> EvilMachine : yes
13:03:40 <davean> mikail_: Might these be in a Vector?
13:03:48 <ski> EvilMachine : saying `foo :: forall a. ..a..' means that for each type `T' that we can replace `a' with, `foo' *can* have type `..T..'
13:03:53 <mikail_> no davean, they are in a normal list
13:03:57 <mikail_> should i use Vector?
13:03:59 * hackagebot prompt 0.1.1.1 - Monad (and transformer) for deferred-effect pure  prompt-response queries  https://hackage.haskell.org/package/prompt-0.1.1.1 (jle)
13:04:05 <EvilMachine> ski: Nice. So the article should give me a feeling if my case is such a misuse. Exactly the right thing.
13:04:07 <davean> mikail_: Most of your performance is probably lost chasing the list
13:04:16 <davean> mikail_: Try a vector
13:04:22 <mikail_> thank you, I will
13:04:23 <davean> mikail_: preferable an Unboxed one
13:04:27 <johnw> mikail_: I have a gut feeling that your performance is lost allocating memory in preparation of doing work, and then doing the work and freeing it
13:04:30 <johnw> I wouldn't switch to Vector just yet
13:04:33 <ski> EvilMachine : sorry, `..T..'
13:04:34 <davean> mikail_: http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed.html
13:04:37 <ski> EvilMachine : saying `bar :: exists a. ..a..' means that there *exists* some type `T' (that has been replaced by `a'), such that `bar' was constructed to have type `..T..'
13:04:46 <johnw> a properly fused-away list is faster than a vector
13:04:51 <mikail_> thank you Sirs, I will take on your advices
13:05:10 <davean> johnw: if he doesn't have to keep them around
13:05:27 <johnw> i.e., it's not always a data problem, sometimes it's a process problem
13:05:37 <mikail_> i just need to compute the average so this is why i am summing
13:05:58 <ski> EvilMachine : `sort :: forall a. Ord a => [a] -> [a]' means that the *caller* of `sort' gets to pick a type `a' (as long as it's in `Ord'), so that `sort', for that call, will have type `[a] -> [a]'
13:06:01 <johnw> mikail_: the real question I have is: do you *only* need the data points to do the summing, or do you do other things with them after?
13:06:22 <johnw> if you frequently need random access into a common data set, then vector is much faster
13:06:24 <mikail_> no sir, i just need to compute the average then i can discard them
13:06:33 <johnw> but if you only need to process, consume, discard, then lists are faster if you do it right
13:06:35 <mikail_> they are generated as part of the MC simulation
13:06:48 <davean> Oh yah, the just generate them straight into the summation
13:06:59 <EvilMachine> ski: Aaah! Otherwise the callee picks the type? That is something that wasn’t obvious to me!
13:07:08 <mikail_> I will post my code in lpaste to show you
13:07:12 <mikail_> what i did
13:07:25 <ski> EvilMachine : `hidden :: exists a. Show a *> [a]' would mean that there is a (single !) type `a', which is in fact in `Show', such that `hidden' was constructed as a list of elements of type `a' (all of the same type). so with `exists', it's the callee, not the caller, which gets to pick the type
13:07:57 <pillow> hi, I am trying to memoize a function of Integer -> Integer with a sparse domain, i tried to google but the example on the haskell wiki for fibonnacci use a list as a memo (which is not sparse and has O(n) access time), anyone got suggestions please ? (PS: i have to use GHC 7.6.3 and i cant install additional libraries)
13:08:00 <EvilMachine> ski: So even if I say f x :: Sometype, f still gets to pick the return type, unless that forall is in its type signature?
13:08:19 <ski> EvilMachine : `hidden :: [exists a. Show a *> a]' would mean that for each element of the list `hidden', there exists some type `a', in `Show', such that that element has type `a'. the type `a' may here be different for each element
13:08:32 <mikail_> http://lpaste.net/164605
13:08:57 <ski> EvilMachine : please elaborate on the question. i don't understand it
13:09:04 <mikail_> if I call simulate with the paths set to 30000 and steps to 1000, then I generate a very big list
13:09:15 <Hijiri> pillow: you could reimplement the memoize package with the special case of Integer -> Integer
13:09:20 <mikail_> for those 30000 paths I want to sum the
13:09:23 <Hijiri> or enough of the package to memoize that one function
13:09:31 <mikail_> in order to calculate the average
13:09:42 <Hijiri> I'm not quite sure how it works though
13:09:58 <johnw> mikail_: use foldl' here, not foldr
13:09:59 <ski> EvilMachine : with `forall', the caller/user picks the type, and the callee/implementor may assume nothing about it, must treat it opaquely
13:10:01 <Hijiri> maybe it uses a lazy tree
13:10:02 <EvilMachine> ski: Well, in my class Myclass a where { f :: (Myclass b, Myclass c) => a -> b -> [c] } they’re not supposed to be all of the same type.  
13:10:06 <pillow> Hijiri: I dont think I understand enough at the moment to re-implement any of it (or even still the code for that matter)
13:10:10 <ski> EvilMachine : with `exists', it's the opposite way around
13:10:16 <maroth_> Thanks for the help, ski. :)
13:10:22 <mikail_> is that faster johnw?
13:10:27 <johnw> in this particular case, much
13:10:33 <ski> maroth_ : no problem :)
13:10:33 <mikail_> oh wow
13:10:36 <mikail_> thank sir
13:10:47 <Hijiri> pillow: The idea is that you make a searchable map data structure that is defined to have all the answers as values
13:10:49 <mikail_> i will try that
13:10:55 <Hijiri> And have it be lazy, so you don't generate the whole thing at once
13:11:00 <Hijiri> (which wouldn't work for Integer)
13:11:23 <Hijiri> A simple BST wouldn't work for Integer, since it's infinite, and you have no middle to start in
13:11:29 <Hijiri> So something based on exponentials?
13:11:33 <ski> EvilMachine : with `foo :: forall a. ..a..' it's always the user/caller of `foo' which gets to pick `a'
13:11:50 <EvilMachine> ski: sounds like forall is what is right for my function, since it exactly has no and should not have any clue what it handles, apart from it being from the class. (It uses a class function to create it from a string.)
13:12:03 <pillow> Hijiri: I am a bit confused, i thought that because functions dont have side effect it should be trivial to memoize them
13:12:11 <EvilMachine> ski: Yes, that’s step 1. Which is nice.
13:12:16 <ski> EvilMachine : with your `f :: forall b c. (Myclass b,Myclass c) => a -> b -> [c]' method of `Myclass a', the caller will pick `b' and `c' (as long as theire in `Myclass')
13:12:25 <Hijiri> pillow: The tricky part is you need to save the answer somewhere once you have the value
13:12:26 <ski> s/theire/they're/
13:12:34 <Hijiri> There's no mutation so you can't just have some table that you set the values in
13:12:53 <pillow> Hijiri: and the compiler cannot do that for me ?
13:13:08 <Hijiri> The compiler won't automatically memoize functions for you
13:13:14 <Hijiri> I don't think it can, in general
13:13:16 <pillow> is there a glag ? :)
13:13:16 <dolio> It is trivial to use all your memory up by memoizing the result of every function.
13:13:19 <pillow> flag*
13:13:33 <EvilMachine> ski: I’m insecure though, what are the correct uses of forall, and which cases are just Java programmers trying to force Haskell to behave like Java. :)
13:13:35 <Hijiri> what's glag?
13:13:49 <pillow> dolio: thats correct, but maybe i could have a flag like --memo=myFunctionName 
13:13:52 <tippenein> anyone written a simple multi-player card game ion haskell?
13:13:56 <ski> EvilMachine : if you want `f' to be able to pick `c', then you probably either want `f :: forall b. Myclass b => a -> b -> exists c. Myclass c *> [c]' or `f :: forall b. Myclass b => a -> b -> [exists c. Myclass c *> c]' (the latter would be more likely, i'd guess)
13:14:24 <pillow> Hijiri: i meant a compilation flag (typo sorry)
13:14:30 <Hijiri> oh
13:14:50 * ski thinks there ought to be a pragma for memoization/tabling
13:15:25 <Hijiri> There's no flag as far as I know
13:15:39 <johnw> ski: with support for strategies, like cache size, expiration method, etc.
13:15:46 <ski> yes
13:15:46 <EvilMachine> ski: Btw, I am *very* bad with one-letter variables and pure structure, like typical for mathematicians. My brain seems to work differently, and can’t attach meaning to such things, making it impossible to keep them in mind when looking at things that use them. So I have big trouble with what you just wrote. :/
13:15:54 <ski> (Mercury has something like that)
13:15:57 <dolio> How much better would it be than using a library?
13:16:39 <hpc> EvilMachine: usually one-letter names are meant to convey a lack of meaning
13:16:46 <hpc> a sort of "this could be anything" kind of deal
13:16:56 <EvilMachine> ski: f should only be able to pick a (=from), and leave b (=via) and c (=to) to the caller.
13:17:21 <hpc> EvilMachine: as your definitions get less abstract, so do the names you give them
13:17:26 <pillow> dolio: i would use a library if I was running the code, but it's for a challenge at codechef.com and they only have an old GHC 7.6.3 :(
13:17:40 <ski> EvilMachine : i'm thinking in terms of a single fixed `a' (as you'd do when you're writing an instance of `Myclass')
13:18:05 <ski> EvilMachine : if caller determines `b' and `c', then `f :: forall b c. (Myclass b,Myclass c) => a -> b -> [c]' sounds ok, i guess
13:18:30 <hpc> pillow: binary search tree perhaps?
13:18:40 <ski> EvilMachine : btw, you should perhaps also note that i used `*>' as distinct from `=>'
13:18:46 <hpc> it'd at least be O(n) in the number of elements, instead of O(n) in the largest element
13:19:13 <pillow> hpc: I think the additional O(log n) would be acceptable for the timelimit, but how can I implement the memoize over a bst ?
13:19:14 <EvilMachine> hpc: Maybe saying that in my brain, that is exactly equivalent to not writing anything at all, makes it a bit more clear why that’s so problematic for me. Try reading what ski wrote, but completely remove all one-letter variables, and replace forall, *>, exists and that dot after forall and exists, by wiggly clouds of confusion. :)
13:19:55 <dolio> It's not too hard to memoize Integer functions with a little endian bit trie.
13:20:29 <hpc> oh right, or that
13:20:32 <pillow> dolio: could you point me to a page explaining that, or walk me through it please ? :)
13:20:42 <EvilMachine> ski: I have no idea what *> does. To me it is a face with one eye and a v-shaped mouth, or a ice cream cone with one of two balls missing. :)
13:22:36 <dolio> pillow: You build an infinite binary tree. At the root is the answer for a 0-bit integer. Down the left branch is the answers for an n+1-bit integer where the lowest bit is 0, and the right tree has the answers where the lowest bit is 1. And when you move down a branch, you shift off the lowest bit to get an n-bit integer.
13:23:30 <hpc> and for negative numbers, you'd have two trees
13:23:39 <hpc> or the trie would store tuples
13:23:58 <ski> EvilMachine : a value of type `Ord a => [a] -> [a]' requires *you* providing an instance of `Ord' for `a', before allowing you to use it as a function of type `[a] -> [a]'
13:24:01 <dolio> But it's slightly more complicated than that, because that only works for non-negative numbers, so the real top level is distinguishing on the sign bit.
13:24:53 <ski> EvilMachine : a value of type `Ord a *> Set a' will *itself* provide you with an instance of `Ord' for `a', in addition to allowing itself to be used as a `Set a'
13:24:58 <dolio> Otherwise you get something that looks like infinitely many 1 bits.
13:25:05 <pillow> dolio: but having a bit trie how do I twick the recursive function to lookup on that ?
13:25:22 <ski> EvilMachine : `=>' would normally be used with `forall', as in `sort :: forall a. Ord a => [a] -> [a]'
13:25:52 <hpc> pillow: write some function that takes a number and uses quotRem to figure out which direction to go down the tree
13:26:05 <hpc> recursively
13:26:21 <ski> EvilMachine : `*>' would normally be used with `exists', as in `[exists a. Widget a => Tree a]' (or something)
13:26:46 <hpc> let (q, r) = number `quotRem` 2 in if q == 0 then something else ...
13:26:49 <dolio> pillow: The most naive way is that you write 'foo :: Integer -> a' then build a trie by storing the answer at each leaf, and then write 'memoFoo :: Integer -> a' which looks the answer up in the trie.
13:26:51 <zq> if i have -XDataKinds and data Kind = A and then a gadt data D a where  A :: D Bool, how could i explicitly reference the constructor A and not the type 'A?
13:27:17 <dolio> pillow: But the less naive way is if 'foo' is recursive, then your recursive calls should look up the answer in the trie.
13:27:24 <ski> (that would be a list of trees of something, where the element type may be different for each tree (but is the same within a tree). and where it is known that the element type is an instance of `Widget' in each case)
13:27:25 <EvilMachine> ski: I read the article now, and I recognize that style. He just stores the functions (and their closures) right in the data type, instead of having a class and multiple types with instances. He fails to mention that once a a Window has passed toWidget, it can never become a full Window with all available functions again.
13:28:44 <pillow> dolio: hpc: sorry to be so picky, but i have trouble to follow, any chance you could give me a 5 lines example for something like f 0 = 0    f i = f (i / 2) + f (i / 3)
13:29:06 <EvilMachine> ski: regarding (*>): Where does the instance come from, if *itself* provides it? 
13:29:57 <ski> EvilMachine : the instance must be in scope when the value is constructed
13:30:10 <EvilMachine> ski: Ok. :)
13:30:10 <hpc> pillow: fStructure = (recursive trie-ish thing); fMemo i = lookupStructure fStructure i
13:30:57 <hpc> pillow: fStructure n = Trie (something fMemo n 0) (fMemo n) (something fMemo n 1)
13:31:18 <ski> EvilMachine : e.g. if we imagine `foo :: Bool -> exists a. Show a *> a; foo False = True; foo True = "False"', then this would rely on there being `Show Bool' and `Show String' in scope
13:31:21 <Hijiri> EvilMachine: You wouldn't be able to do that with existential datatypes either
13:31:34 <hpc> that something there is defined recursively in terms of fStructure and fMemo again
13:31:37 <ski> EvilMachine : note how in this case the choice of `a' depends on the *value* of the `Bool' argument, btw
13:31:48 <hpc> and probably doesn't take those exact parameters, but it will end up depending on them
13:32:40 <hpc> pillow: fStructure starts out as a perfectly ordinary thunk, and as fMemo is called it gets traversed and gradually more evaluated
13:32:45 <ski> EvilMachine : "He fails to mention that once a a Window has passed toWidget, it can never become a full Window with all available functions again." -- the same holds for going from an `a' (with `Widget a' known) to `exists a. Widget a *> a'
13:32:46 <EvilMachine> ski: Regarding the method in the article: What about passing a Window through a function that only handles Widgets, and then wanting to use Window functions on it? It has stopped being a full window. It is now just by coincidence but not necessarily related bits and pieces (functions and values), molded into Widget. 
13:32:59 <EvilMachine> ski: ah, i was one second too late :)
13:33:06 <hpc> pillow: but because it's top-level it never goes away and stays evaluated for next time
13:33:14 <hpc> pillow: and will be memoized that way
13:33:23 <EvilMachine> ski: Yes, which is why (exists) is also not enough.
13:33:51 <ski> EvilMachine : however, passing a `Window' through `forall a. Widget a => ... -> a -> a' is just fine
13:33:52 <EvilMachine> ski: I think I’m now at a point, where I need to ponder what I *actually* want.
13:34:07 <EvilMachine> ski: But now I have a lot more insight, thanks to you. :)
13:34:36 <merijn> You almost never want ExistentialQuantification (and after you try it for the first time, you'll know why :p)
13:34:59 <EvilMachine> ski: I guess it will end up being some (forall) thing… but I have to check that it is extra-clean, considering it is the core of every code I will ever write from now on. :)
13:35:29 <ski> EvilMachine : anyway, i should mention that `exists' and `*>' is just pseudo-code that i'm using to explain the concept. to actually (currently) implement it in GHC, you need to *encode* it (in one of two main ways). however, i happen to think that it's usually nicer to think in terms of `exists' and `*>', rather than the encoding
13:35:34 <EvilMachine> merijn: please elaborate. (Or is it quicker and clearer if I just try? :))
13:35:45 <EvilMachine> ski: aah, 
13:35:52 <dolio> I want it all the time.
13:36:07 <EvilMachine> ski: no clue how to encode it.
13:36:14 <ski> (also `ExistentialQuantification' is, imho, a misnomer since it doesn't give you `exists' (it gives you one of the encodings))
13:36:19 <merijn> EvilMachine: The existential quantification doesn't let you do anything more than actually applying a function, standard example: "[Show s => s] is really just [s]
13:36:22 <EvilMachine> dolio: If there’s a rule to encoding it, a pre-processor should do it. :)
13:36:23 <merijn> eh
13:36:26 <merijn> Just [String]
13:36:46 <ski> merijn : it does let you do more, in nontrivial cases
13:36:46 <merijn> EvilMachine: You have to write A LOT of boilerplate for existential quantification and it doesn't really solve the original problem
13:37:00 <EvilMachine> merijn: which is?
13:37:04 <merijn> ski: I'm not saying you NEVER want EQ, just almost never :p
13:37:20 <ski> merijn : depends on who "you" is (see dolio) :)
13:37:22 <merijn> EvilMachine: Wanting a list of things that follow a certain interface
13:37:24 <dolio> You should learn some more interesting examples.
13:37:36 <merijn> dolio: I like EQ with GADTs, etc. :)
13:37:48 <ski> merijn : same thing
13:38:16 <EvilMachine> merijn: Frankly, this smells like an almost-never case, considering it is a pretty unusual thing. (Yes, yes, I know, mystery me… Sorry, don’t want to tell anyone until it actually works and works elegantly.)
13:38:47 <merijn> EvilMachine: Earlier in #haskell-beginners I gave an example of how you could do, e.g. [Renderable a => a] without existentials
13:39:10 <merijn> lemme see if I can find it
13:39:17 <EvilMachine> merijn: How would you solve the “list of things that follow a certain interface” problem? (And if it is just a symptom of nomething more sensible, what is that more sensible way?)
13:39:29 <merijn> EvilMachine: So what are you trying to do?
13:39:34 <EvilMachine> merijn: Probably like https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
13:39:53 <merijn> EvilMachine: No, that's exactly what I was warning not to do ;)
13:40:20 <merijn> blah, lost my scrollback with my example from earlier...
13:40:42 <merijn> EvilMachine: Like this: http://lpaste.net/164596
13:40:56 <ski> EvilMachine : we can encode `[exists a. Widget a *> Tree a]' as `[SomeWidgetTree]', where `data SomeWidgetTree = forall a. Widget a => WrapWidgetTree (Tree a)' (or alternatively, we can define the same thing with GADT syntax as `data SomeWidgetTree where WrapWidgetTree :: forall a. Widget a => Tree a -> SomeWidgetTree' (`forall' is optional))
13:41:06 <EvilMachine> merijn: I am trying to create a generic interface with which I can handle data of any arbitrary, even not yet invented type, because I found functions that apply to all of them… even the not yet invented ones.
13:41:59 <EvilMachine> merijn: regarding the link: look down. i mean the solution he presents. not the problem at the top.
13:42:05 <hpc> pillow: if you're doing project euler or something like that, those problems are largely intended to be solved analytically
13:42:29 <merijn> EvilMachine: Eh, yes, I think that's similar to what I wrote :)
13:42:32 <ski> EvilMachine : the other way is to use the CPS encoding. here that'd be `[forall o. (forall a. Widget a => Tree a -> o) -> o]'. it requires `Rank2Types' (or `RankNTypes'). in this case also `ImpredicativeTypes', since you have `forall' inside a list (you can hide that in another data type if you prefer. `PolymorphicComponents')
13:42:58 <EvilMachine> ski: Aah, so exactly the upper example in the article. Ok, now I’m starting to see the big picture. :)
13:43:02 * ski thinks merijn meant `[exists a. Renderable a *> a]'
13:43:32 <dolio> I'm not sure how it's not really existential quantification, either. It's just not first class like forall is. It would be like if there were no rank-n types, but you still had PolymorphicComponents.
13:43:58 <ski> EvilMachine : logically, `(exists a. ..a..) -> ...' is equivalent to `forall a. (..a.. -> ...)'. e.g. `length :: (exists a. [a]) -> Int' means the same as `length :: forall a. ([a] -> Int)'
13:44:07 <EvilMachine> ski: what does CPS stand for, apart from child-protective services? :)
13:44:15 <johnw> continuation-passing style
13:44:15 <Cale> Continuation passing style
13:44:19 <dolio> It's a little more convenient than a polymorphic-components-like existential quantifier would be, too.
13:44:19 <EvilMachine> ski: ah, yeah
13:44:20 <EvilMachine> duh
13:44:21 <EvilMachine> lol
13:44:52 <EvilMachine> I haven’t managed to get an intuitive mindset/feel for CPS. Unfortunately. 
13:45:23 <EvilMachine> I have to look up the concept of type “rank” sometime…
13:45:26 <johnw> instead of a function returning a result, it accepts another function to call with that result.  done
13:45:30 <merijn> EvilMachine: You know how C functions calls are compiled in assembly? (With pushing/poping stack frames?)
13:45:33 <pillow> hpc: this is codechef.com i got a Dynamic programming solution in python working perfectly, it's just me being unable to translate that to haskell (the memoize part)
13:45:34 <ski> EvilMachine : because of this, the polymorphic data constructor `WrapWidgetTree :: forall a. Widget a => Tree a -> SomeWidgetTree' can ben thought of as `WrapWidgetTree :: (exists a. Widget a *> Tree a) -> SomeWidgetTree', which explains why the extension allowing this is named `ExistentialQuantification' (still a misnomer, imho. better would perhaps be `ExistentialConstructors')
13:45:50 <hpc> EvilMachine: try messing around with something like ($ False) and see what kind of weird things you can do
13:46:03 <merijn> pillow: With laziness memoizing dynamic programming is actually super easy
13:46:24 <hpc> as you're going through exercises elsewhere
13:46:41 <ski> EvilMachine : it also explains why `forall' is used in `data SomeWidgetTree = forall a. Widget a => WrapWidgetTree (Tree a)' to declare an "existential data type" ("existential data constructor" would be slightly better)
13:46:44 <hpc> that should at least give you something a bit more concrete to get started
13:46:52 <merijn> pillow: Let's restrict ourselves to a simple case where we our arguments are single integers (although generalising isn't very hard)
13:47:03 <ski> EvilMachine : the data constructor itself is polymorphic, but since the type variable `a' doesn't occur in the result type, the effect is that it *hides* that type
13:47:10 <pillow> merijn: it's top down, i cannot bottom up because the domain is very sparse, something like f 0 = 1  f n = f (n / 2) + f (n / 3), is it something i can do with lazyness easily ?
13:47:30 <merijn> pillow: What do you mean with top-down vs bottom-up?
13:47:32 <EvilMachine> ski: damn, I knew that forall/exists logic stuff once! I’m now remembering that I read a lot about it, and had understood what you‘re explaining right now. Stupid Kelly Bundy brain of mine… Like a buffer with a Lemming cliff at the other end. :)
13:47:46 <pillow> merijn: can i paste you python code ?
13:48:11 <merijn> Sure, but whether I'll read it depends on the length+readability to curiosity ratio ;)
13:48:20 <ski> EvilMachine : anyway, i understand that i'm probably going other some things too quickly atm for you to be able to grasp them well. i'm mostly aiming for pointing out the main interesting things, to learn more later (from me, or other sources)
13:48:50 * ski has to leave soon
13:48:59 <EvilMachine> merijn: yes, i used to do low-level programming when I was younger. i also know that nowadays, they try to put as many function parameters into registers as possible, because stack is slow.
13:49:02 <prohobo> ski free
13:49:06 <prohobo> ski free my friend
13:49:06 * ski doesn't ski
13:49:14 * prohobo mumbles
13:49:28 <merijn> EvilMachine: So, imagine generating assembly where you never pop to return from a function
13:49:32 * ski doesn't really do any winter sports
13:49:40 <pillow> merijn: http://lpaste.net/6523352996686856192
13:49:40 <ski> (or summer sports, for that matter)
13:49:43 <dolio> Do you combinate?
13:49:44 <merijn> EvilMachine: CPS is basically: "instead of popping a stack frame, jmp to the next function"
13:49:51 <prohobo> i was alluding to the game ski
13:49:59 * ski knows
13:49:59 <prohobo> and that you were leaving
13:50:04 <ski> @where haskel
13:50:04 <lambdabot> <http://web.archive.org/web/20070703001910/http://www.cs.chalmers.se/~augustss/pics/haskel.gif>
13:50:08 <prohobo> i was giving you a sendoff in referential style
13:51:05 <prohobo> haskell > clojure
13:52:08 <pillow> merijn: http://lpaste.net/6015288035204136960
13:52:17 <EvilMachine> ski: You’re actually doing a good job. I knew this a bit and it starts to come back now. I even remembered how the websites looked that I read it on.
13:53:00 <merijn> pillow: Use an IntMap instead of an array?
13:53:02 <EvilMachine> ski: It is hard to go too quickly for me though. I’m usually annoyed by verbosity and get bored. So your speed was fine. :)
13:53:24 <EvilMachine> ski: thank you. I have to leave soon too.
13:53:34 <ski> yw
13:54:08 <pillow> merijn: I dont get it, i need to go the recursive way if i dont want to have to compute the full range, if i use "solve" i need to compute the full range, only "solve2" can decide which sparse item i care about
13:55:14 <pillow> merijn: do you see how to memoize "solve2" in this paste ? 
13:55:47 <EvilMachine> merijn: I know what CPS is. The concept is elegant and nice. I just had big trouble thinking that way in practice. Because of all the passing around things that you then call through, making it hard to keep track of which direction some parameter goes / will go / had gone / wibbly-wobbly timey-wimey… I found the Tardis monad back then. :))
13:56:40 <rhovland> pillow: I usually do something like http://lpaste.net/164607 as a first stab at it
13:57:08 <EvilMachine> If a prohobo is a professional hobo, what is a prohibited?
13:57:44 <kqv> Hi, I'm trying to :load a module in ghci, but it is giving me an error 'module is package module'
13:57:44 <prohobo> a professional frog-like creature of the past
13:58:12 <EvilMachine> (A property is something that “iz a professionally perty kitteh”)
13:58:18 * EvilMachine goes back on topic.
14:00:01 <c_wraith> pillow, if you're looking for super-clever solutions involving laziness, take a look at  https://hackage.haskell.org/package/data-inttrie 
14:00:46 <buglebudabey> would anyone be willing to provide some guidance regarding writing a compiler in haskell?
14:00:59 <c_wraith> I really like lazy infinite tries for memoization 
14:01:13 <pillow> c_wraith: i'd be cool with a dumb working solution, but i keep that somwhere for my future enlightement, thanks
14:02:13 <kqv> is it possible to have ghc derive show for some type in ghci?
14:02:15 <EvilMachine> buglebudabey: Reading GHC source would maybe help. :)
14:02:40 <kqv> or print the value of a type that doesnt implement Show?
14:02:49 <c_wraith> kqv, hmm. Maybe ghci can do StandaloneDeriving now
14:03:25 <pillow> rhovland: I am confused about the isJust and otherwise thing, also where does "memo3" come from ? what the call to solve be in this case ?
14:04:27 <reptar_> i have a list of strings like ["hi", "hi", "hi"], what's the best way to print out "hi", "hi hi", "hi hi hi"?
14:04:35 <rhovland> pillow: you call with "solve (M.empty,123784612) " , for example... it'll return (map, final answer). Oh, import qualified Data.Map as M somewhere, forgot about that
14:05:29 <pillow> rhovland: so the map is not shared betwene the 3 recursive call ?
14:05:35 <kqv> c_wraith: how would I do that?
14:05:38 <koala_man> reptar_: how would that look for ["foo", "bar", "baz"] ?
14:05:46 <rhovland> pillow: so it looks for n in the memo, if it finds it ("isJust") then it returns the value (and the unchanged memo). if it doesn't find it, it passes the memo down to a n/4, n/3, n/2 call... that's how it goes from memo0->memo1->memo2->memo3
14:06:20 <c_wraith> kqv, first enable it, something like :set -XStandaloneDeriving
14:06:23 <reptar_> koala_man, "foo", "foo bar", "foo bar baz"
14:06:25 <Hijiri> pillow: map the memoized version over the array
14:06:27 <Hijiri> oh
14:06:30 <Hijiri> I was scrolled up
14:06:32 <Hijiri> sorry
14:06:55 <c_wraith> kqv, then use something like "deriving instance Show Foo" 
14:07:02 <pillow> rhovland: awww i got it you return the memo from the result so you pass the cache along, that's clever :D
14:07:38 <koala_man> > map unwords . tails . reverse $ ["foo", "bar", "baz"]
14:07:40 <lambdabot>  ["baz bar foo","bar foo","foo",""]
14:07:59 <koala_man> bah.
14:08:03 <reptar_> koala_man, i want each of em on newline, not in new list
14:08:17 <reptar_> foo
14:08:20 <reptar_> foo bar
14:10:05 <koala_man> > mapM_ (putStrLn . unwords) $ inits ["foo", "bar", "baz"]
14:10:07 <lambdabot>  <IO ()>
14:10:36 <koala_man> thanks lambdabot
14:10:53 <kqv> c_wraith: thanks, that seems to work, is there a way to recursively derive an instance for all types used by a type?
14:11:13 <koala_man> reptar_: in any case, with Data.List imported it would print out that (plus a blank line for the case of the first 0 elements)
14:11:23 <kqv> its complaining that other types in the value do not have Show instances
14:12:11 <c_wraith> kqv, nothung available to do that recursively. instances really should be derived for each type in a source file. *shrug*
14:12:33 <reptar_> koala_man, thank you!
14:12:42 <kqv> c_wraith: is there a way to inspect a balue that doesn't have a Show instance?
14:13:14 <c_wraith> kqv, not without having some other instance or type-specific function 
14:13:38 <kqv> :s
14:13:55 <kqv> would be really useful for going through code that isn't yours
14:14:31 <prohobo> kqv: please dont remind me that someday someone will read my code, thanks
14:14:39 <prohobo> ill need to add apology comments
14:14:45 <kqv> lol
14:15:37 <prohobo> dude no
14:15:58 <prohobo> I USED JQUERY FOR HALF OF A 2 YEAR PROJECT
14:33:33 <pillow> thank you for your help :) I'm off to bed
14:33:39 <pillow> help*
14:34:02 * hackagebot skulk 0.1.2.0 - Eclectic collection of utility functions  https://hackage.haskell.org/package/skulk-0.1.2.0 (geekyfox)
14:44:02 * hackagebot Encode 1.3.8 - Encoding character data  https://hackage.haskell.org/package/Encode-1.3.8 (OtakarSmrz)
14:57:16 <MarioNeri> ciao
14:57:22 <MarioNeri> !list
14:58:14 <simpson> Buongiorno.
14:58:32 * simpson parla un poco
15:01:10 <simpson> Prego.
15:04:03 * hackagebot stratux-types 0.0.1 - A library for stratux  https://hackage.haskell.org/package/stratux-types-0.0.1 (TonyMorris)
15:04:05 * hackagebot stratux 0.0.2 - A library for stratux  https://hackage.haskell.org/package/stratux-0.0.2 (TonyMorris)
15:04:07 * hackagebot pretty-show 1.6.10 - Tools for working with derived `Show` instances and generic  inspection of values.  https://hackage.haskell.org/package/pretty-show-1.6.10 (IavorDiatchki)
15:19:03 * hackagebot wai-session-postgresql 0.2.1.0 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.2.1.0 (hc)
15:29:04 * hackagebot prompt 0.1.1.2 - Monad (and transformer) for deferred-effect pure  prompt-response queries  https://hackage.haskell.org/package/prompt-0.1.1.2 (jle)
15:34:19 <Tekkkz> geekosaur: still here?
15:37:32 <shanemikel> EvanR: what was the name of that typed lisp you mentioned?
15:37:53 <EvanR> i dont recall mentioning one... oh, shen
15:38:09 <EvanR> its more like a type system programming language
15:38:19 <merijn> shanemikel: Probably Racket
15:38:41 <shanemikel> type system programming?
15:38:43 <EvanR> typed racket is probably the more serious of the two
15:38:45 <merijn> Whether Racket is a lisp depends on whether you consider scheme a lisp or not :p
15:38:59 <hpc> why would scheme not be a lisp?
15:39:13 <shanemikel> so, do either of them allow for annotation?
15:39:25 <EvanR> shanemikel: yes, it uses sequent calculus to allow you to make rules about what type(s) a given expression is
15:39:25 <merijn> hpc: Try saying scheme is lisp in a channel with Common Lisp fans :p
15:40:09 <EvanR> you begin with untyped lisp expressions, which are just trees of symbols, and they can gain new types through rules
15:40:19 <ski> merijn : try referring to Common Lisp as just "Lisp" in #scheme or <news:comp.lang.scheme>
15:40:20 <EvanR> Blue can be a symbol or a color
15:41:18 <EvanR> shanemikel: functions are annotated, which is required if type checking is on
15:41:53 <hpc> merijn: i mean, by what mechanism would they say scheme doesn't qualify?
15:42:09 <hpc> or would they just say clisp = only lisp?
15:42:29 <hpc> (this is probably -offtopic territory)
15:42:31 <merijn> hpc: I forgot, but I've been yelled at before :p
15:42:41 <ski> (also note that CLisp is a particular implementation of Common Lisp)
15:43:11 <shanemikel> I would basically like to see what it would take to build a nice lisp language interpreter in haskell, and try to hack together a plugin architecture library with it.. to do for haskell what guile does for c, basically
15:43:24 <shanemikel> (Not on the same scale obviously, but as an experiment really)
15:44:28 <EvanR> you got your lisp in my haskell!
15:44:35 <shanemikel> And it occurred to me that It would seriously limit the number of uses for me if it wasn't statically checked
15:44:37 <hpc> you got your haskell in my lisp!
15:45:07 <EvanR> data S a = A a | S [S a] deriving Scheme
15:45:16 <EvanR> done
15:45:43 <shanemikel> lol, beyond parsing
15:45:48 <monochrom> newtype D = MkD (D -> D) deriving UntypedLambdaCalculus
15:45:52 <EvanR> shanemikel: static typing for lisp sounds like a recipe for limiting the number of approved lisp programs drastically
15:45:59 <Tekkkz> »fatal error: ffi.h: No such file or directory« you know this error? any idea how to solve?
15:46:28 <shanemikel> yeah, that occurred to me as well.  that's why I'm really curious what people have done 
15:46:45 <ski> hm, the Liskell link, <http://clemens.endorphin.org/liskell> appears broken ..
15:46:58 <shanemikel> and if there's anything usable out there
15:47:01 <EvanR> untyped programming is an art form, relying heavily on good debuggers and repls
15:47:07 <EvanR> and culture
15:47:29 <EvanR> and brainpower
15:48:26 <shanemikel> yeah..  I don't know what it would mean for macros and quoting, it'd probably be quite an endeavor
15:49:46 <shanemikel> are there any typed (maybe not so functional) languages that might be well suited?
15:50:09 <shanemikel> small is good
15:50:10 <ski> shanemikel : MetaML/MetaOCaml might be interesting, for the quoting
15:52:33 <shanemikel> Doing this with a dynamic language might be useful, but then I have to build an interactive environment and editor plugins...
15:52:44 <Ankhers> Has anyone created mobile, specifically Android and iOS apps, using Haskell as a library? Specifically I want to have something along the lines of a native UI, language bridge, Haskell library used for core logic.
15:54:10 <EvanR> shanemikel: building a language in a dynamic language is... torture
15:54:12 <shanemikel> the ffi is pretty okay.  it is supposedly easy to expose haskell funcitions with a c api
15:54:55 <merijn> Ankhers: People have done it, it'll be a bunch of work, but shouldn't be a problem
15:55:24 <shanemikel> Ankhers: that is, it's bidirectional, so you can consume c functions from haskell, and expose haskell functions to c
15:55:28 <merijn> Ankhers: People have run Haskell natively on iOS and language bindings is fairly easy, both Objective C and Haskell have a C FFI
15:55:36 <Ankhers> merijn: Any chance you know of any blog posts or anything else where people explained their process a little?
15:55:49 <merijn> Ankhers: Not of the top of my head
15:56:05 <shanemikel> the haskell to c route is actually pretty clean, becuase you can make every exposed piece of your API pure, and then you don't have to worry about state and GC, etc
15:56:11 <merijn> shanemikel: The only thing that's messy about the FFI is if you want to manipulate C structs from within haskell, because then you have to write Storable instances
15:56:24 <merijn> shanemikel: If you only have pointers and primitive data (int, char, etc.) it's all super easy
15:57:07 <Ankhers> merijn, shanemikel: Any chance you know of some way to automatically create the c bindings for a Haskell project? Or would that all be written by hand?
15:57:10 <merijn> Ankhers: Might wanna ask the haskell-cafe mailing list, better chance of finding the right people
15:57:29 <Ankhers> merijn: Thanks. I shall do that.
15:57:43 <merijn> Ankhers: I assume you're somewhat familiar with C, compilation, object files, and linking?
15:58:07 <Ankhers> merijn: Not extensively, but I have done some work with it.
15:58:30 <shanemikel> EvanR: I'm not trying to build a language in the plugin language, I just want a simple plugin language to use, for example, to configure haskell applications (e.g. a connect-like webserver where the routes are built in the guest language)
15:58:34 <Ankhers> Sorry, yes. I am somewhat familiar.
15:58:59 <merijn> Ankhers: Basically, GHC already knows how to import/export C ABI functions, I would recommend reading the FFI chapter (I think it's chapter 8?) of the Haskell Report, it explains exactly what GHC can do for you
15:59:45 <Ankhers> merijn: Thanks, I'll take a look at that.
15:59:46 <merijn> Ankhers: Here's a simple example of importing C functions from haskell: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L270-L297
16:01:34 <EvanR> shanemikel: theres also the quasi quoter for stuff like that, which probably already exists for web routes
16:02:03 <EvanR> you provide the parser and the interpretation in haskell
16:02:58 <shanemikel> yeah, but I'm looking for something where the "plugins" don't need to be statically compiled, and they are comfy to use by people who are scared of haskell and shouldn't even be aware that it's used
16:03:28 <shanemikel> (also, ghc shouldn't be available on machines where it's being used)
16:03:51 <EvanR> obviously the answer is to make an open source reimplementation of mIRC script
16:04:04 <EvanR> its so easy a child could use it
16:04:12 <EvanR> but so is C++
16:04:24 <shanemikel> merijn: do you know if c2hs or hsc2hs are good for exposing haskell libraries to c, or just wrapping c libraries in hs?
16:04:31 <EvanR> which is why angelscript exists
16:04:58 <merijn> shanemikel: So c2hs and hsc2hs exist to deal with what I mentioned earlier, exposing structs to haskell
16:05:14 <merijn> shanemikel: If you don't need to update structs you don't need either of them at all, imo
16:05:35 <shanemikel> the other reason I am interested in lisps, is there is a lot of freedom in evaluation rules, so I can make declarative edsls in lisp and nobody complains about expecting certain evaluation order
16:06:15 <EvanR> is this a pure language?
16:06:49 <EvanR> if so use lazy evaluation and no one will complain, if not if you dont use eager evaluate everyone will complain
16:07:44 <shanemikel> Yeah, that has occurred to me, too.  I mean evaluation in the sense that macros don't evaluate their arguments, so I'm free to use call-by-name vs call-by-value whenever I want
16:08:37 * ski wants by-value macros
16:08:41 <EvanR> that aspect of macros is superceded by regular lazy functions 
16:09:00 <ski> (iow, macro forms in the argument(s) are expanded before the outer macro form expands)
16:09:10 <EvanR> so lazy lisp might be equivalent to haskell without a type system and no template haskell
16:09:38 <shanemikel> are there any lazy lisps?
16:09:40 <EvanR> i guess this explains my confusion about lisp macros and whats the diff between a macro and a function
16:10:16 <ski> (macros in lisp are by-value. at least any of the system's i've heard about)
16:10:32 <ski> (er .. sorry. by-name, that is)
16:10:44 * ski should go sleep
16:10:53 <shanemikel> yeah.. that's why (setq x 10) works and you don't need to do (setq 'x 10)
16:10:55 * EvanR needs to review what by value and by name really mean again
16:11:42 <shanemikel> in a regular function, x would be evaluated before the result is passed to the function, but in the setq macro, x is passed as a symbol
16:11:57 <shanemikel> that's all really, nothing mysterious at all
16:12:15 <koz_> Yep: Lisp macros are just Turing-complete AST manipulations.
16:13:00 <shanemikel> how? I see quotes as ast manipulations, not so much macros
16:13:22 <koz_> shanemikel: Lisp macros can execute arbitrary code as part of the transformations they perform.
16:13:26 <shanemikel> err, anti-quots
16:13:54 <shanemikel> sure, but you get the same thing with passing a quoted expression
16:14:21 <koz_> shanemikel: Many macros have 'expanders' given to them to construct their results.
16:14:25 <ski> a macro call is like an unquotation of a call, with arguments quoted
16:14:27 <koz_> Those expanders are just normal list-manipulators.
16:14:59 <geekosaur> isn't that kinda the point? you get what amounts to the AST of the parameter(s), and produce what amounts to the AST of the result, instead of getting an evaluated parameter and producing an evaluated result
16:15:17 <ski>   (frob (and (foo) (bar)))
16:15:19 <ski> becomes
16:15:20 <geekosaur> also quotation has itself been implemented historically as a type of macro
16:15:24 <koz_> Yeah, which is exactly what I meant when I said that Lisp macros are Turing-complete AST manipulators.
16:15:28 <ski>   (frob ,(and-macro `(foo) `(bar)))
16:16:07 <shanemikel> koz_: oh, yeah.. (quote ...)
16:16:08 <koz_> (as an aside, Sets not being functors is annoying as fuck)
16:16:09 <geekosaur> and the AST of the parameter is also what you get from quoting
16:16:11 <shanemikel> nvm
16:17:03 <shanemikel> so, nobody knows of a lazy lisp?
16:17:15 <koz_> shanemikel: There are Lisps with support for laziness (Clojure for example).
16:17:26 <koz_> But not in the same way as Haskell (i.e. by default).
16:17:35 <shanemikel> also, is there a small lisp specification that doesn't have destructive update?
16:17:38 <ski> shanemikel : perhaps ask in #scheme,#lisp,#emacs,#racket, ...
16:17:42 <shanemikel> pure
16:17:52 <koz_> shanemikel: The purest Lisp we have is Clojure.
16:18:08 <koz_> Where it basically hides destructive updates in STM-type containers.
16:18:20 <koz_> (they still have non-monadic IO though)
16:24:46 <shanemikel> It looks like Lispkit might be the one
16:26:45 <EvanR> Bimp Lispkit?
16:26:50 <shanemikel> meanwhile I'm gonna look at husk
16:27:07 <shanemikel> yeah, that's the one.  they were sued by a crappy alternative band once, too
16:39:06 * hackagebot sbp 1.0.0 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-1.0.0 (markfine)
16:43:39 <siwica> Have there been any changes on command syntax when compiling with ghc? I am currently reading a book that states you have to invoke ghc with all the objects files the linker needs to know about like "ghc -o programname Main.hs submodule.o" whereas I found invoking "ghc -o programname Main.hs" is enough and the described way in the book even gives me error messages.
16:45:55 <koz_> Maybe you nice folks can help me. I need a data structure that is a) sorted, b) non-empty, c) contains only unique elements and d) is well-supported by the lens library. Could anyone suggest anything fitting?
16:46:52 <monochrom> I think Data.Set is only short of (b)
16:47:13 <koz_> monochrom: Yeah, hence why I asked here.
16:47:26 <koz_> I tried to make use of Data.NonEmpty.Set, but that's *severely* deficient.
16:47:43 <koz_> And this is *really* doing my head in.
16:48:01 <monochrom> I would take a compromise and drop (b). It's late Thursday already.
16:48:16 <koz_> monochrom: I guess ... hope this doesn't bite me later.
16:51:15 <michaelt> siwica: yes, that's out of date ; just ` ghc XYZ.hs `  will produce an executable XYZ; use an optimization flag like -O2 
16:52:04 <siwica> michaelt: ok, thank you!
16:52:19 <siwica> Why is optimization not done by default?
16:53:39 <michaelt> siwica: it takes longer.  
16:53:53 <siwica> michaelt: ok, sure enough
16:55:41 <EvanR> koz_: you can use a newtype wrapper smart ctor to ensure the non empty ness
16:56:04 <EvanR> you can also attempt to use phantom types in some way to guarantee theres always an element
16:56:35 <EvanR> like the type of "grabFromUrn" requires at least 2 elements
16:59:07 * hackagebot language-thrift 0.9.0.1 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.9.0.1 (abhinav)
17:02:32 <monochrom> you could ask the same question of gcc. why doesn't it default to -O2 already? I don't know the answer.
17:05:02 <siwica> "Turning on optimization flags makes the compiler attempt to improve the performance and/or code size at the expense of compilation time and possibly the ability to debug the program." (https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)
17:05:25 <siwica> Didn't think of the fact that debugging is an issue then also
17:06:07 <siwica> But sure. You have so make some sort of compromise.
17:06:40 <monochrom> I guess the answer is probably mere inertia. At the beginning, ghc -O and gcc -O2 took forever for not much benefit, so the defaults were -O0. By induction, every year people do not feel like changing it, for fear of hypothetical outcry about hypothetical surprises.
17:07:07 <maerwald> and then programs started to break with -O0, because -O2 makes some memory bugs disappear :P
17:07:38 <siwica> :)
17:08:07 <monochrom> I myself believe in early detection of problems that will happen after deployment.
17:08:27 <monochrom> If you will use -O2 for deployment, you'd better start with -O2 since day one.
17:08:47 <monochrom> otherwise it will be too late to know that -O2 gives you a new problem.
17:08:55 <siwica> hm, this might be true.
17:09:05 <maerwald> I believe in testing the code with all optimization levels and major compilers
17:09:12 <siwica> Is there an 03 with ghc also?
17:09:20 <monochrom> no, ghc's max is 2
17:09:27 <siwica> ok!
17:10:22 <siwica> Apparently -03 includes optimizations that require a speed/size tradeup in gcc
17:10:33 <monochrom> yeah
17:33:15 <rcat> how can I specify in the type signature a vector of any arbitrary size from Linear.V ("linear" in hackage)
17:33:38 <rcat> or it's just that it breaks with the idea of having a type defined sizes :/
17:34:26 <johnw> you can accept a parameter of arbitrary size by making the size a type variable
17:35:07 <johnw> or you can return a value with some particular size (even if unknown) by making the size extensional
17:35:16 <rcat> I have this signature: showPrettyMatrix :: (Show a) => LV.V n (LV.V m a) -> String
17:35:26 <rcat> but passing a V 120 (V 120 (Score, Score))
17:35:57 <rcat> breaks with
17:36:00 <rcat>     Couldn't match kind ‘*’ with ‘GHC.TypeLits.Nat’
17:36:05 <rcat>     Expected type: Linear.V.V n10 (Linear.V.V n0 (Score, Score))
17:36:09 <rcat>       Actual type: Linear.V.V 120 (Linear.V.V 120 (Score, Score))
17:36:15 <rcat> sorry for too much pasting...
17:36:26 <rcat> johnw: ^
17:36:29 <johnw> hmm... i would have expected it to infer the right kind for n and m
17:36:34 <johnw> can you paste the code?
17:39:45 <lpaste> rcat pasted “No title” at http://lpaste.net/164613
17:40:21 <rcat> johnw: sorry, it's a bit of a mess, it took it out of a medium size project, I hope it's clear the idea
17:42:57 <johnw> this code has lots of name ambiguities when I try to evaluate it here
17:43:56 <johnw> can you get your snippet to at least mostly compile there?
17:44:09 * hackagebot flow 1.0.7 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.7 (fozworth)
17:44:21 <johnw> oh, never mind
17:44:26 <johnw> I was able to get to just the one problem
17:44:46 <maerwald> "Write more understandable Haskell by adding even more operators people don't know" :P
17:45:40 <guest794> I have not yet completely understood the famous Stackoverflow post about why seq is bad ("polymorphic seq weakens free theorems"), but I was wondering if the bang patterns for either datatypes or function arguments, which are special use cases of seq, are safe? 
17:47:02 <lpaste> rcat revised “No title”: “Issue with arbitrary size Linear.V” at http://lpaste.net/164613
17:47:14 <dolio> guest794: No.
17:47:15 <rcat> johnw: a minimal case with the same error
17:47:37 <hpc> seq !a b = b?
17:47:41 <johnw> ok, great
17:47:59 <guest794> dolio: they break free theorems too?
17:48:09 <dolio> You can write seq with either of them.
17:48:14 <hpc> data Seq a b = Seq !a b
17:48:15 <guest794> hpc: I meant that if we do not use seq at all but use only bang patterns
17:48:18 <mgsloan> guest794: I haven't seen the post, but maybe the reason is that "seq" allows you to evaluate a bottom argument.  If you didn't have seq, then for a type "a" where you have no constraints on it, you wouldn't be able to cause the exception to be thrown
17:48:33 <hpc> seq a b = let (Seq a' b') = Seq a b in b'
17:48:34 <johnw> rcat: https://gist.github.com/jwiegley/61ed12c9404c9cf150421746ace6d3d7
17:48:37 <johnw> rcat: that evaluates fine
17:48:42 <mgsloan> (or the non-termination)
17:48:48 <hpc> guest794: i just defined seq using both types of bang patterns
17:49:03 <michaelt> rcat: add PolyKinds 
17:49:05 <guest794> hpc: I see, right!
17:49:15 <hpc> guest794: seq is unsafe, you can derive seq from bang patterns, ergo bang patterns unsafe
17:49:17 <guest794> dolio: thanks
17:49:29 <johnw> heh, PolyKinds does indeed solve the problem, thanks michaelt
17:49:31 <hpc> you'll find that sort of technique a lot in proofs of code stuff
17:49:45 <hpc> programming lends itself very well to constructive proofs
17:50:01 <hpc> and you'll maybe learn why that is later down the line
17:50:13 <rcat> johnw: oh!, awesome, thanks John, much appreciated ;)
17:50:24 <guest794> And what if I used the new Strict pragma of GHC 8.0?
17:50:25 <johnw> and michaelt, for reminding me of that extension
17:50:32 <guest794> and do not use any lazy annotations?
17:50:47 <rcat> michaelt: thanks ;)
17:50:48 <guest794> in that case I cannot define seq because both arguments would be strict
17:50:50 <hpc> guest794: haven't used it yet, but if i had to guess it does as well
17:51:06 <dolio> seq is strict in both arguments.
17:51:09 <hpc> you can, seq is already strict in both arguments
17:51:33 <guest794> But then why does this problem not occur in strict languages where everything is strict?
17:51:35 <hpc> seq a b = b (modulo strictness of a)
17:51:42 <hpc> so to evaluate seq a b you must evaluate b
17:51:49 <guest794> right
17:51:54 <hpc> or less operationally, seq a bottom = bottom
17:52:54 <guest794> hpc: why is this not a problem in strict languages? I have only heard of this in the context of Haskell?
17:54:09 * hackagebot network-simple 0.4.0.5 - Simple network sockets usage patterns.  https://hackage.haskell.org/package/network-simple-0.4.0.5 (RenzoCarbonara)
17:54:22 * hpc tries to formulate an answer
17:54:36 <geekosaur> because in strict languages you avoid such things anyway as infinite loops
17:55:02 <geekosaur> but in non-strict languages, some things that are bottom in strict contexts are quite useful in non-strict contexts
17:55:18 <geekosaur> (or as crashes instead of infinite loops)
17:55:23 <codebje> or you go the other way and don't have an explicit bottom
17:55:48 <maerwald> geekosaur: why would you avoid infinite loops?
17:55:57 <guest794> geekosaur: by infinite loops do you mean infinite data structures?
17:55:58 <hpc> i expect it is a problem in strict languages, though the idea of bottom is different
17:56:14 <hpc> you can't be quite so casual about manipulating values that would crash or loop your program
17:56:27 <hpc> and by and large, most strict languages wouldn't care about free theorems anyway
17:56:29 <codebje> maerwald, for one, you might want to prove your program correct
17:56:40 <hpc> they don't even have parametricity
17:56:40 <geekosaur> I am thinking of things like [1..] which can be seen as an infinite data structure or as an implicit infinite loop (a generator, as it's called in some languages)
17:56:45 <maerwald> codebje: so my html server does not run an infinite loop?
17:56:51 <maerwald> or my gtk gui
17:56:53 <maerwald> or...
17:57:20 <hpc> (parametricity being basically the absence of type-case, like java's instanceof keyword)
17:57:29 <geekosaur> maerwald, and indeed infinite loops *can* be a problem in those contexts. consider slowloris wrt the html server :p
17:58:02 <maerwald> I still don't see why you would avoid them. You need them for lots of things.
17:58:19 <codebje> maerwald, you can model such things as a finite structure
17:58:29 <geekosaur> I am trying to figure out if you are deliberately reading out of context or not
17:58:33 <hpc> or you can model them as productively infinite structures
17:58:40 <hpc> which are distinct from bottom
17:58:54 <codebje> corecursion
17:59:09 <codebje> _constructive_ "infinite" loops aren't infinite, because you must construct them
17:59:40 <hpc> you'd have to do a smidgeon of hand-waving in such a language to say that waiting for network input always happens
17:59:49 <hpc> which you can probably cover up by making it a wait with timeout
18:00:11 <guest794> In that case, am i right in assuming that in the absence of any infinite data structures (no infinite lists etc), seq is safe? Does it become unsafe only in the presence of these?
18:00:19 <hpc> from there, a wait for input always yields something definite eventually, and you can perform that operation in perpetuity
18:00:23 <guest794> I mean in terms of the free theorems not breaking
18:00:38 <hpc> guest794: it's the combination of seq and bottom
18:00:57 <hpc> > fix id -- bottom
18:01:01 <lambdabot>  mueval-core: Time limit exceeded
18:01:02 <hpc> > fix (1:) -- not bottom
18:01:03 <dolio> What does it say breaks?
18:01:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:01:23 <hpc> > error "this is also bottom, by crashing instead of looping"
18:01:25 <Hijiri> Maybe someone said this already, but seq violates the notion that \x -> bottom is the same as bottom
18:01:25 <lambdabot>  *Exception: this is also bottom, by crashing instead of looping
18:01:48 <hpc> http://stackoverflow.com/questions/12687392/why-is-seq-bad -- this is the SO post that likely prompted this question
18:02:04 <hpc> which constructs a breakage of the free theorem for map@[]
18:02:21 <Hijiri> because bottom `seq` blah = bottom but (\x -> bottom) `seq` blah = blah
18:02:29 <hpc> (unrelatedly, <3 that new ghc8 notation for instantiating foralls)
18:02:51 <Hijiri> (this is when bottom, (\x -> bottom) :: a -> b
18:03:01 <hpc> er, that was fmap@[], which is Prelude.map
18:03:05 <guest794> hpc: and practically, bottom occurs when one is using an infinite data structure, throwing an error or exception?
18:03:55 <hpc> infinite structures are fine
18:04:09 <Koterpillar> this might be a dumb question, but what would seq even do in a strict language?
18:04:13 <hpc> exceptions are fine-ish, in the sense of "things you can catch in IO"
18:04:21 <hpc> Koterpillar: it'd be flip const
18:04:31 <Koterpillar> then it can't be bad?
18:04:45 <Koterpillar> because it doesn't exist?
18:05:45 <hpc> for the particular example on that SO link, you wouldn't be able to construct f _ = [undefined]
18:06:02 <hpc> and applying bottom to the second f wouldn't be [undefined], it'd just be undefined
18:06:15 <hpc> [undefined] relying on the laziness of (:) remember
18:06:18 <dolio> So, the reason those examples don't break in strict languages is because they blow up much more eagerly.
18:06:35 <dolio> However, you might still be able to construct analogous examples.
18:06:44 <hpc> or in other words, free theorems have failed long before you reach seq's influence
18:06:57 <dolio> Because () -> a has bottom elements that a doesn't.
18:08:09 <hpc> guest794: anyway getting back to that question, exceptions in the "throw things in IO" sense are fine, because they produce defined results when evaluated
18:08:35 <hpc> guest794: possibly not so much when executed, but that's why IO is considered pure
18:09:18 <hpc> :t error -- errors as in this are a sort of bottom that makes the runtime print something before going kablooey
18:09:20 <lambdabot> [Char] -> a
18:09:32 <dolio> For instance, g _ = True, f _ = [\() -> undefined]. map g (f xs) = [True], f (map g xs) = [\() -> undefined].
18:09:35 <hpc> > [1..] -- infinite data structures aren't bottom if they come from productive computations
18:09:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:10:00 <hpc> > let x = x + x in x -- but this isn't a productive computation, so it's bottom
18:10:04 <lambdabot>  mueval-core: Time limit exceeded
18:10:33 <dolio> You can construct the other example, too.
18:10:56 * hpc is quite mathed out for tonight though
18:11:01 <dolio> seq x y = \() -> let _ = x () in y ()
18:11:07 <guest794> hpc: Thanks. I understand now
18:11:28 <hpc> dolio: the lazy monad!
18:11:48 <hpc> (in a language like idris anyway)
18:12:09 <hpc> (also it's a comonad too and some other stuff probably)
18:12:13 <dolio> It's actually not lazy. It will do things multiple times, so it's worse.
18:12:18 <guest794> So is it possible to follow some practices so that one does not encounter such a problem with seq? Say by never defining partial functions which will throw an error, but rather using Maybe etc?
18:12:56 <hpc> dolio: afaik that's fine as long as it isn't impure as well though
18:13:19 <hpc> guest794: correct
18:13:43 <hpc> guest794: if you restrict yourself to a total subset of haskell (total meaning no bottoms), you will be fine
18:14:01 <hpc> in total languages there is in fact no semantic difference between strict and non-strict semantics
18:14:18 <dolio> I mean, it's fine if being slow is fine. :)
18:14:21 <hpc> because strictness/non-strictness are defined in terms of the relationship between evaluation and bottom
18:15:03 <hpc> so idris and agda which are both total languages use strict evaluation
18:15:10 <hpc> for operational convenience
18:15:49 <hpc> er, one of those semanticses needs to be a "denotational"
18:16:04 <hpc> too many big words, gonna go to sleep for real now ;)
18:16:19 <guest794> hpc: Thanks, and what if I restricted myself to a "strict Haskell" that is used only a strict data structure, and all the function arguments are strict? For instance, in the SO post, if I understand it correctly, the examples there would be fine if everything (including the list) was strict because then both sides of the equality would be bottoms. Am I right?
18:16:59 <guest794> hpc: Oh sorry, no problem, I will ask some other time. Thanks!
18:17:01 <dolio> You can construct different examples with the same problems.
18:17:04 <dolio> I did above.
18:18:13 <guest794> dolio: different examples even if all data structures and arguments are strict?
18:18:21 <dolio> Yes.
18:18:44 <guest794> dolio: and that is because of the fact that bottom belongs to every type?
18:18:46 <dolio> To get non-strict A, you just need () -> A.
18:19:21 <dolio> The only way to avoid the problem is to be total.
18:19:34 <guest794> dolio: I see...right
18:19:56 <guest794> dolio: so it is really the fact that bottom is a value in every type that is creating the problem?
18:20:30 <dolio> Yes. Although that's kind of complicated in a strict language.
18:21:19 <guest794> dolio: I see...thanks...and by the way...the fact that strict is not really a monad...is that problem avoidable by being total too?
18:21:27 <guest794> I meant strict state
18:22:54 <guest794> because it seems all the counterexamples to strict State being a monad, again use undefined.
18:23:08 <dolio> Yeah, I guess. There's no such thing as strict vs non-strict state when you're total.
18:24:39 <guest794> dolio: I suppose you mean semantically, because I guess it would make a difference in performance, specifically, constant vs growing heap.
18:25:36 <guest794> dolio: but I guess you meant that the values outputted would not differ between the two implementations.
18:25:51 <dolio> Well, the definition of strictness doesn't make any sense when you're total. So it'd be a question of how things would happen operationally.
18:26:44 <dolio> But operationally they could be the same as well, you never know.
18:27:03 <dolio> Because the compiler evaluating things differently wouldn't change the answer.
18:27:20 <guest794> dolio: right, only the performance may differ.
18:27:57 <guest794> dolio: thanks a lot for answering my questions!
18:28:07 <athan> Would it be possible to use Hackage as a 3rd party authentication server, so I could make a derivative app from it, allowing authors to add more data than what hackage noramally has?
18:28:21 <athan> I'm making a trivial app-store like thing for hackage, basically
18:28:30 <athan> This way would be extremely convenient
18:42:52 <hpc> athan: so basically you'd run your own modified hackage that uses the real hackage's credentials
18:43:17 <hpc> if nothing else you can perform the login as a user would
18:43:38 <hpc> or generate a "login with hackage" button or something that forwards the user
18:43:54 <hpc> probably ask in #hackage
18:44:22 <merijn> @remember DerekElkins Constructivist Motto: I don't believe classical logic is false; I just believe that it is not true.
18:44:22 <lambdabot> It is forever etched in my memory.
18:46:19 <kqv> Anyone know of a way to inspect a value of a type that isn't an instance of Show in ghci?
18:46:38 <hpc> pattern matching if you can
18:46:51 <hpc> or in terms of whatever operations on it you have in scope
18:47:24 <hpc> like if you have a network connection, you can't really show that but you can ask if it has input waiting and what it's connected to
18:47:56 <merijn> I thought there was some debug printing command too
18:48:01 <merijn> But don't ask me what it is :)
18:48:28 <kqv> I'm trying to go through some code that isn't mine, with types I don't know, and they are fairly complicated so it would be a lot easier if I can look at the values and types instead of searching for everything in the code
18:49:09 <merijn> kqv: hdevtools had a "show definition" command last time I checked
18:49:12 <hpc> kqv: time to get good with :t and :info
18:50:15 <AdituV> could you use a deriving instance in interpreter?
18:50:17 <kqv> ghci has a 'standalone deriving' feature which can derive instances such as Show for a simple type, I wonder if this can be somehow used to derive an instance for a complex type
18:50:45 <kqv> AdituV: yeah, but that only works for types that don't use other types which don't have that instance
18:51:03 <AdituV> kqv: oh yeah, right.  So you'd have to derive each one from the bottom up
18:51:43 <kqv> there should be a recursive 'standalone deriving' feature, would be great
18:52:46 <simpson> Well, the instances of Show aren't really the problem so much as the instances of Read, which have to have a symmetry.
18:55:05 <kqv> simpson: what do you mean they have to have symmetry?
18:55:08 <merijn> simpson: Show is also supposed to result in valid haskell
18:55:26 <merijn> kqv: "read . show" should be the same as id
18:55:37 <athan> Thanks hpc, I'll give them a shot
18:55:43 <kqv> oh I see
18:55:51 <athan> basically yeah, just with alternative user-supplied categorization of the packages
18:56:04 <simpson> merijn: Ah. That's even more annoyingly burdensome.
18:56:09 <athan> for better searching and discovering new ones
18:56:11 <athan> also ratings :x
18:56:16 <simpson> I'm used to environments where everything prints, even if it prints uselessly.
18:56:19 <SirF> Can someone help me understand this error? Couldn't match type ‘[]’ with ‘(,) k0’     Expected type: (k0, (Text, Y.Value))       Actual type: [(Text, Y.Value)]
18:56:27 <kqv> It seems to me that since all types are made from simpler types that have instance of Show, deriving the instance automatically should be possible for any type?
18:56:32 <simpson> e.g. Data.Unique would print something like "<unique>". Sure, it's unhelpful, but it *did* print.
18:57:02 <kqv> simpson: thats still somewhat helpful
18:57:03 <simpson> kqv: Nope, it's totally possible to build stuff that can't be shown, and there's a bunch of builtin types that aren't showable.
18:57:13 <kqv> oh I see
18:57:29 <simpson> IORef, Unique, etc. Also how do you print a function?
18:57:30 <AdituV> easiest nonshowable (by default) example: functions
18:57:47 <AdituV> there is a show instance that just prints "<function>" in one module in base though
18:58:16 <geekosaur> SirF, what's the code in questiomn (plus FULL error message)?
18:58:17 <geekosaur> @paste
18:58:17 <lambdabot> Haskell pastebin: http://lpaste.net/
18:58:23 <geekosaur> ^pastebin
18:58:27 <kqv> simpson: print the function source as it is?
18:58:52 <geekosaur> no, prints the literal string "<function>"
18:58:55 <SirF> k, kinda big but l'll pastebin it
18:59:03 <geekosaur> function source is not available at runtime
18:59:08 <simpson> kqv: Turns out to be harder than you think. Also what geekosaur said.
18:59:18 <kqv> geekosaur: yeah but im talking about ghci, with the source
18:59:30 <geekosaur> even then, it's forgotten it by the time it runs it
18:59:34 <kqv> simpson: yeah im being a bit naive
18:59:55 <simpson> kqv: I mean, there *are* systems that keep the source around for stuff like runtime proving, but Haskell's not one of them.
19:00:08 <kqv> geekosaur: yeah, im not saying it is possible with current ghci, im talking about what is possible in theory
19:00:16 <lpaste> SirF pasted “No title” at http://lpaste.net/164617
19:00:24 <simpson> This is one of those parts of Haskell that I just shrugged and accepted a long time ago. Don't use Show for producing user-visible results; use it only for debugging and hacking on small stuff.
19:01:16 <SirF> geekosaur: error is at the bottom
19:01:29 <kqv> Would be useful to have something like a Debug instance in rust, and if a type doesnt have a defined Debug, or it cant be derived, default to just the type name
19:03:13 <geekosaur> looks to me like the problem is that you are trying to apply fromList to a monadic value. the only monad it can find that is relevant is [], and that doesn't work.
19:03:24 <SirF> hmm
19:04:00 <SirF> I was wondering if it was something like that
19:04:01 <geekosaur> probably you need to use fmap to apply HM.fromList "inside" the monad
19:05:16 <SirF> hmm
19:07:19 <SirF> doesnt seem to work.. but i'm probably doing it wrong. I'm pretty new to haskell
19:08:56 <SirF> oh, actually almost got it
19:09:17 <geekosaur> there may well be more wrong, given the other errors
19:09:32 <SirF> I only have one now
19:10:04 <geekosaur> right, I just looked again and the others seem to be knock-on issues
19:10:17 <lpaste> SirF revised “No title”: “No title” at http://lpaste.net/164617
19:10:48 <SirF> seems to be something with the return of parseItem
19:11:17 <SirF> I'm not sure where the Y.parser comes from
19:11:29 <geekosaur> oh, I see, that wasn't quite the right thing
19:12:01 <geekosaur> Y.Parser is the monad here, the thing that lets you use "fail" and which requires use of mapM or Applicative syntax
19:12:25 <glguy> parseItem is returning a 2-tuple instead of a parser
19:12:42 <geekosaur> yes
19:12:49 <SirF> hmm
19:13:44 <SirF> I guess I don't follow how to make it return a parer
19:14:16 <geekosaur> if you look at parseItem in the other instances, it's returning value <$> fields --- this produces a value in the parser monad
19:14:45 <lpaste> glguy annotated “No title” with “something like this” at http://lpaste.net/164617#a164619
19:15:14 <geekosaur> you're almost doing the right thing but you wrap the parser result (the Group k <$> ...) in a tuple
19:17:37 <glguy> Or you can get cute with the Traversable instance for tuples:
19:17:40 <glguy> sequence (k, Group k 07<$> v2 07.:? 04"website" 07<*> v2 07.: 04"slug")
19:19:12 * hackagebot extensible-effects 1.11.0.4 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-1.11.0.4 (shergill)
19:19:47 <SirF> geekosaur: so how do I return a tuple in the parser so that I can HM.fromList it?
19:22:26 <geekosaur> SirF, did you see what glguy added to your paste?
19:22:36 <geekosaur> [27 02:14] <lpaste> glguy annotated “No title” with “something like this” at http://lpaste.net/164617#a164619
19:23:15 <SirF> oh yeah, that seems to work. Now im running into overlapping instances
19:23:33 <glguy> ?type curry sequence
19:23:34 <lambdabot> Monad m => a -> m a1 -> m (a, a1)
19:39:38 <pikajude> glguy, your syntax highlighter is cool
19:39:40 <pikajude> is it that haskell irc client
19:40:06 <glguy> Yeah, it's part of this: https://github.com/glguy/irc-core
19:40:25 <pikajude> neat
19:40:40 <mgsloan> Argh, is hackage down for other people?
19:40:48 <mgsloan> I was about to update the hackage metadata for store...
19:40:55 <Clint> mgsloan: varnish timeouts for me
19:40:57 <pikajude> does it only connect to one server at a time?
19:41:10 <rfw> what's the best way to implement an "abortable" foldl? i want to do foldl over a list but if i encounter something i want to call another function and use that as the result instead
19:41:37 <glguy> pikajude: Yeah, I started framing out support for me, but I only ever use Freenode, so I never finished that :)
19:41:45 <pikajude> oh ok
19:42:03 <Clint> we should fix that
19:42:34 <glguy> mgsloan: I'm seeing a 503 Connection timed out
19:42:53 <mgsloan> Opened https://github.com/haskell/hackage-server/issues/500
19:42:59 <mgsloan> Apt issue number is apt
19:43:33 <Clint> too bad it's not 503
19:43:52 <mgsloan> Lol true
19:46:23 * geekosaur sees nagios is one of the services on status.haskell.org... must not be very "Operational"
19:47:14 <hpc> i prefer nagandroid
19:47:47 * hpc zoidbergs away
19:48:14 * Clint snorts.
19:49:16 <mgsloan> geekosaur: That page says "Updated a month ago"
19:49:20 <mgsloan> What does that mean?!?
19:49:22 <mgsloan> XD
19:49:22 <geekosaur> yep
19:49:29 <geekosaur> I suspect it means "manually maintained"
19:49:56 <geekosaur> instead of being constructed automatically from actual service checks (thus my snark about nagios)
19:50:08 <mgsloan> Ahh gotcha
19:54:01 <statusbot> Status update: The rackspace datacenter has been rebooting some servers to perform updates. Hackage and other services are experiencing a short interruption. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5747b6b10e0ded6f1c0008f3
20:09:51 <statusbot> Status update: Rackspace has described a switching loop in their DFW datacenter. This affects hackage and mail at the moment. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5747b6b10e0ded6f1c0008f3
20:18:32 <sclv> note: we chose to make status manually maintained
20:18:42 <sclv> because we feared "line noise" from too many spurious alerts
20:18:53 <sclv> idk if it was the right choice... but it was def a decision
20:19:12 <mgsloan> That seems like a decision that entirely invalidates the point of a status page
20:20:44 <sclv> its used to communicate widely once we know what's up
20:20:58 <sclv> i'm open to revisiting the decision (i didn't make it, and questioned it too)
20:21:04 <sclv> but it is useful at the end of the day
20:21:11 <sclv> though unexpected
20:21:31 <sclv> maybe we could just attach a "service automated check" as a thing on the page as well, i'll poke at that
20:21:42 <sclv> as there's nothing to be done for the outage but wait for rackspace to fix its datacenter
20:42:26 <sclv> mgsloan: ok, now our webmon stuff is avail from http://auto-status.haskell.org/
20:42:32 <sclv> and status.h.o points to that
20:42:55 <sclv> if you have suggestions for more sites i should add to the auto monitoring let me know
21:12:19 <carterhinsley> welp, i've gotten tensorflow *working* in haskell
21:12:44 <carterhinsley> not much use for it yet but i'll be finishing up the wrapper over the coming weeks and give out the code for folks to play with
21:19:53 <Biessie> whats this?
21:20:12 <Biessie> Why is guest19 spaming this channel
21:22:19 <sm> sclv: http://auto-status.haskell.org is nice
21:22:23 <sm> it goes back 1 year ?
21:22:36 <sm> is that data accurate ?
21:22:42 <sclv> we've been running webmon for a while
21:22:49 <sclv> i just didn't realize we could generate a public status page for it
21:23:30 <sm> I thought we had some bigger outages than it's showing, maybe not
21:23:31 <sclv> also the hackage uptime isn't quite right because it was pointing at a static page that stays up even when some other stuff is hinky
21:23:37 <sclv> so that's the issue there
21:23:45 <sm> ah, good one :)
21:23:48 <sclv> i changed it recently to point to a page that requires hitting the hackage app itself
21:24:00 <sclv> anything else we should monitor let me know and i'm happy to add
21:24:21 <sm> http://matrix.hackage.haskell.org perhaps
21:25:02 <AbleAdamus> Haskell.org down for anyone else too?
21:25:23 <AbleAdamus> Or just hackage I guess
21:26:52 <sm> maybe mgsloan knows a useful stackage page to monitor
21:27:10 <sm> AbleAdamus: yes, https://status.haskell.org
21:28:21 <AbleAdamus> cool
21:29:42 <sm> sclv: also http://hackage.haskell.org/trac/ghc 
21:49:58 <sclv> thoughtpolice: so erm
21:50:04 <sclv> it looks like they're 90% done with the fix
21:50:07 <sclv> but hackage still won't come up
21:50:15 <sclv> prob because it has a drive on the cloud or whatever
21:50:20 <sclv> i don't know what to do to investigate
21:51:23 <sclv> replied to one of those "your server was shutdown" tickets
21:51:28 <sclv> to see if i can get some help from their techies
21:52:09 <sclv> thoughtpolice: should i try to get someone on the phone?
21:52:17 <sclv> oh, wrong channel for this chat, sorry
21:52:19 <thoughtpolice> sclv: I'm trying right now, hold on
21:52:28 <sclv> ok, will take it back to -infra
22:02:33 <petercommand> suppose that I have a stable ptr with type StablePtr Tree in haskell, is this the right way to fetch the constructor infotable and the string in the con_desc field in the info table? GET_CON_DESC(((StgConInfoTable *)deRefStablePtr(stablePtr)));
22:03:29 <petercommand> I am using ghc 7.10.3
22:10:07 <petercommand> I am getting segfaults when accessing the address returned by GET_CON_DESC(((StgConInfoTable *)deRefStablePtr(stablePtr))), so something is definitely wrong
22:12:27 <petercommand> the StablePtr is returned by newStablePtr
22:12:54 <petercommand> from Foreign.StablePtr
22:15:19 <obiwahn> http://paste.debian.net/707500/ -- is there some hackage problem?
22:15:33 <sclv> yes, hackage is down due to hosting issues
22:15:37 <sclv> see http://status.haskell.org
22:21:24 <petercommand> I got the stableptr in C by calling a function with signature IO (StablePtr Tree), and it has a "foreign export ccall" decl
22:21:25 <mgsloan> Yes, you can either use hackage mirrors, or switch to stack which does not rely on hackage availability
22:26:38 <johnw> petercommand: how is this deRefStablePtr defined?  is that something in C?
22:27:10 <petercommand> johnw: https://github.com/ghc/ghc/blob/5d98b8bf249fab9bb0be6c5d4e8ddd4578994abb/includes/rts/Stable.h#L38
22:27:21 <johnw> ah, I see
22:27:37 <johnw> I'm not sure how an StgStablePtr differs from a Foreign.StablePtr
22:29:10 <petercommand> I am not sure about that too
22:30:35 <petercommand> johnw: Foreign.StablePtr should be the HsStablePtr type
22:30:49 <johnw> right, but what you showed me is StgStablePtr
22:31:35 <johnw> if it's not that, than the memory block isn't what you think it is
22:32:55 <petercommand> https://github.com/ghc/ghc/blob/33c029dd77888ee5f9b1c7ce8884c982e0428adf/rts/RtsAPI.c#L342
22:33:48 <petercommand> The function rts_getStablePtr returns HsStablePtr, but it casts its result into StgStablePtr, so that's the reason I think they are the same
22:33:48 <johnw> ah
22:33:56 <johnw> I believe you now
22:34:07 <johnw> so is the data at the memory block really an StgConInfoTable*?
22:34:19 <johnw> what does the actual error from gdb say, btw?
22:34:31 <petercommand> segfault
22:34:33 <johnw> I wonder if it's a null pointer dereference, or a bad pointer, or a misaligned one
22:34:42 <johnw> several things can cause segfaults
22:34:44 <petercommand> no, it's not null ptr
22:34:52 <johnw> can you run it under gdb and show me what it reports?
22:34:59 <petercommand> ok
22:36:19 <obiwahn> type bt after the crash
22:36:31 <johnw> the backtrace is typically useless fwiw
22:36:52 <petercommand> yep, bt is useless
22:38:27 <petercommand> johnw: 0x1023043f3 is the result returned from GET_CON_DESC(((StgConInfoTable *)deRefStablePtr(stablePtr)))
22:38:53 <petercommand> johnw: the error is: EXC_BAD_ACCESS (code=1, address=0x1023043f0)
22:39:05 <zq> is it possible to generate new type variables in type families?
22:39:13 <petercommand> I am using lldb, but should not make a difference
22:39:39 <johnw> petercommand: can you x/20 0x1023043f0
22:39:45 <johnw> is the data accessible?
22:39:59 <johnw> I can't tell whether it's a valid pointer without more inspection
22:40:09 <johnw> it doesn't look like ASCII
22:40:13 <petercommand> johnw: no, it's not accessible
22:40:21 <petercommand> error: failed to read memory from 0x1023043f0
22:40:23 <johnw> ok, that would explain the segfault
22:40:32 <johnw> you're accessing a page not allocated to your process
22:40:38 <johnw> so it's not actually a pointer
22:40:44 <petercommand> yep
22:40:45 <johnw> it's just data that's been cast to a pointer
22:41:03 <johnw> now you have to track back where that data block came from, and what it's value is
22:42:49 <petercommand> which data block?
22:43:16 <obiwahn> undodb 4tw in this situation:) i have one of their sample usb sticks and i was impressed
22:43:47 <petercommand> johnw: this result is from GET_CON_DESC(((StgConInfoTable *)deRefStablePtr(stablePtr)))
22:46:23 <petercommand> johnw: it is basically just doing table lookup + pointer arithmetic
22:46:51 <johnw> i mean, where did that stablePtr come from
22:47:05 <johnw> what's in there isn't a StgConInfoTable *
22:50:30 <johnw> zq: generate?
22:50:33 <petercommand> johnw: it is from a call to a foreign exported function defined in haskell with type "StablePtr Tree"
22:51:08 <johnw> petercommand: interesting; at this point you're beyond my understanding of the GHC internals
22:51:19 <petercommand> I've made sure that the Tree is already evaluated to head normal form
22:51:41 <johnw> and you're expecting to find information about the constructor and its arguments
22:51:42 <zq> johnw: i'm trying to define a type family that takes input like '[Int, Bool, Char] and outputs (Constraint a, Constraint b, Constraint c) => a Int -> b Bool -> c Char
22:51:50 <petercommand> ah, it is IO (StablePtr Tree)
22:51:55 <petercommand> johnw: yes
22:54:48 <johnw> zq: TH can do that; I don't think type families can
22:54:56 <johnw> zq: trying, I get illegal polymorphic type
22:55:19 <zq> johnw: yeah i'm brainstorming a workaround with typeclasses
22:55:44 <petercommand> johnw: actually, the thing I am trying to do is directly transforming haskell sum type into rust sum type without transforming haskell data types into a C data type, then marshal it to the corresponding rust data type
22:56:22 <johnw> petercommand: I see, you just want direct reflection; just to warn you, that could change without notice
22:56:52 <petercommand> yes, I know that
23:15:31 <bollu> I finally understand how a pair of functors that are adjoint yield a monad
23:15:42 <bollu> but can someone explain the intutition as to why the direction "flips"?
23:15:53 <bollu> as in, why does f -| g give us Monad (Compose g f)?
23:16:07 <bollu> like, if someone hands me the adjoint rules now I can write the monad
23:16:21 <bollu> but I don't intuitively understand in which direction stuff flows
23:16:48 <bollu> I was hoping for some intuition
23:17:48 <johnw> so, in this case f is the free functor, and g is the forgetful functor, right?
23:18:10 <bollu> johnw: yes
23:18:43 <johnw> the intuition for G (F X) is that F X "enriches" X somehow, and then G allows the enriched object to be re-mapped into the poorer category
23:19:03 <johnw> the monad gives you a way of work with an enriched structure is a "less capable" kind of medium
23:19:13 <johnw> sorry for the grammatical errors
23:19:35 <bollu> hm, so the G somehow "degrades F enough" to let you build a monad?
23:19:46 <bollu> that's pretty didgy
23:19:49 <bollu> dodgy*
23:19:58 <johnw> so, for example, you can take an object from set, turn it into a monoid, and then map the monoid back into set.  You now have an object with monoid structure encapsulated within set
23:20:19 <johnw> the monad arises because you are working with a rich object in a context where you don't need to think about the richness
23:20:27 <bollu> johnw: but when you go back to set, don't you lose monoid structure again?
23:20:41 <johnw> no
23:20:47 <bollu> johnw: what connection does a monad have to richess? I've always thought of monads as gluing endofunctors
23:20:49 <johnw> once you use "return", the original object is "within" the monad
23:20:52 <johnw> and it never comes back out
23:21:03 <bollu> hmm
23:21:10 <bollu> a -> g (f a)
23:21:11 <johnw> the richness is one half of the adjunction
23:21:36 <bollu> oh, that brings me to another question
23:21:44 <bollu> what is the intution for the couint having the layers flipped?
23:21:47 <bollu> as in, why f (g  a) -> a?
23:23:44 <johnw> that's a good question, I'll have to think on it
23:26:34 <zq> how to declare a closed data family?
23:26:46 <johnw> zq: type family Foo a where
23:26:49 <johnw> the "where" keys it
23:26:56 <zq> `data D ts where` => "parse error on input where"
23:26:58 <zq> johnw: ^
23:27:06 <johnw> data family
23:27:08 <johnw> not just data
23:27:09 <zq> johnw: i want a data family, not a type family though
23:27:15 <zq> doh
23:27:24 <zq> nah, i had family already
23:27:53 <zq> data family D ts where
23:27:53 <zq> <interactive>:2:18: parse error on input ‘
23:28:08 <zq> <interactive>:2:18: parse error on input ‘where’
23:28:16 <zq> maybe it requires a kind signature
23:28:31 <zq> nope, that's not it
23:29:47 <zq> ah whatever i'll just stay with data instance for now
23:31:22 <johnw> i don't think there are closed data families
23:32:07 <johnw> maybe you want a GADT?
23:33:41 <nshepperd> isn't a closed data family just a gadt
23:36:50 <zq> nshepperd: how would you do something like
23:37:00 <zq> data instance D '[] = DNil
23:37:14 <zq> data instance D (a ': as) = D a (D as)
23:37:15 <zq> ?
23:37:30 <johnw> data D :: [*] -> * where DNil :: D '[]
23:37:54 <johnw> DCons :: a -> D as -> D (a ': as)
23:37:55 <zq> oh shit
23:37:58 <zq> yeah
23:38:10 <nshepperd> yeah, that
23:38:22 <johnw> aka, a type-indexed list :)
23:38:44 <johnw> must be a hundred of these on Hackage, btw
23:41:09 <Xandaros> …which appears to be down atm
23:45:34 <bollu> johnw: any insight into a -> g (f a)? As far as I can see, it's just because of the way the functors compose
23:45:43 <bollu> like, f is the free one, so you apply it first
23:45:50 <bollu> and then g is forgetful so you use it lower it down
23:45:52 <bollu> that's it right?
23:45:56 <bollu> like, no deep reason?
23:45:58 <bollu> or is there one?
23:46:12 <johnw> I thought we already covered g (f a)
23:46:33 <bollu> oh, sorry, I mean f (g a) -> a
23:46:41 <johnw> oh, no, I don't have an intuition for that yet
23:46:47 <johnw> i mean, it's going to involve the same concepts
23:46:48 <bollu> it's just the way the functors' domains and codomains are arranged?
23:46:51 <johnw> but I don't know why it works out
23:46:54 <bollu> aw, hackage is down
23:46:56 <johnw> it has meaning
23:47:12 <bollu> I wanted to codensity docs where he says "a kan extension along _itself_"
23:47:26 <bollu> what does that mean? As in, how do you interpret a kan extension along itself?
23:48:11 <bollu> the intuition I have of a kan extension is to "extend" a map C -> D from a smaller domain C to a larger domain C' given a functor C -> C'. The kan extension lets you create a C' -> D (which is the extended C -> D map)
23:48:14 <bollu> right?
23:48:20 <bollu> so, what does it mean to "extend along itself"?
23:49:57 <johnw> along itself means Kan F F
23:50:07 <johnw> aka, forall r. (a -> f r) -> f r
23:50:35 <johnw> I meant, Ran there, I believe
23:51:11 <bollu> johnw: so in the set of 3 categories I used, which two become the same?
23:51:17 <bollu> among C C' and D?
23:51:24 <bollu> oh, the two functors are the same?
23:51:31 <bollu> wait, what? that's just weird
23:51:33 <bollu> how do I visualize it?
23:52:01 <johnw> one sec
23:52:10 <bollu> sure
23:53:29 <johnw> it might be easier to first understand it in terms of some concrete categories
23:53:45 <johnw> that is, instead of thinking of functors, just think about some types
23:54:20 <bollu> johnw: okay. Which ones should i think of?
23:54:21 <johnw> functors are generalizing things, but we don't need them to grasp the intuition
23:54:28 <johnw> say you had a function Int -> Double
23:54:41 <johnw> and I gave you a function Int -> Float
23:54:56 <johnw> you say, "a right kan extension exists for me to extend my float to a double"
23:55:06 <johnw> there's a good analogy for this on the web, looking...
23:55:58 <johnw> I can't find it
23:56:02 <johnw> it basically gives the example of compilation
23:56:09 <johnw> you have one process for compiling from source code to a binary
23:56:18 <johnw> and another process for evaluating source code using an interpreter
23:56:32 <johnw> a kan extension would be like interpreting into a binary code
23:56:45 <johnw> note that such a function to "complete the triangle" doesn't always exist
23:57:47 <johnw> but when it does exist, it has lots of properties (discussed in depth on nLab)
23:59:09 <johnw> for the Int -> Double and Int -> Float case, the final function would be (Int -> Float) -> Double.  That is, you give me a functor Int -> Float, and I can use it to reach Double.
23:59:12 <johnw> now generalize this to functors
23:59:27 <johnw> sorry, meant function Int -> Float up above
