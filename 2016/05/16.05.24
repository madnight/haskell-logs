00:00:08 <jle`> recursion + pattern matching
00:08:36 * hackagebot sandman 0.2.0.1 - Manages Cabal sandboxes to avoid rebuilding packages.  https://hackage.haskell.org/package/sandman-0.2.0.1 (abhinav)
00:10:23 <dibblego> how to Int -> (Word8, Word8, Word8) ?
00:11:17 <EvanR> .&. and shiftR from Data.Bits
00:11:33 <dibblego> OK, will do, cheers.
00:12:17 <Axman6> or quotRem 
00:12:34 <Ralith> or const (0, 0, 0)
00:14:37 <MichaelBurge> dibblego: Depending on what you're doing, you could also use Data.Binary
00:15:03 <dibblego> it's cool, I'll just shift those itty bitty bits
00:28:37 * hackagebot relational-record-examples 0.3.1.0 - Examples of Haskell Relationa Record  https://hackage.haskell.org/package/relational-record-examples-0.3.1.0 (KeiHibino)
00:43:38 * hackagebot th-utilities 0.1.1.0 - Collection of useful functions for use with Template Haskell  https://hackage.haskell.org/package/th-utilities-0.1.1.0 (MichaelSloan)
00:48:02 <EvanR> glguy: does ninjas still work?
00:48:38 * hackagebot compactmap 0.1.4 - A read-only memory-efficient key-value store.  https://hackage.haskell.org/package/compactmap-0.1.4 (SimonMarechal)
00:58:39 * hackagebot authenticate-oauth 1.5.1.2 - Library to authenticate with OAuth for Haskell web applications.  https://hackage.haskell.org/package/authenticate-oauth-1.5.1.2 (MichaelSnoyman)
01:06:34 <jle`> hi everyone
01:06:41 <jle`> why does evalStateT still require a Monad constraint
01:08:39 * hackagebot base-noprelude 4.9.0.0 - "base" package sans "Prelude" module  https://hackage.haskell.org/package/base-noprelude-4.9.0.0 (HerbertValerioRiedel)
01:13:39 * hackagebot language-thrift 0.8.0.1 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.8.0.1 (abhinav)
01:41:12 <Zyxoas> Peep-meisters.
01:42:07 <Zyxoas> I actually forgot what I came here for, now...
01:42:30 <Zyxoas> Oh wait!
01:42:59 <Zyxoas> So, how do I see the transitive dependencies of a package with Cabal-install or stack?
01:43:41 * hackagebot cgrep 6.6.4 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.4 (NicolaBonelli)
01:43:42 <Zyxoas> I basically want to see which one of my dependencies is trying to install the ancient transformers-0.4.2
01:46:04 <Zyxoas> How do I interrogate Cabal's build plan?
01:49:53 <MichaelBurge> Zyxoas: If you're using stack, it looks like that's just what on Stackage: https://www.stackage.org/nightly-2016-05-24
01:50:39 <MichaelBurge> Zyxoas: You could work around it by specifying a newer version in your .cabal, and maybe adding a reference to it in the stack.yaml
01:54:02 <jhrcek> MichaelBurge, jle`: you're right guys, recusrion & pattern matching was simple enough. Thanks
01:55:27 <jle`> np!
01:57:29 <dcoutts> zyla: 
01:57:33 <dcoutts> oops
01:57:46 * dcoutts was going to suggest something to Zyxoas, but they disappeared
01:58:23 <MichaelBurge> dcoutts: I'd be curious to hear it. 
01:58:47 <dcoutts> oh, well the cabal new-build stuff produces a json build plan
01:59:24 <dcoutts> but perhaps the better answer for Zyxoas's Q about why is this version pulled in, is to look at the output of the solver
01:59:38 <dcoutts> as that explains why each thing is tried next, what it was a dep of
02:01:26 <MichaelBurge> dcoutts: So you'd add a newer version constraint for transformers, increase the verbosity, and look at the error?
02:01:40 <dcoutts> MichaelBurge: yes
02:11:02 <brujoand_> hi, is there a way to run cabal install <package> and create a deb package from it with all dependencies?
02:11:23 <brujoand_> I should note that I'm completely new to Haskell
02:14:01 <brujoand_> hm, cabal-debian seems like a good fit
02:18:42 * hackagebot store 0.1.0.1 - Fast binary serialization  https://hackage.haskell.org/package/store-0.1.0.1 (MichaelSloan)
02:28:51 <Desu> brujoand_: you are better off just doing a cabal install on each machine usually
02:31:02 <brujoand_> Desu: The thing is that this is for our local travis workers. And the cabal package in question is Shellcheck, which takes a fair amount of time to complie. But I guess it's a tredeoff between complexity and speed.
02:31:48 <bergmark> brujoand_: you can use travis ci's caching
02:32:26 <brujoand_> bergmark: ah, good point
02:36:42 <brujoand_> bergmark: you would cache all but the config file in ~/.cabal then?
02:37:14 <brujoand_> or rather. lib, packages and share
02:40:37 <whald> hi! I already asked this an hour ago in #haskell-stack but got no answer. so please fogive me being slightly off-topic when asking here again:
02:40:45 <whald> I have a build script which does a "cabal build --prefix=... ; cabal build ; cabal copy --destdir=..." sequence, followed by some other commands collecting the stuff from the destdir for packaging. can s.o. tell me how to achieve similar results with stack?
02:42:41 <Sparhawk> yo
02:43:29 <whald> I only see how I can get stack to put the binaries into some specific directory, but my binaries also require some files (configured in the data-files section of cabal) which would have to end up in the expected place. I could not dig out how to do that with stack.
02:47:17 <dcoutts> whald: your script is exactly what I'd do. It's essentially what the distros do.
02:50:41 <whald> dcoutts, everything is fine with the script, except it does not use stack. I think i'd like to use stack because we recently had some problems with inconsistent package / GHC versions on development and build machines which I feel stack can rule out.
02:51:30 <whald> dcoutts, also, the first command in the script is "cabal configure --prefix=...", not "cabal build .." -- just a typo here.
02:53:06 <dcoutts> whald: a smaller step might be to make sure you're using a consistent set by using cabal freeze to pick the versions that your script installs.
02:54:59 <whald> dcoutts, that's what i previously did, but this means manually installing a consistent set of GHC versions on all machines. we have a mix of linux and freebsd builds, so this was getting kind of tedious. :-/
02:56:05 <dcoutts> whald: you can verify you've got the same ghc version if you have a constraint on base
02:58:06 <whald> dcoutts, cabal freeze actually does generate that constaint on base, so that part is solved. if I only had s.o. to install the required GHC versions and update the PATH variables on all machines. :-)
02:58:45 <dcoutts> whald: I see
03:19:56 <sbrg> wow. using gtk with haskell feels so *wrong*
03:23:01 <phadej> sbrg: it's an exercise of abstraction techniques :)
03:26:12 <lemonxah> i am learning haskell and i want to convert a list of lists into a matrix
03:26:32 <lemonxah> i have found the function fromLists n m [[1..3],..]
03:26:47 <lemonxah> but how do i "import" that function
03:28:53 <newcomer> why is there <* operator and no << operator? what's the use of <* and *> anyway if >> exits?
03:31:03 <EvanR> :t (<<)
03:31:05 <lambdabot>     Not in scope: ‘<<’
03:31:05 <lambdabot>     Perhaps you meant one of these:
03:31:05 <lambdabot>       data constructor ‘Seq.:<’ (imported from Data.Sequence),
03:31:09 <EvanR> hrm
03:32:09 <Cale> I typically think of (*>) and (<*) as being intended to be used together, usually in the context of writing parsers, where you want to keep the order on the page the same as the order in the string being parsed
03:32:28 <Cale> The arrows point toward the thing which is producing the eventual result
03:32:29 <newcomer> :t (<*)
03:32:31 <lambdabot> Applicative f => f a -> f b -> f a
03:33:05 <Cale> Yeah, the other difference is that they only require an Applicative instance.
03:33:19 <Cale> (>>) is much older
03:33:36 <lemonxah> Could not find module ‘Data.Matrix’
03:33:41 <lemonxah> https://hackage.haskell.org/package/matrix-0.3.4.4/docs/Data-Matrix.html
03:33:55 <lemonxah> how would i use that package?
03:34:16 <fr33domlover> Is there an existing operator, say |||, which for (== 1) ||| (== 2) returns a function that returns True iff the argument is 1 or 2?
03:34:33 <Cale> That depends on what tools you're using to build your project. If you just cabal install matrix, you should be able to import Data.Matrix though.
03:34:42 <chipf0rk> fr33domlover: not really an operator, but: liftA2
03:35:00 <chipf0rk> fr33domlover: use the Applicative of functions for this
03:35:14 <lemonxah> Cale i am very new i am not sure what i am using i have ghci that i test code in
03:35:20 <Cale> For this particular case, you could also write (`elem` [1,2])
03:35:35 <fr33domlover> Cale, sure, it's just a simple examle :P
03:35:56 <fr33domlover> chipf0rk, thanks. Could you plz give an example?
03:36:11 <Cale> > liftA2 (||) (==1) (==2) 5
03:36:13 <lambdabot>  False
03:36:15 <Cale> > liftA2 (||) (==1) (==2) 1
03:36:17 <lambdabot>  True
03:36:18 <chipf0rk> ^
03:37:07 <fr33domlover> Cale, chipf0rk, thanks :-)
03:37:44 <chipf0rk> fr33domlover: np
03:38:00 <Cale> lemonxah: If you have cabal-install, you should be able to  cabal install matrix  at the commandline, and get that package
03:38:15 <lemonxah> ok cool let me test that
03:38:33 <lemonxah> sorry for the stupid question :) trying to switch from using scala to haskell
03:38:43 <lemonxah> learning is slow for me
03:49:31 <newcomer> "liftA2 (||) (==1) (==2)" lifts a function that takes two booleans to a couple of functions that return two booleans. That's confusing!
03:50:11 <lemonxah> getDiagonal :: Matrix Int -> Int -> [Int] -> [Int]
03:50:18 <lemonxah> that is a funtion i am trying to write 
03:50:42 <EvanR> gloss-juicy 0.2 doesnt seem to understand latest gloss, build error instead of version dep mismatch
03:50:52 <lemonxah> i want to give it a Matrix of int and then a number of rows and then an acc and then it should give me out [Int] 
03:51:01 <lemonxah> is that the right signature for what i want to do?
03:51:22 <EvanR> gloss/bmp seems to always show a white rectangle instead of a bmp, emailed the "bugtracker"
03:51:40 <chipf0rk> newcomer: for examples as simple as this, yes indeed, but that's just what the function applicative does
03:52:00 <Cale> liftA2 f g h x = f (g x) (h x)
03:56:26 <EvanR> what the heck, there are tabs in the offending gloss-juicy file
03:56:41 <EvanR> vim ... wtf
04:00:23 <EvanR> after fixing... gloss juicy also showing white
04:00:29 <EvanR> on OSX
04:04:07 <newcomer> chipf0rk, Cale: OK, got it. Thanks.
04:08:47 * hackagebot cayley-client 0.1.5.1 - A Haskell client for the Cayley graph database  https://hackage.haskell.org/package/cayley-client-0.1.5.1 (MichelBoucey)
04:19:36 <croix> hi
04:20:25 <croix> question about aeson - is there a way to make toJSON render some fields conditiionally?
04:21:03 <croix> to render some fields and not others depending on the value?
04:24:42 <liste> croix: you can define your own ToJSON instance
04:25:56 <lemonxah> anyone using atom as an ide or still just vim?
04:25:59 <liste> croix: https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson.html#g:2
04:26:06 <guest732> Is possible to traverse list of Either but return `Left` only if all items are `Left`?
04:29:40 <Cale> guest732: Easier to do that if it's with Right.
04:30:07 <Cale> sequence :: [Either e a] -> Either e [a]
04:30:43 <chipf0rk> guest732: If it has to be `Left`s for some reason... you could write your own function to do this. e.g. define flipEither :: Either a b -> Either b a
04:30:49 <chipf0rk> then your function is: flipEither . traverse flipEither
04:31:09 <chipf0rk> in general though, as Cale points out, the convention is to use Right for this
04:33:04 <guest732> What about Maybe? If I have [Maybe a] can I traverse it so it returns Nothing only if all items are Nothing?
04:33:19 <Cale> guest732: What's the type of the operation?
04:33:32 <Cale> [Maybe a] -> Maybe a?
04:33:41 <Cale> :t msum
04:33:43 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
04:33:55 <Cale> > msum [Nothing, Nothing, Nothing]
04:33:57 <lambdabot>  Nothing
04:34:03 <croix> liste i think see, so i would do something like case name of ... blah -> ["name" .= ...]  excludeCondition -> ["otherFields" .= ...]
04:34:05 <Cale> > msum [Just 5, Nothing, Just 8]
04:34:07 <lambdabot>  Just 5
04:34:12 <croix> is there a more elegant way i could express that?
04:34:22 <guest732> [Maybe a] -> Maybe [a]
04:34:41 <croix> like could you somehow make a monoid where some values lead to a field not being rendered?
04:34:51 <jasonmason> :t catMaybes
04:34:52 <lambdabot> [Maybe a] -> [a]
04:34:56 <jasonmason> nope
04:35:47 <Xnuk> :t sequence
04:35:48 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
04:36:43 <guest732> I don't think I could use a monoid
04:36:57 <Xnuk> > sequence [Just 3, Just 4, Just 1]
04:36:59 <lambdabot>  Just [3,4,1]
04:37:00 <croix> guest732 are you talking to me?
04:37:09 <croix> i'm losiing track of conversation threads
04:37:14 <guest732> yes
04:37:42 <croix> guest732 so there's no way to express conditional json rendering other than
04:37:54 <croix> manually case checking each field?
04:38:57 <jasonmason> guest732 what should [Just 1, Just 2, Nothing] return?
04:39:16 <guest732> jasonmason: Just [1,2]
04:40:15 <Xnuk> > catMaybes [Just 1, Just 2, Nothing]
04:40:17 <lambdabot>  [1,2]
04:40:23 <croix> i've gotta think there's a better way
04:40:27 <Athas> Has anyone else noticed ghci being much slower in 8.0?
04:40:34 <Athas> Specifically, the speed of loading modules.
04:40:48 <guest732> I need a function [Maybe a] -> Maybe [a] that returns Nothing only if all elemens are Nothing
04:40:59 <chipf0rk> guest732: what should it do for an empty list?
04:41:01 <chipf0rk> Just []?
04:41:16 <chipf0rk> there's some edge cases here
04:41:31 <Xnuk> > catMaybes [Nothing, Nothing]
04:41:33 <lambdabot>  []
04:41:45 <guest732> chipf0rk:  Just []
04:42:17 <Cale> Well, all the elements of [] are Nothing...
04:42:18 <jasonmason> guest732 why do you want to keep it Maybe [a] instead of just [a]
04:42:36 <Cale> case catMaybes xs of [] -> Nothing; us -> Just us
04:43:11 <chipf0rk> Cale: that returns Nothing for the empty list too though :)
04:43:44 <Freundlich> chipf0rk: All elements of an empty list are Nothing.
04:43:59 <Freundlich> chipf0rk: It's consistent with what you asked for at least. ;)
04:44:08 <guest732> jasonmason: How do I know that list had only Nothings?
04:44:13 <chipf0rk> Freundlich: see above what behaviour guest732 asked for, that doesn't match
04:45:14 <Freundlich> Oh, wait... sorry.
04:45:54 <Freundlich> Now I'm confused.
04:46:40 <Xnuk> > let f [] = Just []; f xs = if null x then Nothing else Just x where x = catMaybes xs in f [Nothing, Nothing]
04:46:41 <lambdabot>  Nothing
04:46:45 <Xnuk> > let f [] = Just []; f xs = if null x then Nothing else Just x where x = catMaybes xs in f []
04:46:46 <lambdabot>  Just []
04:47:10 <guest732> The most important part this function need to work for Either as well so `[Eithere a b] -> Either [b] a ` returns `Left a` only if all items are Left
04:47:21 <jasonmason> guest732 result will be []
04:48:33 <guest732> jasonmason: Ok, but I need it also for Either
04:48:45 <chipf0rk> guest732: what Xnuk proposes. I guess it won't get much more beautiful than this (apart from rewriting it with pattern matching etc)
04:49:04 <jasonmason> :t rights
04:49:05 <lambdabot> [Either a b] -> [b]
04:49:10 <jasonmason> :t lefts
04:49:12 <lambdabot> [Either a b] -> [a]
04:52:29 <jasonmason> if you need to distinguish between an empty list and a list with just Lefts then you'll need to use case
04:53:12 <jasonmason> as far as i know anyway
04:55:50 <guest732> jasonmason: The problem is - my function return not just Either but ExceptT so I cannot use lefts I need something like traverse but with different behavior
04:57:08 <lpaste> chipf0rk pasted “guest732 all lefts” at http://lpaste.net/164447
04:57:30 <chipf0rk> what you want to do with your lefts, only return the first one or combine them, i don't know
04:58:31 <chipf0rk> this has type [Either a b] -> Either [a] [b]
04:58:33 <guest732> chipf0rk: I use ExceptT not just Either so I cannot use lefts
05:00:38 <chipf0rk> guest732: perhaps something like Control.Monad.Except.mapExcept / mapExceptT
05:01:53 <chipf0rk> perhaps not... I'm not sure at this point
05:02:37 <guest732> chipf0rk: Maybe it could work I will try it
05:03:50 * hackagebot kraken 0.0.2 - Kraken.io API client  https://hackage.haskell.org/package/kraken-0.0.2 (wereHamster)
05:03:52 * hackagebot ip 0.6.1 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.6.1 (andrewthad)
05:03:54 * hackagebot hint 0.5.2 - Runtime Haskell interpreter (GHC API wrapper)  https://hackage.haskell.org/package/hint-0.5.2 (mvdan)
05:13:47 <NIX_> I'm ready to drink the koolaid
05:14:46 <selckin> learn you a haskell for great good
05:16:48 <nmattia> lemonaxxad: I've seen people successfully use it
05:17:06 <nmattia> lemonxah: ^^ (sorry for the spelling)
05:18:09 <nixnothing> aka "NIX_" (if it wasn't obvious
05:18:50 * hackagebot github-release 0.1.9 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-0.1.9 (fozworth)
05:25:38 <statusfailed> Is there a "data" equivalent of functional dependencies?
05:26:09 <statusfailed> I'm not sure if data families are what I want
05:36:48 <maerwald> haddock-api throws "Setup: Encountered missing dependencies: ghc >=8.0, ghc-boot -any", but both deps are installed
05:43:51 * hackagebot optparse-helper 0.2.1.0 - Helper functions for optparse-applicative.  https://hackage.haskell.org/package/optparse-helper-0.2.1.0 (pharpend)
05:43:53 * hackagebot rest-types 1.14.1 - Silk Rest Framework Types  https://hackage.haskell.org/package/rest-types-1.14.1 (ErikHesselink)
05:48:52 * hackagebot ip6addr 0.5.1.2 - Commandline tool to generate IPv6 address text representations  https://hackage.haskell.org/package/ip6addr-0.5.1.2 (MichelBoucey)
05:57:17 <kritzcreek> mikeplus32: if you are still fighting with ghc-mod I'd suggest you delete any cabal relic except for the .cabal file from your project. Think cabal.sanbox.config .cabal-sandbix
05:57:30 <kritzcreek> mikeplus32: and the dist/ folder
06:08:03 <phz_> hey, do you think that someday we’ll get rid of the GC?
06:08:58 <hpc> i hear in ghc12 the garbage collector is getting replaced with a rubbish accumulator
06:09:07 <phz_> hm?
06:09:26 <hpc> (but yeah, ghc haskell is probably going to be garbage collected forever)
06:09:42 <phz_> I love how Rust handles that problem
06:09:46 <phz_> I’d love Haskell do the same
06:10:10 <liste> phz_: look into Idris and ATS
06:10:17 <phz_> Idris has a GC right?
06:10:22 <phz_> I don’t know ATS
06:10:40 <liste> phz_: it has a linear typing system under development that would make GC optional
06:10:47 <liste> Idris, that is
06:10:51 <liste> ATS has always had that
06:10:52 <phz_> yeah, I heard of its LT
06:12:09 <phz_> liste: I guess Rust has some kind of LT as well
06:15:17 <jasondockers> does the signature a -> a -> (a -> a) read as "a maps to a function from a to a function from a to a"?
06:15:41 <jasondockers> sorry for the lack of quotes ^
06:15:55 <phz_> jasondockers: it’s isomorphic to a -> a -> a -> a
06:16:02 <ClaudiusMaximus> it's the same as a -> a -> a -> a, which is different from (a -> a) -> a -> a
06:16:04 <Hafydd> jasondockers: it would typically be written as a -> a -> a -> a, and read as "a to a to a to a".
06:16:05 <phz_> or even a -> (a -> a -> a)
06:16:36 <Hafydd> jasondockers: however, you might often think it as a function from 3 arguments of type a to a result of type a.
06:17:12 <jasondockers> Hafydd, if you imagine the currying?
06:17:38 <Hafydd> jasondockers: if you imagine it as the curried version of (a, a, a) -> a, yes.
06:18:39 <Hafydd> Of course, you can also give it 2 arguments and obtain a result of type a -> a, which might be a common use if it's written as a -> a -> (a -> a).
06:18:40 <jasondockers> Hafydd, sorry, you are saying (a, a, a) -> a is conceptually the same as (maybe not isomorphic?) to a -> a -> a -> a.. heh
06:18:53 * hackagebot yesod-bootstrap 0.3 - Bootstrap widgets for yesod  https://hackage.haskell.org/package/yesod-bootstrap-0.3 (andrewthad)
06:20:03 <Hafydd> jasondockers: they certainly aren't ismorphic. I'm saying that in a particular use case, they are conceptually the same.
06:20:20 <jasondockers> Hafydd, okay. That's what I thought. 
06:22:23 <hpc> not isomorphic?
06:23:53 * hackagebot grouped-list 0.2.1.2 - Grouped lists. Equal consecutive elements are grouped.  https://hackage.haskell.org/package/grouped-list-0.2.1.2 (DanielDiaz)
06:24:26 <jasondockers> in set theory isomorphic just means bijective?
06:24:50 <jasondockers> I don't really know any category theory, which I'm hoping I just need to glean to pick up Haskell.
06:25:12 <hpc> you don't really need much CT to learn haskell
06:26:37 <hpc> also CT isomorphisms are slightly different from set theory's
06:26:47 <ij> jasondockers, Usually isomorphic in set theory is a bijective function that preserves some property. also that ^
06:27:06 <jasondockers> hpc, could you recommend any sources to learn haskell? I've found by example to start with is the best so I can memorize the basic syntax, then I move onto books.
06:27:48 <jasondockers> ij, okay
06:27:57 <hpc> @where rwh
06:27:57 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:28:09 <hpc> that's usually a good place to start
06:28:50 <Hafydd> Well, they are isomorphic as objects in Hask, but I assumed that in this case something stronger (I'm not sure what, exactly) was intended.
06:29:32 <Hafydd> Equal under a renaming of type variables, maybe.
06:29:55 <hpc> ah
06:30:47 <Hafydd> The Hask-ismorphism would be curry3, with inverse uncurry3.
06:32:24 <jasondockers> is http://www.realworldhaskell.org/ down for anyone else? I tried changing dns servers but I still can't resolve it.
06:32:50 <barrucadu> It does look down
06:33:39 <jasondockers> ah, I guess I'll either use the way-back machine or table my unrealistic goal of learning Haskell in a week.
06:33:43 <barrucadu> jasondockers: bitemyapp has a collection of learning resources here: https://github.com/bitemyapp/learnhaskell
06:33:53 <barrucadu> There's also lyah
06:33:54 <barrucadu> @where lyah
06:33:55 <lambdabot> http://www.learnyouahaskell.com/
06:36:27 <hpc> jasondockers: it took me about a month to get to the point where i was comfortablly writing code that worked
06:37:13 <dino-> Do people still recommend Learn You? http://learnyouahaskell.com/
06:37:19 <jasondockers> hpc, I'm mainly concerned with learning function programming. I had it introduced in university, but I never really become proficient. I half understood the state monads and such.
06:37:23 <dino-> Learn You A Haskell, for getting started.
06:37:27 <jasondockers> functional*
06:38:54 * hackagebot phantom-state 0.2.1.0 - Phantom State Transformer. Like State Monad, but without values.  https://hackage.haskell.org/package/phantom-state-0.2.1.0 (DanielDiaz)
06:40:19 <hpc> LYAH has been losing popularity
06:41:37 <hpc> it doesn't have exercises, it uses the non-existent State constructor, a few other things
06:41:41 <jasondockers> LYAS was horrible imho
06:41:54 <jasondockers> "Learn You a Scala"
06:44:34 <Jinxit> LYAH is fine as an overview, but not for actually learning haskell
06:47:54 <Maerten> Anyone here who knows how to use keyValueEntityToJSON (http://hackage.haskell.org/package/persistent-2.2.2/docs/Database-Persist-Class.html#g:9) with the default persistent json entity instances?
06:49:39 <Maerten> I want to get a custom JSON format for my entities, while not having to learn TH first, or definining all entity json instances manually (derive generic w/ json doesnt seem to be an option with persistent)
06:51:00 <phz_> hey, how do you compile against GHC 8.0.1?
06:51:08 <phz_> (the base dep?)
06:52:30 <maerwald> Jinxit: it's not even fine as an overview, because it's too verbose for an overview
06:52:43 <hexagoxel> phz_: ghc-8.0.1 corresponds to base-4.9.0.0, if that is your question.
06:53:55 * hackagebot hpath 0.7.1 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.7.1 (maerwald)
06:54:45 <phz_> hexagoxel: thanks
06:54:49 <phz_> where to you find that?
06:54:58 <phz_> I’ve been always wondering where to pick that information
06:55:31 <bergmark> phz_: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
06:56:21 <bergmark> not completely up to date for ghc 8 though
06:57:15 <hexagoxel> phz_: i just queried my ghc-8.0.1/ghc-pkg :p
06:58:16 <hexagoxel> if you plan to support ghc-8, you probably have that lying around somewhere too, right :)
07:03:40 <phz_> hexagoxel: thanks
07:03:51 <phz_> thanks you all
07:04:33 <tenniscp25> is there any monad or abstraction that i can use to help reorder statements based on dependency inside a do block.
07:05:11 <tenniscp25> ?
07:14:22 <dino-> hpc: I was wondering about that. I haven't looked at in a long time as well.
07:16:01 <phz_> I cannot make stack download ghc-8.0.1
07:16:39 <phadej> phz_: resolver: ghc-8.0.1 and recent enough stack?
07:17:47 <phz_> oh
07:17:49 <phz_> thanks :D
07:28:57 * hackagebot event 0.1.4 - Monoidal, monadic and first-class events  https://hackage.haskell.org/package/event-0.1.4 (DimitriSabadie)
07:43:12 <hexagoxel> is there any nice way to be Wall clean from ghc-7.6 to ghc-8.0 in regards to "Overlapping" stuff (without CPP)?
07:49:27 * hexagoxel searches all stackage packages and finds.. only pandoc, which uses CPP to conditionally add "{-# OVERLAPS #-}"
07:49:28 <hexagoxel> meh
07:49:32 <carter> hexagoxel: cpp is probably the simplest :)
07:52:34 <kr36> hi
07:54:34 <Benzi-Junior> is there a case where Enumerable a does not imply Ord a ?
07:55:16 <xa0> uncountable things?
07:55:24 <xa0> oh wait wrong way round nevermind
07:56:06 <Benzi-Junior> xa0: yea I almost put it the wrong way round in the question
07:57:21 <geekosaur> I don't think there are any examples in Prelude, but one could imagine a type which has multiple elements and no fixed ordering
07:58:11 <geekosaur> for example, a card gaame program supporting multiple games would have data Suit = Spade | Heat | Diamond | Club -- but the ordering may be different or even irrelevant depending on the game, so it cant be Ord
07:58:22 <geekosaur> *Heart
07:58:45 <Benzi-Junior> hmm 
07:58:51 <geekosaur> (the faces have the same problem as Ace could be lowest or highest, and at least one game has King as lowest!)
07:59:02 <hpc> geekosaur: in base there's a few things like that, and they seem to just take an arbitrary ordering
07:59:07 <hpc> https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#t:IOMode
07:59:20 <hpc> or derive it, rather
07:59:51 <Benzi-Junior> ye I would have thought
08:01:18 <Benzi-Junior> if you have Enumerable a then you can just derive an ordering by checking wich one appears first in enumerate a 
08:01:26 <puregreen_> or by using fromEnum
08:01:44 <puregreen> :t fromEnum
08:01:45 <lambdabot> Enum a => a -> Int
08:02:42 <geekosaur> well, you could define an ordering but it wouldn't be useful for much other than maybe debugging. you couldn't use it to implement game logic in the example I game
08:02:46 <geekosaur> *gave
08:02:51 <Benzi-Junior> just like you can order numbers both ascending and descending we "arbitrarily" choose to have the ascending ordering be the one used by (<=)
08:04:45 <mizu_no_oto_work> Benzi-Junior: sometimes your type might have a natural partial ordering, but not a natural ordering
08:04:58 <mizu_no_oto_work> yet you can still generate all values of that type
08:05:22 <Benzi-Junior> mizu_no_oto_work: even if it is Enumerable a ?
08:05:48 <lin> Hey all, is part 1 of https://wiki.haskell.org/Roll_your_own_IRC_bot working? I feel like I'm missing something dumb but it compiles and then freezes after printing nothing
08:06:13 <mizu_no_oto_work> Just to confirm, you're talking about https://hackage.haskell.org/package/enumerable-0.0.3/docs/Data-Enumerable.html, right?
08:06:29 <Benzi-Junior> lin: I tried it way back and wored then 
08:06:35 <Benzi-Junior> mizu_no_oto_work: yes 
08:06:51 <mizu_no_oto_work> Well, consider a deck of cards
08:07:27 <mizu_no_oto_work> You might have it where Spade 5 < Spade 9, but Spade 5 can't be compared to Heart 5
08:07:59 <mizu_no_oto_work> Yet you can easily create an Enumerable where first you generate the Spades, then the Hearts
08:08:04 <lin> Probably me being dumb, but a hello world is working - not even sure where to start debugging
08:08:34 <lin> I installed ghc, cabal-install, haddock,happy, alex, and haskell-network (on Arch)
08:08:43 <Benzi-Junior> mizu_no_oto_work: well sure but then you are arbitrarily choosing to have different sorts be incomparable 
08:09:34 <MichaelBurge> Benzi-Junior: I think the word 'naturally' is important. You can well-order any set.
08:10:09 <mizu_no_oto_work> For a less arbitrary example, consider the set of subsets of {x,y,z}
08:10:43 <mizu_no_oto_work> There's a natural partial ordering here, where s < t iff s is a proper subset of t
08:11:13 <mizu_no_oto_work> so {x} is less than {x,y}, but {y} and {x} can't be compared
08:11:26 <mizu_no_oto_work> https://en.wikipedia.org/wiki/Partially_ordered_set#/media/File:Hasse_diagram_of_powerset_of_3.svg
08:11:49 <mizu_no_oto_work> Yet you can easily generate all of the subsets of {x,y,z}
08:12:16 <Benzi-Junior> MichaelBurge: assuming the axiom of choice yes but for the haskell type classes don't implement that
08:12:26 <geekosaur> complex numbers. you have an ordering in either the real or imaginary part if the other part is held constant, but there is no ordering once both can vary
08:12:53 <mizu_no_oto_work> So you could implement some arbitrary Order, but it doesn't really mean anything
08:13:21 <geekosaur> (ordering is inherently 1-dimensional, but complex numbers are naturally represented as points in 2-space)
08:13:42 <Benzi-Junior> MichaelBurge: since the well ordering axiom implies that every type is an instance of Enumerable 
08:13:52 <MichaelBurge> geekosaur: Well, no ordering naturally compatible with the field axioms. You can find loads of orderings if you drop that constraint.
08:14:27 <geekosaur> sure. which as already mentioned is applicable to other cases as well; you can have an arbitrary ordering, but it
08:14:35 <geekosaur> 's not going toc orrespind to anything *useful*
08:14:41 <geekosaur> ...urgh typing
08:14:53 <m1dnight_> Is there an easy way to compile .lhs to .hs? (I want to change it to test hlint in emacs, and then possibly change it back)
08:15:18 <MichaelBurge> Benzi-Junior: Isn't that true? Every pure value is built up from a finite sequence of data constructors. So there are countably many pure values.
08:16:05 <geekosaur> (although even an arbitrary ordering can be somewhat useful; keys in a Map have to be orderable, but not all uses of Map-s require that that order correspond to anything in particular)
08:17:01 <Benzi-Junior> I think the conclusion is: although Enumerable a doesn't imply Ord a you could say that it does and give a uniform way of obtaining ordering from enumeration
08:17:20 <geekosaur> (...and if you do have that case then you might be better served by HashMap anyway)
08:17:29 <geekosaur> yeh.
08:17:42 <geekosaur> actually Haskell needs multiple ordering concepts instead of overloading Ord
08:18:28 <Benzi-Junior> lin: have you made sure that thing connects to a server ?
08:18:29 <geekosaur> (Double already breaks Ord. Try storing NaN in a Map sometime.)
08:18:39 <Benzi-Junior> lin: does it give you any output ?
08:18:43 <geekosaur> (and then getting stuff back out)
08:18:49 <lin> It gives me no output, BJ
08:19:02 <mizu_no_oto_work> ArbitraryOrdering and SensibleOrdering?
08:19:21 <geekosaur> partial orderings, total orderings...
08:19:42 <Benzi-Junior> lin: you haven't made any modification to the code from the wiki ?
08:20:15 <MichaelBurge> There's a function reallyUnsafePtrEquality# :: a -> a -> Bool. Is there a 'reallyUnsafeAddr# :: a -> Ptr'?
08:20:16 <lin> I tried it with no modification, and then changing the server to chat.freenode instread of irc.freenode (since that's how I connect with Irssi, and that works)
08:20:18 * Benzi-Junior Goes find the old IRCbot code he used
08:22:59 <geekosaur> MichaelBurge, I doubt it, since the act of boxing the a into a Ptr could itself render it invalid
08:23:10 <lin> I mean it should just be making a socket and printing stuff out, I thought
08:23:23 <Benzi-Junior> for some reason all of my programming files from a couple of installations ago are executable 
08:23:25 <geekosaur> sinc eit has to allocate the Ptr and that could trigger a garbage collect that moved the a
08:23:34 <geekosaur> Benzi-Junior, were you on Windows at the time?
08:23:49 <andromeda-galaxy> Any idea why threadscope on a program that uses ~1GB of ram would take 15.4GB of virtual memory (according to htop) and not even be done loading the execution profile?
08:23:55 <MichaelBurge> geekosaur: Let's say 'a -> Word8#' then.
08:23:59 <Benzi-Junior> geekosaur: no 
08:24:08 <MichaelBurge> Sorry, Word64
08:24:21 <merijn> andromeda-galaxy: How big is the execution profile?
08:24:26 <geekosaur> MichaelBurge, I think that's just unsafeCoerce#
08:24:36 <Benzi-Junior> geekosaur: oh wait these files might have been copied over to a windows partition at some point
08:24:38 <geekosaur> you're already in unsafe-land...
08:25:04 <MichaelBurge> geekosaur: Yeah that's probably it. I'm curious to see what a Data.Map does as its ordering changes from underneath it.
08:25:30 <geekosaur> as I suggested, just play with NaN-s in a Map Double a
08:25:31 <merijn> MichaelBurge: Return wrong results :p
08:25:41 <geekosaur> they break things in bizarre and sometimes entertaining ways
08:25:42 <Benzi-Junior> lin: I tried my version it worked I'm going to see what modifications I had made 
08:25:48 <geekosaur> and need no iother explicit unsafety
08:25:53 <lin> Thanks <3
08:26:20 <andromeda-galaxy> merijn: I can't check, that machine is swamped by threadscope. I was hoping someone knew what an "expected" value would be so that I could figure out how to make it smaller
08:26:38 <merijn> andromeda-galaxy: What I'd expect depends on the timeframe of the profile
08:26:42 <lin> Oh hell Benzi-Junior it's some ipv6 thing
08:26:51 <merijn> andromeda-galaxy: Is it like a few minutes? Hours?
08:27:03 <andromeda-galaxy> merijn: ~10 minutes
08:27:08 <lin> If I let it run long enough ipv6 times out and it connects
08:27:12 <Benzi-Junior> oh god I remember I allowed my bot to accept arbitrary haskell commands and executed the
08:27:20 <andromeda-galaxy> merijn: threadscope apparently just gave up loading the file, so I checked the size---992M
08:27:29 <geekosaur> MichaelBurge, Map is also one of the classic examples of why instances are global. You can actually hide two separate maps in a Map by flipping the sense of Ord when accessing each one
08:27:50 <lin> That sounds just a bit dangerous
08:28:04 <Benzi-Junior> because I was doing this for shits and giggles and it was only firing into a channel that I and a couple of my friends where one
08:28:13 <andromeda-galaxy> odd... it's not showing a loading dialog anymore, but it isn't showign the profile either, and it's still taking 16G of virtual ram (but apparently not allocating as badly)
08:28:52 <Benzi-Junior> lin: yes somebody asked it for [1..] 
08:29:13 <lin> Heh, of course
08:30:10 <Benzi-Junior> lin: it took me like 3 seconds to realize but it was to late it had flooded the memory and made the computer unresponsive
08:30:12 <MichaelBurge> geekosaur: Now, you're not supposed to have multiple instances. But nothing stops you from writing a few pointers in the implicit dictionary that gets passed around.
08:30:46 <Benzi-Junior> lin: well for one thing I don't use chat.freenode
08:31:03 <Benzi-Junior> lin: mine just uses irc.freenode
08:31:04 <lin> ulimit is your friend
08:32:53 <Boomerang> Benzi-Junior: I think irc.freenode is just and alias for chat.freenode (irc.freenode.net.	300	IN	CNAME	chat.freenode.net)
08:33:22 <Boomerang> *an alias
08:34:11 <lin> Hmm okay
08:35:31 <glguy> EvanR: I think that Ninjas still works. I haven't played it for a few months but last time I tried to build it the dependencies still resolved correctly
08:38:27 <Benzi-Junior> lin: nope works fine for me 
08:39:01 * hackagebot data-pprint 0.2.4.1 - Prettyprint and compare Data values  https://hackage.haskell.org/package/data-pprint-0.2.4.1 (lspitzner)
08:39:03 * hackagebot activehs-base 0.3.0.4 - Basic definitions for activehs  https://hackage.haskell.org/package/activehs-base-0.3.0.4 (lspitzner)
08:39:05 * hackagebot dia-base 0.1.1.4 - An EDSL for teaching Haskell with diagrams - data types  https://hackage.haskell.org/package/dia-base-0.1.1.4 (lspitzner)
08:39:07 * hackagebot dia-functions 0.2.1.5 - An EDSL for teaching Haskell with diagrams - functions  https://hackage.haskell.org/package/dia-functions-0.2.1.5 (lspitzner)
08:39:48 <lin> Well it should, I think my problem is I had no ipv6 dns server configured
08:40:27 <Pennyw95> Hi, can you help me? I want a function to keep track of the user's score while he gives answers to the questions in the list. I think foldM is the way to go, right? but I can't figure out how to also keep track of the question's position in the list (I usually do somelike like map (f) (zip myList [0,1..])
08:40:28 <Pennyw95> https://gist.github.com/DrBenway95/4e640ce343596f6c23fe4edf7f522da5
08:40:41 <Benzi-Junior> lin: probably something like that not to do with the code 
08:41:06 <lin> Yeah the code looks fine, very clean
08:42:03 <Benzi-Junior> lin: I just tried copying the code directly from the wiki to a new file and fired it up and it told me it's name and channel it was joining and things 
08:42:21 <Benzi-Junior> lin: followed by the splash message from freenode all jumbled up 
08:42:34 <lin> Yup I just gotta fix my networking on the box
08:42:52 <hea4iteauotae> is there a version of zip where i can specify one element and it will zip everything with just that one element?
08:43:22 <lyxia> zip (repeat myElement), or fmap ((,) myElement)
08:43:24 <hea4iteauotae> eg zip 3 [x,y,z] = [(3,x), (3,y), (3,z)]
08:43:29 <Pennyw95> map (\x -> (x,element)) list
08:43:37 <hea4iteauotae> ty for repeat i didnt know about that
08:43:51 <infandum> How can I tell stack to recompile everything? Not just load binaries or reuse already built ones?
08:45:22 <David__> stack clean
08:46:03 <andromeda-galaxy> merijn: And..... OOM killed!
08:46:15 <infandum> David__: Including dependencies
08:48:31 <MichaelBurge> geekosaur: Cancel that last thought. I don't think it actually makes sense to rewrite the function pointers in a typeclass dictionary at runtime.
08:49:32 <geekosaur> I admit to wondering about that... I think that for most types the typeclass dictionary is a pointer to something that's read-only
08:49:57 <MichaelBurge> geekosaur: Well, that's not a problem. You could always mprotect() the page to be writable.
09:00:11 <infandum> Like, when I do "stack install H", I get "H-0.8.0.0: using precompiled package", is it possible to NOT use a precompiled package for that?
09:00:27 <newcomer> now that do notation supports functors, what how does "do {fa; fb}" gets de-sugared to?
09:00:58 <lyxia> not a functory thing
09:01:00 <newcomer> I understand that "do {ma ; mb}" is sugar for ma >> mb
09:01:35 <bergmark> infandum: yes, add it as a local package or extra dep
09:01:52 <newcomer> lyxia, were you replying to me?
09:04:02 * hackagebot NoTrace 0.3.0.1 - Remove all the functions come from Debug.Trace after debugging  https://hackage.haskell.org/package/NoTrace-0.3.0.1 (CindyLinz)
09:04:31 <dolio> Ideally 'do x ; y' turns into 'x *> y'. But it seems to not do that yet.
09:05:24 <newcomer> dolio, what does it do now then?
09:05:36 <dolio> 'x >> y' still.
09:05:50 <dolio> It seems very finicky.
09:06:25 <dolio> 'do u <- x ; v <- y ; pure v' has an Applicative constraint.
09:06:40 <dolio> But 'do x ; v <- y ; pure v' is Monad.
09:06:50 <newcomer> dolio, doesn't x >> y needs both x and y be monads?
09:07:44 <dolio> Yes, it's missing some possibilities.
09:17:05 <infandum> bergmark: AHH! I didn't know it worked like that! Thank you!
09:19:03 * hackagebot jammittools 0.5.1 - Export sheet music and audio from Windows/Mac app Jammit  https://hackage.haskell.org/package/jammittools-0.5.1 (mtolly)
09:19:34 <alx741> guys is there any man page for cabal? i see an issue on github but don't know how did that end up
09:19:52 <dcoutts> alx741: as of cabal-1.24, yes.
09:20:03 <sm> yay
09:20:28 <alx741> dcoutts: oh, i'm using 1.22.9, that explains it, thanks! 
09:27:01 <andromeda-galaxy> In a default configuraiton (no special compile/rts opts that I know of) with a -threaded/-N8 build, would the gc pause all threads at once (esp. if all threads are running io using Control.Concurrent.ParallelIO.Global)?
09:27:48 <andromeda-galaxy> Also, would that explain a thread profile where all threads stop/start work synchronizedly for "long" intervals with about 50/50 thread/gc time (held up by gc on the longest thread), and then occasionally all threads pause for a lot longer (~0.25 seconds)?
09:29:03 * hackagebot hPDB 1.2.0.5 - Protein Databank file format library  https://hackage.haskell.org/package/hPDB-1.2.0.5 (MichalGajda)
09:29:05 * hackagebot Octree 0.5.4.3 - Simple unbalanced Octree for storing data about 3D points  https://hackage.haskell.org/package/Octree-0.5.4.3 (MichalGajda)
09:31:23 <NeverDie> How could I read the text file and put it into a list? http://lpaste.net/6999461795169566720
09:31:25 <NeverDie> I currently have that.
09:31:31 <andromeda-galaxy> And if all of this is the case, does anyone know of a good guide do reduce the reduced-parallelism caused by gc
09:31:33 <andromeda-galaxy> ?
09:33:07 <geekosaur> andromeda-galaxy, parallel gc should be the default and will stop all threads for what is supposed to be a short time. there are some runtime options (try "ghc +RTS --help") to tune it.
09:33:23 <andromeda-galaxy> geekosaur: thanks, I'll look into those more
09:33:26 <geekosaur> the non-parallel gc stops everything for the duration of the collection
09:33:42 <andromeda-galaxy> geekosaur:that makes sense...
09:34:07 <andromeda-galaxy> geekosaur: this is the result of looking into why a program that I parallelized to 8 threads from 1 only completes ~2 times faster, even though there are no obvious cases where the threads are working on each other
09:34:14 <tippenein> anyone have a hmac auth example using wreq?
09:34:18 <andromeda-galaxy> Do you have any other suggestions as to general strategies?
09:34:50 <geekosaur> no, sorry. I know people have played around with it but have no pointers
09:35:00 <andromeda-galaxy> geekosaur: htop always shows a high load average while running it, which I thought meant that all threads were being utilizead, so I tried to threadscope a short part of the problem, and am now trying to figure out what the result means/how to fix it
09:35:17 <andromeda-galaxy> geekosaur: ah well, I'll just try to play around a bit....
09:35:32 <andromeda-galaxy> Anyone else with experience in doing parallely things (especially with io) in haskell?
09:36:36 <c_wraith> we tend to distinguish between parallel and concurrent
09:37:00 <c_wraith> most people don't but the distinction is actually useful in Haskell. 
09:37:32 <c_wraith> since you mentioned IO, I think you're talking about what we generally call concurrency, not parallelism 
09:37:43 <andromeda-galaxy> c_wraith: yeah, I know. in this case stuff really is running in paralell (8 HECs)
09:38:10 <andromeda-galaxy> (wait, unless I got it backwards *again*)...?
09:38:16 <c_wraith> ok, but you're still likely talking about concurrent programming. 
09:38:28 <c_wraith> no, sounds like you have it right. 
09:38:35 <andromeda-galaxy> c_wraith: great!
09:38:37 <andromeda-galaxy> c
09:39:02 <andromeda-galaxy> the idea here is that I need to do a bunch of file I/O to calculate things about a billion different directories, so I use a thread pool to try to calculate about 8 directories in parallel
09:39:07 <andromeda-galaxy> the threads don't need to talk to each other
09:39:23 <andromeda-galaxy> but the speedup is less than 2x over serially doing it, which I don't really understand
09:39:31 <c_wraith> parallel meaning actually simultaneous execution, concurrent being a programming model that keeps different threads of execution all together. 
09:39:53 <andromeda-galaxy> c_wraith: right, that's what a thought.
09:40:13 <c_wraith> yeah, that's a concurrent programming problem, even though it involves simultaneous execution 
09:41:07 <c_wraith> is it possible laziness is biting you? 
09:41:22 <andromeda-galaxy> c_wraith: I suppose that it's remotely possible...
09:41:28 <c_wraith> ie, sending thanks between threads? 
09:41:33 <c_wraith> *thunks
09:41:48 <andromeda-galaxy> c_wraith: on each thread I'm reading a whole bunch of files and putting a number of results in a hash table, then reading some more files and looking things up in the hashtable
09:41:56 <andromeda-galaxy> I haven't done any laziness/strictness annotations
09:42:34 <andromeda-galaxy> (and interspersed in there is a little IO to actually get the correct files in the right places, but that shouldn't be the bulk of the execution time)
09:42:38 <c_wraith> I'd make sure the hash table is fully evaluated in any thread that updates it before reinserting into the shared reference 
09:42:50 <andromeda-galaxy> c_wraith: the hashtables are created per-thread
09:43:27 <c_wraith> is there a final step where the tables are consolidated? 
09:43:35 <andromeda-galaxy> nope, just a number returned from each thread
09:43:47 <c_wraith> heh. that could still do it. 
09:43:57 <c_wraith> if that number is a thunk. 
09:44:04 * hackagebot multistate 0.7.1.1 - like mtl's ReaderT / WriterT / StateT, but more than one  contained value/type.  https://hackage.haskell.org/package/multistate-0.7.1.1 (lspitzner)
09:44:17 <andromeda-galaxy> ah, then thread 1 just ends up evaluating everything at the end? 
09:44:25 <c_wraith> yeah
09:44:42 <andromeda-galaxy> hmm... let me think about that for a minute
09:44:54 <c_wraith> that sort of thing is a common cause of the symptoms you described. 
09:45:07 <c_wraith> not the only possible cause, but it's one to consider. 
09:45:12 <andromeda-galaxy> each thread outputs some status updates, and I do see big pauses between the updates during the "reading lots of files & inserting them" phase, so *some* work must be being done...
09:45:56 <andromeda-galaxy> c_wraith: should I try using {-# LANGUAGE Strict #-}/GHC 8?
09:46:30 <c_wraith> only if you're never depending on laziness 
09:46:48 <Rembane> andromeda-galaxy: Can you change the hash table to a strict one?
09:46:52 <geekosaur> -XStrict is not a general purpose hammer
09:47:24 <andromeda-galaxy> Rembane: I'm using the "hashtables" library, I don't recall seeing a strict hashtable wrapper...
09:47:30 <andromeda-galaxy> geekosaur: I had a feeling that was coming...
09:47:32 <c_wraith> the hammer I'd apply for debugging is more like deepseq/NFData
09:48:26 <andromeda-galaxy> c_wraith: yeah but then I need nfdata instances for cuckoo hashtables in the ST monad that directly manipulate raw STarrays...
09:49:24 <andromeda-galaxy> geekosaur: any more guidelines for where/when to use -XStrict?
09:50:01 <geekosaur> tbh I'm not sure when you'd use it. I just see that it is incompatible with an awful lot of code that expects laziness
09:50:48 <andromeda-galaxy> geekosaur: true enough.
09:52:31 <Rembane> andromeda-galaxy: Hm. Lets see, I think Data.Map has a strict implementation, but I don't know if it does what you want in other regards.
09:53:06 <Rembane> andromeda-galaxy: This one: https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map-Strict.html
09:53:12 <c_wraith> this all could be a wild goose chase, too. don't make changes that are too big. just to test it. :) 
09:55:14 <andromeda-galaxy> Rembane: Data-Map has horrible asymptotics for what I'm doing, though.  -thanks for the suggestion anyway :)
09:55:27 <andromeda-galaxy> c_wraith: that's why i was hoping that i could just hit the -XStrict hammer and see what happenned
09:57:58 <andromeda-galaxy> it doesn't help that looking at the thread activity profiles for a small segment of my workload in threadscope uses *all* of my ram!
10:06:11 <andromeda-galaxy> for anyone still curious: GC was definitely part of it
10:06:32 <andromeda-galaxy> I haven't tried strictness yte, but wall clock time went from 238 seconds to 110 seconds with these options:
10:07:00 <andromeda-galaxy> +RTS -N8 -A64m -n4m -qb -H10G -I0 -s -qa -ls
10:07:06 <andromeda-galaxy> (the old run used +RTS -N8 -ls)
10:07:09 <sm> andromeda-galaxy: nice!
10:08:18 <the193rd> *join*
10:09:38 <netsu_> Hello there! It's pleasure to become a part of Haskell community!
10:11:10 <netsu_> I have a question. Suppose, I have ~/.ghc/ghc.conf like this http://nixpaste.lbr.uno/r2dRKtqH
10:11:28 <andromeda-galaxy> sm: thanks!
10:11:32 <andromeda-galaxy> I need more ram now, apparently
10:11:35 <netsu_> And I work on project via 'stack --nix ghci'
10:12:21 <netsu_> Problem is: I have no access to required for ghci pretty-printing libraries in stack sandbox
10:14:04 <andromeda-galaxy> I also need to find out which options to tweak more
10:14:07 <netsu_> what is most convenient way to load required for development-only libraries into stack sandbox (which I don't want to see in production)?
10:14:56 <sm> netsu_: welcome! what about a .ghci in your project folder
10:15:56 <netsu_> sm: hi! Well, I have no .ghci in project. Should I?
10:16:38 <geekosaur> I don't think that helps unless the idea is to just disable the hoogle stuff that uses HsColour
10:16:49 <sm> it's optional. But you can just stack install EXTRAPKG, then stack ghci --package EXTRAPKG
10:19:53 <andromeda-galaxy> Also, any idea why a process running with 8 threads would show up 34 times in htop?
10:21:26 <netsu_> sm: but goal is to have ghci with those packages for main project sources. Will it be available then if I run 'stack --nix ghci' for project target?
10:22:41 <sm> I don't know stack --nix at all, and I'm not understanding you - sorry
10:23:34 <sm> try it perhaps
10:23:36 <netsu_> maybe there's should be some special section in stack.yml like some-development-stuff: bla-bla...
10:23:39 <joobus> how can I print the type of a variable from haskell code (not in a repl)?
10:24:01 <sm> you can also have a separate stack-dev.yaml
10:27:15 <Rembane> andromeda-galaxy: Roger that. :)
10:27:19 <netsu_> sm: I just need hscolour and other libraries for ghci. And use ghci with customized behavior to work with project via stack ghci.
10:27:54 <geekosaur> joobus, in general you can't; types don't exist at runtime
10:28:50 <geekosaur> there is Data.Typeable and Data.Data, but those attach extra information to values with specific type contexts so they can carry the type information around
10:28:57 <Rembane> andromeda-galaxy: Does it show up 34 times with 34 different pids?
10:28:59 <netsu_> sm: hm, separate stack-dev.yaml is nice idea, better than install it by hand. But still not so DRY... Should be better solution. It should be so usual workflow...
10:30:23 <tenniscp25> if my use of the free monad involves a lot of querying and updating the database, could you please suggest how i should write my test interpreter?
10:30:42 <lpaste> joobus pasted “Shell test” at http://lpaste.net/164458
10:31:07 <joobus> I don't know why I'm getting a error in that paste.  Can someone help me out?
10:31:26 <joobus> geekosaur: thanks :)
10:32:35 <geekosaur> you can't get the output just by having a pattern, you need to specify what you want to capture
10:32:51 <geekosaur> also "res" there is not a string, it would be a Handle for you to read
10:33:10 <joobus> but Handle implements show
10:34:05 <lpaste> geekosaur annotated “Shell test” with “Shell test (annotation)” at http://lpaste.net/164458#a164459
10:35:22 <sm> #haskell-ide is open for business again, all welcome. (tips & support for haskell IDEs/related tools)
10:35:29 <joobus> from the docs: "the functions proc and shell are supplied that fill in the fields with default values which can be overriden as needed."
10:35:39 <joobus> I would have thought stdout was the default
10:38:40 <geekosaur> the default is for things to go where they normally would: the same place the invoking program's stdin/stdout/stderr do
10:39:01 <geekosaur> if you were planning to write to it instead, would you suddenly want the default to be std_in=CreatePipe?
10:39:24 <joobus> guess not.  thanks geekosaur 
10:39:45 <geekosaur> or maybe to always create both and force you to deal with them? (note that doing this and not dealing with them gets you the same "open3" problem well known from perl/python/ruby/etc.)
10:47:20 <Myrl-saki> So, I gave it some though.
10:47:58 <Myrl-saki> And I realized something. Why do Haskellers mostly put recursion in the inner-most rather than the outer-most?
10:48:13 <Myrl-saki> sum (x:xs) = x + sum xs
10:48:42 <Myrl-saki> As opposed to other languages where you normally do `sum n (x:xs) = sum (n + x) xs`
10:49:26 <Rembane> Myrl-saki: The other languages approach looks messier imo. More charactesr and mixes recursion and what each recursion step actually does.
10:49:41 <Rembane> Myrl-saki: And we get another parameter.
10:49:47 <Myrl-saki> I'm guessing it has something to do with Haskell's laziness, but I can't quite put my finger on it.
10:49:59 <Myrl-saki> Rembane: Wrapper functions, of course.
10:50:06 <srhb> Myrl-saki: Tail recursion doesn't matter in Haskell
10:50:17 <srhb> Myrl-saki: Well, not in the same way as it does in others.
10:50:34 <srhb> Myrl-saki: In a lot of other languages you _need_ to be able to do TCO to avoid blowing the stack.
10:50:35 <Myrl-saki> srhb: From what I understand, tail recursion works better if it's in the innermost call.
10:50:43 <Myrl-saki> In Haskell.
10:50:53 <srhb> Myrl-saki: tail recursion is irrelevant, really.
10:50:53 <geekosaur> different thunk build-up, I think
10:51:05 <Myrl-saki> geekosaur: Right. That's what I'm thinking of.
10:51:09 <geekosaur> that's the only way in which "tail recursion" is relevant here
10:51:26 <Myrl-saki> I've seen some people complain in stackoverflow about how their "tail recursive function is not working well on Haskell"
10:51:29 <Rembane> Does WHNF have something to do with it?
10:52:04 <Myrl-saki> srhb: Yeah, but I may be wrong, but in Haskell, the first version would work... "faster"
10:52:23 <srhb> Myrl-saki: If you replace + in your example with : this might be more obvioous, as it can be productive immediately
10:52:30 <Myrl-saki> srhb: Right.
10:52:35 <Myrl-saki> srhb: That's also what I was thinking of.
10:53:06 <Myrl-saki> srhb: Maybe that's why, actually. To decrease the "context switching"
10:53:28 <Myrl-saki> srhb: Like, stick to one style rather than alternating.
10:53:28 <srhb> I don't know what you mean by that.
10:53:28 <scshunt> consider map
10:53:37 <scshunt> map f (x:xs) = f x : map f xs
10:53:49 <Myrl-saki> srhb: Borrowed term. http://www.joelonsoftware.com/articles/fog0000000022.html
10:54:09 <Myrl-saki> scshunt: Right.
10:54:13 <srhb> Myrl-saki: I doubt that's relevant.
10:54:27 <scshunt> if you tried to write this in a tail-recursive way, you'd end up forcing the entire list, because you need to evaluate the recursive call in order to get any values back
10:54:33 <srhb> Myrl-saki: (you could easily imagine a co-recursive function that is still productive due to laziness in each data field)
10:54:42 <scshunt> (not even accounting for the performance issues you get from building up lists repeatedly)
10:54:49 <Myrl-saki> srhb: productive?
10:54:58 <scshunt> but since Haksell is lazy, it doesn't need to force the entire list. It just needs however many elements are needed in context
10:55:00 <srhb> Myrl-saki: take 1 $ repeat 42
10:55:16 <johnw> Myrl-saki: productivity in this context means that each iteration builds up more structure; that the function always "does something", and never becomes a no-op
10:55:41 <Myrl-saki> Hmmm
10:56:27 <Myrl-saki> srhb: I'm making a guess that `repeat 42` is the productive part?
10:56:42 <johnw> it's an infinite loop calling "cons", which makes it productive
10:56:45 <srhb> Myrl-saki: It's productive in that it isn't just an infinite loop :-)
10:56:46 <johnw> because at each iteration, cons is called
10:56:49 <scshunt> Myrl-saki: what he means is that you don't need to force the entire list to get values
10:56:56 <Myrl-saki> scshunt: Yeah.
10:56:59 <Myrl-saki> I get that part.
10:57:18 <scshunt> a better example might be take 1 $ map (+1) $ repeat 42. map here is still productive even on an infinite list
10:57:26 <scshunt> since you can get some values out
10:57:47 <Myrl-saki> Hmmm
10:58:09 <johnw> Myrl-saki: part of the complexity here is that co-recursion really is a different thing from recursion, but in Haskell they are both represented by the same types and functions
10:58:14 <Myrl-saki> scshunt: So, it will always be able to generate a value?
10:58:31 <Myrl-saki> Oh. Right.
10:58:50 <Myrl-saki> johnw: Corecursion is when you build something up rather than converge(?) to a value, right?
10:59:08 * hackagebot reflex-jsx 0.1.0.0 - Use jsx-like syntax in Reflex  https://hackage.haskell.org/package/reflex-jsx-0.1.0.0 (dackerman)
10:59:53 <johnw> Myrl-saki: yes, pretty much
11:01:45 <Myrl-saki> Hmmm
11:02:24 <Myrl-saki> How about the thunk buildup?
11:02:50 <johnw> that often means you're strict in one way, but not in another, and the two are not interacting well
11:03:06 <Myrl-saki> I mean. In recursion.
11:03:20 <Myrl-saki> Putting the recursion in the innermost vs the outermost. How does the thunk buildup work
11:03:35 <johnw> if the recursion is done right, there is no thunk buildup
11:04:05 <johnw> you are either computing the answer one piece at a time, or you are computing it all at once without thunks at all
11:04:25 <Myrl-saki> Right.
11:04:41 <Myrl-saki> Thanks.
11:06:34 <dmj`> how do I make a custom tag in blaze
11:07:39 <dmj`> instead of using the 'p' function, I'd want something like, makeElement :: Tag -> [Attribute] -> [Element] -> Element, p = makeElement (toTag "p") [] [] -> "<p></p>"
11:08:23 <dmj`> blaze doesn't expose the internal tree it uses
11:08:25 <dmj`> afaict
11:14:07 <puregreen> dmj`: http://hackage.haskell.org/package/blaze-markup-0.7.0.3/docs/Text-Blaze-Internal.html#t:MarkupM
11:14:09 * hackagebot xpathdsv 0.1.0.0 - Command line tool to extract DSV data from HTML and XML with XPATH expressions  https://hackage.haskell.org/package/xpathdsv-0.1.0.0 (DanielChoi)
11:14:11 * hackagebot table-layout 0.6.0.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.6.0.0 (muesli4)
11:14:30 <puregreen> dmj`: in particular, it seems you can use customParent
11:15:36 <dmj`> puregreen: thank you :) just saw that
11:19:25 <bbear> Is there a Qt binding for Haskell ?
11:20:14 <hpc> there's one but it's rather low-level iirc
11:28:34 <DangerousDave> Hello, can somomne explain to me the following example? : http://pastebin.com/2k0smy39 . The thing that I didn't understood is how this all thing is not circular and when p changes. Thank you!
11:30:04 <DangerousDave> well those are some other relevant loc http://pastebin.com/yzuSADX3
11:30:21 <Lothar2k> http://espedito.homepc.it/ onehostx...)
11:33:58 <muesli4> DangerousDave: When does p change? I don't understand your question.
11:34:24 <dfeuer> Anyone here really good at polyvariadic functions? I have trouble wrapping my mind around them and I'm trying to write one.
11:34:51 <johnw> DangerousDave: it keeps parsing until "v <- p" fails
11:35:34 <dfeuer> In fact, I'm trying to write a somewhat weird/complicated one that may or may not be possible.
11:36:00 <dfeuer> Test.QuickCheck.Function offers a type  Fun x y representing x -> y, but with nice instances and things.
11:36:40 <dfeuer> For functions with multiple arguments, the easy thing currently seems to be to use  Fun (x,y,z) w  and then curry manually.
11:37:25 <johnw> dfeuer: I'm using almost the exact same trick in Coq at the moment
11:37:59 <DangerousDave> muesli4
11:38:11 <dfeuer> I'm wondering if there's some nicer way. One vague notion is a poly-kinded type family FunN that takes any number of arguments, but I don't know if that can work. 
11:38:22 <DangerousDave> Ill tell you what, it seems like this code will run infinitly
11:38:32 <johnw> DangerousDave: but it won't
11:38:44 <DangerousDave> I don't understand why
11:38:45 <muesli4> DangerousDave: I can't see why.
11:38:45 <johnw> DangerousDave: at some point, 'p' will fail to parse its input
11:38:50 <dfeuer> Another vague notion is a sort of generic curry that works on things that look, maybe, like (((a,b),c),d)
11:38:55 <johnw> these are parsers, not invariant values
11:38:56 <dfeuer> But I don't know how to do this stuff.
11:39:08 <johnw> dfeuer: you could use hlists
11:39:11 <dfeuer> johnw, you're doing what exactly?
11:39:12 <muesli4> DangerousDave: Maybe the error is in another piece of your code?
11:39:39 <DangerousDave> museli4: the code works, I just don't understand why
11:39:41 <johnw> dfeuer: I'm working with a type { cod : Type & { dom : list Type & funType dom cod } }
11:39:49 <johnw> as a way of generalizing over function of N arguments
11:39:57 <dfeuer> johnw, sorry, I don't know Coq syntax at all.
11:40:13 <johnw> so, Fun in your case would be a type-level recursive function
11:40:34 <johnw> type family Fun dom cod => Fun (x :: xs) ys  = x -> Fun xs ys.
11:40:35 <johnw> etc.
11:40:57 <dfeuer> johnw that doesn't parse.
11:41:07 <johnw> one sec, I'll write the code
11:41:13 <dfeuer> :D
11:41:18 <dfeuer> Thanks!
11:41:33 <dfeuer> And if I use it, how should I spell your name?
11:41:43 <DangerousDave> johnw: When will the parser be changed? I undestand that 'v' will became the first value that is parsed in case that the parser is parsing char by char, but I don't understand why Parser.many p will not run for ever over the same char
11:41:44 <kr36> hi
11:41:52 <dfeuer> [and I assume you don't mind such use for open source?]
11:42:07 <geekosaur> DangerousDave, because parsers maintain within them an input position that gets updated implicitly
11:42:08 <johnw> not at all
11:42:20 <geekosaur> (they're like State monads)
11:42:47 <johnw> dfeuer: https://gist.github.com/8c41e559e4813f1d1c6320dfa7d48457
11:42:50 <dfeuer> Just trying to put together a pull request for Test.QuickCheck.Function, because I've been finding the manual currying painful.
11:43:03 <DangerousDave> I implemented the >>= method in a way that I dont see how p is changing.
11:43:04 <muesli4> DangerousDave: Maybe you should try evaluating it by hand on a piece of input to understand how it works.
11:43:23 <johnw> dfeuer: you can't really attach instances to these, so you'll need some correspondence wit QuickCheck's machinery
11:43:52 <muesli4> DangerousDave: Nothing changes, just insert definitions and see what the result is.
11:44:41 <sphinxo> So i'm trying to do type level predicates ( a la https://gist.github.com/hodzanassredin/1415832 ) with type families
11:45:13 <dfeuer> johnw, hrm.... I need to be able to deal with QuickCheck's Fun type, I think, producing some sort of applyN function. Unless you think it should really be embedded in there.
11:45:19 <sphinxo> I've got something like this: http://lpaste.net/2202509648009887744
11:45:20 <dfeuer> Er...
11:45:23 <dfeuer> Hrmmm...
11:45:34 <sphinxo> Kind of two approaches
11:45:38 <dfeuer> I may see what you mean?
11:45:48 <dfeuer> But I may not.
11:45:49 <glguy> DangerousDave: p isn't changing, it's the same parser the whole time. It's a parser, not the parsed thing
11:46:00 <glguy> let p = anyChar :: Parser Char in parseTest (p >> p >> p) "abc"
11:46:00 <glguy> 'c'
11:46:17 <sphinxo> Could anyone provide me with some feedback/point me in the right direction? 
11:46:24 <glguy> in that case p parsed an 'a', a 'b', and a 'c'
11:46:53 <DangerousDave> glguy: But after I have parsed somthing I get (parsed, unparsed) and I bind it by >>= to the next parser don't I?
11:47:08 <johnw> dfeuer: let me try establishing a conversion
11:47:13 <dfeuer> johnw, QuickCheck can give us a Fun a b for Arbitrary a and b, or a Fun a (Fun b c), or a Fun (a, b) c, etc. I want to turn what it gives me into a function.
11:47:14 <glguy> DangerousDave: you do, and it binds to some new name, like 
11:47:15 <glguy> v
11:47:25 <glguy> but it doesn't affect p. p stays the same as it was
11:47:25 <DangerousDave> yea, as I thought
11:47:37 <DangerousDave> So how isn't it infinity
11:47:42 <DangerousDave> what does change
11:47:45 <DangerousDave> the input?
11:47:50 <glguy> the parser state
11:48:04 <DangerousDave> but p is the parser
11:48:07 <DangerousDave> T_T
11:48:07 <dfeuer> johnw, although I suppose it mightn't be *horrible* to build a whole parallel implementation for n-ary functions.
11:48:13 <glguy> DangerousDave: there's no input in a parser
11:48:20 <glguy> the input is outside the parser
11:48:21 <dfeuer> The main point is to try to make the interface "nice".
11:49:03 <pikajude> hi, I want to run a bunch of async operations in parallel to fill out keys for a Map, but I don't want to start an operation if a specific key is already being fulfilled
11:49:05 <glguy> DangerousDave: the input string is managed by the thing advancing the parser, the run function for your parser
11:49:07 <pikajude> what's the best way to do that?
11:49:17 <pikajude> should I have an MVar (Map Key (MVar Value))?
11:49:28 <glguy> the parser 'p' is just an instruction to that outside process
11:49:42 <glguy> in my case parseTest was managing the input string
11:50:20 <DangerousDave> what is "the thing", you got my state of mind when you named it
11:50:21 <glguy> p just takes some input token list and produces an output and a modified token list
11:51:01 <DangerousDave> ohhhh
11:51:17 <DangerousDave> I understand, so lets say item = Parser (\inp -> case inp of
11:51:17 <DangerousDave>                [] -> []
11:51:18 <DangerousDave>                (x:xs) -> [(x,xs)])
11:51:31 <DangerousDave> is kind of "manger"?
11:52:05 <glguy> so in your parser notice that there's no input string contained, just a function
12:02:27 <sphinxo> So i'm trying to do type level predicates similar to https://gist.github.com/hodzanassredin/1415832
12:02:31 <sphinxo> but with type families
12:02:59 <sphinxo> Any ideas? - i've got some ideas here: http://lpaste.net/2202509648009887744
12:04:17 <johnw> dfeuer: meh, I'm defeated by my inability to translate what I'd write in Coq into GHC type hackery
12:05:59 <johnw> dfeuer: I can't promote GADTs to the kind level :(
12:06:09 <DangerousDave> item = Parser (\inp -> case inp of
12:06:09 <DangerousDave>                [] -> []
12:06:32 <dfeuer> johnw, that's sad. Do you think there's a way if I dig deeper into QuickCheck?
12:06:50 <johnw> not sure; this Function type class is promising
12:07:06 <dfeuer> I'm not tied to any particular API; just want something that will be easy to use and clear to read.
12:07:32 <dfeuer> If it doesn't give utterly horrifying type errors, that would be a plus.
12:08:02 <johnw> can you show me an example of what you'd _want_ to write?
12:08:06 <johnw> maybe I'm barking up the wrong tree
12:10:15 <dfeuer> johnw, well... I'd like to by able to have QuickCheck hand me *something* called "fun", and then write a property  foo fun a b c = blah (apply fun a b c)
12:11:02 <dfeuer> Where fun is either Fun blobOfABC, or Fun a (Fun b c), or *something*.
12:11:19 <johnw> i see
12:11:21 <Ohso_> Is there a way to simplfy having multiple guards that need to check some of the same conditions as previous ones?  Example here: http://pastebin.com/JpBfMt2Q
12:11:26 <dfeuer> The blob approach strikes me as more promising for avoiding overlap.
12:11:30 <dfeuer> But I don't really know.
12:11:52 <dfeuer> If the type signature for the property can be clear too, that would be lovely.
12:12:15 <johnw> dfeuer: I think I'll bow out at this point, then
12:12:21 <johnw> dodging the snipe
12:12:24 <dfeuer> johnw, what'd I do wrong?
12:12:34 <dfeuer> I wasn't sniping at you!
12:12:34 <johnw> you invoked "this is for convenience" :)
12:13:06 <dfeuer> I just know that the ideas I've thought of thus far generally would give horrifying-looking type signatures even if I could make them work!
12:13:22 <Ohso_> conveni
12:13:23 <johnw> and I guess you've looked at how the printf code does variadics?
12:13:29 <dfeuer> johnw, well, without convenience, I can just write apply2, apply3, apply4, ....
12:13:30 <Ohso_> oops
12:14:03 <dfeuer> Yes, I have. But variadic stuff still always confuses the heck out of me every single time.
12:14:11 <dfeuer> *polyvariadic
12:19:12 * hackagebot traildb 0.1.0.0 - TrailDB bindings for Haskell  https://hackage.haskell.org/package/traildb-0.1.0.0 (Adeon)
12:19:49 <johnw> dfeuer: so, printf stuff uses a type class to achieve the trick
12:19:56 <dfeuer> Right.
12:20:16 <dfeuer> I guess I'll look again.
12:20:29 <dfeuer> But ... hrmm
12:20:58 <johnw> dfeuer: there's also https://hackage.haskell.org/package/safe-printf-0.1.0.0/docs/Text-Printf-Safe-Core.html
12:21:07 <johnw> which uses more modern principle, like type familias and GADTs
12:21:44 <dfeuer> Is that overkill?
12:21:55 <johnw> dunno
12:21:59 <johnw> I bet the type errors are better
12:34:12 * hackagebot texmath 0.8.6.3 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.6.3 (JohnMacFarlane)
13:08:07 <nitrix> I never have the instinct of "oh this could be a GADTs".
13:08:27 <nitrix> I always read on GADT to remind me, then I dig through the code to update those.
13:08:37 <nitrix> Any suggestions ;-;
13:09:44 <nitrix> I end up with rank2 types mess.
13:12:21 <benzrf> hey, any TH buffs here?
13:12:26 <benzrf> is there a notation for $(something [| ...stuff here... |])?
13:12:28 <benzrf> like calling a lisp-style macro
13:13:23 <nitrix> benzrf: It'd defeat the goal.
13:13:54 <benzrf> how so?
13:14:23 <nitrix> It has to be identifyable easily as template code.
13:14:26 <mgsloan> In this https://hackage.haskell.org/package/th-utilities-0.1.1.0/docs/TH-Derive.html I take that pattern even further XD, to $($(something [| ... stuff ... ||]))
13:14:36 <benzrf> well, yes - i was just wondering if there was a special notation for it
13:15:01 <benzrf> like how there is for quasiquoters, instead of just $(qq "... stuff ...")
13:15:03 <mgsloan> quasi-quotes almost give you that, but then you have to have your own haskell parser and such and it gets really messy
13:15:08 <benzrf> right
13:15:51 <mgsloan> I'd really like to be able to have an alias for $($(derive [| ... |])) but oh well
13:15:54 <nitrix> I'm not a huge fan of TH so I have troubles finding any sane recommendation.
13:16:00 <benzrf> haha
13:16:08 <benzrf> i dont have a legitimate use case tbh
13:16:38 <nitrix> I think if you're really stuck and comitting to use TH for large code generation, you probably want it to be as obvious and explicit as possible.
13:16:53 <nitrix> Or so, I think. That's without using it for anything serious.
13:17:06 <mgsloan> I really like TH.  Sure, for expressions, functions and typeclasses make it so you don't need it very much, and the semantics there are cleaner 
13:17:20 <mgsloan> But for generating boilerplate instances and data declarations and such, it rocks
13:17:41 <Tehnix> I think if you're really stuck and comitting to use TH for large code generation, you probably want it to be as obvious and explicit as possible.
13:17:42 <nitrix> I like how lens uses them.
13:17:48 <benzrf> hmm - is there a way to quote expressions such that local variables show up as variables, rather than being lifted
13:18:22 <mgsloan> benzrf: The capture would need to be within the quote
13:18:24 <benzrf> wait hold on... nvm...?
13:18:35 <mgsloan> Alternatively, $(return (mkName "x")) in the quote
13:18:46 <benzrf> yeesh
13:18:59 <mgsloan> Yeah, TH AST quotes aren't very good
13:19:12 <mgsloan> I've done a lot of TH, I usually just build the ASTs directly
13:19:34 <mgsloan> because I always end up reaching beyond the extents of the power of the AST quotes 
13:19:55 <mgsloan> I worked on some replacement quoters for a while (in TH of course) https://github.com/mgsloan/quasi-extras
13:19:56 <benzrf> well again i dont have an real use case - i just wanted to do a shitty hack for fun
13:20:16 <mgsloan> Need to get back to that, but it's really just shaving yaks so it will probably be a while
13:22:01 --- mode: ChanServ set +o mgsloan
13:22:40 <mgsloan> POWER OVERWHELMING
13:22:47 <shapr> :-)
13:22:51 * mgsloan has no idea why he's op
13:23:19 <puregreen> maybe knowing TH makes one qualified to be an OP?
13:23:25 <shapr> must be
13:24:24 --- mode: ChanServ set -o mgsloan
13:29:06 <johnw> at the very least, an OpQ
13:29:25 <shapr> ha
13:30:07 <Tehnix> at the very least, an OpQ
13:30:36 <benzrf> hmm
13:30:41 <benzrf> i've used coq much more than haskell lately
13:30:54 <puregreen> Tehnix: are you a bot?
13:31:03 <benzrf> and i keep trying to think of forall'd variables as ordinary arguments :v
13:34:25 <Hafydd> at the very least, an QpO
13:35:17 <lin> at the very least, an QpO
13:38:23 <FarbrorAlBot> Free web host accounts at http://webgerencie.com.br/billing/xbilling/
13:38:23 <FarbrorAlBot> limited account go fast http://webgerencie.com.br/billing/xbilling/
13:53:58 <Tehnix> puregreen: no?
13:54:09 <Tehnix> Just connecting via Slack
13:54:50 <puregreen> Tehnix: it's just that you copied nitrix's message verbatim and then also copied johnw's message and it seemed suspicious
13:55:05 <puregreen> okay, nevermind then, sorry
13:56:18 <Tehnix> puregreen: that's definitely not supposed to happen :O I'm using sameroom to connect, I'll try and check what is up
13:59:16 * hackagebot traildb 0.1.0.1 - TrailDB bindings for Haskell  https://hackage.haskell.org/package/traildb-0.1.0.1 (Adeon)
14:14:16 * hackagebot ilist 0.2.0.0 - Optimised list functions for doing index-related things  https://hackage.haskell.org/package/ilist-0.2.0.0 (Artyom)
14:19:06 <rfw> is there a builder monad for fgl graphs? or is the usual way to do it runState?
14:29:17 * hackagebot buffer-builder 0.2.4.3 - Library for efficiently building up buffers, one piece at a time  https://hackage.haskell.org/package/buffer-builder-0.2.4.3 (chadaustin)
14:40:57 <benzrf> MWAHAHAHAHAHA http://lpaste.net/164485
14:42:32 <jle`> haha
14:42:42 <benzrf> bbiab
14:59:20 <shapr> benjamin1rom: oh hai
15:13:33 * nitrix stabs sm with an email.
15:14:32 <Sk3letor> ooh, there is a channel for "haskell"
15:15:12 <Clint> "yes"
15:15:25 <Sk3letor> too bad though but this channel not for me 
15:15:56 <nitrix> Are you trying to learn Haskell?
15:16:03 <sm> argh!
15:16:08 <Sk3letor> trying finding my place in gamedev community :3  im unity3d user but im banned from #unity3d
15:16:40 <nitrix> Sk3letor: That's great, but we cannot unban you from #unity3d. You should see with them.
15:16:44 <Sk3letor> this channel's name popout when I was trying googling new channels.
15:16:45 <maerwald> :o
15:17:13 <Sk3letor> nitrix: how you " see " anyone there if you are banned from there? I dont even remember the ops there cause they arent even showed up.
15:18:08 <nitrix> /msg ChanServ access #unity3d list
15:18:29 <newcomer> can <*> be defined using fmap and pure?
15:18:30 <Sk3letor> I tried once talk somebody there but noone respoded.
15:19:00 <Sk3letor> but I bet the most hating users there would be that Tenebrous or ncarter.
15:19:01 <nitrix> Sk3letor: This channel is about the programming language Haskell. We can only really help you with matters related to Haskell.
15:19:09 <marcx> "Gun that killed Trayvon Martin 'makes $250,000 for Zimmerman'"
15:19:15 <ertes> newcomer: nope…  fmap and pure can't combine two F-values into one
15:19:22 <Sk3letor> nitrix: how much its diffrent from C# ?
15:19:29 <kadoban> newcomer: No, that'd be nice though.
15:19:47 <nitrix> Sk3letor: It's different by 20 units.
15:20:05 <Sk3letor> heh, well unity's C# is even more diffrent from C# self.. =)
15:20:07 <newcomer> ertes, kadoban: OK
15:20:19 <ertes> newcomer: also 'pure' would be a rather ad-hoc thing to have without (<*>)
15:21:19 <Sk3letor> Well I wont bother you anymore, bb. =)
15:21:25 <maerwald> nitrix: I disagree, it's probably 21, some say 22 even
15:21:46 <ggVGc> I'd argue it can't be measured
15:22:03 <ertes> CSS3 can measure anything
15:22:04 <maerwald> ggVGc: give proof! ;P
15:22:11 <nitrix> 20 units seems fine. You just have to determine what constitute a unit.
15:22:21 <nitrix> I successfully made him leave though.
15:22:42 <puregreen> I'd argue one could give a more useful answer than “20 units”, but, well, if the point was to make Sk3letor leave :)
15:22:43 <ggVGc> fwiw, Sk3letor has been harassing #gamedev for many many years
15:22:50 <ggVGc> he might be psychitic
15:22:52 <ggVGc> psychotic*
15:23:03 <ggVGc> I feel a bit bad for him, as I think he has some real issues
15:23:13 <newcomer> so what's the original definition of a Monad? is it fmap, return and join? or is it >>=  and return?
15:23:23 <nitrix> newcomer: return and join.
15:23:43 <ertes> probably something you shouldn't discuss in a 1000+ public channel
15:23:51 <newcomer> and >>= is just a handy byproduct?
15:23:59 <nitrix> newcomer: >>= is combination of fmap and join.
15:24:24 <nitrix> If you work out the types, you can see why :)
15:24:32 <ggVGc> ertes: I just wanted to state his irc background, because I don't think he should be abused but managed in a nice way
15:24:40 <ggVGc> anyway, that's all I have to say about that
15:24:41 <ertes> newcomer: (>>=) or 'join'+'fmap', depending on how you express it, are the defining features of Monad
15:24:45 <newcomer> nitrix, yes.
15:24:54 <ertes> newcomer: 'return' is a byproduct in a sense, but one that is required
15:25:03 <ertes> similar to how 0 is a byproduct of (+)
15:25:04 <ggVGc> sorry if it didn't come out the right way(just realised)
15:25:05 <marcx> wasn't monad defined with return and >>= from the start?
15:25:18 <nitrix> marcx: In Haskell because it's more practical.
15:25:28 <nitrix> marcx: Not in cat theory.
15:25:37 <ggVGc> on another note, I just got my sequencer to a fairly finished stage, and but now it has CPU spikes when recording wich is the only time in usage when they are not acceptable
15:25:48 <ggVGc> so now I am taking my first haskell profiling steps
15:25:50 <ertes> marcx: a monad is fully defined by (>>=)…  once it's in place, you don't get to choose 'return'
15:26:07 <ertes> the only thing is that a Monad /requires/ that 'return' exists
15:26:13 <marcx> how is that?
15:26:21 <ggVGc> would MVar congestion come out as CPU spikes?
15:26:31 <nitrix> marcx: The laws for one, gives very little room to the implementation of return.
15:26:31 <ertes> marcx: it takes an identity role in the same way as the neutral element in a monoid
15:26:56 <ertes> marcx: in a monoid once the binary operator is settled, you don't get to choose the neutral element, but it follows from the operator
15:27:12 <ertes> marcx: 0 is the neutral element for addition…  you can't just choose another number
15:27:17 <Cale> The original definition of a monad from category theory is that a monad on a category C is a functor T: C -> C together with natural transformations eta: 1 -> T, (which in Haskell is rendered as a polymorphic function return :: a -> T a), and mu: T^2 -> T (which in Haskell is rendered as a polymorphic function join :: T (T a) -> T a), and these have to satisfy some laws
15:27:21 <Zemyla> ggVGc: Threads waiting on MVars sleep, they don't spinlock.
15:27:24 <ertes> marcx: similar with (>>=) and return
15:27:31 <ggVGc> Zemyla: yeah that's what I reckoned
15:28:25 <marcx> i'm a bit skeptical that you can claim this to be true for all monoids or monads
15:29:05 <nitrix> That's the definition of a monoid :)
15:29:08 <ertes> marcx: i can even prove it for monoids…  for monads someone with more CT experience can prove it, too (up to isomorphism, as everything in CT)
15:29:11 <marcx> i mean you can claim it, but how are you so sure of it
15:29:24 <nitrix> marcx: proofs.
15:29:32 <Zemyla> marcx: If it doesn't have an identity element, it's not a monoid.
15:30:03 <marcx> Zemyla what if it has multiple ones give the same append?
15:30:04 <nitrix> marcx: The laws are there for a reason; they determine what's a legal monoid and what isn't.
15:30:11 <marcx> mappend
15:30:12 <Cale> Uh, I think some people are missing the thing that marcx is complaining about -- the uniqueness of a choice of identity element, given the multiplication.
15:30:25 <ertes> marcx: recall that equality is a symmetric, transitive equivalence relation:  if e1 and e2 are neutral elements for the operator (<>), then:  e1 <> e2 = e1; e1 <> e2 = e2 → e1 = e2
15:30:50 <ertes> marcx: that makes the neutral element unique for every operator
15:30:57 <ertes> (if it exists)
15:31:29 <marcx> Cale I didn't even thought about multiplication, I was just skeptical of the claim. so both 1 and 0 can be monoid identity for multiplication?
15:31:29 <nitrix> From a type perspective though, you could have multiple identity and operations on the same type.
15:31:40 <nitrix> Which Haskell solves with newtype wrappers.
15:31:43 <ertes> marcx: Cale means an abstract "multiplication"
15:32:22 <Zemyla> marcx: 1 is the monoid identity for multiplication.
15:32:41 <nitrix> marcx: 0 for addition, 1 for multiplication.
15:32:43 <Cale> marcx: Well, you mentioned monoids. The monoid operation is usually referred to as multiplication. By analogy, we also refer to the join of a monad (or mu, in traditional CT sources) as "multiplication".
15:33:11 <Cale> 0 is the identity for the multiplication which happens to be addition ;)
15:33:17 <ertes> marcx: the proof means: given a binary operator, if a neutral element exists, there is exactly one…  you don't get to choose from a set of neutral elements
15:33:18 <marcx> Cale ah. no that is not what I meant.
15:33:38 <Cale> marcx: Oh?
15:33:51 <Cale> marcx: Then perhaps I misunderstood what you were concerned about
15:34:01 <nitrix> marcx: We have two monoid instances for those;  Num a => Monoid (Sum a)   and  Num a => Monoid (Product a)
15:35:18 <ertes> the monoid instance is fully determined by mappend…  mempty being a member of Monoid is really just programmer love =)
15:35:38 <Cale> Uhhh
15:35:46 <marcx> Cale i was just skeptical about the claim that when you define >>= you have no choice of return. for all possible monads (including the ones that haven't been invented yet).  likewise for mappend and monoid id. but I'm probably wrong
15:35:46 <dolio> That's not really true.
15:35:46 <Cale> Well, that's not really the case
15:35:57 <nitrix> I feel mempty is very important.
15:36:01 <Cale> You need to know which element is the mempty to have the abstraction work
15:36:03 <marcx> no choice = it can only be one thing
15:36:14 <ertes> Cale: that's what i mean
15:36:25 <ertes> it's not formally necessary, it's "just" very useful
15:36:35 <ertes> formally all you need is a proof that it exists
15:37:06 <Cale> Perhaps classically, but I don't think that's the case constructively
15:37:22 <nitrix> ertes: More than theorical, pratically, you could very well need the identity :P
15:37:29 <dolio> A proof that it exists gives you the element, constructively.
15:37:32 <Cale> well, okay, if you had a constructive proof of existence, you'd have the element :)
15:38:19 <Cale> If you had something like the propositional truncation of that, then it wouldn't really be enough
15:39:24 <ertes> i'm not sure that every proof of identity existence has to be constructive…  at least in set theory
15:39:34 <ertes> in type theory i would buy it
15:39:35 <Cale> Right, it doesn't
15:39:38 <dolio> You're not in set theory.
15:39:45 <Cale> But yeah, we're not in set theory here :)
15:40:04 <ertes> i don't think we are in any theory here ;)
15:40:29 <ertes> proof:
15:40:33 <ertes> :t undefined
15:40:34 <lambdabot> t
15:42:47 <hpc> from a certain perspective, you don't have any choice for return anyway because it's always equal to pure
15:43:25 <hpc> so the question perhaps is can a given definition for (<*>) admit multiple definitions of pure
15:44:42 * nitrix rolls a dice.
15:44:45 <jle`> i think a given definition of <*> restricts you to only have one way to implement pure
15:44:49 <nitrix> 2.
15:45:11 <hpc> newtype Eitherer a = Perhaps a | OrMaybe a
15:45:13 <jle`> but i just jumped into this conversation
15:45:34 <jle`> i guess, one way up to isomorphism
15:45:39 <ertes> hpc: i'm sure 'pure' follows from (<*>)
15:45:49 <hpc> er, s/newtype/data
15:46:17 <jle`> i think your pure there si going to be uniquely determined from <*> there
15:46:26 <jle`> because you're basically implementing Writer ((,) Bool)
15:46:33 <jle`> er, Writer Bool
15:46:41 <jle`> so whatever monoid you pick for Bool will determine your mempty
15:46:43 <hpc> i would have to see if the laws work out for the (<*>) i have in mind, but i don't really feel like it
15:46:56 <dolio> You can prove uniqueness of candidate units of a monad similar to for monoids.
15:46:57 <hpc> jle`: there's two possible monoids for Bool
15:47:02 <jle`> any implementation of <*> you give wil be Writer Bool for different monoids for Bool
15:47:10 <jle`> hpc: yes, and whatever one you pick constrains your mempty
15:47:15 <hpc> jle`: and Eitherer doesn't use Monoid so you can't just pick one
15:47:25 <hpc> er, you have to just pick one
15:47:29 <ertes> hpc: Perhaps a | OrMaybe a ≃ a + a ≃ 2*a ≃ Blah Bool a
15:47:29 <hpc> you can't let it pick for you
15:47:32 <hpc> and it can't be unique
15:47:35 <jle`> whatever monoid you pick determines your pure
15:47:42 <hpc> (which is what classes would do)
15:47:42 <dolio> unit1 = id . unit1 = join . fmap unit2 . eta1 = join . eta1 . eta2 = id . eta2 = eta2
15:47:51 <dolio> Oops, switched to eta there.
15:47:58 <jle`> hpc: so the way you impement <*> determines what monoid (lowercase m) you're using
15:48:03 <jle`> which determines what 'pure' has to be
15:48:34 <ertes> hpc: note that Writer is a *family* of applicative functors indexed by a monoid
15:48:46 <ertes> for every individual monoid, pure is determined by (<*>)
15:49:57 <jle`> whatever way you implement <*> corresponds to Writer Bool for a specific monoid on Bool, so 'pure' is determined by the identity of the monoid you use
15:49:59 <jle`> lowercase m
15:50:37 <shirt> do any other mainstream languages besides haskell have stream fusion?
15:50:46 <ertes> (that's why i don't like to say "*the* state monad" or "*the* writer monad")
15:51:10 <hpc> ah, you're right
15:51:32 <hpc> ertes: there's other reasons to not like to say that too, but this is definitely a good one ;)
15:52:03 <simpson> shirt: I designed two different kinds of fusion for imperative streams: Twisted tubes (Python library, kind of like conduits/pipes), and Monte streams (data Stream a = Stream a (Stream a), basically)
15:52:47 <ertes> shirt: stream fusion isn't really a language feature…  haskell just makes it implicit
15:52:52 <simpson> shirt: But I haven't actually done the implementation; there's so much else that has to be improved elsewhere.
15:52:53 <ertes> you can have it in any language
15:53:20 <simpson> shirt: Note BTW that GHC implements fusion via rewriting rules which are manually added to modules like Data.List. It's not a free feature. It requires elbow grease.
15:53:27 <ertes> shirt: however, i'd question the usefulness without lazy evaluation
15:53:57 <dolio> Stream fusion is more useful without lazy evaluation.
15:55:24 <ertes> in almost all mainstream languages, values correspond to objects in memory…  the way to get (useful) stream fusion is to convince the compiler not to construct those memory objects in the first place
15:55:51 <ertes> so i can see how in an eager language stream fusion could be more useful, but also trickier to implement
15:56:40 <shirt> yeah. i'm thinking something like
15:56:42 <shirt> > concat $ map show [1..9]
15:56:44 <lambdabot>  "123456789"
15:57:09 <shirt> in imperative language, could be compiled into a single loop, without allocating an additional array of strings
15:57:31 <simpson> shirt: Yeah, I leave that up to the JIT.
15:57:54 <shirt> simpson: so there is a mainstream language that has a JIT that will actually do this?
15:58:10 <hpc> in imperative languages you'd have fused it yourself anyway by not thinking compositionally about loops
15:58:31 <simpson> shirt: The JITs generated via meta-tracing (RPython) and partial evaluation (Truffle) certainly can do this sort of thing, provided that they can prove immutability in the values.
15:59:01 <ertes> you don't get the level of certainty you get in haskell though
15:59:26 <simpson> Glass houses. I wouldn't say that Haskell is a language that generally gives you certainty about things like heap usage.
15:59:49 <dolio> Supercompilation attempts to automatically do that sort of thing statically, too. But I'm not sure anything you could call "mainstream" uses supercompilation.
16:00:14 <ertes> simpson: sure, but it does give you certainty with fusion
16:00:23 <simpson> shirt, ertes: This paper that I was reading earlier is very interesting: http://arxiv.org/pdf/1602.00602.pdf
16:00:42 <simpson> ertes: I dunno; I don't really check my Core very often.
16:01:17 <ertes> simpson: writing good fusion rules is an art form, but at least with the vector library i get consistently good results
16:01:24 <simpson> ertes: Anyway, as usual, measure and profile before optimizing, in all cases, whether you're dealing with fusion or JITs or any other kind of unpredictable optimization.
16:01:30 <simpson> Like, um. Uh.
16:01:40 <simpson> Oh! Autovectorization! Hilariously fickle.
16:08:40 <newcomer> Can I post an imgur url here? It's a pic of a paper I wrote a question on.
16:10:10 <newcomer> Here it is anyway ... http://imgur.com/tP6676m
16:10:20 <newcomer> Can anybody help me with 2) and 5)?
16:12:33 <mniip> I don't think you can do 2 using *only* fmap and join...
16:12:54 <mniip> oh wait you can
16:13:12 <mniip> but it's going to be nontrivial
16:13:39 <dfeuer> mniip, just inline by hand.
16:13:40 <dfeuer> Trivial.
16:14:17 <mniip> uhh
16:14:27 <mniip> not sure about that
16:14:33 <dfeuer> And even without that, still not too bad I don't think.
16:14:49 <mniip> you need a return at least I think
16:14:56 <dfeuer> Oh.....
16:14:59 <dfeuer> That's a problem.
16:15:01 <dfeuer> Mabye.
16:15:03 <dfeuer> Maybe not.
16:15:05 <dfeuer> One sec...
16:15:08 <glguy> :t \mf mx -> join (fmap (\f -> fmap (\x -> f x) mx) mf)
16:15:09 <lambdabot> Monad m => m (a1 -> a) -> m a1 -> m a
16:15:20 <mniip> oh
16:15:21 <dfeuer> Yeah, I was thinking something like thta.
16:15:23 <mniip> but of course
16:15:52 <newcomer> glguy, Thanks.
16:16:27 <dfeuer> @pl  \mf mx -> join (fmap (\f -> fmap (\x -> f x)
16:16:28 <lambdabot> (line 1, column 45):
16:16:28 <lambdabot> unexpected end of input
16:16:28 <lambdabot> expecting variable, "(", operator or ")"
16:16:36 <dfeuer> @pl  \mf mx -> join (fmap (\f -> fmap (\x -> f x)))
16:16:36 <lambdabot> const (const (join (fmap fmap)))
16:16:44 <dfeuer> Ewwww...
16:17:08 <glguy> :t \mmx -> mmx >>= \mx -> mx >>= \x -> return x
16:17:09 <lambdabot> Monad m => m (m b) -> m b
16:17:25 <glguy> :t \mmx -> mmx >>= \mx -> mx
16:17:26 <lambdabot> Monad m => m (m b) -> m b
16:17:44 <jle`> :t (>>= id)
16:17:45 <lambdabot> Monad m => m (m b) -> m b
16:18:01 <glguy> jle`: No, id's not one of the things you get to use for #5 :-p
16:18:02 <dfeuer> Oh, I miscopied.
16:18:13 <dfeuer> @pl join (fmap (\f -> fmap (\x -> f x) mx) mf)
16:18:13 <lambdabot> mf `ap` mx
16:18:20 <jle`> hehe
16:18:22 <dfeuer> Clever.
16:18:23 <newcomer> glguy, Thanks man.
16:18:49 <jle`> newcomer: for fun, do the same exercises for comonads
16:18:51 <dfeuer> But still,   \mf mx -> join (fmap (\f -> fmap f mx) mf)
16:19:00 <dfeuer> is simpler.
16:19:19 <dfeuer> @pl  \mf mx -> joiner (fmap (\f -> fmap f mx) mf)
16:19:19 <lambdabot> (joiner .) . flip (fmap . flip fmap)
16:19:26 <dfeuer> Haaaahahahaha. Silly.
16:19:43 <jle`> hello all
16:20:06 <jle`> can i move from implicitparams to reflections style for things like ?foo => Int ?
16:20:20 <jle`> Reifies s Foo => Int doesn't really play well with ghc
16:20:41 <dfeuer> jle`, you need to tag somehow. Typically using a newtype.
16:20:46 <jle`> but then what's the point
16:20:51 <jle`> might as well use Reader
16:20:53 <jle`> or an extra argument
16:20:58 <newcomer> jle`, I don't know what comonads are. I was just trying to wrap my head around moving around that table that I made.
16:21:00 <jle`> er, or the actual argument
16:21:16 <dfeuer> jle`, you get coherence guarantees, and you can make class instances that depend on the "implicits".
16:21:32 <newcomer> but thanks guys ... I'll sleep tight tonight.
16:22:01 <dfeuer> For instance, you could make ToJSON and FromJSON instances depending on runtime config.
16:22:02 <jle`> but i'm basically going to wrap my entire program in newtype wrappers
16:22:10 <jle`> yeah, i get the point for specific use cases
16:22:27 <newcomer> glguy, dfeuer, jle` and mniip ... thanks guys.
16:22:32 <jle`> but i'm trying to see if i can get implicit "configuration" data
16:22:42 <jle`> which (?config) => ... works really well with
16:22:51 <jle`> the only problem is...lack of coherence, and also typeclass instances can't use it
16:23:07 <jle`> and also you can't manage the case when multiple configurations happen side-by-side, if you ever want that for some reason
16:23:18 <dfeuer> Yeah.
16:23:35 <jle`> the traditional pattern is to use Reader Config ..., or MonadReader Config m => ..., but then all of your code has to be monadic style
16:23:39 <jle`> wrapped in a Reader newtype
16:23:54 <jle`> ImplicitConfig allowed me to break free
16:24:05 <jle`> but if i wrap everything in a newtype again, i'm just back where i started
16:25:00 <jle`> woe is me
16:27:42 <dmj`> jle`: :( 
16:27:57 <jle`> is there any fundamental reason why ImplicitParams doesn't work for typeclasses anyway
16:29:21 * hackagebot total-map 0.0.6 - Finitely represented /total/ maps  https://hackage.haskell.org/package/total-map-0.0.6 (ConalElliott)
16:39:22 * hackagebot text-conversions 0.1.0 - Safe conversions between textual types  https://hackage.haskell.org/package/text-conversions-0.1.0 (lexi_lambda)
16:48:43 <orion`_> Hi. What's the recommended way to restart a green thread if it dies due to an exception?
16:52:50 <dmj`> orion`_: check out async, you can wait on a thread, then if it exceptions fork a new one, might need some kind of thread pool abstraction
16:52:55 <dmj`> @package async-pool
16:52:55 <lambdabot> http://hackage.haskell.org/package/async-pool
16:53:42 <EvanR> async is the bomb
16:56:53 <newcomer> :t (\mmx -> mmx >>= (\mx -> mx >>= return x))
16:56:53 <newcomer> :t (\mmx -> mmx >>= id)
16:56:54 <newcomer> :t (\mmx -> mmx >>= (\mx -> mx >>= \x -> return x))
16:56:54 <lambdabot> Monad m => m (m b) -> m b
16:56:55 <lambdabot>     Couldn't match type ‘Expr’ with ‘m b’
16:56:55 <lambdabot>     Expected type: a -> m b
16:56:55 <lambdabot>       Actual type: a -> Expr
16:56:55 <lambdabot> Monad m => m (m b) -> m b
16:57:36 <newcomer> :t (\mmx -> mmx >>= id)
16:57:37 <lambdabot> Monad m => m (m b) -> m b
17:13:34 <obadz> :t join
17:13:36 <lambdabot> Monad m => m (m a) -> m a
17:18:49 <marcx> m (m a) to m a! you better believe it!
17:24:23 * hackagebot xpathdsv 0.1.1.0 - Command line tool to extract DSV data from HTML and XML with XPATH expressions  https://hackage.haskell.org/package/xpathdsv-0.1.1.0 (DanielChoi)
17:29:23 * hackagebot css-syntax 0.0.5 - This package implments a parser for the CSS syntax  https://hackage.haskell.org/package/css-syntax-0.0.5 (wereHamster)
17:39:24 * hackagebot libinfluxdb 0.0.4 - libinfluxdb  https://hackage.haskell.org/package/libinfluxdb-0.0.4 (wereHamster)
17:41:45 <andromeda-galaxy> EvanR: is async better than parallel-io in the case of running the (IO) computations in a list concurrently?
17:41:50 <andromeda-galaxy> *in parallel
17:54:24 * hackagebot hashable-generics 1.1.9 - Automatically generates Hashable instances with GHC.Generics. WARNING: This has been merged into, and made obsolete by Data.Hashable version 1.2. Please use the built-in instances.  https://hackage.haskell.org/package/hashable-generics-1.1.9 (ClarkGaebel)
17:54:26 * hackagebot hashable-generics 1.1.10 - Automatically generates Hashable instances with GHC.Generics.  https://hackage.haskell.org/package/hashable-generics-1.1.10 (ClarkGaebel)
17:55:19 <johnw> andromeda-galaxy: if you want the equivalent of bounded parallel-io over async, see async-pool
17:56:50 <nitrix> I was thinking about it today and wondering why is it that I appreciate this channel so much more than the other ones.
17:57:38 <Rotaerk> nitrix, because I'm in here
17:58:23 <nitrix> I came to the conclusion, surely the learning curve for Haskell filter outs a lot for various reason, but no, I think it's actually due to the people in here.
17:58:23 <geekosaur> most tech-related IRC channels are behavioral cesspools
17:58:55 <geekosaur> #haskell and #perl6 are rare exceptions
17:59:05 <nitrix> I think the regulars in here are awesome, they make you want to be nice to them, you get help, you want to help back (which I've been doing a lot too).
17:59:31 <nitrix> Just my hat off to all of you because that's worth a lot in a community.
18:08:36 <vctr> hey
18:08:44 <marcx> hi
18:09:02 <vctr> could i get some feedback on a bit of code? here's the beginnings of a convenience library for printing data in the repl
18:09:07 <vctr> for interactive data analysis
18:09:13 <vctr> http://lpaste.net/164492
18:10:28 <vctr> marcx if you (or anyone else) have any suggestions for improvement, i'm happy to listen
18:11:41 <pavonia> vctr: "f x = foo . bar . baz $ x" is usually written point-free as "f = foo . bar . baz"
18:11:49 <MichaelBurge> vctr: I wonder if it would be easier to use if you made a pretty-printing typeclass, so someone could just do 'prettyPrint dummy' and have sensible defaults
18:13:19 <vctr> pavonia: thanks, although personally i find it slightly easier to grok knowing there's an argument there
18:13:33 <vctr> i know that point free style is preferred though
18:13:52 <vctr> er grok is maybe not the right term, parse-when-i'm-scanning-code ...
18:14:04 <merijn> MichaelBurge: There's a whole bunch of prettyprinting classes already
18:14:31 <merijn> vctr: But if f has a type signature you can you see the presence of the argument in the type :)
18:14:34 <vctr> merjin yeah maybe i should try to implement these within one of those
18:16:14 <mn9lk> Hi everyone, I have experience programming for some time now, these days at my job I program in Go(lang) and Javascript. And I really enjoy learning more about programming and its something I really like doing, over the years I have seen the name Haskell pop out over and over again, and I have finally decided to give it a try thanks to this https://gist.github.com/quchen/5280339 . Honestly I think this is the first time I am approaching a language after un
18:16:14 <mn9lk> i, without knowing what I even want to solve in it. I am planning to follow this http://learnyouahaskell.com/chapters . What I want to know is, what are some things I need to know about while learning Haskell, I mean resources, bits of advice you guys can throw my way etc etc :) . Forgive me for the long introduction and the loaded question.
18:16:22 <vctr> not many haskell libraries seem to ahve good support for pretty printing. to be honest i haven't quite figured out the concepts of the HughesPJ pretty printing typeclass yet.
18:16:34 <vctr> but maybe i should try to understand that library better since i'm making this for myself
18:17:03 <Cale> mn9lk: Well, feel free to ask us lots of questions as you're learning
18:17:05 <vctr> mn9lk here's my recommendation - don't learn from learn you a haskell, learn from http://haskellbook.com/
18:17:32 <vctr> the pedagogical approach of 'learn you a haskell' is not so great, it can fool you into thinking you're learning only for you to get stuck on a real project
18:17:40 <vctr> haskell book is much better for learning
18:17:56 <merijn> vctr: I've used ansi-wl-pprint for pretty printing and it seemed fairly easy
18:18:15 <vctr> any other thoughts on this code snippet? i feel like i'm cargo culting some of the string conversions
18:18:31 <vctr> lego-ing type signatures until it works. i wonder if the string conversions could be simplified
18:18:56 <vctr> the other thing, i'm wondering if i could make that columnar printing routine, "disp", more general
18:19:15 <vctr> i feel like there's something clever that could be done with generics to iterate over record fields, but i'm not sure how yet.
18:19:44 <merijn> vctr: What are you trying to do?
18:19:44 <vctr> as it stands it kinda works, but not quite right - it adds \" around all the values
18:19:47 <vctr> merjin
18:20:00 <vctr> merjin basically trying to display a collection of records the way R displays a data frame
18:20:11 <vctr> one record per row, with record fields aligned
18:20:26 <merijn> I'm not sure what R does for anything, tbh
18:20:35 <vctr> sec, trying to find an example
18:21:32 <vctr> merjin this sort of view for a collection of records: http://lpaste.net/164493
18:21:36 <vctr> each row is one record
18:22:02 <merijn> I think you want
18:22:03 <merijn> https://hackage.haskell.org/package/boxes
18:22:26 <vctr> ah i didn't know this existed
18:22:35 <mn9lk> Cale: thanks :) 
18:22:52 <mn9lk> vctr: https://gumroad.com/l/haskellbook says the book is still not completed
18:23:18 <vctr> mn9lk don't worry about that, it's still better/ more comprehensive than any other learning resource out there
18:23:25 <vctr> as the author makes revisions you'll get updates
18:23:40 <mn9lk> alright. Ill get it then. Thanks for the advice. 
18:23:41 <vctr> but the book is already over 1000 pages as is, so you'll have plenty to chew on already
18:23:50 <Cale> http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html is also pretty decent
18:23:53 <vctr> the price is worth the time you save, and then some
18:24:05 <Cale> (though quite a bit more brief)
18:24:25 * hackagebot github-types 0.2.1 - Type definitions for objects used by the GitHub v3 API  https://hackage.haskell.org/package/github-types-0.2.1 (wereHamster)
18:26:20 <vctr> there should be a bot that points newbies to haskellbook whenever learn you a haskell is mentioned :-)
18:29:25 * hackagebot github-webhook-handler 0.0.8 - GitHub WebHook Handler  https://hackage.haskell.org/package/github-webhook-handler-0.0.8 (wereHamster)
18:33:41 <EvanR> total-map is pretty cool
18:38:47 <scshunt> Is there any easy way to condition behaviour based on whether a type has a typeclass instance?
18:39:16 <merijn> Easy? No? Horrifically hacky way? yes
18:39:23 <EvanR> we need a Not constraint transformer ;)
18:39:25 <scshunt> merijn: overlapping instances?
18:39:41 <merijn> scshunt: No, there's is a ifctxt package
18:40:05 <merijn> scshunt: https://github.com/mikeizbicki/ifcxt
18:46:03 <scshunt> merijn: thanks
18:47:31 <nitrix> mn9lk: I've been helpinga a lot of beginners on #haskell-beginners and it is my observation that the ones who have read haskellbook.com seems a lot less confused and usually ask about more advanced concepts rather than clarifying their misconceptions; which I think says a lot about the quality of the book.
18:49:02 <vctr> how do you get haddock comment to be preformatted text (for example a code block example or a table)
18:49:04 <vctr> ?
18:53:36 <geekosaur> https://www.haskell.org/haddock/doc/html/ch03s08.html#idm140354810748512 for various lists; no table markup as such; code blocks are indented with "> "
18:55:21 <geekosaur> the usual intent is that if you need more than that, you use literate haskell along with some other kind of markup for e.g. tables. notably, there's a LaTeX mode where the Haskell code the compiler sees is inside \begin{code} ... \end{code} and the compiler ignores everything outside those blocks
18:56:02 <koz_> geekosaur: Wow, really? Which TeX compilers support that?
18:56:11 <geekosaur> ????
18:56:48 <geekosaur> the usual context for "Haskell code" would be a Haskell compiler
18:57:03 <geekosaur> (ghc supports this, I think Hugs used to when it was maintained)
18:57:57 <geekosaur> and there are various stylesheets floating around to format LaTeX with or without the code and with or without various kinds of syntax highlighting appropriate for printed output
18:58:08 <pavonia> koz_: There's a preprocessor called lhs2TeX which converts .lhs files to LaTeX documents
18:58:16 <scshunt> merijn: is it bad to attempt to base a game engine off of that?
18:58:29 <koz_> pavonia: Ah, thanks! Is it on Hackage?
18:58:51 <pavonia> @hackage lhs2tex
18:58:51 <lambdabot> http://hackage.haskell.org/package/lhs2tex
18:58:58 <pavonia> Yes
18:59:15 <koz_> pavonia: Thank you - as ever, you have all the answers.
18:59:46 <pavonia> :o
19:01:43 <vctr> is there a haskell equivalent to https://journal.r-project.org/
19:02:05 <vctr> basically a small journal for package releases?
19:05:14 <Rotaerk> hmm I wonder if it would be a hacky misuse to make a Producer Socket IO () pipe, where it checks if the connection is still alive, and if not reconnects, before yielding the socket
19:05:53 <Rotaerk> so then when it's decided to abort trying to reconnect, it kills the entire pipeline that relies upon it; but until then, the pipeline stays alive, and just waits for reconnection
19:06:57 <Rotaerk> hmm, nah; nevermind
19:24:15 <sm> vctr: not for packages specifically, but there is/was The Monad Reader
19:26:50 <vctr> sm thinking about open sourcing some projects. we have processes for publication, so it's easier if the code is tied to some kind of publication.
19:28:16 <EvanR> Rotaerk: you could have the raw socket handler do reconnecting, and it puts "Ok chunk" or "NotComingBack" into the piipe
19:28:29 <EvanR> before disappearing
19:28:56 <vctr> what's the preferred way for binding python? cpython?
19:29:19 <Rotaerk> EvanR, yea I realized my dilemma wasn't with that, but with the fact that I need two different threads to access the same connection
19:29:21 <will_sm> define binding
19:29:33 <Rotaerk> one that receives from the socket and another that writes to
19:29:41 <sm> vctr: also, there's the Haskell Communities and Activities Report
19:29:45 <Rotaerk> trying to decide how to structure that
19:30:29 <EvanR> do you have a pipeline for writing?
19:31:14 <Rotaerk> I will have a pipeline starting with a Producer of the bytes from the socket, and ultimately acting upon the interpreted data
19:31:32 <Rotaerk> and another pipeline processing input and sending stuff to the socket
19:31:44 <EvanR> is there only one socket total
19:31:48 <Rotaerk> yes
19:32:00 <Rotaerk> I'm not sure whether I should somehow make the pipelines resilient to disconnects, or if they should be rebuilt every time it reconnects
19:32:11 <vctr> sm hmm maybe that's a good venue.
19:32:29 <EvanR> is the protocol resilient to disconnects?
19:32:39 <EvanR> can you pick up right where you left off somehow
19:32:40 <Rotaerk> no; it's IRC
19:32:54 <Rotaerk> I guess that answers my question...
19:33:02 <EvanR> then maybe then both pipelines (related to IRC, not the app as a whole) need to die 
19:33:10 <Rotaerk> yea
19:33:51 <EvanR> the input though could be controlling the app, so thats something else
19:34:48 <Rotaerk> yea I'd have to separate that out
19:43:32 <lethjakman-l> Does {-hi-} have any sort of special meaning?
19:43:54 <lethjakman-l> Or is this a typo?
19:44:20 <Clint> that's a very metaphysical question
19:44:31 <Rotaerk> lethjakman-l, looks like a comment :P
19:44:40 <lethjakman-l> Lol
19:45:05 <lethjakman-l> I'm asking because I see it in this second example: https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/tagsoup
19:46:47 <ahihi> I think it's supposed to be some kind of highlighting markup
19:46:54 <lethjakman-l> Ah, that would make sense. 
19:46:55 <ahihi> but whatever was supposed to parse it... didn't
19:47:07 <lethjakman-l> That makes me feel less dumb. 
19:47:37 <lethjakman-l> Thank you :)
19:47:47 <geekosaur> yeh, it says " All these changes are highlighted." but no highlighting... and those comments
19:48:36 <lethjakman-l> Great point. 
19:48:43 <lethjakman-l> The examples are broken anyways...
19:49:57 <lethjakman-l> Anyone going to lambdaconf or purescript conf btw?
20:52:43 <nitrix> It's not near me, but I'll eat everything that comes out of it :)
20:54:18 <shanemikel> Where theorem proving is the concern, what's the justification for using a general purpose language to program and a prover language to prove, vs a combo language for both
20:56:01 <shanemikel> Seems like the discrepancies between type systems, general properties, and the need to re-encode would be troublesome
20:56:38 <nitrix> shanemikel: Have you used adga/idris/coq?
20:57:05 <MichaelBurge> shanemikel: For proving, general purpose languages might not be as advanced as a dedicated theorem-prover language.
20:57:24 <nitrix> It's very tedious to write code while proving the most minuscule things.
20:57:26 <MichaelBurge> shanemikel: And for programming, the work needed to make a formal proof might get in the way of productivity
20:58:18 <shanemikel> No.  I'm following Friedman's "Little Prover" book ATM, and I have the coq book enqueue
20:58:19 <MichaelBurge> shanemikel: You might think that you can work around it by just admitting theorems for easy things, but even just having to think about them could get in the way
20:59:14 <nitrix> I think type systems are generally very capable of preventing the common issues that could arise during development. Haskell could push it a little further with enforcing laws, but it'd complexify either GHC or the language I think.
21:00:25 <shanemikel> So what sorts of things do people prove with these specialty languages (about programs written in Haskell/other languages)
21:01:22 <MichaelBurge> shanemikel: I think there's a C compiler and microkernel floating around that are written in Coq.
21:01:45 <johnw> CompCert
21:02:23 <nitrix> The problem is, I believe Coq starts with no axioms. You need to add more axioms and you can create inconsistencies.
21:02:40 <nitrix> You can only proove so much :P
21:02:43 <johnw> nitrix: there are some axioms in the standard library that you can opt-in
21:03:00 <johnw> and a certain set have been proven to play together well
21:03:13 <johnw> you can get really far without them, though
21:03:40 <shanemikel> Sure, I see the use for small embedded programs and state machines.  As for the compiler, did they to the trouble of proving the whole thing?
21:03:59 <johnw> shanemikel: at first, they only proven transformations on a representation of a subset of C
21:04:08 <johnw> later, they wrote a proven parser as well
21:04:13 <nitrix> Personally, I think that's digging a hole, but I respect the work put towards the theory as I probably do not understand very well what emerges out of it, but it's probably impactful.
21:04:50 <johnw> it's about compiling C programs that cannot have errors in them due to the compiler
21:04:59 <johnw> there can still be user error, but that should be the only source of error
21:05:27 <johnw> once you can fully trust compiler transformations, then they can also become arbitrarily complex
21:06:14 <MichaelBurge> I've noticed that for a lot of purposes, a passing QuickCheck test seems to carry much of the weight of a formal proof for a lot less work
21:06:27 <MichaelBurge> I mean in the sense that I can often prove a function correct if randomly-generated data passes
21:06:33 <johnw> heh
21:06:47 <johnw> not quite the same, but I understand the sentiment
21:07:00 <johnw> I recently had a QuickCheck that only failed at the 4 billionth iteration
21:07:18 <johnw> there is nothing that can rival proof for correctness
21:07:33 <shanemikel> Do the ghc folk use them to prove, say, compiler optimizations?
21:07:49 <MichaelBurge> GHC is just unit-tested, I believe
21:07:51 <johnw> there is a tool for using Coq to write GHC compiler transformations, but I don't believe the GHC team uses it
21:08:00 <johnw> also, Richard Eisenberg did a model of System FC in Coq, I believe
21:11:17 <marcx2> how do you pronounce coq?
21:11:28 <johnw> like the beginning of "Cockney"
21:13:26 <mniip> marcx2, its logo is a picture of a rooster, what do you think
21:13:48 <marcx2> i didn't pay attention
21:14:05 <marcx2> I could think of a more interesting logo though
21:14:15 <johnw> however, if you pronounce it "Coq", as it "Coq au Vin", no one will mind
21:16:54 <pavonia> johnw: Isn'T that the same pronunciation?
21:17:01 <johnw> it sounds different to my ears
21:17:13 <marcx2> is that a rather phallic looking rooster or am i imagining things. https://upload.wikimedia.org/wikipedia/commons/d/d8/Coq_logo.png
21:17:57 <shanemikel> I'm much further down the rabbit hole than I ever wanted to go.. I just bought Appel's compiling with continuations
21:18:03 <marcx2> i suppose it could have been worse :)
21:18:03 <EvanR> solving for the point in time that a point moving linearly crosses a line segment whose endpoints are also moving linearly
21:18:39 <EvanR> i seem to have only 1 equation with two variables...
21:18:48 <EvanR> then i realized it could cross more than once
21:19:11 <EvanR> now i have no idea where i am
21:20:50 <EvanR> also my one equation isnt even linear
21:21:17 <shanemikel> Come to Haskell to learn a better language, end up learning every language there is, and how to build my own ..
21:21:39 <EvanR> that seems natural, you did say better, you didnt specify haskell ;)
21:23:49 <EvanR> 0 = a0 - x0 + (v_a - v_x)*t + (b_0 - a_0)*s + (v_b - v_a)*s*t
21:23:56 <EvanR> so its bilinear, i think
21:25:01 <EvanR> i can only imagine up to 2 solutions
21:25:16 <EvanR> unless they overlap parallel
21:26:20 <marcx2> is coq being named after a male sex organ proof of patriarchy and rape culture in the programming community
21:27:09 <simpson> marcx2: Wrong channel.
21:27:19 <peddie> marcx2: it's named after Thierry Coquand I believe
21:27:26 <marcx2> simpson good point. what is coq channel?
21:27:48 <EvanR> i was just in a room with mostly women babbling about how bad C# docs are, and PHP
21:30:29 <EvanR> if that RHS is a function of two vars then it defines a surface with at most two troughs... from the s t term, im making shit up
21:30:55 <EvanR> and its a vector valued surface
21:34:44 <shanemikel> The docs for most languages are pretty awful
21:35:05 <EvanR> which is 1 regular surface for each dimension, which can be solved separately, and compared
21:36:10 <shanemikel> I'm kinda bummed that I've had experience with decent docs at all, now I'm spoiled
21:36:59 <EvanR> along the s and t directions, the cross section is linear, but curiously a cross section at some linear combination of the two is a parabola
21:37:12 <EvanR> hard to visualize
21:39:37 <begriffs> Is it normal for hoogle to use 1GB for its database? I created my db with `hoogle data` and the downloads directory inside hoogle-4.2.43/databases is 936M!
21:40:04 <begriffs> However the .hoo files in the databases directory aren't really that big
21:43:00 <marcx2> coq programming penis 41200 hits. coq programming Coquand - 20700 hits
21:43:30 <EvanR> thank you wolframe alpha "hyperbolic paraboloid"
21:44:32 <jle`> there's a Category instance for Refl haha
21:44:56 <jle`> who thinks of this
21:47:09 <jle`> :t (undefined :: Int :~: Bool) C.. (undefiend :: String :~: Int)
21:47:10 <lambdabot>     Not in scope: ‘undefiend’
21:47:10 <lambdabot>     Perhaps you meant ‘undefined’ (imported from Prelude)
21:47:15 <jle`> :t (undefined :: Int :~: Bool) C.. (undefined :: String :~: Int)
21:47:16 <lambdabot> String :~: Bool
21:49:22 <slack1256> how do you create a Refl? you state it with the correct type or there are smart constructors?
21:49:25 <defanor> with `cabal haddock`, is there a way to generate haddock documentation for all the modules, not just the exposed (as in "exposed-modules", in a "library" section of a *.cabal file) ones?
21:52:13 <dfeuer> slack1256, the primitive way is to state it directly. But there are also ways to manipulate them with symmetry, transitivity, etc.
21:53:33 <defanor> found the --all option
21:53:44 <dfeuer> Stuff like  whateverIt'sCalled :: (f :~: g) -> (a :~: b) -> f a :~: g b, and whatchamacallit :: f a :~: g b -> f :~: g  and somethingorotehr :: f a :~: g b -> a :~: b
21:54:11 <dfeuer> Any masters of unboxing around?
21:54:44 <EvanR> You, dfeuer, the master of unboxing, should be able to handle it
21:55:08 <dfeuer> I'm trying to figure out if there's a way to get GHC to unbox all the Ints for Data.Sequence.adjust. I've strictified some stuff, but I'm not at all sure this can be done without hand-unboxing.
21:55:16 <dfeuer> EvanR, I am *definitely* not a master of unboxing.
21:56:20 <jle`> > Refl :: Int :~: Int -- slack1256 
21:56:22 <lambdabot>  Refl
21:58:04 <dfeuer> @let transSlack :: a :~: b -> b :~: c -> a :~: c; transSlack Refl Refl = Refl
21:58:05 <lambdabot>  Defined.
21:58:25 <dfeuer> @let symSlack :: a :~: b -> b :~: a; symSlack Refl = Refl
21:58:27 <lambdabot>  Defined.
21:59:13 <dfeuer> @let bothSlack :: f :~: g -> a :~: b -> f a :~: f b; bothSlack Refl Refl = Refl
21:59:14 <lambdabot>  Defined.
21:59:26 <dfeuer> Etc....
22:04:38 <marcx2> Jack and Jill went up the hill so Jack could lick her candy. But Jack got a shock and a mouth full of cock Cause Jill's real name is Randy
22:04:49 --- mode: ChanServ set +o johnw
22:04:54 --- mode: ChanServ set +o johnw
22:04:55 --- mode: johnw set +b *!~bc816c65@webbox222.server-home.org
22:04:55 --- kick: marcx2 was kicked by johnw (Kicked)
22:04:55 --- mode: johnw set -o johnw
22:05:20 <dfeuer> Thanks, johnw.
22:09:01 <Tehnix`> Some weird bot spam lately :/ (or is it just the first time I'm noticing it?)
22:09:22 <johnw> well, the private messages seemed artisinally crafted, small batch
22:09:28 <dfeuer> In https://github.com/haskell/containers/blob/master/Data/Sequence.hs#L1666 it's a fact that the function argument to adjustTree will *always* be strict in its Int argument. But GHC can't seem to help. 
22:09:40 <dfeuer> Er ... GHC can't seem to figure that out.
22:09:54 <dfeuer> Is there any way I can help, short of manually unboxing everything?
22:10:40 <zcourts> I've read "Implementing Functional Languages: a tutorial", I get the general gist of it but it hasn't clicked as to exactly how partial application is handled. It mentions that constructors must be saturated but nothing for other supercombinators. Does anyone know if/how they're handled? I'm planning to implement it over the weekend to help my understanding.
22:11:34 <dfeuer> I tried making adjustTree local to adjust, with no particular effect.
22:12:02 <dfeuer> I tried specializing adjustTree to Elem and Node manually instead of automatically; that doesn't do the trick either.
22:12:08 <dfeuer> I tried both at the same time; no dice.
22:14:39 <dfeuer> Anyone?
22:15:08 <n_blownapart> hi I've gotten mixed reviews about the book The Haskell Road to Logic, Maths and Programming. How much math does one need to get into it? I have some math inclination, a little scheme experience and some ruby. any thought? thanks
22:15:34 <dfeuer> n_blownapart, I suspect the Ruby experience will be quite irrelevant to any book on such topics.
22:15:40 <dfeuer> Aside from that, no idea.
22:15:42 <n_blownapart> word
22:16:01 <n_blownapart> anyone read "A road to...."
22:16:15 <dfeuer> Someone must have! I've even heard of it.
22:16:20 <n_blownapart> sorry The Haskell Road to..."
22:16:29 <dfeuer> Let me know how you like it.
22:16:49 <n_blownapart> or should I just stick with sicp.
22:17:07 <dfeuer> n_blownapart, those are not the only choices!
22:17:29 <dfeuer> I just haven't personally read the book you're mentioning.
22:17:47 <n_blownapart> dfeuer, what do you suggest for a relative beginner who wants to begin with FP
22:17:48 <n_blownapart> ?
22:17:58 <kadoban> n_blownapart: http://haskellbook.com/ would be my suggestion for haskell, but I've never read the book you mention.
22:18:14 <n_blownapart> thanks kadoban 
22:18:17 <dfeuer> That's bytemyapp's book, right?
22:18:26 <dfeuer> er ... bitemyapp's.
22:18:28 <kadoban> Why choose though? Read a few. SICP is neat and free.
22:18:29 <kadoban> Yep
22:18:36 <dfeuer> People seem to like his work.
22:18:50 <n_blownapart> its bloody hard for a self learner... (sicp)
22:18:56 <kosmikus> dfeuer: I wonder if it would make sense to defunctionalize the adjust* functions
22:19:08 <kadoban> n_blownapart: Sounds possible
22:19:17 <dfeuer> kosmikus, can you explain what you mean/how that might be done?
22:20:02 <dfeuer> kosmikus, the most obvious thing would be to take an approach like lookup or splitAt, but that would give the wrong efficiency (O(log n) monolithic instead of O(log n) incremental)
22:20:17 <Tehnix> n_blownapart: I think the general advice I got a while back was that it might distract too much from the haskell learning, by including much math. I.e. you end up focusing on the wrong things - that said, I haven't read it, so can't advice that much against it :)
22:20:24 <johnw> dfeuer: example here: https://en.wikipedia.org/wiki/Defunctionalization
22:20:25 <dfeuer> I *think* it would, anyway.
22:20:43 <kosmikus> dfeuer: it's a technique to turn higher-order functions into first-order functions by introducing a datatype representing each of the different functions that will be passed as arguments
22:22:36 <dfeuer> kosmikus, I'm not clear on how that works with non-regular datatypes.
22:22:45 <kosmikus> n_blownapart: regarding "The Haskell Road ...": I think it's actually a nice book, but not necessarily a good book if your main goal is to learn Haskell.
22:23:34 <n_blownapart> thanks Tehnix et al. I believe that the Haskell in the Road to book is minimal, just enough to learn math proof thinking. but I'm having trouble both with it and sicp.
22:24:23 <dfeuer> Well, there's always The Art of Computer Programming (which I would *not* recommend as anything but a mathematics text and an algorithm reference text)
22:24:24 <kosmikus> dfeuer: I don't think the non-regularity of the finger tree is a factor here.
22:24:25 <Tehnix> n_blownapart: as others have said, I'd also recommend http://haskellbook.com :)
22:24:38 <kosmikus> dfeuer: The only thing relevant for defunctionalization is the structure of the function calls that occur.
22:25:00 <n_blownapart> thanks again Tehnix dfeuer et al.
22:25:05 <dfeuer> kosmikus, how do I give the things appropriate types?
22:26:30 <dfeuer> Wait ... do I end up with some kind of nested type representing the function?
22:26:30 <rhovland> hmm "data DBN a node where DBN :: Ord node => a -> node -> DBN (M.Map node a)" isn't working
22:27:23 <rhovland> I want to make (DBN a) an instance of functor, so I need to get that ord constraint in there somehow
22:27:52 <dfeuer> rhovland, how can that ever be an instance of Functor?
22:28:04 <rhovland> hmmm I guess I'm doing that a bit in reverse
22:28:08 <dfeuer> I think you may be on a wild chase after geese.
22:28:32 <rhovland> dfeuer: well, I'd define fmap as M.mapKeys
22:28:35 <Tehnix> Don't you just need `fmap` to make it an instance of functor?
22:29:01 <rhovland> dfeuer: but mapkeys needs the ord constraint on the keys
22:29:01 <kosmikus> dfeuer: I can have a look at the actual code in a bit
22:30:01 <Tehnix> rhovland: would deriving Ord suffice? 
22:30:21 <Tehnix> (I'm probably not at all following what's going on here <.<)
22:31:12 <rhovland> that is, I started with just "data DBN a node = DBN (Map node (a,[Int]))"    (and removed the [Int] for clarity since it doesn't matter in explaining the problem)
22:31:57 <dfeuer> rhovland, that won't get you to a Functor instance.
22:31:59 <dfeuer> Thanks, kosmikus.
22:32:41 <dfeuer> I might be able to work it out eventually, but seeing how it's done for this could at least point me in the right direction for the other functions that work similarly.
22:32:53 <rhovland> so then I wanted to do "instance Functor (DBN a) where fmap f (DBN m) = DBN $ M.mapKeys f m"
22:33:22 <rhovland> tehnix: hm deriving ord might suffice.. not sure
22:33:24 <dfeuer> rhovland, you still have big problems because fmap has to take *any* function.
22:34:08 <dfeuer> Sorry, that's the wrong problem.
22:34:24 * dfeuer forgets the details of the actual problem.
22:36:27 <dfeuer> Or maybe that is the actual problem?
22:38:05 <rhovland> dfeuer: that's pretty much the problem... M.mapKeys f constrains f to be (Ord b => a->b)
22:42:56 <rhovland> I suppose I can do M.toList, map across fst, and recombine... hm
22:44:06 <dibblego> it's a known problem, described by the idea of restricted type-classes
22:45:23 <rhovland> dibblego: hm I'll look that up, thanks
22:46:43 <dibblego> correction, restricted data types
22:46:44 <dibblego> http://okmij.org/ftp/Haskell/types.html#restricted-datatypes
23:10:01 <dfeuer> kosmikus, it's about my bedtime. Unless you've got something now, could you maybe let me know by email, or on Github?
23:12:44 <kosmikus> dfeuer: is there a benchmark you're trying to improve?
23:14:01 <dfeuer> kosmikus, there isn't one in the repo yet. I'll have to fix that. The most obvious one would be `index`ing to that spot immediately after `adjust`ing it.
23:14:36 * hackagebot bytestring-handle 0.1.0.4 - ByteString-backed Handles  https://hackage.haskell.org/package/bytestring-handle-0.1.0.4 (GaneshSittampalam)
23:14:51 <kosmikus> dfeuer: I'll commit what I came up with to a fork
23:14:55 <dfeuer> kosmikus, I mostly want to see how this defunctionalization thing could work in this context.
23:15:03 <kosmikus> dfeuer: I used a GADT.
23:15:45 <dfeuer> I assume the GADT was to deal with the nestedness?
23:15:53 <dfeuer> non-regularity, whatever?
23:16:23 <kosmikus> dfeuer: https://github.com/kosmikus/containers/commit/ac6746485f4191a9f31dc28a0877d03802b64250
23:16:38 <kosmikus> yeah, you were right, it's not quite a trivial as usual due to the nested-ness
23:17:37 <kosmikus> it's really not clear whether this is any good. but usually, the allocation of datatypes now and function closures in the old version should be more or less even.
23:17:51 <kosmikus> whereas now, the strictness analysis for the Int argument should no longer be a problem
23:17:59 <kosmikus> which is what you were originally after
23:20:50 <dfeuer> kosmikus, thanks. I'll take a look.
23:21:19 <dfeuer> kosmikus, could you open a PR in case I decide to use it?
23:22:22 <dfeuer> er...
23:22:46 <dfeuer> Oh.
23:22:49 <dfeuer> Weird.
23:23:52 <kosmikus> dfeuer: hm?
23:23:58 <dfeuer> kosmikus, I fear the Sized a context in your GADT. Those dictionaries aren't flying around in the current code.
23:24:21 <kosmikus> yes, I'm not happy about that one either
23:25:39 <kosmikus> dfeuer: I don't really feel like opening a PR without any indication that this is an actual improvement
23:25:50 <dfeuer> Fair. It probably isn't with those contexts.
23:26:21 <dfeuer> If the defunctionalization approach is valid, it should be able to eliminate both at the same time, no?
23:26:41 <kosmikus> dfeuer: there can be arbitrary nesting of Sized dictionaries, or not?
23:27:12 <dfeuer> kosmikus, not really. There are only two instances of Sized; no recursion.
23:27:23 <dfeuer> Er ...
23:27:29 <dfeuer> Sorry, there are more, but no recursion.
23:28:05 <kosmikus> hmm
23:28:32 <kosmikus> ok, I'll look at this again
23:28:45 <dfeuer> The size is either 1 (for Elem a), or pulled out of the size field of a Node or Deep constructor, or summed through one level of indirection.
23:28:50 <dfeuer> Or 0 for an EmptyT.
23:29:29 <dfeuer> Thanks.
23:29:37 * hackagebot pcre-utils 0.1.8 - Perl-like substitute and split for PCRE regexps.  https://hackage.haskell.org/package/pcre-utils-0.1.8 (SimonMarechal)
23:30:21 <Athas> Does any functional language compiler use block tiling to optimise memory accesses?
23:34:37 * hackagebot stateWriter 0.2.8 - A faster variant of the RWS monad transformers.  https://hackage.haskell.org/package/stateWriter-0.2.8 (SimonMarechal)
23:34:39 * hackagebot withdependencies 0.2.3 - Run computations that depend on one or more elements in a stream.  https://hackage.haskell.org/package/withdependencies-0.2.3 (SimonMarechal)
23:41:32 <dfeuer> kosmikus, I'm guessing that by hand-specializing to Elem and Node, you can scrap the GADT in favor of a newtype. Maybe a wacky newtype like newtype AdjustFun a = AdjustFun (StripNode a)  with type family StripNode a where StripNode (Node a) = a
23:41:41 <dfeuer> But maybe that's crazy.
23:42:13 <dfeuer> Er.. I expressed that wrong.
23:42:18 <dfeuer> But ... whatever.
23:43:14 <koz_> https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Extras.html <-- I discovered this, and apparently the 'is Prisms' can be auto-derived. However, if I want to write them myself, how would I go about doing this?
23:43:32 <koz_> (asked because this: http://stackoverflow.com/a/25587871/2629787)
23:43:48 <koz_> (and I prefer to understand from first principles, rather than relying on magic)
23:44:37 * hackagebot yesod-bin 1.4.18.2 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.18.2 (MichaelSnoyman)
23:44:50 <dfeuer> koz_, thanks to the extremely general types in lens, it can in some ways be easier to *write* lenses than to *use* them.
23:44:58 <dfeuer> The main tool I recommend is GHC's typed holes.
23:45:00 <koz_> dfeuer: I've run into that face-first already. :P
23:45:32 <koz_> dfeuer: That doesn't really help me much - I dunno what the types of the auto-derived Prisms described in that SO answer (or consumed by is) would look like.
23:45:36 <dfeuer> Write the signature you need, put a hole. Fill stuff in, with more holes.
23:45:56 <koz_> Alrighty, guess I'll give it a shot...
23:45:59 <dfeuer> koz_, that's easy! Auto-derive them and ask for their types in GHCi :)
23:46:52 <koz_> dfeuer: Why didn't I think of that... derp.
23:46:55 <koz_> Thanks dfeuer.
23:47:03 <dfeuer> No problem.
23:48:57 <dfeuer> Oh, definitely not a newtype.
23:49:00 <dfeuer> Hrmmmhrmmmm
23:49:24 <dfeuer> actually need those bits.
23:54:58 <koz_> Is there a way to make GHCi spew the source code generated by TH?
23:55:23 <GhiOm> hi all!
23:55:43 <koz_> GhiOm: Hihi!
23:56:50 <GhiOm> I'm a haskell beginner, I'm trying to make a small dice game in haskell
23:56:55 <GhiOm> so it involves randomness
23:57:10 <GhiOm> I have two choices as far as I understand
23:57:23 <GhiOm> IO monad or passing a RNG in my game state
23:57:50 <GhiOm> I don't like the RNG method so much, but it seems that the IO monad would "pollute" most of the function signatures
23:58:01 <kosmikus> dfeuer: still there?
23:58:11 <dfeuer> Unfortunately. I *should* be sleeping.
23:58:22 <dfeuer> But I can't tear myself away.
23:58:47 <GhiOm> I'm looking for references to small projects using randomness, anyone knowing where I can look ?
23:58:53 <kosmikus> dfeuer: I think one can specialize the constructor to the two cases to get rid of the dictionaries again
23:59:01 <koz_> GhiOm: Are you familiar with the State monad?
23:59:15 <GhiOm> koz_: not really
23:59:16 <koz_> You might find it helps you here - and LYAH has a whole chapter on its use for exactly this purpose.
