00:07:38 * hackagebot uncertain 0.3.0.0 - Manipulating numbers with inherent experimental/measurement uncertainty  https://hackage.haskell.org/package/uncertain-0.3.0.0 (jle)
00:07:38 * hackagebot failure-detector 0 - Failure Detectors implimented in Haskell.  https://hackage.haskell.org/package/failure-detector-0 (davean)
00:08:23 <shanemikel> jle` that's cool, I was just thinking about writing something like that
00:09:01 <jle`> ever since i put it up, i've found out that a lot of people have written stuff in this space before too ><
00:10:09 <shanemikel> sometimes it's easier to build something than find it in hackage (and determine if it works, still supported, etc)
00:17:03 <Aruro> which exception does read throw?
00:18:10 <Cale> Aruro: It throws an exception using "error", which you usually shouldn't try to catch. If you need to deal with parse failure, use reads or readMaybe
00:18:29 <Aruro> k, ty
00:21:41 <Cale> Aruro: But for the record, the exception type is called ErrorCall
00:22:30 <Aruro> yes, i see it in :i Exception, ty
00:22:32 <Cale> Aruro: You *can* catch it using a combination of Control.Exception.evaluate and try or catch, but it's fiddly in a way that you usually want to avoid if possible
00:22:55 <Aruro> Cale: i will avoid :) Text.Read is better
00:23:20 <Cale> (Catching any exceptions thrown by evaluation of expressions rather than execution of IO actions is tricky)
00:24:55 <Aruro> but if its inside IO, im parsing arguments, will it throw IOException? or ErrorCall?
00:25:12 <Aruro> if i do try (IO block)
00:25:48 <Aruro> Cale: ^
00:26:21 <Cale> It'll still throw ErrorCall.
00:26:32 <Cale> (anything which uses error "string" will)
00:33:15 <koz_> I'm looking at Haskell Design Patterns, but I'm having severe trouble grasping their formulation of 'Patterns of Generic Programming' (i.e. sum of products, origami programming, and Scrap Your Boilerplate). Could someone please direct me to some alternative explanations of these things?
00:33:23 <koz_> (or whatever people use today that does this kinda thing)
00:35:23 <liste> koz_: this looks very readable: http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/origami.pdf
00:36:08 <koz_> liste: Thanks!
00:36:25 <koz_> Also, does anyone here know of any game jams specifically for functional languages (or specifically Haskell)?
00:36:37 <liste> yw (:
00:37:10 <shanemikel> I just bought that book liste 
00:37:10 <ggVGc> koz_: what would be the point of that? I am not sure of any game jams that are specific to any languages really
00:37:26 <shanemikel> really glad too.. the name is really right, it has a lot of fun exercises
00:37:37 <koz_> ggVGc: Lisp Game Jam is one I know of.
00:37:44 <ggVGc> ah, okay
00:37:46 <koz_> (just concluded recently)
00:37:50 <ggVGc> well, it seems like a strange restriction to me
00:38:06 <koz_> ggVGc: Yeah, guess it is.
00:38:10 <koz_> Figured I'd ask though.
00:38:45 <ggVGc> I think  "software jam in X" is reasonable and "X jam in whatever", but I don't see the point of "X jam in Y"
00:39:15 <ggVGc> the first one shows what people choose to build in language/platform X, which is fun to see. The second shows what games people build given whatever tools they want and a certain time, which is also fun
00:39:27 <ggVGc> but with both restrictions I dont see the point
00:41:01 <ggVGc> koz_: either way, if you make a website announcig a haskell game jam, tehre will be one!
00:41:04 <ggVGc> I might join
00:42:26 <koz_> ggVGc: Lol, I was thinking of being a participant rather than an organizer.
00:42:55 <ggVGc> well, sometimes when you want to participate in something you have to start it first
00:43:17 <koz_> ggVGc: This is true.
00:44:14 <koz_> Also, what *is* the latest thing for datatype-generic programming?
00:44:57 <liste> koz_: GHC Generics
00:45:10 <koz_> liste: Any good explanatory writeups for those?
00:46:34 <liste> koz_: you could try this one: http://jozefg.bitbucket.org/posts/2014-04-25-you-could-have.html
00:46:53 <koz_> liste: Awesome, thank you!
00:51:02 <akfp> belief propagation in haskell.  is there an implementation of it?
00:57:39 * hackagebot structural-traversal 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/structural-traversal-0.1.0.0 (lazac)
01:01:03 <superlinux> hello. can someone explain to me the meaning of the exclamation mark in : let !z = i+1 in (z, ()) 
01:01:06 <koz_> What does the ~ indicate where type families are concerned? Is it type equivalence?
01:01:15 <koz_> superlinux: Evaluate z strictly.
01:01:20 <bergmark> koz_: correct
01:01:22 <koz_> (i.e. don't be lazy)
01:01:30 <koz_> bergmark: Thanks!
01:01:59 <superlinux> ah! so you mean the compiler must not wait in the computation as usual. isn't?
01:02:22 <superlinux> i mean it must not delay it
01:02:40 * hackagebot instance-control 0.1.0.0 - Controls how the compiler searches for instances using type families.  https://hackage.haskell.org/package/instance-control-0.1.0.0 (lazac)
01:04:15 <koz_> superlinux: It means that z has to be evaluated completely, whether we need it to be or not.
01:04:41 <superlinux> understood! now makes sense
01:04:52 <koz_> superlinux: Haskell basically does as little as possible by default.
01:06:24 <Cale> koz_: The constraint (a ~ b) in a type says that a and b must be equal as types
01:06:55 <koz_> Cale: OK, that makes sense. Thanks.
01:07:05 <koz_> Trying to understand Haskell stuff properly can sometimes be a bit challenging.
01:07:40 * hackagebot references 0.3.0.1 - Selectors for reading and updating data.  https://hackage.haskell.org/package/references-0.3.0.1 (lazac)
01:08:45 <superlinux> Haskell grammar to me is like Arabic grammar ☺
01:09:04 <koz_> superlinux: Haskell actually has a very easy syntax.
01:09:37 <superlinux> koz_, reading the code is hard.
01:10:43 <superlinux> sometimes you wouldn't know where each thing is supposed to be comprehended
01:10:53 <koz_> superlinux: I dunno - I find Haskell pretty readable.
01:11:08 <koz_> (although I sometimes am left going 'woah, that is a really cool way to do that!
01:11:10 <koz_> ')
01:11:41 <superlinux> yeaahh I get those "wows"
01:11:55 <superlinux> It really intrigues me
01:12:50 <koz_> More precisely, this: https://www.youtube.com/watch?v=WFNEgdwjEhs
01:12:59 <Squarism> Hey.. ive bought "Real World Haskell" and "Programming in Haskell". I understand these are "beginner level". What are suitable books after that?
01:13:35 <koz_> Squarism: I would say 'Typeclassopedia' is practically required post-beginner reading, but it's not a book.
01:13:59 <Squarism> so what is it?
01:14:06 <shanemikel> on the haskelll wiki
01:14:13 <koz_> Squarism: https://wiki.haskell.org/Typeclassopedia
01:15:29 <shanemikel> and, http://dev.stephendiehl.com/hask/ is a nice birds eye view, and reference, in case you forget what some jargon means
01:15:50 <shanemikel> he also has other great stuff on his website
01:16:35 <Squarism> koz_, shanemikel - thanks 
01:16:46 <Squarism> both seem really useful at a glance
01:16:53 <koz_> Squarism: You're welcome! A lot of the stuff the Typeclassopedia links to is also very helpful.
01:17:12 <Squarism> too bad they arent suited for reading in the sun
01:17:26 <koz_> I dunno - my tablet manages OK.
01:17:41 <shanemikel> I just bought "The Fun of Programming" which is full of really cool entry-level domain-specific examples.. also, check out the Monad Reader (digital periodical) and the wiki page for "Functional Pearls"
01:18:19 <koz_> shanemikel: When was 'The Fun of Programming' published? Also, is it Haskell-specific?
01:18:26 <shanemikel> yeah
01:18:35 * geekosaur finds the comparison to Arabic interesting, considering that Arabic has equational sentences >.>
01:19:07 <koz_> geekosaur: Interesting.
01:19:07 <shanemikel> koz_: thats where the "Origami" pdf somebody linked to you is published in
01:19:14 <Squarism> 2003?
01:19:25 <geekosaur> (you have sentences with a subject, an object, and no verb; the missing verb is "is")
01:19:36 <koz_> shanemikel: Ah, OK.
01:19:42 <koz_> Now I *definitely* need a copy.
01:19:42 <shanemikel> yeah, 2003
01:20:41 <EvanR> "I think it's important to get past the stage of being comfortable with an instrument. You need the capacity to learn - most people tend to stay at the same level, which [I think] is boring to listen to." -- robert smith
01:20:57 <EvanR> relevant to functional programming i think
01:21:24 <shanemikel> what's up EvanR.. some were speaking on the recent development to drop FRP
01:22:25 <shanemikel> earlier
01:22:33 <Squarism> also.. is there a haskell book that you could recommend to people - not very interrested in programming, but maybe can be accessible and fun enough to make them read. Using the motivation, "you need to learn FP, its the next big thing"
01:22:41 * hackagebot servant 0.7.1 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.7.1 (SoenkeHahn)
01:22:59 <Squarism> for imperative programmers in the industry
01:23:12 <koz_> Squarism: Learn You A Haskell For Great Good?
01:23:38 <koz_> Although realistically, I'm not sure if that makes the case for 'functional programming' per se.
01:23:46 <shanemikel> no, the tone of that book is not great for mature programmers
01:23:51 <koz_> It is *definitely* accessible and fun.
01:24:13 <koz_> But yeah, if you wanna target mature programmers, then it's not the best call.
01:24:38 <bernalex> I don't think I would recommend any books for learning FP to people who are not interested in programming.
01:25:17 <shanemikel> I think any programmer with an imperative background can appreciate the sophisticated nature of polymorhism in functional languages
01:25:18 <Squarism> bernalex, they dont deserve it right? =D
01:26:20 <bernalex> if they aren't interested in programming, then why on earth would they read a book about learning fp? no matter how good the book on elephant anatomy were, I wouldn't really be reading it anyway since I'm not that interested in elephants.
01:26:47 <aarvar> bernalex: I assume he meant functional programming and left out the word functional
01:27:18 <bernalex> I just realised the reason my mind went to "elephants" without thinking about it, is because of the lyah cover.
01:27:53 <bernalex> aarvar: it still applies then. if they are not interested in functional programming, they won't be successful at learning it from reading a book they would only pick up when motivated to do so.
01:27:59 <shanemikel> the "Fun of Programming" book I just mentioned, may be good for that (It has a chapter on quickcheck, which is a real "Killer" app if you ask me).. and, perhaps the Scrap your boilerplate papers are pretty amazing
01:28:52 <superlinux> guess what!? I have been since last October translating the book Learn You Haskell to Arabic using YouTube. now i am in chapter 9. this month i am now tutoring two girls doing their Masters degree which includes Haskell. I am helping them in making a presentation based on the book Parallel and Concurrency Programming in Haskell.
01:29:13 <shanemikel> anything showcasing the possibilities of generic programming, in general (People tend to think generic programming and static types are incompatible, nowadays)
01:29:37 <koz_> shanemikel: I'm not sure I agree with that.
01:29:47 <shanemikel> agree with what?
01:29:56 <koz_> When you say 'genericity' to Joe Programmer, they tend to think C++ templates.
01:30:02 <koz_> And C++ is pretty darn statically typed.
01:30:18 <EvanR> generics are whatever was tacked onto a language after-the-fact
01:30:34 <shanemikel> yeah, but AFAIK (I'm no C++ programmer), ad-hoc polymorphism is really painful in C++
01:30:38 <Squarism> bernalex, theres alot of people o regard their "programming job" just a "job" and want to use spare time to all but programming
01:30:42 <EvanR> haskell polymorphism is part of the language, generics in haskell tacked on after-the-fact
01:31:01 <EvanR> monotypedness of variables in c++ is part of the language, templates tacked on after-the-fact
01:31:03 <bernalex> shanemikel: the typesystem in general tends to really surprise people, who kind of think about typesystems as "that thing that gets in your way and makes you write a bunch of crap that doesn't really solve anything", because they're used to static types == ALGOL 60.
01:31:17 <bernalex> Squarism: yes, and those people won't learn haskell for fun in their sparetime.
01:31:19 <Squarism> still engaged at work and put pride in delivering quality code
01:31:20 <EvanR> same same same in java, generics tacked on after the fact (equiv to haskell polymorphism)
01:31:51 <bernalex> generic in haskell and java were interestingly tacked on by the same person.
01:31:55 <bernalex> generics*
01:32:13 <koz_> bernalex: Seriously?
01:32:39 <aarvar> wadler?
01:32:56 <bernalex> yes. but tbf lots of other people were involved with both processes.
01:33:17 <shanemikel> yeah, but Java's pretty okay for ad-hoc stuff, it's really the paradigm that discourages generic programming.. if you use interfaces religiously, it's not impossible
01:33:17 <koz_> bernalex: Well, Java's generics make me vomit, while Haskell's make me jump for joy.
01:33:36 <bernalex> wadler worked on pizza (with odersky), and he made GJ, and in general has written a lot of books and papers about generics in java.
01:34:01 <shanemikel> I mean, the reall killer for us, is no ((->) r) type, but other things are doable
01:34:20 <koz_> Eh, I'd never go back to Java now that I have Haskell.
01:34:30 <koz_> Haskell is basically (for me) the ideal high-level language.
01:34:45 <bernalex> any imperative language feels more or less like assembly to me now.
01:34:46 <shanemikel> I don't think you're alone :)
01:35:01 <koz_> shanemikel: Well, 1455 other people at least seem to agree. :P
01:35:20 <shanemikel> but, It's one of the better mainstream languages for polymorphism, AFIACT
01:35:36 <bernalex> haskell is the only nearly mainstream language that I find tolerable.
01:35:47 <koz_> bernalex: Likewise.
01:35:54 <shanemikel> swift, so I've heard, is more or less modern
01:35:58 <koz_> For the others, it's a question of how fast I vomit.
01:35:58 <bernalex> elm doesn't make me cry myself to sleep either, though I much prefer haskell.
01:36:08 <bernalex> shanemikel: swift is terrible. at least as a "functional" language.
01:36:22 <koz_> Swift is a bunch of warmed-over ideas from about 20 years ago.
01:36:31 <koz_> They seriously believe we should consider *lambdas* a huge advance.
01:36:34 <bernalex> but I welcome apple in to the '80s in terms of language design.
01:36:36 <koz_> (according to their site)
01:36:49 <shanemikel> is it? I was under the impression the type system was Hindley-mindler
01:36:55 <geekosaur> compared to objc...
01:37:03 <koz_> geekosaur: Not much of a comparison.
01:37:05 <EvanR> 20 years ago = 1996
01:37:12 <EvanR> i think
01:37:13 <koz_> shanemikel: I'm pretty sure it's not full HM.
01:37:21 <koz_> But I *could* be wrong there.
01:37:30 <bernalex> they also touted a bunch of other "amazing" features that ML had in like '73.
01:37:46 <bernalex> you can't even do function composition in swift. *yawn*.
01:37:52 <EvanR> 20 year ago is approaching the year of "all your base"
01:37:52 <koz_> bernalex: Yeah - I even wrote a whole blogpost about that: http://retro-freedom.nz/blog/2015/12/04/on-swift-freedom-and-not-one-fuck-was-given/
01:37:54 <shanemikel> really?
01:38:00 <geekosaur> koz_, but that's the point. apple's been objc-based forever (and before that, pascal)
01:38:10 <shanemikel> bernalex: no composition?
01:38:10 <koz_> </shameless_self_promotion>
01:38:24 <koz_> geekosaur: If they wanna live in the Stone Age, that's their issue.
01:38:42 <koz_> But I object to them promoting 20+-year-old features as something new and brilliant in their shitty new language.
01:38:43 <geekosaur> so, for them, it's a big advance that their ecosystem is no longer based on a graft of Smalltalk's OO into C
01:38:45 <koz_> Sorry 'new'.
01:38:49 <phadej> that's quite a leap from obj-c to something like ghc-8-haskell
01:38:56 <phadej> so in a sense, understandable
01:39:05 <phadej> also they need obj-c interop
01:39:18 <phadej> i.e. story of Scala
01:39:27 * koz_ is just glad he doesn't have to deal with shitty 'industry' languages.
01:39:32 <bernalex> phadej: yes it makes perfect sense. they need objc interop, and they want people to still feel like it's a familiar language, and not go off write android apps instead.
01:39:44 <koz_> As a PhD student, I can write in anything and nobody gives any fucks as long as I show results.
01:39:48 <shanemikel> well, there has to be SOME industry peddled language that's worth an honorable mention
01:39:57 <koz_> shanemikel: As what, an awful warning?
01:40:04 <bernalex> so in terms of language design, it's a big yawn. but, knowing their audience, they tout ADTs and lambdas as "the next big thing" and super innovative.
01:40:18 <koz_> bernalex: Yeah - their audience probably believes it too.
01:40:19 <EvanR> whoa. wtf, is this a non-haskell bashing session
01:40:44 <EvanR> inappropriate
01:40:52 <geekosaur> apple bashing session, I think >.>
01:41:06 <koz_> geekosaur: I dunno - I just get mad easily methinks.
01:41:20 <shanemikel> EvanR: it hasn't begun to get inappropriate
01:41:30 <EvanR> its begun
01:41:31 <shanemikel> I think that's a bit reactionary
01:41:37 <bernalex> EvanR: I'm hosting a haskell bashing session tonight.
01:41:54 <bernalex> like 90 pps of "why haskell sucks'
01:41:58 <simpson> bernalex: I'm in.
01:42:00 <geekosaur> just remember that apple knows that its audience is well captured by http://www.engadget.com/2015/09/09/comic-predicted-ipad-pro-keyboard/
01:42:13 <EvanR> bernalex: that has not happened yet?
01:42:14 <bernalex> simpson: it's at the main hospital in Trondheim at 6pm.
01:42:19 <geekosaur> (not sure I can find a direct link to the comic that won't have referer issues)
01:42:36 <koz_> geekosaur: Yep, and they exploit this fact with merciless abandon.
01:42:45 <bernalex> EvanR: no. the reddit thread only recently settled, and I do have to actually work (well above) full time.
01:43:00 <simpson> bernalex: I won't be able to attend in person; you can find attached my talk, "Set is not a Monad; and, other Collected Gripes and Grievances".
01:43:09 <shanemikel> bernalex: https://www.objc.io/blog/2014/10/13/functional-snippet-2-function-composition/ ??? is this missing something like variable arity of f?
01:43:20 <shanemikel> otherwise, it looks like composition to me
01:43:42 <bernalex> simpson: you sound like you would have been a very fun person to have around for the after-presentation discussions.
01:43:48 <shanemikel> is zipper a monad?
01:44:01 * EvanR imagines the "compromise" that makes Set a Monad and all that is haskell instantly dies
01:44:17 <bernalex> shanemikel: function composition is pointless in swift. it's a strict language. and most libraries aren't written to facilitate it. and there's no currying.
01:44:30 <shanemikel> oh...
01:44:52 <EvanR> stuff that makes set into a monad makes haskell into clojure
01:44:53 <shanemikel> well, okay. that's what I get for optimism
01:44:55 <geekosaur> the other way in which swift counts as an advance is that it looks rather like javascript with an actual type system
01:45:06 <koz_> geekosaur: You mean TypeScript right? :P
01:45:12 <geekosaur> (of couirse there are others that do that)
01:45:35 <shanemikel> at one point I was curious if there's a typed lisp
01:45:50 <bernalex> shanemikel: typed racket seems to be the best option there.
01:45:59 <geekosaur> pretty sure there have been a few, yes
01:46:04 <koz_> bernalex: Is Typed Racket statically-typed?
01:46:08 <EvanR> koz_: so javascript with an actual type system.. check infernu https://github.com/sinelaw/infernu
01:46:18 <koz_> I mean, type annotations have been around since Common Lisp *at least*.
01:46:34 <bernalex> koz_: yes.
01:46:45 <koz_> bernalex: Huh. Well, now I *have* seen everything.
01:47:04 <bernalex> there's also lazy racket. but I don't think there's a lazy typed racket. which is a bit bizarre to me.
01:47:10 <EvanR> check shen for a typed lisp with a seriously powerful type system
01:47:31 <EvanR> i.e. the type system is programmable in lisp
01:47:35 <geekosaur> ...the problem with the other javascript-with-types is none of them is really in any position to be anything other than "interesting javascript fork" wrt the mainstream
01:47:36 <bernalex> in typed racket you'd do things like (: f (Int -> Int -> Int)) (define (f ...
01:47:40 <bernalex> EvanR: oh yeah, there's shen too.
01:47:58 * koz_ will stick to Haskell for now.
01:48:09 <koz_> It's a tricky enough language to master without adding more to my workload, lol.
01:48:16 <bernalex> was shen by that guy who made that other lisp that was looking cool, but then the compiler was proprietary and everything was proprietary, so nobody ever used it
01:48:19 <shanemikel> EvanR: that sounds like yet another dangerous muse
01:48:45 <bernalex> I don't remember its name, but it was something else zen-like.
01:48:47 <shanemikel> what about the typed clojure I've heard about
01:48:49 <koz_> bernalex: Yes.
01:48:56 <koz_> shanemikel: Type annotations AFAIK.
01:49:00 <EvanR> a lot of complexity is haskells type system is mean to avoid possibly non-terminating type checking
01:49:02 <koz_> (although I could be wrong)
01:49:03 <bernalex> shanemikel: core.typed.
01:49:27 <EvanR> and then undecidable instances...
01:49:34 <geekosaur> nobody tell shanemikel about omega >.>
01:49:35 <bernalex> core.typed is static typing.
01:49:51 <bernalex> uh
01:49:56 <bernalex> I missed a "not" in there. :p
01:50:18 <EvanR> core.typed is dynamic typing
01:50:21 <EvanR> i.e. contracts
01:50:26 <bernalex> iirc the core.typed readme even specifically said something like "it's not as good as haskell, but hey, at least it catches some bugs"
01:51:06 <koz_> Could someone help me out a bit here? http://lpaste.net/162998 <-- I'm having trouble understanding the idea behind this
01:51:34 <shanemikel> is it just me EvanR, or is shen a lisp machine?
01:52:00 <EvanR> shen is just a basic lisp with a type checker
01:52:13 <EvanR> but the type checker can be programmed with lisp
01:52:45 <geekosaur> koz_, did you read on past those definitions?
01:53:00 <koz_> geekosaur: I did, but I still don't really get it.
01:53:14 <geekosaur> "It’s not terribly relevant to the rest of this post, but useful in some odd cases."
01:53:22 <shanemikel> shenlanguage.org mentions a "OS Kernel", and a proprietary "Professional kernel"
01:53:26 <koz_> geekosaur: Isn't that specific to M1?
01:53:43 <geekosaur> but K1 exists to convey information to M1
01:54:08 <geekosaur> you can think of this as threading a state monad through it, but the state lives in the types and not the data
01:54:14 <EvanR> shanemikel: ... its an odd progression, the guy also invented a similar language "Ki" which has since been abandoned
01:54:30 <koz_> Ah, so 'i' and 'c' are the 'state'?
01:54:32 <geekosaur> K1 lets you annotate a type with the state
01:54:41 <EvanR> or "Qi"
01:54:42 <geekosaur> M1 threads the state through the computatuon
01:54:57 <koz_> geekosaur: OH! OK, that makes sense.
01:55:01 <koz_> Thanks.
02:14:00 <shanemikel> anybody know about the ETA on backpack?
02:17:18 <geekosaur> http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/
02:18:08 <geekosaur> cabal-install 1.24 is released; however backpack is still a preview with known bugs
02:19:14 <geekosaur> but they're letting it into the wild because (a) it's already better than the old build stuff in many cases (b) to find and fix as many bugs as possible before making it the default
02:22:48 <Rembane> How does this differ from how stack handles stuff?
02:23:48 <shanemikel> no package distribution
02:24:30 <shanemikel> http://blog.ezyang.com/2014/08/whats-a-module-system-good-for-anyway/
02:27:32 <shanemikel> basically, stack solves the problem of maintaining sandboxes, and also provides a "distro" (much like a linux distro) of package versions that are known to work together.. this is approaching from a different perspective, first, solve the sandbox problem, then, instead of providing a distro (where a central authority has to audit packages, necessarily creating an environment that is apprehensive about adopting new packages), provide a
02:27:32 <shanemikel> more meaninful versioning system
02:28:34 <Rembane> shanemikel: Thank you, that's exactly the explanation I needed to understand this.
02:31:43 <nomeata> I’ll give a a talk „Haskell for Mathematicians“ tomorrow. Are there any libraries or projects of interest to a topologist that I should point out?
02:32:08 <Aruro> nomeata: how is haskell good for Mathematicians?
02:32:49 <Aruro> nomeata: even maxima is more advanced :)
02:33:16 <nomeata> Still, mathematicians I know use C++... there is room for improvement.
02:33:38 <Aruro> nomeata: maybe for numerics?
02:33:53 <Aruro> physicists also use C++ lol :D
02:36:53 <Jinxit> who was it in here that was working on neural nets in haskell?
02:38:19 <Aruro> sombody was rather familiar with it
02:38:23 <Aruro> i think ertes was
02:38:29 <Aruro> not sure.
02:43:22 <akfp> Rembane: cabal new-build will "just work" IF package bounds and dependencies are correct for all packages you depend on.  stack will "just work" IF all packages you depend on are in stackage.  stack has stronger guarantees, but supports less packages.
02:46:49 <Rembane> akfp: Aha. Nice!
02:47:33 <deepfire> geekosaur: do you mean to say that backpack is somehow related to nix-style build?
02:48:45 <deepfire> geekosaur: I'm asking because to my understanding there is no relation..
03:28:26 <fr33domlover> Is there a commonly known flipped 'fmap' or flipped <$>?
03:28:42 <fr33domlover> Much like 'for' is a flipped 'traverse' and so on
03:29:22 <fr33domlover> Could call it 'with' :P
03:29:53 <maerwald> :t for
03:29:54 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
03:31:24 <Xnuk> > ($) . (:) $ 'a' []
03:31:26 <lambdabot>      Couldn't match expected type ‘[t0] -> r’ with actual type ‘Char’
03:31:27 <lambdabot>      The function ‘'a'’ is applied to one argument,
03:31:27 <lambdabot>      but its type ‘Char’ has none
03:31:51 <Xnuk> > (($) . (:)) 'a' []
03:31:52 <lambdabot>  "a"
03:33:10 <lyxia> fr33domlover: <&>
03:34:40 <Aruro> btw why ordering of arguments can not be infered by compiler in case they are not same?
03:34:59 <maerwald> uuh
03:35:12 <maerwald> I smell a whole new class of bugs
03:35:43 <Aruro> if types are different should be no bugs :)
03:38:17 <fr33domlover> Aruro, what if you change some code and suddenly they are?
03:38:44 <fr33domlover> such assumptions are a recipe for trouble :P
03:39:19 <maerwald> Aruro: the problem in your sentence is "should"
03:39:55 <fr33domlover> lyxia, thanks. But that comes from lens... I'll just use flip fmap
03:40:44 <lyxia> you can't use these functions to restrict the types of certain variables anymore
03:41:27 <maerwald> it sounds like turning compiler errors into undefined runtime behavior :P
03:42:39 <maerwald> fr33domlover: maybe add such a function to an alternative prelude or something if it isn't there already
03:44:02 <maerwald> https://hackage.haskell.org/packages/#cat:Prelude
03:45:50 <maerwald> as proper infix operator
03:57:42 <zoran119_> can someone tell me how to start a new snap project using stack?
03:57:59 <zoran119_> cannot find an example anywhere...
03:58:47 <maerwald> zoran119_: snap init
03:58:50 <maerwald> http://snapframework.com/docs/quickstart
04:01:15 <zoran119_> maerwald: i usually do setup a cabal sanbox, install snap there, then do snap init. does stack replace these steps or add to them?
04:02:40 <maerwald> I don't use stack. But the "snap init" step will not change. There's also a snap channel: #snapframework
04:02:47 <statusfailed> Is it possible to browse hackage packages by path? e.g. all packages under "Control.Monad" 
04:05:05 <bergmark> statusfailed: i don't think so, but stackage an index https://www.stackage.org/lts-5.16/docs
04:05:19 <Cale> statusfailed: Interesting idea, though it's not really much more meaningful than a text search of the modules, since the "hierarchy" of modules doesn't actually mean anything -- '.' is just a valid character in module names.
04:06:18 <Cale> (well, it also helps GHC know where to look for source code)
04:07:48 * hackagebot xml-conduit 1.3.5 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.3.5 (MichaelSnoyman)
04:11:16 <zoran119_> i did 'cabal configure -fdevelopment'. how can i 'undo' this?
04:11:30 <dcoutts> zoran119_: cabal configure
04:11:47 <dcoutts> assuming the 'development' flag defaults to False
04:12:41 <aloiscochard> hi there, does anyone knows where I can find documentation about how the GSoC projects are handled?  how vote happen, etc, .. thanks!
04:12:48 * hackagebot extra 1.4.6 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.6 (NeilMitchell)
04:15:29 <zoran119_> dcoutts: excellent, thanks
04:42:50 * hackagebot d3d11binding 0.0.0.7 - A raw binding for the directX 11  https://hackage.haskell.org/package/d3d11binding-0.0.0.7 (jwvg0425)
05:20:44 <martinvlk> Hi, with the lenses library, is it possible to use the "over" function to add an element to a structure, as opposed to replace an existing one?
05:26:08 <Jinxit> martinvlk: that
05:26:17 <Jinxit> oops, *that's not really what lens does
05:27:03 <Jinxit> you could do "xs %= (|> x)"
05:27:43 <Jinxit> but I don't recommend it
05:28:01 <zeawee> Hi guys, what open source haskell projects would you recommend to get involved in haskell development?
05:28:27 <hpc> pandoc is rather readable
05:31:41 <bernalex> zeawee: GHC.
05:32:45 <zeawee> bernalex: wow! isn't it a bit hardcore?
05:33:37 <bernalex> zeawee: I don't think so. it has a great bug tracker, it's got a rather big community of helpful people, it's well documented, etc.
05:35:02 <zeawee> bernalex: thank you! hpc: thanks!
05:36:20 <hexagoxel> zeawee: related current blog entry: http://www.arcadianvisions.com/blog/2016/ghc-contributing.html
05:37:38 <zeawee> hexagoxel: thanks!
05:40:20 <bernalex> zeawee: if you want to work the "where can my contributions be the most beneficial to others"/low-hanging-fruit angle -- check http://www.haskellforall.com/2016/02/state-of-haskell-ecosystem-february.html
05:40:39 <bernalex> and the original version (which it links to)
05:40:56 <bernalex> actually the one I linked is pretty much just an update -- definitely read the original first.
05:41:39 <zeawee> I am using vim for my development, and expected to find some plugins for haskell for perfect autocompletion, syntax checking on the fly, etc. but could only find ghcmod-vim, vimproc.vim, neco-ghc... these only work for haskell core libraries, don't recognize the modules in the project. Do you have any suggestions for haskell development in vim?
05:42:12 <zeawee> since haskell is statically typed, I thought these things would not be hard to find.
05:42:52 * hackagebot lambdacube-gl 0.5.0.5 - OpenGL 3.3 Core Profile backend for LambdaCube 3D  https://hackage.haskell.org/package/lambdacube-gl-0.5.0.5 (CsabaHruska)
05:43:34 <bernalex> zeawee: check out haskell-vim-now (search for its github). I don't use it because I don't like those sort of deals that "take over" your vim, but I use a lot of the stuff that it provides by installing it myself.
05:44:41 <bernalex> emacs is in general ahead of vim though, for haskell (and I guess plugins in general). if you want to write haskell tools for vim -- feel very encouraged to do so. it would be greatly appreciated by me, and others I'm sure. :)
05:45:20 <maerwald> haskell-vim-now is just a broken shell script
05:46:15 <zeawee> yea... in general, for most of the functional programming languages, emacs is far ahead of vim in terms of plugins.
05:47:18 <zeawee> hopefully this will change with the vim 8.0 version, it will have non-blocking I/O support.
05:47:52 * hackagebot hw-prim 0.0.0.12 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.0.12 (haskellworks)
05:48:48 <maerwald> zeawee: also, it's not correct that neco-ghc only works for haskell core libraries
05:49:01 <maerwald> works pretty well on project modules for me as well
05:50:02 <maerwald> it just utilizies ghc-mod and depends on your module imports afais
05:51:19 <zeawee> maerwald: https://github.com/eagletmt/neco-ghc/issues/44
05:52:52 * hackagebot GLURaw 2.0.0.2 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/GLURaw-2.0.0.2 (SvenPanne)
05:53:54 <maerwald> oh, I guess that's my fuzzy youcompleteme completion then
05:53:55 <defanor> i'm using a TMVar to implement graceful exit now, but apparently it's not enough to handle blocking IO actions, and it's a bit cumbersome; found the `graceful` library, which seems to be helpful, but it still requires to handle signals from each worker process manually in order to exit gracefully from those; i'd like something that would allow to wrap small IO (or, rather, MonadIO) actions, like `s <- gracefully FineToQuitHere $ accept
05:53:55 <defanor> ...`, providing a finer control on termination. are there any other libraries, or common approaches to it?
05:56:22 <maerwald> zeawee: and it works perfectly fine if you did "cabal install" in your sandbox previously
05:56:28 <maerwald> so I'd say it works indeed
05:56:41 <maerwald> just not without it being installed
05:57:06 <maerwald> and only if you have the relevant imports
06:01:56 <maerwald> zeawee: did you try that?
06:04:33 <maerwald> so neco-ghc completion works for _all_ installed libraries (including your own project, if that is installed)
06:06:03 <Aruro> are GADT extension and unsafeCoerce related?
06:11:01 <hexagoxel> defanor: like the `async` package? i have recently written some ugly stuff for shutting down multiple threads "gracefully", but i don't understand if that matches what you want exactly.
06:11:24 <dredozubov> Aruro: ghc uses system FC(system F with coercions), so technically yes
06:11:45 <dredozubov> but it's safe coerces
06:12:15 <dredozubov> in that way they're not really related
06:13:53 <zeawee> maerwald: I'm not using youcompleteme, and neither did "cabal install", just expected the autocompletion to work seemlessly as I type like in java IDEs, even dynamically typed clojure has that support in vim with some plugins...
06:14:15 <defanor> hexagoxel: i guess `async` may help there, particularly to deal with blocking IO actions, but it won't solve the whole problem yet. that is, i'd like a handy api with minimal boilerplate. thinking of writing a library for that now, but i suspect that there should be something already
06:14:19 <bernalex> maerwald: ur not on xmpp QQ
06:14:20 <maerwald> zeawee: it works when you do cabal install
06:14:24 <Aruro> dredozubov: ty
06:14:28 <maerwald> without youcompleteme
06:14:31 <ARM9> what if you use stack
06:15:22 <maerwald> bernalex: our jabber servers don't like each other I think
06:16:31 <maerwald> zeawee: 1. do "cabal install" in your project folder, 2. import a module from your project, 3. try auto-completion for a function of that imported module from your own project
06:16:32 <maerwald> works fine here
06:17:54 * hackagebot OpenGL 3.0.1.0 - A binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGL-3.0.1.0 (SvenPanne)
06:17:56 * hackagebot hw-rankselect 0.0.0.4 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.0.0.4 (haskellworks)
06:18:45 <zeawee> yea..
06:20:53 <zeawee> maerwald: thanks
06:21:28 <maerwald> it's a little bit awkward though, would be nicer if it picks symbols up as you go
06:22:35 <maerwald> I also don't remember if there are side-effects if your "installed" version differs from your current source files. In the sense which interface it picks up.
06:22:36 <zeawee> yea... maybe I would write a plugin for it in the future. just will wait for vim 8
06:23:34 <hexagoxel> defanor: what i currently do is use a custom forkIO and store the threadId in some global variable :: [ThreadId]. shutting down means sending some exceptions to all those threads. it seems to be the most straight-forward approach. i am not aware of any related libraries.
06:29:30 <defanor> hexagoxel: ah, i see -- that's approximately what the `graceful` package does. but i want to control things on small IO actions level, not just by raising exceptions in threads or sending signals to child processes. that is, quite often the finalization routine depends on an action on which the process was interrupted (or an error occured), while plain exceptions are not quite helpful with that
06:30:17 <defanor> and then there are critical parts, which shouldn't be interrupted at all, if possible
06:31:57 <hexagoxel> defanor: sounds a bit like http://hackage.haskell.org/package/resourcet-1.1.7.3/docs/Control-Monad-Trans-Resource-Internal.html#t:ResourceT
06:32:35 <hexagoxel> although "depending on" might be more general than that.
06:32:36 <defanor> hexagoxel: oh, i didn't try it -- looks interesting. will check now, thanks
06:36:51 <hexagoxel> defanor: if you end up publishing a new library, please ping me; i'd like to see what interface you decide on.
06:37:41 <defanor> hexagoxel: sure
06:52:55 * hackagebot GLUT 2.7.0.8 - A binding for the OpenGL Utility Toolkit  https://hackage.haskell.org/package/GLUT-2.7.0.8 (SvenPanne)
06:57:55 * hackagebot octane 0.4.20 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.20 (fozworth)
07:09:53 <magneticduck> to make a Monad typeclass instance for a type, I have to define a typeclass instance for Applicative and Functor first?
07:10:11 <magneticduck> the Applicative and Functor definitions can be derived from the Monad definitions of course
07:10:16 <magneticduck> isn't there some way to do that implicitly?
07:12:14 <magneticduck> otherwise I think I'm just going to define hidden aliases for the bind and return operators, and define Functor, Applicative, and Monad with them
07:12:31 <magneticduck> the definitions are trivial but kind of verbose
07:12:52 <magneticduck> that seems like a bit of a hack tbh, why isn't there some way to derive Functor and Applicative from Monad implicitly?
07:14:29 <magneticduck> the next best thing would be to have a MonadDerive typeclass that defined operators equilivant to Monad but with nonconflicting symbols, and then define instance (MonadDerive m) => {Functor,Applicative,Monad} m
07:14:35 <magneticduck> does that exist?
07:14:42 <magneticduck> am I not understanding something?
07:15:19 <mpickering> no
07:16:29 <magneticduck> I guess WrappedMonad does something a little bit like this
07:16:40 <magneticduck> uh, never mind actually
07:16:42 <mpickering> Others feel the same way,  you can google "instance chains" 
07:16:58 <magneticduck> so, what's the accepted solution for my problem?
07:17:04 <Zemyla> magneticduck: WrappedMonad doesn't do anything now that Applicative is a superclass of Monad.
07:17:45 <magneticduck> indeed
07:18:21 <Zemyla> magneticduck: "instance Functor MyMonad where fmap = liftM; instance Applicative MyMonad where { pure = return; (<*>) = ap; (*>) = (>>) }"
07:19:30 <magneticduck> ah right
07:19:57 <Zemyla> Though I always explicitly define Functor and Applicative instances, because they often are more efficient than just using liftM/ap.
07:20:43 <Zemyla> Though for any Monad that's in CPS style, it winds up being the same.
07:24:33 <hpc> Zemyla: any cps-style monad? how does that work?
07:24:53 * hpc hasn't thought about it much and it makes a certain amount of sense, but is still surprising
07:25:18 <Zemyla> Let's take Cont r as an example.
07:26:15 <Zemyla> Cont m >>= f = Cont $ \c -> m $ \a -> runCont (f a) c.
07:26:45 <Zemyla> return a = Cont ($ a)
07:27:07 <hpc> indeed
07:28:07 <Zemyla> liftM f m = m >>= (return . f). return . f = \a -> return (f a) = \a -> Cont $ \c -> c (f a).
07:29:32 <hpc> oh, that one period is a period
07:29:34 <hpc> @src liftM
07:29:34 <lambdabot> liftM f m1 = do
07:29:34 <lambdabot>     x1 <- m1
07:29:35 <lambdabot>     return (f x1)
07:29:49 <Zemyla> Cont m >>= (return . f) = Cont $ \c -> m $ \a -> (\c -> c (f a)) c = Cont $ \c -> m $ \a -> c (f a).
07:30:15 <Zemyla> And that is the definition of fmap for the Cont monad.
07:31:35 <Zemyla> Similarly, ap winds up being ap (Cont mf) (Cont ma) = Cont $ \c -> mf $ \f -> ma (c . f).
07:32:55 <Zemyla> @djinn (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> (b -> r) -> r
07:32:56 <lambdabot> f a b c = b (\ d -> a (\ e -> c (e d)))
07:33:46 <Zemyla> The definition djinn produces is backwards.
07:34:08 <srhb> Zemyla: That's just, like, your opinion!
07:34:29 <Zemyla> It executes effects in the wrong order.
07:34:47 <hpc> the reverse Cont monad
07:38:54 <hexagoxel> it is unfortunate that @djinn only prints the "first" solution..
07:39:36 <hpc> well, it is irc
07:39:44 <hpc> and djinn can bet verbose
07:39:45 <prohobo> damn u djinn
07:40:19 <hpc> @djinn Either (a -> b) (a -> b) -> Either (b -> d) (b -> c) -> a -> Either c d
07:40:19 <lambdabot> f a b c =
07:40:19 <lambdabot>     case a of
07:40:19 <lambdabot>     Left d -> case b of
07:40:19 <lambdabot>               Left e -> Right (e (d c))
07:40:19 <lambdabot>               Right f -> Left (f (d c))
07:40:21 <lambdabot>     Right g -> case b of
07:40:23 <lambdabot>                Left h -> Right (h (g c))
07:40:25 <lambdabot>                Right i -> Left (i (g c))
07:40:37 <hpc> whoops, that was longer than i intended
07:42:09 <hpc> it would be neat if you could @more them though
07:42:17 <hpc> or maybe have it say when it has a unique solution
07:42:46 <hexagoxel> indeed :)
07:42:51 <geekosaur> or teach it to send longer ones to lpaste
07:43:54 * hexagoxel looks for some lpaste library on hackage, finds nothing.
07:44:37 <hexagoxel> (that might a neat beginner project..)
08:02:02 <hpc> hexagoxel: that would involve beginners dealing with lambdabot
08:02:49 <hexagoxel> hpc: i meant just the uploading part. but maybe that is not appropriate either.
08:04:36 <sm> geekosaur: nice idea
08:04:50 <hpc> well that part's fine
08:05:04 <hpc> as far as IO goes, everyone's dealt with http before
08:05:20 <hpc> it's arguably a more familiar start to programming than printing to a terminal
08:08:14 <sgronblo> whats up with this? toJSON is not a visible method of ToJSON?
08:09:44 <lyxia> sgronblo: it is
08:09:50 <ski> @djinn (((a -> b) -> p) -> o) -> ((a -> q) -> p) -> (b -> q) -> o
08:09:50 <lambdabot> f a b c = a (\ d -> b (\ e -> c (d e)))
08:09:56 <ski> Zemyla ^
08:10:23 <unclechu> hi there, how i can map GHC version and 'base' package version?
08:11:01 <jle`> unclechu: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
08:11:02 <fr33domlover> Q: In attoparsec how would I "parse up to N items and give me a list of them"?
08:11:24 <fr33domlover> I could use nested optionals with recursion, but...
08:11:28 <hexagoxel> (ah, the `PastePipe` package includes a library interface for pasting.. nevermind then.)
08:11:29 <fr33domlover> is there a more elegant way?
08:11:50 <unclechu> jle`, thanks a lot!
08:11:58 <unclechu> that just what i need
08:12:02 <jle`> np!
08:12:13 <jle`> i always just google it myself >_>
08:23:32 <int-e> fr33domlover: it's so temptying to write  catMaybes <$> replicateM n (optional item)  ... but of course this will cause an exponential amount of backtracking so it's not an option. I don't have a better idea than to define a quick recursive function.
08:25:06 <fr33domlover> int-e, thanks. I'm defining my own Control.Applicative.Local.upTo for local use then
08:25:18 <scshunt> I see a far-too-clever way to do it
08:25:42 <ski> int-e : will it have to use monadic operations ?
08:26:14 <ski> @type replicateM
08:26:16 <lambdabot> Monad m => Int -> m a -> m [a]
08:26:17 <ski> @type replicateA
08:26:18 <lambdabot>     Not in scope: ‘replicateA’
08:26:18 <lambdabot>     Perhaps you meant one of these:
08:26:18 <lambdabot>       ‘Seq.replicateA’ (imported from Data.Sequence),
08:26:24 <ski> @type Seq.replicateA
08:26:26 <lambdabot> Applicative f => Int -> f a -> f (Seq.Seq a)
08:26:29 <ski> hm
08:27:42 <scshunt> upTo p n = evalStateT (manyTill' p (modify (+1) >> gets (>= n)) 0
08:34:56 <Zemyla> :t fix . flip flip (ap ((<$) . subtract (1::Int)) (guard . (> 0))) -- fr33domlover 
08:34:57 <lambdabot> Alternative f => (c -> (Int -> f Int) -> c) -> c
08:35:15 <Zemyla> :t fix . flip flip (ap ((<$) . subtract (1::Int)) (guard . (> 0))) . (((.) . maybe (pure []) . ((<|> pure []) .)) .) . (.) . liftA2 (:) -- fr33domlover
08:35:17 <lambdabot> Alternative f => f t -> Int -> f [t]
08:35:29 <Zemyla> That should do what you want.
08:36:27 <fr33domlover> Zemyla, thanks. Although it's very hard for me to read
08:36:39 <int-e> scshunt: a) the question was to parse *up to* n items. b) I think you need something like "guard" in there. c) you need to lift p...  perhaps  evalStateT (many (modify (+1) >> gets (<= n) >>= guard >> lift p) 0  would do the trick
08:37:15 <Zemyla> :t \r -> fix (\go n -> if n <= 0 then pure [] else liftA2 (:) r (go $ n - (1::Int)) <|> pure [])
08:37:16 <lambdabot> Alternative f => f t -> Int -> f [t]
08:37:27 <Zemyla> That's the easier to read version.
08:37:51 <int-e> But anyway a separate definition will be far more readable.
08:42:59 * hackagebot pringletons 0.1.0.0 - Classes and data structures complementing the singletons library  https://hackage.haskell.org/package/pringletons-0.1.0.0 (andrewthad)
08:53:00 * hackagebot ghcid 0.6.3 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.6.3 (NeilMitchell)
09:01:26 <fr33domlover> Hmmm what do I call the "at least 1" version of 'upTo'? Like in Attoparsec 'many1' is for 'many'
09:01:40 <fr33domlover> 'upTo1' is confusing. Maybe 'someUpTo' ?
09:02:19 <Zemyla> The at least 1 version should be upTo, and the may be 0 version should be atMost.
09:03:59 <fr33domlover> Zemyla, why these names specifically though? I mean, will people understand
09:05:45 <Zemyla> Also, the version that takes at least 1 should return a NonEmpty, if you're familiar with those.
09:08:00 * hackagebot ascii-flatten 0.1.0.0 - Flattens European non-ASCII characaters into ASCII  https://hackage.haskell.org/package/ascii-flatten-0.1.0.0 (DanielChoi)
09:10:06 <JuanDaugherty> the will understand if they get the camel case natural langish thing from smalltalk
09:10:50 <scshunt> fr33domlover: I'd probably just make fromUpTo p min max
09:11:02 <JuanDaugherty> *they
09:11:44 <scshunt> int-e: oh, yes, I misread the attoparsec docs. I see now
09:22:39 <Zemyla> :t \r m x -> let { mn 0 = mx (x - m); mn k = liftA2 (:) r $ mn $ k - (1::Int); mx 0 = pure []; mx k = liftA2 (:) r (mx $ k - 1) <|> pure [] } in if m < 0 || x < m then empty else mn m -- fr33domlover, fromUpTo.
09:22:40 <lambdabot> Alternative f => f a -> Int -> Int -> f [a]
09:27:06 <fr33domlover> Zemyla, thanks for all that stuff :) I already wrote the upTo I need
10:08:03 * hackagebot ascii-flatten 0.1.1.0 - Flattens European non-ASCII characaters into ASCII  https://hackage.haskell.org/package/ascii-flatten-0.1.1.0 (DanielChoi)
10:13:03 * hackagebot git-annex 6.20160511 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160511 (JoeyHess)
10:15:59 <delYsid> what was the command for lambdabot for point-free transformations again?
10:16:19 <Clint>  @pl
10:16:35 <kadoban> @pl \f x -> f x
10:16:35 <lambdabot> id
10:16:53 <delYsid> ah, thanks
10:18:03 * hackagebot github-backup 1.20160511 - backs up everything github knows about a repository, to the repository  https://hackage.haskell.org/package/github-backup-1.20160511 (JoeyHess)
10:28:04 * hackagebot math-functions 0.1.7.0 - Special functions and Chebyshev polynomials  https://hackage.haskell.org/package/math-functions-0.1.7.0 (AlexeyKhudyakov)
10:38:45 <mdx> Hello, anyone can help me elude how Data.Text and unicode works?
10:39:11 <scshunt> elude? you want to avoid it?
10:39:42 <mdx> no, i want to understand it hahaha
10:39:52 <mdx> there is a weird behaviour when i try to save to a file
10:40:15 <scshunt> can you post a testcase?
10:40:38 <mdx> i'll make a paste, just a sec
10:41:39 <mdx> scshunt: http://lpaste.net/163030
10:43:02 <mdx> TIO =  Data.Text.Lazy.IO, forgot to add that line
10:43:06 <c_wraith> mdx, how are you determining the file contents? 
10:44:12 <mdx> c_wraith: I didn't understand, you mean how I generate the Text or what I use as input to generate it?
10:44:18 <c_wraith> neither. 
10:44:38 <c_wraith> you say the file "is" something. how did you determine that? 
10:44:44 <scshunt> mdx: what GHC version?
10:44:56 <mdx> Ahhh, i open it with notepad/notepad++
10:45:16 <c_wraith> are you sure the editor and your locale agree on encodings? 
10:45:31 <mdx> scshunt: I'm on lts 5.15, so ghc 7.10.3
10:45:45 <scshunt> mdx: then Text will be writing using your locale's encoding
10:45:49 <mdx> scshunt: on windows, if that matters
10:45:53 <scshunt> which may not be the one that notepad/notepad++ are using
10:48:09 <c_wraith> mdx, for more control, encode the Text as a Bytestring first, then write that with bytestring IO
10:48:37 <c_wraith> mdx, that will let you specify the exact encoding, instead of using the system default. 
10:48:49 <mdx> c_wraith: If I switch notepad++ from ascii to utf8 I get  aʊȆ, so that's weird
10:49:08 <mdx> c_wraith:  I see
10:49:30 <c_wraith> I bet the system encoding on windows is something weird. like some codepage or something. 
10:57:11 <mdx> c_wraith: That was it! thanks
10:57:21 <c_wraith> yw
10:57:22 <mdx> c_wraith: BS.writeFile "testeText.txt" (encodeUtf8 "aáééèèèçã")
10:57:53 <monochrom> use "chcp 65001" to get the utf-8 code page
11:13:06 <mdx> shoot now is chrome that must understand that the file is utf8 D:
11:14:12 <mdx> I guess is just a meta tag at most
11:14:15 <Peaker> hey, how can I tell cabal to pass "-debug" to ghc?
11:14:41 <dcoutts> Peaker: either ghc-options in the .cabal file or --ghc-options on the command line
11:14:51 <dcoutts> or ghc-options in the cabal.config file
11:15:10 <Peaker> dcoutts, thanks
11:18:06 * hackagebot craze 0.1.0.0 - HTTP Racing Library  https://hackage.haskell.org/package/craze-0.1.0.0 (etcinit)
11:22:26 <Zemyla> Is there a way to shuffle a Seq in O(n) time without just copying it to an MVector, shuffling that, and putting it back into a Seq?
11:26:09 <kadoban> Zemyla: You can probably do it in O(n lg n) by annotating each with a random priority and then sorting by priority, and then unannotating. It's likely not very good in practice though.
11:26:30 <Zemyla> Yeah, but O(n) time would be better.
11:35:02 <dolio> If you care about the log n, you should probably care about the constant factors, which will also probably be better by using an MVector.
11:35:59 <mdx> Zemyla: Well, if you don't need the entire sequence sorting becomes linear
11:37:32 <mdx> (should say could, depends on the implementation of sort)
11:45:15 <hellcode> hey curries
11:45:41 <recsh> hi i am trying apply recursion scheme to a problem of checking for an element in a structure.  is there a scheme where we are allowed to terminate early based on some condition?  i thought i read it somewhere that there is one but i can't seem google it anymore.
11:45:42 <hpc> schoenfinkels 4 lyf
11:46:09 <hellcode> recsh continuations perhaps?
11:46:43 <recsh> hellcode, i am trying to apply a recursion scheme.
11:46:53 <recsh> i am trying to learn it basically.
11:46:59 <hellcode> oh
11:47:16 <recsh> and i just could not find one that would allow me to terminate early.
11:47:20 <hellcode> but what do you mean by 'terminate early'?
11:47:44 <recsh> well let's say some computation returns True then stop.
11:48:45 <hellcode> and what does your function return on normal conditions?
11:50:21 <hellcode> (a list? a number?)
11:50:27 <hellcode> or does it always hand a boolean?
11:50:29 <recsh> False
11:50:46 <Peaker> Does GHC 7.10 allow stack traces upon crashes even when compiling without profiling?
11:51:01 <dolio> Peaker: I don't think so.
11:51:04 <monochrom> foldr can stop early
11:51:21 <hpc> > foldr const undefined [1..]
11:51:22 <lambdabot>  1
11:51:49 <recsh> foldr would go through all elements, wouldn't it?
11:51:59 <monochrom> yeah, like that, but foldr (&&) and foldr (||) are good examples too
11:52:06 <monochrom> no, that is the biggest lie ever
11:52:24 <monochrom> and you have just seen empirical evidence
11:52:43 <recsh> can you be more specific or concrete?
11:52:54 <monochrom> [1..] is an infinite list, right?
11:53:12 <recsh> ok
11:53:19 <monochrom> the hypothesis "foldr goes through the whole list" can be tested by hpc's [1..] example, right?
11:53:29 <monochrom> well, the hypothesis failed the test. conclusion?
11:53:41 <int-e> . o O ( it's not an infinite list )
11:53:44 <kadoban> monochrom: conclusion: lambdabot is a wizard
11:53:59 <Cale> > foldr (\x xs -> if x > 10 then x else xs) 0 [1..]
11:54:01 <lambdabot>  11
11:54:19 <hpc> here's a bit more detail
11:54:28 <hpc> > foldr (*) z [a, b, c] :: Expr
11:54:29 <lambdabot>  a * (b * (c * z))
11:54:36 <hpc> that's what foldr does to a list
11:54:42 <Cale> > foldr (:) [] [1..]
11:54:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:54:46 <hpc> it puts an operation between all the elements and a zero at the end
11:54:47 <Cale> @src foldr
11:54:47 <lambdabot> foldr f z []     = z
11:54:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:54:53 <hpc> (fsvo zero)
11:55:17 <hpc> if the operation doesn't want to consume the "the rest of the list" folded result value, it doesn't get computed
11:55:28 <Cale> ^^ you can see here that in the case of a nonempty list, foldr f z (x:xs) passes control to f -- only if f pattern matches on its second argument will the foldr continue
11:55:31 <hpc> because haskell is non-strict
11:55:51 <recsh> i see.
11:56:34 <recsh> let me digest that.  thanks.
11:58:30 <idev> cont monad is (a -> r) -> r // I understand. Logic monad is (a -> m r -> m r) -> m r -> m r // wtf ???
11:58:53 <Peaker> I want a stack trace of "thunk forcing", and it seems all I get is a stack trace of function applications
11:59:06 <hellcode> what is 'if-then-else' in the language semantics?
11:59:24 <hellcode> is it an object in it's own right? like a monad or something?
11:59:26 <Peaker> idev, Logic monad is probably a "foldr"-like signature
11:59:39 <hellcode> or is it just a syntactic object?
12:00:24 <Peaker> idev, foldr :: (a -> b -> b) -> b -> [a] -> b,  so if you partially apply the [a], you remain with something that's equivalent to the list, and looks like your sig except "b" is "m r"
12:00:27 <monochrom> it is a syntactic object. it is one branch of the expression grammar.
12:01:22 <TimWolla> I am trying to remove BBCodes from a text using Attoparsec. My parser currently looks like this: http://lpaste.net/163033 Unfortunately I am not able to match strings longer than one character. I tried to use many, but it either does not typecheck or does not parse successfully. Can you point me in the right direction (and a good Attoparsec tutorial?).
12:01:55 <hellcode> monochrom: thanks. 
12:02:21 <idev> Peaker: This sounds insightful, but I don't get it yet.
12:03:03 <idev> so with continuations, the (a -> r) is "the rest of the computation"
12:03:16 <idev> so (a -> r) -> r is somethign that "does some computation, gets an 'a', and calls the (a -> r)" and we're done
12:03:47 <hpc> the most basic value of that type is something like
12:03:50 <hpc> :t ($ False)
12:03:51 <lambdabot> (Bool -> b) -> b
12:05:06 <idev> yeah, I get Cont monad. I don't get Logic Monad
12:05:17 <idev> the (a -> m r -> m r) -> m r -> m r .. that is the one that is confusing me :-)
12:05:36 <hpc> idev: take the type of foldr
12:05:37 <hpc> :t foldr
12:05:38 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:05:47 <monochrom> "forall r. (a -> m r -> m r) -> m r -> m r" is a Böhm-Berarducci way to say "m (LM m a), where LM is defined as data LM m a = Nil | Cons a (m (LM m a))"
12:05:47 <hpc> idev: let b = m r
12:06:00 <hpc> idev: then provide it a (t a)
12:06:23 <hpc> you end up with (a -> mr -> m r) -> m r -> t a -> b, then apply the (t a)
12:06:35 <hpc> and get (a -> m r -> m r) -> m r -> m r
12:06:51 <idev> whoa wait wait, le tme think thi sover
12:07:00 <idev> foldr :: (a -> b -> b) -> b -> t a -> b // okay, I get this
12:07:03 <idev> subst b = mr, we get
12:07:06 <hpc> so what's sort of represented here is a list
12:07:12 <idev> :: (a -> m r -> m r) -> m r -> t a -> m r // okay, I get this
12:07:13 <hpc> which is what you're closing over
12:07:18 <idev> now, how does the ta vanish?
12:07:23 <hpc> and the interface you provide to it is folding over it
12:07:27 <hpc> idev: function application
12:07:27 <idev> oh, we apply an 't a'
12:07:56 <idev> i sdee, so 'foldr' with the [a] already applied gives (a -> m r -> m r) -> m r -> m r
12:07:59 <idev> weird
12:08:08 <hpc> and we use m r instead of just r because it's LogicT
12:08:15 <hpc> and that little bit of transformation is needed
12:08:15 <idev> another dumb question
12:08:21 <idev> LogicT has to do with interleaving, backtracking and search
12:08:23 <hpc> let m = Identity and you get plain jane foldr
12:08:24 <idev> what does foldr have to do with all this
12:08:42 <idev> I mean, sure, this type sig matches, but what insight does this provide
12:09:04 <hpc> foldr is a universal interface to lists
12:09:22 <hpc> there's sort of a general concept of folding over a data structure
12:09:47 <hpc> which depends on what you define the ADT as
12:10:00 <hpc> a fold over a boolean might be a -> a -> Bool -> a
12:10:10 <hpc> you have a case for False, a case for True, and the value being folded over
12:10:26 <hpc> a fold over Maybe might be b -> (a -> b) -> Maybe a -> b
12:10:43 <hpc> a case for Nothing, a case for Just (which depends on what you Just have), and the thing being folded over
12:10:51 <hpc> for lists you have a case for [] and a case for (:)
12:11:14 <hpc> and with that fold, you can write any other operation on the data structure without having to pattern match
12:12:10 <hpc> as for what particular properties of it LogicT benefits from, i would have to read the definitions of its instances
12:12:19 <simpson> a -> a -> Bool -> a -- it's flipped if~
12:12:28 <hpc> it is
12:12:35 <simpson> :t maybe -- and I recognize this one, too
12:12:36 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:12:40 <hpc> specifically it's something people like to sometimes write as (??)
12:12:52 <hpc> (t ?? f) p = if p then t else f
12:13:09 <simpson> Is that legal Haskell? I didn't know that operators could do that.
12:13:13 <hpc> (t ?? f) being an extremely convenient partial application at times
12:13:17 <hpc> totally legal
12:13:27 <magneticduck> simpson: it's just (??) t f p
12:13:48 <simpson> magneticduck: Sure, but I didn't know that you could have a three-argument operator applied like that.
12:13:54 <simpson> Fixity and all.
12:14:07 <magneticduck> it's just ((??) t f) p
12:14:10 <magneticduck> lol
12:14:21 <hpc> currying yo
12:14:29 <magneticduck> lol @ my almost unchanged answer
12:14:40 <simpson> magneticduck: Sorry, sorry, I'm talking in terms of parsing.
12:15:35 <hpc> if i was implementing it i would have the parser just desugar infix applications
12:15:35 <magneticduck> perhaps you understand it at this point, but there's nothing novel of any sort going on there
12:15:59 <hpc> in which case it's trivially translated to a syntax that's already well understood
12:16:05 <magneticduck> (nothing novel, if you've already used the + operator)
12:16:24 <hpc> it's just a bit disorienting because there are very few ternary operators in the wild
12:16:35 <hpc> besides _?_:_ which is pure evil
12:16:44 <hpc> (to borrow agda syntax because it's mixfix)
12:17:08 <lyxia> t ?? f $ p
12:17:18 <lyxia> here's your pseudo ternary operator
12:17:30 <dolio> The novel thing about it (if anything) is that Haskell makes the left hand side a valid parse.
12:17:56 <dolio> You might not expect that, even knowing that, for instance, `x + y = ...` is valid.
12:18:04 <simpson> Agreed that mixfix is nasty, even when using stuff like Pratt parsers that are designed for it.
12:18:25 <Zemyla> @let infixr 0 ??, ?%; (??) = flip id; (?%) t f b = if b then t else f
12:18:27 <lambdabot>  Defined.
12:18:47 <Zemyla> > True ?? 1 ?% 2
12:18:49 <lambdabot>      Ambiguous occurrence ‘??’
12:18:49 <lambdabot>      It could refer to either ‘L.??’,
12:18:49 <lambdabot>                               defined at /tmp/mueval18566691791057418418.hs:1...
12:19:18 <mauke> @undefine
12:19:18 <lambdabot> Undefined.
12:20:18 <Zemyla> @let infixr 0 ?$, ?%: (?$) = flip id; (?%) t f b = if b then t else f
12:20:18 <lambdabot>  Parse failed: Parse error: (
12:20:30 <magneticduck> simpson: assuming you're indeed new to all things Haskell, look at that 'flip id'
12:20:52 <magneticduck> funky, right
12:21:10 <simpson> :t fmap fmap fmap -- magneticduck: I've been around for a bit.
12:21:11 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:21:36 <magneticduck> okey
12:21:58 <simpson> Wasn't there a library that spelled such things with dots? And it had stuff like (.:) to indicate triple (.)?
12:23:15 <magneticduck> well there are a few of those
12:23:48 <DeadZen> wow theres a lot of people here ;p
12:23:51 <simpson> Anyway, not new, just delighted to find syntactic quirks in languages that I thought I knew well.
12:25:30 <dsub> :t flip id
12:25:31 <lambdabot> b -> (b -> c) -> c
12:25:44 <Zemyla> > True ?$ 1 ?% 2 -- It works now
12:25:46 <lambdabot>  1
12:26:05 <magneticduck> simpson: http://hackage.haskell.org/package/altcomposition-0.2.2.0/docs/Data-AltComposition.html there's always .. this thing
12:26:24 <Zemyla> > False ?$ 1 ?% False ?$ 2 ?% 3
12:26:26 <lambdabot>  3
12:26:54 <simpson> "Note: you should use idiomatic haskell instead"
12:26:58 <magneticduck> introduces helpful things like (**%.***)
12:27:06 <magneticduck> as in, its obvious use case
12:27:30 <magneticduck> ".... what the heck ... **%.*** ... other difficult to understand things..."
12:27:44 <simpson> I suddenly am really happy to have learned lens instead.
12:29:40 <magneticduck> it's not an alternative to lens
12:30:13 <simpson> But I feel that I dodged a bullet in the difficult-to-read-operator-library department.
12:30:26 <simpson> Kind of like that time when I gave up learning COBOL.
12:33:12 <magneticduck> meanwhile, C++ is still happy about getting lambdas
12:33:20 <Akii> lol
12:34:19 <hpc> meanwhile in #python "we've had lambdas for years!"
12:34:36 <Akii> meanwhile here: we've had lambdas as foundation
12:34:52 <hpc> you merely adopted the lambda calculus
12:34:56 <hpc> we were born in it, molded by it
12:35:05 <hpc> we did not see a turing tape until we already wore bowties
12:35:11 <maerwald> :D
12:35:16 <Akii> nice one
12:35:17 <Akii> omg
12:35:23 <Akii> wow
12:35:47 <Akii> this is so going on twitter right now
12:35:51 <monochrom> but python's lambda is castrated
12:35:58 <hpc> monochrom: that's the joke
12:36:01 <bitemyapp> @quote hpc you merely adopted the lambda calculus. we were born in it, molded by it. we did not see a turing tape until we already wore bowties.
12:36:01 <lambdabot> No quotes match. I am sorry.
12:36:04 <bitemyapp> dang it
12:36:07 <bitemyapp> @remember hpc you merely adopted the lambda calculus. we were born in it, molded by it. we did not see a turing tape until we already wore bowties.
12:36:08 <lambdabot> Good to know.
12:36:13 <Akii> wow just wow
12:36:25 <magneticduck> a great moment for #haskell
12:37:50 <monochrom> ok, so are they Batman and we Bane now? and we have to wear a mask and speak unclearly?
12:38:20 <hpc> i think we'll be fine if we just mumble a lot and use an accent like shorn cornery
12:38:58 <sm> "Lovely party.. pity I wasn't invited"
12:39:31 <hpc> or just have the mixer totally drop the ball
12:41:51 * sm shall now hear all GHC errors in that voice
12:56:36 <shanemikel> (c -> d) -> (a -> b -> c) -> a -> b -> d
13:00:27 <Aruro> why does haskell need unsafeX functions?
13:01:05 <dolio> It doesn't.
13:01:10 <simpson> Aruro: I'm of the belief that they are not necessary.
13:01:20 <Aruro> so? why are they everywhere?
13:01:32 <maerwald> Aruro: what is unsafeX?
13:01:42 <dolio> They aren't.
13:01:46 <Aruro> unsafePerformIo, unsafeCoerce
13:01:49 <Aruro> and so on.
13:02:32 <maerwald> to make the language useful for cases where you know better than the compiler
13:02:48 <Aruro> what exactly we know better?
13:03:07 <maerwald> Aruro: e.g. when you are dealing with C functions which you know are pure?
13:05:36 <lyxia> even Haskell functions if you hide the underlying IORef
13:06:09 <maerwald> the compiler is not all-knowing, so unless you have that compiler, you will always need an escape hatch
13:06:27 <shanemikel> IDK about you, but my compiler is
13:07:02 <maerwald> I don't believe you
13:07:17 <Aruro> so in haskell modules docs trustworthy means they did not use unsafe functions?
13:07:31 <maerwald> GHC doesn't even have a totality checker... pretty far away from all-knowing
13:07:33 <Aruro> in front of Safe Haskell
13:08:34 <simpson> Aruro: IIUC "trustworthy" means that there's an explicit seal of approval from a human.
13:08:52 <simpson> "safe-inferred" means that it only depends on trustworthy or safe-inferred and doesn't have unsafe stuff. I think.
13:09:06 <Aruro> so there is no module which deep down does not do any unsafe stuff?
13:09:22 <Aruro> and we started so good, everything is safe :)
13:10:17 <simpson> You probably want operational effects, which are unsafe at some edge of your TCB.
13:11:11 <simpson> Like, you're pampered in Haskell. You get IO. IO has *so much power*.
13:11:51 <maerwald> simpson: you mean what purescript and idris already have?
13:12:47 <simpson> maerwald: Yeah. Or, along another dimension, what E and Monte have.
13:13:10 <simpson> Your prelude lets you *access the filesystem*!? Wow! Not in Monte. And forget about printing to stdout.
13:14:25 <shanemikel> @djinn (c -> d) -> (a -> b -> c) -> a -> b -> d
13:14:25 <lambdabot> f a b c d = a (b c d)
13:14:37 <hexagoxel> :exf "(c -> d) -> (a -> b -> c) -> a -> b -> d" -p
13:14:38 <exferenceBot> (.) . (.)
13:14:49 <shanemikel> exf?
13:15:01 <shanemikel> :exf (a -> b) -> a -> b
13:15:01 <exferenceBot> id
13:15:28 <hexagoxel> like djinn, but more powerful, less terminating :D
13:15:38 <geekosaur> https://github.com/lspitzner/exference
13:16:09 <shanemikel> I see
13:16:21 <shanemikel> what's the -p flag?
13:16:28 <shanemikel> pointfree
13:16:36 <hexagoxel> @@ @pl @djinn (c -> d) -> (a -> b -> c) -> a -> b -> d
13:16:36 <lambdabot>  f = (.) . (.)
13:16:59 <shanemikel> lol, is there a manual on what command sare available in lambdabot?
13:17:08 <hexagoxel> djinn and pointfree are fine for this, too, if you compose :)
13:17:24 <shanemikel> what's the @@ ?
13:17:28 <shanemikel> composition operator?
13:17:31 <geekosaur> not a very good one, I'm afraid
13:18:24 <geekosaur> (command manual that is)
13:19:09 <hexagoxel> shanemikel: yeah, it is like @(pl . djinn) (c -> d) -> (a -> b -> c) -> a -> b -> d
13:19:11 <geekosaur> I actually wrote up a better manual for the lambdabot instance I used to run --- but it didn't have the Haskell plugins in it, so I didn't document them
13:21:07 <Aruro> @help
13:21:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:21:25 <hexagoxel> actually, @listmodules is the next step
13:21:38 <Aruro> shanemikel: ^
13:22:00 <geekosaur> (http://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS --- note that lambdabot has changed a bit since then, in addition to my not having all its plugins in it)
13:22:08 <hexagoxel> then "@list $module"
13:23:47 <shanemikel> @listmodules
13:23:47 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
13:23:54 <shanemikel> @list pl
13:23:54 <lambdabot> pl provides: pointless pl pl-resume
13:24:00 <shanemikel> @help pl
13:24:00 <lambdabot> pointless <expr>. Play with pointfree code.
13:24:15 <shanemikel> is there a command to list flags?
13:24:20 <shanemikel> or arguments
13:24:49 <geekosaur> that did list the argument. but one-liners are all you will get from @help
13:25:01 <hexagoxel> (use "/query lambdabot" for more private exploration:)
13:26:39 <shanemikel> so, what's the difference between commands that start with : and @
13:27:44 <hexagoxel> :t is just @type i think, a shortcut to mimic the ":t" from ghci
13:27:45 <lambdabot> parse error on input ‘type’
13:28:09 <geekosaur>  @ and ? are command prefixes. lambdabot also supports special prefixes specified by plugins, so ":t " is recognized as shortcut for :type and "> " for @run, etc.
13:28:10 <hexagoxel> (ghci prefixes any commands with ":")
13:28:23 <geekosaur> er for @type
13:33:11 * hackagebot craze 0.1.1.0 - HTTP Racing Library  https://hackage.haskell.org/package/craze-0.1.1.0 (etcinit)
13:41:04 <C_minus> Sorry I know it's off topic, but ---- I have a functional programming exam tomorrow (in Miranda rather than Haskell). I was just wondering if anybody had any sage words of wisdom for me.
13:41:48 <maerwald> "you can do it"
13:42:01 <hpc> use the types, luke
13:42:09 <sm> get some exercise and sleep
13:42:09 <Luke> ?
13:42:15 <hpc> haha
13:42:37 <hpc> Luke: pre-emptive revenge for when you talk about haskell program coverage :D
13:42:56 <c_wraith> prevenge? 
13:43:09 <hpc> and between them, just venge
13:43:17 <simpson> Don't forget about covenge.
13:43:30 <bernalex> C_minus: don't hand in anything
13:43:38 <Iceland_jack>     > prevenge
13:43:38 <Iceland_jack> I like it
13:43:40 <bernalex> C_minus: say that you are lazily evaluating the exam.
13:44:17 <mauke> C_minus: Miranda is a trademark of Research Software Ltd.
13:44:26 <C_minus> Why did I expect anything more than this? Thanks fellas.
13:44:46 <mauke> claim offside
13:45:07 <hpc> C_minus: using types was serious advice though
13:45:08 <dolio> Does the class not involve writing type signatures?
13:45:31 <dolio> Because signatures seem like they'd be really annoying in Miranda.
13:45:42 <hpc> C_minus: like, do you know how in physics you can get by on everything up to electromagnetics just on knowing a couple of coefficients and what operations convert between units?
13:45:57 <hpc> "i have a meters and a meters per second, so divide one by the other to get seconds"
13:45:58 <dolio> I guess maybe they don't involve variables.
13:46:08 <C_minus> types is the key? yeah i've been feeling that lately.
13:46:12 <hpc> totally ignoring any actual understanding of reality, just doing math
13:46:35 <hpc> basically if you hit a tough question, the type system can guide you in a similar way
13:47:09 <dolio> Are exams given on computers these days?
13:47:20 <dolio> Back in my day, programming exams were pen and paper.
13:50:47 <C_minus> no it's pen and paper still
13:51:24 <C_minus> i'm ok at working out the types of functions, sometimes the complicated ones throw me off a bit.
13:51:40 <bernalex> dolio: it varies with what they are trying to assess (and how modern the school is)
13:52:14 <bernalex> dolio: if they are assessing "are you able to do something practical", it will frequently be a 48h take-home exam or something to that effect. if they are assessing "are you great at reasoning about blah", it will often be pencil & paper.
13:53:11 <bernalex> (the latter is of course inherently flawed due to the artificiality of the situation.)
13:53:11 <dolio> -1 for each semicolon you miss in your hand-written C++.
13:53:25 <bernalex> yes. I've had that kind of exam with antiquated profs.
13:53:32 <dolio> :)
13:54:14 <tiny_test> does anyone know a function with this type: `a -> (a -> Maybe a) -> [a]` in base? this is like iterate except it stops when the function returns Nothing
13:54:51 <dolio> unfoldr is close.
13:54:57 <opqdonut> :t unfoldr
13:54:58 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
13:55:00 <opqdonut> yeah
13:55:21 <tiny_test> :f unfoldr
13:55:24 <tiny_test> :i unfoldr
13:57:27 <simpson> tiny_test: Data.List.
13:57:32 <tiny_test> thanks
13:57:36 <dolio> @type unfoldr . fmap (fmap $ join (,))
13:57:37 <lambdabot> (a -> Maybe a) -> a -> [a]
13:58:48 <RainBowww> XD
14:04:18 <monochrom> at my university, exams are still on paper, simply because no one has figured out how to provide computers and still keep the exam closed-book
14:04:53 <monochrom> and then of course there is an issue of equipment cost
14:05:40 <monochrom> err, why am I answering here? should go to #haskell-offtopic :)
14:14:12 <hexagoxel> when replacing a value-initialized-as-a-record with a smartconstructor (simply because one field now has a static value in a significant amount of cases) i lose the nice `field = expression` overview.
14:14:41 <hexagoxel> there is no extension that provides named parameters using record syntax, is there?
14:15:50 <mauke> there's an oleg library
14:17:43 <monochrom> I don't understand the question. "xxx{field1 = n+3}" is valid syntax. even "(f y){field1 = n+3}" is valid syntax if you need "f y" to build a default record first.
14:18:55 <hexagoxel> monochrom: but with a completely constructed default value, i lose the warning when i forget to truly initialize one of the other fields.
14:19:16 <hexagoxel> especially when i add a new field some point in the future.
14:19:51 <mauke> you could define a new helper type containing just the missing values
14:22:41 <monochrom> ok, now I wonder if there is a phantom type trick to track how many fields, and which ones, you haven't overriden the defaults of :)
14:23:50 <glguy> type PartialThing = (Int, (), Char); type WholeThing = (Int, Bool, Char)
14:24:10 <glguy> If your record's fields are all parameters you can tell which ones haven't be set yet... 
14:24:31 <C_minus> So with regards to "use the types luke"... I am struggling with this one: I can see why myplus is that type, but I'm totally lost trying to work out the type of anotherplus. http://lpaste.net/163042
14:25:13 <hexagoxel> mauke: hmm, the poorest form of named-parameters-using-record-syntax. but it might be worth the linear overhead here. thanks.
14:25:55 <hexagoxel> i still wonder if named parameters have not been proposed in one form or another..
14:25:59 * hexagoxel goes to the archives
14:26:13 <lyxia> C_minus: you can try eta expanding
14:26:43 <monochrom> named parameters have been proposed and implemented and available here and now, in the form of type-level literal strings
14:28:08 <monochrom> for example «R "monochrom"» can be a type, if R is defined by "data R (a :: Symbol) = R Bool"
14:28:13 * hackagebot text-zipper 0.4 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.4 (JonathanDaugherty)
14:30:04 <monochrom> now you can declare your function to have type sig «f :: R "monochrom" -> R "pokemon" -> Bool».
14:30:23 <monochrom> there are also other ways to use type-level string literals
14:31:12 <mauke> http://hackage.haskell.org/package/record
14:32:04 <hexagoxel> monochrom: nice approach. replacing the strings by using datakinds to lift some sum-type containing a constructor for each field should work as well, right?
14:32:30 <mauke> by which I mean https://nikita-volkov.github.io/record/
14:37:26 <fizbin> The package https://hackage.haskell.org/package/either is just supposed to be a simple EitherT transformer, right?
14:37:41 <fizbin> Why does it have that huge awful dependency list?
14:38:54 <monochrom> I don't know. but perhaps review your supposition.
14:40:15 <lyxia> It implements a whole lot of instances for that type
14:43:32 <fizbin> Which kind of makes it useless as a package, unless you're already pulling in the universe.
14:46:16 <cocreature> fizbin: ExceptT in transformers is pretty much the same as EitherT with a slightly different name
14:49:00 <fizbin> cocreature: And with the requirement that I need Error and MonadError instances. 
14:49:09 <fizbin> Or... hrm. Maybe I don't?
14:50:03 <hexagoxel> fizbin: just the ekmett universe :p (25 packages is not that much, especially once you start using more stuff from that universe..)
14:50:14 <lyxia> the alternative is orphan instances, or breaking changes the day you need finer abstractions than the standard ones (like AMP), isn't it?
15:03:08 <shanemikel> https://www.youtube.com/watch?v=IOiZatlZtGU <- anybody hasn't seen this? Shame on you.
15:03:36 <SaleemPheku> hi
15:03:43 <SaleemPheku> i have lots of free time this summer
15:03:46 <shanemikel> "Propositions as Types" by Philip Wadler at Strangeloop 2015
15:03:49 <SaleemPheku> i want to learn haskell
15:03:53 <SaleemPheku> where do i get started
15:04:03 <shanemikel> There are a lot of references
15:04:09 <shanemikel> Do you need them to be free?
15:04:15 <SaleemPheku> preferably
15:05:16 <shanemikel> http://learnyouahaskell.com/ https://wiki.haskell.org/Typeclassopedia http://dev.stephendiehl.com/hask/
15:05:45 <SaleemPheku> Thanks
15:06:15 <shanemikel> the first is a free online book, second is something you should go through in entirety after you're done with the book, and the third is a birds eye reference for when you're curious about advanced features or forget what some terminology means
15:06:15 <maerwald> SaleemPheku: don't do lyah, see https://github.com/bitemyapp/learnhaskell/blob/master/README.md#how-should-i-learn-haskell
15:07:01 <shanemikel> well, I would have recommended ^ that guys book, but it's not free, and the notes in that repo lack production value
15:07:25 <shanemikel> it's published here: haskellbook.com
15:07:51 <maerwald> ?
15:08:23 <shanemikel> oh, I mean the references he links to are kinda old and ugly
15:08:29 <maerwald> no
15:08:52 <SaleemPheku> why is lyah not recommended
15:09:02 <maerwald> because it has no exercises and is a waste of time
15:09:04 <shanemikel> ok, well I didn't go that route, so I don't know
15:09:30 <shanemikel> but it's cute!
15:10:34 <sm> http://www.happylearnhaskelltutorial.com may be cuter
15:11:59 <shanemikel> also, when you're looking for more exercises, you can look at the "Functional Pearls" wiki page, and the "Fun of Programming" book, but it's not cheap, or the "99 Problems" wiki page
15:12:06 <maerwald> if you want to look at funny pictures and read a lot of non-technical blah, you might like lyah... otherwise, take a proper programming course as cis
15:12:13 <maerwald> which is linked in my link above
15:13:03 <sm> tough call actually.. HLHT has robots, LYAH has actual baby chicks and babies
15:13:29 <shanemikel> when people mention THE wiki, they mean https://wiki.haskell.org/Haskell, but there's another wiki here https://en.wikibooks.org/wiki/Haskell, that is incomplete, but has some good tutorials on some advanced features
15:13:51 <maerwald> the wikis are not exactly great learning resources for beginners
15:14:21 <shanemikel> they are when you're trying to learn something specific, after you go through one of the introduction books
15:14:49 <maerwald> not even then imo
15:14:55 <sm> slightly unfortunate we have two wikis
15:15:23 <monochrom> the second one is a "wikibook", which is a subtly different idea from "wiki"
15:15:30 <maerwald> most of the wiki explanations are obscure (e.g. for the state monad)
15:15:44 <shanemikel> the second one isn't an official wiki, it's on the wikimedia website "wikibooks" which has stuff on everything.. (wikimedia is the company behind wikipedia)
15:15:46 <ezyang> hey guys, why is 'top' in http://lpaste.net/163045 inferred to be polymorphic, but if I add z `seq` to line 6 it specializes to bool 
15:15:52 <Peaker> Haskell stack traces confuse me. Whenever a value is used, there are 2 "contexts" that can be used for a "stack trace" -- the chain of "logical" function applications, and the chain of "thunk forcings".  It doesn't seem the two even have names -- and when debugging you sometimes want one and sometimes the other
15:16:09 <sm> I know, and people usually praise it (the wikibook)
15:16:23 <ezyang> Answer: because the z `seq` causes GHC to stop generalizing the let bindings. Follow up: why does it generalize to the polymorphic type? 
15:16:29 <Peaker> For example, I put an "errorWithStackTrace" value inside an MVar -- hoping to see who is incorrectly reading the value from the MVar. Instead, I see who is putting the value inside the MVar
15:16:41 <shanemikel> it's VERY incomplete, but they have good introductions to things like Arrows, Continuations, and Monad Transformers
15:16:42 <hpc> Peaker: if forced to give them names, perhaps i would call them the lexical stack and the thunk stack
15:16:50 <monochrom> the wikibook is long-winded, but otherwise coherent. (yes, even coherence seems to be too much to ask for these days.)
15:16:59 <ezyang> Peaker: Yes, I'd like the dynamic scope sometimes too 
15:17:04 <Enigmagic> hpc: i call the latter the evaluation stack
15:17:04 <Peaker> hpc, and it seems that Haskell only reports the lexical stack
15:17:16 <ezyang> there should be a way to get the RTS to divulge this info 
15:17:18 <monochrom> OTOH, most wiki articles are incoherent because their authors were too excited
15:17:20 <Peaker> despite the thunk stack being very interesting in many case
15:18:07 <monochrom> you do know what happens when a person has an eureka moment and wants to tell the whole world their most recent new understanding
15:18:07 <sm> does the ghci debugger's trace command give that ?
15:18:08 <shanemikel> does anybody have the link for the 99 problems interactive app? there's a website that compiles your answer and checks it
15:20:29 <shanemikel> SaleemPheku: what's your age and experience?
15:21:09 <shanemikel> some books aren't great for people with no programming experience
15:21:09 <SaleemPheku> 19
15:21:36 <SaleemPheku> little prog exp
15:21:39 <SaleemPheku> python
15:22:47 <shanemikel> maerwald: so, you think the cis194 is okay for him?
15:24:16 <shanemikel> some mentioned Hutton's Programming in Haskell yesterday, that it is used for Oxford first year CS students.. may be a good choice, again, not free
15:24:36 <sm> it's really good, but extraordinarily expensive
15:24:54 <shanemikel> maybe he can find a copy online
15:25:13 <shanemikel> erm.. but that is immoral, so don't do that
15:26:02 <Peaker> damn, I think I was bit again by Data.Map.Strict lying about strictness because it shares lazy map's Functor/Traversable instances
15:26:37 <Peaker> It should be its own data-type :-(
15:26:46 <dolio> And not have a Functor instance?
15:26:48 <shanemikel> nobody knows about the "99 Problems" online repl?
15:27:46 <maerwald> shanemikel: yes, it's a proper programming course
15:28:07 <sm> https://www.google.com/search?q=99+problems+haskell ?
15:28:08 <maerwald> cis I mean
15:28:22 <monochrom> some functor laws and free theorems may be subtly unhappy about a strict fmap
15:29:00 <monochrom> otoh probably no one really minds
15:29:09 <shanemikel> sm: no, I can't find it.  I vaguely recall an opens source website with a text editor and compiler, that would check your answers.. can't find it though
15:29:14 <Peaker> dolio, can't it have fmap=Data.Map.Strict.map?  "fast & loose morally correct"?
15:29:36 <Peaker> Data.Map.Strict.traverse doesn't even exist as an alternative :(
15:30:31 <sm> shanemikel: I don't know about checking your answers, but you're not thinking of http://schoolofhaskell.com and the (now retired) FP Complete web ide ?
15:30:54 <ezyang> ok, answer has been solved! 
15:31:01 <Peaker> and Data.Map.Strict.traverseWithKey seems to be lazy on the value!
15:31:10 <shanemikel> nope.. well, it's not important, but it was kinda cool
15:31:13 <monochrom> yes ezyang, I want to know the answer too
15:32:05 <monochrom> tryhaskell.org
15:32:29 <enthropy> > snd $ fmap (\_ -> 1) undefined
15:32:31 <lambdabot>  *Exception: Prelude.undefined
15:32:48 <ezyang> monochrom: the answer is 'and' is in a separate declaration group, so foldr is typechecked and generalized first before we typecheck and 
15:33:06 <monochrom> ah, right
15:33:14 <ezyang> I managed to confuse myself by making a change which I thought put them in the same declaration group, but didn't 
15:35:21 <shanemikel> there you have it SaleemPheku.  a multitude of free and non-free materials;  actually, I think the available free materials for haskell (functional languages in general), are much better than those for the other paradigm
15:35:59 <SaleemPheku> thanks
15:36:56 <shanemikel> monochrom, no I don't think that's it.  oh, well..
15:38:15 * hackagebot hw-json 0.0.0.4 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.0.0.4 (haskellworks)
15:40:20 <Peaker> Does this make sense?  strictify :: Foldable f => f a -> f a ; strictify = foldr seq ()    and then:   strictTraverse f xs = traverse f xs <&> strictify  ?
15:41:05 <Peaker> oops, the foldr ought to have the arg there instead of ()
15:47:56 <Peaker> One really annoying thing about laziness is that to "strictify" after the fact -- you pay for another traversal that in some cases can ruin the asymptotic complexity of the algorithm -- and you really want it to just be strict in the first place. But that's really hard to guarantee in Haskell! (e.g: accidental use of Functor on your Data.Map.Strict field)
15:49:25 <monochrom> I agree. The very existence of Map.Lazy and Map.Strict shows this.
15:50:30 <monochrom> OTOH, the dual is true too. the annoying thing about strictness is that it's just as hard to decrease strictness after the fact.
15:51:16 <Peaker> monochrom, but laziness is sometimes advocated as nicer than strictness because you can "strictify" but not "lazify", but "strictifying" really sucks
15:53:32 <Peaker> My misfortune: A) GHC prematurely calls finalizers on ForeignPtrs, so I cannot destroy my Font objects via finalizers, must bracket. B) Getting font width is a pure op, so I use unsafePerformIO for it. C) Pure use of it outside of bracket explodes :(   D) Debugging *who* is leaking ref to the unsafePerformIO thunk is very difficult (no thunk stack, laziness is hiding somewhere!)
15:54:44 <monochrom> I think it comes down like this. 51% of the time, it is easy to start nonstrict then increase strictness. 49% of the time, it is easy to start strict then decrease strictness. So starting nonstrict is nicer by 1%.
15:55:16 <monochrom> Does a few calls to "touch" help with (A)?
15:55:58 <shanemikel> isn't laziness as simple as \x -> f x ?
15:56:33 <Cale> shanemikel: hm? It's a complete inversion of evaluation order
15:56:49 <Cale> You're evaluating everything outermost-first, rather than innermost-first
15:56:56 <shanemikel> I'm approaching the point where I need to worry about it, but that was, for example the solution for implementing a fixpoint operator in a strict lisp
15:57:07 <Peaker> monochrom, I don't remember the exact details, trying to re-read now because the B,C,D chain is terrible
15:57:25 <Peaker> monochrom, we had a comment referring to http://hackage.haskell.org/package/base-4.8.0.0/docs/System-Mem-Weak.html#v:addFinalizer as explaining the problem but now I don't get it :)
15:58:34 <shanemikel> So, what's the best reasource for understanding the problem?  I was gonna read https://en.wikibooks.org/wiki/Haskell/Laziness and https://wiki.haskell.org/Performance/Laziness
15:58:35 <Cale> shanemikel: Yeah, you can defer the evaluation of one particular thing by putting it in the body of an otherwise pointless function because even most strict evaluators won't attempt to evaluate the body of a lambda.
15:59:32 <Cale> Peaker: Are you aware that Data.Map.Strict and Data.Map.Lazy export the same data type?
15:59:33 <shanemikel> Is that a pun?
15:59:39 <Peaker> Cale, yes :(
15:59:45 <Peaker> Cale, bad idea, IMO
15:59:51 <Cale> okay
15:59:56 <Cale> I don't think it's a terrible idea...
16:00:16 <Cale> The distinction between the modules is the strictness of the functions they export for operating on maps
16:00:20 <Peaker> Cale, they could both newtype a common tree rep, but the Functor/Traversable instances let you easily put lazy thunks inside a supposedly value-strict map
16:00:30 <Cale> you might want to import both and use them together
16:00:35 <ZelteHonor> I want to zip a lot of list of Integer with (+). With padding. Instead of cutting the longest list I want it to be append. I have everyhing working. My problem is that it's incredibly slow. I want to make it faster.
16:00:40 <Peaker> Cale, wouldn't it be nice if Data.Map.Strict represented a data-type with an *invariant* about the strictness of the values?
16:00:48 <Cale> Maybe in some cases
16:01:11 <Cale> I'm very hesitant when it comes to making things strict before it's clearly necessary to do so
16:01:11 <ZelteHonor> I have something like 32000 list.
16:01:15 <Peaker> Cale, O(1) conversion strict->lazy would be possible via newtype in lib.  Other direction would need O(N) forcing of all values (or have an "unsafe" one that trusts you they're strict)
16:01:29 <Peaker> monochrom, https://github.com/lamdu/graphics-drawingcombinators/blob/a45c70c5554c5764ebbbb450f39bbe845cdddc89/src/Graphics/DrawingCombinators.hs#L381 (and line 397) -- problem is that behind the "Font" newtype (from a separate library!) hides a ForeignPtr in it
16:02:08 <Peaker> monochrom, so "addFinalizer" is potentially broken when used on arbitrary newtypes, because they might have ForeignPtrs inside them :(
16:02:20 <scshunt> Peaker: would you want deeply strict values?
16:03:00 <Peaker> scshunt, sometimes -- that is the user's concern as they decide how deep value strictness goes
16:03:22 <ZelteHonor> So my question is how can I make faster addition with list. Or if something else would be quicker It would be fine
16:03:59 <Peaker> What version of ghc added "?location" implicit parameters?
16:04:08 <Cale> Peaker: 8.0.1
16:04:53 <Cale> ZelteHonor: When you say "with padding", what does that mean?
16:05:11 <Cale> ZelteHonor: Are you just referring to the bit that you explained next?
16:05:34 <dfeuer> Cale, I think it was a big mistake for Data.Map.Strict and Data.Map.Lazy to export the same type. There should at least be a newtype wrapper to exclude mistakes like using fmap or traverse when thinking you're dealing with a strict map.
16:05:39 <ZelteHonor> I'll use an example
16:06:15 <ZelteHonor> func [0,0,1] [0,1] would equal [0,1,1] and not [0,1]
16:06:22 <nitrix> dfeuer: I think the idea is that you just changed the import and no code has to change.
16:06:34 <nitrix> dfeuer: s/changed/switch/
16:06:44 <Cale> dfeuer: Maybe -- I've basically never had to use Data.Map.Strict, so I'm probably not one to say what it should be.
16:07:00 <dfeuer> nitrix, that makes no difference. You could name two different types in two different modules the same.
16:07:01 <Cale> ZelteHonor: right, okay
16:07:11 <ZelteHonor> Right now I have
16:07:18 <ZelteHonor> zipPadSum [] bs = bs
16:07:23 <ZelteHonor> zipPadSum as [] = as
16:07:29 <ZelteHonor> zipPadSum (a:as) (b:bs) = (a + b) : zipPadSum as bs
16:07:41 <ZelteHonor> With signature: zipPadSum :: [Integer]->[Integer]->[Integer]
16:07:47 <nitrix> dfeuer: So you want both module the re-export the same type... and newtype it to the same name?
16:07:50 <dfeuer> Cale, normally, you'd expect Data.Map.Strict.Map to be a strict thing, which would not support things like fmap or traverse.
16:07:57 <nitrix> dfeuer: Aren't we going in circles, here?
16:08:11 <Cale> dfeuer: It should support fmap and traverse
16:08:19 <Cale> dfeuer: even if strict...
16:08:20 <Adeon> I think they should be different types, maybe internally they could be the same
16:08:23 <Adeon> strict and lazy maps
16:08:25 <dfeuer> nitrix, that would be fine! No, they'd be *different* types with the *same* representation and and the *same* name.
16:08:34 <Adeon> but Data.Map.Strict.Map would be different from Data.Map.Lazy.Map
16:08:37 <ZelteHonor> I foldl' 32000 list with this function but it is too slow. Is there a solution?
16:08:43 <dfeuer> Cale, that would not be a law-abiding Functor instance.
16:09:29 <dfeuer> As it is, you can import Data.Map.Strict, and then accidentally use fmap to install bottoms in it.
16:09:44 <dfeuer> Or to install thunks in it, anyway.
16:10:21 <Cale> dfeuer: I don't think the laws ought to apply to partial values
16:11:18 <dfeuer> Cale, well, in that case, you'd want the Functor implementation for the strict Map to be different from the one for the lazy Map. As it is, there is no strict one.
16:11:38 <Cale> right, but there is a strict Map.map isn't there?
16:13:47 <renkon> hello i have an exam tomorrow, and i have serious doubts regarding using composition
16:14:15 <dfeuer> Cale, sure. But you could accidentally use fmap instead and the compiler wouldn't know you were using the wrong thing.
16:14:25 <dfeuer> No warning.
16:14:38 <renkon> sum (map (tiempo chocobo)) circuito) <-- I tried to composite it using sum.(map (tiempo chocobo)) circuito, with no result, is there any tip to be able to do this correctly on paper?
16:14:50 <Cale> dfeuer: Well, you might even be using the right thing!
16:15:25 <Cale> dfeuer: Just because you want to strictly map a function over your Map some of the time doesn't mean that you don't also want to lazily do so at other points.
16:15:34 <Cale> But yeah, I can see how you might expect it to be the other way
16:15:46 <dfeuer> Cale, if you want to install thunks in a conceptually strict map, I think you should have to use a special function that makes it clear you're doing something strange.
16:16:20 <ZelteHonor> So I guess that nobody know how to additione list quickly?
16:16:22 <dfeuer> And if I import a type called Map from a module called Data.Map.Strict, I damn well do expect that to be a conceptually-strict map.
16:16:26 <Cale> I guess I don't think of it as a conceptually strict Map, it's just a Map, and the operations may or may not do evaluation on the elements of the Map as they're computed
16:16:36 <dfeuer> ZelteHonor, we do; we are just discussing other things.
16:17:50 <dfeuer> ZelteHonor, you also haven't actually explained your question properly.
16:17:56 <ZelteHonor> dfeuer: sorry then. I do think that lazy and not lazy structure should expose the same API. So you can easily change you import to see if you gain anything.
16:18:12 <dfeuer> renkon,  sum (map (tiempo chocobo)) circuito) doesn't even parse, let alone typecheck. What do you mean?
16:18:26 <renkon> dfeuer typo, remove the ) after chocobo, so its only one
16:18:40 <dfeuer> ZelteHonor, that has virtually nothing to do with it.
16:18:51 <dfeuer> renkon, that still doesn't typecheck. You're summing a function.
16:18:52 <renkon> my bad, tiempo is a function which requires a "chocobo" and circuito is a list of some element, which tiempo requires one element of them and returns a number
16:19:27 <dfeuer> renkon, give fresh code that makes sense. It's hard to follow a natural-language description of it without having it here.
16:20:05 <renkon> in english, it'd be like this: sum (map (getTime character) circuit), where circuit is a list of tracks, and getTime returns the time taken for the character to finish the single track
16:20:32 <renkon> the problem is, I'm having a hard time trying to use composition in them. I have an exam tomorrow and my weakest point is I am hardly being able to use correctly the "." operator
16:20:39 <renkon> s/operator/function
16:21:09 <dfeuer> So you tried to modify that how? Are you supposed to be defining a function, or computing a value?
16:21:16 <renkon> i have tried using sum.(map (getTimeCharacter)) but it hasn't worked.
16:21:25 <renkon> getTime character* and circuit at the end
16:21:35 <renkon> sum.(map (getTime character)) circuit
16:21:40 <dfeuer> Aha!
16:21:40 <ZelteHonor> dfeuer: I have 32000 list of Integer. I want to sum them element by element. I have made a zip function wich I use with a foldl' to do exactly that. And I was asking if there is a better way to do it.
16:21:55 <dfeuer> renkon, function application binds more tightly than any operator.
16:22:20 <dfeuer> So the compiler sees that as sum . ((map (getTime character)) circuit), which is not what you mean.
16:22:35 <renkon> so, should I add ()?
16:22:37 <ZelteHonor> I could also use something else than a list if it's quicker.
16:22:44 <dfeuer> You should either use (sum . (map (getTime character))) circuit, or, more idiomatically,
16:22:53 <dfeuer> sum . map (getTime character) $ circuit
16:23:43 <renkon> we have seen the $ function, but its hard for me to understand it, ill stick with the first one, can't believe those () were lacking. do you have any tips so as not to make mistakes on doing that?
16:23:53 <renkon> do you recommend me to use () all the time i use .?
16:24:13 <dfeuer> ZelteHonor, the fastest single-threaded way to sum a list of Integers is almost certainly foldl' (+) 0.
16:24:32 <dfeuer> renkon, um ... experience?
16:24:42 <dfeuer> The $ function is pretty simple.
16:24:46 <dfeuer> f $ x = f x
16:24:47 <dfeuer> That's it.
16:25:02 <dfeuer> It just has very low precedence.
16:25:13 <renkon> so what would be the difference with using f x? that composition would not work correctly unless using brackets?
16:25:15 <dfeuer> f $ a + b  =  f (a + b)
16:25:19 <greymalkin> I'm starting to use NixOS.  Is there an example of referencing an external binary for the build? I have at least one program that uses imagemagick's `convent` command, for example.
16:25:26 <dfeuer> f . g $ x = (f . g) x
16:25:34 <renkon> ok
16:25:36 <renkon> thank you very much
16:25:41 <dfeuer> Anway, I have to go make dinner now :(
16:25:41 <greymalkin> (cabal-specific, or nix specific for haskell projects, that is)
16:26:14 <greymalkin> To date, I've relied on the user installing imagemagick and just having `convert` somewhere in their path.
16:27:20 <ZelteHonor> dfeuer: This is not what I meant. Sorry if I was not clear enought. I would like a function that do that: [[0,1] [0,1,1] [0,1,1,1]] == [0,3,2,1]
16:28:52 <ZelteHonor> Sum many lists element by element and don't trunkate to the size of the smaller list.
16:29:05 <Zemyla> ZelteHonor: Look up the "these" library. alignWith is what you're looking for.
16:29:38 <Cale> > transpose [[0,1], [0,1,1], [0,1,1,1]]
16:29:40 <lambdabot>  [[0,0,0],[1,1,1],[1,1],[1]]
16:29:56 <Cale> > map sum $ transpose [[0,1], [0,1,1], [0,1,1,1]]
16:29:58 <lambdabot>  [0,3,2,1]
16:30:27 <NeverDie> That is wizardry. 
16:31:26 <Cale> If that's still too slow for you (it may well be), I recommend using something other than lists of arbitrary precision integers
16:31:53 <Cale> Maybe something like Data.Vector.Unboxed
16:32:04 <EvanR> what, Integer is not enough?
16:32:10 <ZelteHonor> Cale and Zemyla. Thanks!
16:32:56 <ZelteHonor> I checked Data.Vector.Unboxed and I don't see instance of Unboxed for Integer..
16:33:11 <Cale> That's correct
16:33:20 <Cale> You'd have to choose a fixed precision then
16:34:13 <ZelteHonor> I don't think I can do that. I have number with 5000 digit.
16:34:19 <Cale> If you need arbitrary precision, then you can't use unboxed array structures, because the arbitrary precision integers use arbitrary amounts of memory too
16:34:40 <Cale> (and so you can't align them nicely in memory like that)
16:34:49 <ZelteHonor> Cale: Unfortunately I think this is the case.
16:38:17 <Peaker> https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:mkWeakMVar <-- if I immediately throw away the weak ref and just give a finalizer, that should work, right?
16:52:39 <ZelteHonor> Cale: So the code seem clearer to me. But not really faster. Maybe there is no way? Because I absolytly need Integer.
16:52:56 <Cale> ZelteHonor: How many additions are you performing in total?
16:54:07 <ZelteHonor> I have list that can grow as big as 32000. And also, I have around 32000 list. So... many?
16:55:06 <Cale> So let's say it's 32000 by 32000, you're performing how many additions? :)
16:55:53 <Cale> Maybe the average length is only 16000 or something, in which case it's only going to be half as many...
16:55:55 <ZelteHonor> 32000 ^ 2. But that's cheating So 1024000000
16:56:22 <Cale> How long is the program taking to run?
16:57:35 <ZelteHonor> I estimate 45-50 minute.
16:57:44 <ZelteHonor> After 1m52 it's at 4%.
16:58:13 <Cale> okay, that's way way longer than it takes my machine, but I'm only adding up 1's
16:58:52 <Cale> Maybe it's spending a substantial amount of time computing the lists that it's adding in the first place.
16:59:20 <Cale> Or perhaps it's just the fact that you're using much larger numbers than I am
16:59:22 <ZelteHonor> Yeah. My lists are like: [0,1] [0,0,1] [0,0,0,1] . But they don't juste add up like that. It's a bit more cimplicated. So really there is not just 1.
16:59:54 <ZelteHonor> Like I said number end up being 5000 digit large.
17:00:29 <ZelteHonor> What I am doing is research. So it's possible that it is not simply doable. Or not doable the way I try it.
17:00:42 <ZelteHonor> By not doable I mean not quickly.
17:01:59 <Peaker> monochrom, I went back to a finalizer approach, the docs say using a finalizer on an MVar is safe (unlike a finalizer on arbitrary data-type or foreign ptr), so I no longer rely on brittle strictness. Thanks for the nudge :)
17:02:04 <Cale> It takes my machine ~2m45s to add up 32000 lists of the form [[1], [1,1], [1,1,1], ...] using the transpose method
17:02:32 <Cale> ZelteHonor: How are you compiling the program?
17:02:42 <ZelteHonor> Well I don't exactly "just" add them like that.
17:02:52 <Cale> Zemyla: make sure that you're compiling with -O2
17:02:57 <ZelteHonor> -Wall -threaded -O2 -funfolding-use-threshold=16 -optc-O3 -rtsopts
17:03:20 <ZelteHonor> -threaded is just for testing. There is no parallelism or concurrency going on.
17:03:37 <Cale> You're compiling and linking in C code using GHC?
17:04:16 <ZelteHonor> No. I was just searching how to enable optimisation with ghc. And I saw -O2 -funfolding-use-threshold=16 -optc-O3
17:04:19 <ZelteHonor> Just copy and paste.
17:04:30 <Cale> -optc is for passing through options to the C compiler, which you hopefully shouldn't be using
17:05:00 <ZelteHonor> So if I don't use C at all I shouldn't have that option?
17:05:04 <Cale> right
17:05:09 <Cale> Well, it doesn't matter
17:05:19 <Cale> But you shouldn't need it anyway
17:05:51 <ZelteHonor> Well. And if use library that are them linking to C? Or do they have their own compilation option? (Stack user here)
17:06:34 <ZelteHonor> Anyway. I delete it.
17:07:32 <Cale> It's something which GHC will pass through to the C compiler. It's possible to give .c files on the GHC commandline to have them compiled and linked with your Haskell code, and GHC will give those options to gcc when it runs it to compile them.
17:07:58 <Cale> A long time ago, when GHC compiled via C, it was more relevant.
17:08:25 <Cale> i.e. it compiled your Haskell code to C code, and then compiled that with gcc, and then mangled the output of gcc a bunch to actually make it work...
17:08:33 <ZelteHonor> Yeah so not just sum. Each element in the list is summing some element before it according to some relation. So I am doing 32000 sum. But not with each element before. Just some.
17:09:16 <ZelteHonor> So I can't really use parallelism.
17:09:22 <ZelteHonor> *can't even use
17:11:13 <ZelteHonor> And all of this with 32000 list. In the best world I would try with a maximum of 610000.
17:12:19 <Cale> I feel like this is the sort of situation in which you either just need a better algorithm, or you need to find a way to parallelise it across many machines, or both.
17:13:36 <Cale> I just started running a program now which replaces each of the 1's with 10^5000's in my previous program, and I'll let you know how long that takes
17:14:32 <ZelteHonor> Yeah. I'll try to search some better algorithm first. Because parralelism would be complicated since I need to sequentially calculate the sum pf each list.
17:14:47 <ZelteHonor> Oh... that might be pretty long. No?
17:15:14 <Cale> ZelteHonor: Well, after doing the transpose, you could split the list of lists into chunks and compute the sums in parallel, I think
17:15:40 <Cale> But I don't know whether that generalises to your real program
17:16:45 <ZelteHonor> It might work. I could try parallelism in each big sum itself.
17:17:16 <Cale> https://archive.org/details/Nicholas1987 I am reminded of this talk, which is related, but probably not in a really useful way :D
17:17:24 <Cale> (It is a great talk though)
17:18:21 <Cale> done
17:18:38 <ZelteHonor> 5 minutes.
17:18:41 <ZelteHonor> Not bad.
17:19:55 <ZelteHonor> But like I said I am not just doing a sum.
17:22:33 <ZelteHonor> Cale: Thanks for your help. I've bookmarked the talk and I'll check it come day. I am quitting.
17:29:40 <idev> given "f :: (a -> b) -> r", "g :: b -> r", is it possible to construct a "h :: a -> r"
17:31:22 <dolio> @djinn ((a -> b) -> r) -> (b -> r) -> a -> r
17:31:22 <lambdabot> -- f cannot be realized.
17:32:27 <monochrom> idev: I think you need one more ingredient: something of type a->b
17:32:56 <monochrom> actually the existing ingredient f does not help
17:33:19 <simpson> h = unsafeCoerce g -- I'm helping~
17:33:34 <geekosaur> "hlepy"
17:33:36 <Cale> simpson: nothing could possibly go wrong
17:34:06 <idev> okay; thanks
17:34:09 <idev> is this provably impossible
17:34:10 <monochrom> I think you can make it a little bit safer by only coercing a to b, not fully coercing b->r to a->r :)
17:34:14 <idev> or is proving such things akin to halting problem?
17:34:43 <monochrom> it is provably impossible
17:34:51 <idev> how do we prove that such things are impossible?
17:34:55 <idev> I'm not even sure how to write a proof
17:34:58 <idev> proof by contradiction?
17:34:59 <idev> or what?
17:35:42 <monochrom> you will need to know the Curry-Howard correspondence between types and intuitionistic logic sentences.
17:35:59 <idev> okay
17:36:03 <idev> and with that, how do we prove it?
17:36:10 <dolio> It is easy to make an informal argument.
17:36:25 <monochrom> then you will need to know a model of intuitionistic logic, so that you can prove that a certain sentence such as "((a -> b) -> r) -> (b -> r) -> a -> r" is unprovable.
17:36:28 <dolio> You take as input ((a -> b) -> r), and want as output (b -> r) -> a -> r
17:37:02 <monochrom> and then you use the Curry-Howard correspondence to conclude that "a unprovable sentence corresponds to an unimplementable type"
17:37:03 <dolio> The first thing has b in a negative position, and a in a positive position, but the second thing has b in a positive position and a in a negative position.
17:37:50 <dolio> So that indicates that you are in trouble.
17:38:05 <idev> if we had "(a -> b) -> r" and "a -> r", would be be able to get "b -> r" ?
17:38:19 * hackagebot ghcjs-dom 0.2.4.0 - DOM library that supports both GHCJS and WebKitGTK  https://hackage.haskell.org/package/ghcjs-dom-0.2.4.0 (HamishMackenzie)
17:38:40 <idev> F :: (a -> b) -> r; A :: a -> r, B :: b -> r // it seems to me that we shoudl be able to do either F+A -> B or F+B -> A, but I can't seem to do either
17:41:07 <monochrom> I wonder if parametricity (free theorems) has a shorter proof.
17:41:48 <monochrom> But then, it took me longer to believe parametricity than to believe Curry-Howard plus the Kripke model of intuitionistic logic
17:43:02 <geekosaur> [12 00:37] <idev> if we had "(a -> b) -> r" and "a -> r", would be be able to get
17:43:14 <geekosaur> wouldn't that require being able to run the (a -> b) backwards?
17:43:39 <idev> "(a -> b) -> r" + "b -> r" ==> can we somehow get an "a -> r" @geekosaur
17:43:40 <geekosaur> oh, urgh/ (trying out fonts. some of them break badly when I select text, sigh)
17:43:45 <geekosaur> yes
17:43:53 <idev> TIL : trying to prove that somethings are impossible to construct typewise requires a math phd
17:43:59 <geekosaur> uh, wait, was not answering the question
17:44:27 <geekosaur> but "yes" is the correct answeer; given those you can do that. the other one requires you to be able to use the (a -> b) as a (b -> a)
17:44:40 <geekosaur> which is not possible in the general case
17:44:44 <idev> geekosaur: how do yo udo it?
17:45:14 <geekosaur> actually you don't need the (a -> b) -> r. you just need whatever you were going to use for the (a -> b) part
17:45:28 <geekosaur> or, f f
17:45:29 <geekosaur> er
17:45:55 <simpson> idev: Well, you need to be an undergrad. Do you know basic formal logic proofs?
17:46:07 <monochrom> I am skeptic about the significance of "requires a math phd"
17:46:21 <geekosaur> I don't have a Ph.D.
17:46:35 <monochrom> because all it says, logically, is only that most undergrad curricula don't teach this stuff.
17:47:07 <simpson> I learned the principles by sitting in on undergrad maths. I was a music major, though. :c
17:47:09 <lpaste> Cale pasted “proof in Coq for idev” at http://lpaste.net/163046
17:47:11 <dolio> Neither do most math phd programs.
17:47:16 <monochrom> Did you know: once upon a time, only CS PhDs knew about OOP
17:48:01 <monochrom> and yet, no one ever mentioned that as a significant argument for or against anything.
17:48:03 <idev> Cale: this is amazing. I'm going to study this.
17:48:05 <Cale> I have no idea why I'm using tactics
17:48:09 <Cale> lol
17:48:42 <Cale> idev: If you fire up coqide and step through it one line at a time, you can follow it better.
17:49:14 <dolio> Yes, it's completely useless without a tool to interact with it. :)
17:49:34 <idev> so line 1 is  like: if we can create thing sof type (( T -> F) -> F), and of (F -> F), and of T, ... then we can prove F (which arrives at contradiction)
17:49:46 <idev> so now we're going to construct ((T -> F) -> F) and (F -> F)
17:49:49 <idev> F -> F is just id
17:49:56 <Cale> yep
17:49:59 <monochrom> because the truth is that "only CS PhDs have heard of OOP" means only that, temporarily, there was a time OOP was not taught to undergrads. Big deal.
17:50:00 <idev> oh man
17:50:02 <idev> this is brilliant
17:50:31 <idev> Cale: how did you learn this?
17:50:40 <Cale> idev: osmosis
17:50:56 <Cale> One day after programming in Haskell for a decade, I realised that I already knew how to use Coq
17:51:23 <idev> yeah, but how did you go from "theorem proving in Coq" to "well, let's pove certain type sigs are impossible"
17:51:38 <idev> this is a bit like "I was playing with legos one day .. and look, I built a spaceship"
17:51:46 <monochrom> I was the other way round. After a decade of proving in HOL4, I found that I knew Haskell.
17:51:51 <Cale> Oh, well, that's just how do we express "not" in constructive logic
17:52:39 <Cale> If you want to show that it would be a contradiction to have a term of a given type A, you try to prove A -> False
17:53:59 <Cale> Usually negation is just defined like that
17:54:12 <Cale> (In fact, it is, I just didn't bother to use Coq's definition)
17:54:39 <monochrom> is "pose" French for "suppose"?
17:54:53 <Cale> heh
17:55:06 <jle`> for example, if you watn to prove that (forall a b. a -> b) is not constructable, you can construct `(forall a b. a -> b) -> Void`, which is trivial to construct
17:55:19 <geekosaur> I read it as like posing a question
17:55:22 <jle`> \f -> (f () :: Void)
17:55:26 <AbelianGrape> Should I be concerned that Snap appears to rely on the "enumerator" package, which is boldly marked as Deprecated?
17:55:46 <dolio> Except you're posing an answer, in this case. :)
17:55:46 <geekosaur> (of course ENglish may well have gotten that idiom from French...)
17:55:56 <dolio> Sort of.
17:56:21 <Cale> AbelianGrape: I wouldn't be *too* concerned. There are a lot of libraries which the Snap developers could replace it with if really necessary.
17:56:22 <geekosaur> yeh, I was citing an idiom (hence "like")
17:56:49 <dolio> Pro-posing.
17:56:56 <Cale> (and perhaps someone will take the trouble at some point)
17:57:25 <Cale> Posing a threat
17:57:44 <geekosaur> yeh
17:57:45 <Cale> I'll show you, theorem prover!
17:57:52 <dolio> Yeah, they should rename that tactic to threaten.
17:58:08 <geekosaur> pro-pos(e)-ition
18:02:47 <lpaste> Cale annotated “proof in Coq for idev” with “proof in Coq for idev (annotation)” at http://lpaste.net/163046#a163048
18:03:04 <Cale> idev: ^^ there's how to do it a bit quicker ;)
18:03:48 <idev> hmm
18:03:49 <idev> why can't it be
18:03:53 <dolio> Just auto doesn't work?
18:03:53 <Cale> Once you apply the hypothesis, the resulting 3 goals of type ((True -> False) -> False), (False -> False) and True are all solvable using auto.
18:03:57 <idev> intro H; apply (H True False False); auto.
18:04:03 <Cale> oh, it can.
18:04:05 <idev> or just import CPDT; crush;
18:04:15 <Cale> heh
18:04:25 <Cale> does crush do it?
18:04:44 <idev> no idea; I thin kthe guessing (H True False False) part still can't be automated and requires Cale's brilliance
18:04:45 <Cale> It would have to be clever to try instantiating the variable types to True and False
18:04:55 <monochrom> if you use too much automation, it is no more enlightening than djinn's answer
18:05:01 <Cale> right
18:05:06 <idev> did djinn provide a proof?
18:05:18 <Cale> yes, in a sense
18:05:26 <AbelianGrape> So if I'm using Snap these days, do I ever touch the Snap monad or do I just write snaplets?
18:05:31 <idev> anyone else here scared that within a decade, computers will steal most programming jobs?
18:05:31 <monochrom> as much as "crush" does
18:06:05 <Cale> Well, to be fair, djinn can't quite do the same proof that we're doing in Coq here.
18:06:06 <monochrom> I am not scared.
18:06:10 <hpc> idev: my dream is that in a decade, programming will mostly consist of writing types for things
18:06:38 <monochrom> because two decades ago I already thought "within a decade, computers will steal most programming jobs"
18:06:48 <monochrom> and look at where we stand today
18:07:09 <monochrom> in fact, two decades ago, I thought I could help speed it up, too
18:07:20 <idev> we live in a world today where someone take to do 3 month ROR bootcamp and write programs that teams of researchers couldn't build in assembly
18:07:23 <monochrom> then I found Haskell.
18:07:38 <idev> it seem like in a decade, we'll have a language so high level you could feed it random noise
18:07:46 <idev> and it'll produce more important code that what teams today do
18:07:52 <Cale> hpc: My dream is that type inference and term inference can meet in the middle somehow, and you can specify just enough bits and pieces of things, whichever way around is easiest for you.
18:08:03 <AbelianGrape> What's the current state of the art on automated program/proof writing in Coq-style dependently typed languages? I'm thinking about doing an auto-prover
18:08:17 <idev> my dream is that someone does end to end deep learning; where input is a vague manager description, and output is working x86 code
18:08:25 <Cale> haha
18:08:41 <simpson> https://www.reddit.com/r/haskell/comments/45q90s/is_anything_being_done_to_remedy_the_soul/d003yap
18:08:42 <monochrom> please output FPGA instead
18:08:50 <hpc> output mips instead
18:08:55 <simpson> Huh. Is this true, that nanopass is unavoidably slow? I've never heard this before.
18:09:26 <Cale> AbelianGrape: Well, the *useful* things which do proof searches generally only handle problems of various restricted classes.
18:09:56 <shanemikel> i wonder what this 'so' person is thinking with a SN like that
18:10:14 <AbelianGrape> Cale: Any papers about this? I'm thinking about just searching through in-scope terms
18:10:17 <shanemikel> I probably flash him 20 times a day
18:11:15 <hpc> you get used to it
18:11:21 <hpc> @hoogle hpc
18:11:23 <lambdabot> package hpc
18:11:23 <lambdabot> package hpc-coveralls
18:11:23 <lambdabot> package hpc-strobe
18:11:31 <monochrom> perhaps he turns off flash
18:23:26 <Profpatsch> When would I use the Poduct and Sum monoids?
18:23:41 <Profpatsch> I can always fold over * and +, can’t I?
18:24:20 <Cale> Profpatsch: When something you're using works with an arbitrary monoid, and you want it to add or multiply numbers
18:24:37 <Profpatsch> Ah, okay.
18:25:18 <Cale> Profpatsch: For example, WriterT (Product Rational) [] is a monad which can keep track of "weights" or "probabilities" of each outcome.
18:26:14 <Profpatsch> Ah, because writer needs a Monoid that it can write to.
18:26:20 <Cale> When you  tell (Product p)  it will multiply the weight of the current branch of the computation by p, and in the end when you run the thing, you'll get a list of results along with their weights.
18:27:18 <Cale> Yeah, and any monoid will do, but you need to express which one you want -- there are at least two plausible monoids you might want on any given numeric type, so the Sum and Product newtypes let you say which one.
18:27:56 <Profpatsch> It’s the „more than one instances for a typeclass“ problem
18:28:04 <Cale> yeah
18:30:19 <Profpatsch> I had trouble understanding those until I noticed the crucial lines are inside the instances.
18:30:44 <nitrix> Profpatsch: Yeah. Idiomatic Haskell so far has been to define newtypes for competing instances.
18:30:46 <Profpatsch> So Alt makes any Alternative/MonadPlus into a Monoid.
18:30:52 <nitrix> Profpatsch: ZipList being another example.
18:31:04 <Profpatsch> nitrix: “so far”?
18:31:14 <Profpatsch> Will we get named instances?
18:31:25 <hpc> someday maybe
18:31:30 <hpc> or maybe something even differenter
18:31:44 <nitrix> Profpatsch: Haskell evolved and will surely keep evolving; who knows.
18:32:01 <hpc> haskell is used for active CS research, so it evolves rapidly
18:32:35 <Profpatsch> Purescript has them, but I don’t know if you can use them to tell the compiler which instance you want to use.
18:32:48 <Profpatsch> Ah, no
18:32:50 <Profpatsch> The instance names are used to help the readability of compiled JavaScript.
18:35:52 <nitrix> > (+) <$> [1,2,3] <*> [4,5,6]
18:35:54 <lambdabot>  [5,6,7,6,7,8,7,8,9]
18:35:59 <nitrix> > (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
18:36:00 <lambdabot>  ZipList {getZipList = [5,7,9]}
18:36:03 <hpc> i will never get used to "compiled javascript" being a thing people say
18:36:19 <nitrix> Profpatsch: ^ For a concrete example. Sorry, it obsess me when I talk about something and can't show it :)
18:38:12 <Profpatsch> hpc: Well, you compile down to assembler as well.
18:38:21 * hackagebot cabal-debian 4.32.4 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.32.4 (DavidFox)
18:39:04 <Xnuk> > (,) <$> [1..3] <*> [4..6]
18:39:05 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
18:41:00 <Profpatsch> nitrix: So the default is a cross product, the ZipList is the pointwise product.
18:43:40 <Profpatsch> Oh, no.
18:44:15 <nitrix> If I get the jargon right, then yes.
18:44:17 <hpc> no, that was right
18:44:49 <Profpatsch> It’s a cartesian product.
18:44:52 <nitrix> Profpatsch: There's luckily not that many of those cases in base; it's a little more common in bigger libraries.
18:45:05 <hpc> also you get a sticker for reminding me of the word "pointwise"
18:45:30 <nitrix> Cartesian product and pointwise sounds correct :)
18:46:17 <Profpatsch> In German the term „Kreuzprodukt“, cross product means both the cartesian product on sets (“everything with everything”) and the cross product on vectors (which is something entirely different afaik).
18:46:25 <hpc> Profpatsch: for your next trick, read the last 24 hours of scrollback and see if LogicT makes sense to you as well ;)
18:46:59 <Profpatsch> I’m not even sure if a cartesian product on lists even makes sense.
18:47:33 <EvanR> as sets?
18:47:44 <Profpatsch> One probably wants to use a term from stochastics for this …
18:47:59 <EvanR> ([], []) ([], [a0]) ([], [a0,a1]) ...
18:48:02 <Profpatsch> EvanR: Yeah, but only if you deduplicate after the fact.
18:48:15 <Profpatsch> There was a nice function for this.
18:48:16 <EvanR> there would be no dups right..
18:49:10 <Zemyla> This is interesting.
18:49:17 <Zemyla> > let { add1 :: State Int (); add1 = do { i <- get; put (i + 1) } } in execState (do { add1; add1; add1 }) 3
18:49:18 <lambdabot>  4
18:49:57 <hpc> what's that unicode character?
18:50:25 <EvanR> i see all the letters and they seem latin enough
18:50:33 <idev> clojure's transducers
18:50:39 <idev> are they like haskell lens?
18:50:42 <Profpatsch> hpc: I’ve been wanting to use LogicT for something.
18:50:45 <hpc> oh, maybe it's an nbsp or something dumb like that
18:51:10 <Zemyla> So why is it only adding 1 once?
18:51:19 <Profpatsch> But I haven’t been able to find a productive problem that could be solved with Prolog/MiniKanren yet. :P
18:51:53 <hpc> Zemyla: oh, does it need semicolons?
18:52:07 <Zemyla> It has semicolons.
18:52:15 <cheater> you normally do not write any snaplets, you write everything in the Snap monad
18:52:16 <hpc> maybe that's the unicode then
18:52:49 <Zemyla> Actually, this is what I did.
18:52:52 <EvanR> > let { add1 :: State Int (); add1 = do { i <- get; put (i + 1) } } in execState (do { add1; add1; add1 }) 3
18:52:54 <lambdabot>  6
18:52:55 <Profpatsch> hpc: My only “achievement” in this direction was asking a question on SO that was answered by The Byrd himself https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp
18:52:55 <Zemyla> :t (;)
18:52:56 <lambdabot> b -> a -> a
18:53:07 <EvanR> tricky
18:53:21 <EvanR> literally a programmable semicolon
18:53:41 <cheater> ; is a function?
18:53:45 <cheater> i thought it was syntax.
18:53:54 <hpc> it's a unicode homoglyph
18:53:59 <EvanR> > ord ';'
18:54:00 <lambdabot>  59
18:54:02 <cheater> ok
18:54:02 <EvanR> >ord ';'
18:54:13 <hpc> > ord ';'
18:54:13 <tealdeer> > programmable semicolon
18:54:14 <lambdabot>  894
18:54:16 <lambdabot>  Not in scope: ‘programmable’Not in scope: ‘semicolon’
18:54:22 <Zemyla> It's the Unicode Greek question mark.
18:54:24 <EvanR> > ord ';'
18:54:25 <cheater> devious
18:54:27 <lambdabot>  59
18:54:37 <cheater> you should flip the arguments
18:54:40 <cheater> to make it even worse
18:54:54 <slaterr> @src (;)
18:54:55 <lambdabot> Source not found. I feel much better now.
18:55:34 <hpc> Zemyla: and you would have gotten away with it if it wasn't for my client's broken font fallbacks
18:55:35 <slaterr> how can (;) function exist when ; is part of haskell syntax
18:55:52 <cheater> it's a different ;
18:55:58 <EvanR> > let (;) = (+) in 3 ; 3
18:56:00 <lambdabot>  <hint>:1:6: parse error on input ‘;’
18:56:06 <cheater> they used something that looks the same but in fact it's a unicode glyph
18:56:13 <EvanR> i cant seem to copy and paste 894 properly
18:56:30 <cheater> > let (;) = (+) in 3 ; 3
18:56:31 <lambdabot>  6
18:57:06 <EvanR> why the heck did unicode make a separate semicolon character for greek questio mark o_O
18:57:31 <Zemyla> Because that's what a Greek question mark looks like.
18:57:34 <EvanR> we dont have separate 'a' in all the euro langs
18:58:16 <EvanR> (i already know the answer)
19:32:55 <dolio> How else would you use up 21 bits?
19:58:23 * hackagebot tn 4.0.0.0 - A simple daily journal program  https://hackage.haskell.org/package/tn-4.0.0.0 (pharpend)
20:30:55 <roconnor> Proxy is so cool.
20:42:32 <quantz_> Anyone familiar with lambda calculus? I have a question I'm stuck on
20:51:22 <Cale> quantz_: yep, most people here would be ;)
20:51:34 <Cale> quantz_: But it really helps to know which question
20:51:59 <quantz_> Okay, here is my question with work: http://pastebin.com/Cdarrj6S -- I am stuck at beta reducing it beyond step 7 I don't know what to do with the free variable z1
20:56:55 <renkon> thanks people for the responses to my questions, tomorrow is my exam, wish me luck, gn!
21:09:26 <pavonia> quantz_: You cannot reduce z1 because there's no argument
21:10:25 <quantz_> ok
21:10:28 <quantz_> so what do i do
21:11:20 <pavonia> You have to reduce the expression on the righthand-size of the lambda expression
21:11:49 <pavonia> i.e. reduce the λx applications
21:13:21 <quantz_> (λx.z)(z1) --- x=z1 but there is no x in the expression and z is a free variable so it becomes z
21:13:21 <quantz_> ?
21:13:45 <quantz_> z1 and λx go away
21:14:14 <quantz_> is that correct?
21:14:21 <pavonia> Yep
21:16:08 <quantz_> that was confusing
21:16:12 <quantz_> i think i get it
21:16:18 <quantz_> ill let it sit and then come back to it
21:17:43 <quantz_> ok i get it
21:17:46 <quantz_> thank you
21:18:21 <quantz_> i havent made it to studying haskell yet (very soon), but how does learning about beta reductions, combinators, alpha eq., anon functions, church-rosser etc. apply/help with haskell?
21:20:28 <idev> does haskell support typed undefined?
21:20:33 <idev> I want to say undefined, but I want to give it a type sig
21:20:47 <idev> and have ghc check for me "if I had an obj of this type, would it type checked" ?
21:20:54 <simpson> :t undefined
21:20:55 <lambdabot> t
21:21:03 <simpson> :t undefined :: [(Int, Char)]
21:21:05 <lambdabot> [(Int, Char)]
21:21:11 <simpson> You can pick any type for `undefined`.
21:21:26 <pavonia> quantz_: Haskell has lambda expression, so knowing how they work is an advantage. Not sure if it helps beyond that, though
21:21:55 <EvanR> idev: you can also use type holes to see what something "should" be
21:22:04 <EvanR> replace a variable with _
21:22:25 <quantz_> ok cool pavonia thanks
21:38:27 * hackagebot servant-server 0.7.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.7.1 (SoenkeHahn)
21:38:29 * hackagebot servant-client 0.7.1 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.7.1 (SoenkeHahn)
21:38:31 * hackagebot servant-cassava 0.7.1 - Servant CSV content-type for cassava  https://hackage.haskell.org/package/servant-cassava-0.7.1 (SoenkeHahn)
21:38:33 * hackagebot servant-docs 0.7.1 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.7.1 (SoenkeHahn)
21:38:35 * hackagebot servant-foreign 0.7.1 - Helpers for generating clients for servant APIs in any programming language  https://hackage.haskell.org/package/servant-foreign-0.7.1 (SoenkeHahn)
21:43:37 * hackagebot servant-js 0.7.1 - Automatically derive javascript functions to query servant webservices.  https://hackage.haskell.org/package/servant-js-0.7.1 (SoenkeHahn)
21:43:39 * hackagebot servant-blaze 0.7.1 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.7.1 (SoenkeHahn)
21:43:41 * hackagebot servant-lucid 0.7.1 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.7.1 (SoenkeHahn)
21:43:43 * hackagebot servant-mock 0.7.1 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.7.1 (SoenkeHahn)
21:51:17 <Big_G> Does anyone have suggestions how I might be able to test a Java server with haskell code?
22:04:05 <platz> when compiling GHC, does BuildFlavour=quick have less "optimizations" than BuildFlavour=perf ?
22:04:07 <sm> Big_G: I've written HTTP test scripts
22:04:22 <sm> using wreq
22:05:32 <sm> also you could do things like https://www.schoolofhaskell.com/user/christianpbrink/quickcheck-and-webdriver
22:20:48 <platz> going with `perf`
22:23:29 * hackagebot conduit-audio 0.2.0.2 - Combinators to efficiently slice and dice audio streams  https://hackage.haskell.org/package/conduit-audio-0.2.0.2 (mtolly)
22:23:31 * hackagebot conduit-audio-lame 0.1.2 - conduit-audio interface to the LAME MP3 library  https://hackage.haskell.org/package/conduit-audio-lame-0.1.2 (mtolly)
22:23:33 * hackagebot conduit-audio-sndfile 0.1.2 - conduit-audio interface to the libsndfile audio file library  https://hackage.haskell.org/package/conduit-audio-sndfile-0.1.2 (mtolly)
22:23:35 * hackagebot conduit-audio-samplerate 0.1.0.2 - conduit-audio interface to the libsamplerate resampling library  https://hackage.haskell.org/package/conduit-audio-samplerate-0.1.0.2 (mtolly)
23:03:32 * hackagebot tls 1.3.8 - TLS/SSL protocol native implementation (Server and Client)  https://hackage.haskell.org/package/tls-1.3.8 (VincentHanquez)
23:17:42 <idev> where is the Alternative class defined?
23:17:47 <idev> I'm googling but I keep on getting Applicative
23:17:56 <jle`> idev: :i Alternative
23:18:02 <cocreature> https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#t:Alternative
23:18:18 <jle`> and you should probably be using hoogle or a haskell search engine instead of google for searching things like this :)
23:18:24 <jle`> ghci> :i Alternative
23:18:38 <jle`>    -- Defined in ‘GHC.Base’
23:25:51 <akfp> no nightly stackage build these last days?
23:27:50 <cocreature> I’ve never figured out when stackage does nightly builds
23:37:59 <idev> wtf
23:38:14 <idev> is there some law that says beore I can  instance MonadPlus, I have to instance Alternative ?
23:39:38 <opqdonut> yes
23:39:43 <opqdonut> class (Alternative m, Monad m) => MonadPlus m
23:40:08 <opqdonut> oh right
23:40:13 <opqdonut> this is because these days we also have
23:40:22 <opqdonut> class Applicative m => Monad m where
23:40:57 <idev> I'm confused
23:41:02 <idev> so I need Functor+Applicative for Monad
23:41:03 <idev> that I get
23:41:13 <idev> but now, to implement MonadPlus, I need Alternative+Monad ?
23:41:27 <idev> is this typeclass inflation? why is everything so much more expensive?
23:41:28 <cocreature> you probably don’t need MonadPlus
23:41:31 <cocreature> just use Alternative
23:41:36 <opqdonut> that too
23:41:38 <idev> I need MonadPlus
23:41:41 <cocreature> why?
23:41:43 <idev> I'm implementing LogicT from scratch.
23:41:49 <idev> re-inventing the wheel ftw
23:41:52 <augur> @hoogle MonadPlus
23:41:53 <lambdabot> Control.Monad class Monad m => MonadPlus m
23:41:53 <lambdabot> package monadplus
23:41:54 <idev> learning more than I expected to
23:42:04 <augur> idev: no such law on the class!
23:42:09 <opqdonut> the docs say
23:42:11 <opqdonut> Minimal complete definition
23:42:11 <opqdonut> Nothing
23:42:13 <opqdonut> for MonadPlus
23:42:18 <cocreature> I still don’t see why you need MonadPlus for that
23:42:20 <opqdonut> because it just uses the definitions from Alternative
23:42:23 <cocreature> Alternative gives you the same thing
23:42:29 <opqdonut> so you can just have an empty MonadPlus instance
23:42:46 <cocreature> the only reason to use MonadPlus is if you want to work with some library that requires you to pass in MonadPlus
23:43:04 <idev> MonadLogic requires MonadPlus
23:43:12 <idev> logic is all about backtracking and having more tha one solutions
23:43:16 <idev> mplus and mzero are kinda important
23:43:16 <kadoban> The entire meaning of MonadPlus is just Monad + Alternative nowadays really, AFAIK.
23:43:37 <idev> doesn't <|> and mplus have different meanings
23:43:51 <idev> <|> is like I promnise you that if either has a solution, we'll get atleast one solution
23:43:54 <idev> whereas mplus is like: ALL THE SOLUTIONS
23:44:03 <Cale> idev: <|> is often all the solutions too
23:44:20 <Cale> and sometimes mplus isn't
23:44:33 <Cale> But they should correspond with each other
23:44:45 <Cale> > Just 45 `mplus` Just 7
23:44:47 <lambdabot>  Just 45
23:44:48 <augur> whatsthe gist of how LogicT works? is it just continuations instead of lists for backtracking?
23:44:57 <Cale> augur: yeah
23:45:15 <opqdonut> > Just 45 <|> Just 7
23:45:17 <lambdabot>  Just 45
23:45:21 <opqdonut> (just checking)
23:45:27 <augur> Cale: is there some subtle improvements involved beyond just tossing it through the continuization grinder?
23:45:44 <Cale> augur: at least when I last used it, it had much higher performance than lists, but it's not particularly subtle
23:45:55 <augur> right, ok
23:47:11 <augur> thats a shame. i had hoped it was more interesting that merely using continuations instead of lists :\
23:47:37 <augur> oh, but it does interleaving, right? thats interesting enough
23:48:29 <augur> i guess you could do interleaving with lists too, tho
23:48:51 <augur> its a shame that the article puts all the things into one place
23:49:52 <augur> i tried reading the logict paper ages ago before i really understood monad transformers and it was really brutal. too much going on at once :\
23:51:44 <zRecursive> Why does it need mask here "_ <- mask $ \restore -> forkIO $ try (restore a) >>= putMVar res" ?
23:52:12 <zRecursive> :t mask
23:52:14 <lambdabot> ((forall a. IO a -> IO a) -> IO b) -> IO b
