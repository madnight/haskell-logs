00:01:40 <Myrl-saki> I think I figured it out. Lol.
00:02:06 <Myrl-saki> @undefine
00:02:06 <lambdabot> Undefined.
00:02:16 <Myrl-saki> @let forkIO = return 1
00:02:17 <lambdabot>  Defined.
00:02:48 <EvanR> forkIO _ = return () ?
00:02:52 <EvanR> forkIO _ = return 1?
00:02:54 <Myrl-saki> EvanR: That can also work. :P
00:04:17 <Myrl-saki> :t let forkIO _ = return 1 in \f xs -> forM (transpose . chunksOf $ 16 xs) $ forkIO . mapM f
00:04:18 <lambdabot>     Couldn't match type ‘[e0] -> [[e0]]’ with ‘[[a]]’
00:04:18 <lambdabot>     Expected type: Int -> [[a]]
00:04:19 <lambdabot>       Actual type: Int -> [e0] -> [[e0]]
00:04:55 <Myrl-saki> Urgh, what did I write earlier? That seemd to work.
00:05:36 <Myrl-saki> @undefine
00:05:36 <lambdabot> Undefined.
00:05:53 <Myrl-saki> @let forkIO _ = return ()
00:05:54 <lambdabot>  Defined.
00:06:41 <Myrl-saki> :t \xs f -> forM (transpose . chunksOf 16 $ xs) (\xs -> forkIO (mapM f xs))
00:06:42 <lambdabot> (Monad m, Monad m1) => [a] -> (a -> m1 b) -> m [()]
00:06:46 <Myrl-saki> :D
00:06:59 <Myrl-saki> Finally.
00:07:20 <Myrl-saki> :t \xs f -> forM (transpose . chunksOf 16 $ xs) (forkIO . mapM f xs)
00:07:22 <lambdabot> Monad m => [a] -> (a -> [a] -> b) -> m [()]
00:07:47 <Myrl-saki> Woops, that's defined wrong. I'll just stop now that, since this might be a bit spammy.
00:09:58 <bollu> @Cale: in the graph category, the terminal object and initial object are both K_1 right?
00:09:58 <lambdabot> Unknown command, try @list
00:10:23 <bollu> Cale, EvanR: ^
00:10:55 <Cale> The empty graph is initial
00:11:15 <Cale> K_1 isn't terminal, because a graph only has a homomorphism to K_1 if it's 1-colourable
00:11:20 <Cale> i.e. if it has no edges
00:18:28 * hackagebot ini 0.3.5 - Quick and easy configuration files in the INI format.  https://hackage.haskell.org/package/ini-0.3.5 (ChrisDone)
00:24:07 <bollu> how do you catch an  std::exception through the FFI?
00:24:18 <bollu> I want to catch divide-by-zero
00:24:59 <Freundlich> Write a C++ program with a C API that catches the exception.
00:25:27 <Freundlich> Also, there isn't a divide-by-zero exception in C++. It's undefined.
00:25:44 <bollu> libc++abi.dylib: terminating with uncaught exception of type std::runtime_error: div: Division by zero
00:26:03 <bollu> wonder what's generating that then. Probably SymEngine. Thanks, I'll do that
01:27:59 <jacereda> I need some help with GHC.Generics, anyone?
01:28:57 <jacereda> I'm trying to get the route to a specific path in a nested record, something like this http://lpaste.net/2579151651071852544
01:29:10 <jacereda> but it's driving me nuts
01:33:32 * hackagebot random-variates 0.1.5.1 - "Uniform RNG => Non-Uniform RNGs"  https://hackage.haskell.org/package/random-variates-0.1.5.1 (kpratt)
01:44:56 <lyxia> jacereda: what's the meaning of the result of gstep?
01:47:17 <jacereda> lyxia: it returns a list of indices that when applied (via another 'walk' function) allow you to reach the field in question
01:47:40 <jacereda> so that you can, for instance, show that particular field
01:48:51 <jacereda> lyxia: the intention is to expose via FUSE a nested record
01:51:14 <jacereda> lyxia: I'm aware of gshow, but if possible I'd like to separate the 'handle' to the file or directory (the route obtained via gstep) from the operation (a show in the case of a read() operation)
01:53:48 <lyxia> jacereda: was something wrong with line 19?
01:54:37 <jacereda> lyxia: yes, that won't typecheck and that's the part I'm struggling with
01:55:33 <lyxia> ah, right, I see
01:56:46 <lyxia> do you only use GWalk to implement route?
01:57:05 <jacereda> yes
01:58:08 <lyxia> So, in (K1 x) there, x has type a, and you need some constraints on a to keep going
01:59:41 <lyxia> you need two functions, one which works on 'Rep's, one which works on regular datatypes (with appropriate constraints)
01:59:57 <lyxia> and you're missing the second one
02:00:14 <lyxia> basically route with one more parameter
02:01:06 <jacereda> lyxia: can you think of a similar class that can serve me as an example to get this one right?
02:03:33 * hackagebot simple-sendfile 0.2.23 - Cross platform library for the sendfile system call  https://hackage.haskell.org/package/simple-sendfile-0.2.23 (KazuYamamoto)
02:04:05 <lyxia> jacereda: look at the Encode example in the docs for GHC.Generics. They have two typeclasses: Encode and Encode'.
02:04:31 <lyxia> jacereda: Encode' corresponds to your GWalk, as it applies to generic Reps
02:05:03 <jacereda> lyxia: ok, thanks, will try following that one
02:15:11 <jacereda> lyxia: isn't the Encode example in the documentation broken?
02:16:00 <lyxia> I don't know, maybe.
02:16:14 <lyxia> what happened?
02:16:23 <jacereda> lyxia: looks like the default encode should read "default encode :: (Generic a, Encode' (Rep a)) => a -> [Bool]" instead of "default encode :: (Generic a) => a -> [Bool]"
02:17:51 <jacereda> http://lpaste.net/7514027842489810944
02:18:11 <lyxia> oh, yes indeed
02:18:18 <jacereda> even with that, I get errors
02:18:29 <jacereda> "No instance for (Generic Int)"
02:18:51 <jacereda> how come? Isn't Generic Int defined in GHC.Generics?
02:19:52 <lyxia> I have "for (Encode Int)", and this is fixed by adding an instance Encode Int
02:22:03 <jacereda> lyxia: in ghc8 this fails: http://lpaste.net/568016146519818240
02:22:25 <jacereda> that one has "instance Encode Int", but still I get the "No instance for (Generic Int)"
02:24:27 <jacereda> oh, right
02:24:46 <jacereda> I was missing the specific Encode Int implementation
02:25:24 <jacereda> I'll report the error in the documentation...
02:25:27 <lyxia> that's an odd error. did they remove Generic Int in GHC8?
02:25:36 <lyxia> I'm still on 7.10
02:25:57 <jacereda> lyxia, no, it's present in the sources
02:27:36 <lyxia> https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Generics.hs#L390 seems to have been fixed in the upcoming release
02:28:08 <jacereda> oh, right
02:30:00 <lyxia> and indeed the primitives are gone from this file
03:52:48 <zoran119> say i have 2 lists and want to generate permutations of them
03:53:13 <zoran119> i can do [ (x,y) | x <- listA, y <- listB ]
03:53:36 <zoran119> is there a way to do this in a more general way, for any number of lists?
03:54:10 <hpc> > sequence [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
03:54:12 <lambdabot>  [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2,...
03:54:20 <hpc> you likely want sequence
03:54:32 <hpc> :t sequence
03:54:34 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
03:55:24 <hpc> this of course, will not work if your lists are different types
03:55:56 <hpc> for that you would have to have a case for each number of lists up to whatever you want, and increasingly larger tuples
04:01:32 <zoran119> hpc: awesome, thanks!
04:08:12 <Xandaros> I see that there are type families for GHC.TypeLits now - does anyone happen to know of any libraries making use of them yet?
04:10:23 <aeryndunham> Argh, it was :l, not :1. I've been sitting here scratching my head in frustration that I couldn't even compile my first function :p
04:10:52 <mauke> this is why good coding fonts are important
04:11:13 <Xandaros> Also why people shouldn't use abbreviations when introducing things... :load would've been a lot clearer
04:11:21 <aeryndunham> Yes, it definitely would have
04:11:50 <mauke> l1I| O0ØQ@ rnm B8R
04:13:41 <Hafydd> If you can't tell the difference between O and @, you have some more serious problems in your life.
04:14:44 <Xandaros> Gotta be honest, though - the difference between 0 and Ø is rather subtle with my typeface
04:15:18 <aeryndunham> Now I just wish the tutorial would have said :load. I was already like :1 doesn't make any damn sense...
04:18:41 <Xandaros> Back to my question: Any libraries making use of TypeLits? In particular, I'd be very interested in an equivalent of sized-vectors, but using the Nats in base instead of type-natural
04:20:22 <s4ke> i would have never thought that i'd love haskell so much so fast :D
04:24:57 <Myrl-saki> ts <- forM (transpose . chunksOf 16 $ [0..n-1]) $ lift . forkIO . runMaybeT . mapM (\n -> do
04:25:01 <Myrl-saki> I should learn to write code..
04:25:13 <Myrl-saki> Because whatever that is, I don't think that's code.
04:25:48 <zzzz> Ive got a question regarding shouldNotTypecheck. when compiling the test with (-fdefer-type-errors) the compiler gives me a warning about the test not typechecking, but when running the tests, they fail with "Expected expression to not compile but it did compile". im confused
04:33:40 <Hafydd> zzzz: what did you expect to happen?
04:34:48 <zzzz> in my expectation is when i compile with defered type errors and then the compiler throws a warning about something not typechecking, the shouldNotTypecheck  test should pass?
04:35:02 <zzzz> you wanna see code?
04:46:47 <bazzle> how do I give stack a path to a local package that's not on hackage?
04:47:33 <zzzz> see http://docs.haskellstack.org/en/stable/yaml_configuration/ 
05:03:41 <lyxia> zzzz: where is that described
05:04:59 <lyxia> zzzz: defer-type-errors is passed to the compiler so that it compiles programs that do not pass typechecking, what cabal sees is simply that the program compiled.
05:06:00 <ironChicken> i have a parsec parser and i want to provide an executable which reads from stdin
05:06:09 <ironChicken> is there something better than just { in <- getConetnts; parse in }
05:07:10 <Myrl-saki> Question. What are the monad rules when defined by join?
05:10:02 <lyxia> join . return = id ; return . join = id ?
05:10:05 <zzzz> lyxia: let me elaborate my problem a bit, here is the code which should describe my issue
05:10:17 <zzzz> http://lpaste.net/4260136116251787264
05:10:47 <ski> Myrl-saki : i assume you mean the monad laws, stated in terms of `fmap',`return',`join' : left identity is `join . return = id', right identity is `join . fmap return = id', associativity is `join . join = join . fmap join'
05:11:12 <Myrl-saki> ski: Yes! Thanks.
05:11:12 <ski> lyxia : `return . join' is emphatically not `id', in the general case
05:11:28 <lyxia> ah, right, of course
05:11:32 <Myrl-saki> join . join = fmap . join seems pretty interesting.
05:11:41 <ski> ?
05:11:43 <hpc> > return . join $ [[1, 2, 3], [4, 5, 6]]
05:11:45 <lambdabot>      No instance for (Show (m0 [a0]))
05:11:45 <lambdabot>        arising from a use of ‘show_M366891229186458436820847’
05:11:45 <lambdabot>      The type variables ‘m0’, ‘a0’ are ambiguous
05:11:45 <Myrl-saki> Err
05:11:48 <Myrl-saki> join . fmap . join*
05:11:53 <Myrl-saki> Ahh fuck
05:11:54 <hpc> :t return . join
05:11:56 <lambdabot> (Monad m, Monad m1) => m1 (m1 a) -> m (m1 a)
05:12:02 <Myrl-saki> I don't know how to type today.
05:12:06 <hpc> > return . join $ [[1, 2, 3], [4, 5, 6]] :: [[Int]]
05:12:07 <lambdabot>  [[1,2,3,4,5,6]]
05:12:13 <Myrl-saki> join . join = join . fmap join* there we go.
05:13:48 <ski> (in terms of a syntax i've been pondering, the laws become `join (| return (| |),m |) = m', `join (| m,return (| |) |) = m', `join (| join (| m0,m1 |),m2 |) = join (| m0,join (| m1,m2 |) |)')
05:14:27 <lyxia> what is (|
05:14:37 <ski> "composition tuple"
05:15:09 <ski> if `m :: IO' and `l :: []', then `(| m,l |) :: IO . []'
05:15:23 <ski> (this is a bit weird, i know)
05:16:22 <ski> (and the "and" there is noncommutative, in general)
05:16:26 <Myrl-saki> I do'nt get it. :P
05:16:53 <ski> Myrl-saki : what i wrote is not Haskell syntax
05:17:52 <ski> i was using `return : id >---> m' and `join : m . m >---> m'
05:18:10 <ski> (those are natural transformations between respective functors)
05:18:33 * ski should try to implement this in a type system, some time
05:19:29 <ski> but anyway, if you use the more categorical syntax, the laws still look a bit nicer than the Haskell version
05:25:31 <Myrl-saki> Wai...
05:25:33 <Myrl-saki> Wait*
05:25:42 <Myrl-saki> Oh, okay. Now I understand them.
05:26:42 <ski>   η : I ⟶ M
05:26:46 <ski>   μ : M ∘ M ⟶ M
05:26:48 <ski> iow
05:26:55 <ski>   η_A : A ⟶ M A
05:27:02 <ski>   μ_A : M (M A) ⟶ M A
05:27:10 <ski> then
05:27:37 <ski>   μ_A ∘ η_{M A} = I_{M A}
05:27:43 <ski>   μ_A ∘ M η_A = I_{M A}
05:27:54 <TCZ> hahaha egyptian symbols ? xd
05:27:54 <ski>   μ_A ∘ η_{M A} = μ_A ∘ M η_A
05:28:01 <ski> nah, greek
05:28:09 <TCZ> k
05:28:54 <ski> ⌜η⌝ is the traditional CT name for `return', and ⌜μ⌝ is the traditional CT name for `join'
05:29:56 <ski> ⌜I⌝ here is the identity (`id' in Haskell), and ⌜∘⌝ is composition (`.' in Haskell)
05:32:18 <ski> Myrl-saki : the point is, if we write out explicitly at which instance the polymorphic operation `join'/⌜μ⌝ is used at, then i think both the identity laws and the associativity law becomes clearer
05:33:39 <ski> there's an ⌜M⌝ in both ⌜μ_A ∘ η_{M A}⌝ and ⌜μ_A ∘ M η_A⌝. in the latter case it corresponds to `fmap', but in the former case we don't see it, because it refers to the fact that we use `return :: m a -> m (m a)' rather than `return :: a -> m a'
05:34:31 <ski> if we passed explicit type arguments in the Haskell code, then we'd see it
05:36:51 <ski> oh, i erred slightly
05:36:56 <ski> the last law should read
05:37:10 <ski>   μ_A ∘ μ_{M A} = μ_A ∘ M μ_A
05:37:44 <ski> (using ⌜μ⌝, not ⌜η⌝)
05:38:11 * Xandaros finds it funny how ski uses all sorts of weird unicode characters, but uses ` and ' instead of ‘ and ’
05:41:13 <notdan> i will try using ' and ` for ‘ and ’ from now on
05:42:01 <TCZ> how to write in third person
05:42:05 <TCZ> like xandaros
05:42:15 <Xandaros> ./me
05:42:16 <ski> /me looks at TCZ
05:42:26 * TCZ looks at ski
05:42:29 <TCZ> 10x
05:43:18 <ski> anyway .. my currently preferred way of writing the laws (not considering the WIP syntax mentioned above) is
05:43:22 <ski>   ⌜⌞μ⌟ A⌝ ∘ ⌜⌞η⌟ (M A)⌝ = ⌜M A⌝
05:43:26 <ski>   ⌜⌞μ⌟ A⌝ ∘ ⌜M (⌞η⌟ A)⌝ = ⌜M A⌝
05:43:32 <ski>   ⌜⌞μ⌟ A⌝ ∘ ⌜⌞μ⌟ (M A)⌝ = ⌜⌞μ⌟ A⌝ ∘ ⌜M (⌞μ⌟ A)⌝
05:43:40 <ski> or, shorter (more pointless) :
05:43:43 <ski>       μ ∘ ⌜⌞η⌟ ∘ M⌝ = ⌜M⌝
05:43:46 <ski>   μ ∘ ⌜M ∘ ⌞η⌟ = ⌜M⌝
05:43:48 <ski>   μ ∘ ⌜⌞μ⌟ ∘ M⌝ = μ ∘ ⌜M ∘ ⌞μ⌟⌝
05:44:51 <hjljo> yikes
05:50:26 <Hafydd> Hahaha.
05:50:29 <Hafydd> It's getting worse.
05:51:42 <ski> the problem with the traditional CT version (apart from not clearly showing the symmetry) is that it's not exact enough, for my taste
05:52:37 <ski> the former of the last two versions above were in terms of morphisms of the category. the latter was directly in terms of natural transformations
05:55:08 <ski> here's a variant expression of the last one, which explicitly shows the intermediate types/objects (all being endofunctors, in this case)
05:55:12 <ski>   {⤙ M ←{ μ }⤙ (M ←{ η }⤙ I) ∘ M ←}  =  {⤙ M ←}
05:55:19 <ski>   {⤙ M ←{ μ }⤙ M ∘ (M ←{ η }⤙ I) ←}  =  {⤙ M ←}
05:55:28 <ski>   {⤙ M ←{ μ }⤙ (M ←{ μ }⤙ M ∘ M) ∘ M ←}  =  {⤙ M ←{ μ }⤙ M ∘ (M ←{ μ }⤙ M ∘ M) ←}
06:01:45 <ski> .. it should perhaps be remarked that there's `∘' at two different levels in e.g. `μ ∘ ⌜⌞η⌟ ∘ M⌝ = ⌜M⌝'. the first is composition of natural transformations. the latter is composition of (endo)functors, which is a bifunctor
06:02:38 <ski> (and the Quine quotes `⌜',`⌝',`⌞',`⌟' tells you which level you're at)
06:03:22 <Hafydd> Hahahah.
06:03:29 <Hafydd> "`⌜',`⌝',`⌞',`⌟'" is just a mess.
06:03:49 * hackagebot casr-logbook 0.0.8 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.0.8 (TonyMorris)
06:03:55 <ski> do you have a better suggestion for how to phrase that sentence ? :)
06:03:56 <davidkart> hello. Is that code correct ?http://vpaste.net/nQPGY
06:04:25 <Hafydd> ski: the Quine quotes ⌜ ⌝ ⌞ ⌟ tell you which level you're at.
06:05:35 <ski> Hafydd : that doesn't work, since i'm referring to the quotes as used in the object language, not the meta language (english)
06:05:59 <Hafydd> ski: why does that mean it doesn't work?
06:06:14 <ski> i'm not talking about how you'd use Quine quotes in english
06:06:25 <Hafydd> ski: but my version doesn't imply that.
06:06:46 <ski> i'm talking about an object language, hence to embed syntax from that object language in an english sentence, i need to quote
06:06:50 <Hafydd> They occur naked in the text, yes, but you're just referring to the characters.
06:06:54 <byorgey> davidkart: I'm not sure what you are asking, can you be more specific?
06:07:37 <davidkart> it's working, I mean do you have some improvements that could be made (basically about shortness) or general comments 
06:07:48 <Hafydd> ski: but your commentary about the quotes is a purely lexical one. It's not going to change your meaning to quote them.
06:07:57 <ski> saying `Fred has four characters.' is different from saying `"Fred" has four characters.'
06:08:03 <byorgey> davidkart: ah, sure.  First, note that   do { h <- getLine; return h}  is the same as just  'getLine'  (this is one of the monad laws)
06:08:25 <ski> quoting always changes meaning, from my standpoint
06:08:34 <byorgey> davidkart: and instead of  forM [1..8] (\a -> ...)  I would write   replicateM 8 ...  since you do not use 'a'
06:08:44 <byorgey> davidkart: so that whole thing becomes  height <- replicateM 8 getLine
06:08:50 * hackagebot casr-logbook 0.0.9 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.0.9 (TonyMorris)
06:08:57 <davidkart> what I found the more « weird » (i'm learning Haskell) is 
06:09:04 <Hafydd> ski: anybody would realise from the context that "⌜ ⌝ ⌞ ⌟" is presenting 4 characters, and not quoting the space character in two different ways.
06:09:46 * ski dislikes having to rely on the context so much for that kind of thing
06:10:23 <davidkart> byorgey, yes indeed
06:10:25 * ski unfortunately has to leave atm, though
06:10:26 <davidkart> thanks a lot
06:10:36 <Hafydd> I see.
06:10:45 <byorgey> davidkart: other than that it looks good to me
06:10:53 <byorgey> davidkart: what did you find weird?
06:10:56 <davidkart> now my program is consistently more elegant.
06:11:37 <Hafydd> Perhaps you'd prefer to say: the Quine quotes in "⌜⌝⌞⌟".
06:12:12 <davidkart> the forM [1..8] (\a-> do (stuff) return h) is actually a list of IO actions ? (correct me if I am wrong). and the '<-' operator is converting them into suitable string ? (correct me if I am wrong)
06:12:31 <davidkart> .So actually <- can map a list.
06:12:50 <davidkart> and the return statement is not needed.
06:13:21 <davidkart> since yeah, you told me h<-getLine ;return h is the same as getLine
06:13:33 <byorgey> davidkart: well, forM works by building a list of IO actions and then sequencing them into one IO action
06:13:46 <byorgey> davidkart: so  forM [1..8] (\a -> do (stuff) return h)  is not a list of IO actions
06:13:53 <byorgey> it is a single IO action that returns a list of strings
06:14:24 <byorgey> also, <- is not an operator, it doesn't convert anything.  It is just syntax which turns into >>=
06:14:45 <byorgey> <- is not doing any list mapping in this example.
06:15:34 <davidkart> well I will be ironic one more time :) In Haskell thingy things are not really the things they seem to be :)
06:15:48 <davidkart> btw, when I do forM[1..8](\a ->)
06:16:10 <davidkart> Is a a variable taking values in [1..8] ?
06:16:14 <byorgey> yes
06:16:26 <davidkart> so basically this is a lambda construct ?
06:16:57 <byorgey> \a -> ...   is a lambda construct, yes.  It is an anonymous function using lambda syntax.
06:17:15 <davidkart> And if I do [1..8]->(\a->2*a) does it give me [2,4..16] ?
06:18:08 <byorgey> map (\a -> 2*a) [1..8]  gives you  [2,4..16]
06:18:20 <byorgey> > map (\a -> 2*a) [1..8]
06:18:22 <lambdabot>  [2,4,6,8,10,12,14,16]
06:18:22 <davidkart> ok
06:18:34 <davidkart> so (\a -> 2*a) is really an anonymous function
06:18:38 <byorgey> yes
06:18:59 <davidkart> and what if I say (\a \b -> a+b)
06:19:21 <byorgey> that is a syntax error, but you can write  (\a b -> a + b)  or  (\a -> \b -> a + b),  they are the same
06:20:01 <davidkart> but then you can't use map
06:20:23 <byorgey> sure you can =)   map (\a b -> a + b) [1..8]  gives you a list of functions
06:20:44 <davidkart> The second is not equivalent
06:20:46 <byorgey> because  (\a b -> a + b)  is really a function that takes a single argument 'a' and returns the function  (\b -> a + b)
06:20:53 <hjljo> or you could
06:20:57 <hjljo> :t zipWith
06:20:58 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
06:21:09 <byorgey> no,  (\a b -> a + b)  and  (\a -> \b -> a + b)  are *exactly* the same.
06:21:23 <byorgey> the first one is just syntax sugar for the second one.
06:21:48 <byorgey> :t  map (\a b -> a + b) [1..8]
06:21:50 <lambdabot> (Enum a, Num a) => [a -> a]
06:22:20 <byorgey> it is the list of functions [\b -> 1+b, \b -> 2+b, \b -> 3+b, ...]
06:23:20 <davidkart> byorgey: oh, beautiful.
06:23:21 <Myrl-saki> ski: Woops, worry, I wasn't looking!
06:23:54 <davidkart> I''m alittle bit setted aback because teh interpreter won't show me that but instead throw me an error (No instance for (Show (a0->a0))
06:24:39 <Myrl-saki> ski: I see.
06:24:53 <byorgey> davidkart: right, because there is no default way to print out a function
06:24:56 <Hafydd> > map (\a b -> a + b) [1..8]
06:24:58 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
06:25:08 <Hafydd> Except with the Show instance lambdabot has.
06:25:12 <byorgey> davidkart: you can always ask for the type instead, to see if it makes sense
06:25:34 <hjljo> type ":t map (\a b -> a + b) [1..8]" in ghci
06:26:04 <Hafydd> t ":type map (\a b -> a + b) [1..8]" in ghci
06:26:22 <hjljo> or that
06:26:27 <byorgey> hehe
06:26:38 <davidkart> yes
06:26:45 <davidkart> another question IE have
06:27:05 <davidkart> can I do let [a,b,c,d]=[1,2,3,4] ?
06:27:09 <Hafydd> Yes.
06:27:19 <davidkart> then a is 1, b is 2, etc.
06:27:37 <Hafydd> i.e. the structure of lists can be pattern-matched on using that shorthand.
06:27:48 <byorgey> > let [a,b,c,d] = [1,2,3,4] in  a
06:27:50 <lambdabot>  1
06:27:51 <Xandaros> Yes. This works for any type, btw. Not just lists. (a,b) = (5,6). Just a = Just 5.
06:28:11 <davidkart> Just is a language keyçorrd
06:28:22 <davidkart> I cannot master all the key word right açway
06:28:25 <Xandaros> Just is a constructor, not a keyword
06:28:26 <davidkart> the picture is too big.
06:28:47 <Xandaros> It's not part of the ‘language’, it's part of the standard library. You can define it yourself, if you want.
06:29:04 <davidkart> Xandaros: what is the minimal subset for teh language ?
06:30:21 <Xandaros> Lambda, case and application? SKI? Depends on what you consider ‘minimal’
06:30:40 <Xandaros> (Actually, you don't need case. Lambda and application should do)
06:31:37 <davidkart> guards
06:31:42 <davidkart> ok
06:31:54 <davidkart> one last question : how do I write to stderr ?
06:31:55 <Xandaros> I think looking for a ‘minimal’ subset of the language is not very beneficial in learning it
06:32:24 <davidkart> Xandaros: yes, I suppose learning IO and the standard library are the basic of « new language learning ».
06:32:25 <byorgey> davidkart: use hPutStr or hPutStr stderr
06:32:29 <byorgey> davidkart: import System.IO
06:32:41 <byorgey> sorry, I meant  hPutStr stderr  or  hPutStrLn stderr
06:32:56 <davidkart> there is no documentation scheme (like docstring in python) with haskell ?
06:33:14 <Xandaros> davidkart: There is, it's called haddock
06:33:19 <davidkart> so that you can interactively consult the help of function or know about the currently in use functions.
06:33:31 <davidkart> Xandaros: seems fishy :p
06:36:48 <Xandaros> davidkart: If you're looking for documentation of a particular function or looking for a function of a certain type, hoogle is very helpful
06:36:51 <Xandaros> @url hoogle
06:36:51 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
06:38:39 <bazzle> thanks zzzz :)
06:46:55 <zzzz> you're welcome bazzle 
06:58:31 <davidkart> heyllo
06:58:48 <dmj`> davidkart: hey
06:59:06 <davidkart> I was thinking, since functionnal programming seems to be the standard way to define mathematically programming
06:59:11 <davidkart> (am I wrong) ?
06:59:31 <davidkart> anyway, imperative programming is clearly overwhelming
06:59:37 <davidkart> why is that so ?
06:59:46 <davidkart> And did you think of all the implications ?
07:00:05 <bergey> overwhelming?
07:00:58 <davidkart> Well java and C and C++ and python are like 80% of the practical use of programming language (not to forgot php but you see the point).
07:02:03 <davidkart> Lisp was invented in the 70 but it never got that much popular (it was at the beginning becauuse of computer science had essentially academic purposes)
07:02:24 <davidkart> the real popular language was basic and is fully imperative.
07:04:08 <davidkart> In fact any programming course starts with a simple thing : iteration
07:04:27 <Xandaros> davidkart: While functional languages are better in almost every way, it is far easier to write compilers for imperative languages. As such, it is not very surprising that the first languages were imperative. Another thing you have to remember, is that a lot of the theory we are used to today, either didn't exist back then or wasn't implemented, so functional languages weren't as powerful. (Heck, Haskell has
07:04:29 <Xandaros> been almost useless for a long time after its invention)
07:05:13 <Xandaros> Lisp is a very special kind of snowflake in itself. I'm not sure it really counts. (Besides, Lisp used to be quite popular)
07:05:24 <hpc> lisp is a family of languages
07:05:30 <hpc> the oldest lisps were not very functional
07:06:06 <hpc> one can argue the lisp family didn't really accept functional style until scheme
07:06:14 <bergey> My impression is it's mostly that people invent & learn languages similar to those that they know.  Most of the rest is that in 1950 or 1970 or 1984, computers were slow & expensive, programmers needed to think about hardware & assembly, and wanted languages that supported that.
07:07:29 <bergey> Python & JS owe at least as much to lisps as to C or Fortran.  A lot of the OO research was conducted in lisp.
07:07:54 <schjetne> I for one still haven't found an object system that can beat CLOS
07:07:59 <oherrala> Lots of new features in JDK are from Lisp :)
07:08:41 <bergey> Whatever bits of academic PLs turn out useful in industry, we relabel as "not academic" anymore.  These days, we probably call them OO. =)
07:09:11 <shapr> GOOD MORNING #haskell! Yay code!
07:09:42 <locallycompact> yay code!
07:10:22 <shapr> davidkart: you may have to let go of some of your beliefs about programming languages in order to fully appreciate Haskell.
07:13:10 <sm> good morning shapr!!
07:13:31 <dmj`> davidkart: it's easier to understand how functions manage complexity, since they can be reasoned about formally. Whereas with objects, when the code base grows, there's many moving pieces and it can be harder to know what's going on. You're only as good as the code you can understand. 
07:15:23 <c_wraith> the biggest benefit haskell provides is the ability to reason locally. There's a lot you can tell about what a piece of code does (and just as importantly, doesn't do) given just its type and implementation. 
07:16:31 <c_wraith> and that is the result of the combination of purity and the expressive type system. 
07:17:07 <obadz> c_wraith: +1
07:19:06 <xnull> is anyone working on a haskell binding for TensorFlow?
07:23:22 <sm> question: modern IDEs show a file's errors inline as you edit. Do they also have a way to show errors elsewhere in the package caused by your edit ? If not, a window running ghcid seems superior
07:24:58 <bazzle> one more thing - if I have some codebase that I want to compile with both ghc and ghcjs, is there a way of doing it in the came .cabal file?
07:25:07 <sm> I don't mean the current haskell IDEs specifically, but how would eg IDEA or visual studio handle that
07:28:08 <ggVGc> okay, how do I make IO in haskell not become like this? https://gist.github.com/04a3b4bb257d5c6737b00130e118c6ce
07:28:35 <davidkart> The type system is unreadable to me I don't understand it. That's where a good Haskell course should start.
07:28:37 <ggVGc> this is the first real project I've written in haskell, it's now 3400 lines, fairly feature rich and very stable, but the code has gone completely off the rails
07:28:53 <bergey> bazzle: Yes.  Look at the lines `if impl(ghcjs)` in https://github.com/ghcjs/ghcjs-dom/blob/master/ghcjs-dom.cabal
07:30:54 <ggVGc> davidkart: in my experience tye type system itself and the syntax for types isn't much, but because of the high level of abstraction possible, many type signatures in code you read is hard to understand
07:31:12 <ggVGc> i.e the abstraction itself is the difficult part
07:31:36 <dmj`> ggVGc: A state monad might help you here
07:31:42 <ggVGc> I understand haskell's type system fairly well, but there are still many libraries that are completely uncomprehesible to me
07:31:56 <ggVGc> dmj`: heh, help with which part? It's all a mess :(
07:32:04 <bazzle> bergey: I would need two sandboxes though, one configured with --ghcjs, right?
07:32:05 <ggVGc> I don't know how to manage these mvars and various callbacks etc.
07:32:10 <ggVGc> and I don't know how to write it in a better way
07:32:33 <ggVGc> without exploding the functions with parameter counts in the range of 5-10
07:32:37 <ggVGc> which is getting ridiculous
07:33:07 <bergey> ggVGc: I'd start by using "real" data types instead of tuples and type aliases.  
07:33:46 <ggVGc> bergey: yeah, that's fair, but why not type aliases?
07:34:09 <ggVGc> type aliases for typles that is
07:34:10 <bergey> If a bunch of functions all take the same set of parameters, that suggests adding another type.  If not, then I don't mind the large number of parameters.
07:34:58 <ggVGc> bergey: yeah, but this function which is the entry point setting everything up has become fairly insance, https://gist.github.com/22a91417b58beb8638ae945aa7e1d6e9
07:35:01 <ggVGc> insane*
07:35:18 <ggVGc> maybe it's also the way I structure the code, since I don't have any real idioms I follow
07:35:33 <bergey> Data types get you better type errors & type inference.  They're also a chance to add named functions (or lenses, since you're already using lenses) to access the fields, which makes the code easier to read.
07:35:55 <ggVGc> yeah, I mostly use records and lenses, but the unpacking of tuples is pretty convenient
07:36:02 <ggVGc> I often wish we could unpack records as lenses
07:36:18 <dmj`> ggVGc: you have a lot of higher order functions being passed in as parameters to functions. It might be beneficial to define a record with these fields as functions, then just pass in that object instead. This way you can get record -> IO (), which would be equivalent to ReaderT record IO (), if you find yourself doing a lot of concurrency using lifted-base, lifted-async would help reduce code as well
07:38:19 <dmj`> you also have a lot of little states being wrapped by MVars, maybe just flatten them, put them into a single record, then wrap that in an MVar
07:38:55 <ggVGc> dmj`: hm, but I didn't want to conflate the different mutable states into one
07:39:01 <ggVGc> but maybe that's actually reasonable in this case
07:39:17 <ggVGc> dmj`: I wanted to have a view of which functions process which mutable state
07:39:34 <ggVGc> I've never used ReaderT at all, so I guess I'll look at that
07:41:17 <ggVGc> dmj`: I've never used anything else for concurrency, but what would lifted-async give me here? All my concurrency is long running with some shared state essentially
07:41:21 <ggVGc> I don't have any background workers
07:41:31 <ggVGc> would I still benefit from lifted-async?
07:44:47 <dmj`> ggVGc: lifted-base would give you the 'fork' function (among other things), this let's you fork threads without escaping into I/O eternally. If you were in a ReaderT and ran forkIO :: IO () -> IO ThreadId, you're now stuck in I/O and can't 'ask' for your state anymore. If you use fork :: MonadBaseControl IO m => m () -> m ThreadId, you can still 'ask' for your reader state, but in a new thread. This might not be relevant to what you're
07:44:47 <dmj`> doing. But it would alleviate you from needing to define two functions, one for a -> IO (), or ReaderT a IO (). 
07:45:29 <sm> davidkart: speaking of a good haskell course, which of the haskell intros have you tried ?
07:46:51 <ggVGc> dmj`: mkay, thanks. I'll keep it in mind. need to learn to start using ReaderT first though
07:47:03 <dmj`> ggVGc: I would focus on a way of purifying your code. Since your code isn't very testable (since it's all in I/O). You can do this with free monads, typeclasses, or records.
07:47:03 <sm> http://haskellbook.com is considered good, and http://www.happylearnhaskelltutorial.com or https://www.schoolofhaskell.com/school/starting-with-haskell/introduction-to-haskell or https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell might be too
07:47:28 <ggVGc> dmj`: oh, but all of the actual functionality is pure
07:47:34 <ggVGc> this is essentially the only file with IO
07:48:21 <ggVGc> I can factor out some parts of it, and will, but the stuff that's there for now is experimental and hence why it's stayed in the IO stuff
07:48:27 <ggVGc> i.e lack of time/effort
07:48:49 <dmj`> ggVGc: I see, you might want to add logging then, there are some _ <- forkIO calls which would be difficult to track down if something goes wrong
07:50:10 <ggVGc> yeah I know
07:50:20 <ggVGc> but it hasn't been a problem yet
07:50:43 <ggVGc> I'm just starting to get lost in all this state juggling and dependency injection
07:50:53 <ggVGc> I'll try to define some more data types I guess
07:51:32 <ggVGc> dmj`: you made a good point though. I should probably group up these MVar contents into a smaller amount of collections
07:51:42 <ggVGc> maybe not all of them into one MVar, but definitely less MVars
07:51:47 <ggVGc> and a type for each
07:51:50 <ggVGc> that'll make it nicer
07:54:07 <dmj`> ggVGc: I'd try to make a single ADT, MVar ADT if you can, and only split it out if you have to.
07:55:16 <ggVGc> dmj`: yeah, that's actually a nice idea
07:55:17 <ggVGc> thanks
07:55:29 <ggVGc> that'll really simplify the type signatures
07:55:30 <ggVGc> cheers
07:55:45 <ggVGc> wow, that's actually a really nice way to handle shared state like this
07:56:48 <dmj`> data StateThings = StateThings { thing1 :: Foo, thing2 :: Bar }, initState :: IO (MVar StateThings); initState = newMVar defaultStateThings
07:58:13 <dmj`> data ActionThings m = ActionThings { changeThing1 :: Foo -> m (), changeThing2 :: Bar -> m () }, this way maybe you can mock out IO, replace it with a State, be purer
07:58:40 <dmj`> ggVGc: cheers
08:39:04 * hackagebot manifolds 0.2.2.0 - Coordinate-free hypersurfaces  https://hackage.haskell.org/package/manifolds-0.2.2.0 (leftaroundabout)
08:39:15 <fresheyeball> hey out there
08:39:45 <c_wraith> Hello yes this is dog.
08:39:53 <fresheyeball> has anyone out there used Auth0 with Haskell?
08:40:01 <fresheyeball> I'm have no luck verifying JWTs
08:40:03 <c_wraith> sorry, always wanted to answer with that. 
08:40:10 <fresheyeball> haha
08:40:30 <fresheyeball> https://www.stackage.org/lts-5.17/package/jwt-0.6.0
08:40:33 <fresheyeball> I'm using this lib
08:40:42 <fresheyeball> and I have a JWT I can verify easily on JWT.io
08:40:47 <fresheyeball> but it doesn't verify with this package
08:41:21 <c_wraith> are you providing the key as a Bytestring? 
08:41:55 <fresheyeball> c_wraith: I am
08:42:11 <fresheyeball> c_wraith: I am hard coding it, using XOverloadedStrings
08:42:17 <fresheyeball> just to test
08:42:30 <c_wraith> Oh... uh.. is it as ascii? 
08:42:37 <c_wraith> -as
08:42:45 <fresheyeball> oh!
08:42:54 <c_wraith> if the key is proper binary, that'd not going to work. 
08:43:07 <fresheyeball> I didn't think XOverloadedStrings would be ASCII
08:43:24 <c_wraith> it depends on the instance being used. 
08:43:56 <c_wraith> if you're importing the Char8 modules, that could be the problem. 
08:44:20 <c_wraith> their IsString instance for Bytestring is sketchy
08:44:23 <fresheyeball> http://lpaste.net/164045
08:45:00 <c_wraith> ok, that's not the problem, then.
08:45:12 <dolio> There is no difference in instances based on which module you import.
08:46:05 <c_wraith> dolio, unless orphan instances get involved, and there are some packages with orphan IsString instances
08:46:14 <dolio> bytestring isn't one.
08:46:23 <fresheyeball> http://lpaste.net/164046
08:46:27 <fresheyeball> ok
08:46:35 <c_wraith> no, but other libraries provide orphans *for* bytestring
08:46:56 <fresheyeball> c_wraith: That paste should have everything
08:47:00 <fresheyeball> how should I approach this
08:47:02 <fresheyeball> ?
08:47:37 <c_wraith> anyway, everything looks base64'd, more or less. so I don't think it's likely an encoding issue. 
08:48:04 <dolio> That's impossible, because the IsString instances for bytestring aren't orphans, so any other orphan instances would always lead to errors.
08:49:53 <c_wraith> last I checked, those instances existed only in the Char8 modules
08:51:04 <c_wraith> fresheyeball, well, I'm out of obvious things to check. I don't know the package, and I'm not in a place to investigate. 
08:51:42 <ironicaldiction> Was hit with a question by prof the other day for why monads are useful to stream programming (e.g. IO monad)
08:52:44 <monochrom> I would be smug and answer "because applicatives are useful for stream programming" :)
08:52:44 <c_wraith> ironicaldiction, remember that monad is only an abstraction that allows sharing code between things that potentially have no other connection. 
08:53:13 <monochrom> actually, on second thought, s/applicatives/arrows/
08:53:45 <c_wraith> so.. profunctor + applicative? 
08:53:46 <dolio> Is IO stream programming?
08:53:46 <monochrom> I think a prof (or anyone) who asks that question is unlikely to understand my answer.
08:54:39 <oherrala> monochrom: which is? :)
08:54:48 <monochrom> I gave my answer above.
08:54:51 <oherrala> ah
08:56:02 <dolio> I'm still wondering what "stream programming" is. But we'll probably never find out.
08:56:53 <monochrom> a prof who asks that question is likely to have multiple misconceptions themselves
08:57:54 <monochrom> hmm, themself? :)
08:58:40 <oherrala> professors usually wear multiple hats, so probably multiple heads aka personalities also :)
08:58:43 <dolio> Your original phrasing is acceptable to us.
08:59:40 <ironicaldiction> my thought was that it's really the only way to deal with "impure" data but I guess that wasn't quite what they were loooking for
09:02:20 <TheMystic> I think we'd need a rigorous definition of what "stream programming" entails to answer that question...
09:03:14 <ironicaldiction> Okay let's narrow it to just iO
09:03:34 <ironicaldiction> for the sake of everyone's sanity :)
09:06:57 <monochrom> dear c_wraith, I tested {-# LANGUAGE OverloadedStrings #-}; import Data.ByteString; x :: ByteString; x = "abc". There was no error, so it looks like the IsString instance was present.
09:07:29 <monochrom> I also tested: import Data.String; import Data.ByteString; x :: ByteString; x = fromString "abc". Still no error.
09:07:51 <obadz> ironicaldiction: well the fact that there's a mapping between do-notation and return/>>= is a hint that monads are useful for do-style stuff maybe? (also works for less powerful Applicative/Functor in some instances)
09:07:57 <c_wraith> I wonder if that's a change, or if I just remembered incorrectly. 
09:08:05 <slack1256> if using hakyll, what is the most easier webserver to set up?
09:08:12 <monochrom> I finally asked ghci :info. It replied: instance Data.String.IsString ByteString  -- Defined in ‘Data.ByteString.Internal’
09:08:29 <TheMystic> slack1256: doesn't hakyll just generate static html files?
09:08:51 <c_wraith> slack1256, something like lighthttpd, if you're running it yourself, I guess. 
09:09:14 <TheMystic> nginx, apache, whatever
09:09:30 <slack1256> TheMystic: yes. I still need a web server for them right?
09:09:49 <maerwald> try hiawatha
09:10:01 <TheMystic> slack1256: yes, something has to respond to HTTP requests on a listening socket and send the files back
09:10:27 <slack1256> OK and a haskell option? or isn't worth for this case?
09:10:42 <slack1256> I will check hiawatha and lighthttpd
09:10:46 <TheMystic> there used to even be an httpd that ran inside the linux kernel ;)
09:11:29 <fresheyeball> c_wraith: so how would I test the Char8 thing?
09:11:45 <slack1256> kernel space? really?
09:12:01 <TheMystic> yeah, not sure if it's still maintained
09:12:04 <jdreaver> If I wrap a list in a newtype, is there an easy way to derive things like Traversable, IsList, etc automatically so that the new type acts like a list?
09:12:16 <c_wraith> fresheyeball, I don't think the problem is likely related to encodings, after looking at your code. 
09:12:25 <oherrala> slack1256: yeah
09:12:26 <slack1256> jdreaver: that's the whole point
09:12:44 <fresheyeball> c_wraith: :(
09:12:51 <slack1256> jdreaver: generalized newtypes deriving are the keywords your are looking
09:12:56 <fresheyeball> so... should I give up and use node.js?
09:13:01 <monochrom> I bet that if the x86 CPU could receive firmware, some people would put a web server there, too.
09:13:58 <oherrala> slack1256: http://www.fenrus.demon.nl/
09:14:01 <jdreaver> Thanks slack1256. I don't think GeneralizedNewtypeDeriving or DeriveAnyClass work for, say, IsList or Traversable. Num classes are easy to wrap (you can automatically derive Num for the newtype)
09:14:10 <oherrala> ''As of kernel 2.3.14, kHTTPd is integrated into the kernel. Kernel 2.3.14 integrates the equivalent of version 0.1.6b.''
09:14:20 <jdreaver> Just wondering if there was a simpler way than manually creating the Traversable or IsList instances :)
09:15:49 <jdreaver> Actually I just discovered DeriveTraversable, I wonder how that will work.
09:28:37 <fizzil> I'm looking to do category theory for my final year project but i need an idea for an implimentation, any thoughts?
09:30:13 <monochrom> what is there to implement?
09:30:23 <fresheyeball> c_wraith: sorry, I had to do a meeting. Anyway, is it time to give up and use node.js or do you see a way I can complete this in Haskell? 
09:31:39 <c_wraith> fresheyeball, I doubt that the library would just plain not work. I think there's a way to get it going, but I don't know the library and am not in a position to investigate for a while. 
09:31:55 <fresheyeball> ok
09:32:01 <fizzil> i need to develop a prototype or demonstration but im having difficulty coming up with one involving category theory.
09:33:05 <ggVGc> fizzil: some type inference?
09:34:13 <monochrom> implement a lambda calculus interpreter or compiler. claim that you have implemented a cartesian-closed category.
09:35:24 <monochrom> more seriously and frankly, if you asked "I want my final year project to be set theory, what should I implement", it would be just as lost as well. I don't know, implement finite maps?
09:35:50 <maerwald> make a new lens implementation
09:36:04 <monochrom> or topology, or Galois theory, or K-theory, etc etc
09:39:06 * hackagebot quickbooks 0.5.0.1 - QuickBooks API binding.  https://hackage.haskell.org/package/quickbooks-0.5.0.1 (jpvillaisaza)
09:44:14 <fizzil> maerwald thanks thats what im looking for
09:47:29 <sm> ooh
10:00:40 <dolio> monochrom: For set theory, you can implement anything, because everyone knows that all mathematics is best thought of as being just about sets.
10:11:53 <orion__> dolio: What about categories?
10:13:16 * slack1256 is happy bc his final presentation is about fundamental group & homotopies
10:13:23 <dolio> What about them? They're tools of young upstarts who don't realize that ZFC is the true foundations of mathematics.
10:13:29 <slack1256> soon I will _understand_ something about homotopy type theory
10:14:21 <mnoonan> dolio: what kind of zealot puts an unrestricted axiom of choice in the foundations?!
10:19:08 * hackagebot harvest-api 0.1.0 - Bindings for Harvest API  https://hackage.haskell.org/package/harvest-api-0.1.0 (jpvillaisaza)
10:24:26 <johnw> dolio: I sense sarcasm
10:28:19 <dolio> Oh yeah?
10:28:31 <johnw> it's early, my ability to read dolio might be compromised
10:43:08 <GLM> Is there a way to get the behavior people use STM for (atomicity) when doing IO like writing to a database?
10:43:34 <johnw> if the database supports transactions you can
10:43:36 <johnw> but not for IO in general
10:43:43 <johnw> you can't unlaunch a missile
10:43:46 <monochrom> I think dolio was joking.
10:44:02 <monochrom> but a zealot would be one who rejects the axiom of choice :)
10:44:24 <puregreen> GLM: transactions are a very hard problem (e.g. see how Sqlite implements them: https://www.sqlite.org/atomiccommit.html)
10:45:13 <monochrom> actually, I think it's efficient transactions that's hard
10:45:19 <dolio> Yeah, I mean, it's totally intuitive that you can just choose things.
10:45:26 <GLM> johnw: I know that I cant unlaunch a missile. Would there be some custom API for STM to make sure that the entire Request->Response transaction is atomic?
10:45:33 <dolio> Only some kind of weirdo would disagree.
10:45:36 <johnw> I choose to abandon the axiom of choice
10:45:56 <fishythefish> axiom of choice - choosing socks is easy; choosing shoes is hard
10:46:04 <nitrix> pyon: Do you have a good article about lifted, unlifted, boxed, unboxed, unpack pragma ?
10:46:06 <fishythefish> (but possible)
10:46:22 <johnw> "To be or not to be, that is the non-constructive question."
10:47:29 <monochrom> nitrix: I came across the definitions in GHC 8.0.1 user guide. (because they need to say it before talking about the new runtime-representation polymorphism)
10:47:53 <Zemyla> fishythefish: You have it the wrong way around.
10:48:00 <monochrom> lifted = has bottom. boxed = is pointer to heap object.
10:48:01 <Zemyla> Choosing shoes is easy; you just take the left one.
10:48:12 <Zemyla> Choosing socks is hard, because they're indistinguishable.
10:49:21 <monochrom> the two overlap very much. you may wonder why there are two names and definitions. I did too. here is an example of difference: array# has no bottom (unlifted), but you still want to put it on the heap and use a pointer to it (boxed)
10:49:36 <dolio> Zemyla: If they're indistinguishable, how can you have a set of more than one of them?
10:50:06 <monochrom> but that's a corner case really. for the most part, lifted and boxed overlap a lot, similarly unlifted and unboxed
10:50:12 <fishythefish> Zemyla: *facepalm*
10:50:13 <fishythefish> it's too early
10:51:54 * dolio kind of suspects the shoe/sock analogy doesn't hold up to scrutiny.
10:52:13 * fishythefish suspects dolio's socks are labeled L/R
10:52:56 <c_wraith> monochrom, so only things that are lifted are scrutinized for evaluation? 
10:53:09 <nolrai> So, would there be a way to [ab]use lambda bot as a dice bot?
10:53:12 <monochrom> I don't know. let me think it through
10:53:20 <Zemyla> dolio: No two socks are exactly alike, but there's no simple rule to choose between them.
10:53:28 <monochrom> I think yes
10:53:34 <byorgey> any two *individual* socks may be distinguishable, but it's hard to give a finite rule that can be used for picking one from each of an infinite number of pairs
10:53:38 <simpson> "Oh, we got both ints: O, and successors to O."
10:54:09 * hackagebot mnist-idx 0.1.2.5 - Read and write IDX data that is used in e.g. the MNIST database.  https://hackage.haskell.org/package/mnist-idx-0.1.2.5 (muzzle)
10:54:18 <Zemyla> Precisely.
10:54:58 <c_wraith> monochrom, and as a follow up, being lifted requires being boxed? 
10:55:08 <monochrom> yes
10:56:33 <dolio> c_wraith, monochrom: The original question might be backwards. Lifted things have to be evaluated to be scrutinized (in a case?). Unlifted things don't, because they're already evaluated.
10:58:26 <dolio> byorgey: Socks are finite objects, though, so it's probably possible. :)
10:58:36 <puregreen> @dice 3d6
10:58:36 <lambdabot> puregreen: 1+1+2 => 4
10:58:41 <puregreen> nolrai: ^
10:59:25 <nolrai> Awesome. 
10:59:31 <Zemyla> dolio: I know there are people who prefer the axiom of dependency to the axiom of choice.
10:59:49 <Zemyla> *determinacy
11:00:21 <nolrai> What is the axiom of determinancy?
11:00:51 <dedgrant_> dolio: Identical socks can be distinguished by their differently-bounded relationships in spacetime. Or, I suppose less physically, by relationships to Other. hmmm...
11:01:38 <dolio> dedgrant_: That's getting further away from socks being a good analogy for sets. :)
11:01:55 <fishythefish> set elements*
11:02:18 <dolio> It's all sets if you're in ZF land.
11:02:23 <johnw> "Socks are finite objects."  Debatable.
11:02:38 <dolio> Are they more like mice?
11:02:44 <dolio> From HHGG?
11:02:44 <johnw> no matter how many right socks I have, I always have one more left sock.  Therefore, I conclude that socks are infinite.
11:03:02 <url2k18> http://espedito.homepc.it OnePostX..)
11:03:09 <geekosaur> that's not a property of socks, though, it's a property of washing machines >.>
11:03:32 <dedgrant_> johnw: Sock application is a fixed point?
11:04:04 <dolio> Zemyla: I remember reading about this, and not liking it much, either.
11:04:39 <dolio> Although choice isn't always bad. It's okay when it's the sort of choice that's a theorem of Martin-loef type theory.
11:06:59 <nitrix> monochrom: That's very informative.
11:07:15 <nitrix> monochrom: It was my understanding that all types in Haskell had a bottom.
11:07:21 <nitrix> monochrom: So how is "no bottom" possible?
11:07:34 <dolio> In Haskell they all do. In GHC they don't.
11:07:45 <nitrix> monochrom: (Unlifted)
11:07:48 <nitrix> dolio: Oh, gotcha.
11:07:54 <geekosaur> nitrix, in standard Haskell all types are lifted
11:08:13 <dolio> Int# is raw machine integers, for instance. There's no bottom element.
11:08:14 <Zemyla> dolio: I prefer choice because the alternative is to say that the ordering of set cardinalities is only a partial order, and there are cardinals incomparable to ℵ₀, and that's not acceptable.
11:08:22 <nitrix> So, only the types ending with # (by convention) could have no bottoms?
11:08:45 <nolrai> Zemyla: why? 
11:08:52 <dolio> Cardinality is a nonsense idea anyway. :)
11:08:58 <Cale> Zemyla: Yeah, certainly for set theory, the negation of choice is weirder than choice.
11:09:05 <nitrix> dolio: Do you have an example of a # type with a bottom?
11:09:22 <dolio> With a bottom? I'm not sure there are any.
11:09:36 <Zemyla> nolrai: Why are there incomparable sets, or why do I feel they're unacceptable?
11:09:37 <dolio> I mean, you can use # in names of your own types with MagicHash on.
11:09:50 <nolrai> The second. 
11:09:52 <geekosaur> by some handwavey arguments you could claim NaN is a bottom
11:10:13 <nolrai> It is bottom like. 
11:10:18 <nitrix> So, typically, no # means has a bottom, # means has no bottom, unless someone creates their own #.
11:10:21 <geekosaur> but it's kind of a special case --- and you could counter-argue that the inclusion of NaN makes it *not* bottom
11:10:24 <dolio> It's not much like bottom.
11:10:25 <nitrix> ?
11:10:32 <geekosaur> (in i333754 that is)
11:10:33 <geekosaur> er
11:10:40 <geekosaur> ieee754. i kan tipe gud)
11:11:13 <dolio> Like, I can identify NaN and do something different than every number you're trying to put 'above' it in a non-monotone way.
11:11:49 <nitrix> dolio: So, it's really rare to see # lifted types?
11:12:17 <nolrai> True, it's closer to null, then bottom. 
11:12:25 <nolrai> *than
11:12:29 <geekosaur> in any case, "bottom" is a computation that diverges. about the only true unlifted bottom is an unmapped memory address --- and that in fact is *also* lifted, just not at a level visible to your program
11:12:39 <dolio> Yes, most types with # in the name are to give more first-class access to machine details.
11:12:45 <geekosaur> (the lifting lives in the CPU's page tables)
11:13:18 <Zemyla> nolrai: This is just a feeling, but it feels like every infinite set should either be an element added to a smaller infinite set, or the infinite union of a number of smaller infinite sets.
11:13:46 <dolio> Int# allows Int (boxed, lifted) to be defined in terms of more primitive things, instead of being a black box, for instance.
11:14:17 <Cale> Zemyla: Well, every set is the infinite union of singletons of its elements regardless...
11:14:17 <nolrai> Zwmyla: doesn't that rule out a rather large number of large ordinals?
11:15:02 <Zemyla> nolrai: Actually, that's how every ordinal is made.
11:15:15 <monochrom> this is a good time to say: what have I done?!
11:15:21 <geekosaur> heh
11:15:51 <Cale> The question is more about how we'd like sets to behave, rather than what is "right".
11:16:04 <nolrai> Cale: I was assuming he meant indexed by a smaller set as well. 
11:16:34 <nolrai> Zemyla: yeah, sorry, I think your right. 
11:17:17 <nitrix> dolio: monochrom That clears up lifting a bit. And boxed is just an indirection mechanism to have the object live on the heap?
11:17:17 <Zemyla> Cale: Yeah, basically. No matter what set of axioms you have that allow infinite sets, they're always going to act in a way you don't expect.
11:17:31 <nolrai> Cale: yes. I am against "one true model"nism.
11:17:49 <monochrom> yes nitrix
11:17:55 <comerijn> nitrix: "boxed" is an indirection that ensures all objects are the same size, so we can generate generic code
11:18:15 <comerijn> nitrix: i.e. "id :: a -> a" compiles as a single function instead of a specialisation per type
11:18:25 <nitrix> dolio: monochrom e.g. Int would translate into C's int* and Int# into int? Although I suspect there's additional information around them too.
11:18:39 <nitrix> comerijn: Oh, gotcha.
11:18:48 <Zemyla> comerijn: You can create specializations over types, though, with the SPECIALIZE pragma.
11:18:52 <monochrom> GHC Int is a bit more than int*
11:18:57 <dolio> nitrix: Not exactly.
11:18:57 <geekosaur> nitrix, yes, there's also a constructor tag in ghc
11:19:02 <dolio> But it's similar, I guess.
11:19:06 <geekosaur> (but this is implementation dependent)
11:19:25 <Cale> The idea or intuition here is that sets are collections of points which have no structure otherwise. If you can have pairs of sets A, B, such that neither an injection A -> B, nor an injection B -> A exists, it sort of runs against that intuitive picture.
11:19:35 <monochrom> it's more "struct *X" where "struct X { word tag; Int# content; };"
11:19:36 <Cale> Infinite sets then have some additional hidden structure to them
11:19:41 <nitrix> monochrom: Right.
11:19:43 <comerijn> nitrix: It's more like "Int#" is like java's int, whereas Int is like Java Integer
11:19:44 <Cale> Like a "shape"
11:19:52 <Cale> Such that neither one can fit inside the other
11:20:00 <dolio> But it's also not just that, because Int can be a delayed computation.
11:20:11 <nitrix> Cale: I unfortunatly have no java background, but a C tagged struct seems clear to me.
11:20:12 <monochrom> actually the "tag" is a pointer to a piece of code, not so much a tag
11:20:15 <comerijn> nitrix: In java the primitive types (i.e., int, char, bool, etc.) are unboxed whereas classes are boxed
11:20:25 <Cale> nitrix: what?
11:20:49 <nitrix> Cale: wrong higlight
11:20:51 <Cale> ah
11:20:57 <nitrix> comerijn: I unfortunatly have no java background, but a C tagged struct seems clear to me.
11:21:24 <comerijn> nitrix: The problem is that C has no notion of boxed values :) Unless you count "void*", I guess
11:21:45 <comerijn> nitrix: C values are always unboxed, which is why you need 1 function per type to do stuff
11:21:53 <nitrix> Lastly, what about PRAGMA Unpack ?
11:21:54 <nolrai> Cale: yeah, and finite "shapes" are just cardinalities..which do fit inside 
11:21:59 <nolrai> Each other. 
11:22:04 <geekosaur> ...and why it's so prone to bad code causing segfaults...
11:22:08 <Cale> Well, yeah, for each finite cardinality, there is only one shape
11:22:28 <geekosaur> can't sanity check anything, because it's all raw memory
11:22:33 <Cale> Well, we need two words now :)
11:22:50 <nitrix> What about {-# UNPACK #-}? Instintively, this seems like it'd only work on unboxed types.
11:22:51 <Cale> For each finite cardinality-with-AC, there's only one cardinality-without-AC
11:23:04 <nitrix> What does it do?
11:23:09 <nolrai> Well that's also true in the infinite case..it's just they don't form a total order.
11:23:23 <nolrai> Ah. Yes. 
11:23:51 <monochrom> UNPACK goes for an unboxed type directly, when possible
11:24:38 <nolrai> Intuition wise I think I like Types better then sets. 
11:25:09 <Cale> I'm pretty sure there are pairs of sets whose cardinality is equal with AC, but whose cardinality is incomparable without.
11:25:18 <dolio> nitrix: Unpack says that when you have 'C0 T', where T has constructor 'T0 U V W X', you internally store that as 'C0 U V W X'.
11:25:48 <dolio> Instead of having a pointer to a T which has pointers to U V W X, you just store your own pointers.
11:25:50 <nitrix> dolio: What if V is another data structure, does it goes recursively?
11:25:51 <nolrai> Yes. I was speaking of the woAC case.
11:25:58 <dolio> No, just one level.
11:26:06 <dolio> You could unpack V in T, though.
11:26:06 <nitrix> dolio: It'd have to have UNPACK as well I suppose.
11:26:37 <nitrix> Interesting. So UNPACK eliminate indirection for fields.
11:26:57 <dolio> Yes. Which is not always good, of course.
11:27:05 <nitrix> At the cost of making the structure bigger.
11:27:20 <nitrix> And duplicating data probably.
11:27:27 <Cale> So the "shape" distinction I was trying to make is that maybe there's some other property that the sets have to "explain" the fact that there is no inclusion of one into the other either way.
11:27:47 <nitrix> dolio: Can you have a boxed type that's also UNPACK'ed ?
11:27:51 <monochrom> nitrix, dolio: you need "C0 !T", not just "C0 T".
11:27:53 <Cale> Of course, plain ZF doesn't require such a property to exist
11:28:47 <Cale> and ZF + not(AC) doesn't really appear to say anything positive about what such a property would be
11:28:59 <nolrai> Because it is compatible with AC.
11:29:00 <nitrix> This actually make me a lot more comfortable for the eventuality that I'll hit strange space leaks / performance issue with my game and know a little bit what to do.
11:29:17 <Cale> right
11:29:19 <Guest83698> hi
11:29:25 <dolio> nitrix: You can unpack any product type.
11:29:29 <Guest83698> Can someone check my documentaton 
11:29:39 <nolrai> Cale: maybe one needs a stronger counter to get something interesting. 
11:29:50 <nitrix> dolio: Unpacking sum types sounds impossible.
11:29:55 <Zemyla> So what happens if you try to unpack, say, Stream a = Stream a {-# UNPACK #-} !(Stream a)
11:29:59 <Guest83698> http://webparakeedocs.sunware.cu.cc/docs/?ckattempt=1
11:30:16 <Zemyla> nitrix: It's really not, you just store its tag, and the maximum of its sizes.
11:30:32 <Cale> But perhaps in ZF, we can formulate a concept that just happens to trivialise in the extension to ZFC.
11:30:38 <monochrom> on the bright side, if you forgot the "!", you will get a warning.
11:31:22 <dolio> nitrix: Right now it is. There's been some discussion about ideas that would allow it, but nothing's been implemented.
11:31:26 <monochrom> GHC does not do unpacking of sum types.
11:32:15 <nolrai> Would unpacking of sum types be useful? 
11:32:29 <Cale> Well, we surely can at least talk about the partition of each AC-cardinality into an injection preorder
11:33:02 <nitrix> nolrai: I doubt it; I was just really more worried about breaking things.
11:33:02 <monochrom> it may improve cache locality
11:33:03 <dolio> nitrix: You can imagine that `data T = C0 A B C | C1 D E F` could be implemented as a tag, plus enough space to store the maximum width of the constructors. And that could be unpacked.
11:33:31 <nitrix> dolio: Oh I see what you mean.
11:33:37 <nolrai> Yep. Do the "levels" have any interesting structure?
11:33:40 <nitrix> dolio: That'd become a tagged union in C.
11:33:41 <dolio> Kind of like a tag plus a C union, where the tag tells you how to interpret the union.
11:33:44 <nitrix> Inside a struct.
11:33:54 <dolio> Yes.
11:34:04 <nitrix> Gotcha.
11:34:13 <nitrix> Right now we have what? Tagged structs, right?
11:34:25 <dolio> There's no unboxed sum primitive like that, though.
11:34:36 <nitrix> Mhm.
11:34:42 <nitrix> This is all very nice though.
11:35:23 <nitrix> I'm assuming all of this is implementation-specific?
11:35:44 <monochrom> yes, so far I have GHC in mind
11:36:01 <exio4> lazy evaluation is an implementation detail too, isn't it?
11:36:17 <nitrix> So, hugs for example might not have the concept of (un)boxed/(un)lifted/(un)packed types?
11:36:23 <monochrom> yes, but so far all Haskell compilers/interpretations do lazy evaluation
11:36:36 <monochrom> I don't know the hugs story.
11:36:37 <Cale> Here's a question: If ZF |- (AC => card A = card B) and (there exists an injection A -> B), must we also have  ZF |- (there exists an injection B -> A)?
11:36:55 <nitrix> monochrom: Well, any other compilers, I just named one I knew, not very smart from me.
11:37:03 <monochrom> I used to use hugs. but by the time I looked under the hood, I already switched to ghc
11:37:28 <nitrix> monochrom: Have you contributed to GHC yet? You seem to know a few details.
11:37:33 <monochrom> no
11:38:12 <nitrix> I tried fixing an -fPIC issue of GHC 8 unable to build on Arch Linux and failed miserably :P
11:38:32 <nolrai> I was thinking about how all small enough enumerated bounded types could be optimized into a single machine int, but I am not sure that removing the inderections from things like "Either Bool  (Maybe Weekday)" would actually have much effect?  
11:38:56 <monochrom> it may improve cache locality
11:39:16 <monochrom> and this is the only possible benefit I can think of
11:39:40 <nolrai> Ah. 
11:40:11 <davidkart> I'm back yelling at the most unpractical language of all times
11:40:28 <dolio> Malbolge?
11:40:38 <geekosaur> with that attitude, you will never do anything but yell at it. you also won't learn anything
11:40:56 <davidkart> that was part humoristic
11:41:39 <Ferdirand> Malbolge is kind of cheated 
11:42:14 <monochrom> in fact, your time is a zero-sum game. if you yell at one thing, you lose also the opportunity cost of using that time for something else.
11:43:10 <davidkart> but still I have a question : to test code in haskell, should it be with the compiler or inside the interpreter ?
11:43:28 <maerwald> wat?
11:43:33 <monochrom> do both
11:43:38 <Cale> davidkart: Depends on what you're testing.
11:43:48 <Cale> If you're testing performance, you probably want to compile things.
11:44:06 <hjljo> use QuickCheck :3
11:44:10 <dolio> Oh, that reminds me.
11:44:15 * monochrom 's lattice of boolean choice: do both < { do left, do right } < toss a coin
11:44:28 <dolio> Cale: Did you know that someone seemed to be working on hat as recently as last year (I think).
11:44:34 <davidkart> Basically I thought about Haskell and to learn this language
11:45:02 <davidkart> https://www.quora.com/Functional-Programming-Which-of-Haskell-and-OCaml-is-more-practical
11:45:10 <Cale> dolio: I do recall noticing that when hat came up in a discussion a while ago, now that you mention it :)
11:45:24 <M-Quora> i hate that website
11:45:31 <maerwald> davidkart: I stopped after the first sentence
11:45:32 <davidkart> understandable
11:45:34 <dolio> Their website looks pretty modern, too.
11:45:54 <davidkart> maerwald: because fp is not practical ?
11:46:07 <nitrix> davidkart: You described evaluating/executing code; not testing per se.
11:46:08 <maerwald> no, because "This is a question I'm particularly well-placed to answer because..." -- whatever ;)
11:46:21 <maerwald> if you start an argument like that, I won't listen
11:46:25 <Cale> davidkart: I work for a company which develops full-stack web applications entirely in Haskell, and at least it's very practical for us.
11:46:35 <nitrix> davidkart: There are libraries and frameworks provided by the build tools dedicated to testing.
11:47:18 <davidkart> Cale: yeah, hu, ok. Now I wanted to ask something but I was off a minute, I am not sure if you would like to answer.
11:47:30 <maerwald> davidkart: haskell in a lot of environments is terribly unpractical, because it's not as easy to find haskell devs as you find javascript devs.
11:47:30 <Cale> davidkart: In fact, it's *especially* practical on the frontend. Being able to compile Haskell to Javascript, and share all the data structures and JSON encoder/decoders and various libraries between the frontend and backend of our applications is pretty nice :)
11:47:39 <monochrom> Haskell and OCaml are equally practical. This is a question right up my alley. :)
11:47:59 <nitrix> Cale: GHCJS ?
11:48:02 <Cale> Yeah
11:48:07 <Cale> and reflex-dom
11:48:13 <nitrix> Cale: Is GHCJS a fork, an extension or a library?
11:48:26 <davidkart> Do you think 1) Haskell is harder to learn that other languages  2) Haskell has a smaller userbase that more mainstream language 3) Is there a plan to ease the pain from 1) in the future of Haskell 4) Nevermind I'll keep trying
11:48:27 <Cale> It's GHC with a Javascript backend.
11:48:33 <Cale> and a bunch of libraries
11:48:52 <nitrix> Couldn't they just extend GHC mainline and add another backend?
11:49:02 <maerwald> davidkart: 1) yes, 2) yes, 3) no
11:49:11 <Cale> davidkart: I think if you already know a bunch of imperative languages, then Haskell is surely harder to learn than yet another imperative language, because it's not merely a reskin of a language you already know.
11:49:11 * hackagebot gi-atk 2.0.2 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.2 (inaki)
11:49:13 <nitrix> Cale: Afaik, that's how LLVM does.
11:49:13 * hackagebot gi-cairo 1.0.2 - Cairo bindings  https://hackage.haskell.org/package/gi-cairo-1.0.2 (inaki)
11:49:15 * hackagebot gi-gdk 3.0.2 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-3.0.2 (inaki)
11:49:17 * hackagebot gi-gdkpixbuf 2.0.2 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-2.0.2 (inaki)
11:49:19 * hackagebot gi-gio 2.0.2 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.2 (inaki)
11:49:28 <Cale> If it's your first programming language, then Haskell is about equally hard as anything else.
11:49:35 <monochrom> Haskell is a bit harder to learn. There is no plan to change that. Because if you change that, you simply get a subset of SML. There is no plan to reinvent a subset of SML.
11:49:44 <maerwald> Cale: probably not
11:49:45 <nitrix> If it's your second programming language, it's even harder! :D
11:50:00 <maerwald> because the amount and depth of concepts is different than in other languages
11:50:19 <dolio> monochrom: That's already called F#. :)
11:50:34 <Cale> I don't know about that actually. There are lots of concepts used in other languages, they're just different ones.
11:50:43 <davidkart> ha yes
11:50:58 <monochrom> oh ha
11:50:59 <dolio> Oh geeze.
11:51:08 <nitrix> davidkart: If you have no commitment to learn, it'll be very hard. People approach languages thinking it's just new syntax to learn and concepts to transpose. With Haskell, you have to genuinely learn new methodologies and mental models.
11:51:10 <monochrom> but at least F# adds a .Net story
11:51:11 --- mode: ChanServ set +q *!*@li229-222.members.linode.com
11:51:18 --- mode: ChanServ set +o dolio
11:51:20 <davidkart> but then, wouldn't it be better for a starting guy in FP to learn first Standard_ML and go on with haskell ?
11:51:28 <maerwald> Cale: C has barely a lot of "concepts". It's just pitfalls and gotchas, but not really concepts.
11:51:35 <Cale> Who was that +q for?
11:51:40 <dolio> hackagebot
11:51:42 <Cale> ah
11:51:48 <davidkart> nitrix: actually one of my motivation to learn Haskell was to master something hard I didn't already know
11:51:55 <davidkart> Tougher than I thought 
11:51:59 <Cale> maerwald: haha, maybe so, but it's still a lot of stuff to learn!
11:52:10 <davidkart> Basically it takes time.
11:52:14 <maerwald> Cale: but the learning curve is fundamentally different
11:52:19 <davidkart> Hopefully I'll have some spare time in the next 2 months
11:52:23 <nitrix> davidkart: It's a strange statement, but I'll still make the claim: It's isn't _hard_, it's just steep. The learning curve is steep.
11:52:45 <Zemyla> Can't you just use the LLVM JS backend?
11:52:49 <davidkart> nitrix: I understand better what you mean because in the end once you digested all that it must look really dumb simple
11:53:11 <nitrix> davidkart: You'll probably be overwhelmed a few times and give up and come back, maybe a couple times until everything just clicks together.
11:53:13 <davidkart> the fact is that I have hard time learning this new things and I am really shaken into my habits.
11:53:47 <nitrix> davidkart: Yes, the simplicity is part of what's overwhelming sometimes.
11:53:59 <Cale> maerwald: I guess you have the thing that in C, you get to run your progrSegmentation fault
11:54:05 <shapr> davidkart: ooh, me too! it's hard to change, but it gets easier!
11:54:26 <shapr> davidkart: you can do it!
11:54:36 <Cale> maerwald: Whereas in Haskell, when your program is wrong in most of the ways that a beginner will get things wrong, the compiler is going to complain at you for it
11:54:45 <davidkart> yes genuinely
11:54:52 <maerwald> Cale: yeah, it's debug driven development and half of the memory bugs don't even make your program crash, just make it do weird things and you often get away with wrong stuff
11:55:18 <davidkart> I'd like to know though if you know anyway to copy paste a code into the interpreter without it yelling because of the lack of a 'let' statement
11:55:24 <maerwald> so it's easier for small programs in the sense "get started to write some stuff"
11:55:25 <Cale> So there's like an illusion of progress, even if you're not really any closer to a correct program than you would be with the compiler errors
11:55:45 <kadoban> maerwald: Which is … precisely the worst possible thing for learning. You really want "I did it wrong" to be immediately and obviously shown to you.
11:55:46 <maerwald> ofc the story is different when we are talking 10k+ LOC codebases, then it suddenly swaps
11:55:47 <Cale> (and you're actually usually much farther from something which works)
11:56:13 <maerwald> kadoban: that's orthogonal to the argument though and I'd even say orthogonal to learning
11:56:23 <maerwald> that's a practical concern
11:56:37 <kadoban> Probably to the argument, not to learning. … err are we not talking about practical concerns?
11:56:38 <davidkart> From the bottom of my heart honestly and all I don't find the ghc error message really easy to understand but it will get better I think.
11:56:54 <shapr> davidkart: it will!
11:56:54 <Cale> davidkart: At the very least, you have a line number!
11:56:56 <monochrom> to copy-paste a lot of code from a file to ghci: use the :load command
11:57:02 <maerwald> kadoban: I was talking about learning and that learning is easier when you don't need 5 weeks of lectures before you can understand a hello world
11:57:23 <shapr> davidkart: I find it easier to use either :r to reload a file in ghci, or I use emacs integration to reload the file so I can just edit and go. Do you have some editor integration?
11:57:28 <Cale> davidkart: If the compiler let you compile the code and just produced a broken program, then you'd have to search very hard to get the line on which things were going wrong :)
11:57:30 <kadoban> maerwald: And I would suggest that learning is better when you actually get correct feedback more quickly.
11:57:34 <nitrix> davidkart: The `let` is still mendatory for reasons a little complicated to explain to a beginner. It's a giant IO `do` block; inside of which only expressions that can be evaluated may exist.
11:57:41 <davidkart> maerwald: sounds familiar ; shapr : I was going to ask
11:57:53 <shapr> davidkart: what's your choice of editor?
11:57:53 <maerwald> kadoban: that actually depends
11:58:17 <davidkart> I'm not so much of an editor freak(no harm intended). I am using kate 
11:58:19 <maerwald> kadoban: for learning spoken languages it has turned out that getting explicitly corrected every time you say something wrong will hinder your learning process
11:58:30 <nitrix> davidkart: Try using a file and loading the file instead. It's more likely to save you tiem and frustrating anyway.
11:58:32 <maerwald> I'm not saying the same is true for programming languages
11:58:35 <davidkart> I got some trouble with repeat
11:58:36 <maerwald> but a little bit
11:58:36 <nitrix> s/frustrating/frustration/
11:58:40 <bergey> I haven't figured out how to persuade beginners to actually *read* the error messages.
11:58:46 <davidkart> I did repeat 3 and it clobbered my interpreter.
11:59:00 <dolio> bergey: If I don't read them, why should they?
11:59:14 <nitrix> davidkart: repeat produces an infinite list :)
11:59:17 <nitrix> > repeat 3
11:59:25 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
11:59:25 <monochrom> there is always ctrl-c
11:59:28 <shapr> all the threes!
11:59:32 <nolrai> You want replicate. 
11:59:48 <nolrai> I hate that to. 
11:59:50 <nitrix> > replicate 5 3
11:59:52 <davidkart> nitrix: surprisingly to you maybe I understood this part (that the interpreter is basically a big IO block). Interesting enough
11:59:52 <lambdabot>  [3,3,3,3,3]
12:00:02 <davidkart> (no surprisingly to me in fact it was)
12:00:21 <davidkart> I just had a grasp of this IO thing yesterday.
12:00:23 <nitrix> davidkart: `replicate` is more likely to be what you want given your surprise.
12:00:33 <TheMystic> davidkart: the key thing with ghci is that your code is run in a context: it's in a `do` block, and the interpreter calls `show` on whatever you type in, so it tries to fully evaluate your line of code
12:00:35 <bergey> dolio: I suppose I read the error closely if I've been staring at the line for more than a few seconds without finding a problem.  Don't you?
12:00:36 <davidkart> nitrix: that's what I was looking for indeed.
12:00:55 <shapr> :t replicate
12:00:56 <dolio> bergey: Yes, but I almost always only read the line number first.
12:00:57 <lambdabot> Int -> a -> [a]
12:01:02 <TheMystic> :t show
12:01:04 <lambdabot> Show a => a -> String
12:01:05 <shapr> @src replicate
12:01:05 <lambdabot> replicate n x = take n (repeat x)
12:01:24 <bergey> dolio: Agreed.  I have mostly gotten my students to do that. =)
12:01:40 <davidkart> but if your program is actually mathematically correct, then there is no bug in Haskell
12:01:44 <nitrix> davidkart: `replicate` taking the first `n` elements of this infinite list generated by `repeat`.
12:01:45 <davidkart> (well virtually)
12:01:52 <nitrix> davidkart: As demonstrated by the source above.
12:01:59 <puregreen> bergey: I used to be incredibly annoyed with people not reading things, before I realised that my mode of operation is similar (“poke into things” instead of “try to build a correct model by reading”), and furthermore I keep poking-instead-of-reading even after having spent an hour poking unsuccessfully, because the mental cost associated with “understand by reading” is so high
12:02:49 <maerwald> well, GHC error messages can be annoying, so it depends
12:02:51 <davidkart> puregreen: that's really interesting that you point that out.
12:03:20 <davidkart> Basically the learning process by essay and error is really a good one I suppose
12:03:21 <shapr> puregreen: it's the problem solution ordering difficulty
12:03:31 <puregreen> hm?
12:03:41 <davidkart> The fact that you need (recompense) (don't know how to say it in english) to keep progressing.
12:03:43 <bergey> Poking at the code is also a good way.  I want "read the error" to come before "ask a teacher / IRC".  Maybe my explanations are much more lucid than GHC's, even when I'm just paraphrasing, but it seems unlikely.
12:03:47 <shapr> puregreen, davidkart: http://mkremins.github.io/blog/doors-headaches-intellectual-need/
12:04:01 <shapr> amusingly, that link explicitly mentions monads
12:04:24 <maerwald> if you use lens and you messed up, the GHC error message will make you call the cops
12:04:49 <nitrix> davidkart: It's an o-kay method, as long as it's combined with actually understanding what you're doing.
12:05:16 <bergey> shapr: I like that post.  It leaves me wondering how long we let people struggle without the solution, so they appreciate it when we provide it.
12:05:19 <nitrix> Otherwise you're stuck in the eternal "poking, trial and error" mode, switching $, with <$> with <*>, until it works without understanding why.
12:05:27 <nitrix> davidkart: ^
12:05:37 <nitrix> And it gets worse.
12:05:43 <HairyDude> Is there a library that lets you parse Haskell and use the results in TH, while letting you specify some extensions?
12:06:00 <bergey> Hehe.  I would make an exception for lens.  I was thinking about programs beginners usually write.
12:06:11 <HairyDude> I'm trying to write a pattern quasiquoter that understands view patterns
12:07:12 <HairyDude> There is haskell-src-meta, but it seems to have a fixed set of extensions
12:07:54 <bergey> Yeah, I spent many hours swapping . with $ before understanding the pattern.  And much longer before I could see the pattern as just an example of order of operations / associativity.
12:08:22 <davidkart> do you know of a good haskell IDE
12:09:21 <davidkart> BTW Cale is your company using haskell because they like it or because of some general higher order  purpose ?
12:09:35 <erisco> ba dum tsh
12:09:54 <Hafydd> HairyDude: the closest to this that I've found is: https://hackage.haskell.org/package/haskell-src-exts
12:10:08 <HairyDude> Hafydd: as I mentioned, but it doesn't let you specify extensions
12:10:32 <Hafydd> HairyDude: that's not the same package, and moreover, it does: https://hackage.haskell.org/package/haskell-src-exts-1.17.1/docs/Language-Haskell-Exts.html#v:parseFileWithExts
12:10:41 <HairyDude> Hafydd: oh, wait. Yeah, haskell-src-exts has a different abstract syntax from TH
12:10:57 <Cale> davidkart: Well, we have a very modern approach to interactive user interfaces that would be far more challenging to implement in a language which was not Haskell.
12:11:27 <davidkart> ok I see
12:11:28 <maerwald> davidkart: emacs, vim
12:11:48 <davidkart> never dug too much into them. I suppose I should.
12:11:51 <maerwald> there's an "all-in-one" thing called leksah
12:12:10 <maerwald> but I don't like the integrated editor
12:13:13 <davidkart> Should I read some code from the standard library to improve my gras of Haskell ?
12:13:18 <davidkart> graspe
12:13:36 <maerwald> do a proper lecture instead with exercises
12:13:47 <HairyDude> davidkart: I've had this open in a browser tab for weeks, but never got round to trying it: https://github.com/begriffs/haskell-vim-now
12:13:51 <dmj`> davidkart: yea, being able to write Data.List, Control.Monad and most of the Prelude from memory would be a good exercise probably
12:14:08 <monochrom> bergey: I also have a theory that says "the 3rd explanation you see is the best explanation". Suppose a program has a type error. If you are the first one to point it out, IRC is the second one, and the compiler's message is the third one, then the students will feel that the compiler message is clearer than both you and IRC.
12:14:32 <maerwald> HairyDude: that's just a weird shell script basically
12:15:51 <dolio> monochrom: It's a side effect of this: https://www.youtube.com/watch?v=MFzDaBzBlL0
12:16:22 <davidkart> what's UML for Haskell ?
12:16:23 <bergey> monochrom: That's an excellent theory.
12:16:28 --- mode: ChanServ set -q *!*@li229-222.members.linode.com
12:16:34 --- mode: dolio set -o dolio
12:17:10 <nolrai> I wonder if one were to think of the "nonstandard" from nonstandard analysis as a type constructor, what properties it would have. 
12:17:17 <davidkart> ha basically I think I encountered a bug in ghci
12:18:26 <Hafydd> HairyDude: I see. Perhaps the author intends to add this functionality to haskell-src-meta, or otherwise perhaps a new package is needed.
12:18:43 <Hafydd> I would have use for it as well, myself.
12:19:12 * hackagebot telegram-api 0.4.1.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.4.1.0 (klappvisor)
12:19:17 <davidkart> thor.hs:8:8: parse error on input ‘|’  <- what's wrong ?
12:19:28 <nitrix> davidkart: Not a bug for sure :P
12:19:37 <nitrix> davidkart: Paste your code on lpaste.net
12:20:16 <nitrix> Keep in mind Haskell is whitespace sensitive.
12:20:30 <davidkart> http://lpaste.net/164055
12:20:38 <nitrix> Some of the language constructs needs to be column-aligned too.
12:20:40 <davidkart> btw
12:20:56 <davidkart> this is never mentionned in any tutorial I've been through.
12:21:05 <maerwald> davidkart: http://staff.elka.pw.edu.pl/~mszlenk/pdf/Metamodel-UML-Profile-FPL.pdf
12:21:33 <nitrix> davidkart: vDir (h|t)
12:21:51 <nitrix> davidkart: What's the goal there? Is it supposed to be functional dependencies?
12:22:07 <iphy> how would I implement something typed Traversable t => [t (Maybe (Either a b))] -> [t (Maybe b)]?
12:22:08 <nitrix> Or, logical OR ?
12:22:33 <hackrilege> i have my bug from yesterday fixed, if anyone wants to see what i was up to... http://lpaste.net/164054
12:22:45 <davidkart> vDir (h:t) is more correct
12:22:56 <nitrix> davidkart: yep :)
12:22:58 <davidkart> It was just a list pattern-matching with the wrong char inside.
12:23:06 <nolrai>  Ah. 
12:23:14 <iphy> so, I want to filter out the Lefts and transform it to a list of Rights, but the Rights are three levels deep
12:23:26 <ggVGc> what do I do when I want to do a fold which I know will produce a valid value, but I don't have start value?
12:23:39 <nitrix> davidkart: Idiomatically, people use `x` ans `xs` for those. It's completelely arbitrary though; just passing the information.
12:23:39 <ggVGc> or, well, the start value should be the first value of the collection
12:23:44 <dmj`> foldl1
12:23:45 <hackrilege> i hope its in a better state now forme to get some help on, i think the problem im hitting might be something to do with traversable, but im not too familiar with that...
12:23:52 <dmj`> @typ foldl1
12:23:53 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
12:23:58 <dmj`> > foldl1 (+1) [1..10]
12:24:00 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ a -> a
12:24:00 <lambdabot>      Expected type: a -> a -> a
12:24:01 <lambdabot>        Actual type: a -> a
12:24:05 <dmj`> > foldl1 (+) [1..10]
12:24:06 <iphy> if I can get this: Traversable t => [t (Maybe (Either a b))] -> [Either a (t (Maybe b))]
12:24:06 <lambdabot>  55
12:24:21 <dmj`> ggVGc: ^
12:24:25 <iphy> I can use Either.rights . x
12:24:26 <ggVGc> dmj`: what happens if you call foldl1 on an empty collection?
12:24:29 <dmj`> beware though, if your colleciton is empty, kaboom
12:24:33 <nitrix> ggVGc: foldX1 uses the first element as the accumulator.
12:24:34 <ggVGc> ah
12:24:36 <ggVGc> fitured
12:24:40 <ggVGc> that's a bit crap
12:24:46 <hackrilege> iphy looks like your doing something similar to me
12:25:16 <davidkart> I'm astonished because my program actually compile
12:25:20 <nitrix> ggVGc: You could implement a mayFoldX1 which returns a `Maybe a` with `Nothing` on the `[]` case.
12:26:44 <hackrilege> iphy how are you changing between Either and Maybe like that? i dont think you can pull the a out of the Maybe...
12:26:45 <hackrilege> 'a'
12:26:48 <davidkart> what would be the closest haskell program to do the pythonic : "for x in the_list: print(x)" ?
12:27:12 <shapr> davidkart: Python got list comprehensions from Haskell, so they're easier in Haskell
12:27:23 <shapr> oh, you mean a for loop?
12:27:28 <hackrilege> mapM_ (putStrLn.show)
12:27:31 <davidkart> so how would you do that ?
12:27:35 <hackrilege> :t mapM_ (putStrLn.show)
12:27:36 <lambdabot> (Show a, Foldable t) => t a -> IO ()
12:27:38 <shapr> yeah, I like what hackrilege says
12:27:47 <davidkart> ok
12:27:49 <dolio> putStrLn.show = print
12:28:08 <hackrilege> > mapM_ print ["hello","world"]
12:28:09 <lambdabot>  <IO ()>
12:28:20 <hackrilege> great stuff!
12:28:40 <dmj`> > foldl1 (+) []
12:28:41 <hackrilege> ... :(
12:28:43 <lambdabot>  *Exception: Prelude.foldl1: empty list
12:29:05 <iphy> hackrilege: fmap sequenceA gets me somewhere
12:29:09 <iphy> not to the end yet
12:29:32 <nitrix> davidkart: mapM_ print theList
12:29:35 <hackrilege> :t fmap sequenceA
12:29:36 <lambdabot> (Functor f, Applicative f1, Traversable t) => f (t (f1 a)) -> f (f1 (t a))
12:30:19 <iphy> :t sequenceA
12:30:20 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
12:30:28 <sm> closest: forM_ print the_list
12:30:28 <davidkart> otherwise is mandatory with guards ?
12:30:43 <nitrix> davidkart: The _ meaning the resulting value from the monadic action is discarded and another point is Haskell using camelCase idiomatically.
12:30:54 <sm> erm.. forM_ the_list print
12:30:54 <nitrix> davidkart: It isn't, but you'll probably get a warning if you don't.
12:31:19 <nitrix> davidkart: Without the `otherwise`, you get a partial function that doesn't cover every cases. :P
12:31:41 <davidkart> it depends
12:31:42 <nitrix> davidkart: Unless it can be proven all cases are covered.
12:31:54 <hackrilege> but i mean, if you provide something with Maybe either a or b, how do you expect it to definitely give you back a type a? oh, your saying (Either a (Maybe b)) === Maybe (Either a b), nasty!
12:32:01 <davidkart> yes : the x>0, x<0 or x==0 is always true with integers
12:32:05 <hackrilege> ok i guess
12:32:12 <nitrix> davidkart: Then you're fine.
12:32:33 <mniip> but
12:32:41 <mniip> Either a (Maybe b) ~ Maybe (Either a b)
12:32:49 <mniip> fsvo ~
12:33:20 <hackrilege> im trying to do something similar on line 76, but i cant get it right... http://lpaste.net/164054
12:33:25 <mniip> because a + (1 + b) = 1 + (a + b)
12:33:47 <ggVGc> nitrix: for this it actually never makes sense for this list to be empty, but I still don't like it
12:34:18 <davidkart> how would you zip two lists and providing a default fill value if one of them is shorter than the other ?
12:35:17 <hackrilege> pad the other list
12:35:33 <monochrom> I would write my own recursion.
12:35:42 <kadoban> davidkart: Do you know which one may be shorter in advance?
12:38:29 <lpaste_> whittle pasted “Well, why can’t it be deduced? ” at http://lpaste.net/164056
12:38:50 <hackrilege> > (\ xs ys -> let (pad,lx,ly) = (\ n zs -> take n (zs ++ (repeat 0)),length xs,length ys) in zip (pad lx xs) (pad ly ys)) [1,2] [1,2,3,4]
12:38:52 <lambdabot>  [(1,1),(2,2)]
12:39:09 <hackrilege> oops!
12:39:56 <nitrix> @let zipWithDefault d (x:xs) (y:ys) = (x,y) : zipWithDefault d xs ys; zipWithDefault d [] ys = zip (repeat d) ys; zipWithDefault d xs [] = zip xs (repeat d)
12:39:57 <lambdabot>  Defined.
12:40:09 <nitrix> zipWithDefault 0 [1..5] [1..8]
12:40:12 <dolio> whittle: a0 is ambiguous, as the error message says.
12:40:12 <hackrilege> > (\ xs ys -> let (pad,lx,ly,lz) = (\ n zs -> take n (zs ++ (repeat 0)),length xs,length ys,max lx lyin zip (pad lz xs) (pad lz ys)) [1,2] [1,2,3,4]
12:40:14 <lambdabot>  <hint>:1:13: parse error in let binding: missing required 'in'
12:40:26 <nitrix> > zipWithDefault 0 [1..5] [1..8]
12:40:28 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(0,6),(0,7),(0,8)]
12:40:29 <hackrilege> > (\ xs ys -> let (pad,lx,ly,lz) = (\ n zs -> take n (zs ++ (repeat 0)),length xs,length ys,max lx ly) in zip (pad lz xs) (pad lz ys)) [1,2] [1,2,3,4]
12:40:31 <lambdabot>  [(1,1),(2,2),(0,3),(0,4)]
12:40:56 <whittle> dolio: Is the issue that the compiler doesn’t know if it’s an instance of ToJSON, or that the compiler is trying to figure out which instance of ToJSON to use? 
12:41:13 <dolio> The latter.
12:41:45 <nitrix> > zipWithDefault 0 [1..8] [1..5]
12:41:46 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,0),(7,0),(8,0)]
12:41:50 <nitrix> Seems to work.
12:41:59 <xieyuheng> anyone knows some good readings about termination check ?
12:43:34 <shapr> xieyuheng: do you mean the halting problem?
12:44:22 <dolio> whittle: toBodyObject is specified as being able to produce every instance of ToJSON. Presumably encode also accepts every instance. So nothing is making the decision about which instance should be used.
12:44:47 <shapr> xieyuheng: are you asking about this? https://en.wikipedia.org/wiki/Halting_problem
12:46:07 <xieyuheng> shapr: yes, but not about halting problem in general.
12:46:08 <hackrilege> also check out fix
12:46:17 <xieyuheng>  only about the implementation of termination checker
12:46:48 <hackrilege> how long were you going to leave it running?
12:47:04 <whittle> dolio: Thank you. I think I get it: I’m allowed to write functions that don’t care which instance is used, but the compiler has to know *at compile time* which instance to use.
12:47:10 <chaosmasttter> :t map $ fmap $ maybe Nothing $ either (const Nothing) Just -- iphy: how about this?
12:47:11 <lambdabot> Functor f => [f (Maybe (Either b a))] -> [f (Maybe a)]
12:47:30 <dolio> whittle: Yes, it's always decided at compile time.
12:48:00 <zyla> xieyuheng: here's an interesting paper: http://www.cs.indiana.edu/~sabry/papers/reactive.ps
12:48:16 <whittle> dolio: Got it. Thank you. 
12:48:27 <hackrilege> in ps!?
12:48:32 <hackrilege> pfd ftw!
12:48:45 <shapr> hackrilege: hey, postscript is a fun language!
12:49:13 <iphy> chaosmasttter: hah
12:49:14 <iphy> yes
12:49:44 <hackrilege> but its invisible!
12:49:58 <iphy> chaosmasttter: thanks
12:50:06 <iphy> much better than my ad-hoc solution
12:50:38 --- mode: ChanServ set +o dolio
12:51:05 <xieyuheng> thank you zyla 
12:52:19 <davidkart> h
12:52:30 <slack1256> When is useful lazy writer?
12:52:35 <shapr> davidkart: you're back! we missed you!
12:53:04 <slack1256> lazy state is useful when you recurse on the state before a first complete tuple. But write?
12:53:06 <shapr> davidkart: do you have more questions?
12:55:08 <hackrilege> anyone want to talk to me about my code? http://lpaste.net/164054
12:56:19 <obadz> are there 'hash' functions that have the chaotic, roughly-uniformly distributed properties, but I don't care if they're easy to reverse/attack/etc. as long as they are cheap to compute?
12:57:22 <shapr> is there something like serverspec written in Haskell?
12:57:32 <hackrilege> there is a knuth paper using bigint like that, just mod some multiplied primes
12:57:37 <shapr> obadz: yes, murmur hash and others used for bloom filters
12:58:53 <lyxia> obadz: modular exponentiation
12:59:08 <shapr> obadz: this could be fun reading for you: http://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed/145633#145633
12:59:20 <obadz> lyxia: isn't that basically RSA encryption?
12:59:41 <simpson> shapr: Oh hi!
12:59:49 <obadz> shapr: sounds perfect indeed
12:59:52 <lyxia> obadz: yeah
13:00:05 <obadz> lyxia: against some random large number?
13:00:35 <obadz> the larger the number, the more 'chaotic' I assume?
13:01:04 <shapr> simpson: howdy!
13:01:07 <davidkart> shapr: I didn't hear the answers
13:01:16 <davidkart> my connection went down unexpectedly
13:01:40 <lyxia> obadz: it's not that chaotic since it's cyclic, but if you take a large enough base you won't see it.
13:03:40 <obadz> lyxia: wdym it's cyclic?
13:03:52 <simpson> shapr: Monte's finally gonna have a developer release! I am terrified/excited.
13:04:45 <shapr> simpson: how/where?
13:05:12 <hackrilege> > let badHash a = mod (a*13) 255 in length $ filter id $ zipWith (==) (map badHash [0..]) [0..255]
13:05:14 <lambdabot>  3
13:05:46 <simpson> shapr: We're gonna send an email to e-lang in a few days, once we put up a domain and tarballs. In the meantime, we have #monte and #erights, and a pile of docs at http://monte.readthedocs.io/en/latest/
13:06:18 <shapr> exciting!
13:07:05 <radix> simpson: grats!
13:07:22 <simpson> radix: Oh hi!
13:07:26 <lyxia> obadz: the sequence x(n) = (a^n) mod p is periodic
13:08:02 <shapr> simpson: are you formerly washort?
13:08:14 <obadz> lyxia: in something like p*n ?
13:08:43 <shapr> Jag är lite forvirrad
13:08:54 <lyxia> obadz: p-1
13:09:15 * hackagebot gi-gstaudio 1.0.2 - GStreamerAudio bindings  https://hackage.haskell.org/package/gi-gstaudio-1.0.2 (inaki)
13:09:17 * hackagebot gi-gstbase 1.0.2 - GStreamerBase bindings  https://hackage.haskell.org/package/gi-gstbase-1.0.2 (inaki)
13:09:19 * hackagebot gi-gst 1.0.2 - GStreamer bindings  https://hackage.haskell.org/package/gi-gst-1.0.2 (inaki)
13:09:21 * hackagebot gi-gstvideo 1.0.2 - GStreamerVideo bindings  https://hackage.haskell.org/package/gi-gstvideo-1.0.2 (inaki)
13:09:22 <lyxia> there may be shorter periods depending on the value a
13:09:30 <whittle> Is there a way to write a fundep for a class that takes three types and two of the types are determined by the other one? 
13:09:35 <obadz> (a+(p-1))^n mod p = a^n mod p ?
13:09:51 <simpson> shapr: No, that's dash. (He's the cool one.) I'm the dorky overweight one.
13:10:05 <shapr> ah, corbin?
13:10:12 <davidkart> Please I have a question. Does basic set theory provides a sufficient theoretical basis for functional programming with Haskell ?
13:10:16 <obadz> I think it's more like (a+p)^n mod p = a^n mod p
13:10:33 <obadz> since all the terms in the binomial expansion will be divisible by p
13:10:34 <lyxia> obadz: no, a^(n+p-1) mod p = a^n mod p
13:11:01 <simpson> Oh yeah, my nick isn't Corbin here. :c
13:11:17 <lyxia> obadz: x(n) = a^n mod p <- a and p are constants
13:11:39 <obadz> isn't a the data?
13:11:54 <obadz> oh n isthe data
13:12:46 <whittle> And when I see "There should be more documentation, but there isn't (yet). Yell if you need it.
13:12:58 <whittle> ", who should I be yelling to? 
13:13:33 <lyxia> whittle: about fundeps, yes.
13:13:38 <lyxia> a b -> c
13:14:20 <lyxia> whittle: documentation of a package?
13:14:48 <whittle> lyxia: That’s in the latest GHC docs in section 7.6.2.
13:15:57 <alemedeiros> Hi guys, I'm trying to run this little example from Scotty: https://github.com/scotty-web/scotty/blob/master/examples/globalstate.hs
13:15:58 <alemedeiros> And I'm getting this error: The first argument of ‘MonadReader’ should have kind ‘* -> *’, but ‘TVar AppState’ has kind ‘*’
13:15:58 <alemedeiros> I've tried searching the web A LOT, even looking at Scotty's code, but I can't seem to understand what is the problem. Am I missing something really obvious?
13:16:18 <lyxia> whittle: good question. maybe some folks at #ghc know.
13:16:28 <whittle> lyxia: Fair point. I’ll try there. 
13:16:44 <lyxia> whittle: the ghc-dev mailing list too
13:17:37 <whittle> lyxia: About the fundeps: so "a b -> c" doesn’t meant that a has kind * -> *? 
13:18:53 <dolio> Fundeps are just lists of variables on both sides.
13:19:03 <lyxia> whittle: it doesn't
13:19:46 --- mode: dolio set -o dolio
13:20:04 <simpson> dolio: I knew it! I always had my suspicions, but now I have proof!
13:23:37 <whittle> lyxia, dolio: Ah, I see. Thank you both. 
13:27:17 <lyxia> alemedeiros: I can compile it just fine with GHC 7.10.3
13:29:15 * hackagebot dynamic-plot 0.1.3.0 - Interactive diagram windows  https://hackage.haskell.org/package/dynamic-plot-0.1.3.0 (leftaroundabout)
13:30:09 <davidkart> how many years does it take to master a programming language such as haskell ?
13:31:09 <idev> , 1 + 2
13:31:11 <idev> > 1 + 2
13:31:13 <lambdabot>  3
13:31:27 <idev> > "snap is interesting"
13:31:28 <lambdabot>  "snap is interesting"
13:32:19 <simpson> davidkart: A couple months? Once your head gains the ability to wrap itself around higher-order logic, you'll steadily progress to having a solid command of the core language.
13:32:30 <davidkart> ok
13:32:50 <simpson> davidkart: I guess it depends on the level of mastery that you want to obtain.
13:36:05 <davidkart> http://lpaste.net/164060 <-can you see my problem here ?
13:36:21 <davidkart> simpson: I want to be able to express myself perfectly well
13:36:53 <davidkart> The idea is to have in my head meaningful and efficient mathematical representation of a problem and to be able to write them down using Haskell
13:37:03 <simpson> davidkart: Oh. Years.
13:37:35 <lyxia> what's the problem? does it not compile?
13:37:38 <davidkart> [22:35:43] <- about that, I am trying to define a generic function
13:37:55 <simpson> davidkart: Do you know about map yet?
13:37:58 <lyxia> up ++ theDir x+1
13:38:03 <lyxia> up ++ theDir (x+1)
13:38:17 <davidkart> as you can see, hDir and vDir are two really similar function and I am trying to factor this behaviour
13:38:20 <lyxia> space binds tighter than anything
13:38:56 <davidkart> I want to define a generic function theDir that does the trick and define hDir and vDir by setting up and down parameters.
13:39:16 * hackagebot zippers 0.2.1 - Traversal based zippers  https://hackage.haskell.org/package/zippers-0.2.1 (ryanglscott)
13:39:34 <grpala> davidkart: use map. Also... cons, stop appending
13:39:50 <lyxia> davidkart: how about making the pair a parameter theDir (up, down) (h : t) = ...
13:40:23 <simpson> :t map -- davidkart: Have you seen this function yet?
13:40:25 <lambdabot> (a -> b) -> [a] -> [b]
13:40:32 <davidkart> yes I know map
13:40:48 <davidkart> map doubleX [1..2] -> gives [2,4]
13:40:53 <simpson> Okay. That is the first kind of abstraction that pops out about your code.
13:40:59 <obadz> lyxia: found fermat's little theorem but not a^(n+p-1) mod p = a^n mod p. any pointers?
13:41:14 <davidkart> lyxia: yes, you could do this
13:41:22 <lpaste_> HairyDude pasted “TH not accepting underscore as variable in pattern” at http://lpaste.net/164061
13:41:32 <davidkart> lyxia: in fact you give two parameters to the function : a tuple and a list
13:41:45 <davidkart> well I can't see well
13:42:00 <davidkart> f a=g a b ? would it work ?
13:42:45 <lyxia> davidkart: write fermat's little theorem down. multiply by a^n.
13:43:19 <lyxia> davidkart: what do you mean
13:43:37 <grpala> davidkart: map (\h -> case compare h 0 of GT -> "E"; LT -> "W"; EQ -> "") [-1,0,1]
13:43:40 <davidkart> > let f a = g a b where (g a b ,b) =( a+b,2)
13:43:41 <lambdabot>  <hint>:1:24: Parse error in pattern: g
13:43:42 <lyxia> davidkart: sorry the fermat stuff was addressed to obadz 
13:43:51 <obadz> lyxia: yes sorry kind of obvious now
13:43:57 <obadz> lyxia: p must be prime though
13:44:17 <obadz> lyxia: why do I want p to be prime here?
13:44:27 <lyxia> HairyDude: what's the code like
13:44:35 <davidkart> qrpala that's not my problem exactly, my problem was more : " how to generalize this abstraction without hardcoding "E" and "W" into the function
13:44:48 <davidkart> def f a b=a+b where b=2
13:44:58 <davidkart> > let f a b = a+b where b=2
13:44:59 <lambdabot>  <no location info>: not an expression: ‘let f a b = a+b where b=2’
13:45:05 <lyxia> obadz: you can try other values but the sequence will have a much shorter period
13:45:08 <davidkart> >let f a b = a+b where b=2
13:45:14 <simpson> davidkart: Factor out map, then factor out compare. Walk before you run.
13:46:58 <grpala> by the way, is there some extension to use guards in lambdas?
13:47:14 <grpala> I know of lambdacase
13:47:18 <grpala> but I mean real guards
13:48:08 <Iceland_jack>     ghci> (\case Just x | even x -> x) (Just 10)
13:48:08 <Iceland_jack>     10
13:48:32 <Iceland_jack> or use MultiWayIf
13:49:06 <geekosaur> I think the issue is that lambdas run into syntax conflicts if you enable general patterns, and if you don't then you need to add new syntax just for guards
13:49:15 <Iceland_jack>     ghci> (\e -> if | even e -> "even" | odd e -> "odd") 10
13:49:15 <Iceland_jack>     "even"
13:49:31 <HairyDude> lyxia: repasted with the code. error is on line 6
13:49:34 <geekosaur> (and then people will ask why the other stuff doesn't work)
13:49:45 <Iceland_jack> Or regular 'case ... of', they also support guards
13:50:29 <HairyDude> lyxia: in the pdx quasiquoter, the % sigil produces a variable
13:50:37 <davidkart> simpson: I don't want to use map, I'd have a recursive construct I thingk
13:50:43 <ggVGc> does this function already exist somewhere? https://gist.github.com/b764accd71c224efa630fa411466d0d0
13:51:08 <grpala> Iceland_jack: MultiWayIf made my day, thanks
13:51:08 <Iceland_jack> ggVGc: what is (\>)?
13:51:24 <ggVGc> oh, sorry, it's just (&)
13:51:30 <ggVGc> but I like the arrow look better..
13:52:21 <geekosaur> someone's been doing too much F# :p
13:52:23 <HairyDude> lyxia: the error message shows what I would expect the pattern to be - I don't understand why it has a problem with the wildcard pattern
13:52:39 <ph88> does BNF map well to parsec/attoparsec ?
13:52:41 <ggVGc> geekosaur: that's where I first started with FP, about 6-7 years ago
13:52:45 <ggVGc> wen F# was fairly new I guess
13:53:03 <simpson> davidkart: Did you miss grpala's example? It totally works.
13:53:04 <HairyDude> ph88: you can make it look fairly like BNF using applicative style
13:53:04 <ph88> i tried making an parsec like parser and tried it on a grammar which was LL(k) for a backtracking parser and failed miserably
13:53:16 <ph88> cool
13:53:22 <whittle> Muahahahahah! It’s alive! (Well, actually, it compiles. Still, very exciting.) Thanks so much dolio and lyxia! 
13:53:46 <whittle> Also, bonus, I found a use for the Void type. 
13:54:00 <whittle> I wasn’t even sure I knew what that was for. 
13:54:07 <HairyDude> ph88: https://github.com/HairyDude/pdxparse/blob/master/src/Abstract.hs starting at line 150
13:54:33 <lyxia> HairyDude: but _ should not be a variable
13:55:35 <lyxia> HairyDude: there's a special constructor for it, WildP
13:55:45 <HairyDude> lyxia: ah... it comes from Language.Haskell.Meta.parsePat, so I guess this is a bug in haskell-source-meta?
13:56:52 <davidkart> simpson: here what I did : http://lpaste.net/164063
13:56:57 <davidkart> it doesn't compile
13:57:17 <davidkart> wow normal
13:57:43 <davidkart> nope not normal
13:57:58 <davidkart> parenthesis forgotten
13:58:03 <davidkart> god killed a kitty
13:58:21 <davidkart> much better now
13:58:46 <fresheyeball> hey
13:58:52 <davidkart> btw not clear how the precedence is working and I feel like it is probably an interesting topic.
13:59:04 <fresheyeball> anyone know what to do, when you can't get a ByteString to decode to Text?
14:00:06 <athan> fresheyeball: ayyy
14:00:13 <simpson> fresheyeball: Error. Is that gonna be common in your system? Do you want to handle the error?
14:00:33 <fresheyeball> I'm just trying to verify a JWT
14:00:38 <fresheyeball> and its taking me DAYS
14:00:58 <fresheyeball> so I have the secret as a literal ByteString via OverloadedStrings
14:01:14 <fresheyeball> and I can Base64 encode it no problem 
14:01:19 <fresheyeball> but then I can't get it out as Text
14:01:20 <HairyDude> lyxia: having said that, actually testing parsePat in ghci gives the right answer...
14:01:27 <fresheyeball> and the JWT lib only works with Text
14:01:36 <lyxia> HairyDude: hmm?
14:01:50 <fresheyeball> https://hackage.haskell.org/package/jwt
14:02:18 <fresheyeball> http://lpaste.net/164049#line49
14:02:37 <fresheyeball> urp no
14:02:40 <fresheyeball> sorry old paste
14:03:01 <HairyDude> lyxia: hah! never mind, I found the bug
14:03:05 <ph88> HairyDude, when starting to write a grammar how would i add tests too it ?
14:03:40 <HairyDude> ph88: errm... pass. testing is not exactly my strong point as a programmer
14:03:52 <fresheyeball> http://lpaste.net/164065
14:03:55 <fresheyeball> there
14:04:10 <fresheyeball> line 49, throws a ut8 error
14:04:20 <fresheyeball> and I'm just lost as to how to get by this
14:04:23 <ph88> hi fresheyeball 
14:04:32 <fresheyeball> ph88: hi!
14:04:41 <fresheyeball> athan: also hi!
14:05:39 <ph88> HairyDude, what kind of games have been made by paradox development studio ?
14:06:08 <fresheyeball> any ideas?
14:07:08 <glguy> fresheyeball: If it's not actually UTF-8 encoded text then you won't be able to UTF-8 decode it
14:07:34 <athan> fresheyeball: I think you need Base64 decode
14:07:51 <fresheyeball> no I need it base64 encoded as Text
14:08:15 <fresheyeball> but I don't see any Base64 libs that work with Text
14:08:25 <athan> there's one for bytestring I know
14:08:57 <fresheyeball> right, which is what I'm using
14:08:58 <athan> fresheyeball: https://hackage.haskell.org/package/base64-bytestring-1.0.0.1/docs/Data-ByteString-Base64.html
14:09:13 <athan> after you decode it, you should be able to parse it back to utf8 as Text
14:09:20 <athan> (maybe :x)
14:09:30 <fresheyeball> did you look at the paste?
14:09:35 <fresheyeball> I'm encoding it, not decode
14:09:44 <fresheyeball> if I just needed it as Text, I could just use the literal 
14:10:03 <glguy> fresheyeball: line 49 is decoding, not encoding
14:10:20 <fresheyeball> oh sorry
14:10:22 <fresheyeball> you are right
14:10:28 <fresheyeball> I got my head backward
14:10:32 <athan> yeah I'm cornfused
14:10:46 <athan> what you have looks right though
14:10:55 <fresheyeball> I thought it was right
14:11:00 <fresheyeball> decode to bytestring
14:11:03 <fresheyeball> then decode to text
14:11:06 <fresheyeball> but it always fails
14:11:17 <fresheyeball> the base64 part is fine
14:11:24 <fresheyeball> but it wont decode to text
14:13:20 <davidkart> >let f l1 l2 = [(a+b) |(a,b) <- zip l1 l2]
14:13:38 <davidkart> that's awesome
14:14:23 <alemedeiros> lyxia: sorry, just got a connection problem, did my last message get sent? I did got that file to run with runghc, but when trying to compile it as the main.hs in my project (using stack) I get the same error as before. could this be a problem with my cabal file?
14:15:57 <lyxia> alemedeiros: what is the whole error?
14:16:50 <davidkart> I am confused and I don't want to ask the channel for standard library question but do you have an idea of how to write (or is it already something existing) that can take two list of chars (maybe of diffferent size) and return a single list with the length being the maximum of the longest list in input and a concatenation of the two characters in the list ?
14:17:42 <alemedeiros> lyxia: http://lpaste.net/164067
14:18:06 <davidkart> this is correct I think : let f l1 l2 = [a++b | (a,b) <-zip l1 l2]
14:18:13 <athan> fresheyeball: I get a decode error from base64 :s
14:18:16 <davidkart> > f ["a","b","c"] ["c","d","e"]
14:18:18 <lambdabot>      No instance for (Show a0)
14:18:18 <lambdabot>        arising from a use of ‘show_M277717057028334572730355’
14:18:18 <lambdabot>      The type variable ‘a0’ is ambiguous
14:18:38 <davidkart> > f ["a","b","c"] ["c","d","e"]
14:18:39 <lambdabot>      No instance for (Show a0)
14:18:39 <lambdabot>        arising from a use of ‘show_M20206181013584652730365’
14:18:39 <lambdabot>      The type variable ‘a0’ is ambiguous
14:18:59 <athan> "invalid base64 encoding near offset 8"
14:19:02 <athan> fresheyeball: ^
14:19:07 <glguy> > transpose [ "abc", "example"]
14:19:09 <lambdabot>  ["ae","bx","ca","m","p","l","e"]
14:19:35 <davidkart> > f ["a","b","c"] ["d","e","f"] where f l1 l2 = [a++b | (a,b)<- zip l1 l2]
14:19:36 <lambdabot>  <hint>:1:31: parse error on input ‘where’
14:19:50 <davidkart> >f ["a","b","c"] ["d","e","f"] where f l1 l2 = [a++b | (a,b)<- zip l1 l2]
14:20:07 <davidkart> > f ["a","b","c"] ["d","e","f"] where f l1 l2 = [a++b | (a,b)<- zip l1 l2]
14:20:09 <lambdabot>  <hint>:1:31: parse error on input ‘where’
14:21:14 <lyxia> alemedeiros: I think it's a problem with your dependencies
14:21:19 <davidkart> why it doesn't work /me is crying
14:21:50 <lyxia> alemedeiros: where do you get Control.Monad.Reader from?
14:23:47 <nitrix> > zipWithDefault 0 [1..3] [1..5]
14:23:49 <lambdabot>  [(1,1),(2,2),(3,3),(0,4),(0,5)]
14:23:54 <dmj`> @package mtl
14:23:54 <lambdabot> http://hackage.haskell.org/package/mtl
14:23:57 <dmj`> lyxia: ^
14:24:01 <nitrix> davidkart: I implemented zipWithDefault while you were gone.
14:24:21 <nitrix> zipWithDefault d (x:xs) (y:ys) = (x,y) : zipWithDefault d xs ys; zipWithDefault d [] ys = zip (repeat d) ys; zipWithDefault d xs [] = zip xs (repeat d)
14:24:41 <davidkart> don't you think it should be in the standard library ?
14:24:59 <alemedeiros> lyxia: wow... that was it, I was getting from monads-tf instead of mtl (and I was actually looking at mtl's docs)... can't believe I lost a whole day on this. thanks a lot!
14:25:01 <alemedeiros> :-)
14:25:24 <nolrai> Why are the margins on math/cs papers so often rediculusly large?
14:25:31 <athan> So I'm trying to make a grammar for simple arithmetical expressions over scalars, like Add, Mult, stuff like that, and something I just discovered is how sets of expressions are actually crucial to arithmetic's function
14:25:36 <nitrix> davidkart: Haskell doesn't have a standard library.
14:25:36 <alemedeiros> I think I added the dependencies from what stack build suggested
14:25:47 <davidkart> BTW, the way I look at the Haskell community now : you are really awesome people here. I never have been so much helped in a single channel.
14:25:49 <nitrix> davidkart: It has a base, which is just enough for the compiler to compile itself.
14:26:00 <athan> for instance, multiplication is actually an `n` sized addition, exponentiation is a list of multplications, etc
14:26:09 <davidkart> I thrive to give more to the community right now
14:26:26 <alemedeiros> again, thanks a lot lyxia, I think I wouldn't have found this anytime soon by myself :/
14:26:34 <athan> it's strange to see this component not fundamental in our mainstream expression representation, like if set theory was actually just as necessary as multiplication
14:26:55 <davidkart> But I feel like for the language to get a more mature user base, you'll need to standardize somethings. Maybe it has never been planned as someone told me a while just here.
14:27:01 <athan> and that `*` is just syntactic sugar for `foldr + xs`
14:27:25 <davidkart> Anyway I enjoy this field of freedom right here and now and I saw your motto is (Not look for success)
14:27:30 <nitrix> davidkart: It's a good mix of beginners, professionals, researchers and teachers. There are many influential people as well; on almost every aspect of the language.
14:27:38 <EvanR> athan: seems inefficient
14:27:41 <davidkart> this is probably much more fine like this.
14:28:07 <lyxia> alemedeiros: yw
14:28:38 <hjljo> there is "these" on hackage for zipping up structures of different sizes
14:29:14 <nitrix> davidkart: https://hackage.haskell.org/package/these
14:29:29 <nitrix> davidkart: That package has an Align class that has a `zipping` operation with padding.
14:30:01 <nitrix> Oh sorry, it's called `align`.
14:31:16 <davidkart> haha « cmccann: unfortunately it is too perfect an abstraction to be useful. »
14:31:21 <davidkart> (sorry )
14:31:28 <davidkart> yes thank you
14:32:01 <davidkart> Why the ; ?
14:32:06 <davidkart> in your definition ?
14:33:00 <davidkart> you can do one-liner guards with ; apparently
14:33:08 <davidkart> no you can break lines with ;
14:33:19 <nitrix> davidkart: Line breaks inserts ;
14:33:19 <hjljo> yup
14:33:31 <davidkart> This is cool, I wasn't sure it was possible
14:33:37 <geekosaur> don't even need ; with guards, actually
14:33:50 <davidkart> > f l1 l2 = [a++b | (a,b)<- zip l1 l2];f ["a","b","c"] ["d","e","f"] 
14:33:51 <lambdabot>  <hint>:1:9: parse error on input ‘=’
14:34:15 <geekosaur> x | x < 5 = 1 | otherwise = 21
14:34:30 <geekosaur> and yours needs let..in; lambdabot does expressions
14:34:43 <geekosaur> unlike ghci
14:34:59 <davidkart> dirac in guard Notation : d x | x==0 = Infinity | otherwise = 0
14:35:47 <davidkart> > let f l1 l2 = [a++b | (a,b)<- zip l1 l2];f ["a","b","c"] ["d","e","f"] 
14:35:48 <lambdabot>  <hint>:1:72:
14:35:48 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:36:30 <hjljo> ; -> in
14:37:21 <hjljo> > let f l1 l2 = [a++b | (a,b)<- zip l1 l2] in f ["a","b","c"] ["d","e","f"] 
14:37:22 <lambdabot>  ["ad","be","cf"]
14:38:32 <davidkart> o:
14:38:38 <nitrix> > zipWith (:) "abc" "def"
14:38:39 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
14:38:40 <lambdabot>      Expected type: [[Char]]
14:38:40 <lambdabot>        Actual type: [Char]
14:38:55 <nitrix> > zipWith (++) ["a","b","c"] ["d","e","f"]
14:38:57 <lambdabot>  ["ad","be","cf"]
14:39:05 <fresheyeball>  uncaught exception: UnicodeException (Cannot decode byte '\xb2': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream)
14:39:09 <fresheyeball> this is driving me nuts
14:39:18 * hackagebot zippers 0.2.2 - Traversal based zippers  https://hackage.haskell.org/package/zippers-0.2.2 (ryanglscott)
14:39:41 <TheMystic> fresheyeball: ?
14:39:54 <geekosaur> fresheyeball, that sounds like you're feeding it iso8859-1 instead of utf8
14:41:40 <fresheyeball> how to fix?
14:41:47 <fresheyeball> http://lpaste.net/164065#line49
14:42:01 <fresheyeball> been beating my head against this for hours
14:43:42 <mauke> fresheyeball: my base64 says "invalid input"
14:43:50 <mauke> and gives me stuff that looks like binary garbage
14:44:17 <fresheyeball> https://hackage.haskell.org/package/base64-bytestring-1.0.0.1/docs/Data-ByteString-Base64-URL.html
14:44:17 <geekosaur> same here, in fact
14:44:22 <glguy> mauke: Are you using a URL Base64?
14:44:23 <fresheyeball> this decodes it every time for me
14:44:29 <fresheyeball> URL Base64
14:44:30 <glguy> or a normal boring base64?
14:44:44 <fresheyeball> normal old base64 fails everytime on that string
14:44:48 <fresheyeball> you need URL
14:44:52 <mauke> glguy: ah, no
14:45:42 <glguy> It doesn't appear that that is either URL/Base64 encoded UTF-8 , nor URL/Base64 enocoded latin1
14:46:01 <mauke> still binary garbage
14:46:14 <fresheyeball> its just a JWT
14:46:21 <mauke> why are you trying to decode it at all?
14:46:22 <fresheyeball> it verifies fine on Jwt.io
14:46:30 <fresheyeball> I just need to verify the JWT
14:46:37 <hjljo> you just want a bytestring, right?
14:46:38 <fresheyeball> and the secret is base64 encoded
14:46:40 <mauke> that doesn't really answer my question
14:46:41 <fresheyeball> so I need to decode it
14:46:45 <hjljo> the utf8 is a red herring
14:46:51 <fresheyeball> ok
14:46:53 <hjljo> it's not utf8
14:46:56 <fresheyeball> ok
14:46:57 <mauke> I don't mean base64 decoding, I mean the utf8 part
14:47:11 <fresheyeball> what do you recommend? 
14:47:42 * mauke reads
14:47:57 <hjljo> doesn't decode give you a bytestring?
14:48:14 <glguy> Looking at the documentation for secret it's not clear you should be decoding anything at all
14:48:14 <glguy> 7.1/docs/Web-JWT.html#v:decodeAndVerifySignature
14:48:20 <glguy> https://hackage.haskell.org/package/jwt-0.7.1/docs/Web-JWT.html#v:decodeAndVerifySignature
14:48:45 <glguy> so either turn on OverloadedStrings or use Text.pack :: String -> Text
14:48:51 <mauke> fresheyeball: "Consider using binarySecret instead if your key is not already a Data.Text."
14:49:51 <fresheyeball> ok! I will try that
14:50:04 <drostie> Hey guys, am I correct in thinking that if a Monoid obeys the associativity laws then foldr mappend mempty xs == foldl mappend mempty xs?
14:51:03 <drostie> The differences seem to be how the folds associate and where the starting element appears, but if mempty really is the identity for mappend the latter doesn't matter and if mappend really is associative then the rest should just drop out, right?
14:51:17 <fresheyeball> oh
14:51:30 <mauke> > foldr (fun "mappend") (var "mempty") [x, y, z]
14:51:32 <lambdabot>  mappend x (mappend y (mappend z mempty))
14:51:33 <fresheyeball> binarySecet is not in the version on the stack lts-5.0 release
14:51:36 <mauke> > foldl (fun "mappend") (var "mempty") [x, y, z]
14:51:37 <lambdabot>  mappend (mappend (mappend mempty x) y) z
14:51:44 <mauke> yeah
14:51:59 <quchen> drostie: No, since foldl never terminates on infinite lists, but foldr might.
14:52:25 <Cale> hmm
14:52:27 <Cale> lpadZipWith :: (Maybe a -> b -> c) -> [a] -> [b] -> [c]
14:52:34 <Cale> shouldn't this be in its own package? ;)
14:53:17 <quchen> Cale: Maybe on Hacmeage.
14:53:29 <drostie> quchen: thanks, I'll make a note of that. :D
14:53:47 <mauke> fresheyeball: the dirty workaround is decodeLatin1
14:53:56 <Cale> (It's something from the these package)
14:53:57 <fresheyeball> I tried that haha
14:53:58 <drostie> mauke: awesome, I didn't realize that lambdabot could be made to do that sort of trick.
14:54:45 <quchen> drostie: The important point is that foldl and foldr do not only differ in the way they associate the operation - they have different recursion structure, and as a result are useful for different things.
14:55:59 <fresheyeball> THAT WORKED
14:56:19 <fresheyeball> updating the jwt lib and using binary secret worked!
14:56:21 <drostie> quchen: yeah, I was just noticing that there seemed to be an equivalence between a foldr and a foldl in my application, and that's useful because it's about to be transcoded to JavaScript function*s where I'd really prefer to essentially implement foldl' , but the missing gap was whether the *only* difference was recursion structure or not.
14:56:24 <quchen> foldl-vs-foldr is Haskell's version of current-vs-voltage.
14:56:34 <elliptic00> Hi, anyone know how to use regex with multiline in Haskell?
14:56:39 <fresheyeball> mauke: I send you all the love
14:56:49 <mauke> > foldr (++) [] (map show [0 ..])
14:56:50 <lambdabot>  "012345678910111213141516171819202122232425262728293031323334353637383940414...
14:56:56 <mauke> > foldl (++) [] (map show [0 ..])
14:57:02 <lambdabot>  mueval: ExitFailure 1
14:57:32 <drostie> Yep, that's what quchen was saying.
15:03:26 <Cale> drostie: There is a difference in terms of meaning not only for infinite lists, but on finite lists the distinction goes away if the function you give it is an associative one.
15:03:35 <Cale> > foldr (-) 0 [1..10]
15:03:37 <lambdabot>  -5
15:03:40 <Cale> > foldl (-) 0 [1..10]
15:03:42 <lambdabot>  -55
15:03:45 <mauke> Cale: sure, but we were talking about monoids
15:04:00 <Cale> ah, okay
15:06:00 <drostie> Right. It's basically that I have (Monoid a, Monoid b) => Monoid (a, b) where a is the list monoid and b is the monoid of Data.Map under union.
15:07:26 <tom-cruise> What's up with UnicodeSyntax extension not recognizing the Unicode >= and other Boolean operators
15:07:28 <tom-cruise> ?
15:07:37 <tom-cruise> Is this a known issue?
15:08:25 <drostie> Except also composed with an interesting product-list Monoid a => Monoid [a] I guess, where the unit is [mempty] and the mappend a b = [mappend u v | u <- a, v <- b]
15:09:45 <Ohso_> Could someone help me with a numeric newtype?  I'm trying to make a "positive only" address class that will error if someone tries to create a negative value, but can't seem to get it to error out (negatives get translated into big positives, which is exactly what I don't want).  http://pastebin.com/M3wZ5dTF
15:09:51 <drostie> Need to double-check that the list ordering you get there is actually associative...
15:11:58 <drostie> Ohso_: the error is that you have fromInteger a = Address (fromInteger a), which punts the job of resolving negative integers to the Word32 instance underlying.
15:12:43 <drostie> Ohso_: instead you want fromInteger a | a <= 0 = error "Addresses must be positive!" | otherwise = Address (fromInteger a)
15:14:13 <drostie> Ohso_: however it is probably a premature optimization if you're doing this; someone who provides a negative integer literal and shoots themselves in the foot is probably not something you need to worry too much about.
15:14:20 * hackagebot text-show 3.2.2 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.2.2 (ryanglscott)
15:14:48 <HairyDude> ph88: mostly grand strategy
15:15:22 <ph88> strategy is nice :)
15:15:32 <ph88> HairyDude, do you know what a backslash means in grammar ?
15:15:46 <ph88> extended_identifier ::= \ graphic_character ( graphic_character )* \
15:16:30 <Ohso_> Thanks. It's not premature though. I don't want any negative addresses - ever, but this is part of a bytecode interpreter where a negative address definitely indicates a bug in the interpreter itself (vs the code running in it)
15:16:31 <davidkart> I've got a little problem
15:16:49 <HairyDude> ph88: what's the context?
15:16:55 <idev> why does == bind more tightly than $ ?
15:17:01 <idev> when is that ever useful?
15:17:05 <Ohso_> Pretty sure I tried what you suggested and it still just happily created the Address with a big positive value...will try again
15:17:25 <simpson> idev: return $ x == y
15:17:25 <ph88> HairyDude, well actually it's  extended_identifier ::= \ graphic_character { graphic_character } \    taken from the VHDL 1993 language specification
15:17:40 <HairyDude> idev: related question: why does Haskell only have 9 precedence levels? :)
15:17:45 <ph88> HairyDude, you can browse it here https://tams.informatik.uni-hamburg.de/vhdl/tools/grammar/vhdl93-bnf.html
15:17:46 <idev> simpson: okay; that makes sense
15:17:53 <idev> HairyDude: it has 99
15:17:59 <idev> HairyDude: it just turns out Prelude only uses 9 of them
15:18:12 <HairyDude> idev: really? how do you specify the other 90?
15:18:29 <simpson> idev: In general, ($) is a precedence hack to avoid parens. Some of us (me included) are weirdos that prefer lots of $ to lots of ().
15:18:46 <idev> hmm, actually there's only 10
15:18:47 <HairyDude> simpson: I am also one of those "weirdos"
15:18:52 <idev> HairyDude: https://www.haskell.org/onlinereport/decls.html I must have misread
15:18:53 <idev> sorry
15:19:03 <idev> simpson: I prefer $ to ()'s also
15:19:09 <idev> simpson: I just had this piece of code:
15:19:18 <idev> readNext dll == listReverse $ readPrev dll
15:19:25 <idev> but then it's ... damn, I need to write it as
15:19:31 <idev> readNext dll == (listReverse $ readPRev dll)
15:19:34 <idev> and that makes me sad
15:19:38 <HairyDude> ph88: I think here that's a literal backslash
15:19:53 <Ohso_> drostie It still lets a negative value get in as a big positive value.  :p
15:19:56 <idev> simpson: maybe == / $ should be same level, and bind right to left
15:19:58 <simpson> idev: It's still readable.
15:20:04 <simpson> idev: Yikes, no please.
15:20:13 <HairyDude> ph88: hmm... no, that doesn't make sense
15:20:22 <idev> simpson: you know what? haskiell precendence level should be: the one that type checks, and if more than one type chcke, follow these rules
15:20:26 <idev> (I'm kidding) :-)
15:20:27 <HairyDude> ph88: honestly, I don't know
15:21:38 <ph88> ok thanks for looking HairyDude 
15:23:10 <drostie> Ohso_: not via fromInteger it doesn't.
15:23:23 <chaosmasttter> idev: you should change it to 'readNext dll == listReverse (readPrev dll)'
15:23:32 <drostie> Ohso_: maybe via subtraction it does, until you rewrite that.
15:24:02 <Pennyw95> Hi... that might sound stupid, but given that I give a list of strings and I want to print them in the prompt via mapM_ (\s -> putStrLn s) myStrings, how can can I make a single string go to a new line? I'm asking because adding \n or \\n inside the string give errors..
15:24:17 <Ohso_> drostie: I'm doing Address -1    and end up with Address 4294967295    How would that be happening?
15:24:54 <drostie> Ohso_: because that's not a call to fromInteger (-1) :: Address but just a call to Address (fromInteger (-1)).
15:25:14 <drostie> Ohso_: if you write (-1) :: Address you'll get the exception.
15:25:18 <Pennyw95> nvm
15:25:28 <Pennyw95> it definitely was stupid
15:26:08 <drostie> Ohso_: basically if you want to do what you're doing one of the things you'll need to do is to export a smart constructor from your package, so that nobody ever can legitimately type Address (-1).
15:26:37 <Ohso_> drostie,  I see.
15:27:19 <drostie> Fortunately, your smart constructor ends up being the library function fromInteger, so you don't really need to 'export' it per se.
15:27:41 <drostie> Just expect people to write 1234 where they see an Address.
15:28:47 <idev> chaosmasttter: that is a bit nicer
15:29:20 * hackagebot stack 1.1.2 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.1.2 (borsboom)
15:30:44 <drostie> simpson: the real question is, do you write  a $ b $ c $ d $ e , or  a $ b $ c $ d e , or  a . b . c $ d e , or a . b . c . d $ e ? :D
15:30:55 <Ohso_> drostie   Hmm, I have a function that takes an address. If I feed it the literal (-1) apprently that gets converted to an Address Word32 on the spot (as a positive value). How can I prevent that?
15:32:28 <drostie> Ohso_: you are lying to me in some fashion or another because Address has kind * and "Address Word32" therefore makes no sense, unless you've strongly changed things.
15:33:05 <simpson> drostie: Personally, I write `a . b . c $ d e`, but `a . b . c` is usually a lens for me, so ($) is usually not my action.
15:33:27 <drostie> Ohso_: Is this a problem with test = -1 :: Address, or is this a problem with test = Address (-1) :: Address ?
15:33:47 <MichaelBurge> Ohso_: Be careful with writing negative literals in a Word32 context. There is a GHC bug: https://ghc.haskell.org/trac/ghc/ticket/9533
15:36:47 <drostie> Last modified 14 months ago... sounds hard to track down...
15:38:06 <MichaelBurge> drostie: I think they're not discussing that ticket in particular, but there's a patch floating around: https://phabricator.haskell.org/D810
15:38:08 <EvanR> MichaelBurge: thats horrible :(
15:40:05 <Ohso_> The code is exactly as I pasted it. I have another module that imports this one (The Address Type is exported, as well as a function which takes an address and prints out the value of the Address. From main if I call the function with a single argument of (-1), it shows a value of over 4 billion. It must be converting the -1 to a positive value somehow. 
15:41:43 <MichaelBurge> > fromInteger (-1) :: Word32
15:41:45 <lambdabot>  4294967295
15:41:54 <MichaelBurge> ^ Ohso_: Look at line 16 in your paste. That's where it occurs.
15:42:18 <MichaelBurge> -1 simply isn't a value in the range of Word32.
15:42:20 <geekosaur> it
15:43:11 <geekosaur> the Word types are pretty much just wrapped machine words. they behave exactly as machine words do: the bit value for a signed value -1 is the same as the maximum value of the word type (4294967295 for 32 bits)
15:43:14 <drostie> Ohso_: does this module still export the Address constructor? Does it still have no check on fromInteger?
15:43:56 <EvanR> geekosaur: unless there is a bug in the equality of patterns
15:43:58 <MichaelBurge> Ohso_: You should probably use Int32 or Int64 if you want to allow negative values.
15:44:47 <Ohso_> Weird, it started working suddenly. I don't export any constructor.
15:45:06 <MichaelBurge> Ohso_: Did it start working when you used GHCi, but fail when you compiled with GHC?
15:45:10 <MichaelBurge> That would be the bug that I mentioned.
15:46:04 <Ohso_> I'm using leksah and for the life of me I don't know how it actually works. 
15:46:24 <drostie> MichaelBurge: just for some context, the question was "how do I create a newtype around Word32 which systematically blocks people from trying to do things that cross the various integer boundaries and instantiate the thing with negatives and so forth?"
15:46:39 <Ohso_> Sometimes it seems to get into these weird loops where it tries to compile (or interpret) my code over and over again.
15:46:44 <drostie> MichaelBurge: Ohso_ does not want to create negative values.
15:47:04 <EvanR> smart constructors
15:47:23 <drostie> Right, and fromInteger will basically suffice as the smart constructor.
15:47:44 <EvanR> > fromIntegral -1 :: Word
15:47:46 <lambdabot>      Couldn't match expected type ‘Word’
15:47:46 <lambdabot>                  with actual type ‘Integer -> Integer’
15:47:46 <lambdabot>      Probable cause: ‘fromIntegral’ is applied to too few arguments
15:47:50 <EvanR> > fromIntegral (-1) :: Word
15:47:52 <lambdabot>  18446744073709551615
15:48:07 <EvanR> that would be very smart if it was user input
15:48:33 <EvanR> your request to transfer $18446744073709551615 is pending
15:49:11 <EvanR> validate before munging
15:50:03 <klowry> (beginner question, please say so if this sounds silly): do haskellers prefer making args explicit, or "reducing" to a partially applied fn
15:50:26 <drostie> Right, newtype Address = Address Word32; followed by instance Num Address where fromInteger n | n < 0 = error "WTF" | otherwise = Address (fromInteger n) ... would mostly work.
15:50:28 <klowry> e.g. "fn x = x + 1" vs "fn = (+1)"
15:50:32 <Ohso_> Yes, basically I need a fixed range of integers. Large positives are OK and likely due to bytecode bugs, but negative values would always be due to an interpreter bug. Therefore I wanted to make sure that any attempt to create a negative address would explode so I could locate the bugs quickly.
15:50:48 <drostie> You need to detect overflows in (+) and underflows in (-) and so forth, but basically good.
15:52:21 <EvanR> Ohso_: theres also Numeric.Natural
15:52:31 <EvanR> > (-1) :: Natural
15:52:33 <lambdabot>  *Exception: Natural: (-)
15:52:46 <EvanR> > 3 - 4 :: Natural
15:52:47 <MichaelBurge> Ohso_: It's actually supposed to warn already when you do that. But a separate bug prevents that from happening.
15:52:48 <lambdabot>  *Exception: Natural: (-)
15:52:55 <drostie> Ohso_: if you have that code on fromInteger then the next thing I'd tackle is something like Address a - Address b | b < a = Address (b - a) | otherwise = error "integer underflow"
15:52:56 <EvanR> > 4 - 3 :: Natural
15:52:57 <lambdabot>  1
15:53:23 <drostie> Or listen to EvanR, apparently Numeric has solved this already. :D
15:53:35 <puregreen> klowry: I prefer making args explicit unless it makes sense to make them implicit – i.e. if I have to explain what a function does in English, and during the explanation I don't mention the argument, then I omit the argument in the code as well. Pipelines like “f . g . x” often end up without arguments, for instance. On the other hand, I tend to avoid sections (like (+1)) and ‘flip’.
15:53:57 <MichaelBurge> > 12039486132894612398046123980461209846123094:: Int
15:53:59 <lambdabot>  -7708447030037083562
15:54:14 <MichaelBurge> I guess lambdabot doesn't show warnings. If you punched that into GHCi, you'd get one.
15:54:21 <EvanR> > 12039486132894612398046123980461209846123094 :: Natural
15:54:23 <lambdabot>  *Exception: stack overflow
15:54:25 <EvanR> o_O
15:54:31 <drostie> ahahahahahahah
15:54:39 <MichaelBurge> Yeah, I'm not going to recommend that anyone use Natural...
15:54:54 <MichaelBurge> Actually, now I'm curious what it's actually doing
15:55:15 <EvanR> its impemented with the same stuff as Integer
15:55:20 <EvanR> maybe not in lambdabot
15:55:20 <mgsloan> Yeah, that should work fine...
15:55:22 <puregreen> hm, it doesn't happen to me
15:56:22 <Ohso_> Thanks, I think I have enough to get it working now.  :)
15:58:19 <puregreen> ah, right, lambdabot's Natural is not GHC's Natural
15:58:28 <puregreen> it's Natural from http://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-Natural.html
15:58:39 <puregreen> where data Natural = Z | S Natural
15:58:51 <EvanR> @import Numeric.Natural
15:58:51 <lambdabot> Unknown command, try @list
15:59:21 <MichaelBurge> > 12345 :: Natural
15:59:24 <lambdabot>  12345
16:00:12 <mgsloan> Arrrgh lambdabotskell
16:00:21 <mgsloan> I really don't get why the bot uses such a dialect
16:02:28 <Ohso_> Argh, no it isn't working...the code I used:  fromInteger a | a <= 0 = error "Addresses must be positive!" only printed a message about negatives because I was also testing with a zero address (which is perfectly legal). If I remove the equal sign, the negative 1 sneaks into Address somehow still.
16:03:42 <MichaelBurge> > 1013706:: Natural
16:03:44 <lambdabot>  1013706
16:03:45 <puregreen> in case anyone is curious, the precise point at which it breaks is 1013707
16:03:48 <MichaelBurge> > 1013707:: Natural
16:03:50 <lambdabot>  *Exception: stack overflow
16:03:58 <puregreen> apparently I wasn't the only one who was curious
16:04:02 <MichaelBurge> hah
16:04:21 <hpc> heh
16:04:53 <EvanR> Ohso_: Numeric.Natural?
16:05:31 <MichaelBurge> I guess it's a 1 MB heap, and Numeric.Natural spends 1 byte for each constructor? Or an 8 MB heap with an 8 byte reference.
16:05:36 <EvanR> also using a parser
16:08:59 <Ohso_> Ah, If I make negate also call error it works.
16:09:19 <Ohso_> Weird
16:10:02 * EvanR writes a smart constructor to make sure Doubles are not imaginary
16:10:22 <geekosaur> makes sense, given the weird way Haskell treats negative literals
16:11:22 <Ohso_> Do you mean use Numeric.Natural in place of Word32?
16:14:19 <EvanR> i suggested it because it doesnt allow negatives
16:14:26 <EvanR> it throw an exception
16:14:26 <drostie> Ohso_: try this: http://lpaste.net/164073
16:16:09 <drostie> Ohso_: you might also want to do instance Bounded Address where minBound = Address 0; maxBound = Address 4294967295 ... for starters.
16:18:58 <Ohso_> Thanks.  Although I assumed Bounded pretty much already was that since I just derived it for Word32
16:19:17 <Ohso_> The stuff you pasted looks very promising. Thanks
16:20:01 <drostie> Ohso_: and with  liftAd f (Address x) = Address . check $ f x  in your toolkit you can also do instance Enum Address where succ = liftAd succ; pred = liftAd pred; toEnum = Address . check . toEnum; fromEnum (Address a) = fromEnum a ... I think the rest is filled in by minimal complete definition stuff, not sure.
16:20:40 <drostie> That should cover any usage of this type by your extra part and in theory you'll only lose a constant factor of speed.
16:21:31 <Ohso_> Thanks. I'll keep it in mind.
16:21:39 <drostie> Ohso_: right, but you can't derive it for Integer (I don't think), so it makes sense to give an explicit definition
16:21:45 <jasonmason> "Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH"
16:21:56 <jasonmason> why is this not covered by cabal dependencies?
16:22:51 <hamishmack> jasonmason: https://github.com/gtk2hs/gtk2hs/issues/171
16:23:18 <ph88^> hey guys, how can i add tests when i want to make a grammar in parsec/attoparsec ?
16:24:48 <jasonmason> hamishmack cool.. this bites me every couple of months, when i go grab some coffee waiting until gtk and everything else is installed, only to find out that there are still long ways to go
16:24:56 <Ohso_> You can derive Bounded if the type is an instance of Enum
16:25:54 <koz_> ph88^: QuickCheck?
16:26:44 <ph88^> hmm
16:27:18 <ph88^> also a question about parsing .. i want to be able to print again the source exactly how it was .. how can i preserve the whitespace and line endings ?
16:28:33 <mgsloan> ph88^: One approach to that is to preserve the source locations.  See for example, ghc's exact print, or the older exact print stuff for HSE
16:29:03 <mgsloan> GHC's exact print is probably a better thing to look at (even if more complicated), since it was written with automatic code refactoring in mind
16:29:09 <ph88^> ah like line number and position on line ?
16:29:34 <ph88^> eh you say i better use GHC's exact print over parsec ?
16:29:53 <mgsloan> Oh, no, unless you're parsing haskell
16:29:55 <fred-fri> floating point representations like double shouldnt be used for financial calculations. eg java has bigdecimal instead, but what should be used in haskell?
16:30:09 <koz_> fred-fri: You can scale up (i.e. do everything in cents).
16:30:13 <mgsloan> Dunno if any existing parser tools support exact print out of the box
16:30:33 <MichaelBurge> fred-fri: I store an integer number of cents.
16:31:05 <koz_> fred-fri: This is actually what C#'s Decimal type (for example) does behind-the-scenes, I think.
16:31:06 <ph88^> mgsloan, you mean look at GHC's exact print for inspiration ?
16:31:20 <fred-fri> that seems like a bit of a hack. i doubt if you wrote haskell for a bank they would tolerate that.
16:31:34 <mauke> fred-fri: http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Fixed.html maybe
16:31:41 <koz_> fred-fri: It's not a hack - lots of *very* respected programming texts basically use this kind of approach.
16:31:46 <koz_> s/use/teach
16:31:57 <mgsloan> ph88^: Yup.  If you never really want to machine edit the code, you could also take a look at haskell-src-exts exact-print
16:32:19 <ph88^> i do
16:32:27 <ph88^> i want to do a lot with the code
16:32:29 <koz_> fred-fri: Also see the point above regarding C#'s Decimal type, which is hardly a 'hack' by any standard.
16:32:33 <ph88^> but also be able to keep some original formatting
16:33:06 <mgsloan> Yeah, take a look at GHC's stuff / HaRe
16:33:10 <fred-fri> i hear what youre saying and i see why it would work but it just sounds too easy =)
16:33:11 <MichaelBurge> fred-fri: I don't consider using cents a hack. However, if you're doing fancier calculations on the amounts(like computing continuously compounded interest), you'd have to put more thought into it
16:33:23 <MichaelBurge> But I think even then you can start and end with cents.
16:33:38 <MichaelBurge> you just wouldn't use them during the calculations
16:33:41 <koz_> fred-fri: Things being overly-complex is a sign that they're *bad*, not that they're good. The fact that working in cents is simpleis a *good* thing.
16:33:43 <nshepperd_> doing things in cents or 0.01 cents is the only sensible thing to do
16:34:06 <nshepperd_> integer number of some base unit
16:34:17 <ph88^> mgsloan, but it's not haskell code that i'm parsing ..
16:34:26 <jasonmason> why not Data.Fixed instead? isn't that bigdecimal equivalent?
16:34:32 <EvanR> > 3.14 / 7 :: Centi
16:34:34 <lambdabot>  0.44
16:34:47 <hackrilege> i need help terminating a recursion, i think it reaches a fixed point, can i use fix?
16:35:01 <mgsloan> ph88^: If you want to preserve formatting, it's the same task
16:35:17 <Cale> hackrilege: You can't accomplish anything with fix that you couldn't otherwise accomplish using recursion normally.
16:35:20 <mgsloan> GHC exact print may indeed be a bit more complicated than your task, due to haskell syntax's flexibility
16:35:37 <sm> fred-fri: hledger uses Decimal, it works great
16:36:16 <hackrilege> i thought that if the recursion ceased to alter the value that fix would return
16:36:20 <koz_> :t fix
16:36:21 <lambdabot> (a -> a) -> a
16:36:26 <Cale> hackrilege: Basically if you have f x = ... f ... then you can write fix (\f x -> ... f ...) as the anonymous equivalent
16:37:26 <hpc> hackrilege: except fix also does some even more coolerer things
16:37:37 <Cale> not really
16:37:38 <koz_> hpc: 'more coolerer', huh. :P
16:37:39 <hackrilege> > fix id 0
16:37:42 <lambdabot>  mueval-core: Time limit exceeded
16:37:43 <nshepperd_> hackrilege: you want an iterative algorithm there, not fix
16:37:50 <fred-fri> sm, that looks like exactly what i want
16:38:03 <hackrilege> hmmm
16:38:05 <Cale> fix actually does *less* than let-recursion allows you to do
16:38:06 <mauke> ooh, decimal floating point
16:38:21 <hpc> heh, that's true
16:38:22 <hackrilege> > fix (:0)
16:38:24 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
16:38:24 <lambdabot>      Expected type: a -> a
16:38:24 <lambdabot>        Actual type: a -> [a]
16:38:25 <Cale> Using let allows you to be polymorphically recursive
16:38:36 <hpc> just meant more than your example has
16:38:41 <Cale> But there's nothing that you can write with fix that you couldn't write using let
16:38:49 <Cale> Well, okay
16:39:12 <Cale> More generally, if you have  let x = ... x ... in x, that can become fix (\x -> ... x ...)
16:39:31 <Cale> (So long as the type system allows it)
16:39:59 <hpc> yeah, that's more where i was going
16:40:05 <hackrilege> > fix (\rec n -> if n == 0 then 1 else n * rec (n-1)) 5
16:40:06 <lambdabot>  120
16:40:21 <koz_> hackrilege: Factorial?
16:40:30 <hackrilege> http://lpaste.net/164074
16:40:37 <Cale> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = f (x,x) (n-1) in map (f ()) [0..]
16:40:39 <lambdabot>  ["()","((),())","(((),()),((),()))","((((),()),((),())),(((),()),((),())))",...
16:40:45 <hackrilege> yes koz_
16:40:47 <hpc> and in haskell, we of course use a strange mathematical dialect of irc where we write "..." as "f"
16:40:56 <hpc> making let x = f x in x
16:40:58 <hpc> @src fix
16:40:58 <lambdabot> fix f = let x = f x in x
16:41:02 <nshepperd_> hackrilege: iterative f x = let y = f x in if x == y then x else iterative f y
16:41:04 <hpc> well well well
16:41:30 <idev> is there a haskell builtn in for :: a -> [a] -> ([a], Maybe a, [a])
16:41:37 <idev> which splits the list at (possibly) the first occurence of the member
16:41:39 <hackrilege> yeees nshepperd_ ftw, but then i need eq, and thats going to be helluv expensive
16:41:48 <nshepperd_> 'iterative' requires a function and a *starting point* and is strict, unlike fix
16:42:01 <koz_> idev: What's the result if the element's not in the list?
16:42:03 <Cale> idev: You can use break
16:42:14 <hpc> :t break
16:42:15 <Cale> > break (== 'c') "abracadabra"
16:42:16 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
16:42:17 <lambdabot>  ("abra","cadabra")
16:42:17 <hackrilege> idev, Data.List.Split has some good ones
16:42:25 <Cale> > break (== 'c') "abrabadabra"
16:42:27 <lambdabot>  ("abrabadabra","")
16:42:39 <idev> koz_: (original list, Nothing, [])
16:42:41 <Cale> and then just pattern match on the second component of the pair to check if it's empty or not
16:42:43 <hackrilege> nice
16:42:48 <hackrilege> @src break
16:42:49 <lambdabot> break p = span (not . p)
16:42:51 <koz_> idev: Yep, then you want break.
16:42:54 <nitrix> idev: I'd use splitAt or break. If the second list of empty, then you know the element wasn't found.
16:42:57 <Cale> If it's nonempty, then its first element is the one you were looking ofr
16:42:59 <Cale> for*
16:43:21 <Cale> splitAt is for splitting at a particular index
16:43:27 <nitrix> whoops
16:43:33 <hpc> and also, the result type doesn't admit some wonky return cases like ([1, 2, 3], Nothing, [4, 5, 6])
16:43:40 <idev> Cale: break it is; thanks!
16:43:46 <hpc> which i expect you would never want your function to produce
16:44:10 <hackrilege> so i thought something like that if lazy evaluation stores recent calls symbolically somehow that it would notice if it was asking for the same values over and over....
16:44:24 <nitrix> I feel like this is some kind of search operation on a zipper.
16:44:27 <hpc> hackrilege: there is something like that, though it's not symbolic
16:44:37 <nitrix> Surely someone has done this before.
16:45:01 <hpc> hackrilege: in ghc, during evaluation of a thunk it is temporarily rewritten to a black or greyhole
16:45:12 <hpc> hackrilege: depending on which RTS is being used
16:45:29 <hackrilege> sounds intense
16:45:35 <mauke> but that's just thunks, not general memoization
16:45:38 <hpc> hackrilege: the greyhole of the threaded RTS is a wait for the result to be evaluated by another thread
16:46:09 <hackrilege> ok
16:46:16 <hpc> hackrilege: the non-threaded RTS guarantees that there's only one chain of evaluation at any given time, so the blackhole is <<loop>>
16:46:21 <Cale> But this only applies to expressions bound to single variables
16:46:39 <Cale> If you start memoising all functions, then you never garbage collect anything
16:46:53 <hpc> hackrilege: if evaluating a thunk involves evaluating the same thunk, that's a class of detectable infinite loops
16:46:55 <hackrilege> hmmm
16:47:12 <hpc> which we can terminate because thanks to the miracle of purity, evaluation is not effectful
16:47:19 <hackrilege> awesome
16:47:24 <hackrilege> so thats how fix returns
16:47:25 <hpc> try that in any other language and you'll be wondering where all your print statements went or something
16:47:35 <hpc> oh no, that's not how fix returns
16:47:35 <Cale> > fix (1:)
16:47:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:47:47 <hpc> fix produces results through plain old laziness
16:47:55 <hackrilege> oh...
16:48:00 <mauke> and in this case, even without laziness
16:48:08 <hpc> when you ask for the head of (fix (1:)), it evaluates it just a smidgeon
16:48:15 <Cale> fix also works in a strict setting, but only when producing a function
16:48:19 <hpc> enough to see that the constructor of it is (:) and the head is 1
16:48:30 <hpc> then if you ask for the tail, the tail has a constructor of (:) and a head of 1
16:48:32 <hpc> etc etc
16:48:37 <mauke> 'let rec a = 1 :: a' works in ocaml
16:48:49 <hackrilege> so in my paste i have 2 functions which dont return... i was hoping i could modify them to use fix, as i think at least the latter version of duplicate should eventually stop alterinng elements
16:48:54 <hackrilege> http://lpaste.net/164074
16:49:26 <Cale> (because even strict evaluators aren't usually eager enough to skip to evaluating the body of a lambda before it has been applied)
16:50:39 <dolio> That's why their semantics is such a mess. :)
16:51:59 <hpc> you can do a tiny bit of semantic reasoning if you just accept the fact that (->) carries effects and bunch of other weird stuff
16:52:26 <hackrilege> at line 65, f is nested until eventually it will always fail and return the original element
16:52:29 <dolio> I wasn't even considering side effects.
16:52:36 <hpc> . o O ( language extension that lifts all of haskell into Kleisli IO )
16:53:13 <hackrilege> im not too sure but i think the two versions might be equivalent...
16:53:16 <hpc> dolio: fortunately in those languages, evaluation is an effect so you can encode its absence of happening in something that defines effects without performing them
16:53:34 <hpc> hooray for making a mess of two things at once
16:53:51 <hpc> it's like the monty burns of equational reasoning
16:54:08 <hpc> https://www.youtube.com/watch?v=aI0euMFAWF8
16:54:13 <Pennyw95> Hi...does GHC compile different files when on windows or Os X?
16:54:51 <mauke> Pennyw95: huh?
16:54:54 <hackrilege> no, but it should compile to different files
16:55:01 <Pennyw95> I'd think that an exe compiled on windows wouldn't work when used by a mac user
16:55:05 <emmanuel_erc> Pennyw95: Your question may be better answered on #ghc.
16:55:55 <mauke> Pennyw95: indeed, but that's a general platform issue, not ghc specific
16:56:10 <geekosaur> this is sounding rather confused to me
16:56:18 <hackrilege> Penny295, your correct, but the files which are compiled are of extensio .hs or .lhs
16:56:27 <Pennyw95> well I'm not looking for an in-depth answer, just...is there a way to make a file work on both platforms? or to make ghc compile the program for Mac even if I'm on windows?
16:56:45 <geekosaur> you cannot create a generic object file that will work anywhere, no
16:56:48 <mauke> 1. no  2. that's called cross-compilation
16:56:52 <hackrilege> use ghci
16:56:53 <geekosaur> and cross compilation is fraught at best
16:57:19 <Pennyw95> eh
16:57:43 <monochrom> at present Windows GHC does not produce Mac executable. and vice versa. (or is it s/and/nor/? nand?)
16:57:47 <geekosaur> people have tried to get cross compilation between Linux and Windows to work, and usually the best solution is to run the appropriate compiler in the appropriate OS in a virtual machine
16:57:52 <hackrilege> ghci wont produce a standalone exe, but it will work on both platforms
16:58:09 <mauke> can you legally run osx in a vm?
16:58:20 <Pennyw95> Damn...I'd hate to resort to java
16:58:20 <dolio> Probably not.
16:58:21 <hpc> ghci works by way of being ghc
16:58:22 <geekosaur> no. and you'll note I did not mention OS X
16:58:39 <Pennyw95> to end up*
16:58:54 <hackrilege> is that a threat?
16:59:03 <Pennyw95> well, at least it would work lol
16:59:07 <monochrom> why not Lua?
16:59:14 <Pennyw95> and scala isn't that bad
16:59:24 <hpc> what do you want to do?
16:59:31 <geekosaur> and Apple has locked things down such that you can't legally run it in a VM or cross compile to it
16:59:47 <hackrilege> android same
16:59:49 <hpc> do you want to use identical compiled files on two platforms, or just use the same code compiled twice?
16:59:59 <glguy> mauke: My understanding was that it was legal to run OS X in a VM as long as you were doing that on a host machine that was legally runnign OS X
17:00:10 <Pennyw95> it's a very silly thing, so it won't be a burden to rewrite it in scala...it was just a quiz I'm doing for a friend :)
17:00:26 <Pennyw95> I just hoped there was a haskell solution
17:00:35 <ElMoloko1> glguy:  I thought that as long as you legally owned OSX it was fine?
17:00:39 <geekosaur> glguy, correct
17:00:44 <hackrilege> use ghci
17:00:55 <monochrom> your friend is obliged to provide you with equipment. you will do it on a mac for real.
17:01:03 <geekosaur> ElMoloko1, not enougj to just own it, you must use OS X as the host OS
17:01:26 <geekosaur> and actually "ghci" is not quite the right alternative. "runhaskell" is
17:01:30 <ElMoloko1> geekosaur: how is that?
17:01:31 <jasonmason> is there ensureFileExists function or something? that takes a file path and creates that file and its directory tree
17:01:35 <monochrom> and yeah, legally speaking, you buy a EULA. and it says you don't "own".
17:01:48 <hackrilege> thanks geekosaur
17:02:00 <geekosaur> ElMoloko1, we're talking about legally
17:02:16 <hpc> jasonmason: probably somewhere, but i don't know of it in the "platform" libraries
17:02:17 <ElMoloko1> geekosaur: I get that, it just seems weird and dystopian :P
17:02:20 <hackrilege> jasonmason createDirectoryIfMissing
17:02:25 <Pennyw95> but the end user won't have ghci installed..welp i guess the JVM is the answer?
17:02:29 <geekosaur> ElMoloko1, welcome to Apple :(
17:02:35 <hackrilege> its in System.Directory
17:02:42 <glguy> ElMoloko1: http://images.apple.com/legal/sla/docs/OSX1011.pdf Section 2,B,iii
17:02:54 <hpc> Pennyw95: will the end user have the jvm installed? :P
17:03:03 <ElMoloko1> geekosaur: even their new campus looks like some postmodern miniluv
17:03:05 <jasonmason> hackrilege i need the same thing for a file. i could hack my own but just wondering if it already exists
17:03:13 <hackrilege> dont we have a hvm or something?
17:03:16 <Pennyw95> hpc: come on now, everybody should :P
17:03:21 <Pennyw95> at least is more likely than ghci
17:03:30 <hackrilege> how is it supposed to produce the whole file!?
17:03:36 <hpc> quite the opposite, everybody should uninstall it unless they have a specific need
17:04:05 * geekosaur would not be surprised to find there's multiple Docker images around
17:04:11 <hpc> it's got something like a 10 year streak in the top 5 most-CVE'd things
17:04:36 <emmanuel_erc> jasonmason: You should take a look at the System.Process module. It isn't exactly what you are looking, but at least you can call bash functions to perhaps do you what you want.
17:04:43 <ElMoloko1> glguy: Wow, the more you know.  It says it right there in plain English.  Just seems weird that that's legally possible.
17:04:43 <emmanuel_erc> Just my 2 cents
17:04:48 <hackrilege> no to hvm?
17:04:59 <hpc> anyway there's your answer
17:05:14 <hpc> thanks to the pixie dust magic of the default platform effect, java is "better" than haskell in that regard
17:05:27 <geekosaur> hackrilege, halvm exists but is not the same thing
17:05:37 <geekosaur> (actually I think it's bitrotted at this point)
17:05:50 <Pennyw95> hpc: I'll take it....thank you all :)
17:05:59 <hpc> but you're not really doing anything different other than typing a different tool into google for downloading
17:06:11 <hackrilege> no thats Xen
17:06:45 <glguy> geekosaur: HalVM is in active use
17:06:54 <glguy> (or however they capitalize it)
17:08:12 <hackrilege> really you would want to produce an osx installer that could use a local ghc to complie the source to the target machine
17:08:13 <hpc> glguy: it gets stylized as LaTeX
17:08:42 <glguy> OK, it's "HaLVM" :)
17:09:59 <hackrilege> oh but hey, did anyone see my paste, i cant get these recursions to terminate, i wanted to use fix, i think the second version of duplicate and possibly the first could make use of it http://lpaste.net/164074
17:13:52 <hackrilege> on lines 46 and 65
17:16:24 <ElMoloko1> Has anyone ever managed to implement a zipN without templatehaskell?
17:17:23 <dolio> Yes.
17:17:30 <mgsloan> ElMoloko1: One approach is to use applicative.  Alternatively, use typeclasses to do polyvariadic tricks http://paczesiowa.blogspot.com/2010/03/generalized-zipwithn.html
17:17:52 <mgsloan> I recommend the less fancy approach of just using ZipList
17:17:57 <ElMoloko1> i was looking for a typeclass-based approach, I know the applicative one
17:18:59 <ElMoloko1> mgsloan:  oh wow this is exactly what i'm looking for, thanks
17:19:25 <ElMoloko1> mgsloan: it's to satisfy my curiosity, not for any real use, that's why.
17:20:21 <hackrilege> http://community.haskell.org/~wren/wren-extras/src/Data/List/ZipWithN.hs
17:21:41 <hackrilege> is that template haskell?
17:21:57 <ElMoloko1> hackrilege: nice, reminds me of the Text.Printf
17:24:41 <geekosaur> hackrilege, no, that's typeclass wizardry
17:26:15 <koz_> Is there an explanation anywhere of how Text.Printf does its variadic magic?
17:26:45 <ElMoloko1> koz_: http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
17:26:59 <geekosaur> pretty sure oleg has something on it
17:27:23 <mgsloan> I have a TH hack that visually explains instance resolution that's handy for it
17:28:18 <koz_> geekosaur: oleg?
17:28:49 <geekosaur> http://okmij.org/ftp/typed-formatting/index.html#dep-type
17:28:59 <geekosaur> Oleg Kiselyov
17:29:26 <koz_> geekosaur: Ah, thanks!
17:29:42 <geekosaur> alrhough that's not the original one, I guess he redid it in terms of type families
17:30:55 <geekosaur> iirc our Text.Printf came from him originally
17:31:06 <geekosaur> although the current one is greatly expanded
17:32:13 <hackrilege> so its just a bunch of instances of a class
17:33:00 <hackrilege> not what i would call polyvariadicity, as they are not the same function..
17:34:12 <hackrilege> many functions with the same name belonging to different classes
17:34:22 <hackrilege> with different types
17:36:18 <mgsloan> ... creating the illusion of polyvariadic functions :)
17:37:16 <mgsloan> I think that's where the "poly" in polyvariadic functions comes from - variadic functions implemented via polymorphism
17:37:21 <geekosaur> haskell's type system being what it is, that's about the only way to pull it off. (note that Text.Printf is implementable in standard Haskell without ghc extensions)
17:37:45 <mgsloan> Or maybe that "poly" just comes from it being many-variadic
17:37:52 <mgsloan> But I mean variadic already kinda implies that
17:38:43 <monochrom> clearly, id is multiplediversifiedpolyvariadic, too.
17:38:50 <monochrom> @quote monochrom 17-ary
17:38:51 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
17:39:10 <jle`> wait but that's backwards from the actual lyrics
17:39:26 * hackagebot data-default-class 0.1.0 - A class for types with a default value  https://hackage.haskell.org/package/data-default-class-0.1.0 (LukasMai)
17:39:28 * hackagebot data-default 0.7.0 - A class for types with a default value  https://hackage.haskell.org/package/data-default-0.7.0 (LukasMai)
17:39:42 <monochrom> you mean the original lyrics were "I am 18, going on 17"?
17:40:01 <jle`> oh wait nvm
17:40:04 <jle`> they are correct
17:40:05 <monochrom> you know, I would love to have that happen to me. I want to grow younger, not older.
17:40:40 <jle`> wait is data-default now a package full of orphan instances now?
17:41:00 <mauke> "now"?
17:41:01 <monochrom> oh haha Benjamin Button would totally sing that. "I am 18, going on 17, you will have to take care of me"
17:41:03 <jle`> oh wait, it's always been this way?
17:41:09 <jle`> monochrom: haha
17:41:15 <mauke> not always, but it has been a while
17:41:17 <jle`> mauke: how scary
17:41:25 <jle`> it's been that way since 2013 apparently
17:41:40 <mauke> but there's a proposal to merge the class and instances-base package
17:41:42 <mgsloan> Orphans are fine if they have a canonical place ^_^
17:41:44 <jle`> oh, are you the maintainer
17:41:48 <mauke> yeah
17:42:17 <jle`> mgsloan: yeah i suppose that makes sense
17:42:53 <mgsloan> Yeah, one of these days I am going to write something that detects any intra-stackage orphan collisions
17:43:18 <mgsloan> Orphan instances are a global problem requiring a roughly global solution w.r.t. managing hackage
17:44:08 <mgsloan> It will also probably give reports about which packages have overlapping module names, because that's interesting too
17:44:30 <mgsloan> When that happens, you won't be able to have both packages and expect "runhaskell" to work
17:44:41 <mgsloan> Which causes a lot of trouble for some of the more naive tooling
17:44:55 <jle`> even with XPackageImports ?
17:45:09 <mgsloan> Right, that's the solution
17:45:23 <mgsloan> *a solution :)
17:51:31 <solidus-river> what ever hapened to this? http://www.scs.stanford.edu/11au-cs240h/projects/jones.pdf
17:51:40 <solidus-river> it looks really usefull but i can't find any mention of it
17:51:46 <solidus-river> i'm guessing they finished the library
17:52:06 <solidus-river> DynaViz using gloss under teh hood
18:02:10 <gabbiel> @src unwords
18:02:10 <lambdabot> unwords [] = ""
18:02:10 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
18:03:01 <gabbiel> > let un = concat. intersperse " "
18:03:02 <lambdabot>  <no location info>:
18:03:02 <lambdabot>      not an expression: ‘let un = concat. intersperse " "’
18:03:27 <hackrilege> @let un = concat. intersperse " "
18:03:28 <lambdabot>  Defined.
18:04:12 <gabbiel> @let l = ["something","here","whatever"]
18:04:13 <lambdabot>  Defined.
18:04:21 <gabbiel> un l == unwords l
18:04:25 <gabbiel> > un l == unwords l
18:04:26 <lambdabot>      Ambiguous occurrence ‘un’
18:04:26 <lambdabot>      It could refer to either ‘L.un’,
18:04:26 <lambdabot>                               defined at /tmp/mueval9957068871823089412.hs:155:1
18:04:45 <hackrilege> @let un2 = concat. intersperse " "
18:04:46 <lambdabot>  Defined.
18:05:23 <gabbiel> > un2 ["foo","bar"]
18:05:25 <lambdabot>  "foo bar"
18:05:36 <gabbiel> > un2 ["foo","bar"] == unwords ["foo","bar"]
18:05:38 <lambdabot>  True
18:06:54 <gabbiel> i must assume unwords's time complexity is better than concat . intersperse " "
18:07:33 <hackrilege> two folds rather than one?
18:07:59 <hackrilege> it would be nice if the compiler could sort that out
18:08:59 <gabbiel> is everything defined with folds?
18:09:19 <jle`> concat . intersperse " " should only take one traversal
18:10:05 <jle`> not everything is implemented with folds, but folds are inherently the natural way to work with lists
18:10:11 <jle`> and most list operations are some sort of fold
18:10:21 <gabbiel> folds are useful
18:10:22 <jle`> (even if you don't use the fold function directly)
18:10:35 <solidus-river> i'm so sad that dynaviz died, it was perfect
18:10:40 <jle`> most functions you write on lists end up being folds, even if you don't use the 'fold' combinator
18:10:44 <solidus-river> i'm doing a simulation and want to update a graph in real time as the simulation unfolds
18:10:52 <hackrilege> i think the question is that while an equivalent operation can be defined using one fold, since both concat and intersperse are, does this way end up working slower by forcing an unnesacary fold?
18:11:03 <solidus-river> anyone know of other libraries that will support this? Seems like people point at gnuplot but i don't see a way to provide real time updating of a graph
18:11:28 <jle`> concat and intersperse should only take one travesal
18:11:37 <hackrilege> im using TVar and opengl for that problem
18:11:46 <jle`> they're really one fold in the end
18:11:50 <hackrilege> solidus-river
18:11:55 <hackrilege> ^
18:12:17 <hackrilege> TVar takes care of the "real time" bit
18:12:53 <jasonmason> > unwords (repeat "x")
18:12:55 <lambdabot>  "x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x...
18:13:08 <jasonmason> @src unwords
18:13:08 <lambdabot> unwords [] = ""
18:13:08 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
18:13:32 <hackrilege> i guess you could substitute another graphing package that had an animation state which could get values from the TVar at set time intervals, or handel this another way...
18:13:38 <jasonmason> > un2 (repeat "x")
18:13:39 <jle`> it's kind of weird that foldr1 is used there
18:13:39 <hackrilege> you could even call gnuplot from the command line if you liked
18:13:40 <lambdabot>  "x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x...
18:13:47 <solidus-river> so you have a thread just regraphing the graph manually in a loop 
18:13:56 <hackrilege> using System.Process
18:14:10 <solidus-river> hackrilege: thanks! I was hoping for something more plug n play though, maybe its not too bad to just write your own
18:14:35 <gabbiel> official definition of unwords makes it easier to visualize
18:14:36 <hackrilege> opengl does do that quite well...
18:14:51 <tippenein> does anyone here use a haskell workflow for data analysis? Curious about the maturity. I use python for work now, but I'd possibly be more comfortable with haskell for preprocessing and such
18:16:09 <hackrilege> the good thing about gnuplot is it dumps a jpeg. if you just want to visualise it, maybe try JuicyPixels
18:19:17 <squall> it exposes Codec.Picture for all your image file format needs.
18:31:53 <jle`> do most of you here use apostrophe prefixes when you use DataKinds ?
18:32:13 <jle`> just wanted to gauge the most common style
18:32:28 <mgsloan> Yes, otherwise you get warnings
18:32:53 <jle`> is that the main reason?
18:33:05 <jle`> i guess in that sense GHC dictates the desired style, heh
18:35:12 <mgsloan> Right, not sure of the history on that, but I bet if DataKinds were done anew the apostrophe would be required
18:35:52 <mgsloan> I like it because it calls out "Hey something magic is happening here, using a value constructor as a type"
18:40:27 <dolio> You only get warnings if you turn them on.
18:40:38 <dolio> So that's not really an argument.
18:41:00 <enthropy> they are on by default
18:41:10 <dolio> That one isn't.
18:43:35 <mgsloan> Ok, but there is a reason for the warning
18:43:41 <mgsloan> So it si a quite valid argument
18:44:00 <mgsloan> I think that one is included in -Wall
18:44:07 <dolio> There are a lot of dumb warnings.
18:44:08 <mgsloan> -Wall is pretty standard haskell best practices these days
18:44:17 <mgsloan> True
18:44:24 <mgsloan> Most of them aren't though
18:44:34 <mgsloan> There are also warnings that should be in -Wall which aren't
18:44:43 <mgsloan> I am not sure how these decisions are madee
18:45:37 * geekosaur is not sure that they were decisions, as such
18:47:11 <jle`> the no-apostrophe version makes things a bit less verbose/cumbersome
18:47:20 <jle`> which might be a good thing considering how cumbersome type-level programming already *is*
18:47:45 <jle`> it could be considered an artificial attempt at making something that's already muddled even more so
18:48:12 <mgsloan> Without DataKinds we do not conflate the namespaces
18:48:15 <jle`> s/it/apostrphe style warnings
18:48:27 <mgsloan> With DataKinds, we do conflate the type and value namespaces
18:48:35 <mgsloan> The apostrophe makes it explicit
18:48:37 <mgsloan> So I like it
18:48:45 <mgsloan> But feel free to have whatever preference
18:49:01 <jle`> in that sense, it's just a namespace issue, like qualified imports
18:50:49 <jle`> i use apostrophes myself, just wondering if there was a consensus on what's idiomatic
18:50:49 <mgsloan> Yup
18:51:14 <mgsloan> It could be argued that as haskell becomes more dependently typed we should give up on keeping the namespaces apart
18:51:37 <dolio> That'd be nice, but there's a ton of code out there that puns.
18:51:58 <jle`> data Identity a = Identity a is a common idiom for some reason
18:52:02 <mgsloan> Yup, so an escape hatch like the apostrophe needs to exist
18:52:06 <jle`> data StateT s m a = StateT ...
18:52:11 <jle`> but, why
18:52:21 <dolio> Because making up names is hard.
18:52:23 <mgsloan> To confuse newcomers </s>
18:52:24 <jle`> we dug our own hole here
18:52:25 <mgsloan> :)
18:52:36 <dolio> Making up one name is easier than making up two.
18:52:55 <mgsloan> Yup, otherwise we'll just end up with messy conventionis like postfixes
18:53:01 <jle`> and less extra identifiers to remember, too >_>
18:53:03 <geekosaur> there are two hard problems in CS, naming things and ...
18:53:10 <mgsloan> data StateTTy s m a = StateTCon ...
18:53:24 <mgsloan> Caching those names in your head? ;)
18:53:45 <jle`> how do they do it in DT languages?  just a prefix/hungarian convention?
18:54:23 <jle`> data tIdentity a = cIdentity a
18:54:56 <dolio> Lots of them would have no need to define an Identity data type.
18:55:44 <dolio> So it wouldn't come up.
18:57:08 <dolio> Agda lets you use constructor names in multiple data types, but I don't think that lets you have types and constructors with the same name.
18:57:34 <dfeuer> I think Haskell makes it a lot easier to tell what name goes with what when than Agda does....
18:57:49 <dolio> Technically speaking, having dependent types doesn't mean your type and term namespace are the same.
18:57:52 <dfeuer> Haskell's capitalization rules may be annoying sometimes, but they're pretty darn useful.
18:58:29 <dolio> But a lot of languages do make them the same.
19:00:53 <dfeuer> dolio, to my mind, the variable/constructor distinction is a good one, since it lets a pattern be interpreted syntactically.
19:01:47 <dolio> I'm not sure what that has to do with the previous discussion.
19:02:22 <jle`> idris has type-directed name resolution ... does that help with things here?
19:02:51 <dolio> I think type-directed name resolution for most things is just terrible. So no. :)
19:25:56 <hardlin3r> Hello
19:26:08 <hardlin3r> Why there are not so many haskell jobs?
19:27:05 <pharaun> why there are more java jobs?
19:27:27 <pharaun> jobs are more or less popular demands by company
19:27:28 <Clint> why is there java?
19:27:33 <Tehnix`> hardlin3r: because it's a less used language than the more popular ones?
19:27:37 <pharaun> ^
19:30:31 <hardlin3r> Why haskell is less used language?
19:31:34 <Clint> because there are fewer haskell jobs
19:32:32 <dibblego> because you haven't made it that way 
19:37:35 <thimoteus> because it avoids $ success at all costs
19:39:44 <hardlin3r> What is the problem domain in which haskell is the best?
19:40:20 <mauke> haberdashery
19:40:34 <klowry> quicksort
19:40:38 <simpson> hardlin3r: Aren't you more interested in which domains it's *not* good at?
19:42:08 <hardlin3r> simpson, it's interesting for me to know both
19:43:17 <simpson> hardlin3r: Well, Haskell's billed as general-purpose, so it can generally do just about anything. What do you want to do?
19:45:24 <hardlin3r> simpson, just curious about pros and cons of haskell
19:47:58 <simpson> hardlin3r: It's nifty!
19:50:27 <thimoteus> selfhosting
19:50:52 <hardlin3r> simpson, can haskell web developer can be productive as ruby on rails developer?
19:54:02 <Clint> and niftier
20:00:34 <simpson> hardlin3r: Sure, why not. I mean, I don't know what that means, but that's okay.
20:02:15 <hardlin3r> simpson, what do you do in haskell?
20:03:06 <simpson> hardlin3r: Nothing, really. I mean, I've written a couple things, but nothing interesting.
20:06:34 <EvanR> if i want to use transformers to write a log and abort early with some value, but not have the abort clear the log, which order do i compose them in
20:07:09 <EvanR> WriterT w (ExceptT e a)
20:07:21 <EvanR> ExceptT e (WriterT w a)
20:07:54 <EvanR> fearful symmetry
20:08:42 <EvanR> well give or take whatever other monads there are
20:08:51 <simpson> EvanR: I only know the answer for EitherT: WriterT w (EitherT e m a)
20:09:16 <EvanR> hmmm. does that actually abort early
20:09:57 <EvanR> bah transformers
20:10:45 <simpson> It'll abort the computation in your inner Monad m, but the WriterT should stay intact.
20:19:45 <nolrai> ExceptT should work the same way.
20:20:15 <EvanR> then i couldnt find what module to load for Identity, so i switched to Either at the bottom
20:26:36 <dfeuer> Fish!
20:27:06 <dfeuer> Did I break it? Let's see!
20:27:16 <dfeuer> No! I did not!
20:31:12 <nolrai> Fish?
20:31:43 <EvanR> runWriterT :: WriterT w m a -> m (a, w), so if m = Either String, how do i get my w
20:31:44 <scshunt> haddock, presumably?
20:32:08 <EvanR> ill only have a Left x for some string x
20:32:11 <scshunt> EvanR: by pattern matching on the Right constructor?
20:32:21 <EvanR> i want the log up to the point of failure
20:32:22 <scshunt> EvanR: if you only have a Left, the w is gone
20:32:29 <scshunt> you have your transformer stack backwards
20:32:39 * EvanR collapses into the table
20:32:45 <scshunt> you want ExceptT (Writer w)
20:40:12 <EvanR> is there a way to make `fail' return Left here
20:40:20 <EvanR> or use throwError
20:40:34 <EvanR> i guess newtype
20:40:50 <scshunt> EvanR: why are you even using fail?
20:44:09 <EvanR> my error type is a String, and i want to call the abort action fail, so i have no choice
20:44:27 <EvanR> unless i decide to not want that
20:44:34 <dfeuer> Did I break it? Did I break it? Let's see!
20:44:34 * hackagebot monoid-subclasses 0.4.2.1 - Subclasses of Monoid  https://hackage.haskell.org/package/monoid-subclasses-0.4.2.1 (MarioBlazevic)
20:44:49 <dfeuer> Running ... running ...
20:45:01 <dfeuer> PASS!
20:45:42 <EvanR> oh ExceptT is a MonadError which is allows catching
20:46:02 <EvanR> which i dont need or watch
20:46:03 <EvanR> want
20:49:47 <dfeuer> EvanR, what are you doing?
20:49:54 <dfeuer> Also, did you have any brilliant bit queue ideas?
20:50:28 <EvanR> only the 2 phase dequeing
20:50:36 <dfeuer> Eh?
20:50:38 <dfeuer> Explain?
20:50:54 <EvanR> after its built, you have two words, each is a "64bit queue"
20:51:10 <EvanR> you dequeue one until its empty, then swap them
20:51:14 <dfeuer> Hrmmm.
20:51:31 <EvanR> during the swap you check if the other is empty, in which case its all empty
20:52:06 <EvanR> but building it might be overly complicated now
20:52:10 <dfeuer> Do you think you could try implementing that? I wore my brain out on that pull request, and have moved on to splitting optimization.
20:52:35 <EvanR> do you have a reference for fast 64 bit dequeuing?
20:53:03 <dfeuer> Yeah. One sec.
20:53:22 <EvanR> coffee shop is closing, brb
20:53:53 <dfeuer> EvanR, see http://stackoverflow.com/a/36972463/1477667 and my second comment on it.
21:12:09 <adelbertc> has anyone played with boomerang (https://hackage.haskell.org/package/invertible-syntax) and/or invertible-syntax (https://hackage.haskell.org/package/invertible-syntax)? i'm interesting in using one of these approaches to (de)serialize an EDSL
21:21:29 <dfeuer> *sigh*.
21:21:52 <EvanR> i see
21:22:49 <EvanR> i will put it on the list, though im really not sure how this fits into Map at all
21:24:20 <plug> what's the unicode name for the double colon character?
21:27:05 <plug> this character ∷
21:27:07 <dfeuer> EvanR, are you familiar with `at` from Control.Lens.At?
21:27:13 <Clint> plug: U+2237 PROPORTION
21:27:42 <scshunt> EvanR: the fact that ExceptT offers catching is irrelevant
21:27:55 <scshunt> ExceptT is the preferred error-catching monad
21:28:35 <scshunt> (catchError expr catch = case expr of { Left err -> catch err; Right val = Right val }
21:28:38 <scshunt> )
21:29:14 <EvanR> dfeuer: no not really
21:29:34 <dfeuer> EvanR, are you familiar with Van Laarhoven lenses generally?
21:30:17 <EvanR> i just investigated forall f . (a -> f b) -> (c -> f d)
21:30:25 <dfeuer> That's enough!
21:30:30 <EvanR> i dont know if thats van laarhoven
21:30:37 <dfeuer> (but with the Functor context inside that you missed)
21:30:41 <dfeuer> Yes, that's Van Laarhoven.
21:30:44 <EvanR> scshunt: whether or not its "preferred", my monad does not allow catching
21:31:03 <scshunt> EvanR: newtype your stack away, then
21:31:12 <EvanR> i just did
21:31:27 <EvanR> its like a page of code, and a lot of undefineds for stuff like local and pass
21:31:54 <dfeuer> If you have a key-value map somewhere, and a key k, then  at k   is a lens from the map to Maybe a value.
21:32:01 <EvanR> ah
21:32:20 <EvanR> so f = Maybe in that case?
21:32:26 <dfeuer> So you can inspect whether the key is in the map, get its value if so, add it if it's missing, replace its value, or delete it.
21:32:29 <dfeuer> EvanR, no, 
21:32:43 <dfeuer> b = Maybe value
21:33:03 <EvanR> ok
21:33:33 <EvanR> scshunt: at this rate its simpler to write the final monad explicitly..
21:33:38 <dfeuer> So think     forall f . Functor f => (v -> f (Maybe v)) -> Map k v -> f (Map k v)
21:33:47 <dfeuer> er... sorr.
21:33:48 <dfeuer> sorry.
21:33:50 <EvanR> at least less code
21:33:51 <dfeuer> that was wrong
21:34:06 <scshunt> EvanR: might be
21:34:13 <dfeuer> EvanR, this is what I meant: forall f . Functor f => (Maybe v -> f (Maybe v)) -> Map k v -> f (Map k v)
21:34:26 <dfeuer> Sooooo...
21:35:19 <EvanR> yep
21:35:50 <dfeuer> The usual Van Laarhoven lens notion is that instead of first digging down to find the part, then digging back down to change it,
21:36:01 <dfeuer> you find it and sort of "save your place".
21:36:16 <dfeuer> If you have a simple structure like a record, this is pretty easy.
21:36:53 <EvanR> :t at
21:36:54 <lambdabot> (Functor f, At m) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
21:36:56 <dfeuer> If you have a "deeper" structure, then you *can* just write the thing in a "natural" way, kind of like implementing traverse.
21:37:03 * EvanR ignores that
21:37:22 <dfeuer> But you end up with one fmap per "level" in the structure.
21:37:57 <dfeuer> That's just fine for functors like Const and Identity, but if someone wants to use, say, [], then you're in performance trouble.
21:38:01 <EvanR> in a deeper structure, does that thing just compose 
21:38:05 <EvanR> doesnt it
21:38:15 <dfeuer> Yeah, you totally *can* do that. It'll be correct.
21:38:23 <dfeuer> It just can be slow for non-trivial functors.
21:39:07 <dfeuer> So the lens trick (implemented in the `fusing` combinator, wherever that is) is to use Yoneda to ensure that there's only one fmap total.
21:39:29 <dfeuer> Yoneda's a bit confusing, and it's almost the same as Coyoneda, so I suggest you look at Coyoneda instead.
21:39:48 <dfeuer> (basically, Yoneda is a CPS-ish version of Coyoneda)
21:40:00 <plug> why would i get a "Parse error in pattern" error when running stack build, but not run into errors within stack ghci?
21:40:25 <dfeuer> Anyway, I tried that, and performance sucked for lightweight functors and cheap-to-compare keys.
21:40:57 <jle`> plug: do you have a pragma that's needed in .ghci ?
21:41:08 <dfeuer> The problem is that it builds up a whole big continuation that, in the Const case, it immediately throws away. And in any case, it's a bunch of clasures.
21:41:26 <EvanR> let me get this straight, composing lenses performance "sucks" if between the top and the target thing, you are doing fmaps which update the entire structure
21:41:40 <plug> jle probably, i have a few i've been guessing and checking, what pragma would be likely to produce that error?
21:41:52 <EvanR> and somehow sequential fmaps can be combined?
21:41:52 <jle`> plug: what's enabled in your ~/.ghci ?
21:41:56 <dfeuer> Pretty much. "The" entire structure is confusing; more like "some" entire structure.
21:42:27 <EvanR> several entire structures
21:42:34 <EvanR> like list fmap
21:42:40 <plug> FlexibleContexts, NoMono..., OLStrings, OLLists, QQ, ScopedTypeVariables, TypeFamilies, UnicodeSyntax, and ViewPatterns
21:42:41 <dfeuer> EvanR,  data Coyoneda f a where Coyoneda :: (b -> a) -> f b -> Coyoneda f a
21:42:49 <dfeuer> That's the simple one.
21:43:02 <dfeuer> Coyoneda f is a functor whether or not f is a functor.
21:43:03 <plug> i've tried almost all of them..
21:43:15 <mgsloan> plug: If you are loading multiple packages / components, you will get options and extensions of all of them used together  
21:43:28 <dfeuer> If f *is* a functor, then you can fmap as many times as you want over Coyoneda f a, then convert it to f a using just one fmap.
21:44:13 <slack1256> I am confused by Traversals and Folds in lens
21:44:30 <slack1256> Traversable did a monadic action on a structure but preserved it
21:44:36 <plug> ah it was the UnicodeSyntax
21:44:50 <dfeuer> slack1256, lens is pretty confusing! I suggest expanding all the type synonyms so you can see what's going on.
21:44:51 <slack1256> Foldable summarized a structure to a value
21:44:53 <jle`> plug: yeah, i've started taking removing most of my extensions from .ghci
21:44:57 <jle`> but, nice catch
21:45:06 <EvanR> does fmap for coyoneda compose f with the (b -> a), where does the new f b come from
21:45:10 <plug> jle` why? isn't it tedious to work with ghci
21:45:17 <jle`> issues like this, heh
21:45:24 <plug> when bugs come up with monomorphism restriction?
21:45:28 <plug> and other stuff?
21:45:39 <slack1256> dfeuer: OK, I thought I could live without going in the details of implementation :-(
21:45:58 <dfeuer> slack1256, well, you can.
21:46:08 <dfeuer> EvanR, yeah, it just composes it.
21:46:18 <EvanR> but, this f b thing
21:46:40 <scshunt> EvanR: Coyoneda is essentially a free structure
21:46:42 <dfeuer> EvanR, Coyoneda f a consists of an f b, for some arbitrary, hidden type b.
21:46:43 <jle`> plug: i've had issues with things like PolyKinds and DataKinds and things like that that cause problems when the file doesn't expect it, yeah
21:46:48 <EvanR> in case f is not a functor, where does it come from
21:46:51 <dfeuer> And a function that turns the b into an a.
21:46:53 <dfeuer> Oh....
21:47:11 <scshunt> EvanR: a Coyoneda doesn't actually apply the function
21:47:14 <scshunt> it merely stores it for later
21:47:23 <dfeuer> EvanR, you can always build something like   Coyoneda id whatever.
21:47:23 <plug> jle` i don't understand PolyKinds and DataKinds enough to be comfortable putting them in my .ghci
21:47:26 <EvanR> but fmap on a coyoneda needs to produce a f b from somewhere
21:47:30 <jle`> plug: btw, NoMonomorphismRestriction is enabled by default in ghci, it's not necessary anymore
21:47:30 <dfeuer> In fact.
21:47:32 <scshunt> EvanR: no
21:47:38 <jle`> it's been the default ghci behavior since 7.8
21:47:38 <scshunt> EvanR: it needs to produce a Coyoneda f b
21:47:47 <plug> although i don't understand FlexibleContexts, ScopedTypeVariables, TypeFamilies either and they're in there ...
21:47:48 <dfeuer> EvanR, no, it doesn't. It just composes the function it's given with the function inside.
21:47:54 <plug> jle` yikes that could be kind of confusing
21:48:06 <plug> (as if monomorphism restrictions weren't confusing enough)
21:48:12 <EvanR> but it has to match whatever the new type of the function is
21:48:14 <dfeuer> It doesn't know, and doesn't care, *what* the function inside is taking, because it's composing on the other side.
21:48:24 <jle`> how so?  NoMonomorphismRestriction is sort of the expected behavior for most ghci stuff I believe
21:48:24 <dfeuer> It's composing on the left.
21:48:34 <jle`> whereas MonomorphismRestriction is 90% of the time the expected behavior for normal programming
21:48:56 <jle`> and yeah, I can imagine ScopedTypeVariables causing problems potentially if a file doesn't expect it to be on
21:49:08 <gabbiel> does -O2 almost always make the program faster? what about binary size
21:49:09 <dfeuer> I don't expect the monomorphism restriction. I pretty much always use type signatures on top-level things.
21:49:11 <EvanR> (a -> b) . (huh -> a) = (huh -> a), and you need a f huh
21:49:22 <dfeuer> I *always* expect ScopedTypeVariables and get confused when it's not on.
21:49:29 <plug> jle` to have just one extension that's implicit. when i was even more beginner i had a hard time figuring out i was looking at a monomorphism restricttion bug
21:49:33 <EvanR> er
21:49:38 <EvanR> huh -> b
21:49:43 <EvanR> and f huh
21:49:44 <dfeuer> Yup.
21:49:56 <EvanR> but... it just uses undefined for f huh?
21:50:02 <dfeuer> ? No.
21:50:17 <jle`> dfeuer: it's not uncommon to write values that happen to be polymorphic over all Num a or something
21:50:17 <plug> unicode makes my code look pretty, i can't decide whether to stick with it or not
21:50:22 <gabbiel> @src words
21:50:22 <lambdabot> words s = case dropWhile isSpace s of
21:50:22 <lambdabot>     "" -> []
21:50:22 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
21:50:28 <scshunt> EvanR: no
21:50:28 <dfeuer> huh is existentially quantified, so you can put something of whatever type you want in there.
21:50:35 <jle`> dfeuer: it's surprising when they're not "memoized"/shared
21:50:44 <EvanR> what does fmap put there?
21:50:49 <dfeuer> Once you've put it in, you can't really do anything useful with it unless f *is* a functor.
21:50:58 <scshunt> EvanR: look at the construct: Coyoneda :: (a -> b) -> f b -> Coyoneda f a
21:50:59 <dfeuer> EvanR, whatever was there before! It doesn't touch it!
21:51:01 <jle`> non-top-level things especially
21:51:08 <scshunt> oh wait
21:51:12 <EvanR> oh the type doesnt change 
21:51:13 <jle`> let x = blah in ..., you sort of expect x to only be calculated once, for the most part
21:51:14 <dfeuer> scshunt, you backwardsed it.
21:51:18 <scshunt> I am looking at the contravariant one
21:51:20 <scshunt> dfeuer: yes
21:51:23 <EvanR> the b doesnt change
21:51:33 <plug> the aesthetics are nice, but it makes evil navigation a slightly awkward, it requires its own package import, and can lead to odd bugs once in a while like this language pragma thing.
21:51:41 <scshunt> EvanR: right
21:52:04 <scshunt> EvanR: basically Coyoneda lets you defer implementing fmap until later
21:52:15 <EvanR> so coyoneda turns repeated fmapping into composition under one fmap
21:52:19 <dfeuer> EvanR, yeah, fmaps just totally leaves that blob alone, building a bigger and bigger function composition in the other field.
21:52:19 <scshunt> yes
21:52:21 <dfeuer> Yes.
21:52:34 <dfeuer> Yoneda does the same thing, but in a different way.
21:52:56 <dfeuer> Yoneda is sort of CPS-ish, and uses a rank 2 type instead of an existential one.
21:53:12 <jle`> plug: well, that partially might be a fault of evil mode, not of UnicodeSyntax stuff
21:53:22 <dfeuer> newtype Yoneda f a = Yoneda (forall b . (a -> b) -> f b)
21:53:30 <EvanR> (i thought yor GADT was using rank 2 type too...)
21:53:42 <dfeuer> No, my GADT was just an existential in GADT syntax.
21:53:55 <EvanR> oh, does that need ExistentialQuantification ?
21:54:02 <EvanR> or no because it didnt have to use forall
21:54:07 <dfeuer> You could write    data Coyoneda f a = forall b . Coyoneda (b -> a) (f b)
21:54:20 <dfeuer> with ExistentialQuantification,
21:54:29 <dfeuer> or you could just enable GADTs and use the GADT syntax.
21:54:52 <EvanR> GADTs subsumes existentials ok
21:54:56 <dfeuer> Yup.
21:55:06 <scshunt> the duality is that given an f a, you need an fmap to turn it into Yoneda f a
21:55:17 <scshunt> but you can retrieve f a from a Yoneda f a without
21:55:19 <dfeuer> Yup.
21:55:32 <scshunt> conversely, you can make f a into Coyoneda f a always, but need an fmap to go back
21:55:35 <dfeuer> Getting back to Data.Map,
21:55:39 <plug> jle` not referring to an evil bug or anything, i mean navigation workflows like "jump to character" don't play well with unicode symbols.
21:55:48 <dfeuer> I found that Yoneda and Coyoneda were much too slow for lookups.
21:56:01 <dfeuer> Because they build these function composition chains or continuations and then throw them away.
21:56:10 <jle`> ah i see
21:56:13 <EvanR> are we talking about M.map now
21:56:27 <dfeuer> So I decided to try something simpler: recording the path I took down the tree. Left, left, right, left, ....
21:56:58 <dfeuer> That way I can go back to the place I found the key without having to perform any more key comparisons.
21:57:21 <dfeuer> Recording that path in a two-word bit string makes it a really cheap bookmark.
21:57:48 <EvanR> ok
21:57:49 <dfeuer> Way cheaper than a chain of closures.
21:58:05 <dfeuer> So that's where that comes in.
21:58:22 <dfeuer> It's a compromise.
21:58:51 <EvanR> which operation needs to lookup releatedly
21:59:17 <dfeuer> It gives not-quite-optimal performance for trivial functors and Int keys, but it works great when the functor and/or keys are heavier.
21:59:33 <plug> how do you guys format argument lists that span more than one line?
21:59:36 <dfeuer> EvanR, suppose you want to increment the value at a key.
21:59:37 * hackagebot uhc-util 0.1.6.6 - UHC utilities  https://hackage.haskell.org/package/uhc-util-0.1.6.6 (AtzeDijkstra)
22:00:03 <EvanR> plug: maybe use type synonyms
22:00:13 <dfeuer> Suppose, in a more crazy example, you want to modify the value at the key in a thousand different ways and make a list of a thousand maps where each represents one way of modifying that value.
22:00:22 <plug> EvanR how so?
22:00:41 <EvanR> give a name to repeated patterns in the signature
22:00:44 <dfeuer> plug, are you a Haskell beginner?
22:00:48 <EvanR> maybe itll fit on one line
22:01:11 <dfeuer> I don't recommend type synonyms for Haskell beginners, aside from the String type.
22:01:41 <dfeuer> They're confusing, and it takes quite a bit of experience to figure out when a type synonym is a good idea.
22:02:05 <plug> dfeuer been at it for about 6 months (part time). read through 80% of haskell book. that's fairly beginner by haskell standards
22:02:34 <EvanR> dfeuer: ok i get that, but which operation is manifesting this looking up a thousand times and making a list of the resulting maps
22:02:35 <plug> EvanR well the signature is more than one line but it's the argument list declaration that bothers me more aesthetically
22:02:43 <dfeuer> plug, I personally tend to split type signatures across lines if I have to. Be sure to split right before an arrow.
22:03:03 <prohobo> ughhhh
22:03:12 <prohobo> haskell > java
22:03:16 <prohobo> ughhhh
22:03:21 <prohobo> shit
22:03:23 <dfeuer> EvanR, no operation in particular. But when a library exports a function, that function should work as well as possible in the broadest context.
22:03:24 <prohobo> wrong country
22:03:32 <dfeuer> ????
22:03:33 <plug> because then the 2nd line of arguments is indented with the function body
22:03:39 <plug> and is hard to discern visually
22:03:48 <EvanR> dfeuer: just not seeing how the previous topic is relating to Maps
22:04:04 <EvanR> how is what saving this bit path and reusing it
22:04:06 <dfeuer> plug, you can bundle up related arguments in a record type.
22:04:23 <prohobo> feels like im a salmon
22:04:24 <prohobo> bahy
22:04:25 <dfeuer> EvanR, the implementation of `at`!
22:04:36 <EvanR> myFunc :: Blaw
22:04:41 <dfeuer> (which actually has its arguments flipped and is called alterF, but whatever)
22:04:42 <EvanR>       -> Blaw2
22:04:47 <EvanR>        -> Blaw2
22:04:50 <EvanR>        -> Blaw3
22:04:53 <EvanR> possible
22:04:57 <EvanR> without a long name
22:05:15 <prohobo> ur mom is a name
22:05:33 <prohobo> no
22:05:40 <EvanR> dfeuer: hmm... how does the implementation of at know that it is being used on a Map
22:06:15 <dfeuer> EvanR, `at` is a class method. 
22:06:17 <dfeuer> :t at
22:06:18 <lambdabot> (Functor f, At m) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
22:06:24 <EvanR> oh, 
22:06:24 <dfeuer> Yeah, the class is called At.
22:06:32 <EvanR> this is standard in Lens?
22:06:36 <EvanR> er lens
22:06:41 <dfeuer> Index and IxValue are type families telling you what the key type and value type are for the map in question.
22:06:46 <dfeuer> Yes, this is standard in lens.
22:06:49 <EvanR> alright
22:07:06 <dfeuer> But lens doesn't have access to the fiddly underlying implementation of the Map type.
22:07:27 <dfeuer> So it currently uses something that can be worse in the cases I described.
22:10:08 <plug> dfeuer maybe adds a couple lines of type code but maybe it's worth it
22:10:23 <plug> man haskell makes me OCD about aesthetics
22:11:01 <EvanR> for a lot of complex arguments yeah a record
22:11:10 <EvanR> which hopefully doesnt come up much
22:11:23 <EvanR> try to make functions that compose instead of huge configurable functions
22:11:24 <plug> what would you consider a lot?
22:11:26 <plug> three?
22:11:32 <EvanR> 9
22:11:37 <plug> hm
22:11:47 <EvanR> example strategy for reducing arguments
22:11:56 <EvanR> f :: Maybe Foo -> Bar -> Baz
22:12:01 <EvanR> you can change this to
22:12:08 <EvanR> f1 :: Foo -> Bar -> Baz, and
22:12:11 <EvanR> f2 :: Bar -> Baz
22:12:16 <EvanR> with different names
22:12:20 <EvanR> or
22:12:27 <prohobo> EvanR is a mom
22:12:32 <EvanR> something
22:12:32 <plug> this function has 6 parameters normally, forcing me to do an 80 char line break. 3 of them naturally group together into a "parameter" type
22:12:50 <dfeuer> prohobo, if you keep this up someone is going to kick you out of the channel.
22:12:56 <hefesto> Hi! Good night, nice people of the Haskell world. I have a dependency error with easyplot. Ive tried 'stack install easyplot' and then 'stack build', but the cabal dependencies seem to still dont want to work. Does anyone know what am i doing wrong? http://lpaste.net/164087
22:13:03 <EvanR> generally i like to use more functions than group everything into one function with a complex universe of arguments
22:13:15 <dfeuer> Yay! I didn't break it!
22:13:34 <EvanR> dfeuer: if At doesnt have access to Map internals, then
22:13:38 <EvanR> what is going on
22:14:09 <plug> EvanR yeah, in this case i'm trying a straight port of python code for the initial version of this.
22:14:11 <mgsloan> hefesto: See the recommended action in the error message? Do that :D
22:14:17 <EvanR> plug: D:
22:14:20 <dfeuer> EvanR, well, I've added a function to Data.Map that provides the functionality of `at`. So if he wants, Edward Kmett can define the At instance for maps to use the new alterF function in Data.Map.
22:14:36 <plug> it's a slightly complicated probabilistic model, so i want to understand the algorithm before rewriting it
22:14:47 <dfeuer> Alternatively, anyone can use it directly...
22:15:03 <EvanR> plug: with this is an interface thing, so ultimately no rewriting is necessary
22:15:27 <plug> with what?
22:15:29 <EvanR> dfeuer: alterF is in there now?
22:15:38 <EvanR> plug: s/with/well/
22:15:51 <gabbiel> evan, tell me if I'm using bangpatterns unrelentlessly here, https://0x0.st/qvH.png
22:16:08 <plug> the funny thing is trying to port the logic as is  has forced me to learn some more advanced topics like lenses and pipes.
22:16:27 <EvanR> gabbiel: !str wont do much
22:17:03 <EvanR> > let !str = 'foo':repeat undefined in head str
22:17:04 <lambdabot>      Syntax error on 'foo'
22:17:04 <lambdabot>      Perhaps you intended to use TemplateHaskell
22:17:04 <lambdabot>      In the Template Haskell quotation 'foo'
22:17:06 <dfeuer> Ho lee shit. Data.Sequence.splitAt will be something close to *twice* as fast in the next version of containers :-D. Very close to that for short ones :-D
22:17:14 <EvanR> > let !str = 'c':repeat undefined in head str
22:17:16 <lambdabot>  'c'
22:17:16 <dfeuer> EvanR, yeah, it's in git master.
22:17:19 <EvanR> the character foo
22:17:34 <EvanR> wow
22:18:05 <dfeuer> Actually, it's probably better than that.....
22:18:11 <dfeuer> Jeepers.
22:19:02 <gabbiel> what happened
22:19:30 <hefesto> mgsloan: I feel ashamed :( Fixed it.
22:19:54 <EvanR> funny that Writer simply appends lists, this seems very inefficient as a log mechanism
22:20:06 <EvanR> if it appended them backwards it would make more sense ;)
22:20:46 <Arxenix> I'm new to programming in haskell and am a little confused about types. Can someone explain what the Top type is to me? And why it exists? 
22:21:00 <EvanR> theres no Top type in haskell
22:21:30 <EvanR> top and bottom are types in a subtyping lattice, which haskell doesnt have
22:21:36 <scshunt> well it does
22:21:41 <scshunt> oh no wait, *types*
22:21:42 <scshunt> nvm
22:21:44 <gabbiel> i've never head of top either
22:21:57 <scshunt> Arxenix: where did you run across this?
22:22:01 <hefesto> mgsloan: I did all sorts of diferent things to the .cabal file, but none to the stack.yaml... I still dont understand well the difference between stack and cabal, do you have a link that contrasts them?
22:22:11 <Arxenix> Someone told me that  "t" in the type means top
22:22:18 <Clint> o_O
22:22:26 <EvanR> t in a type is a variable
22:22:44 <EvanR> maybe youre thinking of a different language
22:23:06 <gabbiel> like in (a -> t), the t is a Top?
22:23:06 <dfeuer> Now I just need to make take and drop work like splitAt does now .....
22:23:24 <Arxenix> No I'm definitely thinking of haskell hold on I'll show you what I mean
22:23:26 <dfeuer> Honestly, this is *boring* work. Which is probably why no one bothered to do it before.
22:23:32 <Clint> go dfeuer go
22:23:38 <dfeuer> :)
22:24:14 * EvanR imagines Data.Sequence as being a racecar (or perhaps a dump truck) re-equipped with an engine twice as big going down a desert highway
22:24:19 <EvanR> maybe not so boring
22:24:34 <dfeuer> Heh.
22:24:51 <gabbiel> the fuher or doofer?
22:24:59 <dfeuer> I just mean writing the code. Figuring out what to do is fun, but then there's a shit-ton of pattern matching and arithmetic.
22:25:04 <EvanR> lol doofer
22:25:24 <EvanR> yeah writing haskell code gets old fast when its repetitive
22:25:44 <gabbiel> i remember when I had trouble understanding pattern matching
22:26:16 <dfeuer> And it's error-prone too. Have to run the package tests all the time and then grovel over the code to figure out where I did something stupid when they barf.
22:26:49 <gabbiel> thats why I write code for myself, because I know itll be crap and nobody will use it
22:26:53 <gabbiel> except me of course
22:26:57 <Arxenix> If the type expression is like
22:27:16 <dfeuer> On the one hand, it would be interesting to re-implement this all using type-aligned sequences, so the type checker will complain about (almost) any mistakes. On the other hand, that would be painful in the extreme.
22:27:20 <Arxenix> a::t->t1->t2->t3
22:27:21 <prohobo> shit
22:27:35 <Arxenix> Is t just a random variable? 
22:27:39 <thimoteus> yes
22:27:47 <Arxenix> Why does it get converted from like x or y to t
22:29:34 <scshunt> dfeuer: heh
22:29:49 <scshunt> dfeuer: I'm trying to decide whether to write game phase transitions in my board game implementation into the type system
22:30:06 <gabbiel> f :: (a -> b) means it takes a type a, and returns a type b, the type b can be the same as the type a, but this notation means it can take two types which are different or the same
22:30:30 <gabbiel> a x y, means that it takes a value x of type a, and a value y of type b, simple as that
22:30:38 <gabbiel> *f x y
22:31:00 <scshunt> dfeuer: I'm thinking I might
22:31:24 <Arxenix> gabbiel: thanks that clears up what I was confused about. Got it
22:32:25 <gabbiel> danm, I messed up
22:32:35 <gabbiel> it takes a value x of type a, and returns a type b
22:32:50 <gabbiel> x and y are variable names
22:33:13 <Arxenix> Oh
22:34:06 <Arxenix> I've never used any sort of functional language before so it's just taking some time to wrap my head around the different way of thinking
22:35:01 <gabbiel> i was like taht at first too
22:35:13 <scshunt> Arxenix: a big reason Haskell does this is to make it easier to write partially-applied functions
22:35:29 <EvanR> dfeuer: so alterF is using this bitqueue thing
22:35:34 <scshunt> in functional languages, you pass functions around a lot as values
22:35:46 <scshunt> so if f :: a -> b -> c
22:35:49 <dfeuer> EvanR, yes.
22:36:02 <scshunt> then you can write "f a" and that's a valid function
22:36:15 <EvanR> thanks for the background on coyoneda, it sort of makes sense now
22:36:56 <Arxenix> scshunt: yeah, I get that. passing around a function as a value seems really strange to me so far though
22:37:26 <plug> is there a unicde replacement for \x -> ...? i know lambda is out
22:37:35 <gabbiel> thats what fp is all about, making functions ordinary
22:37:37 <koz_> :t (^)
22:37:38 <lambdabot> (Integral b, Num a) => a -> b -> a
22:37:48 <koz_> :t (^^)
22:37:49 <lambdabot> (Fractional a, Integral b) => a -> b -> a
22:38:08 <gabbiel> im not sure, it has more to do with editor, maybe lekash can do something about that?
22:38:25 <EvanR> Arxenix: in the classic higher order function map :: (a -> b) -> [a] -> [b], it should seem natural, after a few double-takes
22:38:34 <EvanR> > map (\x -> x + 1) [1,2,3,4,5]
22:38:35 <lambdabot>  [2,3,4,5,6]
22:38:43 <EvanR> map cant work without taking a function as an argument
22:39:12 <EvanR> @src map
22:39:12 <lambdabot> map _ []     = []
22:39:12 <lambdabot> map f (x:xs) = f x : map f xs
22:39:46 <EvanR> it really makes a lot of tasks really simple and natural, when you need more configurability and code reuse
22:40:19 <EvanR> a record full of functions can be used as a driver interface for example, and you can make many implementations of the interface by making more records of that type
22:40:48 <Arxenix> Interesting 
22:40:53 <EvanR> it would be analogous to a structure of function pointers, if you ever did C
22:41:12 <gabbiel> wait what?
22:41:34 <Arxenix> I've only done OOP python and java, so I'm just not really used to the concepts yet
22:41:49 <scshunt> python has lambdas
22:42:01 <EvanR> then its probably pretty alien at this point
22:42:11 <gabbiel> and map, filter, and composition too
22:42:19 <EvanR> python has/hates lambdas
22:42:20 <EvanR> so does ruby
22:42:28 <gabbiel> but its so verbose and disgusting, i'd rather haskell
22:43:07 <gabbiel> you just can't beat "f x y", "def f(x,y):" can;t compete
22:43:22 <Arxenix> Python is pretty concise compared to java at least
22:43:28 <gabbiel> ignonring syntax though, python is useful
22:45:56 <gabbiel> this, Java's version of id is probably "IdentityFunctionthatReturnsTheSameValueBecauseThatsWhatIdentityIs"
22:50:55 <koz_> gabbiel: Don't forget that it also throws an AbstractIdentityFrameworkCommandStrategyAdvisorVisitorNotFoundIONullPointerExceptionError occasionally.
22:51:37 <koz_> Also, could someone tell me how to make an hlint warning at line 11 here go away? http://lpaste.net/164090 (it talks about defaulting to an Integer because of use of ^, and I hate warnings).
22:51:50 <koz_> Advice for less hideous implementations also welcome.
22:57:27 <dfeuer> Whew. The new Data.Sequence.take is done!
22:57:31 <scshunt> woot
22:57:37 <dfeuer> splitAt is done, and take is done.
22:57:55 <dfeuer> But I still need to do drop, and it's painful.
22:58:07 <scshunt> dfeuer: question about what you said about implement at earlier
22:58:08 <dfeuer> I have to turn take backwards. :-(
22:58:15 <dfeuer> Yes, scshunt 
22:58:31 <scshunt> is there a reason to preserve the original structure rather than use a zipper?
22:58:31 <gabbiel> koz, I don't understand ur code, are you trying to determine if the an index exists
22:58:51 <gabbiel> or 1 < index < size?
22:59:01 <dfeuer> scshunt, that's what the code I wrote does. It uses the original structure at a bit string to fake a zipper.
22:59:09 <dfeuer> oh, sorry.
22:59:13 <dfeuer> I misunderstood the question.
22:59:32 <dfeuer> Yes, scshunt, a zipper allocates one heap object per link.
22:59:42 <scshunt> ah, right
22:59:48 <dfeuer> It's bad for exactly the same reasons Yoneda and Coyoneda are :-/
23:00:37 <dfeuer> "Bad" being a relative term. This is all counting how many nanoseconds can dance on the pinhead.
23:02:37 <scshunt> yep
23:03:31 <koz_> gabbiel: If the index is equal to or greater than 2 ^ 2 ^ size, then no such answer exists.
23:03:43 <koz_> It's a Johnson-Stenhaus-Trotter combinatorial enumeration implementation.
23:04:39 * hackagebot uhc-light 1.1.9.4 - Part of UHC packaged as cabal/hackage installable library  https://hackage.haskell.org/package/uhc-light-1.1.9.4 (AtzeDijkstra)
23:07:54 <EvanR> dfeuer: so pull requests are going to containers github?
23:08:34 <dfeuer> EvanR, I'm not sure what you're asking.
23:08:42 <dfeuer> That's the place to submit pull requests, yes.
23:08:46 <dfeuer> Do you have one?
23:10:20 <EvanR> ok
23:10:23 <EvanR> no i dont
23:10:27 <EvanR> just checking which project this is
23:10:56 <dfeuer> EvanR, yeah, that's the right place.
23:11:06 <EvanR> right now im trying to get a working demo of something ready for monday
23:11:22 <dfeuer> Have fun!
23:11:26 <EvanR> so whether or not that gets done by then, i can try a mad science bitqueue algorithm
23:11:28 <dfeuer> I think I'll probably go to sleep soon.
23:11:32 <dfeuer> Yaaaay!
23:11:35 <dfeuer> Mad science!
23:11:36 <EvanR> afterward
23:15:06 <koz_> OK, now I have a question. I have an Integer and a Maybe [Bool], and I need to get Maybe ([Bool], Integer) out of that. Is there some kind of magic typeclass or function I should be aware of for this purpose?
23:15:28 <gabbiel> koz, why (i - half)
23:15:54 <EvanR> > fmap (,3) (Just [True,True,True])
23:15:55 <Cale> koz_: Something like  fmap (\xs -> (xs,b)) m
23:15:56 <lambdabot>  Just ([True,True,True],3)
23:16:03 <gabbiel> yeah, return a pair
23:16:56 <koz_> gabbiel: Draw it out as a tree and it becomes pretty clear.
23:17:17 <koz_> Also, thanks EvanR and Cale!
23:21:58 * dfeuer is very happy with these splitAt improvements :-)
23:22:57 <gabbiel> what happen, deufer, share ur code
23:25:28 <koz_> Also, I still need help removing that warning at line 11 here:  http://lpaste.net/164090 
23:25:36 <koz_> (if anyone could help)
23:56:16 <SmartHex> jj
23:59:01 <Xnuk> e
