00:21:12 * hackagebot tracetree 0.1.0.1 - Visualize Haskell data structures as edge-labeled trees  https://hackage.haskell.org/package/tracetree-0.1.0.1 (EdskoDeVries)
00:26:12 * hackagebot stm-containers 0.2.11 - Containers for STM  https://hackage.haskell.org/package/stm-containers-0.2.11 (NikitaVolkov)
00:56:13 * hackagebot hedn 0.1.8.2 - EDN parsing and encoding  https://hackage.haskell.org/package/hedn-0.1.8.2 (AlexanderBondarenko)
00:57:13 <Jinxit> AST question: http://lpaste.net/163298
00:59:49 <Jinxit> ideally I would like to keep the AST separate from any specific language, but I'm not sure how to
01:04:21 <cocreature> Jinxit: you can always just use a type parameter in place of String and leave the decision up to the users
01:08:02 <Jinxit> cocreature: that's a much better option, thanks
01:08:11 <Jinxit> but still has to be the same type for the entire AST
01:08:22 <Jinxit> but yes, that would allow for enums
01:17:09 <EvanR> "The Set data type is not an endofunctor; it is a functor which maps from the Ord-subcategory of Hask to Hask"
01:18:24 <cocreature> EvanR: I think it’s the other way around? Data.Set.map has an Ord constrained on b when it is given a (a -> b)
01:20:03 <EvanR> Set sends a Ord-type to *
01:20:29 <sword_smith> I have some files in ./src and I want to write some tests to ./t. From the test files in ./t, how do I import the mosules located in ./src?
01:20:36 <EvanR> map sends a function between two ord types to a function between corresponding sets
01:21:01 <EvanR> the key insight is that Ord constraint denotes a subcategory of hask
01:21:29 <cocreature> EvanR: you can create a Set a without an Ord constraint on a, i.e. a singleton set or an empty set
01:21:32 <EvanR> (Set itself doesnt have this constaint though so its kind of stretching things)
01:22:20 <EvanR> but the combination of Set and Set.map as a "exofunctor" wont let you have your empty of Set of non-ord
01:22:35 <cocreature> what’s an exofunctor?
01:22:44 <EvanR> a non endofunctor
01:22:48 <EvanR> https://dorchard.wordpress.com/2011/10/18/subcategories-in-haskell-exofunctors/
01:24:26 <cocreature> EvanR: I don’t get why it shouldn’t be an endofunctor on the Ord-subcategory. if you have Ord a you also have Ord (Set a)
01:25:29 <EvanR> if thats true its peculiar to Set
01:25:46 <EvanR> the blog post is about arbitrary situations where Functor doesnt work
01:26:36 <EvanR> some data structures may not also support the operations of the types theyre parameterized by
01:26:58 <EvanR> i.e. not be in that subcategory
01:27:04 <cocreature> ah ok, I only skimmed it the post very quickly and seem to have missed that
01:31:34 <cocreature> hm I should brush up on my category theory
01:40:24 <bizarrefish> Hi all
01:41:19 <bizarrefish> Are type constructors functors between categories of data (which are called types)?
01:41:45 <EvanR> functors send types to types, and functions to functions
01:42:03 <EvanR> in haskell, the source and destination is always the same category
01:42:07 <EvanR> "Hask"
01:42:41 <EvanR> types and functions live in Hask
01:45:13 <bizarrefish> Right, I get that. Can't you have more granular categories, though. So a category of types, where objects are * and morphisms are * -> * and type constructors are functors?
01:45:42 * bizarrefish is pulling this out of his ass, rather than reading something, so forgive if what I'm saying is off the wall.
01:46:10 <bizarrefish> Oh wait. no. * -> * is a type constructor
01:46:10 <bizarrefish> Nvm
01:46:17 <bizarrefish> f**k
01:46:52 <EvanR> sounds like youre talking about a category where objects are kinds and morphisms are type constructors
01:47:03 <bizarrefish> Yes!
01:47:10 <bizarrefish> That's what I am meaning to say
01:47:25 <EvanR> there is a way to compose type constructors
01:47:32 <EvanR> the package type-compose
01:47:54 <bizarrefish> Don't you mean 'objects are types' though?
01:48:00 <EvanR> and haskell has other kinds of kinds besides *
01:48:18 <bizarrefish> As typce constructors associate types with types, rather than kinds with kinds
01:48:25 <bizarrefish> *type
01:48:41 <EvanR> a * -> * is a morphism that sends a * to a *
01:49:05 <EvanR> you can have other kinds besides *
01:53:38 * bizarrefish reads again. '* is A morphism...'. I think I know where i'm getting mixed up. I was getting stuck in set theory again, thinking morphism = function
01:53:46 <EvanR> * -> * is
01:54:26 <EvanR> N -> R is a morphism from the set of numbers to the set of reals, in the category of sets
01:54:41 <EvanR> even here the role of objects is more like types than sets
01:56:15 * hackagebot cryptohash-sha1 0.11.7.2 - Fast, pure and practical SHA-1 implementation  https://hackage.haskell.org/package/cryptohash-sha1-0.11.7.2 (HerbertValerioRiedel)
01:58:10 <bizarrefish> I was going down the route of: 'a type sends a (* -> *) to a *'
01:58:34 <bizarrefish> Which I see now is not what I thought I had in mind
01:58:42 <EvanR> wut... a *->* sends a * to *
01:58:56 <bizarrefish> EvanR: A type application, rather
01:59:00 <EvanR> pretty soon * will be renamed to Type, avoiding some confusion maybe ;)
01:59:26 <bizarrefish> I can see why :D
01:59:46 <EvanR> Maybe sends a type to a type, Maybe Int is a type
01:59:50 <bizarrefish> Though it's certainly not the thing which has confused me the most, it's definitely annoying
02:00:21 <bizarrefish> If maybe sends a type to a type, does that mean type constructors are morphisms over types?
02:00:45 <EvanR> you could say Maybe is in a category of kinds
02:01:12 <EvanR> it goes between the particular kind * and itself
02:01:51 <EvanR> :k Maybe -- just making sure
02:01:52 <lambdabot> * -> *
02:01:56 <EvanR> yeah
02:01:58 <bizarrefish> Maybe sends * to *
02:02:03 <bizarrefish> Mhm
02:02:26 <EvanR> * is a kind
02:02:46 <bizarrefish> Could one also say Maybe sends a to a, forall a ?
02:02:51 <EvanR> no
02:03:30 <EvanR> you might be mixing up notation * with glob "all" *
02:03:44 <bizarrefish> I think i've been trying to treat morphisms as polymorphic 
02:04:30 <EvanR> for a first approximation i think of id :: a -> a as many different functions
02:04:40 <EvanR> id :: Int -> Int, id :: Char -> Char
02:04:44 <EvanR> etc
02:04:48 <bizarrefish> Maybe is an morphism in the category of kinds. I can get that. An...endomorphism?
02:05:02 <EvanR> it has the same source and destination object so yes
02:05:08 <bizarrefish> Woo, I inferred something!
02:05:32 <bizarrefish> * I inferred something correct
02:06:40 <bizarrefish> How about in the category of types, you could say Maybe refers to a set of morphisms?
02:06:51 <EvanR> no its a single one
02:07:09 <EvanR> * is one kind
02:07:14 <EvanR> its like id :: Int -> Int
02:07:33 <bizarrefish> But in the category of types, there's a Maybe for Int, a Maybe for Bool
02:07:40 <EvanR> no
02:08:07 <EvanR> wait, you said category of types, you mean Hask?
02:08:16 <EvanR> i thought you meant kinds
02:08:16 <bizarrefish> ...I think I might do
02:08:19 <bizarrefish> I meant types
02:08:42 <EvanR> Maybe isnt in that category
02:09:03 <EvanR> you cant have a function from Maybe to something
02:09:19 <bizarrefish> Hah. i think I now *intuitively* get where Hask fits in.
02:10:21 <bizarrefish> How about the type-level equivalent of Flip a ? Or isn't there one?
02:10:52 <EvanR> i think there is
02:10:53 <bizarrefish> type FlipType g f = FlipType f g
02:10:57 <bizarrefish> Or something like that
02:11:01 <bizarrefish> (my haskell is not good)
02:11:42 <EvanR> newtype Flip j b a = Flip { unFlip :: a `j` b }
02:11:44 <bizarrefish> That would go from FilpType Int would go from Maybe -> Maybe Int
02:12:12 <EvanR> thats from type-compose
02:12:38 <bizarrefish> Crap, haskell has a library for every kind of magic.
02:12:44 <EvanR> Maybe -> Maybe Int doesnt make much sense
02:13:03 <EvanR> :k (->)
02:13:04 <lambdabot> * -> * -> *
02:13:10 <bizarrefish> I know, but I was being existensial
02:13:23 <bizarrefish> Perhaps I should stop doing that when trying to grasp something
02:13:30 <EvanR> Flip only makes sense with two argument ctors
02:13:42 <EvanR> Maybe has 1
02:14:28 <bizarrefish> Before, you said that Maybe isn't in category Hask
02:14:44 <bizarrefish> I don't get why it isn't a morphism
02:15:07 <EvanR> because a common description of Hask is the collection of types (in *) and functions between those types
02:15:23 <EvanR> :k (->)
02:15:24 <lambdabot> * -> * -> *
02:15:26 <bizarrefish> Maybe is a type function, is it not?
02:15:40 <bizarrefish> Or rather, a set of type functions (one for each type)
02:15:46 <dibblego> @kind Maybe
02:15:47 <lambdabot> * -> *
02:15:50 <EvanR> for the sake of this discussion ill call it a type constructor
02:15:53 <EvanR> not a function
02:16:09 <EvanR> its not a set of anything its not polymorphic
02:16:18 <EvanR> i mean, and also its not polymorphic
02:16:29 <bizarrefish> So...what category is Maybe Int an object in?
02:16:36 <EvanR> Maybe Int :: *
02:16:39 <EvanR> its a type
02:16:44 <EvanR> its in Hask
02:16:45 <bizarrefish> Right, so it's in category Hask
02:17:08 <bizarrefish> cool, okay. So is there a morphism which goes from Int to Maybe Int in hask?
02:17:15 <EvanR> yep
02:17:21 <bizarrefish> ^.^
02:17:26 <bizarrefish> What is that morphism?
02:17:31 <EvanR> theres a lot
02:17:34 <bizarrefish> Oh
02:17:42 * bizarrefish scratches head
02:17:58 <Freundlich> bizarrefish: If you can write a function of that type then it's a morphism in Hask.
02:18:15 <bizarrefish> Oh right, like return
02:18:15 <Freundlich> bizarrefish: I guess you can imagine that there are a lot of functions of that type.
02:18:19 <Freundlich> Yeah.
02:18:25 <EvanR> > (^0) 2
02:18:26 <lambdabot>  1
02:18:28 <EvanR> > (^0) 1
02:18:29 <lambdabot>  1
02:18:31 <EvanR> > (^0) 0
02:18:33 <lambdabot>  1
02:18:39 <EvanR> hrm... 
02:18:54 <bizarrefish> EvanR: what's the problem?
02:18:59 <EvanR> if that wouldve failed, then (^0) is a good candidate for such a function
02:19:10 <bizarrefish> Ah
02:19:20 <EvanR> Just 1 for non zero, Nothing for 0^0
02:19:45 <EvanR> but this one is obvious
02:19:57 <EvanR> :t Just `asAppliedTo` 0
02:19:58 <lambdabot> Num a => a -> Maybe a
02:20:03 <EvanR> :t Just `asAppliedTo` (0::Int)
02:20:04 <lambdabot> Int -> Maybe Int
02:20:49 <bizarrefish> > (+) 3 4
02:20:51 <lambdabot>  7
02:20:56 <bizarrefish> heh
02:22:05 <EvanR> since Int is finite, theres a finite number of such functions
02:22:17 <EvanR> but its a lot
02:23:09 <bizarrefish> So.... in a category, a morphism doesn't actually associate an individual object to another object, otherwise a type constructor would send Int to Maybe Int.
02:23:11 <EvanR> (intCount + 1) ^ intCount, i think
02:24:36 <EvanR> by object do you mean type?
02:24:45 <bizarrefish> Yes, a type being an object in Hask
02:24:50 <saurabhnanda> is it possible to execute multiple threads in GHCI?
02:25:16 <EvanR> ok, then it sounds like youre talking about functions rather than morphisms in general
02:25:26 <EvanR> with the word associating individuals with something
02:25:44 <bizarrefish> Looks like i need to look up the difference between a function and a morphism
02:25:55 <EvanR> Just is a function, it associates 3 with Just 3
02:26:26 <EvanR> but 3 is not a type
02:26:32 <bizarrefish> But Just 3 is not a different object in Hask from Just 4, they're both Maybe Int
02:26:39 <EvanR> Just 3 isnt an object
02:26:40 <EvanR> or a type
02:26:48 <bizarrefish> But Int is a different object from Maybe Int
02:27:02 <EvanR> youre mixing 3 levels now instead of 2 ;)
02:27:19 <bizarrefish> O_o
02:27:38 <EvanR> Just 3 is different from Just 3
02:27:40 <EvanR> asldjf
02:27:41 <EvanR> Just 3 is different from Just 4
02:27:59 <EvanR> they have the same type
02:28:25 <bizarrefish> Right, I get that
02:28:31 <EvanR> Int and Maybe Int have the same kind: *
02:28:45 <bizarrefish> Aren't objects in Hask types?
02:29:00 <EvanR> sure
02:29:09 <bizarrefish> So Maybe Int is a different object from Int
02:29:24 <EvanR> sure
02:29:50 <bizarrefish> I've been thinking that the morphism between those two objects would be a type constructor
02:30:01 <EvanR> yes
02:30:10 <bizarrefish> Righ, so type constructors are morphisms in Hask
02:30:15 <EvanR> no
02:30:18 <bizarrefish> GAH!
02:30:19 <bizarrefish> :(
02:30:31 <Cale> (some) type constructors are functors Hask -> Hask
02:30:59 <EvanR> the syntax to talk about applications of all these things, and the fact that they dont reduce to anything (Just 3) might lead to confusion
02:31:08 <EvanR> the only way to know we are on another level is the specific name
02:31:23 <EvanR> which is kind of annoying actually unless youre familiar with the names
02:32:44 <EvanR> Cale: are there any functors from Hask to Hask that arent type ctors ...
02:32:53 <bizarrefish> I think my internal lack of understanding is well-stated by saying I don't understand the difference between a morphism and an endofunctor
02:33:04 * bizarrefish googles
02:33:25 <EvanR> morphisms are what you call arrows in a category, and what they are depends on the category
02:33:35 <EvanR> a functor is a thing between categories
02:34:07 <EvanR> and in case youre talking about a category of categories, the morphisms might in fact be functors
02:34:19 <EvanR> but were not
02:34:27 <bizarrefish> Those 4 lines make good sense
02:34:29 <bizarrefish> :)
02:35:04 <bizarrefish> So, perhaps I've been misunderstanding about Hask. Hask defines morphisms to be functions between values of the types(which are objects in hask)
02:35:28 <EvanR> functions between types
02:35:36 <EvanR> id say
02:35:51 <bizarrefish> But you don't mean type-functions?
02:35:54 <EvanR> no
02:36:01 * bizarrefish 's penny drops
02:36:03 <EvanR> so maybe its a bad way to say it
02:36:24 <EvanR> similar to a function from one set to another set...
02:36:49 <EvanR> its not between values in a set, unless those values are also sets...
02:37:01 <bizarrefish> So is there a category of types where the morphisms are type-functions?
02:37:09 <EvanR> and a functor is not "between objects in two categories"
02:37:55 <EvanR> thatd be the kinds category
02:38:38 <bizarrefish> But Maybe Int is the same kind as Maybe Bool, so they would be the same object in the kinds category.
02:38:50 <EvanR> *, ?, ??, #, DataKind1, DataKind2, etc are the objects
02:38:58 <EvanR> if you allow those other kinds
02:39:24 <EvanR> Maybe Int and Maybe Bool arent involved in the kinds category
02:39:34 <bizarrefish> Indeed, they're types. 
02:39:39 <bizarrefish> They're all kind *
02:39:42 <EvanR> like 3 isnt in Hask
02:40:07 <bizarrefish> So how about a category where Int, Bool, Maybe Int and Maybe Bool are objects, and Maybe is a morphism. Would that be a category?
02:40:29 <EvanR> and what would you say
02:40:33 <EvanR> Maybe :: ...
02:40:44 <EvanR> which two objects does it go between
02:41:04 <EvanR> Maybe :: _ -> _
02:41:07 <bizarrefish> It goes between Int and Maybe Int
02:41:18 <EvanR> but it doesnt
02:41:27 <EvanR> youre thinking of Just
02:41:36 <bizarrefish> ohhh sorry
02:41:41 <bizarrefish> yes. I mean Just
02:42:36 <bizarrefish> So, Int Bool, Just Int and Just Bool are all in this category. And Just is a morphism
02:42:48 <EvanR> Just Int doesnt make sense
02:42:54 <fred-fri_> im playing around transforming a small java program into haskell... the java program has a class riskinpercent which is a number between 1-100. its a class rather than a primitive in order to avoid primitive obsession. in haskell i see similar effect can be achieved using newtype, but what is the syntax? ie newtype capital is a number between 0-100
02:42:56 <EvanR> neither does Int Bool
02:43:16 <bizarrefish> Sorry, I meant 'Int, Bool'
02:47:04 <EvanR> fred-fri_: newtype Capital = Capital Int
02:50:02 <bizarrefish> I think all my problems are rooted in my concept of an arrow. An arrow is better thought of as between objects, rather than something which associates an object to another object.
02:50:02 <nmdanny> question: is it possible to parallelize a replication of an opereation n times, where that operation lives in the Rand StdGen monad?
02:50:50 <EvanR> bizarrefish: its a thing with two labels
02:51:11 <bizarrefish> And those labels are objects?
02:51:18 <EvanR> yes
02:52:02 <EvanR> and the order of the labels matters, and thats about it
02:52:19 <fred-fri_> EvanR, thanks. im looking at http://learnyouahaskell.com/making-our-own-types-and-typeclasses. see how they define person with string name and int age? what im getting at is, in a real application,you dont want to use string and int for that, but would rather want to use some other type which enforced rules (eg age cant be negative, name cant be empty). how would one best go about adhering to that in haskell?
02:52:34 <EvanR> apart from the composition operation and the corresponding laws
02:53:07 <bizarrefish> Righty. In my broken conception of Hask, there's a morphism from Int to Maybe Int, and that morphism is called Maybe.
02:54:01 <EvanR> one is const Nothing, another is Just, another is fmap (+1) . Just
02:54:06 <bizarrefish> There would also be a morphism from Int to [Int]
02:54:48 <EvanR> again there are many
02:55:00 <EvanR> replicate 1, replicate 2, const [], etc
02:56:12 <bizarrefish> But those are data-functions. I'm talking about type-level functions. Hang on...what kind of function only admits one possible input? That's not a function!
02:56:30 <EvanR> youre talking about a broken conceptualization of Hask
02:56:42 <EvanR> lets be done with it ;)
02:57:13 <bizarrefish> Indeed, Just trying to understand exactly how it's broken
02:57:18 <EvanR> Hask = data-functions
02:57:23 <EvanR> and their types
02:57:45 <EvanR> you use . to compose them
02:57:57 <nmdanny> does GHCI support threading?
02:58:01 <EvanR> yes
02:58:39 <puregreen> when did oneShot get added to GHC? (Can someone with GHC 7.6 or GHC 7.8 check whether GHC.Base.oneShot is present?)
03:00:05 <Jinxit> I have it on 7.10.3
03:00:35 <bizarrefish> It feels like Hask having types as morphisms and data functions as arrows is mixing 2 different levels. My initial intuition was that type functions would be the morphisms.
03:00:46 <bizarrefish> Sorry, I mean types as objects
03:00:56 <EvanR> nope that is how categories work
03:01:01 <EvanR> the objects act as the types
03:01:02 <cocreature> puregreen: ghc-prim 0.3.1 (I have no idea which ghc that belongs to) doesn’t have it
03:01:11 <EvanR> the morphisms are the values
03:01:24 <bizarrefish> Ah!
03:01:31 <bizarrefish> I think i've pinned down my wrongness
03:01:32 <EvanR> which are labeled with two types
03:01:49 <noxwit> looking to pick up haskell to improve my functional programming skills. what's a good book to begin with? beginning haskell seems to be a recommended book on haskell.org.
03:01:54 <puregreen> cocreature: hm, I think ghc-prim is 7.8 (as per https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory)
03:01:57 <puregreen> okay, thanks
03:02:00 <EvanR> the labels are there to stop you from composing two incompatible things
03:02:01 <bizarrefish> I was completely wrong about the primitives of category theory!
03:02:10 <EvanR> otherwise they dont do anything
03:02:49 <Freundlich> I was about to say that objects can be thought of as some form of typing in any category.
03:02:54 <nmdanny> is it possible to make GHCI emit an eventlog when I want to profile a parallel function?
03:06:43 <bizarrefish> Heh, wikipedia calls a 'Functor' a 'Process'
03:06:46 <bizarrefish> https://en.wikipedia.org/wiki/Category_theory#Functors
03:06:56 <bizarrefish> Better or worse than Context, I wonder
03:07:05 <EvanR> o_O
03:08:22 <EvanR> well armed with the value-type distinction, Functors might make more sense now
03:10:23 <bizarrefish> Anyway, huge thanks to yourself EvanR . I feel I probably owe you some bitcoin.
03:11:31 <bizarrefish> (Assuming you have the means to accept it)
03:16:06 <EvanR> got any worthless gold?
03:18:15 <troydm> is there a convenient function that will turn Bool to Integer?
03:18:38 <EvanR> > fromEnum True
03:18:39 <lambdabot>  1
03:19:21 <bizarrefish> EvanR: As in reddit gold, nah
03:22:29 <gfixler> Anyone know the status of this? https://wiki.haskell.org/MonadPlus_reform_proposal
03:22:41 <gfixler> is it in? is it dead?
03:23:07 <troydm> EvanR: thx
03:26:18 * hackagebot megaparsec 5.0.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-5.0.0 (mrkkrp)
03:31:45 <ggVGc> is there a mapMaybe for Vector?
03:31:53 <ggVGc> or rather, what would I use instead
03:32:01 <ggVGc> because in the docs there obviously isn't one
03:32:11 <EvanR>  :t mayMaybe
03:32:16 <EvanR> mapMaybe*
03:33:10 <ggVGc> but for Vector?
03:33:14 <ggVGc> should I just use toList?
03:33:17 <EvanR> what is it?
03:33:41 <EvanR> :t mapMaybe
03:33:42 <lambdabot> (a -> Maybe b) -> [a] -> [b]
03:33:43 <ggVGc> http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:mapMaybe
03:33:44 <EvanR> oh
03:34:06 <EvanR> isnt this trivially doable with just fmap
03:34:46 <EvanR> oh, it returns a shorter list
03:36:36 <EvanR> you might get fusion by using mapMaybe and list conversions in a certain way
03:38:48 <EvanR> or use fmap followed by a filter followed by a map
03:41:19 * hackagebot cryptohash-sha1 0.11.100.0 - Fast, pure and practical SHA-1 implementation  https://hackage.haskell.org/package/cryptohash-sha1-0.11.100.0 (HerbertValerioRiedel)
03:42:57 <gfixler> EvanR: why the map at the end?
03:43:10 <EvanR> to take off the remaining Justs
03:43:29 <gfixler> EvanR: ah, right
03:43:52 <EvanR> seems like it has a better chance of fusioning, but i have no idea. could check the core
03:44:06 <gfixler> EvanR: could also throw in a rule
03:44:22 <gfixler> https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
03:44:31 <EvanR> but what would you rewrite it to
03:44:54 <gfixler> Hey, I just handle step 1. use a rule
03:44:56 <EvanR> might as well implement the function as that
03:45:00 <gfixler> you have to provide step 2. ???
03:45:46 <sword_smith> When I use stack to handle the compilation of my code, should I still use a .ghci file or does stack handle what .ghci normally handles?
03:45:54 <gfixler> EvanR: do you ever dump out the code and check it for fusioning somehow?
03:46:15 <EvanR> i never did for fusion
03:47:31 <gfixler> https://hackage.haskell.org/package/vector-0.5/docs/Data-Vector-Fusion-Stream.html
03:48:26 <EvanR> ok yeah
03:48:29 <nmdanny> how can I create an eventlog file when building the program with stack?
03:48:46 <EvanR> it seems like you could totally make an efficient mapMaybe, they just didnt
03:49:34 <robstewartUK> I'm getting the following error when trying to install criterion: "is broken due to missing package process-1.2.3.0-a22328103774f0499a990653944cbf99"
03:49:38 <EvanR> by starting with enough space for worst case, the whole vector
03:49:45 <EvanR> and living with it
03:49:49 <robstewartUK> Here's the full log: https://gist.github.com/robstewart57/6ed2f5233e5d72fc097eb0e394649aa2
03:49:53 <robstewartUK> What's going wrong?
03:52:28 <gfixler> robstewartUK: I guess you have to install unix-2.7.1.0-bb54ee8f9f6b2600aae7a748eb88a610 and process-1.2.3.0-a22328103774f0499a990653944cbf99 manually
03:53:09 <bizarrefish>  /query EvanR 
03:53:11 <bizarrefish> oop
03:53:41 <bizarrefish> damn whitespace, there's a reason programming languages don't give it significance.
03:53:49 <bizarrefish> :P
03:54:10 <gfixler> yeah, irc's commands are unforgiving
04:17:12 <MichaelBurge> I have a list of routes, like 'RouteUser 5' should be displayed as '/users/5'. Some things - like the capture rules that turn '/users/:id' back into a RouteUser - belong to the constructor and not the value.
04:17:32 <MichaelBurge> Is there a way to refer to the constructor as a tag that can be shown and compared with equality?
04:19:57 <cocreature> :t toConstr
04:19:58 <lambdabot> Data a => a -> Constr
04:20:09 <cocreature> ^ MichaelBurge that’s one option
04:20:15 <cocreature> assuming you can derive Data
04:21:48 <cocreature> another option is to make an adt for your constructors and then parametrize some other type by that
04:23:57 <MichaelBurge> cocreature: That looks like it could work. And I can reflect over a type when making the capture rule to route association using 'dataTypeOf (undefined :: Route)', right?
04:25:43 <cocreature> MichaelBurge: if you already know its type is Route dataTypeOf won’t tell you anything new
04:34:11 <akegalj> is there a way to `killThread pid` so that I am sure at that time all child threads of pid thread also die ?
04:37:19 <merijn> akegalj: Use a custom forkIO wrapper that registers all children so that the parent can rethrow to the children
04:40:50 <akegalj> merijn: ok. thank you. Can someone help me understand what means that forkIO thread discards ThreadKilled. How is this useful? I don't get it, so we can't send kill signal to that thread?
05:03:15 <ski> MichaelBurge : one alternative may be to factor out your data constructors into one (or several) "enum" types, where they have no argument (i suppose this is what cocreature said). if necessary, define it as a GADT, and possibly use "existentially quantified data constructors"
05:03:40 <cocreature> yeah that’s what I was trying to get at with the second option
05:06:17 <ski> an alternative to factoring the data type would be to define a factoring isomorphism
05:06:46 <ski> (iow, keep the old data constructors, *and* add the "enum" type, and a conversion between them)
05:08:03 * ski would sometimes like to be able to be able to define a datatype with multiple `newtype' declarations at the same time
05:10:12 <MichaelBurge> ski: My only concern there is you'd be duplicating lines between the enum and the full constructor(there's 42 such routes). But maybe it's better to keep the semantics simple.
05:10:34 * ski nods
05:12:04 <ski> MichaelBurge : i'd probably go with the "factoring the data type" route, unless that led to too clunky-looking usage of the data type
05:12:23 <ski> (of course, i haven't seen the details of your data type, yet)
05:20:51 <bbear> Hello
05:21:01 <bbear> Is it advised to use tail recursion whenever possible with Haskell ?
05:22:32 <Rembane> bbear: No
05:22:37 <Rembane> bbear: The compiler will do that for you
05:22:51 <Rembane> bbear: Just write the most easily understood code
05:23:27 <bbear> ok. I am trying to use a function with lazy stopping
05:26:21 * hackagebot phoityne-vscode 0.0.3.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.3.0 (phoityne_hs)
05:26:53 <Rembane> bbear: Does it not work as you want it to?
05:29:52 <bbear> not exactly, I am trying to figure out something
05:30:03 <bbear> I want to get all the digit in a positive integer
05:30:38 <bbear> mathematical definition would look like :[ x%10^k | k<-[1..] ]
05:30:59 <bbear> But I want the evaluation to stop when 10^k becomes bigger than x
05:31:20 <bbear> Also I would like to ignore 0 numbers in the return list.
05:31:36 <bbear> but if they are, not a big problem
05:32:50 <bbear> Well, and I want to return an empty list if the number is negative
05:33:23 <maerwald> :t takeWhile
05:33:24 <lambdabot> (a -> Bool) -> [a] -> [a]
05:36:51 <bbear> ok
05:37:09 <bbear> So here is the challenge. How do you compute the digits of an integer (positive) ?
05:37:42 <bbear> Find max (k\in N) such as quot x 10^k !=0
05:38:28 <Rembane> bbear: Convert it to a string and check the length of it
05:38:43 <bbear> Rembane: I would like but I call this a hack sorry
05:38:56 <Rembane> bbear: ^^
05:39:50 <bbear> for each k in [1..max{k|quot x 10^k}]: digit.append(bar)
05:39:52 <bbear> sorry
05:40:06 <bbear> I got nervously compelled to violentlyhit my keyboard.
05:40:50 <Rembane> bbear: Take a walk around the building then. :)
05:40:58 <Rembane> > map (10^) [1..]
05:41:00 <lambdabot>  [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,...
05:41:14 <bbear> I feel like ar ecursive version is however the most natural form, since I had to remove the last remainder of the number I am examining.
05:41:53 <Rembane> > map (div 123456) (10^) [1..]
05:41:55 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
05:41:55 <lambdabot>                  with actual type ‘[Integer]’
05:41:55 <lambdabot>      The function ‘map’ is applied to three arguments,
05:42:00 <hpc> :t iterate
05:42:01 <lambdabot> (a -> a) -> a -> [a]
05:42:06 <Rembane> > map ((div 123456) . (10^)) [1..]
05:42:07 <lambdabot>  [12345,1234,123,12,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
05:42:42 <Rembane> bbear: What does compute the digits mean?
05:43:06 <bbear> get_digits 123456 = [1,2,3,4,5,6]
05:43:10 <bbear> moreover
05:43:18 <Rembane> > map ((div 123456) . (10^)) [1..]
05:43:20 <lambdabot>  [12345,1234,123,12,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
05:43:26 <bbear> get_digits 102388004 = [1,23,8,8,4]
05:43:26 <Rembane> > map ((divMod 123456) . (10^)) [1..]
05:43:28 <lambdabot>  [(12345,6),(1234,56),(123,456),(12,3456),(1,23456),(0,123456),(0,123456),(0,...
05:43:30 <maerwald> bbear: it works with `div` and recursion 
05:43:34 <bbear> I'm working on it.
05:45:19 <Tekkkz> Hello! I want to build GHC from github source. But after successfully ./boot , I need to ./configure > ERROR: GHC not found. How can I build GHC WITHOUT having GHC installed already? lol
05:46:20 <phadej> Tekkkz: what's lol about that? Who'd you build GCC without GCC for example?
05:46:25 <phadej> bootstrapping is tricky
05:46:45 <Tekkkz> ahh right xD but I mean , how to do that now?
05:47:39 <phadej> Tekkkz: don't, install GHC from binary distribution, and then continue...
05:47:53 <Tekkkz> there is no binary for the system i wanna install it on
05:48:12 <cocreature> what system is that?
05:48:22 <cocreature> in that case you have to crosscompile ghc
05:48:45 <Nilabhra> yeah really what system do you use Tekkkz ?
05:48:53 <Tekkkz> aarch64
05:50:11 <Tekkkz> so what must I do now?
05:50:50 <ski> bbear : tail recursion is sometimes appropriate. but often it's nicer to instead use incrementally generated output
05:51:03 <phadej> Tekkkz: aarch64
05:51:10 <Tekkkz> yes
05:51:17 <phadej> Tekkkz: https://ghc.haskell.org/trac/ghc/wiki/CrossCompilation
05:51:18 <phadej> sorry]
05:51:19 <phadej> that
05:51:40 <Nilabhra> Tekkkz: also https://wiki.archlinux.org/index.php/ArchHaskell
05:52:38 <Nilabhra> Tekkkz: oh you mean 64 bit ARM architecture? yes you need to cross compile sorry
05:53:29 <Tekkkz> okay. thanks
05:54:35 <maerwald> ski: yeah, foldr (&&) True (repeat False) is probably one of those examples
05:55:39 <hpc> . o O ( why do lispers call it tail recursion and not cdr recursion? )
05:59:47 <bbear> get_digits_pre x kstart = if x<=0 then [] else [mod x (10^kstart)] :: get_digits_pre (x-(mod x 10^kstart)) (kstart+1)
05:59:55 <bbear> What's going on ?
06:00:48 <bbear> > get_digits_pre x kstart = if x<=0 then [] else [mod x (10^kstart)] :: get_digits_pre (x-(mod x 10^kstart)) (kstart+1)
06:00:49 <lambdabot>  <hint>:1:25: parse error on input ‘=’
06:02:02 <bbear> why my function doesn't work?
06:06:23 * hackagebot hspec-megaparsec 0.2.0 - Utility functions for testing Megaparsec parsers with Hspec  https://hackage.haskell.org/package/hspec-megaparsec-0.2.0 (mrkkrp)
06:10:11 <byorgey> bbear: you want a single : for cons, not ::
06:10:39 <byorgey> bbear: also, [mod x (10^kstart)] makes a *list* containing a single element
06:10:45 <byorgey> if you cons that onto something, it will be a list of lists
06:10:56 <byorgey> you probably want  (mod x (10^kstart)) : ...
06:12:24 <bbear> byorgey: I wanted to concat two lists
06:12:39 <byorgey> OK, the concat operator is  (++)
06:12:45 <bbear> yes
06:12:53 <bbear> The iterative version of the program is easu
06:12:56 <bbear> (easy)
06:13:10 <bbear> The functionnal writing is hard.
06:14:00 <koz_> byorgey: Hi - love your Typeclassopedia!
06:14:13 <koz_> Thought I'd extend my thanks - it's an amazing read and I learned a lot from it.
06:17:58 <bbear> ho I love recursion
06:18:15 <bbear> my interpreter just crashed under the weight of an infinite list of zeros
06:19:55 <bbear> > get_digits n = if n<=0 then [] else [ mod n 10 ] ++ get_digits (quot (n- mod n 10) 10)
06:19:56 <lambdabot>  <hint>:1:14: parse error on input ‘=’
06:20:06 <bbear> let get_digits n = if n<=0 then [] else [ mod n 10 ] ++ get_digits (quot (n- mod n 10) 10)
06:20:13 <bbear> > let get_digits n = if n<=0 then [] else [ mod n 10 ] ++ get_digits (quot (n- mod n 10) 10)
06:20:14 <lambdabot>  <no location info>:
06:20:15 <lambdabot>      not an expression: ‘let get_digits n = if n<=0 then [] else [ mod n 10 ]...
06:25:40 <bbear> get_digits n = if n<=0 then [] else [ mod n 10 ] ++ get_digits (quot (n - mod n 10) 10) 
06:25:41 <bbear> Hey. This last expression works perfectly fine, but I wonder where I could put the mod n 10 value to avoid the repetition.
06:27:01 <randomclown> With the Functor-Applicative-Monad proposal implemented, you automatically get a Monad instance if you have both Functor and Applicative right?
06:27:19 <quchen> randomclown: No.
06:27:31 <quchen> Functor and Applicative are not enough to make a Monad.
06:27:42 <randomclown> quchen: You still have to manually write a return and bind?
06:28:01 <quchen> Yes to bind, no to return (since it's the same as Applicative's pure).
06:28:33 <quchen> You can't write bind in terms of pure/fmap/ap though, so you'll have to do that one manually.
06:29:09 <randomclown> ok
06:31:01 <ski> randomclown : if you implement `Monad', you can use `liftM' to implement `fmap', and `return',`ap' to implement `pure',`(<*>)'
06:31:03 <quchen> randomclown: What you do get is very easy Functor/Applicative instances if you already have Monad.
06:31:06 <koomi> notably there are types for which no Monad instance can be defined, but which have a valid Applicative definition
06:31:42 <randomclown> ah ok, well I already have Functor and Applicative, and no Monad
06:33:15 <randomclown> So if I write the Monad instance does is there do I get functor and applicative automatically?
06:33:22 <randomclown> or do I still need to actually write their definitions
06:33:40 <randomclown> So if I write the Monad instance* do I get functor and applicative automatically?
06:33:44 <ski>   instance Functor Foo
06:33:48 <ski>     where
06:33:50 <ski>     fmap = liftM
06:33:58 <ski>   instance Applicative Foo
06:33:59 <quchen> randomclown: You do not get one automatically by the compiler, no.
06:34:00 <ski>     where
06:34:04 <ski>     pure = return
06:34:08 <ski>     (<*>) = ap
06:34:12 <ski>   instance Monad Foo
06:34:14 <ski>     where
06:34:18 <ski>     return a = ..a..
06:34:29 <ski>     ... >>= ... = ...
06:34:55 <randomclown> alright I see
06:35:24 <quchen> randomclown: It's just like implementing Ord does not give you an Eq instance, but given Ord code you can easily implement the Eq functions as well.
06:35:40 <quchen> instance Eq Foo where a == b = compare a b == EQ
06:38:41 <koz_> randomclown: As something of an aside, DeriveFunctor is a thing.
06:42:05 <bbear> How do you do something like foo list->list
06:42:31 <bbear> Where foo apply a bar function to every element of the list bar : number-> list
06:51:45 <fr33domlover> bbear, not sure exactly what you mean, but (1) check out the Functor class (2) read the Haskell Wikibook, at least first pages...
06:51:55 <bbear> yes
06:52:11 <bbear> I found out using the where keyword. Actually Haskell comes easier everyday.
06:52:37 <bbear> I'm following a course step by step, that's much more useful because exercising makes the learning fun.
07:02:12 <hpc> somewhat off-topic, but i quite like idris' ffi
07:02:25 <hpc> http://docs.idris-lang.org/en/latest/tutorial/miscellany.html#foreign-function-calls
07:04:28 <hpc> a single dependent function to convert between C types and idris types seems like it would be very convenient
07:04:44 <hpc> i bet you could probably do something similar with type families
07:17:38 <bbear> hello
07:18:02 <bbear> do you know a way to self-call a function without referencing to its name ? (some kind of syntactic sugar).
07:18:47 <xa0> use fix?
07:19:25 <hexagoxel> :t fix
07:19:26 <lambdabot> (a -> a) -> a
07:24:16 <bbear> Haskell beginner feeling : this wonderful satisfaction when you have written in one line of pure functional haskell afunction that would have been ugly and 10 lines in an imperative fashion.
07:24:31 <bbear> 2nd satisfaction: code is hyper generic
07:32:17 <xa0> bbear: :D
07:32:25 <xa0> bbear: are you okay with using fix?
07:32:36 <bbear> what is fix ?
07:32:52 <hpc> :t fix
07:32:53 <lambdabot> (a -> a) -> a
07:32:58 <xa0> for example, if you wanted to make a recursive sum function;
07:33:02 <larryba> > fix error
07:33:03 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
07:33:34 <xa0> > (fix $ \f x -> case x of {[] -> 0; n:xs -> n + f xs}) [1..3]
07:33:35 <lambdabot>  6
07:33:40 <bbear> I don't really get it.
07:33:48 <xa0> :t fix $ \f x -> case x of {[] -> 0; n:xs -> n + f xs}
07:33:51 <lambdabot> Num a => [a] -> a
07:33:53 <bbear> I suppos I will encounter it sooner or later in the tutorial.
07:34:00 <xa0> perhaps
07:34:21 <bbear> What was bothering me was to  write long_name_function x y = if x>0 then ... else long_name_function blabla
07:34:45 <xa0> you could use a helper function :p
07:34:56 <xa0> but there's no sugar for "current function"
07:39:06 <sm> morning all
07:39:13 <ggVGc> what do I write in the type signature for an indexable parameter when using Lens?
07:39:21 <moon__> ̋
07:39:37 <ggVGc> i.e someting I can use `ix` on
07:39:41 <sm> I think I will start that #haskell-atom channel, join if you're interested
07:40:04 <puregreen> ggVGc: you need the Ixed class
07:40:05 <ggVGc> sm: atom as in the dsl for generating C?
07:40:27 <sm> ggVGc: no the editor. Good point, have to be clear
07:40:45 <puregreen> ggVGc: e.g. the type signature of “ix” itself is: “ix :: Ixed m => Index m -> Traversal' m (IxValue m)”
07:40:46 <saurabhnanda> what's the best way to convert Value -> String
07:40:55 <puregreen> (where Index and IxValue are associated types)
07:41:13 <doubling> I thought ix was a natural number
07:41:26 <puregreen> * type families
07:41:30 <sm> is there an official person/org that should own #haskell-atom ?
07:42:11 <puregreen> doubling: it's Int64 for e.g. lazy Text, and [Int] for Tree
07:42:25 <puregreen> (and ‘k’ for Map k v)
07:43:08 <puregreen> sm: perhaps you could just start it and then hand it over if needed
07:43:32 <moon__>  ̮̈
07:44:02 <xa0> moon__: are you trying to break consoles or something
07:44:19 <moon__> No.
07:44:27 <moon__> Its a unicode smiley :P
07:44:29 <sm> puregreen: yup, done
07:44:33 <xa0> ahh
07:44:49 <moon__> Two unicode characters
07:46:15 <ggVGc> puregreen: so  should be able to do this? `getNoteSeq :: Ixed i => Int -> SharedModel -> i NoteEntry`
07:46:21 <ggVGc> I am missing something :(
07:46:25 <ggVGc> because that doesn't compile
07:47:13 <puregreen> I think it should be “Ixed (i NoteEntry) =>”
07:47:36 <puregreen> (if i is something like Set or other thing with kind * -> *)
07:47:52 <ggVGc> Vector in this case
07:48:24 <puregreen> wait
07:48:35 <puregreen> can you show the source of getNoteSeq?
07:48:47 <puregreen> I'm confused about what you're actually trying to index
07:48:55 <ggVGc> puregreen: this is what I'm trying to generalise, https://gist.github.com/ca3e95df11c1649845fd88ccb17d37e7
07:49:21 <puregreen> ggVGc: what's the type of model^.rootNoteSeqs?
07:49:59 <ggVGc> puregreen: Vector(Vector NoteEntry)
07:51:40 <puregreen> you're indexing a Vector (Vector NoteEntry); if you want to generalise it to Vector (i NoteEntry) then you're *still* applying ix to a Vector, not an ‘i’, and so you don't need Ixed
07:52:06 <ggVGc> hm, yeah
07:52:14 <ggVGc> I maybe didn't think about this correctly :)
07:52:15 <ggVGc> thanks
07:52:35 <puregreen> and if you want SharedModel to contain an “i (i NoteEntry)” or something, then ‘i’ should be mentioned in the SharedModel type, I guess
07:52:48 <JagaJaga> What's the "official" way of modules naming? Data.Foo.* or Foo.Data? For example in pandoc I see the 1st style and in Xmonad I see the 2nd style..
07:53:38 <puregreen> JagaJaga: most modules adhere to the hierarchy (Data.Foo.*, Control.*, Text.*, etc) but some people think it's stupid because Data.* and Control.* are kinda meaningless in many cases
07:54:46 <sm> usually it's general.to.specific
07:54:47 <geekosaur> xmonad stuff is not in general shareable with other projects
07:55:11 <c_wraith> in Haskell, data structures can easily be control flow structures. [] is the easiest example. so.. Yeah. 
07:55:14 <sm> sometimes it's just projectname.stuff
07:55:53 <fr33domlover> and sometimes both, when a package has both generally useful utils and some app specific code
08:01:27 * hackagebot HaTeX 3.17.0.0 - The Haskell LaTeX library.  https://hackage.haskell.org/package/HaTeX-3.17.0.0 (DanielDiaz)
08:29:36 <{AS}> Is there any laws coverning Eq and Ord?
08:29:54 <{AS}> I would expect that Eq is an equivalence relation (reflexivity, transitivity, symmetry)
08:30:15 <simpson> {AS}: People generally say that Eq should be an equivalence and Ord should be a partial order.
08:30:21 <{AS}> and Ord is a total order relation (reflexivity, transitivity, anti-symmetry, totality)
08:30:24 <simpson> But I don't know whether that's written down anywhere.
08:30:27 <{AS}> simpson: so Ord is not a total order?
08:30:33 <simpson> > 4.2 < 4.5
08:30:35 <lambdabot>  True
08:30:42 <simpson> > 4.2 < NaN
08:30:44 <lambdabot>  Not in scope: data constructor ‘NaN’
08:30:59 <simpson> > 4.2 < (0.0 / 0.0)
08:31:00 <lambdabot>  False
08:31:14 <{AS}> > compare 4.2 (0.0 /0.0)
08:31:14 <exio4> er, it's more like "We hope it's an equivalence relation, and Ord is a total order"
08:31:15 <lambdabot>  GT
08:31:26 <{AS}> simpson: OK, thanks :)
08:31:35 <exio4> Float(s) are the exception
08:31:38 <{AS}> > compare (0.0 / 0.0) (0.0 / 0.0)
08:31:39 <lambdabot>  GT
08:31:40 <simpson> {AS}: Anyway, I was trying to illustrate that the instance of Ord for floats is questionable.
08:31:51 <{AS}> simpson: Yeah, thanks :)
08:33:23 <Xnuk> > 4.2 > 0/0
08:33:25 <lambdabot>  False
08:35:56 <Xnuk> > map (\f -> 4.2 `f` 0/0) [(>), (>=), (==), (<=), (<)]
08:35:57 <lambdabot>      No instance for (Fractional Bool) arising from a use of ‘/’
08:35:57 <lambdabot>      In the expression: 4.2 `f` 0 / 0
08:35:57 <lambdabot>      In the first argument of ‘map’, namely ‘(\ f -> 4.2 `f` 0 / 0)’
08:36:06 <Xnuk> > map (\f -> 4.2 `f` (0/0)) [(>), (>=), (==), (<=), (<)]
08:36:09 <lambdabot>  [False,False,False,False,False]
08:36:28 * hackagebot eventsourced 1.0.0.0 - Server-Sent Events the UNIX way  https://hackage.haskell.org/package/eventsourced-1.0.0.0 (richardTowers)
08:50:00 <dcoutts> jle`: btw the new nix-style cabal tech preview (in cabal-1.24) shares all built packages between projects (in any configuration, irrespective of whether they are part of a collection or not)
08:51:42 <{AS}> Xnuk: interesting
08:52:14 <{AS}> > any (\f -> 4.2 `f` 0/0) [(>), (>=), (==), (<=), (<)]
08:52:15 <lambdabot>      No instance for (Fractional Bool) arising from a use of ‘/’
08:52:15 <lambdabot>      In the expression: 4.2 `f` 0 / 0
08:52:15 <lambdabot>      In the first argument of ‘any’, namely ‘(\ f -> 4.2 `f` 0 / 0)’
08:52:31 <{AS}> > any (\f -> 4.2 `f` (0/0)) [(>), (>=), (==), (<=), (<)]
08:52:33 <lambdabot>  False
08:57:31 <Lovepon> {AS}: Heck...
08:57:40 <Lovepon> > (0/0) == (0/0)
08:57:41 <lambdabot>  False
08:58:28 * geekosaur suspects that's hardcoded, since IEEE floating point specifies that NaN is not equal to or comparable to anything including itself
08:58:50 <ggVGc> what's the best way to write something like this using Seq? https://gist.github.com/d95e3648d733bfe193bd97dd0336aebd
08:58:55 <{AS}> > Refl :: (0/0) :~: (0/0)
08:58:57 <lambdabot>  Not in scope: type constructor or class ‘/’Not in scope: type constructor or...
08:59:04 <ggVGc> it really sucks how lists are the only ting with nice pattern matching syntax
08:59:32 <{AS}> ggVGc: using foldLeft?
08:59:37 <{AS}> sorry
08:59:38 <{AS}> list
08:59:39 <geekosaur> get someone to add patsyns to Data.Sequence? p
08:59:40 <{AS}> > :t list
08:59:41 <geekosaur> :p
08:59:41 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:59:44 <{AS}> :t list
08:59:45 <lambdabot>     Not in scope: ‘list’
08:59:46 <lambdabot>     Perhaps you meant one of these:
08:59:46 <lambdabot>       ‘last’ (imported from Data.List),
09:00:20 <monochrom> ggVGc: use viewL or viewR.
09:01:12 <{AS}> sorry
09:01:18 <{AS}> I thought there was a function for it
09:01:41 <monochrom> list has nice pattern matching at the price of costly "viewR"
09:01:52 <jedai> ggVGc: viewPatterns are quite nice
09:04:09 <monochrom> similarly, Data.Map has minView, maxView, and splitLookup
09:04:09 <ggVGc> monochrom: where can I read how to use viewL and viewR
09:04:12 <ggVGc> views are completely new to me
09:04:28 <monochrom> eh? they are functions in Data.Sequence. read the doc.
09:05:09 <ggVGc> ah, okay, together with viewpatterns then
09:05:11 <monochrom> unless you're saying I had typos. viewl and viewr
09:05:35 <monochrom> I wouldn't even worry about view patterns. only marginally "nicer".
09:06:16 <ggVGc> monochrom: what I don't compeltely get is how to use the data type viewL usefully without pattern matching on it
09:06:29 * hackagebot casr-logbook 0.0.6 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.0.6 (TonyMorris)
09:06:46 <monochrom> I thought you wanted to pattern-match on something.
09:07:12 <monochrom> so, last call: what is your real, complete requirement?
09:07:38 <ggVGc> wait, I need to experiment. I thought I would need viewpatterns for that
09:09:12 <monochrom> ok, so an opague neural-network requirement that can't be explicated, just like Data.Sequence an opague data type that can't be pattern-matched.
09:10:00 <puregreen> (opague?)
09:10:00 <monochrom> isn't it interesting that the two best things in the world have to remain opague?
09:10:17 <monochrom> yes, opague.
09:10:34 * puregreen gets curious
09:10:54 <monochrom> ok, spelling error. opaque
09:11:55 <puregreen> I was already wondering whether it was a portmanteau I haven't heard of
09:12:22 <ggVGc> monochrom: sorry I just got confused for a bit mixing up operators/functions with constructors
09:12:25 <Clint> puregreen: it is now
09:12:49 <ggVGc> I thought I couldn't do, head :< rest = viewl seq
09:12:56 <ggVGc> hence why I got into viewpatterns
09:13:57 <angryShiva> am i too late?
09:15:05 <angryShiva> Sup!
09:21:29 * hackagebot process-extras 0.3.4 - Process extras  https://hackage.haskell.org/package/process-extras-0.3.4 (DavidFox)
09:46:31 * hackagebot JuicyPixels-repa 0.7.1.0 - Convenience functions to obtain array representations of images.  https://hackage.haskell.org/package/JuicyPixels-repa-0.7.1.0 (ThomasDuBuisson)
09:51:51 <nmdanny> @udo
09:51:52 <lambdabot> Maybe you meant: undo do
09:51:54 <nmdanny> @undo
09:51:54 <lambdabot> Error: expected a Haskell expression or declaration
09:51:59 <nmdanny> @undo do     users <- runDb (selectList [] [])     let people = map (userToPerson . entityVal) users     return people
09:51:59 <lambdabot> <unknown>.hs: 1: 46:Parse error: Last statement in a do-block must be an expression
09:52:10 <nmdanny> @undo do    { users <- runDb (selectList [] [])  ;    let people = map (userToPerson . entityVal) users     ; return people }
09:52:11 <lambdabot> <unknown>.hs: 1: 119:Parse error: }
09:52:23 <nmdanny> @undo do { users <- runDb (selectList [] []) ;  let people = map (userToPerson . entityVal) users  ; return people  }
09:52:24 <lambdabot> <unknown>.hs: 1: 111:Parse error: }
09:52:28 <nmdanny> @undo { users <- runDb (selectList [] []) ;  let people = map (userToPerson . entityVal) users  ; return people  }
09:52:29 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
09:52:45 <nmdanny> @undo  users <- runDb (selectList [] []) ;  let people = map (userToPerson . entityVal) users  ; return people  
09:52:45 <lambdabot> <unknown>.hs: 1: 7:Parse error: <-
09:52:54 <nmdanny> @undo do  users <- runDb (selectList [] []) ;  let people = map (userToPerson . entityVal) users  ; return people  
09:52:55 <lambdabot> <unknown>.hs: 1: 110:Parse error: EOF
09:53:04 <xa0> bad day?
09:53:50 <angryShiva> wait, what's lambdabot?
09:53:54 <nmdanny> @undo do users <- runDb (selectList []); let people = map (entityVal) users; return people
09:53:54 <lambdabot> <unknown>.hs: 1: 85:Parse error: EOF
09:53:56 <nmdanny> @undo do users <- runDb (selectList []); let people = map (entityVal) users; return people 
09:53:57 <lambdabot> <unknown>.hs: 1: 86:Parse error: EOF
09:54:01 <nmdanny> ugh why is it not working
09:54:41 <angryShiva> nmdanny, mind helping me out?
09:54:52 <larryba> @undo do line <- getLine; putStrLn line
09:54:53 <lambdabot> getLine >>= \ line -> putStrLn line
09:55:14 <angryShiva>  @undo do line <- getLine; putStrLn line
09:55:17 <nmdanny> lambdabot is an IRC bot that can do useful things on IRC, kinda like a GHCI
09:55:47 <angryShiva> sweet! Does it take pure haskell expressions or?
09:55:54 <nmdanny> @undo do users <- runDb;  let realUsers = fmap entityVal users; return users 
09:55:54 <lambdabot> <unknown>.hs: 1: 72:Parse error: EOF
09:55:56 <xa0> > 1
09:55:58 <lambdabot>  1
09:56:05 <nmdanny> > putStrLn "Hello"
09:56:06 <hexagoxel> @undo do users <- runDb (selectList []); let { people = map (entityVal) users}; return people
09:56:06 <lambdabot> runDb (selectList []) >>= \ users -> let { people = map (entityVal) users} in return people
09:56:06 <lambdabot>  <IO ()>
09:56:10 <hexagoxel> nmdanny: ^
09:56:15 <nmdanny> thanks
09:56:35 <hexagoxel> nmdanny: it gets confused between different do- and let-statements.
09:56:50 <nmdanny> @pl
09:56:51 <lambdabot> (line 1, column 1):
09:56:51 <lambdabot> unexpected end of input
09:56:51 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:56:53 <hexagoxel> nmdanny: (also, you can /query lambdabot)
09:56:57 <nmdanny> @pl runDb (selectList []) >>= \ users -> let { people = map (entityVal) users} in return people
09:56:57 <lambdabot> (line 1, column 42):
09:56:57 <lambdabot> unexpected "{"
09:56:57 <lambdabot> expecting "()", natural, identifier or "in"
09:57:12 <angryShiva> thanks hexagoxel!
09:58:40 <hexagoxel> @pl runDb (selectList []) >>= \ users -> let people = map (entityVal) users in return people
09:58:40 <lambdabot> map entityVal `fmap` runDb (selectList [])
09:58:54 <hexagoxel> the `in` makes it non-ambiguous again.
09:59:24 <hexagoxel> (and apparently @pl's parser is too weak for {})
10:00:13 <nmdanny> anyway... does anyone know how to use servant by any chance?
10:01:32 <tippenein> nmdanny: in what way? Did this not help? https://haskell-servant.github.io/tutorial/
10:01:35 <sm_> yes, and they wrote it down :)
10:01:45 <sm_> sorry
10:02:36 <nmdanny> ok I have a question, is there a library or something for using OAuth with servant?
10:06:41 <tippenein> nmdanny: this should be informative: https://github.com/haskell-servant/servant/issues/70
10:07:03 <tippenein> You can ask in #servant as well. I'm not that up to date on servant's progress
10:08:48 <nmdanny> hmm from what it looks like, they have basic auth but more advanced stuff isnt quite ready
10:20:57 <puregreen> how can I write a const that accepts an unboxed type?
10:21:02 <puregreen> const :: a -> # -> a
10:27:36 <DangerousDave> Hello, is there any difference between <- and elem?
10:27:44 <DangerousDave> when in list comprehension
10:28:25 <sm_> DangerousDave: yes
10:28:31 <sm_> they are completely different things
10:29:05 <DangerousDave> Can you explain me the difference or give me a reference to an explaination? because google doesn't help me with that issue
10:29:50 <sm_> look for elem in http://haskell.org/hoogle, and "list comprehensions
10:29:59 <sm_> " (<-) in the haskell report
10:30:41 <sm_> elem is a function provided by Data.List, while <- ishaskell syntax
10:31:27 <DangerousDave> I had a function where <- didn't worked as expected
10:31:33 <sm_> surprisingly, <- is in hoogle too. https://www.haskell.org/hoogle/?hoogle=%3C-
10:31:47 <sm_> DangerousDave: you too, eh
10:32:37 <DangerousDave> well, probably.
10:32:41 * ski idly wonders whether DangerousDave has used a logic programming language before, like Prolog
10:33:30 <ski> `elem' is for *checking* whether a given value is an element of a list. `<-' in a list comprehension is for *enumerating* all the element values in a list
10:33:52 <ski> in the first case, both an element and a list is input, and the result is a success/failure indication
10:34:10 <geekosaur> DangerousDave, in some sense <- and elem are conceptually similar but work in opposite directions. <- takes elements from something, elem finds elements in something. but <- is not general, whereas elem is; <- is syntax telling a list comprehension what list(s) to operate on
10:34:23 <ski> in the second case, only the list is input, and the element is output. and you get repeated outputs, for as many elements you have in the list
10:35:26 <ski> (in Prolog, both of these operations would be done by calling the standard predicate member/2. in the first case, calling it with the list argument known, and the element argument known. in the second case, calling it with the list argument known, and the element argument unknown)
10:38:34 <ski> (other possible terms for "known" here are "initialized" and "instantiated")
10:39:32 <DangerousDave> So the seperators are as logical or in this case?
10:39:35 <nmdanny> question regarding persistent: if I define a field as nullable(maybe), and give it a default value, will it be null by default or will it have the default value?
10:39:48 <ski> DangerousDave : "separators" ?
10:40:29 <ski> perhaps you're talking about `|' or `,', in a list comprehension ?
10:40:31 <ski> or `<-' ?
10:42:05 <DangerousDave> because lets say I have a = [(1,2),(4,5)] and [(x,y)|(x,y)<-a, x<-[1,4,6], y<-[2,5,7]]
10:42:15 <DangerousDave> I dont understand why do I get (6,7) in that case
10:43:53 <ski> > [(x,y) | let a = [(1,2),(4,5)],(x,y) <- a,x <- [1,4,6],y <- [2,5,7]]
10:43:55 <lambdabot>  [(1,2),(1,5),(1,7),(4,2),(4,5),(4,7),(6,2),(6,5),(6,7),(1,2),(1,5),(1,7),(4,...
10:43:56 <ski> is the same as
10:44:01 <ski> > [(x,y) | let a = [(1,2),(4,5)],_ <- a,x <- [1,4,6],y <- [2,5,7]]
10:44:02 <lambdabot>  [(1,2),(1,5),(1,7),(4,2),(4,5),(4,7),(6,2),(6,5),(6,7),(1,2),(1,5),(1,7),(4,...
10:44:19 <ski> iow, your latter two `x' and `y' are unrelated to the former two
10:44:33 <ski> DangerousDave : ok ?
10:45:46 <DangerousDave> isn't it like mathematical s.t?
10:45:49 <DangerousDave> such that
10:46:02 <DangerousDave> and the ',' are and operator?
10:46:40 <ski> `,' in list comprehension is "and", yes
10:46:50 <ski> and `|' is like "such that", yes
10:47:04 <DangerousDave> so how can it be I get element that (x,y) is not in a
10:47:25 <ski> however, each time you use `<-', what goes to the left of it is a pattern. every variable that you mention in the pattern is a new/fresh variable, distinct from earlier ones
10:48:08 <ski> > [x | x <- [0 .. 3],x <- [0 .. x]]
10:48:10 <lambdabot>  [0,0,1,0,1,2,0,1,2,3]
10:48:13 <ski> is the same as
10:48:20 <ski> > [x1 | x0 <- [0 .. 3],x1 <- [0 .. x0]]
10:48:21 <lambdabot>  [0,0,1,0,1,2,0,1,2,3]
10:48:22 <ski> ok ?
10:48:57 <ski> if you really wanted to make sure that the latter `x' and `y' were equal to the former ones, use `==' explicitly
10:49:01 <ski> in this example
10:49:07 <ski> > [x1 | x0 <- [0 .. 3],x1 <- [0 .. x0],x0 == x1]
10:49:09 <lambdabot>  [0,1,2,3]
10:49:40 <ski> > [(x,y) | let a = [(1,2),(4,5)],(x0,y0) <- a,x1 <- [1,4,6],x0 == x1,y1 <- [2,5,7],y0 == y1]  -- in your case
10:49:42 <lambdabot>  [(x,y),(x,y)]
10:49:52 <ski> er, right, forgot to rename the first part
10:49:56 <ski> > [(x1,y1) | let a = [(1,2),(4,5)],(x0,y0) <- a,x1 <- [1,4,6],x0 == x1,y1 <- [2,5,7],y0 == y1]  -- in your case
10:49:58 <lambdabot>  [(1,2),(4,5)]
10:50:03 <ski> there you go
10:50:06 <DangerousDave> I ment t hat the a is outsite of the list comprehension
10:50:14 <DangerousDave> but its kind of the same i guess
10:50:18 <ski> DangerousDave : yes, but it doesn't matter
10:50:45 <DangerousDave> Ohhhh OK
10:50:59 <DangerousDave> I think that I understand now
10:51:03 <akegalj> what is List.nub complexity ?
10:51:04 <ski> good
10:51:11 <ski> akegalj : quadratic. has to be
10:51:17 <akegalj> ski: thnx
10:51:25 <ski> it uses `Eq', not `Ord'
10:51:42 <ski> so it has to compare each pair of elements at distinct positions in the list
10:54:12 <akegalj> ski: yep, thnx
11:11:33 * hackagebot Obsidian 0.4.0.0 - Embedded language for GPU Programming  https://hackage.haskell.org/package/Obsidian-0.4.0.0 (JoelSvensson)
11:19:19 <nmdanny> how would I do the following: given a persistent entity, how would I expose only certain fields when GETting the entity, and only require certain entities when POSTting the entity?
11:19:58 <nmdanny> for example, I have the following entity: User json    name Text       password Text      createDate UTCTime default=CURRENT_DATE       UniqueEmail email       deriving show
11:20:41 <nmdanny> I want to make it so when a user sends a GET request, he won't get the password field,
11:20:48 <nmdanny> and when a user makes a POST request, he won't have to fill the createDate
11:20:59 <Rotaerk> hmm someone in here was telling me that host names are defined as byte strings, not character strings
11:21:13 <Rotaerk> still haven't been able to corroborate that notion
11:22:07 <geekosaur> I concluded we are using different definitions of character string
11:22:14 <geekosaur> you seem to believe byte string = numeric data
11:22:24 <geekosaur> that is, "word string"
11:22:34 <geekosaur> well, that's confusing too, feh
11:23:46 <geekosaur> Haskell's ByteString type is mapped to Internet RFC octet strings. Octet strings do not define a representation; they could be numeric (ip address), textual (DNS host labels), etc.
11:24:26 <Rotaerk> geekosaur, characters are things like a, b, c... there's no inherent way to represent them in memory; they're a concept
11:24:38 <geekosaur> Rotaerk, true but pointless
11:24:41 <Rotaerk> you can encode them in memory using ASCII, UTF-8, UTF-16, etc
11:24:52 <geekosaur> if we do not define a common encoding, we can't exchange them usefully
11:25:11 <Rotaerk> does the haskell Char type define an encoding? or is it just the conceptual character
11:25:25 <geekosaur> Char is a Unicode codepoint
11:25:35 <geekosaur> representation of that is not defined, semantic meaning is
11:25:53 <Rotaerk> okay, well that's the level at which hostnames are meaningful to people
11:26:03 <Rotaerk> I don't know or care how "haskell.org" is represented in bytes
11:26:12 <Rotaerk> I just care about the sequence of characters
11:26:29 <Rotaerk> to get it to bytes though, I need to know which encoding is expected
11:26:36 <geekosaur> so maybe thats the problem. you may not care how it is represented in bytes on some level, but resolvers leak that information into their API so you are forced to deal with it
11:26:59 <Rotaerk> the API should either take these conceptual characters, and convert them to an encoding that they need
11:27:08 <Rotaerk> or they should take a ByteString an explicitly specify an encoding that they expect
11:27:11 <Rotaerk> and *
11:27:15 <geekosaur> (browsers being a notable exception, since these days they are almost certain to handle punycode; the libc resolver interface usually doesn't)
11:27:27 <Rotaerk> if you take a bytestring, how do I know if I'm to provide you ASCII, UTF8, etc
11:28:56 <Rotaerk> geekosaur, maybe a concrete example would help.  Given this library, look for the tlsClientConfig function:  https://hackage.haskell.org/package/network-conduit-tls-1.2.2/docs/Data-Conduit-Network-TLS.html
11:29:12 <Rotaerk> geekosaur, this takes a host as a ByteString
11:29:19 <Rotaerk> how do I pass "haskell.org" to that
11:29:38 <geekosaur> it's part of the API description. the Domain Name System specifies a subset of ASCII as its API (note that the DNS protocol itself does not require this; it's effectively a social contract for participation in the Internet)
11:30:06 <geekosaur> s/as its/in its/
11:31:07 <Rotaerk> could you point me to the RFC or whatever that specifies DNS names are inherently a subset of ascii
11:31:09 <geekosaur> ...so am I to understand now that your issue is that Internet APIs are not strongly typed but instead rely on "social contract" RFCs to define that?
11:32:08 <simpson> It's an important issue; it's *the* reason why I don't use statically-typed languages to model interactions over the network.
11:32:14 <geekosaur> https://tools.ietf.org/html/rfc1123#page-13 https://tools.ietf.org/html/rfc952
11:32:34 <simpson> But I'm not sure where this conversation's headed.
11:32:56 <Rotaerk> 952 doesn't specify that host names are ASCII; i've seen that one before
11:32:59 <Rotaerk> looking at 1123...
11:33:40 <geekosaur> no, it doesn't specify it directly, you have to dig deeper to understand that they do not mean a conceptual 0-9 A-Z that you can choose for yourself
11:33:49 <geekosaur> btu if I have to say that, something serious is wrong somewhere
11:34:06 <Rotaerk> err, if it's not specified directly, then it's not specified
11:34:13 <Rotaerk> how do you "dig deeper"?
11:34:34 <Rotaerk> a specification is supposed to explicitly delineate what's expected/allowed in an interface
11:35:25 <geekosaur> https://tools.ietf.org/html/rfc20
11:36:14 <geekosaur> the specification does. where the specification is *the entire set of RFCs*, which do not explicitly refer to each other because it would become too unwieldy. there are certain base RFCs which are assumed by all the rest
11:36:42 <Rotaerk> didn't realize the RFCs were related to one another
11:36:58 <Rotaerk> thought they were just a bunch of ad-hoc standards for a variety of things
11:37:05 <geekosaur> ...how in the world do you even have a coherent network if they don't?
11:37:29 <Rotaerk> actually, I didn't know there was an overall theme for RFCs
11:37:33 <Rotaerk> overall purpose
11:37:42 <geekosaur> admittedly, this is somewhat difficult because the early RFCs were very ad hoc, not a formal standard
11:38:26 <geekosaur> so in some sense rfc20 that I just linked was a patchup because the preceding RFCs had been blithely talking about characters in network protocols without defining what a character was
11:39:23 <Rotaerk> so, anyway, assuming the expected encoding for host names is 7-bit ASCII, why does that network-conduit-tls library decode the bytestring using ByteString.Char8
11:39:35 <Rotaerk> which is defined as codepoints 0-255 of Unicode
11:39:47 <Rotaerk> not as 7-bit ascii
11:40:03 <Rotaerk> it'll end up accepting more characters than ASCII supports
11:40:08 <Rotaerk> err 7-bit ASCII*
11:40:10 <geekosaur> because Haskell doesn't have either a 7-bit type or a subset type restricted to ASCII?
11:40:39 <puregreen> is there a good implementation of mapWithIndex (for lists) anywhere? specifically I'm trying to understand how to make it play well with fusion and so on
11:40:49 <geekosaur> and because Internet protocols are defined in terms of octets (8-bit values) and octet strings, not 7-bit values
11:41:36 <Rotaerk> hmm in RFC 952, it refers to octets as the up-to-3-character number-string in an IP address
11:42:09 <Rotaerk> octet.octet.octet.octet
11:42:38 <geekosaur> and, having seen that, you are reading it as the only meaning of octet?
11:42:47 <Rotaerk> the only meaning within the context of RFC
11:42:53 <geekosaur> I understand it the other way around, it's not defining octet, it's defining IP address in terms of octet
11:44:12 <geekosaur> but at this point I'm feeling rather like I have been cozened into being a dedicated search engine. RFCs are online
11:44:16 <monochrom> I would modestly narrow that down to "within the context of RFC 952", tautologically.
11:44:35 <geekosaur> and Rotaerk already said they consider eeach RFC to be independent
11:44:35 <monochrom> (The disease with most humans is they try so hard to violate tautologies.)
11:44:40 <bbear> hello hanoi :: Integer -> Peg -> Peg -> Peg -> [Move]
11:44:41 <bbear> hanoi 0 _ _ _ = []
11:44:41 <bbear> hanoi n a b c = hanoi (n-1) a c b ++ [(a,b)] ++ hanoi (n-1) c b a
11:44:41 <geekosaur> I'm not sure there's a point here any more
11:44:54 <Rotaerk> I just thought RFCs were some generic format for standards
11:44:58 <bbear> Why  is this working ?
11:44:59 <Rotaerk> I didn't realize they were from IETF
11:45:06 <bbear> I don't understand it at all.
11:45:07 <Rotaerk> and thus they had an overarching purpose
11:45:15 <geekosaur> in any case I'm through playing search engine
11:45:24 <Rotaerk> pretty sure I wasn't using you as search engine
11:45:40 <Rotaerk> I still don't buy the notion that it should be ByteString
11:45:44 <monochrom> geekosaur: and so I have gone to playing tautology engine instead :)
11:48:06 <monochrom> bbear: one thing you can do is to take out 8 discs and play with them physically. that shows you one angle of it. there are other learning activities and reasoning to see other angles. all angles are necessary for a full understanding.
11:48:21 <Rotaerk> if "octet" is allowed to be defined in RFC 952 but the definition is only for the scope of that particular RFC
11:48:40 <Rotaerk> then RFC 20 can't define "character" and automatically apply to all RFCs
11:48:42 <monochrom> indeed, sometimes when I'm in a boring meeting, I take out coins and starting playing Towers of Hanoi
11:48:58 <Rotaerk> RFC 20's definition of character doesn't necessarily apply to RFC 952's usage of "character"
11:48:59 <geekosaur> Rotaerk, I was trying to say you had that backwards
11:49:23 <geekosaur> you appear to have rejected that in favor of uyour prefered "this is a local definition of octet, not a definition of IP address in terms of octets:
11:50:14 <davean> Rotaerk: Interestingly we have a litteral authority on that subject - the IETF. The way their standards work is however they specify is the correct way to interprit them.
11:50:31 <Rotaerk> they specify how to interpret them?
11:50:35 <davean> Yes
11:50:40 <davean> Thats another RFC
11:50:44 <Rotaerk> I see
11:51:22 <davean> actually several others
11:51:22 <geekosaur> heh, if I'm reading STD1 right, they gave up on recasting RFCs as STDs in 2008
11:52:01 <Rotaerk> so basically, the answer to my main question of ... how the hell to use ByteString, when I'm familiar with host names as being strings
11:52:10 <Rotaerk> is that I should encode the string using 7-bit ASCII
11:52:12 <Rotaerk> simple as that
11:53:13 <monochrom> bbear: The reasoning angle is this. Suppose you ask me to move 8 discs from A to B, and allow me to use C for buffer. I'm going to solve the slightly different subproblem first: move 7 discs from A to C, pretend B is the buffer this time. (Don't worry about how for now.) If I get this subproblem done, then I can move the 8th disc from A to B. Then I have one last subproblem to solve: move 7 discs from C to B, pretend A is the buffer this time.
11:53:24 <monochrom> But you should still play it out physically.
11:53:28 <fr33domlover> Q: In Yesod, should forms insert to the database? e.g. I have entities which hold foreign keys to other entities, and I have to either insert some dummy value there or insert in the MForm itself...
11:53:48 <ipweb25> http://espedito.homepc.it OnePostX...)
11:53:49 <fr33domlover> s/insert dummy/pass dummy
11:56:12 <monochrom> Rotaerk: are you proposing that the right way to send my nickname, "monochrom", is to send the string "109.111.110.111.99.104.114.111.109"?
11:57:06 <Rotaerk> monochrom, no, you just converted a character string to another character string in an octet-dot-octet format
11:57:12 <Rotaerk> neither of those are encodings
11:57:18 <Rotaerk> to byte strings, that is
11:57:49 <monochrom> ok, I am cool with further encoding "109.111.110.111.99.104.114.111.109" by 7-bit ASCII.
11:58:11 <monochrom> i.e., the sequence of numbers 49,48,57,46,49,49,49,46,49,49,48,46,49,49,49,46,57,57,46,49,48,52,46,49,49,52,46,49,49,49,46,49,48,57
11:58:12 <davean> monochrom: Are you cool if I then Base64 encode that?
11:58:18 <Rotaerk> monochrom, not sure why you would do that
11:58:30 <davean> monochrom: and then UCS encode that?
11:58:31 <Rotaerk> monochrom, that is how IP addresses are done though, as I understand it
11:58:35 <monochrom> yes! base64 is still 7-bit, in fact 6-bit, even better
11:58:37 <Rotaerk> but not sure why you would do that with your username
11:58:52 <monochrom> NOW WHERE IS THE 6-BIT TYPE I NEED IN HASKELL?!
11:59:06 <davean> monochrom: one sec, writing template haskell to generte it for oyu
11:59:09 <Rotaerk> IP addresses are conceptually 4 bytes, but are encoded in up to 15 bytes, apparently
11:59:15 <bbear> monochrom: yes, what is fascinating is the fact that you assume bluntly that this problem is solvable and let the computer do the work.
11:59:44 <davean> monochrom: Do you want it as an instance of Num, or does that not make sense? :)
11:59:53 <monochrom> bbear: Recursion and induction are fascinating, isn't it? To sum up 10 numbers, just sum up 9 numbers, then plus the 10th.
12:00:38 <monochrom> This is ok as long as you can prove that the recursion terminates, so that "I assume the smaller problem can be solved" has ground. But that's all.
12:00:49 <davean> monochrom: oh actually we have TypeNat now, we can make a type with any number of bits! And use Paeno encoding at the value level.
12:02:05 <Rotaerk> I still object to the use of ByteString because this is a haskell API; it's not the internet; the fact that the host name is being sent to the internet is an implementation detail, and so detail of the encoding (7-bit ascii) should not be exposed through the public interface
12:02:26 <davean> Rotaerk: Unicode?
12:02:33 <davean> Rotaerk: I assure you "String" is very wrong
12:02:48 <Rotaerk> davean, hmm what do you mean?
12:03:02 <Rotaerk> wrong about what?
12:03:28 <monochrom> Rotaerk: talking about the internet, the real and physical Internet out there, I haven't seen a 7-bit medium out there for a long, long time. All I see is 8-bit.
12:03:40 <Jinxit> what's a good tool for "compiling" one AST to another? Writer? State? (compilation needs to track some state)
12:03:47 <Rotaerk> monochrom, it specifies 7-bit ascii, with an 8th bit always set to 0
12:04:04 <Rotaerk> in that RFC 20
12:04:09 <monochrom> And the only time I really saw an 7-bit medium was between a server and a terminal. Not internet at all.
12:04:24 <monochrom> ok, so that's 8-bit. 7+1 = 8, no?
12:04:47 <Rotaerk> is there a better way to refer to this to distinguish it from full ASCII with all 8 bits being used?
12:04:53 <bbear> I don't get the subtility directly. Yes, I am going to build a hanoi game. Yes, with coins it is easy as well.
12:05:26 <davean> Rotaerk: DNS doesn't work on the unencoded value
12:05:37 <davean> Rotaerk: if you use a String interface, there will be domain names you can't look up
12:05:58 <monochrom> bbear: with coins, I still do the recursive scheme. it's of course a bit difficult, I maintain a call stack in my head. yes, there are times I lose my call stack, i.e., "ok, why was I doing this?"
12:06:17 <davean> Rotaerk: for example, if you choose punycode to encoe Unicode chars, you can't look up domains that are UTF-8 encoded
12:06:32 <davean> Rotaerk: if you pick UTF-8, you can't look up domains that are punycode encoded
12:06:38 <Rotaerk> davean, hmm are you saying that not all the characters in the lower 7 bits of ASCII exist in UTF?
12:06:44 <Rotaerk> err Unicode
12:07:01 <davean> Rotaerk: no ..
12:07:04 <bbear> Trying to do that. With three disks, the recursive stack is not that big (that's brain improvement for you :).
12:07:05 * davean gives up
12:07:33 <Rotaerk> davean, could you give an example of a domain name that can't be looked up through a String interface?
12:08:22 <Rotaerk> isn't punycode just a format for encoding non-ascii characters in ascii?
12:08:26 <davean> Rotaerk: I can give you 2 domains, of which (without special casing them) you couldn't look up *both*
12:08:37 <Rotaerk> such as?
12:09:08 <ski> monochrom : fwiw, i figured out an iterative solution to towers of hanoi, long before i heard of the recursive one
12:09:16 <davean> рф.com and ชื่อไทย.คอม
12:09:28 <davean> Rotaerk: you'll only be able to look up one of those without special cases
12:09:39 <davean> the first has to be punyencoded, the second IDN encoded
12:09:46 <davean> Thus you *can not use a string interface*
12:09:48 <monochrom> bbear: I read a fun story of abusing time travel from a cartoon/anime. I have homework due at 9AM, and it's midnight now. I have a cunning plan! I use time travel to snatch the 2AM version of me, the 4AM version of me, and the 6AM version of me to midnight. With the 4 of us working together, we get it done at 1AM. Great! And we can all go back to sleep now.
12:09:51 <Rotaerk> davean, рф.com isn't a valid domain name according to RFC 952 though
12:10:25 <davean> Rotaerk: look at the top of the RFC ...
12:10:28 <monochrom> But just after one hour of sleep, at 2AM, I'm waken up by some bastard to do his homework for 1 hour.
12:10:29 <Rotaerk> you could encode it with punycode to xn--p1ai.com
12:10:41 <Rotaerk> which would be a valid domain name
12:10:44 <ggVGc> I currently generate a very long list which has a lot of holes in it and later on traverse it linearly acting on each index that isn't empty. I'm thinking I should change this to either a Map or a [(Int, a)]. Which would be better?
12:10:48 <monochrom> Then at 4AM, I'm waken up again by another bastard to do his homework for 1 hour.
12:10:50 <davean> Rotaerk: thats why you can't use a string interface, you've found it
12:10:57 <monochrom> Then at 6AM, I'm waken up again by yet another bastard to do his homework for 1 hour.
12:11:02 <Rotaerk> davean, err, I don't get it; why not?
12:11:04 <monochrom> This is recursion.
12:11:18 <Rotaerk> davean, you can represent xn--p1ai.com using a string
12:11:19 <davean> Rotaerk: I've explained it several times now
12:11:21 <monochrom> But at least it gets done after 3 recursive calls or something.
12:12:09 <monochrom> ski: I think you're smart. I only understand recursion.
12:12:11 <dolio> monochrom: Should have traveled to the following afternoon.
12:12:18 <Rotaerk> davean, every valid domain name that can be represented using the lower 7 bits of ascii... can be represented with a string, can't it?
12:12:49 <Rotaerk> haskell String is a superset of the set of valid domains
12:13:10 <Rotaerk> there are certainly String values that aren't valid domains, but the ones that are valid, are all representable as Strings
12:14:53 <Rotaerk> you gave these examples:  рф.com and ชื่อไทย.คอม
12:15:11 <Rotaerk> those are just: xn--p1ai.com  and  xn--b3c0a7a4b9b8d0a.xn--42c2d9a
12:15:17 <Rotaerk> both representable as strings
12:15:23 <Rotaerk> and thus you can look them both up with a string interface
12:15:56 <davean> Nope!
12:15:59 <davean> They aren't
12:16:03 <davean> You're wrong about the second
12:16:18 <Rotaerk> I just pasted the second one into https://www.charset.org/punycode.php
12:16:19 <monochrom> Food for thought: why are octets in decimal, not octal?
12:16:31 <davean> Rotaerk: yep, and punycode isn't a valid encoding for it, as I said
12:16:32 <Rotaerk> and xn--b3c0a7a4b9b8d0a.xn--42c2d9a  is what it spat out
12:16:40 <davean> Rotaerk: you did the wrong thing
12:16:44 <davean> That won't get you the domain
12:17:01 <dolio> monochrom: Because 8 isn't divisible by 3.
12:17:16 <Rotaerk> davean, oh just noticed you said something above that I missed
12:17:20 <davean> Rotaerk: Go read the RFCs
12:17:22 <Rotaerk> "the first has to be punyencoded, the second IDN encoded"
12:17:29 <Rotaerk> I'm not familiar with IDN
12:17:58 <Rotaerk> http://idn-encoding.online-domain-tools.com/  this gave me:
12:18:02 <Rotaerk> xn--b3c0a7a4b9b8d0a.xn--42c2d9a
12:18:23 <monochrom> dolio, but 8 is not divisible by log_2 10 either
12:18:23 <Rotaerk> hrm..
12:18:49 <monochrom> but anyway it's a joke
12:19:02 <dolio> Right, but everyone's accustomed to decimal, so if you pick something else it actually needs to be better. :)
12:19:11 <monochrom> oh haha yes true
12:19:57 <monochrom> Next food for thought: why are octets in base 10, not base 10? :)
12:20:31 <Rotaerk> davean, so are you saying that in order to convert from a human-readable domain name to a ByteString, it's *not* as simple as just converting to lower-128-bit ASCII?
12:20:38 <monochrom> oh I need to add that comic to my tautology page
12:20:45 <Rotaerk> I have to do a variety of encodings based
12:20:56 <Rotaerk> err based on what characters are in the name
12:21:00 <monochrom> wait, we have inflated from 7-bit ASCII to 128-bit ASCII?
12:21:14 <Rotaerk> err lower-128-character
12:21:21 <davean> Rotaerk: thats when DNS is even in 7-bit ascii, check the other RFCs ...
12:21:23 <monochrom> "128 bits ought to be enough for everyone"
12:21:48 <davean> as I said, look at the top of that RFC
12:21:48 <Rotaerk> davean, you're saying there are RFCs that override 952's definition of host name?
12:22:10 <monochrom> and I'm going to put it as tautology #10 :)
12:22:10 <Rotaerk> ah, updated by 1123
12:22:57 <Rotaerk> well, reading through all the RFCs is going to take me literally a year or more
12:23:08 <Rotaerk> do I really have to know all this just to know how to provide a hostname to the network libraries?
12:23:28 <Rotaerk> isn't there something that handles mapping human-readable strings to byte strings?
12:23:53 <Rotaerk> using whatever encodings are needed according to all these RFCs
12:24:43 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #10 :)
12:28:08 <m-renaud> Hey, I was wondering if someone could take a quick look at a simple parser I have that's leaking memory and taking a long time. - http://lpaste.net/163340
12:28:15 <m-renaud> Profiling output included in paste.
12:30:09 <puregreen> m-renaud: doesn't attoparsec retain all of its input? (because of possible backtracking)
12:30:48 <m-renaud> Yes it does, but it's using >200M when the input is ~19M
12:33:04 <monochrom> That is likely explainable by simply "that's what you get for []"
12:33:46 <monochrom> which cons cell takes 24 bytes. this is just the cons cell. I haven't counted the actual data.
12:33:52 <monochrom> s/which/each/
12:34:30 <m-renaud> I wish that `count` could build something more efficient. I have a version that immediately converts it to Sequence, but no improvement
12:34:49 <m-renaud> countSeq n p = Seq.fromList <$> count n p
12:34:49 <monochrom> 24 comes from these: 8 bytes for pointer to data, 8 bytes for pointer to "next", and 8 bytes for a representation of (:), i.e., the constructor
12:35:12 <Rotaerk> hmm, there doesn't seem to be haskell libraries for encoding host names as byte strings...
12:35:21 <Rotaerk> everyone seems to just be packing them using ByteString.Char8
12:35:21 <monochrom> and there are several reasons why they're all 8 bytes. one of them is "better alignment". but there are more.
12:35:32 <m-renaud> monochrom: Mhmm, that makes sense.
12:35:32 <Rotaerk> which can't possible handle all the subtle details of the RFCs
12:36:01 <m-renaud> There has to be a more efficient way of parsing a bunch of doubles
12:36:13 <monochrom> There is one more factor on top of that, causing memory footprint to be twice as much as "24 bytes per cons cell"
12:36:36 <monochrom> i.e., if you have a list of length 10M, sometimes you see 480MB rather than 240MB.
12:37:09 <monochrom> The reason is that GHC's GC is a copying collector (plus many other things), which is an analogue of "double buffering" in graphics.
12:37:54 <monochrom> (profiling will still say 240MB. but your OS will say 480MB.)
12:38:17 <m-renaud> Ahh, that would do it
12:38:57 <monochrom> Haskell's list is one of the worst data structures.
12:39:09 <xa0> linked list?
12:39:11 <monochrom> However, it's also one of the best control structures.
12:39:21 <xa0> define "worst"
12:39:47 <Clint> "most bad"
12:39:52 <m-renaud> I can see that :P Would parsing straight into a Sequence fix that at all?
12:40:13 <monochrom> Sequence may take as much memory.
12:40:14 <m-renaud> I may try grabbing each line as a bytestring and then Seq.unfoldr it
12:40:26 <xa0> are you saying linked lists are objectively bad, or have i jumped in at the wrong time
12:41:00 <monochrom> xa0, I think yes to both
12:41:20 <xa0> hm
12:41:23 <muzzle> hi
12:41:37 <muzzle> is there a way to access a nested field in a json in Aeson ?
12:41:45 <muzzle> without parsing the whole field into a datatype first
12:41:58 <hexagoxel> m-renaud: the `Sample`s are not really forced, are they? (that it contains strict fields does not help..)
12:42:00 <muzzle> kind of like you could do foo["a"]["b"]["c"] in python ?
12:42:07 <puregreen> muzzle: https://artyom.me/aeson#nested-records
12:42:37 <monochrom> m-renaud: however, if you try to use Vector it may be much more compact
12:43:40 <monochrom> Sequence is when you feel freely about appending to the left, appending to the right, asking for head, asking for last, and want all 4 to be fast.
12:43:44 <m-renaud> hexagoxel: No they are not.
12:44:01 <monochrom> but it has as much memory overhead as []. probably even more.
12:45:02 <muzzle> puregreen thx
12:45:03 <m-renaud> Haha, I'm going to have 2 Vector types in the same file :P
12:45:09 <m-renaud> I'll try it out, thanks for the suggestions
12:53:33 <Rotaerk> so no advice on *how* to use an interface that takes a ByteString for a host name?
12:53:51 <Rotaerk> I've been convinced that I'd have to read through all the RFCs to understand the rationale for the design
12:54:01 <Rotaerk> but that doesn't solve the problem of ... I don't know how to come up with that byte string
12:54:09 <geekosaur> ...
12:54:58 <Rotaerk> without reading through the RFCs and doing puny-code encoding and IDN encoding and whatnot
12:55:01 <monochrom> all great journeys of learning begin by starting from scratch
12:55:34 <Rotaerk> I'm not fine with spending a year or more to read through the RFCs just so that I know how to specify a host name to a function
12:55:42 <Rotaerk> when I've been fine for years just providing strings
12:56:22 <monochrom> yes, that is a difficult choice, isn't it?
12:56:51 <Rotaerk> what choice?
12:56:53 <monochrom> to continue using old software so you change nothing, or to learn a whole new world so you can get rid of old software
12:57:24 <Rotaerk> how poetic?
12:57:53 <Rotaerk> geekosaur, why'd you ...
12:58:00 <monochrom> don't you wish the multiple-world interpretation of quantum mechanics is true, so that you simply fork yourself to explore both choices concurrently and parallelly (and they are the same)
12:58:04 <lpaste> hexagoxel annotated “MnistLoader.hs” with “MnistLoader.hs (annotation)” at http://lpaste.net/163340#a163341
12:58:16 <hexagoxel> m-renaud: try that.
12:58:44 <Jinxit> Rotaerk: if I knew I'd tell you (never done web in haskell) but I agree that this channel is being useless atm
12:59:32 <hexagoxel> m-renaud: this change seems to reduce max residency to 40% roughly.
12:59:59 <Rotaerk> Jinxit, I can't really tell if people just don't know, or if I'm making some kind of terrible mistake and people are just baffled at my stupidity
13:00:12 <Jinxit> people usually help regardless
13:01:41 <m-renaud> Wow, just adding the let !sample made that much of a difference
13:01:47 <m-renaud> The heap profile is all ARR_WORDS now
13:02:20 <EvanR> Rotaerk: to encode a hostname as a bytestring, you can use OverloadedStrings and type it literally into the program, pack a list of ascii Word8s, encodeUtf8 a Text representation of the name, compute it from parts joining with '.' ...
13:02:49 <EvanR> for encoding characters i usually have a helper function, fromIntegral . ord
13:02:57 <EvanR> when its less than 256
13:02:57 <Jinxit> m-renaud: doing ML?
13:04:43 <hexagoxel> m-renaud: sure, you just needed to use a monadic action to do the forcing of the samples. you already had everything else (strict fields, vector) in place.
13:05:01 <m-renaud> Jinxit: Yup, well starting to anyways :P
13:05:09 <Rotaerk> EvanR, hmm, but that seems like a simplistic encoding; it doesn't account for all the RFC stuff, like punycode and IDN encoding, that davean mentioned
13:05:28 <Rotaerk> EvanR, if that were sufficient, then a String interface *would* suffice
13:05:30 <EvanR> Rotaerk: ah... all that stuff
13:05:37 <m-renaud> hexagoxel: Thanks, interestingly I originally had the monadic version you added but without the !
13:05:43 <Rotaerk> which is what davean attempted to explain to me is NOT the case
13:05:50 <Jinxit> making a new lib?
13:06:04 <EvanR> Rotaerk: then you might want to look up "encode uri" instead of hostname
13:06:12 <EvanR> it might include the domain name stuff
13:06:26 <m-renaud> Just educational, nothing I would actually use to do ML
13:06:35 <Rotaerk> Jinxit, I'm just trying to figure out how to use https://hackage.haskell.org/package/network-conduit-tls
13:06:37 <Rotaerk> that's all
13:06:51 <EvanR> Rotaerk: this is an odd find... https://hackage.haskell.org/package/idna2008-0.0.1.0/docs/Data-Text-IDNA2008.html
13:07:00 <Jinxit> Rotaerk: that question was aimed at m-renaud, sorry
13:07:04 <Rotaerk> ah k
13:07:47 <EvanR> maybe look for the particular standards name instead of "encode hostname"
13:08:31 <hexagoxel> m-renaud: i think you need the monadic version, because functor alone does not allow to force one sample before executing the next monadic action.
13:08:35 <enthropy> Rotaerk: https://hackage.haskell.org/package/conduit-extra-1.1.13.1/docs/Data-Conduit-Network-UDP.html#t:HostPreference is something you've already looked at?
13:08:41 <Rotaerk> EvanR, the standard's just "the RFCs"; I haven't read them (and don't really intend to, given how huge they are)
13:08:59 <m0rphism> Hi, I've just encountered a type signature which I feel should work as `Constraints => Type` but instead only works with `() => Constraints => Type`. Is there a term I can search for to understand that phenomenon?
13:09:02 <Rotaerk> and how simple the task at hand should be
13:09:34 <hexagoxel> (i.e. there is no way to add some bang to make the fmap version less leaky)
13:09:43 <EvanR> i see references to IDNA and some other acronym
13:09:58 <EvanR> do you even know which RFC
13:10:02 <Rotaerk> enthropy, nope not sure what that is; don't see the source for that
13:10:04 <EvanR> maybe search for punycode
13:10:39 <EvanR> punycode-2.0: Encode unicode strings to ascii forms according to RFC 3492
13:10:43 <Rotaerk> EvanR, no; I'm under the impression that the RFCs are all working together to serve some overall goal, so to understand this stuff I have to read them all
13:11:12 <EvanR> well then it sounds too complex to do without understanding ;)
13:11:21 <Rotaerk> reading just one, such as RFC 952, which specifies that hostnames are just character strings... you miss out on the fact that RFC 20 says characters are ascii
13:11:36 <Rotaerk> EvanR, yea, but somehow people do it all the time without understanding the RFCs :P
13:11:40 <Rotaerk> I mean people use browsers all the time
13:11:40 <EvanR> all RFCs arent necessarily right
13:11:50 <EvanR> you have to know how stuff really works in practice
13:11:55 <EvanR> and what the overall goal is
13:11:56 <EvanR> if any
13:12:02 <Rotaerk> reddit.com is typed all the time without knowing conversion to byte strings
13:13:08 <EvanR> this is kind of the same thing as MIDI, you have books of technical details but whats important is how real programs work
13:13:13 <Rotaerk> EvanR, this all just seems like details that should be encapsulated by networking libraries, not exposed through the interface
13:13:13 <EvanR> and real hardware
13:15:19 <EvanR> like ipv6 in 2005 this might be something without good support yet, requiring someone interested in it to actually understand it enough to know whats going on
13:15:30 <EvanR> and possibly improve things
13:15:38 <Rotaerk> EvanR, I think you were interpreting me as saying that I wanted to do punycode encoding and whatnot
13:15:46 <Rotaerk> it's more that I'm under the impression that I *have* to
13:15:58 <Rotaerk> what I really want is just the ability to specify a host name like I would type into any browser...
13:16:08 <Rotaerk> except to pass it into this parameter of type ByteString
13:16:28 <EvanR> bytestring is indeed what you pass to the underlying OS name resolution system
13:16:36 <EvanR> it does not try to reencode it for you
13:16:45 <EvanR> its up to the application to do the encoding
13:17:06 <RGamma> Hey there, I'm trying to get to grips with RankNTypes a bit better, but already fail with the simplest examples: http://codepad.org/lsyJ1dWS. Someone care to give a hint what's wrong here? In my understand F :: (forall a.a) -> Fun, and any type should go in there. I first tried impredicative types and Map Int (forall a.a), but ran into problems there too, so I tried the workaround from
13:17:08 <RGamma> https://ghc.haskell.org/trac/ghc/wiki/ImpredicativePolymorphism and I can't get it to work
13:17:46 <Rotaerk> EvanR, but not necessarily the application developer :P
13:17:48 <EvanR> (forall a . a) -> Fun, no not any type goes there
13:18:06 <Rotaerk> and IMO really shouldn't be
13:18:06 <EvanR> Rotaerk: either the app developer, or the library developer
13:18:15 <Rotaerk> library developer is what I had in mind
13:18:23 * EvanR nominates Rotaerk 
13:18:26 <Rotaerk> that's why I'm looking for a library that I can provide a String or Text to
13:18:33 <EvanR> well i already posted a few
13:18:43 <m0rphism> nvm, it was a type signature of a pattern synonym. The `Constraints => Constraints => Type` notation is explained in the documentation of the GHC extension.
13:18:46 <Rotaerk> and it gives me back a ByteString
13:19:19 <EvanR> you will have to convert to bytestring yourself with "IDNA2008"
13:19:24 <EvanR> assuming it succeeds
13:20:05 <Rotaerk> I don't think any host names I will use are going to contain characters that aren't simple ascii characters
13:20:15 <EvanR> ... so whats the problem
13:20:33 <EvanR> you can also use punycode package, which has encode :: Text -> ByteString
13:20:43 <Rotaerk> I don't know how to specify "haskell.org" as a bytestring *and* be confident that it's encoded in such a way that it will be interpreted correctly by the network library
13:20:53 <EvanR> ... that is exactly how you specify it
13:20:59 <EvanR> have you ever done network programming before?
13:21:12 <Rotaerk> yea, most languages just take strings
13:21:15 <Rotaerk> not byte arrays
13:21:51 <EvanR> other languages range from strings being equal to byte arrays to being wrong about string handling and byte arrays
13:22:10 <EvanR> im glad haskell has a distinction to make you think
13:22:12 <Rotaerk> when you said "that is exactly how you specify it", what do you mean?
13:22:17 <Rotaerk> what is "that"
13:22:23 <EvanR> "haskell.org"
13:22:35 <Rotaerk> but that's a string, not a byte array, which you just said are different things
13:22:40 <EvanR> OverloadedStrings
13:22:47 <lpaste> m-renaud pasted “MnistLoaderFast.hs” at http://lpaste.net/163344
13:23:00 <EvanR> so its a byte array ascii encoded
13:23:08 <m-renaud> This one runs instantaneously, the profiler doesn't even have time to collect data
13:23:29 <Rotaerk> EvanR, so are you saying that for domain names that contain only ascii characters, you simply do a trivial ascii encoding of the strings?
13:23:50 <RGamma> EvanR: Mhh, I see you're busy. I'll try at a later time. I'll read up on forall once again
13:23:56 <Rotaerk> the RFCs don't require anything else to be done to them?
13:24:16 <EvanR> yes, which is basically like pretending you are in C or PHP 
13:24:31 <EvanR> theres a 1to1 correspondence between bytes and ascii characters
13:24:41 <EvanR> (not really, but they pretend)
13:25:07 <Rotaerk> as I understand it, technically C isn't necessarily ASCII; the numeric value associated with, say, 'a' in C, is dependent upon the compiler
13:25:22 <EvanR> another irrelevant fact
13:25:45 <EvanR> the great thing about standards is when they dont help you understand reality
13:26:43 <Rotaerk> seems like once standards become implemented heavily, they should redefine the standard to cover the implicit standard that emerges through use
13:26:50 <EvanR> try the punycode package to see what encode :: Text -> ByteString does
13:27:18 <EvanR> standards are created after stuff is implemented heavily, sometimes corresponding to what was implemented sometimes not and is ignored
13:27:34 <geekosaur> Rotaerk, you may have missed it since it looked like an irrelevancy at the time, but the IETF actually started to do that
13:27:38 <geekosaur> there's a series of STDs which are renumbered RFCs
13:27:59 <geekosaur> but they apparently gave up on it as an impossible job back in 2008, because the STD index hasn't been updated since then
13:28:19 <Rotaerk> EvanR, I'm under the impression, based on the conversation with davean, that there's more to encoding a hostname than just punycode
13:28:25 <vxr> anyone using mwc-probability
13:28:25 <vxr> ?
13:28:29 <EvanR> to do what a browser does, try the punycode package
13:28:31 <Rotaerk> so I would expect that punycode library to only solve a portion of the problem
13:28:47 <EvanR> instead of reading what the library does, youre just complaining about the name
13:29:07 <Rotaerk> yes, I was assuming it was punycode-specific based on the name
13:29:26 <EvanR> i will read RFC 3492 and tell you what it says ;)
13:29:48 <Rotaerk> I'm not necessarily opposed to reading *an* RFC :P
13:29:54 <geekosaur> also rfc1123 was intended to cover the implicit standards of use / "social contract", although it's incomplete
13:30:00 <Rotaerk> it's just that no RFC in isolation is enough, apparently
13:30:11 <Rotaerk> since they all rely on the assumption that you've read all the *others*
13:30:29 <geekosaur> I rather suspect the collection of RFCs is now too big for anyone to rationally index and cross-reference
13:30:45 <EvanR> Rotaerk: i think youre being mislead here
13:31:28 <EvanR> first you are only really interested in ascii hostnames, which are encoded in ascii and thats it and it just works
13:31:45 <EvanR> second you got sucked into a unicode topic, the full scope of which is usually too much to handle
13:31:57 <EvanR> but you said you dont really care so
13:32:01 <Rotaerk> which is what OverloadedStrings + ByteString provides... okay
13:32:04 <Rotaerk> I'll just try that
13:32:09 <Rotaerk> thanks
13:32:14 <EvanR> encodeUtf8 provides it
13:32:18 <EvanR> too
13:32:36 <EvanR> since the user isnt typing into the source code
13:32:45 <Rotaerk> true
13:33:22 <EvanR> but if i was making a browser i would use punycode
13:34:14 <Rotaerk> in this case it's just an IRC client; I'm not even using network-conduit-tls, so much as an IRC client library built upon it
13:34:51 <Rotaerk> and this confusion sprung up from the fact that it's using ByteString.Char8 encoding in one case, and Utf8 encoding in another
13:34:53 <Rotaerk> for the same byte string
13:34:59 <Rotaerk> err decoding
13:34:59 <EvanR> is there a single irc server hosted at a unicode domain ;)
13:35:08 <Rotaerk> dunno
13:35:58 <EvanR> Utf8 is right for the communication, but not for the hostname
13:36:06 <EvanR> if there are any non ascii characters
13:36:31 <EvanR> i didnt think TLS had anything to do with name lookup though
13:36:59 <Rotaerk> http://hackage.haskell.org/package/irc-conduit-0.1.2.0/docs/src/Network-IRC-Conduit.html#ircClient
13:37:12 <Rotaerk> note that it's got:  unpack $ decodeUtf8 host  in one case
13:38:10 <Rotaerk> err where did I see this...
13:38:17 <EvanR> if its ascii bytes then thatll work
13:38:32 <Rotaerk> only incidentally
13:38:39 <Rotaerk> but I guess that's just me being anal retentive
13:38:39 <EvanR> by design
13:39:01 <Rotaerk> ah yea, http://hackage.haskell.org/package/irc-conduit-0.1.2.0/docs/src/Network-IRC-Conduit.html#ircWithConn
13:39:14 <Rotaerk> host is being passed into decodeUtf8 in one place, ant into tlsClientConfig in another
13:39:23 <Rotaerk> which uses ByteString.Char8 decoding
13:39:55 <Rotaerk> the fact that the same bytestring was being passed into two different decoding functions is what confused me
13:39:57 <EvanR> ByteString.Char8 decoding?
13:40:05 <EvanR> what functino
13:40:40 <Rotaerk> http://hackage.haskell.org/package/network-conduit-tls-1.2.2/docs/src/Data-Conduit-Network-TLS.html#tlsClientConfig
13:40:42 <Rotaerk> S8.unpack
13:41:08 <EvanR> so they were sloppy in how they assumed ascii
13:41:23 <EvanR> but thats whats going on
13:41:36 <Rotaerk> yea, and since I was trying to figure out how to put together a ByteString, this ambiguity wasn't helpful
13:42:03 <Rotaerk> I was like "do I make pack using ByteString.Char8, or do I encode as utf8?"
13:42:11 <Rotaerk> and the documentation didn't specify anything either
13:42:22 <Rotaerk> -make
13:42:31 <EvanR> it doesnt help that these RFCs are written like the goal is to convert unicode into ascii, not into bytestrings
13:42:32 <Clint> probably everything breaks with non-ascii
13:42:52 <EvanR> ascii is synonymous with bytestrings sometimes
13:42:56 <EvanR> which is silly
13:43:29 <Rotaerk> EvanR, some of the people I've spoken to seemed to think that way; like the *semantics* of a host name is a byte string... not a character string
13:43:37 <EvanR> it requires some leap of faith insight to comprehend what they mean, if you are familiar with unicode issues
13:43:40 <Rotaerk> but I'd argue that it's a character string, just implicitly assumed to be encoded as ascii
13:43:57 <Rotaerk> which implies that each character corresponds to a byte
13:44:09 <EvanR> using my language, a character string isnt encoded
13:44:15 <Rotaerk> right
13:44:28 <Rotaerk> it's something that has the potential to become encoded
13:44:44 <Rotaerk> and some encodings may have a one-to-one correspondence between bytes and characters
13:44:49 <EvanR> it could itself be an encoding of something, like punycode
13:45:03 <Rotaerk> yea, I guess "encoding" is a relative term, something that ties two things together
13:45:10 <Rotaerk> X is an encoding of Y
13:45:19 <Rotaerk> not something inherent
13:45:43 <EvanR> category theory strikes again!
13:45:53 * Rotaerk should take the time to learn category theory.
13:46:38 * hackagebot bitx-bitcoin 0.8.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.8.0.0 (tebello_thejane)
13:48:46 <Rotaerk> anyway, thanks EvanR 
13:49:04 <EvanR> X is an encoding of itself
13:49:18 <EvanR> if X is an encoding of Y and Y is an encoding of Z, then X is also an encoding of Z
14:06:39 * hackagebot process-extras 0.4 - Process extras  https://hackage.haskell.org/package/process-extras-0.4 (DavidFox)
14:12:56 <zennist> anyone knows if you can temporarily edit the current line in a text editor in ghci?
14:13:08 <zennist> like C-X C-E in bash
14:14:20 <ski> hm, haven't heard about it
14:14:31 <ski> `:e' allows you to edit the current module
14:15:42 <zennist> I see - that seems to allow editing a new file & load it immediately too
14:15:45 <zennist> not too bad
14:16:19 <agx> new to haskell. want to generate a template file (not html). the `web` suggests shakespearean templates, but that seems for web (html*). Thinking of hastache as the templating lib. any suggestions?
14:16:49 <ski> zennist : i tend to use `emacsclient -nw' with it
14:23:00 <zennist> ski: unfortunately I'm not a emacs person - have been using vim all the time :P
14:26:39 * hackagebot process-extras 0.4.1 - Process extras  https://hackage.haskell.org/package/process-extras-0.4.1 (DavidFox)
14:26:56 <fr33domlover> agx, there are several I know, all run-time though
14:27:22 <ski> zennist : i'm sure that would also work fine :)
14:27:25 <fr33domlover> agx, shakespeaare can be used for plain text too
14:27:50 <dcz> hello guys
14:28:12 <ski> hello dcz
14:28:54 <dcz> how are you today ?
14:29:52 <dcz> I am trying to do this hw, https://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf .
14:30:06 <dcz> For the first part i did this and getting those errors, http://lpaste.net/163346
14:30:27 <dcz>  i dont know what i am doing wrong and actually i dont understand too much Haskell errors :D
14:31:12 <hpc> on line 7, LogMessage is getting 4 parameters
14:31:13 <hpc> they are
14:31:18 <hpc> (take 1 pm)
14:31:22 <hpc> (read (drop 1 (take 2 pm)))
14:31:25 <hpc> unwords
14:31:30 <hpc> (drop 2 pm)
14:31:40 * hackagebot process-extras 0.4.1.1 - Process extras  https://hackage.haskell.org/package/process-extras-0.4.1.1 (DavidFox)
14:32:30 <hpc> you probably want parens around (unwords (drop 2 pm))?
14:33:19 <hpc> the general structure of ghc error is
14:33:25 <hpc> line:column
14:33:28 <hpc> what ghc wanted
14:33:30 <hpc> what ghc found
14:33:40 <hpc> a copy of the line
14:33:44 <dcz> hmm
14:33:58 <hpc> and sometimes if the error is something a bit more interpretable it will give you an english sentence
14:34:08 <hpc> like "The function ‘LogMessage’ is applied to four arguments, ..."
14:34:29 <hpc> from there you just kinda have to get inside ghc's head
14:35:31 <dcz> okey thank you
14:35:40 <agx> fr33domlover: thank you. i'm going to generate some c++, and figured, i'd test haskell for fun. I'll give shakespeare a run. do you have a better suggestion for this use case? 
14:37:41 <fr33domlover> agx, for generating C++ code? there may be some specific packages for that, try a Hackage search
14:38:05 <dcz> btw this is the right thing to this thing ? for example to get 4th item from a list drop 1 (take 4 list)
14:38:10 <dcz> smth like that 
14:46:42 <ski> dcz : instead of `take' and `drop' there, better would be to use pattern-matching to get the parts
15:01:40 * hackagebot dependent-sum 0.3.2.2 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.3.2.2 (JamesCook)
15:03:01 <dcz> sorry
15:03:02 <dcz> :D
15:03:30 <ski> dcz : any comment ?
15:03:55 <dcz>                         in   LogMessage (unwords [n,_..]) (read (unwords (drop 1 (take 2 pm)))) (unwords (drop 2 pm))
15:04:05 <dcz> i did this but ofc i am getting n is not in the scope
15:04:55 <dcz> how should i make pattern-matching ?
15:05:59 <ski> dcz : either use a helper function, or `case', or `let'
15:06:26 <dcz> what helper function ?
15:06:36 <ski> well, `let'/`where' .. but these should only be used when there's no normal possibility for match failure
15:06:41 * hackagebot th-extras 0.0.0.4 - A grab bag of functions for use with Template Haskell  https://hackage.haskell.org/package/th-extras-0.0.0.4 (JamesCook)
15:06:53 <ski> (iow, when match failure means that you might as well kill/abort the whole process)
15:07:08 <ski> dcz : have you seen any of `case',`let',`where' yet ?
15:07:28 <dcz> nope
15:07:32 <ski> dcz : "what helper function ?" -- you invent one yourself, and also define it yourself
15:08:06 <ski> dcz : the idea here is that we want to "decompose" the results of `words list', in order to use the parts for the result
15:08:16 <ski> s/results/result/
15:08:41 <ski> so .. you could call the helper function e.g. `parseMessageHelper'
15:09:12 <ski> or, if you can find a more sensible name, like perhaps `parseMessageWords' in this case, then that could be preferable
15:09:31 <ski> so, let's assume that you use the name `parseMessageWords', for the purpose of this discussion
15:09:38 <ski> dcz : following, so far ?
15:09:55 <dcz> yeah
15:10:43 <ski> you had (correcting the type error)
15:10:50 <ski>   parseMessage :: String -> LogMessage
15:11:24 <dcz> thats right
15:11:26 <ski>   parseMessage list = let pm = words list
15:11:32 <ski>                        in LogMessage (take 1 pm)
15:11:50 <ski>                                      (read (drop 1 (take 2 pm)))
15:11:53 <ski>                                      (unwords (drop 2 pm))
15:12:24 <ski> here you're actually using a `let'-`in' expression
15:12:37 <ski> in this case, this could alternatively have been written using `where' instead :
15:12:54 <ski>   parseMessage list = LogMessage (take 1 pm)
15:13:07 <ski>                                  (read (drop 1 (take 2 pm)))
15:13:14 <ski>                                  (unwords (drop 2 pm))
15:13:16 <ski>     where
15:13:21 <ski>     pm = words list
15:13:43 <ski> it's basically just a different ordering, which might be preferable, for readability reasons
15:13:47 <dcz> hmm this is interesting also
15:13:53 <dcz> yeah definetely
15:13:56 <ski> (there are also a few other differences, but let's ignore them for now)
15:14:37 <ski> anyway, i was intended to show how to do this, by step-by-step rewriting of your original program
15:14:52 <ski> with some practice, you'd not type out all the intermediate steps explicitly
15:15:29 <dcz> yeap i hope so :D
15:16:02 <ski> so, we start by "factoring out" the body part, except the `pm = words list', into the helper function (`parseMessageWords')
15:16:22 <ski>   parseMessage list = parseMessageWords pm
15:16:25 <ski>     where
15:16:29 <ski>     pm = words list
15:16:33 <ski> and then the helper
15:16:46 <ski>   parseMessageWords :: [String] -> LogMessage
15:16:56 <ski>   parseMessageWords pm = LogMessage (take 1 pm)
15:17:10 <ski>                                     (read (drop 1 (take 2 pm)))
15:17:16 <ski>                                     (unwords (drop 2 pm))
15:17:23 <ski> so far, not much exciting has happened
15:17:30 <horatioh1> Never used Template Haskell before and am wondering: how does it represent, say, the Int type as a piece of abstract syntax?
15:17:58 <ski> dcz : do you follow, so far ?
15:18:02 <dcz> yeah
15:18:07 <ski> ok
15:18:24 <dcz> i am just trying as following you 
15:19:01 <ski> (oh, i actually just noticed another type error. let's ignore it for now)
15:19:08 <dcz> :D
15:19:12 <dcz> tell me tell me :D
15:19:18 <dcz> or later tell me
15:19:43 <ski> well, the first argument of `LogMessage' should be a value of type `MessageType', not a value of type `[String]'
15:19:51 <dcz> yeah i know that
15:20:05 <dcz> i am thinking about that , i think i should use case for that
15:20:05 <ski> also, something similar for the `read' thing there
15:20:24 <dcz> read part works actually
15:20:31 <ski> but, let's ignore that for now :)
15:20:36 <dcz> okey :D
15:20:54 <ski> now imagine `pm' is perhaps `["foo","42","bar","baz"]'
15:21:03 <ski> then
15:21:16 <ski>   take 1 pm = ["foo"]
15:21:25 <dcz> yes
15:21:28 <ski>   take 2 pm = ["foo","42"]
15:21:38 <ski>   drop 1 (take 2 pm) = ["42"]
15:21:50 <dcz> yeap
15:22:03 <ski> and then we'd like `read (drop 1 (take 2 pm))' to be the `TimeStamp' (iow `Int') `42'
15:22:15 <bcq> is it possible to set a breakpoint within a module, without having to specify the line number within ghci? "debugger" is used in javascript, IEx.pry in elixir, pdb.set_trace() in python
15:22:18 <ski> but `read' wants a string, not a list of strings
15:22:22 <ski> @type read
15:22:24 <lambdabot> Read a => String -> a
15:22:37 <ski> (and `["42"]' is a list of strings)
15:22:51 <ski> ignoring, and continuing, we'd have
15:23:02 <dcz> ahh sorry
15:23:04 <ski>   drop 2 pm = ["bar","baz"]
15:23:08 <dcz> i forgot to mention that
15:23:14 <ski>   unwords (drop 2 pm) = "bar baz"
15:23:16 <dcz> i added unwords for read part
15:23:21 * ski nods, ok
15:23:25 <dcz> :D
15:23:30 <dcz> anyways go on , sorry 
15:23:57 <ski> now, do you know how lists are really built from the "primitive" (data) constructors `[]' and `:' ?
15:24:19 <dcz> no actually
15:24:25 <ski> ok
15:25:00 <ski> the list syntax in e.g. `[2,3,5,7]' is just a convenient shorthand. that list really is `2 : 3 : 5 : 7 : []'
15:25:09 <dcz> yeah i know that
15:25:13 <ski> and that really means `2 : (3 : (5 : (7 : [])))'
15:25:16 <ski> `[]' is the empty list
15:25:36 <ski> `x : xs' is the non-empty list that starts with the element `x', and continues with all elements of the *list* `xs'
15:25:53 <ski> in short, `x : xs' is the element `x' added in front of the list `xs'
15:25:59 <ski> so, in our case
15:26:09 <ski> > "foo" : "42" : ["bar","baz"]
15:26:11 <lambdabot>  ["foo","42","bar","baz"]
15:26:17 <dcz> yeah
15:26:17 <ski> is our list `pm'
15:26:18 <dcz> got ya
15:26:34 <dcz> for the 3rd element
15:26:38 <ski> now, the idea with *pattern-matching* is that you can define (e.g.) functions by cases
15:26:41 * hackagebot dependent-sum-template 0.0.0.5 - Template Haskell code to generate instances of classes in dependent-sum package  https://hackage.haskell.org/package/dependent-sum-template-0.0.0.5 (JamesCook)
15:26:44 <dcz> x:y:z:zs 
15:26:44 <dcz> :D
15:26:49 <dcz> or..
15:26:59 <ski> handling different "shapes"/patterns of input by different "clauses" / defining equations
15:27:00 <dcz> z is 3rd
15:27:12 <ski> in our case, instead of saying
15:27:18 <ski>   parseMessageWords pm = ..pm..
15:27:20 <ski> we can say
15:27:58 <ski>   parseMessageWords (messageType:timeStamp:rest) = ..messageType..timeStamp..rest..
15:28:11 <dcz> woaaa
15:28:22 <dcz> this is much more logical
15:28:33 <ski> and this would then handle the case where `parseMessageWords' gets passed *any* list having at *least* two elements
15:28:49 <dcz> yeah
15:28:52 <ski> the first two elements are named `messageType' and `timeStamp' (note that these are both strings here)
15:29:09 <ski> the remainder of the list (possibly zero elements) is `rest' (which is then a list of strings)
15:29:21 <dcz> yeap
15:29:36 <dcz> i have a question then
15:29:46 <ski> so .. i take it you can now rewrite the previous body for `parseMessageWords' in terms of the new variables `messageType',`timeStamp',`rest' ?
15:30:15 <dcz> the messageType has 3 kinds , Info  , Warning, Error Int
15:30:25 <dcz> then what would it be if Error Int ?
15:30:35 <dcz> it fails for that case
15:30:45 <ski> hm, yes, that's correct
15:31:41 * hackagebot bitvec 0.1.0.2 - Unboxed vectors of bits / dense IntSets  https://hackage.haskell.org/package/bitvec-0.1.0.2 (JamesCook)
15:31:49 <ski> so, it looks like in case the first element of the list is the string `"E"', then the next element is not the time stamp, but the error severity
15:32:07 <dcz> yeah
15:32:10 <ski> (also note that your previous code didn't handle this case either)
15:32:18 <dcz> i know :D
15:32:39 <dcz> i thought at least for now
15:32:44 <dcz> i should use case of
15:33:06 <ski> btw, before i forget, i should mention that since the above defining equation for `parseMessageWords' only handles lists of length at least two, you should probably also add cases (or just a single case) handling when the list is empty, and when the list is a singleton list
15:33:33 <ski> probably you can't do much sensible there, but you can at least call `error' with an informative error message explaning what was wrong
15:33:59 <ski> now, you can't only match on lists in pattern-matching
15:34:09 <ski> you can also match on numerals, like `42'
15:34:13 <ski> and also on string literals
15:34:21 <dcz> yes sir
15:34:37 <ski> in particular, you could have one case / clause / defining equation for `parseMessageWords' that looks like :
15:34:48 <ski>   parseMessageWords ("I":timeStamp:rest) = ..timeStamp..rest..
15:35:18 <ski> that will only handle the case where the first element is the string `"I"', and there's at least one more element in the list
15:35:41 <ski> to handle other cases, just put their defining equations below (or above) the given one
15:36:01 <bcq> is it possible to set a breakpoint within a module without needing to specify the line number using :break num, i'd like to set a breakpoint using a function imported from a module
15:36:13 <ski> defining equations are tried in order, but often (if reasonable) it's preferable to make sure that the ordering doesn't really matter
15:36:16 <dcz> somehow i got you :D
15:36:19 <ski> dcz : does this help ?
15:36:38 <bcq> which module is :break calling, maybe i can import that module and use some of the functionality :break is using underneath
15:36:44 <dcz> yeah 
15:36:49 <dcz> give me some time pls
15:37:01 <dcz> i will try the things you said
15:37:06 <ski> dcz : now .. you *could* place the definition of this `parseMessageWords' "inside" the `where' belonging to `parseMessage'
15:37:23 <ski> you'd have to indent it equally as the `pm = words list' line
15:37:54 <dcz> okey
15:38:03 <ski> that way, `parseMessageWords' would be private to `parseMessage', can't be seen by other "sibling" definitions to `parseMessage'
15:38:22 <dcz> is it good or bad or depends ?
15:38:43 <ski> i'd recomment doing that, in case your helper function has a useless name like `parseMessageHelper'
15:39:04 <ski> or otherwise is only of interest to thise "larger/outer" definition
15:40:04 <ski> also, if you make it private like this, it's considered ok to use a more "throwaway" (basically, shorter ior not as informative) name, like `helper' or `go' or `loop' or `match' or `doIt'
15:40:45 <dcz> okey :D
15:40:53 <dcz> i am learning a lot from you
15:41:03 <ski> however, if you've managed to figure out a more descriptive name like `parseMessageWords', then *perhaps* this function could have a value of its own, independent value, and not only in relation to how it helps `parseMessage' to perform its task
15:41:38 <ski> in such a case, it could be useful to *not* make the "helper" private, since in that case it could be useful to also use it in other definitions
15:42:00 <ski> (perhaps even exporting it from this module/file, using it in other modules, perhaps written by different people)
15:42:32 <ski> of course, it's not that hard to change between the function being private and being non-private
15:42:58 <ski> but it's an important point to consider, to make readable and reusable code
15:43:31 <dcz> i didnt understand how making private and non
15:43:40 <tzaeru> ski, it's pretty hard if it ends up to production and to wide use tho
15:44:14 <ski> tzaeru : yes. i was only considering module-internal use there :)
15:44:37 * ski waits for dcz to complete the sentence
15:45:18 <dcz> i mean what makes that function private or non-private ? isnt it just a function ?
15:45:36 <dcz> you are just changing its name 
15:45:50 <ski> dcz : basically, the smaller / more local "scope" a name has, the more ok it's considered for its name to be shorter, less informative, more context-dependent
15:46:08 <ski> dcz : if you write
15:46:35 <ski>   parseMessage :: String -> LogMessage
15:46:39 <ski>   parseMessage list = parseMessageWords pm
15:46:42 * hackagebot hsebaysdk 0.4.0.0 - Haskell eBay SDK  https://hackage.haskell.org/package/hsebaysdk-0.4.0.0 (ChristopherReichert)
15:46:44 <ski>     where
15:46:50 <ski>     pm = words list
15:46:52 <ski>     
15:46:57 <ski>     parseMessageWords :: [String] -> LogMessage
15:47:07 <dcz> i want to understand the special thing about it :D but i got what you meant though
15:47:08 <dcz> okey
15:47:22 <ski>     parseMessageWords ("I":timeStamp:rest) = ..timeStamp..rest..
15:47:32 <ski>     ...
15:47:41 <dcz> yeah yeah wait pls i will try okey
15:47:45 <ski> then `parseMessageWords' is local/private to `parseMessage'
15:48:01 <dcz> righty
15:48:08 <ski> and it can't be "seen"/used outside of this defining equation of `parseMessage'
15:49:08 <ski> if you deindent `parseMessageWords', so that it's not "under/inside" the `where', then it can be seen by any definition in the module that's at the same indentation level, not just `parseMessage'
15:49:56 <dcz> ahh
15:50:01 <dcz> now i got you 
15:50:16 <dcz> the parseMessageWords in the parseMessage function
15:50:24 <dcz> finally i got you :D
15:50:28 <ski> yes
15:50:38 <ski> <dcz> i should use case of
15:50:41 <ski> that would also be possible
15:51:00 <ski> but i think using a helper like this for pattern-matching, may be clearer for newbiws
15:51:02 <dcz> i was thinking about how that can be private :D
15:51:03 <dcz> haha
15:51:07 <ski> s/newbiws/newbies/
15:51:21 <ski> it can also, depending on the case, be clearer for oldbies :)
15:51:33 <dcz> :D
15:51:39 <dcz> okey
15:51:42 * hackagebot HaTeX 3.17.0.1 - The Haskell LaTeX library.  https://hackage.haskell.org/package/HaTeX-3.17.0.1 (DanielDiaz)
15:51:58 <ski> if you use `case' here, then you don't have to bother with inventing a name like `parseMessageWords'
15:52:02 <ski> you just type something like
15:52:07 <ski>   parseMessage :: String -> LogMessage
15:52:18 <ski>   parseMessage list = case words list of
15:52:35 <ski>                         "I":timeStamp:rest -> ..timeStamp..rest..
15:52:42 <ski>                         ..other cases here..
15:53:06 <ski> so, you use `->' instead of `=', in this case
15:53:14 <ski> and no name for a pattern-matching function
15:53:17 <dcz> yeap
15:53:21 <ski> but it's still pattern-matching
15:53:36 <dcz> i will do both versions
15:53:52 <ski> often, code like the above would instead be indented like
15:53:54 <ski>   parseMessage list = case words list of
15:54:01 <ski>     "I":timeStamp:rest -> ..timeStamp..rest..
15:54:07 <ski>     ..other cases here..
15:54:18 <ski> in order to avoid too much "rightward drift" of the code
15:54:31 <ski> but conceptually, all these cases/branches are still "under" that `case'
15:54:42 <ski> an alternative is
15:54:47 <ski>   parseMessage list =
15:54:48 <ski>     case words list of
15:54:51 <ski>       "I":timeStamp:rest -> ..timeStamp..rest..
15:54:54 <ski>       ..other cases here..
15:55:26 <dcz> okey thank you
15:55:50 <ski> you should be able to go between different style of indentation like this, at will, as suits the particular situation best
15:56:26 <ski> (and as suits your personal style, as informed by general style and convention advice)
15:56:47 <dcz> okey i got you 
15:57:15 <ski> i think you've got enough to be able to go on for a while with the exercise
15:57:25 <ski> and i think i've said what i intended to mention
15:58:48 <dcz> yeah you helped a lot there , thank you so much 
15:59:23 <ski> yw
16:10:58 <danilo2> Hello guys! Is there any way to use stack with lts and ghc8?
16:13:58 <nmdanny> @hoogle
16:14:00 <lambdabot> No query entered
16:14:01 <lambdabot> Try --help for command line options
16:14:19 <nmdanny> @hoogle (Foldable t,Monad m) => (b -> a -> m b) -> b -> m a -> m b
16:14:21 <lambdabot> Did you mean: Monad m => (b -> a -> m b) -> b -> m a -> m b
16:14:21 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:14:21 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
16:14:22 <geekosaur> danilo2, there is no Long Term Support stackage release for ghc8
16:14:27 <geekosaur> so "no"
16:14:38 <dcz> ski : i am getting about Error part
16:14:47 <dcz> getting error about Error :D
16:14:55 <danilo2> geekosaur: ok, I was thinking that it is so. Are there any official release dates for the publiuc ghc8 ? 
16:15:00 <geekosaur> seeing as ghc8 is not yet officially released (source is out, binaries not, already had to reissue source for one build problem and there may be another yet)
16:15:03 <dcz>          parseMessageWords ("E":severity:timeStamp:rest) = LogMessage (Error read severity) (read timeStamp) (unwords rest)
16:15:15 <geekosaur> when they have binary releases
16:15:36 <danilo2> ok sounds like not a really long period of time :)
16:15:39 <danilo2> thank you! :)
16:15:45 <geekosaur> nd even when it is released I expect there will be a delay before there's an LTS for it
16:16:05 <danilo2> geekosaur: oh, thats a bad news
16:16:14 <danilo2> what can cause the delay?
16:16:37 <geekosaur> testing and integration?
16:16:40 <danilo2> I was thinking that its pretty straightforward to just automatically test the libraries if they're building or nit
16:16:50 <danilo2> geekosaur: but yeh, it takes time. Ok thank you :)
16:17:11 <dcz> ski :  http://lpaste.net/163348
16:17:36 <nmdanny> is it possible to shorten the following do block:
16:17:40 <nmdanny> lendings :: Entity User -> App [Loan]
16:17:44 <nmdanny> lendings curEntUser= do
16:17:45 <geekosaur> I am aware of ways to use stack with ghc8, but dont know when lts will support ghc8. you'd do better asking about that in #haskell-stack
16:17:49 <nmdanny> 	allLendings <- lendingsByUsers
16:17:54 <nmdanny> 	return $ foldr (\(entUser,entLoan) acc -> if entityKey entUser == entityKey curEntUser then entityVal entUser : acc else acc) [] allLendings
16:17:57 <geekosaur> @paste
16:17:57 <lambdabot> Haskell pastebin: http://lpaste.net/
16:18:11 <ski> dcz : more brackets, `Error (read severity)'
16:18:22 <lpaste> nmdanny pasted “can this be shortened” at http://lpaste.net/163349
16:18:31 <nmdanny> can this do block be shortened ^^
16:18:35 <ski> dcz : `Error read severity' is parsed as `(Error read) severity', which isn't what you want in this case ..
16:19:07 <dcz> hmm okey
16:19:12 <nmdanny> the pattern where I extract a value from a monad with <-, then apply a fold on the pure value
16:19:29 <dcz> ski: now i got something strange error after adding parantheses
16:19:29 <ski> nmdanny : s/extract a value from a monad/extract a value from a monadic action/
16:19:50 <dcz> http://lpaste.net/163351
16:20:06 <nmdanny> ok in other words, what im looking for seems to be similar to foldM,
16:20:28 <nmdanny> except that the initial traversable, is itself in the same monad
16:20:33 <ski> dcz : you aren't covering all possible cases of a list of strings
16:20:52 <nmdanny> :t foldM
16:20:53 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
16:21:19 <nmdanny> I need   (Monad m, Foldable t) => (b -> a -> m b) -> b -> m (t a) -> m b
16:21:33 <ski> nmdanny : oh, that's easy
16:21:42 <geekosaur> o.O why is that leaking Char implementation?
16:21:43 <dcz> okey
16:21:59 * ski was wondering the same
16:22:10 <nmdanny> and I want to do it in a single line
16:23:14 <ski> @type comparing
16:23:15 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
16:23:16 <ski> @type equating
16:23:18 <lambdabot> Not in scope: ‘equating’
16:23:50 <ski> @src comparing
16:23:51 <lambdabot> comparing p x y = compare (p x) (p y)
16:23:57 <davean> buf22
16:24:15 <ski>   comparing p = compare `on` p
16:24:17 <ski> @type on
16:24:18 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
16:24:19 <ski> @src on
16:24:19 <lambdabot> (*) `on` f = \x y -> f x * f y
16:24:32 <ski> @let equating :: Eq a => (b -> a) -> (b -> b -> Bool); equating p = (==) `on` p
16:24:33 <lambdabot>  Defined.
16:24:46 <ski>   equating p x y = p x == p y
16:24:59 <ski> then
16:25:00 <ski>   lendings :: Entity User -> App [Loan]
16:26:28 <ski>   lendings curEntUser = foldr (\(entUser,entLoan) -> if equating entityKey entUser curEntUser then (entityVal entUser :) else id) [] <$> lendingsByUsers
16:28:01 <nmdanny> oooooh it was a simple fmap
16:28:14 <ski>   lendings curEntUser = map (entityVal . fst) . filter (equating entityKey curEntUser . fst) <$> lendingsByUsers
16:28:47 <nmdanny> btw, is anyone familiar here with Persistent and/or Esqueleto?
16:29:06 <ski> nmdanny : how about that ^ ?
16:29:12 <Welkin> nmdanny: many
16:29:51 <ski> @index on
16:29:51 <lambdabot> Data.Function
16:30:23 <nmdanny> okay, so far I have the following function::
16:30:27 <nmdanny> usersWithLendings :: App [(Entity User,Entity Loan)]
16:30:41 <ski> `usersWithLendings' is not a function, it's a (monadic) action
16:31:12 <nmdanny> so that action performs an esqueleto join of all users and all of their lendings (loans where they are the lenders)
16:31:35 <lpaste> nmdanny pasted “No title” at http://lpaste.net/163352
16:31:39 <nmdanny> it looks like this ^
16:31:51 <nmdanny> now, I want to make the following function
16:32:15 <nmdanny> lendingsByUser :: Entity User -> App [Loan]
16:33:45 <nmdanny> basically, in the 'on' part, I want to do "E.on loan ^. LoanLender E.==. (entityKey givenUserParam)"
16:35:29 <nmdanny> ok what I said is incorrect,
16:35:50 <nmdanny> but basically I want to perform a one-to-many join given a 'one'.
16:41:43 * hackagebot dependent-map 0.2.2.0 - Dependent finite maps (partial dependent products)  https://hackage.haskell.org/package/dependent-map-0.2.2.0 (JamesCook)
16:42:27 <nmdanny> nvm I found the solution
16:42:41 <nmdanny> I had to use Database.Esqueleto.val
16:44:59 <Fare> hi
16:45:23 <Fare> can I have some help with some design and notation issues?
16:45:46 <Fare> I'm trying to model partial functions, non deterministic functions, etc.
16:46:35 <monochrom> you can use relations
16:46:54 <Fare> Is there a way to define an type operator A --> B that means "maybe partial, maybe non-deterministic function" from A to B ?
16:47:04 <Fare> monochrom, ok, how do I use relations?
16:47:53 <monochrom> I don't have time to teach it from scratch.
16:48:16 <monochrom> but "relation" appears in all discrete math courses
16:48:37 <Fare> yes, I know what a relation is in a mathematical context
16:48:48 <Fare> is there a standard haskell package for that?
16:49:18 <monochrom> have you asked hackage?
16:49:24 <monochrom> it has a search box
16:50:29 <ertes> Fare: (Monad f) => a -> f b
16:51:26 <ertes> replace Monad by a more appropriate constraint, if you have more information
16:52:10 <ertes> (or rather if you *need* more information)
16:53:11 <Fare> the only thing that I see that could be related is https://hackage.haskell.org/package/type-settheory
16:54:27 <Fare> https://hackage.haskell.org/package/type-settheory-0.1.3.1/docs/Type-Function.html
16:55:54 <monochrom> https://hackage.haskell.org/packages/search?terms=relation
16:55:57 <ertes> is this about haskell functions at all?
16:57:11 <Fare> that URL above intrigues me: the operators seem to be sometimes infix, sometimes prefix. How does the parser tell the difference?
16:58:44 <Fare> can I use --> as my notation for relations?
16:59:43 <ertes> syntactically yes
17:00:06 <ertes> but relations can be things other than functions, so using (-->) for relations in general could be misleading
17:05:08 <puregreen> what index-related functions on lists do people often reimplement? deleteAt/replaceAt/insertAt, indexed :: [a] -> [(Int, a)], map/filterWithIndex, what else?
17:07:19 <Fare> ertes: in the context I'm using it, that should be fine.
17:09:06 <Cale> puregreen: Usually if you're operating on particular indices, then you replace the lists with something else entirely.
17:09:44 <ertes> Fare: what is the context?  i'm asking because there are many ways to model them, useful in different contexts
17:10:08 <ertes> for example Map models partial functions, too, useful in the context of evaluation
17:10:09 <Cale> But the operations which act globally on zip [0..] are reasonable
17:10:32 <puregreen> Cale: given that I'm writing a library with the synopsis “indexed functions for lists”, this remark doesn't apply to my usecase :)
17:10:59 <ertes> while type-settheory models functions in the context of examining sizes and equality, as far as i see
17:11:26 <ertes> (also note that the package is six years old…  it's unlikely that it still works due to some major base library changes)
17:13:23 <Fare> ertes: my context is giving a talk on how to model operational semantics and implementations in Haskell.
17:21:51 <ski> Fare : fwiw, "Algebra of Programming" by Richard Bird,Oege de Moor talks about using relations to specify operations, and then gradually refine them into functions implementing the specification
17:22:43 <Fare> ski: nice
17:23:03 <Fare> yes, that's the context in which I'd be giving my talk
17:23:22 <ski> might be worth taking a look then
17:23:38 <Fare> first, I draw nice category theory diagrams, then I try to get some haskell type classes to implement to computational part of those diagrams
17:24:36 <ski> depending, it might perhaps also be nice to use logic programming, in case it could help to run your functions (partial, nondeterministic or whatever) backwards
17:24:52 <Fare> there's no preview of that book on amazon :-(
17:25:11 <ski> your local uni library might carry it
17:25:17 <Fare> ski: that would be a next level
17:25:33 <Fare> I have to prepare my talk for next week, no time for that :-/
17:25:40 * ski nods
17:26:03 <ski> if i may ask, where is this talk ?
17:29:56 <Welkin> yeah, all of the good (reletively recent) books on math/programming/cs are only available buy purchasing them
17:30:04 <Welkin> not even a torrent in sight
17:39:04 <ertes> Fare: you may also be interested in the type-theoretic notion of relations…  however, you need to emulate it in haskell using singleton types, so it's not too pretty
17:40:29 <ertes> Fare: a relation R between A and B is a function from A × B to *…  given x :: A and y :: B, the type R x y is inhabitated, if (x, y) is a member of the relation (in terms of functions: if the argument x results in y)
17:44:49 <Fare> is there a syntactic convention for booleans? should I call my predicate done, is_done, donep, done?  ?
17:45:07 <ertes> done or isDone
17:45:11 * ski notes that, type-theoretically, the axiom-of-choice is a kind of distributive law
17:46:34 <ski> if `forall x : A. exists y : B. R x y', then `exists f : A -> B. forall x : A. R x (f x)'
17:46:38 <ertes> Fare: a (loose) convention is: adjectives for predicates, nouns for functions, verbs and adverbs for actions
17:46:42 <ski> writing this with a different notation
17:47:19 <ski> if `(x :) A -> ((y :) B * R x y)', then `(f :) (A -> B) * ((x :) A -> R x (f x))'
17:47:46 <ski> in the case where `R x y' doesn't depend on `x' and `y' (so write `R x y' as `C' then instead), this reduces to
17:48:05 <ski> if `A -> (B * C)', then `(A -> B) * (A -> C)'
17:48:18 <ski> which distributes `A -> ' over the `*' product
17:49:19 <ski> > sequence ["012","abc"]
17:49:21 <lambdabot>  ["0a","0b","0c","1a","1b","1c","2a","2b","2c"]
17:49:40 <ski> (which is cartesian product) can be seen as an example if such a distribution
17:49:44 <ski> s/if/of/
17:51:08 <ski> (note that the number of elements in the result is `9', iow `3^2', while each element has length `2'. otoh, in the input, we have `2' lists each of length `3')
17:52:15 * ertes notes that in many cases a type-theoretic relation R is a lot more useful with an explicit decision function: a boolean "is member?" function, but where True is annotated with a proof, while False is annotated with a refutation
17:52:48 <ertes> data Decision p = Yes p | No (p -> Void)
17:52:59 <ski> @where boolean-blindness
17:52:59 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
17:53:04 <ski> may be relevant in this context
17:55:19 <ski> (oh, i should say s/an example of such a distribution/an example similar to such a distribution/ .. it's not quite the same thing with that `sequence', it's more like the `S'/`ap'/`(<*>)' combinator)
18:00:37 * ertes is afraid that the learning curve may be too steep for the available time frame
18:00:54 <ertes> unless Fare is already familiar with type theory
18:01:16 <ertes> (but then type-theoretic relations probably wouldn't be news to them)
18:03:12 <ertes> btw, a "non-deterministic function" is a relation R such that ∀ x. ∃ y. R x y (left total)
18:03:40 <ertes> a "deterministic function", i.e. a function, is a relation R such that ∀ x. ∃! y. R x y (left total, right unique)
18:05:23 <ertes> a "partial function" is a relation that is not necessarily left-total (i think the term "total" function originates from this)
18:05:50 <ertes> … but still right-unique
18:06:19 <ertes> and "partial, non-deterministic function" basically means "relation" =)
18:06:26 <ertes> just for the sake of completeness =P
18:07:52 <ertes> wait, no…  left-uniqueness is common to all kinds of mappings
18:08:20 <ertes> so "partial, non-deterministic function" is more like "left-unique relation"
18:09:07 <buttons840> I am trying to configure postgresql-simple to work with spock and need to create a PoolCfg which requires a NominalDiffTime; my problem is I don't know how to create a NominalDiffTime
18:09:54 <ertes> buttons840: it's an instance of Num, so literals will work
18:10:08 <ertes> buttons840: a NominalDiffTime literal is measured in seconds, so "8" means "8 seconds"
18:11:08 <ertes> (scratch the last part of my earlier remark…  it's too late for this stuff)
18:11:15 <buttons840> ertes: thank you: how could I determine that from these docs https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock.html#t:NominalDiffTime ?
18:11:33 <ertes> buttons840: look at the instances
18:11:45 <ertes> you'll find:  Num NominalDiffTime
18:12:13 <buttons840> ah, and the Num typeclass has fromInteger
18:12:55 <ertes> buttons840: yeah, and fromInteger is a conversion function, so this part of the doc also applies: "Conversion functions will treat it as seconds."
18:12:57 <buttons840> i was thinking fromInteger was in it's own typeclass, but that doesn't even make sense now that I think about it
18:13:14 <buttons840> i know fromInteger is used for turning literals to a type
18:13:18 <ertes> buttons840: if only it was =)
18:14:18 <ertes> our numeric type classes are a bit weird (to say the least)
18:14:25 <ski> ertes : you could try figure out what `mono' and `epi' means in the category of sets and binary relations between them ..
18:14:28 <ertes> i love how the only member of the Real type class is toRational =)
18:16:23 <ski> `fromInteger' is more or less the unique ring homomorphism from the ring of integers into any ring
18:16:54 <ertes> ski: interesting exercise, but not for tonight
18:17:42 <ertes> (it's 3:17 AM here)
18:17:48 <ski> (ditto)
18:18:56 <ertes> ski: am i going to see non-iso bimorphisms?
18:19:37 * ski doesn't recall
18:21:57 <ertes> my mental model for mono and epi is "injective" and "surjective"…  i know that's not accurate, but 99% of my category theory is about Hask
18:24:18 <ertes> i'm a haskell user since about 8 years, and i still don't know what the category of endofunctors is
18:25:25 <geekosaur> functors from an object in a category to another object in the same category
18:26:02 <ertes> geekosaur: that doesn't sound "endo" to me
18:26:31 <geekosaur> endo=in, vs. exo=out. so a functor within the same category
18:26:52 <ertes> oh, i see…  wrong level
18:26:57 <geekosaur> an exofunctor would be always to an object in a different category. a general functor could be either
18:28:33 <ertes> so it's not "the" category of endofunctors
18:29:23 <geekosaur> hm? endofunctors themselves form a category
18:30:19 <ertes> yeah, but there is a category of endofunctors for every category
18:30:48 <geekosaur> and there is also a ... from your focus, I guess you might think "supercategory" ... of all such endofunctors
18:31:10 <ertes> now i think, i see the monoid structure, too…  F × F → F (mappend), Id → F (mempty)…  right?
18:31:20 <ertes> uhm
18:31:21 <ertes> F . F
18:31:40 <ski> geekosaur : that description sounds weird ..
18:31:49 <geekosaur> something like that, I think. I am not well versed in category theory beyond what I have absorbed from in here
18:31:58 <ski> ertes : yes
18:32:09 <geekosaur> ski, likely it is. but a superset is just another set...
18:32:25 <ski> functors from a category to the same category are called endofunctors
18:33:02 <ski> if you say "functors from an object in a category to another object in the same category" then that category would have to be a category where the objects are also categories, for this to make any sense
18:33:09 <ertes> have you ever needed 8 years to understand a joke, just to find that it's not funny?
20:36:30 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
20:36:30 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
20:36:51 <ertes> billjoyisgod: you can compose with 'take' from Pipes.Prelude, and then with 'toListM'
20:37:15 <ertes> xs <- P.toListM (myProducer >-> P.take 10)
20:40:57 <hackrilege> Cale, i have a type error!
20:41:09 <hackrilege> can anyone help me with this? http://lpaste.net/163375
20:42:09 <billjoyisgod> ertes works, i had a strange bug though
20:42:21 <hackrilege> ignore all the commented out bits they are dead, sorry i should have removed them
20:42:25 <billjoyisgod> initially I was doing
20:42:40 <billjoyisgod> xs <- P.toListM (prod >-> P.take 10 >-> consumeVal
20:42:56 <billjoyisgod> where consumeVal = forever $ await >>= pure v
20:43:00 <Welkin> billjoyisgod: well maybe you should change your god to lambda calculus instead of bill joy
20:43:34 <hackrilege> Welkin, did you see my code, its a Free Zipper!
20:43:36 <billjoyisgod> when I did that, the type of xs is IO [X]
20:43:57 <billjoyisgod> i don't even know what [X] means ...
20:44:11 <ertes> billjoyisgod: yeah…  in an ideal world that would be a type error, but instead you get an empty list
20:44:21 <Welkin> hackrilege: no, I didn't
20:44:47 <Welkin> I haven't done anything with free monads yet
20:45:01 <hackrilege> it almost works but there is a type error, i dont know how to compose opperators over this structure..
20:45:39 <hackrilege> oh i need Cale, but he is angry at me
20:45:55 <hackrilege> he does not like Free much either...
20:46:12 <jamesgoslingisgo> ertes what's the difference between use cases for toList, toListM, and toListM' ?
20:46:13 <hackrilege> and i can see why, these type errors are ridiculous!
20:46:39 <hackrilege> :t toListM
20:46:40 <Welkin> why is he angry at you?
20:46:40 <lambdabot>     Not in scope: ‘toListM’
20:46:41 <lambdabot>     Perhaps you meant one of these:
20:46:41 <lambdabot>       ‘toList’ (imported from Data.Foldable),
20:47:14 <jamesgoslingisgo> hackrilege this is all in pipes
20:47:15 <hackrilege> because my work is boring and complicated and while it should be my problem im making it his problem as he is the only person who seems to be able to read my work...
20:47:27 <hackrilege> thanks james
20:48:06 <ertes> jamesgoslingisgo: toList = runIdentity . toListM
20:48:17 <hackrilege> i guess my supervisor should be paying him...
20:48:20 <ertes> jamesgoslingisgo: and toListM' gives you the result along with the elements
20:48:39 <jamesgoslingisgo> what does that mean, why would you want a list without elements?
20:49:04 <ertes> jamesgoslingisgo: toListM gives you *only* the elements
20:49:20 <ertes> Producer A M R; elements are of type A, result is of type R
20:49:39 <ertes> toListM gives you [A]; toListM' gives you [A] and R
20:49:55 <hackrilege> ill crowdfund it...
20:50:32 <ertes> jamesgoslingisgo: example:  yield 1 >> yield 2 >> yield 3 >> pure "blah"
20:50:36 <hackrilege> anyway, Free is a very simple datastructure, but working with it is nasty
20:50:40 <ertes> jamesgoslingisgo: example:  xs = yield 1 >> yield 2 >> yield 3 >> pure "blah"
20:50:58 <ertes> toListM xs = pure [1,2,3]; toListM' xs = pure ([1,2,3], "blah")
20:53:05 <jamesgoslingisgo> ertes interesting, where does the result value come from, a consumer at the end of the pipe?
20:53:28 <ertes> jamesgoslingisgo: it comes from the component that terminates the pipeline
20:54:11 <ertes> let xs = each [2,3,5] >> pure "blah"
20:54:35 <ertes> xs >-> P.mapM_ print  -- the pipeline will be terminated by 'xs', and the result will be "blah"
20:55:58 <Guest19729>  #haskell-beginners
20:56:03 <ertes> for example P.take will terminate the pipeline with () as soon as it has produced the given number of elements it has received
20:59:12 <jamesgoslingisgo> ertes bit confused, where is the yield/await in your example?
20:59:31 <ertes> each [2,3,5] = yield 2 >> yield 3 >> yield 5
21:00:35 <ertes> jamesgoslingisgo: less abstract explanation: whenever a component in the pipeline 'await's, the upstream component can either deliver a value (yield) or terminate the pipeline
21:02:58 <ertes> jamesgoslingisgo: (do yield 1; pure "blah") >-> forever (await >>= liftIO . print)  -- the right (downstream) component awaits, the left (upstream) component yields, the right one prints, the right one awaits, but the left component has no more values to yield and terminates the whole thing
21:03:26 <ertes> does that make sense?
21:06:08 <scshunt> doesn't terminating the pipeline mean that the termination flows downstream and then the downstream conduit has to decide what to do?
21:06:31 <ertes> scshunt: this is pipes…  the component that terminates terminates everything
21:06:37 <ertes> in other words, 'await' never returns
21:06:47 <scshunt> oh
21:06:54 <scshunt> hah! some reason I thought it was conduit
21:08:18 <hackrilege> ok, i have neatened up my paste a bit, and added a type which makes it clear why im confused, the type at the bottom should contract...
21:08:19 <hackrilege> http://lpaste.net/163375
21:08:27 <hackrilege> i dont know how to get round this
21:09:55 <Fare> how should I name the class of functors for my category Cat: CatFunctor? Or is it OK to shadow Functor ?
21:11:20 <hackrilege> you can shadow things not in prelude fine
21:11:54 <hackrilege> in this case probably you should make a new name
21:12:16 <hackrilege> unless i misunderstand
21:12:54 <nilof> how do I specify to hasekell that a list is nonempty
21:13:07 <nilof> it keeps throwing exceptions at me
21:13:20 <hackrilege> how do you mean nilof, can we see the code and the bug in a paste?
21:13:32 <hackrilege> what function gives the error?
21:13:36 <nilof> map (head.factorize) palindromeList
21:13:38 <simpson> nilof: Data.List.NonEmpty is the practical thing. What are you working on?
21:13:47 <nilof> where my factorize function always returns a nonempty list
21:14:00 <hackrilege> it should work ok?
21:14:21 <simpson> Always?
21:14:21 <hackrilege> it typechecks ok
21:14:54 <hackrilege> evidently not if it throws an error!
21:16:59 <nilof_> sorry, relogged
21:17:07 <nilof_> did I miss any replies?
21:17:08 <jamesgoslingisgo> ertes i was (still am) a bit vague how >-> interacts with >>
21:17:37 <simpson> nilof_: It always returns a nonempty list? You're sure?
21:17:45 <nilof_> was asking if I can specify that a function returns a nonempty list in the type declaration
21:18:03 <nilof_> well, it is nontrivial for the compiler to see
21:18:03 <Fare> hackrilege, so I cannot shadow something that is in the prelude?
21:18:27 <simpson> nilof_: The typical way to do it is Data.List.NonEmpty, if this isn't homework.
21:18:28 <nilof_> factorizeList :: Integer -> [Integer] -> [Integer] factorizeList n list = if n == 1  	then list    	else factorizeList (quot n (firstFactor n)) ((firstFactor n) : list )  factorize n = factorizeList n []
21:18:31 <nilof_> ah
21:18:38 <nilof_> of course that ended up as a single line
21:18:53 <hackrilege> i dont know, but i know its bad practice, those prelude functions have intuition attatched and if your implementation does something different it would be confusing for the reader
21:19:36 <nilof_> so basically its defined as factorize n = factorizeList n []
21:19:46 <nilof_> where the second function is recursive
21:19:48 <hackrilege> we need a paste for this
21:19:58 <hackrilege> we cant see firstFactor for example
21:20:12 <hackrilege> lpaste.com
21:20:20 <hackrilege> .net sorry
21:20:25 <jamesgoslingisgo> is it common to nest pipes within pipes, for example to mimic nested for loops for a long computation?
21:20:38 <nilof_> it finds the first factor of n, appends it to the list of factors, and calls itself with the new list and the input divided by the first factor
21:21:10 <idev> is there a pure haskell Pdf -> [Png] program ?
21:21:16 <idev> I don't want to use ghostscript (as it often has security issues)
21:21:21 <hackrilege> i dont know what "finds first factor of n" means, i need to see your code!
21:21:21 <nilof_> ah
21:21:24 <idev> I'm wondering if there is a pure haskell model
21:21:26 <nilof_> >.>
21:21:32 <nilof_> it returns the empty list for 1
21:21:41 <hackrilege> bug found
21:21:49 <hackrilege> thats why its good that head throws an exception
21:23:00 <hackrilege> and implementations using [a] which may potentially be [], is still a good idea even if you think your list will always be full, in which case throwing an exception is reasonable
21:23:43 <hackrilege> i dont need to see your code now!
21:24:00 <hackrilege> heres mine; http://lpaste.net/163375
21:24:07 <hackrilege> cant nail that bug to save myself
21:24:13 <ertesx> jamesgoslingisgo: (>>) and (>->) have orthogonal control flow:  you define a component using monadic composition ((>>) and (>>=)) and then you compose components such that one component awaits the values yielded by another
21:24:35 <ertesx> jamesgoslingisgo: so read (>>) as "and then", and read (>->) as "feeding to"
21:24:47 <ertesx> yield 1 >> yield 2  -- yield 1, and then yield 2
21:24:57 <nilof_> huh, it seems to work now
21:25:16 <nilof_> that I defined it to return [1] for 1
21:25:25 <ertesx> jamesgoslingisgo: and nesting is common, because all of the relevant operators are associative
21:25:44 <nilof_> so the compiler figured out that it can't return an empty list in other cases?
21:25:50 <jamesgoslingisgo> ertesx so you have an outer pipe
21:25:53 <ertesx> (a >> b) >> c = a >> (b >> c);  (a >-> b) >-> c = a >-> (b >-> c)
21:25:58 <jamesgoslingisgo> then within one of the pipes you have some sort of
21:26:14 <jamesgoslingisgo> x <- toListM
21:26:20 <jamesgoslingisgo> yield (do something with x)
21:26:26 <hackrilege> no, nilof_ it does not check to see all the possible contents of the list. [] has the same type as [1]. it just checks types so it sees no problem
21:26:35 <jamesgoslingisgo> is that how the nesting structure would work?
21:26:41 <ertesx> jamesgoslingisgo: toListM takes you out of the pipes world
21:26:59 <jamesgoslingisgo> but you could have a toListM within a Pipe function
21:27:05 <jamesgoslingisgo> that then processes the inner pipe
21:27:09 <jamesgoslingisgo> yields something to the outer pipe
21:27:12 <ertesx> sure, if your underlying monad is itself a pipe
21:27:29 <ertesx> Producer A (Producer B m) R
21:27:36 <ertesx> something like that
21:27:52 <ertesx> but that's not very common
21:28:00 <jamesgoslingisgo> or how else would you feed an aggregation of the inner pipe
21:28:03 <jamesgoslingisgo> to the outer pipe
21:28:16 <ertesx> a slightly more common type of nesting is this:  Producer A M (R1, Producer B M R2)
21:28:17 <jamesgoslingisgo> as in a nested for loop type of operation
21:28:41 <ertesx> or the infinite version of that as in pipes-group:  FreeT (Producer A M) M R
21:29:02 <ertesx> i'm not sure what you mean…  perhaps you have a specific application in mind?
21:29:20 <ertesx> because nesting like that is mostly useful for introducing delimiters to producers
21:29:37 <jamesgoslingisgo> effectively it's a long-running computation
21:30:18 <jamesgoslingisgo> i'm substiuting for a nested for loop, that's really all there  is to it
21:30:34 <ertesx> doesn't sound like you would need *any* nesting
21:30:40 <jamesgoslingisgo> so there's an outer for loop. there's an inner for loop with some result
21:30:52 <jamesgoslingisgo> ertesx well but for each item in the outer pipe
21:31:04 <jamesgoslingisgo> i want to do some iteration with an inner pipe
21:31:21 <jamesgoslingisgo> like in that inner pipe i produce 50 values and aggregate them for 1 value going through the outer pipe
21:31:30 <jamesgoslingisgo> can i do that without any nesting?
21:31:33 <ertesx> yes
21:31:48 <jamesgoslingisgo> how so?
21:32:32 <ertesx> sumEach n = do xs <- replicateM n await; yield (sum xs)  -- there are nicer ways to do this, but let's ignore that for the sake of simplicity
21:32:49 <ertesx> awaits n values, yields their sum
21:33:06 <jamesgoslingisgo> ah so :D
21:33:13 <ertesx> sumEach n = forever (do xs <- replicateM n await; yield (sum xs))  -- rather like that
21:33:41 <jamesgoslingisgo> now wait though
21:33:52 <jamesgoslingisgo> i'm not necessarily using n of the outer values
21:34:07 <jamesgoslingisgo> for example the outer values may be a stream 1 .. 10
21:34:26 <ertesx> by "outer" do you mean upstream?
21:34:50 <jamesgoslingisgo> ertesx by outer i mean the equivalent of the outer for loop in an iteration
21:34:58 <jamesgoslingisgo> by inner i mean the equivalent of an inner for loop
21:35:09 <hackrilege> guys, do you want to speak to each other via private message?
21:35:41 <hackrilege> sorrry!! :/
21:35:45 <jamesgoslingisgo> are we being too loud? are you trying to get some sleep?
21:36:03 <hackrilege> im trying to get help with http://lpaste.net/163375
21:36:27 <ertesx> jamesgoslingisgo: /join #haskell-overflow
21:36:32 <hackrilege> and your replacing all the information in my RAM with streams...
21:37:07 <jamesgoslingisgo> by RAM do you mean irc channel or brain? :-)
21:37:21 <ertesx> hackrilege: or in your terms, we're too zippy =P
21:37:47 <hackrilege> yeah i need ddr4 but id have to upgrade the socket in my retena
21:39:07 <hackrilege> my head feels like its zipper is implemented wrong...
21:40:30 <hackrilege> but its getting better at typechecking life
21:45:26 <hackrilege> type Loaf bread = Crust | Slice bread (Loaf bread)
21:46:09 <hackrilege> you cant eat the crust, thats the empty slice, its not of type Slice
21:47:27 * ski eats the crust as well
21:48:05 <Welkin> ski is a dirtyboy
21:49:34 <hackrilege> you cant even be sure thats bread...
21:50:32 <idev> is there a way to tell ghc: "build me a giant staticaly linked executable so I can run it on any linux machine, w/o any *.so problems"
21:51:07 <ski> Fare : quite a mouthful :)
21:52:30 <ski> Welkin : rather parsimonious :)
21:52:42 <ski> Fare : what is `nest' ?
21:53:35 * ski . o O ( The parsimonious filter function, written with a multi-return recursion -- <http://lpaste.net/13301> )
21:53:53 <hackrilege> the trees out of my window have leaves of type Maybe Pigeon
21:53:57 <Fare> ski: (nest (foo bar) (baz quux) (toto tutu)) => (foo bar (baz quux (toto tutu)))
21:54:59 <hackrilege> ooooh ski, can you help me with my type error? http://lpaste.net/163375
21:55:19 <geekosaur> idev, not easily because it really is all or nothing... and statically linking glibc is a recipe for pain
21:55:46 <ski> Fare : ah, right. like a syntactic, combination of `compose' and `apply'
21:55:47 <Fare> that function parses the parameter and return types of the function being wrapped and the API it is mapped to, matches arguments and return values, and generates the wrappers.
21:55:48 <geekosaur> unless you plan to ship a complete glibc with it including the various plugins it wants to load at runtime
21:55:55 <idev> geekosaur: I don't understand why it would be a complete pain
21:56:03 <idev> geekosaur: there are things like busybox which are self contained libs
21:56:10 <idev> geekosaur: what is the pain associalted with linking my own glibc?
21:56:41 <Fare> ski: these are lisp parens, not haskell parens, and since it's syntactic it applies to macros as well as functions
21:56:57 <ski> Fare : yes, i'm aware :)
21:57:09 <geekosaur> you are planning to build from scratch, configured to load nls modules, resolver/nss modules, etc. from your own application's library area?
21:57:24 <Fare> ski: so the point is to not be indented to hell to the right after 19 levels of scoping.
21:57:29 * ski nods
21:57:38 <geekosaur> or are you planning to make it link against uclibc or some other minimalist libc (and hope it's good enough for ghc)?
21:57:49 <idev> geekosaur: I have a machine on digital ocean; it's running ubuntu; it's one job in life is to run this haskell app I have
21:58:04 <idev> but ubuntu and the distro my ghc is on don't match
21:58:36 <geekosaur> the point here is, glibc absolutely insists on loading some things from .so-s at runtime. you cannot stop it from doing so.
21:58:45 <idev> I see
21:59:17 <geekosaur> if you link glibc statically then you must provide those .so-s with it because it will still load them dynamically but they must exactly match the glibc you linked statically. you can't use the ones from ubuntu's glibc
21:59:57 <geekosaur> the linker ill even tell you this if you link glibc statically
22:00:01 <geekosaur> *will even
22:00:27 <hackrilege> geekosaur, ol' buddy, ol' pal, i cant catch my bug... http://lpaste.net/163375
22:00:59 <hackrilege> :D :/ :(
22:01:18 <ski> Fare : fwiw, i've seen something like `(nest-list (n (list 0 1 2)) (foo n (nested (bar))))' which amounts to `(foo 0 (foo 1 (foo 2 (bar))))'
22:01:44 <idev> geekosaur: suppose I'm willing to provide those *.so-s glic need
22:01:45 <idev> wait
22:01:46 <idev> screw it
22:01:52 <idev> at this point, I should just put everything inside a docker
22:02:22 <geekosaur> unfortunately, making ghc link everything but glibc statically is not very easy... your best bet might be to use `ghc -v` to link, note down the exact linker command line it uses, and replace the libc one with the path to libc.so.6
22:02:34 <geekosaur> (full path NOT -lc !)
22:02:47 <geekosaur> glibc makes this annoyingly painful
22:03:04 <Fare> ski: different sort of nesting, that gets much easier with partial continuations.
22:03:08 <geekosaur> any other system it'd be easy. glibc goes out of its way to make life hard
22:03:38 <Welkin> glibc lives a hardknock life
22:03:49 <Welkin> let's put on a musical about it!
22:04:22 <ski> Fare : yes. this version only works with `(nested)' lexically occuring inside the `nest-list' form
22:04:50 * ski ponders how to do it with delimited continuations
22:08:17 <idev> geekosaur: I'm using docker
22:08:23 <idev> you've convinced me I don't want to mess with glibc
22:09:28 * MadRaven peeks through doors
22:09:32 <MadRaven> Hello?
22:09:50 <MadRaven> Anyone?
22:09:51 <hackrilege> hi MadRaven
22:09:54 <MadRaven> Oh hey.
22:09:55 <idev> ski: what's the qustion? I have been doing nothing but studying continuations (as a result of reading LogicT) for th epast few days
22:10:07 <hackrilege> MadRaven, are you new to haskell?
22:10:14 <MadRaven> I should say I am
22:10:27 <MadRaven> Is that a bad thing...? Oh crap, they're right behind me aren't they?!
22:10:28 <Welkin> sam I am?
22:10:31 <ski> idev : implement `nest-list'/`nested' above, using delimited continuations
22:10:54 <hackrilege> MadRaven, if its not Haskell related it shouldnt be here...
22:11:01 <MadRaven> Oh. Sorry.
22:11:09 <MadRaven> What do you guys talk about?
22:11:16 <hackrilege> not that
22:11:16 <MadRaven> And uh, what's Haskell?
22:11:25 <Welkin> hackrilege: if it's not all over the place, it shouldn't be in your face!
22:11:45 <hackrilege> !?
22:11:59 <Welkin> :D
22:12:05 <ski> Haskell. programming. functional programming. type systems. category theory. sometimes math. &c.
22:12:07 <Welkin> it's an ad for a burger restaruant
22:12:19 <MadRaven> I see.
22:12:21 <ski> MadRaven : Haskell is a programming language
22:12:24 <Welkin> haskell should be in your face
22:12:41 <MadRaven> Ah. I believe I am in the wrong area then, as I have never heard of Haskell.
22:12:44 <MadRaven> Good day to you :)
22:12:53 <hackrilege> bye!
22:12:58 <Welkin> o bahan di!
22:12:58 <ski> MadRaven : what channel topic were you looking for, then ?
22:13:35 <Welkin> he mistyped "#hardcoreporn" as #haskell"
22:13:39 <Welkin> happens all the time
22:15:12 <hackrilege> http://lpaste.net/163375
22:15:36 <hackrilege> its actually a pretty interesting bug...
22:15:43 <hackrilege> and the code compiles and is fun
22:15:43 <Welkin> hackrilege is the choo-choo that keeps on chuggin'
22:16:13 <hackrilege> thought it might be nice if the last thing said was haskell related...
22:17:26 <nilof> hmm, it feels sort of nice to see that your solution to project euler problem 4 with haskell is only two short lines long, when the last 10 people to post in the thread all have >10 row solutions in other languages
22:17:36 <nilof> that sort of shows how expressive haskell is
22:18:05 <nilof> here it's mainly because of list comprehensions
22:18:09 <hackrilege> a huge amount of syntax is absorbed into the prelude
22:18:46 <hackrilege> and the paradigm of higher order functional programming neatly abstracts common design paterns
22:18:48 <Welkin> hackrilege: yes, because I rarely say anything haskell related :P
22:19:22 <hackrilege> if i hadnt seen you in action Welkin i would conclude you were some kind of troll...
22:19:31 <Welkin> list comprehensions are not exactly idiomatic haskell
22:19:41 <Welkin> chaining functions together is more like it
22:20:32 <Welkin> hackrilege: I'm a retired haskeller who has been out of service for months now! Get off my lawn! Back in my day...
22:20:36 <hackrilege> list comprehensions are in the syntax of set thoery and so present a reasonable interface to the Free Monoid
22:21:11 <Welkin> I just haven't had a chance to do anything in haskell for a while
22:21:15 <hackrilege> Welkin, you should flex your synapses on my bug
22:21:22 <hackrilege> http://lpaste.net/163375
22:21:23 <Welkin> and my main activity is "web apps" so... yeah
22:23:35 <Welkin> hackrilege: I don't know enough category theory or anything about the Free monad
22:23:58 <Fare> in haskell, do you use camelCase, underscore_separators or what?
22:24:20 <ski> usually `camelCase'
22:24:24 <jle`> camelCase is more of the idiom for normal situations
22:24:28 <Fare> thanks
22:24:34 <ski> <EvanR> does MonadCont have any laws?
22:24:36 <ski> yes
22:24:53 <Welkin> and lol hackrilege 
22:25:04 <Welkin> why is your file in literate haskell when there are not even any comments?
22:25:14 <ski> @where MonadFix_Cont
22:25:14 <lambdabot> "Value recursion in the continuation monad" by Magnus Carlsson in 2003-01-07 at <http://www.carlssonia.org/ogi/mdo-callcc.pdf> (there's also slides at <http://www.carlssonia.org/ogi/mdo-callcc-slides.pdf>)
22:25:18 <hackrilege> there are some comments at the bottom
22:25:22 <ski> EvanR ^
22:28:50 <jle`> Fare: i see people use snake case for things like the names of foreign functions/ffi calls, to emphasize how 'un-haskell' they are, heh
22:28:52 <Welkin> hackrilege: why does it expect a list?
22:29:15 <hackrilege> because thats the parameter to Zipper.
22:29:37 <hackrilege> rather than whatever the hell it actually is, some recursive hellishness resulting from Free
22:30:29 <hackrilege> i have Zipper (Free (Zipper [])) a
22:30:51 <hackrilege> ...
22:31:52 <hackrilege> i think both (left'' eg) and (zfMap left'' eg) work
22:32:08 <hackrilege> you can use them at the ghci prompt to see the code in use
22:32:41 <hackrilege> (to save scrolling up) http://lpaste.net/163375
22:33:11 <Fare> in my diagrams, the category variables are uppercase: A C O S M, etc. Is it OK to have the corresponding Haskell type variables uppercase?
22:33:22 <Fare> or is that too unidiomatic?
22:33:52 <hackrilege> all haskell type variables should be uppercase in the first character
22:33:53 <pavonia> Type variables must be lowercase in Haskell
22:34:07 <hackrilege> polymorphic ones...
22:34:16 <hackrilege> oh variable... yeah sorry
22:34:19 <Welkin> hackrilege: not variables 
22:34:19 <Welkin> lol
22:34:37 <hackrilege> :o
22:36:26 <Welkin> cobreadmonster: do you have crust?
22:36:35 <cobreadmonster> Nope.
22:36:40 <Fare> is it a convention or a compiler-enforced syntactic constraint?
22:36:51 <pavonia> The latter
22:36:54 * hackagebot graphviz 2999.18.1.0 - Bindings to Graphviz for graph visualisation.  https://hackage.haskell.org/package/graphviz-2999.18.1.0 (IvanMiljenovic)
22:41:11 <Fare> if s is a type with class Cat s, is it OK that (obj s) be a type? or should it be (Obj s)? Or should it be another type variable of the class?
22:42:03 <Fare> as in a class (Cat objS arrS) => ...
22:43:50 <ski> idev : fwiw, here's a few more or less silly uses of `callCC', with corresponding Scheme code for comparision <http://lpaste.net/161743>
22:44:16 <hackrilege> not quite sure what you mean, maybe something like (Obj s,Cat s) => , or perhaps (Cat (objS s))
22:44:33 <ertesx> Fare: sounds like a use case for type families
22:44:47 <ertesx> class Cat s where type Obj s; ...
22:44:54 <idev> ski: here's a puzzle ; my favorite recent one
22:45:16 <idev> ski: Logic a = (a -> r -> r) -> r -> r ; we can implement "la >>= alb = la . (flip alb)"
22:45:19 <idev> how crazy/cool is that ?
22:45:32 <idev> it's slightly uglier when we have Logic a = Logic (a -> r -> r) -> r -> r
22:45:56 <ertesx> Fare: but for the common case where Obj s = s, the regular Category type class from Control.Category is sufficient
22:46:43 <FreeBirdTracks> we should find out a bit more what you mean Fare...
22:46:47 <Fare> so this should be OK?
22:46:57 <Fare> class (Cat s) => OperationalSemantics s where run :: Obj s ⟶ Arr s; done :: Obj s ⟶ Bool
22:47:04 <ski> Fare : type variables should start with lower case. however, an associated type `Obj s' specified inside the class (and defined separately, in each instance) would begin with upper case
22:47:53 <Fare> (assuming the long arrow is either -> or some operator to represent functional relations)
22:48:01 <Fare> thanks
22:48:15 <ski> Fare : an associated type implies a functional dependency. for the alternative multi-parameter case `class Cat objS s', you can add an explicit FD `s -> objS', if you like
22:49:06 <ertesx> Fare: first see if your use case maps to Control.Category…  it probably does
22:49:50 <ski> (associated types are a special case of `data'/`type' families)
22:50:18 <ski> idev : yeah, it's fun :)
22:50:25 <ertesx> if the objects of your category are haskell types and the composition operator is an actual haskell function, then Control.Category is the way to go
22:50:58 <Fare> are the two solutions equivalent up to a simple rewrite, or is e.g. the two-variable solution more general?
22:51:01 <ski> idev : backtracking in logic programming can be done as a two-level CPS
22:51:07 <ertesx> idev: out of curiosity, why are you calling that Logic?  it's just List
22:51:16 <hackrilege> had the wierdest dream i had this bug i couldnt fix
22:51:20 <Fare> no, in general, my arrows are not haskell functions
22:51:33 <ski> ertesx : .. depends on where `r' is bound
22:51:37 <ertesx> Fare: your arrows don't have to be
22:52:03 <ertesx> ski: indeed, i was reading a "forall" into it
22:52:12 <idev> ertesx: the more general form is LogicT m a = (a -> m r -> m r) -> m r -> m r
22:52:21 <idev> ertesx: I'm currently studying simple case of m = Identity
22:52:34 <ertesx> ah
22:52:34 <idev> ertesx: however, how is (a -> r -> r) -> r -> r the same as List ? these two types lok ery different to me
22:52:41 <ski> idev : if this is supposed to be a `type' or `newtype', then *please* add an explicit `forall'
22:52:50 <ski> (if that's what you intend)
22:53:01 <ertesx> idev: i can't tell, because i have no idea where 'r' comes from
22:53:17 <ertesx> idev: i assumed that you mean:  Logic a = forall r. …
22:53:38 <ertesx> if it's that, then Logic a ≃ [a]
22:53:39 * ski thinks the fact that GHC adds an implicit `forall' in cases like this is a misfeature, and ought to be removed
22:53:49 <Fare> oh, in this case, my objects are not at the type-level
22:54:21 <Fare> they are base-level entities
22:54:52 <ertesx> Fare: Control.Category makes no assumptions about your morphisms (other than the category laws) and only one assumption about your objects: that they are haskell types
22:55:29 <ertesx> note that haskell types can be many things other than elements of the * kind, due to the DataKinds extension
22:55:59 <ertesx> and Category can deal with those by virtue of the PolyKinds extension
22:56:05 <Fare> my objects are haskell objects
22:56:15 <ertesx> "haskell objects"?
22:56:33 <ski> Haskell values, presumably
22:56:43 <Fare> yes, base-level values
22:56:51 <ertesx> so "values" ;)
22:57:25 <hackrilege> im sure there is a propper name for that...
22:57:50 * ski . o O ( "Haskell programmers knows the value of types .." )
22:57:51 <Fare> although, this is runtime meta-programming, so they represent programs that in their own language have a type, etc. — but I don't think Haskell can type that.
22:58:30 <Fare> "Haskell programmers know the type of everything and the value of nothing yet" ?
22:59:12 <ertesx> Fare: we have fully typed EDSLs…  in fact we use them all the time…  but it's well possible that your specific use case cannot share haskell's type system
22:59:17 <ski> you could perhaps interpret "nothing yet" as `_|_'
23:00:18 <ertesx> anyway, i think you should just learn haskell instead of guessing and guessing and idealising and assuming and guessing, …
23:00:43 * ski thinks they are learning some Haskell
23:00:54 <hackrilege> normal form?
23:01:07 <hackrilege> head normal form? something like that?
23:01:24 <simpson> hackrilege: "value" is the correct term for those things which inhabit types.
23:02:53 <hackrilege> yeah but whats a head normal form?
23:03:39 <simpson> I am gonna defer to WP.
23:03:50 <hackrilege> nvm
23:04:00 <simpson> "In abstract rewriting, an object is in normal form if it cannot be rewritten any further."
23:04:10 <hackrilege> really i just want help with this bug, but its seemingly difficult http://lpaste.net/163375
23:04:16 <ertesx> hackrilege: it's lambda calculus thing that isn't too relevant to haskell
23:04:24 <hackrilege> ah ok
23:04:28 <ertesx> to haskell mostly only weak head normal form and normal form are relevant
23:04:36 <ertesx> and head normal form is something inbetween
23:06:32 <ertesx> hackrilege: one way to get help is to do your homework: don't make people read three screenfuls of code
23:08:01 <hackrilege> i doubt its possible to reproduce that error with less overhead. infact that paste was an attempt (success) at making a much longer paste more readable
23:08:39 <hackrilege> http://lpaste.net/163375
23:08:41 <hackrilege> ...
23:08:45 <hackrilege> but i get your point
23:08:51 <hackrilege> its a nightmare!
23:09:35 <ertesx> you can reduce it a bit by using well known libraries like 'free'
23:11:33 <hackrilege> yeah, and removing the case expressions, but they are not actually the daunting part of this code
23:12:03 <ertesx> i think you have a lot of overengineering in your code
23:12:13 <Fare> ertesx, my "specific use case" is actually a general protocol for representing computing system implementations
23:12:20 <ertesx> for example to me Injector looks like a useless indirection
23:12:21 <hackrilege> how do you mean?
23:12:28 <hackrilege> oh no
23:12:30 <hackrilege> its not
23:12:40 <hackrilege> check the Free instance
23:12:50 <Fare> so my objects are states of computing systems, my arrows are state transitions with effects.
23:13:19 <ertesx> hackrilege: are toInjector and fromInjector supposed to be inverses of each other?
23:13:20 <simpson> Fare: Sounds a lot like a category of objects in the OOP sense.
23:13:22 <hackrilege> basically, if you pull from Free, you need to contain this value wrapped up to some appropriate nesting of Free as its passed into the backwards portion of the zipper
23:14:04 <hackrilege> they used to be called push and pull ...
23:14:13 <Fare> for now, I'm not handling linearity, but possibly for efficiency reasons, I would have to force the threading of access to a computing system :-/
23:14:16 <hackrilege> and yes, they should be inverses. i think the instance i have is good
23:15:00 <ertesx> hackrilege: then every Stack instance includes in its definition a proof that 'Injector f a' is isomorphic to 'a'
23:15:16 <hackrilege> its pretty funky actually, normally a zipper passes the "head" and "cons" it onto the back of the zipper, for Free its the other way round, this seems so coincidental its bizzare
23:15:21 <ertesx> that makes the type…  well…  useless =)
23:15:31 <hackrilege> no
23:15:44 <hackrilege> its needed to contain the value returned from Free
23:15:53 <hackrilege> which is Free s a, not a
23:17:03 <Fare> I'm not sure how exactly to represent that. Probably some kind of type class like class OpSem m objS arrS where advance :: objS -> m arrS
23:17:12 <hackrilege> see line 86
23:17:19 <Fare> where m is some kind of monad
23:17:51 <ertesx> hackrilege: that instance is incomplete
23:18:03 <hackrilege> its not useless. while Basecase a is similar to Recurse (Basecase a) the later is nested more
23:18:43 <Fare> is that good?
23:19:04 <hackrilege> aha! i remember, it is a way to get the container s.... for pushing onto it
23:19:19 <ertesx> hackrilege: as long as toInjector and fromInjector are inverses of each other, they witness an isomorphism (Injector f a ≃ a)
23:19:34 <hackrilege> see line 95
23:20:06 <hackrilege> i can use eg, push (toInjector 1) empty :: Free [] Int
23:20:52 <hackrilege> without the function toInjector i would not be able to make reference to s...
23:21:26 <ertesx> i can't find 'push'
23:21:32 <hackrilege> oops
23:21:33 <hackrilege> injector
23:21:43 <hackrilege> inject
23:21:45 <hackrilege> sorry
23:22:19 <hackrilege> push = inject.toInjector
23:22:35 <hackrilege> but i meant inject...
23:22:54 <ertesx> push :: a -> f a -> f a  -- looks fine to me
23:22:54 <hackrilege> http://lpaste.net/163375
23:23:18 <ertesx> in the Free instance:  push :: a -> Free s a -> Free s a
23:23:24 <ertesx> or rather:
23:23:32 <ertesx> push :: (Stack s) => a -> Free s a -> Free s a
23:23:35 <hackrilege> anywaay, that injector stuff is a nasty hack sure, id love to find a way round it, but it works for now
23:24:04 <ertesx> it's not just a nasty hack, but you include in your code a proof that you don't actually need it =)
23:24:37 <Fare> can I do this? class (Relation (-->)) => (Cat s) => (OpSem (-->) s) where run :: (Obj s) --> (Arr s)
23:24:56 <hackrilege> yeah, i used to have push... heres the version like that, ill try and revert to this version later... http://lpaste.net/
23:25:03 <hackrilege> http://lpaste.net/163395
23:26:17 <ertesx> hackrilege: here is how i would have defined Stack:  class (Alternative f) => Stack f where pop :: f a -> Maybe (a, f a)
23:26:48 <ertesx> it's basically "Uncons"
23:26:50 <hackrilege> yeah thats good thanks
23:27:41 <ertesx> if you refactor Stack and maybe also switch to a well known implementation of Free that doesn't require people to translate back and forth, it's a lot more likely that you get support with your actual problem (or perhaps even figure it out yourself along the way) =)
23:27:43 <hackrilege> i like the defaults though...
23:27:58 <hackrilege> !?
23:28:01 <hackrilege> no
23:28:08 <hackrilege> :)
23:28:58 <hackrilege> all this is discussion of useless symantics
23:29:05 <hackrilege> it is not the bug...
23:29:35 <hackrilege> maybe i get more help if i let everyone else impart their sytax preference, but its not actually helping me!
23:30:10 <hackrilege> i wrote it so it works and it does
23:30:29 <Fare> can a variable type constructor start with : ?
23:30:33 <Fare> and be infix?
23:31:01 <hackrilege> except the bit im stuck at, changing syntax now would be awefully unproductive almost like procrastination, distracting from the important discussion, as is this one!
23:31:09 <ertesx> hackrilege: no need to get offensive…  this is a lot of code, and it is genuinely difficult to understand (give me some credit for trying, and i have failed to understand enough of it to help)…  it takes time to read and understand
23:31:43 <hackrilege> i didnt mean to be offensive i was just explaining why it does not look as nice as it could...
23:32:56 <hackrilege> and yeah, thanks for looking at it
23:33:17 <hackrilege> i like your version of stack also
23:35:31 <ertesx> hackrilege: and i'm explaining *why* you're not getting help…  productivity is a measure of work done, but gains/work ratio…  so doing some work will most likely increase it for you =)
23:35:49 <ertesx> s/a measure of/NOT a measure of/
23:36:04 <hackrilege> Fare, yes but it shouldnt contain letters...
23:36:37 <hackrilege> well i took 1 week to get the last bug
23:36:50 <hackrilege> it was mind boggling
23:37:19 <hackrilege> instance Stack s => Stack (Free s)
23:37:56 <hackrilege> and its awesome now!! try doing (right' (left eg)) to see it in action
23:38:17 <hackrilege> the think is, i do understand your points, which is precisely why its a superfluous discussion
23:39:28 <hackrilege> and more reasonably, the reason im not getting help is because im genuinely annoying
23:39:32 <hackrilege> which is a damn shame!
23:41:42 <hackrilege> one further option is that its because im getting paid to do this and the people helping me are not...
23:42:26 <hackrilege> in which case i concede that i should incorporate all desired syntax improvements
23:42:43 <ertesx> hackrilege: while we're on the topic of productivity: you could have used the last 35 minutes to do that ;)
23:42:50 <ertesx> and the changes are not merely syntactic
23:43:14 <ertesx> your Stack class has lots and lots of members, while mine has only one:  pop
23:43:16 <hackrilege> like i say, this is a superfluous discussion
23:43:28 <hackrilege> mine are just defaults or hacks
23:43:41 <hackrilege> did you see my old version at http://lpaste.net/163395
23:43:58 <hackrilege> its the same as yours but uses MonadPlus over Alternative...
23:44:28 <ertesx> with MonadPlus and Foldable, it should really be empty
23:44:30 <hackrilege> and yeah, im not really sure whats going on with Injector, but really its not the bug, infact, it was the solution to another bug
23:44:49 <hackrilege> ill think about that later...
23:44:50 <scshunt> I have a question
23:44:57 <scshunt> is the following design insane:
23:44:58 <hackrilege> is sounds v bad...
23:45:12 <scshunt> I'm implementing a board game where the game can progress through many phases
23:45:27 <hackrilege> >>=
23:45:35 <scshunt> some things are common to many phases; others are unique to certain phases
23:46:09 <scshunt> does it make sense to have GameState paramaterized on the phase, and then use classy lenses to handle the phase states?
23:46:25 <scshunt> so that way each component is only valid in certain phases
23:47:00 <ertesx> scshunt: if your states are explicit, yeah…  it's ugly though
23:47:19 <scshunt> ertesx: what do you mean by "if they're explicit"?
23:47:26 <hackrilege> like data Phase = Start | Battle | GetBounty?
23:47:51 <hackrilege> and then pattern match on this?
23:47:54 <scshunt> hackrilege: 
23:47:59 <scshunt> *hackrilege: no
23:48:09 <hackrilege> how do you mean i dont understand
23:48:13 <scshunt> data StartPhase = StartPhase { ... }
23:48:19 <scshunt> data BattlePhase = BattlePhas { ... }
23:48:21 <Fare> can I somehow have infix type class variables?
23:48:25 <scshunt> and then
23:48:29 <hackrilege> thats not different...
23:48:36 <scshunt> class CanMove p where ...
23:48:43 <scshunt> instance CanMove BattlePhase where ...
23:48:47 <ertesx> scshunt: a turn-based game type can be designed by behaviour rather than state
23:48:49 <scshunt> instance CanMove MovePhase where ...
23:48:56 <hackrilege> oh ok
23:49:02 <scshunt> ertesx: I'm sure I know what you mean but not in those words
23:49:07 <hackrilege> i see
23:49:22 <ertesx> scshunt: data Game = Phase1 Presentation1 (Move1 -> Game) | Phase2 Presentation2 (Move2 -> Game) | ... | EndGame EndPresentation
23:49:58 <ertesx> scshunt: where the presentation types are used for presenting the game to the player, and the move types are used for making a move
23:50:53 <hackrilege> so that in a different phase if movement can require a different type?
23:51:13 <scshunt> ertesx: hrm
23:51:15 <ertesx> scshunt: here is a two-player guess game, where one player guesses a word, and the other player guesses a number:
23:51:28 <ertesx> they take turns, and the first one who guesses right wins
23:51:32 <hackrilege> Fare,  you can do that with constructors of a datatype
23:51:45 <scshunt> ertesx: that might work for the phase-specific state. Game-overall state would need to be explicit, however
23:51:56 <hackrilege> eg (:)
23:51:57 <scshunt> since that needs to keep passing around, getting updated, etc.
23:52:01 <ertesx> scshunt: nope
23:52:04 <scshunt> no?
23:52:29 <ertesx> scshunt: overall state is implicit…  let's add a twist to it: the overall number of guesses is limited
23:52:51 <hackrilege> are we playing hangman again?
23:53:00 <scshunt> ertesx: right, I know how you do that
23:53:20 <Welkin> hungman
23:53:30 <ertesx> data GuessGame = GuessWord String (String -> GuessGame) | GuessNum String (Integer -> GuessGame) | Draw String Int | WonWord String Int | WonNum String Int
23:53:35 <hackrilege> lol ffs
23:53:42 <ertesx> hackrilege: yeah, indeed
23:53:47 <scshunt> ertesx: please pastebin if you're putting code in
23:53:59 <ertesx> scshunt: that's all the code
23:54:14 <scshunt> ertesx: you have to put the game logic in the functions though
23:54:15 <hackrilege> one line is fine
23:54:39 <ertesx> scshunt: in your game logic, i.e. a value of type GuessGame, you would handle state, for example using recursion or even using a state monad
23:54:42 <ertesx> but it's all implicit
23:54:53 <scshunt> oh, sure
23:54:58 <scshunt> my state is all hiding in a state monad too
23:55:11 <scshunt> I'm not using that interaction method because I'm separating the logic layer and the interaction layer
23:55:15 <ertesx> scshunt: however, if you don't use a state monad, you can switch state types
23:56:00 <hackrilege> ah State, i dont know that yet i should duck out and count some dust
23:56:04 <ertesx> this one draws the border at logic vs. interface
23:56:07 <scshunt> ertesx: There's a natural escape from the state monad at each phase boundary already anyway
23:56:21 <scshunt> so I'm considering using that to change phase types
23:58:07 <scshunt> and zoom handles the rest
