00:04:02 <srhb> tpsinnem: Doubtfully. But things get wonky when you use processes. I would expect you to have to (..phandle) < runInterActiveProcess ...; waitForProcess phandle; doStuffAfter
00:04:25 <srhb> Combined with forkProcess I have no idea what it would do.
00:04:33 <srhb> Possibly nothing.
00:04:35 <srhb> :-)
00:09:11 <shachaf> > foo [Z]
00:09:13 <lambdabot>  []
00:09:22 <shachaf> > foo [S (S (S Z))] 1 2 3
00:09:24 <lambdabot>  [1,2,3]
00:09:42 <shachaf> > foo (Proxy :: Proxy (S (S (S Z)))) 1 2 3
00:09:44 <lambdabot>  [1,2,3]
00:09:45 <shachaf> So much more cumbersome.
00:09:53 <zRecursive> Cv
00:11:16 <srhb> :t foo
00:11:17 <lambdabot> forall (k :: BOX) (proxy :: k -> *) (n :: k) a. Foo n a => proxy n -> a
00:11:22 <srhb> Oh
00:11:30 <srhb> That's pretty nifty.
00:26:04 <fatex> does haskell have a builtlin for "left pad the sting with 0" ?
00:26:39 <shachaf> No, but it has HTTP libraries, so you can use http://left-pad.io/
00:28:48 <srhb> Also Haskell has barely any "builtins". And left padding Strings is inefficient! Pick another type. :-)
00:29:26 <shachaf> I doubt it matters for Strings you want to left-pad.
00:29:33 <srhb> Yeah.
00:31:09 <MasseR> > reverse (take 15 ((reverse "foo") ++ (repeat '0')))
00:31:10 <lambdabot>  "000000000000foo"
00:31:21 <MasseR> inefficient for sure, but simple :)
00:32:49 <srhb> > let pad n xs = replicate (m - length xs) 0 ++ xs in pad 10 "foo"
00:32:51 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Expr’
00:32:51 <lambdabot>      In the first argument of ‘(-)’, namely ‘m’
00:32:51 <lambdabot>      In the first argument of ‘replicate’, namely ‘(m - length xs)’
00:32:53 <srhb> boo
00:33:10 <srhb> > let pad n xs = replicate (m - length xs) '0' ++ xs in pad 10 "foo"
00:33:12 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Expr’
00:33:12 <lambdabot>      In the first argument of ‘(-)’, namely ‘m’
00:33:12 <lambdabot>      In the first argument of ‘replicate’, namely ‘(m - length xs)’
00:33:20 <srhb> > let pad n xs = replicate (n - length xs) '0' ++ xs in pad 10 "foo"
00:33:21 <lambdabot>  "0000000foo"
00:33:22 <srhb> Ugh, damn typos
00:33:25 <MasseR> And this is why I tested with ghci first :)
00:33:32 <srhb> MasseR: That's too pro for me, clearly.
00:35:34 <shachaf> length + replicate is better
00:36:24 <shachaf> Convenient that replicate n returns [] for negative n.
01:01:51 <Arguggi> I'm trying to use the mwc-random lib, does anyone know if I can reuse the same GenIO to generate random numbers in different threads or do I have to call createSystemRandom every time?
01:08:53 <cocreature> Arguggi: having had a quick look at the source it doesn’t look threadsafe, so better make a separate one for each thread
01:09:20 <cocreature> you could ofc wrap it in some sort of lock, but it’s probably faster to create separate generators per thread
01:11:47 <Arguggi> cocreature, just noticed that it does say "This is a somewhat expensive function, and is intended to be called only occasionally (e.g. once per thread)." in the documentation, so calling it once every thread seems the best idea. Thanks!
01:25:00 <ggVGc> hrm.. I am accidentally doing lazu IO...
01:25:02 <ggVGc> https://gist.github.com/ce098e5fabeb929d0ee006fa3b631a71
01:25:09 <ggVGc> could someone tell me why that happens?
01:25:24 <ggVGc> the block I commented in seems to buffer for some reason
01:25:28 <ggVGc> not sure how to get it to evaluate
01:30:12 <fatex> TIL programs rnu much faster under "cabal run" then under "ghci"
01:30:19 <fatex> do ghci code run in interpreted mode?
01:31:23 <srhb> fatex: Yes.
01:31:56 <fatex> that's unfortunate
01:32:01 <srhb> fatex: Why?
01:32:02 <fatex> I thought ghci would compile stuff, link it, then exec it
01:32:06 <fatex> rather than just interpret it
01:32:43 <srhb> fatex: That's what cabal run does.
01:35:20 <srhb> You can also try playing around with -fobject-code
01:37:54 <cocreature> ggVGc: how are you observing that it isn’t evaluated? also you might want to use forM_ instead of & mapM_
01:47:49 <fatex> i'm already using forkIO in my code
01:47:51 <fatex> it's creaing 12 threads
01:47:58 <fatex> but with "top", I only see one thread from "cabal run"
01:48:04 <fatex> do I need to pass options to tell ghc to use more than one thread?
01:48:20 <cocreature> fatex: forkIO creates haskell threads not os threads
01:48:30 <fatex> I have 8 cores
01:48:35 <fatex> should I be using forkOs intead of forkIO?
01:48:45 <fatex> https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:forkOS actually tells me I can use forkIO most of the time
01:49:23 <cocreature> fatex: if you want to distribute your haskell threads on os threads you have to compile with -threaded -rtsopts and run with +RTS -N
01:49:31 <ski> are you using `-threaded' ?
01:49:52 <fatex> no
01:49:57 <fatex> just adding "-threaded" to ghc-options: now
01:50:06 <fatex> where do I specify "+RTS -N" with "cabal run" ?
01:50:49 <lyxia> cabal run -- "+RTS -N"
01:51:18 <lyxia> you put commands to be passed to the executable after "--"
01:51:40 <fatex> *.cabal :   ghc-options: -Wall -fno-warn-orphans -j8 -threaded -rtsopts
01:51:50 <fatex> and:: cabal run -- "+RTS -N" should do it?
01:51:58 <fatex> top still only shows 100%, not 800%
01:53:33 <ski> you could use `threadscope' to view the result of using `-eventlog', and `-ls' to the executable
01:54:17 <fatex> okay, will do that
01:55:36 <ski> run `threadscope' on the `Foo.eventlog' that is created
01:55:43 <fatex> err, it's "+RTS -N8", not "+RTS -N" right?
01:55:45 <fatex> if I want 8 threads
01:55:50 <ski> yes
01:56:16 <cocreature> -N should automatically choose the number of threads by the number of cores
01:56:36 <srhb> You can also bake in that instruction, using -with-rtsopts=-N during compilation
01:56:53 <srhb> (along with at least -threaded, but possibly also -rtsopts?)
02:07:42 <saurabhnanda> is there any easy way to see what Wreq is posting to a remote server?
02:08:22 <peddie> saurabhnanda: tcpdump
02:08:53 <saurabhnanda> peddie: any other way, within Wreq itself. some sort of verbose request/response logging?
02:13:25 <srhb> saurabhnanda: What data exactly are you looking for? Is the requestbody enough?
02:13:47 <saurabhnanda> srhb: complete request/reponse (with headers and content payload)
02:18:19 <Lovepon> GUYS
02:19:31 <Lovepon> :: Maybe (a,b) -> (Maybe a, Maybe b)
02:24:04 <k0ral> Hello
02:24:14 <srhb> k0ral: Hello.
02:24:50 <k0ral> I can't find any decent library to work with tree zippers, did I miss it ?
02:25:49 <IH8|N|199325> hello
02:25:59 <IH8|N|199325> we're here, we're queer, get used to it
02:26:32 --- mode: ChanServ set +o Cale
02:26:35 --- mode: Cale set +b *!*@gateway/web/freenode/ip.172.58.72.172
02:26:36 --- kick: IH8|N|199325 was kicked by Cale (IH8|N|199325)
02:27:52 <Cale> Just when you thought the GNAA trolls were a thing of the past...
02:27:56 --- mode: Cale set -o Cale
02:28:53 <Cale> hmmm! (t -> Cokleisli w a b) -> Cokleisli w a (t -> b)
02:30:43 <Cale> It's amusing how after thinking about things within a certain framework, a simple swap of argument order can be so interesting :D
02:38:44 <sbrg> Cale: GNAA?
02:39:09 <sbrg> googled it, nvm
02:48:22 * hackagebot fquery 0.2.3 - Installed package query tool for Gentoo Linux  https://hackage.haskell.org/package/fquery-0.2.3 (SergeiTrofimovich)
02:56:45 <narender> hi
03:22:38 <boomer> I want to get started with open source. Can anyone suggest a JAVA projects where they are tolerant to newbeis?
03:23:48 <nycatelos> boomer, why are you asking this on a haskell channel?
03:23:50 <srhb> boomer: This channel is about the Haskell programming language. You'll probably have better luck finding a Java channel. Also, how did you reach this channel?
03:23:52 <erikd> boomer: sorry, people in this channel are not likely to be able to heplp.
03:24:23 <boomer> sorry
03:24:25 <boomer> Thank you
03:24:38 <srhb> boomer: I ask because recently a lot of people have entered the channel asking about other topics, and I'm curious where people get the idea to ask their questions here. :)
03:26:22 <boomer> i read somewhere that this is one of the best channels around
03:26:31 <boomer> And the ppl are helpful
03:26:41 <boomer> So it was my first channel
03:27:15 <srhb> boomer: Okay, thanks. :)
03:27:18 <boomer> And I read this while I was looking for JAVA channels
03:27:19 <boomer> http://stackoverflow.com/questions/13271092/freenode-java-or-java
03:27:32 <boomer> And it didn't raise my spirits
03:27:38 <boomer> But thank you
03:27:55 <srhb> boomer: Well, do come back if you decide to learn some Haskell - we do try to be friendly on that topic. :-)
03:27:56 <nycatelos> boomer, if you need to register to join ##java
03:28:23 <nycatelos> /msg nickserv register $password $email
03:32:02 <boomer> It says I need to be identified with services
03:32:10 <boomer> i was already registered
03:32:20 <srhb> boomer: /msg Nickserv identify $password -- I think
03:33:23 * hackagebot werewolf 1.1.0.0 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.1.0.0 (hjwylde)
03:46:15 <bollu> how is someone supposed to think of Kan extensions?
03:46:38 <bollu> like, I can think of two functors being adjoint to each other as some kind of "inverse approximation" to each other
03:46:50 <bollu> so, what's a similar notion that motivates a Kan extension?
03:50:37 <bollu> one more question: what do limits in cat. theory do?
03:53:19 <mpickering> limits give you a very general way of defining other concepts 
03:53:52 <mpickering> you can define lots of other stuff in terms of limits (products, pullbacks, cones etc)
03:58:07 <bollu> mpickering: can you guide me through the definition?
03:58:24 <mpickering> of?
03:59:07 <bollu> limit
03:59:33 <JuanDaugherty> https://en.wikipedia.org/wiki/Limit_(category_theory)
03:59:44 <bollu> :) Yes, I saw that
03:59:48 <bollu> but. it's really abstract
04:00:06 <bollu> I was hoping to take the route of Haskell -> (possibly other math examples) -> cat. theory
04:00:09 * JuanDaugherty imagined the whole channel lolled
04:00:58 <mpickering> err I don't think you really can. 
04:01:32 <bollu> hm, okay :)
04:01:39 * egdfffghff sitting in airport, waiting for delayed plane, thinking about Haskell
04:02:09 <mpickering> So you "take the limit of a diagram" which means you add another object "limF" and arrows from "limF" to all other objects in the diagram
04:03:52 <bollu> mpickering: rules for the arrows from limF to all other objects?
04:05:11 <mpickering> everything commutes
04:05:29 <mpickering> and limF is the universal object with that property
04:05:56 <bollu> hmm
04:07:06 <mpickering> You can read all this on nlab or any category theory book
04:13:51 <amnn_> bollu, which bit of the definition is confusing to you, that might be a good place to start
04:15:24 <bollu> amnn_: I understand what \delta_x and F are in like, the two object category case. \deta_x lets you "pick" one object from C , while F lets you embed J into C
04:15:41 <bollu> consider two categories J and C, where J is the indexing category
04:15:43 <bollu> so as I understand
04:16:13 <bollu> \delta_x :: J -> C maps *every* element of J to one element c of C, and maps *every* morphism of J to the morphism id_c of C
04:16:15 <bollu> correct so far?
04:16:27 <amnn_> I'm not seeing a \delta_x anywhere
04:17:05 <bollu> amnn_: this is what I'm following: https://bartoszmilewski.com/2014/05/08/understanding-limits-2/
04:17:25 <amnn_> ah okay
04:17:55 <amnn_> let me read
04:17:59 <bollu> okay, sure :)
04:22:32 <amnn_> ...this is a really long explanation
04:23:00 <bollu> xD
04:23:08 <bollu> yeah, but I'm focusing on the limits part
04:23:49 <amnn_> okay sure, so do you know what products, pullbacks and equalizers are?
04:24:29 <bollu> products yes. Pullbacks and equalizers no
04:24:33 <bollu> but he seems to explain them along the way?
04:24:50 <amnn_> alright, well no worries, these are easier concepts
04:24:53 <amnn_> (than limits)
04:25:14 <bollu> cool :)
04:25:33 <bollu> okay, so, did I get delta_x right?
04:26:07 <amnn_> in fact, they are all examples of limits, the only thing that differs between them is J and F
04:26:21 <amnn_> well, J, really
04:26:27 <amnn_> bollu, yes, you did
04:26:50 <bollu> okay, now, F is another functor, that embeds J in C
04:26:59 <bollu> i.e, it takes an object in J to some object in C
04:27:23 <amnn_> it's hard to motivate limits if you only know about products
04:27:28 <bollu> and it takes corresponding morphism m :: j1 -> j2 to a morphism F(m) :: F(j1) -> F(j2)
04:28:32 <bollu> now, what I don't understand is why the natural transformation \epsilon = natural transformation from \delta to F  forms the cone / pyramid structure
04:28:54 <bollu> like, what part is the cone?
04:29:01 <amnn_> bollu, are you familiar with natural transformations in general?
04:29:45 <bollu> amnn_: yes, they take functors to other functors, while preserving the functor structure between the two
04:29:49 <bollu> amnn_: correct?
04:30:12 <amnn_> yes, the coherence condition is usually called the naturality square 
04:30:37 <bollu> yeah, so in this case
04:30:49 <bollu> how do the "edges of the cone" get formed by the natural transformation epsilon?
04:31:34 <amnn_> so a natural transformation is defined as a family of morphisms
04:32:17 <amnn_> one morphism for each object in the domains of the functors it is defined upon
04:32:46 <amnn_> in the case of \Delta_X and F, the domain is the index category J
04:33:08 <bollu> okay, I'm with you so far
04:33:51 <amnn_> so for each object Y in J, we define a morphism \Delta_X(Y) --> F(Y) in C
04:34:13 <amnn_> simplifying the definition of \Delta_X(Y), this is actually a morphism in X --> FY in C
04:34:39 <bollu> ohh
04:34:55 <bollu> right, okay. So, let me unpack this
04:35:22 <amnn_> so if you want to imagine the objects of category C all lain out on the floor, and F you highlight the objects and morphisms you are interested in (to make a shape like that found in J)
04:35:33 <amnn_> *with F
04:36:08 <bollu> 1) because a natural transformation "maps functors" together, we take an object in the domain, say y \in J, and we construct a morphism from \delta_x(y) -> F(y) . We do this for every y, which is what gives us our "family of morphisms"
04:36:29 <bollu> however, in our case, \delta_x(y) is _always_the same object x
04:36:33 <amnn_> then you are taking X and hanging it above all the objects you've highlighted, and with the natural transformation, you are drawing the "edges" of a "cone"
04:36:58 <amnn_> bollu, yes, that's right
04:37:46 <amnn_> this is just a cute presentation of cones as a natural transformation from the constant functor.
04:37:50 <bollu> cool, okay, I see how the edges of the natural transform works now
04:38:25 * hackagebot werewolf-slack 1.0.1.1 - A chat interface for playing werewolf in Slack  https://hackage.haskell.org/package/werewolf-slack-1.0.1.1 (hjwylde)
04:38:27 * hackagebot category-printf 0.1.1.0 - Highbrow approach to type-safe printf format specifications.  https://hackage.haskell.org/package/category-printf-0.1.1.0 (CaleGibbard)
04:38:41 <bollu> wait, don't natural transformations have to map morphisms as well?
04:39:20 <amnn_> no, they don't map morphisms
04:39:35 <amnn_> but they have a coherence condition involving morphisms
04:39:40 <amnn_> (the naturality square)
04:40:10 <bollu> ahh, I see
04:40:31 <amnn_> when you choose \Delta_X as your domain functor, this actually simplifies to the coherence condition for cones
04:41:35 <bollu> okay, now in figure 6 (naturality square)
04:41:50 <bollu> He asks us to replace F with \delta_x
04:41:55 <amnn_> if you say c : \Delta_X ==> F is your natural transformation, then the coherence condition is that for any Y, Z in J, and morphism f : FY --> FZ, c_Z = f . c_Y
04:42:38 <amnn_> bollu, yes so FX and FY get sucked together
04:42:50 <bollu> yes, exactly. So the Ff = id
04:43:20 <bollu> and then we get back a cone, correct?
04:43:26 <bollu> but I'm not sure why this example is stuck here
04:43:28 <amnn_> we get the coherence condition for cones
04:43:29 <ij> Problem: irc-client uses conduit and offers a routine "start" and lets you set event handlers. Can I, without changing irc-client's code, make a timer event somehow?
04:44:14 <ij> It could surely run parallel, but I'd like to change the state of the StateMonad that the events run on.
04:45:18 <amnn_> bollu, it is showing the relationship we just described, that coherence for cones is naturality for natural transformations from the constant functor
04:45:22 <bollu> ooh, okay. Because Ff = id, we get the naturality from the diagram. I see
04:46:56 <bollu> okay, now, I understand the "equalizer cone" in Fig. 7
04:47:00 <bollu> as in, I get what he's trying to do
04:47:26 <bollu> he's using p to isolate a "kernel" inside A by indexing A with X
04:47:43 <bollu> and then he's checking that f(p(X)) = g(p(X))
04:47:56 <bollu> so he's using X to "select" the kernel from A
04:48:01 <bollu> correct?
04:48:05 <amnn_> bollu, yes, that's right
04:48:15 <bollu> However, I don't see how this relates to cones / \delta_x
04:48:29 <amnn_> right
04:48:42 <amnn_> well suppose you take J to be the category of 2 objects
04:48:45 <amnn_> A and B
04:49:03 <amnn_> with two morphisms: f, g :: A --> B
04:49:05 <bollu> okay
04:49:20 <bollu> right
04:49:26 <amnn_> ...I've chosen names poorly here, because those are exactly the names that were used in the diagram
04:49:31 <bollu> xD
04:49:37 <bollu> um, re-label things then?
04:49:55 <amnn_> okay, so let's say X and Y are the objects in J
04:50:06 <amnn_> and the morphisms are h, i :: X --> Y
04:50:35 <bollu> okay
04:50:39 <amnn_> ....godammit, Y and Z in J, and h, i :: Y --> Z
04:51:05 <amnn_> (X is the equalizer in the diagram)
04:51:16 <amnn_> okay, so we have J ...finally
04:51:29 <bollu> right, so, next?
04:51:32 <amnn_> then define F : J --> C
04:51:49 <bollu> where C is?
04:52:04 <amnn_> the category that A, B and X live in (from fig. 7)
04:52:46 <amnn_> FY = A, FZ = B, Fh = f, Fi = g
04:52:56 <bollu> I thought X, A and B were themselves categories?
04:53:08 <amnn_> no, they are objects in a category
04:53:13 <bollu> okay
04:53:45 <amnn_> (but the awesome thing about category theory is that if that category happened to be Cat, then they would also be categories)
04:54:01 <bollu> hm. But in general, the kernel is a "collection of objects" right? so when you say p(X), if A is an object and not a category, then your kernel just has one object A
04:54:32 <bollu> I mean, like, the kernel of a group homomorphism is a _set_ of objects, not one object A
04:54:40 <amnn_> right
04:54:52 <amnn_> so your intuition for what equalizers are is correct
04:55:13 <amnn_> but it comes from specialising equalizers to perhaps the category Set, or Grp
04:55:24 <amnn_> in which case you know that the objects are sets (or groups)
04:55:30 <bollu> I see
04:55:51 <bollu> oh, right. so your "object" A can actually be a "collection" in the right Category (eg. Set / Grp / Ring)
04:55:51 <amnn_> equalizers generalise this concept of kernelisation
04:56:14 <amnn_> yes, exactly
04:56:52 <amnn_> so when we say that a particular category "has equalizers"
04:57:17 <amnn_> it, in some sense, means that it has this notion of kernelisation
04:57:28 <bollu> I see
04:58:17 <bollu> now, coming back to J and C
04:58:21 <bollu> where is the cone?
04:59:04 <amnn_> so, Set has equalizers, because, for any two functions, f, g :: A --> B, we can choose a set E, and a function e, such that f(e(x)) = g(e(x)) for all x in E. The simplest way is by picking E to be the subset of A that f and g agree upon, and just letting e by the injection mapping
04:59:07 <amnn_> *e be
05:00:03 <amnn_> bollu, right, so we defined J (h, i : X --> Y), the shape we're interested in, and F, which picks an example of that shape out in C (f, g : A --> B)
05:00:15 <amnn_> *(h, i : Y --> Z)
05:01:13 <bollu> so F maps y -> a, z -> b. h -> f and i -> g?
05:01:22 <amnn_> exactly
05:01:30 <unit73e> Hello! I need to download an html page. How do I do it?
05:01:48 <unit73e> I found this do far: http://hackage.haskell.org/package/download
05:01:57 <amnn_> then, if you define a cone over F, then the object of that cone (the one mapped to by the constant functor) is the equalizer
05:02:08 <bollu> okay, now, if I had to take a guess, I would say that delta_x(_)  = X
05:02:14 <amnn_> yes, exactly
05:02:29 <bollu> so, why does this work out?
05:02:34 <amnn_> when Bartosz decides to name things the same, there's a good reason for it, unlike me :P
05:02:41 <bollu> as in, how is the "cone" idea able to generalize over the equalizer idea?
05:02:42 <bollu> :)
05:03:30 <amnn_> well equalizers are cones over diagrams of type (h, i : Y --> Z)
05:03:50 <bollu> I see, so you just notice the cone structure and exploit it?
05:03:59 <amnn_> I suppose
05:04:11 <amnn_> but more than that
05:04:27 <amnn_> it is very useful to know that a category has "all finite limits"
05:04:35 <bollu> what does that mean?
05:04:42 <bollu> and we haven't yet defined a limit :)
05:04:58 <amnn_> limits are universal cones
05:05:14 <amnn_> so the equalizer is not just any old cone
05:05:18 <bollu> so a limit is a cone through which every other cone factors through?
05:05:24 <amnn_> exactly
05:05:32 <bollu> that must mean that the limit is unique in a cateogyr?
05:05:35 <bollu> category*?
05:05:40 <amnn_> up to unique isomorphism, yes
05:05:52 <amnn_> (for a particular diagram functor)
05:05:56 <bollu> so, each category C has one "limit object" l \in C that is the "apex of the cone"?
05:06:02 <amnn_> bollu, ah, no
05:06:16 <amnn_> given a particular diagram (a particular functor)
05:06:28 <amnn_> the limit object for that diagram is unique
05:06:46 <bollu> oh, so given F: J -> C, there is a unique limit "between" the categories J and C "mediated by" F?
05:07:22 <amnn_> you can consider J to be a shape, or a template, or a type
05:07:31 <amnn_> and F is the thing that picks that shape out in C
05:07:39 <amnn_> C can have many instances of this shape within it
05:08:24 <amnn_> and the limit object is unique for each instance of the shape
05:08:41 <bollu> so what exactly does the delta_x "represent" while picking out a shape? what does F represent?
05:09:17 <amnn_> a particular F represents a single instance of the shape in C
05:09:28 <amnn_> and \Delta_X represents the limit object (which is X)
05:10:37 <bollu> and \Delta_X is what gives you the "apex of the cone", right? which is the "limit object" if it is the apex that every other cone apex factors through?
05:10:43 <amnn_> that is why F is sometimes described as "a diagram of type J"
05:10:58 <amnn_> right
05:11:38 <bollu> limits are really cool :)
05:11:54 <bollu> so if I pick a one-object category for J, what will the limit be for any category C?
05:11:59 <bollu> the initial object is my guess
05:13:11 <amnn_> no, I don't think so
05:13:21 <amnn_> initial objects are examples of co-limits
05:13:45 <amnn_> it is possible to express the terminal object as a limit though, although not as a limit over 1
05:14:13 <bollu> hmm
05:14:31 <amnn_> I'm pretty sure all categories will have limits over 1
05:15:19 <bollu> Nat(ΔV, F) ~ Hom(V, U) <- don't see how this is true
05:15:30 <bollu> oh wait yes
05:15:46 <bollu> no, I don't
05:15:47 <amnn_> if you unpack the definition of what that means, you're saying for any functor F: 1 --> C, I can pick an X in C s.t. there is an arrow from X to all F(*)
05:15:59 <amnn_> which is of course true, you pick X = F(*)
05:16:34 <bollu> hmm
05:16:39 <amnn_> and all cones will factor through this choice
05:16:48 <amnn_> uniquely, becaue the identity morphism is unique
05:18:43 <bollu> amnn_: question: inFig 9
05:18:58 <bollu> Hom(V, U) only has one arrow "h" for some choice of V, right?
05:19:22 <DwarfSock> hi, I have a question that may or may not be haskell related: I'm trying to run the command "stack exec sudo debug" (as I'm told to by "haskell programming from first principles"), but I get an error that says the debug command cannot be found. i tried doing "sudo stack exec debug" as well, but that's not really what i want
05:19:46 <amnn_> bollu, you can't say that in general
05:20:03 <DwarfSock> is there something special I need to do to stack to make it recognize the sudo?
05:20:05 <bollu> Amadiro: why not? 
05:20:22 <bollu> because there might already be morphisms from V to U?
05:20:24 <srhb> DwarfSock: Where are you told this in the book? Especially the sudo?
05:20:25 <bollu> like, more than one?
05:21:05 <amnn_> oh I see,
05:21:14 <amnn_> I think the uniqueness is what is being proven here
05:21:56 <DwarfSock> last chapter, they setup a makefile to more easily run the project, which includes the command "stack exec sudo debug". and it's using sockets, which require administrator priviledges to listen for
05:22:17 <srhb> DwarfSock: Ah.
05:22:19 <bollu> I'm trying to figure out why Nat(\delta_v, F) ~ Hom(V, U)
05:22:25 <amnn_> right
05:22:34 <bollu> Nat(\delta_v, F) consists of the "edges of the cone"
05:22:52 <bollu> from the object V to the lower objects
05:23:00 <bollu> what I don't get is the contents of Hom(V, U)
05:23:11 <srhb> DwarfSock: Aside from the obvious "It's a PATH issue" I'm not sure what's wrong.
05:23:52 <DwarfSock> i can launch properly (at least I get permission denied) when not using the sudo, and sudo works elsewhere, so I'm not really sure what's up
05:23:55 <amnn_> bollu, Nat(\Delta_V, F) is the set of cones from V over F
05:24:04 <amnn_> not the edges of a particular cone
05:24:13 <DwarfSock> srhb: no probs!
05:24:30 <amnn_> Home(V, U) is the set of morphisms from V to U
05:24:30 <bollu> what, how?
05:24:41 <bollu> how is Nat(\delta_V, F) the set of cones?
05:24:46 <amnn_> not the set of all cones
05:24:57 <amnn_> but one object can be the apex of more than one cone
05:25:05 <srhb> DwarfSock: It's probably a bug in the book, really.
05:25:24 <srhb> DwarfSock: I assume you're on a distro that has secure_path set for sudoers
05:25:30 <amnn_> and so Nat(\Delta_V, F) is the set of all cones over diagrams of type F that V is the apex of
05:25:54 <DwarfSock> srhb: i'm on mint
05:26:12 <bollu> amnn_: set of all edges of all possible cones or set of all apexes of all possible cones?
05:26:14 <srhb> DwarfSock: (Maybe try something icky like stack sudo "PATH=$PATH" debug)
05:26:27 <amnn_> bollu, it is actually the set of all *cones*
05:26:41 <DwarfSock> srhb: okay, i'll try that! thanks. really new to the whole linux thing
05:26:47 <bollu> amnn_: what does that mean? how much of the structure constitutes a cone?
05:26:52 <amnn_> not the set of apexes, or the set of edges, but the set of cones, because remember, cones are natural transformations, and Nat(_, _) gives us a set of natural transformations
05:27:09 <srhb> DwarfSock: Or stack sudo -E debug
05:27:55 <amnn_> bollu, well a cone is completely defined by a natural transformation from a constant functor, right?
05:28:19 <bollu> amnn_: right, assuming you have the other functor F : J -> C and the categories J and C
05:28:26 * hackagebot eventloop 0.8.1.0 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.8.1.0 (sebaslafleur)
05:28:28 * hackagebot twentefp-eventloop-trees 0.1.2.4 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and RedBlackTree  https://hackage.haskell.org/package/twentefp-eventloop-trees-0.1.2.4 (sebaslafleur)
05:28:51 <srhb> DwarfSock: Er, I mean stack exec sudo -E debug and stack exec sudo "PATH=$PATH" debug respectively
05:28:51 <amnn_> well, naturally, you must, because a natural transformation from a constant functor must go somewhere (which is our functor F)
05:29:12 <bollu> right :)
05:29:13 <amnn_> but the point is that a cone is completely defined by a natural transformation from a constant functor
05:29:27 <bollu> right
05:29:28 <amnn_> and Nat(\Delta_V, F) is exactly that
05:29:40 <amnn_> a set of natural transformations from a constant functor to a functor F
05:29:50 <bollu> okay, so Nat(\Delta_V, F) "defines" the cone with apex V over the functor F, correct?
05:30:01 <amnn_> right
05:30:12 <bollu> ohh, so if you have the limit U
05:30:20 <bollu> you are guaranteed to be able to factor this cone through U
05:30:26 <bollu> so all you need to know is how to convert V to U
05:30:35 <amnn_> right
05:30:39 <bollu> and you can "get back" the cone with apex V from the cone with apex U
05:30:43 <bollu> damn, that's so slick
05:30:46 <DwarfSock> srhb: none of them worked :( stack didn't recognize the -E, and "PATH=$PATH" only seemed to parse in the command line (with the same error as without "PATH=$PATH")
05:31:43 <bollu> One functor maps V into Hom(V, U) <- why?
05:31:55 <bollu>  maps V into Nat(ΔV, F) <- why again?
05:32:02 <Keiko> Hi everyone, i am running Linux mint and i am used to using Office Outlook for my email with gmail. Can you reccomend a client for Linux?
05:32:21 <srhb> DwarfSock: This was directly in your terminal?
05:32:32 <amnn_> bollu, I'm about to head to lunch, so before I go, I'll leave you with, two questions: (a) terminal objects are limits over diagrams of what type? and (b) what universal construction can be defined as a limit over diagrams of type 2 (the category with 2 objects and only identity morphisms)
05:33:07 <amnn_> bollu, they are just functors that happen to exist, the first one is referred to as the co-variant hom-functor
05:33:10 <Boomerang> Keiko: how about thunderbird?
05:33:12 <srhb> DwarfSock: If so try stack exec sudo -- -E debug
05:33:16 <bollu> I see
05:33:26 * hackagebot stack-run 0.1.0.6 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.0.6 (yamadapc)
05:33:39 <amnn_> or actuallly... the contra-variant hom-functor..
05:33:42 <bollu> Amadiro: thanks :)
05:33:53 <bollu> I want to figure out how this relates to an adjunction as well
05:33:59 <bollu> but I'll come back and to that
05:34:01 <bollu> thanks afain!
05:34:02 <bollu> again*!
05:34:15 <amnn_> no worries, try out those questions, they are both quite cool results
05:34:37 <Keiko> Boomerang: I think this was unorganized, and i had to many mail, got some issues as well. I have tried many from the web and ended up using Thunderbird... but i would like something else
05:34:40 <amnn_> the second one atleast you can do just by unpacking definitions
05:35:11 <bollu> thanks a ton for teaching me :)
05:35:37 <DwarfSock> srhb: still get the sudo: debug: command not found error
05:36:13 <srhb> DwarfSock: where _is_ debug really?
05:36:19 <srhb> DwarfSock: ie `which debug`
05:36:37 <srhb> DwarfSock: Oooh, it's the actual project output
05:36:46 <DwarfSock> yes :)
05:37:54 <DwarfSock> it is one of two executables that builds (the other being the main application)
05:38:14 <DwarfSock> and it's located somewhere in the .stack-work/ folder in my project
05:38:32 <srhb> DwarfSock: OK, so stack exec -- debug works
05:38:34 <srhb> ?
05:39:02 <DwarfSock> yes, only I get a permission denied error when trying to listen to a socket
05:39:22 <DwarfSock> binding a socket *
05:43:50 <srhb> DwarfSock: Does stack exec sudo -- sh -c 'echo $PATH' -- contain the path to the actual executable?
05:45:03 <DwarfSock> srhb: no, only to different /usr/ directories!
05:45:35 <srhb> DwarfSock: Errr...
05:46:22 <srhb> DwarfSock: What's your stack version?
05:46:42 <DwarfSock> 1.1.0
05:46:51 <srhb> DwarfSock: I'd probably recommend asking in #haskell-stack regardless. :-P But you should make sure you have it upgraded first anyway
05:47:39 <DwarfSock> okay, i'll try asking there. I'm running the latest version (at least according to stack upgrade)
05:51:23 <DwarfSock> srhb: thanks for your help nonetheless!
05:59:50 <ski> @tell bollu "wait, don't natural transformations have to map morphisms as well?" -- no and yes ..
05:59:50 <lambdabot> Consider it noted.
06:03:27 * hackagebot github-release 0.1.7 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-0.1.7 (fozworth)
06:03:29 * hackagebot phoityne-vscode 0.0.2.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.2.0 (phoityne_hs)
06:28:28 * hackagebot eventloop 0.8.1.1 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.8.1.1 (sebaslafleur)
06:43:25 <Tritlo> Does anyone have a recent comparison of pipes vs. conduit? Preferably after pipes 4.0.
06:59:00 <fr33domlover> When using running an Attoparsec parser incrementally do I still need to use (<* endOfInput) like with parseOnly?
07:00:41 <Squarism> isnt : case (1,2) of (1,2) -> [] ; _ -> [] 
07:00:45 <Squarism> legit haskell syntax?
07:01:06 <Squarism> even if meaningless
07:02:01 <mauke> > case (1,2) of (1,2) -> [] ; _ -> [] 
07:02:03 <lambdabot>  []
07:02:38 <Squarism> i manage go get parse error on it somehow
07:03:41 <mauke> show your code
07:04:47 <Squarism> let a = case (1,2) of
07:04:47 <Squarism>     (1,2) -> []
07:04:47 <Squarism>   
07:04:51 <Squarism> i found it.. 
07:04:56 <Squarism> it was indentation
07:05:12 <Squarism> i needed 3 tabs relative to the "let" horizontal position
07:05:31 <Squarism> is that obvious? 
07:06:27 <Tritlo> not exactly obvious, but important to distinguish the case expression from the let expression I guess
07:07:04 <Squarism> feels as there must be a rigid explaniation to it
07:07:19 <Squarism> you cant guess the "right amount of tab"
07:07:25 <Squarism> =D
07:07:55 <Squarism> "i feel lucky today, 2 tabs! Damn, parse errors!!"
07:08:17 <mauke> Squarism: layout is based on making things line up with other things, not indentation levels
07:08:24 <mauke> let alone tabs
07:08:51 <mauke> a couple of keywords (such as 'let', 'of', 'where', etc) trigger layout if the following token is not '{'
07:09:16 <mauke> the indentation of that following token sets the base indentation of the following block
07:09:43 <Squarism> "layout" 
07:09:48 <mauke> if a line is indented less than that base, the block is implicitly closed
07:10:04 <mauke> if a line is indented more than that base, nothing happens (it's taken as a continuation of the previous line)
07:10:08 <Squarism> oh ok
07:10:18 <mauke> if a line is indented the same as that base, a ';' is inserted (next statement)
07:10:39 <mauke> in your case you have 2 keywords that trigger layout: 'let' and 'of'
07:11:37 <mauke> the token after 'let' is 'a'. it's not '{', so magic starts
07:11:52 <Squarism> mauke, ok, great to know
07:11:53 <Squarism> !
07:11:56 <mauke> an implicit '{' is inserted and the following block is based on the position of the 'a'
07:12:21 <mauke> the next line (or rather, the first token '(') is aligned with the 'a' above
07:12:29 <mauke> so a ';' is inserted and the block continues
07:13:08 <mauke> and that messes things up because let { a = ...; (1,2) -> [] } ... is a syntax error
07:13:31 <mauke> you need to indent the '(' at least one more than the 'a'
07:17:54 <migimunz> Hi, I'm following schoolofhaskell's "Dependant types in Haskell Pt I", and a piece of code works fine with open type families, but fails to compile when I use closed type families (saying the type function is not injective), and I don't understand why. Here's a piece of code that demonstrates it: https://gist.github.com/migimunz/ae4592509649da13f920db4dc8ef33a2
07:18:39 <migimunz> I don't get it, if it can't prove that a closed type family is injective, shouldn't the same problem arise with open type families?
07:20:43 <migimunz> Oh, nevermind, it has nothing to do with closed type families, I switched the places of n and m on line 24, didn't know that'd matter
07:30:23 <Squarism> in java, when something is fataly wierd, i just throw runtime exception and let everything crash. Can that be done in haskell and how would i do?
07:30:34 <mauke> :t error
07:30:35 <lambdabot> [Char] -> a
07:30:42 <Squarism> i tried : throw Exception and throw SomeException 
07:30:46 <mauke> > error "the impossible happened"
07:30:48 <lambdabot>  *Exception: the impossible happened
07:30:58 <Squarism> ah
07:31:12 <mauke> 'error' isn't really supposed to be caught
07:31:21 <mauke> it's more of an "all is lost" thing than a normal exception
07:31:29 <Squarism> thats what i want
07:31:49 <jaarod> if you are doing it from IO there's throwIO
07:54:46 <cleexiang> ??
07:55:15 <mauke> yes?
08:18:11 <dzdcnfzd> I've been playing around with lambda calculus, and I've found two functions that I think work as the successor function. I'm trying to figure out why only one is used.
08:18:16 <dzdcnfzd> The first is:
08:18:35 <dzdcnfzd> ln . lf . lx . f (n f x)
08:18:56 <dzdcnfzd> The second is:
08:19:02 <dzdcnfzd> ln . lf . lx . n f (f x)
08:19:15 <dzdcnfzd> Why would someone prefer either?
08:19:35 <dzdcnfzd> are they the same?
08:20:16 <byorgey> dzdcnfzd: yes, both work, but only the first generalizes to a way of reresenting any algebraic data tye
08:20:37 <byorgey> type
08:20:55 <dzdcnfzd> byorgey: 1. What does that mean, 2. Do we care in the simply typed lambda calculus?
08:22:15 <nitrix> dzdcnfzd: Haskell uses the \ and -> notation for lambda.
08:23:00 <nitrix> \n f x -> f (n f x)
08:26:09 <ski> @type \n s z -> s (n s z)
08:26:10 <lambdabot> ((r1 -> r) -> r2 -> r1) -> (r1 -> r) -> r2 -> r
08:26:15 <ski> @type \n s z -> n s (s z)
08:26:16 <lambdabot> ((r2 -> r1) -> r1 -> r) -> (r2 -> r1) -> r2 -> r
08:27:07 <dcz> hello guys
08:27:09 <ski> hmm .. this reminds me of Felleisen contexts ..
08:27:26 <ski> hello dcz
08:27:56 <dcz> http://hastebin.com/fabiyifaqi.coffee , in here code , i didnt understand the otherwise part , how it works toDigits(n `div` 10) ++ [n `mod` 10]
08:28:07 <dcz> isnt ++ for concatinating ?
08:28:12 <ski> yes
08:28:28 <dcz> so how :S
08:28:36 <nitrix> toDigits returns a list.
08:28:43 <nitrix> toDigits :: Integer -> [Integer]
08:28:47 * ski gets a blank page when attempting to open dcz's link
08:28:56 <dcz> :D
08:29:09 <nitrix> ski: http://lpaste.net/162659 (repaste)
08:29:14 <ski> also note tht `toDigits' will be unnecessarily inefficient
08:29:22 <dcz> http://lpaste.net/162660
08:29:30 <dzdcnfzd> ski: that's an interesting way of thinking about it
08:29:38 <dzdcnfzd> I don't quite know what to make of the two of them
08:29:42 <ski> oh, you had `toDigitsRev' already
08:29:57 <ski> however, the recursive call is wrong
08:30:00 <dcz> i didnt understand the logic there
08:30:13 <dcz> whats the correct one though ?
08:30:18 <ski> dzdcnfzd : you know Felleisen contexts ?
08:30:26 <dzdcnfzd> ski: haha no
08:30:30 <dzdcnfzd> the types
08:30:35 <ski> oh, ok
08:30:47 <ski> well, just imagine they're all the same `r', if you like
08:31:09 <dzdcnfzd> Is that correct, to do that?
08:31:21 <dzdcnfzd> since it's only the untyped calculus?
08:31:41 <ski> "correct" depends on what you're doing
08:33:53 <dcz> so can anybody explain whats going on there in code ? :D
08:34:05 <nitrix> @let toDigits = (fromIntegral . digitToInt) <$> show
08:34:07 <lambdabot>  .L.hs:274:44:
08:34:07 <lambdabot>      Couldn't match type ‘[Char]’ with ‘Char’
08:34:07 <lambdabot>      Expected type: a -> Char
08:34:16 <nitrix> @let toDigits = fmap (fromIntegral . digitToInt) . show
08:34:20 <lambdabot>  Defined.
08:34:38 <nitrix> > toDigits 12345 :: [Integer]
08:34:40 <lambdabot>  [1,2,3,4,5]
08:34:52 <dcz> i am the newest one at Haskell here :D
08:34:57 <nitrix> > toDigits 12345 :: [Double]
08:34:59 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
08:34:59 <dcz> my first attempt
08:35:26 * ski isn't sure nitrix's version here will help dcz that much 
08:35:47 <ski> <dcz> whats the correct one though ?
08:35:49 <nitrix> I thought the point was there were better ways to write that function. I gave it a try.
08:35:56 <ski> dzdcnfzd : perhaps you can figure it out ?
08:36:17 <ski> <dcz> http://hastebin.com/fabiyifaqi.coffee , in here code , i didnt understand the otherwise part , how it works toDigits(n `div` 10) ++ [n `mod` 10]
08:36:18 <dcz> ski : didnt you say , your attempt is wrong ?
08:36:34 <Lovepon> nitrix: Why would you do thaaaat
08:36:48 <Lovepon> ;~;
08:36:55 <ski> dcz : i have no idea whether this is your code or not. but there is an error in there, right (assuming a reasonable interpretation of what the functions are supposed to do)
08:36:58 <nitrix> Lovepon: I don't assume everyone's a beginner; otherwise it gets on people's nerves D:
08:37:10 <Lovepon> nitrix: But that's ugllyyyyy
08:37:13 <dzdcnfzd> ski: perhaps I can figure it out?
08:37:14 <dzdcnfzd> which?
08:37:26 <ski> dzdcnfzd : sorry, that was for dcz
08:37:28 <dzdcnfzd> dcz's question?
08:37:37 <dzdcnfzd> Oh, okay
08:37:43 <dcz> the only part that i dont have is ++ [n `mod` 10]
08:37:57 <nitrix> Lovepon: Considering the show instance probably does div and mod anyway, I agree.
08:38:18 <ski> dzdcnfzd : anyway, i suppose you could consider how to implement addition, multiplication, exponentiation, with the two different versions of successor
08:38:21 <Lovepon> nitrix: you're hurting my feeeliiingssss
08:38:33 <ski> dzdcnfzd : does the choice of different successor make a difference, then ?
08:38:33 <srhb> nitrix: Unlikely. Also I think it's the best solution. :-P
08:38:34 <Lovepon> nitrix: ;~;
08:38:48 <dcz> who talks to whom ? :D
08:38:51 <Lovepon> srhb: why are you supporting hhiiiiiimm
08:39:18 * ski suddenly got an image in head of two instructors both assuming that the other is a newbie, both attempting to assess the knowledge of the other person
08:39:26 <ski> "What do you think this means ?", "Well, what do *you* think ?", "Well, I'd prefer you'd explain it in your own words."
08:39:27 <srhb> This happens....
08:39:34 <Lovepon> ski: lol
08:40:01 <dcz> nitrix : whats your version of this ? 
08:40:17 <Lovepon> foldr ofc.
08:40:28 <ski> dcz : anyway, i meant to ask you (not dzdcnfzd) : perhaps you can figure it out ?
08:40:31 <dcz> i am following this lectures https://www.seas.upenn.edu/~cis194/spring13/lectures.html
08:40:32 <nitrix> dcz: My version uses `show`, `digitToInt` and `fromIntegral`.
08:40:35 <ski> dcz : iow, where the error is
08:40:40 <nitrix> dcz: And functors.
08:41:03 <dcz> you convert them to what ?
08:41:06 <Lovepon> You want ugly!?
08:41:24 <Lovepon> @let safeDiv n 0 = Nothing; safeDiv n m = n `div` m
08:41:26 <lambdabot>  Defined.
08:41:32 <Lovepon> Wait for a while.
08:41:40 <dcz> woah :D
08:41:50 <Lovepon> Err
08:41:53 <srhb> Lovepon: What the
08:41:54 <dcz> @let and let , whats difference ?
08:41:54 <lambdabot>  Parse failed: TemplateHaskell is not enabled
08:41:56 <Lovepon> Wtf, that's supposed to not work.
08:41:59 <srhb> Oh, there we go
08:42:00 <nitrix> Lovepon: This is supposed to be a type error...
08:42:02 <srhb> Phew
08:42:04 <Lovepon> @let safeDiv n 0 = Nothing; safeDiv n m = Just $ n `div` m
08:42:05 <lambdabot>  .L.hs:283:15:
08:42:05 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ Maybe a
08:42:05 <lambdabot>      Expected type: Maybe a
08:42:08 <Lovepon> WHAT?
08:42:11 <Lovepon> '_
08:42:16 <dcz> :D
08:42:19 <Lovepon> Man, this is so wrong in so many levels.
08:42:19 <ski> nitrix : only a single functor :)
08:42:25 <dcz> you haskell guys are funny :D
08:42:33 <Lovepon> :t safeDiv
08:42:34 <lambdabot> (Eq a, Integral (Maybe a)) => Maybe a -> Maybe a -> Maybe a
08:42:35 <dcz> i loved you already haha
08:42:39 <Lovepon> ......
08:42:40 <nitrix> ski: I meant, the concept of functors would need to be learned to understand the snippet.
08:42:42 <Lovepon> Sweet jesus, wtf?
08:42:51 <dcz> Lovepon : :D
08:42:54 <Lovepon> Can anyone explain this to me?
08:43:00 <nitrix> Lovepon: Can you tune it down a little?
08:43:02 <Lovepon> HOW DIS WORK?
08:43:03 <ski> Lovepon : it's your brainchild. will you now abandon your child ?
08:43:04 <Lovepon> nitrix: Sorry.
08:43:17 <Lovepon> No, seriously. How does that type error?
08:43:19 <nitrix> Lovepon: You're standing out like a sore thumb. This isn't ##programming.
08:43:24 <srhb> :t div
08:43:26 <lambdabot> Integral a => a -> a -> a
08:43:37 <dcz> :D
08:43:44 <Lovepon> nitrix: I'm trying to make this really work though. :|
08:43:44 <srhb> nitrix: That's a rather unfortunate way to treat channel members
08:43:45 <mauke> Lovepon: because it doesn't have the same type as your previous definition
08:43:58 <mauke> which you never removed
08:44:03 <Lovepon> mauke: Oh.
08:44:16 <srhb> Better to stick to > let ... in ... for sanity :-P
08:44:24 <Lovepon> mauke: How do I undefine it?
08:44:29 <mauke> @undefine
08:44:29 <lambdabot> Undefined.
08:44:39 <srhb> It nukes all the things, by th e way.
08:44:47 <Lovepon> @undefine saveDiv
08:44:47 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
08:44:51 <Lovepon> Oh.
08:44:57 <dcz> :D
08:45:01 <dzdcnfzd> ski: as functions, they have different results
08:45:03 <Lovepon> @let safeDiv n 0 = Nothing; safeDiv n m = Just $ n `div` m
08:45:05 <lambdabot>  Defined.
08:45:07 <mauke> '@let' should only be used for gently trolling #haskell
08:45:09 <Lovepon> mauke: Thanks.
08:45:12 <ski> in my day, that's just silently undefine everything anyway ..
08:45:18 <dcz> guys can you just explain what this code means ? :D " toDigits(n `div` 10) ++ [n `mod` 10] "
08:45:39 <srhb> dcz: Which part is unclear?
08:45:40 <nitrix> dcz: If you divide 123 by 10, what do you get?
08:45:48 <ski> dzdcnfzd : even when you only pass valid naturals for the `n' parameter, and so ?
08:45:58 <dcz>  i didnt understand the ++ thing there
08:46:04 <srhb> That's just list concatenation
08:46:05 <dcz> why we combine the numbers and the list
08:46:08 <dcz> ?
08:46:16 <dzdcnfzd> ski: no, when you pass valid naturals, they're the same
08:47:00 <lyxia> dcz: it concatenates the list "toDigits (n `div` 10)" and "[n `mod` 10]"
08:47:01 <dcz> nitrix my question is not about maths :D
08:47:04 <mauke> dcz: what numbers and what list?
08:47:09 <nitrix> dcz: The left side of ++ recursively divides by 10 and builds a list. Which means for the number 12345, it'll yield 4, then 3, then 2, then 1, and build the list [1,2,3,4]. The 5 is missing.
08:47:18 <dcz> toDigits(n `div` 10) is the number
08:47:20 <nitrix> dcz: Thus the right part of ++ is concatenating ++ [5]
08:47:25 <dcz> [n `mod` 10] is the list
08:47:27 <nitrix> dcz: Which is the modulo of 10.
08:47:29 <mauke> dcz: no, toDigits doesn't return a number
08:47:38 <dcz> ahhh i see now
08:47:54 <dcz> so we concatinating the returning number with existing list
08:47:55 <dcz> okeeeeeey
08:48:08 <dcz> alright , stupid me
08:48:14 <nitrix> Not sure what this means.
08:48:27 <dcz> okey okey i got it 
08:48:43 * ski returns a number to the number library
08:48:46 <dcz> thank you guys
08:48:46 <Lovepon> @let toDigits' = unfoldl (\x -> 1 `safeDiv` x >> Just (divMod x 10)) 
08:48:47 <lambdabot>  .L.hs:145:13:
08:48:48 <lambdabot>      Not in scope: ‘unfoldl’
08:48:48 <lambdabot>      Perhaps you meant one of these:
08:48:50 <Lovepon> ...
08:48:59 <dcz> ... :D
08:49:04 * ski smiles quietly inside
08:49:34 <Lovepon> IMO, that's better. :|
08:49:35 <dcz> skie :D
08:49:58 <dcz> i am the beginner, so i dont get your way at all :D
08:50:16 <Lovepon> > let unfoldl f x = reverse (unfoldr (fmap swap . f) x)
08:50:17 <lambdabot>  <no location info>:
08:50:17 <lambdabot>      not an expression: ‘let unfoldl f x = reverse (unfoldr (fmap swap . f) x)’
08:50:23 <Lovepon> I'll take this to PM for now.
08:50:27 <srhb> Lovepon: let ... in ... :)
08:50:48 <dcz> srhb : you are funny though :D repating the same words 
08:51:03 <Lovepon> Question. If I define something in PM, will it work here too?
08:51:13 <srhb> Lovepon: If it's the same lambdabot, yes.
08:51:15 * ski . o O ( `let' ! .. `let',`in' ! .. `let',`in',`do' ! )
08:51:16 <Lovepon> Okay.
08:51:25 <srhb> It's really just one .hs-file
08:51:47 <srhb> Lovepon: (assuming no one @undefine s ;))
08:52:06 <Lovepon> @let toDigits' = unfoldl (\x -> 1 `safeDiv` x >> Just (divMod x 10))
08:52:07 <lambdabot>  Defined.
08:52:11 <Lovepon> There we go.
08:52:17 <Lovepon> > toDigits' 123
08:52:19 <lambdabot>  [1,2,3]
08:52:30 <dcz> :D
08:52:34 <Lovepon> Does anyone like what I did with (1 `safeDiv` x)?
08:52:52 <srhb> I prefer the stringly version... :-P
08:52:53 <ski> you repeat the division, so .. no
08:53:12 <Lovepon> ski: The division is not evaluated though!
08:53:37 <ski> it still feels wrong
08:53:45 <Lovepon> ski: It's meant to feel wrong. :P
08:54:05 <Darwin226> Hey guys. How can I add a C++ file into my haskell project so that it automatically gets compiled with it and that I can use FFI to call functions from it?
08:54:18 <Darwin226> All the functions I want to call are declared as extern "C"
08:54:28 <Darwin226> I've added the file in c-sources in the cabal file
08:54:46 <Darwin226> And it seems to compile when I build the project, but when I run the repl it complains about some missing symbols.
08:55:24 <dcz> how can i access nth element in the list repeadetly , for example every 2nd element
08:55:37 <dcz> for [10 , 1 , 4, 3]
08:55:41 <srhb> dcz: Which list functions are you comfortable using?
08:55:42 <dcz> 10 and 4 
08:55:57 <Lovepon> dcz: I'd use chunksOf, then head.
08:56:04 <Lovepon> The problem is, chunksOf doesn't seem standard.
08:56:12 <dcz> whats that ? 
08:56:20 <Lovepon> dcz: chunksOf takes, well, chunksOf.
08:56:26 <srhb> Lovepon: I don't think it has any pedagogical value either. :-)
08:56:36 <geekosaur> define standard
08:56:47 <nitrix> Lovepon: Standard?
08:56:48 <Lovepon> geekosaur: Part of the stdlib.
08:56:52 <Lovepon> That's what I meant.
08:56:53 <geekosaur> there is no stdlib
08:56:58 <srhb> Sure, there's base!
08:56:59 <Lovepon> Part of base?
08:57:02 <geekosaur> there is base, which is the minimum needed for the compiler to work
08:57:07 <Lovepon> I see.
08:57:24 <Lovepon> Anyways, I don't think that chunksOf is in the Haskell Platform either.
08:57:35 <geekosaur> as part of Data.List.SPlit, it is
08:57:44 <Lovepon> geekosaur: Ah, thanks.
08:58:10 <dcz> take you to the back oldschool
08:58:13 <Lovepon> srhb: What would you use?
08:58:22 <Lovepon> srhb: Just for reference.
08:58:32 <srhb> Lovepon: I would probably use it as an "in" to reinforce pattern matching knowledge
08:58:34 <geekosaur> and in any case it seems that the whole notion of a standard library is deprecated these days; any number of people will tell you the Platform is evil and you should be overjoyed to have to install libraries to do anything
08:58:54 <srhb> Lovepon: ie. defining the explicitly recursive solution.
08:58:57 <geekosaur> and use special tools with magic caching to cover up that you have to install those libraries each time
08:59:17 <Lovepon> srhb: Ah.
08:59:31 <tpsinnem> hm, it's not mentioned in the docs, but apparently waitForProcess in System.Process in the 'process' package will only work on child processes of the calling process. is there an alternative that will wait on the termination of *any* process, as long as you have the handle?
08:59:33 <srhb> Lovepon: Then generalize to n :)
08:59:46 <nitrix> Using only base...
08:59:59 <Lovepon> srhb: IMO, keeping it simple is best.
09:00:24 <dcz> [_,n..] will work for something like this
09:00:27 <Lovepon> srhb: That's too... how do I say it, iterative for me?
09:00:33 <geekosaur> tpsinnem, maybe in the platform specific ones (System.Posix,Process and whatever the win32 equivalent is)
09:00:47 <nitrix> I'd use zip and a filter I think.
09:00:58 <Lovepon> nitrix: Ah, that also works. :)
09:01:13 <dcz> nitrix, the instructions i am following doesnt include zip and filter so on...
09:01:22 <Lovepon> nitrix: And cycle.
09:01:32 <srhb> dcz: What do they give you to work with?
09:01:33 <dcz> so i thought i can do that with in the instructions only 
09:01:46 <srhb> dcz: There's probably a point to the restrictions imposed. :) Or at least, an intention.
09:01:47 <nitrix> Lovepon: Either cycle or a modulo operation on the fst
09:01:49 <dcz> here, i am following https://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
09:03:30 <tpsinnem> geekosaur: doesn't look like it, unfortunately :(
09:03:33 <srhb> dcz: I would suggest using pattern matching and defining an explicitly recursive solution.
09:03:38 <srhb> dcz: I think that's the intention.
09:04:07 <srhb> dcz: In the introductory material, they show you how to get at the "every second element" with pattern matching as part of a more complex function "sumEveryOther"
09:04:22 <srhb> sumEveryTwo, apparently.
09:04:28 <geekosaur> I was wondering how you went about getting a ProcessHandle for a non-child process, since you probably blew past portability and are holding junk
09:05:54 <ski> geekosaur : hm, it's not possible to get a handle to the current process ?
09:06:11 <geekosaur> not a System.Process.ProcessHandle
09:06:21 <DwarfSock> http://lpaste.net/162662 can someone tell me why this can't be parsed? I've imported Text.RawString.QQ and added the quasiquote pragma.
09:06:40 <nitrix> @let takeEveryN n xs = map snd $ filter ((\x -> x `mod` n == 0) . fst) $ zip [1..] xs
09:06:42 <lambdabot>  Defined.
09:06:46 <nitrix> Naive solution
09:06:55 <nitrix> > takeEveryN 3 [1..10]
09:06:56 <lambdabot>  [3,6,9]
09:06:58 <nitrix> > takeEveryN 2 [1..10]
09:06:59 <lambdabot>  [2,4,6,8,10]
09:07:00 <srhb> DwarfSock: What's the library, error, ...
09:07:10 <srhb> DwarfSock: (And does it need a semicolon at the end?)
09:08:29 <srhb> DwarfSock: Or is Query just a String?
09:08:35 <DwarfSock> it's Data.Text
09:08:37 <DwarfSock> i think
09:08:38 <geekosaur> (note that ProcessHandle is not necessarily what the OS uses as a process ID, it's something specific to System.Process. if you want to do anything outside what System.Process provides, you are necessarily going to have to use the platform specific stuff, which does not use ProcessHandle)
09:08:41 <tpsinnem> geekosaur: what I'm doing is something like "do (i,o,e,phandle) <- runInteractiveProcess blah blah ; forkProcess $ waitForProcess phandle ; ... "
09:09:02 <geekosaur> right, you don't own that and you can't do that portably
09:09:21 <tpsinnem> ok i'll have to chew on that
09:09:36 <geekosaur> with the Posix functions you can use the binding for waitpid. I don't know what you do on win32 but its process handling is very different
09:09:56 <DwarfSock> srhb: yup it's a newtype wrapping text
09:10:20 <tpsinnem> geekosaur: i'll note that i don't have portability in mind in this case
09:10:33 <DwarfSock> srhb: (ps: I have overloadedStrings enabled aswell)
09:10:35 <geekosaur> good, so you have some chance of being able to do this
09:10:45 <srhb> DwarfSock: Well that would be a type error anyway
09:11:04 <srhb> DwarfSock: I get no error, but your example is obviously not complete.
09:11:28 <tpsinnem> geekosaur: in any case, the above doesn't work because phandle is not a handle of a child process of the forked process :/
09:11:29 * ski . o O ( sound, but not complete )
09:11:31 <geekosaur> the point there was not "you have to be portable", it was "you CAN'T be portable and you are well beyond what System.Process is capable of dealing with given it is restricted to the few portable process operations"
09:11:44 <geekosaur> tpsinnem, I guess I am not being clear
09:11:48 <geekosaur> you can't use ProcessHandle
09:11:56 <geekosaur> youc an't use System.Process. AT ALL
09:12:06 <geekosaur> use System.Posix,Process
09:12:25 <srhb> DwarfSock: http://lpaste.net/8489202116961763328
09:12:29 <geekosaur> System.Posix.Process (why do I keep typing that comma)
09:12:47 <tpsinnem> geekosaur: ok, thanks, i will indeed look into that
09:13:10 <justin_timberlak> hi
09:13:28 <tpsinnem> i wonder if there is posix-specific stuff that is as convenient as the functions in System.Process
09:14:15 <geekosaur> not generally, because the POSIX process model has too many edge cases
09:14:24 <srhb> DwarfSock: Did you accidentally not put the language pragmas at the very top of your file? I'll stop trying to psychically debug now, paste the actual file if you're still stuck. :-P
09:15:22 <geekosaur> at some point a binding for posix_spawn should be added, but it's too new to be available everywhere
09:15:27 <DwarfSock> srhb: no they're up there starting at line one. doesn't seem to help, I'll post the whole file
09:15:33 <geekosaur> and still has unresolved edge cases
09:16:51 <DwarfSock> srhb: http://lpaste.net/162663
09:17:26 <geekosaur> (there are emulations of posix_spawn in userspace but they all have significant shortcomings because it's hard to get this stuff right everywhere :/ )
09:17:32 <mauke> DwarfSock: "LANGAUGE"
09:18:12 <DwarfSock> mauke: sheesh. thanks
09:21:53 <Lovepon> Hmmm
09:28:04 <dfeuer> Data.IntMap defines  adjust ::  (a -> a) -> Key -> IntMap a -> IntMap a
09:28:04 <dfeuer> adjust f k m
09:28:04 <dfeuer>   = adjustWithKey (\_ x -> f x) k m   Won't that allocate a closure to pass in to adjustWithKey? Wouldn't it be faster to implement adjust directly?
09:29:52 <ggole> That function is closed (apart from f)
09:30:22 <monochrom> it is possible, but look out for INLINE, RULES, and other optimizations
09:30:31 <ggole> Besides, it might be compilermagicked away
09:32:13 <blaird> Hey! I should know how to do this, but I haven't written much haskell in a year. How can I check if a list of the type "X [Window]". I can't just do "== []" right?
09:32:19 <monochrom> get the Core code of a typical usage before you believe anyway
09:32:27 <monochrom> s/anyway/anything
09:32:35 <Lovepon> blaird: Nope.
09:32:52 <monochrom> use :type in ghci to check types
09:33:04 <tpsinnem> does there exist something like MVar, but for inter-process rather than inter-thread communication?
09:33:07 <mauke> besides, never write == []
09:33:08 <dfeuer> monochrom, you think once it sees a specific function it might be all different? -ddump-simpl looks like it's allocating a closure, but I could be misreading of course.
09:33:11 <jaarod> blaird check where?
09:33:38 <monochrom> -ddump-simpl is trustworthy for this
09:33:54 <dfeuer> monochrom, my reading thereof is less so :P
09:34:20 <monochrom> but be sure you're trying somewhat realistic code
09:35:27 <monochrom> yeah, realistic code usually provides a specific f.
09:35:37 <geekosaur> blaird, how you;d do that generally depends on what youre going to do afterward
09:35:58 <tpsinnem> ^ ok i'm reading about ipcvar
09:36:23 <dfeuer> I may leave it alone for right now. I'm mostly interested in avoiding following some pointers totally unnecessarily; I'll swing back around for this sort of thing at some point.
09:38:04 <blaird> geekosaur: Basically I'm just trying to see if any window exists that has a certain property (in any workspace)
09:38:34 * hackagebot process-streaming 0.9.1.2 - Streaming interface to system processes.  https://hackage.haskell.org/package/process-streaming-0.9.1.2 (DanielDiazCarrete)
09:38:39 <blaird> geekosaur: I couldn't find anything that made that kind of test though, but I did find one that returned a list of all windows with that poperty
09:39:23 <dfeuer> WAT.
09:39:30 <blaird> geekosaur: So I just need to see if it's empty. After that my code all works
09:39:44 <fatex> in ghcjs/reflex, is there a function for fetchJSON :: URL -> IO JSON, where URL = String, and JSON = a Data.Aeson encoded string?
09:40:08 <geekosaur> (fmap null) will give you an X Bool, what happens after that depends but you probably want either do notation (p <- fmap null whatever; if p then ...) or >>=
09:40:13 <mauke> blaird: X [Window] is not a list
09:42:55 <ffaas> Is there a functional programming irc for non-haskell users like JavaScript?
09:43:08 <Lovepon> Why is Prelude not safe by default?
09:44:11 <monochrom> dfeuer: I have tried "u k m = adjust not k m" and "u2 k m = adjust negate k m :: IntMap Int". they have specific f's and still build the closures as you anticipated. with -O2 too.
09:44:13 <tobiasBora> Hello,
09:44:16 <simpson> Lovepon: In the Safe Haskell sense? Probably because it's hard to do.
09:44:33 <blaird> geekosaur: You're the best! Looks like it's working
09:44:45 <blaird> geekosaur: Thanks
09:44:49 <Lovepon> simpson: Hard, in "using it" sense, or in "implementing it" sense?
09:45:13 <simpson> Lovepon: Mostly in the "designing it" sense. This kind of safety is exhausting to implement.
09:45:24 <Lovepon> simpson: I see, you're right.
09:46:20 <tobiasBora> I would like to sort a list based on an impure compare function (the sort isn't really perfect, it looks like comparing chess gamers, sometimes some comparative may be wrong, but I would a "not so bad sort"). Is there any way to easily do that in Haskell ? If not, do you know some easy to implement algorithms ? I saw the Elo algorithm but I'm not sure it's exactly what I need since I can compare the elements
09:46:22 <tobiasBora> I want)
09:46:42 <dfeuer> monochrom, that's not totally reliable, since I'm using a modified (very clearly better) adjustWithKey:  https://gist.github.com/treeowl/690ab82512eb08d30afbb35b34cfd86d which could theoretically be optimized better, although thanks to the recursion I doubt it.
09:47:45 <dfeuer> monochrom, that's the lazy version for Data.IntMap.Base. The strict version has the strictification stuff.
09:48:16 <Karlodun> hello, I hope somebody is here, I have several questions for haskell
09:48:27 <Walther> !ask
09:48:32 <Karlodun> first I need a list comprehension
09:48:53 <Karlodun> which creates an endless list of touples (a,b)
09:49:19 <Karlodun> where a and b <--[1..]
09:49:40 <Karlodun> but it must be "created" in a "fair way"
09:49:59 <Karlodun> if I need to check certain elements with elem, it must proc
09:50:47 <Walther> > take 10 $ zip [1..100] (tail [1..100])
09:50:49 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
09:51:26 <Karlodun> with ff = [(a,b) | a <- [1..], b <- [1..a]] , I get some of the necessary pairs, but not all
09:52:47 <opqdonut> Karlodun: you mean you're missing the ones where b>a?
09:52:51 <Karlodun> I expect something like [(1,1),(2,1),(2,2),(1,2),(3,1),(3,2),(3,3),(1,3),(2,3),(4,1),...
09:52:55 <opqdonut> right
09:53:10 <Karlodun> yes, kind of
09:53:24 <opqdonut> > concat [[(a,b), (b,a)] | a <- [1..], b <- [1..a]]
09:53:25 <lambdabot>  [(1,1),(1,1),(2,1),(1,2),(2,2),(2,2),(3,1),(1,3),(3,2),(2,3),(3,3),(3,3),(4,...
09:53:31 <opqdonut> that doubles some pairs though
09:53:57 <lambdafan> If the time complexity of f is O(log^2(n)) and map is O(n) what is the complexity of map f?
09:54:23 <opqdonut> > concat [nub [(a,b), (b,a)] | a <- [1..], b <- [1..a]]
09:54:24 <lambdabot>  [(1,1),(2,1),(1,2),(2,2),(3,1),(1,3),(3,2),(2,3),(3,3),(4,1),(1,4),(4,2),(2,...
09:54:28 <opqdonut> that gets rid of the duplicates I think
09:54:38 <monochrom> clearly, map is not O(n), instead it's O(n * f's time)
09:55:10 <opqdonut> lambdabot: it's something like O(m*log^2(n))
09:55:24 <opqdonut> where m is the length of the list and n is the maximum size of an element in the list
09:55:26 <monochrom> semiclearly, you're using the same "n" for two unrelated things
09:55:30 <opqdonut> yeah
09:55:36 <Karlodun> thanks, that might help, even though it is not exactly the way I needed it
09:56:26 <opqdonut> Karlodun: you might be interested in: http://www.cs.ox.ac.uk/jeremy.gibbons/publications/rationals.pdf
09:57:37 <Karlodun> what does gcd do?
09:57:45 <Karlodun> this one:
09:58:00 <opqdonut> greatest common divisor
09:58:01 <opqdonut> look it up
09:58:02 <Karlodun> gcd :: (Integer,Integer) → Integer
09:58:02 <Karlodun> gcd (m,n) = if m<n then gcd (m,nmodm) else
09:58:02 <Karlodun> if m>n then gcd (mmod n,n) else m
09:58:02 <Karlodun> gcd :: (Integer,Integer) → Integer
09:58:04 <lambdafan> monochrom: good point. I htink I found out what I need to know. The way I am generating fibonacci numbers is way too slow. Even though the function that finds the nth fibonacci number is O(log^n), I never took into account the time complexity for map
09:59:06 <lambdafan> Say I wanted to find the first 5 fib numbers. I was doing this map f [1 .. 5] where f found the nth fib number
09:59:48 <opqdonut> if you want the first n fibonacci numbers it's best to just use the definition
10:00:01 <opqdonut> you get them with O(n) additions
10:00:30 * lambdafan listens and nods
10:00:47 <opqdonut> even though the log-time algorithms are cool :)
10:02:14 <lambdafan> opqdonut: I was taken in by the advertising "fastest fib in the west". True, but I wasn't using as intended.
10:02:35 <geekosaur> taken in by a fast fib...
10:02:36 <opqdonut> is it matrix exponentiation or Z[sqrt(5)]?
10:02:53 <monochrom> yes
10:02:59 <opqdonut> or, shudder, phi^n
10:03:03 <monochrom> err, matrix exponentiation
10:03:53 <opqdonut> I've always preferred the Z[sqrt(5)] field extension approach
10:04:48 <opqdonut> (see e.g. http://pages.cs.wisc.edu/~mhock/SSL/fibcalc.pdf)
10:07:01 <Karlodun> ok, next question: I have my own data: "data Obj = Obj Name Coord1 Coord2 deriving(Eq,Show)
10:07:44 <Karlodun> with: type Name = string; type Coord1 = Float; type Coord2 = type Float
10:08:25 <Karlodun> and "data Basket = Basket Name [Obj]
10:08:36 <Karlodun> then I defined several Objects
10:08:47 <Karlodun> and defined the Basket to have them
10:09:32 <Karlodun> I know how to access data of my objects via matching
10:10:16 <Karlodun> like: "getName (Obj name _ _) = name
10:10:37 <Karlodun> is there a way to access them without making an extra function?
10:10:51 <Karlodun> and how can I access the names of objects in my basket?
10:10:59 <mauke> case ... of { ... }
10:12:22 <Karlodun> ?
10:16:51 <Karlodun> any good sources that describe me how to access stuff from my own data in haskell?
10:17:41 <mauke> any haskell introduction, tutorial, or book
10:19:07 <monochrom> Karlodun: use "record syntax", you will get the functions.
10:19:38 <jaarod> Karlodun you can pattern match with case. you can use named records. or you can use lenses (probably ignore that for now)
10:22:47 <Karlodun> I can get acces to the data of my objects, but not to the data of objects, stored in basket
10:23:26 <jaarod> data Person = Person { name :: String, age :: Int }
10:23:31 <jaarod> creates name and age functions for you
10:23:48 <monochrom> combine list access with field access
10:24:03 <ski> Karlodun : fetch the desired object from the list, then fetch the data inside it
10:25:08 * ski . o O ( "Fetch the Gordosa." )
10:34:18 <Karlodun> here the example code: http://pastebin.com/qpAqW92L
10:34:32 <Karlodun> I have made functions with pattern matching, to access the object data
10:34:57 <Karlodun> but somehow I fail to access the object list of the basket
10:35:10 <Karlodun> hope I could make my question more clear
10:35:12 <ski> i don't think `Coord1',`Coord2' are sensible type names here
10:35:25 <monochrom> perhaps you need to learn more about lists
10:36:16 <ski> why doesn't
10:36:27 <jaarod> that string literal syntax color is hideous
10:36:28 <ski>   getBasketName (Basket name _) = name
10:36:42 <Lovepon> Karlodun: If you want to write it as "Coord1" and "Coord2" I suggest using record syntax.
10:36:42 <ski>   getBasketObjs (Basket _ objs) = objs
10:36:43 <monochrom> yes jaarod, it's redaction
10:36:44 <ski> work ?
10:36:50 <monochrom> pastebin.com redacts your code
10:36:58 <Lovepon> monochrom: Redact?
10:37:03 <Karlodun> let me try
10:37:15 * ski sees no color
10:37:32 <JuanDaugherty> Lovepon, editorial oversight
10:37:32 <Lovepon> Karlodun: You should totally use record syntax for that, but it's also ugly in its own way.
10:37:48 <ski> oh, apparently you wanted to call it `getBasketInner'
10:38:14 <Karlodun> why does it work now????
10:38:37 <ski> Lovepon : yes, default `Show' for record syntax is a bit on the verbose side. i sometimes manually make the ordinary `Show' instance then
10:38:38 <Karlodun> all the time hgci spitted with different errors on me
10:38:49 <ski> Karlodun : perhaps you did it wrong, earlier
10:39:40 <Karlodun> xD, I had either: getBasketObjs (Basket _ [objs]) = objs or getBasketObjs (Basket _ objs) = [objs]
10:39:49 <ski> yeah, that's wrong
10:40:04 <ski> the former will only work when there's only a single object in the list in the basket
10:40:22 <ski> the latter will return a list of lists, namely a list containing a single list (of objects from the basket)
10:40:25 <monochrom> Haskell is not Prolog. You do not throw in [] for every list variable.
10:40:37 <ski> monochrom : even in Prolog, you don't do that :)
10:40:49 <ski> (there is no `[ | Xs]' in Prolog)
10:41:39 <ski> perhaps BASIC would be a better comparision
10:41:44 <ski> (how about Perl ?)
10:41:59 <monochrom> hungarian notation
10:42:32 <ski> well, it's not hungarian notation if it's mandated by the language, no ?
10:45:09 <Karlodun> ^^
10:45:54 <Karlodun> I am just a beginner here, the only language I learned years ago was Visual Basic
10:46:07 <Karlodun> and I did only few lessons, it was in school time ^^
10:47:27 <Karlodun> now I have an error again....
10:47:33 <ski> Karlodun : that's ok
10:48:09 <Karlodun> let maxC1 (Basket _ objs) = maximum (map getC1 (Basket _ objs))
10:48:26 <ski> @quote mutilated
10:48:27 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration."
10:49:13 <ski> Karlodun : `map getC1 (Basket _ objs)' is type error
10:49:35 <ski> Karlodun : `Basket _ objs' is not a list, it's a basket. `map' only works on lists
10:49:49 <monochrom> I am a counterexample to that. I learned BASIC first. I was dissatisfied with it. When I then saw Pascal, I saw what I wanted.
10:49:58 <geekosaur> ^
10:49:58 <ski> Karlodun : also, you can't use `_' in expressions, only in patterns
10:50:37 <monochrom> for example, local variables, user-defined data structures, parameter passing, recursion.
10:51:06 <monochrom> (ok, you can do recursion in BASIC too, but impractical because lack of local vars and parameters)
10:51:07 <ski> monochrom : yes, i also learned BASIC first :) i suppose it explains stuff like my fondness for continuations, recursion
10:51:10 <geekosaur> (one of the first BASIC programs I wrote was a preprocessor to make it slightly saner. actually adding more useful stuff to it was harder given it was in BASIC to begin with...)
10:51:31 <Karlodun> my good experience started with PHP
10:51:42 <Karlodun> PHP seems so much better and developed to me right now
10:51:49 * ski stares blankly
10:52:03 <Karlodun> compared to haskell
10:52:08 <geekosaur> ?
10:52:36 <monochrom> oh, structural programming too. (while loops, if-then-else without line numbers)
10:53:05 <ski> monochrom : and local functions, and functional parameters, right ?
10:53:12 <monochrom> yeah
10:53:15 <geekosaur> I suppose PHP is superior if your goal is something that doesn't necessarily do what you want but doesnt crash when given nonsense
10:53:36 * hackagebot cef 0.1.4 - CEF log format  https://hackage.haskell.org/package/cef-0.1.4 (utdemir)
10:53:46 <Karlodun> wife needs some time, I hope I will not be alone here in 1h
10:53:53 <Karlodun> wanna go out for few minutes, cya
10:55:18 <dcz> hi guys, i have a question, how do i combine functions ? for example i have 4 separate functions to do this, get a number make it a list dobule the 2nd elements and sum the elements later but i couldnt make that happen , the functions work seperately but hw do i combine them ? http://lpaste.net/162666
10:55:27 <ski> @quote synthetic
10:55:27 <lambdabot> minion says: PROGV is a testament to the success of synthetic methamphetamines in the rearing and education of the inveterately brain-damaged contributors to the X3J13 standardisation proceedings.
10:55:57 <ski> dcz : good, you fixed the error :)
10:56:03 <dcz> yeap
10:56:42 <Iceland_jack> dcz: Maybe not what you're looking for, but to double every other number you just create an infinite list [1,2,1,2,1,2,… and zip them together
10:56:45 <ski> `(x : [])' is simpler written `[]'
10:56:56 <ski> er, `[x]', rather :)
10:56:57 <Iceland_jack> > zipWith (*) [10,20,30,40,50] (cycle [1,2])
10:56:59 <lambdabot>  [10,40,30,80,50]
10:57:20 <ski> and `sumDigits(ns)' has redundant brackets
10:57:47 <ski> dcz : what should your new function be called ?
10:57:59 <Iceland_jack> *multiply them them elemenetwise
10:58:07 <monochrom> dcz: it sounds like your choice between "sumDigits (doubleEveryOther (toDigits 4))" and "(sumDigits . doubleEveryOther . toDigits) 4"
10:58:13 <Iceland_jack> And so you're back, from outer space
10:58:16 <dcz> i am trying to do first example
10:58:17 <dcz> https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
10:58:22 <dcz> 4 questions
10:58:38 <dcz> i did the 4 functions there but how to combine them
10:58:43 <ski> monochrom : perhaps too trigger-happy
10:59:15 <monochrom> at least I hardcode the 4
11:01:39 <ski> dcz : `doubleEveryOther' is incorrect
11:01:58 <dcz> why
11:02:07 <dcz> it works like it is intented
11:02:16 <dcz> it doubles every 2nd elemnt
11:02:21 <ski> try `doubleEveryOther [8,7,6,5]'
11:02:39 <ski> see the PDF for the expected result
11:03:05 <ski> dcz : `sumDigits' is also incorrect
11:03:11 <dcz> it works like there
11:03:40 <dcz> maybe sumDigits is wrong
11:03:49 <ski> @letpaste 162666
11:03:50 <lambdabot>  Defined.
11:04:10 <ski> > sumDigits [16,7,12,5]  -- result ought to be `22'
11:04:12 <lambdabot>  20
11:04:28 <Heasummn> hmm
11:04:39 <ski> > doubleEveryOther [8,7,6,5]  -- result ought to be `[16,7,12,5]'
11:04:40 <lambdabot>  [8,14,6,10]
11:04:58 <Heasummn> by what the function is named, that sounds right
11:05:05 <Heasummn> it doubles all even indices
11:05:14 <Heasummn> or "other" indices
11:05:18 <ski> Heasummn : no, all odd indices. *counting* from the *end* :)
11:05:25 <ski> (see PDF)
11:05:26 <Heasummn> is that a builtin function?
11:05:29 <ski> no
11:05:33 <monochrom> so much for "meaningful names"
11:05:34 <Heasummn> ah I just popped in
11:05:36 <ski> dcz defined it in the paste above
11:05:49 <dcz> where ?
11:05:53 <monochrom> just remember that all "meaningful" names contain lies
11:05:58 * ski sometimes prefers "meaningless names"
11:06:15 <monochrom> the correct stance is mnemonic names
11:06:16 <ski> dcz : in <http://lpaste.net/162666>, remember ?
11:07:42 <dcz> skie : for doubleing , it should be [8,7,6,5] -> [8,14,6,10]
11:07:49 <ski> no
11:07:51 <dcz> not [16,7,12,5]
11:07:53 <dcz> yessssssss
11:07:54 <dcz> :D
11:08:07 <ski> <dcz> https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
11:08:08 <xa0> Yeah I'm with dcz, makes more sense
11:08:13 <ski> please read page `2' there ^ :)
11:08:35 <xa0> Oh it's an exercise
11:08:36 <ski> xa0 : "makes more sense" is irrelevant here. what matters is what the specification said
11:08:44 <xa0> Fair play
11:08:55 <xa0> Exercises never make sense
11:09:01 * ski nods sagely
11:10:08 <dcz> at least , how do i combine them ?
11:10:11 * ski took the two examples, for `sumDigits' and `doubleEveryOther', straight from that page
11:10:20 <ski> start by writing
11:10:23 <dcz> i am trying to combine functions but it compiles them gives me error
11:10:27 <ski>   validate :: Integer -> Bool
11:10:30 <monochrom> This exercise is a great example of XYX problems.
11:10:32 <ski>   validate n = ..n..
11:10:44 <ski> then replace `..n..' with something sensible
11:12:14 <monochrom> "Let's store the digits in big endian order, so that when you generate that list you have to do it backwards, and when you double every other digit you have to do it backwards again"
11:12:26 <Heasummn> you're supposed to double every other, from the right
11:12:33 <ski> monochrom : yeah, it's great :)
11:12:54 <dcz> what i am excatly doing is like this
11:12:58 <dcz> check this out
11:13:00 <dcz> 1 moment
11:13:01 <dcz> pls
11:13:13 * ski also suspects that they intended only one of the functions in Exercise 1 to be explicitly recursive
11:13:32 <ski> dcz : two moments have passed ..
11:13:39 <Heasummn> what is Stack, and how does it compare to Platform?
11:13:42 <dcz> :D
11:13:46 <dcz> ski dont push me pls
11:13:58 <ski> dcz : sorry, just jesting :)
11:13:58 <dcz> i am at very beginning learning curve
11:14:15 <dcz> i am trying my best :D
11:14:27 <ski> yes, you're doing fine, so far. asaict
11:14:58 <Heasummn> ski, double every other starts from the right
11:15:01 <Heasummn> not the left
11:15:15 <ski> Heasummn : didn't i already say this ?
11:15:28 <Heasummn> yes, but you're doing it from the left
11:15:30 <ski> <ski> Heasummn : no, all odd indices. *counting* from the *end* :)
11:15:37 <ski> not me, dcz
11:15:50 * ski isn't doing it at all
11:16:06 <Heasummn> oh lol
11:16:59 <jophish> Are there any flags I can pass to Setup (default Setup.hs) to still get output without a tty?
11:17:03 <dcz> http://lpaste.net/162679
11:17:07 <jophish> in a situation such as this: ./Setup test --show-details=streaming | cat
11:17:08 <dcz> this is what i am doing
11:17:44 <dcz> it gives me error 
11:22:02 <ski> dcz : just changing the function you call in the (previously) recursive call won't help
11:23:12 <ski> dcz : .. especially not, considering that they have incompatible types
11:23:28 <dcz> i dont get what i am thinking wrong
11:23:30 <dcz> :(
11:23:53 <dcz> doubleEveryOther returns list anywas, but it gives error
11:24:02 <ski> dcz : in `doubleEveryOther' `zs' is a list of `Integer's, but `toDigitsRev' wants a single `Integer' -- this can't work
11:24:21 * ski doesn't get what dcz was thinking at all, here :/
11:24:27 <dcz> :D
11:24:31 <dcz> right
11:25:02 <ski> dcz : .. perhaps it'd help if you focused first on `toDigits' and `toDigitsRev'
11:25:38 <ski> dcz : those are correct, but can be written in a better (more efficient) way
11:25:45 <dcz> todigitsrev needs integers
11:25:57 <ski> and doing that, may help you get an idea of how to fix `doubleEveryOther' as well
11:25:59 <dcz> ski: how ? 
11:26:59 <ski> dcz : the key observation is to notice that `[x] ++ xs' (aka `x : xs') is cheap, but `xs ++ [x]' is expensive
11:27:25 <ski> dcz : the former can be done in "a single step", basically
11:27:30 <dcz> whats the difference ? 
11:27:59 <ski> dcz : to do the latter, `++' will have to walk through the list of all elements in `xs' 'til the end, and add `x' there
11:28:28 <ski> dcz : now, if you want an element at the end, you want it at the end, so there's no way around it there
11:28:42 <ski> dcz : however, *repeatedly* adding stuff to the end of a list is 
11:28:49 <ski> *needlessly* expensive
11:29:17 <ski> repeatedly adding to the start is cheap. can be done in as many steps as the number of items you add to the start
11:29:26 <Iceland_jack> dcz: You can think of [] and (:) as being free/primitive/atomic, (xs ++ ys) actually has compute things (traversing the 'xs' element-by-element)
11:29:37 <ski> however, adding an element, one by one, to the end, using `++' is needlessly expensive
11:29:59 <ski> you can add a bunch of items to the end of a list in a more efficient way than doing it one by one
11:30:35 <ski> dcz : consider this story, which i read somewhere
11:31:24 <ski> dcz : Schlemiel has been employed to paint the white lines in the middle of a newly constructed road
11:31:48 <ski> dcz : on the first day, everything goes fine. some initial portion of the road now has the white lines
11:32:17 <ski> dcz : on the second day, Schlemiel appears to be making less progress than before
11:32:35 <ski> dcz : and yet less progress, the third day, and the fourth day
11:33:10 <ski> dcz : the fifth day, his boss asks him what is taking so long. he replies that he has to walk such a long way to get to the bucket of paint
11:33:35 <dcz> ski: this is for you , https://www.youtube.com/watch?v=Q3tZZLVqRbs&list=PL0GV_HDMCHhEncBxZjxV_I3ncaIH4f8yu&index=19
11:33:55 <dcz> you are the best 
11:33:57 <ski> dcz : do you understand the story ?
11:34:06 <dcz> i am reading one moment
11:34:37 <Iceland_jack> #haskell-storytelling :]
11:34:54 <dcz> :D
11:35:14 <dcz> at the beginning , things are hard , thats what i understand from that 
11:35:18 <gio111> ski: hi
11:35:45 <ski> dcz : do you understand what Schlemiel's problem was ?
11:36:10 <dcz> no actually :D
11:36:24 <Zemyla> dcz: Also, if you are doing something along the lines of (map f xs ++ ys), then you can do the map and append in the same operation.
11:37:03 <ski> Zemyla : this is a beginner, they don't know `map' yet
11:37:09 <Zemyla> Ahh.
11:37:20 <Zemyla> And they don't know foldr, I assume, either?
11:37:27 <ski> wouldn't bet on it
11:37:33 <ski> dcz : Schlemiel left the bucket of paint at the start of the portion of the road to get painted lines
11:37:44 <Iceland_jack>     (day 1) BUCKET - - -
11:37:44 <Iceland_jack>     (day 2) BUCKET - - - - - -
11:37:44 <Iceland_jack>     (day 3) BUCKET - - - - - - - - 
11:37:44 <Iceland_jack>     (day 4) BUCKET - - - - - - - - - 
11:37:46 <dcz> Zemyla : i think i should do these with sticking to notes there , https://www.seas.upenn.edu/~cis194/lectures/01-intro.html , not too much , maybe i am wrong but i dont know
11:37:47 <Iceland_jack>     (day 5) BUCKET - - - - - - - - - -
11:37:51 <Iceland_jack>  
11:38:00 * Iceland_jack . o O (unhelpful graphic)
11:38:12 <ski> dcz : each day, he had to spend a longer portion of the time walking back and forth between the bucket and the place where he stopped drawing because the paint in his brush got used up
11:38:41 <dcz> ski : ugh i am confused :D
11:38:45 <ertes> hi there…  is there a library with a kind of explicit IO "thunks"?  semantics:  create :: (PrimMonad m) => m a -> m (Var m a);  retrieve :: (PrimMonad m) => Var m a -> m a  -- use case: retrieve a value from a database only when it's actually requested, and reuse the value once that happened
11:38:57 <ski> dcz : the obvious (to the reader) solution would have been to carry the bucket with him. but Schlemiel didn't think of doing that
11:40:40 <ski> dcz : so, Schlemiel did something that seemed to work ok at the start, but got slower and slower (and *unnecessarily* so) as time progressed
11:41:09 <ski> dcz : unfortunately, programmers often seem to do this kind of error. you should be on the look-out for them
11:41:17 <ski> dcz : ok ?
11:43:30 <dcz> ski : you are a very nice guy but i am kinda drunk and i dont get you too much :D
11:43:42 <dcz> i will try my best
11:45:48 * ski imagines dcz walking home to get a new beer, everytime the last one has been finished, during the walk to a friend who's having a party, and lives some distance away
11:46:01 <Iceland_jack> haha
11:46:24 <ertes> i think what i want is an 'Async' that doesn't start the thread until the value is actually requested
11:46:27 <ski> (let's say there are no buses, because of a strike. and dcz doesn't own a vehicle)
11:47:08 <dcz> hahahahah
11:47:09 <dcz> :D
11:47:20 <dcz> you are funny
11:47:29 <Iceland_jack> And the party always moves further away from dcz's home...
11:47:45 <dcz> i dont have any vehicle , thats right :D
11:47:58 <ski> well, it suffices that the party is enough distance away
11:48:13 <ski> so, perhaps a one hour walk, under normal conditions
11:48:28 * ski also assumes dcz likes to take healthy promenades
11:48:48 <dcz> haha
11:48:51 <dcz> no thats wrong
11:49:11 <dcz> i am just my own :D
11:49:23 <ski> oh, but you like your friend, and liquor, enough, that you'd want to walk to the party anyway :)
11:49:35 <Darwin226> Is I give a StablePtr to C++ and it stores it somewhere. How can I "free" that pointer from C++ code?
11:49:35 <monochrom> Schlemiel should ask the employer to provide a car for traveling on the road to be painted
11:50:17 <Darwin226> (I don't know what happened to the grammar in the last message)
11:50:35 <ski> monochrom : employer will possibly refuse the use of a company car, except as a ride at the start and end of the working day
11:51:13 <ertes> Darwin226: GC forgot to drop a few parts of your earlier attempts to formulate the question
11:51:25 <ski> (they have better things to do that drive Schlemiel back and forth)
11:51:45 <Darwin226> ertes: Haha, that's exactly right
11:51:55 <dcz> ski : i dont have any party here man :D
11:52:05 <monochrom> Darwin226: there is "void hs_free_stable_ptr (HsStablePtr sp)" you can use on the C side. If you don't want to #include <HsFFI.h>, HsStablePtr is simply (void *)
11:52:13 <ski> dcz : no. the party was at your friend's place :)
11:52:32 <Darwin226> monochrom: Don't I have to include it anyways to get that function?
11:52:47 <ertes> Darwin226: you could write the function prototype yourself
11:52:59 <Darwin226> Oh right. C. How could I forget.
11:53:01 <ski> Darwin226 : this is C we're speaking about, after all ..
11:53:04 <monochrom> no, because you can "extern void hs_free_stable_ptr(void *)" it yourself
11:53:19 <Darwin226> Excellent
11:53:30 <monochrom> and it should probably be "extern C" too
11:53:57 <Darwin226> Btw, how did you know I don't want to include that header?
11:54:03 <dcz> you are funny man :D good to know
11:54:16 <ertes> C is from a time when it was important that you can write hello-world in a single line of code…  in fact you don't even have to write the prototype
11:54:40 <dcz> ski: so where are we now ? what i need to change ?
11:54:41 <ski> dcz : anyway, i was thinking to show some "traces" of your existsing `toDigits' and `toDigitsRev', to illustrate the problem
11:54:42 <monochrom> because there are lots of use cases where you ship your written-in-haskell library as binary to a pure C or C++ programmer who should be able to use it without installing GHC
11:55:11 <ski> dcz : how about i do it in #haskell-overflow, since it's a little bit noisy in here atm ?
11:55:40 <dcz> i am almost to do working thing 
11:55:42 <Darwin226> monochrom: Oh. For me it's just that the linter is annoying since it can't find that header :D
11:55:56 <dcz> but i didnt get the combining thing
11:56:17 <dcz> actually i did but i am wrong at it obviously
11:56:44 <ski> dcz : so .. will you `/join #haskell-overflow' ?
11:58:56 <dcz> ski: i am there  now
11:59:38 <ertes> data Promise a = Done a | Error SomeException | ToDo (IO a);  newtype Var a = Var { fromVar :: TMVar (Promise a) }
11:59:44 <ertes> that's basically what i'm looking for
12:00:47 <ertes> retrieve :: Var a -> IO a  -- if ToDo, try to compute the value, if Done, just read it, if Error, throw an exception
12:01:01 <monochrom> I think the async library does that. Let me check.
12:01:09 <ertes> monochrom: it wants to compute right away
12:01:22 <monochrom> ah, you want to invoke ToDo by hand?
12:01:46 <ertes> monochrom: yeah, only 'retrieve' should invoke it, creating a Var shouldn't
12:02:08 <ertes> also a separate thread isn't necessary
12:02:08 * monochrom tries to save async by adding a contraption...
12:02:33 <monochrom> nah, your scheme is the best
12:02:34 <dcz> ski: nobody answers there :D
12:04:29 <Karlodun> back from rest
12:04:37 <Karlodun> and solved most issues
12:06:18 <Karlodun> now I have another issue: I have a list of tuples, and need to pick a tuple where one of the elements matches something
12:07:20 <jaarod> how do you determine if it matched something? predicate? equality?
12:08:23 <Karlodun> equality
12:09:26 <Karlodun> to be more exact, let's take the following example: [ ("a",1) , ("b",2) , ( "c",3)]
12:09:50 <Karlodun> and I need a way to pick out "c"
12:10:05 <Karlodun> or ("c", 3)
12:11:43 <Karlodun> some function "f n" which gives me the tuple where n is
12:12:00 <ski> ertes : .. not `ToDo (IO (Promise a))' or something like that ?
12:14:15 <Lovepon> How do I fold(like literally fold a list in half), such that the beginning gets paired with the end, etc. etc.
12:14:26 <Lovepon> The middle element, if it exists, gets discarded.
12:14:52 <Adeon> hmmm
12:15:06 <Adeon> zip two lists together, original and reversed
12:15:11 <Adeon> but cut them in half before zipping
12:15:13 <Lovepon> zipWith (\x y ->) xs $ take (length xs `div` 2) (reverse xs)
12:15:17 <Lovepon> That's what I have so far.
12:15:24 <Adeon> does it work
12:15:27 <Lovepon> I feel like I'm putting too much.
12:15:33 <Lovepon> Adeon: I'm sure it will.
12:15:54 <Lovepon> But it seems too complex, IMO.
12:15:59 <Adeon> if it's real code I usually don't engage in golfing trying to make it shortest possible but that looks okay to me even so
12:16:51 <ertes> ski: why?
12:18:38 * hackagebot zeromq4-haskell 0.6.5 - Bindings to ZeroMQ 4.x  https://hackage.haskell.org/package/zeromq4-haskell-0.6.5 (ToralfWittner)
12:18:59 <ertes> ski: the action shouldn't be able to delay the promise, otherwise 'retrieve' would end up looping (and may even never finish to loop)
12:32:29 <ski> ertes : ok
12:33:00 <mikeD> hey all
12:33:10 <mikeD> is there a Cassava equivalent to "fieldLabelModifier" option in Aeson?
12:33:36 <mikeD> i want to use generics for decoding with named fields, but i want fields to have a suffix
12:33:55 <monochrom> ah, right, I think no.
12:33:57 <mikeD> so that I don't end up with field name clashes between types with different CSVs
12:35:49 <mikeD> monochrom aw man, so the only way to have modified field names is to define parseNamedRecord manually?
12:40:36 <tomphp> hi, can anyone give me some suggestions on how to deal with this error from stack http://pastebin.com/7vVEykx7
12:46:20 <bergmark> tomphp: reinstall ghc
12:46:44 <tomphp> bergmark: will try but that's what broke it
12:48:18 <Zemyla> Can there be a top-level unboxed primitive value in a file?
12:48:52 <Zemyla> Like, can I have val :: Addr#; val = "foostuff"#;
12:53:39 * hackagebot github-release 0.1.8 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-0.1.8 (fozworth)
12:55:13 <troydm> so I'm trying to write 6502 emulator as exercise and I'm thinking about what's the best type to emulate memory
12:55:32 <troydm> it's definitely should be some mutable array type but I'm not sure which one
12:55:45 <troydm> is there effecient Word8 mutable array in Haskell?
12:55:49 <troydm> unboxed one
12:56:35 <troydm> should I use this https://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array-IO.html#t:IOArray ?
12:58:10 <maerwald> is there a way to match on Exception type that does not suck and does not involve ScopedTypeVariables?
12:59:40 <Karlodun> sorry, had to go afk
13:02:37 <cocreature> troydm: you probably want https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed-Mutable.html
13:03:17 <troydm> cocreature: thx
13:05:04 <cocreature> maerwald: does lens suck? :)
13:05:15 <cocreature> maerwald: if not take a look at https://hackage.haskell.org/package/lens-4.14/docs/Control-Exception-Lens.html
13:06:49 <mikeD> what do people recommend for data frame-like data and operations? Vector of records? Frames? something else?
13:09:04 <mikeD> is there an in-memory database package that works well for interactive analyses
13:09:07 <maerwald> cocreature: I wouldn't say it sucks, but I don't want to use it
13:12:45 <tomphp> bergmark: seems to be working, thanks :-)
13:13:19 <ski> maerwald : `PatternSignatures' was a nicer way to do it, imho
13:15:54 <maerwald> ski: that is just ScopedTypeVariables afais
13:18:58 <ski> maerwald : no, imho `ScopedTypeVariables' is worse, usability-wise
13:19:24 <maerwald> Then I don't know what you are referring to really. I don't see such a GHC extension.
13:20:59 <ski> maerwald : emphasis on "was"
13:21:03 <ski> maerwald : it doesn't exist, anymore
13:22:06 <EvanR> what does lambdabot use for evaluating haskell
13:22:26 <geekosaur> mueval
13:22:55 <maerwald> you pretty much cannot write a generic function that lets you react on say n different exception types where n simply depends on the input
13:23:12 <maerwald> it has to be explicit type matching somewhere, so it's static
13:23:34 <geekosaur> maerwald, you can see the old PatternSignatures extension in 6.x ghc releases (until, I think, 6.12)
13:25:43 <geekosaur> and then it was folded into ScopedTypeVariables, which I agree (and thought at the time) is a bit wtf
13:26:26 <NeedHelpHarry> Does anyone know how to implement recursive foldr in haskell? I have no idea where to start
13:29:50 * NeedHelpHarry anyone there?
13:30:20 <Cale> NeedHelpHarry: well, you should start by pattern matching the list
13:30:29 <NeedHelpHarry> Ok
13:30:33 <NeedHelpHarry> I have this for the base case
13:30:35 <Cale> myFoldr f z [] = ...
13:30:41 <NeedHelpHarry> myFoldr fn acc (x:[]) = fn x acc
13:30:41 <Cale> myFoldr f z (x:xs) = ...
13:30:46 <NeedHelpHarry> actually
13:30:47 <NeedHelpHarry>  @paste
13:31:03 <NeedHelpHarry> what is the paste website again?
13:31:07 <Cale> lpaste.net
13:31:10 <NeedHelpHarry> thanks
13:31:33 <Cale> It may help to think of foldr f z xs as meaning "replace every occurrence of (:) in xs with f, and replace the [] at the end, if any, with z"
13:32:15 <NeedHelpHarry> http://lpaste.net/162686
13:32:26 <NeedHelpHarry> ah
13:32:32 <Cale> you should definitely have [] as a base case
13:33:58 <tobiasBora> Hello,
13:34:15 <NeedHelpHarry> Hi
13:34:31 <monochrom> you do not need a special case for x:[]
13:34:38 <tobiasBora> I have an "index out of bound" error, and I would like to using a tool to point me the line where this out_of_bound is done
13:34:45 <tobiasBora> I tried to load my file in ghci
13:34:51 <cite-reader> NeedHelpHarry: I sense you need help. Hello!
13:34:52 <NeedHelpHarry> Isnt that the base case monochrom?
13:35:00 <NeedHelpHarry> hello cite-reader
13:35:02 <monochrom> totally not.
13:35:10 <tobiasBora> Then I wrote :
13:35:14 <tobiasBora> :load myfile.hs
13:35:16 <tobiasBora> :set -fbreak-on-exception
13:35:21 <tobiasBora> :trace main
13:35:22 <NeedHelpHarry> is it at all useful?
13:35:52 <NeedHelpHarry> I am learning haskell and so is my professor so that could explain why he doesn't know anything either
13:35:57 <tobiasBora> then :back
13:36:07 <EvanR> is it possible to transfer objects from one process to another without serializing and deserializing
13:36:09 <tobiasBora> but the function that is here isn't "dangerous" :
13:36:11 <tobiasBora> 88  linear f
13:36:12 <monochrom> x:[] is a necessary special case for some fringe tasks. but definitely not for foldr.
13:36:13 <tobiasBora> 89    | f >= 1 = 1
13:36:15 <tobiasBora> 90    | f <= 0 = 0
13:36:25 <NeedHelpHarry> cite-reader: are you a real person
13:36:57 <cite-reader> Yeah, I'm real. I'm just distracted and in seven channels at the moment.
13:36:59 <tobiasBora> I tried another back, but the function seems to be nice also :
13:37:00 <geekosaur> EvanR, not really. although cloud haskell has some hacks
13:37:01 <tobiasBora> playNeuron f board neuron =
13:37:03 <tobiasBora> 149    f $ sum $ Seq.zipWith (\ b n -> n * b) board $ getValues neuron
13:37:05 <geekosaur> only 7?
13:37:07 <monochrom> EvanR: if they share memory, you can transfer through the shared memory area
13:37:22 <EvanR> right i know about shared memory but ...
13:37:23 <tobiasBora> Do you know why it doesn't give me the good line ?
13:37:27 <NeedHelpHarry> cite-reader: oh lol ok
13:37:49 <EvanR> pointers
13:37:53 <monochrom> that's pretty much it.
13:37:57 <NeedHelpHarry> I am trying to code a recursive foldr function
13:38:29 <EvanR> i guess if the processes in question are exact duplicates that evolve in exactly the same way
13:38:39 <geekosaur> tobiaBora, laziness makes that difficult, the exception is thrown when the dereference is forced
13:38:44 <EvanR> they can trade objects (which.. would appear to change nothing)
13:39:18 <EvanR> geekosaur: what kind of hacks
13:40:00 <tobiasBora> EvanR: So how could I debug this kind of error ?
13:43:24 <geekosaur> EvanR, http://hackage.haskell.org/package/distributed-static-0.3.4.0/docs/Control-Distributed-Static.html
13:43:29 <geekosaur> discusses some of it at least
13:44:18 <shanemikel> any way to get this syntax? `compose :: (Arrow (~>)) => a ~> b -> b ~> c -> a ~> c`
13:44:22 <geekosaur> tobiasBora, ideally use ghc8.0.1rc4 so you get a CallStack-equipped "error" that knows where it actually happened and how it got there
13:44:52 <shanemikel> or something similar?  I feel like I've seen it before
13:46:31 <monochrom> ghc 8.0.1 release candidate 4 is at http://downloads.haskell.org/~ghc/8.0.1-rc4/
13:47:35 <tobiasBora> geekosaur: I can't find how to upgrade ghc with stack...$
13:49:55 <geekosaur> https://www.reddit.com/r/haskell/comments/4b84h1/how_to_use_ghc_8_with_stack/ ?
13:50:08 <EvanR> im trying to understand how reflection is useful, the intro to the paper by oleg about it is not illuminating to me
13:50:15 <EvanR> configuration problem? implicit parameters? what?
13:50:18 <geekosaur> note that it's talking about older versions...
13:50:30 <EvanR> can anybody explain what reflection does / helps with
13:52:32 <geekosaur> EvanR, https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection ?
13:52:42 <EvanR> ill try to read that one again...
13:53:03 <geekosaur> you mentioned Oleg's paper, not that one :)
13:53:47 <EvanR> i did read that one a while back too and gave up
13:55:11 <EvanR> maybe the word reflect isnt matching up with anything in my head
13:55:26 * EvanR tries to ignore it
13:55:45 <geekosaur> it's not like OOP reflection, I think; more like reflecting types to values and back
13:56:03 <geekosaur> since they're using types to pass around runtime configuration values
13:56:06 <bollu> okay, so, this happened: http://pastebin.com/RkWhaxxq
13:56:13 <bollu> ghc: panic! (the 'impossible' happened)
13:56:36 <bollu> what the hell? I was trying to invoke GHCi with symengine (a library I'm writing bindings for)
13:56:40 <EvanR> geekosaur: what is the benefit of doing this rather than just passing in the configuration directly?
13:57:02 <geekosaur> not having 20-parameter functions?
13:57:10 <bollu> ski: "wait, don't natural transformations have to map morphisms as well?" -- no and yes .., context?
13:57:15 <EvanR> record?
13:57:24 <bollu> and does anyone know what exactly caused GHCi to spaz out when I asked it to use a library?
13:57:26 <EvanR> which youd put in this proxy right
13:57:29 <geekosaur> (even if you bundle it all into a record, that's yet another thing to pass around with everything else)
13:57:34 <bollu> link to error: http://pastebin.com/RkWhaxxq
13:57:52 <geekosaur> just like we use state monads to not have to pass state around explicitly, etc.
13:58:40 * EvanR continues to try a find an example of actual use
13:59:04 <Cale> shanemikel: Sadly, not any more. Old versions of GHC allowed the use of infix type variables
13:59:31 <maerwald> ski: basically what I want is this http://lpaste.net/162690 but for any error _type_ I have to add another argument to the function
13:59:32 <EvanR> the blog post is most about implementation
13:59:39 <EvanR> mostly
14:00:59 <EvanR> we need a reflection tutorial fallacy
14:01:52 <EvanR> geekosaur: ... or Reader
14:02:04 <bollu> guys, how did GHCi just die?
14:02:16 <bollu> ghc: panic! (the 'impossible' happened)
14:02:16 <bollu>   (GHC version 7.10.2 for x86_64-apple-darwin):
14:02:16 <bollu> 	Loading archives not supported
14:03:10 <geekosaur> bollu, consider posting your error to a site which is not a willing and active malware vector (it's blocked here because its admins think users should pay for the special privilege of being secure from watering hole attacks)
14:04:24 <bollu> geekosaur: oh, I wasn't aware that pastebin was banned. Gimme a sec, I'll gist it
14:04:31 <shanemikel> Cale: that's really sad..  No extension, either?
14:04:58 <Cale> Not as far as I'm aware
14:05:30 <geekosaur> in any case "archive" usually means a static library
14:05:30 <bollu> link: https://gist.github.com/bollu/2568ae4c85adee8146a2cd6c7d4a9ed0
14:05:36 <geekosaur> those are not designed for dynamic loading
14:05:42 <geekosaur> and require a full linker
14:05:47 <bollu> oh, hm, right
14:06:07 <bollu> wait, but, how do  libraries work with python then? does it also always need a DLL/.so?
14:06:15 <geekosaur> yes
14:06:16 <bollu> I hadn't considered this
14:06:21 <bollu> ooh, okay. thanks, this helps
14:06:32 <geekosaur> I think you can get away with dynamically loading static archives on i386 linux
14:06:32 <bollu> I'll try and build a shared object and link to that :)
14:06:49 <geekosaur> you can't on x86_64, and for reasons deriving from OS X's origins on PPC you can't do it on OS X at all
14:07:20 <mikeD> what is the tilde doing in this expression?
14:08:00 <mikeD> personRec ~(Person name age) = ["name" .= name, "age" .= age]
14:08:05 <Cale> Lazy pattern match
14:08:32 <mikeD> Cale how does that behave differently?
14:08:37 <mikeD> than a normal pattern match
14:08:37 <Cale> It will only evaluate the argument to personRec if one of the variables bound in that pattern is evaluated
14:08:56 <Cale> (and if they pattern didn't match, you get a runtime exception, so it had better match)
14:09:21 <Cale> So, only when you get to the point of using name or age
14:09:44 <Cale> I'm not really sure without more context why that is necessary or desirable in that expression
14:10:25 <mikeD> Cale i'm looking at the Pipes.Csv example http://hackage.haskell.org/package/pipes-csv-1.4.3/docs/Pipes-Csv.html
14:11:03 <Cale> Ah, it's because they want to write  header = fromList $ map fst $ personRec undefined  for whatever reason
14:11:30 <Cale> I'm not sure why *that's* a good idea...
14:13:16 <Cale> But yeah, the reason that doesn't fall over is that it only needs the first element of each pair, and so it won't evaluate name and age
14:18:05 <bollu> geekosaur: thanks :)
14:18:12 <bollu> geekosaur: compiling a .so worked!
14:26:27 <bollu> why does GHCi show everything inside a module for autocomplete, even though I don't want it exporteD
14:26:38 <bollu> even though I haven't exported it**
14:27:32 <EvanR> so you can test it
14:28:03 <dolio> There's two different ways a module can be loaded in GHCi. The one that happens automatically when you haven't compiled the module yet allows you to use unexported things from the module.
14:29:59 <mikeD> where is >-> defined? has it been deprecated?
14:31:50 <cite-reader> mikeD: That's from pipes. https://hackage.haskell.org/package/pipes-4.1.9/docs/Pipes-Tutorial.html
14:35:01 <mikeD> cite-reader thanks. are you a bot?
14:35:16 <cite-reader> Why do people keep asking that today?
14:35:33 <ski> we're all bots in here. even you
14:35:59 <cite-reader> But anyway yes. I am definitely human. Beep boop I love breathing air.
14:38:44 <mikeD> http://i.imgur.com/C0MYp.gif?noredirect
14:40:33 <longview> hey, what frp library would you guys recommend for simulations or games or those kinds of things? netwire? yampa?  
14:40:51 <NeedHelpHarry> Anyone willing to help me with some homework?
14:40:55 <NeedHelpHarry> Basic stuff
14:41:37 <cite-reader> If you can answer specific questions, someone will usually be willing to give you pointers.
14:41:39 <NeedHelpHarry> Cant figure out how to code a right fold function
14:41:49 <NeedHelpHarry> Ok
14:42:08 <Rembane> NeedHelpHarry: Do you know the base case?
14:42:15 <NeedHelpHarry> No
14:42:17 <NeedHelpHarry> I might
14:42:30 <NeedHelpHarry> From what my professor claims it is
14:42:34 <NeedHelpHarry> but I was told it is wrong here
14:43:10 <NeedHelpHarry> http://lpaste.net/162686
14:44:22 <EvanR> longview: you can also ask in #haskell-game
14:44:47 <longview> EvanR: i'll try that, thanks!
14:46:02 <NeedHelpHarry> ANy tips?
14:46:52 <longview> you're not matching the cases properly
14:47:59 <Rembane> NeedHelpHarry: I would put the base case first
14:48:05 <vkbsh> Hi, could anyone explain why something like this doesn't work? http://pastebin.com/sw0ek7Vu
14:48:11 <Rembane> NeedHelpHarry: What happens if you have an empty list as input?
14:48:13 <vkbsh> Trying to create an algebraic data type here
14:48:53 <lyxia> vkbsh: a datatype must be tagged. data Foo = FooInt Int | FooString String
14:48:57 <NeedHelpHarry> Rembane: it should return an empty list I think
14:49:08 <longview> NeedHelpHarry: in addition to what rembane said, you need to get your function to apply multiple times, until you've consumed the entire list 
14:49:36 <NeedHelpHarry> longview: so it should call itself right?
14:49:39 <lyxia> vkbsh: FooInt and FooString here are called constructors, and allow you to disambiguate the two alternatives
14:49:56 <vkbsh> Ah ok, let me try that
14:50:00 <vkbsh> Thanks, lyxia!
14:50:02 <Rembane> NeedHelpHarry: That seems reasonable. 
14:50:09 <Rembane> NeedHelpHarry: Now you have two base cases. :)
14:50:24 <longview> NeedHelpHarry: that's how you would do that in haskell, yes :)
14:50:32 <lyxia> vkbsh: you'll need to use these constructors in the rest of the code BTW.
14:50:51 <NeedHelpHarry> ok lol, I will update the file in a se
14:50:52 <NeedHelpHarry> sec
14:51:02 <Cale> NeedHelpHarry: Have you already written functions such as sum and product?
14:51:22 <Cale> (recursively, I mean)
14:51:47 <NeedHelpHarry> Cale: yes those I dont have trouble with, it is the recursive foldr that I cant wrap my head around
14:51:57 <Cale> NeedHelpHarry: another way to think about how to do this is that foldr is capturing the repetitive part of the definition of those
14:52:07 <Cale> You have:
14:52:11 <Cale> sum [] = 0
14:52:16 <Cale> sum (x:xs) = x + sum xs
14:52:17 <Cale> right?
14:52:22 <Cale> and
14:52:26 <Cale> product [] = 1
14:52:33 <Cale> product (x:xs) = x * product xs
14:52:44 <NeedHelpHarry> yes
14:52:48 <NeedHelpHarry> ah that makes sense
14:52:52 <NeedHelpHarry> Yeah
14:53:03 <Cale> So the only difference here is that we've replaced 0 with 1 and (+) with (*)
14:53:19 <Cale> So what if we were to factor those two things out, and make them function parameters?
14:53:19 <NeedHelpHarry> base case then:myFoldr fn acc [] = acc
14:53:48 <NeedHelpHarry> What do you man
14:53:50 <NeedHelpHarry> mean
14:54:46 <Cale> I mean, we want foldr (+) 0 to be equal to sum, and we want foldr (*) 1 to be equal to product
14:55:30 <Cale> Let's take the definition of sum, and instead of using the functions 0 and (+), let's take those things as arguments:
14:55:44 <Cale> sum plus zero [] = ...
14:55:50 <Cale> sum plus zero (x:xs) = ...
14:56:01 <NeedHelpHarry> I see
14:56:03 <Cale> what will this look like?
14:56:21 <NeedHelpHarry> Umm
14:56:42 <NeedHelpHarry> Wait
14:56:56 <NeedHelpHarry> how does it take in the (+)
14:57:08 <longview> (+) :: (a -> b -> b)
14:57:16 <Cale> Well, this argument (+) is going to be our function for adding
14:57:19 <Cale> er, sorry
14:57:22 <Cale> this argument plus
14:57:36 <Cale> longview: shhhh ;)
14:57:40 <NeedHelpHarry> hhh
14:57:42 <NeedHelpHarry> ohh
14:57:51 <NeedHelpHarry> thats wright
14:57:53 <NeedHelpHarry> right
14:58:06 <NeedHelpHarry> thanks longview lol
14:58:08 <NeedHelpHarry> I forgot
14:58:22 <NeedHelpHarry> so
14:58:35 <NeedHelpHarry> sum plus zero [] = zero
14:59:07 <NeedHelpHarry> sum plus zero (x:xs) = x plus sum xs
14:59:18 <NeedHelpHarry> ?
15:00:09 <longview> that seems a lot like what cale wrote earlier, yes
15:00:17 <Cale> close, except that means that x is the function and not the argument to plus, just because it's not an infix operator
15:00:50 <Cale> also sum xs will need parens around it, and you'll want to pass the plus and zero to use along
15:00:56 <Cale> (not enough arguments there)
15:02:23 <NeedHelpHarry> oh
15:02:24 <NeedHelpHarry> i see
15:02:55 <aleogen> is there a haskell refernece book I should check out?
15:03:18 <aleogen> maybe core docs
15:04:00 <NeedHelpHarry> sum plus zero (x:xs) = plus x (sum plus zero xs)
15:04:00 <NeedHelpHarry> ??
15:04:22 <Cale> aleogen: If you're looking for technical details, the Haskell Report is good, but it's not a tutorial on the language.
15:04:30 <Cale> NeedHelpHarry: right!
15:04:39 <Cale> NeedHelpHarry: Now, what have you actually done?
15:05:02 <NeedHelpHarry> That is a left fold right?
15:05:09 <Cale> nope, right fold
15:05:13 <NeedHelpHarry> wait really
15:05:22 <NeedHelpHarry> how can you tell
15:05:33 <Cale> Well, it's going to right associate the expression it produces
15:05:52 <Cale> sum plus zero (1 : (2 : (3 : [])))
15:06:09 <Cale> -> plus 1 (sum plus zero (2 : (3 : [])))
15:06:09 <NeedHelpHarry> so the first one it adds is 3 + 0 right
15:06:14 <Cale> nope
15:06:23 <NeedHelpHarry> Oh I have to do it that way
15:06:23 <mikeD> longview reflex seems to be the hotness for performant FRP currently
15:06:34 <Cale> It starts by adding 1 to the sum of the rest of the list
15:06:38 <mikeD> longview although I haven't seen anyone *actually* implement a game using it
15:06:48 <NeedHelpHarry> Is it possible to do it so it starts with 3 first
15:06:50 <NeedHelpHarry> ?
15:06:59 <Cale> which, if plus pattern matches on its second argument, will cause the recursion to continue
15:07:08 <NeedHelpHarry> fold-right
15:07:11 <NeedHelpHarry> wait that is what we did
15:07:13 <NeedHelpHarry> I am so confused now
15:07:14 <NeedHelpHarry> lol
15:07:17 <Cale> -> plus 1 (plus 2 (sum plus zero (3 : [])))
15:07:20 <aleogen> Cale: oh, no need for a tutorial, more just a technical reference
15:07:31 <Cale> -> plus 1 (plus 2 (plus 3 (sum plus zero [])))
15:07:41 <Cale> -> plus 1 (plus 2 (plus 3 zero))
15:07:48 <longview> mikeD: yeah, I've been checking it out. it seems a bit too young though, and someone said that arrow-based frp libraries are more suited to 
15:07:54 <NeedHelpHarry> Yeah you are right Cale
15:07:56 <vkbsh> How would I put an if statement in a "where" expression? Something like "where x = 1 if y == "A" else x = 0"
15:08:00 <NeedHelpHarry> I'm just confuseing myself
15:08:08 <longview> mikeD: suited for games and simulations, cause it's easier to switch
15:08:41 <Cale> aleogen: Also, maybe the GHC User's Guide, which has lots of stuff (and often links to more detailed references) about various language extensions
15:09:13 <Cale> aleogen: Simon Marlow's book on concurrency is also very good, if you haven't seen that
15:09:37 <geekosaur> vkbsh, either ``` where x = if y == "A" then 1 else 0 ``` or ``` where x | y == "A" = 1 | otherwise = 0 ```
15:09:49 <Cale> NeedHelpHarry: So, foldr is sort of the most natural thing to write once you've written enough recursive functions on lists
15:10:18 <NeedHelpHarry> Cale: yeah it really makes sense now that I think about it, thanks for your help
15:10:18 <Cale> NeedHelpHarry: It just comes from factoring out the parts which change, and making them arguments to the function -- which is something we love to do in functional programming
15:11:13 <Cale> NeedHelpHarry: Something to notice is that  foldr (:) []  won't affect a list at all:
15:11:19 <Cale> > foldr (:) [] [1..]
15:11:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:11:29 <Cale> It's the identity function
15:11:30 <vkbsh> geekosaur, that worked; thanks much!
15:11:57 <Cale> NeedHelpHarry: So another way to think about foldr f z is that it's replacing all the (:)'s in the list with f, and the [] at the end (if there is an end...) with z
15:11:58 <NeedHelpHarry> Cale: interesting, so is it prepending [] 
15:12:10 <Cale> nope
15:12:21 <Cale> Remember, the [] there will only get used if it reaches the end of the list
15:12:30 <Cale> If the list is infinite, it won't even get used
15:12:41 <Cale> @src foldr
15:12:42 <lambdabot> foldr f z []     = z
15:12:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:12:48 <EvanR> ok the oleg paper got more understandable... though im not too sure how the resource management of stable ptrs is working at the end there
15:12:59 <greg`> Cale , why did that not crash lambdabot?
15:13:05 <NeedHelpHarry> hmm
15:13:31 <Cale> greg`: Well, remember that under lazy evaluation, expressions are evaluated outermost-first
15:13:36 <NeedHelpHarry> Wait so Cale, if I am to implement foldr with list recursion, is that different than what we found out above?
15:14:01 <Cale> NeedHelpHarry: Nope, you wrote it correctly, just rename sum to foldr, plus to f, and zero to z
15:14:17 <greg`> Cale: understood but you didnt take all , you just asked lambdabot to evaluate an infinite list
15:14:18 <NeedHelpHarry> Alright, cool
15:15:08 <Cale> greg`: Yeah, though lambdabot chops the output off after about a line, and only enough of the list required to determine that part of the string is evaluated.
15:15:24 <greg`> ah so
15:15:56 <Zemyla> shachaf: I tried using ghc-core on Windows, and it crashes. D:
15:16:53 <greg`> whats the deal with ghc8 , any killer features noticable?
15:18:06 <NeedHelpHarry> So how would I explain this type declaration in english?
15:18:07 <NeedHelpHarry> (a -> b -> b) -> b -> [a] -> b
15:18:30 <greg`> foldr
15:18:56 <Iceland_jack> NeedHelpHarry: That's not really the question you want answered :)
15:19:45 <NeedHelpHarry> Lol
15:19:52 <NeedHelpHarry> I am supposed to explain it in english
15:19:56 <NeedHelpHarry> for each letter
15:19:57 <NeedHelpHarry> I mean
15:20:04 <Cale> NeedHelpHarry: So, we're transforming a list of values of type a, into a result of type b, given both a function (a -> b -> b) which will explain how to add an element of type a to something of type b, and an "empty" value of type b
15:20:49 <greg`> given a function that combines a type  a and a type  b down to a single type b, given a starting value of type b, and a list of type a's , condense the whole lot down to a single type v value
15:21:11 <Cale> Or, with less interpretation, this is a function which takes (a function which takes a value of type a, and a value of type b, and produces a result of type b), and a value of type b, as well as a list of values of type a, and produces a result of type b
15:21:20 <idev> I need a haskell webserver which does two things: (1) serve a static directory and (2) support websockets. I don't need anything else. What is the most lightweight library for supporting these two things?
15:21:35 <Iceland_jack> So this is an assignment NeedHelpHarry?
15:21:36 <NeedHelpHarry> ohhhh
15:21:37 <greg`> s/v/b
15:21:42 <NeedHelpHarry> thanks guys
15:21:43 <NeedHelpHarry> !!!
15:22:23 <Rembane> idev: If you use nginx for (1) you can do (2) with a library that only does that and does it splendidly.
15:22:37 <idev> which library would that be?
15:22:44 <greg`> um anyone hack haskell on emacs?
15:23:10 <longview> greg`: I do
15:23:12 <idev> https://hackage.haskell.org/package/websockets + nginx ?
15:24:05 * ski . o O ( "Declare `foldr` as a function taking function taking `a` and `b` and returning `b`, `b` and list of `a` and returning `b`." )
15:25:39 <greg`> longview: do you know if haskell-mode can do pattern expansion, i.e. write all skeleton terms for a function to match simple sum types
15:25:39 <greg`> as much as I hate to admit it , haskellbook is amazing , im completely hooked
15:26:30 <NeedHelpHarry> let odds = filter odd [1..]
15:27:08 <Iceland_jack> @let odds = filter odd [1..]
15:27:09 <lambdabot>  Defined.
15:27:15 <NeedHelpHarry> odds
15:27:21 <Iceland_jack> > odds
15:27:23 <NeedHelpHarry> @odds
15:27:23 <lambdabot>  Sequence not found.
15:27:23 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
15:27:29 <NeedHelpHarry> lol cool
15:27:30 <NeedHelpHarry> > odds
15:27:32 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
15:27:36 <NeedHelpHarry> thanks Jack
15:27:38 <Iceland_jack> > take 15 odds
15:27:39 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29]
15:27:49 <Iceland_jack> That will be 20 bucks
15:27:52 <NeedHelpHarry> head odds
15:27:55 <NeedHelpHarry> > head odds
15:27:57 <lambdabot>  1
15:28:01 <NeedHelpHarry> coolio
15:28:04 <ski> > odds (scanl1 (+) [0 ..])
15:28:05 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
15:28:06 <lambdabot>                  with actual type ‘[Integer]’
15:28:06 <lambdabot>      The function ‘odds’ is applied to one argument,
15:28:06 <cite-reader> You can PM lambdabot.
15:28:17 <ski> oh, right
15:28:19 <NeedHelpHarry> how do I pm
15:28:21 <ski> > filter odd (scanl1 (+) [0 ..])
15:28:23 <lambdabot>  [1,3,15,21,45,55,91,105,153,171,231,253,325,351,435,465,561,595,703,741,861,...
15:28:35 <NeedHelpHarry> what is scanl1?
15:28:36 <cite-reader> Usually you type "/msg lambdabot".
15:28:39 <ski> /msg lambdabot > take 15 odds
15:28:40 <NeedHelpHarry> oh cool
15:28:57 <ski> > scanl1 (+) [0 ..]  :: [Expr]
15:28:58 <lambdabot>  [0,0 + 1,0 + 1 + 2,0 + 1 + 2 + 3,0 + 1 + 2 + 3 + 4,0 + 1 + 2 + 3 + 4 + 5,0 +...
15:29:20 <ski> > scanl1 f [a,b,c]
15:29:21 <lambdabot>  [a,f a b,f (f a b) c]
15:29:27 <ski> > scanl f z [a,b,c]
15:29:28 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c]
15:29:29 <longview> greg`: haskellbook is great, yeah. as for the pattern expansion, ghc-mod might have something, but I've never tried. I like typing stuff by myself
15:29:54 <NeedHelpHarry> how can I filter a list of numbers to primes only using list comprehension and not filter
15:30:19 <ski> > [n | n <- scanl1 (+) [0 ..],odd n]
15:30:21 <lambdabot>  [1,3,15,21,45,55,91,105,153,171,231,253,325,351,435,465,561,595,703,741,861,...
15:31:48 <NeedHelpHarry> > takeWhile (<100) odds
15:31:50 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
15:35:39 <ski> > takeWhile (< 30) odds
15:35:41 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29]
15:44:51 <NeedHelpHarry> is there an alternative to filter?
15:47:10 <ski> NeedHelpHarry : list comprehensions ?
15:47:38 * NeedHelpHarry yeah
15:47:50 <NeedHelpHarry> ski: yeah
15:51:15 <Lovepon> NeedHelpHarry: What do you need?
15:51:17 <Lovepon> Oh.
15:51:52 <ski> NeedHelpHarry : i showed about how to do filtering with list comprehensions
15:53:02 <NeedHelpHarry> Wait ski what did you show
15:53:05 <NeedHelpHarry> above?
15:53:14 <NeedHelpHarry> liek with scna?
15:53:18 <NeedHelpHarry> like with scan?
15:54:42 <ski> > [n | n <- scanl1 (+) [0 ..],odd n]
15:54:43 <lambdabot>  [1,3,15,21,45,55,91,105,153,171,231,253,325,351,435,465,561,595,703,741,861,...
15:54:44 <ski> is the same as
15:54:52 <ski> > filter odd (scanl1 (+) [0 ..])
15:54:54 <lambdabot>  [1,3,15,21,45,55,91,105,153,171,231,253,325,351,435,465,561,595,703,741,861,...
15:56:24 <NeedHelpHarry> How are they the same?
15:56:34 <NeedHelpHarry> I dont understand the first statement 
15:57:56 <geekosaur> you asked about list comprehensions, didn't you?
15:58:00 <NeedHelpHarry> Yeah
15:58:04 <NeedHelpHarry> I am really new to them
15:58:43 <NeedHelpHarry> Can someone explain this
15:58:44 <NeedHelpHarry> ilter odd (scanl1 (+) [0 ..])
15:58:51 <NeedHelpHarry> filter*
15:59:17 <ski> > [n | n <- [5,7,1,4,2,8],n > 4]
15:59:19 <lambdabot>  [5,7,8]
15:59:25 <NeedHelpHarry> I dont understand the scanl part
15:59:34 <Cale> NeedHelpHarry: So that's going to construct a list of all the triangular numbers, and filter it to leave only those which are odd
15:59:34 <NeedHelpHarry> that makes ense ski
15:59:46 <Cale> > scanl1 (+) [0..]
15:59:47 <ski> you don't need to understand the `scanl' part here, you only need to know that
15:59:48 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
15:59:52 <ski> > scanl1 (+) [0 ..]
15:59:53 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
16:00:07 <Cale> This is [0, 0+1, 0+1+2, 0+1+2+3, ...]
16:00:15 <ski> > scanl1 (+) [0 ..]  :: [Expr]
16:00:16 <lambdabot>  [0,0 + 1,0 + 1 + 2,0 + 1 + 2 + 3,0 + 1 + 2 + 3 + 4,0 + 1 + 2 + 3 + 4 + 5,0 +...
16:00:39 <NeedHelpHarry> Oh I see now
16:01:36 <NeedHelpHarry> So if I was to take the list of numbers [2 ..] and turn it into the list of primes
16:01:41 <NeedHelpHarry> [2 ..]
16:01:52 <NeedHelpHarry> > [2 ..]
16:01:54 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
16:02:12 <NeedHelpHarry> hmm
16:02:33 <NeedHelpHarry> I will need a prime testing funtion
16:02:43 <augur> bloggity blog blog blog   http://languagengine.co/blog/differentiating-regular-expressions/
16:03:18 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes -- here's one way to do it
16:03:19 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:03:54 <Cale> Note that the prime testing function here is actually using the list of all primes in its definition, and vice-versa
16:04:17 <Cale> The fact that 2 is explicitly added to the beginning of the list of primes is enough to get the whole process moving.
16:04:18 <NeedHelpHarry> [n | n <- [2..] , isnprime]
16:04:33 <NeedHelpHarry> Ohh
16:05:03 <NeedHelpHarry> I dont htink i am allowed to use isprime
16:05:32 <NeedHelpHarry> wait
16:06:01 <NeedHelpHarry> oh cool
16:06:10 <NeedHelpHarry> what does all do?
16:06:31 <Cale> all p xs checks whether p x is True for all the elements of xs
16:07:03 <Cale> @src all
16:07:03 <lambdabot> all p = and . map p
16:07:08 <Cale> @src and
16:07:08 <lambdabot> and = foldr (&&) True
16:08:09 <NeedHelpHarry> @src in
16:08:09 <lambdabot> Source not found. I feel much better now.
16:08:23 <NeedHelpHarry> oh in primes is not part of iit
16:08:45 <NeedHelpHarry> Thanks Cale
16:09:54 <ski> > evalCont $ forM [0,1,2] =<< argFC
16:09:56 <lambdabot>  [0,0,0]
16:10:24 <NeedHelpHarry> Is it possible to modify an already existing list?
16:10:28 <ski> no
16:10:44 <NeedHelpHarry> ok
16:17:30 <NeedHelpHarry> > [3, 5..]
16:17:31 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
16:19:00 <ij> Can I compile .cabal less stuff with stack? Do I just need stack.yaml? 
16:20:35 <geekosaur> stack.yaml tells stack what packages are available, it does not tell stack what packages your program requires to be installed
16:21:25 <ij> Suppose it's just a single .hs file.
16:21:36 <ij> ... which, in this caes, it is. :)
16:24:01 <hjljo> i think you could use the --package flag
16:25:33 <hjljo> i haven't actually done that though, i just saw it in the Turtle tutorial
16:26:25 <ij> I'll have a look at it tomorrow, thanks and night night!
16:28:58 <NeedHelpHarry> @paste
16:28:59 <lambdabot> Haskell pastebin: http://lpaste.net/
16:30:00 <NeedHelpHarry> Anyone know how I can fix my primes definition?
16:30:05 <NeedHelpHarry> http://lpaste.net/162697
16:31:35 * NeedHelpHarry 73.4.238.129
16:31:51 * NeedHelpHarry http://lpaste.net/162697
16:31:53 <NeedHelpHarry> lol oops
16:32:06 <Cale> NeedHelpHarry: Move the "2 :" bit out of the list comprehension
16:32:20 <NeedHelpHarry> Where should it be?
16:32:25 <Cale> NeedHelpHarry: This way of doing things, it sort of needs a prime to get started with
16:32:45 <Cale> primes = 2 : [n | n <- [3,5..], isPrime n]
16:32:52 <NeedHelpHarry> Oh
16:32:56 <NeedHelpHarry> Okay that makes sense
16:33:02 <NeedHelpHarry> I thought it could read the first one from inside
16:33:13 <Cale> Yeah, but it'll try to check isPrime 2 then
16:33:54 <NeedHelpHarry> It works
16:34:03 <NeedHelpHarry> THANKS CANE!!
16:34:35 <hjljo> ij, i mangaged to compile something using "stack ghc --package lens -- qwerty.hs -o out"
16:34:57 <Cale> and then in the course of doing that, it'll get into a loop, because it'll need to determine at least the first element of the list of primes in order to know if there are any primes p such that p*p <= 2
16:35:12 <Cale> but it was already trying to figure out if 2 was the first element, right?
16:38:26 <NeedHelpHarry> Yeah
16:38:29 <NeedHelpHarry> thanks Cale
16:41:32 <obadz> Is there a ghci command I can use to ask which module a given symbol lives in?
16:43:13 <dcz_> my first haskell program finally :D https://github.com/dyrnade/hs/blob/master/creditcard_validator.hs
16:43:42 <peddie> congrats dcz_
16:44:27 <dcz_> thank you so much
16:44:41 <dcz_> do you have any suggestions to improve this code ?
16:44:45 <peddie> did you have fun?
16:44:57 <NeedHelpHarry> thats awesome dcz_
16:44:59 <dcz_> yeah, it was fun but hard also
16:45:13 <maerwald> dcz_: are you doing cis?
16:45:20 <dcz_> thank you so much NeedHelpHarry
16:45:35 <hjljo> dcz_, you could merge the == and < guards with <=
16:45:41 <dcz_> maerwald : yeap i am following that
16:45:48 <dcz_> https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
16:45:50 <maerwald> k, then I won't spoil :P
16:45:59 <dcz_> why ? :D
16:46:15 <maerwald> because the next chapters will involve higher-order functions like foldr
16:46:29 <maerwald> which you can then use to make those functions "smaller"
16:46:35 <dcz_> ahh okey i got you what meant
16:47:15 <dcz_> hjljo : you are right :D
16:47:26 <hjljo> dcz_, also "[a] ++ b" is "a:b"
16:48:43 <dcz_> that means ?
16:49:29 <maerwald> dcz_: you already use that notation when you pattern match
16:49:35 <maerwald> (x : [])
16:49:36 <hjljo> instead of writing "[n `mod` 10] ++ toDigitsRev(n `div` 10)" you can write "n `mod` 10 : toDigitsRev(n `div` 10)"
16:51:17 <hjljo> oh and "f (g x)" is more idiomatic than "f(g x)", especially "f x" rather than "f(x)" :3
16:51:49 <dcz_> when i do this ,   | otherwise = [n `mod` 10] : toDigitsRev(n `div` 10) , it gives error
16:52:10 <peddie> :t (:)
16:52:11 <lambdabot> a -> [a] -> [a]
16:52:16 <hjljo> i recommend using https://github.com/ndmitchell/hlint#installing-and-running-hlint it's great for this sort of stuff
16:52:27 <maerwald> dcz_: on the left hand-side of : is a single element, on the right side a list
16:52:38 <hjljo> dcz_, yup, drop the square brackets
16:54:00 <hjljo> i find myself doing the f(x) thing a lot after programming in other languages
16:54:32 <dcz_> :D
16:54:39 <dcz_> i am sorry i dont understand you too much
16:55:07 <dcz_> whats the difference between  f (g x) and f(g x)
16:55:15 <hpc> for extra fun, in javascript you can do f(x)(y)
16:55:22 <hpc> dcz_: appearance
16:55:49 <NeedHelpHarry> Hmm
16:56:00 <NeedHelpHarry> I have a braintwister if anyone has any idea how to approach it
16:56:18 <NeedHelpHarry> I need to build map
16:56:21 <NeedHelpHarry> using fold
16:56:33 <maerwald> javascript is: var foo = function(bar, function (callback) { baba ; callback(this); }) { something foo bar } ) ) )DidIMissABracket?;
16:56:43 <hjljo> dcz_, by idiomatic i mean "f (g x)" is more of a standard style than "f(g x)", they both mean the same thing though
16:57:02 <hpc> heh, yeah
16:57:09 <dcz_> ahh okey
16:57:16 <hpc> javascript is a lisp where you end an sexpr with }); instead of just )
16:57:17 <ddflare> Does anyone want to help me start  a project. I like some of the others and thought it would be cool to create one out of python, mysql, php, c++, etc. Ohh well tell me if you do, P.S. I am not going to be paying any money. Its just for fun and learning. I have lots of ideas, maybe even an api and something that will make it unique. Like being able to host a game server and a website
16:58:07 <maerwald> ddflare: is that related to haskell?
16:58:08 <jaarod> dcz you need parenthesis because if you typed `f g x' it would try to pass g to f
16:58:12 <dcz_> :D
16:58:19 <ddflare> yes :D
16:58:27 <maerwald> how?
16:58:27 <dcz_> jaarod : where ?
16:58:37 <dcz_> which line
16:58:57 <ddflare> well it will be like php, I will use haskell for maybe a api or something like that
16:59:01 <ddflare> idk
16:59:03 <jaarod> dcz_ f (g x)
16:59:09 <maerwald> ddflare: have you done haskell before?
16:59:15 <hpc> ddflare: sounds like you need acme-php
16:59:16 <ddflare> Ish
16:59:24 <ddflare> Ill add that too
16:59:34 <ddflare> MAybe even start a channel 
16:59:39 <ddflare> Thx for ideas :D
17:00:45 <ddflare> ITs empty I joined #acme-php
17:01:07 <dcz_> is it okey now ? https://github.com/dyrnade/hs/blob/master/creditcard_validator.hs
17:01:07 <ddflare> My channel is #projectHOST
17:01:58 <ddflare> dcz: https://github.com/dyrnade/hs/pull/1
17:02:33 <dcz_> why there ?
17:02:37 <hjljo> dcz_, looks good, except for the higher order fn thing that maerwald mentioned but you'll come to that :3
17:03:07 <ddflare> dcz_: its a pull request
17:03:11 <dcz_> okey thank you for suggestions, i really appreciated
17:03:12 <ddflare> dcz_: Approve it
17:03:22 <dcz_> ddflare : why three ?
17:03:41 <dcz_> https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
17:03:46 <hjljo> dcz_, i think he's trolling
17:03:47 <ddflare> dcz_: Because with the int 2 is even 1 is odd
17:03:56 <ddflare> Also I am not trolling
17:03:59 <dcz_> so ? :D
17:07:56 <dcz_> i am sorry who is hasufell ? 
17:08:08 <ddflare> Does anyone want to help me start  a project. I like some of the others and thought it would be cool to create one out of python, mysql, php, c++, etc. Ohh well tell me if you do, P.S. I am not going to be paying any money. Its just for fun and learning. I have lots of ideas, maybe even an api and something that will make it unique. Like being able to host a game server and a website
17:08:16 <ddflare> Join #projectHOST to help
17:09:38 <maerwald> ddflare: you already said that
17:09:50 <ddflare> Im sorry
17:09:59 <ddflare> Can someone review my code https://github.com/WebParakeet/webp-octa-installer/blob/master/octa-installer.sh
17:10:13 <ddflare> I do not know how to install haskell
17:10:51 <peddie> ddflare: maybe ask for reviews of bash code in #bash?
17:11:19 <peddie> @where stack <-- ddflare
17:11:19 <lambdabot> I know nothing about stack.
17:11:21 <peddie> aww
17:11:35 <peddie> http://docs.haskellstack.org/en/stable/README/  <-- ddflare 
17:12:00 <ddflare> Can you impliment
17:12:10 <ddflare> https://github.com/WebParakeet/webp-octa-installer
17:12:34 <hjljo> mods plz
17:12:49 <peddie> ddflare: no, but i can help if you want to learn haskell
17:13:05 <ddflare> Ps script will be called by bash octa-install.sh
17:13:37 <peddie> ddflare: are you aware that this channel is for discussing the haskell programming language?  it's not for random bash installer questions.
17:13:40 <Cale> ddflare: This channel is for discussion of the programming language called Haskell.
17:13:51 <dcz_> thank you for hlint suggestion
17:13:57 <ddflare> k
17:14:12 <NeedHelpHarry> Anyone have any tips on how to implement map using fold
17:14:14 <ddflare> Ok but it installs it auto
17:14:42 --- mode: ChanServ set +o Cale
17:14:59 <jaarod> > let mymap f = foldr ((:) . f) [] in mymap (^2) [0..]
17:15:00 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
17:15:30 <Cale> ddflare: If you don't have any questions or comments about Haskell, please take it elsewhere.
17:15:40 <ddflare> ok thx
17:16:01 <NeedHelpHarry> I have no idea where to start
17:16:15 <hpc> NeedHelpHarry: is this homework?
17:16:20 <NeedHelpHarry> yeah
17:16:41 <hpc> does the question just say "fold"?
17:16:56 <NeedHelpHarry> "For this problem, you need to build map using fold."
17:17:00 <jaarod> i wish they'd make us write haskell code for homework
17:17:06 <hjljo> ikr
17:17:13 <NeedHelpHarry> lol
17:17:22 <hpc> @quote crie
17:17:22 <lambdabot> Ferdirand says: I was TA for a C++ programming course aimed at 1st year physics once. Some girl asked for help "i wrote pseudo-code but I cannot translate it to C++". Her pseudo-code was valid haskell. I cried.
17:17:37 <NeedHelpHarry> lollllll
17:17:58 <hpc> NeedHelpHarry: so i'll just assume it means foldr then, because otherwise the problem doesn't really make sense
17:18:01 <hpc> :t foldr
17:18:02 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:18:05 <NeedHelpHarry> yes I imagine
17:18:13 <hpc> well, pretend t = [] there
17:18:25 <NeedHelpHarry> ok
17:18:27 <hpc> :t map
17:18:28 <lambdabot> (a -> b) -> [a] -> [b]
17:18:44 <hpc> so yourMap is going to be something like
17:18:58 <hpc> yourMap f xs = ?
17:19:28 <NeedHelpHarry> exactly
17:19:30 <hpc> so f and xs are going to be applied to foldr in some way
17:19:47 <hpc> and the result is of type [b], so you can substitute that into foldr's type for its result
17:20:08 <hpc> foldr :: (a -> [b] -> [b]) -> [b] -> [a] -> [b]
17:20:55 <NeedHelpHarry> ok I think you lost me
17:21:13 <jaarod> do you know how foldr works? and what its arguments are
17:21:19 <NeedHelpHarry> yes
17:22:16 <NeedHelpHarry> why do you substitute?
17:22:27 <dcz_> have a good night guys
17:22:43 <NeedHelpHarry> you too man
17:22:52 <NeedHelpHarry> or woman
17:22:54 <ddflare> sinisalo.freenode.net [SE]?? What is
17:23:04 <hpc> so, yourMap f xs = foldr {something with f xs}
17:23:15 <hpc> yourMap :: (a -> b) -> [a] -> [b]
17:23:38 <hpc> and just to make it a bit less confusing, we'll say foldr :: (a' -> b' -> b') -> b' -> [a'] -> b'
17:23:52 <hpc> because yourMap's result is the result of foldr, that makes b' = [b]
17:24:40 <hpc> so for that specific usage of foldr, you can use a more specific type which hopefully makes it easier to see the next step
17:25:59 <NeedHelpHarry> I'm not sure if I know what type that will be
17:27:04 <hpc> well, substitute [b] for b', and you'll get foldr :: (a' -> [b] -> [b]) -> [b] -> [a'] -> [b]
17:27:36 <hpc> which doesn't completely narrow it down
17:27:57 <hpc> but there's another thing we can do, which is to just take it case by case
17:28:15 <hpc> so, mapping over the empty list produces the empty list
17:28:24 <hpc> @src foldr
17:28:27 <lambdabot> foldr f z []     = z
17:28:29 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:28:46 <hpc> here's the definition of foldr
17:29:02 <NeedHelpHarry> ok
17:29:04 <hpc> and remember with the more specific type of this particular usage, z :: [a
17:29:10 <hpc> z :: [a']
17:29:30 <hpc> figure out how to make it work for the empty list, and don't even worry about what to do when there's a cons
17:29:45 <hpc> it can crash or anything
17:30:01 <hpc> as long as it works for [] and uses foldr, you're halfway there
17:30:07 <NeedHelpHarry> ok
17:30:28 * hpc is going to brb but that should be enough to give you some direction without giving away the whole exercise
17:31:57 <jaarod> NeedHelpHarry, foldr f d [1,2,3], do you know what arguments will f accept on first call?
17:32:14 <NeedHelpHarry> Thanks hpc
17:32:15 <hjljo> maybe it helps to think of the f as a fn that combines a "new element on the left" and a "result so far on the right"
17:32:19 <NeedHelpHarry> and
17:32:31 <NeedHelpHarry> jaarod: what do you mena
17:32:33 <NeedHelpHarry> mean
17:33:10 <jaarod> in `foldr f d [1,2,3]' foldr will call f multiple times, yes? what arguments will it pass to f on the first call
17:33:40 <NeedHelpHarry> 1
17:33:54 <NeedHelpHarry> ?
17:34:08 <jaarod> and the second argument?
17:34:22 <jaarod> first one will be 1 yeah
17:34:32 <NeedHelpHarry> 2
17:34:35 <jaarod> no
17:34:38 <NeedHelpHarry> oh
17:34:41 <jaarod> see the definition
17:34:47 <jaarod> @src foldr
17:34:47 <lambdabot> foldr f z []     = z
17:34:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:34:56 <NeedHelpHarry> the recursive call
17:35:46 <jaarod> yeah. you can think of that recursive call as remaining elements that haven't been computed yet
17:36:01 <NeedHelpHarry> yeah
17:36:03 <NeedHelpHarry> I get that
17:36:06 <jaarod> that will be second argument to f, usually named xs
17:36:13 <NeedHelpHarry> yes
17:37:03 <jaarod> so (\x xs -> ...)?
17:37:34 <NeedHelpHarry> what is that lambda function for
17:38:02 <jaarod> that is f that you should pass to foldr. you can make it a named function too if that makes it easier
17:38:27 <NeedHelpHarry> ohhh
17:38:28 <NeedHelpHarry> I see
17:39:16 <NeedHelpHarry> so the call is foldr (\x xs -> ...) z 
17:39:27 <EvanR> dude, functional programming conference in cuba?
17:39:30 <jaarod> yes. just fill in ... and z
17:39:51 <jaarod> :t map
17:39:52 <lambdabot> (a -> b) -> [a] -> [b]
17:40:00 <EvanR> will it all be in spanish
17:40:38 <NeedHelpHarry> hmm
17:41:39 <jaarod> one important thing, not sure if i was clear enough, the type of x in above lambda is `a', but the type of xs is [b]. it is (yet to be computed) result of all the remaining elements, each one being passed to that f you are writing
17:42:04 <monochrom> what do you know, soon there will be a functional programming conference in north korea too :)
17:42:27 <EvanR> really?
17:42:33 <monochrom> joking!
17:42:44 <NeedHelpHarry> yes I understand jaarod, thanks
17:42:51 <EvanR> i always needed an excuse to travel in enemy countries
17:43:07 <simpson> Cuba sounds like a nice place to visit. I wonder whether it'll finally turn into a beautiful tourist destination like it was last century.
17:44:05 <apricity> i'm just starting to learn haskell, and have neovim set up with vim-haskell-now. I'm trying to get a good workflow going for learning. I have tmux with vim in one window and ghci in the other can can send highlighted txt via ,rs ... do i have to load files into ghci though before sending code to ghci?
17:44:15 <NeedHelpHarry> @src map
17:44:15 <lambdabot> map _ []     = []
17:44:15 <lambdabot> map f (x:xs) = f x : map f xs
17:44:48 <jaarod> NeedHelpHarry, so, as far as your function is concerned, xs already contains elements that you want. so you just have to transform x and combine it with xs
17:45:11 <NeedHelpHarry> oohhhh
17:45:14 <NeedHelpHarry> that makes sense
17:45:21 <jaarod> @src foldr
17:45:21 <lambdabot> foldr f z []     = z
17:45:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:47:35 <jaarod> so lets call it ys to avoid confusing it with xs that yourMap accepts.   yourMap f xs = foldr (\x ys -> ...) d xs
17:47:39 <jaarod> try filling in ...
17:48:07 <NeedHelpHarry> ohh its not xs
17:48:10 <NeedHelpHarry> i was confusing that
17:48:20 <idev> jle`: https://gist.github.com/anonymous/be17a333d59457c33d4e74f0c078f797 <-- any idea what's going on here?
17:48:23 <jaarod> that is just a name. it can be anything
17:48:37 <jaarod> but yes xs in lambda is not the same xs as in the function that yourMap accepts
17:48:54 <NeedHelpHarry> Yeah i forgot that its just lambda args
17:49:10 <NeedHelpHarry> alrght so i will fill this out
17:49:10 <NeedHelpHarry> myMap f xs = foldr (\x ys -> ...) d xs
17:49:49 <jaarod> ... and d. d is what foldr passes to your function after it runs out of all the elements
17:49:54 <jaarod> @src foldr
17:49:55 <lambdabot> foldr f z []     = z
17:49:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:50:19 <jaarod> named z there
17:50:24 <NeedHelpHarry> yes
17:50:25 <NeedHelpHarry> I got tht
17:50:27 <NeedHelpHarry> that
17:52:58 <NeedHelpHarry> I will be right back
17:53:48 * hackagebot brick 0.5.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.5.1 (JonathanDaugherty)
17:56:07 <ski> > evalCont $ (100 +) <$> callCC (\k -> do (k,n) <- replicateCC 4 (k,1); k (10 + n))
17:56:09 <lambdabot>  141
17:58:53 <Zemyla> Why is it only strings that are turned into solid blocks of data?
17:59:44 <Zemyla> If you have an [Int], say, [1, 5, 2, 9], it's stored in the program as 1:5:2:9:[].
17:59:54 <NeedHelpHarry> jaarod: I am stuck
18:02:44 <Cale> Zemyla: I guess because nobody's needed that enough to do it yet.
18:04:41 <geekosaur> wouldn't be surprised if it's listed as an implementable somewhere on the ghc trac
18:05:31 <jaarod> NeedHelpHarry try writing out the types. or use holes and ghci will type it out for you
18:07:37 <NeedHelpHarry> ok
18:11:48 <ski> @type replicateCC
18:11:49 <lambdabot> (Integral i, MonadCont m) => i -> (a -> m Void, a) -> m (a -> m o, a)
18:11:54 <ski> @type replicateCC1
18:11:55 <lambdabot> (Integral i, MonadCont m) => i -> (a -> m o, a) -> m (a -> m o, a)
18:12:34 <hpc> odd that it takes a tuple
18:12:59 <ski> > evalCont $ (100 +) <$> callCC (\k -> do (k,n) <- replicateCC 4 (k,1); k (10 + n))
18:13:01 <lambdabot>  141
18:13:03 <ski> is a sample use
18:13:24 <ski> `replicateCC1' doesn't work for zero input, but `replicateCC' does
18:13:50 <hpc> i mean like, why not curry it
18:14:25 <ski> > evalCont $ (100 +) <$> callCC (\k -> do (k,n) <- (replicateCC 3 <=< replicateCC 2) (k,1); k (10 + n))
18:14:27 <lambdabot>  161
18:14:36 <hpc> or well, why uncurry it to begin with
18:14:53 <ski> to align the input and output types better
18:15:36 <hpc> eh, i suppose
18:15:55 <ski> > evalCont $ (100 +) <$> callCC (\k -> uncurry (. (10 +)) =<< replicateCC 3 (k,1))
18:15:57 <lambdabot>  131
18:16:04 <hpc> those examples come off really poorly on one line too ;)
18:16:33 <hpc> it took me a moment, but i imagine others will need to manually reformat them
18:16:44 <hpc> in notepad or something
18:17:54 <ski> `replicateCC n (k,a)' monadically returns `n' times
18:18:26 <ski> let's say `n = 3'
18:23:25 <ski> `replicateCC 3 (k3,a0)' monadically returns `(k1,a0)' such that when `k1' is called with `a1' (computed from `a0' in some fashion), the `replicateCC' call monadically returns again with `(k2,a1)'
18:24:18 <ski> now when `k2' is called with `a2' (computed in the same way as before, but from `a1' this time), `replicateCC' monadically returns with `(k3,a2)' (the original `k3')
18:24:28 <ski> and `k3' is then eventually called with `a3' (computed from `a2')
18:25:06 <ski> `replicateCC1' behaves the same (but doesn't allow the count to be zero)
18:25:28 <ski> `replicateCC 0 (k0,a0)' obviously just calls `k0' with `a0' immediately
18:26:58 <NeedHelpHarry> Can someone explain this in enlgish
18:26:59 <NeedHelpHarry> myMap f xs = foldr (\z zs -> (f z) : zs) [] xs
18:27:10 <NeedHelpHarry> from what i gather
18:27:13 <NeedHelpHarry> it mean
18:29:15 <NeedHelpHarry> it uses foldr with arguments that consist of a lambda function, a base case of empty string, and the string to be mapped
18:30:27 <NeedHelpHarry> the lambda function uses the function f given, and applies it to the base case, and the result is prepended to the rest of the list, given as well
18:30:28 <ski> yes
18:30:59 <ski> "and applies it to the base case" -- no. it applies `f' to the current element `z'
18:31:19 <NeedHelpHarry> ok
18:31:43 <ski> also, to be clear, `zs' is not the rest of the input list, but the rest of the output list (that we're building right now)
18:31:51 <NeedHelpHarry> yes
18:31:53 <ski> perhaps you already understood that part
18:31:58 <NeedHelpHarry> I shouldve clarified
18:32:11 <NeedHelpHarry> So then I am confused what happens next
18:32:25 <ski> also, instead of `(f z) : zs', you could just say `f z : zs'
18:32:37 <ski> NeedHelpHarry : nothing more happens
18:32:57 <ski> NeedHelpHarry : `[]' in the input list is replaced by `[]' in the output list
18:33:24 <ski> NeedHelpHarry : `(:)' in the input list is replaced by `\z zs -> f z : zs' in the output list
18:33:27 <ski> consider
18:34:02 <ski>      foldr (\z zs -> f z : zs) [] (a : b : c : d : [])
18:34:39 <ski>   =  foldr (\z zs -> f z : zs) [] ((:) a ((:) b ((:) c ((:) d []))))
18:34:48 <NeedHelpHarry> z is constantly changing right
18:35:02 <ski>   =  (\z zs -> f z : zs) a ((\z zs -> f z : zs) b ((\z zs -> f z : zs) c ((\z zs -> f z : zs) d [])))
18:35:12 <NeedHelpHarry> ohhh
18:35:31 <ski>   =  f a : (f b : (f c : (f d : [])))
18:36:24 <ski> if you want to, i could do the last step incrementally :
18:36:28 <ski>   =  (\z zs -> f z : zs) a ((\z zs -> f z : zs) b ((\z zs -> f z : zs) c ((\z zs -> f z : zs) d [])))
18:36:36 <NeedHelpHarry> yes please
18:36:44 <ski>   =  f a : ((\z zs -> f z : zs) b ((\z zs -> f z : zs) c ((\z zs -> f z : zs) d [])))
18:37:03 <ski>   =  f a : f b : (\z zs -> f z : zs) c ((\z zs -> f z : zs) d [])
18:37:11 <ski>   =  f a : f b : f c : (\z zs -> f z : zs) d []
18:37:18 <ski>   =  f a : f b : f c : f d : []
18:37:47 <ski> or, alternatively, doing it one step of `foldr' at a time (which is what actually happens)
18:38:16 <ski>      foldr (\z zs -> f z : zs) [] (a : b : c : d : [])
18:38:26 <ski>   =  f a : foldr (\z zs -> f z : zs) [] (b : c : d : [])
18:38:33 <ski>   =  f a : f b : foldr (\z zs -> f z : zs) [] (c : d : [])
18:38:40 <ski>   =  f a : f b : f c : foldr (\z zs -> f z : zs) [] (d : [])
18:38:47 <ski>   =  f a : f b : f c : f d : foldr (\z zs -> f z : zs) [] []
18:38:51 <ski>   =  f a : f b : f c : f d : []
18:39:00 <NeedHelpHarry> ok
18:39:21 <NeedHelpHarry> makes more sense now
18:39:24 <NeedHelpHarry> thank you so much
18:40:00 <ski> i omitted the boring steps about how `(\z zs -> f z : zs) a (foldr (\z zs -> f z : zs) [] (b : c : d : []))' reduces first `(\zs -> f a : zs) a (foldr (\z zs -> f z : zs) [] (b : c : d : []))' and then to `f a : foldr (\z zs -> f z : zs) [] (b : c : d : [])'
18:40:09 <ski> (and similarly for the other ones)
18:40:18 <ski> NeedHelpHarry : yw
18:40:58 <ski> NeedHelpHarry : however, it's still a good conceptual picture to have that `foldr f z' replaces `(:)' with `f' and `[]' with `z'
18:41:09 <ski> > foldr f z (a : b : c : d : [])
18:41:10 <lambdabot>  f a (f b (f c (f d z)))
18:41:17 <ski> > foldr f z [a,b,c,d]
18:41:19 <lambdabot>  f a (f b (f c (f d z)))
18:41:23 <NeedHelpHarry> yes
18:41:46 <ski> @where folds
18:41:46 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
18:41:55 <ski> NeedHelpHarry : see that ^ as well
18:42:51 <Rotaerk> hmm, kind of bugs me that these libraries take ByteString values all over the place without documenting what they're supposed to contain
18:42:53 <NeedHelpHarry> cool
18:46:30 <nitrix> Hi, out of curiosity, how would someone implement an array in Haskell using algebraic data types?
18:47:00 <Rotaerk> for instance Data.Conduit.Network.TLS's tlsClientConfig function takes a ByteString that's the host name
18:47:00 <Axman6> data Arr a = One a | Two a a | Three a a a | Four a a a a
18:47:01 <nitrix> If we ignore the existing libraries; is it even possible to do so while keeping the familiar time complexity?
18:47:12 <Axman6> I'm kidding of course
18:47:25 <Rotaerk> but it doesn't say what kind of format I'm supposed to encode the hostname in
18:47:32 <Axman6> Data.Seq is a good example of how to get something very close
18:48:07 <Axman6> turns O(1) things into O(log n) things in most cases, but turns some O(n) operations into O(log n) too
18:48:16 <Axman6> or O(n) into O(1)
18:48:30 <Rotaerk> the same problem applies to these IRC libraries
18:50:20 <NeedHelpHarry> Thank you to all of you that helped me 
18:50:24 <NeedHelpHarry> I have to go now
18:50:35 <NeedHelpHarry> good luck with all your endeavors
18:50:55 <Rotaerk> in one place in the source code, the bytestring is being decoded as UTF8, but in another it's being unpacked with Data.ByteString.Char8.unpack
18:51:39 <ski> Rotaerk : .. sounds like a recipe for disaster ?
18:51:48 <Rotaerk> yea
18:53:36 <Rotaerk> I'm not sure why Data.Conduit.Network.TLS even takes a ByteString, when it unpacks it anyway; should just consume a String
18:55:47 <tubs> What are the times people are normally on here?
18:59:42 <Axman6> always
18:59:56 <geekosaur> http://ircbrowse.net/haskell has a chart of active times, looks like the usual peak is 2000-2300 UTC but it's never really silent
18:59:58 <Clint> 110% of the times
19:00:08 <tubs> Ok cool
19:00:18 <tubs> I'm probably gonna have some questions tomorrow lol
19:00:27 <tubs> At like 10ish EST
19:00:51 <nitrix> tubs: We'll all make sure to be there just for you.
19:00:56 <tubs> Lol :p
19:02:25 <nitrix> tubs: No stress.
19:02:59 <tubs> I'm gonna set a timer, you better be here :p
19:03:45 <zRecursive> @wn gonna
19:03:46 <lambdabot> No match for "gonna".
19:03:50 * hackagebot th-reify-many 0.1.5 - Recurseively reify template haskell datatype info  https://hackage.haskell.org/package/th-reify-many-0.1.5 (MichaelSloan)
19:31:24 <Rotaerk> hmm, actually, I suspect Data.Conduit.Network.TLS just consumes a ByteString instead of a String to be consistent with other network libraries...
19:31:31 <Rotaerk> but the pattern makes no sense to me
19:31:50 <Rotaerk> Data.Streaming.Network also consumes a ByteString and immediately converts it to a String
19:31:54 <Rotaerk> what's the ... point
19:41:37 <geekosaur> someone whined about it taking String?
19:42:09 <aleogen> does anyone use HaPy anymore?
19:47:17 <Rotaerk> string, or something conceptually equivalent, is really the only thing that makes sense
19:47:33 <Rotaerk> host names are text
19:48:51 * hackagebot th-utilities 0.1.0.0 - Collection of useful functions for use with Template Haskell  https://hackage.haskell.org/package/th-utilities-0.1.0.0 (MichaelSloan)
19:48:53 <zRecursive> Rotaerk: what's the diff between string and text ?
19:50:20 <geekosaur> well, technically hostnames are octet strings (granted there's the Punycode hack but that's to make them fit in octet strings)
19:51:59 <zRecursive> geekosaur: Is octet string byte string ?
19:52:05 <geekosaur> yes
19:52:26 <zRecursive> ok
19:53:01 <geekosaur> "octet string" is pretty much a holdover from the early days of what became the Internet, when there was still a lot of Tenex around
19:53:25 <geekosaur> and a "byte" on those was typically 9 bits (memory and registers were 36-bit words)
19:54:19 <geekosaur> but it's what the TCP/IP standards use, so we're stuck with it
19:57:51 <divyanshu> JOIN #agda
20:25:21 <Rotaerk> zRecursive, they're conceptually the same aren't they?
20:26:12 <Rotaerk> geekosaur, hm, are you referring to IPs?
20:26:17 <geekosaur> no
20:26:26 <Rotaerk> www.google.com is text, not a byte string
20:27:30 <marc__> hello?
20:28:18 <pavonia> Hi
20:28:23 <Tangerine> hi marc__
20:29:11 <geekosaur> hostnames are octet strings, which is why Punycode exists
20:29:57 <geekosaur> informally it can be treated as "text" but it is not specified as arbitrary text in RFC1035 and successors
20:30:22 <geekosaur> and formally it is clamped to octets
20:30:30 <Rotaerk> but w isn't an octet ...
20:30:55 <Rotaerk> unless it's encoded as one
20:31:05 <geekosaur> it has an octet representation via 7-bit ASCII, which is specified as part of DNS in order to support case folding
20:31:10 <apricity> does anyone here use tmux+vim+haskell+ghci in some sort of repl dev workflow?
20:31:27 <Rotaerk> so you're saying that host names are inherently 7-bit ascii encoding?
20:31:40 <geekosaur> RFC1035 is saying that
20:32:39 <geekosaur> and the Punycode extension was needed to relax it
20:34:07 <Rotaerk> it's still just an encoding though; it's still text (maybe not *arbitrary* text)
20:34:45 <Rotaerk> and I wonder why it's using Char8 as the converter and not some kind of "unpack 7-bit ASCII" when reading the host name from the ByteString
20:35:48 <lambdafan> what is the time complexity of "genericTake n fibb where fibb = 0 : 1 : zipWith (+) fibb (tail fibb)"?
20:36:14 <geekosaur> this is sounding remarkably like the folks who argued that it was completely legitimate to treat POSIX filenames as always being UTF8
20:36:23 <geekosaur> crashes and security issues notwithstanding
20:36:34 <lambdafan> fibb is 0(n) right? would it then be 0(n^2)?
20:37:34 <Rotaerk> not familiar with that argument
20:39:12 <pavonia> lambdafan: Due to lazy evaluation is should still be O(n)
20:40:10 <marc__> whats the best way to implement a minimax tree?
20:41:16 <lambdafan> pavonia thanks :)
20:59:04 <Tangerine> So I'm now learning about Monads and how they work
20:59:49 <Tangerine> so I guess generally, if you have a monadic value, and you want to use the value (i.e. IO String), you can't really "extract" the value out?
21:00:21 <Tangerine> so it feels like you can go from non-monadic things to monadic values but you can't go back?
21:01:31 <texasmynsted> what happened to the haskellcast?
21:01:58 <texasmynsted> There has not been a broadcast since Feb.
21:03:53 * hackagebot th-reify-many 0.1.5.1 - Recurseively reify template haskell datatype info  https://hackage.haskell.org/package/th-reify-many-0.1.5.1 (MichaelSloan)
21:12:08 <Rotaerk> Tangerine, some specific monads let you "extract" the value directly, but that's not a feature of the monad abstraction, so not all instances allow it
21:12:29 <Rotaerk> Maybe lets you get at the contained value in any context, but IO doesn't
21:13:56 <Tangerine> So lets say I want write a program where someone writes his name in IO and then it spits out some number
21:14:24 <lambdafan> Tangerine, what resources are you using to learn Haskell?
21:14:30 <Tangerine> in this case, I would entirely have to work with an IO String monad? and all of my functions have to deal with IO String monads?
21:14:48 <Tangerine> i'm in a class, but just asking some questions that aren't answered by the lectures
21:15:17 <lambdafan> no, write up what you think it should look like in hpaste and I'll show you how you can do you pure functions outside of IO
21:15:44 <Cale> IO String isn't a monad, IO is, and the fact that it's a monad is somewhat irrelevant. A value of type IO String describes some action which could be carried out (with I/O effects) in order to produce a String
21:15:52 <srhb> Tangerine: No, and also, IO String monads makes no sense.
21:15:58 <srhb> ^
21:16:06 <Cale> The action which gets a line of text from the user would have type IO String
21:16:28 <Cale> The action which writes back some number to the terminal might have type IO ()
21:16:57 <Tangerine> I guess my question is, how would I then use this string?
21:17:14 <lambdafan> Tangerine: use how? pass to pure function?
21:17:23 <Cale> You would presumably glue them together somehow into a larger action which would run the first action, you might apply some function String -> Integer to the line of text you get from it
21:17:27 <Tangerine> yes, that is what I meant
21:17:37 <Tangerine> pass to a pure function
21:17:54 <Cale> do x <- getLine; putStrLn (length x)
21:18:08 <lambdafan> what he said
21:18:21 <Cale> The length function needn't know or care that the String it's getting came from executing an IO action.
21:18:25 <Rotaerk> getLine >>= \x -> putStrLn (length x)
21:18:34 <Cale> er, sorry, that should certainly be print x
21:18:45 <Cale> Or putStrLn (show (length x))
21:19:07 <Cale> (which is the same)
21:19:10 <lambdafan> you mean print (length x) ?
21:19:18 <Cale> er, yeah :D
21:19:22 <Tangerine> in this case, how does "lengh" know that it can deal with both a string from an IO action or a regular string?
21:19:31 <lambdafan> string is string
21:19:43 <Cale> Tangerine: There's nothing special about the String which came from executing the IO String action.
21:20:06 <Tangerine> lets say instead of length, I write a function that for each character adds it's place in the alphabet
21:20:22 <Rotaerk> Tangerine, the String within the IO String can be accessed, but only within the context of the bind function
21:20:23 <Cale> sure, something like sum (map ord x) ?
21:20:34 <Rotaerk> and within that context it's ... just a String
21:20:37 <srhb> Tangerine: Note that in the above, x is String, not IO String
21:20:40 <Tangerine> huh interesting...
21:20:53 <Cale> Prelude Data.Char> do x <- getLine; print (sum (map ord x))
21:20:53 <Cale> hello
21:20:53 <Cale> 532
21:21:11 <Tangerine> I just had a lot of problems previously dealing with the Maybe monad, which should work the same way right?
21:21:38 <Cale> Well, it certainly works differently -- Maybe values are much different from IO action values.
21:21:48 <Cale> But there's a similarity in terms of how you're combining things
21:22:03 <Tangerine> similarity in the way that they're both monads?
21:22:08 <lambdafan> yes Maybe exposes the same interface as IO , them both being monads
21:22:30 <Tangerine> huh
21:22:38 <Cale> Yeah -- which really tells you very little -- just that return :: a -> m a and (>>=) :: m a -> (a -> m b) -> m b  are present, (and ought to satisfy some conditions)
21:22:41 <lambdafan> try it out in ghci, it's pretty nifty
21:22:54 <lambdafan> or here
21:22:57 <Cale> and in terms of those things, you get a library of stuff which works with anything that happens to be a monad
21:22:59 <lambdafan> how do I use labdabot?
21:23:10 <lambdafan> lambdabot
21:23:14 <srhb> lambdafan: > expression or :t type
21:23:14 <Cale> But as for exactly what return and (>>=) actually do, well, that depends on the instance.
21:23:20 <srhb> > (+1) 2
21:23:22 <lambdabot>  3
21:23:24 <srhb> :t Just 1
21:23:25 <lambdabot> Num a => Maybe a
21:23:30 <Tangerine> so would
21:23:38 <Tangerine> > length Just "hello"
21:23:39 <lambdabot>      Couldn't match expected type ‘[Char] -> t’ with actual type ‘Int’
21:23:39 <lambdabot>      The function ‘length’ is applied to two arguments,
21:23:39 <lambdabot>      but its type ‘(a0 -> Maybe a0) -> Int’ has only one
21:23:41 <Cale> They're just operations of a particular shape -- a pattern which shows up across many libraries.
21:24:08 <Tangerine> > length (Just "Hello")
21:24:10 <lambdabot>  1
21:24:18 <srhb> Ouch. ;-)
21:24:25 <Cale> You're getting 1 there because Maybe is an instance of Traversable
21:24:40 <Cale> and there's 1 string in that Just "hello" :)
21:24:48 <srhb> > fmap length (Just "hello")
21:24:48 <Cale> > length Nothing
21:24:49 <lambdabot>  Just 5
21:24:50 <lambdabot>  0
21:24:52 <lambdafan> > length <$> (Just "Hello")
21:24:54 <lambdabot>  Just 5
21:25:09 <Cale> > do x <- Just "hello"; return (length x)
21:25:10 <lambdabot>  Just 5
21:25:14 <lambdafan> Maybe is also a Functor
21:25:19 <Tangerine> what does <$> mean?
21:25:26 <Cale> The same thing as fmap
21:25:29 <lambdafan> it's the Functor operation, map
21:25:43 <Cale> f <$> x = do v <- x; return (f v)
21:25:56 <Cale> (whenever you also have a Monad instance)
21:26:11 <Tangerine> ok now out of curiosity
21:26:19 <Tangerine> > length <$> Nothing
21:26:21 <lambdabot>      No instance for (Foldable t0) arising from a use of ‘length’
21:26:21 <lambdabot>      The type variable ‘t0’ is ambiguous
21:26:21 <lambdabot>      Note: there are several potential instances:
21:26:38 <Cale> ah, it doesn't know what sort of thing you might want to take the length of there...
21:26:51 <Cale> > (length :: String -> Int) <$> Nothing
21:26:53 <lambdabot>  Nothing
21:27:26 <Cale> (not that it matters so much in the end, as the function itself won't get a chance to be evaluated -- but the type system doesn't know that)
21:27:31 <dsm> > length <$> Just "ABC"
21:27:33 <Tangerine> so here, you have to declare which "length" I want to use?
21:27:34 <lambdabot>  Just 3
21:27:53 <Cale> Yeah, this is a new complication because length was recently generalised:
21:27:55 <Cale> :t length
21:27:58 <lambdabot> Foldable t => t a -> Int
21:28:03 <Tangerine> Ah I see
21:28:04 <lambdafan> no, the type interference doesn't have enough to go on, so you need to tell it
21:28:06 <srhb> Tangerine: Usually it's inferred entirely from the context of your program. You put in a lot of constraints when you actually write more than oneliners :)
21:28:36 <srhb> Well, often*, is perhaps better
21:30:42 <srhb> Tangerine: But the point is that if you have (a -> b) you can always transform it to (m a -> m b) or (f a -> f b) -- so all your existing functions (like length) are already ready to be used with IO, Maybe, list, ...
21:31:22 <Tangerine> tl;dr: once you go monad you never go back
21:32:29 <lambdafan> there *is* unsafePerformIO
21:32:43 <lambdafan> : unsafePerformIO
21:32:44 <Tangerine> never SHOULD go back hehe
21:32:47 <lambdafan> :t unsafePerformIO
21:32:48 <lambdabot> Not in scope: ‘unsafePerformIO’
21:33:06 <srhb> lambdafan: That would make it possible to break the lambdabot machine. :P
21:33:32 <lambdafan> well just expose the type
21:33:47 <lambdafan> maybe that makes no sense
21:33:56 <fnordmeister> Ceiling cat is watching you perform unsafe IO.
21:34:07 <Cale> Executing IO actions as part of expression evaluation is a recipe for chaos though, and shouldn't be attempted unless you're in a situation where you'd otherwise be prepared to modify the compiler to get what you want.
21:34:33 <srhb> It can be really nifty for some very specific things...
21:34:38 <lambdafan> Cale: What about the Debug package?
21:35:04 <Cale> lambdafan: Well, Debug.Trace.trace can be useful as a temporary measure to get realistic values to test with in some cases.
21:35:32 <Cale> But you'd never want to *actually* print things that way :)
21:35:49 <lambdafan> no, yeah I just wanted to see if there was some reason I should never use it
21:36:02 <Cale> It's sort of unpredictable, since compiler optimisations may affect the order and number of occurrences of the things you print like that :D
21:36:24 <srhb> Also it hurts your brain.
21:36:42 <Cale> Obviously for debugging purposes, anything that works is fine.
21:36:47 <srhb> I spent a lot of time trying to understand why trace revealed that the second argument of (+) was evaluated first, but then I realized it wasn't the case for Double.
21:36:50 <srhb> :-)
21:39:04 <Cale> Yeah, it's also no substitute for actually understanding what's going on. Usually what I'll do is to use it to get hold of arguments to a function which is misbehaving, by doing something along the lines of adding  foo x y z | trace (unwords ["foo", show x, show y, show z]) False = undefined
21:39:10 <Cale> to the top of the definition of the function
21:39:58 <Cale> But also be careful about doing that! It can change the evaluation order, and thus the performance characteristics and termination behaviour of your function.
21:40:20 <Cale> (since showing the arguments will generally force them to be evaluated)
21:46:43 <jle`> idev: ah, sorry, i am a bit behind on making this more prominent, but the package is incompatible with new versions of ghcjs-base
21:48:02 <lambdafan> I have a fib function that generates a lazy list of fobonacci numbers. I want to verify that my function is acutally generating fibonacci numbers. The best I can come up with is taking some n numbers from the list, reversing and taking the head (which was the last number taken) and then sending that to a function that evaluates if the given number is a fibonacci number. Is there a better way?
21:48:35 <srhb> lambdafan: Prove it correct by hand, go on your business. :-P
21:48:51 <lambdafan> srhb: I am playing around with QuickCheck
21:49:06 <srhb> It's the sort of thing that is silly to test because you'll fundamentally use the definition _again_ in your test.
21:49:10 <srhb> Either it's correct or it's not.
21:49:19 <jle`> lambdafan: you can compare three consecutive items, maybe
21:49:24 <jle`> and ensure that x+y=z
21:52:07 <lambdafan> jle' : I have no question about what to do with the sample to test, but rather how to get it. It seems reversing a list is horrible
21:52:32 <srhb> A long list certainly would be, since you have to traverse it entirely.
21:52:50 <jle`> you can get three consecutive items without reversing the list...
21:52:56 <jle`> just take 3 . drop n
21:53:08 <lambdafan> jle' it would be the same three numbers each time
21:53:29 <lambdafan> 0 1 1
21:53:40 <jle`> if you want to use it to learn quickcheck, you can use it to pick random samples to pick
21:53:55 * hackagebot persistent-template 2.5.1.1 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5.1.1 (GregWeber)
21:53:56 <lambdafan> jle` ah that's what I am talking about
21:54:04 <lambdafan> jle1 thanks I know where to look
21:54:14 <jle`> so (x:y:z:_) = drop n fibs, for different n's
22:00:00 <lambdafan> okay I got it
22:00:15 <lambdafan> jle` thanks for pointing me in right direction
22:01:23 <jle`> np! but this is also a bit of an inefficient test
22:40:09 <Guest56043> pwd
22:41:17 <Guest56043> Hey everyone
22:44:58 <sshine> /usr/share/haskell
22:46:36 <idev> jle`: got Reflex.Dom.WebSockets to work
22:46:48 <jle`> oh, nice!
22:47:09 <jle`> btw, if you're not aware, ghcjs-base now has native websockets built in
22:48:56 * hackagebot auto-update 0.1.4 - Efficiently run periodic, on-demand actions  https://hackage.haskell.org/package/auto-update-0.1.4 (MichaelSnoyman)
22:49:48 <idev> are there any decent ghcjs/react bindings ?
22:56:29 <Rotaerk> idev, reflex-dom works with ghcjs
22:56:54 <Rotaerk> IIRC, it's built in terms of the GHCJS libraries
22:57:10 <Rotaerk> and works with either the GHC or GHCJS compiler
22:57:29 <cocreature> there are also a few bindings to react, see https://github.com/fpco/ghcjs-react https://hackage.haskell.org/package/react-haskell and https://hackage.haskell.org/package/react-flux but I haven’t used any of them so I can’t say whether they’re decent
23:06:39 <Tangerine> is it necessary to give main a type signature usually?
23:07:11 <simpson> Tangerine: Well, it's usually IO (), right? Not hard to figure out.
23:07:21 <cocreature> Tangerine: usually it’s not necessary, but a lot of people consider it bad style to not provide type signatures for top level functions
23:07:42 <mauke> most type signatures are not technically necessary
23:08:05 <mauke> but they help human readers, and if you make a mistake, you get better error messages with them
23:08:06 <Tangerine> my compiler with lots of warnings was yelling at me, but i guess one extra line doesn't hurt anyone
