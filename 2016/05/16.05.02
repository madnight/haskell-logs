00:00:28 <arahael> Zemyla: If you have GC, why bother having reference counting?
00:01:26 <Zemyla> So an object can be deallocated immediately rather than waiting for the next GC?
00:01:32 <arahael> Zemyla: Additionally, the aim is not to know how many or how few references you have, but whether you have any at all.
00:01:44 <arahael> Zemyla: GC's can be remarkably fast.
00:02:15 <arahael> Zemyla: In C#, for instance, your objects can be removed within the same stack frame they were allocated in - before the function itself has returned.
00:02:49 <arahael> Zemyla: And infact, the removal of an object isn't the problem.  It's how you deal with live objects that are the issue.
00:02:53 <cocreature> Zemyla: reference is usually not faster than gc it only helps if you have realtime requirements
00:03:01 <cocreature> because you can predict how long it takes
00:04:10 <arahael> Zemyla: With a GC, typically an object that is no-longer used is literally *forgotten*.
00:04:18 <arahael> Zemyla: It's allocated.  And then literally forgotten.
00:04:34 <Zemyla> And now that I think about it, in almost all circumstances (ie. not using an IOVar), you have to GC anyways to know to remove references. :V
00:04:53 <arahael> Zemyla: Conceptually, yes.  But in practice... Typically no.
00:05:02 <arahael> Zemyla: A GC doesn't need to remove the references.
00:05:35 <arahael> Zemyla: Rather, a GC observes that, after dealing with the live objects, that there's a certain amount of memory remaining. That's it, really.
00:05:43 <Zemyla> Ah well. I guess the refcounting will be saved for C++.
00:06:13 <arahael> C++ is an entirely different beast.
00:06:18 <Zemyla> It is.
00:06:37 <Zemyla> Supposedly one of the latest standards added compiler support for GCs?
00:06:45 <arahael> C++ proposes RAII instead, and does so very well; it normally doesn't use reference counts either.
00:07:43 <arahael> Difference, here, is that C++ wishes to cater for *resource* management, including memory.  They view memory as no different to any other resource.
00:07:54 <arahael> And yeah, you can add GC to C++ projects as well.
00:08:26 <arahael> Occasionally you might be in a contrived situation where ref counts make sense.  C++ allows you to do so. That's pretty much it.
00:09:49 <arahael> There are two big problems with reference counting: They don't always work, and they're slow on multithreaded systems.
00:57:14 <gfixler> lerp :: Num a => a -> a -> a -> a
00:57:16 <gfixler> lerp a b t = (b - a) * t + a
00:57:48 <gfixler> How can I make t work with a and b, but allow for things like a pair of doubles for a and b, but just a double in b?
00:58:27 <gfixler> I feel like I need a ~ b or something
00:58:31 <gfixler> lerp :: (Num a, Num b) => a -> a -> b -> a
00:58:34 <gfixler> that doesn't work
00:58:45 <gfixler> "Could not deduce (b ~ a)"
00:58:53 <ski> s/but just a double in b/but just a double in T/ ?
00:59:04 <ski> use some notion of scalar multiplication ?
00:59:18 <gfixler> yes, in t
00:59:59 <gfixler> I should say I made an instance of Num for (a, b) where a and b are Num
00:59:59 <ski> (also `lerp a b t = a * (1 - t) + b * t' is a slightly different way to formulate the same thing ..)
01:00:40 <ski> either use some library with a scalar multiplication operation. or maybe define your own
01:01:14 <gfixler> I can't do it with the types?
01:02:52 <ski> gfixler : i don't know what you mean by that
01:03:40 <gfixler> ski: I'm not sure I do either
01:03:59 <gfixler> yeah, I guess I'm not making sense
01:04:26 <gfixler> I was thinking that I could multiply them if they were both Num
01:04:30 <ski> <https://hackage.haskell.org/package/linear-1.20.4/docs/Linear-Vector.html> seems to have scalar multiplications `(*^)' and `(^*)'
01:04:36 <gfixler> but that's not what Num membership means
01:04:56 <ski> multiplication in `Num' is multiplication of two elements of the same type
01:05:05 <ski> which is now what you wanted here, so you can't use that
01:05:09 <ski> s/now/not/
01:05:13 <gfixler> yep
01:05:23 <gfixler> brain glitch
01:06:28 <ski> i'm not sure which library for linear algebra / vector (and matrix) stuff would be best (for the kinds of things you want to do), but perhaps you could try using the above library
01:06:47 <ski> .. or you could try to roll your own, only supporting what you know you need
01:07:06 <gfixler> ski: why * (1 - t) + b * t?
01:07:17 <gfixler> it seems to simply be reversing time and offsetting by the other point
01:07:35 <ski> i'd expect that the `linear' package distinguishes between vectors and points, which could be a point on favor of it
01:07:44 <ski>      (b - a) * t + a
01:07:53 <ski>   =  b * t - a * t + a
01:07:55 <gfixler> ski: yeah, I've been looking at linear lately
01:08:00 <gfixler> ski: just tweeted about it, in fact
01:08:00 <ski>   =  b * t + a - a * t
01:08:10 <ski>   =  b * t + a * 1 - a * t
01:08:16 <ski>   =  b * t + a * (1 - t)
01:08:22 <ski>   =  a * (1 - t) + b * t
01:08:28 <gfixler> ski: been rolling my own - thought I saw a generalization, but was wrong
01:08:41 <gfixler> ski: not hard stuff, but you just start needing to implement too many little helpers
01:10:01 <ski> also see <https://en.wikipedia.org/wiki/Barycentric_coordinates_(mathematics)> for some math on that
01:10:12 <gfixler>   = tb - ta + a
01:10:12 <ski> gfixler : ok
01:10:40 <ski> note that the sum of `1 - t' and `t' is `1'
01:11:01 <gfixler> conspiracy
01:11:02 <ski> so, you're doing a weighted sum of `a' and `b', with the sum of weights being `1'
01:11:30 <gfixler> yes, I suppose I am
01:11:36 <ski> as long as both weights are `between `0' and `1', the result will be a point (on the line through `a' and `b') between `a' and `b'
01:11:45 <gfixler> that's been a lot of my life, actually, painting weights in games
01:11:52 <ski> when one of the weights is negative, you'll get a point on the "outside"
01:11:55 <gfixler> lots of little weights adding up to 1
01:11:59 <gfixler> the weighting is the hardest part
01:12:34 <gfixler> ski: yep, very handy to be able to talk in terms of the vector between a and b intuitively
01:12:44 <ski> `(b - a) * t + a' is just expressing the same thing as an offset/vector from the point `a', chosen for some reason as a base point
01:13:13 <gfixler> e.g. lerp 3 7 0.5 = midpoint; lerp 3 7 (-1) = go from a away from b by the distance between them
01:13:32 <gfixler> ski: chosen as a base point, because it's lerp
01:13:38 <gfixler> a standard game function used for that purpose
01:13:57 <ski> that Barycentric WP article seems to talk mostly about having three points, and wanting to express any point (e.g. inside the triangle spanned by them) as a weighted sum
01:14:08 <ski> but your case is the same, only you have two points instead of three
01:14:35 <ski> gfixler : what does "lerp" stand for ?
01:14:43 <ski> something with "linear interpolation" ?
01:14:46 <gfixler> yep
01:14:55 * ski doesn't quite see the expansion, though
01:15:08 <gfixler> we say "lerp from 2 to 5 by 0.5" - linearly interpolate from 2 to 5, halfway
01:15:35 <gfixler> it's in most game engines: http://docs.unity3d.com/ScriptReference/Mathf.Lerp.html
01:15:43 <gfixler> http://docs.unity3d.com/ScriptReference/Vector3.Lerp.html
01:16:14 <gfixler> https://processing.org/reference/lerp_.html
01:16:26 <gfixler> https://msdn.microsoft.com/en-us/library/windows/desktop/bb509618%28v=vs.85%29.aspx
01:16:53 <gfixler> even ROBLOX - http://wiki.roblox.com/index.php?title=Lerp
01:18:04 <ski> ok
01:18:11 <Tangerine> how do I test the pointfree bot in here?
01:18:48 <Tangerine> trying to find a pointfree for snd(fst(a))
01:18:55 <ski> @pointless f g x y = g x < g y
01:18:55 <gfixler> @pl snd (fst a)
01:18:56 <lambdabot> f = flip =<< (((.) . (<)) .)
01:18:56 <lambdabot> snd (fst a)
01:19:05 <gfixler> wait, who won?
01:19:08 <gfixler> @pl snd (fst a)
01:19:09 <lambdabot> snd (fst a)
01:19:10 <ski> Tangerine : `(snd . fst) a' ?
01:19:14 <gfixler> @pointless snd (fst a)
01:19:14 <lambdabot> snd (fst a)
01:19:17 <gfixler> so either
01:19:26 <Tangerine> huh
01:19:30 <gfixler> now I know why it's pl
01:19:38 <ski> @help pointless
01:19:38 <lambdabot> pointless <expr>. Play with pointfree code.
01:19:45 <Tangerine> huh
01:19:58 <gfixler> :t (.)
01:19:59 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:20:06 <Tangerine> > (snd . fst ) ((1,2),(3,4))
01:20:08 <lambdabot>  2
01:20:30 <Tangerine> huh, i must have done something wrong while testing this in ghci
01:20:33 <gfixler> snd . fst = \x -> snd (fst x)
01:20:54 <gfixler> (g . f) x = g (f x)
01:21:20 <mfukar> I wonder why was the dot chosen
01:22:00 <gfixler> mfukar: easiest to type character that looks like the math symbol
01:22:15 <gfixler> g ∘ f
01:22:22 <gfixler> that's how it looks in category theory
01:22:38 <mfukar> Ah, of course
01:22:40 <gfixler> and that will also work IIRC in Haskell, with unicode turned on
01:23:30 <ski> gfixler : s/category theory/math in general/
01:23:42 <merijn> . is function composition in general math
01:23:59 <merijn> Additionally, contrary to popular believe there is basically no category theoretical background to haskell
01:24:06 <merijn> s/believe/belif
01:24:14 <merijn> I give up on spelling today..
01:24:21 <Tangerine> TIL that the :: symbol is called the Paamayim Nekudotayim
01:24:34 <ski> in PHP ?
01:24:56 <gfixler> that is what it is called, but that isn't what it's name is
01:25:07 <Tangerine> I mean in general
01:25:20 <Tangerine> like, the name of the physical shape of the symbol
01:25:22 <gfixler> that's just Hebrew for "double colon"
01:25:45 <Tangerine> thank you learnyouahaskell for that insightful comment
01:26:20 <gfixler> In Hebrew-speaking areas they're saying "TIL that the :: symbol is called the Double Colon"
01:26:39 <Tangerine> ahaha
01:27:01 <gfixler> this is always curious for me
01:27:08 * ski notes that that is probably the dual numerus form
01:27:48 <gfixler> like when someone says "The Chinese have a word for it; they call it [cool sounding word that's just the generic term for the thing]." 
01:27:59 <ski> (the "im" at the end, i.e.. like in "Yerushalayim" and "Misrayim")
01:28:18 <gfixler> what's it mean?
01:28:26 <ski> which ?
01:28:39 <gfixler> the "im"
01:29:39 <ski> it's the dual number form. just like there's singular (1) and plural (many), some languages have a special form for dual (two)
01:29:49 <gfixler> oh, interesting
01:29:55 <gfixler> natural languages are so complicated
01:30:06 <ski> e.g. in arabic "binteyn" is "pair of daughters"
01:30:09 * gfixler is struggling with gender/number in Spanish
01:30:55 <ski> ("Yerushalayim" is "the two jerusalems". while "Misrayim" is "the two egypts")
01:32:28 <ski> apparently the "ay" was also part of the dual form. i didn't remember that
01:32:54 <gfixler> So Mayim means two Ms?
01:33:15 <gfixler> I suppose it doesn't take effect everywhere
01:33:32 <ski> you'd have to ask someone who speaks ivrit
01:34:26 <sgronblo> Am I the only one who doesn't like vertically lining up your code?
01:34:44 <gfixler> sgronblo: I sometimes like it
01:34:56 <gfixler> sgronblo: sometimes it makes me feel like I'm behind prison bars
01:36:08 <sgronblo> I just find it creates a lot of extra work to maintain as well as garbage in source code commits
01:36:20 <sgronblo> For a small superficial gain
01:37:25 <merijn> sgronblo: I think it's much more readable
01:37:26 <gfixler> sgronblo: it creates garbage if you're fighting with someone else over formatting, I suppose
01:37:42 <gfixler> sgronblo: I just toy around in Haskell, though, and my commits are my own/flawless
01:37:57 <merijn> The extra time increases the time to write negligibly, whereas I will usually have to read it many times
01:38:06 <Tangerine> ^
01:38:11 <Tangerine> this so many times
01:38:19 <merijn> It also depends on the number of lines, the size of identifiers, etc.
01:38:29 <Tangerine> I think writing code is like 90% thinking/reading code and 10% typing
01:38:29 <gfixler> merijn: I use Vim, and just do something like g= to align all the = around me
01:38:56 <gfixler> nnoremap g= :Tabu /[^=]\zs=\ze[^=]<CR>
01:39:10 <Tangerine> does anyone have an example of an implementation of a constrained datatype I can look at?
01:39:26 <Tangerine> I'm not sure how to style this
01:39:28 <gfixler> Tangerine: constrained in the definition, or in the usage in a function?
01:39:30 <merijn> Number of times I've been annoyed by having to layout code: n. Number of times I've thanked past me for doing so: significantly larger than n :p
01:39:51 <Tangerine> constrained in it's construction I guess?
01:40:03 <Tangerine> i guess it's in function then
01:40:13 <merijn> Tangerine: Can't. Usual solution is to not export constructors and build a "smart" constructor
01:40:26 <merijn> Or not bother constraining constructors at all
01:40:28 <gfixler> GADTs?
01:40:31 * ski idly wonders whether Tangerine wants a "subset type"
01:41:38 <Cale_> Tangerine: what overall problem are you trying to solve?
01:42:09 <Tangerine> say you have data type "data Triple = T { left :: Integer, middle :: Integer, right :: Integer}"
01:42:28 <Tangerine> and say when constructing data Triple from a list, we want to ensure that
01:42:36 <Tangerine> left and right is greater than 0
01:42:44 <Tangerine> left < middle < right
01:43:02 <Tangerine> actually, let middle :: Set Integer
01:43:08 <merijn> Don't export the constructor and use "triple :: Integer -> Integer -> Integer -> Maybe Tripl"
01:43:13 <sgronblo> So can someone tell me what their procedure for adding a dependency to their .cabal file is? With npm I would just do npm install --save the_dependency
01:43:33 <Tangerine> and we want all elements of middle to be between left and right
01:43:33 <sgronblo> But I understand with cabal I have to figure out my version range manually and manually update .cabal?
01:43:49 <merijn> sgronblo: I usually just base constraint on the PVP
01:44:11 <Tangerine> what does Maybe do for us here? Can I not just error if something bad is passed in?
01:44:15 <merijn> Or don't add upper bounds, since I rarely update and it's easier to fix breakage by putting in upperbounds when things stop working
01:44:19 <Cale_> sgronblo: edit the file and add the dep?
01:44:29 <merijn> Tangerine: Depends, are you planning to crash the program on a failure?
01:44:36 <Cale_> oh version ranges
01:44:47 <Tangerine> yes
01:44:59 <sgronblo> merijn: what is PVP?
01:45:53 <ski> @where PVP
01:45:53 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
01:46:41 <sgronblo> merijn: so how do you base the constraint on the PVP?
01:47:03 <merijn> sgronblo: I pick whatever version I happen to have locally as lower bound and use PVP to select a compatible upper-bound
01:47:09 <merijn> Tangerine: That's awful :\
01:47:22 <merijn> Tangerine: With Maybe you get a chance to handle the error/print a message
01:47:47 <phadej> merijn: please put upperbounds if you upload package to the Hackage
01:48:17 <phadej> merijn: I'd say it even easier to relax upperbounds when you update
01:48:27 <Tangerine> merijin: this is for a coding exercise so I'm not trying to be super careful
01:48:45 <Tangerine> how would I do the check for whether everything in middle is between left and right?
01:48:47 <sgronblo> merijn so if Aeson is now at 0.11.20 you would pick aeson >= 0.11.20 && < 0.12 ?
01:49:06 <merijn> phadej: If my updates are less than once a year I'd spend more time fixing uppberound breakage then updating packages. Especially since you can fix upperbounds on hackage when a problem occurs
01:49:28 <gfixler> Tangerine: if left foo < middle foo < right foo then bar else baz
01:49:28 <merijn> sgronblo: For example
01:49:38 <phadej> 0.11.2.0 btw
01:49:38 <merijn> I'd use guards, but yes
01:49:47 <gfixler> Tangerine: if left foo < middle foo && middle foo < right foo then bar else baz
01:50:06 <Tangerine> what if middle is a set instead?
01:50:07 <Tangerine> or a list?
01:50:17 <gfixler> Tangerine: what does less mean in those cases?
01:50:20 <merijn> phadej: Especially since most of my stuff only depends on base/GHC boot libraries
01:50:38 <gfixler> Tangerine: is this where your constraint question comes from?
01:50:45 <Tangerine> yeah
01:50:56 <gfixler> Tangerine: so you want Ord constraining these
01:51:04 <phadej> merijn: hmm, as easily you can relax the bounds on hackage as well. With many package versions without bounds, on breakage you have to fix them
01:51:16 <phadej> all
01:51:30 <phadej> insted of relaxing bounds for the latest release
01:51:35 <gfixler> Tangerine: you'd use a smart constructor with an Ord constraint on the inputs
01:52:10 <merijn> He doesn't need and Ord constraint, since he's using only Integer
01:52:14 <gfixler> Tangerine: e.g. makeTriple :: Ord a => a -> a -> a -> Triple
01:52:23 <ski> @type \left middle right -> all (\middle -> left <= middle && middle <= right) (middle :: S.Set Integer)
01:52:24 <lambdabot> Integer -> S.Set Integer -> Integer -> Bool
01:52:27 <gfixler> merijn: "Tangerine | what if middle is a set instead?"
01:53:06 <gfixler> Tangerine: do you *want* to be able to use other types, or do you just want Int?
01:53:21 <gfixler> Tangerine: if you just want Ints, then your type is fine - you can't pass Triple anything else
01:53:22 <Tangerine> for here, just Int is fine
01:53:28 <Tangerine> i think expanding it to all things isn't that bad
01:54:00 <merijn> gfixler: If middle is a set of Integer you still don't need and Ord constraint :)
01:54:01 <gfixler> Tangerine: *all things that have Ord instances
01:54:12 <Tangerine> where should I doing this check? in patter matching?
01:54:36 <gfixler> merijn: how are Sets ordered?
01:54:47 <gfixler> Tangerine: I gave you the type
01:55:04 <gfixler> Tangerine: makeTriple :: Ord a => a -> a -> a -> Triple
01:55:19 <gfixler> smart constructor that takes 3 things of type a and uses those to construct a Triple
01:55:26 <ski> gfixler : there are different ways. Hoare. Smyth. Egli-Milner
01:55:32 <gfixler> ski: I figured
01:55:49 <gfixler> ski: where does the set of all sets go in the ordering?
01:55:54 <merijn> gfixler: The implied definition was: "left :: Integer, middle :: Set Integer, right :: Integer"
01:56:07 <merijn> gfixler: Unless I misunderstood Tangerine's question
01:56:07 <Tangerine> makeTriple vallist (left, right)= if cond1 && cond2 && cond3 then (T left vallist right) else error "something"?
01:56:28 <merijn> gfixler: Lexographical order of sequential representation of the Set?
01:56:39 <merijn> gfixler: ZFC doesn't allow recursive sets, afaik?
01:56:51 <gfixler> merijn: I think the question was just about 3 things, and making sure the middle one is between the other ones
01:57:13 <Tangerine> or rather in my case, it would be Set.fromList(vallist), and the conditions would just be the checks
01:57:17 <merijn> gfixler: He gave a specific datatype and asked "what if I change middle to a Set?"
01:57:31 <gfixler> merijn: ah, I think I missed the second point
01:57:45 <ski> gfixler : in the Hoare ordering, the full subset is the greatest element
01:58:08 <gfixler> ski: I see
01:58:15 <Tangerine> merijin, I think my trouble is I wasn't sure how to do the comparisons if it needs to be compared to a set. I think the answer I got from this is "you have to do the check beforehand"
01:58:31 <ski> gfixler : you get a greater subset, by adding an element, or by replacing an element with a greater one
01:58:33 <Tangerine> I guess I was thinking of a imperative standpoint, you would do something like
01:58:56 <ski> gfixler : in the Smyth ordering, you get a greater subset, by replacing an element with a greater one, or by *removing* an element
01:59:00 <Tangerine> for (i in x) { if something(i) then return ERROR else blah}
01:59:39 <Tangerine> and I guess it's just not a haskell to write a function that you map which escapes if something goes wrong
01:59:40 <gfixler> Tangerine: sounds ripe for Maybe to me
01:59:57 <ski> merijn : ZFC is all about recursive sets ?
02:00:10 * ski isn't really sure how ZFC is relevant here, though
02:00:14 <merijn> Maybe I'm talking about my ass
02:00:19 <gfixler> Tangerine: no, it's not very Haskellish, because we don't want programs to crash
02:00:22 <merijn> I tend to mix things up :)
02:00:38 <gfixler> Tangerine: so we'd [likely] return a Just successStory or Nothing
02:00:43 <jle`> Tangerine: you can have "short-circuiting" traversals though, that's pretty haskelly.  but you still would like to have a defined result
02:00:49 <ski> (ZFC doesn't allow *cyclic* sets, though. there can be no "infinitely descending/deep" sets in ZFC)
02:01:34 <ski> (well, the set as a whole can be "infinitely deep", it's just that any paths in it must be finite. but they can be of unbounded depth)
02:01:39 <jle`> > asum (map (\x -> if x `mod` 7 == 0 then Just x else Nothing) [1..100])
02:01:41 <lambdabot>  Just 7
02:02:55 <gfixler> :t asum
02:02:56 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
02:03:14 <jle`> > asum [Nothing, Nothing, Just "hello", Nothing, Just "world"]
02:03:16 <lambdabot>  Just "hello"
02:03:18 <jle`> it finds the first Just
02:03:36 * gfixler needs to finally look into Data.Foldable/Traversable
02:03:47 <jle`> asum is more an Alternative thing
02:03:54 <jle`> asum [x,y,z] = x <|> y <|> z
02:03:55 <gfixler> yeah, seems so
02:04:18 <jle`> so it's like "or-ing" every item in the list, sorta.
02:04:35 <jle`> but for something simple like this we can just use 'find'
02:04:44 <jle`> > find (\x -> x `mod` 7 == 0) [1..100]
02:04:46 <lambdabot>  Just 7
02:06:59 <ski> > ((getFirst .) . foldMap . (First .)) (\x -> if x `mod` 7 == 0 then Just x else Nothing) [1..100]
02:07:01 <lambdabot>  Just 7
02:07:59 <gfixler> jle`: "The sum of a collection of actions, generalizing concat."
02:08:10 <gfixler> jle`: how do we concat with asum?
02:08:40 <sgronblo> why does this import Data.Aeson.Types (ToJson) say -> Module ‘Data.Aeson.Types’ does not export ‘ToJson’ ?
02:08:47 <ski> > asum ["fu","bar"]
02:08:50 <lambdabot>  "fubar"
02:08:56 <gfixler> ah, too complicated
02:09:11 <sgronblo> Isnt it right here https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson-Types.html#t:ToJSON ?
02:09:12 <Akii> sgronblo: it's ToJSON
02:09:20 <Akii> not ToJson
02:09:25 <sgronblo> Akii: oh whoops X_X
02:10:07 <jle`> gfixler: concat [x,y,z] = x ++ y ++ z
02:10:14 <jle`> gfixler: asum [x,y,z] = x <|> y <|> z
02:10:16 <gfixler> jle`: I guess I haven't understood <|>
02:10:24 <jle`> <|> for lists is ++ :)
02:10:26 <gfixler> I thought it was a kind of or at the applicative level
02:10:29 <jle`> > [1,2,3] <|> [4,5,6]
02:10:32 <lambdabot>  [1,2,3,4,5,6]
02:10:59 <ski> gfixler : it is
02:11:01 <jle`> it sort of works as an 'or' w.r.t. the Applicative instance
02:11:17 <jle`> > [(+3), (*2)] <*> [2,3]
02:11:18 <lambdabot>  [5,6,4,6]
02:11:33 <jle`> > ([(+3), (*2)] <|> [sqrt, negate]) <*> [2,3]
02:11:35 <lambdabot>  [5.0,6.0,4.0,6.0,1.4142135623730951,1.7320508075688772,-2.0,-3.0]
02:11:38 <jle`> do +3 and *2, OR sqrt/negate them
02:11:46 <jle`> and return the results of each
02:12:07 <jle`> sqrt unfortunately turned everything floaty
02:12:14 <gfixler> it does that
02:12:15 <jle`> > ([(+3), (*2)] <|> [negate]) <*> [2,3]
02:12:17 <lambdabot>  [5,6,4,6,-2,-3]
02:12:39 <jle`> > [(+3), (*2)] <*> ([2,3] <|> [4,5])
02:12:41 <lambdabot>  [5,6,7,8,4,6,8,10]
02:12:44 <jle`> do it to 2 or 3 or 4 or 5
02:13:02 <gfixler> hmm
02:13:10 <jle`> i guess whether or not you think of it as an 'and' or 'or' depends on how you interpret list applicative semantics
02:13:17 <jle`> and how it talks about non-determinism
02:13:37 <jle`> the result of <*> is basically every possible combination...so using <|> gives you more possibilities to go down
02:13:52 <gfixler> well, I tend to think of lists at the applicative level as values in superposition
02:14:00 <jle`> you can go down this path...or that path.  the result is all possibilities
02:14:23 <gfixler> yeah, ORing is like ANDing in that way
02:14:32 <ski> yes, so `<|>' is like or/addition, and `<*>' is like some kind of and/multiplication
02:14:32 <gfixler> I suppose I'm mixing metaphors
02:15:46 <jle`> x <*> y = this and that.  x <|> y = this or that.  (x <|> y) <*> z = (x or y) and z.
02:16:06 <jle`> > [(2,), (3,)] <*> ['h','i']
02:16:07 <lambdabot>  [(2,'h'),(2,'i'),(3,'h'),(3,'i')]
02:16:31 <jle`> > [(2,), (3,)] <*> (['h','i'] <|> ['a','b'])
02:16:33 <lambdabot>  [(2,'h'),(2,'i'),(2,'a'),(2,'b'),(3,'h'),(3,'i'),(3,'a'),(3,'b')]
02:16:36 <gfixler> now I kind of wish <|> was <+>
02:16:45 <jle`> although at this point i'm probably not helping anymore
02:16:54 <gfixler> or that <*> was <&>
02:16:55 <merijn> gfixler: | follows BNF syntax, though
02:16:56 <jle`> if it helps, you can look at the number of elements in the result.
02:16:57 <ski> possibly `<|>' was chosen because grammars
02:17:05 <gfixler> I see
02:17:10 <gfixler> lots of parser usage
02:17:18 <gfixler> that's where I've dabbled with it, anyway
02:17:37 <merijn> Yes, <|> existed in Parsec before Alternative existed
02:17:45 <jle`> MaybeT has a nice Alternative instance too
02:17:59 <ski> so .. how do we define a sensible exponential on idiomatic stuff ?
02:18:07 <gfixler> do people tend to pick a library and dive in, learning it all
02:18:14 <gfixler> or just absorb things over time randomly?
02:18:19 <jle`> for `MaybeT IO a`, x <|> y <|> z <|> ... would execute actions until it sees a success
02:18:20 <merijn> gfixler: Mix of both
02:18:33 <merijn> Depends on the library and the goal :)
02:18:34 <jle`> usually it's more practical for me to start with applications
02:18:36 <gfixler> merijn: been thinking I should whip up a list of the libs I see often and just study each
02:18:41 <jle`> and learn libraries as much as they are useful for the application
02:18:47 <jle`> learning libraries in isolation rarely helps me
02:18:55 <gfixler> jle`: good point
02:18:59 <jle`> if anything it seems slightly silly after a certain point
02:19:00 <gfixler> jle`: good to know what exists, though
02:19:08 <gfixler> jle`: I can be that :)
02:19:32 <Aruro> gfixler: dive is certainly needed for base, Cotnrol.* and few Data.*s
02:19:36 <gfixler> I learned the most this past year putting together the 3-hour talk I recently gave
02:19:38 <jle`> i just work on projects, and if i hear about/hear someone recommend a library that might be helpful, i try to figure out enough of it to use it for my project :)
02:19:50 <gfixler> and then watching it later and studying audience suggestions
02:19:52 <jle`> i don't think i'd ever learn anything if i just studied libraries alone
02:20:03 <gfixler> Aruro: yeah, that's mostly what I was thinking
02:20:14 <gfixler> Aruro: and then a few specialty ones I'm curious about, like Aeson and JuicyPixels
02:20:26 <gfixler> and then... all of kmett's GL lib
02:20:32 <Aruro> gfixler: yep
02:20:49 <gfixler> and then the next 8 years on lens
02:21:15 <gfixler> jle`: I'm taking your sage advice to heart
02:21:31 <jle`> yeah, the only way i ever learned lens was just by using it for applications
02:21:42 <gfixler> jle`: *using* lens seems super simple
02:22:01 <gfixler> jle`: grokking how it does it's thing seems super difficult
02:22:33 <gfixler> I've watched SPJ's talk on it 2 or 3 times, attended a meetup on how it works, and have poked through a few other sources, and another tech talk on the internals
02:22:36 <gfixler> still iffy on it :)
02:22:47 <jle`> yeah, but what's your goal in learning how lens is implemented?
02:22:58 <jle`> just for fun?
02:23:02 <merijn> Did you see edwardk's talk on lens?
02:23:04 <gfixler> jle`: yep
02:23:18 <gfixler> jle`: I love learning, full stop
02:23:38 <jle`> ah, ok :)  was coming at this from a different perspective
02:23:43 <amnn> gfixler, which bit are you iffy on?
02:24:00 <gfixler> amnn: it's been half a year since I was looking into it - can't recall now :)
02:24:13 <gfixler> amnn: all of that learning was just on the core idea of lens
02:24:27 <gfixler> amnn: I think it was Tran's original finding
02:24:28 <jle`> there actually isn't that much of lens the library that is super complicated, I don't think, besides hairy implementation details.
02:24:35 <gfixler> something about how a getter could be a setter, or vice versa
02:24:44 <jle`> i think you can pretty much write your own lens framework yourself
02:24:51 <gfixler> the thing everything else fell out of
02:24:53 <gfixler> the insight bit
02:24:53 <jle`> i mean, writing lenses from scratch isn't too complicated
02:25:02 <gfixler> jle`: I've done it
02:25:04 <jle`> then you need to write 'over', 'set', etc.
02:25:07 <gfixler> jle`: haven't kept up the knowledge
02:25:09 <jle`> so you can use your own lenses
02:25:11 <amnn> gfixler, ah right, lenses are "getter, setter pairs"
02:25:22 <amnn> and the bit you were stuck on was the representation lenses use for them
02:25:25 <gfixler> jle`: but then, you also had me write MaybeIO
02:25:30 <jle`> and then writing your own prisms from scratch takes a bit more getting used to
02:25:38 <gfixler> jle`: and I used hole-driven haskell, and made what people said was a fairly standard implementation
02:25:43 <gfixler> but I still didn't grok what I'd done
02:25:59 <gfixler> I don't think I'm far away, though
02:26:10 <jle`> :)
02:26:11 <gfixler> jle`: still not sure what prisms are
02:26:21 <gfixler> jle`: following the types gets you very far
02:26:30 <gfixler> jle`: and sometimes you look up and have no idea where you are, or how you got there :)
02:26:39 <jle`> yeah, i'm actually not a super big fan of hole-driven development for myself these days
02:26:46 <Aruro> is Text efficient at storing large lists?
02:26:47 <maerwald> is there a good test framework to test file operations?
02:26:47 <merijn> jle`: Heresy!
02:26:55 <jle`> well, it's different when you have dependent types
02:26:56 <merijn> Aruro: Type error :)
02:27:02 <jle`> i like it for that
02:27:07 <Aruro> merijn: :)
02:27:09 <gfixler> jle`: Idris?
02:27:11 <merijn> Aruro: Text is for unicode text, which is unrelated to lists
02:27:26 <jle`> but for non-dependent types, hole driven development usually leaves me more confused than anything heh
02:27:31 <Aruro> merijn: whats best strategy to store huge list of strings?
02:27:33 <gfixler> :)
02:27:40 <jle`> but that's just me
02:27:46 <merijn> Aruro: Ditch it and store a huge list of Text
02:28:22 <jle`> gfixler: lenses = 1 item contained, traversals = 0 or more items contained, prisms = 0 or 1
02:28:31 <Aruro> merijn: should this be ok with 100k elements?
02:28:36 <merijn> Aruro: String can take as much as 24 bytes per character (depending on your architecture), Text should average 2 byte per character with a max of 4 bytes per char (plus a few bytes overhead per every few kilobytes)
02:28:45 <gfixler> jle`: that's a riddle to me
02:28:51 <jle`> heh
02:28:53 <merijn> Aruro: So if you have lots of text elements Text is orders of magnitude smaller
02:28:54 <gfixler> jle`: I don't yet know traversals
02:28:58 <Aruro> merijn: ty, looks good improvement
02:29:03 <gfixler> jle`: I presumed it was something re: the visitor pattern
02:29:05 <jle`> for a lens, you sort of "focus" on exactly one item inside the structure
02:29:13 <Aruro> merijn: ty, will try it
02:29:15 <gfixler> jle`: that I grok
02:29:21 <jle`> like _1, focuses on the single item that is the first in the field
02:29:31 <jle`> for Traversals, you focus in on 0 or more
02:29:37 <merijn> Aruro: You should really only use String for simple/small things because of ease. Text is superior for all non-trivial uses of unicode text :)
02:29:57 <jle`> like the 'traverse' traversal for lists, traverse :: Travese [a] [b] a b
02:30:10 <jle`> there can be 0, 1, or 2, or any number of items you deal with
02:30:19 <gfixler> ok
02:30:28 <jle`> with prisms, there's either 0 or 1.  like _Just, it's either a single item there, or none there
02:30:37 <Aruro> merijn: :) ok then Text it is
02:30:41 <gfixler> merijn: why isn't Text the default?
02:30:47 <merijn> gfixler: Historical accident
02:30:54 <gfixler> merijn: again!?
02:31:09 <jle`> why does history keep on making accidents.  doesn't it learn?
02:31:10 <gfixler> this is Python 2.x Unicode debacle all over again
02:31:16 <gfixler> history so clumsy
02:31:30 <merijn> gfixler: Except that our historical mistake is easier for simple oeprations and correct unicode
02:31:38 <jle`> if only we could submit PR's and bug fixes for history
02:31:44 <gfixler> jle`: 0 or 1 and 0 or more show up a lot in coding
02:31:46 <merijn> Pattern matching on String is trivial compared to Text
02:31:49 <amnn> gfixler, I'm about the same age as Haskell... I've probably made more stupid mistakes in my life than Haskell has...
02:31:59 <gfixler> parsing combinators, regex operators, etc
02:32:08 <merijn> Also, the people doing haskell where making things up as they went :p
02:32:32 <gfixler> jle`: I did put out a call to arms on twitter about that last night
02:32:40 <gfixler> jle`: let's disrupt causality
02:32:43 <merijn> It's not like it was designed from the ground up as "real world" language, so ease of implementation influenced lots of early decisions too
02:32:54 <gfixler> jle`: mostly I just wanted to be able to type into people's shells in the tech talks I watch
02:33:17 <jle`> causality was a mistake marketed as a 'feature'
02:33:21 <gfixler> merijn: everyone's making things up as they go (I'm doing it now)
02:33:28 <maerwald> well, it may have been an accident, but it's understandable why they went with lists, because lists are sort of "natural" in haskell
02:33:35 <gfixler> causality made us invent monads
02:34:03 <jle`> but yeah, it might help to think of things you can do with lenses that you can't do with traversals or prisms
02:34:09 <merijn> I think a haskell inspired systems languages would be nice. You could lift a lot of code wholesale from GHC :p
02:34:20 <merijn> gfixler: You'd probably want built-in support for lenses too
02:34:27 <merijn> And proper concurrency...
02:34:41 <merijn> (i.e. firstclass concurrency), not this hacky nonsense we have in haskell
02:34:43 <gfixler> proper concurrency should be an X-Prize
02:34:54 <jle`> obv you can do 'over'.  and 'set' makes sense if you think of setting as setting every value inside the thing to be the same thing
02:34:59 <merijn> gfixler: Find me funding and I'll write systems haskell with builtin concurrency for you :p
02:35:01 <jle`> 'view' is the one you'll have problems with
02:35:07 <gfixler> merijn: I'm on it
02:35:08 <merijn> That's what I initially wanted to do my phd in :p
02:35:16 <merijn> But couldn't find any money >.>
02:35:24 <gfixler> jle`: yes, these were the things in the talks
02:35:36 <jle`> neat :)
02:35:47 <gfixler> jle`: have you seen SPJ's talk on lens?
02:35:54 <jle`> i have not :O
02:35:57 <gfixler> it's long
02:36:00 <maerwald> merijn: pretty common, no one wants to fund or pay for haskell stuff :P
02:36:12 <merijn> maerwald: Oh, haskell stuff is pretty good
02:36:17 <jle`> i'll be sure to check it out :3
02:36:19 <merijn> But funding for systems stuff is dead
02:52:47 <maerwald> is there a cabal value for the project directory?
02:59:44 <jophish> jle`: I can also recommend the SPJ talk as an intro to lens
03:00:15 <jophish> merijn: isn't that partly what idris was hoping to achieve?
03:04:13 <Tangerine> I'm still confused about Maybe...
03:04:32 <Tangerine> I'm using Map.lookup to get a value out of a map, but it returns a maybe
03:04:48 <Tangerine> how do I get it out? with Maybes.fromJust?
03:04:50 <cocreature> Tangerine: that’s because there might not be a value for the key you are providing
03:05:03 <Tangerine> but when I try to imort Maybes, it says I can't import the package
03:05:31 <maerwald> Tangerine: fromJust is for use cases where you _know_ that for every case there will be no Nothing. For everything else it's unsafe
03:05:48 <Tangerine> I check for M.member first
03:05:54 <Tangerine> and handle that exception if that is false
03:06:03 <maerwald> yes, then fromJust is safe probably
03:06:16 <maerwald> but it can bite you during refactoring still
03:06:21 <Tangerine> do I need to import it somewhere?
03:06:22 <cocreature> you should probably use lookup and pattern match on the result to handle the error
03:06:33 <cocreature> and then don’t check for M.member
03:07:38 <Tangerine> all I'm doing is writing a function that gets an element from a map (Integer, Integer) implementation
03:07:48 <Tangerine> of a sparse matrix
03:08:26 <Tangerine> how would I pattern match the result here?
03:08:58 <cocreature> I’d need to see some code to be more specific
03:10:01 <tpsinnem> is there a nice way to get a string of up to x characters from a GHC.IO.Handle, with a timeout of up to y milliseconds?
03:11:46 <tpsinnem> you can do hWaitForInput and read characters individually but i'm hoping some library already implements this nicely
03:12:06 <arianvp> hmm
03:13:40 <arianvp> this? https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Timeout.html
03:14:24 <arianvp> you could do something like
03:15:02 <Tangerine> getSM (SM {... values = v1} ind@(r,c) = if foo then M.lookup ind v1 
03:15:20 <Tangerine> else error "stuff"
03:17:19 <arianvp> tpsinnem: you could spawn two threads
03:17:23 <arianvp> and call timeout on one of them
03:17:35 <arianvp> one thread waits for data to come in and writes to a Control.Concurrent.Chan
03:17:45 <arianvp> once the thread is timed out. You read out the chan
03:18:02 <arianvp> Does that make sense?
03:18:23 * hackagebot werewolf 1.0.2.2 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.0.2.2 (hjwylde)
03:20:56 <tpsinnem> arianvp: actually i think i can use your suggestion of System.Timeout together with hGetContents and normal string operations in IO
03:21:06 <tpsinnem> thanks
03:22:19 <arianvp> do watch out that System.Timeout has a few quirks with FFI calls
03:22:28 <arianvp> if the underlying IO call is blockin, System.Timeout won't interrupt it
03:23:32 <fr33domlover> Q: I'm trying to make a RESTful app with Yesod and I have a form whose method is PUT. When I run the app, in the logs I see the web browser sends a GET instead
03:23:44 <fr33domlover> Is there a way to tell the browser to send an actual PUT?
03:24:06 <arianvp> but that shouldn't be a problem, as IO is non-blocking in haskell (translates to select/epoll)
03:24:07 <fr33domlover> I tried Midori and GNU IceCat, both send a GET...
03:24:17 <tpsinnem> arianvp: i'll keep that in mind. my guess is it won't be a problem but we'll see
03:27:25 <arianvp> fr33domlover  <form method='PUT'> 
03:27:25 <arianvp> ?
03:27:25 <arianvp> oh apparentlyu you cant :/
03:27:51 <arianvp> that's... odd
03:28:26 <arianvp> fr33domlover: you could use javascript as a 'solution'
03:28:59 <arianvp> or just make the endpoint also support a POST
03:29:22 <martinvlk> Hi, is it possible to pass a GHC flag to stack build such that it is only used for building my library, but not third party libs I use?
03:29:46 <martinvlk> Does it even make sense, specifically for the -fno-full-laziness flag
03:32:20 <lyxia> martinvlk: there is a field in .cabal files for options specific to your library
03:33:14 <fr33domlover> arianvp, you mean use JS as a problem :P I found some answers though: Indeed either use JS which I don't want, or use tunnel through a POST. I'll just make both POST and PUT work with a comment "the POST is a workaround because HTML is stupid"
03:40:08 <zomg> fr33domlover: a workaround used by some frameworks is to use post and include a hidden field which includes the "real" type of the request
03:43:00 <fr33domlover> zomg, yeah I'll need to do some kind of multiplexing over POST. I have both PUT and DELETE in my routes...
03:45:40 <ski> <ski> Tangerine
03:45:45 <ski>   <ski>   case M.lookup key theMap of
03:45:50 <ski> <ski>     Nothing  -> ..not found..
03:45:53 <ski>   <ski>     Just val -> ..found..
03:46:36 <martinvlk> lyxia: yes, but I need to be able to override that from the command line
03:47:22 <martinvlk> I am basically bulding with different flags than the ones used normally and listed in the cabal file
03:48:24 <ij> Here the first argument is [RetryStatus -> Handler m Bool]. Doesn't Handler type constructor accept just one type, not two?
03:48:26 <ij> https://hackage.haskell.org/package/retry-0.7.1/docs/Control-Retry.html#v:recovering
03:48:33 <newfag> hi
03:48:55 <newfag> Hello?
03:48:59 <newfag> Anyone?
03:49:29 <Memetics> Hi?
03:49:37 <Memetics> Hi
03:49:39 <Memetics> Hi.
03:49:40 * ski looks at Memetics
03:49:48 * Memetics looks at ski
03:49:54 * Memetics Memes memes
03:50:01 <ski> do you have a Haskell-related question or statement ?
03:50:07 <Memetics> Oh, Sorry. Nope.
03:50:10 <Memetics> ski
03:50:11 <Memetics> hi
03:50:11 <ski> ok
03:50:16 <ski> hello
03:50:16 * Memetics highlights ski
03:50:18 <Memetics> Hello
03:50:20 <Memetics> How are you?
03:50:42 <xeno__> hi, for IDEA, any reason to pick intellij-haskell over HaskForce?
03:50:47 <Friendly> Do you know any programming languages I havent heard of ?
03:51:10 <ski> i'm fine. for more social talk, #haskell-offtopic or #haskell-blah is commonly preferred
03:51:12 <Friendly> Just a friendly rmeinder by nyouhgh neighbor.
03:51:16 <Friendly> Oh
03:51:18 <Friendly> Sorry
03:51:35 <blume> I wish I had a bouncer.
03:51:41 <blume> No free bouncers here... Moving on
03:52:04 <ski> Guest41435 : how about Lolli,lambdaProlog,Lucid,Single-Assignment C,Cryptol ?
03:53:09 <blume_> ski: not bad
03:53:11 <blume_> Thanks
03:53:28 <Blume1> bluezone: 
03:53:30 <Blume1> Blume1: 
03:53:49 <Blume1> ski: How are
03:53:50 <Blume1> damn
03:53:52 <Blume1> channels
03:54:28 <BlumeUnited> I have sound issues atm
03:54:32 <BlumeUnited> But nvm, my system.
03:54:35 <ski> BlumeUnited : perhaps you've also not heard about Prolog,Erlang,Ada,Eiffel,Dylan,Logo,Mercury,Oz,Joy,Factor,Forth,Io,Smalltalk,SML,OCaml,Clean ?
03:54:55 <BlumeUnited> yeap
03:54:58 <BlumeUnited> like OCAML
03:55:14 <BlumeUnited> ski: you're awesome
03:55:34 <statusfailed> In haskell, you can create your own types, e.g. "data Maybe = Just a | Nothing". Is there a term for such user-defined types (as opposed to types which the compiler supplies, like Integer)?
03:55:35 * ski stares blankly
03:55:38 <BlumeUnited> How do I Haskell, ski 
03:55:48 <ski> statusfailed : algebraic data type
03:56:00 <BlumeUnited> statusfailed: status done
03:56:08 <statusfailed> eh
03:56:11 <BlumeUnited> eh
03:56:14 <BlumeUnited> sup canada
03:56:14 <ski> BlumeUnited : try getting a book, at at least look at a tutorial. read, think, practice
03:56:22 <BlumeUnited> bluezone: 
03:56:31 <BlumeUnited> ski: dont talk to me like im new tho this game thanks
03:56:50 <maerwald> -.-
03:57:00 <maerwald> I sense a disturbance in the force
03:57:01 <BlumeUnited> i like turtles
03:57:08 <statusfailed> ski: oh ok, so that's "any type that is created by combining others"?
03:57:08 <BlumeUnited> i sense children having fun
03:57:09 <Akii> >_>
03:57:11 <statusfailed> thanks
03:57:13 <quchen> statusfailed: There is no real distinction between compiler types and user types. Most of the common types are defined in libraries, for example Bool is not a built-in, but an ordinary ADT.
03:57:32 <Ferdirand> if you like turtles, writing a logo interpreter in haskell might be a fun project
03:57:38 <ski> BlumeUnited : is there a point to you repeatedly highlighting bluezone ?
03:57:44 <BlumeUnited> ski: 
03:57:45 <statusfailed> quchen: The reason I ask is because I'm reading TAPL, and I want to see how you could implement "user-defined types" in a compiler
03:57:46 <BlumeUnited> bluezone: 
03:57:48 <BlumeUnited> ski: 
03:57:48 <BlumeUnited> sk
03:57:49 <statusfailed> so I want to know what to google :-)
03:58:07 <BlumeUnited> statusfailed: duckduckgo
03:58:09 <statusfailed> It has typing rules for variant types, records, and so on, but I wanted to know if there is an umbrella term
03:58:15 <BlumeUnited> yea
03:58:20 <BlumeUnited> statusfailed: Hi.
03:58:23 <ski> statusfailed : algebraic data types are made in Haskell by using the `data' keyword
03:58:23 <merijn> statusfailed: There isn't a name for user defined types, there's a name for compiler builtin ones, though
03:58:33 <statusfailed> merijn: "primitive"?
03:58:37 <merijn> statusfailed: Yeah
03:58:50 <BlumeUnited> Oh well
03:58:51 <ski> statusfailed : "compiler types" aren't disctinguished from other (library) abstract data types
03:58:52 <BlumeUnited> So long
04:00:01 <statusfailed> ski: I'm more after the name for "the feature in a programming language that lets a user create new types" ... but I guess that's a bit too broad to be useful anyway
04:00:14 <statusfailed> I'll go with "Composite" types
04:00:18 <merijn> statusfailed: You can do that in almost any language
04:00:26 <merijn> statusfailed: i.e. consider defining new classes in Java
04:00:34 <justKiddingFolks> merijn: so true
04:00:38 <ski> statusfailed : "used-defined types", perhaps ?
04:00:58 <statusfailed> merijn: yeah, hence a bit too broad to be useful heh
04:01:18 <merijn> statusfailed: What are you looking to describe then?
04:01:45 <statusfailed> merijn: probably just "Algebraic data types" now you ask!
04:02:13 <statusfailed> could always go with "NotPrimitive" :p
04:02:16 <ski> statusfailed : also, if you write `(IO [String],String -> IO ())', is that an example of "lets a user create new types" or not ?
04:02:56 <ski> statusfailed : of course note that `newtype's aren't really algebraic data types
04:03:34 <quchen> They are not?
04:03:39 <statusfailed> ski: that's a good question.. TAPL introduces the "function type" as "an infinite family of types" so I suppose it's just another "type constructor"
04:03:51 <statusfailed> ski: I thought they were just an extremely-limited single-purpose ADT?
04:03:59 <andrewvic> Hey all, I've just set up a haskell environment using Stephen Diehl's vim config http://www.stephendiehl.com/posts/vim_2016.html
04:04:05 <blume_> who's OP around here
04:04:07 <blume_> :P
04:04:08 <blume_> jk
04:04:24 <toph> is there an library operation for Int that would map negative integers to '0' and leave positive integers as is?
04:04:39 * blumeAndMoar is rustling everyone's jimmies
04:04:46 <merijn> toph: No, but it'd be trivial to define
04:04:46 <andrewvic> But I'm getting an error when I open vim: ghcmod vimproc.vim is not installed. 
04:04:51 <quchen> toph: "max 0"
04:04:52 <ski> blumeAndMoar : could you please try to be more on-topic ?
04:04:56 <quchen> > max 0 123
04:04:58 <lambdabot>  123
04:04:59 <quchen> > max 0 (-123)
04:05:01 <lambdabot>  0
04:05:01 <merijn> quchen: oh, good
04:05:03 <blumeAndMoar> ski: Ok, will do. Thanks!
04:05:08 <toph> oh yeah, min, max :) i'm tired
04:05:19 <blumeAndMoar> toph: Go to sleep :)
04:05:26 <statusfailed> anyway, I think that helped clarify, thanks ski, merijn, quchen :-)
04:05:35 <blumeAndMoar> statusfailed: It did.
04:05:41 <merijn> toph: Sounds like you're looking for clamped arithmetic
04:06:04 <quchen> clamp lo hi = max lo . min hi
04:06:09 <blumeAndMoar> lambdabot: 
04:06:13 <blumeAndMoar> lambdabot help
04:06:15 <blumeAndMoar> lambdabot help me
04:06:21 <blumeAndMoar> lambdabot ask a question
04:06:23 <blumeAndMoar> Meh
04:06:29 <blumeAndMoar> lambdabot: Are you an NPC?
04:06:36 <srhb> blumeAndMoar: Yes, she is.
04:06:39 * blumeAndMoar gives flowers to lambdabot 
04:06:42 <blumeAndMoar> Oh.
04:06:44 <blumeAndMoar> It's a SHE.
04:06:45 <srhb> > "Thanks!"
04:06:47 <lambdabot>  "Thanks!"
04:06:51 <blumeAndMoar> ah ty
04:06:52 <quchen> ?botsnack
04:06:53 <lambdabot> :)
04:06:55 <blumeAndMoar> ?
04:07:05 <srhb> blumeAndMoar: You can also PM lambdabot to find out more.
04:07:13 <bloomyGloom> lol srhb 
04:07:15 <bloomyGloom> nope
04:07:19 <bloomyGloom> But Thanks.
04:07:22 <bloomyGloom> I'll go nt i
04:07:30 * JoshS shoot tranquilizer gun at bloomyGloom 
04:08:01 * bloomyGloom slaps joshc with a large trout
04:08:24 * hackagebot Cabal 1.24.0.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-1.24.0.0 (ryant)
04:08:41 <bloomyGloom> haha
04:08:55 <bloomyGloom> i'll sandbox that cabal hell into a dev's corner when i'm done with this.
04:09:06 <bloomyGloom> nice update hackagebot 
04:09:11 <bloomyGloom> hackagebot: Are you an NPC?
04:09:27 <bloomyGloom> hackagebot: This is not a game.
04:09:43 <JoshS> I have no idea what's going on
04:09:51 <bloomyGloom> JoshS: No one does.
04:09:54 <bloomyGloom> At first ;)
04:09:57 <JoshS> I'm just in this channel because I like languages.  I'm more of a lisp, prolog, smalltalk person.  I don't get haskell
04:10:25 <merijn> JoshS: What don't you get? :)
04:10:28 <JoshS> I used c++ for years, but I don't LIKE C++
04:10:39 <merijn> No one who uses C++ likes C++ :p
04:10:41 <JoshS> I don't get WHY
04:10:53 <merijn> JoshS: Why what?
04:10:55 <srhb> JoshS: Purity, sanity!
04:11:00 <JoshS> Haskell is a laundry list of features I don't want
04:11:04 <srhb> JoshS: It's nice to have more tools to reason about your programs.
04:11:13 <JoshS> I am too lazy for this lazy language
04:11:14 <JoshS> >.>
04:11:14 <mniip> merijn, well that's not neccessarily true
04:11:26 <mniip> I do like C++
04:11:26 <srhb> JoshS: Then you might indeed not want Haskell. :-P
04:11:29 <mniip> some bits of it
04:11:38 <merijn> mniip: I don't know anyone that uses C++ and likes it, including myself :p
04:11:44 <mniip> now you do
04:11:53 <merijn> JoshS: Which features are features you don't want, then?
04:11:53 <JoshS> Boost is an example of what's wrong with C++
04:12:02 <quchen> There are likers of every language.
04:12:06 <JoshS> it takes years of work to write a library for C++
04:12:13 <JoshS> years of the time of multiple experts
04:12:36 <JoshS> And it takes similar effort to understand how to use the ecosystem
04:12:42 * ski semi-recently saw some talk by Scott Meyers on C++14
04:13:19 <merijn> C++14 has quite some decent things, it's just covered by so much annoying cruft and ugly backwards compatibility hacks :\
04:13:28 <JoshS> which features don't I want?  I think the types
04:13:35 <srhb> JoshS: Why would you not want types?
04:13:45 <JoshS> I am curious what the purity and laziness would be like in a less typed language
04:13:55 <srhb> Not as amazing as you'd think :-P
04:14:02 <JoshS> ^
04:14:13 <JoshS> I don't like having to name things
04:14:15 <quchen> Purity and laziness are independent of type systems.
04:14:19 <merijn> Without the types purity and laziness are a hassle to work with
04:14:20 <JoshS> so I don't like being rid of mutation
04:14:42 <JoshS> I don't like having to name every loop
04:14:47 <merijn> JoshS: Pointfree form reduces the number of names you need. Additionally you can do mutation just fine
04:15:03 <merijn> JoshS: I don't remember the last time I wrote an explicit loop
04:15:29 <merijn> 90% just become folds
04:15:34 <JoshS> Why not types?  Because they're a SECOND problem you have to solve other than the algorithm
04:15:42 <merijn> (Actually 100% of all loops become folds if you want)
04:15:44 <JoshS> But yes, I love folds
04:15:46 <JoshS> >.>
04:15:51 <quchen> I wrote a couple of small programs in a pure, lazy, untyped language. It's not very pleasant. Just like in any other untyped language.
04:16:24 <JoshS> It's true that I'm finally getting experience writing long programs in an untyped langauge
04:16:26 <JoshS> and you get lost
04:16:30 <merijn> JoshS: Writing a program is trying to find a piece of source that confirms to the spec in the space of all possible source files
04:16:32 <JoshS> and start missing types...
04:16:45 <JoshS> But I think I'm learning to adapt
04:16:51 <merijn> JoshS: Types preemptively rule out large non-sensical parts of the search space
04:16:52 <akegalj> how can I create MonadReader instance of this type http://lpaste.net/6224407003549138944 ? I would like to create MonadReader on type s (the same way it is for MonadState)
04:17:07 <quchen> The problem with "types" is that most people tend to think of "types" as "types like in Java or C++".
04:17:25 <merijn> quchen: C++ has "auto" now :p
04:17:32 <JoshS> I remember feeling that I liked SML when I was learning it
04:17:45 <JoshS> I suppose I should feel the same way about Haskell
04:17:47 <quchen> Those have terrible, ad-hoc, user-unfriendly type systems.
04:17:55 <hpc> merijn: that's almost a non-zero amount of useful! ;)
04:17:55 <JoshS> but I keep wanting to turn it into lisp and prolog >.>
04:18:15 <JoshS> auto is cool
04:18:20 <maerwald> is it bad to link people to your hspec exception testing code as a substitute of documenting possible exceptions explicitly?
04:18:52 <srhb> JoshS: SML was destroyed for me when they reached IO
04:18:52 <JoshS> someone should have a contest where you write C++ programs where all typenames other than "auto" are illegal
04:18:57 <srhb> JoshS: Out went all the safety. :(
04:19:07 <merijn> hpc: auto is pretty sweet with lambda's
04:19:10 <JoshS> safety is overrated
04:19:13 <merijn> hpc: And template voodoo
04:19:23 <srhb> JoshS: I... okay. That's why you don't like Haskell :-P
04:19:42 <merijn> JoshS: Please never write software for cars and similar :(
04:19:46 <JoshS> ok
04:20:06 <JoshS> cars will be controlled by neural networks
04:20:11 <JoshS> that are trained not programmed
04:20:16 <JoshS> and are more like animals than programs
04:20:18 <merijn> That's even scarier
04:20:22 <JoshS> sleep well
04:20:46 <ent> it'll be like riding a horse
04:20:53 <ent> except faster
04:20:56 <quchen> Here's your new car. It's a really good driver but it hates birds so occasionally it'll chase one and you can't stop it. But don't worry, otherwise it's safe
04:21:05 <JoshS> ^
04:21:05 <hpc> remember, google's self-driving cars haven't yet had an at-fault accident
04:21:15 <hpc> ergo they are 100% safe and should not have steering wheels
04:21:30 <JoshS> They started with a neural net that learns to play video games
04:21:30 <hpc> because something something safety
04:21:36 <hpc> something something humans are the real monsters
04:21:37 <JoshS> from a british company
04:21:42 <JoshS> full of neuroscientists
04:21:52 <bloomyGloom> by love
04:21:54 <bloomyGloom> given 
04:21:59 <bloomyGloom> to you-hoohooo
04:22:02 <JoshS> That is the origin of the neural network in the google care
04:22:04 <JoshS> *car
04:22:09 <bloomyGloom> heh
04:22:13 <bloomyGloom> so much this JoshS 
04:22:15 <JoshS> they threw away their programming and started eith that
04:22:35 <JoshS> <3
04:22:39 <bloomyGloom> <3
04:22:43 <bloomyGloom> =d
04:22:45 <JoshS> this turns out to be a friendly channel than #lua
04:22:47 <JoshS> who knew
04:22:52 <bloomyGloom> yea
04:22:59 <JoshS> They need more personality types
04:23:01 <srhb> I was just about to say "but let's talk about Haskell -- or move to an offtopic channel" :-)
04:23:25 * hackagebot cabal-install 1.24.0.0 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-1.24.0.0 (ryant)
04:23:53 <JoshS> since I do like writing compilers maybe I should get into haskell
04:23:59 <JoshS> it's reputed to be good at that
04:24:06 <bloomyGloom> well JoshS 
04:24:09 <bloomyGloom> thats just rumours
04:24:26 <bloomyGloom> it's like anyone reinvented the wheel..
04:24:28 <JoshS> is Haskell written in Haskell?
04:24:31 <bloomyGloom> +NOT*
04:24:40 <bloomyGloom> is your JoshS written in joshs?
04:24:58 <bloomyGloom> Mr. Robot is a true story
04:25:02 <bloomyGloom> in wonderland, alice
04:25:07 <cocreature> JoshS: yep ghc is written in haskell (with the exception of the rts, which is C)
04:25:08 <bloomyGloom> [morpheus chiming in]
04:25:24 <clever> cocreature: i heard that the RTS also has some C-- code in it
04:25:32 <bloomyGloom> the real time strategy?
04:25:42 <clever> runtime system
04:25:53 <JoshS> a lot of compilers are self hosting or written in previous versions of themselves
04:25:53 <JoshS> curry is written in Haskell and compiles to Haskell
04:26:15 <JoshS> http://www-ps.informatik.uni-kiel.de/kics2/
04:26:23 <bloomyGloom> ML
04:26:35 * bloomyGloom hosts paranoia
04:27:20 <JoshS> <bloomyGloom> is your JoshS written in joshs?
04:27:23 <bloomy> is there a we br browsre written in haskell
04:27:24 <merijn> JoshS: The main reason the runtime system isn't rewritten in Haskell is "Why re-engineer something that works well and is battle-tested with something new if it works"
04:27:28 <JoshS> That's a kind of interesting question
04:27:43 <JoshS> not ever language is suitable for a runtime system
04:27:45 <bloomy> who is dr. who :P
04:27:59 <JoshS> I would expect the runtime to be assembly language and C
04:28:25 <bloomBoom> I'm the mockingbird currently
04:28:33 <JoshS> Unless Haskell has a C like sublanguage
04:28:49 * bloomBoom substitues joshs for a nice drink
04:28:49 <clever> JoshS: ghc does have an option to compile haskell to c
04:28:51 <JoshS> Pure strict low level sublanguage
04:28:51 <merijn> JoshS: It's mostly C and Cmm
04:28:55 <merijn> clever: Not really
04:29:01 <hpc> wouldn't a haskell RTS require an RTS anyway?
04:29:04 <clever> yeah, i hear its not maintained anymore
04:29:08 <merijn> hpc: No
04:29:10 <hpc> or it would need to be built differently
04:29:16 <bloomBoom> clever: maintain it
04:29:18 <JoshS> Bloom now I want a drink and I don't have anything like that in the house
04:29:21 <merijn> clever: It's only used for unregisterised builds (i.e. cross-compiling for new architectures)
04:29:45 <cocreature> I thought that was done via llvm these days?
04:30:03 <JoshS> llvm IS kind of C isn't it
04:30:20 <bloomBoom> ... Dare me, Haskell.
04:30:26 <JoshS> oh well I'm getting boring
04:30:27 <bloomBoom> Dear Hskell i love u :)
04:30:34 <JoshS> I suppose I should get to work
04:30:38 <bloomBoom> heh JoshS 
04:30:44 <bloomBoom> <3 where's teh luv
04:30:54 <merijn> cocreature: There' is an llvm backend, but it's not the default
04:30:54 <JoshS> I'm writing a macro system for Lua, and integrating it into an IDE
04:30:59 <merijn> cocreature: The default is GHC custom codegen
04:31:19 <cocreature> merijn: I know, but I thought the llvm backend is what is used for cross-compiling to new architectures
04:32:10 * bloomBoom dares truth
04:32:28 <JoshS> I know this is the wrong channel, but when it's documented enough I will want people to help me test it
04:32:30 <bloom_NOT> prisons..
04:32:41 <JoshS> and so far #lua doesn't seem interested >.>
04:32:45 <bloom_NOT> yea
04:32:52 <bloom_NOT> JoshS: #lua are whackos
04:32:55 <JoshS> or if you're bored you can play with it already
04:33:00 <bloom_NOT> Oh...
04:33:04 <bloom_NOT> JoshS: Hi.
04:33:07 <JoshS> it's sort of integrated
04:33:10 <JoshS> hi
04:33:11 <bloom_NOT> Aha
04:33:12 <bloom_NOT> Hi
04:33:13 <bloom_NOT> Welcome
04:33:14 <bloom_NOT> :)
04:33:18 <bloom_NOT> This is #hsakell
04:33:20 <JoshS> :D
04:33:21 <bloom_NOT> No wa8
04:33:22 <bloom_NOT> :D
04:33:22 <JoshS> also :3
04:33:25 <bloom_NOT> <34
04:33:28 <bloom_NOT> <1234567890
04:33:40 <bloom_NOT> ya rite
04:33:46 <bloom_NOT> new smileszszszszs for planet uaerth
04:33:53 <bloom_NOT> Everyone is like that at first.
04:33:55 <merijn> Could an op do something about the noise?
04:33:55 <JoshS> the readme is 20 days out of date >.> https://github.com/differentprogramming/lua-macro
04:33:56 <bloom_NOT> Bu then...
04:34:04 <JoshS> on a program that's 20 days old
04:34:08 <bloom_NOT> merijn: Hi Op, Noise?
04:34:13 <cocreature> @where ops
04:34:13 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
04:34:18 <cocreature> bloom_NOT is trolling
04:34:25 <bloom_NOT> cocreature: You're trolling
04:34:38 <bloom_NOT> @why
04:34:38 <lambdabot> Maybe you meant: wn what thx ghc
04:34:40 <JoshS> He or she does seem a bit excited
04:34:49 <bloom_NOT> yea well
04:34:51 <bloom_NOT> Medicine.
04:34:52 <bloom_NOT> .....
04:34:56 <JoshS> which medicine?
04:34:59 * bloom_NOT stops death from dying
04:35:03 <bloom_NOT> whose medi?
04:35:06 <bloom_NOT> im sick
04:35:06 <clever> JoshS: this may interest you, http://lcamtuf.coredump.cx/afl/
04:35:09 <bloom_NOT> im a sick brit
04:35:12 <bloom_NOT> minding your palace
04:35:27 <merijn> clever: American Fuzzy Lop is cool :)
04:35:37 <xa0> What's this about Britain?
04:35:38 <JoshS> Fuzzy lop
04:35:44 <JoshS> it;s named after a kind of bunny
04:35:49 <JoshS> I have to love that
04:36:13 <clever> merijn: ever since ive started haskell, i havent been doing any c/c++, so i'm not sure i can find a use for fuzzy lop, lol
04:36:50 <clever> oh, and while i'm here, how well does haskell play with valgrind?, i need to see if my FFI stuff is leaking
04:37:34 <merijn> clever: I don't see why it wouldn't work?
04:37:40 <merijn> clever: Never tried, though
04:37:44 <oherrala> clever: never tried, but maybe compile the FFI things with ASAN?
04:37:51 <jophish> clever: not exactly the same, but I've not had any problems using it for crashes in FFI code
04:38:04 <JoshS> code fuzzer
04:38:13 <clever> merijn: i could see the RTS doing funny memory stuff and making it falsely detect leaks
04:38:17 <merijn> jophish: You can load haskell programs into gdb just fine when debugging the RTS in my example
04:38:21 <merijn> *experience
04:38:25 <merijn> eh
04:38:30 <merijn> s/jophish/clever
04:38:33 <JoshS> I'd rather have humans who are interested if I can find any
04:38:45 <clever> merijn: for example, it likely cant make any meaningful backtraces
04:38:54 <merijn> clever: Not of haskell code, no
04:39:01 <merijn> But it could make backtraces of the C code
04:39:33 <clever> but when i allocate something with convPtr <- malloc, it wont say where i leaked it
04:40:19 <suppi_> does anyone have a simple example of sending a file over a network using conduit?
04:40:29 <thorium> hello all, I've got a question about persistent: I know it's not desired because I'd lose type safety but can I somehow fetch a result using raw SQL with a varying number of columns? basically I know my first col is a timestamp and then there are 1-n cols of Texts - depending on the query string only known at runtime
04:41:03 <JoshS> someone said I should never write code for a car:  https://www.youtube.com/watch?v=UC4vz6IbdtY
04:41:21 <JoshS> Imagine your car ran Windows
04:41:27 <clever> JoshS: This video contains content from Fremantle International, who has blocked it in your country on copyright grounds.
04:41:38 <JoshS> aww It's THE IT crowd
04:41:59 <JoshS> and the bomb squad's drone robot crashes because it's running Vista
04:42:04 <JoshS> "WE'RE ALL DOOMED!"
04:42:05 <clever> seems like its blocked in canada but not in america
04:42:31 <clever> ah, reboot it, again, lol
04:42:39 <JoshS> actuall that was we're all gonna die
04:42:44 <clever> just let the answering machine do that
04:42:54 <JoshS> right, "have you tried turning it off and turning it on again?"
04:43:10 <clever> oh crap
04:43:14 <clever> thats a bomb robot
04:44:56 <clever> lol
04:45:55 <JoshS> Well maybe someone should say that you should never write a car in a non-strict dialect of Haskell because memory management?
04:46:17 <merijn> JoshS: I wouldn't recommend haskell for hard real-time, no
04:46:18 <clever> JoshS: i recently had a crazy idea for a minute, running haskell on an AVR
04:46:27 <JoshS> what is an AVR
04:46:42 <clever> JoshS: a microcontroller, 20mhz cpu, 32kb of ram
04:46:54 <JoshS> Is there a compiler for strict only haskell?
04:47:23 <demize> Rather, it's a microcontroller architecture, there are a bunch of different AVRs.
04:47:30 <cocreature> strictness doesn’t help with hard realtime, the gc will still be a problem
04:47:32 <clever> correction, 2kb of ram
04:47:32 <r444> JoshS: maybe some proprietory ones
04:47:32 <JoshS> People keep saying this odd idea that there will be future versions where they throw out laziness
04:47:33 <merijn> There were people working a strict dialect called Habit, but I think that never materialised
04:47:42 <clever> 32kb of compiled code, and 2kb of ram
04:47:43 <cocreature> mu is strict afaik
04:47:49 <merijn> JoshS: Laziness is a better default than strict
04:47:50 <r444> clever: it won't work, haskell has a strict runtime
04:47:55 <cocreature> that’s standard chantered’s internal compiler
04:48:04 <merijn> The problems of laziness can be solved by a local strictness annotation
04:48:04 <clever> r444: i dont think even the runtime would fit onto an AVR
04:48:19 <r444> cocreature: it's not entirely strict afaik, chatted with some guys from SC earlier
04:48:20 <merijn> The problems of too strict cannot be solved locally and require rewriting the entire callchain
04:48:21 <demize> clever: That would be an.. ATmega?
04:48:28 <clever> demize: yeah, 328
04:48:33 <cocreature> r444: ah interesting
04:48:55 <r444> cocreature: it was described to me as "not as lazy as ghc"
04:48:58 <r444> :p
04:49:04 <JoshS> no GC lisp is a seductive idea that seems bad in practice
04:49:08 <JoshS> the copy-only lisp
04:49:09 <cocreature> r444: a very precise definition :)
04:49:21 <JoshS> I suppose copy-only Haskell would be just as bad
04:49:31 <merijn> cocreature: You'd have to ask augustss next time he's here :)
04:50:00 <cocreature> merijn: oh he is here sometimes? I don’t think I’ve ever seen him here
04:50:13 <merijn> I've seen him here a few times
04:50:15 <dredozubov_> interesting, haven't seen him there too
04:50:16 <merijn> Not as much recently
04:50:18 <demize> clever: Anyway, you certainly can do it, though I've only heard of people doing it on Arduinos.  Shouldn't be hard to get it working on other µCs though.
04:50:19 <dredozubov_> here*
04:51:10 <clever> demize: the closet example i can think of is when somebody ran CP/M on an AVR: http://spritesmods.com/?art=avrcpm
04:51:33 <clever> demize: he didnt use the avr ram directly, rather, the avr emulates only a cpu, using the ram for internal state&registers
04:51:37 <JoshS> I wonder if a copy-only tiny dialect of haskell could be worked out at all
04:51:45 <JoshS> it would no doubt be a different langauge
04:51:45 <clever> and then external sram as the 'guest' ram
04:52:00 <JoshS> but it might be suitable for microcontrollers and real time
04:52:20 <JoshS> i have no idea what I'm saying
04:52:35 <demize> clever: Mmm. Well, I've heard of a few people using Atom.
04:52:45 <clever> demize: in theory, a heavily modified haskell RTS could possibly use external sram&flash for code&variables, and then it could scale, but i dont know the RTS yet
04:52:56 <xa0> cocreature: only in august :p
04:53:44 <clever> demize: how much do you know about the RTS?, how much ram does it use for state, assuming you compiled a simple main = return () program?
04:53:55 <demize> clever: Sounds like it could be a fun and very frustrating project to implement.
04:53:59 <demize> No clue, alas.
04:55:03 <clever> demize: a quick spin with valgrind says it allocated 4108 bytes, and didnt free them at exit
04:55:09 <clever> ==19225==     in use at exit: 4,108 bytes in 2 blocks
04:55:11 <clever> ==19225==   total heap usage: 50 allocs, 48 frees, 64,120 bytes allocated
04:55:26 <clever> ah, nearly 65kb, that would exaust the entire address space of an AVR, lol
04:57:08 <hpc> here's an idea, compare it to main = undefined
04:57:16 <hpc> see if it's different
04:57:39 <demize> clever: Not exactly what you want, but still interesting: https://leepike.wordpress.com/2010/12/18/haskell-and-hardware-for-the-holidays/
04:57:41 <clever> ==19708==     in use at exit: 4,420 bytes in 8 blocks
04:57:44 <clever> ==19708==   total heap usage: 51 allocs, 43 frees, 64,192 bytes allocated
04:57:52 <clever> hpc: it used slightly more ram printing out the err msg
04:59:16 <clever> demize: neat
05:01:06 <JoshS> https://wiki.haskell.org/DDC
05:01:19 <JoshS> Disciple is a dialect of Haskell that uses strict evaluation as the default and supports destructive update of arbitrary data structures...
05:01:57 <JoshS> perhaps a candidate for microcontroller programming 
05:03:16 <JoshS> also google finds "Standard Chartered Bank has an internal Haskell dialect called Mu that actually is a strict version of Haskell, but I don't think it's publicly available."
05:03:28 * hackagebot envparse 0.3.3 - Parse environment variables  https://hackage.haskell.org/package/envparse-0.3.3 (MatveyAksenov)
05:08:29 * hackagebot concurrent-output 1.7.6 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.7.6 (JoeyHess)
05:08:31 * hackagebot tzdata 0.1.20160417.0 - Time zone database (as files and as a module)  https://hackage.haskell.org/package/tzdata-0.1.20160417.0 (MihalyBarasz)
05:18:38 * hackagebot idris 0.11.1 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.11.1 (EdwinBrady)
05:43:38 * hackagebot b9 0.5.19 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.19 (SvenHeyll)
05:58:39 * hackagebot hw-parser 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-parser-0.0.0.1 (haskellworks)
06:08:41 * hackagebot tz 0.1.1.0 - Efficient time zone handling  https://hackage.haskell.org/package/tz-0.1.1.0 (MihalyBarasz)
06:09:34 <deepfire> weird.. just was staring at a top session during a haskell-src-exts build..
06:09:48 <deepfire> almost nothing was happening -- ghc CPU usage at 3-4%
06:10:12 <deepfire> not IO bound, since SSD (and it wasn't being used)
06:10:31 <deepfire> not network-bound, because, why the hell would it be
06:11:32 <cocreature> deepfire: was it swapping?
06:11:48 <deepfire> cocreature, no
06:11:58 <deepfire> plenty RAM unused
06:12:09 <deepfire> managed to get a strace
06:13:41 * hackagebot fold-debounce 0.2.0.1 - Fold multiple events that happen in a given period of time.  https://hackage.haskell.org/package/fold-debounce-0.2.0.1 (debugito)
06:18:41 * hackagebot perfecthash 0.2.0 - A perfect hashing library for mapping bytestrings to values.  https://hackage.haskell.org/package/perfecthash-0.2.0 (MarkWotton)
06:28:17 <haskell529> hello people.. I'm just learning haskell and I'm trying use pattern matching .. i want the user to enter [1..10] and get the result [1,10,2,9,3,8,4,7,5,6,6,5,7,4,8,3,9,2,10,1] so i have taken in the list and reversed it but any advice on how I can then merge them in that way? thank you for any help!
06:29:55 <pavonia> You know how to recurse on a single list using pattern matching, right?
06:31:21 <haskell529> I have done a couple of simple things yes
06:32:21 <pavonia> So you just do the same with two lista as parameters, putting one element from both into the result list
06:34:00 <Ferdirand> alternatively, see if you can first build an intermediate result, like [[1,10],[2,9],[3,8],...]
06:38:42 * hackagebot hw-succinct 0.0.0.12 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.12 (haskellworks)
06:43:42 * hackagebot newtype-deriving 0.1.4 - Instance derivers for newtype wrappers  https://hackage.haskell.org/package/newtype-deriving-0.1.4 (NikitaVolkov)
06:44:38 <sm> good morning all
06:44:54 <Xnuk> w
06:45:20 <sm> if a thread receives an asynchronous exception while blocked on takeMVar, what happens ?
06:46:05 <sm> ie, does the exception take effect immediately ?
06:46:35 <eiaheouna> hello guys
06:46:55 <eiaheouna> why would winGHCI add ' to the start of my types and constructors when I run :t
06:46:59 <eiaheouna> is this known behaviour?
06:47:12 <k_bx> sm: depends if it’s masked or not, I’d say it’s easier to check :)
06:47:33 <sm> k_bx: check ?
06:48:06 <k_bx> sm: well, yeah, write a small program with a situation you described
06:48:23 <sm> oh
06:48:29 <joeyh> eiaheouna: ' in the start means eg, a DataKind. ghc often includes the ticks in output when it's not strictly necessary for disambiguation
06:48:48 * hackagebot autoexporter 0.2.2 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-0.2.2 (fozworth)
06:50:15 <sm> I guess that's a good idea, but with exceptions or threads, I fear doing anything adventurous 
06:51:02 <sm> that might work today and not tomorrow
06:53:02 <eiaheouna> joeyh: what purpose is it supposed to serve?
06:53:19 <eiaheouna> it's made me worried my data definitions are wrong
06:54:15 <joeyh> eiaheouna: True is a value of type Bool. 'True is a type of kind 'Bool. If you're not using DataKinds though, you shouldn't be seeing the ticks afaik.
06:55:37 <sm> k_bx: it seems the answer is yes. THanks
06:58:26 <k_bx> sm: yes it waits for mvar or yes it gets exception?
06:58:27 <geekosaur> datakinds on and confusing data and type constructors?
06:59:05 <sm> k_bx: the exception is raised, piercing the takeMVar
07:00:18 <k_bx> sm: ah ok, thanks
07:01:23 <bloom> #haskell
07:01:28 <bloom> This time, it's personal.
07:01:31 <bloom> :P
07:01:32 <bloom> jk
07:01:36 <joeyh> sm: when I start worrying about that kind of thing, I often reach for STM instead.
07:01:42 <bloom> lambdabot: how do you like haskell?
07:01:50 * bloom is interviewing robots
07:02:05 <Akii> > "I love haskell"
07:02:06 <lambdabot>  "I love haskell"
07:02:08 <bloom> >
07:02:12 <bloom> > print
07:02:14 <lambdabot>  <() -> IO ()>
07:02:15 <bloom> > print ""
07:02:17 <lambdabot>  <IO ()>
07:02:22 <bloom> > print "M"
07:02:24 <lambdabot>  <IO ()>
07:02:30 <bloom> print IO
07:02:33 <sm> joeyh: good to know. This is a tiny little thing, I'm trying not to overthink it - https://github.com/yesodweb/wai/pull/541/commits/716ac44caa9131526ec431e4b89420045f9cc84e#diff-e2c5ba59e4d690b8800ab5563a7f635bR196
07:02:39 <joeyh> IO IO it's off to work we go
07:02:44 <bloom> bb joeyh 
07:03:00 <bloom> joeyh: hope you like it here.
07:15:18 <darkmercenary> whats the difference between using template haskell vs generic for making json instances for aeson?
07:16:31 <Clint> darkmercenary: generic is easier and prettier, TH uses less memory and is more flexible
07:16:42 <Clint> also less portable i think
07:19:30 <merijn> I'm getting a lot of "failed to install" errors from cabal but all the logfiles are empty...
07:19:33 <darkmercenary> oh okay
07:20:07 <merijn> Any clues how to debug?
07:20:57 <sm> merijn: -j1 -v3 ?
07:21:42 <merijn> I tried -v3 but that wasn't very enlightening
07:21:48 <merijn> But maybe -j1 will help
07:25:45 <haskell370> hello again...i want to generate the result: [1,10,2,9,3,8,4,7,5,6,6,5,7,4,8,3,9,2,10,1] from the input [1..10] ... i know how to reverse the list but can you tell me how to mix them together in this way?  i tried this: mix listA listB = [x:y:[] | x <- listA, y <- listB] ....but it does not give the desired result﻿
07:27:16 <jrajav> haskell370: http://stackoverflow.com/questions/3938438/merging-two-lists-in-haskell
07:28:42 <opqdonut> > [y | x <- [1..10], y <- [x, 11-x]]
07:28:44 <lambdabot>  [1,10,2,9,3,8,4,7,5,6,6,5,7,4,8,3,9,2,10,1]
07:28:58 <opqdonut> that's a tricky way to do it :)
07:30:47 <paolino_> > [1..10] >>= \x -> [x,x-11]
07:30:49 <lambdabot>  [1,-10,2,-9,3,-8,4,-7,5,-6,6,-5,7,-4,8,-3,9,-2,10,-1]
07:31:00 <nitrix> > [y 
07:31:01 <lambdabot>  <hint>:1:4:
07:31:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:37:17 <Ferdirand> > concat . transpose . ([id, reverse] <*>) . (:[]) $ [1..10]
07:37:19 <lambdabot>  [1,10,2,9,3,8,4,7,5,6,6,5,7,4,8,3,9,2,10,1]
07:47:06 <bo080808080om> lambdabot: is this real life?
07:47:09 <bo080808080om> > RL?
07:47:11 <lambdabot>  <hint>:1:4:
07:47:11 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:47:18 <bo080808080om> lambdabot: IO?
07:47:22 <bo080808080om> lambdabot: define
07:47:24 <bo080808080om> > define
07:47:26 <lambdabot>  Not in scope: ‘define’
07:47:29 <bo080808080om> > scope
07:47:31 <lambdabot>  Not in scope: ‘scope’
07:47:37 <bo080808080om> > 'scope"
07:47:39 <lambdabot>  <hint>:1:8:
07:47:39 <lambdabot>      lexical error in string/character literal at end of input
07:47:42 <bo080808080om> > 'scope'
07:47:44 <lambdabot>      Syntax error on 'scope'
07:47:44 <lambdabot>      Perhaps you intended to use TemplateHaskell
07:47:44 <lambdabot>      In the Template Haskell quotation 'scope'
07:47:49 <bo080808080om> lol
07:47:50 <bo080808080om> nope
07:47:55 <bo080808080om> TH is for qise
07:48:03 <bo080808080om> > haskell?
07:48:05 <lambdabot>  <hint>:1:9:
07:48:05 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:48:09 <bo080808080om> > haskell?()
07:48:11 <lambdabot>  Not in scope: ‘haskell’Not in scope: ‘?’
07:48:15 <pavonia> You can use lambdabot in /query too
07:48:19 <bo080808080om> sry pavonia 
07:48:20 <Ferdirand> you may be interested to know that lambdabot answers private queries too
07:48:28 <bo080808080om> Ferdirand: ?
07:48:30 <bo080808080om> why
07:51:14 <maerwald> Ferdirand: because you are spamming the channel
07:51:23 <maerwald> bo080808080om: ^
07:53:46 <paolino_> > [1..10] >>= flip (:) . return  <$> (11 -) <*> id
07:53:48 <lambdabot>  [1,10,2,9,3,8,4,7,5,6,6,5,7,4,8,3,9,2,10,1]
07:53:50 * hackagebot d3d11binding 0.0.0.2 - A raw binding for the directX 11  https://hackage.haskell.org/package/d3d11binding-0.0.0.2 (jwvg0425)
08:01:15 <Aruro> what does system stands for in heap profile?
08:36:48 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
08:36:48 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
08:36:48 --- names: list (clog lstrano srenatus panosk slaytaner Argue phyrex1an Frankablu st0opkid Welkin thiagofm eacameron nycs Mikasa- groscoe jle` rodlogic lokien xenog warc anishathalye _davek plakband mimi_vx marc_ zero_byte goldfire Nilabhra cfricke nyuszika7h jutaro scepticulous boothead chrzyki mirsal AntiSpamMeta timrs2998 Caelum x1n4u mitchty binaryplease LnL skeet70 ross_ amnn eddsteel divVerent johnw amyers deepfire Ravana Guest26166 wei2912 dh lambdabot moplove cnr)
08:36:48 --- names: list (mac10688 danvet nitrix Sornaensis _janne zxtx stevenxl suppi justanot1eruser thoughtpolice saurik_ fall__ luigy_ sephiap saurabhn_ Quintasan_ jroesch_ madgen bencryption_ valdyn dredozub- nekomune_ phileas maaarcocr pfurla shwouchk_ Eliel_ kritzcreek Squarism Jaxan_ Sonarpulse omilu_ reem aaron7 pchiusano lan3y niteria_ PotatoGim Natch_w paf31_ harmchop ernestob brezel deavidsedice mmaruseacph2 dhil_ yaknyasn dkua tvv_ seanparsons drbean_ jamiis_ zyoung_)
08:36:48 --- names: list (cross_ swistak35_ dixie_ atriq x77686d quimrsto_ tokik_ max-m nak| howdoi hongminh1e thomie_ freekevi- psacrifi- tlevine_ ryanpcmcquen si14 drostie_ bitonic dpower dmiles_afk Azel copy` dhex carrob magneticduck mmachenry jathan alunduil JagaJaga lokien_ systemfault aupiff dsh pkug daniel-s chrisdotcode Luke oconnorct1 t7 sepp2k ixti stef204 Noldorin Reshi pbgc danhuynh______ Lokathor aarvar crobbins jrajav darkmercenary splanch plutoniix PennyNeko radge__ cdg)
08:36:48 --- names: list (sigmundv schjetne ype thunderrd k_bx codesoup kadoban rgrinberg umib0zu al-damiri machinedgod guampa noraesae roconnor andrewsw algae burdges fizbin hiptobecubic Gurkenglas__ mceier cpup BartAdv Warrigal eliasr etabot PaulN ggole GenericUsername FjordPrefect Christo__ hackebeilchen1 numee udm logcat nikolaMilj danthemyth elih sdothum BlackYoup dgpratt_ nkaretnikov mada latro`a_ benl23 pixelzerg madbub jsbruner bba akegalj a3Dman nh2 Nikotiini JoshS xelxebar)
08:36:48 --- names: list (zalatovo prkc v_g ozgura ij takle chlong djellemah_ hjljo shesek besenwesen mjo coup_de_shitlord shelf Cale rotty paolino_ ski adlan_ PlasmaStar ali_bush_ zoran119_ DM-300 hexagoxel iross_ jtcs_ mountaingoat obadz dinoangelov_ yorick_ bjobjo Soft RegEchse simukis_ KeelOfSteel rydgel hk238 LiamGoodacre perspectival Yuras afcondon erikd danza Lowl3v3l kvda T0BI herzmeister ncl Faucelme saulzar edwinvdgraaf bluepixel Tangerine rembo10 nomeata badon merijn)
08:36:48 --- names: list (jessicah Iskarlar M-ou-se pantsman- caumeslasal Guest94361 thc202 Arguggi Wizek Ariadeno_ CurryWurst firstdayonthejob xinming tristanp_ LucaTM dddddd Copperis razi1 dmwit_ Fubar^ slomo ThomasLocke grouzen shutdown_-h_now caconym eklavya silver ninedotnine dsantiago vili_ dsm MitchW isenmann forgottenone otto_s der-landgraf dustinm Meow-J nshepperd_ etcinit frelux mbrcknl YP-Cloud__ hansihe dwynwen_ddlleyw arnihermann fuziontech gridaphobe falafel_ jbalint)
08:36:48 --- names: list (lspitzner exferenceBot LordBrain Enigmagic Khisanth pavlicek cebreidian cow-orker electrostat enolan sevas darkf odi rkk Swizec_ chokboy cleamoon cogrendel SHODAN markus1199 predator217 nont__ Moto-chan dented42 sivs svp_ zos Wamanuz doshitan Jesin cyphase arianvp hosttor aib Vq awal bbee Didac bgamari julmac rntz Nik05 ollef jedws kevinyings gpampara m0rphism Fullma ibid zaquest eldon kmicu martingale Shou catsup MichaelBurge albel727 zudov fengshaun augur)
08:36:48 --- names: list (isocliff hackagebot dibblego sajith Tehnix Guest72742 Boney kosorith Skuzzzy acertain goodboy paulsamways mathu theorbtwo nakal koshmar Thulsadum tristero gienah rbocquet AustinMatherne Forty-Bot jokleinn yude godel geekosaur Johannes13 eyck Ewout miklcct LordDeath kier _ashbreeze_ nathanic Nivim chris2 kp666 Tourist M-Illandan1 Athas pmade cmars tnks_ bizarref2sh bd__ sword_smith_ sLite_ richi235 borkdude_ chattered spinda moei felixsch prophile adarqui)
08:36:48 --- names: list (solrize magicflakes stroutkernel heurist ps-auxw ninegrid baweaver loli-pyon nisstyre pharaun_ monochrom elementalest verement zv MrWoohoo Chunlea_ texasmynsted hamishmack amiller jknick worch wolfcore John[Lisbeth] SLi ent schnizzle jophish osfameron Qommand0r wedify Desoxy FMJaguar conal Excureo fr33domlover qnikst Maerten_ RaitoBezarius mdarse Xorlev aristid amingoia Freundlich Guest34040 tjpeden zpconn__________ obcode carter iphy yminsky carlw2 tarcwynne_)
08:36:48 --- names: list (ggherdov jmct Guest33283 Xe kalloc bluezone Chobbes robertk infinity0 RageD vic_ pikajude greymalkin d3lxa surtn- uwap_ jb55 kolko NingaLeaf fiddlerwoaroof tv Maxdamantus DigitalKiwi tpsinnem Bjarki Voldenet eL_Bart0 pydave6367 chishiki Amnez777 betawaffle chaptastic kolmodin_ selckin robogoat igniting potatoe nathyong swilsonau garphy sizur Excurio dogui Zekka hyPiRion CosmicRay alk joeyh emmanuel_erc josephle Hijiri aplund Akii jotrk hpd s4msung_ wtw mpw ion)
08:36:48 --- names: list (Black-Wolf pointfree DrCode magthe hiratara hxegon ortmage mlhmwglt kakos S_Walker samgd ericbmerritt mfukar orcus ski_ Liskni_si Nahra Simson-san ahihi Elision koz_ nemesit|znc condy chirpsalot ChongLi_ gbarboza Uakh cjwelborn Intensity case39 MindlessDrone Iceland_jack maerwald stiell litriv_ Adios Zemyla tdammers platz xanadu_ henriquev__ thetallguy mkurkov kfpratt OnkelTem @ChanServ mauke Draggor swilde tomjaguarpaw dalcde jcreekmore derpderp forze)
08:36:48 --- names: list (fangs124 wizonesolutions fabianvf shans_ runeks ryoia CARAM__ caw sclv magically alphonse23_ andreypopp__ katymoe amatecha parsnip jcp pkogan_ Ralith lancetw bigs bedouin OliPicard vikram_________ S11001001 zph_ chrismytton jlyndon rikkus_ mpickering jonrh dstockwell phuu ocharles_ TabAtkins mno2 solidsnack sisir__ Sonderblade atomi nxnfufunezn urdh quakestor bsmt nullFxn jix ramatevish whiteline vishesh geppettodivacin jfredett kurnevsky srcerer MoALTz grol)
08:36:48 --- names: list (SaidinWoT Schrostfutz Jaak jstolarek gniourf bizarrefish bananagram polux andjjj23 IndigoTiger BillyIII Nimatek_ andyo Madars_ Majiir jud lachenmayer brisbin alanz s_e mak` moop M-david M-davidar jre2 amiri mikecaruso drdo LonelyCloud Mandus lhynes myme impure_hate Mollrow saml DustyDingo tromp otulp marienz dcoutts marmalodak cjh` marens felher ]OLI[ c_wraith davesilva mattp_ aloiscochard bydo owlscientist Philonous [swift] hydraz jackhill rieper hvr)
08:36:48 --- names: list (lattenwald M-mistake radix M-Quora M-schmittlauch kini Jonno_FTW petercommand jtobin poga mingc absence Kwoth orion solirc n__dles rcsgns_ coeus LoganG avn Amadiro MarcelineVQ StoneToad EvanR kramin chu pfoetchen JRHaigh noam fakedrake kriztw bazzle WarzoneCommand troydm Purlox ireniko zopsi peddie fergusnoble rstone micmus micxjo nkpart nbouscal louispan superfatkappa qguv corne vigs Raynes simony mach mrshoe sm mrvdb epta iliastsi rofer averell indiffernet)
08:36:48 --- names: list (Jinxit opqdonut pfeyz klugez jimki ppnkk fingerzam1 XMunkki edwtjo pharaun metaf5 tumdum mendez ph88_ fractalcat CindyLinz dunj3 tippenein kolmodin ljhms statusbot crank1988 canta zrl_ caasih ajmccluskey edwardk trig-ger_ leather dario callumacrae cantstanya wyvern eyenx clion lpsmith hemite seagreen joco42_ Edoxile bshelden briansmith zuz_ Vivek Ezku_ lurker6_ KorriX karls wedens quicksilver ackthet davl themagician ricardo82 esssing hegge vodkaInf1rno)
08:36:48 --- names: list (Guest47170 staffehn RazorX- swhalen Bashmetim staticfox code_crimes_ pelegreno Internet13 luzie tsani jdt Reyu newsham arkeet dreamdust Ranhir jcurbo unsymbol relrod zerokarmaleft binocvlar wagle Ke cods raek linduxed knyppeldynan dino- huonw acro abrar theDon Deewiant Bane^ zerowidth gseitz levi dtulig tolt irclogger_com lispy Factionwars lyxia jgornick ido apo_ Clint gfixler wamaral dfranke hive-mind abra0 cbm80 mero leadingthenet PanicSkittle Jello_Raptor)
08:36:48 --- names: list (MasseR sjl_ s4kashya vin-ivar tomku Horv Chousuke simpson ec\ luis jlewis strixy nurupo aleogen liff tusj Guest78801 mj12`_ Lutin` ndeine abh Ulrar Belgarion0 sbrg Rodya brt1 Ferdirand nobag jrslepak cgfbee pdgwien djanatyn \u ReinH mindos_cloud____ mgaare monty brixen Profpatsch kav leftylink kloeri Reisen ClaudiusMaximus cfloare_ int-e fionnan_ Walther barrucadu z-nexx fmapE kungp gnusosa_ irishsul1an ephemeron RevJohnnyHealey bitemyapp cYmen__ rvncerr)
08:36:48 --- names: list (pranzor NemesisD georgew capisce_ mudfog_ spill1 avocado phadej acomminos watersoul horlicks TheVoid Oxyd Cetusx asjo TheMystic mw dicioccio keix mniip Adeon ironChicken Slush- maartenpi hausdorff jzl t0mb0_ solatis m1dnight_ Xandaros vqrs_ owa armlesshobo ggVGc Igloo da-x Pucilowski Cathy tomaw moredhel taksuyu sleezd Twey guios FledRebel bernalex ft dschoepe stux|RC-only octo- qnix_ seliopou tumdedum lf94 earthy pnutus jrp6 zomg niluje KaneTW kantokomi)
08:36:48 --- names: list (statusfailed robtaylor Ov3rload marmoute Xack d-snp Taylor joehillen mrd DDR asm89 FUZxxl spwhitt hpc adamCS Paks kaictl pleiosaur lokydor Tene myfreeweb Kahva quuxman sewilton obiwahn xaimus tero- davean inr OutlawStar martinbjeldbak dzackgarza GHCI bogdanteleaga hodapp flux _6a68 lassulus majoh Hafydd rtur zenzike ernst horatiohb catern vincenz malthe haasn andreass liyang joshc dan64 scopedTV mads- Ongy tek0 Kneiva nilOps connor_goodwolf Bez_ mudfog squimmy)
08:36:49 --- names: list (kipras GGMethos xa0 t00m0 Kavec Biohazard_ Tamini nesqi sbauman zeroskillor ThePhoeron_ capicue siddhu Arch-TK Saizan_ fboyer codebje_ hanDerPe1er alexlord RayNbow`TU LeaChim glckr_ hiredman zhulikas_ dqd brennie_ luite_ Keikran_ Lovepon supki benjamin1rom PierreM_ scshunt SphericalCow kshannon l3france marcel monkeyiqde marko__ shadowdao padre_angolano Baughn xou slick opios gabiruh nolrai cjay mvr_ bgyss_ jgertm kipd arrdem cbaines kyagrd clever keemyb)
08:36:49 --- names: list (WizJin MrRacoon Watcher7 julm vifon qz e mokus cursork nikola Ankhers toure_ Saimeidae hc sunfun noctux abbe alang nicola kyren __main__ Ornedan _flow_ Rembane alevy jinblack telser dilinger tortal sohum sea-gull codehero cstrahan funfun {AS} minad keteim milessabin nyandoge xnyhps bartavelle icedev anoe Tritlo sparr joedevivo avdi stass imalsogr` nopf Blkt mt ByronJohnson folsen xplat|work raid Boreeas benonsoftware gregf_ mnoonan sanitypassing tazjin)
08:36:49 --- names: list (magicman thebnq sqrt2 tgeeky danieli stelleg phaskell chelfi thorkilnaur_ M2tias joachifm Diabolik TimWolla sdboyer BigEndian Morgawr lucz oherrala dxld exio4 ploop byorgey gdsx sdx23 sternenseemann lyddonb alpounet julienXX Geekingfrog stomp saiam Willis sujeet dju jorendorff pyrtsa `0660 joeytwiddle tessier Gothmog_ spaceships alem0lars Cr8 vikraman oberstein pikhq u-ou Klumben SenpaiSilver skarn Forkk happy0 kjnilsson cynick xacktm MK_FG hbar tjbp)
08:36:49 --- names: list (SolarAquarion idupree Cerise spion Vbitz jedavis cschneid_ wolf_moz- carter-znc optocoup1er Bigcheese SegFaultAX mrlase pm52 yusukesuzuki niko spacebug zymurgy kishar andromeda-galaxy jaaket a6a3uh benzrf doubling kosmikus cmn angseus_ kaol cheater dkibi_ bengt_ Scorchin jstimpfl1 shachaf notdan trevorriles lexi-lambda beckyconning_ mankyKitty buoto chriswk yamadapc shennyg aleator arw fryguybob viaken aweinstock anachrome noplamodo_ lanodan sgronblo)
08:36:49 --- names: list (sphalerite pdxleif koomi defanor ybit koala_man __rlp ziman ario etrepum adamh luxbock_ Xnuk Kaini_ Dykam taruti takeey otterdam Moyst zimp ephess_ dalmahal negatratoron Plastefuchs emiliocobos elgot greeny__ ethercrow askarpo CIA Axman6 codedmart geal kwantam wrengr_away zmanian__ thomas eikke so Ring0` Speed wayne Shandy jlouis archaic eagleflo aparent Starfire yeltzooo wting Drezil honkfestival froztbyte ahf yarou isomorphismes low-profile fold4 sleepynate)
08:36:49 --- names: list (PHO lnx phz_ larsen kennyp gratimax Spaceghost Erebe JPohlmann liste DANtheBEASTman tzaeru bjs cin SuperTux88 nek0 BrianHV shteou brolin_empey dasmith91 demize lenstr o`connor srhb amontez ManiacTwister knittl bcoppens naudiz karshan xxpor bergmark lpaste noexcept reynir mrowe cosban gothos prooftechnique tg deni okek posco d6e dxtr Atlanis aatxe Tristan-Speccy tych0 japesinator liszt jkarni lieven ircbrowse Ashy comboy gargawel squisher friden dpn` Eiam)
08:36:49 --- names: list (przembot maskd Fylwind thallera1 Sigyn telmich giraffe ddima_ lukky513 numberten dysfun sellout ixian burp TommyC frontendloader SoupEvil bsermons stephe_ codebam banjiewen incomprehensibly Elsi shelling__ spicydonuts jameseb tekacs mephx loopspace jfokkan__ mikeizbicki wjm minsky cocreature Tiktalik integral acfoltzer drewdavis AlainODea rom1504 pootler_ agrif)
08:36:54 <geppettodivacin> Oh, that makes sense. paolino_, the input functor is (-> Int) and the output functor is (-> [Int]), right?
08:37:45 <paolino_> no
08:37:48 <geppettodivacin> Also, nitrix, why can't (->) be a functor? Other than it's the wrong kind without its type argument?
08:37:59 <scshunt> geppettodivacin: exactly that reason
08:38:16 <nitrix> geppettodivacin: Exactly that reason, but stretching it further... what would it read?
08:38:28 <scshunt> but (-> a) is not a functor. (a ->) is
08:39:02 <nitrix> scshunt: I don't think you can write infix instances.
08:39:02 <scshunt> (-> a) is a contravariant functor
08:39:19 <scshunt> nitrix: you cannot
08:39:22 <scshunt> but ignore that
08:39:26 <nitrix> ((->) r)
08:40:18 <geppettodivacin> Ah, right. So, modifying my figuring, we start with something of Int -> Int, and we end with something of Int -> [Int].
08:40:49 <geppettodivacin> So the functor the whole way through is ((->) Int) a, where a takes on Int for the input and [Int] for the output.
08:41:02 <paolino_> sure thats the argument of the bind
08:41:31 <paolino_> a -> m b
08:42:04 <paolino_> if you need parallel works on 'a'
08:42:32 <paolino_> flip (:).return collect the list
08:42:52 <geppettodivacin> Yep. I've used lists as monads, but couldn't figure out how a list was coming out of the right hand side.
08:43:41 <geppettodivacin> Using ((->) r) as a functor looks really strange when you actually try to type check because function application doesn't look like a type.
08:46:49 <nitrix> Quite the opposite, I find type constructors, even at the kind level, things mimick function application.
08:47:05 <paolino_> :t join (f <*> g))
08:47:06 <lambdabot> parse error on input ‘)’
08:47:12 <paolino_> :t join (f <*> g)
08:47:14 <lambdabot> (Monad m, FromExpr (m a1), FromExpr (m (a1 -> m a))) => m a
08:47:30 <paolino_> :t \f g -> join (f <*> g)
08:47:32 <lambdabot> Monad m => m (a1 -> m a) -> m a1 -> m a
08:47:33 <nitrix> Even constraints...
08:47:36 <nitrix> :k (,)
08:47:37 <lambdabot> * -> * -> *
08:48:01 <nitrix> :k Num
08:48:02 <lambdabot> * -> Constraint
08:48:03 <nitrix> :k Num Int
08:48:05 <lambdabot> Constraint
08:48:17 <paolino_> :t \f g -> join (f <$> g)
08:48:19 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
08:48:40 <paolino_> :t \f g -> join (f <$> g <*> h)
08:48:41 <lambdabot> (Monad m, FromExpr (m a1)) => (a2 -> a1 -> m a) -> m a2 -> m a
08:48:57 <paolino_> :t \f g h -> join (f <$> g <*> h)
08:48:58 <lambdabot> Monad m => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
08:49:09 <geppettodivacin> nitrix: You're right, they do. But when written as a type signature, the function application almost feels like it has a special meaning as opposed to representing just another type.
08:49:35 <geppettodivacin> But it's cool that everything in a type signature works the same way as regular function application.
08:49:49 <ski> @let infixl 4 <*>>; (<*>>) :: Monad m => m (a -> m b) -> m a -> m b; mamb <*>> ma = join (mamb <*> ma)
08:49:51 <lambdabot>  Defined.
08:50:40 <ski> @type \f g h -> f <$> g <*>> h
08:50:41 <lambdabot> Monad m => (a1 -> a -> m b) -> m a1 -> m a -> m b
08:50:49 <ski> @type \f g h i -> f <$> g <*> h <*>> i
08:50:50 <lambdabot> Monad m => (a2 -> a1 -> a -> m b) -> m a2 -> m a1 -> m a -> m b
08:50:59 <ski> paolino_ ^
08:51:02 <nitrix> ski: eheh, nifty.
08:51:38 <paolino_> hide the join(t)
08:57:17 <xa0> :t <*>>
08:57:18 <lambdabot> parse error on input ‘<*>>’
08:57:27 <xa0> :t (<*>>)
08:57:29 <lambdabot> Monad m => m (a -> m b) -> m a -> m b
08:57:58 <xa0> :t (<<*>)
08:57:59 <lambdabot>     Not in scope: ‘<<*>’
08:58:00 <lambdabot>     Perhaps you meant one of these:
08:58:00 <lambdabot>       ‘<*>’ (imported from Control.Applicative),
08:58:03 <xa0> Heh
08:58:05 <ski> nyet
08:58:16 <srhb> Obviously just needs flip.
08:58:24 <xa0> Lol
08:58:39 <ski> this is why `<*>' is a bad name
08:58:51 * hackagebot persistent-audit 0.1.0.0 - Parses a Persist Model file and produces Audit Models  https://hackage.haskell.org/package/persistent-audit-0.1.0.0 (mchaver)
08:58:57 <ski> (should have been `<$>')
08:59:01 <prophile> with a name like yours you may be biased on that front
08:59:42 <Aruro> i have list of directories and then i do mapM getfiles [dirs] , it is best solution? profiling kinda puzzles me
08:59:43 <ski> i'm not seeing a connection
08:59:52 <Welkin> SKI combinators
08:59:52 <xa0> <*>>=
08:59:58 <prophile> <*> is the S combinator isn't it?
09:00:11 <hpc> in the PAL release of ghc, (<$>) is localized to (<£>)
09:00:16 <xa0> Haha
09:00:19 <xa0> Nice
09:00:19 <Welkin> hpc: is that a joke?
09:00:22 <ski> i don't see what that has to do with the naming of infix operators here
09:00:56 <Welkin> has anyone used <)(> yet?
09:00:56 <hpc> ski: just since you mentioned the naming of <$> and <*> i had to get a joke in ;)
09:01:05 <prophile> I began typing it before your second message intending to go for a joke about naming it `s` isn't humour great when you explain it
09:01:08 * ski tends to read the symbol `$' aloud as "string"
09:01:14 <prophile> :o
09:01:41 <ski> (old habits die hard)
09:01:49 <hpc> ski: perl habits?
09:01:53 <ski> no
09:01:55 <Welkin> bruce willis?
09:01:55 <ski> BASIC
09:01:58 <hpc> ah
09:02:11 <hpc> i have a similar habit about the section character being simoleons
09:09:21 * hackagebot json-autotype 1.0.14 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-1.0.14 (MichalGajda)
09:11:36 <Aruro> any code examples/libraries which handles half million lists of elements up to 300 bytes each?
09:11:57 <Aruro> list with length about 0.5 M
09:19:21 * hackagebot persistent-audit 0.1.0.1 - Parses a Persist Model file and produces Audit Models  https://hackage.haskell.org/package/persistent-audit-0.1.0.1 (mchaver)
09:30:57 <jle`> > last [1..1000000] -- Aruro
09:30:59 <lambdabot>  1000000
09:31:42 <jle`> > foldl' (+) 0 [1..1000000]
09:31:43 <lambdabot>  500000500000
09:41:20 <darkmercenary> i have a list of things of different datatype. i want to map a function over it that changes it all to a different type but i cant do that because i cant even define the list.
09:41:39 <Xnuk> > foldl' (+) 0 [1..1000000000]
09:41:40 <darkmercenary> of course i can just copy-paste the function all across but can iavoid that
09:41:43 <lambdabot>  mueval-core: Time limit exceeded
09:42:53 <simpson> darkmercenary: It sounds like you don't actually have a list of differently-typed values. Could you pastebin your code?
09:43:27 <darkmercenary> sure
09:44:48 <darkmercenary> http://pastebin.com/SsWbP2kP
09:47:32 <simpson> darkmercenary: Ah. Yes, you can't have the thing that you want in that form. Sorry.
09:47:35 <ski> looks like your `a' and `b' are local
09:48:31 <darkmercenary> the a and b are some tuple of fields from the Vehicle
09:48:35 <ski> iow, you should in principle be able to have `[exists a b. Derivation a b]'
09:48:38 <darkmercenary> that depends on whatever im trying to compute at the time
09:48:57 <dfeuer> Death zipper.
09:49:22 * hackagebot libroman 1.0.0 - arabic to roman numeral conversions  https://hackage.haskell.org/package/libroman-1.0.0 (ahakki)
09:49:47 <dfeuer> I can't remember how to run these silly tests without the full cabal test, and yech.
09:49:59 <ski> it's not completely clear why `compute_vehicle_aero_c_coeff_epa' doesn't already have type `Vehicle -> Vehicle'
09:50:58 <darkmercenary> yeah i couldve wrote all of these as Vehicle -> Vehicle
09:51:26 <darkmercenary> i was thinking that itd be nicer to break it apart into smaller pieces and package it into a datatype but im not sure
09:51:32 <darkmercenary> im not very experienced in haskell
09:51:45 <ski> there seem to be no gain to stage it up in three parts, parameterized on `a',`b', at least as soon as you place them in that "heterogenous list"
09:51:57 <darkmercenary> my thought was that i have the computation part thats just in normal numbers that have no maybes on it
09:52:02 <darkmercenary> would be easy to see if they worked
09:52:34 <ski> darkmercenary : you *could* use an existential to make a "heterogenous list", but currently you'd have to make a new datatype, and apply its data constructor on each element, instead of `toVDerivation'
09:52:44 <ski> so it's not clear it's a gain
09:54:18 <ski> in any case, as soon as you put something like your `compute_vehicle_aero_c_coeff_epa :: Derivation CCoeffEpaA CCoeffEpaB' into that "heterogenous list", you'll lost the ability to inspect (and twiddle) the intermediate results of type `CCoeffEpaA' and `CCoeffEpaB'
09:54:22 * hackagebot libroman 1.0.1 - arabic to roman numeral conversions  https://hackage.haskell.org/package/libroman-1.0.1 (ahakki)
09:55:26 <ski> (well, you could inspect the intermediate `Maybe' part, check if it's `Nothing' or not, but not any more inspection)
09:56:06 <obs43> (<*>) <$> something
09:56:07 <obs43> What of the following is this doing?
09:56:08 <obs43> (1) Passing the arguments <$> and something to the function (<*>)
09:56:09 <obs43> (2) Applying (<*>) and something to the operator <$>
09:56:09 <obs43> ?
09:56:28 <ski> neither, i'd say
09:56:54 <obs43> So what is it doing then?
09:56:58 <darkmercenary> okay. i have another question. say these computations depend on others, what are some ideas that i could use to make sure they happen in the right order?
09:57:14 <ski> obs43 : this smells like a homework exercise ?
09:57:31 <obs43> ski: i'm not in school. but it's an exercise in a book yes
09:57:57 <ski> darkmercenary : just make sure there are (the correct) data dependencies, and then stuff should just work
09:58:02 <obs43> (or rather, it's a part of the answer in a book. not getting it)
09:58:11 <ski> well
09:58:13 <hpc> obs43: putting an operator in parens makes it parse like a regular identifier
09:58:28 <hpc> obs43: so your example parses the same as something <$> somethingElse
09:58:29 <ski> applying the operator `<$>' to the left argument `(<*>)' and the right argument `something'
09:59:06 <ski> (`(<*>)' itself is not visibly applied in this expression. and neither is `something')
10:00:01 <ski> obs43 : does hpc's and my explanation make any sense ?
10:00:03 <darkmercenary> the fields of Vehicle are usally Maybe Double. so if its Nothing the computation is just going to return nothing, but some computation might populate it because its (Vehicle -> Vehicle)
10:00:21 <obs43> hpc: what is somethingElse, and where did <*> go?
10:00:42 <ski> darkmercenary : it might be nicer to use monadic operations for the `Maybe' monad, to propagate/short-circuit intermediate `Nothing' answers
10:00:43 <hpc> it's just a different expression that parses the same way
10:01:21 <hpc> obs43: the parsing rules for operators and identifiers are more or less common sense
10:01:26 <ski> darkmercenary : `runComp' can be expressed using `fmap'
10:01:32 <hpc> obs43: and then () around an operator makes it an identifier
10:01:40 <hpc> obs43: and `` around an identifier makes it an operator
10:01:41 <ski> or `(>>=)' and `return' (or `do'-notation and `return'), if you prefer
10:01:48 <obs43> hpc: I thougth () around an operator turned it into a regular function.
10:01:52 <hpc> obs43: from there the rest should be readily extrapolated
10:02:01 <ski> or `(<$>)', which is just another name for `fmap'
10:02:13 <ski> (or `pure' and `(<*>)', if you insist)
10:02:31 <hpc> obs43: "identifier" vs "operator" happens at the level of parsing
10:02:50 <hpc> obs43: the distinction between functions and other types of values happens after, and you don't need it to understand the parsing of that expression
10:02:56 <ski> it would also be possible to use the function `maybe' in `runPlacer'. not sure whether you'd consider it clearer or not
10:02:59 <Aruro> is it possible to put several LANGUAGE pragmas in one line?
10:03:10 <ski> Aruro : yes, use commas inbetween
10:03:20 <ski> Aruro : and only a single `LANGUAGE'
10:05:05 <obs43> Let me put it like this:
10:05:05 <obs43> (<*>) <$> something
10:05:07 <obs43> We know <*> is an operator. Wrapping it in parentheses turns it into a function. So (<*>) is a function.
10:05:09 <obs43> We know <$> is an operator.
10:05:10 <obs43> This means that
10:05:12 <obs43> (<*>) <$> something
10:05:13 <obs43> is passing the operator <$> and something into the function (<*>)
10:05:14 <obs43> in a similar way that
10:05:16 <obs43> (+) 1 2
10:05:17 <obs43> is passing 1 and 2 into the function (+)
10:05:17 <obs43> right?
10:06:13 <ski> correction : We know <*> is an operator. Wrapping it in parentheses turns it into a expression. So (<*>) is a expression. Because it has a type of the shape `... -> ...', it is a function expression.
10:06:23 <ski> obs43 : no
10:07:08 <ski> obs43 : `(<*>) <$> something' is like if you had said `(+) * 3'. this is passing `(+)' and `3' as (left and right) arguments to the operator `*'
10:08:01 <hpc> lambdabot used to have some fairly heinous code that made it even make some kind of sense to write that
10:08:11 <hpc> > (+) * 3
10:08:12 <lambdabot>      No instance for (Typeable a0)
10:08:12 <lambdabot>        arising from a use of ‘show_M850641205131540871016315’
10:08:12 <lambdabot>      In the expression:
10:08:25 <obs43> ski: ah ok. this is what i've been asking :)
10:08:25 <obs43> Ok, so my question now is, why is this?
10:08:26 <obs43> This sounds like a contradiction to the following rule I heard: In Haskell, function application has a higher precedence than operators.
10:08:35 <ski> @let instance Num a => Num (rho -> a) where (f + g) r = f r + g r; (f - g) r = f r - g r; (f * g) r = f r * g r; negate f r = negate (f r); abs f r = abs (f r); signum f r = signum (f r); fromInteger n r = fromInteger n
10:08:37 <lambdabot>  Defined.
10:08:42 <tobiasBora> Hello,
10:08:49 <tobiasBora> I'm trying to use SIMD and Haskell
10:08:52 <ski> > ((+) * 3) 10 1000
10:08:55 <lambdabot>  3030
10:09:12 <ski> obs43 : ^ just a silly example of using `(+) * 3' :)
10:09:15 <hpc> obs43: what that means is that f x * g x is going to parse as (f x) * (g x)
10:09:19 <tobiasBora> And I can't manage to install the library : "cabal install simd" and "stack install simd" both give me errors : 
10:09:24 <hpc> obs43: as opposed to f (x * g) x
10:10:04 <ski> obs43 : `(<*>) <$> something' is strictly speaking the *operator* (not function, though it corresponds to one) `<$>' applied to `(<*>)' and `something'
10:10:07 <hpc> obs43: in (x * y) there's no function application to mix precedence with operator application
10:10:57 <tobiasBora> The errors :  http://paste.debian.net/678965
10:11:07 <tobiasBora> Does anyone knows how I could solve them ?
10:11:46 <tobiasBora> Isn't stupid to have major bound on version ?
10:12:04 <obs43> hpc: Was that parenthesized according to precedence rules only, or because Haskell was smart enough to know that the other paranthesization would not have typechecked?
10:12:17 <hpc> precedence
10:12:31 <hpc> haskell parsing is independent of typechecking
10:12:34 <ski> obs43 : bracketing doesn't take types into account, period
10:13:07 <tobiasBora> (And here is the lib I would like to install : https://hackage.haskell.org/package/simd
10:13:09 <tobiasBora> )
10:13:21 <ski> `f x * g x' means `(f x) * (g x)', because function application has higher precedence (iow, binds "tighter") than operators
10:13:24 <hpc> tobiasBora: did you mean upper bound instead of major bound?
10:13:34 <tobiasBora> hpc: upper yes sorry
10:13:48 <ski> (there are a few exceptions, but they don't apply to normal operators)
10:13:51 <hpc> upper bounds prevent old packages from becoming broken in the future by API changes in dependencies
10:14:15 <hpc> they're perhaps one of the most important things an author can do to help users of a package
10:14:26 <obs43> hpc: Ok. I'm starting to get it now. So in your example of "f x * g x", * acts as a "stopper" in the whole expression. So that it's not x, *, g, and x being applied to f. But rather it becomes (f x) * (g x) because of * acting as the "stopper"
10:14:38 <obs43> So in my example, <$> would in a similar way act as a stopper
10:14:48 <obs43> hmm
10:14:49 <hpc> at this very moment i have a patch to a package sitting on my desktop because it didn't have an upper bound set
10:15:10 <hpc> (which i actually no longer need, but just goes to show)
10:15:17 <ski> obs43 : let's imagine for a short while that function application would have been explicit, written using the symbol `@' (which is sometimes used in research papers for this purpose)
10:15:38 <tobiasBora> hpc: It's pretty rare than API changes no ? So why nearly each API has an upper bound ?
10:16:02 <hpc> API changes happen very frequently
10:16:17 <hpc> imagine writing something against GTK2 and then GTK3 happens
10:16:27 <ski> obs43 : then `f x * g x' would actually have been `f @ x * g @ x', and now the precedence rules tell us that `@' (function application) binds tighter than `*', so that has to be parsed as `(f @ x) * (g @ x)', so, eliding the explicit `@'s, we get back `(f x) * (g x)', as expected
10:17:06 <ski> obs43 : does that help ?
10:17:42 <hpc> tobiasBora: theoretically, every package on hackage follows the package versioning policy, which states that major versions only get bumped for API changes
10:17:59 <hpc> (in practice there's weird crap like HTTP-4000 but it's fairly rare)
10:18:06 <tobiasBora> hpc: Haskellers never respect backward compatibility ? And if an app is well design you usually had things in API, eventually "obsolete" some functions, but not write again the whole API no ?
10:18:19 <hpc> tobiasBora: things eventually deprecate
10:18:24 <hpc> and disappear
10:19:06 <hpc> having no upper bound on a dependency version is you claiming your code will work against any version of a package for the rest of time
10:19:11 <hpc> which is obviously false
10:20:08 <tobiasBora> Yes, I understand, but I see really lot's of upper bounds in packages, so libraries seems to change really often
10:20:13 <tobiasBora> For example, here :
10:20:21 <hpc> in a perfect world, a package version would be some magical encoding of the visible API, deprecations, etc
10:20:27 <hpc> and you can get inferred compatibility from that
10:20:32 <tobiasBora> base: needed (>=4.7 && <4.8), 4.8.2.0 found (latest applicable is 4.7.0.2)
10:20:33 <tobiasBora>       ghc-prim: needed (>=0.3 && <0.4), 0.4.0.0 found (latest applicable is 0.3.1.0)
10:20:35 <tobiasBora>       primitive: needed (>=0.5 && <0.6), 0.6.1.0 found (latest applicable is 0.5.4.0)
10:20:37 <tobiasBora>     needed for package simd-0.1.0.1
10:20:39 <tobiasBora> YYy
10:20:52 <tobiasBora> are all upper bound needed ?
10:21:03 <hpc> but it'd be complicated and authors would need to pay attention to things like a package deciding a graph now goes +x +y in a right-up direction instead of right-down
10:21:10 <tobiasBora> (base really change ?)
10:21:11 <hpc> and other non-type-related API changes
10:21:28 <obs43> ski: can you provide an @ example with functions of multiple arguments?
10:21:33 <obs43> that may help more
10:21:33 <Aruro> ski: ty!
10:22:00 <tobiasBora> hpc: And so do you have a solution to treat such above conflicts ?
10:22:11 <ski> obs43 : `f x y' would be `f @ x @ y', and because `@' is left-associative, this means `(f @ x) @ y', eliding again we get `(f x) y'
10:22:36 <obs43> ski: ok i'm starting to get it now!
10:22:38 <obs43> ski, hpc thanks!
10:22:42 <ski> np
10:22:48 <hpc> tobiasBora: the only way it could work is if the author set the upper bound based on the PVP and not testing
10:23:04 <tobiasBora> hpc: PVP ?
10:23:05 <hpc> tobiasBora: and by some great luck there are no breaking changes outside that version range
10:23:09 <hpc> package versioning policy
10:23:11 <ski> obs43 : also note that `->' in types is right-associative
10:23:21 <obs43> yeah
10:23:35 <ski> obs43 : `map :: (a -> b) -> [a] -> [b]' means `map :: (a -> b) -> ([a] -> [b])'
10:23:43 <hpc> tobiasBora: so basically, it could work but it's not promised
10:23:49 <ski> obs43 : this corresponds to `map f as' meaning `(map f) as'
10:24:00 <hpc> you can edit the cabal file to stretch the upper bounds a bit and see
10:24:31 <hpc> and if it works maybe suggest to the maintainer that they release a version with just those wider dependency bounds
10:25:23 <ski> > map (sin^2 + cos^2) [0,pi/8,pi/4]
10:25:26 <lambdabot>  [1.0,1.0,1.0]
10:25:46 <ski> > map (id^2 - id + 1) [0 ..]
10:25:48 <lambdabot>  [1,1,3,7,13,21,31,43,57,73,91,111,133,157,183,211,241,273,307,343,381,421,46...
10:27:17 <ski> > (take 4 . map (take 4 . (fst^2 + fst*snd + snd^2))) [[(x,y) | y <- [0 ..]] | x <- [0 ..]]
10:27:18 <tobiasBora> hpc: And if I want to respect the bounds used ? Why stack/cabal cannot install the older versions ?
10:27:19 <lambdabot>      Couldn't match expected type ‘([a], [a])’
10:27:19 <lambdabot>                  with actual type ‘[(Integer, Integer)]’
10:27:19 <lambdabot>      In the expression: [(x, y) | y <- [0 .. ]]
10:27:30 <ski> > (take 4 . map (take 4 . map (fst^2 + fst*snd + snd^2))) [[(x,y) | y <- [0 ..]] | x <- [0 ..]]
10:27:32 <lambdabot>  [[0,1,4,9],[1,3,7,13],[4,7,12,19],[9,13,19,27]]
10:28:11 <hpc> tobiasBora: your base version 4.8.2.0 is >= 4.8, ghc-prim 0.4.0.0 >= 0.4, and primitive 0.6.1.0 >=0.6
10:28:33 <hpc> "primitive: needed (>=0.5 && <0.6), 0.6.1.0 found (latest applicable is 0.5.4.0)"
10:29:14 <tobiasBora> hpc: I understand yes, but why cabal can't install in addition primitive 0.5.4.0 ?
10:29:42 <hpc> it probably requires a different version of base
10:29:44 <Sornaensis> :t id^2 - id+1
10:29:45 <lambdabot> Num a => a -> a
10:29:51 <hpc> and base is one of those "you can't change me ever" packages
10:29:53 <erisco> I'm afraid I can't do that tobiasBora.
10:29:56 <hpc> along with some ghc stuff
10:30:28 <hpc> honestly, you generally don't want multiple versions of the same package around anyway
10:32:53 <xa0> :t (^)
10:32:55 <lambdabot> (Integral b, Num a) => a -> b -> a
10:33:54 <tobiasBora> hpc: If you don't have multiple versions of the same package I can't see how cabal would deal with two libraries such that one need a library A with version < 4.0 and another library that needs library A with version > 4.0
10:35:15 <hpc> tobiasBora: it couldn't, which would put it in good company with just about every other package manager around
10:35:56 <geekosaur> specifically, primitive is access to wired-in ghc primitives
10:36:12 <geekosaur> it comes with the compiler/runtime, by necessity
10:36:46 <geekosaur> (iut's a stable interface to decidedly unstable internals, so it has to be n exact match and only the one that came with your ghc will work)
10:36:48 <hpc> as-is, for packages that aren't low-level enough to be locked at one version, cabal will gladly install alternate versions of packages without a thought
10:37:02 <geekosaur> well, "stable"
10:37:11 <simplify> Does stack have a command to add a dependency to my cabal file along with its deps? I am new to Haskell and I am looking for something like npm install --save
10:37:11 <hpc> however you need to then be careful of having z depends on x and y
10:37:19 <hpc> x depends on w < 1, y depends on w >= 1
10:37:34 <hpc> now you have z depends on w < 1 && >= 1
10:37:39 <hpc> which is of course not satisfiable
10:38:11 <hpc> but it's not immediately obvious if you have a sufficiently "real world" scenario of installing packages
10:38:43 <S11001001> simplify: style is to only add your direct dependencies to your cabal file, because the maintenance burden of keeping the transitive bounds up-to-date is just too much
10:39:24 * hackagebot http-dispatch 0.1.0.0 - High level HTTP client for Haskell  https://hackage.haskell.org/package/http-dispatch-0.1.0.0 (owainlewis)
10:41:25 <tobiasBora> hpc: Ok thank you !
10:42:57 <saurabhnanda> hey everyone, philosophical question -- what's the difference between promises (as in JS) vs continuations?
10:43:13 <saurabhnanda> context: I'm figuring out how to deal with JSON RPC callbacks....
10:43:26 * ski doesn't know the details of how promises in JS work
10:43:26 <saurabhnanda> context 2: actually JSON RPC over websocket
10:43:50 <ski> there's Continuation-Passing Style (CPS), and then there's continuation effects
10:44:02 <ski> just like there is State-Passing Style, and state effects
10:44:33 <Aruro> how to rollback a rollback in darcs? :) maid mistake
10:44:47 <ski> in State-Passing Style, you pass the prior state as an argument to the computation, and the computation, in addition to the "main result", also returns the post state
10:44:53 <saurabhnanda> ski: asyncFunction().onSuccess(function() {}).onFailure(function() {})
10:44:56 <ski> in types, `s -> (a,s)'
10:45:23 <ski> saurabhnanda : oh, that looks like a more elaborated variant of CPS, possibly
10:45:32 <erisco> ski, possibly no one does
10:45:43 <ski> saurabhnanda : however, to really be CPS, it has to be pervasive
10:45:46 <ski> erisco : does what ?
10:45:58 <erisco> knows the details of how JavaScript promises work
10:46:02 <ski> ok
10:46:05 <saurabhnanda> ski: pervasive?
10:46:39 <ski> saurabhnanda : you can't just throw a few commands into those functions passed to `onSuccess' and `onFailure'
10:47:02 <ski> you have to eventually call the (or one of the) continuation(s) that you yourself received
10:47:22 <ski> otherwise it's not CPS, but (possibly) nqCPS (not-quite CPS)
10:47:54 <hpc> javascript promises look like just multiple-continuation CPS
10:48:08 <saurabhnanda> does haskell have promises?
10:48:08 <ski> oh, and every function call, except perhaps "primitive" ones, must be a tail-call, otherwise it's not CPS
10:48:13 <hpc> (multiple-continuation nqCPS)
10:48:21 <saurabhnanda> okay, I'll stop the abstract discussion and try attacking it with specifics instead
10:48:28 <ski> saurabhnanda : if you could explain what "promises" in JS do, then perhaps we could answer
10:49:00 <erisco> I'm just saying it could be difficult or impossible to make comparisons
10:49:06 <jophish> Do people tend to do (f &&& g) or (bimap f g)?
10:49:23 <hpc> although... the MDN description of Promise seems to make it sounds like async
10:49:33 <dolio> Those are two different functions.
10:49:37 <ski> jophish : possibly you mean `f *** g'
10:49:38 <saurabhnanda> I receive a notification on a websocket, and I need to react to it. HOWEVER, before I can react to it, I need to make another call to the remote API, and wait for a response to come back (it will come over the websocket, pretty much like another notification), take some data from the second response, and then complete my original reaction. What's the best way to get this done?
10:49:39 <hpc> "This lets asynchronous methods return values like synchronous methods: instead of the final value, the asynchronous method returns a promise of having a value at some point in the future."
10:49:48 <hpc> compare with the examples on http://hackage.haskell.org/package/async-2.1.0/docs/Control-Concurrent-Async.html
10:49:56 <jophish> ski: oh, yes. I always get those two confised
10:50:10 <dolio> Anyhow, people should use bimap.
10:50:53 <ski> hpc : reminds me of events in CML
10:51:15 <saurabhnanda> basically it's not about sequencing two request/responses BECAUSE over a websocket, the response is async. 
10:51:20 <simpson> hpc: Or "promises" in E.
10:51:29 <ski> simpson, ok
10:52:30 <saurabhnanda> should I use MVar's or is call/c what I need?
10:52:51 <ski> saurabhnanda : judging from the descriptions so far, i'd say that at best it could be viewed as nqCPS .. however, that is something that one'd often want to express using `shift' and `reset' combinators, and i'm not sure how natural that'd be in this case
10:53:32 <ski> `MVar's are for use with concurrency
10:54:39 <ski> if you want to use `Cont' (or `ContT'), i'd suggest perhaps building something on top of `shift' and `reset' (composable/delimited continuations), rather than `callCC' (undelimited continuations)
10:54:52 <saurabhnanda> so basically threadA receives a notification, and it makes a request and it then needs to wait. The response is received by threadB and someone it needs to be communicated back to threadA. a shared MVar, perhaps?
10:55:02 <ski> (well, or using `shift' and `reset' directly .. but i suspect it can be a bit clunky)
10:55:17 <saurabhnanda> ski: where can I read about shift, reset?
10:56:06 <ski> saurabhnanda : you could try <http://okmij.org/ftp/continuations/index.html#tutorial>
10:56:42 <ski> @quote oleg
10:56:42 <lambdabot> oleg says: The implementation of RSA on type level is left for future work.
10:57:22 <ski> saurabhnanda : oh, and if you're not afraid of reading papers, i can also give two other links
10:57:24 <saurabhnanda> @quote saurabhnanda
10:57:24 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
10:57:36 <saurabhnanda> @quote ski
10:57:36 <lambdabot> ski says: my answer to that is : don't deduce, denote!
10:57:48 <ski> @quote milliOleg
10:57:49 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
10:58:06 <erisco> @quote medfly
10:58:06 <lambdabot> medfly says: I approve of kittens
10:58:09 <erisco> @quote medfly
10:58:09 <lambdabot> medfly says: I'm sure it was obvious to any onlookers that I do not have a licence, as I only crossed into the speed limit once
10:58:18 <erisco> @quote medfly_
10:58:18 <lambdabot> No quotes match. Abort, Retry, Panic?
10:58:21 <erisco> -.-
10:58:50 <saurabhnanda>  Participants are encouraged to bring their laptops and program along.”
10:59:22 <erisco> I think someone truncated the quote database
11:00:44 <saurabhnanda> ski: this is the actual paper, right? http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf
11:01:31 <ski> dunno, i haven't seen this tutorial before
11:02:41 <ski> saurabhnanda : the two papers i was thinking about was "Representing control: a study of the CPS transformation" in 1992 at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/RC.ps.gz> and "Abstracting Control" in 1990 at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/AC.ps.gz>, both by Olivier Danvy,Andrzej Filinski
11:04:12 <saurabhnanda> ps.gz -- great
11:04:24 * hackagebot http-dispatch 0.2.0.0 - High level HTTP client for Haskell  https://hackage.haskell.org/package/http-dispatch-0.2.0.0 (owainlewis)
11:04:25 <ski> the good old time ..
11:05:01 <saurabhnanda> wow, this is too dense for me
11:05:54 <Akii> woah
11:06:52 <saurabhnanda> actually I'm not sure if continuations are the answer for me here
11:09:58 <saurabhnanda> I need one thread to wait while some other (unknown) thread receives a response and communicates the response to the first thread
11:10:59 * ski learned about continuations partly by reading papers like those
11:11:31 <ski> saurabhnanda : Koen Claessen's "A Poor Man's Concurrency Monad" paper might be more accessible
11:11:48 <erisco> @quote medfly>
11:11:49 <lambdabot> medfly> says: and at work I have a slightly less large dump because I don't want to accidentally have naked ladies show up
11:12:00 * ski has seen the hand-painted/written slides for it
11:12:36 <Akii> http://www.di.ens.fr/~pouzet/cours/systeme/bib/koen-concurrency-poor-man-jpf93.pdf
11:13:10 <Akii> god I love all the wisdom and knowledge :D
11:14:25 * hackagebot elm-bridge 0.2.2.1 - Derive Elm types from Haskell types  https://hackage.haskell.org/package/elm-bridge-0.2.2.1 (AlexanderThiemann)
11:17:53 <Sonarpulse> I Asked earlier, but how can i write (~ Foo) :: * -> Constraint?
11:18:33 <hpc> :k ((~) Int)
11:18:34 <lambdabot> * -> Constraint
11:18:35 <amnn> Akii, when was that pearl published? All the references in it seem to be after '93...?
11:18:47 <Sonarpulse> (~) oh duh!
11:18:50 <Sonarpulse> thanks!
11:18:58 <ski> amnn : says "January 1993" on the top of the first page
11:19:07 <hpc> it's not exactly (~ Int) but fortunately (~) is commutative
11:19:12 <amnn> ski, yeah but the first line mentioned (Wadler, 1995)
11:19:29 <Akii> Tardis Monad probably
11:19:31 <ski> oh. that's interesting
11:19:41 <ski> possibly this is a polished-up later version then
11:19:42 <Akii> I've no idea, just googled it
11:20:03 <amnn> (in fact, every reference in it is from or after 1993)
11:21:34 <ski> saurabhnanda,Akii,amnn : <http://www.cse.chalmers.se/edu/year/2016/course/pfp/Material/ParMonad/Koen316.pdf> slides
11:22:16 <saurabhnanda> actually if my websocket did sync request/response then my problem gets simplifed
11:25:26 <Akii> saurabhnanda: that sounds like blocking
11:26:59 <Sonarpulse> nbp: How about (\_ -> (~ Foo)) :: k -> * -> Constraint ?
11:27:20 <saurabhnanda> Akii: yes, I want my websocket request to block till the response comes back, on the same thread
11:27:25 <Sonarpulse> well (\_ -> ((~) Foo)) :: k -> * -> Constraint
11:27:28 <Sonarpulse> to use what I know so far
11:27:29 <ski> no lambdas in types
11:28:44 <Sonarpulse> ski any... workaround?
11:28:52 <Akii> saurabhnanda: I've no idea how this would look functional but theoretically you could have events that happen after commands sent by the client, so the blocking would be done on the client
11:30:36 <amnn> ski, that was a nice talk (the par monad), thanks
11:31:59 <Akii> I'd love to know how you can send around events in haskell
11:33:31 <saurabhnanda> so, I'm thinking MVar. ThreadA sends out a request and stores (requestId, onSuccessFn) in a list. ThreadB receives data over the websocket, and if looks up requestId in the shared MVar, and executes the corresponding onSuccessFn
11:34:08 <ski> amnn : yw
11:34:37 <saurabhnanda> can I 'select' (as in 'C' select) over a websocket connection (https://hackage.haskell.org/package/websockets-0.9.6.1/docs/Network-WebSockets.html#g:2) and a channel 
11:34:37 <saurabhnanda> ?
11:34:51 <ski> Sonarpulse : not that i can think of
11:38:23 <c_wraith> saurabhnanda, you can forkIO threads that read from each and write to a shared MVar or Chan. 
11:38:42 <c_wraith> saurabhnanda, and ghc threads are far lighter than system threads. 
11:39:25 <hpc> ("far lighter" meaning "limited only by your system's RAM")
11:39:37 <hpc> (you can have millions of threads if you want it hard enough)
11:41:33 <darkmercenary> is there a way i can take a diff between two different values of a datatype
11:41:36 <darkmercenary> i have a really big record
11:41:45 <darkmercenary> and i dont want to see all Nothings or something
11:41:53 <darkmercenary> or rather can i hide the Nothings from the show instance
11:43:07 <johnw> darkmercenary: you can write a diffing function that produces a list of "Actions" which you've defined as a description of actions applied to the first value needed to result in the second value
11:43:29 <johnw> because that's what a diff is, except that we all understand already what those actions are (add, delete, change)
11:43:31 <saurabhn_> c_wraith: and wait for something to com on that interim channel?
11:43:50 <c_wraith> saurabhn_, yes
11:44:03 <johnw> for a big complex data type, it's going to be somewhat ugly, just warning you
11:44:41 <darkmercenary> hmm
11:47:18 <amnn> darkmercenary, from your second explanation, it sounds like you just want to truncate the record (get rid of all the fields that are Nothing)
11:48:29 <darkmercenary> its mostly for me to play around in ghci
11:48:49 <darkmercenary> yea
11:49:57 <amnn> well, perhaps it is worth factoring the record out into smaller components
11:51:08 <Sonarpulse> polymorphic recursion with nats seems brittle?
11:51:35 <c_wraith> Sonarpulse, in that ghc knows nothing about them? yes. 
11:52:02 <Sonarpulse> in that I have an explicitly annotated forall (n :: Nat) ...
11:52:04 <Sonarpulse> function
11:52:04 <amnn> (for instance, if you find that fieldA is Nothing iff fieldB is Nothing, then perhaps they should be factored into their own record)
11:52:27 <Sonarpulse> and i try to recur plugging in n as something else
11:52:32 <Sonarpulse> and I get a unifcation error
11:52:50 <c_wraith> huh. I haven't run into that. 
11:53:01 <c_wraith> got a small example? 
11:53:10 <Sonarpulse> it's as if the function is rebound without the `forall n.` in its body
11:53:19 <Sonarpulse> mmmm
11:53:29 <Sonarpulse> i guess I'll try to reduce
11:53:47 <amnn> this will reduce the Nothings in your record as a side effect. Another thing you could try is, getting rid of Maybe altogether, and having a different constructor for every combination of values your type could have. This may be prohibitively large though, I appreciate that.
11:53:51 <Sonarpulse> but I'm working in ghcjsi with lots a cruft lying around
11:53:57 <Sonarpulse> so might be difficult
11:54:15 <Sonarpulse> well, lots of irrelevant things that can be removed, but lots to remove period
11:54:53 <Sonarpulse> maybe I'll try aliasing my function
11:56:25 <Sonarpulse> ah nevermind!
11:56:30 <Sonarpulse> need more rankNtypes
11:56:39 <montanonic> Say I have a function that filters and maps an input Set, leading to an output the same size or smaller, and that the total input size is usually going to be quite small (one to five elements). Say also, that I'm going to use every element of the output, by formatting them for printing on a webpage. Would it make more sense to use foldr, or foldl' for this?
11:57:19 <Sonarpulse> working!
11:57:33 <montanonic> the performance impact of either is predictably extremely small, but I really like having an optimal solution
11:58:36 <JagaJaga> Perhaps I did `stack build` for the first time on my computer for the first time for the project. The cache for stack is located in "~/.stack" and "/project/.stack-work"?
11:59:18 <ski> montanonic : i suppose i'd try with `foldr' then
11:59:31 <montanonic> ski: okay, thank yu
11:59:32 <montanonic> you*
11:59:59 <infinity0> i'm writing a monad transformer that lets you schedule things to run later, trying to think of a name for it... AtT / CronT / SchedT / LaterT, can anyone help me decide? :p
12:00:05 <thorium> reasking a question from earlier today (about persistent): I know it's not desired because I'd lose type safety but can I somehow fetch a result using raw SQL with a varying number of columns? basically I know my first col is a timestamp and then there are 1-n cols of Texts - depending on the query string only known at runtime
12:00:52 <infinity0> i'm tending towards the last two, but SchedT is a bit abstract and may be confused with e.g. thread/process scheduling, and LaterT sort of implies the entire computation will happen later (not the case, only parts of it happen later)
12:00:54 <montanonic> infinity0: like, to run something after some X number of commands?
12:01:09 <montanonic> infinity0: or after a given time? which would require IO
12:01:11 <infinity0> run something after X number of abstract ticks, then you give a clock (either real or fake) when you runXXXT it
12:01:22 <ski> montanonic : possibly it doesn't really matter much, but perhaps it's be slightly nicer to be able to output the text incrementally, instead of bulkily
12:01:24 <montanonic> infinity0: does it rely on IO then?
12:01:38 <infinity0> most of it doesn't need IO, only "real" clocks do
12:02:07 <infinity0> but you could in theory code up a fake clock without IO i think. i haven't actually tried it yet, but i have a rough structure to be able to do it
12:02:24 <montanonic> ski: okay. thank you. I'm still trying to get a handle on laziness vs. strictness when it comes to performance
12:02:41 <montanonic> infinity0: that's interesting; I'd be curious how
12:02:51 <johnw> thorium: if all the columns are text, then just have your query return (TimeStamp, [Text])?
12:02:51 <infinity0> yeah i will push this code as soon as i settle on a name :p
12:02:59 <johnw> that's perfectly type safe, according to your specification
12:03:09 <infinity0> i don't want to push it then change the name several times..
12:03:50 <ski> montanonic : btw, instead of `foldr' on a set, you could convert to a list, and possibly use `concatMap'
12:04:14 <ski> (well, perhaps you want to also keep track of some state. it wasn't clear)
12:04:21 <montanonic> ski: I am folding a function that filters and maps at the same time
12:04:43 <ski> montanonic : no, i meant the function that you would pass to `foldr'
12:04:53 <ski> montanonic : .. oh, i see what you mean
12:05:06 <amnn> well, that is also achievable with concatMap
12:05:20 * ski thought montanonic was talking about `foldr (...) (...) . map (...) . filter (...)'
12:05:24 <montanonic> infinity0: I like SchedT, personally. It conveys the most information.
12:05:32 <thorium> johnw: ah I wasn't aware that persistent is smart enought to figure that out. I thought it would interpret that as 2 cols: 1 timestamp and one array? not arbitrary number of cols
12:05:37 <ski> amnn : unless there's some extra part of the state that's needed
12:06:19 <amnn> from.... foldr (\x acc -> if p x then insert (f x) acc else acc), we could do concatMap (\x -> if p x then [] else [f x]) . fromList
12:06:25 <amnn> yes that is true
12:06:40 <amnn> and I'm not sure there are any benefits to converting to a list either
12:06:43 <infinity0> montanonic: thanks yeah, i think i prefer that too
12:07:27 <montanonic> amnn, ski: I'll paste my actual function so you both can see
12:07:46 <ski> amnn : well, a `concatMap' could be clearer than a `foldr'
12:08:15 <amnn> what would be clearest is probably a filter and then a map, leaving GHC to fuse them
12:08:34 <montanonic> amnn, ski: http://lpaste.net/5490745418805411840
12:09:04 <montanonic> That function is then passed to another which adds more concrete types with it, and I use it to do some Html field server-side checking in Persistent. 
12:09:48 <montanonic> I have an Entity Field that can't have duplicates in a particular field, but duplicates only aren't allowed within the set of entitities that belongs to that particular user
12:10:31 <montanonic> And I return all the conflicting terms, along with creating links to the Entitites that contain them, which is the motivation for that data structure
12:10:55 <amnn> montanonic, you are folding over the list, not the set
12:11:19 <montanonic> amnn: yes, you're right, I had forgotten about that because I didn't look at it until now (I coded it last night)
12:11:34 <montanonic> the Sets are just for 'intersection' purposes
12:12:17 <montanonic> amnn: GHC fuses filter and map?
12:12:35 <montanonic> amnn: I hand-rolled the fold because I thought that would be the only way to get it done in a single pass
12:13:14 <montanonic> Many GHC optimizations are still completely foreign to me, especially when they actually happen
12:13:15 <amnn> montanonic, GHC has been known to fuse folds together
12:13:39 <amnn> ...whether it will in your specific case, well I would hope so, but I couldn't say for certain
12:14:26 * hackagebot http-dispatch 0.3.0.0 - High level HTTP client for Haskell  https://hackage.haskell.org/package/http-dispatch-0.3.0.0 (owainlewis)
12:14:38 <montanonic> amnn: so it seems like my current solution, even if a bit hard to read, is probably as close to efficient as I could get without changing my data structures
12:15:19 <montanonic> I'll profile with a concatMap implementation for fun
12:15:24 <montanonic> ty both
12:15:42 <amnn> your solution is probably worst case optimal, and I find it difficult to believe that if you were having performance problems, the problem would be in this piece of code, so I think you're pretty safe.
12:16:30 <amnn> your absolute best bet is probably just the composition of a map and a filter
12:25:39 <Aruro> why hlint complains about redundant lambdas? i find it nice to see that something is a function.
12:26:00 <ski> it likes to complain about some things
12:27:36 <S11001001> Aruro: as long as you're willing to pay for that
12:28:28 <erisco> linters are opinionated
12:28:53 <kadoban> Aruro: It's not always correct, and you're free to ignore it/shut it up.
12:29:34 <S11001001> Aruro: in this case it's just sort of a hint about the cost you're paying; you can suppress as you like, as erisco/kadoban say
12:30:07 <erisco> what is this cost?
12:30:21 <ski> not eta-reducing ?
12:30:41 <ski> (iow not sharing the result amongst multiple uses)
12:31:32 <erisco> I suspect the optimiser can eta-reduce
12:31:59 <ski> not so sure about that
12:32:16 <ski> (well "can" is one thing, "will try" is something else)
12:33:48 <S11001001> optimizing would also change the strictness
12:36:37 <Aruro> S11001001: so there is some subtle difference in meaning?
12:36:47 <jle`> int-e: hi! :) any particular reason why RecordWildCards isn't enabled in lambdabot?
12:37:55 <lyxia> Aruro: \x -> undefined x is more defined than undefined
12:38:49 <saurabhn_> is there a quick and dirty way to create a data type that can either be a ByteString or an Integer?
12:39:04 <saurabhn_> data MyFunkyType = ByteString | Integer ?
12:39:25 <kadoban> saurabhn_: data MyFunkyType = A ByteString | B Integer -- they need to have constructor names
12:39:28 * hackagebot rest-core 0.39 - Rest API library.  https://hackage.haskell.org/package/rest-core-0.39 (ErikHesselink)
12:39:30 * hackagebot rest-gen 0.19.0.3 - Documentation and client generation from rest definition.  https://hackage.haskell.org/package/rest-gen-0.19.0.3 (ErikHesselink)
12:39:32 * hackagebot rest-happstack 0.3.1.1 - Rest driver for Happstack.  https://hackage.haskell.org/package/rest-happstack-0.3.1.1 (ErikHesselink)
12:39:34 * hackagebot rest-snap 0.2.0.1 - Rest driver for Snap.  https://hackage.haskell.org/package/rest-snap-0.2.0.1 (ErikHesselink)
12:39:36 * hackagebot rest-wai 0.2.0.1 - Rest driver for WAI applications.  https://hackage.haskell.org/package/rest-wai-0.2.0.1 (ErikHesselink)
12:39:43 <simplify> How do sparks and Mvars compare to Erlang processes and mailboxs in performance? Is there a reason to choose Erlang over Haskell?
12:39:48 <Aruro> lyxia: i mean in case undefined is not involved
12:40:03 <geekosaur> saurabhn_, quick and dirty would be Either ByteString Integer
12:40:39 <maerwald> simplify: do you know about https://haskell-distributed.github.io/ ?
12:40:45 <Aruro> dotdirs = \x -> x /= "." && x /= ".." VS dotdirs x = x /= "." && x /= ".."   ???
12:41:01 <maerwald> I don't know the answer to your specific question, but "Erlang-style concurrent and distributed programming in Haskell."
12:41:26 <lyxia> Aruro: I don't think there's a difference here
12:42:19 <lyxia> you're more likely to get hit by the monomorphism restriction with the former
12:42:22 <maerwald> Aruro: https://github.com/quchen/articles/blob/master/fbut.md#f-x---is-not-f--x---
12:42:23 <simplify> maerwald: Yes, but I assumed that Cloud Haskell is more trying to fill in the gaps of OTP. I was hoping that someone had run a comparison of the Haskell RTS vs the Erlang VM in terms of scheduling performance and latency.
12:42:37 <maerwald> lyxia: there is a difference afais
12:42:41 <lyxia> oh
12:43:55 <Aruro> maerwald: ty, interesting
12:44:27 <saurabhnanda> geekosaur: ah, thanks -- simple solutions sometimes are elusive
12:44:38 * hackagebot rest-example 0.2.0.4 - Example project for rest  https://hackage.haskell.org/package/rest-example-0.2.0.4 (ErikHesselink)
12:51:47 <Aruro> any suggestions to improve this test directory traversal code ? http://lpaste.net/162171
12:52:18 <Aruro> gets memory problems with more than 700000 files :)
12:52:49 <Aruro> usage: progname Int, where Int - directory trav. scan level
13:06:06 <S11001001> Aruro: random guess, all the back and forth with Text?  IIRC the win with Text comes with quite, quite large strings
13:09:03 <burp> 700k is a lot, what is "memory problem"? 
13:09:35 <burp> I assume it does build up a complete list at some point?
13:10:33 <Aruro> burp: yes, precisely
13:11:07 <Aruro> S11001001: suprisingly text did add some performance gain vs native FilePath
13:11:18 <Aruro> S11001001: looks ugly i agree
13:11:40 <burp> yea, FilePath is just a type String I think?!
13:11:43 <Aruro> burp: 700k filepathes is not so much
13:11:53 <Aruro> average machine should have about 1M
13:12:15 <Aruro> burp: yes, its String
13:12:40 <S11001001> Aruro: too bad that FilePath isn't backwards
13:12:44 <Aruro> just for fun im trying to improve it, i know there is lazy version
13:12:54 <Aruro> for this problem
13:13:19 <S11001001> Aruro: random style, too, x >>= return . f is always fmap f x
13:13:27 <Aruro> somebody mentioned to me that turtle library manages to do directory-traversal using folds
13:14:01 <Aruro> S11001001: yes that is just some remnant after cleaning, hlint suggested it i think too
13:14:18 <S11001001> Aruro: bon
13:14:26 <Aruro> my main concern is how to reduce memory footprint from huge-mega list
13:14:36 <burp> do you want it sorted by path? or is a/foo.hs a/bar.hs a/b/xy.hs a/blub.hs a/b/zz.hs fine?
13:14:58 <Aruro> burp: all fine, whatever makes it less memory hungry
13:15:27 <Aruro> maybe some algorithm change, everything makes sense here it seems
13:15:46 <Aruro> on my sistem i can not scan below level 5
13:16:15 <Aruro> i think there should be above 1M files for computer which is used.
13:16:15 <burp> I don't see any principal reason that wouldn't allow it to be lazy and run in low constant memory
13:16:44 <Aruro> burp: you are right, the goal it to put whole structure in memory
13:18:19 <S11001001> Aruro: if you preserve the tree structure and have only basenames at all the nodes, you'll save on the string size, anyway.
13:18:34 <Aruro> 1M file pathes it should take, mm i dont know max 500M in memory? maybe a bit more, 700. 
13:19:09 <Aruro> S11001001: true, then i need some sort of tree structure data type?
13:19:53 <burp> a problem might be your recursion
13:20:16 <Aruro> burp: i tryied to wave deepseq at it, but without any real understanding :)
13:20:30 <burp> wonder if your code is fine in a single directory with 700k files :D
13:20:42 <Aruro> yes should be :)
13:21:03 <Aruro> on my machine i use it from / directory, but my proc directory is not changing fast
13:21:19 <Aruro> some people have exceptions from fast changing files in /proc
13:21:56 <burp> your scanner is also not tail recursive, right? so it might break down on deep structures
13:22:05 <Aruro> btw does fmap (d:) win over fmap ([d]++) ?
13:22:34 <ski> Aruro : probably no big difference, if any
13:22:37 <Aruro> burp: i think its not
13:23:04 <Aruro> ski: people claim it reduced memory usage from 200m to 140
13:24:02 <Aruro> im thinking maybe i should get rid from list and have on mega huge 50Mb Text string?
13:24:29 <glittershark> Is there an idiomatic way to destructure multiple fields using lenses?
13:25:05 <glittershark> I'm used to being able to do `\(MyRecord { foo = recFoo, bar = recBar} -> ....`
13:25:19 <glittershark> and obviously I can destructure one field using view patterns
13:25:37 <glittershark> `\(view foo -> recFoo) -> ...`
13:26:03 <glittershark> but I can't combine together multiple fields like that
13:26:49 <burp> Aruro: or Data.Sequence? People claim lists are not good for lots of elements
13:27:00 <ski> glittershark : and-patterns would be useful here ..
13:27:38 <glittershark> is that what @ is called
13:27:42 <burp> I'd work/play on/with your recursion, figure out why it builds up huge chunks of data
13:27:51 <glittershark> because I tried that and it's a parse error with multiple lenses
13:28:05 <lyxia> glittershark: "as-pattern"
13:28:09 <ski> glittershark : it's what could be extended into and-patterns
13:28:16 <glittershark> ie \(view foo -> recFoo) @ (view bar -> recBar) -> ... is a parse error
13:28:17 <glittershark> ah, yeah
13:28:22 <ski> yes, unfortunately
13:28:23 <glittershark> I know the term "as-pattern"
13:28:42 <glittershark> oh so this is one of those times I'm just hitting into a problem with the language
13:28:51 <glittershark> rather than a problem with my knowledge of it :P
13:29:16 <paolino_> there is an extension to have applied record fields in scope for free
13:29:16 <ski> `\(view foo &&& view bar -> (recFoo,recBar)) -> ...' would work, but i think it'd be a bit tedious with more fields
13:29:18 <Aruro> burp: ty, i will try to look into Data.Sequence
13:29:30 <glittershark> ski: was literally just about to suggest (&&&)
13:29:37 <ski> whee !
13:29:40 <Iceland_jack> glittershark: pattern synonyms
13:29:48 <Aruro> burp: ty for help!
13:29:52 <glittershark> I mean,
13:29:52 <lyxia> there's also RecordWildCards
13:30:03 <glittershark> well, yeah, but that's not lens-specific
13:30:12 <burp> just guessing :D might not help, but using stuff from containers instead of lists is always good ;)
13:30:15 <lyxia> right
13:30:23 <Aruro> burp: :)
13:30:35 <glittershark> like if I were gonna use pattern synonyms I could just write a lens that operated on a tuple of multiple fields
13:30:57 <glittershark> ie fooAndBar :: Lens' MyRecord (FooType, BarType)
13:31:15 <glittershark> but it seems weird to have to do that every time I want to destructure multiple fields...
13:31:17 <Iceland_jack> Why do you want to operate on them in pairs?
13:31:18 <glittershark> man
13:31:20 <glittershark> I don't
13:31:25 <glittershark> I just want to destructure multiple fields
13:31:52 <glittershark> a la let MyRecord { foo = recFoo, bar = recBar } = xyz
13:32:26 <glittershark> but also it'd be nice to be able to destructure one field but pattern match on the other
13:32:35 <glittershark> this is sounding even more like and-patterns
13:32:36 <glittershark> dangit
13:32:59 <glittershark> anyone know if there's a syntax extension in the works?
13:34:50 <maerwald> is there a "equality" function for lists that ignores the order?
13:35:10 <hpc> :t comparing S.fromList
13:35:11 <lambdabot> Ord a => [a] -> [a] -> Ordering
13:35:27 <hpc> ah no, that dedupes as well
13:35:41 <Iceland_jack> > comparing sort [1,3,2] [3,2,1]
13:35:43 <lambdabot>  EQ
13:35:47 <hpc> that was it
13:36:07 <hpc> in any event to do it efficiently you need Ord
13:36:40 <maerwald> it's a unit test, precision over efficiency
13:37:22 * ski imagines people optimizing their unit tests
13:37:39 <Iceland_jack> Speaking of un-optimized tests, I use 'suchThat' a lot
13:37:41 <Iceland_jack> :t suchThat
13:37:42 <lambdabot> Gen a -> (a -> Bool) -> Gen a
13:38:33 <Iceland_jack> This is slightly evil
13:38:34 <Iceland_jack>     generateZeros = suchThat arbitrary (\a -> eval a == 0)
13:38:34 <Iceland_jack> generates terms like (4 - 4) and (if True 0 10)
13:38:51 <Iceland_jack> If you're lucky :)
13:52:51 <Zemyla> Are the arguments in Bits required to be positive, or could you have a Bits type that has bits at (-1), (-2), etc.?
13:54:54 <byorgey> > bit (-64) :: Int
13:54:55 <lambdabot>  1
13:55:21 <byorgey> it seems that they wrap around for most types.
13:55:37 <byorgey> so I see no problem with having a type for, say, bi-infinite bit strings
14:09:31 * hackagebot eventloop 0.8.0.1 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.8.0.1 (sebaslafleur)
14:13:20 <glittershark> Is there a lens operator (or combination of such) for getting a value in a maybe?
14:13:27 <glittershark> or
14:13:30 <johnw> _Just
14:13:32 <glittershark> getting a field out of a value in a maybe
14:13:35 <glittershark> rather
14:13:36 <glittershark> sorry
14:13:41 <johnw> > Just 10 ^? _Just
14:13:42 <glittershark> so just
14:13:43 <lambdabot>  Just 10
14:14:16 <glittershark> what if that `10` is a record
14:14:19 <johnw> > Just 10 & _Just %~ (+1)
14:14:20 <lambdabot>  Just 11
14:14:21 <glittershark> and I want to get a field in that record
14:14:23 <johnw> then just compose other lenses
14:14:30 <johnw> > Just (10,11) & _Just._2 %~ (+1)
14:14:32 <lambdabot>  Just (10,12)
14:14:38 <johnw> > Nothing & _Just._2 %~ (+1)
14:14:39 <lambdabot>      No instance for (Show b0)
14:14:39 <lambdabot>        arising from a use of ‘show_M161963599328695594921108’
14:14:39 <lambdabot>      The type variable ‘b0’ is ambiguous
14:14:43 <scshunt> or vice versa
14:14:58 <johnw> well, it will be Nothing when the type is known
14:15:02 <scshunt> > (Just 10, "hello"), & _2._Just %~ (+1)
14:15:03 <glittershark> right
14:15:03 <lambdabot>  <hint>:1:19: parse error on input ‘,’
14:15:10 <scshunt> > (Just 10, "hello") & _2._Just %~ (+1)
14:15:12 <lambdabot>      Couldn't match type ‘Maybe a1’ with ‘[Char]’
14:15:12 <lambdabot>      arising from a functional dependency between:
14:15:12 <lambdabot>        constraint ‘Field2
14:15:20 <montanonic> So, should we be writing our binds as (=<<) to improve performance?
14:15:21 <scshunt> > (Just 10, "hello") & _1._Just %~ (+1)
14:15:23 <lambdabot>  (Just 11,"hello")
14:15:24 <scshunt> there we go
14:15:26 <maerwald> is there something like an IO sandbox, similar to a restricted docker container I can use for testing IO code?
14:15:31 <glittershark> Just (10, 11) ^. _
14:15:40 <glittershark> > Just (10, 11) ^. _Just._2
14:15:42 <lambdabot>      No instance for (Show a0)
14:15:42 <lambdabot>        arising from a use of ‘show_M381537892156803356721169’
14:15:42 <lambdabot>      The type variable ‘a0’ is ambiguous
14:15:54 <glittershark> > (Just (10, 11) ^. _Just._2) :: Integer
14:15:55 <lambdabot>      No instance for (Monoid Integer) arising from a use of ‘_Just’
14:15:55 <lambdabot>      In the first argument of ‘(.)’, namely ‘_Just’
14:15:55 <lambdabot>      In the second argument of ‘(^.)’, namely ‘_Just . _2’
14:16:03 <glittershark> > (Just (10, 11) ^. _Just._2) :: Maybe Integer
14:16:03 <scshunt> glittershark: _Just is a Traversal
14:16:04 <lambdabot>      No instance for (Num (Maybe Integer)) arising from the literal ‘11’
14:16:04 <lambdabot>      In the expression: 11
14:16:04 <lambdabot>      In the first argument of ‘Just’, namely ‘(10, 11)’
14:16:26 <glittershark> > (Just (10, 11) ^? _Just._2) :: Maybe Integer
14:16:28 <lambdabot>  Just 11
14:16:31 <glittershark> ahhh
14:16:32 <glittershark> ok
14:16:51 <johnw> _Just here is called a "prism"
14:16:57 <scshunt> right
14:17:01 <johnw> meaning it's a traversal over zero or one elements
14:17:01 <glittershark> wrapping my head around the fact that prisms and lenses can be composed with (.)
14:17:09 <glittershark> or
14:17:10 <johnw> they are all just functions
14:17:11 <glittershark> traversals and lenses
14:17:19 <scshunt> johnw: not all traversals one zero or one elements are prisms
14:17:22 <scshunt> but yes, _Just is a prism
14:17:33 <scshunt> glittershark: traversals, lenses, and prisms can all be composed
14:17:35 <johnw> scshunt: right, the constraint is different
14:17:46 <johnw> they can all be composed so long as the constraints are satisfied
14:17:49 <glittershark> how do I turn a lens into a traversal, then
14:17:56 <glittershark> without composing it with _Just
14:17:57 <scshunt> glittershark: both lenses and prisms are also traversals
14:18:02 <glittershark> like, I wanna do 
14:18:04 <scshunt> lens . lens = lens, prism . prism = prism, _ . _ = traversal
14:18:19 <glittershark> > Just (10, 11) ^. _2
14:18:21 <lambdabot>      Could not deduce (Num t0)
14:18:21 <lambdabot>      from the context (Num t,
14:18:21 <lambdabot>                        Num t2,
14:18:33 <glittershark> > (Just (10, 11) ^. _2) :: Maybe Int
14:18:34 <lambdabot>      No instance for (Num t0) arising from the literal ‘10’
14:18:34 <lambdabot>      The type variable ‘t0’ is ambiguous
14:18:34 <lambdabot>      Note: there are several potential instances:
14:18:40 <scshunt> glittershark: you can't do that because you need to go inside the Just
14:18:42 <amnn> glittershark, you have to use ^? _Just._2
14:18:55 <glittershark> right but that feels too monomorphic
14:19:00 <scshunt> glittershark: what would Nothing ^. _2 be?
14:19:04 <glittershark> Nothing
14:19:08 <scshunt> can't be
14:19:14 <glittershark> keep in mind I'm coming from <$> here
14:19:21 <glittershark> so where previously I was using
14:19:36 <glittershark> (fst <$> Just (10, 11))
14:19:44 <glittershark> now I want to be able to do that using lenses
14:19:46 <glittershark> ior
14:19:47 <glittershark> or
14:19:50 <glittershark> traversals
14:19:50 <glittershark> rather
14:20:15 <glittershark> but I dont' want to have to care what Traversable happens to be in there
14:20:44 <amnn> glittershark, if you tell us what operations you plan to do with this traversal, we can say what constraint you need
14:20:56 <glittershark> I mean, right now it's just a maybe
14:21:11 <amnn> glittershark, I mean, do you want to read from it *and* construct new versions of it?
14:21:17 <amnn> for that you need a Prism
14:21:20 <glittershark> oh, no
14:21:21 <glittershark> just read
14:21:26 <amnn> then you can use any traversal
14:21:44 <scshunt> but you have to care
14:21:46 <glittershark> but how do I take a lens
14:21:50 <glittershark> and turn it into a traversal
14:21:54 <scshunt> glittershark: a lens is a traversal
14:21:58 <glittershark> but I can't do
14:22:03 <amnn> glittershark, there is no "turning into", a Lens is a traversal
14:22:11 <glittershark> > Just (1, 2) ^? _1
14:22:13 <lambdabot>      Could not deduce (Num t0)
14:22:13 <lambdabot>      from the context (Num t,
14:22:13 <lambdabot>                        Num t2,
14:22:15 <scshunt> glittershark: of course not
14:22:25 <glittershark> I thought you said a lens was a traversal
14:22:27 <scshunt> it is
14:22:28 <glittershark> _1 is a lens
14:22:29 <amnn> glittershark, consider the types
14:22:33 <glittershark> why can't I use it like a traversal
14:22:34 <scshunt> but _1 is not a lens that operates on a Maybe
14:22:36 <scshunt> it operates on a tuple
14:22:38 <nkaretnikov> thoughtpolice: in the middle of your cbor talk: how do you ensure that a fixed sized buffer you allocate matches the size of a data structure you're dealing with?  is it encoded at the type level?  otherwise, it sounds c-like-scary.
14:22:41 <glittershark> *right*
14:23:04 <glittershark> how do I turn _1, a lens that operates on an `a`, to a lens that operates on a `Traversable a`
14:23:04 <scshunt> Just (1, 2) is a Maybe (Int, Int) [well, assuming you concretize the Num instance to Int for the sake of the discussion]
14:23:17 <glittershark> not a lens that operates on a `Maybe a`
14:23:19 <amnn> glittershark, right, I get what mis-understanding here
14:23:19 <glittershark> or
14:23:23 <glittershark> not Traversable a
14:23:27 <scshunt> glittershark: there's no generally perfect way to do that
14:23:28 <glittershark> `Traversable m => m a`
14:23:47 <glittershark> I can do it with fmap
14:23:50 <nkaretnikov> thoughtpolice: also, interesting that constructing ast gives a speed boost compared to generating directly.  iirc, aeson did the opposite to boost perf
14:23:55 <scshunt> glittershark: you can do this with fmap too
14:24:13 <scshunt> > (^. _1) <$> Just (1, 2)
14:24:15 <lambdabot>  Just 1
14:24:15 <glittershark> basically I'm trying to get around having to do `view _1 <$> Just (1, 2)`
14:24:17 <glittershark> right
14:24:22 <glittershark> I *know* that
14:24:31 * hackagebot hedis 0.8.2 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.8.2 (k_bx)
14:24:32 <scshunt> glittershark: but if you want to do that with a Traversal, you must specify the Traversal
14:24:33 <amnn> glittershark, what's the issue with that solution?
14:24:33 <glittershark> I'm asking if there's an operator that composes <$> and ^.
14:24:44 <glittershark> the issue is that it's ugly
14:24:50 <scshunt> glittershark: just write one
14:24:52 <johnw> why do you need that?
14:24:56 <scshunt> it's two lines
14:24:56 <glittershark> ok
14:24:58 <glittershark> christ
14:25:01 <glittershark> I know how to write it
14:25:06 <glittershark> I'm asking if it already exists!
14:25:06 <shachaf> I don't know what you want to do exactly, but there's preview (_Just . _1), as someone has already mentioned.
14:25:19 <glittershark> yes or now
14:25:21 <glittershark> no*
14:25:22 <amnn> glittershark, it does not
14:25:25 <glittershark> cool
14:25:27 <amnn> at least in common knowledge
14:25:33 <glittershark> man, #haskell is fun sometimes
14:25:37 <amnn> ...who knows what kmett's squirreled away
14:26:04 <scshunt> haha
14:26:24 <glittershark> me: hey does a common function exist to do this thing #haskell: you must not know what you're talking about! let me tell you how to write that function yourself!
14:26:51 <amnn> ...by our reactions, I think we can assume this function probably isn't "common"
14:27:19 <glittershark> really? people aren't using lens-subjects within functors?
14:27:34 <glittershark> basically all my values in my code are sitting in a functor somewhere
14:27:35 <EvanR> when a function is defined as f . g then a lot of the time its not going to be predefined, since theres n^2 blow up of such functions in general and you can just write f . g instead
14:27:42 <scshunt> glittershark: you didn't ask "is there an operator that composes (^.) with fmap?"
14:28:26 <thoughtpolice> nkaretnikov: Well, you can kind of just know as a client, like if you're taking an Encoding and creating a builder out of it, if you're smart enough ahead of time you can use your own builder of the right size for the output buffer, then the builder never has to do a doubling or something in order to accomodate the output.
14:28:45 <thoughtpolice> So that's an optimization up to clients, really (Currently we don't expose that in an easy way, but we probably should)
14:29:09 <EvanR> thoughtpolice: which talk is this referring to ?
14:29:11 <amnn> glittershark, yes it's a common usecase, but Functor really is the type class that embodies the minimal set of constraints you wanted, so fmap is what you end up having to use
14:29:35 <nkaretnikov> EvanR: binary-serialise-cbor from boston haskell
14:32:10 <nkaretnikov> thoughtpolice: could you explain again why the decoder is split into two parts?  like why do you ever want to go_slow?
14:40:03 <tobiasBora> Hello !
14:40:41 <tobiasBora> I have some list of int, and I would like to write something like "1 2 3". I mean I would like to concat strings with a separator
14:40:49 <tobiasBora> Does a function always do that ?
14:41:51 <koala_man> > intercalate " " . map show $ [1,2,3]
14:41:52 <lambdabot>  "1 2 3"
14:42:44 <geekosaur> and as lpaste keeps reminding me, intercalate " " is unwords >.>
14:44:26 <koala_man> I'll pretend that occurred to me but that tobiasBora said "a separator" and not space specifically. maybe the separator is " 2 ". 
14:45:08 <thoughtpolice> nkaretnikov: Also I can't quite speak to the details of Aeson's evolution, but I think JSON is harder to do in general case and make as fast (you don't know as much up front, even things like the potential size of a list, which you could possibly exploit etc).
14:48:14 <thoughtpolice> nkaretnikov: But look at the code carefully; what happens is go_slow is first started and that calls go_fast, which tries a bunch of tryConsume* functions to read the input buffer. If those fail, it goes to go_fast_end. go_fast_end then might return back to go_slow some kind of information like "we didn't have enough input in this chunk of the buffer" or it
14:48:15 <thoughtpolice> might fail outright.
14:48:36 <thoughtpolice> In the case you have a failure like "there wasn't enough input" the slow path might try to read more data from a chunk or something.
14:48:53 <tobiasBora> koala_man: Great thank you !
14:50:08 <arntzy> set beep_when_window_active ON
14:50:34 <thoughtpolice> nkaretnikov: This should all vaguely be documented internally, Duncan explained it all pretty well to me once and the specifics are eluding me since I didn't write it down :)
14:50:38 <thoughtpolice> dcoutts: ^^ :)
14:54:53 <nkaretnikov> thoughtpolice: i literally lol'd at the seriali{s,z}e thing, so good
14:56:01 <thoughtpolice> nkaretnikov: Then you'll probably like "Protect our repository with an evil bureaucratic dragon" https://github.com/well-typed/binary-serialise-cbor/commit/4661cf717dc7f1b53679a18f6fed593822b7cf14, too
14:56:11 <thoughtpolice> Unfortunately I had to revert it because it actually didn't work ;_;
14:57:04 <thoughtpolice> Also, his flames need to be replaced with a teacup, or something.
14:57:07 <nkaretnikov> hahaah
14:57:35 <thoughtpolice> maybe a wig, too
14:57:57 <MarcelineVQ> the reluctant bureaucrat
14:59:02 <nkaretnikov> thoughtpolice: why do you need all the non git greps?
14:59:20 <thoughtpolice> nkaretnikov: Because Cereal calls it 'Serialize' with a 'z', and you don't want it to trip on those.
14:59:32 <thoughtpolice> But we only care about for the benchmarks and nothing else.
14:59:35 <nkaretnikov> damn, that's complicated
14:59:44 <glittershark> \q
14:59:47 <glittershark> damn
15:00:52 <thoughtpolice> Oh I bet I know why it messed up.
15:01:07 <thoughtpolice> Actually no, I fixed that by using 'git grep'. So I'll still have to debug it. Oh well.
15:04:57 <lpaste> yyyyy pasted “Instance more specialised than class?” at http://lpaste.net/162183
15:05:09 <yyyyy> hey everyone. is there a way of providing an instance to a class with additional constraints?
15:05:15 <yyyyy> as in the paste above?
15:07:48 <yyyyy> e.g. requiring (C a) => a -> _ when the original class didn't specify the need for C. 
15:09:08 <nkaretnikov> yyyyy: lpaste doesn't seem to work over tor, so i can't take a look.  but given your example, i'm failing to understand the need for this
15:09:36 <thoughtpolice> yyyyy: Yes, if you use ConstraintKinds and associated types.
15:09:55 <thoughtpolice> Well, only if you also wrote the original class, too.
15:10:54 <yyyyy> nkaretnikov: i want to provide a Bifunctor instance to HashMap, and the way i see it i need toList to implement `first`.
15:11:19 <yyyyy> which in this case implies Eq and Hashable constraints that don't exist in Bifunctor
15:11:48 <nkaretnikov> yyyyy: let me see...
15:12:13 <yyyyy> bimap f g b = H.toList b & fmap (bimap f g) & H.fromList
15:12:42 <yyyyy> second would be trivial doing them separately, it's just fmap
15:14:36 <yyyyy> thoughtpolice: i suppose it won't work in this case then?
15:14:49 <nkaretnikov> yyyyy: going back to the initial question: given the def'n type HashMap k v = Map k v, wouldn't that be just instance Bifunctor (Map k) where ...?
15:15:01 <nkaretnikov> yyyyy: similar to the Functor instance sig
15:16:17 <yyyyy> nkaretnikov: that would make it (* -> *), it needs a (* -> * -> *) for Bifunctor
15:16:57 <nkaretnikov> yyyyy: ah, right. otherwise, you wouldn't be able to substitute in place for p a c etc.
15:17:04 <yyyyy> right :)
15:19:40 <nkaretnikov> yyyyy: so first is just :: (k1 -> k2) -> Map k1 v -> Map k2 v
15:19:57 <nkaretnikov> yyyyy: seconds is (v1 -> v2) -> Map k v1 -> Map k v2
15:20:04 <nkaretnikov> second is*
15:23:23 <nkaretnikov> yyyyy: you can use fmap to map over values, but you need to convert to a list of pairs with toList to change the keys
15:23:30 <nkaretnikov> yyyyy: does it answer your question?
15:24:28 <yyyyy> that's what i did, but toList for HashMap requires Eq and Hashable. I'll check later, can't stay now. Thanks, guys :)
15:24:33 * hackagebot prim-spoon 0.1.0 - Catch errors thrown from pure computations using primops.  https://hackage.haskell.org/package/prim-spoon-0.1.0 (lambdamichael)
15:27:16 <maerwald> waat, catching unsafePerformIO or wat
15:28:25 <nkaretnikov> yyyyy: ah, i know understand the problem...  well, i don't see a way to solve this properly since the binfunctor instance must work for types without an ord constraint
15:28:53 <EvanR> maerwald: im not sure how this is different from spoon
15:29:18 <nkaretnikov> yyyyy: you could probably write a newtype wrapper for a version that's specialized to a type that has ord, but i'm not sure off hand whether it'll work or not
15:29:21 <EvanR> maybe spoon would not catch division by zero
15:29:48 <puregreen> the readme says it's just faster than spoon
15:29:49 <puregreen> https://github.com/michaeljklein/prim-spoon#prim-spoon
15:30:06 <EvanR> ah thats what using primops means
15:32:23 <m1dnight_> If `cabal run` outputs "<<loop>>", am I correct in guessing that I have an infinite loop somewhere?
15:33:24 <geekosaur> m1dnight_, specifically you have something that refers to itself directly, like `let x = x in x` where, to evaluate x, it must evaluate x. infinite loops /per se/ are not necessarily a problem in haskell
15:33:40 <m1dnight_> Ah yeah, I have one of those. 
15:34:23 <m1dnight_> I have "let f x y = if <cond> then x else f x y
15:38:55 <m1dnight_> I don't get it. It must be the late hour. The code seems perfectly legal to me.
15:39:15 <m1dnight_> https://www.refheap.com/118568
15:40:36 <nkaretnikov> m1dnight_: cond is not mutable, so if it doesn't hold your program will loop forever
15:41:22 <johnw> yeah, that would be equivalently written as just: let f x y = if <cond> then x else error "cond doesn't hold"
15:41:45 <m1dnight_> Huh. I increment the counter each loop?
15:42:08 <m1dnight_> It's more like "f x = if x = 0 then x else f x - 1"
15:42:40 <johnw> that would need to be f (x - 1)
15:42:45 <johnw> otherwise, it's no different
15:42:47 <LordBrain> ==
15:43:04 <nkaretnikov> m1dnight_: i'd suggest posting the actual code
15:43:06 <LordBrain> :t (=)
15:43:07 <lambdabot> parse error on input ‘=’
15:43:13 <LordBrain> :t (==)
15:43:13 <m1dnight_> that is the actual code :o
15:43:14 <lambdabot> Eq a => a -> a -> Bool
15:43:28 <shachaf> m1dnight_: "let acc = acc ++ s" is a recursive definition.
15:44:01 <LordBrain> classic i came from imperative paradigm mistake
15:44:11 <m1dnight_> Ah!
15:44:19 <m1dnight_> That was indeed the mistake.
15:44:26 <m1dnight_> Dang. I wouldn't have spotted that one.
15:44:43 <m1dnight_> Thanks guys. It proceeding now :)
15:45:10 <m1dnight_> (It's a Z-machine interpreter, btw!)
15:45:52 <LordBrain> in functional, we don't update cells, we make new bindings, with their own names, so acc2 = acc1 ++ s
15:46:05 <LordBrain> well, you know what i mean
15:46:12 <LordBrain> adapt it to yoru style preference
15:46:20 <m1dnight_> For some reason I thought you could rebind names. I don't know why I came up with it.
15:46:27 <LordBrain> you can
15:46:41 <LordBrain> you'll get warnings about it from hlint, but it cna be done, if they are not recursive
15:46:45 <m1dnight_> Oh. Because it's an implicit let-rec or something?
15:46:50 <LordBrain> yes
15:47:00 <LordBrain> let in haskell is let-rec
15:47:37 <m1dnight_> Cool! It's working! 
15:47:43 <m1dnight_> Thanks for the patience guys! :)
15:49:35 * hackagebot dejafu 0.3.1.0 - Overloadable primitives for testable, potentially non-deterministic, concurrency.  https://hackage.haskell.org/package/dejafu-0.3.1.0 (barrucadu)
16:05:11 <nitrix> Could someone help me figure out the conversion from :: Point V2 Int32 to :: Point V2 CInt ?
16:05:33 <nitrix> Of the linear package? (Linear and Linear.Affine. Lenses are involved too).
16:06:11 <jle`> nitrix: fmap fromIntegral ?
16:06:37 <nitrix> jle`: That wouldn't map both I think.
16:06:43 <jle`> both what?
16:07:28 <nitrix> newtype Point f a = P (f a)
16:07:38 <nitrix> Where f is V2 here, there's two coordinates.
16:07:46 <nitrix> I want to convert both.
16:07:53 <jle`> what do you think fmap does for V2 ?
16:08:08 <nitrix> Probably only the right one?
16:08:10 <jle`> fmap :: (a -> b) -> V2 a -> V2 b
16:08:16 <jle`> so, would the first component stay an 'a' ?
16:08:24 <jle`> and the second component becomes a 'b' ?
16:08:33 <nitrix> I see that I'm wrong.
16:08:59 <jle`> yeah, try implementing 'fmap' that way, and it won't typecheck
16:09:00 <jle`> :)
16:09:09 <Welkin> fmap fmap
16:09:10 <jle`> fmap f (V2 x y) = V2 x (f y) won't typecheck
16:09:56 <jle`> `V2 a` is more or less equivalent to (Bool -> a)
16:10:10 <nitrix> I don't know why I thought the type was separate for each coordinate; like `V2 a a`
16:10:11 <jle`> fmap has to change the type of all of the a's
16:10:23 <jle`> ah, if that was the case, there's no point in using V2 :P  just use (,)
16:10:28 <nitrix> In my mind I needed a bifunctor but since the instance was missing, I dig into the lens stuff.
16:10:36 <nitrix> jle`: right.
16:10:51 <Welkin> jle`: (,) looks like a pig's butt
16:11:01 <nitrix> Let me guess, linear is by edward too?
16:11:01 <jle`> what is (,,) ?
16:11:12 <Welkin> an aliean pig with two tails
16:11:16 <drostie_> a rabbit's paw.
16:11:17 <jle`> yeah, linear is an edwardk library
16:11:33 <Welkin> lol
16:11:41 <Welkin> half of hackage is by edward
16:11:42 <nitrix> I propose that edward is an alien.
16:11:54 <Welkin> and I don't understand most of the things he writes
16:12:57 <drostie> I like Kmett, he once said something like "I had all these dreams of developing the perfect language, then one day I ran into Haskell and I was like, 'I am not smart enough to do better than this', so I abandoned those dreams and started writing Haskell instead."
16:13:31 <jle`> hm, if a 2-vector is a (Bool -> a), is a (Bool, a) a 2-covector in any meaningful way?
16:13:59 <jle`> i understand that covectors is already a concept in LA/tensor calc
16:14:45 <drostie> If by covector you mean a 1-form, that would be the linear set of (Bool -> a) -> a.
16:16:55 <drostie> Not sure I can see any straightforward mapping between that and (Bool, a).
16:17:38 <jle`> yeah, it's more or less a Bool
16:21:04 <drostie> sort of. It's isomorphic to (a, a) because f :: (a, a) -> (Bool -> a) -> a defined by f (a, b) g = a * g False + b * g True  gives all of the possible transforms.
16:21:51 <drostie> So ($ True) and ($ False) are the basis covectors.
16:30:04 <qguv> what's it called in propositional logic when [for all x in S: p(x)] is true only because S is the empty set?
16:34:02 <qguv> the term was "vacuous truth" for the curious
16:35:21 <Welkin> a vacuum-like truth
16:35:31 <Welkin> it sucks?
16:35:33 <Welkin> or it's empty?
16:35:58 <Welkin> and only contains virtual particles and quantum energy fluctuations
16:36:16 <qguv> . /r/VXjunkies
16:38:54 <drostie> It's vacuous because it's lacking punch. A implies B means in prop.logic "either A is false or else B is true" -- because you violate "A implies B" by making A true and B false simultaneously. It's therefore the case that any provably-false proposition implies everything "vacuously", since it satisfies that implication but will never be helpful to actually use it. ^_^
16:44:37 * hackagebot hobbits 1.2 - A library for canonically representing terms with binding  https://hackage.haskell.org/package/hobbits-1.2 (EddyWestbrook)
16:50:51 <developer_010> http://caffeinealgorithm.com/
16:54:19 <Welkin> don't click it!
16:54:22 <Welkin> it's probably a trap
16:56:39 <nitrix> What the hell. stack ghci works on a project, but stack build doesn't.
16:57:18 <scshunt> O_o
16:57:21 <nitrix> Parse error on a binding <- of a do block.
16:57:30 <nitrix> I don't get it.
16:57:42 <scshunt> !paste
16:57:50 <scshunt> hrm, what's the command
16:57:55 <scshunt> anyway, paste a minimal reproduction
16:58:21 <nitrix> http://lpaste.net/162186
16:58:29 <nitrix> line #15 in that paste.
16:59:26 <scshunt> that's bizarre
16:59:27 <monochrom> I think you need that block indented a bit more to the right
16:59:34 <nitrix> Whao. Works if I indent the `do` block further from the column of `loop`.
16:59:38 <scshunt> oh right, yeah
16:59:57 <nitrix> But why `ghci` let it through and not `build`?
17:00:07 <monochrom> otherwise it would think "events ..." is a sibling of loop.
17:01:07 <nitrix> Oh, the multiple let declaration syntax or something.
17:01:17 <nitrix> I'm surprised the two tools aren't consistent though.
17:01:33 <monochrom> you know, I have trouble believing that ":load that-file.hs" in ghci would work.
17:01:34 <nitrix> You'd expect the same GHC backend for compilation :/
17:01:43 <scshunt> nitrix: stack ghci will still launch ghci if there's a build failure
17:02:18 <nitrix> monochrom: The game is way too complicated to just load a tiny file, sadly :)
17:02:28 <nitrix> I just replaced the main function to test a theory.
17:02:58 <nitrix> Turns out, drawing multiple tiny objects it what's slowing my renderer. A very very large texture draws blazing fast.
17:03:37 <nitrix> I think I'll chunk the game world into regions and render those to a texture then draw those textures instead, sort of a "cache" system.
17:04:00 <nitrix> (There's already culling done, the problem is too many elements).
17:04:11 <nitrix> monochrom: scshunt Oh, well, sorry about that.
17:19:21 <tobiasBora> Hi again ! I have a little question about where : is it possible to use "where" when I use IO monad ?
17:19:31 <tobiasBora> for example, I would like to write :
17:19:37 <geekosaur> what does the IO monad have to do with anything?
17:19:44 <tobiasBora> my_random =
17:19:46 <geekosaur> where is part of declaration syntax
17:20:07 <tobiasBora> geekosaur: I mean, can I use the "->" operator instead of "=" in where clauses
17:20:26 <geekosaur> no
17:20:46 <Welkin> -> is not an operator
17:20:49 <geekosaur> (assuming you meant <-)
17:20:51 <Welkin> iti s syntactic sugar
17:20:57 <Welkin> er yes, <-
17:20:58 <Welkin> :P
17:21:13 <geekosaur> and it's not an operator, and you need to understand what it really is so you can understand how/where you can use it
17:21:27 <mgsloan> nitrix: interesting!  I bet it's due to the build using haskell2010, I don't think stack ghci currently accounts for that
17:22:08 <nitrix> mgsloan: It is using haskell2010, yeah.
17:22:24 <tobiasBora> geekosaur: Yes "<-" indeed
17:22:59 <NeverDie> Anyone know how I could serve up a static bundle.js React file with Haskell to make a web app?
17:23:32 <tobiasBora> NeverDie: Yesod ?
17:24:01 <NeverDie> Can it be done with Spock?
17:24:34 <mgsloan> nitrix: https://github.com/commercialhaskell/stack/issues/2092
17:24:49 <Welkin> you can serve use a static file using anything
17:24:55 <Welkin> even ust warp itself
17:25:07 <Welkin> or scotty
17:25:17 <fr33domlover> warp would work. Yesod also has a LiteApp class which makes it easy
17:25:19 <Welkin> use yesod if you actually want to build something though
17:25:33 <NeverDie> Welkin: How come Yesod over Spock?
17:25:41 <Welkin> spock is very low level, like scotty
17:25:53 <Welkin> yesod is fully featured and ready for production use
17:25:56 <simony> so I'm trying to figure out what's going on in my Hakyll code, but debugCompiler doesn't seem to be doing anything. I've run it using `stack exec site rebuild -v` but don't see any output from the debugCompiler
17:26:25 <NeverDie> Welkin: Oh there's one called Scott too?
17:26:28 <simony> am I doing something really wrong or expecting something that it isn't meant to do?
17:26:30 <NeverDie> I thought you were saying that as a pun lol.
17:26:32 <tobiasBora> By the way, is there any Haskell equivalent to the Ocaml "ocsigen", that let you write the client side code (usually Javascript) in serveur side code (Haskell/Ocaml) ?
17:26:34 <NeverDie> Scotty*
17:26:52 <Welkin> yes
17:27:00 <Welkin> they all use the same http server underneath: Warp
17:27:08 <kadoban> tobiasBora: Not familiar with ocsigen, but, GHCJS?
17:27:12 <Welkin> scotty and spock add some basic route handling
17:27:14 <Welkin> that's it though
17:27:20 <fr33domlover> tobiasBora, check out Fay
17:27:36 <nitrix> mgsloan: Added a comment for completeness (sorry :P)
17:29:01 <geekosaur> kadoban, it looks like ocsigen lets you intermix client and server code, like if ghc had some way to compile some functions with the native backend and others with ghcjs backend
17:29:42 <geekosaur> (then the output is separate server-side program and client-side js lib)
17:30:14 <kadoban> Sounds interesting
17:30:36 <geekosaur> as things currently work, I think you;d need to make them separate projects and build one with ghc and the other with ghcjs/fay/whatever
17:31:01 <NeverDie> Welkin: That's just about what I want I suppose. I'm looking to create a project that can analyze the computational complexity of algorithms you paste.
17:31:11 <Welkin> I don't get the whole "single page app" craze
17:31:12 <NeverDie> Like if you were to paste a JavaScript function, it'd tell you what the computational complexity is for it.
17:31:20 <Welkin> it's going backward and makes for horrible experiences for the user
17:31:38 <Welkin> slow, buggy, doesn't work right, and adds far too much complexity
17:31:59 <Welkin> you don't need an in-browser app for that
17:32:05 <Welkin> just add some ajax calls to your page
17:32:06 <Welkin> done
17:33:35 <monochrom> I think it's because programmers are control freaks, they crave for the unnecessary total control offered by Flash and "single page app" etc.
17:34:02 <kadoban> Javascript and the web is now (partially) just another platform for applications, which is kinda nice because it's quite generally available, every common OS has a port of one of the decent browsers.
17:34:03 <obadz> if I create a :command in ghci that takes module name as an arg, how do I tell GHCI to perform completion accordingly?
17:34:14 <kadoban> Nothing particularly wrong with that to me, as long as it works fine.
17:34:19 <monochrom> That's right, remember those days when every "designer" websites were Flash'es?
17:35:23 <NeverDie> Welkin: So I should be good just using Spock?
17:35:25 <kadoban> Welkin: In other words, it saves me writing the same thing for windows and then linux and then OSX and then iOS and then android and then etc.
17:35:42 <Welkin> namecheap updated their control panel last year and now it is horribly slow, actually lags my browser, and is imposible to use
17:35:50 <Welkin> the old one loaded instantly and was easy to use
17:35:59 <Welkin> the new one is a "single page app"
17:36:01 <monochrom> And before Flash, before users worried about malware, programmers would actually have you download and run a bloody exe
17:36:10 <obadz> Welkin: I moved all my domains to google domains yesterday for that reason and a few others
17:36:17 <tobiasBora> Fay and ghcjs are pretty interested... But If I understand well, it's not that easy to call from client side a function that will run on server side without explicitly playing with Ajax.
17:36:26 <obadz> Welkin: well Google is a single page app too, just faster.
17:36:40 <Welkin> I'm fine with namecheap
17:36:47 <Welkin> I just hate their new interface
17:36:51 <monochrom> That's right, remember 25 years ago when even a simple Christmas card had be to an exe?
17:37:09 <obadz> Welkin: if you use their free mailforwarders, it drops E-mails it thinks is spam, no way to fish them out, no way to get notified, no way to turn that off…
17:37:15 <mathu> any of you have nice writings about applicatives that you'd recommend? that was the part out of LYAH i had the most difficulty with, and it's not coming naturally in http://www.seas.upenn.edu/~cis194/spring13/lectures/10-applicative.html either
17:37:45 <Welkin> mathu: the typeclassopedia
17:38:35 <mathu> Welkin: ah, right, i forgot that was linked on this page, i'll give that a read
17:38:36 <mathu> thank you
17:40:54 <NeverDie> Welkin: That's interesting. I recently started working for Namecheap.
17:42:04 <obadz> NeverDie: what's up with the non-optional spam filters man :)
17:42:31 <monochrom> perhaps it's a bug
17:42:39 <NeverDie> Still trying to get acquainted to everything lol. 
17:57:38 <lpaste> lambdafan pasted “Controlling how test data is generated in QuickCheck 2” at http://lpaste.net/162217
17:59:52 <tomleb_> Anyone familiar with the Spock framework can tell me how I can get the last url visited ?
18:06:20 <teeter> So, I want to learn and use lens, but I'm apprehensive about adding the bloat to my projects. Is simple-lens a good alternative?
18:07:14 <teeter> *lens-simple
18:09:42 <paulsamways> tomleb_: are you talking about the referring url?
18:11:14 <tomleb_> paulsamways: Yeah I guess so
18:11:49 <tomleb_> paulsamways: Like, to be able to "go back"
18:17:51 <koz_> How do I start an instance of GHCi in a Cabal sandbox without implicitly importing the Prelude?
18:20:31 <paulsamways> tomleb_: Hmm. So the referer header will only be set if they followed a link to the current page (won't be available if they go there directly). If you're trying to create some sort of ui where you redirect them to a page and want to give them an option to go back, then you'll need to look at using sessions to store the current url before redirecting.
18:20:46 <geekosaur> hm. I think: cabal exec -- ghci -XNoImplicitPrelude
18:20:51 <geekosaur> but maybe not
18:22:24 <koz_> geekosaur: Thanks - that's what I was missing. I was trying 'cabal repl' for some raisin.
18:23:08 <geekosaur> you can do that but I don't think you get to choose options in that case. flip side, cabal exec ghci won't load anything from your project, although it will know about the modules in it
18:23:14 <tomleb_> paulsamways: Yeah I want to redirect them back when they followed a link. Are you sure I need sessions for that ? Could I use the context instead to look for the referer header ?
18:23:59 <tomleb_> paulsamways: Also, I have a lot of trouble figuring out how to read the documentation. So I have no idea how to mess around with sessions.. 
18:25:05 <Lokathor> so is it mostly "normal" to have NFData instances on types you make in a library?
18:25:22 <KaneTW> is that a pun
18:25:47 <Lokathor> not intentionally so
18:26:30 <Lokathor> i'm wondering if i should keep my dependency list of the library a little smaller, or just go for it
18:27:37 <arahael> Lokathor: Build first. Optimise later.
18:28:09 <KaneTW> if the need arises
18:28:15 <KaneTW> someone will tell you they'd like a NFData instance
18:28:22 <KaneTW> don't overcomplicate things imo
18:28:50 <Lokathor> well right now I have the instances, but they're just orphan within the Benchmark.hs benchmark file
18:29:17 <KaneTW> well
18:29:19 <KaneTW> if you already have them
18:29:22 <KaneTW> just include them
18:29:29 <KaneTW> since you obviously have a usecase already
18:30:10 <Axman6> paulsamways: Poke (-> #haskell.au)
18:30:19 <Lokathor> well that's why i asked how common it was for others to use NFData :P
18:31:17 <KaneTW> reasonably common
18:31:25 <KaneTW> and i mean
18:31:42 <KaneTW> writing a benchmark isn't that rare
18:35:18 <paulsamways> tomleb_: It really comes down to your use case. If you want to control the URL they are redirected back to, then session (or query string param) is the usual way.
18:36:34 <tomleb_> paulsamways: Huh, so I guess I'll have to figure out how to setup sessions then
18:37:04 <tomleb_> paulsamways: and use the Weird SpockActionCtx thingy
18:40:58 <paulsamways> tomleb_: or query params if you don't want to have a server-side session. 
18:43:24 <tomleb_> paulsamways: Is there a simple tutorial somewhere that shows how to use these things ? I mean, I looked at funblog but there's way too much stuff for a beginner.
18:47:06 <puregreen> teeter: yep, it's alright. For bigger projects you might want microlens instead because there are more instances, but lens-simple on the other hand has a nicer implementation which is good if you're only learning lenses
18:52:35 <paulsamways> tomleb_: No idea, I haven't used Spock, but the mentioned techniques are essentially the same across languages/frameworks.
18:55:55 <teeter> puregreen: cool, I'll try it then
18:57:34 <begriffs> I'm running into a baffling threading problem, perhaps some of you have experienced something similar and have ideas what might be wrong. My program seems to create child processes which never die and start cumulatively using all the CPU.
18:58:27 <begriffs> It happens slowly. Threads get spun up from web requests, make db calls, return results then just hang around.
18:59:42 * hackagebot highlight-versions 0.1.3.6 - Highlight package versions which differ from the latest  version on Hackage  https://hackage.haskell.org/package/highlight-versions-0.1.3.6 (BrentYorgey)
19:00:34 <begriffs> Anyway the issue is documented here, with strace and perf output. It's hard to debug. https://github.com/begriffs/postgrest/issues/565
19:04:59 <lambdafan> hey begriffs :)
19:05:19 <begriffs> lambdafan: hey there
19:05:48 <lambdafan> begriffs: do you have a minute to look at my quickcheck 2 problem? I've got both hpaste and stackoverflow version
19:06:00 <begriffs> Sure
19:06:15 <lambdafan> http://stackoverflow.com/questions/36992969/controlling-how-test-data-is-generated-in-quickcheck-2
19:06:31 <lambdafan> do you prefer hpaste?
19:10:42 <begriffs> lambdafan: some of these quickcheck generators look like they work with the Bounded typeclass. Stuff like arbitraryBoundedRandom
19:11:39 <KaneTW> also check out the various newtypes
19:11:43 <KaneTW> https://hackage.haskell.org/package/QuickCheck-2.8.2/docs/Test-QuickCheck.html
19:13:21 <lambdafan> begriffs: oh so it's not as simple as making a new Args ?
19:13:49 <lambdafan> begriffs: that's what I wanted confirmed, I wanted to make sure I wasn't doing things the hard way unnessecarily
19:14:28 <begriffs> lambdafan: there's this related looking SO post about bounding values https://stackoverflow.com/questions/29106904/test-a-function-with-a-list-of-bounded-value-with-quickcheck
19:14:42 * hackagebot split 0.2.3.1 - Combinator library for splitting lists.  https://hackage.haskell.org/package/split-0.2.3.1 (BrentYorgey)
19:14:48 <lambdafan> KaneTW: thanks for the link too!
19:15:02 <lambdafan> begriffs: thanks :)
19:22:53 <mathu> i have a `f :: String -> Maybe (a, String)` and `g :: String -> Maybe (b, String)`. i want to take the second half of the tuple after evaluating f and feed it to g, unless f gives me Nothing. can i pattern match like `case f of _ -> Nothing` ?
19:23:37 <mathu> er, `case f of (_ -> Nothing) -> ...`
19:24:42 * hackagebot riak 1.0.1.0 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-1.0.1.0 (lambda_foo)
19:25:47 <tomleb_> mathu: Not too sure (I'm pretty new) but I think it would be possible with functor / applicative functor.
19:26:53 <nitrix> mathu: Maybe is a functor, and tuples are functors too :)
19:27:05 <nitrix> mathu: You have two nested data structures, but it's do-able :)
19:27:45 <nitrix> You could fmap . fmap, or manually do it if you think it's too clever for now.
19:28:31 <tomleb_> nitrix: How would YOU you do it ? Or what would be the most idiomatic way ?
19:28:54 <mathu> tomleb_: i'm actually implementing an applicative instance for a type, haha
19:28:58 <nitrix> > (fmap . fmap) (++"!") Just (5, "Hello")
19:28:59 <lambdabot>      Couldn't match type ‘[Char]’ with ‘(Integer, [Char])’
19:28:59 <lambdabot>      Expected type: (Integer, [Char]) -> Maybe [Char]
19:28:59 <lambdabot>        Actual type: [Char] -> Maybe [Char]
19:29:07 <nitrix> > (fmap . fmap) (++"!") (Just (5, "Hello"))
19:29:08 <lambdabot>  Just (5,"Hello!")
19:29:24 <nitrix> > (fmap . fmap) (++"!") Nothing
19:29:26 <lambdabot>      No instance for (Show (f0 [Char]))
19:29:26 <lambdabot>        arising from a use of ‘show_M298961051626866718826813’
19:29:26 <lambdabot>      The type variable ‘f0’ is ambiguous
19:29:39 <nitrix> Oh, baboom.
19:30:35 <nitrix> tomleb_: I'd use monads.
19:30:55 <nitrix> He's extremely close to almost discover them on his own :P
19:32:09 <tomleb_> nitrix: tbh I never went too deep in the haskell language and just learned applicative functor form learnyouahaskell lol
19:32:25 <nitrix> tomleb_: So you basically haven't learned them :P
19:32:34 <tomleb_> although I did take a course on edx for functional programming which was on haskell and covered a tiny bit of monads
19:32:58 <tomleb_> But I still have to go back and reading this long text to fully comprehend it
19:33:07 <nitrix> Learn You A Haskell is a nice book to get people curious, but I don't think it's a good material to teach anything.
19:33:32 <tomleb_> What would you recommend ?
19:33:46 <jaarod> LYAH lost me at applicatives
19:33:55 <nitrix> tomleb_: I'm biased unfortunatly. haskellbook.com
19:34:36 <tomleb_> jaarod: why
19:34:44 <nitrix> jaarod: Do you understand them now?
19:35:17 <tomleb_> nitrix: Huh, 59$ can't afford that 
19:35:30 <Mateon1> Hi, I have a question, what's the intended usage for fixIO? I've used it in a hacky way to make an infinite loop but realized there's forever instead. Now I wonder, what, if anything can it be used for?
19:35:54 <nitrix> tomleb_: It doesn't change my answer though.
19:35:55 <jaarod> tomleb i couldn't figure out why they are useful from lyah, but it could be me and not the tutorial. nitrix yeah i get them now
19:36:18 <nitrix> > (+1) <$> (Just 5)
19:36:20 <lambdabot>  Just 6
19:36:33 <nitrix> > Just (+1) <*> (Just 5)
19:36:35 <lambdabot>  Just 6
19:36:50 <jaarod> your first example didn't use applicatives :P
19:36:59 <nitrix> I'm comparing them.
19:37:18 <nitrix> What people don't realise is that their full name are Applicative Functors.
19:37:34 <nitrix> They share a lot of similarities from functors.
19:37:37 <nitrix> :t <$>
19:37:39 <lambdabot> parse error on input ‘<$>’
19:37:41 <nitrix> :t (<$>)
19:37:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:37:44 <nitrix> :t (<*>)
19:37:45 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:38:04 <johnw> Mateon1: http://stackoverflow.com/questions/25876042/what-does-fixio-do
19:38:25 <Mateon1> johnw: Thanks
19:38:26 <hubleBee> :t fixIO
19:38:27 <lambdabot> Not in scope: ‘fixIO’
19:38:37 <nitrix> Same signature, minor the function being wrapped by this `f`. Thus, they are functors that can be applied to other functors, hence, applicative functors.
19:39:16 <nitrix> Books can embelish it a little, but it doesn't have to be complicated. LYAH is just completly off.
19:40:24 <tomleb_> Is it though ? I think it says exactly what you just said about functors
19:41:40 <nitrix> tomleb_: Maybe we need a more valid theory about why LYAH is always leaving people more confused then.
19:41:59 <ski> Mateon1 : the intended usage is "value recursion in the `IO' monad"
19:42:19 <Mateon1> johnw: Oh, I understand. fix functions give back what you return as an argument. I thought it was the function itself, just to allow an eternal recursion
19:42:25 <tomleb_> nitrix: maybe it's because LYAH is one of the first resource a beginner will encounter, and it's because he's a beginner that makes him confused
19:42:51 <jaarod> applicatives = functors with <*>. monads = applicatives with join. is that right?
19:43:05 <jaarod> with <*> and pure*
19:43:19 <Mateon1> nitrix: By the way, does that mean that (>>=) = flip (<*>) and (=<<) = (<*>)?
19:43:27 <ski> Mateon1 : the idea is that `fixIO f', when executed, will execute `f x' *once*, yielding `x' as result, and then itself yield `x' as result
19:44:14 <nitrix> Mateon1: >>= is <$> then join.
19:46:59 <ski> Mateon1 : e.g., say that you have a `type IORefList a = IORef (IORefCell a)' where `data IORefCell a = Nil | Cons a (IORefList a)', and that `f :: IORefList a -> IO (IORefList a)' will take a given such "list", and, when the resulting `IO'-action is executed, will allocate some more `IORef' mutable cells to hold `IORefList a's, thereby adding some cells in front of the "input list"
19:47:58 <ski> Mateon1 : then `fixIO f' will feed back the monadic result of `f' as the input that's passed to `f', so that we're actually constructing a *cyclic* `IORefList a' !
19:49:49 <Mateon1> Interesting, so something like (let x = 1 : x) except deferred via IO, right? Or more generally, fixIO f ~ (let x = f x) with some IO magic
19:54:06 <ski> Mateon1 : yes
19:54:23 <ski> Mateon1 : but the `IO' effects by `f' will only happen once
19:55:15 <ski> @type System.IO.fixIO
19:55:16 <lambdabot> (a -> IO a) -> IO a
19:56:11 <Mateon1> ski: Great. Before I found out about 'forever', I did: join $ fixIO $ return <$> (do {...} >>) -- let me work out how that worked now that I think I understand it.
19:56:52 <ski> @type Control.Monad.Fix.mfix
19:56:53 <lambdabot> MonadFix m => (a -> m a) -> m a
19:56:56 <ski> @type Control.Monad.Fix.fix . (=<<)
19:56:57 <lambdabot> Monad m => (a -> m a) -> m a
19:57:19 <ski> Mateon1 : `mfix' is the generalization of `fixIO' to (some) other monads as well
19:58:00 <ski> the above version with `fix' does *not* do the same thing, instead it does an infinite loop, similar to `forever'
19:58:36 <Mateon1> Cool, thank you, ski
19:59:01 <Mateon1> I think I need to go to sleep, because the sun is rising about now.
20:00:12 <ski> wrt `IORef', it would in that case be possible to set the `IORef' mutable cell first to some dummy value, then construct the to-be-cyclic list, then patch it up at the end, by changing the contents of the "deepest" referenc cell
20:00:18 <ski> but it's a bit more clunky
20:00:28 <ski> using `fixIO' makes this simpler
20:00:45 <ski> and in other cases, there may be no good alternative to using `fixIO'/`mfix'
20:03:08 <ski> @let newCyclicIORef :: (Data.IORef.IORef a -> a) -> IO (Data.IORef.IORef a); newCyclicIORef f = System.IO.fixIO (Data.IORef.newIORef . f)
20:03:09 <lambdabot>  .L.hs:147:17:
20:03:09 <lambdabot>      Not in scope: type constructor or class ‘Data.IORef.IORef’
20:03:09 <lambdabot>      Perhaps you meant ‘Data.STRef.STRef’ (imported from Data.STRef)
20:03:20 <ski> hm
20:03:29 <ski> @type let newCyclicIORef :: (Data.IORef.IORef a -> a) -> IO (Data.IORef.IORef a); newCyclicIORef f = System.IO.fixIO (Data.IORef.newIORef . f) in newCyclicIORef
20:03:30 <lambdabot> (GHC.IORef.IORef a -> a) -> IO (GHC.IORef.IORef a)
20:16:10 <toph> has anyone used the hscurses logging functions (debug, trace)? i tried specifying the -debug flag for ghc and #define __DEBUG__ in my file but i don't see any log file created
20:46:05 <NeverDie> Anyone know how to serve React code with the Spock web framework?
20:48:22 <mathu> nitrix: thank you for the suggestion! i'll try tomorrow -- the wifi at the starbucks i was at went out so i'm walking home now and using my phone haha
20:49:11 <NeverDie> mathu: You work from a Starbucks?
20:50:39 <tobiasBora> A little question : I have a Word8 n, and I would like to do (n-60) `mod` 12.
20:51:30 <mathu> NeverDie: sometimes i go there to study with friends, yeah
20:51:40 <tobiasBora> The problem is that when n-60 is negative, the result is quite "absurde" because it computes the result of (n-60)+2^8 `mod` 12
20:51:46 <NeverDie> That's where I used to go.
20:51:52 <mathu> it's exam week so the library is absolutely full
20:52:09 <NeverDie> mathu: Where are you from?
20:52:40 <tobiasBora> So here is my question : should I come back to Int, or can I stay with Word8 to do my compute ?
20:52:52 <mathu> NeverDie: USA
20:53:12 <mathu> midwest
20:53:22 <NeverDie> Ah, I see. I figured as much that you were from the USA lol.
20:53:47 <mathu> yeah i guess that's still a safe assumption haha
20:54:45 * hackagebot phoityne-vscode 0.0.1.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.1.0 (phoityne_hs)
20:54:47 <mathu> alright, off to bed
20:55:42 <hubleBee> i'd just go to int, fromIntegral ((fromIntegral n - 60) + 2^8 `mod` 12)
20:55:54 <hubleBee> there and back again
20:56:10 <hubleBee> might need a type sig
20:58:14 <hubleBee> yeah,  you'd need to disambiguate the inner fromIntegral
20:58:26 <tobiasBora> hubleBee: Why should I add 2^8 ?
20:58:33 <watChmeFly> Hey guys
20:58:48 <hubleBee> oh i just cut and passted your thing and modified
20:59:46 * hackagebot octane 0.4.19 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.19 (fozworth)
21:00:25 <tobiasBora> hubleBee: Oh ok. Well thank you !
21:09:24 <ski> tobiasBora : absurd, how ?
21:14:26 * dfeuer stabs criterion.
21:15:11 <dfeuer> Specifically, its infinite list of dependencies.
21:21:46 <koz_> What's a good library for zippers? I need a tree zipper specifically.
21:25:15 <Axman6> koz_: the zippers package lets you build zippers from anything which you can use lenses to traverse. takes a little getting used to though
21:26:18 <koz_> Axman6: I might have to check it out then. I've been trying to hand-roll a zipper for my (somewhat unusual) tree, and it's proving nightmarish.
21:26:26 <koz_> So I figured I'll check out how other folks did it.
21:27:07 <koz_> ... and of course it was made by Edward Kmett. :P
21:27:28 <Axman6> zippers is really code, because it gives you a zipper into anything you can focus on with lenses, and keps the path in the type system
21:27:46 <Axman6> so you get heaps for free
21:27:49 * ski idly wonders how koz_'s tree type looks like
21:28:50 <koz_> ski: It's kinda annoying to explain, but I'll fill you all in once I finish it (because I'm gonna want critique).
21:29:15 <koz_> Axman6: I see what you mean about it taking some getting used to...
21:31:03 <Axman6> basically you use downward to go deeper into the tree, and upward to come back up
21:31:46 <Axman6> #haskell-lens might not be a bad place ot ask questions if you have any and don't get much help here.
21:31:57 <koz_> Axman6: I'm having *severe* trouble even understanding this package.
21:32:09 <koz_> Like, I genuinely have no clue wtf it is I don't even
21:32:27 <Axman6> start playing with some of the types in ghci
21:32:35 <koz_> Axman6: I may have to.
21:33:10 <koz_> I guess it helps to understand lenses with this?
21:34:27 <Axman6> you'll get things like downward _1 (zipper (1,2)) :: Top :> ((Int,Int) @ ()) :> Int I think
21:34:47 <Axman6> yeah that might help, but playing around with some types might teach a lot
21:35:05 <koz_> Axman6: Well, I always wanted to understand lenses anyway, so it might be a good place to begin.
21:35:16 <Axman6> good luck! 
21:35:40 <koz_> I get the feeling I'll need it...
21:36:00 <Axman6> they're not that difficult, their implementation is very general though. lens is big but there's onlky a few concepts you need to know to get started: Lens, Prism and Traversal and Iso get you a very long way
21:36:30 <koz_> Axman6: Well, I'll give it a go. Worst comes to the worst, I could always hand-roll this particular zipper and then ask some of you nice folks how I can lens it up.
21:37:39 <Axman6> Lens s a: focus on the single a in an s, Prism s a might focus on an s in the s, if it exists, Traversal s a lets you focus on all the a's in an s (thing of Traversal [a] a focusing on potentially all the a's in the list) and Iso a b is an isomorphism between two types
21:37:54 <Axman6> Ed has given a few good talks on lenses which are on youtube
21:41:01 <cocreature> the good thing about lens is that you can get very far without knowing how it works internally
21:56:32 <kadoban> Is there a decent golf function for …  :: (a -> Bool) -> a -> Maybe a ?
21:57:20 <EvanR> @djinn (a -> Bool) -> a -> Maybe a
21:57:20 <lambdabot> f a b =
21:57:20 <lambdabot>     case a b of
21:57:20 <lambdabot>     False -> Nothing
21:57:20 <lambdabot>     True -> Just b
21:57:35 <shachaf> [x | p x]
21:58:03 <simpson> shachaf: To be fair, don't you need listToMaybe in there too?
21:58:12 <kadoban> Oh with uhm, whatever that extension is that allows that?
21:58:16 <shachaf> No.
21:58:18 <shachaf> Yes.
21:58:22 <shachaf> MonadComprehensions
21:58:37 <simpson> Pfft, well-played. I nearly spat out my drink.
21:59:01 <kadoban> Right, thanks. Hmm, I think I might just write it out, pretty sure I'll forget what that's doing.
21:59:36 <shachaf> Well, there's always listToMaybe [x | p x]
21:59:53 <kadoban> Yeah, I suppose I'll remember what that is
22:01:50 <EvanR> so listToMaybe . filter p . (:[])
22:05:23 <EvanR> seems roundabout
22:05:58 <dfeuer> shachaf, you may be interested in https://github.com/haskell/containers/pull/215/  You may also have some good ideas for speeding it up.
22:15:23 <kadoban> > min (0/0) 5.0
22:15:25 <lambdabot>  5.0
22:15:30 <kadoban> Shouldn't that be NaN ? :-/
22:15:51 <EvanR> > (0/0) < 5.0
22:15:53 <lambdabot>  False
22:16:14 <kadoban> IEEE breaks everything … damn you NaN
22:16:18 <Axman6> > 5.0 < (0/0)
22:16:19 <lambdabot>  False
22:16:23 <Axman6> \o/
22:24:48 * hackagebot fold-debounce-conduit 0.1.0.1 - Regulate input traffic from conduit Source with Control.FoldDebounce  https://hackage.haskell.org/package/fold-debounce-conduit-0.1.0.1 (debugito)
22:29:48 * hackagebot monad-unlift 0.2.0 - Typeclasses for representing monad transformer unlifting  https://hackage.haskell.org/package/monad-unlift-0.2.0 (MichaelSnoyman)
22:29:50 * hackagebot monad-unlift-ref 0.2.0 - Typeclasses for representing monad transformer unlifting  https://hackage.haskell.org/package/monad-unlift-ref-0.2.0 (MichaelSnoyman)
23:34:50 * hackagebot yesod-job-queue 0.2.0.1 - Background jobs library for Yesod.  https://hackage.haskell.org/package/yesod-job-queue-0.2.0.1 (nakaji_dayo)
23:59:57 <jle`> > 5.0 > (0/0)
23:59:59 <lambdabot>  False
