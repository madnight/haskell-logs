00:07:37 * hackagebot wai-make-assets 0.1.1 - Compiling and serving assets  https://hackage.haskell.org/package/wai-make-assets-0.1.1 (SoenkeHahn)
00:07:37 * hackagebot cndict 0.7.6 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.7.6 (DavidHimmelstrup)
00:11:43 <BartAdv> in what circumstances compiler requires datatype declaration before its use?
00:12:11 <BartAdv> I thought it can be anywhere in the module, but now I started to have "Not in scope" errors
00:12:20 <BartAdv> and I can't really figure why is that
00:15:45 <geekosaur> TH, mostly
00:16:30 <geekosaur> since it's running while it is reading the source file, it cannot see the current definition or anything after it, only what came before
00:18:02 <BartAdv> hm, yeah, there is TH to derive JSON instances: https://gist.github.com/BartAdv/a13e88b06b3c67aed1b2e53ce106e718#file-declorder-hs
00:18:17 <BartAdv> but I use it for 2 datatype decls here, and it only errors out for the latter
00:20:21 <BartAdv> and I don't see how this derivation would affect the API type, as it is not affected by those instances
00:25:45 <BartAdv> but indeed, removing TH alleviates the problem
00:31:01 <lyxia> BartAdv: TH forces an ordering of definitions
00:31:32 <koz_> If I have a function foo :: a -> a -> Maybe b, and I have x :: Maybe a and y :: Maybe a, how would I feed them to foo?
00:31:48 <koz_> I can do the case of foo' :: a -> Maybe b and x :: Maybe a, but not this one.
00:31:50 <BartAdv> lyxia: yeah, I can imagine that, I got a bit surprised it only errors out for the CourseData and NewCourse is fine
00:32:31 <Koterpillar> koz_: do { x' <- x; y' <- y; foo x y }
00:32:38 <lyxia> BartAdv: yeah, it's basically like the TH breaks the module into chunks
00:32:41 <koz_> Koterpillar: Shoulda known...
00:32:42 <Koterpillar> koz_: do { x' <- x; y' <- y; foo x' y' }
00:32:52 <BartAdv> oh, putting the TH invocations in one place fixes the issue too
00:33:05 <koz_> Koterpillar: What does that look like without do-sugar?
00:33:29 <BartAdv> so I can get away with having the API declared first, the API data next, and the handler implementations on the end, which I find cool to read
00:33:38 <BartAdv> thanks!
00:35:21 <geekosaur> I think that's also applicative? foo <$> x <*> y
00:35:57 <koz_> geekosaur: Would that really work?
00:37:14 <koz_> geekosaur: It *does*, but only if I had a -> a -> b.
00:37:18 <koz_> Which is... oddly even better.
00:37:27 <Axman6> join $ foo <$> x <*> y works
00:37:47 <Axman6> works for foo :: a -> b -> m c
00:38:58 <koz_> Axman6: Yeah, Just figured...
00:39:05 <koz_> Also, what's the type I should use for exact fractions again?
00:39:18 <mtesseract> Morning :)
00:39:19 <Axman6> what do you mean?
00:39:24 <koz_> Hi mtesseract!
00:39:44 <koz_> Axman6: I wanna represent *exactly* 1/3, as opposed to 0.333... for some number of digits.
00:39:51 <koz_> What number type in Haskell does that?
00:39:53 <Axman6> Rational is a good start
00:39:59 <koz_> Axman6: Thanks!
00:40:02 <Axman6> > 1/3 :: Rational
00:40:04 <lambdabot>  1 % 3
00:40:40 <Axman6> but the operations you can perform are limited to ones which can guarantee rational results, so don't try any trig functions
00:41:39 <mtesseract> Yes, Rationals are awesome.
00:41:53 <koz_> Axman6: I don't plan on any trig functions.
00:42:02 <koz_> Just want me some sexy fractions.
00:55:35 <lpaste> koz_ pasted “Applicative style question” at http://lpaste.net/164892
01:06:39 <lpaste> lyxia annotated “Applicative style question” with “Applicative style question (annotation)” at http://lpaste.net/164892#a164895
01:06:46 <lyxia> koz_: ^
01:15:38 <lpaste> malice` pasted “List tests” at http://lpaste.net/164897
01:15:48 <malice`> Hi guys! Haskell noob here!(working through the tutorial) I've got a question about Haskell lists: how are you allowed to combine , and .. inside list([])?
01:15:57 <malice`> You can see my "List tests" above, I guess
01:15:58 <malice`> :)
01:16:54 <malice`> I guess that if you have max. 2 "elements" (e.g. [1,2..5]) then .. will kind of work, but I guess that's syntax sugar and I would understand it better if I knew what it does underneath
01:17:00 <malice`> I find some results strange
01:19:17 <geekosaur> there isn't a lot of flexibility
01:19:34 <jle`> malice`: the list range syntax is honestly a little awkward/clunky, i usually don't use it that much
01:20:11 <geekosaur> [x..] is enumFrom x, [x..y] is enumFromTo x y, [x,y..] is enumFromThen x y, [x,y..z] is enumFromThenTo x y z
01:20:17 <koz_> lyxia: Thanks - flip to the rescue I guess!
01:20:26 <jle`> beat me to typing it.  but yup, that's it
01:20:30 <geekosaur> those are the only valid forms
01:20:42 <malice`> Thank you. Gonna look it up now.
01:20:44 <jle`> that's it as in, that's all of it, really
01:23:49 <body> Hello, somebody online ?
01:24:03 <malice`> Okay, I get it now, thanks!
01:24:12 * EvanR hits body with a candlestick in the conservatory
01:25:07 <koz_> Maybes, Maybes everywhere...
01:34:03 <body> basically, I have this config https://raw.githubusercontent.com/SKaDiZZ/wolf-xmonad/master/.xmonad/xmonad.hs , and i am getting this errors, http://pastebin.com/zKiTr8yU , anybody have some ideea what I am doing wrong ?
01:35:04 <Axman6> you might get a more informed response in #xmonad
01:35:11 <east_> Can I do something similiar to this with where clause in do clause http://lpaste.net/164898 ?
01:35:32 <scepticulous> I recently finished a course on functional programming in haskell and instructor ( erik meijer ) seemed to have a strong opinion to prefer singleton/empty lists over the maybe type in haskell. Is there anybody here that might have a clue about the resoning, maybe some references or quotes or explainations why that might be the case ?
01:37:53 <Axman6> east_: you can use let
01:38:13 <Axman6> let h = ...; g = ...; z <- g $ h y
01:40:38 <Cale> scepticulous: Because he's weird. There are cases where it would be preferable of course, but it's pretty rare that it would be preferable in the case where there's at most one element.
01:42:16 <east_> Axman6: ty.
01:44:25 <sannysanoff> hi there. I am having low-level IO issue. My process hass multiple sockets open and relay packets forth and back in multiple forkio(), and as I shut down some of the remote servers, entire process stops sending data on all sockets at once. Is it known bug? I attached gdb and got some stacktraces of all threads. Is there anything that could help diagnosing this definitely RTS bug?
01:47:45 <sannysanoff> thanks community! the posting this question here alone helped me to question my own statement. It's problem in my program, not RTS.
02:01:20 <Cale> sannysanoff: That's good to hear
02:02:24 <shelf> anyone know if it's feasible to cross-compile, linux build -> Mac OS X run?
02:02:30 <koz_> How can I cut [a] into ([a], [a]), ensuring that a) the pieces are in the same order as the original and b) the 'left' list always has an even number of elements? 
02:02:45 <shelf> the wiki pages are mostly concerned with cross compilation between architectures, not platforms
02:03:44 <Cale> shelf: I expect it to be tricky.
02:04:01 <Cale> koz_: f xs = ([], xs)
02:04:58 <koz_> Cale: I guess I didn't specify properly. 
02:05:01 <shelf> dang. i think we're on the verge of setting up a mac mini build farm :(
02:05:34 <koz_> How can I cut [a] into ([a], [a]), ensuring that a) the pieces are in the same order as the original, b) the 'left' list always has an even number of elements, and c) the sizes of both halves are as similar as possible.
02:05:42 <koz_> ^ That should be more specific
02:06:22 <alproxy> @let data Free f a = Pure a | Free (f (Free f a)) deriving (Show)
02:06:23 <lambdabot>  .L.hs:308:24:
02:06:23 <lambdabot>      No instance for (Show (f (Free f a)))
02:06:23 <lambdabot>        arising from the first field of ‘Free’ (type ‘f (Free f a)’)
02:06:39 <alproxy> ^How to derive Show for this
02:10:21 <alproxy> Is there any way to ensure `f` is member of `Show` and derive `Show` instance for `Free`
02:11:20 <alproxy> Looks like no one is here
02:12:08 <Cale> deriving instance Show (f (Free f a)) => Show (Free f a)
02:12:12 <Cale> try that
02:12:26 <Cale> You'll need StandaloneDeriving turned on
02:13:02 <Cale> also probably FlexibleContexts
02:14:15 <jle`> koz_: i'd probably pattern match two at a time
02:14:40 <jle`> foo (x:y:zs) = let (xs, ys) = foo zs in (x:xs, y:ys)
02:14:51 <alproxy> Cale: I'm trying that
02:14:59 <jle`> so you just peel off pairs and put them in each list
02:16:01 <koz_> jle`: Thanks - I found a slightly different way.
02:16:02 <jle`> @let pairOff (x:y:zs) = let (xs, ys) = pairOff zs in (x:xs, y:ys); pairOff (x:[]) = ([x],[]); pairOff [] = ([],[])
02:16:05 <lambdabot>  Defined.
02:16:09 <jle`> > pairOff [1..10]
02:16:13 <lambdabot>  ([1,3,5,7,9],[2,4,6,8,10])
02:16:19 <koz_> Now I need to get [a] -> [(a, a)] (just pair off adjacent elements)
02:16:39 <jle`> > (\xs -> zip xs (tail xs)) [1..10]
02:16:43 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
02:17:09 <koz_> jle`: Without overlap on snd and fst of adjacent elements.
02:17:17 <koz_> (I know the list is even-sized)
02:17:26 <jle`> you can use the same pattern as 'pairOff' i wrote earlier
02:17:29 <alproxy> Cale: I am getting this error-
02:17:34 <alproxy>     Could not deduce (Show a) arising from a use of ‘showsPrec’
02:17:36 <alproxy>     from the context (Show (f (Free f a)))
02:17:36 <alproxy>       bound by the instance declaration at Free.hs:5:1-56
02:17:44 <jle`> > uncurry zip (pairOff [1..10])
02:17:47 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
02:17:52 <Cale> Oh, you'll also need that as a constraint...
02:18:12 <jle`> yeah, for the Pure case, heh
02:18:19 <Cale> deriving instance (Show a, Show (f (Free f a))) => Show (Free f a) -- how about this?
02:18:38 <jle`> koz_: you can rewrite the recursive 'pairOff' implementation to put them into one list instead of two lists
02:18:57 <jle`> or zip up the results of the original pairOff ... or use zip xs (tail xs) and drop every other element
02:19:13 <alproxy> oops, you are right. I haven't even read the error
02:19:17 <alproxy> Thanks
02:41:42 <koz_> If I have a function f I'm using as an argument to sortBy, how can I reverse the sort order?
02:42:37 * hackagebot swagger2 2.1 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-2.1 (NickolayKudasov)
02:43:36 <lyxia> flip?
02:44:08 <koz_> So normally, if I call 'sortBy f x', I would get a sorted x from smallest to largest. I need the same, but largest to smallest.
02:44:27 <jul2000>  /leave
02:44:32 <jul2000> crap
02:46:08 <dcoutts> koz_: as lyxia said, flip, so sortBy (flip f) xs
02:46:41 <koz_> dcoutts: That *works*?
02:46:51 <dcoutts> > sortBy (flip compare) [1..10]
02:46:53 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
02:47:07 <dcoutts> > sortBy compare [1..10]
02:47:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
02:47:16 <koz_> ... woah.
02:47:19 <koz_> Thanks!
02:47:49 <dcoutts> koz_: np. If you think it through for a sec you'll see why it works.
02:48:52 <dcoutts> koz_: there's also a Down newtype in the Data.Ord module that's sometimes useful, for expressing the reversed default sort order in the types
02:52:37 * hackagebot intero 0.1.12 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.12 (ChrisDone)
02:53:09 <EvanR> :t getDown
02:53:10 <lambdabot> Not in scope: ‘getDown’
02:53:13 <EvanR> :(
02:53:28 <koz_> EvanR: You need to import Arnold.Schwarzenegger to get that function. :P
02:53:50 <EvanR> newtype ToTheChoppa
02:54:49 <koz_> When I run 'cabal build', does it default to any optimization settings?
02:54:55 <koz_> If not, where do I have to tell it to?
02:56:00 <dcoutts> koz_: yes, -O. And you can change that with -O0 -O2 etc if you want to.
02:56:08 <dcoutts> ie cabal build -O0
02:56:15 <koz_> dcoutts: Thanks!
02:56:36 <koz_> dcoutts: It doesn't seem to like 'cabal build -O2'...
02:57:05 <dcoutts> koz_: oh sorry, it's an arg to configure, not build
02:57:25 * dcoutts is too used to the new-build command in cabal-1.24
02:57:28 <koz_> dcoutts: OK, will try.
02:57:50 <koz_> Well, here goes nothing...
02:57:57 <koz_> This will likely run all night.
02:58:05 <koz_> (assuming something doesn't break first)
02:58:15 * koz_ is such an optimist.
03:00:05 <idev> how do I get pre 8.0.1 haskell platfor?
03:00:07 <idev> I need to install idris
03:01:02 <koz_> Woah, thrashy-thrashy.
03:01:14 <koz_> This bit of Haskell just guzzled 6+G of RAM.
03:02:15 <steshaw> idev: you may be able to get a binary package depending on which platform you're on
03:02:45 <bergmark> idev: it might be easier to use stack than to have two versions of HP active
03:04:29 <idev> how do I install stack ?
03:04:51 <idev> http://docs.haskellstack.org/en/stable/install_and_upgrade/#mac-os-x
03:04:57 <basdirks> I wish to re-install all packages I currently have installed (using stack), to get documentation and profiling. I have enabled both options in my .cabal/config. How do I now make stack re-install all packages?
03:05:08 <idev> okay
03:05:10 <idev> I have stack already
03:05:13 <idev> how do I use stack ot get idris
03:08:36 <hexagoxel> basdirks: have you tried `stack haddock` ? i don't think stack touches ~/.cabal at all.
03:36:42 <fkbm> :q
03:39:20 <idev> stack setup is giving me 7.10.2
03:39:23 <idev> I need 7.10.3
03:39:25 <idev> how do I get 7.10.3 ?
03:44:13 <phadej> idev: use resolver for 7.10.3? i.e. lts-6.0?
03:44:13 <oherrala> idev: lts-6.1 has 7.10.3: https://www.stackage.org/lts-6.1
03:44:25 <phadej> e.g.
03:45:17 <idev> I'm using lts-6.1
03:45:21 <idev> but stack setup is installing 7.10.2
03:46:14 <lemonxah> is there a tool that will create a new empty project setup?
03:46:56 <EvanR> cabal init ?
03:47:09 <lemonxah> thank you
03:47:40 <lemonxah> sorry if my ignorance is offensive :) just staarting out with haskel today 
03:48:05 <idev> okay; so I udpated stack from 0.1.2 to 1.1.2
03:48:11 <idev> and now it appears taht 'stack setup' is installing 7.10.3
03:52:12 <lemonxah> i am busy setting up vim as my ide any other recommendations on which ide should be used?
03:52:28 * hexagoxel notices how the question-mark at the end of an answer is easily read as "doesn't everyone know this" instead of "was this what you wanted to know?"
03:52:47 <EvanR> "actually I'm not sure if this is correct"
03:53:24 <hexagoxel> (it depends on what "project setup" means..)
03:59:27 <lemonxah> when using cabal init i get asked which langauge to craete the package in and there is haskell2010 and haskell98
03:59:40 <lemonxah> i assume the 2010 and 98 is the years?
03:59:46 <lemonxah> so i should be going with 2010 then?
03:59:49 <dcoutts> lemonxah: yes, pick 2010
04:00:28 <lemonxah> thankyou
04:02:05 <idev> 98 is actually 1998
04:02:11 <idev> not 98 AD
04:02:59 * hexhex has been told many times to learn haskell
04:03:02 <hexhex> python ftw
04:03:08 <steshaw> lemonxah: I quite like Atom but I haven't used it for a while
04:04:36 <hexagoxel> lemonxah: it refers to the language specification, see https://www.haskell.org/onlinereport/haskell2010/ (and https://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-4000)
04:04:52 * hexhex wants a bigger haskell at aber uni 4 years ago please
04:26:34 <bwe> Hi, is there a function that calculates 'peak value' (Scheitelwert) of a given list of values? Scheitelwert identifies that value where most values gather (afaik, it's basically output of a density function).
04:27:41 * hackagebot language-puppet 1.2 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.2 (SimonMarechal)
04:29:48 <EvanR> > group . sort $ "mississippi"
04:29:50 <lambdabot>  ["iiii","m","pp","ssss"]
04:30:06 <EvanR> :t sortBy
04:30:08 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
04:30:39 <EvanR> > maximumBy length . group . sort $ "mississippi"
04:30:41 <lambdabot>      Couldn't match type ‘Int’ with ‘[Char] -> Ordering’
04:30:41 <lambdabot>      Expected type: [Char] -> [Char] -> Ordering
04:30:41 <lambdabot>        Actual type: [Char] -> Int
04:30:56 * EvanR goes to sleep
04:35:00 <lemonxah> .
04:44:35 <hexagoxel> > maximumBy (comparing length) . group . sort $ "mississippi"
04:44:37 <lambdabot>  "ssss"
04:57:42 * hackagebot persistent-sqlite 2.5.0.2 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.5.0.2 (MichaelSnoyman)
05:02:51 <s4ke> hi i got a question. how can i "lift" the map function from
05:02:53 <s4ke> :t map
05:02:54 <lambdabot> (a -> b) -> [a] -> [b]
05:03:43 <s4ke> to map :: arr (arr a b, [a]) [b]
05:04:09 <s4ke> :t (arr $ uncurry map)
05:04:11 <lambdabot> Arrow a => a (a1 -> b, [a1]) [b]
05:05:02 <s4ke> the first argument of the arrow now only needs to be an arrow
05:05:28 <s4ke> :t (first $ arr) >>> (arr $ uncurry map)
05:05:30 <lambdabot> (a -> b, [a]) -> [b]
05:07:42 * hackagebot hlwm 0.1.0.2 - Bindings to the herbstluftwm window manager  https://hackage.haskell.org/package/hlwm-0.1.0.2 (hpdeifel)
05:09:58 <s4ke> welp got it
05:10:17 <s4ke> :t (arr $ uncurry (\arrs arr -> map (>>> arr) arrs)
05:10:18 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
05:10:28 <s4ke>  :t (arr $ uncurry (\arrs arr -> map (>>> arr) arrs))
05:10:45 <s4ke> :t (arr $ uncurry (\arrs arr -> map (>>> arr) arrs))
05:10:47 <lambdabot> forall (k :: BOX) (a :: * -> * -> *) (cat :: k -> k -> *) (a1 :: k) (b :: k) (c :: k). (Arrow a, Category cat) => a ([cat a1 b], cat b c) [cat a1 c]
05:11:10 <xa0> that's terrifying
05:11:21 <s4ke> xa0 why?
05:11:37 <xa0> just an unpleasant looking typesig
05:11:50 <hpc> it also still looks wrong i think
05:11:56 <Xnuk> :t (>>>_
05:11:58 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
05:11:59 <Xnuk> :t (>>>)
05:12:00 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
05:12:24 <s4ke> ok lambdabot just messes
05:12:26 <s4ke> maybE?
05:12:31 <s4ke> ghci is kinder
05:12:47 <s4ke> ah no :D
05:13:14 <s4ke> :t (arr $ uncurry (\arrs arr -> map (>>> arr) arrs))
05:13:15 <lambdabot> forall (k :: BOX) (a :: * -> * -> *) (cat :: k -> k -> *) (a1 :: k) (b :: k) (c :: k). (Arrow a, Category cat) => a ([cat a1 b], cat b c) [cat a1 c]
05:14:51 <s4ke> ah damn it cat and a must be the same...
05:17:10 <s4ke> nvm. ghc takes it :)
05:18:04 <Xnuk> :t \(gs, f) -> map (. f) gs
05:18:06 <lambdabot> ([b -> c], a -> b) -> [a -> c]
05:18:27 <s4ke> but i specifically need arrows
05:29:23 <lemonxah> has anyone used intelliJ for haskell?
05:29:31 <s4ke> i am using it
05:29:38 <lemonxah> haskforce?
05:29:48 <s4ke> uhm just the default plugin
05:31:41 <lemonxah> haven't used vim in a long time although it looks good and atom is meh
05:31:57 <lemonxah> i use intellij for scala stuff so i thought of trying it for haskell
05:32:09 <lemonxah> s4ke, how is your experience with it?
05:32:16 <s4ke> i switched to intellij from atom
05:32:30 <s4ke> it has some flaws, but for now they dont annoy me too much as i ship around them
05:33:35 <s4ke> it has basic syntax highlighting, some (!) autocomplete and helps me with compiler errors, but they are for some reason just popus that go away as soon as you move your mouse
05:33:43 <s4ke> but i just copy paste the message into notepad :d
05:35:28 <maerwald> wow, hdevtools depends on a non-existent package?
05:36:43 <maerwald> https://github.com/hdevtools/hdevtools/issues/20 meh
05:36:54 <zinking> let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) problem_2' = sum [ x | x <- takeWhile (<= 1000000) fibs, even x] can fibs be declared as a separate function other than in where ?
05:37:37 <bennofs> fibs = 1 : 1 : zipWith (+) fibs (tail fibs) works at the top-level
05:38:16 <zinking> yeah, then why it can't be used in problem_2' ?
05:38:33 <ski> zinking : yes, except `fibs' is not a function (it's a list)
05:39:23 <zinking>  -- /var/tmp/ex1.hs:7:1: parse error (possibly incorrect indentation or mismatched brackets) Compilation failed.
05:39:35 <ski> @paste
05:39:35 <lambdabot> Haskell pastebin: http://lpaste.net/
05:47:44 * hackagebot hw-rankselect 0.0.0.5 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.0.0.5 (haskellworks)
05:51:35 <doubling> hasketball
05:51:53 <deni> does anybody know how to compile a snap project in development mode so that I get dynamic reloading on file change?
05:52:01 <deni> (using stack)
05:52:22 <deni> I tried doing stack build --flag snap:development but it doesn't work
05:52:44 * hackagebot intero 0.1.13 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.13 (ChrisDone)
05:57:44 * hackagebot servant-swagger 1.1 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.1 (phadej)
06:00:52 <nitrix> deni: There's a few of them. e.g. http://hackage.haskell.org/package/snap-loader-dynamic-0.10.0.4
06:01:36 <nitrix> Snap itself doesn't seem to have a flag for that. Only `old-base` is listed.
06:58:45 <dfeuer> Woohoo!
06:59:55 <quchen> dfeuer: ?
07:00:14 <dfeuer> Yeah, making Data.Sequence.adjust more eager (although keeping in just as non-strict!) seems to be a big performance win.
07:00:28 <dfeuer> When many adjustments are performed in a row, anyway.
07:00:41 <dfeuer> Obviously not *always*
07:00:43 <quchen> Ah, Data.Sequence. The cool module I've always been avoiding for no good reason.
07:00:54 <quchen> Maybe because finger trees are black magic.
07:01:05 <dfeuer> quchen, well, if you ask Ed Kmett, it's just too slow for practical work.
07:01:10 <quchen> Learning about them just pushes the "what the - no this must be magic" moment further back.
07:01:12 <dfeuer> But it's fun.
07:01:20 <quchen> Oh, is it?
07:01:25 <dfeuer> *shrug*
07:01:35 <hpc> finger trees are bite-sized for your enjoyment
07:02:13 <dfeuer> Data.Sequence is not the most space-efficient, and there's a lot of pointer chasing.
07:03:19 <dfeuer> But it has some really fun bits. quchen, if you want your mind blown, look at inits and tails (by Wasserman). I like to think my own <*> and *> are pretty nifty too.
07:04:02 <dfeuer> I just added insertAt and deleteAt, which are horrible slogs.
07:07:21 <Akii> http://stackoverflow.com/questions/28906742/how-do-inits-and-tails-work-in-data-sequence
07:07:24 <Akii> this?
07:07:38 <dfeuer> Akii, yeah, that was my question.
07:12:47 * hackagebot servant-swagger-ui 0.1.0.2.1.4 - Servant swagger ui  https://hackage.haskell.org/package/servant-swagger-ui-0.1.0.2.1.4 (phadej)
07:15:56 <contiver> How frequently is Scientific used? I read in the Haskell book that it is faster than Rational, but learning that some operations can diverge stopped me from using it.
07:16:23 <Aruro> contiver: which haskell book you read?
07:17:08 <contiver> Aruro: The one I'm referring to is Haskell programming from first principle 
07:18:17 <pavonia> I've only seen it being used once, in the aeson package
07:18:19 <Aruro> contiver: i see, well. All haskell numeric types are complicated, there is also CReal and continued fractions
07:18:33 <hpc> if you need both speed and precision, and it turns out to actually perform as required, just be careful when using it
07:18:37 <hpc> or use CReal or something, yeah
07:19:02 <Aruro> contiver: best haskell numeric type is Integer
07:20:32 <contiver> well, I'm fine with Rational for the moment. Just found the concept of Scientific interesting and wanted to give it a try, but really disliked that issue, because it's completely random, you don't know when you might do something like 1/3 and have your program halt.
07:20:32 <hpc> imo you should stick with Rational, as it's going to be more consistent
07:21:22 <hpc> if you need the computable reals (which is a superset of rational numbers), Scientific is completely unsuitable anyway
07:21:33 <pavonia> > pi :: Rational
07:21:35 <lambdabot>      No instance for (Floating Rational) arising from a use of ‘pi’
07:21:35 <lambdabot>      In the expression: pi :: Rational
07:21:42 <hpc> > pi :: CReal
07:21:45 <lambdabot>  3.1415926535897932384626433832795028841972
07:22:02 <hpc> don't let the number of digits fool you, that's an exact representation of pi
07:22:35 <contiver> hpc: exact? interesting. 
07:23:11 <hpc> one of my insane impossible goals is to be able to read the source for CReal and understand it
07:23:25 <simpson> Isn't it just a continued fraction
07:24:03 <hpc> it is, but in a very continuation-heavy way
07:24:04 <simpson> Ah, no, it's a "fast binary Cauchy sequence".
07:24:09 <hpc> or something like that
07:26:09 <simpson> > sqrt 8 * sqrt 8 :: CReal
07:26:11 <lambdabot>  8.0
07:26:17 <hpc> data CReal = CR (Int -> Integer)
07:26:53 <Aruro> contiver: scientifically most advanced haskell number types are CReal and continued fractions from cf package.
07:27:46 <Aruro> contiver: but if u look they are good old Integer :)
07:28:27 <hpc>   (CR x') + (CR y') = CR (\p -> round_uk ((x' (p+2) + y' (p+2)) % 4)) -- just a taste of the math going on internally
07:29:04 <hpc> it's not something you can just sit there and read, i just need to catch up on a smidge of math first
07:29:13 <Aruro> hpc: math there is rather boring actually, its just increasing precision
07:30:26 <simpson> It certainly is not as cool as continued fractions. But it appears to have fewer weird corner cases.
07:31:12 <hpc> not sure what weird corner cases continued fractions have, but i have certainly never been surprised by CReal's behavior
07:31:22 <hpc> everything that logically makes sense to be computable is
07:31:43 <hpc> things like 0/0 are non-terminating, but whatever
07:31:53 <hpc> > 0/0 :: CReal
07:31:57 <lambdabot>  mueval-core: Time limit exceeded
07:37:48 * hackagebot phantom-state 0.2.1.1 - Phantom State Transformer. Like State Monad, but without values.  https://hackage.haskell.org/package/phantom-state-0.2.1.1 (DanielDiaz)
07:47:33 <bernalex> howto -Wall by default in ghc-mod in emacs?
07:47:54 <bernalex> also, howto pointfree/pointful suggestions+refactoring in emacs?
07:52:34 <bwe> So, I want to create (1) density of list of values, then (2) identify max. density and (3) trace it back to corresponding 'peak value' (Scheitelwert): Example: http://imgur.com/XONdvHG would be ~50.
07:52:49 * hackagebot Delta-Lambda 0.1.0.0 - A demonstration interpreter for type system delta-lambda (of N.G. De-bruijn)  https://hackage.haskell.org/package/Delta-Lambda-0.1.0.0 (listofoptions)
07:52:51 * hackagebot extract-dependencies 0.2.0.1 - Given a hackage package outputs the list of its dependencies.  https://hackage.haskell.org/package/extract-dependencies-0.2.0.1 (yamadapc)
07:53:18 <bwe> Which packages should I consult for my endeavour?
07:57:49 * hackagebot stack-run-auto 0.1.1.2 - Initial project template from stack  https://hackage.haskell.org/package/stack-run-auto-0.1.1.2 (yamadapc)
08:02:50 * hackagebot delude 0.1.0.0 - Generalized the Prelude more functionally.  https://hackage.haskell.org/package/delude-0.1.0.0 (sgschlesinger)
08:03:30 <maerwald> how many alternative preludes do we have now? 200?
08:04:04 <hpc> mine is the best
08:06:03 <jacco> how do I pass a flag to a dependency when doing cabal build? Or do I just have to seperately install the dependency first with its flag?
08:10:59 <maerwald> jacco: flags should actually not impact the interface. It sounds like that's the case here
08:11:39 <maerwald> afair you can set that in the cabal config though
08:11:57 <maerwald> https://stackoverflow.com/questions/23523869/is-there-any-way-to-define-flags-for-cabal-dependencies
08:12:50 * hackagebot HaTeX 3.17.0.2 - The Haskell LaTeX library.  https://hackage.haskell.org/package/HaTeX-3.17.0.2 (DanielDiaz)
08:17:50 * hackagebot binary-list 1.1.1.1 - Lists of length a power of two.  https://hackage.haskell.org/package/binary-list-1.1.1.1 (DanielDiaz)
08:18:54 <shapr> wow, lambdabot is now an official debian package!
08:19:26 <maerwald> so?
08:20:15 <shapr> maerwald: Pseudonym hacked up lambdabot as a quick hack, I wrote the plugin system, it's amazing to see what was a tiny project now have official debian package.
08:20:50 <maerwald> not sure what's so great about being included in debian, but yeah
08:22:09 <AlainODea> maerwald: it means anyone with Debian or Debian-derivatives (ex: Ubuntu) can install without jumping thru hoops
08:22:36 <maerwald> I think they are better off using cabal or stack.
08:24:06 <AlainODea> it depends. I almost 100% agree. For a simple chat server with lamdabot a package simplifies and accelearates provisioning if you're automating it
08:24:45 <deni> nitrix: I'm already using that it seems....as part of snap..because i use loadSnapTH
08:24:48 <AlainODea> although stack works well there too, you need to pay the build cost in memory and CPU which may mean breaking from free tier
08:24:56 <deni> nitrix: but it's not working
08:25:23 <deni> it says in the comments from the scafollding that I need to compile the thing with the development flag but when I do it doesn't work
08:25:46 <lambda-11235> To be honest cabal and stack should have an uninstall option if you want to use it as a package manager.
08:27:16 <dfeuer> Hi conal! I just came across your "checkers" package, and it looks pretty darn cool.
08:27:40 <conal> dfeuer: thanks!
08:28:07 <dfeuer> Speaking of which, am I correct in thinking that PropertyM Identity can work much like the Maybe monad, but with more informative test failure messages?
08:28:59 <dfeuer> That is, if I want to try to produce a value to use later in a test, but if that value is no good, I get a nice message?
08:29:13 <categoryTheoreti> I'm trouble with a typeclass and some methods.  I have a data type Backend which can be = a | b.  I'm trying to make a typeclass "foo (backend::Backend)" whose instances would be 'foo a' and 'foo b' each of which has backend specific methods matching the signitures in the typeclass.  However, I get complaints that the method signitures don't contain the Backend kind variable.  But then I wouldn
08:29:13 <categoryTheoreti> 't have thought they needed to since the instances do.  
08:29:18 <conal> dfeuer: i don't remember PropertyM
08:29:26 <categoryTheoreti> Sorry for the wall of text
08:29:56 <dfeuer> categoryTheoreti, link to code. That's awfully vague.
08:35:59 <categoryTheoreti> Ok, I have a problem with instances of a typeclass here: https://gist.github.com/anonymous/2b97c9aafccbbb619be750c5ca270019
08:36:04 <categoryTheoreti> I wonder if anyone could advise?
08:36:21 <categoryTheoreti> Sorry for spam earlier
08:37:39 <dfeuer> categoryTheoreti, yeah.
08:37:43 <dfeuer> There's definitely a problem.
08:38:19 <dfeuer> The type variables in your class heading must *all* appear in *each* class method signature.
08:38:44 <dfeuer> As it is, GHC has absolutely no way to ever determine which instance to use.
08:39:11 <dfeuer> One option would be to use something like  runAccVector :: proxy backend -> ACCVector n a -> SVector n a
08:39:39 <categoryTheoreti> Ok, would I keep the the backend types in the instance declaration?
08:39:40 <dfeuer> And then call it with, e.g.,  runAccVector (Proxy :: Proxy Interpreter) ....
08:40:18 <dfeuer> All that would change would be that you'd add an extra proxy argument to each method.
08:40:25 <categoryTheoreti> ah, ok
08:40:30 <deni> anyone else uses stack with snap and knows how to get it to run in development (autoreload) mode?
08:40:57 <dfeuer> In GHC 8, you can use explicit type application instead, but I haven't touched that yet and it won't work for any earlier versions and it kind of scares me.
08:43:00 <categoryTheoreti> Am I right in thinking that there's no reason to have multiple instances of the typeclass then if the method iteself is only ever going to evaluate the proxy argument?
08:47:52 * hackagebot TypeCompose 0.9.12 - Type composition classes & instances  https://hackage.haskell.org/package/TypeCompose-0.9.12 (ConalElliott)
08:57:39 <deni> while I'm on the subject of heist can someone tell me why the first submitText tag get's rendered and the second one get's rendered as text "${submitText}"   (last 2 lines here): http://dpaste.com/3VAW1T8
08:59:50 <deni> ah nevermind....it's ${tag} vs <tag/> silly me
09:15:29 <erisco> it would be nice to write  s s z  rather than   s (s z)
09:16:08 <TheMystic> erisco: you can also write: s $ s z
09:17:49 <dfeuer> $ has the wrong fixity, according to Cale. And Cale is pretty much always right.
09:19:56 <shapr> dfeuer: what fixity should it have?
09:20:31 <mauke> it should associate to the left
09:20:40 <ZelteHonor> I have the same question as this one on SO but is there any place to read for more information? Is there more than these 3 types that uses ARR_WORDS? : http://stackoverflow.com/questions/7241470/what-is-arr-words-in-a-ghc-heap-profile
09:20:52 <c_wraith> ugh. spammers found lpaste.net (probably not the first time) 
09:21:18 <shapr> c_wraith: require them to do a bit of haskell eval to put up a paste?
09:21:39 <c_wraith> that would prevent beginner questions 
09:21:50 <erisco> would be nice if lens didn't take all the _number names… 
09:21:51 * erisco steals
09:26:45 <jdreaver> I'm trying to use attoparsec to parse postgres log prefixes. I've run into a problem where I need to parse something similar to the following regex: "(.+):". That is "at least one of any char followed by a colon." 
09:27:04 <jdreaver> Is there an efficient way to do this in attoparsec? I've tried this:
09:27:04 <jdreaver> parseOnly (many1 anyChar >> char ':') "hello:"
09:27:17 <jdreaver> But, that doesn't work because "many1 anyChar" eats the colon
09:28:53 <mauke> why not ([^:]+): ?
09:28:57 <opqdonut> jdreaver: many1 (notInClass ":")
09:29:01 <opqdonut> i.e. what mauke said
09:29:25 <erisco> I vaguely recall something about brackets which use Applicative, so if you write  [| f x y z |]  this becomes  [| f <$> x <*> y <*> z |]  or some such
09:29:33 <erisco> anyone know what I'm thinking of?
09:29:40 <opqdonut> jdreaver: you can also try takeTill
09:29:55 <jdreaver> I need to include colons in the match though. For example, this should parse "he:llo:"
09:30:31 <opqdonut> oh
09:30:32 <shapr> jdreaver: can you change anyChar to not have a colon?
09:30:55 <jdreaver> In general, you can make your postgres log prefix whatever you want, so I'm trying to solve the general problem of parsing just enough without eating too much.
09:31:00 <tsahyt> If I have two different elements of state in one computation, what would be the best way to separate them? I'd prefer to write functions that take the part of the state they operate on as a constraint
09:31:00 <mauke> (.(?:[^:]*:)*[^:]*):
09:31:02 <jdreaver> shapr: No I can't :/
09:31:10 <tsahyt> should I just wrap two StateTs?
09:31:26 <hpc> is that a regex or @pl output?
09:31:31 <jdreaver> Obviously I could solve this with regexes, but I just wanted to know if it's possible in atttoparsec :)
09:31:53 <shapr> jdreaver: so there could be a colon in the content, and it would still have to end with a colon?
09:32:05 <jdreaver> Yes shapr
09:32:27 <tsahyt> i.e. I suppose I want a type that is an instance of MonadState StateA and MonadState StateB
09:32:35 <tsahyt> instead of having MonadState CombinedState or something
09:33:00 <jdreaver> I just gave a specific example of "(.*):", but prefix strings are often larger and would need a regex like this:
09:33:19 <opqdonut> tsahyt: well you can use StateT CombinedState and then write the MonadState State* instances yourself
09:33:29 <jdreaver> "(.+):(.+)\[([0-9+])\] (.+) ..." etc
09:33:41 <tsahyt> opqdonut: I've just been thinking about that. How much boilerplate code am I looking at roughly?
09:33:51 <tsahyt> ah wait, almost nothing really
09:34:01 <opqdonut> tsahyt: yeah, get and put
09:34:06 <Xandaros> In my attoparsec parser, how can this fail with “Left "Rule > Sum: Failed reading: nope"” instead of erroring with “guhegh”: http://tcp.mniip.com/nvgi ?
09:34:10 <jdreaver> So multiple matches of any char followed by whatever separators the user put in there. The problem is we really do need something like "anyChar"
09:34:19 <tsahyt> which I can implement in terms of the get and put that's already there. great, that'll do I think
09:35:34 <opqdonut> tsahyt: you need a combinator like: manyThen x end = choice [manyThen x end, end]
09:35:48 <opqdonut> tsahyt: (+ accumulating the results, obviously)
09:35:55 <opqdonut> tsahyt: but I have no idea how efficient that will be
09:35:59 <tsahyt> opqdonut: I don't think that was meant for me
09:36:04 <opqdonut> oops
09:36:08 <opqdonut> yeah
09:36:19 <jdreaver> In lieu of solving this in attoparsec though: what is the fastest Haskell regex lib for regexes with a lot of ".+" in them? I'm thinking of just starting with regex-pcre-builtin.
09:36:25 <opqdonut> jdreaver: what I addressed to tsahyt above was meant to you
09:36:28 <Xandaros> opqdonut: That list is in infinite type, is it not?
09:36:29 <jdreaver> Ah, thanks!
09:37:02 <hpc> jdreaver: depends on what you're going to be doing with the regex
09:37:11 <hpc> jdreaver: not every regex library supports substitution, for instance
09:37:20 <opqdonut> Xandaros: yeah that was just a sketch
09:37:22 <jdreaver> hpc: Just extracting matching groups, non-recursively too
09:37:46 <hpc> and honestly, none of them is particularly good
09:38:05 <hpc> it might just be that i am spoiled by perl, but trying anything with them is just awful
09:38:31 <jdreaver> That sucks. We are spoiled by our great parser combinator libs! haha
09:38:37 <Xandaros> @remember hpc it might just be that i am spoiled by perl
09:38:37 <lambdabot> It is forever etched in my memory.
09:42:06 <mauke> a regex with .+ in it is basically a bug
09:42:54 * hackagebot Clipboard 2.3.0.0 - System clipboard interface.  https://hackage.haskell.org/package/Clipboard-2.3.0.0 (DanielDiaz)
09:43:37 <Xandaros> About my attoparsec question: I seem to be getting a different error if I replace foldr with foldl. What is going on? :(
09:46:38 <opqdonut> jdreaver: https://gist.github.com/opqdonut/8e17f2d86ff3533f08b10800e9681944 I got it to work
09:48:24 <tsahyt> opqdonut: Turns out that I can't declare the two instances because of the functional dependency MonadState s m | m -> s
09:48:55 <tsahyt> not when using mtl anyhow
09:50:07 <opqdonut> tsahyt: .... right!
09:50:31 <tsahyt> that's most unfortunate :/
09:51:54 <hpc> to be fair, that fundep is what makes type inference on MonadState operations not a living hell
09:52:36 <tsahyt> yeah I understand why it's there but I still need some way to work with multiple pieces of state at the same time while ideally keeping them separate
09:52:40 <hpc> and i like knowing any given type only has one state you can manipulate inside it
09:52:54 * hackagebot Clipboard 2.3.0.1 - System clipboard interface.  https://hackage.haskell.org/package/Clipboard-2.3.0.1 (DanielDiaz)
09:53:09 <hpc> can you use a tuple and something like modify . first?
09:53:12 <hpc> :t modify . first
09:53:14 <lambdabot> MonadState (c, d) m => (c -> c) -> m ()
09:53:20 <hpc> :t modify . second
09:53:21 <lambdabot> MonadState (d, c) m => (c -> c) -> m ()
09:53:52 <tsahyt> that's isomorphic to what I'm doing now
09:54:00 <hpc> ah, fair enough then ;)
09:54:10 <tsahyt> but it's somewhat unsatisfying
09:54:40 <tsahyt> for example say you have a symbol table and whatever other stuff you need, and I'd like to write a function that operates *just* on the symbol table
09:54:46 <tsahyt> i.e. that is guaranteed to operate just on the symbol table
09:55:05 <tsahyt> how would I express this kind of contraint?
09:56:13 <hpc> the naive way would be to just make more types to express operations that only do one thing
09:56:17 <tsahyt> I was thinking that I could write a typeclass HasSymbolTable of which the product type of state pieces is an instance, and then I could use HasSymbolTable s, MonadState s => ...
09:56:32 <tsahyt> hpc: for example?
09:56:32 <hpc> and give them very limited apis that you can access from the context of being able to manipulate everything
09:56:46 <hpc> a rather tangental example is acid-state's Update and Query types
09:57:43 <hpc> Query has a MonadReader instance for accessing state values and whatnot
09:57:53 <hpc> Update has the exact same MonadReader instance, but also MonadState
09:58:33 <hpc> they have a limited api in the form of some operations that live in IO for applying those actions to a particular state
09:58:59 <hpc> you might actually be able to run query actions without being in IO, i don't remember
09:59:07 <hpc> but basically something like that
09:59:25 <hpc> write some basic thing that only admits operations you want on one part of your state
09:59:28 <hpc> ditto the other parts
09:59:44 <hpc> make them only have runFoo :: Foo a -> Bar a or whatever
10:00:13 <tsahyt> that might actually be an option
10:00:20 <hpc> more generally, this technique is called embedded domain specific languages, or eDSLs
10:01:16 <hpc> i call it the naive way because you can somewhat abstract over your specific case with indexed monads or something more mathematically intense like that
10:01:27 <tsahyt> so for example I'd have some monad for symbol table manipulation, build whatever action I want in that, and have some run :: MonadState BigState m => SmallStateAction a -> m a
10:01:40 <hpc> but i like this better for the simplicity of being "just" writing types and apis
10:01:46 <hpc> yep
10:02:21 <tsahyt> I think this might have more static guarantees than the typeclass thing I thought of earlier too
10:03:30 <ggVGc> I just made a small eDSL for composing modes in my program, where each function is just AppMode -> AppMode, and there's one function runModes :: [AppMode] -> AppMode -> AppMode, which takes a list of modes to chain, and a default mode to fall back on if none of them handled input
10:03:35 <ggVGc> it's working super well so far
10:03:46 <tsahyt> in particular I think it's easy to pass the other part of the state as read-only that way
10:03:57 <tsahyt> which I need anyhow
10:04:43 <ggVGc> hpc: why runFoo :: Foo a -> Bar a, rather than Foo -> Foo?
10:04:50 <ggVGc> Foo a -> Bar a doesn't seem as composable
10:04:55 <jdreaver> oqdonut: I just saw your gist, thanks for your help! I'll see if I can get this to work in general.
10:05:10 <jdreaver> Sorry, opqdonut
10:05:17 <tsahyt> ggVGc: Because sooner or later I'll have to execute the stateful code on one part of the state to apply the changes on the whole state
10:05:43 <opqdonut> jdreaver: cheers
10:07:04 <hpc> ggVGc: you'd have different operators for composing Foo values
10:07:15 <hpc> ggVGc: perhaps Foo a -> (a -> Foo b) -> Foo b
10:07:16 <hpc> ;)
10:07:46 <ggVGc> that looks familiar!
10:07:49 <ggVGc> :)
10:10:41 <deni> can anyone tell me what this error in runtime means: unable to load package `cipher-aes-0.2.11' ?
10:10:47 <deni> Am I missing some shared libraries on the system?
10:11:02 <hpc> at runtime? what are you running and how?
10:11:33 <ggVGc> that looks like a ghc error to me
10:12:53 <deni> ggVGc: it is yes
10:13:16 <deni> ggVGc: http://dpaste.com/31QXZAY
10:13:25 <deni> I'm not sure what that menas
10:13:27 <deni> *means
10:13:33 <ggVGc> me neither
10:13:36 <ggVGc> that looks realy strange
10:14:10 <deni> the process just hangs... I can only kill it with kill -9
10:14:33 <deni> this happens with the default snap init scafollding built using stack lts-5.18
10:17:21 <mizu_no_oto_work> deni: Have you done anything to the scaffolding?
10:17:39 <mizu_no_oto_work> Or does it just start out in a broken state?
10:19:22 <nitrix> Is it conceivable for a language to use only product types?
10:22:50 <bennofs> nitrix: well, C mostly only has product types (enums are basically just constants)
10:23:02 <deni> mizu_no_oto_work: other than doing stack init and adding stuff to extra-deps no
10:23:23 <nitrix> bennofs: How would you implement a sum type using only product types?
10:23:44 <mizu_no_oto_work> deni: what deps did you add?
10:24:03 <bennofs> nitrix: you don't. you merge all the fields of the sum types into one type and have a tag to decide between which of those fields are valid
10:24:29 <mizu_no_oto_work> nitrix: there's also church encodings
10:24:59 <mizu_no_oto_work> i.e. Either a b is isomorphic to (a -> r) -> (b -> r) -> r
10:25:00 <nitrix> Oh ture.
10:25:47 <nitrix> That's actually a very clever way to think of it.
10:25:54 <nitrix> mizu_no_oto_work: Appreciated.
10:26:19 <mizu_no_oto_work> no problem
10:26:30 <bennofs> well by that reason, you don't even need product types, since (a,b) is isomorphic to (a -> b -> r) -> r
10:27:00 <mizu_no_oto_work> Well, you don't...
10:27:17 <mizu_no_oto_work> They're mighty useful, though
10:27:35 <mizu_no_oto_work> Church encodings are a bit of a turing tarpit
10:27:52 <hpc> a lambda lagoon, if you will
10:27:55 * hackagebot minilens 1.0.0.2 - A minimalistic lens library, providing only the simplest, most basic lens functionality.  https://hackage.haskell.org/package/minilens-1.0.0.2 (RaminHonary)
10:27:57 * hackagebot rose-trie 1.0.0.2 - Provides "Data.Tree.RoseTrie": trees with polymorphic paths to nodes, combining  properties of Rose Tree data structures and Trie data structures.  https://hackage.haskell.org/package/rose-trie-1.0.0.2 (RaminHonary)
10:27:59 * hackagebot inf-interval 0.1.0.2 - Non-contiguous interval data types with potentially infinite ranges.  https://hackage.haskell.org/package/inf-interval-0.1.0.2 (RaminHonary)
10:28:25 <deni> mizu_no_oto_work: http://dpaste.com/1QZH932
10:29:11 <nitrix> mizu_no_oto_work: I'm aware. It's still good for reasoning while a less practical abstraction.
10:30:12 <mizu_no_oto_work> They're also useful when you don't want to use an ADT for whatever reason but don't mind using functions
10:31:02 <mizu_no_oto_work> For example, if you're working with the FFI in Purescript, church encodings are easier to interoperate with than ADTs
10:31:32 <hpc> sometimes you're put in a situation where you can't use an ADT (or at least not easily)
10:31:38 <hpc> like with higher-ranked types
10:32:11 <deni> mizu_no_oto_work: there's also this: .stack/snapshots/x86_64-linux/lts-6.1/7.10.3/lib/x86_64-linux-ghc-7.10.3/cipher-aes-0.2.11-LCbQiUgBdfG1swKGFESvIB/libHScipher-aes-0.2.11-LCbQiUgBdfG1swKGFESvIB.a: unhandled ELF relocation(RelA) type 42
10:33:02 <deni> cipher-aes seems to be deprecatad in favor of cryptonite hmm
10:33:22 <hpc> what a great name for a library
10:35:13 <deni> mizu_no_oto_work: could itbe that it's just falling back to the C implementation and I don't have the library installed?
10:37:07 <bennofs> deni: is this using yesod?
10:37:28 <bennofs> oh it's snap
10:37:41 <mizu_no_oto_work> deni: could be
10:39:21 <bennofs> perhaps it has to do with some sort of live-reload functionality where the code is recompiled on the fly?
10:40:28 <deni> bennofs: snap
10:40:47 <deni> bennofs: it does.... infact this only happens when I enable dynamic reload
10:41:25 <bennofs> deni: can you try running the server with stack exec -- command/to/run/server ?
10:41:26 <deni> bennofs: so when I compile the default scaffoling with -fdevelopment
10:42:02 <deni> this make is so that snap-loader-dynamic is installed and imported in Main.hs to enable live reloading
10:42:28 <deni> bennofs: I don't know enough about how this stuff works to even guess as to what the problem is
10:44:00 <bennofs> deni: yeah, can you try using stack exec -- command/to/run/server? (like stack exec -- dist/build/<some name>/<some name>, where I don't know what <some name> is, depends on your project name I guess)
10:44:30 <bennofs> or well, perhaps not dist/build/... if you're using stack, not too familar with it
11:00:42 <adam1> whats the difference between a lens and a cursor?
11:01:11 <erisco> can you define type families inductively on naturals? (yes, you can define your own Peano naturals and promote them, but is there anything predefined?)
11:01:30 <erisco> particularly it would be nice to use literals such as "3" instead of "S (S (S Z)))"
11:01:33 <adam1> based on what I have been reading it seems like the both take some larger context and allow you to focus on just the part that you care about manipulating it as if it was the only context that exists
11:02:20 <adam1> and both of them seem to rely on creating some kind of path that allows you to navigate through the context into the part you care about, as well as having a function that then gets/sets it once you are there
11:05:31 <bennofs> what is a cursor
11:07:25 <erisco> a zipper? *shrug*
11:07:30 <adam1> here is one example of them being used in OM which is a clojurescript library: https://github.com/omcljs/om/wiki/Cursors
11:08:20 <adam1> here it is for reagent http://blog.ducky.io/reagent-docs/0.6.0-alpha2/reagent.core.html#var-cursor
11:09:12 <erisco> :info Proxy
11:09:27 <erisco> where does Proxy come from
11:11:06 <bennofs> erisco: Data.Proxy on newer GHC (>= 7.10 i believe)
11:11:25 <bennofs> erisco: otherwise, Data.Proxy from the tagged package
11:11:31 <erisco> thanks
11:12:30 <erisco> > natVal (Proxy :: Proxy 3)
11:12:32 <lambdabot>  Not in scope: ‘natVal’
11:15:26 <erisco> well damn D: you can't recurse on these (towards zero)
11:19:21 <erisco> I guess you can alias… type N0 = Z, type N1 = S N0, type N2 = S N1…
11:27:58 * hackagebot telegram-api 0.4.3.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.4.3.0 (klappvisor)
11:31:57 <erisco> would be cool if you could pass type arguments like value arguments
11:32:08 <erisco> so you didn't need to define proxy wrappers
11:32:58 * hackagebot octane 0.5.5 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.5 (fozworth)
11:41:09 <jle`> erisco: not sure if you were referencing this, but you can do that with ghc 8 :)
11:41:21 <erisco> can you? how is that done with 8?
11:42:06 <jle`> well, for things with results that don't have the type in the result, you'll still need a proxy
11:42:29 <jle`> but you can do `natVal (Proxy @3)`
11:42:50 <erisco> ah, cool
11:42:55 <jle`> or natVal @3 undefined, i suppose
11:43:00 <erisco> so I can  Proxy @N1  maybe
11:43:01 <jle`> natVal @3 Proxy
11:43:17 <erisco> parse error D:
11:43:24 <jle`> > natVal @3 Proxy
11:43:26 <lambdabot>  Pattern syntax in expression context: natVal@3
11:43:41 <jle`> looks like lambdabot isn't on ghc 8 yet, or has TypeApplications off
11:44:00 <int-e> it's not on ghc 8 yet
11:44:28 <jle`> mystery solved
11:47:59 * hackagebot scrape-changes 0.1.0.1 - Scrape websites for changes  https://hackage.haskell.org/package/scrape-changes-0.1.0.1 (2chilled)
12:13:46 <erisco> TypeApplications is great! it would be nice if there was an implicit default type for kinds though, maybe
12:14:14 <erisco> or some other change where you didn't need proxy (it is noisy)
12:15:03 <erisco> say you could have function signatures which accepted type arguments, and then you used TypeApplications to supply them
12:15:08 <erisco> these arguments would not be constrained to *
12:17:33 <erisco> ohh, I misunderstood!
12:17:47 <erisco> wonder how it defines the argument order… *erisco reads*
12:18:30 <erisco> left-to-right "as appearing in the foralls"
12:18:48 <erisco> well this is superb :D
12:18:56 <erisco> so you don't need a * at all
12:19:07 <erisco> Proxy gets the boot
12:23:59 <erisco> type families cannot introduce type variables on the right hmmmmm
12:24:15 <erisco> (fair)
12:24:40 <Sinestro> I'm trying to 'get' GHC.TypeLits, and I can't figure out what on earth the point of SomeNat/SomeSymbol is. I mean, I get that it's required so that functions can convert Integers into Nat-things, but... A way to refer to a type level value without knowing what the value is during typechecking, just what I always wanted!
12:30:01 <c_wraith> Sinestro, the point is that the existentials pack the class dictionary in, too. 
12:31:07 <c_wraith> Sinestro, so when you unpack SomeNat, you get the KnownNat constraint, too. 
12:32:40 <c_wraith> Sinestro, https://stackoverflow.com/questions/30752653/can-i-have-an-unknown-knownnat/30762622#30762622 has an example of using that. 
12:33:00 * hackagebot partial-handler 1.0.1 - A composable exception handler  https://hackage.haskell.org/package/partial-handler-1.0.1 (NikitaVolkov)
12:33:09 <Sinestro> Guess what Stack Overflow question I found with Google 30 seconds after I realized that I was being dumb
12:33:11 <Sinestro> haha
12:33:37 <c_wraith> Sinestro, the main point is that you get a way to use things that rely on types, without knowing the type at compile time 
12:33:43 <Sinestro> I get it
12:34:25 <Sinestro> I think I get it now, I was having a reading problem where for some reason the proxy part of SomeNat disappeared in my brain, so I was getting code that obviously didn't type check and going 'What?'
12:38:54 <c_wraith> someNatVal is actually incredibly dirty, internally. but it has a safe interface! 
12:43:01 * hackagebot slave-thread 1.0.1.1 - A principal solution to ghost threads and silent exceptions  https://hackage.haskell.org/package/slave-thread-1.0.1.1 (NikitaVolkov)
12:53:01 * hackagebot biohazard 0.6.6 - bioinformatics support library  https://hackage.haskell.org/package/biohazard-0.6.6 (ustenzel)
13:27:02 <erisco> can ScopedTypeVariables scope from an instance head to a member definition?
13:27:09 <erisco> I am trying this but I am not sure it is working
13:27:35 <erisco> mainly because I am giving an explicit signature, yet GHC is still introducing new variables
13:28:47 <erisco> ah, I think I have a different issue anyways
13:28:54 <dolio> I can't think of a way in which scoped type variables would have anything to do with instances.
13:30:06 <Tekkkz> Hello, a make command is failing on my system like following: http://ix.io/NiG
13:30:10 <Tekkkz> what went wrong?
13:30:13 <Tekkkz> out of RAM ?
13:30:42 <aesonComma> Hello! I am trying to get aeson to give a better error message when there is a missing or extra comma. Basically, I want to catch things in the (String -> Json.Value) phase so I can at least give some hints.
13:31:00 <aesonComma> Do you know of any strategies or resources about this?
13:31:18 <aesonComma> A missing comma gives you "Failed reading: satisfy"
13:33:03 * hackagebot cndict 0.7.7 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.7.7 (DavidHimmelstrup)
13:35:09 <aarvar> edwardk: is there a way to create a top level instance from a Dict?
13:35:35 <roboguy`_> Tekkkz: did you kill the process?
13:36:09 <Tekkkz> roboguy`_: no, ofc not
13:36:50 <roboguy`_> Tekkkz: what are you trying to build?
13:36:55 <roboguy`_> cabal?
13:37:40 <geekosaur> looks to me like ld ran the machine out of memory during linking and got OOM-killed
13:38:00 <Tekkkz> yes. and yeah, how to bypass OOM? setting custom DEFAULT_TMPDIR
13:38:27 <geekosaur> you can't bypass it. it's a response to a critical situation; *something* is going to get killed
13:38:37 <geekosaur> if you can, you add more swap space
13:38:51 <Tekkkz> i have 8GB, but on htop i se no usage of the swap
13:39:08 <geekosaur> is swap even enabled, then?
13:39:35 <aeson-comma> Okay, I think my internet is working again
13:39:36 <Tekkkz> swapon is executed by me
13:40:10 <geekosaur> also, if you are looking at a number talking about the number of processes swapped out, that will rarely be nonzero because actual swapping (moving an entire process out of memory instead of individual pages as needed) mostly isn't done any more
13:40:37 <geekosaur> but I odn't have enough information to say anything more
13:40:49 <Tekkkz> so what should i do now?
13:41:20 <thoughtpolice> htop doesn't show swap usage for any individual process IIRC; it shows the actual amount of memory committed to the swap file(s), so that should be a realistic measure of whether it's actually being used.
13:41:52 <aeson-comma> Okay, maybe another way to ask my question is, are there any alternatives to aeson?
13:42:01 <geekosaur> aside from, the two things that can lead to an unexpected "Killed" are the kernel responding to a critical out-of-memory condition and the dynamic loader "losing" a symbol it had previously found at a point where it can't recover (i.e. something called that function and it couldn't be found in a shared library; all it can do is crash)
13:42:29 <aeson-comma> Here's a potential plan: run aeson parser, if it fails run another parser that detects structural errors, if that one fails prefer its error message
13:42:56 <aeson-comma> But does "another parser" already exist?
13:45:09 <kadoban> aeson-comma: https://hackage.haskell.org/package/json apparently has the option to use parsec. I have no idea how good it is or anything about it.
13:45:50 <aeson-comma> I was just looking at that. I'll report back if it's better!
13:49:13 <augur> parsec peeps: is there a conventional way to do something similar to chainl only with multiple kinds of operators?
13:49:53 <aeson-comma> kadoban, hmm, it's still pretty bad
13:50:38 <geekosaur> try to find a json parser based on trifecta?
13:51:01 <augur> in particular, i need to parse things like so:    Foo.Bar Baz -> Quux   which is a left-recursive nesting of three operators, Dot, Apply, and (->), with that precedence ordering
13:51:26 <aeson-comma> I mean, I think it's more about finding an author that cares about errors than the backing parser
13:51:54 <augur> and its chainl-like because   Foo.Bar0.Bar1.Bar2 Baz0 Baz1 Baz2 -> Quux   is of course also valid, so its a bunch of Dots then Applies then (->)
13:52:12 <aeson-comma> Oof, I can't bring in deps like that!
13:52:32 <augur> i suppose a possible answer is some nested chainl's?
13:53:11 <geekosaur> yes, but trifecta's got a reputation for very good parse error reporting
13:54:48 <erisco> ffs lol
13:54:59 <erisco> it was a quirky thing with scoped variables… I still don't get it
13:55:13 <erisco> but now it works using ScopedTypeVariables + TypeApplications
13:55:28 <erisco> for whatever reason, giving the signature didn't work… but TypeApplications does… well whatever
13:59:55 <scshunt> what is 'True?
14:00:05 <scshunt> it's some sort of boolean type, but where does it come from? Is it built-in?
14:00:13 <glguy> DataKinds extension
14:00:51 <byorgey> scshunt: it's True but lifted one level up, from a value to a type.  it has kind Bool (also lifted one level).
14:02:32 <scshunt> ah, thanks
14:02:45 <scshunt> are there library functions to lower?
14:02:50 <scshunt> e.g. 'Bool -> Bool
14:05:29 <byorgey> scshunt: for that you can use singleton types.  See https://hackage.haskell.org/package/singletons for an automated way to generate & work with them.
14:06:02 <byorgey> Though note that 'Bool -> Bool  doesn't make sense as stated, since 'Bool is a kind and Bool is a type
14:07:17 <burp> having a monadic function f :: a -> m a, and a function g :: (a -> a) -> a, how can I get g to accept f as the first argument, i.e. transform g into g :: (a -> m a) -> m a? I'm stuck with lifts, and not sure if that is possible at all 
14:08:12 <byorgey> burp: I don't think it's possible without editing the source code of g
14:08:21 <burp> byorgey: I feared so, thanks :D
14:10:52 <byorgey> @type mfix
14:10:54 <lambdabot> MonadFix m => (a -> m a) -> m a
14:11:11 <byorgey> burp: ^^^ not sure if this will help but the type made me think of it
14:14:27 <metl> if i'm running :main from within ghci and I interrupt instead of quitting normally, how can i kill off all the threads/open sockets that were opened without having to restart ghci?
14:14:30 <burp> well, it has the same type signature as my target function ;)
14:18:45 <ph88> anyone know how to write this in do-notation?    identifier = (I1 <$> basicIdentifier) <|> (I2 <$> extendedIdentifier)
14:19:38 <Clint> ph88: what?
14:21:35 <ph88> do   blabla   return
14:22:20 <ph88> https://en.wikibooks.org/wiki/Haskell/do_notation
14:22:34 <dolio> (do x <- basicIdentifier ; return (I1 x)) <|> (do x <- extendedIdentifier ; return (I2 x))
14:22:56 <scshunt> byorgey: interesting. Thanks.
14:24:05 <ph88> so it can't be done with 1 do ?
14:25:08 <Clint> do (I1 <$> basicIdentifier) <|> (I2 <$> extendedIdentifier) ?
14:28:53 <erisco> ph88, <$> and <|> are Alternative, whereas do-notation helps with Monad, so there isn't much point in writing it using do-notation
14:29:20 <erisco> the only thing you can rewrite with do-notation is <$> as dolio has shown, because <$> comes from Functor, which all Monads are
14:29:37 <aeson-comma> Alright, about the commas and JSON stuff, I wrote up a proposal of how to get to a nicer place: https://www.reddit.com/r/haskell/comments/4lxmu6/library_request_validate_json_structure_with_nice/
14:30:11 <aeson-comma> Seems not too crazy, and seems like it'd be good to have available to the whole community
14:30:40 <scshunt> ugh, proxy is hideous
14:31:15 <ph88> oki thx erisco 
14:38:21 <lambda-11235> Can reactive banana be integrated into a loop without using callbacks? Like netwire?
14:39:40 <lambda-11235> I'm trying to decide which FRP library to use for writing a pong game.
14:44:27 <erisco> https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies says you use a comma to separate the dependencies, so  type family X a b | a -> b, b -> a where   for example
14:44:37 <metl> are there any programming languages with anonymous sum types?
14:44:46 <erisco> but I get a parse error on the comma
14:45:04 <dfeuer> metl, sure. There's C.
14:45:28 <erisco> I guess they haven't implemented this yet? damn
14:45:52 <metl> dfeuer: i guess i was looking for a functional language :D
14:46:13 <dfeuer> metl, what, you haven't heard of unsafeCoerce?
14:46:14 <metl> dfeuer: not that i have much use for them, i was just wondering why languages like Haskell or Idris don't have them
14:46:30 <dfeuer> metl, what exactly could you *do* with them?
14:46:56 <metl> dfeuer: I dunno, i just thought you can define a function that returns (Int,Double), so why not (Int|Double)
14:47:27 <dfeuer> metl, seriously, I think that feature is quite rare in modern programming languages of *any* sort.
14:47:35 <lambda-11235> metl: Either
14:47:41 <erisco> oh, I guess there is no point
14:47:54 <geekosaur> wasn't someone actually poking at those recently on ghc-devs though?
14:48:09 <metl> lambda-11235: ah, yeah :)
14:48:13 <geekosaur> (although one open question was in fact "so what can you do with them exactly?")
14:48:20 <dfeuer> geekosaur, I think you're thinking of *unpacking* sum types.
14:48:27 <geekosaur> no, that's mor RECENT
14:48:31 <dfeuer> Oh.
14:48:36 <dfeuer> Then I have no idea.
14:48:36 <geekosaur> er, whoops
14:48:46 <geekosaur> this was a discussion a month and a half or so ago
14:48:51 <dfeuer> *shrug8
14:48:56 <geekosaur> I think it died when they realized there wasn't much point
14:49:17 <dfeuer> There's always unsafeCoerce.
14:49:35 <dolio> C doesn't have sum types.
14:49:38 <lispy> lambda-11235: I tried using reactive-banana for writing a pong game.
14:49:51 <dfeuer> dolio, it has "unions", which are untagged sums, no?
14:50:05 <lispy> lambda-11235: It's better now, but when I tried it it had serious performance issues and I had to switch (I switched to yampa)
14:50:14 <thoughtpolice> metl: You can do this with Polymorphic variants in OCaml, I believe.
14:50:22 <dolio> Untagged unions aren't sums.
14:50:32 <lispy> lambda-11235: If I were to pick it up and make another go at it, I would try the FRPNow library this time. For whatever it's worth.
14:50:32 <dfeuer> Oh, okay. So what's an untagged sum?
14:50:35 <dolio> It's also arguable whether C unions are union types.
14:51:04 <lispy> dolio: and the answer is no
14:51:10 <dolio> Like, they are, except you can use them in ways that union types shouldn't be able to be used.
14:51:14 <roboguy`_> metl: I guess it depends on what you consider to be an anonymous sum type... In a dependently typed language, you can have something like f : (p : Bool) -> if p then Int else Char. That's not really a sum type (it's a pi type), but it's the closest I can think of
14:51:18 <thoughtpolice> metl: https://realworldocaml.org/v1/en/html/variants.html ctrl+f 'let is_positive' should give you an example very close to what you're describing.
14:52:00 <lambda-11235> lispy: I'm mainly worried about how to interface it with my main loop, instead of with callbacks from a GUI library.
14:52:44 <metl> oh i forgot about this: http://hackage.haskell.org/package/anonymous-sums
14:52:53 <lispy> lambda-11235: it might have bitrotted since I last worked on it, but here is how I tackled that problem: https://github.com/dagit/1GAM/blob/master/pong/reactive-banana/Main.hs#L180
14:53:16 <geekosaur> ahh, yes, it was actually a side issue brought up duering the unpacking-sums discussion
14:53:39 <geekosaur> and it got lost in questions of syntax if I'm reading the archives right
14:53:48 <dolio> 'A union B' should only be usable in ways where it doesn't matter whether the value is an A or a B. But instead C just lets you use a B value as if it were an A (and vice versa), through the lens of them both being bit patterns in memory.
14:53:59 <dolio> Or maybe it doesn't, and the behavior is just undefined if you do that. I don't know.
14:54:14 <lispy> dolio: the latter
14:54:19 <dolio> Great.
14:54:23 <lispy> dolio: most compilers will make it work
14:54:25 <geekosaur> (the unpacking proposal included anon sums as an implementation detail, apparently)
14:54:45 <geekosaur> and much longer ago than I misremembered. https://mail.haskell.org/pipermail/ghc-devs/2015-September/009847.html
14:55:03 <lispy> dolio: but IIRC, the compiler doesn't even have to guarantee they are stored in the same place
14:55:50 <lambda-11235> lispy: Thanks
14:56:50 <lispy> lambda-11235: if you poke around in there, there is a yampa version and I seem to recall it's more complete
14:58:07 * hackagebot delude 0.1.0.1 - Generalized the Prelude more functionally.  https://hackage.haskell.org/package/delude-0.1.0.1 (sgschlesinger)
14:58:08 <lispy> lambda-11235: I think my ultimate conclusion was that I can't make my brain think in an FRP way so none of those examples are complete.
14:58:38 <lispy> lambda-11235: In Yampa I kept wanting my network to be dynamic in ways that you cannot express directly
14:58:55 <hpc> wow, that's the second alternate prelude uploaded today
15:03:07 * hackagebot eventstore 0.13.0.0 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.13.0.0 (YorickLaupa)
15:03:14 <lambda-11235> lispy: Yeah, my big problem is deciding what graphics/input library to use.
15:04:37 <lispy> lambda-11235: I recommend GLFW-b. it works on windows, linux, and osx
15:05:02 <lispy> lambda-11235: if you need sound and fonts, you will find it lacking but if you just need windowing and input, it's pretty nice
15:05:02 <hpc> i have had bad luck with building things against it on windows
15:05:23 <hpc> if you have trouble, use gloss which has no foreign dependencies that aren't in the platform
15:05:41 <hpc> it might just be my setup is broken though
15:05:44 <lispy> glfw-b (the -b is important) bundles it's deps
15:06:09 <lispy> It could have broken again since I last worked on it, but at the time I made sure it built on all three platforms in a hassle free way
15:06:38 <hpc> lispy: yeah, not sure why it's not working for me
15:09:42 <lispy> lambda-11235: if you need more than windowing and input, then IMO it's better to switch to something like sdl2 that provides a lot of stuff
15:10:09 <lispy> lambda-11235: the drawback is that if you make a demo and you're just sharing it with your friends via source it's harder for them to get sdl2 stuff installed/built
15:12:33 <koz_> How do I use 'readArgs' from CorePrelude?
15:12:45 <koz_> I'm a bit confused over wtf it returns.
15:13:38 <metl> is there a ppa for the latest haskell-platform?
15:14:44 <glguy> koz_: You can click on the typeclass when you're reading the haddocks to see instances of that type class
15:16:32 <koz_> glguy: Ah, it needed an explicit type parameter.
15:44:02 <koz_> My Haskell program is burning through RAM like it's going out of fashion. How can I profile its memory use?
15:44:39 <erisco> ctrl+alt+del system resources tab
15:46:21 <koz_> erisco: Haha, very funny. I guess what I meant was that I wanted to know where in my program is demanding so much memory.
15:46:23 <maerwald> erisco: erm, are you presuming windows?
15:46:35 <koz_> Also, what maerwald said.
15:47:29 <maerwald> koz_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
15:48:16 <kindaro> Hi friends. Of late I've been triying to make use of System.Plugins and various wrappers around it (such as HotSwap, DynamicLoader, found on Hackage), but to no avail. All I can get so far is all kinds of "couldn't find symbol" and "Prelude.undefined". I determined the problem is not in path to object file (if I remove my object file, the error would be different) but rather in the ability of System.Plugins.load & Co. to find the ri
15:48:53 <kindaro> Does anyone has any working solutions to this problem?
15:49:10 <kindaro> * has -> have
15:51:19 <koz_> Do I give the profiling options to 'cabal configure'?
15:51:29 <koz_> Because it doesn't seem to like -prof.
15:52:55 <koz_> Also, if my program has command-line args, do they go after or before the +RTS -p ?
15:52:55 <maerwald> koz_: here's a tutorial https://nikita-volkov.github.io/profiling-cabal-projects/
15:53:09 <Cale> kindaro: your message was cut off at "the ability of System.Plugins.load & Co. to find the r"
15:53:31 <maerwald> he's probably using pidgin, it does that :/
15:53:55 <Cale> Well, any IRC client which doesn't auto-split your messages for you will do that
15:54:14 <Cale> and the annoying thing is that it's impossible to know precisely where to split, you just have to guess
15:54:24 <geekosaur> koz_, before, or use -RTS to delimit the end of RTS opts
15:54:40 <geekosaur> (or --RTS to mark end and stop the RTS from looking for more +RTS options to apply)
15:55:42 <Cale> The IRC server will truncate messages which are longer than a particular length, but that length is not simply the length of the message, but the entire length of the line that it's sending, which includes your hostname, and which your client never sees, because it doesn't echo your messages back to you
15:56:27 <maerwald> Cale: there must be a maximum length of the part the "client does not see" though, no?
15:56:41 <maerwald> so one could just use that as a safe bet
15:56:56 <zomg> I'm fairly sure the irc servers send you a message which specifies the max message length for that particular server
15:57:18 <zomg> but can't remember whether there was some way of figuring your own hostmask if that really affects it as well
15:57:18 <kindaro> I determined the problem is not in path to object file (if I remove my object file, the error would be different) but rather in the ability of System.Plugins.load & Co. to find the right entry point(?).
15:57:23 <geekosaur> you need all of: max msg length, max nick length, max channel name length, max hostname length
15:57:31 <geekosaur> at least the first three can vary between servers
15:58:14 <Cale> kindaro: It does look like someone has been trying to keep the plugins package alive at least...
15:58:30 <geekosaur> ...but I wouldn't expect it to work with ghc8 yet\
15:58:52 <Cale> Yeah, if you're trying to use it with GHC 8, it's a pretty safe bet that it wont'.
15:58:55 <Cale> won't*
15:59:59 <kindaro> I believe I have ghc --version 7.10.3
16:00:02 <Cale> Well, I don't really know -- maybe relaxing the version bound will work, but at least at one point, plugins contained some code which was sensitive to the layout of .hi files
16:00:25 <Cale> and those often change between GHC versions somehow
16:00:28 <geekosaur> recent versions use ghc-api so should not have that (then again, ghc-api has its own version slop)
16:01:31 <Cale> kindaro: You might try hint and see if your luck is any better with that
16:01:49 <Cale> (It claims to be an interpreter, but iirc, if the .o and .hi files are present it will load them)
16:03:10 * hackagebot phantom-state 0.2.1.2 - Phantom State Transformer. Like State Monad, but without values.  https://hackage.haskell.org/package/phantom-state-0.2.1.2 (DanielDiaz)
16:13:10 * hackagebot octane 0.5.6 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.6 (fozworth)
16:16:27 <Big_data> does anyone do machine learning with haskell here?
16:18:14 <Big_data> no?
16:19:57 <Big_data> WHOIS absence
16:20:00 <Big_data> oops
16:21:46 <Big_data> What do you guys talk about here?
16:22:59 <Jinxit> haskell isn't a very popular language for ML
16:23:07 <Jinxit> mostly a lack of libraries
16:23:28 <Big_data> I've noticed, I work in C++ primarily, but I enjoy experimentation with other languages
16:23:40 <Big_data> GitHub has HLearn
16:23:58 <Jinxit> using ML is usually algorithmically simple enough that the language doesn't really matter
16:28:11 * hackagebot arithmoi 0.4.2.0 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  https://hackage.haskell.org/package/arithmoi-0.4.2.0 (Bodigrim)
16:28:36 <Big_data> thank you
16:33:29 <ertes> Big_data: i have done ML with haskell
16:34:10 <ertes> Jinxit: ML can be very complicated
16:34:40 <ertes> especially the modern stuff like deep learning
16:35:55 <ertes> and making things efficient and still keeping a reasonable amount of abstraction is another challenge
16:36:24 <erisco> uh oh, cabal haddock broke for me in 8.0 :(
16:36:46 <Jinxit> ertes: I never said implementing ML libraries wasn't difficult :)
16:36:46 <erisco> haddock: internal error: C:Program\settings: openFile: does not exist (No such file or directory)
16:36:54 <Jinxit> but normally one would just use them
16:37:12 <erisco> is it missing a backslash? i.e. C:\Program\settings?
16:37:43 <ertes> erisco: likely…  "C:abc" is the path "abc" within the *current directory* on C:
16:37:50 <ertes> windows is a bit weird
16:38:00 <Big_data> whats new
16:38:03 <erisco> ah
16:38:08 <erisco> then maybe something else is wrong
16:38:23 <erisco> I don't know what Program\settings is coming from
16:39:45 <ertes> Jinxit: except i have yet to see a single haskell ML library that isn't useless…  each time i see another neural network implementation using lists of lists, a part of me dies
16:40:01 <erisco> is there another way to run haddock? :s
16:40:15 <erisco> I can never tell if the documentation is going to work before I upload it
16:41:25 <ertes> erisco: usually if it works locally, and you don't have C dependencies, it works; if it doesn't, there is a way to upload your local docs manually…  i can't remember how though
16:41:48 <erisco> yeah but it is a pain in the butt, and too slow to fix minor mistakes
16:41:57 <ertes> i agree
16:43:03 <erisco> I wonder if I have the wrong cabal version or something… it is 1.22.5.0
16:43:12 <erisco> no idea what I should have with ghc 8.0.1
16:43:52 <ertes> not sure, but most likely hackage builds with 7.10
16:44:07 <ertes> if your package doesn't build with it, no automatic docs
16:45:47 <nineonine> erisco: try updating cabal to 1.24
16:45:49 <erisco> https://www.haskell.org/platform/ tells me to run 'cabal user-config init'
16:45:54 <erisco> my cabal does not recognise that command
16:46:17 <erisco> I installed the full platform… maybe I have a cabal installed somewhere it shouldn't be
16:46:29 <erisco> mm
16:46:41 <dcoutts> erisco: ghc-8 needs cabal-1.24+
16:46:58 <erisco> who do I have  C:\Program Files\Haskell …
16:47:04 <erisco> why* … no idea where that came from
16:47:49 <erisco> I am confused
16:48:14 <erisco> so, there is cabal.exe here  C:\Program Files\Haskell Platform\8.0.1\lib\extralibs\bin
16:48:20 <erisco> I guess it should be pointing there!
16:49:51 <erisco> there we go
17:07:08 <erisco> do you just 'cabal upload' now or is there still a way to build the distributable? I am blind and am missing the command
17:09:30 <maerwald> dcoutts: needs? it ships it
17:12:19 <cheater> maerwald: cabal is not part of ghc.
17:12:27 <cheater> it's part of haskell platform.
17:12:36 <maerwald> cheater: https://github.com/ghc/ghc/tree/master/libraries
17:12:55 <cheater> that's the library, the executable is separate
17:13:08 <cheater> you can have a newer ghc and an older cabal executable.
17:13:49 <maerwald> cheater: you mean cabal-install, not Cabal I guess
17:14:04 <cheater> i mean the cabal executable
17:14:17 <cheater> that's in the cabal-install package
17:14:20 <maerwald> yes
17:14:51 <erisco> I thought the command used to be 'cabal dist'
17:15:06 <erisco> derp, 'sdist'
17:15:26 <cheater> missing grep? :)
17:15:53 <erisco> I have grep when I use mingw
17:16:18 <erisco> actually it works in cmd.exe too… though I don't know how to pipe things in cmd.exe
17:16:51 <geekosaur> the same way, mostly
17:17:27 <geekosaur> ti even handles Bourne shell-style redirections these days (e.g. 2>&1)
17:18:13 * hackagebot data-function-tacit 0.1.0.0 - Write functions in tacit (pointless) style using Applicative and De Bruijn index notation.  https://hackage.haskell.org/package/data-function-tacit-0.1.0.0 (erisco)
17:18:30 <erisco> *finally*! it is a cool module, check it out
17:20:32 <erisco> mm, I guess it is broken on cmd.exe, though it runs without exploding
17:21:02 <erisco> it seems to print the first 2 characters and then gives up
17:27:20 <erisco> the module lets you rewrite any function in pointless style in a straight-forward way
17:27:37 <erisco> and the result is more-or-less readable ;)
17:33:51 <recursio1-ninja> Hey guys, I have a question about stack configuration.
17:33:59 <recursio1-ninja> When I run `stack install --haddock`, how can I specify where to place the HTML documentation?
17:34:01 <peddie> dfeuer: I spent a couple hours trying to come up with a clearer implementation, but in the end, I ended up with something significantly longer, probably marginally slower and not any easier to follow :/
17:45:10 <cheater> hello
17:46:14 <cheater> can someone tell me what "haskell for mac" is and why one would be inclined to pay money for that?
17:46:21 <cheater> http://haskellformac.com/
17:49:05 <recursio1-ninja> cheater: You wouldn't want to do that. Just install `haskell-platform` for Mac and your good to go. I think "Haskell For Mac" offers a GUI... if memory server
17:49:12 <cheater> yea
17:49:13 <recursio1-ninja> *you're
17:49:27 <josephle> you could even use ghcforosx
17:49:41 <cheater> i'm just surprised people ask money for something like this
17:49:49 <josephle> that one might give you $PATHing headaches though
17:50:05 <cheater> i'm simply not sure what the added value is over haskell platform
17:50:09 <cheater> or stack
17:50:39 <josephle> some people might not know how/are too lazy to set up their own "live-coding" environment
17:50:54 <josephle> even though this not particularly difficult on os x
17:51:15 <cheater> aren't there enough "first time tutorials" out there?
17:51:29 <josephle> well, first time tutorials focus on doing haskell
17:51:38 <josephle> not making your favorite development environment
17:51:54 <cheater> nah i meant ones that tell you what to install and run
17:51:59 <cheater> that's usually part of it
17:55:45 <Welkin> hey vanilla face
17:56:03 <recursio1-ninja> cheater: Just use emacs, Leksah, notepad++ or Atom for editing Haskell.
17:56:05 <glguy> Haskell for Mac is more or less unrelated to HP or stack, it's a workbook environment like iPython
17:56:19 <recursio1-ninja> cheater: or vim if you're so inclined...
17:56:42 <glguy> it puts the error messages inline, and has a live GHCi-like environment in panel that can render graphics and results
17:56:53 <Welkin> I don't get why people think they need some complex rube goldberg machine to write their programs
17:56:56 <Welkin> like eclipse
17:57:03 <Koterpillar> glguy: I know IHaskell exists though
17:57:12 <Welkin> write your programs with a pen on paper
17:57:15 <glguy> Koterpillar: It's a similar offering to that
17:58:36 <Welkin> Koterpillar: are you a villager who lives in a simple medieval german dwelling?
18:00:00 <Koterpillar> Welkin: I'm more of a vim-lagger
18:00:19 <Welkin> you just reminded me of how long it has been since I had a beer
18:00:33 <Welkin> haven't had any summer ales yet
18:03:14 * hackagebot purescript 0.9.1 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.9.1 (PhilFreeman)
18:03:39 <Welkin> that summer when I had a summer shandy for breakfast every morning
18:07:27 <ertes> Welkin: emacs with haskell-interactive-mode is an experience very similar to eclipse or visual studio, except keyboard-driven and efficient…  it's effectively a full haskell IDE
18:07:30 <ertes> and i love it
18:07:50 <EvanR> why does there appear to be no full featured haskelly R-tree 
18:08:25 <EvanR> data-r-tree exists but...
18:08:37 <Welkin> I too use emacs, but only with haskell-mode syntax highlighting
18:09:30 <Welkin> I have had nothing to program for months now
18:10:02 <ertes> there is benefit in using an IDE, if most of your work consists of coding/prototyping, and honestly i don't understand why the IDE as a concept gets so much hate ("just use a good text editor blah blah blah")
18:12:39 <Ralith> ertes: I think that's mostly because properly configured emacs or whatever can usually do all the same stuff without being incredibly slow and taking gigabytes of memory
18:13:06 <ertes> Ralith: but emacs/haskell-interactive-mode *is* an IDE
18:13:36 <Welkin> because whenever I use an IDE (xcode when programming for iOS) the goddamn thing crashes and breaks and makes me want to throw the computer out the window
18:13:48 <ertes> and a persistently running background GHC does easily take a gigabyte or two or RAM
18:13:57 <Welkin> and keyboard shortcuts/navigaton doesn't work right
18:14:07 <ertes> of
18:14:57 <Velizar> How can I rewrite this code to use a higher-order function instead of recursion? It's pseudocode but I hope it's clear. https://gist.github.com/VelizarHristov/608056bfc8d76d35e15fcba9fcabfc4e
18:15:01 <ertes> i don't know about xcode, and i hated eclipse and visual studio when i had to use them…  but i like the idea of an IDE
18:15:24 <Welkin> Xcode = ExitCode because it craches every 5 minutes
18:15:29 <Welkin> crashes*
18:15:35 <ertes> i wouldn't want to go back to "Makefile+shell prototyping"
18:16:16 <Welkin> Velizar: first, rewrite it using pattern matching
18:16:35 <glguy_> ?type unfoldr
18:16:37 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
18:17:01 <ertesx> i wouldn't want to go back to "Makefile+shell prototyping"
18:17:31 <glguy_> Velizar: ^
18:17:32 <Welkin> Velizar: what you wrote doesn't even look like haskell to me
18:17:46 <Welkin> too many prens, very strange way of writing it
18:18:26 <Velizar> looks like unfoldr will do the trick
18:20:15 <ertesx> using c(style(argument)(passing))(will)(make(you)(very))(unhappy)(very)(quickly(in(haskell)))
18:21:48 <divVerent> ertesx: but... but... how can we survive in Haskell without varargs functions?
18:21:52 <divVerent> you know, va_list
18:21:54 <EvanR> ertesx: IDE gets hate because the typical IDE is a clunky GUI app
18:22:10 <EvanR> that may or may not work, or but fixable
18:22:14 <EvanR> be*
18:22:34 <EvanR> so there is a clear distinction between that idea and emacs
18:23:42 <divVerent> but seriously, why is f1 . f2 . f3 $ f4 arg the preferred style, that's inconsistent when adding another function
18:24:13 <Welkin> divVerent: that is not right
18:24:15 <Koterpillar> divVerent: that's different from putting arguments in parens
18:24:18 <Welkin> f4 would be your input then
18:24:41 <Koterpillar> f1(f2) doesn't add anything useful in any case
18:24:49 <divVerent> Welkin: it is right
18:24:53 <pavonia> I think  "f1 . f2 . f3 . f4 $ arg" is preferred
18:24:57 <divVerent> personally I'd prefer writing f1 . f2 . f3 . f4 $ arg
18:25:08 <divVerent> but that's longer and I saw some style guides advising against it
18:25:28 <divVerent> but while at it
18:25:36 <divVerent> why is f1 $ f2 $ f3 $ f4 arg so evil?
18:26:57 <divVerent> it still works fine when in between a function needs some args... e.g. sin $ subtract 2 $ sin $ sin 4 works fine
18:27:45 <divVerent> (I know one issue: this syntax needs more changes when you later see you can make it pointfree)
18:28:04 <ertesx> EvanR: an "intergrated development environment"…  sounds to me like haskell-interactive-mode would qualify as an IDE
18:28:34 <divVerent> the minimum I'd like a Haskell IDE to do is to make sense out of the many screens long Haskell error dumps
18:28:54 <divVerent> sounds like an easy task actually - just highlight all places that have an error, at token (not line) accuracy
18:29:02 <maerwald> divVerent: I sometimes like to think that if I do f1 . f2 $ arg that (f1 . f2) should be something that I can actually think of easily as a new function, not some obscure merged thing. But in practice, I barely follow that. It's more an intuitive thing when to do what.
18:29:16 <ertesx> divVerent: HIM does that
18:30:07 <divVerent> sounds good, but when I had needed it, I couldn't set it up against the existing build environment... but that's more fault of the build environment
18:30:37 <EvanR> ertesx: boiling the ocean trying to interpret existing jargon differently, if nonethless more literally
18:30:45 <divVerent> would probably have been nicer if it could just run a custom build command on demand, parse the output and highlight the places that are broken
18:31:22 <divVerent> also, mouseover on the error reports should show the error at this place in a tooltip :)
18:31:30 <EvanR> IDE = bloated uI/ux DisastEr
18:31:55 <divVerent> to me, IDE = workaround for ghc error messages that are longer than C++ template errors
18:32:00 <divVerent> (and have lower SNR)
18:32:21 <ertesx> EvanR: at which point does an extensible text editor become an IDE?  does it *have* to have a clunky, mouse-driven-by-default GUI to qualify as one?  to me IDE is a concept: integrate your entire development cycle into the editor, including editing, debugging, testing, etc.
18:32:31 <EvanR> pretty much
18:32:38 <divVerent> like, I multiple times hit this: 10 error messages for a single typo, caused by the code allowing for 10 different places to change that would each resolve a type conflict
18:32:39 <Welkin> me and my homie azimat parked our sweet ride out front
18:32:42 <EvanR> without that its just an editor
18:32:46 <divVerent> (in the end it was something stupid like a forgotten fmap)
18:32:48 <Welkin> we're lookin' for a place to rest our black asses tonight
18:32:49 <EvanR> whether or not it can send email
18:32:55 <Welkin> no hos, just a couple o' pimps
18:33:05 <divVerent> ertesx: sure is
18:33:10 <divVerent> VIM may or may not count as IDE in some setups
18:33:19 <divVerent> personally I can only call it an IDE if it has an integrated debugger
18:33:19 <geekosaur> welkin, can you take that to offtopic at least
18:33:25 <Welkin> lol geekosaur 
18:33:29 <divVerent> i.e. highlight current line, keybinds to advance further, etc.
18:33:31 <Welkin> are you glguy now?
18:33:37 <divVerent> (could be fun to imagine in a lazy language though...)
18:33:41 <EvanR> preferably #haskell-offtopic ;)
18:34:00 <Koterpillar> "we're looking for a place... whether or not it can send email"
18:35:03 <ertesx> EvanR: i'm sorry for you then…  to me there is no reason to hate a useful concept because the popular implementations of it suck
18:35:06 <EvanR> i refrain from calling it an IDE because its not clunky and terrible, IDE users dont call it an IDE because it doesnt do feature XYZ
18:35:14 <EvanR> it goes both ways
18:35:42 <EvanR> one of which is probably allows me to use a mouse to click a button
18:35:47 <divVerent> e.g. I would not call any of the existing "LaTeX IDEs" IDEs, but others do
18:35:49 <EvanR> (graphical emacs and vim notwithstanding)
18:35:52 <divVerent> matter of definition
18:36:28 <EvanR> "vim is an IDE" "vim isn't a REAL IDE"
18:36:37 <EvanR> see the insanity
18:36:37 <divVerent> and others call vim their IDE because it can run make
18:36:45 <ertesx> if you're honest, there is little difference between emacs+HIM and visual studio, except that emacs has a good text editor and not-as-stupid defaults
18:36:57 <divVerent> well, vim can certainly be turned into an IDE by enough code :)
18:37:10 <EvanR> it probably boils down to native look and feel
18:37:12 <Welkin> I think the best editor is the one that can recite lines from Borat at the right time using your system's speech synthesizer
18:37:18 <Welkin> just when you need that boost of notivation
18:37:28 <Welkin> motivation
18:37:56 <divVerent> nowadays I'd consider fix suggestions an important IDE feature
18:38:13 <divVerent> in C++ e.g. to suggest 
18:38:16 * hackagebot rank1dynamic 0.3.3.0 - Like Data.Dynamic/Data.Typeable but with support for rank-1 polymorphic types  https://hackage.haskell.org/package/rank1dynamic-0.3.3.0 (FacundoDominguez)
18:38:23 <divVerent> . vs -> or importing stuff
18:38:50 <ertesx> divVerent: with LaTeX perhaps IAE would be more appropriate…  authoring =)
18:38:55 <divVerent> true
18:39:08 <ertesx> yeah, you can program LaTeX…  but…  you…  don't
18:39:16 <EvanR> ;_; the R tree package doesnt return all overlaps, only fully enclosed rectangles
18:39:19 <divVerent> a true LaTeX IDE would let me step through macros
18:39:25 <divVerent> ertesx: once did
18:39:41 <divVerent> made a tex file asking for form field values interactively
18:40:00 <divVerent> but that was a mess
18:41:13 <ertesx> you think GHC's error messages are voodoo?  LaTeX error messages sound like dark phrases from the necronomicon…  while trying to decipher them i can feel satan's cold breath in my neck
18:41:25 <divVerent> ertesx: true
18:41:30 <divVerent> I never read them
18:41:36 <divVerent> just care for the location
18:41:44 <divVerent> the very thing GHC obscures
18:41:52 <EvanR> Line 4124: you figure it out
18:41:59 <divVerent> by suggesting so many locations where the error might be
18:42:18 <divVerent> that's where an IDE comes in - it can visualize that crap
18:42:31 <Welkin> isn't this off topic?
18:42:37 <Welkin> where are the topic nazis now?
18:42:46 <EvanR> Welkin: thats offtopic
18:42:58 <divVerent> the ontopic part of this is "name some good haskell IDEs"
18:43:02 <Koterpillar> Where's Print Screen key in Graphics.X11.ExtraTypes.XF86?
18:43:03 <categoryTheoreti> I have a simple beginner's question:  I have an enumeration type data Bd = Ac | Cd  where the constructors Ac and Cd are only used to pattern match on in some functions.  When I export Bd and then try to instantiate an expression using that datatype, I'm told Cd and Ac are not in scope.  How can I make them in scope?
18:43:05 <ertesx> Welkin: your question is off-optic
18:43:18 <ertesx> wow…  seems like i overused lens recently
18:43:20 <Koterpillar> categoryTheoreti: export Bd(..)
18:43:21 <ertesx> good night
18:43:28 <categoryTheoreti> Thank you
18:43:42 <Koterpillar> categoryTheoreti: or export Ac and Cd individually
18:44:09 <geekosaur> Koterpillar, it's not; it's the standard key xK_Print
18:44:20 <ertesx> divVerent: to answer your question:  emacs + haskell-mode + haskell-interactive-mode is a decent IDE, whether people would call it one or not =)
18:45:06 <categoryTheoreti> I so far like Atom with the haskell plugin, but I'm fairly new.  Seems to deal well with stack ...
18:45:06 <Koterpillar> geekosaur: thanks, indeed it is!
18:46:07 <divVerent> ertesx: Ugh! It got emacs in it! ;)
18:47:03 <ertesx> divVerent: the latter one adds a builtin interpreter, live error highlighting, many smart editing aids (like adding imports and extensions automatically), displaying types of things in scope, etc.
18:47:27 <geekosaur> I liked the direction atom was going, but (a) memory leaks out the wazoo (b) breaks when chrome updates
18:47:30 <divVerent> right, all this is nice - unfortunately in the wrong editor
18:47:47 <divVerent> I once tried using Emacs and ended up too deep in Lisp
18:47:54 <ertesx> divVerent: there are similar things for vim i hear…  something based on ghc-mod i think
18:48:06 <divVerent> and not getting work done as I was hacking emacs instead
18:48:12 <geekosaur> ..but if you think elisp is bad, wait until you meet vimscript
18:48:20 <divVerent> I know vimscript
18:48:22 <ertesx> hehe
18:48:29 <divVerent> but I manage to avoid it somehow
18:48:40 <divVerent> I did run into the vi turing tarpit though
18:48:43 <geekosaur> (I still think one of the design goals was "make elisp look good")
18:48:48 <ertesx> i hate elisp…  but it's a necessary evil =)
18:49:00 <hpc> to be fair, vimscript has absolutely no veneer of quality
18:49:01 <divVerent> once made a brainfuck interpreter in old standard vi (not vim)
18:49:11 <hpc> elisp is in the lisp family for crying out loud
18:49:17 <divVerent> that proves vimscript is useless ;)
18:49:25 <divVerent> as vi keyboard macros are already TC
18:49:40 <koz_> I followed this guide: https://nikita-volkov.github.io/profiling-cabal-projects/ , but when I tried 'cabal install --only-dependencies --enable-library-profiling', it complained about 'Perhaps you haven't installed the profiling libraries for package ‘base-4.8.2.0’?' over and over and over again.
18:49:45 <koz_> What did I forget to do?
18:49:52 <roboguy`> divVerent: they are? I always suspected...
18:49:59 <maerwald> divVerent: yeah, emacs is more like an operating system that happens to have a semi-broken text editor you need to program first
18:50:03 <divVerent> roboguy`: almost
18:50:17 <divVerent> to be honest, I got this to work in every single vi clone including nvi
18:50:23 <divVerent> elvis, vim too
18:50:29 <geekosaur> koz_, install the profiling libs for ghc itself. if you installed via package manager, you need the prof package (ghc-prof on debianoids)
18:50:33 <divVerent> but original vi loses marks
18:50:38 <koz_> geekosaur: Thanks!
18:51:08 <divVerent> so for some odd reason it worked when pasting the toplevel loop in the editor over and over again in original vi
18:51:17 <ertesx> emacs has a good text editor…  it's called evil
18:51:21 <ertesx> extensible vi layer
18:51:35 <divVerent> it doesn't do :map right ;)
18:51:48 <divVerent> thus can't run my bf.vi
18:52:11 <geekosaur> which original vi?
18:52:34 <divVerent> the one open sourced about 5-10 years ago
18:52:50 <divVerent> ex-vi
18:53:17 <divVerent> that's the one where marks inside macros don't always work
18:53:22 <geekosaur> I mean, there were several iterations of the 4BSD vi, some of which did indeed have bugs in :map including a few later ones. then there was the SVR3 iteration with its added features
18:54:24 <geekosaur> fidn someone with a 4.3bsd source tape and hope the lawyers ar elooking the other way :p
18:54:32 <divVerent> hehe
18:54:39 <divVerent> maybe buy it from sco
18:54:41 <divVerent> oh wait
18:55:37 <divVerent> anyway, nvi (the one FreeBSD ships) is already sure turing complete
18:55:54 <ertesx> enough editor scripting language war…  night =)
18:56:00 <divVerent> night
18:56:01 * geekosaur usually installs that one in place of vim anyway >.>
18:59:47 <iostream> Hello. Does anyone here have experience with implementing type inference for type classes?
19:01:24 <divVerent> anyway, just for the geeks - the vim/nvi brainfuck interpreter: http://nopaste.linux-dev.org/?1118390
19:01:34 <divVerent> needs minor edits for elvis, forgot which
19:01:45 <divVerent> cursor pos on paste differs I think
19:12:34 <scshunt> GHC -Wredundant-constraints warns about constraints introduced via a type synonym
19:12:37 <scshunt> is there a way to avoid this?
19:12:42 <scshunt> without losing the whole warning
19:17:19 <nitrix> I'm I allowed to duplicate STRefs ?
19:17:43 <hpc> how do you mean duplicate?
19:18:18 <nitrix> First, can I even store an STRef in a record like you would an IORef?
19:19:04 <hpc> you can, though it will require either language extensions or threading the 's' through
19:19:13 <nitrix> Or does the STRef exists only for the duration of the ST monad ?
19:19:28 <hpc> like instead of data Magic = Magic (STRef s Int)
19:19:40 <hpc> you'd use data Muggle s = Muggle (STRef s Int)
19:19:51 <hpc> Magic needs some foralls but you get the idea
19:20:11 <hpc> STRefs can escape if you're a terrible person
19:20:24 <hpc> it doesn't make much sense though, and you have to break the api pretty badly to do it
19:20:28 <hpc> unsafeCoerce and the like
19:21:08 <nitrix> hpc: I'm trying to think of a nice way to arrange relational data and try to have O(1) access time complexity without falling back to IORefs.
19:21:53 <nitrix> hpc: Almost everything out there are doing some lookup in some relational mapping (e.g. Ixset).
19:22:21 <nitrix> The problem is, almost anything else is necessarily not pure as you'd break referential transparency.
19:23:30 <Cale> hpc: It matters where the forall goes there ;)
19:23:45 <hpc> ah right, that too
19:24:01 <hpc> i don't remember what each position of forall means, but that's just because i don't like using either of them
19:24:04 <Cale> You can smuggle an STRef out in an existential, you'll just never be able to use it.
19:24:15 <Cale> RankNTypes are pretty nice!
19:24:26 <hpc> Cale: unsafeCoerce?
19:24:29 <Cale> Existentials can be nice, but are usually not necessary
19:24:37 <Cale> Well, with unsafeCoerce, anything is possible
19:25:05 <hpc> all that statement needs is a rainbow effect on "anything is possible"
19:26:13 <hpc> nitrix: how much data are you expecting? strictly speaking, O(1) access time is impossible
19:26:33 <hpc> though if you know the size of the data you can pretend, like with an array in memory
19:27:06 <nitrix> hpc: I've brought the example here a few times but, consider a game where you have players belonging to guilds. That's a simple relation out of many possible, but it illustrate it well.
19:27:23 <hpc> also what access patterns, though being relational narrows that down somewhat
19:27:41 <nitrix> hpc: In C, each player could just share a pointer to the same object. If the object is mutated, all players gets affected, which obviously doesn't fit super well in Haskell's model.
19:28:29 <hpc> maybe take the approach most graph libs do
19:28:33 <hpc> give each guild and player an id
19:28:36 <hpc> players store a guild id
19:28:49 <nitrix> Well that's the thing.
19:29:02 <nitrix> I do have that. I have a _lot_ of those, and it's driving me nuts :P
19:29:34 * Cale .oO( Dynamic t (Map (Id Player) (Id Guild)) )
19:30:10 <hpc> there might be some refactoring that would make it better without having to change your design
19:31:09 <hpc> usually "my code is ugly" has a refactoring answer instead of a restructuring answer, as long as you have working code to start with ;)
19:31:25 <nitrix> I was thinking of STRef and threading up something in the Player type, but :/
19:33:54 <nitrix> hpc: I genuinely haven't asked myself if it's refactoring or restructuring or inovating or whatever. I just know it's a problem in Haskell that doesn't seem solved very well.
19:48:19 * hackagebot delude 0.1.0.2 - Generalized the Prelude more functionally.  https://hackage.haskell.org/package/delude-0.1.0.2 (sgschlesinger)
20:08:20 * hackagebot hgrev 0.2.0 - Compile Mercurial (hg) version info into Haskell code  https://hackage.haskell.org/package/hgrev-0.2.0 (LukeHoersten)
20:13:20 * hackagebot prometheus 0.4.0 - Prometheus Haskell Client  https://hackage.haskell.org/package/prometheus-0.4.0 (LukeHoersten)
20:13:22 * hackagebot seqid 0.5.0 - Sequence ID production and consumption  https://hackage.haskell.org/package/seqid-0.5.0 (LukeHoersten)
20:18:20 * hackagebot seqid-streams 0.5.0 - Sequence ID IO-Streams  https://hackage.haskell.org/package/seqid-streams-0.5.0 (LukeHoersten)
20:18:22 * hackagebot unagi-streams 0.2.0 - Unagi Chan IO-Streams  https://hackage.haskell.org/package/unagi-streams-0.2.0 (LukeHoersten)
21:18:17 <wagle> is Lambda the Utimate dead for anyone else?
21:19:18 <EvanR> long live LtU
21:20:08 <pavonia> wagle: Not really dead but shows an SQL error
21:20:36 <wagle> yes, thats it..  i decided not to be overly precise
21:21:49 <wagle> whats bizarre is that feedly no longer lists todays article
21:31:07 <EvanR> is compact map faster than a simple array of key values pairs
21:31:44 <EvanR> i was just thinking whether a simple array of key value pairs would be a beneficial data structure for some cases
21:39:14 <suzu> you mean Data.Map vs an association list?
21:40:38 <EvanR> yes, except not a list, its an array
21:40:49 <EvanR> i always wonder about the effect of lists on locality
21:44:27 <EvanR> maybe compact map is just better
21:58:30 <EvanR> tryhaskell.org is doing something weird on bootup
21:59:39 <EvanR> readFile "/welcome"
21:59:54 <EvanR> this returns "some text!" :: IO String
22:00:01 <EvanR> o_O
22:00:47 <Koterpillar> stub?
22:01:08 <EvanR> it has a mini filesystem for limited IO 
22:01:15 <EvanR> but "foo bar baz" isnt an IO String
22:01:49 <Koterpillar> well, readFile is
22:01:52 <Cale> I get: "Welcome to your mini filesystem! Try playing with this function: getDirectoryContents"
22:01:52 <Koterpillar> ?type readFile
22:01:54 <lambdabot> FilePath -> IO String
22:02:03 <Koterpillar> it runs "IO"
22:02:20 <EvanR> Cale: i get that and :: IO String on the end
22:02:34 <Koterpillar> EvanR: I bet print "str" will be an IO ()
22:02:36 <Cale> yeah, it always prints the type of the term it just interpreted
22:02:42 <Koterpillar> ^^
22:02:54 <EvanR> but...
22:03:09 <EvanR> the term it just interpreted wasnt "Welcome to your mini filesystem! Try playing with this function: getDirectoryContents"
22:03:20 <EvanR> thats not the answer to the evaluation
22:03:25 * hackagebot processing 1.2.0.2 - Web graphic applications with processing.js.  https://hackage.haskell.org/package/processing-1.2.0.2 (DanielDiaz)
22:03:25 <Koterpillar> it is
22:03:37 <Koterpillar> you are in an IO context
22:03:47 <Cale> It's the type of what was evaluated, it's not the type of the String that it printed as an effect.
22:04:04 <Koterpillar> if the type of your expression is IO something, it's evaluated in that context, and you get the result
22:04:08 <Cale> It not only evaluated the IO String action, but proceeded to execute it
22:04:12 <EvanR> for other commands you get <some answer> :: <the type>
22:04:23 <Cale> Unfortunately, it executed it before printing the type of the term, making the result confusing.
22:04:25 <EvanR> so "some text" :: IO String is misleading
22:04:46 <EvanR> i mean that sentence right there is just wrong
22:04:52 <Koterpillar> EvanR: if your input makes sense as "x <- (input)", you get x printed; otherwise you get the result of your input printed
22:05:00 <dfeuer> Is there any chance that tryhaskell.org will work on mobile browsers anytime soon?
22:05:04 <Koterpillar> EvanR: if you look at it that way, sure
22:05:15 <Koterpillar> EvanR: but it's consistent with GHCi
22:05:19 <EvanR> is it?
22:05:23 <Cale> EvanR: The interleaved string isn't what it's trying to say is an IO String
22:05:39 <Cale> it's just there as a side effect of the execution of that IO String
22:05:43 <EvanR> Cale: if it printed any other thing before the :: that would make sense, but theres nothing
22:06:01 <EvanR> so it looks like the prinout is the answer
22:06:04 <Cale> EvanR: Well, it should just print the :: first, before executing the action.
22:06:13 <EvanR> you mean ":: IO String" ?
22:06:17 <Cale> yeah
22:06:22 * EvanR scratch head
22:06:22 <Cale> So you'd have:
22:06:27 <dfeuer> Or   <IO ACTION> :: IO String
22:06:28 <Cale> readFile "/welcome"
22:06:30 <Cale> :: IO String
22:06:40 <Cale> "Welcome ..."
22:06:55 <Koterpillar> Cale: I like this idea
22:07:17 <EvanR> if it just removed the :: IO String in this case it would make more sense
22:07:34 <EvanR> thats usually how ghci works for me
22:08:03 <Koterpillar> EvanR: I think highlighting the types makes sense for people *trying out* haskell
22:09:06 <Cale> Speaking of highlighting, it would be nice if the text weren't all light grey and pastels on white
22:09:53 <EvanR> that too
22:10:16 <EvanR> Koterpillar: sure... but executing IO and doing this is going to confuse how IO works
22:10:25 <EvanR> and how types work, possibly
22:10:43 <Koterpillar> then put some symbol before the result
22:10:49 <Cale> Well, it's less confusing if it attaches the type signature to the expression you entered
22:11:08 <Cale> In fact, perhaps it should even put it on the line right after the point where you pressed Enter
22:11:21 <EvanR> zork style
22:11:28 <EvanR> > get lunch
22:11:30 <lambdabot>      Ambiguous occurrence ‘get’
22:11:31 <lambdabot>      It could refer to either ‘Control.Monad.State.get’,
22:11:31 <lambdabot>                               imported from ‘Control.Monad.State’ at /tmp/mue...
22:11:31 <EvanR> (out of the bag)
22:11:36 <EvanR> taken.
22:11:45 <EvanR> launchMissiles
22:11:47 <EvanR> (IO ())
22:11:50 <EvanR> launched.
22:14:17 <EvanR> also its having random failures
22:14:30 <EvanR> like cant get the type and evaluation of foo
22:14:35 <EvanR> and file not found
22:19:16 <EvanR> in other news Infinity is coming in handy to talking about unbounded intervals of doubles when i didnt think of that originally
22:19:23 <EvanR> s/to/for/
22:28:10 <EvanR> also, phooey on equivalent type syonyms being unable to overlap
22:34:27 <EvanR> what is the defaulting Num ? Integer?
22:34:43 <Axman6> or Double if it's got a decimal
22:35:21 <EvanR> thats require Fractional though
22:35:44 <EvanR> ok
22:36:00 <EvanR> for a minute i thought it was defaulting Ord...
22:48:43 <slacker_d> http://cur.lv/z4ui1
23:04:46 <augur_> is this familiar to anyone:    remainder p f = p >>= (\x -> f x <|> return x)
23:05:40 <MichaelBurge> I associate URLs like "/users/:userId" to a constructor in a data type like "RouteUser Int". I'm trying to write showUrl ("/users/:userId", "RouteUser 1") = "/users/1" without writing it for each term.
23:06:03 <dfeuer> :t \p f -> p >>= \x -> f x <|> return x
23:06:05 <lambdabot> (Monad m, Alternative m) => m b -> (b -> m b) -> m b
23:06:12 <MichaelBurge> I think I can use gunfold or fromConstrB in Data.Data, but I'm having a little trouble reading the docs here
23:06:23 <dfeuer> augur_, no, not particularly familiar.
23:06:40 <augur_> dfeuer: ive come across it in an attempt to make a parser more elegant
23:06:51 <augur_> basically the idea is, you'd write something like    foo `remainder` bar
23:07:00 <MichaelBurge> I was wondering if someone had an example of dynamically feeding the number and type of arguments to a constructor at runtime
23:07:07 <augur_> or, well sorry let me say    foo `remainder` barRemainder
23:07:33 <augur_> dfeuer: and the idea is, you'll try to parse a full bar (which has foo as a prefix) but failing that, youll just get back the foo
23:08:10 <augur_> so for instance in haskell, funapp is a prefix of annotations, so you might do    funapp `remainder` annotationRemainder
23:08:31 <augur_> which will try to parse a full annotation, but failing that, itll just give you back the function application you might have
23:08:51 <augur_> eg   f x :: A    and   f x    will both parse
23:09:34 <augur_> and of course funapp itself is a remainder parser:    funapp = (var <|> parenthesized) `remainder` funappRemainder
23:10:27 <augur_> the idea here is that we have these different kinds of expressions that have overlapping prefixes, but in ways where the prefix isnt always the same, but at least partially ordered
23:10:51 <augur_> (often, where one entire thing is a prefix of another, as with function application and annotations)
23:18:21 <augur_> i guess the way to think about it is as an optional suffix
23:22:33 <EvanR> join followed by two fmaps... cant be right
23:22:42 <augur_> EvanR: ?
23:22:50 <EvanR> nvm
23:23:13 <augur_> :t fmap f (fmap g (join x))
23:23:15 <lambdabot>     Ambiguous occurrence ‘f’
23:23:15 <lambdabot>     It could refer to either ‘L.f’,
23:23:15 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:320:1
23:23:16 <EvanR> =<< to the rescue
23:23:20 <augur_> :|
23:23:29 <EvanR> i meant join (fmap f (fmap g(
23:23:35 <augur_> oh
23:23:52 <augur_> well, fmap f . fmap g = fmap (f.g), fwiw
23:24:21 <augur_> :t join . fmap g
23:24:23 <lambdabot> (Monad m, Show a1, FromExpr (m a)) => m a1 -> m a
23:24:29 <augur_> ...
23:24:33 <augur_> wtf is wrong with lambdabot
23:24:37 <EvanR> Map k (Maybe (x,y)), trying to get a Maybe x
23:25:40 <EvanR> join $ fmap fst <$> lookup...
23:25:45 <augur_> anyway, given Monad m:    f :: a -> m b   ;   fmap f :: m a -> m (m b)   ;   join . fmap f :: m a -> m b
23:26:07 <augur_> so   \f -> join . fmap f   has the type   Monad m => (a -> m b) -> m a -> m b
23:26:14 <augur_> :t mapM
23:26:15 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
23:26:42 <augur_> oh wait what am i doing
23:26:45 <augur_> :t (=<<)
23:26:47 <lambdabot> Monad m => (a -> m b) -> m a -> m b
23:26:53 <augur_> there. :P
23:27:04 <EvanR> right
23:27:31 <augur_> so, join followed by two fmaps is right, and is (=<<). your rescue was correct!
23:27:42 <EvanR> fmap fst =<< lookup...
23:28:23 <augur_> i would suggest using do notation tho. explicitly writing it out is usually more understandable
23:29:41 <EvanR> affectedTarget = fmap fst =<< M.lookup k cix
23:29:46 <augur_> ok night peeps
23:38:29 * hackagebot delude 0.1.0.3 - Generalized the Prelude more functionally.  https://hackage.haskell.org/package/delude-0.1.0.3 (sgschlesinger)
23:45:20 <pontre2k> http://espedito.homepc.it :))
