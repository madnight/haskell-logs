00:00:36 <koz_> Goddamn, lens needs half of Hackage.
00:01:29 <Axman6> lens is half of hackage
00:04:27 <seraphime> Good morning
00:09:10 <liste> good morning seraphime
00:33:47 <koz_> What does it mean when I see 'GHC stage restriction' as a warning?
00:33:56 <koz_> (this is via Flycheck hooking into GHC and HLint)
00:34:40 <JuanDaugherty> something inappropriate for the stage of compilation would be my guess
00:34:50 <koz_> Never mind - importing Control.Lens fixed that, derp.
00:35:56 <jle`> huh, didn't realize that you can use lambdas in viewpatterns
00:39:24 <ski> jle` : well, any expression goes, no ?
00:39:48 <koz_> OK, I'm trying to get the second element of something given to me by a lens called 'cov'. I wrote '_2 . cov $ p' and the compiler complains.
00:39:49 <jle`> i didn't realize it was any expression, heh, i thought it was just identifiers i guess
00:39:54 <jle`> like for `foo` syntax
00:40:03 <koz_> But if I write 'snd . cov $ p', all is well.
00:40:15 <jle`> koz_: view (_2 . cov) p
00:40:32 <jle`> assuming cov is actually a lens
00:40:43 <koz_> jle`: cov is indeed a lens. 
00:40:45 <shachaf> But many use cases of view patterns are functions applications.
00:40:47 <koz_> I'll give that a try.
00:40:48 <jle`> er, (cov . _2)
00:40:56 <shachaf> stripPrefix "...", preview ...
00:41:23 <jle`> a new world is open to me o.o
00:41:49 <koz_> jle`: That didn't help...
00:42:09 <koz_> Oh well, whatever, I can use snd.
00:42:13 <ski> > let (stripPrefix "abc" -> Just back) = "abcde" in back
00:42:14 <lambdabot>  "de"
00:43:11 <jle`> koz_: what's the type of cov ?
00:46:48 <koz_> jle`: The Lens type? I dunno, I autogenerated them as per the suggestions of the docs.
00:51:54 <koz_> OK, lenses are *much* more tricky than the lens docs makes them look...
00:53:04 <jle`> koz_: what about :t in ghci?
00:53:43 <koz_> jle`: What's the command to load an arbitrary file?
00:53:50 <jle`> :l
00:53:55 <jle`> er, :load
00:54:53 <koz_> Grrr, that complains about missing another file in the project (which I already loaded earlier).
00:55:06 <jle`> what are you using to manage the project?
00:55:12 <koz_> jle`: Cabal.
00:55:18 <jle`> if you use stack, then 'stack ghci' should load everything up
00:55:21 <jle`> are you sandboxing or anything?
00:55:25 <koz_> jle`: Yes, in a sandbox.
00:55:39 <nomeata> Hi. Anyone here aware of Watkins’ work of using Haskell to prove Conway’s lost comological theorem: https://www.cs.cmu.edu/~kw/pubs/conway.pdf
00:55:40 <jle`> you probaly don't want to load a file, but a module
00:55:45 <koz_> So :m?
00:55:50 <jle`> import Foo.Bar
00:56:06 <jle`> if you're in cabal's sandboxing ghci
00:56:15 <jle`> but i haven't used cabal in a while
00:56:18 <nomeata> I am confused about his definition of cover, which ... nevermind, phrasing a question solves it. thanks for rubber-ducking!
00:56:29 <koz_> I ran ghci with 'cabal exec', and 'module whatever' doesn't work for loading my module.
00:56:51 <jle`> i don't think the module keyword would work here
00:57:02 <koz_> What should I do instead?
00:57:03 <jle`> try cabal ghci or cabal repl ?
00:57:09 <jle`> "import ...", instead of "module .."
00:57:13 <jle`> "module ..." defines new modules
00:57:16 <jle`> you want to import a module :)
00:57:25 <koz_> jle`: Ooops, I meant 'import whatever'.
00:57:30 <koz_> But let me just try 'cabal repl'.
00:57:49 <koz_> Nope, cabal repl doesn't work, because all it grabs is my trivial main.
00:57:56 <koz_> I guess I could have it dummy import those things...
00:58:05 <jle`> can you calbal repl and then import?
00:59:28 <koz_> jle`: OK, dummy imports into Main worked.
00:59:41 <koz_> :t of cov yields cov :: PUnit -> Coverage
00:59:42 <lambdabot> parse error on input ‘of’
00:59:58 <koz_> (where Coverage is a type alias for (Int, Table))
01:00:28 <jle`> koz_: yeah, that's not a lens
01:00:31 <jle`> that's just a normal function
01:00:37 <jle`> that's why snd (cov p) worked
01:00:50 <jle`> the same way f (g x) would work :)
01:01:14 <jle`> > snd (unzip [(1,'a'),(2,'b')])
01:01:16 <lambdabot>  "ab"
01:01:34 <koz_> jle`: Oh, OK then. But I put 'makeLenses ''PUnit' to have lenses.
01:01:40 <koz_> Since later, I actually wanna use chained sets.
01:01:46 <koz_> (well, 'set's, rather)
01:01:56 <jle`> try :browse-ing your module to see what the lenses are named as
01:02:04 <koz_> Oh, fuck, underscore decorators...
01:02:25 <jle`> usually the convenition is to name your record accessors _cov, etc., and the lenses would be generated with the names 'cov', etc.
01:02:37 <jle`> but if you named your record accessor 'cov', i'm not sure what happens
01:03:15 <koz_> Yeah, that's what I meant by 'underscore decorators'. And what happens is that GHC stomps on lens.
01:03:25 <koz_> (it generates the typical accessor functions you'd expect from record syntax)
01:03:40 <Hijiri> I thought the lens are generated with _ if the accessors have no _
01:03:40 <koz_> I just fixed that, :r'ed, and now they're lenses.
01:03:53 <jle`> hooray!
01:03:56 <koz_> Hijiri: Well, it sure as heck generated no lenses for me.
01:04:18 <jle`> it might have generated lenses, did you :browse to see?
01:05:14 <koz_> jle`: I didn't back then. It doesn't matter now - I have lenses.
01:05:55 <jle`> mhm. it probably generated lenses, so you could have used what it generated if you wanted too
01:06:01 <jle`> (generated in the earlier case)
01:06:05 <jle`> it depends on the convention you want
01:07:05 <koz_> jle`: Well, fact is, right now, I have the lenses I wanted.
01:07:21 <koz_> Thanks for making me use a proper workflow. :)
01:07:44 <jle`> yup, it's usually common to have a ghci window open while you're developing
01:08:02 <jle`> just so you can :r and try out new things as you make edits
01:08:02 <koz_> jle`: Yeah - I'm starting to see why.
01:08:23 <jle`> and yeah, you can also use :t for things like this, and :browse to check out the results of any TH stuff
01:08:37 <jle`> and :i too
01:08:53 <koz_> I knew about :t and :i, but not :browse.
01:08:57 <koz_> I'll have to remember that one.
01:09:01 <jle`> it's kind of annoying that you have to redefine your bindings every time you reload though
01:09:09 <jle`> but i'm not sure what the alternative would be
01:09:21 <jle`> "replay" functionality?
01:13:57 <koz_> jle`: I have a call like 'set cov c (set expr e p)'. Is there a way I can write it in a less painful manner? I'm not too sure how to compose setters.
01:14:06 <chattered> What's the problem with having an ML style toplevel where you don't have to redefine anything when you reload your file?
01:17:03 <jle`> `set cov c . set expr e` is a decently nice way of doing two set's in a row.  you can also use set's infix operator alias, .~
01:17:24 <jle`> > (1,2) & _1 .~ 'a' & _2 .~ True
01:17:27 <lambdabot>  ('a',True)
01:18:11 <koz_> jle`: Thanks!
01:18:12 <jle`> > (_1 .~ 'a') . (_2 .~ True) $ (1,2)
01:18:16 <lambdabot>  ('a',True)
01:18:41 <jle`> (nobody does it that last way though i think)
01:22:41 <koz_> jle`: I can see why.
01:29:19 <EvanR> ive seen some references to the property "pacman complete"
01:29:31 <EvanR> any idea where this was first used, and proofs of pacman completeness
01:33:33 * hackagebot uom-plugin 0.2.0.1 - Units of measure as a GHC typechecker plugin  https://hackage.haskell.org/package/uom-plugin-0.2.0.1 (AdamGundry)
01:51:31 <absence> i have two lists of keys and values, [(K, A)] and [(K, B)], where the keys are shared. what's the best way to combine the lists into a single list [(K, (A, B))] or similar?
01:52:59 <bergmark> sort and zip
01:54:11 <koz_> What's the simplest way of going from [a] -> [(a, a)] such that for all (x, y) in the result, x /= y?
01:55:52 <bergmark> filter by equality
01:56:08 <bergmark> n/m :_)
01:56:18 <merijn> > [(x,y) | x <- [1..10], y <- [1..10], x /= y]
01:56:20 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,3),(2,4),(2...
01:56:44 <opqdonut> koz_: do you want _all_ such pairs (x,y)?, then what merijn said is what you want
01:56:49 <merijn> :t \xs -> [(x,y) | x <- xs, y <- xs, x /= y]
01:56:50 <lambdabot> Eq t => [t] -> [(t, t)]
01:56:56 <koz_> opqdonut: Yes, all.
01:57:01 <absence> bergmark: ah right, by shared i mean the lists use the same set of keys, but they're not guaranteed to have the exact same keys or be of the same size
01:57:08 <merijn> Note, mine checks for equality, so if you have multiple identical values all pairs will be filtered
01:57:10 <opqdonut> koz_: is the input finite?
01:57:16 <koz_> opqdonut: Yep.
01:57:35 <merijn> i.e. [1,1,2] would only return [(1,2),(2,1)]
01:57:46 <koz_> merijn: That's not an issue.
01:57:47 <merijn> Actually, I suppose it would have duplicate tuples
01:57:57 <merijn> > (\xs -> [(x,y) | x <- xs, y <- xs, x /= y]) [1,1,2]
01:57:58 <lambdabot>  [(1,2),(1,2),(2,1),(2,1)]
01:58:16 <merijn> Since there's two ones and the 1s in (1,2) and (1,2) are distinct
01:58:36 <merijn> So it depends on what, exactly, you want
02:00:10 <bergmark> absence: another solution is just inserting into a map
02:00:25 <koz_> merijn: Duplicates of the form you described are fine.
02:00:30 <opqdonut> absence: I'd use a map
02:00:33 <koz_> So I guess I'll use a list comprehension.
02:01:30 <merijn> @undo do { x <- xs; y <- xs; guard (x /= y); return (x,y) }
02:01:31 <lambdabot> xs >>= \ x -> xs >>= \ y -> guard (x /= y) >> return (x, y)
02:01:43 <merijn> hmmm, not really what I had in mind :p
02:02:05 <bergmark> absence: These from the `these' package might also help you
02:03:00 <merijn> absence: What do you want to do for keys that don't have both A and B? Drop them
02:03:07 <absence> bergmark, opqdonut: so convert one list to data.map, then map over the other and look up in the map?
02:03:14 <merijn> absence: No
02:03:17 <merijn> absence: unionWith
02:03:24 <merijn> :t M.unionWith
02:03:25 <lambdabot> Ord k => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
02:03:35 <merijn> oh...not the right type
02:03:45 <absence> merijn: ah, convert both to data.map then
02:03:46 <opqdonut> might need some massaging
02:03:54 <absence> but yes, wrong type
02:04:00 <opqdonut> use something like (Maybe a, Maybe b) as the type
02:04:02 <merijn> :t M.mergeWithKey
02:04:03 <lambdabot> Ord k => (k -> a -> b -> Maybe c) -> (M.Map k a -> M.Map k c) -> (M.Map k b -> M.Map k c) -> M.Map k a -> M.Map k b -> M.Map k c
02:04:17 <opqdonut> oh, that's good!
02:04:30 <absence> hah, i just found that one as well :D
02:04:43 <merijn> It's called the "universal combining function" with a reason :p
02:05:01 <absence> great, thanks
02:05:07 <merijn> Oh, actually
02:05:11 <merijn> You don't want union, duh
02:05:15 <merijn> :t M.intersectionWith
02:05:16 <lambdabot> Ord k => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
02:05:19 <merijn> :t M.intersectionWith (,)
02:05:20 <lambdabot> Ord k => M.Map k a -> M.Map k b -> M.Map k (a, b)
02:05:33 <merijn> Of course that drops any keys that don't have both a and b values
02:08:15 <absence> merijn: nice, i think i want that. just have to ponder the edge cases :)
02:23:36 * hackagebot numtype 1.2 - Type-level (low cardinality) integers.  https://hackage.haskell.org/package/numtype-1.2 (BjornBuckwalter)
02:25:01 <merijn> absence: I used the Validation to check for missing keys, maybe you can adapt that code from here: https://github.com/merijn/lambda-except/blob/master/UniqMap.hs
02:43:36 * hackagebot th-lift-instances 0.1.7 - Lift instances for template-haskell for common data types.  https://hackage.haskell.org/package/th-lift-instances-0.1.7 (BennoFuenfstueck)
03:22:17 <lpaste> mhwombat pasted “Cabal 1.24 new-build fails on bifunctor” at http://lpaste.net/162764
03:24:33 <mhwombat> I'm trying to use cabal new-build (cabal-install 1.24) on a local library (creatur), but I get an error on bifunctor. It builds OK using sandboxes, though.
03:43:39 * hackagebot werewolf 1.1.1.0 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.1.1.0 (hjwylde)
03:50:10 <praetor> how should I loop an array in haskell? I want to move a list of files so I want to call a moveFile method for every element of the list
03:50:36 <julianleviston> praetor: mapM_ is probably what you want.
03:50:38 <srhb> praetor: mapM_ -- in that case
03:50:41 <julianleviston> praetor: or something like that.
03:50:41 <srhb> :t mapM_
03:50:43 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
03:50:55 <julianleviston> praetor: but if you tell us some more about what you mean, we can probably help in a better way :)
03:51:58 <maerwald> :t forM_
03:51:58 <maerwald> is nicer
03:51:59 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
03:52:35 <julianleviston> praetor: the first argument to mapM_ is the function that does the moving in your case.
03:52:37 <maerwald> forM_ files $ \file -> move file destination
03:52:56 <julianleviston> maerwald: yeah, much nicer with an inline do block like that
03:53:48 <praetor> I'm only 3-4 pages down http://learnyouahaskell.com/. Let me process your answers and come back with more doubts x)
03:53:59 <maerwald> praetor: ditch it
03:54:31 <maerwald> check out https://github.com/bitemyapp/learnhaskell/blob/master/README.md#how-should-i-learn-haskell instead
03:55:35 <julianleviston> praetor: the trouble with the on-the-fly learning around IO like you’re doing is that you won’t really understand what’s happening, and so therefore won’t really understand why all the pieces do what they do.
03:55:45 <maerwald> LYAH is for when you've had 2 glasses of wine and cannot follow a proper lecture anymore
03:55:52 <julianleviston> haha it’s not that bad.
03:56:21 <maerwald> it doesn't even have real exercises
03:56:42 <julianleviston> it’s just that it isn’t particularly good for understanding haskell with… really really good for showing it off a little bit. :)
03:56:50 <julianleviston> still, it’s open and free.
03:58:53 <absence> merijn: interesting combination with Validation, thanks
04:07:33 <dredozubov> maerwald: forM_ is now called for_
04:07:38 <dredozubov> :t for_
04:07:39 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
04:07:56 <dredozubov> and it has a weaker constraint
04:08:04 <praetor> maerwald well I haven't had 2 glasses of wine but I'm stealth-learning it in a busy newsroom x)
04:08:10 <julianleviston> wow. That’ll be fun to try to explain :)
04:08:25 <praetor> I'll take a look at the guide you gave me
04:08:29 <julianleviston> praetor: we’d be keen to get your feedback on www.happylearnhaskelltutorial.com
04:09:11 <julianleviston> praetor: hasn’t got monad stuff in it, though, so probably you’re beyond where it currently goes to already. Working on volume 2 as we speak :)
04:09:43 <maerwald> praetor: lol, I misread that for "busy mushroom" xD
04:09:55 <julianleviston> maerwald: I want that T-shirt! :)
04:12:12 <absence> if i have [(A, A)] where consecutive events share snd and fst, is there a nicer way to get a list of unique elements than this horrible kludge? map fst list ++ [snd (last list)]
04:13:02 <julianleviston> absence:  what’s a consecutive event?
04:14:13 <absence> julianleviston: neighbours, example: [(1,4),(4,2),(2,9),(9,5),(5,...]
04:14:25 <julianleviston> absence: why don’t you use a Set? (just wondering)
04:14:51 <julianleviston> absence:  there is the nub function, by the way.
04:15:22 <julianleviston> absence: then there’s nubBy if you don’t just want to do a nub based on equality.
04:15:30 <Maxdamantus> I don't think that's what he wants. He has a list of edes and he wants to show the path.
04:15:30 <julianleviston> absence: does that help?
04:15:41 <julianleviston> ah sorry I was having a trouble trying to work out what he wants.
04:16:03 <absence> sorry if i was unclear, but Maxdamantus has it spot on. i'm not looking for unique elements or anything
04:16:08 <absence> in that sense
04:16:22 <absence> but in the other pathy sense :)
04:16:26 <julianleviston> absence: what did you mean by “unique” then? :)
04:16:34 <julianleviston> absence:  (when you said “unique elements”) ?
04:16:59 <absence> julianleviston: the snd and fst are duplicated for neighbour elements, so that's the spot i want uniqueness
04:17:01 <julianleviston> absence: sorry in advance if I’m being dese.
04:17:09 <Xandaros> absence: It probably won't get much better than what you already have. I suggest moving it out into a function and making sure it works on empty lists, too :)
04:17:10 <absence> julianleviston: the same pair can still occur several times without problem
04:17:19 <julianleviston> absence: I don’t understand.
04:17:37 <Xandaros> julianleviston: [(1,2),(2,3),(3,4)] → [1,2,3,4]
04:17:45 <julianleviston> ahhhh
04:17:56 <julianleviston> flatMap with nub ?
04:18:02 <julianleviston> or am I being stupid?
04:18:09 <Maxdamantus> I have a feeling the source of the list is slightly illogical.
04:19:03 <absence> Maxdamantus: yes :) it's not "mine" unfortunately
04:19:04 <Maxdamantus> If you include the start node separately, you avoid the illogical empty list issue, and the solution is just `start : map snd list`
04:20:18 <Maxdamantus> You could always just derive that `start` value, which might be preferable to what you have.
04:20:30 <Maxdamantus> fst (head list) : map snd list
04:20:38 <julianleviston> much nicer, though.
04:20:53 <absence> Maxdamantus: right, that's more elegant than using ++. was still hoping for something better, but the standard library doesn't always hold magic up its sleves
04:21:27 <Xandaros> Well, `(:) <$> (fst <$> listToMaybe list) <*> (pure $ map snd list)`? ...probably not
04:21:50 <julianleviston> absence: using a set would be better.
04:22:19 <julianleviston> absence: wouldn’t it?
04:22:25 <Xandaros> absence: What if a node is multiple times on the path? i.e. [(1,2),(2,3),(3,4),(4,2),(2,5)]?
04:22:49 <julianleviston> oh… the order is important?
04:22:55 <julianleviston> and duplicates are allowed?
04:23:07 <julianleviston> wow it’s taking me *so* long to understand the requirements of this problem
04:23:44 <absence> Xandaros: yeah :/
04:23:54 <merijn> Isn't this trivial to write manually?
04:24:09 <absence> what i want is basically the oposite of zip <*> tail
04:24:38 <absence> thus the idea that there would be something "nice" in the library
04:24:41 <julianleviston> absence: so why can’t you just flatMap and then remove subsequent duplicates?
04:24:54 <julianleviston> absence: what’s your definition of “nice”, though?
04:25:06 <absence> julianleviston: isn't flatMap some kind of scala thing?
04:25:08 <Xandaros> > (zip <*> tail) [1,2,3,4,2,5]
04:25:10 <lambdabot>  [(1,2),(2,3),(3,4),(4,2),(2,5)]
04:25:14 <Maxdamantus> It's not a nice thing to solve, because it doesn't work for empty lists.
04:25:42 <julianleviston> absence: sorry, concatMap
04:26:08 <lpaste> merijn pasted “Paths” at http://lpaste.net/162783
04:26:09 <Xandaros> absence: Go with the manual thing and make sure you catch the empty list. That's probably the ‘nicest’ solution you'll find
04:26:20 <merijn> absence: What's wrong with my solution?
04:26:46 <Xandaros> Wrong way around
04:26:51 <Xandaros> That's what he wants to reverse
04:27:37 <absence> julianleviston: not sure i follow how that would work
04:28:02 <Xandaros> absence: Do you want to retain duplicate nodes like I showed earlier?
04:28:21 <absence> Xandaros: yes
04:28:29 <Xandaros> In that case, I don't think it would.
04:28:56 <lpaste> merijn annotated “Paths” with “Paths (annotation)” at http://lpaste.net/162783#a162785
04:29:01 <merijn> Still not that hard?
04:29:05 <julianleviston> Xandaros: there aren’t any functions that remove consecutive duplications? 
04:29:58 <absence> merijn: it's not about it being hard, i could easily write it manually :)
04:30:01 <Xandaros> julianleviston: [(1,2),(2,2),(2,3)]
04:30:11 <julianleviston> :t concatMap
04:30:12 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
04:30:31 <merijn> absence: Then I don't understand the problem?
04:30:36 <Xandaros> julianleviston: If you remove all consecutive duplicates, you'll end up with [1,2,3], not [1,2,2,3]
04:30:49 <julianleviston> I don’t understand the problem either then
04:30:58 <julianleviston> Could you maybe explain the problem?
04:32:01 <Xandaros> Someone mentioned this is like a graph problem and absence agreed. (1,2) is an edge between node 1 and 2. [(1,2),(2,3)] is a path from node 1 to node 3, via node 2. You want all nodes on the path
04:32:17 <absence> merijn: i could also solve the oposite problem by writing it out with explicit recursion, but in that case it can be solved at a higher level with "zip <*> tail". my question isn't about solving the problem, but learning about the existence of such alternative solutions
04:32:18 <Xandaros> This is what I'm basing my answers on, anyway...
04:33:04 <absence> yes it's a graph problem, and i already know how to solve it. the question is "are there other (better) ways to solve it"
04:33:13 <julianleviston> ah ok
04:33:15 <absence> (it seems like there isn't)
04:33:33 <absence> sorry about the confusion :)
04:33:35 <julianleviston> absence:  what about instead of using pairs, using your own data type… and having a function which spits out what you want using that?
04:34:03 <absence> julianleviston: i don't produce the list, it's given
04:34:21 <Cale> okay
04:34:26 <julianleviston> absence sure, but you could easily coerce it into your “graph” right? In fact I’m sure there would be graph libraries, no?
04:34:39 <coms> here
04:34:51 <julianleviston> absence:  of course there are: https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Graph.html
04:35:08 <merijn> tbh Data.Graph is really only useful for small graphs, imo
04:35:12 <Cale> coms: So one thing which makes type classes different from say, abstract base classes, is what goes on with type variables which occur multiple times
04:35:13 <julianleviston> ah ok
04:35:31 <coms> cale: so it supports non-linearity
04:35:37 <Cale> :t compare
04:35:38 <merijn> Small being: Probably about 10k-ish vertices? Depending on the algorithm
04:35:38 <lambdabot> Ord a => a -> a -> Ordering
04:35:41 <julianleviston> merijn: surely lists of 2-tuples is going to be LESS useful tho?
04:35:42 <Cale> yeah
04:35:48 <Cale> So that's the first thing
04:35:53 <coms> thats kinda huge
04:35:58 <Cale> The second thing is that you can abstract over type constructors and not just types
04:36:00 <julianleviston> absence: is that not better?
04:36:07 <Cale> :t fmap
04:36:07 <merijn> julianleviston: I'd use mutable vectors, probably CSR or edge list representation
04:36:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:36:30 <Cale> ^^ apply a function to all the elements of a container of some sort, for example
04:36:41 <merijn> The third thing is the ability to have multiple parameters
04:36:42 <Cale> > fmap (*2) (Just 5)
04:36:43 <lambdabot>  Just 10
04:36:51 <Cale> > fmap (*2) [3,4,5]
04:36:53 <lambdabot>  [6,8,10]
04:37:05 <coms> Cale: you mean overloaded?
04:37:14 <Xandaros> julianleviston: Data.Graph appears to use 2-tuples like that... `data Edge = (Vertex, Vertex)` :P
04:37:22 <Xandaros> s/data7type
04:37:55 <Cale> coms: Yeah -- notice that the thing being constrained here is a type f which has a parameter
04:38:07 <Cale> This is also used by the Monad type class, for example:
04:38:08 <julianleviston> Xandaros: <shrug> it was an alternative. I think it’s “nicer” than using pairs directly, but it’s totally up to what absense considers nice. :)
04:38:10 <Cale> :t (>>=)
04:38:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:38:34 <Cale> Here, m is a type constructor, which might be applied to different argument types
04:38:52 <Cale> and we're saying "any m will do, so long as it's an instance of the type class Monad"
04:39:35 <Cale> Another thing is that the instances travel separately from the data they act on, based on the types of functions, which means we get return type polymorphism:
04:39:37 <Cale> :t read
04:39:38 <lambdabot> Read a => String -> a
04:39:39 <coms> why not just have it be: Monad m a -> (a -> m b) -> m b
04:39:58 <Cale> ^^ parse anything which is an instance of Read, as determined by the type context
04:40:15 <julianleviston> coms: pay attention to the difference between => and ->
04:40:25 <Cale> coms: Well, it would have to be  Monad m -> m a -> (a -> m b) -> m b
04:40:30 <coms> julian: yeah => restricts to a typeclass
04:40:49 <Cale> coms: i.e. we could translate the Monad type class into a record of the operations which act on these things
04:40:56 <Cale> But it's important that it's separate from the data
04:40:59 <Cale> :t return
04:41:00 <lambdabot> Monad m => a -> m a
04:41:05 <Cale> ^^ what do you do here?
04:41:17 <Cale> return takes a value (of any type whatsoever)
04:41:26 <Cale> say type a
04:41:34 <Cale> and it produces something of type m a
04:41:43 <coms> you can do that with templates
04:41:47 <Cale> and which m to choose is just whatever the type system says is needed
04:42:22 <Cale> coms: I'm not sure if modern C++ can abstract over template-abstracted things...
04:42:28 <Cale> but it couldn't when I last looked...
04:42:33 <coms> oh its quite extensive
04:42:43 <coms> its actually a Turing-complete meta-language
04:42:54 <merijn> Cale: I'm pretty sure templates can
04:43:00 <coms> but its actually unweildly
04:43:01 <merijn> coms: The problem is what templates cost you
04:43:08 <coms> yeah they become almost unreadable
04:43:14 <merijn> coms: Not just readability
04:43:32 <merijn> coms: Also reasonability, since templates can "case" on argument type and change behaviour depending on that
04:43:33 <coms> what 'cost' would there be after that
04:43:44 <Cale> Yeah, templates also don't lose parametricity
04:43:46 <julianleviston> coms: probably structural complexity
04:43:47 <Cale> er
04:43:54 <Cale> that's the opposite of what I meant to write
04:44:03 <Cale> templates lose parametricity
04:44:17 <coms> thats desirable for performance reasons
04:44:27 <coms> and the alternative exists when its needed
04:44:31 <coms> but not with the same power
04:44:56 <coms> but that usually means one has not reduced the program sufficiently
04:45:30 <coms> i mainly was interested in your critique of Agda/Idris typeclasses
04:45:38 <coms> c.f. Haskell typeclasses
04:45:39 <Cale> Okay, so there, the point is more subtle
04:46:18 <coms> (Pure supports 'typeclasses' in a way too)
04:47:20 <coms> in general i'm very surprised that more Haskell coders haven't really taken up Agda/Idris and gone the dependent types route
04:47:24 <Cale> The difference has to do with the behaviour you get when there is more than one way to get hold of a type class instance for the type you're working with
04:47:50 <tasslehoff> Is Applicative available in 7.6.3? I get: Not in scope: type constructor or class `Applicative'
04:47:59 <coms> Cale: so we're clear, you mean when there are overlapping typeclasses for a given concrete type?
04:48:11 <absence> merijn, Xandaros, julianleviston: thanks for the ideas, but i'm interested in the solution of the specific problem of a list of pairs, not the use of a graph library. "case list of (x:_) -> fst x : map snd list; _ -> []" it is
04:48:38 <Cale> Well, it might not even be overlapping, but that's one case
04:48:40 <Xandaros> absence: Like I said, it's probably your best bet
04:49:11 <coms> Cale: overlapping in the sense that the type could belong to more the one typeclass?
04:49:19 <praetor> noob question: why currying?
04:49:22 <praetor> what's the point?
04:49:37 <julianleviston> praetor: it lets you do things you can’t otherwise
04:49:40 <lyxia> tasslehoff: have you imported Control.Applicative
04:49:42 <Cale> praetor: The point is that we work with a lot of higher order functions which want functions as arguments
04:50:06 <coms> praetor: allows a connection to algebraic properties that only operate on functions of a single parameter
04:50:13 <tasslehoff> lyxia: I have 'import Control.Applicative()'
04:50:20 <obadz> In aeson, if I want to encode a record that has a field that's a Maybe
04:50:20 <Cale> praetor: and given that, it's very very convenient to be able to apply a function to fewer than as many arguments as it could possibly take, and obtain another function
04:50:22 <lyxia> tasslehoff: that hides the typeclass
04:50:26 <obadz> and I don't want it to show it as Null
04:50:30 <obadz> what's the right way to do it?
04:50:56 <obadz> maybe mempty ("key" .=) maybeValue -- doesn't seem to work
04:50:58 <coms> praetor: but don't assume currying is necessarily about partial function application
04:51:03 <tasslehoff> lyxia: ok. the gch on ubuntu 16.04 errored if I did not add ()
04:51:09 <tasslehoff> ghc..
04:51:20 <geekosaur> errored how?
04:51:24 <praetor> I see
04:51:34 <coms> Cale: ok so this distinction between them, go on if you would
04:51:43 <Xandaros> praetor: See for example the map function. It takes a function with 1 parameter and applies it to each element in a list. With currying you can do something like map ((+) 5), which adds 5 to each element in the list. This would not work if (+) was uncurried
04:52:06 <coms> praetor: but there are other ways to realize these things without currying. its a choice in language design.
04:52:07 <Cale> Well, it's partly about "partial application", in the sense that you can write something like  compileRegex :: Regex -> String -> Bool, which takes a regular expression, and having only that argument, produces a DFA for determining if a String matches
04:52:22 <Cale> and gives you back a function which runs that DFA
04:52:42 <coms> DFA?
04:52:49 <Cale> deterministic finite automaton
04:52:57 <coms> thats an interesting use
04:53:16 <obadz> In other words, what is the "inverse" of Data.Aeson.(.:?) ?
04:53:21 <coms> you mean it returns a bound function
04:53:44 <Cale> coms: okay, so here's a diamond diagram of the sort we're concerned with
04:54:13 <coms> cale: this almost sounds like you are about to describe a problem analogous to multiple inheritance diamond problem
04:54:26 <Cale> We have that from Ord a (the fact that the type a has a total ordering), we can get Ord [a], (i.e. an ordering on lists of values of type a)
04:54:47 <Cale> because there is an  instance Ord a => Ord [a]
04:55:04 <Cale> From  Ord [a], we also get Eq [a], because Eq is a superclass of Ord
04:55:38 <Cale> But then starting from the top, from Ord a, we can get Eq a, from the superclass constraint
04:55:57 <Cale> and then we have an explicit instance Eq a => Eq [a]
04:56:10 <Cale> (Eq is a type class for equality testing)
04:56:15 * coms nods
04:56:19 <tasslehoff> geekosaur: http://pastebin.com/gL1VNdAt
04:56:20 <Cale> So we have two ways of getting an instance Eq [a]
04:56:32 <Cale> In Haskell, we know that it doesn't matter which way around you find your instance
04:56:40 <geekosaur> pastebin.com blocked here
04:56:42 <Cale> It's designed such that this cannot matter
04:57:00 <tasslehoff> geekosaur: where do you want the paste?
04:57:04 <coms> Cale: ok so how is it in Coq/Agda/Idris?
04:57:06 <geekosaur> @paste
04:57:06 <lambdabot> Haskell pastebin: http://lpaste.net/
04:57:52 <Cale> It's not like that -- instance resolution just does a search for what's in scope and picks the first thing, and there's nothing to guarantee that more than one thing won't match.
04:58:05 <Cale> and it won't even warn you
04:58:23 <Cale> It just picks something, and what it picks might depend on the order that the code is listed in
04:58:24 <tasslehoff> geekosaur: http://lpaste.net/162790
04:58:40 <coms> Cale: not sure why thats a problem yet
04:58:57 <coms> Cale: its not inducing a hierarchy?
04:58:59 <merijn> coms: Do you like having to guess what your compiler guessed? :)
04:59:01 <Cale> coms: It's a problem because it means that you can't easily understand which code will be running.
04:59:27 <coms> so its not static is what you are saying?
04:59:31 <geekosaur> that's a warning, not an error. and it's not really relevant; you're using ghc 7.10.3 and parts of Applicative are in the Prelude in that version
04:59:31 <hpc> coms: it means defining putStrLn before putStr could change the meaning of your code
04:59:42 <merijn> coms: It's static for a specific version of your source file
04:59:52 <Cale> It'll just be *something*, and it might be a different thing each time, which is disastrous, if say, you're using the Ord instance to build a balanced tree structure or something, and it's very important the same ordering is used each time
04:59:56 <coms> im aware of the way lexicographical ordering has an impact on pattern matching in unification/resolution systems
05:00:06 <merijn> coms: Imagine you decide to move the order of functions in your source and it picks a different instance JUST because the ordering change?
05:00:28 <merijn> Doesn't sound like a fun time debugging to me :)
05:00:41 <coms> there are reasons why languages are designed with that
05:00:48 <tasslehoff> geekosaur: yeah. it's -Werror that "kills me". how should I handle this so it works on both 7.10.3 and 7.6.3?
05:00:50 <coms> depending on how it performs unification
05:01:00 <coms> and its rules on normalization
05:01:26 <tasslehoff> perhaps I should upgrade to 7.10.3 on ubuntu 14.04?
05:01:31 <hpc> "depending on how" is exactly the problem
05:01:31 <coms> so what you are saying is in haskell typeclasses are guaranteed to apply in a fixed way
05:01:43 <merijn> coms: No, better
05:01:55 <merijn> coms: In haskell there can only ever be one instance per type
05:02:04 <merijn> coms: So there is no ordering to consider
05:02:11 <geekosaur> I just try to avoid -Werror, since in C, C++, and Haskell it's a good way to force you into wild gyrations to accomplish portability :/
05:02:21 <Cale> coms: With such an implicit way of providing code which is meaningful at runtime, and not just compile-time proofs of properties, you really want some guarantee that there's exactly one option, or else the compiler will shout at you
05:02:38 <geekosaur> I think you end up using CPP if you insist on -Werror aka -Wonly-this-platform-and-ghc
05:02:55 <maerwald> geekosaur: especially since as of recently I get tons of "redundant import of (<$>)" blah things... if I fix it, nothing sompiles on 7.8 anymore
05:02:57 <merijn> There's an obscure edge-case using orphan instances that GHC can't warn about.
05:03:05 <merijn> But hence why orphans are evil too
05:03:20 <coms> Cale: so this has to do with haskell's pattern matching algorithm
05:03:24 <Cale> coms: because without that guarantee, you lose track of what the heck is running at compile time, and the way that your code is split up into modules might result in incoherently choosing multiple instances at different parts of your code, for the same type, and mangling all the invariants on your data as a consequence
05:03:44 <hpc> coms: pattern matching is different, this is purely type system stuff
05:03:48 <Cale> Yeah, the type-level pattern matching algorithm which takes place at compile time to determine which instance is selected
05:03:56 <coms> hpc: its directly related
05:04:02 <Cale> rather than the value level pattern matching
05:04:04 <coms> hpc: type system uses pattern matching / unification
05:04:05 <lyxia> obadz: object (maybe [] (\v -> ["key" .= v]) maybeVal <> restOfTheObject)
05:04:25 <hpc> i don't know of anyone who refers to unification as pattern matching
05:04:25 <Cale> It's pretty different -- it's taking place in a completely separate world as far as Haskell is concerned
05:04:29 <coms> and there are a couple hard choices to make for pattern matching algorithms that change the behavior of what you guys are describing
05:04:38 <Cale> The type class system is actually a lot more like prolog than like Haskell
05:04:42 <Cale> oddly enough
05:04:50 <coms> i mean in the guts
05:05:15 <coms> in any instance where multiple rules apply or overlap for term
05:05:16 <obadz> lyxia: is that really the best way? :-/
05:05:26 <obadz> lyxia: seems syntactically heavy
05:05:32 <coms> you have to decide up-front when writing your unifier
05:05:47 <Cale> The pattern matching that Haskell has at runtime doesn't have this problem because you can't do it piecemeal -- you always list all the patterns you're matching, in the order you'd like to try them.
05:05:49 <coms> so you enjoy that rule that it prevents ordering from changing and i can definitely see why
05:06:14 <Cale> But with what's going on at the type level, it's spread out and implicit, and often just happens as part of type inference
05:06:16 <coms> yeah this algorithm is happening way before the runtime ad-hoc stuff
05:06:37 <coms> thats something i hadn't thought about even in my own design
05:06:39 <Cale> and so you want it to be nice and confluent
05:06:50 <coms> well its confluent but if you change the order of axioms
05:06:54 <coms> i mean rules
05:07:15 <Cale> Haskell's mechanism for type class instance resolution is independent of the order in which you list the rules
05:07:21 <coms> yeah
05:07:44 <coms> but that isn't necessarily so for other implementations
05:07:50 <Cale> right
05:07:51 <coms> so its a good point you've made
05:08:03 <coms> like i said, haskell has a lot of thought-hours in it
05:08:09 <Cale> the other implementations are kind of half-assed, because those languages already had to have implicit parameters for various reasons
05:08:11 <julianleviston> generally, Haskell’s “timelessness” is pretty amazing.
05:08:45 <coms> on the other hand, i've never had problems like this
05:08:46 <Cale> But there's a qualitative difference between the sort of information that usually comes along with implicit parameters in dependently typed languages, and the sort of information which comes along with instances.
05:09:07 <coms> i generally dislike implicit
05:09:33 <Cale> Well, type classes make certain kinds of things usable which wouldn't otherwise be usable.
05:09:54 <coms> right in another language its just a feature
05:09:58 <coms> (optional usage)
05:10:13 <coms> but because of the type system for haskell its part-and-parcel
05:10:19 <Cale> Monad is a great example of that -- bind is just horrible if it has to take a third parameter for which monad it is
05:10:26 <coms> i found that to be a bit of a restriction, but i could get used to it
05:10:27 <Cale> and you have to pass that around explicitly everywhere
05:10:35 <Cale> (and get it right, even though it's based on the type)
05:10:53 <coms> well 
05:10:59 <Cale> otoh, there are a few types which would admit more than one monad structure
05:11:08 <Cale> But you want that rarely enough that it almost doesn't matter
05:11:14 <lyxia> obadz: I can't find anything relevant in the docs either, so maybe you can define your own operator.
05:11:21 <coms> thats somewhat of an artifact of purely functional
05:11:38 <Cale> Nah, Monad is useful regardless
05:11:47 <coms> no i mean the necessity for implicit
05:11:58 <Cale> er...
05:12:11 <Cale> You mean we could just use a global mutable variable to choose or something?
05:12:19 <coms> no
05:12:33 <Cale> (That's pretty awful, and doesn't work when you actually want to use more than one monad at the same time)
05:12:34 <coms> not having to manifestly decorate types
05:12:46 <obadz> lyxia: not sure what it would return? J.object takes a [J.Pair]
05:12:47 <coms> it doesnt arise the same way in another language
05:12:48 <Cale> @src sequence
05:12:49 <lambdabot> sequence []     = return []
05:12:49 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:12:49 <lambdabot> --OR
05:12:49 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
05:12:53 <Cale> consider sequence here
05:13:06 <Cale> sequence :: (Monad m) => [m a] -> m [a]
05:13:31 <Cale> We can write this function once, and then reuse it for every monad -- that's sort of the point of the whole abstraction
05:13:51 <Cale> (that functions such as sequence and liftM2, and so on exist, and we can write them once and reuse them)
05:14:01 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
05:14:03 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
05:14:09 <lyxia> obadz: I'm thinking of something like object ("key" .=? maybeVal <> restOfTheObject), so (.=?) :: Text -> Maybe Value -> [Pair].
05:14:09 <coms> there are many ways to reify that construct in syntaxes that don't obivate the need for implicit interpretation
05:14:11 <julianleviston> Cale: it’s kind of the whole point of abstraction in general, isn’t it? And Haskell delivers here in ways that other languages always promise, but rarely actually deliver, because of the implicit dependencies which aren’t talked about
05:14:19 <Cale> julianleviston: yeah
05:14:42 <lyxia> obadz: you can also do (.=?) :: Text -> MaybeValue -> Object
05:14:47 <Cale> coms: So, if we didn't have this implicitness, sequence would take a parameter for the monad to use
05:14:57 <coms> right i understand why this language needs it
05:15:07 <coms> im just saying that its actually why this language needs it
05:15:13 <coms> and that its 'not even wrong' in another language
05:15:17 <coms> doesn't exist
05:15:18 <Cale> and it would pass it to each occurrence of (>>=) and return in its definition... we could make that a little nicer by extending the do-notation
05:15:25 <Cale> but still, it would be pretty awkward
05:15:53 <Cale> coms: Right, well, I would want a Monad type class in any language where I could have it
05:15:59 <julianleviston> lol :)
05:16:00 <coms> the thing that excites me most that i found from haskell was actually monad transformers
05:16:15 <Cale> Monad is a damn good abstraction of what goes on in a lot of libraries
05:16:51 <coms> but actually making monad transformers productive is non-trivial
05:16:55 <coms> (as a language designer)
05:17:03 <Cale> Parsers, nondeterminism, various kinds of transactions, basically any sort of library which defines a special sort of "computation" which we're gluing together is probably going to get us an instance in most cases.
05:17:07 <coms> if you have any suggestions i'd give them a second go
05:17:26 <julianleviston> Cale: any significantly large program written in a language with a type system inferior to at least Haskell’s involves a half-baked implementation of Haskell’s type system ?
05:17:31 <Cale> Monad transformers I could personally live without, but the ability to abstract over the choice of a monad is huge
05:17:43 <Cale> (and if you can do that, you can probably do monad transformers too)
05:17:43 <coms> i wanted to rely entirely on monads and monad transformers for programming in the large
05:18:14 <coms> but i gave it  up for just modules 
05:18:33 <Cale> an ML-style module system can get you half-baked monads
05:18:48 <coms> i couldn't get a universal way to allow *productive* monad transformer stacks/apis
05:19:02 <Cale> Maybe you *could* do monad transformers using modules... but it would be pretty funky
05:19:16 <Cale> and probably very awkward
05:19:23 <coms> if there was a way to just expose the internals of a monad transformer stack as if it were like any other API that would be huge
05:19:44 <maerwald> coms: just use extensible effects and be done
05:20:02 <maerwald> but it's not really popular in haskell and the few libraries that exist are barely used
05:20:20 <Cale> But really, you want your lengthy applications of many monad transformers to be abstracted away in most cases *anyway*, so it's usually not such a huge deal
05:21:28 <ski> i think one problem with monad transformers is that you have to commute and lift manually (type classes like `MonadState' doesn't really solve the general problem here, consider `StateT s0 (ContT o (StateT s1 [])) a')
05:21:36 <coms_> i must have got disconnected
05:21:40 <coms_> what did i miss
05:22:57 <coms> i think i got disconnected?
05:23:27 <Cale> coms_: I pasted the stuff you missed in PM
05:23:32 <maerwald> monad transformers impose static ordering of effects, are not as expressive as extensible effects, require you to throw around with a plethora of liftSomething functions and building an API around monad transformers can be a pita
05:23:42 <coms_> thank you
05:23:42 <ski> Cale : heh, did the same :)
05:24:21 <ski> maerwald : can those libraries handle continuation effects ?
05:24:30 <coms_> i preumse 'extensible effects' has a manual page on haskell.org or related?
05:24:39 <coms_> presume*
05:24:47 <Cale> maerwald: Though, they can do ContT :)
05:25:03 <Cale> (but maybe you don't care)
05:25:09 <ski> Cale : can or can't ?
05:25:33 <Cale> Monad transformers can, I don't think extensible-effects can.
05:25:34 <coms_> what about a programming basis entirely on group actions
05:25:39 <Cale> https://hackage.haskell.org/package/extensible-effects-1.11.0.2
05:25:47 <coms_> which leads cleanly into reversible computing
05:25:53 <Cale> I could be wrong though
05:25:57 <coms_> which leads to quantum adiabadic computing
05:26:04 <maerwald> Cale: I'm sure oleg could come up with a way :P 
05:26:25 <maerwald> the question is only how practical that madness is :P
05:26:54 <coms_> it would be mind-bending because there wouldn't be functions anymore per-say
05:26:56 <ski> coms_ : .. i had some ideas which view operations like `mconcat :: Monoid a => [a] -> a' as monad actions
05:26:59 <Cale> Extensible-effects only gets you the effects which would sanely commute with everything else, in a way
05:27:08 <Cale> and ContT doesn't
05:27:14 <Cale> So it probably doesn't get you that
05:27:25 <coms_> are extensible effects like type description level effects?
05:27:49 <ski> you want automatic commutation of the things that commute, and a reasonble way to handle the cases where things doesn't commute
05:27:54 <maerwald> coms_: writeAndAdd :: (Member (Writer a) e, Member (State a) e, Num a, Typeable a) => [a] -> Eff e ()
05:27:54 <coms_> i.e., descriptions of effects 'lifted' to the type level?
05:28:19 <maerwald> a bit clumsy though, it's nicer in Idris
05:28:37 <maerwald> see https://hackage.haskell.org/package/extensible-effects-1.11.0.2/docs/Control-Eff-Example.html
05:28:43 <coms_> thank you
05:28:53 <Cale> coms_: Yeah, the idea is you have this monad Eff r, and you never actually say which type r is, you work with computations of type Eff r a, where a is the result type, and you constrain r with various type classes which say which effects are present
05:29:00 <ski> coms_ : anyway .. i think doing reversible computing could possibly benefit from mode and determinism checking in logic programming
05:29:21 <obadz> lyxia: yes, thanks!
05:29:36 <coms_> here is the PDF
05:29:39 <coms_> http://okmij.org/ftp/Haskell/extensible/exteff.pdf
05:30:14 <Cale> coms_: There are like a million ways to do stuff vaguely of this sort
05:30:26 <coms_> Cale: yeah i thought it might work like that; that's almost dependent type level stuff
05:30:46 <ski> Cale : hm, you'd need an ordered logic for the constraints, to be able to handle effects sensibly, i think
05:30:53 <coms_> the dirty confession is that im trained and bred on imperative
05:31:25 <coms_> so the solutions im interested in need to be machine code isomorphic modulo productivity
05:31:57 <coms_> FP is generally conceptual > metal
05:31:59 <Cale> ehhh... the solutions I'm interested in are too, except the translation to machine code is weird ;D
05:32:01 <maerwald> coms_: in idris they do something like: readFile : String -> Eff (IOExcept String) [FILE_IO (), STDIO] (List String)
05:32:14 <maerwald> so you somehow supply a list of effects with nicer syntax
05:32:16 <coms_> where IMP is metal > conceptual
05:32:31 <coms_> maerwald: yeah its a pseudo operational semantics
05:32:35 <coms_> lifted to the type level
05:32:37 <Cale> coms_: that is true though
05:32:44 <coms_> 'crowbar'd into the type system
05:32:54 <coms_> because it can't self-host first-class
05:33:06 <coms_> meaning, it is not meta-circular first-class
05:33:29 <coms_> i attack the problem by hosting the language in a kernel that can entail the object language that you actually use to code
05:33:29 <Cale> coms_: once you're working in a language where evaluation order almost doesn't matter because any order which terminates will give you the same result, you quickly start thinking about things equationally rather than in terms of what the machine is going to do
05:33:56 <Cale> coms_: Oh, that's another reason lazy evaluation is good: if any evaluation order terminates, lazy evaluation will
05:34:22 <coms_> termination proofs are trivial under real-time hard guarantees
05:34:35 <Cale> heh
05:34:51 <coms_> i blew my mind on Ackermann(4,4)
05:34:55 <coms_> it 'terminates'
05:35:02 <coms_> but you'll die before it does
05:35:11 <bennofs> Is cabal-install-1.24 already officially released? Any one knows when the next cabal-install release will be?
05:35:22 <coms_> in fact Ackermann(4,4) is the first ordinal on the Wainer hierarchy
05:35:35 <coms_> and dominates all primitive recursive functions
05:35:47 <Cale> coms_: Oh, you might like an interesting recent result
05:36:07 <Cale> coms_: The value of BB(7918) is independent of ZFC set theory
05:36:38 <ski> coms : ackermann is definable as a total function in type theory, though
05:37:14 <hpc> Cale: wait what
05:37:16 <coms> Cale: busy beaver? BB?
05:37:29 <Cale> yeah
05:37:30 <coms> ski: only with higher order functions
05:37:41 <Zemyla> coms: Maybe *you* will die before it does. I don't plan to.
05:37:52 <ski> iirc, the difference is in whether your "primitive recursion" are allowed to have the other parameters/result be functions as well
05:37:58 <coms> zemyla: are you into cryopreservatoin?
05:38:17 <Cale> http://www.scottaaronson.com/blog/?p=2725 has more details
05:38:18 <ski> Cale, interesting
05:38:20 <coms> preservation*
05:38:31 <Zemyla> Nope, just living past the projected lifetime of the universe.
05:38:39 <coms> zemyla: elaborate
05:38:42 <Cale> (there are some technical limitations on the result though...)
05:39:50 <Cale> There's a 7918 state 2-symbol Turing machine which runs forever assuming the consistency of a certain "reasonable" large cardinal axiom, but which can't be proved to run forever in ZFC, assuming that ZFC is consistent.
05:39:53 <coms> that is a good read, Cale thank you
05:40:30 <coms> what bearing does this have on constructivist mathematics
05:40:34 <coms> and intuitionists
05:40:43 <coms> if any
05:41:01 <Cale> Well, we always knew that such a machine existed
05:41:08 <Cale> It's the specific small bound on its size which is interesting
05:41:24 <hpc> Cale: do we know what the machine is, or just how big it is?
05:41:31 <Cale> We know precisely what the machine is
05:41:45 <Cale> It was compiled using https://github.com/adamyedidia/parsimony
05:42:35 <Cale> coms: also such machines will exist for basically any formal theory which is expressive enough to discuss the termination of Turing machines.
05:42:50 <coms> right
05:42:53 <coms> Turing equivalence
05:43:04 <coms> which is why im bemused they simulated actual Turing machines
05:43:13 <coms> algorithmic information theory has something to say
05:43:22 <coms> prefix universal turing machines
05:43:29 <coms> and bit-level programming languages that are ultra compact
05:43:34 <Cale> Yeah, because they wanted a specific concrete numerical result :D
05:43:36 <coms> then make the mapping back into the Turing machine
05:43:44 <Cale> Well, it's not so much the simulation which is important
05:43:49 <coms> i suppose the function ranking Turing machines would be non-trivial
05:43:51 <Cale> the thing is supposed to run forever, after all
05:44:15 <coms> you know what this reminds me of? STOKE
05:44:19 <Cale> The compiler is also particularly weird in that it doesn't care about runtime efficiency at all
05:44:22 <Cale> only state count matters
05:44:31 <coms> so they attacked in the limit?
05:44:42 <coms> some kind of Levin search?
05:44:44 <Zemyla> cons: It's a joke :P
05:44:48 <coms> simulated annealing ?
05:45:02 <coms> the whole thing or ?
05:45:16 <Cale> They just compile from a simple imperative language to a Turing machine, with a carefully selected program
05:45:23 <hpc> all-natural organic annealing
05:45:59 <coms> well i'll read up on it later for sure
05:46:08 <coms> but i was more interested in something like STOKE
05:46:16 <Cale> There's also someone working on writing an actual program to search for an inconsistency in ZFC directly.
05:46:19 <coms> super-optimization is so delicious
05:46:35 <Cale> (was it Stefan O'Rear I heard was doing that?)
05:47:13 <coms> lets talk about de Bruijn indices
05:47:37 <coms> is ski still here
05:47:46 * ski is not here
05:47:48 <Cale> Oh, yeah, Stefan O'Rear implemented a metamath kernel in Laconic
05:47:50 <coms> ;)
05:48:07 <da-x> Is there any example that uses the package 'ad' for arriving at the symbol derivatives of formulas containing matrix multiplication? e.g. in neural networks activation, 'y = wA + b' 
05:48:19 <coms> im actually working on a script to convert metamath databases
05:48:47 <coms> cale: are you familiar with the metamath syntax
05:49:07 <Cale> vaguely
05:49:16 <peddie> da-x: 'ad' won't do matrix calculus for you; it treats each element separately
05:49:23 <da-x> peddie: thanks
05:49:29 <coms> when you say he implemented a metamath kernel, do you mean he created an independent verifier for metamath syntax?
05:49:44 <Cale> coms: Yeah, a completely impractical one
05:49:50 <peddie> da-x: you can use CasADi from Haskell or a number of other languages to do this efficiently
05:49:58 <Cale> coms: which gets compiled to a Turing machine
05:50:05 <peddie> da-x: probably tensorflow as well, though I don't know of a haskell binding
05:50:12 <Cale> coms: whose simulation runs incredibly slowly
05:50:15 <coms> Cale: what is the difference between a 'tactic' and a 'tactical'
05:50:42 <da-x> peddie: thanks*2 - already using TensorFlow, I looked for a pure Haskell way to do so
05:50:53 * ski would imagine a tactical is a higher-order tactic
05:51:05 <coms> da-x: Pure can do symbolic computation and numeric computation and compiles using LLVM, you may find it interesting
05:51:15 <coms> da-x: Pure programming language that is
05:51:32 <da-x> nice
05:51:36 <coms> da-x: there is also SymPy, which can do matrices symbolically
05:51:44 <coms> (in python)
05:51:58 <coms> SAGE uses SymPy as a back-end
05:52:01 <da-x> coms: I am seeking to extend my blog post on the matter (  http://blog.aloni.org/posts/symbolic-gradients-with-plain-haskell/ ) to matrices too
05:52:18 <Cale> coms: Well, from my interaction with Coq, the distinction is usually between a program which does a proof search of some sort (a tactic), and something which acts on or transforms such programs (tacticals)
05:52:50 <coms> Cale: what is the most simple tactic
05:53:14 <coms> Cale: i set out to write a proof checker and 'accidentally' wrote a theorem prover
05:54:05 <coms> Cale: every proof search is a tactic, thus i would like to know the name of the tactic i serendipitously created 
05:54:18 <Cale> Well, there are things like "intro x." where if you have a goal which looks like A -> B, it introduces a variable x:A into the context, and reduces the goal to B.
05:54:20 <coms> Cale: the approach is left-most inner-most applicative unification
05:54:42 <Cale> and exact y, where if y:B, and the goal is B, solves the goal.
05:54:47 * ski idly wonders whether a tactic language would work nicely for session types
05:54:58 <Cale> ski: heh, neat idea
05:54:59 <coms> elaborate on 'session type'
05:55:14 <coms> what is the 'cruch' tactic in Coq
05:55:17 <coms> crush*
05:55:18 <ski> coms : more or less "types for protocols"
05:55:27 <Cale> coms: Session types basically encode everything which is supposed to take place in a communication protocol at the type level
05:55:32 <coms> ski: a kind of temporal logic?
05:55:54 <coms> why not just use dependent types?
05:56:02 <Cale> Generally you are using dependent types
05:56:23 <coms> actually i did find some limitations with dependent types
05:56:40 <coms> the analog of 'term traversal' is not easily found in dependent types
05:56:50 <Cale> Though there's ways to do this kind of stuff in Haskell if you don't totally need the value dependency
05:57:02 <coms> statically?
05:57:05 <Cale> yep
05:57:16 <coms> i cant imagine it would be productive
05:57:28 <coms> what i mean by productive when i say this here is 'timely'
05:57:29 <Cale> The types look awful, they're basically almost as long as the program, but hey, it works.
05:57:30 <ski> coms : "Propositions as Sessions" by Philip Wadler in 2012-09 at <http://homepages.inf.ed.ac.uk/wadler/topics/recent.html#propositions-as-sessions> is the extent to which i know about session types
05:57:45 <coms> thank you ski
05:57:45 <ski> coms : not temporal logic, in this case. linear logic
05:58:03 <ski> (i already knew about linear logic, when reading that paper)
05:58:22 <coms> a kind of straight-jacketed FSM?
05:58:37 <Cale> This paper is quite a workout on sequent calculus ;)
05:59:13 <ski> Cale : yeah. did a presentation of it. unfortunately we had to spend most of the time explaining linear logic ..
05:59:35 <coms> one can kinda infer what it means just from the name
05:59:36 <ski> Cale : also, there's various small typos, at least in the version i read
06:00:02 <coms> am i the only one who uses the Lynx browser
06:00:07 <Cale> We need a session type for the paper to make sure that it communicates its ideas correctly
06:00:14 <coms> Cale: lol
06:00:24 <ski> Cale : and, from my perspective, they should have dualized the definition of session types
06:00:41 <ski> coms : W3m here
06:00:52 <coms> ski: is it CLI?
06:01:03 <Cale> yeah
06:01:15 <ski> coms : no, it's interactive, takes over the whole terminal
06:01:20 <coms> ski: i use the CLI because i just want the text 99% of the time
06:01:26 <ski> full-terminal
06:01:28 <Zemyla> I wish there were a way to reify a KnownNat and a constraint on its size, like (KnownNat k) => proxy k -> Integer => (forall n. (KnownNat n, n >= k) => r) -> Maybe r.
06:01:32 <exio4> coms: elinks has a nicer interface :P
06:01:54 <coms> when i work at night i do it in the dark, and use redshift -O 1000K
06:02:01 <exio4> Zemyla: unsafeCoerce? :P 
06:02:04 <coms> this lets me work in complete darkness without losing night vision
06:02:10 <ski> coms : i heard RMS reads the web by using `wget' 
06:02:20 <coms> ski: lol
06:02:30 <coms> ski: i've actually had a correspondence with him once, he is very cool
06:02:31 <ski> that would be using CLI
06:02:43 <Zemyla> exio4:  I don't know what form the n >= k dictionary takes.
06:02:43 <coms> what i meant by CLI was not GUI
06:02:59 <coms> but i can see why it would literally mean line interface
06:03:02 <ski> well, but it is GUI, in the same sense that `emacs -nw' or `vi' is
06:03:09 <ski> as opposed to `ed', e.g.
06:03:16 <coms> right
06:03:32 <Cale> RMS reads the web by encoding the URL into a song which he plays on his flute and a team of mice come out of the walls and bring him bits of paper.
06:03:42 * ski smiles
06:04:05 <coms> so we're all linux here
06:04:16 <ski> no, some people here are on BSD
06:04:20 <ski> or windows
06:04:22 <ski> or OS X
06:04:26 <coms> but you and Cale
06:04:28 <Cale> (the mice use wget)
06:04:36 <coms> i use nc
06:04:36 <ski> i wouldn't be surprised if there was also some other system
06:04:38 <Cale> I use linux
06:04:46 <coms> netcat > wget
06:04:52 <coms> lol
06:05:06 <coms> i actually use netcat to transfer files between VMs
06:05:17 <coms> such a damn fine utility
06:06:06 <coms> Cale: have you used ATS
06:06:11 * ski hasn't
06:06:27 <coms> i believe it is also dependently typed
06:06:31 <ski> yes, it is
06:06:38 <Cale> I haven't used it
06:06:59 <coms> do you not find imperative to be more time efficient to work in?
06:07:21 <coms> when you just want to get something done
06:07:22 * ski smiles at coms's joke
06:07:26 <coms> hahahah
06:07:36 <coms> you don't use Python or the sort for quick things?
06:07:41 <coms> prototypes even?
06:08:26 <coms> guess not lol
06:08:26 <zeawee> I personally prefer to use python in declarative way really...
06:08:41 <zeawee> itertools, functools are great
06:08:45 <Cale> coms: nope, I write shell-script like stuff in Haskell even.
06:09:16 <Cale> if it's more complicated than a single commandline anyway
06:09:43 <Cale> coms: Haskell makes a great imperative language, if you just write some IO actions
06:09:51 <coms> :/
06:10:20 <Cale> It's actually very usable as such, there are just some differences you need to get used to
06:10:54 <coms> pascal : 1990s :: haskell :: 2010+
06:11:08 <ski> @quote world's.best
06:11:08 <lambdabot> SPJ says: Haskell is the world's best imperative language.
06:11:10 <coms> (miller analogies tet format)
06:11:29 <coms> haskell is like pascal to me
06:11:29 <Cale> coms: oh, and btw, here's something hilarious I wrote the other day: http://hackage.haskell.org/package/category-printf-0.1.1.0
06:11:32 <coms> its a teaching language
06:11:40 <Cale> dang, the documentation still hasn't generated
06:11:49 <Cale> maybe I should just upload some for the latest version
06:12:18 <coms> but haskell has influenced me more than a little
06:12:21 <coms> a lot more
06:12:27 <coms> its hard to shake it off
06:12:35 <Cale> coms: I use Haskell every day in production.
06:12:48 <coms> i dont doubt
06:12:53 <Cale> Both compiled to native code (backends) and Javascript
06:13:11 <coms> ever looked at the assembly of a hello world haskell program?
06:13:17 <Cale> hah, yeah
06:13:19 <coms> its kinda big
06:13:30 <Cale> Well, there's a whole runtime system, thread scheduler, garbage collector...
06:13:35 <dgpratt> folks use Pascal every day in production, too :)
06:14:02 <coms> Wirth's languages had an influence on me
06:14:07 <Cale> If you compile it with shared objects, it'll be smaller
06:14:18 <ski> Cale : oh, i now remember you talking about that the other day, and that i remember considering that way to do concatenative some years ago
06:14:24 <coms> if we had had pstrings instead of cstrings an entire class of vulnerabilities might not exist
06:14:29 <dgpratt> but Pascal is moribund, I think
06:14:50 <coms> pascal strings > C strings
06:14:53 <ski> it's not dead as long as there's someone using it
06:15:01 <coms> but the way they were reified was unfortunate
06:15:31 <Cale> ski: nice
06:15:47 <Cale> ski: With the cokleisli and all?
06:15:54 <ski> Cale : the nice is that you can do heterogenous stacks. the not so nice is that it's CPS
06:16:05 <coms> what concerns me about working in FP langs is that i spend a lot more time worrying about abstraction than implementation
06:16:17 <Cale> The Cokleisli type constructor makes it a lot easier to follow what's going on, amusingly
06:16:26 <ski> Cale : no, just the `((a -> b -> s) -> (x -> y -> z -> s))' part
06:16:31 <Cale> http://hackage.haskell.org/package/category-printf-0.1.1.0 -- docs showed up
06:16:35 <dgpratt> implementation is hard, let's abstract!
06:16:40 <Cale> (because I manually uploaded them)
06:16:43 <ski> Cale : as describing the stack effect `( x y z -- a b )'
06:16:50 <Cale> yeah
06:17:24 <Cale> coms: if you look at the source code for this library, it's hilarious, almost everything is a one-liner
06:17:32 <ski> Cale : i even remember talking on #concatenative about a type system inspired by this, where you could also name the type of the remaining stack
06:17:52 <Cale> coms: It's basically just the recognition that printf format specifiers are an instance of this particular abstraction
06:18:01 <Cale> from category theory
06:18:04 <Cale> almost directly!
06:18:05 <zeawee> Cale: I am new to haskell world and loved it, (just finished reading learnyouahaskell book), and would want to use it in production, could you tell me your favorite frameworks, tools for it? prefer vim as IDE if possible.
06:18:21 <coms> i love how haskelleers state in the affirmative that preexisting implementations are just special cases of their abstractions
06:18:30 <coms> i.e. printf format specifiers
06:18:31 <coms> lol
06:18:37 <coms> im tongue in cheek on this of course
06:18:43 <coms> because i admire the guile
06:18:59 <coms> and partially because i have been coding in C for > 25 years
06:19:30 <coms> so i am largely bemused by an entailment of the C printf format anywhere outside C
06:19:35 <coms> such as in Python
06:19:40 <aussetg> Hi
06:19:43 <coms> hello
06:19:55 <dfeuer> My rewrite rule is making things worse, and I really can't see how.
06:19:57 <dfeuer> Rewriting to something I've tested and found to be fast.
06:20:03 <ski> coms : btw, perhaps you'll find <http://existentialtype.wordpress.com/2011/03/16/languages-and-machines/> interesting
06:20:38 <Axman6> zeawee: I don't understand your question, favourite frameworks for doing what?
06:21:03 <Cale> coms: It's actually a little different from the C printf format, what I've done -- you're really constructing data structures which contain functions of various types, but it does the same thing as C printf, in a type safe way.
06:21:19 <coms> ski: i am interested and i have bookmarked
06:21:24 <Cale> coms: It's also a little bit like typed Forth
06:21:33 <Cale> >>> printfLn (dup . s . " plus " . swap . dup . s . " equals " . apply2 (+) . s) 4 6
06:21:33 <Cale> 4 plus 6 equals 10
06:21:47 <aussetg> If I have beginner questions I need to ask them here or go on another beginner channel?
06:21:59 <Cale> aussetg: Feel free to ask questions here :)
06:22:00 <srhb> aussetg: Here is just fine.
06:22:07 <aussetg> Ok thanks
06:22:08 <Axman6> Cale: what's s?
06:22:18 <Cale> Axman6: format something using its Show instance
06:22:40 <Cale> So this duplicates the first argument
06:22:54 <Axman6> ah right. so, assuming tuple based stack, Show a => (a,b) -> (String,b)?
06:23:20 <Cale> It's a continuation based stack, but basically
06:23:27 <Axman6> is there a IsString instance being used there?
06:23:27 <coms> well my new friends, i must sleep
06:23:33 <Cale> yes
06:23:47 <coms> ski: thank you for entertaining my strange lexicon
06:23:54 <Cale> http://hackage.haskell.org/package/category-printf-0.1.1.0/src/src/Control/Category/Printf.hs might be easier to read
06:23:56 <coms> Cale: enjoyed the thoughtful discourse
06:24:02 <Axman6> it should be pretty easy to use a Num instance too I suppose
06:24:10 * coms waves
06:24:14 <coms> o7
06:24:15 <Cale> instance (a ~ b, IsString s, Monoid s) => IsString (Cokleisli ((->) s) a b) where fromString = c . fromString
06:24:28 <aussetg> I'm doing the hangman exercise from the HaskellBook.
06:24:30 <aussetg> I wrote a function 
06:24:32 <aussetg> makeHWord :: String -> HWord
06:24:36 <aussetg> And
06:24:38 <aussetg> randomWord :: [String] -> IO String
06:24:42 <aussetg> I wanted to select a random word and then transform it in my HWord format. so my main is :
06:24:46 <aussetg> main :: IO ()
06:24:48 <aussetg> main =
06:24:50 <aussetg>   wordSize 5 10 <$> removeSpecialWords <$> loadDictionary
06:24:52 <aussetg>   >>= (makeHWord <$> randomWord)
06:24:54 <aussetg>   >>= forever guessLetter
06:24:56 <coms> will see you all on later i hope
06:24:58 <srhb> aussetg: lpaste.net for multiline
06:24:58 <aussetg> If I'm correct " (makeHWord <$> randomWord) " should apply makeHWord to the String inside IO.
06:25:01 <Cale> coms: later!
06:25:02 <aussetg> But the compiler is complaining :
06:25:04 <aussetg> Couldn't match type ‘[HLetter]’ with ‘IO HWord’
06:25:06 <aussetg> Expected type: [String] -> IO HWord
06:25:08 <aussetg>   Actual type: [String] -> HWord
06:25:10 <aussetg> In the second argument of ‘(>>=)’, namely
06:25:12 <aussetg>   ‘(makeHWord <$> randomWord)’
06:25:14 <aussetg> In the first argument of ‘(>>=)’, namely
06:25:16 <aussetg>   ‘wordSize 5 10 <$> removeSpecialWords <$> loadDictionary
06:25:18 <aussetg>    >>= (makeHWord <$> randomWord)’
06:25:20 <aussetg> In the expression:
06:25:20 <zeawee> Axman6: I am using javascript most of the times, even for building hybrid mobile apps... and using nodejs for rest api server (I don't like the language design but, well... it is ok if you ignore the bad parts) but would love to use haskell for these if there are some mature ways.
06:25:22 <aussetg>   wordSize 5 10 <$> removeSpecialWords <$> loadDictionary
06:25:23 <srhb> Well, next time... :-)
06:25:24 <aussetg>   >>= (makeHWord <$> randomWord)
06:25:26 <aussetg>   >>= forever guessLetter
06:25:28 <aussetg> /home/guillaume/Documents/HaskellBook/hangman/src/Main.hs: 18, 22
06:25:30 <aussetg> Couldn't match type ‘IO String’ with ‘[Char]’
06:25:32 <aussetg> Expected type: [String] -> String
06:25:32 <Cale> whooooa
06:25:34 <aussetg>   Actual type: [String] -> IO String
06:25:36 <aussetg> In the second argument of ‘(<$>)’, namely ‘randomWord’
06:25:38 <aussetg> In the second argument of ‘(>>=)’, namely
06:25:40 <aussetg>   ‘(makeHWord <$> randomWord)’
06:25:41 <Axman6> @where ops
06:25:42 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
06:25:46 <aussetg> And I can't see why
06:25:48 <aussetg> ok I'll do it
06:25:48 <Cale> aussetg: http://lpaste.net/
06:25:52 <srhb> It's finished!
06:25:58 <Axman6> aussetg: that's a very good way to get banned
06:26:05 --- mode: ChanServ set +o dcoutts
06:26:09 <aussetg> sorry didn't know
06:26:12 <srhb> Axman6: I've never seen that happen.
06:26:14 <Cale> Yeah, don't paste more than maybe 2-3 lines at a time
06:26:38 --- mode: ChanServ set -o dcoutts
06:26:38 <srhb> Live and learn. :-)
06:26:39 <Cale> You probably won't get banned so long as you don't do it repeatedly, but you may get kicked
06:26:45 <ski> Cale : btw, iirc, "Functional unparsing" <http://okmij.org/ftp/typed-formatting/index.html#derivation> used a similar idea
06:26:59 <lpaste> aussetg pasted “My Hangman problem” at http://lpaste.net/162816
06:27:16 <Axman6> dcoutts: sorry to alarm you =) Did you see my PR on binary-serialise-cbor by any chance?
06:27:24 <dcoutts> oh, lets see...
06:27:35 <Axman6> Cale: I remember a few years ago someone wrote something about how amazing factor is, and someone wrote a very simple type safe implementation using tuples, which had all the same power, in just a few lines (relatively speaking). it actually liiked quite nice to use
06:27:43 <lpaste> aussetg revised “My Hangman problem”: “My Hangman problem” at http://lpaste.net/162816
06:27:56 <dcoutts> Axman6: great, having a look
06:28:06 <Axman6> dcoutts: I wrote a simple pretty printer (which turned out to be much more painful than I expected it to be, and took several iterations)
06:28:39 <ninja9> Hi
06:28:57 <Cale> aussetg: I think you want >> rather than >>=
06:29:02 <Axman6> dcoutts: if you have a better implementation, I'd love to hear it, it's pretty ugly internally but gets by without adding any deps
06:29:06 <Cale> aussetg: after the first statement there...
06:29:08 <dcoutts> Axman6: oh, you're trying to do the cbor.me printer
06:29:09 <dfeuer> dcoutts, you think you can help me figure out why my rule is slowing things down when I'm quite confident that I'm rewriting to something good?
06:29:11 <thoughtpolice> Axman6: I haven't commented on it, but at a glance it looks OK. I would probably like to move it into a .Pretty module (at least internally)
06:29:23 <Axman6> dcoutts: yeah, something similar, but slightly uglier
06:29:24 <RoseTreeHelpMe> Can anyone tell me the code to map over a rose tree?
06:29:29 <Cale> aussetg: Well, do you use the result of that first line in any way?
06:29:31 <dcoutts> dfeuer: maybe, but give me a mo
06:29:46 <Cale> aussetg: what's the type of (wordSize 5 10 <$> removeSpecialWords <$> loadDictionary)
06:29:47 <thoughtpolice> Axman6: Because we'll probably want the other, json-ish printer too, and it would be good to move that code out. And we'd probably then use the json one for Show output, and the cbor.me-ish variant for debugging.
06:30:03 <Cale> ohhhh
06:30:06 <Cale> aussetg: I see
06:30:18 <Cale> aussetg: You want the result of that to be the argument to randomWord
06:30:37 <ski> `makeHWord <$> randomWord' should be `(makeHWord <$>) . randomWord', i suspect
06:30:49 <Axman6> thoughtpolice: yeah I didn't want to add any new files (and stuck it in Writer because I needed access to toStrictBytestring)
06:30:55 <aussetg> wordSize 5 10 <$> removeSpecialWords <$> loadDictionary
06:30:57 <aussetg>   :: IO [String]
06:31:00 <Cale> (wordSize 5 10 <$> removeSpecialWords <$> loadDictionary) >>= \xs -> makeHWord <$> randomWord xs
06:31:08 <Cale> But seriously, just use do-notation
06:31:08 * ski nods
06:31:20 <Aruro> Cale: do is bad
06:31:35 <Axman6> thoughtpolice: happy to implement the JSON like printer too, should be able to do it with the same pretty printer monad
06:31:48 <srhb> Or (randomWord >=> makeHWord)
06:31:54 <Cale> do xs <- wordSize 5 10 <$> removeSpecialWords <$> loadDictionary; w <- makeHWord <$> randomWord xs; forever (guessLetter w)
06:32:18 <Cale> Yeah, you could use the fish operator :)
06:32:23 <thoughtpolice> Axman6: Yeah, so I'll drop the comments on the ticket later this morning, in the middle of a few things atm
06:32:23 <aussetg> srhb: I don't know >=> yet unfortunately, soon hopefully
06:32:29 <hpc> Aruro: do-notation is a layer of indirection that makes teaching (>>=) more difficult, but it's not bad by any means
06:32:30 <srhb> Never forgo an opportunity to use the fish operator :-)
06:32:32 <thoughtpolice> dcoutts may have other comments
06:32:34 <Cale> But at a point, it just gets hard to read
06:32:38 <ski> srhb : well, i thought of that, but you'd have to use `return' there as well ..
06:32:39 <srhb> aussetg: It's "just" composition, really.
06:32:40 <ninja9> Which language is this
06:32:42 <Axman6> thoughtpolice: no worries, looking forward to it
06:32:46 <srhb> ski: Would you?
06:32:49 <Cale> once you have to remember the associativity of the operators
06:32:52 <Axman6> ninja9: English =)
06:32:54 <ski>   makeHWord :: String -> HWord
06:32:57 <ninja9> Funny
06:33:10 <Axman6> ninja9: Haskell, as the name of the channel says
06:33:13 <dfeuer> dcoutts, see https://github.com/treeowl/containers/tree/at-brokenrules  The Const rule works perfectly, but the Identity rule totally screws up performance even though I've gotten good results with (essentially) the same code as what it rewrites to.
06:33:17 <Aruro> hpc: i find vertical syntax worse than horizontal. its just psychology.
06:33:21 <ski> (and `HWord' is not `IO Something')
06:33:23 <srhb> ski: Oh, yes.
06:33:46 <srhb> Dunno how I brainfarted that away.
06:33:57 <aussetg> What I don't understand is that I thought ' (makeHWord <$> randomWord) ' meant ' apply makeHWord to the string under the IO that is the result of randomWord " Am I mistaken?
06:34:08 <ski> @hoogle Monad m => (b -> c) -> (a -> m b) -> (a -> m c)
06:34:09 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
06:34:09 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
06:34:09 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
06:34:11 <ski> bah
06:34:15 <ninja9> Looks like a tweaked shell script
06:34:35 <ski> aussetg : as i said, `(makeHWord <$>) . randomWord'
06:34:44 <Axman6> it's nothing like a shell script (except the packages which attempt to be)
06:34:45 <srhb> aussetg: Yes, you're mistaken. Check the type of fmap again
06:34:46 <srhb> :t fmap
06:34:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:34:57 * dfeuer tweaks ninja9's shell script to make penne arrabiata instead of swordfish salad. Yes, much better now.
06:35:11 <aussetg> ski: It works, I'll just think about it to understand why
06:35:16 <aussetg> ski: thanks
06:35:23 <ski> aussetg : however, `forever guessLetter =<< (makeHWord <$>) . randomWord =<< ...' is simpler written as `forever guessLetter . makeHWord =<< randomWord =<< ...'
06:35:23 <aussetg> srhb: ok thanks
06:35:25 <dcoutts> Axman6: for a basis for that, take a look in the tests/Tests/{Reference.hs,Reference/Implementation.hs} at the diagnosticNotation
06:35:35 <nater_> Hi, I'm still feeling my way around in Haskell.  I'm implementing a module that in its inner-most function needs to draw from a sequence that never produces the same value twice (doesn't matter, could be monotonically increasing naturals).  Is ST, and threading around an STRef the right choice here, or is there something better?
06:35:40 <srhb> aussetg: You haven't applied it to the [String] yet
06:36:13 <ski> nater_ : the simplest would be to just have a list of values to draw from
06:36:14 <dcoutts> Axman6: that includes an implementation of the CBOR diagnostic notation from the spec, and used in the test vectors.
06:36:22 <dfeuer> nater_, if you only need the one thing, and it's generated purely (not using I/O, random numbers, etc.) then you should probably use State or StateT, not ST.
06:36:29 <srhb> aussetg: So the `f a` is `[String] -> IO String` -- not `IO String`
06:36:34 <Cale> nater_: If passing a list of the remaining values around is too unwieldy, there are fresh name supplies you could use...
06:37:02 <ski> nater_ : if it's just an "accumulator" (well, perhaps rather "decumulator" ?), just use an argument
06:37:14 <aussetg> srhb: oh that makes sense. My erronous parenthesis even made it clear
06:37:16 <dfeuer> nater_, ST is useful if you need really fast mutable vectors, or data structures made of/filled with mutable references.
06:37:19 <hpc> there's stream processing libraries you can use too
06:37:28 <srhb> aussetg: Perhaps it's more clear if you write it as \ss -> makeHWord <$> (randomWord ss)
06:37:29 <Cale> http://hackage.haskell.org/package/value-supply
06:37:31 <srhb> aussetg: Right
06:37:31 <hpc> (a lazy list of computed values is a stream)
06:37:32 <ski> nater_ : if you also need to return it, consider `State' or `Supply' or something similar
06:37:51 <dcoutts> Axman6: only difference is that it works on Terms from the reference impl. Also it produces output all on one line, though if we want better we'll have to decide if we want a dep on pretty.
06:37:52 <nater_> Okay, wow, thanks.  The closest is fresh names.
06:37:59 <ski> aussetg : did you understand my simplification ?
06:38:07 <dfeuer> For other purposes, ST is likely slower than pure code.
06:38:45 <Axman6> dcoutts: bleh, wish I'd found that before starting :\
06:38:59 <aussetg> ski: yes I think so, it's the same thing as srhb correction written in reverse in a way
06:39:24 <dcoutts> Axman6: sorry, I mentioned it on the ticket but only recently, probably after you started. :-(
06:39:46 <dcoutts> Axman6: of course it's not the same as your debug/cbor.me output
06:39:55 <cantora> anyone know a good channel for general/high level questions about functional programming?
06:39:55 <dcoutts> these are useful for different purposes
06:39:58 <ski> aussetg : the main point here is that `f =<< liftM g ma' is `f . g =<< ma'
06:40:06 <Axman6> yeah I think the cbor.me is quite nice for debugging
06:40:15 <ski> cantora : how about this one ?
06:40:39 <hpc> cantora: here is good, and if it gets too far removed from things that could apply to haskell there's #haskell-offtopic
06:40:46 <cantora> ski: sure, its my first time here so im not sure whats expected/desired here
06:40:56 <dcoutts> Axman6: right, exactly, for debugging at a lower level, and the other diagnostic notation for debugging at a different level (when at least you've got well-formed tokens)
06:40:58 <ski> cantora : np
06:41:27 <dfeuer> cantora, anything less specific is likely to be pure wankery. You should usually avoid wankery of the "What's true of all functional languages?" and "What's the best functional language?" sort.
06:41:48 <ski> aussetg : anyway, if you're going to avoid `do', and use `>>=' pointlessly, i think it often reads better with `=<<' instead
06:41:52 <dfeuer> dcoutts, did you catch my link?
06:42:07 <aussetg> ski: it's what the book calls the left identity law?
06:42:28 <ski> aussetg : no, that's `return a >>= amb  =  amb a'
06:42:41 <Axman6> dcoutts: do you have a preferred location for pretty printers? seems that diagnosticNotation function would be very useful too (afaict it's basically the notation used in the left hand pane of cbor.me right?)
06:42:53 <ski> aussetg : but it can be derived, using the laws, and the implementation of `liftM'
06:42:56 <ski> @src liftM
06:42:57 <lambdabot> liftM f m1 = do
06:42:57 <lambdabot>     x1 <- m1
06:42:57 <lambdabot>     return (f x1)
06:43:09 <dcoutts> Axman6: it is yes, it's the same one uses in the CBOR spec's tests/examples.
06:43:16 <ski> aussetg : note that this is `liftM f ma = return . f =<< ma'
06:43:28 <dcoutts> Axman6: right, these probably should live in a different module, like we have for term/flat-term.
06:43:55 <thoughtpolice> dcoutts: Yeah, I mentioned that (see my msgs above). I'll drop some of those notes on the ticket.
06:44:40 <ski> aussetg : so, we had `f =<< liftM g ma', which is `f =<< (return . g =<< ma)', which by the associative law is `(\a -> f =<< return (g a)) =<< ma', which by that identity law is `(\a -> f (g a)) =<< ma', which by definition of `.' is `f . g =<< ma'
06:44:44 <ski> aussetg : ok ?
06:45:28 <aussetg> ski: yes
06:45:32 <mnoonan> I've never made a Haskell web app before, but I'm interested in using it for an upcoming project. I'm curious about what framework to use.
06:45:43 <cantora> heres my question: i was looking at a makefile and noticing similarities with functional and logic programming. i.e. pattern matching of targets (functional feel), non-deterministic goal->procedure execution (logic lang feel, as opposed to procedure->goal style of procedural languages). has there ever been any experimentation with making a more coherent
06:45:43 <cantora> version of this idea than "make"? in other words, something that uses these ideas, but also makes creation of "subprocesses/subcommands" feel "first class"
06:45:45 <Axman6> mnoonan: what sort of web app?
06:46:07 <aussetg> ski: thanks, I think I just need experience
06:46:13 <Axman6> cantora: take a look at shake
06:46:14 <mnoonan> Axman6: The basic app will just need to let users upload files for processing and then stash the results of that processing in some database for later analysis or maybe browsing
06:46:43 <Axman6> mnoonan: so, pretty simple rest service mostly? Servant is excellent for those
06:46:59 <ski> cantora : not quite what you're asking about, but perhaps you'll find it interesting anyway : <http://neilmitchell.blogspot.de/2014/07/applicative-vs-monadic-build-systems.html>
06:47:01 <mnoonan> I think so, yeah
06:47:09 <zeawee> Axman6: thanks, I was also asking about a rest framework
06:47:14 <cantora> Axman6: thanks, will look that up
06:48:18 <Aruro> aussetg: also remember about point-less style when using >>=
06:49:14 <cantora> ski: thanks, does look interesting
06:50:51 <ski> cantora : also, perhaps "Cake: a fifth generation version of make" by Zoltan Somogyi (an LPL implementor (Mercury)) in 1987-04 at <https://web.archive.org/web/20130501093116/http://ww2.cs.mu.oz.au/~zs/papers/papers.html> might be interesting
06:51:26 <Axman6> dcoutts: #if !MIN_VERSION_base(4,8,0) is the right way to selectively import Control.Applicative right? 
06:51:36 <dcoutts> Axman6: I think so
06:51:37 <aussetg> aruro: I will
06:51:53 <Axman6> and 4.8 is the deciding version?
06:52:02 <ski> (cantora : i'm not sure if it incorporates that many ideas from LP. a quick scan tells me that it adds the ability to say that a file depends on some other file, *if* a condition holds)
06:52:05 <dfeuer> dcoutts, do you know when you might have that moment? Axman6, yes it is.
06:52:16 <dcoutts> dfeuer: ok, probable now
06:52:34 <Axman6> dfeuer: thanks
06:52:57 <dcoutts> dfeuer: lemme grab tea...  and if this is more appropriate for #ghc then ask there (less traffic)
06:53:46 <ski> cantora : on this vein, but not a `make'-thing : F[i]-shell <http://fishell.sourceforge.net/> is a shell that incorporates some ideas from Logic Programming
06:55:14 <cantora> ski: cool, definitely sounds interesting. yeah in my mind i was thinking someone could make a logic lang style shell language, in which one could re-implement make, and then some
06:55:37 <Aruro> cantora: he almost pointed you to Mercury language
06:55:54 <ski> cantora : namely, you can define "procedures" by matching (at least on the number of arguments, iirc). and you can easily create pipes, and pass them as arguments to the procedures, like you use arguments in LP for both input and output
06:56:05 <Aruro> cantora: Zoltan guy developed Mercury, i think
06:56:29 <ski> Aruro : yes, i said
06:56:44 <cantora> yeah ive read about mercury, but still need to sit down and try it out
06:56:52 <ski> and Fergus Hendersson and some others have also contributed
06:56:55 <cantora> definitely sounds interesting though
06:57:03 <ski> cantora : Boney in #mercury is one of the implementors
06:57:04 <Aruro> cantora: are you already enjoying Prolog?
06:57:34 <cantora> Aruro: yes ive enjoyed working with prolog very much
06:57:43 * ski . o O ( there's also ##prolog )
06:57:57 <cantora> havent done anything serious with it, but its been fun to learn
06:58:15 <Aruro> ski: more people in Haskell need to look at Prolog :) its fine :)
06:58:24 <ski> Aruro : yeah, i agree
06:58:46 <benzrf> what, exactly, is "elaboration", in the context of PL impls
06:59:10 <ski> Mercury has a modern module system (not as powerful as the MLs, though, but even Haskell doesn't have that either), a modern static type system (even with type classes), and a static mode and determinism system (for more LP-y parts)
06:59:29 <ski> benzrf : expressions evaluate, commands execute, declarations elaborate
06:59:45 <hpc> http://programmers.stackexchange.com/questions/141164/what-is-meant-by-elaboration-of-a-declaration-statement
06:59:51 <ski> benzrf : patterns match, lvalues locate
07:00:09 <hpc> aligators aligate
07:00:28 <benzrf> aha
07:00:29 <ski> goals solve
07:00:36 <benzrf> hpc: surely they allegate
07:02:19 <ski> benzrf : elaboration is determining a collection of identifiers, to bind to "computations" of the respective classes
07:03:19 <ski> e.g. binding a name to a type, or to an expression, or to an exception, or to a pattern, or to ...
07:04:21 <cantora> ski: what do ML module systems have that haskell doesnt?
07:04:43 <merijn> cantora: First class modules
07:04:53 <merijn> i.e. parameterised modules that can be composed
07:05:00 <int-e> long initialization times
07:05:16 <hpc> they reverse (:) and (::)
07:05:59 <hpc> cantora: first-class modules somewhat replace type classes
07:06:23 <hpc> it's not a perfect 1:1, as there's some things type classes do better
07:06:40 <hpc> and i am told some things that ML modules do better too, though i don't know enough to explain what those things are
07:07:13 <merijn> hpc: The ability to, e.g. writing modules that can work with both ByteString and lazy ByteString without duplicating code
07:07:59 <hpc> merijn: that could be done with type classes too, they just didn't
07:08:38 <cantora> are people still "working" on these MLs? is there a compiler i can get to try it?
07:09:09 <cantora> or is this theoretical? like a module system defined in a paper?
07:09:28 <ski> cantora : SML/NJ. OCaml
07:09:43 <ski> also #sml and #ocaml
07:09:57 <cantora> ski: ah, so OCaml has this first class module system?
07:10:14 <merijn> yes'
07:10:16 <srhb> cantora: MosML
07:10:18 <ski> (unfortunately the .NET ML, F# (see ##fsharp), doesn't have the module system)
07:10:23 <merijn> cantora: Google for ocaml functors
07:10:31 <merijn> (which are different from haskell functors)
07:10:46 <ski> cantora : there are several ML implementation. e.g MlTon,MlKit
07:11:07 <ski> srhb : heh, i met Peter Sestoft a week or two ago :)
07:11:16 <srhb> ski: Oh cool :-)
07:11:20 <ski> guest lecture
07:11:26 <srhb> ski: Is he still teaching at ITU?
07:11:40 <ski> i don't recall. the slides probably'll say
07:11:44 <srhb> Right right.
07:11:56 <ski> i got a "Java Precisely" book from him, with signature
07:12:19 <ski> (the guest lecture was on "Parallel Functional Programming in Java")
07:12:28 <srhb> Scary :-P
07:12:45 <cantora> nice, ill go check out all those ML langs, thanks everyone
07:13:34 <ski> srhb : <http://www.cse.chalmers.se/edu/year/2016/course/pfp/schedule.html> and <http://www.cse.chalmers.se/edu/year/2016/course/pfp/Material/Java/slides.pdf> says "Peter Sestoft, IT University, Copenhagen"
07:14:24 <srhb> ski: Alright :)
07:14:28 <ski> cantora : note that SML is one language, and OCaml it's sibling language. SML/NJ,MosML,Mlton,MlKit are all different implementations of SML
07:14:46 <cantora> ski: ah ok
07:15:25 <srhb> OCaml is a standard ML? I had no idea.
07:15:47 <ski> srhb : i thought i recognized the name, at the start, then after i while i recalled i'd seen the name in connection with Moscow ML and asked him about it. i also now see that he's done work in Partial Evaluation, and i think i may have seen the name in that connection as well
07:16:01 <ski> srhb : no, OCaml is not a Standard ML :)
07:16:22 <srhb> Oh, I read that completely wrong.
07:16:33 <ski> (neither is Alice ML,Caml Light,GCaml,O'Labl)
07:17:08 * ski doubts anyone uses the latter three
07:17:40 <ski> (i suppose Lazy ML should also be mentioned here)
07:17:47 <srhb> ski: Mosml used to be the ML of choice for the introductory programming language at university of copenhagen compsci. 
07:17:52 <ski> @where LazyML
07:17:53 <lambdabot> See `lml'
07:17:55 <ski> @where lml
07:17:56 <lambdabot> See `hbc'
07:17:59 <ski> @where hbc
07:17:59 <lambdabot> The Chalmers Haskell-B Compiler by Lennart Augustsson (augustss) at (darcs get) <http://www.cse.unsw.edu.au/~dons/code/hbc>,<http://darcs.augustsson.net/Darcs/hbc> -- Alternatively, the Hierarchical Bayes Compiler <http://www.cs.utah.edu/~hal/HBC/>
07:18:10 <hpc> ski: see LazyML ;)
07:18:33 <ski> srhb : yeah, i had a vague memory of that, i think
07:18:42 <ski> srhb : "used to be" ?
07:18:47 <srhb> ski: F# :/
07:18:52 <ski> that's a shame
07:18:54 <srhb> The travesty cannot be overstated.
07:19:02 <merijn> Could be worse
07:19:06 <merijn> Could be python/java
07:19:16 <ski> that's a bit like MIT not using Scheme with freshmen, but Python instead
07:19:25 <ski> merijn : i agree, it's better than Python
07:19:31 <ski> but still :(
07:20:51 <hpc> i think my ideal uni CS program would use a different language in every class
07:21:53 <merijn> hpc: Lemme tell you the "ideal" order of teaching PL that one of my colleagues suggested :p
07:22:05 <ski> srhb : we used to have Åke Wikström ("Functional Programming Using Standard ML") here teaching first year course in functional programming
07:22:50 <merijn> 1) Coq, 2) x86 ASM, 3) Haskell/Ocaml, 4) C, 5) something OO (smalltalk, scala) 6) Forth/APL or something
07:23:22 <Axman6> no Logo? disappointing
07:23:22 <ski> merijn : please, a nicer assembly than x86
07:23:36 <ski> merijn : also, needs logic programming
07:23:37 <Axman6> SPARC
07:24:29 <hpc> merijn: my mental image of your colleage is that they wear a diagonal striped bowtie, a beanie, an abercrombie hoodie, a kilt, and thick-rimmed glasses with no prescription
07:24:35 <Axman6> merijn: VHDL/Verilog imo are pretty useful for making programmers understand what their assembly costs
07:24:36 <ski> (we had SPARCs here, years ago. unfortunately i think they're all gone now)
07:24:42 <hpc> and those weird rubber toe-shoes
07:26:15 <Axman6> I quite enjoyed learning SPARC assembly, seemed less weird than ARM, while still being a usable real world architecture. had some nice features too. always thought the branch delay slot was cool, but have since heard they're more trouble than they're worth, despite giving you a free instruction
07:30:09 <merijn> hpc: None of those :p
07:30:44 <merijn> I do have a colleague with the weird toe shoes...
07:31:16 <hpc> heh
07:31:45 <hpc> i don't really have an ideal ordering, though i have some fuzzy opinions on what should be taught early vs later
07:32:53 <hpc> i do think every programmer needs to know a C-like language, an assembly language, some basics of transistors, a functional language, an object-oriented language, a variant of sql, prolog, an untyped scripting language, a theorem proving language, and all the crap that goes into parsing
07:33:19 <VoltzLive> It's been a while since I've been in here. 
07:33:23 <hpc> and more than a single course of each of them
07:33:27 <exio4> I would leave OOP to later on :P 
07:33:36 <hpc> especially sql
07:33:45 <merijn> Also, use Erlang/Smalltalk for OOP, not Java/C++/C#
07:34:03 <exio4> merijn: we did our OOP course in C++!
07:34:07 <VoltzLive> C++ for OOP? jesus 
07:34:53 <exio4> VoltzLive: indeed :P
07:35:26 <hpc> while i don't necessarily think everyone needs to know haskell specifically, it's pretty much the inevitable choice for the functional language since you also need to know a proof language - no other language would give you a smooth transition
07:36:17 <hpc> prolog is also conspicuously missing from the list of proof languages ;)
07:36:20 <exio4> Idris in a few years :P 
07:36:36 <ski> hpc : .. and Twelf
07:36:58 <ski> Mercury or Oz (perhaps) could also do for an LPL
07:37:19 <hpc> oh yes, and the languages you need to know is orthogonal to the techniques and concepts
07:37:35 <hpc> you could learn concurrency via haskell or via erlang at the same time as OO
07:37:51 <hpc> if you're feeling evil, you can slip some timing-related stuff into the hardware courses
07:38:49 <robtaylor> .
07:39:11 <ski> (but then some think that you ought to experience the pain of debugging non-statically-checked logic programming, before being able to better appreciate statically-checked logic programming)
07:39:15 <ski> (see "Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09|10) at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html>)
07:39:52 <ski> hpc : also i'd like to slip attribute grammars into the parsing and compilation stuff
07:40:21 <hpc> ski: yeah, i was thinking stuff like that as well
07:40:28 <hpc> ski: certainly not the lex/yacc that i learned :(
07:40:54 * ski recalls reading about recursive descent parsing in Pascal
07:40:55 <hpc> something a step above
07:41:27 <roconnor> is cabal configure -O2 the right way to turn on aggressive optimizations?
07:42:03 <dolio> Yes, I think so.
07:42:16 <roconnor> dolio: thanks!
07:42:30 <roconnor> it changes the binary, so that is a good sign.
07:42:41 <roconnor> the logs were a little opaque though.
07:43:11 <dolio> I'm not sure the binary changing is a reliable measure of GHC doing something genuinely different. :)
07:43:18 <ski> hpc : in an ideal world, they'd also learn about partial evaluation, staged programming, continuations, and also dataflow languages
07:43:57 <hpc> oh, i forgot one
07:44:04 <hpc> they need to lean spreadsheet programming
07:44:11 <ski> (in my mind, partial evaluations goes together with continuations)
07:44:26 <ski> hpc : well, dataflow :)
07:44:50 <hpc> ah yeah, it does fall under that family
07:45:38 <ski> for SQL, reading "The Third Manifesto" could be useful
07:45:39 <jophish> What constitutes 'learning' in this context?
07:45:42 <hpc> spreadsheet languages specifically because there's a lot you can do in excel or google docs if you know how to write table formulas
07:46:03 <ski> jophish : having at least a vague idea what it's about, it's strengths
07:46:46 <hpc> for a game group, i have dealt with spreadsheets that take several minutes to recalculate because of the logic involved
07:46:57 <Tekkkz> Hello! I have a dataype called: Task{valA :: String, valB :: String} ... so my question is: Now I have a list of Task ([Task]), how can I change the valB of the element which have "test" as valA and recreate the list with the changed item?
07:47:08 <hpc> and translating just one of those comes out to about 500 lines of sql in stored procedures, views, and functions
07:47:23 <scshunt> Tekkkz: use map
07:47:24 <ski> Tekkkz : that's the data constructor, not the name of the data type
07:47:30 <scshunt> also what ski said
07:47:33 <hpc> it's extremely different from normal programming
07:47:40 <hpc> more so than haskell
07:48:24 <ski> hpc : do you have any links to suggest ?
07:49:29 * ski recalls the "Single Assignment C" guy talked about expressing your algorithm "in space" rather than "in time", in order to enable auto-parallelization
07:49:49 <ski> Tekkkz : if you prefer, you could use a list comprehension instead of `map'
07:50:17 <hpc> ski: sadly no, just some insane spreadsheets i ended up helping to run for a while
07:50:34 <hpc> and they're mostly private because they're for pvp stuff
07:50:48 <ski> (iow, to compute factorial, don't make a loop (recursive or not). instead create an array of the desired numbers, and multiply it (using an operation which can fold in parallel))
07:51:05 <ski> @where PVP
07:51:05 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
07:51:05 <ski> ?
07:51:10 <hpc> player vs player
07:51:13 <ski> ok
07:51:18 <merijn> ski: Single Assignment C is more about writing everything using explicit matrix/array support and auto parallelising by, essentially fusing all matrix transforms very deeply
07:51:31 <ski> merijn : yep, i got that :)
07:51:49 <merijn> ski: Combined with the notion of matrix comprehensions and purity you can fuse that sorta stuff pretty deeply and easily auto-parallelise
07:52:07 <merijn> It's a shame they don't open source the compiler so that people would maybe consider actually using it :p
07:52:14 <ski> i just wondered how the "extremely different from normal programming" compared to that. iow still extremely different from that, or just quite different ?
07:52:42 <hpc> oh yeah, it's a lot like that
07:53:01 <merijn> SAC is pretty ordinary. They took great care to make people think it's C like
07:53:03 <Tekkkz> scshunt: to get the value I know how, but how to change it?
07:53:17 <hpc> it's like
07:53:24 <ski> Tekkkz : compute the changed value. make a new list collecting all the changed values
07:53:43 <Tekkkz> i see. So i drop this old one out of the list, append the new and resort
07:53:43 <hpc> if you write lisp in a particular style it's sort of like untyped haskell
07:53:45 <Tekkkz> right?
07:53:52 <hpc> but there's so much more weird stuff you can do with lisp
07:54:00 <hpc> spreadsheet programming is like untyped sql
07:54:03 <Tekkkz> ski: right idea?
07:54:08 <hpc> (or well, unstructured)
07:54:17 <ski> Tekkkz : no "drop this old one out of the list, append the new and resort" -- just `map' -- or a list comprehension
07:54:33 <hpc> you think very much in terms of data
07:54:37 <ski> Tekkkz : do it all in one go, don't remove and add elements to the list, one at a time, in a loop
07:55:03 <hpc> and particularly in terms of unstructured bulk data
07:55:07 <ski> hpc : interesting
07:55:24 <ski> hpc : how do you handle error cases ? don't handle them ?
07:55:45 <hpc> you usually let errors flow up
07:56:05 <ski> Tekkkz : *repeatedly* appending stuff to a list is needlessly inefficient. don't do that
07:56:22 <hpc> until you use some aggregation logic somewhere and you don't want the whole calculation to error from one cell
07:56:36 <ski> hpc : *nod*
07:56:48 <hpc> all the intermediate steps of the calculation are visible so it's generally quite obvious when you have bad data
07:56:58 <hpc> and you just fix it
07:57:24 <ski> @where adaptive
07:57:24 <lambdabot> "Adaptive Functional Programming" by Umut Acar,Blelloch,Harper in 2002 (POPL) at <http://www.umut-acar.org/publications/popl2002.pdf> and in 2006 (TOPLAS) at <http://www.umut-acar.org/publications/toplas2006.pdf>
07:57:26 <ski> @where incremental
07:57:26 <lambdabot> "Monads for Incremental Computing" (Functional Pearl) by Magnus Carlsson in 2002 (ICFP) at <http://www.carlssonia.org/ogi/papers/icfp-2002.pdf>,<http://www.carlssonia.org/ogi/Adaptive/>,in Hackage at <http://hackage.haskell.org/package/Adaptive>
07:57:41 <ski> i think is about applying such recomputation ideas from spreadsheets to functional programming
07:57:52 <hpc> neat
07:58:04 <hpc> i might find time to read those later
07:58:53 <ski> Tekkkz : i must go now. hopefully someone else can help you more, if needed
07:59:05 <scshunt> Tekkkz: \r -> r { field = value }
08:00:46 <dot_asp> Hello. I don't quite understand how Hackage libraries are structured. For example, what does Data.ByteString, Data.ByteString.Lazy and Data.ByteString.Char8 have in common? Why Data.ByteString.Builder is on the same level as Data.ByteString.Lazy ?
08:01:03 <roconnor> Is {-# UNPACK #-} !Integer worthwhile for bigints?
08:01:20 <srhb> dot_asp: "Not" -- really.
08:01:40 <meditans> what's the meaning of the constraint `(~) * a b`?
08:02:10 <dot_asp> Why are they grouped in one library?
08:02:33 <insitu> dot_asp that's a choice of the library's author(s)
08:03:03 <lyxia> meditans: it's usually written a ~ b (* is implicit), and means a and b are equal types
08:03:13 <dolio> roconnor: You can't unpack Integers, I think.
08:03:23 <dolio> So that does nothing.
08:03:45 <dolio> Well, the ! does something.
08:03:56 <meditans> lyxia: ok, could you explain the meaning of the version with *? I mean, how can it be left implicit in the other version?
08:04:01 <insitu> dot_asp a common pattern is to have "nested" packages which implement low-level details and are selectively exposed by a "parent" package
08:04:35 <lyxia> meditans: ~ is polykinded: it can express equality of types of different types
08:04:51 <lyxia> uh, of types of different kinds
08:04:57 <meditans> lyxia: oh, I see, thanks!
08:05:15 <dot_asp> What about greyed out libraries? The ones that have no docs?
08:05:30 <dot_asp> In a mature library.
08:05:57 <AdituV> are they all internal modules?  if so, just don't use them unless you know you need to :P
08:06:29 <lyxia> dot_asp: for some reason some libraries don't have their docs built, even though they could.
08:06:35 <insitu> dot_asp not sure what do you mean
08:06:50 <dot_asp> Data.ByteString.Builder.Prim.Internal like this
08:07:22 <dot_asp> Is it filled with private functions that shouldn't be used?
08:07:25 <AdituV> dot_asp: yes
08:07:55 <dot_asp> are those private functions used in its parent package?
08:08:06 <srhb> dot_asp: Parent package?
08:08:19 <AdituV> dot_asp: again, yes, the private functions are used in the parent module
08:08:23 <srhb> dot_asp: They are (in this case) used in the library, yes.
08:08:28 <srhb> dot_asp: They needn't be, though.
08:09:57 <srhb> dot_asp: As in, I'm not sure whether you're asking questions about this library or Hackage libraries in general.
08:10:15 <roconnor> dolio: makes sense.
08:10:16 <srhb> dot_asp: In general, Internal modules are not exposed (except when they are) but only contain functions intended for use by the library itself.
08:11:10 <dolio> roconnor: Until we get unboxed sums, unpacking sum types doesn't work, basically.
08:12:21 <dolio> In principle you could probably do it without unboxed sums, but I don't even know what level that would work at.
08:14:39 <dolio> Also I'm not sure it'd be worth it.
08:15:50 <Tekkkz> ok so how to do all in map at once? i don't understand. wasn't my solution idea ideal?
08:16:02 <greg`> how does one use QuickChecks coArbitrary to generate functions, i dont follow
08:16:07 <dolio> Like, the GMP binding isn't going to have worker-wrapper for all its functions, so all unpacking the integer would probably do is result in rebuilding the integer every time you want to call a function on it.
08:16:30 <roconnor> dolio: I understand.  I'm not familiar with the internal structure of Integer.  I didn't think UNPACK would be useful, but I thought I would check.
08:17:06 <dolio> And worker-wrapper for sum types without some more primitive thing seems non-trivial as well.
08:17:07 <srhb> Tekkkz: If you have a function, f, which does what you want for a single value...
08:17:14 <srhb> Tekkkz: Then `map f` does what you want for the whole list.
08:17:14 <dolio> Sure, just thinking things through out loud.
08:18:01 <lyxia> greg`: Coarbitrary gives you a way to perturb a random generator, it is unpredictable but deterministic.
08:18:22 <srhb> Tekkkz: If this doesn't seem right to you, then you might have described a different problem than what you intended to.
08:18:37 <Tekkkz> right. but I only know how to do it for finding out the right element (match value) but how to change the data in it at the same time?
08:18:42 <lyxia> greg`: when you use arbitrary to get a function, it takes a random generator, and every time you pass an argument it is used to perturb that generator in a way unique to this argument
08:18:49 * hackagebot hruby 0.3.3 - Embed a Ruby intepreter in your Haskell program !  https://hackage.haskell.org/package/hruby-0.3.3 (SimonMarechal)
08:21:44 <insitu> greg See this SO question: http://stackoverflow.com/questions/16214093/how-to-generate-random-typed-functions
08:22:08 <greg`> thanks lyxia, i see that but variant takes an n , so theres no way generic way to perturb the function really , unless haskell has some notion of typecode
08:23:46 <lyxia> greg`: Coarbitrary can be derived with haskell generics
08:24:07 <dot_asp> How can I know if importing a library will also include all its children functions? In sdl2, "import qualified SDL" is (probably?) enough to access every function that is listed in Hackage's index. While "import Data.ByteString" will (probably?) not call anything from Data.ByteString.Lazy.
08:24:16 <jameseb> Tekkkz: map will change each element according to the function you specify
08:24:43 <lyxia> greg`: so it's not as easy as a single polymorphic function but it's pretty close
08:26:22 <lyxia> dot_asp: a library (bytestring) may export multiple modules (Data.ByteString, etc)
08:26:35 <lyxia> dot_asp: "import" imports a single module
08:26:37 <enthropy> dot_asp: I don't think there's an easy way to tell. You could :browse SDL in ghci, and compare that list with the index page of the haddocks
08:27:25 <enthropy> by index page I mean http://hackage.haskell.org/package/bytestring-0.10.8.0/docs/doc-index-All.html
08:28:17 <sm> you can usually tell by what's visible in the hackage haddocks, no ?
08:28:41 <sm> oh, unless the author didn't write haddocks..
08:28:50 * hackagebot hjsonschema 0.10.0.0 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.10.0.0 (seagreen)
08:29:29 <insitu> dot_asp there is a reason why you would not want to expose all functions from "inner"  modules in a single toplevel module
08:29:57 <insitu> in the case of bytestring, you may want to use strict OR lazy ByteString, or even both
08:30:18 <insitu> which propagates to all "subpackages" like Char8 or Encioding
08:33:36 <joneshf-laptop> Is there some clickbaity "Pattern matches considered harmful" thing anywhere? I could've sworn I read this in the past, but cant find it now.
08:33:55 <scshunt> joneshf-laptop: why would pattern matches be harmful?
08:34:56 <joneshf-laptop> There might or might not have been a whole slew of examples in that thing I may or may not have read.
08:35:43 <joneshf-laptop> I feel lik eit wasn't specifically a haskell thing
08:36:23 <magneticduck> is there a shorter way to write (Typeclass a, Typeclass b) => .. ?
08:36:24 <joneshf-laptop> I've also heard people say in passing that if you're pattern matching, you're missing something.
08:36:33 <dot_asp> Is there an article for laymen explaining the bytestring library?
08:37:09 <dcoutts> roconnor: did you get your perf Qs answered?
08:38:03 <lyxia> magneticduck: {-# LANGUAGE ConstraintKinds #-} type TypeclassTwice a b = (Typeclass a, Typeclass b)
08:39:25 <dcoutts> roconnor: re unpacking, for future reference you can check yourself: ghci> :i Integer   You'll see it has two or three constructors (depending on your ghc/integer-gmp version). And the rule is single constructor data types can be unpacked, no others.
08:40:04 <dcoutts> so there's nothing special about Int or Integer, it's just one has a single constructor, the other has multiple.
08:40:19 <c_wraith> dcoutts, when did it pick up a third constructor? 
08:40:20 <jameseb> dot_asp: what do you need explaining about it?
08:40:47 <dcoutts> c_wraith: the integer-gmp with 7.10 changed the representation
08:41:38 <c_wraith> that long ago? huh. 
08:41:46 <dcoutts> c_wraith: it now uses positive or negative gmp bigint (as well as small Int#)
08:42:09 <c_wraith> why that particular change? 
08:42:22 <dcoutts> you'd have to ask the author
08:42:36 <dcoutts> it was a fairly major overhaul of the binding
08:43:06 <dcoutts> much of the changes were related to memory handling iirc
08:43:28 <dot_asp> Why ByteString is more efficient than the standard String implementation?
08:43:40 <dolio> Old integer-gmp had some rather weird stuff in it, too.
08:43:48 <dolio> Hopefully that got fixed.
08:43:56 <dcoutts> dot_asp: primarily a dense representation
08:43:58 <c_wraith> yeah, I remember that it was about making it cooperate with normal gmp much better, in terms of memory allocation. 
08:44:09 <StoneToad> dot_asp: because String is just [Char], a singly linked list of characters
08:44:13 <dolio> I think it made some benchmarks of alternatives a bit unfair for gmp.
08:44:15 <dot_asp> Oh
08:44:21 <c_wraith> dot_asp, String and bytestring really have nothing in common. 
08:44:35 <dcoutts> c_wraith: right, so that we don't have to set the gmp memory allocator
08:44:39 <c_wraith> dot_asp, bytestring is for binary data. 
08:45:02 <c_wraith> dot_asp, String is specifically for text. 
08:45:08 <dcoutts> as is Text
08:45:31 <c_wraith> yes, the difference between String and Text is much more fair of a question 
08:45:37 <dot_asp> getContents returns IO String, while hGetContents returns IO ByteString
08:45:41 <dcoutts> dot_asp: right, the direct replacement for String is Text, both are unicode
08:45:42 <dolio> Text is more specifically for text than String, even. :)
08:46:00 <magneticduck> oh jeez, why am I having so much trouble understanding the number typeclasses
08:46:05 <dot_asp> I'm using getLine as input 
08:46:07 <thoughtpolice> Right, so hvr actually did the integer-gmp rewrite to make the implementation a lot more sane in major areas. The main one was that we had to hook GMP's allocator to allocate data on the Haskell heap, but that had a lot of bad consequences.
08:46:18 <magneticduck> where's that flowchart with all of them, can't find it
08:46:28 <thoughtpolice> Now, all the actual allocation happens on the Haskell side, and GMP merely fills in buffers for us. So it's much more like a regular FFI library, in that regard.
08:46:34 <dot_asp> getLine is probably similar to getContents
08:46:37 <dcoutts> dot_asp: no, there standard version of hGetContents also returns String. But there are functions with these names also for Text and ByteString
08:47:34 <dcoutts> dot_asp: all three (String, Text, ByteString) share a very similar API, so you have to use qualified imports to select the right one.
08:47:39 <dolio> dcoutts: BTW, do you remember why all the fusion was removed from bytestring?
08:48:03 <c_wraith> thoughtpolice, do you know why Integer got a third constructor, offhand? 
08:48:23 <dcoutts> dolio: it was never added in any release. It was not a clear benefit in practice for bytestring, where as the same approach is beneficial for Vector. I think it's questionable if it's worth it for Text.
08:48:37 <dolio> Ah.
08:48:40 <dcoutts> dolio: it's just a question of what the common operations are.
08:49:08 <dot_asp> there's online programming practice problems that feeds a large input to, uh probably stdin. I tried using getLine but the site said I used too much memory.
08:49:21 <dcoutts> as the person who first added fusion to Text (by getting a masters student to do it), I rather suspect it's not worth it.
08:49:30 <dcoutts> there's certainly cases where it makes things worse
08:49:32 <dolio> :)
08:49:36 <thoughtpolice> c_wraith: It was a design/optimization question. See here: https://phabricator.haskell.org/D82
08:49:48 <c_wraith> thoughtpolice, thanks
08:49:52 <thoughtpolice> The TL;DR is, hvr did this so that you could exploit pointer tagging because 3 constructors fits in the tag bits even on 32bit machines.
08:49:56 <dot_asp> what kind of function should I use? and with which type?
08:49:59 <thoughtpolice> Rather than encoding the sign bit with another word or whatever
08:50:05 <thoughtpolice> This does mean you have to handle more cases, however.
08:50:41 <Lovepon> Urgh
08:50:49 <Lovepon> Sddm isn't starting anything.
08:50:51 <thoughtpolice> c_wraith: But it's more of just a design point, in the process of the overall integer-gmp rewrite (which is basically what it ended up being, despite being essentially compatible otherwise)
08:52:25 <dot_asp> do ByteString.Lazy and Conduit have something in common?
08:53:07 <dolio> dcoutts: It preempts certain concerns, at least.
08:53:51 * hackagebot libgraph 1.11 - Store and manipulate data in a graph.  https://hackage.haskell.org/package/libgraph-1.11 (faddegon)
08:54:39 <dolio> dcoutts: For instance, there was that utf-8 vs. utf-16 project a while back, and the report mentioned that it'd be advantageous to have 'toUTF8 . process . fromUTF8' not have to go through utf-16. But that's a completely moot point if 'process' is stream fusible.
08:55:28 <dcoutts> dolio: true
09:07:33 <roconnor> dcoutts: yep.  Thanks for the tip about :i Integer
09:34:26 <ZelteHonor_> Can someone help me?
09:34:38 <scshunt> Probably.l
09:34:58 <ZelteHonor_> I have a problem with hp2ps. I have 4 test. 3 generate a .ps file that I can perfectly read. But the fourth one generate a .ps file without complaining but when I try to open it failed saying invalid synthax.
09:35:46 <ZelteHonor_> hp2ps is a tool that convert heap profiling into postscript.
09:39:01 <NemesisD> hi all, having some trouble with free monads (using the free package). I've got a pure operation mkSource :: Foo -> Source m Bar. if I've got an interpreter ioInterp :: Free MyLangF a -> IO a, mkSource would have that m be IO
09:39:50 <NemesisD> i'm trying to figure out how to encode a constructor in the MyLangF ADT that can support this. its not running in the final monad but it has a type variable that references the final monad
09:40:26 <NemesisD> i seem to always hit this case, it seems like it may be impossible to have self-referential free monads when encoded this way?
09:40:41 <tzh> ZelteHonor_: this might be completely wrong guess, but when i had a problem like that the issue was that one of my profiling headers ended up like "reallyLongFunctionName(.." with the trailing ) cut off by length limits, and that apparently made something in the chain break. my fix was just to find&replace through the raw output file to add the close-parenthesis when it was needed
09:41:05 <tzh> ZelteHonor_: but who knows if your problem is the same
09:42:47 <ZelteHonor_> I'll try something like that. Thanks for the tip.
09:44:20 <ZelteHonor_> tzh: It worked!
09:44:50 <tzh> ZelteHonor_: hooray! yeah that was not a fun issue for me to debug, so glad i could save you the hassle :V
09:45:38 <ZelteHonor_> ^_^
09:49:28 <ZelteHonor_> This lead me to a new extremely problematic issue. I am using the graph library Fgl. And I am adding a huge number of edges in the graph. And that fill my memory.
09:57:25 <lyxia> NemesisD: how does your mkSource relate to your interpreter
09:59:01 <johnw> NemesisD: can you show us code?
10:01:16 <NemesisD> give me a few. i've gotten this tangled up a bit. i'm starting to see why this may be misguided
10:08:54 * hackagebot ref-fd 0.4.0.1 - A type class for monads with references using functional  dependencies.  https://hackage.haskell.org/package/ref-fd-0.4.0.1 (GeoffreyMainland)
10:11:54 <NemesisD> i think i've got it figured out! so i'm writing a small free monad over amazonka. amazonka has a typeclass AwsPager that can turn some request type into a Source of its corresponding responses
10:14:27 <NemesisD> so the operation i added was data MyLangF x = ... | Paginate DescribeAlarms (Source (Free MyLangF) DescribeAlarmsResponse -> x), which gets me paginate :: MonadFree MyLangF m => DescribeAlarms -> m (Source (Free MyLangF) DescribeAlarmsResponse)
10:15:49 <NemesisD> and i realized i can't just drop in amazonka's paginate for the real interpreter because the conduit must operate in the Free MyLangF monad, which is a much narrower subset of operations, so i just moved that paginate code into my own and specialized it to just use ops in my free monad
10:16:13 <ddflare617> https://github.com/WebParakeet/webp-octa-installer/issues/6 Can you help me fix this the code is here https://github.com/WebParakeet/webp-octa-installer/blob/master/octa-installer.sh
10:17:05 <NemesisD> it would be nice if I didn't have to specialize Paginate to DescribeAlarms, its fine for now but I think i could use a GADT if i wanted it generalized to anything with an AWSPager instance
10:18:54 * hackagebot exception-mtl 0.4.0.1 - Exception monad transformer instances for mtl classes.  https://hackage.haskell.org/package/exception-mtl-0.4.0.1 (GeoffreyMainland)
10:30:34 <bollu> hey guys
10:30:50 <bollu> I was looking for an intuitive way to think of Kan extensions
10:31:14 <bollu> I mean, what the hell are the 3 categories doing? and why do we say that "one functor is extended *along* another one"?
10:31:18 <Iceland_jack> bollu: Oh boy :)
10:31:21 <bollu> I'm not able to see what's happening
10:31:23 <bollu> Iceland_jack: :)
10:31:29 <bollu> Iceland_jack: this is hard, I take it? 
10:32:13 <Iceland_jack> Kan extensions are very abstract, are you familiar with examples of them for simple categories?
10:32:19 <bollu> Iceland_jack: nope
10:32:23 <Iceland_jack> Such as preorders
10:32:26 <bollu> Iceland_jack: I was just given the definition
10:32:40 <bollu> Iceland_jack: no, I don't really know what a Kan extension on a preorder would look like
10:32:43 <Iceland_jack> Right that's evil
10:32:56 <EvanR> whats up wit this: http://elm-lang.org/blog/farewell-to-frp
10:32:58 <bollu> Iceland_jack: can we pick a partial order? I'm more comfortable with them
10:33:53 <EvanR> hmm i was getting an error message
10:33:54 <Iceland_jack> I think you'll find the example from https://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf quite comfortable
10:34:20 <Iceland_jack>     An associative operation that is monotone and that has a neutral element.
10:34:57 <bollu> Iceland_jack: "netural" in the sense of ?
10:35:09 <Iceland_jack> Identity
10:35:50 <Iceland_jack> Integers equipped with multiplication *. It being a kan-extension means that
10:35:50 <Iceland_jack>       m * k <= n 
10:35:50 <Iceland_jack>     IF AND ONLY IT 
10:35:50 <Iceland_jack>       m <= n / k
10:36:38 <Iceland_jack> Beyond that I'm not sure I can help with intuition
10:36:54 <bollu> Iceland_jack: example of a preorder that is not a partial order?
10:37:12 <bollu> so a preorder is a relation that is reflexive and transitive?
10:37:50 <Iceland_jack> Yeah, exactly like a category has an identity element and composition
10:38:05 <Iceland_jack>     id  : a -> a
10:38:05 <Iceland_jack>     (.) : (b -> c) -> (a -> b) -> (a -> c)
10:38:26 <Iceland_jack> You have
10:38:26 <Iceland_jack>     refl  : a <= a
10:38:26 <Iceland_jack>     trans : (b <= c) -> (a <= b) -> (a <= c)
10:38:30 <bollu> Iceland_jack: but, what the hell, oh. hm. I'd never thought of (.) as "transitive". It's more of "composition" 
10:38:57 <bollu> soo an equivalence relation is also a preorder?
10:39:16 <bollu> Iceland_jack: what's a preorder that's not anything "stronger"? (like, say, partial order or equivalence relation)
10:39:28 <Iceland_jack> "On the other hand, if it is symmetric, that is, if a ≤ b implies b ≤ a, then it is an equivalence relation."
10:39:46 <Iceland_jack> Why are you looking for intuition on Kan extensions?
10:39:56 <bollu> Iceland_jack: because I want to understand Codensity
10:39:59 <bollu> and Density
10:40:02 <Iceland_jack> Do you have an intuition for functors and natural transformations and adjunctions?
10:40:19 <Iceland_jack> Because there is quite a bit of foundation it builds on
10:40:31 <bollu> Iceland_jack: yes. Functor -> map two categories faithfully. Natural transformation - "bundle of morphisms" that takes one functor to another faithfully
10:40:36 <bollu> adjunction -> "approximate inverses"
10:40:51 <Iceland_jack> Faithfully is not the word I'd use, "faithful" is actually a technical term
10:41:08 <bollu> Iceland_jack: heh, okay. so what is the right term? "naturally"?
10:41:15 <Iceland_jack> preserving structure
10:41:24 <bollu> soo "isomorphism"?
10:41:26 <Iceland_jack> no
10:41:44 <Iceland_jack> I also find your natural transformation inutition odd
10:41:50 <Iceland_jack> What is structure in a category?
10:41:59 <bollu> Iceland_jack: objects and arrows between the objects
10:42:07 <bollu> and between categories, you have functors
10:42:22 <Iceland_jack> Yes, objects and arrows are a part of their structure
10:42:27 <Iceland_jack> So functors preserve them
10:42:39 <Iceland_jack>     fmap id = id
10:42:39 <Iceland_jack>     fmap (f . g) = fmap f . fmap g
10:42:41 <bollu> right. So a natural transformation is a "mapping of functors"
10:43:08 <Iceland_jack> Yes
10:43:18 <bollu> so, f you have two functors f, g, then a natural transformation e is something that takes \all c \in C, { f(c) -> g(c) | c \in C}
10:43:29 <bollu> really terrible notation
10:43:36 <Iceland_jack> For preorders it's
10:43:36 <Iceland_jack>     forall x. f x <= g x
10:43:47 <Iceland_jack> where f/g are "functors" (monotone functions)
10:44:10 <bollu> yeah, monotone maps are the functors between partial orders (and I'm assuming pre-orders as well)
10:44:13 <Iceland_jack> In Haskell it's (kinda)
10:44:13 <Iceland_jack>     forall x. x -> x
10:44:13 <Iceland_jack>     forall x. [x] -> Int
10:44:23 <Iceland_jack> So the similarity is quite clear
10:44:24 <bollu> icedev: what is your intuition of a natural transformation?
10:44:34 <bollu> Iceland_jack: ^
10:45:08 <Iceland_jack> Some intuition is difficult to express, especially when you're not sober
10:45:09 <Iceland_jack> http://www.cs.ox.ac.uk/people/daniel.james/functor/functor.pdf
10:45:12 <bollu> hahaha
10:45:30 <Iceland_jack> This gives an interesting account of Functors, in an approchable way
10:45:37 <Iceland_jack> I would also play around with the Hask library
10:46:06 <bollu> Iceland_jack: I see.
10:46:11 <bollu> Iceland_jack: which one is that?
10:46:12 <johnw> you don't play around with Hask; it plays around with you
10:46:39 <bollu> Iceland_jack: and, well, what's the "right" way to think of natural transformations if not as a bunch of morphisms that convert the image of one functor into another?
10:46:45 <bollu> which makes sure the diagram commutes ofc
10:46:46 <Iceland_jack> bollu: It's hard for me to recommend it to you easily because it's incomplete and I don't know your GHC version or level of Haskell but...
10:47:00 <Iceland_jack> https://github.com/ekmett/hask/
10:47:13 <Iceland_jack> there have been a lot of changes in GHC 8 that make the library more intuitive
10:47:45 <amnn_> bollu, did you figure out the answers to the questions I left you with? (to do with limits)
10:47:46 <Iceland_jack> There natural transformations of functors are defined as
10:47:46 <Iceland_jack>     forall x. Object cat1 x => f1 x `cat2` f2 x
10:48:02 <bollu> amnn_: I just plopped down with a book and some water :)
10:48:06 <Iceland_jack> for functors
10:48:06 <Iceland_jack>     f1 : cat1 -> cat2
10:48:06 <Iceland_jack>     f2 : cat1 -> cat2
10:48:14 <bollu> amnn_: I'm trying them out now. 
10:48:26 <amnn_> ping me if you want hints
10:48:30 <bollu> amnn_: sure!
10:48:49 <bollu> I want to learn category theory properly over the summer
10:48:54 <bollu> like, undergrad level or something
10:49:07 <Iceland_jack> you can PM me if you want to shoot shit about CT
10:49:43 <Iceland_jack> The essance of natural transformations is not just the collection of arrows though
10:49:46 <Iceland_jack> but how they interact
10:51:03 <Iceland_jack> The diagrams show this better than words
10:51:03 <Iceland_jack>     F A ---(F h)--> F B
10:51:03 <Iceland_jack>      |               |
10:51:03 <Iceland_jack>     f @A            f @B
10:51:06 <Iceland_jack>      V               V
10:51:09 <Iceland_jack>     G a ---(G h)--> G B
10:51:46 <bollu> where @ is the natural transformation?
10:51:50 <bollu> Iceland_jack: ooh, I will 
10:51:53 <Iceland_jack> mm no, @ is just Haskell syntax
10:52:00 <amnn_> f is the natural transformation
10:52:00 <Iceland_jack> in GHC 8 allowing TypeApplications
10:52:04 <Iceland_jack> Yes
10:52:09 <bollu> wait what? o_O
10:52:09 <Iceland_jack>     f :: forall x. F a -> G a
10:52:11 <bollu> @ is syntax?
10:52:17 <monochrom> new syntax :)
10:52:19 <bollu> so what is @A?
10:52:19 <Iceland_jack> Then
10:52:19 <Iceland_jack>     f @A :: F A -> G A
10:52:20 <amnn_> Iceland_jack, that's cool I didn't realise that was coming in GHC 8
10:52:22 <bollu> what does it do?
10:52:25 <Iceland_jack> and
10:52:25 <Iceland_jack>     f @B :: F B -> G B
10:52:43 <Iceland_jack> That's right! My Category Theory diagrams use GHC 8 features
10:52:44 <amnn_> bollu, it instantiates a universally quantified type, it seems
10:52:52 <Iceland_jack> We've gone in many circles now
10:53:05 <monochrom> You have seen "id :: a -> a", in which "a" is a type variable. if you want to specialize it to "Int -> Int", you used to write "id :: Int -> Int". today you can write "id @ Int" too.
10:53:20 <bollu> monochrom: ohhh, I see. 
10:53:42 <bollu> amnn_: right, now your sentence of "iinstantiates a universally quantified type" makes sense after the example :)
10:53:57 <Iceland_jack> bollu: also the classic "show . read"
10:54:06 <Iceland_jack> can be
10:54:06 <Iceland_jack>     show . read @Float
10:54:34 <hpc> well, i officially can't wait for GHC8 now
10:54:54 <bollu> Iceland_jack: in your commuting diagram, where are the functors?
10:55:03 <amnn_> bollu, F and G
10:55:03 <Iceland_jack> bollu: F and G usually denote functors
10:55:28 <Iceland_jack> But keep in mind that "id" is a natural transformation (depends on what your definition of the word "is" is)
10:55:33 <monochrom> and with "const :: a -> b -> a", you can now write "const @ Int @ Bool".
10:55:39 <Iceland_jack> but there are seemingly no functors
10:55:45 <monochrom> soon, you will feel like @_@ :)
10:55:52 <Iceland_jack> hah
10:56:12 <Iceland_jack> You just view
10:56:12 <Iceland_jack>     id :: a -> a
10:56:12 <Iceland_jack> as
10:56:12 <Iceland_jack>     id :: forall a. Identity a -> Identity a
10:56:12 <bollu> hmm, so you're considering mappings from F A -> F B? because you've first lifted a lower mapping from (A -> B) to (F A -> F B)?
10:56:15 <monochrom> hpc: I am so impatient, I installed RC4
10:56:41 <bollu> hmm, explaining Haskell to newbies will be harder now. Not that I know a lot of Haskell myself :P
10:56:43 <hpc> Iceland_jack: btw you gave me an idea for another acme module
10:57:01 <Iceland_jack> bollu: Why?
10:57:01 <hpc> acme-naturaltransformations, a library of natural transformations that are all implemented with unsafeCoerce
10:57:13 <hpc> like listToMaybe and whatnot
10:57:15 <bollu> Iceland_jack: more features?
10:57:27 <Iceland_jack> bollu: Well I will argue this will help
10:57:27 <amnn_> bollu, you don't have to introduce them all at once though
10:57:30 <Iceland_jack> :t length
10:57:32 <lambdabot> Foldable t => t a -> Int
10:57:38 <Iceland_jack>     length @[] :: [a] -> Int
10:57:39 <Iceland_jack>     
10:57:45 <Iceland_jack>     length @[] @Bool :: [Bool] -> Int
10:57:46 <Iceland_jack>  
10:58:17 <amnn_> Iceland_jack, how is the parameter order determined? is it left to right in the type itself?
10:58:24 <bollu> Iceland_jack: ooh, but what if I want to specialize t Bool -> Int?
10:58:33 <Iceland_jack> bollu: length @_ @Bool
10:58:45 <bollu> Iceland_jack: ahh, neat
10:58:51 <Iceland_jack> amnn_: There are some tricky and conservative rules that they use to determine
10:58:52 <monochrom> you know what, even when I was a newbie, 50% of the time I wanted a way to write "I'm using a:=Int here"
10:59:12 <Iceland_jack> you generally have to specify a type signature to it
10:59:33 <amnn_> seems sensible
10:59:43 <Iceland_jack> So '(id id) @Int' doesn't work
11:00:00 <bollu> Iceland_jack: in your diagram, h :: A -> B right?
11:00:02 <Iceland_jack> this is sometimes annoying but makes it more stable
11:00:04 <Iceland_jack> that's right bollu 
11:00:09 <bollu> and (F h :: F A -> F B)
11:00:37 <Iceland_jack> The definition of Functor in hask is quite beautiful
11:00:46 <bollu> hm, so the natural transformation is something such that you can either go from F A -> G A and then apply F h. Or you can apply F h and then go to G 
11:01:18 <Iceland_jack>     class (Category (Dom f), Category (Cod f)) => Functor (f :: i -> j) where
11:01:18 <Iceland_jack>       type Dom f :: Cat i
11:01:18 <Iceland_jack>       type Cod f :: Cat j
11:01:18 <Iceland_jack>       fmap :: Dom f a a' -> Cod f (f a) (f a')
11:01:28 <nitrix> Does that mean we're headed towards explicit quantification?
11:01:30 <Iceland_jack> Exactly bollu
11:01:32 <nitrix> Agda :P ?
11:01:54 <bollu> Iceland_jack: okay, now how does this fit with the world view of a "collection of morphisms"?
11:02:06 <bollu> as in, "every natural transformation is a collection of morphisms"?
11:02:23 <bollu> I'm guessing it's (f @A) \cup (f @B)?
11:02:25 <Iceland_jack> bollu: The collection is
11:02:25 <Iceland_jack>     F Int  -> G Int
11:02:25 <Iceland_jack>     F ()   -> G ()
11:02:28 <Iceland_jack>     F Bool -> G Bool
11:02:38 <Iceland_jack> But if that were the only requirement it would be pretty useless
11:02:50 <monochrom> I think we're headed towards taking in all ideas from Agda except termination proofs.
11:02:50 <EvanR> .oO(natural transformation is an indexed family of morphisms?)
11:03:28 <amnn_> yes, indexed by objects in the domain category
11:03:49 <amnn_> (but not just an indexed family)
11:03:51 <bollu> oh, I assumed it was indexed in the image
11:03:55 <bollu> hmm
11:03:56 <Iceland_jack> the most interesting part is how they relate
11:04:03 <bollu> so what about the morphisms in the image?
11:04:06 <bollu> where do you get those from?
11:04:15 <monochrom> "GHC combines the static flexibility of Agda and the dynamic safety of Haskell"
11:04:20 <bollu> the F B -> G B part?
11:04:24 <amnn_> bollu, the morphisms are in the image, they are indexed in the domain
11:04:59 <EvanR> for each object in the domain there is a morphism in the codomain
11:05:07 <bollu> amnn_: hm, then I'm using the word "indexed" wrong. Indexed in the sense of "axiom of choice indexing set" correct?
11:05:23 <bollu> EvanR: ah, thanks
11:05:25 <EvanR> i shouldnt have said that, its really just a "functional" relationship
11:06:24 <amnn_> bollu, yes, or a generalisation of that, because a categories objects may form a structure larger than a set
11:06:32 <amnn_> *category's
11:06:51 <EvanR> or just forget sets when talking about categories
11:07:08 <EvanR> you could think of categories in the form of dependent types instead
11:08:12 <HallaSurvivor> Hey, does anyone know how to use GLUT with the state monad?
11:08:43 <HallaSurvivor> All I can find are examples using IORef
11:09:00 <EvanR> GLUT (StateT S IO)? ;)
11:09:23 <EvanR> just kidding
11:09:24 <Iceland_jack> IORef (StateT S IO a)!
11:11:03 <hpc> heh, the GLU transformer
11:11:23 <bollu> so for every element in F A, there is a morphism from F B -> G B?
11:12:13 <amnn_> bollu, F A is an object, when speaking generally of categories, we cannot "peer into it", it is an indivisible entity.
11:12:26 <kardun> hi guys, can someone guide me and im fairly new to haskell. ive created a mathematical 'function' (if thats what you call it) sort (((A-(A∩B)) ++ (B-(A∩B)))
11:12:30 <EvanR> for every A in C there is a morphism F A -> G A
11:12:32 <EvanR> in D
11:13:10 <kardun> ill make a better paste, w8
11:13:19 <Iceland_jack> bollu: Read what EvanR said and this side by side
11:13:19 <Iceland_jack> <Iceland_jack> There natural transformations of functors are defined as
11:13:19 <Iceland_jack> <Iceland_jack>     forall x. Object cat1 x => f1 x `cat2` f2 x
11:13:19 <Iceland_jack>  
11:13:22 <EvanR> such that for every other object in C...
11:13:34 <bollu> amnn_: oh, wait, aren't you allowed to "check out" the things inside a category for its objects and arrows?
11:13:39 <bollu> isn't F A a category?
11:13:40 <bollu> from A 
11:13:41 <bollu> ?
11:13:51 <bollu> like, (A -> B) was lifted to (F A -> F B)?
11:13:59 <amnn_> if F is a functor, then F A is an object
11:14:00 <Iceland_jack> I think you need to get to the basics 
11:14:13 <Iceland_jack> Kan extensions come way after this
11:14:50 <Iceland_jack> (no offense meant, it's just necessary groundwork)
11:14:54 <EvanR> bollu: F A is an object in D
11:14:55 <bollu> yeah, I understand
11:15:18 <amnn_> but yes, you are right, you can unpack a category to "check out" its objects and arrows
11:15:21 <bollu> EvanR: where D is the category?
11:15:30 <EvanR> D is the second category in question here
11:15:35 <bollu> EvanR: the commuting diagram doesn't even mention the category!
11:15:41 <EvanR> but this does
11:15:51 <bollu> "this" being?
11:15:54 <amnn_> bollu, the entire diagram is in "D space"
11:15:58 <EvanR> a natural transformation between two functors F : C -> D, and G : C -> D
11:16:03 <EvanR> is
11:16:05 <EvanR> ...
11:16:13 <kardun> okay i created a more readable paste http://lpaste.net/738452431783854080
11:16:44 <amnn_> kardun, have you tried using Set, instead of lists?
11:16:48 <bollu> ahh, right. I was missing that part. I assumed the "A" and "B" were categories and we were talking about the "natural transformation between categories" as a whole rather than objects
11:16:55 <bollu> thanks for the clarification :)
11:17:12 <Iceland_jack> Categories involved: 2
11:17:12 <Iceland_jack>   Functors involved: 2
11:17:23 <Iceland_jack> And the functors are parallel
11:17:24 <bollu> Iceland_jack: can I re-state from the beginning what I know?
11:17:28 <Iceland_jack> Sure!
11:17:31 <bollu> so, you have two categories C and D
11:17:38 <bollu> and two functors F: C -> D and G: C -> D
11:17:46 <shachaf> Maybe you would have an easier time if you mentally substituted "diagram" for "functor".
11:17:50 <kardun> oh. i haven't started with Sets yet amnn_ i thought i could implement it. ill take a look at it
11:17:54 <bollu> now, a natural transformation e is a "mapping of functors" F and G
11:18:16 <amnn_> kardun, http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Set.html . If you don't want to use sets, then the `nub` function gets rid of duplicates
11:18:17 <EvanR> its a mapping of objects in C to morphisms in D
11:18:28 <bollu> EvanR: hmm
11:18:28 <Iceland_jack> bollu: Where does this mapping exist?
11:18:32 <EvanR> with type F A -> G A
11:18:45 <bollu> Iceland_jack: between the functors? that's how we draw it in diagrams
11:18:51 <kardun> thanks amnn_ i actually need those duplicates
11:19:00 <Iceland_jack> bollu: Between the functors doesn't convince me :)
11:19:25 <amnn_> kardun, in your paste, it says you get [1,1,2,2], and you want [1,2] ?
11:19:26 <bollu> Iceland_jack: it is an arrow in the "category of functors"?
11:19:47 <Iceland_jack> mm no, functors are arrows in the category of functors
11:19:51 <Iceland_jack> I think you're mixing levels
11:20:00 <bollu> Iceland_jack: possibly
11:20:06 <amnn_> Iceland_jack, functors are arrows in the category of categories
11:20:09 <Iceland_jack> or well, no
11:20:20 <Iceland_jack> right
11:20:34 <Iceland_jack> The mapping doesn't reside there though
11:20:49 <Iceland_jack> as EvanR said, the components of the natural transformation are in the category "D"
11:21:21 <EvanR> bollu: here is a diagram i made to begin to explain natural transformations http://imgur.com/Q6jsC6b the ?_A is the natural transformation applied to A
11:21:33 <EvanR> the next slide explains the property of ? that matters
11:21:48 <EvanR> which involves duplicating and overlaying this diagram, which im not sure youre ready for ;)
11:22:08 <kardun> lets say i have an array [3,4,5,6,7,8,4,5,6] [3,4,4,5,6,7,5,8,3,6,5,6,4] the output i expect should be [4,5,6] more likely B-A
11:22:12 <bollu> Iceland_jack: the type of a natural transformation is nat :: F C -> (F D -> G D) correct? that is, for one element of "F C", it creates a morphism from f(c) to the corresponding g(c)
11:22:47 <EvanR> sorry, the notation is not coincident here with A B F G C D
11:22:56 <amnn_> bollu,  a natural transformation has type forall a. F a -> G a.
11:23:04 <kardun> the current solution i made using the code in paste gives me an output of [3,4,5,6]
11:23:09 <bollu> amnn_: but the a should be inside C!
11:23:19 <EvanR> forall a :: C . F a -> G a
11:23:22 <Iceland_jack> bollu: amnn_ And it is
11:23:30 <Iceland_jack> the 'F' maps C's to D's
11:23:39 <amnn_> yes, but in Haskell, there is only one category, Hask, and all functors are endofunctors
11:23:40 <Iceland_jack>       A : C
11:23:40 <Iceland_jack>     -------
11:23:40 <Iceland_jack>     F A : D
11:24:01 <EvanR> restricting to hask is probably confusing at this point
11:24:37 <amnn_> yes, I'm not sure the haskell based intuition is necessary useful for natural transformations, perhaps it is just an interesting side point after the concept's been understood
11:26:01 <bollu> hmm
11:27:23 <Iceland_jack> bollu: If you read the paper F for Functor you'll find the part about function application interesting
11:27:34 <bollu> okay, so, a natural transformation e = f:: F C -> G C, e(F(c)) -> G(c) forall c \in C?
11:27:36 <Iceland_jack> *functor
11:27:52 <EvanR> F : C -> D, remember this means two things, a mapping of objects like F A, and a mapping of arrows in C to arrows in D
11:28:35 <EvanR> you can similarly type a natural transformation like u : F => G, but it is simpler in this case in that it only makes objects in C to morphisms in D
11:28:52 <EvanR> u A : F A -> G A
11:29:31 <bollu> EvanR: but it's not exactly the "morphisms in D" right? it's objects in C to morphisms from F D to G D
11:29:49 <EvanR> it is nonetheless morphisms in D
11:29:56 <EvanR> F D is not well typed
11:30:15 <EvanR> so nevermind the nonetheless
11:31:21 <EvanR> F A -> G A is exactly morphisms in D
11:31:36 <bollu> EvanR: where A \in C?
11:31:40 <EvanR> yep
11:32:32 <Iceland_jack> bollu: Keep in mind that there is no "object" there yet
11:33:15 <bollu> Iceland_jack: what does that mean? >_<
11:33:19 <EvanR> u can be applied to any A : C
11:33:33 <EvanR> in haskell youd probably not use capital A for that
11:33:34 <Iceland_jack> Natural transformations assign an object Int to a component of the NT (Int -> Int)
11:33:51 <Iceland_jack> <Iceland_jack> bollu: If you read the paper F for Functor you'll find the part about function application interesting
11:34:53 <Iceland_jack> "This suggests that an arrow (a : F -> G) in D^C sends an object A of C to an arrow (a @A : F A -> G A) in D."
11:36:39 <bollu> Iceland_jack: on it :)
11:36:42 <bollu> reading the paper that is
11:37:03 <Iceland_jack> Applying Int to a functor, is itself a functor. 
11:37:03 <Iceland_jack> Applying Int to the object component:
11:37:03 <Iceland_jack>     F : Hask -> Hask
11:37:03 <Iceland_jack>     ----------------
11:37:06 <Iceland_jack>     F Int : Hask
11:37:08 <bollu> I find it weird that he uses bra-ket for templates though (\langle and \rangle) why not use  <T>?
11:37:25 <Iceland_jack> Templates?
11:37:38 <bollu> interface Function<T>
11:37:43 <Iceland_jack> In the Java code?
11:37:46 <bollu> yes
11:38:03 * Iceland_jack fart noises
11:38:14 <bollu> ? -_^
11:38:22 * EvanR cracks a window
11:38:31 <Iceland_jack> *noises*
11:39:34 <Iceland_jack> Applying Int to the arrow component is, what I believe, you were asking:
11:39:34 <Iceland_jack> Say we have a natural transformation 'listToMaybe : [] ~>Maybe' 
11:39:34 <Iceland_jack>  
11:39:34 <Iceland_jack>     listToMaybe : [] ~> Maybe
11:39:37 <Iceland_jack>     -------------------------------------
11:39:40 <Iceland_jack>     listToMaybe @Int : [Int] -> Maybe Int 
11:40:05 <Iceland_jack> So the natural transformation doesn't care about the a's or the Int's, it's all about those functors
11:41:18 <bollu> ah
11:41:19 <bollu> hm
11:41:35 <Iceland_jack>     type f ~> g = forall x. f x -> g x
11:41:43 <bollu> so the natural transformation is about F -> G, since it doesn't care "on what" the functor is instantiated on
11:41:55 <bollu> right, "works for all x"
11:42:00 <Iceland_jack> Yeah, it just has to satisfy the coherence condition
11:42:06 <bollu> is that a legit Haskell type BTW?
11:42:09 <bollu> the (~>)
11:42:09 <Iceland_jack> yes
11:42:12 <bollu> nice
11:45:02 <johnw> another way to phrase it is that the natural transformation is irrespective of objects
11:50:53 <bollu> the preorder to monoid mapping is particularly clever
11:51:20 <Iceland_jack> Yes it's quite a strange example if all you're used to is Haskell's Functor
11:51:31 <bollu> mapping from any category to 1: Map every object to 1, and map every morphism to id_1. Correct?
11:52:23 <Iceland_jack> Let me read it, that sounds odd
11:52:31 <opqdonut> bollu: yes
11:53:41 <Iceland_jack> The Functor itself is between preorders and monoids, what did you mean by "mapping from any category to 1"?
11:54:28 <dfeuer> bgamari, and everyone else, do you have an opinion on whether it should be lens-at-style alterF :: (Ord k, Functor f) => k -> (Maybe v -> f (Maybe v)) -> Map k v -> f (Map k v) or Data.Map.alter-style alterF :: (Ord k, Functor f) => (Maybe v -> f (Maybe v)) -> k -> Map k v -> f (Map k v) ? I've heard from about one person on each side of the issue.
11:54:32 <Iceland_jack> For ‘types’ (objects) it maps everything to "1"
11:54:53 <Iceland_jack> dfeuer: I would vote lens style
11:55:02 <dfeuer> Iceland_jack, may I ask why?
11:55:42 <dfeuer> I'm happy to do that; I just want to hear a good justification to explain myself to posterity when asked why the Data.Map API is oddly inconsistent in that corner.
11:55:44 <Iceland_jack> Outside of lens I think the function wouldn't be used directly by users, it would mostly be used to implement other functions. 
11:56:03 <Iceland_jack> (I was just reading the mailing list for the 3rd time yesterday actually, funny you bring this up)
11:56:23 <Iceland_jack> I think its use is mostly being composed with other lenses
11:56:39 <dmj`> EvanR: ping
11:57:02 <dolio> Which argument is most likely to be partially applied?
11:57:29 <dfeuer> dolio, I would say the map.
11:57:47 <dfeuer> Which under either of these orders is the *last* argument.
11:57:48 <dolio> You would?
11:58:10 <Iceland_jack> Oh interesting
11:58:19 <dfeuer> I would guess that Data.Map is most often in reality used in a single-threaded fashion, with one map running through.
11:58:26 <dfeuer> Could be wrong.
11:58:40 <dolio> Then I don't understand your answer.
11:58:45 <dfeuer> If not the map, then probably the function.
11:59:03 <Iceland_jack> A good rule of thumb is to return transformations
11:59:05 <dolio> Because partially applying alterF to a map means you're going to alter the same map in multiple different ways.
11:59:10 <Iceland_jack>     map :: (a -> b) -> ([a] -> [b])
11:59:16 <dfeuer> dolio, oh, I'm being ridiculous.
12:00:23 <dfeuer> The function is most likely to be partially applied, I guess, which leans towards the Data.Map.alter style rather than the lens style.
12:01:07 <dolio> I'm not sure that's the answer I'd pick, but it's the criterion I'd use.
12:01:17 <dfeuer> dolio, what do *you* think?
12:02:03 <dolio> I think the key is most likely, in that this is expected to be used in composition of lenses, and like Iceland_jack, I'm not sure who else would use it.
12:02:12 <Iceland_jack>  
12:02:12 <Iceland_jack> dfeuer: In the case of 'alterF' I don't see an obvious argument order so that's one of the reasons why I lean towards lens
12:02:13 <dolio> But I haven't thought about it very long.
12:02:55 <dolio> It's also not really a lens lens, though, so maybe that doesn't even matter.
12:03:08 <Iceland_jack> Maybe
12:03:11 <dfeuer> How's it not a lens?
12:03:25 <dolio> It's not using profunctors instead of arrows.
12:03:44 <dfeuer> A lens uses arrows. lens has other stuff with profunctors.
12:03:45 <dolio> So it's not exactly the type lens uses for lenses.
12:03:53 <Iceland_jack> Wait is that a condition on lenses?
12:04:01 <dfeuer> Isos use profunctors, I think.
12:04:21 <dfeuer> type Lens s t a b = forall f . Functor f => (a -> f b) -> s -> f t
12:04:28 <Iceland_jack>     Lens s t a b = ∀f. Functor f => (a -> f b) -> (s -> f t)
12:04:29 <dfeuer> That's the lens definition of Lens.
12:04:44 <dfeuer> And this is what it calls a Lens':  Lens' s a = Lens s s a a
12:05:18 <dolio> Oh, in that case, the argument has more weight.
12:05:21 <Iceland_jack>     alterF :: Ord k => k -> forall f. Functor f. (Maybe v -> f (Maybe v)) -> (Map k v -> f (Map k v))
12:05:21 <Iceland_jack> is
12:05:21 <Iceland_jack>     alterF :: Ord k => k -> forall f. Functor f. Lens' (Map k v) (Maybe v)
12:05:21 <Iceland_jack>  
12:05:28 <dfeuer> alterF :: Ord k => k -> Lens' (Map k v) (Maybe v)
12:05:32 <Iceland_jack> oops
12:05:39 <Iceland_jack>     alterF :: Ord k => k -> Lens' (Map k v) (Maybe v)
12:05:39 <Iceland_jack>  
12:05:48 <Iceland_jack> didn't remove constraints
12:06:48 <dfeuer> We could also have   updateF :: Ord k => Lens (Map k v) (Map k v) v (Maybe v)  if we wanted.
12:07:07 <dfeuer> Err ... updateF :: Ord k => k -> Lens (Map k v) (Map k v) v (Maybe v)  if we wanted.
12:07:22 <Iceland_jack> I believe that goes against making the two pairs be families
12:07:47 <dfeuer> Iceland_jack, the what be who?
12:08:17 <Iceland_jack> pff I need to work myself up to Googling that
12:08:42 <dfeuer> Oh, updateF is not a proper lens or something? I can easily believe that.
12:09:07 <dfeuer> It probably isn't one. alterF should be just fine though.
12:09:32 <Iceland_jack> I think it's mentioned http://comonad.com/reader/2012/mirrored-lenses/
12:09:36 <dfeuer> Er ... sorry, I guess updateF wouldn't be a lens of any sort; it'd have to be a traversal.
12:09:45 <Iceland_jack> "I'd like to note that you can't just let these 4 arguments vary with complete impunity, so I'll be referring to these as "lens families" rather than polymorphic lenses, a point that I'll address further below."
12:09:55 <dfeuer> Yeah.
12:10:11 <Iceland_jack> Sometimes I get impatient when I type
12:10:16 <Iceland_jack> and I just want to get the sentence over with
12:10:23 <dolio> It's not going to be a valid traversal, though.
12:10:59 <dfeuer> I'm not thinking about updateF right at the moment. I'm thinking about alterF, which is "at" for maps. I might also consider adjustA, which would be "ix".
12:13:48 <bizarrefish> Hi all.
12:14:09 <Iceland_jack> dfeuer: My core reason is that its connection to lens is too strong to ignore, but it's more of an appeal to emotion :)
12:14:22 <bizarrefish> So, given that monads are monoids in the category of endofunctors...return, the unit of the monoid, must be an endofunctor; what is the category of that endofunctor?
12:14:33 <shachaf> No, the monad is the endofunctor.
12:14:33 <dfeuer> Iceland_jack, well, if that's how most people who care about it feel about it, I'm fine with that.
12:14:55 <shachaf> return is a natural transformation, i.e. an arrow in the category of endofunctors.
12:15:04 <dfeuer> An endofunctor category has categories as objects.
12:15:07 <dfeuer> no.
12:15:18 <dfeuer> Has endofunctors as objects.
12:15:20 <dfeuer> I'm really out of it.
12:16:00 * dfeuer goes out.
12:16:41 <phadej> https://en.wikipedia.org/wiki/Monoid_(category_theory)
12:17:15 <phadej> unit and join are morphism, which in endofunctor category are natural transformations
12:17:16 <bizarrefish> So, return is an arrow, rather than an object.
12:17:21 <Iceland_jack> Yeah
12:17:23 <Iceland_jack>     return :: Monoid => a -> m a
12:17:23 <Iceland_jack>  
12:17:33 <Iceland_jack>     type Arr m a b = a -> m b
12:17:36 <bizarrefish> It associates one endofunctor with another endofunctor
12:17:38 <Iceland_jack> *Monad
12:17:38 <Iceland_jack>  
12:18:20 <Iceland_jack>     return :: Monoid => (Arr m) a a
12:18:36 <Iceland_jack> gah, just guess the right constraints
12:18:58 <phadej> bizarrefish: yes, Identity and 'm'
12:18:58 * hackagebot OpenGLRaw 3.2.0.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-3.2.0.0 (SvenPanne)
12:19:43 <phadej> I kind of get what that means, but I have no clue what to do with that knowledge
12:20:00 <Iceland_jack> :t (>=>)
12:20:01 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:20:04 <Iceland_jack> :t return >=> return
12:20:06 <lambdabot> Monad m => c -> m c
12:20:32 <amnn> Iceland_jack, it seems that you are describing the Kleisli category of a monad
12:21:12 <amnn> where return is the identity morphism, and (>=>) is the composition of morphisms
12:21:46 <Iceland_jack> Yeah
12:22:03 <Iceland_jack> not what was asked
12:22:27 <amnn> yeah, that's what I was thinking. Interesting all the same though
12:24:31 <bizarrefish> So hang on, if I'm getting this straight. The kleisli arrow is *the* arrow in the category of endofunctors. Endofunctors + Kleisli arrows obey the monoid laws, hence monoid.
12:24:36 <lpaste> sam revised “f”: “f” at http://lpaste.net/563504090101841920
12:24:40 <bizarrefish> Am I talking garbage?
12:24:41 <bizarrefish> :/
12:24:49 <lpaste> sam revised “f”: “f” at http://lpaste.net/563504090101841920
12:26:11 <bollu> Iceland_jack: I was referring to the unique map from every category to 1
12:26:13 <bollu> back then
12:27:22 <amnn> bizarrefish, I don't think that's quite right
12:27:40 <shachaf> bizarrefish: No, Kleisli arrows don't get involved in this definiton at all.
12:27:52 <amnn> kleisli arrows are the morphisms in the kleisli category of a monad, which was something separat
12:27:54 <amnn> *separate
12:29:26 <amnn> bizarrefish, have you seen this: http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html ? Maybe it will help
12:29:30 <bizarrefish> So the monad has return, which associates identity with m. The monad also has join, which is an endofunctor from m m to m
12:29:53 <bizarrefish> Wait, no. join associates m m endofunctor with m endofunctor
12:29:55 <bollu> for a functor from category to Set, map every object in category to some point in Set. Map Hom(A, B) to some function from image of A to image of B
12:31:09 <amnn> bizarrefish, yes
12:32:15 <amnn> join is a natural transformation M . M => M. Here functor composition takes the place of monoidal product
12:33:59 * hackagebot network-hans 0.2 - HaNS to Network shims for easier HaNS integration  https://hackage.haskell.org/package/network-hans-0.2 (AdamWick)
12:36:31 <amnn> not monoidal product, sorry, it takes the place of product (regular old product) in the category of endofunctors. join is obviously the monoidal product
12:38:42 <CptnSandwich> hi, i have a small problem with the sqlite-simple library. i import the main package and two subpackages that _should_ provide useful instances for a few standard types. In ghci i can use ":info" on those types and the instances will show up, but as soon as I try to compile with stack build, the instances are gone and i get a lot of "no instances for" errors. Any experience or hints?
12:38:53 <bizarrefish> amnn: product here, meaning arrow?
12:40:25 <bollu> for a functor from category to Set, map every object in category to some point in Set. Map Hom(A, B) to a function from image of A to image of B?
12:41:08 <amnn> bizarrefish, in the category of endofunctors, the composition of functors is the product object
12:41:15 <amnn> *gives the product object
12:41:23 <bollu> is my construction of a functor alright?
12:42:12 <amnn> so if you have two endofunctors, F and G, their composition is the product object
12:42:25 <bollu> Iceland_jack: is my functor from category to Set okay?
12:42:33 <amnn> bollu, not quite, because in Cat, the morphisms are functors
12:43:01 <amnn> (not the hom-sets)
12:43:05 <bollu> amnn: oh, I didn't mean "Cat". I meant "some locally small category"
12:43:21 <bollu> works then, right?
12:43:38 <wikideer> I don't understand how haskells function declarations work 
12:44:13 <wikideer> how does: add a b c become add Int -> Int -> Int -> Int
12:44:24 <amnn> bollu, well then I don't think so, you need to know more about this locally small category
12:44:56 <bollu> amnn: why? I'm mirroring the structure of the category entirely in Set
12:45:05 <bollu> amnn: the question is from the paper F is for Functor
12:45:17 <bollu> "Recall that we write the set of all arrows from A to B in a category C as C (A,B). Try to turn this into a functor from C to Set, the category of sets and functions"
12:45:28 <wikideer> I would have assumed it to be something like (Int Int Int) -> Int 
12:45:39 <wikideer> As in it takes three ints and returns one
12:45:41 <magneticduck> wikideer: it's a function that, given an Int, returns a function that, given an Int, returns a function that, given an Int, returns an Int
12:45:48 <magneticduck> yeah that's how it is in other languages
12:45:56 <amnn> bollu, the question is to try and convert C(A,B) into a functor
12:45:57 <magneticduck> you can do that in Haskell too, (Int, Int, Int) -> Int
12:46:23 <AdituV> :t curry
12:46:25 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:46:28 <bollu> amnn: correct, I should make a functor from C to Set
12:46:43 <magneticduck> wikideer: but in Haskell we generally use something called currying, where we parameterize a process by describing each parameterization as a function that returns a function
12:46:46 <magneticduck> it's called currying
12:46:47 <bollu> so I was saying that the functor will take the objects of C and map it to some "s" in a Set
12:47:02 <bizarrefish> Okay, i'm tying myself in knots here a bit. Take the list functor. It associates an element with a list of those elements. Associates category x with category [x]. So it's not an endofunctor.
12:47:05 <amnn> bollu, right but the whole question is which s
12:47:25 <bollu> amnn: the Set underlying the category? that won't work because categories can be larger than sets?
12:47:25 <amnn> and the trick is to realise that C(A,B) (the hom-set from A to B) is a set
12:47:46 <bollu> amnn: again, that is only if the category is locally small, right? or is that true for all categories?
12:47:51 <amnn> only locally small
12:48:00 <amnn> but we are in that setting right now
12:48:21 <wikideer> Bleh
12:48:34 <wikideer> I was trying to figure out the compiler messages last night 
12:48:36 <EvanR> bollu: you are given a functor from C to Set, so its fine
12:48:39 <wikideer> And it was so hard >.<
12:48:58 <amnn> EvanR, well not quite yet, the task was to convert C(A,B) into a functor
12:49:02 <bollu> amnn: then, why can't you do what I did?
12:49:32 <bollu> amnn: map every object in Cat to the underlying set, and "compress" Hom(A, B) into "one" function from the image of A to the image of B (this is for covariant)
12:49:32 <EvanR> hom-set terminology doesnt imply that there is a honest to god set in volved
12:49:37 <EvanR> its just what hom-sets are called
12:49:51 <EvanR> you can think of C(A,B) as a dependent type
12:50:09 <magneticduck> wikideer: yeah, you don't know what currying is, so it's understandable that you would have a hard time getting things to compile x) 
12:50:18 <magneticduck> read through Learn You a Haskell for Great Good
12:50:25 <amnn> bollu, okay, so lets be clear, and not call it "Cat", because that is a specific category.
12:50:31 <roconnor_> how do I enable threaded when building with cabal?
12:50:54 <dcoutts> roconnor_: in the .cabal file, ghc-options: -threaded
12:51:09 <dcoutts> if you're asking what I think you're asking
12:51:10 <bollu> amnn: right, sorry. I'll call the category C, and U C as S (the set underlying C is S)
12:51:15 <bollu> amnn: so far so good?
12:51:29 <wikideer> http://rextester.com/YYX86704
12:51:42 <wikideer> I was making a function to compute my favorite set of numbers
12:51:49 <roconnor_> dcoutts: thanks
12:52:05 <amnn> well, that kind of implies that U is a functor, which it is, but that is a red herring
12:52:36 <bollu> amnn: okay, now, I'll define a functor F from C to S
12:52:37 <amnn> the notation Ob(C) for the objects of C is common, and for locally small categories, this will be small enough to fit into a set.
12:52:51 <bollu> okay, cool. So, I have C, and S = Ob(C)
12:52:55 <bollu> now, F maps C to S
12:53:07 <bollu> such that F(c) = Ob(c) (is this correct notation)?
12:53:08 <amnn> bollu, but S is an object in Set
12:53:14 <amnn> not a category itself
12:53:33 <bollu> amnn: okay, right. Hm, okay, so I map C to Set then
12:53:39 <amnn> yes
12:53:49 <bollu> where F(c) = { Ob(c) }
12:54:03 <bollu> is that okay notation?
12:54:08 <EvanR> you also need to say what F does to arrows
12:54:09 <amnn> bollu, but c is an object in C, so Ob(c) is a type error
12:54:36 <bollu> amnn: right, so what's the notation to refer to the object itself devoid of any structure? just F(c) = { c} ?
12:54:43 <bollu> EvanR: getting to it :)
12:54:59 <amnn> well, an object on its own has no extra structure
12:55:09 <bollu> amnn: hm, right. 
12:55:09 <roconnor_> dcoutts: is +RTS -N6 a good setting if I have 6 cores?
12:55:13 <amnn> so maybe you want to say F(c) = { c }
12:55:23 <bollu> amnn: yes, basically that
12:55:24 <dcoutts> roconnor_: yes, or sometimes 5
12:55:30 <amnn> (this is not what the question intended, but let's see this through)
12:55:50 <dcoutts> roconnor_: also the -qa flag to try, see what performs best
12:55:59 <hpc> i think you can just use +RTS -N as well
12:56:00 <bollu> amnn: okay, next, F(Hom(a, b)) = f, where f(a) = b. Domain of f is {a}, range of f is {b}
12:56:20 <roconnor_> what's -qa?
12:56:26 <amnn> bollu, F does not act on hom-sets, it acts on individual morphisms
12:56:45 <bollu> amnn: F(h \in Hom(a, b)) = f then
12:56:46 <shachaf> I suggest #haskell-overflow for this conversation.
12:56:55 <bollu> going there
12:56:56 <amnn> shachaf, yes, that is a good shout
12:56:57 <bollu> :)
12:57:53 <roconnor_> hpc: oh nice
12:58:56 <bizarrefish> I've just had a think. Would it be correct to say that the elements of the monoid (in the case of the monads), are the morphisms over endofunctors?
12:59:13 <hpc> i wonder when -threaded is going to be made default, and +RTS -N is going to be implied as well
12:59:23 <bizarrefish> Where the monoidal product is composition of morphisms, and the monoidal unit is Identity -> m
12:59:31 <hpc> those both seem like fairly reasonable changes for a major GHC release
12:59:52 <EvanR> i second that motion
13:00:31 <hpc> also good automatic defaults for profiling
13:01:11 <EvanR> (otoh what would the flag be for undoing that default)
13:01:19 <ahihi> stack projects already have -threaded and -with-rtsopts=-N by default
13:01:28 <EvanR> -bulk
13:03:14 <bizarrefish> If that were true, wouldn't it be more correct to say 'monads are a monoid in the category of morphisms over endofunctors'?
13:04:00 * hackagebot hjsonschema 0.10.0.1 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.10.0.1 (seagreen)
13:04:09 <benzrf> bizarrefish: the category of endofunctors on hask
13:04:18 <benzrf> "category of X" means a category where the objects are X
13:04:28 <benzrf> of course this can be ambiguous, but so are most things
13:04:29 <amnn> bizarrefish, a monad is a monoid object in the category of endofunctors
13:04:49 <EvanR> a statement i have on hotkey just in case i need to say it
13:04:53 <bizarrefish> amnn: Are the elements of that monoid morphisms over endofunctors?
13:05:04 <bizarrefish> Identity -> m being the unit
13:05:06 <amnn> bizarrefish, yes, they are, but they are endomorphisms
13:05:10 <benzrf> bizarrefish: the monoid does not have "elements"
13:05:21 <benzrf> it's a monoid object, not a literal set monoid
13:05:24 <bizarrefish> Right. Right right right. Endomorphism. I can figure out what that means without google :)
13:05:41 <amnn> bizarrefish, if M is the monoid object, they are M -> M
13:05:44 <benzrf> what are you actually asking, then?
13:06:00 <amnn> actually no, they are not, sorry
13:06:02 <amnn> :P
13:06:07 <benzrf> amnn: smh
13:06:16 <benzrf> bizarrefish: do you know what a monoid object is
13:06:33 <bizarrefish> benzrf: I'm trying to understand how that famous phrase about monad being a monoid object in the category of endofunctors.
13:06:38 <amnn> that is a different representation of monoids, like benzrf said, the instance of a monoid that is a monoid object are embedded within the monoid object
13:06:43 <bizarrefish> benzrf: I'm starting to think no
13:06:55 <EvanR> bizarrefish: that wasnt a full sentence
13:07:11 <EvanR> did you mean to put "works" at the end
13:07:17 <bizarrefish> EvanR: yes.
13:07:31 * bizarrefish downloads EvanR for future autocompletion needs.
13:07:39 <benzrf> bizarrefish: honestly you shouldnt care, imo
13:07:43 <benzrf> but
13:08:03 <EvanR> the famous phrase is slightly misleading for several reasons
13:08:19 <EvanR> one, it has no bearing on how to use haskell or do FP
13:08:19 <bizarrefish> benzrf: I know monads for programmers, and can do monad stuff effectively. But I need to be able to reconcile that phrase with my understanding.
13:08:41 <benzrf> the idea is that you generalize the notion of a monoid in a way that lets you use an object of any suitably nice category instead of an object of Set (or Hask, here) in particular
13:08:51 <EvanR> two, monads are not unique in being monoids in a functor category
13:09:06 <EvanR> three, many people know what monoids are, but not what monoid objects are
13:09:13 <bizarrefish> EvanR: I was starting to realise that second one, the more I thought about it
13:09:19 <EvanR> so by itself this is leading to a broken image
13:09:31 <benzrf> bizarrefish: the monoid operation is join :: m (m a) -> m a
13:09:37 <benzrf> the identity is return :: a -> m a
13:10:24 <bizarrefish> Right. both morphisms are between functors.
13:10:31 <bizarrefish> *both are morphisms between functors
13:10:38 <EvanR> they are natural transformations
13:10:41 <benzrf> m . m ~> m / Id ~> m, if you prefer
13:11:04 <benzrf> bizarrefish: to be precise
13:11:17 <benzrf> the notion of an ordinary monoid can be defined in categorical terms
13:11:42 <benzrf> as an object M, a morphism M x M -> M, a morphism () -> M
13:11:55 <benzrf> such that composing these morphisms suitably satisfies certain identities
13:12:53 <benzrf> for example, if w is an isomorphism M -> M x (), then f . w = id
13:12:58 <benzrf> er, i mean
13:13:11 <bizarrefish> But there are other monoid objects in the category of endofunctors, besides the one including join and return...
13:13:14 <bizarrefish> right?
13:13:15 <benzrf> for example, if w is an isomorphism M -> M x (), then mappend . lmap mempty . w = id
13:13:30 <benzrf> bizarrefish: that's a nonsensical statement, sorry 
13:13:48 <benzrf> are you reading what i'm writing
13:14:22 * bizarrefish reads a few more times
13:15:26 <bizarrefish> Need more haskell background/time to make sense of your last statemenet
13:15:35 <benzrf> do you know what a bifunctor is
13:15:41 <bizarrefish> Nope
13:15:54 <benzrf> it's just a functor from a product category
13:16:06 <benzrf> for example a functor Hask x Hask -> Hask
13:16:33 <benzrf> "_ x _" is a bifunctor of that type
13:16:41 <bizarrefish> So, a functor which associates a composition of a functor with itself, with the functor?
13:16:49 <benzrf> ?
13:17:19 <EvanR> each of these concepts, even product should be covered in detail, which means getting a suitable book and going over each little thin
13:17:28 <benzrf> yup
13:17:43 <toph_> are MVars considered an example of two-phase locking?
13:17:53 <EvanR> and im not sure it will help with haskell
13:17:57 <benzrf> yup
13:18:34 <benzrf> bizarrefish: an ordinary monoid operation is a morphism from the product of the type with itself, to the type
13:18:48 <benzrf> join is a morphism from the composition of the endofunctor with itself, to the endofunctor
13:19:05 <benzrf> this is the connection
13:19:46 <levp> What does "{-hi-}...{-/hi-}" thing mean in this code? http://lpaste.net/162929
13:19:52 <bizarrefish> Pretty sure I now get what a product category is. And yes, I understand that last part.
13:20:23 <amnn> levp, they are just comments
13:21:22 <kadoban> levp: They're likely meant to be parsed by some tool, but I have no idea what one. Yeah they're just comments though.
13:22:16 <benzrf> bizarrefish: the key is that,
13:22:27 <benzrf> if i characterize what a monoid is, in categorical terms
13:22:45 <EvanR> the farewell to frp blog post on elm-lang.org... is frustrating. it presents an FAQ question "what are signals?" and then says "who cares! they are no more in the new version"
13:22:57 <EvanR> which leads me to not care about the new version either
13:23:03 <EvanR> since history can repeat itself
13:23:15 <benzrf> the only specific properties of hask, x, and () that i am leveraging, are that x is an associative bifunctor and () is an identity of it
13:24:15 <benzrf> bizarrefish: therefore, i can restate the definition of a monoid using any other category C, bifunctor T : C x C -> C, object I, as long as T is associative and I is an identity of T
13:24:31 <bizarrefish> benzrf: So product category is how binary operations in general become morphisms.
13:24:38 <benzrf> no
13:24:54 <bizarrefish> Hang on, no. I know that's wrong
13:25:10 <benzrf> i really dont recommend that you try to learn tihs
13:25:18 <ertes> EvanR: to me it sounds like elm basically gave up FRP (not that they had ever used it in the first place)
13:25:21 <EvanR> youre using the word morphism for anything which is confusing
13:25:36 <benzrf> EvanR: no, that one was coherent
13:25:41 <benzrf> or at least, had a coherent thought behind it
13:25:47 <EvanR> yes
13:25:53 <bizarrefish> Binary operations fit into category theory as bifunctors?
13:25:54 <ertes> EvanR: from the post it sounds like they are basically back to event handlers, and the reasoning is even better: because it makes it easier to learn apparently
13:25:56 <benzrf> bizarrefish: no
13:26:13 <bizarrefish> Well, i got confused somewhere, then.
13:26:15 <ertes> that reminds me why i never really liked elm
13:26:17 <bizarrefish> damn it
13:26:21 <EvanR> ertes: so... its moving to a simpler model... explicitly subscribing observers
13:26:21 <benzrf> binary *functors* fit in as bifunctors
13:26:26 <benzrf> binary operations in general? no
13:26:44 <bizarrefish> Okay, I see the distinction.
13:26:48 <EvanR> farewell is to whatever it was doing before, not necessarily frp
13:26:59 <benzrf> anyway the *entire point* of category theory is to let go of a concept of "elements" and to thinking of morphisms as "functions"
13:27:12 <benzrf> if the thing you want to say is not purely in terms of composition, then don't try to say it
13:27:23 <benzrf> or at least, find a way to say it in terms of composition
13:27:38 <benzrf> ok maybe not the "entire point" but close enough
13:28:04 <pikajude> so ixset hasn't been maintained in 4 years and tables is now deprecated
13:28:10 <pikajude> what do I use for my in-memory database??
13:28:14 <EvanR> is something wrong with ixset ?
13:28:19 <EvanR> besides its Typeable
13:28:31 <pikajude> well once ghc 8 comes out i presumably won't be able to use it anymore
13:28:34 <pikajude> since it doesn't compile right now
13:28:41 <EvanR> ;_;
13:28:49 <pikajude> because of impredicative polymorphism
13:28:52 <pikajude> and that i do not know how to solve
13:28:56 <EvanR> what about this one https://hackage.haskell.org/package/ixset-typed
13:28:58 <ertes> i guess reflex is too much of a competitor now =)
13:29:05 <benzrf> question of my own: i have next to 0 experience with gui programming outside of the browser
13:29:14 <pikajude> uploaded 2014
13:29:16 <pikajude> hmm
13:29:17 <benzrf> how disgusting would it be to use ghcjs so that i can use the dom for my interface?
13:29:19 <pikajude> maybe
13:29:32 <pikajude> doesn't ghcjs involve the browser anyway?
13:29:40 <EvanR> benzrf: you can even bundle a browser with your app
13:29:50 <ertes> benzrf: you can use GHC instead together with webkit and ghcjs-dom
13:30:03 <benzrf> pikajude: i dont mean how disgusting would it be to use ghcjs for that, i mean how disgusting would it be to do that (which i would accomplish with ghcjs(
13:30:05 <benzrf> ))
13:30:21 <pikajude> oh, yeah, dom for interface is absolutely godawful
13:30:24 <pikajude> if you're not making a website
13:30:40 <benzrf> so what's better then?
13:31:15 <ertes> benzrf: do you use reflex?
13:31:17 <bergey> My impression is that lots of people use HTML+JS for GUI because for all its shortcomings, the alternatives are worse.
13:31:18 <pikajude> OS specific GUI libs
13:31:46 <benzrf> pikajude: askin for specifics here
13:31:50 <benzrf> ertes: never touched it
13:32:02 <pikajude> Cocoa
13:32:05 <pikajude> Metro
13:32:08 <pikajude> GTK+
13:32:13 <pikajude> is my guess
13:32:50 <EvanR> yep i definitely have a separate obj-c process for GUI
13:32:53 <EvanR> and its not fun
13:33:08 <kadoban> benzrf: I'd seriously consider doing that for a GUI, with reflex-dom and such, but that's because I'm already learning it and none of the other haskell GUI stuff ever really seemed nice to me. My understanding is that there could eventually be something like reflex-gtk as well, at least theoretically.
13:33:10 <EvanR> but it does get you "native look and feel"
13:33:45 <ertes> benzrf: ghcjs-dom works with GHC, too, with webkit, so you basically write your GUI as HTML, but the DOM manipulation happens with native code
13:34:09 <benzrf> that's worrying
13:34:17 <ertes> benzrf: works pretty much out of the box, and reflex-dom, the FRP DOM framework, has builtin support for that
13:35:02 <ertes> benzrf: by HTML i really mean DOM…  you never have to write actual HTML
13:35:04 <bizarrefish> Gotta go now, peoples. Bed and stuff. Many thanks for the insight. I've definitely learned stuff. Have pleasant evenings/days.
13:35:08 <kadoban> benzrf: In fairness, I didn't look that hard at other GUI stuff, it's possible that some of it is nice and I just didn't see it.
13:36:03 <ahri> apologies ahead of time; i'm actually using js, but am trying to force myself to do functional programming as a gateway to haskell. that being said i'm writing a websocket server and i'm struggling with how to model state changes in a functional language - the server is simple; user registers, user can issue commands, all that comes back are async events (it's effectively a simple event store) - can anyone t
13:36:09 <ahri> ell me how i should think about this in a functional way?
13:36:17 <ertes> benzrf: alternatively most native GUI frameworks follow the same principle: you create objects, you change their state, you assign event handlers, you go crazy
13:36:43 <benzrf> ahri: you're gonna have a hard time doing that in js
13:37:22 <ahri> on the subject of UI programming i've found using cyclejs with its reactive streams (rxjs) helped me to like functional programming way more than anything else
13:37:36 <ertes> ahri: you should learn a functional language, even if you don't use it to do the actual work
13:37:38 <benzrf> ahri: js just doesnt have the right tools and builtins to make purity actually feasible
13:38:06 <ertes> ahri: don't learn haskell though…  it ruins you for JS
13:38:14 <benzrf> you can write purescript :')
13:38:14 <EvanR> im using js right now with immutable data structures
13:38:21 <EvanR> and lenses!
13:38:24 <benzrf> hoo boy
13:38:25 <ertes> ugh
13:38:34 <EvanR> but not lazy evaluation
13:38:35 <ahri> benzrf: yeah, that's a struggle for me, but i'm trying to take a practical approach here :)
13:38:49 <benzrf> ahri: just learn haskell :V
13:38:53 <ahri> EvanR: yeah, this is the way i'm going, i'm using mori
13:38:58 <EvanR> yeah haskell is the gateway, not the destination
13:39:40 <ahri> well for now js makes the most sense; i want to run the business logic both on the server and the client, so sharing js code is easiest
13:39:56 <ertes> EvanR: yeah, i can imagine how your code looks:  var _blah = function (f) { function (x): f(x).fmap …
13:40:03 <ertes> can't even finish it…  i'm confused…
13:40:18 <ertes> i even got it wrong, holy crap
13:40:32 <ahri> and i can cheat when time pressures are there, and refactor when i have time and have learnt more
13:41:33 <benzrf> ahri: so learn haskell but just dont use it for serious projects
13:41:53 <ertes> ahri: more seriously: it all starts with replacing objects by higher-order functions
13:42:02 <benzrf> i seriously doubt any amount of prep in js is going to make you be able to start writing programs in haskell right as you start learning it
13:42:16 <ertes> ahri: you want to abstract over behaviour?  behaviours are functions (in JS)…  you should abstract over them
13:42:45 <ahri> ertes: i am embracing this, just find it hard not to think in OO ways sometimes :(
13:42:56 <benzrf> ahri: juuuuusttt leaaaarnn haskelllllllll
13:42:58 <benzrf> really
13:43:17 <benzrf> it will be much more fun than trying to force yourself to write weird js
13:43:19 <ZelteHonor> If you enable -threaded in Ghc and then use RTS -N. Without putting any parallelisme and concurrency in your code. What happen?
13:43:33 <simpson> ahri: Just wait until you encounter an object-based language that doesn't have OO practices.
13:43:40 <benzrf> when i write js i dont make it perfectly function b/c thats not what js makes nicest
13:43:47 <benzrf> *perfectly functional
13:43:51 <ertes> ahri: think of "classes" (as far as they can be represented in JS) and objects more as modules, i.e. containers for definitions…  if you ever overload or use prototypes, you're already back to OO
13:43:57 <ahri> benzrf: let's say i did, i would be asking the same question: how do i solve this in a functional way?
13:44:06 <benzrf> no, because you wouldn't be writing that program :)
13:44:15 <benzrf> you'd be doing something else that would be more conducive to learning haskell
13:44:18 <ertes> ahri: you can use them as a substitute for haskell modules, because otherwise JS has pretty much no modularity
13:45:07 <ZelteHonor> I would think that it would not change anything. But when I checked all of my core become busy. Is there some kind of automatic parellisation? Also the program is a bit slower.
13:45:27 <ahri> benzrf: presumably you can write a websocket server in haskell?
13:45:41 <pikajude> yep
13:45:46 <ertes> ahri: i highly recommend learning a functional language though…  i promise you that it will help you with functional JS much better than prose
13:45:59 <benzrf> ahri: yes, but you *wouldn't*, until you've been using haskell for long enough to be somewhat comfortable
13:46:10 <simpson> Alternatively, stop trying to make "functional JS" happen.
13:46:15 <ertes> ZelteHonor: are you compiling with -threaded?
13:46:17 <geekosaur> ZelteHonor, I believe garbage collection uses all available capabilities
13:46:27 <ZelteHonor> Yes
13:46:29 <benzrf> ahri: think of it as being like when you originally started programming at the beginning
13:46:33 <ZelteHonor> ertes: yes
13:47:04 <ertes> ZelteHonor: did you pass it +RTS -N?  or does your program set the number of capabilities explicitly?
13:47:21 <ZelteHonor> I pass +RTS -N explicitly.
13:47:35 <ertes> ZelteHonor: then most likely what geekosaur said
13:47:45 <ertes> ZelteHonor: or a library you're using like repa
13:48:35 <ZelteHonor> I don't think I use any parallel library. My program is running something like 2.something second without +RTS -N and 3.something secondd with it,
13:48:36 <geekosaur> as for slower, the threaded runtime needs to take locks even if you don't actually make any threads
13:49:02 <ertes> (GC uses all capabilities, but it shouldn't be noticable, unless you have a lot of "complicated" GC state, like objects that appear and disappear all the time, but the compiler can't assign them a static scope)
13:49:17 <ahri> well let's put it another way; i have a haskell book sat on the shelf largely unread, and worked through the first few chapters of 'learn you a haskell' - picking up bits of functional programming in js has suited me more and gotten me farther than learning haskell outright. i will learn it, but right now this project is in js
13:49:46 <geekosaur> because it can't know that you aren't, so it must lock various internal structures. (there is also at least one additional thread "running" but in a program that doesn't forkIO it shouldn't be doing much unless you make FFI calls --- in which case your main thread will be blocked)
13:49:48 <EvanR> ertes: believe it or not, its simpler this way
13:49:53 <EvanR> for what im trying to do
13:50:16 <ertes> EvanR: i believe it, but your colleagues probably don't =)
13:50:23 * EvanR looks around
13:50:28 <EvanR> long gone
13:50:33 <ertes> ahri: learn it (or scheme or …) as you go…  you don't have to interrupt your project
13:50:42 <ZelteHonor> Thanks. It's really interesting.
13:50:50 <ertes> EvanR: i reinvented iteratees in PHP
13:51:03 * benzrf hisses
13:51:05 <ertes> believe it or not, it was simpler that way
13:51:14 <EvanR> yeah PHP 5.3 was sorry it added lambdas because of me
13:51:16 <ZelteHonor> If I use enormous amount of data would multicore GC help clean it?
13:51:55 <geekosaur> in any case the threaded runtime does have higher overhead, and things like garbage collection take more time because the garbagfe collector must lock against other threads trying to do allocations even if there aren't any (it can't know)
13:52:06 <EvanR> ahri: alternatively, take a plunge into the deep end
13:52:24 <geekosaur> it is normal for +RTS -N1 (or +RTS -N with only one user thread) to be slower than the non-threaded runtime, in other words
13:52:42 <ertes> (i still like iteratees for some reason…  they are so…  simple)
13:52:50 <benzrf> ahri: lyah is meh anyway :D
13:53:21 <ertes> ZelteHonor: it's less about the number or size of heap objects, but more about their lifetime
13:53:52 <ZelteHonor> Lifetime?
13:53:59 <ertes> ZelteHonor: static GC is as cheap as a stack cleanup in C, sometimes even cheaper…  the trouble starts when the lifetime of your objects is dynamically determined
13:54:52 <ZelteHonor> ertes: What does it mean: the lifetime of your objects is dynamically determined : and what is lifetime?
13:55:25 <ZelteHonor> (If the wikipedia page is fine you can just point me to it. Don't have to write big text if you don't want to)
13:55:48 <ertes> ZelteHonor: when a heap object has no more references to it, it's no longer alive and GC will delete it
13:55:50 <EvanR> lifetime ends at a time after which the object will never be accessed again
13:56:03 <EvanR> which could mean there are no more references to it
13:56:35 <ZelteHonor> Ah. So it's the time the object has lived in the heap?
13:57:14 <ertes> ZelteHonor: very often the lifetime of a heap object (e.g. a haskell value) is statically known, so garbage collection is more conceptual than an actual algorithm…  it's basically just pointer arithmetic, if at all
13:57:27 <Ralith> geekosaur: aren't uncontended locks very cheap?
13:57:52 <dolio> Not as cheap as no locks. :)
13:57:57 <geekosaur> Ralith, it's still making calls to lock and unlock routines that the nonthreaded runtime doesn't
13:58:12 <geekosaur> over time these add up, even if they're fast
13:58:13 <Ralith> interesting to see a dramatic difference result
13:58:21 <ZelteHonor> I understand. Thanks.
13:58:36 <Ralith> also, what sort of analysis is ghc doing to identify objects with static lifetime?
13:59:19 <ertes> ZelteHonor: but when the compiler doesn't understand your code well enough, it has to perform an actual GC algorithm on it…  now it needs to do bookmarking, etc., and that can be expensive…  the cost is along the lines of malloc() and free() in C, but may still be cheaper, because GHC's RTS has a specialised memory manager
13:59:35 <ertes> s/bookmarking/bookkeeping/
14:00:14 <ertes> it can also be more expensive, when objects are kept around longer than necessary
14:02:04 <dedgrant> Ralith: The related optimizations arise from aggressive inlining, unboxing, strictness analysis, caching and limited escape analysis (which I think is limited to local let bindings specifically).
14:02:09 <ertes> Ralith: i think it's very basic: identify scope and see if the "path" is linear…  GHC probably has a linear/uniqueness type system in disguise to do that
14:02:29 <dedgrant> (this is GHC mind)
14:03:51 <Ralith> cool, thanks
14:04:12 <Ralith> are there detailed technical writeups of ghc's optimization methods published anywhere?
14:04:39 <shachaf> There are papers about many aspects of it.
14:05:00 <shachaf> You can find a list at Simon Peyton Jones's publications page.
14:05:16 <ertes> i'd start with the STG paper to learn how it works in general
14:05:28 <ZelteHonor> I was asking because I just started to read the parallel and concurrency free book about Haskell.
14:07:06 <ertes> (or: how i learned to stop worrying and trust GHC)
14:09:20 <EvanR> concurrency-free book
14:11:22 <geekosaur> physical books are pretty concurrency-free :p
14:11:36 <ZelteHonor> EvanR: Not exactly. More the free book about parallelism and concurrency in Haskell.
14:14:05 <ddhouse> So My project is going really good but can someone check my code, https://jsfiddle.net/zrkz7wj2/ from https://github.com/WebParakeet/webpControlPanel/issues/1
14:15:06 <roconnor> where is the monad instance for Either a?
14:15:47 <dolio> transformers?
14:15:47 <jle`> :i Either
14:15:59 <jle`> instance Monad (Either e) -- Defined in 'Data.Either'
14:16:22 <roconnor> oh
14:17:08 <prophile> https://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.Either.html#line-137
14:23:59 <jle`> Right r >>= k = k r
14:24:08 <jle`> l >>= _ = unsafeCoerce l
14:24:55 <monochrom> :)
15:04:05 * hackagebot language-c-quote 0.11.6.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.6.1 (GeoffreyMainland)
15:04:07 * hackagebot cryptohash-sha256 0.11.7.2 - Fast, pure and practical SHA-256 implementation  https://hackage.haskell.org/package/cryptohash-sha256-0.11.7.2 (HerbertValerioRiedel)
15:13:51 <volhovm> Hey! What's the difference between `A => B => c` and `(A, B) => c`? Is there any?
15:14:11 <volhovm> s/Hey/Hi/
15:15:00 <wikideer> http://pastebin.com/NH7aHmrw 
15:15:12 <wikideer> In these examples I have drawn up Haskell is the sexiest 
15:15:15 <wikideer> Hands down 
15:15:31 <AdituV> @volhovm: none I know of.  When I put the former into ghci, it converts it to the latter, anyway
15:15:31 <lambdabot> Unknown command, try @list
15:15:48 <AdituV> oops, did that go through?  forgot about lambdabot
15:15:50 <geekosaur> volhovm, the only place it is different is in pattern synonyms, where you can separate required constraints from new constraints made available when the pattern matches
15:15:59 <wikideer> I gave up on Erlang because it's stupid, it's documentation is stupid, and it's errors are just vague as hell
15:16:13 <volhovm> geekosaur: can you show some simple example please? :)
15:17:54 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms#Staticsemantics is the only thing I'm aware of
15:18:10 <volhovm> thanks!
15:18:17 <mpickering> The user guide has probably the best description
15:18:26 <geekosaur> dunno if any code actually uses it yet, it's quite new
15:19:38 <b2coutts> when I write haskell, I find it annoying to document a function with a comment because the variables aren't named in the type signatures. Are there nice conventions for dealing with this?
15:19:48 <b2coutts> do you just name them in the comment so you can refer to them?
15:19:56 <pikajude> yes
15:20:13 <Rembane> b2coutts: You can use type to make more informative type names
15:20:17 <pikajude> haddock kind of bakes that functionality in also
15:20:26 <pikajude> you put each argument on a separate line and document it in an adjacent comment
15:20:35 <pikajude> so if you wish to haddock early and haddock often you can do that
15:21:50 <nitrix> Is the complaint about the type signature of the function arguments (left hand side of =) ?
15:22:47 <b2coutts> nitrix: it's more an observation that haskell, as opposed to most languages, doesn't require you to explicitly name all of the variables of a function
15:23:00 <b2coutts> which makes it awkward to refer to them when writing a comment to explain the behaviour of a function
15:23:10 <b2coutts> s/variables/arguments/
15:23:10 <lyxia> this would be a nice feature to add to haddock
15:23:22 <nitrix> b2coutts: You still have the option of using more meaningul names for the type variables.
15:24:07 <nitrix> Not sure if that helps.
15:24:17 <lyxia> ah well if the variables are not there in the first place...
15:24:20 <b2coutts> nitrix: I feel like if a function takes an Int and a [Int], it's more generally readable/sensible to make those the types, rather than make the types "Branchwidth" and "Neighbours" and have the reader have to go figure out what those are
15:24:26 <b2coutts> it strikes me as a weird workaround
15:24:56 <nitrix> Type variables are lowercase.
15:25:09 <b2coutts> I don't think I know what you mean then
15:25:16 <b2coutts> (I'm also not very experienced with haskell)
15:25:20 <nitrix> `a` is a type variable.
15:25:24 <lyxia> you can give your parameters names in a comment
15:25:48 <b2coutts> lyxia: yeah, that's what I was thinking of, it just seemed a bit annoying to have to do that every time I document a function
15:25:56 <nitrix> `[element]`, here `element` is also a type variable. If all the single letter types annoys you.
15:26:03 <lyxia> (as you said, I just noticed)
15:27:10 <b2coutts> I guess you can get away with that if you're using a type variable, but what if the type is just Int?
15:28:19 <nitrix> Then you know it's an Int and there's no confusion.
15:29:11 <b2coutts> sure, but then if I have a function f :: Int -> Bool -> Int, how do I refer to the first and second arguments if I want to have a comment describing the behaviour of the function?
15:29:27 <nitrix> Type aliases could help.
15:29:27 <b2coutts> in most other languages the function declaration would have explicitly given names to the Int and the Bool, so I'd just use those names
15:29:38 <monochrom> I have a cunning plan. The type sig should be an animated GIF that rotates through "Int" and "Bandwidth".
15:29:51 <nitrix> b2coutts: Oh you're not asking about types at all.
15:30:01 <nitrix> b2coutts: You're asking about function parameters.
15:30:04 <b2coutts> nitrix: right
15:30:16 <nitrix> b2coutts: Well just name them; that's what the identifiers are for.
15:30:23 <b2coutts> name them how/where?
15:30:31 <ertes> -- | @replicate n x@ is the list of @n@ repetitions of @x@.
15:30:35 <nitrix> f myFirstVariable mySecondVariable = ...
15:30:36 <monochrom> But haddock has a way for you to add a blurb to each parameter type
15:30:38 <ertes> replicate :: Int -> a -> [a]
15:30:39 <b2coutts> I mean if the type signature is followed by a line like f a b = ... it's fine
15:30:47 <b2coutts> but if it's followed by different patterns and such it gets ugly
15:30:48 <ertes> that's the way you can document your code
15:31:01 <b2coutts> oh I guess that's reasonably nice
15:31:18 <ertes> s/the/a/
15:31:21 <monochrom> But the ideal is still my annoying animated GIF idea
15:31:24 <nitrix> b2coutts: Then do not eta-reduce the function if it makes it confusing.
15:31:24 <nitrix> b2coutts: I feel you're trying to solve a problem after indulging it on yourself.
15:31:48 <ertes> monochrom: like in 90's myspace pages?
15:31:57 <nitrix> If you do not use pointfree notation and eta-reduce everything, your problem goes away.
15:31:58 <ertes> with blinking stars in the background?
15:32:07 <nitrix> There's a reason why it's supposed to be used sparingly.
15:32:12 <b2coutts> nitrix: *shrug* I think the notion of defining functions by a sequence of exhaustive patterns is a really nice thing haskell has
15:32:27 <monochrom> actually I didn't come across much of myspace pages back then
15:32:36 <b2coutts> I'm not using it universally or excessivly, just when it seems to be the clearest or most concise way to write the function
15:32:44 <nitrix> b2coutts: So your question is about pattern matching then?
15:32:55 <ertes> monochrom: not sure if i'm mixing it up with geocities…  they were practically the same thing
15:33:21 <monochrom> geocities pages certainly had a lot of those annoying eye poisons
15:33:24 <b2coutts> nitrix: well, it's about one possibly bad side effect of being able to define functions this way; that the arguments of a function aren't always named
15:33:41 <ertes> nitrix: chunksOf n = takeWhile (not . null) . map (take n) . iterate (drop n)  -- try to write this with the explicit argument
15:34:19 <b2coutts> I like this way of defining functions enough (when it's actually helpful) that it's still worth it to me, but figured this would be a common problem and there would be common conventions for documenting functions like this
15:34:23 <nitrix> ertes: ... $ xs
15:34:45 <ertes> nitrix: seems like noise
15:34:58 <nitrix> ertes: It is, but it gets the argument named.
15:35:16 <ertes> nitrix: you can name it in the documentation, like above
15:35:19 <nitrix> You can't have both while complain that you hate writing comments...
15:35:24 <ertes> -- | @chunksOf n xs@ is ...
15:35:25 <nitrix> ertes: He doesn't wants to do that.
15:35:51 <b2coutts> nah, I think that's good enough; it's at least better than constantly saying "argument 1", "argument 2", etc.
15:36:06 <b2coutts> but also figured that if there was a way *everyone* deals with this I may as well follow convention
15:36:09 <b2coutts> but I guess there isn't
15:36:30 <monochrom> there are 4 ways
15:40:47 <monochrom> I think people coming from other programming communities have been ruined by those communities' obedient docile conformist ban-independent-critical-thinking culture that they come to Haskell expecting every task to have a unique convention to obey to.
15:41:18 <monochrom> But no, this community makes you think for yourself. And statistically every task has about 5 unique conventions, not 1.
15:41:40 <ertes> (there are languages that even use this as a selling point…  i won't name them)
15:41:49 <ertes> s/use/abuse/
15:42:11 <monochrom> And the 4 conventions for this one are:
15:42:25 <b2coutts> I guess; for situations like this where the choice of convention really doesn't matter, I think it makes the most sense to choose what people are most used to
15:42:27 <monochrom> 1. document nothing. (saidly, it's still statistically significant)
15:42:40 <monochrom> 2. write a per-parameter blurb
15:42:59 <eikke> carter: were you working on some blockchain/ledger project?
15:43:00 <monochrom> 3. write a holistic "@f x y@ will do so-and-so" blurb
15:43:05 <monochrom> 4. write both
15:43:22 <ertes> note that haddock has a handy syntax for argument documentation within the type signature
15:43:33 <carter> eikke: hopper language is work related but in my name yes :)
15:43:51 <dfeuer> A per-argument blurb is generally only wise if there are a lot of arguments. If there are a lot of arguments, you might consider using fewer of them :P
15:43:53 <ertes> f :: A {- ^ first arg doc -} -> B {- ^ second arg doc -} -> C {- ^ result doc -}
15:44:06 <monochrom> no, this is exactly the situation where what other people are used to is beside the point.
15:44:16 <dfeuer> Of course.
15:44:27 <dfeuer> I'm as opinionated as the next person :P
15:44:34 <eikke> carter: is that JPMC's project, Juno?
15:44:40 <monochrom> some functions are best explained in the per-parameter style. some other functions are best explained in the holistic style.
15:44:52 <monochrom> and the rest are so hard to explain that you have to do both.
15:44:54 <ertes> and some are best explained by laws
15:45:23 <ertes> i wish people would add more equations to documentation
15:45:31 <monochrom> you have to do the best for your functions. not follow some other "majority" whose functions clearly have different natures and requires different explanation styles than yours.
15:45:51 <monochrom> you have to use independent critical value-judgment thinking
15:46:27 <monochrom> and if there is one thing people in this community is used to, it's independent critical value-judgment case-by-case-basis thinking
15:47:33 <ertes> i also like tekmo's .Tutorial convention
15:47:59 <ertes> write concise reference-style documentation, add a .Tutorial module with more introductory prose and examples
15:52:56 <bbear> hey ya
15:53:12 <bbear> what's wrong with my function readAllLines ? http://vpaste.net/JHSBT
15:53:57 <monochrom> delete "readAllLines 3"
15:54:08 <monochrom> put parentheses around "n-1".
15:54:16 <geekosaur> (read getLine :: Int) won't do what you want
15:54:17 <bbear> yeah I did it already
15:54:22 <monochrom> I don't understand "read getLine"
15:54:26 <bbear> geekosaur: but you get the idea.
15:54:27 <AdituV> getLine >>= read
15:54:38 <AdituV> well, not quite
15:54:44 <bbear> Basically it is made to read « n » lines from the input, converting each of them as an integer.
15:54:48 <AdituV> sorry super tired :p  but you need some sort of composition there
15:54:56 <bbear> I'm total beginner
15:54:58 <Cale> fmap read getLine
15:54:58 <geekosaur> the compiler doesn't though...
15:55:12 <Cale> Or, somewhat better, there exists readLn
15:56:00 <monochrom> I wonder if I should simply suggest "replicateM n (fmap read getLine)"
15:56:02 <Cale> (which differs in the way in which it throws an exception when parsing fails -- the exception will be easier to catch, since it occurs during the execution of the IO action rather than during evaluation of the result)
15:56:24 <monochrom> but if you want to write your own recursion, you should use the do-notation again
15:57:11 <bbear> seems complicated to learn haskell. But I wont give up. (so many ways to do things).
15:57:24 <bbear> what does fmap exactly ?
15:57:31 <monochrom> actually I think you should read my IO tutorial first. http://www.vex.net/~trebla/haskell/IO.xhtml
15:57:54 <shanemikel> hello all
15:58:07 <AdituV> fmap lifts a function from (a -> b) to acting within some other context (f a -> f b).  E.g. (IO a -> IO Int) in this case
15:58:23 <bbear> can you give an example ?
15:58:26 <maerwald> monochrom: meh, the page formatting :P
15:58:31 <AdituV> > fmap (+3) [1,2,3]
15:58:33 <lambdabot>  [4,5,6]
15:58:41 <AdituV> fmap not (Just True)
15:58:43 <bbear> ok. much more clear :)
15:59:31 <bbear> fmap read getLine
15:59:52 <bbear> map read GetLine [1..n]
16:00:17 <bbear> few. Do you know of a short book to learn haskell on the grass ?
16:01:10 <monochrom> No. For any meaningful, respectable sense of "learn haskell", it cannot be done on grass. Unless you're Dijkstra.
16:01:32 <ertes> bbear: it doesn't exist…  learning haskell is a hands-on experience
16:01:36 <sm> programming in haskell
16:01:39 <bbear> well you can learn pretty things on grass with a book in the hands.
16:01:41 <TommyC> Curious, what does "on the grass" mean?
16:01:42 <AdituV> well... I guess you could use a laptop and program while sitting on grass?
16:01:44 <sm> http://www.cs.nott.ac.uk/~pszgmh/book.html
16:02:01 <bbear> I mean reading a book sitting on the grass.
16:02:02 <monochrom> You have to test your guesses on the computer to see how wrong you are. Not just speculate on grass and believe you've got it.
16:02:04 <TommyC> Unless he meant that literally "on the grass."
16:02:14 <TommyC> monochrom: Ah, thank you.
16:02:46 <bbear> monochrom: I just have a feeling that there is a risk that I am almost totally wrong on many points.
16:02:48 <monochrom> Unless you have also figured out a way to use grass for molecular computing.
16:03:18 <ertes> bbear: very often understanding when and why you're wrong boils down to reading the types
16:03:29 <ertes> "is this value a valid argument to this function?"
16:03:31 <bbear> yes, type reading is mandatory.
16:03:44 <bbear> this is very different from C or C++ programming.
16:03:53 <ertes> like:  is (getLine :: IO String) a valid argument to (read :: String -> A)?
16:04:05 <bbear> nope
16:04:21 <bbear> So you mean I should heavily use the :t function in the interpreter to improve my knowledge ?
16:04:21 <ertes> that was your first breakthrough =)
16:04:44 <bbear> I must use the connector.
16:04:54 <shanemikel> do s <- getLine; let n = read a :: Int; return n
16:04:55 <bbear> yay breakthrough.
16:05:16 <sm> holy god why is this book $62 on amazon, or $198 for hardback ?
16:05:32 <ertes> bbear: also as a beginner you might struggle with IO a lot…  read monochrom's tutorial, of which the essence is this:
16:05:35 <ertes> @quote /bin/ls
16:05:36 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
16:05:55 <shanemikel> :t getLine >>= return . read
16:05:57 <lambdabot> Read b => IO b
16:06:19 <shanemikel> :t (getLine >>= return . read) :: IO Int
16:06:21 <lambdabot> IO Int
16:06:22 <geekosaur> sm: academic press pricing :(
16:06:41 <sm> seems crazy. It wasn't like that when I bought it
16:06:51 <AdituV> sm: possibly also because it's a standard text for first year CS at Oxford now
16:07:03 <dsm> :t fmap read getLine :: IO Int
16:07:04 <lambdabot> IO Int
16:08:29 <bbear> AdituV: that kind of pricing seems like an invitation for cheap pdf printing
16:08:57 <shanemikel> :t (s <- getLine; let n = read a :: Int; return n)
16:08:58 <bbear> well losing myself in that comment.
16:08:59 <lambdabot>     parse error on input ‘<-’
16:08:59 <lambdabot>     Perhaps this statement should be within a 'do' block?
16:09:11 <ertes> (wait for it: very soon someone will write a variant using (<$>))
16:09:21 <shanemikel> :t (do s <- getLine; let n = read a :: Int; return n)
16:09:23 <lambdabot> parse error on input ‘)’
16:09:37 <geekosaur> need extra braces around the let block
16:09:57 <geekosaur> :t (do s <- getLine; let {n = read a :: Int}; return n)
16:09:59 <lambdabot>     Couldn't match type ‘Expr’ with ‘[Char]’
16:09:59 <lambdabot>     Expected type: String
16:09:59 <lambdabot>       Actual type: Expr
16:10:11 <shanemikel> oh.. I usually don't put do syntax on one line
16:10:11 <shanemikel>  
16:10:13 <geekosaur> ...and you forgot to define a
16:10:20 <geekosaur> did uou mean s?
16:10:23 <AdituV> :t (do s <- getLine; let n = (read s :: Int); return n)
16:10:25 <lambdabot> parse error on input ‘)’
16:10:26 <shanemikel> lol, yup
16:10:28 <geekosaur> :t (do s <- getLine; let {n = read s :: Int}; return n)
16:10:29 <lambdabot> IO Int
16:10:33 <shanemikel> there you go
16:10:34 <shanemikel> thanks
16:10:51 <AdituV> huh, I didn't know about that let braces thing.  cool
16:11:01 <dfeuer> Ping dolio.
16:11:03 <geekosaur> AdituV, it must be braces. let uses layout, so for a 1-liner you need to replace the layout with braces
16:11:12 <dolio> Yo.
16:11:18 <koz_> dolio: Sup?
16:11:19 <shanemikel> why not for do?
16:12:02 <dfeuer> Yo yo! dolio, I should've thought of you when looking about for people to review this crazy code. https://github.com/haskell/containers/pull/220 I'm mostly concerned about two things:
16:12:10 <geekosaur> because there's no other thing contending for the layout
16:12:31 <geekosaur> the let needs it only because the parser can't tell where the let block ends and the do block resumes
16:12:49 <geekosaur> if you nested do blocks then you'd find you needed the braces around the nested one as well
16:12:51 <shanemikel> and the do is not surrounded by another expression
16:12:54 <dfeuer> 1. I don't have the means to easily test that my fallback cutoffs are correct. That requires a 32-bit word and a very large, very unbalanced map.
16:13:00 <AdituV> shanemikel: ahh thanks, I get it now
16:13:29 <shanemikel> AdituV: once you're in IO, theres no escaping
16:13:55 <ertes> > concat (map (replicate 3) "abcd")  -- this is a social experiment
16:13:57 <lambdabot>  "aaabbbcccddd"
16:14:07 <sm> more book pricing trivia: http://www.amazon.com/Haskell-Functional-Programming-International-Computer/dp/0201882957/ref=pd_cp_14_3?ie=UTF8&refRID=09EZCGY7PT5JFSDHW86N is $40, or *$190* on kindle
16:14:09 <dfeuer> 2. Earlier, when I was using the Map.alter argument order instead of the At.at order, I was having a lot of trouble with the Identity RULES, and had to expand out to two arguments to make it work right. This doesn't *seem* necessary here, but I feel like I really don't understand what the story is about how to decide how to do that right.
16:14:53 <shanemikel> It's gonna feel restrictive and awkward, but later, once you learn about monad transformers, you will feel better
16:14:54 <dfeuer> I don't want to goof up and have the rules not fire, or do that insane thing where performance mysteriously goes utterly down the drain (worse than either LHS or RHS of RULES)
16:15:36 <AdituV> shanemikel: now it sounds like you're talking to the wrong person ^^  original question was bbear
16:15:41 <dfeuer> dolio, also, I'm curious whether there's a nice fast way to get one more bit out of my BitQueue. I can't see how to do it without splitting a shift into two rounds of shifting or adding a branch.
16:15:46 <ertes> i never liked this notion that you can't get out of IO…  it's really the other way around: you can't get *into* IO
16:15:49 <shanemikel> oh
16:16:06 <ertes> you *start* in IO after all
16:16:15 <dfeuer> ertes, that's not how I see it.
16:16:16 <shanemikel> ertes, I suppose that's more precise
16:17:14 <dfeuer> I would say "You can't get an `a` out of an `IO a`." And I like to describe the type of `IO a` as being the type of recipes for baking values of type `a`. You can't take the cake out of the recipe; you have to follow the recipe to bake the cake.
16:18:49 <shanemikel> what's your metaphor for unsafePerformIO?
16:19:03 <shanemikel> Stealing a cake?
16:19:54 <idev> why is the def of ">>-
16:19:57 <ertes> do you really need a metaphor for something that breaks metaphors?
16:19:58 <dfeuer> shanemikel, I don't have a metaphor for it. It's a window into some particular runtime systems that doesn't make any sense in a more general Haskellian context.
16:20:11 <idev> why is the def of ">>-" in https://hackage.haskell.org/package/logict-0.6.0.2/docs/src/Control-Monad-Logic-Class.html#lnot not just ">>=" ? it seems to have identical signature to bind
16:20:26 <ertes> idev: it has different semantics
16:20:33 <simpson> shanemikel: Let's say that you have a recipe for a brick oven, and you want a pizza. unsafePerformIO is like taking the first brick from the pile of bricks and biting into it.
16:20:46 <shanemikel> lol
16:21:11 <shanemikel> So, oxford starts their first year students with Haskell?
16:21:13 <ertes> idev: try this:  take 10 $ [1,3..] >>- \x -> [2,4..] >>- \y -> pure (x, y)
16:21:14 <simpson> If done correctly, it will be exactly like pizza, just not...pizza-shaped.
16:21:19 <ertes> idev: then do the same with (>>=)
16:21:36 <AdituV> shanemikel: yeah.  I didn't go there though, so can't say more than that :p
16:21:49 <shanemikel> I wonder why not ghc
16:22:44 <JuanDaugherty> they devolved
16:22:46 <Tendies> Hi I'm trying to create a type called interval that has a lower and upper bound and has functions to give the lower bound, give midpoint, and give upper bound
16:22:53 <shanemikel> I'm looking for a book that provides insights and examples into rolling your own control structures in haskell
16:23:16 <Tendies> I'm confused how to set this up. do i define a typeclass, say Range Float Float, and make a class Interval that takes a Range type?
16:23:46 <ertes> Tendies: is the interval type-bound or value-bound?
16:23:59 <shanemikel> I did pretty well with the Transformers and Continuations pages on wikibooks, now I'm looking into arrows and delimited continuations.. but so far it looks like I'm gonna have to dive into research papers, and I don't' feel quite ready to do it
16:24:00 <dfeuer> shanemikel, a *book*? I'm not sure that's the way to go. There are some fun articles, like "A tutorial on the universality and expressiveness of fold". And you can read source code to some interesting libraries.
16:24:32 <Tendies> ertes: i'm not sure entirely. It just needs to have two floats, an upper bound and a lower bound
16:24:35 <AdituV> Tendies: you probably want a datatype 
16:24:53 <ertes> Tendies: do you know how to define a type?
16:24:54 <Tendies> oh
16:25:11 <dfeuer> shanemikel, I would generally recommend reading things that *other people* write about work that Oleg Kiselyov has done, or articles he's written with others. His own solo papers tend to be quite dense.
16:25:12 <Profpatsch> Hm, I had to apply two nested fmaps to datastructures twice now.
16:25:18 <JuanDaugherty> also there are interval libraries you might want to look at
16:25:22 <Tendies> i know how to make the type yes, but i don't know how to make a class for that type
16:25:23 <Profpatsch> But the best I’ve come up with is something like
16:25:34 <ertes> Tendies: what do you need a class for?
16:25:39 <Profpatsch> (fmap transInner).transOuter <$> data
16:25:40 <AdituV> Tendies: do you even need a class?  You could just make a function on its own
16:25:58 <Profpatsch> Is there some easier-to-read way to write that?
16:26:17 <bbear> so strictly speaking how do you read n lines, each integer on a different line ?
16:26:29 * dfeuer wonders if dolio fell down the rabbit hole of reading his code, or got called away to other matters.
16:26:39 <dolio> I'm looking at it.
16:26:42 <dfeuer> Thanks!
16:26:44 <bbear> (assuming the input is correctly formatted -- which is a non haskellian concept I suppose).
16:26:56 <dolio> I can't say it's obvious to me why most of this is in here, but I haven't been paying attention to this.
16:26:58 <ertes> Tendies: you use classes when you have *multiple* types with common semantics, which can be confusing if you're coming from an OOP background
16:27:04 <Tendies> ertes, well where i'm confused as far as just using a typeclass is that equality on an interval needs to be defined mifferenly
16:27:28 <ertes> Tendies: you want your type to be an instance of the Eq type class?
16:27:29 <Tendies> because if two intervals overlap they aren't > or < than one another
16:27:43 <shanemikel> Tendies: can you describe the methods you're looking to have on an Interval class?
16:27:57 <AdituV> instance Eq Interval where.... ?
16:28:09 <ertes> Tendies: i suggest you write the functions first without using any class
16:28:32 <dfeuer> dolio, that reminds me that I definitely need to write a high-level overview. The raison d'etre (sp?) of the whole exercise is to do a good job of modifying maps with expensive-to-compare keys in heavy functors (like []). But performance has to be very good in all the other cases. I want to replace the implementation of Control.Lens.At.at for Data.Map.
16:28:34 <shanemikel> Tendies: or, you can look into a class for partial ordering
16:29:03 <dolio> I understand the high level.
16:29:08 <Tendies> shanemikel: i'm not very experienced in haskell and i'm making this type in an attempt to learn
16:29:15 <dolio> Just not why a bit queue is involved, etc.
16:29:24 <Tendies> type, or.. thing.. i don't know what to call it
16:29:39 <ertes> Tendies: your Interval is a type, and your functions are, well, functions =)
16:30:02 <dfeuer> dolio, the bit queue is a breadcrumb trail. It's just a really, really cheap one that won't hurt even lookup performance much.
16:30:47 <dfeuer> Instead of building a continuation or zipper (expensive, relatively), it just keeps track at each node of whether it went left or right, so it can follow that path back in.
16:30:55 <ertes> Tendies: do you have an OOP background?
16:31:07 <shanemikel> class ~= interface, type or datatype ~= struct/union, type alias.. exactly what it sounds like
16:31:11 <dfeuer> The fallback builds a continuation, and it's the fallback because its constant factors suck.
16:31:26 <Tendies> ertes: yeah, i'm from c++
16:31:41 <shanemikel> It's a little confusing that the sytnax to declare a type alias is just "type" because you won't hear anybody referring to it like that
16:31:52 <ertes> Tendies: then i strongly suggest that you ignore type classes for now…  pretend that they don't exist as much as you can
16:32:09 <dfeuer> C++ is OOP? I thought it was "oops!"
16:32:31 <Tendies> or rather id say i just come from.. not functional languages
16:32:34 <dfeuer> shanemikel, I don't think most beginners should declare type synonyms at all. Ever.
16:32:57 <shanemikel> dfeuer: well, he's gonna see 'em, and hear of 'em, so he should know about 'em to avoid confusion
16:33:04 <dolio> Is this cheaper than using the stack?
16:33:34 <dfeuer> dolio, how are you going to uses the stack with a functor like [], IO, etc.?
16:33:58 <dfeuer> Have I missed something really obvious?
16:34:01 <ertes> Tendies: we use a lot of the terminology that OOP uses, but mean entirely different things (because our terminology comes from math and logic), which can be confusing
16:34:11 <dfeuer> The stack *is* faster for Identity, which is why I have RULES for that.
16:34:19 <ertes> Tendies: a "class" in haskell has almost nothing to do with a class in C++
16:34:34 <dolio> I guess it's entirely possible that it is faster.
16:34:36 <hpc> in fact it has less than almost nothing
16:34:39 <shanemikel> Sum types (e.g. `data A = B | C`) correspond exactly to unions, where Product types (e.g. `data A = A Int String`) correspond exactly to structs, or tuples
16:34:41 <Tendies> yeah im feeling it 
16:35:08 <Tendies> i think ill do as you said though ertes and do it with just a type and plain functions
16:35:19 <monochrom> shanemikel: it's true, I am do not extremely like the choice of keywords "type", "newtype", and "data". (actually I think "data" is ok, the other two are not.)
16:35:19 <AdituV> tiny correction: sum types ~= *tagged* unions
16:35:32 <AdituV> (but how often do you use an untagged union?)
16:35:56 <dfeuer> The whole alterFIdentity is the stack-based version. I don't rewrite to alter because alter makes very different trade-offs and is therefore quite a bit worse in shape-preserving cases than even the bit-queue version.
16:36:06 <ertes> Tendies: don't worry about modularity for now…  we have different facilities for that (and type classes aren't one of them, or only in a very limited sense)
16:36:24 <shanemikel> I believe the reason that classes don't come across easily, is AFAIK ad-hoc polymorphism is really not well supported by C++
16:36:25 <dolio> Hmm, okay.
16:36:26 <dfeuer> ?????
16:36:32 <shanemikel> but that's heresay
16:36:37 <dfeuer> Type classes are very useful for modularity. What????
16:37:05 <Tendies> im having a terminology problem again ;_;
16:37:15 <ertes> dfeuer: i mean modularity as in keeping things separate and local in a very literal sense
16:37:26 <ertes> like haskell modules
16:37:30 <shanemikel> Tendies: you will need to learn monads and functors eventually, and that's probably the best time to learn about classes
16:37:47 <ertes> shanemikel: uuuhhhh…
16:37:49 <shanemikel> just put it off until you need to start working with collections and IO
16:37:53 <Tendies> say i have a type i've defined with two parts, a float for lower and a float for upper. If a functino was to take such a type, how would i access the upper float for the purpose of displaying what the upper bound of that instance was?
16:37:57 <ertes> shanemikel: UUUUHHHHHH…
16:38:14 <monochrom> :)
16:38:16 <AdituV> Tendies: pattern match on it!
16:38:20 <shanemikel> ertes: what?
16:38:30 <monochrom> you also have to put it off until you need numbers :)
16:38:35 <dfeuer> shanemikel, I also have a soft spot for the beginner-friendly Ord, but its superclass Eq is mostly bad for beginners.
16:39:01 <monochrom> wait, how is Eq bad?
16:39:33 <ertes> shanemikel: i think functors and monads are about the *worst* time to learn about classes…  and collections (with their lovely class-based interface) and IO…  well…
16:39:35 <dfeuer> monochrom, many beginners use it when they should use pattern matching. It's not bad in and of itself.
16:39:44 <Tendies> AdituV: like, my function def is lower :: Interval a -> Float b, and i need to get the "lower" float out of the Interval "a"
16:39:47 <monochrom> I see
16:39:57 <AdituV> Tendies: why is it "Interval a"?  
16:40:21 <Tendies> i want my function to take an Interval and return a float corresponding to that interval's lower bound
16:40:25 <shanemikel> dfeuer: I don't see how you could get away with that for very long.. how do you unpack anything?
16:40:28 <AdituV> Tendies: right.  So lower :: Interval -> Float
16:40:32 <shanemikel> err.. unwrap
16:40:39 <ertes> Tendies: data Interval = Interval Float Float
16:40:43 <dfeuer> I just think it's best to get thoroughly accustomed to computation by pattern matching before being exposed to the easily-abused ==.
16:40:47 <ertes> Tendies: f (Interval lower upper) = ...
16:40:51 <dfeuer> shanemikel, how do you unwrap what?
16:40:57 <AdituV> Tendies: you can deconstruct a datatype by pattern matching.  For example `lower (Interval hi lo) = lo`
16:40:57 <ertes> Tendies: that's called pattern-matching
16:40:58 <monochrom> this is a hard problem because from other programming languages, even from math itself, equality has always been the only matcher they taught you.
16:41:58 <shanemikel> dfeuer: nvm
16:42:56 <dfeuer> monochrom, not quite.   f(0) = 3; f(k + 1) = f(k) * 12  is perfectly standard mathiness.
16:43:03 <shanemikel> ertes: when would you suggest exposure?
16:43:10 <Tendies> AdituV: that was just what i needed! 
16:43:21 <ertes> shanemikel: i like monoids for that…  they aren't particularly difficult or interesting, but they are very useful and have a lovely type class interface
16:43:23 <dfeuer> Of course, n+k patterns are dead in Haskell.
16:43:27 <ertes> shanemikel: or even just Eq and Ord
16:43:34 <Tendies> didnt know you could deconstruct, very good
16:44:35 <ertes> Tendies: after two years of haskell you will complain about every language that lacks pattern-matching, while in haskell you will cry every time you have to pattern-match explicitly
16:45:02 <AdituV> ertes: I tried elm for the first time the other week.  I was crying so hard about the explicit pattern matching ^^
16:45:03 <dredozubov> why would you cry?
16:45:19 <monochrom> that does not show the full story. the full story happens when you watch the teacher explain how to use it for computation. the teacher will say, literally, "to compute f(10), observe 10 equals 9+1". the teacher does not say "pattern matching". the teacher says "equal".
16:45:42 <dfeuer> dolio, can you suggest a way to reduce code duplication between Data.Map.Base and Data.Map.Strict here? It's really bothering me.
16:47:10 <monochrom> for more examples, observe how a discrete math course demonstrates structural induction proofs on trees. "base case: T = the empty tree". "induction step: T = root node with left subtree L, right subtree R". they say "equal". students will just assume that "equal" is the only option.
16:47:30 <dfeuer> monochrom, yes, and pattern matching involves equality too. But it's a rather different, more formal notion of equality than ==.
16:47:57 <monochrom> but no teacher will mention that, and no students will guess that.
16:48:20 <ertes> is this really equality?  it has a binding, quantifying nature
16:48:28 <ertes> unification
16:48:36 <monochrom> and if you try to postpone or avoid mentioning Haskell's ==, students will demand it here-and-now anyway
16:49:08 <ertes> AdituV: EvanR ruined elm for me earlier today
16:49:19 <Tendies> okay ertes, i've written the functions i want for the interval type. But it seems that in order to have a different definition of equality for my type means using "instance" 
16:49:44 <ertes> Tendies: first of all, can you define equality for your type?
16:49:55 <shanemikel> Yeah, you might be right.  However, seeing as how most languages have a default equality of reference, I think most people get introduced to polymorphism with the notion of containers (at least I did, with Java "Generics").  So, I feel it's likely to recognize a need for polymorphism in that capacity, sooner (and perhaps a way to comfort them in a new land).
16:50:23 <shanemikel> On the other hand, getting the idea of references out of a persons head quickly could be a good thing.
16:51:04 <ertes> Tendies: if two intervals are equal when their lower and upper bounds are equal respectively, you can write an Eq instance, or you can even let the compiler derive the instance for you
16:51:12 <ertes> Tendies: data Interval = Interval Float Float deriving (Eq)
16:51:50 <Tendies> i'm going to read this page on realworldhaskell, it seems it may help me do what i want
16:51:52 <shanemikel> anyway, functors are perfectly simple when you limit yourself to traditional container types
16:52:01 <Cale> ertes: What'd EvanR say about Elm?
16:52:21 <ertes> Cale: they just made me read the most recent blog post
16:52:28 <Tendies> ertes: oh, yeah i know how to just derive Eq, but the problem is Eq doesn't do equality how i need it to be
16:52:29 <Cale> Oh
16:52:38 <monochrom> Cale: I think it's the "Elm is replacing FRP by ..." thing
16:53:07 <monochrom> I don't know replace by what. I only read a few sentences from LtU
16:53:27 <ertes> Cale: the gist: "we no longer need FRP (not that we were using it in the first place), because now WE HAVE THE OBSERVER PATTERN!"
16:53:44 <Cale> ertes: Right, I saw the article actually
16:53:48 <AdituV> ertes: oh ew
16:54:21 <shanemikel> so, to see an example of implementing the interface Eq, http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
16:54:31 <monochrom> "the Observer pattern" is a provocative way to say it. but if you say "tangible values" (which is the same thing) it's suddenly politically correct.
16:54:34 <shanemikel> (instantiating the typeclass for a type, that is)
16:54:39 <geekosaur> my read of that was more "we gave up on convincing people to do it right and gave them what they demanded instead"
16:55:07 <Cale> ertes: Really, they've gone from having one sort of broken implementation of FRP to another. The new (Sub a) type is quite a bit like (Event a), only without most of the operations you'd want on that.
16:55:21 <dolio> dfeuer: Why would someone use alter instead of alterF with Identity, or vice versa?
16:55:23 <Cale> But hey, it has never, fmap and some kind of merge...
16:56:42 <shanemikel> that's a shame about Elm.. but at least we don't have a kid running around implying publicly that he knows better than a lot of experienced researchers
16:57:13 <dfeuer> dolio, if the probability is very high that they will add or remove a key, then alter will generally be better. If there's a good chance they'll leave the map alone (delete absent) or modify the value of an existing key, then alterF with Identity will generally be better.
16:57:21 <monochrom> no kid would do that. but a few old people do.
16:58:13 <dfeuer> dolio, I think there's a decent argument for replacing alter with alterFIdentity, but it's not a pure win. I  think the argument is extremely good for using such a technique for insertWith.
16:58:28 <dfeuer> And also for update.
16:58:29 <dolio> dfeuer: I don't believe people are going to consciously choose between these two ways of altering a map based on that.
16:59:25 <shanemikel> monochrom: https://www.youtube.com/watch?v=Agu6jipKfYw .. I appreciate his work.. but that presentation carries a pretentious tone 
16:59:34 <ertes> Cale: "we never supported switching anyway, so let's just remove the remaining useful combinators"?
16:59:41 <Cale> ertes: right.
17:00:03 <dolio> So, I think one should be picked and used, independently of alterF.
17:00:39 <dfeuer> dolio, that's valid. In this pull request, I don't want to make that decision. But I do think your input on https://github.com/haskell/containers/issues/217 which discusses that general question, would certainly be appreciated.
17:01:04 <ertes> they're right though…  an incomplete API is easier to learn than a useful API
17:01:32 <dfeuer> The alterF way is about 5% slower on insert-absent, and maybe 6% slower on delete-present.
17:02:03 <dfeuer> It's ridiculously much faster on delete-absent, and maybe ... 20%? faster on insert-present.
17:02:08 <shanemikel> can you link the article?
17:03:23 <shanemikel> Tendies: did you see the link I posted for you/
17:03:34 <Cale> ertes: We just need to get as much documentation effort put into reflex and reflex-dom somehow... well, Ryan's been secretly working on a new version which will get released in the next few weeks, and I hear it's better organised and he's put a bunch of thought into making it more accessible.
17:04:10 <Tendies> im looking at it yeah
17:04:29 <dolio> dfeuer: You did make the decision, though. You decided that alterF should make the opposite decision that is made in alter. :)
17:04:35 <dfeuer> Cale, what little I've seen of reflex looks very carefully considered. I really hope it works out.
17:04:44 <dolio> And that's the primary source of duplicated code.
17:04:55 <Cale> dfeuer: It's certainly lovely to use once you're used to it
17:05:32 <Profpatsch> It looks to me like string literals are not unicode? oO
17:05:40 <Profpatsch>                       <*> m .: "AI_Straße"
17:05:44 <dfeuer> dolio, that's not true! I didn't have a choice once I determined that building a continuation was too expensive!
17:05:49 <Profpatsch> But:
17:05:52 <Profpatsch> <interactive>: parse error (Failed reading: conversion error: no field named "AI_Stra\223e") at 
17:06:09 <Cale> dfeuer: The main trouble right now for beginners is just that it's a little tricky to figure out what the important bits are when you're starting out -- there are very important things that you'll use all the time, and seldom-used-but-fundamental things sitting in the same modules.
17:06:17 <ertes> Profpatsch: your source code file must be in UTF-8 i think
17:06:33 <geekosaur> yes
17:06:53 <dfeuer> dolio, well, okay, maybe I had a bit of a choice. But then alterF, not specialized to Identity, would be slower *everywhere*.
17:07:04 <dolio> dfeuer: alterFPlain is your rewritten alter, which is used in a rewrite rule for alterF, when alter could be used.
17:07:04 <geekosaur> well, it uses your locale. used to be it required ISO8859 which is what that looks like to me
17:07:11 <ertes> Profpatsch: String and Text literals certainly support unicode…  note that ByteString literals can be problematic
17:07:19 <geekosaur> could try forcing LANG=C
17:07:26 <Profpatsch> ertes: file(1) says they are.
17:07:33 <Profpatsch> Err, the file is.
17:07:54 <dfeuer> dolio, to use alter in the rewrite rules, I'd feel obligated to make alterF (without such rules) perform generally like alter. Because otherwise the rules would sometimes make it much slower.
17:07:58 <geekosaur> \223 is not utf8
17:08:09 <shanemikel> :i Ord
17:08:33 <monochrom> I would use a hex editor to confirm the bytes in a file. but I guess file(1) is not dumb.
17:08:43 <shanemikel> :t Ordering
17:08:45 <lambdabot> Not in scope: data constructor ‘Ordering’
17:08:48 <shanemikel> :i Ordering
17:08:56 <shanemikel> hmm...
17:08:58 <ertes> Cale: i want to see the new version, too, though i'm not sure how he could improve the API, and the way it sounded he was mainly doing internal improvements
17:09:00 <geekosaur> there's no :i in lambdabot
17:09:04 <Profpatsch> geekosaur: Ooooooh, cassava takes ByteStrings as field names.
17:09:17 <Cale> ertes: Well, for one, Dynamic is getting an Applicative instance
17:09:35 <ertes> oh, finally!
17:09:38 <Profpatsch> So I need to explicitely input Strings and convert them to ByteStrings.
17:09:53 <Profpatsch> OverloadedStrings is not as innocent as it may seem.
17:10:13 <geekosaur> oh. then I have to assume you need to encode it in utf8, since ByteString won't take that as is
17:10:16 <ertes> Profpatsch: the trouble is that ByteString is abused as a text type here
17:10:44 <ertes> it's the old byte vs. character story
17:11:07 <dfeuer> dolio, somewhere we have to compare what went into the function with what came out of it. In the BitQueue regime, we can either do that *before* we "go back down" or *after*. Doing it *before* saves time because we get to build a custom call stack. alter only goes down once, so its call stack has to deal with what's going on as it comes up.
17:11:42 <ertes> Profpatsch: not to say that cassava had a choice in the first place…  it does follow the RFC
17:11:52 <shanemikel> Tendies: You mentioned before, that some intervals are less than, equal to, or greater than others, but some are not necessarilly comparable.  the problem with the Ord class, is that its methods return the type Ordering, which is defined as `data Ordering = LT | EQ | GT`, you see.  There is no constructor for an uncomparable value.  Hence, the suggestion that you use another class similar to Ord, that allows for partial ordering.
17:12:30 <ertes> compareM :: Interval -> Interval -> Maybe Ordering
17:13:27 <shanemikel> which, would be certainly easy to do.  and I agree with the suggestion wholeheartedly.
17:13:47 <dolio> dfeuer: Anyhow, the obvious answer to how to not duplicate code is: don't use bang patterns for your strictness.
17:14:04 <dolio> That's the only reason the code needs to be duplicated.
17:14:30 <Profpatsch> ertes: Huh, but I don’t know what I should do then.
17:14:53 <dfeuer> dolio, oh, you mean pass in a copy of seq/const, and try to make sure things inline enough?
17:15:07 <dolio> Right. Or even a boolean argument or something.
17:15:13 <ertes> Profpatsch: make sure your encoding matches the encoding of the file
17:15:23 <dolio> And make sure constructor specialization happens.
17:15:37 <ertes> Profpatsch: the safest option would be to use ASCII for CSV headers
17:15:45 <ertes> ugly, but safe
17:15:50 <dfeuer> Hrrrmmmm... That sounds a bit finicky.
17:16:01 <Profpatsch> Oh, it seems like I can convert from Text and it matches.
17:16:22 <monochrom> yes, the Text route goes through utf-8
17:16:47 <dolio> But I think the right answer is to not write alterFPlain at all.
17:16:51 <monochrom> I don't entirely know why the ByteString IsString instance stays with 8859-1
17:17:10 <ertes> probably .Char8 legacy
17:17:27 <ertes> utf8-string is still a separate library after all
17:17:35 <monochrom> IsString was conceived long after 8859-1 was taboo. one would think they would go utf-8
17:17:48 <dfeuer> dolio, so you think I should change alter to alterPlain? Or I should sometimes let the rewrite rules slow the code down?
17:18:41 <Profpatsch> monochrom: Ah, I see.
17:19:18 <Profpatsch> I am using toS to do it semi-automatically.
17:19:45 <dolio> For this patch, I'd let the rewrite rules slow down the code, and have a separate discussion about alter. Maybe the outcome is that there are both functions with explicit tradeoffs, and then the rewrite rule uses the one that acts more similarly to alterF.
17:19:54 <dolio> Or just don't rewrite for Identity at all.
17:20:18 <ertes> monochrom: would be weird to have a fromString that encodes to UTF-8, but no API to actually handle it
17:20:51 <ertes> the real problem is that bytestring still offers the .Char8 interface
17:21:25 <Tendies> i'm told that to make an instance of a default typeclass, i need to know what functions i need to redefine for it. it says to look in the docs, but i'm not seeing anything to the tune of "to make an instance of this typeclass you must define ...". is hackage not "the docs"?
17:22:04 <Tendies> oh sorry!
17:22:06 <shanemikel> ertes's suggestion is to simply implement a function that returns a Maybe Ordering, and that's a very simple fix. the only benefit to going the class route (other than learning about classes), is you could define other functions that use the ordering (e.g. sorting functions) that are generic... mySort :: PartialOrd a => [a] -> [a]
17:22:24 <dfeuer> I'm not going to do that. I'll see what I can do about the lazy/strict code duplication though. Ultimately, alter may be changed to alterF, or alterFPlain may be exposed with a sensible name, but I care more about high consistent performance than about avoiding a bit of extra code.
17:22:24 <Tendies> "minimal complete definition" means the same thing doesn't it? the 
17:22:49 <Tendies> the minimum complete definition for the typeclass instance is what i need to define to use it.. ok
17:23:03 <ertes> Tendies: at least
17:23:19 <monochrom> ertes: there is a funny piece of history. ByteString came from PackedString, an internal library of GHC (for GHC itself to store identifiers compactly). PackedString and probably early ByteString did utf-8. it then switched to 8859-1.
17:23:23 <ertes> for an Eq instance (==) is enough, because (/=) follows from it
17:23:48 <shanemikel> Tendies: it is your option to define others, only because you may have a more performant implementation
17:23:49 <ertes> monochrom: seems like a weird choice
17:24:46 <ertes> monochrom: on the other hand i really don't see ByteString as a text type, and i'd want 'length' to be O(1)
17:26:04 <monochrom> I don't think there is any conflict between "I store utf-8" and O(1) length.
17:26:28 <ertes> monochrom: splitAt may be a better example
17:26:39 <monochrom> In fact if I put "ë" in utf-8 and ask for length, I expect the answer to be 2, not 1.
17:27:03 <ertes> well, that's a philosophical discussion
17:27:40 <ertes> don't get me wrong, i'd want fromString to encode as UTF-8
17:27:42 <Sonolin> will haskell GC a large list stored in the state monad, assuming each action only uses the head of the list?
17:28:07 <ertes> but that only makes sense if .Char8 disappears and is replaced by a UTF-8 API
17:28:18 <Sonolin> e.g. I'm trying to figure out if something like this is even necessary:
17:28:45 <Sonolin> do { s <- get :: [String]; put (take 5 ("new element":s) }
17:29:15 <Sonolin> when later, I only use "head s" (of old state)
17:29:55 <Sonolin> (well technically "take 5 s" not just head s)
17:30:14 <monochrom> I use an economic argument, not a philosophical argument. I convert some characters into some bytes and put them in a bytestring. Then I will send it out through my ISP to you. My ISP charges me $1 per byte. So I surely want bytestring's length to tell me how many dollars I will be spending, not how many characters it represents.
17:31:06 <ertes> monochrom: no disagreement, Data.ByteString gives you that semantics
17:31:32 <Tendies> If i'm making an instance of Ord, but i only want to use >, < on my type, do i still need to define compare or <=
17:31:36 <monochrom> splitAt splitting the middle of a utf-8 stream is unfortunate. but it is not like 8859-1 solves it. if 8859-1 can't even preserve my ≤ sign, there is no point worrying about splitAt
17:31:40 <anks> I've got some basic question about pipes library. This code https://gist.github.com/5fcc6c2d420cbecdb3961f205680c046 is returning a size of a chunk, how to return the size of file?
17:31:40 <shanemikel> Sonolin: I'm not totally sure, but I think GHC will not GC stuff you still hold references to
17:32:06 <Sonolin> ah ok that's what I was assuming, but just wanted to check
17:32:14 <ertes> Sonolin: it won't GC before the 'head s'
17:32:30 <monochrom> anyway I enjoy using ecomonics to trump philosophy
17:32:31 <ertes> … is evaluated
17:33:04 <ertes> monochrom: i'm still talking about .Char8 though, not about Data.ByteString
17:33:15 <geekosaur> Tendies, yes
17:33:21 <ertes> ideally get rid of the bytestring library altogether
17:33:24 <geekosaur> because < and > are defined in terms of one of those two
17:33:31 <ertes> vector has a better API in every way
17:34:04 <geekosaur> ertes, there's  ahistorical thing here
17:34:20 <Sonolin> I guess I'm just wondering if I can safely store a huge (almost endless) list in state, without too much memory loss, assuming I only use "head s" in my monadic action
17:34:49 <monochrom> Alt.Data.ByteString.Char8.Die.Die.Die would be a great name for a newsgroup in the alt hierarchy
17:34:52 <geekosaur> specifically, I think if you want to propose that, you also get to rewrite ghc in terms of Vector. (ByteString derives from ghc's old "fast packed string" internal type)
17:34:56 <Sonolin> maybe I'm just worrying too much about optimization at this stage, but its just something I was pondering
17:35:10 <shanemikel> No, it's a perfectly reasonable question
17:35:43 <shanemikel> ertes: Can you elaborate on the GC question?
17:35:53 <Sonolin> I suppose, since I'm not evaluating the entire list, there's nothing "too store"... since technically you can have an endless list in haskell without memory spike
17:36:22 <ertes> shanemikel: not sure how
17:36:25 <johnw> anks: you'll need to split the pipe (ala 'tee'), so that one end goes into a fold computing the length, and the other goes to stdout
17:36:28 <Sonolin> but idk
17:36:35 <johnw> the exact same as you would do at the shell, essentially
17:37:11 <Tendies> ertes: but if i only define compare, i can then use <, > without defining those too?
17:37:14 <shanemikel> if he puts the large list into his state monad, and proceeds to only use the head, will it be GC'd before he exits the monad?
17:37:20 <Tendies> @_@
17:37:30 <ertes> there is one pitfall with GC: fields of a constructor are not collected, until the constructor itself is collected
17:37:44 <ertes> other than that GC does pretty much what you would expect
17:37:56 <shanemikel> Tendies: you can define your own < and >, and hide the prelude versions, if you like
17:38:08 <ertes> Tendies: yeah
17:38:31 <ertes> Tendies: all comparison operators follow from 'compare'
17:38:47 <Tendies> as for the incomparable thing you were talking about shanemikel, i think in this case i can use Ord and just make sure if the intervals interlap that the result is false
17:38:49 <shanemikel> oh.. misunderstood
17:39:09 <geekosaur> Tendies: < and > are defined in terms of compare, the default compare is defined in terms of == (inherited from Eq superclass) and <=
17:39:17 <geekosaur> so you need to define iether (<=) or compare
17:39:33 <ertes> Tendies: in fact you should only write a minimal complete definition, unless you have more efficient implementations for (<=), etc.
17:39:48 <Tendies> ok i guess ill look at the original version of Ord's compare and modify it to do what i need
17:39:52 <ertes> Tendies: also note that in general we assume Ord instances to be totally ordered
17:40:13 <shanemikel> Tendies: false? which of LT, EQ, and GT are false?
17:40:40 <Tendies> the results of <, >
17:40:56 <Tendies> so i will have to make my own <, > in addition :o
17:41:00 <ertes> Tendies: 'compare' must give LT, EQ or GT, and the behaviours of (<) and (>) follow from it
17:41:07 <anks> johnw: I think I still don't get how to use pipes. Thanks anyway
17:41:07 <anks>  
17:42:03 <ertes> Tendies: in other words, for a valid Ord instance, given two values of your type, you *must* decide whether they are equal or, if not, which one is the smaller one
17:42:29 <Tendies> the comparison parameters ensure the intervals are not overlapping
17:42:38 <Tendies> so then i think i dont have to worry
17:43:21 <shanemikel> ertes: do you know of a partial ordering class that comes with sorting classes (better yet, is there a blessed one?)
17:43:26 <shanemikel> err.. sorting funcitons
17:43:42 <ertes> none that i know of
17:44:33 <roconnor> are there RTS flags that will print the maximum heap usage after a program exits?
17:45:31 <dolio> roconnor: -s
17:45:33 <ertes> roconnor: -s displays "maximum residency"…  is that what you mean?
17:45:53 <roconnor> I think so
17:46:09 <ertes> -t displays it, too
17:46:14 <roconnor> what is -t
17:46:19 <ertes> mini-s
17:46:24 <roconnor> ah
17:46:38 <ertes> if all else fails, use 'time'
17:46:44 <ertes> time ./myprogram
17:47:06 <roconnor> BTW, Control.Parellel.Stragies indeed did make my code easy to parallelize.  The promise was true.
17:47:16 <roconnor> ertes: in this case I'm interested in memory use.
17:47:23 <roconnor> oh does time give that?
17:47:28 <ertes> roconnor: it does
17:47:31 <roconnor> :D
17:47:39 <geekosaur> the simple one does not. many shells have a time built-in that gives full rusage info
17:47:46 <geekosaur> (or that can give it)
17:48:00 <ertes> (bad ertes, assuming an operating system again…)
17:48:18 <roconnor> though I did have to rearrange my code a little bit to get the parallisim I wanted.
17:48:20 <Tendies> ack! i non exhaustive pattern for compare so i cant instance from Ord. What are some partially ordered default typeclasses?
17:48:50 <ertes> Tendies: are are none in the base library…  just write a function
17:49:12 <shanemikel> Tendies: I think you can be okay with implementing each of < > <= >= yourself, and give compare a nonsensical implementation, but then again, it will be nonsensical.. or you can implement compare to return LT for uncomparable intervals, and the rest as usual
17:49:12 <Tendies> can i make that function be invoked using <, > ?
17:49:20 <ertes> Tendies: i think you have this uncomfortable feeling that standalone functions must be a bad idea
17:50:00 <Tendies> ertes: im trying to instance from default types that use <, > to invoke, because i don't know that i can overload <, >
17:50:20 <ertes> Tendies: you can, but only with a total order
17:50:23 <shanemikel> if you MUST use polymorphism for this, I suggest looking at Data.Poset from the altfloat package (doing it the right way), or going from ertes' suggestion
17:51:07 <shanemikel> if you need to have <, >, <=, >=, you can `import Prelude hiding ((<),(>),(<=),(>=))
17:51:14 <ertes> Tendies: seriously, just write a function…  note that you can invent operator names in haskell, and you can write functions infix
17:51:15 <shanemikel> and implement the functions yourself
17:51:30 <ertes> Tendies: call it (.<.) or something
17:51:39 <Tendies> it has to be < and >
17:51:44 <shanemikel> (<) :: MyData -> MyData -> Maybe Ordering
17:51:45 <ertes> Tendies: why?
17:51:56 <shanemikel> a < b = ...
17:53:03 <ertes> Tendies: sorting only makes sense with a total order anyway…  if there is some property of your intervals that gives rise to a total order, then you can just use sortBy
17:53:16 <ertes> > sortBy (comparing length) ["abc", "ab", "abcd", "a"]
17:53:18 <lambdabot>  ["a","ab","abc","abcd"]
17:54:01 <shanemikel> ertes: there are certainly situations where sorting with a partial ordering makes sense
17:54:24 <shanemikel> but he may not need any sorting anyhow...
17:54:31 <Tendies> yeah i dont need to sort them
17:54:41 <geekosaur> we sort Double even though it has NaN
17:54:43 <ertes> they were talking about sorting earlier, so i assumed
17:54:48 <geekosaur> (and it's Ord even though it has Nan, sigh)
17:54:56 <shanemikel> my final suggestion is to invent your own operator that don't clash with prelude
17:55:20 <Tendies> so if i make a function (<) that only takes my type, it won't clash?
17:55:25 <shanemikel> e.g. <? >? <=? >=? 
17:55:33 <ertes> Tendies: seconded, write a function…  feel free to name it (.<.) or (~<~) or really anything you like
17:55:35 <Tendies> since there's nothing in prelude that takes that type
17:55:36 <shanemikel> no, it will.. you need a different name
17:56:04 <ertes> Tendies: don't name it (<), otherwise you will get ambiguity errors
17:56:19 <ertes> haskell doesn't have ad-hoc overloading the way C++ does
17:56:46 <shanemikel> oh yeah, what I said about hiding them from prelude, that will NOT work, sorry
17:57:13 <shanemikel> you basically have to trash the Ord class, too, which is clearly problematic
17:57:20 <ertes> it will, if you hide it properly:  import Prelude hiding (Ord((<)))
17:57:36 <ertes> at least i think
17:57:40 <shanemikel> I stand corrected
17:57:50 <shanemikel> In any case, it's frowned upon
17:57:52 <ertes> @let import Prelude hiding (Ord((<)))
17:57:55 <lambdabot>  Defined.
17:57:57 <ertes> :t (<)
17:57:59 <lambdabot> Ord a => a -> a -> Bool
17:58:04 <ertes> so much for that
17:58:08 <ertes> @undef
17:58:08 <lambdabot> Undefined.
17:58:50 <ertes> Tendies: note that you can write every function infix in haskell
17:59:08 <ertes> > let lessThan = (<) in 3 `lessThan` 4
17:59:10 <lambdabot>  True
17:59:15 <shanemikel> ertes: that works, I just think the lambdabot environment doesn't permit it
17:59:26 <ertes> ah, i see
17:59:27 <shanemikel> I just tried it in a repl
18:00:53 <muyfine> hi all - having trouble determining behavior in a Binary instance around 'get' with a sumtype - advice very much appreciated. Don't know how to figure out how to get the right behavior chosen on deserialization where there is no constructor to drive the behavior
18:01:01 <muyfine> reduced code: http://lpaste.net/911281542112739328
18:01:56 <muyfine> I know going into the decoding which type (ProtoA or ProtoB) its going to decode to
18:02:54 <muyfine> but trying to figure out how to "force" that
18:03:36 <muyfine> should I use newtype wrappers for each protocol?
18:10:18 <muyfine> ugh, with newtype wrappers: http://lpaste.net/4301126137368543232
18:10:32 <muyfine> seems like a lot of wrapping and grossenss
18:12:50 <Cale> muyfine: I don't understand why it's a sum type
18:13:11 <Cale> muyfine: It looks like it's just two separate types, doesn't it?
18:13:50 <Tendies> i got it working how i wanted :D
18:14:12 <Tendies> what i did was in the instance, i defined compare, but then i defined < and > to not use compare
18:15:05 <Cale> Tendies: I missed the start, is that just for performance?
18:15:22 <Cale> Tendies: If you define compare correctly, you shouldn't usually have to define (<) or (>)
18:15:33 <Tendies> no its for some screwy type that needs < and > but isn't fully ordered
18:15:46 <Cale> Oh, maybe it would be better not to use the Ord class then...
18:16:08 <Tendies> but the > and < needed to be usable with the exact same name
18:16:20 <muyfine> Cale: I'm storing the messages in a channel
18:16:22 <Tendies> a dumb requirement i understand
18:16:27 <Cale> If you don't have a total ordering, it'll cause things like Set and Map to generate bad structures if someone ever tries to use your type as a key
18:16:50 <muyfine> Cale: which can hold messages from either protocol
18:17:11 <Tendies> it wouldnt make sense to put them in a set or map
18:17:22 <Tendies> or actually you could probably argue that :P
18:17:22 <muyfine> Cale: so using a sum type for that (channel is a TChan)
18:17:30 <Tendies> a map of intervals
18:17:53 <muyfine> Cale: if there's a better way to represent that, would love to hear!
18:18:49 <Cale> muyfine: hmm...
18:18:59 <Cale> There are some other ways, but I'm not sure they'd be better
18:20:09 <ertes> Tendies: i find that naming requirement suspicious
18:20:11 <Cale> This example is too simplified for me to guess what would be good
18:21:35 <muyfine> I was hoping phantom types could help out
18:21:44 <muyfine> but I'm not familiar enough with them
18:21:50 <Cale> yeah, or even non-phantom types which make the distinction
18:27:58 <ertes> good night
18:29:12 * hackagebot vty 5.5.0 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.5.0 (CoreyOConnor)
18:29:14 * hackagebot vty-examples 5.5.0 - Examples programs using the vty library.  https://hackage.haskell.org/package/vty-examples-5.5.0 (CoreyOConnor)
18:42:36 <nesstingisheart> is there such thing on haskell that only uses the if case
18:42:49 <nesstingisheart> i want to get rid of the then clause
18:43:17 <Iceland_jack> nesstingisheart: Good question
18:43:21 <Iceland_jack> What would its type be?
18:44:04 <Iceland_jack> We can think of 'if' as fancy syntax for
18:44:04 <Iceland_jack>     if :: Bool -> a -> a -> a
18:44:04 <Iceland_jack>     if True  tru _   = tru
18:44:04 <Iceland_jack>     if False _   fls = fls
18:44:23 <nesstingisheart> I was wondering the same.
18:44:33 <Iceland_jack> nesstingisheart: Here's the twist, this does actually exist. 
18:44:47 <Iceland_jack> Here's the reveal:
18:44:47 <Iceland_jack>     when :: Bool -> IO () -> IO ()
18:45:02 <Iceland_jack> It actually has a more general function
18:45:07 <Iceland_jack> *general type
18:45:07 <Iceland_jack> :t when
18:45:08 <lambdabot> Applicative f => Bool -> f () -> f ()
18:45:27 <nesstingisheart> wow, i never knew this
18:45:42 <Iceland_jack> You also have its inverse:
18:45:42 <Iceland_jack> :t unless
18:45:43 <lambdabot> Applicative f => Bool -> f () -> f ()
18:45:55 <Iceland_jack> nesstingisheart: Keep in mind that the basic idea is dead simple!
18:46:21 <Iceland_jack>     when :: Bool -> IO () -> IO ()
18:46:21 <Iceland_jack>     when True  act = act
18:46:21 <Iceland_jack>     when False _   = pure ()
18:46:21 <Iceland_jack>  
18:46:24 <Iceland_jack>  
18:46:35 <Cale> You could also, for example, define  (Monoid m) => Bool -> m -> m  like  (\b x -> if b then x else mempty), which might sometimes make sense. Not sure what name it ought to have.
18:47:41 <nesstingisheart> hahha, too much thinking i guess, should have gone with a simpler solution. thanks Iceland_jack
18:48:44 <Iceland_jack>     when      :: (Applicative f) => Bool -> f () -> f ()
18:48:44 <Iceland_jack>     when p s  = if p then s else pure ()    
18:48:51 <Iceland_jack> How it's defined in 'base'
18:48:52 <Cale> You only need to use pure () there if you're writing the general Applicative version. It would be more usual to write return () for the IO action which does nothing.
18:49:20 <Cale> (for not much reason -- it's the same thing)
18:49:41 <Iceland_jack> Right, 'return' is still with our Haskell family for historical reasons
18:50:05 <Cale> I think it's a better name tbh
18:50:40 <nesstingisheart> i agree with you
18:50:43 <Iceland_jack> Interesting, I agree and disagree.
18:51:09 <Cale> At least, given that most of our monads are some sort of computations, and return v is typically the computation which "does nothing except to return v"
18:51:26 <Iceland_jack> It depends on what view you take, if you view "pure" as a kind of identity element like "0", I think it's discriptive
18:54:20 <Iceland_jack> But when Monads were all the rage, the name 'return' became the ultimate bikeshed ;)
18:55:30 <johnw> what was the positive argument for "return" btw?  I must have missed it
18:56:02 <Cale> johnw: Just that it's quite descriptive to have return v be the action which does nothing except to return v
18:56:24 <johnw> doesn't that still not mean anything?
18:56:39 <johnw> so it was return because it's typically "the last statement"?
18:56:40 <Iceland_jack> The confusion with C's return concerned many people
18:56:50 <Iceland_jack> Because it's very different
18:57:20 <joobus> do any of the haskell web servers take advantage of multiple cpu cores?
18:57:28 <johnw> let's rename it to longjmp
18:57:37 <Iceland_jack> I'll take it.
18:57:54 <Cale> johnw: hah
18:57:55 <Hijiri> joobus: Any that use haskell threads do
18:58:33 <mgsloan> Rename it "yield" just to really mess with people
18:58:34 <Cale> johnw: No, even if it's in the middle of a do block, the action (return v) in isolation, does nothing except to result in v
18:58:54 <Hijiri> If you run with multiple cores in your RTS options, the processing of haskell threads will be spread over OS threads
18:59:05 <johnw> Cale: the best name I've ever thought of besides pure is embed; but I can't fathom the reasoning behind "return"
18:59:14 * hackagebot brick 0.6 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.6 (JonathanDaugherty)
18:59:14 <Cale> It makes perfect sense to me
18:59:37 <johnw> "return" implies going back to something earlier, or giving back something obtained earlier
18:59:43 <Iceland_jack> "doNothingButReturnThisValue" obviously
18:59:56 <Cale> johnw: Well, it returns the value as its own result
19:00:09 <johnw> Iceland_jack: oh! you mean it makes sense from the point of view of the person defining the Monad instance
19:00:19 <Cale> The "earlier" thing you're referring to is the thing which is executing return
19:00:20 <johnw> all this time I've been thinking solely of the clients of Monad
19:00:31 <mgsloan> I think johnw's on to something - we say "returns a value" due to the C tradition, however the C naming came from "returning execution to the caller"
19:00:51 <johnw> yeah, C is directly related to assembly's "ret"
19:01:05 <johnw> which, btw, does not take a value
19:01:33 <johnw> C sort of combined two operations, because it was such a common pattern, but "return;" is closest to the assembly
19:01:57 <Cale> Yeah, I suppose if you're thinking of "return" as referring to the control effect, then I can see how it's confusing.
19:02:33 <Cale> But I just think of it as referring to the fact that every action produces a value
19:02:53 <Cale> The value which it "returns"
19:02:53 <Iceland_jack> When you think of it, our use is the ‘more right’ one ;)
19:02:56 <johnw> right, thinking in terms of the action's definition, and not the user creating the action, it makes much more sense
19:03:07 <shanemikel> Tendies: take a look at these http://lpaste.net/8941567361274609664  and http://lpaste.net/7764798613397438464
19:03:17 * geekosaur wonders if it should have been called "is"
19:03:28 <johnw> what I like most about pure is the way it advertises "this has no effects"
19:03:38 <Iceland_jack> geekosaur: ..., interesting
19:03:51 <dolio> I think the only reason you think of it that way is that you had to invent a meaning that makes sense because people 15+ years ago chose bad terminology to borrow. :)
19:04:51 <mgsloan> I actually kinda like "yield" except that nowadays its associated with coroutines
19:05:11 <mgsloan> Makes more direct sense to me as an english word choice than pure
19:05:12 <dolio> Yeah, yield has all the same problems as return, really.
19:05:31 <Iceland_jack> Yeah
19:05:52 <mgsloan> Yep, pure has the advantage of not being confused with existing concepts
19:06:26 <Cale> I feel like naming it pure would just be making a concession to the fact that those people 15 years ago conflated a bunch of things when naming their thing 'return'
19:06:30 <johnw> we could just be direct about it and call it "bikeshed"
19:06:35 <Cale> hahaha
19:06:35 <Iceland_jack> haha
19:07:09 <Cale> (well, much more than 15 years ago now...)
19:07:10 <Iceland_jack> Cale: Kidding aside, my point wasn't to defend "return" but rather to say that the debate raged about what to name "return"
19:07:21 <Cale> Iceland_jack: Yeah, I'm aware :)
19:07:48 <Iceland_jack> just making sure :) I liked resurrecting it actually
19:08:05 <Iceland_jack> Maybe this should become a #haskell tradition, to argue about what to call "return" one day a year
19:08:25 <Iceland_jack> It's the journey, not the destination
19:09:05 <Cale> haha
19:09:07 <mgsloan> Indeed, sometimes the paint falls off the bikeshed and it needs to be repainted
19:09:38 <Cale> We could just call it η
19:09:40 <Iceland_jack> Oh, "Day of no Return"?
19:10:11 <scshunt> I suspect that it wouldn't be called return if they were starting from scratch
19:10:23 <scshunt> if only because it wouldn't even be a function in Monad, it would just use Applicative's
19:10:34 <scshunt> liftM would be fmap, etc.
19:10:40 <Cale> Well, when you look at all our examples of monads, I think the name makes good sense
19:10:45 <Iceland_jack> Oh actually
19:10:47 <Cale> liftM is still useful btw
19:10:50 <Iceland_jack> Why not liftA0
19:11:12 <Cale> For defining the required Functor instance, when you have the Monad instance written.
19:11:34 <Cale> (similarly with ap)
19:11:35 <Iceland_jack> Of course ideally we wouldn't have the 'A'
19:12:33 <Iceland_jack>     lift0 :: a                  -> A a
19:12:33 <Iceland_jack>     lift1 :: (a -> b)           -> (F a -> F b)
19:12:33 <Iceland_jack>     lift2 :: (a -> b -> c)      -> (A a -> A b -> A c)
19:12:33 <Iceland_jack>     lift3 :: (a -> b -> c -> d) -> (A a -> A b -> A c -> A d)
19:12:34 <Cale> The A helps distinguish it from all the infinitely many other things people use the word 'lift' for ;)
19:12:36 <Iceland_jack> going all in
19:13:20 <johnw> liftA0 is a touch brilliant
19:13:24 <Iceland_jack> I don't care about the rest of the world when I'm goofing off!
19:13:47 <scshunt> Cale: true. But I wouldn't have to use it anywhere else
19:15:44 <Iceland_jack> I do find the point about 'return' and 'yield' to be interesting though
19:20:35 <scshunt> Cale: it kind of surprises me that there's no compiler extension to allow a type class to default the implementation of its "parent" classes
19:20:47 <scshunt> especially in the Report, where the contexts are much more constrained
19:21:04 <Cale> scshunt: I think something like that is happening... and yeah, people have been proposing such things for a long time.
19:21:16 <scshunt> oh, superclass is the technical term
19:21:28 <Cale> The Report is *very* conservative about type class features
19:21:43 <scshunt> yeah
19:21:58 <scshunt> that's why it would be easier in the Report
19:22:21 <scshunt> when you have crap like IncoherentInstances it might be harder to sort out what superclass defaults actually mean.
19:22:35 <Iceland_jack> Yeah, type classes are a very interesting feature
19:23:22 <Cale> scshunt: Yeah, but it's not the Report's place to document things which don't exist :)
19:24:14 * hackagebot CC-delcont 0.2.1.0 - Delimited continuations and dynamically scoped variables  https://hackage.haskell.org/package/CC-delcont-0.2.1.0 (DanDoel)
19:24:30 <pyon-binatorial> Is there any way to get Haddock to generate documentation with qualified names?
19:24:45 <Heasummn> what does <$> mean?
19:24:48 <Iceland_jack> fmap
19:24:56 <Heasummn> fmap?
19:25:05 <Iceland_jack> @src <$>
19:25:05 <lambdabot> f <$> a = fmap f a
19:25:14 <Cale> :t (<$>)
19:25:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:25:19 <pyon-binatorial> Heasummn: In ghci: “:i Functor”.
19:25:19 <Heasummn> ah ok
19:25:29 <Heasummn> I saw it being used in some IO code, was unsure what it did
19:25:29 <Iceland_jack> > toUpper <$> "Hello, World!"
19:25:31 <lambdabot>  "HELLO, WORLD!"
19:25:34 <Cale> It does the most obvious thing it could do which has that type
19:25:37 <Iceland_jack> > map toUpper "Hello, World!"
19:25:39 <lambdabot>  "HELLO, WORLD!"
19:25:42 <hackrilege> hi! does anyone know a function which operates on Functor f => Free f a, which can be composed with itself n times to alter the nth internal f?
19:25:44 <mgsloan> Cale: Something like that is actually happening? Awesome!  I don't think superclass defaults makes very much sense, TBH.  It is too much complication for too little power
19:26:02 <mgsloan> "instante templates" adds a lot of extra power with perhaps just a little bit more complication
19:26:07 <Cale> mgsloan: I could have sworn I heard something about it for GHC 8, but maybe it's actually a little later? I dunno
19:27:03 <hackrilege> :t fmap . fmap
19:27:04 <Iceland_jack> Excuse me, how do those work?
19:27:04 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:27:18 <pyon-binatorial> Heasummn: If you do “io_action2 = fmap f io_action1”, then “io_action2” is an action which first runs “io_action1”, and then returns the result of applying “f” to “io_action1” 's result.
19:28:03 <mgsloan> Cale: Maybe you're thinking of UndecidableSuperclasses?  AFAIK nothing like superclass defaults exists.  I think someone wrote a new implementation + paper in the last couple years that tried to do this, but it wasn't received well
19:28:29 <Iceland_jack> I'm very excited about UndecidableSuperclasses
19:28:35 <mgsloan> I think https://ghc.haskell.org/trac/ghc/wiki/InstanceTemplates should be implemented
19:28:56 <pyon-binatorial> Anyway... I'm reading numeric-prelude's documentation, and it's madness! Every type is called T, and every type class is called C. I'd like to regenerate the documentation, using qualified names in type signatures. Is this possible?
19:29:42 <Iceland_jack> Oh right, that feature
19:29:43 <hackrilege> i think its; freeMap f (Recurse a) = (Recurse (fmap f a))
19:29:49 <hackrilege> does this have a name?
19:29:50 <Cale> pyon-binatorial: Not as far as I know. Henning Thielemann is just a Haskell terrorist.
19:29:56 <geekosaur> ah, Henning-skell
19:30:14 <mgsloan> Yup, cuz all your classes should be named C
19:30:15 <geekosaur> actually I thought there was an option to haddock to make it fully qualify things
19:30:36 <pyon-binatorial> Actually, using T and C would make sense in a language like OCaml, where modules can be abstracted over, passed around, and having predictable names for module members is a good thing.
19:30:42 <pyon-binatorial> But it doesn't make sense in Haskell!
19:30:58 <Cale> Yeah, I believe that's where it comes from
19:31:10 <geekosaur> look at the --qual option
19:31:24 <pyon-binatorial> Checking.
19:31:26 <geekosaur> default is none, alternatives are full, local, relative, aliased
19:31:27 <Cale> At some point we need a community project to go around and hand-rename all the types and classes in Henning's packages.
19:31:45 <hackrilege> which package?
19:31:53 <pyon-binatorial> numeric-prelude
19:32:07 <pyon-binatorial> geekosaur: Ah, nice, thanks!
19:32:17 <mgsloan> Or just release new packages that do similar things and use reasonable conventions
19:33:22 <mgsloan> IIRC the reasoning for the style was really the opinion that it was good to force the user to use qualified imports
19:34:25 <pyon-binatorial> I can empathize with that sentiment, but is it really worth making the Haddock-generated documentation significantly less usable? :-O
19:34:40 <hackrilege> i dont think its well defined what this package achieves, perhaps the bits most desired should be specified
19:35:07 <hackrilege> which parts should be in the prelude for example
19:35:22 <mgsloan> I actually don't empathize that much with the sentiment :)  I like imports with no explicit list.  Less locked down, sure, but more concise.  It's a tooling problem to tell you where something comes from
19:39:08 <pyon-binatorial> AFAICT, the first thing numeric-prelude achieves, and it's a very important one, is splitting some of the Prelude's classes (e.g., the additive part of Num is split into a separate type class) and removing superfluous superclasses (e.g., Num's counterpart doesn't have Eq and Show as base classes).
19:39:43 <geekosaur> neither does the real Prelude these days
19:40:27 <pyon-binatorial> Oh.
19:40:53 <pyon-binatorial> But splitting off (+), (-) and negate is still useful. :-p
19:41:17 <Iceland_jack> Hm, I may have an idea
19:42:14 <pyon-binatorial> What idea? :-O
19:42:57 <v937xjd> Hi 
19:43:08 <tommd> v937xjd: Welcome to #haskell
19:43:11 <Iceland_jack> I'm in my buffer fleshing it out :-) basically indexing the Num type class with some kind of hierarchy itself
19:43:17 <Iceland_jack> Welcome v937xjd 
19:43:41 <hackrilege> when i think of numbers, i dont think that its unreasonable to want to multiply and add them. if a user cannot provide an instance for both, does that not indicate they do not actually have a number?
19:44:00 <geekosaur> hackrilege, it has to do with number theoretical basis for numbers
19:44:10 <hackrilege> really?
19:44:19 <Iceland_jack> I personally haven't seen any convincing replacement of Num 
19:44:22 <geekosaur> it's a number if it has two monoids (addition and multiplication) with a certain relationship between them
19:44:24 <hackrilege> because according to the prelude a number should have just those instances
19:44:30 <hackrilege> a Num*
19:45:01 <hackrilege> oh, geekosaur, we are not disagreeing
19:45:02 <geekosaur> (formally, that's the definition of a "ring")
19:45:04 <Iceland_jack> Despite including things like 'abs' and 'signum'..
19:45:44 <geekosaur> well, typeclasses do have this bit about providing default ops with the ability to provide optimized versions for given instances
19:45:51 <v937xjd> Fiddling with raskell on my phone before going to sleep 
19:46:44 <geekosaur> ...gone
19:47:19 <pyon-binatorial> hackrilege: Let's say you want to use types for compile-time dimensional analysis. Then you don't want multiplication to have type “Num a => a -> a -> a”, but rather “Mul a b c => a -> b -> c”, where you have a “class Mul a b c | a b -> c”.
19:47:27 <geekosaur> they're gone
19:47:32 <pyon-binatorial> Ouch.
19:47:44 <geekosaur> (possibly only temporarily; they've been in and out a lot, I presume bad network somewhere)
19:52:29 <Iceland_jack> pyon-binatorial: "add" is an umbrella term over many different things though, for example adding a vector offset to a point
19:52:46 <Iceland_jack> Like in https://hackage.haskell.org/package/linear-1.20.4/docs/Linear-Affine.html
19:52:52 <pyon-binatorial> Indeed.
19:57:49 <hackrilege> i think (*) is pretty dead, there is only really one associative operation which is (+)
19:58:10 <hackrilege> (*) = foldr (+) 0
19:58:25 <hackrilege> oopps
20:00:29 <hackrilege> (*) = (foldr (+) 0).replicate
20:00:31 <hackrilege> anyway...
20:01:17 <geekosaur> well, the point is more that people want Num to be on a sound theoretical basis, so it should represent a ring rather than an ad hoc agglomeration of operations
20:01:24 <hackrilege> wouldnt a ring require two orthogonal operations?
20:02:07 <hackrilege> perhaps that is some other thing
20:02:13 <geekosaur> no, they're supposed to be related
20:02:56 * Iceland_jack . o O ( implementing Num as a single class indexed by its algebraic hierarchy )
20:03:19 <hackrilege> one is a Monoid (*) and the other has an inverse
20:03:58 <geekosaur> a ring has an abelian group (a monoid whose operator is commutative and which has an inverse), a second monoid whose operator may not necessarily be commutative or have an inverse, and the second monoid is distributive with respect to the first
20:04:15 <hackrilege> boom! awesome
20:04:39 <idev> in clojure, datomic and it's Entity-Attribute-Value store is all the rage.
20:04:41 <geekosaur> ...rings where the second monoid is commutative, as with integers, *are* a thing --- but rings themselves do not require this
20:04:46 <idev> Is there a way to do a typed Entity-Attribute-Value store in haskell ?
20:04:53 <idev> where the type of the Value depends on the *value*( of the Attribute
20:05:25 <Iceland_jack> so each layer subsumes the next..
20:06:07 <geekosaur> idev, you can do that with Data.Dynamic. it''s not a very popular thing in Haskell but it can be done
20:06:40 <hackrilege> looks like someone has tried to brute force a structure around Int with (+),(*). really this choice is arbitrary and it makes it look like a ring is not such an elemental structure.
20:07:05 <geekosaur> you mean the current Num? pretty much
20:07:10 <hackrilege> since its basically derived from Int with (+),(*) its not so informative to say that Int with (+),(*) is a Ring...
20:07:25 <hackrilege> no i mean Ring
20:07:28 <Iceland_jack> Is something like https://hackage.haskell.org/package/algebra the answer?
20:07:42 <Iceland_jack> I am sceptical
20:08:20 <geekosaur> hackrilege, you might want to study the theory behind this. (I am far from expert at it although I know the basics)
20:08:29 <hackrilege> i guess you think those also are not "elemental" enough
20:08:45 <hackrilege> i did Group theory at school
20:08:49 <shanemikel> is there a shorcut to import a library hiding all infix operators?
20:08:51 <geekosaur> Int is not elemental in number theory, no. Sets are
20:09:06 <hackrilege> by int i meant Z
20:10:52 <hackrilege> i never claimed Int was a elemental as Set is, i said Ring wasnt
20:11:04 <geekosaur> rings aren't elemental either
20:11:08 <geekosaur> I even told you what they're made of
20:11:18 <geekosaur> and those things aren't elemental either
20:11:27 <hackrilege> exactly, again we are not disagreeing
20:11:53 <hackrilege> monoids are pretty elemental, so are Abilien Groups
20:12:28 <geekosaur> ...numbers are not elemental because you can deduce rules about them and those rules point to relationships that you must either consider /ad hoc/, or search for a reason for them. searching for a reason for them brings you to lower level concepts, which take you to even lower level concepts...
20:13:09 <hackrilege> ideally we would like that the Prelude got these in canonical order
20:14:16 <hackrilege> and a good artist would know when to stop in deriving less simple constructions
20:14:47 <geekosaur> art is not about understanding
20:15:03 <hackrilege> we want a tractable Prelude
20:15:14 <geekosaur> if you're trying to understand *why* numbers are, you keep going until you find out, not stop when you feel aesthetically satisfied
20:15:45 <geekosaur> but the current one isn't really. Num, as it currently exists, is a hack to try to make numbers behave the way non-Haskellers expect them to
20:15:46 <hackrilege> right, so we need Ring at least...
20:16:16 <geekosaur> and it fails often enough to make one suspect that was a mistake
20:16:19 <hackrilege> the main criticism of Num is that non-Haskelers try and use it like Monoid
20:16:42 <hackrilege> which isnt Nums fault
20:17:18 <geekosaur> wat
20:17:34 <hackrilege> it fails to behave as non-Haskelers would expect it too...
20:17:44 <geekosaur> yes, I said that
20:17:48 <Iceland_jack> Do you mean 
20:17:48 <Iceland_jack>     "hello" + " " + "world"
20:17:48 <hackrilege> "the programmer is currently forced to define a method for '(*)' when she defines a method for '(+)'."
20:18:30 <hackrilege> eg trying to make vectors Num
20:18:47 <hackrilege> and using (*) cross product or something
20:19:25 <hackrilege> which i guess is just bad Group theory...
20:20:07 <hackrilege> "but i want them to add up with the '+' symbol like in matlab"
20:23:09 <hackrilege> by making this interface Num for noobs, all kind of problems arise from this approach which wouldnt if better habits were established. having Num in the prelude almost indicates that its "correct", while really Ring should be used, and in some uses, something less complex
20:24:13 <hackrilege> personally i think things like return and pure should be a single class, so as i should never have to write return = pure
20:24:40 <Iceland_jack> hackrilege: Also keep in mind that the tower is already quite complicated, even with the current Num:
20:24:40 <Iceland_jack>     RealFrac, Real, Fractional, RealFloat, Floating, ... 
20:25:09 <hackrilege> by this logic Num should have only methods derived from Superclasses...
20:25:31 <benzrf> thats something ppl do sometimes
20:25:48 <Iceland_jack> It complicates a reasonable transition
20:27:12 <hackrilege> i see it as a severe limitation of the language that while a class can have default methods, it cannot instantiate methods of a superclass.
20:27:51 <Iceland_jack> Yes, this is the icky underbelly of Haskell
20:28:52 <zRecursive> There is no inheritance in haskell classes, isnot there ?
20:29:00 <hackrilege> i should be able to separate out mutual definitions over two classes and have an instance of one automatically derive the other
20:29:54 <Iceland_jack> What happens if a method is determined by two separate classes
20:30:13 <Iceland_jack>     fmap = liftA
20:30:13 <Iceland_jack> vs
20:30:13 <Iceland_jack>     fmap = fmapDefault
20:30:46 <hackrilege> they are different?
20:30:57 <hackrilege> pretty sure there is only one fmap, some laws
20:31:19 <Iceland_jack> They are the same, but you need to make a choice
20:31:29 <hackrilege> no, they are the same!
20:31:45 <Iceland_jack> Operationally :) you have to make a choice
20:32:05 <hackrilege> i guess i was talking about an extended version of the language where you didnt
20:33:11 <hackrilege> i think the argument is that you could make a faster instance or something, but anyway my code is far too long with a load of useless superfluous Alternative instances
20:33:29 <hackrilege> its embarrassing to present...
20:33:56 <Iceland_jack> I'm not in disagreement that it's a problem, but most proposed solutions never quite convince me
20:34:14 <hackrilege> the prof is all like "whats this Alternative" and i say, "oh some redundant artifact of the language" and he kind of pulls a disgusted face
20:34:57 <hackrilege> my proposition at least is to make a class out of extract, and another class out of return.
20:35:23 <hackrilege> one for associative binary opperators
20:35:31 <Iceland_jack> Yeah Pointed
20:36:00 <hackrilege> and then im tempted to say all essential classes should have only one function and have only essential classes as superclasses
20:36:24 <hackrilege> and then you lose mutual definitions across classes
20:36:53 <geekosaur> if you want to be disgusted with something, it's not Alternative, it's Foldable >.>
20:37:13 <geekosaur> I mean, operationally it's useful, but there's no theory backing it
20:37:21 <dolio> Yes there is.
20:37:35 <hackrilege> i like Foldable
20:37:59 <dolio> It's all about monoidal folding and free monoids.
20:38:15 <Iceland_jack> I would hate to have 
20:38:15 <Iceland_jack>     pure f <*> xs <*> ys
20:38:15 <Iceland_jack> have leftover constraints (Pointed f, Applicative f) 
20:38:17 <geekosaur> let me rephrase. there is no theory that gives you half the prelude being methods of Foldable >.>
20:38:24 <dolio> And then you can write slow versions of all kinds of stuff with that, and people instead want fast versions.
20:38:46 <hackrilege> it means that if all the elements of the container belong to a group the container has some intrinsic linearity allowing for composition
20:39:08 <hackrilege> :t mconcat
20:39:09 <lambdabot> Monoid a => [a] -> a
20:39:13 <hackrilege> ok, thats fold
20:39:37 <hackrilege> and half the things in the Prelude can be put in lists
20:40:00 <hackrilege> lol, i hope you see what i mean
20:41:01 <hackrilege> Iceland_jack, Applicative would wrap up the Pointed
20:41:20 <hackrilege> you would have class Pointed => Applicative where; <*> :: ...
20:41:55 <Iceland_jack> I'm aware
20:42:26 <hackrilege> oh yeah i see sorry, use of pure a implies Pointed a
20:42:27 <Tendies> lpaste.net/162990 sorry about the indentation, but what is the proper way to do what i'm trying to do? I
20:42:51 <hackrilege> nonono scratch that
20:42:55 <hackrilege> it hides it
20:42:56 <Tendies> am getting a parse error and haven't found a way to do this right with lambdas, do, or where notation
20:43:06 <geekosaur> Tendies, there's some oddness with negative constants
20:43:12 <geekosaur> you have to say (-1) not just -1
20:43:19 <geekosaur> and (-2) etc.
20:43:27 <Tendies> oh okay ill fix that
20:43:30 <Iceland_jack> hackrilege: Apart from that, migration: https://mail.haskell.org/pipermail/libraries/2013-August/020667.html
20:43:34 <Tendies> but the parse error is on the guards
20:43:53 <geekosaur> guards don;t go after where
20:43:53 <hackrilege> sometimes i had to write 0-1...
20:44:17 <geekosaur> in fact that looks kinda backwards to me?
20:44:27 <Tendies> i know the syntax is completely wrong
20:44:43 <Tendies> i want to know how i should carry out that logic in a way that will compile
20:45:16 <hackrilege> aha, well if you could derive a Pointed instance from an Applicative instance there would be no problem with migration....
20:45:18 <geekosaur> func (Interval a b) | a < 0 = Interval (-2) (-1) | a == 0 = Interval (-2) 0 | a > 0 = Interval (-2) 1
20:45:36 <geekosaur> (-> would be correct in place of = if this were a case expression)
20:46:04 <Iceland_jack> I'm lukewarm to the benefits that's all
20:46:16 <Tendies> oh derp :D
20:46:21 <Tendies> thanks geekosaur 
20:46:40 <hackrilege> without it this canonical class structure is impossible for reasons of migration
20:47:01 <Axman6> geekosaur: Interval (-2) (signum a)
20:47:28 <geekosaur> yep, but I was demonstrating the guard syntax
20:47:33 <geekosaur> which was the question
20:47:42 <Axman6> ah, should've read back further =)
20:47:47 <geekosaur> the fatc that the guard isn't actually needed is a different issue
20:49:47 <hackrilege> never mind your inthermerance, overcoming that hurdle is my absolute desire, i would do it if i could
20:51:23 <hackrilege> i guess at some point i need to write a haskell interpreter
20:51:44 <hackrilege> bit daunted by the language extensions
20:52:21 <Iceland_jack> It's a good exercise to build one with as few extensions as you can
20:52:37 <hackrilege> are there any good walkthroughs?
20:53:25 <hackrilege> i guess the main hurdle to making a useful compiler is supporting all the packages
20:53:42 <hackrilege> plenty of language extensions
21:14:19 * hackagebot turingMachine 0.1.1.2 - An implementation of Turing Machine and Automaton  https://hackage.haskell.org/package/turingMachine-0.1.1.2 (sanjorgek)
21:25:54 <idev> I sort of understanding Continuations. I sort of undersand LogicT. I have no idea why we have newtype LogicT m a = LogicT { unLogicT :: forall r. (a -> m r -> m r) -> m r -> m r .
21:26:00 <idev> WTF is going on with that typeclass?
21:26:04 <idev> err, that newtype
21:39:20 * hackagebot turingMachine 0.1.2.0 - An implementation of Turing Machine and Automaton  https://hackage.haskell.org/package/turingMachine-0.1.2.0 (sanjorgek)
21:44:20 * hackagebot network-conduit-tls 1.2.2 - Create TLS-aware network code with conduits  https://hackage.haskell.org/package/network-conduit-tls-1.2.2 (MichaelSnoyman)
21:44:22 * hackagebot basic-prelude 0.5.2 - An enhanced core prelude; a common foundation for alternate preludes.  https://hackage.haskell.org/package/basic-prelude-0.5.2 (MichaelSnoyman)
21:49:20 * hackagebot streaming-commons 0.1.15.5 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.15.5 (MichaelSnoyman)
21:49:22 * hackagebot wai-handler-launch 3.0.2 - Launch a web app in the default browser.  https://hackage.haskell.org/package/wai-handler-launch-3.0.2 (MichaelSnoyman)
21:54:20 * hackagebot turingMachine 0.1.3.0 - An implementation of Turing Machine and Automaton  https://hackage.haskell.org/package/turingMachine-0.1.3.0 (sanjorgek)
22:10:03 <kahoot> hi guys, is there a definitive solution where I can AND all elements on the list ? Example [True, False, True] = False, [True, True, True] = True
22:10:21 <scshunt> yes
22:10:24 <scshunt> and
22:10:32 <scshunt> :t and
22:10:33 <lambdabot> Foldable t => t Bool -> Bool
22:11:13 <kahoot> damn, im such an idiot
22:11:20 <kahoot> thanks bud
22:19:25 <pavonia> @src and
22:19:25 <lambdabot> and = foldr (&&) True
22:20:17 <shanemikel> can you guess the implementation of or?
22:33:46 <zRecursive> can we see the magic of `seq` ?
22:34:22 * hackagebot uncertain 0.3.0.0 - Manipulating numbers with inherent experimental/measurement uncertainty  https://hackage.haskell.org/package/uncertain-0.3.0.0 (jle)
22:34:37 <zRecursive> @src foldl'
22:34:37 <lambdabot> foldl' f a []     = a
22:34:37 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:34:46 <kadoban> zRecursive: Don't believe so, it should be an internal thing in the compiler.
22:35:44 <zRecursive> kadoban: then can we look at the internal thing ?
22:36:06 <kadoban> zRecursive: I'm sure there's code for it somewhere in GHC, I wouldn't know where personally.
22:36:30 <zRecursive> or by -dump option ?
22:39:16 <zRecursive> ghc.exe -C Foo.hs ?
22:50:45 <jle`> seq isn't really implementable in haskell, you can think of it as a part of the API ghc offers for its runtime system
22:57:48 <zRecursive> jle`: thanks! BTW, `ghc.exe -C -H16m Test.hs` => ghc.exe: cannot compile this file to desired target: Test.hs  ?
22:58:19 <zRecursive> I just want to see its C codes.
22:59:19 <zRecursive> Test.hs is a simple module which  has a foldl' call.
23:00:35 <shanemikel> what does C have to do with it?
23:02:05 <zRecursive> not sure
23:04:32 <Axman6> zRecursive: what are you trying to do?
23:04:59 <zRecursive> seq
23:05:39 <zRecursive> @src sequence
23:05:39 <lambdabot> sequence []     = return []
23:05:39 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:05:39 <lambdabot> --OR
23:05:39 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:05:49 <zRecursive> i know seq is NOT sequence
23:08:57 <zRecursive> so just curious about seq's implementation
23:10:20 <shanemikel> zRecursive: I can't find it by grepping the ghc repo
23:10:27 <shanemikel> at least, the .hs files
23:10:51 <zRecursive> shanemikel: seems hard to find it
23:11:24 <zRecursive> it is GHC's magic
23:13:30 <shanemikel> but it's used all over the place, seems important to the implementation of GHC itself, so I betcha it's lower level
23:13:40 <jle`> zRecursive: it's 'magic' in the same way that parsing identifiers is magic
23:13:48 <jle`> it's just a part of the compiler :P
23:14:02 <shanemikel> you mean parsing identifiers isn't magic?
23:16:24 <jle`> seq would be implemented on the same level that ghc implements its run-time system, so things like laziness, its concurrency system, etc.
23:16:26 <zRecursive> Once ghc sees `seq`, what will it do ?  i donot see why it is the same as "parsing identifiers" ?
23:16:58 <shanemikel> jle` do you know where the runtime code is in the repo? what subdir?
23:17:07 <tasslehoff> I use -Wall. Can I turn off the warning about redundant module imports somehow?
23:18:05 <jle`> i don't :|
23:18:57 <jle`> zRecursive: yeah, a question like that is like asking what ghc does when it sees `take 10 [1..]` ; it allocations thunks, finds out what needs to be evaluated, implements thunk cacheing, etc.
23:19:02 <jle`> for lazy evaluation to work
23:20:42 <zRecursive> i see. i am just curious how `seq` ensures the sequence ?
23:20:47 <ahihi> when GHC sees x `seq` y, it generates code to force x to WHNF and return y
23:20:48 <ahihi> :P
23:21:56 <zRecursive> "force x to WHNF", good to know it.
23:22:20 <shanemikel> the wiki page mentions that doesn't always happen, and that it's only guaranteed to mean '_|_ `seq` b = b' and 'a `seq` b = b'
23:22:31 <shanemikel> err
23:22:50 <shanemikel> obviously it doesn't mean that :)
23:22:54 <jle`> yeah, 'seq' doesn't really have anything to do with sequencing anything
23:23:14 <jle`> (if that was the question)
23:23:15 <ahihi> _|_ `seq` b = b sounds like a bad time
23:23:30 <shanemikel> _|_ `seq` b = _|_
23:24:02 <jle`> seq doesn't make any guaruntees on ordering.  but the semantics follow ^^
23:24:03 <zRecursive> weird
23:24:27 <shanemikel> yeah, seems reasonable
23:24:35 <deepfire> is there something like:  Monad m => Maybe a -> m (Maybe a) -> m (Maybe a)
23:25:14 <shanemikel> seq doesn't recursively evaluate, right?
23:25:20 <deepfire> i.e. monadic Alternative for Maybe
23:25:54 <shanemikel> flip const
23:28:07 <zRecursive> then why do ghc need `seq` if it doesnot guaratee the Ordering ?
23:28:43 <zRecursive> just for semantics ?
23:29:29 * hackagebot failure-detector 0 - Failure Detectors implimented in Haskell.  https://hackage.haskell.org/package/failure-detector-0 (davean)
23:29:41 <ahihi> the wiki page really puts it quite well https://wiki.haskell.org/Seq
23:29:57 <shanemikel> what jle` implied, is that in order to guarantee _|_ `seq` b = _|_ and a `seq` b = b, you need to evaluate the first argument 
23:30:29 <jle`> deepfire: can you show an implementation?
23:30:36 <jle`> deepfire: it's tricky to see what you want
23:31:13 <jle`> zRecursive: ghc doesn't need seq, it offers it as an API to people who write haskell code
23:31:25 <jle`> so we can use it to control evaluation in the RTS
23:31:45 <zRecursive> yeah
23:31:49 <shanemikel> jle` I saw a lot of use of seq glancing through the code just now
23:31:52 <jle`> but if it didn't offer it, it'd still work
23:32:04 <deepfire> jle`:  alterMon maybex action = case maybex of { Nothing -> action; Just x -> pure x }
23:32:36 <shanemikel> but that was the compiler part
23:32:47 <jle`> maybe action pure ?
23:33:58 <deepfire> jle`: the thing is, action :: Monad m => m (Maybe a)
23:34:26 <deepfire> jle`: i.e. either yield the Just-value, or run the action
23:35:20 <shanemikel> deepfire lift?
23:35:39 <deepfire> shanemikel: lift what? how?
23:35:44 <deepfire> shanemikel: sorry, I'm obtuse
23:36:29 <deepfire> alterMon :: Monad m => Maybe a -> m (Maybe a) -> m (Maybe a)
23:36:40 <shanemikel> sorry, it looks like you might be able to use monad transformers
23:36:42 <jle`> there is an Alternative for m . Maybe
23:36:50 <jle`> but it requires a newtype wrapper
23:36:56 <jle`> it might not be worth the trouble for something one-off like this
23:37:25 <deepfire> it's chaining of possibly-successful actions
23:37:35 <jle`> there's a newtype wrapper over `m (Maybe a)` that gives it a proper Alternative instance
23:37:41 <jle`> so you can use <|> to get what you want
23:37:57 <jle`> but for small cases like this it's probably easier to just pattern match or use 'maybe'
23:37:57 <deepfire> jle`: I see, thank you!
23:38:22 <jle`> it'd be x <|> y, basically
23:38:29 <deepfire> yes, I see..
23:38:30 <jle`> except with x and y wrapped in the newtype wrapper
23:38:35 <deepfire> thank you again!
23:38:46 <jle`> np!
23:38:57 <jle`> the wrapper is commonly offered as MaybeT in the transformers library
23:39:40 <jle`> for one-offs like this it isn't worth the effort, but if you want to manipulate a lot of them, or use Alternative-polymorphic methods like 'asum', it'd be useful
23:40:17 <jle`> that's sort of the thing about the newtype-wrappers-to-give-new-instances idiom in genera
23:40:19 <jle`> l
