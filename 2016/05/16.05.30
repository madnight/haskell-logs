00:03:28 * hackagebot compactmap 0.1.4.1 - A read-only memory-efficient key-value store.  https://hackage.haskell.org/package/compactmap-0.1.4.1 (SimonMarechal)
00:42:03 <jle`> ~>
01:22:10 <shourya> Does anyone here have the anon ops channel?
01:22:49 <sshine> I'm not sure what channel that is.
01:25:19 <shourya> Oops texted on the wrong channel. Sorry sshine
01:25:47 <sshine> no worries!
01:28:31 * hackagebot language-javascript 0.6.0.5 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.5 (ErikDeCastroLopo)
01:41:11 <fr33domlover> dcoutts, ping. Remember there was a patch to make Hackage count NEWS and NEWS.md as a change log too, with higher priority than ChangeLog{.md} ? Did that get committed / deployed?
01:53:31 * hackagebot hw-prim 0.0.3.1 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.3.1 (haskellworks)
02:08:32 * hackagebot opaleye 0.5.0.0 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.5.0.0 (tomjaguarpaw)
02:14:41 <fProgrammer_> <pasting it from haskell-beginners channel> quick question: I am working on a proof of concept(poc) project where i m supposed to maintain state(and other data) of a user connected to my haskell server.. Looking for an in memory database which has good support for haskell. I have used aerospike before and it doesnt seem to support haskell at the moment. Ideas?
02:15:55 <netsu> Hello. Seems like 'hoogle' broken a little. E.g. it can't find 'toListOf' or 'traversed'. And 'hayoo' not so powerful: it not so smart in searching by data types. Surely, I can search in stackage on stack website. But, for first, it online-only, and would be nice to have tool on local machine, and also, it search on stackage only, and not all packages from hackage on stackage yet. Could you suggest any usable options/alternatives for
02:16:28 <nkaretnikov`> where can i read about injective typeclasses (not type families)?  it was in ghc 8.0.1 release notes, but i cannot find anything in the manual
02:17:16 <nkaretnikov`> alternatively, if someone could tell me why the following fails to typecheck, that'd be great: class C (T a) where ...
02:17:34 <shachaf> It's not broken, it's just not searching every package.
02:17:55 <shachaf> You can ask it to search lens with "+lens ..."
02:18:10 <nkaretnikov`> the typechecker complains about T and probably just wants only a, but i thought it's supported, no?
02:18:59 <shachaf> I don't see anything about injective type classes in https://ghc.haskell.org/trac/ghc/blog/ghc-8.0.1-released
02:19:01 <sshine> fProgrammer_, in-memory database for haskell; you could try AcidState?
02:19:35 <nkaretnikov`> shachaf: https://mail.haskell.org/pipermail/ghc-devs/2016-January/010966.html
02:19:36 <fr33domlover> fProgrammer_, depends on your needs I suppose. You can use SQLite in in-memory mode, or Redis (which is iirc in memory + periodic writes to disk)
02:19:57 <nkaretnikov`> shachaf: a typo?
02:20:03 <sshine> yeah, SQLite is probably the only other thing I can think of that's in-memory and is supported outside of Haskell.
02:20:25 <shachaf> nkaretnikov`: Maybe. I don't know much about GHC 8. Any reason you're expecting that particular syntax to do it?
02:20:32 <fr33domlover> fProgrammer_, also check out the serversession package, I didn't use it but it may be relevant
02:20:35 <sshine> it's probably not a bad choice if you should want to migrate to real DBMS support.
02:21:33 <shachaf> https://mail.haskell.org/pipermail/ghc-devs/2016-May/012098.html doesn't mention anything about it
02:21:43 <nkaretnikov`> shachaf: no reason. i'm just trying to model python classes as close as possible, and that looked like a natural way of doing it: class RecVal a => C (Rec a) where init :: Rec a -> [a] -> Rec a -> Rec a
02:21:51 <nkaretnikov`> well, for my particular usecase
02:22:11 <nkaretnikov`> where Rec is type Rec = Map String
02:22:48 <shachaf> I don't know why that models Python classes, but maybe you can use (RecVal a, b ~ Rec a) => C b where ... or something.
02:23:39 <fProgrammer_> fr33domlover: can you comment on use of it? good support for haskell bindings? 
02:23:41 <nkaretnikov`> shachaf: okay, how would you express class Foo(object): def __init__(self): self.foo = "foo"?
02:23:52 <fProgrammer_> ease of use*?
02:23:56 <fr33domlover> fProgrammer_, SQLite and Redis have Haskell packages
02:24:07 <fr33domlover> actually, several for each :P
02:24:35 <EvanR> nkaretnikov`: specifically, the 7 layers of mixed up ideas?
02:24:42 <fr33domlover> fProgrammer_, for a POC you can just use StateT, you know...
02:24:53 <fr33domlover> with a simple HashMap UserID UserState
02:24:57 <fr33domlover> etc.
02:25:02 <nkaretnikov`> EvanR: huh?
02:25:16 <shachaf> nkaretnikov`: I didn't mean that your thing was wrong, just that I giving a black box answer without figuring it out.
02:25:22 <netsu> Hello. Seems like 'hoogle' broken a little. E.g. it can't find 'toListOf' or 'traversed'. And 'hayoo' not so powerful: it not so smart in searching by data types. Surely, I can search in stackage on stack website. But, for first, it online-only, and would be nice to have tool on local machine, and also, it search on stackage only, and not all packages from hackage on stackage yet. Could you suggest any usable options/alternatives for
02:25:26 <netsu> Example: https://www.haskell.org/hoogle/?hoogle=toListOf
02:25:30 <fProgrammer_> fr33domlover: awesome, lemme search. I was wondering how solutions like curryDB and HiDB etc work.. curryDB hasn't been updated for couple of yrs
02:25:30 <shachaf> netsu: I already answered your question above.
02:25:32 <nkaretnikov`> shachaf: ah, okay
02:26:03 <shachaf> nkaretnikov`: But isn't __init__ just a regular method?
02:26:13 <Axman6> fProgrammer_: that's not going to work concurrently
02:26:33 <netsu> shachaf: oh, thank you, missed it!
02:26:37 <EvanR> its implicitly executed at some time during construction
02:26:54 <Axman6> ReaderT (IORef (HashMap UserID UserState)) might be more appropriate
02:27:41 <fProgrammer_> Axman6: Thing is, I want a record to have TTL etc. which aerospike supports, not sure about redis 
02:27:56 <nkaretnikov`> shachaf: yes, but i want to override it later, the only way of having this sort of behavoir is typeclasses, right? well, there're mutable variables, too, but that's even further away, imo
02:28:30 <EvanR> nkaretnikov`: you can use records of functions as objects, the record type is the interface. record syntax lets you "override" fields
02:28:32 <Axman6> fProgrammer_: what do you mean be TTL?
02:28:45 <Axman6> by*
02:29:04 <nkaretnikov`> shachaf: damn, i can use b ~ Rec a because i want to refer to a in the init signature, which is impossible with b. any other ideas?
02:29:16 <fProgrammer_> Axman6: TTL as in Time to live. The record will automatically be deleted after ttl of record 
02:29:24 <nkaretnikov`> EvanR: but records are not extensible, no?
02:29:35 <nkaretnikov`> EvanR: open world assumption or whatever it's called
02:29:40 <EvanR> no, and thats not the only limitation
02:29:51 <nkaretnikov`> EvanR: not sure i follow, plz elaborate
02:29:54 <EvanR> you might want to read oleg's paper on Haskell OOP
02:30:03 <nkaretnikov`> oh no :)
02:30:05 <fr33domlover> fProgrammer_, run a background thread that goes over the DB and deletes entries once in a while? :P
02:30:31 <nkaretnikov`> EvanR: when you said oop, i also thought of lens...
02:30:39 <EvanR> eh?
02:30:46 <fProgrammer_> fr33domlover: I am very lazy :P 
02:30:58 <nkaretnikov`> EvanR: it supports imperative behavoir, which is kind of related
02:31:01 <fr33domlover> fProgrammer_, ah then it's simple, don't write that POC
02:31:06 <nkaretnikov`> but anyway, going to read oleg's stuff, thx
02:31:09 <EvanR> were all over the place now
02:31:24 <EvanR> what lens is imperative behavior?
02:31:31 <Axman6> fProgrammer_: right, just have a thread running forever (getCurrentTime >>= \now -> atomicModifyIORef (\hmap -> (HashMap.filter (pastTTL now) hmap,()) >> threadDelay (seconds 1))
02:31:55 <nkaretnikov`> EvanR: nevermind, i was just referring to the fact that it allows to program in an imperative style, sort of
02:32:08 <EvanR> er...
02:32:19 <nkaretnikov`> EvanR: and that dot thing, which looks like a method call
02:32:41 <EvanR> the ordering of functions in a composition isnt really that paradigm shifty
02:33:24 <fProgrammer_> fr33domlover: lol! what I meant was, it'll be nice if there's an existing solution.. I can always write the code. If I write my own code, I will have to ensure I delete it from all database nodes and ensure consistency. Anyway thanks!
02:33:50 <EvanR> we can take this as an example of the meaning of imperative to be disintegrating
02:33:59 <nkaretnikov`> EvanR: is it the work you were referring to: https://arxiv.org/pdf/cs/0509027.pdf?
02:33:59 <EvanR> along with all other terminology!
02:34:16 <EvanR> right
02:34:29 <nkaretnikov`> k, thanks. i wasn't aware of that.
02:34:32 * nkaretnikov` goes to read
02:35:42 <netsu> shachaf: is there any option to search all the hackage?
02:37:42 <netsu> shachaf: or it's better to direct this question to hoogle's author in mail?
02:37:53 <shachaf> I don't know.
02:38:00 <shachaf> You can run your own Hoogle locally.
02:38:12 <netsu> thanks anyway.
02:40:50 <Phantom_Hoover> when is someone going to fix the syntax highlighting on the wiki to properly handle single quotes
02:42:03 <Axman6> iirc the wiki is mediawiki, so probably never
02:43:19 <Phantom_Hoover> Axman6, ...what, because nobody wants to touch mediawiki internals?
02:43:35 * hackagebot compdata 0.10.1 - Compositional Data Types  https://hackage.haskell.org/package/compdata-0.10.1 (PatrickBahr)
02:44:02 <merijn> Phantom_Hoover: And because people are working on things they think are more important
02:48:35 * hackagebot ClustalParser 1.1.4 - Libary for parsing Clustal tools output  https://hackage.haskell.org/package/ClustalParser-1.1.4 (FlorianEggenhofer)
02:49:10 <Axman6> Phantom_Hoover: PHP, need I say more?
02:50:56 <Phantom_Hoover> well it seems like wikibooks have a working highlighter: https://en.wikibooks.org/wiki/Haskell/Foldable#The_Foldable_class
02:52:13 <Phantom_Hoover> though i can believe that nobody really wants to bother stealing it
03:05:18 <quchen> How would I create a Haddock hyperlink to foldl'? I tried 'foldl'', 'foldl\', 'foldl' ', but none of them worked.
03:06:57 <EvanR> $'s in some way maybe
03:13:36 * hackagebot cgrep 6.6.9 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.9 (NicolaBonelli)
03:17:09 <quchen> EvanR: Thanks. Turns out it's an embarassing oversight on my side: foldl' wasn't in scope, so fully qualifying the name solved the problem.
03:17:19 <quchen> 'Data.Fodable.foldl''
03:17:47 <quchen> (Can I import a module in Haddock somehow so that I don't have to qualify the name?)
03:18:18 <ggVGc> I never know when to use foldr
03:18:25 <ggVGc> I don't think I can come up with a scenario
03:18:34 <ggVGc> and I'm not sure when I'd want a lazy fold either
03:18:36 * hackagebot ideas 1.5 - Feedback services for intelligent tutoring systems  https://hackage.haskell.org/package/ideas-1.5 (BastiaanHeeren)
03:18:46 <ggVGc> so I always just use fodl'
03:19:43 <pikajude> hey, can i make an IO action that prints to stdout print to stderr instead?
03:21:18 <maerwald> :t stderr
03:21:20 <lambdabot> Not in scope: ‘stderr’
03:22:10 <dcoutts_> fr33domlover: it didn't thanks for reminding me. Are you sure it should be higher priority than changelog?
03:22:33 <maerwald> :t hPutStrLn
03:22:34 <lambdabot>     Not in scope: ‘hPutStrLn’
03:22:35 <lambdabot>     Perhaps you meant one of these:
03:22:35 <lambdabot>       ‘BS.hPutStrLn’ (imported from Data.ByteString),
03:22:37 <pikajude> reason being, I am reading IO actions from a Chan because I'm using ansi-terminal
03:22:49 <maerwald> pikajude: hPutStrLn stderr "goo" -- should work
03:22:53 <pikajude> and those IO actions contain lots of setSGR, putStr, etc.
03:22:56 <maerwald> stderr is a handle
03:23:13 <pikajude> i don't want to have to go into each of my logging invocations and manually change it to hPutStr stderr instead
03:23:16 <pikajude> but I may have to
03:24:00 <fr33domlover> dcoutts_, no bit let's think about it: If you have both NEWS and ChangeLog, most likely ChangeLog is a detailed log of every change, which is what people usually do with `git log` these days, and NEWS is for human visible stuff. I have both but my ChangeLog simply says "See git log" and is there just because of the convention. So in my case, I'd want NEWS.md to be shown on hackage etc
03:24:08 <fr33domlover> s/bit/but
03:24:37 <dcoutts_> fr33domlover: right, I'm just checking up on the gnu convention and it's exactly that.
03:24:49 <fr33domlover> dcoutts_, yep :P
03:24:56 <fr33domlover> that's why I do it like that
03:26:27 <dcoutts_> fr33domlover: thanks
03:27:14 <fr33domlover> dcoutts_, /I/ should be thanking /you/ :P
03:28:53 <pikajude> alternatively, can I redirect a Handle but only in a thread?
03:37:55 <Xandaros> Is there an ‘easy’ way to prepend a monad value to a monadic list? (Something like: Monad m => m a -> m [a] -> m [a])
03:38:14 <lyxia> liftM2 (:)
03:38:37 * hackagebot JuicyPixels 3.2.7.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.7.1 (VincentBerthoux)
03:39:00 <Xandaros> lyxia: Thank you! (Though I'll replace that M with an A :P)
03:39:27 <Xandaros> I always forget about liftA*
03:40:50 <lyxia> yeah :D that was just so that I got the exact same signature
03:41:14 <hexagoxel> :exf "Monad m => m a -> m [a] -> m [a]" -n "3"
03:41:16 <exferenceBot> \ a b -> a >>= (\ f -> fmap ((:) f) b)
03:41:16 <exferenceBot> \ a b -> b >>= (\ fs -> fmap (\ j -> j : fs) a)
03:41:16 <exferenceBot> liftA2 (:)
03:42:53 <YellowOnion> OK, could someone give me access to the ghc trac?
03:43:15 <YellowOnion> Spam detection is over zealous...won't let me sign up :(
03:43:34 <shachaf> Probably ask in #ghc.
03:43:54 <YellowOnion> shachaf, thanks
03:45:46 <bernalex> YellowOnion: there's a thread on the ml about it. seems more than you are being hit. talk to bgamari in #ghc.
04:03:39 * hackagebot FontyFruity 0.5.3.2 - A true type file format loader  https://hackage.haskell.org/package/FontyFruity-0.5.3.2 (VincentBerthoux)
04:13:39 * hackagebot time-out 0.2 - Timers, timeouts, alarms, monadic wrappers  https://hackage.haskell.org/package/time-out-0.2 (akrasner)
04:18:39 * hackagebot monad-hash 0.1.0.2 - Monad transformer for incremental hashing  https://hackage.haskell.org/package/monad-hash-0.1.0.2 (akrasner)
04:28:23 <Guest27032> is there a function that returns all segements of list? it would be similiar to subsequences
04:29:14 <maerwald> anyone using multi-ghc-travis? It seems it doesn't support cabal-1.24, despite the docs claiming that
04:31:10 <cocreature> > inits =<< tails [1,2,3]
04:31:11 <dsm> > permutations [1,2,3]
04:31:14 <lambdabot>  [[],[1],[1,2],[1,2,3],[],[2],[2,3],[],[3],[]]
04:31:14 <lambdabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
04:31:27 <cocreature> you can easily filter out the empty lists
04:32:10 <Guest27032> I found a stack overflow answert with "continuousSubSeqs = filter (not . null) . concatMap inits . tails
04:32:25 <Guest27032> but i like the "inits =<< tails"
04:32:30 <EvilMachine> Hello. Does anyone have an example of how to actually pattern-match on Data.Typeable.(:~:) to get out Refl?
04:33:12 <cocreature> Guest27032: =<< is concatMap when specialized to lists
04:35:42 <Guest27032> cool, thx. I already thought that it was a very small function and there not in 'Data.List' 
04:35:52 <Guest27032> *therefore
04:48:40 * hackagebot VKHS 1.6.4 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-1.6.4 (SergeyMironov)
05:23:41 * hackagebot compdata-param 0.9.1 - Parametric Compositional Data Types  https://hackage.haskell.org/package/compdata-param-0.9.1 (PatrickBahr)
05:25:25 <bernalex> who's "in charge" of #haskell, and know a bit about the related IRC chans?
05:28:00 <demize> bernalex: `/msg ChanServ ACCESS #haskell LIST` to get a list of ops.
05:28:24 <bernalex> demize: afaik some of the ops are just ops. i.e. they're just around to kickban annoying people.
05:28:36 <demize> The person with F in flags is the founder, which "owns" the channel.
05:33:41 <erisco> what would you pay for an IDE/editor plugin that gave you better Haskell support? and what is your IDE/editor of choice?
05:35:23 <bernalex> erisco: €0. emacs.
05:35:46 <bernalex> I might contribute patches though.
05:35:58 <erisco> bernalex, do you find the Haskell support in emacs sufficient?
05:36:22 <bernalex> I don't think that it's possible to have sufficient support. there's always things that could be done to improve.
05:36:44 <erisco> by "sufficient" I mean "adequate"
05:36:46 <bernalex> also, I started using emacs just recently, so I have no clue what I'm doing. I'm probably missing some things.
05:37:01 <fr33domlover> Is there a way in Persistent to get just the key for a Unique? Something like getKeyBy :: Unique record -> m (Maybe (Key record))
05:37:15 <bernalex> I don't think adequate is attainable.
05:37:30 <fr33domlover> (I use 'getBy' a lot, but in many cases I need just the key)
05:38:42 * hackagebot pipes-text 0.0.2.2 - properly streaming text  https://hackage.haskell.org/package/pipes-text-0.0.2.2 (MichaelThompson)
05:44:40 <polarke> Hello all! While I was reading the source code for applicative and monad, I found some parts of the code are exactly the same. So Why is it necessary to duplicate the code ?
05:45:20 <erisco> polarke, what is an example of this?
05:46:34 <polarke> For example, both have the same definition for functor class and applicative class.
05:46:55 <erisco> both of what?
05:47:32 <erisco> can you link to or pastebin the example?
05:49:24 <polarke> by both, I meant the source code for Control.Applicative and Control.Monad
05:49:39 <simpson> polarke: It's because Applicative and Monad used to not have the link that they currently have, basically. So people would have to implement the same logic over and over for those typeclasses.
05:50:21 <malorie> how'd I go about making a lookup into [MyType], when MyType is isomorphic to Eq a => (a, b)?
05:51:01 <erisco> :t filter -- malorie
05:51:03 <lambdabot> (a -> Bool) -> [a] -> [a]
05:51:18 <polarke> simpson, got it. thx!
05:51:35 <erisco> :t find -- malorie
05:51:36 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
05:52:48 <malorie> erisco: I see. I was thinking about something along the lines of converting my type, so that it passes to lookup, but this should work too
05:54:34 <erisco> newtype MyType a b = MyType { runMyType :: (a, b) }   flip (flip lookup . fmap runMyType)
05:55:35 <malorie> :-)
05:55:58 <erisco> (. fmap runMyType) . lookup
05:56:15 <erisco> haven't typed checked these, but something like that
05:59:10 <Guest27410> Hi you all, can anyboby give some example, link, or anything where I can see "listOf" from Digestive Functors in action using Heist, I've already seen uses with Snap + Hamlet but I cant find any Heist related stuff
06:05:44 <ned> anyone know why cabal install might be hanging indefinitely?
06:05:54 <ned> on 'resolving dependencies'
06:06:05 <ned> is there any way I can see what it's stuck on?
06:06:45 <merijn> ned: Maybe try with "-v3" and see what it's reporting?
06:06:46 <ned> my project runs fine on my computer, but I transferred the files to my production box and, as I said, it's just hanging
06:06:56 <ned> awesome, didn't know about that flag, I'll try it
06:11:39 <EvilMachine> erisco: I use leksah, and like it
06:13:40 <ned> hmmm, there's a giant wall of 'trying' and 'rejecting', but I think this is the meat of it
06:13:42 <ned>  rejecting: snap-0.14.0.7, 0.14.0.6 (conflict: comonad==5, snap => comonad>=1.1 && <4.3)
06:14:22 <merijn> ned: So snap can't work with the version of comonad your package requires
06:15:06 <edwardk> guessing your production box has already had a more recent comonad installed on it than snap allows
06:15:17 <edwardk> from something you installed previously?
06:15:56 <erisco> @tell EvilMachine thanks for the feedback
06:15:56 <lambdabot> Consider it noted.
06:15:59 <ned> edwardk: that seems likely, thanks
06:16:45 <edwardk> this is why people like sandboxes
06:16:53 <scshunt> or stack
06:16:55 <edwardk> never did get the hang of them myself
06:16:59 <edwardk> or stack
06:17:06 <ned> yeah, I should probably be using a sandbox
06:17:13 <ned> I haven't used stack on this machine
06:17:27 <ned> is ghc-pkg unregister the right way to 'remove' a package?
06:18:50 <erisco> what is the wrapper for -> to get a Contravariant instance?
06:19:29 <erisco> Op!
06:19:39 <merijn> ned: It will do just that, delete the package from GHCs registry. Although it does leaves the files in ~/.cabal
06:20:19 <ned> merijn: great, thanks
06:20:53 <merijn> YOu can just delete the relevant files afterwards, if you worry about disk space
06:21:11 <merijn> If not, you can just not bother and leave them there until you nuke the entire thing at some reinstall point in the future
06:22:55 <erisco> can you define types with lambdabot?
06:23:32 <ski> yes
06:23:50 <erisco> how do you define types with lambdabot
06:24:19 <ski> @let data PBBTree a = Elements a | Double (PBBTree (a,a)) deriving (Eq,Show,Read)
06:24:22 <lambdabot>  Defined.
06:24:47 <ski> you can also do `class' and `instance' declarations like that
06:24:51 <ski> (and even `import')
06:25:09 <ski> (and, iirc, `deriving instance' as well)
06:25:09 <erisco> :t fmap (getOp . contramap (fmap runMyType) . Op) lookup -- malorie
06:25:12 <lambdabot> Not in scope: ‘getOp’
06:25:13 <lambdabot>     Not in scope: data constructor ‘Op’
06:25:13 <lambdabot>     Perhaps you meant one of these:
06:25:24 <sm> erisco: I currently like intellij IDEA
06:25:34 <erisco> odd that those are not in scope, yet contramap is oO
06:25:47 <ski> where's `Op' ?
06:25:55 <erisco> http://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#t:Op
06:26:07 <ski> @let import Data.Functor.Contravariant
06:26:10 <lambdabot>  Defined.
06:26:11 <ski> @type Op
06:26:12 <lambdabot> (b -> a) -> Op a b
06:26:20 <erisco> :t fmap (getOp . contramap (fmap runMyType) . Op) lookup
06:26:22 <lambdabot> Eq a => a -> [MyType a b] -> Maybe b
06:27:44 <sm> erisco: FYI, there's also a #haskell-ide
06:28:05 <ski> erisco> :i MyType
06:28:25 <ski> oh, a pair
06:28:40 <erisco> sm, thanks. How is the support for Haskell?
06:29:15 <sm> it's almost very good.. it depends on ghc-mod which may work for you depending on what kind of project you have
06:29:36 <sm> but highlighting and basic code navigation just works
06:30:05 <erisco> @let ret = fmap; arg f = getOp . contramap f . Op
06:30:08 <lambdabot>  Defined.
06:30:20 <erisco> :t (ret (arg (fmap runMyType))) lookup
06:30:21 <lambdabot> Eq a => a -> [MyType a b] -> Maybe b
06:30:43 * ski 'd write that as `(ret . arg . fmap) runMyType lookup'
06:31:15 <zyder> hello all! I am new to haskell and hoping someone could help me with an exercise from haskellbook / Haskell Programming
06:31:16 <ski> (first the path, then the function to apply there. then the structure to which to apply the function-at-path)
06:31:46 <erisco> yes, that's right ski :) semantic editor combinators
06:31:52 <zyder> not sure how to solve this using foldr. Current solution uses filter and map.
06:31:58 <erisco> though I'd write it (ret.arg) (fmap runMyType) lookup
06:32:01 <zyder> 1. Try to eventually arrive at a solution that uses foldr, even if earlier versions don’t use foldr.
06:32:01 <zyder> lefts' :: [Either a b] -> [a]
06:32:06 <ski> @where SEC
06:32:06 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
06:32:07 <erisco> :t ret.arg
06:32:09 <lambdabot> Functor f => (b -> b1) -> f (b1 -> a) -> f (b -> a)
06:32:27 <erisco> thought it would be cool to derive this with contramap
06:32:43 <ski> (possibly should have given an explicit type signature for `ret', to specialize it for functions)
06:33:30 <weather2> http://espedito.homepc.it hostxall
06:33:44 * hackagebot pipes-text 0.0.2.3 - properly streaming text  https://hackage.haskell.org/package/pipes-text-0.0.2.3 (MichaelThompson)
06:34:08 <erisco> sm, I am wondering what a plugin that improves Haskell support for your IDE is worth to you
06:34:31 <ski> zyder : i have to leave now (otherwise i'd take a look). you can also try in #haskell-beginners, but this channel is also fine for newbie questions
06:35:07 <erisco> ski, I guess fmap is as good as an editor as any… ret.arg.fmap seems good :)
06:35:21 <sm> erisco: up to $50 for something much much better than the free options
06:36:09 <maerwald> the problem is not the money, but that it's proprietary software
06:36:30 <erisco> sm, thanks :)
06:36:45 <maerwald> if they send me the source code after I purchase it, that would already be fine
06:37:34 <erisco> maerwald, what permissions do you want with the software you have paid for?
06:38:13 <maerwald> it would be nice if it's free software, but just having access to the source of what I run is even more important
06:38:43 <maerwald> and I don't mean "free" as in "free of charge"
06:39:33 <erisco> maerwald, what freedoms do you want with software you have paid for?
06:40:21 <maerwald> I'd be fine with being able to hack on it, modify it and run the modified version. I don't care about publishing/distributing that modified version.
06:41:01 <zyder> @ski Thanks
06:41:01 <lambdabot> Maybe you meant: wiki src ask
06:41:10 <zyder> ski: Thanks
06:42:34 <erisco> maerwald, would you be interested in publishing and distributing your modifications?
06:42:56 <maerwald> interested yes, but it wouldn't be a requirement for me to purchase that software
06:44:50 <ned> are the flags for cabal install documented somewhere? Wish there were man pages :/
06:46:37 <hexagoxel> ned: `cabal help install` or `cabal install --help` or `man cabal` (with an up-to-date cabal-install installation)
06:46:46 <bernalex> cabal has manpages now?
06:46:51 <hexagoxel> yis
06:46:54 <bernalex> I have 1.22.8.0 and I don't have that
06:47:00 <bernalex> 1.22.9.0 even
06:47:12 <bernalex> it's about time at least
06:47:57 <hexagoxel> although it currently appears to be _one_ large manpage. my `man` navigating skills may be lacking, though.
06:48:11 <hexagoxel> (1.24.0.0)
06:49:28 <bernalex> oh ok it's with 24.
07:08:45 * hackagebot inflections 0.2.0.1 - Inflections library for Haskell  https://hackage.haskell.org/package/inflections-0.2.0.1 (jpvillaisaza)
07:33:47 * hackagebot kqueue 0.2 - A binding to the kqueue event library.  https://hackage.haskell.org/package/kqueue-0.2 (ErikHesselink)
07:45:46 <Wizziee> Hi, my foldr over the list is currently taking a tuple of 3 elements as an accumulator... The fold function looks like this:  makeRepr :: Int -> (String, Int, Int) -> (String, Int, Int) 
07:45:51 <Wizziee> Is there a way to make it better?
07:46:00 <Wizziee> More readable? How to refactor this?
07:46:29 <Jinxit> you could make it a type
07:47:20 <Wizziee> that's what I thought at first, but I doubted it will make it more readable. I will try this ;)
07:49:32 <scepticulous> I am currently trying to do some haskell exercises. Until now I only worked with "stack" and had 1) created a new stack project 2) worked with a single file and used stack ghc and stack runhaskell.. However now I have to implement a module for a given test file . however stack runhasekell test_file.hs complains about HUnit not being installed
07:50:01 <scepticulous> is there something I can do about that, without generating an entire stack project ( which would be a hassle for a lot of small exercises ) 
07:51:02 <erisco> according to this survey the vast majority of Haskellers use emacs or vi http://blog.johantibell.com/2011/08/results-from-state-of-haskell-2011.html
07:51:36 <erisco> exactly 85%, because no emacs user uses vi and vice-versa
07:52:27 <erisco> is 2011 still the latest survey?
07:53:59 <erisco> is anyone surprised by that? I am
07:56:05 <Aruro> erisco: u are surprised majority of haskellers like lisp?
07:56:17 <oherrala> erisco: I use both emacs and vi :)
07:57:36 <maerwald> the vast majority of programmers use emacs or vi
07:58:57 <benma> i wonder whether that is really true
07:59:13 <benma> hey, is anyone using hspec and stack?
08:01:12 <benma> i am missing an easy way to run a subset of the tests with a regexp or something
08:03:48 * hackagebot multiset 0.3.3 - The Data.MultiSet container type  https://hackage.haskell.org/package/multiset-0.3.3 (TwanVanLaarhoven)
08:06:03 <benma> `stack test --test-arguments "-m <filter>"` is quite verbose :/
08:07:28 <erisco> maerwald, do you have a survey that demonstrates this?
08:07:35 <maerwald> no
08:08:48 * hackagebot intero 0.1.10 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.10 (ChrisDone)
08:09:08 <erisco> there were a low number of responses for the survey I linked, and I don't think it had enough diversity, so I am not too confident in it
08:09:19 <erisco> "Like last year I ran the survey for one week. I got 798 responses (compared to 804 last year). The survey was announced on reddit, the major Haskell mailing lists, my Twitter account, and on this blog."
08:10:42 <erisco> I do not subscribe to any Haskell mailing lists, nor do I use reddit, nor do I read Tibell's blog
08:13:48 * hackagebot safecopy 0.9.1 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-0.9.1 (JeremyShaw)
08:16:05 <erisco> I am a REPL & Notepad++ user myself
08:16:24 <erisco> mainly REPL, Notepad++ when I want to keep stuff on disk
08:17:57 <Cale> erisco: I recently changed from vim to Sublime Text, and have been enjoying that.
08:19:38 <Cale> erisco: It doesn't surprise me at all that emacs and vim are the two most popular text editors though.
08:19:49 <Cale> This is just well-known isn't it?
08:20:32 <ahihi> is there data to back it up?
08:20:42 <ahihi> it certainly doesn't match my experience
08:21:04 <Cale> ahihi: Well, there's that data point erisco mentioned :)
08:21:33 <Cale> It certainly matches my experience, almost every programmer I know is using emacs or vim, with a few exceptions.
08:21:59 <umib0zu> are there any haskellers here that are also into category theory?
08:22:03 <Cale> umib0zu: lots
08:22:21 <maerwald> Cale: emacs is not a text editor. It's an operating system that happens to have a text editor 
08:22:31 <Cale> maerwald: fair enough
08:22:40 <ahihi> stack overflow's survey results look quite different http://stackoverflow.com/research/developer-survey-2016#technology-development-environments
08:23:02 <maerwald> Cale: and neither the operating, nor the text editor within work particularly well :P
08:23:04 * maerwald hides
08:23:08 <erisco> it doesn't match my experience
08:23:17 <Cale> ahihi: Yeah, though that's a much more general survey...
08:24:02 <Cale> I doubt there are many Haskell programmers who are using Visual Studio to edit their Haskell code, for example.
08:24:31 <Cale> There was a plugin for that many many years ago...
08:24:36 <ahihi> oh, I thought the claim was about editor usage among all programmers, not just haskellers
08:24:37 <erisco> I am also dubious about the survey because of the number of responses and that the respondents were only reddit users, Haskell mailing list subscribers, and readers of Tibell's blog
08:25:29 <erisco> I would use VS for Haskell if the plugin was good, but it wasn't good enough
08:25:56 <Cale> I'm surprised that it still exists.
08:26:28 <Cale> But given that you're saying it's not good enough, maybe it's not the one I heard about long ago
08:26:53 <benma> while almost everyone i know also uses emacs/vim, i doubt the majority of all programmers do
08:27:03 <benma> after all we are all in a sort of bubble
08:27:22 <benma> we are attracted to work and companies which have a culture of using such tools
08:27:36 <Cale> There was a really cool VS plugin for Haskell that Simon Marlow and Krasimir Angelov worked on a very long time ago.
08:27:49 <Cale> But I wouldn't be surprised if that bitrotted.
08:28:49 <ahihi> I don't find command-line editors ergonomic and mostly use textmate2/sublime
08:30:37 <erisco> when it was working I think the Haskell support in Atom was the best I've used
08:30:47 <erisco> but it broke and I haven't got it working again
08:31:13 <maerwald> with vim/emacs, everything is constantly broken, but kinda works
08:31:33 <Cale> The things people focus on when writing the language-specific support for text editors aren't the things I want them to focus on...
08:31:37 <ski> umib0zu : fwiw, there's also ##categorytheory
08:32:16 <Cale> maerwald: With basically all text editors, everything is constantly broken but kinda works.
08:33:42 <maerwald> Cale: nano is barely broken
08:34:05 <maerwald> but it doesn't really "work"
08:34:54 <umib0zu> I mostly asked because I’m getting together a reading group using Spivak’s Category Theory for Scientists. I’m wondering if Haskell would be a useful tool in doing homeworks.
08:35:09 <Cale> umib0zu: Pretty much no...
08:35:13 <ski> Cale : what are they focusing on that you don't want them to, and what'd you prefer them focusing on ?
08:36:18 <Cale> ski: Well, I dunno, there's a lot of focus being put on e.g. integration with build tools, which is not very useful to me, when it's still so painful to... edit... text.
08:36:31 <Cale> I would like an editor which *really* understand's Haskell's offside rule.
08:36:34 <umib0zu> I think right now the hardest thing I have to wrap my head around is specifications in proofs. How do I show a specification is met using haskell? Like a “for all x, there exists an f such that P(f, x)” seems to imply I just write the existence of f, but then assert P(f, x).
08:36:37 <Cale> understands*
08:36:49 <ski> Cale : how about more advanced refactoring ?
08:36:49 <Cale> ugh, that apostrophe :P
08:37:02 <ski> even e.g. just renaming a bound variable
08:37:48 <Cale> I also don't really care about automatic refactoring... the thing which Sublime does is good enough there: when I select something, semi-highlight the matching things nearby and let me press a key to start selecting those too and then edit them all at once.
08:38:11 <ski> umib0zu : well, `f'd normally also depend on `f' there, so you'd add it as another argument, i suppose
08:38:21 <Cale> Sublime's multiple cursors thing is a definite advancement for me
08:38:51 <Cale> (though I kind of worry that it lets me work with repetitive code that shouldn't exist in the first place)
08:39:55 <Cale> But yeah, it's sort of a halfway solution to the fact that the editor completely doesn't understand what indentation means and how to edit stuff involving it
08:40:41 <maerwald> mh, sublime doesn't even properly build my project
08:41:07 <Cale> maerwald: That's an example of a feature that I absolutely do not care about, but editors seem to focus on a lot
08:41:20 <NatureShade> is there anything like gloss with a cairo backend, I am giving up on OpenGL
08:41:26 <maerwald> I wasnt compiler errors to show up in the code, not in a separate window
08:41:31 <maerwald> s/wasnt/want/
08:41:53 <Cale> That doesn't really affect me at all, I don't really care where the errors appear
08:42:09 <Cale> and more often than not, I really need them in a separate window
08:42:22 <Cale> because they're too large to waste editor real-estate on
08:43:01 <Cale> (though they could appear in a separate pane in the editor, and it would be the same)
08:43:23 <Cale> It's not important to me that it's the editor vs. just another terminal though
08:43:30 <maerwald> vim allows both with plugins, sublime just fails to build stuff at all
08:43:49 * hackagebot hpath 0.7.3 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.7.3 (maerwald)
08:44:10 <Cale> Maybe I'm biased by the fact that I'm pretty much always using custom build scripts which no editor is going to really know what to do with anyway.
08:45:00 <Cale> The projects for my work use nix in various ways to build things, anyway.
08:47:42 <Cale> But yeah, how nice would it be to have an editor where if any edit you made caused the first non-whitespace character following a layout keyword to change position, caused the entire block to move analogously?
08:48:21 <maerwald> I just realized how incredibly lazy we are
08:48:50 * hackagebot pandoc-placetable 0.4 - Pandoc filter to include CSV files  https://hackage.haskell.org/package/pandoc-placetable-0.4 (mb21)
08:48:57 <Cale> I think there might be some cases which would need some finesse there -- like what happens when this accidentally causes the block levels to collide -- you might need a grace period where they don't "stick together" for a second or so
08:49:27 <maerwald> the editor should just read my thoughts
08:49:42 <MichaelBurge> Cale: I usually just use the block-replace command to add indentation afterward
08:50:06 <Cale> MichaelBurge: Yeah, but that sucks, and it affects the ways in which it's reasonable to lay out code.
08:50:16 <MichaelBurge> Cale: Or rather the rectangular replace
08:50:39 <Cale> My preferred indentation style to read is very different from my preferred indentation style to write
08:50:45 <kaol> @pl \f a b -> f a == f b
08:50:45 <lambdabot> flip =<< (((.) . (==)) .)
08:51:37 <Cale> e.g. I actually hate pressing enter after 'do', but I do it anyway because if you don't the code is annoying to edit.
08:52:11 <Cale> Sometimes I'll put the newline *before* the do, but even that's kind of annoying to edit
08:52:13 <Koen_> sounds like your text editor needs customizing
08:52:26 <Cale> Koen_: It needs a feature which nobody has implemented
08:52:44 <Koen_> this nobody sounds like a great guy
08:52:55 <Koen_> has he implemented other features you're missing?
08:52:58 <Cale> hahaha
08:53:04 <kaol> I have a feeling that there should be a way to write that function without repeating f. But not the way @pl did it.
08:53:31 <Cale> liftM2 (==) f f
08:53:37 <Cale> join (liftM2 (==))
08:57:48 <lpaste> lzc pasted “fetch data type” at http://lpaste.net/164828
08:57:48 <lpaste> lzc pasted “fetch data type” at http://lpaste.net/5420607030903701504
08:58:02 <lpaste> lzc pasted “fetch data type” at http://lpaste.net/5752172557625196544
08:58:10 <Guest27410> Please, some example to dynamic checkbox list using Digestive Functors + Heist ????
08:59:23 <lpaste> lzc revised “fetch data type”: “fetch data type” at http://lpaste.net/164828
08:59:47 <lpaste> lzc revised “fetch data type”: “fetch data type” at http://lpaste.net/5420607030903701504
08:59:57 <lpaste> lzc revised “fetch data type”: “fetch data type” at http://lpaste.net/5752172557625196544
09:00:20 <lpaste> lzc revised “fetch data type”: “fetch data type” at http://lpaste.net/5752172557625196544
09:00:48 * ski looks at lzc
09:07:24 <deech> Where can I get more information on the GHC 8's constraint redundancy checker? It's throwing a redundant constraint warning for a constraint on the single instance of an empty typeclass.
09:08:22 <erisco> hm, found a @pl bug
09:08:52 <erisco> @pl \f -> liftA2 (==) <$> pure f <*> pure f
09:08:52 <lambdabot> (liftA2 (==) <$>) . liftM2 (<*>) pure pure
09:11:23 <erisco> maybe it doesn't understand typeclass members
09:33:52 * hackagebot intero 0.1.11 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.11 (ChrisDone)
09:35:09 <dreamaddict_> is it true that haskell "never" core dumps?
09:35:19 <erisco> nope
09:36:57 <oherrala> it's possible to core dump, but it's difficult :)
09:46:27 <srhb> oherrala: I saw this somewhere: foreign import ccall main :: IO ()
09:47:10 <srhb> As with most things in Haskell, it's quite easy! ;-)
09:47:53 <erisco> hmm… f x == f y  is tough!
09:49:03 <ski> erisco ?
09:49:08 <erisco> to make pointless
09:49:30 <mjburgess> f = (==)   ?
09:50:46 <erisco> there is  on (==)
09:50:52 <erisco> but that isn't so satisfying
09:50:55 <ski> erisco : would sometimes be nicer, with real existentials
09:51:24 <erisco> kaol, try  on (==)
09:51:32 <ski> @let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f
09:51:35 <lambdabot>  Defined.
09:51:41 <ski> @type comparing
09:51:42 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
09:51:47 <ski> @src comparing
09:51:47 <lambdabot> comparing p x y = compare (p x) (p y)
09:51:50 <ski> @src on
09:51:50 <lambdabot> (*) `on` f = \x y -> f x * f y
09:51:57 <ski>   comparing p = compare `on` p
09:52:04 <erisco> it is just the exact thing we're trying to make pointless
09:52:08 <dolio> Why is on not satisfying? That's the reason it was made.
09:52:23 <erisco> dolio, ^
09:52:27 <ski> @type (==) `on` fst
09:52:29 <lambdabot> Eq a => (a, b) -> (a, b) -> Bool
09:52:41 <ski> `Eq a => (a,b0) -> (a,b1) -> Bool' would be nicer
09:52:57 <ski> (which i think one'd have, if `fst :: forall a. (exists b. (a,b)) -> a')
09:53:18 <ski> (in many cases it doesn't matter, though)
09:54:30 <erisco> mm, I see what you're saying, but that seems like a different issue
09:54:55 <byorgey> @pl \f x y -> f x == f y
09:54:55 <lambdabot> flip =<< (((.) . (==)) .)
09:54:57 <byorgey> whee
09:55:08 * ski smiles
09:55:12 <erisco> now explain it to me
09:55:50 <ski> perhaps someone should make `pl' into an expert system ?
09:57:18 <oherrala> srhb: heh, true
10:00:29 <erisco> semantic editor combinators read obviously, and http://stackoverflow.com/a/34536499/260584 reads obviously
10:00:45 <erisco> you can express many things that way
10:00:51 <erisco> but I'm not sure about  f x == f y
10:01:30 <jle`> wait, why doesn't on work?
10:01:54 <erisco> because it is just the exact thing we're trying to make pointless
10:02:18 <erisco> ideally you want simpler, more general pieces
10:02:26 <jle`> but that's like saying that (.) isn't allowed
10:02:30 <erisco> if you just introduce the primitive "on" then it is an uninteresting answer
10:02:35 <jle`> for foo = f (g x) is f . g
10:02:35 <erisco> no, it isn't
10:02:54 <jle`> turning f (g x) into f . g
10:03:02 <jle`> but (.) is literally just the exact thing you're trying to make pointless
10:03:23 <erisco> I'm not trying to make  f (g x)  pointless
10:03:29 <jle`> on is generally useful in lots of situations beyond this one, just like (.)
10:03:40 <jle`> yeah, but saying that `on` is unsatisfying is like saying that (.) is unsatisfying
10:03:46 <jle`> or...any other combinator, for that matter
10:04:04 <erisco> it would be unsatisfying if we wanted to express (.) with other primitives!
10:05:32 <Welkin> erisco: your prime minister is a heathen molestor!
10:05:55 <erisco> Welkin, Trudeau?
10:06:12 <Welkin> yes
10:06:24 <erisco> he is still overcoming the elbowing scandal, what now?
10:06:24 <Welkin> molestation
10:06:47 <Welkin> same
10:07:34 <erisco> opponents are just taking any opportunity to attack him… it is petty
10:07:43 <Welkin> but, he molested!
10:07:56 <erisco> is that how it has escalated? lol
10:08:20 <Welkin> your own common house said it themselves
10:08:25 <Welkin> he molested a member of the house!
10:08:53 * hackagebot spatial-math 0.3.0.0 - 3d math including quaternions/euler angles/dcms and utility functions  https://hackage.haskell.org/package/spatial-math-0.3.0.0 (GregHorn)
10:08:54 * ski checks the channel name
10:09:46 <Welkin> sorry ski
10:09:59 <Welkin> you are in #canuck-gov
10:18:53 * hackagebot yesod-auth-hashdb 1.5.1.1 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.5.1.1 (paulrouse)
10:22:58 <lambda-11235> I'm trying to run two computation in parallel with STM, but they are taking the same amount of time as if they were ran in sequence.
10:23:09 <lambda-11235> https://gist.github.com/lambda-11235/49c134ac4966f254b9c5031fe92212bf, any suggestions?
10:23:39 <byorgey> lambda-11235: are you compiling with -threaded and running with  +RTS -N2 -RTS ?
10:24:34 <lambda-11235> byorgey: No. I'll try that.
10:24:50 <haskell268> I have this parsec parser `test = ((try $ string "a") <|> (string "ab")) *> (string "c")` but it cannot parse "abc" string. Is there any simple way to forse the parser to check (string "ab") branch?
10:26:06 <lambda-11235> byorgey: It had no effect.
10:26:16 <byorgey> lambda-11235: otherwise it is only running with 1 thread.  Using STM gives your program concurrent *semantics*; whether your program is actually using multiple threads/cores is a completely separate runtime issue
10:27:32 <byorgey> lambda-11235: does your machine have more than 1 core?
10:28:54 * hackagebot gll 0.3.0.10 - GLL parser with simple combinator interface  https://hackage.haskell.org/package/gll-0.3.0.10 (ltvanbinsbergen)
10:28:56 <lambda-11235> byorgey: It has 2 real cores, and an additional 2 virtual cores.
10:28:56 * hackagebot generic-accessors 0.6.0.1 - stringly-named getters for generic data  https://hackage.haskell.org/package/generic-accessors-0.6.0.1 (GregHorn)
10:28:58 * hackagebot haxr 3000.11.1.6 - XML-RPC client and server library.  https://hackage.haskell.org/package/haxr-3000.11.1.6 (BrentYorgey)
10:30:27 <byorgey> lambda-11235: hmm, I don't know then.  I can't see anything else obviously wrong.
10:31:16 <dolio> Do you get different results using plain MVar?
10:32:34 <joneshf-laptop> How do we know that there are unique instances for `Functor`, `Foldable` and `Traversable`?
10:32:51 <byorgey> lambda-11235: I just tried it, and I get a nice speedup when running with -N2.
10:33:06 <Freundlich> haskell268: Using <|> the other way around should work: (try $ string "ab") <|> (string "a")
10:33:16 <byorgey> lambda-11235: maybe try deleting the executable and .o file before recompiling with -threaded
10:33:24 <lambda-11235> byorgey: Do my flags look ok? ghc -fforce-recomp -threaded +RTS -N4 -RTS test.hs
10:33:52 <byorgey> lambda-11235: the +RTS -N4 -RTS flags should be passed to the executable when running it, not to GHC
10:33:55 <geekosaur> haskell268, reverse the branches (but leave the try on the first)
10:33:58 <Freundlich> haskell268: p <|> q tries p first and only tries q if p failed and didn't consume any input (which you get by using try p).
10:34:09 <haskell268> Freundlich: yes, but I cannot change the order
10:34:19 <geekosaur> the only way the first parser fails is if the first letter is not "a"; if it is "a" then that first parser will succeed without looking for a "b".
10:34:46 <geekosaur> and parsers cannot magically tell what some other branch will do
10:35:04 <lambda-11235> byorgey: Ok, got it. Thanks.
10:35:43 <haskell268> geekosaur: I don't need magic I want to tell parser somehow to check all the options
10:36:10 <Aruro> haskell268: check first ab
10:36:21 <geekosaur> so run the second one even though the first succeeded? how is it supposed to decide which to use then?
10:36:42 <geekosaur> track which one consumed the most input?
10:36:58 <Aruro> haskell268: actually both of them have a so u have to use char 'a' to consume this a
10:37:23 <geekosaur> haskell268, what is the real problem you are trying to solve?
10:37:24 <Freundlich> haskell268: What you are asking for is basically a non deterministic parser. I don't think you want that.
10:37:38 <geekosaur> <|> is not going to do what you want. so what *do* you want, and what are you allowed to use?
10:37:39 <haskell268> geekosaur: If it fails it should try another branches
10:37:47 <geekosaur> it's not failing
10:37:49 <geekosaur> that
10:37:52 <geekosaur> that's the poiunt
10:37:57 <Freundlich> haskell268: It's not failing the branch, it's failing later.
10:38:01 <geekosaur> try $ string "a" <-- SUCCEEDS
10:38:06 <geekosaur> so the other branch is not tried
10:38:26 <Freundlich> haskell268: Should it go back and try all other combinations of all the branches?
10:38:36 <geekosaur> and by the time you get to the match "c" it is too late to go retry arbitrary things it committed to.
10:38:39 <haskell268> Freundlich: yes
10:38:42 <geekosaur> refactor the parser
10:38:46 <ski> (`( [a] | [a,b] ),[c]' would work in Prolog ..)
10:38:56 <Aruro> haskell268: maybe u will be interested in parser optional
10:39:11 <Aruro> haskell268: to optionally check for b is u matched a
10:39:17 <haskell268> here is the whole problem, maybe someone can answer it http://stackoverflow.com/questions/37525609/is-it-possible-to-force-backtrack-all-options
10:39:40 <ski> @hackage parsek
10:39:40 <lambdabot> http://hackage.haskell.org/package/parsek
10:39:44 <geekosaur> haskell268: more specifically yiou have the <|> inside parens. retry is only going to happen within those parentheses, not at any arbitrary point later
10:40:39 <geekosaur> there are ways to do backtracking like regex but that's not it and it's not a natural thing for this kind of parser
10:41:28 <geekosaur> ...and the reason nobody makes it work is that experience with regex, which does allow it, is that you pay heavily in either time or memory for that backtracking
10:41:51 <geekosaur> so you should refactor your parser to not do things that way
10:43:30 <ski> haskell268 : perhaps you could try that Parsek thing
10:43:48 * ski thinks this is one of the uglier parts of Parsec
10:44:04 <Aruro> haskell268: test = (char 'a' *> optional (char 'b')) *> string "c" :: Parser String
10:44:13 <haskell268> ski: I don't want to change a parser library
10:44:20 <ski> ok
10:47:20 <haskell268> Aruro: I want to find an approach so it could work with any parsers (try a <|> b) *> c
10:49:09 <geekosaur> this smells to me like someone wants to demonstrate the "superiority" of regex. never mind that showing that as a regex to people who actually know regex will get you an admonition to rewrite it the same way you would to turn it into a parser. for the same reason, even.
10:50:34 <haskell268> geekosaur: I don't want an regex, I have a real problem http://stackoverflow.com/questions/37525609/is-it-possible-to-force-backtrack-all-options and I want to undestand is there any simple solution
10:51:21 <geekosaur> regex is the "simple solution". it'll also be pathological if you feed it large inputs, depending on how often it's allowed to match
10:52:07 <geekosaur> you are basically asking "how do I walk from London to Moscow in 15 minutes"
11:10:40 <hexagoxel> is there a common high-precedence name for `flip (.)` ?
11:11:05 <ski> @type (<<<)
11:11:07 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
11:11:20 <hexagoxel> ski: _high precedence_
11:11:29 <ski> hm, just noticed that part
11:11:30 <ski> sorry
11:11:33 <hexagoxel> :)
11:17:22 <zaquest> hello. can not figure out how to get a list of strings from [Symbol] type parameter using singletons. is it possible? or at least just check if runtime value is in that list
11:18:38 <mtesseract> Hi
11:31:28 <ZelteHonor> I am using stack for a project and I can't seem to find how to enable +RTS option when I use stack exec. I have -rtsopts in my .cabal in ghc-options: but it's still fail saying: stack: Most RTS options are disabled. Link with -rtsopts to enable them.
11:31:46 <ZelteHonor> Do I need to "force" all my dependency to use it?
11:34:13 <geekosaur> ZelteHonor, stack exec -- ...
11:34:27 <geekosaur> without the --, stack itself is eating the +RTS
11:34:59 <geekosaur> (alternately use --RTS instead of --)
11:35:25 <ZelteHonor> geekosaur: Thanks. I even knew it. I just forgot.
11:41:50 <jle`> zaquest: it is possible
11:42:11 <dfeuer> YOU are possible.
11:42:19 <jle`> :3
11:42:21 <zaquest> good :D
11:42:44 <dfeuer> Anyone know how to implement single-element deletion in 2-3 finger trees without horrifying amounts of nasty code?
11:42:48 <jle`> zaquest: you need to either pass along the `Sing syms` or have a SingI syms instance
11:42:59 <dfeuer> (and with maximal sharing)
11:43:19 <dfeuer> (and high speed)
11:44:56 <jle`> zaquest: symsSingToList = \case SNil -> []; s `SCons` ss -> fromSing s : symsSingToList ss
11:45:43 <jle`> zaquest: that's a function that takes an explicit Sing, but you can also use a SingI instance and 'sing'
11:49:26 <nitrix> dfeuer: Using recursion.
11:49:50 <dfeuer> nitrix, is there some particular way you mean?
11:50:42 <dfeuer> I'm working on a recursive thing, yes, but that doesn't get into much detail. The trouble is that 2-3 (non-finger) tree deletion has a lot of cases, and has to deal with a few levels of tree at once.
11:50:58 <dfeuer> Then the finger tree stuff gets layered on top, and ew.
11:51:06 <nitrix> dfeuer: You traverse the tree recursively, focus on the the region of interest to ignore it; return the rest as-is.
11:51:09 <jle`> gross
11:51:32 <nitrix> dfeuer: Oh maybe the question is about the rebalancing?
11:52:09 <dfeuer> nitrix, more about whether there's some particularly nice way to structure the code, or whether "horrifying" is about the only way to do it.
11:52:45 <nitrix> dfeuer: https://github.com/nitrix/lspace/blob/1c4fa4a81d1b907e28cbcdfd9ff604420d065e0f/src/Grid.hs
11:53:00 <nitrix> dfeuer: I don't know. Maybe use a more sane language, sometimes it helps.
11:53:09 <dfeuer> The approach I'm currently working on uses data Del a = Full !(Node a) | Defect a, passing those things up. But the top of the finger tree (where there are elements instead of nodes) is a whole different thing.
11:53:17 <nitrix> dfeuer: That one's a Quadtree. Was painless to implement.
11:53:25 <dfeuer> And I don't know that I can even handle the Digits uniformly.
11:53:57 * hackagebot hapistrano 0.2.1.2 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.2.1.2 (jpvillaisaza)
11:56:13 <dfeuer> nitrix, it looks like your types are regular, which is a somewhat simpler situation.
11:57:01 <dfeuer> (you don't have to change types to "clean up" results)
11:57:30 <nitrix> dfeuer: What's the definition of your finger tree?
11:58:22 <dfeuer> nitrix, it's the one in Data.Sequence.  data FingerTree a = Empty | Single a | Deep !Int !(Digit a) (FingerTree (Node a)) !(Digit a)
11:59:22 <dfeuer> So I need to descend a couple levels down the spine before I get nodes of nodes, which are the recursive case for deletion.
11:59:53 <nitrix> dfeuer: Deletings in 2-3 finger trees are prefix-based, right?
11:59:59 <nitrix> Deletions*
12:00:08 <dfeuer> nitrix, what do you mean by "prefix-based"?
12:00:34 <dfeuer> I'm trying to implement deleteAt :: Int -> Seq a -> Seq a
12:01:07 <dfeuer> I've already implemented insertAt :: Int -> a -> Seq a -> Seq a, which wasn't *too* bad, but this seems substantially worse.
12:02:14 <dfeuer> The goal is to increase speed and sharing over the simple splitAt-based approach.
12:03:52 <dfeuer> deleteAt i xs = case splitAt i xs of (p, q) -> p <> drop 1 q
12:06:21 <zaquest> jle`, just unable to understand how this works :| i tried all this, it gives me various type errors. for example http://lpaste.net/164832 . also i can not understand what SingI is. there are no instances of SingI it seems and it is unclear to me how to produce them.
12:07:17 <dfeuer> nitrix, I know I can accomplish my goal; I know I'm on a path that will get me there. I'm just unhappy with the amount of hairy code it seems to require.
12:11:18 <jle`> zaquest: you need to "case match"
12:11:20 <jle`> because it's a GADT
12:11:25 <jle`> you can't directly pattern match like that on a GADT
12:11:41 <jle`> so toList l = case l of SNil -> ...
12:11:45 <zaquest> oh, ok
12:11:46 <jle`> or toList = \case SNil -> ...
12:12:20 <jle`> it's sort of because all of the branches need to be "wrapped up together" in the same expression, sort of
12:12:38 <jle`> so it's like toList l = (case l of SNil -> ...; SCons _ _ -> ...)
12:12:58 <jle`> you can't split up handling a GADT across multiple declarations because then things get weird
12:13:01 <danpalmer> Hi all, I'm not sure if I'm misunderstanding how building with stack works, but `stack build --os=linux` doesn't appear to give me a linux binary? Am I missing something here?
12:13:23 <ski> jle` : hm, i thought it worked fine, as long as you had an explicit type signature ?
12:13:44 <jle`> hm, whenever i try it, i get an explicit "please use a case statement" error from GHC
12:13:57 <jle`> maybe i also happent to not have type signatures too
12:13:58 * hackagebot twitter-feed 0.2.0.6 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.6 (jpvillaisaza)
12:14:06 <zaquest> jle`, it gives me the same error...
12:14:22 <jle`> zaquest: ah, you should probably also have the type signature too then, heh
12:14:44 <jle`> toList :: forall (ss :: [Symbol]). Sing hs -> [String]
12:14:47 <jle`> s/hs/ss
12:15:11 <jle`> or toList :: Sing (ss :: [Symbol]) -> [String] might work too
12:16:10 <jle`> and you'll need a SingI constraint on your instance
12:16:23 <jle`> instance SingI xs => Read (OneOf xs) where
12:16:46 <jle`> because of type erasure and stuff like that
12:16:54 <dfeuer> Hrmmm... Not sure how to handle this case.... Mumble.
12:17:59 <zaquest> jle`, forall gives me parse error, but the second one type checks. still dont understand what SingI is :D
12:18:19 <jle`> you'll need to turn on ScopedTypeVariables or RankNTypes for the forall syntax to work
12:18:31 <zaquest> jle`, i have ScopedTypeVariables enabled
12:18:38 <jle`> oh interesting
12:18:47 * geekosaur would have expected that pretty much every extension implies ExplicitForalls by now...
12:18:52 <dfeuer> Gross.....
12:18:57 <jle`> zaquest: SingI lets you construct the 'Sing' structure from 'xs'
12:19:21 <jle`> zaquest: it's basically the equivalent of "passing" a `Sing xs` into your 'read'
12:19:24 <dfeuer> Always turn on ScopedTypeVariables to avoid getting confused.
12:19:35 <zaquest> jle`, yes, but how do i get an instance of it?
12:19:49 <jle`> the most direct way is to just use type literal
12:20:06 <jle`> like `read :: String -> OneOf '["Hello", "World"]`
12:21:56 <jle`> using type literals and things like that will give you your SingI instance when you use it
12:22:19 <zaquest> jle`, oh, so it is there for type literals and i just need to specify it explicitely because of type earasure. probably i understood that bit :D
12:22:33 <jle`> you get the instance whenever you use a type literal
12:23:27 <jle`> because of type erasure, when you write a Read instance for OneOf xs, you don't "know" what xs is
12:23:41 <jle`> becuase it can depend on runtime
12:23:59 <jle`> er, it's in general not knowable until runtime
12:24:19 <jle`> what you *can* do is pass a `Sing xs` along to your function, which is a normal data type that can be generated at runtime
12:24:26 <jle`> (like any other data type)
12:24:48 <jle`> but, in a typeclass instance, you can't require `read` to also take a `Sing xs`...that would change the type signature of `read`
12:25:17 <jle`> so a `SingI xs =>` constraint is a way for your Read implementation to get a 'Sing xs' implicitly
12:27:41 <zaquest> jle`, ok, thank you
12:28:21 <jle`> np!
12:31:07 <jle`> zaquest: it's a little confusing at first, becuase it feels obvious that GHC would always know what 'xs' is.  but, there are situations where 'xs' can not be known until runtime, or depend on runtime things like user input, etc.
12:31:54 <jle`> and there might never even be any type literals in the entire process
12:37:41 <polarke> Hello! I am using ghc 8, and I found it's impossible to import Language.Haskell.Exts. Is it because haskell-src-exts doesn't support ghc 8?
12:38:12 <geekosaur> there is not yet a release for ghc8
12:40:43 <geekosaur> and it doesn't look like the repo HEAD has ghc8 support either
12:42:43 <polarke> geekosaur: thx! Does it mean that if the package uses haskell2010, it would support ghc8
12:44:40 <c_wraith> polarke: ghc 8 is *very* new.  It'll take another month before it has wide support, anyway
12:45:54 * geekosaur is not sure what haskell2010 has to do with it. ghc stopped doing haskell98 and haskell2010 as of 7.10.1 anyway; backward compatibility became too difficult
12:47:47 <scshunt> where are the official release notes for 8.0?
12:48:16 <geekosaur> it is possible that, iuf you are using cabal or stack, --allow-newer=haskell-src-exts will let it build. note that it won't understand any of the new language features in ghc8; that requires someone to add the support
12:49:41 <ryantrinkle> geekosaur: i'm using haskell-src-exts on ghc 8; I'm not sure how much 8.0 syntax/etc. it supports, but it does build and work for what it was doing before
12:49:43 <int-e> haskell-src-exts should build just fine... at least it did 2 days ago.
12:50:21 <mauke> scshunt: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/8.0.1-notes.html
12:50:26 <scshunt> ty
12:50:45 <int-e> (with ghc-8.0.1)
12:50:51 <geekosaur> see also https://ghc.haskell.org/trac/ghc/wiki/Migration/8.0
12:51:23 <int-e> there are a few template haskell changes that are slightly annoying
12:52:28 <polarke> As I am just learning haskell, it seems I'd better go back to haskell 7.10.3
12:52:36 <int-e> I have not run into the remaining changes listed on the wiki yet
13:04:01 <int-e> polarke: yes, going back to 7.10.3 is probably best for now. in any case, if you expected a haskell-src-exts package compiled for ghc-7.10.3 to still work for ghc-8.0.1: this never works, all packages have to be (re)compiled for the specific compiler version.
13:05:31 <polarke> int-e: ty!
13:29:00 * hackagebot Rasterific 0.6.1.1 - A pure haskell drawing engine.  https://hackage.haskell.org/package/Rasterific-0.6.1.1 (VincentBerthoux)
13:30:43 <hpc> oooooh
13:30:52 <hpc> rasterific is an amazing package
13:34:00 * hackagebot higher-leveldb 0.3.1.0 - A rich monadic API for working with leveldb databases.  https://hackage.haskell.org/package/higher-leveldb-0.3.1.0 (jeremyjh)
13:40:31 <mpickering> ryantrinkle: There is a new branch which has support for the new syntax but I also removed the simplified AST
13:40:50 <mpickering> so it is not yet clear whether we will release a new version without the simpified ast or not
13:41:07 <ryantrinkle> mpickering: ah, cool :)
13:59:01 * hackagebot svg-tree 0.5.1.1 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.5.1.1 (VincentBerthoux)
14:06:11 <deech> Is there such a thing as a type level fallback with closed type families? I want to express something like, if the equation `Foo X Y` doesn't match anything, try `Bar X Y`. 
14:07:03 <RyanGlScott> deech: What's an example of what you're trying to do?
14:12:32 <deech> RyanGlScott: I'm using a type family to do a "lookup". Something like http://lpaste.net/164870.
14:13:54 <RyanGlScott> deech: OK. In this scenario, I take it you want to do something else if, say, Dictionary1 is given a type other than InDictionary1?
14:14:07 <deech> Yes.
14:14:25 <deech> I want to check Dictionary2.
14:14:55 <RyanGlScott> Would adding a catch-all equation at the bottom suffice? Dictionary1 x = Dictionary2 x?
14:15:17 <deech> Ah! Didn't think of that. Thanks!
14:15:22 <RyanGlScott> That requires UndecidableInstances, sadly, but it'll work
14:15:31 <deech> Whee!
14:26:00 <nineonine> has anyone encountered such problem ?
14:26:01 <nineonine> http://stackoverflow.com/questions/20034933/cabal-cant-find-source-for-xxx-h-in-dist-build-autogen
14:26:06 <nineonine> local builds are ok
14:26:40 <nineonine> for me it only happens when im trying to build with travis
14:26:40 <nineonine> https://travis-ci.org/nineonine/haskogs/jobs/134017715
14:26:40 <nineonine> it is complaining about module which is not exported by library
14:26:57 <nineonine> you can find it in "other-modules" in .cabal file however
14:28:40 <RyanGlScott> nineonine: The most glaring problem is that there doesn't seem to be a file named Horde3DUtils_h anywhere in that repo
14:28:51 <nineonine> yeah i know
14:29:02 <nineonine> thats because this stackoverflow is not my question
14:29:11 <RyanGlScott> So if you can't find that, ¯\_(ツ)_/¯
14:29:12 <nineonine> looks like it has same problem
14:29:16 <nineonine> hehe
14:29:22 <nineonine> here is my library
14:29:26 <nineonine> https://github.com/nineonine/haskogs
14:34:38 <polarke> Hello! Is there any library for generating typed Haskell syntax tree? I only found haskell-src-exts to generate untyped syntax tree.
14:35:22 <nineonine> RyanGlScott: any thoughts ? :)
14:35:24 <monochrom> I think people go all out and use the GHC API. it is a really big hammer.
14:36:05 <RyanGlScott> nineonine: ? Are you experiencing the same issue as the StackOverflow question with haskogs?
14:36:14 <nineonine> yes !!!
14:36:20 <Cale> monochrom: Kind of, but it is a pretty appropriately-sized hammer for that problem...
14:36:40 <nineonine> you can see it in build log here
14:36:41 <nineonine> https://travis-ci.org/nineonine/haskogs/jobs/134017715
14:36:48 <RyanGlScott> Ah sorry, it wasn't clear from just the link. I'll take a gander.
14:37:07 <nineonine> sorry about that !
14:37:15 <glguy> ninedotnine: capitalization
14:37:17 <glguy> err
14:37:23 <glguy> nineonine: Capitalization of file names
14:37:45 <glguy> Presumably you're building on OS X where things are case-insensitive and Travis is not 
14:37:57 <nineonine> true
14:38:01 <nineonine> im on OS X
14:38:03 <prohobo> hehe travis
14:38:14 <nineonine> so I should rename everything in downcase ?
14:38:28 <nineonine> everything in src ?
14:38:31 <glguy> No, you need to settle on MarketPlace or Marketplace, not both
14:38:35 <hpd> Is there any reason why the transformers dependency of monads-tf hasn't been updated to transformers-0.5? It seems to build fine
14:39:00 <nineonine> where do you see both versions ?
14:39:21 <glguy> ninedotnine: the filename in github didn't match the filename in the travis build output
14:40:06 <nineonine> wow
14:40:14 <RyanGlScott> hpd: The author just hasn't gotten around to updating it. I've e-mailed the author (Ross Paterson) before, he's pretty responsive about fixing things like that.
14:40:20 <nineonine> true
14:40:26 <nineonine> thanks !!!!
14:40:35 <nineonine> will try to fix it now
14:40:55 <hpd> RyanGlScott: alright, thanks. I'll email him
14:49:03 * hackagebot google-translate 0.2 - Google Translate API bindings  https://hackage.haskell.org/package/google-translate-0.2 (DavidJohnson)
14:50:12 <tippenein> bench: TemplateNotFound "default"
14:50:22 <tippenein> trying to benchmark something to output file
14:50:45 <tippenein> bench 'stack exec prog -- arg' --output output.html
14:53:02 <ZelteHonor> What is ARR_WORDS in Haskell? Also are Integer (the arbitrary precise one) implemented using it?
14:54:29 <tippenein> STMContainers.Map.stream m where m :: STMContainers.Map ByteString Integer
14:54:44 <tippenein> how would I sort a map stream from STMContainers
14:55:17 <tippenein> stream :: Map k v -> ListT STM (k, v) 
14:56:17 <tippenein> maybe a traverse_ from ListT?
15:27:19 <dfeuer> There is a very, very small chance that this will work.
15:27:33 <dfeuer> There is a very, very large chance that this will require extensive debugging.
15:27:37 <dfeuer> Yup, failed.
15:28:08 <dfeuer> Er ...
15:28:14 <dfeuer> No, made a mistake.
15:30:04 <prohobo> wait
15:30:19 <prohobo> you made a mistake that stopped you from failing?
15:33:09 <dfeuer> prohobo, I wrote my QuickCheck property wrong.
15:33:23 <dfeuer> prohobo, that said, I don't really trust this implementation yet.
15:33:44 <scshunt> switch to agda
15:33:50 <scshunt> prove it correct
15:36:13 <dfeuer> scshunt, not a chance. Deleting an arbitrary element from a 2-3 finger tree does not sound like fun Agda.
15:42:35 <doubling> which proof assistant is most suitable for verifying my excel scripts
15:44:07 <Cale> doubling: Microsoft Visual Coq
15:44:39 <simpson> Cale: I can't tell if that's a real thing. I'm not sure whether I want that to be a real thing.
15:49:13 <MichaelBurge> It wouldn't surprise me if they had something like that; they do have Microsoft Research after all
16:01:05 <nitrix> Is ixset the only viable approach to relational data in Haskell? Decoupling the relation into some kind of indice mechanism?
16:02:49 <EvanR> what about haskelldb
16:03:41 <Clint> viable approach for what
16:04:13 <nitrix> It's less about the existing libraries than knowing how one would tackle the problem in Haskell, as compared to, say, C.
16:04:53 <nitrix> Clint: I'm interested in the situation where multiple pieces of data have to share a common other part of data.
16:06:34 <Clint> so something you would use a relational database for
16:06:46 <dfeuer> nitrix, I wrote the thing. The thing is disgusting. https://github.com/haskell/containers/pull/270
16:07:45 <nitrix> Clint: One could just duplicate the share data everywhere, since lifted values in Haskell means you'll just copy a pointer, not the data in itself, but I'm also interested in the idea of having that shared data mutable.
16:08:19 <nitrix> Clint: Which now obviously makes updating all the instances everywhere out of the question.
16:08:51 <nitrix> My game currently uses a lot of Map lookup tables to solve relations; it's getting tiresome and I'm open to suggestions.
16:09:18 <nitrix> Besides, in C, you'd just share the pointer, access would be O(1), not O(log n).
16:12:15 <zennist> how can I specify class constraint such that - instance type a of ClassA a will not be an instance of ClassB?
16:12:30 <nitrix> dfranke: insertAt isn't doing much nicer with insTree and insNode.
16:12:40 <nitrix> dfeuer*
16:12:49 <zennist> I'm writing instances for a class where, ClassA a all share the same implementation and ClassB all share the same implementation
16:13:14 <zennist> but ghc complains these two instances overlap because it can't know there can't be any type satisfying both ClassA and ClassB
16:14:45 <Koterpillar> zennist: create two proxy types? newtype UseA a = UseA a; newtype UseB b = UseB b; write instances for UseA and UseB
16:15:20 <Koterpillar> zennist: this way, even if someone violates your assumption tomorrow by creating a class implementing both ClassA and ClassB, they'll be forced to choose
16:15:38 <geekosaur> you can't do it with a constraint anyway
16:15:53 <geekosaur> constraints are not considered during instance selection, so they'd overlap no matter what
16:17:18 <zennist> Koterpillar: the thing is that having newtype isn't really an option for me.. because the instances are supposed for existing types where users already work with
16:17:44 <zennist> I'm thinking maybe I can achieve the trickery via Indexed TypeFamily or DefaultSignature
16:18:08 <zennist> with DefaultSignature maybe I just need copy paste that same line for all the concrete types I know
16:18:17 <Koterpillar> what happens if you do implement both classes though?
16:20:09 <zennist> ideally my instance declaration clearly specifies that it applies to 'instance of ClassA', but NOT 'instance of ClassB', vice versa
16:20:24 <zennist> so that when you have a type implementing both, you get no instance
16:21:00 <Koterpillar> unless you didn't import one of them...
16:21:37 <zennist> but as I said, DefaultSig might help me write the same instance for all concrete types - but problem is that I don't think DefaultSig supports multiple signatures
16:33:43 <grumpy_nolrai> So is this the right place to ask about stack hanging on the configure step?
16:34:07 * hackagebot haskell-player 0.1.2.0 - A terminal music player based on afplay  https://hackage.haskell.org/package/haskell-player-0.1.2.0 (potomak)
16:39:51 <pavonia> I'd say so
16:40:00 <geekosaur> if no answer here, try #haskell-stack (smaller but perhaps more dedicated)
16:45:45 <Wizziee> Hi - if I do two combinations on a list - first mapAccum, then filter - then it will take only one pass due to haskell's laziness?
16:46:52 <deech> Does anyone know if Liquid Haskell can produce code that can be distributed and compiled without Z3 etc?
16:48:25 <grumpy_nolrai> deech: At worse you can just compile it without Liquid Haskell iiuc.
16:52:06 <capum> hello
16:53:38 <capum> anyone familiar with rabbitvcs on linux mint?
16:54:09 * hackagebot blosum 0.1.1.2 - BLOSUM generator  https://hackage.haskell.org/package/blosum-0.1.1.2 (GregorySchwartz)
16:54:11 * hackagebot haskell-player 0.1.2.1 - A terminal music player based on afplay  https://hackage.haskell.org/package/haskell-player-0.1.2.1 (potomak)
16:56:10 <Axman6> Wizziee: usually, yes
16:57:16 <Wizziee> thanks ;)
17:02:01 <capum> any forum?
17:03:59 <capum> can't get to work rabbitcs on linux mint!
17:04:30 <dolio> That's off topic in this channel.
17:04:38 <capum> y
17:04:54 <capum> there is no help elsewhere!
17:04:57 <Axman6> this is a channel about the Haskell programming language
17:05:11 <capum> but i am trying to find a venue at least
17:05:14 <Axman6> not a linux mint or rabbitcs support channel
17:05:32 <Axman6> then try a linux/linux mint/rabbitcs related channel
17:06:03 <capum> dude, no one answers, the channel is full of zumbis
17:06:13 <Axman6> @ops
17:06:13 <lambdabot> Maybe you meant: pl oeis docs
17:06:17 <thimoteus> regardless this isn't the right channel
17:06:17 <Axman6> @where ops
17:06:18 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
17:06:42 <capum> are you on linux ?
17:07:05 <capum> what forum has active users?
17:07:14 <Clint> ...
17:07:41 <Koterpillar> capum: no one here knows what rabbitvcs is
17:07:41 <Axman6> urgh, where are the ops >_<
17:07:57 --- mode: ChanServ set +o dolio
17:08:08 <geekosaur> why does this require ops?
17:08:23 <capum> I am asking if you know some good linux forums
17:08:38 <capum> i stopped asking about rabbitvcs 10 minutes ago
17:08:41 <Koterpillar> this isn't a place to ask about linux forums either...
17:08:47 <capum> jesus
17:09:06 <Koterpillar> seriously, try #linux for that
17:09:10 <Cale> How did you end up here? This channel is for discussion of the programming language Haskell.
17:09:14 <Clint> yes, ask about jesus in #linux
17:09:38 --- mode: dolio set -o dolio
17:10:23 <nitrix> Despite the incident; I think some of the reactions observed from a few people of the channel could have been better.
17:10:34 <nitrix> This doesn't require ops in any way.
17:12:57 <monochrom> No, IMO it required ops, and it required ops early and the person should be banned early. Because the person had an entitlement attitude: we owe them just because they couldn't find help elsewhere.
17:13:38 <nitrix> There's no denying that his mindset is wrong; but we can all pass that message to him.
17:14:25 <simpson> Don't worry about it. It's now in the past.
17:20:51 <grumpy_nolrai> So I'm trying to get stack to work on windows, but it keeps hanging on the configure step. I could sworn I read something about what shell I use meaning I have to do something? (sorry for being so vague.)
17:23:10 <nitrix> grumpy_nolrai: Have you tried just using the installer?
17:23:14 <nitrix> grumpy_nolrai: http://docs.haskellstack.org/en/stable/install_and_upgrade/#windows
17:23:55 <nitrix> It doesn't play well with Haskell Platform though.
17:26:54 <grumpy_nolrai> No, stack it self is installed, just when I run it on my project that worked on another machine, it prints "Compress-0.1.0.0"  and just sits there, all night if I let it.
17:29:09 <nitrix> Were the files (including the .stack-work folder) copied from an existing machine?
17:29:39 <grumpy_nolrai> From a git repo.
17:31:01 <nitrix> grumpy_nolrai: Open the file in .stack-work/logs named Compress-0.1.0.0.log
17:31:19 <nitrix> See if there's suspicious in there.
17:31:25 <nitrix> *anything
17:35:55 <erisco> are there any estimates of the number of Haskell users?
17:36:49 <Xnuk> > (1 `id`)
17:36:51 <lambdabot>  1
17:37:02 <Xnuk> > 1 `id` 7
17:37:04 <lambdabot>  1
17:37:56 <jmcarthur> NumInstances is back? It keeps coming and going.
17:37:56 <erisco> that is curious
17:38:12 <jle`> > (sin^2 + cos^2) 10
17:38:13 <jmcarthur> > (sin^2 + cos^2) 3
17:38:14 <lambdabot>  1.0
17:38:15 <lambdabot>  0.9999999999999999
17:38:17 <jle`> lol
17:38:17 <jmcarthur> we got the same idea
17:38:35 <jmcarthur> That example is what NumInstances is best for.
17:38:40 <jmcarthur> Just that one.
17:38:43 <jle`> yup
17:38:46 <geekosaur> every so often someone loads it in
17:39:04 <jmcarthur> Oh, so it's a dynamically loaded thing? That would explain it.
17:39:25 <geekosaur> someone's got a miniature version they @letlpaste
17:39:29 <erisco> it depends on celestial factors
17:39:51 <thimoteus> i read that as functors at first
17:40:15 <erisco> cutting edge research topic
17:41:03 <jmcarthur> In all honesty, the main thing I use NumInstances for is writing point free math formulas on record fields.
17:41:30 <erisco> on SO there are only 28,059 Haskell questions, wow
17:41:59 <jmcarthur> I don't think Haskellers turn to SO as often as average. I'm not entirely sure why.
17:42:04 <erisco> popular languages have about a million questions
17:42:28 <erisco> 0.5m to 1m
17:43:23 <erisco> I am just looking for a way to measure the size of the Haskell user base
17:43:51 <ryantrinkle> jmcarthur: it might be partially because #haskell is so successful :)
17:44:19 <geekosaur> I can imagine people not asking on SO on the theory that not-popular languages wouldn't get an answer
17:44:40 <erisco> to the contrary, Haskell questions are answered readily
17:44:53 <erisco> there are so few of them they get poached
17:44:53 <Koterpillar> ryantrinkle: SO is async, which is a benefit especially if you're in a strange TZ
17:45:03 <jmcarthur> ryantrinkle: I'm not sure about that as an explanation.
17:45:23 <ryantrinkle> Koterpillar: yeah, that definitely makes sense
17:45:32 <geekosaur> I didn't say it was a correct theory, just one people might well hold (which would indicate their cynicism toward SO)
17:45:45 <ryantrinkle> jmcarthur: yeah, maybe not :)
17:45:56 <ryantrinkle> but i've always asked my questions here
17:46:01 <erisco> there are a dozen to two dozen asked a day roughly, though I don't have a graph
17:46:06 <ryantrinkle> there's always enough people that it's quite likely to get a useful conversation
17:46:33 <erisco> well, this channel is 1448 users and as per IRC the majority are idlers
17:46:44 <erisco> logged in on a PC in the closet
17:46:47 <jmcarthur> I think #haskell is great for a short but immediate answer, whereas something like SO is better for a thought out answer with more detail.
17:47:11 <jmcarthur> SO also has the advantage of being more easily searchable.
17:47:17 <scshunt> honestly, I don't trust SO users to know enough about the ridiculous things I'm usually looking for advice on
17:48:21 <jmcarthur> Even if you get some bad answers, I think you're likely to get some good ones.
17:48:28 <nitrix> I'll bite and risk getting laughed at or appear as an elitist, but I just think the crowd Haskell attracts is just less prone to ask others for help. They typically read on the subject and learn on their own with existing resources.
17:48:38 <jmcarthur> Or you just don't get the answer you're looking for, but that's no worse than not asking.
17:49:30 <scshunt> jmcarthur: I suppose that might be.
17:52:12 <jmcarthur> nitrix: I have the same feeling, but the reason I didn't want to vocalize it is because it could have the effect of further disuading people from asking questions for fear of standing out.
17:52:41 <grumpy_nolrai> I used to ask a lot.
17:52:45 <Koterpillar> on the contrary, people like *answering* questions, so it's a win
17:53:04 <grumpy_nolrai> Yeah, its fun, makes you feel smart.
17:53:27 <jmcarthur> I love teaching, but not because it makes me feel smart.
17:53:48 <jmcarthur> The game I like to play is to make the learner appear as smart as possible.
17:53:57 <jmcarthur> I win if they learn it faster than I did.
17:54:05 <thimoteus> i only ask questions if i've spent way too much time trying to figure it out myself with no progress
17:55:37 <nitrix> jmcarthur: I don't mean it in a bad way; more in the lines that they can distinguish between "I don't know enough yet" problems vs. a "I've learned about it and it doesn't doesn't work intuitively" problems.
17:55:52 <nitrix> jmcarthur: Even this classification is loose, but I hope you see the point.
17:56:06 <jmcarthur> nitrix: I know you don't mean badly. Sorry if it seemed like I could have meant it that way.
17:56:44 <nitrix> jmcarthur: Even when they come here, you feel like users have actually tried tried things and they are capable of exposing their problem clearly.
17:57:04 <jmcarthur> nitrix: Reading back over what I said, now I feel like I should clarify that I didn't even mean to imply that I thought it was a mistake to bring it up.
17:57:13 <nitrix> #haskell-beginners is the exception where a lot of (long) teaching sessions happens.
17:57:37 <nitrix> Nah, the subject is fine. I've asked myself that question a few times :)
17:59:19 <nitrix> grumpy_nolrai: By the way, have you figured the hanging on Compress?
18:01:47 <jmcarthur> I've had a lot of experience teaching people in real like some high level concepts that come up often in functional programming, and I think most people are able to learn this stuff but are just not sure it would be worth the effort.
18:02:34 <erisco> takes a long time to integrate it into your everyday thinking
18:02:52 <erisco> then it overwhelms and destroys you
18:03:49 <jmcarthur> There is a pragmatic kind of laziness (I can't think of a more positive word even though I don't mean it negatively) that some people have. It's true that you can get more done when you're not researching tons of things having dubious value.
18:04:08 <cannibalbob> it prevents you from ever being happy working with java again
18:04:17 <jmcarthur> And there's that.
18:04:31 <erisco> you're not building products when you're out learning new theories and technologies
18:04:43 <jmcarthur> I've kind of come full circle on mainstream languages.
18:05:05 <jmcarthur> I think I'd be fine working with Java again, but only if I'm working on it with a bunch of FPers at my side.
18:05:20 <cannibalbob> yea, i am still only halfway around the circle
18:05:27 <erisco> it is the local maxima of production, where stopping to learn new approaches goes downhill
18:06:00 <erisco> jmcarthur, what stage of grieving is that again? acceptance?
18:07:42 <jmcarthur> erisco: Early stages of acceptance, perhaps.
18:08:30 <jmcarthur> They say the grass is always greener on the other side, but that doesn't seem to apply to programming languages at all. I wonder why that is.
18:08:44 <erisco> status quo is a comfortable place
18:10:03 <nitrix> jmcarthur: Afaik, C.S. is always about trade-offs.
18:10:18 <jmcarthur> erisco: Actually, I don't fall anywhere in the stages of grief, since I don't have to write Java anyway.
18:11:44 <erisco> nitrix, the engineering of software is certainly about trade-offs
18:12:06 <erisco> you can't fix all problems
18:19:12 * hackagebot hpio 0.8.0.1 - Monads for GPIO in Haskell  https://hackage.haskell.org/package/hpio-0.8.0.1 (dhess)
18:44:37 <erisco> you're not having fun until UndecidableInstances is on
19:04:00 <erisco> closed type classes would be so coooool
19:04:28 <erisco> the biggest bummer to type families is you can't give an implementation
19:05:04 <hpc> perhaps you want data families?
19:05:23 <hpc> or a GADT
19:07:04 <erisco> I don't understand data families
19:08:15 <erisco> the problem is that type classes are not closed
19:08:27 <erisco> so in a type family you can give an order to the pattern matching
19:08:41 <erisco> this means that previous patterns must not have matched
19:08:48 <erisco> whereas with class instances you cannot do this
19:08:51 <dfeuer> erisco, want to see some incredibly ugly code?
19:09:04 <erisco> if you have a catch-all, for example, this instance is matched everywhere
19:09:16 <hpc> type families aren't ordered
19:09:24 <erisco> yes they are, the closed ones are
19:09:41 <erisco> a catch-all at the end of a closed type family only matches if all the previous patterns do not
19:09:56 <dfeuer> As erisco says. But that doesn't, unfortunately, quite give you what you'd get from an ordered (closed) list of overlapping instances, because GHC is much more paranoid about type safety than about coherence.
19:10:08 <hpc> oh, it's new
19:10:18 <hpc> last time i checked closed type families didn't exist
19:10:20 <erisco> not that new
19:10:37 <erisco> a 7.8 feature iirc
19:10:40 <dfeuer> hpc, it's certainly been around since 7.8. Not sure about 7.6.
19:11:51 <erisco> this is the idea here
19:12:36 <erisco> I can define the type family to give me the type I want, but I can't define the implementation
19:12:48 <hpc> i last gave it a thorough reading during 7.4
19:13:16 <hpc> though it seems i have 7.10 installed here so not sure how i didn't discover it sooner
19:13:42 <erisco> Unpack curries all the tuples in a function's arguments
19:13:53 <erisco> I mean Unpacked does, at the type level
19:14:04 <erisco> then the implementation should be quite similar, but… D:
19:15:39 <erisco> hm, the only extensions needed are typefamilies and undecidableinstances… I was mucking around
19:17:30 <erisco> how neato burrito would that be to have working… (I have a really cool use case for it)
19:23:27 <erisco> mm… if I remember, I think people tag values to work around this
19:23:47 <Ohso_> Question about unboxed arrays:   If I create an array but fails to specify values for all the indices, they values seem to be zeroed, but I can't find anywhere in documentation that say this necessarily happens. Is this something that can be relied upon? What if a type doesn't have zero as a legal value?
19:25:39 <Axman6> Ohso_: I would guess the result is undefined
19:26:25 <Ohso_> That's annoying, that means there's no way to validate whether or not someone actually populated the values.
19:27:06 <Ohso_> an error would make more sense than picking an arbitrary value
19:27:46 <erisco> zeroing is expensive
19:32:42 <Ohso_> Just tried with an array of Char and unspecified elements end up with \\NUL
19:41:54 <dfeuer> How can I figure out how much of my code is being touched by the QuickCheck tests?
19:44:36 <glguy> ?google haskell coverage
19:44:36 <lambdabot> https://wiki.haskell.org/Haskell_program_coverage
19:48:53 <dfeuer> glguy, that says CPP is a problem. Do you know if that's the case? containers uses CPP pretty heavily.
19:49:00 <dfeuer> *still the case
19:49:17 * hackagebot stripe-core 2.1.0 - Stripe API for Haskell - Pure Core  https://hackage.haskell.org/package/stripe-core-2.1.0 (DavidJohnson)
19:49:19 * hackagebot stripe-haskell 2.1.0 - Stripe API for Haskell  https://hackage.haskell.org/package/stripe-haskell-2.1.0 (DavidJohnson)
19:49:21 * hackagebot stripe-http-streams 2.1.0 - Stripe API for Haskell - http-streams backend  https://hackage.haskell.org/package/stripe-http-streams-2.1.0 (DavidJohnson)
19:49:45 <glguy> dfeuer: I imagine that you'll still have to make use of the work around listed in that section of the wiki
19:50:31 <dfeuer> glguy, that's rather .... tricky .... when the test suite is all cabalified, no?
19:50:53 <glguy> Could be, but hpc is how you do program coverage of Haskell programs
19:51:03 <dfeuer> Thanks.
19:51:12 <dfeuer> It looks lovely, aside from that one huge caveat.
19:52:02 <dfeuer> glguy, it looks like that info may be out of date: https://ghc.haskell.org/trac/ghc/ticket/3376
19:52:12 <dfeuer> I'll have to try and see.
19:55:55 <erisco> lol, I have it working with tagging
19:56:45 <sebleblanc> I need to split a non-infinite list into n lists of every nth member, each list offset by 1... [a] -> Int/Integer -> [[a]]; my use case is a buffer of interleaved audio samples, e.g. even frames are left, odd frames are right
19:57:30 <sebleblanc> I can do it with drop and take, but I cannot figure out how to make it work with an arbitrary number of "channels"
19:57:31 <dfeuer> erisco, eh?
19:57:58 <erisco> to impose an ordering you can tag the types (with other types)
19:58:26 <erisco> this becomes insanely more complicated but…
19:58:50 <glguy> > let deinterleave n = transpose . chunksOf n in deinterleave 3 [1..12]
19:58:52 <lambdabot>  [[1,4,7,10],[2,5,8,11],[3,6,9,12]]
19:58:53 <dfeuer> erisco, what are you trying to do?
19:59:02 <erisco> nothing now, I already did it
19:59:05 <dfeuer> Oh.
19:59:35 <glguy> sebleblanc: ^
20:00:04 <byorgey> > let deinterleave n = transpose . chunksOf n in deinterleave 3 ([1..10] ++ undefined)  -- let's see how lazy it is
20:00:05 <sebleblanc> glguy, wow; I can't find chunksOf outside of Data.Text, though
20:00:06 <lambdabot>  [[1,4,7,10*Exception: Prelude.undefined
20:00:09 <erisco> it curries all the tuples in a function's arguments
20:00:45 <byorgey> > let deinterleave n = transpose . chunksOf n in deinterleave 3 ([1..10] ++ undefined) !! 1
20:00:47 <dfeuer> sebleblanc, Data.List.Split.
20:00:48 <lambdabot>  [2,5,8*Exception: Prelude.undefined
20:00:51 <byorgey> looks OK
20:01:10 <glguy> byorgey: yeah, transpose is pretty lazy :)
20:01:15 <dfeuer> sebleblanc, and in the next major version of containers, there will also be Data.Sequence.chunksOf
20:01:18 <byorgey> yep, nice =)
20:01:57 <dfeuer> transpose is ugly :(
20:02:08 <dfeuer> I think.
20:02:12 <byorgey> sebleblanc: Data.List.Split is in the 'split' package
20:02:13 <shachaf> @where pi_10
20:02:13 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
20:02:20 <sebleblanc> byorgey, yes, found it
20:02:21 <dfeuer> I can't make it make sense unless all the lists are the same length.
20:02:28 <sebleblanc> byorgey, nice intro, on the package's page
20:02:37 <dfeuer> Which means they should really be dependent vectors.
20:02:43 <byorgey> =)
20:03:37 <dfeuer> byorgey, I hope you don't mind that I stole your chunksOf function for Data.Sequence :)
20:04:29 <byorgey> dfeuer: not at all =)
20:04:39 <byorgey> dfeuer: you see, I stole it from someone else =)
20:05:01 <byorgey> (don't recall who... maybe Lennart Augustsson?)
20:05:38 <dfeuer> Heh! Well, I didn't steal the implementation at least. Although I *did* steal one from lens to make Data.IntMap.Lazy.alterF, because there's no need to do anything complicated like Data.Map.Lazy.alterF.
20:07:58 <dfeuer> Any QuickCheck masters here? I'm trying to figure out if PropertyM will be useful for my porpoises.
20:08:15 <dfeuer> Specifically, I'm interested in the most boring incarnation: PropertyM Identity.
20:08:35 <dfeuer> Which *looks* like it can be a sort of "informative Maybe".
20:09:53 <dfeuer> Good gosh, this stuff is awful.
20:10:24 <dfeuer> I just added deleteAt to Data.Sequence, and it's a giant blob of utterly disgusting code.
20:11:29 <c_wraith> Is it more efficient than a split, an uncons, and a merge?
20:12:24 <mniip> mmmm
20:12:27 <mniip> category of linear spaces
20:13:07 <dfeuer> c_wraith, several times as fast for long sequences.
20:13:52 <dfeuer> Well, that's for good cases, anyway. But a lot of cases will be good. 
20:14:13 <dfeuer> Once the defect is repaired, it doesn't have to stray from the access path.
20:14:22 <dfeuer> So that should also enhance sharing a good bit.
20:16:51 <dfeuer> A lot of cases will be good because even if 2-nodes and 3-nodes occurred with equal frequency, it's likely that a 3-node will occur sometime soon. And in fact sequence operations generally try to make as many of the node 3-nodes as possible.
20:17:09 <dfeuer> So lots of sequences will be very 3-heavy.
20:22:11 <dfeuer> c_wraith, know what I mean?
20:31:19 <dfeuer> SO BORING.
20:33:02 <dfeuer> My fingers are getting sore writing this code.
20:33:06 <dfeuer> It's awful.
20:33:38 <dfeuer> But it would take many times longer to attempt to figure out how to automate the process.
20:33:49 <peddie> dfeuer: last time I wrote finger tree code, I just generated a lot of bits, it wasn't that bad
20:34:04 <dfeuer> peddie, what do you mean?
20:34:09 <dfeuer> How did you do it?
20:34:13 <sebleblanc> dfeuer, such a martyr
20:34:36 <peddie> just hacky string concatenation, sadly :/
20:35:19 <dfeuer> peddie, I'm not very good at that. Moreover, there are all sorts of little decisions to make about how to calculate the sizes. I could probably formalize the patterns, but by then I could've been long since done....
20:35:19 <peddie> I don't know whether your problem is a lot of repetitive code or not a lot of really complex code, though
20:35:37 <dfeuer> Repetitive, but not all in the same ways.
20:35:38 <peddie> ok, fair enough
20:35:42 <dfeuer> I guess? 
20:35:49 <peddie> well, good luck then
20:35:54 <dfeuer> I'm sure someone better at this could figure out the patterns.
20:36:48 <dfeuer> peddie, even just "do the same thing on the right as on the left, only backwards" seems a bit messy. And sometimes you want to do something subtly different to influence tree balance.
20:37:09 <dfeuer> *barf*
20:38:47 <peddie> hm, yeah, I was generating all the different cases for "how full are these edge nodes", but it gets annoying if you want to tune the way each case works for balance as well
20:39:02 <erisco> I did it :DDDDD
20:39:34 <dfeuer> peddie, well, I'm done with that bit, I think. But I want to make sure I inspect as few nodes as possible to get the measurements. Would you like to look at the code in a few minutes and tell me how you suggest I improve it?
20:40:00 <peddie> oh man, haha, I can try, but not promising I can contribute much (or even understand it)
20:40:39 <dfeuer> It's very possible/likely that there's some nicer way.
20:41:14 <peddie> if you stick it up somewhere, I can see whether anything comes to mind . . . 
20:41:36 <dfeuer> peddie, I want to finish making it more eager; then I'll put it up.
20:42:03 <peddie> ok, I only have a few minutes, but I'll see how far I get :)
20:42:25 <shapr> @quote
20:42:25 <lambdabot> Nimatek says: People shouldn't be able to add two and two in Haskell without knowing monoids!
20:56:30 <JordiGH> Why does this work? let x = 2 + 2 where 2 + 2 = 5
20:57:28 <Koterpillar> JordiGH: you are redefining '+'
20:57:38 <peddie> JordiGH: you're defining a new function `+` with one case, the 2+2 case, then calling it
20:57:48 <Koterpillar> JordiGH: try this: let 2 + 2 = 5; and then try adding things
20:57:59 <JordiGH> I see.
20:58:27 <JordiGH> *** Exception: <interactive>:6:5-13: Non-exhaustive patterns in function +
20:58:28 <JordiGH> Aha.
21:00:37 <dfeuer> peddie, if you're still there, https://github.com/treeowl/containers/blob/seq-delete-cleanup/Data/Sequence.hs#L1842
21:04:27 <dfeuer> peddie?
21:05:30 <peddie> dfeuer: hey sorry, taking a look right now
21:05:35 <dfeuer> Thanks.
21:05:40 <peddie> I see what you mean
21:05:49 <dfeuer> It's disgusting.
21:07:00 <peddie> not a suggestion, but why do you force the int you don't use in `delTreeE`?
21:07:42 <dfeuer> peddie, just my general practice of forcing primitive arguments I don't use.
21:07:49 <dfeuer> I could benchmark both ways.
21:08:21 <peddie> in my naive understanding, it seems like it couldn't possibly help if you don't use it, but I would be curious to hear if it helps!
21:08:41 <dfeuer> Good question, and you may very well be right!
21:09:20 * hackagebot octane 0.5.3 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.3 (fozworth)
21:11:46 <EvanR> @hoogle b -> ([a] -> b) -> [a] -> b
21:11:48 <lambdabot> No results found
21:11:58 <EvanR> fromMaybe for lists?
21:12:11 <Koterpillar> EvanR: const id
21:12:14 <peddie> dfeuer: it seems like maybe some sub-cases are duplicated in delNode, like you could do Defect e -> someFunction e?
21:12:25 <EvanR> > const id [1,2,3]
21:12:27 <lambdabot>      No instance for (Typeable a0)
21:12:27 <lambdabot>        arising from a use of ‘show_M67445311530666774101986’
21:12:27 <lambdabot>      In the expression:
21:12:31 <peddie> possibly with a few more arguments
21:12:44 <dfeuer> peddie, I'll check. This seems quite possible.
21:12:59 <peddie> but in general most of the stuff is as annoying as I remember, with lots of different patterns for the different node sizes and digit sizes . . . :)
21:13:02 <Koterpillar> EvanR: const id :: b -> ([a] -> b) -> [a] -> b
21:13:09 <dfeuer> I guess I could go whole-hog and restructure the way I did splitAt, but this is ... worse.
21:13:29 <EvanR> > const id 3 length [1,2,3,4]
21:13:31 <lambdabot>  4
21:13:45 <EvanR> > const id 3 length []
21:13:48 <lambdabot>  0
21:13:56 <EvanR> hmm.
21:14:09 <Koterpillar> that's what I meant
21:14:10 <glguy> ?type \z f xs -> maybe z f (NE.nonEmpty xs) -- maybe you're looking for something like this
21:14:12 <lambdabot> b -> (NE.NonEmpty a -> b) -> [a] -> b
21:14:27 <dfeuer> splitAt I could wrap my mind around what was going to happen to the results; here ... I wrote the code, but I can only understand one piece at a time :P
21:15:09 <EvanR> yeah
21:15:29 <peddie> boy, this module doesn't make you feel good about functional style saving you lines of code, haha
21:18:17 <peddie> dfeuer: I had some suggestions about delDigit, but it turns out you can't deduplicate a lot of the stuff because you get the elements out of the top-level pattern match . . . it seems like there should be a better way, but I can't put my finger on it
21:18:39 <dfeuer> peddie, I could put the whole thing in a giant case expression....
21:19:29 <peddie> actually it might not be as bad as I thought
21:19:42 <peddie> I think you could deduplicate a lot of the Defect cases with a top-level `where`
21:20:59 <peddie> so pattern-match on the actual argument in a `go` or whatever and then make some helpers that do the case for choosing Node3 or Node2
21:22:09 <dfeuer> I'll have to look at it tomorrow, probably. But yeah, that generally sounds like a good idea.
21:22:28 <peddie> I don't have time to rewrite it right now; possibly tonight . . .
21:22:52 <dfeuer> Tomorrow, however, I have to apply for an internship I won't get.
21:23:00 <peddie> why apply?
21:23:04 <dfeuer> Well, maybe that's too pessimistic.
21:23:22 <peddie> in that case, best of luck :D
21:23:43 <dfeuer> @ops TheCreepyPickle is PM spamming.
21:23:43 <lambdabot> Maybe you meant: pl oeis docs
21:23:48 <dfeuer> @ops
21:23:48 <lambdabot> Maybe you meant: pl oeis docs
21:23:50 <dfeuer> rmmm
21:23:52 <EvanR> best way to say that everything in a list is equal?
21:23:59 <dfeuer> How do you ask for ops here again?
21:24:23 <EvanR> .oO what are ops here supposed to do about PM spam
21:24:49 <dfeuer> EvanR, ban it from the channel.
21:25:04 <EvanR> to stop the PM?
21:25:19 <Koterpillar> >  :type \ls -> and $ map (uncurry (==)) $ zip ls (tail ls)
21:25:20 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:25:22 <dfeuer> To stop it from pulling the list of users in the channel to use as PM targets.
21:25:28 <Koterpillar> ?type \ls -> and $ map (uncurry (==)) $ zip ls (tail ls)
21:25:29 <EvanR> good point
21:25:30 <lambdabot> Eq a => [a] -> Bool
21:25:41 --- mode: ChanServ set +o glguy
21:25:42 --- mode: glguy set +b *!*@IRCop.com
21:25:42 --- kick: TheCreepyPickle was kicked by glguy (TheCreepyPickle)
21:26:18 <EvanR> Koterpillar: whoa...
21:26:31 <dfeuer> Thanks.
21:26:49 <Koterpillar> EvanR: I have no idea if that's the best way; it seems efficient
21:27:03 <EvanR> Koterpillar: i mean, what do you call this situation
21:31:25 --- mode: glguy set -o glguy
21:42:55 <EvanR> :t foldl
21:42:57 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
21:44:07 <dfeuer> EvanR, there should be a version of Foldable for type-aligned sequences, folding up to a Category.
21:44:30 <EvanR> type aligned sequence?
21:45:18 <dfeuer> Things like  data TList c x y where Nil :: TList c x x; Cons :: c x y -> TList c y z -> TList c x z
21:45:47 <EvanR> mkay
21:46:06 <dfeuer> These support an operation like foldMap that uses (.) and id instead of (<>) and mempty.
21:46:20 <EvanR> yeah
21:46:39 <EvanR> time to burn more bridges
21:46:44 <dfeuer> Haaaahahahahaha.
21:46:46 <dfeuer> No.
21:47:01 <dfeuer> But what's the status of MonadFail?
21:50:44 <scshunt> dfeuer: on its way in
21:50:55 <dfeuer> scshunt, great.
21:53:13 <peddie> dfeuer: I lied, I'm trying to rewrite it now . . . 
21:53:20 <dfeuer> :P
21:53:47 <dfeuer> peddie, I just pushed a minor update.
21:53:58 <dfeuer> But if you're doing a big restructure, I'll layer on top.
21:53:59 <peddie> oops
21:54:00 <peddie> ok
21:54:04 <peddie> no, it's not big
21:54:05 <peddie> well
21:54:11 <peddie> it might be, but let's not worry about it
21:54:15 <dfeuer> No, really, I didn't do anything interesting.
21:54:18 <peddie> I'll just put up a diff if it works out
21:54:25 <dfeuer> Go ahead and do what you like.
21:54:32 <dfeuer> Thanks!
21:54:42 <dfeuer> If you can make it faster at the same time, that would be even cooler :P
21:54:59 <peddie> lol, don't hold your breath
21:55:18 <peddie> it just bugs me because it seems like it should be able to clean it up, but it's not clear how
21:55:32 <dfeuer> Hey, I restructured and strictified splitAt and got a pretty impressive performance boost.....
21:56:27 <dfeuer> Maybe you'll do the same here. We'll see.
21:56:44 <dfeuer> You're welcome to review insertAt while you're at it, but that's not *nearly* as nasty.
21:57:01 <peddie> I'm not even sure that I'm going to be able to save code yet :)
21:57:38 <dfeuer> Well, if you make it longer *and faster*, I'll take that too ...
21:58:24 <peddie> haha
21:59:22 * hackagebot haskell-player 0.1.3.0 - A terminal music player based on afplay  https://hackage.haskell.org/package/haskell-player-0.1.3.0 (potomak)
21:59:24 * hackagebot haskell-player 0.1.3.1 - A terminal music player based on afplay  https://hackage.haskell.org/package/haskell-player-0.1.3.1 (potomak)
22:00:52 <dfeuer> I'm pretty sure it could be sped up by splitting out *yet another* level from the top of the tree, and using strict versions of the Del types below that. But ew.
22:05:15 <dfeuer> peddie, what sorts of work were you doing with finger trees anyway? I'm curious now.
22:07:42 <peddie> dfeuer: oh, nothing complicated -- it's just that if you want something optimized for performance, as far as I know, Haskell doesn't have a way to let you write the structure once and properly unbox where applicable, so you end up having to write your own specialised version for every type you want to unbox
22:07:44 <dfeuer> Ahahaha, I got the insertion and deletion functions interleaved. I'll have to deal with that before the next release!
22:07:54 <peddie> dfeuer: I was doing interval trees
22:08:15 <dfeuer> I've never learned about those :/
22:09:00 <peddie> it's an example application in the Hinze and Paterson paper on finger trees, it's not complicated -- I just had schedules with "windows" that might overlap and had to do operations on them
22:09:03 <dfeuer> You can play some tricks with generics and Template Haskell and things, but yeah, unboxed is painful.
22:09:21 <dfeuer> *nod*
22:09:23 <peddie> but the reason I had to write my own is to get unboxing for different indices
22:09:46 <peddie> yeah, it's kind of annoying, but the alternative is to go the C++ route and just generate assloads of code, so . . .
22:10:23 <dfeuer> Generating assloads of code is better than *writing* assloads of code.....
22:10:53 <peddie> well, that's a good point.
22:11:18 <dfeuer> I need to get ready for bed.
22:11:31 <dfeuer> Open an issue or pull request if you come up with anything, and thanks again.
22:11:39 <peddie> yeah, I'll see how it ends up
22:11:43 <peddie> thanks for the fun problem
22:11:51 <peddie> always interesting to try to write cleaner code
22:12:00 <dfeuer> *nod*
22:12:14 <peddie> good luck with the interview
22:12:18 <dfeuer> I'm glad I managed to implement insertAt and deletAt at all.
22:12:22 <dfeuer> *application
22:12:27 <dfeuer> Thanks.
22:12:32 <peddie> oh right
22:12:50 <dfeuer> I wasn't sure if there *was* a way to write them better than splitting and appending.
22:12:58 <peddie> yeah, it's cool!
22:13:09 <peddie> I haven't even grokked the whole thing yet
22:13:12 <dfeuer> It's just classic 2-3 tree insertion/deletion.
22:13:16 <peddie> just enough to try to reduce this one function
22:13:19 <dfeuer> But with the horrors of nested types.
22:13:34 <dfeuer> And some fiddling with digits.
22:13:48 <peddie> is there anything special you do to be able to install the cabal packages to test and benchmark?
22:13:55 <peddie> for some reason I'm getting version complaints from the solver
22:14:03 <dfeuer> Hrmmm...
22:14:27 <peddie> OK, if not, don't sweat it; I'll work it out
22:14:27 <dfeuer> I don't know about the cabal benchmark integration. That was just added. You can cd to the benchmarks directory and run make bench-Sequence
22:14:37 <peddie> ok
22:15:12 <dfeuer> But if there's a problem with said benchmark integration, we should try to fix it. I ran into a complaint too, about not having the right version of criterion or something. Hrmmmm.
22:15:42 <dfeuer> Gabriel Gonzalez did that stuff; I really don't know anything about cabal benchmark stuff.
22:16:02 <peddie> it's pretty easy, I think it's just like the test suites where you tell it the name of a program to run
22:16:35 <dfeuer> Yeah, that's what it looks like. Just need to get versions matched up and all.
22:16:58 <dfeuer> Oh, when running benchmarks, I highly recommend killall -STOP firefox plugin-container, or the equivalent for your browser
22:17:08 <peddie> ?
22:17:11 <dfeuer> Then killall -CONT firefox plugin-container after.
22:17:16 <peddie> I haven't got flash on this machine . . .
22:17:22 <dfeuer> Ah.
22:17:27 <dfeuer> Then skip the plugin-container.
22:17:40 <dfeuer> But STOP whatever's your own CPU/memory hog.
22:17:48 <peddie> chrome ;)
22:17:57 <peddie> it's appalling
22:18:01 <peddie> thanks for the tip
22:18:07 <dfeuer> That can have a big impact on the benchmarks.
22:18:31 <peddie> I'd imagine
22:18:36 <dfeuer> NIGHT.
22:18:50 <peddie> ADIOS.
22:19:23 * hackagebot rasterific-svg 0.3.1.2 - SVG renderer based on Rasterific.  https://hackage.haskell.org/package/rasterific-svg-0.3.1.2 (VincentBerthoux)
22:59:25 * hackagebot asciidiagram 1.3.1.1 - Pretty rendering of Ascii diagram into svg or png.  https://hackage.haskell.org/package/asciidiagram-1.3.1.1 (VincentBerthoux)
23:02:08 <adam1> does haskell have transducers like clojure?
23:07:39 <Koterpillar> adam1: found this: http://conscientiousprogrammer.com/blog/2014/08/07/understanding-cloure-transducers-through-types/
23:09:12 <lambda-11235> How do I get the most versions of a package using cabal. cabal info shows "and x others" in the versions field. 
23:09:17 <EvanR> adam1: theres nothing called transducers
23:09:53 <EvanR> but depending on what transducers can do, they can be done in haskell
23:13:00 <simpson> Transducers are just a kind of fold.
23:14:26 * hackagebot hylogen 0.1.2.1 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.2.1 (sleexyz)
23:49:28 * hackagebot wai-make-assets 0.1.1 - Compiling and serving assets  https://hackage.haskell.org/package/wai-make-assets-0.1.1 (SoenkeHahn)
