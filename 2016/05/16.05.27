00:01:12 <johnw> or, (Source -> Interpreted) -> Binary... you give me an interpreter, and I'll use it to produce a binary by reflection on the interpreted result instead of the source code
00:01:21 <bollu> hmm
00:01:59 <johnw> it's such a vastly general notion that it's been said that all concepts in the end are kan extensions :)
00:02:13 <bollu> I see
00:02:37 <bollu> johnw: are there any topological / algebraic / analysis examples you can give me of kan extensions? :)
00:02:48 <johnw> no, sorry, I'm not a mathematician of any form
00:02:52 <bollu> johnw: and this is not a "kan extension along itself" right?
00:02:58 <bollu> johnw: ah, no problem!
00:03:10 <johnw> kan extension along itself would be (a -> b) -> b
00:03:18 <bollu> johnw: what's an example of a pair of functions that forms a kan extension  along itself?
00:03:41 <bollu> johnw: um, can I please have an example that's a little more in depth?
00:03:43 <johnw> btw, up above I should have said "let's take the example where the functors are all the identity functor"
00:04:39 <bollu> johnw: how so?
00:04:48 <johnw> (a -> f r) -> f r
00:04:59 <bollu> johnw: and when we say we are extending along itself, according to my notation above, we mean that C' = C right
00:04:59 <bollu> ?
00:04:59 <johnw> if f is the identity (the real one), then you can Ran Id Id, or (a -> r) -> r
00:05:12 <bollu> so we extend "along an endofunctor"?
00:05:32 <johnw> it's not C = C'
00:05:37 <johnw> it's that the functors are the same
00:05:48 <johnw> Ran F and F
00:06:26 <johnw> oh, wait
00:06:33 <johnw> I think you maybe right about C = C'
00:10:25 <bollu> johnw: any help with the kan extension along itself? :)
00:10:39 <johnw> i'm not quite sure what you're looking for, particularly
00:11:47 <bollu> johnw: I was hoping for the explanation of Codensity as a kan extension along itself of <some functor>
00:11:47 <johnw> why does "along itself" wreck the intuition?
00:11:58 <johnw> Codensity is forall r. (a -> f r) -> f r
00:12:04 <johnw> which is exactly Ran f f
00:12:14 <johnw> or the right kan extension of f along itself
00:13:59 <bollu> johnw: how did you characterise codensity that way? The way I look at codensity is Codensity f = {forall x. (f x, x -> a) } right?
00:14:14 <bollu> as in, I have a functor'd object that is existential
00:14:22 <bollu> and a way to "bring it down" to the correct type a
00:14:23 <johnw> where did you find that?
00:14:30 <bollu> Codensity f a = {forall x. (f x, x -> a) } right?
00:14:37 <johnw> not the one that I know
00:14:47 <bollu> that was the way codensity was explained to me? That way, you can use the Codensity to avoid an expensive fmap
00:14:50 <bollu> rather than fmapping on the f x
00:15:00 <bollu> you can fmap on the (x -> a) to get (x -> b)
00:15:06 <bollu> and then you can "lower" your codensity
00:15:09 <bollu> to get f b
00:15:18 <bollu> so it acts as a way to improve functor performance
00:15:31 <johnw> that's left kan extension
00:15:51 <bollu> johnw: how so?
00:15:55 <johnw> see http://comonad.com/reader/2008/kan-extensions/
00:16:27 <bollu> johnw: ooh, thanks :)
00:16:39 <johnw> btw, I'm used to seeing that called Coyoneda
00:16:51 <akfp``> rackspace indicates that services are fine.  why is hackage down still?
00:17:03 <johnw> akfp``: let's ping #haskell-infrastructure
00:17:05 <bollu> johnw: oh, crap, right
00:17:19 <bollu> johnw: I confused codensity and coyoneda >_<
00:17:29 <bollu> johnw: okay, so, coyoneda has no relationship to kan extensions?
00:17:36 <bollu> i thought there was some relationship between coyoneda and density?
00:17:43 <bollu> some kind of an adjoint relationship?
00:17:45 <johnw> Coyoneda is left kan of f along identity
00:18:03 <johnw> Codensity is right kan of f along itself
00:18:19 <johnw> Yoneda is right kan of f along identity
00:18:21 <bollu> johnw: what's the left kan extension like?
00:18:22 <bollu> in terms of categories
00:18:44 <johnw> it completes the triangle by pulling in the reverse direction
00:18:58 <johnw> pretty pictures here: https://en.wikipedia.org/wiki/Kan_extension
00:19:09 <johnw> the arrows are all flipped, as its dual
00:19:10 <bollu> given C -> D, C -> C', it pulls D -> C'?
00:19:55 <johnw> ah, finally found that article: given C <- D, C' <- C, it pulls D -> C'
00:19:57 <johnw> https://www.quora.com/What-is-a-laymans-explanation-of-Kan-extensions
00:20:04 <johnw> one sec, confirming category arrows
00:20:07 <bollu> so, right kan extension: C -> D, C -> C' gives C' -> D. So left kan extension is given D -> C, C' -> C, it pulls D -> C
00:20:14 <bollu> D -> C'*
00:20:52 <bollu> I guess a left kan extension is like "embedding"
00:21:02 <bollu> a functor from C' -> C is like an embedding of C' in C
00:21:20 <lpaste> magthe pasted “Haddock bug?” at http://lpaste.net/164625
00:21:21 <bollu> and hence, we use D -> C to find the "embedded" functor D -> C'?
00:22:07 <magthe> Any ideas as to what might case this? http://lpaste.net/164625
00:22:12 <bollu> is that interpretation okay?
00:22:18 <johnw> still checking
00:24:00 <johnw> bollu: i'm getting too tired, I recommend you to read http://everything.explained.today/Kan_extension/
00:24:04 <johnw> sorry, I mean
00:24:09 <johnw> www.math.harvard.edu/theses/senior/lehner/lehner.pdf
00:25:18 <bollu> johnw: okay, thanks! It looks like the direction of the natural transformation changes :)
00:25:26 <johnw> yes
00:25:50 <magthe> hackage seems to no be co-operating today :(
00:26:43 <thimoteus> magthe: https://redd.it/4l8wi6
00:27:09 <reptar_> how do i make an infinite list with a certain type?
00:27:18 <Cale> https://status.haskell.org/
00:27:48 <reptar_> newtype Something = Something Int
00:27:48 <bollu> reptar_: use Stream?
00:27:52 <magthe> thimoteus: ah, thanks :)
00:28:04 <johnw> bollu: there's something else about the flip, because you go from (a -> f r) -> g r, to (g r, f r -> a), or something similar
00:28:05 <reptar_> and i want [Something 1..]
00:28:21 <Cale> map Something [1..]
00:28:35 <reptar_> Cale, thanks!
00:29:02 <bollu> johnw: hm, all right. I'll take a look :)
00:29:14 <bollu> Cale: can I have examples of kan extension is some toplogical / algebraic context?
00:29:30 <johnw> Cale is a good person to ask, I'll leave this to him now :)
00:29:52 <bollu> johnw: thanks for all the help so far :D
00:30:04 <reptar_> No instance for (Show Something) arising from a use of `print'
00:30:33 <Cale> I don't really know a whole lot about Kan extensions, tbh.
00:31:10 <bollu> Cale: oh, hm. It seems to be one of those "folklore" topics with mysticism and all
00:31:24 <johnw> bollu: the lehner paper should help a lot
00:31:29 <bollu> Cale: okay, um, what about the relationship between Codensity and the Kan extension?
00:32:12 <Cale> Well, you can figure that out just by looking at the definition, no?
00:32:46 <Cale> I would link you to hackage, but it's down :P
00:32:46 <bollu> Cale: I'm trying to, but I'm not really able to imagine "Kan extension along itself
00:32:56 <bollu> and hackage is down to take a closer look
00:33:02 <bollu> yeah :P
00:33:33 <johnw> tonight is when I love my local Hoogle
00:33:39 <brujoand_> I cant update cabal aganst hackage.haskell.org. Just me or is there a struggle somewhere?
00:33:48 <johnw> does stack build such a thing?
00:35:00 <Cale> newtype Ran g h a = Ran { runRan :: forall b. (a -> g b) -> h b }
00:35:11 <Cale> newtype Codensity m a = Codensity { runCodensity :: forall b. (a -> m b) -> m b }
00:35:26 <liste> reptar_: you need to have a "deriving (Show)" for your Something
00:35:41 <liste> data Something = Something Int deriving (Show)
00:35:46 <reptar_> liste, ah, ok
00:35:55 <reptar_> getting this error a lot, thanks!
00:48:34 <oherrala> brujoand_: https://www.reddit.com/r/haskell/comments/4l8wi6/hackage_downtime/
00:51:25 <brujoand_> oherrala: thanks
01:09:28 <zq> ghci
01:37:44 * hackagebot jsaddle 0.4.0.1 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.4.0.1 (HamishMackenzie)
01:37:46 * hackagebot jsaddle-dom 0.1.0.1 - DOM library that uses jsaddle to support both GHCJS and WebKitGTK  https://hackage.haskell.org/package/jsaddle-dom-0.1.0.1 (HamishMackenzie)
01:37:48 * hackagebot ghcjs-dom 0.3.0.1 - DOM library that supports both GHCJS and WebKitGTK  https://hackage.haskell.org/package/ghcjs-dom-0.3.0.1 (HamishMackenzie)
01:37:50 * hackagebot som 9.0.1 - Self-Organising Maps.  https://hackage.haskell.org/package/som-9.0.1 (AmyDeBuitleir)
01:37:52 * hackagebot creatur 5.9.12 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.12 (AmyDeBuitleir)
01:38:46 <thoughtpolice> OK, Hackage is now fixed.
01:41:46 <johnw> thank you!
01:42:54 * hackagebot vcswrapper 0.1.3 - Wrapper for source code management systems  https://hackage.haskell.org/package/vcswrapper-0.1.3 (HamishMackenzie)
01:42:56 * hackagebot hid 0.2.2 - Interface to hidapi library  https://hackage.haskell.org/package/hid-0.2.2 (DimitriSabadie)
01:42:58 * hackagebot zero 0.1.4 - Semigroups with absorption  https://hackage.haskell.org/package/zero-0.1.4 (DimitriSabadie)
01:43:00 * hackagebot tellbot 0.6.1 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.1 (DimitriSabadie)
01:43:02 * hackagebot table-layout 0.6.0.1 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.6.0.1 (muesli4)
01:48:04 * hackagebot eventloop 0.8.1.2 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.8.1.2 (sebaslafleur)
01:48:06 * hackagebot ginger 0.2.5.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.2.5.0 (TobiasDammers)
01:48:08 * hackagebot octane 0.5.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.0 (fozworth)
01:48:10 * hackagebot pointful 1.0.8 - Pointful refactoring tool  https://hackage.haskell.org/package/pointful-1.0.8 (MikhailGlushenkov)
01:48:12 * hackagebot hsimport 0.7.1 - A command line program for extending the import list of a Haskell source file.  https://hackage.haskell.org/package/hsimport-0.7.1 (DanielTrstenjak)
01:53:14 * hackagebot ffmpeg-light 0.11.0 - Minimal bindings to the FFmpeg library.  https://hackage.haskell.org/package/ffmpeg-light-0.11.0 (AnthonyCowley)
01:53:16 * hackagebot text-conversions 0.2.0 - Safe conversions between textual types  https://hackage.haskell.org/package/text-conversions-0.2.0 (lexi_lambda)
01:53:18 * hackagebot JuicyPixels-extra 0.1.0 - Efficiently scale, crop, flip images with JuicyPixels  https://hackage.haskell.org/package/JuicyPixels-extra-0.1.0 (mrkkrp)
01:53:20 * hackagebot incremental-maps 0.0.0.0 - Package for doing incremental computations on maps  https://hackage.haskell.org/package/incremental-maps-0.0.0.0 (jelken)
01:53:22 * hackagebot data-function-meld 0.1.1.0 - Map the arguments and return value of functions.  https://hackage.haskell.org/package/data-function-meld-0.1.1.0 (erisco)
01:58:24 * hackagebot webdriver 0.8.3 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.8.3 (AdamCurtis)
01:58:26 * hackagebot wordpass 1.0.0.5 - Dictionary-based password generator  https://hackage.haskell.org/package/wordpass-1.0.0.5 (MichalGajda)
01:58:28 * hackagebot BlogLiterately 0.8.3 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.3 (BrentYorgey)
01:58:30 * hackagebot gi-gtk-hs 0.2.0.0 - A wrapper for gi-gtk, adding a few more idiomatic API parts on top  https://hackage.haskell.org/package/gi-gtk-hs-0.2.0.0 (HamishMackenzie)
01:58:32 * hackagebot gi-gtk-hs 0.2.0.1 - A wrapper for gi-gtk, adding a few more idiomatic API parts on top  https://hackage.haskell.org/package/gi-gtk-hs-0.2.0.1 (HamishMackenzie)
02:03:34 * hackagebot octane 0.5.1 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.1 (fozworth)
02:03:36 * hackagebot postgresql-simple 0.5.2.0 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.2.0 (LeonSmith)
02:03:38 * hackagebot minimal-configuration 0.1.3 - Minimal ini like configuration library with a few extras  https://hackage.haskell.org/package/minimal-configuration-0.1.3 (MariusGhita)
02:03:40 * hackagebot concurrent-machines 0.2.3 - Concurrent networked stream transducers  https://hackage.haskell.org/package/concurrent-machines-0.2.3 (AnthonyCowley)
02:03:42 * hackagebot Frames 0.1.3 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.1.3 (AnthonyCowley)
02:04:47 <slx> G'day 
02:08:44 * hackagebot roundRobin 0.1.1.0 - A simple round-robin data type  https://hackage.haskell.org/package/roundRobin-0.1.1.0 (winterland)
02:08:46 * hackagebot pseudo-boolean 0.1.5.0 - Reading/Writing OPB/WBO files used in pseudo boolean competition  https://hackage.haskell.org/package/pseudo-boolean-0.1.5.0 (MasahiroSakai)
02:08:48 * hackagebot wai-routes 0.9.8 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.8 (AnupamJain)
02:08:50 * hackagebot xdot 0.3.0.1 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  https://hackage.haskell.org/package/xdot-0.3.0.1 (DennisFelsing)
02:08:52 * hackagebot stratux 0.0.1 - A library for stratux  https://hackage.haskell.org/package/stratux-0.0.1 (TonyMorris)
02:13:54 * hackagebot NetSNMP 0.3.2.2 - Bindings for net-snmp's C API for clients  https://hackage.haskell.org/package/NetSNMP-0.3.2.2 (PavloKerestey)
02:13:56 * hackagebot cabal-sort 0.0.5.3 - Topologically sort cabal packages  https://hackage.haskell.org/package/cabal-sort-0.0.5.3 (HenningThielemann)
02:13:58 * hackagebot homplexity 0.4.3.2 - Haskell code quality tool  https://hackage.haskell.org/package/homplexity-0.4.3.2 (MichalGajda)
02:14:00 * hackagebot bitwise 0.1.1.1 - fast multi-dimensional unboxed bit packed Bool arrays  https://hackage.haskell.org/package/bitwise-0.1.1.1 (ClaudeHeilandAllen)
02:14:02 * hackagebot both 0.1.1.0 - Like Maybe, but with a different Monoid instance.  https://hackage.haskell.org/package/both-0.1.1.0 (barrucadu)
02:19:04 * hackagebot cases 0.1.3.1 - A converter for spinal, snake and camel cases  https://hackage.haskell.org/package/cases-0.1.3.1 (NikitaVolkov)
02:19:06 * hackagebot hw-prim 0.0.2.0 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.2.0 (haskellworks)
02:19:08 * hackagebot dpor 0.1.0.1 - A generic implementation of dynamic partial-order reduction (DPOR) for testing arbitrary models of concurrency.  https://hackage.haskell.org/package/dpor-0.1.0.1 (barrucadu)
02:19:10 * hackagebot dejafu 0.3.1.1 - Overloadable primitives for testable, potentially non-deterministic, concurrency.  https://hackage.haskell.org/package/dejafu-0.3.1.1 (barrucadu)
02:19:12 * hackagebot async-dejafu 0.1.2.2 - Run MonadConc operations asynchronously and wait for their results.  https://hackage.haskell.org/package/async-dejafu-0.1.2.2 (barrucadu)
02:22:42 <kadoban> That's a … lot of updates. For GHC 8, heh?
02:23:19 <mjrosenb> woah, GHC 8?
02:23:24 * mjrosenb goes to read up on it
02:24:14 * hackagebot hunit-dejafu 0.3.0.1 - Deja Fu support for the HUnit test framework.  https://hackage.haskell.org/package/hunit-dejafu-0.3.0.1 (barrucadu)
02:24:16 * hackagebot tasty-dejafu 0.3.0.1 - Deja Fu support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-dejafu-0.3.0.1 (barrucadu)
02:24:18 * hackagebot data-lens-light 0.1.2.2 - Simple lenses, minimum dependencies  https://hackage.haskell.org/package/data-lens-light-0.1.2.2 (RomanCheplyaka)
02:24:20 * hackagebot nonlinear-optimization-ad 0.2.2 - Wrapper of nonlinear-optimization package for using with AD package  https://hackage.haskell.org/package/nonlinear-optimization-ad-0.2.2 (MasahiroSakai)
02:24:22 * hackagebot traverse-with-class 0.2.0.4 - Generic applicative traversals  https://hackage.haskell.org/package/traverse-with-class-0.2.0.4 (RomanCheplyaka)
02:25:10 <mjrosenb>  * support for Applicative do notation
02:25:14 <mjrosenb> awwwwwyis
02:29:24 * hackagebot relational-record-examples 0.3.1.1 - Examples of Haskell Relationa Record  https://hackage.haskell.org/package/relational-record-examples-0.3.1.1 (KeiHibino)
02:29:26 * hackagebot relational-record 0.1.5.0 - Meta package of Relational Record  https://hackage.haskell.org/package/relational-record-0.1.5.0 (KeiHibino)
02:29:28 * hackagebot codex 0.5.0.0 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.5.0.0 (aloiscochard)
02:29:30 * hackagebot hjsonpointer 0.3.0.1 - JSON Pointer library  https://hackage.haskell.org/package/hjsonpointer-0.3.0.1 (seagreen)
02:29:32 * hackagebot hjsonschema 0.10.0.2 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.10.0.2 (seagreen)
02:34:34 * hackagebot concurrent-machines 0.2.3.1 - Concurrent networked stream transducers  https://hackage.haskell.org/package/concurrent-machines-0.2.3.1 (AnthonyCowley)
02:34:36 * hackagebot blosum 0.1.1.1 - BLOSUM generator  https://hackage.haskell.org/package/blosum-0.1.1.1 (GregorySchwartz)
02:34:38 * hackagebot fixed-vector-hetero 0.3.1.1 - Generic heterogeneous vectors  https://hackage.haskell.org/package/fixed-vector-hetero-0.3.1.1 (AlexeyKhudyakov)
02:34:40 * hackagebot VKHS 1.6.2 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-1.6.2 (SergeyMironov)
02:34:42 * hackagebot extra 1.4.8 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.8 (NeilMitchell)
02:39:44 * hackagebot LambdaDB 0.0.0.5 - On-memory Database using Lambda Function environment.  https://hackage.haskell.org/package/LambdaDB-0.0.0.5 (Ailrun)
02:39:46 * hackagebot prompt 0.1.1.1 - Monad (and transformer) for deferred-effect pure  prompt-response queries  https://hackage.haskell.org/package/prompt-0.1.1.1 (jle)
02:39:48 * hackagebot skulk 0.1.2.0 - Eclectic collection of utility functions  https://hackage.haskell.org/package/skulk-0.1.2.0 (geekyfox)
02:39:50 * hackagebot Encode 1.3.8 - Encoding character data  https://hackage.haskell.org/package/Encode-1.3.8 (OtakarSmrz)
02:39:52 * hackagebot stratux-types 0.0.1 - A library for stratux  https://hackage.haskell.org/package/stratux-types-0.0.1 (TonyMorris)
02:44:07 <akegalj> I am trying to make Dialog (https://hackage.haskell.org/package/gtk3-0.14.2/docs/Graphics-UI-Gtk-Windows-Dialog.html) using gkt3 and make it fixed sized. But xmonad keeps resizing it. Can I somehow set up hint that this dialog should float ?
02:44:54 * hackagebot stratux 0.0.2 - A library for stratux  https://hackage.haskell.org/package/stratux-0.0.2 (TonyMorris)
02:44:56 * hackagebot pretty-show 1.6.10 - Tools for working with derived `Show` instances and generic  inspection of values.  https://hackage.haskell.org/package/pretty-show-1.6.10 (IavorDiatchki)
02:44:58 * hackagebot wai-session-postgresql 0.2.1.0 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.2.1.0 (hc)
02:45:00 * hackagebot prompt 0.1.1.2 - Monad (and transformer) for deferred-effect pure  prompt-response queries  https://hackage.haskell.org/package/prompt-0.1.1.2 (jle)
02:45:02 * hackagebot sbp 1.0.0 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-1.0.0 (markfine)
02:50:05 * hackagebot language-thrift 0.9.0.1 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.9.0.1 (abhinav)
02:50:06 * hackagebot flow 1.0.7 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.7 (fozworth)
02:50:08 * hackagebot network-simple 0.4.0.5 - Simple network sockets usage patterns.  https://hackage.haskell.org/package/network-simple-0.4.0.5 (RenzoCarbonara)
02:50:11 * hackagebot extensible-effects 1.11.0.4 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-1.11.0.4 (shergill)
02:50:12 * hackagebot bytestring-tree-builder 0.2.7 - A very efficient ByteString builder implementation based on the binary tree  https://hackage.haskell.org/package/bytestring-tree-builder-0.2.7 (NikitaVolkov)
03:05:21 <chris2> i have cabal 1.24 but i want to build stack 1.1.2 which needs 1.22.8
03:05:35 <chris2> since i build stack in a cabal sandbox anyway, this should still work, no?
03:06:10 <chris2> but when i install "Cabal" into the sandbox (with pinned cabal.config from stackage), it installs cabal 1.22.8, but later building stack fails nevertheless
03:12:47 * hackagebot hdo 0.1 - A Digital Ocean client in Haskell  https://hackage.haskell.org/package/hdo-0.1 (abailly)
03:31:49 <Tekkkz> I want to build the network package from source. But at ./Setup build    I get the error: No template specified, and template-hsc.h not located.    Any idea how to solve that?
03:35:09 <int-e> Tekkkz: that error is produced by hsc2hs, which appears to be missing (or unable to find) its data files.
03:35:37 <Tekkkz> so what does this mean? or how to fix that?
03:36:00 <int-e> I'd try (re)installing hsc2hs manually
03:39:19 <Tekkkz> okay. give me some time
03:40:31 <int-e> it's a bit weird to see it broken though, as it should be part of ghc's distibution.
03:42:04 <Tekkkz> now the compilation seems to work with the reinstalled hsc2hs. THANKS
03:43:50 <int-e> Tekkkz: how did you install ghc?
03:44:32 <Tekkkz> cloned the precompiled stuff from debian repo
03:46:36 <Tekkkz> btw, how to fix the warning: /usr/lib/ghc/bin/ghc: /usr/lib/libtinfo.so.5: no version information available
03:47:57 <puregreen> Tekkkz: I had this warning yesterday on Arch and for me installing libtinfo5 worked
03:48:10 <puregreen> Tekkkz: I see that there's a libtinfo5 package in Debian as well, you may try it
03:48:55 <puregreen> hm, tho in my case it was an error, not a warning
03:49:00 <puregreen> perhaps our cases are different
03:52:32 <Tekkkz> nono i am on arch
03:53:30 <puregreen> Tekkkz: then it's libtinfo-5, not libtinfo5
03:53:36 <puregreen> (in AUR)
03:53:41 <Tekkkz> okay. thanks
03:54:58 <Tekkkz> i have still the problem with the warning about no version information q.q
03:55:20 <Tekkkz> /usr/lib/ghc/bin/ghc: /usr/lib/libtinfo.so.5: no version information available (required by /usr/lib/ghc/bin/../terminfo-0.4.0.2/libHSterminfo-0.4.0.2-ghc8.0.1.so)
03:57:48 * hackagebot publicsuffix 0.20160526 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160526 (wereHamster)
04:14:27 <Unode> quit
04:14:46 <EvanR> nevar
04:22:49 * hackagebot VKHS 1.6.3 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-1.6.3 (SergeyMironov)
04:27:50 * hackagebot gi-atk 2.0.4 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.4 (inaki)
04:27:52 * hackagebot gi-cairo 1.0.4 - Cairo bindings  https://hackage.haskell.org/package/gi-cairo-1.0.4 (inaki)
04:27:54 * hackagebot gi-gdk 3.0.4 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-3.0.4 (inaki)
04:27:56 * hackagebot gi-gdkpixbuf 2.0.4 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-2.0.4 (inaki)
04:27:58 * hackagebot gi-gio 2.0.4 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.4 (inaki)
04:33:00 * hackagebot gi-girepository 1.0.4 - GIRepository (gobject-introspection) bindings  https://hackage.haskell.org/package/gi-girepository-1.0.4 (inaki)
04:33:02 * hackagebot gi-glib 2.0.4 - GLib bindings  https://hackage.haskell.org/package/gi-glib-2.0.4 (inaki)
04:33:04 * hackagebot gi-gobject 2.0.4 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-2.0.4 (inaki)
04:33:06 * hackagebot gi-gst 1.0.4 - GStreamer bindings  https://hackage.haskell.org/package/gi-gst-1.0.4 (inaki)
04:33:08 * hackagebot gi-gstaudio 1.0.4 - GStreamerAudio bindings  https://hackage.haskell.org/package/gi-gstaudio-1.0.4 (inaki)
04:38:10 * hackagebot gi-gstbase 1.0.4 - GStreamerBase bindings  https://hackage.haskell.org/package/gi-gstbase-1.0.4 (inaki)
04:38:12 * hackagebot gi-gstvideo 1.0.4 - GStreamerVideo bindings  https://hackage.haskell.org/package/gi-gstvideo-1.0.4 (inaki)
04:38:14 * hackagebot gi-gtk 3.0.4 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.4 (inaki)
04:38:16 * hackagebot gi-gtksource 3.0.4 - GtkSource bindings  https://hackage.haskell.org/package/gi-gtksource-3.0.4 (inaki)
04:38:18 * hackagebot gi-javascriptcore 3.0.4 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-3.0.4 (inaki)
04:43:20 * hackagebot gi-javascriptcore 4.0.4 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-4.0.4 (inaki)
04:43:22 * hackagebot gi-notify 0.7.4 - Libnotify bindings  https://hackage.haskell.org/package/gi-notify-0.7.4 (inaki)
04:43:24 * hackagebot gi-pango 1.0.4 - Pango bindings  https://hackage.haskell.org/package/gi-pango-1.0.4 (inaki)
04:43:26 * hackagebot gi-pangocairo 1.0.4 - PangoCairo bindings  https://hackage.haskell.org/package/gi-pangocairo-1.0.4 (inaki)
04:43:28 * hackagebot gi-poppler 0.18.4 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.18.4 (inaki)
04:47:32 <Tekkkz> I want to build hackage-security from sources. But it fails with ffi.h not found. But i have installed it before ... what can I do?
04:48:30 * hackagebot gi-soup 2.4.4 - Libsoup bindings  https://hackage.haskell.org/package/gi-soup-2.4.4 (inaki)
04:48:32 * hackagebot gi-vte 2.91.4 - Vte bindings  https://hackage.haskell.org/package/gi-vte-2.91.4 (inaki)
04:48:34 * hackagebot gi-webkit2 4.0.4 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-4.0.4 (inaki)
04:48:36 * hackagebot gi-webkit2webextension 4.0.4 - WebKit2-WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-4.0.4 (inaki)
04:48:38 * hackagebot gi-webkit 3.0.4 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-3.0.4 (inaki)
04:53:40 * hackagebot monad-parallel 0.7.2.2 - Parallel execution of monadic computations  https://hackage.haskell.org/package/monad-parallel-0.7.2.2 (MarioBlazevic)
04:57:51 * hackagebot type-level-sets 0.7 - Type-level sets and finite maps (with value-level counterparts)  https://hackage.haskell.org/package/type-level-sets-0.7 (DominicOrchard)
05:07:11 <Tekkkz> I want to build hackage-security from sources. But it fails with ffi.h not found. But i have installed it before ... what can I do?
05:08:47 <pavonia> That file should be part of the GHC installation, so perhaps some paths not being set correctly?
05:09:28 <Tekkkz> it also worked previousely
05:10:46 <pavonia> Hhm no, I'm confusing that with something else
05:11:36 <pavonia> Tekkkz: Do you have the libffi-dev package installed?
05:13:15 <Tekkkz> i am on arch. but yeah, libffi is installed
05:15:41 <cocreature> Tekkkz: maybe the include path is not set correctly? the file is in /usr/lib/libffi-3.2.1/include
05:17:40 <Tekkkz> I have it on 3 path's: /usr/include/aarch64-linux-gnu/ffi.h
05:17:40 <Tekkkz> /usr/lib/libffi-3.2.1/include/ffi.h
05:17:43 <Tekkkz> /usr/local/lib/libffi-3.0.13/include/ffi.h
05:17:53 <Tekkkz> but on none it is finding?? still error
05:24:37 <int-e> Tekkkz: ghc has its own ffi.h file, something like /usr/lib/ghc-7.10.3/include/ffi.h
05:25:49 <int-e> Tekkkz: and that's the second header file shipped with ghc that you're failing to find... your ghc installation is messed up. (the hsc-template.h file is usually in /usr/lib/ghc-7.10.3/template-hsc.h)
05:26:20 <int-e> obviously the path varies with installation root and ghc version... but it should be possible to extrapolate from these two.
05:30:57 <Xandaros> int-e: I don't seem to have it, either: http://tcp.mniip.com/1k2j - so, either it's in a completely different location or the arch package is borked
05:31:23 <Xandaros> (The fact that pkgfile doesn't find it in ghc at all, seems to suggest the latter)
05:35:20 <Xandaros> It seems to configure ghc with “    --with-ffi-includes=$(pkg-config --variable=includedir libffi)
05:35:23 <Xandaros> ”
05:35:31 <int-e> Xandaros: right, and --with-system-libffi
05:35:38 <Xandaros> yup
05:35:55 <int-e> so that explains that and it should probably work.
05:37:47 <int-e> and the arch package does ship /usr/lib/ghc-7.10.3/template-hsc.h
05:40:24 <int-e> okay, Debian also uses "--with-system-libffi" (at least in sid and stretch)
05:42:52 * hackagebot gi-gtkosxapplication 2.0.4 - GtkosxApplication bindings  https://hackage.haskell.org/package/gi-gtkosxapplication-2.0.4 (inaki)
05:43:05 <riaqn> Hi, is there any real time math typesetting library?
06:06:50 <Tekkkz> where can i donwload haskell-libffi sources int-e ?
06:08:36 <int-e> Tekkkz: the ffi.h problem will not happen on x86 or x86_64, because then ghc has its own support for the "adjustors" used by 'foreign import ccall "wrapper"'... so that may explain how this could slip into the debian package.
06:08:57 <Tekkkz> so what must i do?
06:12:33 <int-e> Tekkkz: I'd probably add a symlink to /usr/lib/libffi-3.2.1/include/ffi.h in /usr/local/include or something like that. Debian should be passing --with-ffi-includes when configuring its ghc package.
06:12:54 * hackagebot syntactic 3.6.1 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.6.1 (EmilAxelsson)
06:14:30 <reptar_> is it possible to unload Prelude?
06:17:16 <Akii> reptar_: NoImplicitPrelude
06:17:18 <chelfi> reptar_: https://wiki.haskell.org/No_import_of_Prelude
06:17:36 <reptar_> thank you, both!
06:17:39 <Akii> :D
06:24:16 <S11001001> What's a good name for the hypothetical Foldable-ish function f a → exists s. (s, s → Maybe (a, s)) ? (The function can be iteratively invoked to unroll the left fold of f, one by one)
06:31:52 <Arguggi> Does lifting a pure function to a monad transformer with IO as the base monad have much of a performance penalty? For example how much slower is something like this  MyError -> Maybe a -> ExceptT MyError IO a , when the function that generates the Maybe a is pure?
06:42:26 <jle`> Arguggi: slower compared to what?
06:44:51 <sshine> slower than e.g. MyError -> Maybe a -> Either MyError a, I suppose...
06:45:52 <jle`> sounds like something you can benchmark :)  but, in any case, why don't you just provide MyError -> Maybe a -> Either MyError a instead?
06:45:57 <jle`> the type is much more descriptive
06:46:15 <Arguggi> slower then just handling it with a case xxx of 
06:52:55 * hackagebot lazyio 0.1.0.2 - Run IO actions lazily while respecting their order  https://hackage.haskell.org/package/lazyio-0.1.0.2 (HenningThielemann)
07:01:34 <Tekkkz> int-e: i am not on debian! i am on arch
07:03:56 <Tekkkz> int-e: sudo ln -s /usr/loca
07:04:07 <Tekkkz> l/lib/libffi-3.0.13/include/ffi.h /usr/lib/ghc/include/ works fine
07:07:42 <APic> Hi.
07:22:57 * hackagebot open-typerep 0.6.1 - Open type representations and dynamic types  https://hackage.haskell.org/package/open-typerep-0.6.1 (EmilAxelsson)
07:30:13 <ironChicken> in Text.Parsec.choice, do the failing parsers consume input?
07:32:41 <ironChicken> the implementation is just `foldr <|> mzero` which i guess means that the behaviour of <|> applies
07:33:24 <ironChicken> so does that mean that parsers in choice only get tried if earlier parsers did not consume input?
07:33:49 <ironChicken> and should we therefore wrap them in `try` if we want to "go back" in the input and try again?
07:39:09 <pantsman-> ironChicken, yes, you should use `try` around each parser that might consume input before failing
07:39:45 <ironChicken> pantsman-: and specifically in `choice`, right?
07:40:03 <pantsman-> yes, choiced does nothing specific to affect backtracking
07:40:06 <pantsman-> *choice
07:40:16 <ironChicken> yes, i see. thanks
07:40:55 <sm> I have choice' = choice . map try
07:41:44 <ironChicken> sm: nice
07:42:16 <sm> probably encourages inefficiency
07:42:42 <ironChicken> well, i'll worry about correctness first :-)
07:42:57 * hackagebot gipeda 0.3 - Git Performance Dashboard  https://hackage.haskell.org/package/gipeda-0.3 (JoachimBreitner)
07:42:59 * hackagebot ratel 0.2.0 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-0.2.0 (fozworth)
07:43:01 <sm> +1
07:43:01 * hackagebot nvim-hs 0.0.7 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-0.0.7 (saep)
07:43:16 <pantsman-> and it isn't always what you want, sometimes you might want subparsers to commit after having partially suceeded
07:43:51 <sm> pantsman-: indeed, I do want that. Is there a way to get it other than throwing an exception ?
07:43:58 <sm> with parsec, I mean
07:46:12 <sm> hmm.. ghc8 shows a (truncated) call stack by default on error, which breaks doctests. Not sure how to handle it
07:46:55 <sm> more CPP, testing base version I guess :/
08:00:15 <sm> doesn't work. I guess doctest/haddock is not processing CPP, or not using the same package set
08:03:52 <sm> well, it was a stupid test anyway
08:15:57 <lpaste> tippenein pasted “monadic return from Pipe..” at http://lpaste.net/164635
08:16:27 <tippenein> ^ a question about the monadic returns from Pipes
08:17:21 <tippenein> Producer Text m () >-> Pipe Text m Text  should yield a Text out of the monadic context, amirite?
08:23:24 <rsch> Hi, I am trying out some Haskell code for dependent type.  And I got an error in ghci as follow:  *Dependent.Nat> transpose ((1 :- 2 :- 3 :- Nil) :- (2 :- 3 :- 4 :- Nil) :- Nil)  <interactive>:35:1:     No instance for (Num (Vector a0 n1)) arising from a use of ‘it’     In the first argument of ‘print’, namely ‘it’     In a stmt of an interactive GHCi command: print it   I am not sure how to declare Num for Vector.  Sorry no
08:26:18 <glguy> rsch: It most likely means that the type of transpose or of your vector is forcing the type of one(or all) of those number literals to be a Vector
08:26:32 <glguy> not that you actually need to make a Num instance for Vector
08:27:00 <glguy> If you want to paste more of your code to lpaste you'll get more help
08:27:23 <AdituV> hey there, I seem to remember that there's a sort-of-out-of-date compiler with simpler error messages.  does anyone know which one I'm thinking of?
08:27:30 <rsch> glguy can you give me the link to lpaste?
08:27:35 <glguy> ?lpaste
08:27:35 <lambdabot> Haskell pastebin: http://lpaste.net/
08:28:03 <rsch> i am pasting the code now.
08:28:29 <sleblanc> ack, cannot install package hsndfile: c2hs complains with error "Illegal use of incomplete type!" at sndfile.h:355
08:28:47 <sleblanc> Expected a fully defined structure or union tag; instead found incomplete type
08:28:56 <rsch> http://lpaste.net/164636
08:29:15 <rsch> i just copied this from one of the examples I found.
08:29:54 <rsch> transpose ((1 :- 2 :- 3 :- Nil) :- (2 :- 3 :- 4 :- Nil) :- Nil)
08:30:02 <rsch> is the test in ghci.
08:30:58 <glguy> rsch: Ask GHCi:   :t ((1 :- 2 :- 3 :- Nil) :- (2 :- 3 :- 4 :- Nil) :- Nil)
08:31:08 <sleblanc> I can work around it by "merging" the typedef into the struct definition, but I feel dirty for editing that file
08:31:12 <rsch> hang on.
08:31:37 <glguy> rsch: and see if you can spot the problem with the resulting type
08:32:03 <rsch> :t ((1 :- 2 :- 3 :- Nil) :- (2 :- 3 :- 4 :- Nil) :- Nil) ((1 :- 2 :- 3 :- Nil) :- (2 :- 3 :- 4 :- Nil) :- Nil)   :: (Num a, Num (Vector a n1), Num (Vector a ('S n1)),       Num (Vector (Vector a ('S n1)) n),       Num (Vector (Vector (Vector a ('S n1)) ('S n)) 'Z)) =>      Vector        (Vector           (Vector (Vector (Vector a ('S n1)) ('S n)) ('S 'Z)) ('S ('S 'Z)))        ('S 'Z)
08:32:04 <AdituV> I get the error with just 1 :- 2 :- 3 :- Nil
08:32:06 <lambdabot>     Not in scope: data constructor ‘:-’
08:32:06 <lambdabot>     Perhaps you meant one of these:
08:32:06 <lambdabot>       ‘:+’ (imported from Data.Complex),
08:32:21 <glguy> rsch: I don't want you to paste it, I want you to look at it :)
08:32:31 <rsch> oh ok.
08:33:49 <rsch> it infers that Vector is supposed to be Num.
08:34:03 <rsch> since they don't match.
08:34:06 <glguy> More importantly it infers that you have a VEctor of Vectors of Vectors of Vectors ...
08:34:38 <glguy> The problem is on line 55 of your paste
08:34:38 <rsch> yes.  but that is what I got from the examples.
08:34:53 <AdituV> @rsch: your associativity on the vector constructor is wrong
08:34:53 <lambdabot> Unknown command, try @list
08:34:58 <rsch> I am not adding any code.  So did something changed?
08:35:06 <glguy> rsch: I don't know, but it's wrong
08:35:17 <AdituV> (1 :- 2 :- Nil) == ((1 :- 2) :- Nil) instead of (1 :- (2 :- Nil))
08:35:40 <rsch> ok let me try the brackets.
08:35:54 <glguy> or you can change the fixity on line 55
08:36:38 <AdituV> glguy: sorry if I spoiled your socratic method.  only just spotted what you were trying to do :/
08:37:04 <rsch> AdituV it is all good.
08:37:33 <rsch> I am just trying to have one working example of dependent type code, so I can reason about how to do it.
08:37:54 <rsch> with this (1 :- 2) gives the same error about Num
08:38:12 <glguy> What do you think 1 :- 2 should be?
08:38:33 <rsch> oh i see it should start with Nil.
08:38:37 <rsch> let me try that.
08:39:15 <rsch> ok got that.
08:39:57 <rsch> i see so the brackets caused it to not getting into the right Vector type.
08:40:32 <AdituV> rsch: yes.  it wanted a Num constraint for vector so it could convert the "2" in 1 :- 2 into a vector using fromInteger
08:41:55 <rsch> thanks glguy.  got it to work with this : transpose ((1 :- (2 :- (3 :- Nil))) :- (( 2 :- (3 :- (4 :- Nil))) :- Nil))
08:42:19 <AdituV> rsch: just change the fixity :p  infixl -> infixr to change the way the brackets are automatically
08:42:20 <glguy> rsch: Now change infixl to infixr on line 55 so that you don't have to do that
08:42:21 <rsch> Thanks AdituV.
08:43:03 <rsch> that is cool.  thanks.
08:48:01 * hackagebot lazyio 0.1.0.3 - Run IO actions lazily while respecting their order  https://hackage.haskell.org/package/lazyio-0.1.0.3 (HenningThielemann)
08:53:01 * hackagebot elm-bridge 0.3.0.2 - Derive Elm types from Haskell types  https://hackage.haskell.org/package/elm-bridge-0.3.0.2 (AlexanderThiemann)
08:58:01 * hackagebot hstzaar 0.9.4 - A two player abstract strategy game.  https://hackage.haskell.org/package/hstzaar-0.9.4 (PedroVasconcelos)
09:10:05 <nitrix> How does (`f` g . h) parses as?
09:10:49 <nitrix> Nvm, unpl'ed.
09:11:16 <merijn> Also depends on the fixity of `f`, I suppose?
09:13:02 * hackagebot weigh 0.0.0 - Measure allocations of a Haskell functions/values  https://hackage.haskell.org/package/weigh-0.0.0 (ChrisDone)
09:14:16 <enthropy> merijn: I feel like it should depend on f's fixity, but at the same time I think operator sections follow a simpler rule
09:14:56 <cocreature> the weigh package hackagebot just posted looks interesting
09:15:20 <merijn> enthropy: Basically, it has the meaning of applying "f . g" as second argument of 'f' OR parse error, I think
09:15:30 <enthropy> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-300003.5 doesn't mention fixities
09:16:13 <merijn> @define foobar :: a -> a -> a; foobar = undefined; infixr 9
09:16:13 <lambdabot>  Parse failed: Parse error: EOF
09:16:21 <merijn> @undefine
09:16:21 <lambdabot> Undefined.
09:16:24 <merijn> @define foobar :: a -> a -> a; foobar = undefined; infixr 9 `foobar`
09:16:26 <lambdabot>  Defined.
09:16:36 <merijn> :t (`foobar` id . id)
09:16:38 <lambdabot> (c -> c) -> c -> c
09:16:45 <merijn> @undefine
09:16:45 <lambdabot> Undefined.
09:16:50 <merijn> @define foobar :: a -> a -> a; foobar = undefined; infixl 9 `foobar`
09:16:51 <lambdabot>  Defined.
09:16:52 <merijn> :t (`foobar` id . id)
09:16:54 <lambdabot> (c -> c) -> c -> c
09:16:56 <merijn> hmmm
09:16:57 <merijn> ok
09:17:16 <enthropy> the infix dec can be part of a let I think
09:17:41 <merijn> Yeah, but I was too lazy in case it didn't :p
09:21:05 <geekosaur> it "should" use fixity, but I think in the case of a section it has to commit to a parse before it can reliably know the fixity
09:21:25 <Zemyla> Oh, how do you use QuickCheck to test a parser?
09:22:06 <enthropy> Zemyla: write a pretty printer first
09:22:14 <merijn> enthropy: Not really
09:22:25 <merijn> enthropy: Pretty printers are more consistent than the possible input
09:22:28 <enthropy> or a second parser that is "obviously correct" for some reason
09:22:41 <enthropy> :t let infixl 9 %; (%) = (+); in (% pred . succ)
09:22:43 <lambdabot> (Enum c, Num (c -> c)) => (c -> c) -> c -> c
09:22:43 <merijn> The real answer is: You don't really, you write out testcases for corner cases by hand
09:23:20 <enthropy> merijn: agreed
09:24:44 <enthropy> geekosaur: there's a bootstrapping issue with parsing and fixities, without involving sections
09:24:56 <geekosaur> sure
09:28:11 <Zemyla> Why is there no URec for things like Array#?
09:28:26 <merijn> URec?
09:28:59 <Zemyla> URec is an addition to Generics for unboxed values like Int# and Double#.
09:29:13 <merijn> no idea, tbh
09:29:20 <merijn> Sounds like a question for #ghc
09:33:27 <ConsciousCreator> Hi everyone...
09:34:03 <JuanDaugherty> yello ConsciousCreator 
09:34:14 <merijn> Zemyla: Essentially these very detailed/low-level questions that only a handful people can answer are best asked in either #ghc or on mailing lists, bigger chance of people knowing the answer seeing it...
09:34:21 <nitrix> ConsciousCreator: Welcome on the Haskell channel :)
09:35:05 <geekosaur> and I think in general the mailing list works better for this kind of thing, as many of the people who know ghc internals don't hang out in #ghc (or don't do so regularly)
09:35:55 <merijn> geekosaur: Sure
09:35:58 <ConsciousCreator> JuanDaugherty: howdy :-)
09:36:05 <ConsciousCreator> nitrix:  Thanks :-)
09:36:08 <merijn> But at least #ghc is so low-traffic that your question will stay on screen for hours
09:36:19 <merijn> So if someone in there DOES know, you are likely to get an answer
09:36:31 <merijn> Whereas here it scrolls off screen in less than a minute
09:36:49 <ConsciousCreator> I've never used haskell before, but I heard about how good the haskell community tends to be, so I wanted to check it out for myself... :-)
09:38:46 <ConsciousCreator> Is anyone interested in telling me what in particular they like about haskell?  And why you choose to program in Haskell, as opposed to, say, Java / C++ / etc..?
09:39:06 <nitrix> I don't think we're good salesman.
09:39:16 <maerwald> heh
09:39:25 <maerwald> and biased too
09:39:35 <JuanDaugherty> personally, state and io
09:39:53 <maerwald> except IO in haskell sucks :P
09:39:59 <mkloczko> the type system
09:40:00 <ConsciousCreator> nitrixx: No sales involved here  :-)   ...just want to hear your honest opinions...
09:40:01 <merijn> ConsciousCreator: The summary: The only way to write complex projects that actually work is if you can reason about your program behaviour. Haskell makes reasoning about program behaviour easier, and thus makes writing complicated programs easier
09:40:05 <merijn> maerwald: Wut?
09:40:09 <nitrix> ConsciousCreator: The type system.
09:40:26 <maerwald> merijn: it's a giant "anything might happen here" type, which is not really haskell-ish
09:40:58 <merijn> ConsciousCreator: Easy programs are harder in haskell than other languages, but hard programs are easier than in other languages.
09:41:16 <maerwald> and it's not easy to reason about a haskell program that has a lot of IO types stuffed into it, so there goes that
09:41:19 <merijn> ConsciousCreator: Some of the simplest things I've written in haskell, I wouldn't dare attempt to write in other languages
09:41:40 <merijn> maerwald: As someone who's written haskell code that is 90% IO, that's not true
09:41:41 <ConsciousCreator> merijn:  So, Haskell allows you to work more at the solution-level rather than getting bogged down in minutiae as with, say, C...?
09:41:46 <merijn> ConsciousCreator: Yes
09:41:50 <maerwald> oh, I do that too and I disagree with you
09:41:59 <maerwald> and there are easy solutions to it
09:42:02 <maerwald> like an effect system
09:42:04 <merijn> maerwald: I've written runtime systems in both C and Haskell, and the Haskell solutions are an order of magnitude easier
09:42:20 <maerwald> there's no excuse to not have more fine-grained effects
09:42:24 <maerwald> IO is just the machine gun
09:42:28 <ConsciousCreator> merijn:  Great. I like the sound of it already...
09:42:28 <merijn> maerwald: You're arguing a strawman
09:42:33 <maerwald> not really
09:42:38 <merijn> maerwald: I never said there's no way to improve IO
09:42:47 <merijn> maerwald: I said "IO is better than existing imperative languages"
09:43:03 * hackagebot matrix 0.3.5.0 - A native implementation of matrix operations.  https://hackage.haskell.org/package/matrix-0.3.5.0 (DanielDiaz)
09:43:04 <nitrix> You could always divide subtypes of IO that are given a handful of responsabilities.
09:43:05 <maerwald> merijn: and I said "except IO in haskell sucks" and you asked why
09:43:05 * hackagebot git-annex 6.20160527 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160527 (JoeyHess)
09:43:06 <merijn> maerwald: You're arguing "IO is not as good as it could be"
09:43:08 <maerwald> so there is your answer
09:43:17 <nitrix> One could argue that this is what StateT and others are going already.
09:43:19 <maerwald> yes, which was my initial point
09:43:50 <ConsciousCreator> merijn:  My area of specialization in my University degree was Embedded Systems Engineering, so we had to do a decent amount of Assembly language and C....so I know all about getting bogged down in minutiae and losing precious hours debugging a program that should "just work"...
09:44:14 <dgpratt> if you were going to set up a VM just for Haskell development, what distro would you use?
09:44:26 <merijn> ConsciousCreator: I always try to keep things realistic for beginners, for example, for me it took like 6+ months before I was able to "really" write real world code in haskell (granted, there were less books back then), but once you CAN write real world haskell, hard problems become way easier
09:44:30 <simpson> dgpratt: NixOS.
09:44:48 <nitrix> ConsciousCreator: A common saying in the Haskell community is "if it compiles, it probably works". To take with a grain of salt.
09:45:07 <merijn> ConsciousCreator: For example, I wanted to write a quick webscraper to download a webcomic: Wrote a concurrent webscraper in like 80 lines of code (20 or so of which were imports >.>)
09:45:28 <ConsciousCreator> merijn:  Nice! :-)
09:45:32 <dgpratt> an interesting choice, simpson
09:45:40 <dgpratt> I dabbled with it before
09:45:44 <merijn> ConsciousCreator: It's also fairly easy to use the FFI to call C, so what I end up doing is "write almost everything in Haskell" and use the FFI if I need the control of writing C
09:45:53 <simpson> dgpratt: Not really. I'm just tired of messing around with distros with inferior package managers. Nix is just that good.
09:46:22 <dgpratt> found some guides for doing haskell dev, but they were out of date in certain respects and I had a hard time translating
09:46:23 <ConsciousCreator> merijn: What does FFI stand for?
09:46:35 <nitrix> simpson: How do you deal with packages not yet ported?
09:46:40 <ConsciousCreator> Foreign Function Interface...got it :-)
09:46:49 <maerwald> ConsciousCreator: IO in haskell sucks and is not really a good seller, IMO, because it can contain random effects to anything. Although it's technically well-typed, it doesn't give you a lot of information about what is _really_ going on, in contrast to pretty much most of the IO-free code you will see in haskell.
09:46:54 <maerwald> where the types actually mean something
09:47:24 <nitrix> maerwald: I'm not sure why IO bothers you.
09:47:31 <maerwald> nitrix: I just explained it
09:47:39 <hpc> maerwald: i agree with all of that except that it's not a good seller
09:47:50 <nitrix> maerwald: You've also ignored my own messages, so we're even.
09:48:09 <ConsciousCreator> maerwald:  Exactly what kind of IO are you referring to?  Could you provide me with a specific example..?
09:48:19 <simpson> nitrix: Port them.
09:48:24 <hpc> imo, simply having first-class IO to begin with is more important even than first-class functions
09:48:33 <merijn> hpc++
09:48:37 <simpson> nitrix: I mean, c'mon, it's just Nix. It's not really that scary as far as bespoke languages go.
09:48:43 <hpc> well maybe that's exaggerating
09:48:46 <hpc> but it's pretty damn powerful
09:48:54 <nitrix> maerwald: Ultimately, you need a way to have effects and IO does exactly that. Everything ends up in IO and that's normal because your main is IO.
09:49:00 <maerwald> ConsciousCreator: the Snap monad in an http server allows arbitrary IO to be executed within, which means there can happen anything, including deleting your whole filesystem (to exaggarate)
09:49:15 <maerwald> nitrix: look at purescript or idris, they have IO effects too, just more fine-grained
09:49:15 <hpc> in any other language you're throwing around (() -> a) values instead, and it looks ridiculous enough that nobody does it
09:49:20 <nitrix> maerwald: Everything else is _already_ broken down into subtypes like StateT and others to extract responsabilities from IO.
09:49:27 <nitrix> maerwald: I think you're conflating a lot.
09:49:38 <nitrix> maerwald: The fine-fained exists in Haskell.
09:49:41 <nitrix> *grained
09:49:49 <maerwald> except no one uses it
09:49:57 <nitrix> Everyone uses them!
09:50:07 <nitrix> If you use IO for everything, you got it all wrong.
09:50:08 <merijn> maerwald: Idris is not anywhere near ready for real use, purescript I don't know anything about
09:50:09 <maerwald> aha, who me where people use extensible effects then
09:50:21 <merijn> maerwald: Extensible-effects, as-is, sucks
09:50:23 <nitrix> maerwald: Are all your functions in IO ?
09:50:24 <maerwald> nitrix: you don't seem to get my point, sorry
09:50:27 <hpc> extensible effects are a specific case of the general concept of restricted IO
09:50:39 <maerwald> nitrix: yes, becasue they deal with the filesystem
09:50:40 <merijn> The performance is terrible and it can't cover all of the functionality of transformers
09:50:48 <hpc> which don't get used because you usually don't need your effects to be extensible
09:50:51 <maerwald> nitrix: but that doesn't mean they should call network crap too, which they can technically though
09:50:55 <hpc> or polymorphic or whatever
09:50:56 <maerwald> because IO allows it
09:50:57 <nitrix> maerwald: I have written a filesystem myself and they aren't IO.
09:51:11 <maerwald> nitrix: you are not reading what I am saying
09:51:15 <ConsciousCreator> maerwald: Okay...so what you're saying is that there are potential security vulnerabilities in the way Haskell does IO... Is that correct?
09:51:39 <nitrix> maerwald: You're making an unbased claim and feeding the new guy with it.
09:51:44 <merijn> ConsciousCreator: No, this entire argument is a rather ideological discussion
09:51:53 <dolio> I don't see how IO being divided into a bunch of separate things would have anything but a marginal effect on most of my Haskell code.
09:51:58 <nitrix> maerwald: At the least appropriate time, mind you.
09:52:03 <maerwald> ConsciousCreator: that would be a bit far-fetched, no... it's just that default IO in haskell is awkward, because it makes it hard to reason about a program (e.g. does the function just read from a file, does it write to a file, does it do network calls..?)
09:52:24 <merijn> ConsciousCreator: IMO maerwald I *way* exaggerating a very marginal point
09:52:27 <maerwald> nitrix: I wrote a filemanager in haskell and there is a lot of IO code, because I _deal_ with the filesystem
09:52:43 <maerwald> and IO there sucks, because I want to say "this will only write to the filesystem, nothing else"
09:53:00 <nitrix> maerwald: So does mine and doesn't have your issue. It's a fallacious argument.
09:53:02 <maerwald> and I don't think that's a marginal point at all
09:53:03 * hackagebot scalpel 0.3.1 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-0.3.1 (fimad)
09:53:12 <maerwald> nitrix: what do you mean with "doesn't have your issue"?
09:53:21 <merijn> maerwald: It is when someone is asking "should I learn haskell instead of C/java/whatever"
09:53:25 <ConsciousCreator> It's really great to be getting these diverse perspectives from this discussion....I'm learning a lot already...
09:53:30 <nitrix> maerwald: I have a single function of type IO in my entire fuse-based file-system.
09:53:33 <maerwald> merijn: he asked about my opinion
09:53:43 <hpc> ConsciousCreator: wait until we actually start teaching things ;)
09:53:47 <maerwald> nitrix: I am not writing a filesystem
09:53:49 <ConsciousCreator> I really like the way you guys can have an open and rational discussion...
09:54:01 <maerwald> nitrix: you don't really seem to get what I am saying, so I will stop arguing with you
09:54:01 <merijn> maerwald: All those languages are orders of magnitude worse...and the languages that can do better are not realistic options, they only become interesting after learning a bit of haskell
09:54:05 <nitrix> maerwald: Even if you interface with a filesystem, it's the same deal.
09:54:16 <ConsciousCreator> hpc:  :-)
09:54:42 <Welkin> ConsciousCreator: why the ellipsis at the end?
09:54:50 <maerwald> nitrix: if you use the low-level posix functions, you are bound to IO everywhere (for reading and writing files). Can you follow that far?
09:54:52 <Welkin> it makes you seem sarcastic
09:55:28 <maerwald> nitrix: https://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-IO.html here you go
09:55:44 <nitrix> maerwald: This discussion has become not enjoyable. You're welcome to continue it with somebody else.
09:56:42 <ConsciousCreator> Welkin:  ellipsis?
09:56:44 <Welkin> lol nitrix 
09:56:45 <maerwald> And this is how idris does it https://github.com/idris-lang/Idris-dev/blob/master/libs/effects/Effect/File.idr#L119
09:56:49 <maerwald> which is way different
09:56:49 <Welkin> ConsciousCreator: your "..."
09:57:18 <maerwald> "Eff Bool [FILE_IO ()]" is more descriptive than just "IO ()"
09:57:54 <hpc> usually in haskell you would write some new type, and use Filesystem () which is restricted to FS operations
09:57:56 <ConsciousCreator> Welkin:   I wish I understood what you are referring to, but I'm not following... What are you referring to?
09:58:04 * hackagebot airship 0.6.0 - A Webmachine-inspired HTTP library  https://hackage.haskell.org/package/airship-0.6.0 (reiddraper)
09:58:06 * hackagebot cgrep 6.6.7 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.7 (NicolaBonelli)
09:58:09 <maerwald> hpc: which is still awkward imo
09:58:28 <hpc> perhaps
09:59:03 <hpc> usually the domain of IO covered by a library is more complicated than "this touches files", but now i understand your argument
10:00:08 <ConsciousCreator> maerwald:  So, in your comment about IO, you were basically saying that the nature of Haskell being a high-level language results in there being somewhat of a "disconnect" between the programmer and the low-level details of what is happening "beneath the hood", so to speak...?
10:00:18 <hpc> i can see some neat places for the idris approach to go though, which you wouldn't be able to do in haskell
10:00:21 <merijn> I understand his point, I just think it's completely useless/inappropriate to bring up to beginners asking about haskell when they haven't even started
10:00:23 <hpc> like encoding chroot in the type system
10:00:24 <maerwald> also see purescript http://www.purescript.org/learn/eff/
10:00:38 <ConsciousCreator> maerwald:  And, if that is the case, isn't this true of basically all high level languages?
10:00:41 <hpc> and being able to infer that two sets of file operations are acting on different directories
10:00:56 <dolio> If you want to replicate Idris' system, you could do it like mtl is analogous to a system of various pure effects.
10:01:09 <dolio> Then IO is a concrete implementation of the abstract effects you're programming to.
10:01:14 <merijn> ConsciousCreator: No, his point is that he wants even tighter restrictions on what code can do, so you can not only see that code is doing IO, but exactly WHICH IO it is doing (file access, network access, etc.)
10:01:15 <maerwald> ConsciousCreator: no, it's just an implementation thing that can be fixed by better abstractions
10:01:16 <Cale> ConsciousCreator: maerwald is talking about something built in Idris using even higher level type system features than Haskell supports
10:01:17 <dolio> But your functions specify exactly the things you need.
10:01:29 <dolio> And it is only specific to IO at the edges.
10:01:54 <hpc> maerwald: unfortunately the bar is set so far below haskell that it's hard to argue haskell's approach is bad, even though it can be improved
10:01:57 <dolio> If this is such a big deal, and the majority of your program is dealing with it, it might even be worth while.
10:02:05 <maerwald> hpc: I'm whining at high-level ;)
10:02:09 <hpc> :D
10:02:10 <dolio> Even as a one-off thing.
10:03:14 <ConsciousCreator> merijn:  Thanks, now I understand...
10:04:12 <ConsciousCreator> maerwald:  I understand... It frustrates you that it could have been implemented better... somewhat of a "design flaw"...
10:04:15 <merijn> ConsciousCreator: And I was complaining that in, e.g., java/c/c#/whatever you can't even restrict whether functions do IO or not at all, so despite his complain having SOME merit, it's not really an argument against haskell
10:04:40 <merijn> ConsciousCreator: I don't think haskell is the "perfect" language either, it's just in a sweet spot of "good" and "usable"
10:04:40 <Cale> As much of a proponent as I am for dependent types, I haven't seen too many situations in which I felt effect types would be better than some curated monads with appropriate names given the effects that are allowed, though I can imagine that in something like a file manager, you might really want something of that sort -- especially with regard to the set of files which any given piece of code is allowed to touch.
10:04:49 <maerwald> ConsciousCreator: yeah and there are languages (not many though) that do it better, so when I want to sell haskell, I usually go another route than "oh, we have IO!"
10:05:13 <merijn> The "better" languages are experiments who only just started, they're not serious contenders for "real world" development at the moment, due to instability, lack of libraries, etc.
10:05:33 <merijn> ConsciousCreator: So what haskell lacks in platonic perfection it makes up in library support/etc.
10:05:38 <maerwald> Cale: I want more! I want to tell the RTS which directories it can touch in a given function! haha
10:05:39 <dolio> You don't even need dependent types to implement an effect system, except possibly to implement the finite set part at the type level.
10:05:58 <ConsciousCreator> merijn:  In terms of commercial usability, in which applications does Haskell tend to be used most...?
10:06:00 <maerwald> but I'm not sure that can be sanely done even
10:06:17 <Cale> maerwald: It seems doable to me
10:06:24 <Cale> (with dependent types)
10:06:41 <maerwald> e.g. when running my test suite, I always think "what happens if the tests are actually broken? will it rm -rf /*?" :o
10:06:46 <Cale> You have actions parameterised on sets of paths.
10:06:57 <hpc> maerwald: you're making me want to write some crazy type-level IO stuff in idris now
10:07:09 <maerwald> as merijn said it's far from being production ready
10:07:19 <maerwald> and not many libraries
10:07:24 <maerwald> and too much flux, and...
10:07:39 <merijn> ConsciousCreator: The biggest users of haskell are banks/financial industry, and, I suppose nowadays Facebook
10:07:47 <Xandaros> maerwald: It's not like there are big companies that ship shell scripts which potentially delete everything, or anything like that…
10:07:49 <merijn> ConsciousCreator: Facebook is doing a bunch of spam fighting with haskell
10:07:57 <hpc> eve online uses haskell on the backend in a few places
10:08:00 <maerwald> Xandaros: you mean like valve?
10:08:00 <Cale> and then your primitives have types which say which paths are affected, which will depend on their file path arguments
10:08:08 <Xandaros> maerwald: yup
10:08:10 <maerwald> ;)
10:08:14 <maerwald> I know that bug report
10:08:18 <Cale> and then the combinators you use to glue actions together take unions of the sets
10:08:25 <hpc> which i guess makes sense because they are simulating an entire financial industry
10:09:21 <merijn> ConsciousCreator: Things I would consider haskell good at: multi-threaded/concurrent networking/servers, parsers. But honestly, I use it for everything
10:09:36 <merijn> ConsciousCreator: Nowadays I even write my "quick hacks for inside shell scripts" in haskell
10:09:51 <merijn> The only stuff I do in another language is GPUs
10:10:33 <Xandaros> I started enjoying haskell when I wrote a parser in it. It was the first time I was actually able to do that. Parser combinators are blooy amazing.
10:10:44 <maerwald> Xandaros: ah, found it https://git.io/x36Y heh
10:11:04 <maerwald> gotta love shell scripting
10:11:09 <Cale> ConsciousCreator: The company I'm working for is building web applications entirely in Haskell, both for the backend (using snap for the webserver and groundhog to interact with postgresql), and the frontend (using reflex-dom compiled using GHCJS to Javascript)
10:11:38 <danza> Cale, but development on GHCJS is kind of stagnating?
10:11:46 <Cale> danza: How so?
10:12:19 <merijn> Man, I don't get this new idea that's taken root since the Web2.0 bullshit that "less updates/commits" == stagnating
10:12:29 <Welkin> what's dat?
10:12:34 <dolio> Is it that recent?
10:12:39 <merijn> Maybe there's not that many commits because it's mostly finished?
10:12:41 <Welkin> you mean the github "streak" crap?
10:12:56 <dolio> I guess web 2.0 isn't really that recent anymore.
10:12:59 <merijn> Welkin: No, but people going like "library X hasn't been updated in a year, it must be dead"
10:13:00 <Welkin> lol
10:13:06 <EvanR> merijn: it needs to be maintained duh, software slowl disintegrates spontaneously
10:13:07 <merijn> dolio: Man, Web2.0 is like a decade old by now
10:13:08 <danza> Cale, maybe i was just misled by this conversation https://github.com/ghcjs/ghcjs/issues/481#issuecomment-222155019
10:13:15 <EvanR> its like exponential decay
10:13:16 <Welkin> "web 2.0" is like 2001
10:13:25 <simpson> EvanR: It's true.
10:13:39 <simpson> "In the long run every program becomes rococo - then rubble."
10:13:44 <ConsciousCreator> merijn:  From what I know, in banking/finance the main language used tended to be Fortran...  Is Haskell similar to Fortran ?
10:13:52 <merijn> danza: Tbh, I don't think it's worth updating to 8.0 until 8.0 is actually like cristallized and finished
10:14:06 <Cale> danza: Well, I presume the update to GHC 8 is on its way
10:14:07 <Welkin> I thought "web 2.0" meant being able to add user-generated content to a page, like blog comments and social networking
10:14:08 <dolio> I'm not sure your Fortran statistic is accurate.
10:14:09 <merijn> ConsciousCreator: I would say haskell and fortran have zero in common
10:14:17 <ConsciousCreator> Cale:  Cool :-)
10:14:36 <merijn> ConsciousCreator: Also, I'm talking like hedgefunds/investing, not your daily checkings account :)
10:14:50 <merijn> Yeah, banks don't use fortran, cobol or bust :p
10:15:01 <Welkin> I thought banks used java
10:15:05 <ZelteHonor> Physicist use Fortran
10:15:08 <dolio> Even a lot of Cobol got replaced by Java.
10:15:09 <ConsciousCreator> merijn:  Ahh, I see, investment banking... 
10:15:18 <Xandaros> Welkin: Yes. We are now doing Web 3.0 - aka semantic web
10:15:22 <merijn> ZelteHonor: nuclear powerplants use fortran >.>
10:15:44 <Welkin> merijn: thankfully they don't use javascript
10:15:53 <ZelteHonor> merijin: I don't know. Maybe
10:15:58 <maerwald> async js in a powerplant? xD
10:16:14 <merijn> ZelteHonor: I know this, because my dad (who hasn't programmed in like 4 decades) was asked to come teach Fortran77 (yes, 77, not 95) to people at a nuclear power plant because the engineers didn't know fortran and they couldn't find anyone else with Fortran77 experience...
10:16:29 <merijn> Which, frankly, is a terrifying idea
10:16:29 <maerwald> the root of the most weird type of bugs: async IO
10:17:04 <Welkin> merijn: uh... they can just read a book?
10:17:12 <ZelteHonor> Javasript a world where: [] == -[]
10:17:19 <maerwald> thank god we don't need that crap in haskell, since we have nice green threads
10:17:45 <EvanR> ZelteHonor: wtf...
10:18:04 <maerwald> reasoning about an async js codebase is one of the worst things there are
10:18:18 <ZelteHonor> EvanR: You can try yourself. It's because of course [] == [] is false.
10:18:55 <EvanR> i did, and i came to the same conclusion, which is obviously nonsense
10:19:19 <Welkin> could you imagine silicon valley creating a nuclear power startup?
10:19:26 <Welkin> meltdowns would happen daily
10:19:34 <ZelteHonor> There is actually a big Diagram how is == working in javascript. And there is some leak like that in the definition.
10:19:49 <maerwald> ZelteHonor: don't people use === these days?
10:19:53 <maerwald> I forgot if there is ====
10:19:59 <Welkin> yes
10:20:01 <Welkin> er
10:20:03 <Welkin> no
10:20:05 <Welkin> just ===
10:20:07 <ZelteHonor> I thought that === was for PHP?
10:20:16 <simpson> Both languages have them.
10:20:20 <maerwald> ZelteHonor: nah, I use it all the time
10:20:26 <maerwald> because == is more broken
10:20:31 <glguy> The horrors of JavaScript and PHP and Fortron are off topic in #haskell
10:20:54 <maerwald> glguy: we are evaluating the differences to haskell, so it's sort of on topic
10:21:00 <maerwald> as long as we don't get sidetracked too far
10:21:04 <xa0> maybe it's a mark of a ghastly language, to have ===
10:21:09 <Akii> ["1","2","3"].map(parseInt); is the best
10:21:18 <Cale> maerwald: Yeah, the best way to do asynchronous programming in Javascript is to compile from Haskell, and use Haskell threads :P
10:21:27 <ZelteHonor> There is a blog post called PHP:  Fractal of bad design. It's actually pretty funny as long as I don't have to write PHP.
10:21:40 <Akii> love that post
10:21:45 <Xandaros> ZelteHonor: That's a good one
10:21:47 <suppi> Reason has ===
10:22:07 <maerwald> Cale: can't even convince people here to use haskell for the backend... for the frontend, even less. Because no one else know haskell here, so...
10:22:27 <Welkin> that is not an excuse
10:22:29 <ZelteHonor> Do anyone here have any experience with FGL?
10:22:35 <Welkin> if you don't know something, you can learn it
10:22:41 <Welkin> often very quickly, even a matter of days
10:22:55 <Welkin> what is the real excuse?
10:23:08 <Welkin> they are afraid of change?
10:23:34 <simpson> Welkin: "Software totemism" was a concept that I liked for that.
10:23:39 <djbeau> ZelteHonor: are you referring to the graph library? I have used it a bit
10:23:47 <maerwald> Welkin: oh, it's a pretty good excuse, because you have to train ~10+ people who never have touched functional programming to become haskell-hackers in... I dunno, 6 months +?
10:23:52 <maerwald> you know how much money that is?
10:23:57 <Welkin> 6 months?
10:24:01 <maerwald> yes
10:24:02 <Welkin> more like 6 days
10:24:05 <maerwald> lol no
10:24:06 <ZelteHonor> It's because I have a big graph. It can't fit in memory. So I am deleting it at the same time that I am creating it. Because of laziness It does not actually delete the edges. And it fills my memory. But If I use deepseq to force it to delete the node it became super slow.
10:24:08 <mkloczko> You need some time for some lessons to sink.
10:24:16 <ZelteHonor> djbeau: Yes this one.
10:25:17 <djbeau> ZelteHonor: I haven't used it that aggressively to provide any tips on your specific problem
10:25:31 <merijn> ZelteHonor: How big is your graph?
10:25:49 <EvanR> Welkin: even 6 days is something many places cant spend
10:26:11 <ZelteHonor> Well the graph itself is not that big. But I have huge label.
10:26:24 <merijn> ZelteHonor: Incidentally, which algorithms are you running?
10:26:41 <maerwald> the point is... you can tell a group of javascript developers to switch to php or "this other language that's pretty much just another js" or to switch to another framework. Switching from js to haskell for non-academics is a pretty tough thing. Believe it or not
10:26:48 <maerwald> and productivity will be down the sinkhole for a long time
10:27:13 <simpson> It's because they don't know anything besides JS.
10:27:21 <simpson> Not because Haskell is hard.
10:27:27 <EvanR> maybe that principle works in the other direction
10:27:41 <maerwald> it doesn't
10:27:42 <EvanR> ask them to switch to something even worse than js / whatever, and productivity skyrockets?
10:27:56 <dolio> JavaScript programmers write in manual CPS constantly.
10:28:16 <ZelteHonor> merijn: Algorithms? My graph is a directed acyclic graph. And for each node I have for label the sum of the label from incoming edge.
10:28:21 <maerwald> simpson: haskell is too hard for some people, yes
10:29:04 <dgpratt> does anyone else use nixos?
10:29:10 <simpson> maerwald: I mean, *programming* appears to be hard for some people, regardless of language. Haskell's not especially hard.
10:29:15 <merijn> ZelteHonor: Yeah, but I meant, which algorithms do you plan to run on the graph?
10:29:18 <maerwald> simpson: yes it is for some people
10:29:40 <maerwald> I know several who tried and gave up, because it was too hard for them, required learning too much abstraction and concepts
10:30:07 <EvanR> C / js requires no learning, thats why its great... wait
10:30:32 <ZelteHonor> merijn: To be honest none. I have no interest the graph itself. All I care about is the label of the last node.
10:30:45 <maerwald> simpson: I know a lot of haskellers make general conclucion based on their own learning experience and I think that's a problem
10:31:18 <Welkin> in haskell more of the work is front-loaded
10:31:37 <Welkin> whereas in C or js you can get started immediately... and subsequently have terrible practices
10:31:43 <ZelteHonor> I am even thinking of switching away from the graph to try something else. For now I have to chose between incredibly slow or fills the memory.
10:31:50 <simpson> maerwald: Sure. Like all other Haskellers, I did the same thing; I merely came to a different conclusion, which is that Haskell is not especially hard or tricky; it's not a special snowflake in the wider programming ecosystem.
10:31:51 <EvanR> i learned haskells stuff gradually
10:32:25 <maerwald> simpson: not especially hard or tricky for YOU
10:32:29 <mkloczko> It is not, but most people are used to programming in imperative languages. Switching to a different paradigm takes time.
10:32:48 <ZelteHonor> dgpratt: Unfortunatly no but I think that it looks really interesting.
10:33:05 * hackagebot hsyslog 3 - FFI interface to syslog(3) from POSIX.1-2001  https://hackage.haskell.org/package/hsyslog-3 (PeterSimons)
10:33:06 <simpson> maerwald: Sure. I also know that I'm an idiot that can't think about more than five lines of code at a time.
10:33:44 <EvanR> haskell has been enlightening for learning more about how "most people" think of programming
10:34:01 <maerwald> mkloczko: it's not just the paradigm, but the abstraction and the concepts involved. It's too much for some people to digest and they don't have the patience for it.
10:34:03 <EvanR> when you try to explain it to them
10:34:15 <mkloczko> mearwald: agree
10:34:22 <maerwald> you don't need much patience to learn javascript, you just do stuff, sometimes it breaks and then you look why
10:34:28 <maerwald> there's not much you need to know up-front
10:34:31 <maerwald> which does not apply to haskell
10:34:46 <dolio> It doesn't?
10:34:50 <maerwald> nope
10:34:51 * dgpratt is thinking that perhaps he should stick with something more mainstream, e.g. ubuntu
10:35:00 <Welkin> the real difference is the focus on types, and not thinking about your program as a simple state machine
10:35:17 <EvanR> do people think of their program as a state machine? 
10:35:22 <ZelteHonor> dgpratt: I don't like Ubuntu. It keep crashing on me.
10:35:40 <Welkin> lol dgpratt, ubuntu is my default, but only because I have been too busy to learn nixos
10:35:47 <dgpratt> what do you use, ZelteHonor?
10:35:49 <Welkin> ubuntu us all kinds of broken though
10:35:52 <dolio> I'm pretty sure I learned mostly by doing stuff.
10:36:00 <dolio> Like my homework.
10:36:05 <EvanR> in haskell you just do stuff
10:36:10 <EvanR> in ghci, it works
10:36:18 <EvanR> or you get an error
10:36:19 <ZelteHonor> dgpratt: Archlinux. It's suppose to be unstable but funnily I never had any problem.
10:36:36 <dgpratt> arch is on my short list
10:36:36 <EvanR> most people do the same thing with js, debug console
10:36:48 <ZelteHonor> Also there is stack and a lot of Haskell package right in the official repository.
10:37:18 <Welkin> there are ways to convince anyone to do what you want them to do
10:37:21 * EvanR is annoyed by the linux distro discussion
10:37:30 <maerwald> dolio: you can write a standard parser in javascript with just knowing for loops and string splitting (and that's what people use). If you do it in idiomatic haskell, you need to know a bit more and first learn functors, applicatives, monads and so on
10:37:35 <Welkin> all you need to do it start by agreeing with them, and then make them think that your idea is their idea
10:37:36 <maerwald> that's quite a difference
10:37:42 <Welkin> make them believe they came to the conclusion on their own
10:37:43 <simpson> maerwald: Isn't Read idiomatic?
10:37:48 <merijn> simpson: Hell no
10:37:51 <EvanR> Welkin: thank you d. trump
10:37:56 <ZelteHonor> EvanR: I do think of my program as a machine but no necesserely a state one.
10:38:00 <merijn> simpson: Do you have any clue how incredibly shit the performance of read is?
10:38:05 * hackagebot lens-family-th 0.5.0.0 - Generate lens-family style lenses  https://hackage.haskell.org/package/lens-family-th-0.5.0.0 (DanBurton)
10:38:11 <Welkin> so you can convince your company to use haskell
10:38:17 <simpson> merijn: I didn't claim that it was fast, only that it used Haskell idioms.
10:38:18 <dolio> Well, I didn't have to write any parsers for the homework I did, I think.
10:38:26 <dolio> I was just solving AI problems.
10:38:27 <Welkin> just don't use logical arguments, because logic and humans don't mix
10:38:37 <dolio> Somehow I managed.
10:40:53 <dolio> Applicative didn't exist back then, of course. So obviously the conceptual overhead was much lower.
10:41:38 <Welkin> back in dolio'd day...!
10:41:50 <ZelteHonor> Can Monad be seen as a context of computation? Like Maybe is a context of computation that can fail, List is a context of computation with non-determinism, IO is a context of computation with side effect?
10:42:17 <djbeau> dgpratt: I do use nixos daily
10:42:21 <ZelteHonor> I use this one to explain Monad to friend who son't write Haskell and they seem to understand it.
10:42:27 <dolio> Then, of course, when I showed up here, there was a 13-ish kid who knew more about everything than I'd know for years.
10:42:29 <johnw> ZelteHonor: sure, it can be, but it's just one way and may not exactly fit every case
10:43:05 <johnw> the Identity monad isn't a "computation" at all
10:43:07 <ZelteHonor> johnw: Do you have example that does not fit? I've found this one to be pretty universal.
10:43:33 <ZelteHonor> No?Isn't the identity a computation with no special context?
10:43:41 <johnw> no, it's just a value
10:43:49 <johnw> Identity Int is equivalent to just Int
10:44:03 <c_wraith> ZelteHonor, best to think of monad as a pattern of composition. it lets you compose some things. 
10:44:21 <johnw> yes, the pattern of composition description has some good insights
10:44:28 <maerwald> ZelteHonor: some people talk about "effect flow" vs the "result flow" afair, which is also nice to explain the difference of applicative and monad, but that's also through blurry glasses
10:45:00 <maerwald> but that's fine, just tell them it *can* be more complicated than that
10:45:40 <maerwald> coming up with a 100% accurate wording will probably result in no one understanding you :P
10:46:06 <Akii> I think those approximations to what a Monad is are really helpful
10:46:23 <Akii> good enough to get going until you really need to understand it
10:46:27 <Akii> lazy evaluation of sorts
10:46:42 <maerwald> ZelteHonor: http://stackoverflow.com/a/17412969/2976251 there he talks about effects vs results, which I find nice
10:46:55 <maerwald> but in the end, it's just a typeclass...
10:47:21 <c_wraith> maerwald, somehow I knew you were going to link to my answer there. 
10:47:33 <maerwald> c_wraith: is that yours?
10:47:36 <maerwald> very nice
10:47:50 <ZelteHonor> Yeah. Haskell transform mathematical concept into interface for programming? Is that somewhat correct?
10:47:59 <maerwald> I even bookmarked it
10:48:07 <c_wraith> yep. I agree that effects and results are messy and fuzzy. I just don't know better words to communicate those ideas. 
10:48:32 <maerwald> haven't seen a better answer for giving an intuitive feeling of the difference of monads vs applicatives
10:48:36 <EvanR> the issue with monad wording is that it makes it even more complex than it really is especially for stuff like Identity, Maybe, List
10:48:37 <thoughtpolice> dolio: sorear?
10:49:01 <EvanR> Reader
10:49:11 <Welkin> dolio: lol, a kid? you mean benzrf?
10:49:15 <dolio> thoughtpolice: Yeah. Now he's minimizing Turing machines that prove upper bounds on the busy beaver numbers that ZFC can prove the value of.
10:49:31 <thoughtpolice> Sounds about right.
10:49:45 <thoughtpolice> Welkin: I mean, this was probably close to like, 8-10 years ago now.
10:51:07 <thoughtpolice> tfw you've been in #haskell for like 10 years
10:51:46 <dolio> You can always take comfort in shapr being here longer than you.
10:52:39 <merijn> :p
10:53:06 * hackagebot retry 0.7.3 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.7.3 (MichaelXavier)
10:56:25 <sbrg> I'm not sure if I'm missing something in the documentation, but is it not possible to do partial parsing with megaparsec? I'm using its lexing module to write a lexer and I obv. need to be able to parse a program into a list of tokens. the `parse` function and most other variants just return Either (ParseError ..) a. 
10:56:52 <sbrg> There is `runParser` but that takes a parsing state (which I don't know how to get) and returns a parsing state and an Either. 
10:59:20 <Mateon1> Hello, how do I turn a [Maybe String] into a [String], such that values that are Nothing aren't in the resulting list?
10:59:40 <maerwald> :t catMaybes
10:59:42 <lambdabot> [Maybe a] -> [a]
10:59:55 <Mateon1> Nice, thank you
11:00:05 <quchen> Mateon1: It's also a good exercise to implement this yourself :-)
11:00:05 <Welkin> maerwald: you can search for a function by type signature using hoogle
11:00:15 <Welkin> @hoogle [Maybe a] -> [a]
11:00:19 <EvanR> srhb: megaparsec parsing state appears to be a regular data type exposed to you: https://hackage.haskell.org/package/megaparsec-5.0.0/docs/Text-Megaparsec.html#t:State
11:00:20 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:00:20 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
11:00:20 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:00:22 <Welkin> except use the website
11:00:35 <Welkin> er
11:00:40 <Welkin> Mateon1^
11:01:08 <Mateon1> quchen: I think it might be (map fromJust . filter isJust), but I completely forgot about Hoogle
11:01:51 <dolio> Mateon1: It'd be a good exercise to come up with a nicer definition than that. :)
11:02:07 <dolio> That would work, though.
11:02:11 <sbrg> EvanR: yep, I was actually being kind of silly. The lexeme parser handles whitespace so I can just do (many myParser), etc.
11:02:53 <maerwald> that's a pretty good definition imo, not sure what's the most performant though, but I'd guess it fuses both operations
11:03:15 <dolio> Performance isn't really the issue.
11:03:27 <django_> hey all
11:03:30 <django_> anyone know what this means
11:03:46 <Welkin> django_: boba is your son
11:04:00 <quchen> django_: Please don't paste into this channel … I have a hunch you're preparing a huge paste :-þ
11:04:02 <quchen> ?where paste
11:04:02 <lambdabot> Haskell pastebin: http://lpaste.net/
11:05:10 <shapr> thoughtpolice: he's right
11:05:29 <Mateon1> dolio: I think { foldr (\l acc -> if isJust l then l:acc else acc) [] } (might) be better, but I still don't know the performance caveats fully and I think I read that foldr is bad or something like that
11:06:04 <Welkin> no, your read tah foldl should not be used over foldl'
11:06:07 <Welkin> you*
11:06:10 <Welkin> that*
11:06:37 <Mateon1> I remember something about thunks accumulating in memory for large lists, so maybe
11:06:40 <maerwald> Mateon1: I like your first better, because if then else sucks
11:07:01 <quchen> "sucks" is not a good way to criticise code.
11:07:22 <maerwald> quchen: it's longer and not really haskell-ish where you can use function composition instead
11:07:24 <quchen> Mateon1: I suggest you use more pattern matching. Instead of isJust, why not match on the Maybe value?
11:07:38 <quchen> maerwald: Function composition does not magically make code idiomatic.
11:07:42 <maerwald> and using fromJust is fine if you can prove that it's total in that context
11:07:51 <Mateon1> Possibly, quchen , however how do I case match on a single line?
11:07:53 <maerwald> quchen: I didn't say that
11:08:07 * hackagebot irc-dcc 1.2.1 - A DCC message parsing and helper library for IRC clients  https://hackage.haskell.org/package/irc-dcc-1.2.1 (JanGerlinger)
11:08:10 <Welkin> Mateon1: you don't need to
11:08:13 <quchen> Mateon1: Haskell has multiline support ;-) But you can write things on a single line like so:
11:08:19 <dolio> Mateon1: Yes, the lesson is that if you see both isJust and fromJust, pattern matching is often nicer.
11:08:25 <quchen> > case Just () of Just () -> "just"; Nothing -> "nothing"
11:08:27 <lambdabot>  "just"
11:08:29 <Welkin> just use a where clause to define your folding function
11:08:45 <Welkin> being on "one line" is not the goal
11:09:04 <Mateon1> Welkin: In IRC, I mean. I obviously don't write Haskell oneliners in real code. Maybe some in GHCi
11:09:56 <django_> woops
11:09:59 <django_> i thought i had pasted it
11:10:07 <django_> this: https://bpaste.net/show/a1443b7b59bb
11:11:10 <quchen> Mateon1: Here's one way to write that function: > let quchenCatMaybe [] = []; quchenCatMaybe (Just x:xs) = x : quchenCatMaybe xs; quchenCatMaybe (Nothing:xs) = quchenCatMaybe xs in quchenCatMaybe [Just "hel", Nothing, Just "lo", Just " world"]
11:11:24 <quchen> Now try using foldr instead of explicit recursion. :-)
11:11:58 <dolio> I think the nicest way to write it is the way catMaybes is actually written. But you don't often run into other situations like it.
11:12:16 <mkloczko> I really don't get what's wrong with using (map fromJust . filter isJust) 
11:12:16 <django_> quchen, wasnt that long
11:12:17 <django_> 1 sentence
11:12:47 <maerwald> mkloczko: nothing, they just don't like that he's using fromJust I think, but it's fine there
11:13:00 <quchen> dolio: Ah, list comprehensions, I always neglect those
11:13:01 <maerwald> and yeah, the actual library definition is pretty nice
11:13:05 <mkloczko> And the solution used in Data.Maybe is nice, but I don't see how is it really better. More succint perhaps.
11:13:26 <Mateon1> > matCatMaybe = foldr (\l acc -> case l of Just v -> v : acc; Nothing -> acc) []; matCatMaybe [Just "He", Just "l", Nothing, Just "lo"] -- ?
11:13:28 <lambdabot>  <hint>:1:13: parse error on input ‘=’
11:13:37 <Mateon1> > let matCatMaybe = foldr (\l acc -> case l of Just v -> v : acc; Nothing -> acc) []; matCatMaybe [Just "He", Just "l", Nothing, Just "lo"] -- ?
11:13:41 <lambdabot>  <hint>:1:143:
11:13:41 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:13:49 <Mateon1> Meh, I suck at this
11:14:10 <Welkin> Mateon1: just write it on lpaste
11:14:16 <quchen> Mateon1: "in" instead of the last semicolon. :-)
11:14:19 <Welkin> @where paste
11:14:19 <lambdabot> Haskell pastebin: http://lpaste.net/
11:14:32 <Welkin> Mateon1: you can run your lpaste code on lambdabot 
11:14:44 <quchen> Welkin: Wat?
11:14:53 <quchen> How? Since when?
11:14:54 <Mateon1> Welkin: Really..?
11:14:55 <ConsciousCreator> Thanks for your explanations, guys...
11:14:59 <ConsciousCreator> Really appreciate it.
11:15:01 <Welkin> was it removed?
11:15:06 <Welkin> I thought benzrf added it
11:15:06 <ConsciousCreator> Need to get to sleep now :-)
11:15:09 <quchen> Welkin: I don't know, I've never heard of it
11:15:11 <Welkin> I have seen him use it
11:15:15 <ConsciousCreator> 4am here in Melbourne, Australia
11:15:40 <quchen> Welkin: I gotta go, but please do @tell me when you find out! :-)
11:16:05 <ConsciousCreator> Ciao y'all.
11:16:10 <Mateon1> @help letlpaste
11:16:11 <lambdabot> letlpaste <paste_id>. Import the contents of an lpaste.
11:16:19 <Mateon1> Didn't know about that one
11:17:10 <mjrosenb> how old is that feature?
11:17:25 <Welkin> not that old
11:17:32 <Welkin> it has been around since last year
11:18:07 * hackagebot hledger-lib 0.27.1 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-0.27.1 (SimonMichael)
11:18:09 * hackagebot hledger 0.27.1 - Command-line interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-0.27.1 (SimonMichael)
11:18:11 * hackagebot hledger-ui 0.27.5 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-0.27.5 (SimonMichael)
11:23:34 <malorie> hi all. I'm using Aeson and just decided to use the pretty-printing drop-in-replacement for encode, but GHC suddenly isn't finding the ToJSON instance for my type anymore. any idea what's might causing this?
11:24:04 <ZelteHonor> This looks funny: https://github.com/fokot/howerpoint
11:24:16 <dolio> mkloczko: The reason is that testing a predicate for a boolean value and then doing something that will only be well defined in the event that you guard it appropriately by the boolean (which cannot be checked) is generally a poor way to design things.
11:24:47 <dolio> In this case it is so simple as to be obviously correct.
11:25:29 <dolio> Pattern matching allows the test to give you the information in a way that the ill-defined situation cannot occur.
11:28:59 <sbrg> malorie: you need to post code.
11:29:53 <sm> ghc8-compiled executables are about 20M bigger, it seems
11:32:02 <sbrg> sm: in general?
11:32:20 <sm> all the ones I've just built on osx, anyway
11:33:07 <lpaste> malorie pasted “No title” at http://lpaste.net/1730914357644099584
11:33:18 <malorie> sbrg: like so?
11:33:40 <Cale> malorie: I can't even attempt to run that...
11:33:45 <mkloczko> dolio: Well, yeah, it this case we rely on isJust doing it's job, and fromJust getting no other arguments that Just. If isJust suddenly doesn't do it's job, we're in trouble.
11:34:14 <malorie> I've just changed `encode' to `encodePretty', both having type ToJSON a => a -> ByteString
11:34:43 <EvanR> mkloczko: the concern with isJust is the programmer not doing its job
11:34:54 <Cale> malorie: I'm pretty sure that if that was the only change, then the problem isn't new.
11:35:00 <EvanR> if the programmer doesnt do its job, were in trouble
11:35:16 <malorie> Cale: if I change it back, it works again, though
11:35:52 <Cale> malorie: What's the actual complete error message you're getting?
11:35:54 <sbrg> malorie: a small test case that reproduces your error
11:36:01 <sbrg> and that
11:36:04 <Cale> (also, it would be nice if you just posted complete program source)
11:36:18 <lpaste> malorie annotated “No title” with “No title (annotation)” at http://lpaste.net/1730914357644099584#a8213450562130149376
11:36:43 <Cale> okay, is there an instance of that class in your code?
11:37:04 <malorie> yes
11:37:09 <Cale> The fact that there's a package constraint there makes me think you have inconsistent package versions
11:37:26 <Cale> e.g. the package that encodePretty is from depends on a different version of aeson than you're compiling against
11:37:38 <dolio> mkloczko: Practicing things in simple examples helps you do them in complicated ones (hopefully).
11:39:08 <Cale> Usually GHC only starts printing the "aeson-0.7.0.6:" part in types once you have more than one version of the package in use, which is generally a bad idea.
11:39:59 <Cale> (though sometimes unavoidable and okay in cases where the usage is sufficiently encapsulated... in this case clearly not)
11:40:45 <malorie> ah, I see. aeson-pretty is a seperate package, it seems. I'll try adding it to my sandbox
11:42:24 <Cale> Yeah, that may help... though it sounds like it's already installed (but built against the wrong aeson) -- I don't know if the sandboxes normally let in packages from outside, but I suppose if they do, that's probably what's happening.
11:42:57 <mkloczko> dolio: One thing I like to ponder about is the trust programmers place in other's code vs the trust placed in compiler doing it's job. The Data.Maybe solution trusts that the Just x <- ls part will filter out the Nothings out of the list. I can see why one would prefer to use the second solution. Still, I don't think that the first one is bad 'assuming' that both fromJust and isJust do it's job. 
11:43:07 <malorie> yeah, it's not working as I've imagined :\
11:44:04 <Cale> mkloczko: Well, the key is to do it in one place rather than two.
11:44:13 <EvanR> kernel of trust
11:45:11 <Cale> mkloczko: When the isJust and fromJust are right next to each other, maybe it's okay, but they can drift apart, such that to verify that the fromJust isn't going to crash, you need to read a larger portion of the program.
11:45:59 <Cale> If you use pattern matching, then both the test that the thing is of the form Just x, and the extraction of x happen in a single step and can't be separated.
11:47:30 <Cale> This is just something that you get insanely paranoid about if you've ever been working on a large program and had it die with "*** Exception: Maybe.fromJust: Nothing" and no other indication of where or why that happened.
11:48:01 <Cale> Tracking that kind of thing down *really* sucks. Maybe it'll suck a little bit less in GHC 8 now, I dunno.
11:48:37 <EvanR> any time i say or hear "meh, its obvious that this cant crash, despite being not checked by the compiler" i imagine it nonetheless crashing
11:48:38 <Cale> But even so, you don't want that kind of thing making it to production, so if you can structure your code so that you're not using fromJust at all, it's usually a good idea.
11:49:24 <dolio> The thing that the Data.Maybe solution relies on is knowing that list comprehensions don't crash when a pattern match fails.
11:49:37 <EvanR> it could be a mistake or it could be an assumption not holding
11:49:53 <Cale> You could also just write the concatMap directly.
11:50:25 <Cale> > concatMap maybeToList [Just 1, Nothing, Just 2, Just 3, Nothing]
11:50:28 <lambdabot>  [1,2,3]
11:50:32 <Cale> > catMaybes [Just 1, Nothing, Just 2, Just 3, Nothing]
11:50:34 <dolio> There's no way a `Nothing` could end up in the result, at least from the top-level of Maybes.
11:50:34 <lambdabot>  [1,2,3]
11:50:47 <dolio> fromJust does crash, though.
11:53:13 <dolio> I try not to do things that can crash, except if I properly check some other condition, and the relationship between the two isn't machine checked.
11:53:32 <ggVGc> I am rethinking the type of my main updating functions in this sequencer, does anyone have any feeback on this? https://gist.github.com/8ed477fba64efb9f38de6501eb2eb46e
11:53:37 <dolio> Because I am not trustworthy.
11:53:49 <dolio> Or, it is better if I am not required to be trustworthy.
11:53:55 <ggVGc> is what I'm doing reasonable, or am I overcomplicating it?
11:54:04 <Cale> There are certainly cases where you really can't have Haskell's type system guarantee for you that things are not going to crash.
11:54:14 <ggVGc> or is there a better type I could have?
11:54:15 <Cale> But they do tend to be a little more complicated than this ;)
11:54:27 <ggVGc> I'm not sure about the concept of an "updater" function and a flag of how it should be applied
11:55:24 <EvanR> ggVGc: a function that takes a 3-value type to tell it what to do
11:55:37 <EvanR> rather, shouldnt it be three different functions
11:55:49 <ggVGc> EvanR: yeah, maybe. that's what I'm thinking
11:55:54 <ggVGc> well, I don't know honestly
11:56:00 <EvanR> (with the same type, so it can be swaped out )
11:56:01 <mkloczko> dolio, Cale: So in other way this is mostly minimalizing the risk. Using fromJust when you can't assume that you'll receive only Nothings is bad. And a programmer might make a mistake of not checking for it. 
11:56:19 <ggVGc> EvanR: not sure how I could split it up thpugh
11:57:14 <EvanR> where the case that checks that flag is, you use the function corresponding to the choice of branch
11:57:19 <Cale> mkloczko: Right -- basically we avoid using partial functions whenever it's reasonably possible to do so. It's not always reasonably possible, but if it is, then we'd rather write it the way that nothing can go wrong.
11:57:37 <EvanR> thats comes when you refactor to remove the repeated stuff outside the case
11:58:07 <Cale> A good heuristic is that if you needed to check using isJust, then using fromJust probably isn't the right way to go.
11:58:09 * hackagebot feed-gipeda 0.1.0.0 - Simple project template from stack  https://hackage.haskell.org/package/feed-gipeda-0.1.0.0 (sgraf812)
11:58:11 <EvanR> f1 = repeated inner1, f2 = repeated inner2, f3 = repeated inner3
11:58:33 <Cale> fromJust is for the cases where you know by construction that something is going to be found, but this fact isn't something you can encode in the types
11:58:53 <Guest78210> If I have a Pipe Int Int IO (), can i lift it in some way to a Pipe [Int] [Int] IO ()?
11:58:53 <Cale> (or isn't something that you want to encode in the types)
11:59:21 <texasmynsted> I see many frameworks here https://wiki.haskell.org/Web/Frameworks
11:59:44 <texasmynsted> What would be the best choice for a library to consume REST web services?
12:01:22 <ggVGc> EvanR: hm, I don't think I follow you
12:01:53 <EvanR> i dont know how complex your function is, but it sounds too complex to be left like that ;)
12:01:56 <ggVGc> EvanR: you saying I should use the functions from the evaluator directly in the update function rather than pass out a flag on how it should be used?
12:02:26 <EvanR> instead of passing a flag, use one of the three functions. if the flag is from a variable, that variable should *be* the desired function
12:03:01 <EvanR> unless this is serializable, in which case the parser can produce this function as a result
12:03:32 <EvanR> but for regular code a configure parameter like this is not idiomatic imo
12:04:10 <ggVGc> EvanR: conceptually what it is, is "take a state of the sequencer, and a state of a control surface and some general info about application state, and return a new shared state for the main model, and a function that can be used to update a control surface, and an indication of how to apply that function"
12:04:26 <Cale> texasmynsted: Most of those things are HTTP servers, it sounds like you want an HTTP client library?
12:04:43 <ggVGc> EvanR: if I use one of the functions, this ends up in IO though
12:04:45 <EvanR> ggVGc: too complicated
12:05:05 <EvanR> you can apply functions that return IO without being in IO
12:05:40 <Cale> There really isn't a notion of "being in IO"
12:06:03 <maerwald> Cale: aren't we all in IO? :o
12:06:06 <mkloczko> Cale: Ok. It just seemed to me a little bit harsh to exclude the (map fromJust . filter isJust) as a ok function. Maybe it's because I did it myself, dunno.
12:06:13 <EvanR> i think ggVGc knows what im talking about 
12:06:56 <EvanR> :t map fromJust
12:06:58 <lambdabot> [Maybe b] -> [b]
12:07:01 <EvanR> :t catMaybes
12:07:02 <lambdabot> [Maybe a] -> [a]
12:07:10 <EvanR> catMaybes . filter isJust ?
12:07:21 <EvanR> (useless but safer than using map fromJust
12:07:25 <Cale> catMaybes . filter isJust = catMaybes
12:07:30 <EvanR> right
12:07:54 <maerwald> EvanR: map fromJust is perfectly safe there
12:07:55 <EvanR> all three are the same, and the one with map fromJust seems the silliest
12:08:03 <Cale> Of course, if you're implementing catMaybes, that doesn't get you anywhere
12:08:09 * hackagebot feed-gipeda 0.1.0.1 - Simple project template from stack  https://hackage.haskell.org/package/feed-gipeda-0.1.0.1 (sgraf812)
12:08:18 <Cale> concatMap maybeToList  is a possibility
12:08:21 <EvanR> its the only one with a partial function
12:08:47 <Cale> (\xs -> [x | Just x <- xs]) is another option
12:08:58 <maerwald> the definition is total, it doesn't matter whether it uses a partial function inside in a safe way
12:09:10 <EvanR> its not "inside" here... 
12:09:23 <EvanR> its also not a definition
12:09:28 <EvanR> its loose code
12:09:41 <maerwald> no
12:09:47 <EvanR> its not good style to use this code somewhere instead of catMaybes
12:09:59 <maerwald> uhm, he tried to implement catMaybes
12:10:11 <EvanR> oh
12:10:17 <maerwald> no one wanted it to use instead of catMaybes
12:10:25 <maerwald> but the definition is *fine*
12:10:38 <Cale> The definition is okay, but you can avoid the fromJust
12:10:47 <Cale> (and so you probably should)
12:10:50 <dolio> Cultivating habits that don't allow making mistakes is something that matters.
12:11:09 <maerwald> using unsafe functions in a safe context is not a bad habit
12:11:13 <Cale> Any time that you can easily avoid using fromJust, you should avoid it.
12:11:16 <EvanR> your entire program is a series of definitions, if you use partial functions in each one, you will probably screw up ;)
12:11:35 <EvanR> even the lowest level stuff can be made as safe as normal code
12:11:48 <EvanR> assuming either can be made safe
12:12:12 <Cale> maerwald: It is a bad habit because your code becomes harder to understand since there will be many other conditions that are required to hold which aren't documented in the type system
12:12:17 <maerwald> Cale: I'd rather have GHC implement a totality checker instead of worrying about that. 
12:12:35 <maerwald> Cale: I think the given definition is pretty easy to understand
12:12:39 <Cale> So when you go to change things, you can break the program without realising it, and more importantly, without GHC realising it.
12:12:59 <Cale> In this particular instance, given that the isJust and fromJust are immediately adjacent, it might be fine.
12:13:03 <EvanR> isJust fromJust is unnecessarily going through a Bool ...
12:13:09 * hackagebot brick 0.7 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.7 (JonathanDaugherty)
12:13:21 <Cale> But if you program like that in general, then maybe over time those drift apart, and perhaps after a refactor, they're in separate definitions.
12:13:48 <EvanR> @djinn [Maybe a] -> [a]
12:13:48 <lambdabot> Error: Undefined type []
12:13:57 <Cale> and now anyone who is working on the code needs to know that this list of Maybes really can't be an arbitrary list of Maybes, it has to be all Justs or the program will crash
12:14:10 <Cale> (or something similar to that)
12:14:12 <maerwald> Cale: you have "perhaps" followed by "maybe" in your argument
12:14:24 <maerwald> you can write horrible code with and without that pattern
12:14:53 <EvanR> the rule of thumb to use pattern matching instead of bool tests tends to avoid horrible code more than not
12:14:53 <Cale> If we were to add a totality checker, it just wouldn't let you write fromJust in the first place.
12:15:06 <Cale> (most likely)
12:15:24 <mkloczko> Cale: That are two different cases here... Maybe we should discuss about the roles of habit in programming instead. In one context some solutions can be allright, in another they are an abomination. 
12:16:15 <EvanR> @src catMaybes
12:16:15 <lambdabot> catMaybes ls = [x | Just x <- ls]
12:16:21 <maerwald> I don't see how that given definition "map fromJust . filter isJust" will ever need refactoring. And a lot of small pieces of code can be done that way which use e.g. unsafe head.
12:16:23 <Cale> Obviously, for a small enough example which is going to sit there and not be subject to modification after the fact, anything which gets the job done will work
12:16:24 <EvanR> grumble
12:16:51 <thoughtpolice> Well, in reality "just implement a totality checker" isn't exactly easy, first off. And second, you're probably going to have to assist it in determining whether those uses of fromJust, etc are safe anyway. There's no free lunch, you'll almost certainly have to pay for it some way. This is based on my experience with Liquid Haskell; in reality having a
12:16:51 <thoughtpolice> conceptual framework for what it can do is difficult (because its power expands over time), and assisting it, even though it's extremely automated, still requires work.
12:17:04 <Cale> But when you have options which are just as easy to write that don't need any external proof that things don't crash, then you're generally better off sticking with those.
12:17:08 <thoughtpolice> It will be much easier for the checker *and* users to understand the program, even if it is slightly longer or more verbose to deal with these changes.
12:18:12 <EvanR> catMaybes [] = [], catMaybes (Nothing:xs) = catMaybes xs, catMaybes (Just x:xs) = x : catMaybes xs
12:18:15 <maerwald> I wish liquidhaskell was more robust
12:18:27 <thoughtpolice> Naturally, you can sometimes write one liners that are 'completely obvious', which are fine. But it's something that can bite hard if you're not careful, and fixing those things after the fact if they do bite, IMO, tends up being costly later on. So I tend to try and avoid it anyway.
12:18:29 <EvanR> "i see nothing wrong with this definition"
12:19:03 <EvanR> because there is nothing wrong
12:19:20 <Cale> Yeah, there's the recursive definition too :)
12:19:43 <mkloczko> Yep, it can be considered the best one. Small, verbose, nice to read. 
12:20:34 <maerwald> while we were chit-chatting here a java programmer implemented a webserver!
12:20:36 <maerwald> we are too slow
12:20:48 <thoughtpolice> I have quite high hopes for Liquid Haskell, though. It's very easy to hit bugs in it as it stands, currently, but it's definitely got a good power-to-weight ratio.
12:21:32 <maerwald> thoughtpolice: it also has serious performance problems
12:21:41 <maerwald> it blows up on nested lists very easily
12:23:23 <thoughtpolice> Performance has not been an issue for me, except in one case where it went to town on an extremely complex thing with a lot of cases that I haven't looked into yet. I've mostly been using it to verify bit-fiddly things, or modeling low level pointer/byte buffer manipulation, which it's worked quite well at. But using it at scale is more complex anyway
12:23:23 <thoughtpolice> because understanding exactly what it can do currently is a bit difficult, at least to me.
12:23:28 <maerwald> I liked the way it can be used with pointers though, there was a presentation, which was sort of insane
12:24:24 <maerwald> https://www.youtube.com/watch?v=vYh27zz9530 I don't know which minute it was
12:24:45 <thoughtpolice> It's obviously slow (about 10loc/s for the prover IIRC from the numbers I saw at a talk in March) in general, but I haven't hit any huge blow ups otherwise except that one case (and to be fair it's like 2000 lines of deeply nested mutually recursive function calls that are very low level, with no help, so I guess getting confused was inevitable)
12:27:39 <augur> anyone have experience with parsec? maybe know why parsec is having trouble with comments at the beginning of a string?
12:27:53 <hpc> what's the string / parser?
12:28:36 <monochrom> I have experience with analyzing actual code.
12:28:55 <augur> hpc: any string that begins with a comment, it seems :(
12:29:16 <augur> let me try to make a minimal example that i can put in the pastebin
12:33:08 <ron__> Hello.
12:33:40 <ron__> I'm looking at GHC AST, and I see some funny variable names like $dFoo, $WBar. Can you point me to some docs about these prefixes?
12:35:26 <geekosaur> this is probably better asked in #ghc, or on the glasgow-haskell-users mailing list
12:36:03 <ron__> Thanks, will give it a try.
12:37:11 <texasmynsted> Cale, yes I am wanting to consume the REST web services, not host them.
12:37:46 <shachaf> ron__: GHC AST? You mean generated Core?
12:39:14 <ron__> shachaf: The Typechecked AST, not yet core.
12:39:31 <shachaf> Ah, I guess it comes up there too.
12:39:39 <shachaf> Anyway looks like you already got your answer.
12:41:49 <augur> hpc, monochrom: http://lpaste.net/164662
12:42:13 <augur> initial comments seem to be a problem, but trailing comments arent. am i misunderstanding how the token parser works?
12:43:57 <augur> i probably can just parse off some whitespace at the beginning, i guess, to consume all the comments at the start?
12:45:00 <geekosaur> IIRC that's a general rule of the token parser, they expect no leading whitespace and consume trailing whitespace
12:45:50 <monochrom> yes, I think you should skip whitespace at the very beginning. makeTokenParser probably turns comments into whitespace.
12:46:35 <augur> monochrom: indeed, the whiteSpace parser treats comments as whitespace. i guess thats what ill do. that seems to work
12:47:09 <augur> strange that the token parsers expect to start precisely on a token, and consume up to the beginning of the next token
12:47:42 <augur> but i guess that just regularizes things: you construct something like   whiteSpace *> parseit <* eof   for all parsers
12:50:37 <monochrom> yes
12:55:51 <geekosaur> and you have to pick one side or the other; doing both is inefficient and I am recalling it leading to weird edge cases
12:57:07 <ggVGc> EvanR: so, what I'm trying now is to send in a record of partially applied functions(because they need access to some MVars) returning IO, and the return type of the update function will be (SharedModel, [IO()]). Is that reasonable?
12:57:50 <ggVGc> where the pertially applied functions are the "API" for a mode, which can do things like starting recording and updating other control surfaces
12:59:11 <EvanR> ggVGc: a record of functions is an interface, and you can hide values in functions through closures / partial application
13:00:15 <EvanR> for example you can pass the MVar into the records constructor, and you can produce such a record with different functions its not limited to just 1 implementation
13:01:14 <ggVGc> EvanR: exactly, that's what I'm doing
13:01:52 <EvanR> ggVGc: im doing something like this (SharedModel, [IO ()]) thing right now... its signature is like runPoke :: Poke m a -> m -> (m, [IO ()], [Request])
13:02:06 <ggVGc> EvanR: so my main application builds a record of partially applied functions, which gets passed to all the different modes, and they return a list of results of calling those interface functions, which I then evaluate at a later point
13:02:08 <EvanR> Poke is a monad for modifying m
13:02:12 <EvanR> and doing IO
13:02:17 <EvanR> but not with MonadIO
13:02:26 <EvanR> since it is limited to only certain kinds of IO signatures
13:02:35 <ggVGc> haha, I awas just not thinking "I should maybe make a monad instance for the evaluation of the actions"
13:02:42 <ggVGc> just now*
13:03:23 <EvanR> i meant, (a, m, [IO ()], [Request]) ... but actually its an Either because you can also abort
13:05:15 <EvanR> the IO () are "fire and forget" actions like launchMissiles, Request is an action with a result and a way to turn the response into another Poke
13:05:20 <texasmynsted> so anybody have suggestions on best lib for consuming REST calls?
13:05:40 <EvanR> so basically javascript
13:06:10 <texasmynsted> no.
13:06:24 <texasmynsted> not sure if you are talking to me EvnR
13:06:28 <EvanR> the request will happen async while for example a loading screen will animate
13:06:56 <texasmynsted> I am talking about something with no ui.
13:07:19 <texasmynsted> I would simply be writing some code to talk with a remote server via REST
13:07:41 <EvanR> texasmynsted: if consuming REST calls means "do http requests" then wreq exists
13:07:57 * texasmynsted checks on wreq
13:08:12 * hackagebot xdcc 1.0.3 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.0.3 (JanGerlinger)
13:08:25 <EvanR> which seems to be built on http-client
13:09:16 <texasmynsted> wreq looks perfect 
13:09:18 <texasmynsted> thank you
13:13:12 * hackagebot language-nix 2.1.0.1 - Data types and useful functions to represent and manipulate the Nix language.  https://hackage.haskell.org/package/language-nix-2.1.0.1 (PeterSimons)
13:19:07 <ggVGc> I've got this function for generating a "diff" of two records. is there a better and/or less manual way of doing this? https://gist.github.com/b67b2fa985e98f6fc85d64afa753c499
13:19:52 <EvanR> heh...
13:20:02 <EvanR> you need a rank 2 map
13:20:06 <EvanR> somehow
13:20:38 <EvanR> (why is the fold at the bottom ...)
13:20:48 <ggVGc> because I'm stupid and weird
13:21:09 <Welkin> and then god created the multiverse
13:21:17 <ggVGc> not really
13:21:24 <Welkin> and all the little haskellings
13:21:30 <ggVGc> all 5 of them
13:21:33 <EvanR> probablyNotRightMap :: (forall a b . a -> b) -> [forall a . a] -> [forall b . b] ;)
13:21:41 <EvanR> (definitely not right)
13:22:45 <ggVGc> EvanR: I am going back and forth on this dilemma. On one hand I have what I have now, which is the diff function, and the modes just create a new model and then I diff it to propagate changes to ohther control surfaces. But Iwas trying to get the modes to just return the diff function instead, but it turns out it's a pain to write the implementations of the modes then
13:22:46 <EvanR> hmm forall b . (forall a . a -> b) -> [forall a . a] -> [b]
13:22:50 <ggVGc> and it's also less flexible
13:22:54 <ggVGc> so I guess I'm sticking with the differ
13:23:50 <EvanR> i have an immutable, animated, model and the only update that im doing is dt -> m -> m
13:24:06 <EvanR> and so far its hasnt been that bad to compose these for a complex model
13:24:35 <EvanR> i made combinators to do certain things, like share part of a model computed at a higher level to places below
13:25:42 <ggVGc> yeah, this is a new situation for me, because i essentially have two states. One is the actual model of the sequencer, which would be your m. The other is the state of a control surface, which is a bit special. The control surface states need to be synced to eachoter, but only parts of them and only the updated pieces, while the other state is a shared
13:25:55 <ggVGc> and each mode needs to generate both of these
13:26:02 <ggVGc> I haven't had this situation before
13:26:11 <EvanR> eh... why its not all in the same model?
13:27:32 <Gurkenglas> :t let foo phi x = return x <|> (phi x >>= foo phi) in foo -- Do we have this somewhere?
13:27:34 <lambdabot> (Monad f, Alternative f) => (a -> f a) -> a -> f a
13:27:34 <EvanR> anyway its interesting you are making a list, im not sure whats going on
13:27:44 <EvanR> i mean, what the fold is producing
13:28:00 <EvanR> Applicative might be more idiomatic for whatever pattern this is
13:28:12 * hackagebot reactive-banana-wx 1.1.1.0 - Examples for the reactive-banana library, using wxHaskell.  https://hackage.haskell.org/package/reactive-banana-wx-1.1.1.0 (HeinrichApfelmus)
13:28:23 <ggVGc> EvanR: because each control surface mostly updates intependently keeping it's own view state, while sharing a global sequencer state. But in some instances a control surface wants to sync an to either all the other ones or one of them, but this sync should not mess with any of the other state of the other updated surfaces
13:28:55 <EvanR> i toyed with having multiple models at once
13:29:06 <EvanR> i decided on putting it all together in the end
13:29:35 <ggVGc> EvanR: say one surface is showing a note mode, and the other one is showing a trigger mode, and then one of them wants to say "hey, everyone, we should all focus on the same song position now", That makes all the views change target, but they still keep whatever other state they have intact
13:29:48 <ggVGc> EvanR: but I raelly can't in this case. I had it like that at first, and refactored it into this
13:29:54 <ggVGc> because it's inherently different states
13:29:59 <EvanR> "view state" sounds weird
13:30:19 <EvanR> (s1,s2) is two inherently different states ;)
13:30:24 <ggVGc> EvanR: if we a are playing a computer game, and you move your character, it's not so cool if my screen also twirls around to copy your viewing angle
13:30:28 <ggVGc> I just want your position
13:30:48 <EvanR> huh?
13:31:04 <ggVGc> EvanR: you can consider each of my control surfaces as a client, and the sequencer as a server
13:31:43 <EvanR> sure
13:31:57 <EvanR> actor model is the universal fallback
13:32:06 <Welkin> do you systematically fuck the client over with the fine print?
13:32:50 <EvanR> ggVGc: i also start with a combinated model and view, and composing this ended up being a bitch, and also its less flexible because you should be able to view the same thing multiple ways
13:32:56 <EvanR> so i took the view out
13:33:15 <ggVGc> EvanR: well, I don't know another way. Say I have only one big model. How do I then model that differnet control surfaces looking at different aspects of a song, and keeping different states of "last edited note value" etc. if I don't keep separate states?
13:33:43 <EvanR> theres a uniform interface to each control surface?
13:33:55 <EvanR> and they have different internal state?
13:34:03 <ggVGc> yes
13:34:16 <EvanR> and you can create and delete them dynamically?
13:34:26 <ggVGc> not right now, but I will at some point
13:34:39 <EvanR> then ive been using a "barn"
13:34:59 <ggVGc> no idea what that is
13:35:05 <EvanR> the state for control surfaces, buried somewhere would look like Map SurfaceId ControlSurface
13:35:41 <EvanR> which contains all the active surfaces
13:35:48 <EvanR> or existing surfaces
13:36:13 <EvanR> the update for this is to update all of them
13:36:24 <EvanR> which may do nothing
13:36:55 <EvanR> it depends on how each control surface works
13:36:55 <ggVGc> EvanR: the overall state of my aplication is essentially (SharedModel, [ControllerSession]), where ControllerSession has a ControllerState with some IO related things like midi buffer handles. And each mode gets called for each controller session, being given (SharedModel, ControllerState). Then that session is updated with the new state, and the global model is updated with the returned new SharedModel
13:37:30 <EvanR> so the reason you say SharedModel and ControllerState arent part of the same model is because one of them has IO ?
13:37:44 <ggVGc> no, it's because they contain compeltely different things
13:37:53 <EvanR> ... so does the model (s1,s2)
13:38:06 <ggVGc> EvanR: SharedModel holds the actual data of the song. ControllerState holds things like "current focused note for editing"
13:38:20 <ggVGc> EvanR: oh, we are talkinga bout the same thing
13:38:31 <EvanR> right it all seems the same to me, its not the same type, but its all in the model
13:39:01 <EvanR> what youre focused on affects the view
13:39:19 <EvanR> and what the controller effects
13:39:26 <ggVGc> I actually have this type, type SeqModel = (SharedModel, ControllerState)
13:39:31 <ggVGc> which is the main type the modes work with
13:39:31 <EvanR> i wouldnt make it also mess with the model
13:39:51 <EvanR> yes mine is deeper
13:40:02 <EvanR> when i cant be arsed to make a record its more tuples
13:40:03 <ggVGc> I thought you were saying I should do something different
13:40:07 <ggVGc> but I think we are saying the same thing
13:41:09 <EvanR> at the very top i have a type like GameOverable a = GameOver a | Playing a
13:41:25 <EvanR> at each level i have a parameter a, and the full model is a composition of these
13:41:41 <ggVGc> EvanR: my core design purpose of this was to keep modes unaware of single or multiple control surfaces, but still enable them to communicate and sync well together
13:41:49 <ggVGc> and it's worked out pretty well so far
13:42:08 <EvanR> well, introducing the idea of communication might be too much
13:42:22 <EvanR> but will certainly work, actor model
13:42:30 <ggVGc> how do you mean too much?
13:42:41 <ggVGc> it's a very core feature of my program
13:43:13 * hackagebot reactive-banana 1.1.0.1 - Library for functional reactive programming (FRP).  https://hackage.haskell.org/package/reactive-banana-1.1.0.1 (HeinrichApfelmus)
13:43:20 <ggVGc> the only notion of other controllers that a mode has is "Update only myself, update the last other touched one, or update all other controllers"
13:43:31 <EvanR> so what "are" control surfaces?
13:43:39 <ggVGc> midi controllers
13:43:42 <ggVGc> with leds and buttons
13:43:54 <EvanR> a graphical panel
13:43:59 <ggVGc> but they might as well be a GUI on a screen
13:44:00 <ggVGc> right
13:44:00 <EvanR> which does what
13:44:20 <ggVGc> edits my sequencer state through different modes of operation
13:44:32 <ggVGc> essentially differnet views
13:44:37 <EvanR> it edits the sequence?
13:44:47 <ggVGc> well, the song
13:44:53 <ggVGc> the SharedModel
13:44:54 <EvanR> or it edits anything in the app
13:45:05 <EvanR> does it do arbitrary IO?
13:45:08 <ggVGc> no
13:45:14 <ggVGc> that's outside the scope of the modes
13:45:31 <EvanR> right so the idea of an edit doesnt require communication
13:45:35 <EvanR> an edit is like a -> a
13:45:52 <ggVGc> exactly, most of my editing functions are SeqModel -> SeqModel
13:45:59 <EvanR> which are not?
13:46:00 <ggVGc> where SeqModel is (SharedModel, ControllerState)
13:46:24 <ggVGc> oh, smaller ones for editing sequences of notes
13:46:26 <EvanR> heh, they can edit other control surfaces?
13:46:30 <ggVGc> but they are used by the a->a ones
13:46:32 <ggVGc> i
13:46:33 <ggVGc> no
13:46:46 <ggVGc> they can just say "share my last view update with another surface"
13:46:57 <EvanR> "view update" ?
13:47:11 <ggVGc> EvanR: the sahring of state is for things like "I switched track, switch the other surfaces to the same track"
13:47:44 <EvanR> wouldnt that just be a "function" of the core model?
13:47:50 <ggVGc> no
13:47:58 <ggVGc> the core model has no notion of a current track
13:47:59 <EvanR> surfaces can look at the focused track
13:48:03 <EvanR> well why not!
13:48:13 * hackagebot weigh 0.0.1 - Measure allocations of a Haskell functions/values  https://hackage.haskell.org/package/weigh-0.0.1 (ChrisDone)
13:48:33 <ggVGc> because it doesn't make sense. A sequence of notes has no notion of a focus. And also each control surface can focus on different tracks
13:48:37 <ggVGc> except when sometimes they want to syn
13:48:38 <ggVGc> c
13:48:55 <EvanR> ah so there is nothing else besides control surfaces, and youre trying to do it all independently, except its not independent
13:49:18 <ggVGc> it's half-independent, which is why the situation is a bit more complex than usual
13:49:24 <EvanR> right
13:49:28 <ggVGc> and why I have the differ function
13:49:54 <EvanR> if a bunch of surfaces are all agreeing on the idea of a focus, then that really needs to exist outside of them
13:50:06 <EvanR> instead of being copied
13:50:28 <EvanR> imagine if instead of a central database each browser kept an out of date copy, and had to sync
13:50:46 <ggVGc> EvanR: it's the same as if we are collaboratively editing a painting, and we all have diffent colours and brushes, but it's possible if we want to say "Sync everyone to my colour", and then we all keep our current brushes but all get the same clour
13:51:14 <ggVGc> EvanR: they do not agree on one focus. But sometimes I want to sync their focuses
13:51:20 <ggVGc> it's not something that gets kept in sync
13:51:21 <EvanR> wait, so do they also have their own copy of the sequence?
13:51:26 <ggVGc> no
13:51:29 <EvanR> why not! ;)
13:51:31 <ggVGc> they are all editing a main song
13:51:42 <ggVGc> it's essentially a server client architechture
13:51:55 <EvanR> you can go full OO/actor by moving the song into yet another control surface, and control surface becomes an actor
13:52:13 <EvanR> the reason you chose to have a sequence as its own thing is because it makes more sense
13:52:38 <EvanR> and so does centralizing other aspects of the app
13:52:42 <ggVGc> EvanR: https://gist.github.com/26e7ba1b3f13a5c3b6a1927ea891c304
13:52:49 <ggVGc> this is the core model of the program
13:53:39 <EvanR> im not sure im getting the right impression of ControllerStates purpose
13:53:45 <EvanR> is that the song
13:54:14 <ggVGc> EvanR: your web example isn't really applicable I think. It's more that, each browser has it's own scroll offset. Imagine if whenever anyone scrolled on a web site you also got their scroll offset
13:54:38 <ggVGc> but you are both still viewing/editing the same content on the site
13:54:49 * EvanR imagines different web browsers randomly wanting to control each others scroll
13:54:51 <ggVGc> why is a view state a strange thing to you?
13:54:54 <ggVGc> how are you doing your animations
13:54:56 <ggVGc> ?
13:55:13 <EvanR> im making a distinction between a view and a state or model
13:55:17 <Welkin> I have a friend who built a stupid web app that did things like that
13:55:23 <Welkin> it was for trolling
13:55:24 <EvanR> its not merged
13:55:27 <ggVGc> EvanR: that's more the point, but in this instance it's something I want since I am actually in front of all the controllers
13:55:32 <Welkin> you can press buttons and it affects the other people
13:55:58 <ggVGc> EvanR: but to me there is also a distinction of a "state of the data" and "state of the presentation"
13:56:28 <EvanR> ggVGc: eh, ... if presentation is a function of the state, then there is no state there
13:56:40 <Welkin> ggVGc: of course, since the presentation layer on the client anyway
13:56:42 <Welkin> the data is on the server
13:56:57 <ggVGc> for a game the stat of the data would be positions of players, while the state of the presentation would be things like the camera value and if debug information is being presented etc.
13:57:13 <Welkin> and if they have hax
13:57:14 <EvanR> taking inspiration from browsers might not be the best idea for desktop apps
13:57:24 <Welkin> Second Life knows this too well
13:57:30 <EvanR> ggVGc: no, the camera angle is in the model
13:57:33 <Welkin> they can't even keep the presentation straight between players
13:57:43 <EvanR> debugOn is in the model
13:58:01 <ggVGc> EvanR: what if I have two screens and want to have debug view on one and not on the other?
13:58:03 <EvanR> the view being a function is the point
13:58:13 <EvanR> two monitors?
13:58:16 <ggVGc> or if I add 10 more screens and want to view my character from different angles on each of them?
13:58:22 <EvanR> screens?
13:58:28 <ggVGc> yes, monitors
13:58:30 <ggVGc> or whaever
13:58:35 <EvanR> i dont see an issue
13:58:37 <ggVGc> what's the equivaalent of what I am doing
13:59:05 <EvanR> your model now has the notion of screens
13:59:08 <ggVGc> EvanR: how do you have multiple view angles when the viewing angle is in the core model?
13:59:28 <ggVGc> aha, but there are sub-models in that model is what I'm arguing
13:59:48 <EvanR> by "model" i mean everything that is changing through time
13:59:58 <EvanR> and its obviously composed of many pieces
14:00:03 <ggVGc> yeah this is why we are confusing eachother
14:00:13 <EvanR> whats core and whats not is going to change as development goes
14:00:22 <EvanR> whats core isnt that important
14:00:34 <ggVGc> so my actual model is then the tuple of (SharedModel, [ControllerSession])
14:01:23 <EvanR> the view is the decision of how to show that model and its not changing
14:01:39 <EvanR> but you could swap out different views
14:01:46 <EvanR> like console vs graphical
14:02:50 <NemesisD> i'm in some code that needs O(1) snoc on a list. the only operations i need are snoc and toList and I don't want to add a dependency on containers, dlist, etc. is this reasonable: newtype RL a = RL [a]; RL as |> a = RL (a:as); toList (RL as) = reverse as ?
14:02:54 <codedmart> Just trying 8.0.1 now. If I get a `redundant-constraints` warning in 8. Will removing the redundant constraint cause any issue with GHC 7 or GHC 6?
14:03:14 * hackagebot sorted-list 0.1.6.0 - Type-enforced sorted lists and related functions.  https://hackage.haskell.org/package/sorted-list-0.1.6.0 (DanielDiaz)
14:03:39 <EvanR> NemesisD: you can compose [a] -> [a] functions of the form ([x] ++)
14:03:50 <EvanR> and in the end apply to []
14:04:08 <EvanR> that will avoid the final reverse
14:04:23 <NemesisD> EvanR: that's a dlist yeah? would that be more efficient?
14:04:27 <geekosaur> codedmart, I'd imagine problems with "redundant" Applicative or Functor constraint on something with a Monad constraint in versions < 7.10
14:04:30 <c_wraith> codedmart, it's actually pretty easy for that to cause issues with pre-amp ghc
14:04:39 <EvanR> NemesisD: yes, without the dependency
14:05:13 <EvanR> it would be more efficient if you snoc'ed on more than 1 thing at a time
14:05:14 <NemesisD> EvanR: cool! i'll write up a quick benchmark. thanks!
14:05:14 <codedmart> So I can silence the warning for 8 if I want to continue supporting < 7.10?
14:05:39 <c_wraith> you should be able to find a flag to disable that warning 
14:05:40 <NemesisD> EvanR: i never need to do that
14:06:02 <NemesisD> so in that case they'd be equal?
14:06:19 <EvanR> you have to benchmark i dont know
14:06:27 <codedmart> c_wraith geekosaur Thanks!
14:06:28 <NemesisD> fair dues
14:06:33 <EvanR> reversing a long list isnt cheap
14:13:24 <codedmart> c_wraith: Any chance you know how to disable it?
14:13:45 <codedmart> c_wraith: It is included in -Wall apparently.
14:14:59 <geekosaur> -Wno-redundant-constraints
14:15:35 <geekosaur> codedmart ^^
14:15:59 <codedmart> Oh duh. I was trying that but had a typo :) thanks!
14:16:11 <geekosaur> they used to be -f before ghc8
14:18:47 <Welkin> ghc8 is out?
14:19:50 <Adeon> yes
14:20:46 <Adeon> now with less support of windows XP
14:20:47 <EvanR> ggVGc: btw i was just about to do "camera angles" when i realized it should be computed based on toher stuff rather than be explicit
14:21:06 <EvanR> that way they dont have to be in sync
14:21:39 <EvanR> so not only stuff that might seem like view be state, it might not exist ;)
14:28:14 <codedmart> geekosaur: One other question. How do I have that warning only apply to ghc 8?
14:30:38 <geekosaur> codedmart, I think your only option there is using a condition in a cabal file (if impl(ghc) > 8)
14:31:24 <enthropy> #if __GLASGOW_HASKELL__ >= 800\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif -- pretty sure this works too
14:32:31 <geekosaur> presuming CPP is already on, and I thought there were bootstrapping issues with conditionalizing pragmas via CPP (although maybe it works if you enable CPP in the cabal file instead of the source file)
14:32:32 <enthropy> and have the c preprocessor enabled by say having a LANGUAGE pragma above that mess
14:33:22 <geekosaur> because if it's reading pragmas, it would have to stop and start over on seeing LANGUAGE CPP
14:34:18 <enthropy> yes it looks like it could be a problem but it hasn't been one in my experience
14:37:12 <codedmart> geekosaur: I get an error with if impl(ghc) > 8
14:37:13 <hexagoxel> codedmart: This warning is new and was (nonetheless) added to the -Wall set with ghc-8.
14:37:25 <Guest53217> hello, I'm looking for help with attoparsec.  Specifically, I'm having trouble getting it to "skip" parts of a line I don't care about
14:38:05 <hexagoxel> codedmart: the correct syntax is "if impl(ghc > 8.0) {"
14:38:14 <codedmart> Yeah just noticed that thanks!
14:42:32 <EvanR> Guest53217: to skip bytes, you can use skip, word8, skipWhile, take, takeWhile, manyTill...
14:42:42 <EvanR> depending on the skipping criteria
14:43:26 <EvanR> skipping amounts to parsing for the pattern of the skippable stuff then not using the result
14:46:42 <Guest53217> EvanR, thanks for the nod.  Here is my example http://pastebin.com/bvWVDXd5
14:47:15 <EvanR> note that you can use lpaste for haskell code 
14:47:41 <EvanR> http://pastebin.com/raw/bvWVDXd5
14:48:06 <EvanR> Guest53217: anything in here you are having trouble with specifically
14:50:10 <Guest53217> EvanR, I'm not sure what lpaste is, but I'll try and figure it out later... Yes, I have a specific issue.  I *think* that my skipParser is doing what you described...identifying the pattern of that which is to be skipped, and thet my logEntryParser is ignoring it.  However, I just get Right [] when I run it this way.  I can't see why its wrong.
14:51:20 <hexagoxel> @where paste
14:51:20 <lambdabot> Haskell pastebin: http://lpaste.net/
14:51:28 <EvanR> Guest53217: for parsers that dont return anything interesting, you can return () instead of Skip
14:52:22 <Guest53217> EvanR, OK, so I'll change skipParser to :: Parser (), and see if that helps
14:52:28 <EvanR> Guest53217: if you are supposed to skip "skip," it wont work when you are missing a , in your test input
14:52:40 <EvanR> it wont match, and the parsing will fail
14:53:56 <EvanR> Right [] seems weird
14:54:22 <Guest53217> EvanR, I don't understand...where do you see the ','?
14:54:48 <EvanR> ignoreParser
14:55:02 <EvanR> nevermind thats not being used
14:55:39 <Guest53217> EvanR, Oh, I see.  sorry about that--a side effect of my struggle :)
14:55:56 <EvanR> more suggestions, (string "mouse" >> return Mouse) can be written Mouse <$> string "mouse"
14:56:21 <EvanR> <$> = fmap, Parsers are Functors, which gives the nice utility operation fmap
14:56:43 <EvanR> er Mouse <$ string "mouse"
14:56:47 <EvanR> :t (<$)
14:56:49 <lambdabot> Functor f => a -> f b -> f a
14:58:00 <EvanR> Guest53217: your timeParser will fail the whole thing if you dont have the full time in your input
14:58:36 <EvanR> you should have gotten an error message about this when the parser fails
14:58:46 <EvanR> maybe not that description in attoparse
14:58:47 <Guest53217> EvanR, good. thx.  I've taken this entire example from an online tutorial.  I ran it to prove it works, then added "skip" in the test data and tried to make the parser skip it.  Time (and all the other fields) were working before.  My " skip " field seems to have caused all the trouble.
14:59:13 <EvanR> you put skip in between the timestamp
14:59:25 <EvanR> but the parser for skip isnt between the two parts of the timestamp parser
14:59:34 <Guest53217> EvanR, the parser doesn't fail, it returns "Right []"
14:59:54 * EvanR looks up "parseOnly"
15:00:09 <EvanR>  Parser a -> ByteString -> Either String a
15:00:28 <EvanR> if you get Right [], then you are running a Parser [X]
15:00:46 <EvanR> not LogEntry
15:01:59 <Guest53217> EvanR, yes, as I undrestand it, Log is a [LogEntry]
15:02:18 <EvanR> oh, Parser Log
15:02:37 <EvanR> yes, so you used many
15:02:39 <Guest53217> EvanR, I'm running many $ logEntryParser <* endOfLine
15:02:55 <EvanR> it cant fail as such, it will produce [] if it cant even parse one thing
15:03:37 <Guest53217> EvanR, so perhaps there is a better way for me to structure a test run, in that I may see errors?
15:04:03 <EvanR> if you put eofOfInput after both of those, it will fail because you expected the entire file to consist of logs and it wont reach 
15:04:13 <EvanR> endOfInput
15:04:33 <EvanR> many (logEntryParser <* endOfLine) >> endOfInput
15:05:20 <EvanR> er.. many (logEntryParser <* endOfLine) >>= \x -> endOfInput >> return x
15:05:44 <EvanR> youll get "expected end of input" or something
15:05:59 <EvanR> to test the logEntryParser by itself, just run that
15:08:28 <monochrom> w00t new haskell-platform
15:09:35 <monochrom> it comes with stack, too
15:13:17 * hackagebot jmacro 0.6.14 - QuasiQuotation library for programmatic generation of Javascript code.  https://hackage.haskell.org/package/jmacro-0.6.14 (GershomBazerman)
15:13:19 * hackagebot rethinkdb 2.2.0.5 - A driver for RethinkDB 2.2  https://hackage.haskell.org/package/rethinkdb-2.2.0.5 (codedmart)
15:15:06 <zq> is it possible for a gadt ctor to have a variable number of arguments?
15:15:54 <zq> i've tried `data D ins where { D0 :: MoreThanOne ins -> D ins }` where `MoreThanOne '[a] = a; MoreThanOne (a ': as) = a -> MoreThanOne as`
15:15:56 <EvanR> yes, one way is a fun list
15:16:01 <zq> EvanR: how?
15:16:10 <EvanR> http://twanvl.nl/blog/haskell/non-regular1
15:16:48 <EvanR> theres also the printf trick
15:17:16 <zq> EvanR: that's not a vararg ctor
15:17:30 <zq> EvanR: Done has arity 1, More has arity 2
15:17:52 <EvanR> all functions have 1 argument
15:18:56 <EvanR> you cant do varargs in haskell because of that
15:19:01 <EvanR> but there are equivalents
15:19:41 <sbrg> Is there a way to somehow get stack to run a program on a file if the file has changed? I'd like to run happy on foo.y to generate foo.hs and then compile against foo.hs
15:19:44 <sbrg> or should I just be using make?
15:24:03 <glguy> Cabal already knows that it should rerun happy on your .y files
15:24:35 <glguy> or do you mean install an active watch and rebuild when the file is saved?
15:29:02 <sbrg> glguy: how can it know when there is nothing in my cabal file regarding my .y files?
15:29:21 <glguy> There's nothing regarding .hs files generally, either, just modules
15:29:35 <glguy> It knows about .l and .y and .hsc
15:29:40 <sbrg> ah, i see.
15:32:07 <Guest53217> EvanR, just finally realized the answer (which you did give me, but it took a while to get through the ole' brain bucket shell).  I put "split" between the time and date segments of the time stamp.  Doh!.  Thanks for your help.
15:32:21 <sbrg> glguy: what is the correct procedure? I have my Parser.y in src/, and stack build does not automatically run happy on the .y file
15:32:30 <ggVGc> how do I try a function on a list of values and return the value of the first one that matches some criteria
15:32:39 <glguy> sbrg: Make sure you don't also have a Parser.hs file
15:32:53 <ggVGc> i.e "try f on xs, and return f x when f x satisfiest something"
15:33:17 <EvanR> Guest53217: and if you want to fail when one of the lines is wrong instead of getting [], you need to put endOfInput at the end of the top level parser
15:33:57 <EvanR> ggVGc: find . map f ?
15:33:59 <Guest53217> EvanR, will-do, thx
15:34:02 <EvanR> :t find
15:34:04 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
15:34:09 <EvanR> find p . map f
15:34:47 <ggVGc> EvanR: ah yeah, cheers
15:35:02 <sbrg> glguy: Doesn't seem to work. I import the Parser module in my Main module and stack complains about it being missing
15:35:11 <nitrix> Mhhh. Haskell Platform on windows doesn't seem to work so well with stack yet.
15:35:18 <lispy> nitrix: how so?
15:35:20 <glguy> sbrg: Then something else is wrong with your configuration
15:35:26 <lispy> nitrix: and which HP release?
15:35:46 <nitrix> Did a stack build and got an error about the pkg id of Cabal missing during a call to ghc-pkg something.
15:36:02 <nitrix> I was using the nightly snapshot to get GHC 8.
15:36:07 <sbrg> glguy: https://gist.github.com/2ca5c640ebc0928b2c09e55df9822286 only thing I've changed here is the megaparsec dependency
15:36:10 <nitrix> lispy: checking
15:36:13 <sbrg> everything else is autogenerated
15:36:41 <lispy> nitrix: okay, you should file an issue then so we can get the windows folks to look at it: https://github.com/haskell/haskell-platform/issues
15:36:57 <glguy> sbrg: did you add the Parser module to your cabal file?
15:36:58 <nitrix> lispy: Yeah the error message did say that I should report it :P
15:37:03 <lispy> nitrix: heh
15:37:54 <sbrg> glguy: nope. just to build-depends, or where do I put it?
15:38:04 <glguy> other-modules: Parser
15:38:27 <glguy> sbrg: Every module in your package needs to be listed in your cabal file whether its a library or executable
15:38:35 <log10> hi
15:38:55 <log10> i'm having some issues with GHC 7.10.3 using a huge amount of memory and freezzing
15:38:57 <log10> freezing
15:39:29 <log10> stack build -v suggests it's happening during
15:39:32 <log10> the build of System.Process.Read src/System/Process/Read.hs:301:3)
15:39:41 <log10> this is in a project with template haskell.
15:40:04 <log10> has anyone run into this before?
15:41:14 <zxtx> hey I'm getting a ghc panic when I run cabal repl
15:41:29 <zxtx> ghc: panic! (the 'impossible' happened)
15:41:30 <zxtx>   (GHC version 8.0.1 for x86_64-unknown-linux):
15:41:30 <zxtx> 	atomPrimRep case a1_s9S8 of _ [Occ=Dead] { }
15:41:37 <zxtx> I have no idea what this means
15:44:46 <sbrg> glguy: thanks, that was it! It's pretty awesome that it knows about .y files automatically
15:44:53 <sbrg> zxtx: sounds like you should submit a bug report
15:46:41 <zxtx> sbrg, will try to isolate it and then will do that
15:48:18 * hackagebot ekg-core 0.1.1.1 - Tracking of system metrics  https://hackage.haskell.org/package/ekg-core-0.1.1.1 (JohanTibell)
15:50:34 <EvanR> im missing some terminology here, trying to search for topics pertaining to sequences or functions that "forget their origin"
15:51:22 <EvanR> where index or time shifting doesnt change some essential quality
15:52:27 <dgpratt> would anyone who uses nixos for haskell dev be willing to share a bit about their process? djbeau simpson?
15:53:08 <nineonine> typeclass constraints question here !
15:53:17 <nineonine> lets say I have a lot of data types
15:53:18 * hackagebot ekg 0.4.0.10 - Remote monitoring of processes  https://hackage.haskell.org/package/ekg-0.4.0.10 (JohanTibell)
15:53:20 * hackagebot ekg-statsd 0.2.0.4 - Push metrics to statsd  https://hackage.haskell.org/package/ekg-statsd-0.2.0.4 (JohanTibell)
15:53:27 <nineonine> that have similar fields
15:53:33 <nineonine> example
15:53:44 <nineonine> data A = A { a_id :: Int }
15:53:54 <nineonine> data B = B { b_id :: Int }
15:54:09 <nineonine> so I made a typeclass with accessor function
15:54:13 * EvanR recoils in fear from all the Id's
15:54:19 <nineonine> class Resource a where
15:54:27 <nineonine> resourceId :: a -> Int
15:54:47 <djbeau> dgpratt: I use the packageOverrides capability in ~/.nixpkgs/config.nix along with the ghcWithPackages derivation to select which hackage packages I want installed
15:54:58 <nineonine> sometimes the ID field is of type TEXT
15:55:07 <nineonine>  wanted to do something like
15:55:15 <EvanR> nineonine: maybe this https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/DuplicateRecordFields
15:55:19 <dgpratt> ok, thanks djbeau
15:55:23 <nineonine> resourceId :: Show b => a -> b
15:55:30 <nineonine> yeah i know
15:55:42 <nineonine> but its too much refactoring 
15:55:46 <djbeau> though I have to be sure that I manually upgrade that custom derivation when I update my system (i.e., I cannot rely on 'nix-env --upgrade \*' to do the right thing)
15:55:55 <EvanR> but refactoring is awesome
15:55:57 <nineonine> i decided to go with typeclasses
15:55:59 <djbeau> not sure if that helps answer your question
15:56:01 <nineonine> thats enough for me
15:56:10 <dgpratt> it helps :)
15:56:29 <dgpratt> some :)
15:56:31 <nineonine> so
15:56:42 <dgpratt> just gotta figure out how to get going :)
15:56:56 <nineonine> is it possible to make it work ?
15:56:59 <dgpratt> there's a lot to absorb
15:58:18 * hackagebot ekg-json 0.1.0.2 - JSON encoding of ekg metrics  https://hackage.haskell.org/package/ekg-json-0.1.0.2 (JohanTibell)
15:58:32 <EvanR> nineonine: yes type classes can do this
15:58:57 <nineonine> i tried adding constraint
15:59:08 <nineonine> everything works fine with data 
15:59:12 <nineonine> which id :: Int
15:59:32 <nineonine> but when im trying to give an instance to something with ( ID :: Text )
16:00:13 <nineonine> oh no , actually neither it works for Ints now
16:00:19 <nineonine> D:
16:00:48 <EvanR> if they are not only different record types but different field types, you need to add an associated type to the class
16:01:00 <EvanR> namely the type of that field for that record
16:01:26 <nineonine> hmm
16:01:27 <dgpratt> djbeau, when you setup an environment, do you typically include all the packages you think you might want, or do you add them as you go?
16:01:51 <nineonine> i didnt really understand
16:01:56 <nineonine> what should i do
16:02:21 <djbeau> dgpratt: agree that there is a lot to absorb - I am still learning even after doing this for a few years
16:02:27 <EvanR> keyword is associated type synonyms under type families
16:02:44 <nineonine> yeah im learning type families right now
16:02:50 <nineonine> i intuitively thought 
16:02:57 <nineonine> that it might give an answer
16:03:16 <djbeau> dgpratt: I am not sure what you mean precisely by "setup an environment", but on any particular system I basically add as I go
16:03:22 <EvanR> specifically this is the part of type families that lets you define a synonym family as part of a class
16:03:50 <nineonine> im reading about type families here
16:03:56 <nineonine> https://wiki.haskell.org/GHC/Type_families
16:04:10 <djbeau> If I had more discipline, I would add my own projects into the nix tree early on (which would automatically pull in the necessary dependencies), but my Haskell workload is low enough that I have gotten away with a more ad-hoc approach
16:04:22 <EvanR> read type families and thing "functions that take and return types"
16:04:37 <EvanR> F Int = Bool
16:04:45 <EvanR> F Char = Int
16:05:06 <dgpratt> djbeau, by "set up an environment" I meant the ghcWithPackages thing
16:05:28 <djbeau> I see
16:05:30 <dgpratt> that is mentioned here http://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure
16:05:36 <EvanR> in this case, Id RecA = Int, Id RecB = Text
16:05:48 <EvanR> IdFieldType RecA = Int
16:05:49 <dgpratt> http://nixos.org/nixpkgs/manual/#how-to-install-a-compiler-with-libraries
16:06:03 <dgpratt> djbeau, is that what you were referring to? ^
16:06:07 <nineonine> ooooh 
16:06:15 <nineonine> so I have to define a special type for that ?
16:06:32 <EvanR> IdFieldType would be the synonym family defined inside the Id class
16:06:36 <djbeau> dgpratt: yes, essentially, although I should review that section myself
16:07:01 <djbeau> I developed my workflow mainly from mailing list emails
16:07:24 <dgpratt> djbeau, so if you want to add a package, you update the derivation and...re-run the nix-env command?
16:08:07 <dgpratt> hmm, no, that doesn't seem right
16:08:47 <nineonine> i will spend more time learning about type families
16:09:00 <nineonine> EvanR: Thanks for showing the way !
16:09:20 <EvanR> yes theres more to them than that, you can define families outside of classes as their own thing
16:09:28 <EvanR> can be pretty handy
16:11:27 <djbeau> dgpratt: yep, that's what I do (I have to run either 'nix-env --install' or 'nix-env --upgrade --always' along with '--attr nixos.hsEnv')
16:11:50 <dgpratt> ok, thanks djbeau
16:12:06 <djbeau> I have heard of ways of doing cabal sandboxing or some such during development, but I have not gotten into that at this point
16:12:31 <djbeau> unfortunately my Haskell development is sporadic these days
16:13:07 <dgpratt> I recall seeing some mention of stack/nix integration, which sounded interesting to me, but I've not had time to investigate yet
16:15:17 <simpson> dgpratt: I use cabal2nix to make derivations during development. I know nothing about Stack but hear many people speaking of it.
16:15:46 * koz_ is sad that equating has the type signature it has, even though he gets why.
16:16:19 <koz_> (it means I can't compare two different Foldables on length using equating)
16:17:44 <dgpratt> simpson, one would kind of have to "bootstrap" that process by installing cabal, ghc, cabal2nix, right?
16:18:43 <dgpratt> I looked into this a few months ago -- I thought I could just install cabal2nix and it would grab the necessary dependencies, but that didn't seem to work
16:18:47 <simpson> dgpratt: Yeah, but that's just a matter of nix-env.
16:20:30 <dgpratt> simpson, do you use nix-shell for the per-project stuff?
16:23:02 <dgpratt> dumb question: if I install e.g. ghc, etc. under my own profile with nix-env, will that be used by an environment created by nix-shell?
16:24:00 <simpson> dgpratt: Yeah, I use nix-shell all the time.
16:24:55 <simpson> nix-shell still inherits all of the environment, including anything installed with nix-env. It'll take precedence.
16:28:04 <dgpratt> simpson, ok, cool
16:29:19 <dgpratt> djbeau, simpson, do you pretty much stick with one version of ghc?
16:29:27 <nkaretnikov> what's the painless way to implement cut -f1 with cut from turtle?
16:30:00 <nkaretnikov> dgpratt: nix-shell inherts everything that's on your PATH unless you pass --pure
16:30:08 <nkaretnikov> inherits*
16:30:19 <dgpratt> ah
16:31:10 <Adeon> if you want to upload documentation manually to hackage, how do I avoid having links point to my local files instead of hackage
16:32:24 <Adeon> hmm wait I think I got it
16:33:20 * hackagebot traildb 0.1.0.2 - TrailDB bindings for Haskell  https://hackage.haskell.org/package/traildb-0.1.0.2 (Adeon)
16:33:27 <dgpratt> is there anything else that would make sense to install at top level (e.g. with nix-env) besides ghc, cabal, and cabal2nix?
16:34:18 <nkaretnikov> dgpratt: nox? (a painless nix-env)
16:34:37 <dgpratt> will google "nox", thanks nkaretnikov
16:34:53 <simpson> dgpratt: I don't really pay much attention to GHC; I only do Haskell stuff occasionally, and I use whatever the distro provides.
16:35:28 <dgpratt> ok
16:53:21 * hackagebot cereal 0.5.2.0 - A binary serialization library  https://hackage.haskell.org/package/cereal-0.5.2.0 (TrevorElliott)
17:38:36 <djbeau> dgpratt: I just usually use latest stable ghc
17:39:02 <djbeau> I don't require long-term stability per-se
17:39:41 <djbeau> although I have had to suffer through library API changes and such when using newer packages, but I accept that risk
17:40:01 <hpc> ah, the arch model
17:40:11 <hpc> much like mongodb, it strives for eventual stability
17:40:31 <EvanR> it reaches an economic equilibrium
17:40:36 <EvanR> tomorrow
17:40:47 <hpc> which in practice leads to a rotating cycle of brokenness, but in practice i do find ghc to be rather reliable
17:41:08 <hpc> if you get the process down for updating your package db with each version
17:42:00 <Welkin> hpc: break the wheel!
17:42:27 <hpc> Welkin: it's impossible!
17:42:35 <hpc> Welkin: the wheels are triangular, the most structurally sound shape
17:53:24 * hackagebot hpio 0.8.0.0 - Monads for GPIO in Haskell  https://hackage.haskell.org/package/hpio-0.8.0.0 (dhess)
18:02:07 <Vektorweg1> how can i run tests?
18:02:07 <Vektorweg1> i installed a package with cabal and --enable-tests and now i try to find the right command to run the tests. cabal test <package> doesnt work. 
18:16:31 * hackagebot uniform-pair 0.1.12 - Uniform pairs with class instances  https://hackage.haskell.org/package/uniform-pair-0.1.12 (ConalElliott)
18:21:43 * hackagebot uniform-pair 0.1.12 - Uniform pairs with class instances  https://hackage.haskell.org/package/uniform-pair-0.1.12 (ConalElliott)
18:21:43 * hackagebot pkcs10 0.1.1.0 - PKCS#10 library  https://hackage.haskell.org/package/pkcs10-0.1.1.0 (ktimothy)
18:26:38 * hackagebot memcache 0.2.0.0 - A memcached client library.  https://hackage.haskell.org/package/memcache-0.2.0.0 (DavidTerei)
18:41:39 * hackagebot monad-coroutine 0.9.0.3 - Coroutine monad transformer for suspending and resuming monadic computations  https://hackage.haskell.org/package/monad-coroutine-0.9.0.3 (MarioBlazevic)
19:05:24 <ertes> hi there…  i'm trying to insert a soft hyphen ('\173' a.k.a. "&shy;") into a string literal, and i get the following error: Site/Template/Html.hs:40:60: lexical error in string/character literal at character '\173'
19:05:46 <ertes> i have -XOverloadedStrings turned on, and unicode works in string literals
19:05:55 <EvanR> > "\173"
19:05:56 <lambdabot>  "\173"
19:06:38 <EvanR> > text "\173"
19:06:40 <lambdabot>  ­
19:06:47 <EvanR> > "­"
19:06:48 <ertes> yeah, it works that way, but why is the literal character an error?
19:06:49 <lambdabot>  <hint>:1:2:
19:06:49 <lambdabot>      lexical error in string/character literal at character '\173'
19:06:55 <EvanR> wtf
19:07:09 <geekosaur> ghc is annoying that way
19:07:30 <geekosaur> it also rejects private use area character literals (again, unless using escaped syntax)
19:07:45 <ertes> any particular reason it does that?
19:08:05 <geekosaur> I don't know of one
19:08:32 <ertes> ok, thanks
19:08:38 <geekosaur> I asked in #ghc once but got no response. maybe file a bug and see if they'll consider being more liberal in their unicode character support in the lexer?
19:08:52 <EvanR> is it just private use and -?
19:09:05 <geekosaur> probably others as well, those are the only ones I've run across
19:09:42 <EvanR> maybe they consider it error prone, you cant just look at the source and see that its not a normal hyphen
19:09:57 <ertes> > read . (++ "\"") . ('"' :) $ ['\128'..] :: String
19:10:03 <lambdabot>  mueval-core: Time limit exceeded
19:10:11 <ertes> > read . (++ "\"") . ('"' :) $ ['\128'..'\180'] :: String
19:10:16 <lambdabot>  "\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\144\145\14...
19:10:24 <EvanR> that probably wont catch it
19:10:38 <geekosaur> I suspect they only allow characters from a limited set of Unicode categories. would bet that things like RTL/LTR marks also rejected
19:10:45 <ertes> > text . read . (++ "\"") . ('"' :) $ ['\128'..'\180']
19:10:46 <lambdabot>   ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´
19:11:02 <ertes> > " ¡¢£¤¥¦§¨©ª«¬®¯°±²³´"
19:11:04 <lambdabot>  "\160\161\162\163\164\165\166\167\168\169\170\171\172\174\175\176\177\178\17...
19:11:10 <ertes> funny
19:11:28 <geekosaur> > '́'
19:11:30 <lambdabot>  '\769'
19:11:39 <EvanR> haha
19:11:43 <geekosaur> ok, it takes bare combining chars at least
19:11:59 <EvanR> the raised eyebrow operator
19:12:45 <geekosaur> betting they don't like category Other
19:15:12 <geekosaur> > '︀'
19:15:13 <lambdabot>  '\65024'
19:16:20 <geekosaur> > '⁤'
19:16:22 <lambdabot>  <hint>:1:2:
19:16:22 <lambdabot>      lexical error in string/character literal at character '\8292'
19:16:26 <geekosaur> heh
19:16:42 <geekosaur> U+2064 INVISIBLE PLUS (Other, Format)
19:18:23 <simpson> Hi! Does anybody know much about nanopass? I had a couple questions about the concept but was not sure where to start asking.
19:21:40 * hackagebot google-cloud 0.0.4 - Client for the Google Cloud APIs  https://hackage.haskell.org/package/google-cloud-0.0.4 (wereHamster)
19:26:40 * hackagebot indentation-core 0.0 - Indentation sensitive parsing combinators core library  https://hackage.haskell.org/package/indentation-core-0.0 (AlekseyKliger)
19:26:42 * hackagebot indentation-parsec 0.0 - Indentation sensitive parsing combinators for Parsec  https://hackage.haskell.org/package/indentation-parsec-0.0 (AlekseyKliger)
19:26:44 * hackagebot indentation-trifecta 0.0 - Indentation sensitive parsing combinators for Trifecta  https://hackage.haskell.org/package/indentation-trifecta-0.0 (AlekseyKliger)
19:31:41 * hackagebot indentation 0.3 - Indentation sensitive parsing combinators for Parsec and Trifecta  https://hackage.haskell.org/package/indentation-0.3 (AlekseyKliger)
19:55:09 <jle`> huh saw a really interesting usage of WriterT today
19:55:23 <jle`> i sort of always dismissed it
19:55:29 <jle`> i guess i have been small-minded
19:59:17 <Welkin> jle`: well, what was it?
20:00:23 <jle`> WriterT with elm-like signals, and [HtmlElement] as the accumulating monoid
20:00:56 <jle`> and every signal "tell"s an HtmlElement as it does its thing
20:01:09 <ertes> jle`: check out reflex-dom
20:01:25 <jle`> so when you run a `WriterT [Element] Signal a` you also get live-updating html elements
20:01:31 <jle`> in addition to the result
20:01:42 * hackagebot indentation 0.3.0.1 - Indentation sensitive parsing combinators for Parsec and Trifecta  https://hackage.haskell.org/package/indentation-0.3.0.1 (AlekseyKliger)
20:01:59 <jle`> you get a Signal ([Element], a)
20:02:06 <jle`> ertes: i've been meaning to look at that :O
20:02:21 <ertes> it does the same thing, except efficiently =)
20:02:38 <jle`> yeah, this integrates well with the entire framework of live-updating signals on the page and stuff
20:02:42 <jle`> neat
20:03:23 <jle`> the talk i was at today showed how to use it, along with an Arbitrary-like typeclass, to automatically generate live javascript examples on purescript documentation pages
20:03:42 <ertes> "it"?
20:03:42 <jle`> because it can generate an arbitrary demo just from the type signature, like how QC generates arbitrary tests from type signatures
20:04:00 <jle`> the WriterT thing
20:05:05 <ertes> you know stuff like blaze-html and lucid
20:05:34 <jle`> the idea is that if you want to a demo of foo :: Int -> Bool, you can just use `foo <$> intSignal <*> boolSignal`, which creates inputs as well as an output through the writer stuff
20:05:41 <jle`> i've worked a bit with blaze-html
20:05:41 <ertes> reflex-dom is the same thing, but reactive…  the elements are also updated transparently
20:06:18 <ertes> and even created and destroyed transparently when they correspond to a haskell data structure
20:08:05 <jle`> sounds like it's worht looking into
20:08:13 <jle`> but i wonder what other Applicatives would be interesting with WriterT
20:08:37 <ertes> not many, because WriterT as it is implemented in transformers is inefficient
20:08:56 <jle`> yeah, i don't mean the actul WriterT
20:09:09 <jle`> as it's implement
20:09:12 <jle`> ed
20:09:25 <jle`> but WriterT the idea
20:09:36 <ertes> it's interesting whenever you want to construct (think markup) or collect (think log messages) something while doing something else
20:10:30 <ertes> WriterT over something like [] is particularly interesting
20:10:54 <ertes> but it's not groundbreaking
20:11:58 <ertes> i tend to use StateT over [] from time to time (follow/review all execution paths of a state variable)
20:11:59 * jle` goes on a hunt
20:12:19 <jle`> i sort of thought that the interesting thing about an application of WriterT was the monoid accumulator
20:12:35 <jle`> but i never thought about interesting Applicatives to use it with
20:12:44 <ertes> sometimes in combination with Free/FreeT to examine the state of the computation at a "breakpoint"
20:13:18 <jle`> WriterT over [] is some form of the "probability monad", right?
20:13:52 <ertes> it's really just a "collections monad"
20:14:16 <ertes> you need a few restrictions for it to become a probability monad
20:15:05 <ertes> and StateT over [] is more interesting: it's the "list of evolution paths monad"
20:15:56 <ertes> example:  do f <- lift [func1, func2, func3]; modify f; ...
20:18:13 <idev> for transfering a lot of files, is it better ot use tar or zip as the format?
20:18:26 <idev> i.e. which ones allows me (1) random access and (2) have pure-haskell binidngs (no worry for bufer overflow)
20:18:44 <jle`> ertes: yeah, that one is pretty fun too :)
20:19:26 <ertes> idev: tar is at least simpler, but does not compress on its own…  otherwise there isn't much of a difference
20:20:13 <ertes> idev: why do you need random access for transferring?
20:20:42 <idev> ertes: so I have this webservice written in java/clojure for processing untrsuted data
20:21:14 <idev> ertes: haskell/snap takes untrusted user input, sends it to a clojure/jvm program to process it -- the output is multiple files; I need it to send it back as a single file to haskell
20:21:31 <idev> so the question is: do I tell clojure/jvm to send it back as a zip or a tar?
20:21:56 <idev> compression probably doesn't matter, as te output is (1) a bunch of jpegs and (2) a bunch of json files
20:22:21 <ertes> idev: if it's on the same machine, tar is probably more efficient…  over a network like i would go with tar.gz, if possible, otherwise .zip
20:22:39 <ertes> s/like/link/
20:23:20 <idev> hmm
20:23:21 <ertes> idev: i'd pick the variant that works best with haskell streaming libraries like conduit and pipes
20:23:27 <idev> so I'm looking at https://hackage.haskell.org/package/tar-0.5.0.3/docs/Codec-Archive-Tar.html
20:23:36 <idev> and I preer something where I can read the contents WITHOUT writing ot the file system
20:24:03 <idev> as much as possible, I'd prefer everything just stay in RAM (and thus also why I want randoma ccess -- to bea ble to choose what to read w/o having ot write it all out sequentially)
20:25:45 <ertes> looks like the 'tar' library can do that
20:25:51 <ertes> with 'read' and 'write'
20:26:13 <idev> https://hackage.haskell.org/package/tar-0.5.0.3/docs/src/Codec-Archive-Tar-Read.html#read ?
20:26:41 <ertes> i'm looking at Codec.Archive.Tar
20:27:03 <ertes> it doesn't give you fully random access, as you have to traverse the list of files
20:27:21 <ertes> Entries is basically a list of files with an extra constructor for errors
20:27:45 <ertes> you could post-process it into a HashMap though
20:27:55 <idev> okay, the Next, Done, Fail
20:28:00 <ertes> yeah
20:28:05 <idev> so I take a tar file, call read on it, basically get an Either [Entry] Error
20:28:12 <idev> then I change it to a Map [FileName] -> Entry
20:28:16 <idev> err, a "Map FileName Entry"
20:28:19 <idev> cool, thanks!
20:28:20 <ertes> in fact you can get extra speed by post-processing it into a trie as in the 'bytestring-trie' package
20:28:34 <idev> it's alright, I need to run deep learning on this
20:28:44 <idev> opening up the tar file is not goign to be my bottleneck
20:29:10 <ertes> then you can "go into a subdirectory" cheaply
20:29:20 <idev> it's flat :-)
20:29:28 <ertes> in that case just use HashMap (not Map)
20:30:04 <ertes> it's in the 'unordered-containers' library
20:30:37 <ertes> idev: do you have an efficient implementation of RBMs in haskell?
20:31:42 <idev> ertes: restricted boltzmann machines? no; I'm going to use CUDA + Torch
20:31:54 <idev> ertes: are there nice Haskell / Cuda / Blas libraries?
20:32:02 <ertes> ah, ok
20:32:08 <idev> everything is matrix algera in the end, and I don't know how good the haskell Cuda-Blas bindings are
20:32:08 <ertes> well, there is a CUDA library
20:32:12 <ertes> and there is accelerate-cuda
20:32:19 <idev> yeah, but does it have blas?
20:32:24 <idev> I don't want to wirt emy own matrix routines :-)
20:33:06 <ertes> i don't know…  check their API docs
20:33:43 <idev> (I thought you might ahve known given your interest in Haskell RBMS)
20:33:53 <ertes> i found this: https://hackage.haskell.org/package/cublas
20:34:21 <ertes> i haven't implemented RBMs yet…  so far logistic regression has been sufficient for my purposes
20:34:41 <ertes> i'm personally interested in deep learning, but i wouldn't know what to do with it right now
20:35:20 <idev> ertes: is logistic regression 1-layer or deep-learning? :-)
20:35:48 <idev> https://hackage.haskell.org/package/cublas-0.2.1.0/docs/Foreign-CUDA-Cublas.html looks like level 3 blas
20:36:11 <ertes> from an ANN perspective in its simplest form it's an ANN without hidden layers and one logistic output neuron
20:36:48 <ertes> there is also multinomial logistic regression, which allows multiple output neurons, but with the restriction that they are softmax-bound
20:36:52 <ertes> i.e. their outputs sum to 1
20:43:06 <smeagol> this is super bizarre
20:43:20 <haskell> this is super bizarre
20:43:41 <Cale> What is?
20:43:44 <haskell> using the frames library, weird things make ghc use a shit ton of memory and effectively lock up my computer
20:44:01 <haskell> it uses template haskell, but the template haskell part alone doesn't do it
20:44:18 <Cale> hm
20:44:22 <haskell> when I use any of the functions to convert the pipe stream form of the data to an in-memory representation
20:44:27 <haskell> is what causes it
20:44:34 <haskell> either using inCoreAoS
20:45:15 <haskell> or when i tried to be clever and manually do it (PP.toListM myStream) >>= (\x -> pure $ toFrame x)
20:45:40 <haskell> just uncommenting either of those leads GHC to basically lock up my computer
20:46:02 <haskell> but when i just work with the pipe streams, even with all the rowtype generation template haskell stuff, it builds fine
20:46:11 <Cale> At compile time?
20:46:20 <Cale> That's interesting
20:47:20 <haskell> yes at compile time
20:47:59 <haskell> i find it really bizarre. in the version where I coerced it, it doesn't look like there should be any compile time computation
20:48:12 <haskell> or at least not obviously so
20:49:26 <Cale> Ah, I suppose if somehow it was inside a splice or something and building the Frame at compile time, that would make sense. If not, I dunno.
20:50:33 <haskell> yeah. well i'm a TH rube... but it seems like the splicing only happens when i'm generating the types from the csv file
20:52:05 <haskell> also weird - i can load it in ghci no problem
20:53:41 <haskell> bizarre :(
20:53:50 <haskell> just when i was beginning to appreciate the design of frames
20:57:11 <haskell> Cale are there common ghc flags people try to "unstuck" problematic builds?
20:57:58 <MichaelBurge> haskell: Are you using a GHC less than 8?
20:58:52 <haskell> MichaelBurge 7.10.3
20:59:15 <haskell> i'm holding off on making the jump until some of the initial bug reports are filed
20:59:38 <MichaelBurge> haskell: Serialization libraries often use generics. Does your library use generics to help automate creating instances of typeclasses?
20:59:43 <haskell> unless it's known to fix a lot of these issues, but my assumption would be that 7.10.3 is less buggy
21:00:30 <haskell> my code doesn't. i'm using frames which is doing some heavyweightish TH stuff for row type generation though
21:00:44 <haskell> not sure if it's using generics as well, maybe vinyl is?
21:01:25 <MichaelBurge> haskell: I know there was a bug where just deriving (Generic) could lead to a huge amount of memory being used during compile-time, and a workaround was to abort and rebuild
21:01:58 <MichaelBurge> haskell: Another possibility is it's being overly lazy and the code is just wrong. I like to to cap the RTS' memory use with one of the options, to avoid that bringing down my system
21:02:52 <haskell> why would laziness lead to ghc crashing? e
21:03:11 <haskell> was the Generics bug fixed in 8.0? that might give me a reason to make the jump earlier
21:03:36 <MichaelBurge> haskell: The generics bug should be fixed in 8.0. Newer versions of GHC grow the stack as needed. The maximum stack size defaults to 80% of system memory
21:03:57 <MichaelBurge> haskell: So stack overflows could bring down your system without changing settings
21:04:37 <haskell> hmm maybe i will give ghc 8 a try
21:05:17 <MichaelBurge> haskell: I haven't made the switch yet myself. I was waiting on Stackage to update its packages. It looks like they've done that just today, so I'll probaly switch in a week or two
21:07:17 <haskell> trying now. yikes... this is way too bleeding edge to be using for work :P
21:07:31 <haskell> may have to give up on frames a 2nd time
21:15:53 <Cale> haskell: If it's any indication, we plan to be using GHC for client work in the next few days.
21:16:45 <Cale> Usually I would be more concerned about the stability of a GHC x.1 release but apparently it's been solid in testing.
21:25:23 <texasmynsted> I am trying to learn how to create instances
21:25:30 <texasmynsted> I have 
21:26:04 <texasmynsted> data Pair a = Pair a a
21:26:20 <texasmynsted> and the following instance works, if both pairs are the same type
21:26:30 <texasmynsted> instance Eq a => Eq (Pair a)  where (==) (Pair x y) (Pair xx yy) = x == xx && y == yy
21:26:31 <glguy> If you want to paste code you can use http://lpaste.net
21:26:37 <texasmynsted> ok
21:26:50 <glguy> This will make it possible for you to layout your code readably and for people to annotate answers and help
21:28:11 <texasmynsted> http://lpaste.net/2244962685311516672
21:31:27 <glguy> texasmynsted: That instance looks fine. Are you typing out a question about it?
21:31:57 <texasmynsted> yes it does not take into account something like this
21:32:12 <texasmynsted> Pair 1 2 == Pair 'a' 'b'
21:32:26 <texasmynsted> That should be False not explode 
21:32:34 <glguy> That's just a type error. (==) has the type: Eq a => a -> a -> Bool
21:32:43 <geekosaur> you can't do that in Haskell, it'd require "type case"
21:33:13 <geekosaur> you cannot compare arbitrary types, nor can you inspect the type of something to decide what you can do with it
21:33:38 <texasmynsted> So a compile time error not run-time
21:33:44 <texasmynsted> this is good
21:33:44 <geekosaur> (barring stuff like Data.Typeable which requires additional constraints and runtime overhead to carry it around at runtime)
21:34:07 <texasmynsted> I want compile-time errors, not run-time
21:35:56 <glguy> Or we could do something terrible with FlexibleInstances, MultiParamTypeClasses, and OverlappingInstances
21:35:58 <glguy> 03class HEq a b 03where (07=?=) 07:: a 07-> b 07-> Bool
21:36:10 <glguy> But we shouldn't
21:36:46 * hackagebot haskell-player 0.1.1.0 - A terminal music player based on afplay  https://hackage.haskell.org/package/haskell-player-0.1.1.0 (potomak)
21:36:58 <simpson> What, and then instance HEq a a where x =?= y = x == y
21:37:12 <glguy> With an Eq a constraint
21:37:21 <simpson> Ah, yeah. Tricky.
21:37:33 <glguy> and another for when the types don't match
21:37:43 <Cale> Won't that also need IncoherentInstances?
21:37:51 <simpson> instance HEq a b where _ =?= _ = False -- yikes
21:38:04 <glguy> Cale: No
21:38:46 <glguy> http://lpaste.net/2244962685311516672
21:38:56 <Cale> Oh, right, we expect to be comparing things of known types, so it shouldn't be a problem
21:38:58 <texasmynsted> wow
21:39:31 <texasmynsted> If I want to create an instance that will have two different types that must have Eq, can I do this?
21:39:39 <texasmynsted> instance Eq a, b => . . .
21:39:47 <Cale> instance (Eq a, Eq b) => ...
21:39:57 <texasmynsted> oh ok
21:39:57 <glguy> It wouldn't be worth doing that because Eq's == needs two values of the same type
21:39:58 <texasmynsted> thank you
21:40:11 <glguy> so you won't be able to use that constraint
21:40:15 <texasmynsted> Doing an Eq instance for Tuple
21:40:17 <glguy> ooops
21:40:22 <glguy> yeah, I was still thinking about the bad idea
21:41:14 <nickkuk> Hello. Here http://lpaste.net/8316813597263003648 I want to do Show instance for a whole type class X.
21:41:18 <nickkuk> But it somehow "breaks" instance (Show Int). Is it bug or do I miss something?
21:41:36 <lambda-11235> Types can be completely erased in vanilla haskell, right? What extensions, if any, would need types at runtime?
21:41:51 <Cale> glguy: b... but what if we want to compare values whose types have different kinds? :)
21:42:40 <Cale> lambda-11235: none, but Typeable provides runtime type information of a sort
21:43:16 <glguy> Cale: hmm, sounds like something we'll have to evaluate on a case by case basis :)
21:43:43 <glguy> nickkuk: You should include the errors when you paste
21:44:17 <glguy> nickkuk: The first problem is that GHC doesn't know what type 1 has
21:44:23 <lambda-11235> Cale: Thanks. That's what I thought, but wasn't sure about all the extensions.
21:44:39 <texasmynsted> Why does the lpaste.net underline in red the last yy in this?  http://lpaste.net/9137057651065094144
21:44:54 <glguy> nickkuk: And you overlapped all the instances for Show with your instance
21:44:55 <Cale> nickkuk: This kind of instance is usually a bad idea.
21:45:02 <glguy> ^
21:45:03 <Cale> yeah
21:45:51 <Cale> The problem being that when deciding which instance to commit to, GHC pattern matches on the structure of the type, and *can't* use the type class constraints on the instance to inform how this happens (since it doesn't know if future modules provide instances of those classes or not)
21:45:53 <glguy> nickkuk: because your browser has spell-checking
21:46:45 <texasmynsted> lol
21:46:47 <Cale> nickkuk: So, to the algorithm which is trying to decide which instance to use, your instance looks like   instance Show x where ...
21:46:51 * texasmynsted facepalm
21:46:54 <texasmynsted> thank you
21:47:15 <Cale> nickkuk: and then only after it commits to the instance would it check whether the constraints hold
21:47:30 <lpaste> glguy annotated “Show instance for class” with “GHC 8 does a much better job with this error message” at http://lpaste.net/8316813597263003648#a2861143716075143168
21:47:50 <Cale> nice
21:48:00 <Cale> They've done a lot of work on the error messages in GHC 8 from what I've heard
21:48:01 <jle`> i've been pretty happy with ghc 8's error messages so far
21:48:07 <jle`> pleasantly surprised
21:48:18 <Cale> Apparently it can also tell you when you have type class constraints that are redundant or unnecessary
21:48:39 <glguy> It certainly can tell you if you have redundant constraints, it doesn't mean that you can remove them
21:48:43 <glguy> but it'll tell you
21:49:14 <jle`> yeah, that has been a nice feature
21:50:00 <glguy> fortunately you can turn that off when it's wrong
21:51:26 <Cale> There's a lot of situations when refactoring code in our projects (somehow it comes up a lot with both reflex-dom/GHCJS related code on the frontend and groundhog-related code on the backend) where we end up refactoring things in a way that some piece no longer needs all its constraints, but they stick around anyway because nobody realises it, and that forces everything down the line to have similarly overspecific constraints.
21:51:34 <Cale> So that should help us a bunch
21:57:27 <glguy> One particular thing that annoys me is that if a class method has a constraint any instance that doesn't use that class instance generates a warning
21:57:39 <glguy> not considering that other instances are using it
21:57:53 <glguy> in other cases it doesn't know that the constraint is helping the type checker
22:22:54 <lambda-11235> Are there any propositions for alternatives to module export lists?
22:28:46 <simpson> lambda-11235: Go for it.
22:29:45 <mdibaiee> bgamari: Hey Ben, I found the solution to the problem, it was the laziness. My network had to iterate hundreds of thousands of times, and the laziness would create a big stack. What I did was force all the operations (using `force a = seq a a`) and ta-daa! Thanks for your help!
22:30:05 <shachaf> mdibaiee: seq a a = a
22:30:16 <shachaf> Your force = id
22:31:10 <mdibaiee> shachaf: seq takes two arguments, force takes one, so `seq (some calculation) (some calculation)` becomes `force (some calculation)` am I wrong?
22:31:28 <lpaste> koz_ pasted “Something about this lens-based signature isn't making GHC happy” at http://lpaste.net/164683
22:31:40 <shachaf> You can replace "force x" with "x" anywhere in your code and it would behave the same way.
22:32:01 <shachaf> "seq (some calculation) (some calculation)" would probably calculate twice, if those two calculations are the same.
22:32:35 <shachaf> koz_: I don't know, but I bet the type checker tells you.
22:32:59 <koz_> shachaf: The problem is that I don't understand what it's telling me.
22:33:32 <koz_> Let me add that.
22:34:06 <shachaf> That is almost always the right thing to do.
22:34:34 <mdibaiee> shachaf: no, `force x` makes sure `x` is calculated right there, and not once it's needed. In big recursions, this laziness fills up memory. That's why we have strict folds
22:35:01 <shachaf> mdibaiee: "seq x x" is the same thing as "x".
22:35:02 <lpaste> koz_ revised “Something about this lens-based signature isn't making GHC happy”: “Something about this lens-based signature isn't making GHC happy” at http://lpaste.net/164683
22:35:19 <shachaf> The function "id" is already strict. "force" behaves the same way as "id".
22:35:20 <koz_> shachaf: Hopefully that clears it up/
22:35:43 <shachaf> koz_: Well, it's telling you to turn on the extension RankNTypes, because you have a rank-n type.
22:35:53 <shachaf> So you can do that.
22:36:04 <koz_> shachaf: I guess I don't understand *why* Iso' a a is a RankN.
22:36:35 <shachaf> Because Iso' s a = forall p f. (Profunctor p, Functor f) => p a (f a) -> p s (f s)
22:36:46 <shachaf> Iso' a a is rank-1. f :: Iso' a a -> ... is rank-2
22:37:04 <koz_> Oh, right, derp.
22:37:10 <koz_> Thanks - that makes it abundantly clear.
22:37:18 <shachaf> An alternative would be to make your function take AnIso' instead of Iso'
22:37:40 <koz_> Ah, because AnIso is rank-0.
22:37:40 <shachaf> That's probably nicer to people who use it.
22:37:57 <koz_> Alrighty, I shall use AnIso' then.
22:38:11 <koz_> Thanks shachaf - I keep forgetting that lens types are much scarier underneath.
22:38:52 <koz_> Sorry, I meant 'AnIso' is rank-1'.
22:38:58 <koz_> Rank-0 are concrete types IIRC.
22:39:20 <shachaf> I'd say that AnIso' a a is rank-0.
22:39:45 <mdibaiee> shachaf: http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:seq
22:39:53 <mdibaiee> shachaf: "#
22:39:55 <mdibaiee> The value of seq a b is bottom if a is bottom, and otherwise equal to b. seq is usually introduced to improve performance by avoiding unneeded laziness."
22:40:01 <shachaf> mdibaiee: I know how seq works.
22:40:07 <shachaf> seq a a = a
22:40:34 <mdibaiee> shachaf: yes, but it's guaranteed that a is evaluated
22:40:47 <shachaf> When you evaluate a, it's already guaranteed that a is evaluated.
22:40:53 <shachaf> The same as when you evaluate (seq a a).
22:41:04 <shachaf> They're the same, not just in terms of value, but in terms of behavior.
22:42:09 <EvanR> seq a a *really* guarantees its evaluated ;)
22:42:16 <EvanR> (not really)
22:43:01 <koz_> shachaf: In that case, I don't understand type ranks.
22:43:22 <mdibaiee> shachaf: seq a a guarantees a is evaluated _at the moment_, not once needed, and that's what I want.
22:43:31 <EvanR> let !x = seq foo foo in StrictIdentity $! x
22:43:49 <shachaf> mdibaiee: Evaluating (seq a a) guarantees that a is evaluated.
22:43:58 <shachaf> But so does evaluating a.
22:44:07 <shachaf> They behave exactly the same.
22:44:17 <mdibaiee> shachaf: then why do we have `seq`? :D
22:44:29 <EvanR> for when you dont use it on the same two things
22:44:32 <shachaf> Because you don't have to pass it the same argument twice.
22:44:51 <shachaf> Usually you write seq a b. Then it makes sense. But seq a a doesn't make sense.
22:44:59 <MichaelBurge> > let infinity = 1 : infinity in let seq_infinity = seq infinity infinity in head seq_infinity
22:45:02 <lambdabot>  1
22:45:17 <MichaelBurge> ^ If seq fully evaluated its argument like you thought, that program would not terminate, right?
22:45:37 <shachaf> MichaelBurge: No, it would terminate even in that case, because seq only evaluates to WHNF.
22:45:59 <MichaelBurge> shachaf: I know, I was using it as a counterxample to the idea that seq fully evaluates its argument
22:46:20 <shachaf> Oh, I see, you're talking about something different.
22:46:25 <shachaf> OK.
22:46:48 <shachaf> Maybe the conversation is about WHNF vs. NF, though it didn't look that way to me.
22:47:02 <mdibaiee> shachaf: well, I'm not sure about the definitions, but, I can clearly see the difference, if I remove `seq a a` from my code, my program takes gigabytes of memory. By using `seq a a` my program takes less than 30 megabytes of memory.
22:47:16 <EvanR> skeptical
22:47:31 <shachaf> mdibaiee: If you replace "seq a a" with "a", your program will behave the same.
22:47:45 <mdibaiee> mdibaiee: no it wont, that's what I just said.
22:47:57 <shachaf> Well -- unless something very strange is going on.
22:48:29 <Adeon> could strange GHC optimizations affect something like this
22:48:37 <Adeon> in my intuition "seq a a" should be 100% the same as just writing "a"
22:48:41 <EvanR> its not supposed to thats the whole point of these laws
22:49:03 <shachaf> They would have to be pretty strange.
22:49:11 * EvanR thinks mdibaiee may be missing something
22:49:29 <shachaf> I think it's more likely that something else is going on.
22:49:43 <shachaf> But without the code it's not reproducible.
22:50:23 <tippenein> never seen this syntax before firstP, secondP :: (a -> a) -> (Pair a -> Pair a)
22:50:32 <tippenein> declaring 2 functions types in 1 line
22:53:07 <glguy> tippenein: That works for records, too
22:53:19 <glguy> 03data T 03where C { a,b,c 07:: Int }
22:53:47 <tippenein> I can't tell if I like that or now
22:53:51 <tippenein> not*
22:55:08 <mdibaiee> EvanR, shachaf: I see, I thought about it and it's right. I tried with the code and it seems running the program with `runhaskell` (and not building it) was causing the memory leak, not `seq a a`, or maybe a combination of two. Ooo. Thank you :D
22:55:14 <mdibaiee> bgamari: ^
22:55:29 <glguy> tippenein: It's nice for emphasizing that multiple values have the same type
22:56:02 <glguy> https://github.com/glguy/5puzzle/blob/master/Cube.hs#L24
22:58:33 <Myrl-saki> https://gist.github.com/b7c94ea505bbf1e8c93113db4f902c4e
22:58:45 <Myrl-saki> That should work... right?
22:59:17 <glguy> Myrl-saki: That'll loop forever
22:59:37 <Myrl-saki> glguy: Why?
23:00:08 <glguy> Because both branches of your if-expression immediately make a recursive call to generateSample
23:00:12 <Myrl-saki> I mean, that's clearly "oh my god, that's obvious"
23:00:22 <glguy> and IO execution is strict
23:00:22 <Myrl-saki> But if it's lazy, then it shouldn't make the recursive call until needed.
23:00:29 <Myrl-saki> Oh.
23:00:30 <glguy> so it's going to keep on executing and never "finish"
23:02:12 <glguy> and then you tried to print the otherwise infinite list
23:02:16 <glguy> so that was going to take a long time
23:03:32 <Myrl-saki> glguy: lol. :p
23:04:40 <glguy> Myrl-saki: https://gist.github.com/Myrl/b7c94ea505bbf1e8c93113db4f902c4e
23:05:22 <Myrl-saki> glguy: Right. Nice catch. Thanks.
23:08:25 <koz_> My head officially hurts now.
23:09:06 <Myrl-saki> koz_: why?
23:09:10 <Myrl-saki> because of my code? :3
23:10:21 <koz_> Myrl-saki: Nope - because of mine.
23:10:35 <Myrl-saki> koz_: Show us. :3
23:10:35 <koz_> I've been trying to hack this together for days and every time, I end up painting myself into an ugly corner and hating it.
23:10:55 <koz_> Myrl-saki: I made a SO question: http://stackoverflow.com/questions/37495750/confused-about-constructing-an-iso-from-another-iso
23:12:53 <glguy> koz_: Do you at least understand your typeerror?
23:13:04 <koz_> glguy: No, that's the issue.
23:13:14 <koz_> If I understood my type error, I'd at least know where to begin.
23:13:20 <glguy> liftClause is constructing an:  Iso' (Conjunction a) (Disjunction a)
23:13:31 <glguy> see how the 'a' is repeated?
23:13:36 <koz_> Yes.
23:13:53 <glguy> Your target type was: Iso' CNF DNF  
23:13:56 <koz_> Oh wait....
23:14:03 <koz_> I think I see it now.
23:15:02 <koz_> OK, that didn't *quite* get me there.
23:15:16 <koz_> I tried altering liftClause to Iso ' (Conjunction a) (Disjunction b)
23:15:20 <koz_> That *almost* worked.
23:15:51 <koz_> Except now, pipeline's suffering from a type error.
23:16:11 <koz_> Never mind, I need *two* pipelines.
23:16:19 <koz_> Because in one of them, I need a 'from x'.
23:16:21 <koz_> Right?
23:17:52 <glguy> That'll certainly make it type-check
23:18:12 <koz_> glguy: I am *shocked* I didn't see it.
23:18:16 <koz_> Feels really obvious now...
23:18:26 <koz_> Is this a sign I've been staring at this too long?
23:18:43 <Myrl-saki> Man. I'm confuzzed.
23:19:46 <koz_> glguy: Well, it does make it typecheck, but negatingForm is still unhappy.
23:20:09 <koz_> Wait, never mind, needs more from.
23:20:47 <lpaste> glguy pasted “don't know what it does but it typechecks now” at http://lpaste.net/164685
23:21:35 <koz_> glguy: I did basically the same, except I had a from in negatingForm's definition instead.
23:21:42 <koz_> This is *definitely* something I need to test though.
23:21:50 * hackagebot optparse-generic 1.1.1 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.1.1 (GabrielGonzalez)
23:21:55 <glguy> Don't miss out on your chance to use: involuted :: (a -> a) -> Iso' a a
23:22:00 <koz_> glguy: ??
23:22:03 <glguy> up there in negatingAtom
23:22:04 <koz_> That's a thing?
23:22:28 <koz_> Woah, neat.
23:22:56 <koz_> I wondered whether there was a helper for self-inverting functions.
23:23:11 <koz_> Apparently I should not underestimate Edward Kmett's definition of 'batteries included'.
23:25:38 <koz_> glguy: I don't suppose I'm too insane if I wanna try and replace 'conjuncts' and 'disjuncts' by a single Getter somehow? Can I even do that?
23:26:13 <glguy> we can certainly make liftClause more fun
23:26:20 <glguy> that's the goal, right?
23:26:34 <koz_> glguy: Not exactly; this is more a 'personal curiosity' thing.
23:26:51 * hackagebot mvc 1.1.3 - Model-view-controller  https://hackage.haskell.org/package/mvc-1.1.3 (GabrielGonzalez)
23:27:05 <koz_> Like, I have these two (very similar) types, and I wanna lens into their (very similar) innards with one Getter.
23:27:12 <koz_> Can I actually do that, and if so, how?
23:27:21 <lpaste> glguy annotated “don't know what it does but it typechecks now” with “first draft” at http://lpaste.net/164685#a164686
23:27:36 <glguy> I temporarily changed the Set to [] because it made mapping work out
23:27:43 <glguy> but we can do something to that it works on Sets again
23:28:00 <koz_> glguy: setmapped can do that I think.
23:28:16 <glguy> No, we need an Iso
23:28:39 <koz_> What kinda crazy type would that even *have*?
23:29:26 <lpaste> glguy annotated “don't know what it does but it typechecks now” with “closer” at http://lpaste.net/164685#a164687
23:29:32 <glguy> a type like that
23:30:07 <koz_> glguy: I *clearly* don't know lenses.
23:30:51 <koz_> So you're lifting an Iso between types into an Iso between *setters* on those types?
23:30:56 <koz_> Sorry, Sets, derp.
23:31:02 <koz_> OK, that makes a bit more sense.
23:31:09 <glguy> That's what you were doing earlier, we're just naming it
23:31:36 <lpaste> glguy revised “closer”: “closer” at http://lpaste.net/164687
23:32:25 <koz_> What does 'review' give us again?
23:32:45 <koz_> I'm guessing by its positioning 'review x' == 'view (from x)'?
23:32:54 <glguy> it's like writing   view (from x) -- technically view (re x)
23:33:13 <glguy> but since you're using rank2 types and taking Isos as arguments we can forget the difference
23:33:19 <koz_> I see.
23:34:05 <koz_> So in liftClause, we basically prism out of a Disjunction, lift our innard-Iso into the Set world, then rewrap?
23:34:11 <koz_> I just wanna make sure I'm not insane here.
23:34:18 <Welkin> koz_: you is
23:34:22 <koz_> Welkin: Lol.
23:34:41 <koz_> Isn't this the kind of thing lenses were made for?
23:35:04 <lpaste> glguy annotated “don't know what it does but it typechecks now” with “No with fewer ranks” at http://lpaste.net/164685#a164689
23:35:16 <glguy> Now with*
23:35:36 <glguy> koz_: Yeah, that sounds right
23:35:48 <koz_> glguy: Ah, so *that*'s how AnIsos get used.
23:35:54 <koz_> is there a reason to avoid Rank2Types?
23:36:01 <glguy> screws up type inference
23:36:20 <koz_> glguy: Even Rank2? I knew that RankN did.
23:37:12 <koz_> (AFAIK RankN is undecidable in the general case or something)
23:37:48 <koz_> Also, glguy, how long do I have to work with lenses before I can write magic like yours there?
23:38:42 <glguy> no idea, actually. I don't actually know when I started playing with the library
23:39:10 <koz_> glguy: I've been trying to make sense of it for 1 week+, and I'm *still* finding out I know nothing every day.
23:39:23 <koz_> I'm starting to feel like the Jon Snow of lenses.
23:40:06 <glguy> I don't use them for most day to day programming, but I find them interesting nonetheless
23:40:38 <koz_> They *are* very interesting.
23:40:49 <Welkin> I learned a few lens combinators
23:40:54 <Welkin> but I don't even use lens
23:46:15 <koz_> glguy: HLint suggests rewriting the lambda using 'iso `on` Set.map', but it seems not to make the typechecker happy. I assume that HLint is missing some critical info to inform its decision properly?
23:47:52 <glguy> :t on
23:47:54 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
23:48:21 <koz_> I see why it won't work.
23:48:30 <Welkin> you could write Dr. Seuess using lens
23:48:34 <glguy> Yeah, looks like an hlint buy
23:48:40 <glguy> Bug
23:48:41 <koz_> I'll ignore it for now.
23:48:47 <koz_> Well, given what we're making it do...
23:48:51 <koz_> (should I report it?)
23:49:39 <koz_> Welkin: I do not like green eggs and (Choice c, Profunctor f) => c (f a) -> f (c a), I do not like them AnIso' a b? :P
23:50:39 <glguy> Sure. I don't know what hlint's policy is for suggestions that depend on the types be valid
23:51:52 * hackagebot foldl 1.2.1 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.2.1 (GabrielGonzalez)
23:56:40 <koz_> OK, and reported. Thanks glguy!
