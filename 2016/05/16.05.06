00:01:46 <orb> Hi.  Does anyone know how (or whether) I can use Conor McBride's newtype package's ala to lift traverse?
00:02:06 <orb> and (<*>).
00:17:23 <cheater> @type ala
00:17:26 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
00:17:30 <cheater> wrong
00:17:43 <cheater> ala :: (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
00:17:47 <cheater> this is the one from the package
00:18:15 <cheater> it's ala NewtypeWrapper function argument
00:18:40 <cheater> so you'd like something that's like, say,   ala Product traverse xs
00:18:45 <cheater> @type traverse
00:18:47 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
00:19:39 <cocreature> :t \f -> ala Sum (\wrap -> traverse f . fmap wrap)
00:19:40 <lambdabot>     Could not deduce (Applicative Sum) arising from a use of ‘traverse’
00:19:40 <lambdabot>     from the context (Traversable t)
00:19:40 <lambdabot>       bound by the inferred type of
00:19:48 <cheater> so yeah, it looks fine to me
00:19:56 <cheater> the types check out
00:20:25 <cheater> not sure about what you wrote though cocreature
00:21:46 <cocreature> tbh I’m not entirely sure what orb is trying to do
00:21:58 <cocreature> ala Product traverse definitely doesn’t typecheck
00:22:12 <orb> cheater, cocreature: thanks.
00:22:25 <orb> I want to do something like under2, or over2.
00:22:41 <orb> The documentation for ala hints that this should be possible.
00:22:46 <orb> (Hence no under2 in the package.)
00:22:52 <cheater> do you run into errors though?
00:23:18 <urbanslug> cocreature: Hey uh do you have much time on your hands to help me with something?
00:23:22 <orb> I want to use the List Applicative for ZipLists.
00:23:45 <cheater> urbanslug: what issue do you have?
00:23:48 <urbanslug> Uh just that I'd want your opinion on something ideas, whatever you can give. Tell me what you think.
00:24:30 <urbanslug> cheater: Well I was asking cocreature specifically :) because I kinda know his nick from the interwebs and github.
00:24:39 <cheater> ok
00:24:46 <ocramz> morning all
00:24:48 <cheater> i hope one day to be famous like that
00:25:04 <urbanslug> cheater: It's not like that. I'm kinda ashamed of my newbiness.
00:25:16 <urbanslug> Long story, don't want to talk about it.
00:25:24 <cheater> it's ok
00:25:56 <urbanslug> cheater: Have you used haskell for web dev?
00:26:14 <cheater> sure
00:26:22 <ocramz> anyone relying on `stack` here?
00:26:28 <orb> ocramz: yes.
00:26:33 <urbanslug> ocramz: Most of us :)
00:26:40 <metl> is there a way to put a unicode code point in a string? like "#0x0123" ?
00:26:58 <cheater> use a backslash
00:27:15 <cheater> https://wiki.haskell.org/Unicode-symbols
00:27:24 <cheater> sorry, wrong link
00:27:44 <cocreature> lol I’m famous now? how did that happen
00:27:48 <cocreature> urbanslug: sure go ahead
00:28:12 <cheater> http://book.realworldhaskell.org/read/characters-strings-and-escaping-rules.html
00:28:16 <ocramz> orb urbanslug , great :) How is the single-module interaction supposed to be working? I mean, doesn't seemingly keep a global library, but instead one is supposed to rely on projects with a stack.yaml . Is this the only way? I mean, from a tinkering perspective
00:30:13 <metl> ok, so just \XXXX
00:30:39 <orb> single-module interaction?
00:30:54 <cheater> yes metl
00:31:03 <orb> What do you mean by single-module interaction?
00:31:11 <metl> ty :)
00:32:54 <ocramz> orb: exactly this: I set up a single file, `module Test0 where ..` and add dependencies and so on. I do this all the time, and I hope stack lets me work like this as well without having to setup a project and recompile half of Hackage for every throwaway module I create
00:33:34 <orb> ocramz: I don't know if it works that way.  I usually do: stack new SomeNewName, and tinker with the standard-ly named Lib.hs
00:33:45 <orb> (Perhaps even rename it, if I am feeling non-lazy.)
00:33:55 <orb> That's almost as little work as single module.
00:34:07 <orb> You don't have to recompile hackage.
00:34:13 <orb> It's usually pretty quick.
00:34:18 <orb> (Not sure what kind of caching they do.)
00:34:55 <orb> ocramz: oh, just tested, stack ghc SingleModule.hs also works.
00:35:13 <orb> stack says: "Run from outside a project, using implicit global project config"
00:36:30 <ocramz> orb, and this implicit global config would signify also a cache of libraries that were compiled for other projects, e.g. Vector or transformers or what have you
00:36:31 <ocramz> ?
00:37:18 <orb> ocramz: I think so.  I suggest you just check it out.
00:38:25 <orb> ocramz: yes, seems to work.
00:38:44 <orb> (You'll have to eg stack install vector, to install vector into the implicit global project.)
00:39:25 <ocramz> orb: I'm asking this because of how Emacs' haskell-mode fails to find this global cache. I'm using the stack provided with GHC for OSX
00:39:43 <orb> ocramz: sorry, I am using vim.
00:40:29 <ocramz> orb, but the editor shouldn't matter here. Once I understand Stack I can figure the rest out 
00:41:11 <orb> ocramz: I use stack from the command line.
00:42:40 <ocramz> orb, right. That's the easiest
00:42:50 <ocramz> thanks for the tips
01:09:44 <{AS}> Is it possible to extract datatype definitions from definitions of eliminators (folds) alone?
01:10:23 <{AS}> e.g. if I have (a -> a -> z) -> a -> z
01:10:36 <{AS}> I may know that this requires a pair
01:15:05 <{AS}> wait that is the wrong eliminator
01:15:09 <{AS}> Hmm, nevermind
01:31:20 <fessguid> Hello, new to the haskell and looking for the way to use it on frontend and backend. Can anybody say how ghcjs is ready for production? Can I really reuse the code, what are disadvantages? And maybe somebody have tried it with react-native?
01:32:30 <Cale> fessguid: We're using it in production for our clients' web applications
01:32:41 <Cale> fessguid: In particular, with reflex-dom
01:33:21 <Cale> fessguid: It's pretty ready :)
01:34:07 <fessguid> Cale: Thank you. Are you happy about that? If you start from the scratch today, will you consider PureScript or Elm for example?
01:35:24 <Cale> Quite happy -- While we still have a ways to go on producing documentation for Reflex and making it easy to learn, I think it's a good bit ahead of the other systems technically.
01:36:10 <fessguid> Cale: Thank you very much, I'll go and play with it then
01:36:19 <zomg> Cale: it would be interesting to read what insights you've found from using Haskell in web development compared to what you usually see used for that (ie. node, php, python, rails)
01:36:47 <Cale> fessguid: Check out https://github.com/reflex-frp/reflex-platform
01:37:07 <fessguid> Cale: Thanks, I will
01:37:15 <Cale> fessguid: It has a try-reflex script you can use to get ghcjs set up in an environment with reflex and reflex-dom
01:37:43 <fessguid> Cale: Oh nice, exactly what I need to start with
01:37:51 <Cale> zomg: Well, the main insight is "hey, this actually doesn't horribly suck"
01:39:34 <Cale> zomg: By sharing API types between the backend and frontend, you can make changes to something on the backend, for example, and run the compiler and fix type errors and eventually get to making a change to your API, and then have the type errors propagate through to the frontend
01:40:57 <Cale> zomg: and the fact that it's the same Aeson-generated instances reading and writing the JSON on both sides is nice, you basically never have a bug related to the JSON format
01:41:18 <fessguid> Another question about GHCJS if I may: Can I produce independent modules/libs using it and then just distribute and use it from JS language? 
01:41:19 <Cale> and then there's all the nice things about using FRP to build interactive GUIs
01:41:26 <zomg> Cale: yeah sounds pretty much the same as I thought :)
01:41:41 <zomg> but I've not used haskell in production that extensively myself, just a bit here and there
01:41:44 <Cale> fessguid: maybe??? It's easier to go the other way.
01:42:13 <Cale> fessguid: Well, it ought to be theoretically possible. I don't know of anyone who is doing it.
01:42:49 <Cale> fessguid: The code size has a large enough constant term that if you're going to use ghcjs, you're going to want the majority of your app's code in it, most likely.
01:43:01 <fessguid> Cale: Part of my app is in ClojureScript and I was thinking how can I gradually move it to Haskell. My idea was to use GHCJS to produce some JS modules ant attache them together
01:44:09 <fessguid> Cale: Size is not a problem for me, I'm using it with react-native, so all JS is just part of a bundle
01:44:43 <Cale> fessguid: btw, feel free to join us in #reflex-frp -- there are some knowledgeable people who hang out there who are too busy to follow #haskell
01:45:07 <fessguid> Cale: Got it, thanks
01:45:44 <Cale> fessguid: Oh, you might also be interested in the fact that if you compile a reflex-dom application with GHC, then you get a native webkit application
01:46:33 <fessguid> Cale: Read about it yeah, looks really cool. 
02:15:32 <ij> Can I change a data's entry that is prefixed with _?
02:16:08 <cocreature> ij: yep
02:18:38 * hackagebot hw-json 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.0.0.1 (haskellworks)
02:18:44 <ij> Not like this, surely? http://46.109.13.1/share/prtscr/4IF.png
02:19:46 <cocreature> can you show the export list of Types.hs?
02:20:09 <DwarfSocks> hey, does anyone know if it's possible to setup haskell-mode in emacs to run stack build/stack exec instead of the cabal commands?
02:20:56 <ij> cocreature, module Network.IRC.Client.Types ( module Network.IRC.Client.Types -- * Re-exported , Event(..) , Source(..) , Message(..)) where
02:22:12 <cocreature> ij: that’s not exporting ConnectionConfig at all?
02:22:21 <ij> I am wondering myslf.
02:22:56 <hvr> DwarfSocks: try 'M-x customize-mode' inside a haskell buffer
02:23:29 <hvr> DwarfSocks: there's lots of knobs you can tweak in haskell-mode via the customize-interface, including which commands are called
02:23:59 <cocreature> oh I missed the module … thing at the beginning
02:24:49 <DwarfSocks> hvr: thanks!
02:53:42 <ij> cocreature, The new version wasn't in stack... :(
02:53:55 <ij> Well loaded, that is.
03:02:20 <Darwin226> Hey guys. Is it possible to have a haskell value that holds some foreign pointer and somehow hook into the GC so that I can free the pointer when no other haskell values hold it's reference?
03:04:54 <lyxia> Darwin226: maybe you want a weak pointer
03:05:35 <Darwin226> lyxia: Hmm, that wouldn't help me with automatic deallocation, would it?
03:06:09 <cocreature> ForeignPtr already allows you to pass in a finalizer iirc?
03:07:05 <Darwin226> cocreature: So that's a function that will get called when the actual ForeignPtr value get's GCd?
03:07:35 <lyxia> right
03:07:54 <quicksilver> the exact timing guarantee is weak I think
03:07:58 <quicksilver> but that's the correct intuition
03:08:29 <Darwin226> Wow, that's exactly what I need
03:08:32 <Darwin226> Awesome
03:08:39 * hackagebot network-conduit-tls 1.2.1.1 - Create TLS-aware network code with conduits  https://hackage.haskell.org/package/network-conduit-tls-1.2.1.1 (MichaelSnoyman)
03:08:39 <Darwin226> Thanks
03:10:19 <cocreature> the only thing it guarantees iirc is that the finalizer will be run exactly once and it will only be run when there are no more references to the ForeignPtr
03:14:01 <quicksilver> cocreature: "at most" once
03:14:03 <quicksilver> IIRC.
03:14:29 <cocreature> quicksilver: I thought WeakPtr runs at most once but ForeignPtr will be run on program exit if it hasn’t been called before
03:15:09 <bollu> what's a Kan extension?
03:15:09 <cocreature> “ There is no guarantee of promptness, however the finalizer will be executed before the program exits.”
03:15:16 <bollu> I'm reading the docs on Codensity
03:15:27 <bollu> cocreature: oh, bindings? to which library?
03:15:54 <cocreature> bollu: I was just answering a question of DwarfSocks 
03:16:01 <cocreature> eh Darwin226 who left
03:16:08 <bollu> ah, I see :)
03:16:21 <ski> bollu : funny i was just thinking about Kan extensions :)
03:16:48 <quicksilver> cocreature: ah good
03:17:00 <bollu> ski: :) go on, any background I can use? ELI(know some cat theory because haskell)
03:17:05 <quicksilver> I'm always thinking about Kan extensions
03:17:08 <quicksilver> even when I don't realise it
03:17:08 <ski> bollu : can extensions are adjoint functors to the "compose on the right" functor
03:17:44 <ski> bollu : a prerequisite for understanding the math of it is then to understand adjunctions
03:17:49 <bollu> ski: back a step then. what's an adjunction?
03:18:03 <bollu> ski: I know a fair of undergrad level pure math if that helps
03:18:05 <ski> bollu : for particular applications, it may suffice to know less
03:18:28 <ski> bollu : well, first you must know what a category is, and what a functor is. also natural transformations
03:18:28 <bollu> ski: so you can algebra / analysis / topology your explanation :) So, well, what's an adjunction?
03:18:55 <bollu> ski: I know those. A category is a collection of objects and arrows, a function is a morphism of categories, and a natural transformation is..
03:18:56 <ski> bollu : roughly speaking, adjoint functors are a sort of "weak inverse"
03:19:14 <bollu> a natural transformation is a mapping between _functors_, correct?
03:19:18 <bollu> ski: hm, okay
03:19:20 <ski> yep
03:19:38 <ski> bollu : do you know anything about galois connections ?
03:20:18 <ski> (covariant) galois connections are adjunctions (in the special case of preorders. or perhaps they usually require a partial order, not sure)
03:20:23 <bollu> ski: nope. Is it about the correspondence of subgroups (galois group) <-> sub-extensions (field extension)?
03:20:45 <ski> well, forget about galois connections here, then
03:20:47 <bollu> okay
03:21:09 <ski> bollu : you know how given any set, you can form a vector space with the elements of that set as basis vectors ?
03:21:59 <bollu> ski: um, any set? no, I do not know this. Don't you need a vector space structure on the set to be able to do that? 
03:22:26 <ski> bollu : e.g., given the set `{e_0,e_1}' with two elements, we get two-dimensional space `|R^2'
03:22:59 <ski> bollu : you can regard this as a definition of what it means to have a basis of a vector space ..
03:23:11 <bollu> ski: oh, so you're making the set be the "basis set" over R
03:23:12 <bollu> gotca
03:23:15 <bollu> gotcha*
03:23:15 <amnn> ski, you get something isomorphic to |R^2
03:23:16 <ski> yep
03:23:19 <bollu> righy, go on
03:23:22 <ski> amnn : yes. same thing :)
03:23:49 <ski> (there's a canonical isomorphism)
03:23:56 <amnn> indeed
03:24:07 <ski> bollu : well, this construction is an example of an adjoint functor
03:24:16 <bollu> ski: okay, how so?
03:25:03 <ski> bollu : well, let's start with the functor `U : Vect >---> Set', the underlying/forgetful functor, which ignores the vector space structure, and only recalls the underlying set
03:25:49 <bollu> ski: okay, so you can recover the set S given the vector space V
03:25:51 <ski> bollu : a *left* adjoint to this functor is, by definition, a functor in the opposite direction, satisfying a certain condition
03:26:13 <ski> bollu : it turns out that this `Free : Set >---> Vect' functor is in fact the left adjoint to `U'
03:26:41 <amnn> ski, bollu, related: https://twitter.com/nicolasgwu/status/531011332775370753
03:27:07 <bollu> ski: what's the precise condition? Some universal property right?
03:27:14 <orb> What's a good package to use for combining Applicatives?  (Ie composition, product, etc?
03:28:13 <ski> bollu : in general, given any catgories `C', and `D', and any two functors `F : C >---> D' and `G : D >---> C', we say that `F' and `G' (in that order) forms an *adjunction situation*, in case `Hom_D(F A,B)' is naturally isomorphic to `Hom_C(A,G B)', in `A' (from `C') and `B' (from `D')
03:28:32 <ski> bollu : we say that `F' is the left adjoint to `G', and `G' is the right adjoint to `F'
03:29:09 <ski> this adjunction situation is often written symbolically as `F --| G'
03:29:35 <ski> bollu : consider the concrete case with `F' being `Free' and `G' being `U' (and `C' is `Set' and `D' is `Vect')
03:30:02 <bollu> ski: question: (F A and B) will live in two different categories, correct? F A \in D, B \in D?
03:30:22 <ski> bollu : we're claiming that we can convert between `T : Free S >---> V' and `f : S >---> U V', in a way natural in the set `S' and the vector space `V'
03:30:54 <ski> bollu : `A' lives in `C', so `F A' lives in `D', where `B' also lives. so not two different categories, no
03:31:11 <bollu> Ah, gotcha
03:31:34 <ski> bollu : so, given any function `f' which maps the elements of the "basis set" `S' into `U V', the underlying set of the vector space `V'
03:32:04 <ski> we're claiming that there corresponds a unique linear transformation `T' from the free vector space `Free S', into `V'
03:32:25 <ski> namely by mapping the basis vectors in `Free S' according to `f', and otherwise define `T' by linearity
03:33:01 <ski> does that make sense ?
03:33:11 <bollu> ski: 'Free S' is the vector space we created by taking elements of 'S' as the basis, correct? and 'V' is..?
03:33:22 <ski> yes to `Free S'
03:33:36 <ski> and `V' is just any plain old vector space (with or without a basis)
03:34:15 <ski> we're decribing that to map out of a "based" vector space, it suffices to decide how to map the basis vectors
03:34:46 <ski> (by a "based" vector space, i mean one having a basis. iow one which is isomorphic to `Free S', for some set `S')
03:34:55 <bollu> ski: 'U V'  now is the vector space 'V' with 'S' as the basis right? and 'V' is "just the vector space" while ignoring the basis structure?
03:35:08 <ski> nono. not at all
03:35:41 <ski> `V' is any vector space at all, and `U V', perhaps more commonly written as `|V|', or just `V', is the underlying set of that vector space
03:35:51 <ski> `S' has nothing (directly) to do with `V' at all
03:36:05 <ski> we're not claiming here that `V' need to have any basis
03:36:30 <ski> we're not ignoring any basis structure here
03:36:45 <ski> we're ignoring the vector space structure of `V', when we do `U V'/`|V|'
03:36:53 <bollu> so, 'U V' will contain (formal) sums of the basis elements of 'S', right ?
03:37:00 <ski> no
03:37:09 <ski> `Free S' will contain that
03:37:33 <bollu> so 'U V' contains?
03:37:51 <ski> it's just the set of vectors of `U', which is an arbitrary vector space
03:38:05 <ski> er, of `V'
03:38:30 <bollu> but _which vector space_ is V?
03:38:35 <ski> doesn't matter
03:38:37 <ski> any one you like
03:39:12 <ski> the above conversion works regardless of which vector space `V' is
03:39:20 <bollu> ahh, okay :)
03:39:26 <bollu> Could we restart please?
03:39:28 <ski> (and, importantly, it's *natural* in the choice of `V')
03:39:58 <ski> <ski> bollu : we're claiming that we can convert between `T : Free S >---> V' and `f : S >---> U V', in a way natural in the set `S' and the vector space `V'
03:40:01 <ski> from there ?
03:40:22 <bollu> yes please :)
03:40:37 <ski> so, do you see how `f' uniquely determines `T' ?
03:41:39 <ski> `f' specifies, in an arbitrary way, how to map the basis elements, into elements of the underlying set of `V'
03:42:22 <bollu> yes, because f: S -> 'U V', we know which vectors in 'V' are basis vectors of the vector space V. Since we know the basis vectors of 'Free S' (which are simply elements of S and the basis vectors  of 'V' through f, we can write down T uniquely by mapping the correct basis vectors from 'Free S' to 'V'
03:42:22 <ski> and when defining the linear transformation `T' from this, we define it to map the basis vectors in `Free S' (iow basically just the elements of `S') according to `f'
03:42:52 <ski> "we know which vectors in 'V' are basis vectors of the vector space V" -- no, not at all
03:43:18 <ski> let's take this example. we want to define `T : |R^2 >---> |R^3'
03:43:40 <ski> and, i was claiming that `|R^2' is iso to `Free {e_0,e_1}', so let's just accept that part for the moment
03:43:40 <bollu> okay..
03:43:47 <bollu> cool, right
03:43:56 <ski> so, we want to define `T : Free {e_0,e_1} >---> |R^3'
03:44:25 <ski> so, we're claiming that to define this *linear* *transformation* it suffices to define an arbitrary function
03:44:35 <ski>   f : {e_0,e_1} >---> |R^3
03:44:44 <ski> (using `|R^3' here also for the underlying set)
03:44:52 <ski> e.g. we can define this as
03:45:02 <ski>   f(e_0) = (1,0,2)
03:45:05 <ski>   f(e_1) = (1,0,2)
03:45:17 <bollu> oh, "f" is a plan function, and not a linear transformation, while T is a linear transformation. Hm, I'd missed that.
03:45:41 <ski> now, (a) the vectors that `f' map `{e_0,e_1}' need not be linearly independent (they're not, here)
03:46:23 <ski> and (b) the vectors that `f' maps `{e_0,e_1}' into need not span the codomain (they're not spanning it here, either)
03:46:39 <ski> yes, `f' is an arbitrary morphism of `Set'
03:47:20 <bollu> right. So, in that case, how exactly do we get a linear transformation T?
03:47:42 <ski> so, the point is, by *arbitrarily* specifying how the basis vectors should map, we can always extend this by linearity to also specify how all the other formal sums should be mapped
03:47:58 <ski> so
03:48:04 <amnn> this example might be a bit complicated, because I think it is actually the composition of two adjunctions, between Vect and Field, and Field and Set
03:48:05 <ski>   T(e_i) = f(e_i)
03:48:15 <bollu> so you're saying T(a e_0 + b e+1) = a f(e_0) + b f(e_1) ?
03:48:34 <ski>   T(sum_{i in I} x_i * e_i) = sum_{i in I} x_i * f(e_i)
03:48:43 <ski> bollu : yep
03:49:13 <ski> amnn : hm, i haven't thought about that
03:49:21 <bollu> oh, hm, so a random *morphism* from S -> |V| somehow provided us a way to "lift" into Free S -> V?
03:49:27 <ski> yes
03:49:39 <ski> bollu : and also vice versa, in a bijective way
03:49:41 <bollu> okay, so which part of this is the adjunction? what is "f" and what is "g"?
03:49:47 <ski> and further, this is natural in `S' and `V'
03:50:16 <ski> the adjunction is between the functor `Free', and the functor `| _ |'
03:50:16 <amnn> for an arbitrary set {e_0, e_1}, we don't actually have access to the +, and * we need without first forming a free field over the set.
03:51:10 <ski> so, the general picture `F --| G' in this case is `Free --| | _ |'
03:51:22 <bollu> so the adjunction between 'Free' and '| |' allowed us to define a morphism from Free S -> V given  S -> |V|?
03:51:28 <bollu> that is freaking insane
03:51:34 <ski> bollu : yes. and vice versa
03:51:39 <bollu> ooh, that's super neat
03:51:52 <bollu> but, how is this related to a "weak inverse" ?
03:52:26 <amnn> bollu, this concept is a generalisation of isomorphisms between categories
03:52:27 <ski> bollu : ok, so there's several variants of how to specify the condition for being an adjunction. but they're all equivalent
03:53:36 <ski> bollu : for `f : A >---> B' and `g : B >---> A' to be inverses, we require `f . g = id_B' and `id_A = g . f'
03:53:53 <bollu> ski: right. 
03:54:44 <ski> bollu : for `F : C >---> D' and `G : D >---> C' to form an adjunction situation, we require two natural transformations `epsilon : F . G >---> id_D' and `eta : id_C >---> G . F', satisfying a few conditions
03:55:21 <ski> bollu : in the "isomorphism of categories" example (usually called equivalence of categories), these natural transformations would have been natural *isomorphisms*
03:56:20 <ski> `eta' is known as the "unit" of the adjunction, while `epsilon' is the "counit"
03:56:57 <bollu> F . G is the composition of functors, right? so id_D is the "identity functor on D"?
03:57:04 <ski> yes
03:57:06 <amnn> bollu, that's right
03:57:14 <ski> bollu : and the conditions, you ask ?
03:57:50 <bollu> yes, what are the conditions?
03:58:40 * hackagebot BlogLiterately 0.8.2.2 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.2.2 (BrentYorgey)
03:59:36 <ski> bollu : well, start with `F', which is `F . id_C'. using `F . eta' we get to `F . G . F'. using `epsilon . G', we get back to `F'. this ought to be the identity natural transformation on `F', iow `id_F'
04:00:03 <ski> <bollu> yes, what are the conditions?
04:00:06 <ski> <ski> bollu : well, start with `F', which is `F . id_C'. using `F . eta' we get to `F . G . F'. using `epsilon . G', we get back to `F'. this ought to be the identity natural transformation on `F', iow `id_F'
04:00:11 <bollu> sorrry, I DC'd
04:01:21 <ski> bollu : then, starting instead with `G', which is `id_C . G'. using `eta . G', we get `G . F . G'. using `G . epsilon', we get `G . id_D', which is `G'. this should be the same as `id_G'
04:01:54 <bollu> what exactly do you mean by "using G . epsilon"?
04:02:07 <ski> bollu : these conditions are equivalent to the condition i named above about the isomorphism between `F A >---> B' and `A >---> G B', natural in `A' and `B'
04:02:47 <bollu> oh, hm
04:03:05 <bollu> ski: right, okay, so the pair F and G form an adjunction, right?
04:03:09 <bollu> over C and D?
04:03:15 <ski> bollu : `.' is a bifunctor. by `G . epsilon' i mean applying the natural transformation `epsilon' : F . G >---> id_D' on the "right" part, and using identity on the left
04:03:40 * hackagebot houseman 0.1.0 - A Haskell implementation of Foreman  https://hackage.haskell.org/package/houseman-0.1.0 (DaisukeFujimura)
04:03:41 <ski> so, from `epsilon : F . G >---> id_D', we get `G . epsilon : G . F . G >---> G . id_D = G'
04:04:20 <ski> bollu : this is similar to if `g : B_0 >---> B_1', then `A * g : A * B_0 >---> A * B_1'
04:05:10 <ski> it's just that in our case, we had the functor `(.) : E^D * D^C >---> E^C', instead of `(*) : Set * Set >---> Set'
04:05:32 <bollu> ohh, gotcha
04:05:32 <bollu> at least, I think :)
04:05:32 <bollu> right, so, go on ski
04:05:44 <ski> ok
04:06:35 <ski> anyway, this situation where you have an "underlying/forgetful functor" (usually not terribly interesting its own), but where there exists a left adjoint to it, is quite common
04:06:56 <ski> (adjoints are unique, but need not exist)
04:07:55 <bollu> which part is the left adjoint? G is left adjoint to F, correct?
04:07:58 <bollu> I'm assuming the order matters?
04:08:39 <ski> ".., we say that `F' and `G' (in that order) forms an *adjunction situation*, ..", yes
04:08:53 <ski> `F' is left adjoint to `G', with the naming i used above
04:09:22 <ski> <bollu> I'm assuming the order matters?  <ski> ".., we say that `F' and `G' (in that order) forms an *adjunction situation*, ..", yes  <ski> `F' is left adjoint to `G', with the naming i used above
04:09:40 <bollu> hmm
04:10:08 <bollu> ski: so if I reverse the order? is it possible that F and G form an adjunction situation while G and F don't? Like, weren't all our conditions symmetric?
04:10:13 <ski> in the natural iso between `F A >---> B' and `A >---> G B', note that `F' "occurs to the left"
04:10:28 <ski> bollu : "is it possible that F and G form an adjunction situation while G and F don't?" -- yes, it's possible
04:10:55 <ski> in the `Free : Set >---> Vect' and `U : Vect >---> Set' case, `Free' is for sure *not* a right adjoint to `U'
04:11:07 <ent> sln
04:11:55 <ski> "weren't all our conditions symmetric?" -- nope. only if you simultenously pass to the opposite categories, i think
04:12:09 <bollu> hmm
04:12:30 <ski> if we have a functor which we think of as "underlying/forgetful" (usually we'd require it to be faithful), then we call its left adjoint (in case it exists) the "free functor"
04:13:13 <ski> so, there is an underlying functor from `Group' to `Set'. its left adjoint is the construction that generates the free group over a set of generators
04:13:37 <ski> similarly with `Ab' in place of `Group' (though the result is smaller in that case)
04:13:44 <bollu> in F |- G, is group to set F or G?
04:13:54 <bollu> the "left" / "right" terminology is confusing to get used to, sorry 
04:13:55 <ski> it was `F --| G', not `F |- G'
04:14:02 <bollu> whoops :)
04:14:21 <bollu> right, so, F —| G. Is Group -> Set F or G?
04:14:24 <ski> assuming `F --| U' here, `U' would be the underlying functor from `Group' to `Set'
04:14:49 <ski> the free functor is left adjoint to the underlying/forgetful one
04:14:49 <bollu> and F is the "free functor" ?
04:14:52 <ski> yes
04:14:55 <bollu> oh, of course!
04:15:24 <bollu> The right functor is "stripping out" structure, so the one to the left is _forced_ to make "as little choice as possible" where reconstructing the object, so it gives you the "Free" structure
04:15:25 <bollu> right?
04:15:55 <ski> exactly
04:16:05 <ski> "add/assume as little as possible"
04:16:17 <bollu> I still don't see why the Free functor is to the left and why the Forgetful functor is to the right
04:16:26 <ski> now, consider instead the example `U : Ab >---> Group', forgetting only that the group was abelian
04:16:27 <bollu> like, how the conditions of the adjoint force the hand
04:16:43 <ski> the left adjoint / free functor to this is the abelianization of the give group
04:17:09 <ski> iow, identify as few elements of the group as possible, in order to force it to be abelian
04:17:10 <bollu> so that is the mapping from G -> G/(Commutator of G)?
04:17:15 <ski> yes
04:17:18 <bollu> nice
04:17:44 <ski> also, consider `U : PO >---> PreOrd', from partial orders to preorders
04:17:50 <bollu> ski: could you elaborate as to "why" the forgetful functor is forced to be on the right?
04:17:58 <bollu> while the free functor is forced to be on the left?
04:18:05 <bollu> as in, why is the opposite direction "wrong"?
04:18:07 <ski> the free functor here identifies associated elements, iow elements `x' and `y' where `x =< y' and `y =< x'
04:18:16 <ski> forcing anti-symmetry
04:19:31 <bollu> hm, the map U forgets the anti-symmetry structure right?
04:19:38 <ski> well, is we think of `D' as being an "enriched" variant of `C'. iow objects in `D' are just objects in `C', with some extra structure (operations ior laws)
04:19:44 <ski> bollu : yep
04:20:08 <bollu> ski: okay, continue please. So, "D" is enriched.
04:20:27 <bollu> hence, D -> C will be forgetful and C -> D will be free, right?
04:20:31 <ski> yep
04:21:02 <bollu> so if we get F: C -> D and U: D -> C as adjunctions, you can _conclude_ that D has more structure than C?
04:21:07 <ski> then `F A >---> B' corresponding to `A >---> U B' makes sense since we're claiming that from any underlying morphism from `A' to `U B' ("essentially just `B'"), we can make a morphism from `F A' to `B'
04:21:37 <ski> so, `F A' has to be the `D'-structure that assumes as little as possible, apart from what is required from the underlying `C'-structure on `A'
04:21:53 <ski> because, in general, morphisms in `C' are more "arbitrary" than ones in `D'
04:22:08 <ski> ones in `D' have to satisfy the extra structure that `D' adds over `C'
04:22:31 <bollu> we are given F A >—> B and we are to construct A >—> U B right?
04:22:53 <bollu> oh, the other way around?
04:23:05 <ski> if we plug in identity for `F A >---> B', iow set `B' to `F A', then the conversion will give us the unit `A >---> U (F A)', which includes the "lower" structure into the "upper" one
04:23:16 <ski> bollu : either way should work
04:23:37 <ski> bollu : but often one will consider the direction from `A >---> U B' to `F A >---> B'
04:23:51 <ski> iow, from a morphism in `C', to a morphism in `D'
04:25:19 <bollu> ski: we usually consider (A >—> U B) -> (F A >—> B), right? that is, take structure in the lower one and lift it into the upper one? But the other way around is also possible?
04:25:50 <bollu> and this is so freaking cool, like, how the hell does one realize that it's possible to generalise something like "more structure", "forgetful" and "free"? 
04:25:50 <ski> if we plug in the identity on the other side of the conversion, iow set `A' to `U B', then we instead get the counit `F (U B) >---> B'
04:26:26 <ski> bollu : yes, that direction is probably more common to consider. but it should be a bijection (well isomorphism, natural in `A' and `B')
04:26:54 <ski> bollu : with enough examples, analogies and structure appear to present itself, i suppose
04:27:05 <ski> bollu : now, a few more example
04:27:23 <ski> consider `Top' the category of topological spaces and continuous functions
04:27:32 <bollu> ski: so, all we care about is the adjunction condition to work out, then we can immediately gain the facts that: (a) D has more structure than C. (b) a forgetful functor from D -> C. (c) a Free functor from C -> D?
04:28:02 <ski> the left adjoint to `U : Top >---> Set' (the free functor from `Set' to `Top') is the discrete topology functor
04:28:17 <ski> given any set, it adds the topology in which every subset is open (and also closed)
04:28:33 <amnn> bollu, illustration for you: https://www.dropbox.com/s/zhx08ozop2sggld/IMG_20160506_122426949.jpg?dl=0
04:28:49 <ski> so continuous functions from that topology are arbitrary, not restricted
04:28:58 <bollu> ski: right, that's the finest topology possible over any set right?
04:29:34 <amnn> not all adjunctions are of the free/forgetful variety
04:29:45 <bollu> how do you remember which is to the left and which is to the right?
04:30:09 <amnn> bollu, that is what that tweet I linked was for "F --| G because F is free, and G is 'getful"
04:30:31 <bollu> ahh :)
04:30:31 <ski> amnn : heh, haven't heard that one before :)
04:30:36 <amnn> (so the free functor is the left adjoint)
04:30:53 <ski> bollu : anyway, any idea what the *right* adjoint of `U' would be ?
04:31:29 <ski> <bollu> ski: so, all we care about is the adjunction condition to work out, then we can immediately gain the facts that: (a) D has more structure than C. (b) a forgetful functor from D -> C. (c) a Free functor from C -> D?
04:31:33 <ski> not really
04:31:37 <ski> the (a) part doesn't follow
04:32:01 <ski> it's extra data that we have to plug in, in order for the "underlying, resp. free functor" terminology to make sense
04:32:36 <bollu> ski: right adjoint to U in general or in the case of `U: Top >—> Set`?
04:33:16 <ski> but if we already know that `D' in some sense has more structure than `C', e.g. by the existence of a faithful functor `U : D >---> C', then it would usually make sense to call this underlying/forgetful, and the left adjoint (in case it exists) the free functor
04:33:31 <ski> (there are situations in which we don't require it to be faithful, though)
04:33:38 <ski> bollu : this was in general
04:34:04 <ski> well, what i just said here was in general. as a response to the message of yours that i quoted
04:34:23 <ski> bollu : but the right adjoint of `U' was for the specific case `U : Top >---> Set'
04:34:29 <bollu> hm
04:34:44 <bollu> well, It would have to be something that has _more_ information?
04:35:02 <ski> hm. not sure what you mean by "_more_ information" here
04:35:31 <bollu> something that creates a metric space on S that has Top as the underlying topology? but that's not very generic, because some topo. spaces can't have a metric on them
04:35:57 <bollu> well, for U to have a right adjoint, it must mean that it should be the "left adjoint" of _something_, right? so it should "become a free functor"?
04:36:03 <ski> for any function `f : U T >---> S', there should be continuous function `c : T >---> G S', where `G' here is supposed to be the right adjoint of `U'
04:36:24 <ski> `T' is any topological space whatsoever
04:36:28 <amnn> bollu, not all left adjoints are free, but free functors are left adjoints to forgetful functors.
04:36:37 <ski> (and `S' any set whatsoever, as before)
04:36:58 <metl> :i Pico
04:37:03 <metl> :t Pico
04:37:04 <lambdabot> Not in scope: data constructor ‘Pico’
04:37:13 <ski> bollu : well, it turns out that the right adjoint in this case is pretty trivial
04:37:19 <ski> bollu : shall i saw what it is ?
04:37:24 <ski> s/saw/say/
04:37:54 <bollu> yes please. 
04:38:00 <ski> ok
04:38:02 <bollu> ski: will the identity functor work?
04:38:10 <ski> <bollu> well, for U to have a right adjoint, it must mean that it should be the "left adjoint" of _something_, right? so it should "become a free functor"?
04:38:14 <ski> ^ what amnn said
04:38:17 <amnn> bollu, doesn't type check
04:38:26 <ski> what amnn said :)
04:38:40 <ski> we require here `G : Set >---> Top'
04:38:41 * hackagebot cabal-rpm 0.9.11 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-0.9.11 (JensPetersen)
04:38:44 <bollu> hmm
04:38:44 <bollu> right
04:38:47 <ski> (so in the same direction as the free functor)
04:39:19 <ski> ok, i'll say it
04:39:22 <bollu> take the nono
04:39:23 <bollu> no
04:39:25 <amnn> bollu, (but fwiw when you write down a forgetful functor, it looks very much like an identity functor, because you are doing no "computation", you are just loosening the "type constraints")
04:39:26 <bollu> gimme a minute :)
04:39:28 <ski> ok
04:40:48 <bollu> what are the elements of T? as in, what is 'U T -> S' mapping? the open sets, right?
04:42:23 <bollu> the category has open sets as objects and continuous functions as morphisms?
04:42:36 <bollu> oh wait, I'm stupid*
04:42:51 <bollu> The objets are topological spaces, and the morphisms are continous maps *between* top. spaces right?
04:43:08 <amnn> bollu, in Top, yes
04:43:09 <ski> `T' is a topological space. it consists of an underlying set `U T', and a selection of some of its subsets as "open", subject to a few conditions
04:43:27 <ski> `U T >---> S' is mapping the points of the underlying set. not the open sets
04:43:34 <ski> the open sets map in the opposite direction
04:43:56 <ski> "the category has open sets as objects" -- no
04:44:10 <ski> you got it right the last time
04:44:30 <bollu> "the last time" referring to which time? :)
04:44:39 <ski> <bollu> The objets are topological spaces, and the morphisms are continous maps *between* top. spaces right?
04:44:42 <ski> naturally :)
04:44:58 <bollu> xD
04:44:59 <bollu> okay
04:45:14 <bollu> so, U T is a set of topo. spaces right?
04:45:27 <amnn> no, U T is the underlying set of the topological space T
04:45:33 <ski> no, it's the set of points of the topological space `T'
04:45:33 <metl> anyone know how to get the integer out of a Pico?
04:45:41 <bollu> hmm
04:45:51 <ski> metl : defined in which package ?
04:45:55 <bollu> ohh okay
04:45:59 <metl> Data.Fixed
04:46:17 <amnn> bollu, and if c is a continuous map, `U c` is a function (we are just forgetting that it is a continuous function)
04:46:27 <ski> metl : no such package
04:46:29 <bollu> ammn: right
04:46:36 <bollu> amnn: right*
04:46:54 <bollu> so the right adjoint must somehow figure out how to make sure that functions go to continuous functions
04:47:12 <metl> ski: http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Fixed.html ?
04:47:27 <ski> ok, so the package is `base', then
04:47:45 <bollu> ski: I give up, I'm not sure what I'm looking for
04:48:56 <amnn> bollu, the right adjoint is a functor G, going from Set --> Top, which, takes sets to topological spaces, and functions between two sets to continuous maps between the two topological spaces it created from those two sets.
04:49:27 <metl> i've actually got a POSIXTime which is from the `time` package
04:49:41 <bollu> amnn: you can take the set and impose a discrete topology on the set?
04:50:20 <bollu> that way every function automatically becomes continuous?
04:51:59 <amnn> is there a natural isomorphism between [U _, _] and [_, G _] ?
04:52:00 <bollu> ski: amnn am I correct?
04:52:34 <maerwald> metl: and what do you want to do with the time?
04:52:42 <ski> metl : ok, so, as far as i can see, you just strip off the `MkFixed' data constructor, and divide by the `resolution'
04:53:04 <ski> metl : strange that there isn't already an operation for this this ..
04:53:16 <metl> maerwald,ski: POSIXTime is just a type synonym for NominalDiffTime which is a newtype for Fixed, but the MkNominalDiffTime constructor is not exported
04:53:21 <bollu> ski: correct / wrong?
04:53:31 <maerwald> metl: that doesn't answer the question :o
04:53:49 <koz_> What's the difference between transformers and mtl, and which one should I use?
04:53:52 <ski> bollu : imposing the discrete topology doesn't work in this case
04:53:53 <metl> maerwald: i want to convert it to an Integer and print it
04:53:55 <bollu> or did I understand it completely wrong?
04:54:04 <ski> bollu : that's for the left adjoint. and it doesn't work for the right adjoint here
04:54:20 <ski> (of course, there are cases where the left and right adjoint of a given functor coincide)
04:54:34 <maerwald> metl: look at the class instances of NominalDiffTime
04:54:41 <bollu> ski: discrete topology?
04:54:47 <maerwald> it has RealFrac, Show and so on
04:54:53 <metl> * NominalDiffTime is a newtype for Pico rather
04:54:56 <ski> bollu : that was in response to
04:54:58 <ski> <bollu> amnn: you can take the set and impose a discrete topology on the set?
04:55:01 <bollu> ski: ohh, thanks :)
04:55:02 <bollu> hmm
04:55:05 <maerwald> metl: doesn't matter, it has its own instances
04:55:16 <ski> bollu : so, it's *not* the discrete topology ! :)
04:55:28 <bollu> ski: right. I'm trying to think of a solution
04:55:41 * ski nods
04:56:00 <metl> maerwald: is there a way to convert without loss of information though? i'm not looking to round to the nearest Integer, i want to get an Integer from the raw bits
04:56:07 <bollu> we are given a morphism from U Top -> Set. We need to come up with a morphism Set -> Top such that any function in Set is continuous in Top, correct?
04:56:16 <ski> > realToFrac (2/5 :: Rational) :: Double
04:56:17 <lambdabot>  0.4
04:56:38 <ski> metl : can't you use `realToFrac' to convert to `Double' or `Rational' or whatever you like ?
04:56:55 <maerwald> yes, it has a Real instance too, so realToFrac works
04:56:58 <ski> metl : or also use `round'/`floor'/`ceiling'/`truncate', if you want to get to `Integer'
04:57:08 <bollu> ski: I have to go, I have my exams to study for :( Could you give me the answer so I can think about it and get back on IRC in a few hours with questions?
04:57:12 <ski> metl : but you'll lose precision
04:57:35 <ski> bollu : it's the indiscrete topology, where only the empty and the full subsets are open. topologially, all points in the space are indistinguishable
04:57:38 * ski . o O ( apropos, "The universe is indiscrete" by Martín Hötzel Escardó,Thomas Streicher in 2013-11-16. earlier draft version of "The intrinsic topology of Martin-Löf universes" by ibid in 2016-02-12 at <http://www.cs.bham.ac.uk/~mhe/papers/universe-indiscrete.pdf> )
04:57:41 <bollu> ski: hmmm
04:58:12 <ski> bollu : next question here would have been, what is the left adjoint of the left adjoint of the underlying functor `U : Top >---> Set' ?
04:58:25 <bollu> ski: what are the continuous functions on the indescrete topology?
04:58:27 <ski> bollu : or, if you prefer, consider the underlying functor `U : Graph >---> Set'
04:58:40 <bollu> what's Graph?
04:58:53 <ski> the category of graphs and graph homomorphisms
04:59:08 <bollu> hm
04:59:17 <bollu> I'll be back :) gotta go. I'll think about this, thanks!
04:59:31 <ski> take e.g. loopless simple undirected graphs. so no multiple edges between two nodes. and no directed edges. and no self-loops
04:59:40 <ski> (though i think it doesn't really matter much)
04:59:57 <ski> @tell bollu take e.g. loopless simple undirected graphs. so no multiple edges between two nodes. and no directed edges. and no self-loops  .. (though i think it doesn't really matter much)
04:59:57 <lambdabot> Consider it noted.
05:03:03 <ski> metl : it's not clear what you want, if you want an `Integer', but don't want to lose information
05:03:21 <ski> metl : do you just want to serialize it into a bitpattern ?
05:03:31 <freinn> hi! I'm trying to implement the function sum for the foldable typeclass, I think I have the idea, but the compiler does not agree. http://lpaste.net/162558
05:03:53 <metl> ski: i was looking at Data.Bits just now to see if i could convert to bits as an intermediate form and then go to Integer
05:04:14 <jhrcek> Is this site working for anyone? S Diehl's "What I wish I knew when learning haskell"? http://dev.stephendiehl.com/hask/
05:04:37 <lyxia> it is
05:04:38 <ski> metl : because if you have a fixed value `2.001 :: Milli Integer', converting in the natural way to an `Integer' will lose information
05:04:55 <ski> metl : unless you separate the fractional part out from the integral part, i suppose
05:05:24 <hpc> :t \x -> x `quotrem` 1
05:05:25 <lambdabot>     Not in scope: ‘quotrem’
05:05:26 <lambdabot>     Perhaps you meant one of these:
05:05:26 <lambdabot>       ‘quotRem’ (imported from Prelude),
05:05:30 <hpc> :t \x -> x `quotRem` 1
05:05:31 <lambdabot> Integral a => a -> (a, a)
05:05:44 <hpc> > 5.265 `quotRem` 1
05:05:46 <lambdabot>      No instance for (Show a0)
05:05:46 <lambdabot>        arising from a use of ‘show_M515014646793615231317279’
05:05:46 <lambdabot>      The type variable ‘a0’ is ambiguous
05:05:58 <hpc> oh wait, derp
05:06:00 <ski> @type properFraction
05:06:01 <lambdabot> (Integral b, RealFrac a) => a -> (b, a)
05:06:05 <hpc> that was it
05:06:05 <ski> metl : you could try that ^
05:06:35 <ski> > properFraction 2.001
05:06:36 <lambdabot>  (2,9.999999999998899e-4)
05:06:55 <ski> > properFraction (2.001 :: Milli)
05:06:57 <lambdabot>  (2,0.001)
05:08:42 * hackagebot FractalArt 0.2.0.1 - Generates colorful wallpapers  https://hackage.haskell.org/package/FractalArt-0.2.0.1 (TomSmeets)
05:10:24 <ski> jhrcek : <http://www.downforeveryoneorjustme.com/http://dev.stephendiehl.com/hask>
05:11:30 <ski> freinn : you should also use `getSum'
05:11:48 <jhrcek> ski: it's up for me, but not displaying any text. I see error in browser console: Failed to parse SourceMap: http://dev.stephendiehl.com/hask/css/bootstrap.min.css.map
05:12:20 <ski> jhrcek : hm, ok. works for me in W3m here
05:13:51 <metl> ski: ah :) that almost works but it gives me a POSIXTime in the right: properfraction x :: Integral b => (b,POSIXTime)
05:14:57 <metl> *properFraction
05:15:19 <ski> metl : well that `POSIXTime' expresses the fractional part that the `Integer' conversion would otherwise lose
05:15:26 <gio111> ski: hi
05:15:41 <metl> ski: oh this might work: properFraction $ realToFrac x
05:16:05 <gio111> ski: could you please see pm
05:16:06 <metl> :: (RealFrac a, Integral b) => (b,a)
05:16:09 <ski> metl : then you could get the fractional part as a `Rational', or `Double', or something
05:16:18 <ski> gio111 : mhm
05:43:43 * hackagebot FractalArt 0.2.0.2 - Generates colorful wallpapers  https://hackage.haskell.org/package/FractalArt-0.2.0.2 (TomSmeets)
05:43:45 * hackagebot aeson-json-ast 0.1 - Integration layer for "json-ast" and "aeson"  https://hackage.haskell.org/package/aeson-json-ast-0.1 (NikitaVolkov)
05:57:05 <ozgura> does this give an sql error to anyone else: https://ghc.haskell.org/trac/ghc/report/21?max=100&Q=Code+coverage&sfp_email=&sfph_mail=
05:59:09 <ClaudiusMaximus> ozgura: yes errors here
05:59:17 <ozgura> ClaudiusMaximus: thanks
05:59:23 <ozgura> I assume it will to everyone
05:59:49 <ozgura> trac is so bad :(
06:01:26 <ozgura> can anyone tell me how I can run a full text search in the ghc trac?
06:03:44 * hackagebot json-ast-json-encoder 0.1 - Encoders of JSON AST  https://hackage.haskell.org/package/json-ast-json-encoder-0.1 (NikitaVolkov)
06:05:27 <ClaudiusMaximus> ozgura: https://ghc.haskell.org/trac/ghc/report/21?Q=banana
06:06:17 <ozgura> oh it seems to be the space that upsets it
06:06:35 <gio111> ski
06:07:02 <ozgura> also banana comes up surprisingly often, I guess due to banana brackets. amusing :)
06:10:00 <mpickering> If I have a bunch of monadic actions M (Maybe a) then what is an idiomatic way to run each in turn until one of them is a Just?
06:10:45 <mpickering> I guess I want a function Ma -> [M (Maybe a)] -> M a
06:10:56 <lyxia> use asum on MaybeT?
06:17:48 <mpickering> good suggestion thanks
06:18:09 <mpickering> I didn't think I could use it but turns out transformers is available 
06:19:42 <freinn> thanks ski
06:31:22 <pothepanda> uhm.. since when this is acceptable haskell syntax:  foldl (λacc x: Nat#. rem (x * acc) n) 1 (enumFromTo 1 (n - 1)) ?
06:32:44 <hiptobecubic> since everyone lost their minds over unicode bling and it got its own language extension or something
06:33:07 <hpc> very very few people use it
06:33:12 <pothepanda> there several things i never used, like the λ which makes sense tho
06:33:36 <ARM9> unnecessary parsing complexity woo
06:33:39 <hiptobecubic> I hate it.
06:33:45 * hackagebot postgresql-typed 0.4.4 - A PostgreSQL access library with compile-time SQL type inference  https://hackage.haskell.org/package/postgresql-typed-0.4.4 (DylanSimon)
06:33:47 <pothepanda> but it looks cool right ? :D
06:33:49 <hiptobecubic> No
06:33:56 <hiptobecubic> It looks hard to read in many fonts
06:34:37 <pothepanda> what λacc x: something looks better than \_ x -> something, no ? i got greek chars with alt-shift its pretty easy for me to change tho
06:34:38 <hiptobecubic> I don't want to pick a font based on what unicode :: or -> looks like so that I can read source code for the 1% of haskell packages using unicode symbols
06:34:54 <pothepanda> right right :/
06:35:28 <hpc> there's fonts that make ligatures for the most common haskell symbols though
06:36:03 <hiptobecubic> right, use one of those if you care about "beautiful" characters :)
06:36:07 <hpc> you don't get to write \ and see λ, but you can see (/=) be a wide (=) with a line
06:36:26 <hpc> and as a plus nobody else even needs to know
06:36:38 <hiptobecubic> That's a very big plus.
06:36:50 <pothepanda> wasnt it that haskell IDE was doing that already
06:37:08 <hiptobecubic> AND it will work even on other people's source code. People who still use \ and ::
06:37:19 <pothepanda> yea yea, i think thats best right
06:39:31 <hpc> the original reason behind the unicode extension iirc was languages like agda which natively use unicode everywhere
06:39:42 <hpc> but those languages come with IDEs
06:40:14 <hpc> (agda ships with an emacs plugin for unicode input and a bunch of integrated typechecking tools)
06:40:35 <geekosaur> actually I wasn't aware of any extension that allows lambda there, because it's a Unicode letter and therefore a Haskell identifier character
06:41:18 <hpc> the extension changes the parser
06:41:21 <hpc> it's like MagicHash
06:42:23 <ARM9> well unicode is supported by default so
06:42:31 <ARM9> http://ideone.com/4mZ3Go
06:42:46 <geekosaur> -XUnicodeSyntax specifically avoided lambda though
06:42:53 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#unicode-syntax
06:44:14 <hpc> ah
06:51:34 <jophish> pothepanda: be aware that if it changes the width of certain characters things may not line up as nicely
06:54:58 <pothepanda> jophish: indeed :)
06:58:45 * hackagebot htoml 0.2.0.1 - Parser for TOML files  https://hackage.haskell.org/package/htoml-0.2.0.1 (cies)
06:58:47 * hackagebot FractalArt 0.2.0.3 - Generates colorful wallpapers  https://hackage.haskell.org/package/FractalArt-0.2.0.3 (TomSmeets)
07:03:45 * hackagebot tagsoup 0.13.10 - Parsing and extracting information from (possibly malformed) HTML/XML documents  https://hackage.haskell.org/package/tagsoup-0.13.10 (NeilMitchell)
07:13:37 <maerwald> is there a framework that abstract over all available databases?
07:15:57 <hpc> i assume you mean all sql databases?
07:16:22 <hpc> in any event, there isn't
07:16:35 <hpc> there's probably several that try, but i have never bothered with them
07:16:58 <hpc> the databases themselves have enough individual differences (some of which are quite severe) to make it not really feasable
07:17:27 <hpc> for instance sqlite isn't acid, and it has an extremely weak type system
07:18:03 <hpc> some databases support joins in different ways, certain methods of querying can or can't be nested, etc
07:18:26 <Clint> that's why persistent is pretty lcd
07:19:19 <hpc> it's a tough situation for people like me who are very good at those quirkier parts of sql and enjoy the expressiveness you gain from it
07:20:13 * hpc has resigned himself to being primarily mysql because it's what everyone seems to have even though it's crap
07:20:59 <hpc> any common framework is ultimately going to just look like getters and setters, which even java programmers don't like
07:22:33 <surganov> just found out that most `Writer` and `State` monad tutorials are out of date
07:22:57 <surganov> can someone recommend what to read on `Writer` and `State` monad?
07:23:25 <hpc> the only difference is instead of using State to construct actions, use state
07:23:26 <hpc> :t state
07:23:27 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
07:24:18 <hpc> and yeah, they are veeeery out of date
07:24:26 <nitrix> I think StateT is still an option?
07:24:32 <hpc> :t StateT
07:24:33 <lambdabot> (s -> m (a, s)) -> StateT s m a
07:24:39 <surganov> but underlying StateT requring knowledge of monad transformers
07:24:52 <hpc> you need to make slightly more changes to use StateT
07:25:35 <zaquest> why are they out of date? was state monad different?
07:25:50 <hpc> there used to not be mtl / transformers
07:25:58 <zaquest> i didnt notice it when i was learning about it
07:26:14 <nitrix> zaquest: Haskell is as much of a standard as it is the compilers that implements the language as it is the community packages and extensions. It evolves :)
07:26:17 <hpc> so it was just data State s a = State {runState :: s -> (a, s)}
07:26:29 * hpc still doesn't know why the hell that tuple is reversed, but whatever
07:26:46 <hpc> now is's type State s a = StateT s Identity a
07:26:56 <nitrix> hpc: I think it's to use the tuple as a functor?
07:27:18 <hpc> that's terrible if true
07:27:39 <hpc> because it means you have a much more awkward definition to use (State s) as a functor
07:27:53 <hpc> also it just looks ridiculous when you go to use runState
07:28:00 <surganov> the most recent tutorial that I could find was `haskellbook`
07:28:15 <hpc> RWH might be up to date
07:28:23 <nitrix> surganov: Calling it a tutorial seems a little offending.
07:30:13 <surganov> sorry for `tutorial`
07:31:00 <surganov> RWH still relies on mtl 1.*
07:31:03 <zaquest> why differentiate two. the one w/o the transformer is easier to explain and they are interchangeable otherwise, no? differentiating them seems to me like "looking under the hood", breaking the abstraction
07:31:36 <zaquest> i mean in the context of tutorials at least
07:31:51 <nitrix> zaquest: It requires understanding transformers and the Identity monad.
07:32:27 <hpc> well, the Monad instance for the Identity type
07:32:57 <hpc> and knowing that it represents the end of the chain
07:33:17 <surganov> isn't that confusing that State is basically StateT with Identity but that's not the case for Maybe and MaybeT?
07:33:31 <hpc> (and then later, knowing that another valid end to the chain is IO, or any other type with a Monad instance)
07:33:39 <nitrix> hpc: Are you really that annoyed when people say Identity monad, versus Monad instance for Identity?
07:33:46 * hackagebot d3d11binding 0.0.0.6 - A raw binding for the directX 11  https://hackage.haskell.org/package/d3d11binding-0.0.0.6 (jwvg0425)
07:34:16 <hpc> nitrix: not usually, but there was a long discussion about it yesterday and i am just noticing it more ;)
07:34:24 <nitrix> hpc: It's just regular speech; it's heavy otherwise.
07:35:21 <hpc> it's dangerous to people unfamiliar with the shorthand, thinking that the fact that a type is an instance of Monad makes it special
07:36:30 <nitrix> hpc: Think of the list functor, suddently the pedantry doesn't seem as important anymore.
07:37:13 <hpc> C-like languages have a very different idea of what a functor is, so that could still be confusing ;)
07:38:01 <zaquest> doesnt Monad instance makes a type special. i mean it's a Monad now, not everything is a Monad. special enough for me :D
07:38:15 <arahael> hpc: then again, c-like languages have a very different idea of what a *function* is.
07:38:26 <hpc> lol yes
07:39:05 <nitrix> When I say `monad`, I mean it as an adjective. Like, a white dog, a brown dog, a blue dog, it's just adding more clarity about that dog.
07:39:26 <nitrix> It's not that dogs are all red or something.
07:39:41 <hpc> let me put it this way
07:39:59 <nitrix> I totally know what you mean, I've seen the argument many times and participated to a lot of them.
07:40:11 <hpc> when catholic missionaries went to japan, they brought some dietary traditions with them
07:40:33 <hpc> they made oddly prepared food once and japanese people go "what's that?"
07:40:59 <surganov> can someone explane the purpose of wrapping 3 monads at once? https://github.com/byorgey/MonadRandom/blob/master/Control/Monad/Random.hs#L75
07:41:00 <hpc> they say it's their holy time of whatever, which when translated includes "tempura"
07:41:14 <hpc> they thought that referred to the method of preparation and there you go
07:41:30 <surganov> RandT → StateT → m in `newtype RandT g m a = RandT (StateT g m a)`
07:41:43 <nitrix> hpc: Get to the point.
07:41:58 <nitrix> hpc: People might get confused that IO is a monad? It _is_ a monad.
07:42:04 <hpc> IO is a type
07:42:10 <hpc> it is an INSTANCE of Monad
07:42:19 <byorgey> surganov: it is defining a new monad transformer called RandT, which can be applied to an existing monad m
07:42:34 <hpc> (arguably IO is a type constructor or a type function or whatever, but point is there's no is-a relationship for type classes)
07:42:40 <byorgey> but RandT is defined in terms of another monad transformer, StateT
07:42:56 <nitrix> hpc: Put a pause on your pedantry and think about it two seconds and try to see what possible harm could come out of it.
07:43:01 <nitrix> hpc: There's absolutly none.
07:43:06 <byorgey> I don't think "wrapping 3 monads at once" is a useful way to think about it
07:43:07 <hpc> you need to speak correctly about relationships between things when speaking to someone who isn't already familiar, or they will take it seriously and learn it wrong
07:43:43 <surganov> so RandT is kinda synonymous for StateT with identity monad by default?
07:43:52 <nitrix> hpc: For a beginners, without understanding monads yet, they're just going to compartise things that "are monads" mentally, then understanding that to be a monad, you need to implement a type instance. These things come later.
07:44:11 <byorgey> surganov: RandT is pretty much synonymous with StateT, yes
07:44:23 <byorgey> surganov: and if you use Rand then it instantiates m with Identity by default
07:45:27 <hpc> nitrix: and that's an incorrect understanding
07:45:47 <hpc> nitrix: when teaching it's obviously necessary to teach some things later than others, and allow for incomplete understanding
07:46:08 <hpc> nitrix: but teaching in a way that leaves an incorrect understanding in the middle is bad teaching
07:46:18 <TheMystic> hpc: I was under the impression that, in the mathematical sense, a type that implements a typeclass like Monad "is a Monad." I think you just have to disabuse people of the notion that that "is a" means the same thing as in OOP.
07:46:46 <TheMystic> If it walks like a duck and quacks like a duck, it "is a" duck.
07:47:27 <zaquest> hpc, now i dont understand it :D how is something that is an instance of Monad is not a Monad. can we use `a` that has `instance Monad a` anywhere where `Monad a` is required? yes, then why is it not a monad?
07:47:40 <hpc> TheMystic: in the mathematical sense, (m, return, join) is a monad
07:47:46 <hpc> the type is just a type
07:49:18 <hpc> zaquest: class instances can get much more complicated to the point that you hardly even have a thing to "is a" at all
07:49:41 <surganov> byorgey: can you recommend some up-to-date learning materials about State monad? even `Typeclassopedia` still relies on mtl 1.* (newtype wrappers instead ot transformers)
07:50:34 <hpc> zaquest: http://hackage.haskell.org/package/JuicyPixels-3.2.7/docs/Codec-Picture-Types.html#t:ColorConvertible
07:50:46 <surganov> byorgey: and want to thank you for your CIS194’13, very enlightening
07:51:25 <hpc> zaquest: one can imagine in this scenario, pixel values of complex numbers
07:51:32 <mfukar> wait, do "Identity is a Functor", and "Identity is an instance of Functor" mean different things?
07:52:14 <hpc> zaquest: you wouldn't terribly easily be able to convert between a complex pixel image and one of the more integer-y pixel images
07:52:17 <nshepperd_> yeah, that sounds like incredibly useless hair splitting
07:52:33 <hpc> zaquest: so now you have two different groups of pixel types that you can't really convert between
07:53:05 <hpc> zaquest: so when you say a pixel type "is a" ColorConvertible, you need to specify what types it can convert from/to
07:53:15 <hpc> zaquest: which is multiple instances
07:53:36 <zaquest> hpc, so you cant use a pair of type (a,b) as ColorConvertible if a is complex and b is integer
07:54:05 <hpc> actually i didn't even need to make that complicated an example
07:54:25 <nshepperd_> no one ever uses "is a" for multi param typeclasses like that though so that's fine
07:54:38 <zaquest> pair of types* sorry im not sure im expressing myself correctly, not very good at english
07:54:54 <hpc> nshepperd_: sure, but then you have to break the "is a" misconception in order to teach MPTC
07:55:25 <hpc> nshepperd_: you've given them a mental model that doesn't admit it
07:56:30 <zaquest> hpc, i still dont understand why. why break "is a" misconception? it's the same thing, it just requires two types, so instead of saying a is a monad, you say a,b are color convertible.
07:57:42 <hpc> zaquest: perhaps if it was instance ColorConvertible (a, b)
07:57:53 <nshepperd_> i dunno, that doesn't sound like a huge problem to me
07:58:55 <hpc> i have a similar argument for GADTs, which are the most obvious thing in the world if you start with "data Foo where" instead of "data Foo = "
07:58:58 <zaquest> hpc, it seems the same to me :D if you have ColorConvertible (a,b) you can get ColorConvertible a b and vice versa, no?
07:59:20 <hpc> no, because ColorConvertible :: * -> * -> Constraint, not * -> Constraint
07:59:44 <nshepperd_> (*, *) -> Constraint
08:00:25 <zaquest> hpc, no, i mean if you call it different maybe. im not sure if its possible to do it in haskell, but arent they the same thing?
08:00:50 <zaquest> hpc, one packed in tuple and another unpacked
08:01:49 <nshepperd_> (type family Uncurry f  (a, b) = f a b)
08:02:53 <nshepperd_> anyway, the point of "list is a functor" and such phrases is that there is really one really obvious way of mapping over it
08:03:47 * hackagebot stack-run-auto 0.1.1.1 - Initial project template from stack  https://hackage.haskell.org/package/stack-run-auto-0.1.1.1 (yamadapc)
08:04:13 <nshepperd_> I'm not sure I would use is-a for the less obvious type classes like Printf
08:05:36 <nshepperd_> but for functors and monads, sure, because there's usually exactly one reasonable definition
08:05:42 <zaquest> it's probably because it leads to weird language :D like `a is a printf`, but if it was called differently `Printfable` for example then why not :D
08:06:19 <quicksilver> APossiblePrintFReturnType
08:07:00 <zaquest> oh, right, i dont really know what Printf does :D
08:14:54 <ARM9> lots of ugly type nesting to simulate a variadic function with no useful static type checking
08:20:19 <geekosaur> actually it's PrintfType
08:20:23 <geekosaur> not Printf
08:23:48 * hackagebot pgdl 9.0 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-9.0 (sifmelcara)
09:04:14 <nemeci> where are u twelve?
09:08:49 * hackagebot enumerate 0.1.1 - enumerate all the values in a finite type (automatically)  https://hackage.haskell.org/package/enumerate-0.1.1 (sboo)
09:37:39 <surganov> how to install lambdabot on OSX with latest ghc/stack?
09:41:28 <Jinxit> surganov: cry
09:41:30 <Jinxit> cry a lot
09:41:50 <geekosaur> lambdabot is difficult to install at the best of times
09:41:52 <NeedHelpHarry> i cry
09:41:57 <NeedHelpHarry> ever tim
10:29:56 <icicled> does anyone have experience with using postgresql composite types with the postgresql-simple library?
10:33:52 * hackagebot avers-api 0.0.5 - Types describing the core and extended Avers APIs  https://hackage.haskell.org/package/avers-api-0.0.5 (wereHamster)
10:35:39 <icicled> I'm trying to use a composite type with postgresql-simple and I get some type validation errors
10:35:46 <icicled> minimal example: http://lpaste.net/5757999685784567808
10:37:52 <icicled> run-time type errors
10:38:59 <CYbErCodE> hi
10:39:25 <CYbErCodE> whats the best IDE for Haskell programming?
10:40:44 <suppi> CYbErCodE, I think emacs and atom works best, perhaps also vim and sublime text
10:41:22 <CYbErCodE> Thanks suppi
10:41:48 <CYbErCodE> how about Leksah?
10:42:10 <ARM9> if you don't have a favourite then try leksah
10:42:28 <ARM9> most people already use emacs/vim/atom/subslime/etc. so they use some plugin for that
10:42:38 <suppi> CYbErCodE, I haven't used it. try it if you are interested :)
10:42:54 <CYbErCodE> okay thanks guys
10:43:45 <ARM9> unless you're already an emacs user I wouldn't recommend it, haskell-mode just doesn't want to work
10:43:52 <ARM9> unless there's a better solution now
10:44:51 <monochrom> emacs haskell-mode works for me. but it is not an IDE.
10:46:26 <hpc> i use screen with multiple tabs, and put ghci on one of them
10:47:07 <hpc> switching between them is just ^A^A and it doesn't require even editing any dot-files
10:47:45 <suppi> i work with haskell mode and it's mostly good for me
11:28:54 * hackagebot fast-tagsoup 1.0.12 - Fast parser for tagsoup package  https://hackage.haskell.org/package/fast-tagsoup-1.0.12 (VladimirShabanov)
12:07:08 <aweinstock> is there a way to ask hackage about reverse-dependencies
12:08:38 <geekosaur> not hackage
12:08:58 <bergmark> aweinstock: http://packdeps.haskellers.com/reverse/aeson
12:09:11 <geekosaur> yeh, was trying to pull that url out of my history 
12:09:18 <geekosaur> wekll, minus the aeson :p
12:09:54 <aweinstock> bergmark: thanks
12:10:49 <aweinstock> sadly, category-printf wasn't on there
12:12:16 <bergmark> that's strange
12:12:22 <unluckyone_> bergmark am working aki Spain lifting and doing nothing
12:13:37 <bergmark> error: no parse
12:13:49 <sm> I keep thinking I can nest where clauses and having GHC bark at me.. am I dreaming ?
12:14:22 <bergmark> you might be dreaming about ghc barking? it's possible to nest them
12:14:54 <sm> yes it is, darnit. I'll study that error next time. Thx
12:15:03 <geekosaur> where is declaration syntax. nested declarations work
12:15:24 <geekosaur> but people keep trying to apply where to expressions instead of declarations
12:19:22 <sm> expressions /= declarations, I'll check that next time
12:28:56 * hackagebot avers-server 0.0.4 - Server implementation of the Avers API  https://hackage.haskell.org/package/avers-server-0.0.4 (wereHamster)
13:03:31 <nitrix> Can someone confirm lambdabot disables monomorphic restriction?
13:03:47 <nitrix> Learned about MR recently, I'm a little surprised.
13:04:21 <volhovm> Hello guys! I'm using ACID as database mostly, but my current task implies I should store about 20-30 GB of data (some set (hash/tree) + another tree). What is the right way to do it? Will using ACID be efficient?
13:05:40 <volhovm> Also I suppose using i should use mutable sets from `hashtables` package...
13:05:49 <volhovm> s/using//
13:14:04 <kritzcreek> I'm running into something like a deadlock that only occurs on windows... Is there a case where STM doesn't protect you from deadlocks?
13:14:45 <nitrix> kritzcreek: Afaik, the runtime will kill deadlocked threads.
13:17:25 <kritzcreek> nitrix: hmm I'm not seeing anything like that
13:17:45 <fatex> does ghc 7.10.x still call gcc as part of the compilation process?
13:17:50 <fatex> I thought this was all llvm by now
13:18:09 <nitrix> fatex: With or without FFI code?
13:18:22 <fatex> nitrix: good question
13:18:27 <fatex> what should I grep for in the package?
13:18:50 <nitrix> fatex: Without FFI, GHC has its own backend to generate target machine code.
13:18:59 <fatex> grep -i "ffi" **/*.hs shows up nothing in zsh
13:19:34 <nitrix> fatex: Search for Foreign.C maybe?
13:19:37 <fatex>   31380  0.0  0.0   8148   328 ?        R    13:18   0:00 /nix/store/ikzdbd65z7453spdvm05r0izd56zdvkx-gcc-4.9.3/bin/gcc -fno-stack-protector -DTABLES_NEXT_TO_CODE -c -o dist/build/Pdf/Content/GlyphList_o_split/GlyphList__13289.o /tmp/nix-build-pdf-toolbox-content-0.1.0.drv-0/ghc31652_0/ghc_41.split__13289.s -B/nix/store/pv9sza1cf2kpawck7wbwdnhlip5h57lg-glibc-2.23/lib/ -idirafter /nix/store/pv9sza1cf2kpawck7wbwdnhlip5h57lg-glibc-2.23/in
13:19:37 <geekosaur> fatex, "foreign" would be a better thing to look for
13:19:59 <fatex> that baffles me ; I'm trying to figure out why Pdf.Content (from pdf-toolbox on hackage) is calling gcc and stalling my machine
13:20:15 <fatex> grep -i "foreign" **/*.hs brings up nothing
13:21:46 <geekosaur> oh
13:21:49 <fatex> is there any reason why building this file: https://gist.github.com/182233c319722a9fd80e698f2b5ed277
13:21:53 <fatex> would involve calling gcc and stalling forever?
13:21:57 <fatex> it took somethin glike 5 mins to compile that one file
13:22:08 <geekosaur> output is assembly language? then it uses gcc to invoke the assembler?
13:22:25 <fatex> ah; I'm an idiot; that's the .s ?
13:22:29 <geekosaur> yes
13:22:35 <geekosaur> that's the input file
13:23:03 <geekosaur> ohhhh dear
13:23:04 <nitrix> It seems to use io-streams, which uses the CPP extension.
13:23:07 <geekosaur> this is a known thing
13:24:00 <geekosaur> it's got a ~5000 line list constant
13:24:25 <fatex> yeah, shouldn't suhc code be easy to compile?
13:24:27 <geekosaur> this is known to be handled badly by current ghc
13:24:30 <fatex> no optimization  required ... just list it out
13:24:53 <geekosaur> well, as you saw the real problem is the generated code chokes the assembler
13:26:04 <geekosaur> 5000 line (10000 element) list, and 5000 of those elements are String which is another list.
13:26:23 <fatex> I see
13:26:26 <geekosaur> (and for those wondering, no, switching to Text won't help)
13:26:32 <fatex> thanks for digging into the mechanics of this and explaining it
13:26:39 <geekosaur> basically it's a known screw case
13:26:57 <fatex> the assembler's been around for decades, and no one's bothered to fix it? :-)
13:27:10 <geekosaur> its not the assembler /per se/. it
13:27:29 <geekosaur> 's that the generated assembly code we're feeding it is less than optimal
13:28:42 <geekosaur> I have not looked but given how Haskell lists work I can imagine it's been fed a bunch of data values containing pointers to each other.
13:29:01 <geekosaur> beyond that I suspect you'd have to ask the folks in #ghc
13:29:07 <fatex> lol
13:29:11 <fatex> so the Strings are [Char]'s
13:29:17 <fatex> and we have lots and lots of long-ish Strings
13:29:23 <fatex> okay, I can imagine that not being nice
13:29:27 <geekosaur> (actually I think thius has been assumed to be a problem inside ghc, and here it looks like it's a problem with the generated asm; that might be news to the ghc devs)
13:29:40 <geekosaur> enh, these are short as String goes
13:29:55 <geekosaur> they're not even long enough to balance the overhead of Text
13:30:28 <geekosaur> (not that Text would helpp because it'd still generate the String-s and then insert a T.pack call)
13:30:54 <geekosaur> (because Text is not a "built-in" type)
13:36:14 <dolio> Strings being [Char] isn't the problem, because string literals don't get compiled to list stuff.
13:36:34 <dolio> But that still means Text isn't going to help.
13:37:54 <nmdanny> how would I make a function that converts a matrix, represented as a list of lists, to a matrix, represented as a map of positions to values?
13:37:59 <nmdanny> something with a signature like: [[a]] -> Map (Int,Int) a
13:38:05 <dolio> If you look at the core of code involving string literals, you'll see stuff like: GHC.CString.unpackCString# "hello"#
13:39:13 <dolio> So if the assembler is choking, it's choking on the emitted C style strings.
13:40:50 <dolio> Which looks like this: http://lpaste.net/2079104109335543808
13:41:18 <ARM9> > .align 1
13:41:19 <lambdabot>  <hint>:1:1: parse error on input ‘.’
14:12:55 <EvanR> hey... you got your idris in my erlang http://lenary.co.uk/publications/dissertation/Elliott_BSc_Dissertation_Poster.pdf
14:19:52 <lyxia> nmdanny: \matrix -> Map.fromList $ do { (i, row) <- zip [0 ..] matrix ; (j, a) <- zip [0 ..] row ; return ((i, j), a) }
14:23:36 <koz_> What is the difference between mtl and transformers, and which should I use?
14:24:19 <Clint> koz_: mtl is a layer on top of transformers
14:24:45 <Cale> koz_: transformers implements the monad transformers themselves. mtl adds the type classes like MonadState and such.
14:25:52 <Cale> Well, MonadTrans and MonadIO are in transformers, but those are of quite a different flavour
14:28:28 <koz_> Cale: So if I need a State monad, but don't need to transform it, should I use transformers then?
14:29:25 <Cale> yeah
14:29:46 <koz_> Cale: Thanks - now I know which one I need.
14:31:04 <EvanR> from the sdl channel "i remember when unity apps were borked for a minute when apple moved the fonts" ... this sort of failure seems pretty bad, and i cant think of how i would engineer a program to deal with it
14:31:14 <EvanR> what type system prevents this ;)
14:33:32 <monochrom> koz_: even if you need to transform, e.g., StateT Bool (ReaderT () IO) Char. If you do that concretely, transformers is sufficient, but of course mtl re-exports that; if you want the generalized (MonadState xxx, MonadReader xxx, MonadIO xxx) thing, that's when mtl is a must.
14:34:38 <monochrom> I think you can simply go with mtl because it's a union of both, you won't miss anything. Unless you want to avoid the type classes.
14:35:12 <monochrom> But there is a strong reason to embrace the type classes.
14:35:49 <Zekka|Sigfig> The typeclasses don’t behave well in combination with homemade transformer types though
14:36:13 <Zekka|Sigfig> imho monad transformers are already not pretty, mtl is *really* not pretty
14:36:41 <koz_> monochrom and Zekka|Sigfig: I'm just trying to use State, mainly.
14:36:43 <Philippa> mtl's a case of reaching the limits of what Haskell had stably been able to do, yeah
14:37:05 <Philippa> I suspect we can do better once we're comfortable that the basic of dependent haskell are stable, but we'll see
14:37:31 <Zekka|Sigfig> I think there’s a philosophical problem with the idea of extensible effects, at least given how powerful monads are
14:37:37 <monochrom> Just yesterday a fellow asked: "I have StateT S IO A overall, but it is 1 line of IO and 20 lines of StateT sans IO, and I have already separated out those 20 lines into its own definition, let's call it foo. How do I express in type that foo does not use IO?"
14:38:02 <Zekka|Sigfig> suppose I say “I have a program that wants to use continuations, keep state, and do backtracking”
14:38:10 <Zekka|Sigfig> that’s probably some combination of [], ContT, and StateT
14:38:29 <monochrom> and the answer is "foo :: MonadState m S => m A".
14:38:35 <Zekka|Sigfig> But there are a lot of different ways to get the combination of those behaviors — does backtracking reset the state? Do continuations reset backtracking?
14:39:01 <Zekka|Sigfig> monochrom: The other way is StateT s IO a vs StateT s m a
14:39:03 <koz_> Well, I think I'll just dive into the deep end and use mtl then.
14:39:21 <Zekka|Sigfig> Philippa: IMHO there’s a lot of missing information when you say “I want to combine these effect types"
14:39:31 <monochrom> oops, yeah, that works too, probably better. nevermind.
14:39:34 <Zekka|Sigfig> maybe if we used something less powerful than monads and monad transformers there would be less missing information
14:39:56 <Zekka|Sigfig> monochrom: Yours works better if you want to say “also if you have even more things beyond just StateT, I still work,” of course
14:40:10 <EvanR> callcc ruins the show
14:40:22 <Cale> Yet another option is to ditch the monad transformer altogether, and instead pass around a record of operations abstracted over the monad, like:
14:40:26 <EvanR> (this includes exceptions)
14:40:29 <Philippa> Zekka|Sigfig: much of the missing information - or rather, the /mandatory/ information, is in the sequencing
14:40:35 <Cale> data StateOps m = SO { get :: m s, put :: s -> m () }
14:40:53 <Zekka|Sigfig> Philippa: Yeah, I think order is important —I don’t know what else is important
14:40:58 <Philippa> pretty much every alternative we have is an attempt to either weaken the programs you can write or the set of effects available to us in exchange for that
14:41:25 <Philippa> if the individual effects are well-specified? Order and what they are/were is everything, the rest is arguing about how to name which bits of the stack you're trying to use
14:41:25 <Zekka|Sigfig> I’ve seen some approaches that try to get rid of the sequence and say “look, we have a set of effects"
14:41:27 <Cale> and then if you have something of type  forall m. (Monad m) => StateOps m -> ... -> m Result
14:41:34 <Zekka|Sigfig> I haven’t determine what they do in cases like what I described
14:41:41 <Cale> then you know that it doesn't do anything except use the operations that you gave it
14:42:10 <Philippa> if you only have a set of effects you either have programs that can't specify necessary effect-interactions, or you have classes of effects that aren't permitted
14:42:13 <Philippa> pretty much that simple
14:42:21 <Cale> We can abstract over that picture, and implement a monad which is a glorified reader monad for carrying around records of operations:
14:42:23 <Zekka|Sigfig> Cale: FWIW I have been doing something along these lines in my last program — it takes a little extra code to go to the trouble of doing that, but it didn’t turn out badly
14:42:53 <Cale> newtype FreeVL ops a = FVL { runFreeVL :: forall m. (Monad m) => ops m -> m a }
14:43:09 <Cale> (the Monad instance is easy)
14:43:31 <Philippa> something /closely related/ to the monad transformer (though for reasons of "what happens when I pass stuff into control operators?", not quite the monad transformer itself) is pretty much fundamental for the same reason the internal language of monads is something that also crops up as a compiler IR
14:43:36 <Zekka|Sigfig> I haven’t *yet* seen the need to recordize or readerize my monad ops, but I think transformers have not been necessary — I’m basically dealing with a free monad where I inlined teh Free parts
14:44:06 <Cale> Yeah, you can also just pass the operations in as separate polymorphic arguments
14:44:26 <Cale> (Monad m) => m s -> (s -> m ()) -> m r
14:44:37 <EvanR> Cale: does this method cover things like callcc
14:44:47 <Cale> it should, yes
14:45:17 <markan__> Quick question: how can I get every nth element in a list?
14:45:25 <EvanR> so internally you need to implement a monad that can support all these operations anyway
14:45:41 <EvanR> perhaps with transformers
14:45:43 <Cale> EvanR: yes, but sometimes that monad is just IO
14:46:05 <Cale> You're free to implement the state ops with just an IORef if you feel like it
14:46:13 <Zekka|Sigfig> EvanR: I lately try to avoid implementing stuff with transformers because I think transformers are confusing
14:46:13 <EvanR> yes it seems like your method is good for restricting IO rather than building up a working monad from more primitive (non IO) monads
14:46:38 <EvanR> since IO is often involved that makes sense
14:46:49 <Cale> EvanR: But hey, you can also wrap up what's going on with IORefs/STRefs in its entirety, and abstract over it
14:46:52 <EvanR> and IO can do anything
14:47:25 <Philippa> having a large area that you have to use transformers in is almost inevitably confusing, yeah. Sometimes they're the neatest way to spend 10 lines of "crunchy" code and 50 lines of stub building the thing you needed though
14:47:39 <EvanR> but i feel like the haskell way would rather be build up to the goal from pieces parts than "bondage and discipline"
14:47:52 <Cale> e.g.  data RefOps r m = RO { newRef :: a -> m (r a); writeRef :: r a -> a -> m (); readRef :: r a -> m a }
14:48:05 <Philippa> basically, I think they're a crappy effect system but they're still one of the best pieces of tech we've got for building effectful EDSLs
14:48:16 <Cale> and then  FreeVL (RefOps r)  is a monad with as many mutable references as you want
14:48:29 <Zekka|Sigfig> Philippa: personal experience is that hte interface is kind of awkward, but they work if you really want to use them
14:48:46 <Cale> effectively, it's a pure implementation of the ST monad
14:48:51 <Philippa> right: I'm saying get the hell away from the default interface as fast as you can
14:49:18 <Philippa> wrap it up and expose the thing you meant to be doing in the first place instead. Showing your transformers is probably low-level programming in the Perlis sense
14:49:22 <Cale> but in order to write an interpreter with runST, you'll need ST itself, or something like a polymorphic store that internally uses unsafeCoerce
14:49:44 <Cale> But yeah, the computations themselves, you can represent in a pure way like this
14:50:31 <EvanR> so van laarhoven free monad and transformers are two orthogonal discussions, one is interface, the other is potential implementation. and so "abandone one for the other" doesnt make sense
14:50:38 <Philippa> I suspect we'll start seeing actually-not-awful systems once people've spent a while playing with dependent haskell and realised you can do something more subtle than row types to represent when you do/don't want to talk about ordering
14:50:39 <Cale> I agree strongly with Philippa -- I've far too often seen monad transformers being used as a substitute for thoughtful API design
14:50:51 <shachaf> whoa whoa whoa, hi Philippa
14:51:13 <Philippa> hi shachaf. I got bored, plus had some stuff to talk to Cale about re c'tee business
14:51:23 <Philippa> (nothing I haven't at least hinted at on the haskell-prime list)
14:51:56 <Cale> EvanR: ehhh... kinda
14:52:34 <Cale> EvanR: You often still need something to fill in for the eventual monad, sure.
14:53:00 <Cale> and monad transformers can get you a monad which you use to implement your interpreter
14:53:33 <Philippa> and as we build a proper discipline of "effectful engineering" we're going to admit pretty early on that even if we know there's an underlying structure to "transactional state" we should talk about "transactional state" as often as possible
14:53:42 <Philippa> because, well, high vs low level programming again
14:54:33 <Cale> yeah, and in real applications, your operations, the ones that you actually care about, are not going to be 'get' and 'put'
14:54:34 <Philippa> but you need to be aware of that structure for every time somebody's forgotten to say that's there when it is because, well, it's a structural thing
14:54:44 <Philippa> quite
14:54:59 <EvanR> can i has a library for a monad which has transactional state, exceptions, restricted IO
14:55:04 <Cale> They're going to be something a lot more interesting and structured and indeed "transactional" is a good word there, I think.
14:55:30 <Philippa> transactional makes it clear you don't want the "state survives errors" semantics, certainly
14:56:06 <Philippa> EvanR: StateT over your chosen exception transformer over IO, write wrappers until you have the monad you want to work with
14:56:33 <Philippa> (and this is why you /don't/ have that: aside from the "choose your own IO fragment" it's trivial enough nobody wants to publish it)
14:57:04 <Philippa> remember: bottom of the stack has the last word, because the bottom of the stack is ultimately equivalent to either Identity or IO
14:57:09 <Cale> The thing I like about FreeVL, even if I don't *really* use it so much, is that it better directs your attention to the stuff which matters: you're required to provide a record of the operations you care about, and design that type.
14:57:20 <Philippa> and IO means you're trying to pick an argument with the meteorite hitting your computer
14:57:29 <EvanR> Philippa: but the number of wrappers here is huge, and "write this" is not the same as "a library exists"
14:57:47 <Philippa> Cale: yeah. Which brings me into "ye gods the Haskell module system story is pathetic", but what else is new?
14:58:26 <EvanR> it seems like i shouldnt have to write 100 lines of code to set up a standard imperative backstory
14:58:31 <Philippa> EvanR: yeah, but you /have to write the wrappers/ to declare which IO operations you want access to. So the handful for get/put/exceptions are not that big a deal
14:58:43 <Philippa> you're talking closer to 10 for all the stuff that isn't "which subset of IO?"
14:58:46 <EvanR> no StateT is no adequate either
14:58:51 <dolio> Almost all stuff in this space is minor variations on the same thing.
14:59:03 <dolio> RefOps above is a reified MonadRef type class.
14:59:04 <Philippa> okay, what value of "state" do you need?
14:59:05 <EvanR> it gives you one giant record, not references
14:59:23 <Philippa> okay. Welcome to #haskell: when you say "state" and not "a mutable heap", guess what we're going to give you?
14:59:38 <EvanR> we said "transactional state"
14:59:48 <Philippa> yes. That still doesn't imply a heap
14:59:49 <EvanR> i.e. STM-sort-of-thing
14:59:52 <Philippa> no
15:00:05 <dolio> The VL free monad could be written with the class, too. And the thing you'd be wrapping with that free monad would be the 'tagless interpreter' construction for that free monad.
15:00:07 <Philippa> hi: many of us here have been using haskell substantially longer than STM has been extant
15:00:33 <EvanR> one giant record with 100 wrappers for using it as a set of variables is abysmal
15:00:38 <dolio> And the extensible effects stuff is also free monads, and the mtl is the tagless interpreter analogue of all that stuff.
15:01:05 <Philippa> "transactional state" doesn't mean STM or we'd have said STM. I agree that the lack of a neat COW "heap-as-transformer" monad is an issue
15:01:08 <EvanR> this discussion is about how nice it is to use monads/transformers, not really what is possible
15:01:25 <Philippa> *monad transformer
15:01:25 <EvanR> StateT whatever is possible
15:01:48 <EvanR> i think we agreed its not nice to give your end user a type which is 6 levels of transformer
15:01:53 <Philippa> StateT is also not infrequently what people actually /need/ for their task
15:01:57 <Philippa> yep, no argument there
15:02:06 <EvanR> i say its not nice to have modules upon modules of interface code 
15:02:16 <EvanR> for each and every time you set this up
15:02:21 <Philippa> so: as far as I'm concerned here, the issue is not having STT or similar
15:02:29 <Philippa> otherwise, the duplicated bits are about ten lines
15:02:30 <haasn> Wasn't GHC supposed to have an SMT solver in 7.10?
15:02:33 <Philippa> yes, I write that /a lot/
15:02:46 <haasn> I still can't write my appendV :: Vec t x -> Vec t y -> Vec t (x+y)
15:02:57 <Philippa> if you're after a subset of IO, *you will have to specify that subset somewhere*. So it goes.
15:03:10 <Cale> dolio: Well, yeah -- but tutorials often seem to focus on some very simple examples in that design space (transformers and mtl-style classes) and don't really make people aware of the spectrum, and they end up piling up a bunch of applications of monad transformers in place of actually designing something properly, and then end up dissatisfied.
15:03:19 <Philippa> the constant overhead really isn't that bad if you set the 10 lines up right and don't expose the helper function
15:03:19 <EvanR> yeah and it would be nice to factor out the part that you specify to be exactly the same each time
15:03:50 <chicken> can haskell interact with the winapi? 
15:03:52 <Philippa> which is where you get down to "our module system sucks" and "okay, liftIO in principle was supposed to do that"
15:03:54 <geekosaur> haasn, not ghc itself iirc. someone was working on an SMT solver plugin using the (expanded?) plugin interface in 7.10
15:04:05 <Philippa> chicken: yep, there's a standard lib for it
15:04:09 <Philippa> haven't tried it myself though
15:04:29 <geekosaur> chicken, look at the Win32 module. which is not, unfortunately, documented online because the doc builder is Linux and doc building is part of package building x.x
15:04:39 <EvanR> the complex transformer-backed more-or-less identically wrapped at each point pattern is an abstraction failure
15:04:44 <Cale> dolio: So I like to point it out a whole lot that there are some other sort of "frameworks" to get people thinking. I think if people overused FreeVL, that's a better world than overusing the MonadState/MonadReader/etc. classes, because at least they're forced into defining the set of operations clearly.
15:05:14 <Philippa> EvanR: yes, it is. But you're pointing in the wrong places re where abstraction fails
15:05:27 <EvanR> what am i pointing at
15:05:30 <geekosaur> s/the doc builder/the package builder/
15:05:41 <Philippa> the *actual* failure of abstraction is that we can't take what amounts to a module and say "throw this wrapper around each thing in it and we're done"
15:06:11 <Cale> MonadState isn't intrinsically bad, it just becomes bad when people use it in place of actually designing clear operations.
15:06:31 <Philippa> Cale: or when you actually needed the asymptotic behaviour of references, in fairness
15:06:38 <Philippa> sometimes you wanted a heap
15:07:01 <Philippa> sometimes you want a /branchable/, version-controllable heap. Some languages effectively have those, we don't
15:07:03 <Cale> In that regard, just using my StateOps record type wouldn't be any better
15:07:11 <Philippa> quite
15:07:22 <dolio> Cale: I know that's what you tell people to do. It's kind of contrary to some of the claimed advantages of e.g. the extensible effects stuff, because there you're supposed to be using sets of effects together directly, I think.
15:07:27 <Cale> (and with regard to providing a clear API)
15:07:30 <EvanR> Philippa: yeah so at the least we can create a library for this sort of monad
15:07:42 <dolio> Of course, it's not really an advantage at all, because it's all fundamentally the same stuff with the same capabilities.
15:07:56 <Cale> dolio: right :D
15:08:00 <dolio> Just slightly different presentations/constructions.
15:08:11 <Philippa> EvanR: Yeah. The blocking part for which is the branching heap. Which is very much a "wants actual compiler and RTS support" thing
15:08:17 <Cale> It's really just "please actually think about this a bit"
15:08:44 <Philippa> having to write wrappers rather than just a list of identifiers for which IO operators you want is uncomfortable, but it's nowhere near the same class of issue
15:09:13 <EvanR> for list of IO operations, the record of IO actions is fine
15:09:51 <Philippa> personally I don't see that as any less clunky than the alternatives, but sure
15:10:08 <Philippa> well. *Almost* sure. Now you need the monad to be dependent on that record
15:10:17 <EvanR> yes
15:10:22 <EvanR> thats one of the parameters
15:10:31 <Philippa> I'm sure people've picked standard solutions while I'm gone prior to GHC8 being stable enough, but hey
15:10:44 <Cale> Well, you don't *need* it to be -- you can skip the transition to FreeVL and just pass a record parameter around by hand, and it's really not that bad
15:11:01 <Philippa> it's also not that /good/, though
15:11:06 <Cale> fair enough :D
15:11:12 <EvanR> it works when youre in IO
15:11:23 <EvanR> "just use IO everywhere" is also not that bad
15:11:24 <Philippa> anyway: I'd back a "why the hell don't we have STT yet?" proposal...
15:11:32 <Cale> EvanR: But you're also not in IO
15:11:35 <dolio> You can't have STT.
15:11:41 <Cale> EvanR: you're in "an arbitrary monad with such and such operations"
15:11:41 <Philippa> I'm pretty sure that in practice the lack of STT is what's killing things
15:11:47 <dolio> At least not as implemented in ST.
15:11:56 <Philippa> dolio: what exactly needs to shift?
15:12:11 <EvanR> Cale: how does this work with IO again?
15:12:13 <Cale> EvanR: (which just happens to be IO in the end... maybe)
15:12:19 <Philippa> ...oh, right, you're going to need an explicit interface for navigating the branches
15:12:21 <dolio> You need to not implement it with side effects.
15:12:39 <Philippa> or do what I said, yes
15:13:15 <Cale> EvanR: Your record is parameterised over the underlying monad, and you can keep that parameter abstract until you really run the action, and plug in a MyApplicationOps IO or whatever
15:13:35 <Philippa> I mean, having the equivalent of an actual branchId token in the transformer would surely do too, no? Just so long as the branchId going dead is enough to GC that branch?
15:13:55 <Philippa> but side-effecty implementations are non-trivial enough to've not happened yet, certainly
15:13:59 <Cale> I think I could implement an STT
15:14:10 <EvanR> runApp :: MyRecord IO -> IO ()
15:14:19 <Philippa> Cale: I'm happy with one that needs IO underneath initially too, yeah
15:14:33 <Philippa> (that is, so you've got somewhere you're nominally pinning your base heap to)
15:14:48 <Cale> EvanR: right
15:14:56 <Cale> EvanR: err
15:15:17 <EvanR> FreeVL (MyRecord IO) -> IO () ?
15:15:34 <EvanR> FreeVL (MyRecord IO) a -> IO a ?
15:15:54 <Cale> Or even  (forall m. Monad m => FreeVL (MyRecord m) a) -> IO a
15:16:19 <Cale> if you want to be very picky about not using IO that you shouldn't use
15:16:29 <Philippa> yeah, though that last one's a trick we really ought to have a type synonym for
15:16:52 <Philippa> (building a universal wrapper to promise you're really /really/ not making any other assumptions)
15:16:59 <Cale> er, wait
15:17:01 <Cale> nononono
15:17:04 <Philippa> though I think the point of the parm to MyRecord is to say where its ops are coming from
15:17:05 <Cale> there's an extra m there
15:17:17 <Cale> FreeVL MyRecord a -> IO a
15:17:28 <Cale> The whole point of FreeVL is that it does that quantification for you
15:17:41 <Philippa> *nods*
15:18:06 <Philippa> it's not going to buy the transactional storage EvanR is asking for though, and that does matter
15:18:37 <EvanR> you can implement the primitives with STM
15:19:05 <Philippa> and we end up with some serious cases where "use a logic language instead" becomes the least bad answer because of the mixture of that and other effects
15:19:09 <EvanR> except then you cant do IO in the middle
15:19:26 <dolio> Philippa: I'm not sure how you're going to work out the branching structure for arbitrary monads.
15:19:36 <Cale> EvanR: Of course, if you really want to do random nonsense IO in the middle, you can throw an equivalent to liftIO into your list of operations.
15:19:49 <EvanR> which i dont
15:19:55 <Cale> But... yeah, that sort of defeats the purpose of this exercise
15:20:48 <dolio> Like, I can imagine that instead of passing a featureless token, you pass some 'path', which is used to determine which version of the heap you're referring to.
15:20:54 <ZelteHonor> I have a big problem. A problem of memory leak. Like in 1 minute it fills my 8 go of RAM.
15:20:59 <EvanR> so in a transactional environment, you can update variables and you can schedule "fire and forget" actions that do IO (), and may be forgotten before they happen
15:21:19 <Philippa> dolio: that's more or less what I'm thinking. That, and extant path!tokens being used to determine heap-branch liveness
15:21:31 <EvanR> but you cant do a request and get a response during the transaction...
15:21:35 <ZelteHonor> I have use profiling and the 2 things that full my memory are (') and :
15:21:40 <EvanR> you have to use a callback
15:21:42 <dolio> However, I don't know that that works for all monads.
15:21:45 <EvanR> maybe this can be made into a monad
15:21:46 <ZelteHonor> Wich I assume is a 2-tuple and list.
15:21:57 <dolio> Like, can you number STT (Cont r)?
15:22:27 <Philippa> dolio: each continuation that's /changed/ a heap finds itself holding onto an effectfully-generated new path
15:22:57 <Philippa> oh, wait, other way round. No need to even consider it then, the continuations don't touch state per se so there's no need
15:23:21 <Philippa> ...nope, the first one
15:23:52 <Philippa> Cont on the bottom, each continuation that /changes/ the heap gets its own heap!branch token and you have something internally trying to prove linearity to find cases where it doesn't have to generate that
15:24:09 <Philippa> (because let's face it, that path!token is going to get big)
15:24:27 <dolio> Also, you don't get to know you're working with Cont r.
15:24:33 <Philippa> yeah, I know
15:24:44 <dolio> Or anything in particular, of course.
15:25:00 <EvanR> STT ?
15:25:00 <ZelteHonor> Is there anyone that could help me?
15:25:03 <Philippa> "each thing that changes the heap that I haven't proved linear use of the heap for [because let's leave room for the compiler to do some optimisation] gets a new version"
15:25:56 <EvanR> ST transformer?
15:26:38 <Philippa> EvanR: the thing we'd use if we built a transactional heap that was somewhere in the middle of a transformer stack, were it to exist
15:27:02 <Philippa> dolio: point is, you don't "look down the stack", you just look at how the STT stuff gets invoked
15:27:14 <Philippa> granted, tracing linearity could be /really hard/ sometimes
15:27:29 <Cale> Philippa: have you seen https://hackage.haskell.org/package/vault
15:27:47 <Cale> It could be used to implement a runSTT
15:28:55 <Cale> (in IO, because you'll need to create keys...)
15:29:28 <Philippa> huh. I'm glad that exists. I don't think it's enough to create a /good/ runSTT, but it might be enough for some other problems I have at least!
15:29:40 <Philippa> (guess who's messing about with constraint solving too much)
15:29:48 <Cale> haha
15:30:01 <Cale> Or I guess there's an ST-ish version there now too
15:30:07 <Philippa> admittedly there I'd want the version that's happy with concurrent updates ideally, but yeah
15:30:37 <Philippa> I mean, I'm *still* having "why can't I take the fixpoints off everything and glue them back on later?" problems :-)
15:31:47 <Philippa> (enough so that I got bored enough to /start/ a language implementation, not enough to've finished one)
15:32:01 <Philippa> (hi, I'm the same Philippa you all used to know still!)
15:32:06 <EvanR> not bored enough to finish
15:32:15 <EvanR> same problem
15:32:46 <Philippa> yeah, well. Last few years have been an unfortunate case of "may you live in interesting times" for me, so hey
15:33:33 <Philippa> okay, I realise we can't reliably get every logbot, but did we actually invite irclogger_com in here?
15:33:52 <Philippa> where by "we", I mean the other ops?
15:33:53 <dolio> Philippa: Actually, you might want to talk to edwardk. A couple months ago he was going on about versioned data structures and how to have mutable, efficient implementations of versioned immutable structures.
15:33:58 <dolio> Which is probably related.
15:34:19 <Philippa> dolio: most certainly is, yeah. Then again, we've usually got /something/ to talk about and not enough time
15:35:04 <Philippa> and realistically, er. I have my type system project to take far enough and I probably ought to actually admit I'm getting out after that. Never gonna code for a living, probably never gonna have anything that interests me enough to be more than a very slow side-project, y'know?
15:35:23 <Philippa> (but that type system stuff has the feel of something Actually Important that nobody else is doing, which is a little different)
15:51:22 <djames> Does the Haskell Stack have its own channel?
15:52:07 <djames> I am trying to figure out where Stack 1.10's new `build` options go, exactly, in stack.yaml. I am not seeing an effect with them at the top-level.
15:53:14 <djames> Hmmm, if I intentionally spell the names wrong, stack warns me. So I'm setting up stack.yaml correctly it would appear.
15:53:59 <geekosaur> there is #haskell-stack, yes
15:57:30 <icicled> anyone have experience with composing field parsers w/postgresql-simple?
15:58:03 <djames> geekosaur thanks
16:03:24 <nmdanny> question: how can I turn a set of 2D points into a contagious Boolean array
16:03:46 <nmdanny> a 2d array that is, or a list of lists
16:03:59 <nmdanny> aka, Set (Int,Int) -> Array (Int,Int) Boolean
16:04:07 <nmdanny> or, Set (Int,Int) -> [[Boolean]]
16:04:59 <hpc> nmdanny: it's impossible in haskell, but really easy in smallpox
16:05:29 <nmdanny> what is smallpox
16:05:30 <sm> ?
16:05:37 <hpc> "contagious Boolean array"
16:05:41 <sm> ha
16:05:51 <nmdanny> oh, lol, I meant contiguous
16:05:53 <hpc> it was too good to pass up
16:06:20 <nmdanny> say for example I have the following points: (0,0), (5,0) (0,5) (5,5),
16:06:30 <hpc> nmdanny: there's an array constructor that's basically a loop
16:07:03 <nmdanny> I would like to get the following matrix: [[1,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,0,0,0,1]]
16:07:07 <hpc> nmdanny: i forget what it's called but it's somewhere in the docs, and basically you'd specify the bounds, and an element function of "look up this point in the set and do blah"
16:09:28 <nmdanny> Or, in more simple terms, can I have a function that does: Map (Int,Int) a -> Array (Int,Int) a
16:09:41 <hpc> ah, accumArray
16:09:42 <dolio> Depending on how many points there are, looping over all possible points with a predicate may be pretty un-optimal.
16:10:10 <hpc> dolio: perhaps, but there's not really a better way with the way the question is asked
16:10:22 <nmdanny> in case you're wondering, I am implementing conway's game of life
16:10:34 <nmdanny> my world is represented as a set of the coordinates of alive cells
16:10:50 <nmdanny> however, I have an exercise that requires me to work with [[Int]], where 0 means dead and 1 means alive
16:10:59 <EvanR> yuck
16:11:23 <dolio> If it's nested lists, you can't do better, true.
16:11:32 <nmdanny> acumArray seems to be pretty close,
16:11:44 <nmdanny> would there be a function that converts Array (Int,Int) a to [[a]] ?
16:11:54 <nmdanny> or, say, Array (Int,Int,Int) a to [[[a]]]
16:12:02 <hpc> you'd have to write it
16:12:04 <nmdanny> aka, convert an n-dimensional array to n-nested lists?
16:12:17 <hpc> it can't be written generically
16:12:40 <sizur> is haskell platform the rec way to install? i remember hearing something that support got dropped.
16:14:13 <nmdanny> ok, can the function Array (Int,Int) a -> [[a]], be written manually, in a sane way?
16:14:36 <adamCS> sizur: I think "stack" (http://docs.haskellstack.org/en/stable/README/) is an easier way but it depends what you want.
16:15:56 <EvanR> nmdanny: gymnastics like this is why Vector is probably better than array for practical stuff
16:16:06 <EvanR> just because of the api
16:17:14 <nmdanny> to be fair, I am not interested in neither vector or array
16:17:26 <nmdanny> I want to convert a set of points into an array
16:17:27 <EvanR> in which case you can use toList and chunksOf
16:17:35 <nmdanny> a set of points into a list of lists ***
16:18:26 <EvanR> then you should create your [[(Int,Int)]] with a list comprehension and map it into your set
16:20:06 <nmdanny> No, I already have a given Set (Int,Int)
16:20:26 <nmdanny> I have a bunch of points in 2D space
16:21:10 <nmdanny> I want to convert them to a list of lists, representing a contiguous 2D space 
16:22:08 <EvanR> i know
16:22:25 <EvanR> so create a list of lists with the proper continuous coordinates, in order
16:22:34 <EvanR> and map that to True or False using the set
16:22:52 <EvanR> or Alice Dead or 0 1
16:23:09 <EvanR> or Alice Cooper
16:23:41 <nmdanny> I guess that would be possible,
16:23:50 <nmdanny> I have made a function that gets the bounding rectangle of a set of points
16:23:57 <nmdanny> so I can easily get the width and height of the matrix
16:24:13 <nmdanny> so, the total amount of elements would be width*height
16:24:18 <EvanR> yes
16:24:57 <nmdanny> I could use a listcomp to make a flat array of width*height elements, using calls to Set.Member to check if an element should be 0 or 1
16:25:21 <nmdanny> then, I would use chunksOf width , to de-flatten it
16:25:41 <EvanR> it would be more efficient to doubly recurse through the i j of width, height, but it would be even more efficient to use a proper spatially indexed data structure instead of a Set
16:26:49 <nmdanny> would a 'proper spatially indexed data structure' be, an Array (Int,Int) for example?
16:27:56 <EvanR> Array (Int,Int) Bool ? no
16:28:10 <EvanR> your data is sparse so thats wasting space
16:28:21 <EvanR> kind of sparse
16:28:48 <nmdanny> wait, if my data is sparse, is it not better to use a set of points rather than a contiguous array of 2d space?
16:29:02 <nmdanny> if I have the following points: [(0,0),(100,100)]
16:29:24 <nmdanny> that would be a 2D array of width 100 and height 100
16:29:41 <nmdanny> so 100^2 cells
16:29:47 <nmdanny> as opposed to a list of two tuples
16:30:10 <EvanR> not a set
16:30:46 <EvanR> in doom for example, the entities in the world were arranged in 2D. and they used a special tree that you could ask what is in a certain bounding rectangle
16:30:52 <EvanR> with a set you can only ask what is at a specific point
16:32:42 <EvanR> keyword binary space partition tree
16:33:29 <EvanR> i see references to "k-d tree" more often now though
16:34:44 <nmdanny> sounds cool, although way outside of my needs for now
16:36:28 <nmdanny> ugh I hate how atom's ghc-mod breaks whenever I add a dependency to cabal
16:38:34 <ElMoloko> What's the state of Haskell support in Atom like now?  I'm pretty satisfied with all the vim options, but I can see Atom's support being much better than it was a year ago
16:40:02 <nmdanny> well, for me, better than sublime-text which appears to not be working for me
16:42:30 <rhovland> how can I do something like "type MyStuff = [a]" ? like, if I have functions that are f :: [a] -> Int, say, and I want to change that to f :: MyStuff -> Int ?
16:44:12 <nmdanny> ehm, I'm not sure, but try doing "type MyStuff a = [a]"
16:45:17 <rhovland> nmdanny: oh right. ha.
16:49:18 <nmdanny> fucking ghc-mod keeps crashing
16:49:30 <nmdanny> why does haskell not have proper development tools that are not emacs or vim
16:49:59 <ElMoloko> have you tried Leksah?
16:50:12 <nmdanny> no
16:50:22 <ElMoloko> It's pretty nice, IMO
16:50:32 <EvanR> rhovland: the two other ways would be like type MyStuff a = Foo, then a is called a phantom type. and type Mystuff = forall a . [a] which would be an existential type
16:51:24 <nmdanny> does it work with stack,  shows errors/lints on the code, has autocompletion, autocomplete docs, showing type on cursor selection, etc?
16:53:34 <ElMoloko> It should do all of those things
16:53:41 <ElMoloko> the latter might require some finagling
16:57:02 <nmdanny> well I might try it later
17:06:28 <nmdanny> ugh meanwhile I still have trouble converting a Set (Int,Int) to [[Int]]
17:12:22 <lpaste> louispan pasted “Programatically create new types” at http://lpaste.net/162589
17:13:06 <louispan> Hi, is there already a library that allows the ability to programatically create new types from other types? eg http://lpaste.net/162589
17:14:04 <louispan> I'm not sure how to search for this using hoogle or hackage since the library will only define data family and instances.
17:24:04 * hackagebot time 1.6.0.1 - A time library  https://hackage.haskell.org/package/time-1.6.0.1 (AshleyYakeley)
17:26:08 <lpaste> louispan revised “Programatically create new types”: “Programatically create new types” at http://lpaste.net/162589
17:36:03 <AN_> hey guys! Can i have a question about folds and laziness?
17:38:01 <sm> No you can not!
17:38:37 <sm> just kidding :-)
18:07:03 <tomleb> What is the difference between state and sessions (for the Spock framework) ?
18:09:17 <tomleb> Is it that the state is for the entire website while the session are different for each user ?
18:09:34 <tomleb> Guess I'll check :p
18:14:00 <zRecursive> dcoutts: are you here ?
18:14:58 <zRecursive> @tell dcoutts would you mind sending your solution to z_axis@163.com ?
18:14:58 <lambdabot> Consider it noted.
18:15:12 <dcoutts> zRecursive: I just submitted a pull request for Cabal
18:15:15 <dcoutts> https://github.com/haskell/cabal/pull/3408
18:15:32 <dcoutts> zRecursive: it will not fix the problem, but it will correctly report when the problem is
18:15:47 <zRecursive> ok
18:18:32 <dcoutts> zRecursive: so if you wanted to continue and find the real cause, you could apply that patch to your Cabal-1.22.5.0 and re-compile Setup.exe and re-run ./Setup configure
18:18:37 <sm> tomleb: yes that sounds about right
18:19:05 <dcoutts> zRecursive: then it should tell us which program is producing non-unicode text output that's causing Cabal to trip up here
18:19:25 <zRecursive> dcoutts: i will try
18:19:32 <dcoutts> thanks!
18:21:31 <sm> in a travis.yml, should you cache ~/.ghc ?
18:23:09 <sm> http://docs.haskellstack.org/en/stable/travis_ci/ says not, I guess
18:27:01 <lpsmith> icicled, the support for composite types in postgresql-simple right now is kinda minimal
18:27:44 <lpsmith> icicled, unfortunately postgresql doesn't exactly make it's syntax overly compositional
18:28:33 <lpsmith> I'd suggest flattening the composite types for now,  which works pretty well unless you want to e.g. deal with arrays of composite types
18:29:03 <lpsmith> In which case,  there is support for composite types in the typeinfo system
18:29:13 <zRecursive> dcoutts: `https://github.com/haskell/cabal.git` is working, can i see your patch in browser ?
18:29:31 <lpsmith> But you are pretty much on your own as far as parsing the syntax is concerned
18:29:34 <zRecursive> i mean `git clone https://github.com/haskell/cabal.git` is running now
18:30:21 <dcoutts> zRecursive: git pull https://github.com/dcoutts/cabal.git fix-runprocess-io-output-exceptions
18:33:33 <zRecursive> dcoutts: but i currently have no git repository 
18:33:46 <zRecursive> ls
18:33:56 <dcoutts> zRecursive: I thought you cloned it?
18:34:06 <zRecursive> running ...
18:34:23 <dcoutts> oh ok
18:35:11 <dcoutts> if it's too slow you could apply the patch to your existing version
18:35:12 <dcoutts> https://github.com/haskell/cabal/pull/3408/commits/cc35a48a68a3fb299b23c1934880520db91a71cb
18:42:53 <zRecursive> dcoutts: just finish `git pull https://github.com/dcoutts/cabal.git fix-runprocess-io-output-exceptions`, seeing diff now.
18:47:12 <zRecursive> `ghc Setup.hs` now ...
18:48:27 <zRecursive> dcoutts: `./Setup.exe configure` => Configuring Cabal-1.25.0.0..., then OK ?!
18:48:40 <zRecursive> no error now ?
18:48:59 <dcoutts> zRecursive: no error at all?
18:49:13 <zRecursive> yeah, no any output
18:49:26 <dcoutts> I was expecting an error, but a more useful one :-)
18:50:00 <zRecursive> Does it mean i can  use it now.
18:51:24 <zRecursive> It seems the patch just suppress the output, doesnot it ?
18:51:41 <dcoutts> zRecursive: no, the output was from us using -v3
18:51:58 <dcoutts> zRecursive: no it just reports the exception in the right place and with a better message
18:52:16 <dcoutts> zRecursive: but you're using a whole new version of Cabal, so lots of other changes too
18:52:31 <dcoutts> zRecursive: but perhaps a later one will just work, you could try https://www.haskell.org/cabal/release/cabal-install-1.24.0.0/cabal-install-1.24.0.0-x86_64-unknown-mingw32.zip
18:53:15 <zRecursive> any 32 bits version ?
18:55:17 <zRecursive> It doesnot matter! i will merge the patch and use it until the new version is ready.
18:56:35 <zRecursive> `ghc-pkg unregister Cabal-1.22.5.0` now.
18:59:01 <cyberbat> hello
19:29:08 * hackagebot pseudo-boolean 0.1.4.0 - Reading/Writing OPB/WBO files used in pseudo boolean competition  https://hackage.haskell.org/package/pseudo-boolean-0.1.4.0 (MasahiroSakai)
19:39:08 * hackagebot hw-conduit 0.0.0.11 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-conduit-0.0.0.11 (haskellworks)
20:24:09 * hackagebot hw-json 0.0.0.2 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.0.0.2 (haskellworks)
20:24:11 * hackagebot hw-succinct 0.0.0.14 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.14 (haskellworks)
20:35:19 <koz_> How would I do x >>= foo >>= foo ... >>= foo for n-many instances of >>=?
20:37:41 <simpson> :t iterateM
20:37:42 <lambdabot>     Not in scope: ‘iterateM’
20:37:42 <lambdabot>     Perhaps you meant one of these:
20:37:42 <lambdabot>       ‘iterate’ (imported from Data.List),
20:37:59 <simpson> Hm. There's something like that in Control.Monad... what's it called?
20:38:24 <koz_> simpson: Are you sure it's in Control.Monad and not Control.Monad.FooBarQuux?
20:38:29 <koz_> (for some FooBarQuux)
20:39:23 <simpson> koz_: Oh, I was thinking of replicateM.
20:39:33 <koz_> simpson: http://hackage.haskell.org/package/monad-extras-0.5.11/docs/Control-Monad-Extra.html#v:iterateM <-- this?
20:39:36 <koz_> :t replicateM
20:39:37 <lambdabot> Monad m => Int -> m a -> m [a]
20:39:50 <koz_> Oh yeah, that works perfectly, thanks!
20:40:09 <simpson> koz_: Oh, there's also, more precisely, a bunch of stuff in C.M.Loops: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
20:40:38 <koz_> simpson: Wait, replicateM *doesn't* work for me here.
20:40:48 <koz_> I'll look into Control.Monad.Loops.
20:45:17 <koz_> simpson: Never mind - figured out how to do it with recursion.
20:45:27 <koz_> Probably can rewrite with foldM or something.
20:47:06 <jmcarthur> :t (`appEndo` return) . mconcat . replicate 10 . Endo . (<=<)
20:47:07 <lambdabot> Monad m => (a -> m a) -> a -> m a
20:47:25 <jmcarthur> I'm... mostly kidding
20:47:32 <koz_> jmcarthur: Wow, that's impressive.
20:47:46 <koz_> A little long-winded, but impressive.
20:47:57 <jmcarthur> It's longer than I wanted.
20:48:49 <koz_> jmcarthur: I got it to this: http://lpaste.net/162595
20:49:58 <koz_> Although arguably, permuteBool 0 should give [], not [[]].
20:50:24 <jmcarthur> I think [[]] makes sense.
20:50:58 <koz_> jmcarthur: Yeah, I guess so - it's one permutation of no elements.
20:51:14 <koz_> I don't think I can write permuteBool any more concisely than that, I don't think.
20:51:23 <jmcarthur> ah
20:51:38 <koz_> I also said 'I don't think' twice. Wtf me.
20:52:28 <jmcarthur> You don't mean permutations, do you? This is just all possible lists of bools of a given length, right? Or am I misunderstanding something?
20:53:05 <koz_> This is just all possible lists of bools of a given length, yes.
20:53:14 <koz_> (at least, that was my idea)
20:53:39 <jmcarthur> :t (`replicateM` [False ..])
20:53:40 <lambdabot> Int -> [[Bool]]
20:54:47 <koz_> Wow, is that all I'd need?
20:55:08 <jmcarthur> Yeah, that's the whole thing.
20:55:18 <koz_> Wow, thanks.
20:55:23 <koz_> I got the feeling it could be done simpler somehow.
20:58:38 <koz_> I clearly don't have declarative programming down.
21:01:03 <jmcarthur> It takes time to recognize a lot of patterns
21:08:27 <jmcarthur> :t flip (alaf Endo foldMap (<=<) . replicate 10) pure
21:08:28 <lambdabot> Monad f => (a -> f a) -> a -> f a
21:08:43 <jmcarthur> Still not great.
21:08:55 <jmcarthur> I also hate flip.
21:09:11 <koz_> It's only fun when lambdabot does it.
21:09:22 <koz_> @pl \a b c d e f g -> g f a d b c d e
21:09:23 <lambdabot> ((((flip . (flip .)) .) .) .) . flip flip id . ((flip . (liftM2 (flip . (flip .)) .) . flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .) . flip (flip . flip id)
21:10:58 <jmcarthur> :t foldr (<=<) return . replicate 10  -- less fancy, much better
21:10:59 <lambdabot> Monad m => (b -> m b) -> b -> m b
21:11:11 <johnw> oh yes that's better
