00:00:42 <Cale> Yeah, this thing is sometimes called the van Laarhoven encoded free monad
00:00:56 <Cale> But that's just a name
00:01:20 <Lokathor> ah
00:01:23 <Cale> Despite the higher-rank data cosntructor here, really this is a glorified reader monad for carrying around a record of operations
00:01:50 <linman32> oh hi cale... do u know wut is wrong? http://lpaste.net/162453
00:01:52 <Cale> constructor*
00:01:56 <Lokathor> so it's like putting a ReaderT over stuff, sorta
00:02:17 <Cale> linman32: Yeah, show isn't a method of the Show type class. You're expected to define shows or showsPrec
00:02:54 <Cale> linman32: But really, you probably shouldn't use the Show type class for what you're doing here
00:03:11 <Cale> It's nice if Show instances always produce valid Haskell code for reconstructing the values
00:03:18 <linman32> wut shuld i use?
00:03:23 <shachaf> Cale: It'sa method, just not usually the one you want to define.
00:03:26 <Cale> Some other function that you define
00:03:36 <Cale> er, is it?
00:03:44 <shachaf> Well, sometimes it's fine.
00:04:13 <shachaf> @let data T = T
00:04:15 <lambdabot>  Defined.
00:04:16 <Cale> oh, right, it is
00:04:19 <Cale> huh
00:04:21 <shachaf> @let instance Show T where show T = "T"
00:04:22 <lambdabot>  Defined.
00:04:31 <Lokathor> Cale, i'm going to put this conversation as notes somewhere
00:04:33 <Lokathor> and get back to the idea
00:04:35 <Cale> I'm just not remembering things correctly then
00:05:04 <Cale> and apparently the file linman32 pasted is incomplete, because he wouldn't have gotten that error
00:06:01 <Cale> Lokathor: So, anyway, yeah, you can then consider FreeVL StateOps
00:06:04 <linman32> using BasicPrelude, hiding Prelude
00:06:10 <linman32> @Cale
00:06:10 <lambdabot> Unknown command, try @list
00:06:27 <Cale> linman32: I don't know what BasicPrelude is, but that sounds like the source of your problem
00:07:41 * hackagebot socks 0.5.5 - Socks proxy (version 5) implementation.  https://hackage.haskell.org/package/socks-0.5.5 (VincentHanquez)
00:07:41 * hackagebot mandrill 0.5.2.1 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.5.2.1 (AlfredoDiNapoli)
00:08:14 <Cale> Lokathor: and note that the FreeVL data constructor, whose type is  (forall m. Monad m => ops m -> m a) -> FreeVL ops a,  will turn the field extractors for the record of operations into actions.
00:08:54 <Lokathor> i.. will attempt to process that
00:09:09 <Cale> Well, I'll write out the example in full
00:10:57 <linman32> @Cale think it was problem. getting a lot of other errors, but seems fixed so far. thanks
00:10:57 <lambdabot> Unknown command, try @list
00:24:05 <Cale> Lokathor: http://lpaste.net/162455
00:25:19 <Cale> Lokathor: let me know if that makes sense :)
00:26:43 <Lokathor> so.. a function written for MonadState will work with this?
00:27:07 <Lokathor> I think I'll have to examine it more closely tomorrow, my brain is pretty weak tonight
00:27:33 <Lokathor> but i've got it all written down in a google doc
00:28:20 <Cale> runStateSTRef :: FreeVL (StateOps v) a -> STRef s v -> ST s a
00:28:20 <Cale> runStateSTRef x r = runFreeVL x SO { _get = readSTRef r, _put = writeSTRef r }
00:28:26 <Cale> and so on and so forth
00:28:55 <Cale> you can get interpreters for this FreeVL monad just by supplying the implementations of get and put that you want
00:29:16 <Lokathor> yeah free seemed pretty fancy like that when i first heard about it
00:30:20 <Cale> This is, I think, the an easier encoding of free monads to actually use for most of the things you might want free monads for -- apart from delimited computations where you want to occasionally pause
00:30:39 <Cale> -the
00:32:17 <ocramz> hi there!
00:32:29 <Cale> But if you find the FreeVL bit confusing, you can get essentially everything just writing polymorphic functions which accept an argument of type StateOps s m -- where it's the m which is left polymorphic, and you just assume that it's some monad
00:37:42 <Cale> Lokathor: Well, that "runStateT" is perhaps slightly disingenuous, in that you won't be able to lift a computation in the monad m to being a FreeVL (StateOps s) computation
00:38:15 <Cale> Lokathor: However, we can do things to alleviate that as well :)
00:38:51 <Lokathor> well, you can perform the computation written for the other typeclass within the FreeVL, and so do it in IO for example?
00:39:04 <Lokathor> FreeVL becomes like an adapter, even if it's not normal lifting
00:39:29 <Cale> I mean, there won't be an equivalent to lift/liftIO here
00:39:38 <ocramz> [tooling] does anyone have an effective migration strategy from 7.8 to 7.10 under OSX?
00:40:24 <Cale> Really  FreeVL (StateOps s) a  is isomorphic to  State s a, it's just a reformulation in terms of building up things using get and put and the monad operations
00:40:53 <Cale> ocramz: What would that consist of?
00:42:28 <Cale> Lokathor: but yeah, we could build liftIO into our operations record if we want
00:42:49 <Cale> Just sticking in some field   _liftIO :: IO a -> m a
00:43:15 <ocramz> Cale I don't know; this `cabal-helper` has been introduced since 7.10 and it messes with my setup in strange ways
00:44:31 <jle`> should my stack.yaml go in extra-source-files for a cabal project?
00:45:26 <Lokathor> hmm
00:47:17 <Cale> jle`: I can imagine that being a good idea, if stack doesn't automatically stick it into the distribution tarball.
00:47:58 <Cale> jle`: I haven't really used stack much, but I imagine that it behaves similarly to cabal sdist when you stack sdist
00:48:06 <jle`> cool.  i just notice that i've been doing it automatically
00:48:20 <jle`> i'm not sure if it's by accident, but i just noticed it and i was wondering if there was a good reason
00:48:26 <jle`> or if i had just picked up the habit randomly
00:48:41 <Cale> try leaving it out and see if it ends up in the sdist tarball :)
00:49:38 <jle`> i...don't imagine that it would.  would it make a difference if it was?
00:49:59 <jle`> (it might, i'm not sure :O  i'm more interested in the implications of it being included or not)
00:50:37 <Cale> jle`: Well, stack might include that file itself anyway
00:51:18 <jle`> what does the inclusion of the file do?
00:51:29 <jle`> just allow people who 'cabal unpack'/'stack unpack' it to have it?
00:51:42 <jle`> does the file have any effect when just normally cabal/stack-installing?
00:52:21 <Cale> Doesn't it say where to get all the packages from?
00:52:26 <Cale> I imagine that has an impact
00:53:51 <Cale> It obviously has no effect when you cabal install the package
00:54:13 <fr33domlover> Is there a performance difference in attoparsec between writing in monadic (do notation) VS applicative style?
00:54:26 <jle`> if it's stack-installed from stackage, i always thought that the stack.yaml of the project you're in/your global stack.yaml decides where packages come from
00:54:33 <fr33domlover> or is readability the only consideration
00:54:37 <Cale> fr33domlover: Doubtful...
00:55:02 <Cale> There's potential performance to be had there, but I don't *think* attoparsec is designed to take advantage of it
00:55:33 <fr33domlover> Cale, thanks
00:56:07 <Cale> fr33domlover: Yeah, looking at the code, the Applicative instance uses the Monad instance.
00:56:46 <Cale> for some reason, not using Control.Monad's ap, but instead reimplementing it... I'm guessing something to do with the inliner.
00:57:11 <fr33domlover> i have some code to convert to monadic then... :P
00:57:41 <fr33domlover> all the 'optional' and '<*' and '*>' make the current code not readable like i'd want
00:58:26 <Cale> The main problem is when you get things like (\many args here -> ...) <$> ... <*> ... <*> ...
00:58:38 <Cale> (for readability)
01:01:02 <Cale> The mnemonic for *> and <* is that the arrows point toward the thing whose result matters... that can result in some pretty clear code if used well
01:02:31 <chattered> spaces *> lookAtMe <* spaces
01:07:37 <mikail_> Hi, I need some beginners help with typeclasses. Please refer to this example : http://lpaste.net/162457. In the instance I would like to pass in a Foo and then access the Int inside the implementation. I am not sure how to do that. Please can you help me with that.
01:09:45 <koz_> mikail_: http://lpaste.net/162457#a162458
01:10:05 <koz_> This is called 'pattern matching' - it's very useful!
01:10:06 <mikail_> wow - easy as that!
01:10:09 <mikail_> thanks mate
01:10:18 <koz_> mikail_: No problem - it's a good thing to know.
01:10:19 <mikail_> cheers
01:10:42 <EvanR> its a good thing to make you hate going back to javascript ;)
01:11:22 <koz_> EvanR: Or almost anything else.
01:11:51 <EvanR> except javascript is one where you might find yourself doing functional programming
01:12:08 <EvanR> not so much in ruby or blub5.3
01:12:10 <koz_> EvanR: Well, you can do some level of functional programming in practically any language.
01:12:39 <EvanR> theres "can" and its hard to separate that from "be ridiculed out of a company"
01:13:05 <koz_> EvanR: I didn't realize we were discussing corporate policy; I thought we were talking about programming. :P
01:13:31 <koz_> If your employer has a screaming hard-on for whatever-they-think-OO-means, the language they impose on you won't really make any difference.
01:14:08 <koz_> (for example; feel free to replace the screaming hard-on for something biologically more appropriate to the employer in question)
01:14:17 <EvanR> standard support for the stuff you do in haskell ranges from a pain in the ass to if-you-do-it-your-code-is-probably-broken
01:14:19 <mikail_> lol
01:14:28 <koz_> EvanR: On *that*, we are in total agreement.
01:14:56 <EvanR> pain in the ass would be getting by without pattern matching
01:15:11 <Cale> Guys, it's easy to do pattern matching in Javascript. Just build all your Javascript using GHCJS ;)
01:15:29 <EvanR> lol... and x86 has pattern matching!
01:15:37 <EvanR> build with GHC-not-js
01:15:39 <Cale> Indeed it does!
01:15:57 <dfeuer> I could use some help defeating full laziness (or whatever exact transformation is giving me this trouble). GHC wants to allocate a thunk I only need sometimes to increase sharing; I don't care about sharing this particular thing.
01:16:17 <koz_> Cale and EvanR: Lols.
01:16:54 <Cale> koz_: haha, only serious
01:17:01 <dfeuer> I could make this happen with NOINLINE, I think, but that would screw up other things (I want some things unpacked, and GHC won't unpack them with NOINLINE)
01:17:16 <koz_> dfeuer: Mind showing us the code you think is causing this?
01:17:21 <dfeuer> I could work around that by replacing my datatype with unboxed pairs, but that would suck.
01:17:24 <koz_> It's a little hard to give any answers in the abstract.
01:17:26 <dfeuer> koz_, sure, one sec....
01:20:35 <dfeuer> koz_, take a look at https://github.com/haskell/containers/pull/215/files and scroll down to line 985.
01:20:50 <dfeuer> Well, actually 987. 
01:21:12 <dfeuer> The trouble is that  deleteAlong q m depends only on q and m, and not on fres.
01:21:40 <dfeuer> So GHC creates a thunk way up high for it.
01:22:05 <koz_> Would a bang annotation for the 'fres' argument in that lambda there fix it?
01:22:59 <dfeuer> This would actually increase sharing .... under circumstances I don't care about. koz_, I don't see how a bang annotation there would matter. The trouble is that once I case analyze it, the Nothing branch is "too free".
01:23:07 <dfeuer> Or whatever.
01:32:57 <dfeuer> koz_, I can do it with GHC >= 7.10 using the extremely magical oneShot function, which is not really approved for external use.....
01:36:49 <oherrala> Humble Bundle (https://www.humblebundle.com/eye-candy-bundle) has Human Resource Machine. Cool little programming game :)
01:45:10 <dfeuer> Huh.... I think I fixed it.
01:47:54 <dfeuer> Oh no, I didn't.
01:47:56 <dfeuer> Silly me.
02:07:37 * hackagebot HaskellNet 0.5.1 - Client support for POP3, SMTP, and IMAP  https://hackage.haskell.org/package/HaskellNet-0.5.1 (lemol)
02:11:53 <biglama> hi guys, can someone show me how to sort a vector of integers with vector-algorithms ?
02:12:19 <biglama> sort $ fromList [9, 2, 1] complains about a Control.Monad.Primitive.PrimState
02:12:55 <EvanR> it seems to require IO or ST
02:14:20 <biglama> http://stackoverflow.com/questions/3655329/how-does-one-sort-with-data-vector-generic-mutable
02:14:34 <biglama> here they seem to make mutable vector but I find that a bit complicated...
02:14:49 <EvanR> are you trying to do it on a mutable vector?
02:14:57 <lyxia> well vector-algorithms does work on mutable vectors
02:15:09 <lyxia> I can't see fromList in the mutable interface
02:15:11 <EvanR> i would be surprised if fromList [9,2,1] gives you a mutable vector
02:15:27 <EvanR> since its not IO
02:15:49 <biglama> no, my vector is not mutable 
02:16:04 <biglama> but I haven't found anything else on sorting vector on Google :(
02:16:41 <lyxia> thaw (fromList [9, 2, 1]) >>= sort
02:16:50 <lyxia> well this discards the vector
02:16:59 <lyxia> thaw (fromList [9, 2, 1]) >>= \v -> sort v >> dostuffwith v
02:17:11 <EvanR> vector-algorithms seems to be about in-place, mutable stuff
02:17:45 <EvanR> to sort an immutable vector, sort the toList and use fromList, i guess!
02:18:11 <biglama> EvanR: yeah but it seems a bit inefficient, isn't ?
02:18:23 <EvanR> not sure
02:19:14 <ggVGc> is there a stanard function for this, and if not, how can I write this more efficiently? https://gist.github.com/10725b6b3d9a23b574d40d4394752877
02:20:05 <biglama> okay, thanks
02:20:39 <biglama> lyxia: could i store the sorted v in a variable with your version ?
02:20:54 <biglama> let a = thaw (fromList [9, 2, 1]) >>= \v -> sort v 
02:20:57 <biglama> does not work
02:21:56 <EvanR> thaw makes a copy right
02:22:01 <lyxia> you have to freeze it back
02:22:48 <lyxia> let a = runST (thaw myVector >>= \v -> sort v >> freeze v)
02:23:10 <lyxia> EvanR: right
02:23:46 <biglama> lyxia: thanks ! 
02:24:08 <biglama> but I don't really understand what's going on with thaw, runST (don't know anything about monads actually)
02:24:45 <lyxia> ggVGc: Yours looks fine. maybe you can save one traversal with list & reverse & dropWhile (not . pred) & reverse
02:25:29 <bernalex> I've had this but can't think of an example right now -- does anyone have an example of runtime errors when using record access functions?
02:26:14 <kadoban> ggVGc: I think that's essentially Data.List.dropWhileEnd ?
02:27:15 <lyxia> oh I didn't know that one either
02:31:05 <kadoban> bernalex: Can't you get those when you do …   data A = A { unA :: Int } | B    and then call unA on a B? Or maybe you're looking for something else?
02:31:35 <bernalex> kadoban: perfect example -- ta!
02:31:45 <kadoban> Cool, always glad to provide terrible code ;)
02:32:01 <bernalex> kadoban: I'm working on my "Why Haskell Sucks" presentation from my reddit thread. ;)
02:32:11 <kadoban> Haha, wonderful
02:32:18 <lyxia> biglama: ST is a typesafe way of writing algorithms that use mutation to implement pure functions.
02:32:51 <Xnuk> > let a = [1..] in a == a
02:32:55 <lambdabot>  mueval-core: Time limit exceeded
02:32:56 <lyxia> The types are kinda scary admittedly.
02:33:09 <bernalex> kadoban: it's terrible code indeed -- but it really should not be permitted.
02:33:45 <kadoban> Well, it's at least warned about. Partial functions in general are kinda not good in haskell, but occasionally necessary.
02:34:15 <bernalex> kadoban: well, I'm the guy who wants an opt-in totality checker for haskell
02:34:45 <kadoban> bernalex: That sounds nice. Though -Werror is already kind of it and more, right?
02:34:56 <EvanR> bernalex: oh was that your presentation
02:35:13 <EvanR> it was kind of a mystery for a minute
02:35:16 <bernalex> EvanR: the one on /r/haskell now? that's someone else's
02:35:20 <EvanR> oh
02:35:40 <bernalex> EvanR: I put up the thread and announced the meetup -- quite randomly someone else were scheduling a presentation on the exact same topic at the same time
02:36:50 <bernalex> kadoban: I'm not sure if -Werror picks up everything that I want for that... it certainly picks up too much though! what I'd want is to be able to annotate my functions with "total", and have the compiler guarantee totality.
02:37:33 <kadoban> Yeah, that'd be kinda cool. And yeah -Werror isn't exactly right (and somehow I doubt it does catch everything).
02:37:49 <EvanR> luckily haskell is a total language, it is well known that bottom inhabits every type
02:38:13 <kadoban> Definitely won't catch *uses* of partial functions at least, since there's no warning for that.
02:38:36 <bernalex> kadoban: it would also be cool if you could annotate a usage like 'total head []'.
02:39:10 <kadoban> bernalex: Like "trust me, this really is not going to blow up, this time?"
02:39:30 <bernalex> kadoban: no like 'pls guarantee that this won't blow up'.
02:39:49 <bernalex> kadoban: I want compiler guarantees not programmer guarantees. those are always wrong. :p
02:39:52 <EvanR> how do you guarantee using head wont blow up... with haskells type system
02:39:57 <kadoban> bernalex: Ahh. That sounds hard to me, though I dunno what I'm talking about.
02:40:19 <kadoban> bernalex: Compiler guarantees kind of require … haskell to totally be a different language, don't they?
02:40:19 <bernalex> EvanR: you don't... I think. which leads back to something else I complained about -- no dependent types. :)
02:40:20 <EvanR> and the list type being the way it is
02:40:59 <bernalex> kadoban: hm I don't think it's wholly unfeasible at least for things like opt-in totality checking of individual functions. but I'm not sure.
02:41:00 <EvanR> type List1 a = (a, [a]) there we go
02:41:05 <EvanR> fst is total
02:41:11 <kadoban> It seems like you could get something fairly nice without even dependent types. As interesting as agda is … doesn't seem very fun to program in.
02:41:35 <bernalex> idris is 'simpler' to program in.
02:41:39 <bernalex> easier on the eyes too.
02:41:57 <kadoban> bernalex: It'd be nice if it was opt-in and you could also annotate specific usages with "yep, this is fine". At least that would show someone thought about it.
02:42:04 <bernalex> yeah
02:42:09 <bernalex> it would be an improvement over nothing!
02:42:11 <kadoban> I should try idris more.
02:42:26 <EvanR> totality checking would require data types that were known to be non infinite
02:43:39 <bernalex> EvanR: or a way to not permit total functions to operate on possibly-infinite types.
02:43:59 <EvanR> i mean, any recursive type is possible infinite
02:44:02 <bernalex> basically, "total functions" could only operate on "total types".
02:44:43 <EvanR> and we dont know where the type came from 
02:44:49 <EvanR> i mean where the value came from
02:44:52 <bernalex> yeah. I enjoy infinite types for their elegance. but in general I think I would value totality way more.
02:45:32 * EvanR opens the emergency exit to reveal idris out in the alleyway
02:57:53 <ocramz> anyone here using Emacs, OSX and stack (at the same time)?
03:00:40 <bernalex> any lens guys in here who can give me a lens example for replacing nested record updates?
03:00:47 <bernalex> data D = D { e :: E }
03:00:49 <bernalex> data E = E { f :: F
03:00:51 <bernalex>            , x :: Int }
03:00:53 <bernalex> data F = F { y :: Int }
03:01:28 <bernalex> now, making a D with an E that has x=1 and an F with y=2 with record syntax is just ugggghhhhhhh. how would it be with lenses?
03:01:32 <dfeuer> *barf*
03:01:43 <dfeuer> I just found myself needing to use Proxy# for the first time.
03:01:53 <dfeuer> And not as it was intended.
03:01:59 <bernalex> I don't use lenses often enough to remember the syntax, unfortunately. I could look it up, but my guess is you guys can think of something more clever than I'll end up with anyway. :)
03:02:07 <bernalex> dfeuer: hiya!
03:02:29 <salutcestrene> hi all
03:02:41 <dfeuer> bernalex, I can never remember lens operators. Sorry. I understand some of the basic ideas, and how to implement some lensy things, but using them is another story.
03:02:57 <salutcestrene> i have just one newbie question, how can i map over a Seq ?
03:03:26 <lyxia> fmap?
03:03:31 <salutcestrene> omg thanks
03:03:38 <salutcestrene> that's it
03:03:46 <dfeuer> I use a NOINLINE function   bogus :: a -> Proxy# (); bogus a = proxy#, then pass the resulting proxy all through my recursion to fool GHC into thinking I care about its nonexistent value.
03:03:46 <lyxia> :D
03:03:58 <salutcestrene> i didn't manage to find an answer the such a simple pb :p
03:04:19 <dfeuer> Q: "How do I map over a _____?" A: "fmap, probably".
03:04:31 <dfeuer> salutcestrene, you can also use Data.Sequence.map
03:04:35 <dfeuer> I think?
03:04:36 <dfeuer> er..
03:04:39 <dfeuer> Maybe that doesn't exist.
03:04:47 <salutcestrene> nop it doesn't 
03:04:52 <dfeuer> Never mind.
03:04:53 <dfeuer> :P
03:05:08 <lyxia> bernalex: eLens . fLens . yLens %~ (+1) $ someD
03:05:09 <dfeuer> But yeah, fmap works for most things.
03:05:38 <paolino_> s/most things/functors
03:05:49 <salutcestrene> did fmap use specialized map function where they are available ?
03:05:59 <funrep> why do i get this error? https://gist.github.com/funrep/e980dfd7ecf2e6a1e019f798764e6f01
03:06:13 <dfeuer> salutcestrene, unless someone's implemented it in a very strange way, then *always*.
03:06:17 <funrep> when i define the exact same function in ghci with let syntax i do not get an error 
03:06:25 <jle`> funrep: you spelled identity wrong
03:06:28 <jle`> on line 2
03:06:37 <jle`> it's spelled "idendity"
03:06:37 <lyxia> salutcestrene: you can learn a lot about what you can do with a type by just looking at the instances it implements
03:06:53 <salutcestrene> i mean, when a type is an instance of Foldable, i guess its implemtation routes to specialized map
03:06:54 <bernalex> lyxia: what's someD? I was wanting to make a new D
03:07:09 <bernalex> lyxia: so... D?
03:07:16 <funrep> jle`: oh thanks!
03:07:20 <lyxia> bernalex: some value of type D
03:07:23 <jle`> np!
03:07:27 <EvanR> salutcestrene: you mean Functor ?
03:07:28 <lyxia> bernalex: and you use lens to modify it
03:07:32 <bernalex> lyxia: right that's what I assumed. so D. :) thanks
03:07:40 <salutcestrene> oops yes
03:07:42 <salutcestrene> functor
03:07:54 <lyxia> bernalex: well D is already the name of the constructor
03:08:06 <bernalex> lyxia: right so you need a lensD or whatever
03:08:13 <EvanR> each instance is a specialized implementation
03:08:23 <bernalex> lyxia: but where is X set to 1 here?
03:08:27 <lyxia> bernalex: no you just need a concrete value of type D
03:08:31 <bernalex> and y is set to (+1), whatever that menas
03:08:32 <salutcestrene> ok, thanks guys
03:08:40 <EvanR> which happens to be auto derivable!
03:08:50 <lyxia> bernalex: it means "increment the value in the y field of the f field of the e field of someD"
03:08:53 <bernalex> lyxia: ah
03:09:15 <bernalex> lyxia: ok so what I inquired about was making a D that has an E with x=1 and an f with y=2.
03:09:20 <lyxia> if you want to increment x, you would use the lens (eLens . xLens) instead
03:09:20 <bernalex> lyxia: that means constructing a new D
03:09:41 <lyxia> you wouldn't use lenses to construct values from scratch
03:10:06 <dfeuer> Interestingly, my new version of `at` for Data.Map is faster for replacing a key than the `insert` function is. It may be time to change the insert function....
03:10:45 <bernalex> lyxia: well how would D/E/F look with lenses? different, no? so constructing a D would be different if there were lenses instead of record fields
03:10:46 <dfeuer> Also interestingly, it seems no one noticed how absurd the implementation of `adjust` was in that module.
03:11:13 <dfeuer> [having been implemented using a function that's substantially more general but also substantially slower)
03:11:36 <jle`> dfeuer: nice
03:11:48 <paolino_> bernalex, lenses are paths in this case
03:12:01 <jle`> i always thought containers was heavily optimized
03:12:16 <jle`> as a priority
03:12:21 <bernalex> paolino_: I want to use eLens . fLens . yLens %~ (+ 1), like lyxia said, but applied to a D constructed like I mentioned above
03:12:32 <dfeuer> jle`, my `at` still isn't as fast for some other things, and may never be. But its primary goal is to be *decent* when key comparison is really cheap, and to beat the pants off other options when that's *not* the case.
03:12:33 <lyxia> bernalex: I don't understand your question.
03:13:11 <dfeuer> jle`, see this craziness: https://github.com/haskell/containers/pull/215/files
03:13:14 <bernalex> lyxia: OK let's start with -- how would you define e/f/yLens?
03:13:22 <dfeuer> jle`, if you can improve my BitQueue, please do.
03:13:36 <jle`> a work of art :3
03:13:48 <dfeuer> jle`, eh?
03:14:05 <jle`> the code in the commit
03:14:10 <lyxia> bernalex: by hand or automatically using TH?
03:14:37 <bernalex> lyxia: right. so -- is there a way (with lens or otherwise) to alleviate the construction of D per my instructions?
03:14:48 <dfeuer> jle`, I find much of it horrifying. The bit crud, and also the use of Proxy#.
03:14:59 <paolino_> bernalex how is it ugly to build your value ?
03:15:02 <lyxia> bernalex: I still didn't quite understand your instructions.
03:15:44 <bernalex> paolino_: because nested records don't really look very nice. even remembering precedence and where to put parens is a chore.
03:15:57 <paolino_> lenses solves (at least) the ugly *update* operation, because creation is not ugly
03:15:58 <lyxia> bernalex: I just showed one way of defining a function D -> D using lenses, that modifies some chosen nested field.
03:16:00 <barbar> hi
03:16:09 <barbar> I downloaded a haskell source zip from github
03:16:15 <barbar> but it's not clear to me how I install it
03:16:16 <lyxia> bernalex: but if you start with nothing you won't be able to apply that function
03:16:20 <barbar> can anyone help?
03:16:55 <lyxia> barbar: are you trying to install the compiler GHC?
03:17:02 <bernalex> paolino_: actually, only for updates are the parens needed here. you could just do D { e = E { f = F { y = 2 }, x = 1 } }
03:17:04 <barbar> lyxia: no
03:17:05 <bernalex> which isn't *that* terrible
03:17:10 <paolino_> bernalex, D(E 1 (F 2)) is not ugly
03:17:17 <barbar> lyxia: I have ghc on my computer already
03:17:31 <EvanR> bernalex: if you are setting a constant value
03:17:31 <bernalex> paolino_: yeah but that's not using record syntax. :)
03:17:47 <bernalex> lyxia: yeah I understood that
03:18:20 <lyxia> ok, so can you reformulate your requirements?
03:18:25 <paolino_> bernalex, I think the only need for that syntax is update
03:18:37 <bernalex> lyxia: right now I'm using 'eLens . fLens . yLens %~ (+ 1) D (E 1 (F 2))'
03:19:50 <bernalex> the equivalent with record syntax is uh well yeah I'm still working on that because there are too many curly braces for my brain
03:19:52 <lyxia> barbar: usually haskell projects have a theproject.cabal file, and we just use stack or cabal to build it.
03:20:16 <barbar> lyxia: there is a cabal file in the root
03:20:33 <barbar> so I just type 'cabal <filename>'?
03:20:39 <paolino_> cabal install
03:21:32 <paolino_> or (sometimes better) cabal sandbox init && cabal install 
03:21:51 <bernalex> lyxia: (f (e D { e = E { f = F { y = 2 }, x = 1 } })) { y = 2 } looks right
03:22:15 <fakedrake> hello, i am trying to run ghc in a sandbox with `cabal exec runghc -O2 Foo.hs' but it complains that -O2 is not known to exec
03:22:40 <lyxia> bernalex: this just gets you the f field
03:22:46 <bernalex> lyxia: or, to mirror the lens, (+1) (y (f (e D { e = E { f = F { y = 2 }, x = 1 } })))
03:22:55 <bernalex> lyxia: yeah I need to stuff that into the E and so on too
03:22:59 <lyxia> right
03:23:14 <bernalex> lyxia: it actually only gives me the y
03:23:36 <lyxia> barbar: what paolino_ said.
03:24:30 <lyxia> bernalex: \d -> let e' = e d ; f' = f e' ; x' = x f' in d { e = e' { f = f' { x = x' + 1 } } }
03:24:48 <barbar> lyxia: it seemed to work
03:24:50 <barbar> thanks
03:24:56 <bernalex> lyxia: type errors
03:25:01 <lyxia> :'(
03:25:17 <lyxia> oh
03:25:19 <lyxia> s/x/y
03:26:07 <lyxia> type errors are not sexy
03:26:40 <paolino_> the impossible has happened is
03:27:36 <EvanR> runtime error is a type error in a type system that no one could be arsed to invent
03:28:41 <bernalex> lyxia: let d = D {e = E {f = F {y = 2}, x = 1}} in (\g -> d { e = (e d) {f = (f . e $ d) { y = g (y . f . e $ d) }} }) (+1)
03:29:51 <lyxia> No thank you, I'll have some more lenses.
03:30:20 <bernalex> d { e = (e d) {f = (f . e $ d) { y = (y . f . e $ d) + 1 }} } is shorter
03:33:46 <lyxia> GHC tells you "My brain just exploded" when you let-pattern-match on one. Are there other fun error messages out there?
03:33:59 <lyxia> let... on a GADT*
03:41:44 <EvanR> whats the issue with let binding a GADT? 
03:42:51 <xa0> Test
03:43:07 <paolino_> too much lazyness ?
03:48:43 <akegalj> when some class is defined "class ClassName a b | a -> b where" what should this definition mean? Can someone point me to the documentation
03:50:03 <lyxia> it is a type class with two parameters, and a determines b.
03:50:19 <lyxia> the | a -> b part is called a functional dependency
03:50:53 <lyxia> akegalj: https://prime.haskell.org/wiki/FunctionalDependencies
03:51:38 <akegalj> lyxia: thanks, will take a look
03:53:29 <EvanR> i looked at looks like 1% of the error messages in ghc code... nothing as awesome as brains exploding yet
03:58:46 <akegalj> lyxia: can you elaborate what means "a determines b"? If I didn't write functional dependency "class ClassName a b where" how would that differ from "class ClassName a b | a -> b where". Can you name an example ?
03:59:20 <akegalj> I read the link documentation but it is not clear to me yet
03:59:42 <hpc> akegalj: suppose you were writing some kind of C-like thing
04:00:10 <hpc> akegalj: you have implicit conversions in C, which you might represent with type classes, and you have things of the same number of bits
04:00:23 <lyxia> akegalj: it means that for every type a there is at most one b such that there is an instance ClassName a b.
04:00:29 <hpc> akegalj: you might do class Convertable a b where ..., with instances for all the ints and such
04:00:58 <hpc> akegalj: but then for things of the same size, maybe you want to pick a canonical type for each size like u_int32_t
04:01:26 <hpc> so you use a fundep there, and have instance SameSize Float UInt32, etc
04:02:06 <hpc> so you say that everything of the same size is related to its respective word type, but nothing else
04:02:21 <hpc> (this is actually a bad example i just realized)
04:03:42 <lyxia> akegalj: MonadState for example. The constraint MonadState s m tells you that the type m has a state of type s.
04:03:46 <akegalj> hpc: yes, that one was too deep.
04:04:24 <lyxia> And the typeclass has a dependency: MonadState s m | m -> s, which means that you can deduce the state type just from looking at the type m.
04:04:53 <akegalj> lyxia: ok, does "a determines b" always mean "a has b" ?
04:05:12 <akegalj> or "a contains b"
04:05:36 <akegalj> let me think for a minute
04:05:45 <hpc> it just means given a known type 'a', you can instantly infer 'b' with no other information
04:06:11 <akegalj> ok
04:06:13 <akegalj> I get it
04:06:17 <lyxia> akegalj: Not really, the relationship can be less clear than that.
04:07:09 <akegalj> so " | a -> b" is just streightening some constrains
04:07:10 <lyxia> I mean often, m is a monad transformer stack and you just look for the parameter of StateT. But sometimes m is an opaque type and it can still have some state.
04:08:05 <hpc> sometimes m's state is monomorphic, even
04:08:12 <akegalj> yes, ok. On a very generic way I understand now. Thanks lyxia hpc 
04:08:30 <lyxia> One other way to say it is in this case is that the typeclass is a function (hence "functional" dependency)
04:08:50 <hpc> i am trying to think of a MonadState example where the state isn't a type parameter...
04:10:25 <hpc> (loads of examples for MonadIO types that aren't MonadTrans though)
04:27:34 <gpyh> hi
04:28:04 <bernalex> can someone give me a scary lens type error? one of the reasons haskell sucks is apprantely because lens type errors are scary.
04:28:57 <gpyh> say a module exports this type: newtype MyInt = MyInt Int ; It does not export the constructor. When I import the module, can I access the underlying Int?
04:29:42 <mpickering> If you use unsafeCoerce then yes
04:30:04 <gpyh> mpickering: thank you
04:30:35 <mpickering> however, it is probably safer to ask the library author to expose the constructor
04:37:32 <lyxia> Does safe coerce not work if the constructor is not exposed?
04:43:28 <maerwald> I'm looking for a way to do restricted IO code testing, something like a sandbox, without me having to use something like docker or chroots
04:46:39 <mpickering> lyxia: That is a good point, yes it does
05:05:33 <jophish> maerwald: the first think I thought of when reading your question was docker or chroots
05:06:02 <jophish> maerwald: see this though https://blog.pusher.com/unit-testing-io-in-haskell/
05:06:49 <maerwald> well, mocking is no option
05:12:43 * hackagebot purescript-bridge 0.3.2.0 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.3.2.0 (eskimo)
05:20:13 <Benzi-Junior> ok guys how should one generate tags for haskell files
05:20:45 <Benzi-Junior> on the wiki it says: echo ":ctags" | ghci -v0 Main.hs
05:21:25 <Benzi-Junior> but that doesn't go through the codebase only the Main.hs file
05:22:11 <Benzi-Junior> and "echo ":ctags -R" | ghci -v0 Main.hs" generated the tags and wrote them to a file named "-R" 
05:23:07 <Benzi-Junior> and by generated the tags I mean only the tags for the Main.hs file
05:30:09 <stphn> Hi, haskellers, I need your help about your daily practice, developping with Haskell in linux environment.
05:30:12 <stphn> ubunut for me
05:30:44 <stphn> I would like really often to look at the source code of Prelude or other stuffs I use, where can we find them ?
05:31:55 <osa1> stphn: you can use Hackage to browse sources
05:32:21 <osa1> stphn: http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html see "source" links
05:32:43 * hackagebot conduit 1.2.6.6 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.6.6 (MichaelSnoyman)
05:33:28 <maerwald> unfortunately some "source" links are broken for some packages
05:33:42 <maerwald> mostly because of CPP and internal modules
05:34:03 <maerwald> https://hackage.haskell.org/package/filepath-1.4.1.0/docs/src/System.FilePath.Posix.html#pathSeparator
05:34:31 <osa1> maerwald: it's working as expected I think
05:34:45 <osa1> maerwald: you need to find Internal.hs
05:35:05 <maerwald> osa1: no, it's not working as expected
05:35:16 <osa1> maerwald: you want macros to be expanded?
05:35:22 <bergey> stphn: Another option is `cabal get base-4.8.0.0` to download a source package.
05:35:36 <maerwald> osa1: no, I want to get to the source code of the function and I don't care how hackage does it
05:36:23 <lyxia> or stack unpack :)
05:36:40 <osa1> maerwald: that may not be possible in general. the source you'll be using in your system will be different than what Hackage will be using in some cases
05:37:20 <osa1> IIRC there's also a ctags generator that generates tags of all the dependencies so you can just jump to a tag to look at docs/src
05:38:18 <Benzi-Junior> anyone know haw to have ghci generate tags recusively through a codebase ?
05:38:32 <thomie> Benzi-Junior: use hasktags or fast-tags, both mentioned on the wiki
05:38:41 <osa1> Benzi-Junior: use fast-tags
05:39:08 <maerwald> osa1: it's not about the perfect solution, but anything is better than the current one
05:40:02 <osa1> at least being able to follow the #included file would be nice
05:41:14 <Benzi-Junior> both of those use their own parser so they won't neccesarily parse correctly
05:41:50 <osa1> Benzi-Junior: that's how you handle partial inputs and CPP-filled files
05:42:33 <paolino> is there a way to "reify" a constraint so it can be used in instance selection ?
05:47:10 <Philonous> How do I catch an IOException of type ResourceVanished ?
05:47:24 <lyxia> paolino: this? data C' a where C' :: C a => C' a
05:47:44 * hackagebot Win32 2.3.1.1 - A binding to part of the Win32 library  https://hackage.haskell.org/package/Win32-2.3.1.1 (TamarChristina)
05:50:09 <Benzi-Junior> osa1: fast-tags still only goes through the top file it doesn't go through the imports
05:50:35 <osa1> Benzi-Junior: no it doesn't, you specify which files/dirs to tag
05:50:47 <osa1> Benzi-Junior: try fast-tags --help
05:51:02 <osa1> Benzi-Junior: this is what I use to tag GHC, as an example https://github.com/osa1/rcbackup/blob/master/.zshrc#L147
05:51:15 <maerwald> Philonous: catch action (\e -> if ioeGetErrorType e == ResourceVanished then ...) or something
05:52:25 <Philonous> Yes, where do I get the ResourceVanished constructor from? It's not exported by System.IO.Error
05:52:35 <maerwald> GHC.IO.Exception
05:52:42 <Philonous> Hmm, fair enough
05:52:45 <Philonous> Thanks
05:52:56 <paolino> lyxia, I make an example, I did not explain well
05:53:14 <maerwald> Philonous: check out https://github.com/dan-t/hsimport
05:53:22 <maerwald> there is a vim plugin
05:54:12 <Philonous> Interesting, thanks
06:06:41 <paolino> lyxia, http://lpaste.net/162466
06:07:44 * hackagebot htoml 0.2.0.0 - Parser for TOML files  https://hackage.haskell.org/package/htoml-0.2.0.0 (cies)
06:08:50 <lyxia> paolino: well apart from the duplicate instances I'm not sure I see a problem
06:09:10 <paolino> that's what I'd like to resolve
06:10:55 <lyxia> Can you explain the purpose of such a thing
06:11:12 <lyxia> I don't understand your intent with this.
06:11:27 <paolino> select different instances from different constraints
06:12:25 <lyxia> what if you have both a Num and a Monoid?
06:13:06 <paolino> ok, they arenot exclusive
06:14:48 <paolino> so they are not reifyable to types and cannot be used for instance selection
06:15:04 <lyxia> there's a package ifcxt that allows you to write "if" on constraints, but it's really a hack
06:15:37 <paolino> no, I'm not looking for a hack
06:16:50 <paolino> I was looking of a generic technic to reformulate
06:18:33 <lyxia> If you want to use (+) and (*) as monoid operations there's Sum and Product
06:21:31 <dredozubov> i've heard that Semigroup is in base now
06:21:39 <dredozubov> i wonder if it'll be a superclass of Monoid
06:22:11 <geekosaur> I think that's planned for later
06:29:58 <thomie> dredozubov: see also the new -Wsemigroup warning flag. https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html#ghc-flag--Wsemigroup
06:31:15 <paolino> lyxia, I pass around higher order functions and avoid typeclasses, thanks for looking
06:31:41 <sphinxo> How should I implement pattern matching for my interpreter?
06:32:20 <Rembane> sphinxo: Do you want your language to have pattern matching?
06:32:34 <sphinxo> Rembane: Preferably :)
06:34:08 <Rembane> sphinxo: Ah.
06:34:13 <sphinxo> Rembane: why might I not?
06:34:20 <sphinxo> ( except for increased complexity )
06:35:31 <dredozubov> thomie: nice!
06:35:34 <Rembane> sphinxo: I don't know, I just needed to ask a question to confirm that I had understood your question. :)
06:35:53 <dredozubov> it looks like it's a green light for a deprecation cycle
06:37:21 <Rembane> sphinxo: Naively, by defining a data type for what you want to be able pattern match on and then go from there.
06:37:45 <Rembane> sphinxo: My google fu only gives me strange results. :D (like this: https://www.cs.cornell.edu/courses/cs312/2005sp/lectures/lec17.asp )
06:37:45 * hackagebot hedis 0.8.3 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.8.3 (k_bx)
06:38:03 <sphinxo> ok - thanks
06:39:33 <oeuvre> hey hulk{-_-} 
06:39:34 <oeuvre> how goes
06:40:03 <hulk{-_-}> oeuvre: Hello, didn't expect you here.
06:40:16 <oeuvre> hulk{-_-}: what's new buddy
06:41:00 <hulk{-_-}> Catching network exceptions, failures and other unexpected occurences.
06:42:08 <Rembane> sphinxo: No worries, hopefully somebody who has implemented pattern matching in a language and knows how this works shows up. :)
06:51:03 <navaro> Hello guys, I have a question - is there a function like fold that gives access to "tail" of each step?
06:51:50 <navaro> sth like superfold (\accumulator val tail -> undefined) someStartingValue Foldable
06:52:46 * hackagebot http-conduit 2.1.10.1 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.1.10.1 (MichaelSnoyman)
06:54:06 <oeuvre> that is cool hulk{-_-} 
06:56:39 <hulk{-_-}> Does yesod devel work on windows?
06:58:46 <lyxia> navaro: foldl (\acc (val : tail) -> ...) acc0 . tails ?
06:59:28 <lyxia> oh not quite, you need to pattern match on the tails because the last one is empty
06:59:41 <lyxia> navaro: foldl (\acc (val : tail) -> ...) acc0 . init . tails
07:00:02 <fatex> What is a good resource for implementing something like minikanren in Haskell?
07:00:21 <fatex> I want to grok logic programming, and it seems that I can best do that by writing an interpreter so I can understand how the machine woirks.
07:00:27 <maerwald> navaro: just implement it with explicit recursion, it's pretty simple
07:02:46 * hackagebot hw-conduit 0.0.0.10 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-conduit-0.0.0.10 (haskellworks)
07:02:48 * hackagebot hw-succinct 0.0.0.13 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.13 (haskellworks)
07:04:10 <humanoyd> Is there a more idiomatic way for this: `if cond then [alwaysPresent, conditionallyPresent] else [alwaysPresent]` ?
07:04:58 <maerwald> navaro: like this you mean? http://lpaste.net/162469
07:05:35 <navaro> yes :)
07:05:44 <navaro> maerwald: yes
07:05:56 <navaro> just wondering if there something already implemented in prelude or sth
07:06:04 <maerwald> haven't seen something like that
07:08:09 <Hijiri> It's probably in recursion-schemes
07:08:51 <lyxia> humanoyd: I like [alwaysPresent] ++ [conditionallyPresent | cond]
07:09:36 <dredozubov> i find [conditionallyPresent | cond] syntax confusing
07:09:44 <dredozubov> i have to scratch my head each time i see it
07:10:33 <Rembane> It looks bayesian
07:11:19 <hpc> it's more like set syntax in math
07:11:44 <maerwald> it should be removed, we have do-notation
07:12:00 <maerwald> which is more general
07:12:19 <dredozubov> maerwald: yep
07:15:12 <lyxia> ok fine. conditionallypresent <$ guard cond
07:15:25 <lyxia> does that even work
07:16:19 <lyxia> > fmap (\ b -> () <$ guard b) [True, False]
07:16:21 <lambdabot>      No instance for (Show (f0 ()))
07:16:21 <lambdabot>        arising from a use of ‘show_M188245872290605982226744’
07:16:21 <lambdabot>      The type variable ‘f0’ is ambiguous
07:16:27 <lyxia> > fmap (\ b -> () <$ guard b) [True, False] :: [[()]]
07:16:29 <lambdabot>  [[()],[]]
07:28:29 <humanoyd> lyxia: Thx, so would it be something like `concat [return alwaysPresent, conditionallyPresent <$ guard cond]` ?
07:30:31 <lyxia> I'm not a fan of concat here but that's more of a matter of taste at this point. always : (conditionally <$ guard cond)
07:33:34 <humanoyd> yeah, that looks cleaner, thx
07:37:47 * hackagebot alea 0.5.0.0 - a diceware passphrase generator  https://hackage.haskell.org/package/alea-0.5.0.0 (rnhmjoj)
08:00:44 <bru_> Hello. Is there any spanish Haskell IRC?
08:04:54 <sm> bru_: good question, I don't think so
08:05:35 <sm> time to start it ?
08:05:46 <bru_> Ok...
08:13:52 <MichaelK> Hi, is there a workaround to use the rule pragma for pattern matching on overloaded strings?
08:15:06 <MichaelK> i.e. `f :: Text -> Bool`, `f "true" = True`, `{-# RULES "test" f "true" = True #-}
08:34:12 <mpickering> are there an laws which say how profunctor and category instances should interact with each other?
08:38:31 <mpickering> It seems like we should be able to prove stuff like - rmap f C.id . h = rmap f h  
08:47:59 <Shou> How do I link to a typeclass with Haddock? 'M.Typeclass' tries #v:Typeclass instead of #t:Typeclass
08:48:00 <lingxiao> hey all
08:48:02 <lingxiao> is anyone doing haskell's summer of code here?
08:56:11 <hulk{-_-}> How does one search the version of a package they have on stack?
08:57:58 * hackagebot protobuf-simple 0.1.0.0 - Simple Protocol Buffers library (proto2)  https://hackage.haskell.org/package/protobuf-simple-0.1.0.0 (mrijkeboer)
08:58:45 <hulk{-_-}> Like stack ghc-pkg
09:10:18 <sm> hulk{-_-}: do you mean in your current project's stack config ? stack exec -- ghc-pkg list ...
09:11:40 <sm> or, alias stack-pkg="stack exec -- ghc-pkg"; alias stack-list="stack-pkg list"
09:13:43 <nitrix> "The monomorphism restriction is probably the most annoying and controversial feature of Haskell's type system."
09:13:51 <nitrix> Well, looks like I've hit the bottom.
09:14:05 <nitrix> Gotta learn thigs, then things will only get better from now on ;-;
09:17:59 * hackagebot rosa 0.3.0.0 - Query the namecoin blockchain  https://hackage.haskell.org/package/rosa-0.3.0.0 (rnhmjoj)
09:20:29 <TipTop> i try to understand this basic HTK code
09:20:38 <TipTop> i am a newbie in haskell
09:20:50 <TipTop> so i do not understand the count() definition
09:20:59 <TipTop> can anybody help?
09:21:04 <TipTop> (the code is here http://pastebin.com/JJufLG0M )
09:22:13 <nitrix> f4 = show
09:22:24 <nitrix> The type of `f4` is :: () -> String ?
09:22:37 <nitrix> I'm reading the wiki about monomorphism restriction, I'm a little baffled.
09:23:11 <sm> http://www.informatik.uni-bremen.de/htk, nifty
09:23:55 <TipTop> sm: do you understand the count() definition in this code?
09:24:12 <sm> no
09:25:21 <sm> >>> is the arrow operator, https://www.google.com/search?q=haskell+arrow&gws_rd=ssl
09:28:56 <sm> TipTop: can you get native look and feel with Tk ?
09:29:33 <Guest93494> does anyone know why zip-conduit's getSource is deprecated?  I'm finding it hard to use sourceEntry, as turning my "sink" into a real Conduit Sink is painful, but sourceEntry requires one.
09:30:10 <lyxia> nitrix: the type of f4 is Show a => a -> String. But because of monomorphism restriction, it will be specialized by looking at its usage elsewhere in the program.
09:30:31 <Guest93494> on the other hand it's easy for me to use the Source provided by getSource and consume it in my "sink" - but I'd rather not use a deprecated routine
09:30:52 <nitrix> lyxia: It's not used anywhere elsewhere in the program yet, and even if it was, I think it'd still have that type, due to monomorphism restriction?
09:31:03 <sm> seems like http://hackage.haskell.org/package/uni-htk would be a useful addition to the Haskell GUI story, with more maintainers and screenshots
09:31:35 <TipTop> sm: no idea. running the code on ubuntu 12 displays something so simple that it is hard to be sure it follows the current gtk theme or not.
09:31:56 <lyxia> nitrix: I just tried it and it doesn't default anything, so you get an ambiguous type error.
09:32:28 <geekosaur> Tk generally does something resembling ancient Motif without a resouce file
09:32:35 <nitrix> lyxia: That's monomorphism restriction in effect.
09:32:39 <geekosaur> (oddly colored and uuuuuugly)
09:33:00 * hackagebot alea 0.5.1.0 - a diceware passphrase generator  https://hackage.haskell.org/package/alea-0.5.1.0 (rnhmjoj)
09:33:02 <lyxia> nitrix: Monomorphism restriction prevents it from being polymorphic. It doesn't restrict what it will be specialized as.
09:33:08 <RedNifre> Hi.
09:33:16 <RedNifre> I forgot, how do I define something in lambdabot and ask it for a type?
09:33:30 <lyxia> nitrix: I don't know where you got the idea that f4 would be () -> String
09:33:47 <monochrom> you can say "@type \x y -> y x x" for example
09:33:51 <nitrix> pyon is being incredibly helpful to help me figure this out in parallel so your help might not be necessary after all.
09:33:54 <nitrix> lyxia: ^
09:34:15 <nitrix> lyxia: From the haskell report, the wiki and GHC threads.
09:34:33 <nitrix> But I can ignore those atm.
09:34:47 <RedNifre> How do I tell lambdabot to define something again?
09:35:44 <RedNifre> :let justGuessing = 4
09:36:08 <bernalex> @let justGuessing = 4
09:36:09 <lambdabot>  Defined.
09:36:20 <bernalex> :t justGuessing
09:36:22 <lambdabot> Num a => a
09:36:29 <bernalex> RedNifre: you don't need to define it though
09:36:37 <bernalex> :t 4 -- is the same thing
09:36:38 <lambdabot> Num a => a
09:36:50 <RedNifre> @let strange a b = a + b
09:36:52 <lambdabot>  Defined.
09:36:53 <RedNifre> :t strange
09:36:54 <lambdabot> Num a => a -> a -> a
09:37:00 <RedNifre> @let strange = (+)
09:37:01 <lambdabot>  .L.hs:179:1:
09:37:01 <lambdabot>      Multiple declarations of ‘strange’
09:37:01 <lambdabot>      Declared at: .L.hs:170:1
09:37:12 <RedNifre> @let strange2 = (+)
09:37:13 <lambdabot>  Defined.
09:37:15 <RedNifre> :t strange2
09:37:16 <lambdabot> Num a => a -> a -> a
09:37:21 <RedNifre> Huh.
09:38:10 <RedNifre> When I try that in ghci I get Integer -> Integer -> Integer
09:38:18 <shachaf> The thing you're talking about is called the monomorphism restrciction, and you can read about it on the wiki.
09:38:37 <RedNifre> Thanks, I will. Why doesn't it apply for lambdabot though?
09:38:43 <bernalex> shachaf: that should not be a thing (by default) in ghci any longer
09:38:55 <shachaf> Because it can be turned off.
09:38:56 <bernalex> I just did let f = (+); :t f; in ghci, and it says Num a.
09:39:07 <bernalex> I think it is off by default now.
09:39:30 <RedNifre> I might have an old version of Haskell here.
09:40:00 <bernalex> RedNifre: check 'ghc -V'
09:40:31 <RedNifre> Oh, wow, the wiki uses EXACTLY the same piece of code that I wrote when I first ran into this.
09:40:46 <RedNifre> I have version 7.6.3
09:41:44 <bernalex> OK. I think they changed it in 7.8. check the wiki article for what the "problem" is.
09:42:03 <shachaf> This feature has been around for a long time.
09:42:26 <RedNifre> Thanks, the wiki articles answered all my questions.
09:46:11 <nitrix> Is there an offline version of the wiki?
09:47:43 <infinity0> try "torsocks wget -r -p -np --mirror"
09:50:40 <Profpatsch> How would I split a string on a char?
09:51:25 <Profpatsch> "abbacca" = ["bb", "cc"]
09:51:55 <Zemyla> So what happens if a C function calls a Haskell function, which throws an error?
09:51:59 <Profpatsch> The „easiest“ I’ve found would involve unfoldr and span
09:54:57 <Guest93494> Profpatsch: maybe Data.List.splitOn
09:56:17 <rene25> hi
09:56:25 <glguy> Zemyla: the program terminates
09:56:45 <glguy> Zemyla: (unless you catch the exception)
09:56:45 <Zemyla> glguy: There's no way to catch it beforehand?
09:57:07 <Zemyla> I mean after it's left the C function.
09:57:40 <rene25> i have a question, how to create an UArray, i wrote import qualified Data.Array.UArray as A  and next A.UArray (1,100) ... and it says : Not in scope: data constructor `A.Uarray'
09:59:10 <glguy> Zemyla: I don't understand your question, then.
10:00:01 <Zemyla> Can I do catch (cfunc haskellfunptr) handler?
10:00:28 <glguy> The Haskell exceptions aren't propagated through the FFI
10:01:02 <glguy> so you'd handle them in the exported Haskell function. If you want to you could propagate the error through the FFI via a return code or some other convention you define
10:04:27 <lyxia> rene25: you must use functions here to construct arrays > http://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array-IArray.html#g:3
10:04:27 <Guest93494> does anyone know why zip-conduit's getSource is deprecated?  I'm finding it hard to use sourceEntry, as turning my "sink" into a real Conduit Sink is painful, but sourceEntry requires one.
10:04:28 <Guest93494> on the other hand it's easy for me to use the Source provided by getSource and consume it in my "sink" - but I'd rather not use a deprecated routine
10:06:26 <fr33domlover> Guest93494, email the maintainer
10:07:20 <Guest93494> fair enough
10:10:45 <Profpatsch> ah, I’m so dumb.
10:10:56 <Profpatsch> words. of course.
10:12:19 <bernalex> Profpatsch: words does not take a delimiter.
10:13:07 * hackagebot eternal 0.1.4 - everything breaking the Fairbairn threshold  https://hackage.haskell.org/package/eternal-0.1.4 (Heather)
10:13:11 <Profpatsch> bernalex: You are right, but that’s actually what I wanted.
10:13:21 <bernalex> then you are in luck. :)
10:17:47 <lpaste> glguy pasted “error in foreign exports” at http://lpaste.net/162478
10:17:58 <glguy> Zemyla: for example
10:23:19 <bblfish> I was watching the Silicon Valley series yesterday and it occurred to me that  Richard Hendricks - the founder of Pied Piper - must have written his code in Haskell. It would make a lot of sense that anyone who just tried to quickly copy his ideas would find it nearly impossible to do very quickly, as they'd first have to learn Category Theory. Especially if he then used advanced features like CoMonads... It would kind
10:23:19 <bblfish>  of make sense. When I was at Imperial 20 years ago we did a course on CT and one of the applications was to write a fractal application, that would calculate only the exact amount needed for the screen resolution.
10:23:45 <bblfish> has anyone thought of calling the team of that Series and suggesting they show some advanced Haskell on the screen?
10:26:10 <kadoban> bblfish: Category theory is *far* from a prerequisite to learning haskell.
10:26:37 <kadoban> As far as I know, there's no teaching materials available that even recommend you learn it.
10:26:46 <hpc> if anything, it's a little bit the other way around
10:27:00 <hpc> learning haskell being a decent lead-in to CT in some ways
10:27:06 <bblfish> I have never seen so much CT concepts since I looked at Haskell or scalaz
10:27:08 <hpc> (though it's still very different)
10:27:19 <bblfish> And I think it has done me good :-)
10:27:38 <hpc> learning haskell via CT is only going to leave you with a bunch of "this is how haskell isn't CT" exceptions
10:27:55 <hpc> if you can understand CT well enough to translate it over to begin with
10:28:48 <simpson> bblfish: There's sufficient clues left around to piece together that most of Pied Piper is Ruby.
10:29:07 <bblfish> but that would make my point. It could be that the founder of Pied Piper knows CT and Hakell, but his co-workers don't. So when they try to understand the more advanced concepts, they find themselves pointed to articles on important constructs that he needed to make his compression algorithm efficient, but that just can't be learnt over night :-)
10:29:39 <bblfish> I think the shell scripts are Ruby. The real code should be Haskell.
10:29:48 <simpson> bblfish: But Haskell isn't magic. It's just another language.
10:30:01 <kadoban> The advanced concepts of haskell don't require category theory either.
10:30:48 <locallycompact> Even the basics of haskell are lost on me without CT tbh
10:30:48 <bblfish> Come on. I have been reading about monads, co-monads, adjuncts, monoid mutliplication and addition for the past week :-)
10:31:17 <monochrom> I was learning induction recently.
10:31:25 <speedcell4> monads is so hard
10:31:45 <monochrom> Haskell made me rethink the nature of natural numbers.
10:31:50 <bblfish> It's true I did use Free Monads to good effect a year ago without understanding all of it that well. But I thought it would probably help to get a better understanding.
10:31:52 <hpc> speedcell4: have you learned Functor and Applicative?
10:32:04 <glguy> monochrom: What did you come up with?
10:32:20 <speedcell4> not yet
10:32:29 <monochrom> oh, I'm exaggerating. I was studying "forall r. r -> (r -> r) -> r".
10:32:48 <hpc> speedcell4: learn Functor first, then Applicative
10:33:08 <hpc> speedcell4: Functor isn't too terrible, but get quite comfortable with Applicative before moving on
10:33:17 <bblfish> I think I am at the point now where I understand adjunctions...
10:33:36 <hpc> while not explicit (though it soon will be), Monad depends on Applicative
10:33:37 <monochrom> It annoyed me (not anymore now) because I knew how to write down induction for "data N = Z | S N", but I didn't know how to write one for "forall r. r -> (r -> r) -> r"
10:33:50 <Gurkenglas__> Does the assertion "undefined = const undefined" imply some confusion in the speaker?
10:33:51 <hpc> and there's a much smoother logical build-up of concepts when you follow that order
10:34:07 <Gurkenglas__> *"undefined == const undefined"
10:34:16 <speedcell4> hpc: thanks, so is there some recommended books or blogs?
10:34:46 <Gurkenglas__> Argh, it's supposed to be neither definition nor the name provided by Eq
10:34:52 <hpc> speedcell4: just the usual tutorials and whatnot, which should be following that order anyway
10:35:06 <monochrom> Eventually I followed my hunch and saw what parametricity (free theorems) says for this. It was great, it gave me more than induction.
10:35:12 <Gurkenglas__> "Can I say that the function undefined maps everything to undefined"?
10:35:17 <Gurkenglas__> -""
10:35:17 <hpc> modulo a brief peek ad Monad just to be able to do IO, if they handle it clumsily
10:35:50 <hpc> Gurkenglas__: in some ways that assertion is true
10:36:04 <hpc> Gurkenglas__: you can only distinguish between undefined and \_ -> undefined in the presence of seq
10:36:08 <hpc> which gets ignored as convenient
10:36:17 <bblfish> It's actually quite easy to use monads funnily enough. But to understand the theory behind them takes a lot more time. And I feel that it is useful at some point to go beyond the simple usages of Monads.
10:36:40 <hpc> yeah
10:37:08 <hpc> there's a safe early lie to be had, just to get someone using IO (which is a major step for motivation to continue if nothing else)
10:37:12 <kadoban> bblfish: I never bothered with any of the theory, and I do fine with every Monad I've looked at. From what I understand, they're not even monads from CT, so I'm not sure what theory would be helpful enough to actually learn.
10:37:44 <hpc> then do a better explanation after you have the foundational concepts to understand the definition and instances
10:38:18 <hpc> everything CT in haskell happens in the category Hask
10:38:50 <bblfish> kadoban it may be that by using Haskell you're actually have a good entry into CT, so that you have aquired the concepts just by reading code.
10:39:07 <monochrom> anyway, I was looking at all these "Haskell caused me to learn CT" comments, and I just wanted to bring it to a whole new level by "Haskell caused me to learn the natural numbers".
10:39:08 <hpc> which is ultimately a funny way of saying "it has to deal with the imperfections of (->)"
10:39:12 <kadoban> I highly doubt it. I have no idea what people are talking about in CT even now.
10:39:22 <hpc> haskell caused me to learn java
10:39:28 <kadoban> hpc: lol
10:39:31 <ski> hpc : "everything CT in haskell happens in the category Hask" -- not sure i can agree
10:39:34 <bblfish> hpc: lol
10:39:40 <johnw> ski: yeah, I was just typing that too
10:39:59 <hpc> well, a lot of things anyway
10:40:11 <johnw> ski: Hask^op was the first thing that came to mind, and then there are the object in the monoidal category over Hask endofunctors, etc.
10:40:15 <bblfish> I started with Java, then I came to Scala and now I am looking at Hask to understand these concepts, because so many articles are written in haskell.
10:40:47 <hpc> actually this one is serious, haskell made me very good at perl
10:40:55 <ski> johnw : i was thinking about stuff of kind `(* -> *) -> (* -> *)'
10:41:03 <hpc> in some ways perl is a better language for FP than haskell
10:41:05 <ski> and `(* -> *) -> *', and so on
10:41:27 <bblfish> hpc Nah! No way. That can't be possible
10:41:37 <kadoban> hpc: :-/
10:41:47 <hpc> haskell is a better imperative language than perl though ;)
10:41:51 <kadoban> Oh you said "some", that's pretty possible, every language has strengths.
10:42:07 <kadoban> Well … most of them do anyway.
10:42:15 <hpc> perl's strength is in capturing the unrelenting absence of types in untyped lambda calculus
10:42:27 <hpc> plus adding some ridiculousness opportunities of its own via list flattening
10:42:42 <hpc> and having scoping that isn't absolute pants like js
10:42:49 <dolio> I'm not sure perl is much like the untyped lambda calculus.
10:42:53 <hpc> and having first-class functions that aren't horridly onerous to type
10:43:11 <hpc> dolio: it's closer than haskell anyway
10:43:20 <hpc> you can write the traditional fix in it
10:43:53 <hpc> where haskell becomes better at imperative programming is first-class IO
10:44:12 <bblfish> that's just nonsense. If I search through the libraries, 90% of the concepts are from CT I'd say. I have never seen them in Perl, or Java. They only appeared on my horizon in Scala.
10:44:17 <kadoban> I like javascript's scoping, mostly xD
10:44:38 <bblfish> 90% of Haskell libraries I meant
10:44:45 <hpc> kadoban: you probably also end every line with a semicolon too
10:44:46 <dolio> 90% is very high, unless you're looking at a particular cross section of libraries.
10:44:53 <kadoban> hpc: Yes
10:44:56 <hpc> kadoban: there's whole unplumbed depths of language you haven't seen
10:45:10 <bblfish> just take IO, which is probably the most important one. That's a Monad.
10:45:15 <kadoban> Oh, well yeah, I only use JS as it should be, not as it … can be when you're insane.
10:45:32 <hpc> IO is only an instance of Monad because that api happens to fit
10:45:42 <bblfish> then there are functors all over the place :-) Nothing wrong with that. I find it actually refreshing to be learning something intelligent while coding.
10:45:43 <monochrom> I think 100% of the libraries use CT concepts.
10:45:46 <hpc> iirc there's even debate on if IO obeys all the laws
10:46:13 <monochrom> Proof: they use either types (which are objects) or functions (which are arrows). or both. XD
10:46:14 <dolio> monochrom: I mean, they all use functions in Haskell. And functions are exponentials in category theory.
10:46:30 <hpc> bblfish: er, i meant to finish that line with, i don't think you can really count instances or else you could even call arrays a CT library
10:46:45 <aarvar> bblfish: it's misleading to say IO is a monad
10:46:54 <aarvar> it has a monad instance, but so does list
10:47:03 <bblfish> IT may be misleading, but I bet it's in the library :-)
10:47:05 <monochrom> I think I can further increase that to 110%. Because some libraries are not on hackage.
10:47:06 <hpc> "IO is a type", "IO is an instance of Monad"
10:47:08 <aarvar> is any code using lists now category theoretic?
10:47:21 <Cale> I don't think it's misleading
10:47:24 <hpc> acme-php uses CT
10:47:30 <mnoonan> monochrom: I was going to contradict you with Acme.Empty, but it has a value of type IO () after all :)
10:47:42 <monochrom> \∩/
10:47:55 <mnoonan> er, Acme.Box I suppose
10:48:03 <jophish> @tell wrengr_away Would you accept a patch deriving Data.Data.Data for IntVar and UTerm in unification-fd?
10:48:03 <lambdabot> Consider it noted.
10:48:17 <Cale> IO is indeed a monad on the category of Haskell types, as is the type constructor for lists.
10:48:27 <bblfish> If I look at the IO page http://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html I see Monad, Functor MonadFix and Applicative
10:49:01 <Cale> What's misleading is when you *know* you're working with an IO action or working with a list, and you spuriously focus on the fact that it's a monad in cases where you're not actually using that fact.
10:49:09 <aarvar> Cale: only if you think of IO as not just a type constructor, but also the set of all its instances
10:49:11 <hpc> otoh, you can use IO quite effectively without ever seeing "return", ">>=", or "Monad"
10:49:17 <Cale> aarvar: hm?
10:49:46 <aarvar> Cale: if we disregard the existence of type classes for a moment, IO is just a type constructor
10:49:48 <dolio> It's somewhat misleading to say that IO is a 'concept from category theory'.
10:50:01 <aarvar> the triple (IO, ioBind, ioReturn) is a monad
10:50:28 <Cale> Right, IO isn't a concept from category theory, Monad is. IO happens to be an example of a monad, but it didn't come from CT.
10:50:29 <hpc> @quote prepromorph
10:50:29 <lambdabot> kms_ says: in C++ a for loop is magical built-in syntax.  in haskell we can define zygohystomorphic prepromorphisms in a library
10:50:41 <hpc> that's what IO is ;)
10:50:42 <bblfish> It's perhaps not a concept from category theory, but the doc mentions concepts from CT.
10:51:25 <monochrom> wait, IO is a zygohystomorphic prepromorphism?!
10:51:26 <Cale> bblfish: Well, we've stolen some ideas from CT, and squished them down so that they'll fit in Haskell.
10:51:33 <aarvar> Cale: consider "String is a monoid"
10:51:40 <speedcell4> what is zygohystomorphic
10:51:40 <hpc> monochrom: no, but how would you know without CT!
10:51:42 <bblfish> which I think is the only language I have yet encountered where it's so deep in the language. So yes, one can use it without deep understanding of CT, but over time one gets to be intruiged...
10:51:50 <Cale> aarvar: Yep, I actually made *heavy* use of that fact in a recent library :)
10:51:57 <monochrom> I know nothing
10:51:59 <aarvar> that phrase only makes sense if you have type classes
10:52:02 <Cale> http://hackage.haskell.org/package/category-printf
10:52:08 <Cale> ^^ check that out :)
10:52:12 <monochrom> Like I said, I found that I didn't even know induction. :)
10:52:19 <dolio> hpc: 'zygo' 'histo' stuff isn't really category theory.
10:52:20 <aarvar> if we consider just the string type and ignore its instances, String isn't a monoid
10:52:33 <aarvar> there are many monoids we could define for String, but String itself isn't a monoid
10:52:45 <Cale> aarvar: Sure -- String is only a monoid by virtue of the fact that we've specified an identity element and multiplication on strings.
10:52:47 <monochrom> When you think that you know everything, you can get a Bachelor's degree.
10:52:48 <hpc> IO uses CT in the same way StateT uses functional dependencies
10:53:02 <monochrom> When you find out that you know nothing, you can get a Master's degree.
10:53:03 <Cale> aarvar: But it *is* a monoid, given that we have done so.
10:53:09 * hackagebot protobuf-simple 0.1.0.1 - Simple Protocol Buffers library (proto2)  https://hackage.haskell.org/package/protobuf-simple-0.1.0.1 (mrijkeboer)
10:53:16 <aarvar> Cale: I think the use of the "is a" terminology causes confusion for people not familiar with type classes is all
10:53:28 <monochrom> And when you finally find out that your thesis supervisor know nothing too, you can get a PhD
10:54:00 <kadoban> monochrom: Hah
10:54:17 <Cale> aarvar: Maybe, but type classes should be one of the first things you get introduced to.
10:54:22 <monochrom> My own experience is that they are partly true.
10:54:31 <aarvar> and when you say things like "Maybe is a monad" then people think they're using monads every time they use Maybe
10:54:56 <monochrom> Because when I finished my MSc, I certainly felt that I knew nothing but my supervisor knew everything.
10:55:02 <bblfish> aarvar is that not true?
10:55:09 <Cale> aarvar: I totally agree with you that it's inaccurate to say that you're using monads
10:55:27 <Cale> You're using one thing which happens to be a monad, and you may or may not be exploiting that fact.
10:55:53 <monochrom> And after that, halfway towards my PhD, my supervisor also admitted to not knowing a lot of things, things that I learned on my own and then asked him for more guidance.
10:55:58 <aarvar> I think it's better to avoid the "is a" terminology all together
10:56:03 <Cale> The point at which it becomes interesting or valuable to talk about monads is the point at which you write or use code which works for all of them.
10:56:04 <aarvar> and say that Maybe *has* a monad
10:56:23 <hpc> if there's going to be any "is a" relation in haskell, the only thing it can sanely refer to is "has type of"
10:56:26 <aarvar> bblfish: is what not true?
10:56:27 <Cale> aarvar: Yeah, but it can only have one monad instance, so that's perhaps even more misleading.
10:56:46 <Cale> It is a monad in exactly one canonical way.
10:56:58 <bblfish> aarvar you answered my question. following with interest.
10:56:59 <hpc> there's no "a monad" imo
10:57:01 <aarvar> Cale: yes, but I think that's lost on some people since it's quite specific to haskell
10:57:04 <monochrom> Clearly, IO is a * -> *
10:57:09 <hpc> only instances of Monad
10:57:25 <hpc> monochrom: honestly, yes
10:57:27 <Cale> aarvar: Well, even if it's not strictly true in mathematics, it's also how people speak in the literature.
10:57:49 <aarvar> Cale: which is fine, if you're familiar with what it means
10:57:51 <Cale> aarvar: A functor T that has been equipped with a unit and multiplication is a monad.
10:58:24 <Cale> and you'll see "the monad T" rather than "the monad (T, eta, mu)" quite frequently
10:58:35 <aarvar> sure
10:58:39 <dolio> Just like they do with monoids.
10:58:46 <hpc> Cale: that's my major stumbling block to getting into CT
10:58:47 <Cale> This is because usually you're not fighting to deal with more than one monad structure on the same functor
10:58:49 <dolio> And rings, and ...
10:59:22 <aarvar> Cale: sure, but it's a convention which could cause confusion to someone not familiar with it is all
10:59:24 <maerwald> Cale: how interesting would that be... if it was possible in haskell :D
10:59:30 <Cale> So once it's been specified what that eta and mu are, if you know which T you're using, you know it's the ones which were defined for T.
11:00:10 <bblfish> CT is pretty weird I must admit.  I mean it says essentially that there is a similarity between lists, numbers and addtion, numbers and multiplication, IO, etc... 
11:00:34 <aarvar> bblfish: what's weird about it
11:00:41 <Cale> aarvar: I dunno, do you think perhaps we just need to do a better job of describing type classes? Because this isn't something that I would normally regard as a sticking point. People seem to have no trouble with it in the case of, say, Ord
11:00:47 <Cale> Or Num
11:01:03 <aarvar> Cale: I think you're right that it's specific to Monad
11:01:32 <Cale> I don't think it's even quite the problem
11:01:36 <aarvar> I think it's because people often say "the maybe monad" when they really just mean Maybe
11:01:39 <aarvar> etc
11:01:40 <bblfish> aarvar:  It's weird but I am getting used to it :-) I think it's a bit like guiness or club mate: you get used to it.
11:01:44 <Cale> Yes, *that* is the problem
11:01:45 <aarvar> while they don't say "the Int Ord"
11:01:49 <Cale> Right.
11:02:17 <hpc> i think it has to do with Monad being in some ways a really invasive API
11:02:29 <Cale> It was fashionable for quite a while to say "the Blah monad", which puts way too much emphasis in many situations on the fact that Blah is a monad.
11:02:57 <Cale> Of course, if you're discussing how you're using the fact that it's a monad, that sort of phrase is just fine.
11:03:01 <montanonic> bblfish: Scala was the first language I used, and it got me interested in Haskell.
11:03:06 <aarvar> right
11:03:11 <Cale> But I tend to say "the IO type" instead at first now
11:03:24 <aarvar> so, reserve the phrase "the Foo monad" for talking about the monad instance
11:03:28 <Cale> yeah
11:03:40 <bblfish> For example before getting into this space, I would never have thought of comparing monoid addition and monoid multiplication as I recently did with http://blog.higher-order.com/blog/2014/03/19/monoid-morphisms-products-coproducts/
11:03:43 <hpc> even then, say "the Monad instance for Foo"
11:03:51 <Cale> I think it's fine to say that "Foo is a monad"
11:03:57 <aarvar> if you say that Foo has a monad, rather than is a monad, than it's impossible to make that mistake
11:04:04 <Cale> if that's a salient property which you're discussing
11:04:16 <aarvar> *then
11:04:17 <hpc> aarvar: that just begs the question of what a monad is again
11:04:21 <Cale> "Foo has a monad" just sounds wrong to me though
11:04:37 <bernalex> I agree with Cale.
11:04:38 <hpc> "Foo has a Monad instance"
11:04:39 <Cale> That sounds like you're talking about something related to Foo which happens to be a monad
11:04:50 <hpc> also it needs to be capitalized
11:04:52 <Cale> Like, some other type constructor obtained from Foo somehow
11:05:00 <hpc> if only to be specifically about the type class
11:05:01 <Cale> Foo itself is the monad
11:05:09 <aarvar> depends on what you think of Foo as
11:05:26 <maerwald> so people are debating half on hour over "has" vs "is" -.-
11:05:30 <Cale> Just like with the integers. The integers don't have a ring, they are a ring.
11:05:37 <bernalex> Cale: it's just that usually Foo is more interesting than the Foo monad.
11:05:41 <kadoban> Half an hour? More like half a minute.
11:05:41 <aarvar> "is a" only makes sense if you think of a type as a set of values, plus all of the instances indexed on the type
11:05:47 <aarvar> which is technically correct in haskell
11:06:04 <bernalex> saying that Foo has a monad is like saying that 3 has a number.
11:06:10 <Cale> aarvar: We're really stealing this language from mathematics, and using it the same way that mathematicians use it.
11:06:15 <aarvar> sure
11:06:21 <aarvar> maybe they use it wrong as well
11:06:31 <geekosaur> maerwald, use/mention distinction arguably has started wars, this surprises you?
11:06:34 <Cale> There's no right or wrong way. Only convention.
11:06:35 <hpc> aarvar: they did!
11:07:00 <hpc> aarvar: "13:58 < Cale> and you'll see "the monad T" rather than "the monad (T, eta, mu)" quite frequently" ;)
11:07:00 <Cale> Often just following convention is more valuable than any other difference in utility available between options.
11:07:27 <aarvar> I suppose
11:07:29 <bernalex> Cale: I'm not sure I agree. you can't just say that "3 has a number" and chalk it up to "it's my convention to say that". it's just weird.
11:07:46 <aarvar> you just have to be clear then that "Maybe" doesn't just refer to "data Maybe a = Just a | Nothing"
11:07:51 <hpc> that's not even a well-typed analogy
11:07:52 <aarvar> but also refers to all of its instances
11:07:54 <bernalex> if you want to, you could say that Foo admits a Monad.
11:07:56 <hpc> a better one is "Int has a Num"
11:07:58 <Cale> It means that when someone who is a Haskell programmer (note: not "has a haskell programmer") goes and looks in the literature, they're met with familiar turns of phrase 
11:08:03 <hpc> which... sounds worse
11:08:24 <bernalex> hpc: I'm not talking about Haskell. I'm talking about what "has" and "is" means. "number" is not a thing in Haskell.
11:08:47 <aarvar> or "has an instance", whatever
11:09:05 <monochrom> Aristotle: "what does it mean to be a monad?"  Descartes: "what does it mean to be?"  Nietzsche: "what does it mean?"  Russell: "what does 'it' mean?"  C. S. Lewis: "what does it?"  Lil John: "what?"  http://captionsearch.com/image.php?id=244
11:09:13 <Cale> bernalex: Right, this convention is what it is due to the properties of English, though that doesn't always stop us in mathematics from speaking in a weird stilted way that doesn't quite line up with ordinary English grammar :D
11:09:15 <bernalex> hpc: just like saying 'I mean that "number" has not a thing in Haskell' makes no sense.
11:09:28 <bernalex> Cale: I agree with your general point on convention, yeah.
11:10:05 <bernalex> Cale: like "a denotational semantics", even though "semantics" is supposed to be uncountable as a word.
11:10:13 <maerwald> geekosaur: what I find funny is that people discuss over such detailed distinction although there is no confusion anyway... 
11:10:27 <hpc> there is though
11:10:33 <hpc> otherwise we wouldn't have burrito jokes
11:10:41 <maerwald> I don't see how that is related
11:10:44 <Cale> maerwald: Well, this is really a discussion about pedagogy amongst people who all already know what they're talking about
11:10:57 <bernalex> pædagogy is incredibly important.
11:11:00 <aarvar> ^
11:11:14 <maerwald> usually, people just understand what you mean, no matter if you say "has a monad instance" or "is a monad" or whatever
11:11:19 <geekosaur> (and how much of it is also about the fact that the meaning of any given English phrase is about as stable as water?)
11:11:38 <maerwald> yeah, spoken language != formal language
11:11:39 <aarvar> maerwald: which people are these
11:11:49 <bernalex> yeah I'm gonna chuck a [citation needed] at that
11:11:56 <geekosaur> talking pedagogical math in a notoriously ambiguous and multivalued language, yep
11:12:00 <Cale> aarvar: Anyway, the really important thing is that people need to see enough examples of monads, and tutorials need to focus on the benefit which comes from defining the monad instance: all the polymorphic functions which work with an arbitrary choice of monad.
11:12:08 <maerwald> aarvar: the ones I talked to, pretty much all of them
11:12:38 <monochrom> no, students never understand what you mean. they just think they do. My experience: students learn "the empty set" and then "the empty string". they go on to say that the two are the same because "it's empty".
11:12:39 <bernalex> Cale: people need to see the problem that monads fixes.
11:13:00 <bernalex> *fix.
11:13:01 <monochrom> so nevermind how much effort you put into "is" and/or "has".
11:13:01 <aarvar> nothing is a maybe and maybe is a monad, therefore nothing is a monad
11:13:03 <Cale> I'm not even sure I'd go so far to say that monads even really fix a problem
11:13:15 <dolio> bernalex: No, fixes. :)
11:13:19 <bernalex> Cale: sure they do. it could have been fixed a different way though.
11:13:20 <aarvar> they fix the problem of code repetition
11:13:25 <aarvar> just like every other abstraction
11:13:29 <bernalex> dolio: not in BE. maybe in AE.
11:13:32 <Cale> We're just capturing a pattern that occurs across many libraries, and abstracting over it to save writing the same code multiple times
11:13:42 <dolio> No, I'm just wrong.
11:13:45 <Cale> Code for stuff like sequence and liftM2
11:13:46 <aarvar> just emphasize the fact that Monad is just like Ord or any other abstraction
11:13:55 <Cale> and mapM
11:13:58 <Cale> and so on
11:14:00 <maerwald> geekosaur: yeah, the point is you can be as precise as you might think about something... it's rarely going to make a newcomer understand better what you mean, because he is not into that terminology anyway, so the point is moot
11:14:05 <monochrom> students will hold your wording against you, and not recognize that names are meaningless, that it's the axioms that are meaningful.
11:14:18 <bernalex> Cale: monads, in haskell fix that awful shortcoming of c++ overloading -- you can't overload ';'. :)
11:14:21 <aarvar> anyway, gtg
11:14:34 <Cale> bernalex: But we don't need to know that something is a monad to actually do that
11:15:08 <hpc> maerwald: where do you draw the line about correctness mattering when teaching then?
11:15:11 <bernalex> Cale: sure, I agree. and you can make really great software without really understanding most of anything.
11:15:20 <maerwald> so I think this whole discussion is just an end in itself ;)
11:15:32 <Cale> bernalex: If we just deleted the monad type class, and instead, all the libraries which presently define an instance of Monad, instead just gave you a monomorphic return and (>>=) for their specific case, along with some randomly selected half of Control.Monad, things would be kind of okay
11:15:40 <bernalex> Cale: I do think it's useful to show that "we want to be able to do this" (in the case of monads, spare us some repetition) first, then "here's some examples", and then finally a deeper intuition.
11:15:47 <Cale> (probably even they wouldn't all give (>>=))
11:16:07 <maerwald> hpc: when teaching, I care about teaching. It matters who I am talking to. I might choose a completely different language depending on the audience.
11:16:12 <Cale> But it does kind of solve a problem with library uniformity, I suppose.
11:16:37 <bernalex> Cale: sure. but I maintain that you should show something that monads in a way "fix". even if you could have fixed it differently.
11:16:52 <Cale> But yeah, in any particular instance, there's nothing you can do with monad that you couldn't do without. The difference comes when you start writing code which will work across any choice of monad.
11:16:54 <aarvar> bernalex: what does Ord fix?
11:17:59 <jophish> I think maerwald has it right. It depends entirely on who the audience is
11:18:00 <Cale> We'd been writing combinator libraries for decades before Haskell was even around (let alone before the concept of a monad came to Haskell), which gave nice ways of joining simpler computations into more complex ones.
11:18:11 <bernalex> aarvar: it is useful to abstract over things that are totally ordered. it also saves you *a lot* of repetition since you can derive it, and it gives a bunch of functions for free. I could probably think of more things fixed by Ord if I wanted to. but I'm not about to teach anyone Ord, so it's quite limited how much effort I want to put into it.
11:18:25 <monochrom> Ord fixes the binary search problem
11:18:49 <Cale> If you watch the SICP lectures, or read the book, you'll even see one or two very direct examples of things which happen to be a monad and yet this fact goes unrecognised, and everything is okay
11:19:10 <monochrom> Num fixes the SML and OCaml +, .+., ..+.. etc problem
11:19:16 <Cale> heheheh
11:19:19 <kadoban> There's SICP lectures? What in MIT OCW?
11:19:23 <bernalex> Cale: I'm not sure where your argument is going. it sounds like "we should just get rid of monads who cares you don't need to know them"
11:19:37 <Cale> https://www.youtube.com/watch?v=2Op3QLzMgSY
11:19:57 <Cale> bernalex: I'm not saying that -- I'm saying that if all you have is one monad, then pointing out that it's a monad is pretty much worthless.
11:20:15 <bernalex> Cale: well nobody ever said otherwise iirc, so I'm not sure why you are arguing that. :)
11:20:23 <Cale> The value in recognising that anything is a monad comes entirely from the fact that there are many examples of them
11:20:52 <hiptobecubic> Bartosz Milewski likes to talk about the various missed opportunities for a monadic interface to C++ features
11:20:58 <Cale> Well I was sort of countering the point that monad solves the problem of how to have a programmable semicolon -- you can do that without the monad type class.
11:21:05 <bernalex> Cale: my argument was that you should give some examples of things that would be annoying to write without monads (or some other neat solution), and then show them some examples of things that are monads, and then let them write a simple monad thing, like for a wrapper type, and then finally they can start to think about the deeper intuition.
11:21:33 <bernalex> Cale: usually I just treat monads as an API, or more precisely as the >>= function.
11:21:40 <Cale> The thing that you can't do without Monad is write control structures which work with *any* programmable semicolon that someone else has defined
11:21:53 <bernalex> you could probably do that without monads
11:22:00 <Cale> yeah
11:22:03 <bernalex> you could probably do it in a very ad-hoc and unformal way
11:22:32 <maerwald> duck typing
11:22:38 <bernalex> I find that in general most of the typeclasses are vastly "overrated" in terms of how some people teach them
11:22:41 <Cale> You can always just define the functions and fail to notice that things happen to have a viable monad instance, and you'll solve all the same problems, but you'll waste a lot of time redefining the sequence function, and so on.
11:22:58 <dolio> You can't have a 'nice' syntax for all of them without some agreed on abstraction.
11:23:08 <hiptobecubic> Plus the bugs associated with defining it slightly wrong sometimes
11:23:09 <Cale> dolio: Yeah, there is do-notation
11:23:32 <dolio> Regardless of whether you can write functions that work on all of them.
11:24:04 <shachaf> Is it still a waste of time if you count all the extra time that you spend talking about monads?
11:24:08 <Cale> which is fair enough, but if Monad were *just* the syntactic sugar without the ability to write things with "(Monad m) => ..." in the type, I'm not sure it would be very worthwhile either
11:24:18 <Cale> shachaf: hahaha
11:24:22 <bernalex> IO is rather strange, since it's sticky, so I tend to talk about that type a bit more in-depth than the rest. but usually I just present typeclasses as neat APIs. I give some examples of stuff that would be a bore to write, then show how we can abstract them (be it functor, monad, whatever), then show a bunch of examples of those abstractions, then write some of them (like make our own List type and do it by
11:24:24 <bernalex> hand, and think of some unique things)... and then in the end intuition is kind of just something that comes along naturally.
11:24:53 <Cale> bernalex: The example which made it really click for me was parsing monads.
11:25:02 <dolio> Cale: Multiple other languages have exactly what you're talking about.
11:25:11 <dolio> So it is worthwhile.
11:25:46 <dolio> At least to some people.
11:26:07 <Cale> dolio: I suppose so!
11:26:08 <bblfish> It's good exercise for the mind.
11:26:46 <Cale> I suppose there's still some value in saying "this is a thing which we're going to look to provide across many of our libraries, whenever we can get it", even if you can't do the polymorphism part.
11:27:17 <Cale> But I still say it's not quite worthwhile as an idea until you really do get the polymorphism.
11:27:34 <dolio> Yes, certainly it's better if you can do polymorphism.
11:28:09 <bernalex> I've always wondered... are monads like Mexican burritos, tex-mex burritos, or just what the average American or European call burritos?
11:28:31 <hpc> they're actually like the wraps you get at panera
11:28:40 <kadoban> CA-style I usually picture
11:28:58 <maerwald> bernalex: you know... I've never eaten one in my life and the first time I heard about that thing ever was in a shitty monad tutorial. I had to look it up on wikipedia, lol.
11:29:17 <kadoban> You've never had a burrito? *boggle*
11:29:19 <maerwald> yes
11:29:32 <kadoban> You're missing out … they're pretty amazing.
11:29:39 <maerwald> I know doner though
11:30:26 <bernalex> kadoban: yeah CA style is what I've imagined too
11:30:52 <bernalex> now I'm hungry. luckily I'm making sweet potato & black bean enchilladas soon.
11:31:14 <kadoban> I just ate thankfully, otherwise this would be a bad conversation.
11:31:23 <monochrom> http://www.vex.net/~trebla/photo/unorganized/burrito-salad.jpg
11:31:56 <maerwald> that's a burrito transformer then?
11:32:12 <monochrom> hee hee
11:33:37 <hpc> texmex is definitely the best burrito though
11:33:52 <fatex> what is the easiest way in haskell to do Int -> Hex ?
11:33:57 <fatex> Hex represented as a String
11:34:05 <Cale> > showHex 43229 ""
11:34:06 <lambdabot>  "a8dd"
11:34:20 <bernalex> that's in Numeric fwiw
11:34:22 <hpc> heh, i was going to say printf but that's even easier
11:34:39 <Cale> heh, you could use my printf library ;)
11:35:14 <maerwald> printf in haskell is awkward, it's either unsafe, uses TH or has otherwise unnatural syntax
11:35:26 <bernalex> printf is an interesting hack
11:35:32 <bernalex> it's most usefully expressed with dependent types.
11:35:38 <Cale> maerwald: You didn't see my library? :D
11:35:44 <maerwald> bernalex: exactly
11:35:50 <Cale> You don't actually need dependent types!
11:35:51 <maerwald> but I feel that's sort of its showcase lol
11:36:05 <bernalex> Cale: is it typesafe and not ridiculous? link pls!
11:36:12 <dolio> Cale: You do if you want to actually be printf. :)
11:36:12 <Cale> https://hackage.haskell.org/package/category-printf-0.1.0.2/docs/Control-Category-Printf.html
11:36:17 <bernalex> I'm pretty sure dependent types make it easier at least
11:36:40 <Cale> Yeah, okay, the format specifiers are not exactly *String*, but they are an instance of IsString which can be used to do the non-special bits.
11:36:55 <maerwald> complicated types
11:37:13 <bernalex> using a cokleisli is hardly more complicated than using dependent types
11:37:14 <Cale> The types are a little complicated, but they make sense
11:37:14 <hpc> Cale: needs usage info
11:37:16 <maerwald> intAtBase :: (Real t, Integral t, Show t, Monoid s, IsString s) => t -> (Int -> Char) -> Format s a (t -> a)
11:37:16 <maerwald> that line could be longer
11:37:18 <maerwald> :D
11:37:26 <Cale> Yeah, I need to add some examples to the documentation
11:37:48 <maerwald> bernalex: I'm actually not sure if dependent types are a good idea yes
11:37:59 <enthropy> Cale: is that the same thing xformat does?
11:38:01 <maerwald> because that's really a LOT of potential complexity real-world programs could use
11:38:14 <maerwald> another layer you have to think of, when reasoning about something
11:38:24 <hpc> oh this is that thing from -offtopic the other day
11:38:25 <bernalex> the idea is to reason *less*
11:38:36 <bernalex> you don't want to write the same thing twice, once on type-level & once on term-level
11:38:39 <maerwald> that's not always what happens though :D
11:38:45 <bernalex> you just would like to encode things at typelevel
11:38:46 <Cale> *Main> printfLn (dup . s . " in hexadecimal is " . hex) 1024
11:38:46 <Cale> 1024 in hexadecimal is 400
11:39:01 <bernalex> yeah I agree that implementing dependent types in a practical way is tricky and terra incognita
11:39:11 <exio4> Cale: dup? what's this? FORTH? :P 
11:39:13 <bernalex> idris is probably the most interesting atm
11:39:20 <Cale> exio4: yep, pretty much typed forth
11:39:31 <bernalex> exio4: haha
11:39:57 <bernalex> I toyed with "J-as-a-library" in haskell. but thankfully came to my senses and started doing something more useful instead.
11:39:58 <Cale> *Main> printfLn ("The s formatter formats anything showable, like " . s . " or " . s . ".") [1,2,3] (5,'c')
11:39:59 <Cale> The s formatter formats anything showable, like [1,2,3] or (5,'c').
11:40:32 <hpc> what are the type errors like?
11:40:35 <Cale> printfLn ("The s formatter formats anything showable, like " . s . " or " . s . ".") :: (Show t, Show t1) => t -> t1 -> IO () <--- this is an inferred type!
11:40:55 <maerwald> Cale: that's not really printf syntax though
11:41:23 <maerwald> I know there are other libraries already that do a similar thing typesafely, but they all change the syntax of the original printf
11:41:25 <Cale> maerwald: Sure, and I could have made it a little closer by at least using the same letters
11:41:43 <Cale> However, it captures the essence of what printf format specifiers are really nicely.
11:41:45 <geekosaur> actually I'm looking at that and thinking... perl
11:42:01 <hpc> geekosaur: i said the same thing, it's the (.) for string concatenation
11:42:08 <geekosaur> exactly
11:42:40 <nmdanny> what is a better way of representing 2-d matrices in haskell: an array of arrays, or an array of 2-elm tuples?
11:42:53 <Cale> When you see in the types Format m a b, that means it's something which may add to the output of type m, while effectively changing the type of printf from a to b
11:43:28 <maerwald> the idris one hast pretty much the original syntax, as in: printf "Test %s" 10
11:43:34 <hpc> Cale: what's the type of ("The s formatter formats anything showable, like " . s . " or " . s . ".")?
11:43:41 <Cale> e.g. Format String a (Integer -> a) is a formatter for String values, which adds an Integer argument
11:44:13 <geekosaur> nmdanny, often a third way is used: a vector and functions to simulate 2D indexing in a flat vector
11:44:17 <Cale> (Show t, Show t1, IsString s, Monoid s) => Format s b (t -> t1 -> b)
11:44:18 <hpc> Show a, Show b => Format String c (a -> b -> c)?
11:44:22 <hpc> :D
11:44:28 <Cale> yep
11:44:34 <hpc> oh, and that stuff
11:44:44 <dolio> I don't really get why people get so into having exactly the same syntax as printf, anyhow.
11:44:55 <Cale> Yeah, stuff is generalised over the type of strings you're using, just because it can be, and Text is nice
11:44:56 <geekosaur> because printf is what they know
11:45:04 <hpc> because taking advantage of 35-year-old familiarity is handy for adoption
11:45:14 <hpc> see also, every other C-like language out there
11:45:17 <Cale> Soon, reflex is going to have an Applicative instance for Dynamic, and when it does, we'll get printfWith dynText
11:45:22 <geekosaur> (or think they know --- most people don't know printf flags well, or how they interact, or things like the $n syntax)
11:45:33 <Cale> which will be a printf formatter with dynamically changing inputs
11:45:35 <exio4> Cale: that sounds nice
11:45:45 <hpc> a lot of people only ever use %s anyway
11:45:49 <exio4> I mean, really nice
11:45:54 <exio4> hpc: %s, %d and %f
11:45:58 <Cale> because we'll be able to lift the Monoid and IsString instances through Dynamic
11:46:16 <hpc> the syntax matters more in date formatting anyway
11:47:17 <maerwald> I think printf isn't that useful anyway. There was only one time I found use for it and then I did it differently anyway.
11:47:43 <dolio> Having combinators for building up format specifications is good.
11:47:52 <dolio> printf is actually not that good for that.
11:47:55 <Cale> Oh, I just thought of a new one...
11:48:46 <hpc> Cale: when you reproduce the printf functionality for leading zeros and alignment and such, make sure you depend on acme-left-pad
11:48:55 <Cale> lol
11:49:00 <Cale> Yeah, I need to add that stuff
11:49:11 * geekosaur still has somewhere on his to-do list making formatter combinators similar to those used in database reporting
11:49:28 <geekosaur> ...it'll never happen probably because I haven't actually had any call for them in the past, er, 20 years
11:49:28 <hpc> geekosaur: database reporting?
11:49:39 <hpc> heh
11:49:48 * enthropy wonders if "formatting combinator library" is the new "monad tutorial" is the new ...
11:49:49 <geekosaur> report generators for databases
11:49:50 <ertes> hi there…  a church encoding of FreeT i would expect to be:  newtype FT f m a = FT { runFT :: forall r. (a -> m r) -> (f (m r) -> m r) -> m r }
11:50:30 <Cale> (dup . s . " plus " . swap . dup . s . " equals " . apply2 (+) . s) :: (Num t, Show t, IsString m, Monoid m) => Format m a (t -> t -> a)
11:50:37 <ertes> however, the encoding in the 'free' package is:  newtype FT f m a = FT { runFT :: forall r. (a -> m r) -> (forall x. (x -> m r) -> f x -> m r) -> m r }
11:50:41 <ertes> does anyone know why?
11:50:41 <Cale> *Main Control.Comonad> printfLn (dup . s . " plus " . swap . dup . s . " equals " . apply2 (+) . s) 4 6
11:50:42 <Cale> 4 plus 6 equals 10
11:50:44 <geekosaur> which these days are more likely to generate things like web pages instead of lpr-able plain text, but things like number formatting are still potentially issues
11:50:59 <Cale> Typed Forth :D
11:51:06 <geekosaur> (less so than they used to be, admittedly. one of these days I'll wake up and find that CSS5 or whatever added them >.> )
11:51:21 <dolio> ertes: That is isomorphic to your type.
11:51:57 <ertes> dolio: that's why i'm asking…  it looks like an unnecessary indirection
11:51:57 <dolio> Or, not really. But as long as f is a functor it is.
11:52:20 <ertes> assume f to be a functor
11:52:43 <dolio> Anyhow, the alternate type will be better for some things.
11:53:01 <Cale> enthropy: haha, are you referring to how Dan Patterson gave a talk about this?
11:53:03 <dolio> Like, you don't need to know that f is a functor to write certain operations.
11:53:11 <Cale> enthropy: Or are there yet other things I don't know about?
11:53:17 <ertes> i see
11:53:39 <dolio> And even if f is a functor, mapping over f might be expensive, which this will not have to do repeatedly.
11:54:06 <ertes> dolio: so for any particular functor F (if i were to make an F-specific version of this), there is no advantage?  mapping is cheap for mine
11:54:07 <enthropy> Cale: I mean there are many packages like http://hackage.haskell.org/package/formatting , printf-mauke, xformat, and probably many more
11:54:20 <Cale> ah, but most of that isn't new :)
11:54:22 <dolio> So, same reason as applying (co-)Yoneda to many things. You can get different performance characteristics.
11:54:46 <hpc> yoneda is still magic to me
11:55:02 <dolio> For certain choices of f, there may be no practical difference, or possibly a disadvantage.
11:55:09 <Cale> I admit that my only contribution is realising that it's Cokleisli ((->) m)
11:55:19 <ertes> dolio: background: i don't want to depend on any particular stream processing library, so i'm going to make a custom variant of this specific to (f = (,) a), where 'a' is the item type
11:55:30 <Cale> And even that, I dunno if perhaps edwardk or someone might already have known
11:55:37 <enthropy> Cale: well I haven't seen the idea of composing things with the Prelude.., which reminds me of the proliferation in the lens department
11:55:48 <nitrix> Are there days when you guys think that "extremely safe and extremely generic" is very annoying and you wish you could just come back to a handful of not so powerful building blocks?
11:55:51 <Cale> enthropy: ah, it's not really the Prelude (.), it's the Control.Category (.)
11:56:13 <Cale> nitrix: lol
11:56:33 <nitrix> I'm sure the opposite is true as well; I just want to make sure it's weighting in on the Haskell side of the balance in general.
11:56:36 <maerwald> nitrix: yes... then I did javascript and instantly regretted it
11:56:44 <nitrix> Cale: There's genuinely days when I'm questioning myself, yes.
11:56:53 <johnw> nitrix: no, I never actually think that
11:57:03 <Cale> nitrix: There are ways to get all those crappy building blocks in Haskell if you really want them
11:57:04 <johnw> nitrix: in fact, I go in the other direction
11:57:19 <ertes> nitrix: i think haskell isn't "extremely safe" anyway
11:57:26 <maerwald> Haskell can be really annoying, especially when you deal with commonly used anti-patterns like monad transformers. But the alternative is usually worse.
11:57:38 <dolio> ertes: In that case, it's probably best to do 'm r -> a -> m r' or maybe flipped, in all situations.
11:57:42 <Cale> Yeah, Haskell is only reasonably safe and only if you use it in the intended fashion.
11:57:48 <nitrix> maerwald: transformers are anti-patterns?
11:58:00 <nitrix> maerwald: What's the idiomatic way? Writing your own combining monad?
11:58:07 <maerwald> nitrix: extensible effects
11:58:12 * hackagebot hobbits 1.2.1 - A library for canonically representing terms with binding  https://hackage.haskell.org/package/hobbits-1.2.1 (EddyWestbrook)
11:58:18 <ertes> dolio: yeah, that's what i'm going to do…  thanks
11:58:21 <nitrix> maerwald: What does that mean?
11:58:23 <maerwald> nitrix: http://okmij.org/ftp/Haskell/extensible/
11:58:32 <maerwald> also see the chapter "Limitations of Monad Transformers"
11:58:43 <maerwald> the paper goes more in-depth as to why they suck
11:58:55 <dolio> It's also wrong about some of it.
11:59:11 <ertes> nitrix: transformers aren't an anti-pattern
11:59:18 <Cale> nitrix: It's hard to say that monad transformers are not idiomatic, however, I somewhat agree with maerwald that they've become a bit of an anti-pattern. Really in absolute terms, monad transformers are fine. When people use them instead of thinking about the design of their library, that's when it stops being fine.
11:59:27 <nitrix>    1  ::  2 ::  3  :: []
11:59:28 <nitrix> wth.
11:59:36 <ertes> people don't like them for various reasons, but most of them boil down to nothing practical
11:59:38 <mauke> this looks mly
12:00:43 <Cale> Monad transformers are not a substitute for actually thinking about what operations you'd really like to provide and providing something nicer than MonadState/etc. as an API.
12:00:53 <scshunt> they're not?!
12:00:57 <scshunt> ;)
12:00:58 <ertes> nitrix: background: there is this notion that as a library designer, if you're going to define type classes, 90% of the time you shouldn't do it
12:01:07 <ertes> nitrix: not so well known:  the same goes for monad transformers
12:01:32 <maerwald> Cale: it was a neat way initially to overcome the limitation of haskell not having a proper effects system, but it's now often just transformer-foo if you deal with powerful frameworks and it's just annoying
12:01:43 <maerwald> and as the paper outlines, there is a better way
12:02:03 <maerwald> idris also does it better, purescript too
12:02:16 <scshunt> yeah, I would *love* effects for my code
12:02:27 <Cale> maerwald: yeah, and I see people using bare ReaderT to avoid passing around a parameter, and then struggling with hoist garbage to deal with forkIO and catching exceptions and such, and it's just ;____;
12:02:55 <Cale> and there's liftIO all over the place so they didn't even save any code
12:03:01 <maerwald> exactly
12:03:21 <bernalex> it really is very QQ
12:03:22 <maerwald> and the error messages when something goes wrong :D
12:03:23 <bernalex> and it's hard to get away from
12:03:34 <bernalex> I envy purescript's system
12:03:40 <maerwald> GHC just says "blergh, something something"
12:03:44 <ertes> we have an effect system that by most practical considerations isn't any less powerful or elegant than a "proper effects system"
12:03:48 <Cale> It's really very avoidable: just don't do it
12:04:10 <ertes> i'm talking about mtl
12:04:25 <dolio> Yes, mtl is an effect system.
12:04:27 <Cale> The place to use monad transformers is once you have a very clear plan of the monad you want to construct and all its operations, and you see crisply how to construct it using them.
12:04:28 <bernalex> ertes: I have not used mtl enough. but how would e.g. purescript's main look using mtl?
12:04:32 <dolio> Which the paper completely ignores.
12:04:43 <ertes> bernalex: main :: IO ()
12:04:44 <Cale> and then you wrap up your construction in a newtype and nobody has to know you're using monad transformers
12:04:49 <bernalex> ertes: well that's horrible then
12:05:07 <bernalex> 'IO ()' just tells me that "oh ok it might do something"
12:05:13 <scshunt> Cale: along with instances of Monad* classes?
12:05:24 <Cale> scshunt: In fact, I would tend to avoid those
12:05:26 <bernalex> 'main :: forall e. Eff (fs :: FS, trace :: Trace, process :: Process | e) Unit' otoh is *a lot* more descriptive.
12:05:43 <maerwald> I like the explicit forall too
12:05:55 <Cale> scshunt: Just because they don't say what my operations really are -- I might invent some new type classes, or I might just provide some new functions
12:06:13 <dolio> main :: forall m. (FS m, Trace m, Process m) => m ()
12:06:19 <bernalex> I don't like explicit foralls any longer. I used to think they were great, because I tend to prefer being explicit. but in practice they just annoy me.
12:06:20 <Cale> But, to pick on MonadState some more, 'get' and 'put' are too generic to really be the right thing in most cases
12:06:38 <ertes> bernalex: i don't mind 'main' being omnipotent
12:06:41 <Cale> What are we getting, what are we putting?
12:06:52 <Cale> Are there restrictions on how we can change the state?
12:07:04 <ertes> my problem with mtl is that the set of classes is not well thought out
12:07:11 <ertes> not with its overall design
12:07:18 <hpc> ertes: well, imagine something like an app store where you use the type of main to decide what permissions to grant
12:07:28 <bernalex> ertes: I meant the type of main, not main as in a haskell program's entry point.
12:07:29 <Cale> The set of classes there can't be well-thought out just because of where it's positioned.
12:07:36 <ertes> bernalex: me, too
12:07:50 <Cale> It's sort of fine as a starting point to build up something more particular
12:07:53 <ertes> hpc: you would use a different type for 'main' in that case
12:08:01 <ertes> hpc: its context would tell you what permissions it needs
12:08:01 <Cale> But it's not something you want to dump on the users of your library
12:08:13 <bernalex> ertes: again, I don't mean the type of *main*, I mean the *type* that main has. disregard "main" entirely. I am talking about "forall e. Eff (fs :: FS, trace :: Trace, process :: Process | e) Unit".
12:08:39 <maerwald> Cale: i've thought about how to refactor my GUI code, because I have a global state (the outer GUI window and it's widgets) and an inner state that is sort of a drawing widgets (and there can be multiple)
12:08:39 <maerwald> so I actually tried using some state monad or so to hide this stuff, because it looks awkward to pass around explicitly, but it sucked even more
12:09:07 <ertes> bernalex: i'm not familiar with that syntax
12:09:12 <maerwald> and then I thought wth, who cares
12:09:53 <maerwald> explicit is fine, unless it starts to be confusing
12:10:10 <ggVGc> haven't had to use a monad transformer yet..
12:10:20 <ertes> anyway…  i've had those days when i thought: "a better effect system would be nice"…  then i started writing programs – how i learned to stop worrying and love mtl =)
12:10:29 <Cale> maerwald: Have you had a look at reflex/reflex-dom at all? I think we're really getting to something there with respect to how to structure the management of state in interactive applications -- though reflex-dom is currently itself a bit disorganised. (There will be a new 1.0 release in the next few weeks which should fix that though!)
12:10:33 <bernalex> ertes: it means that the function "uses the file system, traces messages to the console, and does something to the current process."
12:10:51 <maerwald> Cale: I'm doing gtk+, that's not an option
12:10:56 <ertes> bernalex: that much i understood…  and it looks like a type to me
12:11:03 <Cale> Yeah, we don't have a reflex binding to all of gtk+
12:11:12 <maerwald> I'd love to do FRP, but I really don't have the time to lay the groundwork for gtk+ frp
12:11:21 <Cale> Though, it actually *is* using GTK :)
12:11:25 <bernalex> ertes: Eff is a monad that represents what IO does in Haskell, but with more granularity.
12:11:31 <Cale> (It's just using the webkit stuff)
12:11:36 <kadoban> Cale: Oh wow, there's going to be a 1.0 in a few weeks? That's exciting.
12:11:56 <Cale> kadoban: Yeah, with Functor and Applicative instances for Dynamic! :D
12:12:02 <kadoban> Huzzah!
12:12:06 <ertes> bernalex: you can have that in haskell, if you really want to…  there are even multiple ways to do it
12:12:16 <bernalex> ertes: I can't think of a really nice way of doing it
12:12:25 <maerwald> Cale: and another problem is... those are just bindings and it's not a natural haskell lib, so you are forced on IO everywhere
12:12:37 <bernalex> people always say that I can do it, and then they show me some monad transformers-equivalent monstrosity
12:12:46 <ertes> bernalex: let me put it this way: it doesn't pay off
12:12:47 <Cale> maerwald: Well, GHCJS.DOM is using IO everywhere, and we handle wrapping it up *pretty* well.
12:12:48 <kadoban> Cale: Out of curiosity, not that it really matters, but how backwards compatible does it seem like it'll be, if you can even tell right now? Going to be easy to use old code with new reflex?
12:12:53 <maerwald> I am pretty sure it would be less problematic to write nicer GUI code even without FRP if the library was native haskell
12:13:14 <Cale> maerwald: I think a full GTK binding for Reflex is totally doable, it's just a *lot* of gruntwork to get off the ground.
12:13:14 <ertes> bernalex: at least it didn't for me…  the closest i got to a first-class effect system was via FreeT
12:13:20 <scshunt> Cale: Hmm... but I want to use zoom, for instance
12:13:40 <ertes> bernalex: i still use FreeT, but more to define languages and delimited monads
12:13:41 <Cale> scshunt: Well, that's a whole other direction in which you can take things, sure.
12:14:05 <maerwald> I really like the API of the diagrams library and the delaying of IO. I wish we had that for a full GUI library.
12:14:25 <scshunt> Cale: I suppose it's true, though, that I don't handle state transitions well
12:14:33 <scshunt> but you can't really statically verify state transitions
12:14:41 <StarsC> okmij is frequently cited here, any rival/complimentary website/thinker?
12:14:50 <scshunt> not without dependent types, anyway
12:14:59 <ertes> StarsC: loads
12:15:03 <Cale> kadoban: I don't actually know the details -- Ryan's been telling us and showing us some of his developments on it, but we haven't really actually gotten to play with it yet.
12:15:10 <dolio> oleg is one of a kind, I think.
12:15:10 <StarsC> ertes: f e?
12:15:21 <kadoban> Cale: Ah okay. Well I'll be looking forward to it either way :)
12:15:41 <ertes> StarsC: comonad.com is edwardk (edward kmett), haskellforall.com is Tekmo (gabrial gonzalez), etc.
12:15:42 <Cale> kadoban: I expect it won't be *too* much translation work, but it may involve *some*.
12:16:09 <Cale> kadoban: and it should be hopefully made easy by the typechecker and stuff
12:16:28 <Cale> You shouldn't expect the code to compile and yet not work.
12:16:35 <StarsC> ertes: i thought haskell for all is more of a blog?
12:16:37 <kadoban> Right, always a bonus in haskell
12:17:27 <Cale> kadoban: Stuff like mapDyn can be replaced by fmap of course -- I imagine Ryan might have a deprecated mapDyn stick around for a bit just for compatibility's sake.
12:17:58 <amnn> StarsC, Phil Wadler's page has some interesting papers on it: http://homepages.inf.ed.ac.uk/wadler/ and so does John Hughes: http://www.cse.chalmers.se/~rjmh/ if you're looking for more of an academic spin
12:17:59 <kadoban> Yeah, I'm looking through and mapDyn is used a lot of places … but it should be a pretty mechanical translation at worst to fix those.
12:18:13 * hackagebot uncertain 0.2.0.0 - Manipulating numbers with inherent experimental/measurement uncertainty  https://hackage.haskell.org/package/uncertain-0.2.0.0 (jle)
12:18:15 * hackagebot publicsuffix 0.20160505 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160505 (wereHamster)
12:18:16 <kadoban> At best I can probably refactor some of this stuff a tad to make it cleaner.
12:18:23 <Cale> kadoban: and combineDyn will get replaced with Applicative operations :)
12:18:40 <Cale> Should be pretty nice
12:19:01 <kadoban> Ohhh right, that'll be badass
12:19:10 <jle`> wait
12:19:10 <StarsC> amnn: yes im looking in academic spin :) ty
12:19:14 <jle`> i just used stack upload
12:19:22 <jle`> but i didn't provide my hackage password
12:19:23 <tpsinnem> hey, while working with nix i ran into the apparent fact that certain libraries are provided along with ghc. the problem is that i don't know which versions of these libraries ('directory' among others) come with which version of ghc
12:19:25 <amnn> StarsC, also Conor McBride's publications: http://strictlypositive.org/publications.html
12:19:26 <jle`> ...how did stack upload my package? >_>
12:19:30 <ertes> StarsC: blogs are a common way to convey haskell "science" these days
12:19:32 <tpsinnem> ^hwo might i find that out?
12:19:43 <ertes> StarsC: if you're looking only for papers, you will miss a *lot*
12:21:07 <Cale> tpsinnem: Someone's gotta have a table of that somewhere, and when you find it please let me know ;)
12:21:21 <Cale> tpsinnem: Of course, with nix, you can install all the different ghcs in separate shells and find out
12:22:07 <Cale> I really wish that all the libraries with GHC, especially base, would just have its version.
12:22:39 <Cale> Or at least something which vaguely resembled the GHC version they went with, possibly with an extra component
12:23:00 <Cale> But I guess that runs into problems with the PVP and versions released in between GHC releases and such
12:23:10 <Cale> still, ugh, it's annoying :D
12:23:19 <dolio> That's not a problem for base, at least.
12:23:29 <tpsinnem> Cale: found such a thing!: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
12:23:34 <tpsinnem> :)
12:24:23 <StarsC> amnn: ty, im glad u put word science in quotes :) , any real interesting global methodology in this area? so far looks to me like very big field of artisan stuff :)
12:24:48 <amnn> StarsC, did you mean to highlight ertes?
12:25:12 <StarsC> my appologies
12:25:14 <StarsC> indeed :)
12:25:29 <StarsC> ertes: 
12:25:36 <StarsC> it was maybe to you both :)
12:26:12 <amnn> what do you mean by "global methodology"? Different people approach solving problems in and for Haskell in different ways
12:26:14 <dolio> If you think blogs aren't academic, you're going to be disappointed to find out that some published academic papers cite blogs.
12:26:27 <ertes> StarsC: i don't know what you mean…  if you tell us what you're actually looking for, perhaps we could be more helpful
12:27:08 <StarsC> ertes: well , im just trying to understand big picture of the field , most of articles look like random interesting stuff which maybe soon forgotten
12:27:23 <ertes> StarsC: which field?
12:27:28 <StarsC> ertes: fp
12:27:53 <ertes> StarsC: FP is a very vague notion
12:28:22 <StarsC> ertes: Bird in one of his books cites technique which he calls program calculation, is there interesting progress in this area?
12:29:03 <StarsC> ertes: he basically does some transformative calulations between folds and scans , thus simplifying program
12:29:06 <amnn> StarsC, yes, it's an area of active research
12:29:27 <StarsC> amnn: any valuable starting points ? :)
12:29:31 <ertes> StarsC: maybe you're looking for a "big picture" that simply doesn't exist…  bird has done one isolated technique (in equational reasoning) that you can apply and/or combine with other otherwise isolated techniques
12:30:16 <StarsC> ertes: yes, i think im more interested in equational reasoning, seems this gonna stick for long time :)
12:30:33 <amnn> StarsC, if you are specifically interested in that, then this set of notes may be a good start: http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/acmmpc-calcfp.pdf
12:30:34 <ertes> StarsC: category theory is definitely a good starting point for things you would do in haskell
12:31:21 <amnn> ertes, the two are not mutually exclusive, as the notes show
12:31:24 <ertes> StarsC: but it too won't really give you a big picture…  it's not like in OOP, where you can say: "everything is an object, and how do i map my application to that idea?"
12:31:48 <StarsC> amnn: ty! will investigate these links
12:31:56 <ertes> amnn: that's what i'm saying…  everything is isolated and small, but they compose very well =)
12:32:28 <ertes> that's basically the "big picture" of FP: small higher-order things you can compose
12:33:05 <StarsC> ertes: actually are there well formulated mathematical problems of FP? like best possible parser or smth like that
12:33:13 * hackagebot system-test 0.1.1 - Runs system tests of applications.  https://hackage.haskell.org/package/system-test-0.1.1 (ExcaliburZero)
12:34:10 <StarsC> ertes: FP does have big picture, everything is function , wrong?
12:34:27 <amnn> I think you'll find it hard to find a "big picture" that everyone can agree with, because we all have different focusses. I'm sure if you head over to ##c++ (if you dare) and asked them what the "big picture" view of C++ is, they will have similar difficulty
12:34:37 <johnw> StarsC: it's been proven that you can't determine the "best possible parser"
12:34:54 <amnn> it is hard to see the forest for the trees when you are actually *in* the forest
12:35:13 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/ <-- this talk is really good for people looking for a general approach in functional programming
12:35:47 <Cale> It's an approach which isn't always straightforward to apply, but when it works, it tends to work very very well
12:35:52 <StarsC> ty guys, im not demanding anything, just very hard to learn without big picture :(
12:36:31 <StarsC> Cale: ty
12:36:59 <StarsC> johnw: can u give me some link?
12:37:10 <Cale> StarsC: The big picture of functional programming is that whenever you see something repetitive, we try to give you the tools to chop it out and turn it into a definition, so rather than doing the same thing over and over, we can hopefully turn things into reusable libraries.
12:40:43 <jle`> should i put upper bounds on my packages?
12:40:49 <jle`> er, my dependencies?
12:41:10 <johnw> StarsC: it has a name that I can never remember
12:41:24 <StarsC> amnn: ty for help
12:41:35 <amnn> no worries, happy exploring
12:41:49 <maerwald> Composing blocks of functionality is easier when that functionality is strictly defined (via input and output _only_) and "order of execution" doesn't matter. The white lie here is... the haskell IO type :P
12:42:44 <Cale> jle`: ... maybe? It empirically seems to result in the solver being able to find correct solutions more often, from what I last heard. But also, it results in frustrating situations where packages don't get updated, and fail to install for no better reason than an upper bound needs relaxing.
12:43:06 <jle`> yeah
12:43:10 <jle`> i read over neil mitchell's post
12:47:50 <ertes> StarsC: i understand your difficulty, so i suggest you try to learn with a specific application in mind, or with a specific motivation…  not "FP", but rather "web applications", "games", etc.
12:48:29 <ertes> then see how a haskell (or whatever "FP" language) programmer would approach those problems
12:49:39 <ertes> also i think the landscape of techniques and abstractions has become so huge that a "big picture", even if it exists, may not be a realistic goal
12:53:58 <bernalex> ertes: «My goal is simple. It is a complete understanding of the universe, why it is as it is and why it exists at all.» :)
12:54:14 * shapr gives bernalex the gold lambda
12:54:17 <shapr> YOU WIN
12:54:25 <bernalex> shapr: hiya! long time no see!
12:54:30 <shapr> howdy bernalex!
12:54:36 <bernalex> shapr: get into #haskell-offtopic!
12:54:38 <shapr> Yeah, life has been distracting, how's your Haskell code?
12:55:04 <bernalex> to be cont'd in #-offtopic!
12:56:12 <ertes> to be ContT'd in …
13:02:14 <nmdanny> Question: using a Data.Map, if I want to update a bunch of elements, is it more efficient to use a single union over multiple inserts?
13:02:49 <ertes> nmdanny: single union
13:02:51 <jle`> nmdanny: you can use fromList?
13:03:03 <jle`> ah yeah i misread your question
13:03:16 <ertes> nmdanny: in most cases at least
13:03:54 <ertes> nmdanny: i suggest you benchmark your case…  criterion will help you to get precise timings
13:04:16 <jle`> i wonder why pattern synonym type signatures swapped the order that you specify the different constraints for 8.0
13:04:17 <nmdanny> it's a general question, since from what I understand in functional languages inserts modify the entire data structure
13:04:23 <jle`> it seems kind of silly, why not just keep the original order?
13:04:49 <jle`> nmdanny: not necessarily, most functional languages take advantage of sharing
13:04:52 <ertes> nmdanny: they do, but most of the structure is just reused untouched from the old one
13:05:00 <ertes> nmdanny: that's called sharing
13:05:14 <jle`> for example, if xs = [1,2,3], and you have `1 : xs`, xs is used in memory as-is
13:05:35 <jle`> you don't have to copy xs to have ys = 1 : xs
13:06:35 <nmdanny> Ok, I am using a Map (Int,Int) Int to represent a matrix, and every step I update all elements in that map
13:06:46 <nmdanny> implementing conway's game of life
13:07:16 <ertes> nmdanny: Map is not the best choice, if you have an actual rectangular grid that you update entirely at every step
13:08:14 * hackagebot tubes 2.0.0.1 - Write stream processing computations with side effects in a series of  tubes.  https://hackage.haskell.org/package/tubes-2.0.0.1 (gatlin)
13:08:26 <ertes> nmdanny: if you have to visit every single item for every frame (note that you don't have to in GoL), you should probably use an array instead (like from the 'vector' package)
13:09:03 <nmdanny> the thing is, its an infinite(unbounded) grid
13:09:35 <nmdanny> and I'd want to add new elements to the matrix(aka resize it)
13:09:58 <ertes> nmdanny: why Int as the element type?
13:10:25 <ertes> nmdanny: my first GoL implementation would probably be with Set (Int, Int)
13:10:43 <ertes> (or rather Set (V2 Int), where V2 is from the linear package, but that's just me)
13:11:27 <nmdanny> Hmm that's a good idea, I guess that I can just consider stored elements as alive, and the rest as dead
13:12:50 <ertes> yeah
13:13:31 <ertes> (Set k) is equivalent to strict (Map k Bool)
13:13:53 <ertes> uhm
13:13:58 <nmdanny> though now that I'm thinking about it, the whole notion of using indexes for an unlimited GoL is kinda tricky
13:13:59 <ertes> what a nonsense…
13:14:02 <ertes> (Set k) is equivalent to strict (Map k ())
13:14:50 <ertes> nmdanny: is it?
13:16:16 <nmdanny> every time I expand my grid, I would have to either change all indices or use negative indices
13:16:31 <ertes> there is nothing wrong with negative indices
13:16:31 <amnn> nmdanny, definitely do the latter
13:16:58 <ertes> > S.fromList [(1, 2), (2, 3), (-1, -1)]
13:17:00 <lambdabot>  fromList [(-1,-1),(1,2),(2,3)]
13:17:03 <nmdanny> and I would also have to eventually trim the grid of dead cells
13:17:17 <ertes> nmdanny: what's a "dead cell"?
13:17:53 <jle`> how are you going to trim a set of the things that aren't in the set, heh
13:18:09 <ertes> nmdanny: you mean like one that isn't in the set? ;)
13:18:40 <nmdanny> Ok disregard that, 
13:18:48 <EvanR> theoretically, life happens on a grid where you forgot the indexes, forgot where 0 0 is
13:19:02 <EvanR> which is an interesting thing
13:19:04 <nmdanny> eventually I will have to create a rectangular grid from a bunch of points
13:19:17 <ertes> nmdanny: i created one above
13:19:31 <ertes> the points (1, 2), (2, 3), (-1, -1) are alive
13:19:46 <amnn> ertes, "a bunch of points" :: Set (Int, Int)
13:20:13 <amnn> the question is about bounding the points in a rectangle, essentially
13:20:21 <EvanR> spatial index
13:20:39 <ertes> amnn: nmdanny said that there should be no bound (except that there is one, due to the boundedness of Int)
13:20:56 <EvanR> bounding meaning searching for whats in a box
13:21:08 <ertes> oh
13:21:09 <EvanR> so you can display something
13:21:15 <amnn> ertes, there is no bound on how big the grid may grow, but at any one instance, the grid is finite, and could be rendered on screen.
13:21:17 <jle`> EvanR: forgetting where 0,0 is gives you interesting implications via noether's theorem
13:21:20 <EvanR> or perhaps use to do the rule
13:21:40 <ertes> there are quite a few methods to achieve that…  i would use a cheap spatial tree like a k-d-tree
13:21:44 <EvanR> 3x3 box around a given point
13:22:27 <EvanR> jle`: i dont recall at this point what that theorem is
13:22:40 <nmdanny> basically in my program, indice values are not important, what is important is the direction of one point to another
13:22:41 <jle`> symmetries imply conserved quantities
13:22:58 <EvanR> ah that noethers theorem
13:23:15 <jle`> ie, translational symmetry in mechanics begets conservation of momentum
13:23:22 <EvanR> i wonder what that does for game of life
13:23:31 <amnn> ertes, if we are going to use a sptial index to facilitate bounding, we might as well use it on its own, no need for the set of points.
13:23:43 <EvanR> amnn: indeed
13:23:45 <ertes> amnn: yeah, that's what i would do
13:23:54 <jle`> maybe it doesn't apply, becuase GoL isnt reversable
13:23:58 <jle`> oh wel
13:24:00 <amnn> quite a common technique for storing game of life configurations is a hash based spatial index
13:24:33 <EvanR> http://sjsu.rudyrucker.com/~kwanghyung.paek/paper/
13:25:21 <ertes> note that Set can be used to make bounding boxes, too
13:25:26 <qnikst> ertes, hi, was ertes.de your site? there was a great tutorial on automatons, arrows (and it was telling there would be introduction to FRP and netwire sometimes then) is it still available somewhere?
13:25:29 <jle`> neat
13:25:38 <EvanR> jle`: this one ends up looking like billiards http://cell-auto.com/bbm/2d/index.html
13:25:45 <ertes> qnikst: yeah, that was mine, and sorry, not right now
13:26:08 <ertes> qnikst: however, you may find it via archive.org or something
13:26:15 <ertes> they have a "wayback machine" i think
13:26:15 <jle`> that's cute
13:26:25 <qnikst> ertes, are you planning to publish those tutorials sometimes then?
13:26:58 <qnikst> those are banned in my country, but basically I realized that I need to fix links in  my blog :)
13:27:29 <jle`> i was only able to find one paper on applying noether's theorem to reversable cellular automata
13:27:33 <amnn> nmdanny, https://en.wikipedia.org/wiki/Hashlife
13:27:37 <jle`> hmm
13:28:00 <ertes> qnikst: i had a major data loss unfortunately…  but tor may allow you to access them
13:28:12 <qnikst> ertes: oh.. I see
13:28:53 <ertes> qnikst: also netwire is obsolete now…  i recommend not using it
13:28:55 <qnikst> ertes: not that I need it right now, I've studied that several years ago, but I have no place to point people who asks relavant questions to
13:29:08 <ertes> qnikst: point them here
13:29:13 <EvanR> ertes: exactly whats wrong with it now?
13:29:37 <qnikst> ertes: ok, will do
13:30:51 <ertes> EvanR: it's impossible to maintain, and the abstraction has is set of problems…  inhibition can be great, but it shouldn't be built-in
13:31:32 <nmdanny> Ok, I have an idea for a naiive solution to the infinite GoL problem: use a set of indexes(which can be negative), 
13:31:46 <qnikst> ertes: any recommendations what to use from FPR world?
13:31:49 <nmdanny> each step I would iterate over all points in the set, and for each point, iterate over the 8 points in each direction from it
13:32:19 <EvanR> nmdanny: pretty much
13:32:23 <ertes> qnikst: my personal recommendation is reflex for most applications, and yampa for high-speed time-framed applications like games and simulations
13:32:33 <nmdanny> and eventually when I want to create a bounded grid, I would eliminate empty rows/columns
13:32:48 <EvanR> i dont get that part
13:32:57 <EvanR> what empty rows columns
13:33:09 <ertes> qnikst: reactive-banana is also a good library
13:33:21 <amnn> nmdanny, you can just iterate through the points in the set, keeping track of the min/max of each co-ordinaite, to find the corners of your bounding rectangle
13:33:22 <qnikst> ertes: thanks, was not aware of reflex
13:33:36 <amnn> *co-ordinate
13:33:36 <qnikst> ertes: I used reactive-banana a bit for UI
13:33:39 <nmdanny> oh yea, I guess that would be simpler
13:34:26 <ertes> qnikst: if you've got an hour to waste, i recommend to watch ryan trinkle's videos on reflex
13:34:29 <qnikst> really we are using netwire in some random place and really tiny bit, but knowing that it's not maintained anymore is helpful, and if we will need to extend those bits maybe we will need another solution
13:34:34 <EvanR> this allows a potentially infinite grid, but doesnt allow an infinite initial (or ever) configuration
13:34:57 <qnikst> ertes: it's always possible to find just another hour for a good talk, thanks
13:35:04 <ertes> qnikst: i'm working on a replacement for netwire, but very slowly, because i have no commercial need for it right now
13:35:39 <qnikst> ertes: I see
13:36:17 <EvanR> i see a way to allow infinite configurations
13:36:23 <bakery> what does yampa give you that is better for games and simulations, compared to i.e. reflex? performance?
13:36:42 <qnikst> I always tried to use some FRP library, but finished with some specialised solution in spirit of FRP, and even in current project where I tried to not touch that part, it's finished with own solution with few bits of netwire
13:36:48 <ertes> bakery: cheap mass switching
13:37:07 <nmdanny> speaking of reflex, I tried for days to install Reflex and GHCJS using stack, but I never managed to build them successfuly
13:37:13 <qnikst> so I still want to learn how to do it right
13:38:48 <bakery> nmdanny: https://github.com/luigy/try-stack-reflex/blob/master/stack-ghcjs-improved-base.yaml
13:39:16 <nmdanny> would this build successfully on windows?
13:39:28 <bakery> built it on windows a couple of days ago :) 
13:39:42 <amnn> EvanR, well you can represent your grid as a function from co-ordinate to Bool
13:40:13 <EvanR> i am thinking of a different way
13:40:20 <EvanR> but maybe that way is even simpler
13:40:28 <EvanR> not sure which is slower
13:40:37 <amnn> it's simple, but after a few generations, will slow down for point queries
13:40:39 <ertes> qnikst: with reactive-banana and reflex you pretty much can't do it wrong…  they both have very strong semantic guarantees
13:40:42 <amnn> it's not very practical
13:40:55 <bakery> but you have to update the compiler to what's listed on stack documentation, and exchange the reflex git commits to the newest ones (which are from github.com/reflexfrp/*)
13:41:25 <EvanR> if you only look at a fixed rectangle on the screen then you only need to simulate the universe at a linearly increasing bounding box expanding from that rectangle
13:41:39 <mgsloan> nmdanny: Have you tried this https://github.com/luigy/try-stack-reflex ?
13:41:47 <EvanR> so as the generations go you are simulating n^2 more universe, and playing catch up 
13:41:52 <EvanR> so more than n^2
13:41:56 <StarsC> ertes: ty for help
13:42:46 <EvanR> seems kind of like the performance of lazy reals
13:43:15 <EvanR> (which is exponential)
13:43:39 <amnn> well the problem with representing the grid as a function is that after 100 generations, to check whether a particular point is alive will invoke 8^100 recursive calls...
13:44:01 <amnn> actually, 9^100
13:44:41 <ertes> realise2D :: (Unbox a) => StoreT (V2 Int) a -> StoreT (V2 Int) a
13:44:47 <ertes> whoops
13:45:05 <ertes> realise2D :: (Unbox a, Functor w) => StoreT (V2 Int) w a -> StoreT (V2 Int) w a
13:45:31 <bakery> ertes: what do you mean when you said yampa has cheap mass switching?
13:45:33 <amnn> EvanR, can you give us a clue as to what your tactic would have been?
13:45:51 <ertes> amnn: that was for you
13:46:29 <EvanR> amnn: the initial configuration would be a function obviously, but what you are looking at is immediately realized as a data structure, but nothing else
13:46:33 <ertes> bakery: in AFRP you can have the whole application world in the reactive semantics and just turn off the parts you don't currently need
13:46:49 <amnn> EvanR, ah, I see
13:46:50 <ertes> you can block, pause, switch, etc.
13:46:51 <EvanR> after 1 generation you simulate that data structure, and 1 square of boundary past the visible region
13:46:58 <EvanR> and 1 old generation
13:47:11 <EvanR> after 2, 2 cells of boundary and 2 old generations
13:47:12 <nmdanny> @bakery , I get the error: Setting codepage to UTF-8 (65001) to ensure correct output from GHC C:\Users\Danny\Programming\reflex-todomvc-base\reflex-todomvc\: getDirectoryContents: does not exist (The system cannot find the path specified.)
13:47:12 <lambdabot> Unknown command, try @list
13:48:41 <amnn> EvanR, I'm not sure that quite works, because even though we can't see the changes currently, whilst we are simulating within our "area of interest" the initial configuration all around us will be changing too
13:48:45 <bakery> nmdanny: just remove the line that says - location: reflex-todomvc
13:48:53 <EvanR> the initial configuration is not changing! ;)
13:49:12 <EvanR> but because the rest of the universe is changing, you do have to play catch up
13:49:19 <EvanR> it cant affect your answers though because of the speed of light
13:50:37 <EvanR> you can see this effect if you simulate a finite grid with an array and make the edges behave incorrectly
13:50:53 <EvanR> the interior of the universe will behave normally until a wave from the edge arrives with "wrongness"
13:51:43 <nmdanny> @bakery, now I get: C:\Users\Danny\Programming\reflex-todomvc-base>stack build Setting codepage to UTF-8 (65001) to ensure correct output from GHC Downloaded lts-5.1 build plan. Caching build plan Error parsing targets: The specified targets matched no packages
13:51:43 <lambdabot> Unknown command, try @list
13:51:45 <EvanR> conversely to get it right, your rectangle has to send out a wave of "correctness"
13:52:09 <amnn> right
13:52:11 <EvanR> there is no in between! ;)
13:52:18 <EvanR> (unless the pattern is repeating)
13:52:27 <ertes> bakery: let me give you a specific example: in AFRP you can have this:  enemies :: SF (V2 Int, Event Whatever) (VisibilityTree Enemy)
13:52:41 <ertes> bakery: where the fst input is the current player position
13:52:42 <bakery> nmdanny: did you change the build plan to 5.14? like they do here: http://docs.haskellstack.org/en/stable/ghcjs/
13:52:58 <amnn> I see the trouble now, in my mind, the bounding rectangle was increasing in size at every iteration too, but that makes no sense
13:53:07 <nmdanny> should I?
13:53:11 <EvanR> no this relies on keeping that the same
13:53:12 <bakery> yes :)
13:53:16 * hackagebot organize-imports 0.4.0.0 - Organize scala imports  https://hackage.haskell.org/package/organize-imports-0.4.0.0 (lcycon)
13:53:40 <nmdanny> by build plan do you mean LTS version?
13:53:41 <amnn> there are actually two rectangles in this interpretation, the bounding rectangle, and the "light cone"
13:54:09 <bakery> nmdanny: yes. I think the newest version of ghcjs requires 5.14
13:54:12 <EvanR> yeah, the observes local region and his region of causality
13:54:37 <amnn> nice
13:54:39 <bakery> ertes: i see. that seems useful
13:54:57 <EvanR> woe be to anyone with rules that are non-local!
13:55:25 <nmdanny> again I get the 'the specified targets match no packages'
13:56:20 <ertes> bakery: it's possible with non-A FRP, but not with the same efficiency, because it's impossible to do low-level optimisations…  for example (though yampa can't), AFRP can easily keep a mutable structure without having to expose it
13:56:37 <nmdanny> do I need to have any other file than that yaml?
13:58:16 * hackagebot yesod-crud 0.1.4 - Generic administrative CRUD operations as a Yesod subsite  https://hackage.haskell.org/package/yesod-crud-0.1.4 (league)
13:58:43 <bakery> nmdanny: not that I know of. as long as you did a new stack project and just swapped the stack.yaml file for what's listed in the stack documentation, you should be able to build at least ghcjs
13:59:02 <nmdanny> I've managed to build GHCJS before, but adding reflex made it not build
13:59:45 <bakery> ertes: cool! I gotta read up on that more closely
13:59:56 <mgsloan> nmdanny: Did you see the link to https://github.com/luigy/try-stack-reflex ?
14:00:18 <ertes> bakery: don't…  you'll end up writing an AFRP library =)
14:00:33 <ertes> i speak from experience =P
14:00:48 <nmdanny> mgsloan : I tried using improved base, which is the latest version, if I'm correct?
14:00:54 <nmdanny> and I deleted the todomvc package line
14:01:09 <EvanR> amnn: interesting ... i wonder what the theoretical judgment is on the kinds of initial configurations poisslbe
14:01:13 <bakery> nmdanny: hmm, I'm not sure then. if you updated the commit checksums and the commits to the ones found here: https://github.com/reflex-frp
14:01:16 <EvanR> with a function
14:01:27 <bakery> nmdanny: I think I didn't do anything different
14:01:56 <bakery> ertes: doesn't sound like the worst summer project ever
14:02:13 <nmdanny> I have to update the commits too?
14:02:49 <bakery> nmdanny: yeah, you need to get the checksums for the newest commits
14:03:03 <nmdanny> for both GHCJs and Reflex?
14:03:57 <bakery> nmdanny: only for the reflex packages, I think
14:03:58 <amnn> EvanR, any (computable) initial configuration should be fine, right? We would get in to trouble if the rules of the automata were non-local (we can't have teleportation)
14:04:27 <bakery> the ghcjs repo that's listed in the stack documentation is the newest one
14:06:19 <EvanR> amnn: i mean whther there are some you cant get i guess gets philosophical
14:07:38 <nmdanny> bakery : again I updated the commits and it still says, the specified target matched no packages
14:08:28 <Cale> nmdanny, bakery: if you're interested in reflex, I recommend the try-reflex script in this package as a quick way to get started on a project: https://github.com/reflex-frp/reflex-platform
14:08:46 <nmdanny> unfortunately i'm on windows
14:08:51 <Cale> ohh
14:09:14 <maerwald> my condolences
14:09:50 <nmdanny> could it be that the GHC from haskell-platform on my path that is interferring with the build?
14:10:05 <Cale> hm, yeah, I don't know what to do about that -- you might ask ryantrinkle in #reflex-frp if he knows anything about other windows users' experiences
14:10:40 <Cale> It seems like if you were using Stack, it ought to make sure you have the correct ghc
14:11:19 <nmdanny> btw, does sublime haskell work for somebody? or hsdev for that matter?
14:12:46 <Zemyla> I have a question about the new Typeable, where TypeRep has a parameter.
14:13:17 <Zemyla> Will there be a function kindRep :: TypeRep (a :: k) -> TypeRep (k :: Kind)?
14:15:04 <ertes> people here tend to forget that windows exists, and that's bad, but there is a solution:  all windows users should switch to another operating system
14:15:08 <mgsloan> nmdanny: Your system ghc will not be used if it's the incorrect version
14:15:28 <ertes> (SCNR)
14:15:36 <nmdanny> ok, I have managed to install GHCJS from http://docs.haskellstack.org/en/stable/ghcjs/
14:16:00 <mgsloan> For the most part, stack does isolated / controlled installs.  The only exception is when the ghc needed matches your system ghc
14:16:10 <mgsloan> In that case it is possible for your environment's setup to affect your builds
14:16:17 <augur> is there some f such that [] ~ Free f?
14:16:36 <mgsloan> (e.g. packages in your global DB, or leftover broken packages, can screw things up)
14:16:42 <johnw> Free ((,) a) () ~ [a]
14:17:22 <augur> johnw:  hmm
14:17:23 <mgsloan> IMHO we should always use a stack installed ghc, would probably prevent a few extra issue reports, at the cost of system resourcesf
14:17:23 <Zemyla> augur: Free Pair is pretty much the same thing, where Pair a = Pair a a.
14:17:32 <Iceland_jack> johnw: just not with the instances you'd expect
14:17:35 <mgsloan> There was some discussion of this, and the consensus was to use the system ghc if it's there
14:17:51 <Iceland_jack> Zemyla: Yes I think so
14:18:26 <augur> johnw: i was hoping more for   Free f a ~ [a]   :)
14:19:02 <Iceland_jack>     toList = const [()]
14:19:02 <Iceland_jack>  
14:19:18 <nmdanny> sigh this fucking matched no packages error
14:19:44 <amnn> augur, data ListF r a = Cons a r | Nil
14:20:48 <ertes> augur: there is no such f
14:20:52 <nmdanny> does anyone happen to have a stack.yaml for ghcjs+reflex, that compiles today?
14:21:11 <amnn> hold on... this is Free, not Fix... my bad
14:21:15 <ertes> augur: if the f has more than one "point", Free f ends up being a tree
14:21:31 <nmdanny> there are so many builds for reflex and ghcjs, I can't tell what works with what
14:22:03 <fizruk> ertes: but list is also a tree
14:23:22 <mgsloan> nmdanny: The ones I linked to do
14:23:31 <augur> so heres what i figured.   [a] ~ 1 + a*[a] ~ 1 + a + a*a*[a]   ;   [a] ~ Free f a ~ a + f (Free f a)
14:23:32 <mgsloan> I would just use those versions and upgrade later if you need to
14:23:50 <augur> ~ a + f [a]
14:24:10 <fizruk> ertes: perhaps you mean that in Free f a, a only occurs in Pure a, but in Free f a, you can substitute Pure x with any (Free f a) value via bind?
14:24:16 <augur> so   1 + a + a*a*[a] ~ a + f [a]   requiring   f [a] ~ 1 + a*a*[a]  so obviously   f X = 1 + a*a*X
14:24:27 <fresheyeball> hey people of the haskell, I want the greatest most complete dev environment ever complete with ghc-mod and such
14:24:32 <fizruk> ertes: so you can't enforce it to be a list?
14:24:44 <fresheyeball> is there a known way to do that?
14:24:47 <ertes> fizruk: yeah, you could say that
14:25:02 <augur> but this requires X to know a, but we cant make such a thing because a in `Free f a` is independent of f
14:25:08 <ertes> fizruk: augur is looking for an f such that (Free f a ≃ [a])
14:25:11 <ertes> and there is no such f
14:25:25 <ertes> because you can't control the number of levels of the tree
14:25:42 <ertes> very similar to how you can't control the number of elements in a free monoid
14:26:30 <nmdanny> what is the best haskell development tool that is not emacs/vim ?
14:26:34 <amnn> is it equality we're looking for, or just isomorphism?
14:26:43 <shapr> nmdanny: whatever text editor you prefer?
14:26:54 <Cale> nmdanny: Whatever your favourite text editor is... and ghci open beside it
14:26:56 <nmdanny> im using atom but it is quite slow sometimes
14:27:15 <nmdanny> I tried using sublime with sublime-haskell but that doesn't work at all
14:28:01 <Cale> Have you tried using it without sublime-haskell?
14:28:05 <maerwald> nmdanny: did you try leksah?
14:28:09 <amnn> augur, if you take f to just be [], don't you get what you want?
14:28:17 * hackagebot located-base 0.1.1.0 - Location-aware variants of partial functions  https://hackage.haskell.org/package/located-base-0.1.1.0 (EricSeidel)
14:28:18 <maerwald> just a text editor is a pretty bad suggestion imo
14:28:25 <shapr> maerwald: why so?
14:28:31 <deepfire> jgoerzenware slowly dies..
14:28:35 <nmdanny> I tried leksah but it seemed pretty confusing with all those windows and module thingies
14:29:00 <ertes> nmdanny: note that you can use emacs and vim on windows
14:29:11 <Cale> sublime has reasonable enough looking support for Haskell built in
14:29:20 <StarsC> nmdanny: why not emacs? its leading developer John Wegley is big haskell fan :) 
14:29:23 <augur> amnn: no, Free [] a is not [a] as a monad
14:29:42 <EvanR> more haskell fans should admit it ;)
14:29:43 <ertes> johnw: you're a leading emacs developer?
14:29:43 <maerwald> shapr: because if that was fine for him, he wouldn't have asked in the first place
14:29:47 <nmdanny> because I really don't want to spend a month on learning emacs
14:30:06 <augur> i mean, it's ~ as a set, that much is true, but im looking for the case where the resulting monad is the correct one :)
14:30:08 <Cale> Then again, I'm not one to judge these things -- I am extremely un-picky about my text editor. Everything is basically isomorphic to gedit.
14:30:09 <StarsC> ertes: he became head of something at emacs this spring
14:30:10 <shapr> nmdanny: yeah, I can understand that.
14:30:19 <ertes> ah
14:30:20 <nmdanny> though emacs seems to have many addons that support haskell
14:30:29 <shapr> maerwald: ok, I see your point. What would you suggest?
14:30:30 <ertes> augur: Free ((,) a) r  -- this is a very interesting list monad
14:30:34 <StarsC> nmdanny: i will teach u emacs in one line -> everything is function
14:30:35 <EvanR> basically isomorphic
14:30:38 <maerwald> shapr: I suggested leksah already
14:30:42 <shapr> nmdanny: that's true, I enjoy writing Haskell from inside emacs
14:30:50 <ertes> augur: while [] is the cartesian product monad, Free ((,) a) is the concatenation monad
14:30:52 <nmdanny> is it possible to use emacs like a modern text editor, aka cursor and traditional keybindings?
14:30:52 <johnw> ertes: I'm not a leading developer, just the maintainer
14:31:09 <StarsC> nmdanny: 2nd lesson in emacs -> everything is possible :)
14:31:11 <shapr> I'm not sure I agree with johnw's most recent statement, I use a bunch of elisp code he's written.
14:31:20 <ertes> augur: you can think of it as a stream producer…  even with effects if you want:  FreeT ((,) a) m
14:31:22 <nmdanny> i'm not asking if its possible, im asking if its supported and whatnot
14:31:23 <augur> ertes: yeah, so that's interesting
14:31:35 <StarsC> nmdanny: is it supported, called cua mode or something
14:31:37 <ertes> johnw: ah, i see
14:31:45 <mauke> johnw: ooh, can I complain to you about emacs?
14:31:47 <shapr> I think nmdanny does bring up a good point, I think the Haskell world needs an equivalent for Python's IDLE
14:31:59 <johnw> mauke: sure, using M-x report-emacs-bug. :)  And yes, I'll read it.
14:32:10 <EvanR> haskell world needs an equivalent to whatever IDLE uses for its GUI
14:32:13 <mauke> that would require me to install and start emacs :-(
14:32:13 <augur> so for some monads M, there exists an f such that   Free f a ~ M a, while for others you have   Free f r ~ M a   where f involves a somehow
14:32:20 <ertes> nmdanny: it's actually the default
14:32:20 <shapr> EvanR: right!
14:32:36 <augur> thats quite an interesting thing
14:32:36 <EvanR> this regression may not terminate ;)
14:32:37 <ertes> nmdanny: only the key bindings are different
14:32:46 <Lokathor> shapr, "but i just use emacs! control+rightAlt+Shift+LeftClick+F4 is all you need!"
14:32:47 <shapr> EvanR: maybe a web based editor?
14:32:50 <ertes> nmdanny: instead of C-s you say C-x C-s to save
14:33:01 <nmdanny> Merely learning how to configure emacs would be hard enough for me
14:33:04 <augur> Free ((,) a)   is i guess something like a diff list, almost
14:33:06 <fizruk> ertes: FreeT ((,) a) ~ WriterT [a] ?
14:33:11 <shapr> Lokathor: I do like emacs, but I didn't realize you knew the key combo to produce butterflies, how long have you been using emacs?
14:33:14 <deepfire> are monomorphic profunctors a thing?
14:33:22 <EvanR> shapr: that would be an interesting trajectory to take, haskell embracing the web more than other languages who are supposed to be "good for web programming"
14:33:26 <augur> Free ((,) a) r   is a list of a's with an r for its tail. so when r = () we get just a list
14:33:29 <ertes> fizruk: nope, rather Producer a from pipes
14:33:29 <nmdanny> I don't want to tinker with configuration files, modes and all those stuff... I just want a normal modern text editor
14:33:32 <deepfire> kind of like mono-traversable..
14:33:33 <EvanR> basically out of pragmatism
14:33:34 <Lokathor> nmdanny, you can set CUA-bindings to get an approximation, but you still need to use emacs though the GUI and not through a terminal
14:33:36 <StarsC> nmdanny: it pays off, same as it pays of to learn a little math trick
14:33:44 <augur> this is very interesting yes
14:33:46 <shapr> EvanR: well, I did the whole ghcLiVE thing
14:34:01 <Lokathor> nmdanny, "normal, modern text editor" is the polar opposite of emacs
14:34:03 <StarsC> nmdanny: emacs is modern, its a listp interpretator
14:34:12 <Cale> I think I'm going to try totally-unconfigured sublime-text and see how it is. Seems okay.
14:34:13 <ertes> nmdanny: really just give it a shot…  editing in emacs doesn't feel too different from your regular windows text editor, except that you can easily access more productive ways to edit
14:34:14 <StarsC> lisp*
14:34:15 <mauke> StarsC: how is that modern? lisp is ancient
14:34:28 <mauke> StarsC: and elisp in particular is pretty sucky. it's like the perl4 of lisp
14:34:30 <StarsC> mauke: compare to what exactly?
14:34:34 <augur> oh but the monad instance for Free ((,) a) is not a normal list
14:34:38 <shapr> nmdanny: I think your choice to separate learning an editor from learning a programming language shows good sense :-)
14:34:39 <fizruk> ertes: the difference being it separates monadic actions between produced `a` elements?
14:34:41 <mauke> StarsC: any other programming language. lisp is from the 50s
14:34:53 <StarsC> mauke: have you read lisp original paper?
14:34:54 <augur> so i guess there are just some monads that arent derived from Free behavior
14:34:56 <fizruk> ertes: it = Producer
14:34:56 <mauke> StarsC: no
14:34:58 <Lokathor> mauke, Haskell is from the 80s :P
14:34:58 <ertes> fizruk: they are virtually identical
14:35:01 * shapr points to #haskell-offtopic
14:35:02 <nmdanny> the only thing that I'm interested in emacs is its support for haskell and whatnot
14:35:03 <StarsC> mauke: do it.
14:35:07 <mauke> Lokathor: see? much more modern
14:35:11 <mauke> StarsC: why?
14:35:11 <EvanR> lets all use elixir
14:35:20 <EvanR> its the most modern
14:35:21 <Lokathor> oh my mistake
14:35:22 <Lokathor> 1990\
14:35:28 <StarsC> mauke: because its nice to talk to smart people.
14:35:32 <shapr> sooo, what editor that's not vim or emacs has the best support for Haskell?
14:35:34 <mauke> StarsC: non sequitur
14:35:37 <shapr> I've heard eclipse has good Haskell support
14:35:42 <ertes> fizruk: (FreeT ((,) a) m) and (FreeT ((->) a) m) correspond almost directly to (Producer a m) and (Consumer a m) from pipes
14:35:42 <deepfire> nmdanny: btw, #haskell-emacs is pretty populated
14:35:49 <EvanR> haskforce plugin for intellij ?
14:35:51 <fizruk> ertes: I mean with Producer we can inspect monadic actions, with Writer we can't, right?
14:35:54 <ertes> fizruk: and if you take the sum of those functors, you get Pipe
14:35:56 <shapr> mauke: go forth to #haskell-offtopic !
14:36:04 <shapr> er go lisp in #haskell-offtopic !
14:36:06 <mauke> indeed
14:36:08 <ertes> fizruk: not sure what you mean
14:36:15 <EvanR> go go to 
14:36:18 <Lokathor> shapr, any editor that can insert spaces when you press Tab, and that can copy the last line's initial indentation when you press enter
14:36:27 <shapr> nmdanny: Have you tried eclipse and its Haskell plugins?
14:36:28 <mauke> shapr: except #haskell-blah
14:36:33 <EvanR> Lokathor: i disable that every time
14:36:34 <Cale> oh, of course, have to set the option to expand tabs to spaces :D
14:36:37 <nmdanny> no I have not
14:36:41 <Lokathor> EvanR, which part?
14:36:46 <EvanR> auto indent, it drives me nuts
14:36:54 <ertes> fizruk: (Producer a) and (FreeT ((,) a)) are both "effect, then produce, repeat", until they end production
14:36:56 <Lokathor> i write too many long do-blocks
14:37:02 <shapr> nmdanny: I've heard eclipse supports Haskell, though I've not tried it myself. I've also heard that Eclipse is friendly to new users.
14:37:09 <EvanR> i try to not use more than 1 or 2 levels of indent
14:37:13 <nmdanny> I would prefer using IntelliJ but is it as good as ecllipse in regards to haskell?
14:37:17 <StarsC> nmdanny: did u wander why every editor tries to "beat" emacs and vim?
14:37:23 <shapr> nmdanny: I don't know, compare them and tell us?
14:37:29 <shapr> nmdanny: that would be good to know
14:37:31 <Lokathor> EvanR, they're not heavily intented exactly, they're just many many lines long. also case statements and such
14:37:48 <EvanR> if its a huge case or something, might as well use code to generate it ;)
14:37:59 <Lokathor> nmdanny, the biggest Haskell for eclipse plugin is actually no longer in development i heard >_>
14:37:59 <EvanR> rather than constant factor keyboard input tricks
14:38:18 * deepfire screams something about monomorphic profunctors
14:38:33 <nmdanny> ok basically what I want is sublime text so I'll drop discussing emacs and vim because thats not gonna happen for me
14:38:37 <ertes> i don't know if it's a bug or a feature, but i think the best ways to write haskell code right now are emacs and vim
14:38:42 <nmdanny> but......sublime-haskell does not work for me
14:38:44 <fizruk> ertes: yeah, and Writer is just "effect then produce", you lose the explicit "semicolon" between individually produced values ("tell"s)
14:38:53 <nmdanny> some problem with the hsdev connection
14:38:54 <Lokathor> ertes, it's a bug for sure
14:39:28 <ertes> emacs (and as i heard, vim) give you pretty much full haskell IDEs with everything from identifier lookup to builtin interpreters
14:39:29 <StarsC> nmdanny: look at repos activities on github and make an informed decision, haskell-mode repo.
14:39:46 <mauke> I could write haskell in notepad, so notepad++ would probably work nicely
14:39:47 <ertes> complete with debugging features, etc.
14:40:06 <nmdanny> the thing is with emacs is that I don't want to learn all those keybinds etc..
14:40:16 <nmdanny> and modes modals and whatnot which I have no idea what is..
14:40:31 <ertes> fizruk: yeah…  Writer is more like computing a single "side value"
14:40:40 <ertes> i don't think of it as a list/stream producer at all
14:40:55 <nmdanny> I want smooth scrolling, menubars instead of keybindings, traditional keybindings aka ctrl c, ctrl f etc.. cursors..
14:40:59 <EvanR> nmdanny: the way i learned vim was on the job, by being pissed off at editors other people used. so maybe thats the best way, under pressure
14:41:07 <deepfire> nmdanny: emacs has CUA-mode, which is geared to replicate the usual C-x/C-c/C-v shenanigans
14:41:07 <ertes> fizruk: also its strictness properties make it almost useless in practice
14:41:07 <EvanR> to learn an editor
14:41:16 <mauke> nmdanny: which tradition for ctrl-c? :-)
14:41:20 <StarsC> EvanR: he is not ready yet :)
14:41:29 <nmdanny> ok but cua-mode would only work for stock emacs
14:41:41 <deepfire> what do you mean?
14:41:41 <nmdanny> and now if I install a bunch of haskell packages, they have their own crazy keybindings
14:41:50 <EvanR> menu bars are definitely a pain in the ass to use
14:41:57 <EvanR> and necessarily feature incomplete
14:42:11 <deepfire> indeed..
14:42:16 <nmdanny> I don't need complex stuff, just things such as, show me the type of the expression that I selected with my cursor
14:42:17 <EvanR> mouse wheeling, slow, repetitive stress injury prone
14:42:23 <nmdanny> or, lint the file, check the file, etc..
14:42:25 <mauke> haha
14:42:28 <ertes> nmdanny: emacs will quickly teach you the value of keyboard control…  i've disabled emacs' menubar a long time ago =)
14:42:44 <inkjetunito> nmdanny: have you tried the haskell modes of some "common" editors like kate or gedit?
14:42:51 <ertes> nmdanny: in other words: you can have it, if you want, but you probably don't in six months from now =)
14:43:13 <ertes> nmdanny: the menubar is active by default
14:43:19 <mauke> nmdanny: "type of selection" sounds far more complex than all of vi :-)
14:43:33 <EvanR> i had that in vim
14:43:38 <nmdanny> atom for example supports most of what I want but its kinda slow and doesnt always work
14:43:39 <EvanR> for clojure though
14:43:45 <mauke> EvanR: using external tools, I hope
14:43:54 <EvanR> fireplace 
14:44:03 <EvanR> or whatever its called
14:44:08 <mauke> because writing a type checker in vimscript wouldn't be fun
14:44:11 <deepfire> nmdanny: emacs menus are populated with haskell stuff, although how complete that population is remains open to judgement
14:44:16 <EvanR> no it called out to the jvm
14:44:17 <ertes> (none of what i say implies that emacs is better than vim, btw…  i just don't have much vim experience)
14:44:28 <nmdanny> and my C drive just ran out of space.. I guess that happens when trying a bunch of LTS versions..
14:44:47 <nmdanny> windirstat to the rescue
14:44:48 <EvanR> engage the C drive, warp 10
14:45:04 <maerwald> ertes: objectively... the emacs plugin system is less shaky, but most of the rest boils down to opinion
14:45:24 <deepfire> watch the C-beams, glitter in the dark, off the Tannhauser's gate..
14:45:26 <nmdanny> ok suppose I do want to try emacs..I saw a thing called spacemacs which looks pretty, should I get that one?
14:45:29 <zennist> in haskell, for function without any arguments - does the compiler optimize it such that multiple invocations only actually compute once?
14:45:48 <ertes> maerwald: i guess…  i did try "EVIL mode" (vim in emacs) a few months ago, and it wasn't for me
14:45:49 <mauke> zennist: all functions have exactly one argument
14:45:50 <EvanR> no such thing!
14:45:53 <Lokathor> zennist, you mean constant values? well, "it depends"
14:45:56 <mauke> zennist: if it doesn't have arguments, it's not a function
14:45:58 <EvanR> a function with no arguments is not a function
14:46:17 <ertes> i prefer the more "immediate" editing mode of emacs, but that's entirely personal
14:46:19 <zennist> guys chill - I was talking about things like 'def' from Data.Default
14:46:30 <EvanR> :t def
14:46:31 <lambdabot> Default a => a
14:46:38 <zennist> would you say it's a function or a value..? I think it's a function because that's inside a typeclass
14:46:43 <fizruk> polymorphic constant
14:46:45 <Lokathor> :t state next
14:46:46 <lambdabot> (MonadState s m, RandomGen s) => m Int
14:46:53 <Lokathor> that won't be computed "just once"
14:46:56 <mauke> zennist: ah. that depends on which level we're talking about
14:46:58 <Lokathor> :t 3 * 5 :: Int
14:46:59 <lambdabot> Int
14:47:00 <ertes> zennist: the rule of thumb is: everything that has a name (in scope) will only be computed once…  this is called sharing
14:47:02 <Lokathor> that will be computed just once
14:47:17 <ertes> zennist: computed multiple times:  f 5 + f 5
14:47:26 <jle`> zennist: ghc doesn't automaticlaly memoize functions
14:47:26 <ertes> zennist: computed once:  let x = f 5 in x + x
14:47:38 <mauke> all of your answers are missing the point
14:47:49 <EvanR> theres nothing to memoize about def
14:47:50 <zennist> so basically, if I have a function that invokes 'def' multiple times with the same parameterized type - I actually need to do let d' = def to get sharing..!?
14:47:56 <ertes> zennist: if it doesn't have a name, in some rare cases GHC will still perform common subexpression elimination, but you definitely shouldn't rely on it
14:48:12 <nmdanny> so if I want to begin with emacs, should I get spacemacs or just a stock emacs install?
14:48:30 <ertes> zennist: 'def' is slightly tricky, because while it's not a function semantically, technically it is one
14:48:33 <EvanR> shouldnt the dictionary contain the constant for def ?
14:48:35 <zennist> when you guys say 'name', is there an exact definition?
14:48:38 <mauke> zennist: do you actually use def in a polymorphic context?
14:48:39 <ertes> nmdanny: stock
14:48:50 <Lokathor> nmdanny, http://lpaste.net/162502 this is what my emacs config looks like, and I also have an emacs extension that enables tabbed file editing like chrome/firefox/etc
14:48:56 <EvanR> the CAF rather
14:49:30 <nmdanny> ugh why does that file have so many parens
14:49:41 <nmdanny> why don't they use something more normal like JSON
14:49:44 <zennist> mauke: what I really mean is I would have a function that takes Default a => ... -> a ; but within it 'def' is going to be the same value everywhere 
14:49:49 <ertes> zennist: a name is an identifier, and there are a few constructs that introduce them:  'let', 'where', pattern-matches ("f x = ..."), lambdas ("\x -> ...")
14:50:02 <mauke> nmdanny: this is executable code. (...) is lisp syntax for function calls
14:50:18 <ertes> zennist: to make sure that sharing is used with 'def', you should give it another name:  "let x = def in ... x ... x ..."
14:50:28 <mauke> ertes: wtf
14:50:48 <zennist> ertes: alright I see; it's hard to believe that the compiler doesn't do this sort of optimization though: given the functional guarantee of having the same output for a given input, it would be similar to compute something twice
14:50:52 <fizruk> zennist: I would say that multiple uses of def with the same type should share value at runtime, so you don't need let x = def in ...
14:50:55 <nmdanny> which emacs should I get, i386 or i686
14:51:02 <mauke> zennist: ok, that might actually do a runtime lookup (depending on how you use it), but what computation is there that you'd want to share?
14:51:36 <ertes> zennist: GHC can't do CSE in general, because of laziness: it would end up producing worse code in a lot of cases
14:51:37 <zennist> fizruk: but according to the definition of 'name' by ertes just now that doesn't seem to constitute as an 'identifier'
14:51:40 <mauke> zennist: for each type, def is a constant. there's no computation behind it, so to speak
14:51:42 <EvanR> if def was an infinite list, then i can see how not restarting the CAF would be bad
14:51:59 <EvanR> and it should be up to the programmer to control sharing
14:52:01 <arahael> nmdanny: #emacs
14:52:31 <EvanR> constants can be arbitrarily expensive to compute
14:52:40 <EvanR> or infinite
14:53:05 <zennist> right - but if it's a constant anyway can't the compiler just computes it at compile time and plugs it in
14:53:08 <ertes> zennist: if you look at 'def's type:
14:53:08 <ertes> :t def
14:53:09 <lambdabot> Default a => a
14:53:14 <EvanR> zennist: no, see above
14:53:17 <mauke> zennist: yes, if the type is known
14:53:33 <EvanR> top level ones = 1 : ones
14:53:35 <zennist> yeah - as each invocation of any function has a known type - right?
14:53:52 <ertes> this is not a function…  however, in terms of sharing, unless it's specialised (either by MR or by an explicit type signature), it is treated like a function
14:53:54 <zennist> so the compiler can theoretically just sub in the right constant at each use site
14:53:57 <mauke> also, you're getting contradictory answers because everyone is talking about slightly different things
14:54:15 <StarsC> nmdanny: http://haskell.github.io/haskell-mode/manual/latest/
14:54:39 <EvanR> zennist: CSE is not necessarily the right thing to do, performance wise, so its not automatic
14:54:40 <ertes> zennist: i think it would be best, if you just pasted code
14:54:45 <mauke> nmdanny: i686 is pentium pro (or better)
14:55:11 <ertes> zennist: and as said, in a lazily evaluated language like haskell CSE will do the wrong thing very very often
14:55:18 <ertes> and by "wrong" i mean terribly wrong
14:55:29 <ertes> it may make your code asymptotically worse
14:55:35 <mauke> sure, but that doesn't apply to def
14:55:41 <EvanR> it could
14:55:42 <zennist> okay my real code is about a package called Data.Enumerate that automatically derives Enum (like) instances from Generics which allow for Sum types
14:55:52 <StarsC> nmdanny: https://github.com/emacs-tw/awesome-emacs
14:55:54 <ertes> mauke: i'm just explaining why GHC doesn't do CSE in general
14:55:56 <EvanR> if def was an infinite list and saved in the one dictionary for a type
14:55:59 <EvanR> growing without bound
14:55:59 <shachaf> I hope it doesn't make my code asymptomatically worse.
14:56:04 <zennist> its typeclass has a single function which is like: enumerated :: [a]
14:56:11 <arahael> mauke: funny how "or better" implies compatibility ;)
14:56:21 <zennist> but the actual code does a lot of 'things' as I can see from the code to get that list
14:56:37 <c_wraith> shachaf, if it was asymptomatic, how would you even notice? 
14:56:53 <mauke> INTUITION
14:57:03 <EvanR> zennist: i would hope that rebooting this CAF each time is what ghc does
14:57:05 <zennist> if I could be sure that the compiler is smart enough to 'share' this value among the invocations of the same type that would save a bit of extra typing for me
14:57:20 <zennist> EvanR: what is 'CAF'?
14:57:23 <EvanR> otherwise it could fill memory with no way to do anything about it
14:57:30 <ertes> zennist: for things that have a name, most of the time it will do the right thing
14:57:46 <deepfire> so, have anyone heard of how to apply profunctors to monomorphic types -- akin to mono-traversable?
14:57:47 <EvanR> zennist: constant applicative form, what youre calling a function
14:57:58 <EvanR> with no arguments
14:58:25 <shachaf> c_wraith: That's exactly the issue.
14:58:44 <shachaf> deepfire: What would that mean?
14:58:51 <ertes> zennist: for things that you explicitly gave a name yourself, it will always do the right thing (if sharing is the right thing)
14:59:11 * c_wraith makes all of shachaf's code asymptomatically worse. 
14:59:13 <EvanR> zennist: consequently, this is why Default and def are annoying more often than useful, if you had passed in the def value instead of using a type class youd be done by now ;)
14:59:40 <ertes> zennist: the value "f x" doesn't have a name, but the individual "f" and "x" do…  if you refer to a value by a name, it will be shared in most cases
14:59:58 <zennist> haha - but I'm too lazy to remember all the names of those default values
15:00:13 <EvanR> you could pass it it and call it def
15:00:56 <EvanR> ertes: the point here being, does that rule help when its a type class method
15:00:58 <ertes> (Default is such a weird concept anyway…  in all the cases i can make sense of "default" it just coincides with "identity element of this monoid")
15:00:58 <zennist> I just thought a bit more and it's less clear to me that the compiler would do the right thing for it... if I invoke 'def' multiple times inside the same function - they still can be of different types
15:01:11 <ertes> EvanR: for def i wouldn't care =)
15:01:12 <fizruk> EvanR: would it start share CAF with {-# NOINLINE #-} ?
15:01:27 <EvanR> i dont see how inline matters here
15:02:06 <zennist> so the compiler needs to make sure: 1. def is invoked multiple times with the same function name (which is); 2. each def that needs to share value should have the same type
15:02:17 <EvanR> zennist: well it goes to some dictionary, one for each type
15:02:32 <fizruk> EvanR: not sure, but I hoped it could force sharing
15:03:02 <ertes> zennist: i'm pretty sure GHC will do the right thing, particularly because 'def' is usually just a very simple value without much computation
15:03:05 <EvanR> fizruk: for polymorphic Default, wouldnt this inline amount to... inlining the lookup to the dict, which should already happen?
15:03:08 <zennist> alright I imagine I'm mostly convinced now
15:03:18 * hackagebot enumerate 0.1.0 - enumerate all the values in a finite type (automatically)  https://hackage.haskell.org/package/enumerate-0.1.0 (sboo)
15:03:31 <fizruk> EvanR: no, I meant NOINLINE for specific instance
15:03:33 <ertes> zennist: but if you want to make sure that it's shared, you can always give it a name with a monomorphic type signature
15:03:37 <EvanR> oh
15:03:52 <ertes> zennist: let myDef = def :: MyType in ...
15:04:01 <zennist> yes - that would be the safest option
15:04:08 <EvanR> you can also pass it in as an argument
15:04:10 <ertes> zennist: is your value that expensive?
15:04:14 <EvanR> f (def :: MyType)
15:04:32 <ertes> EvanR: if it comes as an argument, you don't need the type signature
15:04:42 <EvanR> maybe not
15:04:49 <zennist> yeah as I said it's actually about an 'enumerated :: [a]' polymorphic constant that can be very expensive to generate
15:04:59 <ertes> and even with 'let' you won't need it most of the time (MR)
15:06:01 <EvanR> ertes: im not sure it makes sense to guess at compiler functionality for a specific type class just because we dont like that class
15:06:11 <EvanR> this question about sharing trascends Default
15:06:47 <ertes> EvanR: i know…  that was just a side note =)
15:06:56 <EvanR> like, what about many mempties
15:08:38 <ertes> also i understand the practical value of defaults, but i always try to find a monoid that has my desired default as its identity
15:09:02 <ertes> and if i can't, then Default seems like a weird thing to use…  why not just a regular top-level definition?
15:09:10 <ertes> defConfig :: Config
15:09:30 <EvanR> yet another misguided use case for type classes!
15:09:42 <EvanR> i want a list of guided use cases, "typeclasses the good parts"
15:10:53 <ertes> this is actually an entirely practical consideration…  i see the value of defaults, but not the value of Default
15:11:37 <ertes> it seems like just an annoying dependency i need in my cabal file most of the time, and an import for every source code file
15:11:46 <ertes> "def" is short, but most of the time i end up typing more
15:12:00 <fresheyeball> anyone know how to tell stack where to put binaries?
15:12:15 <fresheyeball> as in `stack build --copy-bins /my/custom/dist` ?
15:13:58 <mgsloan> "stack build --local-bin-path /my/customn/dist"
15:14:17 <mgsloan> (documented in "stack --help")
15:15:49 <EvanR> ertes: for a "function polymorphic a default" a short named argument is shorter and more flexible
15:15:55 <EvanR> in a default*
15:16:20 <EvanR> :t maybe
15:16:21 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:16:53 <EvanR> Default b => (a -> b) -> Maybe a -> b
15:18:30 <ertes> EvanR: i don't see the value of such a function for exactly the same reason…  neither have i ever used such a function
15:18:40 <ertes> maybe defConfig  -- seems fine to me
15:23:19 * hackagebot fast-tagsoup 1.0.11 - Fast parser for tagsoup package  https://hackage.haskell.org/package/fast-tagsoup-1.0.11 (VladimirShabanov)
15:23:59 <REDDITMAN> hi
15:24:03 <REDDITMAN> anyone use spock?
15:24:22 <REDDITMAN> i'm trying to programmatically generate routes but I'm not sure how to do it
15:25:02 <EvanR> ertes: right
15:25:26 <EvanR> i think such use of typeclasses makes code harder to read
15:26:06 <REDDITMAN> EvanR really how so?
15:26:53 <EvanR> because if you see maybe defConfig you know whats going on
15:27:29 <EvanR> if you see maybe... then you have to go get the type signature
15:27:37 <EvanR> and guess at how its being used
15:27:56 <EvanR> replacing arguments with typeclasses can have this effect, you arent sure how the typeclasses is supposed to work
15:28:09 <ertes> yeah
15:28:25 <EvanR> and you have to use newtypes to modify the behavior
15:28:30 <ertes> now if the default library came with a reasonably large selection of such functions, and you would actually want to use them in your code, that would change things
15:28:48 <ertes> but for something like 'def' there really isn't much you can provide
15:32:46 <enthropy> the point of having def in a library is that it might be a standard name and choosing between defConfig vs. defConf vs. defConfiguration vs. Some.Other.Qualification.defConfiguration is more work than it seems
15:34:50 <ertes> enthropy: in that sense 'def' is like a convention, and you have to look it up just like any other convention
15:34:59 <ertes> defTypeName would be a better convention IMO
15:37:05 <enthropy> right it's one convention. But it's the same convention in the packages that use that data-default-class (diagrams and xmonad come to mind)
15:41:29 <enthropy> compare it with what you get from a library like Cabal: http://hackage.haskell.org/package/Cabal-1.22.8.0/docs/doc-index-D.html , where sometimes the defaultFoo :: Foo
15:42:41 <enthropy> or it's a record accessor, or just a function to get something
15:43:51 <fr33domlover> Why does this make GHC say it requires UndecidableInstances? instance TimeInterval i => IntervalToEventTime i where
15:44:51 <fr33domlover>  Constraint is no smaller than the instance head
15:44:54 <fr33domlover>           in the constraint: TimeInterval i
15:44:56 <geekosaur> yes
15:45:01 <geekosaur> and it overlaps all instances
15:45:15 <geekosaur> the context is noit part of instance selection
15:45:19 <dfeuer> On GHC, what's the absolute smallest amount of memory a Map of size N can use? Assume all the keys are of type Int and all the values are of type ().
15:45:45 <Enigmagic> then use IntMap ;-)
15:45:52 <REDDITMAN> I'm a bit stuck here
15:45:54 <REDDITMAN> http://lpaste.net/162512
15:45:57 <geekosaur> it does not mean "any TimeInterval i is an IntervalToEventTime i". it means "every type is an IntervalToEventTime, but when you go to use it check if the type has a TimeInterval instance"
15:46:01 <REDDITMAN> trying to generate routes programmatically
15:46:11 <REDDITMAN> in Spock instead of hardcoding them
15:46:29 <REDDITMAN> but I'm not sure how to express an "unrolled" spock monad type
15:46:30 <Axman6> probablt ~6N words
15:46:35 <Axman6> probably*
15:46:46 <dfeuer> Enigmagic, I'm using a two-word bitstring to implement a version of `at` inside Data.Map.Base. I need to know when I have to worry about overflowing that bit string.....
15:47:25 <fr33domlover> geekosaur, is there a way to do the former then? or is my approach what you'd normally do
15:47:47 <dfeuer> Axman6, so .... one word overhead per node, plus one word overhead per key? How do the leaves play into it, or does GHC do some bit magic to make them free somehow?
15:49:02 <Axman6> the keys and values both have one word headers, plus one word of data, then each node in the tree has: one header, one word pointing to the key and one word pointing to the value, so maybe 5N words
15:49:09 <Axman6> 6 was a rough guess =)
15:49:44 <Axman6> there are also tools which can tell you this
15:50:21 <phooby> hey, any idea if pcre-heavy library allows you to set verbose mode somehow with the regexes? would be great to span complex regexes to multiple lines instead of one-liners ;)
15:50:58 <fr33domlover> phooby, check out regex-applicative too
15:51:05 <dfeuer> Axman6, the values are all pointing to the same object in this hypothetical, but there are two child pointers unless maybe the ones at the bottom don't have those.
15:51:14 <Axman6> phooby: or use the right tool for the job, use a parser ;)
15:52:20 <Axman6> dfeuer: see http://stackoverflow.com/questions/3254758/memory-footprint-of-haskell-data-types and http://blog.johantibell.com/2011/06/computing-size-of-hashmap.html
15:52:45 <phooby> thanks for the tips, guys!
15:53:54 <Axman6> phooby: patrser combinators are more readable, composable and more powerful than regexes. it's very rare that a regex is the right tool for the job
15:54:03 <phooby> i was thinking of going the parser route. the problem is, i already have written a substantial amount of 'em regexes for this and wouldn't want to rewrite them all :p
15:54:25 <Axman6> you'll thank yourself when you do
15:55:16 <ski> fr33domlover : can't you define the members of `IntervalToEventTime' as stand-alone operations, with a context in terms of `TimeInterval' ?
15:55:44 <fr33domlover> ski, I would but I need more instances
15:56:00 <fatex> do we have cuda+blas lbindings for haskell? in particular, I want to run blas operaitons on cuda on nvidia gpu, and I want to do this in a Haskell DSL
15:56:23 <ski> fr33domlover : oh, i suppose you mean for another class than `TimeInterval', which you intend to keep disjoint from it ..
15:57:36 <dfeuer> I can count on one word key pointer, one word key value, one word value pointer, and for all internal nodes I can count on two words child pointers. I imagine GHC probably actually has the child pointers even for childless nodes? Measuring the size isn't really sufficient, because the trees could have various weird shapes and if I overflow my queue then users silently get wrong answers.
15:57:42 <fr33domlover> ski, I defined the IntervalToEventTime class and I need instances for several time libraries - TimeInterval is from hourglass, then there's NominalDiffTime from 'time' and 'TimeSpec' from 'clock'
15:58:06 <fr33domlover> i suppose that UndecidableInstances thing is the usual way to make the code build... :P
15:58:26 <Axman6> dfeuer: "Can I count on..." no, it could change at any time
15:59:05 <ski> fr33domlover : well, `UndecidableInstances' won't help you making also `instance NominalDiffTime i => IntervalToEventTime i' and `instance TimeSpec i => IntervalToEventTime i'
15:59:42 <ski> fr33domlover : because they'll overlap, and you'll have no way to disambiguate
15:59:46 <fr33domlover> ski, iirc TimeSpec and NominalDiffTime are both types, not classes :P
15:59:54 <ski> oh, i see
15:59:58 <fr33domlover> ski, but then how does it work in mtl etc.?
16:00:02 <dfeuer> Axman6, I'm thinking of realistic implementations. Unless the representation of the tree changes with the key type, I can be pretty sure of those, I think....
16:00:25 <ski> fr33domlover : still, i think overlapping instances is usually a bad idea
16:01:12 <fr33domlover> ski, I mean stuff like this from transformers:
16:01:15 <fr33domlover> Applicative m => Applicative (ReaderT * r m)
16:01:18 <dfeuer> Overlapping instances should be replaced with a different mechanism. There was some work on one a few years back, but the project it was part of died.
16:01:44 <ski> fr33domlover : but that has decreasing constraints, so that's not a problem
16:02:26 <fr33domlover> ski, hmmm then how can I say "make a IntervalToEventTime instance for each TimeInterval instance"?
16:02:32 <ski> fr33domlover : the pattern `ReaderT * r m' (on the right) is strictly larger than the pattern `m' (on the left)
16:02:35 <fr33domlover> or is there no way?
16:03:10 <ski> fr33domlover : i'm not sure there is a way, except by enumerating every (known) `TimeInterval' instance :/
16:03:27 <fr33domlover> in this specific case I happen to have a workaround, but just wondering about the general case...
16:04:18 * fr33domlover was hoping type sorcery has a solution
16:05:18 <ski> fr33domlover : however, to help with that, it could help with making an opreation which can be used as s default implementation of the method (or methods) of `IntervalToEventTime', in terms of `NominalDiffTime', so that users which need an instance of `IntervalToEventTime' which you haven't anticipated can just write an implementation with the method set to this default operation
16:05:56 <ski> fr33domlover : this is similar to saying e.g. `instance Applicative Foo where pure = return; (<*>) = ap', assuming you've already written a `Monad' instance for `Foo'
16:06:31 <ski> hm, actually ..
16:06:41 <fr33domlover> ski, indeed that is my workaround: I have "instance IntervalToEventTime Seconds" and then you can use "toSeconds" to convert any TimeInterval i to Seconds
16:06:50 <fr33domlover> so in my case I'm not worried
16:08:10 <ski> fr33domlover : i think you could use <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#class-default-signatures> to avoid users having to manually mention that default operation
16:08:26 <ski> fr33domlover : but they'd still have to manually write `instance IntervalToEventTime Seconds'
16:09:19 <fr33domlover> ski, I am writing that instance
16:09:30 <fr33domlover> I mean people can just call 'toSeconds' manually
16:09:40 <ski> fr33domlover : .. obviously this wouldn't work in case there'd be more than one such defult that you'd like to make
16:09:46 <fr33domlover> and then get a Seconds value which has the instance I wrote etc.
16:10:16 <ski> fr33domlover : *nod*, just saying that you can actually avoif the "people can just call 'toSeconds' manually" step
16:10:59 <fr33domlover> ski, that's good to know :) in my trivial case though i'll keep things simple
16:11:25 <fr33domlover> the only instance I really need is the Seconds one actually
16:11:43 <fr33domlover> (i mean among the TimeInterval instances)
16:14:11 <dfeuer> Axman6, another question? What do you think are the chances that someone's going to make a Data.Map.Map with over 5524345252318620 elements in the next 10 years?
16:15:25 <kadoban> dfeuer: Pretty close to zero?
16:16:24 <dfeuer> kadoban, I just don't want to make trouble if that's realistic :P
16:16:44 <pavonia> That's more than 17 million new entries per second :p
16:17:00 <pavonia> for the next 10 years, nonstop
16:17:02 <kadoban> dfeuer: I think I missed the context, but just on the face of it that sounds … hard.
16:17:16 <kadoban> Yeah, the orders of magnitude just don't appear to match up with reality.
16:17:51 <dfeuer> kadoban, sweet. That's what I wanted to hear. I don't want to waste time checking for something that's not going to happen.
16:18:26 * ski isn't really fond of encoding the physical unit (as opposed to the physical dimension) in the type
16:18:30 <erisco> is there a reason bimonads are not in a package other than someone hasn't put it together yet?
16:24:12 <johnw> erisco: and no compelling reason to?
16:25:00 <EvanR> bimonad? is that just two monads at once?
16:25:14 <tomleb> Any resource on when to use $ and when to use (.) and when to use f1 (f2 n) ?
16:26:05 <erisco> johnw, bifunctors and biapplicatives are compelling but not bimonads?
16:30:04 <bergey> tomleb: I tend to use `f $ g x` if one $ is enough, `f . g . h $ x` rather than multiple $, and ()s if it's not all right-associative.
16:30:46 <bergey> But sometimes I find ()s more readable even when that heuristic wouldn't say so.  *shrug*
16:31:03 <EvanR> liking (f . g . h) x is i can remember to open a paren
16:36:20 <tomleb> bergey: Alright, I'll try to go along with these rules then
16:40:25 <maerwald> tomleb: also mind that $ is special https://github.com/quchen/articles/blob/master/fbut.md#-has-special-powers
16:42:47 <EvanR> you could use the unspecial one if you think it would matter ;)
16:42:58 <EvanR> ($$) = id
16:53:05 <johnw> erisco: bimonads are not terribly compelling, no
16:55:06 <zRecursive> Up to now, is it practical to develop https://sourceforge.net/p/maxima/ system using haskell ?
16:56:27 <maerwald> zRecursive: I can't really follow that question. You want to rewrite maxima in haskell?
16:58:03 <tomleb> maerwald: What do you mean $ is special ?
16:58:10 <maerwald> tomleb: I gave you a link
16:58:14 <zRecursive> maerwald: no, i am curious about symbolic energy of haskell ?
16:58:27 <maerwald> zRecursive: what is symbolic energy?
16:58:43 <zRecursive> symbolic handling
16:58:59 <EvanR> haskell is good for making new languages, including symbolic ones
16:59:14 <tomleb> maerwald: Oh right sorry I'm blind
16:59:31 <EvanR> if maxima is anything like mathematica, the untyped data structure is trivial
16:59:46 <EvanR> GUI on the other hand
16:59:55 <zRecursive> EvanR: yeah, it is like mathematica
17:00:13 <maerwald> zRecursive: haskell is used in the financial industry. I believe they also write their own compilers.
17:00:38 <maerwald> the plotting and the GUI can be done too pretty easily
17:00:57 <tomleb> maerwald: Oh that's a nice link you gave me there
17:01:21 <zRecursive> maerwald: I heard of people liking math will like haskell, so haskell is called mathematican's programming language ?
17:01:33 <maerwald> I don't know about that
17:01:55 <maerwald> the default numeric stuff is actually a bit awkward, but if you do something like maxima, you're probably going your own way anyway
17:02:11 <zRecursive> i hope so
17:02:13 <maerwald> wrt numeric types etc
17:02:26 <EvanR> Integer is pretty solid
17:02:41 <EvanR> exact-real is pretty sweet too
17:03:05 <EvanR> but some transcendental functions may require more support
17:03:29 <zRecursive> Maxiam is great but its performance sucks
17:21:42 <Magnap`> Hi all! What practical differences are there between "freer" and "extensible-effects"?
17:28:01 <fr33domlover> Q: I have a function which gives a functor instance, does some fmap over the items. I have a list of 3-tuples and I'd like to apply that function only the 3rd items of the tuples. If there an existing newtype wrapper adapter for this? Or should I write one, or use unzip3 and zip3?
17:28:29 <fr33domlover> s/If there/Is there
17:31:06 <Magnap`> fr33domlover: I would make a newtype and derive the Functor instnce with DeriveFunctor
17:32:05 <Cale> fr33domlover: I wouldn't use zip at all, map is sufficient
17:32:26 <fr33domlover> Cale, but then I need a newtype wrapper
17:32:28 <Cale> map (\(x,y,z) -> (x,y,f z))
17:32:40 <Cale> Maybe I don't understand what you're doing somehow
17:32:54 <fr33domlover> Cale, there
17:32:58 <fr33domlover> oops
17:33:06 <Magnap`> Cale: I think they want to (fmap . fmap) something
17:33:22 <Magnap`> For which your function is fine
17:33:55 <Cale> Well, there is a possible Functor instance for (,,) a b which applies the given function to the third component of the triples
17:33:59 <Magnap`> But it feels a little like manually giving the Functor instance for (a,b,c)
17:34:07 <Cale> But I don't think it's in the libraries
17:34:24 <EvanR> triples are wildly unpopular!
17:34:35 <EvanR> they dont even have projections
17:34:42 <Magnap`> I just checked: GHC derives it if you make a newtype Triple a b c = Triple (a,b,c) deriving (Functor)
17:35:00 <Cale> Well, to be fair, the lambdas for the projections are clearer than any other naming scheme
17:35:43 <Magnap`> fr33domlover: The usual "common wisdom" is that you should have a record rather than an n-tuple
17:36:02 <EvanR> also (a,(b,c)) or ((a,b),c) ...
17:36:11 <EvanR> or a proper data type
17:36:15 <Magnap`> ^
17:37:12 <fr33domlover> Magnap`, this is for temporary use before I convert to a record. Actually if the Functor instance exists, it lets me avoid writing the wrapper :P
17:37:26 <fr33domlover> which for the record type, i'd have to write
17:38:01 <Magnap`> If it's just for temporary use, I agree with Cale that you should just fmap (\ (a,b,c) -> (a,b, f c))
17:39:35 <fr33domlover> Magnap`, but I don't have access to the function, that's the idea
17:39:45 <fr33domlover> I have an existing function:
17:39:47 <EvanR> fr33domlover: you can do standalone deriving and DerivingFunctor
17:39:50 <EvanR> but really...
17:40:11 <fr33domlover> f :: Functor t => t T1 -> t T2
17:40:26 <fr33domlover> suppose I don't want to copy stuff from the source code of f
17:40:37 <Magnap`> And then you have a [(a,b,c)]?
17:41:01 <EvanR> you can still use f
17:41:04 <fr33domlover> yep, suppose I have [(Int, Int, T1)]
17:41:06 <EvanR> using Identity
17:41:42 <fr33domlover> EvanR, can you plz given an example?
17:41:43 <Magnap`> Yeah, then you'll need to make it a Functor
17:41:45 <EvanR> > map (\(x,y,z) -> (x,y,asIdentity f z))
17:41:47 <lambdabot>      Not in scope: ‘asIdentity’
17:41:47 <lambdabot>      Perhaps you meant one of these:
17:41:47 <lambdabot>        data constructor ‘Identity’ (imported from Control.Monad.Identity),
17:42:06 <EvanR> asIdentity f = getIdentity . f . Identity
17:42:26 <EvanR> it might be even simpler than that
17:42:55 <fr33domlover> it's definitely simple to use unzip3 here :P
17:43:06 <EvanR> :t unzip3
17:43:07 <lambdabot> [(a, b, c)] -> ([a], [b], [c])
17:43:07 <Magnap`> EvanR: I think they have a function "[f a] -> [f b]" and they want to apply it to a "[(b,c,a)]"
17:43:08 <fr33domlover> dunno about efficiency, but it's simple 
17:43:35 <EvanR> Magnap`: well, im tired of trying to guess at whats going on
17:43:49 <EvanR> it seems rather simple any which way
17:43:54 <Magnap`> Agreed
17:44:19 <fr33domlover> I gave you the signature above actually :P
17:44:32 * Magnap` continues trying to pick a library for algebraic effects
17:44:34 <EvanR> f :: Functor t => t T1 -> t T2
17:44:38 <EvanR> t = Identity, done
17:44:53 <EvanR> asIdentity f is now a normal function
17:45:01 <fr33domlover> EvanR, I want to use 'f' where t is list
17:45:08 <EvanR> then
17:45:10 <fr33domlover> I have a list of triples
17:45:19 <fr33domlover> and I want f applied on the 3rd items of them
17:45:34 <EvanR> why do you want to use t = list?
17:45:55 <fr33domlover> EvanR, because I have a list (Int, Int, T1) given as input
17:46:04 <EvanR> yeah, which is the wrong type
17:46:16 <fr33domlover> and I need to apply 'f' on the 3rd items to produce a list of (Int, Int, T2)
17:46:28 <EvanR> you cant apply f to the 3rd item if t = list
17:46:35 <EvanR> you can if t = identity
17:46:44 <fr33domlover> EvanR, unless I use a newtype which has a Functor instance
17:46:55 <fr33domlover> or I unzip3, apply 'f' and then zip2
17:46:58 <EvanR> Identity already exists
17:47:13 <Magnap`> fr33domlover: then make "newtype Triple a b c = Triple {fromTriple :: (a,b,c)} deriving (Functor)" and then "fmap (fromTriple . f . Triple)" over your lsit
17:47:19 <EvanR> and i would think unzip rezip is less efficient
17:47:32 <Magnap`> newtypes are free!
17:47:44 <EvanR> also standalone deriving functor for triples
17:47:51 <EvanR> all of this seems overkill for "quick and dirty"
17:48:29 <Magnap`> EvanR: orphan instances...
17:48:50 <EvanR> this discussion isnt even justified for quick and dirty ;
17:48:56 <fr33domlover> thanks for all the input :)
17:49:05 <Magnap`> fr33domlover: It sounds like that triple should be a real data type instead
17:49:39 <Magnap`> Now, anyone who has some opinions on the various libraries for extensible effects based on free monads?
17:51:05 <zRecursive> `cabal.exe install -j random` => Configuring random-1.1...\n fd:4: hGetContents: invalid argument (invalid byte sequence)\n cabal.exe: fd:4: hGetContents: invalid argument (invalid byte sequence)\n cabal: Leaving directory 'c:\TEMP\cabal-tmp-196\random-1.1' \ncabal.exe: Error: some packages failed to install:
17:51:54 <zRecursive> I have not encountered such a problem before :(
17:52:29 <hpc> i really hope this doesn't fix it, but try without -j?
17:52:52 <hpc> (if that fixes it, imo that means there's a problem with -j)
17:53:16 <zRecursive> no, `cabal.exe install random` is same
17:58:12 <zRecursive> `stack.exe install random` => Run from outside a project, using implicit global project config\n TlsExceptionHostPort (HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa))) "www.stackage.org" 443
18:06:05 <ElMoloko1> what version of GHC and stack do you have?
18:06:13 <ElMoloko1> also, https://groups.google.com/forum/#!topic/stackage/jQ4fe9MbFmI
18:06:53 <zRecursive> ElMoloko1: ghc-7.10.3 on win32
18:07:17 <zRecursive> stack-1.1.0-windows-i386-installer.exe
18:14:29 <ElMoloko1> http://windows.microsoft.com/en-us/windows-vista/view-or-manage-your-certificates
18:15:16 <ElMoloko1> see if you have a globalsign root ca
18:17:57 <zRecursive> ElMoloko1: where to find globalsign ?  
18:18:39 <zRecursive> oh, find it
18:19:33 <ElMoloko1> http://globalsign.tbs-certificats.com/gsorganizationvalsha2g2r1.crt
18:20:02 <ElMoloko1> oops
18:20:04 <ElMoloko1> https://secure.globalsign.com/cacert/gsorganizationvalsha2g2r1.crt
18:20:19 <ElMoloko1> Better to dl straight from globalsign :P
18:21:19 <zRecursive> thanks !
18:24:42 <mathu> i'm not entirely clear on the differences between forkOS and forkIO. is it simply that forkOS produces a kernel-schedulable thread/process while forkIO is a purely userland one?
18:25:31 <ElMoloko1> @zRecursive, that should potentially fix the cabal install
18:25:31 <lambdabot> Unknown command, try @list
18:25:44 <ElMoloko1> zRecursive, that should potentially fix the cabal install
18:26:07 <ElMoloko1> I think you need the amazon CA for the stackage one
18:26:39 <zRecursive> thanks
18:27:39 <dcoutts> mathu: did you read the haddock docs about it? It explains bound threads
18:27:56 <ElMoloko1> can you see: https://good.sca0a.amazontrust.com/
18:28:02 <Magnap`> For anyone interested: i ended up going with https://hackage.haskell.org/package/freer
18:28:50 <mathu> dcoutts: uh, i thought i did but it doesn't sounds familiar looking at it again. 0:)
18:29:41 <dcoutts> mathu: if it's still unclear I'm sure we can clear up any remaining Qs
18:30:46 <zRecursive> ElMoloko1: i can see it
18:31:25 <zRecursive> Now `stack.exe install random` is working like a charm.
18:31:41 <ElMoloko1> did you install the CA?
18:31:44 <ElMoloko1> oh awesome!
18:32:05 <zRecursive> Yeah, i just import the download *.crt
18:48:01 <mathu> dcoutts: do you know why bound threads are still scheduled by the haskell runtime?
18:49:09 <dcoutts> mathu: I'm not sure if I get the premise. All Haskell threads are always scheduled by the RTS (on a specific capability)
18:50:00 <dcoutts> with bound threads it's just that the RTS has to switch to running the capability using the specific OS thread while it runs that Haskell thread
18:51:08 <dcoutts> mathu: remember, bound threads do not create more capabilities, so no more parallelism/concurrency than before.
18:51:32 <mathu> dcoutts: you lost me, haha. i thought a bound thread had system-level contention instead of only contending with threads inside the single user process, therefore it's somethign for the OS to schedule
18:51:46 <mathu> dcoutts: and i don't know what capabilities are in this context haha
18:51:53 <dcoutts> it's just a mechanism to make sure that whenever a particular Haskell thread is running, it's running on a specific OS thread
18:52:11 <dcoutts> e.g. so you can use C style thread local storage in FFI calls
18:52:27 <dcoutts> mathu: no, it doesn't change that at all
18:52:53 <mathu> hm
18:52:54 <dcoutts> mathu: capabilities are the RTS abstraction for using multiple cores in parallel
18:53:15 <mathu> i'll read more about this later haha. i'm tired and sick so i'll probably go watch a movie haha
18:53:24 <mathu> thank you for explaining, dcoutts!
18:53:37 <dcoutts> mathu: bound threads probably don't solve the problem you're thinking of
18:53:45 <dcoutts> mathu: what problem are you trying to solve?
18:54:39 <dcoutts> mathu: ok, bye, hope you feel better soon
18:54:54 <mathu> nothing in particular. i'm writing a bad threaded webserver for a semester project, but the prof doesn't know haskell so it doesn't have to be good haha. i was just curious, since my reading about it defies what my operating systems prof said
18:55:23 <mathu> he said you usually want kernel threads (bound threads) because your thing will get run more often since it's scheduled by the kernel
18:55:31 <geekosaur> "bound thread" in Haskell does not mean the same thing as "bound thread" in other contexts
18:55:33 <mathu> then again, he was also a goon and that class was a colossal waste of time
18:55:34 <dcoutts> mathu: you may have learned about 1:1 and M:N threading models?
18:55:45 <dcoutts> mathu: if so, the RTS implements M:N threading
18:56:00 <mathu> dcoutts: not even, haha. we didn't learn about lightweight processes at all, it was "user threads" and "kernel threads"
18:56:13 <zRecursive> However, `/ghc-7.10.3/bin/cabal.exe install random` still reports the same error as "Configuring random-1.1...\n Failed to install random-1.1\n Build log ( c:\z\Application Data\cabal\logs\random-1.1.log ):\n Configuring random-1.1...\n fd:4: hGetContents: invalid argument (invalid byte sequence)\n cabal.exe: fd:4: hGetContents: invalid argument (invalid byte sequence)"
18:56:49 <dcoutts> zRecursive: can you post a more detailed log somewhere, running with -v3? Also, do you really need random, it'll be installed already.
18:57:10 <dcoutts> mathu: ok, well bound threads are a very minor detail of the system, the big thing is capabilities and Haskell lightweight threads
18:57:11 <EvanR> mathu: you want haskell forkIO threads for you web server
18:57:31 <zRecursive> dcoutts: `/ghc-7.10.3/bin/ghc-pkg.exe | grep -i random` => Nothing
18:57:33 <mathu> we did two homework assignments with threading. one was "int threadno = pthread_create(); pthread_join(threadno); threadno = pthread_create(); pthread_join(threadno);"
18:57:51 <EvanR> yes pthreads bad
18:57:54 <EvanR> forkIO good
18:58:01 <dcoutts> zRecursive: ghc-pkg list random
18:58:04 <EvanR> (if possible, its not really possible with openGL)
18:58:09 <mathu> EvanR: yeah, i have forkIO in right now and i have my main do block preceeded with runInUnboundThread
18:58:21 <mathu> EvanR: the pthreads stuff was in C, where forkIO isn't real haha
18:58:31 <EvanR> forkImaginary
18:58:32 <zRecursive> dcoutts: `/ghc-7.10.3/bin/ghc-pkg.exe list random` => c:/ghc-7.10.3\lib\package.conf.d:\n     (no packages)
18:58:54 <dcoutts> zRecursive: ok, I guess you got one of those minimal installers
18:59:09 <zRecursive> yeah
18:59:27 * ski ponders a notion of the trivial subgroup being empty
18:59:54 <zRecursive> dcoutts: the newest cabal seems having bugs ?
18:59:59 <EvanR> what kind of group has no identity, sub or not
19:00:19 <ski> every group would have it
19:00:34 <ski> the point would be that in a certain sense, the identity "doesn't exist"
19:00:36 <dcoutts> zRecursive: I've never seen that one, could you get us a log with -v3?
19:00:51 <dcoutts> zRecursive: and let us know what env that is, msys or what
19:01:06 <zRecursive> ok
19:01:18 <dcoutts> zRecursive: the error itself is complaining about character set decoding errors. Like invalid unicode.
19:01:47 <ski> (or perhaps one could say "is part of the fabric of the underlying universe" (which is the category `Group'))
19:02:16 <Hijiri> I don't think a group can be empty, unless empty means something else in this context
19:02:51 <ski> "empty subgroup" here means the least subgroup, the intersection of all subgroups
19:03:32 <ski> just like `_|_ |- A' specifies falsum in logic
19:03:55 <Hijiri> so like an initial object?
19:04:01 <ski> yes
19:04:44 <ski> and "union" of `A' and `B' would be the least subgroup that includes both `A' and `B'
19:05:24 <ski> and the idea is to try to use set-theoretical-looking language/notation for this
19:05:39 <zRecursive> @paste
19:05:39 <lambdabot> Haskell pastebin: http://lpaste.net/
19:05:41 <ski> so the empty subgroup would be written as `{}'
19:06:16 <ski> (or `∅' if you prefer)
19:06:23 <geekosaur> zRecursive, are you sure this is a problem with cabal? we already kn ow there are damaged files (the package index, at least) being served by Hackage
19:06:43 <geekosaur> or were --- conceivably it's sorted now but there have been several reports within the past 24 hours
19:06:55 <Hijiri> it seems like it could cause ambiguity, since set notation is already used to show the trivial group as a singleton set
19:07:01 <dcoutts> geekosaur: were there? I wasn't aware of that
19:07:13 <lpaste> zRecursive pasted “abal.exe install random -v3” at http://lpaste.net/162519
19:07:28 <geekosaur> yeh, Iv'e sent two people to #hackage with reports of downloads and seen other mentions of a truncated package index being served
19:07:32 <ski> Hijiri : well, in case one must also talk about the category `Set', one could explicitly use the underlying functor
19:07:39 <geekosaur> *download errors
19:07:47 <zRecursive> geekosaur: i am not sure
19:08:10 * EvanR is now paranoid
19:09:11 <ski> anyway, the (vague) idea is that group combination could be thought of as "superposition" in some sense
19:09:21 <ski> and then the neutral element is the empty superposition
19:09:52 <ski> (and therefore it is in some sense not real)
19:10:22 <dcoutts> geekosaur: I was aware of one chap who was behind a http 1.0 proxy on free mcdonalds wifi that was getting truncated downloads. That's all.
19:11:13 <eacameron> Does GHC let you have two different instances of the same package in your build? Or does it require that there be only one instance of every package in a single build target.
19:11:40 <zRecursive> dcoutts: i am using ADSL directly.
19:11:46 <ski> i'm also thinking about attempting to relate this to a logic where `_|_' is defined to mean `forall x,y. x = y' (those variables ranging over the current group we're talking about)
19:11:48 <dcoutts> geekosaur: thanks for directing them to #hackage. The one I mentioned went astray and ended up in #haskell-ops :-)
19:12:11 <geekosaur> saw that, yes
19:12:32 <ski> EvanR : hm ?
19:13:19 <zRecursive> `cabal.exe: fd:4: hGetContents: invalid argument (invalid byte sequence)` means network problem ?
19:13:25 <NeedHelpHarry> Total haskell noob here
19:13:34 <NeedHelpHarry> can anyone offer some herp
19:13:36 <NeedHelpHarry> help
19:14:05 * ski waits for a question to appear
19:14:20 <ski> (a Haskell-related one)
19:14:49 <NeedHelpHarry> I am trying to take a list of integers, and then return a list with the integers squared
19:14:53 <NeedHelpHarry> without map
19:14:58 <NeedHelpHarry> and done recursively
19:15:01 <ski> ok
19:15:37 <NeedHelpHarry> Shall I paste what I have?
19:15:41 <ski> @paste
19:15:41 <lambdabot> Haskell pastebin: http://lpaste.net/
19:15:44 <ski> there, please
19:16:09 <ski> (if you specify #haskell as the channel, it'll automatically be announced in here)
19:17:00 <NeedHelpHarry> http://lpaste.net/162520
19:17:16 <ski> ok, i see you didn't specify the channel
19:17:47 <NeedHelpHarry> Wait me?
19:17:54 <ski> yes
19:18:01 <NeedHelpHarry> How do I do that
19:18:15 <dcoutts> zRecursive: do you have time to help debug it? I think I might know what's happening
19:18:38 <NeedHelpHarry> yeah
19:18:56 <ski> NeedHelpHarry : when pasting at that site, one of the fields you can fill in is the channel in which to announce the paste (and annotations of it)
19:19:03 <NeedHelpHarry> Oh shoot
19:19:30 <ski> NeedHelpHarry : no worry. you can try it next time :)
19:19:33 <ski> NeedHelpHarry : why is there a stray `a' in the second defining equation for `squareList' ?
19:19:43 <zRecursive> dcoutts: i wonder what's your way ?
19:19:49 <ski> your base case has a type error
19:20:04 <NeedHelpHarry> Hold on I forgot to get rid of the a!
19:20:04 <ski> and so does your recursive case, even ignoring the `a'
19:20:13 <NeedHelpHarry> How do you mean
19:20:25 <dcoutts> zRecursive: ok, cabal unpack random; cd random-1.1/; ghc Setup.hs; ./Setup configure
19:20:43 <ski> NeedHelpHarry : have you learned yet how to state a type signature ?
19:20:50 <NeedHelpHarry> No not yet
19:20:58 <ski> ok
19:21:06 <ski> look at
19:21:08 <ski>   squareList [x] = x * x
19:21:13 <ski> you said
19:21:15 <ski> <NeedHelpHarry> I am trying to take a list of integers, and then return a list with the integers squared
19:21:31 <NeedHelpHarry> so it nees brackets
19:21:34 <ski> here the input is `[x]', which is indeed a list (a list with exactly one element, namely `x')
19:21:54 <ski> so, assuming it's a list of *integers*, then `x' is in that case an *integer*
19:21:56 <ski> ok, so far
19:22:13 <ski> then, you have specified the output as `x * x'
19:22:14 <NeedHelpHarry> Ok
19:22:25 <dcoutts> zRecursive: so what I suspect is that Cabal calls gcc, and gcc is producing invalid UTF8 output
19:22:27 <ski> if `x' is an integer, then `x * x' is also an integer (namely the square of `x')
19:22:42 <NeedHelpHarry> yes
19:22:48 <ski> NeedHelpHarry : however, `squareList' is supposed to return a *list* of integers
19:22:54 <zRecursive> dcoutts: `cabal unpack` to where ?
19:23:06 <dcoutts> zRecursive: it'll unpack a dir within the current dir
19:23:11 <ski> but here you're attempting to return a single integer, in the case where the input is a singleton *list* of one integer
19:23:26 <ski> NeedHelpHarry : note that a singleton list with an element is very different from that element itself
19:23:36 <NeedHelpHarry> ok
19:23:47 <NeedHelpHarry> so should there be brackets
19:23:48 <NeedHelpHarry> ?
19:23:52 <ski> where ?
19:23:57 <dcoutts> zRecursive: "cabal unpack random" is the command to run. It'll create a dir random-1.1/
19:23:59 <NeedHelpHarry> [x*x]
19:24:01 <ski> yes
19:24:16 <zRecursive> dcoutts: find it
19:24:27 <ski> NeedHelpHarry : then, there's still the type error in the other defining equation of `squareList'
19:24:40 <dcoutts> zRecursive: ok, so now:  cd random-1.1/; ghc Setup.hs; ./Setup configure
19:24:44 <ski> NeedHelpHarry : you also need to fix that one, before the implementation accepting your code
19:24:58 <NeedHelpHarry> Ok
19:25:02 <NeedHelpHarry> let me guess what it is
19:25:07 <ski> ok
19:25:24 <NeedHelpHarry> it should be ++?
19:25:32 <ski> why ?
19:25:40 <NeedHelpHarry> No wait
19:25:49 <ski> what is the difference between `:' and `++' ?
19:25:51 <ski> do you know ?
19:26:01 <NeedHelpHarry> numbers :
19:26:32 <zRecursive> dcoutts: thanks! Does it mean i will need to use `cabal unpack` in the future ?
19:26:43 <NeedHelpHarry> hmm
19:26:50 <NeedHelpHarry> string is ++
19:26:54 <NeedHelpHarry> numbers is : I think
19:27:04 <ski> that's not quite it
19:27:14 <ski> shall i tell ?
19:27:19 <NeedHelpHarry> Sure lol please
19:27:37 <dcoutts> zRecursive: wait, did the ./Setup configure work?
19:27:40 <ski> `++' are used to combine two *lists* into a third list, by concatenating/appending them
19:27:44 <dcoutts> or give the same error as before?
19:27:56 <ski> `:' otoh is used to add a *single* element in front of a list
19:27:56 <zRecursive> dcoutts: wait ...
19:28:06 <NeedHelpHarry> Oooooohhhh
19:28:11 <ski> > [0,1,2] ++ [3,4]
19:28:12 <lambdabot>  [0,1,2,3,4]
19:28:17 <ski> > 0 : [3,4]
19:28:18 <lambdabot>  [0,3,4]
19:28:23 <NeedHelpHarry> so x shouldnt have brackets
19:28:32 <ski> NeedHelpHarry : perhaps those ^ examples help illustrate the difference
19:28:36 <NeedHelpHarry> yes thank you
19:28:54 <ski> in that case, the elements are numbers, but they can be anything, as long as they are the same type of thing, in any given list
19:29:29 <ski> > [[0,1],[2]] ++ [[],[3,4]]
19:29:30 <lambdabot>  [[0,1],[2],[],[3,4]]
19:29:37 <ski> > [0,1]: [[],[3,4]]
19:29:37 <NeedHelpHarry> cool
19:29:39 <lambdabot>  [[0,1],[],[3,4]]
19:29:45 <NeedHelpHarry> I see
19:29:50 <ski> in this case, the elements of the lists are themselves lists
19:30:01 <NeedHelpHarry> yeah
19:30:07 <ski> but it still holds that `:' only adds a single element in front of a list
19:30:15 <NeedHelpHarry> That makes sense
19:30:21 <zRecursive> dcoutts: `./Setup.exe configure` => Configuring random-1.1...\n Setup.exe: fd:4: invalid argument\n Setup.exe: fd:4: hGetContents: invalid argument (invalid byte sequence) 
19:30:22 <NeedHelpHarry> I got it actually running now
19:30:27 <NeedHelpHarry> But it returns the same list
19:30:27 <ski> (iow, makes a new list whose first element will be that element, and whose remaining elements will come from the other input list)
19:30:28 <NeedHelpHarry> hmm
19:30:39 <NeedHelpHarry> yeah
19:30:44 <ski> NeedHelpHarry : not quite the same list, right ? :)
19:31:12 <ski> NeedHelpHarry : now, after fixing the type errors, you need to fix the "logic error", which the implementation didn't catch
19:31:15 <NeedHelpHarry> Oh now it works!!!
19:31:18 <ski> (because it can't read your mind)
19:31:28 <dcoutts> zRecursive: can you post the log of ./Setup configure -v3, I'm trying to see if we can get a little more detail
19:31:30 <NeedHelpHarry> I didnt call the function *facepalm*
19:31:49 <ski> NeedHelpHarry : you can use the "Annotate" button on the paste page, to provide an updated version of your code
19:32:00 <ski> or to add additional detail which wasn't included earlier
19:32:13 <NeedHelpHarry> Cool
19:32:30 <ski> NeedHelpHarry : would you like to try that now ?
19:32:34 <NeedHelpHarry> Yes
19:32:38 <NeedHelpHarry> I have two other questions
19:32:39 <NeedHelpHarry> is that ok
19:32:53 <ski> sure
19:32:53 <zRecursive> @paste
19:32:54 <lambdabot> Haskell pastebin: http://lpaste.net/
19:33:15 <ski> this channel is for talking about Haskell, and related things
19:33:28 <ski> asking questions about Haskell is included in that
19:33:51 <lpaste> zRecursive pasted “Setup.exe configure -v3” at http://lpaste.net/162524
19:34:10 <NeedHelpHarry> Cool
19:34:30 <dcoutts> zRecursive: ok, now, can you edit the Setup.hs and change main to be:
19:34:30 <dcoutts> main = defaultMainWithHooks simpleUserHooks { postConf = \_ _ _ _ -> return () }
19:34:42 * ski notices that NeedHelpHarry didn't add the announce channel now either
19:34:55 <NeedHelpHarry> wait how do i do that
19:34:59 <NeedHelpHarry> I am such a noob lol
19:34:59 <dcoutts> zRecursive: then recompile and re-run Setup:  ghc Setup; ./Setup configure
19:35:28 <NeedHelpHarry> * test
19:36:06 <ski> /me looks at NeedHelpHarry
19:36:32 * NeedHelpHarry
19:36:50 * NeedHelpHarry what does this do
19:36:59 <ski> it's called "action"
19:37:08 * ski bounces up and down on the chair
19:37:22 <NeedHelpHarry> lol
19:37:33 <NeedHelpHarry> Ready for next one?
19:37:35 <ski> NeedHelpHarry : the version that you wrote "Updated working!" doesn't look like it'll compute the expected result, actually
19:37:43 <NeedHelpHarry> wait really
19:37:56 <NeedHelpHarry> did I not test an edge case
19:38:10 <ski> perhaps you didn't annotate with the right version ?
19:38:11 <zRecursive> dcoutts: it is same 
19:38:26 <zRecursive> Setup.exe: fd:4: hGetContents: invalid argument (invalid byte sequence)
19:38:35 <ski> NeedHelpHarry : it looks like `squareList [2,3]' will answer `[2,9]', using that annotation
19:38:47 <dcoutts> zRecursive: you recompiled it ok?
19:38:58 <NeedHelpHarry> [2,81]
19:39:07 <ski> NeedHelpHarry : have you tried calling it with a list of length greater than one ?
19:39:36 <NeedHelpHarry> it only works on the last one
19:39:38 <NeedHelpHarry> damn
19:39:40 <ski> yes
19:39:45 <ski> can you figure out why ?
19:39:49 <zRecursive> dcoutts: it is ok except “Setup.hs:8:1: Warning: Tab character“，
19:39:59 <NeedHelpHarry> fixed
19:40:22 <NeedHelpHarry> yeah that was my bad
19:40:22 * ski doesn't see a new annotation yet
19:40:29 <NeedHelpHarry> oh i edited it
19:40:33 <NeedHelpHarry> into the last annotation
19:40:33 <NeedHelpHarry> lol
19:40:35 <NeedHelpHarry> oops
19:40:39 <dcoutts> zRecursive: just to check, can you post your edited Setup.hs
19:40:54 <ski> (there should be a box thing in which you can select "#haskell" as the channel, when annotating)
19:41:12 <ski> ok
19:41:28 <NeedHelpHarry> should be good i think
19:41:33 <ski> NeedHelpHarry : now, what should `squareList []' return ?
19:41:36 <NeedHelpHarry> thanks for that lol
19:41:39 <NeedHelpHarry> ooh
19:41:39 <ski> is there a sensible result ?
19:41:41 <NeedHelpHarry> []
19:41:54 <dcoutts> zRecursive: then the next thing to try is this: make a test.c file containing:  int main(int argc, char** argv) { return 0; }
19:41:55 <ski> does your version give that result for the empty list ?
19:42:13 <lpaste> zRecursive pasted “Setup.hs” at http://lpaste.net/162529
19:42:21 <NeedHelpHarry> no i have to add it
19:42:22 <NeedHelpHarry> thanks
19:42:45 <ski> NeedHelpHarry : now, do you see why one of your defining equations is redundant ?
19:43:05 <NeedHelpHarry> which one
19:43:14 <ski> can you figure it out ? :)
19:43:35 <NeedHelpHarry> lol the line [x] = [x * x]
19:43:43 <ski> yep :)
19:43:56 <ski> it's now handled already by the two other cases
19:44:19 <ski> this means that you now don't need to duplicate the code `x * x' anymore, which is good
19:44:23 <NeedHelpHarry> lol thanks
19:44:35 <ski> if you wanted to change it, but forgot to change one of them, then that would have been an error
19:44:47 <ski> it's better to only have it written in one place in the program
19:45:16 <NeedHelpHarry> yeah
19:45:22 <zRecursive> dcoutts: test.c compiled by gcc is OK .
19:45:25 <ski> NeedHelpHarry : also, this is a lesson to try to remember "empty cases", and try to see if they can be sensible for whatever you're currently doing
19:45:35 <NeedHelpHarry> usually with strings right
19:45:50 <dcoutts> zRecursive: can you try with the gcc that comes with ghc? it's in the mingw/bin dir that comes with ghc
19:45:54 <ski> NeedHelpHarry : also, this shows that when adding such empty cases, it is often possible to simplify the rest of the code more
19:46:07 <ski> NeedHelpHarry : so, these are things to look out for, when you're learning
19:46:21 <NeedHelpHarry> Cool
19:46:26 <ski> NeedHelpHarry : well, in Haskell, strings are lists where the elements happen to be characters
19:46:34 <ski> > ['c','a','t']
19:46:36 <lambdabot>  "cat"
19:46:58 <zRecursive> dcoutts: `/ghc-7.10.3/mingw/bin/gcc test.c ` is still ok.
19:47:09 <dcoutts> zRecursive: does it produce any output?
19:47:11 <NeedHelpHarry> I see
19:47:20 <zRecursive> dcoutts: nothing
19:47:23 <NeedHelpHarry> My next problem involves tuples
19:47:29 <NeedHelpHarry> thats like (x, y) right?
19:47:37 <NeedHelpHarry> I need to find distance formula
19:47:53 <ski> NeedHelpHarry : finally, it shows that if you're writing a function taking a list as input, and you're thinking you need to do different things now depending on the "shape" of the list, your *first* thought should be making a case for `[]', and another case for `x:xs'
19:48:13 <ski> NeedHelpHarry : this is not always the right way, but it's good as a default way
19:48:13 <NeedHelpHarry> yeah
19:48:37 <zRecursive> weird problem !
19:48:53 <ski> distance between two points, both expressed as coordinate pairs ?
19:48:56 <ski> i see
19:49:17 <lpaste> dcoutts annotated “Setup.hs” with “Setup.hs (annotation)” at http://lpaste.net/162529#a162533
19:49:28 <dcoutts> zRecursive: can you try using that Setup.hs? ^^
19:49:35 <NeedHelpHarry> yeah
19:49:40 <dcoutts> ie recompile it and run ./Setup configure -v3
19:49:50 <ski> do you have an idea of how to do it ?
19:50:02 <NeedHelpHarry> input is a tuple of items, each being a tuple of numbers 
19:50:32 <ski> that would be one possible way to do it, yes
19:50:57 <NeedHelpHarry> so I listen for two tuples
19:51:05 <NeedHelpHarry> each being x y coordinates
19:52:24 * ski waits for NeedHelpHarry to continue
19:52:27 <NeedHelpHarry> Lol
19:52:36 <NeedHelpHarry> letme paste
19:52:39 <NeedHelpHarry> @paste
19:52:39 <lambdabot> Haskell pastebin: http://lpaste.net/
19:53:02 * ski wonders if it'll be announced this time
19:53:49 <NeedHelpHarry> was it announced
19:53:53 <ski> nope
19:54:10 <NeedHelpHarry> how do i do that
19:54:11 <ski> lpaste would have done it, like it did for dcoutts's paste above, e.g.
19:54:21 <NeedHelpHarry> i am using #haskell
19:54:25 <NeedHelpHarry> not sure why it doesnt
19:54:36 <NeedHelpHarry> http://lpaste.net/162534
19:55:14 <ski> i think you have a typo in `distance'
19:55:57 <NeedHelpHarry> yes
19:56:01 <ski> oh, and you're not calling `distance' in a way consistent with how it was defined
19:56:05 <NeedHelpHarry> it is supposed to read in four numbers
19:56:15 <ski> you have a call `distance ((x1, y1), (x2, y2))'
19:56:33 <NeedHelpHarry> oh yeah
19:56:35 <NeedHelpHarry> i just saw
19:56:36 <ski> but you don't have a definition `distance ((x, y), (i, j)) = ..x..y..i..j..'
19:56:37 <NeedHelpHarry> ok
19:56:50 <zRecursive> dcoutts: `./Setup configure -v3` returns same : ... Setup.exe: fd:4: invalid argument\n Setup.exe: fd:4: hGetContents: invalid argument (invalid byte sequence)
19:56:51 <ski> either change the call, or the definition
19:56:54 <ski> so that they agree
19:57:10 <NeedHelpHarry> the call is given
19:57:17 <dcoutts> zRecursive: I'd like to see the log, to see where those trace messages occur relative to the error
19:57:18 <NeedHelpHarry> so i shall change distance
19:57:23 <ski> iow, either you pass a pair with pair components
19:57:28 <ski> or you pass two separate pairs
19:57:57 <ski> `main' can be simplified a little bit
19:58:25 <dcoutts> zRecursive: I had thought that it was happening when we call gcc, but replacing the postConf with return should skip calling gcc, so now I'm trying to track down which step the error occurs in.
19:58:30 <NeedHelpHarry> I have to keep main 
19:58:34 <ski> ok
19:58:47 <lpaste> zRecursive pasted “Setup.exe configure -v3” at http://lpaste.net/162536
19:58:48 <NeedHelpHarry> is the first case alright?
19:59:12 <NeedHelpHarry> no wait
19:59:12 <ski> you mean
19:59:14 <ski>   distance _ _ = 0
19:59:14 <ski> ?
19:59:26 <ski> that's saying that the distance is `0', no matter what
19:59:29 <NeedHelpHarry> should it be (0,0) (0,0) instead
19:59:40 <ski> if you mean that, say that
19:59:46 <ski> it's not the same thing
19:59:58 <ski> `_' means "don't care" or "anything goes"
20:00:16 <ski> it's called the "wildcard", or "anonymous variable"
20:00:22 <NeedHelpHarry> i dont hink it needs a base case
20:00:49 <ski> you're correct. because it's not recursive
20:01:01 <ski> or, another way to say the same thing : every case is a base case
20:02:11 <NeedHelpHarry> yeah
20:02:13 <NeedHelpHarry> good point
20:03:08 <NeedHelpHarry> I will update
20:03:36 <NeedHelpHarry> the updated code
20:03:42 <NeedHelpHarry> http://lpaste.net/162534
20:03:53 <NeedHelpHarry> typeclass does not work
20:03:58 <NeedHelpHarry> for distance
20:04:28 <ski> ok, i see you attempted to make a type signature
20:04:35 <ski> you can do this in two ways
20:04:44 <stiX> Hi guys
20:04:50 <ski> either you decide that the numbers must be `Double's
20:04:57 <ski> (no overloading)
20:05:03 <stiX> Could someone tell me why my code keeps giving me a parse error?
20:05:08 <stiX> I think it ran fine yesterday
20:05:19 <Rembane> stiX: Black magic! Pastebin it!
20:05:29 <stiX> @lpaste
20:05:29 <lambdabot> Haskell pastebin: http://lpaste.net/
20:05:32 <NeedHelpHarry> is my way not work
20:05:35 <NeedHelpHarry> does*
20:05:48 <ski> NeedHelpHarry : or you decide on some suitable type class that supports all the numeric operations used in `distance'
20:06:04 <ski> NeedHelpHarry : note that `double' is not a type class, and neither is `Double'
20:06:11 <ski> (`Double' is a type)
20:06:24 <NeedHelpHarry> oh
20:06:36 <NeedHelpHarry> but even when i changed it to Double it didnt work
20:06:45 <ski> NeedHelpHarry : are you using an interactor to test things ?
20:07:08 <NeedHelpHarry> i am using ghci
20:07:55 <dcoutts> zRecursive: ok, so this is very surprising. Looking at the code, there's almost nothing happening after the "after conf hook" message but before the "post conf" message.
20:08:42 <NeedHelpHarry>  ‘Double’ is applied to too many type arguments     In the type signature for ‘distance’:       distance :: Double a => ((a, a), (a, a)) -> a
20:08:53 <zRecursive> yeah, i am trying `stack install random` now, Linking is so slow!
20:09:17 <dcoutts> zRecursive: ok, can you run ./Setup clean; ./Setup configure -v3;  and then check if dist/setup-config exists
20:09:41 <NeedHelpHarry> oh i got it
20:09:44 <zRecursive> after linking, i will try it
20:11:05 <NeedHelpHarry> nevermind
20:11:07 <zRecursive> As i guess, `stock install random` returns same error!
20:11:08 <NeedHelpHarry> failed
20:11:15 * NeedHelpHarry doesnt work
20:11:27 <dcoutts> zRecursive: it may well do, it also calls Setup
20:12:00 <dcoutts> zRecursive: but it's possible there's some environment difference that means it does not hit it.
20:12:14 <Rembane> NeedHelpHarry: Add more brackets!
20:12:34 <zRecursive> dcoutts: there is no dist/setup-config after `setup clean; setup configutr -v3`
20:12:48 <dcoutts> ok, interesting
20:13:05 <dcoutts> zRecursive: btw. what does ./Setup --version say?
20:13:27 <zRecursive> `./Setup.exe --version` => Cabal library version 1.22.5.0
20:15:57 <dcoutts> zRecursive: are you prepared to do a little more debugging? We could unpack Cabal-1.22.5.0 and insert some tracing into the code. There's a fairly narrow bit of code where it must be failing, but I can't for the life of me see why it'd be. There's no call to hGetContents, certainly not on a pipe
20:16:21 <dcoutts> there would be if we were calling gcc, but setting postConf = print "blah"  skips that
20:17:41 <zRecursive> dcoutts: ok
20:18:44 <NeedHelpHarry> where did you go ski
20:18:58 <dcoutts> zRecursive: ok, then cabal unpack Cabal-1.22.5.0; cd Cabal-1.22.5.0;  then you want to edit Distribution/Simple.hs and look at configureAction and insert some print statements between the call to confHook and the call to postConf
20:19:43 <dcoutts> zRecursive: you'd then need to ghc Setup.hs in the Cabal-1.22.5.0/  dir, which will make a new Setup.exe
20:20:25 <dcoutts> you can try running the Setup.exe configure in the Cabal dir and see if you get the same issue there (probably will) or run that Setup.exe from within the random-1.1 dir
20:26:04 <zRecursive> dcoutts: `Cabal-1.22.5.0 $ ./Setup.exe configure` => Configuring Cabal-1.22.5.0...\n "blah---1"\nSetup.exe: fd:4: invalid argument\n Setup.exe: fd:4: hGetContents: invalid argument (invalid byte sequence)
20:26:47 <zRecursive> `random-1.1 $ ../Cabal-1.22.5.0/Setup.exe configure` => Configuring random-1.1...\n "blah---1"\n Setup.exe: fd:4: invalid argument\n Setup.exe: fd:4: hGetContents: invalid argument (invalid byte sequence)
20:26:59 * NeedHelpHarry anyone here willing to help a newbie
20:27:09 <dcoutts> zRecursive: ok, good so still reproducible. Did you insert any tracing into the configureAction code ?
20:27:41 <zRecursive> yeah, print "blah---1" and print "blah---2"
20:28:18 <zRecursive> print "blah---2" doesnot run
20:28:23 <dcoutts> zRecursive: ok, where were those inserted?
20:28:49 <dcoutts> the three interesting bits at the moment are the confHook, writePersistBuildConfig and postConf
20:29:51 <zRecursive> localbuildinfo0 <- confHook hooks epkg_descr flags\n print "blah---1" ...print "blah---2"\n postConf hooks args flags pkg_descr localbuildinfo
20:30:31 <zRecursive> in "configureAction hooks flags args" of Simple.hs
20:31:38 <dcoutts> zRecursive: ok, so the only interesting thing between those is writePersistBuildConfig so lets go add tracing there
20:31:48 <dcoutts> that lives in Distribution/Simple/Configure.hs
20:36:35 <zRecursive> dcoutts: print "Configure.hs:252"\n     writeFileAtomic (localBuildInfoFile distPref) $\n       BLC8.unlines [showHeader pkgId, encode lbi] \n    print "Configure.hs:255",  `Setup configure` only prints "Configure.hs:252" and no "Configure.hs:255"
20:37:08 <dcoutts> zRecursive: thanks, that's interesting
20:37:12 * dcoutts is thinking
20:37:13 <zRecursive> seems it is encoding problem
20:38:13 <zRecursive> dcoutts: i will leave for someting. see you later
20:38:23 <dcoutts> zRecursive: thanks for taking the time
20:38:28 <zRecursive> welcome
20:54:51 <NeedHelpHarry> ski?
20:54:58 <scshunt> yes
20:55:17 <dcoutts> zRecursive: find me tomorrow, I think I have a fix, or at least something that will narrow down the problem by reporting the error in the right place.
20:55:33 <dcoutts> @tell zRecursive find me tomorrow, I think I have a fix, or at least something that will narrow down the problem by reporting the error in the right place.
20:55:33 <lambdabot> Consider it noted.
20:57:02 <NeedHelpHarry> anyone know what is wrong with my program
20:57:14 <NeedHelpHarry> @paste
20:57:15 <lambdabot> Haskell pastebin: http://lpaste.net/
20:57:42 <NeedHelpHarry> http://lpaste.net/162534
20:57:44 <NeedHelpHarry> it wont work
20:57:46 <NeedHelpHarry> for some reason
20:59:32 <pavonia> What means won't work here?
20:59:55 <pavonia> :t (^)
20:59:57 <lambdabot> (Integral b, Num a) => a -> b -> a
21:00:34 <NeedHelpHarry> it does not work
21:00:40 <NeedHelpHarry> maybe my input is wrong
21:01:20 <pavonia> Well, "don't work" is the one of the least helpful problem descriptions you can give
21:01:28 <NeedHelpHarry> Ok
21:01:29 <NeedHelpHarry> hold om
21:01:31 <NeedHelpHarry> on
21:01:36 <NeedHelpHarry> I will provide input and output
21:02:06 <pavonia> Does it even compile? Because your call of disctance looks wrongly typed
21:02:57 <dmwit> ?quote dmwit instance.*Num.*Bool
21:02:57 <lambdabot> dmwit says: ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs = id; signum = id; fromInteger = odd
21:03:08 <NeedHelpHarry> yes it compiles
21:03:38 <NeedHelpHarry>  Distance 0 0 3 4
21:03:55 <NeedHelpHarry>  Non type-variable argument       in the constraint: Floating (a -> a -> a -> t)     (Use FlexibleContexts to permit this)     When checking that ‘it’ has the inferred type       it :: forall a a1 a2 t.             (Floating (a -> a1 -> a2 -> t), Num a, Num a1, Num a2,              Num                ((a -> a1 -> a2 -> t, a -> a1 -> a2 -> t),                 (a -> a1 -> a2 -> t, a -> a1 -> a2 -> t))) =>             t
21:04:01 <NeedHelpHarry> oh god
21:04:18 <NeedHelpHarry> http://pastebin.com/MMVTtNas
21:04:37 <NeedHelpHarry> that is the error
21:05:28 * NeedHelpHarry any input?
21:06:02 <pavonia> You get that error when running the binary? O.o
21:06:31 <NeedHelpHarry> well
21:06:32 <NeedHelpHarry> no
21:06:42 <NeedHelpHarry> when inputting distanec 0 0 3 4
21:06:44 <NeedHelpHarry> into ghci
21:07:08 <pavonia> distance only takes a single argument
21:07:19 <pavonia> of type ((Double, Double), (Double, Double))
21:07:34 <NeedHelpHarry> wait
21:07:37 <NeedHelpHarry> what is the main doing then?
21:07:46 <NeedHelpHarry> the main function was given to us
21:08:17 <pavonia> But you're not calling the main, are you?
21:08:27 <pavonia> Try :main 0 0 3 4
21:08:42 <dmwit> no
21:08:58 <pavonia> Err right, that's wrong
21:08:59 <dmwit> I mean, there's nothing wrong with doing that, but the `0 0 3 4` bit will be ignored.
21:09:18 <NeedHelpHarry> oh
21:09:19 <NeedHelpHarry> ok
21:09:56 <dmwit> The correct syntax for calling `distance` in ghci would be something like `distance ((0,0),(3,4))`.
21:10:23 <dmwit> You can also run `main` (or use the `:main` command) and type `0 0 3 4` in when prompted.
21:10:29 <NeedHelpHarry> true
21:10:34 <NeedHelpHarry> here is the code from the test file
21:10:35 <NeedHelpHarry> http://pastebin.com/6PHdt7LP
21:10:44 <NeedHelpHarry> That is what my input should be, but i cant understand it
21:13:08 <pavonia> What file format is that?
21:13:40 <NeedHelpHarry> .t
21:13:46 <NeedHelpHarry> i that pearl?
21:13:49 <NeedHelpHarry> is*
21:13:58 <pavonia> No idea
21:14:48 <NeedHelpHarry> so i definitely think I have to enter main
21:14:51 <NeedHelpHarry> main 0 0 3 5
21:14:54 <NeedHelpHarry> but that doesnt work
21:15:20 <dmwit> Just `main`. Nothing more.
21:15:30 <dmwit> Then type `0 0 3 4` on the next line.
21:15:47 <NeedHelpHarry> yup that was it
21:15:48 <NeedHelpHarry> omg
21:15:51 <NeedHelpHarry> Thank you so much
21:17:43 <lpaste> hefesto pasted “error_make-ing_jhc” at http://lpaste.net/162542
21:17:46 <NeedHelpHarry> i am an idiot
21:20:43 <hefesto> Hi! I am trying to compile jhc, but I am not able to (I am not that good yet). The error seems to be in "Could not deduce (Applicative (ReaderWriter r w))". The full error is on http://lpaste.net/162542
21:23:29 <pavonia> hefesto: What GHC version are you using?
21:26:11 <hefesto> 7.10.2
21:27:18 <pavonia> I presume the JHC code requires an older version then
21:28:07 <hefesto> I'll try that. Thanks!
21:31:14 <pavonia> A verion with base < 4.8 should work
21:31:19 <pavonia> *version
21:47:33 <stiX> Is anyone in here familiar with scala, and willing to chat with me in a different channel?
21:49:29 <stiX> Is that a no?
21:53:25 <Cale> stiX: Perhaps try #scala
21:56:20 <fatex> are there any haskell tools for extracting location + glyphs from a pdf file?
21:56:36 <fatex> I'm loooking for something with type siganture :: PdfFile -> [(Char, Rect Double Double Double Double)]
21:56:45 <fatex> maybe PdfFile -> [(FontName, Char, Rect)]
21:56:59 <fatex> maybe PdfFile -> [(PageNumber=Int, FontName, Char, Rect)]
21:58:55 <scshunt> ahahahahahah
21:59:02 <scshunt> unlikely
21:59:18 <scshunt> PDF is a truly terrible file format, it's unlikely anyone has made something so specific
22:01:06 <arahael> fatex: Last time I had to do that, I ended up using regexps.
22:01:23 <arahael> fatex: And it was horrible.
22:01:34 <fatex> NO
22:01:39 <fatex> atleast use parsec
22:01:53 <scshunt> PDF parsing is not decidable
22:02:05 <arahael> fatex: I didn't want to parse the PDF format.
22:02:19 <arahael> fatex: Just rip out whatever content I can, on a case-by-case basis.
22:03:17 <fatex> https://hackage.haskell.org/package/pdf-toolbox-content looks promising
22:22:50 <zRecursive> away
22:23:35 <zRecursive> dcoutts: i am coming back.
22:28:31 * hackagebot BiGUL 0.9.0.0 - The Bidirectional Generic Update Language  https://hackage.haskell.org/package/BiGUL-0.9.0.0 (joshko)
22:56:38 <BTNZ> hello
23:13:50 <liste> hello BTNZ 
23:15:27 <BTNZ_> hi
23:18:08 <BTNZ_> Ping timeout ??
23:18:30 <BTNZ_> I'm online.
23:18:31 <johnw> set your TTL way higher than 2 mins
23:19:00 <BTNZ_> I use webchat.freenode.net.
23:23:49 <mfng> I have a question
23:24:07 <mfng> f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
23:24:22 <mfng> foldrWithKey f "Map " [(5,a),(3,b)]
23:24:48 <mfng> returns "Map: (5,a) (3,b)"
23:25:04 <mfng> But shouldn't this be the other way round? -> "Map: (3,b) (5,a)"
23:43:20 <Cale> mfng: why?
23:43:40 <Cale> Oh, because the keys are in order...
23:44:06 <Cale> wait, but you're not applying foldrWithKey to a Map
23:44:12 <Cale> That's just a list of pairs
23:44:23 <Cale> So it would make sense that it preserve the order
23:49:34 <cocreature> maybe mfng is using OverloadedLists or something, I don’t think we have foldrWithKey for lists
23:53:40 <geppettodivacin> cocreature: He simplified the code a little. We solved it over in #haskell-beginners. Turns out the Map preserved the order of the keys, not insertion order.
23:53:58 <cocreature> k
