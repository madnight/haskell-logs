00:07:39 * hackagebot persistent-template 2.5.1.1 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5.1.1 (GregWeber)
00:07:39 * hackagebot auto-update 0.1.4 - Efficiently run periodic, on-demand actions  https://hackage.haskell.org/package/auto-update-0.1.4 (MichaelSnoyman)
00:20:18 <aleogen> hi which version of ghc should I use?
00:20:29 <aleogen> looks like 7.6.3 is what debian has for me
00:20:42 <aleogen> 7.10.3 appears to be the latest
00:21:01 <hvr> aleogen: https://packages.debian.org/jessie-backports/ghc
00:21:01 <Tangerine> is it possible to put guards in a case pattern matching?
00:21:26 <aleogen> hvr: is that the version I should use?
00:21:33 <Tangerine> ah yes nvm
00:21:40 <hvr> aleogen: depends on what you want to do :_)
00:22:08 <aleogen> hvr: I suppose normal stuff, whatever that means. Pros and cons?
00:22:17 <aleogen> Is there a major change log I could look at?
00:22:51 <hvr> aleogen: each major ver user's guide has a release-note entry, e.g.
00:22:53 <hvr> aleogen:  https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/release-7-10-1.html
00:23:00 <hvr> aleogen:  https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/release-7-8-1.html
00:23:19 <hvr> which points out major highlights relative to version-1
00:23:51 <aleogen> hvr: so is there a crucial reason which debain is using an old version?
00:23:53 <hvr> aleogen: if you want to use packages from Hackage, then 7.10 will likely give you a better experience
00:23:53 <srhb> aleogen: You probably shouldn't bother with your distro version, especially not as far back as 7.6. Get Stack and let it maintain whatever GHC you need for your project.
00:23:59 <srhb> aleogen: Debian is always way behind.
00:24:16 <hvr> aleogen: debian ships with the version that was deemed stable at the time it shipped
00:24:25 <aleogen> ah, okay. Thanks for that advice srhb. I go ahead and set up
00:24:31 <hvr> aleogen: and then it's policy not to update major versions anymore
00:25:07 <hvr> aleogen: make sure to alos grab the cabal-install backport
00:25:17 <srhb> hvr: Why?
00:25:23 <hvr> srhb: why what?
00:25:31 <srhb> hvr: Why grab the cabal-install backport?
00:25:54 <hvr> srhb: because the non-backported one is a bit outdated as well
00:26:06 <srhb> hvr: OK, why grab cabal-install at all, is what I meant. :-)
00:26:19 <hvr> why not? ;)
00:26:31 <srhb> hvr: Well, it's not necessary to get stack up and running, is it?
00:26:51 <hvr> neither would be  https://packages.debian.org/jessie-backports/ghc if he went for Stack
00:27:00 <srhb> Oh, no, sure. :)
00:27:43 <hvr> but I have almost no experience with Stack; hence I recommend what I acutally have experience with
00:27:54 <srhb> OK :)
00:28:15 <aleogen> yeah, I have no experience with stack, but I'll check it out
00:28:21 <srhb> To summarize: Either grab those backports, or grab Stack. No reason to do both.
00:28:43 <hvr> aleogen: the basic thing I can tell you about Stack is that, it install everything into your $HOME, rather than using a system-packager based installation
00:29:10 <aleogen> hvr: sandboxed?
00:29:13 <hvr> aleogen: yeah
00:29:20 <aleogen> cool :-)
00:29:28 <aleogen> Is HaPy still in use?
00:29:29 <hvr> aleogen: the ghc binaries are not tested/built by Debian maintainers
00:30:02 <hvr> (& nor maintained/patched)
00:30:26 <aleogen> https://hackage.haskell.org/package/HaPy
00:30:39 <aleogen> https://github.com/ddfisher/HaPy
00:30:50 * hvr has no idea if ppl use HaPy
00:31:08 <hvr> but it looks like it'll work with GHC 7.10
00:31:14 <aleogen> yay :-)
00:31:19 <aleogen> How can you tell?
00:31:36 <hvr> release one year ago, and the version bounds include GHC 7.10's bundled library versions
00:31:49 <hvr> e.g. `0660 base (>=4.5 && <4.9)`
00:31:52 <aleogen> oh I see. Okay, I'll try it all out here shortly
00:32:12 <hvr> good luck! :)
00:32:22 * hvr needs to grab some food now
00:40:27 <Zemyla> What is the earliest version of GHC that will build the current version?
00:44:26 <srhb> Zemyla: Current as in 7.10.3?
00:44:34 <Zemyla> Yeah.
00:44:46 <srhb> Zemyla: https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/Tools
00:44:52 <srhb> "To build 7.10.* you need GHC >= 7.6"
00:45:50 <Zemyla> Hmm. And what would I need to build GHC 7.6?
00:46:14 <Zemyla> Ahh.
01:08:52 <Tangerine> question again on the IO monad
01:09:26 <Tangerine> I want to either get the text from stdin (which gives me a Handle) and from a file I opened with openFile
01:09:33 <Tangerine> which is a IO Handle
01:10:17 <Tangerine> how do I use getContents on an IO Handle if its type is Handle -> IO String
01:11:11 <pavonia> Either use a do-block or (>>=)
01:11:57 <Tangerine> so I'm doing
01:12:04 <Tangerine> contents <- hGetContents h
01:12:24 <Tangerine> and its saying "couldn't match expeected type 'Handle' with actual type 'IO Handle'
01:12:31 <Tangerine> do i need to use return.hGetContents instead?
01:12:37 <bergmark> i don't think that line is the problem
01:13:01 <MasseR> Tangerine: hGetContents takes a Handle, you are givint it a IO Handle
01:13:08 <MasseR> *giving
01:13:33 <pavonia> Tangerine: Where is h coming from?
01:13:38 <MasseR> You probably have an openFile or something above that line
01:13:49 <MasseR> (the line where you get the h)
01:13:52 <Tangerine> yes, its from an openFile
01:14:02 <Tangerine> either from an openFile or from  (return stdin)
01:14:11 <MasseR> Could you show us that line
01:15:11 <Tangerine> I open it in another function and pass it here
01:15:29 <Tangerine> passed in from "columns (openFile x ReadMode) arg2..."
01:15:46 <MasseR> h <- openFile x ReadMode
01:15:49 <MasseR> columns h arg2 ...
01:16:17 <MasseR> The openFile function returns an IO Handle, and you need to "unwrap" it to a plain Handle with <-
01:18:16 <Tangerine> ah that worked
01:18:18 <Tangerine> thanks a lot!
01:18:48 <Tangerine> what does <- exactly mean in haskell?
01:19:10 <MasseR> You can think of it as a syntactic sugar for the (>>=) function
01:19:12 <MasseR> @type (>>=)
01:19:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:19:50 <MasseR> so my previous example would be synonymous with `openFile h ReadMode >>= \h -> columns h arg ...`
01:20:04 <Tangerine> ooh i see
01:20:04 <srhb> @undo do { b <- ma; foo b; foo c }
01:20:04 <lambdabot> ma >>= \ b -> foo b >> foo c
01:20:11 <srhb> Tangerine: @undo can be helpful
01:20:27 <Tangerine> does that work in GHCI as well?
01:20:51 <MasseR> Unfortunately no
01:20:56 <Tangerine> just here?
01:21:36 <bblfish> Hi I have been reading/studying the "co-monads are objects" blog post from 2013. Already learnt a lot doing that. http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
01:21:36 <MasseR> Or in private with lambdabot (preferred)
01:23:00 <bblfish> Was wondering if syntax idea proposed there had been taken up. (I can't tell if the syntax can be implemented from the information in the blog post. My Haskell is not good enough for that)
01:27:16 <budObud> @search "haskell"
01:27:16 <lambdabot> Unknown command, try @list
01:31:39 <budObud> please someone here have book "haskell programming from first principles" by allen and moronuki? i would appreciate if anyone could share it. wanna try before buy,ehm, 60bucks is pretty much for poor students...thnx...
01:32:48 <srhb> budObud: I don't think people are inclined to engage in piracy of a product produced by people who are actively here in channels and contribute to the community
01:32:54 <srhb> budObud: However, if you're poor, contact them directly.
01:33:03 <srhb> budObud: They are inclined to help you out if you do them that curtesy.
01:33:25 <sshine> hi srhb :)
01:33:30 <srhb> sshine: Hi
01:33:34 <budObud> hh understood 
01:34:21 <opqdonut> there's http://haskellbook.com/images/sample.pdf
01:34:31 <opqdonut> official sample with the first couple of chapters
01:36:38 <budObud> thnx, nevermind i wanted to look at advanced topics like functors, monads and applicative which is of course not included in that sample... nevermind...
01:48:08 <JustinHitla> is haskell's code "self-documenting" ?
01:54:01 <srhb> JustinHitla: Do you mean "will people still like me if I don't document my Haskell"?
01:54:51 <JustinHitla> I mean why should I document a code it if its self-documenting, the question is haskell self-documenting or if it were I would allready kne that so its not ?
01:56:20 <ahihi> I haven't seen any programming language that's inherently self-documenting, it depends entirely on how you write it
01:57:22 <Tangerine> is there a !! that is safe with maybes?
01:58:08 <Tangerine> i.e. [0,1,2]!!6 = Nothing
01:58:39 <ahihi> Tangerine: atMay from the safe package
01:59:25 <Tangerine> it feels quite unhaskell to have !! not do that by default
01:59:50 <JustinHitla> may I ask what "[0,1,2]!!6" do ?
01:59:52 <ahihi> I agree, but changing it would break lots of existing code
02:00:33 <Tangerine> !! a finds the element indexed at a
02:00:43 <Tangerine> [0,1,2] is just a list
02:00:56 <opqdonut> Tangerine: lists are unsafe like that, see also head
02:01:14 <Tangerine> I could write my own right?
02:01:21 <opqdonut> sure
02:04:43 <Freundlich> JustinHitla: Given a function type the set of possible functions of that type is generally huge. So no, haskell is not self documenting. But often you can guess the intended semantics from said type.
02:05:34 <pavonia> > let cs !? n = lookup n $ zip [0 ..] cs in [1, 2, 3] !? 6
02:05:37 <lambdabot>  Nothing
02:08:19 <ruslan_t> noob question, can't figure out how to parse a string like this "some_field5-name" with parsec. The problem i am having is making sure the last character is a letter (previous parser consumes all input). thank you
02:09:29 <Freundlich> ruslan_t: Sounds like you want an LR parser instead.
02:10:17 <Freundlich> What you are trying to do is the worst-case scenario for an LL parser like parsec. It should be able to decide as quickly as possible which right-hand side applies.
02:13:34 <ruslan_t> Freundlich: Thank you ... :( everthing is in parsec, can't really switch everything just for a small parser
02:15:03 <troydm> what is the difference between Data.Array and Data.Vector in Haskell?
02:17:28 <lyxia> Array is more general, it allows different index types
02:17:58 <cocreature> also array doesn’t do fusion iirc
02:18:01 <lyxia> you can only index vectors with Int, but it is well optimized
02:19:00 <troydm> ah, ic thx lyxia and cocreature 
02:20:58 <cocreature> I tend to just use go for vector in all cases and write some index translation code myself if I need it
02:29:19 <Glenjamin> hi all. Does anyone know if its possible to get a `--flag, --no-flag` option via Options.Applicative to produce `Maybe Bool` ?
02:37:31 <merijn> Glenjamin: I don't think there's a builtin combinator, but I don't see why you couldn't write your own?
02:38:02 <merijn> Freundlich: Nitpick: parsec is not "an LL parser"
02:38:18 <merijn> Freundlich: It's a library for the easy writing of recursive descent parsers.
02:38:23 <Glenjamin> mainly because I don't really know what I'm doing :D
02:38:47 <merijn> Glenjamin: Also, "Maybe Bool" seems like an odd type
02:38:52 <Glenjamin> i'll live with a standard Bool and come back to this if it turns out to be important
02:39:09 <Glenjamin> the concrete example is --color, --no-color, and omission is autodetect
02:40:00 <merijn> Glenjamin: Why not declare as "data Colouring = Colour | NoColour | Autodetect" and use Autodetect as default?
02:40:44 <Glenjamin> yeah, i was going to make a YesNoAuto type, but I thought maybe bool would be easier to parse
02:40:58 <merijn> Glenjamin: Bool leads to boolean blindness: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
02:47:38 * hackagebot monad-dijkstra 0.1.0.0 - Monad transformer for weighted graph searches using Dijkstra's or A* algorithm  https://hackage.haskell.org/package/monad-dijkstra-0.1.0.0 (ecramer)
02:59:24 <Saizan_> i wish there was a way to put the fallback case first in a case expression
03:00:16 <Saizan_> something like case .. of IfAllElseFails -> ..; ...;
03:07:38 * hackagebot lambdacube-gl 0.5.0.4 - OpenGL 3.3 Core Profile backend for LambdaCube 3D  https://hackage.haskell.org/package/lambdacube-gl-0.5.0.4 (CsabaHruska)
03:13:45 <The_Ice> hello, are there any ability to trigger heap profiling during runtime? Suppose, I have some long running service, that I can't stop, but it has some rpc. So I want to turn on "+RTS -p" for some time, and then - turn it off. The only thing, that I have found so far is  GHC.Profiling module, but it is not enought.
03:18:49 <The_Ice> sorry, looks like #ghc is more suited for my question
03:32:36 <obadz> Is there a simple way to generate a UserError IOException from a string?
03:32:39 * hackagebot hpack 0.14.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.14.0 (SimonHengel)
03:33:09 <obadz> :t throwError . userError
03:33:10 <lambdabot> MonadError IOError m => String -> m a
03:33:15 <obadz> looks like that's what I want
03:47:37 <maerwald> does 'doctest' do anything weird? Because it can'f find a *.hs file generated from *.hsc while the normal build can
03:49:28 <dcoutts_> maerwald: the build system puts the generated .hs into a different dir, to not pollute the source dirs
03:49:37 <maerwald> I know
03:49:51 <maerwald> still doesn't explain why doctest doesn't pick it up
03:53:35 <maerwald> something is seriously broken there
04:07:40 * hackagebot declarative 0.2.2 - DIY Markov Chains.  https://hackage.haskell.org/package/declarative-0.2.2 (JaredTobin)
04:27:26 <nomeata> Complete this sentence, as concise but precise as possible: „A type constructor is...“
04:28:45 <opqdonut> an injective function
04:28:58 <nomeata> hmm, hardly.
04:29:05 <opqdonut> oh right, type constructor
04:29:11 <opqdonut> well, they're injective in haskell2010
04:29:25 <gfixler> a function that take 0 or more types and yields a type
04:29:49 <nomeata> opqdonut: only if a polymorphic "type" is not considered to be a type constructor
04:29:53 <hpd> ... a type constructor
04:30:04 <gfixler> taut, qed.
04:30:07 <nomeata> gfixler: better, but I really dislike function here
04:30:29 <nomeata> I have "A type constructor a parametric type", but that also doesn’t quite cut it.
04:30:49 <gfixler> they're type-level functions
04:31:02 <locallycompact> nomeata, I see where you're coming from but *why* not function
04:31:43 <nomeata> locallycompact: too much risk of concusion with type families or term-level functions
04:31:56 <gfixler> morphisms then
04:32:19 <locallycompact> what's a type family in this context?
04:32:32 <nomeata> locallycompact: see, it’s confusing :-)
04:32:38 <locallycompact> :)
04:33:12 <nomeata> A type constructor is what forms a polymorphic type?
04:33:12 <locallycompact> what's a type family at all tbh
04:33:22 <nomeata> locallycompact: functions on the type level
04:33:27 <gfixler> https://wiki.haskell.org/GHC/Type_families
04:34:05 <gfixler> " They are the data type analogue of type classes: families are used to define overloaded data in the same way that classes are used to define overloaded functions."
04:35:09 <nomeata> gfixler: I believe I know what type families are, and this description would not help me :-)
04:35:35 <nomeata> or maybe a bit, after thinking longer about it
04:35:40 <maerwald> does anyone know why doctest is broken here? http://lpaste.net/162709
04:35:44 <gfixler> "Data constructors are first class values in Haskell and actually have a type."
04:35:46 <gfixler> https://wiki.haskell.org/Constructor
04:35:56 <nomeata> it might better be an answer to "what can type families be used for"
04:35:59 <gfixler> that's data constructors, though
04:36:16 <gfixler> Haskell's page on constructors doesn't mention functions
04:36:38 <gfixler> only once, and only to say that data constructors can be passed to functions
04:37:00 <gfixler> so type constructors are type constructors - even the haskell wiki doesn't claim that they're some other thing
04:38:12 <Clint> maerwald: posix-paths missing from the testsuite stanza in the cabal file?
04:38:39 <maerwald> Clint: no
04:39:26 <maerwald> posix-paths is not used
04:40:37 <mfukar> Interestingly enough, the wiki seems very loose with what a type constructor is. Where's "constructor" defined? Are they functions?
04:41:20 <maerwald> the normal build succeeds just fine, just doctest screws up
04:51:15 <bernalex> IDR the wiki, but type constructors should just be 'things that are * -> *' really.
04:52:25 <hpc> well, there's a case to be made for type constructors being the things with capital letters, too
04:52:38 <hpc> mostly just because type classes make them significant
04:52:45 * hpc isn't sure which he prefers
05:06:13 <merijn> mfukar: Type constructors are to type level functions as value constructors are to value level functions
05:07:11 <merijn> That is, constructors are a subset of functions on either the value or type level
05:09:07 <Philonous> Is there a predefined traversal in lens that targets the nth element of a list? 
05:09:24 <merijn> nomeata: In the context of type families type constructors are similar to data constructors in that they're the only thing that you can "match" on
05:10:03 <Philonous> Oh, never mind, `ix` does the trick
05:12:50 <Tangerine> is there a difference between IO [Int] and [IO Int]?
05:13:09 <Taneb> Tangerine, yes
05:13:22 <merijn> Tangerine: Yes, one is an IO action producing a list of Int, the other is a list of IO actions that produces Int
05:13:32 <merijn> Tangerine: Try the following in ghci
05:13:43 <merijn> :t map print [1..10] !! 3
05:13:44 <lambdabot> IO ()
05:13:58 <merijn> :t map print [1..10]
05:13:59 <lambdabot> [IO ()]
05:14:23 <merijn> Similarly, try: "fmap (!!3) $ mapM print [1..10]"
05:14:29 <merijn> :t mapM print [1..10]
05:14:30 <lambdabot> IO [()]
05:15:56 <Akii> mapM is like sequence? :o
05:16:05 <Philonous> @source mapM
05:16:06 <lambdabot> Unknown command, try @list
05:16:18 <merijn> Akii: "mapM f = sequence . map f"
05:17:04 <Akii> oh
05:17:07 <Akii> nice
05:17:20 <bernalex> as an example using the same function
05:17:20 <merijn> Also "mapM_ f = sequence_ . map f"
05:17:22 <Akii> and that works for every monad, I was wondering how that would work
05:17:24 <merijn> :t mapM_
05:17:25 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
05:17:30 <Akii> :t mapM
05:17:31 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
05:17:34 <merijn> Akii: Every monad and traversible, even :)
05:17:35 <Akii> wait
05:17:35 <bernalex> :t [read <$> getLine :: IO Int]
05:17:37 <lambdabot> [IO Int]
05:17:44 <Akii> that signature looks different in my ghci
05:17:46 <bernalex> :t (++) <$> (read <$> getLine) <*> (read <$> getLine) :: IO [Int]
05:17:48 <lambdabot> IO [Int]
05:18:04 <Akii> ok, no, but could've sworn it looked different yesterday
05:18:06 <Philonous> Akii, You probably have an older GHC
05:18:11 <Akii> nope
05:18:15 <Tangerine> I have variable a that is a IO [Int] , how can I make a IO [Int] that contains all numbers from 1 to 9 that are NOT in a?
05:18:30 <merijn> Tangerine: fmap a function into it? :)
05:18:35 <Tangerine> does a list comprehension not work here?
05:18:38 <Akii> ah no, mixed that up with foldM
05:18:49 <Akii> :t foldM
05:18:50 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
05:18:51 <bernalex> monad comprehensions would work but fmap is the most clear, usually.
05:19:08 <Tangerine> I tried [x | x <-[1..9], notElem x a]
05:19:14 <tiny_test> what's a monad comprehension?
05:19:30 <merijn> tiny_test: A generalisation of list comprehensions :)
05:19:38 <bernalex> tiny_test: list comprehensions abstracted to all monads. uses the MonadComprehensions extension.
05:19:44 <tiny_test> huh, TIL
05:19:47 <merijn> tiny_test: Basically, the realisation that list comprehensions actually work for more than lists :)
05:20:16 <bernalex> tiny_test: [x | x <- Just 5] as an example
05:20:38 <Tangerine> I'm not sure how I can use fmap here
05:20:44 <Tangerine> what am I fmaping onto what?
05:21:02 <bernalex> Tangerine: so [[x] | x <- Just 5] would be Just [5]. it's pretty simple. usually not all that simple. :)
05:21:07 <tiny_test> > [x | x < Just 5] :: Maybe Int
05:21:09 <lambdabot>      Couldn't match expected type ‘Maybe Int’ with actual type ‘[Expr]’
05:21:09 <lambdabot>      In the expression: [x | x < Just 5] :: Maybe Int    Couldn't match expec...
05:21:09 <lambdabot>                  with actual type ‘Maybe Integer’
05:21:12 <Lovepon> Monad comprehensions are quite... I don't know.
05:21:13 <bernalex> Tangerine: sorry that was for tiny_test 
05:21:18 <tiny_test> [Expr] what
05:21:25 <Lovepon> > [x | x <- Just 5]
05:21:26 <lambdabot>      Couldn't match expected type ‘[t]’ with actual type ‘Maybe Integer’
05:21:26 <lambdabot>      In the expression: Just 5
05:21:26 <lambdabot>      In a stmt of a list comprehension: x <- Just 5
05:21:31 <bernalex> the extension isn't activated here.
05:21:35 <tiny_test> ah
05:22:33 <Lovepon> Do MonadComprehensions work on MonadZero or something?
05:22:50 <Lovepon> MonadPlus?
05:22:56 <merijn> Lovepon: Yes
05:23:06 <Lovepon> merijn: The latter or the former?
05:23:23 <merijn> Lovepon: MonadPlus, I don't believe MonadZero exists anymore
05:23:29 <Lovepon> merijn: Ah.
05:23:49 <Lovepon> merijn: So it doesn't work on just Monads?
05:24:14 <merijn> Lovepon: Only needs MonadPlus if you use guards
05:24:23 <Lovepon> merijn: Ah, thanks.
05:24:49 <Lovepon> merijn: I was confused to how [x | x <- Just 5, x == 0] returned Nothing.
05:25:04 <Tangerine> O
05:25:19 <Tangerine> I'm still confused as to how to do my thing with fmap
05:25:32 <notdan> Tangerine: what do you want to do?
05:26:00 <Tangerine> I have an IO [Int] called foo and I want to make a IO [Int] that contains the numbers from 1-9 that are NOT in foo
05:26:14 <bernalex> Tangerine: write a function that does what you want to do without IO
05:26:20 <bernalex> then use fmap to use it on something in IO
05:26:53 <Tangerine> oh so
05:27:02 <Tangerine> i could write my list comprehension with a generic list
05:27:16 <Tangerine> like in a lambda function
05:28:09 <notdan> > fmap (\a -> filter (not . flip elem a) [1..9]) (return [2,3])
05:28:11 <lambdabot>      No instance for (Show (f0 [a0]))
05:28:11 <lambdabot>        arising from a use of ‘show_M5719913404537083317930’
05:28:11 <lambdabot>      The type variables ‘f0’, ‘a0’ are ambiguous
05:28:21 <notdan> > fmap (\a -> filter (not . flip elem a) [1..9]) (return ([2,3] :: [Int]))
05:28:22 <lambdabot>      No instance for (Show (f0 [Int]))
05:28:22 <lambdabot>        arising from a use of ‘show_M7154152612818265928942’
05:28:22 <lambdabot>      The type variable ‘f0’ is ambiguous
05:28:28 <notdan> wh
05:28:43 <notdan> > fmap (\a -> filter (not . flip elem a) [1..9]) ((return [2,3]) :: IO [Int])
05:28:45 <lambdabot>  <IO [Int]>
05:28:55 <notdan> > print $ fmap (\a -> filter (not . flip elem a) [1..9]) ((return [2,3]) :: IO [Int])
05:28:56 <lambdabot>  <IO ()>
05:29:21 <notdan> Ok, i don't know how to get it to work in lambdabot, but that's the gist of it I think
05:29:37 <bernalex> uh that looks very overcomplicated
05:29:39 <Maxdamantus> just change `IO` to `Maybe`
05:29:45 <bernalex> Tangerine: just use your present function
05:29:52 <Maxdamantus> (in the example without print)
05:30:00 <notdan> True
05:30:00 <bernalex> Tangerine: let f a = [x | x <- [1..9], notElem x a]
05:30:11 <bernalex> Tangerine: now you can f <$> somethingInIO
05:30:15 <Tangerine> yup thats what I have
05:30:31 <bernalex> as an example
05:30:33 <bernalex> λ f <$> (read <$> getLine :: IO [Int])
05:30:35 <bernalex> [5]
05:30:37 <bernalex> [1,2,3,4,6,7,8,9]
05:30:47 <Tangerine> ah I see...
05:30:54 <bernalex> Tangerine: IO is a Functor. do you know about Functors? Functors are your friend.
05:30:56 <bernalex> :t fmap
05:30:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:31:01 <Tangerine> that makes sense now
05:31:08 <bernalex> now your function works on everything, not just IO.
05:31:16 <Tangerine> I was just confused as to what exactly fmap does
05:31:34 <bernalex> you can do f <$> [[5]] now, or f <$> Just [5]
05:32:02 <bernalex> read the type. it takes a function, and applies to to a value in some context, and then you get back the value with the function applied to it *in the same context it was in the first place*.
05:32:06 <bernalex> @src fmap
05:32:06 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:32:09 <bernalex> sigh
05:32:57 <bernalex> Tangerine: see https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Functor.html
05:33:35 <bernalex> Tangerine: for a rather in-depth explanatios nee https://wiki.haskell.org/Typeclassopedia#Functor (and the rest of that article)
05:33:44 <Tangerine> and just checking, does this also work if you're trying to filter through multiple lists?
05:34:01 <Tangerine> i.e. [1..9] not in foo, bar, or baz
05:34:26 <Tangerine> would I need to fmap 3 times?
05:39:13 <bernalex> Tangerine: I'm not sure what you mean.
05:39:33 <Tangerine> foo bar baz are all IO [Ints]
05:39:37 <bernalex> Tangerine: if you have some f :: a->b, then fmap will always be able to apply it to some f a and return some f b.
05:39:40 <Tangerine> and i want [1..9] not in either foo bar or baz
05:39:40 <jophish> Are the ghc-8 api docs online somewhere?
05:40:01 <bernalex> jophish: what API?
05:40:13 <jophish> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/ bernalex 
05:40:34 <jophish> aha https://downloads.haskell.org/~ghc/8.0.1-rc4/docs/html/libraries/ghc-8.0.0.20160421/index.html
05:40:50 <Tangerine> if I fmap once, then the result is IO [Int], but would I still use fmap when filtering the results with other IO [Int]s?
05:42:42 * hackagebot yesod-job-queue 0.3.0.0 - Background jobs library for Yesod.  https://hackage.haskell.org/package/yesod-job-queue-0.3.0.0 (nakaji_dayo)
05:42:59 <bernalex> Tangerine: you could fmap (fmap f) [foo, bar, baz]
05:43:48 <bernalex> Tangerine: I'm not sure what you really mean though
05:44:08 <Tangerine> if foo bar baz are sets
05:44:12 <bernalex> Tangerine: you mean you have three IO [Int] and want an IO [Int] after f-ing all the three IO [Int]s?
05:44:30 <Tangerine> then I want (([1..9] \ foo ) \ bar ) \baz
05:45:00 <bernalex> why don't you just concatenate foo & bar & baz first?
05:45:09 <Tangerine> i...didn't think of that...
05:45:42 <bernalex> if you use do-notation it will probably be nicer
05:45:50 <bernalex> g2g eat pizza. lunch. :)
05:45:58 <Tangerine> thanks for the help!
05:59:02 <bblfish> Interesting follow up article "Comonads are neighbourhoods, not objects" http://gelisam.blogspot.co.uk/2013/07/comonads-are-neighbourhoods-not-objects.html
06:06:24 <troydm> so I'm trying to use StateT and I have declared IO monad to be StateT's m now how do I convert IO action into State?
06:06:29 <troydm> *StateT
06:07:05 <troydm> execute IO action from inside StateT monad
06:07:10 <bergmark> :t liftIO
06:07:12 <lambdabot> MonadIO m => IO a -> m a
06:08:13 <troydm> bergmark: wait, isn't liftIO a hack 
06:08:19 <geekosaur> ??
06:08:28 <tpsinnem> the commentary in https://hackage.haskell.org/package/binary-0.8.3.0/docs/Data-Binary.html mentions decoding Binary-instanced values from a Handle, but package doesn't seem to actually contain any function that actually does that. is there another package that would do this, from a Handle or Fd?
06:08:36 <troydm> bergmark: I'm looking at more traditional transformer approah
06:08:37 <geekosaur> there's also just lift
06:08:38 <troydm> *ch
06:08:48 <geekosaur> but how is liftIO a hack?
06:10:06 <merijn> troydm: Well, you could explicitly wrap it into StateT, but, uh, that's exactly what liftIO already does?
06:11:49 <tpsinnem> ^ erm, nevermind i was interpreting the comments wrong
06:12:02 <nitrix> IO is anything but a hack :/
06:12:27 <troydm> sorry, I misunderstood usage of Haskell Transformers
06:12:31 <nitrix> MonadIO as well. Transformers are somewhat well-reasoned, despite being anti-patterns.
06:13:59 <merijn> Wut?
06:14:07 <merijn> When did transformers become an anti-pattern?
06:14:38 <bernalex> merijn: long since.
06:15:21 <merijn> Must be in some weird corner of the internet that I don't frequent, because I've never heard that
06:15:46 <bernalex> it's often mentioned here. and sometimes papers by prolific haskellers for that matter.
06:15:50 <geekosaur> there's a certain subpopulation around here that is convinced they're an antipattern
06:15:51 <maerwald> merijn: you mean stacking 20 effects with static ordering into each other with random lift functions is an elegant solution?
06:16:07 <maerwald> (not to mention writing that crap is horrible)
06:16:21 <geekosaur> the lovingly hand-crafted alternative of course has no issues
06:16:46 <merijn> maerwald: How do you even stack 20 effects? There isn't that many common transformers
06:17:17 <merijn> geekosaur: Custom artisanal hand-written monads?
06:17:38 <Akii> stumbled upon a paper the other day "Extensible Effects" that deals with State Transformers and their limitations
06:17:49 <Akii> hand crafted merijn
06:17:57 <bernalex> that would be oleg's paper.
06:18:03 <Akii> artisanal hand-crafted eloquent monads
06:18:06 <Akii> EloquenTM
06:18:15 <bernalex> he tends to be right about things, ime.
06:18:16 <Akii> yep et. al.
06:18:28 <merijn> Akii: Except the last time I looked at Extensible effects it was slow as shit :)
06:18:31 <maerwald> bernalex: yes and that solution is the right direction, although I'm not certain how well it plays out in that form in the haskell ecosystem currently
06:18:39 <maerwald> monad transformers are just limited
06:18:47 <merijn> Not to mention that the ordering has an impact of semantics, so extensible effects give up that choice
06:18:52 <bernalex> it works nice in purescript
06:18:56 <maerwald> indeed
06:19:02 <maerwald> and Idris
06:19:30 <maerwald> but I guess people are just used to that one solution so they want to stick with it ;)
06:19:33 <bernalex> purescript is even closer to haskell, so that's why I mentioned it. but it's great in idris too.
06:19:53 <bernalex> that doesn't really sound like haskell. SPJ refers to GHC as a "type laboratory" for crissakes.
06:20:35 <bernalex> although certain issues will probably never fixed, I don't think we're stuck with monad transformers as our only option forever.
06:20:44 <merijn> maerwald: What is the solution to performance issues and semantics of ordering effects with extensible effects?
06:21:39 <maerwald> merijn: I don't have any, but the direction is the right one
06:22:03 <merijn> Possibly
06:22:30 <merijn> But it's a bit soon to call things an anti-pattern if there isn't even a strictly better alternative yet
06:22:50 <maerwald> merijn: whether there are useful alternatives is orthogonal to the fact that something is an anti-pattern
06:22:53 <bernalex> there's a difference between using monad transformers and designing an entire library around them
06:23:51 <maerwald> merijn: also, I can see that monad transformers have their domain where they might be useful, I just think they are heavily oversued and in ways that make it an anti-pattern sometimes
06:28:00 <Benzi-Junior> does ghci not support generating tags recursively like "ctags -R" does using ":ctags -R" in ghci just writes the tags to a file named "-R"
06:28:11 <geekosaur> correct
06:29:36 <geekosaur> it is not a built in exuberant-ctags
06:29:46 <Benzi-Junior> geekosaur: you mean I am correct in saying that it doesn't support it ?
06:32:23 <Benzi-Junior> geekosaur: ok thanks
06:35:48 <Benzi-Junior> geekosaur: is it intended to stay that way or ?
06:37:26 <geekosaur> ghci is not a full IDE
06:38:11 <geekosaur> there are haskell tags packages on hackage. ghci provided only the bare minimum, it is not intended or expected to be the ultimate tags program
06:39:34 <Benzi-Junior> ye I completely understand I was just wondering
06:58:51 <`Guest00000> @pl \x -> x
06:58:51 <lambdabot> id
06:59:16 <`Guest00000> @pl \x y -> 10 * x + y
06:59:16 <lambdabot> (+) . (10 *)
06:59:40 <`Guest00000> @pl \x y -> y + 10 * x
06:59:41 <lambdabot> (+) . (10 *)
06:59:51 <`Guest00000> lies...
07:00:13 <hpc> (+) is commutative
07:00:20 <`Guest00000> @pl \x y -> (10 `mul` x) `plus` y
07:00:20 <lambdabot> plus . (10 `mul`)
07:00:32 <`Guest00000> @pl \x y -> y `plus` (10 `mul` x)
07:00:32 <lambdabot> flip plus . (10 `mul`)
07:00:35 <merijn> hpc: Denotationally, but not necessarily operationally :)
07:01:40 <hpc> i don't think anyone who cares about operational semantics is going to be using @pl
07:02:45 * hackagebot postgresql-transactional 1.1.1 - a transactional monad on top of postgresql-simple  https://hackage.haskell.org/package/postgresql-transactional-1.1.1 (patrick_thomson)
07:04:50 <nitrix> Where's tubs? He said he'd be here at 10 EST :)
07:06:29 <geekosaur> ...as I thought but did not say at the time, "AM or PM?"
07:09:01 <sena_kun> hi folks. does yi text editor development is dead? No improvement commits for a few months already.
07:10:58 <geekosaur> wasn't there a new release over the weekend?
07:13:36 <mdibaiee_> Hey, I'm wondering if there is a way to disable CAFs entirely, or deeply for a function (if I use NOINLINE on a function, functions used inside it, probably built-ins, are not disabled)
07:13:51 <sena_kun> geekosaur, this release only fix one build bug, without any improvevents. It's not like I can tell people what to do on their free time, only interested in current status of the project. Maybe it'll be better to ask the devs, though.
07:14:01 <mdibaiee_> I explained my situation completely here: https://mail.haskell.org/pipermail/beginners/2016-May/016841.html
07:14:48 <sena_kun> s/fix/fixed/
07:19:30 <geekosaur> mdibaiee, if you are seeing memory being taken up by "CAF" then you have written something that grows indefinitely. this is not a general property of CAFs but a specific property of a particular CAF
07:20:42 <geekosaur> usually it is something recursive, like the classic Fibonacci: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
07:20:56 <geekosaur> which will grow as values are requested from it and will memoize them
07:21:11 <geekosaur> if that's not what you want thne you need to reformulate it so it doesn't implicitly memoize
07:22:48 <geekosaur> (and, you can't get rid of CAFs entirely. main :: IO a is a CAF, and required)
07:47:33 <fractalsea> I'm rewriting a Haskell function in C that I will call through the FFI. The Haskell version returns a Maybe. What type should I use to represent this in C, and how should I marshall it into Haskell Maybe? Thanks
07:49:36 <phadej> fractalsea: depends on Maybe what
07:50:08 <fractalsea> phadej, it's just a Maybe Word64
07:50:33 <phadej> but anyway: first rewrite the function, then think about ffi part
07:51:09 <fractalsea> phadej, ok well I guess I should just return a "null", but I'm just not used to C so I don't know if that's bad practice
07:51:50 <phadej> fractalsea: you cannot return NULL as uint64_t, it would be just 0
07:52:16 <phadej> The task you on, sounds suspcisios. Why you are rewriting Haskell function in C?
07:52:17 <fractalsea> phadej, ah I see. Well that could actually be sufficient...
07:53:15 <fractalsea> phadej, because we have a large long lived data structure that needs low latency reads/writes. The Haskell GC causes latency spikes that are unacceptable
07:58:40 <CptnSandwich> hi, is there a nice solution to the "configuration problem"? having immutable global variables that affect function behaviour?
07:59:07 <CptnSandwich> or do i just make a config record type and pass it around?
07:59:30 <dmj`> CptnSandwich: you can use a reader monad
08:00:51 <CptnSandwich> dmj`: and then i 
08:00:59 <CptnSandwich> 'runreaderT' all my functions?
08:01:04 <CptnSandwich> the monadic ones at least
08:02:16 <CptnSandwich> dmj`: nevermind, the examples in the haddock should suffice
08:02:46 * hackagebot cabal-helper 0.7.0.1 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.7.0.1 (DanielG)
08:02:50 <deni> how would one write an instance for FromJSON for an API that returns something like "items": [{...}] when returning collections but returns "item": {...} when returning just one item. Ie. different toplevel key.... or rather....why is there even a toplevel key at all
08:04:02 <dmj`> CptnSandwich: I'd use the MonadReader typeclass, then you can program against an interface that has a global config
08:04:05 <dmj`> from mtl
08:04:37 <deni> the only thing that I can think of is to do a newtype ItemList....but that's so meh
08:05:00 <dmj`> :t show <$> ask :: MonadReader Int m => m String
08:05:01 <Boomerang> deni you could have an intermediary data type with both Maybe Item for and Maybe [Item] and then convert that to another data type [Item] yourself (throwing an error if both are Nothing)
08:05:01 <lambdabot> MonadReader Int m => m String
08:05:04 <dmj`> CptnSandwich: ^
08:05:38 <Boomerang> and throwing an error if both are Just too
08:06:49 <Boomerang> (By throwing an error I mean whatever system you use for Json decode, Either, Maybe or even error if that's what you're doing)
08:07:15 <deni> Boomerang: do you have an example handy? 
08:07:35 <Boomerang> I could write one
08:10:19 <`Guest00000> how can i overload function application?
08:11:08 <dolio> You can't.
08:12:08 <magneticduck> hm, what's the canonical way of defining a library along with an application that uses that library in the same cabal file?
08:12:48 <dolio> A library section and an executable section.
08:12:52 <Peaker> Is there a nice idiom for: ($ x) <$> wrappedFunc  somewhere?
08:13:00 <dcoutts> magneticduck: define both components in the .cabal file, make the exe depend on the lib. Put the exe in a different src dir from the lib and set the hs-source-dirs appropriately in the .cabal file.
08:13:26 <dolio> @type (??)
08:13:27 <lambdabot> Functor f => f (a -> b) -> a -> f b
08:13:39 <dcoutts> magneticduck: the key thing is that src dirs thing, otherwise the exe will just pick up the source files directly rather than using the lib.
08:14:14 <magneticduck> dcoutts: but when I make a dependency with build-depends, I don't target 'the lib' I target the whole project being defined by the responsible cabal file, right?
08:14:22 <magneticduck> well, what you say works, so I don't understand something
08:14:29 <dcoutts> magneticduck: the lib has the same name as the package as a whole
08:15:18 * dcoutts notes that cabal-1.26 will support private convenience libs too
08:19:26 <magneticduck> dcoutts: "cannot satisfy -package-id <package>-1.0.0-inplace"
08:19:53 <dcoutts> magneticduck: did you add the dependency?
08:19:57 <magneticduck> ah never mind, the library declaration was malformed
08:20:02 <magneticduck> I had a colon after library
08:20:10 <dcoutts> ah ok
08:20:15 <magneticduck> interesting that that wasn't caught as a syntax error and instead messed up dependency resolution
08:25:45 <lpaste> Boomerang pasted “deni JSON item/items” at http://lpaste.net/162720
08:25:54 <Peaker> dolio, cool, thanks :)
08:26:22 <Boomerang> deni: make sure to use proper handling of the JSON parsing errors though :)
08:29:28 <lpaste> Boomerang revised “deni JSON item/items”: “deni JSON item/items” at http://lpaste.net/162720
08:33:22 <SNT604> Anyone here??
08:33:51 <geekosaur> only about 1500 of us...
08:34:19 <SNT604> Can someone help in tech?
08:35:25 --- mode: Cale set -o Cale
08:36:19 <magneticduck> SNT604: (maybe)
08:36:32 <Cale> SNT604: On IRC if you want help with something, it's usually better just to ask your actual question (hopefully related to the channel you're in) rather than asking *if* someone can help you with something that they don't know what it is yet.
08:36:56 <Cale> There's a lot of people here, someone might be able to help, but nobody knows if they can help with something that they don't know what it is.
08:37:21 <tumble_> can someone look at this code
08:37:25 <tumble_> https://gist.github.com/anonymous/1aa19818f0baa8df61cc3a4ae1d018cd
08:37:35 <tumble_> And tell me why there's an parse error?
08:37:36 <deni> Boomerang: nice!! thank you! I've had this problem in another project I was working as well so it's going to help alot
08:37:44 <SNT604> ok thanks for the reply.. i'll surely do that
08:37:58 <SNT604> How to use outlook with gmail??
08:38:18 <geekosaur> tumble_, it's usually a good idea to include the full error message with any such code
08:38:24 <Cale> tumble_: Well, first of all, Haskell is case sensitive. Module and Where are not keywords, but module and where are.
08:38:25 <Boomerang> deni: Good luck with your project :)
08:38:25 <tumble_> oh sorry
08:38:26 <tumble_> new
08:38:41 <geekosaur> but in this case I see an indentation problem on lines 27-28
08:38:43 <Cale> You don't have to indent the entire module
08:38:50 <magneticduck> SNT604: uh-oh, the internet is leaking again
08:38:54 <Cale> and yeah, there's also the indentation issue at the end there
08:39:01 <geekosaur> if you're using tabs, don't; the interpretation of tabs is ... variable, and Haskell is indentation-sensitive
08:39:19 <geekosaur> (like Python if you've used that)
08:39:30 <Cale> The first non-whitespace character following 'let' (or 'do', 'of', 'where') sets the indentation level for the block
08:39:43 <Cale> All the subsequent lines which belong to that block need to start in the same column
08:39:46 <tumble_> oh
08:39:48 <tumble_> s:26:22: parse error in let binding: missing required 'in'
08:39:53 <tumble_> That's what it's saying too now
08:39:54 <tumble_> thanks
08:40:01 <Cale> (which is why tabs don't mix with Haskell code, because we care which column things start in)
08:40:28 <SNT604> Anyone knows any tech channel??
08:41:28 <Cale> SNT604: Nothing in particular? Just "tech"?
08:41:39 <tumble_> Now I'm getting this error https://gist.github.com/anonymous/b080f9ac2459c443f5f416588f4d03b6
08:41:44 <magneticduck> he wants help with setting up an email client
08:41:54 <magneticduck> I .. really don't know where you'd find that on freenode
08:42:06 <SNT604> Tech channel for solving issues or error?
08:42:43 <Cale> tumble_: okay, so it's saying that f :: a -> a -> Bool
08:42:50 <tumble_> Yes
08:42:52 <Cale> tumble_: So it takes two arguments
08:43:38 <tumble_> so change it to a -> Bool?
08:43:43 <Cale> (not . f) x = not (f x) would be applying not to something which is a function of that second argument
08:43:54 <Cale> Perhaps you want (\x y -> not (f x y)) ?
08:43:57 <tumble_> What if I added another hand
08:43:59 <tumble_> like hand2
08:44:13 * ski normally indents the whole of the module ..
08:44:27 <Cale> Oh, but then that's not a suitable argument to filter either
08:44:32 <tumble_> oh
08:44:36 <tumble_> so how do I change it?
08:44:45 <tumble_> This isn't my code, but I'm meant to modify it
08:44:56 <tumble_> and I am not good at doing that with other people's code
08:44:58 <Cale> Oh, I see what you're doing
08:45:12 <Cale> filter (not . f h) t
08:45:54 <tumble_> oh ok
08:46:09 <Cale> hand1 = [card1]++[card2]++[card3]++[card4]++[card5]++[card6] could be written  hand1 = [card1, card2, card3, card4, card5, card6]
08:47:21 <tumble_> error
08:47:39 <maerwald> why can't I add directories or proper globs to "extra-source-files:"?
08:47:40 <tumble_> https://gist.github.com/anonymous/e9154120120ccf8e22bfcbf256006846
08:47:47 <tumble_> Thank you for the help Cale.
08:48:01 <Cale> tumble_: Well, yeah, hand1 is a list of cards
08:48:17 <Cale> tumble_: The first argument to mySort is a function
08:48:31 <tumble_> so how do I pass hand1 in?
08:48:36 <Cale> Try  mySort (<=) hand1
08:48:43 <maerwald> I have like 30 test files in a test directory... does cabal expect me to list them all now or what?
08:49:12 <dcoutts> maerwald: it lets you use wildcards if the files share a file extension
08:49:25 <maerwald> they are in different directories, that will save me nothing
08:49:34 <Cale> tumble_: Oh, you don't have an Ord instance
08:49:38 <tumble_> yea
08:49:47 <dcoutts> maerwald: sorry, this is being relaxed/generalised in later versions
08:50:06 <tumble_> So how do I do that, Cale?
08:50:07 <Cale> tumble_: In that case, maybe try something like  mySort (\x y -> cardValue x <= cardValue y) hand1
08:50:27 <tumble_> IS there some code I can add in to add the ord?
08:50:30 <Cale> yeah
08:50:32 <tumble_> if it's short
08:50:39 <tumble_> what would that be? if you don't mind
08:50:46 <Cale> See the 'deriving (Show)' bit?
08:50:50 <tumble_> Yea
08:51:02 <Cale> Change it to 'deriving (Eq, Ord, Show)'
08:51:49 <tumble_> And then now how do I call it?
08:52:22 <Cale> That gives you equality tests (==), (/=) and ordering (<=), (>), compare, etc. for those data types
08:52:34 <tumble_> and do I put that in both of the data types?
08:52:41 <Cale> yeah
08:53:00 <Cale> and there's a generic instance  (Ord a, Ord b) => Ord (a,b)
08:53:20 <tumble_> ok cool
08:53:22 <Cale> which compares the first component of the pair, and only if it matches, it compares the second component
08:53:34 <Cale> So, you'll be able to compare cards then
08:53:37 <tumble_> And if I wanted to make hand 2, I just do the same thing again?
08:53:42 <tumble_> but name it card 2?
08:53:45 <tumble_> hand2*
08:53:49 <Cale> You could
08:53:54 <tumble_> ok cool
08:54:01 <Cale> I would probably just write the things into the list directly
08:54:20 <Cale> hand1 = [(Ten, Spades), (Jack, Spades), ...]
08:54:37 <tumble_> Has to be a new hand :/
08:55:11 <Cale> Well, yeah, it doesn't matter which hand it is we're talking about :P
08:55:19 <tumble_> oh lol
08:56:06 <Cale> It just seems a little awkward to define each of the cards separately like that, and then make a list out of them -- unless perhaps there's some reason to do that
08:56:20 <tumble_> I'm not aware of it, but it was specified
08:56:28 <deni> Boomerang: unfortunately it doesn't work...you can't have a type alias like that in the instance declaration
08:56:43 <Boomerang> do a newtype then :)
08:56:44 <Cale> If you had to refer to (Jack, Spades) a whole bunch of times, maybe card2 would be a reasonable thing to define
08:56:59 <deni> Boomerang: yeah that's basically what I did with my previous iteration
08:57:10 <Cale> (but even then, sJ or something might be a better name for it)
08:57:22 <Boomerang> In the first version I wrote it with newtype but then changed it. Is this not good for your project?
08:57:48 <deni> Boomerang: basically i need onre more data type for parsing a single item
08:58:05 <maerwald> wow, cabal sdist cannot handle broken symbolic links... seems it tries to follow symlinks
08:58:42 <deni> Boomerang: or rather...I think I can just have function toItem vs toItems
08:58:48 <deni> shuld work
08:59:01 <dcoutts> maerwald: I think in the majority of cases here for sdist, following symlinks would be the "right thing"tm no?
08:59:16 <maerwald> I guess I'll just have the tests break with cabal sdist and tell people to file a cabal bug
08:59:20 <Boomerang> In that case you don't even need the intermediary data type, just parse them as maybe separately (item and items)
08:59:21 <dcoutts> one has to produce a self-contained tarball, so if you're symlinking other things into your build tree
08:59:44 <dcoutts> then those ought to be copied into the tarball
08:59:52 <maerwald> dcoutts: IMO, following symlinks is barely the right thing, especially when I tar something up
09:00:03 <maerwald> but yeah, it's hard to guess what the user wants
09:00:13 <Boomerang> I thought you just wanted to parse them to a list of items regardess if it was just one or several items. This is obviously a decision that depends on the rest of your project :)
09:00:19 <Cale> I don't really understand why you'd have symbolic links in the first place...
09:00:25 <maerwald> Cale: as I said: tests
09:00:30 <deni> Boomerang: I don't think I can away without the intermediate type
09:00:52 <tumble_> Thanks a lot guys
09:00:53 <deni> Boomerang: or I don't understand what you mean...basically I need to be able to parse Maybe Item and Maybe [Items] 
09:00:55 <tumble_> cale especially
09:01:07 <Cale> maerwald: can't the tests make the broken symlinks themselves?
09:01:22 <maerwald> Cale: circular tests then?
09:01:57 <deni> Boomerang: and I don't know how to get away without creating a newtype ItemList
09:02:48 <maerwald> Cale: I want to have as little foreign IO in my tests as possible, if I start messing with files, it gets worse
09:03:10 <maerwald> and it's easy to pre-create them
09:03:16 <maerwald> just that cabal doesn't know how to handle it
09:04:28 <Yaiyan> What does "type State = String -> Integer" mean? I've been trying to google, but it's a bit hard when google doesn't let you search for symbols
09:04:49 <Yaiyan> Does the type mean a function, or?
09:05:04 <ski> it's a function type, yes
09:05:26 <ski> if something is of type `State', then that means that it is a function from inputs of type `String' to outputs of type `Integer'
09:05:44 <ski> so, `State' is defined to be the type of functions from `String' to `Integer'
09:06:02 <Yaiyan> Hmm, thanks
09:06:19 <ski> it's just an abbreviation/synonym/macro
09:06:23 <ski> whenever you write
09:06:26 <ski>   foo :: State
09:06:30 <ski> you could just as well have written
09:06:36 <ski>   foo :: String -> Integer
09:06:38 <Yaiyan> So then, func :: Typea -> State -> z; is a function taking in Typea, and a function as an argument
09:06:38 <Yaiyan> Oh
09:06:47 <Yaiyan> Ok, I see what you mean
09:06:49 <ski> yes, that signature is an abbreviation for
09:06:57 <Boomerang> deni: What is the object above "item" or "items" in the hierarchy? When parsing that one just use a Maybe for both "item" and "items", then whatever code using that parent data type will have to handle the Nothing and Just case for each of them. The solution I was giving you made a list every time, when you only have one item it would be a singleton list. This method gets rid of the Maybe by enforcing that only (and exactly) one of "i
09:06:57 <Boomerang> tem" and "items" is present in the JSON.
09:07:00 <ski>   func :: Typea -> (String -> Integer) -> z
09:07:05 <deni> how can I get "0.00744" (Float) to show up as such rather than "7.44e-3" ?
09:07:18 <Yaiyan> Ok, thanks :)
09:08:01 <ski> > showEFloat Nothing 0.00744 ""
09:08:03 <lambdabot>  "7.44e-3"
09:08:04 <ski> > showFFloat Nothing 0.00744 ""
09:08:06 <lambdabot>  "0.00744"
09:08:07 <ski> > showGFloat Nothing 0.00744 ""
09:08:09 <lambdabot>  "7.44e-3"
09:08:21 <ski> deni : probably you can use one of those
09:08:25 <deni> ski: tnx
09:08:45 * ski doesn't recall the difference
09:10:28 <deni> Boomerang: so basically have a case statement in the parseJSON function and use whichever is present "item" or "items" as a toplevel object?
09:11:03 <deni> Boomerang: will that work with just one datatype "Item" (so without a newtype ItemList) ?
09:14:06 <puregreen> where is the cabal config file on Windows and OS X?
09:15:38 <Boomerang> I'm not sure how you will be using this item/items afterwards but make sure that it is consistent at the type level. If you want to keep the possibility that it is either a single item or a list of items then you can use something like Either Item [Item]. I thought it would be better to just make it [Item] and then it is easier to handle afterwards.
09:16:40 <somenickz> Hi guys, any idea on how to reach the Russian underground hackers who do hack for pay?
09:17:05 <Boomerang> You shouldn't follow the way JSON was designed with one item and several items separate except if it is an important distinction for your application
09:17:06 * ski idly wonders how somenickz's question is related to the Haskell programming language
09:17:57 * ski thinks Boomerang is advocating treating one case as (being a shorthand for) a subset of the other case
09:18:02 <hpc> people just come in here sometimes thinking they can ask "hai gais hao2blackhat plz"
09:18:22 <puregreen> somenickz: this channel is logged and the logs are stored forever
09:18:22 <hpc> it's probably hackage
09:18:32 <puregreen> somenickz: no self-respecting hacker will talk to you now
09:18:46 <puregreen> you're already on the watchlists
09:18:55 * ski notes that puregreen clearly can't be a self-respecting hacker
09:18:56 <hpc> somenickz: new york university won't be happy to know what you're doing on their network
09:20:01 <puregreen> ski: yeah, I wanted to pretend to be a Russian undergeround hacker at first but then thought the other option was more interesting
09:20:07 <puregreen> * underground
09:20:08 <Boomerang> ski, from the wording of the original question it did seem that there was no reason for such a design in the JSON. That may be wrong, I have no idea what the context is :)
09:20:10 <hpc> but then i took an arrow to the knee
09:20:24 <Tekkkz> Hello. I have a string in an url encoded format, like: "this is an %C3%A4" (what means: "this is an ä") ... how can I decode this in haskell to an "ä" ?
09:21:08 <ski> anyway, i was going to say to somenickz that presumably the "Russian underground hackers" would respect them more if they learned how to "hack" for themselves
09:21:13 <ski> (but they left)
09:21:36 <hpc> i wonder if it was the watchlist comment or my whois that scared them off
09:22:23 <puregreen> maybe they just didn't feel quite welcome
09:22:35 <hpc> heh
09:22:54 * ski . o O ( "The Scheme Underground" <http://www.ai.mit.edu/projects/su/su.html> )
09:23:02 <Boomerang> Tekkkz, there are several libraries that can help. Maybe have at this method: https://hackage.haskell.org/package/http-types-0.9/docs/Network-HTTP-Types-URI.html#v:urlDecode
09:23:02 <geekosaur> Tekkkz, http://hackage.haskell.org/package/network-uri-2.6.1.0/docs/Network-URI.html#v:unEscapeString
09:23:02 <hpc> soon, somewhere in st petersburg, "don't try haskell, the people on irc are so unwelcoming"
09:23:30 <Boomerang> * a look
09:24:01 <chattered> How do you derive the generic instance for an imported datatype?
09:24:31 <puregreen> chattered: try standalone deriving
09:24:32 <puregreen> https://wiki.haskell.org/GHC/Stand-alone_deriving_declarations
09:24:38 <Tekkkz> geekosaur: these are no escape strings, or?
09:24:48 <puregreen> no, bad link
09:24:52 <chattered> puregreen: Cheers.
09:25:49 <puregreen> chattered: anyway, you just put “deriving instance Generic T” on a separate line in the file
09:26:04 <puregreen> and enable {-# LANGUAGE StandaloneDeriving #-} at the top
09:27:48 * hackagebot servant-quickcheck 0.0.0.0 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.0.0 (jkarni)
09:29:09 <chattered> puregreen: No worries. Found the right link.
09:30:28 <Tekkkz> Boomerang: I get from »urlDecode True (strToBS "hello+world%C3%A4")« output: ""hello world\195\164"" but I need ""hello world ä"" ..?
09:30:55 <geekosaur> it gave you utf8, you have to then decode that
09:30:57 <Boomerang> Use a UTF8 decoding
09:31:07 <Tekkkz> Boomerang: eg?
09:32:19 <puregreen> Tekkkz: apply Data.ByteString.UTF8.toString to it
09:32:30 <puregreen> from utf8-string
09:33:09 <puregreen> alternatively, just use the function from network-uri instead
09:34:29 <maerwald> Tekkkz: also, after you've converted it to String, don't call 'show' on it
09:34:40 <Boomerang> in the same library there is https://hackage.haskell.org/package/http-types-0.9/docs/Network-HTTP-Types-URI.html#v:parseQueryText
09:34:58 <Boomerang> To parse an URI to a UTF8 encoded Text
09:36:03 <Boomerang> But utf8-string is probably simpler
09:37:49 * hackagebot nested-routes 7.1.0.1 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-7.1.0.1 (athanclark)
09:37:51 * hackagebot atomic-primops 0.8.0.4 - A safe approach to CAS and other atomic ops in Haskell.  https://hackage.haskell.org/package/atomic-primops-0.8.0.4 (RyanNewton)
09:43:22 <jophish> If there's anyone in the UK looking for some fun Haskell work, take a look: https://www.reddit.com/r/haskell/comments/4ikdx5/myrtle_software_is_looking_for_haskell_developers/
09:44:47 <magneticduck> how might one hide a few symbols from a module being imported and assigned a name?
09:45:02 <puregreen> import X hiding (a, b, c)
09:45:02 <jophish> magneticduck: import Foo hiding (bar, baz)
09:45:02 <hpc> jophish: that's the one from the other day with the low chance of remote hires, right?
09:45:07 <magneticduck> e.g. import Thing as Export hiding (something)
09:45:10 <jophish> hpc: that's the one
09:45:23 <jophish> sorry about the remote thing
09:45:28 <hpc> yeah
09:45:29 <puregreen> import qualified X as Y hiding (a, b, c) then
09:45:31 <magneticduck> jophish: yeah I know about hiding, but when I have an 'as' clause in there, I get a parse error
09:45:56 <magneticduck> I can't hide without qualifying?
09:46:07 <puregreen> you can
09:46:17 <magneticduck> iff I'm not assigning a name to the module?
09:46:20 <puregreen> I just tried it without qualifying and it worked for me
09:46:31 <puregreen> “import Prelude as X hiding (a, b, c)”, to be exact
09:46:44 <deni> Boomerang: this is what I came up with: http://dpaste.com/1S7NXPC
09:47:19 <magneticduck> right, the issue was something else
09:49:13 <Boomerang> deni: That seems like a nice and concise solution for droplet/droplets :) Are you using Applicative Do for parseJSON?
09:49:17 <maerwald> is hackage case sensitive? can you upload a package with the same name but with different case?
09:49:40 <dolio> It was in the past, at least.
09:50:04 <jophish> maerwald: it is
09:50:20 <jophish> https://hackage.haskell.org/package/vulkan https://hackage.haskell.org/package/Vulkan
09:50:28 <maerwald> meh, the colliding package is 6 years old
09:50:51 <maerwald> oh
09:51:06 <Boomerang> jophish: Do you know if myrtle software is taking interns?
09:52:25 <jophish> Boomerang: Sure, send us a CV!
09:53:42 <Boomerang> Great! But it's probably too late for this summer, right?
09:54:37 <jophish> Boomerang: not at all, we're fairly small so are able to onboard people fairly quickly
09:55:12 <deni> Boomerang: not in this instance...but i'm experimenting right now so I might rewrite it in applicative style.... (i usually use that notation for most cases)
09:55:23 <Tekkkz> Boomerang: »toString $ urlDecode True (stringToBS "hello+world%C3%A4")« results in "hello world\228" ... but still no "ä" ...
09:57:11 <Tekkkz> 228 is utf8 hex code for ä
09:59:05 <ski> Tekkkz : as maerwald said, don't use `show'/`print'. use `putStr' or something
09:59:36 <maerwald> > show "äü"
09:59:38 <lambdabot>  "\"\\228\\252\""
09:59:39 <Boomerang> Tekkkz I think ski is onto something
09:59:40 <maerwald> ...
10:00:10 <ski> > "äü"
10:00:12 <lambdabot>  "\228\252"
10:01:27 <Tekkkz> > putStr "\228"
10:01:29 <lambdabot>  <IO ()>
10:01:40 <ski> @help run
10:01:40 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
10:01:47 <ski> note the "no IO" part
10:01:58 <Tekkkz> ok
10:02:04 <Tekkkz> but it works in ghci
10:02:07 <ski> yes
10:02:07 <puregreen> > text "\228"
10:02:09 <lambdabot>  ä
10:02:14 <Tekkkz> BUT: i don't wanna print it. I need it for a variable
10:02:26 <ski> then don't print it
10:02:31 <ski> what is the problem ?
10:02:41 <puregreen> Tekkkz: "hello world\228" is just how your String is shown in GHCi
10:03:02 <ski> > 'ä'
10:03:02 <ski> is the same thing as
10:03:04 <lambdabot>  '\228'
10:03:04 <Tekkkz> puregreen: oh ok
10:03:15 <ski> it's a single character
10:03:16 <maerwald> show is for debugging, not for pretty-printing
10:03:23 <Tekkkz> then it's solved, thanks for all
10:03:33 * ski nods
10:03:34 <maerwald> https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
10:04:09 <simpson> > take 5 $ iterate (^2) 2
10:04:10 <lambdabot>  [2,4,16,256,65536]
10:04:19 <simpson> > take 5 $ iterate (^9) 9 -- "Go nuts!"
10:04:20 <lambdabot>  [9,387420489,196627050475552913618075908526912116283103450944214766927315415...
10:04:37 <simpson> Wow, it put more effort into that than I would have expected.
10:05:17 <hpc> > length . show $ 9 ^ 9 ^ 9
10:05:23 <lambdabot>  mueval: ExitFailure 1
10:05:33 <ski> > take 7 (iterate (2^) 0)
10:05:35 <lambdabot>  [0,1,2,4,16,65536,2003529930406846464979072351560255750447825475569751419265...
10:05:40 <hpc> > length . show $ (9 ^ 9) ^ 9
10:05:42 <lambdabot>  78
10:05:47 <hpc> only 78 digits ;)
10:06:15 <ski> > (length . show . (!! 6) . iterate (2 ^)) 0
10:06:16 <lambdabot>  19729
10:08:21 <hongminhee> I am finding a good templating engine (not for HTML, but plain text)
10:08:46 <hongminhee> could you recommend anything to me?
10:09:01 <hpc> :t id -- hongminhee ;)
10:09:02 <lambdabot> a -> a
10:09:25 <hpc> not sure what a templating engine for plain text would even do tbh
10:09:44 <hongminhee> I tried to use hamlet first, but it seems assume the result will be html
10:10:09 <hongminhee> I actually need to generate some Python code stuffs
10:10:59 <hpc> that's less a templating engine and more a DSL or eDSL
10:11:27 <hpc> try language-python
10:11:33 <ski> @oeis 1 0 1 2 9
10:11:34 <lambdabot>  Subfactorial or rencontres numbers, or derangements: number of permutations ...
10:11:56 <hongminhee> at first I used AST provided by language-python, but generating Python code by building AST was too easy to be verbose
10:12:50 <hongminhee> I tried also Text.Shakespeare.Text as well, but it does not provide loops nor conditionals
10:12:55 <hpc> write code of your own that factors out the verbosity and uses language-python under the hood
10:13:24 <hongminhee> haha that seems too long way to go 😭
10:13:28 <hpc> this is one of those weird fringe needs that is never going to have a completely perfect solution for all needs ;)
10:14:06 <ski> hongminhee : looks like you want a (heterogenous) staged programming system
10:14:43 <ski> perhaps something like camlp4/camlp5 could work
10:14:49 <ski> (that's for OCaml)
10:17:02 <koomi> hpc: a common case for non-html templating is filling in variables in config files
10:17:30 <koomi> or generating spam messages if you insist on plain text :-)
10:17:48 <hpc> nah most spam is html nowadays
10:29:12 <hongminhee> i wonder what is the most widely used way to generate script codes e.g. py/rb/js
10:30:10 <Jinxit> I did it the dumb way of concatenating text based on an AST
10:30:14 <Jinxit> but it didn't feel good at all
10:30:23 <hongminhee> indeed
10:32:23 <Guest71639> Hi :D
10:32:36 <Guest71639> My code is not working http://collabedit.com/grrw2
10:32:51 <Guest71639> fizruk: hi
10:33:20 <fizruk> Guest71639: o/
10:33:57 <noGoog> \o
10:35:26 <sm> hongminhee: there are a lot of templating libs on hackage, I think some of them must support both plain text and logic
10:36:22 <Guest71639> What is haskell
10:36:25 <sm> http://stackoverflow.com/questions/5770168/templating-packages-for-haskell lists some (but there are more)
10:36:36 <hongminhee> thank you!
10:37:16 <Guest71639> http://collabedit.com/7tru5
10:37:24 <Guest71639> Need some help withmy code
10:39:48 <Guest71639> http://collabedit.com/7tru5 contains my question
10:40:59 <srhb> Guest71639: If you paste it on lpaste.net, people can view it without having to enter a name or anything.
10:41:23 <lyxia> it's not haskell
10:41:27 <srhb> Oh.
10:41:41 <srhb> Guest71639: This channel is about the Haskell Programming language. :)
10:41:49 <Guest71639> http://lpaste.net/162725
10:42:00 <Guest71639> srhb: I know but are you good at bash
10:42:11 <Guest71639> http://lpaste.net/162725
10:42:14 <Nycatelos> Guest71639, try #bash?
10:42:26 <Nycatelos> or the other channels dedicated to what you're having issues with
10:43:13 <ChameleonSix> hello
10:43:34 <ChameleonSix> is this a good learning material?
10:43:35 <ChameleonSix> http://learnyouahaskell.com/introduction#about-this-tutorial
10:43:57 <Nycatelos> yes
10:44:15 <ChameleonSix> ok
10:44:20 <ChameleonSix> anything else to recommend?
10:44:41 <Nycatelos> http://haskellbook.com/
10:45:17 <srhb> ChameleonSix: https://github.com/bitemyapp/learnhaskell/ -- the author of this list really dislikes LYAH though, so the advice might be somewhat contrary :-)
10:45:19 <Guest71639> https://codereview.stackexchange.com/questions/127921/creating-a-vhost-on-a-port
10:45:34 <dolio> Guest71639: This channel is for Haskell discussion.
10:45:36 <srhb> Guest71639: Your question is off topic in this channel. People stop repeating it.
10:45:54 <ChameleonSix> haskell is good
10:45:55 <ChameleonSix> ?
10:46:15 <srhb> ChameleonSix: It's thoroughly enjoyable!
10:46:18 <Guest71639> sorry
10:46:19 <ChameleonSix> ok
10:46:21 <ChameleonSix> scala/
10:46:24 <Guest71639> join the #--
10:46:25 <srhb> ChameleonSix: (What do you expect people in this channel will answer. ;-))
10:46:26 <ChameleonSix> is it beter
10:46:29 <ChameleonSix> hah yes
10:46:41 <np356> Is there a tutorial that shows how to build a real-world semi-large system in haskell?
10:46:57 <jle`> np356: what aspects are you asking about?
10:47:01 <np356> I've read many books on haskell and now I need something that will glue all those concepts together
10:47:17 <jle`> or are you looking for a tutorial about a *specific* real-world semi-large project?
10:47:24 <jle`> or a tutorial explaining basic principles of making one?
10:47:51 * hackagebot pureMD5 2.1.3 - A Haskell-only implementation of the MD5 digest (hash) algorithm.  https://hackage.haskell.org/package/pureMD5-2.1.3 (ThomasDuBuisson)
10:48:09 <np356> I understand most concept, and I can implement things in haskell fairly well, I just need something that will guide me through the process of thinking about building an entire system in haskell, like how to isolate IO from computation, how to structure types and code
10:48:16 <np356> something more practial
10:49:09 <nitrix> What about trial and error & common sense? Sounds cliche, but a couple side projects to gain experience would be 2X more beneficial I think.
10:49:29 <nitrix> Then you can read on the parts that are problematic as you hit them.
10:49:54 <nitrix> I doubt you have apply the same magical methological approach for any project.
10:49:59 <nitrix> s/have/can/
10:51:25 <srhb> Also, if you run into problems, this channel! :-)
10:51:39 <ChameleonSix> tnx
10:51:59 <sm> np356: there have been a number of posts and docs covering various parts of that.. if they are gathered anywhere, it will be on the wiki
10:52:51 * hackagebot hpath 0.5.9 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.5.9 (maerwald)
10:53:55 <ChameleonSix> how do i access the bash shell
10:53:58 <ChameleonSix> like system()
10:54:02 <sm> np356: a quick way to learn more about the file structure, eg, is stack new
10:54:40 <sm> ChameleonSix: look at the process lib, or others like turtle and shelly
10:54:46 <ChameleonSix> ?
10:54:50 <ChameleonSix> any command for that
10:55:23 <sm> yes, in those libraries I mentioned. You can find docs for those packages on hackage, or by searching at http://haskell.org/hoogle
10:55:37 <ChameleonSix> ok
10:56:02 <srhb> ChameleonSix: If you've never used Haskell before, this is not where you want to start!
10:56:07 <srhb> (That's just opinion, of course)
10:56:09 <jgoux> Hello, I imagine it's a frequent question so sorry to ask it but when does GHC 8.0 will be released ? I saw a "mid april" date somewhere
10:56:19 <ChameleonSix> i am reading a book
10:56:21 <srhb> jgoux: Soon^TM
10:57:00 <jgoux> srhb: Do you mean, http://i2.kym-cdn.com/photos/images/facebook/000/117/012/tumblr_lj57goZvBh1qdjdp1o1_500.jpg ? :P
10:58:03 <srhb> jgoux: Yes. :)
10:58:10 <jgoux> Oh, this is where I saw the mid-april : https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1#Dates
10:58:18 <jgoux> ok, soon is fine ! :D
10:59:08 <sm> ChameleonSix: here are some good ways, eg: http://hackage.haskell.org/package/process-1.4.2.0/docs/System-Process.html#g:2
10:59:45 <ChameleonSix> ok
11:01:55 <Guest71639> hi
11:02:11 <Guest71639> ./join #parakeet
11:02:14 <Guest71639>  ./join #parakeet ./join #parakeet
11:02:15 <Guest71639>  ./join #parakeet
11:02:16 <Guest71639>  ./join #parakeet
11:02:17 <Guest71639> No
11:02:19 <Guest71639>  ./join #parakeet
11:02:22 <Guest71639>  ./join #parakeet
11:02:25 <Guest71639>  ./join #parakeetM keptad
11:02:27 <Guest71639>  ./join #parakeet
11:02:29 <Guest71639>  ./join #parakeet
11:02:32 <Guest71639> My keyboard
11:02:34 <Guest71639>  ./join #parakeet
11:02:37 <Guest71639>  ./join #parakeet
11:02:38 --- mode: ChanServ set +o shachaf
11:02:39 <Guest71639>  ./join #parakeet
11:02:42 <Guest71639>  ./join #parakeet
11:02:44 <Guest71639>  ./join #parakeet
11:02:46 --- kick: Guest71639 was kicked by shachaf (Guest71639)
11:03:01 <Guest71639> I fixed it
11:03:04 <Guest71639> Thats for ban
11:03:09 <Guest71639> I mean kick
11:03:27 <awal> I think I came at the wrong time :/
11:03:39 <Guest71639> awal: join #parakeet
11:03:46 --- mode: shachaf set +b *!*ubuntu@*.53.148.146.bc.googleusercontent.com
11:03:46 --- kick: Guest71639 was kicked by shachaf (Guest71639)
11:08:30 <saurabhnanda> how to I wrap my head around the type of Control.Lens.^. ?
11:08:35 <saurabhnanda> :t Control.Lens.^.
11:08:36 <lambdabot> parse error on input ‘Control.Lens.^.’
11:08:43 <saurabhnanda> :t ^.
11:08:44 <lambdabot> parse error on input ‘^.’
11:08:47 <puregreen> :t (^.)
11:08:48 <lambdabot> s -> Getting a s a -> a
11:08:55 <saurabhnanda> :t (Control.Lens.^.)
11:08:56 <lambdabot> s -> Getting a s a -> a
11:09:17 <puregreen> Getting a s a = (a -> Const a a) -> s -> Const a s 
11:09:17 <saurabhnanda> puregreen: what does the type sig mean? I'm stuck with composing a lens access
11:09:29 <puregreen> and Const x a is just wrapped x
11:10:12 <puregreen> “Getting a s a” is one of types that a lens can be “downgraded” to
11:10:15 <saurabhnanda> can you tell the type of this expression by just looking at it? (v L.^. (L.key "method"))
11:10:24 <saurabhnanda> where L = Control.Lens
11:10:40 <puregreen> I haven't seen “key” in lens
11:10:56 <puregreen> is it from lens-aeson?
11:11:14 <saurabhnanda> sorry
11:11:19 <saurabhnanda> import qualified Control.Lens as L
11:11:19 <saurabhnanda> import qualified Data.Aeson.Lens as L
11:11:19 <saurabhnanda> yes
11:11:37 <puregreen> it won't work, as Value isn't a Monoid
11:11:44 <puregreen> you need ^?
11:12:19 <saurabhnanda> wut?
11:12:25 <saurabhnanda> :t (^?)
11:12:26 <lambdabot> s -> Getting (First a) s a -> Maybe a
11:12:46 <saurabhnanda> okay I can see that this is returning a Maybe -- and that's what I was expecting
11:12:55 <saurabhnanda> but what does Monoid have to do with this?
11:13:04 <saurabhnanda> and how is one supposed to know!
11:13:20 <puregreen> ^. has rather unintuitive semantics on traversals
11:13:28 <puregreen> it tries to combine traversed values
11:13:35 <puregreen> (and for this they have to be monoids)
11:13:57 <puregreen> sometimes it's useful, but mostly not (at least to me)
11:14:03 <saurabhnanda> "combine" in what sense?
11:14:14 <puregreen> <>
11:14:29 <puregreen> > ["a","b","c"] ^. each
11:14:41 <saurabhnanda> how to read something like -- v L.^? (L.nth 0) . (L.key "gid") -- I wrote it a week ago and can't grok how exactly it works
11:15:29 <sulibese> jo
11:15:29 <puregreen> (it was supposed to return "abc" but lambdabot doesn't want to)
11:16:08 <saurabhnanda> puregreen: right, I tried that on my repl
11:16:09 <saurabhnanda> it returns abc
11:16:13 <puregreen> you can read it as “take 0th element of v, and lookup the "gid" field”
11:16:36 <puregreen> it'll return Nothing if types don't match (string instead of array, etc)
11:16:45 <saurabhnanda> if I had to write it without the (.) composition, how would I do that?
11:17:05 <fizruk> saurabhnanda: it could have been v[0]["gid"] in some other language
11:17:42 * saurabhnanda wonders if Haskell has reader macros to define simpler syntax
11:17:52 <puregreen> L.preview (L.key "gid") =<< L.preview (L.nth 0) v
11:17:55 <puregreen> probably like this
11:18:02 <puregreen> preview is just a synonym for ^?
11:18:44 <fizruk> saurabhnanda: v ^? nth 0 . key "gid"  is fine by me (don't use Lens as qualified and omit redundant parentheses)
11:18:49 <saurabhnanda> puregreen:  why the name "preview"?
11:19:48 <puregreen> ^. is “view”, “pre” adds take-first-element semantics but no idea where the name comes from
11:20:00 <saurabhnanda> puregreen: what about -- v ^? (nth 0) ^? (key "gid")
11:20:25 <puregreen> won't work because it's wrapped in Maybe after the first ^?
11:21:56 <saurabhnanda> why didn't they right ^? to be more like the monadic >>=
11:22:02 <saurabhnanda> *write
11:23:37 <saurabhnanda> puregreen: thanks, this un-sticks me.... for now!
11:29:59 <saurabhnanda> is there a lens for Data.Aeson.Result?
11:30:12 <saurabhnanda> to help one get the Success part of the Result?
11:33:53 <saurabhnanda> found another way probably, asText
11:35:49 <ski> saurabhnanda : no reader macros
11:36:50 <saurabhnanda> are lens-aeson and aeson-lens different packages?! Why?!
11:37:29 <idev> is there anything like datomic for haskell?
11:37:34 <idev> I really like the entitivy/attribute/value store
11:37:58 <puregreen> someone wrote aeson-lens and the author of lens was dissatisfied (because it didn't satisfy some laws) and wrote lens-aeson instead
11:38:29 <puregreen> and Hackage doesn't have a way to mark packages as “unrecommended” against author's will
11:38:46 <saurabhnanda> wow!
11:38:59 <saurabhnanda> it's like window managers for linux
11:40:03 <saurabhnanda> aargh these string types are killing me.  A function called _String returns Text
11:40:09 <saurabhnanda> who came up with this?
11:40:09 <ZelteHonor_> Is it possible for a function that recursively make a list to be changed in such a way that tail recursive optimisation may be enable?
11:40:36 <puregreen> saurabhnanda: String is how it's called in JSON specification, Text is the type that the author of aeson chose to use
11:40:54 <puregreen> similarly, Array is Vector and Number is Scientific
11:41:04 <puregreen> (we don't happen to have a numeric type called Number)
11:41:08 <puregreen> (at least not in wide use)
11:41:30 <puregreen> actually: how did you find lens-aeson? just googled for “lens aeson” or something?
11:41:35 <puregreen> * aeson-lens
11:41:46 <saurabhnanda> what's recommended to use for internal use? [Char] or Text?
11:42:02 <saurabhnanda> puregreen: first hit on google
11:42:10 <saurabhnanda> https://www.google.co.in/search?client=opera&q=data.aeson.lens&sourceid=opera&ie=UTF-8&oe=UTF-8
11:42:20 <cite-reader> Text, unless you're interoperating with something that only takes [Char].
11:50:51 <ZelteHonor_> When you do profiling what does -hr mean? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/prof-heap.html#retainer-prof
11:51:23 <ZelteHonor_> I am trying to understand why my program is taking so much memory. It even fill my memory.
11:51:51 <ZelteHonor_> With the option -hr it's (2)SYSTEM that is fulling my memory.
11:51:55 <ZelteHonor_> What does it mean?
11:52:10 <saurabhnanda> is there a way to accept an argument (in a function), such that the data type is whatever's the data-type of another argument of some other function? eg. writing helper functions which take the same arguments but call a lower-level function.
11:53:04 <ski> ZelteHonor_ : "Is it possible for .." -- yes, and it's not really an optimization. also it's not always desirable
11:53:56 <ski> saurabhnanda : perhaps make a tuple of functions
11:54:01 <geekosaur> saurabhnanda, generally just use the same signature as the thing you're calling (or let ghc infer it)
11:54:23 <ski> saurabhnanda : but often you could just let them be separately polymorphic ..
11:54:30 <saurabhnanda> geekosaur: what about best practice of defining type-sigs of functions
11:54:37 <ZelteHonor_> I am desperetly trying to find out why my program is taking so much memory.
11:55:05 <saurabhnanda> basically I need to accept a string-like argument and I don't care what it is. I'm simply going to pass is to get/post/runClient. It needs to be whatever they want.
11:55:08 <geekosaur> saurabhnanda, sometimes your options there are let ghc infer it or use trickery to force the issue (or extensions such as ScopedTypeVariables)
11:55:26 <geekosaur> it *is* a best practice, just not always possible in some odd cases
11:57:09 <geekosaur> you might provide a concrete example of what you're trying to do, though, as ski and I seem to have different notions of it?
11:57:27 <tzh> saurabhnanda: if you have a specific type in mind, there are a lot of cases where the other function will have a constraint you can mirror. `myFunction :: ToMarkup a => a -> Thing` that calls some library function w/ a type signature like `thing :: ToMarkup a => a -> Bar`
11:58:49 <saurabhnanda> startWebsocketClient :: Text -> Int -> Text -> [(Text, Text -> Result a -> IO ())]-> IO ThreadId 
11:58:59 <saurabhnanda> startWebsocketClient host port path callbacks
11:59:21 <saurabhnanda> so, host & path actually need to be string because they're just being passed to the Websocket library
11:59:36 <saurabhnanda> but I"d like to use whatever's the recommended String/Text type for my own data types
12:00:14 <saurabhnanda> so, a sig like startWebsocketClient :: String -> Int -> String -> [(Text, Text -> Result a -> IO ())]-> IO ThreadId seems weord
12:00:35 <saurabhnanda> can I write: startWebsocketClient :: _hole -> Int -> _hole -> [(Text, Text -> Result a -> IO ())]-> IO ThreadId and let the compiler figure it out based on actual use
12:03:40 <saurabhnanda> any pointers?
12:04:16 <monochrom> I think no for now.
12:05:37 <saurabhnanda> hmm
12:05:38 <saurabhnanda> anyways
12:05:55 <saurabhnanda> are lenses a solution for allowing same field names across different record types?
12:07:16 <jle`> not quite, but they allow a uniform interface of sorts
12:07:28 <paolino> saurabhnanda, the compiler is not casting String to Text, you have to
12:07:46 <jle`> as in, syntactic record accessors don't have special privilege.  lens abstracts over them
12:08:18 <jle`> er, i mean, if you use normal record accessors, they have special syntax stuff.  but using a lens-base approach lets you not use the actual syntactical accessors and instaed use first-class accessors
12:08:28 <jle`> so you can replace them with typeclasses over multiple data types, etc.
12:09:22 <jle`> this wouldn't be too different than just ignoring syntactic accessors and giving your own update/project/create functions manually for users to use, but lens packs them up and makes them a bit easier to work with
12:09:56 <jle`> (so no, not directly, but they make alternatives to syntactic records a bit nicer)
12:11:22 <saurabhn_> jle`: from the tutorial, data Meetup = Meetup { _name :: String, _location :: (Latitude, Longitude) } 
12:11:41 <saurabhn_> jle`: (a) I can have name & location as fields in other records?
12:11:50 <saurabhn_> jle`: (b) how do I create a Meetup object, now?
12:11:54 <Dipper> hi
12:11:55 <saurabhn_> jle`: ....
12:11:57 <Dipper> anyone have lenovo laptop?
12:12:55 <zennist> Is there a function with the same definition of ($) but with lower precedence than (=>>) or (=<<) ?
12:13:21 <jle`> saurabhn_: the alternative method would be to never use _name and _location, but create a typeclass HasName, HasLocation
12:13:45 <jle`> where HasName instances would give you the ability to modify and access "_name" fields
12:13:56 <jle`> (what tutorial are you talking about, btw?)
12:14:31 <jle`> you can create a value of any ADT by using its constructors
12:14:35 <saurabhn_> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
12:14:43 <paolino> saurabhn_, you can think Meetup (on the right) as a function of a String and a (Latitude,Longitude) so Meetup "somewhere" (4141,4141541)
12:14:46 <jle`> for example, for data Maybe a = Just a | Nothing, you can say 'Just 10'
12:14:59 <jle`> and for your meetup, you can say 'Meetup "hello" (123,345)', yea
12:15:06 <jle`> Just and Meetup are constructors
12:16:01 <jle`> similar for something like data Either a b = Left a | Right b, you can make an Either Int Bool with 'Right True'
12:17:04 <saurabhn_> jle`: right, I get that. But can I create a Metup object using the record-style constructor?
12:17:22 <saurabhn_> this doesn't work:
12:17:23 <saurabhn_> data Person = Person { _name :: String, _email :: String }
12:17:29 <saurabhn_> data Employee = Employee { _name :: String, _email :: String}
12:17:34 <saurabhn_> Person{_name="Saurabh", _email="Hey"}
12:17:40 <saurabhn_> gives an error
12:17:48 <jle`> yeah, you can't have duplicate record field names
12:17:53 * hackagebot amazonka-core 1.4.1 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.4.1 (BrendanHay)
12:17:55 * hackagebot amazonka 1.4.1 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.4.1 (BrendanHay)
12:17:57 * hackagebot amazonka-test 1.4.1 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.4.1 (BrendanHay)
12:17:59 * hackagebot amazonka-glacier 1.4.1 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.4.1 (BrendanHay)
12:18:01 * hackagebot amazonka-ecr 1.4.1 - Amazon EC2 Container Registry SDK.  https://hackage.haskell.org/package/amazonka-ecr-1.4.1 (BrendanHay)
12:18:05 <geekosaur> (yet)
12:18:13 <Clint> saurabhn_: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Design
12:18:19 <jle`> but you can create Meetup objects if your data type is properly defined
12:18:42 <saurabhn_> so, which part of this problem do lenses solve?
12:18:51 <saurabhn_> the access problem?
12:19:00 <jle`> instead of using record syntax, use "normal functions"
12:19:09 <jle`> so don't use { _blah :: .. }, etc. 
12:19:18 <jle`> and you can use typeclasses to abstract over different data types
12:19:36 <jle`> so write a HasName typeclass, and make data types that have a 'name' field to be instances
12:19:45 <jle`> lenses make these easier to work with
12:20:14 <jle`> the approach itself doesn't involve lenses, but using lenses makes these 'normal functions'-based accessors and modifiers easier to work with
12:20:19 <saurabhn_> jle`: but when creating a new object with a lot of fields, if one doesn't use the record syntax it gets very cumbersome
12:20:53 <paolino> saurabhn_, Person and Employee are the same, you should factor it out
12:21:03 <jle`> sure
12:21:35 <saurabhn_> paolino: hypothetical example, not real life code
12:21:51 <saurabhn_> okay, let that be... the reason I"m investigating this is completely different.
12:21:58 <paolino> flawed imo
12:22:15 <jle`> yeah, it's not a perfect solution.
12:22:27 <jle`> at the moment there is some TH that exist to make things a bit smoother
12:22:38 <paolino> typeclasses serve other purposes usually
12:22:46 <jle`> in the future though when overloaded record fields and associated lenses are integrated into GHC, things would be much nicer
12:22:50 <saurabhn_> what's a good way to model a bunch of callbacks to a websocket client?
12:23:03 * hackagebot amazonka-cloudhsm 1.4.1 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.4.1 (BrendanHay)
12:23:05 * hackagebot amazonka-dynamodb 1.4.1 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.4.1 (BrendanHay)
12:23:07 * hackagebot amazonka-datapipeline 1.4.1 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.4.1 (BrendanHay)
12:23:09 * hackagebot amazonka-iam 1.4.1 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.4.1 (BrendanHay)
12:23:11 * hackagebot amazonka-kinesis-firehose 1.4.1 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.4.1 (BrendanHay)
12:23:15 <jle`> yeah, i definitely think it's not an ideal solution, and it's def an abuse of typeclasses.
12:23:22 <saurabhn_> approach (a): [(String, String -> IO ())]
12:23:27 <jle`> you're not going to find me arguing for it :)
12:23:53 <paolino> :-) I was sure
12:23:59 <jle`> a bunch of callbacks, why not just [String -> IO ()] ?
12:24:17 <saurabhn_> or approach (b): WebsocketCallbacks{onDownloadStart=..., onDownloadPause=...., onDownloadStop=...., onDownloadcomplete=....}
12:24:44 <jle`> oh, did you mean like Map String (String -> IO ()) ?
12:24:52 <jle`> like a map of names to callbacks associated with the names?
12:25:03 <saurabhn_> [(websocketMethod, websocketMethod -> IO())]
12:25:07 <jle`> oh
12:25:09 <saurabhn_> jle`: yes
12:25:16 <jle`> yeah, don't use lists of tuples as maps :P
12:25:35 <jle`> but the data type version is probably preferred.
12:25:38 <saurabhn_> passing-in the websocketMethod to the function so that the same function can be used for multiple callbacks. Just an optimization.
12:25:57 <saurabhn_> I like the record-type. It's safer
12:25:58 <jle`> i've used data types to store bundles of callbacks like that before
12:25:58 <saurabhn_> BUT
12:26:09 <saurabhn_> it's a never-ending list
12:26:33 <jle`> the record is a list?
12:26:36 <saurabhn_> If I want to define just one callback, I have to type out the entire record.
12:26:45 <sinelaw> In SystemF, are these equivalent?   forall a. t -> (a -> a)   and:   t -> (forall a. a -> a)
12:26:48 <saurabhn_> jle`: the possible callbacks are a lot
12:26:56 <jle`> are not all callbacks always going to be defined?
12:27:19 <puregreen> saurabhn_: if the callbacks can be undefined, you can use Maybe
12:27:28 <puregreen> and then have a “def” record with a bunch of Nothings
12:27:29 <jle`> if they are always going to be defined, and some are just sometimes different, you can use Data.Default's Default and provide a default "normal callbacks" object people can use
12:27:46 <saurabhn_> puregreen: still, one callback and a bunch of Nothing's
12:27:46 <jle`> and then have thempass in def { onDownloadPause = ... } to have the defualt thing, but with onDownloadPause changed
12:28:03 <jle`> or you can just use a Map CallbackType (String -> IO ())
12:28:13 * hackagebot amazonka-route53-domains 1.4.1 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.4.1 (BrendanHay)
12:28:13 <saurabhn_> what's a 'def' ?
12:28:15 * hackagebot amazonka-directconnect 1.4.1 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.4.1 (BrendanHay)
12:28:16 <jle`> data CallbackType = DownloadStart | DownloadPause | DownloadComplete ...
12:28:17 * hackagebot amazonka-sqs 1.4.1 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.4.1 (BrendanHay)
12:28:19 * hackagebot amazonka-devicefarm 1.4.1 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.4.1 (BrendanHay)
12:28:21 * hackagebot amazonka-cognito-sync 1.4.1 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.4.1 (BrendanHay)
12:28:30 <jle`> saurabhn_: class Default d where def :: d
12:28:36 <johnw> sinelaw: is there any way to distinguish them?  Is a 't' in the context of an 'a' that it doesn't use different from 't' in a context without 'a'?
12:28:48 <jle`> from the 'data-default' library
12:29:13 <jle`> @hackage data-default
12:29:14 <lambdabot> http://hackage.haskell.org/package/data-default
12:29:18 <saurabhn_> jle`: checking it out
12:29:27 <jle`> but, if you are going to mostly have Nothing's, might as well use a Map ?
12:29:36 <jle`> you get O(log n) lookup instead of O(1), but
12:29:50 <saurabhn_> jle`: yes, I like your approach of Map CallbackType (CallbackType -> IO ())
12:30:00 <sinelaw> johnw: t is unrelated to a ('a' would be not be free in 't', I guess)
12:30:09 <jle`> (you probably mean String -> IO)
12:30:11 <jle`> (rigt?)
12:30:21 <saurabhn_> jle`: why not make even that type-safe
12:30:39 <saurabhn_> jle`: Map CallbackType (CallbackType -> IO ())
12:30:41 <jle`> it depends on what the callback function expects
12:30:54 <jle`> i'm not sure why a callback functino would expect a callback type
12:30:57 <saurabhn_> jle`: how do I define a Map? is there special sugar for it?
12:31:09 <jle`> Map CallbackType (CallbackInput -> IO ())
12:31:21 <jle`> you can use 'fromList'
12:31:25 <saurabhn_> same function to be used for 3 callbacks with a minor difference, easily implemented as a case statement within the function
12:31:50 <jle`> there's some syntactic sugar that lets you type [(k,v),(k',v')] and have it interpreted as fromList [(k,v),(k',v')]
12:32:11 <jle`> sure, you know more about what your callbacks are going to be taking than me
12:32:24 <jle`> but i assumed that the type of callbacks and the thing that your callbacks accept would be different
12:32:36 <jle`> if they have the same type in your case, then go ahead
12:33:19 <saurabhn_> let me try the Map approach
12:33:23 * hackagebot amazonka-elb 1.4.1 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.4.1 (BrendanHay)
12:33:25 * hackagebot amazonka-marketplace-metering 1.4.1 - Amazon Marketplace Metering SDK.  https://hackage.haskell.org/package/amazonka-marketplace-metering-1.4.1 (BrendanHay)
12:33:25 <saurabhn_> now, next question. Which Map should I be using?!
12:33:27 * hackagebot amazonka-cloudformation 1.4.1 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.4.1 (BrendanHay)
12:33:29 * hackagebot amazonka-sts 1.4.1 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.4.1 (BrendanHay)
12:33:31 * hackagebot amazonka-autoscaling 1.4.1 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.4.1 (BrendanHay)
12:33:34 <jle`> probably just Data.Map.Strict's Map
12:33:43 <saurabhn_> it's the same story as Text/String/ByteString
12:34:07 <paolino> saurabhn_, do you need to move the map around ?
12:34:16 <jle`> i don't think it makes a big difference which map type you use for most use cases
12:34:41 <jle`> it's not really a fundamentally-different-use-case deal, like with Text/String/ByteString, which all represent completely different things
12:34:47 <jle`> and are completely different ADT's
12:34:54 <jle`> as different as Int and Bool
12:35:15 <jle`> strict Map and lazy Map are different by only implementation details i think
12:35:18 <shachaf> String represents the same thing as Text.
12:35:25 <saurabhn_> paolino: "move" ?
12:35:27 --- mode: shachaf set -o shachaf
12:35:33 <paolino> as argument
12:35:33 <sinelaw> johnw: Equivalence should probably mean inhabited by same System F terms, and I think they are. Can we arbitrarily switch Λα.λx.λ(y:α).y into λx.Λα.λ(y:α).y
12:35:35 <sinelaw> no?
12:35:40 <geekosaur> strict and lazy map are the same structure. it's the functions that differ
12:35:40 <shachaf> The only difference is that String can include some invalid code points.
12:36:06 <sinelaw> λx:t, of course
12:36:10 <saurabhn_> paolino: yes, it'll be passed once, at most
12:36:21 <geekosaur> which means you can intermix strict and lazy map functions on the same map, if you need to for some reason
12:36:48 <jle`> ah that's nice to know :)
12:37:09 <sinelaw> If we can, then ∀a.t -> (a -> a) is equivalent to t -> (∀a.a -> a)
12:38:26 <saurabhn_> jle`: problem with Map approach. the function arguments are different to each callback. At least I'd like them to be. Else I'll have to wrap them in some typeclass.
12:38:33 * hackagebot amazonka-certificatemanager 1.4.1 - Amazon Certificate Manager SDK.  https://hackage.haskell.org/package/amazonka-certificatemanager-1.4.1 (BrendanHay)
12:38:35 * hackagebot amazonka-kinesis 1.4.1 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.4.1 (BrendanHay)
12:38:37 * hackagebot amazonka-kms 1.4.1 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.4.1 (BrendanHay)
12:38:39 * hackagebot amazonka-cloudsearch-domains 1.4.1 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.4.1 (BrendanHay)
12:38:41 * hackagebot amazonka-cloudwatch 1.4.1 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.4.1 (BrendanHay)
12:39:39 <paolino> saurabhn_, are you sure it's not enough to pass a function (CallbackValue -> IO ()) ?
12:39:51 <saurabhn_> jle`: actually can't even do that. Because that would mean that every callback should be able to to take all instances of the typeclass
12:40:05 <saurabhn_> paolino: what will CallbackValue be?
12:41:08 <paolino> String iirc
12:41:35 <saurabhn_> jle`: what about a typeclass which implements all callback functions -- each function does nothing. You create your own instance of the typeclass and override the callbacks that you're interested in?
12:41:52 <saurabhn_> paolino: want to be as type-safe as possible
12:42:33 <paolino> you are not meking it type safe by putting functions in a record
12:42:36 <saurabhn_> is here a python equivalent of 'pass' in haskell?
12:43:02 <saurabhn_> paolino: how? can't I specify the function's type-sig in the constructor?
12:43:41 <sm> saurabhn_: return () in an IO block is the nearest thing
12:43:43 * hackagebot amazonka-iot-dataplane 1.4.1 - Amazon IoT Data Plane SDK.  https://hackage.haskell.org/package/amazonka-iot-dataplane-1.4.1 (BrendanHay)
12:43:45 * hackagebot amazonka-cloudtrail 1.4.1 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.4.1 (BrendanHay)
12:43:47 * hackagebot amazonka-elasticache 1.4.1 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.4.1 (BrendanHay)
12:43:49 * hackagebot amazonka-elasticsearch 1.4.1 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.4.1 (BrendanHay)
12:43:51 * hackagebot amazonka-waf 1.4.1 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.4.1 (BrendanHay)
12:48:24 <Lovepon> saurabhn_: pass?
12:48:34 <saurabhn_> Lovepon: do nothing.
12:48:47 <Lovepon> saurabhn_: Monadically? return ()
12:48:53 * hackagebot amazonka-importexport 1.4.1 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.4.1 (BrendanHay)
12:48:55 * hackagebot amazonka-s3 1.4.1 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.4.1 (BrendanHay)
12:48:57 * hackagebot amazonka-swf 1.4.1 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.4.1 (BrendanHay)
12:48:59 * hackagebot amazonka-sdb 1.4.1 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.4.1 (BrendanHay)
12:49:01 * hackagebot amazonka-ec2 1.4.1 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.4.1 (BrendanHay)
12:49:09 <sinelaw> lovely
12:50:43 <adelbertc> what is the easiest way to get a sandboxed install of a haskell executable/binary (thats on hackage)? i used to be able to just do cabal sandbox init; cabal install <foo> and thena dding the directory to my PATH. trying to switch to stack and am having trouble figuring out what the stack equivalent is
12:51:48 --- mode: ChanServ set +o dolio
12:51:50 <Lovepon> adelbertc: I may be wrong here, but stack is by default sandboxed.
12:51:52 <Lovepon> Or something like that.
12:51:56 --- mode: dolio set +q hackagebot!*@*
12:52:26 <sinelaw> adelbertc: if all you want is an executable, and if the package is on stackage, then just: stack install foo
12:52:35 <adelbertc> Lovepon: surely i need some sort of 'init' command in a folder to tell it where to sandbox?
12:52:53 <adelbertc> oh i guess itll just create a local folder in ~/.stack or something specific to foo ?
12:53:41 <geekosaur> everything is implicitly sandboxed; you only need an explicit sandbox for a specific project you are developing
12:53:54 <adelbertc> ah sweet
12:54:16 <adelbertc> hm when i try it i get Recommended action: try adding the following to your extra-deps in <omitted>/.stack/global-project/stack.yaml
12:54:16 <adelbertc> - machines-binary-0.3.0.2
12:54:16 <adelbertc> - msgpack-1.0.0
12:54:29 <geekosaur> if you tell stack to install something, it creates a hidden sandbox for that install based on its dependencies, installs programs to ~/.local/bin or libraries into its library cache, then removes the temporary sandbox
12:54:42 <sinelaw> adelbertc: those packages are not on stackage in the LTS version you have, probably
12:55:08 <sinelaw> it's suggesting to tell it to explicitly include them in the set of packages allowed
12:57:17 <mgsloan> geekosaur: Well, sorta.  That is how it will work on HEAD in a week from now :)
12:57:40 <paolino> saurabhn_,, there are amazing things like DMap , but Map a b is not making any distinction at the type between keys or values (between callbacks, in your case)
12:57:43 <adelbertc> hmmm so i added those to stack.yaml in global (which seems a bit sketchy now.. ?) and it complains about more and more things incrementally... a lot of machines-0.6 stuff
12:57:44 <mgsloan> When you run "stack install" outside of a project, it just uses the global project as a default
12:58:55 <mgsloan> adelbertc: What I usually do is just check out the source repo for something I want to install
12:59:17 <mgsloan> and then I do "stack init" inside there if they don't have a stack.yaml, maybe "stack init --solver"
13:00:30 <mgsloan> However, I realize that isn't that great if you just want to install software.  If you don't want to temporarily put extra-deps in your global stack.yaml (nothing wrong with that, really), you can create a new folder and stick a stack.yaml in it that says "resolver: lts-5.13" and "packages: []"
13:00:45 <dolio> Did everyone still see that hackagebot stuff?
13:00:47 <mgsloan> Then with that config you can install whatever and add extra-deps and stuff
13:01:10 <puregreen> dolio: after you +q'd it, no
13:01:16 <dolio> Okay.
13:01:31 <saurabhn_> how to allow this type-hackery: http://lpaste.net/162732
13:01:42 <adelbertc> mgsloan: so the project does have a stack.yaml
13:01:55 <mgsloan> I agree that "stack install" that refers to hackage packages should do a better job of UX for missing deps - that's tracked by https://github.com/commercialhaskell/stack/issues/2039
13:02:20 <mgsloan> adelbertc: Cool so you should be good to go!  Just run "stack install" inside the project
13:02:35 <sm> dolio: is there a problem with hackagebot ?
13:02:49 <dolio> Someone just published ~70 packages.
13:03:13 <mauke> that's as many as 7 tens
13:03:25 <Lovepon> mauke: Or 10 sevens...
13:03:29 <Lovepon> Dang
13:03:34 <mauke> bzzt
13:03:48 <mauke> the correct answer would have been: "and that's terrible"
13:05:24 <sm> they'll be reported in batches of five, over ~70 minutes 
13:05:32 <paolino> is it human to publish 7 tens of packages ?
13:11:28 <jle`> sm: amazonka project has a bunch of packages that they generate programatically
13:11:55 <adelbertc> mgsloan: sweet that worked!
13:12:11 <adelbertc> it seems to have installed to ~/.local/bin - is there a corresponding stack command to remove if i decide i dont want those anymore?
13:12:16 <adelbertc> or do i have to remove manually
13:12:27 <geekosaur> the latter
13:12:47 <sm> there's no uninstall command. It's a rule. :)
13:13:01 <geekosaur> haskell's package system doesn't really support tracking programs, so neither cabal sandboxes nor stack can help you with uninstalling programs.
13:13:16 <maerwald> geekosaur: I can uninstall dependencies just fine in cabal sandboxes
13:13:21 <geekosaur> (it's not really a "package system" so much as a "library manager" that's been coerced into doing unnatural acts)
13:13:30 <adelbertc> got it
13:13:38 <adelbertc> is there a way to do a local stack install
13:13:43 <adelbertc> that doesnt copy anything to .local/bin ?
13:13:54 <adelbertc> that just keeps the executables in the local folder
13:13:56 <sm> stack build
13:14:11 <sm> then stack exec -- PROG ...
13:14:46 <jle`> ^^ is automated with the stack-run utility
13:14:53 <sm> aha
13:14:55 <jle`> stack run -- PROG ...
13:15:41 <jle`> i wonder why stack-run isn't built into stack
13:15:59 <geekosaur> maerwald, I was talking about programs. libraries, there's enough info to uninstall. programs, if they have data files the only way you're going to track those is strace-ing the install...
13:16:39 <maerwald> yeah, both cabal and stack are broken
13:16:48 <geekosaur> (or something similar to debian fakeroot or macports trace mode)
13:17:19 <sm> I bet cabal and/or stack would accept patches to track executables better
13:18:25 <geekosaur> the real problem is the Cabal library knows about libraries, not executables. and currently executable installation is ad hoc as a result (hence need for strace or similar). you need new APIs at that level to track that information, and then every package that installs an executable has to be rewritten from ad hoc to using the APIs
13:18:33 <mgsloan> jle`: I don't think there's any reason to not build stack-run into stack, I was actually fairly surprised to see that project instead of a PR
13:18:56 <jle`> c'est le vie
13:18:58 <mgsloan> buut I do also want to keep stack's scope to just the things that really make sense to be in the main tool
13:19:21 * jle` hopes nobody notices he doesn't actually know how to spell anything in french
13:19:43 <jle`> mgsloan: fair enough
13:20:02 <jle`> but stack run feels like a better fit than that new documentation builder+opener, at least
13:20:17 <jle`> not that the latter isn't useful
13:20:24 <sm> it sure is, thank you
13:20:27 <mgsloan> the "stack haddock --open" option?
13:20:34 <jle`> yea
13:20:57 <sm> I've been needing that since my first haddock comment
13:21:07 <mgsloan> jle`: Yeah, I want to change the CLI for that https://github.com/commercialhaskell/stack/issues/2025
13:21:49 <jle`> nice :)
13:22:38 <mgsloan> On one hand, it'd be nice to keep stack as maintainable as possible.  On the other hand, it is tempting to make it into an awesome swiss army knife
13:22:49 <mgsloan> (well awesomer swiss army knife)
13:23:06 <jle`> yeah, i guess you'll only get in trouble if you play the "if X is in it, why not Y?" game
13:23:30 <mgsloan> Yup, but I think "stack run" is well within the boundaries of reasonable scope creep
13:23:57 <mgsloan> (being just a shortened version of a common workflow)
13:24:50 <mgsloan> I'd also kinda like to make the interpreter a little more first class, like you could have "stack run" (build and run), and also "stack run --interpret" (load into ghci and run), or "stack run --interpret --file-watch" (something like ghcid, heh)
13:25:30 <mgsloan> Such a unification would be pretty but not sure if it's worth the effort, got bigger fish to fry :)
13:35:24 <raek> @djinn [a] -> Maybe a
13:35:24 <lambdabot> Error: Undefined type []
13:35:44 <raek> Why can't I use [] with djinn?
13:36:05 <shachaf> Because it wouldn't be useful.
13:36:17 <shachaf> Even Maybe is dubious.
13:36:46 <dolio> Lists are more problematic than Maybe.
13:37:06 <adelbertc> im guessing for whatever reason if i need to wipe stack cache i can just nuke ~/.stack ?
13:37:50 <raek> which function can be inferred from the type in general? those only using universally quantified type variables and (->)?
13:38:52 <jle`> raek: djinn has problems with recursive data types
13:39:03 <dolio> djinn is based on a decision procedure for the propositional calculus.
13:39:26 <dolio> Maybe a is 'true + a', but there is no analogue of lists.
13:39:36 <dolio> Er, 'true \/ a'.
13:40:21 <raek> got it. thanks!
13:40:44 --- mode: dolio set -q hackagebot!*@*
13:40:48 --- mode: dolio set -o dolio
13:41:17 <mgsloan> adelbertc: Yeah, although you might want to skip .stack/config.yml if you put anything in there
13:41:25 <mgsloan> global project too
13:42:11 <mgsloan> You usually shouldn't have to remove ~/.stack/.  I haven't needed to in months, and I've even ben doing stuff like messing around with stack's internal cache formats
13:42:58 * hackagebot smtLib 1.0.8 - A library for working with the SMTLIB format.  https://hackage.haskell.org/package/smtLib-1.0.8 (IavorDiatchki)
13:43:39 <adelbertc> mgsloan: cool thanks
13:43:44 <adelbertc> mgsloan: yeah i just nuked it out of paranoia
13:44:33 <adelbertc> stack solver is quite neat
13:50:57 <jle`> raek: it can handle Maybe tho
13:51:42 <jle`> @djinn a -> Maybe a -> a
13:51:42 <lambdabot> f a b =
13:51:42 <lambdabot>     case b of
13:51:42 <lambdabot>     Nothing -> a
13:51:42 <lambdabot>     Just c -> c
13:56:30 <adelbertc> what does djinn do with unsafe stuff
13:56:33 <adelbertc> @djinn Maybe a -> a
13:56:33 <lambdabot> -- f cannot be realized.
13:56:36 <adelbertc> :P
13:56:47 <EvanR> jle`: hmm. but thats not the unique solution
13:57:06 <jle`> EvanR: djinn stil gives solutions that aren't unique
13:57:11 <jle`> @djinn a -> a -> a
13:57:11 <lambdabot> f _ a = a
13:57:19 <jle`> vs. f a _ = a
13:57:29 <EvanR> i was about to post that as an example of how polymorphic type sigs can generate useful code
13:57:35 <EvanR> but... 
13:59:47 <EvanR> hmm can you predict the number of solutions of A -> (B -> C) from the number for A -> and B -> C
13:59:55 <EvanR> hrm
14:03:12 <aarvar> EvanR: (C ^ B) ^ A ?
14:03:40 <EvanR> normally, but i was thinking about polymorphic stuff like a -> Maybe a -> a
14:03:53 <aarvar> ah
14:06:21 <benzrf> is haskell not fully dependent at the kind level yet :\
14:07:19 <EvanR> TypeInType maybe
14:07:50 <puregreen> could anyone run http://lpaste.net/raw/7530970401845805056 (a revision link, so malicious edits on lpaste are impossible) on their machine and send me the results and your physical location? I'm testing different Hackage mirrors and I want to determine which is the fastest one for different countries
14:10:03 <puregreen> actually no, malicious edits are still possible, sorry (so look at it before running it)
14:12:52 <adelbertc> mgsloan: cool everything is working now
14:12:57 <adelbertc> thanks for your help everyone!
14:12:59 * hackagebot multiset-comb 0.2.4.1 - Combinatorial algorithms over multisets  https://hackage.haskell.org/package/multiset-comb-0.2.4.1 (BrentYorgey)
14:13:01 * hackagebot first-class-patterns 0.3.2.3 - First class patterns and pattern matching, using type families  https://hackage.haskell.org/package/first-class-patterns-0.3.2.3 (BrentYorgey)
14:23:01 <whittle> I’m writing an HTTP API server that relies on another HTTP API server that is provded by a third party. I’m looking for suggestions about how to test. In particular, how do I mock/stub the third-party HTTP responses in my integration tests? 
14:24:37 <bergmark> whittle: servant might be a good choice
14:25:26 <scshunt> or you can make a very small component to do the actual calls to third-party servers that you test less/not at all
14:30:59 <whittle> bergmark: Using servant, I would stand up a fake server on localhost and point my API calls at that? 
14:32:00 <whittle> scshunt: I’m trying to isolate the API client code, but I still feel like I should be running some smoke tests on it. 
14:32:34 <bergmark> whittle: right, that's how we test our api
14:32:52 <scshunt> whittle: you should be able to isolate the client code from the code actually making the HTTP requests
14:33:00 * hackagebot cryptohash-md5 0.11.7.1 - Fast, pure and practical MD5 implementation  https://hackage.haskell.org/package/cryptohash-md5-0.11.7.1 (HerbertValerioRiedel)
14:33:24 <whittle> bergmark: I don’t suppose that code is public? 
14:33:54 <whittle> scshunt: Are you aware of any good examples of this? 
14:34:51 <scshunt> whittle: Not aware of any offhand, but presumably you are using an HTTP library to send requests?
14:35:11 <bergmark> whittle: no, sorry
14:35:49 <bergmark> we would have open sourced it but I wasn't really able to make it general purpose enough...
14:37:41 <whittle> scshunt: I’m using the http-conduit family of libraries. 
14:38:00 * hackagebot BlogLiterately 0.8.2.3 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.2.3 (BrentYorgey)
14:39:02 <whittle> bergmark: Well, nerts. Thanks for the servant idea. 
15:03:24 <everyonemines> I'm trying to decide on a compilation target for a toy language....
15:03:31 <everyonemines> is StgSyn appropriate as a compilation target?
15:18:03 * hackagebot htoml 1.0.0.0 - Parser for TOML files  https://hackage.haskell.org/package/htoml-1.0.0.0 (cies)
15:43:04 * hackagebot th-utilities 0.1.0.1 - Collection of useful functions for use with Template Haskell  https://hackage.haskell.org/package/th-utilities-0.1.0.1 (MichaelSloan)
15:43:26 <Lovepon> Lol. https://www.reddit.com/r/ProgrammerHumor/comments/4igxd3/difference_between_python_and_haskell/
15:48:04 * hackagebot hpath 0.6.0 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.6.0 (maerwald)
15:56:25 <Gurkenglas_> How do I make \mathtt text bold?
15:58:05 * hackagebot htoml 1.0.0.1 - Parser for TOML files  https://hackage.haskell.org/package/htoml-1.0.0.1 (cies)
16:00:14 <bollu> I *hate* setting up travis with GHC
16:01:11 <puregreen> bollu: why? multi-travis-ghc works well
16:01:59 <bollu> puregreen: I'm trying to set up CI for SymEngine.hs
16:02:03 <scshunt> whittle: right, ok. So at some point you'll have a conduit in your pipeline that actually makes the HTTP calls. Stub that.
16:02:05 <bollu> https://travis-ci.org/symengine/symengine.hs/builds/128942078
16:02:18 <bollu> every build is failing because of weird reasons
16:02:24 <bollu> it's not able to find tasty-quickcheck
16:02:27 <scshunt> whittle: you can test the rest of the stack, even integrated together, and then test the HTTP calls indepedently
16:03:04 <bollu> plus, it keeps saying that its not able to download the cache
16:03:14 <bollu> I would love to understand what the hell is happening
16:03:44 <puregreen> “could not download cache” probably means that there were no successful caches in the past
16:03:50 <puregreen> so it's alright
16:04:33 <bollu> and why is cabal not able to find tasty-quickcheck
16:04:36 <bollu> ?
16:05:39 <bollu> https://travis-ci.org/symengine/symengine.hs/jobs/128942085
16:05:46 <bollu> ^ it's not able to find a compiler version (stack)
16:05:53 <puregreen> cabal update wasn't done for some reason
16:05:59 <bollu> hmm
16:06:57 <puregreen> interesting 
16:06:58 <puregreen> https://travis-ci.org/symengine/symengine.hs/jobs/128942082#L377
16:07:09 <puregreen> here it jumps straight to cabal install
16:07:37 <puregreen> but in the script you have “cabal --version” before
16:07:37 <puregreen> https://github.com/symengine/symengine.hs/blob/master/.travis.yml#L197
16:14:12 <bollu> ohh
16:14:13 <bollu> hm
16:14:19 <bollu> puregreen: any idea what the hell is happening?
16:14:44 <Bor0> Anyone interested in reviewing a small math proof?
16:16:05 <puregreen> bollu: I'm not good at bash so my only idea is “maybe you could put semicolons after lines”
16:16:22 <bollu> puregreen: thanks I'll try this out
16:17:27 <puregreen> Bor0: what area of math?
16:17:47 <Bor0> Relations and partial orders specifically
16:18:00 <puregreen> then not me
16:18:24 <bollu> Bor0: sure
16:18:36 <bollu> Bor0: I'm not a professional mathematician
16:18:42 <bollu> Bor0: but I'd be happy to take a look
16:18:51 <amnn> Bor0, what's the proposition?
16:18:57 <Bor0> I am not an expert myself..going through "How to prove it" and I had an idea about alternative (more intuitive) definition of an element being R smallest
16:19:13 <Bor0> But not sure if my reasoning is correct
16:19:13 <bollu> puregreen: https://travis-ci.org/symengine/symengine.hs/jobs/128995734
16:19:18 <bollu> puregreen: it's compiling!
16:19:33 <bollu> puregreen: oh, hm. Now it's not able to fiind the library
16:19:36 <Bor0> Http://www.texpaste.com/n/lqacz9t0/raw
16:20:03 <Bor0> On that link is the proposition and a proof attempt
16:21:47 <Bor0> To me the other definition is more intuitive because I was able to come with it given a programming background. Of course the first one is more elegant but I am just curious if they are equivalent
16:22:00 <glguy> Bor0 bollu amnn, that looks like it's off-topic for #haskell, so you might take it to another channel together
16:22:33 <Bor0> I know I know, sorry. Tried math but always finding the right persons here :)
16:27:14 <amnn> Bor0, I pm'ed you, but I might as well tell you here, that your proof is sound
16:28:06 * hackagebot webcloud 0.1.0.1 - Turn an optparse-applicative program into a CGI program!  https://hackage.haskell.org/package/webcloud-0.1.0.1 (ThomasSutton)
16:28:25 <puregreen> bollu: to be honest, no idea this time
16:30:59 <Bor0> Thanks amnn!
16:33:06 * hackagebot either 4.4.1.1 - An either monad transformer  https://hackage.haskell.org/package/either-4.4.1.1 (EdwardKmett)
17:08:07 * hackagebot libravatar 0.4 - Use Libravatar, the decentralized avatar delivery service  https://hackage.haskell.org/package/libravatar-0.4 (akrasner)
17:40:06 <whittle> scshunt: Thank you. I’m still figuring out how best to structure things.
17:57:32 <roconnor> does cabal by default make with -O2?
18:07:15 <jmcarthur> roconnor: I think it builds with -O by default.
18:07:17 <nh2> hvr: if you have some time: https://github.com/hvr/cassava/pull/115
18:13:06 <ddhouse> I [heart] haskell
18:13:17 <koz_> ddhouse: Me too.
18:13:30 <lifter> Sooo awesome.
18:13:39 <ddhouse> koz_: I am creating a hosting control panel using haskell
18:13:45 <ddhouse> Want to help
18:13:47 <ddhouse> ??
18:13:54 <lifter> :r
18:14:13 <ddhouse> lifter: Do you want to help?
18:14:16 <koz_> ddhouse: Sorry, I have enough of my own work thanks.
18:14:23 <ddhouse> ok
18:14:35 <lifter> ddhouse: Too much on my plate as it is... :(
18:14:48 <ddhouse> oh k
18:15:05 <ddhouse> Anyone know what a haskell mixed with a mac is?
18:15:45 <dredozubov> maskell?
18:15:50 <ddhouse> no
18:15:51 <roconnor> jmcarthur: I see
18:15:58 <ddhouse> haskellmac
18:16:05 <roconnor> is the optimization flag passed to cabal configure or cabal build?
18:16:43 <ddhouse> Anyone good at creating logos
18:16:45 <ddhouse> ??
18:23:50 <ddhouse> ./clear
18:24:02 <ddhouse> Can someone help me create a logo?
18:24:15 <peddie> ddhouse: remember that this channel is for discussing the haskell programming language
18:24:28 <ddhouse> Oh where can I ask questions about logos
18:24:43 <montanonic> ddhouse: #haskell-blah
18:24:45 <peddie> I'm not sure, actually
18:25:34 <ddhouse> Oh where can I ask questions about logos, its for a haskell project
18:26:38 <Clint> ...
18:29:08 <sm> ddhouse: #web might know
18:29:21 <sm> they're arty
18:53:52 <ddhouse> Anyone want to join the WebParakeet project, its for hosting, https://github.com/WebParakeet, just pm my username.
18:57:50 <Axman6> what is it?
19:00:31 <EvanR> can we define a type of finite sequences which doesnt require the whole thing to be generated strictly
19:00:37 <EvanR> or eagerly
19:00:43 <jmcarthur> ddhouse: I've noticed that a lot of things you are saying seem off topic. I recommend taking it to some place other than #haskell. For example, we have #haskell-blah, where you can talk about anything but haskell.
19:01:08 <ddhouse> I cant join it
19:01:13 <jmcarthur> Why not?
19:01:25 <jmcarthur> Also, that doesn't mean you can be off topic here.
19:01:32 <montanonic> jmcarthur: TLS-only channel
19:01:37 <EvanR> as in data FinList a = Empty | Cons a !(FinList a)
19:01:38 <jmcarthur> Ah.
19:02:10 <EvanR> equip TLS or go to #haskell-offtopic
19:02:16 <ddhouse> 9:01:51 PM  #haskell-blah :Cannot send to channel.
19:02:18 <deiwos> i've just started using parsec. is there a way to match any series of non-whitespace characters except for a few reserved characters, but while still allowing words that contain that character? for example, i want the parser to accept a;b but not ; by itself. the best i have so far is satisfy (\chr -> chr /= ';'), but that rejects too many things.
19:02:19 <jmcarthur> EvanR: Any finite length or a *specific* length?
19:02:23 <EvanR> jmcarthur: any
19:03:34 <jmcarthur> EvanR: Can it be that the length must be known once you have evaluated the head? Or must it be possible for it to have a length that is only known once you reach the end?
19:04:58 <EvanR> neither must is a must
19:05:36 <EvanR> im just thinking of a list that cant be infinite basically
19:05:37 <scshunt> EvanR: newtype Neither a b ?
19:06:52 <EvanR> since a thunk can do anything, i guess this has to involve some type hacks
19:07:19 <jmcarthur> I can't think of anything other than a totality checker.
19:07:26 <jmcarthur> s/totality/termination/
19:07:50 <EvanR> yeah i guess this is equivalent to having a totality checker
19:08:51 <exio4> working with length-indexed lists while keeping the length polymorphic should do the trick 
19:09:03 <exio4> (maybe adding some existential types to hide the length)
19:09:29 <EvanR> basically Vect
19:09:53 <EvanR> and just be really flexible with what the length is
19:10:20 <EvanR> whats the simplest way / package for that
19:10:51 <EvanR> and does that really stop infinite lists in haskell?
19:11:13 <jmcarthur> I think exio4 is right that it will prevent infinite lists, but it's going to be annoying to use.
19:11:32 <EvanR> truly
19:13:30 <scshunt> you'd need to make the length strict though
19:15:49 <EvanR> length strict?
19:16:06 <EvanR> what is strict at the type level
19:17:18 <exio4> what I had in mind doesn't stop infinite lists 
19:23:24 <idev> is there a channel here dedicated to m36 ?
19:24:01 <zRecursive> EvanR: Maybe: class Foo !a !b where ... ?
19:24:45 <EvanR> huh
19:25:47 <zRecursive> off topic, Is there any VPN channel ?
19:27:34 <EvanR> trying to understand the amb operator, and now i get it by analogy to list monad. then i got into implementation of amb in schema, its amazing how much simpler lazy evaluation makes things
19:28:16 <EvanR> scheme*
19:42:30 <Tertain> Is there a way to pattern match against a typeclass that is a subclass of another typeclass? Something like "| (_ :: Foo a => a) = <code>". I have a typeclass that "extends" Exception, and wanted to write a function that accepts SomeException and takes different operations depending on if its an 'Exception', or a 'MyExceptionTypeclass'. 
19:43:24 <EvanR> Tertain: check out the function catches
19:43:33 <EvanR> https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:catches
19:43:57 <EvanR> which may make the SomeException unnecessary
19:45:55 <Tertain> Okay thanks, I'll check it out.
20:04:45 <ski> shachaf : `Maybe' isn't dubious ..
20:04:45 <ski> benzrf : "is haskell not fully dependent at the kind level yet :\" -- not dependent
20:05:17 <shachaf> ski: It's dubious when people try to infer a particular Haskell function using Maybe.
20:05:50 <shachaf> Haskell isn't dependent at all and has never been dependent. It's been getting a more expressive type system. I don't know why people say it's dependent.
20:06:31 <ski> presumably because they don't really understand what a dependent system is about
20:11:28 <dmtd> Hi all, fairly new to haskell. How can I make it so that I call one function in a program, and that function calls all other helper functions automatically? Similar to a java "main" method of sorts
20:13:45 <ski> make the function call all other helper function (not automatically) (just as in Java)
20:30:42 <dfeuer> UGH. Conceptually, I want something like  data Foo a = Foo !Bool !a, but for some reason (pointer tagging?) it seems that data Foo = FooFalse !a | FooTrue !a ends up being significantly faster. Is there some less blecherous way?
20:33:15 * hackagebot th-orphans 0.13.1 - Orphan instances for TH datatypes  https://hackage.haskell.org/package/th-orphans-0.13.1 (MichaelSloan)
20:38:22 <jle`> dfeuer: use the second one and use pattern synonyms
20:38:24 <jle`> hehe
20:39:00 <dfeuer> jle`, pattern synonyms don't play well with incomplete match warnings :-(
20:39:19 <jle`> yea :/
20:39:28 <jle`> i wonder if that's a fundamental problem
20:39:35 <jle`> is that being worked on for GHC?
20:39:40 <dfeuer> I can't help wondering if I'm somehow doing something wrong with my flag.
20:39:59 <dfeuer> Joachim Breitner has proposed a hack around the problem using a pragma much like the MINIMAL one for class methods.
20:40:32 <dfeuer> Allowing someone who defines pattern synonyms to declare complete sets. But I don't know if anyone's worked out all the details.
20:43:21 <jle`> can it not be partially inferred from the definition itself?
20:43:54 <jle`> in some cases
20:44:21 <dfeuer> jle`, in some cases, sure. In particular, if multiple pattern synonyms match on the same "view", then it *should* in many cases be able to figure that out. But it doesn't.
20:45:41 <dfeuer> That doesn't, however, cover all cases. For instance, in Data.Sequence, there are viewl and viewr. Each of those is sure to split off a piece of sequence as long as the sequence is non-empty, but the pattern checker isn't likely able to figure that out.
20:46:22 <dfeuer> That is,    Empty +  x :<| xs   or  Empty + xs :|> x  should be considered complete.
20:47:03 <jle`> hm
20:47:16 <idev> GeneralizedNewtypeDeriving <-- so all this does is "if the inner thingy implements class C, then the outer thingy auto implements class C" ?
20:47:17 <jle`> yeah, in cases like that it'd be unfeasible
20:47:38 <jle`> idev: yeah, that's the basic implementation philosophy
20:47:52 <idev> jle`: got it, thanks
20:48:24 <jle`> having a MINIMAL-like pragma would be ncie
20:50:08 <ski> dfeuer,jle` : being able to declare exhaustive, as well as disjoint, sets is needed, yes, at least for the abstract data type case
20:50:38 <ski> (dfeuer : i'm wondering if maybe the difference you're seeing is related to continuations ..)
20:50:49 <jle`> yeah, it'd be important to prevent implementations from leaking for proper ADT support in haskell
20:51:05 <jle`> (ADT as in abstract data type)
20:51:24 <dfeuer> ski, eh?
20:51:27 <ski> hm, i think pattern synonyms are automatically injective ?
20:51:52 <ski> dfeuer : maybe the continuation can get unpacked in the latter case. not sure
20:51:57 <dfeuer> ski, only simply bidirectional ones. Not manually constructed ones.
20:52:24 <ski> ok, then injectivity would be another property one'd like to be able to declare
20:52:37 <ski> (in the worst case, promise)
20:53:08 <ski> (which should then entail the module having to be `Trustworthy')
20:53:16 * hackagebot th-reify-many 0.1.5.2 - Recurseively reify template haskell datatype info  https://hackage.haskell.org/package/th-reify-many-0.1.5.2 (MichaelSloan)
20:54:54 <dfeuer> ski, Trustworthy status is only required if GHC optimizes based on those promises.
20:55:16 <Zemyla> Why is mkStableName an IO function?
20:55:16 <ski> ok
20:55:23 <ski> dfeuer : but how would you know ?
20:55:41 <Zemyla> Will anything go wrong if I use unsafePerformIO on it?
20:55:43 <ski> Zemyla : allocates a new name, i think, distinct from all others
20:55:49 <dfeuer> ski, and I'd want a separate, per-promise pragma decreeing that GHC is allowed to do so.
20:56:12 <ski> Zemyla : is there an `Eq (StableName a)' instance, with no requirement for `Eq a' ? -- if so, that's your answer
20:56:38 <ski> dfeuer : what's the point of a promise that the implementation isn't allowed to use ?
20:57:10 <dfeuer> That is, I'd want to have a {-# TrustMeComplete #-} on it, or whatever, and then that group of pattern synonyms will be trusted by the optimizer and the module no longer inferred Safe.
20:57:29 <ski> jle`,dfeuer : what if one was able to declare something like `pattern data Seq a = Empty | a <| Seq a' ?
20:57:35 <Zemyla> Also, I really wish that Haskell had a language subset with termination proofs.
20:57:56 <dfeuer> ski, there are two ways to "use" the information. The proposal is to use it to reduce inappropriate compiler *warnings*. Using it in the optimizer would be a whole 'nother matter.
20:57:59 <jle`> ski: hm, that'd be nice
20:58:16 <ski> Zemyla : yes, being able to state termination properties, and the implementation saying which of them it was able to prove, would be nice. Mercury has something like that
20:59:27 <dfeuer> For the warning feature, there's no need for Trustworthy. Using it in the optimizer would necessitate that sort of thing. I think for Data.Sequence, the optimizer is almost certainly able to figure that bit out for itself.
20:59:31 <Zemyla> Because I kind of want to be able to tell the compiler "This is a calculation that is pure, terminating, and total. I want you to calculate it at compile-time."
20:59:46 <ski> dfeuer : well, ok. but i'm not sure i'd think it'd be legitimate to use it to reduce the warnings, unless it actually was injective .. and in that case, why not allow optimizations as well, if the implementation sees fit to do so ?
21:00:31 <ski> iow, what's a usecase for not having to declare it as `Trustworthy', in the "only use it to reduce warnings" case ?
21:01:05 <ski> Zemyla : well, the "calculate it at compile-time." bit doesn't follow from the other parts :)
21:01:26 <dfeuer> ski, the idea is that library authors writing pattern synonyms will be careful about it. Safe Haskell is about what can break the type system or allow IO in "pure" computations; it's not about totality at all.
21:01:54 <ski> ("allow IO in \"pure\" computations" can also break the type system)
21:02:18 <ski> "will be careful about it" -- careful about what ?
21:02:21 <dfeuer> ski, yes, *can*. It depends what sort of IO. `trace` can't break the type system.
21:02:37 <dfeuer> About making sure the claims are valid!
21:02:46 <ski> it is possible to implement `unsafeCoerce :: a -> b', in terms of `unsafePerformIO :: IO a -> a'
21:03:02 <dfeuer> Yes, but it is not possible to implement unsafeCoerce in terms of trace.
21:03:09 <Zemyla> ski: Well, it's more "I can prove that this top-level binding is pure, terminating, and total, so evaluating it at compile-time should give the same result as calculating it at run-time".
21:03:16 <dfeuer> So trace is unsafe but does not break the type system.
21:03:26 * ski nods
21:03:44 <dfeuer> At least I *hope* trace is considered unsafe... Let me check.
21:04:24 <dfeuer> Yes, Debug.Trace explicitly decrees {-# LANGUAGE Unsafe #-}
21:04:25 * ski goes away for a little bit
21:05:13 <Zemyla> But yeah, I want to use mkStableName in pure code to detect recursive bindings and such.
21:17:59 <ski> Zemyla : i just checked the `Eq' instance, and it's as i assumed
21:18:34 <ski> Zemyla : so it can't be just `makeStableName :: a -> StableName a'
21:21:28 <Zemyla> Well, suppose I have ListSt a = Nil | Cons a (StableName (ListSt a)) (ListSt a), and I use a smart constructor cons a l = unsafePerformIO $ do { sn <- mkStableName l; return (Cons a sn l) }
21:22:18 <ski> Zemyla : then that's unsafe
21:22:54 <Zemyla> ski: Why so?
21:22:55 <ski> (and i don't mean that in the sense "it's implemented using `unsafePerformIO'" (the name is unfortunate))
21:23:10 <ski> Zemyla : because it allocates a new identity for the stable name
21:23:54 <ski> if `cons' is not inlined, then `cons a l == cons a l' will be `False'
21:24:03 <ski> if it's inlined, then it'll sometimes be `True'
21:25:26 <Zemyla> Well, okay, let me describe my real use-case. Are you familiar with the Church-encoded free applicative?
21:25:27 <ski> note `instance Eq (StableName a)', without a dependency on `Eq a'
21:25:58 <ski> so a `StableName a' includes a unique identity (perhaps an `Integer' or something)
21:26:12 <ski> this is btw similar to the `instance Eq (IORef a)' case
21:26:57 <ski> Zemyla : i don't recall having looked at it
21:27:13 <ski> anyway, you said "I want to use mkStableName in pure code to detect recursive bindings and such"
21:27:27 <ski> which is a usecase i'm familiar with
21:29:54 <ski> Zemyla : do you have `forall o. (forall a. a -> o a) -> (forall a b. o (a -> b) -> o a -> o b) -> o a' or what ?
21:30:06 <Zemyla> Well, I want to use it for labeling the nodes in an applicative, context-free parser, because those often have mutually recursive definitions.
21:30:14 * ski nods
21:31:44 <Zemyla> ski: forall p u y z. (forall b v. f b -> p v -> p (b, v)) -> (forall x. (x -> y) -> p x -> z) -> (u -> a -> y) -> p u -> z.
21:32:36 <Zemyla> Though to make it a free alternative, I'd be adding (forall v w. p v -> p w -> p (Either v w)) as an argument.
21:36:11 <Zemyla> And when I call the two sides of the Alternative, I'm feeding them both the same tail.
21:36:33 <ski> currently i'm pondering the `u -> a -> y' and `p u' parts (the others i think i understand)
21:37:09 <Zemyla> Read http://www.eyrie.org/~zednenem/2013/05/27/freeapp and https://www.eyrie.org/~zednenem/2013/06/freeapp-2 .
21:37:11 <ski> the `forall x. (x -> y) -> p x -> z' part corresponds to a `CoYoneda', in order to make it a functor
21:37:34 <ski> and `forall b v. f b -> p v -> p (b, v)' is a combination of `pure' and `(<*>)'
21:37:53 <Zemyla> ski: It's basically like liftA2 (,).
21:38:00 <ski> yes
21:38:30 <ski> well, i suppose actually more like `lift' (or what you call it), and `(<*>)'
21:39:44 <ski> "tail" ?
21:49:19 <Zemyla> ski: So what I want to do is assemble a free applicative using StablenNames to identify mutually recursive definitions.
21:50:00 <montanonic> Can I use guard syntax, | x == b = ..., with a lambda function somehow?
21:50:31 <montanonic> As far as I can tell, MultiWayIf is the only way to achieve that, which, I guess, is fine
21:50:39 <montanonic> just wondering if there's a more native way though
21:51:36 <Zemyla> LambdaCase?
21:58:26 <saurabhnanda> hey, I'm trying to build an abstract like, like in Java. Does anyone have any ideas about how to make this work? http://lpaste.net/162732
21:58:29 <montanonic> Zemyla: LambdaCase is just syntactic sugar for avoiding a redundant variable; (\x -> case x of ...), becomes  (\case ->
21:58:49 <montanonic> MultiWayIf is what I was looking for though. There doesn't appear to be anything like it.
21:59:16 <EvanR> saurabhnanda: i would replace that class with a record of functions
21:59:17 <montanonic> err, rather, it's exactly what I was looking for anyways, just with an 'if' added
21:59:48 <EvanR> saurabhnanda: your default implementation there is then just a default record with those values
21:59:49 <saurabhnanda> EvanR: had a long discussion with jle about this yesterday. record of functions is my fallback approach. 
22:00:12 <EvanR> it really is a more flexible way, im using it for drivers in mikmod
22:00:29 <saurabhnanda> EvanR: a micro-optimization I'm trying to do here is the following -- if the number of callbacks is very large, the record gets unwieldy. 
22:00:31 <EvanR> this should be more well known "OOP in haskell" idiom
22:00:39 <saurabhnanda> EvanR: I had 35 possible callbacks, but I want to define only 2
22:00:49 <saurabhnanda> EvanR: how many Nothing's will I need in the record constructor!
22:01:08 <ski> Zemyla : i think you'd have to be very careful to ensure that people can't detect the identity in `StableName's .. in the worst case, make the program `undefined'
22:01:12 <EvanR> if you can group the callbacks somehow then a nested record might make sense
22:01:27 <HallaSurvivor> hey, I'm getting started with GLUT. does anybody know how to get the size of your window?
22:01:30 <EvanR> none the less, you can also abstract the default construction full of Nothings away
22:01:39 <saurabhnanda> EvanR: how? 
22:01:45 <EvanR> with functional programming
22:01:58 <saurabhnanda> EvanR: also, any idea about how to make this approach work? Isn't this what Phantom-types are supposed to be
22:02:02 <EvanR> defaultDriver = MkDriver Nothing Nothing Nothing Nothing...
22:02:12 <montanonic> saurabhnanda: you need {-# LANGUAGE DefaultSignatures #-}  to have default implementations
22:02:20 <saurabhnanda> EvanR: got it. That's what I currently use -- thought there was something better
22:02:36 <EvanR> coolDriver = defaultDriver {f1 = notNothing, f2 = alsoNotNothing}
22:02:45 <montanonic> saurabhnanda: see some of the classes here: http://hackage.haskell.org/package/mono-traversable-0.10.2/docs/src/Data-MonoTraversable.html#MonoFoldable
22:03:21 <ski> saurabhnanda : no `Nothing'
22:03:43 <montanonic> EvanR: the record approach essentially turns what would be a typeclass constraint into an additional argument to pass to the function (being the record type), correct?
22:04:33 <EvanR> montanonic: its a lot easier to create custom drivers than custom versions of an instance
22:04:45 <montanonic> EvanR: I don't understand the term "drivers"
22:04:52 <EvanR> you can use reflection to mess with instances at runtime but...
22:05:30 <EvanR> montanonic: imagine you have an interface like Interface { action1 :: IO (), action2 :: Int -> IO Bool }
22:05:39 <ski> saurabhnanda : anyway, i suppose i should say that i'd also use a record
22:05:40 <montanonic> okay
22:05:46 <EvanR> now any record with this type is a driver
22:05:52 <EvanR> you can have many drivers for this interface
22:06:09 <EvanR> and its easy to make new ones
22:06:13 <EvanR> (from old ones)
22:06:15 * ski drives away with the interface
22:06:40 <saurabhnanda> montanonic: what was MonoTraversable for?
22:06:42 <montanonic> EvanR: ahhh, I see
22:06:55 <montanonic> saurabhnanda: to show you how to write classes with default implementations
22:07:14 <montanonic> saurabhnanda: you were trying to provide defaults, but without an extension, Haskell won't let you
22:07:46 <EvanR> montanonic: unless you do like defaultDriver { action2 = foo }
22:08:01 <montanonic> saurabhnanda: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html
22:09:07 <montanonic> EvanR: right, I'm not trying to steer saurabhnanda away from using record types, just want to clarify how to solve the problem he was trying to solve, even if they probably shouldn't solve it that way
22:10:29 <montanonic> EvanR: yeah, the record method certainly seems more extensible. thanks for elaborating
22:11:10 <EvanR> id say the type classes are the fallback, the fallback for when you need to do "type level computation" at runtime
22:11:41 <saurabhnanda> montanonic: which type-class extension should I be looking at?
22:11:59 <EvanR> which is more unwieldy, so records are nicer when you dont have to use type classes
22:12:55 <montanonic> saurabhnanda: DefaultSignatures
22:13:57 <saurabhnanda> hmmm, I don't completely understand how I can use that to complete my type-class approach.
22:14:55 <saurabhnanda> I thought it was for the record approach. To help in writing Mkdefault kind of functions
22:15:01 <HallaSurvivor> does anybody know how to get the windowsize for a display function?
22:15:07 <HallaSurvivor> in GLUT
22:16:06 <EvanR> saurabhnanda: you can type Nothing 35 times pretty easily in many editors ;)
22:16:17 <EvanR> else there is template haskell
22:16:33 <EvanR> but that seems like a weird interface
22:16:34 * ski isn't sure why saurabhnanda wants to use `Maybe' in the first place ..
22:16:45 <saurabhnanda> EvanR: well, think of it as a puzzle for me to solve, right now.
22:16:56 <EvanR> XY problem = ... Y problem?
22:17:02 <EvanR> i hate those ;)
22:17:07 <ski> (the type class didn't mention any `Maybe')
22:17:28 <EvanR> if Nothing is supposed to mean "default" then this isnt right
22:17:48 <saurabhnanda> ski: right. Till now I've ended up using Maybes for such records with large fields. Didn't realize that I could have a constructor that provides default values instead of Nothing's
22:18:50 * ski idly wonders whether `Unfoldable' could help
22:20:21 <EvanR> o_O
22:21:45 <EvanR> how?
22:23:40 <ski> i'm not sure. that's why i wonder
22:27:41 <saurabhnanda> the documentation of DefaultSignatures in the standard Haskell documentation is very tough. Why are they talking about Generics, suddenly?
22:29:03 <ski> saurabhnanda : it's an example which motivated adding the `DefaultSignatures' extension, iirc
22:29:55 <saurabhnanda> ski: "You can lift this restriction and give another type to the default method using the flag -XDefaultSignatures." Why would one want to do that?
22:30:06 <saurabhnanda> ski: default method having a different signature from non-default one
22:30:27 <ski> better to say "more restricted" than "different" (or "another")
22:31:17 <saurabhnanda> I'm getting confused. The DefaultSignature is a way to solve my type-classes approach or does it allow giving default values to a constructor?
22:33:28 <saurabhnanda> https://wiki.haskell.org/Default_values_in_records
22:34:06 <montanonic> saurabhnanda: yes, that is a better way of approaching the problem you're trying to solve
22:34:18 <ski> saurabhnanda : i'm not sure what you're trying to solve in your "type-classes approach"
22:35:47 <saurabhnanda> ski: basically hack-together what is an "abstract class" in Java
22:35:52 <sinelaw> Hey, what do you call the property of lifting foralls out of right-hand-side of -> ? Either in System F's type system or in predicate logic with second-order quantifiers, couldn't find a name for this property
22:36:20 <saurabhnanda> ski: right now, records is probably the way to go, but I'm just playing code-golf now.
22:36:48 <ski> sinelaw : "property" ? of what ?
22:37:04 <sinelaw> forall a. s -> t   <=>  s -> forall a. t    where 'a' is not free in s
22:37:16 <sinelaw> ski: that's true, right? :)
22:37:23 <ski> sinelaw : is this a property of the system, or of `t' or what ?
22:37:39 <sinelaw> ski: given any s, t where a is not free in s
22:38:03 <ski> yes. but you said "property". i'm wondering what the domain of this property is
22:38:20 <sinelaw> property of the type system
22:38:38 <sinelaw> or am I being unclear?
22:38:47 <ski> well, at least to me
22:39:04 <ski> (but then i perhaps often have a too literal interpretation of what people say)
22:39:37 <sinelaw> My claim is that given any s, t and a such that 'a' is not free in s, the following equivalence holds: forall a. s -> t   <=>  s -> forall a. t    
22:39:49 <sinelaw> where I guess equivalence could mean "inhabited by same values"
22:40:02 <ski> i'm not sure if the property has any standard name. it'd be a part of what's required for prenex normal form, though
22:40:16 <montanonic> saurabhnanda: consult stuff written by Michael Snoyman if you want to see more OOP-styled implementations. Libraries like mono-traversable or yesod
22:40:24 <montanonic> saurabhnanda: also, this www.yesodweb.com/blog/2016/03/why-i-prefer-typeclass-based-libraries
22:40:25 <EvanR> saurabhnanda: DefaultSignatures was suggested in response to your typeclass example, but i dont know how it applies. it has nothing to do with records
22:40:42 <sinelaw> ski: how would one "prove" it?
22:41:11 <saurabhnanda> montanonic: EvanR ski thanks for the help... I'll stop the code-golf now and get hacking
22:41:39 <EvanR> saurabhnanda: abstract class... this is the old style of doing interfaces, which corresponds to the record type (or object type in oop)
22:42:04 <ski> sinelaw : in System F, it's clearly not inhabited by the same values
22:42:07 <sinelaw> ski: Using curry-howard etc. the equivalent is true in logic, forall a. P => Q   is true whenever   P => (forall a. Q)
22:42:29 <sinelaw> 'a' not being in P (however you say that in logic)
22:42:30 <ski> sinelaw : yes, i wasn't distinguishing between types and logical formulae here, anyway
22:42:32 <sinelaw> ski: it isn't?
22:42:44 <sinelaw> counterexample?
22:44:06 <ski> sinelaw : clearly `/\ a. \ () :: (). Nothing a :: Maybe a' is distinct from `\ () :: (). /\ a. Nothing a :: Maybe a'
22:44:23 <ski> `s' being `()' and `t' being `Maybe a'
22:45:22 <sinelaw> ski: oh I see
22:45:35 <sinelaw> ski: you mean flipping /\ and lambda?
22:45:38 <ski> sinelaw : however, the two types are of course isomorphic
22:45:51 <sinelaw> one could claim those two terms are 'isomorphic' as well
22:46:16 <ski> (terms can't be isomorphic. they can be related by a particular isomorphism, however)
22:46:41 <sinelaw> which leads to my other question...do people usually talk about equivalence of such terms in System F?
22:46:48 <sinelaw> in this sense
22:47:07 <ski> i'm not sure which term is usually employed
22:47:16 <ski> but surely people talk about this topic
22:47:24 <sinelaw> TAPL doesn't seem to mention any of this
22:47:32 <sinelaw> And it seems pretty basic
22:48:14 <ski> TaPL is more focused on practically applying type systems, than on studying type theory, i think
22:48:41 <sinelaw> ski: ok
22:48:56 <sinelaw> when implementing type checking one needs to take these things into account in unification etc.
22:49:24 <ski> normally unification wouldn't unify types that are isomorphic, but not identical
22:49:40 <sinelaw> Isn't that wrong?
22:49:42 <ski> but some allowances are made, i agree
22:49:57 <ski> sinelaw : well, in case there's multiple isomrphisms, which one will you use ?
22:50:13 <ski> the behaviour of the resulting program may depend on which isomorphism you use
22:50:21 <sinelaw> In a basic System F type checker
22:50:53 <sinelaw> ski: are there other commonly used isomorphisms?
22:51:10 <ski> e.g., when unifying `a * a * b' with `a * b * a', do you use the translation between `(x0,x1,y)' and `(x0,y,x1)' ? or the one between `(x0,x1,y)' and `(x1,y,x0)' ?
22:52:03 <sinelaw> hm
22:52:11 <ski> (let's assume that either `*' is left-associative, or that this is a ternary product (like in the MLs), for specificity)
22:53:32 <ski> the non-uniqueness of isomorphisms is one of the obstacles to simply just treating isomorphism as equality, in the naive way
22:54:08 <sinelaw> It does seem like that equivalence is more fundamental
22:54:24 <ski> i think you can probably prove, with parametricity, that there's a unique isomorphism between `forall a. (... -> ..a..)' and `... -> (forall a. ..a..)'
22:54:55 <ski> well .. a unique isomorphism, that is *natural* in yadda yadda
22:54:57 <ski> something like that
22:55:21 * ski ponders
22:55:47 <ski> let's say `forall a. t -> f a', for concreteness
22:56:49 <ski> the question is whether there's a unique isomorphism between `forall a. t -> f a' and `t -> (forall a. f a)', that's natural in `t' and `f'
22:57:41 <sinelaw> what's the definition of natural
22:57:53 <ski> natural transformation, category theory
22:58:14 <ski> consider `foo :: forall a. F a -> G a', where `F' and `G' are functors
22:58:28 <shachaf> ski: What sort of category is this?
22:58:29 <ski> the naturality condition is :
22:58:30 <ski> @free foo :: forall a. F a -> G a
22:58:30 <lambdabot> $map_G f . foo = foo . $map_F f
22:58:48 <ski> where `$map_F' and `$map_G' are both `fmap'
22:59:20 <ski> shachaf : i'm not quite sure, atm :)
23:00:15 <shachaf> I think you'd have to answer that sort of question before talking about naturality.
23:00:27 <shachaf> Does forall make some sort of end?
23:00:31 <sinelaw> got to go...thanks ski :)
23:01:39 <ski> i'd agree that you'd have to answer that question to make sure that talking about naturality makes any sense
23:01:59 <ski> (but i don't agree with having to answer that before being allowed to talk about naturality)
23:02:46 <shachaf> Fair enough.
23:02:46 <ski> (this is a bit similar to reasoning backwards in proofs. or "inwards-out")
23:03:58 <ski> anyway, the vague intuition that made me bring up natuality at all here is :
23:04:11 <ski> we can say that there's an iso between `a * b' and `b * a'
23:04:18 <ski> but a unique one ?
23:04:23 <ski> depends on what `a' and `b' is
23:04:48 <ski> however, there's a unique natural iso between `a * b' and `b * a' (natural in `a' and `b')
23:05:35 <ski> so, i was thinking we could possibly handle this sort of situation in `forall a. t -> f a' vs. `t -> forall a. f a', also using naturality
23:05:42 <ski> that was the motivation
23:05:53 <ski> shachaf : makes any sense to you ?
23:06:49 <shachaf> Why are those not the same? Are you talking about a dependently-typed language?
23:06:54 <ski> (for concreteness, in the former case, you can take a symmetric monoidal category, such as any category with binary products)
23:07:30 <ski> (well, binary and nullary)
23:08:05 <ski> shachaf : well, perhaps it's not required in this case
23:08:13 * ski isn't sure
23:08:32 <shachaf> Well, even if it was it wouldn't matter.
23:09:10 <ski> "Are you talking about a dependently-typed language?" -- i was assuming at least System F
23:13:28 * hackagebot th-reify-many 0.1.6 - Recurseively reify template haskell datatype info  https://hackage.haskell.org/package/th-reify-many-0.1.6 (MichaelSloan)
23:36:24 <wikideer> Hi 
23:36:42 <wikideer> Does anyone know how to represent this in math notation? http://rextester.com/YYX86704
23:38:50 <ent> what do you mean by math notation?
23:39:41 <liste> wikideer: f(s,t,c) = { s, when t=c; f(s*4,t+1,c) otherwise ?
23:39:48 <liste> with a big-ass {
23:39:58 <pyrtsa> 4^5
23:40:25 <wikideer> If I were to represent that haskell as a maths equation in latex how would I do that
23:41:23 <ent> http://www.johndcook.com/blog/2009/09/14/latex-multi-part-definitions/
23:41:29 <tasslehoff> Trying to fix some AMP compile errors without knowing haskell. If I fix it like shown in http://stackoverflow.com/questions/31652475/defining-a-new-monad-in-haskell-raises-no-instance-for-applicative, will it work for older Haskell versions as well?
23:42:06 <ent> wikideer: that should help with the big {
23:42:41 <liste> wikideer: http://www.texpaste.com/n/lnh2h3ju
23:42:56 <jle`> tasslehoff: should mostly work for that specific error
23:43:03 <jle`> it depends on how old of a version you're talking about of course
23:43:08 <ent> oh, there's a texpaste :o
23:44:00 <tasslehoff> jle`: 7.6.3
23:44:05 <jle`> then yeah, it should be fine
23:44:10 <jle`> for that specific error, at least
23:44:21 <tasslehoff> jle`: cool. part of an ubuntu 14.04 to 16.04 upgrade :)
23:44:29 <jle`> :D
