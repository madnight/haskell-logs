00:07:39 * hackagebot hw-json 0.0.0.2 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.0.0.2 (haskellworks)
00:07:39 * hackagebot hw-succinct 0.0.0.14 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.14 (haskellworks)
00:14:52 <bollu> ski: ping
00:15:21 <bollu> I was hoping someone could clarify something about adjunctions that's been bugging me
00:16:05 <bollu> let's consider a pair of functors F, G. F is left-adjoint to G. G :: Topology -> Set, G((X, T)) = X. Now, what should F be such that it is a left adjoint to G?
00:16:22 <bollu> where (X, T) is the topology with X being the base set and T being the topology over X
00:16:56 <bollu> I'm actually trying to understand what Kan extensions are
00:18:27 <bollu> Cale, ReinH, ski: any help with understanding adjunctions, please?
00:22:44 <cocreature> bollu: without thinking too deep about it, I would say that F assigns to a set X the discrete topology
00:23:01 <shachaf> Yes, it's the discrete space.
00:23:49 <shachaf> Continuous functions : Discrete(X) -> Y are in natural correspondence with functions : X -> G(Y)
00:23:59 <shachaf> Since every function from a discrete space is continuous
00:24:20 <shachaf> G also has a right adjoint that maps sets to indiscrete spaces, since every function to an indiscrete space is continuous.
00:24:44 <bollu> shachaf: why do we care that "every function must be continuous"? I think I'm missing something here. From what I understand, the F must be "free" that is, when it takes functions from Set -> Topology, it must be continuous
00:24:59 <bollu> however, how do I *know* that continuity is the property I care about?
00:25:15 <bollu> I mean, why not some other property like bounded? 
00:25:24 <shachaf> Because that's the category you're talking about, presumably.
00:25:26 <bollu> I'm not sure how the adjoint definition enforces *what* property must be preserbed
00:25:33 <bollu> preserved*
00:25:35 <shachaf> You said G : Topology -> Set.
00:25:39 <bollu> yes, correct
00:25:48 <shachaf> The category of topological spaces people usually talk about has continuous functions as morphisms.
00:26:06 <shachaf> If you're talking about a different category then adjoints will be different, of course.
00:26:10 <bollu> shachaf: okay, so, well, therefore the morphisms on Set must __all__ become morphisms of Topology?
00:26:33 <bollu> oh right, it's a functor
00:26:39 <bollu> so stuff must go to legal stuff
00:27:02 <bollu> so if I had, say, G :: Ring -> Set, then the left-adjoint F :: Set -> Ring should take every set function to a ring homomorphism?
00:27:35 <shachaf> Yes.
00:27:53 <bollu> hmm
00:27:58 <bollu> and the right-adjoint to G?
00:28:21 <bollu> since G :: Top -> Set, takes every continuous function to a "function on Set"
00:28:45 <bollu> the right adjoint H :: Set -> Top, how do you know what it should do?
00:28:47 <shachaf> If G : C -> D, both a left and a right adjoint would be : D -> C
00:29:05 <bollu> correct, but what property should H try and preserve?
00:29:08 <bollu> as a functor?
00:29:11 <Cale> bollu: Yeah, the idea is that when F is left adjoint to G, you have that maps FX -> Y in one category are "the same thing as" maps X -> GY in the other category
00:29:20 <shachaf> It's the same property.
00:29:26 <shachaf> I guess I should have stated it explicitly.
00:29:56 <bollu> shachaf: then why do we get the indiscrete topology instead of discrete?
00:30:36 <Cale> Well, every function whose codomain is an indiscrete category is continuous.
00:30:37 <shachaf> If you have categories C, D, and F : D -> C, G : C -> D, F -| G means that C(F(A), B) ~~ D(A, G(B)), naturally in A and B.
00:31:15 <shachaf> What Cale said.
00:31:43 <shachaf> So in this case (I'm going to rename G to U to keep things straight), you have Discrete -| U and U -| Indiscrete
00:31:48 <Cale> So, if X is any topological space at all, and Y is some set, then the continuous maps from X to the indiscrete category on Y are in correspondence with the functions from the underlying set of X to the set Y
00:32:07 <shachaf> Which means that for any space -- well, what Cale just said.
00:32:18 <Cale> oops
00:32:26 <Cale> I said indiscrete category rather than indiscrete space
00:32:32 <shachaf> Or what I assumed he said.
00:32:34 <Cale> haha
00:32:46 <Cale> same thing ;)
00:32:50 <bollu> Cale: how do we prove that functions that go to the indiscrete topology are continuous?
00:33:05 <bollu> sorry, my topology is like swiss cheese :)
00:33:05 <shachaf> That's a topology question more than a category theory question. :-)
00:33:09 <Cale> bollu: Well, what are the open sets of the indiscrete topology?
00:33:20 <bollu> Cale: empty set and the entire topology
00:33:24 <Cale> right
00:33:27 <shachaf> There are only two open sets in the indiscrete space, and their preimages are guaranteed to be open.
00:33:30 <Cale> What will their preimages be?
00:33:35 <bollu> so for a mapping to be continuous, it should map open sets to open sets
00:33:39 <bollu> ohh I see now!
00:33:51 <shachaf> No, that's certainly not what it means for a mapping to be continuous.
00:33:51 <bollu> f^-1({}) = {} 
00:33:57 <shachaf> Yes.
00:33:57 <bollu> inverse image*
00:34:04 <bollu> f^-1(Y) = X
00:34:05 <bollu> neat
00:34:06 <bollu> :)
00:34:19 <bollu> hmm, okay, I think I understand it much better now
00:34:25 <Cale> cool :)
00:34:52 <shachaf> If you think of the topology of a space as telling you what you can observe about it, and of continous functions as functions that don't reveal any unobservable information, it becomes pretty intuitive.
00:35:28 <shachaf> You can't observe anything about an indiscrete space, so every function that maps to it is continuous. And you can observe everything about a discrete space, so every function that maps from it is continous.
00:35:28 <bollu> so, because *every* function from Set(X) -> Set(Y) will remain continuous by applying indiscrete topology to Y, we apply indiscrete topology as the right adjoint? nice
00:35:45 <shachaf> What is "Set(X) -> Set(Y)"?
00:35:56 <bollu> Set(X) -> Y*
00:36:02 <bollu> X was the topological space
00:36:22 <bollu> shachaf: "don't reveal any unobservable information" is a double negative - can you simplify it for me please?
00:37:34 * hackagebot tracetree 0.1.0.0 - Visualize Haskell data structures as edge-labeled trees  https://hackage.haskell.org/package/tracetree-0.1.0.0 (EdskoDeVries)
00:37:51 <shachaf> I guess by Set you mean the underlying functor.
00:38:02 <bollu> yes, I did :)
00:38:07 <bollu> ouch, yes.
00:38:10 <bollu> that was what I meant
00:38:33 <bollu> um, I have to go, but I think I've gotten a *much* clearer picture now :) thanks Cale, shachaf!
00:52:35 * hackagebot soap 0.2.3.0 - SOAP client tools  https://hackage.haskell.org/package/soap-0.2.3.0 (AlexanderBondarenko)
01:22:36 * hackagebot tls 1.3.6 - TLS/SSL protocol native implementation (Server and Client)  https://hackage.haskell.org/package/tls-1.3.6 (VincentHanquez)
01:27:36 * hackagebot tls-debug 0.4.3 - Set of programs for TLS testing and debugging  https://hackage.haskell.org/package/tls-debug-0.4.3 (VincentHanquez)
01:36:40 <Freeme> Serve & Protect
01:48:12 <zRecursi`> @tell dcoutts up to now your patch works well. thanks for your work.
01:48:12 <lambdabot> Consider it noted.
02:07:25 <koz_> If I have [Foo] and a constructor for Foos 'Bar Foo Foo', how can I reduce down the list [Foo] into a single Foo most easily? foldr needs a starting value, and there's no obvious one to begin with.
02:09:28 <bergmark> koz_: can you use Nothing as the starting value?
02:09:44 <jophish> koz_: do you mean reduce down to a single Bar?
02:09:49 <jophish> take a look at foldr1
02:10:09 <jophish> this takes no initial value, but has the restriction that the list must be non-empty
02:10:48 <jophish> sorry, I meant: "koz_: do you mean reduce down to a single Foos?"
02:12:21 <koz_> jophish: foldr1 is exactly what I sought, thanks!
02:13:07 <Iceland_jack> koz_: Where does your list come from? Can it ever be empty?
02:13:09 <jophish> koz_: you're welcome.
02:14:09 <koz_> Iceland_jack: No, it can never be empty, and that's for sure.
02:14:25 <Iceland_jack> Maybe use Data.List.NonEmpty then
02:14:30 <jophish> koz_: This may not be important, but foldr will construct a tree which has depth linear in the number of 'Foo's. If 'Bar' is an associative operation you might want to build a more balanced tree
02:14:45 <Iceland_jack> https://hackage.haskell.org/package/semigroups-0.18.1/docs/Data-List-NonEmpty.html
02:14:54 <koz_> jophish: Bar is associative.
02:16:14 <koz_> Iceland_jack: Is there a numeric type similar to Natural, but that covers {1, 2, 3, ...} instead of {0, 1, 2, 3...} (in set notation)?
02:16:26 <Iceland_jack> Not really
02:16:30 <koz_> Iceland_jack: :(
02:17:13 <Iceland_jack> When you go down that path something like LiquidHaskell is exactly what you'd want
02:17:32 <koz_> Iceland_jack: I see. 
02:18:10 <Iceland_jack>     {-@ type Natural1 = { v:Int | 0 < v } @-}
02:18:44 <Iceland_jack> But that isn't a realistic option at the moment, one day
02:18:48 <Iceland_jack> What is your use case
02:19:18 <koz_> I'm constructing logical expressions using hatt based on randomly-generated truth tables given a number of variables as an argument.
02:19:26 <koz_> Currently, said argument is a Natural.
02:19:40 <koz_> Ideally, it should be a Positive.
02:19:47 <Iceland_jack> I have a feeling you don't actually need this
02:20:00 <koz_> So what, pass an Int?
02:20:18 <Iceland_jack> Yeah probably
02:21:32 <koz_> Regardless of what I pass there, I still need to fold a bunch of expressions into a single Disjunction. Using a fold *does* create a very unbalanced tree however.
02:21:36 <koz_> (I'm using hatt for this purpose)
02:24:17 <Iceland_jack> Have you seen ... by the way
02:24:17 <Iceland_jack> @hackage hatt
02:24:17 <lambdabot> http://hackage.haskell.org/package/hatt
02:25:00 <Iceland_jack> Other than that it sounds like you're focusing on type safety in non-dangerous areas — as it were
02:26:01 <koz_> Iceland_jack: I just said I was using hatt. :P
02:26:32 <Iceland_jack> So that's a yes? ;)
02:27:34 <Iceland_jack> I assumed it was one of those million logical normal forms I hadn't heard of and that the Hackage library was just an implementation, so my bad
02:29:47 <koz_> I'm trying to implement a logical synthesis idea I had, and I'm using hatt to make it less annoying to do.
02:38:20 <OnkelTem> Hi all. What is the optimal workflow when I edit a functions in a file and call them from ghci? I mean, can I somehow elude the need of 'stack build' after every edit?
02:39:57 <paolino> Anyone knows if TH can insert (splice?)  the filename of the source code ?
02:48:02 <Cale> OnkelTem: what happens when you put :r into ghci?
02:48:57 <OnkelTem> Cale: +++
02:49:18 <OnkelTem> I thought I have to explicitly rebuild everything 
02:50:22 <Cale> paolino: fmap loc_filename location ?
02:50:46 <Cale> paolino: I guess you want to insert it as a String literal?
02:51:17 <paolino> possibly in the end to feed $embedFile
02:51:26 <Cale> Oh, I see
02:51:54 <Cale> In that case, you won't need lift
02:52:16 <paolino> I've never used TH so I don't know the power of it. I'mjust guessing
02:53:00 <Cale> (i.e. Language.Haskell.TH.Syntax.lift -- it's a type class method for turning a value (of various types) into a Q Exp to splice in.
02:53:02 <Cale> )
02:53:19 <paolino> I'm writing little snippets of Reflex, and I would like to automate the boilerplate
02:53:35 <Cale> ah
02:53:48 <Cale> Yeah, I like to use fileEmbed for showing things off
02:54:14 <paolino> I feed it with hscolour
02:54:42 <paolino> the other way around
02:55:01 <Cale> el "pre" $ text $(embedStringFile "demo.hs")  or whatever
02:55:18 <Cale> But of course, I know the filename, so I don't have to bother looking it up
02:56:33 <paolino> yep
02:56:46 <paolino> how do I look it up ?
03:17:25 <paolino> Cale I've copied shamelessly from you (the embed idea)
03:27:43 <paolino> Cale: the idea to store the contents in the page to avoid github and such is very useful. ex: http://lambdasistemi.net/public/ghcjs/DynamicList/
03:52:40 * hackagebot declarative 0.2.1 - DIY Markov Chains.  https://hackage.haskell.org/package/declarative-0.2.1 (JaredTobin)
04:13:04 <tpsinnem> hey -- does haskell somehow automatically flush stdout and stderr buffers before the program exits, or does this indeed need to be done explicitly if i want to make sure everything goes to the OS?
04:15:56 <EvanR> you have to flush 
04:17:53 <lyxia> "On program termination, the standard Handles stdout and stderr are flushed automatically" https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Exit.html
04:18:33 <EvanR> oh, thats good
04:18:53 <EvanR> totally thought that was just not happening in ghc
04:20:49 <EvanR> though i wonder if that documentation is specifically talkinga bout exitWith
04:21:01 <Patrol02> Hi all
04:25:50 <Patrol02> I am calling "currentCallStack" and I see the same function mentioned a number of times with ".\\.\\" after the name (from 1 to 5 occurrences of it). What does it mean?
04:26:12 <lyxia> EvanR: Right the docs seem a bit ambiguous to me too. But I would have assumed this behavior. Not flushing means most programs would need one more line to be correct, which sounds excessive.
04:27:34 <lyxia> Patrol02: it refers to anonymous functions within the body of the named function
04:27:38 <EvanR> unless its usually doing it
04:27:48 <EvanR> and no one notices most of the time
04:29:06 <Patrol02> lyxia: ah, thanks! 
04:56:26 <dom___> hello
04:59:00 <ski> hello dom___
04:59:28 <gio111> ski: hi
05:04:14 <freinn> hi! I've completed some exercises about the Foldable typesclass from a book, but now I don't know why some of them can be done "the normal way", using the funcions and provided, and some of them can't. This are which can http://lpaste.net/162604, and this are which can't http://lpaste.net/162601
05:06:31 <dominik> Suppose I have a data definition data T = C1 | C2 | .. | CN
05:06:45 <dominik> and suppose, I want to run the same code for two of the two constructors Ci and Cj
05:06:59 <dominik> is there any way that I can pattern match against these two constructors simultaneously?
05:07:08 <Iceland_jack> dominik: Yes, pattern synonyms
05:07:19 <maerwald> pattern synonyms are evil though
05:07:21 <dominik> so that I don't have to repeat the exact same code for Ci and Cj
05:07:26 <dominik> ?
05:07:30 <Iceland_jack> Pattern synonyms are not evil :)
05:07:53 <ggole> Pull out the common code with where
05:08:02 <maerwald> Iceland_jack: yes, because there is a GHC bug with them where it doesn't know whether pattern matching is exhaustive or not
05:08:09 <cocreature> freinn: not sure what you’re referring to by “the normal way” but you’re foldr implementations are incorrect. you need to use the element of the correct type, otherwise the laws are not fullfilled
05:08:09 <maerwald> and that's a pretty huge deal breaker for me
05:08:16 <ski> freinn : i'm not sure what you mean by "the normal way", but i can tell `2',`3',`4',`5' on the latter link are all wrong
05:08:23 <ski> (freinn : the others are correct)
05:08:32 <Iceland_jack> maerwald: Neither were GHC before this recent reason but that didn't make GADTs evil
05:08:50 <Iceland_jack> Let's *recent release
05:09:10 <maerwald> I don't understand
05:09:38 <ski> dominik : unfortunately, there are no disjunctive patterns in Haskell
05:09:40 <Iceland_jack> dominik: You can use lenses (Prism' T ()) or just use a normal predicate that you use in guards or if_then_else
05:09:57 <Iceland_jack> So there are many ways of accomplishing this but as ski said we don't have patterns like that
05:10:06 <ggole> Why doesn't Haskell have or-patterns? They're very pleasant in ML.
05:10:07 <dominik> hmm, ok.
05:10:33 <ski> ggole : i don't know. i also think they're very nice in OCaml
05:11:08 <Iceland_jack> freinn: Keep in mind that you can use InstanceSigs and actually use valid type signatures (hint: you have to change the type variables for 'Constant a')
05:11:55 <dominik> I think I'll go with factoring out the common bits into a where. Thanks all :-)
05:11:58 <Iceland_jack>     instance Foldable (Constant e) where
05:11:58 <Iceland_jack>       foldr   :: (a -> b -> b) -> b -> Constant e a -> b
05:11:58 <Iceland_jack>       foldMap :: Monoid m => (a -> m) -> Constant e a -> m
05:11:58 <Iceland_jack>  
05:12:12 <Iceland_jack> You enable InstanceSigs by placing {-# LANGUAGE InstanceSigs #-} at the top of your source file or by entering the following into GHCi:
05:12:12 <Iceland_jack>     ghci> :set -XInstanceSigs
05:16:37 <freinn> thanks cocreture ski and Iceland_jack
05:17:16 <ski> freinn : do you see how to fix them ?
05:17:52 <freinn> ski not for now, I have to work on what Iceland_jack said
05:19:04 <Iceland_jack> freinn: (it's not necessary, just if you want machine/compiler-checked types) =)
05:19:32 * ski likes `InstanceSigs'
05:19:37 <Iceland_jack> It helps me when I write type class instances
05:20:04 * ski would also like to be able to write signatures in import and export lists
05:20:10 <Iceland_jack> I use them for everything, especially when they get tricky (multi-parameter type classes, associated types, some weird nested quantification, ...)
05:20:58 <ski> yes, it's a good way to remind yourself of exactly which specialization of the type signature is desirable in the current case
05:21:15 <ski> also helps the reader see the point/use of the specific implementation
05:21:23 <Iceland_jack> I've been trying to push the pragma more
05:21:29 <Iceland_jack> extension
05:21:44 <Iceland_jack> When I started using it I found plenty of bugs
05:24:36 <Iceland_jack> I think most people can easily implement methods as top-level functions but when they are methods with no type signature (or, bad in a different way, they know the general signature 'Functor f => (a -> b) -> (f a -> f b)' and have to mentally substitute Maybe for 'f' or something really difficult like ((->) r) because then you have to worry about using different variables and infix operators etc.
05:24:48 <Iceland_jack> ) let's close that 
05:25:39 <Iceland_jack> Compare that to using InstanceSigs
05:25:39 <Iceland_jack>     instance Functor ((->) r) where
05:25:39 <Iceland_jack>       fmap :: (a -> b) -> ((r -> a) -> (r -> b))
05:25:39 <Iceland_jack>       fmap = ???
05:25:43 <Iceland_jack> a newcomer at least stands a fighting chance here
05:26:03 <Iceland_jack> or 'pure' which becomes downright trivial
05:26:04 <Iceland_jack>     instance Applicative ((->) r) where
05:26:04 <Iceland_jack>       pure :: a -> r -> a
05:26:04 <Iceland_jack>       pure a _ = a
05:26:58 * ski nods
05:27:29 <Iceland_jack> So yeah, someone needs to start a InstanceSigs revolution
05:27:29 <Iceland_jack>     crap, I need to start an InstanceSigs revolution?
05:29:41 <Iceland_jack> I'll go to sleep instead
05:29:58 <ski> yes, sleep on the big decision
05:30:09 <ski> good idea
05:30:27 <Iceland_jack> Don't knock it, the revolution will blow people's socks off
05:40:20 <ertesx> hi there…  ist there an easy way to review the full dependency tree of a package?  a flat list would suffice
05:46:14 <ertesx> perhaps something along the lines of `cabal install --dry-run --reinstall`, but it doesn't show already installed dependencies
05:53:27 <Shou> ertesx: `stack list-dependencies` perhaps?
05:54:50 * ertesx installs stack…
05:55:08 <cocreature> there is also stack dot if you want a graph
05:55:19 <ertesx> a flat list would suffice
05:56:29 <cocreature> then stack list-dependencies is what you’re looking for
05:57:09 <paolino> which is the relation between stack and cabal ?
05:57:40 <ertesx> hmm…  it wants me to stackify the project
05:57:53 <ertesx> isn't there an easier way?  a non-destructive way
05:58:02 <ertesx> after all it's just a query to the cabal package database
05:58:07 <paolino> cabal init ?
05:58:45 <ertesx> paolino: stack adds deployment capabilities
05:59:37 <nitrix> paolino: cabal is the common interface used by both stack and cabal-install (which the executable is awkwardly named cabal for increased confusion).
06:00:19 <paolino> stack is not using cabal install then
06:00:30 <nitrix> Nope.
06:00:57 <paolino> deployment in the sense of binaries ?
06:01:23 <nitrix> paolino: And as far as the packages go; cabal-install uses Hackage, stack uses Stackage but can fallback on Hackage.
06:01:56 <nitrix> Both support local packages, although they seem less painful to setup with stack (many things are less painful).
06:03:09 <ertesx> ok, i'm abusing nix to do it now
06:11:22 <freinn> I summon ski, cocreature and Iceland_jack to see if now my instances are correct: http://lpaste.net/162605
06:12:37 <ski> summons fizzled, Iceland_jack doesn't appear
06:22:18 <ski> freinn : i'd write `Constant e a' instead of `(Constant e) a', ditto for the others
06:22:27 <ski> freinn : otherwise it seems ok
06:22:39 <ski> freinn : the naming in `2' is not consistent
06:23:14 <ski> freinn : in `3',`4',`5', you haven't defined `foldMap'
06:47:46 * hackagebot protolude 0.1.5 - A sensible set of defaults for writing custom Preludes.  https://hackage.haskell.org/package/protolude-0.1.5 (sdiehl)
07:02:46 * hackagebot github-release 0.1.0 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-0.1.0 (fozworth)
07:12:47 * hackagebot github-release 0.1.1 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-0.1.1 (fozworth)
07:17:15 <nitrix> freinn: Not very constructive; but I'll just sneak in the idea that writing comments in spanish is probably suboptimal.
07:19:27 <freinn> nitrix jajajajaja (spanish laught) I'm spanish and from the Canary Islands, so is optimal for me bro!
07:20:33 <nitrix> You're missing the point but I wont eternize on this.
07:20:55 * ski looks at freinn
07:22:47 * hackagebot github-release 0.1.2 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-0.1.2 (fozworth)
07:30:43 <freinn> ski please check it last time, I hope is perfect now: http://lpaste.net/162607
07:36:47 <ski> freinn : it (still) looks ok
07:36:54 <ski> freinn : and you didn't take
07:36:56 <ski> <ski> freinn : i'd write `Constant e a' instead of `(Constant e) a', ditto for the others
07:37:00 <ski> <ski> freinn : the naming in `2' is not consistent
07:37:05 <ski> into account
07:37:38 <ski> also, you introduced some more inconsistent naming in `4',`5'
07:37:54 <freinn> ski can you explain with an example?
07:38:06 <freinn> ski I dont know what you mean by inconsistent
07:38:08 <ski> freinn : and `(f y)' in `4' could be `f y'. similarly for the similar cases
07:38:21 <ski> consider your `2' :
07:38:29 <ski>   foldr f z (Two _ x) = f x z
07:38:33 <ski>   foldMap f (Two _ y) = f y
07:38:44 <ski> why is the element called `x' in one case, but `y' in the other ?
07:39:00 <ski> it's not wrong. but it's slightly confusing
07:39:08 <ski> is there a good reason not to name them the same ?
07:39:14 <freinn> nope
07:39:17 <freinn> I do just for fun
07:39:18 <freinn> xD
07:39:25 <ski> similarly for `4' and `5'
07:39:34 <freinn> okay thanks
07:39:45 <ski> also the bracket issues i mentioned
07:39:47 <freinn> thanks to you now I got the Foldable typeclass better
07:39:54 <freinn> yes, I will correct them
07:39:59 <freinn> thanks you ski
07:40:05 <ski> np
07:48:54 <ggVGc> what do I need to do to make the second version work? https://gist.github.com/0b8fbd397953ecba25ab4b65bb96f5cc
07:54:20 <texasmynsted> So I use neovim + stack + ghci.  I see that "haskell for mac" is on sale today and wonder if I should leap into this.  Who uses this?  I also have intelliJ idea which has Haskell support.  
08:00:25 <nmdanny> how do I split a list in two?
08:01:50 <mauke> nmdanny: problem is underspecified
08:02:08 <texasmynsted> split it in two where?
08:02:35 <texasmynsted> http://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html
08:03:02 <mauke> :t const ([], [])
08:03:03 <lambdabot> b -> ([t], [t1])
08:03:04 <nmdanny> nvm found a solution
08:03:16 <mauke> ok, but have you found the problem?
08:04:12 <nmdanny> split it by length/2
08:04:29 <mauke> is this for mergesort?
08:04:39 <nmdanny> no, im creating a balanced binary tree
08:04:42 <nmdanny> from a list
08:05:26 <lyxia> ggVGc: You're just missing a type signature on differ2 because GHC cannot infer higher ranked types well.
08:07:43 <darkmercenary> does anyone have any experience with ghcjs and/or the react-flux library? im trying to use the jsonAjax function but i keep getting this error
08:07:45 <darkmercenary> # compiler: ghcjs-0.2.0.20160315_ghc-7.10.3 # compiler-check: match-exact # setup-info: #   ghcjs: #     source: #       ghcjs-0.2.0.20160315_ghc-7.10.3: #         url: "https://github.com/nrolland/ghcjs/releases/download/v.0.2.0.20160315/ghcjs-0.2.0.20160315.tar.gz" compiler: ghcjs-0.2.0.20160414_ghc-7.10.3 compiler-check: match-exact setup-info:   ghcjs:     source:       ghcjs-0.2.0.20160414_ghc-7.10.3:         url: https:/
08:07:48 <darkmercenary> oops
08:08:19 <darkmercenary> all.js:25518 Uncaught TypeError: hsreact$ajaxCallback is not a function
08:11:12 <ggVGc> lyxia: yeah but what's the type signature?
08:11:24 <ggVGc> I guess just a Lens' a b?
08:11:34 <nmdanny> question: does quickcheck by default generate lists of arbitrary type?
08:12:02 <lyxia> ggVGc: yeah
08:12:36 <lyxia> Eq b => Lens' a b -> a -> a -> a -> a
08:18:15 <texasmynsted> This seemed to work for half 
08:18:18 * texasmynsted shrug
08:18:19 <texasmynsted> let half xs = Data.List.Split.chunksOf (length xs `div` 2) xs
08:22:19 <lyxia> nmdanny: the instance Arbitrary a => Arbitrary [a] means that "arbitrary" will generate lists of types which are instances of Arbitrary.
08:27:01 <augur> whats a good little library for drawing trees?
08:27:52 <texasmynsted> what do you mean by drawing them?
08:27:59 <texasmynsted> Like graphviz?
08:28:02 <augur> uh.. drawing pictures?
08:28:38 <sm> with graphics or text ?
08:28:47 <augur> graphics...
08:29:14 <augur> i guess diagrams would probably be the best place to start
08:29:42 <s_aly> can you import data types in Haskell from one file to another?
08:29:43 <texasmynsted> http://graphviz.org/Gallery.php
08:29:48 <augur> probably the place I'm most likely to find some functionality for trees
08:30:12 <augur> texasmynsted: we're in #haskell. clearly im asking about a haskell library, not graphviz
08:30:23 <sm> woah, didn't know graphviz could do all that
08:30:50 <texasmynsted> So does this make you feel better?  http://hackage.haskell.org/package/graphviz
08:31:38 <augur> the more you know
08:31:55 <geekosaur> s_aly, import Module (Type(Constructors), ...)
08:32:10 <sm> http://hackage.haskell.org/package/diagrams-contrib-1.3.0/docs/Diagrams-TwoD-Layout-Tree.html also looks useful
08:33:01 <augur> sm: :)
08:33:33 <texasmynsted> One advantage of graphviz is it is widely used, and is somewhat compatible with other tools, the graphs can be converted to other formats, etc.
08:33:54 <sm> diagrams can write graphviz too
08:34:09 <s_aly> geekosaur, if my type were data BinaryTree = E | N Int (BinaryTree) (BinaryTree) deriving (Show,Eq) in module Binary
08:34:13 <s_aly> how would I go about it?
08:34:22 <s_aly> Binary(BinaryTree) ?
08:34:23 <texasmynsted> oh?  Interesting
08:35:14 <geekosaur> if you import Binary (BinaryTree) you have the type but no constructors for it
08:35:34 <geekosaur> import Binary (BinaryTree(..)) imports its data constructors as well (E and N)
08:35:36 <s_aly> so how should I do it?
08:35:43 <s_aly> ah sweet thanks.
08:35:44 <geekosaur> or import Binary (BinaryTree(E, N))
08:35:45 <s_aly> let me try it.
08:35:46 <sm> I think. At least, it can use graphviz for layout - http://hackage.haskell.org/package/diagrams-graphviz
08:37:43 <s_aly> bless you geekosaur. It worked :)
08:38:08 <texasmynsted> It is kind of nice with graphviz that it does not care how you construct, for example, a dot file (or dot input), it can graph it all the same.
08:38:30 <texasmynsted> I have used scala input, XML, manual input, all kinds of things.
08:39:55 <texasmynsted> in any case, it would be interesting to find out what you eventually do
08:48:03 <nmdanny> can somebody help me with quickcheck? I'm trying to test properties about a JoinList (which is like a binary tree with a monoid annotation attached to each node)
08:48:32 <s_aly> how can one fix Couldn't match type `IO String' with `[Char]' ?
08:48:36 <nmdanny> I've implemented an arbitrary instance for a JoinList, and I have some props about JoinList that I want to implement
08:49:05 <nmdanny> however I get the following error when doing quickCheck for those props: No instance for (Show a0)... No instance for (Eq a0)..
08:50:02 <ski> s_aly : shortest answer : use `<-'
08:50:19 <ski> s_aly : for longer answers, please show your code
08:50:20 <ski> @paste
08:50:20 <lambdabot> Haskell pastebin: http://lpaste.net/
08:50:56 <s_aly> ah silly me.
08:51:13 <s_aly> i was changing the code and had getLine instead of my input variable!
08:51:15 <s_aly> Thanks
08:51:43 <ski> nmdanny : perhaps fix that type variable to some concrete type ?
08:51:51 <lyxia> nmdanny: this means that the type of your test cases is ambiguous
08:51:53 <ski> s_aly : also `=<<' in that case
08:52:32 <ski> s_aly : hm, actually `<$>' or `liftM' or `fmap' (all the same thing). not `=<<'
08:52:51 * ski ponders
08:53:00 <s_aly> =<< what does that do? o.O
08:53:03 <ski> (well, could be `=<<' as well)
08:53:16 <ski> s_aly : easiest way to explain is if you'll show your code :)
08:53:49 <nmdanny> Ok, I have fixed my joinlist props to use 'Size' (which is a monoid that I've also implemented arbitrary for)
08:53:57 <nmdanny> but I still get the same error
08:54:38 <lyxia> nmdanny: can you lpaste it?
08:54:41 <nmdanny> https://gist.github.com/nmdanny/8945b8718104a34dc3106e7cdaf5bc79
08:55:03 <teknokrat> hi
08:55:17 <lyxia> nmdanny: quickCheck doesn't work on polymorphic properties
08:55:33 <nmdanny> what do you mean by polymorphic property?
08:55:46 <lyxia> nmdanny: 
08:55:47 <lyxia> prop_jl_eq_list :: (Eq a,Arbitrary a) => [a] -> Bool
08:55:50 <ski> nmdanny : it still doesn't know for which actual type instead of `a' it should check your properties
08:56:07 <lyxia> is polymorphic: there is a type variable in the type.
08:56:27 <nmdanny> I see,
08:56:29 <nmdanny> so I should do something like
08:56:31 <nmdanny> prop_jl_eq_list ::  [String] -> Bool
08:56:34 <nmdanny> prop_listIndex_eq_jlIndex ::   Int -> JoinList Size String -> Bool
08:56:35 <nmdanny> instead?
08:56:54 <ski> nmdanny : either make the properties monomorphic, or add a type ascription to make the use sites monomorphic
08:57:07 <nmdanny> mom-what?
08:57:11 <ski> nmdanny : that would be the first option, yes
08:57:25 <ski> "monomorphic" is the opposite of "polymorphic"
08:57:57 <nmdanny> oh
08:58:03 <nmdanny> so in other words, concrete?
08:58:14 * ski thought there was some module in QuickCheck which helped with checking polymorphic stuff ..
08:58:26 <ski> yes
08:58:58 <sshine> how do I run my executable that stack made for me after I did 'stack init && stackbuild'?
08:59:17 <Clint> ski: you mean like Test.QuickCheck.Poly?
08:59:31 <ski> Clint : yes. i don't recall exactly what it does, though
08:59:31 <lyxia> there is a TH thing that puts Integer in place of type variables
08:59:38 <nmdanny> btw, I see that it is not needed to provide 'Arbitrary' instances for newtype wrappers over arbitrary types
08:59:44 <nmdanny> without even using generalized newtype derivation
09:00:07 <nmdanny> Oh wait nevermind, I'm not really generating those wrappers
09:01:38 <sshine> ahhh, 'stack exec <name-from-.cabal-file>'
09:01:51 * ski looks at s_aly
09:03:36 <s_aly> hey ski. here's what my main looks like. http://lpaste.net/2337732338227609600 it works now though.
09:04:04 <s_aly> i am writing a simple program which will output the latex code for different data structures.
09:04:58 <ski>   main = writeFile "todo.tex" . (startStuff ++) . (++ endStuff) . convertToBinary . output . words =<< getLine
09:05:01 <ski> s_aly ^
09:05:10 <ski> that's how one could use `=<<' here
09:05:38 <s_aly> ah cool.
09:05:53 <sbrg> How can documenters be so.. oblivious? I mean, the esqueleto docs are .. pretty good (for Haskell docs) but the very basic thing is missing.. where do you even put those queries? Familiarity with persistent is just assumed. And even then, copy-pasting examples directly doesn't even work. god -_-
09:07:33 <sbrg> gotta be my biggest gripe with Haskell. Instead of being up and running using a working example immediately, it is way too common that i'm forced to wrangle insane type errors whose meaning i cann't possibly grasp fully because I didn't write the library, etc..
09:10:49 <simpson> sbrg: It could be worse. You could have a strong command of Haskell's type system and *still* be fighting it to get it to understand your goal.
09:12:41 <nmdanny> agreed, haskell docs really gotta have more examples and stuff
09:12:46 <nmdanny> sometimes types aren't enough
09:13:29 <sbrg> simpson: I have been writing Haskell for a few years now, and I would personally like to think that I do have a strong grasp of its type system. While I can obviously understand what of the type isn't fitting, there is often a lot of info missing. We really, really need custom type errors like scala has
09:13:53 * EvanR feels special that lowgl on hackage is basically one huge example (several examples)
09:14:16 <ski> sbrg : type error slicing would also help, imho ..
09:14:18 <EvanR> sbrg: extensive use of typeclasses i think has this effect
09:16:21 <simpson> sbrg: Oh. This is business as usual; becoming proficient with a language necessarily means becoming aware of its limitations and failings.
09:16:55 <nmdanny> you know..I just realized..in languages such as javascript, documentation is mostly about examples, whereas in haskell, its mostly about types..
09:18:06 <sbrg> EvanR: yeah. the worst cases are where there is so much type level magic going on that you need explicit types to get it to typecheck. Sometimes it helps to build the type incrementally using partial type signatures, but sometimes even that doesn't really help
09:18:20 <sm> sbrg: the obliviousness continues because the community is used to it. We need something like http://cpants.cpanauthors.org/kwalitee 
09:18:42 <EvanR> nmdanny: examples are really good in haskell too, its just that examples arent nearly enough even in js
09:19:15 <nmdanny> yes, but in many haskell docs, I look at the library and I don't know where to start
09:19:22 <EvanR> right
09:19:26 <nmdanny> and I have to scour the internet for practical tutorials on using that library
09:19:28 <sbrg> sm: Yep -- I saw that in a reddit thread. that looks really cool. Wiki-ish automatic pull requests to edit documentation would be neat as well.
09:20:24 <sm> I also think doctest needs more promotion, you end up with a whole lot of examples "for free"
09:21:12 <sm> it has matured quite a lot
09:22:11 <EvanR> haddock has really nice support for putting examples in the code!
09:22:27 <EvanR> might as well use it
09:22:53 <EvanR> a lot of complaints are coming from the database-related frameworks
09:27:00 <nmdanny> btw, question, whats the most common/popular way of dealing with relational databases in haskell?
09:27:03 <sm> doctest also gives you line numbers, unlike hunit
09:27:26 * sm is converting all unit tests to doctest
09:27:46 <nmdanny> is persistent+esqueleto a reliable ORM? or do people use raw SQL access?
09:28:48 <sbrg> persistent is pretty neat for simple stuff. esqueleto seems pretty cool as well if you can get it to work. 
09:29:16 <nmdanny> ok, but how about for not so simple stuff?
09:29:49 <sbrg> well, it doesn't seem possible to do joins and such using just persistent. but you can just use esqueleto for the less simple stuff
09:30:01 <nmdanny> for example, if I'm dealing with one-to-many or many-to-many relations,
09:30:15 <nmdanny> I would use persistent+esqueleto in that case, right?
09:30:40 <nmdanny> or, raw sql queries?
09:31:40 <sbrg> I would do anything to not use raw SQL personally. but tbh i'm pretty new at both so I can't really go into much detail about the pros and cons
09:32:49 <EvanR> nmdanny: for simple stuff there is obviously mysql-simple and postgres-simple
09:32:57 <sm> there are low-level, mid-level, and high-level rdbms libs available. They're all pretty good once you've mastered them, and all pretty hard to learn (IMHO)
09:32:58 <EvanR> its not exactly raw SQL
09:34:14 <EvanR> i kind of want a lib like ruby Sequel
09:34:45 <sbrg> nmdanny: I just read in the hackage docs for esqueleto that they are aiming for it being possible to use it for all queries, no exceptions
09:34:47 <EvanR> also i want haskelldb
09:35:37 <cocreature> EvanR: that already exists https://hackage.haskell.org/package/haskelldb
09:36:05 <cocreature> maybe hadb is still free
09:38:37 <nmdanny> anyway, I see that RBDMSs limit you to pretty simple types, how would I go for persisting more complex, native haskell types?
09:39:35 <EvanR> cocreature: i mean, is it ready to use
09:40:02 <cocreature> EvanR: I have no idea, I just searched on hackage because I was sure something of that name exists.
09:42:09 <EvanR> no yeah that was a big project
09:42:24 <zaquest> nmdanny, http://hackage.haskell.org/package/acid-state maybe
09:42:38 <EvanR> no, acid-state is not about relational
09:42:43 <EvanR> or rdbms
09:42:55 <EvanR> its "nosql" ;)
09:43:13 <zaquest> he just wants to persist native haskell types, no?
09:43:35 <EvanR> oh i was still on "interface with relational databases"
09:43:54 <EvanR> nmdanny: serializing complex haskell types is not exactly what relational is about
09:44:03 <EvanR> but acid-state does exactly that
09:44:37 <EvanR> you store exactly one value of 1 type, with the point being acid
09:45:50 <nmdanny> could that value be, a list of values, for example?
09:45:51 <Clint> and you're constrained to ram capacity, which is terrible
09:46:18 <EvanR> nmdanny: yes
09:46:40 <nmdanny> what do you mean constrained to ram? can I not save that data to a file for example?
09:46:41 <EvanR> Clint: yes so its only suitable for datasets that are nowhere near PC ram sizes
09:47:02 <EvanR> nmdanny: you wouldnt use a list though since thats not easily searchable
09:47:08 <EvanR> efficiently*
09:47:23 <EvanR> yes it is saved to disk, that is the D in acid
09:47:41 <nmdanny> ok, but in order to interact with that data, I would have to load it all to the ram?
09:47:47 <EvanR> but it is designed to have all data in memory which is simpler and faster
09:48:09 <EvanR> as long as its not too much for memory
09:48:34 <EvanR> it seems to work for hackage?
09:49:46 <Clint> hackage is a small dataset
09:49:59 <EvanR> the downside of acid state imo is the safe-copy machinery
09:50:33 <EvanR> the idea is right but i dont feel good about using safe copy
09:52:22 <nmdanny> ok dumb question, lets say I want to model the following problem: I have many persons, and many graphs(a graph data type I mean), each person can own many graphs (one to many relation)
09:52:39 <nmdanny> so on the one hand, I have relational data
09:52:51 <nmdanny> on the other hand, I have more complex data that I can't store in a rbdms
09:52:51 * hackagebot github-release 0.1.4 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-0.1.4 (fozworth)
09:53:09 <EvanR> a graph is relational data almost by definition
09:53:39 <EvanR> nodes in the graph are objects, and the connectivity is a relation
09:53:58 <EvanR> an endorelation
09:54:09 <dmj`> EvanR: safecopy is like the best data migration experience I've ever had
09:55:28 <EvanR> relational data modeling is one thing, thinking you can/want to store already-compiled documents in a database is another
09:56:36 * ski . o O ( `E : C(V,2) -> 2' )
09:56:39 <sm> kage
09:56:45 <EvanR> as for the question, many persons, many graphs, and ownership of persons and graphs, this is 3 indexed sets
09:57:06 <nmdanny> i'm not just asking if its possible, i'm asking if its efficient?
09:57:06 <monochrom> ski: what is C(V,2)?
09:57:20 <EvanR> nmdanny: to query?
09:57:22 <monochrom> I assume V is the vertices.
09:57:25 <ski> monochrom : "`V' choose two"
09:57:29 <monochrom> ah
09:57:31 <nmdanny> because looking up graphs in a relational database would surely take a bunch of lookups and indirections, no?
09:57:52 <ski> monochrom : the set of subsets of `V' of size `2' (iow subsets that are isomorphic to `2')
09:57:57 <monochrom> hey, that's more cool than "V^2 -> 2 but make sure it's symmetric"
09:58:05 <ski> yep :)
09:58:12 <ski> also, no self-loops
09:58:15 <EvanR> nmdanny: it would be fast in acid state or in sql
09:58:24 <ski> categorification is fun
09:58:45 <nmdanny> I guess what i'm asking is, if I have data from different paradigms, e.g I have relational data, document data, graph data, etc..
09:58:52 <ski> monochrom : actually i was pleasently surprised when i saw the lecturer used the `C(V,2)' notation
09:59:03 <nmdanny> then, it would be impractical to store all those different data types in a single kind of database, right?
09:59:08 <EvanR> data doesnt have a paradigm
09:59:25 <EvanR> you can store all of that in a single database
09:59:50 <nmdanny> ok, but I don't want just to query, I want to operate on that data from the database?
10:00:01 <EvanR> sure
10:00:11 * ski isn't sure about "data doesnt have a paradigm"
10:00:31 <nmdanny> I mean, right now there are different kinds of databases, SQL, NoSQL like Mongo, Graph databases, etc..
10:00:43 <EvanR> obj <- select person 4
10:00:51 <EvanR> obj.getParadigm()
10:01:10 <EvanR> nmdanny: some of these are misguided at best
10:01:25 <monochrom> indeed, the history of databases shows 3 paradigms. "network" (pointers and nodes), dictionary (e.g., Berkeley database), relational.
10:01:28 <ski> (in practice, the lecturer actually used
10:01:31 <ski>   ⎛V⎞
10:01:32 <ski>   ⎝2⎠
10:01:33 <EvanR> some are used for the wrong applications, some are wrong for pretty much any application
10:01:43 <ski>  but it's the same thing, just different concrete syntax)
10:01:53 <sm> nmdanny: if your data is small, you can jam it into any kind of db that you like using. Using the right db becomes more important at scale
10:02:19 <ski> (at least different data *encodings* may be "in different paradigms", i think you'll agree)
10:02:48 <nmdanny> I know eventually I can jam any data into any database, but I'm wondering how to do things "the right way"
10:02:50 <sm> monochrom: also object databases ?
10:03:04 <EvanR> object databases, misguided
10:03:19 <nmdanny> I know that regarding using ORMs theres a thing called object-relational mismatch
10:03:21 <sm> I wouldn't say gemstone or ZODB are misguided
10:03:25 <ski> monochrom : before network, also tree/hierarchical ones, no ?
10:03:29 <ski> also, "flat" ones
10:03:36 <monochrom> very few people have heard of "network database" today. but it was big and it was taught 25 years ago. and it was uphill both ways. but it's a pretty simple idea: nodes containing data and having pointers to other nodes. if you say "directed graph" that's also right.
10:03:53 <DwarfSock> hi! i'm working my way through Haskell Programming From First Principles, and I'm currently at the chapter about monad transformers. I've been tasked with writing functor, applicative and monad instances for StateT, and I'm stuck at the applicative instance
10:04:32 <nmdanny> so, if I choose to use 'persistent' as a database, would I also face some mismatch between relational-functional data types?
10:04:45 <monochrom> but that's also the time when the relational way became successful and eventually replaced the network way.
10:05:24 <EvanR> what was a network database product example?
10:05:27 <sm> nmdanny: I think with persistent that mismatch is minimal because it doesn't do a lot of fancy relational stuff
10:05:56 <ski> afaiui, (most, i suppose) current relational systems have woefully inadequate data types. but that's not intrinsically a problem of the relational data model
10:06:22 <ski> (well, but "1NF : attributes are atomic" must die, in its usual interpretation)
10:06:46 <monochrom> if you say, "but what's so profound about the network way? I'm already doing that with linked lists and ad-hoc custom-made data structures full of pointers", you're also right, it was not profound, it was just what everyone did before relational.
10:07:22 <monochrom> except for the difference between "in main memory" and "on disk"
10:07:40 <ski> DwarfSock : show your code
10:07:42 <swilde> hi *, importing Attoparsec it announces to be depricated -- so what should I use instead?  Parsec?
10:07:45 <nmdanny> ok, so now im thinking practically, if I want to make some average CRUD web-app with some relational modelling(one to many/many many links etc), using persistent would be good enough for most purposes?
10:07:51 <sm> nmdanny: well, or maybe that is the mismatch right there. It does have some kind of support for references to other values, but it's not as simple as storing a value in acid-state (I assume)
10:08:06 <EvanR> nmdanny: really i like the -simple libraries
10:08:21 <sm> nmdanny: yes, that is the most-trodden path
10:09:22 <nmdanny> also, are there any packages for easily creating generic CRUD APIs using yesod, servant or something alike?
10:09:24 <cocreature> swilde: just the top level module is deprecated. you should import Data.Attoparsec.Text or whatever text format you’re working with
10:09:44 <sm> http://hackage.haskell.org/packages/search?terms=crud
10:10:02 <swilde> cocreature: Ah I see, thanks!
10:10:03 <DwarfSock> ski: the first problem I've run into is don't really know how to get pure to work properly. I tried this     pure x = StateT $ \s -> (\(a, s') -> (pure a, s')) $ runStateT x s
10:10:43 <monochrom> I think you have too many lambdas.
10:10:53 <ski> DwarfSock : looks way too complicated
10:11:14 <monochrom> the \s is necessary. the other one seems to be an XY problem.
10:11:25 <DwarfSock> yeah probably. my logic is that I want to make sure the applicative layer m in s -> m (a,b) is pure
10:11:44 <ski> DwarfSock : you should not need to use `runStateT' there at all
10:12:27 <nmdanny> When I used django I really liked the idea of generic viewsets that let me easily create CRUD apps, with dynamic filtering, pagination, authentication etc..
10:12:52 * hackagebot pipes 4.1.9 - Compositional pipelines  https://hackage.haskell.org/package/pipes-4.1.9 (GabrielGonzalez)
10:12:53 <nmdanny> so im wondering if something like that exists in haskell
10:13:10 <sm> nmdanny: I just linked to two, yesod-crud & yesod-crud-persist
10:13:18 <ski> DwarfSock : "my logic is that I want to make sure the applicative layer m in s -> m (a,b) is pure" -- that's what `pure' is for
10:13:37 <ski> DwarfSock : however, you used `pure' in the wrong place
10:14:10 * ski would recomment DwarfSock start over from `pure x = StateT $ \s -> ..x..s..'
10:14:32 <ski> DwarfSock : and there, start by figuring out the type of that `..x..s..' "hole"
10:14:44 <DwarfSock> okay, I'll try that, thanks!
10:14:57 <ski> (hopefully the types of `x' and `s' should be obvious. otherwise you need to figure out those as well)
10:16:30 <jmcarthur> nmdanny: I don't really understand what you are asking for.
10:16:31 <DwarfSock>     pure x = StateT $ \s -> pure (x, s)
10:16:41 <ski> DwarfSock : yep :)
10:16:44 <ski> simple, right ?
10:16:48 <DwarfSock> wow, I feel dumb now
10:16:49 <jmcarthur> nmdanny: Maybe because "generic viewset" means something I am not aware of.
10:16:57 <Lovepon> Why was it called pure?
10:17:10 <Lovepon> Just curious.
10:17:16 <Lovepon> What was the idea behind the naming.
10:17:27 <ski> presumably because it expresses having no effects
10:17:28 <jmcarthur> Lovepon: Probably because it must not have any effect.
10:17:46 <Lovepon> jmcarthur: I see.
10:17:56 <nmdanny> its a django thing, but anyway yesod-crud seems to provide something similar although pretty complex
10:18:02 * ski should have stressed the "expresses" part
10:18:36 <jmcarthur> ski: But it should literally have no effect, otherwise the identity laws wouldn't hold.
10:18:56 <jmcarthur> ski: So I think it was right not to emphasize "expresses" too much.
10:19:23 <EvanR> jmcarthur: this is a pattern that emerges after enough database munging, you want to filter and paginate "any table", but able to modify any cell, add new records
10:19:35 <EvanR> basically PHP myadmin
10:19:58 <jmcarthur> EvanR: Ah, so just a generated UI for manipulating tables
10:20:17 <ski> jmcarthur : the point being that `I' in `pure :: a -> I a' is a way to *express* the possible presence of some specific kind of effect
10:20:22 <ski> e.g. `Maybe' expresses failure
10:20:31 <ski> `[]' expresses angelic nondeterminism
10:20:34 <ski> &c.
10:20:34 <jmcarthur> ski: I would say you are desribing the type constructor I, not the function pure.
10:21:20 <jmcarthur> Whatever, I think we're just approaching it from different angles.
10:21:30 <ski> so, a value in `I a' *may* express some `I'-effects. but `pure x' actually expresses none
10:21:38 <ski> jmcarthur : hm, probably
10:21:41 <jmcarthur> Yeah, we don't disagree. :)
10:23:03 <ski> DwarfSock : does `(<*>)' work out fine ?
10:23:11 <DwarfSock> not yet
10:24:06 <sm> nmdanny: there's also http://postgrest.com, which generates a REST api and has add-ons providing a client-side UI
10:24:43 <EvanR> ski: "angelic" ?
10:24:58 <nmdanny> I've seen that one, but it seems kinda cheaty to me because I don't really have to write haskell to use it
10:25:22 <sm> quite right. Let's forget that one
10:25:23 <simpson> EvanR: Probably referring to how the list Monad doesn't fairly search, but is very biased.
10:25:47 <simpson> So its nondeterminism can take (informally) way too long to find stuff.
10:25:50 <ski> simpson, no
10:26:04 <simpson> ski: Oh? Then I, too, am confused and eager to learn.
10:26:26 <ski> EvanR : referring to that you can decide to ask for another solution, if you don't like the one you got
10:26:52 <ski> if there is a solution which will "make things turn out in the end", then angelic nondeterminism will find it for you
10:27:24 <EvanR> as opposed to giving you no choice about the result?
10:27:26 <ski> viewed as an oracle, that picks an element out of a set for you, it will pick the most helpful element, according to the context you're using it in
10:27:41 <ski> while demonic nondeterminism will choose the least helpful element
10:28:04 <EvanR> how would that go
10:28:28 <ski> there's also erratic nondeterminism (think e.g. concurrency, randomness, or library nonspecificity), where you can't rely on which answer you'll get, only that you'll get *some* answer
10:30:06 <ski> "Non-determinism in Functional Languages" by Harald Søndergaard,Peter Sestoft in 1988-08,1992-05 at <http://comjnl.oxfordjournals.org/content/35/5/514.abstract>
10:31:05 <ski> simpson,EvanR ^
10:31:10 <EvanR> nice
10:31:11 <simpson> ski: Nifty, thanks.
10:31:44 <ski> i think the demonic kind can be useful when doing simulations, to try to compute worst cases
10:32:07 <ski> the thing you get in Prolog is the angelic kind
10:32:32 <ski> well, unless in certain cases, where you don't have completeness, in which case you get the erratic kind, more or less
10:32:50 <ski> in Mercury, that is called "committed-choice nondeterminism"
10:33:03 <ski> e.g., collecting all the solutions of a goal in a list
10:33:12 <ski> the solutions is a set, which can be ordered in a list in many ways
10:33:19 <ski> so conceptually, there's many possible solutions
10:33:41 <ski> but the implementation will just compute one of them, the ordering in which it happened to compute the goal solutions in
10:34:13 <ski> (and that can change, depending on implementation optimizations. conceptually, it can even change between different calls with the same input, the same process)
10:34:15 <simpson> Oh, is that kind of like how a PEG commits to just one of the choices, while a CFG can explore all of them?
10:34:19 <ski> yes
10:34:54 <ski> often, in such a case, the system is set up in such a way that you'll always get the same answer in the end, regardless of the path you take towards an answer
10:35:13 <monochrom> haha, erratic nondeterminism
10:36:03 <ski> Mercury has pragmas `promise_equivalent_solutions' and `promise_equivalent_solution_sets' for such cases, in case the intermediate solutions may differ, but the "ultimate answer" is always the same
10:37:32 <ski> (<https://www.mercurylang.org/information/doc-latest/mercury_ref/Goals.html> describes those two pragmas)
10:41:44 <bollu> hey 
10:41:52 <bollu> I was wondering if someone could explain Kan extensions to me
10:41:58 <bollu> now that I think I have a hang of adjoint functor
10:42:00 <bollu> adjoint functors*
10:42:31 <ski> bollu : remember how adjoint functors allow you to go between `F A >---> B' and `A >---> G B'
10:42:47 <bollu> ski: hey :)
10:43:03 <bollu> right,
10:43:05 <bollu> I do
10:43:16 <ski> bollu : right Kan extensions allow you to go between `F . G >---> H' and `F >---> Ran_G H'
10:43:41 <ski> bollu : iow, right Kan extensions are adjunctions `(. G) --| Ran_G'
10:43:49 <bollu> what is F . G ? you're composing functors? and what is Ran_G?
10:43:50 <EvilMachine> Hey. Haskell’s right-hand side is really nice in that you just write what that which you want consists of, to get it. But its left-hand side… the pattern-matching…  seems to lack that power. I wish you could put functions in there. What do I do to parse things with that same “describe what it’s made out of” mindset?
10:43:57 <ski> bollu : and left Kan extensions are adjunctions `Lan_G --| (. G)'
10:44:42 <ski> bollu : `F : D >---> E',`G : C >---> D', functors yes
10:45:00 <sbrg> Anyone familiar with esqueleto that can tell me how I can go about applying a function to a value for groupBy? For example, if I have a database of (thing, timestamp) pairs, I can group by hours by being able to group by on timestamp `div` 60, etc.
10:45:10 <ski> bollu : `H : C >---> E',`Ran_G H : D >---> E'
10:45:10 <simpson> EvilMachine: There's the ViewPatterns extension, which is almost but not quite the kind of thing that you're asking for.
10:45:12 <bollu> F is from D to E?
10:45:20 <bollu> wait, I'll grab a pen and paper for this
10:45:21 <ski> (probably i should have swapped the names of `F' and `G')
10:45:27 <EvilMachine> simpson: like that “tea” from HHGTTG? :D
10:45:29 <ski> bollu : agree to swap the names ?
10:45:36 <bollu> ski: sure
10:45:38 <EvilMachine> simpson: thanks. i’ll look into it.
10:45:48 <bollu> ski: gimme a minute or two
10:45:52 <ski>   F : C >---> D
10:45:56 <ski>   G : D >---> E
10:46:02 <ski>   G . F : C >---> E
10:46:06 <simpson> EvilMachine: It is one of my deepest regrets that there is not a version of those books with chapter and verse numbers, so that I could quote it like a bible.
10:46:07 <ski>   H : C >---> E
10:46:21 <ski>   Ran_F H : D >---> E
10:46:37 <ski>   Lan_F H : D >---> E
10:46:56 <ski> `Ran_F H' is the right Kan extension of `H', along `F'
10:47:04 <ski> `Lan_F H' is the left Kan extension of `H', along `F'
10:48:24 <ski> EvilMachine : view patterns allow you to "put functions in there"
10:48:37 <ski> EvilMachine : "HHGTTG" ?
10:50:11 <simpson> ski: The Hitchhiker's Guide to the Galaxy.
10:50:28 <DwarfSock>  ok, I'm struggling with <*> for StateT as well.
10:50:29 <EvilMachine> simpson: Well, if there is an online version, you could use an XPath, to point to an exact paragraph or even characters. Firefox used to support XPaths after the # in URLs. But they removed it because “nobody used it”. (Hint: Nobody ever heard it even existed, for years.)
10:50:29 <ski> EvilMachine : perhaps you could elaborate on what you intend by "you just write what that which you want consists of, to get it","describe what it’s made out of" ?
10:50:40 <ski> simpson : oh
10:50:49 <DwarfSock>   (StateT f) <*> (StateT x) =  StateT $ \s -> ((f <*> x), s)
10:50:57 <simpson> EvilMachine: No, I mean, building the tool would be a bit of work and extremely risky in terms of legal liability. But I still want it.
10:51:00 <EvilMachine> simpson: There are tools that allow you to select stuff on a HTML page, and give you the XPath of it.
10:51:02 <ski> DwarfSock : redundant brackets detected
10:51:37 <DwarfSock> yeah forgot to remove them :) but I'm missing the applicative context, and I'm not sure how to get it
10:51:38 <ski> DwarfSock : also, that can't be right. it has to "thread" `s' through both `f' and `x'
10:51:42 <bollu> ski: okay, I'm bak
10:51:44 <EvilMachine> simpson: Only if you respect the organized crime (aka Content Mafia), even though they are the main harm to artists. I rather put my stuff on servers outside of their control. :)
10:51:44 <bollu> back*
10:51:56 <bollu> so both Ran_F H and Lan_F H map to the same thing
10:51:57 <bollu> ?
10:52:00 <simpson> EvilMachine: Let's not worry about it today. Tomorrow is a better day.
10:52:05 <bollu> map the same categories*?
10:52:06 <simpson> Also, winter is coming.
10:52:08 <EvilMachine> simpson: ViewPatterns are very close to what I needed. :) Thank you, I think they are good enough.
10:52:09 <bollu> sorry I'm a little tired
10:52:09 * ski ponders how to `fork(2)' themselves
10:53:20 <EvilMachine> simpson: I know… I always worry… it’s not like we would quickly accelerate into totalitarian fascism because nobody worries /sarcasm. (But I can hold it for now. So don’t worry. :)
10:53:31 <DwarfSock> ski: i'm not sure I understand. I thought the type of f was (a -> b) in StateT s m (a -> b) and x was a in StateT s m a?
10:54:21 <DwarfSock> so that f <*> x = m (a -> b) -> m a 
10:54:25 <ski> bollu : "so both Ran_F H and Lan_F H map to the same thing ?" -- yes, the left adjoint and the right adjoint of a functor must have the same type
10:54:48 <bollu> ski: okay, so I'm guessing the objects/morphisms they ma to are different even if the categories are the same
10:55:23 <ski> DwarfSock : no, the type of `f' is `s -> m (a -> b,s)', and the type of `x' is `s -> m (a,s)'
10:55:33 <EvilMachine> ski: Well, e.g. mainwindow = titleBar /// frame (menu /// frame (sidebarL ||| textEdit ||| sidebarR ) /// statusBar)
10:55:42 <DwarfSock> oh
10:55:43 <EvilMachine> ski: I just made up ///
10:55:52 <ski> DwarfSock : this follows from `newtype StateT s m a = StateT (s -> m (a,s))'
10:56:05 <bollu> ski: okay, right. So now, (a) what is the auxiliary H? (b) what to Ran F H and Lan F H do?
10:57:49 <ski> EvilMachine : also see pattern synonyms
10:58:29 <ski> <bollu> ski: okay, so I'm guessing the objects/morphisms they ma to are different even if the categories are the same
10:58:32 <ski> yes
10:58:34 <ski> note
10:59:34 <bollu> yes?
10:59:43 <ski>   (.) : E^D * D^C >---> E^C
10:59:46 <ski>   F : C >---> D
10:59:51 <ski>   (. F) : E^D >---> E^C
10:59:53 <ski>   Ran_F,Lan_F : E^C >---> E^D
11:00:27 <ski> where `D^C' is the functor category, where objects are functors from `C' to `D', and morphisms are natural transformations between such functors
11:00:40 <ski> and mutatis mutandis for `E^D' and `E^C'
11:01:16 <ski> in types, `D^C' would instead be written `C -> D'
11:01:24 <ski> so, you could say
11:01:37 <ski>   (. F) : (D -> E) >---> (C -> E)
11:01:48 <ski>   Ran_F,Lan_F : (C -> E) >---> (D -> E)
11:01:58 <ski> dunno if that makes it easier to read for you, or not
11:02:26 <ski> (`->' is exponential in `Cat', which is very different from `>--->')
11:02:46 <bollu> I'm drowning
11:02:54 <bollu> okay 1) how is -> different from >—>
11:02:56 <bollu> ?
11:02:57 <ski> (or at least a different kind of thing. it's a bit like the difference between implication `=>' and entailment `|-')
11:03:17 <ski> `->' takes two categories and forms a new category (the functor category)
11:03:27 <ski>   (->) : Cat * Cat >---> Cat
11:03:32 <bollu> wait, first of all, what *is* a Kan extension? as in, what is it *doing*?
11:03:43 <bollu> and >—> is a ..? morphism?
11:04:17 <ski> `A >--->_C B' is the collection of morphisms, in category `C', from object `A' to object `B'
11:04:31 <ski>   (>--->_C) : C^op * C >---> Set
11:04:48 <ski> (the latter `>--->' there is really `>--->_Cat')
11:05:28 <bollu>   (>--->_C) : C^op * C >---> Set? I'm confused, why is C^op here? Why is it mapping to set?
11:05:36 <bollu> I'm sorry if the questions are silly, I'm just new to Cat. theory :)
11:05:51 <ski> each morphism class is a set .. at least if `C' is a small category
11:05:58 <ski> (otherwise it's larger than a set)
11:06:11 <DwarfSock> ski: i didnt read the question properly, I see that I need a monad instance for m in StateT s m a in order to be able to write <*>
11:06:11 <ski> but i was ignoring size issues
11:06:34 <bollu> ahh
11:06:50 <bollu> what exactly do you mean by "morphism class"?
11:06:54 <EvanR> mutatis mutandis sounds like harry potter jargon
11:07:11 * ski heard that term before Harry Potter existed
11:07:21 <EvanR> dont lie
11:07:29 <ski> it means, roughly, "changing what should be changed"
11:07:51 <ski> or perhaps s/should/ought to/
11:08:46 <ski> DwarfSock : hm, yes. you're right
11:09:05 <bollu> ski: can we take a step back, and, well, motivate what a Kan extension is trying to do the way you did with adjoint functors? :)
11:09:17 * ski didn't think of that (though i wondered why you were writing `m' instead of `i' or `f')
11:09:54 <ski> bollu : you should probably ask Cale or edwardk for that. i don't know very much about the motivation for them
11:10:01 <bollu> hm, okay
11:10:11 <bollu> in that case, can we do the cat. theory behind them?
11:10:16 <bollu> okay, now I have the diagram with me
11:10:20 <bollu> what am I looking at?
11:10:24 <bollu> how do I construct Ran)F H?
11:10:31 <ski> bollu : i know it was noticed by edwardk that they can be useful in a programming context
11:10:50 <ski> and i've read the section in "Categories for the Working Mathematician" about them
11:12:16 <ski> bollu : in terms of Haskell types, `Ran_F H a' is `forall b. (a -> F b) -> H b'
11:12:53 <ski> hm, i should probably swap the names of `a' and `b', there
11:13:10 <bollu> so why did we need the G?
11:13:30 <ski> since the argument to `F' and `H' is an object in `C', and the argument to `Ran_F H' is an object in `D'
11:14:03 <ski> bollu : same reason we needed `B' in the adjunction `F --| U' converting between `F A >---> B' and `A >---> U B'
11:14:13 <bollu> hm, okay
11:14:14 <bollu> go on
11:14:24 <ski> bollu : just as an "additional variable to hang things on" :)
11:14:39 <bollu> so, how do I construct Ran_F H?
11:15:01 <ski> <ski> bollu : in terms of Haskell types, `Ran_F H b' is `forall a. (b -> F a) -> H a'
11:15:11 <ski> (i renamed `a' and `b')
11:15:33 <ski> bollu : consider `foo :: forall a. G (F a) -> H a'
11:15:55 <ski> this corresponds to the `G . F >---> H' natural transformations
11:17:15 <bollu> yeah, is't H just G . F?
11:17:23 <bollu> oh, it's *along* the same lines as G. F
11:17:27 <ski> yes
11:17:27 <bollu> hm
11:17:32 <ski> `H' can be any functor
11:17:43 <bollu> is H = G . F or H <(natural transform)> G . F?
11:18:02 <ski> rather `G . F >---> H' :)
11:18:19 <bollu> right :)
11:18:24 <ski> so `foo : G . F >---> H' is the type signature of the natural transformation `foo'
11:18:50 <ski> bollu : now, we know, in general, `Yoneda F b' is `forall b. (b -> a) -> F a', in terms of Haskell types
11:19:07 <ski> but, when `F' is a functor, `Yoneda F' is isomorphic to just `F'
11:19:12 <ski> ok ?
11:19:13 <bollu> ski: you're telling me that's what Yoneda is?
11:19:19 <bollu> because I don't know Yoneda
11:19:26 <ski> er, sorry, typo
11:19:35 <ski> in general, `Yoneda F b' is `forall a. (b -> a) -> F a', in terms of Haskell types
11:20:46 <bollu> okay, now how do I think about that?
11:20:56 <ski> `forall a. (b -> a) -> F a' is the type of "delayed `fmap's over `F', with `b' as \"element type\""
11:21:36 <ski> @type \f -> fmap f "foo"
11:21:38 <lambdabot> (Char -> b) -> [b]
11:21:43 <ski> is an example
11:22:05 <ski> we have a structure, and we've applied `fmap', but we haven't yet decided what function to actually use with the `fmap'
11:22:27 <ski> this is useful for fusing together several `fmap's "in a row", so that we only traverse the `F' structure once
11:23:00 <ski> regardless of whether `F' is a functor or not, `Yoneda F' is a functor
11:27:54 <ski> @let newtype Yoneda f b = JorpPamF {fMapProj :: forall a. (b -> a) -> f a}
11:27:56 <lambdabot>  Defined.
11:29:14 <bollu> hmm
11:29:14 <bollu> wait
11:29:15 <bollu> so
11:30:20 <bollu> ski: how does this let us fuse Fmap?
11:30:38 <ski> @let instance Functor (Yoneda f) where fmap :: (b0 -> b1) -> (Yoneda f b0 -> Yoneda f b1); fmap b01 yfb0 = JorpPamF (\b1a -> fMapProj yfa0 (b1a . b01))
11:30:38 <lambdabot>  Parse failed: InstanceSigs is not enabled
11:30:44 <ski> oh :(
11:30:52 <ski> @let instance Functor (Yoneda f) where fmap b01 yfb0 = JorpPamF (\b1a -> fMapProj yfa0 (b1a . b01))
11:30:53 <lambdabot>  .L.hs:185:53:
11:30:53 <lambdabot>      Not in scope: ‘yfa0’
11:30:53 <lambdabot>      Perhaps you meant ‘yfb0’ (line 185)
11:30:59 <ski> oh, typo
11:31:09 <ski> @let instance Functor (Yoneda f) where fmap b01 yfb0 = JorpPamF (\b1a -> fMapProj yfb0 (b1a . b01))
11:31:11 <lambdabot>  Defined.
11:31:12 <ski> ok
11:31:38 <ski> @let proj :: Yoneda f b -> f b; proj yfb = fMapProj yfb0 id
11:31:39 <lambdabot>  .L.hs:198:21:
11:31:39 <lambdabot>      Not in scope: ‘yfb0’
11:31:39 <lambdabot>      Perhaps you meant ‘yfb’ (line 198)
11:31:45 <ski> @let proj :: Yoneda f b -> f b; proj yfb = fMapProj yfb id
11:31:46 <lambdabot>  Defined.
11:32:36 <ski> note that `fMapProj yfb ba' is equal to `fmap ba (proj yfb)', which explains the name `fMapProj' (and `JorpPamF', which is that one, backwards)
11:33:03 <ski> however, to include into `Yoneda f b', you need `f' being a functor
11:33:42 <ski> @let incl :: Functor f => f b -> Yoneda f b; incl fb = JorpPamF (fmap fb)
11:33:44 <lambdabot>  .L.hs:196:26:
11:33:44 <lambdabot>      Couldn't match type ‘f’ with ‘(->) a’
11:33:44 <lambdabot>        ‘f’ is a rigid type variable bound by
11:33:59 <ski> oh, flip
11:34:06 <ski> @let incl :: Functor f => f b -> Yoneda f b; incl fb = JorpPamF (\ba -> fmap ba fb)
11:34:07 <lambdabot>  Defined.
11:34:10 <ski> ok
11:35:05 <ski> bollu : `proj . fmap f . fmap g . incl xs' is `fmap (f . g)'
11:35:12 <ski> s/ xs//
11:35:23 <bollu> ski: I'll be back in 5
11:35:55 <ski> anyway, the main point here is just to note that `Yoneda f b' is iso to `f b', when `f' is a functor
11:40:10 <sanderman01> Hi. I'm concepting a sort of mini-operating system in haskell, which I plan to embed inside a game about spaceships. Think something like computercraft or 0x10c.
11:40:47 <sanderman01> I plan to use include a terminal and to use hint for interpreting haskell scripts.
11:41:40 <sanderman01> Is there a way for me to allow users to access files in their game save directory, but not allow any of that outside the game directory? sort of like a security sandbox?
11:42:17 * ski doesn't know of anything, save `chroot'
11:42:31 * ski doesn't know how to use `chroot' properly, either
11:43:05 <Nycatelos> c-h-root?
11:43:20 <ski>   chroot - run command or interactive shell with special root directory
11:43:31 <ski> see `man chroot'
11:43:34 <sanderman01> I'm hoping for something crossplatform. chroot is only used on unixes, right?
11:43:52 <ski> dunno whether CygWin has it
11:44:11 <monochrom> you are about to write your own OS, yeah
11:44:44 <EvanR> write your own PL instead?
11:44:53 <sanderman01> I was thinking maybe I should just wrap everything in System.IO to make sure only paths inside the game save directory can be accessed.
11:45:03 <ski> EvanR : could amount to the same thing, depending ..
11:45:05 <EvanR> sad that its necessary but haskell just doesnt seem to be designed for this
11:45:17 <monochrom> no, I'm just scaring you. you are only to implement a very small aspect of an OS, it's tractible.
11:46:03 <EvanR> sanderman01: how would that ensure that?
11:46:03 <sanderman01> I'm aware that this project is quite ambitious, especially for someone new to haskell. :)
11:47:03 <sanderman01> EvanR I was thinking I could perhaps make my own System.IO module which internally checks that paths are allowed and then calls the real System.IO module
11:47:08 <monochrom> you can use hint and accept almost arbitrary haskell code, but don't let them use the standard IO. define and implement your own newtype wrapper over IO, provide censoring operatations.
11:47:35 <EvanR> replacing IO might work
11:47:57 <EvanR> but you can still import regular IO
11:48:14 <bogart> hi
11:48:26 <EvanR> and checking FilePath strings for insecure stuff sounds....
11:48:44 <monochrom> for example do not let them use openFile. but you can provide your own ironCurtainOpenFile :: Filepath -> Mode -> IronCurtainIO Handle. now it can refuse to serve certain files.
11:48:46 <sanderman01> lots of ways for things to slip through, yeah..
11:49:11 <EvanR> if its not actually going to be secure then you might as well not waste your time
11:49:28 <EvanR> this sort of issue exists with pretty much every game engine
11:49:38 <bogart> Im having some trouble testing if an unboxed vector is empty, does anyone know how to do it?
11:49:41 <bogart> import Data.Vector.Unboxed as VU; let a = empty; VU.null a; Type variable 'a0' is ambiguous
11:49:47 <bollu> ski: so, Yoneda *itself* is a functor?
11:49:48 <bollu> what the hell
11:50:20 <ski> bollu : `Yoneda F' is a functor
11:50:20 <sanderman01> it's mostly intended to prevent "I accidentally.. my documents folder"
11:50:52 <EvanR> sanderman01: then, dont let them delete files, actually dont let them reading files, whats the point of this feature?
11:51:18 <EvanR> allow script access to save game files? is that useful?
11:51:33 <EvanR> if so, export a thing to retriev a saved game file
11:51:34 <monochrom> I have a bright idea.
11:51:46 * ski has a cunning plan
11:52:05 <monochrom> Let them save but don't let them read. You can implement this by nop. Since they can't read to verify.
11:52:29 <sanderman01> basically I was thinking the in-game operating system's root dir would just map to a directory inside their save folder, so players would be able to edit their scripts inside our outside the game
11:52:38 <sanderman01> and reading and writing is useful for settings files
11:52:57 <monochrom> chroot is the safest.
11:53:02 <EvanR> editing scripts with a script written using the script editor ... script?
11:53:14 <bogart> @help
11:53:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:53:14 <ski> bollu : whether `Yoneda' itself can be considered a functor .. well, let's not go there now
11:53:20 <simpson> sanderman01: Look at it this way. Why do you want a new filesystem with the semantics of your existing filesystem? You have an opportunity to aggressively simplify things inside your environment.
11:53:22 <sanderman01> a trading oriented person might want to write an automatic trading script that keeps a log of all trades, for instance
11:53:27 <bogart> @list
11:53:27 <lambdabot> What module?  Try @listmodules for some ideas.
11:53:33 <bogart> @listmodule
11:53:33 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
11:53:39 <bogart> @listmodules
11:53:39 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
11:53:40 <ski> bollu : the important point, as i said, is that `Yoneda F' is iso to `F', in case `F' is a functor
11:53:48 <EvanR> sanderman01: so expose a logging API instead of the OS
11:54:02 <bogart> @list vector
11:54:03 <lambdabot> No module "vector" loaded
11:54:07 <sanderman01> simpson that makes sense
11:54:07 <bogart> @list data
11:54:08 <lambdabot> No module "data" loaded
11:54:08 * ski idly wonders what bogart is looking for
11:54:12 <bogart> @list data.vector
11:54:12 <lambdabot> No module "data.vector" loaded
11:54:14 <scshunt> Coyoneda's where it's at
11:54:19 <fatex> https://gist.github.com/anonymous/ef29b138879f6ed1cfc550ccffcaefa3 <-- does this def work for Free/Functor ?
11:54:26 <EvanR> create a database that is not just a big blob that the user can edit with the script
11:54:28 <ski> scshunt : yes, we may get to that as well
11:54:32 <monochrom> actually I have not seen a game that restricts file access just for the purpose of editing scripts and maps
11:54:35 <bogart> @listlist help
11:54:35 <lambdabot> Unknown command, try @list
11:54:39 <bogart> @list help
11:54:39 <lambdabot> help provides: help
11:54:41 <EvanR> the OS and filesystem dont need to be exposed directly
11:55:16 <ski> bogart : `list' and `listmodules' are for *lambdabot* modules, not Haskell modules
11:56:32 <monochrom> what they do is default to the default script directory and the default terrain directory etc. they don't disallow you to click your mouse 10 times to walk to other directories. but who will? and even if someone will, it's their file.
11:57:21 <EvanR> no but the idea is it is running untrutsed code
11:57:22 <monochrom> but the very fact that you have to go out of your way to click 10 times before you can destroy some other files means that it is enough for reducing accidents
11:57:37 <monochrom> no, that's the Y of the XY problem
11:57:46 <sanderman01> I was thinking it would be good if the in-game API's looked a lot like the official haskell ones, for consistency and the educational ecosystem. But now that I think about it. Exposing my own simpler API that does exactly what I want, might be the best way to go indeed.
11:57:51 <EvanR> even then, games dont bother restricting this
11:57:55 <monochrom> the X problem is reducing accidents. (not even increasing security.)
11:58:15 <monochrom> the Y problem is "maybe I can reduce accidents by being extremely secure"
11:58:41 <EvanR> the W is you want a scripting language that is useful for a particular game rather than a general purpose language
12:00:22 <ski> bollu : shall we continue ?
12:00:31 <bollu> can you give me 15?
12:00:38 <ski> seconds, minutes, or hours ?
12:00:38 <ertesx> hi there…  in unordered-containers, items with colliding hashes act like sequences, right?
12:00:41 <sanderman01> Thanks for the input. Lots of food for thought.
12:00:44 <bollu> minutes
12:00:47 <ski> ok
12:01:00 <ertesx> in terms of performance
12:01:21 <ertesx> (this is a security-related question)
12:01:33 <fatex> <$> is fmap; does <*> (from applicative) have a name?
12:01:37 <fatex> or is it just <*> ?
12:01:52 <ertesx> fatex: you could call it `ap`, but it has a stronger type signature
12:01:55 <ski> fatex : it's sometimes called `ap' (from "apply" or "application")
12:01:55 <DwarfSock> <*> is called apply I think
12:02:01 <ski> cf.
12:02:02 <fatex> :t ap
12:02:03 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:02:04 <ski> @type2 ap
12:02:05 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:02:12 <fatex> ap requires Monad
12:02:22 <fatex> oh, that's what you meant by "stronger type signature" ?
12:02:23 <ski> (which is the corresponding thing from `Monad'. this existed before `Applicative' was invented)
12:02:28 <ertesx> fatex: yeah
12:02:34 <ertesx> fatex: it's still the same thing though
12:02:40 <fatex> ertesx, ski: thanks
12:02:58 * ski . o O ( why DwarfSock get no thanks ? )
12:03:19 <fatex> nightmares about dwarf fortress
12:03:22 <ertesx> regarding the HashMap/HashSet question above: i guess it has to act like that
12:03:33 <fatex> DwarfSock: thanks -- didn't see your response, sorry
12:03:36 <ski> (:
12:03:49 <DwarfSock> i wanted the nickname +CaveSpiderSilkSock+ but for it's too long for freenode
12:03:53 <monochrom> ertesx: I don't know the answer. But I know that a lot of people think that they know the answer, but they never read the actual code, they just guessed, and they're likely wrong. So if someone answers you, check whether they read the source code at all.
12:04:23 <EvanR> ertesx: er, those are trees though
12:04:24 <ertesx> monochrom: well, due to the contexts (Eq and Hashable) it really doesn't have much choice, i guess
12:04:35 <monochrom> yeah
12:04:35 <EvanR> so not sure if its like a classic hashtable in that respect
12:04:53 <ertesx> i'd really prefer, if HashMap would degenerate to Map instead, and i wouldn't mind the stronger Ord constraint
12:05:17 <monochrom> well, you never know how many secondary, tertiary, quaternary levels of hashing you can do with just one hash code :)
12:05:30 <ski> monochrom : .. fwiw, i needed `C(N,K)' as a set earlier, when categorifying a formula relating combinations and sterling numbers into epi-mono factorization ..
12:06:11 <urbanslug> Hey, I have an interesting case. I want to use haskell-ide-engine. I have added it in a checkouts/ in my package. Then added it in packages in my stack file. However, from it's stack.yaml it also has it's own depending packages. In the root dir.
12:06:17 <ertesx> EvanR: i'm aware that they are trees…  they are basically IntMap
12:06:31 <urbanslug> Which is the best way to make it find it's depends
12:06:39 <urbanslug> This https://github.com/haskell/haskell-ide-engine/blob/master/stack.yaml
12:06:57 <ertesx> and the question is, do they act like IntMap (Seq (K, A)) or more like IntMap (Map K A)
12:07:15 <urbanslug> As you can see it depends on other local packages. However it stack can't build it because it can't find it's local packages.
12:07:22 <monochrom> ertesx: what do you think of "The implementation is based on hash array mapped tries" and "The implementation is based on big-endian patricia trees"?
12:07:42 <EvanR> lookup :: (Eq k, Hashable k) => k -> HashMap k v -> Maybe v
12:08:02 <EvanR> so this suggests linear search
12:08:04 <EvanR> howevr
12:08:16 <EvanR> lookup :: (Hashable k, Ord k) => k -> Map k a -> Maybe a
12:08:26 <EvanR> from the hashmap package, suggests otherwise
12:08:53 <EvanR> which literally says its an IntMap
12:09:00 <ertesx> monochrom: sounds like the Seq variant, except perhaps with Vector…  not sure though, because it's vague
12:09:25 <ertesx> (not Vector from 'vector', but an array)
12:09:36 <monochrom> ok, the first one is unordered-cotainers HashMap, the second one is containers IntMap
12:09:50 <monochrom> the point is HashMap is not "basically IntMap"
12:10:07 <monochrom> and the meta-point is: see how many people actually checked. even you didn't.
12:10:36 <monochrom> and at this level I haven't even read the source code. I have only read the docs.
12:10:48 * EvanR ponders the moral of the story, decides not to check the docs of `hashmap' for validity, and goes to get coffee
12:10:53 <monochrom> the corollary is how many people even read the docs?
12:11:04 <ertesx> monochrom: i'm aware of those though, but they don't tell anything about the case i'm asking about, namely hash collisions
12:11:39 <ertesx> what if the hashes of two different keys are equal?  does it degenerate to linear search?  and the most plausible answer, given the context, is yes
12:12:55 * hackagebot github-release 0.1.5 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-0.1.5 (fozworth)
12:13:12 <ertesx> given the current security status of the hashable package (yes, it's documented), it basically means that HashMap is a dangerous choice for untrusted data
12:13:35 <ertesx> it doesn't blow up memory-wise like a hash-table would, but the time asymptotics do blow up
12:14:08 <EvanR> the security of hashable or HashMap?
12:14:14 <ertesx> EvanR: hashable
12:14:14 <monochrom> ok, yes, that's something you can deduce from polymorphism over Eq and Hashable
12:14:42 <ertesx> EvanR: it uses unkeyed hashing, so an attacker can find collisions easily
12:14:51 <EvanR> yuck
12:15:09 <EvanR> well you can use hashmap Map instead which uses the Ord constraint
12:15:17 <ertesx> keyed hashing is a problem of its own in haskell land, but it could be solved somewhat elegantly using a phantom type that reflects the key
12:15:29 <monochrom> you can't quite deduce "it must be a list". but you can deduce "Ω(n) because information theory"
12:16:06 <ertesx> EvanR: i can't really use HashMap at all in that case, because it doesn't let me handle collisions myself
12:16:26 <ertesx> i've wondered about this a few times now…  maybe i should make a proof of concept implementation of my hashable idea
12:16:28 <dolio> monochrom: Did you read the docs on the docs, to realize that "hash array mapped tries" and "big endian patricia trees" are kind of the same thing?
12:16:42 <monochrom> no, I haven't.
12:16:47 <dolio> :)
12:17:12 <EvanR> ertesx: well hashmap Map isnt HashMap
12:17:13 <monochrom> however, I wouldn't trust you either!
12:17:15 <EvanR> it IntMap
12:17:25 <ertesx> EvanR: oh, sorry…  misread
12:17:26 <monochrom> Naw, I trust you a lot.
12:17:53 <EvanR> i just realized all thse words are basically the same lol
12:17:54 <bollu> ski: I'm back :)
12:17:56 * EvanR leaves
12:17:59 * ski . o O ( "Trust, but verify." )
12:18:16 <ertesx> hehe
12:18:47 <ski> bollu : so, do you want to go over the details of `Yoneda' more ?
12:18:55 <bollu> yes please
12:18:59 <bollu> any new concept is fun
12:19:46 <ski> bollu : recall `fmap :: (a -> b) -> (F a -> F b)'
12:19:57 <bollu> ski: okay
12:20:18 <ski> bollu : so the idea is that, given an `F a', we can partially apply `fmap' to this, and get an `forall b. (a -> b) -> F b', iow an `Yoneda F a'
12:21:08 <bollu> ski: okay, with you so far
12:21:33 <ski> bollu : and if we want to now `fmap' a function in `a0 -> a1' over `Yoneda f a0', to get to `Yoneda f a1', what we really do is wait for the function in `a1 -> b' from the future, compose it with the `a0 -> a1', and pass that to `Yoneda F a0', getting back `F b' as required
12:21:38 <ski> bollu : does that make sense ?
12:23:07 <ski> "that" being the composed function, of type `a0 -> b'
12:23:26 <nmdanny> :h
12:23:29 <nmdanny> :hoogle
12:23:35 <ski> @hoogle nmdanny
12:23:37 <lambdabot> No results found
12:23:38 <bollu> yes, I think so. We get h :: a1 -> b as a parameter to Yoneda f a1. We then compose it with `a0 -> a1` to get overselves a `g :: a0 -> b`, That we pass to the original `Yoneda f a0` to get out a b, right?
12:23:42 <nmdanny> @hoogle (Monoid m) => [a] -> (a -> m) -> JoinList m a
12:23:43 <lambdabot> Warning: Unknown type JoinList
12:23:43 <lambdabot> No results found
12:23:54 <ski> @where hayoo
12:23:54 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
12:23:56 <nmdanny> @hoogle (Monoid m) => [a] -> (a -> m) -> t m a
12:23:56 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith' :: Monad m => (a -> b) -> GT m g a -> g -> m (b, g)
12:23:56 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith :: Monad m => (a -> b) -> GT m g a -> m g -> m (b, g)
12:23:56 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
12:24:02 <ski> nmdanny : try that one instead ^ ?
12:24:31 <ski> bollu : yes, except we get an `f b', not a `b'
12:24:39 <nmdanny> nvm i'm not looking for an already existing type.. Just thinking if I can abstract some datatype I've made
12:24:59 <bollu> oh right :)
12:25:11 <ski> bollu : so `fmap'ping over `Yoneda f a' will just compose function. it will wait to traverse the `f' until we use `proj :: Yoneda f a -> f a'
12:25:14 <bollu> so, 'Yoneda f' is a functor for all functors
12:25:20 <ski> yes
12:25:22 <ski> well
12:25:35 <ski> `Yoneda f' is a functor, regardless of whether `f' is a functor or not
12:26:03 <bollu> oh, so "f" can be anything of kind * -> *?
12:26:04 <ski> and this can be useful because if `phi :: forall a. f a -> g a', you can use that to get from `Yoneda f a' to `Yoneda g a'
12:26:30 <ski> so, even if `f' is definitely *not* a functor (like perhaps `Endo' or `IORef'), `Yoneda' applied to it could be useful
12:26:34 <monochrom> does "cabal init" find my email from my .gitconfig?
12:26:37 <bollu> I see.
12:26:42 <bollu> can you expand on "proj"?
12:27:07 <nmdanny> question: if I have a binary tree, and I want to add a monoid annotation/context to each node, does it mean I can use a monad?
12:27:25 <bollu> so, just to be clear, the intuition for Yoneda comes from "partially applied fmap for F", the "Yoneda" typeclass of kind * -> * -> * does *not* need a Functor F?
12:27:30 <ski> bollu : we get `Yoneda f a', and we want `f a'. `Yoneda f a' is just `forall b. (a -> b) -> f b', so we pick `b' to be `a', and apply to `id :: a -> a', to get our `f a'
12:27:53 <dcoutts> monochrom: yes (as one place amongst many)
12:28:01 <ski> bollu : `Yoneda' is not a type class. also `Yoneda F' is a functor, regardless of whether `F' is or not
12:28:17 <bollu> sorry, I meant type*
12:28:25 <ski> bollu : in some sense, one might say `Yoneda F' is a free (perhaps rather cofree) functor
12:28:36 <bollu> Yoneda is a type of kind * -> * -> *, where Yoneda F is a functor?
12:28:38 <shachaf> Yoneda is cofree, coyoneda is free.
12:28:43 * ski nods
12:28:43 <shachaf> Clearly someone got something wrong.
12:28:47 <bollu> and why is a cofree functor?
12:28:55 <bollu> aren't functors the duals of themselves?
12:29:08 <shachaf> Yes, but free things are dual to cofree things.
12:29:09 <ski> probably, `Yoneda' is the right adjoint to some underlying functor
12:29:09 <bollu> so does it make sense to talk about "free" and "cofree" functors?
12:29:36 <shachaf> You have the functor U that maps Haskell endofunctors to the underlying Haskell type constructors.
12:29:38 <bollu> ski: to some forgetful functor from what to what?
12:29:43 <shachaf> And you have Coyoneda -| U -| Yoneda
12:29:44 <ski> what shachaf said
12:29:59 <bollu> (I'm so glad I understood that sentence about adjoints :) thanks for that)
12:30:40 <bollu> shachaf: uhh, concrete example? does it map Maybe -> Just or something?
12:30:48 <bollu> since Maybe is an endofunctor in Hask
12:30:51 <shachaf> This is a bit tricky to talk about in Haskell because these things are so similar.
12:30:53 <bollu> and the type constructor s Just?
12:30:54 <bollu> hmm
12:30:59 <shachaf> You have Maybe the type constructor, and Maybe the Functor.
12:31:03 <bollu> okay, then abstractify it?
12:31:08 <shachaf> The latter has more structure than the former.
12:31:38 <ski> the former is in `* -> *', the latter is in `{f :: * -> * | Functor f}', i suppose you could say
12:32:18 <bollu> ski: the latter notation means? the set of all f where f has kind * -> * and f is a Functor?
12:32:27 <ski> yes, something like that
12:32:31 <sinelaw> edwardk: In HMF, (\x -> (x :: (forall a. a -> a))) is not valid, right? Because it would require x to be instantiated to an impredicatively
12:32:32 <shachaf> The arrows in the former are functions :: forall a. f a -> g a
12:32:37 <shachaf> The arrows in the latter are natural transformations.
12:32:48 <shachaf> Very similar, so similar that people usually don't distinguish between them.
12:33:07 <ski> (hint : ask yourself whether `readIORef :: forall a. IORef a -> IO a' is a natural transformation ?)
12:33:24 <sinelaw> The paper says explicitly that eta-expansion doesn't work for polymorphic parameters, so I guess so.
12:33:39 <ski> (.. or rather, *attempt* to ask yourself that)
12:33:43 <ertesx> nmdanny: those seem orthogonal
12:34:20 <ertesx> nmdanny: data BTree v a = Pure a | Branch v (BTree v a) (BTree v a)  -- this is a monad
12:34:29 <shachaf> I'll write natural transformations as ~> and polymorphic functions with the forall.
12:34:43 <ertesx> nmdanny: data BTree v a = Pure v a | Branch (BTree v a) (BTree v a)  -- this is a monad, if v is a monoid
12:34:50 <ertesx> nmdanny: etc.
12:34:51 <ski> shachaf : well .. codensity constructs monads, while density constructs comonads .. must be the fault of the same person
12:35:08 <nmdanny> Oh I see
12:35:10 <bollu> how is stuff in the latter natural transformations?
12:35:11 <shachaf> ski: Yes, and Codensity is very similar to Yoneda.
12:35:19 <ski> yes
12:35:28 <ertesx> nmdanny: the easiest way to see whether your tree type is a monad is to ask yourself whether it's a free monad
12:35:35 * ski wasn't planning on covering `Density' and `Codensity' here
12:35:42 <bollu> heh, this entire conversation started hecause of Codensity
12:35:55 <ski> oh :)
12:35:56 <shachaf> So for Coyoneda, you have eta : forall a. a -> Coyoneda a
12:35:59 * ski had forgotten that
12:36:00 <bollu> ski: I wanted to learn what Codensity is, remember? :) Which led to Kan extension which led to Adjoint
12:36:01 <ertesx> nmdanny: however, the second one is not (obviously) a free monad, so it's not exhaustive
12:36:02 <shachaf> and eps : Coyoneda ~> Id
12:36:15 <shachaf> Hmm, no, I got the level wrong here.
12:36:15 <bollu> shachaf: um, a step back
12:36:20 <bollu> shachaf: how did we get there?
12:36:22 <nmdanny> what is a free monad?
12:36:26 <bollu> I was with you till Yoneda
12:36:42 <shachaf> For Coyoneda, you have eta : forall a. F a -> Coyoneda a, and eps : Coyoneda ~> F?
12:36:45 <bollu> nmdanny: a structure that has "just enough" to be able to write the monad laws on it, but no more structure
12:36:53 <ertesx> nmdanny: data Free f a = Pure a | Free (f (Free f a))  -- this is a "free monad" whenever f is a functor
12:36:56 <bollu> shachaf: what does Yoneda *do*?
12:36:56 <ski> bollu,shachaf : perhaps we should consider moving to #haskell-overflow or #haskell-in-depth (or maybe ##categorytheory) ?
12:37:04 <bollu> um, that exists?
12:37:14 <ertesx> nmdanny: if you can find a suitable functor 'f' to represent your tree, you have a free-monadic tree
12:37:14 <shachaf> I thought ski explained Yoneda earlier.
12:37:26 <bollu> shachaf: yes, but just abstractly
12:37:33 <bollu> where would I concretely choose to use it?
12:37:37 <bollu> and why is it a Free cofunctor?
12:37:40 <nmdanny> so basically, Free f a is a monad if f is a functor?
12:37:45 <shachaf> What's a cofunctor?
12:37:48 <monochrom> yes nmdanny
12:37:55 <ertesx> nmdanny: (nice bonus: you get almost everything for free, Functor from -XDeriveFunctor, Monad from the generic instance of Free)
12:37:56 <shachaf> I was only half paying attention but it looked pretty concrete.
12:37:56 * hackagebot pipes-parse 3.0.6 - Parsing infrastructure for the pipes ecosystem  https://hackage.haskell.org/package/pipes-parse-3.0.6 (GabrielGonzalez)
12:37:57 <ski> bollu : `CoYoneda f b' is `exists a. (f a,a -> b)'
12:38:01 <ski> "cofunctor" is nonsense
12:38:02 <shachaf> I'll go to #-overflow, though.
12:38:11 <bollu> right, Cofree functor*
12:38:18 <bollu> functor ~= co-functor right? :P
12:38:23 <ski> yes
12:38:24 <shachaf> ski: Well, presumably a cofunctor is a functor : C^op -> D^op
12:38:34 <ski> shachaf : maybe
12:38:34 <hsk3> sigh. i understood monads finally. but now monad transformers. another hurdle to get over. i'm sure i'll get over it in the coming weeks.
12:38:34 <bollu> I'm on #haskell-in-depth
12:38:34 <nmdanny> I have the following data structure
12:38:35 <hsk3> my question: will this ever end?!
12:38:38 <bollu> where are you guys?
12:38:39 <hsk3> this never-ending hurdles
12:38:42 <nmdanny> can this structure be made a monad then:
12:38:42 <nmdanny> data JoinList m a = Empty                   | Single m a                   | Append m (JoinList m a) (JoinList m a)                   deriving (Eq,Show,Read)
12:38:50 <shachaf> hsk3: If you're lucky it'll never end.
12:38:55 <ertesx> hsk3: the best way to learn monad transformers is to reinvent them
12:38:57 <bollu> hsk3: I think not :) I'm in year 1 and a half of haskell
12:39:06 <ertesx> hsk3: (i found)
12:39:19 <monochrom> hsk3: it's up to you to put an end at the point you want end.
12:39:41 <monochrom> indeed, most programmers put an end before they start Haskell altogether.
12:39:41 <nmdanny> I think my JoinList is not a free monad, since 'Empty' has no 'm' in it, so I would have to implement it manually
12:39:46 <hsk3> quite the contrast with a lang like c.. at some point you just know the whole of c. doesn't seem to be possible with haskell :S
12:40:05 <shachaf> I thought #haskell-in-depth was dead.
12:40:14 <ertesx> nmdanny: the problem is not Empty, but Single
12:40:30 <monochrom> And indeed, most managers put an end before they start any programming language altogether. They chose to hire and supervise programmers instead. Wise choice. And better pay.
12:40:34 <ski> shachaf : "That is not dead which can lie eternal sleeping."
12:40:35 <bollu> shachaf: looks like there are still people there
12:40:36 <nmdanny> how so?
12:40:58 <mfukar> bollu: maybe *they're* dead
12:41:14 <bollu> mfukar: :)
12:41:15 <monochrom> To be sure, I think I see that these days management students are required to take one 1st-year programming course too. But they pretty much all resent it, get it done, and forget it.
12:41:33 <hsk3> hmok
12:42:43 <ertesx> nmdanny: in your functor Empty corresponds to just the same thing:  data JoinListF m x = Empty | Append m x x
12:43:03 <ertesx> nmdanny: but the Free JoinListF doesn't include the annotation for Pure
12:43:03 <monochrom> I wouldn't say "at some point you know the whole of C" and "Haskell never ends" conjunctively.
12:43:20 <monochrom> it is an unfair comparison
12:44:17 <monochrom> because "at some point you know the whole of C" can only be true in the sense of "but I still don't know how to do exotic data structures in C, and certainly not monad transformers in C"
12:44:40 <monochrom> but when you say "Haskell never ends" you're including monad transformers, not excluding.
12:44:56 <monochrom> it's an unfair comparison and cognitive dissonance.
12:45:49 <montanonic> hsk3: in my experience, overcoming the hurdle between having some feel for monads, and trying to learn Monad Transformers, was a matter of using the language enough to really start to intuit why the monad laws are useful, and when/how to use the different common abstractions. And I'm still totally on that path. It's just, the more you traverse down it, the more comfortable you feel, the more easily you can write and reason about 
12:45:49 <montanonic> programs.
12:46:00 <nmdanny> i'm still too confused about the notion of free monads, perhaps I'll read about them later,
12:46:12 <nmdanny> but for now, I can implement monad manually for my joinList, yes?
12:47:31 <montanonic> nmdanny: if you can make it follow the Monad Laws, yes. Are you asking *if* your JoinList can be a monad in the first place?
12:48:27 <nmdanny> I am asking if my JoinList can be made a legal monad (aka follow the monad laws)
12:48:53 <monochrom> Could I see JoinList?
12:48:59 <nmdanny> JoinList m a = Empty | Single m a | Append m (JoinList m a) (JoinList m a)
12:49:16 <hsk3> montanonic, monochrom thanks for your comments
12:49:17 <monochrom> may I assume that m is a monad?
12:49:21 <montanonic> nmdanny: is the `m` supposed to be a monad?
12:49:22 <hsk3> i'm not filled up with optimism again
12:49:27 <hsk3> ups and downs
12:49:34 <nmdanny> no, m is a monoid
12:49:35 <ski> montanonic : wrong kind
12:49:39 <ski> er, monochrom
12:49:56 <montanonic> hsk3: yeah, I've had some really tough points with feeling like I just was out of my league with what I was coding in Haskell
12:50:35 <montanonic> hsk3: my solution was to, after getting frustrated for a while each time, working on things that I could actually manage, instead of trying to learn something that was several steps above where my current level of knowledge was at.
12:51:03 <montanonic> hsk3: after some time, my comfort and knowledge increased, and I could step up to a new level of difficulty.
12:51:16 <hsk3> yeah
12:52:57 <ertesx> nmdanny: perhaps you should review how Fix works…  Free is a very similar notion
12:53:58 <ertesx> nmdanny: data List a = Nil | Cons a (List a)  -- now replace the recursion by a "slot" that can be filled
12:54:22 <monochrom> nmdanny: I think yes, JoinList is a monad.
12:54:23 <ertesx> nmdanny: data ListF a x = Nil | Cons a x
12:54:46 <ertesx> nmdanny: now Fix (ListF a) ≃ List a
12:54:59 <ertesx> ≃ ListF a (ListF a (ListF a ...
12:55:02 <nmdanny> I don't know what's fix either
12:55:46 <ertesx> nmdanny: infinite application of a type constructor to itself:  newtype Fix f = Fix (f (Fix f))
12:55:59 <ertesx> Fix f ≃ f (f (f (f (f (f ...
12:57:19 <cocreature> Has anyone seen http://sprunge.us/LbDJ using 'cabal new-build'?
12:57:24 <nmdanny> does it mean that any recursive data structures that are monads, can be made fix too?
12:57:46 <monochrom> yes, but it's more basic than that.
12:57:55 <monochrom> any recursive data structure can be made fix.
12:58:18 <nmdanny> wait, fix and MonadFix are different things?
12:58:22 <monochrom> yes
12:58:25 <nmdanny> oh
12:58:29 <ertesx> nmdanny: review the natural number type (data Nat = Z | S Nat), now replace the recursion by a "slot" (data NatF x = Z | S x), now (Fix NatF) gives you back Nat (or a type isomorphic to it)
12:58:29 <nmdanny> so any recursive data structure can be made fix
12:58:31 <EvanR> fix. made fix
12:59:06 <ertesx> nmdanny: and if you didn't already guess it, yeah, Fix Maybe is indeed a type of natural numbers =)
12:59:21 <ertesx> (because NatF is just Maybe in disguise)
12:59:54 <nmdanny> wait, is there such a data type Nat?
13:00:34 <nmdanny> or are you just using it to explain what a fix is?
13:00:41 <ertesx> i'm using it to explain
13:00:45 <EvanR> data Nat = Z | S Nat
13:01:19 <nmdanny> Ok, so Z means 0
13:01:19 <EvanR> now it exists ;)
13:01:36 <ertesx> @let data Nat = Z | S Nat  deriving (Eq, Ord, Show)
13:01:37 <lambdabot>  .L.hs:193:1:
13:01:37 <lambdabot>      Multiple declarations of ‘Nat’
13:01:37 <lambdabot>      Declared at: .L.hs:155:1
13:01:41 <ertesx> hehe
13:01:43 <ertesx> > Z
13:01:45 <lambdabot>      No instance for (Show Nat)
13:01:45 <lambdabot>        arising from a use of ‘show_M84983801671308403719131’
13:01:45 <lambdabot>      In the expression:
13:01:49 <ertesx> @undef
13:01:49 <lambdabot> Undefined.
13:01:52 <ertesx> @let data Nat = Z | S Nat  deriving (Eq, Ord, Show)
13:01:53 <lambdabot>  Defined.
13:02:00 <ertesx> > Z
13:02:02 <lambdabot>  Z
13:02:06 <EvanR> deriving Num ?
13:02:17 <ertesx> EvanR: i'd love that to work…
13:02:20 <nmdanny> lambdabot can run haskell in irc?
13:02:48 <hpc> sort of
13:02:52 <hpc> it evaluates expressions
13:02:58 <ertesx> nmdanny: a safe subset of haskell
13:02:59 <hpc> and then shows them
13:03:06 <ertesx> nmdanny: it won't perform IO though
13:03:11 <hpc> and the imports are carefully controlled
13:03:18 <hpc> > readFile "/etc/passwd"
13:03:19 <EvanR> then how can we see the output smarty pants
13:03:20 <lambdabot>  <IO [Char]>
13:03:38 <ertesx> (unfortunately nobody seemed to have come across my april fools joke)
13:03:43 <nmdanny> > print "hello there"
13:03:44 <lambdabot>  <IO ()>
13:03:56 <hpc> ertesx: oh?
13:04:03 <nmdanny> > show "hello there"
13:04:05 <lambdabot>  "\"hello there\""
13:04:23 <nmdanny> > show $ take 50 [1..]
13:04:25 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:04:27 <ertesx> on april 1st i replaced all Prelude IO actions with seemingly impure functions
13:04:35 <hpc> ah
13:04:38 <ertesx> getLine :: String, putStrLn :: String -> ()
13:04:39 <ertesx> etc.
13:05:04 <EvanR> glad i didnt update on april 1
13:05:19 <ertesx> and i even made it look like they did actually perform the IO on the server with fitting exceptions
13:06:37 <ertesx> nmdanny: you don't need 'show'
13:06:49 <nmdanny> > take 50 [1..]
13:06:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:07:06 <hpc> oh, i remember that now
13:07:06 <ertesx> EvanR: i just @let the necessary stuff, including @let import Prelude hiding (...) =)
13:07:35 <nmdanny> > concat $ take 50 $ repeat "spam"
13:07:36 <lambdabot>  "spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspa...
13:07:50 <ertesx> > let 2 + 2 = 5 in 2 + 2
13:07:51 <lambdabot>  5
13:08:02 <EvanR> > fix ("spam" ++)
13:08:04 <lambdabot>  "spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspa...
13:08:11 <ertesx> > fix error
13:08:13 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:08:15 <nmdanny> fix (1:)
13:08:22 <nmdanny> > fix (1 : )
13:08:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:08:26 <hpc> @let spam = fix ("spam" ++)
13:08:28 <lambdabot>  Defined.
13:08:34 <nmdanny> > spam
13:08:35 <lambdabot>  "spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspa...
13:08:46 <nmdanny> > spam ++ spam ++ spam
13:08:47 <lambdabot>  "spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspa...
13:08:50 <ertesx> is the cake recipe still defined?
13:08:53 <ertesx> > cake
13:08:54 <lambdabot>      Not in scope: ‘cake’
13:08:54 <lambdabot>      Perhaps you meant one of these:
13:08:54 <lambdabot>        ‘take’ (imported from Data.List),
13:09:02 <ertesx> too bad
13:09:05 <hpc> cake nooooooo
13:09:08 <EvanR> somebody ate it
13:09:14 <hpc> RIP TOOTOOTASCIICAT
13:09:21 <nmdanny> > data cake = Tasty | VeryTasty
13:09:22 <ertesx> hehe
13:09:23 <lambdabot>  <hint>:1:1: parse error on input ‘data’
13:09:31 <ertesx> nmdanny: if you want to define stuff, you need @let
13:09:41 <nmdanny> @let data cake = TastyCake | VeryTastyCake
13:09:42 <lambdabot>  Parse failed: Illegal data/newtype declaration
13:09:45 <nmdanny> @let cake = TastyCake | VeryTastyCake
13:09:46 <lambdabot>  Parse failed: Parse error: |
13:09:47 <EvanR> data cake = Foo | Bar is not an expression
13:10:12 <EvanR> even if capitalized
13:10:36 <nmdanny> @let data Cake = TastyCake | VeryTastyCake | MeltInYourTongueCake deriving (Eq,Show,Read,Generic)
13:10:37 <lambdabot>  .L.hs:154:37: Not in scope: type constructor or class ‘Generic’
13:10:41 <nmdanny> @let data Cake = TastyCake | VeryTastyCake | MeltInYourTongueCake deriving (Eq,Show,Read)
13:10:42 <lambdabot>  Defined.
13:11:16 <ertesx> @let import GHC.Generics (Generic)
13:11:17 <lambdabot>  Defined.
13:11:21 <hpc> melt IN your tongue?
13:11:26 <hpc> http://vignette1.wikia.nocookie.net/unnaturalworld/images/d/dc/Tongue.jpg/revision/latest?cb=20140629192145
13:11:28 <ertesx> @let data X = X deriving (Generic)
13:11:30 <lambdabot>  Defined.
13:11:45 <nmdanny> @let class IsReal a where isReal :: a -> Boolean
13:11:45 <int-e> hpc: maybe it's "meltin' your tongue"
13:11:47 <lambdabot>  .L.hs:162:24: Not in scope: type constructor or class ‘Boolean’
13:11:51 <nmdanny> @let class IsReal a where isReal :: a -> Bool
13:11:53 <lambdabot>  Defined.
13:11:55 <ertesx> nmdanny: if you want to experiment further, you can /query lambdabot 
13:12:09 <nmdanny> what does it do?
13:12:25 <ertesx> nmdanny: i mean, it responds to private messages, too
13:12:28 <nmdanny> @let instance IsReal Cake where isReal _ = False
13:12:30 <lambdabot>  Defined.
13:12:36 <nmdanny> > isReal TastyCake
13:12:37 <lambdabot>  False
13:12:37 <ertesx> nmdanny: so you don't cause a traffic accident here =)
13:13:41 <nmdanny> @let isALie x = not . isReal
13:13:42 <lambdabot>  Defined.
13:13:47 <nmdanny> @let isALie = not . isReal
13:13:48 <lambdabot>  .L.hs:170:1:
13:13:49 <lambdabot>      Multiple declarations of ‘isALie’
13:13:49 <lambdabot>      Declared at: .L.hs:166:1
13:14:06 <nmdanny> @undef isALie
13:14:07 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
13:14:07 <dolio> Is this necessary?
13:14:20 <nmdanny> very
13:14:31 <dolio> Wrong answer.
13:15:15 <shachaf> Yes. Please stop with the bot spam, or take it to another channel or /msg.
13:15:21 <nmdanny> Ok :c
13:16:10 <nmdanny> Anyway, so about fix..  what is the point of using fix as opposed to simply defining a recursive data structure?
13:18:05 <Cale> nmdanny: There's not a whole lot of point apart from the ability to avoid naming something, or to make explicit the way in which recursion is involved.
13:18:54 <ertesx> nmdanny: for you it's primarily interesting to see how one could define a recursive type in terms of a non-recursive type constructor
13:19:15 <ertesx> nmdanny: because Free is a very similar notion
13:19:28 <Cale> Yeah, sometimes it helps to expose the structure of things -- sometimes the function you're taking the fixed point of is something which is itself important
13:20:06 <Cale> Other times, it's just a handy way to write a loop
13:20:22 <ertesx> nmdanny: compare:
13:20:22 <ertesx> newtype Fix f    =          Fix  (f (Fix f))
13:20:22 <ertesx> data    Free f a = Pure a | Free (f (Free f a))
13:20:39 <Cale> e.g. you'll often see something like  let loop = do ... ; ... loop ... in loop
13:21:02 <EvanR> fix vs Fix
13:21:03 <Cale> which could also be written  fix $ \loop -> do ... ; ... loop ...
13:21:13 <shachaf> I thought people were talking about type-level Fix.
13:21:25 <Cale> Well, nmdanny used lowercase f
13:21:26 <nmdanny> I'm confused, but anyway, won't the repeat and iterate functions suffice?
13:21:37 <nmdanny> :i fix
13:21:42 <nmdanny> :t fix
13:21:43 <lambdabot> (a -> a) -> a
13:21:50 <nmdanny> :t iterate
13:21:51 <lambdabot> (a -> a) -> a -> [a]
13:21:53 <ertesx> i think nmdanny really means Fix, because that's what we were talking about earlier
13:21:53 <dolio> Cale: Actually, someone pointed out a nice way to use fix to write inline loops a while back.
13:22:00 <ertesx> rather than 'fix'
13:22:08 <nmdanny> :t repeat
13:22:10 <lambdabot> a -> [a]
13:22:16 <Cale> dolio: was it the same as the way I just gave? ;)
13:22:21 <ertesx> dolio: fix $ \again -> putStrLn "blah" >> again
13:22:24 <nmdanny> :t (concat . iterate)
13:22:25 <lambdabot> Foldable ((->) a) => (a -> a) -> [a]
13:22:26 <EvanR> fix is not just about repeating the same thing
13:22:31 <dolio> Oh, yeah.
13:22:38 <Cale> nmdanny: Maybe you also want an argument to the loop
13:22:48 <irssi_> :t add
13:22:49 <lambdabot>     Not in scope: ‘add’
13:22:49 <lambdabot>     Perhaps you meant one of these:
13:22:49 <lambdabot>       ‘and’ (imported from Data.List), ‘odd’ (imported from Prelude)
13:22:53 <dolio> Cale: You missed the part of the trick where you can have loop variables, though. :)
13:22:57 <bollu> isn't fix just a way to "extract" recursion from any recursive function?
13:23:03 <dolio> fix ?? x0 ?? y0 ?? z0 $ \next x y z -> ...
13:23:11 <ertesx> dolio: fix $ \again x -> print x >> again (x + 1)
13:23:25 <EvanR> nmdanny: even without extra variables, fix can be used to escape out of an infinite loop
13:23:28 <Cale> dolio: yeah, where ?? is some flippy function application thing
13:23:30 <EvanR> by checking whats going on
13:23:39 <Cale> (normally those arguments would go after the function)
13:23:41 <dolio> It's flip, as an infix operator, yeah.
13:23:46 <EvanR> oh nice
13:23:48 <Cale> yeah
13:23:55 <nmdanny> why doesn't haskell come with a built in infix flip operator?
13:24:15 <bollu> it does, &
13:24:19 <bollu> :t (&)
13:24:20 <lambdabot> a -> (a -> b) -> b
13:24:26 <Cale> :t flip
13:24:27 <lambdabot> (a -> b -> c) -> b -> a -> c
13:24:32 <dolio> :t (??)
13:24:34 <lambdabot> Functor f => f (a -> b) -> a -> f b
13:24:37 <Cale> heh
13:24:42 <ertesx> also i think (&) is a lens combinator, isn't it?
13:24:51 <nmdanny> > take 5 $ repeat [1..]
13:24:53 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:24:55 <ertesx> (as in: from the lens library)
13:24:56 <nmdanny> > repeat [1..] & take 5
13:24:58 <dolio> (&) got moved to base. (??) didn't.
13:24:58 <Cale> bollu: (&) is flip ($)
13:24:58 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:25:03 <ertesx> ah
13:25:26 <bollu> Cale: you wanted?
13:25:45 <Cale> bollu: The (??) we're talking about is really just flip itself
13:25:47 <nmdanny> is there an operator for normal function application?
13:25:53 <Cale> nmdanny: ($)
13:25:57 <ertesx> nmdanny: or id
13:25:59 <nmdanny> not that one
13:26:08 <nmdanny> with the normal application precedence
13:26:13 <nmdanny> like when you have space
13:26:15 <EvanR> ?? = (<&>) ?
13:26:16 <Cale> Normal function application is not an infix operator
13:26:16 <lambdabot> Plugin `compose' failed with: Unknown command: ""
13:26:17 <ertesx> nmdanny: nope
13:26:25 <Cale> It binds more tightly than any infix operator could
13:26:39 <nmdanny> so it's impossible to define an infix operator for normal function application?
13:26:40 <Cale> I really wish that ($) had the same associativity as normal function application though
13:26:44 <Cale> nmdanny: right.
13:26:49 <bollu> ahh :) I see
13:26:51 <irssi_> :t +
13:26:52 <lambdabot> parse error on input ‘+’
13:26:56 <nmdanny> :t (+)
13:26:57 <lambdabot> Num a => a -> a -> a
13:26:59 <dolio> EvanR: No. f ?? x = ($x) <$> f
13:27:10 <Cale> nmdanny: Which is a good thing for sanity's sake -- you know that any infix operator has *got* to bind more weakly than a function application
13:27:18 <EvanR> is the Functor necessary?
13:27:26 <Cale> Even if you haven't looked up its exact precedence leve
13:27:27 <Cale> l
13:27:28 <nmdanny> or else.. havoc would ensue?
13:27:37 <dolio> It's a 'generalization' of flip.
13:27:39 <ertesx> nmdanny: if you want to get a taste of that havoc, try to read agda code
13:27:41 <Cale> Well, it would make things harder for humans to parse
13:27:58 <dolio> Kind of like (.) = fmap is a generalization of composition.
13:28:08 <EvanR> (??) = flip works
13:28:13 <ertesx> nmdanny: agda does allow you to use some pretty crazy fixity
13:28:22 <Cale> Because it's hard to keep all the precedence levels clear in your head all the time -- the fact that whitespace function application has got to be tighter than anything else just makes it a lot easier in that regard.
13:28:23 <dolio> For my example, you just need flip.
13:28:34 <nmdanny> :t (->)
13:28:36 <lambdabot> parse error on input ‘->’
13:28:39 <nmdanny> :t ->
13:28:41 <lambdabot> parse error on input ‘->’
13:28:44 <nmdanny> :t ((->))
13:28:46 <lambdabot> parse error on input ‘->’
13:28:48 <ertesx> nmdanny: (->) is not a value
13:28:51 <Cale> :k (->)
13:28:53 <lambdabot> * -> * -> *
13:28:57 <Cale> ^^ it is a type constructor
13:28:59 <nmdanny> :i (->)
13:29:07 <Cale> Lambdabot doesn't have :i
13:29:52 <nmdanny> remind me what a * is?
13:29:54 <nmdanny> a kind?
13:30:02 <ertesx> nmdanny: it's the kind of types
13:30:09 <ertesx> concrete types that is
13:30:27 <ertesx> if you think that its name is horrible, i agree
13:30:29 <nmdanny> whats the kind for non concrete types?
13:30:33 <nmdanny> :k Functor
13:30:35 <lambdabot> (* -> *) -> Constraint
13:30:45 <ertesx> well, any kind that isn't * =)
13:30:48 <ertesx> :k Maybe
13:30:49 <lambdabot> * -> *
13:30:53 <ertesx> that's not a concrete type
13:30:59 <nmdanny> I see, so (* -> *) is a kind, that is not concrete
13:31:23 <ertesx> the kind is concrete, but it is a kind of type constructors
13:31:40 <ertesx> type-level functions from a concrete type to a concrete type, if you will
13:32:27 <ertesx> in other words, it is the concrete kind of things that aren't concrete types, like Maybe or Either Int
13:32:41 <nmdanny>  o..k
13:33:00 <nmdanny> anyway, so if there's (->), can one define a different operator or function for dealing with kinds?
13:33:11 <nmdanny> like, a different way to define functions for example?
13:33:21 <ertesx> well, you can alias (->) like any other type
13:33:27 <ertesx> type Array = (->)
13:33:39 <ertesx> length :: Array [a] Int
13:34:10 <nmdanny> @let type (<->) = (->)
13:34:12 <lambdabot>  Defined.
13:34:30 <nmdanny> @let id :: a <-> a
13:34:31 <lambdabot>  .L.hs:169:1:
13:34:31 <lambdabot>      The type signature for ‘id’ lacks an accompanying binding
13:34:31 <lambdabot>        (The type signature must be given where ‘id’ is declared)
13:34:40 <nmdanny> @let id :: a <-> a ; id a = a
13:34:40 <DwarfSock> how can you make lamba expressions pointfree? i have this: rShow = ReaderT $ \r -> Identity (show r), and I'm tasked with writing it in a pointfree style 
13:34:42 <lambdabot>  Defined.
13:34:47 <nmdanny> :t id
13:34:48 <lambdabot>     Ambiguous occurrence ‘id’
13:34:48 <lambdabot>     It could refer to either ‘L.id’,
13:34:48 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:173:1
13:35:04 <nmdanny> cool I did not know you can define your own alias for (->)
13:35:05 <ertesx> DwarfSock: review the definition of (.)
13:35:29 <ertesx> DwarfSock: and remind yourself that "=" means "equals"
13:35:35 <nmdanny> is there more magic that can be done with (->) ?
13:36:02 <ertesx> nmdanny: a lot…  virtually all of haskell is based on the magic you can do with (->) =)
13:36:30 <ertesx> (it's a joke, but with a lot of truth to it)
13:36:34 <nmdanny> I mean, can I define a function, that is used to define functions?
13:36:51 <ertesx> nmdanny: like a higher-order function?
13:36:54 <nmdanny> no not that
13:37:01 <nmdanny> I mean, like how (->) is used in type annotations
13:37:15 <ertesx> if you mean whether you can define your own function type: no
13:37:17 <nmdanny> so, define something which uses (->), and that thing can be used in type annotations
13:37:26 <ertesx> in that sense (->) is primitive (a.k.a. magic)
13:37:51 <nmdanny> I see
13:37:57 <ertesx> if you think of (->) as just another type constructor, you can do a lot with it
13:38:02 <ertesx> what you can't do is reinvent it
13:38:29 <nmdanny> you mean, if I do    func :: a -> b
13:38:33 <nmdanny> then, func is a type constructor for b
13:38:45 <nmdanny> that is parameterized over a?
13:38:50 <ertesx> you want type-level functions?
13:39:03 <ertesx> functions that give you types from types?
13:39:14 <ertesx> or do you want types from values?
13:39:15 <nmdanny> what's a type level function?
13:39:32 <ertesx> anything of kind * -> * you could call a type-level function
13:39:41 <nmdanny> :t Maybe
13:39:42 <lambdabot>     Not in scope: data constructor ‘Maybe’
13:39:42 <lambdabot>     Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
13:39:48 <nmdanny> :k Just
13:39:49 <lambdabot> k -> Maybe k
13:39:51 <nmdanny> :t Just
13:39:52 <lambdabot> a -> Maybe a
13:40:36 <ertesx> haskell with appropriate extensions is equivalent in expressive power to a dependently typed language, so you can take this very far
13:40:42 <ertesx> up to computing types from values
13:40:46 <Cale> ehhhhh
13:40:49 <nmdanny> :k []
13:40:50 <lambdabot> * -> *
13:40:57 <ertesx> but…
13:41:00 <Cale> Yeah, I don't know if I'd say that it's really the same
13:41:13 <ertesx> i strongly recommend that you don't go there just yet =)
13:41:16 <nmdanny> so a type level function, is a function which takes a type, returns a type?
13:41:39 <ertesx> Cale: http://lpaste.net/109388
13:42:12 <Cale> You can sort of kind of emulate the techniques which get applied in dependently typed languages, but there are pretty serious limitations on it. I'm aware of what you can do with singletons
13:42:14 <ertesx> nmdanny: in a way
13:43:03 <nmdanny> ok, another thing,
13:43:09 <ertesx> nmdanny: haskell has a strict boundary between values and types…  in particular the (->) type is not the same as the (->) kind
13:43:24 <nmdanny> :t (->)
13:43:25 <lambdabot> parse error on input ‘->’
13:43:35 <ertesx> nmdanny: type constructors behave in many ways like type-level functions, but in many ways they don't
13:43:49 <nmdanny> does haskell have real type level functions then?
13:44:17 <ertesx> you can push it to emulate them
13:44:33 <nmdanny> oh, so with a bunch of extensions I assume?
13:44:41 <ertesx> yeah, but it's not pretty
13:44:46 <nmdanny> ok
13:44:52 <nmdanny> anyway, so I'm wondering about arrows
13:45:05 <nmdanny> arrows have something to do with (->) if I'm not mistaken, right?
13:45:15 <Cale> (->) is an instance of the Arrow type class
13:45:23 <Cale> If you're talking about that type class
13:45:53 <Cale> (a somewhat trivial instance)
13:45:59 <ertesx> have fun and a nice weekend =)
13:46:23 <nmdanny> Right, so that means that arrows can be used to perform function application/composition and whatnot, correct?
13:47:37 <Cale> not application
13:47:42 <Cale> but composition, yes
13:48:23 <Cale> Well, there's an ArrowApply type class for instances of Arrow which have something roughly analogous to application, but every such thing is really a monad, so probably you wouldn't want to be using Arrow in that case.
13:48:34 <EvanR> i wrote up a demo of the ?? trick http://lpaste.net/162631
13:48:42 <bollu> Cale: application needs a closed cartesian category right?
13:49:38 <Cale> bollu: yeah, you can look at it like that, though Arrow + ArrowApply is something more particular than CCC
13:49:52 <nmdanny> what are the practical uses of arrows in every day code? So far i've seen them used as a shortcut when mapping tuples
13:51:54 <Cale> nmdanny: The problem is that Arrow shoots itself in the foot as an abstraction to some extent -- most of the niche applications it would fit well are harmed by either the existence of 'arr', or the lack of a bunch of explicit operations for things which you can sort of get via 'arr', but which you'd rather not, because functions are black boxes
13:52:10 <Cale> Well, perhaps some context would help
13:52:48 <Cale> One of the things which Arrow has as an advantage over, say, Monad as an abstract way of gluing together computations
13:53:16 <montanonic> What's little 'o' do in GHC compilation? I know -O is stage one opts, and -O2 is maximum opts, but what's -o ?
13:53:28 <mauke> output file
13:53:28 <Cale> is that whereas with Monad, the right argument to (>>=) is a function, and so you can't really know anything about which function it is before running the action on the left
13:53:33 <montanonic> mauke: ah, thank you
13:53:42 <Cale> both of the arguments to (>>>) are of a type you specify
13:54:07 <Cale> So there's some hope that f >>> g could be simplified prior to execution.
13:54:22 <Cale> Maybe depending on what computation g is, f might not have to do some of its work
13:55:04 <nmdanny> what do you mean? short circuiting?
13:55:14 <Cale> But then along comes arr :: (Arrow (~>)) => (b -> c) -> (b ~> c)  (to use the old notation, back when we were allowed to use infix type variables)
13:55:48 <Cale> I mean, it's possible that g takes a pair as its input, and happens to ignore the left component of the pair, say
13:56:08 <Cale> and so maybe f can skip all the work which would have computed that left component
13:56:20 <nmdanny> oh I see, thats what happens when you use 'first' or 'second', right?
13:56:42 <Cale> Yeah, g = second would be a reasonable example
13:57:28 <Cale> Just to be clear, this wouldn't happen automatically, but there's some hope that by doing analysis on the value we're constructing, we could determine this prior to doing whatever we normally would do to run our computation.
13:57:41 <EvanR> did you discover all this when doing arrow FRP for that game?
13:57:44 <Cale> yeah
13:58:01 * EvanR still would like to see the details of that thing
13:58:02 <Cale> Whereas with Monad, all hope of this is lost, because the right argument to (>>=) is a black box to us
13:59:00 <Cale> EvanR: It was very very complicated, and while we did get some benefits from it, they were harmed significantly by the time spent doing that runtime analysis
13:59:05 <Cale> But still :)
13:59:24 <Cale> anyway, the point I was trying to make
13:59:40 <EvanR> one data point for "stop thinking so hard and just do something"
13:59:57 <Cale> This is all good, but as soon as you have an arr in between two things being composed, you're again back to not being able to analyse
14:00:12 <Cale> f >>> arr (\(x,y) -> (y,x)) >>> g
14:00:47 <Cale> Even though it's really simple and structural here, that lambda is a black box to us at runtime, and totally thwarts analysis
14:00:48 <EvanR> you can just use myArr right
14:01:01 <Cale> What we did was to add a bunch of methods to the Arrow class
14:01:03 <EvanR> or no, it cant be a lambda at all
14:01:03 <Bor0> not a haskell question but it could relate :) given the definition b is minimal if for all x, x R b -> x = b. I don't understand how this defines the minimal element. shouldn't the definition be something like this: for all p, q, b R p and q R p -> b = q?
14:01:14 <Cale> corresponding to the rest of the definition of a symmetric monoidal category
14:02:13 <EvanR> Cale: did you ever have issues with ordering of "arguments" to each component, like did you have to swap things around, like braiding
14:02:39 <Cale> i.e. we added swap :: (a,b) ~> (b,a), and assocL :: (a,(b,c)) ~> ((a,b),c), assocR :: ((a,b),c) ~> (a,(b,c)), as well as things which added and removed units, like  unitL :: a ~> ((),a), and retractL :: ((),a) ~> a
14:03:03 <Cale> and then we made a preprocessor which rendered the proc/do notation in terms of that
14:03:16 <Cale> Our game ran 6 times faster :D
14:03:53 <EvanR> did you have to carefully plan and rewrite swap networks
14:03:57 <simpson> Cale: Is there a publically-available typeclass (ArrowSym?) which people can use, or would somebody have to write it up?
14:04:18 <Cale> EvanR: not just swaps, but mostly reassociations
14:04:27 <EvanR> geez
14:04:47 <Cale> EvanR: and yeah, we did eventually get to rewriting these heterogeneously typed graphs
14:04:52 <EvanR> well i wrote a quasiquoter which did that based on input like x y z -> y x y
14:05:12 <Cale> But even before that, it immediately made things a lot faster
14:05:47 <Cale> (basically because we could avoid forming tuples altogether)
14:06:04 <EvanR> i correctly determined that in a non trivial program you may have a non trivial swap networking and it would be hellish to go back and modify it if you changed something on either side
14:06:14 <EvanR> yeah in my experiment i didnt use tuple
14:07:02 <EvanR> it used hetero list and so could not be an Arrow or anything similar
14:07:02 <Cale> simpson: There have been some things like http://www.megacz.com/berkeley/garrows/ which is pretty much an exact replica of what we ended up with
14:07:15 <Cale> (though with a somewhat ugly naming scheme :P)
14:08:53 <montanonic> EvanR: what is "swap networking"?
14:09:50 <hsk3> When will GHC 8 be released on https://www.haskell.org/ghc/ ?
14:10:03 <tobiasBora> Hello,
14:10:56 <EvanR> montanonic: https://graphicallinearalgebra.net/2015/05/06/crema-di-mascarpone-rules-of-the-game-part-2-and-diagrammatic-reasoning/ scroll down to see a diagram split into several parts, between parts there is a swap. in general if your components didnt agree before hand what order things are in, it could get ugly
14:10:57 <Cale> montanonic: He's referring to working out all the swaps of adjacent things to go from one permutation of a bunch of arguments to another
14:11:13 <EvanR> in my case it wasnt just permutations, but also the copy and merging
14:11:14 <hsk3> https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1
14:11:20 <hsk3> it says mid-april 2016 but that's long gone now
14:11:21 <Cale> We didn't actually try very hard to minimise the number of swaps and associations
14:11:36 <Cale> (but we did try a bit)
14:12:42 <Cale> I would be very interested if someone had an algorithm for quickly finding minimal paths through associahedra :)
14:12:58 <EvanR> well
14:13:24 <Cale> (many bonus points if you also deal with commuting things)
14:14:04 <EvanR> my algorithm simplifies the graphical linear algebra version of these categories
14:14:10 <EvanR> not the arrow version
14:14:31 <EvanR> but it gets what i would have gotten on paper and thinking hard
14:15:34 <Cale> hsk3: There are still some serious bugs to work through as I understand it.
14:16:16 <Cale> https://ghc.haskell.org/trac/ghc/report/1
14:16:55 <montanonic> EvanR: okay, I see. It's a kind of way of organizing an interacting system of components and their inputs/outputs. The twist is a swap. 
14:17:16 <montanonic> by "I see", I mean, "I can somewhat understand the abstraction"
14:17:17 <EvanR> yes
14:17:31 <EvanR> thats an awesome blog btw
14:17:57 <montanonic> EvanR: yeah, I bookmarked it. Very good post. Sparked my curiosity.
14:18:39 <EvanR> when the crack egg goes from egg to 2 egg whites, not 1 and not 3, its like linear logic, i guess
14:19:20 <EvanR> without a copy operator, you have to use exactly 2 egg whites after cracking an egg, either by explicitly throwing them away or using them somewhere that expects it
14:20:29 <EvanR> programs made entirely of those components have a chance to be compiled into microcontroller code since they are so static, and they cant loop
14:20:41 <EvanR> no need for memory management
14:21:05 <EvanR> (if you make illegal certain types of loopbacks)
14:21:17 <saurabhnanda> can any Haskell IDE give me type information for a symbol if the file is "partially compiled"? What about Emacs? Context: I'm writing a function and there's a lot of non-working code in the same file, but I need to know the type of a symbol under my cursor.
14:22:03 <montanonic> EvanR: is the Arrow abstraction the thing that corresponds to those components?
14:22:14 <EvanR> its similar
14:22:37 <EvanR> linear algebra has any number of "ports" but arrow has 2
14:22:44 <montanonic> I see, okay.
14:22:46 <EvanR> and you have to do the reassoc thing
14:23:30 <EvanR> linear algebra works because dependent types ;)
14:25:14 <EvanR> also Arrow doesnt have swap
14:26:32 <tobiasBora> I would like to implement a system with an array where I randomly modify a few cells in it (For example 10 cells on an array of 100 cells). Then I would like to do it again and again, in order to find an "optimal array" (I would like to implement some evolutionist algorithms). What is the better way to proceed in haskell to do so ?
14:27:06 <EvanR> theres IOVector and STVector in Data.Vector
14:28:18 <bollu> what can I do to better understand Kan extensions?
14:28:31 <bollu> I was explained the idea by shachaf and ski
14:28:38 <bollu> but I want some practise with it
14:28:50 <bollu> Cale, edwardk: any references? exerciese? books?
14:29:11 <tobiasBora> EvanR: You talk to me or not ? If yes IOVector are mutable, and I wonder if an immutable version could give me some benefits
14:30:31 <EvanR> i assumed you wanted fast updates
14:30:56 <EvanR> you could also use IntMap for immutable updates
14:31:20 <EvanR> but you said array so, Vector
14:31:41 <lethjakman-l> Are there any especially good articles on cleaning up type signatures?
14:31:48 <lethjakman-l> Or just keeping them clean in general?
14:33:20 <tobiasBora> EvanR: In Data.Vector I can read that update is update
14:33:28 <tobiasBora> *is O(m+n)
14:33:42 <EvanR> there are mutable and immutable updates in vector
14:33:49 <EvanR> immutable update of vector is not efficient
14:34:24 <maerwald> does that not depend on optimization?
14:35:00 <EvanR> it does a copy
14:36:10 <tobiasBora> EvanR: It doesn't act like "if the index asked is 3 then return true, else check in the Vector XXX" ?
14:36:29 <lyxia> no
14:36:30 <EvanR> no
14:36:55 <EvanR> you can make something like that but, you might as well use IntMap
14:37:40 <tobiasBora> And if I want to do so (IntMap are seen like trees right ?), what should I do ?
14:38:16 <EvanR> import Data.IntMap
14:40:33 <ElMoloko> Ugh does GHCi still not work on ARM
14:41:21 <tobiasBora> ElMoloko: I manage to make it work on my android running debian chroot, so I think it depends on the version you are running
14:41:32 <ElMoloko> Whoa
14:41:37 <ElMoloko> what version of debian?
14:41:42 <tobiasBora> unstable
14:41:45 <ElMoloko> I'm trying to install it on an rpi
14:41:45 <lethjakman-l> I thought I saw articles about it running on raspberry pi. 
14:42:00 <ElMoloko> ahh I'll try enabling the unstable repos for jessie
14:42:49 <tobiasBora> For rpi I tried, but didn't success because I didn't try the unstable repo. If it doesn't work I may try to use on my rpi "debian" instead of "raspbian"
14:43:53 <tobiasBora> lethjakman-l: Does they compile it by hand ? (I saw something like one week to compile if you don't use qemu)
14:44:13 <tobiasBora> EvanR: I will use Data.IntMap, thank you.
14:44:35 <ElMoloko> I saw the compiling manually thing
14:44:38 <ElMoloko> don't have the time for that
14:44:55 <ElMoloko> I guess cross-compiling isn't much of an option either
14:45:26 <lethjakman-l> Ahhh, you have to have 7.8
14:45:30 <tobiasBora> qemu isn't really cross compiling, but indeed it's not the simplest option. It's just faster to run since it uses the desktop memory/cpu
14:45:32 <ElMoloko> :(
14:45:51 <ElMoloko> Right, but is there no cross compiling option?
14:45:53 <tobiasBora> ElMoloko: It doesn't work with unstable ?
14:45:53 <lethjakman-l> Also, it's not really worth it to compile on a pi for sure. 
14:46:02 <ElMoloko> QEMU will still be realllly slow
14:46:15 <tobiasBora> Never tried QEMU so maybe.
14:46:35 <tobiasBora> And I'm not an expert on cross compilation, sorry for that...
14:46:49 <tobiasBora> (but I think I saw some tutorials on the internet about rpi)
14:46:52 <ElMoloko> Well I'll let you all know if I figure something out :)
14:47:00 <tobiasBora> ElMoloko: Thank you ;)
14:47:41 <tobiasBora> ElMoloko: And when I'll get more time I will try also.
14:51:14 <tobiasBora> And for information I'm running with Linux Deploy Debian unstable, and ghci version 7.10.3
14:52:12 <sze421> ElMoloko: ghc on raspberrypi https://www.reddit.com/r/haskell/comments/4hzsgv/ghc_stack_arm_is_a_flaming_car_crash_but_read/
14:55:19 <FROGGER> hi
14:59:36 <ElMoloko> @sze421 thanks! wow, 2 days ago.  Trying out the 7.10.3 bindist that guy linked
14:59:36 <lambdabot> Unknown command, try @list
14:59:55 <ElMoloko> sze421 thanks! wow, 2 days ago.  Trying out the 7.10.3 bindist that guy linked
15:02:08 <sze421> ElMoloko: you are welcome. Kind of strange, I am taking a look at haskell first time in a long time reading a bunch of stuff, first time in this room and actually able to help :)
15:03:03 * ski kindly notes that it is called a "channel" :)
15:04:15 * ElMoloko wonders what the haskell chatroom on AIM is like
15:04:16 <EvanR> hashtag haskell
15:06:37 <tobiasBora> sze421: Thank you ! However there seems to be lot's of compile job to do at the end. I may try to use real debian.
15:07:51 <ElMoloko> That's if you want stack and cabal, no?
15:08:54 <sze421> I only saw that post, it's not as if I did the work ;)
15:09:02 <ElMoloko> I mean, of course we do.  But right now my white whale is getting GHCi :D then maybe I'll leave this compiling overnight....for a week and try to get cabal and stack built
15:13:15 <ElMoloko> holy crap, this is ghc 8.1.  seriously doubt this will work
15:19:11 <tommd> I'm excited by the stated focus on performance in GHC.  I have code with compilation times slowing by 2-6x since 6.12.x
15:19:33 <tommd> And those were random samples.  I'm curious what the worst regression looks like.
15:29:55 <ElMoloko> sze421: That link worked perfectly!  The first commenter in that reddit thread linked nightly binary builds; the latest was for 8.1, and it's working perfectly, GHCi included!
15:42:04 <sze421> ElMoloko: interactive development on an raspberry etc. sounds interesting
15:44:34 <ElMoloko> now I have GHCi on a device with GPIO pins :)
15:47:20 <ElMoloko> oooh and I have a quadcopter body with motors, props and motor controllers ready to be interfaced with the RPi
15:48:20 <ElMoloko> and an SSH connection, and to the RPi which I am running GHCi in
15:48:57 <ElMoloko> this will end in tears
15:49:06 <ElMoloko> both types of tears
15:50:29 <tpsinnem> good luck :)
15:50:30 <sze421> maybe implement emergency shutdown for the quadcopter first or get a cage for it
15:51:10 <ElMoloko> Hmm, I think I'll remove the props for now :)
15:51:24 <ElMoloko> https://hackage.haskell.org/package/HPi-0.4.0/docs/System-RaspberryPi-GPIO.html
15:53:09 <ElMoloko> will need to make something to handle the pwm stuff
15:58:21 <tobiasBora> Great !
15:58:25 <tobiasBora> ElMoloko: pwm ?
15:58:46 <tobiasBora> And does the build include stack or not ?
16:00:07 <tobiasBora> And since it's nighty build, why doesn't they implement ghci 10 ?
16:00:46 <tobiasBora> stupid
16:00:58 <tobiasBora> 8.3 > 7.10...
16:03:25 <newsham> even for large values of 7.10?
16:17:06 <tobiasBora> newsham: Well, if you put enough "+0.1" you may manage to disturb enough the system to loop on integ...
16:17:10 <tobiasBora> er
16:18:02 * hackagebot liquidhaskell-cabal 0.1.1.0 - Liquid Haskell integration for Cabal and stack  https://hackage.haskell.org/package/liquidhaskell-cabal-0.1.1.0 (MichaelSmith)
16:18:04 * hackagebot liquidhaskell-cabal-demo 0.1.1.0 - Demo of Liquid Haskell integration for Cabal and stack  https://hackage.haskell.org/package/liquidhaskell-cabal-demo-0.1.1.0 (MichaelSmith)
16:32:28 <EvanR> data structure question, a data Bag a = Empty | Insert a (Bag a) | Append (Bag a) (Bag a) is efficient at concat and traversal, but is there a similarly simple one for being able to efficiently remove an item
16:43:07 <sm> hmm, is it possible to use N and J as aliases for Nothing and Just ?
16:48:20 <nitrix> EvanR: I'll ask the same question but twist it a little; to delete AND lookup an item.
16:48:34 <nitrix> EvanR: Suddently the O complexity changes.
16:49:01 <Rotaerk> is the conduit package very popular, or is there a different abstraction that's "better"
16:50:07 <v937xjd> Pipes seems to have more uptake is my impression
16:51:29 <Rotaerk> thanks
16:52:26 <bergey> packdeps and Hackage download counts suggest conduit has at least 3-4x more usage
16:53:05 <EvanR> nitrix: actually i want to filter
16:53:16 <EvanR> so maybe this structure is fine
16:55:01 <nitrix> EvanR: What you could do is insert a `Deletion a` at the begining/root. This way, the next time you traverse the data structure, you can ignore elements that are known to be deleted, and eventually discard them when the new data structure is yield.
16:55:26 <nitrix> EvanR: Depending what the goal is; lazy deletions has all the obvious problems of lazyness.
16:55:46 <augur> byorgey: some of the links in the hackage docs for Diagrams are local file locations on your computer
16:56:10 <EvanR> nitrix: im ok with unlazy
16:56:33 <EvanR> i dont totally get insert Deletion a
16:57:40 <nitrix> `Deletion a (Bag a)`, I should say.
16:58:06 <tobiasBora> EvanR: nitrix : well with good balancing trees, the lookup/deletion is in O(log(n)) no ?
16:58:24 <nitrix> EvanR: In my head, it's an amortized deletion. You keep note that something has to be deleted to ignore potentially existing values if found on your next traversal.
16:58:25 <tobiasBora> balanced*
16:58:31 <EvanR> tobiasBora: but union is not as fast as with Bag
16:58:34 <nitrix> tobiasBora: Yeah, but I think EvanR is looking for O(1) for everything.
16:58:41 <EvanR> haha
16:59:00 <nitrix> Half-serious, of course :P
16:59:13 <EvanR> so instead of deleting on a traversal, i insert something....
16:59:46 <EvanR> and Deletion is inserted specifically around an Insert
17:00:25 <EvanR> it seems like inserting or just really deleting now are the same to me
17:00:32 <nitrix> EvanR: My idea is the most basic. You "insert" the fact that something has to be deleted eventually, so that the next traversal done, you actually do remove it.
17:01:03 <tobiasBora> EvanR: With binomial trees union is pretty fast
17:01:03 <nitrix> EvanR: Thus, deletions are "O(1)", and the real cost of removing them is amortized by the next time that you'd have to traverse the structure anyway to really remove them.
17:01:11 <EvanR> inserting deep in this tree isnt really that efficient
17:01:28 <EvanR> tobiasBora: well, with Bag its just Append (Bag a) (Bag a)
17:01:39 <EvanR> no work is done
17:02:11 <tobiasBora> Yes, but in works case you could chain bag like list, and it's not really good...
17:02:22 <tobiasBora> *worst
17:02:28 <EvanR> nitrix: "O(1)" heh...
17:02:34 <nitrix> EvanR: Yes.
17:02:52 <EvanR> to insert a delete at the site of an Insert, you need to have rebuilt the whole path to it
17:02:56 <nitrix> Delete 5 (Insert 5 Empty)
17:03:21 <EvanR> during a filter, might as well just rebuild it without the filtered items
17:03:27 <nitrix> EvanR: You do it at the begining/root.
17:03:31 <tobiasBora> And with lot's of dead element in your tree I'm not sure it would be really efficient if you often delete items.
17:03:39 <EvanR> oh youre talking about Eq
17:03:52 <EvanR> Bag has duplicates
17:04:06 <EvanR> it needs to be able to remove only 1 item
17:04:10 <nitrix> The Delete solution still works for duplicates.
17:04:17 <EvanR> not all items that are Eq
17:05:05 <nitrix> EvanR: Have I explained the idea correctly and you just think it's not suitable, or did I do a poor job?
17:05:11 <EvanR> so in your mind you have a stack of Deletes on the top, and to actually remove them or ignore them you begin by making a Set to traverse with?
17:05:31 <EvanR> and remove from the Set if you see that item (to get duplicates to work)
17:05:34 <EvanR> ?
17:05:48 <EvanR> im still trying to understand it
17:06:35 <nitrix> The idea is to not mutate it until it's traversed/filtered.
17:06:50 <EvanR> how would the mutation happen
17:07:19 <nitrix> Empty, this is my current Bag.
17:07:41 <nitrix> Insert 5 Empty, this is another Bag, which I inserted 5, O(1) time complexity.
17:08:31 <nitrix> Now imagine there are more values; Delete 5 (theLargeBag), you "inserted" the fact that an item has to be removed, that's still O(1) time complexity.
17:08:41 <EvanR> right
17:08:49 <EvanR> (the one that is Eq to 5)
17:08:56 <EvanR> (hopefully not all of them)
17:09:03 <nitrix> And when you actually do traverse the list to know what's inside, which would necessarily be O(n), you use that time productively to ignore any elements that are known to be deleted.
17:09:19 <EvanR> how do you know? with a Set ?
17:09:33 <EvanR> or linear search through the deletions
17:09:33 <nitrix> It's a bad of sets?
17:09:37 <nitrix> *bag
17:09:53 <nitrix> Oh.
17:10:17 <EvanR> i see you put the info there, but didnt explain how to use it
17:10:40 <nitrix> Honestly, you totally could. As you find items "to be deleted", you can add them to a set, and as you traverse, check elements to see if they are in that set.
17:11:13 <nitrix> That'd give O(n * log m), but it can be improved with a bloom filter :)
17:11:17 <EvanR> ok, and when you see one, remove it from the set?
17:11:23 <nitrix> to near O(n).
17:11:49 <nitrix> It's already near O(n) to be honest, assuming you don't pile up a ridiculous amount of deletions. Again, it's the same problem as lazy evaluation. Now you have lazy deletions.
17:13:37 <nitrix> EvanR: Yup. Or use a map if you need to keep track of the count... but maps perform worst than sets I think. It'd make the bloom filter a lot more important if you do that.
17:14:23 <EvanR> i was not planning on having Eq nor Ord here for the items ;)
17:14:24 <augur> boy, diagrams takes forever to install :x
17:14:45 <nitrix> EvanR: The goal of that bloom filter being to get O(1) true positive that the item is known not to be in that deletion map/set without looking it up.
17:14:50 <EvanR> its just a -> Bool
17:15:22 <nitrix> EvanR: It's a frenkenstein data structure, but it's theorically possible to get near O(1) deletions too, provided the cons about lazyness are well understood.
17:15:25 <EvanR> so before even getting into how much Set operations this is going to take, the Deletion idea seems hard to do
17:16:12 <nitrix> EvanR: The bloom filter skips almost all of the set operations.
17:16:17 <nitrix> Shall I implement it :P ?
17:16:19 <EvanR> how does that work?
17:18:06 <nitrix> EvanR: Bloom filters, ehm... layman, it's a bitset; keys are very lightly "hashed" to a bit pattern, which is AND'ed with the bitset.
17:18:28 <nitrix> EvanR: Thus, it allows you to test if anything has been "seen before", because you'd have a 1 in there.
17:18:48 <EvanR> with false positives? 
17:19:06 <nitrix> EvanR: It gives true positives but prevents false negatives. If I got the terminology right.
17:19:14 <nitrix> No wait.
17:19:50 <nitrix> EvanR: It can guarantees an item hasn't been seen before, but it might think it has seen one it hasn't, and that's the only case where you'd actually lookup the set to really know.
17:19:59 <nitrix> EvanR: So it can avoid a lot of set lookups.
17:20:19 <nitrix> I don't know, it was just an idea like that. Maybe I'm going on a tangeant with my O(1) deletion with sets and bloom filters :/
17:21:06 <nitrix> Food for thoughts.
17:22:35 <EvanR> heres something http://lpaste.net/162640
17:22:48 <nitrix> EvanR: In other words, it'd traverse the Bag, check them agaisn't the bloom filters, most of them would be know the be certainly not deleted, and rarely, a few will be diagnosed as "potentially deleted", you verify and that's it.
17:23:03 <nitrix> *filter *known
17:23:08 <EvanR> if its very short, it cant be that bad(tm) ;)
17:23:13 <montanonic> when you call forkIO, what type of thread are you creating? A "green" thread, or another thread on a processor?
17:23:22 <nitrix> montanonic: Green.
17:23:23 <EvanR> a green thread
17:23:28 <montanonic> cool, ty
17:23:44 <nitrix> montanonic: forkOS is the real thread.
17:23:48 <EvanR> nitrix: so youre basically requiring Bits or something
17:23:49 <jmcarthur> montanonic: It's a "green" thread, but GHC green threads do support parallelism, in case that wasn't clear.
17:23:52 <montanonic> nitrix: ahh, I see
17:23:55 <jmcarthur> nitrix: No, it's not.
17:24:05 <nitrix> jmcarthur: Oh?
17:24:17 <nitrix> I know there's still scheduling happening, with bound threads and whatnot.
17:24:20 <jmcarthur> nitrix: forkOS just creates a bound thread. It guarantees that foreign calls in that thread always happen on the same OS thread.
17:24:24 <nitrix> Right.
17:24:24 <montanonic> jmcarthur: yes, green threads are utilized by idle processors
17:24:36 <montanonic> idle "actual threads" rather
17:24:36 <nitrix> jmcarthur: Okay thanks.
17:24:45 <montanonic> jmcarthur: is that correct?
17:24:48 <jmcarthur> nitrix: But it doesn't create a new OS thread just for the thread, and it doesn't guarantee that all Haskell code runs on that OS thread either.
17:25:20 <nitrix> jmcarthur: That much I knew. I hit a corner case with SDL requiring thread local variables.
17:25:28 <EvanR> to understand processors you must first understand capabilities
17:25:39 <EvanR> threads run on capabilities
17:25:51 <EvanR> at most one thread per
17:26:18 <EvanR> (at a time)
17:26:22 <nitrix> EvanR: https://hackage.haskell.org/package/bloomfilter
17:26:40 <nitrix> EvanR: I have no idea how good the implementation is, I just found that; seems like what I'm talking about (for bloom filters).
17:26:44 <simpson> I hate that use of "capability". It is so foreign to the security sense of the word. But it's also the right word according to docs that are older than me, so.
17:27:54 <nitrix> EvanR: insert, elem, notElem.
17:28:11 <EvanR> and each processor can run at most one capabilities at a time
17:28:12 <EvanR> so there
17:28:18 <geekosaur> capability i overloaded, like pretty much any other term. there's also the capability maturity model which is a double hit ("CMM")
17:28:19 <EvanR> lots of jargon
17:28:51 <jmcarthur> I think the context is separate enough from the world of security as to not be too confusing.
17:29:03 <simpson> Yeah, and TBH I wish that the security concept had a better name. We sometimes say "power" or "authority" but it's not the same.
17:30:05 <thoughtpolice> It's an interesting question where the name first appeared. Anyway, we should probably fix the Control.Concurrent documentation to be more explicitly clear about this.
17:30:53 <simpson> Maybe we should just say "unforgeable transferable authority" and popularize "UTA" or another acronym.
17:30:59 <thoughtpolice> The current forkOS docs do some hand waving about blocking stuff, but it doesn't really flat out say directly "It creates a lightweight, forkIO thread - it simply ensures all foreign calls from that thread always occur on the bound OS thread that is created."
17:31:03 <simpson> Actually, I'm posting that to #erights.
17:31:13 <thoughtpolice> Which would probably be good because that misconception is frequent.
17:31:22 <nitrix> EvanR: I think this shows visually the idea https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg
17:31:27 <nitrix> EvanR: Good luck :)
17:31:46 <EvanR> wow 
17:32:00 <nitrix> EvanR: It's very elegant :)
17:32:22 <nitrix> I know redis uses it; or a variant (HyperLogLog) to count unique elements.
17:32:23 <EvanR> can we replace like everything with such a picture
17:33:24 <EvanR> so it requires Hashable support or similar
17:34:15 <nitrix> EvanR: https://hackage.haskell.org/package/bloomfilter-2.0.1.0/docs/Data-BloomFilter-Hash.html
17:35:02 <EvanR> so im expecting the bags to be like less than 10 items big at most
17:35:12 <EvanR> maybe it doesnt even matter
17:35:16 <EvanR> and i should use lists
17:35:55 <nitrix> 10, hahahah, yes, yes you should :P
17:36:04 <nitrix> Is it a game?
17:36:20 <EvanR> o
17:36:23 <EvanR> no
17:36:40 <EvanR> this is a "reference" runtime for something
17:36:55 <EvanR> messages may arrive simultaneously in bags
17:37:03 <EvanR> and pattern matched on
17:37:23 <EvanR> mostly they ought to be singletons
17:37:33 <EvanR> i guess i was thinking webscale
17:37:42 <nitrix> EvanR: It has to be its own hashing system obviously; the goal isn't like popular hashing algorithm to get chaotic (a small tiny change modifying the entire hash)
17:37:59 <EvanR> no?
17:39:15 <nitrix> It's still well distributed. I don't remember the details.
17:39:33 <nitrix> Anyway, I should work on my game - because weekend :P
17:42:02 <EvanR> this random page just says the hash should be faster than crypto hash, just because its not crypto
17:42:05 <EvanR> http://billmill.org/bloomfilter-tutorial/
17:43:38 <nitrix> Sounds about right.
17:45:49 <nitrix> I was just playing the game of figuring out O(1) deletions by the way. I still think it's overkill for 10 items.
17:50:35 <EvanR> yeah im actually just going to use lists
17:53:45 <kendricktan> can anyone here explain typeclasses? 
17:53:50 <kendricktan> please
17:54:38 <zRecursive> kendricktan: a bit like interface in Java ?
17:55:44 <kendricktan> zRecursive: i'm taking the learnyouahaskell course, which also states how typeclasses are like interfaces in java, but better...
17:56:13 <kendricktan> should i just treat it like a black box
17:56:52 <nitrix> kendricktan: Typeclasses regroup multiple types together by similarities that they have in common. For example, the `Show` typeclass would represent things that can be shown. Every type that wants to be shown has to implement an instance for this typeclass; which implies implementing the `show` function.
17:57:43 <nitrix> kendricktan: Different typeclasses have different requirements (typically in the form of functions to implement, but sometimes mathematical laws as well).
17:57:58 <kendricktan> nitrix: ahhh, okay i get it now. thanks :) 
17:58:00 <nitrix> Nothing crazy, if it reassures you :)
17:58:23 <EvanR> type classes were invented to do ad-hoc polymorphism, if you know this from OOP
17:58:34 <EvanR> > 2 + 2
17:58:36 <lambdabot>  4
17:58:38 <EvanR> > 2.0 + 2.0
17:58:39 <lambdabot>  4.0
17:58:44 <montanonic> kendricktan: you can have a typeclass such as `class QueueLike`, and give it multiple methods that are to be implemented to satisfy the type of operations we want to have for a Queue, like `pop` and `push`, and maybe some methods that use other methods in their definition, `popTwice = pop . pop`, or whatever
17:58:49 <EvanR> :t (+)
17:58:50 <lambdabot> Num a => a -> a -> a
17:59:20 <nitrix> kendricktan: A few more example, the Eq typeclass is for types that allow comparison, it requires types the implement an instance that has the (==) function.
17:59:25 <kendricktan> montanoic: sweet, so its exactly like java interfaces
17:59:39 <nitrix> kendricktan: Ord is for things that are orderable, so types must implement >, <. <=, >=, compare, etc.
17:59:48 <montanonic> kendricktan: lots of similarities as far as I can tell, so yes
17:59:52 <EvanR> kendricktan: not exactly
18:00:09 <montanonic> ^but they probably don't have to worry about the differences just yet
18:00:17 <montanonic> (unless they do?)
18:00:49 <EvanR> well, java has added a lot of functionality to interfaces ...
18:00:59 <nitrix> kendricktan: I think it's not super harmful intuition for now, but eventually you'll see there's a bit more going on at the type (and kind) level :)
18:01:02 <EvanR> so its getting hard to describe the differences seriously
18:01:03 <kendricktan> i'll just take it to be like java's interfaces for now. Thanks everyone :) 
18:01:23 <zRecursive> v
18:01:31 <zRecursive> yeah
18:01:50 <nitrix> :t (==)
18:01:51 <lambdabot> Eq a => a -> a -> Bool
18:01:53 <sshine> wasn't there a not-haskell channel?
18:01:54 <EvanR> when you can implement printf with jav ainterfaces call back ;)
18:01:56 <montanonic> kendricktan: no problem :) ; I'd also recommend using resources mentioned in: https://github.com/bitemyapp/learnhaskell
18:02:08 <montanonic> kendricktan: CIS 194 goes into more detail than LYAH, and has exercises
18:02:19 <EvanR> sshine: #haskell-blah
18:02:30 <sshine> thanks.
18:02:47 <nitrix> kendricktan: I'm jumping the guns, but it's my style to give hints ahead to peek people's curiosity.
18:02:53 <nitrix> :t (==)
18:02:54 <lambdabot> Eq a => a -> a -> Bool
18:03:23 <kendricktan> montanoic: that looks great. i'm from an oop background and just wanna learn a different paradigm of thinking so thank you
18:03:32 <nitrix> kendricktan: Here, you can see this function is comparing two things, of some type `a`, and it's returning a Bool.
18:03:52 <EvanR> kendricktan: it takes some getting used to to see when and when not ot use type classses, you generally dont use them for the same thing as in java
18:03:56 <EvanR> as interfaces 
18:04:18 <EvanR> if you try it may end badly
18:04:43 <nitrix> kendricktan: On the left hand side of `=>`, you'll discover that this is a type constraint, and not all types `a` can be compared, there's a constraint in place that only types with an `Eq` instance fits in there.
18:05:04 <nitrix> kendricktan: This is obviously very layman but its a taste of what's to come :) Typeclasses are very important.
18:05:07 <kendricktan> EvanR: hopefully not ahaha
18:06:07 <kendricktan> nitrix: sorry i got lost at the type constraint bit
18:06:56 <kendricktan> nitrix: ohhh wait i think i got it
18:07:34 <nitrix> kendricktan: Give yourself a few chapters and you'll slowly connect the dots. :)
18:09:37 <EvanR> :t (+)
18:09:38 <lambdabot> Num a => a -> a -> a
18:11:16 <nitrix> kendricktan: I am jumping the guns because it does requires a little knowledge of polymorphism (like at least type variables).
18:11:47 <nitrix> kendricktan: If I remember LYAH gets the order a bit wrong in how it should be taught, but yeah.
18:11:59 <kendricktan> nitrix: not a master of oop, but i do understand the basics like abstraction, encapsulation, polymorphism so i get the basic link between it now :) 
18:12:06 <EvanR> + works on values of the same type, and returns a value of that type, as long as that type is a number (has a Num instance)
18:12:28 <EvanR> > (1%3) + (2%3)
18:12:30 <lambdabot>  1 % 1
18:12:45 <kendricktan> EvanR: sweet, that cleared the remaining question O:) 
18:12:46 <EvanR> > (1 :+ 3) + (2 :+ 3)
18:12:48 <lambdabot>  3.0 :+ 6.0
18:13:01 <EvanR> (:+ is the constructor for Complex)
18:13:08 <EvanR> % is for Rational
18:13:23 <nitrix> EvanR: Scary.
18:14:01 <EvanR> > (1,2) + (3,4)
18:14:03 <lambdabot>      No instance for (Show t0)
18:14:03 <lambdabot>        arising from a use of ‘show_M165560129477208152324932’
18:14:03 <lambdabot>      The type variable ‘t0’ is ambiguous
18:14:14 <EvanR> > (1,2) + (3,4) :: (Int,Int)
18:14:15 <lambdabot>      No instance for (Num (Int, Int)) arising from a use of ‘+’
18:14:16 <lambdabot>      In the expression: (1, 2) + (3, 4) :: (Int, Int)
18:14:19 <EvanR> blarg?!
18:14:31 <nitrix> kendricktan: If we specialize this type signature for Int, by replacing the `a`'s with Int, you'd get :: Num Int => Int -> Int -> Int
18:14:44 <nitrix> kendricktan: Int can only fit there because it has an instance for Num.
18:15:01 <EvanR> yes type variables are best understood through substitution
18:15:13 <nitrix> kendricktan: Thus, "foo" + "bar" is a type error, as you'd expect.
18:15:23 <EvanR> > "foo" <> "bar"
18:15:23 <nitrix> > "foo" + "bar"
18:15:25 <lambdabot>      No instance for (Num [Char]) arising from a use of ‘+’
18:15:25 <lambdabot>      In the expression: "foo" + "bar"
18:15:25 <lambdabot>  "foobar"
18:15:29 <EvanR> lol
18:15:34 <EvanR> :t (<>)
18:15:36 <lambdabot> Monoid m => m -> m -> m
18:15:39 <nitrix> EvanR: Please don't confuse him.
18:15:47 <nitrix> I don't want to move this to #haskell-beginners.
18:15:54 <EvanR> harsh
18:16:19 <nitrix> kendricktan: Here's me adding two strings, the compiler complained:  No instance for (Num String) arising from a use of ‘+’
18:16:31 <EvanR> > "foo" ++ "bar"
18:16:32 <lambdabot>  "foobar"
18:17:33 <kendricktan> i think i get it now :) 
18:17:45 <kendricktan> thank you guys
18:18:04 <EvanR> in ghci get info on a particular type class with :i
18:18:10 <EvanR> :i Num
18:18:15 <EvanR> :i Monoid
18:18:16 <EvanR> etc
18:20:30 <nitrix> EvanR: By the way, apologies, I was rude.
18:21:40 <xa0> :t (=>)
18:21:41 <lambdabot> parse error on input ‘=>’
18:21:49 <xa0> :k (=>)
18:21:50 <lambdabot> parse error on input ‘=>’
18:22:08 <pavonia> => is syntax
18:22:19 <xa0> I thought so, but you never know :p
18:22:31 <nitrix> EvanR: It's just... people get scared easily - and I think the comforting lie of "I think I can actually understand still" is more productive than "Oooookay, wth. Should I be understanding this at my stage?"
18:22:49 <nitrix> xa0: (=>) is syntax but (,) isn't though.
18:22:57 <nitrix> :k (,)
18:22:58 <lambdabot> * -> * -> *
18:23:05 * hackagebot ttask 0.0.0.2 - This is task management tool for yourself, that inspired by scrum.  https://hackage.haskell.org/package/ttask-0.0.0.2 (outoftune)
18:23:07 <nitrix> :k Num
18:23:09 <lambdabot> * -> Constraint
18:23:12 <nitrix> :k Num Int
18:23:13 <lambdabot> Constraint
18:23:16 <xa0> Yeah, I just remembered being caught out by (->)
18:23:27 <nitrix> xa0: The left hand side of => needing to be a Constraint.
18:23:45 <xa0> That's what I was expecting :p
18:24:02 <xa0> Constraint -> * -> *
18:24:04 <xa0> Or something
18:24:47 <nitrix> I don't think you could possibly give a kind to (=>). Don't quote me on that.
18:25:24 <shachaf> @let data DoubleArrow k a = DoubleArrow (k => a)
18:25:26 <lambdabot>  Defined.
18:25:28 <shachaf> :k DoubleArrow
18:25:30 <lambdabot> Constraint -> * -> *
18:27:06 <nitrix> :k DoubleArrow (Num Int) Bool
18:27:07 <lambdabot> *
18:27:26 <nitrix> It doesn't seem like it allows for functions though... what's the kind of ((->) r) ?
18:28:39 <nitrix> The kind of :: r -> u, actually.
18:28:42 <nitrix> Oh that works!
18:29:15 <nitrix> shachaf: Why is (=>) only syntax then?
18:30:22 <tobiasBora> Is there a structure like IntMap, but which ensure that there is exaclty n elements in it, and that there isn't any hole (For example, I don't want an IntMap defined on 0,1,5,6, but on 0,1,2,3).
18:30:50 <jle`> tobiasBora: sounds like an Array ?
18:30:58 <jle`> or a Vector
18:30:59 <nitrix> Or a vector
18:31:18 <tobiasBora> jle`: The problem in Array is that changing one component is long in immutable arrays
18:31:35 <jle`> do you think it takes more time than for an IntMap ?
18:32:01 <nitrix> On very large arrays, possibly.
18:32:01 <tobiasBora> jle`: Well in IntMap changing should be in O(n log n) no ?
18:32:17 <tobiasBora> While in vector it's in O(n) no ?
18:32:26 <tobiasBora> (I mean immutable vector)
18:32:33 <jle`> nlog n is bigger than n
18:32:39 <tobiasBora> sorry
18:32:43 <tobiasBora> I mean O (log n)
18:33:06 * hackagebot configurator-export 0.1.0.1 - Pretty printer and exporter for configurations from  the "configurator" library.  https://hackage.haskell.org/package/configurator-export-0.1.0.1 (jle)
18:34:15 <nitrix> tobiasBora: If you still really want to use an IntMap, nothing prevents you from writing your own module that keeps track of the smallest and biggest key and doesn't allow insertions n-2 or m+2 of that range.
18:34:30 <nitrix> s/module/data structure/
18:35:42 <tobiasBora> nitrix: I must be sure that all elements betwoon n and m are present
18:35:59 <nitrix> tobiasBora: They are, by definition.
18:35:59 <abg> tobiasBora: What about Data.Sequence? It's immutable, numerically indexed and has logarithmic time lookups and updates.
18:36:28 <nitrix> Oh look, someone already implemented it :)
18:37:56 <jle`> Data.Sequence is based on finger trees :)  but yeah, i think a lot of these differences might be constant factors and won't matter until a certain point.  some of this might be premature optimization
18:38:14 <jle`> it's ok to use an ADT with the right interface, it might not be the bottleneck in your application
18:39:26 <jle`> modifications on small IntMaps are actually O(n)
18:40:05 <nitrix> jle`: Recent example, my game was using a data Bimap k v = MkBimap (Map k (Set v)) (Map v (Set k)) until very recently when I profiled it and rewrote it as a kdtree :)
18:40:30 <tobiasBora> abg: Great thank you !
18:40:43 <nitrix> It managed to go under the radar for a very long time :P
18:40:56 <jle`> nice :P
18:41:05 <jle`> profile-driven optimization
18:41:26 <nitrix> jle`: Yeah, GHC cost centres with some package I found on hackage called `profiteur`.
18:41:33 <dolio> Whoever worked on ConstraintKinds forgot to allow you to do (=>).
18:41:56 <tobiasBora> Do you have good tools to profile an application ?
18:42:07 <nitrix> jle`: It generates an html page that divides a square into smaller squares (named as your functions) and you get a visual profile of bottlenecks.
18:42:23 <jle`> dolio: huh, yeah, that's odd, i always thought it worked
18:42:30 <jle`> but => behaves weirdly in Pattern Synonyms
18:44:37 <dolio> In the type of a pattern synonym?
18:45:39 <geekosaur> it can occur twice in the type of a patsyn, one is the required constraints and the other the provided constraints on match
18:46:01 <jle`> it's weird though becuase it normally already can occur twice+ times in a normal type signature
18:46:16 <jle`> Num a => Show a => Ord a => ..
18:46:31 <jle`> in that sense it's Num a => (Show a => (Ord a => ...))
18:46:38 <jle`> so it sort of pretends to behave like a normal operator
19:13:07 * hackagebot pandoc-crossref 0.2.1.2 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.2.1.2 (lierdakil)
19:23:07 * hackagebot github-release 0.1.6 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-0.1.6 (fozworth)
19:34:50 <montanonic> How would I write a FromJSON instance where some of the JSON data is nested, but the data type I'm parsing the JSON into is flat? Do I have to use an intermediary type to do this?
19:36:33 <montanonic> In my case, Google Calendar API bundles up start time and end time information into individual objects, but that additional structure is useless to my use-case, and frustrates my ability to have one single type from JSON to a Persistent backend.
19:37:18 <THE_MATRIX> hello
19:38:29 <montanonic> THE_MATRIX: hi
19:41:30 <aleogen> can someone help me understand intuitively what a monad is and a group action applied to a bundle?
19:41:40 <solirc> sm: Please don't
19:41:54 <solirc> sm: Latest version of HUnit gives you line numbers
19:42:03 <solirc> sm: So does hspec for a long time
19:42:25 <solirc> sm: doctest is for testing documentation not for testing code
19:42:35 <nitrix> THE_MATRIX: Are you evading a k-line? #89512: 2016-01-09 22:15:28 xvvx!32894c74@gateway/web/cgi-irc/kiwiirc.com/ip.50.137.76.116 ([www.kiwiirc.com] xvvx) k-line
19:42:56 <nitrix> Can you PM me?
19:44:03 <shachaf> aleogen: You'll probably be better off asking your question and seeing if anyone answers.
19:52:17 <THE_MATRIX> nitrix ?
19:53:14 <geekosaur> nitrix, the web gateways periodically get k-lined by mistake (it's not possible to kline someone connected via a web gateway; it klines the gateway itself)
19:53:30 <geekosaur> freenode even accidentally klines its own web gateway occasionally
19:54:12 <nitrix> How strange.
19:54:37 <geekosaur> why? it does it by address
19:54:50 <geekosaur> the only address it can use for a web gateway is the address of the gateway
19:54:55 <nitrix> Oh no, I mean, antispammeta kept the record.
19:56:17 <nitrix> It's rare to see evil doers on #haskell, so I got curious. I can probably get the entry removed (:
20:33:54 <fatex> in ghci, is there a way to bind C-c to "kill current computation, and all forked off threads" ?
20:43:57 <ElMoloko> spawn ghci through a wrapper that handles SIGINT
20:44:29 <ElMoloko> then finds all children of the ghci process
20:44:36 <ElMoloko> and sends it to them
20:53:10 * hackagebot yi 0.12.5 - The Haskell-Scriptable Editor  https://hackage.haskell.org/package/yi-0.12.5 (DmitryIvanov)
20:54:33 <lpaste> Tril pasted “forkProcess issue” at http://lpaste.net/162646
20:55:11 <Tril> ok that did not wrap very nicely... any tips welcome.
20:57:16 <Tril> edited to wrap a little better... same link above
20:59:11 <Tril> summary: looks like the 2 haskell daemon libraries I tried either both use forkProcess wrong or there's an issue in forkProcess.
21:00:39 <geekosaur> ghc version?
21:00:57 <Tril> 7.10.3, I think also 7.10.2
21:01:32 <geekosaur> (also I have built and run xmonad using both debian/ubuntu ghc 7.6.3 and hvr's 7.10.3 PPA, it uses double-forking heavily, no locking issues)
21:03:35 <geekosaur> oh. I think I looked at the code of one of those once and saw some iffy things, but I don't recall details. many people do not get the POSIX process model, and it will bite you HARD if you don't.
21:03:50 <geekosaur> ...oh wait, this is locking in pthread. I think that is a known issue
21:04:00 <tobiasBora> Hello,
21:04:43 <geekosaur> fork() itself is dubious with multiple threads; forkProcess is even more so and I think they are aware that it's buggy with the threaded runtime. (xmonad doesn't use the threaded runtime because X11 isn't really thread safe)
21:05:30 <tobiasBora> I have a fonction f :: a -> IO (b), and another function g :: b -> c, and I would like to "compose" f and g to get (g $ f a) :: IO (). Do you have any idomatic way to do se ? 
21:05:32 <tobiasBora> *so
21:07:27 <Tril> tobiasBora I think you want the bind operator (>>=)
21:07:59 <nitrix> tobiasBora: g <$> f
21:08:16 <nitrix> Actually no.
21:08:38 <nitrix> That'd give you an `IO c`.
21:08:48 <tobiasBora> sorry
21:08:54 <tobiasBora> I mean IO c
21:09:08 <nitrix> Well, there you go then. IO as a Functor.
21:09:39 <tobiasBora> and if f :: IO(b) ?
21:10:06 <Tril> tobiasBora: then see >> operator
21:10:12 <nitrix> g <$> f x  in the first case
21:10:17 <nitrix> g <$> f  in the former.
21:10:22 <nitrix> *latter
21:10:46 <nitrix> Tril: I think (>>=) is ill-advised considering g isn't monadic anywhere.
21:11:04 <geekosaur> well, it's the antipattern g >>= return . f
21:11:13 <geekosaur> (which should be fmap aka <$>)
21:11:30 <nitrix> I don't encourage anti-patterns :x
21:11:43 <geekosaur> wait, I think I have those backwards
21:11:50 <geekosaur> f >>= return . g
21:11:52 <Tril> geekosaur: so if I want to make a daemon in Haskell and shouldn't use forkProcess which library should I call?
21:11:54 <geekosaur> or g <$> f
21:12:10 <geekosaur> Tril, I think you have to avoid using forkProcess with the threaded runtime or you get that kindf of failure
21:12:19 <geekosaur> the non-threaded runtime is fine
21:12:33 <tobiasBora> Hum the error I god was because of bad parenthesis
21:12:35 <tobiasBora> Thank you
21:12:51 <geekosaur> lemme see if I can find the trac ticket about it
21:12:53 <tobiasBora> Do you have a more beautifull way to write :   Layer f <$> (Seq.replicateM nb_input $ create_neuron_alea nb_input)
21:13:03 <tobiasBora> (By removing the parenthesis
21:13:05 <tobiasBora> )
21:13:16 <Tril> geekosaur: my daemon does nothing right now, so I will try testing that without threads... but I think I will want them soon
21:13:58 <nitrix> tobiasBora: No sure. Maybe,  fmap (Layer f) $ Seq.replicateM nb_input $ create_neuro_alea nb_input
21:14:10 <nitrix> tobiasBora: Can I ask why you're using snake case in a camelCase convention language?
21:14:36 <tobiasBora> snake case is using underscore ?
21:14:46 <nitrix> Correct.
21:15:37 <geekosaur> Tril, https://ghc.haskell.org/trac/ghc/ticket/9470 looks to be either it or related. note that there's a workaround that may help you, or may not
21:15:41 <tobiasBora> Well I love using "Ctrl - backspace" to remove the last part of a variable. It's really easy to correct "my_variable_brown" into "my_variable_red" like that
21:16:17 <nitrix> tobiasBora: Sounds like a defect of your editor, not a justification to barbarise the language.
21:16:47 <tobiasBora> While with "myVariableBrown" + "Ctrl - backspace" would remove everything.
21:17:04 <geekosaur> Tril, there is also https://ghc.haskell.org/trac/ghc/ticket/9347 which is a different issue (basically, forkProcess is unsafe if there are any MVars or TVars in play)
21:17:09 <geekosaur> ...or maybe that is your problem
21:17:22 <tobiasBora> Barbarise... I come from an Ocaml world where '_' is the convention, I don't think it's barbare, it's much more easy to read I think.
21:18:00 * geekosaur prefers _ as well for readability... admittedly I have my own little issues to deal with (and I camelCase in xmonad because that's what
21:18:05 <geekosaur> s already there, sigh)
21:18:53 <tobiasBora> But if you have a simple way to configure emacs to transform Ctrl-backspace to remove until the last upper case letter, I can try to use camlCase...
21:19:24 <geekosaur> it's doable certainly. I have a modified ctrl-backspace somewhere although it doesn't do that
21:19:27 <nitrix> I just think your argument is affected irrationally by something that shouldn't influence it.
21:19:43 <geekosaur> (and hm, I might have to pull it from a backup, come to think of it)
21:19:50 <nitrix> If you don't know how your tools work or can't get them to work, they shouldn't be blamed or involved in a decisive process.
21:20:46 <nitrix> I'm positive someone, somewhere, already figured this out. But I'm not an emacs user.
21:21:52 <tobiasBora> nitrix: Well, if you need to change all defaults configuration in every program you can use, while default already exists with a more readible form, the convention may be seen as a pain...
21:25:18 <nitrix> tobiasBora: M-x subword-mode
21:30:53 <Tril> geekosaur: there are no locks, the minimal test case only runs forever $ return () or forever $ threadDelay 1000000. BTW, the non-threaded runtime appears to work
21:31:52 <geekosaur> the issue in 9347 involved Handle locks in the runtime, not application code
21:32:11 <geekosaur> (and you have three of those by default: stdin stdout stderr)
21:32:53 <geekosaur> but this sounds like the 9470 issue maybe. in which case you can use the threaded runtime, start with -N1, and then setNumCapabilities (IIRC) after you're done forking
21:34:09 <geekosaur> yep http://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:setNumCapabilities
21:34:47 <Tril> geekosaur: thanks. I will also consider closing the 3 handles earlier - they get closed anyway in the grandchild
21:37:00 <tobiasBora> nitrix: Great thank you :D
21:48:12 * hackagebot hw-prim 0.0.0.11 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.0.11 (haskellworks)
21:58:13 * hackagebot hw-rankselect 0.0.0.3 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.0.0.3 (haskellworks)
22:04:58 <tobiasBora> I'm a bit lost with all these operations...
22:05:03 <tobiasBora> updateFloat :: Float -> Float -> IO Float
22:05:09 <tobiasBora> updateNeuronSlow :: Float -> Neuron -> IO Neuron
22:05:12 <tobiasBora> updateNeuronSlow proba neuron =
22:05:14 <tobiasBora>   Neuron <$> fmap (updateFloat proba) $ getValues neuron
22:05:33 <tobiasBora> I see that this cannot work because fmap should take a pure function
22:05:52 <tobiasBora> but I don't see how I could extract the io from fmap here
22:08:34 <tobiasBora> I found this : 
22:08:36 <tobiasBora>   x <- mapM (updateFloat proba) $ getValues neuron
22:08:44 <tobiasBora>   return $ Neuron x
22:09:05 <ski>   updateNeuronSlow proba neuron = Neuron <$> (mapM (updateFloat proba) =<< getValues neuron)
22:09:10 <tobiasBora>   Neuron <$> (mapM (updateFloat proba) $ getValues neuron)
22:09:12 <ski> i imagine
22:09:22 <geekosaur> fmap Neuron (mapM (updateFloat proba) $ getValues neuron)
22:09:33 <ski> well, it wasn't clear to me what the type of `getValues' was
22:09:52 <geekosaur> right, we're both guessing
22:10:21 <ski> i was assuming `getValues :: Neuron -> IO (Foo Float)', while `Neuron :: Foo Float -> Neuron'
22:10:55 <ski> but perhaps you have `getValues :: Neuron -> Foo Float' ?
22:11:17 <geekosaur> well, I just rewrote the "I found this" without do notation
22:11:18 <tobiasBora> ski: getValues :: Neuron -> Seq Float yes
22:11:35 <ski> tobiasBora : in any case, "how I could extract the io from fmap here" is almost surely `mapM'/`traverse'
22:11:55 <tobiasBora> ski: I though that mapM was only for lists at the beginning
22:12:07 <ski> @type mapM
22:12:10 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
22:12:10 <ski> @type traverse
22:12:12 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:12:59 * ski was writing their version before the "I found this"
22:13:13 * hackagebot tls 1.3.7 - TLS/SSL protocol native implementation (Server and Client)  https://hackage.haskell.org/package/tls-1.3.7 (VincentHanquez)
22:13:15 * hackagebot tls-debug 0.4.4 - Set of programs for TLS testing and debugging  https://hackage.haskell.org/package/tls-debug-0.4.4 (VincentHanquez)
22:13:56 <ski>   updateNeuronSlow proba = (Neuron <$>) . mapM (updateFloat proba) . getValues
22:15:46 <tobiasBora> With this version I have  
22:15:48 <tobiasBora> (Neuron <$>) . mapM (updateFloat proba) . getValues
22:15:54 <tobiasBora> Couldn't match expected type ‘IO Neuron’
22:15:56 <tobiasBora>                 with actual type ‘Neuron -> IO Neuron’
22:17:06 <geekosaur> did you adjust the parameters too? neuron got eta-reduced away
22:18:44 <tobiasBora> Of course I'm stupid...
22:19:08 <tobiasBora> Well it works, but I don't have lot's of intuitions right now, thank you for your help I'll study it !
22:19:22 <tobiasBora> Is there any advatages to the eta-reduced version ?
22:19:53 <geekosaur> not especially, iirc ghc knows how to eta reduce for itself if it would be an optimization
22:20:08 <geekosaur> but experienced haskellers usually do it automatically
22:20:30 <tobiasBora> Ok
22:20:56 <tobiasBora> It's funny, because I usually find it's clearer when I can see all the argument my function should take
22:21:03 <tobiasBora> but it's maybe a question of habits.
22:21:07 <tobiasBora> Thank you !
22:25:51 <chemouna> Hello, anyone can help with installing lambdabot please ? with cabal install i get mueval-0.9.1.1.2 failed during the building phase. The exception was: ExitFailure 1
22:27:04 <chemouna> each time, i've tried also with stack but after putting all needed deps in global stack.yml i get a bunch of failures when adding dependencies:
22:40:52 <apricity> I'm getting ready to install haskell on arch linux, anyone recommend a certain way to install it? for instance a certain repo
22:42:58 <chemouna> apricity use stack 
22:47:14 <cocreature> apricity: see http://docs.haskellstack.org/en/stable/README/ for the docs on stack
22:48:54 <shachaf> Why does Text.Printf still use IsChar instead of (Char ~)?
22:49:16 <apricity> i'm seeing hackage and nix as alternatives... is stackage still the way to go?
22:52:59 <srhb> apricity: I prefer Nix. Steeper learning curve than Stack + Stackage though
22:53:51 <Cale> Nix is great, but I hate it ;___;
22:54:02 <srhb> Cale: Hate is such a strong feeling!
22:54:34 <Cale> I use it for work every day
22:57:12 <Cale> It's pretty good when I don't have to configure things, although the purity means that there are often cases where I just can't get away from waiting for tediously long rebuilds when something fails, because the old partially compiled results can't be reused (unless every haskell source file was made into its own individual nix package or something...)
22:58:15 <srhb> Not having to do that and still getting the benefits of the partial artifacts would certainly be pretty cool.
22:59:15 <Cale> and then there's its wonky little programming language, which is the modern day M4
22:59:39 <Cale> I really really wish that language were just Haskell.
23:00:03 <srhb> Agreed.
23:00:34 <Cale> It's hard to figure out the intention regarding how things are to be used without a proper type system, and I often feel like most everyone is just cargo-culting stuff
23:02:02 <Cale> But yeah, the fact that someone else can make a package I can download and it'll drop me into a shell where it's as if my whole system is a clone of their system and everything will work consistently is pretty nice!
23:02:33 <chemouna> @type map
23:02:34 <lambdabot> (a -> b) -> [a] -> [b]
23:03:41 <chemouna> anyone has install lambdabot successfully locally ?
23:05:55 <apricity> I went with stack for the moment i think it's working... when i ran stack exec testing-exe it output someFunc
23:07:04 <srhb> Cale: Agreed again. It's nice, and it's the only thing that does THIS thing, but a type system is sorely needed, (and why not use an existing one...)
23:07:33 <srhb> apricity: It's a good choice. :)
23:07:40 <shachaf> Hmm, there's an advantage to *-kinded naturals over promoted DataKinded naturals:
23:08:06 <shachaf> If I write data Z = Z; data S n = S n, then I can use [S (S (S Z))] on the value level to compactly express a type argument.
23:08:39 <shachaf> I don't think there's anything as convenient with DataKinded naturals.
23:12:34 <fatex> I'm using Data.Aeson. I have converted my haskell data type to a "Value". Now, how do I write it to file. Is there something more efficent than calling "show/read" ?
23:14:33 <Xnuk> I installed lambdabot successfully, but I had trouble with configuring it, so now I use mueval only.
23:14:42 <srhb> fatex: Perhaps the functions in Data.Aeson.Encode
23:15:37 <srhb> fatex: If you mean to write the JSON, and not the serialized Value, to disk
23:15:59 <fatex> maybe we discuss XY problem right now
23:16:02 <fatex> here is my problem
23:16:12 <fatex> I have haskell data strucure; they ahve (derive Generic)
23:16:14 <fatex> I want to serialize them to disk
23:16:20 <fatex> ^^^ above = actual problem
23:16:27 <fatex> potential solution = why not use Data.Aeson ?
23:16:31 <fatex> what do you suggest?
23:17:47 <srhb> fatex: Using cereal.
23:18:00 <srhb> fatex: https://hackage.haskell.org/package/cereal-0.5.1.0/docs/Data-Serialize.html
23:18:12 <fatex> okay; I actually really want to use Data.Aeson
23:18:15 * hackagebot hw-json 0.0.0.3 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.0.0.3 (haskellworks)
23:18:16 <fatex> this also needs to work with ghcjs
23:18:23 <fatex> I meant "how do you suggest I use Data.Aeson" :-)
23:18:35 <srhb> Oh. :P
23:19:19 <srhb> fatex: Data.Aeson.Encode.encode with a fitting ToJSON instance, which I assume can be derived.
23:20:29 <srhb> fatex: Ie. data YourType = ... deriving (Generic); instance ToJSon YourType; -- now you should be able to use encode.
23:20:41 <srhb> ToJSON even.
23:20:43 <fatex> srhb: I think I almost have it working
23:20:49 <fatex> my main issue riht now is no longer encoding
23:21:00 <fatex> it's ghc complaining about ByteString vs String
23:21:06 <fatex> so I think it works (but can't verify yet)
23:21:22 <srhb> fatex: Maybe you need OverloadedStrings
23:21:29 <srhb> But it's hard to guess from this little data.
23:22:18 <apricity> is there a way to get integrated haskell documentation in emacs?
23:23:04 <fatex> apricity: you can try installing vim
23:24:50 <apricity> fatex: I'm actually a vim user for the most part, just trying both vim and emacs with haskell to see which works better
23:24:58 <fatex> apricity: use vim-haskell-now
23:24:59 <fatex> it's amazing
23:25:51 <fatex> srhb: got it working now
23:25:59 <fatex> srhb: thanks for all your help with debugging blindly w/ no info
23:26:08 <srhb> fatex: :-P
23:26:10 <fatex> srhb: I don't think I made a single paste or showed a single error; excellent debugging on you rpart
23:26:15 <srhb> Sure thing
23:57:04 <tpsinnem> hmh. if i do "(i,o,e,phandle) <- runInteractiveProcess foo bar Nothing Nothing" then is "forkProcess $ do waitForProcess phande ; ..." not supposed to work? I get "waitForProces: does not exist (No child processes)"
23:57:20 <tpsinnem> erm, s/phande/phandle
23:58:05 * tpsinnem types typos because offending code is on different computer than this irc
