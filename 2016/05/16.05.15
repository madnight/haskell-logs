00:01:34 <Fare> thanks a lot to all of you for your help!
00:02:15 <scshunt> yeah, I *think* this design will work
00:02:40 <scshunt> there's a couple little tricks I need to play though to make it actually work
00:02:53 <scshunt> but I think it will actually cut down on boilerplate
00:07:37 * hackagebot logging 3.0.4 - Simplified logging in IO for application writers.  https://hackage.haskell.org/package/logging-3.0.4 (aupiff)
00:07:37 * hackagebot graphviz 2999.18.1.0 - Bindings to Graphviz for graph visualisation.  https://hackage.haskell.org/package/graphviz-2999.18.1.0 (IvanMiljenovic)
00:09:08 <ertesx> scshunt: http://lpaste.net/163399
00:10:10 <ertesx> of course the phases are very similar…  i made the move types different to create an illusion of difference
00:11:20 <EvanR> ski: thx
00:27:03 <pkug> Hi, I am trying to think of an easy way to replicate a list interleaving some characters by matching their positions in another list, really like a Vigenere cipher exercise from haskellbook to repeat the key material on plaintext skipping the spaces: 'HEY', 'I DONT KNOW' -> 'H HEYH EYHE'.. so far couldn't come up with an intuitive solution, can anyone share a little hint?
00:28:13 <pkug> (little typo above, it should've been 'H EYHE YHEY')
00:36:00 <narendraj9> > dervie (x:xs) (y:ys) = if y == ' ' then dervie xs (y:ys) else x : derive xs ys; derive _ [] = []
00:36:01 <lambdabot>  <hint>:1:22: parse error on input ‘=’
00:36:18 <narendraj9> pkug: Something like this should work I guess.
00:36:43 <narendraj9> But there should be better ways of doing this. 
00:37:42 <narendraj9> > let dervie (x:xs) (y:ys) = if y == ' ' then y : dervie (x:xs) ys else x : derive xs ys; derive _ [] = []
00:37:43 <lambdabot>  <no location info>:
00:37:43 <lambdabot>      not an expression: ‘let dervie (x:xs) (y:ys) = if y == ' ' then y : derv...
00:37:59 <narendraj9> I seem to have forgotten how to define stuff. 
00:38:18 <Chousuke> maybe you didn't mean to type 'dervie'? :)
00:38:28 <narendraj9> > let derive (x:xs) (y:ys) = if y == ' ' then y : derive (x:xs) ys else x : derive xs ys; derive _ [] = []
00:38:29 <lambdabot>  <no location info>:
00:38:30 <lambdabot>      not an expression: ‘let derive (x:xs) (y:ys) = if y == ' ' then y : deri...
00:38:35 <narendraj9> Chousuke: :) Oh. Thanks :)
00:39:05 <narendraj9> I should just stop. :-D Or Maybe think of a cleverer way of doing it. 
00:41:29 <Chousuke> I prefer straightforward code to clever code :P
00:44:02 <Chousuke> Generally the less brainpower it takes to understand a function, the better.
00:47:25 <narendraj9> @let derive (x:xs) (y:ys) = if y == ' ' then y : derive (x:xs) ys else x : derive xs ys; derive _ [] = []
00:47:26 <lambdabot>  Defined.
00:47:41 <narendraj9> > derive "HEY" "I DONT KNOW"
00:47:42 <lambdabot>  "H EY*Exception: /tmp/mueval18566691791057418418.hs:(157,1)-(159,16): Non-ex...
00:48:28 <simpson> > transpose ["fixed", "width", "lines"]
00:48:29 <lambdabot>  ["fwl","iii","xdn","ete","dhs"]
00:48:49 <simpson> Oh, wrong operation, I see.
00:52:09 <narendraj9> @let derive (x:xs) (y:ys) = if y == ' ' then y : derive (x:xs) ys else x : derive (xs ++ [x]) ys; derive _ [] = []
00:52:10 <lambdabot>  .L.hs:157:1: Warning:
00:52:11 <lambdabot>      Pattern match(es) are overlapped
00:52:11 <lambdabot>      In an equation for ‘derive’:
00:52:35 <narendraj9> @undefine derive
00:52:36 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
00:52:53 <narendraj9> > derive "HEY" "I DONT KNOW"
00:52:55 <lambdabot>  "H EY*Exception: /tmp/mueval18566691791057418418.hs:(157,1)-(159,16): Non-ex...
00:53:30 <EvanR> There's currently no way to undefined just one thing, only this message explaining that its not possible, and the this message explaining the message
00:54:38 <narendraj9> @let derive' (x:xs) (y:ys) = if y == ' ' then y : derive' (x:xs) ys else x : derive' (xs ++ [x]) ys; derive' _ [] = []
00:54:40 <lambdabot>  Defined.
00:54:48 <narendraj9> > derive' "HEY" "I DONT KNOW"
00:54:49 <lambdabot>  "H EYHE YHEY"
01:06:54 <fred-fri> yesterday i wasked about options for getting started with haskell and was advised to use stack rather than haskell platform or cabal sandboxes, so i installed stack through http://docs.haskellstack.org/en/stable/install_and_upgrade/#arch-linux
01:07:20 <fred-fri> my understanding was that stack was used to create a separate environment for each project, but i cant find eg ghci-mod in the project i created
01:08:01 <fred-fri> or am i supposed to installl my os package version of ghci-mod?
01:14:57 <Jinxit> what's a good approach to code generation? (as in generating well formatted C code from haskell)
01:16:59 <ggVGc> Jinxit: in my experience, if you're generating a language like C and want nice formatted output, it's better to just spit it out however and run it through a formatting pass using something that already exists
01:17:03 <ggVGc> I bet there are many C formatters
01:17:08 <ggVGc> eh, beautifiers
01:17:20 <ggVGc> rather than try to generate it "nicely" from your code-gen
01:18:18 <puregreen> @hackage language-c -- if you meant “well-formed” by well-formatted (just in case)
01:18:19 <lambdabot> http://hackage.haskell.org/package/language-c -- if you meant “well-formed” by well-formatted (just in case)
01:19:00 <cocreature> clang-format can format your code
01:19:38 <Jinxit> puregreen: you're right, I mean both actually
01:19:43 <Jinxit> but not specifically C
01:19:46 <Jinxit> asking in general
01:20:54 <Jinxit> that one seems to create an AST specifically for C and then prettyprint it
01:20:54 <puregreen> I don't know whether it's the approach people generally use, but I'd go with “write a DSL for generating AST and then write a pretty-printer for AST”
01:20:56 <cocreature> usually it’s best to generate some ast (it can be limited to the language subset you actually need). once you have an ast you can get some sort of pretty printing fairly easily by simply indenting everytime you descend the tree
01:21:39 <puregreen> with the caveat that sometimes the AST is already written for you (language-c, language-javascript)
01:23:29 <Jinxit> I happen to have -an- AST, but it's not strictly the language target
01:24:02 <Jinxit> so build a basic AST for the language that covers my needs, translate to that, prettyprint?
01:24:50 <cocreature> that’s the approach I would take
01:24:59 <cocreature> or reuse an already existing ast for your target language
01:25:09 <Jinxit> yeah
01:26:34 <Jinxit> might go with C actually just to test it out
01:26:36 <Jinxit> thanks!
01:40:35 <tsahyt> Hello, I have a problem with cabal and stack. I'm creating a shared library exporting a C API for loading with a C++ project. for that I have a configure script which adds the appropriate runtime library to the cabal options. Compiling via cabal gives me an error in the configure stage about the rts library being a missing C library, but it compiles just fine and the library is actually linked into the
01:40:37 <tsahyt> resulting executable. Using stack however, the build process stops after the configure step and exits, meaning that no library is created. Can I force stack to compile anyway?
01:41:27 <tsahyt> alternatively, I guess fixing the error would be an option, but since rts is not a C library in the first place I don't know how to go about this at all
01:52:56 <fred-fri> should i install ghc-mod through cabal or my os package?
01:57:50 <gfixler> fred-fri: I feel like cabal would have a more updated version
01:58:02 <gfixler> unless your os updates packages often
01:59:06 <fred-fri> i was advised yesterday to get started with haskell using stack instead of cabal
01:59:20 <fred-fri> frankly i dont understand the difference and im very confused about so many things =)
01:59:51 <hvr> fred-fri: the community is somewhat divided about cabal and stack :-)
02:00:03 <sbrg> they are two tools that do roughly the same things. stack was the neater solution for a while and is really easy and convenient to use(because it will even download ghc for you), while cabal had some issues, which I believe most of which are fixed by now. 
02:00:09 <hvr> fred-fri: depending on whom you ask, you get recommended cabal or stack
02:00:52 <gfixler> fred-fri: cabal used to suffer an issue called "cabal hell"
02:01:08 <gfixler> fred-fri: it stores packages in a global place, so you couldn't have different versions of the same package
02:01:19 <gfixler> fred-fri: which lead to all manner of collisions and build issues
02:01:25 <fred-fri> i did set up a project using stack yesterday and can get it to run etc, but i was coding manually through text editor. now i want to set up a real environment and im really struggling because it seems like most ides want the path to ghc-mod etc. and my understanding of stack is that, rather than installing global OS level ghc, each project has its own. so wouldnt that be true of ghc-mod as well?
02:01:49 <gfixler> fred-fri: then it got sandboxes, where you set up a sandbox in each project, and everything gets installed/built separately for each
02:02:01 <gfixler> fred-fri: that mostly solved the issue, but it also means you're always downloading/rebuilding everything
02:02:07 <sbrg> fred-fri: stack has a global place for packages as well. you can install ghc-mod globally, and then add the correct path to your $PATH
02:02:24 <tsahyt> the difference being that stack's package list is curated
02:02:27 <sbrg> ^
02:02:42 <sbrg> all the package versions are known to work with the other packages
02:02:54 <gfixler> tsahyt: I thought the big addition was allowing different versions to be installed side-by-side
02:03:22 <tsahyt> yes that too, but due to the packages coming from stackage everything is supposed to be compatible
02:03:23 <fred-fri> ok so my current state is i have stack installed through http://docs.haskellstack.org/en/stable/install_and_upgrade/#arch-linux
02:04:04 <gfixler> tsahyt: now I'm doubting my earlier belief, because I hadn't thought about what it meant for curation
02:04:18 <gfixler> tsahyt: I was thinking it was a bit like nix, where each version gets its own cubbyhole
02:04:24 <tsahyt> as far as I understand you're limited to one snapshot at a time, but you can have different snapshots installed for different projects
02:04:32 <gfixler> tsahyt: but curation is about picking one version of each package that works together
02:04:40 <gfixler> tsahyt: ah, that's right
02:04:46 <gfixler> tsahyt: so it's still mostly sandboxing
02:04:53 <gfixler> tsahyt: but with curation
02:04:53 <tsahyt> in a way, yes.
02:05:06 <sbrg> fred-fri: then you're pretty much set. 
02:05:31 <fred-fri> sbrg, yeah i can create, build and run projects in stack just fine
02:05:37 <tsahyt> I wish I could get stack to ignore errors during configure stage and compile anyway
02:05:39 <tsahyt> cabal does that
02:05:42 <hvr> gfixler: otoh, cabal 1.24 starts having support for a nix-style global store
02:05:45 <gfixler> so then the handling of collisions and flxibility seems to be cabal < sandboxes < stack < nix
02:05:58 <hvr> gfixler: which obsoletes explicit sandboxes 
02:06:00 <tsahyt> and unless I can get stack to do it, or fix the error in some miraculous way, I'm stuck with GHC 7.8 for this project :/
02:06:30 <fred-fri> but i want to set up a real ide and not just use the text editor. and all ides require a path to ghc-mod, which stack didnt install for my project
02:07:04 <sbrg> fred-fri: I don't use ghc-mod but still have live checking of my code files. 
02:07:05 <hvr> gfixler: (i.e. this here: http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/ )
02:07:14 <sbrg> via flycheck-stack-ghc or some such (for emacs)
02:07:49 <sbrg> fred-fri: I personally gave up on ghc-mod because the developers were rather slow and support for stack took a while. i still hear people having problems with ghc-mod
02:08:04 <fred-fri> sbrg, i thought ghc-mod was required if you wanted auto completion etc
02:08:18 <fred-fri> i just feel so lost ive been researching environments all weekend with zero progress
02:08:23 <sbrg> nope. but it depends on the editor, I'd guess. what editor are you using?
02:08:30 <fred-fri> im using intellij
02:09:06 <sbrg> ah. well, I have no idea bout using haskell with intellij, unfortunately. you probably have to use ghc-mod, yeah. have you installed ghc-mod?
02:09:06 <fred-fri> theres four different mutually exclusive haskell plugins for intellij and all of them want paths to ghc-mod, hlint, stylish haskell
02:09:47 <sbrg> if you're not in a stack project, you can simply do: stack install ghc-mod and it will install it in the 'global project'. 
02:09:57 <fred-fri> what i dont understand is how to install those things. should i install them through stack? through my os package? through cabal?
02:10:12 <gfixler> hvr: very interesting - thanks for the link
02:10:23 <sbrg> fred-fri: there are various ways to do it, really. I would personally not install anything through the OS package manager and just stick to using stack for it. 
02:10:32 <fred-fri> oh i will try that
02:10:53 <gfixler> fred-fri: I've installed haskell things through ubuntu's repos, but they were usually very out of date
02:10:54 <sbrg> so If I had to ste up haskell on a completely new arch installation: pacaur -S stack; stack install ghc-mod; 
02:10:56 <gfixler> fred-fri: and never updated
02:11:32 <fred-fri> yeah
02:12:39 <fred-fri> so what are your environments and development flows like? im a java dev so i code in in intellij which automatically compiles for me. i trigger test runs and deploys to local server etc.
02:13:06 <fred-fri> i hear some haskell devs dev by loading modules into the repl or whatever its called and then play around, is that the norm?
02:14:33 <sbrg> fred-fri: I work in emacs, using haskell-mode and flycheck. I use the repl(ghci) through emacs, yes, and test things as I write code. running is just a matter of "stack exec --build <foo>" or running main through the repl
02:14:39 <tsahyt> okay so I'm calling a haskell function from C, which is supposed to fork a thread that does stuff. but apparently the thread just blocks. any ideas why that happens?
02:15:27 <sbrg> maybe you need -threaded? or does that not have any   effect on the FFI?
02:15:53 <tsahyt> I have ghc-options: -threaded in my cabal file
02:16:12 <tsahyt> it compiles to a shared object that is then dynamically loaded in C, maybe that has something to do with it?
02:16:21 <fred-fri> sbrg, runnign through stack exec build foo is what i did but that isnt interactive, it just runs what youve coded... ive heard a major advantage of haskell is being able to load a module and then interactively playing around with it in the interpreter, what are the best means of doing that?
02:16:55 <sbrg> yes
02:16:58 <sbrg> stack ghci
02:17:23 <sbrg> then just :r in the repl for :reload
02:19:11 <puregreen> fred-fri: I use Emacs and have code in the left pane and the interpreter in the right pane. Pressing C-c C-l reloads the code, and then I can switch to the interpreter pane and call functions from the module (or other imported modules)
02:20:23 <sbrg> ^
02:20:27 <sbrg> that's how I roll as well
02:20:41 <sbrg> emacs is an adventure of its own, however. 
02:25:40 <puregreen> fred-fri: however, Haskell's live-coding abilities are pretty limited (compared to Clojure, for instance). You can't replace functions while the code is running (or do pretty much anything else, I think), functions you've defined in the interpreter are lost when you reload the module, and generally I've noticed that when I'm writing anything more-or-less complicated, printf-style debugging becomes less painful than trying to
02:25:40 <puregreen> play with functions (this greatly depends on what kind of code you're writing, tho, as well as your level of competence)
02:27:42 <randomclown> Hey quick question, suppose I had a `data Expr = IntExpr int | LongExpr long` and `data Statement = PrintInt Expr | PrintLong Expr`. Is there a way for the compiler to ensure that only Exprs of the type `IntExpr` can go into `PrintInt Expr`?
02:27:54 <randomclown> Or does haskell need dependent types for that to work
02:28:18 <randomclown> s/int/Int/g s/long/Integer/g
02:29:08 <sbrg> puregreen: I have never found printf style debugging to be very useful in haskell due to purity. i find it somewhat unreliable to guess when stuff will be printed (because of non-strictness/laziness) and so on.
02:29:40 <sbrg> randomclown: make them separate types is one way
02:29:56 <randomclown> sbrg: won't that be pretty bloaty?
02:30:11 <cocreature> sbrg: depends on how IO instensive your code is. if it consists mostly of doing IO printf debugging works just as well as in any other language
02:30:18 <sbrg> cocreature: true
02:30:56 <sbrg> but doesn't help much for debugging semantically incorrect pure parts of your code. it's where haskell is hardest to debug, IMO. the debugger is nigh useless in my experience. though I haven't given it much of a chance.
02:31:23 <tsahyt> ahh, since I've been linking the runtime system explicitly into the shared object, -threaded has no effect. it's effectively a linking option, and I'm never having GHC linking an executable. So I have to link the threaded rts explicitly and now it seems to work.
02:31:24 <cocreature> I have never even tried using the debugger :/
02:32:42 <gfixler> puregreen: when you reload the code, does it literally type :r in the right pane?
02:33:50 <puregreen> gfixler: according to haskell-mode's process log, it types :load "path/to/module"
02:34:13 <gfixler> puregreen: is that call hidden from your view usually, though?
02:34:17 <puregreen> yep
02:34:26 <gfixler> puregreen: diabolical - any idea how it does that?
02:34:38 <gfixler> puregreen: separate shell or background process or something?
02:35:06 <puregreen> haskell-mode parses the output and changes some things, I believe
02:35:33 <gfixler> puregreen: interesting - I ask as I just use tmux send-keys from Vim to another split in tmux
02:35:45 <gfixler> sometimes - I'm fast, so I often just switch back and forth between the panes manually
02:36:06 <gfixler> but send-keys is literally sending key presses to the term, so I see :r, etc
02:36:21 <sbrg> i used to do that sa well
02:36:25 <sbrg> then I went full emacs
02:36:41 <gfixler> I may do that eventually
02:36:46 <gfixler> I've had a good 10-year run in Vim
02:37:12 <sbrg> ¯\_(ツ)_/¯ yeah, I ditched vim for emacs.
02:37:17 <gfixler> I've watched many videos on the wonders of emacs, though, and not really felt any stirring inside
02:37:29 <gfixler> org-mode seems interesting, but not useful to me, personally
02:37:34 <gfixler> it's super loved, though
02:37:52 <gfixler> I've watched several 1-hour long talks on it
02:38:34 <gfixler> the one thing that did seem interesting so far was the idea that the shell was just another buffer
02:38:45 <gfixler> and so you could interact with it on a textual level
02:38:51 <sbrg> i gave emacs a weekend last summer or some such. immediately converted. emacs is, IMO, a better vim than vim, heh.
02:39:10 <prohobo> well yeah
02:39:14 <prohobo> but dont say that to a vim user
02:39:16 <gfixler> Vim's a mess - I just love the language-of-keypresses philosophy
02:39:25 <gfixler> I'm a Vim user, but not part of the wars
02:39:32 <prohobo> emacs with vim mode is much better than vim
02:39:33 <sbrg> indeed. I can't live without vim editing. which is why I use evil-mode.
02:39:53 <prohobo> i actually use atom now
02:39:57 <prohobo> because it has vim mode
02:40:04 <prohobo> and looks a lot nicer
02:40:16 <gfixler> yeah, I had to go and graduate from art school, so I care about looks
02:40:17 <prohobo> easier to manage packages and such
02:40:24 <gfixler> a tick against emacs is how ugly it's looked for me
02:40:30 <gfixler> though I know it can look nice - I've seen it
02:40:50 <gfixler> but I don't care about flashy looks, so Vim with a nice color scheme/font is super great
02:45:27 <prohobo> ur uninvited from my birthday party
02:49:00 <puregreen> that's pretty evil
02:49:05 <puregreen> as a consolation, you're invited to mine
02:49:32 <gfixler> I wasn't going to any parties anyway; there's too much vimming to do.
02:49:48 <prohobo> :P
02:52:14 <pavonia> Any ideas why Data.ByteString.Lazy.readFile would give "openBinaryFile: permission denied" on a Windows system when trying to read a file, while my editor can read it without problems?
02:54:38 <pavonia> The file is locked for write access from another process, but still no idea why is can't read it
03:00:16 <gfixler> pavonia: is there a strict version of Bytestring's readFile?
03:00:27 <gfixler> pavonia: not sure how laziness would affect it, but I'm curious
03:00:56 <pavonia> There is, I'm trying that ...
03:01:31 <pavonia> Same error
03:03:19 <gfixler> Data.Bytestring.Lazy.readFile calls openBinaryFile f ReadMode
03:03:29 <gfixler> I'm guessing the issues is with openBinaryFile
03:04:34 <fred-fri> how can i see if ive installed ghc through stack or not?
03:06:56 <raichoo> fred-fri: stack exec which ghc
03:08:09 <fred-fri> test
03:08:28 <fred-fri> usr/bin/ghc so its using a global os package ghc it seems. odd, because i dont remember installing that
03:09:41 <rios> pl \x y -> x y
03:10:43 <rios> @pl \x y -> x y
03:10:43 <lambdabot> id
03:10:51 <rios> @pl flip $
03:10:51 <lambdabot> (line 1, column 7):
03:10:51 <lambdabot> unexpected end of input
03:10:51 <lambdabot> expecting white space or simple term
03:11:02 <raichoo> fred-fri: you can set `system-ghc: false` in your ~/.stack/config.yaml to force using the ghc installed by stack
03:11:31 <rios> @pl flip ($)
03:11:31 <lambdabot> flip id
03:13:20 <fred-fri> raichoo, youre supposed to be able to do this too but i seem to be missing something [fred-fri@laptop ~]$ stack --no-system-ghc Missing: COMMAND|FILE
03:13:51 <randomclown> is there a way to derive show for an instance of GADT?
03:13:57 <raichoo> fred-fri: stack --no-system-ghc ghci  
03:14:04 <randomclown> i.e. I have Expr a, but derive show on (Expr Int)
03:14:36 <raichoo> fred-fri: that should just start your repl. You need to tell stack what you want it to do.
03:14:53 <fred-fri> raichoo, i see
03:14:57 <fred-fri> in the yaml it is then
03:15:32 <randomclown> Ah found it
03:15:58 <raichoo> fred-fri: I've set this since I'm already have GHC 8.0.1 installed on my system and I want my stack projects to be unaffected by that.
03:16:25 <raichoo> fred-fri: YMMV :)
03:16:54 <fred-fri> raichoo, do you also set system-ghc: false in your individual project yamls?
03:17:02 <raichoo> no
03:18:12 <raichoo> To be honest, I never thought about doing that. It might also make sense.
03:20:44 <surganov> how to write CoArbitrary instance for `newtype Combine a b = Combine { unCombine :: (a -> b) }` ?
03:21:00 <fred-fri> raichoo, http://pastebin.com/awuSJRjB
03:21:48 <raichoo> fred-fri: mine is basically just that `system-ghc: false` line + the comments.
03:22:23 <raichoo> fred-fri: no curlies.
03:22:32 <fred-fri> i see, thanks
03:22:51 <raichoo> fred-fri: this might help. https://en.wikipedia.org/wiki/YAML
03:24:10 <fred-fri> indeed it does thanks
03:24:43 <raichoo> fred-fri: Sure thing, have fun!
03:31:08 <pavonia> Opeining the file using the Win32 functions also fails which is really weird
04:02:41 * hackagebot eventsourced 1.1.0.0 - Server-Sent Events the UNIX way  https://hackage.haskell.org/package/eventsourced-1.1.0.0 (richardTowers)
04:04:47 <troydm> is there a shortcut to return ()
04:04:49 <troydm> ?
04:05:00 <troydm> I mean someFun = return () ?
04:05:04 <troydm> like a shorter name
04:05:59 <puregreen> no, but if you have a longer function you can use void :: m a -> m () to avoid an explicit return () at the end
04:07:01 <puregreen> i.e. “someFun = void $ do a; b; ...” instead of “someFun = do a; b; ...; return ()”
04:08:06 <troydm> puregreen: yeah I know about void thx, was just wondering if there was some shorter form of return ()
04:09:38 <Maxdamantus> pure ()
04:09:59 <Maxdamantus> Might result in different type constraints.
04:10:47 <Maxdamantus> Was that one of the things they were fixing?
04:15:52 <cgrs> hi everyone!
04:16:24 <troydm> so I have bunch of a bunch of functions with different M a  types can I save those into record 
04:16:25 <cgrs> is there a way to use groupBy to group elements only equals to a value?
04:16:44 <troydm> like I want to save those into record without thinking about type
04:16:52 <cgrs> i mean: if i have a list like this [1,0,0,1,1,1,1,0,0,1]
04:17:00 <troydm> something like R { myFun :: M * } 
04:17:03 <troydm> ?
04:17:08 <cgrs> group only if they're equals to 1
04:18:08 <phadej> cgrs: filter before grouping?
04:18:41 <Maxdamantus> troydm: what do you do with the `myFun` fields?
04:18:56 <cgrs> phadej: that'd break the point of counting the maximum number of occurrences of the n number i'm trying to test
04:19:05 <cgrs> i'll start from the beginning:
04:19:17 <troydm> Maxdamantus: in some record
04:19:20 <cgrs> i'm making a connect four game for my classes
04:20:05 <Maxdamantus> troydm: yes. What do you do with the contents of that record?
04:20:29 <cgrs> and i'm checking the rows, if there are at least 4 or more cells with a 1 (but they have to be consecutive), player 1 wins
04:21:43 <troydm> Maxdamantus: save it for later calling
04:21:54 <troydm> for example I have two type of IO actions
04:22:04 <troydm> IO Bool and IO Int
04:22:25 <troydm> I want to save them into the same type of record despite them being of different types
04:22:35 <troydm> I could all cast them to IO () 
04:22:44 <dredozubov> parametrize the record with this type
04:22:47 <troydm> but I don't want to loose return type just in case if I'll need it
04:22:49 <Maxdamantus> There is no casting.
04:23:04 <dredozubov> data Rec a = Rec { field :: a, field2 :: .. }
04:23:33 <troydm> dredozubov: if I'll parametrize record I won't be able to save them into same list
04:23:54 <troydm> because then I would need to have different lists 
04:23:54 <dredozubov> you will, if you'll use an existentially quantified wrapper
04:24:05 <troydm> dredozubov: that, I think I need that
04:24:11 <Maxdamantus> troydm: how would you distinguish between `IO Bool` and `IO Int`?
04:24:20 <troydm> Maxdamantus: good question
04:24:25 <troydm> idk, rly
04:24:31 <troydm> haven'th thought about it yet
04:24:37 <troydm> hmm
04:24:52 <phadej> cgrs: filter after?
04:25:01 <dredozubov> why do you want to distinguish them in the first place?
04:25:08 <dredozubov> on the type leve
04:25:11 <dredozubov> level*
04:25:15 <Maxdamantus> Haskell doesn't have dynamic typing (aka subtyping); there is no `instanceof`
04:25:39 <dredozubov> Maxdamantus: there is Typeable, if you really want it
04:26:00 <cgrs> phadej: that'd be a solution, but i don't know how to filter a list of lists
04:26:46 <Maxdamantus> Yes. There is that library to emulate it through hacks.
04:27:09 * Maxdamantus suspects it's not standard in any way though.
04:27:17 <dredozubov> it's in base
04:27:26 <dredozubov> and it's totally legit
04:28:08 <Maxdamantus> I don't think that means it's standard.
04:28:14 <dredozubov> you want to have some representation of types if you want to investigate something happening at runtime for example, e.g. you can print the exact typeRep
04:28:30 <dredozubov> what do you mean by standard?
04:29:10 <Maxdamantus> Either specified in the report or portably implementable.
04:29:42 <dredozubov> report is so outdated, no one really cared for a long time :)
04:30:03 <dredozubov> haskell you see today is pretty much defined by ghc, not the haskell report
04:31:04 <Maxdamantus> If it requires non-standard language-specific hacks, I'd still say it's not really Haskell.
04:31:29 <dredozubov> the only haskell currently exists is the haskell defined by the GHC implementation
04:31:32 <Maxdamantus> Something like connecting to an X server doesn't match that criterion.
04:31:36 <dredozubov> like it or not, that's how it is
04:31:54 <hpc> there used to be many others
04:32:14 <hpc> ghc's deviations from the haskell standard are always made with the idea of using them to guide future standards
04:33:06 <dredozubov> hpc: sure, there are new committee members out there to resurrect it
04:34:43 <hpc> anyway, when you say "language with a specification defined by an implementation" i immediately think of something like perl where the spec is a suite of unit tests
04:34:57 <hpc> which haskell is very much not ;)
04:35:09 <dredozubov> hpc: are you sure?
04:35:19 <dredozubov> before i'm pretty sure you're wrong :)
04:35:26 <hpc> about perl or haskell?
04:35:32 <dredozubov> about haskell
04:35:45 <hpc> the haskell report is written in terms of denotational semantics
04:35:52 <maerwald> hpc: he still has a point
04:36:37 <maerwald> if you turn off GHCisms, maybe ~10% of the whole hackage ecosystem would compile probably less
04:36:47 <dredozubov> hpc: compare it to any modern/sufficiently advanced haskell library
04:37:00 <dredozubov> it uses plenty of extensions and features of modern ghc
04:37:23 <dredozubov> and the expressivity we get from it makes modern haskell what it is today
04:37:28 <dredozubov> not the outdated report
04:38:02 <dredozubov> maerwald: i would expect that the larger percentage than 10% will be broken
04:41:11 <gfixler> Anyone here do the NICTA course? I'm curious how long it takes to work through it.
04:41:40 <dredozubov> gfixler: depends on your familiarity with the concepts
04:42:00 <dredozubov> i haven't completed it, but liked it
04:42:32 <gfixler> dredozubov: sure, but I figured I could sample some data points
04:43:00 <gfixler> if everyone says it took months is different from a mix of "2 days" through "3 weeks," e.g.
04:43:44 <dredozubov> i've tried it during weekend and completed.. idk half of it or something
04:43:58 <gfixler> dredozubov: cool - that's a good data point
04:44:13 <dredozubov> but i was doing it very casually and i've been familiar with the most concepts and combinators
04:44:35 <gfixler> dredozubov: well, even being familiar with 6th grade math, it took me weeks to get through Khan's 6th grade math :)
04:44:51 <dredozubov> hehe, maybe, haven't tried that
04:44:58 <gfixler> dredozubov: but I watched every video
04:45:06 <gfixler> dredozubov: just decided to do all the math on the site
04:45:28 <gfixler> surprising amount forgotten/never learned
04:46:36 <dredozubov> i'd be pretty frustrated if i'll have to solve calculus problems
04:47:04 <dredozubov> it seems like my mind erased all the details after the exams
04:47:13 <dredozubov> and it was a long time ago :)
04:49:34 <gfixler> dredozubov: that's where I'm heading - I never had calc
04:49:37 <gfixler> always been curious
04:52:43 * hackagebot hw-prim 0.0.1.0 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.1.0 (haskellworks)
05:05:02 <nkaretnikov_> conal: fyi: your blog at http://conal.net/blog/ is not working: "error establishing a database connection"
05:12:43 * hackagebot gi-glib 0.0.2 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.0.2 (inaki)
05:15:10 <rios> @pl filter (\snake -> maxVal == getVal snake)
05:15:10 <lambdabot> filter ((maxVal ==) . getVal)
05:17:44 <nitrix> Pointfree all the predicates!
05:17:58 <maerwald> urghs
05:27:44 * hackagebot hw-prim 0.0.1.1 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.1.1 (haskellworks)
05:36:30 <hexagoxel> can i add a constraint to an (open) type family declaration?
05:43:52 <rios> @pl getSol maxVal = getF $ filter $ (maxVal ==) . getVal
05:43:52 <lambdabot> getSol = getF . filter . (. getVal) . (==)
06:15:30 <freinn> hi bros, I'm reading a book about Haskell but I don't get why the two expressions here: http://lpaste.net/163404 are equivalent, I don't know what is happening in the first one.
06:21:58 <greg`> my equational reasoning sucks and I would like to prove that (fmap
06:21:58 <greg`>         . fmap) = (Functor f , Functor g) => (a -> b) -> f (g a) - f (g b)
06:22:06 <greg`> any pointers?
06:24:02 <maerwald> (fmap . fmap) is just a clumsy way to go one level deeper
06:24:09 <maerwald> > (fmap . fmap) (+ 3) (Just $ Just 2)
06:24:11 <lambdabot>  Just (Just 5)
06:24:34 <greg`> understood, but I want to prove it
06:24:52 <greg`> chapter 16 of haskellbook, says work through the types
06:26:05 <hpc> :t fmap
06:26:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:26:07 <hpc> :t (.)
06:26:08 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:26:21 <maerwald> greg`: there are some stackoverflow threads that walk through the type process
06:26:29 <hpc> so, start with the root of the expression, which is (.)
06:26:45 <raek> freinn: take a look of the first expressions with parentheses added: (((fmap . fmap) sum) Just) [1,2,3]
06:26:46 <hpc> and apply it to fmap twice
06:26:52 <hpc> giving you two equations
06:27:08 <hpc> (b -> c) = (Functor f => (a -> b) -> f a -> f b)
06:27:35 <raek> expand the (.) and you get: ((fmap (fmap sum)) Just) [1, 2, 3]
06:27:37 <hpc> and (a -> b) = (Functor f => (c -> d) -> f c -> f d)
06:28:00 <hexagoxel> > ((.) . fmap) sum Just [1,2,3]
06:28:02 <lambdabot>  Just 6
06:28:26 <hpc> i would solve for a in the second equation first
06:28:51 <hpc> first you can show it's valid to begin with, because both sides of the equation have (->) at their root
06:29:08 <hpc> and then you'll find b = f d, a = (c -> d) -> f c
06:29:10 <raek> so the first epxression uses two different functors, Maybe and (e ->)
06:29:35 <raek> are freinn and greg` trying to solve the same problem?
06:29:53 <freinn> raek I think so, coincidence xDD
06:29:55 <hpc> repeat for b and c in the first equation, and you'll have two solutions for b
06:30:03 <raek> freinn: OK. :-)
06:30:08 <hpc> use the transitive property to solve for f d = (whatever the other one is)
06:30:09 <hpc> etc etc
06:30:40 <hpc> basically, type unification is a system of equations that needs to be solved
06:30:51 <greg`> hpc: thanks , ill work work through that
06:31:55 <hpc> also don't make the mistake i just made of using the same type variable on both sides of the equation
06:31:56 <greg`> hpc : ah I see
06:32:02 <hpc> give everything a unique name so you don't get confused
06:32:12 <greg`> lol ok good to keep them separate
06:32:24 <greg`> i can see the approach , thats all i need
06:32:27 <greg`> hpc: thanks
06:32:31 <raek> freinn: so I would read the first expression as "make a new variant of the Just function that apples the wrapped value to (fmap sum)"
06:33:32 <freinn> thanks raek, I will work on this
06:35:42 <raek> so the first argument of the leftmost fmap in "((fmap (fmap sum)) Just) [1, 2, 3]" is "fmap sum :: Maybe [Int] -> Maybe Int" (the function to run "inside" the function functor) and the second argument is Just :: [Int] -> Maybe [Int] (the function functor value)
06:36:38 <raek> the result will be a function of type [Int] -> Maybe Int, which you then apply to [1, 2, 3]
06:53:38 <freinn> thanks again raek, bye
06:54:14 <troydm> is there a function in Haskell that would print binary representation of number?
06:54:27 <troydm> for example Word8 binary representation
06:57:47 * hackagebot haskell-gi-base 0.15 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.15 (inaki)
06:57:49 * hackagebot haskell-gi 0.15 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.15 (inaki)
06:57:51 * hackagebot gi-glib 0.0.2.1 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.0.2.1 (inaki)
06:57:52 <geekosaur> > Numeric.showIntAtBase 2 Data.Char.intToDigit (46 :: Word8) "" -- ick
06:57:54 <lambdabot>  "101110"
06:58:08 <troydm> geekosaur: wow, thx
06:59:04 <Reshi> Do you guys have a haskell mug? 
07:01:14 <phadej> Reshi: actually I think I do
07:01:35 <Reshi> phadej: Did you buy it or get it printed ?
07:01:35 <kanye> hi
07:02:06 <phadej> Reshi: I got it as present, but IIRC it was baught from somewhere
07:07:47 * hackagebot human-readable-duration 0.2.0.1 - Provide duration helper  https://hackage.haskell.org/package/human-readable-duration-0.2.0.1 (yogsototh)
07:30:10 <puregreen> what's an example of a bad producer that is still fast?
07:30:50 <puregreen> I'm benchmarking a function and I want to benchmark it on a list that isn't produced by a good producer (and so there aren't any opportunities for fusing)
07:32:15 <eudoxia> hello folks, quick beginner question: periods in module names are (aside from the actual file/directory structure) just a convention to define nested modules, right?
07:32:48 * hackagebot eventsourced 1.1.1.0 - Server-Sent Events the UNIX way  https://hackage.haskell.org/package/eventsourced-1.1.1.0 (richardTowers)
07:33:00 <scshunt> eudoxia: yes
07:33:12 <scshunt> the Report doesn't consider the periods to be significant
07:33:21 <scshunt> most compilers map them to directory structure
07:34:04 <eudoxia> scshunt: thanks
07:34:20 <simpson> There's no scoping or parenting, if that's what you're asking. The module namespace is flat.
07:34:58 <eudoxia> simpson: that is exactly what I was asking :)
07:41:16 <toms_> I am trying to program a functional graph, but type errors prevent me from making it an instance of Functor. Any care to help me with this 10 line snippet?
07:41:18 <toms_> http://pastebin.com/cVyiVUAK
07:42:31 <scshunt> toms_: well let's look at what values you have and types you want
07:42:35 <scshunt> you have an a -> b
07:42:58 <scshunt> and a Graph a
07:42:59 <scshunt> and you want to produce a Graph b. To do that, you need a Context b and a Graph b. How do you get those?
07:43:05 <scshunt> oh, you also have a Context a
07:44:16 <toms_> Yes I'd like to be able to map a function over all Contexts
07:44:38 <scshunt> toms_: let's start with the Graph
07:44:44 <scshunt> you have a Graph a and a function a -> b
07:44:47 <scshunt> how do you get a Graph b?
07:45:31 <toms_> I would have written something like this: fmap f (Graph ctx rest) = Graph (f ctx) (fmap f rest)
07:46:36 <scshunt> toms_: right, but that doesn't work. You also need a way to go from a Context a and an a -> b to a Context b
07:46:45 <scshunt> (the "fmap f rest" is correct though)
07:47:33 <bitonic> Is there a reliable way to wait forever (e.g. `do mv :: MVar () <- newEmptyMVar (); takeMVar mv`), without getting a `BlockedIndefinitelyOnMVar`?
07:49:39 <toms_> scshunt: It doesn't work because the type is Graph a and not Graph (Context a). Right?
07:51:46 <sbrg> toms_: you're very close. Hint: why `f ctx` but `fmap f rest`? 
07:52:15 <Zemyla> Is there a list with compile-time fixed length and O(log n) access time?
07:52:52 <scshunt> toms_: no, that's not your issue
07:53:03 <scshunt> the issue is that ctx is a Context a
07:53:06 <scshunt> f is an a -> b
07:53:19 <scshunt> the only way this would work is if a ~ Context a, which is impossible
07:55:05 <jmcarthur> Zemyla: If it has compile time fixed length you could just make it O(1) access time by using an array.
07:56:37 <toms_> scshut: Maybe something like this: fmap f (Graph (inc, n, out) rest) = Graph (fmap f inc, f, fmap f out) (fmap f rest)
07:57:07 <Zemyla> jmcarthur: Yes, but that means updating it is O(n).
07:57:32 <nilof> O.o compiling with ghc gets a really huge (20x) speedup over the Haskell platform interpreter for some problems, but less than 2x for others
07:57:40 <Zemyla> And there's no guarantee that the array inside it is actually n long.
07:58:35 <f-a_> I have a problem with Data.ByteString.Char8
07:58:59 <f-a_> main = B.putStrLn (pack " ██ ██ aa ") <-- this does not display the, err,█  
07:59:17 <f-a_> is it something not meant to be done with Bytestrings?
08:01:05 <nitrix> I don't think Char8 is supposed to do so.
08:01:32 <maerwald> f-a_: why are you using Char8?
08:02:27 <geekosaur> f-a_, Char8 truncates. you will lose anything with a codepoint > 255 unless you explicitly encode the string into utf8
08:02:46 <maerwald> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad -- although I don't agree with all details of that section
08:02:51 <nitrix> f-a_: "" is a string literal; it has type [Char]. The Char8 module only uses the 8 lowest bits of the Char.
08:02:58 <f-a_> maerwald: https://hackage.haskell.org/package/simpleirc-0.3.1/docs/Network-SimpleIRC-Core.html#g:2 library I use uses bytestring and an example packed w/ char8
08:03:09 <f-a_> ohh I see
08:03:16 <f-a_> so if I use data.bytestring I should be ok?
08:03:31 <geekosaur> you still need to encode to utf8
08:03:54 <geekosaur> using ByteString instead of ByteString.Char8 means you work with Word8 values instead of Char values
08:04:14 <nitrix> f-a_: Yes, but it'll just be a bunch of arbitrary bytes. If you want to print UTF-8, it has to be encoded as UTF-8.
08:04:24 <geekosaur> which at least makes it more obvious that it does *not* handle Unicode codepoints, and if you want those then you need to encode to UTF8
08:04:28 <nitrix> f-a_: The Text module is designed with text and encodings in mind.
08:04:45 <f-a_> nitrix: yeah unfortunately the library I picked uses BS :s
08:05:00 <nitrix> f-a_: There are conversion functions from and to Text & Bytestring.
08:05:34 <nitrix> f-a_: https://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-UTF8.html
08:05:43 <nitrix> f-a_: Here that one even does it from String.
08:06:30 <f-a_> thanks nitrix geekosaur maerwald , I always get confuzzle with chars & co.
08:07:33 <nilof> after understanding monads, I have a question
08:07:38 <nitrix> nilof: Shoot.
08:07:45 <maerwald> nilof: see you later then :D
08:08:05 <maerwald> jk
08:08:12 <nilof> let's say I want to write a CLI program that continuously prompts the user untill you time exit, how would I do that?
08:08:18 <sbrg> asdf
08:08:23 <nilof> how do I get a main loop?
08:08:31 <nitrix> nilof: forever; until.
08:08:56 <exio4> fix $ \loop -> do :P 
08:09:04 <exio4> nitrix: how would you "escape" the forever?
08:09:08 <nitrix> :t until
08:09:09 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
08:09:34 <nitrix> exio4: In the forever case, you can't, afaik; unless you throw an exception.
08:10:29 <exio4> the nicest way I can think of is a fix $ \loop -> do { x <- getLine; when (x /= "exit") loop; } 
08:10:33 <nilof> can I pass a state from each iteration to the next, like for example if I want to make a simple text based game?
08:10:34 <nitrix> :t unless
08:10:35 <lambdabot> Applicative f => Bool -> f () -> f ()
08:10:55 <nitrix> nilof: https://github.com/nitrix/lspace/blob/master/src/Main.hs#L59
08:11:00 <nitrix> nilof: See mainLoop.
08:12:22 <nitrix> It's very naive but it's the same principle. Every language even does it similarly; a recursive loop and a short-circuiting condition.
08:12:49 * hackagebot gi-glib 0.0.2.2 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.0.2.2 (inaki)
08:13:49 <toms_> scshunt: I would like to give the function that fmaps over the graph the full context though. I'd like the function to be (f -> Context a)
08:15:10 <EvilMachine> Hi. It seems that on my system, when -XCPP is turned on, it can’t find ffi.h, which resides at /usr/lib/libffi-3.2.1/include/ffi.h here. Am I right in assuming ffi.h shouldn’t reside there?
08:15:13 <toms_> I mean (Context a -> Context b)
08:15:19 <EvilMachine> (it = GHC)
08:18:50 <toms_> sbrg: Because I'd like the function have access to each Context. Thats why `f ctx`
08:26:21 <enthropy> is there a standard newtype that composes functor? And could it have instances of everything in the "linear" package?
08:27:00 <phadej> enthropy: composes Functor?
08:27:28 <enthropy> phadej: http://hackage.haskell.org/package/applicative-extras-0.1.8/docs/Control-Applicative-Compose.html but maybe that one isn't the original
08:27:36 <phadej> http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html 
08:28:02 <phadej> that one is in base-4.9.0.0
08:28:09 <phadej> is moved*
08:28:17 <enthropy> thanks phadej
08:33:38 <EvilMachine> GHC 7.10.3, when using -XCPP, seems to look for ffi.h, but can’t find it. All *I* could find, were /usr/lib/ghc-7.10.3/include/HsFFI.h and /usr/lib/libffi-3.2.1/include/ffi.h. So what do I do?
08:40:46 <geekosaur> --with-ffi-includes=/usr/lib/libffi-3.2.1/include ?
08:41:10 <geekosaur> (systems do that when they need to support multiple libffi versions concurrently)
08:41:44 <geekosaur> you may also need the corresponding --with-ffi-libraries=...
08:58:54 <nilof> :t (+)
08:58:55 <lambdabot> Num a => a -> a -> a
08:59:07 <nilof> huh, that is a nice function of the chatroom
09:02:30 <nilof> ah, until is essentially the same as nestwhile in Mathematica
09:04:00 <f-a_> ok, I am now using 'proper' bytestrings (instead of Char8), but now I got a problem.
09:04:14 <f-a_> I would like to do B.split '\n' msg <-- how to encode '\n' in word8?
09:04:50 <geekosaur> > ord '\n'
09:04:52 <lambdabot>  10
09:05:10 <f-a_> :t ord
09:05:12 <lambdabot> Char -> Int
09:07:05 <f-a_> thanks, fromIntegral . C.ord did it
09:07:51 * hackagebot process-extras 0.4.1.3 - Process extras  https://hackage.haskell.org/package/process-extras-0.4.1.3 (DavidFox)
09:08:38 <Cale> f-a_: Note that all the stuff in Data.ByteString.Char8 still works on the Data.ByteString type
09:09:03 <Cale> f-a_: The type itself is the same type, the only difference is in the functions which act on it.
09:09:12 <nilof> ooo
09:09:14 <f-a_> I see, thanks
09:09:21 <nilof> just realized I could curry the bind operator
09:10:08 <Cale> f-a_: The reason people recommend not using Data.ByteString.Char8 isn't so much because Data.ByteString would be better, but that if you're working with text, the Data.Text module is much better.
09:10:15 <Cale> (typically)
09:13:08 <f-a_> Cale: roger that. Since in this case I have a lib which takes BS, what's the best course of action. Do everything I can with Text and then convert it to BS, right?
09:13:18 <f-a_> (encodeUtf8)
09:13:41 <Cale> f-a_: Yeah, that would probably be good.
09:14:06 <f-a_> I see, thanks
09:27:09 <ryantrinkle> is there a flag that adds HasCallStack to everything?
09:44:38 <scshunt> ugh
09:44:49 <scshunt> folding over monads is the worst
09:45:05 <scshunt> foldrM from Data.Foldable is more consistent in general
09:45:11 <scshunt> but it doesn't support discarding values
09:45:20 <scshunt> (that is, there's no foldrM_)
09:45:33 <scshunt> foldM_ works, but it swaps argument order and is only a right fold
09:45:34 <scshunt> whyy
09:47:47 <enthropy> lovely that RecordWildCards wasn't renamed to NamedFieldWildCards
09:52:53 * hackagebot process-extras 0.4.1.4 - Process extras  https://hackage.haskell.org/package/process-extras-0.4.1.4 (DavidFox)
10:12:01 <montagy> i use xml-conduit and html-conduit parse html,i expect nameLocalName "p", but it give me "P",is it wired?
10:26:01 <cgrs> hi again!
10:26:58 <cgrs> i'm trying to get the list of indexes of  the diagonal of a matrix (not needing to be square) starting from a coordinate
10:27:27 <cgrs> and i can't understand how to do that with, for example, comprehension lists
10:32:40 <Rasmusolle> http://tinyurl.com/jfcurn5
10:32:54 * hackagebot zip 0.1.3 - Operations on zip archives  https://hackage.haskell.org/package/zip-0.1.3 (mrkkrp)
10:33:14 --- mode: ChanServ set +o monochrom
10:33:19 --- mode: monochrom set +b *!*@78-67-125-136-no247.tbcn.telia.com
10:33:19 --- kick: Rasmusolle was kicked by monochrom (Rasmusolle)
10:33:27 --- mode: monochrom set -o monochrom
10:33:41 <marcx> nsfw i guess? :P
10:33:49 <cgrs> spam i think
10:34:52 <cgrs> anyone that could help me with my problem?
10:37:59 <Jinxit> just count to min m n
10:38:49 <nilof> hmm, I'm trying to figure out why this won't compile:
10:38:51 <nilof> main = until False ((>>= putStr) >> readLn) "1" 
10:38:57 <cgrs> Jinxit: i don't undesrtand
10:39:06 <marcx> :t until
10:39:17 <marcx> > "hello"
10:39:19 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
10:39:20 <lambdabot>  "hello"
10:39:32 <marcx> nilof False is not (a -> Bool)
10:39:46 <nilof> ah right
10:41:29 <monochrom> use "forever" from Control.Monad
10:41:49 <nilof> :t forever
10:41:50 <lambdabot> Monad m => m a -> m b
10:42:25 <nilof> Does it have an exit condition though? Was thinking of replacing false with something else evenetually
10:42:48 <monochrom> no, it doesn't
10:43:16 <nitrix> nilof: There are `until` and `unless` for that.
10:43:43 <monochrom> if I had an exit condition, I wouldn't look for a Bool-based loop construct. since my exit condition may have nothing to do with Bool at all.
10:44:03 <monochrom> so I would just write my own recursion. so-called "exit" simply means don't recurse.
10:44:29 <monochrom> and this works even better if I have multiple "exit" conditions at multiple places
10:45:02 <monochrom> there is no loop function that covers all possibilities
10:45:25 <nilof> well, what I was planning to do was to give it an IO-based exit condition
10:45:27 <monochrom> there is one covering while-loop, but like I said it's Bool-based which is boolean blindness.
10:46:58 <hjljo> cgrs: something like [(n,n) | n <- [1..min rows cols]] ?
10:47:48 <monochrom> "unless" doesn't loop
10:48:26 <marcx> nilof write your own loop. or just use recursion
10:48:38 <cgrs> hjljo: yes, that works, but if i have to start in other position, like (1,0)?
10:48:45 <cgrs> *want to
10:49:00 <Cale> nilof: main = do v <- getLine; unless (v == "quit") $ do putStrLn v; main
10:50:57 <Cale> cgrs: something like [(n+1,n) | n <- [1..min (rows-1) cols]] ?
10:51:12 <cgrs> Cale: that was i was thinking of, thanks
10:51:17 <cgrs> i'll keep trying
10:52:43 <nilof> huh, reading the definition of forever helped
10:53:37 <nilof> so basically, I can modify it to say, pattern match for an exit case on the input and calling itself with the input otherwise?
10:54:31 <monochrom> yes
10:55:57 <marcx> @src forever
10:55:57 <lambdabot> forever a = let a' = a >> a' in a'
10:56:14 <cgrs> Cale: my problem is that it surpasses the boundaries of the list
10:57:11 <Cale> cgrs: Well, be careful about what your bounds are
10:57:35 <cgrs> Cale: thanks, i'm going on that xD
10:57:47 <monochrom> perhaps use "parallel list comprehension"
10:58:37 <cgrs> Cale: done :D 
10:58:48 <cgrs> diag1i (x,y) t = [(a+x0,a+y0)| a<-[0..min n m], (a+x0)<n, (a+y0)<m]
10:59:01 <cgrs> where (x0,y0) are the starting points of the diagonal
11:00:22 <Cale> cgrs: maybe you want a <- [0 .. min (n-1) (m-1)]
11:01:12 <cgrs> Cale: yes, right ^^'
11:01:15 <Job316> hi - I'm having some trouble with an example from learn you a haskell re state: http://lpaste.net/163411
11:01:25 <Job316> says State isn't being imported, but I see it in the import list
11:01:28 <Job316> what am I missing?
11:01:35 <cgrs> Cale: but it still overflows
11:02:23 <monochrom> Job316: "pop = state $ \(x:xs) -> (x,xs)". there is an API change after LYAH was done
11:02:31 <Cale> Job316: Control.Monad.State now defines the State monad in terms of StateT
11:02:47 <Cale> So, yeah, what was once the State data constructor is just the state function.
11:03:22 <Cale> Another thing is that you don't have to indent every line of your module like that
11:03:48 <monochrom> you also need to know: type name ≠ data constructor. type name "State" is imported. data constructor "State" no longer exists.
11:04:29 <Job316> LYAH? also, can you give me a hint as to how I might go about fixing it?
11:04:43 <monochrom> LYAH is the book you're reading
11:04:48 <Job316> ah right
11:04:50 <Job316> acronyms
11:05:04 <monochrom> I have already given the replacement.
11:05:25 <Job316> oh so it is
11:06:40 <Job316> so state is a variable that takes a state transforming function and returns the new monad wrapped value?
11:06:53 <Job316> so the state itself is somewhat more in the background now?
11:08:42 <monochrom> I don't understand the "background" analogy. but yes.
11:09:10 <monochrom> generally I don't understand any analogy. except the ones I invented.
11:09:46 <marcx> .
11:10:07 <Aleksejs> Hello, probably my question is for #haskell-blah, as I couldn't find the answer: why Haskell creators chose $ sign for application? Why not any other symbol?
11:10:20 <Job316> ah. the idea was instead of returning (s,a) it just returns m a
11:13:43 <scshunt> it's incredible how quickly my game engine has become a mess
11:14:57 <monochrom> time to use a mix of literate programming and aspect-oriented programming to untangle it
11:17:55 * hackagebot optparse-helper 0.1.0.0 - Helper functions for optparse-applicative.  https://hackage.haskell.org/package/optparse-helper-0.1.0.0 (pharpend)
11:19:45 <monochrom> they both allow you to dissociate how-to-show-code-to-humans from how-to-show-code-to-computer
11:19:56 <nilof> all right, from looking at forever I ended up trying:  let spam = readLn >>= putStr >> putStr "\n" >> spam   , and worked from there by adding cases
11:20:04 <nilof> ended up learning quite a bit
11:20:54 <monochrom> have you used recursion before?
11:21:06 <nilof> yes, but not for IO functions
11:21:41 <nilof> or with monad bind operators
11:21:46 <Cale> Time to use a mix of <adjective> programming and <noun>-oriented programming to <positive-sounding verb> it.
11:22:56 * hackagebot optparse-helper 0.2.0.0 - Helper functions for optparse-applicative.  https://hackage.haskell.org/package/optparse-helper-0.2.0.0 (pharpend)
11:25:46 <geekosaur> Aleksejs, actually that is better asked on the haskell-cafe mailing list as few of the people who would know are on IRC
11:25:48 <nilof> I had always thought about recursive functions as necessarily involving a stack which involved execution at the lowest level first, but monad bind operators add a lot of flexibility
11:25:52 <monochrom> "<noun>-oriented" is a special case of "<adjective>"
11:26:34 <monochrom> and 2 is a special case of natural numbers
11:26:59 <monochrom> So, time to use a mix of (<adjective> programming)* to <positive-sounding verb> it
11:32:56 * hackagebot blatex 0.1.0.9 - Blog in LaTeX  https://hackage.haskell.org/package/blatex-0.1.0.9 (2016rshah)
11:33:50 <Cale> nilof: Well, there's nothing really recognisable as a call stack here. There is a stack which is used to basically keep track of what is waiting for an expression to be finished evaluating, basically for the purposes of pattern matching.
11:35:47 <Cale> The binds themselves are just gluing together descriptions of what actions should be performed, and of course those descriptions can be recursively defined like anything else.
11:38:39 <nilof> hmm, would I have a stack if I wrote let spam = readLn >>= putStr >> putStr "\n" >> spam >> spam   ?
11:38:58 <monochrom> yes for that one
11:39:20 <nilof> so the key ingredient is tail recursion
11:39:21 <monochrom> but no for the previous just-trying-to-be-a-loop one
11:39:35 <monochrom> yes actually tail-call is relevant for IO
11:40:26 <monochrom> because IO is where everything you learned from imeprative programming applies again.
11:40:46 <monochrom> especially "events happen in code order, more or less"
11:42:29 <nilof> I like how Haskell relaxes execution order from (essentially) a time coordinate to a causal structure
11:42:40 <nilof> from an ordered set to a partially ordered set
11:43:04 <nilof> you specify what causes what instead of what happens first
11:43:10 <latro`a> following what cale said a bit ago, my impression is that if you try to *guess* how GHC works, you are inevitably wrong
11:43:52 <nilof> that sounds a lot like the laws of physics
11:51:42 <nilof> hmm, with cases choosing recursion calls, that also means I can do things that can't be done in imperative languages that have no goto function
11:51:52 <nilof> inb4 glorious spaghetti code
11:52:36 <nilof> with functions instead of labels
11:52:56 <buttons840> any suggestions on how to handle database migrations with postgresql-simple?
11:53:02 <nilof> and bind tail call instead of goto
12:05:37 <posi> Hey everybody, help me say smart things in my reading club about http://research.microsoft.com/pubs/74063/beautiful.pdf. I know haskell a little bit, but I am far from an expert. I learned it and was interested in school! Which was about the same time as this paper.
12:07:01 <monochrom> what is a reading club?
12:07:15 <monochrom> and why do people have to say smart things in a reading club?
12:07:58 <monochrom> can it not be a dumb question that turns out to beg a pretty deep question?
12:08:01 <buttons840> a reading club is a club where people read -- (sorry) it's a group that all read the same interesting thing and then later get together to talk about it
12:08:07 <buttons840> and say smart things apparently :)
12:08:33 <hpc> i want to see the reading club where the reading list is 50 shades of grey, the daily mail, and a 3000 year old tablet complaining about the poor quality of grain
12:08:36 <monochrom> for example "what are numbers?" is not a smart thing to say, but it can start a deep discussion
12:09:04 <monochrom> similarly, "what is concurrency?"
12:09:25 <hpc> i was about to answer "what are numbers?" and i just involuntarily stopped for a moment and went "hmm"
12:09:56 <buttons840> posi: according to simon marlows execelent book "STM" is an implementation detail, the actual language features is "atomic memory block" when you can make changes to several variables and all the change either succeed or fail, or automatically retry if needed like we have in haskell
12:10:35 <monochrom> it's my favourite counter-question to "what are monads?"
12:11:10 <posi> monochrom: we have a book club
12:11:10 <mauke> what *are* birds?
12:11:14 <monochrom> the subtext being: if you know how to explain numbers to the innumerate, then I can explain monads to you, using your very explanation strategy.
12:11:14 <posi> monochrom: sorry i got distracted
12:11:27 <posi> secretly asked that question to a bunch of people
12:11:31 <posi> because i never expect a response
12:11:34 <posi> i am sorry for the rudeness
12:11:36 <monochrom> the subsubtext being: if you can't, then I can't
12:11:44 <posi> let me synchronize 
12:12:18 <posi> cool
12:12:22 <posi> thanks for the interesting questions
12:12:27 <posi> i will attempt to answer them for myself
12:16:04 <Job316> Hi - I'm now mucking about with state, trying to replace a simple test IO interaction with one using state, but am running into a type error I can't figure out: http://lpaste.net/163413
12:16:27 <Job316> It says it wants an int, but I specifically told it it wants an IO
12:18:10 <geekosaur> other way around, actually
12:18:18 <Job316> hmm?
12:18:44 <mauke> Job316: you told it it wants an Int
12:19:03 <mauke> counter' :: State ... Int
12:19:20 <Job316> oh I might have this backwards
12:19:35 <Job316> I see, let me take a look
12:19:39 <Job316> thank you
12:20:03 <dolio> The first argument is the state type.
12:21:09 <Job316> yeah I sure do have it backwards
12:21:10 <Job316> thank you
12:24:27 <posi> what are numbers?
12:26:00 <Job316> posi: :i Num
12:26:45 <posi> heh
12:26:45 <posi> ok
12:32:19 <enthropy> > sortOn (negate . length) . group . sort $ "apple pie is the best thing ever"
12:32:21 <lambdabot>  ["      ","eeeeee","iii","ppp","ttt","hh","ss","a","b","g","l","n","r","v"]
12:33:20 <enthropy> is that the best way to tally "votes"? What if we know something about the number of voters / candidates?
12:33:29 <mauke> > sortBy (flip (comparing length)) . group . sort $ "apple pie is the best thing ever"
12:33:31 <lambdabot>  ["      ","eeeeee","iii","ppp","ttt","hh","ss","a","b","g","l","n","r","v"]
12:34:21 <mauke> you could use an array from candidates to votes
12:50:57 <pyon> Which is zipping/unzipping: going from the root of a tree to the leaves, returning to the root?
12:52:10 <zennist> is there an IO equivalent of TQueue for thread safe queues?
13:00:25 <Aruro> how do i map over every second elem of list? i'th?
13:02:17 <enthropy> :t \f xs -> zipWith ( \b x -> if b then f x else x) (cycle [True,False]) xs
13:02:19 <lambdabot> (c -> c) -> [c] -> [c]
13:03:14 <hexagoxel> > sortBy (flip $ comparing snd) $ M.toList $ M.fromListWith (+) $ (,1) <$> "apple pie is the best thing ever"
13:03:18 <lambdabot>  [(' ',6),('e',6),('i',3),('p',3),('t',3),('h',2),('s',2),('a',1),('b',1),('g...
13:03:46 <Aruro> ok, so there is nothing standard?
13:03:55 <Aruro> like mapMn's
13:05:06 <Aruro> using n'th tuple or list of length n filled with [True,False... seems elaborated :(
13:05:39 <hexagoxel> enthropy: if your input is lazy, this is space O(n) instead of O(m).
13:06:49 * enthropy is actually starting with IntMap Int, so probably there's better reason to do it with some kind of unionsWith
13:07:42 <hexagoxel> huh, what is the key in the input?
13:12:16 <Aruro> data.list has all theses general functions, strange they did not generalized map
13:14:19 <Cale> Aruro: map doesn't have an Int argument
13:14:40 <Cale> (or result)
13:14:49 <Smoke_Max> Hey guys, I have a question about optparse-applicative. Can I embed input validation in the Parser definition of my datatype somehow? Say I have an Integer field that must be greater than 1, is that possible?
13:15:03 <hexagoxel> Aruro: use split's or extra's chunksOf & fmap _ & concat
13:15:21 <Aruro> Cale: general map does
13:15:22 <hjljo> you have access to the index with lens' "imap"
13:15:30 <marcx> I think recursion would be cleanest way to implement it
13:15:40 <marcx> and probably most efficient
13:15:41 <hjljo> i agree w/ marcx if you're not using lens
13:15:43 <Aruro> marcx: yes, that is clear :)
13:15:43 <Cale> Aruro: hm?
13:16:04 <Aruro> Cale: general map is map which maps nth element? false?
13:16:26 <marcx> hjljo I'd be interested to see lens solution 
13:16:29 <Cale> Well, that's actually a less general operation than map is in some ways
13:16:33 <Cale> :t map
13:16:34 <lambdabot> (a -> b) -> [a] -> [b]
13:16:47 <Cale> map can change the type of the elements of the list
13:16:48 <puregreen> marcx: lens literally just defines an “imap”
13:16:57 <marcx> :t imap
13:17:01 <puregreen> marcx: and a bunch of other generalisations of list functions
13:17:03 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
13:17:15 <hjljo> >imap (\i x -> if i `mod` 2 == 0 then 10 * x else x) [1,2,3,4,5]
13:17:17 <Cale> Just adjusting the nth element of a list is a weird thing to do -- you probably don't want to be using a list if that's an operation you need
13:17:33 <Aruro> Cale: why wierd?
13:17:49 <hjljo> do i need a space after the >
13:17:51 <Cale> Aruro: Well, it's similar to writing a loop which does something different on its nth iteration
13:17:52 <Squarism> Im a total haskell newb. Im implementing a game and want to shuffle a deck. I found this https://wiki.haskell.org/Random_shuffle . It provides an "if you want to avoid using IO" example. I wonder why i would want to avoid that? is "IO" too coarse grained / unspecific or what?
13:17:52 <puregreen> marcx: they're also surprisingly non-optimal (given that the rest of lens seems super-optimised)
13:17:52 <hjljo> > imap (\i x -> if i `mod` 2 == 0 then 10 * x else x) [1,2,3,4,5]
13:17:54 <lambdabot>  [10,2,30,4,50]
13:18:55 <Cale> But yeah, the general trick for cases where you want to perform an operation dependent on the indices of a list is to apply zip [0..]
13:19:05 <Cale> and then use whatever higher order function is appropriate from there
13:19:51 <Aruro> hjljo: yep, something like that, index map
13:19:55 <Cale> Lens defines imap, but if you don't feel like pulling in all of lens to get it,  imap (\i x -> ...) xs  is the same thing as  map (\(i,x) -> ...) (zip [0..] xs)
13:20:16 <hjljo> yeah don't depend on lens just for imap :3
13:20:29 <enthropy> hexagoxel: those IntMap Int are bijections (I think... I really mean that once you've seen (1,2) that means you can't have a (1,9) or a (9,2))
13:20:54 <enthropy> and all the numbers go from 1 to some N
13:20:58 <hjljo> at least not for the list specialized version
13:21:18 <Aruro> Cale: yes, using zip [0..] for indexing seems less ugly.
13:21:37 <Aruro> Cale: than other non lens solutions
13:25:00 <Aruro> (a->a)->Num i->[a]->[a] seem pretty nice general type to me. to completely ignor it.
13:27:14 <dolio> Or even better, zipWith.
13:27:31 <EvanR> i have some tricky abstraction issue here
13:28:13 <EvanR> right now i can do A m1 v1 -> A m2 v2 -> A (m1,m2) (v1,v2)
13:28:22 <EvanR> heres the code http://lpaste.net/163415
13:28:39 <EvanR> but it should work and be more convenience to do this for any record type
13:28:47 <EvanR> but i cant figure out how to genericize it
13:29:08 <EvanR> (i determined function types and sums wont work)
13:29:50 <Cale> Right, you can zipWith (\i x -> ...) [0..] xs
13:30:14 <dolio> (Σ i:I. A (m i) (v i)) -> A (Σ i:I. m i) (Σ i:I. v i)
13:31:20 <jmcarthur> EvanR: Do you ever expect to read out that first field without applying one of the function fields to it?
13:31:30 <EvanR> sure
13:31:41 <EvanR> you should be able to see and modify the m at any point
13:32:08 <jmcarthur> EvanR: I was going to say that if you were okay with making it an existential then this type could easily just become an Applicative instance.
13:32:27 <EvanR> i can make it biapplicative, but it would not function correctly
13:32:41 <jmcarthur> I don't see how you could even make it biapplicative
13:32:42 <EvanR> because the functional animation doesnt appear in the result, so it cant be modified
13:32:43 <Aruro> Cale: zipWith seem to be most general solution of this case
13:32:55 <jmcarthur> The m appears in both positive and negative positions.
13:33:12 <Squarism> Im a total haskell newb. Im implementing a game and want to shuffle a deck. I found this https://wiki.haskell.org/Random_shuffle . It provides an "if you want to avoid using IO" example. I wonder why i would want to avoid that? is "IO" too coarse grained / unspecific or what?
13:33:18 <EvanR> true, so you cant
13:33:52 <EvanR> so thats another reason it wont function
13:33:58 <EvanR> its gotta be products
13:34:21 <jmcarthur> EvanR: What kind of data is going to be stored in m?
13:34:25 <EvanR> anything
13:34:34 <dolio> Oh wait, that shouldn't be sigma.
13:34:37 <dolio> It should be pi.
13:34:41 <EvanR> ah
13:34:45 <jmcarthur> It just seems like a somewhat unusual type to me.
13:34:45 <EvanR> let me reread that with pi ;)
13:34:55 <EvanR> its a modifiable animation
13:35:35 <EvanR> dolio: yes exactly
13:37:34 <hpc> Squarism: part of good programming is making what a thing can do as narrow as you can
13:37:59 <Squarism> hpc, ok - get it
13:38:01 <hpc> Squarism: such as making sure truecrypt doesn't open any network connections
13:38:01 <Cale> Squarism: IO actions can only be executed by other IO actions
13:38:25 <hpc> a random shuffle of a deck doesn't require opening files or whatnot, so why have IO
13:38:26 <EvanR> jmcarthur: after using mapView, the model remains as is, and can be modified at will (keeping the type the same) and will be reflected immediately in the view
13:38:32 <Cale> Squarism: So, for example, if you wanted to make a function of type String -> String which made use of the shuffler somehow, then having it be in IO wouldn't suffice.
13:38:34 <Squarism> but using the StdGen approach, i need to redfine my main right?
13:39:07 <hpc> you would need main to pass the rng into the shuffle logic, yes
13:39:16 <Squarism> okej
13:39:23 <hpc> because without IO you can't get a truly random seed
13:39:45 <Cale> Well, you probably want to get a StdGen from IO, but the key there is that you can get your initial StdGen by executing newStdGen, and then pass that along to the functions which need a supply of random values
13:39:47 <EvanR> 23781273443 heres a truly random seed, just type it into the code
13:39:55 <Squarism> i see this: 
13:39:56 <Squarism> shuffleIO :: [a] -> IO [a]
13:39:56 <Squarism> shuffleIO xs = getStdRandom (shuffle' xs)
13:39:56 <hpc> EvanR: 4 is better
13:40:04 <EvanR> yeah nothing up my sleeve
13:40:25 <hpc> it's the expected result of a fair d6 roll
13:40:29 <hpc> guaranteed to be random ;)
13:40:34 <Squarism> is that cheating in how StdGen is retrieved?
13:40:44 <koala_man> my last several shellcheck releases has had various package failures. I'ev already verified the next one on fresh debian/ubuntu/centos installs, but would anyone be willing to help verify that it builds on other configurations before I publish it? https://www.shellcheck.net/ShellCheck-0.4.4.tar.gz
13:40:47 <jmcarthur> EvanR: So it's basically a Store.
13:40:53 <dolio> EvanR's is obviously better, because the space is much larger than 6.
13:41:11 <Squarism> Cale, ok
13:41:18 <hpc> Squarism: that will be fine
13:41:39 <hpc> although i might even go further, because using getStdRandom you can change the global rng with shuffle'
13:41:56 <EvanR> jmcarthur: i think so, maybe if you reverse the args to the animation function it can be represented as a Store
13:42:13 <EvanR> does that have this fusing operation?
13:42:34 <hpc> simply not being in IO removes a literal world full of bugs anyway :D
13:42:47 <jmcarthur> no
13:42:52 <jmcarthur> brb
13:42:58 * EvanR looks at the bugs in apartment, agrees
13:43:30 * johnw ponders on the ecological instability of a world without bugs
13:43:32 <hpc> technically a literal moon full of bugs: https://en.wikipedia.org/wiki/Io_%28moon%29
13:44:02 <EvanR> thats no moon
13:44:04 <hpc> (all those spots are the burrows of those giant sand worms from dune)
13:44:07 <johnw> EvanR: lol
13:44:50 <hpc> speaking of bugs, i need to get back to writing this really complicated array chunking function :(
13:45:10 <johnw> hpc: that's where proof assistants come in beautifully
13:45:24 <johnw> an algorithm like array chunking is a perfect one to prove properties of
13:46:44 <hpc> i am getting back into DT languages
13:46:56 <hpc> spent most of a day getting idris to build on one gig of ram
13:48:00 * hackagebot language-thrift 0.9.0.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.9.0.0 (abhinav)
13:48:25 <EvanR> ok not a Store since the m appears in the result of the function
13:48:58 <johnw> hpc: I'm in the process of implementing the ByteString library mathematically, using refinement proofs to render a performant Haskell implementation which maintains those semantics, along with a set of proofs in terms of those semantics
13:49:47 <puregreen> koala_man: it builds on Arch (as in “cabal build”) and passes the test suite. Should I do anything else? 
13:49:53 <hpc> nice
13:49:54 <EvanR> maybe works Store m (v, Delta -> A m v)
13:50:00 <koala_man> puregreen: no, that's great. thanks!
13:50:37 <jmcarthur> EvanR: It doesn't help you much. I was just noting the kind of use case you had in mind.
13:51:48 <EvanR> er no
13:52:19 <EvanR> Delta -> Store m (v, Delta -> Store m (..
13:52:22 <EvanR> infinite type
13:52:27 <sphinxo> How should I do (:) on text?
13:52:32 <jmcarthur> That's fine. You would just use a newtype.
13:52:49 <jmcarthur> But again, I don't think this will get you closer to your goal.
13:52:51 <EvanR> oh you mean ComonadStore
13:53:16 <liste> sphinxo: Text.cons
13:53:24 <sphinxo> liste: Thanks
13:53:37 <liste> @hoogle Char -> Text -> Text
13:53:38 <jmcarthur> Yes, I really did just mean that you could instantiate ComonadStore. The observation was enlightening to me because it shows how m is meant to be used.
13:53:43 <lambdabot> Data.Text.Lazy cons :: Char -> Text -> Text
13:53:43 <lambdabot> Data.Text cons :: Char -> Text -> Text
13:53:44 <lambdabot> Data.Text intersperse :: Char -> Text -> Text
13:53:53 <EvanR> yeah
13:54:00 <liste> sphinxo: hoogle is awesome for that kind of stuff
13:55:24 <EvanR> jmcarthur: and being able to inspect the raw model is useful for an external system scheduling events at interesting points in the animation, which has no facility for IO
13:55:50 <EvanR> still trying to figure out that part
13:58:00 * hackagebot ShellCheck 0.4.4 - Shell script analysis tool  https://hackage.haskell.org/package/ShellCheck-0.4.4 (vidarhol)
14:03:00 * hackagebot bytestring 0.10.8.1 - Fast, compact, strict and lazy byte strings with a list interface  https://hackage.haskell.org/package/bytestring-0.10.8.1 (DuncanCoutts)
14:28:33 <EvanR> dolio: is there a way to do that product with generics?
14:29:59 <dolio> EvanR: Dunno about generics. But you might be able to do it with some kind of singleton thing.
14:35:22 <dcz> hello guys
14:36:13 <marcx> hi
14:36:30 <dcz> how do we use this kind of functions " insert :: LogMessage -> MessageTree -> MessageTree " 
14:36:37 <dcz> i couldnt build its body
14:49:56 <dgonyeo> anyone here know why this line would block forever sometimes? hSetBuffering stdin NoBuffering
14:53:32 <Squarism> ok.. stupid question. But as im new to haskell i could use a bit of inspiration on nice solutions. My take on calculating indexes in a deck of cards to players 0 and 1 : [(i + 1,j * 2 + i + 1) | i <- [0,1], j <- [0..5]]
14:53:45 <Squarism> oh players 1 and 2
14:53:57 <Squarism> when dealing
14:54:39 <Squarism> nicer solution anyone?
15:08:55 <lpaste> tippenein pasted “advice on map reduce with Pipes” at http://lpaste.net/163418
15:09:30 <Squarism> >  [(i + 1,j * 2 + i + 1) | i <- [0,1], j <- [0..4]]
15:09:32 <lambdabot>  [(1,1),(1,3),(1,5),(1,7),(1,9),(2,2),(2,4),(2,6),(2,8),(2,10)]
15:09:37 <tippenein> I'm able to stream lines containing a specific piece of text, but I need to map a different piece of data to a count map Map String Int
15:10:08 <Squarism> how would i group by x so that i get [(Int,[Int])]
15:13:53 <Squarism> oh found it http://stackoverflow.com/questions/15412027/haskell-equivalent-to-scalas-groupby
15:28:54 <Squarism> compiler laughs at my code : http://lpaste.net/163420
15:29:04 <Squarism> any obvious error there?
15:31:17 <davean> Squarism: Why do you nest wheres like that?
15:31:35 <dolio> It's too big for the errors to be obvious. :)
15:31:57 <Squarism> davean, im new to haskell
15:32:37 <Squarism> i want them to be local functions 
15:32:37 <davean> Squarism: You aren't catching scope from the functions the sub-wheres are on, so just delete those wheres and move the function over to the same alignment as the function the where you deleted was on
15:32:39 <dolio> Line 4 is weird.
15:33:06 <dolio> I think you're missing an arr.
15:33:07 <puregreen> and unless Num is a type, you want “Num a => [(a,a)]”, not “[(Num,Num)]”
15:33:09 <davean> Squarism: yes
15:33:15 <davean> Squarism: that doesn't stop them being local
15:34:23 <lpaste> simpson annotated “Deal 6 cards ” with “Deal 6 cards  (annotation)” at http://lpaste.net/163420#a163422
15:34:46 <Squarism> i want integers really
15:34:52 <simpson> Undid the where-tower and patched the fst and snd.
15:35:20 <simpson> Squarism: What type did you want that function `foo` to have?
15:37:04 <Squarism> simony, [(Faction,Card)]
15:37:09 <Squarism> simpson, 
15:37:42 <simpson> Squarism: Okay. So what's with the do-syntax? Are you using the list monad? I'm not sure I understand your plan.
15:38:04 <Squarism> haha
15:38:23 <Squarism> im a noob in action.. sorry for that
15:38:58 <Squarism> i prolly havent gathered the meaning of "do". Thought them let me do procedural style programmign
15:39:09 <lpaste> simpson revised “Deal 6 cards  (annotation)”: “Deal 6 cards  (annotation)” at http://lpaste.net/163422
15:39:17 <Earnestly> Squarism: The curse of syntax sugar
15:39:25 <simpson> Squarism: How do you feel about let-in instead? ^^^
15:40:12 <simpson> Squarism: do-syntax is for "imperative" or "procedural" programming, kind of, but only in a really specific way that has to do with monads. We can totally get into it, but let's focus on your program instead.
15:40:26 <Squarism> simpson, id be totally ok for that
15:41:06 <Squarism> simpson, okej.. ive gotten hints "do" is monad only but somehow i keept using it
15:41:26 <simpson> Squarism: do {expr} is equivalent to expr
15:41:39 <simpson> Which is what lpaste is warning you about with the "redundant do" warning.
15:41:51 <Squarism> ok
15:42:19 <Squarism> now ive rewritten it as i would in a imperative/proc style
15:42:25 <simpson> :t groupByIndex -- I don't know this function
15:42:26 <lambdabot> Not in scope: ‘groupByIndex’
15:42:33 <Squarism> http://lpaste.net/163429
15:42:43 <Squarism> ok.. ill add that too
15:43:52 <simpson> Ooh, that paste looks nice. Could you try rewriting it to not use `do`? You'll want to say `let ... in map ...`
15:43:52 <Squarism> http://lpaste.net/163432
15:44:05 <Squarism> ok
15:44:47 <simpson> groupByIndex looks like Somebody Else's Problem. We'll focus on your code for now. Thanks.
15:45:16 <Squarism> oh ok
15:45:53 <Squarism> http://lpaste.net/163434
15:46:05 <Squarism> complains on second "let"
15:46:24 <davean> The other lets aren't supposed to be there
15:46:31 <davean> just replace them with spaces
15:46:39 <davean> nd then put an "in " before "map"
15:46:44 <Squarism> oh ok
15:47:03 <davean> er, you did put in the "in "
15:47:31 <simpson> let { x = ...; y = ....; z = ...; } in ...
15:48:04 <davean> Squarism: "let foo (pInd, cInd)" has the same issue
15:48:28 <davean> Which the compiler will tell you about when it gets far enogh along in compiling
15:49:15 <davean> but I'll let you do that translation yourself, you should have seen enough of how let should look from this the translation should occure to you.
15:49:22 <Squarism> http://lpaste.net/163436
15:49:33 <Squarism> ok.. now  compiler seems more reasonable
15:53:38 <Squarism> woho it works
15:53:39 <Squarism> http://lpaste.net/163439
15:53:59 <_d0t> ohai. Is it possible to automatically derive aeson instances for a GADT?
15:54:00 <Squarism> so what could be done nicer / more haskell style
15:54:14 <Squarism> thanx davean and simpson 
15:55:45 <geekosaur> _d0t, in general you can't derive instances for a GADT
15:56:34 <puregreen> I've googled this up, but I've no idea how usable it is (given that it hasn't been released to Hackage): https://github.com/ku-fpg/aeson-gadts
15:56:49 <_d0t> geekosaur: ok, what about TH?
15:56:57 <_d0t> would that be possible?
15:57:30 <_d0t> i've tried writing it in code, but ghc fails to compile code generated by $(deriveJSON ...)
15:57:54 <geekosaur> I don't think TH will help. the problem is that, unless you're writing a Hskell98-compatible type in GADT syntax, it involves a forall
15:57:58 <davean> Squarism: You probbly want to use less names, like "newY" is probably useless,why not just replace "newY" with "map snd arr" directly?
15:57:59 <_d0t> so i'm wondering if i should pursue that path or just write instances by hand
15:58:04 <geekosaur> and you can't derive existentials
15:58:32 <davean> Squarism: and you definately want to sue things like "fst" and "snd" instead of writing them out yourself
15:58:45 <puregreen> geekosaur: but wait, if it's possible to write an instance by hand surely it must be possible to generate it with TH?
15:59:18 <geekosaur> in theory yes, in practice it likely requires something fairly clever
15:59:37 <Squarism> davean, doesnt it help reading it with names here and there?
15:59:49 <davean> Squarism: "newY" is a meaningless name IMO
16:00:02 <Squarism> well ok =D
16:00:06 <davean> So no. There are names that would help, but "newY" is far less clear then the action that defines it.
16:00:22 <EvanR> yes y' is obviously clearer
16:01:12 <EvanR> half joking because while its still unclear, its idiomatic
16:01:35 <Squarism> ok.. now i tried to make it more readable.. but now compiler complains
16:01:36 <Squarism> http://lpaste.net/163443
16:01:39 <davean> Squarism: consider "in map (λ(x,arr) → (x, map snd arr)) bar"
16:02:55 <_d0t> ok, thx guys
16:03:14 <Squarism> davean, got that
16:03:19 <_d0t> i'll try to dig into th code in aeson a bit later to figure this out
16:03:58 <davean> Squarism: Then consider "in map (fmap (map snd arr)) bar", which you might consider less clear
16:04:07 <idev> what is the simplest way to do JPEG -> (Double, Double) ?
16:04:13 <idev> I want to extract the width/height of a jpeg file
16:04:19 <simpson> idev: f _ = (0, 0)
16:04:31 <EvanR> clever
16:04:32 <Squarism> oh nothing
16:04:36 <Squarism> works
16:04:36 <simpson> Ah. I don't know what library the JPEG type comes from.
16:04:51 <simpson> JuicyPixels, right?
16:05:16 <Welkin> lol
16:05:17 <idev> simpson: how is juicy pixels?
16:05:18 <Welkin> what a name
16:05:24 <idev> http://hackage.haskell.org/package/JuicyPixels
16:05:28 <davean> Squarism: then theres the foo/cInd thing
16:05:42 <simpson> idev: Which library are you using?
16:05:47 <Welkin> I seem to remember it being not what I was looking for when I was evaluating libraries for image manippulation
16:05:48 <simpson> idev: For JP, it looks like this: http://hackage.haskell.org/package/JuicyPixels-3.2.7/docs/Codec-Picture-Metadata.html
16:05:49 <davean> Squarism: WTF is up with that?
16:06:01 <idev> simpson: I haven't decided yet -- looking at hackage
16:06:09 <davean> Squarism: Theres A) no reason to beleive the deck and your dealedIndexes will line up from your code.
16:06:09 <EvanR> idev: the dimensions are in the Image type
16:06:09 <idev> simpson: perferably something that does not use imagemagick and its buffer overflows
16:06:30 <davean> Squarism: B) Not a clear reason you're not iterating on the deck directly.
16:06:33 <EvanR> which you can get from the dynamicImage type
16:06:38 <simpson> idev: "ImageMagick is like a cockroach. It'll always be around." ~ Gary Bernhardt
16:06:38 <EvanR> DynamicImage
16:07:16 <idev> is juicypixels pure haskell
16:07:21 <idev> or does it depend on external libraries
16:07:37 <EvanR> it depends on zlib
16:07:44 <simpson> It doesn't depend on IM or GD.
16:08:00 <simpson> But it's not 100% safe total code.
16:08:02 <idev> https://www.cvedetails.com/vulnerability-list/vendor_id-72/product_id-1820/GNU-Zlib.html
16:08:18 <simpson> If you want 100% safe total code, then don't use Haskell. Heck, don't use computers. Most of them are terribly unsafe.
16:08:29 <EvanR> if security is an issue, better not using jpeg or png
16:08:45 <EvanR> try deflated targa ;)
16:09:01 <Squarism> davean, remember... this is my first haskell program
16:09:11 <davean> Squarism: Sure
16:09:16 <Earnestly> EvanR: (Or versions of software over a decade old)
16:09:22 <Squarism> davean, im fresh out of imperative world
16:09:26 <idev> hmm, how about https://hackage.haskell.org/package/jpeg
16:09:35 <idev> well, I'm writing a webservice for processing untrusted image files
16:09:41 <idev> what would you recommend instead?
16:09:43 <davean> Squarism: Even there your indexes need to line up ;)
16:09:44 <EvanR> Earnestly: yes, though deflate and targa arent referring to softawre
16:10:00 <EvanR> in my case
16:10:14 <Squarism> davean, you mean my function assumes the deck is of certain size? 
16:10:23 <EvanR> the simpler the better for security
16:10:25 <davean> Squarism: yes
16:10:37 <Squarism> davean, im taking baby steps here
16:10:42 <Earnestly> EvanR: Simple like GHC's runtime? :P
16:11:05 <davean> Squarism: I'd think you could map on the deck
16:11:15 <Squarism> davean, i guess i could
16:11:15 <simpson> idev: A good sandbox, lots of monitoring, and a fifth of bourbon.
16:11:15 <EvanR> simple like purely functional semantics
16:11:15 <davean> at the least you could definately fold on it
16:11:29 <davean> Then you'd never have an index issue, also you're code would be FAR faster
16:11:32 <Squarism> davean, ill take that as an excersise
16:11:44 <simpson> idev: What's your TCB? Figure that out first.
16:11:47 <davean> Squarism: Your current code is O(n^2), mapping or folding would be O(n)
16:13:04 <Welkin> davean: maybe he is an indian programmer whose job depends on creating bugs that he can then fix?
16:13:17 <simpson> idev: Does that make sense? I can dispatch more vaguely unhelpful security advice if you like.
16:13:32 <idev> simpson: maybe I do all this on jvm
16:13:38 <davean> Welkin: thats not very nice
16:13:52 <idev> whgen's the last time there's been an image/pdf processing exploit on the jvm ?
16:14:04 <Squarism> actually my main goal is getting a working game / learn some haskell. not all functions has to be optimal
16:14:17 <simpson> idev: Sorry, I really did mean "safe", like E or Monte, and "total", like Agda or Idris.
16:14:22 <Squarism> and deck will be same size every time function is called
16:14:51 <simpson> idev: Anyway, ignore all of that for a moment. Your TCB; your "trusted computing base" or "trusted computing boundary". All of the machines and software which are innately trusted by you. Do you have that documented yet?
16:15:12 <idev> simpson: no
16:16:03 <simpson> idev: Okay! That's the first thing you need; it will help tell you whether you need a sandbox, an isolated machine, a VM, trusted computation, etc. to safely process your untrusted inputs.
16:16:08 <davean> Squarism: WIll it always just be the same?
16:16:16 <Squarism> davean, yep
16:16:20 <davean> simpson: Then why are you passing it in?
16:16:23 <Squarism> but randomized
16:16:25 <davean> er, that was to Squarism 
16:16:34 <davean> Thats not the same
16:16:40 <Squarism> same size
16:17:11 <Squarism> for "block of lets" is it more haskell style to follow "let" with new line?
16:17:45 <Squarism> multiple "let's" as in my program
16:19:25 <pyon> Is there anything like unfoldr, but in a monadic context?
16:19:34 <EvanR> unfoldM
16:19:39 <davean> However you want to do it, most people would do a lot of those as "where" though
16:19:50 <davean> Squarism: where is the same, it just comes after.
16:21:44 <deech> Hi all, who can I talk to about possibly contributing to the Summer Of Code fund?
16:23:16 <simpson> deech: Are you thinking of GSoC, or is there another thing with the same name?
16:23:25 <deech> yes, GSoC.
16:23:45 <deech> Has that opportunity passed?
16:23:50 <simpson> deech: That's not a fund. That's Uncle Googlebanks emptying out pocket change onto the community.
16:24:03 <geekosaur> simpson, haskell split from gsoc and is running its own this year
16:24:10 <simpson> geekosaur: Oh! I had no idez.
16:24:12 <simpson> *idea, even.
16:24:15 <EvanR> oh wow
16:24:15 <hjljo> yup
16:24:28 <simpson> geekosaur: Well, then I suppose that donations are probably quite welcome, right?
16:24:53 <geekosaur> (gsoc is nice in some ways but has its own problems, and sometimes you are better off doing your own thing instead. there are projects that tried to do gsoc, and collapsed under the load)
16:24:58 <puregreen> simpson, EvanR: https://www.reddit.com/r/haskell/comments/48eurt/haskell_summer_of_code/
16:25:01 <deech> At some point I think Ed Kmett was taking donations but I didn't know if it was too close now.
16:25:12 <Squarism> davean, http://lpaste.net/163454 better?
16:25:19 <geekosaur> I'd imagine they'll need more than just up-front funding
16:26:28 <Welkin> what's the point?
16:26:40 <Welkin> why are you paying the volunteers?
16:27:01 <EvanR> to get them to volunteer?
16:27:15 <Welkin> then it is not volunteering
16:27:19 <EvanR> or is it
16:27:56 <puregreen> I've never seen GSoC participants called “volunteers”, actually
16:28:04 <davean> simpson: you can still donate
16:28:41 <geekosaur> it's make more sense to consider GSoC a sort of summer school funded by Google
16:28:56 <geekosaur> or maybe grad school type given the participants get stipends
16:29:13 <simpson> It paid about as well as any other summer job when I was a GSoC student.
16:29:51 <Welkin> minimum wage?
16:30:27 <Welkin> does that work out though?
16:30:43 <Welkin> is the result of gsoc better or worse than just getting year-round volunteers?
16:31:33 <Welkin> athan would like to donate himself to your cause
16:31:38 <geekosaur> that's only part of it. the injection of cash counts for a lot as well (note in the reddit link that gsoc has been helping pay for haskell.org infrastructure)
16:32:45 <davean> Welkin: It depends on what they do, if its something the community needs, and how much they get done, relatively?
16:32:56 <davean> Welkin: With summer of code projects, the community selects ones they want
16:34:07 <davean> Welkin: some of us do volunteer year round
16:36:48 <pyon> EvanR: thanks!
16:41:33 <nkaretnikov> does hakyll or pandoc require a lot of time to link?
16:42:12 <nkaretnikov> i'm trying out hakyll.  a hello world kind of project has been linking for minutes
16:42:20 <davean> Squarism: That looks fine, usually the reason for the where is that the line its self is clear in its intent, and you can refer to the where for the details if you remain interested.
16:42:39 <nkaretnikov> i wonder whether i hit a bug or not :\
16:42:41 <davean> Squarism: In your case, "map baz" isn't clear at all, but I think that will change as you get experience
16:44:41 <Squarism> davean, its "map baz bar", ill let foo = map to get rid of the map
16:45:00 <Squarism> =D
16:45:13 <davean> Squarism: :-p
16:45:28 <Squarism> davean, get it. I like that layout i must say
16:45:34 <EvanR> foo = map
16:45:40 <EvanR> "foo baz bar"
16:45:58 <Squarism> both the let and where alternatives
16:46:17 <Squarism> thats readability for you
16:46:24 <davean> Squarism: when you want something defined up front, or defered to after is ENTIRELY style
16:46:35 <davean> Squarism: So I'm glad you tried them both out :)
16:46:48 <davean> I'm sure in the end you'll mix and match as you feel is appropriate for the function at hand
16:46:55 <Squarism> thanks for your patience
16:48:59 <davean> No problem
16:49:04 <nkaretnikov> oh, it finally linked...
16:59:30 <tippenein> how do I consume Text from a Producer and insert it as a key into a Strict Map? I'm using the Pipes library
17:00:36 <lpaste> tippenein pasted “Map increment from Text producer” at http://lpaste.net/163474
17:01:28 <tippenein> maybe a chain?
17:03:22 <tippenein> > :i chain
17:03:23 <lambdabot>  <hint>:1:1: parse error on input ‘:’
17:03:30 <tippenein> :i chain
17:05:40 <EvanR> alright so  so i back tracked to the idea of generally wrapping the model with a functor that adds some behavior http://lpaste.net/163475
17:06:20 <EvanR> but it relies on the ability to wrap a value in a functor, and get the value back. what clas is that
17:07:56 <EvanR> like a simple record type that has a polymorphic last field
17:09:05 <EvanR> i guess f a -> a would be an algebra
17:09:55 <EvanR> and a -> f a is pointed
17:14:19 <dolio> a -> f a is a coalgebra.
17:14:54 <EvanR> ah not too familiar with those
17:15:21 <dolio> Well, it's just like an algebra, but backwards.
17:20:29 <jdt> this may seem like a dumb question, but it's driving me nuts, so I'll just ask...
17:20:45 <posi> how is stm's model different from database isolation models. When do I need to worry about the equivlent of read committed, or phantom reads?
17:21:12 <jdt> if all I want out of Groundhog is to get a list of all the entities in a table (without the ids), would I use selectAll or select?
17:21:19 <EvanR> never because STM is totally serialized, unlike models that are not SERIALIZABLE
17:21:29 <jdt> I would assume the former, but I'm having a really hard time with that and wondering if I should be using select instead.
17:23:07 * hackagebot simple-sendfile 0.2.22 - Cross platform library for the sendfile system call  https://hackage.haskell.org/package/simple-sendfile-0.2.22 (KazuYamamoto)
17:23:50 <posi> kk
17:24:23 <EvanR> the way databases *should be* by default
17:25:15 <posi> EvanR: in all scenarios even! everything else is an abomination! Oh wait no that's impractical and we've understood the tradeoffs for a long time
17:25:51 <EvanR> on disk mayb
17:27:03 <EvanR> and defaults arent about tradeoffs
17:27:09 <posi> and by databases i assume you mean rdbms, most things people use as datastores don't provide full serializability. There's that lmdb thing which is great! I can't remember what isolation guarantees it provides. But of course it's more of an embedded database
17:27:14 <posi> great features for an embedded with no sql
17:27:35 <posi> the openldap project found it practical to use
17:27:40 <posi> i think it's a practical library
17:28:18 <MichaelK> Hi, can I combine a lazy pattern match with an as pattern? i.e. `a@(b:bs)` and `~(b:bs)`
17:28:20 <EvanR> definitely, i wish there was more room for not RDBMS or misengineered clones in web ecosystems
17:30:46 <dolio> MichaelK: Yes.
17:30:50 <geekosaur> > let a@~(b:bs) = [1,undefined] in b
17:30:52 <lambdabot>  b
17:31:16 <geekosaur> hm... not quite right
17:31:43 <geekosaur> > let a@(~(b:bs)) = [1,undefined] in b
17:31:45 <lambdabot>  1
17:33:43 <MichaelK> geekosaur: thanks
18:00:10 <pyon> Is there an example in Haskell of a Bifunctor that's braided monoidal, but not symmetric monoidal?
18:02:05 <pyon> Errr, I mean, a Bifunctor that makes Hask a braided monoidal, but not symmetric monoidal category.
18:02:49 <pyon> (Both Either and (,) make Hask symmetric monoidal.)
18:08:21 <Squarism> myFkn :: (Eq a) => (a -> c) -> [(a,b)] -> (c,[b])
18:08:33 <Squarism> that is a legit signature
18:09:06 <pdxleif> Hrm; all that griping online about the "haskell.org" downloads, and apparently I've never used that page. :|
18:09:07 <Squarism> what if i want theres an Eq (a,b) 
18:09:09 <Squarism> present
18:10:44 <pavonia> :t \(x,y) -> (x,y) == (x,y)
18:10:46 <lambdabot> (Eq t, Eq t1) => (t, t1) -> Bool
18:11:09 <geekosaur> you could say that, or (Eq a, Eq b) and rely on the instance (Eq a, Eq b) => Eq (a,b)
18:11:53 <pavonia> :t \p -> let _ = fst p in p == p
18:11:55 <lambdabot> (Eq a, Eq b) => (a, b) -> Bool
18:11:59 <pavonia> :<
18:15:35 <pavonia> For the last expression, would it infer the same type if the aforementioned instance weren't in scope?
18:19:10 <tippenein> I'm trying to understand Pipe.Prelude's `fold`
18:19:11 <tippenein> fold :: Monad m => (x -> a -> x) -> x -> (x -> b) -> Producer a m () -> m b
18:19:23 <tippenein> what is the (x -> b) referring to
18:20:14 <shanemikel> I've seen ML modules being referred to as Functors.  In what sense?
18:22:27 <tippenein> shanemikel: do you mean, why do they call modules 'functors'?
18:22:36 <dolio> In the sense that the word "functor" sounds like "function".
18:23:05 <shanemikel> is that all there is to it?
18:25:38 <dolio> It has no origin in category theory, as far as I know. Maybe there's some way to make sense of it as a functor in category theory, but that'd just be because you can organize a lot of stuff that way.
18:25:42 <geekosaur> you can parameterize a module with types. in some sense this is like mapping the module/"functor" over those types
18:26:29 <geekosaur> (that is, you can look at a parameterized module as a type level fmap of sorts)
18:26:29 <dolio> ML functors are functions from modules to modules. They needed a word that was like 'function' but not.
18:26:48 <dolio> Like C++ functors.
18:28:35 <shanemikel> I've read a bit about how backback is going to make builds hashable, but is it going to give us modules in the ML style as well?
18:29:30 <sshine> I don't suppose a Prolog 'functor' is much like one from Category Theory, either...
18:29:44 <simpson> Nope.
18:29:52 <geekosaur> shanemikel, changing the build system won't make modules parameterizable, that would require language changes
18:29:56 <sshine> it just sounds cool and slightly different from 'function' :)
18:31:05 <simpson> Why not use "functino"? It's a cool-sounding typo, rigt?
18:31:49 <pavonia> Sounds like some Italian food
18:32:19 <shanemikel> I had some functino rigtino the other night
18:32:31 <dolio> Prolog functor is the outermost atom of a term?
18:32:50 <shanemikel> or was it rigtoni
18:32:52 <simpson> It's the name and arity of the term's relation.
18:32:55 <geekosaur> "functule"
18:33:00 <sshine> geekosaur, hehe
18:33:05 <simpson> In derp(X, Y), the functor's derp/2.
18:33:19 <simpson> IIRC. I haven't Prolog'd in a while.
18:33:24 <sshine> simpson, that's what I recall.
18:33:37 <sshine> also, derp is a good name for a functor.
18:34:20 <simpson> I prefer it to "foo" as a metasyntactic name.
18:35:04 <sshine> so if you need another name, what comes after derp?
18:35:07 <shanemikel> derp . dee = \derr -> derp (dee derr)
18:35:16 <sshine> yeah, okay.
18:35:33 <hpc> let robSchneider = herp `de` derp
18:35:42 <simpson> It used to be "hurp", but it confused people when spoken out loud.
18:36:48 <dolio> Anyhow, I'm not sure why 'functor' keeps getting used/made up instead of other possible words.
18:37:15 <dolio> Maybe we should contact Chomsky about some sort of genetic predisposition to the word 'functor'.
18:37:49 <hpc> maybe just because it's similar to "function" but sounds smarter
18:37:55 <sshine> geekosaur, functule sounds kind of like function + module.
18:38:08 <hpc> functule sounds like something the doctor removes
18:38:22 <simpson> Yeah, ick.
18:38:26 <sshine> but when I speak to mathematicians about modules, they also get confused, so shrug.
18:38:41 <dolio> The only other word I can think of is "functional".
18:39:14 <dolio> Which is sometimes used to mean higher-order function by mathematicians, I think.
18:39:48 <pavonia> "functionoid"
18:39:49 <hpc> i think if you used that people would think you didn't know your nouns from your adjectives
18:39:50 <sshine> dolio, yeah, when I learned of functional, I thought maybe that's where early ML'ers had gotten it from.
18:40:08 <sshine> hpc, don't be so negatoid.
18:40:14 <hpc> :D
18:40:44 <dolio> Maybe they did.
18:41:20 <dolio> I suppose that's one way of classifying languages as functional; whether they have functionals.
18:42:32 <hpc> haha
18:43:21 * simpson blinks
18:43:29 <simpson> Wow, that's quite the semantic coincidence.
18:44:07 <hpc> that's right up there with classifying people as ugly based on whether they have uggs
18:44:10 <simpson> But as usual, we need to somehow exclude C from the cool club, and C has qsort(), so nope.
18:44:28 <hpc> (couldn't resist the pun)
19:02:33 <shanemikel> :q!
19:02:35 <shanemikel> :q!
19:11:08 <EvanR> ok so at least i found a better way to combine animations, using a functor-like thing, collect :: (forall a b . (a -> b) -> f a -> f b) -> f (A m v) -> A (f (A m v)) (f v), does 1 parameters, a bifunctor-like thing does 2, not sure about arbitrary records but at least this function is easy to generate
19:11:45 <EvanR> but this generic fake fmap works on Map and Set which is awesome
19:12:26 <EvanR> the extra A's in the structure seem annoying, but i guess its better this way
19:18:22 <Fare> Hi. I'm looking for an audience to rehearse my talk to BostonHaskell this Wednesday
19:18:29 <Fare> over Google Hangouts
19:20:58 <Cale> What's the talk about?
19:21:27 <Cale> I probably shouldn't ask, I have to get work done :)
19:24:54 <Fare> First-class Implementations http://www.meetup.com/Boston-Haskell/events/228966396/
19:25:51 <Fare> also, PCLSRing, Migration, Runtime Meta-programming.
19:37:48 <tomleb> Hey guys I can't push my application with haskell-on-heroku, anyone can help ? There is a problem with my constraints or something.
19:38:00 <tomleb> remote: -----> Determining constraints
19:38:00 <tomleb> remote:        cabal: No sandbox exists at /home/tomleb/dev/web/portfolio/.cabal-sandbox
19:38:03 <tomleb> remote:    *** ERROR: Failed to determine constraints
19:38:06 <tomleb> remote:    *** ERROR: Failed to deploy app
20:00:42 <sshine> Fare, I got caught up in the text "Civil Obedience: How to break the Cycle of Violence" that you host, but I can't find the mp3 for "The Ogre, the Midget, and Us".
20:01:23 <elliptic00> hi, can anyone explain to me why the expression is like the following?
20:01:34 <elliptic00> []:[]
20:01:39 <elliptic00> [[]]
20:01:46 <elliptic00> I understand that,
20:02:05 <elliptic00> "":[]:[] output ["", ""]
20:02:30 <elliptic00> why  the output is ["", ""]
20:03:40 <sqrt2> in your first case, the type of [] is [a], whereas in the second case it is of type [Char] (also called String)
20:03:49 <geekosaur> because the first [] has to have type String, aka [Char], and the Show instance for [Char] always shows with double quotes
20:03:50 <sqrt2> so in the first case, haskell can't display [] as ""
20:04:03 <sqrt2> it just knows it's an empty list
20:04:10 <sshine> elliptic00, since String = [Char], so when you use the syntactic construct "", your interactive interpreter defaults to showing the list as such.
20:04:52 <elliptic00> so [] = ""?
20:04:59 <sshine> yep.
20:05:00 <sqrt2> if [] :: [Char]
20:05:27 <sshine> [] :: [a], and "" :: [Char], so [] = "" if a = Char.
20:06:12 <elliptic00> thanks the explanation
20:07:02 <elliptic00> BTW, anyone know how to log all my commands in file in GHCi or Prelude?
20:07:37 <elliptic00> I'm looking at the ~/.ghc/ghci_history, it only store less 100 commands
20:07:50 <sqrt2> check out the unix script command, it will log everything that's on your console
20:07:53 <elliptic00> I want to increase the # log
20:08:31 <elliptic00> thanks sqrt2
20:11:58 <elliptic00> I try the script command, but there are many weird characters in the log file, is there anyway I can log my GHCi commands in file?
20:14:05 <geekosaur> http://trac.haskell.org/haskeline/wiki/UserPrefs see maxHistorySize
20:42:34 <scshunt> ugh, I'm pretty sure I'm abusing the hell out of monad transformers...
20:53:12 * hackagebot bytestring-builder 0.10.8.1.0 - The new bytestring builder, packaged outside of GHC  https://hackage.haskell.org/package/bytestring-builder-0.10.8.1.0 (LeonSmith)
20:58:43 <Tangerine> any idea what this error is about?
20:58:44 <Tangerine> https://gist.github.com/TangerineCat/93450b1ae160adddbf6b8114cbcdf93b
20:59:19 <Tangerine> errors are from sublimehaskell's error checker
21:00:53 <sshine> :t (^)
21:00:55 <lambdabot> (Integral b, Num a) => a -> b -> a
21:00:59 <geekosaur> they're all warnings, and are because (a) ghc these days defaults to working every time it uses defaulting, and (b) Data.List was pretty much gutted when ghc 7.10 rewrote it all in terms of Foldable and Traversable and put them in the Prelude
21:01:41 <geekosaur> and yes, you will pretty much always have defaulting with (^) because there's no way to infer a type for the right hand parameter
21:01:53 <Tangerine> so I should just ignore those warnings?
21:02:10 <Tangerine> and remove the line with import Data.List
21:02:11 <geekosaur> yes
21:02:27 <Tangerine> how would I suppress the ^ error?
21:02:35 <sshine> Tangerine, (^) is overloaded to a bunch of different Num types for the exponent. for performing the actual computation, it needs a specific function to run, so it defaults to one.
21:02:48 <sshine> Tangerine, you could suppress it by adding e.g. :: Int
21:02:51 <Tangerine> ah
21:03:00 <Tangerine> so i ^::int 3
21:03:02 * geekosaur always needs to look up the -W flag
21:03:12 <geekosaur> i ^ (3::Int)
21:03:16 <Tangerine> ooh i see
21:03:51 <Cale> That flag shouldn't even be on with -Wall by default
21:04:36 <geekosaur> -fno-warn-type-defaults
21:04:40 <geekosaur> not a -W, sigh
21:05:46 <Cale> The only way I can imagine it got turned on is that whoever wrote the thing that's producing warnings for you was overzealous and turned on every warning flag or something
21:06:55 <geekosaur> sadly, as of ghc 7.10 -Wall *does* include that warningf
21:07:20 <Cale> wait, really?
21:07:36 <Cale> oh
21:07:47 <Cale> I was misreading the list of them
21:07:59 <Cale> er, no...
21:08:06 <Cale> -Wall:
21:08:06 <Cale> Turns on all warning options that indicate potentially suspicious code. The warnings that are not enabled by -Wall are -fwarn-type-defaults, -fwarn-name-shadowing, -fwarn-missing-signatures, -fwarn-warn-hi-shadowing, -fwarn-orphans, -fwarn-unused-do-bind, and -fwarn-trustworthy-safe, -fwarn-unticked-promoted-constructors.
21:08:24 <Cale> Note the "not"
21:08:36 <dolio> What version of the docs are you looking at?
21:08:52 * geekosaur didn't use a list. ghci -Wall -fignore-dot-ghci
21:09:18 <Cale> oh, it got changed from 7.10.1 to 7.10.2 apparently
21:09:33 <geekosaur> er -ignore-dot-ghci (I didn;t actually use that as I don't have a .ghci)
21:10:45 <Cale> Anyway, ugh, that makes -Wall even less useful than it already was :P
21:13:10 <elliptic00> I try to write a mergelistList function,   mergeListList::[[String]]->[[String]]->[[String]]
21:13:24 <elliptic00> here is the code
21:13:25 <elliptic00> http://pastebin.com/jeaqR0ma
21:13:40 <elliptic00> i got following error 
21:13:41 <elliptic00> Non-exhaustive patterns in function mergeListList
21:13:54 <elliptic00> can anyone explain to me what is wrong with my function?
21:18:22 <maybefbi> is there a free monad that has functions identical to IO and can be lifted to IO?
21:19:39 <elliptic00> I'm not sure what is your question?
21:21:16 <sshine> elliptic00, you should seek to simplify your base cases.
21:21:42 <sshine> elliptic00, e.g. start by listing your recursive case first, and then assume that if it doesn't match, then either xs or ys is empty.
21:24:31 <gabbiel> why not define null as "null = (==[])"
21:25:02 <Cale> maybefbi: Theoretically? Yes (up to interpretation of the word "identical"). Practically? I don't know if anyone's written it. I remember seeing a teletype-only fake IO monad
21:25:26 <geekosaur> gabblet, because then you have to resolve the first list constructor and the first element of the list
21:25:42 <geekosaur> when you only need the first list constructor (is it (:) or is it []?)
21:25:51 <geekosaur> also you add a pointless Eq constraint
21:25:52 <simpson> gabbiel: And you also need an Eq instance on the contents.
21:26:35 <maybefbi> Cale, thanks
21:26:52 <gabbiel> so I see, its inefficient then
21:28:14 * hackagebot ghc-dump-tree 0.2.0.1 - Dump GHC's parsed, renamed, and type checked ASTs  https://hackage.haskell.org/package/ghc-dump-tree-0.2.0.1 (EdskoDeVries)
21:28:16 * hackagebot oscpacking 0.1.0.0 - Implements an osculatory packing (kissing circles) algorithm and display.  https://hackage.haskell.org/package/oscpacking-0.1.0.0 (infrared)
21:32:01 <geekosaur> inefficient and limiting since you may not otherwise need an Eq constraint, so why force one just to test if a list is empty?
21:34:42 <gabbiel> does "foo a = 9" reserve space for a, even though not used, would "foo _ = 9" be better?
21:36:23 <geekosaur> it doesn't reserve space period. it's not a variable, it doesn't need its own separate space
21:37:38 <geekosaur> it saves a tiny amount of space in the compiler, and it may help catch typoes since you can't use it by accident if you don't name it
21:38:41 <gabbiel> i mean, when I call it, like "foo "bar" ", does "bar" get stored?
22:12:23 <tippenein> if I have a stream of Text, how can I create a counting Map of the Texts it consumes? Map Text Int
22:13:06 <tippenein> the stream is Proxy () Text () Text SafeT IO r    .... so, a Pipes producer
22:13:10 <Axman6> insertWith (+) <text> 1 and fold that over all the Texts
22:14:58 <Axman6> should be able to use: fold (\mp t -> M.insertWith (+) t 1) M.empty id
22:15:25 <Axman6> fold coming from Pipes.Prelude
22:15:43 <Axman6> might want to use foldl' and Data.Map.Strict
22:18:50 <lpaste> tippenein pasted “fold over map reduce” at http://lpaste.net/163486
22:20:22 <Axman6> tippenein: fold takes a Producer as input, so you probably want: mapper = P.filter (\line -> "knicks" `T.isInfixOf` line) >-> P.map (second . T.split ((==) '\t')), and then use P.fold (\mp t -> Map.insertWith (+) t 1) initialMap id mapper
22:20:22 <tippenein>     Couldn't match expected type ‘Map.Map k a -> Map.Map k a’
22:20:23 <tippenein>                 with actual type ‘Map.Map Text.Text Int’
22:20:44 <tippenein> probably due to the unused args? not sure
22:21:00 <Axman6> unused args?
22:21:22 <Axman6> anyway, you need to give fold a Producer, it's not part of the pipeline, it consumes the pipeline
22:22:56 <tippenein> fold :: (x -> a -> x) -> x -> (x -> b) -> Producer a m () -> m b
22:23:12 <tippenein> how do you pass the results of the pipeline into the fold
22:27:13 <Axman6> tippenein: do you need to continue to write things out at the end of the pipeline? I think what you want is: runSafeT $ fold ... $ getInputFiles >-> mapper
22:29:29 <tippenein> perhaps. The ultimate goal is to print the counters in the Map to terminal/file
22:30:22 <tippenein> so, consume the mapper with the fold
22:30:31 <Axman6> right, so the result of doIt there would be the Map Text Int
22:31:31 <Axman6> which you can then... traverseWithKey (\k v -> print (k,v))
22:31:42 <Axman6> or whatever format you want
22:34:08 <VillainInc> /?
22:35:23 <Axman6> tippenein: any luck?
22:38:04 <tippenein> [the Pipes.fold is still invalid along with some other things
22:39:37 <tippenein> printMap $ runSafeT $ runEffect $ foldIntoMap $ getInputFiles >-> mapper
22:39:52 <tippenein> where printMap :: Map Text Int -> IO ()
22:43:37 <Axman6> printMap =<< runSafeT ...
22:43:52 <Axman6> since runSafeT will return IO (Map Text Int)
22:46:38 <tippenein> confused about this one you wrote: Pipes.fold (\mp t -> Map.insertWith (+) t 1)
22:46:53 <tippenein> what is the `mp`?
22:54:34 <cocreature> that should probably be Map.insertWith (+) t 1 mp
22:56:17 <lpaste> tippenein revised “fold over map reduce”: “fold over map reduce” at http://lpaste.net/163486
23:00:05 <EvanR> so, data structure that has a function somewhere deep in it cant be debugged as normal because show instances
23:00:17 <EvanR> is it acceptable to add a trivial show instance for functions
23:02:37 <opqdonut> EvanR: you can't write a manual show instance for the container that doesn't try to show the functions?
23:03:39 <cocreature> EvanR: you can also just import Text.Show.Functions (from base) to get a dummy instance
23:03:51 <EvanR> opqdonut: not if the contents is up to the user
23:04:04 <EvanR> i.e. i dont know which are functions and which arent
23:04:09 <EvanR> cocreature: nice
23:04:12 <opqdonut> right, it's parameterised
23:04:18 <opqdonut> yeah then a dummy instance is fine
23:05:35 <EvanR> cool, <function>
23:05:50 <EvanR> > putChar
23:05:52 <lambdabot>  <Char -> IO ()>
23:05:58 <EvanR> even cooler ;)
23:32:32 <Ricky81682> anyone here?
23:32:53 <gabbiel> how do I make a function strict
23:34:29 <liste> gabbiel: `seq', $! and/or strictness annotations
23:35:45 <gabbiel> is there a guide somewhere?
23:36:17 <liste> gabbiel: at least this https://wiki.haskell.org/Seq
23:36:44 <gabbiel> yeah, just found it too
23:36:55 <cocreature> also make sure that you understand what you want to be strict and why before you start randomly throwing in seq or $!
23:37:04 <Axman6> gabbiel: why do you need a strict function?
23:37:32 <gabbiel> because I want to control space complexity
23:44:43 <gabbiel> let a = a
23:47:56 <zRecursive> > let a = a
23:47:58 <lambdabot>  <no location info>: not an expression: ‘let a = a’
23:48:18 * hackagebot intero 0.1.6 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.6 (ChrisDone)
23:53:18 * hackagebot persistent-sqlite 2.5.0.1 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.5.0.1 (MichaelSnoyman)
23:53:20 * hackagebot intero 0.1.7 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.7 (ChrisDone)
23:53:45 <EvanR> gabbiel: sometimes adding strictness causes worse memory performance
23:54:10 <EvanR> > let a = a in a
23:54:14 <gabbiel> example?
23:54:15 <lambdabot>  mueval-core: Time limit exceeded
23:54:16 <EvanR> (unrelated)
23:55:43 <gabbiel> this seq stuff is confusing
23:55:47 <EvanR> when the normal form of the data is larger than the thunk that would generated it
23:55:59 <EvanR> s/generated/generate/
23:56:28 <EvanR> and if you can consume the data incrementally
23:56:35 <EvanR> i.e. the rest of the code is lazy enough
23:57:55 <EvanR> > let x = undefined in fst (3, x)
23:57:56 <lambdabot>  3
23:58:05 <EvanR> > let x = undefined in x `seq` fst (3, x)
23:58:06 <lambdabot>  *Exception: Prelude.undefined
23:58:16 <EvanR> thats how seq works
23:58:40 <EvanR> but bang patterns might be easier to use depending on the circumstances
23:58:48 <gabbiel> how can a thunk be bigger than the data if a thunk is that data stored
23:59:02 <gabbiel> do I always use a let expression?
23:59:04 <EvanR> a thunk can be bigger than data if the data is really small
23:59:11 <EvanR> like an Int
23:59:35 <EvanR> if you are storing lots of Ints you probably want them evaluated earlier
23:59:37 <gabbiel> e.g., i can't do (undefined `seq` fst (3,undefined)
23:59:48 <EvanR> you can
23:59:56 <cocreature> 1 + (1 + (1 + (1 + 1))) is bigger than 5
23:59:59 <EvanR> but in real code undefined would be a big expression
