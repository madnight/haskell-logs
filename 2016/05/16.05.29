00:07:38 * hackagebot phoityne-vscode 0.0.4.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.4.0 (phoityne_hs)
00:07:38 * hackagebot hw-prim 0.0.3.0 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.3.0 (haskellworks)
00:42:28 <minib00m> guys, im having a constructor data VarList = VarList [Variable]
00:43:10 <minib00m> and in some functions i'm flattening this VarList to just list of Variables
00:45:14 <minib00m> nvm... i'm stupid lol
01:08:32 <henke> im a bit confused, i read about people using both stack and nix to solve the same problem is stack replacing the need to use nix?
01:19:13 <hvr> henke: if you want even more confusion, http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/ :-)
01:21:04 <hvr> henke: however, Nix manages your complete system, including c dependencies
01:21:30 <hvr> afaik that's not yet handled by Stack
01:21:46 <minib00m> C dependencies?
01:22:06 <hvr> minib00m: some haskell packages require c libraries & header files to link against
01:22:29 <minib00m> oh wow, didn't know
01:22:51 <hvr> e.g. http://hackage.haskell.org/package/gtk
01:23:45 <hvr> has "pkgconfig-depends: gthread-2.0, gtk+-2.0" in its .cabal file
01:24:58 <minib00m> got it!
01:54:04 <cocreature> however stack can integrate with nix for C dependencies
01:59:00 <minib00m> is it hard to do that?
02:00:10 <cocreature> minib00m: I haven’t used it myself, here’s the corresponding blogpost http://www.tweag.io/blog/stack-nix-portable-reproducible-builds
02:03:11 <minib00m> cocreature: thanks for the reading :)
02:10:07 <blueonyx> hi, regarding conduits, how can i run a Consumer? runResourceT $ CB.sourceFile $$ CL.lines =$= CL.foldM gives me a hard time
02:13:17 <blueonyx> i also dont need the value foldM produces only the IO actions it performs
02:17:24 <blueonyx> oh i have to use liftIO to do IO in the CL.foldM
02:22:39 * hackagebot protocol-buffers 2.4.0 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.4.0 (k_bx)
02:22:41 * hackagebot protocol-buffers-descriptor 2.4.0 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.4.0 (k_bx)
02:22:43 * hackagebot hprotoc 2.4.0 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.4.0 (k_bx)
02:27:39 * hackagebot wikicfp-scraper 0.1.0.1 - Scrape WikiCFP web site  https://hackage.haskell.org/package/wikicfp-scraper-0.1.0.1 (debugito)
02:52:22 <PragCyphr> has anyone ever run into something like this before when trying to do a cabal install? ghc: mmap 131072 bytes at nil: operation not permitted
03:27:07 <saurabhnanda> trying to use lenses for the first time. Stuck at multiple declaration error here: http://lpaste.net/164776
03:27:14 <saurabhnanda> how to get around this?
03:28:01 <EvanR> is there a counter example to show only knowing f (x . y) = f x . f y doesnt imply f id = id
03:29:08 <EvanR> saurabhnanda: you cant use the same field name in the same module
03:29:25 <EvanR> you can put each record type in a different module
03:29:40 <EvanR> or ghc 8 -XDuplicateRecordFields
03:29:45 <saurabhnanda> EvanR: isn't that one of the things that lenses solve? I was under the impression the _blah is a special case and doesn't really get declared
03:29:51 <EvanR> nope
03:29:52 <saurabhnanda> EvanR: on 7.10 right now
03:30:02 <EvanR> _ is just convention for lenses
03:30:27 <saurabhnanda> strange -- I read at multiple places that lenses were a possible solution for duplicate field names
03:30:53 <EvanR> yeah but the field accessors themselves arent lenses
03:31:16 <saurabhnanda> so I can have multiple lenses called "expires_in" ?
03:31:18 <EvanR> they will be used in the generated lenses
03:31:35 <EvanR> probably somehow, because type class tricks
03:31:56 <EvanR> but im not sure how makeLenses works
03:32:06 <saurabhnanda> any idea how to solve my current problem with lenses?
03:32:28 <saurabhnanda> is there a way to call the field name something else, but still have the lens called "expires_in
03:32:59 <EvanR> no i dont know
03:33:39 <saurabhnanda> too bad :(
03:34:51 <FjordPrefect_> What does ((!)) mean in imports? 
03:35:00 <EvanR> (!) is an operator
03:35:12 <FjordPrefect_> Okay. That does?
03:35:17 <EvanR> :t (!)
03:35:19 <lambdabot> Ix i => Array i e -> i -> e
03:35:27 <EvanR> crashing array lookup
03:37:10 <FjordPrefect_> I'm not sure I understand. Could you give me an example?
03:37:41 <jedai> FjordPrefect_: "array ! 0"  returns the first element of an array
03:38:10 <jedai> FjordPrefect_: equivalent to array[0] in other languages
03:38:45 <FjordPrefect_> Bah. Was overthinking it. Thanks jedai!
03:38:55 <EvanR> for the array a = [(0,'z'),(1,'e'),(2,'n'),(3,'o')], a ! 2 is 'n'
03:38:59 <EvanR> and a ! 9 is crash
03:39:04 <jedai> FjordPrefect_: of course given the type of (!) there's no provision to signal an out-of-bound index so you get an exception (so "crashing")
03:39:39 <EvanR> :t lookup
03:39:41 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
03:40:00 <EvanR> > 2 `lookup` [(0,'z'),(1,'e'),(2,'n'),(3,'o')]
03:40:03 <lambdabot>  Just 'n'
03:40:07 <EvanR> > 9 `lookup` [(0,'z'),(1,'e'),(2,'n'),(3,'o')]
03:40:08 <lambdabot>  Nothing
03:40:26 <EvanR> thats the list equivalent
03:40:47 <FjordPrefect_> I got it now
03:47:54 <EvanR> what do you call a commutative fmap
03:48:10 <EvanR> fmap f . fmap g = fmap g . fmap f
03:50:15 <mpickering> Distributive
03:50:27 <zenleaf> @help
03:50:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:50:47 <zenleaf> @list
03:50:48 <lambdabot> What module?  Try @listmodules for some ideas.
03:50:51 <EvanR> huh
03:50:58 <zenleaf> @help list
03:50:58 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
03:51:08 <EvanR> oh wow
03:51:11 <zenleaf> @type fmap
03:51:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:51:17 <Jinxit> zenleaf: the bot responds to PMs
03:51:29 <EvanR> "This is the categorical dual of Traversable."
03:51:49 <zenleaf> lol thanks Jinxit
03:58:25 <saurabhnanda> I managed to get lenses working with duplicate field name. However, I don't understand why the three gHC extensions were required. The tutorial doesn't mention them, so I'm not sure if I'm doing the right thing here -- http://lpaste.net/164777
03:59:18 <EvanR> saurabhnanda: can you paste the error you were getting too
03:59:46 <EvanR> saurabhnanda: also you fixed your field names, they are no longer duplicated
04:00:00 <saurabhnanda> EvanR: nuked the error. 
04:00:10 <saurabhnanda> EvanR: yes, found some functions to ease the boilerplate
04:00:24 <saurabhnanda> EvanR: first error had something to do with Fundeps
04:00:43 <EvanR> im just saying you dont have duplicate field names anymore
04:02:24 <saurabhnanda> EvanR: that is correct
04:12:29 <mpickering> saurabhnanda: It is because of the template haskell splices
04:13:15 <mpickering> It generates classes which require them extensions
04:14:28 <saurabhnanda> ah kay
04:44:50 <ggVGc> is there a type class for "things with singleton values"?
04:45:38 <EvanR>  :t?
04:46:34 <ggVGc> EvanR: I have a few functions that deal with Seq and Vectors, and I always only use mempty and X.Singleton
04:46:41 <ggVGc> eh, X.singleton
04:46:51 <ggVGc> so if ther is a type class for singleton, then all those become more generic
04:47:11 <maerwald> Maybe x?
04:47:12 <maerwald> :o
04:47:44 * hackagebot intero 0.1.9 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.9 (ChrisDone)
04:47:51 <EvanR> well theyre not generic since they have different constraints
04:48:09 <EvanR> so you wouldnt gain any polymorphism
04:49:17 <EvanR> the API of all those things have a lot of overlapping names
04:49:39 <EvanR> but theyre not polymorphic
04:50:25 <EvanR> ggVGc: heh.. but if youre lucky enough to have Applicative then pure
04:50:32 <EvanR> > pure 3 :: [Int]
04:50:34 <lambdabot>  [3]
04:51:15 <EvanR> which isnt always singleton, in which case id ask what the law for singleton is
04:54:46 <ggVGc> EvanR: in this specific case it's basically always Seq or Vector, so pure should work eh?
04:56:58 <EvanR> its certainly shorter than singleton
04:57:18 <ggVGc> EvanR: reason I want to do it is because I am experimenting with which data types to use while profiliung
04:57:29 <ggVGc> and it's annoying to change S.singleton to V.singleton etc.
04:57:48 <EvanR> you could just say singleton ;)
05:02:35 <EvanR> i am a group equipped with an operation bisect : g -> g -> g such that for any x,y : g  y = x * (bisect y x)^2
05:02:41 <EvanR> what am i
05:02:45 * hackagebot websockets 0.9.6.2 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.9.6.2 (JasperVanDerJeugt)
05:04:33 <EvanR> hmm
05:06:27 <EvanR> y = x + (y - bisect y x) + (bisect y x - x)
05:06:46 <EvanR> different saner bisect
05:08:00 <EvanR> implying commutative group
05:08:46 <EvanR> not saner, now bisect can be anything
05:09:29 <EvanR> y = x + (y - bisect y x)^2 = x + (bisect y x - x)^2
05:12:45 * hackagebot coin 1.0 - Simple account manager  https://hackage.haskell.org/package/coin-1.0 (piotrborek)
05:14:08 <EvanR> y - bisect y x = bisect y x - x
05:15:15 <EvanR> yx = xy = b^2
05:17:41 <Freundlich> EvanR: So b = id (if that's true for all x,y)?
05:18:24 <EvanR> i dont think so
05:20:03 <EvanR> yx = (rbisect y x)^2 for a regular group
05:20:15 <Freundlich> Right, I don't think I thought this through.
05:20:40 <EvanR> y + x = x + y = (bisect y x)*2 for a commutative group
05:27:28 <EvanR> > let bisect x y = let b = (x+y)/2 in if b*2 == x+y then b else error "_|_"
05:27:30 <lambdabot>  <no location info>:
05:27:30 <lambdabot>      not an expression: ‘let bisect x y = let b = (x+y)/2 in if b*2 == x+y th...
05:27:43 <EvanR> > let bisect x y = let b = (x+y)/2 in if b*2 == x+y then b else error "_|_" in bisect 2 2
05:27:47 <lambdabot>  2.0
05:28:18 <EvanR> > let bisect x y = let b = (x+y)/2 in if b*2 == x+y then b else error "_|_" in bisect 1 3
05:28:22 <lambdabot>  2.0
05:38:33 <EvanR> doubles are surprisingly resilient to this test
05:47:46 * hackagebot th-lift-instances 0.1.8 - Lift instances for template-haskell for common data types.  https://hackage.haskell.org/package/th-lift-instances-0.1.8 (BennoFuenfstueck)
05:49:29 <benzrf> @let bisect x y = let b = (x+y)/2 in if b*2 == x+y then b else error "_|_"
05:49:29 <s4ke> hi. i am having trouble writing a map with arrows
05:49:31 <lambdabot>  Defined.
05:49:56 <benzrf> @test \x y -> bisect x y `seq` ()
05:49:56 <lambdabot> Maybe you meant: tell list let leet
05:50:01 <benzrf> @quickcheck \x y -> bisect x y `seq` ()
05:50:01 <lambdabot> Unknown command, try @list
05:50:05 <benzrf> @check \x y -> bisect x y `seq` ()
05:50:07 <lambdabot>  No instance for (STestable ()) arising from a use of ‘myquickcheck’
05:50:07 <lambdabot>  In the first argument of ‘text’, namely ‘(myquickcheck (\ x y -> bisect x y ...
05:50:11 <benzrf> :(
05:50:35 <s4ke> how can i lift the first argument of map to an arrow?
05:50:43 <benzrf> s4ke: 
05:50:45 <benzrf> :t arr
05:50:46 <lambdabot> Arrow a => (b -> c) -> a b c
05:51:27 <EvanR> > bisect (1/3) (4/3)
05:51:29 <lambdabot>  0.8333333333333333
05:51:46 <EvanR> > bisect (5/16) (11/17)
05:51:49 <lambdabot>  0.4797794117647059
05:51:57 <EvanR> > bisect (5/16) (1000000/17)
05:51:59 <lambdabot>  29411.920955882353
05:52:07 <benzrf> @check \x y -> bisect x y `seq` True
05:52:09 <lambdabot>  +++ OK, passed 100 tests.
05:52:12 <EvanR> wtf
05:52:13 <benzrf> dang
05:52:31 <benzrf> :t bisect
05:52:33 <lambdabot> (Eq a, Fractional a) => a -> a -> a
05:52:41 <benzrf> wait - is it testing it using Rational?
05:52:41 <f-a> when I use forkIO do I have to worry about 'closing' threads?
05:52:47 <EvanR> > bisect (5/16) (1000000/17) :: Double
05:52:49 <lambdabot>  29411.920955882353
05:52:58 <benzrf> @check \x y -> bisect x (y :: Double) `seq` True
05:53:00 <lambdabot>  +++ OK, passed 100 tests.
05:53:02 <benzrf> @check \x y -> bisect x (y :: Float) `seq` True
05:53:04 <lambdabot>  +++ OK, passed 100 tests.
05:53:07 <benzrf> o=
05:53:09 <f-a> (like, say I call a bazillion times forkIO $ putStrLn "something")
05:53:10 <EvanR> someone fixed floats
05:53:31 <EvanR> > bisect (5/16) (1e-307) :: Double
05:53:33 <lambdabot>  0.15625
05:53:40 <EvanR> > bisect (5/16) (1e-308) :: Double
05:53:42 <lambdabot>  0.15625
05:53:59 <EvanR> guess that does nothing
05:54:01 <s4ke> basically i need this: ((a -> b) -> [a] -> [b]) -> ((arr a b) -> [a] -> [b])
05:54:26 <s4ke> benzrf: i know about arr :)
05:54:30 <EvanR> benzrf: there might be a proof that every pair of doubles has a bisection...
05:54:39 <EvanR> or midpoint
05:55:19 <EvanR> which would be enlightening
05:55:38 <EvanR> i assume bisecting had to induce something like rationals
05:55:52 <EvanR> but maybe its an artifact of doubles being broken in almost every other way
05:55:56 <benzrf> well, *that*'s not true
05:56:00 <benzrf> look up the dyadic ratoinals
05:56:08 <EvanR> right
05:56:14 <EvanR> something like dyadic rationals
05:57:33 <EvanR> if i can bisect doubles willy nilly, then that means perfect integrals....
05:57:59 <EvanR> at least perfect interval length
06:00:42 <ollie_jkdfsghfsk> How do you debug what's going on in a library in Haskell? I can't work out what's going on with this auth plugin I'm trying to set up in Yesod + LambdaCms
06:06:08 <Axman6> f-a: no, they are garbage collected
06:11:32 <f-a> thanks Axman6 
06:15:04 <maerwald> wow, this is awful... hspec seems to not stop testing when the before_ function fails
06:18:47 <s4ke> hmm is it even possible to write a generic map function that works on arrows?
06:19:54 <s4ke> meaning i want to convert map :: (a -> b) -> [a] -> [b] to an arrow map :: arr ((arr a b), [a]) [b]
06:20:11 <s4ke> and the only constraint is that arr is an ArrowApply
06:22:04 <EvanR> :t apply
06:22:06 <lambdabot> Not in scope: ‘apply’
06:22:29 <EvanR> :t app
06:22:30 <lambdabot> ArrowApply a => a (a b c, b) c
06:22:47 * hackagebot metronome 0.1.1 - Time Synchronized execution.  https://hackage.haskell.org/package/metronome-0.1.1 (PaoloVeronelli)
06:22:53 <EvanR> :t arr map
06:22:55 <lambdabot> Arrow a => a (a1 -> b) ([a1] -> [b])
06:38:04 <maerwald> ghc-mod doesn't compile again, what a surprise
06:40:42 <saurabhnanda> in the HTTP (or Wreq) library if I get a StatusException (due to a 400), how do I access the response body sent by the server?
06:43:20 <Axman6> saurabhnanda: IIRC, there's a huge hack for that, it's stored as a header in the exception or something
06:44:30 <saurabhnanda> Axman6: notices that
06:44:34 <saurabhnanda> *noticed that
06:44:37 <saurabhnanda> that's why I was inquiring
06:44:42 <saurabhnanda> seems strange that's been done
06:44:49 <Axman6> I agree
06:45:07 <Axman6> luckily I haven't run into it myself, but a colleague has
06:45:21 <saurabhnanda> is there a way for it to NOT throw an exception a return a regular Response object -- I can compare response codes on my own
06:45:33 <saurabhnanda> *and return
06:46:03 <EvanR> you can make it not throw an exception apparently using checkStatus
06:46:12 <EvanR> but you dont get a response object
06:47:48 * hackagebot hslogger 1.2.10 - Versatile logging framework  https://hackage.haskell.org/package/hslogger-1.2.10 (JohnGoerzen)
06:48:05 <saurabhnanda> type StatusChecker = Status -> ResponseHeaders -> CookieJar -> Maybe SomeException
06:48:08 <EvanR> all these functions look kind of backwards to me
06:48:10 <saurabhnanda> probably I can do something here
06:48:43 <saurabhnanda> when status is 400, my statusChecker shouldn't return an exception
06:48:47 <saurabhnanda> who came up with this interface?
06:48:59 <hexagoxel> I have an ast that contains many instances of a data constructor `Foo a = Foo Something a`, where `a` recurses further down in the tree. I'd like to generically fold this structure using the existing Data.Data.Data instance; the problem is that i need a way to observe the `Data a` constraint on any `Foo Something a`. When i gmapQl and cast, i cannot (easily/directly) retrieve that constraint.
06:49:42 <saurabhnanda> Function that checks the status code and potentially returns an exception. This defaults to Nothing, which will just use the default of Request which throws a StatusException if the status is not 2XX.
06:50:01 <hexagoxel> is there something better than using `gmapQi` and doing some wonky extraction/re-synthesizing on Foo?
06:50:12 <Axman6> saurabhnanda: is this for github btw?
06:50:18 <EvanR> saurabhnanda: i looked at 0.1.0.0 for giggles... applyCheckStatus :: (Status -> ResponseHeaders -> CookieJar -> Maybe SomeException) -> Response BodyReader -> IO (Maybe SomeException)
06:50:30 <Axman6> I seem to remember my colleague's problem coming when working github
06:50:37 <saurabhnanda> Axman6: github?
06:50:41 <EvanR> making more sense now
06:50:47 <saurabhnanda> Axman6: no, any RESTful endpoint 
06:50:48 <Axman6> the API you're accessing
06:50:55 <Axman6> right, ok
06:50:57 <saurabhnanda> Axman6: Google uAoth
06:51:01 <saurabhnanda> google oauth
06:51:18 <Axman6> ah, maybe it was that actually
07:17:49 * hackagebot hasql-transaction 0.4.5 - A composable abstraction over the retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.4.5 (NikitaVolkov)
07:53:45 <xenog> If I call a C function that creates threads from my Haskell program, how does the Haskell runtime deal with them?
07:54:18 <xenog> If the thread has its signals masked, and my Haskell program terminates with an interruptible signal, will the program stop running or not?
07:59:16 <geekosaur> it will stop when the main thread does
08:00:55 <turiya> hi
08:04:10 <lpaste> turiya pasted “ghccore repa” at http://lpaste.net/164781
08:04:42 <turiya> i am trying to understand the slow performance of my program using repa
08:04:55 <turiya> i have been learning about ghc core today 
08:05:27 <turiya> how do i know from the ghc core code whether my sum is strict or not
08:06:01 <turiya> line no. 37 in http://lpaste.net/164781
08:06:36 <turiya> in the expression (+## sc1 1.0)
08:07:35 <lpaste> turiya pasted “program repa” at http://lpaste.net/164782
08:08:08 <dfeuer> Why does it take so long to build transformers?
08:13:00 <xenog> Thank you geekosaur, I’m trying to understand how the C++ ØMQ library interacts with the Haskell code when using the bindings.
08:27:52 * hackagebot these 0.7 - An either-or-both data type & a generalized 'zip with padding' typeclass  https://hackage.haskell.org/package/these-0.7 (phadej)
08:52:53 * hackagebot hpath 0.7.2 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.7.2 (maerwald)
09:02:53 * hackagebot linear 1.20.5 - Linear Algebra  https://hackage.haskell.org/package/linear-1.20.5 (EricMertens)
09:07:54 * hackagebot octane 0.5.2 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.2 (fozworth)
09:26:44 <ggVGc> I want to generate a list like [(0,0), (0,1), (0,2), (1,0), (1,1),(1,2),(2,0),(2,1),(2,2)]. What's the best way⎋?
09:27:14 <EvanR> > [(i,j) | i <- [0..2], j <- [0..2]]
09:27:16 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
09:27:50 <EvanR> "i love it when a plan comes together"
09:28:00 <ggVGc> ah, a simple list comprehension
09:28:04 <ggVGc> yeah, I just figure it out :)
09:28:10 <ggVGc> heh, I forgot about list comporehensions for a while
09:28:33 <ggVGc> that's so elegant
09:28:34 <ggVGc> love it
09:32:16 <maerwald> I sometimes feel like it's syntax sugar of 2nd degree. Too much sugar :P
09:33:56 <ggVGc> maerwald: but writing what I needed just now in another way is pretty ugly
09:33:59 <ggVGc> waht's your alternative?
09:34:07 <maerwald> do-notation
09:34:08 <ggVGc> a nested map expressio?
09:34:42 <ggVGc> maerwald: do notation is a lot more noise than this, https://gist.github.com/eadb17ae7eb7da1f5695e66eecae80a8
09:35:07 <maerwald> only slightly
09:35:27 <EvanR> somehow i dont think about list monad as being in any particular order
09:35:33 <EvanR> but i guess i should
09:35:51 <ggVGc> EvanR: isn't that basically the point of List?
09:35:58 <ggVGc> to be an oredered sequence
09:36:30 <EvanR> the "point" of the monad instance is to implement non deterministic computation
09:36:54 <EvanR> which doesnt mean randomly sorted, but im not sure what order it should be
09:37:27 <EvanR> ideally the one that maximizes your chance of getting the desired answer
09:39:42 <geekosaur> it's nondeterminacy, not concurrency. things come out in an order but that order will be affected by intermediate results
09:40:45 <maerwald> ggVGc: ([0..reps] >>= \rep -> [0..laneLen] >>= \trig -> return (rep,trig)) == ([(rep,trig) | rep<-[0..reps], trig<- [0..laneLen]])
09:42:02 <ertes> hi there…  is ixset still the way to go for relational in-memory data?
09:42:21 <ertes> i need Set with automatically maintained indices
09:44:56 <ggVGc> maerwald: yeah.. I don't think thats' better than the list comprehension
09:45:36 <ggVGc> is this too much nesting? https://gist.github.com/c112dc35b3c17a61ac9cfd3af075277a
09:45:46 <maerwald> ggVGc: I think it is
09:46:20 <ertes> ggVGc: i think you overuse (&) a bit
09:46:53 <ertes> lenses are the only example of "argument first" i can think of, when it's actually nicer
09:47:51 <ggVGc> ertes: yes, everyone does
09:48:14 <maerwald> I don't :P
09:48:16 <ondraa> hello. I wanted to go through https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html so I did 'stack new digits', added the packages as in the artical to stack.yaml and added them as extra-deps, however when I try to include hmatrix, I get "Could not find module ‘Numeric.LinearAlgebra.Static’". How can I fix it, please? Thank you
09:48:29 <ertes> ggVGc: me neither
09:49:22 <ondraa> I also get "Ignoring package Cabal due to wanting version 1.22.8.0 instead of 1.22.5.0" if I run stack build with -v flag, it might be related.
09:49:50 <ggVGc> ertes: I meant everyone thinks I do
09:50:21 <ertes> ah
09:50:25 <ertes> that's because you do =)
09:51:06 <ertes> the problem is:  i need to digest multiple lines of code to understand the *structure* of your code…  not what it does, just what is passed to what
09:51:46 <ertes> when the simple solution is: just use forM instead of mapM
09:52:59 <ggVGc> yeah, fair
09:53:14 <ggVGc> how can I write this using modify instead of get/put? https://gist.github.com/d4f55ae579aabc1cb74e1b41f6d474c3
09:54:11 <ertes> (do x <- get; put (f x)) = modify f
09:55:36 <ertes> since you use the result after 'put', you actually need 'state' rather than 'modify'
09:55:58 <ertes> (do x <- get; put (f x); pure (g x)) = state (\x -> (g x, f x))
09:59:10 <ggVGc> ertes: , so, this? https://gist.github.com/a5a5d3cebfead79efba183b15dcd1903
09:59:20 <ggVGc> compiles and seems to be what I want?
10:00:18 <ertes> ggVGc: looks good
10:00:29 <ggVGc> except for the & :)
10:00:33 <ggVGc> I actually just moved it
10:00:38 <ggVGc> breaking out of the habit
10:01:22 <ertes> don't worry…  you will get out of that habit very quickly, once you have to revisit your own code six months later =)
10:02:00 <ertes> the same way i learned not to overuse ($) =)
10:02:19 <ggVGc> yeah, I've started using more parenthese
10:02:22 <ggVGc> aI used to hate them
10:02:28 <ggVGc> but now I kind of like them a lot
10:02:33 <ertes> same here
10:02:36 <EvanR> next stop, lisp
10:02:45 <ggVGc> not that much..
10:02:51 <ggVGc> EvanR: I also like types and a compiler
10:03:06 <ertes> my trouble with lisp is not that it has so many parentheses, but that they have meaning other than grouping
10:03:13 <ertes> (f x) vs. ((f x))
10:03:25 <ggVGc> I didn't even know that
10:03:29 <EvanR> yep
10:03:50 <ggVGc> how can I import something like lookup from Map unqualified without clashing with Prelude?
10:03:55 <ggVGc> oh, wait
10:03:57 <ggVGc> it's not in prelusde
10:03:59 <ggVGc> it's in list
10:04:08 <Zemyla> EvanR: Is it because a function with zero arguments is different from its result?
10:04:28 <ertes> ggVGc: you can actually import Prelude explicitly, if you want:  import Prelude hiding (...)
10:04:42 <EvanR> function(){} vs (function(){})()
10:04:50 <ggVGc> oh, it's in prelude..
10:04:56 <ggVGc> ertes: ah, didn't know about hiding
10:04:57 <ggVGc> thanks
10:05:12 <Zemyla> Yeah. I like that Haskell doesn't have that distinction.
10:05:35 <ertes> ggVGc: but the convention is to only use that to hide a special operator in order to import a more general variant, e.g. this is common:  import Control.Category; import Prelude hiding ((.), id)
10:06:17 <Zemyla> ertes: Why are (.) and id not the ones from Control.Category in the first place?
10:06:33 <ertes> ggVGc: also if you need to use 'lookup', you probably shouldn't use lists at all
10:06:40 <ggVGc> ertes: other way
10:06:45 <ggVGc> I'm switching from vector to Map
10:06:51 <ertes> Zemyla: history, i guess
10:06:53 <ggVGc> using Map.lookup
10:07:04 <ertes> Zemyla: same reason why 'map' is not fmap
10:07:06 <EvanR> raisins, damn
10:07:14 <Zemyla> So it could be changed like FTP did?
10:07:44 <ertes> ggVGc: the convention here is to import Data.Map.Strict qualified, most commonly as M
10:07:49 <ertes> so you get M.lookup
10:07:49 <geekosaur> in theory
10:10:36 <ggVGc> I used GHC's heap profiling for the firs ttime yesterday
10:10:38 <ggVGc> and man
10:10:39 <ggVGc> so awesome
10:10:46 <ggVGc> getting a graph with almost no work
10:10:55 <ggVGc> helped me so much in optimizing some things
10:12:56 * hackagebot hruby 0.3.4 - Embed a Ruby intepreter in your Haskell program !  https://hackage.haskell.org/package/hruby-0.3.4 (SimonMarechal)
10:28:03 <saurabhnanda> does anyone know how to "run" a HandlerT (from yesod)?
10:28:32 <saurabhnanda> :t Yesod.Auth.GoogleEmail2.getPerson
10:28:33 <lambdabot>     Not in scope: ‘Yesod.Auth.GoogleEmail2.getPerson’
10:28:53 <Clint> saurabhnanda: what are you trying to do?
10:30:48 <saurabhnanda> more specifically, how do I manually (i.e. outside the regular scope/context of a yesod app) run this function -- https://s3.amazonaws.com/haddock.stackage.org/lts-6.0/yesod-auth-1.4.13.2/Yesod-Auth-GoogleEmail2.html#v:getPerson
10:31:15 <saurabhnanda> Clint: I have a google oauth access token and I want to use getPerson from Yesod-auth, instead of rewriting my own
10:32:24 <saurabhnanda> the oauth token has NOT come from the regular yesod <=> google integration. I'm using a different method for acquiring the oauth tokens (a method recommended for limited capability devices)
10:33:14 <geekosaur> quite possibly you don't, if it relies on yesod internal state
10:33:47 <Clint> looks like it doesn't
10:34:10 <saurabhnanda> Clint: doesn't what?
10:34:29 <Zemyla> > div (1 + ord maxBound) 65536
10:34:31 <lambdabot>  17
10:34:33 <ondraa> ě/quit
10:34:45 <saurabhnanda> isn't there a way to run an action wrapped inside a HandlerT monad? FWIW, my massive, complicated app, has a yesod app running in a separate thread as well.
10:35:04 <Clint> saurabhnanda: looks like it doesn't rely on yesod internal state as geekosaur suggested
10:35:16 <saurabhnanda> ah okay -- so that's good news for me
10:36:21 <brain2k> http://espedito.homepc.it hiz...))
10:37:35 <cocreature> saurabhnanda: the simplest solution would probably to reimplement getPerson, it’s only 4 lines
10:37:54 <geekosaur> damn. comes in here, sits 4 hours, spams and immediately exits
10:38:01 <geekosaur> the spammers are winning :(
10:38:10 <saurabhnanda> cocreature: well, that's not fun. This way I get to learn more about monad transformers and how yesod's written
10:39:29 <cocreature> saurabhnanda: well HandlerT requires you to pass in yesod’s internal state
10:39:49 <cocreature> so running it outside of your yesod context is not that easy
10:40:05 <cocreature> but there is no reason that getPerson should run in HandlerT
10:40:29 <saurabhnanda> cocreature: if it helps, my app has access to all of Yesod's data structures AND a running yesod app, but in a different thread
10:40:31 <cocreature> it just requires MonadIO and MonadResource
10:41:05 <Zemyla> Man, I find it really awkward that there are 17 * 65536 characters. It makes making a tree for them so awkward.
10:41:07 <saurabhnanda> cocreature: ah, so are you saying that it's just wrapped in HandlerT as a convenience -- because it's a yesod library
10:41:16 <cocreature> saurabhnanda: yep
10:41:28 <saurabhnanda> cocreature: so, how do I uncomplicate it's function signature
10:41:30 <cocreature> saurabhnanda: you can basically copy the source and let ghc infer a more general type for you
10:41:43 <saurabhnanda> cocreature: copy the source :)
10:41:59 <cocreature> copy the source of getPerson that is
10:42:37 <EvanR> Zemyla: make 17 trees ;)
10:43:08 <EvanR> each one perfectly balanced
10:43:34 <Zemyla> EvanR: Yeah, that's what I'm going to do.
10:43:34 <saurabhnanda> cocreature: yes, I got that... but I don't want to copy the source, really. There must be a way to run a HandlerT action.
10:44:05 <saurabhnanda> there is an unHandlerT
10:44:25 <cocreature> yeah you can use unHandlerT but then you nee dHandlerData 
10:44:56 <Zemyla> I'm trying to make an interval-based CharSet, and creating a CharSet from a function Char -> Bool is something that benefits from lazy evaluation.
10:45:34 <cocreature> saurabhnanda: I mean you could probably just pass undefined to the function you get from unHandlerT since it doesn’t look like getPerson uses it
10:46:28 <Zemyla> On the other hand, is there anyone who's used MVars and unsafePerformIO to manage thunks themselves?
10:47:11 <EvanR> o_O
10:47:34 <EvanR> you can rig up "pure" Futures that way
10:48:25 <EvanR> for intervals of things in a tree you can split on a key to get the left and right tree
10:48:50 <saurabhn_> cocreature: I have another thread running the same yesod app, can't that help anyhow?
10:49:17 <cocreature> saurabhn_: can you run code in that thread at any point or only if you get a request and yesod calls one of your handlers?
10:49:21 <ertes> Zemyla: i would make 17 bit-fields, each 8 KiB in size and optional (if any of the bits are set)
10:49:31 <cocreature> I’ve never used yesod
10:50:16 <ertes> Zemyla: very small memory footprint…  you can increase the granularity to get even smaller…  O(1) member query
10:51:46 <saurabhn_> cocreature: AFAIK, with my limited knowledge, yesod controls the http-manager, intercepts the requests, and calls the handlers that I've defined
10:52:16 <cocreature> saurabhn_: then having another thread doesn’t really help as you can’t use it to run your request
10:53:04 <saurabhn_> hmm
10:53:05 <saurabhn_> okay
10:53:05 <saurabhn_> let me think of some other way
10:53:09 <orion`_> What are the strengths/weaknesses of parallel-io and async-pool?
10:54:04 <Zemyla> ertes: I actually want the granularity to be 256 bits, and I'd probably have it evaluate the first 256 bits explicitly.
10:55:04 <ertes> Zemyla: i'd choose the granularity based on the length of a cache line
10:55:43 <ertes> 64 bytes are common, i think, so 512 bits
10:57:00 <ertes> but it's also a question of usage:  if you aren't going to have many characters in the set, you can use IntSet
10:57:51 <Zemyla> Well, yeah, there's an IntSet-based CharSet on hackage, but the other thing I was kind of wanting to do was have it actually be a set of intervals.
10:58:53 <ertes> to query intervals or just to represent intervals efficiently?
11:00:32 <ertes> in any case, you get both using a finger-tree of character intervals; see the fingertree package
11:01:59 <ertes> it even has a predefined implementation of IntervalMap
11:04:37 <juanca_> Does anyone knows where to find GHC.SrcLoc or CallStack in ghc 8？ i can't seem to find it :(
11:10:41 <Zemyla> juanca_: GHC.Stack.
11:16:03 <juanca_> Zemyla: I get this: Data constructor not in scope: CallStack
11:16:07 <juanca_> :(
11:16:26 <Zemyla> Can you paste your code?
11:18:55 <juanca_> i'm trying to fix this library for a personal project 
11:18:56 <juanca_> https://github.com/Soostone/katip/blob/master/katip/src/Katip/Core.hs
11:19:03 <juanca_> to work with ghc 8
11:23:16 <Zemyla> juanca_: SrcLoc is in GHC.Stack now.
11:24:01 <Zemyla> Also, you need to use HasCallStack instead of ?loc :: CallStack, and callStack instead of ?loc.
11:33:53 <Zemyla> I have a question.
11:34:06 <Zemyla> Why doesn't the Applicative instance of IO use (*>) = (>>)?
11:34:28 <Zemyla> Wait, they do. But they don't use thenIO.
11:36:24 <juanca_> yes I need SrcLoc
11:38:37 <Zemyla> juanca_: Well, SrcLoc is in GHC.Stack, so it should work without GHC.SrcLoc.
11:39:17 <juanca_> Zemyla: ghc 8 doesn't find that module
11:39:31 <Zemyla> Which one, GHC.Stack? It's in base-4.9.0.0.
11:41:44 <juanca_> yup
11:42:16 <juanca_> Zemyla: I'm thinking that i should just leave like that and keep using ghc 7.10
11:43:49 <Zemyla> Nah, just send an issue to the package's creator.
11:44:39 <juanca_> Zemyla: i'll do so, but just one question, what should they use thenIO?
11:45:16 <Zemyla> juanca_: That was a different thing entirely, and doesn't have anything to do with your callStack stuff. :V
11:45:22 <Zemyla> Sorry, I jump from topic to topic without warning.
11:45:54 <juanca_> I see, thanks dude for your time
11:46:40 <Zemyla> juanca_: Did you try removing GHC.SrcLoc? It should work then.
11:48:08 <juanca_> Zemyla: yup it builds, but it loses that part for logging
11:48:38 <Zemyla> It shouldn't, because it's all in GHC.Stack.
11:50:21 <juanca_> there's a function that use all that, i really don't need it but the library was built using that. Anyway stack seems capable of solving by ghc version and i can add my custom dirs
11:50:28 <juanca_> it is enough in this case
11:50:31 <juanca_> i guess
12:02:51 <ggVGc> is there a generalisation over Map and IntMap?
12:04:37 <dolio> Not really.
12:04:58 <enthropy> http://hackage.haskell.org/package/EdisonAPI-1.3/docs/Data-Edison-Assoc.html might be
12:05:03 <ryantrinkle> ggVGc: https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-At.html#t:At
12:05:28 <dolio> Way back, there were ideas about creating a Map type that would use a specific 'best' implementation for each type. But it never really happened.
12:05:34 <dolio> Unless you could HashMap.
12:06:25 <ryantrinkle> it doesn't give you union/intersection/etc., but i've found this `at` lens to be quite useful for generalizing lookups and such
12:07:32 <ertes> ggVGc: Monoid gives you union, and the semigroupoids package gives you Apply (intersection) and Alt (union)
12:07:41 <ggVGc> rtur: yeah, I'm doing it with ix now
12:07:54 <ertes> ggVGc: At from lens gives you lookup and update
12:07:58 <ryantrinkle> ertes: oh yeah, good point! and `these` gives you unionWith
12:08:05 <ggVGc> what type signature is I need again for using ix? https://gist.github.com/6d7ce2d5f1acf34f2aee0400e485e17b
12:08:13 <ggVGc> I always forget how to write it
12:08:37 <ertes> ryantrinkle: btw, semigroupoids is a great interface for Event
12:09:07 <ryantrinkle> ertes: interesting; what's the mapping?
12:09:48 <ertes> ryantrinkle: it gives you principled event intersection and union without insisting on 'pure' (the nonsensical "event that happens all the time")
12:10:27 <ryantrinkle> ertes: hmm, i'm having trouble grasping how the kinds would line up: https://hackage.haskell.org/package/semigroupoids-5.0.1/docs/Data-Semigroupoid.html
12:10:32 <ryantrinkle> is that the thing you're referring to?
12:10:56 <ertes> ryantrinkle: Data.Functor.Apply, Data.Functor.Plus
12:11:23 <ertes> in principle Event is even a Data.Functor.Bind, but that might be difficult to implement in your model
12:17:39 <ertes> ryantrinkle: also Data.Functor.Extend (Comonad without 'extract'): turn an (Event a) into an (Event (Event a)), the event of single-occurrence-events
12:17:59 <ryantrinkle> ertes: ah, interesting
12:18:30 <ertes> in case you missed it: Data.Functor.Apply, Data.Functor.Plus; in principle Event is even a Data.Functor.Bind, but that might be difficult to implement in your model
12:18:32 <ggVGc> god, what's the tupe signature for an indexable collection?
12:18:40 <ggVGc> I don't understand IxValue, Ixed etc.
12:18:41 <ggVGc> :/
12:18:50 <ertes> ggVGc: what do you need?
12:18:57 <ryantrinkle> ggVGc: it might be best to just write some code and then see what GHC gives you :P
12:18:58 <ertes> ggVGc: collections with multiple indices?
12:19:17 <ryantrinkle> ertes: yes, i think you're right about that stuff - and i think Data.Functor.Bind.join might just be Reflex.Class.coincidence
12:19:18 <glguy> Ixed are things that can be indexed, Index returns the type you index something with, IxValue returns the value you get when you index something
12:19:29 <ertes> ryantrinkle: it is
12:19:35 <ryantrinkle> it does satisfy the law
12:19:48 <ryantrinkle> it *was* difficult to implement :P
12:19:51 <ggVGc> this, https://gist.github.com/6b2f8c6e62c4021e97bbc0634fc6a880
12:19:57 <ertes> ryantrinkle: i can imagine =)
12:20:14 <ertes> ryantrinkle: the dual 'duplicate' from Extend may be just as difficult
12:20:23 <ertes> though not necessarily
12:20:27 <glguy> ggVGc: You're getting that because of monomorphism restriction
12:20:36 <ryantrinkle> ertes: well, there's onceE
12:20:42 <ryantrinkle> and headE
12:20:55 <ryantrinkle> i think you could just do something like
12:20:58 <glguy> err, wrong
12:21:07 <ryantrinkle> pushAlways (\_ -> onceE e) e
12:21:09 <glguy> you're getting it because writing that type signature requires an extension, oops
12:21:12 <ertes> ryantrinkle: but onceE relies on MonadHold
12:21:18 <ertes> duplicate has to be pure
12:21:23 <ryantrinkle> ertes: you get MonadHold inside of pushAlways
12:21:28 <ryantrinkle> even though pushAlways is itself pure
12:21:40 <ertes> ah, indeed
12:21:44 <ryantrinkle> (the hold runs at the time the event fires)
12:21:54 <ggVGc> glguy: not sure what that means :/
12:22:28 <glguy> ggVGc: We can't guess what it is you don't understand
12:22:31 <ertes> ryantrinkle: here is the AFRP semantics i use: http://hub.darcs.net/esz/wires/browse/Control/Wire/Internal.hs#69
12:22:41 <ggVGc> glguy: I don't know what "monomorphism restriction" is
12:22:42 <ggVGc> sorry
12:22:46 <ggVGc> readin now
12:22:59 <glguy> ggVGc: Forget about that one, it's not related ot this problem, I responded too quickly
12:23:12 <ggVGc> glguy: well, I know I've solved this before by adding the correct type signature
12:23:15 <glguy> ggVGc: The problem is that the inferred type as a constraint that isn't allowed by normal Haskell 2010
12:23:17 <ggVGc> but I always get lost with ixed
12:23:40 <ggVGc> because I don't really get type families yet
12:23:45 <glguy> Constraints have to be:  Thing variable variable variable
12:24:00 <glguy> FlexibleConstraints allows you to have: non-variables as arguments to constraints
12:25:18 <ggVGc> I thought I would be able to do something like this? https://gist.github.com/71e9a056aeac2e134bb6eec2f0372517
12:25:28 <jle`> @tell ondraa let me know if you still need any help!
12:25:28 <lambdabot> Consider it noted.
12:25:42 <glguy> ggVGc: If you want to do that you need to add an extra constraint that   Index s ~ Int
12:26:12 <glguy> That is that the type 's' can be indexed by 'Int's
12:26:25 <ggVGc> how do I add that contraint?
12:26:47 <glguy> (Index s 07~ Int, Ixed s) 07=> Int 07-> s 07-> [Maybe (IxValue s)]
12:26:54 <ggVGc> oh, I never saw that syntax before
12:26:55 <ggVGc> thanks
12:27:04 <glguy> You'll need the TypeFamilies language extension to use that "equality constraint" 
12:27:17 <ertes> i never understood the index stuff from lens
12:27:22 <ggVGc> ertes: same
12:27:24 <ggVGc> hence why I struggle
12:27:35 <ggVGc> I am trying to write general functions over Map and IntMap
12:27:40 <ggVGc> and Ixed seems to be the best option
12:28:28 <ertes> in terms of lens "indices" seem to be something other than "keys", because i've used things like At and Ix without ever caring about indices or "index preserving"
12:28:30 <ggVGc> glguy: cheers, that worked
12:29:11 <glguy> The optics that carry around the current "index" are orthogonal to indexable data structures
12:29:23 <glguy> that's just about remembering where you are, not about actually doing indexing
12:29:56 <ertes> so it corresponds more to traverseWithKey than lookup/update
12:30:03 <ertes> ?
12:30:23 <glguy> yeah, but more to the WithKey part then the traverse part
12:30:40 <ertes> i see
12:31:33 <ertes> do traversals (the optics i use the most) ever *not* preserve indices?
12:31:43 <ertes> since the laws suggest they always do
12:32:42 <glguy> normal traversals don't carry indexes at all
12:33:13 <glguy> e.g. traverse
12:35:18 <ertes> ah…  so there are indexed traversals that give me access to the position during traversal, there are index-preserving traversals that i can compose with them and still get the indices
12:35:30 <glguy> yeah
12:35:34 <ertes> but non-indexed non-preserving traversals would hide the index
12:36:13 <ertes> so, given indexed traversal f, with 'f . traverse' i could no longer access the indices
12:36:18 <ertes> right?
12:36:20 <glguy> Right
12:36:28 <ertes> i see, thanks
12:36:45 <glguy> It will force f to have a type that doesn't track them at all, so it's not that it hides them as much as they don't get carried
12:37:03 <ertes> yeah, i see
12:37:07 <glguy> That's where the Conjoined megaclass comes in, it has two instances, one that carries indexes and one that doesn't
12:37:25 <ertes> why do you call it "megaclass"?
12:37:50 <glguy> because of the wall of superclasses that it has
12:38:16 <glguy> It's only intended to have two instances "normal functions" and "indexed functions", so it has a super class for everything those two types have in common
12:38:17 <ertes> ah
12:38:28 <ertes> no worries, i've seen worse
12:48:52 <ertes> > "-abcd" %@~ replicate
12:48:53 <lambdabot>      Couldn't match type ‘[Char]’
12:48:53 <lambdabot>                     with ‘Indexed Int a0 (Identity [a0]) -> s -> Identity t’
12:48:53 <lambdabot>      Expected type: AnIndexedSetter Int s t a0 [a0]
12:49:17 <ertes> > "-abcd" & itraversed %@~ replicate
12:49:19 <lambdabot>  ["","a","bb","ccc","dddd"]
12:49:33 <ertes> interesting
12:50:11 * ertes understands indexed optics
12:50:22 * ertes is a bit happier
12:52:04 * ertes is also a bit sad, because now ertes is going to refactor all of ertes' traversals, so they become index-preserving
12:52:26 <ertes> with great power comes great…
12:59:12 <Jinxit> work, it seems
13:27:03 <Lokathor> so it seems that i can use stack with ghc8 as long as i just pick a nightly rather than an LTS?
13:33:37 <jle`> Lokathor: yup, and you can add extra dependencies as you need (if they build)
13:34:34 <Lokathor> time to upgrade stack i suppose
13:34:37 <dfeuer> Should Data.Sequence have insertAt?
13:34:42 <jle`> (extra deps that are outside of the lastest nightly, at least)
13:34:48 <jle`> Lokathor: i don't think you need to upgrade stack to use the new nightly
13:35:11 <Lokathor> well i'm on stack 1.0 anyway, so i should probably take a moment to upgrade either way
13:35:41 <jle`> ah yeah, probably might as well :)
13:36:27 <dfeuer> Also, I'm wondering if Data.Sequence.adjust is too lazy. If someone performs a bunch of adjustments to various elements, they'll all stack up at the top of the tree. Should I eagerly push them down to the leaves?
13:37:33 <ertes> dfeuer: insertAt would be useful…  also there should be a 'split' that never misses an element
13:37:48 <ertes> oh, wait
13:37:51 <dfeuer> ertes, what do you mean by "never misses an element"?
13:37:55 <ertes> i'm in a different module
13:38:03 * hackagebot scotty-resource 0.1.1.0 - A Better way of modeling web resources.  https://hackage.haskell.org/package/scotty-resource-0.1.1.0 (taphu)
13:38:03 <dfeuer> ertes, oh, you're thinking Data.IntMap.
13:38:07 <dfeuer> I completely agree.
13:38:13 <ertes> yeah
13:38:16 <dfeuer> That's just weird.
13:38:27 <dfeuer> ertes, what should it be called?
13:38:42 <ertes> dfeuer: i think, it should be called 'split' =)
13:38:48 <dfeuer> No can do. Sorry.
13:38:48 <ertes> the current 'split' is…  wrong…
13:38:57 <dfeuer> Of course.
13:39:02 <dfeuer> But there's no changing it. 
13:39:20 <ertes> yeah, i know…  splitAt perhaps?
13:39:28 <dfeuer> Hrmmmm..
13:39:36 <dfeuer> Actually,
13:39:44 * chenyu say hello to everyone
13:39:44 <dfeuer> I'm sorry to say I'll have to use the names from Data.Map.
13:39:53 <dfeuer> Which kind of suck, but consistency.
13:40:03 <dfeuer> That is, if there's a nice way to implement what you want.
13:40:22 <ertes> it can be implemented in terms of splitLookup and insert
13:40:30 <dfeuer> I'm very tempted to deprecate and kill Data.IntMap.split; as you said, it's wrong.
13:40:44 <ertes> so it should be efficient enough
13:41:06 <dfeuer> What do you think about my actual question, regarding Data.Sequence.insertAt?
13:41:22 <ertes> insertAt would have been useful to me in the past
13:41:48 <dfeuer> And, by the way, someone on StackOverflow requested // for Data.Sequence; i'm thinking doing that right would need Data.IntMap.splitSensibly.
13:41:59 <dfeuer> In the past?
13:42:00 <ertes> about strictness: Seq is one of those containers that essentially needs a .Lazy/.Strict split
13:43:44 <Lokathor> oh yay, stack can upgrade itself on windows
13:44:08 <ertes> i mean: i encountered cases when insertAt would have saved me from splitting and reassembling
13:44:17 <dfeuer> Hrmmmm. That's an option, I suppose. The adjust, update, and (if added) insertAt support implementations that are "structurally strict" but still lazy.
13:44:33 <dfeuer> For many other operations, a strict version is fairly worthless.
13:44:46 <dfeuer> Strictly mapping over a sequence is pretty expensive.
13:45:03 <ertes> i don't think strictness is terribly necessary…  you can always use ($!) or seq
13:45:24 <ertes> would just be a convenience
13:45:37 <dfeuer> I'm just saying that there are a very few operations where certain forms of strictness might be good even in the lazy case.
13:45:48 <dfeuer> I should really distinguish better here
13:45:52 <dfeuer> between "strict" and "eager".
13:45:54 <dfeuer> Sorry.
13:46:20 <dfeuer> Making adjust build its result eagerly could sometimes prevent an unpleasant buildup of thunks.
13:46:26 <dfeuer> But also,
13:46:48 <ertes> how about providing both variants?
13:46:51 <ertes> adjust and adjust'
13:46:54 <dfeuer> a *strict* version could be useful, to prevent a *terrible* buildup of thunks of someone adjusts the same location over and over.
13:46:59 <dfeuer> So there are really three options:
13:47:29 <dfeuer> 1. strict and eager, 2. non-strict and eager, 3. non-strict and lazy
13:47:44 <ertes> that doesn't really help =)
13:47:56 <ertes> i like the "structurally strict" and "value-strict" distinction more
13:48:05 <dfeuer> OK...  adjust :: (a -> a) -> Int -> Seq a -> Seq a
13:48:16 <dfeuer> There are two non-strict variants.
13:48:52 <dfeuer> In one, you place a thunk at the root of the tree, which will get knocked down step by step as relevant portions of the tree are accessed.
13:49:13 <dfeuer> One the second, you descend the tree and place a thunk at the relevant leaf.
13:49:35 <dfeuer> In the last, you descend the tree, evaluate the function strictly, and place the result in the leaf.
13:49:47 <ertes> they can be mixed as well: structure-non-strict, value-strict (if you reach the leaf, the value is evaluated)
13:50:33 <ertes> or even: the value is evaluated as soon as the root constructor is reached
13:50:46 <dfeuer> ???
13:50:56 <dfeuer> That last is just the strict one.
13:50:59 <ertes> sorry, that was nonsense
13:51:10 <dfeuer> The mixed one is a possibility, but I'm not sure it's useful enough in this context.
13:52:10 <ertes> i think a structurally non-strict variant is not very useful in general…  it would blow up very quickly, if you build sequences iteratively
13:52:20 <ertes> and i don't see a benefit…  you don't get infinite sequences or anything
13:52:21 <dfeuer> That's the *current* version.
13:52:28 <ertes> really?
13:52:59 <dfeuer> Well, there are operations (like map) where that sort of laziness is the best thing;
13:53:17 <Zemyla> ertes: You know, this reminds me of the fact that most packages that provide an "extract nth value" don't separate the "evaluate the extraction" part from the "evaluate the value" part.
13:53:22 <dfeuer> there are operations like <| and |> that take care to force things incrementally to prevent buildups,
13:53:30 <Zemyla> Vector does, with indexM and such.
13:53:44 <dfeuer> there are operations like splitAt and viewl that naturally force things as needed,
13:53:51 <dfeuer> but then adjust and update just don't.
13:54:00 <dfeuer> It could have been an oversight, I suppose.
13:54:22 <dfeuer> Zemyla, most packages don't have to care.
13:54:42 <dfeuer> Vector only has to care because you can't pattern match on a vector.
13:57:52 <Zemyla> dfeuer: Well, things like Map aren't pattern-matchable, but it provides something that returns a Maybe.
13:58:28 <dfeuer> True dat.
13:59:03 <dfeuer> Very true dat.
13:59:24 <dfeuer> Data.Sequence really should offer such a thing.
13:59:26 <dfeuer> As well.
13:59:38 <dfeuer> As well/ass well
13:59:42 <monochrom> it offers two. viewl and viewr
13:59:59 <monochrom> or are they viewL and viewR?
14:00:20 <dfeuer> monochrom, viewl/viewr, IIRC, but it doesn't offer indexMay, which it really should.
14:00:28 <monochrom> I see
14:00:29 <dfeuer> I hate that name, though. Ugh!
14:00:40 <monochrom> pig latin
14:01:26 <dfeuer> So the only way to accomplish that is something like viewl . drop, which is not so efficient.
14:01:48 <dolio> Laziness is essential to the asymptotic complexity of Data.Sequence.
14:02:06 <dfeuer> dolio, absolutely. Some of it is, anyway. Some of it is not.
14:02:54 <ertes> dfeuer: why is (viewl . drop n) not so efficient?
14:03:20 <dfeuer> Data.Sequence is actually rather well-behaved, laziness-wise, in that it's generally pretty easy to see where the laziness is and is not essential....
14:03:54 <dfeuer> ertes, because it builds a whole tree and then discards everything but the root.
14:04:10 <dfeuer> Its big-O is fine, but its constant factor sucks.
14:04:19 <ertes> i see
14:04:32 <ertes> isn't 'drop' lazy enough?
14:05:07 <dfeuer> It used to be rather stupidly lazy. I've made it stricter. I'm not going back.
14:05:53 <dfeuer> (building O(log n) thunks to avoid building an O(log n) tree spine is not such a hot idea)
14:07:56 <dfeuer> ertes, splitting (taking, dropping) is inherently an O(log (min (i, n -i))) *monolithic* operation. Lazily deferring rebuilding just leads to more churn.
14:13:04 * hackagebot hruby 0.3.4.1 - Embed a Ruby intepreter in your Haskell program !  https://hackage.haskell.org/package/hruby-0.3.4.1 (SimonMarechal)
14:14:26 <buttbutter> I'm not sure if more context is needed, but. Why does this work: validate :: Integer -> Bool
14:14:29 <buttbutter> validate x =  (sumDigits . doubleEveryOther . toDigits $ x) `mod` 10 == 0 
14:14:53 <buttbutter> But not validate x = sumDigits . doubleEveryOther . toDigits $ x `mod` 10 == 0 
14:15:15 <dolio> $ has lower precedence than pretty much everything.
14:15:43 <geekosaur> $ is not something that can guess what you mean; it just has very low precedence
14:15:52 <Zemyla> It winds up being (sumDigits . doubleEveryOther . toDigits) $ ((x `mod` 10) == 0).
14:15:54 <geekosaur> lower than both (.) and mod
14:15:59 <buttbutter> Oh. Hm. So if f = sumDigits . doubleEveryOther . toDigits. Then in the second case it's f (x `mod` 10 == 0)?
14:16:00 <geekosaur> and (==)
14:17:11 <buttbutter> So is there a better way to write it other than what I have above with the parens?
14:18:04 * hackagebot pcre-utils 0.1.8.1 - Perl-like substitute and split for PCRE regexps.  https://hackage.haskell.org/package/pcre-utils-0.1.8.1 (SimonMarechal)
14:18:24 <dolio> You could move more stuff into the composition, if you like that better.
14:18:54 <dolio> (== 0) . (`mod` 10) . sumDigits . doubleEveryOther . toDigits
14:19:00 <ertes> dfeuer: i see, thanks
14:20:00 <buttbutter> dolio: Oh. Of course.
14:20:05 <ertes> is there a small functional, lazy scripting language i can easily embed?
14:20:22 <buttbutter> Seeing '==' as a function is still...pecuiliar to me. :P
14:20:41 <buttbutter> Thanks everyone!
14:21:18 <ertes> buttbutter: it has been a function in every language you have used before, but for some reason the language designers thought that it needs arbitrary special restrictions ;)
14:22:38 <ertes> buttbutter: you may find it more interesting that (&&) is a regular function…  in other languages it's a language-construct to achieve short-circuiting
14:24:07 <EvanR> i thought == and if were core primitives of the universe ;)
14:24:16 <buttbutter> ertes: Oh, interesting. I haven't taken an PL theory course yet so I don't know too much about the implementations :(
14:24:32 <EvanR> then i thought church encoded bools were
14:24:50 <ertes> EvanR: and today you don't even know what equality is anymore =P
14:25:01 <EvanR> you know it when you see it
14:25:11 <ertes> the curse of understanding type theory
14:26:07 <ertes> buttbutter: in the language you have used before, try to implement the function (&&)
14:27:44 <ertes> buttbutter: example in javascript:  function and(x, y) { return x ? y : false; }
14:28:19 <ertes> then try this:  and(false, infiniteLoop());
14:28:29 <ertes> and compare to this:  false && infiniteLoop();
14:30:23 <monochrom> or you could use division by zero
14:30:38 <ertes> yeah: and(false, 1/0);
14:30:42 <EvanR> not in javascript
14:30:49 <monochrom> heh
14:30:53 <dolio> Yeah, 1/0 is probably just false or something.
14:31:07 <ertes> hehe
14:33:12 <ertes> JS seems to have Infinity, too
14:33:18 <Zemyla> ertes: An embedded, functional, lazy scripting language? Like, perhaps, Haskell? http://hackage.haskell.org/package/hint
14:33:28 <ertes> Zemyla: small ;)
14:33:41 <ertes> i.e. not GHC ;)
14:33:53 <Zemyla> Reimplment hint in Hugs? :P
14:33:56 <dolio> Right, it has Infinity, but it will work as a boolean.
14:35:09 <Zemyla> ertes: Also, the best example would be and(false, alert("Hello!"))
14:35:30 <ertes> yeah, perhaps
14:36:32 <orion`_> Hey, anyone know when stackage will support GHC 8?
14:36:32 <Zemyla> But yeah, I don't know of any other functional, lazy languages no matter what the language.
14:36:33 <ertes> you know why i can't write javascript?  i wouldn't even have thought of side effects at that point
14:36:38 <Zemyla> *what the size.
14:37:00 <maerwald> ertes: javascript is one thing, async IO another
14:38:06 <ertes> if 'False && alert "blah"' weren't a type error in haskell, and if (&&) were fully strict, i would still expect it to do nothing
14:38:14 <ertes> it would just be False
14:38:33 <geekosaur> orion`_, apparently nightlies alreadt do. I don't know what scheduling there is for LTS ghc8
14:38:45 <orion`_> geekosaur: Ah, thanks.
14:39:31 <ertes> (&&) :: (b :: Bool) -> if b then Bool else a -> Bool
14:40:13 <dolio> You definitely don't want that.
14:42:53 <dfeuer> Hrmm... I should be able to define Data.Sequence.deleteAt too. It will be a bit messy, but it seems wrong to add insertAt without also adding deleteAt.
14:47:41 <orion`_> geekosaur: Are there major differences between parallel-io and async-pool?
14:47:52 <geekosaur> I have no idea
14:47:56 <dfeuer> In a QuickCheck property, is there a nice way to request an Int in a certain range?
14:48:37 <dfeuer> It seems nasty to ask for an Int and then discard it if it happens to be in the wrong range.
14:49:00 <dfeuer> Is there some way to ask for a random seed instead and pull the Int out of that?
14:49:27 <geekosaur> iirc the only way to do that is a newtype with a custom Arbitrary instance, and unwrap to use?
14:50:10 <dfeuer> geekosaur, that won't work here, I don't think, because we don't have dependent types!
14:51:47 <glguy> with tricks like the reflection package you wouldn't need dependent types for that
14:51:56 <Zemyla> dfeuer: Use a newtype for Seq that only generates Seqs of the length given, and a newtype for Int that only generates Ints in [0, n - 1].
14:52:14 <Zemyla> Because remember, one of the parameters for Gen is a size parameter.
14:53:20 <dfeuer> Zemyla, that forces me to fix the length altogether in the type, and make a separate property for each length. All I want is an Arbitrary seed, and a function to pull an Int range out of that.
14:54:10 <Zemyla> Not really. Generate a length, then test the property with that length.
14:54:35 <ertes> dfeuer:
14:54:38 <ertes> :t mkStdGen
14:54:39 <lambdabot> Int -> StdGen
14:54:45 <ertes> :t randomR
14:54:46 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
14:54:47 <orion`_> I've been told that if you want a thread to continuously be running regardless of what exceptions are thrown, you could use a thread pool. Is it also possible to use forkFinally from base?
14:55:07 <dfeuer> ertes, that's not a terrible option at all.
14:55:15 <dfeuer> I don't think.
14:55:16 <orion`_> What are the pros and cons of using a thread pool to keep a thread running as opposed to catching all exceptions?
14:55:52 <ertes> dfeuer: it's inefficient…  personally i'd go with a newtype and reflection to encode the range on the type level
14:56:04 <dfeuer> ertes, I was thinking about reflection too....
14:56:10 <dfeuer> I was about to mention it.
14:56:22 <dfeuer> I'll have to think about how that would work.
14:56:42 * dfeuer goes to figure that out.
14:56:58 <ertes> dfeuer: instance (Reifies r (a, a)) => Arbitrary (Ranged r a)
14:57:20 <ertes> reflect (Proxy :: Proxy r)  -- needs ScopedTypeVariables and gives you the range
14:57:31 <EvanR> orion`_: there was a package which implemented an unkillable thread, cant remember the name
14:57:57 <EvanR> immortal
14:58:01 <ertes> dfeuer: one quirk is that you may not be able to use 'reify', depending on your test framework
14:58:12 <EvanR> https://hackage.haskell.org/package/immortal-0.2.2/docs/Control-Immortal.html
14:58:15 <ertes> dfeuer: but you can write an explicit Reifies instance
14:58:40 <dfeuer> ertes, I wanted to figure it out myself, but I was thinking in that direction.
14:58:47 <ertes> oh, sorry =)
15:00:00 <Zemyla> Also, is dfeuer doing this in the official containers package? Because I don't think adding a "reflection" dependency would be good for something that lives in the Haskell platform.
15:00:19 <ertes> Zemyla: it's a test dependency
15:00:33 <abg> dfeuer, ertes: You may also be able to use the 'Given' class from reflection. I've had moderate success with it in passing 'parameters' down to Arbitrary instances.
15:00:41 <dfeuer> Zemyla, the containers test suite is for containers developers and Travis CI. It's not really for general consumption.
15:00:50 <dfeuer> abg, I will not use Given now or ever.
15:00:57 <dfeuer> Unless I'm extremely desperate.
15:01:00 <abg> What's wrong with it?
15:01:00 <orion`_> EvanR: Thanks for that.
15:01:15 <ertes> abg: it's basically a global variable in disguise
15:01:18 <dfeuer> abg, read its documentation first, and then ask that again.
15:01:34 <dfeuer> Ed Kmett told me he'd remove it from the module except that people would complain.
15:01:41 <Zemyla> Ohh, can't you use KnownNat and its reification?
15:01:58 <dfeuer> Zemyla, another thing I was thinkin' about. Also a nice idea.
15:01:58 <abg> No, I understand that. To alleviate issues, I wrapped everything in newtypes or custom types.
15:02:23 <abg> Like, Given FooParams => instance Arbitrary Foo where ...
15:02:23 * dfeuer goes to see if he can do it the sensible way first, before falling back on horrors.
15:02:44 <dfeuer> Another option might be just to ask for a Large Int and then use rem.
15:02:52 <dfeuer> Low-tech, but whatever.
15:03:02 <ertes> Zemyla: with all the ugly plumbing necessary to use TypeLits, reflection might be nicer
15:03:04 <dfeuer> (and yeah, not a fair sample, but that doesn't matter)
15:03:15 <Zemyla> Actually, why can't you use the size parameter given to a Gen?
15:03:46 <Zemyla> I mean, that's literally what it's there for, and it's given random values when the property is tested.
15:03:47 <metl> how could i combine a null check with isPrefixOf to exclude empty string matching?
15:03:56 <ertes> dfeuer: works, but depending on your range you don't get uniform distribution that way
15:04:16 <dfeuer> Zemyla, you can do a lot of things in Gen land, but it's hard to do that and keep your property type signatures meaningful, unless there's some trick I've missed.
15:05:02 <ertes> ok, let's overengineer this
15:05:05 <metl> i guess i come up with: (\x -> (not $ null x) && isPrefixOf x "quit") ""
15:05:06 <dfeuer> ertes, real uniformity is an extremely low priority for QuickCheck. It just needs to be uniform enough to get reasonable coverage.
15:05:14 <Zemyla> :t let { go (cp:lp) (cl:ll) | cp == cl = isPrefixOf lp ll; go _ _ = False } in go -- metl
15:05:16 <lambdabot> Eq a => [a] -> [a] -> Bool
15:05:30 <ertes> if you use singletons, you can use specify the range on the value level and still pick the right Arbitrary instance
15:05:41 <ertes> myProp (Ranged 15 20 x) = ...
15:05:45 <hexagoxel> if there is "boolean blindness", does "Maybe blindness" make sense as well?
15:06:00 <ertes> hexagoxel: i count that to boolean blindness
15:06:31 <dfeuer> hexagoxel, absolutely. My limited experience with dependently typed languages suggests that Either-like types are much more useful. And in general you might as well give them custom names so you can see what's going on.
15:06:46 <ertes> "boolean blindness" = reducing formal information to assumptions
15:07:03 <ertes> like:  when (not (null xs)) (print (head xs))
15:07:07 <dfeuer> Instead of  Maybe (a :~: b), it's nice to have something like Either (a :~: b -> Void) (a :~: b).
15:07:26 <nkaretnikov> is there anyone using hell as their primary shell daily?  how is it?
15:08:44 <ertes> hexagoxel: it's not the boolean that's essential here, but the cons
15:08:44 <Zemyla> dfeuer: Actually, use sized from Test.QuickCheck.Gen.
15:09:02 <dfeuer> Zemyla, use it for what how?
15:11:06 <Zemyla> Am I the only one seeing that Gen a literally is passed an Int for the purposes of using as a size parameter for anything that needs it?
15:11:15 <Zemyla> unGen :: Gen a -> QCGen -> Int -> a
15:11:49 <dfeuer> Zemyla, I see that, but what that "size" means is generally rather vague.
15:12:11 <dfeuer> And usually undocumented.
15:12:41 <dfeuer> But I guess I could use it with a custom Arbitrary instance.
15:12:48 <dfeuer> To implement whatever.
15:13:06 <dfeuer> What's it buy me?
15:13:50 <Zemyla> It means you don't have to mess with type-level literals and reflection.
15:13:59 <glguy> "get to"*
15:15:21 <hexagoxel> dfeuer: but Maybe ~ Either () … the "custom names" aspect makes sense though.
15:15:52 <hexagoxel> ertes: that example makes me doubt again that i understand the concept at all :/
15:16:05 <dfeuer> hexagoxel, sure, but in a dependently typed setting, having a Maybe often means that when you get Nothing you have to go dig into where it came from to figure out what it means, and life sucks.
15:16:30 <dfeuer> Whereas an Either may be able to tell you immediately everything you need to know.
15:17:31 <hexagoxel> dfeuer: ah, so using an Either with some newtype'd wrapper around () would already give you more to work with. makes sense, thanks.
15:17:49 <dfeuer> Zemyla, the size stuff is all in Gen-land. How's that help me in property-land?
15:18:00 <dfeuer> hexagoxel, no, probably not.
15:18:13 <dfeuer> hexagoxel, in Haskell, Maybe is very often quite enough.
15:18:28 <xrisk> :q
15:18:28 <dfeuer> But custom names might be useful anyway.
15:19:18 <dfeuer> data Lookup a = Missing | FoundIt a  is nice, but it's probably not worth the trouble and losing the ability to use fromMaybe, maybe, etc.
15:21:33 <hexagoxel> i would use that definition over the following, but using "Lookup a = Either NotFound a; newtype NotFound = ()" would provide the same information, right?
15:21:45 <hexagoxel> you could even `either` over that :)
15:22:10 <hexagoxel> `newtype NotFound = NotFound ()` ofc
15:22:42 <glguy> dfeuer: I want to the QuickCheck documentation for the property module and searched for "size"
15:22:52 <glguy> dfeuer: Looks like you can modify the size insider your property
15:23:43 <orangerobot> What is the Haskell equivalent for Scala's flatMap?
15:23:57 <hexagoxel> (>>=) ?
15:24:47 <orangerobot> hexagoxel: is that syntactic sugar for an actual function with a name?
15:24:59 <Zemyla> orangerobot: No, that's the actual name of the function.
15:25:08 <orangerobot> Zemyla: alright thanks
15:25:14 <Zemyla> list >>= fn is the equivalent of flatMap fn list.
15:25:25 <twanvl> For lists there is concatMap
15:27:42 <aupiff> how can I pass flags to a package's Setup.hs when using stack?
15:28:03 <aupiff> the equivalent of cabal's "--configure-option"
15:29:15 <orangerobot> Zemyla: isn't it called bind? Quoting from LYAH: "The >>= function is pronounced as bind."
15:30:10 <Zemyla> It's actually pronounced "tuk tuk yob". :P
15:30:54 <hexagoxel> > [1,2,3] >>= \x -> [x,x]
15:30:56 <lambdabot>  [1,1,2,2,3,3]
15:31:01 <hexagoxel> ! List(1,2,3).flatMap(x => List(x,x))
15:31:21 <hexagoxel>  List[Int] = List(1, 1, 2, 2, 3, 3)
15:31:38 <hexagoxel> :t (>>=)
15:31:39 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:32:20 <hexagoxel> > (>>=) [1,2,3] (\x -> [x,x])
15:32:22 <lambdabot>  [1,1,2,2,3,3]
15:32:24 <hexagoxel> orangerobot: it is actually written like that, no matter how you pronounce it.
15:32:26 <twanvl> > concatMap (\x -> [x,x]) [1,2,3]
15:32:29 <lambdabot>  [1,1,2,2,3,3]
15:32:41 <dfeuer> glguy, that looks like a big and very unwieldy hammer.
15:32:59 <orangerobot> alright hexagoxel 
15:33:07 <hexagoxel> orangerobot: but it is indeed called "bind"
15:35:09 <dfeuer> I'm thinking an extremely obvious thing would be to add an Arbitrary instance for Test.QuickCheck.Random.QCGen.
15:36:15 <dfeuer> Maybe not the friendliest for seeing what case failed, but just generally pleasant to have around in case it's needed.
15:38:21 <hexagoxel> (there are containers in scala, like Map, that implement FilterMonadic, where the haskell equivalent is not a Monad, though. and vice versa.)
15:40:03 <Zemyla> dfeuer: Add a Coarbitrary instance, too, and you can create random Gens. :P
15:40:27 <dfeuer> Zemyla, let me see here....
15:48:08 * hackagebot ersatz 0.3.1 - A monad for expressing SAT or QSAT problems using observable sharing.  https://hackage.haskell.org/package/ersatz-0.3.1 (EricMertens)
15:53:01 <Zemyla> There's a package for solving the SATs?
15:56:27 <dfeuer> Oh, there it is!
15:56:38 <dfeuer> Test.QuickCheck.Property.forAll.
15:56:54 <dfeuer> er...
15:56:56 <dfeuer> Wait, no.
15:57:04 <dfeuer> er ... maybe.
15:57:08 <dfeuer> No.
15:57:10 <dfeuer> Wat.
15:57:18 <dfeuer> No.
16:05:20 <dfeuer> Sooooo much work here.
16:12:47 <juanca_> Has anyone here have used hadoop with haskell?
16:18:02 <Welkin> juanca_: shoop da woop
16:20:43 <juanca_> Welkin: I need help, in hadoop you can use hadoop straming to use any executable as mapper and reducer, as long as they use STDIN and STDOUT
16:20:51 <juanca_> there's a hakell library hadron
16:21:01 <juanca_> but there's no enough documentation
16:21:09 <juanca_> and i need help
16:22:36 <Welkin> that is common with haskell libraries
16:22:43 <Welkin> the solution is to read the source very carefully
16:22:49 <Welkin> I have not worked with that one in particular
16:23:03 <Welkin> it is usually easy enough to figure out if you follow the types
16:23:25 <Welkin> or you could wait around for someone who has used it to show up here
16:24:33 <juanca_> Welkin: i don't know if it is worth the effort, i mean i could make something very simple for stdin and stdout
16:37:37 <Myrl-saki> What's the "idiomatic" way to use emacs and nix?
16:37:44 <Myrl-saki> Rather, use emacs in nixos?
16:43:09 * hackagebot lambdabot-core 5.1 - Lambdabot core functionality  https://hackage.haskell.org/package/lambdabot-core-5.1 (BertramFelgenhauer)
16:43:11 * hackagebot lambdabot-haskell-plugins 5.1 - Lambdabot Haskell plugins  https://hackage.haskell.org/package/lambdabot-haskell-plugins-5.1 (BertramFelgenhauer)
16:43:13 * hackagebot lambdabot-irc-plugins 5.1 - IRC plugins for lambdabot.  https://hackage.haskell.org/package/lambdabot-irc-plugins-5.1 (BertramFelgenhauer)
16:43:15 * hackagebot lambdabot-misc-plugins 5.1 - Lambdabot miscellaneous plugins  https://hackage.haskell.org/package/lambdabot-misc-plugins-5.1 (BertramFelgenhauer)
16:43:17 * hackagebot lambdabot-novelty-plugins 5.1 - Novelty plugins for Lambdabot  https://hackage.haskell.org/package/lambdabot-novelty-plugins-5.1 (BertramFelgenhauer)
16:47:21 <Eromenos__> Greetins haskellers
16:47:30 <Eromenos__> Is anybody about?
16:47:49 <simpson> Eromenos__: Sure.
16:47:54 <Eromenos__> hi simpson 
16:48:01 <simpson> Hi.
16:48:14 <Eromenos__> are you elite haskeller? :D
16:48:19 * hackagebot lambdabot-reference-plugins 5.1 - Lambdabot reference plugins.  https://hackage.haskell.org/package/lambdabot-reference-plugins-5.1 (BertramFelgenhauer)
16:48:21 * hackagebot lambdabot-social-plugins 5.1 - Social plugins for Lambdabot  https://hackage.haskell.org/package/lambdabot-social-plugins-5.1 (BertramFelgenhauer)
16:48:23 * hackagebot lambdabot-trusted 5.1 - Lambdabot trusted code.  https://hackage.haskell.org/package/lambdabot-trusted-5.1 (BertramFelgenhauer)
16:48:25 * hackagebot lambdabot 5.1 - Lambdabot is a development tool and advanced IRC bot  https://hackage.haskell.org/package/lambdabot-5.1 (BertramFelgenhauer)
16:48:42 <simpson> Probably not.
16:48:59 <Eromenos__> haha
16:49:05 <Eromenos__> i wondered if anyone could answer my question
16:49:13 <Eromenos__> i have a feeling i know the answer is 'no' but...
16:49:29 <shachaf> If you have a question you should ask it instead of trying to get people to commit to helping you without knowing what your question is.
16:49:39 <Eromenos__> is there a way in haskell to detect fields required for a partially constructed type?
16:52:00 <roboguy`> Eromenos__: fields for a partially constructed type?
16:52:18 <Eromenos__> i guess firstly: is a partially constructed type even possible?
16:52:29 <roboguy`> what is a partially constructed type?
16:52:32 <glguy> Maybe give an example of what you're trying to do
16:52:46 <Eromenos__> ok i will invent an example now
16:53:52 <Eromenos__> data Object = Object {number :: Int, name :: String}
16:54:14 * EvanR thinks "type" means "record value" and partially constructed is partially applied ctor
16:55:11 * geekosaur thinks so too
16:55:31 <glguy> I know geekosaur thinks so
16:55:31 * geekosaur also thinks that while new programmers think Monad is the incomprehensible thing, it's Maybe that they really don't understand...
16:55:47 <Eromenos__> example = Object {number=2}
16:56:11 <EvanR> thats fully constructed
16:56:17 <EvanR> with undefined
16:56:26 <glguy> Eromenos__: If you want to indicate that some field is missing you can parameterize your object type so that you can tell from the types that a field has the wrong type
16:56:35 <Eromenos__> right, is there a way for a function to observe the missing field?
16:56:43 <glguy> data Object a = Object { number :: Int, name :: a }
16:56:50 <glguy> then an object without a name could have type Object ()
16:57:01 <glguy> but once you set the name it could be Object String
16:57:33 <glguy> You can also use a type synonym to hide that a bit: type FinishedObject = Object String
16:58:46 <glguy> Or you can have name :: Maybe String
16:58:50 <glguy> and initialize it to Nothing
16:58:59 <Eromenos__> i thought  about using Maybe for all the fields
16:59:39 <geppettodivacin> Is there a way to handle evaluating an undefined without exception handling?
16:59:47 <Eromenos__> what i want  to achieve is to have a type that has a bunch of required fields
16:59:47 <geppettodivacin> For example, an isUndefined function?
16:59:55 <Eromenos__> and for there to be defaults for these fields
17:00:05 <glguy> geppettodivacin: No, it's a feature that it's hard to detect undefined
17:00:34 <geppettodivacin> glguy: Makes sense.
17:00:35 <Eromenos__> and to be able to pass partially constructed types to a function that constructs this type, 'overriding' the defaults
17:01:10 <Eromenos__> i could do it by wrapped every field in a Maybe
17:01:33 <Eromenos__> but that  would mean when i want  to define overrides, i would have to create a whole bunch of Nothings, along with the one or two fields that were important  
17:01:45 <Eromenos__> glguy, am i making some sense?
17:01:58 <geppettodivacin> Eromenos__: You may want to consider having a default function (maybe called "default" or "defaultObject") and then modify the attributes of that default object.
17:02:07 <Koterpillar> perhaps you can parametrize your type by a Functor? data Object f = Object { number :: f Int, name :: f a }
17:02:25 <geppettodivacin> @let data Object = Object { number :: Int, name :: Maybe String }
17:02:28 <lambdabot>  Defined.
17:02:28 <Koterpillar> and when you're done setting all the values, convert it to a plain object where f = Identity
17:02:53 <geppettodivacin> @let defaultObject = Object { number = 0, name = Nothing }
17:02:55 <lambdabot>  Defined.
17:03:12 <glguy_> Koterpillar: that works but it gets annoying to deal with the newtype constructor for Identity
17:03:13 <geppettodivacin> > defaultObject { name = Just "geppettodivacin" }
17:03:15 <lambdabot>      No instance for (Show Object)
17:03:15 <lambdabot>        arising from a use of ‘show_M36500138509253297944627’
17:03:15 <lambdabot>      In the expression:
17:03:21 <geppettodivacin> :P
17:03:33 <geppettodivacin> @let defaultObject = Object { number = 0, name = Nothing } deriving Show
17:03:33 <lambdabot>  Parse failed: Parse error: deriving
17:03:34 <Eromenos__> geppettodivacin i understand what you are saying, do you think it is possible to have a version where the nothings can be excluded?
17:04:03 <geppettodivacin> Eromenos__: What do you mean by "excluded?"
17:04:08 <geppettodivacin> The fields will always exist.
17:04:21 <geppettodivacin> But they can have "no value," or Nothing.
17:04:37 <geppettodivacin> I'm not sure what more you want.
17:04:42 <Koterpillar> Eromenos__: do you really want pass the incomplete objects around?
17:04:55 <Eromenos__> i need to rethink my question
17:05:29 <roboguy`> you can just keep a default value at the top level and set fields with record syntax when you make a new value
17:05:35 <Koterpillar> Eromenos__: if you only want to have them in a limited scope, define another type, MaybeObject, with all the fields Maybe'd, and have a function converting it to a Maybe Object for the outside world
17:05:41 <roboguy`> no Maybes needed
17:05:58 <Eromenos__> that... works i think
17:07:04 <geppettodivacin> The other thing you could do is make it a sum type.
17:07:47 <Eromenos__> thanks guys i will think about all this
17:07:49 <geppettodivacin> @let data Object2 = Object { number :: Int, name :: String } | ObjectWithoutName { number :: Int }
17:07:51 <lambdabot>  .L.hs:275:16:
17:07:51 <lambdabot>      Multiple declarations of ‘Object’
17:07:51 <lambdabot>      Declared at: .L.hs:272:15
17:08:05 <geppettodivacin> @unlet
17:08:06 <lambdabot>  Define what?
17:09:41 <Eromenos__> im only trying to come up with a way in haskell to create 'subclasses' without having to restructure a whole module when adding new 'subclasses'
17:10:06 <roboguy`> geppettodivacin: you would need 2^n constructors in the sum type though, where n is the number of fields
17:13:11 * hackagebot rethinkdb-client-driver 0.0.23 - Client driver for RethinkDB  https://hackage.haskell.org/package/rethinkdb-client-driver-0.0.23 (wereHamster)
17:17:03 <pwm> Hi all, I'm a complete beginner. My question is if a monad is commutative does that mean that bind is Ma -> (a -> Ma) -> Ma instead of Ma -> (a -> Mb) -> Mb?
17:17:29 <dolio> No.
17:17:41 <Eromenos__> Hi pwm 
17:17:49 <Eromenos__> i think it would be
17:17:59 <dolio> Commutative means that the two ways of going from (M a, M b) to M (a, b) are the same.
17:18:15 <Eromenos__> if it was commutative the evaluated monad would have to be the same type as the input
17:18:22 <shachaf> A commutative monad is still a monad, so you can do everything with it that you can do with a monad.
17:21:29 <roboguy`> Eromenos__: not necessarily. dolio's pair example would be an instance of that not holding
17:22:41 <Eromenos__> i see
17:22:42 <roboguy`> in terms of do notation, for commutative monads, this "do { x <- mx; y <- my; return (x, y) }" is the same as "do { y <- my; x <- mx; return (x, y)"
17:24:54 <pwm> Sorry for the pseudo code, but then how does something like bind(bind(unit(a), f), g) works if the inner bind(unit(a), f) return Mb but the 1st parameter for bind is Ma?
17:25:23 <EvanR> Eromenos__: i'd say that there are better ways to that inheritance to structure your code in haskell, though it may take some practice to figure out how
17:25:38 <EvanR> than inheritance*
17:26:05 <EvanR> however if you mean record subtyping, then theres a few options for that
17:26:45 <EvanR> since the point is to be able to convert a more specific record to one with fewer fields, you can have two record types and an explicit quotienting function
17:27:02 <EvanR> theres also extensible records
17:27:25 <Eromenos__> oh yea you nailed it, im exploring inheritance in haskell
17:27:49 <EvanR> inheritance is usually not a good idea, theres better ways to reuse implementation code
17:27:56 <Eromenos__> quotienting function?
17:27:58 <roboguy`> pwm: a and b are not concrete types, bind is polymorphic in a and b. So the 'b' from the inner bind would match (that is, be the same type as) the 'a' from the outer bind
17:28:14 <EvanR> an example of a quotienting function is one that forgets fields
17:28:39 <EvanR> another is one that returns the floor of a double
17:29:07 <Eromenos__> ah
17:29:17 <EvanR> i.e. a function that looks at some type and cant tell the difference between some of them
17:29:23 <EvanR> some of the values
17:30:25 <roboguy`> > (Just 3 >>= (\x -> return (x * 10))) >>= (\y -> return (y + 2))
17:30:29 <lambdabot>  Just 32
17:30:37 <EvanR> a sort of opposite notion is sometimes used for subtyping, like "any int can be mapped injectively into the reals"
17:30:41 <pwm> roboguy, thanks i'll mull over this
17:30:45 <roboguy`> ^ pwm the 'b' of the inner bind matches the 'a' of the outer bind there
17:31:08 <EvanR> that one is more like a subset type
17:31:38 <EvanR> either way haskell eshews implicit conversions
17:31:47 <Eromenos__> right
17:32:07 <Eromenos__> ill have a look around for ways to reuse implementation code
17:32:17 <EvanR> thats like bread and butter of FP
17:32:25 <EvanR> factor out reused implementation
17:33:09 <simpson> Bread and butter for pretty much any program, really; I'm having trouble thinking of languages where it doesn't apply.
17:33:29 <EvanR> FP makes it easy
17:33:39 <EvanR> at least for "functional" situations
17:33:54 <simpson> Forth makes it easiest, I think.
17:34:04 <EvanR> which is why people keep looking for ways to think about stuff functionally
17:34:43 <simpson> Like, one of my favorite standard Forth words is... : 1+ 1 + ;
17:35:57 <simpson> If that's not extreme factoring, then I don't know what is.
17:36:02 <EvanR> composability isnt just about how easy it is to put things together, if it were then big ball of mud C programs would count as "composable". the dual key notion is to be able to take it apart again, ideally any slice of your code that you take still makes sense somehow, then you can rearrange it
17:38:02 <EvanR> if its locked together like a puzzle that sucks, if something easily moves then causes antimatter containment failure that sucks
17:39:00 <simpson> Sure. Seriously, Forth embodies this principle. Relatives like Joy and Factor give you more FP-like combinators, but the principle's still the same.
17:39:16 <EvanR> i see forth may work like this
17:39:22 <EvanR> not too familiar with it
17:40:10 <dolio> What does defining 1+ do for you? Save a space?
17:40:58 <simpson> It's a very simple language in a family called "concatenative languages". These languages have the pleasant property that, in general, you can concatenate two valid programs to compose them.
17:41:18 <EvanR> guessing untyped?
17:41:34 <simpson> dolio: Originally, yeah. By the time of ANS FORTH, IIUC it was in the standard so that implementations could use an efficient CPU opcode.
17:42:11 <simpson> Forth is untyped, but Joy and Factor are typed, and their typing resembles an exotic (and awesome) type-system concept called "row polymorphism".
17:42:59 <vx1r_> i've heard forth described as the failed pre-julia julia
17:43:31 <simpson> Julia, the Python-descended language for numerical work?
17:43:33 <hpc> i wouldn't describe it as failed, since i have seen it discussed more than julia
17:43:52 <vx1r_> nowadays, no way... much more hype around julia atm
17:44:32 <vx1r_> simpson yeah i suppose it's starting to fill in the gap of "better language than python for scientific computing" that forth was somewhat intended to?
17:44:42 <roboguy`> simpson: hmm, you don't happen to know any papers about a connection between Forth with delayed blocks and lambda calculus, do you? That's something I've wondered about for a while
17:45:17 <roboguy`> You can implement a church-style boolean, if statement and while using just some delayed blocks, force, dup, drop and swap (IIRC)
17:45:20 <vx1r_> julia seems to be more of an  amalgamation of matlab/python + nicer fp, f#-ish ideas + nicer llvm/performance-oriented features
17:45:33 <simpson> vx1r_: Whoa! No, Forth is ancient; it's a couple decades older than Python. And it was intended as a general-purpose language to bridge the (then) gap between assembly hackers and "high-level languages" like FORTRAN, IIUC.
17:46:21 <simpson> roboguy`: Interesting! That's interesting. I know that you can emulate call/cc with a single mutable cell and the ability to touch the return stack, so I wouldn't be surprised if you could build delays in a similar way.
17:46:56 <simpson> vx1r_: Forth is the language that OpenFirmware drops you into, if you've ever been on one of those machines.
17:47:36 <vx1r_> my experience is probably skewed. the few contexts in which i've heard forth mentioned have been discussions of julia where people were asking why forth never filled the niche julia is in
17:47:59 <vx1r_> i guess they vaguely share the high-low level language gap space
17:48:12 <vx1r_> as does haskell
17:48:16 <EvanR> julia is still pretty high up
17:48:23 <EvanR> and dynamic
17:48:43 <EvanR> i didnt see a way to directly modify the llvm code
17:48:57 <vx1r_> EvanR i'm not really into it. the selling point is "never write C again" though (at least for scientific computing purposes)
17:49:05 <roboguy`> simpson: I've heard you can do a lot with 'dip' but I actually haven't tried using it yet
17:49:09 <simpson> vx1r_: Well, I've never heard anything like that, and I'm super-confused by the concept. Forth's strength lies in having words like @ and ! which touch memory directly, all the way up to arbitrarily-high-level meta-object protocols.
17:49:14 <EvanR> i can certainly agree with that goal
17:50:03 <vx1r_> EvanR sure i'd rather have haskell or an ML-ish descendent fill that space though.
17:50:50 <EvanR> haskell for numerics...
17:50:59 <vx1r_> evanr is that too much to ask?
17:51:25 <EvanR> maybe its possible to make a beast of a linear algebra suite with it
17:51:36 <carter> vx1r_: EvanR there's some cool stuff pending in that space
17:51:59 <carter> Like, hella cool. Just a lot of work from paper to mature tool that's well designed ;)
17:52:12 <vx1r_> carter i know ;-) looking forward to that
17:52:25 <vx1r_> for now i'm trying to make it work with what's available.
17:52:31 <carter> Hehe.
17:52:56 <carter> I'm a bit hosed the next few days, but let's finish catching up latter half of this week
17:53:28 <vx1r_> sounds good carter
17:54:41 <willyager> Hey y'all. I wrote a preliminary draft of an article containing some practical tips about writing distributed applications in Haskell. I would appreciate some feedback. http://yager.io/Distributed/Distributed.html
17:55:46 <vx1r_> ah nice, cloud haskell has some activity post-parallel scientific
17:56:36 <carter> willyager: 1) Ghc.Event is worth checking out 2) stm plus retry to sleep until changes is better than ticks unless you have some sort of hard latency needs
17:57:06 <willyager> carter: Why would one use STM to wait for network events?
17:57:33 <carter> I'm about to nap. Because it's that or mvars ;)
17:57:36 <willyager> I suspect cloud haskell (or distributed-transport) uses GHC.Event under the hood, but I'm not sure
17:57:45 <carter> And you can't sleep on more than one mvar
17:57:52 <carter> willyager: it doesn't. 
17:58:00 <carter> Or I doubt it at Least.
17:58:14 <EvanR> you can but its clunky
17:58:18 <EvanR> involve other threads
17:58:31 <willyager> I'm not sure how you're imagining using STM in this way. Could you explain? Like I don't even see how it fits the problem domain
17:58:41 <carter> Also some of the libs on top use timed stuff because they didn't know how to use stm for this
17:59:04 <carter> fryguybob: can maybe explain this better cause he has to explain this to me sometimes
17:59:27 <carter> willyager: how are you implementing blocking / sleeping workers ?
17:59:45 <carter> It bottoms out to stm or mvars
17:59:48 <willyager> carter: Processes block on incoming message
17:59:58 <willyager> epoll is the underlying blocking system
18:00:08 <willyager> or kqueue
18:00:21 <carter> No.  That's a sys call Api that ghc.event used
18:00:32 <carter> ;)
18:00:36 <carter> Mull a bit
18:03:36 <willyager> carter: Network.Transport.TCP uses GHC's Network stack, which I'm pretty sure in this case boils down to epoll
18:04:08 <carter> Only if it's using Ghc.event. 
18:04:17 <carter> If it's not importing that module then it's not
18:04:23 <carter> Check the source
18:04:23 <willyager> GHC.Event doesn't have a monopoly on the usage of epoll...
18:04:39 <carter> It's the only one ghc ships with
18:04:52 <carter> So your re
18:04:56 <willyager> Didn't GHC switch from select to epoll for Network.Socket back in like 2006?
18:05:08 <carter> That isn't a ghc lib. 
18:05:13 <carter> It's it's own package
18:05:46 <carter> Ghc.event is a module in base that ships with ghc
18:06:19 <willyager> OK, so what is the underlying primitive that gets used when I have 10000 threads listening on different sockets?
18:06:57 <willyager> https://ghc.haskell.org/trac/ghc/ticket/635
18:07:00 <willyager> What is that all about ^?
18:07:43 <willyager> Haven't read the newer GHC IO manager whitepaper in a while, but as I recall it used epoll
18:07:54 <carter> I told you, read the source
18:09:02 <willyager> Can you just tell me, or do you not know? 
18:09:48 <carter> I would literally have to read the source of the lib to know. And you should do it instead.
18:10:18 <carter> Because the source is always the ground truth.  Not the paper from several years ago.
18:10:39 <willyager> Well you're talking quite authoritatively for someone who doesn't know. I'm presenting some reasonably hard evidence here, and I'm just curious if you actually know
18:10:51 <willyager> Because it would save me some time
18:13:13 * hackagebot gtk2hs-buildtools 0.13.2.0 - Tools to build the Gtk2Hs suite of User Interface libraries.  https://hackage.haskell.org/package/gtk2hs-buildtools-0.13.2.0 (HamishMackenzie)
18:16:43 <vx1r__> arg frames library keeps crashing ghc
18:18:14 * hackagebot cairo 0.13.3.0 - Binding to the Cairo library.  https://hackage.haskell.org/package/cairo-0.13.3.0 (HamishMackenzie)
18:18:16 * hackagebot glib 0.13.4.0 - Binding to the GLIB library for Gtk2Hs.  https://hackage.haskell.org/package/glib-0.13.4.0 (HamishMackenzie)
18:18:18 * hackagebot pango 0.13.3.0 - Binding to the Pango text rendering engine.  https://hackage.haskell.org/package/pango-0.13.3.0 (HamishMackenzie)
18:18:20 * hackagebot gio 0.13.3.0 - Binding to GIO  https://hackage.haskell.org/package/gio-0.13.3.0 (HamishMackenzie)
18:18:36 <nineonine> trying to build library with travis - but it fails with "cabal: can't find source for Some/Module in src, dist/build/autogen
18:18:47 <nineonine> it complains about the file which is not exported 
18:19:02 <nineonine> but I have it on "Other-modules" in .cabal 
18:19:19 <carter> willyager: I'm busy in a family vacation this weekend and on the prime committee.  I'm giving you reading suggestions for your own edification. 
18:21:40 <carter> Pardon if I sound cranky
18:22:13 <carter> But ghc doesn't have a built in io manager. It has ghc.event. Which it ships with but is basically user land
18:23:14 * hackagebot gtk3 0.14.4 - Binding to the Gtk+ 3 graphical user interface library  https://hackage.haskell.org/package/gtk3-0.14.4 (HamishMackenzie)
18:28:14 * hackagebot gtk 0.14.4 - Binding to the Gtk+ graphical user interface library.  https://hackage.haskell.org/package/gtk-0.14.4 (HamishMackenzie)
18:37:39 <shagmin> exit
18:43:09 <willyager> carter: I followed the Network.Transport code and it eventually does go down to GHC.Event
18:43:25 <carter> Ok. Cool.
18:44:02 <willyager> So Cloud Haskell does get epoll for free :) all good there
18:47:48 <carter> But now you know!
18:48:19 <carter> Also notably: the io manager is totally userland. You could like fork it and make it a cabal package or such :)
18:49:10 <willyager> Well, I don't know anything more than I new before except with maybe like 15% higher certainly
18:49:23 <willyager> But I guess that's something :)
18:49:52 <carter> And you now know where to dig
18:49:58 <carter> And that is just code
18:54:52 <EvanR> 15% higher or your money back
18:57:50 <EvanR> ... marveling at the unreasonable success rate at massive refactoring without breaking anything
18:58:15 * hackagebot units 2.4 - A domain-specific type system for dimensional analysis  https://hackage.haskell.org/package/units-2.4 (RichardEisenberg)
19:11:56 <HallaSurvivor> hey hey! I don't have questions right now, but I might later, so I'll do a preemptive ask
19:12:24 <HallaSurvivor> I'm learning agda, and #agda is fairly barren. Do people here know an alternate place to ask questions?
19:13:16 * hackagebot units-defs 2.0.1.1 - Definitions for use with the units package  https://hackage.haskell.org/package/units-defs-2.0.1.1 (RichardEisenberg)
19:31:13 <Welkin> hahahaha
19:31:22 <Welkin> did anyone see the new silicon valley episode?
19:32:18 <Welkin> they included tabs vs spaces as an argument
19:36:00 <EvanR> brilliant
19:42:41 <tippenein> do I have to use Data.Binary to concert an Int to a ByteString?
19:42:46 <tippenein> convert*
19:43:46 <geppettodivacin> You don't have to. But it makes it pretty easy.
19:44:40 <c_wraith> I mean, you could use bitshifts, masks, fromIntegral, and pack.
19:46:44 <tippenein> > Data.Binary.encode 42
19:46:46 <lambdabot>  Not in scope: ‘Data.Binary.encode’
19:51:42 <tippenein> (encode 1) == ("1" :: LBS.ByteString)
19:52:14 <tippenein> ^ i expected that to be true 
19:52:24 <EvanR> there are many ways to convert Int into ByteString
19:52:40 <EvanR> it seems like you want encodeUtf8 . show
19:52:49 <EvanR> it seems like you want encodeUtf8 . T.pack . show
20:02:04 <Welkin> haha
20:02:05 <Welkin> https://www.jonahryanforcongress.com/
20:02:10 <Welkin> it's a real website
20:06:17 <you-user-name-he> 73 31 20 3d 20 31 32 23 33 6a 34 61 7a 7a 36 70 0d 0a 73 32 20 3d 20 2a 28 29 6a 2b 3d 6d 39 38 66 7a 7a 70 0d 0a
20:06:20 <you-user-name-he> Good Luck!
20:07:56 <EvanR> blonde, brunette, redhead
20:08:14 <cyphase> you-user-name-he, what about it?
20:08:19 * hackagebot snake 0.1.0.0 - A basic console snake game.  https://hackage.haskell.org/package/snake-0.1.0.0 (alaminium)
20:18:19 * hackagebot samtools 0.2.4.2 - Binding to the C samtools library  https://hackage.haskell.org/package/samtools-0.2.4.2 (NicholasIngolia)
20:23:19 * hackagebot samtools 0.2.4.3 - Binding to the C samtools library  https://hackage.haskell.org/package/samtools-0.2.4.3 (NicholasIngolia)
20:28:20 * hackagebot flexible-defaults 0.0.1.2 - Generate default function implementations for complex type classes.  https://hackage.haskell.org/package/flexible-defaults-0.0.1.2 (JamesCook)
20:38:20 * hackagebot yesod-crud 0.1.5 - Generic administrative CRUD operations as a Yesod subsite  https://hackage.haskell.org/package/yesod-crud-0.1.5 (league)
20:38:22 * hackagebot yesod-crud 0.1.7 - Generic administrative CRUD operations as a Yesod subsite  https://hackage.haskell.org/package/yesod-crud-0.1.7 (league)
22:53:25 * hackagebot hlint 1.9.33 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.33 (NeilMitchell)
23:38:27 * hackagebot monad-hash 0.1.0.1 - Monad transformer for incremental hashing  https://hackage.haskell.org/package/monad-hash-0.1.0.1 (akrasner)
23:48:27 * hackagebot wai-make-assets 0.1 - Compiling and serving assets  https://hackage.haskell.org/package/wai-make-assets-0.1 (SoenkeHahn)
23:58:27 * hackagebot time-interval 0.1.1 - Use a time unit class, but hold a concrete time type.  https://hackage.haskell.org/package/time-interval-0.1.1 (akrasner)
