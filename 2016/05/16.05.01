00:04:50 <arahael> What's the difference between: (fst.head a) and (fst.head $ a)
00:05:13 <arahael> Doesn't the dot operator bind more heavily?
00:06:56 <Cale_> fst.head a means fst . (head a)
00:07:15 <Cale_> while fst . head $ a means (fst . head) $ a
00:07:38 * hackagebot hw-succinct 0.0.0.9 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.9 (haskellworks)
00:07:38 * hackagebot QLearn 0.1.0.0 - A library for fast, easy-to-use Q-learning.  https://hackage.haskell.org/package/QLearn-0.1.0.0 (dpandya)
00:07:54 <Cale_> whitespace function application binds more tightly than any infix operator
00:09:56 <arahael> Thanks.
00:10:36 <Lovepon> Is it possible to say `((), a) ~ a` ?
00:12:32 * hackagebot Gifcurry 2.0.0.0 - Create animated GIFs, overlaid with optional text, from video files.  https://hackage.haskell.org/package/Gifcurry-2.0.0.0 (lettier)
01:07:34 * hackagebot hylogen 0.1.0.12 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.12 (sleexyz)
01:45:56 <linduxed> hey guys
01:46:23 <linduxed> i'm wondering if compilation results in zero dependency binaries?
01:47:21 <linduxed> meaning that as long as it's the same OS and architecture, the binary will run
01:48:15 <simpson> linduxed: Not by default, but it's possible.
01:55:00 <linduxed> so this would mean that by default, ghc is necessary for execution of the binary?
01:55:13 <linduxed> just having it around on the system
01:59:19 <riaqn> Hi, how do I specify a single constructor in the type signature?
01:59:51 <riaqn> I.e., the value is from the only constructor.
02:02:35 <srhb> riaqn: If you mean data constructor, you do not.
02:03:07 <riaqn> srhb: thx.
02:03:14 <srhb> riaqn: We don't have (that) dependent types. Only type constructors go in type signatures. :)
02:05:39 <srhb> linduxed: Normally, all the Haskell libraries are linked statically, so no, you do not need GHC. On the other hand, normally, all the system libraries are linked dynamically, so you need those.
02:06:19 <srhb> linduxed: And by normally I mean these are the default options, and you can change them.
02:06:55 <linduxed> srhb: and by system libraries, you mean stuff like libc?
02:07:18 <srhb> linduxed: Right.
02:07:35 <srhb> linduxed: You can probe your executable with ldd to see which you have dynamically linked against.
02:07:43 <linduxed> ok
02:08:43 <linduxed> i'm kinda asking because i've never given this much thought before and i was quite impressed with go's one-binary-and-nothing-more approach
02:08:49 <srhb> linduxed: Short version, you basically need to pass -optl-static -optl-pthread to build statically against external libraries.
02:08:53 <linduxed> it was about the only thing i liked about the language, i think
02:08:55 <linduxed> but still
02:09:16 <srhb> Prepare for huge binaries. :-)
02:09:35 <linduxed> haha
02:11:03 <simpson> linduxed: The downsides to the everything-static strategy are well-documented but poorly-understood by many of its advocates.
02:11:28 <simpson> linduxed: But, that said, feel free to produce fully static binaries. There's flags floating around somewhere to make GHC do it.
02:16:41 * arahael made a tiny, crappy little haskell utility to sum up all* his finances. (* No, not all of them).
02:16:58 <arahael> Feels awesome: I had to refactor it as it was _too_ crappy, and was pleasently surprised at how easy haskell is to refactor.
02:18:38 <arahael> Speaking of static libs and binaries...
02:19:04 <arahael> I suspect that most proponants of static binaries are really trying to work around the lack of a _sane_ bundling tool, like Mac OS X.
02:19:37 <arahael> like _in_ Mac OS X. :)
02:20:08 <simpson> Or perhaps a real build system, like Nix.
02:20:23 <arahael> Arguably.
02:20:42 <arahael> If you had a real build system on windows, say - and we do - you still have the issue of distributing those binaries.
02:22:07 <simpson> Well, Windows has been a problematic platform for a long time. It's not going to stop being problematic.
02:23:21 <arahael> Not denying that.
02:23:33 <arahael> But Windows _is_ the reason, imho, for the desire to have a static build.
02:27:32 <simpson> I guess? Windows, to me, is not a worthwhile platform to target, so I don't really factor it in. But I can see the POV.
02:28:00 <ggVGc> hah, what
02:28:12 <ggVGc> why is windows not a worthwhile platform to target?
02:28:34 <arahael> I don't think anyone said that.
02:28:44 <arahael> Well, ok, simpson said it.
02:28:53 <arahael> But it really depends on your motivations and target.
02:29:01 <Ralith> 02:23:11 < arahael> But Windows _is_ the reason, imho, for the desire to have a static build.
02:29:08 <Ralith> have you ever tried to package something for OSX?
02:29:10 <arahael> Literally the only reason to support windows, is to get windows users to buy your product.
02:29:20 <arahael> Ralith: Yes, using XCode.
02:29:26 <Ralith> that's cheating :P
02:29:34 <arahael> Ralith: Arguably.
02:29:44 <arahael> Ralith: XCode does a huge amount of crap.
02:29:54 <arahael> And it is nearly required if you want to do iOS as well, anyway.
02:30:14 <Ralith> can it be used to package haskell projects with large external dependencies?
02:31:15 <arahael> You know... I don't think this is the place to discuss XCode's shortfalls. ;)
02:31:52 <simpson> ggVGc: Low number of people in my target demographic on Windows, combined with Windows being permanently idiosyncratic to support; the amount of code that behaves differently *only* on Windows compared to non-Windows is ludicrous.
02:33:32 <arahael> And all the variations of windows therein. :(
02:34:09 <Ralith> arahael: I mean, you might as well compare to packaging a VS C# app on windows :p
02:34:36 <arahael> No, it's definitely better on the mac.
02:35:22 <Ralith> if you say so
02:42:37 * hackagebot directory 1.2.6.3 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.2.6.3 (Rufflewind)
02:52:38 * hackagebot pandoc-crossref 0.2.1.1 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.2.1.1 (lierdakil)
04:07:40 * hackagebot d3d11binding 0.0.0.1 - A raw binding for the directX 11  https://hackage.haskell.org/package/d3d11binding-0.0.0.1 (jwvg0425)
04:33:34 <zoran119> is there an easy way to tell if all Ints in a list are either positive or negative?
04:34:03 <zoran119> [1,2,3] is good, [-1,-2,-3] is good, [1,2,-3] is bad
04:36:35 <srhb> :t (\ns -> all (<0) ns || all (>=) ns)
04:36:36 <lambdabot>     Couldn't match type ‘a -> Bool’ with ‘Bool’
04:36:36 <lambdabot>     Expected type: a -> Bool
04:36:36 <lambdabot>       Actual type: a -> a -> Bool
04:36:36 <saurabhnanda> hmm
04:36:37 <saurabhnanda> lpaste is down
04:36:40 <srhb> Woops
04:37:02 <srhb> :t (\ns -> all (<0) ns || all (>=0) ns)
04:37:03 <lambdabot> (Num a, Ord a, Foldable t) => t a -> Bool
04:37:28 <saurabhnanda> how do I write this function? https://gist.github.com/saurabhnanda/0b914b54132771096a330d2638c48ec8
04:37:41 * hackagebot hw-prim 0.0.0.10 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.0.10 (haskellworks)
04:39:12 <zoran119> srhb: can i combine that with ($)? i have the list coming from a function call
04:39:19 <saurabhnanda> is there a throwM example available anywhere?
04:39:29 <zoran119> srhb: (... || ...) $ someFunc p1 p2
04:39:40 <zoran119> doesn't seem to work
04:39:57 <ggole> zoran: (\ns -> ... || ...) $ ...
04:40:04 <ggole> Or just give it a name, which seems cleaner
04:40:28 <ggole> And is easier to test if you are into that
04:40:49 <zoran119> ggole: yep, will give it a name
04:41:24 <lyxia> saurabhnanda: you need the scopedtypevariables extension and a forall a.  in the top-level type signature
04:42:08 <lyxia> saurabhnanda: does it not work if you simply drop the inner type annotation?
04:42:53 <saurabhnanda> lyxia: thanks, but too complicated for me right now. Is there an easier way to achieve the same result?
04:42:53 <saurabhnanda> lyxia: let me try that
04:43:18 <lyxia> the thing is that by default :: Either String a means :: forall a. Either String a,  that is a here is a fresh type variable
04:43:23 <saurabhnanda> lyxia: thanks, that worked. Now stuck with the next one... Nightwatch/Websocket.hs:139:13-18: Couldn't match type ‘JsonRpcException’ with ‘SomeException’ … In the expression: throwM ...     In the expression: throwM $ JsonRpcParseException s 
04:43:44 <saurabhnanda> lyxia: why is it a fresh type variable? It's coming from the signature above right? Or not,
04:43:46 <saurabhnanda> actually not
04:43:59 <saurabhnanda> the type variables in the signature have no effect on the fn body, right?
04:44:22 <lyxia> nope you need scopedtypevariables for that
04:44:57 <saurabhnanda> got it, thanks
04:45:03 <saurabhnanda> lyxia: any idea about the SomeException related error?
04:48:19 <LiamGoodacre> saurabhnanda, do you not just want `Left (JsonRpcParseException s)`?  or do you actually want an exception?  If you look here: http://haddock.stackage.org/lts-5.14/classy-prelude-0.12.7/ClassyPrelude.html#v:throwM the instance for Either: `(~) * e SomeException => MonadThrow (Either e)` is saying that `e` must be "equal" to `SomeException`, defined here: http://haddock.stackage.org/lts-5.14/base-4.8.2.0/Control-Exception-Base.html
04:48:19 <LiamGoodacre> #t:SomeException
04:49:10 <Lovepon> Guys, why is there no _ for types?
04:49:37 <cocreature> Lovepon: there is, just use -XPartialTypeSignatures
04:49:50 <saurabhnanda> LiamGoodacre: you're right
04:49:51 <Lovepon> cocreature: Ah. Thanks.
04:49:53 <LiamGoodacre> saurabhnanda, if you want the `Left (J...`, you could use `first` from Bifunctor: https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bifunctor.html#v:first
04:50:15 <saurabhnanda> and that's the only one which requires SomeException -- wonder why
04:50:56 <lyxia> Lovepon: Actually it should already work in a way without the extension. GHC tells you what type is appropriate there, but makes it an error by default and PartialTypeSignatures makes it a warning.
04:51:02 <Lovepon> cocreature: Any reasons this  isn't on standard Haskell?
04:51:48 <lyxia> saurabhnanda: the MonadThrow instance of Either requires the Left type to be SomeException.
04:52:03 <Lovepon> lyxia: Mmmm, but how about a _ which is not negative? What if I want to say "its type doesn't matter"
04:52:16 <Lovepon> lyxia: I could just use anothedr type
04:52:21 <Lovepon> Errr
04:52:24 <Lovepon> Another type variable
04:52:35 <Lovepon> lyxia: But that wouldn't really convey it as clearly.
04:52:43 <fizbin> That is the usual way it's done, Lovepon.
04:52:51 <Lovepon> fizbin: I know.
04:54:36 <saurabhnanda> LiamGoodacre: actually, I think I don't understand how to use throwM
04:54:36 <saurabhnanda> LiamGoodacre: is MonadThrow supposed to the monad which my code needs to run under, or is it Either?
04:54:36 <saurabhnanda> okay, what does this even mean? -- SomeException $ JsonRpcParseException "works"
04:54:37 <lyxia> An unconstrained type variable means "don't care" enough to me.
04:54:47 <fizbin> And I suspect that standard Haskell is that way because the type theory way to write a type where a certain bit doesn't matter is \forall a . SomeType Int a  (where \forall is the upside down A symbol)
04:55:04 <saurabhnanda> lyxia: so , do I need to return a (Left MyException) from the function, or (throwM MyException) ? 
04:55:53 <lyxia> return Left (Json...)
04:56:10 <lyxia> Left (JsonRpsParseException s)
04:56:20 <lyxia> no "return"
04:56:48 <lyxia> MonadThrow is the typeclass for monads which can throw *any* exception.
04:56:52 <LiamGoodacre> saurabhnanda, I believe the reason for the use of `SomeException` is that `MonadThrow` is indexed by types of kind `* -> *`.  `Either` has kind `* -> *` so the instance would have to be on `Either e`.  But `throwM :: forall e. Exception e => ...` that is, it works for all `e`.  So the instance for `Either e` needs to fix the type `e` to one that satisfies the constraint `Exception` (which is `SomeException`).
04:56:53 <saurabhnanda> lyxia: then what's throwM for? and then how do I compose a string of function calls, each of which is in a different monad, and each of which can fail?
04:57:18 <LiamGoodacre> oops, fix: `Either` has kind `* -> * -> *`
04:57:20 <lyxia> Either JsonRpcException a can only "throw" JsonRpcExceptions
04:58:13 <saurabhnanda> I'm utterly confused. If I have to use the left-value of Either, then what's throwM for?
04:58:35 <saurabhnanda> which then means, that I have to keep using maybeToEither to compose Maybe's and Either's
04:58:38 <lyxia> saurabhnanda: there's no general solution to that, it will depend on what your monads are, what your exceptions are etc.
05:00:32 <saurabhnanda> is there a tutorial for throwM somewhere?
05:01:51 <saurabhnanda> for more context -- I'm trying to rewrite functions that look like this -- https://gist.github.com/saurabhnanda/bc3ccc61e88e72c66a3e90e3339166b4
05:02:28 <lyxia> To avoid conversions, maybe you can try to write more polymorphic functions
05:03:03 <saurabhnanda> lyxia: can't throwM help me reduce all the type conversion boilerplate?
05:03:20 <saurabhnanda> and also avoid the runExceptT boilerplate
05:03:33 <saurabhnanda> be able to write straightforward throwM and catch ?
05:10:08 <lyxia> saurabhnanda: ideally the error strings should be part of the functions to which they correspond, instead of returning a Maybe.
05:10:42 <lyxia> Either is not satisfactory either though, because you will still have to do conversions when you use more elaborate types, as you do here.
05:12:25 <lyxia> a common solution is to use a typeclass to abstract over all monads that can throw errors, and since you're just throwing Strings I think MonadError is more appropriate
05:12:47 <saurabhnanda> does this more like what I want? https://gist.github.com/saurabhnanda/8adbd3c24e3ab9618662277d94ec4563
05:13:00 <saurabhnanda> *does this look more like what I want?
05:13:19 <saurabhnanda> will I, now be able to use this function in any monad?
05:13:20 <lyxia> Right I was thinking of this kind of signature
05:13:35 <lyxia> only in instances of MonadThrow
05:15:20 <saurabhnanda> type NwApp = persistent-2.2.4:Database.Persist.Sql.Types.SqlPersistT IO
05:15:21 <saurabhnanda> would this be an instance of MonadThrow? 
05:15:33 <saurabhnanda> it has IO as one of the inner monads?
05:16:10 <lyxia> yeah
05:16:21 <saurabhnanda> lyxia: alright then, let me try
05:17:02 <troydm> hey all! how can I convert ByteString to lazy ByteString
05:17:22 <lyxia> SqlPersistT is a synonym for a ReaderT which is also an instance of MonadThrow, which lifts throwM from the inner type.
05:18:42 <lyxia> troydm: Data.ByteString.Lazy.toStrict
05:20:27 <troydm> lyxia: thx
05:21:14 <lyxia> fromStrict*
05:36:34 <LiamGoodacre> I'm using `Turtle.find` and I'm wanting to get all `.js` files which aren't in `node_modules` folders, having trouble with the pattern though.  Currently I have: `view $ find (invert (contains "/node_modules/") *> ends ".js") "."`, but it's not working :P.  Any ideas?
05:58:19 <troydm> what are some requirments/guidelines of releasing a package on hackage?
06:04:10 <srhb> LiamGoodacre: How is it not working?
06:05:31 <LiamGoodacre> srhb, it's doesn't give me any filepaths at all
06:05:38 <LiamGoodacre> it*
06:07:05 <srhb> LiamGoodacre: It's currently installing here, but don't you need to find all the ".js" files and then invert with the contains clause?
06:17:44 * hackagebot table-layout 0.5.0.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.5.0.0 (muesli4)
06:18:00 <LiamGoodacre> srhb, possibly; not sure how to do that.  Hmm, might be more straight forward to switch to `lsif` and then filter by ending in ".js" afterwards.
06:25:24 <ClaudiusMaximus> troydm: afaik, not much beyond "open source license", and "passes cabal check"
06:30:03 <hexagoxel> troydm: and perhaps "adheres to the pvp sufficiently that it will install cleanly with up-to-date ghc/package index".
06:30:45 <srhb> LiamGoodacre: Yes, or use grep or somesuch. I don't think there's an AND for patterns (nor AND NOT) 
06:32:05 <haskell829> What is the difference between "dist" and "install" directories in .stack-work ?
06:39:16 <hexagoxel> haskell829: `dist` seems to be for individual packages, while `install` is for stack-project-global stuff. (just observations, no stack expert.)
06:40:08 <hexagoxel> haskell829: the difference might be more apparent when you have multiple packages in subdirectories and none in ".".
06:40:59 <troydm> hexagoxel: https://github.com/troydm/paranoia <- I build this with stack so I have no idea how can I build sdist using stack
06:41:45 <hexagoxel> troydm: s/stalk/stack/
06:41:52 <troydm> ahh yeah
06:42:32 <troydm> hexagoxel: ahaha
06:42:35 <troydm> :D
06:42:42 <troydm> I mistyped it in a weird way
06:47:44 <haskell829> hexagoxel: executable file from what directory should be used?
06:49:21 <hexagoxel> haskell829: not sure, but i'd choose "install". if you have different executable packages, all will be put there.
06:50:36 <tpsinnem> hmh, why does 'executeFile' in System.Posix.Process return 'IO a' rather than just 'IO ()'?
06:51:26 <haskell829> hexagoxel: any idea why executable from dist and install have different size?
06:51:35 <hexagoxel> haskell829: or use `stack install` and use the executable placed in your local-bin-path, even.
06:52:08 <troydm> nice! my first package on hackage https://hackage.haskell.org/package/paranoia
06:52:25 <hpc> fleeting thought: the power of Maybe is extremely easy to see when you're dealing with an interface to a C library
06:52:45 * hackagebot paranoia 0.1.0.0 - http proxy server  https://hackage.haskell.org/package/paranoia-0.1.0.0 (troydm)
06:53:03 <hpc> you'll be looking at both sides of the documentation a lot, and where the C side would document a parameter as "HANDLE* arg - the thing to do the stuff, or NULL if blahblah"
06:53:16 <hpc> the haskell side just says ":: Maybe HANDLE -> ..."
06:57:43 <hexagoxel> troydm: also, you need a `cd paranoia` in your usage. apart from that, package seems fine (it installs cleanly with cabal-install).
06:58:17 <troydm> hexagoxel: k, I'll add it now
07:04:52 <tpsinnem> is there in general reason to use executeFile in System.Posix.Process rather than some of the tools like createProcess in System.Process? the latter seems to give more convenient access to stderr etc.
07:07:20 <tpsinnem> or, rather, i'm not sure if executeFile gives you any access to those at all
07:10:30 <srhb> tpsinnem: I can't think of any. And to answer your question about IO () -- I think it's just convenience, I don't think you can use the "value" at any point.
07:12:05 <tpsinnem> srhb: yeah, that's kinda what i've figured. thanks
07:14:56 <geekosaur> the reason you would use executeFile is that you want to replace the current process instead of creating a new one, or you need finer control than createProcess gives you (then use forkProcess+executeFile)
07:15:32 <latenite> Hi folks, I never used a haskell program before. How do I (build, install, run) this one? https://hackage.haskell.org/package/flaccuraterip
07:16:10 <maerwald> meh, even the unix package is not low-level enough
07:16:57 <srhb> latenite: Given a Haskell infrastructure (ghc, cabal-install) on your computer, you write cabal install flaccuraterip
07:17:58 <srhb> latenite: That would (if everything goes well) install the executable into ~/bin/, I believe
07:18:37 <maerwald> why is it that you need to fork half of the libraries you use if you want to get anything done
07:20:09 <hpc> depends on the thing you want done
07:20:29 <civick> hi guys
07:20:45 <hpc> for "simple" stuff like webdev, you'll probably never fork a repo at all
07:21:01 <maerwald> hpc: I disagree
07:21:46 <tpsinnem> geekosaur: hm, under executeFile, do there then not exist new stdouts and stderrs in the first place?
07:22:00 <srhb> maerwald: Maybe you meant to write "I" instead of "you" then. :-)
07:22:07 <geekosaur> tpsinnem, not with executeFile itself
07:23:00 <maerwald> srhb: no
07:23:37 <srhb> maerwald: Uh, okay, I was just joking, really...
07:24:21 <civick> guys I have a hacking project,  I need a pro
07:24:31 <civick> who is ready? 
07:24:40 <hpc> civick: www.tehprohaxxors.com ;)
07:24:45 <geekosaur> you might want to read up on the POSIX process model; executeFile is exec(), forkProcess is fork(), to change file descriptor mappings in a child you would do it between the forkProcess and the executeFile (bnote that you need to create any pipes *before* forkProcess so they will be shared between the parent and child)
07:25:19 <hpc> civick: but seriously, just describe the project, don't worry about asking to ask or looking for an answer before we know the question
07:27:36 <civick> hpc r u a pro hacker?  I can explain the project
07:28:26 <latenite> srhb, ok I am emerginf the ghc stuff. When thats done I ll try what you wrote. Thanks for helping
07:28:59 <hpc> srhb: ~/.cabal/bin
07:29:09 <srhb> hpc: Oh right. It's been a while...
07:29:21 <hpc> srhb: which on windows will happen to be %appdata%/cabal/bin
07:29:39 <hpc> (yay for missing dot)
07:33:37 <tpsinnem> geekosaur: i will note that this confuses me a bit. if the file you execute with executeFile is a program that thinks it can produce something to 'its standard output', what happens to that output? does capturing it involve these file descriptor mappings you mentioned?
07:34:01 <geekosaur> like I said, you need to read about the POSIX process model
07:34:17 <tpsinnem> geekosaur: all right, thanks
07:34:18 <geekosaur> you're not capturing anything with executeFile, your program *goes away* and is replaced by the one you exec-ed
07:34:40 <geekosaur> it continues to use all the files your program had open
07:34:57 <geekosaur> (except for those that have been marked close-on-exec)
07:39:11 <HoloIRCUser> Guys I need a pro hacker for a project  , it has a lot of money and it hasn't legal problems in USA 
07:39:31 <HoloIRCUser> Send me a pm 
07:39:55 <tpsinnem> geekosaur: thanks, that is very helpful. i hope i wasn't too much of a bother! :)
07:40:12 <srhb> HoloIRCUser: Does it have legal problems in Denmark?
07:40:13 <hpc> HoloIRCUser: that's off topic here
07:40:31 <monochrom> HoloIRCUser: it's off-topic. please leave.
07:40:35 <geekosaur> you weren't. you may fuind the POSIX model to be, though; it's got lots of weird edge cases and complexity (which is why createProcess)
07:40:39 <hpc> just got this in a PM: 10:40 <HoloIRCUser> Its about to hack a Iranian bank
07:40:54 <srhb> Aha. :-P
07:41:57 <geekosaur> ...someday we should probably provide a binding to spawnProcess, and maybe the standalone version (it's not quite 100% of an implementation, iirc, but deals with most of the edge cases for you)
07:42:38 <HoloIRCUser> Oh OK sorry 
07:44:34 <srhb> ... that was slightly surprising. Preconceptions are weird.
07:45:16 <srhb> LiamGoodacre: Ack, now that I've played around with it I really _wish_ you could do something like that with patterns
07:46:01 <srhb> LiamGoodacre: ie making (ends ".blah") `andNot` (contains "wrong") be the obvious solution to use with find
07:53:57 <lpaste> tippenein pasted “constraint ‘MonadReader Object from forM” at http://lpaste.net/162035
07:55:27 <tippenein> a bit confused about this error ^
07:56:36 <tippenein> forM objects (view oKey) where object is IO [Object]
07:57:49 <srhb> :t view
07:57:49 <lambdabot> MonadReader s m => Getting a s a -> m a
07:59:38 <tippenein> for some reason, the library says - oKey :: Lens' Object ObjectKey
07:59:55 <srhb> tippenein: Looks more like (^.oKey)
07:59:57 <tippenein> but ghci reports it as Functor f => (ObjectKey -> f ObjectKey) -> Object -> f Object
08:00:02 <srhb> Same thing
08:00:36 <maerwald> does anyone have an idea how to build my package against a forked version of "unix"? ghc just blows up with linking errors.
08:00:57 <srhb> I really don't recall that constraint, oh well.
08:01:30 <maerwald> because ghc has its own unix version
08:03:06 <srhb> Why is it that view has a MonadReader constraint and (^.) doesn't?
08:03:58 <srhb> tippenein: Anyway, doesn't (^.oKey) instead of (view oKey) work?
08:04:36 <tippenein> fmap (^. oKey) g   was my first attempt actually
08:04:49 <tippenein> but that gives Couldn't match type ‘[Object]’ with ‘Object’
08:05:33 <srhb> They shouldn't be different anyway...
08:05:51 <jomg> srhb, i'm guessing the more general version simply doesn't work with the operands flipped
08:06:03 <srhb> tippenein: Well, it should still be forM g (^. oKey)
08:06:32 <tippenein>     Expected type: Getting (m b) [Object] (m b)
08:06:32 <tippenein>       Actual type: (ObjectKey -> Const (m b) ObjectKey)
08:06:32 <tippenein>                    -> Object -> Const (m b) Object
08:06:33 <srhb> tippenein: Oh, not it shouldn't.
08:06:49 <srhb> Mixing up the sequencing here. 
08:07:58 <srhb> tippenein: You mean to map (view oKey) <$> g -- right?
08:08:05 <srhb> and then sequence that.
08:08:47 <tippenein> that's the ticket!
08:09:03 <tippenein> How did you know that from the type errors? 
08:09:30 <srhb> I just realized we were messing up t (m a) with m (t a)
08:10:16 <tippenein> the <$> g makes sense now, but I didn't glean that from the errors 
08:10:19 <srhb> Each of the (one) IO action produces an [Object] -- which we cannot view with that particular lens
08:10:31 <srhb> Hence [Object] vs Object
08:14:51 <saurabhnanda> is it possible that a monadic action doesn't get executed if it's result is not used?
08:14:54 <saurabhnanda> due to laziness?
08:15:06 <srhb> saurabhnanda: Yes.
08:15:15 <hpc> not due to laziness though
08:15:16 <srhb> Well, sort of.
08:15:20 <srhb> ^
08:15:39 <hpc> well, sometimes not due to laziness
08:15:45 <hpc> it depends on what you mean by "executed"
08:15:51 <saurabhnanda> line #5 in this function doesn't seem to get executed -- https://gist.github.com/saurabhnanda/c4cf531bfcf8b14c0821229983ba0578
08:16:17 <hpc> for most types that are an instance of Monad, evaluating through (>>=) is triggered by other evaluation
08:16:27 <hpc> for IO, evaluating through (>>=) is triggered by execution
08:16:36 <srhb> saurabhnanda: You've never sequenced that action.
08:16:44 <saurabhnanda> createDownload is an action in NwApp and so is logAndSendTelegramMessage
08:17:05 <srhb> saurabhnanda: let in a do block just binds some names to values, it doesn't sequence them
08:18:12 <hpc> to very roughly translate it in terms of javascript, let foo = (some sort of action) in bar foo
08:18:31 <hpc> translates to function() { bar(function() { some sort of action }) }
08:18:55 <saurabhnanda> it *is* due to lazy evaluation right?
08:18:55 <hpc> rather than what you probably expected which is do {foo <- some sort of action; bar foo}
08:19:17 <hpc> in your case no, because it's backed by IO
08:19:21 <hpc> so it's purity that's doing it
08:19:33 <hpc> or referential transparency or whatever
08:20:05 <hpc> key point is, (createDownload url gid logId userId) isn't appearing in the chain of (>>=)
08:20:35 <hpc> @undo do {let str = getLine in putStrLn str}
08:20:35 <lambdabot> let { str = getLine} in putStrLn str
08:20:43 <hpc> oh right
08:21:06 <hpc> @undo do {str <- getLine; putStrLn str} -- the other way
08:21:06 <lambdabot> getLine >>= \ str -> putStrLn str
08:21:12 <hpc> that's the distinction
08:21:29 <saurabhnanda> tried https://gist.github.com/saurabhnanda/c4cf531bfcf8b14c0821229983ba0578 - still not working
08:22:48 * hackagebot table-layout 0.5.1.1 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.5.1.1 (muesli4)
08:22:50 <hpc> what's nwCmd?
08:22:55 <saurabhnanda> eariler tgMsg depended upon the return value of createDownload. That's what I changed, and this stopped working.
08:22:59 <hpc> also, include type errors in your paste
08:23:14 <saurabhnanda>  nwCmd = fromJust $ logNwCmd aria2Log
08:23:21 <saurabhnanda> hpc: no type error -- it's compiling
08:23:30 <Kwoth> Hello, is unix-2.7.1.0 unable to be installed on windows (using msys2)?
08:23:31 <saurabhnanda> hpc: there are a lot of definitions coming from the outside function context
08:23:43 <hpc> Kwoth: yes, quite deliberately
08:24:03 <hpc> Kwoth: you want the win32 package, or you need something more thoroughly posix like cygwin
08:24:15 <geekosaur> or unix-compat, at least for some things
08:24:43 <hpc> Kwoth: however by using cygwin you'll be forcing a dependency on it for users of your program, either through you bundling the dll or them having to install it
08:24:56 <Kwoth> I'm just trying to install lambdabot, i solved like 3 errors so far, this is latest one
08:25:14 <geekosaur> urgh
08:25:27 <geekosaur> I think you are pretty much doomed, to be honest
08:25:35 <hpc> ^
08:25:46 <Kwoth> xD
08:25:56 <hpc> even in the right environment lambdabot sucks to install
08:26:02 <srhb> Kwoth: I'm impressed by your perseverance. :-)
08:26:17 <Kwoth> srhb: thx but seems i've reached a dead end :D
08:26:34 <Kwoth> hexagoxel helped me a lot
08:26:40 <MitchellSalad> hello, are there any matrix inverse/pseudoinverse algorithms on hackage?
08:26:50 <hpc> Kwoth: if you do get it working though, definitely paste a screenshot of it running in cmd so you can be officially sworn in as a bad enough dude to save the president
08:27:03 <Kwoth> XD
08:27:11 <srhb> MitchellSalad: Have you checked HMatrix?
08:27:11 <geekosaur> coyld try signing up as a microsoft developer and using the new win10 linux subsystem.. although that too has lots of "fun" edge cases especially in the area of subprocess management
08:27:41 <geekosaur> (those cases being why it currently requires developer... it's Not Ready For Prime Time)
08:27:48 * hackagebot murmur-hash 0.1.0.9 - MurmurHash2 implementation for Haskell.  https://hackage.haskell.org/package/murmur-hash-0.1.0.9 (ThomasSchilling)
08:28:13 <MitchellSalad> srhb: I've not, I was using 'linear'
08:28:39 <srhb> MitchellSalad: Doesn't linear have inverses? O_i
08:28:57 <hpc> saurabhnanda: i am entirely befuddled then, since mistakes with let-in and (>>=) pretty much always result in a type error of some kind
08:29:08 <MitchellSalad> srhb: it does?
08:29:08 <hpc> saurabhnanda: you've probably fixed it enough that your error now lies elsewhere maybe
08:29:25 <hpc> saurabhnanda: get back to debugging ;)
08:29:38 <srhb> MitchellSalad: I would certainly expect it to...
08:29:57 <justin_beiber> good morning everyone
08:30:08 <MitchellSalad> srhb: alright, well that's not helpful :P - I'll checkout hmatrix, though
08:30:18 <justin_beiber> did somebody say hmatrix?
08:30:34 <MitchellSalad> yep, <-- this guy
08:30:44 <justin_beiber> hmatrix - it's not pretty but there's not many options :(
08:30:56 <justin_beiber> i haven't used linear
08:31:00 <justin_beiber> how did you like it?
08:31:01 <MitchellSalad> justin_bieber: i'm looking for a matrix pseudoinverse algorithm, like matlab's pinv
08:31:25 <justin_beiber> hmatrix looks like it covers that
08:31:37 <saurabhnanda> hpc: the entire thing is getting compiled into an executable
08:31:43 <saurabhnanda> hpc: no error anywhere
08:31:47 <MitchellSalad> so it does :)
08:31:57 <justin_beiber> i tried repa, but i realized there isn't even support to print matrices
08:32:00 <MitchellSalad> i think this means i have to port all my linear types to hmatrix types
08:32:08 <justin_beiber> and scurried back to hmatrix
08:32:24 <justin_beiber> mitchellsalad you could just write a wrapper function around pinv
08:32:32 <justin_beiber> if that's the only thing you're missing
08:32:40 <MitchellSalad> ah, good point!
08:32:55 <justin_beiber> i'm thinking of going in the other direction actually, switching from hmatrix to linear
08:33:14 <MitchellSalad> linear's API is a thing of beauty
08:33:30 <MitchellSalad> hmatrix looks like poopoo
08:33:44 <justin_beiber> since i may want to do some frontend stuff and the native library dependencies are not going to play with that
08:33:48 <justin_beiber> mitchellsalad lol yeah
08:34:02 <justin_beiber> unfortunately for "batteries included" math, it's pretty much the only game in town
08:34:27 <saurabhnanda> hpc: this was the final fix -- https://gist.github.com/saurabhnanda/c4cf531bfcf8b14c0821229983ba0578 -- and it doesn't make sense to me. Why didn't the compiled help me from writing incorrect code?
08:34:33 <justin_beiber> i was trying to use it to do some ODE computations, and it was fairly unpleasant and slow
08:35:31 <hpc> saurabhnanda: because the types checked out and you just had a logic error, it seems
08:35:40 <justin_beiber> wish carter would release numerical, but it looks like that's going to be a while, if ever
08:35:58 <hpc> saurabhnanda: much in the same way types aren't going to stop you from writing an (Int, Int) coordinate pair as (y, x) instead of (x, y)
08:36:09 <saurabhnanda> hpc: not adding up... let me see what happens if I write a bunch of SQL queries which don't depend on each other
08:36:11 <justin_beiber> probably has other priorities which is fine
08:36:13 <srhb> saurabhnanda: I think a clearer example of what you were doing wrong was...
08:36:16 <carter> Hblas is due for a release soon
08:36:37 <srhb> @undo do { let foo = 42; print 9001 }
08:36:37 <lambdabot> <unknown>.hs: 1: 31:Parse error: }
08:36:38 <justin_beiber> speak of the devil :)
08:36:39 <srhb> derp
08:36:57 <geekosaur> saurabhnanda, there's a tradeoff between making types more specific so they can catch these kinds of things (for example, using newtypes) and the extra work of having to wrap and unwrap stuff all the time
08:37:02 <carter> justin_beiber: go back to the Disney channel
08:37:31 <geekosaur> (and if you use deriving to avoid the unwrap/rewrap, you're back where you started --- it won't catch misuses that deriving hides under the rug)
08:37:49 <carter> justin_beiber: the main thing right now is I kinda got roped into building a new language at my day job. Which eats up a lot of thinking time
08:37:55 <geekosaur> this is also why some of the newer database interfaces use tagged types
08:37:59 <justin_beiber> no way man i'm writing my next album in tidal
08:38:00 <saurabhnanda> geekosaur: how does deriving types come into the conversation?
08:38:01 <carter> Hblas is overdue for a new release. 
08:38:09 <hpc> obligatory http://www.joelonsoftware.com/articles/Wrong.html
08:38:18 <geekosaur> (for example, using newtypes)
08:38:19 <hpc> saurabhnanda: it was just an example
08:38:19 <justin_beiber> carter that's fair
08:38:20 <carter> Need to finish some cleanup
08:38:42 <saurabhnanda> so, apparently, doing this to monadic actions is important: blah <- dbAction
08:38:53 <hpc> very important
08:39:07 <geekosaur> I was saying that if you make newtypes for all the simple types so the compiler will catch you misusing them, and then you use deriving to avoid the extra wrapping and unwrapping, you have effectively made the newtype go away so it can't catch you misusing things
08:39:08 <saurabhnanda> dbAction1; dbAction2; dbAction3 -- will result in only the dbAction3 being run; who would've thunk
08:39:08 <carter> justin_beiber: the hopper project from work is kinda a modern type theory that's meant to be a resource logic and performant and sound.
08:39:11 <hpc> it's the difference between (getLine >>= putStrLn) and putStrLn (getLine)
08:39:20 <hpc> :t (getLine >>= putStrLn)
08:39:21 <lambdabot> IO ()
08:39:23 <hpc> :t putStrLn (getLine)
08:39:24 <lambdabot>     Couldn't match type ‘IO String’ with ‘[Char]’
08:39:24 <lambdabot>     Expected type: String
08:39:24 <lambdabot>       Actual type: IO String
08:39:34 <carter> I'm pro new type / data all the things
08:39:36 <geekosaur> ...that sounds wrong, I'd consider that a mis-designed database interface
08:39:40 <saurabhnanda> geekosaur: ah got it ... analogous examplke
08:40:02 <saurabhnanda> geekosaur: I'm working with Yesod/Persistent
08:40:04 <geekosaur> I mean. it's the same wrong as if putStrLn "a": putStrLn "b" only output "b"
08:40:21 <carter> geekosaur: one cool thing I discovered I can do this week is ghc lets you put a type signature in the left hand side of a pattern match
08:40:32 <carter> Which may be a scoped type variables thing
08:40:33 <hpc> @undo do {dbAction1; dbAction2; dbAction3}
08:40:33 <lambdabot> dbAction1 >> dbAction2 >> dbAction3
08:40:40 <geekosaur> carter, it is
08:40:49 <geekosaur> used to be a separate extension (PatternSignatures)
08:41:08 <migimunz> Hi everyone, I'm playing around with type families in order to understand them, and am adding some type level information for numbers (whether they're positive,negative, zero  or top). However, I can't get my closed type family to expand in this example (last line) : https://gist.github.com/migimunz/099b133db14518993f99a077f78fff59
08:41:44 <saurabhnanda> what inference would you draw from https://gist.github.com/saurabhnanda/c4cf531bfcf8b14c0821229983ba0578
08:42:21 <chaoxu> hi guys, what does the curly bracket part mean in "newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }"?
08:42:41 <geekosaur> chaoxu, that is a record
08:42:42 <migimunz> chaoxu, it's record syntax
08:42:48 <chaoxu> thanks!
08:43:08 <saurabhnanda> do {createDownload; logAndSendTgramMessage} resulted in only the latter being executed
08:43:30 <saurabhnanda> do { dloadE <- createDownload; logAndSendTgramMessage} executes both actions
08:43:53 <geekosaur> yeh, that's actually laziness there, you never use the return value of createDownload so it never gets demanded
08:44:05 <geekosaur> I think
08:44:30 <geekosaur> or, it runs but you don't have the handle so you can't do anything with it
08:45:58 <srhb> It seems odd that the final example should work but not if you strip the binding to a name off
08:46:02 <srhb> In fact, that sounds plain wrong.
08:46:14 <saurabhnanda> hmm... laziness=gun, inexperience=foot
08:46:23 <srhb> saurabhnanda: Are you sure that is the case?
08:46:31 <saurabhnanda> srhb: just tried it three time
08:46:56 <geekosaur> something still seems "off" here...
08:46:57 <srhb> saurabhnanda: By doing s/dloadE <- // on the second example?
08:46:59 <saurabhnanda> let me get this thing done, then I'll try to write a minimal isolated PoC
08:47:11 <srhb> Er, on the third example
08:47:21 <hpc> @undo do {a; b}
08:47:21 <lambdabot> a >> b
08:47:26 <hpc> @undo do {x <- a; b}
08:47:26 <lambdabot> a >>= \ x -> b
08:47:42 <srhb> hpc: Yes, exactly.
08:47:42 <hpc> it looks to me like the only thing that could explain that behavior is a broken override of (>>)
08:47:46 <srhb> Indeed.
08:47:50 <saurabhnanda> first example shoudl work, right?
08:47:58 <texasmynsted> anybody find a monospaced font with ligatures to work well with haskell say with vim or something?
08:48:10 <srhb> saurabhnanda: I don't think so.
08:48:12 <saurabhnanda> btw I'm sneakily in the MonadThrow monad if that means anything
08:48:22 <srhb> I think your monads are not monads.
08:48:31 <geekosaur> texasmynsted, iirc vim needs specific patches for the ligature programming fonts to work right
08:48:39 <srhb> saurabhnanda: So all bets are off. :-P
08:48:40 <geekosaur> (not included in the standard distribution)
08:48:42 <texasmynsted> hmm
08:48:51 <hpc> aren't ligatures mutually exclusive with monospace?
08:49:03 <geekosaur> hpc, no
08:49:09 <saurabhnanda> srhb: does it have anything to do with MonadThrow?
08:49:26 <texasmynsted> no, 
08:49:39 <srhb> saurabhnanda: I don't know. What's the NwApp () monad?
08:49:46 <srhb> NwApp rather
08:49:47 <geekosaur> they work fine *if* they are multiples of the character cell width *and* the program rendering them checks for and handles multiple-width characters
08:50:03 <hpc> aha: https://raw.githubusercontent.com/i-tu/Hasklig/master/hasklig_example.png
08:50:06 <hpc> now i understand
08:50:14 <geekosaur> manyt programs don't, iwhuch is why you need patches for them to work rightr
08:50:18 <geekosaur> ... typing
08:50:19 <saurabhnanda> type NwApp = SqlPersistT IO 
08:51:39 <rntz> if I want a typeclass which has an associated type which is guaranteed to be Ord, how do I express that?
08:52:04 <rntz> class Foo blah where { data Bar; ... }
08:52:08 <rntz> and I want Bar to be ord
08:52:09 <srhb> saurabhnanda: That does sound rather comforting...
08:54:36 <saurabhnanda> srhb: :)
08:54:38 <rntz> also, is there a good rule of thumb for when to use associated types & when to use functional dependencies?
08:55:15 <t7> never
08:55:22 <hpc> lol
08:55:26 <pavonia> rntz: I think you should have these constraints on the functions using the type, not the type itself
08:56:27 <rntz> hm. that's very different from if I used functional dependencies, where I'd just make Bar an additional typeclass parameter and require Ord to be a superclass...
08:56:30 <rntz> but I guess I can do that
08:56:42 <rntz> it feels a bit weird to write (Ord Node) => 
08:56:51 <rntz> in fact, I think I can't do that without the FlexibleContexts extension
08:57:01 <texasmynsted> The net with something like Hasklig is that the source stays the same but the representation that you see is improved for ligatures 
08:57:09 <hpc> could you maybe do something like class FOO blah where {type Ord (F blah) => F blah; ...}?
08:57:44 <hpc> er, s/type/data
08:57:49 * hackagebot hedis 0.8.1 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.8.1 (k_bx)
08:58:32 <rntz> hpc: um, that doesn't parse, and I also don't know what it would mean if it did
08:59:18 <hpc> oh, what about mapping from the data family to a comparable type, or putting the comparing function inside the class
08:59:41 <hpc> class Foo a where {data Bar a; compare :: Bar a -> Bar a -> Ordering}
09:00:09 <rntz> I know I can do this with functional dependencies, and I'm not interested in uglifying my code just to use associated type families
09:00:16 <hpc> instance Ord (Bar a) where compare = compare
09:00:55 * hpc feels good about that idea
09:02:23 <hpc> er, instance Foo a => Ord (Bar a) where ...
09:12:16 <JagaJaga> Can't `stack build` be parallel?
09:12:56 <Rembane> It is
09:13:00 <Rembane> At least on my computer
09:13:19 <k_bx> stack build —ghc-options=“-j” gives even more parallelism
09:13:23 <JagaJaga> It downloads and builds everything in not a parallel way as I see it...
09:13:42 <k_bx> But per-package parallelism is on by default (uses all CPUs)
09:14:21 <k_bx> JagaJaga: maybe check stack version, it wasn’t always parallel by default
09:14:42 <JagaJaga> k_bx: Version 1.0.2
09:15:32 <Sonarpulse> is there a monadic %~ from lens?
09:15:56 <k_bx> JagaJaga: how did you install it?
09:15:56 <Sonarpulse> i.e. I want to modify the "field" with a monadic function (a -> m b)
09:16:19 <JagaJaga> k_bx: with nix.
09:17:25 <k_bx> JagaJaga: sorry, probably better to speak to nix maintainer of stack then :/
09:18:28 <hpc> Sonarpulse: hayoo claims that the (a -> b) is really Profunctor p => p a b, which would have let you use p = Kleisli
09:19:18 <hpc> Sonarpulse: seems to have changed in 4.0
09:19:32 <Sonarpulse> hpc oh i just found an issue saying not possible
09:19:47 <Sonarpulse> https://github.com/ekmett/lens/issues/520
09:20:49 <hpc> ah cool
09:21:28 <blackcat_007> Where can i find basics of hacking and start towards it 
09:22:05 <hpc> blackcat_007: where did you get the idea that was on-topic here?
09:22:23 <blackcat_007> Sorry New user 
09:22:37 <nitrix> blackcat_007: This is a channel for the programming language Haskell. Questions about Haskell are welcome here :)
09:23:03 <blackcat_007> my bad 
09:23:35 <srhb> I wonder if it's because of the name of hackage. Does seem to be a common misconception.
09:23:37 <hpc> serious question though, you're the second person in just a few hours to think this is a blackhat channel
09:24:42 <Sonarpulse> ...this is kinda funny
09:25:16 <Lovepon> I'd have to ask, why is there no `Event t a -> Event t b -> Event t a` in Reflex?
09:25:32 <Lovepon> It's not hard to emulate though, but why?
09:26:06 <Sonarpulse> Lovepon: you know there is a #reflex-frp channel?
09:26:15 <Lovepon> Sonarpulse: Yes.
09:26:31 <Sonarpulse> k. of course question is not off topic here
09:26:57 <Sonarpulse> but in my experience generally get a fast response there and of course greater density of reflex users
09:27:36 <Lovepon> Okay, I'll go ask there then.
09:28:52 <tippenein> how can I figure out the name of a constructor in ghci?
09:29:17 <tippenein> I have let g = ObjectKey "sometext"
09:29:28 <tippenein> how can I pull out the "sometext" as Text
09:29:31 <chaoxu> hi guys, is there somewhere to read more about type and kind? like Monad is of kind "(*->*)->Constraints". Want to know more about type parameters and maybe a bit of theory behind it (possibly category theory)
09:29:55 <hpc> chaoxu: you might try the wikibook
09:29:58 <hpc> @where wikibook
09:29:58 <lambdabot> http://en.wikibooks.org/wiki/Haskell
09:30:08 <hpc> chaoxu: i don't remember if RWH covers it, but look there too
09:30:09 <hpc> @where RWH
09:30:10 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:30:17 <geekosaur> tippenein, do you mean you have an unknown constructor, or a known one?
09:30:25 <chaoxu> hpc: thanks
09:30:32 <geekosaur> if you know it. you can just pattern match: let ObjectKey k = g
09:30:42 <hpc> chaoxu: at a very basic level, kinds are types of types and they follow most of the same general rules
09:30:45 <geekosaur> if you don't, take a look at Data.Data
09:31:03 <tippenein> geekosaur: perfect. thanks
09:31:07 <geekosaur> (I hope you at least know the type)
09:31:43 <hpc> chaoxu: usually there's no distinction - in some languages like agda, literally the only difference is types are elements of Set 0 and kinds are elements of Set 1
09:31:43 <Cahu> Hi! Is it part of the Haskell specifications that types deriving Enum are assigned values from 0 to n-1, in order of declaration, when using fromEnum ? Or should I explicitly create an instance of Enum by hand to enforce this ?
09:31:58 <hpc> chaoxu: (on a theoretical level)
09:32:26 <hpc> anyway much of that should be covered by the wikibook and whatnot
09:32:31 <Sonarpulse> ok next lens question, how do i get a lens-like for my newtype?
09:33:27 <hpc> Cahu: https://www.haskell.org/onlinereport/derived.html
09:33:28 <chaoxu> hpc: cool, is there corresponding in Cateogory theory?
09:33:57 <hpc> Cahu: or h2010, https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18200011
09:34:07 <chaoxu> hpc: seems Functor is arrow there in the Type category, but doesn't have anything to do with GHC.Prim.Constraint
09:34:49 <hpc> chaoxu: i only know very broad strokes at the level of how theory maps to code, so i can't really point to a specific math thing and say "that's a type/kind"
09:35:29 <hpc> stick around and someone else might know though
09:35:52 <chaoxu> hpc: cool
09:36:14 <geekosaur> I don't think ghc's Constraint maps to mathematical concepts
09:36:34 <geekosaur> in some ways it's just a hack to be able to talk about contexts within the language
09:36:46 <geekosaur> i.e. an implementation detail, not a theoretical construct
09:36:49 <c_wraith> You can describe it in mathematical terms.  But it doesn't derive naturally from them.
09:37:08 <geekosaur> well, sure, you an describe a lot of things in mathematical terms :)
09:37:46 <geekosaur> you can describe IEEE floats in mathematical terms, that doesn't make them any better behaved for folks looking for a real number ring
09:39:12 <geekosaur> ..in fact you'll find a lot of things in Haskell that don't have much to do with theoretical math. Like, the whole Num hierarchy >.>
09:39:33 <Sonarpulse> nevermind, works now
09:39:59 <hpc> you'll also find a non-zero chunk of time in this channel is spent going into great detail about exactly how such things don't have much to do with theoretical math
09:40:00 <horatiohb> What's happened to #haskell-blah?
09:40:14 <hpc> horatiohb: it went off the deep end
09:40:17 <hpc> horatiohb: reconnect with ssl
09:40:18 <c_wraith> whoever admins it decided only people connecting via TLS can use it.
09:40:36 <horatiohb> thx
09:40:46 <hpc> wouldn't want someone snooping on our lolcats
09:41:00 <nitrix> horatiohb: We have #haskell-offtopic by the same ops as #haskell.
09:41:10 <nitrix> Hopefully that one can take off.
09:41:15 <geekosaur> unsafeLolcat ...
09:44:41 <Cahu> hpc, thanks. I read that before asking but I was not sure this applied to all compilers
09:47:09 <latenite> Hi folks, how do I install system wide using cabal? For now it it only in the (root) users directory https://gist.github.com/anonymous/14ff0975275c38b933d10bf662290252
09:47:56 <geekosaur> --global
09:48:01 <geekosaur> but in general that's a bad idea
09:48:41 <geekosaur> it makes recovering from installing conflicting versions of packages more complicated
09:50:08 <gio_gio> !ciao
09:50:15 <gio_gio> !lista
09:50:17 <monochrom> latenite: see my http://www.vex.net/~trebla/haskell/sicp.xhtml#root
09:50:40 <gio_gio> !lista
09:51:45 <plakband> is there a difference between m >>= f and m >> (fmap f m)?
09:51:49 <gio_gio> quit
09:52:17 <monochrom> yes. try m = putStrLn "hello".
09:52:54 <ClaudiusMaximus> f also has different types in those two expressions
09:53:00 <monochrom> yeah
09:54:02 <nitrix> I believe `m` on the right version will be executed twice.
09:54:11 <unit73e> hey. I'm having this issue with xmonad+xmobar: https://wiki.haskell.org/Xmonad/Frequently_asked_questions#XMonad_stops_but_the_current_window_still_responds_to_keys
09:54:17 <unit73e> I don't get why it's happening
09:54:38 <runeks> How can I write this expression in reverse? I assume there's some standard infix operator
09:54:41 <runeks> putMessage . wrapClientVersionInMessage . convertToClientVersion $ OpenChannel duration
09:55:17 <nitrix> runeks: Are you launching xmonad from .xinitrc ?
09:55:33 <unit73e> or better yet, I don't get how I can fix xmonad.hs and xmobarrc. How do I know what's not being read?
09:55:38 <runeks> nitrix: I think you'll want to talk to unit73e :)
09:55:49 <latenite> monochrom, thank you, that did the trick.
09:55:54 <nitrix> unit73e: ^
09:56:35 <geekosaur> unit73e, might do better to ask in #xmonad because it's busy in here. but put your xmonad.hs and .xmobarrc (if any) in a pastebin somewhere
09:56:36 <geekosaur> @paste
09:56:37 <lambdabot> Haskell pastebin: http://lpaste.net/
09:56:40 <geekosaur> ^ recommended pastebin
09:57:12 <unit73e> geekosaur, I didn't know that channel existed. Thanks.
09:57:44 <unit73e> nitrix, not using .xinitrc but I'll go #xmonad as recommended
10:05:52 <plakband> monochrom ClaudiusMaximus thanks
10:13:18 <plakband> I'm struggling to see why >>= and >> are necessarily in the same type class. Is there an identity relating the two?
10:13:53 <simpson> plakband: You can implement (>>) using (>>=), right, so (>>) isn't essential.
10:14:17 <simpson> plakband: However, (>>) can be much more efficient in some Monads if open-coded, so that option is available to you when writing your Monad instance.
10:16:44 <simpson> plakband: Does that make sense?
10:16:55 <nitrix> @src (>>)
10:16:55 <lambdabot> m >> k = m >>= \_ -> k
10:16:59 <nitrix> plakband: ^
10:17:33 <MichaelBurge> plakband: On Hackage, a typeclass will often have a 'Minimally Complete Definition' section for the crucial parts. Monad only needs '>>='
10:17:46 <MichaelBurge> plakband: Anything else is just for performance or if you want to override the defaults
10:17:52 <nitrix> Theorically, monads would only need `join`, but that's another matter.
10:18:04 <plakband> Thanks guys, that answers my question perfectly
10:19:17 <plakband> I was just about to ask whether  (\_ -> x) would make >>= into >> when lambdabot said that
10:19:48 <plakband> or nitrix asked for the source rather
10:19:54 <nitrix> :)
10:23:25 <nitrix> It could be implemented as (*>), but then you're risking people creating infinite definition loops (trying to define their (*>) in terms of (>>=)).
10:23:49 <nitrix> Err, (>>)
10:24:27 <nitrix> The naive implementation is fine :)
10:26:39 <plakband> So (*>) is just (>>) for applicatives, right?
10:27:26 <thimoteus> yes
10:28:00 <awal> hello
10:30:27 <awal> I am not-highly experienced developer. I know JS, python, c, rust (not much), etc. I know and use functional programming in these languages and I feel content with it. What can I hope to learn from Haskell about (functional programming) *other* than what these languages have already taught me?
10:30:33 <Sonarpulse> anyway i can get an inverse lens-like for a new type?
10:31:05 <Sonarpulse> i.e. i want to project to new type, do some operation, unwrap
10:32:21 <awal> I can find lots of haskell vs. no-haskell and fp vs. no-fp debates on the internet with the proponents generally describing that haskell is enlightening, but I'd like to know what about it is enlightening compared to other common languages. I can't find this, though :(
10:32:28 <maerwald> awal: none of the languages you named have a comparable functional paradigm like haskell, except a little syntax. So you'll feel like learning programming again.
10:33:17 <awal> maerwald: yeah, well examples for that is what I am looking for :P
10:33:28 <simpson> awal: There's a couple concepts common to the ML family (lightweight syntax, type inference) which you'll get to experience.
10:33:52 <Sonarpulse> awal if you haven't learned haskell
10:33:54 <Sonarpulse> google some code
10:34:02 <simpson> awal: There's also the opportunity to experience some of the extremely-high-level libraries unique to Haskell, and to learn the unique curse words that we throw at those libraries.
10:34:02 <Sonarpulse> and if it makes no sense at first
10:34:04 <Sonarpulse> well there you go
10:34:07 <maerwald> awal: examples are everywhere
10:34:21 <simpson> awal: But yes, learn some Haskell. Just do it. Also learn Forth and Prolog.
10:34:44 <awal> I know prolog, thanks. Forth is unheard to me :)
10:35:20 <awal> I hate to say this because I know it'd come off as rude, but "Just do it" isn't a compelling argument.
10:35:58 <maerwald> awal: I already answered your question... the languages you named are _nothing_ like haskell so they basically haven't taught you anything haskell will teach you
10:36:46 <simpson> awal: Don't learn Haskell. It's a waste of time and you can be fully enlightened as a career Java programmer. Actually, while we're on the topic, computers are hard and usually not rewarding, so I recommend doing something non-computery.
10:37:00 <maerwald> simpson: +1
10:38:06 <awal> maerwald: Again, begging for an example. It'd be great if you could just link to some 5 line code or anything which you feel couldn't be done as simply/efficiently in any of the languages I mentioned.
10:38:30 <maerwald> awal: I never said you cannot do haskell code in other languages as simple or efficient
10:38:30 <simpson> awal: Doesn't exist. Of the languages you listed, JS is trash, and Python and Rust both have scenarios in which they shine and Haskell falters.
10:38:34 <maerwald> so no idea what you mean
10:38:51 <awal> > JS is trash
10:38:51 <awal> +1
10:38:52 <lambdabot>  Not in scope: data constructor ‘JS’    Not in scope: ‘is’
10:38:52 <lambdabot>      Perhaps you meant one of these:
10:38:52 <lambdabot>        ‘id’ (imported from Data.Function),
10:39:04 <awal> sick of that idiotism because of my day job
10:39:35 <simpson> It's getting better, but they're not removing the bad parts, so avoid it. Fortunately, Haskell has like three decent Haskell-to-JS compilers.
10:40:35 <awal> simpson: "Python and Rust both have scenarios in which they shine and Haskell falters." sure, but surely there are also scenarios for the inverse? Examples for *those* scenarios?
10:40:48 <maerwald> abstraction
10:40:51 <mfukar> awal, it's more useful to find applications of Haskell to the problems you face daily or interest you, instead of bikeshedding about contrived examples which are bound to suffer from bias (in many ways)
10:41:28 <mfukar> So, what's a problem that's interesting to you at the moment?
10:42:01 <awal> mfukar: NLP I guess.
10:42:14 <awal> totally agree with what you said above, btw.
10:42:29 <simpson> > let fibs = 0 : scanl (+) 1 fibs in take 20 fibs -- awal: behold the alien tongue of Haskell
10:42:31 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
10:42:32 <mfukar> welp, I can't offer anything there. :)
10:43:05 <plakband> awal: I always found quicksort a great and accessible example of the power of Haskell
10:43:20 <bernalex> plakband: that's strange. because quick sort is *horrible* in haskell.
10:43:34 <bernalex> merge sort is nice enough though.
10:43:36 <maerwald> plakband: you probably don't mean the real quicksort
10:43:48 <maerwald> which relies on in-place mutation
10:44:08 <plakband> ~power~ -> expressiveness
10:44:34 <maerwald> plakband: see http://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html
10:44:37 <c_wraith> Real expressiveness gives you the ability to say what you're not doing.
10:44:50 <bernalex> awal: there's no language that does anything really interesting in five lines of code. haskell included. the reason haskell's features are so good manifest the most clearly when you have 10K SLOC that are five years old.
10:44:54 <c_wraith> That is, it gives you the ability to arbitrarily limit your power.
10:45:26 <maerwald> bernalex: and that property of haskell is difficult to communicate :/
10:45:43 <simpson> c_wraith: Sure. Haskell's not that language, but it's much better than e.g. C.
10:46:10 <c_wraith> simpson: it's better than anything that lacks a termination checker :)
10:46:41 <mettekou> To the people familiar with the calculus of inductive constructions/Coq: does the guarded-by-destructors syntactic predicate (Giménez, 1994) seem like an ideal job for uniplate or is that just me?
10:46:48 <bernalex> awal: I mean, sure we can whip up a oneliner for all fibonacci numbers: 'f = 0 : 1 : zipWith (+) f (tail f)'. but is that really interesting and useful? not that much.
10:46:52 <MichaelBurge> awal: It might sound boring, but I like Haskell because I don't have to write unit tests for every little thing to enable refactoring and my code often works the first time it compiles.
10:47:05 <MichaelK> Hi, why isn't there a non-io catch function? I looked through the source and ended up at catch# from GHC.Prim, which uses State# RealWorld
10:47:12 <MichaelBurge> awal: The types also make it easy to browse documentation
10:47:14 <awal> bernalex: fair enough
10:47:21 <simpson> c_wraith: I politely disagree; Haskell is not *capability-safe*, meaning that there really is a tier just beyond Haskell (and far below Agda and Idris) where E, Monte, and other capability languages reside.
10:47:39 <awal> MichaelBurge: How is that specific to haskell though?
10:47:43 <tdammers> MichaelK: because catching exceptions it intrinsically impure
10:47:45 <c_wraith> MichaelK: Because catching exceptions allows distinguishing things that are all bottoms in denotational semantics.
10:48:15 <c_wraith> MichaelK: if you want to pretend catching exceptions is ok despite that, there is the spoon library
10:48:18 <c_wraith> @hackage spoon
10:48:18 <lambdabot> http://hackage.haskell.org/package/spoon
10:48:19 <maerwald> awal: it is not, he just means strong typing, which haskell does too
10:49:30 <bernalex> maerwald: it's far more than just *strong* typing. try expressing the IO type in a sensible way using c++, or having nice GADTs using PHP.
10:49:45 <MichaelK> c_wraith: that's interesting, I ended up writing something similar. but it's appx. 5x slower than leaving it in IO, which doesn't make sense to me
10:50:03 <jophish> Is there a class for operations like this: (f a -> f b) -> a -> b
10:50:04 <c_wraith> awal: types actually expressing meaningful things about code requires expressive type systems.
10:50:07 <jophish> hoogle didn't help
10:50:22 <c_wraith> jophish: about the only type that's usefully defined on is Identity.
10:50:29 <MichaelK> jophish: wouldn't that escape the functor?
10:50:37 <simpson> bernalex: Go stronger. There's a pile of Python libraries for implementing GADTs, although nearly nobody calls them that in Python; additionally, IO is hilariously overpowered compared to fine-grained capabilities in e.g. Monte.
10:50:41 <jophish> c_wraith: heh, that's what I'm looking for
10:50:47 <jophish> well, Id from the ad package
10:50:48 <MichaelBurge> awal: I guess it isn't. Something like F# would probably do fine on all of those accounts, and perhaps has even better tooling. Maybe ML would work too.
10:51:20 <jophish> simpson: what are they called in python?
10:51:36 <jophish> I didn't think python had enough of a type system to make that possible
10:52:09 <simpson> jophish: Python's got strong types and the power to type-check values. There's a pile of different libraries; the last one I interacted with was called "characteristic".
10:52:16 <MichaelBurge> awal: It certainly gives you an advantage over e.g. Perl, Python, Ruby, C, Javascript, etc. But I wouldn't claim it's the only functional language with a strong type system.
10:52:17 <awal> yeah, mostly I am looking for exclusive features to motivate myself into learning haskell. I have an extremely tight schedule (trying to find time to come here since over 3 weeks I think), so starting learning haskell is probably gonna be expensive for me.
10:52:36 <simpson> jophish: (The really powerful GADT stuff isn't available in Python, but it's also not available in much short of Agda and co.)
10:52:36 <jophish> MichaelK: pretty much, yes, could be done with Comonad
10:52:44 <c_wraith> awal: I wrote a rather contentious article about how haskell types are fantastic documentation.  Some people said "yes, of course".  Some people said "that's all abstract nonsense".  The article is https://www.schoolofhaskell.com/user/chowells79/types-not-tutorials
10:52:58 <simpson> [a] -> [[a]]
10:52:59 <maerwald> bernalex: c++ is strongly typed? uh
10:53:20 <tdammers> fwiw, what Python calls "types" is a different beast from what types are in Haskell
10:53:50 <geekosaur> maerwald, compared to C it is
10:54:03 <MichaelBurge> awal: Good features other languages don't have are ADTs and pattern matching. If you write an interpreter for a simple programming language, that will emphasize those two.
10:54:05 <Zemyla> c_wraith: (,) w, where w is a Monoid, has a useful definition too.
10:54:06 <geekosaur> (sadly, it still allows you to use some C-isms)
10:54:07 <tdammers> maerwald: I would call it "somewhat strongly typed" - some implicit type coercion does happen, but it isn't as weak as, say, C
10:54:26 <simpson> awal: Don't bother. Focus on your day job.
10:54:31 <monochrom> I am skeptic of the value of the programming language equivalent of debating over "is Christoph Waltz tall?"
10:54:42 <c_wraith> Zemyla: oh, hey.  It does!  Actually, I don't think w even needs to be a monoid, since the implementation is probably just going to ignore it.
10:54:43 <awal> c_wraith: would read soon, thanks! :)
10:55:01 <Zemyla> c_wraith: Yeah, it does, it needs mempty at least.
10:55:08 <Zemyla> To turn an a into an f a.
10:55:13 <c_wraith> Ah, right.
10:55:30 <Zemyla> Also, (->) w, where w is a monoid.
10:55:35 <oconnorct1> I need help -_- f lst = [x | x <- lst, y <- [0..], y `mod` 2 not 0]
10:55:39 <bernalex> simpson: without more context than that, you are simply coming off as needlessly rude and hostile to newbies. please try to be more helpful.
10:55:53 <c_wraith> So..  Really..  You just need f to be Pointed and Copointed.
10:55:54 <Zemyla> Basically, if f is a Comonad and an Applicative, it can be done.
10:56:07 <xa0> Zemyla: reader doesn't need monoid does it?
10:56:08 <oconnorct1> I am trying to iterate through a list, everytime I reach an odd index I want to make a new list of only the odd
10:56:08 <c_wraith> Which happens more often than Comonad and Applicative
10:56:15 <Zemyla> xa0: It does for extract.
10:56:21 <c_wraith> Reader isn't Copointed, though.
10:56:23 <monochrom> oconnorct1: use /= for "not equal". and I am not sure what is x doing there.
10:56:24 <xa0> Oh you're on comonads
10:56:26 <xa0> Ok
10:56:41 <maerwald> I'm on comonads *sniff* :D
10:56:44 <Zemyla> c_wraith: extract f = f mempty; duplicate f = \ra rb -> f (mappend ra rb)
10:56:46 <mfukar> oconnorct1, you want to filter out every other element?
10:56:46 <bernalex> awal: learning haskell by reading a tiny bit, say two days a week, on a tight schedule, is probably not going to work well for you since you don't know any properly similar languages. I would suggest putting haskell away for now, and pulling it up again when you have a vacation or other opening that lets you devote about a full work week in a month's time or so.
10:57:02 <c_wraith> Zemyla: Sure, but that's something different from Reader.
10:57:04 <oconnorct1> yes :P
10:57:15 <oconnorct1> every even element, so 0 2 4 I am not interested in
10:57:18 <oconnorct1> just 1 3 5
10:57:21 <oconnorct1> etc
10:57:38 <oconnorct1> Now with /= I get lots of 8s
10:57:41 <oconnorct1> hmm
10:57:46 <simpson> bernalex, awal: Don't bother learning things if you don't have time to learn and you don't know why you want to learn. Nobody here can motivate you to learn without anecdotal information as to why *they* learned. It's the monad tutorial problem.
10:57:50 <awal> bernalex: oh, ok. You are probably right.
10:57:57 <c_wraith> > map snd . filter fst . zip (cycle [True, False]) $ [0,1,2,3,4,5]
10:57:58 <lambdabot>  [0,2,4]
10:58:02 <Zemyla> If Writer and Env aren't different, then Reader and Traced are the same thing.
10:58:11 <c_wraith> Whoops.  Change the cycle around. :)
10:58:22 <bernalex> awal: it really is *very* different to the languages you have listed, and will take *serious* dedication to get into. not because learning haskell is all that difficult, but because you know languages that act very differently. in time, tools shape the way you think -- not just the other way around. so your brain will very likely "resist" haskell. if you are only reading a tiny bit of haskell every now and
10:58:25 <bernalex> again, you will simply forget it all between lessons, because your brain quickly chucks it away in favour of your established way of thinking.
10:58:50 <simpson> Haskell isn't some magic brain worm that your mind "resists". It's just another programming language.
10:58:53 <bernalex> simpson: thanks. although "the monad tutorial problem" likely doesn't tell a non-haskeller very much. :p
10:59:07 <awal> simpson: Here is why I *want* to learn haskell: I tried reading some haskell code and wasn't able to understand most things. I am generally very good with foreign languages though, so haskell surprised me. That sparked enough interest in me to care.
10:59:16 <simpson> bernalex: You'd be surprised how many people have only heard of Haskell via monad tutorial blog posts.
10:59:21 <oconnorct1> c_wraith was that for me?
10:59:26 <oconnorct1> There isn't a simpler way?
10:59:39 <simpson> awal: Cool! There's lots of learning resources, a few good books, and a relatively well-informed and helpful community.
10:59:55 <c_wraith> oconnorct1: simpler is a relative term.  There are ways to do it involving fewer pieces.  But they involve more complicated pieces.
10:59:57 <bernalex> simpson: it emphatically isn't "just another programming language" in the way that people generally use that phrase. if you know php, perl, and python -- picking up lua is *very easy* compared to haskell. in this case, lua is "just another programming language" -- haskell might as well be recently recovered ancient alien knowledge.
11:00:06 <mfukar> oconnorct1, how about this: http://lpaste.net/162044
11:00:09 <tdammers> simpson: Haskell is sufficiently different from all the major mainstream languages; many approaches that work well all in those languages won't work in Haskell, or will make for incredibly clumsy unidiomatic code
11:00:18 <awal> bernalex: yeah I guess that's right. I'd come here again in summers maybe.
11:00:26 <oconnorct1> Yeah, I am really good at js and Java and even c, but haskell... I just can't wrapy my brain around it yet
11:00:28 <oconnorct1> gonna keep trying
11:00:35 <monochrom> the brain itself is magical enough. there are a lot of things the brain can magically resist. (again, the magic is on the brain, not on the things resisted.) case in point: a lot of programmers resist scientific thinking.
11:00:50 <MichaelK> awal: I was at a similar point. the only way I got started is when I found a suitable project that needed a rewrite and had the time
11:00:51 <awal> Thanks a lot for the discussion guys! And sorry if I stirred up shit. :)
11:00:54 <tdammers> simpson: and the "resistance" lies in how you will keep trying to apply your existing problem solving strategies in a Haskell context, and fail
11:01:06 <simpson> bernalex, tdammers: I live in Portland. All of the college kids here learn Haskell. It really is just another programming language. This whole "alien language" thing is a pretty cruddy meme that prevents us from acknowledging that.
11:01:13 <mfukar> oconnorct1, it's slightly wrong, but it's simple enough to modify it to get the right behaviour :)
11:01:13 <bernalex> awal: I learned haskell during a summer vacation. two months of maybe three hours, five days a week. not in the most diciplined manner. I ended up being competent enough to write something useful after about two months.
11:01:29 <simpson> bernalex, tdammers: To quote Perlis: "Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies."
11:01:34 <oconnorct1> wow, that looks really interesting mfukar
11:01:36 <oconnorct1> thanks
11:01:47 <bernalex> simpson: they are not learning it by reading two hours a week, and just picking up stuff as they go -- unless they have an agda/idris background, which most people *don't*.
11:02:36 <simpson> bernalex: They're learning it in exactly the same manner as students might learn Java, or C, or Python: An instructor stands up in front, recites a litany of obtuse programming concepts, and befuddles freshmen.
11:02:39 <bernalex> simpson: if you know python & perl, you can do that with lua without any problem.
11:02:58 <simpson> bernalex: Neophytes can learn Haskell as their first programming language. It really is just another language.
11:03:19 <maerwald> it's not his first programming language, which makes it harder
11:03:21 <bernalex> simpson: yes, of course they can. but you seem to be eliminating all the context I am giving my statements on purpose, so I give up.
11:03:36 <simpson> bernalex: I just don't think that Haskell is special, sorry. :c
11:03:46 <oconnorct1> It works!
11:03:50 <oconnorct1> Thanks mfukar!
11:04:03 <bernalex> simpson: haskell is special to a lua/perl/python programmer the same way c++ would be very different to a haskell/idris/agda programmer.
11:04:03 <maerwald> simpson: it's about how much the paradigm is different, not about "special", you are misinterpreting
11:04:49 <mfukar> Unfamiliar, perhaps
11:05:09 <monochrom> a lot of programmers also resist math and/or algebra. to them, the motto "you can do equational reasoning in Haskell" is a con, not a pro.
11:05:41 <MichaelBurge> simpson: There's a sense in which you're right, but in practice imperative programming doesn't necessarily teach you to think in a way that is shared between Haskell and, say, C++
11:05:44 <monochrom> so yes statistically Haskell is special, if your pool of brains is from programmers
11:05:54 <bernalex> if bikes turned the other way, that wouldn't be special or more difficult to learn than the way they turn today. but if you were to spend two hours a week learning how to turn the other way, all the while riding a normal bike 40h a week, learning to ride the "wrong bike" would be really difficult.
11:06:00 <tdammers> simpson: what I meant is that while Haskell *is* just another programming language, the current list of popular languages is similar enough to one another to make Haskell not just another one of *those*
11:06:32 <bernalex> and riding a bike that turns the other way is just a single operation. a programming language is far more intellectually demanding and complex.
11:17:24 <monochrom> You know what, I heard that with today's bikes, you go left by turning the handle right, because then counterintuitive momentum physics kicks in and brings you left.
11:18:00 <monochrom> So I would actually welcome a hypothetical, alternatively bike that "turns the other way", which would be the intuitive way.
11:21:06 <monochrom> What you want for a better analogy is a REPL that makes you enter each command in reverse order. For example to ask for ":t id id" you enter "di di t:"
11:21:31 <oconnorct1> I have another question
11:21:33 <oconnorct1> http://pastebin.com/7cL4nU9X
11:21:37 <oconnorct1> I posted the question here
11:23:02 <monochrom> I don't understand the question. What is rev :: [[a]] -> [a] supposed to do? (Do not play the "meaningful identifier" card on me.) (ELINT = Explain like I am not telepathic.)
11:24:19 <oconnorct1> Sorry, ok. So basically, I THINK what the website is doing, is putting all the input into different arrays like this: [[1],[2],[3]]
11:24:23 <oconnorct1> which is stupid
11:24:25 <Zemyla> How often is a Functor Copointed without being a Comonad?
11:25:00 <monochrom> OK, I take it that you don't know either.
11:25:31 <Zemyla> monochrom: rev _ = [].
11:25:33 <oconnorct1> http://pastebin.com/ZRUATiQH
11:25:38 <geppettodivacin> oconnorct1: Are you trying to flatten and reverse the list?
11:25:41 <oconnorct1> better yet here is the error message I get for my funciton
11:25:42 <Tene> It's very disorienting for me at work to hear otherwise-apparently-competent engineers claiming that Haskell is some kind of incomprehensible eldritch knowledge that they're fundamentally unable to comprehend.
11:25:44 <oconnorct1> I just want to reverse it
11:25:50 <oconnorct1> which is really easy with a normal array.
11:26:02 <oconnorct1> But I can't figure out quite how this website is flattening the input
11:26:23 <oconnorct1> Because I tried writing my own main method to take all teh input and the website doesn't allow that.
11:26:40 <Tene> I usually try to believe people when they self-report internal experience, but...
11:26:43 <geppettodivacin> > reverse . join $ [[1],[2],[3]]
11:26:44 <lambdabot>  [3,2,1]
11:26:57 <geppettodivacin> oconnorct1: Like that? ^
11:27:05 <oconnorct1> right, I wasn't supposed to cheat but, that works I guess
11:27:20 <exio4> implement join and reverse yourself then :)
11:27:36 <oconnorct1> haha, ok,but I guess I see the . $ value.
11:27:36 <exio4> but [[a]] -> [a] for a rev function is weird.
11:27:41 <oconnorct1> RIGHT?!
11:27:51 <oconnorct1> it should just be [a] -> [a]
11:28:27 <geppettodivacin> But you can do it. You've just got to consider it two different steps: a flattening step and a reversing step.
11:28:28 <oconnorct1> btw - where did you get join I wonder
11:28:40 <geppettodivacin> join is a Monad thing. I probably should have done it with concat.
11:28:50 <geppettodivacin> > reverse . concat $ [[1],[2],[3]]
11:28:51 <lambdabot>  [3,2,1]
11:29:00 <oconnorct1> HAHA, sorry, I have yet to get to monads -_- sorry
11:29:10 <geppettodivacin> join is a generalization of concat to other types.
11:29:32 <oconnorct1> Couldn't match type `Int' with `[a0]'
11:29:34 <oconnorct1>     Expected type: [[a0]]
11:29:36 <srhb> oconnorct1: Also your original paste seems to imply that your rev solution would make it easy. But if you COULD write just rev, the last flattening step is fairly simple.
11:29:36 <oconnorct1>       Actual type: [Int]
11:29:38 <oconnorct1> I get a weird error still
11:29:49 <srhb> oconnorct1: It's also illustrative to understand why you're building an infinite type.
11:30:03 <oconnorct1> hmm
11:30:26 <srhb> oconnorct1: Well, or trying to unify a type `a` with a type `[a]`
11:30:45 <srhb> :t (:)
11:30:46 <lambdabot> a -> [a] -> [a]
11:30:51 <srhb> ^ note this type
11:32:20 <oconnorct1> maybe I should be going back to the basics.. I might be ahead of myself.
11:32:32 <slaterr> what was that haskell library/preprocessor that allowed you to have inlined C in a .hs file?
11:32:57 <Zemyla> slaterr: Was it hsc2hs?
11:33:18 <oconnorct1> me? I dunno, I practice functoinal programming on HackerRank
11:33:50 <srhb> oconnorct1: What's the type of rev (tail l) ?
11:34:22 <slaterr> Zemyla no, you could actually write plain C using C syntax in a haskell source file. like some compilers let you write inlined assembly in a C source
11:35:31 <slaterr> I'm checking inline-c, maybe that was it
11:35:53 <r444> it's inline-c, yes
11:36:30 <srhb> oconnorct1: Or even simpler, what's the type of `rev l`?
11:36:42 <oconnorct1> No instance for (Show a0) arising from a use of `show'
11:36:44 <oconnorct1>     The type variable `a0' is ambiguous
11:37:00 <srhb> oconnorct1: I mean, try to reason out the type :)
11:37:09 <srhb> oconnorct1: Given a list, what should rev return?
11:37:15 <srhb> Which type.
11:37:53 <oconnorct1> a list
11:37:55 <oconnorct1> sorry
11:37:57 <oconnorct1> haha
11:38:05 <oconnorct1> if it's a list, you just return the list opposite
11:38:10 <srhb> oconnorct1: Right! And what's the type of `head l` ?
11:38:22 <oconnorct1> just an int
11:38:35 <srhb> Ok, so if rev l :: [Int] and head l :: Int
11:38:49 <oconnorct1> OH!
11:38:55 <oconnorct1> so you just take the head of each one
11:39:01 <srhb> Weelll, maybe not
11:39:10 <srhb> But hopefully you can see why this is a problem
11:39:20 <srhb> :t \(x:xs) -> xs : x
11:39:21 <lambdabot>     Occurs check: cannot construct the infinite type: t ~ [[t]]
11:39:21 <lambdabot>     Relevant bindings include
11:39:21 <lambdabot>       xs :: [t] (bound at <interactive>:1:5)
11:39:27 <srhb> Because...
11:39:29 <srhb> :t (:)
11:39:30 <lambdabot> a -> [a] -> [a]
11:39:38 <oconnorct1> yeah, I struggles with the :t and the \ backslash
11:39:41 <srhb> Oh sorry
11:39:42 <oconnorct1> still learning all the syntax
11:40:16 <srhb> I'm just saying that the list cons operator, (:), takes an element as its first argument and a list of that element as its second, and produces such a list [a]
11:40:39 <srhb> You have a list [a] as the first argument (tail (rev l)) and an element as the second (head l)
11:40:47 <srhb> Which gives you funky type problems.
11:40:49 <slaterr> has anyone tried both inline-c and language-c-inline? what were the pros and cons of each?
11:41:03 <bernalex> monochrom: some guy made a bike that turned the other way. he spent a lot of time learning how to ride it. and found that when it finally clicked -- he was unable to ride normal bikes.
11:41:04 <oconnorct1> oh... DUH. So I need to concat not use : use ++
11:41:28 <srhb> oconnorct1: Now that sounds a lot more sane :-)
11:41:38 <oconnorct1> HAHAHAH, thank you so much
11:42:03 <oconnorct1> or I could just do head l : rev $ tail l
11:42:20 <srhb> oconnorct1: Could you now...
11:42:24 <bernalex> monochrom: the research he was actually doing was on brain function in children; children learnt to ride it much more quickly than he or other adults did. the same problem remained though, afair, in that they could only learn how to ride one of the bikes, and needed substantial time to revert to the other way of turning.
11:42:56 <monochrom> I want his study replicated for my REPL idea :)
11:42:57 <oconnorct1> hmm
11:42:59 <oconnorct1> no that doesn't work
11:43:01 <oconnorct1> let me think
11:43:35 <oconnorct1> last l : rev $ init l
11:43:53 <srhb> I liked your first version better, with the concat.
11:44:11 <oconnorct1> Yeah, I guess it is clearer
11:44:16 <srhb> I also think pattern matching is a lot clearer than using head and tail
11:45:39 <oconnorct1> Can you expound upon that a bit?
11:45:52 <srhb> ie rev (x:xs) = rev xs ++ (the part with x you haven't done yet)
11:48:07 <oconnorct1> ohhh
11:48:16 <oconnorct1> Yeah, I've seen that style in tutorials and I like it too
11:49:09 <srhb> (This particular solutions suffers from some problems, but I think they are better left for another time, and the clearness of what is happening is more important right now :-))
11:50:02 <saurabhnanda> is it possible to define ad-hoc record types? It's quite a pain to define new types for every single JSON response (wrt Aeson)
11:50:42 <bergmark> saurabhnanda: you can decode into aeson's Value type to just manipulate it in json form
11:50:59 <saurabhnanda> bergmark: well, that's plan B.
11:51:26 <saurabhnanda> bergmark: what will happen if in the applicative chain (while using <*>) one expected parameter is not present?
11:51:41 <bergmark> which applicative? Parser?
11:52:48 <r444> saurabhnanda: you'll have something of kind * -> *, if the rest typechecks
11:54:24 <saurabhnanda> bergmark: yes, parser
11:54:38 <saurabhnanda> parallal, stupid question. Is (f g x) same as (f.g x)
11:54:45 <ski> nope
11:54:54 <ski> `f.g x' means `f.(g x)'
11:55:07 <ski> `f g x' means `(f g) x'
11:55:26 <ski> however, `(f . g) x' is the same as `f (g x)'
11:55:29 <saurabhnanda> ski: so, (f.g x) is same as (f $ g x)
11:55:35 <ski> no
11:55:40 <bergmark> saurabhnanda: it depends on what combinator you are using, e.g. with .: the whole parse will fail, but with .:? you get a Maybe instead
11:55:44 <ski> the latter is another way to spell `f (g x)'
11:55:52 <ski> the former is something different
11:58:24 <saurabhnanda> how is (^? (nth 0) . (key "gid")) accessing [{"gid":"3a46f47812e5f25a"}] ? I wrote it earlier, but can't understand it myself now.
11:58:49 <saurabhnanda> bergmark: is using lenses a good idea? instead of parsers?
12:00:46 <slaterr> inline-c is amazing. so much easier to use than ForeignFunctionInterface extension
12:01:19 <bergmark> saurabhnanda: i can't read lens, what's its type?
12:01:58 <saurabhnanda> bergmark: I can't grok the type... too complicated.
12:03:35 <saurabhnanda> :t (^?)
12:03:36 <lambdabot> s -> Getting (First a) s a -> Maybe a
12:03:59 <bergmark> :t key
12:04:00 <lambdabot>     Not in scope: ‘key’
12:04:01 <lambdabot>     Perhaps you meant one of these:
12:04:01 <lambdabot>       ‘IM.keys’ (imported from Data.IntMap),
12:04:46 <saurabhnanda> :t Data.Aeson.Lens.key
12:04:47 <lambdabot> Not in scope: ‘Data.Aeson.Lens.key’
12:05:10 <saurabhnanda> key  :: (Applicative f, AsValue t) => Text -> (Value -> f Value) -> t -> f t
12:05:31 <saurabhnanda> nth :: (Applicative f, AsValue t) => Int -> (Value -> f Value) -> t -> f t
12:06:03 <bergmark> seems to me that this parser will never fail and just give a Nothing instead
12:07:12 <saurabhnanda> I'm not sure how this Lens access is really working
12:07:26 <saurabhnanda> as in, I can't understand how I got this complicated chain of functions to compose
12:08:01 <shanemikel> I'm trying to figure out how to install applications with stack.. I'm playing with yi, installing it in global project, but it needs to be able to find the yi library headers and the docs stuff in .stack/****/share.. so I've been using stack exec to start it.. trouble is, what happens when I run it with my working directory a stack project?
12:08:46 <Lovepon> https://hackage.haskell.org/package/cryptocipher-0.3.0/docs/src/Crypto-Cipher-RSA.html#makeSignature
12:09:03 <jophish> I have a datatype `Orbit a` where a is the type used to represent numbers in the orbit. I can't derive functor without allowing the user to break the invariants of the type. I would like to provide unsafeMapOrbit though for things like `unsafeMapOrbit realToFrac`. Does anyone know of a generics package able to write this function for me?
12:09:08 <jophish> uniplate doesn't seem able to
12:09:14 <Lovepon> Am I going crazy, or should that have been klen <= siglen?
12:10:36 <bergmark> jophish: did you try with the uniplate Data interface?
12:12:10 <jophish> bergmark: most of the uniplate functions are along the lines of: Data a => SomeTransformation -> a -> a
12:12:26 <jophish> but I need: SomeTransformation -> Orbit a -> Orbit b
12:13:31 <MichaelBurge> saurabhnanda: There's no shame in unrolling a terse section of code into something more verbose that's clearer to read
12:13:32 <jophish> I saw some package a while ago which could derive functor instances, I'll try and find that aggain
12:14:00 <jophish> ah, genifunctors
12:14:06 <saurabhnanda> MichaelBurge: true, but it seems to be the recommended way of using lenses. Sample: https://hackage.haskell.org/package/aeson-lens-0.5.0.0/docs/Data-Aeson-Lens.html
12:16:22 <bergmark> i would recommend to use the parts of lens that you understand...
12:16:25 <MichaelBurge> saurabhnanda: You're linking to a support library that adds lenses for Aeson in support of lenses being recommended. It seems a bit circular.
12:16:46 <saurabhnanda> MichaelBurge: ? didn't get that.
12:17:16 <saurabhnanda> MichaelBurge: I meant to say, that lenses seem to be written this way itself. Doesn't seem to be a way to "unroll" lenses
12:20:06 <MichaelBurge> saurabhnanda: By 'unroll', I mean write a function with type 'getGid :: Data.Aeson.Value -> Maybe Data.Text'
12:20:42 <MichaelBurge> saurabhnanda: Actually, I would write an ADT to represent the JSON and write ToJSON and FromJSON instances for it. You can do it by hand, or using deriveJSON.
12:21:06 <MichaelBurge> saurabhnanda: Then I would access the text field in the ADT just using the record accessor
12:21:14 <saurabhnanda> MichaelBurge: the problem with defining data types is that it's just too many of them
12:23:02 <saurabhnanda> is there a version of fromJust which can throw an errorMsg if Nothing is passed to it?
12:23:17 <jophish> hmm, genifunctors didn't work :(
12:23:17 <bergmark> saurabhnanda: in the `safe' package
12:24:44 <thoughtpolice> :t maybe (error "Uh oh")
12:24:45 <lambdabot> (a -> b) -> Maybe a -> b
12:24:53 <thoughtpolice> :t maybe (error "Uh oh") id
12:24:54 <lambdabot> Maybe b -> b
12:25:04 <thoughtpolice> Easy low-key solution I use sometimes.
12:25:45 <saurabhnanda> :t fromJustNote
12:25:46 <lambdabot> Not in scope: ‘fromJustNote’
12:25:55 <saurabhnanda> :t Safe.fromJustNote
12:25:56 <lambdabot> String -> Maybe a -> a
12:26:14 <saurabhnanda> bergmark: is that the on? fromJustNote?
12:27:50 <saurabhnanda> :t maybe
12:27:51 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:30:16 <bergmark> saurabhnanda: yes, Note
12:31:53 <slaterr> in inline-c is there a direct way of marshalling String to char * without converting it manually to ByteString or CString first?
12:32:55 * hackagebot module-management 0.21 - Clean up module imports, split and merge modules  https://hackage.haskell.org/package/module-management-0.21 (DavidFox)
12:32:59 <Hijiri> do you mean converting automatically to ByteString or CString?
12:33:31 <Hijiri> String is just a linked list of characters, so some conversion has to take place
12:34:05 <exio4> slaterr: I hope not - would you default to UTF-8? UTF-16 (LE)? ASCII and truncate?
12:34:15 <saurabhnanda> if I have a monad NwApp, and a bunch of values of type NwApp (Maybe x) that depend on each other, how do I compose their function calls? such that the first value that return (NwApp Nothing) short-circuits the computation?
12:34:18 <slaterr> Hijiri yeah it would have to convert it to ByteString or CString first
12:34:44 <maerwald> slaterr: what's the purpose?
12:35:12 <slaterr> exio4 I would expect it to default to whatever newCString :: String -> IO CString is defaulting to
12:35:22 <slaterr> maerwald less boilerplate
12:35:32 <maerwald> slaterr: I mean what are you marshalling
12:35:36 <maerwald> what's behind it
12:35:45 <slaterr> plain ascii characters
12:35:53 <slaterr> stored in String
12:36:00 <maerwald> what characters
12:36:35 <slaterr> maerwald does it matter? "foo"
12:36:46 <maerwald> yes, it matters... e.g. if you are dealing with filepaths
12:37:02 <maerwald> or if it is other stuff
12:37:03 <MichaelBurge> saurabhnanda: I think that's 'MaybeT'
12:37:06 <exio4> slaterr: áéíóúñùûüöä? 
12:37:14 <slaterr> i'm not right now, but curious how paths would make a difference
12:37:27 <maerwald> slaterr: first, paths are not plain ascii characters
12:38:06 <saurabhnanda> MichaelBurge: I was afraid of that. I was trying to rewrite my code to avoid EitherT & MaybeT and use MonadThrow instead
12:39:25 <slaterr> maerwald, ok. they are ascii characters. do you have an answer to my question, or was all this questioning for nothing?
12:39:42 <MichaelBurge> saurabhnanda: The other option would be to produce a '[NwApp (Maybe x)]' and write a function that composes them directly, if the x are the same type
12:40:05 <slaterr> let btext = pack text void [C.exp| int { puts($bs-ptr:btext) } |]
12:40:12 <slaterr> I want this without the pack text part
12:40:58 <maerwald> slaterr: the questioning was to figure out what input you expect which you did not tell us in advance
12:41:20 <saurabhnanda> MichaelBurge: nope, 'x' are not of the same type
12:41:23 <slaterr> question was about inline-c, then it devolved into something else
12:41:37 <maerwald> because String is not just String
12:42:27 <slaterr> maerwald, so now that you got answers to your questions do you have an answer to mine?
12:42:49 <saurabhnanda> wow, this is hard
12:44:15 <saurabhnanda> actually fmap to the rescue
12:44:16 <MichaelBurge> saurabhnanda: A 3rd option would be to add a 'is_short_circuiting' flag to your monad, change 'fail' to switch it on, and write 'check :: NwApp (Maybe a) -> NwApp a'
12:44:39 <maerwald> slaterr: if you only care about the first 8 bit of characters, then you can start using Data.ByteString.Char8, because that truncates
12:46:12 <slaterr> I can't because the code I am using is already using String and I don't have the desire to change everything
12:46:50 <maerwald> otherwise look at the available encodings https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html
12:46:51 <maerwald> and pick one
12:47:00 <maerwald> slaterr: you "can't"?
12:47:08 <maerwald> pack :: String -> ByteString
12:47:13 <maerwald> what can you not?
12:47:23 <slaterr> my question was about marshalling in inline-c, not about encodings or a choice of haskell data type 
12:47:35 <exio4> he wants to avoid explicit pack(s)
12:47:42 <slaterr> maerwald, yeah.. I said that about 15 minutes ago
12:48:30 <exio4> the only way to do it, if something expects a ByteString and you have a String, is to encode it, or whatever
12:49:06 <exio4> there's no way around it, if you have a String that can be safely truncated into a ByteString, though, you might be able to avoid String completely and don't even run into that issue
12:49:10 <maerwald> yes, and the "marshaller" cannot know what you mean, so you have to tell it
12:49:20 <maerwald> everything else is undefined
12:49:56 <slaterr> and yet somehow newCString :: String -> IO CString still exists, and I don't need to tell it anything
12:50:13 <maerwald> does it do what you think it does?
12:50:50 <maerwald> it calls getForeignEncoding
12:51:10 <slaterr> yes. not that i care, but i did look it up prior
12:51:56 <maerwald> "The Unicode encoding of the current locale, but where undecodable -- bytes are replaced with their closest visual match"
12:51:57 <maerwald> good look
12:52:00 <maerwald> *luck
12:52:11 <maerwald> you'll need it :P
12:52:27 <slaterr> you're still making this about encodings. my question was about inline-c, you havent' said a single word about inline-c
12:52:58 <kadoban> String -> CString is inherently about encodings.
12:53:10 <kadoban> Same as String -> ByteString
12:54:03 <maerwald> does OverloadedStrings work with inline-c?
12:54:33 <MichaelBurge> slaterr: The problem is that String can be a thunk, so if you passed the C code a direct pointer to the String in memory it would just have a pointer to some Haskell code
12:54:39 <slaterr> I don't know if it does
12:55:22 <MichaelBurge> slaterr: If you evaluated all such strings to normal form, you could theoretically reconstruct C strings from the C code using the thunks in memory.
12:56:19 <hexagoxel> maerwald: i would assume all Data.String.IsString's work.
12:56:33 <maerwald> the inline-c repository also seems to use OverloadedStrings
12:56:55 <maerwald> but I don't know enough about TH to know how that plays out
12:57:26 <slaterr> MichaelBurge I never suggested otherwise. even without thunks it wouldn't work, they are different data structures. but inline-c marshalling could just call newCString under the hood, which is a reasonable way to convert String to CString
12:58:00 <maerwald> I don't think that's reasonable, because it makes assumptions about encoding
12:58:07 <MichaelBurge> slaterr: Oh sure, that would work fine. But I thought you wanted to do this without re-encoding it as some sort of challenge?
12:58:14 <maerwald> which may or may not be correct
12:58:26 <MichaelBurge> slaterr: Is it just the inconvenience of having to call pack or unpack everywhere?
12:58:27 <slaterr> it is reasonable according to authors of Foreign.C.String module. and reasonable for my own set of requirements (ascii only)
12:59:15 <slaterr> MichaelBurge yes, just a convenience of not having to call pack or newCString everywhere. inline-c provides it for ByteString, I was wondering if it also does for String
12:59:20 <hexagoxel> (i don't see any IsString instances for CString, but it was a quick search)
12:59:58 <maerwald> well, wrt Strings and encoding, lots of haskell stuff is not reasonable, so I tend to disagree, but anyway
13:00:08 <maerwald> did you try OverloadedStrings now?
13:00:19 <slaterr> it is as reasonable of a default as any other I can think of
13:00:38 <slaterr> that works but only for literal strings
13:01:00 <maerwald> it's reasonable to have no default and not make assumptions when it comes to encoding
13:01:03 <slaterr> actually I don't think you even need OverloadedStrings, template haskell is just dumping all the characters to a .c file and then passing it to C compiler
13:03:07 <slaterr> the question was about non-literal strings. literal strings just worked, as can be seen in inline-c examples. this is a problem from trying to answer inline-c specific question without ever having used inline-c
13:05:29 <Boomerang> Does anyone know how I can make a recursive Var using the varying package? I see there is a function called "delay" ( https://hackage.haskell.org/package/varying-0.5.0.0/docs/Control-Varying-Core.html#v:delay ) that seems to do that but I can't figure out how to use it...
13:05:41 <maerwald> except it isn't inline-c specific
13:06:19 <MichaelBurge> slaterr: It looks like they actually parse the C: https://hackage.haskell.org/package/inline-c-0.5.5.2/docs/src/Language-C-Types-Parse.html
13:06:28 <slaterr> except it is
13:06:55 <MichaelBurge> slaterr: I bet you could hack on that to add some goofy syntax for representing strings that are converted before being passed to the C
13:06:57 <xQuasar2> ..
13:09:01 <MichaelBurge> slaterr: See, it's easy with bytestring because a bytestring is literally just a pointer and 2 other values. So they just use the pointer
13:09:03 <MichaelBurge> slaterr: https://hackage.haskell.org/package/inline-c-0.5.5.2/docs/src/Language-C-Inline-Context.html#bsCtx
13:09:32 <slaterr> MichaelBurge, I think it is even simpler than that. I did some googling while talking in the channel, and it seems that inline-c's support for bytestrings is not hard coded, and that you can extend it to do something similar for String
13:09:55 <MichaelBurge> slaterr: Yeah, I think you have to create a 'Context' and maybe an 'AntiQuoter'
13:10:06 <slaterr> yeah
13:21:34 <erisco> I went out on quite a limb with these comments on purity and equality. I'd appreciate some feedback on my thoughts here http://stackoverflow.com/questions/36969344/are-side-effects-everything-that-cannot-be-found-in-a-pure-function/36971495#36971495
13:22:40 <erisco> they are some thoughts I've had for a while, but perhaps wrong or misguided
13:24:05 <MichaelBurge> erisco: Every function has side effects of some sort, even a pure function. Most allocate heap memory, and all of them change registers on the CPU.
13:24:29 <erisco> MichaelBurge, sure, but I am discarding side effects from the discussion entirely because I don't know how to qualify a side effect
13:24:48 <erisco> I am just concerned with the definition I give at the top for purity
13:26:21 <MichaelBurge> erisco: I don't think so. Consider a function 'f :: a -> a = id' that also as a side effect increments a predetermined memory location
13:26:35 <erisco> MichaelBurge, you don't think so about what?
13:26:46 <MichaelBurge> erisco: Then the function itself is pure according to your definition, but one could use it to construct a non-pure function.
13:27:13 <erisco> how could you construct a non-pure function?
13:27:27 <exio4> "compiling it to machine code"? 
13:27:42 <erisco> I guess I don't quite understand what you are saying. The only definition of purity I am talking about is the one I provide
13:27:42 <exio4> that is what MichaelBurge suggests (or at least looks like it)
13:28:15 <erisco> if you have a pure function (according to my definition) I do not see how that allows you to construct a second function which is impure
13:28:39 <MichaelBurge> erisco: Is your purity definition 'for all x, for all y, x = y implies f x = f y'?
13:28:48 <erisco> yes
13:29:24 <arrow> is there a way to declare "data Foo = Foo a" where "a" is any datatype that derives "instance Show a" ?
13:29:42 <erisco> arrow, instead of that you would say   instance (Show a) => Show (Foo a) where …
13:30:02 <MichaelBurge> arrow: data Foo = forall a. Show a => Foo a
13:30:06 <erisco> or   myFunction :: (Show a) => Foo a -> B
13:30:07 <MichaelK> Hi, where can I ask about including some material from a BSD3 licensed library in my own library?
13:30:13 <arrrow> erisco: I don't think that's what I want
13:30:19 <arrrow> MichaelBurge: that looks like what I want; thanks!
13:30:26 <erisco> you don't want that :(
13:30:34 <erisco> hasn't that been deprecated by now?
13:30:37 <arrrow> erisco: I don't want *what* ?
13:31:09 <MichaelBurge> arrrow: The only thing you know about a is that you can turn it into a string, so I wonder if you can just use 'type Foo = String' instead?
13:31:11 <arrrow> I want something that can store *any type* (almost like a dynamic) as long as the type satisfies a certain interface
13:31:37 <arrrow> MIchaelBurge: I have this ADT, that can be "rendered" in many ways, like renderSvg, renderOpenGL, etc ...
13:31:49 <arrrow> and I want to throw in arbitrary objects, as long as they can be rendered
13:32:13 <erisco> something that can store any type is  data Foo a = Foo a  as you have given, and "satisfies Show" is defined as  myFunction :: (Show a) => Foo a -> B
13:32:24 <erisco> you constrain Foo when you use it, not when you declare it
13:32:34 <tpsinnem> what are the "(unknown)" strings about in the examples in http://book.realworldhaskell.org/read/using-parsec.html ?
13:32:52 <arrrow> erisco: but I don't want the 'a', because it's a gigantic scene
13:33:01 <arrrow> that can contain a bunch of random objects, and the objects can be hetereogeneous
13:33:01 <MichaelBurge> arrrow: I think that's a common pattern in UIs, to use a forall type
13:33:06 <arrrow> and as long as they can be rendered, I'm happy
13:33:21 <erisco> okay, then you're right, and this is a different use case than I thought
13:34:20 <erisco> {-# LANGUAGE GADTs #-} data Foo a where Foo :: (Show a) => a -> Foo a    how about
13:37:17 <MichaelBurge> erisco: I guess it hangs on what you consider to be a function. If you mean, "A function is the compiled bytes in memory of a abstract pure function", then you can have
13:37:36 <MichaelBurge> erisco: another pure function rewrite its bytes at runtime as a side effect, while staying pure itself
13:37:45 <erisco> a function is what Haskell defines a function to be semantically
13:38:15 <MichaelBurge> erisco: Haskell, Haskell 98/2010, or GHC?
13:38:27 <erisco> did GHC change the semantics? I hope not
13:39:22 <MichaelBurge> erisco: I mean, there's unsafePerformIO, or pattern-matching on RealWorld#. Or the new Callstack implicit global variable.
13:39:40 <LordBrain> you could construct nonpure functions from pure ones using threading
13:39:55 <erisco> ah, so GHC may have added some extras
13:40:10 <LordBrain> but the type system has IO on to mark the fork functiosn
13:40:19 <zeitgeist7> Hello from Mauritius
13:40:40 <erisco> if we're talking about memory and CPUs it already is the wrong discussion. It is a good discussion for side effects but not for my definition of purity
13:40:40 <MichaelBurge> erisco: also, you define purity of a function. What about something like 'IO Integer' that isn't itself a function, but people say is non-pure?
13:40:53 <erisco> and I agree already that my definition of purity does not match what most people mean
13:41:19 <zeitgeist7> I am new to Haskell and I would like to ask a few questions. Is that the right channel?
13:42:04 <shachaf> Yes.
13:42:19 <zeitgeist7> thanks shachaf
13:42:20 <erisco> MichaelBurge, what people say about IO probably isn't the same as what I am saying about purity. I don't know how to address the question because I don't know what equality on IO is
13:42:21 <MichaelBurge> zeitgeist7: You're welcome here, and there's also #haskell-beginners
13:42:39 <zeitgeist7> I am having issues with cabal install hoogle
13:42:39 <shachaf> That channel also exists, but it's unaffiliated with this channel.
13:42:51 <erisco> if the Haskell spec gives a semantic for IO then I'd look there
13:42:51 <MichaelBurge> erisco: Equality on IO would be something like a equality of a list of AST statements?
13:42:51 <shachaf> The fact that it exists doesn't mean beginners shouldn't be here.
13:43:26 <jungletrain> hi
13:43:44 <zeitgeist7> it is reporting some weird errors: int foo() {} ...reaches end of non-void function
13:43:58 <zeitgeist7> so clearly some C thingy going on here
13:44:34 <zeitgeist7> I am running on Mac OS X El Capitan
13:44:55 <zeitgeist7> anybody else having the same issues?
13:45:17 <erisco> the meat of what I'm doing is comparing equality as per Haskell semantics with user-defined equality via Eq instances
13:45:33 <zeitgeist7> problems with gcc?
13:45:43 <zeitgeist7> or clang
13:45:46 <erisco> and it seems to be a category theory discussion but I don't know much there
13:46:25 <MichaelBurge> erisco: That's the difference between intensional equality(built into the logic, allowing term substitution) with extensional equality(has an axiom, but no support in the logic)
13:48:21 <erisco> MichaelBurge, are you saying 2 and 1 + 1 are intensionally equal? I am not sure what is meant
13:48:55 <erisco> I am saying 2 and 1 + 1 are semantically (extensionally) equal, whereas I'd expect 1 + 1 to be intensionally equal to 1 + 1 and not 2
13:49:37 <erisco> the question is what semantics we are using, right? so I am comparing Haskell's semantics with other semantics we may choose as a user (such as sets)
13:49:38 <MichaelBurge> erisco: That depends on the exact setup. Sometimes 2+2 = 4 is the first nontrivial theorem along those lines, since 1+1 really is by definition.
13:50:12 <MichaelBurge> erisco: Other times, 1+1 = 2 isn't true purely by definition, so it counts as a theorem.
13:50:37 <erisco> okay, I understand that, so lets say 2 + 2 = 4 so we're not confused by definitional equality
13:50:51 <Cale_> and sometimes all equations of sums of constants are by definition, and you need a variable to make things intensionally distinct
13:51:42 <Cale_> It depends on exactly what relation definitional/judgmental equality is.
13:51:50 <dolio> I don't think intensional vs. extensional is the right line to be drawing about that.
13:52:32 <Cale_> Yeah, it probably deserves a different name
13:53:32 <dolio> Also there are grades of intensionality. You may choose to include computation in 'intensional equality' or not.
13:54:20 <dolio> Most things do.
13:54:46 <Cale_> erisco: Even in intensional type theories, you will typically have 2 + 2 = 4 as a judgment, and not just something like p : Id Nat (2+2) 4, which is why you'll be able to typecheck refl : Id Nat (2+2) 4 in most systems
13:57:06 <dolio> Also you may choose to include 'non-computational' axioms in 'intensional equality' or not.
13:57:08 <dolio> Like eta.
13:58:31 <MichaelBurge> erisco: How about 'f x :: Int -> Int = deterministic_malloc(x)', where deterministic_malloc allocates 1 byte of memory the first time it is called and returns the same address every call after 
13:58:40 <adarqui> hm. is there any way I could do something like, type Tuple a b = (a, b) .. yet still use it like: blah = Tuple 1 2 ? basically a type synonym but called using the Tuple constructor? sounds weird but wondering if there's any magic like that, via a language extensions etc.. right now i'm using a function call tuple instead, which is probably the obvious way to go, since I don't want a new type introduced
13:58:52 <MichaelBurge> erisco: Two program runs could have different results, but the results would be consistent within a program
13:59:30 <MichaelBurge> erisco: The actual address would depend on the history of the system heap, the first time.
14:01:22 <MichaelBurge> erisco: 'x' could probably be better named 'byteId' in that example. So people would commonly call 'deterministic_malloc 0' to get an address for object 0.
14:02:25 <erisco> I think deterministic_malloc is dubious to begin with because what does it mean? You've explained what it does but I don't know what it is
14:02:58 * hackagebot async-dejafu 0.1.2.1 - Run MonadConc operations asynchronously and wait for their results.  https://hackage.haskell.org/package/async-dejafu-0.1.2.1 (barrucadu)
14:03:59 <MichaelBurge> erisco: deterministic_malloc x = unsafePerformIO $ do { check if x is in the cache; if so, return cache[x]; else return (cache[x] = malloc(1); }
14:04:30 <erisco> that begets the question of what is unsafePerformIO?
14:04:53 * erisco trolls the logicians
14:05:14 <MichaelBurge> erisco: It's in the Haskell standard, so it's included as part of Haskell semantics, which you claim to be using?
14:05:22 <dolio> No, it isn't.
14:07:53 <Zemyla> Huh, so I did find a Comonad instance for newtype S a = S { find :: (a -> Bool) -> a }.
14:08:19 <geekosaur> unsafeLocalState is part of the FFI. if you read between the lines you could infer that it is an unsafePerformIO (but it's even more unsafe than unsafePerformIO, at least in ghc, unless used as documented)
14:08:37 <Zemyla> geekosaur: What is unsafeLocalState?
14:09:05 <dolio> It's unsafePerformIO, but it has completely unspecified behavior unless you use it in very narrow ways.
14:09:08 <geekosaur> documented use is for calling C functions that are known to actually be pure; you have to do the call in IO but you can use unsafeLocalState to make the result pure
14:09:49 <geekosaur> ...in ghc, it also skips some locking that is needed if you're actually running Haskell code with it, so you can get core dumps if you abuse it to run Haskell IO code
14:10:29 <erisco> something I aimed to prove was that ∀f∀x∀y x = y ⇒ f x == f y  where '=' is equivalence of the Haskell semantic and '==' is an equivalence defined as per Eq. Is there anything category theory can offer here? It seems like a categorical thing at a glance and I'd like to know more
14:11:29 <MichaelBurge> erisco: To be clear, do you mean 'Haskell' or do you mean one of the sublanguages that's been desugared and acts on primitives in a well-defined way?
14:12:00 <erisco> what is one of these sublanguages?
14:12:15 <MichaelBurge> erisco: Core, STG
14:12:21 <MichaelBurge> Cmm also counts, I guess
14:12:55 <tippenein> anyone know why stack docker pull automatically pulls fpco/stack-build ?
14:13:18 <MichaelBurge> erisco: System FC
14:13:27 <tippenein> is the image `base` in stack.yaml not the setting for that?
14:14:55 <dolio> What does 'f x == f y' mean in your specification? That it computes to True? Because there are some values where 'x == x' doesn't compute to True.
14:15:51 <erisco> MichaelBurge, I don't think any denotational semantics are part of the specification. You have to take a little leap of faith
14:16:04 <hpc> oh boy
14:16:14 <erisco> a leap of faith that there is an ad-hoc specification that we're tentatively agreeing to
14:16:15 <hpc> ghc is taking enough memory on this compile for youtube to stutter
14:16:56 <MichaelBurge> hpc: Check for big generic instances. I ran into that the other week. I think 8.0 fixes it.
14:16:59 <erisco> dolio, that is a great point! (I presume you're referring to ⊥)
14:17:11 <dolio> ⊥ is one, but there are others.
14:17:18 <hpc> MichaelBurge: it's not my package, but good to know it's being improved
14:17:22 <maerwald> http://lpaste.net/162063 I can't find this function, is it too specific?
14:17:24 <erisco> dolio, what others? I am interested
14:17:31 <dolio> NaN == NaN reduces to False, and infinite lists also run forever.
14:17:33 <MichaelBurge> hpc: You can work around it by cancelling and rebuilding, I think
14:18:13 <hpc> looks like i got past it
14:18:16 <hpc> it peaked at 2 gigs
14:18:48 <erisco> dolio, running on forever is ⊥, yes? and NaN == NaN being False demonstrates that some numeric instances of Eq do not abide by the laws you'd expect of equality (so I am discounting those. I assume == is an equivalence relation, otherwise it isn't really equality)
14:19:41 <dolio> Yes, running forever is ⊥. But the inputs are not ⊥, so you can't even get around it by saying you're excluding partially defined inputs.
14:21:15 <erisco> Indeed. Then I wonder if there is a way to repair what is meant by f x == f y
14:21:20 <hpc> having IO input be greater than bottom is what lets you write any real-world code in agda
14:22:25 <erisco> the simplest adaption might be that f x == f y = True ∨ f x == f y = ⊥
14:22:44 <dolio> There are of course also cases where 'x == x' is not even a valid expression by default, like where 'x' is a function.
14:22:59 * hackagebot reactivity 0.3.1.0 - An alternate implementation of push-pull FRP.  https://hackage.haskell.org/package/reactivity-0.3.1.0 (JamesCandy)
14:23:08 <erisco> I assume that == exists, otherwise it is a proposition about nothing
14:23:25 <dolio> Because == is about having a decision procedure for equality, not just about equality.
14:23:47 <erisco> Indeed. I addressed that point but deleted it somewhere in my revision
14:24:03 <erisco> so yes, == must exist and it must be an equivalence relation
14:24:04 <MichaelBurge> dolio: For functions, maybe f = g if lift f = lift g?
14:24:25 <MichaelBurge> sorry, f == g if lift f == lift g
14:24:30 <dolio> What's lift?
14:24:46 <dolio> Anyhow, you can't decide equality of functions in general.
14:24:58 <erisco> you cannot define == for functions in Haskell for all types
14:24:58 <MichaelBurge> dolio: It gets the AST of its input
14:25:40 <dolio> If you can get the AST of a function, you will be anti-extensional.
14:25:47 <erisco> if they are syntactically equal then sure, but that is a bit weak
14:26:07 <dolio> Also anti-computational, probably.
14:26:29 <dolio> I'm not even sure it makes sense to say that all functions have an associated AST, even.
14:28:19 <erisco> dolio, I think the mistake was using Bool, i.e. the result type of ==, which is not the same thing as the true and not-true of x = y
14:28:41 <erisco> I can compare Bool things with = though
14:29:51 <erisco> once you see that x == y :: Bool then you know that first of all it doesn't fit with x = y, but also ⊥ :: Bool
14:32:30 <erisco> dolio, do you agree with the revision   ∀f∀x∀y x = y ⇒ f x == f y = True ∨ f x == f y = ⊥   ? or am I too far in unchartered waters to comment
14:33:18 <dolio> I mean, that's a more sensible specification of (==). But there is still Double and Float, unfortunately.
14:33:46 <erisco> sure, but I am excluding definitions of == which are not equality relations
14:33:57 <erisco> but I'll make that explicit again
14:34:18 <dolio> Double and Float also have examples where 'x == y' but not 'x = y'.
14:34:45 <erisco> the other direction doesn't hold for many types
14:34:52 <erisco> an example I give is Data.Set
14:35:07 <erisco> I also give the silly type of Pair, and also a type called Spry
14:36:21 <dolio> Well, Data.Set at least doesn't let you distinguish things via its API, I think.
14:36:39 <erisco> that is part of what I am trying to say
14:37:02 <erisco> you can talk about purity as per Haskell semantics, but you can also talk about purity as per your own semantics
14:37:02 <dolio> It's an abstract type, so 'x = y' should take that into consideration, and I think that 'x == y' gives the right answer.
14:37:31 <erisco> the Haskell semantics aren't concerned with Data.Set being a set
14:39:45 <justin_beiber> hello
14:43:35 <erisco> dolio, I have added these corrections to my answer. Thanks!
14:43:46 <dolio> No problem.
14:44:37 <erisco> one of my main points is that purity is something you should be concerned about when you're defining your own semantics, because Haskell offers no help for you despite it being a pure language
14:45:09 <erisco> which is perhaps a surprising idea
14:58:00 * hackagebot propellor 3.0.3 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.0.3 (JoeyHess)
15:07:59 <Zemyla> Is there anything you can say about f if f is both a Monad and a Comonad, and join . duplicate == id?
15:08:00 * hackagebot Chart 1.7.1 - A library for generating 2D Charts and Plots  https://hackage.haskell.org/package/Chart-1.7.1 (TimDocker)
15:08:02 * hackagebot Chart-cairo 1.7.1 - Cairo backend for Charts.  https://hackage.haskell.org/package/Chart-cairo-1.7.1 (TimDocker)
15:08:04 * hackagebot monoidal-containers 0.1.2.5 - Containers with monoidal accumulation  https://hackage.haskell.org/package/monoidal-containers-0.1.2.5 (BenGamari)
15:08:06 * hackagebot Chart-diagrams 1.7.1 - Diagrams backend for Charts.  https://hackage.haskell.org/package/Chart-diagrams-1.7.1 (TimDocker)
15:13:00 * hackagebot total-map 0.0.5 - Finitely represented /total/ maps  https://hackage.haskell.org/package/total-map-0.0.5 (ConalElliott)
15:13:46 <erisco> you might suspect that is provable from the laws, do you think Zemyla?
15:17:05 <Zemyla> Well, if w is an idempotent monoid, then both (->) w and (,) w satisfy that law.
15:17:42 <erisco> is there a counter-example?
15:18:01 * hackagebot hw-succinct 0.0.0.10 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.10 (haskellworks)
15:22:30 <koz_> I get the feeling I'm not understanding Haskell's (or specifically, BasicPrelude's) numbers: http://paste.rel4tion.org/346
15:24:57 <lyxia> what's the problem
15:26:09 <stomper> so who's going to lambdaconf?
15:31:27 <Lovepon> Err
15:31:41 <Lovepon> cryptocipher's pq generation seems wrong.
15:32:04 <erisco> 13 People Who Are Going To Lambdacomf: One Will Shock You!
15:32:08 <Clint> Lovepon: you probably want to use cryptonite instead
15:32:18 <Lovepon> Clint: Checking.
15:32:59 <Lovepon> Also, I was looking at an outdated version. Woops.
15:37:03 <Lovepon> Clint: It's still "wrong"
15:37:15 <Lovepon> Clint: "For security purposes, the integers p and q should be chosen at random, and should be similar in magnitude but 'differ in length by a few digits'[2] to make factoring harder. Prime integers can be efficiently found using a primality test."
15:37:53 <Lovepon> "p <- generatePrime (8 * (size `div` 2))"
15:38:00 <Lovepon> "q <- generatePrime (8 * (size - (size `div` 2)))"
15:42:32 <Lovepon> Also, size + (size `mod` 2) ?
15:42:47 <EvanR> Lovepon: the only thing dumber than implementing your own crypto (without one of the limited licenses to be a badass issued by the internet) is attempting to fix someone elses crypto
15:43:02 <Lovepon> EvanR: Why?
15:43:18 <EvanR> thats a classic course of vulnerabilities 
15:43:22 <EvanR> source*
15:43:32 <Lovepon> EvanR: The fixing someone else's crypto part?
15:43:37 <EvanR> "its like that for a reason dammit" retroactive warning
15:44:30 <Lovepon> EvanR: I don't get how fixing someone else's crypto is dumb though.
15:44:39 <EvanR> maybe i should say "fixing"
15:44:46 <Lovepon> EvanR: Ah.
15:45:54 <Lovepon> EvanR: Hmmm
15:46:30 <koz_> I'm a bit confused how you actually create a RealFrac.
15:46:37 <EvanR> ask the author about the number of digits difference thing, because i trust wikipedia on crypto least of all
15:46:44 <koz_> Like, I just wanna represent a fraction.
15:47:13 <EvanR> > 2 % 6 
15:47:14 <lambdabot>  1 % 3
15:47:15 <EvanR> ?
15:47:19 <Lovepon> EvanR: It has a reference to I think is a paper by the authors themselves.
15:47:31 <EvanR> ask the author of the library youre fixing
15:47:42 <koz_> EvanR: So wait, is % an infix constructor for fractions?
15:47:52 <EvanR> no its a smart ctor
15:47:59 <koz_> EvanR: Ah, right.
15:48:04 <EvanR> :t 1 % 3
15:48:06 <lambdabot> Integral a => Ratio a
15:48:21 <EvanR> Rational = Ratio Integer
15:49:15 <Lovepon> EvanR: I'll go ask him when I have the time, thanks.
15:49:18 <koz_> EvanR: Where do I get % from?
15:49:25 <EvanR> Data.Ratio
15:49:29 <koz_> EvanR: Thanks!
15:49:40 <erisco> @hoogle (%)
15:49:41 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
15:50:31 <Lovepon> :t isPrime
15:50:33 <lambdabot>     Not in scope: ‘isPrime’
15:50:33 <lambdabot>     Perhaps you meant ‘isPrint’ (imported from Data.Char)
15:50:37 <Lovepon> Mmm
15:50:56 <EvanR> thats a non trivial question ;)
15:52:18 <Lovepon> EvanR: isPrime?
15:52:27 <EvanR> in general yeah
15:52:50 <koz_> Lovepon: To elaborate - there is a deterministic primality test, but it's quite slow.
15:53:01 <Lovepon> EvanR: Ah, I assumed that Data.Primes was imported.
15:53:02 * hackagebot hw-succinct 0.0.0.11 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.11 (haskellworks)
15:53:10 <EvanR> wheres Data.Primes from
15:53:53 <Lovepon> Oops, Data.Numbers.Primes
15:53:58 <Lovepon> https://hackage.haskell.org/package/primes-0.2.1.0/docs/Data-Numbers-Primes.html
15:54:03 <erisco> @hoogle Data.Primes
15:54:03 <lambdabot> package primes
15:54:03 <lambdabot> package MyPrimes
15:54:48 <EvanR> arithmoi also has prime tests
15:54:57 <EvanR> isPrime :: Integer -> Bool
15:55:00 <Lovepon> right
15:55:01 <EvanR> isCertifiedPrime :: Integer -> Bool
15:55:26 <Lovepon> EvanR: It has less deps though, so may be suitable for lambdabot.
15:55:51 <EvanR> yeah i hate deps
15:56:09 <EvanR> lets get monolithic
15:56:17 <Lovepon> lol
15:58:02 * hackagebot mainland-pretty 0.4.1.4 - Pretty printing designed for printing source code.  https://hackage.haskell.org/package/mainland-pretty-0.4.1.4 (GeoffreyMainland)
15:59:25 <Lovepon> :|
16:00:12 <erisco> wow can we have more of this? http://tomasp.net/coeffects/
16:00:20 <erisco> dead pieces of wood is right
16:00:42 <erisco> not thought I'd be opposed to an academic popup book
16:01:17 <erisco> not that I'd*
16:10:24 <EvanR> erisco: my microtubes presentation also had this context requirement in the type
16:11:09 <erisco> I am just lauding the presentation of the content
16:11:12 <EvanR> coeffects does have nice web2.0
16:12:44 <erisco> dynamic scoping sounds like a good idea with this system
16:14:48 <erisco> every program that integrates with various services (HTTP servers, databases, file systems, etc) has this bag of configuration it needs to pass around
16:15:14 <MichaelK> Can ScopedTypeVariables be used with unlifted types? i.e. something like `\(y :: State# RealWorld) -> y`?
16:15:15 <erisco> which is often solved in other languages with some mutable global state
16:15:24 <erisco> (and sometimes in Haskell too!)
16:15:25 <tobiasBo1> Hello,
16:15:37 <tobiasBo1> I have some troubles with Monad/IO :
16:15:54 <tobiasBo1> Here is a simple function I'm writing :
16:15:57 <tobiasBo1> http://paste.debian.net/613438
16:16:48 <tobiasBo1> I would like it to return a function () -> IO () in order to apply it later
16:17:25 <tobiasBo1> However I have an error on line "return ..." :     Could not deduce (Foldable IO) arising from a use of ‘mafonction’
16:17:39 <erisco> tobiasBo1, what do you mean by "apply it later"?
16:17:47 <lyxia> () -> IO () is really useless in haskell
16:18:06 <erisco> if you have written f : () -> IO () then this is as good as f () : IO ()
16:18:10 <EvanR> () -> IO () is isomorphic to IO ()
16:18:14 <EvanR> ignoring bottom
16:18:58 <lyxia> tobiasBo1: do you come from OCaml?
16:19:10 <erisco> tobiasBo1, IO side effects are executed as they are sequenced, not when you apply f to ()
16:19:21 <tobiasBo1> erisco: The idea is that I would like to send some notes to a midi piano, (via the send pitch function), and when I would like to stop the piano, I need to run another function, which is the one I would like to return
16:19:24 <EvanR> they arent executed when they are sequenced either
16:19:28 <tobiasBo1> lyxia: Yes I come from Ocaml ^^
16:19:45 <EvanR> > putChar 'a' >> putChar 'b'
16:19:46 <erisco> EvanR, when I say "as" I mean "according to how"
16:19:46 <lambdabot>  <IO ()>
16:19:55 <lyxia> the units and the French gave it away :)
16:21:10 <tobiasBo1> You mean that here the function would apply the IO during the "reading" of the function, and not return the function ?
16:21:19 <tobiasBo1> So what is the "Haskell" way to code this ?
16:21:49 <ski> tobiasBo1 : i suspect you want `mapM', not `map', there
16:22:17 <tobiasBo1> ski: Indeed
16:22:26 <tobiasBo1> Ow
16:22:27 <lyxia> tobiasBo1: what does send_one_pitch return
16:23:07 <tobiasBo1> lyxia: send_one_pitch return the function to run to stop playing the current pitch
16:23:17 <erisco> tobiasBo1, when you run your program it executes 'main' which has type 'IO ()'. You can assign whatever 'IO ()' term you want to main
16:23:42 <tobiasBo1> Here is my whole program if needed : http://paste.debian.net/614444
16:23:44 <amnn_> tobiasBo1, send_one_pitch appears to be returning thunks ( () -> x functions ) as ewll, right?
16:23:48 <amnn_> *well
16:24:04 <erisco> tobiasBo1, notice how main :: IO (), not main :: () -> IO ()
16:24:04 <tobiasBo1> amnn_: exactly
16:24:28 <amnn_> tobiasBo1 in that case, you want sequence
16:24:43 <EvanR> whats the ocaml version of IO (), ...    () -> () ?
16:24:47 <tobiasBo1> erisco: Yes, I never really understand why it's not () -> IO ()
16:24:53 <tobiasBo1> *understood
16:25:09 <erisco> tobiasBo1, putChar 'a' :: IO (), do you understand that?
16:25:31 <EvanR> tobiasBo1: effects arent executed as a side effect of function evaluation in haskell, since its a pure language, function evaluation has not much to do with IO or mutable variables or any of that
16:25:33 <amnn_> tobiasBo1, Haskell is a lazy language, so a value of type `IO ()` is merely the intention to perform the IO
16:25:51 <EvanR> function evaluation is more like math 
16:26:01 <tobiasBo1> Hum yes I think I'm getting it
16:26:24 <amnn_> you can compose intentions to perform IO together, by sequencing them (with >>, >>=, mapM, forM, sequence, et cetera)
16:26:28 <EvanR> the IO data type is a way to create scripts to be executed by the runtime later
16:26:39 <EvanR> you can combine IO actions in many ways
16:26:46 <EvanR> and store them in containers for later use
16:27:37 <amnn_> and in the end you just have one big intent to perform all those IO's, which can eventually be run (most probably by being put somewhere in the `main :: IO ()` action that will be run when the program is run.
16:27:44 <tobiasBo1> > () -> ()
16:27:45 <lambdabot>  <hint>:1:4: parse error on input ‘->’
16:27:50 <EvanR> :t () -> ()
16:27:52 <lambdabot> parse error on input ‘->’
16:27:56 <EvanR> doh
16:28:01 <erisco> :k () -> ()
16:28:01 <EvanR> :k () -> ()
16:28:02 <lambdabot> *
16:28:02 <lambdabot> *
16:28:13 <EvanR> probably unenlightening ;)
16:28:26 <EvanR> later that will output `Type' instead of `*'
16:29:57 <amnn_> tobiasBo1, like ski suggested, you most likely want to replace this entire function definition with just `mapM_ (send_one_pitch h conn) pitchs`
16:30:14 <amnn_> the takeaway here is that Haskell is managing those thunks for you
16:31:41 <amnn_> (send_one_pitch will also have to be updated so that it doesn't wrap its `IO` actions in thunks too)
16:31:42 <tobiasBo1> amnn_: Entire ?
16:32:07 <erisco> Maybe this example is enlightening? main = const (return ()) (printChar 'a')  *shrug*
16:32:14 <EvanR> is () -> () really called thunks ?
16:32:39 <amnn_> tobiasBo1, that's right: `send_pitchs h conn pitchs = mapM_ (send_one_pitch h conn) pitchs`
16:33:07 <tobiasBo1> amnn_: But here there isn't any result anymore no ?
16:33:22 <EvanR> :t mapM_
16:33:23 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
16:33:32 <amnn_> tobiasBo1 the return value of that is IO ()
16:33:32 <erisco> I guess Haskell's lazy evaluation muddies that example
16:33:47 <EvanR> erisco: what is that an example of?
16:34:00 <tobiasBo1> amnn_: Yes, but me I would like to return a fonction that stops the piano that I can call when needed
16:34:13 <erisco> EvanR, well if you thought applying 'a' to printChar printed a character then it should illuminate that it doesn't
16:34:40 <slaterr> tobiasBo1, but () -> IO () function does nothing that IO () action couldn't do
16:34:51 <tobiasBo1> in short, send_pitchs should send the notes to the piano, and return a function to quiet the piano later
16:34:51 <ski> EvanR : plain OCaml version would be `unit -> unit', yes
16:35:04 <EvanR> tobiasBo1: so you want -> IO (IO ())
16:35:16 <EvanR> when executed it gives an IO action that stops the piano (not executed yet)
16:35:23 <MichaelK> IO finally made the sense to me when I found its definition: `newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))`, so `IO a` is a function taking the "real world" state, modifying it, and returning some result. (Maybe this isn't helpful though..)
16:35:41 <EvanR> MichaelK: thats actually a horrible way to explain it, imo
16:36:08 <EvanR> because its neither based on any principle or on any sane implementation strategy ;)
16:36:09 <amnn_> EvanR, () -> () in an impure, strict language would just be a procedure called for side effects. I was calling () -> IO () a thunk because it was simulating the lazy creation of an IO action.
16:36:45 <tobiasBo1> EvanR: Maybe indeed I'm looking for IO (IO ())
16:36:50 <EvanR> yeah
16:37:16 <EvanR> a cleanup action
16:37:20 <MichaelK> EvanR: fair enough
16:37:31 <tobiasBo1> exactly
16:38:13 <erisco> EvanR, it is based on the principle of satisfying purity
16:38:18 <amnn_> tobiasBo1, does that cleanup action get called only once?
16:38:26 <Lovepon> > 5527939700884757 `mod` (2^32)
16:38:28 <lambdabot>  3258320149
16:38:31 <erisco> EvanR, the "same arguments give same answers" version of purity
16:38:41 <EvanR> erisco: in this case, its not. the code involving the real world token is executing in an impure language
16:38:54 <EvanR> the token is there to ensure side effect ordering
16:38:55 <tobiasBo1> amnn_: It should be called only once yes
16:39:16 <erisco> EvanR, you mean the code hidden in, say, putChar?
16:39:31 <EvanR> the code hidden in main
16:40:02 <MichaelK> EvanR: you mean FC, Core, or C-- ?
16:40:05 <erisco> EvanR, I don't follow
16:40:10 <EvanR> haskell is really good at giving you something that can be understood without understanding the implementation
16:40:23 <EvanR> because the implementation is so insane
16:40:25 <amnn_> tobiasBo1, it may be worth thinking about making the interface reflect that
16:40:33 <amnn_> ...maybe later though
16:40:45 <tobiasBo1> amnn_: Any idea to do so ?
16:41:01 <MichaelK> :t join
16:41:02 <lambdabot> Monad m => m (m a) -> m a
16:41:03 <erisco> EvanR, I understanding the ordering part of it
16:41:21 <EvanR> erisco: core works because executing side effects as part of evaluation
16:41:21 <amnn_> well originally I was thinking you could have a function that took as a parameter, an IO action to perform between starting and stopping the piano notes that you just sent
16:41:25 <tobiasBo1> How can I force a thunk (IO ()) to be run ?
16:41:44 <amnn_> but that only allows "well bracketed" songs to be played
16:41:55 <EvanR> so i dont think its a terribly enlightening way to explain how haskell works
16:42:35 <amnn_> tobiasBo1, if you inspect an IO action at the ghci prompt, it will be run
16:42:45 <slaterr> main = do { stop <- playNote note; stop; return () }
16:42:49 <erisco> EvanR, I am still not sure I follow. I agree they are side effects happening, but is "same arguments give same answers" violated?
16:42:59 <amnn_> likewise, if you put it in your main IO action, it will be run when your program is run.
16:43:11 <slaterr> don't even need return (), assuming stop returns IO ()
16:43:23 <EvanR> tobiasBo1: you dont usually think of it like that. if its sequenced into the main action it will run. if you want to convert IO (IO ()) into one IO () that executes both, use join :: m (m a) -> m a
16:43:32 <EvanR> which you probably dont in this case
16:43:38 <tobiasBo1> slaterr: If I do : "main = do { stop <- playNote note; stop; stop; return ()}", will stop be play only once ?
16:43:43 <EvanR> erisco: in an impure language yes
16:43:54 <MichaelK> be well, all
16:44:07 <erisco> EvanR, what is the example of this?
16:44:59 <slaterr> tobiasBo1 executing main will execute stop twice
16:45:29 <EvanR> case currentTime () of t1 -> case currentTime () of t2 -> (t1, t2)
16:45:42 <Boomerang> :t replicateM
16:45:44 <lambdabot> Monad m => Int -> m a -> m [a]
16:46:30 <tobiasBo1> slaterr: Hum... So now I don't understand anymore why I would need IO (IO ()) ^^'
16:46:59 <amnn_> tobiasBo1, the type of playNote is IO (IO ())
16:47:04 <EvanR> tobiasBo1: i assume you want one action to start playing a note, then get back an action to stop that note. thats the IO (IO ()) pattern
16:47:19 <amnn_> sorry, it's `Note -> IO (IO ())`
16:47:19 <EvanR> you can defer stopping the note to any time you want
16:48:11 <EvanR> stop <- play 'C'
16:48:12 <EvanR> ...
16:48:14 <EvanR> stop
16:48:36 <tobiasBo1> Hum yes I see, I thought that the return must be of type (IO ()), so playNote would be Note -> IO (IO (IO ()))
16:48:41 <tobiasBo1> sorry ^^'
16:48:55 <EvanR> IO (IO (IO ())) is too much i think
16:49:19 <EvanR> its an io action that when executed returns an io action that when executed returns ()
16:49:34 <EvanR> oops i cant even get that right
16:49:48 <erisco> not enough layers on your onion
16:49:58 <EvanR> Fix IO
16:50:01 <EvanR> done
16:50:16 <amnn_> if whatever you are sending your notes to doesn't like being stopped twice, you can make sure the notes are only stopped once in the `stop` action, (example forthcoming).
16:50:35 <EvanR> its midi so stopping one note twice isnt a bad thing
16:50:45 <EvanR> assuming you actually want to stop the note
16:51:44 <erisco> EvanR, it seems to me like you didn't apply currentTime to enough arguments. Where is RealWorld?
16:53:04 * hackagebot concurrent-output 1.7.5 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.7.5 (JoeyHess)
16:53:21 <EvanR> exactly how would passing in real world make it more correct?
16:53:24 <amnn_> erisco, EvanR, I think you two are having slightly different conversations.
16:53:47 <EvanR> time is not involved in this language
16:54:07 <EvanR> unlike my current project! ;)
16:54:20 <erisco> amnn_, conversations are often like that =\
16:55:05 <amnn_> in any case, the "IO is kind of like State" is not *all* bad, it is a fair analogy if all you are looking for is a mental model.
16:55:15 <EvanR> the RealWorld hack is a thing to get effects ordering right, not a way to get effects to work or work right in themselves
16:55:30 <EvanR> amnn_: there are much better models for IO
16:55:53 <Lovepon> EvanR: I'm interested.
16:56:13 <erisco> it does that, but it also satisfies "same arguments give same answers" (that's all I'm saying)
16:56:16 <EvanR> heres one https://wiki.haskell.org/IO_Semantics
16:56:27 <chaoxu> hi guys, in ghci, you can type :k Int->Int and get *, but if you type :k a->a, you get a error instead of *->*. How to get around this?
16:56:29 <tobiasBo1> I works, than you for your help everybody, I understood some nice things, thank you ! By the way here is my final code, if you see some improvement in styling I'm intersted in it : http://paste.debian.net/618259. Thank you again !
16:56:36 <EvanR> erisco: not really, where are you getting these real world values?
16:56:38 <amnn_> the issue with mental models though, is that what is best for a particular person depends on not only the thing being modelled, but the person's existing level of understanding. There's no use in a model going over somebody's head.
16:57:20 <EvanR> amnn_: personally i have never been at a level of understanding where GHC's real world thing made any sense, so im biased
16:57:24 <EvanR> or not at that level yet
16:58:20 <amnn_> ironically, level is perhaps a bad model for what I meant :P
16:58:40 <amnn_> maybe "existing neighbourhood of understanding" is better
16:58:46 <Lovepon> EvanR: Thanks.
17:00:42 <chaoxu> hi guys, is it possible to type in ghci sth like :k a->a and get *->*?
17:00:57 <erisco> EvanR, that's a fair objection, I don't know. If you pretend the guts of putChar and friends don't matter, and are only concerned about >>=, then the make-believe game is that no RealWorld value is equal to one before (I think you know this angle already)
17:01:36 <amnn_> :k (->)
17:01:37 <lambdabot> * -> * -> *
17:01:41 <amnn_> chaoxu, like so ^ ?
17:01:47 <erisco> which is a linear type something something but that is the end of my understanding
17:01:55 <slaterr> tobiasBo1 give this a try, same concept.  http://lpaste.net/162071
17:02:18 <slaterr> tobiasBo1 in ghci type stop <- flood "hi";  then type stop
17:02:31 <chaoxu> amnn_: yea, but I'd like to provide type variable like (forall x. x->a)->a
17:02:36 <EvanR> erisco: you kind of dont need any make believe if you say that IO is an abstract type for building programs from IO primitives and combining them
17:02:42 <chaoxu> amnn_: or just a->a
17:02:47 <EvanR> and that some other thing executes it
17:03:18 <amnn_> chaoxu, the kind of (a -> a) is *, because a is implicitly universally quantified
17:03:40 <EvanR> you dont get any good semantics, but at least its not misleading
17:03:56 <EvanR> basically falling back to the syntactic only intepretation
17:03:58 <chaoxu> amnn_: right, just wondering whether I can use :k to ask kind for this kind of type with argument
17:04:11 <chaoxu> amnn_: one way is to "type End a = a->a", then ":k End"
17:04:20 <chaoxu> amnn_: but it requires more typing
17:04:22 <amnn_> right, that was that I was going to suggest
17:05:22 <tobiasBo1> slaterr: Great thank you ! It's funny, I was playing with forkIO just before, and the killTread is nice for me !
17:05:36 <amnn_> unfortunately, haskell doesn't have a notion of "anonymous type constructor" which is what you're looking for
17:06:07 <chaoxu> amnn_: got it, thanks
17:06:09 <amnn_> tobiasBo1, http://lpaste.net/162072
17:06:54 <amnn_> you probably don't need that, but that is how you would make sure the stop action was only performed once, regardless of how many times the `stop` action is sequenced in.
17:07:18 <tobiasBo1> amnn_: It's not possible to do that without reference ?
17:07:36 <tobiasBo1> And what'es the better, IOref, Mref, other ?
17:07:54 <amnn_> well you will need to store the state of whether stop has been called before somewhere
17:07:55 <EvanR> TVar is best var
17:08:25 <nitrix> TVaifu
17:10:19 <tobiasBo1> EvanR: Here they talks about MVar, what's the difference : https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html ?
17:11:14 <amnn_> tobiasBo1, if you think there are going to be multiple threads accessing this reference, then yes, TVar is the way to go. If you are able to encapsulate your usage of state operations into one extensionally pure function, then use STRef, if you want to abstract over what kind of reference you have (this seems unlikely to me, unless you're writing some sort of library code), then use MRef, and otherwise, when in IO, use
17:11:14 <amnn_>  IORef.
17:12:41 <arahael> amnn_: I notice that there's nothing about MVar there.
17:12:55 <arahael> I guess TVar's replaced MVars?
17:13:41 <tobiasBo1> Thank you !
17:13:54 <erisco> EvanR, I don't know if it says anything the other explanation doesn't (or vice versa)
17:14:22 <slaterr> now try to write something like this that does all the IORef managing for you.  once :: IO () -> IO (IO ())
17:15:32 <amnn_> arahael, I'll be honest, I don't know the nuances of the two, but they both appear to be thread-safe.
17:16:44 <arahael> Fair enough.
17:18:18 <amnn_> `once` could be a candidate for implementation using MRef: `once :: HasMRef m => m () -> m (m ())`
17:20:13 <slaterr> maybe even make it `m a' instead of `m ()' and have it just return the yielded value on all subsequent calls
17:21:01 <ski> arahael : iirc, there's also `TMVar'
17:21:36 <amnn_> can confirm: https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM-TMVar.html
17:22:00 <erisco> EvanR, oh I should have read more carefully. The way they map `IO a` to a tree was not how I was expecting
17:23:13 <erisco> so they are describing a nondeterministic program, and executing the program is a matter of choosing one path from an initial to terminal state
17:24:10 <amnn_> erisco, no, instances of IOTree are deterministic programs
17:24:11 <erisco> that is quite a nice idea
17:24:55 <erisco> sorry you're right
17:25:21 <amnn_> it is a nice idea though, closely related to free monads
17:25:42 <chaoxu> hi guys, can you turn on ExistentialQuantification in ghci?
17:26:13 <amnn_> IOTree isn't quite a free monad because it deals with some of the sequencing for you (in the form of r -> IO a functions)
17:26:44 <slaterr> I like this explanation of IO http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/  .same mental model of IO being a tree, but you can compile and test the code and even print the tree. 
17:27:28 <erisco> I have been a fan of making more things be data… I made this weird thing a few years ago https://github.com/erisco/haskell-decision/blob/master/src/decision.hs
17:27:34 <ski> amnn_ : which `IOTree' is that ?
17:27:52 <amnn_> ski, the one in the IO Semantics wiki: https://wiki.haskell.org/IO_Semantics
17:28:17 <erisco> the idea was to rewrite algorithms as a tree that represented all possible decisions
17:28:50 <erisco> so for example you'd rewrite sortBy so that instead of taking a comparison function it instead produces the tree for all possible decisions the comparison function could have made
17:29:04 <erisco> which is equivalent, but you can then do things with the tree
17:29:21 <erisco> for example, if you take the leaves of the tree then you have every permutation of the input
17:29:43 <erisco> so in that sense sorting a list and finding all permutations is the same thing! :)
17:30:09 <erisco> there are many functions which meld together when you look at them this way
17:30:09 <ski> erisco : using `Show' for pretty-printing :(
17:30:43 <amnn_> erisco, well indeed, a non-deterministic program for sorting would just divine the correct permutation, and verify it
17:30:48 <erisco> ski, it is more convenient on ghci, which is the only place this is being executed
17:31:27 <erisco> amnn_, the "decision trees" I made are deterministic, I was just wrong when I said non-deterministic
17:31:33 <ski> also those record fields are partial
17:31:45 <ski> (and not used in the remainder of the code in that module)
17:32:15 <erisco> ski, what do you mean? also keep in mind that it wasn't designed to be amazing Haskell code :P
17:32:30 <erisco> hell I wrote this   up2 init f = up (\r -> (undefined, init r)) (\a (_, c1) (_, c2) -> (a, f a c1 c2))
17:33:09 <amnn_> erisco, in the first instance the IOTrees represented deterministic computations, but if you build a decision tree, like you suggest, then you can consider it to be a search tree that a program may non-deterministically search (simultaneously searching all the paths at once) in order to find the correct permutation
17:33:30 <ski> erisco : i would just have said `data Decision a r = Branch (Decision a r) (Decision a r) a | Return r'
17:33:36 <amnn_> (the correct permutation being the sorted permutation)
17:34:06 <erisco> I am fine with partial record fields
17:34:11 <amnn_> anywho, I am off!
17:35:15 <erisco> I never got around to rewriting sortBy because it seemed more difficult at the time
17:36:03 <ski> is `a' meant to compute a `Bool' to make the decision about the branch to take ?
17:36:22 <erisco> you can see how I use it later in the module
17:37:00 <erisco> span :: (a -> Bool) -> [a] -> ([a],[a])  so   dspan :: [a] -> Decision a ([a], [a]);   groupBy :: (a -> a -> Bool) -> [a] -> [[a]]  so  dgroupBy :: [a] -> Decision (a, a) [[a]]
17:38:12 <erisco> then I also define a mess of other functions such as up, down, and look so you can poke around the tree and make decisions you otherwise couldn't with the originals
17:38:41 <erisco> because with the tree you can use other branches to influence your choice, or descendants, or whatever you'd like
17:38:51 <ski> your `s -> Cont s a r' looks like `StateT s (Either r) a'
17:39:58 <erisco> sure you could probably rewrite it all in a much better way. It is something I wrote years ago and would rewrite completely if I wanted to revive it
17:40:17 <ski> erisco : oh, i think i see. you want to make an explicit tree representing external "oracle" decisions an algorithm will have to make ?
17:41:11 <erisco> yes that's right. Absent of the oracle it simply offers all possible choices
17:41:18 * ski nods
17:42:06 <ski> so, it would be possible to generalize `Decision a r' into `Decision a Bool r'
17:42:27 <erisco> that seems like a reasonable idea
17:42:27 <ski> where `Bool' is the type of replies from the oracle, and `a' is the type of queries to it
17:43:03 * ski once did something like this, but also involving `IO', for CGI programming
17:43:41 <erisco> it made me start thinking about always programming like this, because it seems like it is more powerful
17:44:09 <ski> the idea was to, when a form generated by CGI got filled in and posted, the engine would fastforward the program from the start to the place where it stopped last time (emitting the CGI stuff), and then continuing onward from there
17:44:48 <ski> and earlier `IO' requests would not be redone, but cached (either in the server, or on the client)
17:45:53 <erisco> your entire program could ostensibly be a decision tree, and the oracle is input from the environment
17:46:00 <erisco> which is why I thought it was related
17:46:49 <ski> hm, there's also some package which i think has a similar idea, but i can't recall the name of it atm
17:47:44 <ski> the idea is that you use a custom data type (usually a GADT, i think), to express the type of possible requests that you can make, annotated with the response type
17:48:48 <ski> and you can program in your monad as if these are you querying the user. while the monad handles running your computation up to the first such request, and then presents that to the user running the monadic action
17:57:47 <tobiasBo1> A little question : I did a program with two threads (forkIO), but when they write something with putstrln, the output are mixed ! For example if one thread sends "AAAA" and the second sends "BBBB", the output seen will look like "ABABAB"
17:58:30 <erisco> should that be surprising?
17:58:42 <erisco> what did you expect as output tobiasBo1?
17:59:36 <tobiasBo1> erisco: No, it's not that surprising, but I'm wondering if it's not possible, with buffering or anything else to send the whole string in one single step
17:59:51 <tobiasBo1> like "atomically" but for putStrLn ^^
18:00:47 * tobiasBo1 thinks that Haskell deals with threads in a really easy to use way !
18:03:11 <geekosaur> I think the usual solution is to have a write thread and pass stuff to it via a (T)Chan
18:03:55 <tobiasBo1> geekosaur: Ok, thank you !
18:09:33 <hpc> tobiasBo1: a more general form of that tip, (T)Chans and (T)(M)Vars are probably the best inter-thread communication mechanism of all time
18:09:51 <hpc> tobiasBo1: and the limit on threads you can spawn with ghc is decided only by how much memory you have
18:10:29 <hpc> it's not unheard of for a program to spawn a million threads at once, wait for them to finish, and combine the results
18:15:40 <Eduard_Munteanu> tobiasBo1, usually stdout is line-buffered and you won't get things mixed on the same line unless you exceed the buffer length.
18:17:32 <tobiasBo1> Eduard_Munteanu: Maybe emacs shell is not like that ?
18:17:53 <Eduard_Munteanu> Hm, could be.
18:17:53 <tobiasBo1> hpc: Interesting... And are both forkIO/forkOS powerfull ?
18:18:16 <tobiasBo1> forkIO cannot use the power of several cores right ?
18:19:07 <Eduard_Munteanu> tobiasBo1, forkIO is what you normally want, and it can
18:20:05 <exio4> tobiasBo1: it can with -threaded
18:20:12 <tobiasBo1> Cause I tried to use ps aux to see the treads and I don't see any difference when the thread is run and when he is not
18:20:22 <tobiasBo1> Hum ok
18:21:01 <Eduard_Munteanu> forkOS is for odd cases when you require an OS thread, though not for performance reasons.
18:22:09 <tobiasBo1> Ok. And I think that the threads created with forkIO aren't POSIX threads ?
18:22:20 <exio4> they're green threads
18:22:39 <Eduard_Munteanu> Yeah, they're smaller than POSIX threads and the kernel doesn't know about them.
18:22:54 <Eduard_Munteanu> Entirely userspace thing.
18:24:27 <Eduard_Munteanu> Green threads do get multiplexed onto (a smaller set of) POSIX threads with -threaded, though.
18:25:13 <tobiasBo1> Ok... It looks like a bit magic that -threaded can react like that, thank you !
18:26:01 <geekosaur> its standard N:M threading. java does it too
18:26:05 <Eduard_Munteanu> Well, that's why I said forkIO is usually what you want, you do get the benefits of multiple cores.
18:27:07 <exio4> geekosaur: it still does? I thought they didn't do that anymore
18:28:00 <geekosaur> huh. maybe they should settle on a thread model sometime :)
18:28:22 <geekosaur> they started out with only green threads and the main OS thread, then they went to N:M, ...
18:29:39 <geekosaur> (java:write once, rewrite when they change the thread model out from under you yet again)
18:49:43 <Gurkenglas__> Control.Comonad.Cofree should have to inits what duplicate is to tails
18:50:28 <edwardk> Gurkenglas__: iirc the streams package has causal and anticausal streams
18:51:07 <edwardk> for one of them duplicate is that inits-like operation
19:26:32 <MichaelK> Hi, is it possible to do something like `\f (x :: (# a, b #)) -> f x`? I get an "Expecting a lifted type, but ‘(# a, b #)’ is unlifted" error, which I haven't been able to figure out
19:38:09 * hackagebot active 0.2.0.9 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.9 (bergey)
19:38:11 * hackagebot diagrams-core 1.3.0.7 - Core libraries for diagrams EDSL  https://hackage.haskell.org/package/diagrams-core-1.3.0.7 (bergey)
19:38:13 * hackagebot diagrams-lib 1.3.1.2 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.1.2 (bergey)
19:38:15 * hackagebot force-layout 0.4.0.4 - Simple force-directed layout  https://hackage.haskell.org/package/force-layout-0.4.0.4 (bergey)
19:38:17 * hackagebot diagrams-contrib 1.3.0.10 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.3.0.10 (bergey)
19:43:19 * hackagebot diagrams-svg 1.4.0.1 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.4.0.1 (bergey)
19:43:21 * hackagebot diagrams-cairo 1.3.0.6 - Cairo backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-cairo-1.3.0.6 (bergey)
19:43:23 * hackagebot diagrams-postscript 1.3.0.5 - Postscript backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-postscript-1.3.0.5 (bergey)
19:43:25 * hackagebot diagrams-rasterific 1.3.1.6 - Rasterific backend for diagrams.  https://hackage.haskell.org/package/diagrams-rasterific-1.3.1.6 (bergey)
19:43:27 * hackagebot diagrams-canvas 1.3.0.4 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-canvas-1.3.0.4 (bergey)
19:46:13 <ski> @type let foo :: ((# a,b #) -> c) -> (# a,b #) -> c; foo f x = f x in foo  -- MichaelK ?
19:46:14 <lambdabot> ((# a, b #) -> c) -> (# a, b #) -> c
19:46:36 <ski> @type let foo :: ((# a,b #) -> c) -> (# a,b #) -> c; foo = \f x -> f x in foo
19:46:38 <lambdabot> ((# a, b #) -> c) -> (# a, b #) -> c
19:48:53 * hackagebot diagrams-html5 1.3.0.5 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-html5-1.3.0.5 (bergey)
20:38:50 <montanonic> Agda.Utils has so many good things that I wish came default in the different Preludes (common sense things like maybeLeft :: Either a b -> Maybe a). I'm considering whipping together a package containing them.
20:39:39 <Clint> montanonic: https://hackage.haskell.org/package/errors-2.1.0/docs/Control-Error-Util.html
20:40:20 <montanonic> Clint: is still missing Either a b -> Maybe a, among other things. I wouldn't have gone all the way to Agda's utilities otherwise
20:44:01 <Clint> montanonic: hush . flipEither
21:12:44 <dolio> @type preview _Left
21:12:45 <lambdabot> MonadReader (Either a c) m => m (Maybe a)
21:20:03 <hackrilege> its usually pretty quiet just now, but if anyone is online and could help me with the bug at the bottom of this paste that would be swell http://lpaste.net/162079
21:25:23 <montanonic> hackrilege: so, this probably isn't very helpful, but after looking at it for a while, all I can say is that GHC is complaining that the type is polymorphic, when it knows that 'q' has to be Free instead.
21:25:38 <hackrilege> i dont understand this error line;
21:25:39 <hackrilege> `q' is a rigid type variable bound by
21:25:39 <hackrilege>           the type signature for
21:25:39 <hackrilege>             toZipper :: Stack [] => q [] a -> ZipperN [] a
21:25:45 <montanonic> hackrilege: try making q 'Free'. If that works, then figure out how to make it more polymorphic
21:26:16 <hackrilege> that works
21:26:38 <montanonic> hackrilege: so the problem is that you're saying 'q' is polymorphic, but by the way you define the functions, it actually isn't
21:26:40 <hackrilege> so how do i make it more polymorphic? i guess i add a forall q. somewhere?
21:26:54 <hackrilege> isnt it?
21:27:20 <hackrilege> well i guess not
21:27:31 <hackrilege> so how do i make it so? is there a way?
21:27:55 <montanonic> hackrilege: you could try that, but the issue is that Haskell only sees Free where there is 'q'
21:28:06 <hackrilege> z is more polymorphic than q atm...
21:28:18 <montanonic> hackrilege: you're doing something that uses Free, I just can't find it myself
21:28:28 <hackrilege> oh
21:28:32 <hackrilege> thats ListN
21:28:48 <hackrilege> > type ListN = Free []
21:28:52 <lambdabot>  <hint>:1:1: parse error on input ‘type’
21:29:07 <hackrilege> sorry lambdabot
21:31:15 <hackrilege> ListN is in natural correspondence with ZipperN, the Zipable instance relates the two, i would expect different shaped Zipable containers to map to other structures 'q' provided with [] a as parameters
21:31:29 <montanonic> hackrilege: that would be your problem. Also, though I've basically never really used them myself and so could be totally off, I'm a bit skeptical at how useful it is for 'Zippable' to be MultiParameter
21:32:02 <ryanpcmcquen> is `reverse (3 : reverse [1, 2])` faster than `[1, 2] ++ [3]` on really long lists?
21:33:01 <hackrilege> for instance, ZipperN uses Stacks to represent a Free []
21:33:02 <hackrilege> nope
21:33:09 <hackrilege> Stack s => Free s
21:33:12 <hackrilege> ...
21:33:20 <montanonic> err, sorry, that's not what I meant exactly, but rather: at the ZipperN instance for zippable having a concrete value (the []), as opposed to designing it so that it's more polymorphic, and would work on something like, say, Functor+Monoid, instead of just list
21:34:03 <montanonic> Now I don't know if you *can* actually make that second term more polymorphic, but if you could, it would definitely be an improvement
21:34:10 <hackrilege> it can be polymorphic in Stack s
21:34:34 <hackrilege> but the problem is that the first term, the q, must be polymorphic
21:35:07 <hackrilege> the Stack s <-> [] correspondence worksok
21:35:35 <montanonic> I wish I could help more, but this is a bit out of my league of comfort. Nicely written code though, it definitely looks good.
21:35:37 <srhb> ryanpcmcquen: Which part are you making longer?
21:35:47 <hackrilege> Stack is both MonadPlus and Foldable, as well as having pull, or complus <- new concept?
21:36:08 <ryanpcmcquen> srhb: the `[1, 2]` list
21:36:45 <montanonic> ryanpcmcquen: if the earlier list is longer, ++ will be faster, I believe
21:37:03 <srhb> ryanpcmcquen: So very long list ++ [one element] ?
21:37:10 <srhb> In that case it's just a tiny constant factor.
21:37:14 <montanonic> actually, it seems like in both cases ++ would be faster, but I may be mistaken
21:37:42 <hackrilege> monatonic, how can i phrase the question i need to ask so that others can help?
21:38:12 <hackrilege> im glad you understand the error about polymorphism, it would be a shame to lose that input
21:38:26 <ryanpcmcquen> ah, i also think it reads better as ++, so that is good to know
21:38:33 <ryanpcmcquen> thanks!
21:38:46 <montanonic> hackrilege: I wouldn't have the slightest idea. And I figured out the polymorphism error because it comes up all over the place, even in very basic code
21:39:21 <hackrilege> seems that its easier to make all but the first parameter polymorphic...
21:39:31 <hackrilege> i dont get why, or how to relieve this error
21:39:36 <srhb> ryanpcmcquen: Unless you're implying that the first version actually finds the last element on every recursion, in that case it's massively slower.
21:40:03 <srhb> ryanpcmcquen: It's hard to read expressions as definitions and try to figure out what they mean :-P
21:40:45 <hackrilege> i think i could get round it by defining a blank class of 3 parameters, and then placing this in the constraint
21:41:03 <hackrilege> BlankClass q => q a b -> etc
21:41:12 <montanonic> hackrilege: I've never gotten tangled up with types or classes as complex as you have there, so I really wouldn't know
21:41:29 <montanonic> but good luck hackrilege 
21:41:54 <hackrilege> hmm when someone more experienced than me is confused by my code that means i have swam out into shark infested waters!
21:42:02 <hackrilege> thanks monatonic
21:43:57 <hackrilege> the problem with the BlankClass approach is that its useless redundant syntax and i was sure i could achieve something like what i want using RankNTypes, but im a total noob...
21:44:39 <hackrilege> having to instantiate BlankClass with all structures that have Zippers seems bizare
21:47:44 <hackrilege> but constraining q to Free is so restrictive as to violate the whole purpose of having the class Zipable
21:48:49 <montanonic> hackrilege: q could just be: (Functor q) => q
21:48:57 <montanonic> hackrilege: since Free is a functor
21:49:22 <montanonic> hackrilege: also, I'd recommend using `operational` if you're going to use Free Monads; it's a more streamlined and efficient implementation
21:52:08 <hackrilege> hmm
21:52:52 <hackrilege> i tried;
21:52:53 <hackrilege> > class (Stack s) => HasZipper q s where
21:52:53 <hackrilege> >  toZipper   :: (Zipable z s,Stack s) => q s a -> z s a
21:52:53 <hackrilege> >  fromZipper :: (Zipable z s,Stack s) =>          z s a -> q s a
21:52:57 <hackrilege> but it did not work
21:53:00 <lambdabot>  mueval-core: Time limit exceeded
21:53:00 <lambdabot>  mueval-core: Time limit exceeded
21:53:00 <lambdabot>  mueval: ExitFailure 1
21:53:00 <lambdabot>  mueval: ExitFailure 1
21:53:00 <lambdabot>  mueval-core: Time limit exceeded
21:53:05 <lambdabot>  mueval: ExitFailure 1
21:53:06 <hackrilege> ooooo
21:53:30 <hackrilege> complains about the same error this time with z
21:54:09 <hackrilege> even though its in a constraint it still says its rigedly bound in the type signature and that no individual instance of Zippable will work
21:56:10 <montanonic> hackrilege: I was suggesting to turn this: toZipper   :: Stack s => q s a -> z s a
21:56:24 <montanonic> into: toZipper :: (Stack s, Functor q) => q s a -> z s a
21:56:50 <montanonic> and likewise with fromZipper
21:57:49 <hackrilege> Functor q!?
21:57:51 <montanonic> hackrilege: but your Free will need to have a Functor instance; again, I'd recommend `operational`
21:57:51 <hackrilege> kind error
21:58:08 <hackrilege> i looked at it it looks horrible!
21:58:34 <montanonic> takes a little getting used to, but it's really just the Free monad. There's also the `free` package
21:58:40 <montanonic> which has what you have, but with instances
21:59:01 <hackrilege> im fine using Free f a = Basecase a | Recurse (f (Free f a))
21:59:12 <hackrilege> its one line...
21:59:27 <hackrilege> the only problem i have is this bug
21:59:30 <hackrilege> at the moment!
21:59:35 <montanonic> one line and with no instances, so that anywhere you use it, you have to restrict the variable corresponding to it to Free
22:00:01 <hackrilege> oh i understand the problem now thanks
22:00:05 <montanonic> np
22:00:18 <hackrilege> but my Free [] synonym has many instances
22:00:37 <Cale_> I tend to find it's better not to get sucked into writing endless type classes from the outset. Write the code which would use the classes in a monomorphic and painful way first, and then figure out what's making things painful and repetitive, and you'll get the right abstractions.
22:01:05 <montanonic> ^yesssss
22:01:21 <bitemyapp> @karma+ Cale_
22:01:21 <lambdabot> Cale_'s karma raised to 1.
22:01:46 <hackrilege> :-|
22:01:59 <montanonic> hackrilege: in other words, write out your functions without any typeclasses and for only one type of data, then write them for another type of data, then keep going until you see a pattern you can abstract over
22:02:30 <hackrilege> this bug is entirely to do with classes
22:02:38 <hackrilege> anyway...
22:02:54 <Cale_> How much code is written which already uses these classes?
22:03:07 <montanonic> the point is that you're classes might not be the correct abstraction, hence why the bug would be the classes
22:03:07 <hackrilege> oodles
22:03:10 <montanonic> your*
22:03:28 <hackrilege> oh, you mean my Zipable class?
22:03:50 <montanonic> hackrilege: he's asking if you're applying the code in that module to anything, like, concretely
22:03:58 <Cale_> yeah, the Zipable and Stack abstractions and whatnot
22:04:11 <Cale_> Is there much code yet which is actually written using them?
22:04:19 <hackrilege> i will be implelemting more than one Stack and more than one Zipable container
22:04:44 <Cale_> It's not just about having multiple instances, but writing code which really uses the abstraction
22:05:11 <hackrilege> how do you differentiate these?
22:05:18 <Cale_> If you don't have repetitive code to begin with, it can be hard to tell what abstraction is *really* going to help
22:05:27 <hackrilege> you need not concern yourself as to my motivation for writing a class...
22:05:35 <hackrilege> trust
22:05:56 <hackrilege> i wrote this example to communicate a bug
22:06:04 <hackrilege> that i cant understand how to solve
22:06:44 <hackrilege> sufficiently, the requirement for a class is to communicate this bug that i get when i try and write classes
22:07:06 <Cale_> You think there's a GHC bug?
22:07:15 <Cale_> Or you just mean a type error?
22:07:19 <hackrilege> i could have written a smaller example, but this is the example i was thinking of and it was easier to write than explain
22:07:47 <hackrilege> its some kind of inability to polymorphise the paramatrisesd type its self..
22:08:16 <hackrilege> but its pointless me trying to put it into words, i wrote a very clear paste
22:08:26 <hackrilege> because i fail to explain sometimes
22:08:48 <Cale_> oh, I'll look at the paste
22:10:52 <Cale_> ... he left
22:11:22 <hackrilege> sorry bad connection
22:12:01 <Cale_> ah
22:12:50 <Cale_> hackrilege: okay, so, clearly the type signature for toZipper in the class declaration is silly, right?
22:13:14 * hackagebot aeson-compat 0.3.3.0 - Compatibility layer for aeson  https://hackage.haskell.org/package/aeson-compat-0.3.3.0 (phadej)
22:13:20 <hackrilege> toZipper   :: Stack s => q s a -> z s a
22:13:29 <Cale_> q isn't in scope
22:13:29 <hackrilege> no i like that i want it to work
22:13:41 <hackrilege> supposed to be polymorphic
22:13:45 <hackrilege> 'a' isnt in scope either
22:13:53 <Cale_> sure
22:14:04 <Cale_> But you might as well have written b -> z s a
22:14:20 <hackrilege> no, thats a kind error
22:14:23 <Cale_> because the fact that q takes s and a as type parameters doesn't say anything
22:14:25 <hackrilege> well
22:14:26 <Cale_> no it isn't
22:14:32 <hackrilege> ok its not
22:14:39 <hackrilege> but i want to write Free [] a
22:14:44 <hackrilege> and then q is Free
22:14:55 <hackrilege> Stack s is []
22:14:55 <Cale_> Maybe just write that?
22:14:59 <hackrilege> no
22:15:01 <montanonic> ahhh, I didn't see that one; good catch. Sometimes I forget about how polymorphism works when there's HKTs in the mix. 'a' really can be *anything*
22:15:15 <hackrilege> because i want each zipable instance to correspond to a unique q
22:15:35 <Cale_> aha
22:15:47 <Cale_> So perhaps you want q to be a parameter to the class
22:16:01 <Cale_> with some functional dependencies
22:16:03 <hackrilege> but really ZipperN [] is the z s
22:16:14 <hackrilege> corresponding to Free []
22:16:21 <hackrilege> its the zipable object
22:17:20 <Cale_> class Stack s => Zipable z s q | z s -> q where
22:17:37 <hackrilege_> sorry dropped connection again
22:17:40 <Cale_> class Stack s => Zipable z s q | z s -> q where
22:17:52 <montanonic> the | z s -> q part says that there's only one q for each pairing of z s, right?
22:17:56 <Cale_> yeah
22:18:15 <montanonic> okay, gotcha
22:18:17 <Cale_> maybe you really want z -> q
22:18:17 <hackrilege_> ooooh
22:18:23 <hackrilege_> this loooks promising
22:18:27 <Cale_> But I have no idea what any of this means
22:19:06 <Cale_> I'm just providing an option based on your description of what you want, rather than my own judgment of what would be good. :)
22:19:07 <hackrilege_> i think z -> q
22:19:18 <hackrilege_> perfect!
22:19:34 <Cale_> you can also say q -> z if you like
22:19:44 <hackrilege_> honestly id never get anything written if i did what you thought would be good...
22:20:13 <Cale_> I dunno, you might be surprised
22:20:35 <hackrilege_> not in scope type variable q
22:20:46 <Cale_> Yeah, it becomes Zipable z s q
22:21:04 <hackrilege_> noooooo
22:21:05 <Cale_> or z q s or whatever
22:21:17 <Cale_> okay, there's another option
22:21:23 <Cale_> add an associated type
22:22:03 <hackrilege_> thats a data definition in the class header?
22:22:18 <Cale_> class (Stack s) => Zipable z s where { type Q z :: (* -> *) -> * -> *; ... }
22:22:51 <Cale_> and then you'll have toZipper :: Stack s => Q z s a -> z s a
22:23:00 <Cale_> and fromZipper :: z s a -> Q z s a
22:24:42 <hackrilege_> couldnt match Q ZipperN with Free
22:25:13 <Cale_> Well, what's your instance look like?
22:25:28 <hackrilege_> oh
22:25:32 <hackrilege_> it should contain a Q
22:25:34 <hackrilege_> ok
22:26:01 <Cale_> yeah, you have to say  type Q ZipperN = Free   in the instance
22:29:05 <hackrilege> thanks, associated types was EXACTLY what i needed
22:29:28 <hackrilege> it compiles now
22:29:56 <hackrilege> woop woop! wont be long until i have a 2d fluid solver as an example using this
22:30:55 <hackrilege> maybe when its neater it will look more like a library. its built around this zmap thing, i hope it all works in n dimensions now
22:31:10 <confusedpotato> I'm new to Haskell. HP or Stack?
22:32:10 <Cale_> confusedpotato: They're both reasonable. Stack is a bit more project-oriented.
22:35:44 <confusedpotato> Cale_: Thanks :)
22:54:21 <arahael> If he stayed another few minutes, I'd have mentioned that as a newbie, I find stack easier to get started.  Less fluffing about wiht incompatible modules.
22:59:33 <hackrilege> Cale, you were asking about the occurrence of Zipable and Stack instances. Stack is a superclass constraint to Zipable, as a Zipper requires both a constructor and a deconstructed (push, pull). The only requisite of Stack over MonadPlus is pull. As mplus is used in construction, does this motivate CoMonadPlus as having complus as a deconstructor? Also, MonadPlus isn't ideal as it's only necessary to add or remove) one element at a time,
23:03:40 <hackrilege> Any idea about those classes? I guess it's not an group operator if it has type like (:)
23:14:01 <ski> hackrilege : cut off "Also, MonadPlus isn't ideal as it's only necessary to add or remove) one element at a time,"
23:44:29 <Zemyla> I wonder if it'd be possible to add reference counting to Haskell, as well as the GC, because reference counting can never say an object has too few references, only too many.
23:44:45 <Zemyla> It might speed up code at the expense of greater data size, or something.
