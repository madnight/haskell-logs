01:22:44 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
01:22:44 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
01:37:42 <EvanR> is there a more common name for this data type
01:38:02 <EvanR> data Foo a b = Foo a b | Bar a b
01:43:43 <opqdonut> EvanR: (Bool,a,b)?
01:44:02 <opqdonut> EvanR: Either (a,b) (a,b)?
01:44:03 <EvanR> grss
01:45:19 <opqdonut> you can also call it (a -> b -> c) -> (a -> b -> c) -> c
01:45:36 <EvanR> these arent exactly names ;
01:46:10 <merijn> opqdonut: Did you just suggest a Bool to distinguish them? ಠ_ಠ
01:46:19 <opqdonut> by golly I did
01:46:37 <opqdonut> in seriousness, I think EvanR's definition is good, and no, there's no established name for that
01:46:48 <EvanR> [Bool] can do a lot
01:47:25 <EvanR> ([Bool],Bool,[Bool]) for balance
01:51:09 <I_am_a_robot_Muh> Guys, how do you turn a list of ints into a single int
01:51:14 <I_am_a_robot_Muh> as functiong
01:51:31 <I_am_a_robot_Muh> [1,2,3,4] into the Int 1234
01:53:48 <I_am_a_robot_Muh> Anyone?
01:54:08 <chelfi> one possible way would be to turn each int into a string, concatenate those strings, and convert the final string to an int
01:54:27 <EvanR> 4*1 + 3*10 + 2*100 + 1*1000
01:54:30 <I_am_a_robot_Muh> but how do you turn in into a string then
01:54:39 <merijn> chelfi: No you're making me sad
01:54:43 <merijn> *Now
01:54:50 <mfukar> > let fromDigits = foldl addDigit 0 where addDigit num d = 10*num + d in fromDigits [1,2,3,4]
01:54:52 <lambdabot>  1234
01:55:21 <mfukar> Turning into strings is also possible, but kinda roundabout
01:55:42 <merijn> Really inefficient way of doing the same thing
01:56:00 <nomotif> Dumb question, what is the state of GUI programming in Haskell right now?
01:56:29 <merijn> nomotif: I recently heard a talk about making it not suck, but didn't watch it yet
01:56:35 <EvanR> GTK exists
01:56:45 <EvanR> reactive banana exists
01:56:57 <I_am_a_robot_Muh> well now I get a naked expression error @mfukar
01:57:08 <merijn> nomotif: My experiences is "it sucks, but mostly in the same ways that it always sucks in every language"
01:57:19 <merijn> nomotif: https://www.youtube.com/watch?v=5hoQLovZBxQ&index=7&list=WL
01:57:20 <nomotif> merijn: Ahh, that makes sense.
01:57:35 * hackagebot relational-schemas 0.1.3.0 - RDBMSs' schema templates for relational-query  https://hackage.haskell.org/package/relational-schemas-0.1.3.0 (KeiHibino)
01:57:38 <EvanR> there was a guy a few years ago named manatee and he made an entire "environment" out of GTK and haskell, with its own browser, its own editor, terminal
01:57:46 <EvanR> it was called manatee
01:58:07 <nomotif> evanr: Huh, thats interesting.
01:58:15 <EvanR> i had no idea how he did it
01:58:16 <I_am_a_robot_Muh> @mfukar how do I fix it
01:58:16 <lambdabot> Unknown command, try @list
01:58:20 <EvanR> its probably not working anymore
01:58:27 <I_am_a_robot_Muh> how do I fix it @mfukar
01:58:33 <mfukar> I_am_a_robot_Muh: not sure, can you show your code?
01:58:44 <EvanR> nomotif: also, theres the web
01:59:05 <nomotif> evanr: Yeah, I've been looking for an excuse to use Yesod.
01:59:06 <I_am_a_robot_Muh> http://lpaste.net/163838 @mfukar
01:59:17 <EvanR> three-penny-gui
02:00:07 <nomotif> evanr, mfukar: I guess my question is better phased as if I wanted to freelance with Haskell would desktop GUI applications be more trouble than its worth?
02:00:53 <merijn> nomotif: I think desktop GUI has a high up-front cost (figuring out how to build things so that they work cross-platform, etc.)
02:01:10 <nomotif> merijn: Ahh
02:01:15 <merijn> nomotif: But I think that once you've got an environment setup and know how to build stuff it's no problem
02:01:31 * EvanR wonders about haskell GUI on windows
02:01:37 <mfukar> I_am_a_robot_Muh: take fromDigits out of the let...in expression
02:01:48 <merijn> nomotif: So if you're willing to, say, spend a few weeks sorting all that out once for yourself you should be fine after that
02:02:09 <merijn> nomotif: Alternatively, if you already KNOW how to do GUI stuff in another language, why not use that for the GUI and do the logic in haskell?
02:02:21 <merijn> nomotif: You can easily call haskell via FFI
02:02:26 <EvanR> indeed that is the route i went with cocoa
02:02:30 <I_am_a_robot_Muh> still a naked error though @mfukar
02:03:15 <nomotif> merijn, evanr: That definitely makes  a lot of sense as well.
02:03:25 <EvanR> naked expression error, sounds like a top level thing that doesnt look like
02:03:29 <EvanR> foo x y z = bar
02:03:38 <EvanR> specifically no =
02:03:44 <merijn> nomotif: Assuming you know your way around C/dynamic libraries/static libraries/linking all the haskell FFI stuff is really straightforward
02:04:08 <EvanR> merijn: perhaps unless its Obj-c
02:04:19 <merijn> i.e., most of the confusion/problems I see people having with the FFI is a lack of understanding of linking :)
02:04:25 <merijn> EvanR: How so?
02:04:26 <I_am_a_robot_Muh> yeah basicly i have a naked expression still at top lvl
02:04:53 <merijn> EvanR: I think copyed the "let...in..." into his file directly
02:04:58 <EvanR> if you know your way around C, dynamic libraries, static libraries, and linking, you may still be up a creek in order to make an objective C front end
02:05:04 <I_am_a_robot_Muh> I did
02:05:20 <merijn> EvanR: Not if you let XCode do the linking for you, I would think
02:05:21 <EvanR> which is 1/3 of dekstop GUIs
02:05:36 <EvanR> xcode is required in any case
02:05:50 <I_am_a_robot_Muh> I really just need a function that turns a list into an int
02:05:51 <EvanR> which i hate
02:06:10 <I_am_a_robot_Muh> as I said [1,2,3,4] into an Int 1234
02:06:12 <EvanR> > let f _ = 3 in f [1,2,3,4]
02:06:14 <lambdabot>  3
02:06:16 <EvanR> oh
02:06:31 <merijn> EvanR: Well you need XCode for any compilation, doesn't mean you have to use the actual XCode GUI
02:07:10 <EvanR> time for an applescript to click on the xcode gui as part of the build process ;)
02:08:00 <I_am_a_robot_Muh> So what would the function be to turn a list xs into an Int   (So [1,2,3,4] -> 1234
02:08:01 <merijn> EvanR: So far I've been able to do everything from the commandline (including linking against ObjC frameworks)
02:08:06 <nomotif> merijn, evanr: lol
02:08:42 <EvanR> merijn: i know its possible, just saying classic C tooling wont translate
02:09:25 <EvanR> and the only reason is because you want GUI on osx :(
02:09:40 <merijn> EvanR: No, but then, if you need to link against ObjC I'm assuming you already know how to do that with just ObjC and then haskell FFI is still as easy as linking against C
02:09:58 <EvanR> is it the same?
02:10:05 <I_am_a_robot_Muh> So what would the function be to turn a list xs into an Int   (So [1,2,3,4] -> 1234) @EvanR
02:10:27 <merijn> EvanR: binaries are binaries
02:10:35 <EvanR> > let f [1,2,3,4] = 1234 in f [1,2,3,4]
02:10:37 <lambdabot>  1234
02:11:00 <EvanR> merijn: i.e. same calling conventions? i assume FFI is based on C
02:11:04 <EvanR> non-objective
02:11:08 <merijn> EvanR: It's not possible to distinguish a GHC produced .so from a gcc or clang produced .so unless you start disassembling and notice "wow...this is some pretty whacky code"
02:11:36 <merijn> EvanR: The report only mandates a C FFI, but ObjC has a C FFI too (actually, you can call C ABI functions directly)
02:11:39 <EvanR> well, when i look at a c++ object file...
02:11:46 <EvanR> it dont look natural
02:11:48 <merijn> C++ has a different ABI
02:11:52 <EvanR> exactly
02:11:52 <merijn> Well
02:12:00 <merijn> The symbols are the same, though
02:12:10 <merijn> C++ symbols just look wonky due to name mangling
02:12:36 * hackagebot relational-record-examples 0.3.0.0 - Examples of Haskell Relationa Record  https://hackage.haskell.org/package/relational-record-examples-0.3.0.0 (KeiHibino)
02:12:44 <I_am_a_robot_Muh> but how can I write that so it works with any list on ints? @EvanR
02:12:55 <I_am_a_robot_Muh> I need it to work with list xs
02:13:21 <EvanR> the code was already given to you above, but i recommend thinking harder 
02:14:23 <liste> I_am_a_robot_Muh: suppose you have two numbers, 3 and 4. what operations are needed to produce a number 34 ?
02:15:21 <nomotif> merijn, evanr: Thanks guys, definitely gave me a bit to chew on.
02:16:38 <I_am_a_robot_Muh> 3 * 10 + 4 * 1?
02:17:25 <liste> I_am_a_robot_Muh: yep
02:17:33 <EvanR> nomotif: the quest to come up with a declarative DSL for GUIing continues
02:18:18 <liste> I_am_a_robot_Muh: now does that work for e.g. 23 and 4 -> 234?
02:18:33 <nomotif> EvanR:  It's one of those "Oh theres obviously a good way to do this we just... hmmm... *10 months later* but if we just..." type things.
02:18:35 <I_am_a_robot_Muh> 23 * 10 = 4 * 1
02:19:04 <nomotif> EvanR: Or at least the thought pattern seemed familiar when I wondered about it
02:19:11 <EvanR> nomotif: im going on year N just trying to do pacman
02:19:37 <nomotif> EvanR: 8-o
02:20:01 <EvanR> without resorting to the equivalent to "C in any language"
02:20:05 <EvanR> equivalent of
02:21:25 <liste> I_am_a_robot_Muh: now you know how to append a digit to the end of any number. half of the problem is solved
02:22:16 <I_am_a_robot_Muh> http://lpaste.net/163839 @liste
02:22:25 <I_am_a_robot_Muh> still does give error 
02:22:30 <I_am_a_robot_Muh> mainly because of the reverse
02:24:48 <liste> I_am_a_robot_Muh: you don't need to reverse at all, just modify your digitstoInt a bit
02:25:47 <EvanR> nomotif: my latest mad science experiment involves modifiable animations
02:26:01 <I_am_a_robot_Muh> Hmm well I always get the last element of a list with head reverse xs
02:26:11 <nomotif> EvanR: That sounds interesting, how are you going about it?
02:27:48 <Cale> nomotif, EvanR: have you tried reflex-dom?
02:27:52 <Cale> :)
02:28:07 <nomotif> Cale: I must have missed it in my survey, let's see...
02:28:15 <EvanR> i looked into reflex sans don somewhat
02:28:33 <EvanR> but the name -dom is off putting
02:28:53 <Cale> If you compile a reflex-dom application with ghc, you get a native application which uses webkit-gtk, and manages its DOM directly (without Javascript)
02:29:16 <EvanR> having to deal with DOMs in day to day work is bad enough
02:29:30 <EvanR> its like the GUI version of S expressions
02:29:54 <fred-fri> http://pastebin.com/PXhuyHGR anycare care to answer this dumb question?
02:30:00 <EvanR> but i appreciate the practicality
02:31:02 <I_am_a_robot_Muh> well I have no errors now
02:31:18 <Cale> fred-fri: yes, the second one gets the second element of the list for some reason, and isn't safe
02:31:29 <Cale> It'll crash on a list of length 1
02:31:49 <fred-fri> Cale, oh thats just a typo
02:31:52 <EvanR> Cale: does reflex(/-dom) have something to talk about internally scheduled events that may be interrupted arbitrarily by something seemingly unrelated?
02:32:18 <fred-fri> i mean is there any difference between using above style with the guard and the below style with just whatever that plain style is called
02:32:19 <I_am_a_robot_Muh> http://lpaste.net/163840 but this returns [] instead of a combination of 9 numbers where 1 is dividable by 1, 12 by 2 123 by 3 etc @liste
02:32:33 <EvanR> without having to manage it externally or manually
02:32:49 <lyxia> wow
02:32:50 <Cale> EvanR: Well, you can gate an Event based on a Behavior t Bool
02:33:14 <EvanR> but the event is still going to happen and have to be filtered
02:33:30 <EvanR> so if its recurring, itll pile up
02:33:39 <EvanR> or in any case be a waste
02:33:41 <Cale> Wait, what?
02:33:56 <Cale> No, the occurrences which fire while the behaviour is False will just be dropped
02:34:02 <EvanR> right
02:34:24 <I_am_a_robot_Muh>  del is del :: Eq a => [a] -> [a] -> [a] del xs ys = [y| y <- ys, not(elem y xs)]  @liste
02:34:25 <Cale> and they'll have no performance impact on the remainder of the system
02:34:33 <EvanR> if the program has two states, with its own events going on, then when you are in either state, the only thing stopping the other state from doing stuff is an army of such droppers
02:34:49 <EvanR> which doesnt make much sense
02:34:53 <Cale> That's not true
02:34:58 <Cale> There's switch
02:35:22 <Cale> switch :: Behavior t (Event t a) -> Event t a
02:35:34 <EvanR> when you switch does it clear everything that was happening in the previous state?
02:36:38 <EvanR> also i dont understand that type signature
02:36:40 <Cale> It doesn't merge the events together
02:36:54 <Cale> You have a choice of Event which changes over time
02:36:54 <sdx23> fred-fri: pattern matching is the way to do it. Only by this you get an element out of the list. If you use guards, head will eventually pattern match anyways.
02:37:16 <Cale> and you get an Event from it which fires if and only if the currently selected Event is firing
02:37:54 <fred-fri> sdx23, so the plain style is referred to as pattern matching, and the guard style is referred to as guards?
02:38:35 <Cale> None of the other values that the Behavior may have had in the past or may have in the future affect whether it's firing right now, or even the computation necessary to determine whether it is firing presently.
02:38:41 <EvanR> what if its from an event that is not selected?
02:38:55 <Cale> You don't even have that Event
02:39:09 <Cale> You only have one Event at a time, the current value of the Behavior
02:39:46 <Cale> and if it's occurring, the result is occurring
02:40:18 <sdx23> fred-fri: plain style? Pattern matching is when you decontruct data. This may be more obvious for Maybe: f (Just x) = ...; f Nothing = ... -- than for lists, due to syntax sugar there.
02:40:19 <Cale> and it may switch to being some other Event at some point, and then the result is occurring if and only if *that* Event is occurring
02:41:05 <EvanR> how would you save the state for later before you switch to some other state
02:41:39 <Cale> By using hold or foldDyn somewhere
02:42:22 <Cale> hold :: MonadHold t m => a -> Event t a -> m (Behavior t a)
02:42:40 <Cale> is sort of *the* primitive for remembering the value of something over time
02:43:02 <EvanR> so the behavior has the latest value of the event
02:43:23 <EvanR> and you need to use a monad to register it
02:43:28 <Cale> yeah, at all times *following* the Event having fired with that value
02:44:03 <EvanR> and is there unregistering?
02:44:10 <Cale> You can think of that monad as basically being a reader monad for the current time, so that all occurrences of the event before that time can be ignored.
02:44:31 <Cale> (but in the real implementation, it's using IO to set up an IORef)
02:44:54 <Cale> Unregistering what?
02:45:21 <EvanR> nevermind, i guess that would cause breakage after you connect the behaviors together
02:45:37 <EvanR> back to my original question, was the internally scheduled events
02:45:47 <EvanR> reacting to user input is only half the situation
02:46:02 <Cale> So, you want a timer?
02:46:20 <EvanR> a coreographed thing will have a complex, possibly programmatically defined schedule
02:46:24 <EvanR> that could be interrupted
02:46:37 <EvanR> and it goes along without user input
02:46:51 <EvanR> yes timer is one way to implement something like that
02:46:58 <EvanR> but you have to manually cancel timers, in js
02:47:01 <Cale> Reflex on its own doesn't do anything to provide internal operations for getting Events that occur at particular times, because it is so agnostic about the representation of time that it couldn't.
02:47:17 <Cale> Reflex-dom on the other hand, provides some ways to get timers
02:47:18 <merijn> EvanR: "programatically defined" schedule sounds rather antithetical to FRP
02:47:27 <merijn> EvanR: You appear to be reasoning rather opertionally?
02:47:31 <fred-fri> sdx23, sorry im not terribly familiar with the terminology =)
02:47:35 <fred-fri> is there any difference between http://pastebin.com/rbkQ4qRT
02:47:45 <EvanR> no i am not
02:48:27 <EvanR> it sounds like FRP has turned into only talking about responding to user input or external notifications, but i could be wrong
02:48:43 <sdx23> fred-fri: there's an unnecessary call to head in the second. Other than that, no.
02:48:46 <merijn> EvanR: No, you can easily generate internal events based on timers
02:49:01 <merijn> EvanR: Since most (all?) FRP frameworks have a notion of time based events/behaviours
02:49:02 <EvanR> timers is operational
02:49:23 <merijn> No, I meant a "secondsFromNow :: Int -> Event a"
02:49:39 <merijn> Or "everyX :: Int -> Event a"
02:49:44 <EvanR> yes, in a few of my libs i have delay which delays events by a fixed amount
02:50:08 <merijn> EvanR: You can easily have events based on other events triggering too
02:50:10 <Cale> EvanR: If you want to do the low-level thing to create and destroy timers from IO, there's performEventAsync which is a low-level thing that can be used to create an event with values provided by something that demands a callback and involves IO.
02:50:15 <EvanR> but its not good enough to do what im saying, because of my original problem posed, that if you wanted to cancel the whole thing, youd have to put a filter
02:50:35 <merijn> Besides "wall-clock" time and external events and compositions of behaviours/events I don't see what you'd miss?
02:50:39 <EvanR> and now a thing you wanted to stop is continually getting filtered until it would have been done
02:50:52 <merijn> EvanR: That depends on the underlying implementation
02:51:23 <merijn> EvanR: Consider, e.g. reactive-banana, which compiles your behaviours/events into a graph and will GC parts of it when possible
02:51:30 <Cale> EvanR: So obviously, if the place from which you're getting the timer is some device external to the FRP system, you might need to use some Event which is hooked to the low-level stuff to turn it off.
02:51:34 <Cale> (or on)
02:51:40 <EvanR> you cant optimize away the future because the filter function may eventually recant and let stuff through
02:51:44 <merijn> EvanR: So while selection is defined as "perpetual filtering" that's not what it does
02:52:39 <EvanR> Cale: yes manual management of timers
02:52:48 <merijn> EvanR: Well, yes, that's the hard part of FRP implementations, reactive has a custom monad for switching to avoid this behaviour and allow early GC in exchange for limiting the flexibility
02:53:37 <EvanR> for a video game, most of the action going on is not user input
02:54:04 <EvanR> its an internal world of interaction, some of it is happening on a fixed time schedule, some of it is emergent based on the simulation 
02:54:10 <Cale> So you'll probably have a clock Event which fires once per frame
02:54:15 <EvanR> it happens by itself
02:54:28 <Cale> and very little which fires at times other than that
02:54:32 <EvanR> and sometimes the emergence causes stuff to be cancelled, and its a bitch to manage
02:54:42 <merijn> EvanR: You realise reflex is the result of Cale & others writing an FRP action game, right? :p
02:54:46 <EvanR> a clock event that fires once per frame?
02:55:44 <Cale> One way to think of an Event is that it represents permission to do some computation at the times when it occurs
02:56:31 <EvanR> a clock event that fires once per frame sounds like continuous animation manually
02:57:35 <Cale> Well, that would be the most frequently occurring event in the system, and most Events would occur at some small subset of the times at which it's occurring
02:58:03 <Cale> You wouldn't actually want to give that Event to too many things
02:58:10 <EvanR> when i think of the platonic form of a video game, video frames arent events
02:58:31 <EvanR> nothing reacts to that in an essential way
02:58:41 <EvanR> its just the sample rate
02:58:41 <Cale> Well, sure, perhaps you have a Behavior on output which is what is meant to be drawn on the screen
02:59:08 <merijn> EvanR: Main fighting games and platformers do have abstract frames that tick every N seconds
02:59:14 <EvanR> in my mind events are much more seldom than that
03:00:16 <EvanR> and they happen on user input, or when a missile strikes something, or if theres a discontinuous change in somethings flow through time
03:00:32 <Cale> Events fire as often as you want to give some part of the system the right to do arbitrary computation. So indeed, most events will be much less frequent than that.
03:00:56 <EvanR> a smooth animation doesnt need an event to make it go
03:01:01 <Cale> That's true
03:01:12 <Cale> If you don't want a clock event, you don't have to have one
03:01:21 <EvanR> so like the difference between wave function evolving and wave function collapse
03:01:44 <Cale> But you do need something which will grant various parts of the system the right to compute
03:01:54 <Cale> and it can't *just* be user input, as you pointed out
03:02:28 <Cale> An AI clock might not need to be every frame, just as often as you want the AI to be able to change its plan.
03:02:28 <EvanR> for heads up display UI which is really just about reacting to input i can see not needing timers
03:02:43 <EvanR> the app is in a static state until you poke it
03:03:06 <EvanR> Cale: exactly, which is where i started my current line of reasoning
03:03:09 <Cale> (which might involve ticks from stuff happening due to user input, plus some infrequent clock)
03:03:29 <EvanR> here is the line of reasoning
03:04:41 <Cale> EvanR: But note that even if you provide the AI with a Behaviour which represents the continuously varying value of everything in the world, it can only look at this whenever one of its input Events occurs
03:04:55 <EvanR> each behavior relies on executing some change to the model when certain conditions are met in the pure animation, for example a pacman ghost decides on a plan to reach pacman, based on pacmans not just location but known trajectory
03:05:20 <EvanR> but that plan, which is a pure animation, isnt the ultimate plan, it will need to change
03:05:23 <EvanR> but when
03:05:37 <EvanR> it might need to change no sooner than when something that the plan was based on is modified
03:05:53 <Cale> So, we also have Dynamic
03:05:53 <EvanR> this idea expands beyond AI into other things
03:06:38 <EvanR> if some effect was based on the ghosts trajectory, then that effect will update when the ghosts plan updates, potentially
03:06:53 <EvanR> most of the time all these effects are just waiting for their time to execute
03:06:58 <EvanR> not checking every frame
03:07:12 <Cale> A Dynamic is essentially a pair of a Behaviour, a function of time which always has a value, and an Event such that the Behavior changes only following moments when the Event is occurring.
03:07:31 <Cale> So it's something that you can react to all the changes in
03:07:48 <Cale> but which you can also determine its value at times when it is not changing
03:07:59 <EvanR> is it static between occurrences?
03:08:02 <Cale> yes
03:08:09 <EvanR> mmkay
03:09:14 <EvanR> so an AI that is using continuously varying input to make decisions doesnt seem very natural
03:09:43 <EvanR> a decision on what to do is made at an instant
03:10:03 <EvanR> and you dont want to wait for input to change enough to make the decision, you want to make a prediction now
03:10:25 <EvanR> and possibly update your decision later, before your chosen future execution time comes
03:10:46 <EvanR> in any case once your goal is reached, you want to go back to the drawing board and start over
03:10:59 <EvanR> or quit
03:12:41 <EvanR> this also covers very slow animations, that go by frame to frame
03:13:18 <EvanR> instead of each frame updating a counter, and doing nothing until it reaches a point, you should sleep until the time comes to update
03:13:29 <EvanR> for efficiency
03:16:13 <bollu> hey all
03:16:28 <bollu> I was wondering if someone could explain the "adjunctions create monads" thing
03:16:56 <bollu> like, how adjunctions yield monads, and how this is related to (,) and (->) and State
03:37:35 <Cale> EvanR: right, the AI only gets to make decisions at times when its input events fire
03:43:10 <EvanR> Cale: youre talking about an explicit kick in the pants to make it rethink?
03:43:35 <EvanR> i remember doing something similar to this with a GUI, to make all elements report that they changed to cause a canvas redraw
03:44:02 <EvanR> something i either thought should be abstracted out, or just done for you
03:45:39 <Cale> Well, you could always have only game-world events go into the AI, but often it's useful to have a bit more than that.
03:46:21 <EvanR> the AI only *needs* to make decisions, at most, when whatever it based its previous decision on has changed, or it has completed its task
03:47:38 <EvanR> and when it based a decision on some smooth animation, that doesnt count as changing
03:47:54 <EvanR> because it sees that animation as timeless
03:47:57 <Cale> Well, if you have the AI completely recompute its plan every time any of the inputs to the plan changes, sometimes that results in poor performance. So perhaps you want to build a plan and stick to it for at least some time.
03:48:17 <Cale> It depends on how frequently those inputs are changing
03:48:31 <EvanR> i meant changing in an unpredictable way
03:48:37 <hpc> it also depends on if the AI can do incremental planning
03:48:41 <EvanR> and yes as a further optimization you can put a limiter
03:49:12 <EvanR> yes incremental planning can be part of its goal
03:49:25 <EvanR> think some, then plan to think more later
04:11:21 <trubert1> what would be the most computationally efficient way to divide two Integer values and get back a Double?
04:11:32 <trubert1> divd a b = fromIntegral a / fromIntegral b ... anything better?
04:12:50 <opqdonut> trubert1: that's it
04:13:39 <trubert1> opqdonut: ok, thanks.
04:13:44 <opqdonut> trubert1: however if you want accuracy for very large Integers, you should construct a Ratio and then convert to Double
04:13:50 <opqdonut> but that's less efficient
04:14:43 <plunks> hey! could anyone take a look at this piece of code http://lpaste.net/3185049001120497664 and give a suggestion on how to not write the same code twice for processing Ints and Floats? the idea here is that i need a function that processes some collection of key, value pairs. i know that some of the keys will always be there like "toktype", "value",
04:14:43 <plunks>  "unit" but there could be others. the Token data type is designed with that in mind
04:19:44 <opqdonut> plunks: a function "multiply :: OtherValue -> Int -> OtherValue" might help
04:20:20 <opqdonut> of course that won't work for the S or O case
04:20:43 <opqdonut> if you want more type safety you could consider having
04:20:44 <Cale> Maybe a type class?
04:20:54 <plunks> yeah, but then i would have to redefine a lot of arithmetic to have custom functions for OtherValue
04:20:54 <opqdonut> a type class can help too yeah
04:21:21 <EvanR> also generalized newtype deriving?
04:21:25 <Cale> oh, or no
04:21:30 <opqdonut> or you could do something like "data OtherValue = S String | N MyNumber | O Other; data MyNumber = I Integer | F Float"
04:21:43 <Cale> Just write a function which is polymorphic and takes the things you pattern matched
04:21:49 <opqdonut> and then have "multiply :: MyNumber -> Int -> MyNymber"
04:22:00 <Cale> but in addition takes the constructor to apply
04:22:01 <Maxdamantus> You could also just define some Num a => (a -> OtherValue) -> a -> String -> String -> Maybe Others
04:22:02 <Cale> I or F
04:22:03 <plunks> i tried to solve this by converting the Token type to a typeclass, so that the typeclass parameter would signify the type of "unit", and i could then write define process :: Num a => (Token a, String), but this prevents me from having "value" as String
04:22:11 <Maxdamantus> er
04:22:40 <Maxdamantus> Num a => (a -> OtherValue) -> a -> String -> String -> Maybe Others -> (Token, String)
04:24:00 <Cale> grr, lpaste down for maintenance
04:24:09 <Maxdamantus> (that's basically what Cale suggested)
04:29:09 <plunks> oh, ok, defining a separate function to process the pattern matched stuff would work i guess
04:37:20 <Cale> plunks: I wrote that for you, but lpaste went down and ate it :P
04:40:48 <plunks> Cale: thanks, i noticed that too just now
04:44:40 <plunks> i tried an alternative variant using typeclasses that that would go something along the lines of http://pastebin.com/9ef4zuwG
04:45:59 <plunks> this does not compile though. gives me "`proc' is not a (visible) method of class `Token2'"
04:47:42 * hackagebot chalmers-lava2000 1.6.1 - Hardware description EDSL  https://hackage.haskell.org/package/chalmers-lava2000-1.6.1 (EmilAxelsson)
04:57:42 * hackagebot container-builder 0.1 - Functions for building containers from a known number of elements  https://hackage.haskell.org/package/container-builder-0.1 (andrewthad)
05:16:02 <lyxia> plunks: you need to specify the typeclass in the instance declaration
05:16:24 <lyxia> plunks: instance Num a => Proc (Token2 a) where
05:45:03 <plunks> lyxia: thanks, i tried to reproduce an earlier piece of code and missed that. the real problem here was that when defining the proc method for the instance i got an errorhttp://lpaste.net/3261527276147179520
05:45:40 <plunks> lyxia: "Couldn't match expected type `b' with actual type `Token2 a'"
05:46:41 <plunks> sorry, the link is http://lpaste.net/3261527276147179520
05:47:27 <Eduard_Munteanu> plunks, you do realize 'b' is universally-quantified, right?
05:47:59 <Eduard_Munteanu> :t (+)
05:48:00 <lambdabot> Num a => a -> a -> a
05:48:46 <Eduard_Munteanu> plunks, the implementation must provide a polymorphic result, it is implied
05:52:04 <plunks> Eduard_Munteanu: no sorry, i don't know what the implications of 'b' being universally quantified are here. what i tried to get from this is that i could define a function that is restricted with Num a => ... and i could return anything i want
05:52:23 <plunks> Eduard_Munteanu: be it Int, Float or String
05:56:26 <Eduard_Munteanu> plunks, you might want to make 'b' a parameter of your typeclass, or make a data like   data Number = IsInt Int | IsFloat Float | IsString String
05:57:14 <Eduard_Munteanu> Alternatively to the former, you can use associated type families.
05:58:00 <Eduard_Munteanu> e.g. type Result a   in the class declaration, and replace 'b' by 'Result a'.
05:58:17 <Eduard_Munteanu> But I don't know what your usecase is.
06:02:23 <plunks> Eduard_Munteanu: this was a different take on the problem i stated earlyer. basically what i want is to be able to parse/modify some arbitrary collection of key, value pairs and i'm trying to find the best way to do it. i know for sure that some key, value pairs will definitely be in the collection. that's why i've made the data type "Token" seen i
06:02:24 <plunks> n the code gist - it has some keys predefined, and a collection "others" for the rest of they key, value pairs
06:03:24 <Eduard_Munteanu> plunks, use a plain data then, like my Number above or your OtherValue.
06:03:37 <plunks> the problem i'm constantly struggling  with is that the values can bey either String, Int, Float (or maybe something else in the future) and i want to be able to transform one such collection to another one
06:04:53 <plunks> and i'm trying to find a way to not duplicate code when dealing with Ints and Floats
06:07:45 * hackagebot logict-state 0.1.0.2 - Library for logic programming based on haskell package logict  https://hackage.haskell.org/package/logict-state-0.1.0.2 (AtzeDijkstra)
06:27:45 * hackagebot pringletons 0.3 - Classes and data structures complementing the singletons library  https://hackage.haskell.org/package/pringletons-0.3 (andrewthad)
06:46:45 <Sparhawk> yo
06:48:51 <EvanR> plunks: you may want to define a dynamic type
06:49:08 <EvanR> with (unsafe) Num instance which does the "right thing" (tm)
06:49:18 <EvanR> or find one on hackage
07:01:49 <RainBowww> nobs
07:01:54 <RainBowww> sorry too much lol
07:01:57 <RainBowww> -.-
07:04:21 <plunks> EvanR: i have been thinking about it. that might be a solution
07:10:14 <Xnuk> Can I get compiled haskell-src-exts?
07:10:50 <[hiring]SubTales> Hey, any C/C++ programmers who would like a job on my project?
07:11:00 <hpc> that's off topic here
07:11:10 <[hiring]SubTales> what is on topic here then
07:11:15 <hpc> read the topic
07:11:20 <Xnuk> I'm installing haskell-src-exts and it's heavy and slow
07:12:09 <Sparhawk> is oop asm on the topic
07:12:47 * hackagebot jsontsv 0.1.7.0 - JSON to TSV transformer  https://hackage.haskell.org/package/jsontsv-0.1.7.0 (DanielChoi)
07:23:41 <EvanR> is there a trie package where i can query for the subset of all values where the key is a prefi
07:23:44 <EvanR> prefix
07:24:35 <thoughtpolice> EvanR: bytestring-trie
07:24:53 <EvanR> i have lists of Integer rather than Word8
07:25:21 <crobbins> what's a good string interpolation lib?   wanting something with quasiquotes
07:27:26 <EvanR> i see bytestring-trie has exactly what im looking for... maybe i need to encode
07:32:34 <bennofs> crobbins: i think https://hackage.haskell.org/package/interpolate looks pretty solid. haven't used myself though
07:38:12 <felixsch> I'm playing around with XMonad and XMonad encodes it's Layout as type. I want to build a State monad arround XConfig l (l is the layout type) to configure xmonad in a monadic way. But when I use something like `StateT (XConfig l) m a` the layout is fixed to the initial state l. How would you solve the problem?
07:41:50 <cocreature> Xnuk: unfourtunately it’s normal for haskell-src-exts to take ages to compile
07:44:27 <EvanR> and holy shit bytestring-trie is friggin amazing
07:44:42 <EvanR> the matches function
07:47:48 * hackagebot octane 0.4.24 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.24 (fozworth)
07:53:43 <prinsen> Im exposing a method via foreign export, but my C++ executable just hangs.
07:57:48 * hackagebot sorted-list 0.1.5.0 - Type-enforced sorted lists and related functions.  https://hackage.haskell.org/package/sorted-list-0.1.5.0 (DanielDiaz)
08:13:28 <hackrilege> hi!
08:13:35 <crobbins> is this a reasonable way to turn lazy io into strict io?
08:13:37 <crobbins> !content <- fmap force getContents
08:13:53 <crobbins> using BangPatterns and deepseq
08:15:03 <hackrilege> i have a problem with composing functions returning Maybe...
08:15:04 <hackrilege> normally i would use (>>=)
08:15:22 <hackrilege> http://lpaste.net/163852
08:15:22 <cocreature> if you want to compose functions returning Maybe you probably want >=>
08:15:24 <cocreature> :t >=>
08:15:26 <lambdabot> parse error on input ‘>=>’
08:15:27 <hackrilege> ooh nice
08:15:30 <cocreature> :t (>=>)
08:15:31 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:15:39 <hackrilege> good tips
08:15:41 <exprmer> Someone help me write the Applicative instance for this type: `data SExpr a = SVal a | SCons(SExpr a)(SExpr a) deriving (Eq,Show,Read);instance Functor SExpr where {fmap f=mapped where {mapped(SVal a)=SVal(f a); mapped(SCons xs ys)=SCons(mapped xs)(mapped ys)}};instance Monad SExpr where {return=SVal;(>>=)(SVal a)f=f a;(>>=)(SCons xs ys)f=SCons((>>=)xs f)((>>=)ys f)}`
08:16:25 <hackrilege> i think its more like fmap (>=>) (Just.fmap)
08:16:32 <hackrilege> so maybe not quite the same
08:17:10 <hackrilege> the composition will be on line 46
08:17:23 <monochrom> crobbins: I think yes
08:17:31 <hackrilege> in place of the .
08:17:34 <hackrilege> (.)
08:17:45 <crobbins> monochrom, great, thanks.  it seems to work well
08:18:05 <Xandaros> Wasn't there talk about renaming ‘*’ to ‘Type’? Is that still a thing and should I avoid calling things ‘Type’ in new projects?
08:19:41 <hackrilege> line 51 is an alternative to the use of (:[]) in the definition of iterate'
08:19:50 <hackrilege> http://lpaste.net/163852
08:20:21 <hackrilege> im not sure how to break the problem down
08:20:45 <Myrl-saki> Not exactly Haskell-related, but does anyone have a link to that article where dynamic typing is just a special case of static typing?
08:21:42 <simpson> Myrl-saki: https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/
08:22:10 <Myrl-saki> simpson: Thanks.
08:22:50 <simpson> Myrl-saki: Sure.
08:23:48 <monochrom> exprmer: SVal f <*> x = looks like you can use fmap here.  SCons a b <*> x = SCons (a recursive call here) (another recursive call here)
08:24:31 <cocreature> exprmer: if you already have a monad instance you can just use (*> = ap
08:24:53 <Myrl-saki> I've seen some functors that are not applicative, but are there some applicatives that are not mnoads?
08:25:21 <Myrl-saki> Correct me if I'm wrong, but can't monads be described only by applicative's functions?
08:25:58 <monochrom> ziplist is a non-monad applicative
08:26:11 <hackrilege> no, there should also be something of type m (m a) -> m a
08:26:18 <hackrilege> :t join
08:26:19 <lambdabot> Monad m => m (m a) -> m a
08:26:28 <monochrom> there are also parser combinator examples, circuit modeling examples
08:26:43 <Myrl-saki> I thought ziplists are non-applicative.
08:26:46 <hackrilege> @src (>>=)
08:26:47 <lambdabot> Source not found. Are you typing with your feet?
08:26:59 <hackrilege> nvm
08:27:40 <hackrilege> Cale, my code is neat and below 100 lines!! will you look at it yet? http://lpaste.net/163852
08:28:35 <Myrl-saki> Hmmm, I guess I was wrong. ziplists are applicatives.
08:29:10 <cocreature> Myrl-saki: one of the primary reasons why there is a ziplist newtype is to provide the applicative instance 
08:29:28 <Myrl-saki> cocreature: I see. I guess I've heard way wrong then.
08:29:52 <Myrl-saki> I wonder what happened. xD
08:30:49 <Myrl-saki> Also, I think I've found the correct question to ask about monads now.
08:31:01 <Myrl-saki> What are the benefits of the laws?
08:31:19 <Myrl-saki> Aside of course, from "because it keeps stuff consistent!"
08:32:41 <hpc> you can use properties that emerge from the laws to write code for you
08:32:43 <byorgey> Myrl-saki: maybe see this stackoverflow answer: http://stackoverflow.com/questions/3433608/explanation-of-monad-laws
08:32:48 <hpc> for instance, associativity
08:32:49 * hackagebot test-fixture 0.1.0.0 - Test monadic typeclasses deterministically using hooks.  https://hackage.haskell.org/package/test-fixture-0.1.0.0 (jxv)
08:33:02 <Myrl-saki> hpc: I get the associativity part.
08:33:16 <Myrl-saki> I like that part, actually.
08:33:19 <hpc> one benefit of associativity is performance optimization
08:33:27 <hpc> take Writer for instance
08:33:43 <byorgey> Myrl-saki: well, other than associativity, there are only the identity laws, which just say that 'return' creates a computation with no effects
08:34:09 <hpc> actually not Writer, just []
08:34:27 <hpc> Myrl-saki: you have likely encountered cases of terrible performance when building lists in the wrong direction
08:34:28 <Myrl-saki> Okay, let me change the question that makes people "urgh", how does the existence of the monad laws cause "impurity"(in the purest sense of impure, e.g. State), etc. etc.
08:34:45 <hpc> Myrl-saki: the wrong direction being (a ++ b) ++ c as opposed to a ++ (b ++ c)
08:34:57 <Myrl-saki> hpc: Right.
08:35:16 <hpc> Myrl-saki: you can write code to automatically translate between them, because by the Monoid associativity laws the two forms are equal
08:35:25 <Myrl-saki> hpc: INdeed.
08:35:28 <hpc> and for lists that's DList
08:35:37 <hpc> similar stuff occurs for Monad and (>=>)
08:35:46 <hpc> and that's yoneda iirc
08:35:57 <bennofs> Myrl-saki: to me, the laws just mean: "do blocks behave like a sane person would expect.": https://wiki.haskell.org/Monad_laws
08:36:04 <bennofs> (section 2)
08:36:45 <hpc> similarly, by the Monad laws you are able to get Applicative and Functor for free
08:36:54 <monochrom> the Identity monad shows that impurity is not necessary
08:37:15 <byorgey> Myrl-saki: the monad laws do not "cause impurity".
08:37:16 <Myrl-saki> monochrom: Right. I just gave that as an example.
08:37:23 <Myrl-saki> byorgey: Indeed. That was just an example.
08:37:30 <Aruro> Myrl-saki: u just pointed out they are not laws, seems no point to use/think of this word longer.
08:37:43 <Myrl-saki> Aruro: What do you mean?
08:37:58 <Aruro> Myrl-saki: i mean they are not laws, here mathematical parts ends.
08:38:16 <byorgey> Myrl-saki: I'm not sure I understand. You gave it as an example of what?
08:38:20 <Aruro> Myrl-saki: rest is speculation/observation/custom practice
08:38:26 <hpc> Myrl-saki: in general, when there are restrictions on what you are allowed to do by way of laws or the type system, you gain back invariants which you can use to generate code for you
08:38:27 <monochrom> instead, the type "m a", as opposed to naked "a", is where impurity is allowed (but sitll not forced)
08:38:50 <hpc> Myrl-saki: the logical conclusion of this is dependent types, where you can write the type of a function and it will literally be derived automatically
08:38:55 <monochrom> because now m could be something other than Identity
08:39:23 <Myrl-saki> Aruro: What are not laws?
08:39:34 <Aruro> Myrl-saki: what u called monad laws.
08:39:40 <hpc> Myrl-saki: or djinn which uses free theorems (invariants that come from the laws of the type system)
08:39:47 <Myrl-saki> Aruro: I'm pretty sure they are.
08:40:02 <Aruro> Myrl-saki: in haskell not, in math maybe
08:40:21 <Aruro> Myrl-saki: you are coming from mathematically inclined side of thinking?
08:40:57 <hackrilege> can nayone help with my paste? http://lpaste.net/163852
08:41:05 <Myrl-saki> byorgey: If I understand monochrom's explanation correctly, then I guess I was wrong to say that introducing monads allow impurity, rather, introducing monads did not disallow impurity.
08:41:34 <Myrl-saki> Aruro: More or less. Either way, the monad laws are still laws in the sense that all monads must follow them, otherwise they are faulty.
08:41:59 <monochrom> no, you understood me wrong.
08:42:22 <Myrl-saki> Woops.
08:42:33 <Aruro> Myrl-saki: they are not laws in mathematical sense, they are suggestions/good practice. You can make wrong monad instances no problem.
08:42:50 * hackagebot ilist 0.1.0.0 - Optimised list functions for doing index-related things  https://hackage.haskell.org/package/ilist-0.1.0.0 (Artyom)
08:43:02 <Aruro> Myrl-saki: in general inverse operation not always leads to id function in haskell
08:43:44 <hpc> well, they are laws in a mathematical sense, but they aren't enforced
08:44:14 <Aruro> hpc: thats why they are not laws even in mathematical sense.
08:44:27 <Myrl-saki> hpc: Is it possible that compilers might take advantage of the laws although the laws are not upheld(what's the proper term to use here)?
08:44:38 <Aruro> hpc: if you form contradiction law is not valid anymore.
08:44:41 <hpc> Aruro: you'll be hard-pressed to find any laws in haskell then ;)
08:44:46 <hpc> @hoogle unsafeCoerce
08:44:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:44:49 <Myrl-saki> monochrom: Ah, I did not see the comma.
08:44:50 <Aruro> hpc: exactly
08:45:22 <Aruro> hpc: people just tend to very much overestimate mathematical purity of haskell, that is in some sense haskell's fault.
08:45:23 <hpc> it's more useful to think of laws at a higher level than what's been made technically impossible
08:45:42 <monochrom> actually I wonder if inlining assumes a monad law.
08:45:54 <hpc> and the culture of haskell respects those laws
08:46:02 <hpc> i actually wish they would be called laws in other languages
08:46:08 <hpc> even java's toString would have laws then
08:46:23 <hpc> and we can properly reason about which laws are desirable instead of saying "java's Object class is bad"
08:47:22 <hpc> that laws are breakable arguably makes it even more important for them to be called such
08:47:27 <hpc> so you can call people out on it
08:48:25 <obadz> is there such a thing as Char8 ? I understand that Char = Unicode code point and Word8 = Byte… what's Char8 in Data.ByteString?
08:48:37 <Myrl-saki> obadz: Word8?
08:48:41 <Myrl-saki> Oh.
08:48:53 <hpc> obadz: it's Word8 with the implication that it represents the encoded bytes of a character string
08:49:28 <Myrl-saki> How does B.pack/B.unpack work? ASCII, or assumes nothing?
08:49:41 <hpc> UTF-8 iirc, but you'd need to check the docs
08:49:45 <obadz> hpc: I understand what that means?
08:49:59 <hackrilege> ^poor question
08:50:02 <obadz> hpc: a byte is a byte, no?
08:50:20 <hpc> obadz: it's like FilePath, basically
08:50:43 <hpc> there isn't any hard type called Char8, it's just a designation
08:51:12 <hackrilege> a synonym?
08:51:38 <hpc> i don't know that there's a type synonym for Char8 either, so i am speaking more broadly
08:51:47 <obadz> hpc: but the ByteString type that's in Data.ByteString is the same as the one in Data.ByteString.Char8? 
08:51:47 <hpc> in terms of intent behind the name
08:51:57 <hpc> oh i see
08:52:26 <hpc> the ByteString in D.BS.Char8 is https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/src/Data-ByteString-Internal.html#ByteString
08:52:34 <hpc> so they're the same
08:52:38 <monochrom> there is no Char8. there is only a module that has Char8 as part of the name.
08:52:48 <obadz> monochrom: what for though?
08:52:58 <Myrl-saki> monochrom: I think I got it. It's not the monad laws that inherently gives it the properties(sequenceability, mutability, ...), and instead, may in fact, be unrelated to the properties themselves. It just ensures that it follows associativity under the given "environment"
08:53:11 <etaoin> !me
08:53:13 <hpc> obadz: for representing encoding-dependent textual string values
08:53:20 <monochrom> it's a "meaningful" module name that tries to say that it uses ISO-8859-1 conventions
08:53:23 <etaoin> exit
08:54:24 <obadz> monochrom: ok thx
08:55:33 <dsm> I heard that in Haskell, only case expressions perform evaluation. then the expression (1+2) does not performs an evaluation?
08:56:05 <hpc> dsm: evaluation is sort of relative
08:56:16 <oherrala> dsm: evaluation is performed when the result is needed
08:56:27 <hpc> dsm: evaluation is dependent on other evaluation
08:56:31 <Aruro> dsm: case expressions perform only partial evaluation, until case condition is possible to resolve
08:56:34 <oherrala> if you don't know the result of (1+2), then why evaluate it?
08:56:35 <hpc> dsm: and initiated by execution (like running main)
08:56:46 <oherrala> err, don't need to know :)
08:57:12 <hackrilege> so its just a way of getting unpack to return String?
08:57:22 <hpc> dsm: result = case foo of {...} will make evaluating result dependent on evaluating foo
08:57:57 <hpc> but as mentioned, if you don't evaluate result you never get to foo anyway
08:59:33 <dsm> so every evaluation of expressions in haskell are started from initial case expression?
08:59:38 <Aruro> dsm: haskell is partially declarative language it means you can just write essays from programs and nothing happens, because u just Describe things. Untill u need them evaluated.
09:00:59 <Aruro> dsm: a = 1+2  is a declarative description of what a is, there is no evaluation involved.
09:02:04 <hpc> dsm: here's an example
09:02:12 <hpc> dsm: open ghci, type let a = 1 + 2
09:02:17 <hpc> dsm: then type :sprint a
09:02:25 <hpc> it will show you what has been evaluated so far
09:02:28 <hpc> dsm: then type print a
09:02:31 <hpc> then :sprint a again
09:02:51 * hackagebot gi-atk 2.0.1 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.1 (inaki)
09:02:53 * hackagebot gi-cairo 1.0.1 - Cairo bindings  https://hackage.haskell.org/package/gi-cairo-1.0.1 (inaki)
09:02:55 * hackagebot gi-gdk 3.0.1 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-3.0.1 (inaki)
09:02:57 * hackagebot gi-gdkpixbuf 2.0.1 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-2.0.1 (inaki)
09:02:59 * hackagebot gi-gio 2.0.1 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.1 (inaki)
09:03:07 <hpc> actually don't do that, it's a bad example for silly reasons
09:03:21 <hpc> let a = Just (1 + 2)
09:03:40 <hpc> hmm
09:03:41 <Aruro> hpc: wish, lambdabot had :sprint
09:04:02 <hpc> don't do that either, i need to remember how :sprint works and i have to take a call here shortly
09:04:11 <hpc> but check out :sprint, it's awesome
09:04:56 <hpc> okay, this one works
09:05:06 <monochrom> beware that if a gets the type "Num a => a", then even after you have evaluated a for 10 times, a will still remain unevaluated. (do you see why?)
09:05:08 <hpc> i think it had to do with Num constraints and polymorphism
09:05:10 <hpc> use let a = id (Just ())
09:05:32 <hpc> Just () is monomorphic, and id makes it not get reduced right away
09:05:42 <monochrom> in general, numbers are the worst examples in Haskell.
09:05:53 <monochrom> stick with Char and Bool.
09:06:07 <monochrom> and (), yeah
09:06:21 <Aruro> > let a = [True,False,True]
09:06:23 <lambdabot>  <no location info>: not an expression: ‘let a = [True,False,True]’
09:06:33 <monochrom> lambdabot is not ghci
09:06:47 <Aruro> sadly
09:07:24 <Myrl-saki> Hahaha, I like this post. http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
09:07:24 <hpc> dsm: and for a slightly more elaborate example
09:07:25 <hpc> Prelude> let a = id (Just (id False))
09:07:25 <hpc> Prelude> seq a ()
09:07:26 <dsm> i think let a = "abcd" is working
09:07:43 <hpc> i remember :sprint working a bit oddly with strings
09:07:47 <hpc> and lists in general
09:07:54 <Myrl-saki> Really though, Haskell also broke me. I can't program on anything but Haskell now.
09:08:01 * hackagebot gi-girepository 1.0.1 - GIRepository (gobject-introspection) bindings  https://hackage.haskell.org/package/gi-girepository-1.0.1 (inaki)
09:08:03 * hackagebot gi-glib 2.0.1 - GLib bindings  https://hackage.haskell.org/package/gi-glib-2.0.1 (inaki)
09:08:05 * hackagebot gi-gobject 2.0.1 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-2.0.1 (inaki)
09:08:07 * hackagebot gi-gst 1.0.1 - GStreamer bindings  https://hackage.haskell.org/package/gi-gst-1.0.1 (inaki)
09:08:09 * hackagebot gi-gstaudio 1.0.1 - GStreamerAudio bindings  https://hackage.haskell.org/package/gi-gstaudio-1.0.1 (inaki)
09:08:11 <Aruro> Myrl-saki: yeah :D common symptom
09:08:12 <hpc> but it's being strict on a ton of stuff for me, and it sounds like you're getting the hang of it anyway
09:08:22 <hpc> there's a weird anti-breaking point
09:08:25 <Myrl-saki> My Java code is very Haskelly, for example. "Do I need something? Oh, I guess I'll just make another object and concatenate from that."
09:08:43 <hpc> where you get comfortable enough with haskell that it bleeds into other languages in a way that makes you appreciate them more
09:08:47 <Myrl-saki> s/concatenate/compose/
09:08:51 <hpc> i got that with perl something hard
09:09:01 <hpc> and i still like perl better for functional programming
09:09:07 <dsm> then what's the difference between case expression's inspection(or pattern matching?) of expression and evaluation?
09:09:24 <dsm> perform of inspection is perform of evaluation?
09:09:30 <Myrl-saki> OHHHH, I now know what I'm doing.
09:09:37 <Myrl-saki> I'm using objects to substitute for partial functions!
09:09:37 <monochrom> pattern matching is one of the main drivers of evaluation
09:09:46 <Myrl-saki> Something like
09:10:02 <Myrl-saki> x = new Foo(bar); Foo.bar(baz);
09:10:04 <monochrom> so I wouldn't actually say "there is a difference"
09:10:29 <Myrl-saki> It made me very confused since, it feels like Haskell, but I'm not exactly sure which part was Haskell. I just realized it right now.
09:10:48 <dsm> are there any other driver of evaluation besides case expression?
09:11:07 <hpc> a few
09:11:07 <Myrl-saki> dsm: IO?
09:11:15 <hpc> execution initiates evaluation to begin with
09:11:28 <hpc> bang patterns, seq
09:11:29 <Aruro> dsm: there is a function for it called seq
09:11:41 <hpc> strictness annotations on data declarations
09:11:50 <hpc> newtypes if you want to stretch the idea a bit
09:11:55 <dsm> thanks, it makes sense
09:12:08 <hpc> and foreign types are generally strict as well
09:12:26 <hpc> (by not being boxed and such)
09:12:26 <Myrl-saki> hpc: Trying to think of a politics pun..
09:12:44 <hpc> we'll build a wall and make the thunks pay for it
09:12:54 <hpc> *we'll build a -Wall
09:12:55 <Myrl-saki> hpc: There we go.
09:13:11 * hackagebot gi-gstbase 1.0.1 - GStreamerBase bindings  https://hackage.haskell.org/package/gi-gstbase-1.0.1 (inaki)
09:13:13 * hackagebot gi-gstvideo 1.0.1 - GStreamerVideo bindings  https://hackage.haskell.org/package/gi-gstvideo-1.0.1 (inaki)
09:13:15 * hackagebot gi-gtk 3.0.1 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.1 (inaki)
09:13:17 * hackagebot gi-gtksource 3.0.1 - GtkSource bindings  https://hackage.haskell.org/package/gi-gtksource-3.0.1 (inaki)
09:13:19 * hackagebot gi-javascriptcore 3.0.1 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-3.0.1 (inaki)
09:14:16 <dolio> Oh boy.
09:15:01 --- mode: ChanServ set +q *!*@li229-222.members.linode.com
09:15:10 --- mode: ChanServ set +o dolio
09:29:59 <oftl> hi
09:30:05 <oftl> why is it, that the last element of a list can not be followed by a comma (like [ 1, 2, 3, ] ) ?
09:30:51 <Xandaros> Is there a class similar to Monoid, but where the composition method is ‘a → b → a’ instead of ‘a → a → a’? In my particular case, b is a part of a and you can add more b's all you want, but two a's are not composable. (Well, I could make them composable, but it doesn't make complete sense)
09:31:03 <puregreen> oftl: I don't think there's a deep reason, it's just how it is (in some languages commas are separators, in some they are terminators)
09:31:16 <obadz> Xandaros: would have to be a MultiParamTypeClass
09:31:23 <Xandaros> it would
09:31:34 <obadz> feels a bit like Foldable
09:32:10 <puregreen> or like Cons
09:32:25 <puregreen> (from any listlike library)
09:33:18 <monochrom> what does "b is part of a" mean?
09:33:38 <monochrom> even Int is not "part of" Integer
09:33:47 --- mode: dolio set -q hackagebot!*@*
09:33:50 --- mode: dolio set -o dolio
09:33:54 <monochrom> and Identity is not "part of" Maybe.
09:34:06 --- mode: ChanServ set +o dolio
09:34:14 <Xandaros> The concrete type of this ‘a’ is: ‘data CDDL Text Rules’. Of particular interest might be, that ‘Rules’ is a Monoid
09:34:27 <Xandaros> data CDDL = CDDL Text Rules
09:35:16 --- mode: ChanServ set -q *!*@li229-222.members.linode.com
09:35:28 --- mode: dolio set -o dolio
09:36:03 <Xandaros> You can combine a CDDL with more Rules, but you can't combine two CDDLs (a CDDL has a ‘main’ rule, determined by the Text thing. Currently considering just discarding the one from the right CDDL, but that seems a bit dirty to me)
09:37:46 <dolio> Is b a monoid? If so, then a -> b -> a is a monoid action of b on a.
09:38:09 <dolio> Well, that's not true, I suppose, but it might be true.
09:38:13 <monochrom> yeah, except there may be no existing type class for it.
09:38:41 <dolio> Yes, if that's the question, then the answer is no. :)
09:38:44 <monochrom> but I wouldn't look for a type class, unless and until I have 3 use cases.
09:38:55 <dolio> Maybe not even then.
09:40:24 <Xandaros> I thought b was a monoid, but it's actually a Semigroup. Shouldn't make a difference, though
09:40:52 <Xandaros> Guess I'll just have a specific function, then
09:50:42 <dolio> If you don't want to write one function to refer to a specific function, it's easy to accomplish that by taking a function as a parameter. Using a type class for the same thing requires agreeing on a specific name to refer to multiple functions, so it's arguably more specific.
09:57:53 * hackagebot data-function-meld 0.1.0.0 - Map the arguments and return value of functions.  https://hackage.haskell.org/package/data-function-meld-0.1.0.0 (erisco)
09:58:29 <erisco> I figured this needed to be on Hackage somewhere, so there it is :)
09:59:03 <zzzzz> hello, I do need a type with two properties. 1. there is a fast 'String -> t' fun 2. the 'Ord t' instance is reasonably fast. can anybody give me a hint?
10:00:36 <hsk3> Am I correct that the real purpose of using the MaybeT IO monad - or rather, where the MaybeT IO monad truly shines - is where you have functions that return IO (Maybe a)? In other words, where you have IO actions that can possibly return Nothing, in which case you want the whole thing to stop?
10:01:18 <lyxia> hsk3: yes
10:01:38 <lyxia> zzzzz: t = ()
10:02:05 <hsk3> lyxia: After all, stopping at Nothing is one of the main purposes of the Maybe monad. So what I described above is how you get to benefit from both the IO and Maybe monads at once.
10:02:08 <hsk3> Am I thinking about this right?
10:02:18 <zzzzz> lyxia: how about no? :)
10:02:20 <lyxia> zzzzz: more seriously, take a look at hashable
10:02:37 <lyxia> are you not looking for a hashing function?
10:03:11 <lyxia> hsk3: yeah that's pretty much it
10:03:30 <hsk3> lyxia: So sweet, thank you!!!
10:03:42 <hsk3> beautiful monads
10:03:50 <lyxia> erisco: the build failed!
10:04:03 <erisco> lyxia, oh noes! what is the error?
10:04:38 <lyxia> erisco: I mean on hackage
10:05:16 <erisco> yeah, hm, I don't know
10:05:34 <erisco> it installed locally for me
10:06:04 <jle`> hsk3: the Monad instance isn't the only useful thing about the MaybeT newtype wrapper
10:06:11 <jle`> there's a nic Alternative instance, too
10:06:20 <erisco> if it cannot resolve the base package then I dunno what to do about that
10:06:47 <jle`> zzzzz: what sort of types are you looking for?
10:06:56 <jle`> zzzzz: that's a very general question
10:06:56 <zzzzz> lyxia: it depends. it depends on what the compiler does to my code. I do have code (https://github.com/sachs4/servant/blob/rate-limit/servant-server/src/Servant/Server/Internal.hs#L542) which indexes a Map (https://github.com/sachs4/servant/blob/rate-limit/servant-server/src/Servant/Server/Internal/RateLimit.hs#L81) with a String obtained via symbolVal (https://github.com/sachs4/servant/blob/rate-limit/servant-server/src/Servant/Ser
10:07:01 <erisco> anyways, it lets you map function arguments and return values for functions of any arity
10:09:42 <zzzzz> jle`: does this make my situation clear?
10:11:58 <lyxia> erisco: neat
10:17:36 <dfeuer> I do not like this asymmetry. I don't know if I'm willing to go to the trouble of eliminating it.
10:17:54 * hackagebot telegram-api 0.4.0.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.4.0.0 (klappvisor)
10:24:54 <dfeuer> Ffff
10:28:39 <hackrilege> i have massaged my code to give a meaningful error, could someone take a look, im stumped; http://lpaste.net/163857
10:29:14 <MichaelBurge_> Is there a way to automatically add an 'location :: CallStack => ...' implicit global to every function in a module? Can you rewrite existing functions with Template Haskell?
10:29:51 <erisco> anyone know what this build error is? http://hackage.haskell.org/package/data-function-meld-0.1.0.0/reports/1 "rejecting: base-4.8.2.0/installed-0d6..."
10:31:12 <MichaelBurge_> erisco: That looks like Cabal Hell. You can work around it by using a sandbox, or a tool like Stack
10:31:36 <geekosaur> except that's on a buildbot, and those are already sandboxed
10:31:53 <MichaelBurge_> Oh good point
10:32:59 <geekosaur> and what that error is telling me is that the package's dependencies don't permit ghc 7.10
10:33:16 <hackrilege> ancient package
10:33:26 <MichaelBurge_> erisco: I think you're using GHC 7.10, but you've listed in the cabal file base < 4.8, which is the version for 7.10.
10:33:28 <erisco> I see, okay
10:33:28 <MichaelBurge_> https://wiki.haskell.org/Base_package
10:33:41 <erisco> I just kept whatever cabal init gave me
10:33:54 <erisco> this is the .cabal here https://github.com/erisco/data-function-meld/blob/master/data-function-meld.cabal
10:34:03 <erisco> how do I determine the correct version of base?
10:34:27 <MichaelBurge_> erisco: See the table here: https://wiki.haskell.org/Base_package
10:35:06 <hackrilege> could anyone talk me through this type error? http://lpaste.net/163857
10:35:25 <erisco> hm… should I have an upper limit on the base version at all?
10:35:27 <hackrilege> im not so strong with nested Monads of different types
10:35:44 <bluezone> help me please
10:36:31 <hackrilege> erisco, yes, its a good idea to predict when your code might expire, but you could change that restriction and hope it works and update it if it doesnt
10:36:41 <hackrilege> whats up bluezone?
10:36:45 <erisco> perhaps change it to <4.9 then
10:37:07 <erisco> and I can drop the min to >=4.0
10:37:15 <bluezone> hackrilege: I am a javascript developer and I want to shoot myself because of this new project codebase
10:37:17 <hackrilege> there could be many conventions that have changed and not work now
10:37:45 <hackrilege> is this a haskell question?
10:38:43 <erisco> hopefully flip, (.), and ($) don't go out of Prelude… 
10:38:47 <Cale_> bluezone: You can use GHCJS to compile Haskell to Javascript now. :D
10:38:49 <erisco> well hell, I can just redefine those locally and not use prelude at all
10:39:06 <erisco> but that might be tinfoil hat crazy
10:39:17 <hackrilege> you need a lot of Prelude...
10:39:32 <erisco> I am just using (.), flip, and ($)
10:39:34 <bluezone> Cale_: hackrilege yes, I'm also too stupid to learn haskell -.-
10:39:51 <bluezone> and not sure if it will help my predicaments anyway
10:39:56 <hackrilege> i hope things improve!
10:40:32 <hackrilege> ok, perhaps a js irc would be better for you, we just talk about haskell here
10:41:21 <bluezone> if only the other communities were as nice as haskell :(
10:42:08 <hackrilege> ok, thats enough, if you dont have any haskell questions you shouldnt be here, your basically trolling us
10:42:55 * hackagebot hakyll-contrib-elm 0.1.0.0 - Compile Elm code for inclusion in Hakyll static site.  https://hackage.haskell.org/package/hakyll-contrib-elm-0.1.0.0 (narrative)
10:42:59 <hackrilege> Cale_ can i get a high five for my code? http://lpaste.net/163857
10:43:01 <jle`> bluezone: you don't need to be a super genius to learn haskell ^^ haskell is probably one of the easiest languages to learn
10:43:07 <erisco> I think this means my other packages are screwed up on Hackage :P
10:43:13 <simpson> bluezone: What was your original question, sorry?
10:43:14 <jle`> much easier than C, java, python, javascript, etc.
10:43:16 <erisco> I didn't realise base was being restricted so severely
10:43:23 <Cale_> bluezone: I actually find it more fun working on the frontends using reflex-dom, our functional reactive system for dynamically controlling the DOM, than working on the backend now.
10:43:51 <Cale_> (even if it does mean coming into contact with CSS every so often)
10:47:10 <erisco> hrm, I thought I had 7.10 installed…
10:47:15 <hackrilege> anyone!? http://lpaste.net/163857
10:47:38 <erisco> ah maybe not, that is just recently in March isn't it
10:49:25 <monochrom> I installed 7.10.3 in December
10:49:36 <hackrilege> usr/bin/ghc --version
10:50:05 <erisco> monochrom, early adopter? :)
10:51:52 <monochrom> if you thought it through, you wouldn't say that. it's 7.10.3, not 7.10.1.
10:52:54 <monochrom> it's a bugfix release, so there is nothing brave in switching to it when it was released, assuming one has already gone 7.10.x already.
10:53:17 <monochrom> in fact, it takes extreme bravity to skip a bugfix release
10:54:08 <erisco> extreme eh… well it seems I am a year behind… 7.10.1 was March last year, not this year, whoops
10:54:39 <hackrilege> i dont understand this type error, this is as close as i can get it to work, its really tricky can anyone help? http://lpaste.net/163857
10:55:45 <hackrilege> im not sure i think maybe im using (=<<) over 2 different monads...
10:56:53 <lyxia> which is it supposed to be
11:01:12 <karanlearnshaske> hello room.
11:01:31 <karanlearnshaske> i am reading LYAH and have a doubt thats hard to stop worrying about.
11:01:38 <karanlearnshaske> in this code 
11:02:07 <karanlearnshaske> quicksort :: (Ord a) => [a] -> [a]     quicksort [] = []     quicksort (x:xs) =          let smallerSorted = quicksort (filter (<=x) xs)           biggerSorted = quicksort (filter (>x) xs)        in  smallerSorted ++ [x] ++ biggerSorted 
11:02:21 <lyxia> @lpaste karanlearnshaske 
11:02:21 <lambdabot> Haskell pastebin: http://lpaste.net/
11:02:32 <hackrilege_> lpaste.net
11:02:34 <hpc> karanlearnshaske: your concern is probably correct
11:02:35 <karanlearnshaske> sorry.
11:03:17 <hackrilege_> whats the concern?
11:03:44 <karanlearnshaske> http://lpaste.net/163859
11:03:48 <karanlearnshaske> on line 5 
11:04:13 <karanlearnshaske> why are there round brackets   biggerSorted = quicksort (
11:04:18 <karanlearnshaske> after quicksort
11:04:30 <hpc> ah
11:04:31 <karanlearnshaske> why cant i omit the round brackets and write it as 
11:04:48 <karanlearnshaske> biggerSorted = quicksort filter (>x) xs  
11:04:54 <jasonmason> because without them you would pass 3 arguments to quicksort, filter, (>x) and xs
11:05:03 <hpc> when you write f a b c, that translates to (((f a) b) c)
11:05:10 <jasonmason> instead of passing the result of filter (>x) xs
11:05:17 <hackrilege_> you could write quicksort $ filter (>x) xs
11:05:26 <hpc> the parens say that quicksort is only getting one parameter, the expression (filter (>x) xs)
11:05:42 <hackrilege_> a $ b c = a (b c)
11:06:01 <hackrilege_> @ src ($)
11:06:04 <hackrilege_> @src ($)
11:06:04 <lambdabot> f $ x = f x
11:06:27 <karanlearnshaske> wow. thank you all very much. 
11:06:47 <karanlearnshaske> this was better than internet search. thanks
11:08:02 <karanlearnshaske> agree with jasonmason , hpc , hackrilege_
11:08:12 <hackrilege_> is (quicksort . filter . (>x)) xs also correct?
11:08:15 <karanlearnshaske> i also understood $ now
11:08:35 <hpc> :t let quicksort = undefined :: [a] -> [a] in \x -> (quicksort . filter . (>x))
11:08:37 <lambdabot>     Couldn't match type ‘[a0] -> [a0]’ with ‘[a1]’
11:08:37 <lambdabot>     Expected type: (a0 -> Bool) -> [a1]
11:08:38 <lambdabot>       Actual type: (a0 -> Bool) -> [a0] -> [a0]
11:08:41 <hpc> karanlearnshaske: don't think so
11:08:45 <hpc> er hackrilege_
11:08:53 <hackrilege_> hmm nvm
11:09:08 <lyxia> hackrilege_: remove the second dot
11:09:10 <hpc> :t let quicksort = undefined :: [a] -> [a] in (quicksort . filter . (>))
11:09:11 <lambdabot>     Couldn't match type ‘[a1] -> [a1]’ with ‘[a]’
11:09:12 <lambdabot>     Expected type: (a1 -> Bool) -> [a]
11:09:12 <lambdabot>       Actual type: (a1 -> Bool) -> [a1] -> [a1]
11:09:36 <hackrilege_> (quicksort . (filter (>x))) xs
11:10:02 <andromeda-galaxy> :t (quicksort . (filter (>x)) xs
11:10:04 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:10:40 <jasonmason> don't need parens around filter (>x)
11:10:43 <erisco> oh my god Hackage -.- it won't take any tar I send it
11:11:05 <erisco> complains it is in the old something 7 format, now complains it is in the GNU tar format
11:11:08 <erisco> what does it want
11:11:45 <lyxia> yeah it's a mess
11:12:00 <glguy> erisco: What are you trying to upload? A package or documentation?
11:12:12 <srhb> glguy: Does the answer depend on that? :|
11:12:19 <hackrilege_> :( http://lpaste.net/163857
11:12:45 <glguy> If the answer is "a package" then use cabal sdist and it'll be in the right format, but that's specific to packages, so yeah
11:13:01 <lyxia> hackrilege_: which monad is this bind supposed to work with
11:13:04 <hackrilege_> i dont understand the types its giving me on line 77
11:13:06 <puregreen> and if “documentation” then use neil (otherwise your links will be broken anyway)
11:13:16 <hackrilege_> Maybe
11:13:17 <glguy> if the answer is documentation then there are pre-existing scripts like the one I wrote and use for lens and other things
11:14:16 <lyxia> hackrilege_: drop the bind
11:15:16 <hackrilege_> fmap also does not work
11:15:32 <lyxia> hackrilege_: (duplicate'2 f :: Maybe (FLZ a) -> Maybe (FLZ a)), (iterate's ... :: Maybe (FLZ a))
11:15:42 <lyxia> you can just apply
11:15:59 <lyxia> I dunno if what the semantics you want are though
11:16:07 <lyxia> -if
11:16:51 <hackrilege_> apply=fmap?
11:16:53 <erisco> glguy, right now I am trying to get it to accept the contents of the doc archive
11:17:01 <erisco> I can't figure out the correct structure for it
11:17:17 <lyxia> hackrilege_: ($)
11:17:19 <glguy> erisco: This is how I generate docs for packages: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
11:17:34 <hackrilege_> that also does not work!
11:18:03 <hackrilege_> Expected type: FLZ a -> Maybe (FLZ a)
11:18:04 <hackrilege_>    Actual type: a -> Maybe a
11:18:13 <lyxia> it's another error
11:18:45 <lyxia> but as I said maybe my "fix" wasn't one
11:18:46 <hackrilege_> true...
11:18:58 <hackrilege_> ah ok
11:19:09 <hackrilege_> no i really cant figure it out its nasty
11:19:35 <lyxia> hackrilege_: what's the type of f left'
11:19:43 <lyxia> hackrilege_: and what's the type of iterate'2
11:20:00 <lyxia> how do you resolve the mismatch
11:20:54 <hackrilege_> there is a mismatch?
11:22:30 <hackrilege_> i constrained the types at line 59 to be what i thought they should be
11:22:33 <erisco> glguy, it doesn't accept gzipped archives, so that seems strange
11:22:34 <lyxia> hackrilege_: iterate'2 :: (FLZ a -> Maybe (FLZ a)) -> ... ; f left' :: a -> Maybe (FLZ a) -- yes
11:22:50 <lyxia> a -> Maybe a
11:22:55 <erisco> File in tar archive is not in the expected directory "data-function-meld-0.1.0.0-docs"  I don't know what this means
11:22:58 <hackrilege_> aha
11:22:59 <hackrilege_> thanks
11:23:10 <hackrilege_> thats hopeful
11:23:25 <hackrilege_> no...
11:23:35 <hackrilege_> left' :: FLZ a -> Maybe (FLZ a)
11:24:15 <hackrilege_> === b -> Maybe b
11:24:34 <lyxia> erisco: did you tar the directory with that name precisely with -docs?
11:25:11 <lyxia> hackrilege_: but then that's not *any* b
11:25:14 <hackrilege_> sorry, left' :: LZ (FLZ a) -> Maybe (LZ (FLZ a))
11:25:58 <erisco> grr
11:26:21 <lyxia> hackrilege_: duplicate'2 wouldn't work with any a
11:26:35 <erisco> the archive was not being created like how I thought it was
11:26:45 <erisco> okay, docs uploaded, but still no docs on Hackage oO
11:27:05 <lyxia> it takes about a minute
11:27:33 <erisco> ah ha there we go, great
11:27:47 <EggsAndSausage> hi! is there a way to end a parser (using trifecta) in a case statement without calling unexpected?
11:28:13 <hackrilege_> duplicate'2 :: ((LZ (FLZ a) -> Maybe (LZ (FLZ a))) -> ((FLZ a) -> Maybe (FLZ a))) -> Iso (Maybe (FLZ (FLZ a)))
11:28:17 <hackrilege_> still does not work"
11:28:22 <hackrilege_> !
11:28:42 <erisco> I don't know how to rerun the build on Hackage… I edited the dependencies to relax the base version, it should work now
11:29:18 <hackrilege_> you edited the .cabal file and now you want to reupload it?
11:29:41 <erisco> I edited it on Hackage directly
11:29:55 <hpc> have you tried turning it off and on again?
11:30:49 <erisco> let me ssh into Hackage and eject the CD tray
11:31:06 <hpc> no, you ssh into hackage2 and eject the cd tray
11:31:12 <hpc> which then presses the power button on hackage
11:34:05 <hackrilege> im no closer to understanding this error...
11:35:14 <lyxia> hackrilege: one too many FLZ at the end
11:35:25 <lyxia> and with ($) I have it compiling
11:35:34 <lyxia> but still no idea what you're trying to do
11:36:43 <hackrilege> could you annotate the paste? im not sure what you mean one less FLZ, pretty sure it needs two for duplicate...
11:37:46 <lpaste_> lyxia annotated “type error handeling Maybe” with “type error handeling Maybe (annotation)” at http://lpaste.net/163857#a163864
11:39:43 <numberten> for a given ADT can you construct a generalized type for all value constructors? e.g. type Foo = {- something -} such that Left :: Foo and Right :: Foo
11:39:46 <numberten> (for Either a b)
11:39:56 <hackrilege> sorry...
11:40:37 <lyxia> numberten: type Foo = Either a b?
11:40:48 <numberten> Left isn't of type Either a b
11:40:51 <lyxia> ah, right
11:40:54 <numberten> it's of type a -> Either a b
11:40:57 <numberten> etc
11:41:01 <lyxia> a -> Either a a
11:41:21 <lyxia> it doesn't work in general because constructors may have different arities
11:41:35 <numberten> yeah but that's a specialization of Either a b 
11:41:38 <numberten> yeah
11:41:50 <numberten> I was thinking some solution to that problem of a and b being different
11:41:57 <numberten> could solve the arity problem
11:42:02 <numberten> after you uncurry
11:42:11 <numberten> because then you just have different sized tuples
11:47:53 <mibbit123> hi
12:06:04 <c_wraith> hello
12:06:25 <c_wraith> (what's a 20 minute wait for a response?) 
12:06:32 <MichaelBurge_> I think he left already
12:07:46 <MichaelBurge_> What's a good way to add error reporting to a web service? I'm considering turning values of type 'a' into type '(?l :: CallStack) => CallStack -> a'
12:07:58 * hackagebot haskell-kubernetes 0.4.0 - Haskell bindings to the Kubernetes API (via swagger-codegen)  https://hackage.haskell.org/package/haskell-kubernetes-0.4.0 (aaronlevin)
12:08:08 <MichaelBurge_> That not only gets me a callstack at the function site, but forces its caller to provide an entry too so I don't accidentally miss spots.
12:08:30 <MichaelBurge_> Can you modify existing functions with TH to automatically add the implicit Callstack variable?
12:09:48 <c_wraith> TH can only create new declarations, not change existing ones. 
12:10:20 <MichaelBurge_> You can also get callstacks with the RTS, but that requires my site to run with profiling enabled all the time.
12:20:32 <davidkart> hi
12:20:38 <davidkart> I'm trying to run this : http://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf
12:20:52 <davidkart> I'm independant learner that's not really homework
12:21:04 <davidkart> But I'd like to know what is wrong in this example.
12:21:35 <shapr> davidkart: have you tried to fix it?
12:22:04 <davidkart> look at this boiler plate with comments of my own : http://vpaste.net/jskrR
12:22:15 <davidkart> shapr : i'm trying since 1 hour at least.
12:22:48 <davidkart> I want to parse messages of this types : "E 70 3 Way too many pickles"
12:22:55 <davidkart> or "W 5 Flange is due for a check-up"
12:23:18 <davidkart> The data constructor uses the first word to determine the type of message (error, warning or information)
12:23:49 <davidkart> if the message is an error, then you have an additionnal error code
12:24:20 <davidkart> Well to put it bluntly I don't know how to structure my code. The most logical would be to check each word of the string and use branchings
12:24:35 <davidkart> In a much known imperative fashion
12:24:49 <davidkart> If I try to break into pieces the functions it gets too generic
12:25:26 <shapr> davidkart: are you allowed to use parsec for this assignment?
12:25:35 <davidkart> parsec ?
12:25:40 <asthasr> davidkart, what does the other number mean?
12:26:14 <asthasr> i.e. E 70 3 -- which is the error code? W 5 -- what is the 5?
12:26:29 <davidkart> No but read, unword, words, and so on : "You can use the read function. Other functions which may (or may not) be useful to you include lines, word, unwords, take, drop, and (.).
12:26:37 <shapr> ah, ok
12:26:39 <davidkart> (don't know what the last is typically).
12:26:47 <asthasr> . is "compose"
12:26:50 <shapr> davidkart: perhaps a case statement after using words?
12:26:51 <davidkart> I feel this assignment a little bit fishy.
12:27:01 <asthasr> it's not fishy, why would it be?
12:27:29 <shapr> davidkart: given the tools you just listed, I'd cut the input at spaces (words) and then throw the first word into a case statement
12:27:31 <davidkart> shapr: yeah, probably the most direct way.
12:27:43 <davidkart> yeah
12:27:59 <davidkart> I'm still trying to wrap my head into haskell programming
12:28:14 <pantsman-> I was hoping not to be reminded of the pickle-flange interactions I've had. :-(
12:28:40 <davidkart> pantsman-: ?
12:28:52 <davidkart> shapr: I was trying to use guards
12:29:08 <shapr> davidkart: guards are the same as case statement, so that could work
12:29:17 <pantsman-> you may have been overthinking it. The "imperative way" you describe is just matching, which is a core part of FP.
12:29:19 <davidkart> shapr: the problem is what I do next.
12:29:39 <shapr> davidkart: each branch constructs something from the datatype?
12:30:08 <davidkart> basically, if it's an error message, I need to get the error code, then get back to « usual parsing » (common to all message types).
12:30:08 <pantsman-> each branch gets the rest of the list of tokens (words), with the first one having been consumed
12:30:37 <davidkart> how do I throw away the head of the list and call the next function on the remaining objects ?
12:30:38 <shapr> case firstchar of 'I' -> Info
12:30:53 <davidkart> pantsman-: ok
12:30:54 <shapr> davidkart: you could cut the list into lines first
12:31:16 <davidkart> basically I let "words" do it, and I feed "parseMessage" with a list of strings.
12:31:23 <pantsman-> davidkart, by pattern matching on the first cons cell of the word list. case line of ("I":tail) -> (do something with tail)
12:31:37 <shapr> parseLines (line:lines) = parseMsg line : parseLines lines
12:31:40 <davidkart> ok (*enlighted*)
12:31:55 <shapr> davidkart: or you could map parseMsg over a list of lines
12:33:49 <asthasr> ("W":sev:ts:message)
12:33:50 <shapr> davidkart: I like the lazy list approach because you can just grab a few at a time that way
12:33:54 <asthasr> er, with E not W
12:34:05 <davidkart> ok. I know it sounds weird,but the lazy thing is my problem.
12:34:24 <shapr> davidkart: my favorite example is this:
12:34:30 <shapr> > let ones = 1 : ones in take 15 ones
12:34:32 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
12:34:47 <shapr> davidkart: you know that colon adds things to a list, right?
12:34:53 <davidkart> asthasr: this way sounds mostly correct ; how do I manage errors ?
12:34:55 <davidkart> no
12:34:59 <davidkart> (no shapr)
12:35:16 <shapr> > 1:2:[]
12:35:18 <lambdabot>  [1,2]
12:35:22 <shapr> > 1:2:[] == [1,2]
12:35:28 <lambdabot>  True
12:35:36 <davidkart> oh this, yes I knew
12:35:37 <asthasr> davidkart, Errors in the sense of "incorrectly formatted log messages" or errors in the sense of "E 70 5 some message"
12:35:47 <davidkart> the first.
12:36:14 <asthasr> is it a requirement of the problem?
12:37:00 <shapr> davidkart: so the list named ones has a first element 1, and the rest of the list is something else, so when the second element is request, go look that up (the rest of the list is something named ones) and the first element of THAT is 1, and so on infinitely
12:38:27 <davidkart> asthasr: one could think that yes.
12:38:43 <davidkart> If it was with guards, I'd use otherwise key word
12:39:02 <shapr> > otherwise == True
12:39:06 <lambdabot>  True
12:42:27 <davidkart> there is no « anything else » statement with case ?
12:42:49 <geekosaur> use a wildcard pattern
12:42:59 * hackagebot hakyll-contrib-elm 0.1.0.1 - Compile Elm code for inclusion in Hakyll static site.  https://hackage.haskell.org/package/hakyll-contrib-elm-0.1.0.1 (narrative)
12:43:01 <davidkart> _ -> Unknow s
12:43:38 <davidkart> parse erro on input
12:44:58 <asthasr> use Either and return Left "invalid log message"
12:46:32 <davidkart> Either ?
12:47:12 <davidkart> it's wearying that it's not working as expected.
12:47:28 <davidkart> I already have all the good types to manage errors.
12:48:00 * hackagebot hakyll-contrib-csv 0.1.0.2 - Generate Html tables from Csv files  https://hackage.haskell.org/package/hakyll-contrib-csv-0.1.0.2 (narrative)
12:50:10 <davidkart> few
12:50:36 <davidkart> let's get something simpler
12:52:28 <davidkart> can you think of a one liner to read 8 integers from stdin, one on each line and return them as a list ?
12:53:04 <c_wraith> do imports count against lines needed? 
12:53:09 <davidkart> no
12:53:35 <davidkart> I want to do the following thing : readLines until EOF, then convert that list into integers.
12:54:12 <kunja> this is a dumb question, but once i started using mtl a sizeable amount of my applications' code are using do notation, or the applicative style. less parameters being passed around and more StateT and ReaderT "passing" things through.
12:54:16 <kunja> is that normal?
12:54:38 <c_wraith> :t replicateM 8 readLn
12:54:39 <lambdabot> Read a => IO [a]
12:55:15 <c_wraith> davidkart, ^ will work. 
12:55:26 <kunja> it feels imperative, just with annotations on the type that show which capabilities i have for that function.
12:55:31 <maerwald> kunja: it can be an anti-pattern, but that's hard to say in general
12:55:59 <kunja> maerwald: when do you draw the line, very generally?
12:56:20 <jle`> kunja: sometimes you can try to isolate the "effectful" parts of your code
12:56:36 <jle`> for example, if foo f x y = bar <$> x <*> y, you can just not provide foo and just provide bar
12:56:50 <maerwald> kunja: I always start with explicit parameters style and only if that starts to get really weird and overcomplicated, I refactor it into something
12:57:04 <jle`> also, if you're using mtl for your applications, there isn't really any reason to work with StateT or ReaderT in your logic
12:57:19 <kunja> the logic uses MonadReader and MonadState
12:57:29 <jle`> ah yeah, then that makes sense
12:57:43 <kunja> i was always using explicit parameters
12:57:51 <davidkart> what's wrong : http://vpaste.net/oxbwh ?
12:58:07 <sm> c_wraith: for extra credit.. a command-line one-liner ?
12:58:07 <jle`> using MonadState s m instead of the s -> (a, s) pattern whenever possible makes sense, I think
12:58:17 <jle`> especially because it leads to composable code
12:58:18 <jasonmason> david youre missing main IO action
12:58:30 <kunja> but the parts where i'm using is where the network comes into play, and i thought having a storage location for configuration would be in ReaderT, while the actual credentials that get shared are in a StateT
12:58:31 <jle`> MonadReader r m instead of r -> .. is a bit less clear-cut
12:58:34 <davidkart> can you tell me how to clear this ?
12:59:04 <nitrix> m-renaud: Have you figured out the issue with the foldl'?
12:59:07 <kunja> so if they expire i can just modify them, but the configuration is read-only. i'm new to mtl.
12:59:30 <jle`> yeah, i definitely see how MonadState s m => ... leads to more composable code in general, i don't think there's much issue with that
12:59:32 <jasonmason> :t replicateM 8 getLine
12:59:36 <lambdabot> IO [String]
12:59:37 <jle`> especially because the alternative is so unweildy
12:59:43 <jle`> MonadReader is less clear-cut
12:59:58 <jasonmason> :t replicateM 8 getLine >>= mapM putStrLn
13:00:00 <lambdabot> IO [()]
13:00:00 <kunja> but since the application has IO in the bottom of the stack, something that can blow up gets a MonadIO, and it seems like i'm "leaking stuff" out for some reason.
13:00:07 <jasonmason> main = replicateM 8 getLine >>= mapM putStrLn
13:00:22 <kunja> i'm using reader for ini files configuration. once the service is up, i don't intend to change it.
13:00:23 <davidkart> gets on my nerve
13:00:25 <jle`> kunja: your type signatures encode the type of effects that can happen, so nothing leaks implicitly
13:00:28 <jasonmason> probably want mapM_ there
13:00:32 <jle`> it's all explicit :)
13:00:41 <jle`> kunja: there are some nicer alternatives to MonadReader
13:00:46 <davidkart> the easiest Helloworld program takes lik 6 months to be written.
13:00:57 <jle`> including ImplictParams and reflections-based styles
13:01:02 <kunja> jle`: oh, i didn't know. can you point out some of them?
13:01:05 <davidkart> bazillion of functions to do the same thing, not a standard way.
13:01:16 <nitrix> davidkart: Are you talking of Haskell?
13:01:19 * shapr hugs davidkart
13:01:19 <jle`> using MonadReader forces all your otherwise normal code to be "monadic" or "applicative"
13:01:24 <shapr> davidkart: it'll be okay, we can help!
13:01:42 <jle`> using ImplicitParams is nice, but the problem is that it can't be used for typeclass instances for some reason
13:01:50 <kunja> jle`: that's true, but since it's part of a larger stack i didn't mind. i also don't know of another way.
13:01:53 <jle`> (i'm not sure if this is a fundamental restriction or just a lacking feature with GHC)
13:02:21 <jle`> with reflections-style programming you can basically get implicit params that works in typeclass instances
13:03:00 <jle`> yeah, if you already have your code pretty monadic/applicatively then MonadReader makes a little more sense
13:03:19 <kunja> another issue is that there is no clear way to use ExceptT as part of a larger stack without allowing the whole thing to fail on the first exception. so i end up doing runExceptT for "local" exception stacks to contain the damage.
13:03:20 <jle`> but it still feels like an awkward way to approach the implicit configurations problem, though
13:03:23 <jasonmason> davidkart you can do it many ways in most other languages. C: while loop, do while loop, for loop, for loop with explicit break, for loop with goto, recursion
13:03:44 <davidkart> that's all the same mathematic construct basically two ways : iterate or recurse.
13:03:52 <jle`> like shoe-horning something into the "monadic" framework that might not make sense
13:04:03 <jle`> kunja: you can use 'catch'
13:04:09 <jle`> or catchError, not sure what it's called
13:04:10 <jle`> :t catchError
13:04:12 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
13:04:24 <jle`> you can catch errors within your MonadError e m => ... code
13:04:30 <jle`> so one error doesn't cause everything else to fail
13:04:34 <davidkart> what I want is just easiness for simple tasks.
13:04:44 <kunja> so i just need to make my error ADT an instance of MonadError and reap the benefits?
13:04:46 <davidkart> but I seem to ask too much.
13:04:56 <jle`> kunja: you don't need to make it an instance of MonadError
13:05:04 <davidkart> IO are like the 10th chapter of 11 in a standard haskell textbook.
13:05:06 <jle`> ExceptT has an instance that doesn't require a MonadError instance
13:05:07 <davidkart> makes me cry.
13:05:20 <kunja> oh, that's great
13:05:25 <jasonmason> its easy once youre past the initial learning curve
13:05:30 <jle`> er, sorry
13:05:39 <jle`> mixing up names
13:05:44 <maerwald> jasonmason: nah, it's not, the learning curve is always steep
13:05:50 <jle`> your error type doesn't need an Error instance
13:05:59 <jle`> to be able to use your code as a MonadError e m
13:06:23 <jasonmason> maerwald, in haskell? 
13:06:24 <nitrix> jasonmason: Because you have the will to learn less or slower doesn't make the curve less steep.
13:06:24 <jle`> MonadError e's instances are the monads/contexts your computation is in, not your error type
13:06:30 <nitrix> I'd argue it gets even steeper as you go.
13:06:33 <kunja> i would just do deriving (MonadError ErrorADT, …) as part of the stack then?
13:06:39 <kunja> seems really easy
13:06:44 <jle`> your error type doesn't instance MonadError
13:06:53 <maerwald> jasonmason: yes, what you are describing is rather C, not haskell, IMO. Difficult at first, but then there are no concepts anymore to learn. That's not the case with haskell.
13:07:02 <jle`> your computations would be (MonadState s m, MonadReader r m, MonadError e m) => ... -> m a
13:07:11 <jle`> your error ADT doesn't need any instances
13:07:19 <jle`> it'd be (.. MonadError ErrorADT m ..) => ...
13:07:26 <jasonmason> maerwald, C is always difficult
13:07:31 <jasonmason> even after you mastered it
13:07:32 <jle`> oh, you mean your "transformer stack"
13:07:34 <kunja> jle`: but doesn't that make the entire thing break when an exception happens?
13:07:36 <jle`> then yea,h you're right :)
13:07:38 <kunja> yeah
13:07:40 <maerwald> jasonmason: I was talking about _learning_, not mastering
13:07:45 <jle`> kunja: not if you use 'catchError'
13:07:50 <jle`> :t catchError
13:07:52 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
13:08:01 <jle`> you can catch exceptions locally
13:08:12 <kunja> (e -> m a) is just a handler then
13:08:13 <jle`> within the context of your bigger computation
13:08:15 <jle`> yes
13:08:38 <jle`> but be aware that if your errors are primarily IO based exceptions, you're probably better off using the IO Exception system that GHC offers
13:08:40 <jasonmason> maerwald, C is deceptively easy to learn. it doesn't have as many concepts at haskell, but it has a minefield of undefined behavior
13:08:54 <maerwald> jasonmason: yeah, but that's irrelevant to the point IMO
13:09:23 <maerwald> and since haskell has a LOT of concepts, it doesn't get a lot easier
13:09:36 <maerwald> e.g. when you dive into lens after a year of haskell
13:09:39 <maerwald> not really easy
13:09:45 <jle`> i don't think you need that much concepts to start programming haskell practically
13:10:00 <jle`> the barrier of things to learn to start programming haskell is not unreasonably high
13:10:16 <jle`> and is comparable to other languages, it think ...
13:10:20 <sm> davidkart: it's not that bad once you get a little more familiar
13:10:23 <maerwald> jle`: I agree, but I don't think it's accurate to say that haskell gets a lot easier after the first learning curve... it keeps being challenging
13:10:25 <maerwald> and that's ok
13:10:30 <jle`> ah, yeah
13:10:44 <jle`> it's definitely an interesting learning curve :)
13:10:48 <jasonmason> maerwald you don't have to dive into lens 
13:10:53 <sm> davidkart: learn the Prelude, it's worth it
13:10:58 <sm> ghc -e 'sequence $ replicate 3 readLn :: IO [Int]' # <- one liner
13:11:33 * jle` . o O ( sequence (replicate n x)  == replicateM n x )
13:11:43 <maerwald> jasonmason: you don't have to learn haskell ;)
13:11:53 <sm> that requires an import, which was harder to figure out on command line
13:12:00 <jle`> oh, does it really? ;_;
13:12:22 <davidkart> why can't whave some recursive constructe ?
13:12:28 <kunja> jle`: though in this case i would have to mix match the pure ExceptT with exceptions where IO is happening
13:12:30 <jle`> it doesn't seem to require an import for me
13:12:33 <jasonmason> maerwald but learning lens isn't learning haskell. more complex libraries and concepts are not needed to be productive in haskell.
13:12:43 <maerwald> depends
13:12:51 <puregreen> jle`: I've seen you do the “o O” thing like a dozen times by now and only now I realised that it was a thought bubble and not “o_O” (as in “eyes”/surprise)
13:12:55 <jle`> kunja: nobody said anything about ExceptT
13:12:58 <sm> ghc -e 'import Control.Monad; (replicateM 3 readLn :: IO [Int])'  # <- exits immediately
13:13:01 <jle`> but yeah
13:13:10 <jle`> using Either alongside IO exceptions makes sense
13:13:20 <kunja> that might be a quite reasonable thing — to contain IO with GHC's mechanism and use ExceptT in the pure parts.
13:13:34 <jle`> (acutlaly i said things about ExceptT, sorry :) )
13:13:38 <sm> davidkart: ?
13:13:41 <jle`> puregreen: :)
13:13:54 <kunja> lol, no worries
13:14:05 <kunja> that was enlightening in any case
13:14:11 <jle`> but yeah, the thing to remember is that your actual logic doesn't involve ExceptT or StateT or ReaderT
13:14:16 <puregreen> (and this led to some very confused thoughts like “why would jle` be surprised at *that*”)
13:14:24 <davidkart> well the easy way : [ read (getLine) str | k<-[1..8] ]
13:14:31 <davidkart> well the easy way : [ read (getLine) Int | k<-[1..8] ]
13:14:42 <davidkart> It seems simple, no idiosyncracy
13:14:48 <jle`> a lot of times I end up implementing my own monad and writing MonadError, MonadReader, MonadState instances for it
13:14:53 <davidkart> readable
13:14:58 <davidkart> and understandable
13:15:17 <davidkart> why couldn't it work ?
13:15:29 <jle`> i rarely use StateT, ReaderT, etc. for merging effects now
13:15:50 <jle`> davidkart: read getLine Int -- that do you think that does?
13:16:18 <davidkart> well minus the syntactic approximation it would read "read (getLine) :: Int"
13:16:34 <jle`> `read getLine` doesn't really make sense, because read works on strings
13:16:53 <davidkart> and getLine is a IO string
13:16:55 <jle`> but getLine isn't a string .... it's a data type that represents the action of reading a line from stdin
13:17:02 <jle`> yeah, you can't read an IO String, that doesn't really make sense
13:17:06 <jle`> just like you can't read a Bool
13:17:07 <sm> davidkart: you have to line up the types. At first, this seems really a hassle but it becomes much easier soon
13:17:08 <davidkart> there you go
13:17:14 <davidkart> more idiosyncracy
13:17:16 <jle`> or read an Int
13:17:26 <davidkart> yes it *is* a hassle
13:17:30 <shapr> davidkart: I see it as being more explicit
13:17:45 <jle`> i'm not sure what the hassle is, though
13:17:49 <jle`> do you expect to be able to read a Bool?
13:17:51 <jle`> into an Int?
13:17:54 <kunja> you can do `read =<< getLine` though
13:18:02 <jle`> * fmap read getLine
13:18:17 <jle`> 'getLine' doesn't have any String for 'read' to read
13:18:21 <jasonmason> kunja that won't work
13:18:21 <jle`> it doesn't contain any strings
13:18:30 <sm> davidkart: people who like haskell and other statically-typed languages accept that small initial hassle in exchange for the huge benefit of programs that work 
13:18:42 <kunja> i don't remember ever using read
13:18:44 <kunja> :t read
13:18:45 <lambdabot> Read a => String -> a
13:18:57 <kunja> :t getLine
13:18:58 <lambdabot> IO String
13:19:16 <kunja> :t (read =<< getLine)
13:19:20 <lambdabot> Read (IO b) => IO b
13:19:34 <jasonmason> :t fmap read getLine
13:19:36 <lambdabot> Read b => IO b
13:19:40 <puregreen> davidkart: this idiosyncrasy is most definitely not *needed* (lots of languages don't use it), and there are also some more fine distinctions that Haskell is blind at (e.g. why do we a distinction between actions and values, but not between computations and values?). Sure the distinction between actions and values is a hassle in some cases, but it also enables some other nice things to exist. It's a tradeoff. Some people like
13:19:40 <puregreen> it, others don't.
13:20:22 <jle`> in Haskell, we work with IO actions instead of implicit side-effects...and that opens up a lot of doors
13:20:27 <jle`> makes a lot of things possible that weren't otherwise possible
13:20:33 <shapr> yeah, it's a superpower
13:20:43 <jle`> 80% of my Haskell code is only possible if I'm allowed to work with descriptions of IO actions
13:20:45 <maerwald> IO is awkward though, nothing to be proud of
13:21:05 <davidkart> well I'll try to put it another way : what if I told you : « write a program that reads a list of integers from stdin and display them multiplied by two on stdout ». It sounds like a baby step to every learning programmer. Yet in Haskell I have tried since 10 days to write a program I _understand_ to do that and failed.
13:21:20 <jle`> being able to work with IO actions instead of implicit side-effects is something i leverage every day
13:21:35 <davidkart> I feel like the stupidest guy on earth.
13:21:48 <shapr> davidkart: oh me too! all the time! And I've been doing Haskell for fifteen years!
13:21:58 <shapr> davidkart: but you get used to it, and then you learn so many awesome things!
13:22:04 <puregreen> davidkart: I was absolutely hating *everything* when I was learning HTML and then SQL
13:22:15 <sm> davidkart: this is common when starting haskell, it doesn't last too long
13:22:20 <jle`> it took me at least a few months to write anything useful in javascript
13:22:21 <puregreen> davidkart: if Haskell makes you feel stupid, it doesn't really say anything about either you or Haskell
13:22:22 <maerwald> IO breaks what I liked about haskell at first: predictability of functions. IO is basically: "I might read or write to the disk, might print to stdout, might do syscalls, might do network stuff, might spawn processes, might use IORefs, might do...."
13:22:59 <jle`> maerwald: are you talking about IO, or haskell, or the IO type?
13:23:01 * hackagebot pgdl 9.2 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-9.2 (sifmelcara)
13:23:03 <sm> davidkart: have you written a program that does that for one integer ?
13:23:11 <davidkart> yeah but maerwald : it looks like all the practical purpose of a programming language are lost in this fine piece of mathematical abstraction.
13:23:11 <maerwald> jle`: the haskell IO type
13:23:25 <TheMystic> maerwald: all of those things are also unpredictable in other languages -- haskell just makes you be explicit about that
13:23:28 <davidkart> (from my point of view of course)
13:23:33 <maerwald> TheMystic: no
13:23:43 <monochrom> "read a list of integers from stdin" is not baby step. "read one integer, and assume it's on its own line" is.
13:23:44 <maerwald> TheMystic: here is purescript for you: main :: forall e. Eff (fs :: FS, trace :: Trace, process :: Process | e) Unit
13:23:55 <maerwald> which is more useful than: main :: IO ()
13:24:08 <monochrom> for starters: what is the "list" input format?
13:24:11 <jle`> maerwald: but main :: IO () is more useful than main :: () :P
13:24:42 <jle`> the discusion was about the fact that we work with "IO actions" instead of implicit side-effects
13:24:53 <jle`> not necessarily about the finer details of its implementation
13:25:14 <monochrom> and there are big differences between the 3 obvious possibilities I can think of now: (A) they're all on the same line, separated by spaces; (B) they're one per line; (C) they're in the [1,2,3,4] format on one line
13:25:21 <TheMystic> maerwald: so you're saying you want a more expressive type for functions that can do any or all of those things?
13:25:58 <monochrom> even if I were learning Java, (A) or (C) would be difficult
13:26:05 <TheMystic> I misread your statement as "why do I have to wrap dangerous things in a Monad"
13:26:20 <jle`> davidkart: 'readLn' is an IO action/program that reads a value from a line, and replicateM n takes a program and does it n times
13:26:29 <jle`> davidkart: so your program is just replicateM n readLn :)
13:26:32 * puregreen remembers the days of Pascal when reading numbers separated by spaces was the easiest thing in the world
13:26:35 <maerwald> TheMystic: yes, IO is awkward and can be done a lot better. Other languages have done that
13:27:07 <jle`> well, 'readLn' might not be actally want you want to do, but you write your "do it once" program, say, 'foo', and then just use replicateM to manipulate it
13:27:09 <sm> jle`: that's not the easiest thing to come up with when you're starting out 
13:27:12 <TheMystic> maerwald: aren't there alternate preludes in Haskell that even do that?
13:27:18 <sm> you also will need a type annotation
13:27:27 <davidkart> monochrom: if you want a fine abstraction to read int you could tell the following : any char that is not a digit (ie in [0..9]) is a separator; break the content of the file into a list of strings based on the previous definition.
13:27:27 <monochrom> if I were learning C, (A) and (B) would be easy, but that's unfair, scanf is a library function (not the language itself per se) that is hugely complex and does all the heavy-lifting for you. you still don't learn parsing from using it.
13:27:28 <jle`> not necessarily
13:27:33 <jasonmason> maerwald what other languages?
13:27:35 <jle`> i usually don't need type annotations when i use read or readLn
13:27:44 <maerwald> TheMystic: what does that give you when all libraries use the IO type?
13:27:45 <maerwald> nothing
13:27:53 <maerwald> jasonmason: purescript and Idris for instance
13:27:56 <sm> jle`, try it
13:28:16 <jle`> ghc -e "replicateM 10 (readLn >>= \x -> print (x*2))"
13:28:30 <sm> doesn't work :)
13:28:42 <jle`> well, maybe have to write it as a program v.v
13:28:47 <jle`> but type inferance takes care of it
13:28:48 <sm> try it :)
13:28:52 <dolio> Instead you use a language with no libraries. :)
13:28:55 <shapr> @hoogle replicateM
13:28:58 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
13:28:58 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
13:28:58 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
13:29:05 <davidkart> yeah monochrom(I'm starting to thinking that I've been really lazy in writing programming since I took python course).
13:29:27 <TheMystic> maerwald: a lot of the useful bits are abstracted over any Monad instance, aren't they?
13:29:30 <shapr> sm: worked with ghc -e "Control.Monad.replicateM 10 (readLn >>= \x -> print (x*2))"
13:29:31 <davidkart> wait. So what's in the scope of replicateM cannot be read from outside ?
13:29:35 <jle`> sm: it worked for me
13:29:52 <maerwald> TheMystic: ??
13:30:09 <jle`> ghc 7.10
13:30:10 <TheMystic> i.e. if you have an alternate prelude that wraps the syscalls, fs ops, socket library, &c, you can still use the standard methods of composing those things
13:30:22 <jle`> davidkart: what scope do you mean?
13:30:28 <maerwald> it doesn't give you any benefit when the whole ecosystem does not use it
13:30:53 <davidkart> how do you know the replicateM n instruction is finished ?
13:30:59 <maerwald> unless you want to rewrite everything
13:31:01 <jle`> davidkart: an `IO ()` represents a program that does IO.  `replicateM 10 foo` is another program, IO ()
13:31:03 <jle`> *replicateM_
13:31:11 <jle`> davidkart: that represents doing whatever 'foo' did, but ten times
13:31:12 <sm> yeah that works (shapr's command, or yours when converted to a main function with suitable import)
13:31:35 <TheMystic> maerwald: I guess I don't have a good sense of how much of the ecosystem depends on IO directly
13:31:47 <jle`> davidkart: in Haskell, when we work with IO, we describe programs.  we describe IO actions
13:31:58 <jle`> so when we describe 'foo :: IO ()', a program that does soemthing
13:32:18 <jle`> we can describe 'replicateM_ 10 foo :: IO ()', a program that does what foo does, but ten times
13:32:26 <jle`> putStrLn "hello" represents a program that prints hello
13:32:31 <maerwald> TheMystic: _all_ programs and probably the majority of libraries
13:32:34 <jle`> replicateM_ 10 (putStrLn "hello") represents a program that prints hello ten times
13:33:04 <jle`> you can't write replicateM_ in most programming languages in this way
13:33:13 <jle`> that's because you don't pass "descriptions of IO" in other languages
13:33:42 <jle`> the only reason we can even write replicateM_ is because in Haskell, we *describe* IO actions, and manipulate those descriptions, use them to build more complex descriptions
13:33:56 <jle`> because those descriptions are just normal data, like Int's or Bool's or String's
13:34:01 <shapr> first class actions
13:34:36 <jle`> try writing something as simple as `doTwice x = x >> x` in another language and you'll see the problem :)
13:34:48 <jle`> or doTwice x = do x; x
13:35:19 <dolio> You can do it in C. It's just much uglier.
13:35:28 <jle`> or one of the shining achievements of IO-as-actions and laziness, doForever x = x >> doForever x
13:35:40 <mauke> let doTwice x () = x (); x ()
13:36:35 <dolio> I think this whole problem could be recast in C (or many other languages).
13:36:41 <TheMystic> dolio: sure, you have to have code that writes thunks for you and returns function pointers...
13:37:01 <TheMystic> basically, you'd implement a compiler for a non-strict language inside C
13:37:13 <dolio> Well, this case isn't that complicated. It's just a function that takes a function pointer.
13:37:17 <jle`> you'd basically implement your own concept of IO as data/actions...which is the whole point
13:37:20 <dolio> And calls it twice.
13:37:32 <jle`> why it's nice to represent IO as values
13:37:42 <TheMystic> dolio: right but to do it in the general case would be significantly uglier
13:37:50 <jle`> in that case, it'd be representing IO with function pointers
13:37:52 <tnks> I feel you all are in the death spiral of agreement.
13:38:00 <TheMystic> haha probably
13:38:03 <jle`> and at that point, that proves the whole point of the argument :)
13:38:19 <davidkart> « We won't concern ourselves with deriving too much for now » <-the number of time I've seen this in haskell tutorials
13:38:44 <TheMystic> davidkart: are you familiar with promises in javascript?
13:39:05 <davidkart> mostly not familiar with javascript
13:39:07 <dolio> Like, why can't I call sscanf with the function pointer getline as the first argument?
13:39:12 <davidkart> but promises yes I've heard of it.
13:39:25 <TheMystic> the model is strikingly similar, except without the strong type safety (or any type safety)
13:39:28 <maerwald> please don't compare promises with haskells IO :P
13:39:33 <maerwald> it's  nothing similar
13:39:51 <shapr> davidkart: if you're near Atlanta, I'll give you an in-person Haskell intro
13:39:53 <davidkart> my first project is a parser of ints.
13:39:54 <TheMystic> maerwald: the way you reason about its execution is pretty similar...
13:39:57 <maerwald> no
13:40:34 <shapr> > read "1" :: Int
13:40:36 <lambdabot>  1
13:40:38 <shapr> tada!
13:40:40 <davidkart> shapr: I am really sensitive to your proposal, and I'd like to take you on this. I'm lik 15000 km distant.
13:40:55 <davidkart> (skype is the most probable possibility to have a lesson
13:41:02 <davidkart> yes
13:41:04 <maerwald> Promises is a way to wait for async IO and use return values instead of callbacks. IO is something abstract that you have control over WHEN to execute.
13:41:06 <shapr> davidkart: ah, 15kkm is a bit far
13:41:33 <dolio> Is that on the moon?
13:41:36 <maerwald> ghc doesn't just randomly fire up your IO actions
13:42:16 <shapr> I'm guessing eastern europe?
13:42:17 <maerwald> the reasoning is fundamentally different
13:42:29 <davidkart> maerwald: -> no I?m lost in astonishment.
13:42:37 <davidkart> Maybe is a type constructor.
13:42:56 <davidkart> (basically it may be more understandable than template functions in C++)
13:43:03 <davidkart> mathematical rigour is always of interest.
13:43:07 <davidkart> (when programming).
13:43:44 <maerwald> when you make a list of promises, they are already executing. When you make a list of IO actions... it's just that, a list of IO actions.
13:43:48 <idev> in vim, is it possible to have the title of the fold just be the first line of the fold? (this is for haskell, where I want the type sig of the function to just be the fold title
13:45:13 <TheMystic> maerwald: I'm not claiming they're the same, but you can use the same intuitive sense that the data structure encapsulates the execution
13:45:30 <TheMystic> at least as a starting point coming from strict/imperative languages
13:45:46 <TheMystic> it's been helpful for me to compare them while learning in any case
13:46:05 <maerwald> Async IO is not intuitive and is fundamentally different, whether you use promises or not. I feel like that comparison will rather lead to confusion.
13:47:08 <maerwald> a Promise is not a description of an IO action... it's an IO action that's already executing
13:47:23 <maerwald> IO in haskell is just a description
13:47:39 <TheMystic> maerwald: yes, I understand the difference
13:47:47 <puregreen> it still helps to demonstrate the idea of values and actions being different things
13:48:10 <puregreen> whether it will lead to confusion or not probably very much depends on the learner
13:48:28 <TheMystic> comparisons of similar but non-identical things are often enlightening
13:48:34 <maerwald> depends
13:49:18 <MichaelBurge_> I don't want to confuse a newcomer, but is it really accurate to say that IO a is 'a description of an action that calculates a value of type a'?
13:49:39 <MichaelBurge_> The definition in base is more like 'a function that takes a RealWorld state token, and returns a new state token along with a value of type a'.
13:49:59 <TheMystic> MichaelBurge_: yeah but then you have to explain what a "RealWorld state token" means ;)
13:50:03 <dolio> That second description doesn't make any sense, so you definitely shouldn't explain it like that.
13:50:32 <TheMystic> perhaps more accurate would be to say that IO a is "a value that, when executed, produces a value of type a"
13:50:32 <MichaelBurge_> I mean, the first description is literally '[d| putStrLn |]' to me.
13:50:46 <puregreen> you might try to use the RealWorld description to explain *how* it works, but not *what* it is
13:50:57 <MichaelBurge_> And I don't think in general that you can lift an IO a into a syntax tree representation of the value.
13:52:04 <maerwald> MichaelBurge_: action :: IO a -- may outright fail without calculating anything
13:52:50 <monochrom> I can explain how RealWorld works.
13:53:05 <monochrom> It works by getting erased by the compiler.
13:53:27 <monochrom> so perhaps I should say: it "works".
13:53:43 <TheMystic> monochrom: that's just handwaving though
13:53:57 <TheMystic> in terms of explaining to someone what haskell's model of computation is
13:54:11 <monochrom> I can tell you more about why it is erased and why it exists before it gets erased.
13:55:26 <dolio> Real world passing completely fails at allowing you to give a denotational semantics of Haskell expressions that doesn't involve side effects, or modeling effects denotationally.
13:55:28 <TheMystic> monochrom: heh, sure, but you've already lost people by that point :)
13:56:01 <monochrom> the compiler has an optimizing code generator that translates all kinds of expressions to machine code. part of the optimization comes from feeling free to re-arrange evaluation order. only data dependency forbids certain re-orderings.
13:56:33 <monochrom> but in case I/O is at stake, you don't want re-ordering.
13:56:35 <dolio> So it's a pretty bad way of explaining the abstract IO type.
13:56:48 <MichaelBurge_> ^ That's my understanding as well. IO a is the same as an a, except that it introduces a data dependency.
13:56:55 <dolio> Since it fails to do the thing the abstract type was introduced for.
13:57:14 <MichaelBurge_> And by convention, our standard libraries put database access and such in values of type IO a(because these need dependencies).
13:57:27 <maerwald> MichaelBurge_: there's really more to it than that
13:57:32 <monochrom> if you write "putStrLn xx >> getLine", you want events to happen in that order you wrote, even though they're data-independent.
13:58:05 <TheMystic> I read the "awkward squad" paper recently, I actually found that pretty enlightening and approachable
13:58:08 <maerwald> IO a is not the same as "a with guaranteed ordering"
13:58:18 <monochrom> RealWorld is added to add a fake backdoor "data" dependency to fool the optimizing code generator.
13:58:37 <monochrom> I put "data" in quotes because it's a phatom type. it contains nothing.
13:58:55 <monochrom> it is not even the "data X = X" kind of data.
13:59:18 <monochrom> and so the late-stage code generation sees this and erases RealWorld near the end.
13:59:45 <monochrom> but it's late enough that no more re-ordering is considered after
14:00:03 <monochrom> this is how RealWorld "works" for IO.
14:00:22 <monochrom> it explains why RealWorld is not an explanation or model of IO.
14:00:35 <monochrom> it is one particular compiler's coding trick.
14:00:59 <m-renaud> Quick package version question: If you simple change an upper bound on a build-depends, do you need to bump the version?
14:01:18 <monochrom> it only explains "how to avoid writing two different code generators"
14:02:08 <dolio> m-renaud: No, I don't think that's in the policy.
14:02:23 <maerwald> m-renaud: distros have revisions for that, but hackage does not have that
14:02:55 <monochrom> and yes you should get really lost when you hear this story. because RealWorld is about one way to write a compiler, not one way to gain a model useful for users.
14:02:56 <maerwald> a version component that does not describe the API of the package, just metadata surrounding it
14:02:59 <glguy> m-renaud: the only way I can imagine changing versions would be necessary would be if you were reexporting something from another package and the new version changed the types or behavior of your exports, but I think that would be rare
14:03:41 <m-renaud> Gotcha, thanks. That's what I was thinking but wanted to double check firest :)
14:03:43 <m-renaud> first*
14:03:45 <monochrom> you don't try to understand function application by reading GHC source code either, do you?
14:04:18 <hpc> as far as mental models go, RealWorld is actually a pretty terrible one
14:05:15 <monochrom> programmers are the kind of people with the highest amount of cognitive dissonance, of all kinds of people I've seen.
14:05:32 <maerwald> err
14:05:41 <monochrom> when they are learning function application and lambda abstraction, they don't go read GHC source code
14:06:08 <monochrom> when they are learning the module system (though simplistic it may be), they still don't go read GHC source code.
14:06:19 <MichaelBurge_> That raises a follow-up question: A (boxed) value of type a is either a pointer to a concrete representation of a, or a pointer to some code that calculates a and replaces the thunk with a reference.
14:06:29 <monochrom> (and even when they are learning SML's module system, they still don't go read SML/NJ source code)
14:06:32 <MichaelBurge_> What is a value of type 'IO a'?
14:06:49 <monochrom> and then suddenly when they learn IO, they cite GHC source code as authoritative.
14:07:01 <monochrom> I do not understand this split-personality.
14:07:18 <dolio> Would reading the SML/NJ source code be easier than reading a paper on ML module systems, though?
14:07:23 <dolio> It might be.
14:07:23 <maerwald> monochrom: it's easy to understand, because that explanation was given by SPJ in one of his papers.
14:07:41 <maerwald> so people read that and go "aha" (whether that's good or not)
14:07:46 <josephle> also type-theoretic explanations of SML's module system are quite...complex
14:08:26 <hpc> perhaps IO is too abstract for them ;)
14:10:20 <josephle> dolio: I think the SML/NJ source is easier to understand than the theory behind ML module systems
14:10:32 <dolio> It might be. :)
14:10:34 <monochrom> it is useful for every programmer to take a write-a-compiler course. even if the compiler written is for Pascal
14:10:46 <hpc> i think to some extent, people see IO as a type and go "oh, it has a data declaration"
14:11:07 <hpc> which... doesn't happen for Monad?
14:11:08 <hpc> who knows
14:11:13 <monochrom> because you realize that some parts of the compiler are parlor tricks to get the desired asm code generated, as opposed to actually corresponding to reality.
14:11:18 <josephle> dolio: the source would have to be severely hacky to be more complex than dependent kinds
14:11:26 <hpc> people who are still learning can't be trusted to know what they are doing
14:11:28 <davidkart> how do I return the position of the maximum in a list ?
14:11:41 <davidkart> hpc: I agree
14:11:49 <monochrom> and some other are also parlor tricks, but this time for checking some consistency
14:12:11 <maerwald> I feel the next suggestion is going to be to write a web app in ASM before doing web development in haskell
14:12:15 <hpc> dependent kinds?
14:12:40 <dolio> RealWorld is the Haskell equivalent of saying that IO a in ML would be () -> a.
14:12:54 <dolio> If you aren't satisfied by the latter, you shouldn't be satisfied by the former.
14:13:09 <hpc> thunks in ML are also () -> a :P
14:13:11 <dolio> I guess it would be 'a io or something.
14:13:15 <glguy> fst 07. maximumBy (comparing snd) 07. zip [04007..] 07:: Ord a 07=> [a] 07-> Int
14:13:27 <glguy> would be one way (I don't think that such a function is predefined in base)
14:13:46 <jasonmason> dolio by RealWorld you mean ghc's implementation of IO? 
14:13:57 <dolio> Yeah.
14:14:08 <monochrom> dolio, what if I'm satisfied by the latter? :)
14:14:22 <dolio> monochrom: Then I feel bad for you. :)
14:15:03 <monochrom> I actually know the origin of the RealWorld trick from a PhD thesis.
14:15:22 <dolio> I mean, everyone who uses ML is satisfied.
14:15:40 <monochrom> It is a very old one (1960s? 1950s?) in the U of Toronto.
14:15:40 <dolio> Or maybe they aren't, but live with it.
14:15:43 <hpc> occurs check: could not satisfy constraint (ML programmer)
14:16:12 <dolio> Also every Clean user, I guess.
14:16:21 <josephle> dolio, Bob Harper has once told me in a lecture that he could never decide if he was satisfied
14:16:25 <monochrom> I don't think you can find it online. But I was a PhD student there, I got to go to the department's "past theses bookshelf" and read it for real.
14:16:26 <davidkart> not working glguy
14:16:38 <davidkart> I mean for all practical purpose
14:16:50 <hpc> monochrom: 50s would be very old, that's when lisp was conceived
14:17:06 <dolio> josephle: Oh, I meant satisfied with this particular thing, not with the whole of ML.
14:17:20 <monochrom> in fact in this case it gets even better, since I met its author long before I knew of his thesis, from other occasions and events.
14:17:35 <dolio> I'm pretty sure Harper is satisfied on this issue.
14:17:39 <hpc> in a classic twist, monochrom was the author
14:17:41 <monochrom> (so I also got to speak with him after I had finally read it)
14:17:53 <josephle> dolio: the quote was with respect to monads vs impure benign effects
14:18:01 <monochrom> no no, I am not that young. I supervised Church's thesis.
14:18:05 <dolio> Oh. I see.
14:18:32 <josephle> he joked that on MWF he liked impurity and on TTh he liked monads
14:18:32 <jasonmason> dolio why does IO implementation matter as long as specs are followed? unless you're interested in contributing to ghc 
14:18:37 <dolio> Well, he has a good poker face, I guess.
14:19:35 <monochrom> dolio: I am satisfied by the ()->a story, but only in the context of compiling to an imperative machine, i.e., this is when I consider "->" to be effectful.
14:19:39 <davidkart> glguy: don't you forget some import ?
14:20:02 <dolio> jasonmason: It doesn't matter that much, but if you're going to explain something about it, it matters if the explanation is fundamentally at odds with something that it's attempting to accomplish.
14:20:08 <glguy> davidkart: I didn't, maybe you did? You'd have to tell what error you're reading
14:20:24 <dolio> monochrom: Yes, it's okay as an operational semantics, but not a denotational semantics.
14:20:52 <monochrom> denotation is going to be very hard
14:21:03 <davidkart> glguy: not in scope : comparing
14:21:24 <monochrom> Hoare made it easy, but people rejected it. (set of message exchange histories.)
14:21:24 <glguy> ?index comparing
14:21:24 <lambdabot> Data.Ord, Distribution.Simple.Utils
14:21:39 <glguy> ^ first one there
14:24:46 <dolio> monochrom: Or really, it's not that denotational semantics for IO is ever going to be good. But explaining `IO a` as `() -> (a, ())` makes the denotational semantics of everything as bad as that of IO.
14:25:01 <dolio> And you can do much better for a lot of stuff.
14:26:26 <dolio> That's kind of true for operational, too, but only if your operational semantics is something like term rewriting.
14:26:49 <dolio> Once you get to a machine model isn't not going to get a whole lot worse.
14:28:04 * hackagebot elm-export 0.3.0.0 - A library to generate Elm types from Haskell source.  https://hackage.haskell.org/package/elm-export-0.3.0.0 (krisajenkins)
14:28:06 * hackagebot elm-export 0.3.0.1 - A library to generate Elm types from Haskell source.  https://hackage.haskell.org/package/elm-export-0.3.0.1 (krisajenkins)
14:30:15 <monochrom> I did use term rewriting as my operational semantics in my thesis :)
14:31:33 <davidkart> thanks a lot glguy, I finally succeded.
14:32:35 <davidkart> mmh
14:32:50 <davidkart> I wanted to kindly tell something on my mind.
14:33:04 * hackagebot telegram-api 0.4.0.1 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.4.0.1 (klappvisor)
14:33:17 <monochrom> I am happy to hear it.
14:36:54 <davidkart> well I don't know if you are wanting to teach Haskell someday to someone. I find that it is more gratifying to write working program in order to learn.
14:37:18 <davidkart> So I jumped into the IO section of LYHFAGG and ran into what I needed.
14:37:47 <davidkart> Well thank you very much.
14:37:54 <davidkart> I had made some progress tonight.
14:39:41 <numberten> is it possible to have functions as keys to a map?
14:39:49 <numberten> you'd just need an ord instance on.. (a -> b) right?
14:40:04 <dolio> Have you tried writing one?
14:40:17 <monochrom> if you want to use IO early, Hudak's "The Haskell School of Expression" does it better.
14:40:49 <fr33domlover> numberten, or wrap with a newtype
14:40:56 <fr33domlover> and make the newtype an Ord instance
14:42:05 <monochrom> I don't know how to make an Ord instance for functions
14:42:21 <dolio> If you pick the right constraints on a and b, it's possible.
14:42:26 <monochrom> but yes, if I knew how to, I would probably solve the halting problem too.
14:42:44 <dolio> You still won't want to use them as keys in a map, though, most likely.
14:42:58 <dolio> Kind of like using strings isn't a good idea.
14:43:04 * hackagebot elm-export 0.3.0.2 - A library to generate Elm types from Haskell source.  https://hackage.haskell.org/package/elm-export-0.3.0.2 (krisajenkins)
14:43:08 <glguy> We do alright having an instance of Ord for lists even though there are inputs where it doesn't terminate
14:43:26 <EvanR> er, how to encode an object interface as a record with binary method ?
14:44:31 <monochrom> perhaps one field is simply a 2-ary function.
14:44:52 <EvanR> but like :: self -> self -> self
14:45:35 <EvanR> if i do :: MyType x -> MyType x -> MyType x, the two arguments could have different implementations and then i cant implement the actual operation
14:49:15 <EvanR> i vaguely remember something about a recursive type that solved this, wasnt sure if haskell could pull it offf
14:49:40 <Zemyla> GADTs?
14:51:03 <Zemyla> dolio: (Bounded a, Enum a, Ord b) => Ord (a -> b) where compare af bf = foldMap (liftA2 compare af bf) [minBound .. maxBound]
14:52:42 * EvanR tries GADTs
14:53:05 * hackagebot dimensional 1.0.1.2 - Statically checked physical dimensions,  using Type Families and Data Kinds.  https://hackage.haskell.org/package/dimensional-1.0.1.2 (dmcclean)
15:00:46 <EvanR> Zemyla: how were you think gadts would factor in
15:23:25 <EvanR> newtype Fix f = f (Fix f)... data PreFoo r a = PreFoo { binop :: PreFoo r a -> PreFoo r a -> PreFoo r a }, type Foo = Fix PreFoo
15:23:33 <EvanR> hmm
15:24:16 <EvanR> type Foo a = forall r . PreFoo r a
15:43:07 * hackagebot werewolf 1.2.0.1 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.2.0.1 (hjwylde)
15:48:08 * hackagebot hledger-ui 0.27.4 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-0.27.4 (SimonMichael)
15:59:47 <scshunt> is there a way to truly return an existential type?
16:00:13 <scshunt> e.g. return something where you guarantee nothing other than that it's an instance of a given typeclass?
16:01:49 <S11001001> scshunt: there's datatype definition and taking a rank-2 continuation as argument, that's all
16:02:33 <scshunt> S11001001: examples?
16:05:24 <Hijiri> scshunt: If you return (forall a. Typeclass a => a -> r) -> r, that is basically equivalent to an existential "something that is an instance of Typeclass"
16:05:42 <S11001001> scshunt: otherargs -> (forall e. IAmBad e => e -> z) -> z
16:05:46 <Hijiri> You can also do something like data AnOrd = Ord a => AnOrd a
16:05:50 <S11001001> Beaten by Hijiri 
16:05:56 <Hijiri> @let data AnOrd = Ord a => AnOrd a
16:05:57 <lambdabot>  .L.hs:147:18: Not in scope: type variable ‘a’
16:05:57 <lambdabot>  
16:05:57 <lambdabot>  .L.hs:147:29: Not in scope: type variable ‘a’
16:06:03 <Hijiri> ok, maybe that is wrong syntax
16:06:08 <Hijiri> I can do it with GADT syntax though
16:06:21 <Hijiri> @let data AnOrd where AnOrd :: Ord a => a -> AnOrd
16:06:22 <lambdabot>  Defined.
16:06:44 <Hijiri> this one in particular would be pretty useless though, because with an Ord thing in isolation all you could do is compare it to itself
16:06:45 <nvtf> Hi, somewhat very abstract question: let's say I have a data structure that I want to work with it in a "modified" way and want any "change" that I do in the modified version to take place in the original version at the end. I have a very basic understanding of Lenses, but is this a use case where they would apply? Or is there any other abstraction that is already there for this kind of thing?
16:06:54 <nilof> How do I get leksah to build with stack?
16:10:14 <EvanR> nvtf: ive been using semantic editor combinators, which includes working with a view of the data through an isomorphism
16:10:33 <EvanR> > (chr . (+1) . ord) 'a'
16:10:35 <lambdabot>  'b'
16:11:21 <EvanR> the cool part is that (chr . _ . ord) is composable with other editors, so you can reach into a data structure
16:11:27 <nvtf> Somewhat concrete example: let`s say a have a map with a bunch of data that I don`t care about and a bunch of data that I do and let`s say this map is an M, I have a lib that works with maps of the form of M2, where M2's attributes are a subset of M's attributes (and that calls some of those attributes differently). So basically I want some sort of abstraction where I can: map an M "instance" to a M2 instance on an entry point -> works internall
16:11:27 <nvtf> y with this M2 -> adapts M2 to M again, but applying the computations I made on that M2. (let's say that I wanna abstract passing the original contents of M around and whatnot)
16:12:07 <nvtf> EvanR Ill take a look at it, thanks
16:17:16 <nilof> Question: do stack and Haskell platform coexist well on the same system?
16:37:37 <jle`> @tell nilof yes
16:37:37 <lambdabot> Consider it noted.
16:38:41 <nitrix> :t Control.Category..
16:38:42 <lambdabot> parse error on input ‘Control.Category..’
16:38:46 <nitrix> :t Control.Category.(.)
16:38:47 <lambdabot>     Not in scope: data constructor ‘Control.Category’
16:39:09 <geekosaur> :t (Control.Category..)
16:39:10 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
16:39:50 <nitrix> geekosaur: Leading to my question; what's the difference between Control.Category's (.) vs. Prelude's (.) ?
16:40:40 <nitrix> My understanding is that `>>>` and `<<<` are `flip (.)` and `(.)` respectively.
16:40:54 <geekosaur> I *think* just that it can work with more than just kind *
16:42:05 <nitrix> Weird, the implementation uses  (<<<) = (.)
16:42:35 <nitrix> How can it gain a more general form when the implementation is less generic?
16:44:14 <nitrix> Actually it is less generic, I think. It's constrained to Category.
16:44:16 <codebje> nitrix, Control.Category redefines (.) 
16:44:29 <nitrix> OH!
16:45:01 <nitrix> That's not Prelude's (.), gotcha.
16:45:28 <geekosaur> I admit to beiung confused as to why you thought that was (Prelude..)
16:46:48 <nitrix> geekosaur: Inexperience.
16:47:43 <nitrix> geekosaur: Hope it solves the confusion :)
16:49:24 <codebje> @instances Category
16:49:27 <lambdabot> (->), Kleisli m, ReifiedFold, ReifiedGetter
16:50:13 <EvanR> how do i (a -> a -> a) -> (b -> a) -> b -> b -> a
16:50:32 <EvanR> @pl f g x y = f (g x) (g y)
16:50:32 <lambdabot> f = fix (join . ((flip . ((.) .)) .) . (.))
16:50:44 <EvanR> o_O
16:50:56 <EvanR> @pl h f g x y = f (g x) (g y)
16:50:57 <lambdabot> h = join . ((flip . ((.) .)) .) . (.)
16:53:10 * hackagebot werewolf 1.2.0.2 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.2.0.2 (hjwylde)
16:53:16 <nitrix> @let (.:) = (.) . (.)
16:53:17 <lambdabot>  Defined.
16:53:20 <nitrix> :t (.:)
16:53:21 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:53:33 <nitrix> EvanR: I think I'm close?
16:53:53 <hpc> @djinn (a -> a -> a) -> (b -> a) -> b -> b -> a
16:53:54 <lambdabot> f a b c _ = a (b c) (b c)
16:54:27 <hpc> s/_/d and s/f c/b d (one of them)
16:54:33 <nitrix> @djinn (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:54:33 <lambdabot> f a b c d = a (b c d)
16:54:41 <nitrix> Oh, oh that's wrong.
16:59:40 <EvanR> djinn gives a pointful
17:03:04 <EvanR> might be in the aviary
17:05:22 <godel_> hey
17:05:30 <godel_> how can I force ghci
17:05:40 <godel_> to tell me which pattern am I missing?
17:05:44 <godel_> Exception: comb.hs:(40,1)-(51,20): Non-exhaustive patterns in function reduce
17:05:54 <godel_> like when I get that kind of error
17:08:08 <dfeuer> godel_, I'm used to seeing more. What version of GHC?
17:08:24 <geekosaur> this is the runtime error, not the compile-time check
17:08:30 <dfeuer> Ohhhhh
17:08:39 <dfeuer> Well then, use the compile-time check.
17:09:00 <hpc> the motto of #haskell
17:09:31 <dfeuer> Does -dverbose-core2core usually make GHC really, really slow?
17:10:13 <geekosaur> :set -fwarn-incomplete-patterns
17:10:59 <jasonkuhrt> Hi, I'm learning Haskell and trying to understand something about how import syntax works
17:11:34 <jasonkuhrt> if I want to import Data.Text qualified as well as the type `Text` do I need two import statements for this?
17:11:50 <jasonkuhrt> import qualified Data.Text as Text \n import Data.Text (Text)
17:11:55 <jasonkuhrt> Is there a better way? Thanks
17:12:21 <bergey> Yes, you need both.  That's pretty common.
17:12:28 <Clint> there is no better way
17:14:04 <fr33domlover> godel, build with -Wall
17:14:29 <hpc> usually imports are sufficiently managable that two lines for the odd module isn't too bad
17:14:57 <crobbins> i think most languages have that limitation
17:15:47 <crobbins> i guess the difference is in scala you could do something like `import Data.Text, Text._`
17:16:06 <crobbins> or rather: import Data.Text, Text.Text
17:16:15 <geekosaur> extensions to the import syntax have been discussed, but I don't think anyone's actually made a formal proposal
17:16:23 <jasonkuhrt> Thanks for clarifying everyone, I think the design could be better but I'll get on with my day knowing its what is on offer from Haskell : )
17:16:52 <crobbins> yeah, i'm just having a hard to thinking of a language that deals with this case much better
17:16:53 <hpc> extensions to import would probably end up with riders attached to make parameterized modules and possibly some improvements to the record system
17:17:13 <hpc> although i hear that records can share fields in upcoming ghc so that part might be moot anyway
17:18:31 <Tehnix`> jasonkuhrt: there have been some proposals to amend that (such as https://ghc.haskell.org/trac/ghc/wiki/ShorterImportSyntax) but unfortunately nothing in GHC yet :(
17:19:54 <jasonkuhrt> Tehnix`: Thanks for the link. One feature I like about Go is how functions are given generic names (e.g. `encode`) with the import providing the namespace leading to user-code like `Base64.encode`
17:20:04 <tomleb> Which framework is the prefered ? Scotty vs Spock
17:20:23 <jasonkuhrt> I realize in Haskell this is possible but in Go its the _only_ way since day 1, so its a breeze to work with imports in this regard
17:20:26 <hpc> jasonkuhrt: you'll like type classes
17:21:08 <jasonkuhrt> hpc: I'm familiar with them, how do you mean in this case?
17:22:21 <hpc> to some extent, they're a form of type-directed overloading
17:22:26 <hpc> one identifier, many implementations
17:22:41 <hpc> so you don't need the 'Base64.' part
17:22:44 <Tehnix`> tomleb: I don't know about *those* two, I personally prefer Yesod or Servant for web dev'ing. From those two, I'd probably go with Spock, entirely based on their nicer website
17:24:39 <jasonkuhrt> hpc: Yep makes sense! I haven't written/read too much Haskell code so haven't been exposed to the breadth of how that abstraction plays out in the wild for organizing codebases. Looking forwarding to getting more practical experience and knowledge on the topic
17:25:18 <jasonkuhrt> (re "read" I mean Haskell programs proper, I've read a fair bit of simple Haskell code by now)
17:31:23 <jasonkuhrt> Tehnix`: Finished reading that proposal. Looks like a fine step foward, I would welcome it!
17:31:48 <jasonkuhrt> I wish Haskell development was on Github so I could add my thoughts to the the discussion as a user.
17:32:34 <hpc> haskell the language, or development that uses haskell?
17:32:37 <scshunt> Hijiri: yeah, I'm considering some disgusting typeclass crap to allow me to effectively dynamically change state types in a monad
17:32:41 <hpc> a lot of projects are on github
17:33:12 <Tehnix`> jasonkuhrt: hah, that is actually I think that is usually brought up, and also in the context of this extension (it's currently dead in the waters). A recent discussion on the GHC development took place on /r/haskell here https://www.reddit.com/r/haskell/comments/4isua9/ghc_development_outsidein/? which might be somewhat interesting :)
17:33:57 <Tehnix`> hpc: GHC-haskell probably to be specific
17:34:45 <scshunt> oh, I've made a terrible design mistake, goddamin it
17:35:34 <jasonkuhrt> Tehnix`, hpc: Yeah I mean GHC-Haskell
17:35:53 <cdk> which stack command do I use to run Main.hs (as generated by stack init)?
17:37:10 <cdk> it seems that there isn't one
17:37:18 <Tehnix`> cdk: like `stack runghc Main.hs`? Or if you `stack build` it you can do `stack exec the-executable-name` which will run the executable built in the local stack dir
17:38:16 <cdk> Tehnix`: that works, thanks. I expected there to be something equivalent to `cabal run`
17:40:24 <Tehnix`> cdk: I usually end up consulting `stack --help` if in doubt, and then `stack cmdname --help` to get deeper info
17:58:24 <Tehnix`> :O Didn't know you could make "Saved Replies" in GitHub
17:58:31 <Tehnix`> Wups, wrong chan, sorry
18:03:04 <Profpatsch> Does someone know what generates the Paths_packagename modules?
18:03:13 * hackagebot niagra 0.2.3 - High performance CSS EDSL  https://hackage.haskell.org/package/niagra-0.2.3 (natesymer)
18:03:47 <Profpatsch> It somehow generates source files at compile time with module paths.
18:04:01 <Profpatsch> But I have no idea where they come from.
18:04:13 <Profpatsch> This packages has them: https://hackage.haskell.org/package/hprotoc-2.3.0/src/hprotoc.cabal
18:04:36 <Profpatsch> Also, gitit: https://hackage.haskell.org/package/gitit-0.12.1.1/docs/Paths_gitit.html
18:06:41 <jasonkuhrt> Tehnix`: Thanks for the link, I had read that article. Edward Kmett's input was useful I thought https://www.reddit.com/r/haskell/comments/4isua9/ghc_development_outsidein/d31ucx0
18:08:36 <Tehnix`> jasonkuhrt: Indeed, I very much agree with him. The current process is also what keeps me from even trying to do much on GHC atm
18:09:35 <jasonkuhrt> As GHC becomes more popular, I prsume the pressure will mount, but maybe not or it won't matter e.g. Linux
18:09:40 <jasonkuhrt> presume*
18:10:31 <geekosaur> Profpatsch, it's created by cabal (or presumably stack)
18:10:40 <Profpatsch> geekosaur: wtf, I just found out.
18:10:48 <geekosaur> actually it may be part of the lower level cabal machinery
18:10:49 <Profpatsch> How can I change this horseshit?
18:10:51 <geekosaur> ?
18:11:03 <Profpatsch> I am building a static binary.
18:11:34 <Profpatsch> It compiles in the path …
18:11:43 <Profpatsch> Which is of course not where it was.
18:12:02 <geekosaur> then don't use that mechanism, which exists specifically to do that
18:12:17 <Profpatsch> wat
18:12:20 <geekosaur> provide some other way to find data files, via environment variables or parameters or whatever
18:12:33 <geekosaur> or did you think Paths_* does something else?
18:12:50 <Profpatsch> Well, it’s not documented anywhere.
18:13:00 <Tehnix`> Seems is a convention for putting hardcoded paths in a lib?
18:13:18 <Profpatsch> And it’s magically generated without any hint on where or why.
18:13:40 <Tehnix`> Actually there is a file for it, for example the gitit repo https://hackage.haskell.org/package/gitit-0.12.1.1/docs/src/Paths_gitit.html#version
18:13:42 <geekosaur> https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code looks like documentation to me
18:13:56 <Profpatsch> It took me the last two hours to even find out where it comes from.
18:13:56 <Tehnix`> It's just a plain file
18:14:05 <Profpatsch> Or where it’s generated.
18:14:23 <gfixler> guard feels like it's named backwards
18:14:39 <Tehnix`> Admittedly I've never seen this before, so I've no idea what the purpose is for (I'm talking about the Paths_gitit btw)
18:14:50 <Profpatsch> And of course it makes programs break very badly.
18:14:52 <gfixler> I expect (guard (x == 2)) to not let x in if it equals 2
18:14:58 <hpc> clearly it should be named draug
18:15:02 <Tehnix`> geekosaur: ah, thanks for the link :)
18:15:05 <gfixler> I was thinking allow
18:15:11 <gfixler> allow (x == 2)
18:15:20 <Profpatsch> Meh, now I have to patch that out of gitit.
18:15:21 <hpc> class Draug implements Drauger
18:15:35 <gfixler> class MeDroogies
18:15:36 <nitrix> I just want to confirm a thought I had; the equivalent of a class in an OOP language is a typeclass + an existantial wrapper type in Haskell, right?
18:15:41 <nitrix> e.g. data Existantial = ∀s. Super s => MkExistantial s
18:15:49 <geekosaur> niteria, not really
18:15:50 <hpc> i used to be a programmer like you until i took an Arrow to the knee
18:15:54 <geekosaur> whoops, tab
18:16:09 <nitrix> Poor niteria always getting my hilights.
18:16:23 <Tehnix`> Profpatsch: doesn't it give you e.g. the env variable `gitit_bindir` that you can set for the bin dir?
18:16:24 <geekosaur> nitrix, not really. that's a common new-Haskell-programmer trap for those coming from OOP languages, in fact
18:16:29 <hpc> now you know my life in this channel
18:16:40 <hpc> @hoogle hpc
18:16:40 <lambdabot> package hpc
18:16:41 <lambdabot> package hpc-coveralls
18:16:41 <lambdabot> package hpc-strobe
18:16:45 <geekosaur> it looks like it ought to let you pretend typeclasses are OOP but it just gets you in trouble
18:16:52 <nitrix> geekosaur: Mind you I'm not trying to transpose my OOP knowledge to Haskell.
18:17:04 <nitrix> geekosaur: Please don't make assumptions, I'm just looking for the correspondance.
18:17:10 <hpc> there's not really one
18:17:15 <gfixler> @hoogle gfixler
18:17:15 <lambdabot> No results found
18:17:17 <gfixler> :(
18:17:48 <hpc> OOP classes are extremely varied in the features they admit, and some of those features are non-rigorously defined to the extreme
18:17:52 <nitrix> My own game uses ADT, GADTs and some frenkenstein record of functions at times.
18:17:56 <geekosaur> nitrix, I'm not accusing you, I'm noting how it is a common trap for OOP programmers. you've been around here a while, I presume you aren't leaping into that trap
18:18:26 <nitrix> But aren't an existantial and a typeclass enough?
18:18:37 <geekosaur> it does about half of what you'd need to do OO. but m between the existential and the way Haskell's type system works, it makes the other half impossible
18:18:38 <hpc> a class and existential wrapper is considered an antipattern btw, as it's equivalent to a record of class methods
18:18:48 <geekosaur> s/ m / in /
18:18:51 <nitrix> It gives you a set of operations bound to data, which is a concrete type.
18:19:05 <nitrix> hpc: Right.
18:19:24 <hpc> so there's as much correspondance there as with ADTs
18:19:41 <bergey> I really like Oleg's paper on OO in Haskell.  Though I think I learned more about what OO is than about Haskell.
18:20:17 <hpc> there's something to be said for prototype OO, which sort of maps to ADTs
18:21:16 <hpc> for sometimes very tenuous values of "sort of"
18:21:51 <nitrix> geekosaur: hpc bergey That's actually very helpful.
18:21:56 <hpc> but the basic ideas are the same, of keeping method definitions in a data structure and using containing as the relation between types
18:22:27 <nitrix> So if I'm ever temptated to create an existantial wrapper for a class, I know something's wrong with my design.
18:22:30 <tomleb> Why am I having so much trouble with Haskell-on-heroku ? Huhhhhh
18:22:52 <nitrix> I just want mental cues to spot code smell :)
18:23:14 * hackagebot webapp 0.3.0 - Haskell web app framework based on WAI & Warp  https://hackage.haskell.org/package/webapp-0.3.0 (natesymer)
18:23:55 <idev> what's the state of the art in randomized testing? (quick check?) And what is the best way to learn it? (I want to both read the theory + implmentatin papers behind it + actually use it.)
18:28:14 * hackagebot webapp 0.3.1 - Haskell web app framework based on WAI & Warp  https://hackage.haskell.org/package/webapp-0.3.1 (natesymer)
18:33:14 * hackagebot relational-record-examples 0.3.0.1 - Examples of Haskell Relationa Record  https://hackage.haskell.org/package/relational-record-examples-0.3.0.1 (KeiHibino)
18:34:01 <Tehnix`> Is there any good resources on the ' in type signatures? (e.g. `'Lax` in `data instance AuthProtected authdata usr subserver 'Lax = APL...`)
18:34:33 <Tehnix`> s/Is/Are/
18:35:00 <EvanR> its under the DataKinds documentation
18:35:24 <EvanR> its for disambiguating when you want the type or the kind
18:36:49 <Tehnix`> EvanR: thanks! :)
18:38:14 * hackagebot hylogen 0.1.1.2 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.1.2 (sleexyz)
18:38:16 * hackagebot hylogen 0.1.1.3 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.1.3 (sleexyz)
18:48:14 * hackagebot webapp 0.3.2 - Haskell web app framework based on WAI & Warp  https://hackage.haskell.org/package/webapp-0.3.2 (natesymer)
19:08:15 * hackagebot webapp 0.3.3 - Haskell web app framework based on WAI & Warp  https://hackage.haskell.org/package/webapp-0.3.3 (natesymer)
19:08:52 <geekosaur> well there's a nice searchable name >.>
19:09:40 <EvanR> still we dont have killer-webapp
19:18:13 <sm> what *is* going to be haskell's killer app ?
19:18:16 * hackagebot brick 0.6.2 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.6.2 (JonathanDaugherty)
19:21:09 <Profpatsch> RecordWildCards in Lambdas?
19:21:20 <zRecursive> sm: There seems no killer app in haskell ?  However, haskell is good for learning FP programming.
19:21:23 <Profpatsch> data Foo = Foo { foo :: Bar }
19:21:43 <fr33domlover> zRecursive, isn't Pandoc sort of a killer app?
19:21:56 <davidthomas> I have some repeated code that I can't seem to pull out into a function
19:21:57 <Profpatsch> \Foo{..} -> foo
19:21:57 <fr33domlover> I mean, it's the best of its kind, afail
19:22:01 <Profpatsch> Should that work?
19:22:05 <fr33domlover> *afaik
19:22:17 <fr33domlover> Profpatsch, try in GHCi
19:22:18 <burp> https://hackage.haskell.org/packages/ so much killer stuff :D
19:22:19 <vx1r> haxl might be killer-ish, though not super sexy, considering the volume and revenue it's responsible for
19:22:32 <Profpatsch> Oh lol, I wrote LANUGAGE
19:22:35 <vx1r> burp that's not really what killer app means =/
19:22:36 <Profpatsch> Now it works.
19:22:56 <EvanR> vx1r: how much volume and revenue?
19:22:59 <davidthomas> Profpatsch: hah, for me it's usually LANGAUGE
19:23:08 <burp> vx1r: yea, jk
19:23:19 <zRecursive> I think Maxima is killer app in Commom Lisp, ocsigen is a killer app in ocaml ...
19:23:22 <burp> I'd agree with pandoc, or darcs
19:23:30 <geekosaur> fr33domlover, as a developer-oriented app, sure. likewise git-annex. neither one is something that arbitrary people might use though
19:23:45 <andromeda-galaxy> hledger?
19:23:50 <geekosaur> (and xmonad, being a tiling window manager, is firmly nestled in a tiny niche)
19:23:50 <zRecursive> For haskell, xmonad seems good
19:23:55 <burp> ah true, xmonad
19:23:59 <Profpatsch> davidthomas: I want a Hlippy, that jumps up when I start to type {.. and asks if I want to import the extension. :P
19:24:06 <EvanR> rails is used by arbitrary people?
19:24:25 <vx1r> EvanR well it's the primary spam filter for facebook, that's got to be a ridiculous amount of volume.
19:24:29 <andromeda-galaxy> It hasn't really caught on yet, but it's way more awesome than the old ledger and has broad(er) appeal
19:24:36 <EvanR> actually that settles it, there can never be any more killer apps because that is defined as rails, and its like homoiconic languages, there is only 1
19:24:49 <fr33domlover> geekosaur, do websites count?
19:25:04 <vx1r> zRecursive ooh somebody else that likes maxima :D
19:25:05 <andromeda-galaxy> EvanR: if you're thinking of lisps being homoiconic, I wouldn't say that there's only one...
19:25:05 <EvanR> any other suggestions will rightly be criticized
19:25:07 <fr33domlover> many websites may be using Yesod and we don't even notice
19:25:09 <geekosaur> but if you made me pick something written in Haskell that was the closest to a killer app, it'd probably be pandoc
19:25:13 <EvanR> andromeda-galaxy: uh oh
19:25:24 <sm> andromeda-galaxy, how good-looking and intelligent you are 8-)
19:25:43 <vx1r> zRecursive I wish it was better though. my main issue with maxima is the fucking slow performance. especially for the graphical clients like wxMaxima
19:25:45 <andromeda-galaxy> (I used to do (pretty much only) lisps before I got into haskell)
19:26:04 <vx1r> I *really* wish haskell had it's own maxima alternative
19:26:10 <sm> geekosaur: I think it's pandoc too right now, but I'm wishing for something higher-profile
19:26:18 <zRecursive> vx1r: maxima built with SBCL seems fast
19:26:21 <andromeda-galaxy> vx1r: that would be awesome!
19:26:30 <vx1r> doesn't seem to be much interest in symbolic computation in spite of the high density of mathy people :(
19:26:36 <nitrix> I'm really wondering what's the fuss about "killer apps".
19:26:55 <vx1r> zRecursive: well whatever version they have you download as the OSX distribution is pretty damn slow
19:26:58 <andromeda-galaxy> Emacs really needs to become one, since John Wiegley is a haskell dev & the new emacs maintainer
19:27:24 <vx1r> especially the gui front ends. I kind of gave up and use emacs text mode for most maxima work nowadays. looks ugly as hell though.
19:28:01 <andromeda-galaxy> vx1r: with lisps, generally "downloadable binaries" are a hard problem...
19:28:49 <andromeda-galaxy> vx1r: you might want to try installing a good lisp environment (Steel Bank Common LIsp is probably the most performant by a good margin) and then loading maxima from there? (I haven't personally used macsyma in quite a while)
19:28:51 <vx1r> andromeda-galaxy seems like people do little CAS proof of concept blog posts, but nobody has shot for a full-blown symbolic computation engine in haskell
19:29:05 <vx1r> maybe, i'm not really familiar with all this lisp dev ops stuff
19:29:22 <vx1r> just an end user of maxima and elisp... that's about it. why is it so problematic?
19:29:27 <vx1r> does it not compile or something?
19:29:31 <andromeda-galaxy> vx1r: nope!
19:29:48 <vx1r> clisp doesn't have a compiler?
19:29:52 <andromeda-galaxy> the topic of making lisp code run at all, and particularly run fast is long and complicated
19:30:09 <andromeda-galaxy> There are a number of different "interpreters" (like SBCL, CMUCL ClozureCL to name a few)
19:30:10 <vx1r> geez what a turn off
19:30:27 <andromeda-galaxy> because lisp images can do so much introspection and dynamic modification
19:30:45 <andromeda-galaxy> it doesn't work to compile it down to something with as little information left around as machine code
19:31:01 <vx1r> i wasn't that interested in lisp in the first place, the decades of history of failed adoption isn't something i have a strong desire to dive into
19:31:11 <vx1r> got other stuff to do, like learn haskell :P
19:31:13 <andromeda-galaxy> The various lisps are have some really impressive tricks to make them run quickly anyway
19:31:35 <andromeda-galaxy> (SBCL has lots of operation specialization, a good jit, lots of tricks in memory layout, etc.)
19:31:39 <vx1r> andromeda-galaxy well asm can run data as code fine :)
19:32:00 <andromeda-galaxy> vx1r: right, but then you need all of the information to take the "code" in the asm and turn it back into the original lisp forms that you want to manipulate at runtime
19:32:13 <vx1r> yeah that makes sense
19:32:26 <andromeda-galaxy> and that's quite hard (and probably requires something bigger than the original "compiler"), so it's easier to hold on to the original code
19:32:42 <andromeda-galaxy> The images that you're downloading are probably heap images + some lisp interpreter
19:32:45 <andromeda-galaxy> (probably SBCL)
19:32:50 <vx1r> anyway i have my hands full getting a grasp of haskell. if i'm going to use lisp it''ll probably be some modern incarnation
19:32:59 <andromeda-galaxy> but might be old versions, and are almost certainly not well optimized for your hardware
19:33:04 <vx1r> like racket or clojurescript
19:33:15 <andromeda-galaxy> (e.g. IIRC sbcl has lots of target specific optimizations)
19:33:23 <andromeda-galaxy> racket is a very nice language, it's a lot more uniform than CL.
19:33:36 <vx1r> why isn't it more popular?
19:33:44 <andromeda-galaxy> in terms of package ecosystem, and probably performance, a well-tuned common lisp program (at least in SBCl) can probably beat it though
19:34:00 <vx1r> john carmack is the only reason i've heard of racket
19:34:19 <andromeda-galaxy> I'm really not sure, I've always really liked the language, I just like haskell a little bit better :-)
19:34:45 <andromeda-galaxy> I got into racket from "The Little Schemer" => R5RS scheme in DrScheme => <a few years later> Racket
19:35:08 <andromeda-galaxy> (since DrRacket is essentially a rebranded DrScheme and Racket is mostly R6/7RS compliant)
19:35:15 <andromeda-galaxy> but I haven't been too involved in the racket world for the last couple of years
19:35:37 <vx1r> i started with SICP. i didn't realize people use scheme for anything other than SICP but i guess they do
19:35:40 <andromeda-galaxy> EvanR: do you have any examples of languages that are homoiconic but which people refuse to accept as such?
19:35:50 <EvanR> everything except lisp
19:35:57 <andromeda-galaxy> vx1r: yeah SICP is also a very good book, I think it's also mostly in R5RS?
19:36:04 <andromeda-galaxy> EvanR: how is, say, Perl homoiconic?
19:36:08 <vx1r> what is r5rs?
19:36:12 <EvanR> its because theres no good definition of homoiconic that doesnt devolve into "lisp"
19:36:17 <EvanR> andromeda-galaxy: its not
19:36:22 <andromeda-galaxy> vx1r: scheme standard
19:36:33 <andromeda-galaxy> Revised^5 Report on the Algorithmic Language Scheme
19:36:42 <andromeda-galaxy> (but it's bene mostly superceded now, it's from 1998)
19:36:43 <EvanR> its more of a emotional thing, like many things in lisp
19:36:53 <andromeda-galaxy> EvanR: fair enough
19:37:39 <EvanR> so i saw an analogy to killer apps and ruby on rails
19:38:07 <andromeda-galaxy> EvanR: I guess the definition of what the AST is, and whether or not it's isomorphic to the textual syntax is somewhat handwavey
19:38:48 <andromeda-galaxy> now I want to go write a language that is definitely homoiconic and emphatically not a lisp...
19:39:30 <andromeda-galaxy> vx1r: but yeah, lisps are, in my opinion, probably the nicest language family apart from the one including Haskell (also Idris, Agda, etc.)
19:40:08 <vx1r> andromeda-galaxy now that i've seen nice type systems it's hard for me to go back
19:40:10 <andromeda-galaxy> (well, sorry for hijacking that conversation!)
19:40:25 <andromeda-galaxy> vx1r: yeah, definitely---that's what happened to me
19:40:49 <davidthomas> is forth homoiconic?
19:40:53 <vx1r> i wonder how long it will take the rest of the world to catch up to the distinction between type systems for people vs. type systems for compilers
19:41:09 <vx1r> also, i feel like lisp had it's shot and pretty muched missed every window of opportunity
19:41:16 <vx1r> most recently with clojure
19:41:30 <andromeda-galaxy> vx1r: Hopefully not too long, people in industry are slowly starting to recognize the promise
19:41:53 <andromeda-galaxy> vx1r: yeah, lisp has not been the best at getting people to catch on.
19:42:06 <andromeda-galaxy> Then again, our unofficial slogan is aparently "avoid success at all costs"!
19:42:58 <andromeda-galaxy> davidthomas: nice question! I suppose that according to the dictionary definition, we'd have to decide if a/the forth "compiler" reads forth into a tree that directly mirrors its syntax or not
19:43:06 <vx1r> i feel like 26 years is a reasonable enough long term investment to cash something in
19:43:36 <andromeda-galaxy> davidthomas: but overall I agree witih EvanR that that's not a very good definition---what would happen if someone made a lisp compiler that used a different internal representation but was externally the same?
19:44:01 <andromeda-galaxy> vx1r: from the point of view of having lots of fun writing code, or from that of pl research, I'd argue that lisp has had a very good record
19:44:10 <andromeda-galaxy> it just hasn't been good at convincing people that it's good
19:45:31 <vx1r> anyone know of any good haskell openings?
19:54:33 <ElMoloko> do notation is just sin-tactic sugar really, like list comprehensions
20:02:28 <argent0> Hi, what's the haskell 7.10 equivalent of hSelect?
20:04:28 * argent0 Installed select-0.4.0.1
20:08:16 <andromeda-galaxy> argent0: hSelect?
20:11:23 <andromeda-galaxy> By the way, is there a projected replacement for the functionality provided by the boxy types implementation that was ripped out in GHC 7.0?
20:11:41 <andromeda-galaxy> Having to write type signatures *everywhere* when dealing with Rank-3 typ esis *annoying*
20:12:53 <geekosaur> argent0, usually you don't use select/poll/epoll directly but let GHC's IO manager do it for you. what problem are you trying to solve?
20:13:05 <fresheyeball> anyone out there can help me with Servant?
20:14:29 <nitrix> I'm getting my ">>=   Stay lifted"  Haskell T-shirt tomorrow :D !
20:15:08 <geekosaur> (because if you try to do it yourself and it blocks, you will screw up thread scheduling --- or indeed prevent other threads from running, if you are not using the threaded runtime. and even with the threaded runtime, there are a number of gotchas)
20:18:19 <dfeuer> andromeda-galaxy, if you write one and it's really good, I bet you could get it merged.
20:18:43 <andromeda-galaxy> dfeuer: that would be great fun, but not nearly something that I could do now :)
20:19:10 <andromeda-galaxy> I was just wondering if there was/wasn't a concrete plan, since I can't find much information about the original addition/removal of boxy types
20:19:20 <dfeuer> andromeda-galaxy, sadly, there are very few really great type system hackers. More sadly, I'm not one of them either.
20:20:03 <davidthomas> if I have a pile of functions of the form (forall a . Q a => a -> B), for various Q, B...
20:20:06 <dfeuer> I gather that a lot of people complained the boxy types error messages were inscrutable, but I also remember someone telling me they were okay once you got used to them....
20:20:35 <andromeda-galaxy> dfeuer: true enough (about the lack of type system hackers). I'd love to be one as well
20:21:05 <andromeda-galaxy> dfeuer: I think that the implementation was also a major source of complexity?
20:21:15 <idev> is there any haskell library for doing sms phone # verification?
20:21:19 <davidthomas> and I have several ways of making an A such that Q A for all of those Q
20:21:26 <idev> i.e. I want to verify that the user has access to phone number abc-defg
20:21:31 <andromeda-galaxy> dfeuer: no-one seems to have come up with a better way of providing the same functionaly that I could find, so I was just wondering if I'd missed something
20:21:32 <dfeuer> andromeda-galaxy, could be.
20:22:23 <davidthomas> is there any way of factoring out the picking of which A is desired?
20:23:11 <davidthomas> I can do it inline at all the call sites for the various functions
20:23:21 <davidthomas> but I can't seem to give it a type if I pull it out as a function
20:26:13 <dfeuer> davidthomas, what problem are you having? Are your A values polymorphic?
20:28:18 <argent0> geekosaur: I want to launch a subprocess and send the parent's stdin and some other input (generated by the parent)
20:28:54 <geekosaur> one would use threads for this normally, not try to go behind the runtime's back
20:29:01 <athan> Why is `(\x -> x ** x) 144 :: Double` = "Infinity"? 
20:29:24 <argent0> geekosaur: ok, i will research that alternative. Thanks
20:29:35 <athan> I hope this doesn't break lambdabot...
20:29:36 <andromeda-galaxy> athan: the result is too big for floating point?
20:29:49 <athan> > (\x -> x ** x) 144
20:29:51 <lambdabot>  Infinity
20:29:55 <athan> :\
20:30:19 <athan> andromeda-galaxy: Hmm... okay
20:30:21 <EvanR> argent0: for general process shenanigans theres is System.Process
20:30:24 <athan> > (\x -> x ** x) 144 :: Rational
20:30:26 <lambdabot>      No instance for (Floating Rational) arising from a use of ‘**’
20:30:26 <lambdabot>      In the expression: x ** x
20:30:26 <lambdabot>      In the expression: \ x -> x ** x
20:30:28 <dfeuer> I just added fmap/reverse and reverse/fmap rewrite rules to Data.Sequence. Any other ones people have been dreaming of?
20:30:34 <andromeda-galaxy> athan: (**) assumes Floating a
20:30:39 <athan> oh snap
20:30:43 <andromeda-galaxy> athan: for integer/rational exponentiation you probably want (^)
20:30:53 <davidthomas> dfeuer: naturally, I solved my problem right after asking the question
20:30:56 <dfeuer> Or ^^ if the exponent might be negative.
20:31:03 <davidthomas> thanks, though! :)
20:31:05 <EvanR> dfeuer: nice, is this s significant speed boost?
20:31:06 <dfeuer> davidthomas, that is indeed a natural law.
20:31:08 <andromeda-galaxy> dfeuer: oops, yeah that's a good thought
20:31:34 <athan> well I'd still like the ability to do rooting with `root n x = x ** (1/n)` andromeda-galaxy
20:32:09 <dfeuer> EvanR, dunno. The reverse function has always been implemented *using* a function that basically does fmap f . reverse (to deal with the nested types sequences are made of). So this was practically a freebie.
20:32:19 <andromeda-galaxy> athan: yeah, it's true that (^) assumes the exponent is integral
20:33:02 <andromeda-galaxy> athan: is it necessarily always possible to get the exact Rational root of a Rational?
20:33:36 <athan> andromeda-galaxy: That's a good question haha
20:33:46 <andromeda-galaxy> athan: e.g. the builtin sqrt is Floating a => a -> a
20:33:57 <argent0> EvanR: I'm currently using that to run the subprocess, thanks
20:34:12 <andromeda-galaxy> athan: (and I think (but am not sure) that usually these root functions use iterative approximation algorithms that work better with floating point numbers)
20:34:19 <dfeuer> EvanR, that is, all I needed to write was a thin wrapper `coerce`ing the passed function to the correct type, and then pass it on to the function reverse would call anyway.
20:34:43 <athan> andromeda-galaxy: For performance I'm guessing right? Right on, hmm
20:35:32 <EvanR> exactly what is a square root of a rational
20:35:43 <andromeda-galaxy> EvanR: precisely what I was getting at
20:35:44 <EvanR> ive heard of square root of an integer (effectively the floor)
20:35:51 <andromeda-galaxy> athan: e.g. sqrt(2) :: Rational -> Rational
20:35:51 <geekosaur> you'd end u with some great huge rationals otherwise
20:36:17 <andromeda-galaxy> that can't work, because there is no Rational which when squared = 2
20:36:48 <EvanR> there is this:
20:37:02 <geekosaur> yep and if you try to approximate it then you end up with a rational that has hundred-digit num and denom
20:37:03 <athan> I mean really it's just `pow :: Ratio Integer -> Ratio Integer -> Ratio Integer`
20:37:03 <EvanR> > sqrt (realToFrac (1 % 3)) :: CReal
20:37:05 <lambdabot>  0.5773502691896257645091487805019574556476
20:37:13 <EvanR> but thats not rational
20:37:21 <athan> yeah it is
20:37:27 <athan> er oh
20:37:28 <EvanR> no its not?
20:37:34 <athan> your example, sorry
20:37:40 <EvanR> > sqrt (realToFrac (1 % 9)) :: CReal
20:37:42 <lambdabot>  0.3333333333333333333333333333333333333333
20:37:44 <geekosaur> it's truncated
20:37:44 <EvanR> that is 
20:37:50 <andromeda-galaxy> EvanR: if anything goes through Floating/Double, then the lack of precision errors that athan was having trouble with come in to play
20:37:55 <andromeda-galaxy> 144^2 = Infinity
20:38:11 <dfeuer> Anyway, I'm much more excited about the performance gains I got from changing the splitAt implementation. Boo-yah! Pretty big gains for splitting short sequences, and also for zipping sequences.
20:38:16 <geekosaur> that was 144^144
20:38:37 <EvanR> nice, ive always wondered whether Data.Sequence was appropriate, in terms of performance and easy of use
20:38:48 <geekosaur> which, yeh, Double's exponent overflows
20:38:48 <andromeda-galaxy> sorry, I was trying to write arrow notation and didn't input the arrows right
20:39:18 <dfeuer> EvanR, usually not :P. It has some very impressive big-O asymptotics, but the constant factors mostly suck.
20:39:21 <andromeda-galaxy> 144 arrow arrow 2 = 144 ^ 144 IIRC
20:39:23 <geekosaur> and I don't think there's a Haskell type corresponding to C (long double)
20:39:32 <dfeuer> Which is why I was glad to improve them a bit.
20:39:33 <geekosaur> even when that exists as a real thing
20:39:50 <andromeda-galaxy> and all of our perfectly precise types don't work because it's not a problem that can generally be done with perfect precision
20:40:02 <dfeuer> Last time I touched zipWith in Data.Sequence I made it about five times faster. Not quite so impressive this time, but definitely measurable.
20:40:12 <andromeda-galaxy> athan, EvanR, geekosaur: Something like Data.Real.Constructible might be mildly useful?
20:40:45 <EvanR> the package exact-real is really nice
20:40:58 <dfeuer> FSVO useful.
20:41:12 <athan> What's interesting is that you can at least break it into two integral actions though
20:41:15 <EvanR> it beats all the lazy reals i found 
20:41:43 <EvanR> athan: can you?
20:41:56 <nshepperd_> EvanR: terrible_sqrt (p % q) = integer_sqrt p % integer_sqrt q? :p
20:42:00 <EvanR> are you talking about the "law" sqrt(a/b) = sqrt(a) / sqrt (b)
20:42:01 <athan> so `x ** (Ratio n d) = root d (power n x)`
20:42:02 <andromeda-galaxy> EvanR: I hadn't come across that, looks interesting
20:42:18 <dfeuer> geekosaur, the lack of an Int128 is very unfortunate, and forced me to make https://github.com/haskell/containers/blob/master/Data/Utils/BitQueue.hs much more complicated than it would have been otherwise.
20:42:31 <dfeuer> Or Word128, even.
20:42:36 <EvanR> or Word256
20:42:49 <dfeuer> Oh wait, you're talking about a long double, not a double long.
20:42:50 <dfeuer> Sorry.
20:42:54 <EvanR> idris has us beat, it has a dependent n-bit number ;)
20:42:56 <andromeda-galaxy> athan: there seem to be a number of packages that might be able to do roughly what you want
20:43:32 <athan> right on, thank you andromeda-galaxy & gang :)
20:43:43 <dfeuer> EvanR, that is very much not useful when your goal is to implement an almost-queue holding 126 bits....
20:43:56 <andromeda-galaxy> athan: no problem, glad to be able to help.  I hope you figure out how to do what you need to!
20:44:03 <EvanR> almost-queue?
20:44:45 <dfeuer> EvanR, it's not a full-service queue. It has a "builder" for all snoccing, then a "build" function to make the final form which supports uncons.
20:45:00 <EvanR> ah
20:45:06 <dfeuer> The "build" function counts zero bits and does some shifting and masking and stuff.
20:45:29 <dfeuer> BTW, EvanR, if you can speed up that implementation, please do. I'm no bit hacking guru.
20:45:42 <nshepperd_> I'm sure one day largeword will be in base
20:46:34 <EvanR> of the almost queue? where is that
20:46:45 <dfeuer> EvanR, https://github.com/haskell/containers/blob/master/Data/Utils/BitQueue.hs
20:47:16 <dfeuer> I used it to implement alterF for Data.Map.
20:47:37 <dfeuer> For reasons I really should document in the source.....
20:47:56 <EvanR> mmm raisins
20:48:27 <EvanR> does this data structure need to use at most 2 words
20:49:15 <dfeuer> Yeah... Basically, it's really, really hard to beat "just find the right key again" when implementing an `at` lens into  Map Int v. But when you have heavier keys, and a functor like [], that's another story.
20:50:10 <dfeuer> Two words? Well, two words is slower than one word. If I could get enough bits into one word I'd do that, but the words aren't big enough.
20:51:25 <dfeuer> So ... I'd be willing to test an implementation that uses more words, but I'd be surprised if it could beat this one when applied....
20:51:57 <dfeuer> What do you want to do, EvanR, store the length? You're welcome to try; I haven't done that yet.
20:52:19 <dfeuer> Just run the Data.Map benchmarks to compare alterF performance.
20:52:32 <dfeuer> (the "no rules" benchmarks, in particular)
20:52:59 <EvanR> how does the guard bit work
20:53:07 <EvanR> 0 1 is "empty" ?
20:53:32 <dfeuer> Empty builder = 100000000....   Empty queue = 0000000001
20:53:35 <EvanR> i was thinking store the "pointer" int the two words
20:53:55 <EvanR> into the
20:54:07 <dfeuer> Bits gets snocced on from the left, and unconsed off the right.
20:55:14 <EvanR> is 126 enough, how about 123 or so ;)
20:55:16 <dfeuer> EvanR, how will you implement the indexing? I considered that at one point, but it started to look messy and it was an extra word so I gave up. But if you do it, I'll be happy to benchmark it myself if you don't want to.
20:56:02 <dfeuer> 123 is enough for now.
20:56:46 <dfeuer> I figure I need 121 to cover current address space sizes for 64-bit machines, but it never hurts to have room to spare.
20:57:15 <EvanR> in that case maybe all there is left to do is get some bit wizardry to do the shifting faster
20:57:41 <dfeuer> A 31-bit queue would be enough for *many* purposes, but it's not free to check every time (although I don't know why it seem to actually cost enough to matter).
20:59:04 <dfeuer> Er ... I meant a 64-bit queue.
20:59:11 <dfeuer> 63-bit.
20:59:13 <dfeuer> Oy.
21:00:01 <dfeuer> There's very nice bit wizardry for 63 bits, using subtraction and such. For 126 it's much less clear.
21:04:05 <fresheyeball> anyone know where the Arbitrary instance for Text is?
21:05:16 <EvanR> what if you dequeue the first word first, then when its empty dequeue the second word
21:05:30 <EvanR> at the change over swap the two words
21:05:51 <EvanR> each dequeue would use the faster 63 bit tricks
21:06:59 <EvanR> not sure about the builder
21:09:55 <nocturne777> some people say that for streaming purposes Haskell's builtin laziness should not be used in production and that pipe/conduit should be used instead
21:10:13 <nocturne777> could someone enlighten me on this?
21:10:27 <sm> they are more predictable
21:11:34 <jle`> nocturne777: it's not laziness that's the problem
21:11:38 <jle`> it's lazy IO
21:11:46 <jle`> something unrelated to haskell's laziness
21:12:14 <jle`> it's a problem with how 'readFile' and related methods in Prelude/base are implemented
21:12:20 <EvanR> missile launching will occur as soon as the program needs to check the flight parameters, if ever
21:12:44 <EvanR> making it weirder than usual 
21:12:45 <jle`> nocturne777: a lot of the IO methods provided in base/Prelude are implemented in "lazy IO" style
21:12:45 <nocturne777> in this case when relying on pure laziness, we are  at the mercy of the garbage collector, I think
21:12:58 <jle`> "lazy IO" is unrelated to haskell laziness
21:13:11 <jle`> it's just the style of the way readFile etc. happen to be implemented in
21:13:20 <jle`> they're unsuitable for complex streaming purposes
21:13:20 * hackagebot casr-logbook 0.0.7 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.0.7 (TonyMorris)
21:13:22 <nocturne777> I see
21:13:23 <EvanR> the gc is doing stuff either way
21:13:42 <idev> is there some haskell library that is like snap lego pieces together?
21:13:55 <jle`> but it's not a problem with haskell's laziness, it's just a consequence of how readFile is implemented by default
21:14:11 <EvanR> lego pieces would require dependent types
21:14:11 <JuanDaugherty> one of the web frameworks uses that name
21:14:19 <jle`> mostly that it provides no guaruntees for file handle closing, fun stuff like that
21:14:26 <jle`> which is something that would be nice to have in a lot of cases
21:14:28 <nocturne777> jle`: how about streaming stuff with Text.Lazy ?
21:14:42 <jle`> it depends if their IO methods are implemented in lazy-IO style
21:15:07 <EvanR> consuming lazy text generated in pure code is really nice
21:15:09 <jle`> "lazy IO" is a slightly unfortunate name because it might make you think it's related to haskell laziness
21:15:25 <jle`> but it's just a specific style of implementing IO actions
21:15:48 <jle`> other styles could have been chosen
21:16:37 <nocturne777> EvanR: what do you mean by the missile launching example? 
21:16:44 <jle`> lazy-IO style IO is nice for simple use cases, but the lack of the ability to reason about it makes it unsuitable for serious/complex streaming
21:17:25 <jle`> 90% of the time in normal every day usage though, lazy IO is adequate
21:17:30 <EvanR> launchMissile :: IO (), if implemented with unsafeInterleaveIO like readFile and getContents, would immediately return a () when executed, but no missiles would launch until (if ever) something evaluates the ()
21:17:33 <jle`> which is what made it so tempting :)
21:18:15 <EvanR> which means you actually have to care when stuff is evaluated
21:18:23 <EvanR> which is tougher
21:19:18 <slack1256> Hi I am using Network.Socket.ByteString. I want to know when a socket closed its half of a tcp socket. The docs says that I receive a zero length message. Yet using `recv sock 2048` I supposed this function will never return on such message
21:19:29 <jle`> pipes/conduit lets you handle streaming constant-space IO in ways that give you guaruntees and laws about how resources are handled
21:19:40 <slack1256> Should I be listening for an exception or it will return the zero size buffer even so?
21:19:50 <jle`> lazy-IO style IO actions let you handle streaming IO in ways with 0 guaruntees or laws about how resources are handled
21:20:57 <idev> does haskell have a notion of "import qualified Foo EVERYTHING, even the things that are not exported?" // I want to have Testing / Implementation code be two separate files, but this requires I have access to internal/hidden stuff
21:21:46 <geekosaur> idev, no
21:22:16 <geekosaur> although if ghci compiles something to bytecode, it makes all names available (as does runhaskell/runghc)
21:22:54 <idev> geekosaur: hmm, so if Testing code wants to see un-exported stuff, it needs to be part of the same module?
21:23:01 <geekosaur> generally one makes a .Internal module which the public module imports and then doesn't re-export the internals, but you can get to them by importing the .Internal
21:23:19 <idev> yeah, but that explodes 1 file => 3 files
21:23:21 * hackagebot webapp 0.3.4 - Haskell web app framework based on WAI & Warp  https://hackage.haskell.org/package/webapp-0.3.4 (natesymer)
21:23:26 <idev> there's a .Internal, .Testing, and .Public
21:23:26 <geekosaur> (this is also recommended because invariably *someone* comes up with a good reason to be able to access your internal stuff)
21:23:54 <idev> I think that's a bad idea as it allows people to code vs IMPL rather than code vs API
21:24:59 <geekosaur> and? what stops someone else from using the same magic import you do for testing?
21:26:02 <idev> geekosaur: People who use {-# LANGUAGE UNSPEAKARABLE_HACK #-} are well aware that this depends on internals and may break
21:26:10 <idev> but I guess people who import .Internal may also already be in that mindset
21:26:26 <geekosaur> yes. generally the name is a good enough warning
21:27:43 <EvanR> haskell does seem to need more modules
21:27:54 <slack1256> How do I know the other half of the socket is closed?
21:27:57 <slack1256> tcp socket
21:27:58 <EvanR> if you want 1 module, you live with simplified structures
21:28:08 <EvanR> like full access
21:28:33 <EvanR> slack1256: when you read from it, youll get 0 bytes back
21:28:36 <geekosaur> slack1256, if you're reading then you get EOF. if writing then you get SIGPIPE
21:28:36 <idev> the problem is that instead of Foo.hs
21:28:47 <idev> I now have Foo/ Foo/Internal.hs Foo/Test.hs Foo/Public.hs
21:28:54 <idev> this makes me unhappy as it's 4 lines in my NerdTREE window
21:29:24 <EvanR> then expose everything in Foo.hs for testing
21:29:48 <slack1256> Even when I say `recv sock 2048`? will this ever return on such case?
21:29:57 <slack1256> (block in such case)
21:30:12 <EvanR> i use ByteString's Handle IO 
21:30:13 <sm> idev: some people put the tests farther away in a tests/ hierarchy
21:31:32 <slack1256> Mmm hGet in bytestrings doc say what it will do
21:31:39 <slack1256> thanks EvanR geekosaur
21:32:04 <sm> you could also use doctests, which might clutter code a bit less
21:34:47 <idev> https://hackage.haskell.org/package/doctest-0.11.0/docs/Test-DocTest.html is almost useless
21:34:50 <idev> how does doctests work?
21:35:05 <idev> oh
21:35:08 <idev> it's not going to work for me
21:35:15 <idev> then things I have have way too much internal structure
21:35:24 <idev> I have a new implemenetaion of virtual-dom trees
21:36:10 <sm> I am liking doctests a lot. There's no reason they can't test complex things
21:36:22 <idev> https://github.com/sol/doctest
21:36:29 <idev> it seems to base on idea that output is simple enough to show
21:36:37 <idev> not good for big/large data structures
21:36:54 <sm> you can simplify the output
21:38:29 <idev> you may have nissed the part where I said 'virtual dom'
21:38:36 <idev> have you seen how complicated webpages are?
21:39:09 <sm> I can imagine, but surely you can test a lot without printing the full literal output
21:39:40 <idev> no
21:39:46 <idev> this argument stupid
21:39:56 <idev> maybe it works; but I can't see it
21:42:22 <slack1256> for faking cheaply a while loop, should I use ExceptT and it short-circuiting behaviour + forever?
21:42:43 <slack1256> *its
21:42:51 <Myrl-saki> waitTimeout :: ThreadId α -> Integer -> IO (Maybe (Either SomeException α))
21:43:12 <Myrl-saki> Wouldn't IO (Either (Maybe SomeEcteption) α) be bettir here?
21:43:12 <scshunt> slack1256: what are you actually trying to do?
21:43:47 <slack1256> recv socket until get EOF. then close socket
21:43:57 <Myrl-saki> That returns Nothing on timeout, Just $ Left ex on excption, and Just $ Right x on success.
21:44:20 <scshunt> slack1256: http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#
21:44:20 <Myrl-saki> Any reason why that
21:44:46 <slack1256> scshunt: it's a contribution, I don't want them to pull more dependencies :-)
21:44:56 <Myrl-saki> Any reason why what they choose would be better, except for the guarantee that everything is of the same depth?
21:45:28 <scshunt> slack1256: I'd say just write your own combinator then
21:45:42 <scshunt> slack1256: not that monad-loops is a big lib
21:45:52 <sm> idev: there's also things like http://hackage.haskell.org/package/tasty-golden
21:46:07 <EvanR> slack1256: fake cheap while loop, stupid fix tricks
21:46:20 <slack1256> mfix tricks?
21:46:26 <EvanR> regular fix
21:46:37 <EvanR> fix $ \loop -> do
21:46:50 <slack1256> maybe throwing an exception + forever
21:46:52 <slack1256> mmmmmmm
21:46:56 <slack1256> that will work
21:47:02 <EvanR> inside the do choose whether to loop or return
21:47:05 <slack1256> it will fix it
21:47:31 <slack1256> nice!
21:47:37 <slack1256> I will use this
21:49:35 <Myrl-saki> Hmmm
21:49:45 <Myrl-saki> [a] -> [[a]] -> [b]
21:50:14 <Myrl-saki> Rather... [a] -> [[a]] -> [b]
21:50:31 <Myrl-saki> I'm stupid.
21:50:38 <Myrl-saki> [a] -> [[a]] -> m [b]
21:51:17 <Myrl-saki> There we go. It's not a function's type. It's how I plan to make something.
21:52:03 <Myrl-saki> forM (transpose . chunksOf 16 $ xs) (mapM (mapM ...))
21:52:37 <Myrl-saki> Rather, (mapM (forkIO $ mapM ...))
21:52:52 <Myrl-saki> Is that sane?
21:53:01 <Myrl-saki> Or is there a cleaner way?
21:53:47 <Myrl-saki> :t \xs f -> forM (transpose . chunksOf 16 $ xs) (mapM . forkIO $ f)
21:53:48 <lambdabot> Not in scope: ‘forkIO’
21:53:53 <Myrl-saki> Meh...
21:54:19 <Myrl-saki> @let forKIO = id
21:54:20 <lambdabot>  Defined.
21:54:24 <Myrl-saki> @let forkIO = id
21:54:25 <lambdabot>  Defined.
21:54:29 <Myrl-saki> :t \xs f -> forM (transpose . chunksOf 16 $ xs) (mapM . forkIO $ f)
21:54:30 <lambdabot> Monad m => [a] -> (a -> m b) -> m [[b]]
21:54:46 <Myrl-saki> :t \xs f -> forM (transpose . chunksOf 16 $ xs) (mapM . forkIO . mapM $ f)
21:54:47 <lambdabot> (Monad m, Traversable t) => [t a] -> (a -> m b) -> m [[t b]]
21:54:58 <Myrl-saki> That didn't work. Lol.
21:55:30 <java_man> hello?
21:55:47 <Myrl-saki> :t \xs f -> forM (transpose . chunksOf 16 $ xs) (\xss -> mapM (\xs -> forkIO (mapM f xs)) xss)
21:55:49 <lambdabot> (Monad m, Traversable t) => [t a] -> (a -> m b) -> m [[t b]]
21:55:51 <java_man> ah
21:55:55 <Myrl-saki> Weird. I'll try this again.
21:55:57 <Myrl-saki> I have to go.
21:56:17 <java_man> question - for long iterations with logged/printed output that takes on the order of 5-60 mins
21:56:45 <java_man> is it more convenient (from a rapid development & frequent re-running standpoint) to express it as a pipe or a fold?
22:03:22 * hackagebot random-variates 0.1.5.0 - "Uniform RNG => Non-Uniform RNGs"  https://hackage.haskell.org/package/random-variates-0.1.5.0 (kpratt)
22:04:18 <EvanR> java_man: do you want a real time feed like tail -f, or
22:05:28 <idev> okay
22:05:33 <idev> sop I figure out my module / testing / internal problem
22:05:46 <idev> I'm going go just put the word Internal at the end of every data type / constructor / function meant to be internal
22:05:56 <idev> and thus still have just 1 *.hs file
22:15:03 <java_man> EvanR: real time would be preferable
22:15:48 <EvanR> so theres simplfy putStrLn in your code, a logger thread, a LoggerT transformer, pipes
22:16:01 <java_man> EvanR honestly there aren't many professional applications with a human in the loop that wouldn't necessitate some sort of realtime feedback for a 5+ minute process
22:17:15 <EvanR> and accumulating a huge log in memory which might get lost and is intended to eventually just output seems like a waste
22:18:20 <java_man> yeah but a log could be as simple as "10% done"
22:18:23 * hackagebot mnist-idx 0.1.2.4 - Read and write IDX data that is used in e.g. the MNIST database.  https://hackage.haskell.org/package/mnist-idx-0.1.2.4 (muzzle)
22:19:43 <EvanR> oh
22:19:46 <EvanR> progress bar
22:20:03 <EvanR> https://hackage.haskell.org/package/terminal-progress-bar
22:38:20 <java_man> EvanR progress is just an example. my point is that the point is for a long running computation, some monitoring will be useful. doesn't have to be a huge log.
22:38:35 <java_man> i'm not looking for a progress bar solution
22:39:50 <EvanR> there is EKG for monitoring resource usage, its almost a drop in for any given app
22:40:17 <EvanR> you can also design your own monitoring UI, this terminal-based framework just came through the pipe `brick'
22:42:32 <java_man> monitoring? that seems like more of a complex fudge than pipes
22:43:29 <EvanR> you just asked for monitoring
22:45:19 <bollu> Iceland_jack, Cale: ping, cat. theory question
22:45:24 <bollu> how do adjunctions generate a monad?
22:47:36 <EvanR> http://stackoverflow.com/questions/4697320/monads-as-adjunctions
22:47:51 <athan> > logBase 4 (2 ** 4)
22:47:53 <lambdabot>  2.0
22:47:56 <athan> > logBase 5 (2 ** 5)
22:47:58 <lambdabot>  2.1533827903669653
22:48:01 <athan> > logBase 6 (2 ** 6)
22:48:03 <lambdabot>  2.3211168434072493
22:48:06 <athan> :(
22:49:18 <opqdonut> that's... not how it works
22:49:20 <opqdonut> > logBase 2 (2**6)
22:49:21 <lambdabot>  6.0
22:49:30 <opqdonut> > logBase 6 (6**3)
22:49:32 <lambdabot>  3.0000000000000004
22:49:52 <EvanR> bollu: the code there gives an explicit construction of a monad for any two adjoint functors
22:51:17 <athan> bahaha crap thanks opqdonut 
22:57:38 <bollu> EvanR: what is compose?
22:58:31 <bollu> as in, Compose g f
23:00:13 <EvanR> newtype Compose f g a = Compose { getCompose :: f (g a) }
23:02:21 <EvanR> so (a -> ) `Compose` (a,) = a -> (a,)
23:02:42 <EvanR> if that was valid syntax which i doubt it is
23:03:26 <EvanR> a -> (a,) is isomorphic to the State monad
23:10:37 <bollu> EvanR: ah
23:10:43 <bollu> EvanR: that's an insanely cool observation
23:15:50 <raduom> I am a bit of a noob when it comes to maths. Any ideas as to where I could start learning Category Theory?
23:17:32 <EvanR> this book seems pretty good so far, categories for the working mathematician by saunders mac lane
23:17:54 <raduom> thanks. will go for it.
23:19:43 <bollu> also, I'm writing bindings for SymEngine
23:19:54 <bollu> and I really really want a sane numeric tower
23:20:13 <bollu> should I use a proper math-based numeric tower?
23:20:21 <bollu> like, from, algebra by kmett?
23:20:22 <EvanR> (but numerics arent a tower)
23:20:51 <EvanR> i.e. a linear subtyping hierarchy
23:20:53 <bollu> EvanR: they are..? The whole Num, Rational, Fractional, … 
23:21:04 <bollu> AFAIK, tower doesn't mean linear
23:21:05 <EvanR> in haskell they arent either
23:21:06 <bollu> https://en.wikipedia.org/wiki/Numerical_tower
23:21:31 <bollu> EvanR: so, well, what do you recommend?
23:21:41 <EvanR> dont mind me just complaining
23:21:46 <bollu> do you think the design space is interesting? to use proper rings / fields / whatever?
23:21:49 <pavonia> raduom: As a small overview, https://en.wikibooks.org/wiki/Haskell/Category_theory is a good start
23:22:21 <EvanR> bollu: i havent seen practical use for those algebraic structures in doing numeric programming
23:23:30 <bollu> EvanR: this is more symbolic math
23:23:31 <bollu> also, does the fact that (->) and (,) are adjoint have some connection to curry/uncurry?
23:24:47 <EvanR> even in algebra, the monoids, rings, groups, fields and whatever you are left with at sedenions are more like a numeric salad bowl
23:34:03 <johnw> bollu: it's not (->) and (,) that are adjoint
23:34:34 <johnw> bollu: it's the functors ((->) a) and ((,) a) that are adjoint; and they don't just have a connection with curry/uncury; that adjunction *is* curry/uncurry
23:35:00 <Reshi> Does anyone have a day job not in Haskell? But still have side projects in Haskell. I think I am going to find myself in that situation.
23:35:58 <bollu> johnw: oh
23:36:01 <bollu> johnw: hmm, I see
23:36:11 <simpson> Reshi: Yeah, I've never had Haskell at my day job but still had Haskell side projects.
23:36:12 <bollu> johnw: I'd seen curry/uncurry being connected through the exponential
23:36:20 <bollu> so this means that the exponential and adjunction are connected?
23:37:21 <Reshi> simpson: Do you find you have to make time for it?
23:38:31 <simpson> Reshi: Well, of course.
23:39:58 <johnw> bollu: i.e.: f a -> b ≅ a -> g b; that is: (a * r) -> b ≅ a -> (r -> b)
23:40:07 <johnw> bollu: I don't know what you mean about exponential and ajdunction being connected
23:41:11 <johnw> unless you are talking about the isomorphism that arises from adjunction being expressed in terms of exponents (functions)
23:41:32 <bollu> johnw: I was wondering that, well, you said tat the adjunction *is* the currying
23:41:44 <bollu> however, you can also see the currying by chasing the diagram of the exponential object, right
23:41:44 <bollu> ?
23:41:48 <johnw> but it doesn't actually need to be exponentials at all
23:41:59 <johnw> the actual form is: Ψ c,d:hom D(L(c),d)≅hom C(c,R(d))
23:42:41 <johnw> these are just hom-sets; the fact that exponentials/functions/hom-sets coincide in Hask should not confuse the matter
23:43:06 <bollu> johnw: oh, so it's a quirk of haskell that it works out neatly?
23:43:11 <johnw> yes
23:43:39 <johnw> it's better not to think in terms of Haskell if what you want to know lies outside of Haskell
23:43:55 <johnw> it's great as one example, but you often can't/shouldn't generalize
23:44:50 <bollu> johnw: ah, alright, thanks :)
23:44:59 <bollu> johnw: what are some nice examples of categories other than Poset and Top?
23:45:08 <bollu> johnw: I want something with an interesting flavour
23:45:14 <johnw> I like graphs
23:45:29 <bollu> johnw: how do they form a category?
23:45:45 <johnw> objects are vertices, morphisms are edges, composition is edge concatenation
23:46:08 * simpson blinks
23:46:10 <Hijiri> I thought morphisms were paths
23:46:16 <EvanR> only some graphs are categories ...
23:46:24 <simpson> Huh, that's an interesting trick.
23:46:44 <Cale> Yeah, the arrows have to be paths so that you have something to concatenate :)
23:47:07 <Cale> There's also the category of graphs and graph homomorphisms
23:47:35 <johnw> https://golem.ph.utexas.edu/category/2011/03/which_graphs_can_be_given_a_ca.html
23:47:44 <johnw> sorry, I did mean paths
23:47:51 <Cale> Whose objects are graphs, and whose arrows f: X -> Y are functions from the vertex set of X to the vertex set of Y such that whenever x ~ y, we have f(x) ~ f(y)
23:48:18 <Cale> (where by x ~ y, I mean the vertex x is connected to the vertex y by an edge)
23:48:28 <EvanR> x~x ?
23:48:39 <Cale> Usually you don't allow x ~ x
23:48:49 <Cale> But you can talk about graphs with self-loops if you want
23:49:24 <Cale> This definition works with only minor adjustments for many different flavours of graph
23:50:40 <EvanR> so graph homomorphisms can add new edges
23:52:06 <Cale> In the sense that it's possible for x to not be adjacent to y, but f(x) ~ f(y), yeah
23:54:26 <Cale> There's a graph homomorphism from the graph which is a cycle of n vertices to the graph K_2 which looks like *----*  if and only if n is even.
23:56:22 <EvanR> uh K_2? *----* ?
23:56:28 <Cale> yeah
23:56:35 <Cale> The complete graph on two vertices
23:56:55 <Cale> Actually, saying that there is a homomorphism X -> K_n is the same as saying that X is n-colourable
23:58:40 <pharaun> hm i'm getting segmentation fault when i run 'stack repl' even with --no-load
23:58:43 <Cale> You can imagine trying to fold up a physical cycle where there were joints at the vertices, and the edges are rigid and the same length, trying to get it to look like *----* by having it double back on itself a bunch
23:58:47 <pharaun> any idea where/what i should start my search over
23:59:56 <EvanR> yeah
23:59:56 <Cale> and you'll only succeed if there are an even number of vertices -- if it's odd, you end up with a triangle left over that doesn't fold down (which is to say, you have a homomorphism to K_3 instead)
