00:08:21 * hackagebot amazonka-elasticsearch 1.4.0 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.4.0 (BrendanHay)
00:08:23 * hackagebot amazonka-waf 1.4.0 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.4.0 (BrendanHay)
00:08:24 <liste> Gurkenglas: 1) make it a Cabal package 2) create an account in Hackage 3) check if your package conforms to guidelines 4) use "cabal upload" to upload it to Hackage
00:08:52 <hvr> liste: don't use 'cabal upload' please... :-)
00:09:03 <liste> hvr: what's wrong with it?
00:09:04 <hvr> liste: that one posts the package straight to the index w/o any way to preview the result
00:09:13 <liste> hvr: ah, I see
00:09:36 <liste> hvr: so the right way is to use Hackage web UI ?
00:09:37 <hvr> (but there's somewhere a ticket about teaching cabal upload to upload as a candidate)
00:10:00 <jle`> i thought the issue was that it transmitted passwords and package contents in plaintext
00:10:02 <hvr> liste: either that, or use https://github.com/hvr/hackage-cli until 'cabal upload' learns to
00:10:30 <hvr> jle`: that one has been addressed in cabal 1.24 by shelling out to wget/curl/powershell (and hackage-cli uses TLS too by default)
00:10:37 <jle`> nice
00:11:01 <hvr> jle`: and before cabal 1.24, we switched to digest mode iirc
00:11:08 <hvr> to make it less plaintext
00:11:13 <jle`> that's nice
00:11:28 <jle`> should i not be using 1.22 ?
00:11:44 <hvr> cabal 1.24 is not released yet... but soon
00:12:02 <jle`> ah
00:12:06 <hvr> if you don't mind using an unreleased snapshot, just build from the 1.24 Git branch 
00:12:17 <jle`> yeah, or i can just avoid cabal upload for now heh
00:12:49 <jle`> who am i kidding, i'd be flattered if someone thought i was important enough to try to hijack my hackage account
00:13:10 <hvr> :3
00:13:23 <EvanR> if they managed to delete my stuff id be ok with that
00:13:52 * hackagebot amazonka-importexport 1.4.0 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.4.0 (BrendanHay)
00:13:54 * hackagebot amazonka-s3 1.4.0 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.4.0 (BrendanHay)
00:13:56 * hackagebot amazonka-swf 1.4.0 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.4.0 (BrendanHay)
00:13:58 * hackagebot amazonka-sdb 1.4.0 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.4.0 (BrendanHay)
00:14:00 * hackagebot amazonka-codecommit 1.4.0 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.4.0 (BrendanHay)
00:14:08 <jle`> i guess the real issue with secure hackage is things like MitM-ing small underlooked packages and inserting disk-reformatting template haskell into their source code
00:14:17 <jle`> s/underlooked/overlooked
00:14:41 <EvanR> yes no good very bad
00:15:10 <cocreature> we need people mitm packages and uploading docs
00:15:15 <hvr> jle`: that would be addressed by a later phase of hackage security
00:15:24 <hvr> jle`: which would bring aus author signing of packages
00:15:53 <jle`> cocreature: that would be nice
00:16:28 <jle`> can you imagine someone tapping edwardk's connection and inserting disk-reformatting template haskell into a lens update
00:16:34 <jle`> things would be bad
00:16:54 <jle`> although you really shouldn't be running cabal/stack with admin privileges 
00:17:12 <cocreature> I don’t want it to wipe my user directory either
00:17:35 <hvr> jle`: well... you already have to trust all of lens' hackage-maintainers not to be compromised
00:18:34 <jle`> cocreature: hm yeah, wouldn't want it phoning home with the contents of ~/credit-card-numbers-and-bank-passwords.txt too
00:18:50 <cocreature> luckily I don’t have such a file :)
00:19:02 * hackagebot amazonka-codedeploy 1.4.0 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.4.0 (BrendanHay)
00:19:04 * hackagebot amazonka-cloudfront 1.4.0 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.4.0 (BrendanHay)
00:19:06 * hackagebot amazonka-efs 1.4.0 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.4.0 (BrendanHay)
00:19:13 * hackagebot amazonka-gamelift 1.4.0 - Amazon GameLift SDK.  https://hackage.haskell.org/package/amazonka-gamelift-1.4.0 (BrendanHay)
00:19:15 * hackagebot amazonka-elasticbeanstalk 1.4.0 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.4.0 (BrendanHay)
00:19:17 * hackagebot amazonka-apigateway 1.4.0 - Amazon API Gateway SDK.  https://hackage.haskell.org/package/amazonka-apigateway-1.4.0 (BrendanHay)
00:19:17 <hvr> jle`: if there only was a way to encrypt text files containing sensitive information....
00:19:19 <jle`> hackagebot: hm, yeah
00:19:19 * hackagebot amazonka-ses 1.4.0 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.4.0 (BrendanHay)
00:19:21 * hackagebot amazonka-support 1.4.0 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.4.0 (BrendanHay)
00:19:22 <jle`> *hvr
00:19:29 <hvr> yay... it's amazonka time again!
00:19:44 <cocreature> I have a filter in my irc client specifically for amazonka :)
00:20:10 <jle`> i actually filter #haskell on my client to only let through messages about amazonka
00:20:40 <jle`> that way i get to see amazonka pushes and people reacting to them
00:24:23 * hackagebot amazonka-dms 1.4.0 - Amazon Database Migration Service SDK.  https://hackage.haskell.org/package/amazonka-dms-1.4.0 (BrendanHay)
00:24:25 * hackagebot amazonka-dynamodb-streams 1.4.0 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.4.0 (BrendanHay)
00:24:27 * hackagebot amazonka-redshift 1.4.0 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.4.0 (BrendanHay)
00:24:29 * hackagebot amazonka-opsworks 1.4.0 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.4.0 (BrendanHay)
00:25:25 <EvanR> zonked again
00:28:56 * MichaelK waves
00:29:09 * cocreature waves back
00:40:43 * hackagebot amazonka-emr 1.4.0 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.4.0 (BrendanHay)
00:40:45 * hackagebot amazonka-cognito-identity 1.4.0 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.4.0 (BrendanHay)
00:40:47 * hackagebot amazonka-codepipeline 1.4.0 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.4.0 (BrendanHay)
00:40:49 * hackagebot amazonka-ssm 1.4.0 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.4.0 (BrendanHay)
00:40:51 * hackagebot amazonka-ml 1.4.0 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.4.0 (BrendanHay)
00:45:53 * hackagebot amazonka-workspaces 1.4.0 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.4.0 (BrendanHay)
00:45:55 * hackagebot amazonka-inspector 1.4.0 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.4.0 (BrendanHay)
00:45:57 * hackagebot amazonka-rds 1.4.0 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.4.0 (BrendanHay)
00:45:59 * hackagebot amazonka-iot 1.4.0 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.4.0 (BrendanHay)
00:46:01 * hackagebot amazonka-ds 1.4.0 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.4.0 (BrendanHay)
00:51:03 * hackagebot amazonka-cloudwatch-logs 1.4.0 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.4.0 (BrendanHay)
00:51:05 * hackagebot amazonka-route53 1.4.0 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.4.0 (BrendanHay)
00:51:07 * hackagebot amazonka-cloudsearch 1.4.0 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.4.0 (BrendanHay)
00:51:09 * hackagebot amazonka-storagegateway 1.4.0 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.4.0 (BrendanHay)
00:51:11 * hackagebot amazonka-ec2 1.4.0 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.4.0 (BrendanHay)
00:56:13 * hackagebot amazonka-marketplace-analytics 1.4.0 - Amazon Marketplace Commerce Analytics SDK.  https://hackage.haskell.org/package/amazonka-marketplace-analytics-1.4.0 (BrendanHay)
00:56:15 * hackagebot amazonka-elastictranscoder 1.4.0 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.4.0 (BrendanHay)
00:56:17 * hackagebot amazonka-lambda 1.4.0 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.4.0 (BrendanHay)
00:56:19 * hackagebot amazonka-config 1.4.0 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.4.0 (BrendanHay)
00:56:21 * hackagebot amazonka-sns 1.4.0 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.4.0 (BrendanHay)
00:56:22 <dmj> c_wraith: ping
01:01:23 * hackagebot amazonka-ecs 1.4.0 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.4.0 (BrendanHay)
01:06:01 <cbopt> Any idea why one might get this error?
01:06:01 <cbopt> Couldn't match expected type ‘Integer’
01:06:01 <cbopt>                 with actual type ‘t0 Integer -> Integer’
01:06:01 <dmj`> cbopt: can you paste more of your code
01:06:01 <dmj`> @where paste
01:06:01 <lambdabot> Haskell pastebin: http://lpaste.net/
01:06:01 <cbopt> I'm trying this tutorial: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_1
01:06:03 <cbopt> The error comes in "In the expression: Number $ foldl op $ map unpackNum params"
01:06:58 <dmj`> cbopt: We don't know the types for op, unpackNum, and params. Can you paste your code on lpaste.net for us to see
01:07:02 <liste> cbopt: you're missing an inital value for foldl
01:07:18 <liste> cbopt: either supply one or use foldl1 (which is partial btw)
01:07:27 <cbopt> http://lpaste.net/155631
01:08:01 <liste> initial*
01:08:09 <cbopt> liste: What does foldl1 do?
01:08:15 <cbopt> Haven't used that before.
01:08:28 <liste> > foldl1 (+) [1,2,3,4,5]
01:08:30 <lambdabot>  15
01:08:46 <liste> it's a variant of foldl that uses the first value in the list as the initial value
01:09:02 <liste> > foldl1 (+) [] -- but beware of this
01:09:04 <lambdabot>  *Exception: Prelude.foldl1: empty list
01:09:49 <cbopt> Ah! I see. Thanks
01:10:14 <liste> that (along with head, read, etc) are partial, so many people avoid them
01:10:19 <MichaelK> Is there a way to tell whether an expression is a function without TemplateHaskell? I.e. "isFunction 1 = False", "isFunction (+1) = True"?
01:11:38 <cocreature> MichaelK: no
01:11:50 <cocreature> well you might be able to do some typeclass trickery with overlapping instances
01:12:03 <liste> MichaelK: what'd you do with that information?
01:12:49 <kadoban> isFunction :: a -> b \n isFunction _ = True
01:12:54 <MichaelK> liste: something like "until (not . isFunction) ($ Nothing)" 
01:15:02 <liste> MichaelK: what'd be the type of that?
01:16:20 <MichaelK> liste: probably "a -> Bool"
01:16:51 <EvanR> heh
01:17:00 <EvanR> :t const True
01:17:02 <lambdabot> b -> Bool
01:17:07 <EvanR> good enough
01:17:31 <liste> MichaelK: I mean your whole expression
01:20:45 * hackagebot language-vhdl 0.1.2.8 - VHDL AST and pretty printer in Haskell.  https://hackage.haskell.org/package/language-vhdl-0.1.2.8 (mararon)
01:21:04 <MichaelK> liste: oh. I'm not sure. Is there a way to express the final return type? (as opposed to the first return type, i.e. ((->) r) )
01:22:39 <liste> MichaelK: there's the printf trick
01:22:43 <liste> @hackage printf
01:22:43 <lambdabot> http://hackage.haskell.org/package/printf
01:23:16 <MichaelK> (not found?)
01:23:17 <liste> http://stackoverflow.com/a/7828634/1283954
01:23:38 <liste> MichaelK: oh, it's this one https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html
01:23:44 <liste> didn't remember it was in base
01:26:36 <MichaelK> liste: Would defining an instance of "Num (a -> t)" be similar, so that you could tell when you had applied a Num to a Num? (removing the error for "print(0 0)")
01:28:57 <EvanR> MichaelK: sooooooooooo determining if "an expression" is a function or not at runtime
01:29:04 <liste> MichaelK: what do you mean by "could tell" ?
01:29:31 <EvanR> you might want to rethink this, for example you can attach the necessary runtime information to your data type to indicate if its a function or not
01:29:41 <EvanR> the user will have to do this in order to get the program to compile
01:30:19 <EvanR> data FunctionOrNot a b c = Yep (a -> b) | Nope c
01:30:36 <EvanR> hmm. c might be a function
01:30:47 <EvanR> we dont have type system support for "not a certain type"
01:30:49 <MichaelK> EvanR: and what about n-ary?
01:30:59 <EvanR> if b is a function, its n-ary
01:31:24 <EvanR> or do you also want to detect the number of arguments for some reason
01:31:43 <MichaelK> liste: maybe return (-1) for composition of Num's? I'm not exactly sure because I can't think of a specific use case for that
01:31:50 <EvanR> > typeOf ord
01:31:52 <lambdabot>  Char -> Int
01:32:15 <EvanR> for any Typeable, you can inspect the TypeRep, which indicates functionality
01:32:58 <EvanR> theres also probably generics shenanigans you can pull
01:33:03 <MichaelK> EvanR: I don't really need number of arguments. 
01:34:26 <EvanR> class IsFunction a where isFunction :: a -> Bool
01:34:44 <EvanR> instance IsFunction (a -> b) where isFunction _ = True
01:35:03 <MichaelK> EvanR: and then continue with more instances as needed?
01:35:05 <EvanR> isFunction (proxy :: whateverMyExprsTypeIs)
01:35:19 <EvanR> :: defeatingThePurposeEntirely
01:35:37 <EvanR> more like what are you really trying to do and when?
01:37:19 <MichaelK> EvanR: I am trying to make a function `compile :: a -> a` that returns the original function/expression if nothing has been applied or a recompiled version, with the arguments applied so far as compile-time constants
01:38:35 <EvanR> compile :: a -> a cant do anything at runtime except return the argument
01:38:40 <EvanR> or crash
01:38:57 <cocreature> or loop forever
01:39:02 <EvanR> right
01:39:09 <cocreature> yeah bottom \o/
01:39:49 <EvanR> which is kind of included in "cant do anything"
01:40:46 * hackagebot zip 0.1.1 - Operations on zip archives  https://hackage.haskell.org/package/zip-0.1.1 (mrkkrp)
01:40:54 <EvanR> so it sounds like what you want is template haskell
01:44:31 <MichaelK> EvanR: I don't get why "compile :: a -> a cant do anything at runtime except return the argument". What about "f (x, f) = (f x, f) :: (a, a -> a) -> (a, a -> a)" (if only based on the type)?
01:44:58 <quchen> That doesn't have type `a -> a`.
01:45:14 <quchen> It *unifies* with `a->a`.
01:45:49 <liste> :t f (x, f) = (fx, f)
01:45:50 <lambdabot> parse error on input ‘=’
01:45:57 <quchen> When we say something has type `a -> a` it means that it works for all possible choices of a. Your example only works if we choose `a --->  (a, a -> a)`.
01:45:57 <liste> :t let f (x, f) = (fx, f) in f
01:45:58 <lambdabot>     Not in scope: ‘fx’
01:45:58 <lambdabot>     Perhaps you meant one of these:
01:45:58 <lambdabot>       ‘f’ (line 1), ‘x’ (line 1), ‘f’ (imported from Debug.SimpleReflect)
01:46:12 <liste> I give up
01:46:31 <quchen> :t let f (x, f) = (f x, f) in f
01:46:32 <lambdabot> (t, t -> t1) -> (t1, t -> t1)
01:47:02 <liste> remember that "a -> a" is really "forall a. a -> a" in disguise
01:47:02 <quchen> Private Lambdabot window for testing, hooray. :-)
01:47:45 <liste> MichaelK: maybe you're lookin for "`a -> a' for some `a'" instead of "`a -> a' for all `a'" ?
01:49:30 <MichaelK> quchen: hmm. lets suppose an "eval :: String -> IO a" and thus "unsafeEval :: String -> a" and "getSource :: a -> String". Then wouldn't "unsafeEval . getSource :: a -> a" with (presumably) unsafe stuff in the middle?
01:51:33 <quchen> Sure, you can break the type system, and then have your functions do whatever they want.
01:51:44 <quchen> But that's not what we consider good (or even acceptable) code.
01:51:59 <quchen> Those unsafe functions have a *very* limited range of valid applications.
01:53:02 <quchen> Debug.Trace is a very simple use case of using such hacks to enable "printf debugging" in Haskell.
01:53:10 * MichaelK nods
01:53:45 <merijn> Also, I'd like to point out
01:53:49 <merijn> @quote not.a.bug
01:53:49 <lambdabot> SPJ says: [This is] clearly not a bug in GHC; but it would be more felicitous if it gave you a warning...
01:53:53 <merijn> eh, wrong quote
01:54:07 <merijn> @quote Lemmih not.a.bug
01:54:07 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
01:54:47 <MichaelK> merijn: heh.
01:55:54 <MichaelK> what about things like calling safe, but not checkable by GHC, foreign functions? i.e. "cos" in "math.h"
01:56:28 <merijn> MichaelK: unsafe doesn't mean "will crash" it means "I solemnly swear that I know what I'm doing, and while you might not understand, this is safe"
01:57:03 <tdammers> I like to think of 'unsafe' as the compiler telling you that you're on your own
01:57:12 <merijn> MichaelK: Also, if cos uses errno, then it's actually not safe. But yes, in theory calling side-effects free C functions is fine
01:57:29 <merijn> MichaelK: Unsafe basically means "the compiler can't help you here, may god have mercy on your soul" ;)
01:57:35 <quchen> I like Idris' `believe_me :: a -> b`.
01:57:47 <quchen> s/::/:/
01:58:06 <merijn> MichaelK: When using "unsafePerformIO" you should be fine with any and all of the following results: 1) code is never run, 2) code is run once, 3) code is run any number of times
01:58:24 <merijn> MichaelK: If any of those options is undesirable, then you probably shouldn't be doing what you are :p
01:58:48 <merijn> Besides, unsafePerformIO is postively innocent when compared with atrocities like unsafeCoerce
01:58:55 <quchen> unsafePerformIO isn't even safe to launch the missiles if you want to destroy things, because it might never run :-(
01:59:15 <merijn> Worst unsafePerformIO will do is get weird executions orders/repeated effects
01:59:24 <merijn> unsafeCoerce is "please segfault my program"
01:59:59 <merijn> MichaelK: Incidentally "calling safe, but not checkable by GHC, foreign functions" is the entire reason why unsafePerformIO was added as part of the FFI ;)
02:00:04 <quchen> unsafePerformIO does weird things, unsafeCoerce does evil things ;-)
02:00:06 <tdammers> also, 4) code is run multiple times, in parallel
02:00:31 <tdammers> and 5) code is run in unpredictable order
02:00:32 <quchen> merijn: Really? The entire reason?
02:00:46 <MichaelK> tdammers: if you don't mind, how does that work when calling a function from a function pointer?
02:01:10 <merijn> quchen: Haskell98 includes it as part of the FFI addendum, unsafePerformIO isn't part of the original standard and only part of 2010 because the 98 FFI addendum includes it
02:01:22 <merijn> quchen: Clearly it might have existed before then, but not as part of the standard
02:01:26 <quchen> Huh, I didn't know unsafePerformIO is standard
02:01:30 <quchen> was*
02:01:51 <merijn> It has to be to make a pure FFI work :)
02:01:58 <quchen> I can't find it in the Report
02:02:08 <merijn> MichaelK: Dangerously ;)
02:02:40 <quchen> In case of functions pointers, you better make sure those always point to things that are pure. Same thing as with ordinary values.
02:02:45 <merijn> quchen: It's in the FFI part. I remember looking it up after last time I argued "unsafePerformIO isn't haskell" and someone said the addition of the FFI addendum added it
02:02:49 <MichaelK> merijn: I mean for parallel execution
02:03:09 <merijn> MichaelK: Multiple threads can call function pointers independently just fine?
02:03:49 <quchen> merijn: `unsafeLocalState :: IO a -> a` is in there
02:04:01 <MichaelK> merijn: oh, ok. I wasn't sure whether a safe function called by pointer by different threads would overlap in execution
02:04:28 <merijn> MichaelK: If it's *actually* pure, then no problem
02:04:35 <quchen> Interesting! I never read the foreign part of the Report.
02:05:50 <MichaelK> merijn: So like a ffi c function "int doubleIt(int x){return x*2}"?
02:07:14 <merijn> MichaelK: Yeah, that only uses it's own stack space. But, say, "int doubleIt(int x) { static int result = x*2; return result; }" is trouble
02:08:10 <MichaelK> merijn: Ah, ok
02:11:48 <merijn> MichaelK: Basically, as long as the C function doesn't mutate any shared state it's fine. If it does, you better be sure about what you're doing marking things pure :)
02:12:47 <MichaelK> merijn: makes sense
02:16:08 <cbopt> Hey! Is there a package available in haskell for syntax parsing and getting grammars from natural languages?
02:16:23 <cbopt> I'm looking for something like https://github.com/clulab/processors
02:17:20 <cbopt> The idea is to extract grammar and lexicons from natural language (English, in this case).
02:20:40 <aleator> Hi. I'm trying to grok recursion-schemes. If I'm trying to query an ast, can I do it easily with any of the schemes?
02:22:39 <merijn> tbh, I've found it hard to do *anything* easily with recursion schemes :p
02:24:58 <aleator> merijn: Then s/easily/'with few lines'
02:40:48 * hackagebot generics-sop-lens 0.1.1.0 - Lenses for types in generics-sop  https://hackage.haskell.org/package/generics-sop-lens-0.1.1.0 (phadej)
02:43:26 <quchen> merijn: Factorial! product . enumFromTo 1 is a hylomorphism ;-)
02:44:35 <quchen> I've tried recursion schemes for a complex syntax tree and it's way too messy for the perceived benefits, unfortunately.
02:44:47 <quchen> Complex as in many mutually recursive data structures
03:05:50 * hackagebot union 0.1.0.0 - Extensible type-safe unions  https://hackage.haskell.org/package/union-0.1.0.0 (int_index)
04:42:58 <brian_> I have a question about trampolining. When I define a recursive function, let's say factorial, that calls itself like (n * fact(n-1)), and I write a helper function to make  it tail call, like go(acc, n) so that fact(n) calls go(1,n), is that trampolining?
04:43:53 <quchen> No, that is ordinary recursion, sometimes referred to as the worker/wrapper transformation.
04:44:23 <hpc> trampolining isn't really a concept in ghc haskell
04:44:26 <brian_> The worker/wrapper transformation is the step where I make the recursion stop eating up stack frames?
04:44:54 <merijn> brian_: Haskell (or rather, the way GHC compiles it) doesn't have call stacks
04:45:09 <merijn> brian_: So function calls don't eat stack frames
04:45:31 <Akii> LYAH says you can have a stack overflow, tried to reproduce - didn't work
04:45:38 <brian_> I thought that this was unnecessary with Haskell. Can someone point me to why that is?
04:45:47 <merijn> This is also why the question "is this function tail recursive?" is rather nonsensical in Haskell. Depending on your point of view either ALL or NONE of the functions in haskell are tail recursive
04:46:05 <merijn> Akii: I didn't say haskell didn't have a stack, it just doesn't have a CALL stack :)
04:46:18 <Akii> hmm it still didn't overflow
04:46:19 <Akii> :D
04:46:25 <quchen> GHC has a pattern match stack. Handwavy, each "case" does something stacky.
04:46:42 <merijn> Akii: Specifically, haskell has a pattern match stack, which you can still overflow (well, actually, I don't think you can anymore, I think it's dynamic now)
04:46:57 <Akii> cool stuff :o
04:47:03 <merijn> brian_: All haskell function calls compile to jumps in assembly
04:47:31 <merijn> brian_: i.e. haskell isn't compiled using the standard "call" style instructions. Which means there's never a need to return to pop stack frames
04:48:03 <brian_> Great, that's really helpful.
04:48:06 <merijn> Actually, I say "Haskell", but I mean GHC. Haskell doesn't have a specified way to implement things :)
04:49:00 <brian_> Is it a weakness of the JVM that prevents Scala or Clojure from managing such a feat?
04:49:08 <merijn> brian_: If you have (basic) assembly and/or C knowledge, there's an excellent paper on how to compile haskell to asm that is very readable (it's a bit outdated, in terms of tricks and details, but the overall picture still holds)
04:49:26 <Akii> link? :D
04:49:30 <Akii> I love papers
04:49:31 <merijn> brian_: The JVM is a stack based VM, which means that it actually uses the stack for everything
04:49:31 <brian_> Yes, please.
04:49:44 <quchen> Well, there's thef irst paper, and then there's the fast curry one which is a nice follow-up
04:49:45 <merijn> Akii, brian_: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
04:49:50 <Akii> nice thanks!
04:50:28 <merijn> And yeah, the "How to make a Fast Curry" is a good followup paper
04:50:44 <quchen> merijn: Isn't there a jump back to the 'case' once the scrutinee is evaluated?
04:51:08 <merijn> quchen: No, because you just jump to the continuation
04:51:26 <quchen> Where is that continuation stored?
04:51:27 <hpc> brian_: more specifically, the JVM has no concept of a tail call and java doesn't attempt any optimization itself
04:51:35 <Akii> that one? http://community.haskell.org/~simonmar/papers/evalapplyjfp06.pdf
04:51:35 <merijn> quchen: The stack, else you wouldn't need it ;)
04:51:37 <hpc> (and such optimization would be difficult anyway due to the object model)
04:51:47 <merijn> Akii: Based on the PDF name, yes
04:52:00 <hpc> scala iirc handles recursive functions well
04:52:01 <quchen> merijn: Ah, I see, so you just have to pop the stack to jump on, as opposed to C, where you have to pop the stack to jump back, and then jump (or move) on
04:52:13 <brian_> So is the worker/wrapper transformation useless in Haskell, then?
04:52:39 <merijn> brian_: There's still uses in terms of inlinability, fusion and other optimisations :)
04:53:21 <hpc> worker/wrapper has expressive power beyond "oops i ran out of memory"
04:54:00 <hpc> so it remains useful sort of
04:54:03 <merijn> And actually a "tail call" version can be useful because it allows you to add strictness to avoid space leaks
04:54:18 <hpc> sometimes there's better ways to write something, sometimes worker/wrapper is that better way
04:55:04 <hpc> here's an example where the worker/wrapper style can get rather involved: http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.OldList.html#sortBy
04:56:08 <hpc> (i don't want to call it a "pattern" because it's not just one mechanical transformation of code)
04:58:36 <tdammers> hpc: I'd argue that "pattern" in this sense is a different meaning of the word than "pattern" in "pattern matching"
04:58:41 <tdammers> or "pattern substitution"
04:59:02 <hpc> tdammers: as in design pattern
04:59:25 <hpc> which in java is a mindless lump of code with some // INSERT YOUR STUFF HERE thrown in
05:00:42 <tdammers> hpc: I don't think that's what it's meant to be in Java either
05:00:49 <merijn> "My language isn't good enough to DRY up this repetition"
05:01:09 <tdammers> hpc: the Gang Of Four book, IIRC, explicitly states that the examples are intended as that, examples, and not as copy-paste templates
05:01:33 <hpc> tdammers: sadly their "examples" are useful, and there's no abstraction that reduces the copy-paste required
05:01:47 <hpc> leaving java moist with repetition
05:01:51 <tdammers> hpc: yes, but that's a Java-specific orthogonal concern
05:02:19 <hpc> in fact i would argue that being repetitive is necessary to it being a pattern
05:02:26 <tdammers> I've always maintained that the use of a "code snippets" feature in a programming editor or IDE is a symptom of a suboptimal language, or suboptimal use of it
05:02:30 <hpc> see also: the actual definition of pattern
05:02:35 <tdammers> well, maybe
05:02:48 <tdammers> maybe it would have been better to call them "problem solving approaches"
05:02:54 <hpc> there's a reason we say "applicative style" and not "applicative pattern"
05:03:21 <tdammers> yes, because the applicative pattern is encoded in the Applicative typeclass
05:03:38 <tdammers> a type that follows the applicative pattern can be (and usually is) made an instance of Applicative
05:03:52 <tdammers> I guess that's the kind of abstraction that Java lacks
05:04:15 <hpc> indeed
05:04:57 <hpc> if haskell lacked type classes, you'd be seeing the applicative pattern in the form of maybePure = Just; maybeApp = ...
05:05:16 <hpc> or maybe you'd see data Applicative f = ...
05:06:04 <hpc> anyway, that's all pure opinion
05:07:38 <tdammers> yeah, if you look at Elm, you see that that's pretty much exactly how it's done there
05:08:00 <tdammers> the List module exports List.map, the Vector module has Vector.map, etc.
05:08:38 <hpc> actually, a good example of patterns in haskell is template haskell
05:08:49 <hpc> which "abstracts" over things that have to be syntactically repeated
05:09:07 <tdammers> well, yes, but even TH is a better abstraction than writing out the patterns every time
05:09:15 <hpc> yeah
05:09:37 <hpc> just if you ever wonder "does haskell have patterns?", look at what TH gets used for
05:09:42 <hpc> and those are the shortcomings of the base language
05:11:47 <tdammers> agree
05:15:05 <merijn> Not entirely, Template Haskell covers two distinct use cases, only one of which is a shortcoming in the language
05:15:22 <ph88_> what was that yahoo haskell website ?
05:15:24 <merijn> i.e. repeated/duplicated code, the other usecase is compiletime reasoning
05:15:25 <ph88_> to search in packages
05:15:28 <merijn> hayoo?
05:15:29 <puregreen> @where hayoo
05:15:29 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
05:15:37 <ph88_> thx
05:15:47 <hpc> duckduckgo has !hayoo
05:15:59 <ph88_> that website is pretty slow by the way
05:16:07 <bernalex> and !hackage and !hoogle. I put them there. :p
05:16:08 <hpc> the price of completeness
05:16:18 <Akii> I installed hoogle locally today, any way of also getting the documentation locally?
05:16:26 <hpc> the hoogle site only uses base iirc
05:16:35 <hpc> (and the package listing)
05:16:39 <ph88_> http://hayoo.fh-wedel.de/ is down ?
05:16:48 <merijn> Akii: If you edit your cabal.config it will automatically install docs locally, even without Hoogle
05:17:04 <merijn> Akii: Edit cabal.config and change the "Documentation:" line to True
05:17:17 <merijn> I forget the linux location of it, though. ~/.cabal/ maybe?
05:17:26 <Akii> I don't even have cabal installed, using stack on os x
05:17:37 <merijn> You do have cabal
05:17:45 <merijn> stack just uses cabal, so else it wouldn't work
05:18:01 <puregreen> tdammers: I disagree about snippets – it's possible that some snippet is the clearest way to express some thought (when you're optimising for readability), and yet it's too long to be typed. Same with stuff like autocompletion of identifiers – “createDirectory” is better than “crdir” when you're reading the code, but “crdir” is better than “createDirectory” when you're writing it
05:18:41 <Akii> merijn: doesn't look like it though, at least I can't "access" it
05:19:02 <merijn> Akii: oh, OSX, yeah, then it's elsewhere, lemme check
05:19:14 <tdammers> puregreen: well, yeah, it's not black-and-white; nothing wrong with automating stuff like adding imports or language pragmas
05:19:39 <merijn> ~/.cabal/config for me
05:19:54 <merijn> Akii: But it might also be somewhere under ~/Library/Haskell
05:20:46 <ph88_> how can i do a lookahead for more than one character?  https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Text.html#g:8
05:21:15 <merijn> ph88_: Why do you need to lookahead more than one character?
05:22:11 <ph88_> because if i reach "->" i must end the current thing i'm looking for .. but when it's just "-" without ">" behind it then it's still part of the current
05:22:29 <merijn> ph88_: Then just try to parse "->" and fall back to "-" if that fails?
05:22:39 <joco42> is there a way to create a where clause which can be accessed from all pattern match cases ?
05:22:40 <ph88_> i'm trying to parse this string "WS  : [ \t\r\n]+ -> skip ;"
05:23:03 <ph88_> of course with extra \ for haskell so \\t\\r\\n
05:23:13 <merijn> joco42: No, but you could move all the patterns into a case-of inside a single pattern?
05:23:30 <Akii> I've to dig into this later, thanks for the info though merijn :D
05:23:55 <ph88_> merijn, for " [ \t\r\n]+ " this part i use  satisfy isPrint   .. so it consume -> too .. that's why i need a lookahead
05:25:14 <joco42> merijn:  thanks, i think i understand your point
05:25:44 <merijn> joco42: Alternatively, use pattern guards, as where clauses scope across multiple guards
05:27:25 <joco42> merijn:  thanks, i look into that
05:28:28 <lonokhov> is there a package with TH descructor generator?
05:28:40 <merijn> lonokhov: What do you mean?
05:31:35 <lonokhov> merijn: for data Foo = FooA Int | FooB String | FooC Int Float generate (Int -> a) -> (String -> a) -> (Int -> Float -> a) -> Foo -> a
05:31:38 <lonokhov> like maybe or either
05:32:08 <merijn> lonokhov: Oh, you want like the Scott/Churhc encoding of an ADT?
05:32:19 <merijn> *Church
05:32:28 <lonokhov> merijn: idk, maybe and either are called destructors or something
05:32:36 <merijn> Try using those two as the magical keywords when searching
05:32:52 <black0range> Is it possible to create a custom handle? 
05:33:18 <merijn> lonokhov: Tekmo uses Scott encoding in Morte to model datatypes, so he might have some stuff on that in his Morte blog posts too
05:33:27 <merijn> black0range: What do you mean by custom handle?
05:35:11 <lonokhov> merijn: thanks
05:35:20 <bartavelle> lonokhov, this is also called, as merijn said, church/scott encoding, or even just "fold"
05:35:25 <bartavelle> I suppose this is related : https://hackage.haskell.org/package/regular-0.3.4.4/docs/Generics-Regular-Functions-Fold.html
05:36:22 <black0range> merijn: Creating a web server and i would like to create handle for the socket to hand over to the web application
05:36:41 <bartavelle> lonokhov, or I suppose this: https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:gfoldl
05:37:02 <black0range> but this 'handle' has to do some custom stuff such as send an eof after a specific limit of bytes or read chunked data
05:37:07 <bartavelle> (not sure about the last one)
05:37:22 <lonokhov> bartavelle: I'll check it out, thank you
05:38:16 <Xandaros> I'm using servant to provide a REST-API. What would be the 'best' way of keeping some state in memory between requests?
05:38:53 <lonokhov> Xandaros: IORef?
05:39:53 <Xandaros> Yeah... I thought about IORefs, but I try to avoid those. Also, can't requests come in simultaneously? That could cause a race condition, couldn't it?
05:41:12 <lonokhov> Xandaros: if you use atomic* functions then it should be ok.
05:43:32 <Xandaros> lonokhov: Hmm, I guess that works. Thanks. I have an inexplicable dislike towards IORefs, but I guess that's just me
05:44:36 <lonokhov> Xandaros: we all dislike shared mutable state in here ;)
05:45:10 <lonokhov> Xandaros: https://www.reddit.com/r/haskell/comments/39ef3y/ioref_vs_mvar_vs_tvar_vs_tmvar/ this can be interesting to you
05:45:11 <black0range> Sometimes state is necessary to deal with the real world :)
05:49:14 <Xandaros> I might just use a global MVar. Then, I can take and put instead of having to modify. complex modify operations always ends looking messy in my code
05:58:55 <ggVGc> does this seem reasonable for a haskell API? https://hackage.haskell.org/package/websockets-0.9.6.1/docs/src/Network-WebSockets-Connection.html#receiveDataMessage
05:59:09 <ggVGc> throwing exceptions on normal program behaviour such as connections closing seems a bit crap
06:00:00 <merijn> ggVGc: I'd say that the default should be an "Either" return and exception version should be optional
06:00:09 <ggVGc> right
06:00:32 <ggVGc> merijn: but it's not even exceptional
06:00:41 <ggVGc> it's expected that at some point the connection will close
06:00:47 <ggVGc> looks like terrible API design to me
06:00:55 <merijn> I tend to write network loops using "forever" + exception to break out
06:02:11 <ironChicken> when `cabal install` inside a sandbox warns me "The following packages are likely to be broken by the reinstalls:" and lists some system-wide installed pacakges that are nothing to do with the code in my sandbox, can i just --force-reinstalls?
06:02:18 <ironChicken> and will my global packages still work?
06:02:27 <merijn> "Maybe"
06:02:32 <merijn> If you're lucky
06:02:35 <ggVGc> haha... cabal
06:02:37 <ggVGc> you dog
06:02:52 <ironChicken> yeah, but stack isn't working for me here either :-/
06:03:23 <ironChicken> the global package that i particularly care about is xmonad as installed from debian
06:03:48 <ironChicken> that is, it's not a dependency of my sandbox, but i do use it as my window manager
06:07:57 <Xandaros> If you're using a sandbox, it shouldn't complain about global packages
06:09:42 <ironChicken> Xandaros: i am.
06:12:11 <ironChicken> grr. well that didn't help. now it says "cannot satisfy -package-id optparse-applicative-0.12.1.0-17db19a120db464a231f3a67aeca2c77"
06:12:17 <ironChicken> fine, i'm trying stack again
06:14:08 <Xandaros> ironChicken: the only thing I can think of is that cabal doesn't recognise your sandbox for some reason. Make sure it is properly initialized and you're in its root directory
06:16:18 <hexagoxel> nah, cabal has some bug where it thinks it would break stuff where it will not.
06:16:38 <hexagoxel> i am mildly certain that --force-reinstalls is safe in that case.
06:17:38 <hexagoxel> "safe" in that it wont break anything other than potentially the sandbox.
06:18:14 <hexagoxel> (it is in the tracker somewhere)
06:18:41 <ironChicken> hexagoxel: my hunch was in line with yours
06:19:15 <ironChicken> i'm not sure whether my global packages are now broken, but i can still `xmonad --recompile` which feels quite promising
06:20:26 <hexagoxel> ironChicken: `ghc-pkg check` would report if anything was broken.
06:20:57 <hexagoxel> (it won't see the sandbox unless you `cabal exec ~`
06:20:59 <hexagoxel> )
06:21:30 <hexagoxel> (rather `cabal exec -- ~`)
06:21:53 <kmelva> getting my feet wet with Gtk3 - any ideas how to do something on button click? in Gtk2 there was `onClicked` function, but it's no longer present in Gtk3
06:22:09 <ironChicken> hexagoxel: ty. it seems lots of packages *are* broken, but none that i care about, and none that cabal just warned me it was going to break :-)
06:22:24 <hexagoxel> ironChicken: eh :)
06:23:22 <ironChicken> so when i try and run the test-suite with stack i get a "Bad interface file:" error from ghc
06:25:31 <puregreen> kmelva: button `on` buttonActivated
06:28:15 <ironChicken> but it has actually successfully built the testsStub in .stack-work/dist/x86_64-linux/Cabal-1.22.5.0/build/foo-testsStub/foo-testsStub
06:28:23 <ironChicken> and it executes correctly too
06:29:14 <kmelva> puregreen: thanks! was searching under Gtk, instead of Glib! Gtk3 doesn't have that much documentation :(
06:29:48 <puregreen> nope, it's in gtk3
06:30:05 <puregreen> http://hackage.haskell.org/package/gtk3-0.14.2/docs/Graphics-UI-Gtk-Buttons-Button.html#v:buttonActivated
06:30:38 <kmelva> puregreen: yeah, `buttonActivated` is, but `on` is in Glib :)
06:30:41 <puregreen> ah
06:30:58 <lonokhov> is there dumb applicative trie-based [Text] parser? like router, but dumb and without bindings to any web framework?
06:33:27 <hexagoxel> to be fair, the gtk3 hello world example does contain `on button buttonActivated (putStrLn "Hello World")` :p
06:38:23 <kmelva> hexagoxel: link to that example?
06:39:12 <tippenein> I need something like this but for haskell: http://www.lispcast.com/convince-your-boss-to-use-clojure
06:39:39 <hexagoxel> kmelva: World.hs in https://hackage.haskell.org/package/gtk3-0.14.2/src/
06:40:07 <puregreen> kmelva: https://github.com/gtk2hs/gtk2hs/blob/master/gtk/demo/hello/World.hs
06:40:24 <puregreen> a more direct link
06:40:34 <hexagoxel> right, that is better, thanks.
06:41:54 <kmelva> puregreen: ah, bummer... didn't remember to browse gtk2hs source :/ thanks, lots of material in demo dir
06:43:16 <hexagoxel> ah, gtk3 package has broken home page link.. pssh.
06:45:37 <hexagoxel> kmelva: what i do half the time for largish dependencies is just `cabal get` them, and look at examples locally.
06:52:02 * hackagebot clash-lib 0.6.14 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.14 (ChristiaanBaaij)
06:52:04 * hackagebot clash-ghc 0.6.16 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.16 (ChristiaanBaaij)
07:00:49 <ij> Can xml-conduit parse incomplete xmls?
07:03:55 <xnyhps> If you have a prefix, then you can use Text.XML.Stream.Parse.
07:12:14 <ij> What prefix?
07:12:37 <puregreen> ij: a prefix of a complete XML, I guess
07:13:08 <puregreen> i.e. you're missing the end but not the beginning or random pieces from the middle
07:13:59 <ph88_> how can i do a lookahead for more than one character?  https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Text.html#g:8
07:16:54 <buaa> can you see me
07:17:15 <buaa> why i can't see any words?
07:18:14 <hpc> are they Word64s or Word32s?
07:19:02 <ph88_> buaa i see you !
07:19:18 <buaa> oh, thanks
07:19:41 <buaa> i am just learning irc
07:19:59 <hpc> nobody had spoken yet since you joined, so there was no scrollback for you to read
07:20:20 <hpc> this is the quietest 1600 user channel ever
07:20:33 <buaa> got it !
07:22:42 <puregreen> ph88_: it seems that you can't
07:23:02 <puregreen> ph88_: http://stackoverflow.com/questions/20894973/is-it-possible-to-efficiently-look-ahead-more-than-one-char-in-attoparsec
07:25:11 <ph88_> uf
07:26:57 <cbopt> Hey! Have any of you tried the latest version of processors library for NLP? I keep getting OutOfMemoryError on default everything.
07:39:27 <Athas> Does anyone know what the future plans are for Data-Parallel Haskell?
07:42:00 <kriztw> Athas: there was a reddit thread recently: https://www.reddit.com/r/haskell/comments/4b5xo4/about_the_status_of_data_parallel_haskell/
07:43:23 <Athas> kriztw: thanks.
07:47:06 <ph88_> puregreen still here ?
07:47:12 <puregreen> yep
07:47:59 <ins_> easiest way to take a string like '0xdeadbeef' and turn it into a bytestring representation?
07:48:26 <ph88_> puregreen, that SO post suggested doing a pattern match on the result. I saw a different approach using "try" http://stackoverflow.com/a/26796909 i'm not sure if that would work in attoparsec (my first question) and my second question is which would be preferable, the pattern match or the try ?
07:48:55 <puregreen> ‘try’ doesn't do anything in Attoparsec
07:49:17 <scshunt> ins_: you mean to turn it into a series of bytes, like [0xde, 0xae, 0xbe, 0xef]?
07:49:22 <merijn> try is for parsec compatibility all attoparsec parsers backtrack
07:49:22 <liste> ins_: you mean hex -> bytestring conversion?
07:49:24 <puregreen> so if something works with ‘try’ in Parsec, it should work even without ‘try’ in Attoparsec
07:49:30 <puregreen> ...I think
07:49:35 <merijn> puregreen: Correct
07:49:58 <ins_> scshunt: exactly
07:50:11 <merijn> :t Data.ByteString.pack
07:50:13 <puregreen> bu-ut I'm kinda busy now so can't help you, sorry
07:50:13 <lambdabot> [Word8] -> BSC.ByteString
07:50:37 <merijn> > Data.ByteString.pack [0xde, 0xae, 0xbe, 0xef]
07:50:39 <lambdabot>  Not in scope: ‘Data.ByteString.pack’
07:50:45 <merijn> Anyway, you get the idea
07:51:22 <ph88_> puregreen, actually i found another lookahead, there is this one https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Text.html#g:8 which i pointed to before and there is also this one http://hackage.haskell.org/package/attoparsec-0.13.0.0/docs/Data-Attoparsec-Combinator.html#v:lookAhead this guy http://stackoverflow.com/a/13204259 says you can use that lookahead function to give it an entire string "(string ">")"  
07:51:22 <ph88_> so maybe the string can be longer than 1 character? what you think puregreen ?
07:51:27 <merijn> Alternatively, use binary/cereal to serialise a Word32 to ByteString
07:51:54 <merijn> > 0xdeadbeef :: Word32
07:51:56 <lambdabot>  3735928559
07:52:00 <puregreen> hm, interesting
07:52:24 <puregreen> okay, you can use the latter ‘lookAhead’, yep
07:52:34 <ph88_> thanks puregreen !
07:52:56 <ph88_> i'm going to use it to find "->"  in this string   "WS  : [ \t\r\n]+ -> skip ;"
07:53:25 <ins_> Practically, it'll always fit into a Word32, but I can't assume that for the interface I don't think
07:53:37 <ph88_> because for " [ \t\r\n]+ " i use "satisfy isPrint"  and that is so greedy it will try to eat "->" too .. so that's why i would like to use the lookahead to see if there is still a "->" coming
07:53:41 <ins_> I suppose I'll parse it myself
07:54:49 <ins_> I just supposed there might be some simple way to do it
07:55:00 <ins_> the read instance for ByteString seems a bit silly to me
07:55:09 <ph88_> puregreen, should i write it like this    satisfy $ isPrint && not lookAhead (string "->")    ?
07:55:16 <puregreen> busy
07:55:22 <ph88_> ok no problem, i wait
07:55:27 <liste> :t readHex -- ins_, this may help
07:55:29 <lambdabot> (Eq a, Num a) => ReadS a
07:56:26 <ins_> It would if ByteString was instance of Num. What I'm doing currently is using Integer's read instance, and then converting from Integer to ByteString
07:56:44 <liste> > map readHex ["de", "ad", "be", "ef"]
07:56:45 <lambdabot>  [[(222,"")],[(173,"")],[(190,"")],[(239,"")]]
07:57:37 <ins_> > (read '0xdeadbeef' :: Integer)
07:57:38 <lambdabot>  <hint>:1:8: parse error on input ‘0xdeadbeef’
07:57:53 <ins_> hmm
07:57:57 <liste> > (read "0xdeadbeef" :: Integer)
07:57:59 <lambdabot>  3735928559
07:58:10 <Sornaensis> single quotes do not a string make
07:58:22 <ins_> ah, sorry, too used to bash
08:08:53 <Arguggi> Hi, I'm trying to use Turtle.inproc to start alsactl to monitor when the volume changes but the command in ghci isn't showing any Text (Turtle.view $ Turtle.inproc "alsactl" ["monitor"] Turtle.empty ) while `alsactl monitor` in a terminal works fine, what am I missing?
08:10:05 <mauke> I don't know what Turtle is but is that the right calling convention for command line args?
08:10:20 <mauke> also, does 'alsactl monitor | cat' work?
08:11:16 <puregreen> ph88_: I think it's going to be something like “T.pack <$> manyTill (satisfy isPrint) (string "->")”
08:11:21 <puregreen> you don't even need lookAhead
08:11:52 <ClaudiusMaximus> Arguggi: if ...|cat doesn't work that would point to a buffering issue perhaps
08:13:04 <ph88_> puregreen, why don't i need the lookAhead ?
08:13:14 <ph88_> what's T.pack ?
08:13:49 <Arguggi> sorry forgot to link to Turtle: https://hackage.haskell.org/package/turtle-1.2.5/docs/Turtle-Prelude.html#g:3 . I think the command line args are correct since I already used inprop for another command and it worked fine. "... | cat" with Turtle.inshell doesn't seem to work either, I guess I'll have to check if buffering is mentioned somewhere
08:13:56 <merijn> Data.Text.pack, presumably
08:14:15 <puregreen> ph88_: well, you can use lookAhead and then you would have to consume "->" again
08:14:30 <puregreen> maybe that's what you want, I don't know exactly
08:14:40 <ph88_> oh yes i understand .. i would like to understand your solution as well
08:14:51 <ph88_> T.pack <$> manyTill (satisfy isPrint) (string "->")
08:16:28 <puregreen> can you say again what you're trying to parse?
08:17:04 <ph88_> "WS  : [ \t\r\n]+ -> skip ;" into "WS", "[ \t\r\n]+" and "skip"
08:17:05 <geekosaur> Arguggi, yes, that could well be buffering since monitor just keeps running. on linux try: Turtle.inproc "stdbuf" ["--output=0", "alsactl", "monitor"]
08:17:54 <Arguggi> geekosaur, works like a charm :) Thanks !
08:19:24 <puregreen> ph88_: okay, then it's going to be "T.pack <$> manyTill (satisfy isPrint) (skipSpace *> string "->")
08:19:41 <puregreen> it'll parse the whole "[ \t\r\n]+ ->" chunk
08:19:54 <ph88_> ok, but i don't understand what you've written there
08:20:32 <ph88_> how is "satisfy isPrint" not getting greedy anymore and consume "->" in that solution ?
08:21:15 <puregreen> because manyTill tries the "->" parser before applying the “satisfy isPrint” parser
08:21:36 <puregreen> check for ->; consume a character; check for ->; consume a character; check for -> ...
08:22:23 <ph88_> ooh i see it now in the manyTill description .. i thought the magic was coming from T.pack
08:22:30 <ph88_> what did you put that in for ?
08:22:58 <puregreen> manyTill, unlike e.g. takeWhile, doesn't produce a Text – it produces a list of parses
08:23:05 <puregreen> so you're going to get [Char]
08:23:14 <puregreen> and T.pack converts it to Text
08:23:23 <puregreen> if you don't want Text, sure, you don't have to use T.pack
08:24:19 <ph88_> hhmm i think it's better to go back to Text if i was already using that
08:24:44 <ph88_> i see that pack function is not in Text ?? https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Text.html
08:24:45 <ij> Can I stop a fold? 
08:25:35 <ph88_> puregreen, what do i have to import to get the pack function ?  hayoo is down :/
08:25:46 <oherrala> ph88_: Data.Text has pack
08:25:49 <puregreen> import qualified Data.Text as T
08:25:58 <puregreen> (can choose another name, too)
08:26:17 <ph88_> ij, no, but i think you can make it in such a way that "the rest of the fold"  just returns the same stuff as you wanted to return "in the middle of the fold"
08:26:36 <ij> That's surely possible.
08:26:42 <puregreen> (I just like T/V/M/HM/BS)
08:27:05 <puregreen> (not sure whether there's any consensus on them)
08:27:18 <ph88_> i will try this suggestion
08:28:46 <SlimCow> Hey! In computing the combinations of a list http://lpaste.net/155670 I don't get why this works. For input "[1,2] 3" shouldn't it crash?
08:31:45 <SlimCow> 1:(combinations [2] 2) = 1:(2:combinations [] 1) = 1:(2:[]) but here [] is an empty list of lists, so you shouldn't be able to cons 2 to it, right?
08:32:23 <geekosaur> SlimCow, in a list comprehension <- means "for all lists in ..."
08:32:52 <geekosaur> so `ys <- combinations ...` runs the list comprehension on each result list, so [] is just an empty list
08:33:17 <geekosaur> if it had been `let ys = combinations ...` then you would be correct
08:37:27 <SlimCow_> geekosaur: I'm afraid I don't understand
08:39:32 <geekosaur> just as `i <- [0..length xs - 1]` iterates over each number in the list, `ys <- combinations ...` iterates over each element of the list produced by combinations
08:40:27 <geekosaur> and each of those elements is another list
08:42:12 <ij> Shouldn't a "let u = undefined" in ~/.ghci make it accessible in ghci?
08:42:19 <SlimCow_> Ooooh! So you will be getting an empty list each time, because you don't have what to append the element 2 to?
08:42:22 <ij> The prompt works, so I'm usign the right file.
08:43:58 <orion> I need to query a SQL database and generate a nice looking HTML "report" of what I find. What packages would be particularly helpful for generating the report?
08:45:28 <geekosaur> SlimCow_, ??? it's recursively invoking combinations on a sublist and then applying the list comprehension to each element of the result
08:52:09 * hackagebot tinylog 0.13.0 - Simplistic logging using fast-logger.  https://hackage.haskell.org/package/tinylog-0.13.0 (ToralfWittner)
08:54:38 <SlimCow_> geekosaur: got it now, thanks! geekosaur++
09:03:30 <icicled> orion: use blaze/lucid to render a html table w/bootstrap css?
09:04:08 <icicled> if you're using sqlite then just run the query with `sqlite3 -html`
09:08:15 <ins_> I ended up with this poor man's implementation
09:08:52 <ins_> (mapM (readMaybe . ("0x" ++)) $ chunksOf 2 "0xdeadbeef" :: Maybe [Word8]) >>= return . BS.pack
09:09:18 <ins_> for String -> Maybe ByteString
09:19:56 <jle`> `>>= return . f`
09:19:58 <jle`> :(
09:20:05 <jle`> why
09:24:43 <ph88_> anyone know why http://hayoo.fh-wedel.de/ is down ?
09:42:27 <lambda-11235> @pl (\x -> (>>= return . f))
09:42:27 <lambdabot> const (f `fmap`)
09:42:44 <lambda-11235> @pl (\f -> (>>= return . f))
09:42:45 <lambdabot> fmap
09:42:48 <the_2nd> If I want to calculate the average within a list, I'd call sum l / (fromIntegral $ length l)
09:43:23 <the_2nd> but this would iterate the list twice, right? Is there no method doing both at once? Or do I have to write it myself?
09:44:41 <Carisius> man, i should come back haskell again, i miss it so much, i guess it changed a lot in these 8 years
09:51:46 <portnov> hi all
09:52:10 <portnov> Q: is it possible to support sub-sub-modes with cmdargs library?
09:52:27 <portnov> like "cabal sandbox init"
09:53:33 <c_wraith> I haven't used it, but I suspect that if it is, it's just a matter of putting a submode in a submode. 
09:55:35 <sm> portnov: if you try, let us know
09:55:46 <portnov> i tried smth like https://paste.in.ua/1485/ but it didn't exactly work; it created flags --sub1 and --sub2 without arguments
09:57:12 * hackagebot ipython-kernel 0.8.4.0 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.8.4.0 (gibiansky)
09:57:14 * hackagebot ihaskell 0.8.4.0 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.8.4.0 (gibiansky)
09:57:16 * hackagebot ihaskell-widgets 0.2.3.1 - IPython standard widgets for IHaskell.  https://hackage.haskell.org/package/ihaskell-widgets-0.2.3.1 (gibiansky)
10:23:55 <the_2nd> chunkParMap :: http://lpaste.net/155817
10:24:22 <xa0> >let (three x = x 3) :: (forall a. a -> a) -> Int in three id
10:24:53 <xa0> can i do that inline? >_>
10:25:28 <c_wraith> :t ($ 3)
10:25:30 <lambdabot> Num a => (a -> b) -> b
10:25:43 <c_wraith> is that what you're looking for? 
10:26:00 <xa0> well, i was using it as an example of a rank2type
10:26:17 <xa0> so specifically the id part
10:26:17 <c_wraith> ah. those can't be inferred. 
10:26:20 <xa0> ah
10:26:26 <xa0> right
10:26:44 <c_wraith> so you will always need to annotate the higher rank type somewhere. 
10:27:13 <xa0> is that something scopedtypevariables can help with?
10:27:56 <scshunt> xa0: no
10:28:06 <UberLambda> Hello everyone... Any resources that you know about how to think in a functional way being an heavily imperative programmer?
10:28:07 <xa0> ah, okay, oh well
10:28:09 <xa0> thanks
10:28:21 <c_wraith> by the way, your example forgot the Num a constraint, which is why I misunderstood at first. :) 
10:28:32 <xa0> ah right, my bad!
10:29:40 <c_wraith> I guess it didn't need the constraint, but it's way more useful with it. 
10:29:56 <xa0> makes sense
10:52:15 * hackagebot language-javascript 0.6.0.2 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.2 (ErikDeCastroLopo)
11:09:50 <jophish> The commands on the instances here seem a little mixed up https://wiki.haskell.org/GHC.Generics#Complete_working_example
11:35:46 <Zemyla> How do you prove the correctness of something that presents an immutable interface but uses unsafePerformIO behind the scenes?
11:36:48 <hpc> you use the semantics of unsafePerformIO
11:36:58 <hpc> which are very implementation-dependent
11:37:17 * hackagebot yesod-auth-oauth2 0.1.8 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.1.8 (jferris)
11:37:32 <benzrf> UberLambda: writing a lot of code :P
11:37:50 <UberLambda> benzrf: well... that could work I guess :P
11:37:52 <hpc> er, not /very/ implementation-dependent, but to a certain extent
11:38:22 <hpc> and you reason about what the expected and unexpected real-world interactions of that IO will be
11:39:09 <hpc> and when things get evaluated, etc
11:39:12 <hpc> it's a tricky thing
11:40:12 <Zemyla> Well, the goal is to have a vector where elements can only get set once, and can only get set in order.
11:42:18 * hackagebot libvirt-hs 0.2.0 - FFI bindings to libvirt virtualization API (http://libvirt.org)  https://hackage.haskell.org/package/libvirt-hs-0.2.0 (IlyaPortnov)
11:42:49 <Zemyla> The goal is to have a vector type where k snocs on it have amortized time O(k) as long as no other references to that vector have been made and writteb to.
11:43:11 <Zemyla> If they have, then the vector gets copied and the time is O(n+k).
11:45:11 <jle`> the general heuristic is that your values should still be "referentially transparent" when being used, and "pure"
11:45:54 <jle`> make sure things like x `seq` x = x, inlining things like f x = x ++ x makes sense, that they're thread-safe, etc.
11:46:05 <jle`> you look at these through the lens of unsafePerformIO's semantics
11:51:00 <Zemyla> Yeah. The design I'm looking at is the core vector would be an MVar wrapping an MVector, generation numver, and current endpoint.
11:51:36 <Zemyla> And the user-visible type would have said MVar, a current generation number, offset, and length.
11:53:11 <Zemyla> The core function would be append :: (Vector v a) => AppendVector v a -> Int -> (forall s. Mutable v s a -> ST s ()) -> AppendVector v a.
11:53:34 <Zemyla> So I'd have to worry about exception safety as well.
11:55:16 <Zemyla> And what happens if one thread evaluates va = append v ka fa, and while it's doing that, another thread evaluates vb = append v kb fb.
11:58:05 <Zemyla> I think if I make sure that the user can't ever get theie hands on an AppendVector that goes "past the end", and the vector can't be written to more than once, that should be 99% of the possible problems.
12:01:32 <EvanR> is there a concept for a inverse of a functor and some sort of isomorphism when you have a pair of inverse functors
12:02:14 <Zemyla> EvanR: Look up "contravariant".
12:03:40 <EvanR> hrm yes i know contravariant functor but thats not the same thing
12:03:53 <EvanR> talking about two covariant functors
12:04:43 <Zemyla> So what do you mean the inverse of a functor?
12:05:25 <the_2nd> length l >= 1
12:05:27 <the_2nd> vs
12:05:50 <the_2nd> null $ tail l
12:06:03 <the_2nd> I guess the 2nd will be way faster for large lists?
12:06:27 <Gurkenglas> Why's this say ambigous infix expression? http://lpaste.net/155819
12:06:30 <Gurkenglas> @letlpaste 155819
12:06:30 <lambdabot>  Parse failed: Ambiguous infix expression
12:07:36 <the_2nd> and is there a "check if length > x" method?
12:08:51 <Gurkenglas> > genericLength [0..] > (10 :: Natural)
12:08:53 <lambdabot>  True
12:10:35 <the_2nd> Gurkenglas, still has to iterate all elements, right?
12:10:52 <Gurkenglas> Doesn't look like that traversed all elements of [0..]
12:11:23 <EvanR> Zemyla: two functors which compose to give the identity functor
12:11:59 <the_2nd> Gurkenglas, I came up with this so far: http://lpaste.net/155821
12:12:02 <the_2nd> seems to work fine
12:12:16 <the_2nd> thinking about adding it to the parallel package
12:13:52 <the_2nd> Gurkenglas, using length was way slower in the first condition
12:14:12 <the_2nd> since now I only have to check the first and second element in the list
12:14:34 <Gurkenglas> genericLength using Naturals also has that behavior
12:15:31 <lpaste> Gurkenglas annotated “No title” with “In any case, pattern matches are better than partial functions” at http://lpaste.net/155821#a155822
12:15:47 <Gurkenglas> (like, what if chunks is empty?)
12:16:56 <the_2nd> Gurkenglas, right, this looks better
12:17:13 <the_2nd> just gonna test for [] aswell and it'll be fine
12:17:34 <lpaste> Gurkenglas revised “In any case, pattern matches are better than partial functions”: “Like this, of course, for more local names” at http://lpaste.net/155822
12:20:16 <EvanR> Zemyla: ah... equivalence of categories
12:21:52 <Gurkenglas> the_2nd, is there more than a constant penalty for calling parMap rpar (map f) chunks even in the [_] case?
12:22:53 <the_2nd> Gurkenglas, seems like
12:23:02 <the_2nd> adding the special map case boosted my speed
12:23:21 <the_2nd> also the check for null $ tail boosted it aswell vs length > 1
12:23:30 <the_2nd> * length <= 1
12:23:42 <the_2nd> and yours is just as fast, but cleaner
12:23:46 <Gurkenglas> Then perhaps parMap should be tweaked to have a special case of length 1 instead
12:24:22 <the_2nd> Gurkenglas, problem might be the concat aswell
12:24:45 <Gurkenglas> concat on a list of length 1 is constant time.
12:25:55 <Gurkenglas> hayoo is down?
12:26:17 <the_2nd> Gurkenglas, I'll remove the map case and try again
12:26:32 <EvanR> wikipedia says a essentially surjective functor (or dense functor) F : C -> D means that every object d of D is equal to F(c) for some c in C. two objects are isomorphic if theres a pair of arrows between them such that f . g = g . f = id?
12:26:47 <EvanR> seems like weird language
12:27:36 <Gurkenglas> Any questions?
12:27:53 <EvanR> f.g=id_A g.f=id_B
12:28:02 <EvanR> er
12:28:09 <EvanR> f.g=id_B g.f=id_A
12:28:42 <EvanR> Gurkenglas: ever heard that characeterization of isomrphic objects?
12:29:05 <Gurkenglas> sure how else would you define isomorphism
12:29:48 <EvanR> theres a zillion different isomorphisms
12:30:01 <EvanR> but yeah i guess youre right
12:32:01 <Akii> hm I'm currently trying to implement an event sourced aggregate with this as foundation https://gist.github.com/Fristi/7327904
12:32:26 <Akii> there are multiple things I dislike, right now I'm working on getting rid of the function seed
12:32:58 <the_2nd> Gurkenglas, no difference, my bad. Something else must have changed before while testing
12:33:23 <Akii> anyone here who did this kind of stuff? :D
12:35:36 <Gurkenglas> Akii, why does execute have its first argument?
12:36:17 <Akii> Gurkenglas: well you need some sort of state to execute a command on, except for the creation case
12:36:24 <Akii> this screams state monad
12:36:31 <Akii> have to look it up again, still new ^^
12:38:33 <the_2nd> Akii, I did something similar with a lot of a -> b -> c -> s -> s functions
12:38:37 <the_2nd> where s is the state
12:39:53 <the_2nd> Akii, https://github.com/I3ck/HGE2D/blob/master/src/HGE2D/Datas.hs#L39
12:40:06 <Akii> I worked around this here https://gist.github.com/Akii/f54d25e28ce52bf8d3dc with an "empty" data type
12:40:10 <Akii> but this feels ugly
12:40:40 <Akii> not just feels, it is
12:40:51 <Akii> there is no such thing as a "NewOrganization" :D
12:42:10 <the_2nd> Akii, have you taken a look at the modifying functions?
12:43:51 <Akii> the_2nd: not yet
12:43:56 <Akii> let me look around :D
12:44:09 * ski is idly wondering whether Akii needs to have a `Show' instance that doesn't output a (string representation of) a Haskell expression that (in an appropriate environment) will evaluate to an equal value
12:44:19 <the_2nd> in /Examples there's implementations of those, in case that helps
12:45:06 <Akii> ski: hey having show doesn't hurt, right?
12:45:11 <ski> (btw, `seed' is not (declared as) a function. it's just a value. a method of the type class `Aggregate', if you will)
12:45:36 <Akii> yep
12:45:40 <Akii> and that's just wrong
12:46:19 <Akii> the "seed" is the initial state you get from executing the (one of) initial commands that construct the aggregate
12:46:24 <Akii> usually it's one command
12:46:35 <Akii> and usually that results in one state+event
12:46:39 <ski> Akii : `Show' is mainly for debugging (and simple serialization) uses. imho, it out to generate a valid Haskell expression evaluating to the given value. preferably it also ought to be readable back, using the `Read' class
12:47:19 <ski> Akii : if you want some kind of pretty-printing, nothing is stopping you from defining a different function for that (or, perhaps in some cases, a different type class)
12:47:25 <Akii> which show do you mean exactly?
12:47:46 <ski> i mean `instance Show (EventData e) where show = show . eventId', the explicitly given instance
12:48:08 <Akii> ye that idea is also flawed I think
12:48:12 <Akii> the whole thing
12:48:20 <ski> (the derived instances will automatically satisfy the (imho) preferred, given above)
12:48:20 <Akii> the eventId should be part of the actual event
12:49:12 <ski> ok
12:49:16 <Akii> the EventData type doesn't really make sense to me atm
12:49:23 <ondrejs> Hello. I installed stack with haskell-stack-tool (arch) and now run stack upgrade, which installed a local copy into my home dir. Should I uninstall the system installed stack? Can I force stack to replace the old system installation when upgrading?
12:49:32 <Akii> but one issue at the time :D
12:50:37 <ski> (well, i was reading the paste through from the start, commenting on what i was seeing)
12:51:04 <Akii> (I appreciate it! :D)
12:51:19 <ski> (fwiw, `deriving (Show)' could be just `deriving Show')
12:51:59 <ski> (similarly, `(Aggregate a) =>' could be `Aggregate a =>')
12:53:33 <shirt> i have a monad action that returns (Maybe a). How do i run this repeatedly until it returns "Nothing", and collect all the "a" results in a list?
12:54:28 <Akii> ski: will change that, thanks! :D
12:54:29 <shachaf> shirt: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:unfoldM
12:55:14 <Akii> quick question: Aggregate a => ... means that all a in the definition are instances of type class Aggregate?
12:55:28 <Akii> (I think I missed that part in LYAH)
12:55:34 <shirt> shachaf: thanks!
12:55:39 <ondrejs> Akii: yes
12:55:42 <Akii> nice
12:56:40 <ski> (Akii : perhaps clarification : there's only one single `a' type in the signature, though there may be many occurances of this type variable, referring to that same type)
12:58:30 <statusfailed> Is there a neat way to get this to short-circuit? liftM2 (||) (a :: m Bool) (b :: m Bool)
12:58:48 <Akii> ski:  but Aggregate a => a -> a -> a; all a would be an instance of type class Aggregate, right? (as in, that what you're getting at? :D)
12:59:03 <Akii> I wonder how this looks for more than one type class >_>
12:59:22 <ski> statusfailed : `liftM2' always executes both given actions
12:59:34 <Gurkenglas> statusfailed, orM from Control.Monad.Loops
12:59:44 <ski> Akii : yes
13:00:16 <statusfailed> Gurkenglas: awesome, thanks!
13:00:41 <ski> Akii : i just wanted to highlight that for a single use of an operation of this type, you have to pick a *single* type to use in place of the type variable `a' there. you can't use different types for the three `a's in `a -> a -> a', for a single use of the operation of that type
13:01:07 <ski> (and the single type you pick has to be in the class `Aggregate')
13:02:17 <Akii> okay that I don't get, wat
13:02:38 <ski> Akii : anyway, i'd explicitly name the limits `4' and `8' there, instead of repeating "magic" numbers
13:02:50 <Akii> `a is something different than a or a' - I get that
13:04:28 <ski> Akii : `User' is an instance of `Aggregate', so if we assume `foo :: Aggregate a => a -> a -> a', we can decide to pick `a' as `User', (conceptually) replacing *all* uses of `a' in the signature, getting `foo :: Aggregate User => User -> User -> User'
13:04:40 <irc-ape> burn all jews in gas oven
13:04:49 --- mode: ChanServ set +q *!*@85-76-140-22-nat.elisa-mobile.fi
13:05:03 <Akii> wat
13:05:05 --- mode: ChanServ set -q *!*@85-76-140-22-nat.elisa-mobile.fi
13:05:25 <Akii> sorry, got interrupted by this *ehm* guy
13:05:36 <ski> (just noise, ignore)
13:06:03 <Akii> that's an unexpected applyance of goodwins law
13:06:17 --- mode: ChanServ set +o johnw
13:06:22 --- mode: ChanServ set +o johnw
13:06:36 <ski> Akii : since we know `Aggregate User' holds (iow, `User' is an instance of `Aggregate'), we can simplify this signature to `foo :: User -> User -> User', meaning that if `u0,u1 :: User', we can apply the function to these arguments, getting the signature `foo u0 u1 :: User' for the result
13:06:41 --- mode: johnw set -o johnw
13:06:42 <merijn> Akii: Freenode is often spammed/DDoSed by scriptkiddies, etc. flooding channels with racist diatribe happens every few weeks
13:07:00 <Zemyla> :t (. ((. guard) . flip maybe (const $ return True))) . (>>=) -- statusfailed
13:07:01 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
13:07:06 <Akii> merijn: I'm a lot on freenode, first time that happened wow
13:07:14 <Akii> ski: let me catch up :D
13:07:20 <Zemyla> That is a short-circuiting monadic or.
13:09:27 <ski> Akii : if we assume that `Aggregate LUser' also holds, for some other type `LUser', then another valid instantiation of `a' in the type signature for `foo' would be `foo :: Aggregate LUser => LUser -> LUser -> LUser', which as before can be simplified to `foo :: LUser -> LUser -> LUser', and so if `lu0,lu1 :: LUser', we get `foo lu0 lu1 :: LUser'
13:10:19 <Akii> ski:  ok that makes sense
13:10:20 <ski> Akii : however, we can't use `User' to replace some of the `a's in the signature, and `LUser' to replace some of the other `a's. we can't get `foo :: Aggregate User => LUser -> User -> LUser'
13:11:12 <Akii> ye those would be different "a"s so to say
13:11:18 <Akii> I was thinking of "b"s
13:11:34 <Gurkenglas> :t fmap isJust . runMaybeT . traverse_ ((>>= guard) . lift) -- Zemyla, so is this :D
13:11:36 <lambdabot> (Monad f, Foldable t) => t (f Bool) -> f Bool
13:11:39 <Akii> like Aggregate a => Whatever b => a blubb b
13:11:42 <ski> Akii : finally, it would conceptually work fine to replace `a' with some type *not* known to be an instance of `Aggregate', say perhaps `Int'. we'd get `foo :: Aggregate Int => Int -> Int -> Int'. however, since we don't know `Aggregate Int' (we don't know `Int' to be an instance of `Aggregate'), we can't in this case simplify to `foo :: Int -> Int -> Int', and so we can't actually *use* `foo' with `a' being `Int'
13:12:44 <ski> so it's only useful here to pick `a' to be a type that's actually (known to be) an instance of `Aggregate'
13:13:06 <Akii> I hope anything other would be rejected by the compiler :D
13:13:27 <ski> (one could perhaps imagine more advanced situations, say where someone else will pick the instance, where it could be useful to pick some type *you* don't (explicitly) know to be an instance ..)
13:14:05 <ski> Akii : you'll get a complaint about no/missing instance
13:14:07 <Akii> it would still be an instance of Aggregate as in, it has all the functions needed
13:14:50 <Akii> but what if a function needs an Aggregate and an Ord, how'd that look like
13:14:57 <Gurkenglas> Does some lens stuff relate Maybe () and Bool?
13:15:01 <Akii> Aggregate a => Ord b => ...
13:15:08 <ski> Akii : anyway, possibly you already (more or less) knew most what i said about instances above. i merely wanted to reinforce it a bit, and explain it a little bit more explicitly
13:15:20 <ski> Akii : usually `(Aggregate a,Ord b) => ..a.b..'
13:15:48 <Akii> ski: I really appreciate any input, this strengthens my understanding and expands it!
13:16:37 <ski> @type let bar :: Eq a => Num a => a -> a; bar x = x in bar
13:16:39 <lambdabot> (Eq a, Num a) => a -> a
13:16:58 <ski> see lambdabot even rewrites your format to the other one ^
13:17:23 * hackagebot delay 0 - More useful and humain delaying functions  https://hackage.haskell.org/package/delay-0 (davean)
13:17:34 <Akii> cool :o
13:17:39 <Zemyla> EvanR: I think that you might want to look at adjunctions?
13:17:50 <Gurkenglas> :t \x y -> isJust <$> runMaybeT ((lift x >>= guard) <|> (lift y >>= guard)) -- No wait that other one was andM, not orM, my bad
13:17:51 <lambdabot> Monad f => f Bool -> f Bool -> f Bool
13:20:38 <ski> Akii : btw, note that some people don't bother to remove the "wrapping" brackets in contexts (and `deriving' clauses), when redundant. i just happen to prefer not including them, when there's only one (atomic) constraint (or class, for `deriving'). now that i've told you that you can omit those brackets, you should decide for yourself which you prefer
13:21:05 <EvanR> Zemyla: is this related to equivalence of categories?
13:21:20 <Zemyla> Hmm, probably not :V
13:21:36 <Akii> ski: note that the first gist is not my writing :D I'll certainly improve on my second and amend my copied code
13:21:49 <ski> Akii : `notEmpty = not . null' is generally better (doesn't traverse the whole list to the end. also works on infinite lists)
13:21:50 <Akii> not sure what I like more yet
13:22:20 <Akii> ye the whole validation stuff is still a mystery to me
13:22:39 <ski> Akii : you should be able to rewrite `lengthBetween', not mentioning `True' nor `False'
13:22:47 <Akii> I need to read about applicatives again
13:23:19 <ski> (this is similar to why `... == True' or `... == False' is considered bad style)
13:23:52 <ski> Akii : oh, i thought you had written all of the paste
13:23:59 <Akii> well the thing itself evaluates to boolean
13:24:20 <Akii> nope, I took the first one as base and extended it with my use-case
13:24:38 <ski> e.g. `null xs == True' is the same as just `null xs'
13:24:52 <ski> and `null xs == False' is the same as `not (null xs)'
13:25:07 <Akii> or not $ null xs!
13:25:08 <Akii> :D
13:25:11 <ski> yes
13:25:14 <Akii> yay
13:25:25 <ski> (but i think `$' is overused)
13:25:55 <Gurkenglas> (i think notNull should be the named one of the two)
13:26:14 <tdammers> not . null $ xs
13:26:35 <Akii> I'll keep the lengthBetween thing as an excercice
13:26:51 <nitrix> I personally would write it `not . null $`
13:27:08 <nitrix> ski: Any point to support parenthese over $ in a case like this?
13:27:24 <nitrix> Just preference?
13:27:38 <ski> preference
13:27:42 <Gurkenglas> @letlpaste 155819
13:27:42 <lambdabot>  Parse failed: Ambiguous infix expression
13:27:50 <Gurkenglas> Why's this say that? http://lpaste.net/155819
13:27:57 <EvanR> not (null x)
13:28:19 <EvanR> you just avoided frightening noobs and small children
13:28:49 <nitrix> >> minima, (True,)
13:28:52 <Gurkenglas> not . null, you just came a step closer to eetaaa reduuctiiooon *angelic chorus*
13:29:55 <Akii> I've to look at function composition again
13:30:27 <Akii> "null $ xs" is strange
13:31:05 <EvanR> or the classic
13:31:09 <EvanR> not $ null $ x
13:31:12 <EvanR> ^ :D
13:31:22 <maerwald> look like IO monad stuff :P
13:31:23 <Akii> it just does.. nothing
13:31:26 <Akii> right
13:32:13 <Akii> null [] == null $ []
13:32:25 <ski> <Akii> the "seed" is the initial state you get from executing the (one of) initial commands that construct the aggregate  <Akii> usually it's one command  <Akii> and usually that results in one state+event
13:32:45 <ski> looks to me that `execute :: s -> Command s -> Either (Error s) (Event s)' doesn't result in a state, only an event (or an error)
13:32:58 <Akii> yep, that works if you have state
13:33:11 <Akii> ideally you'd always get new state with a number of emitted events
13:33:15 <Akii> events change state
13:33:40 <Akii> so let's say s -> Command -> Either (Error s) (s, [Event s])
13:33:45 <ski> <Akii> Gurkenglas: well you need some sort of state to execute a command on, except for the creation case
13:33:48 <ski> <Akii> this screams state monad
13:34:04 <ski> so you're adding in a state monad not just yet, then ?
13:34:19 <Akii> well it looks just like state monad
13:34:33 <Akii> so yes, I've to re-evaluate this and change the design
13:34:54 <ski> with a state monad, you get a new state back (implicitly) upon executing an action
13:34:56 <Akii> just trying to avoid complexity
13:35:13 <Akii> I need both, state and the events
13:35:22 <ski> in your case, you get no state back from `execute', at all
13:35:47 <Akii> yep, you'd somehow take the Right from execute, apply the event and get new state
13:35:54 <ski> you could do it without an explicit state monad, as well -- if you prefer, for learning purposes
13:36:20 <Akii> apply is pretty much "perfect"
13:36:28 <ski> the `Right' alternative currently only gives you an event, which, iiuc, doesn't include a state
13:36:40 <ski> instead of
13:36:42 <ski>   execute :: s -> Command s -> Either (Error s) (Event s)
13:36:43 <ski> would
13:36:47 <ski>   execute :: s -> Command s -> Either (Error s) (Event s,s)
13:36:48 <ski> be ok ?
13:36:51 <ski> or perhaps
13:36:57 <ski>   execute :: s -> Command s -> (Either (Error s) (Event s),s)
13:36:58 <ski> ?
13:37:12 <ski> with the former, you don't get a new state, in case of error
13:37:24 <ski> with the latter, you get a (possibly) new state, even in case of error
13:37:25 <Akii> execute :: s -> Command s -> Either (Error s) (Event s,s) is quite all right
13:37:34 <ski> ok
13:37:34 <Akii> error really means no state change
13:37:51 <Akii> the problem here is the initial state
13:38:19 <ski> @unmtl StateT s (Either (Error s)) (Event s)
13:38:19 <lambdabot> s -> Either (Error s) (Event s, s)
13:38:25 <Akii> ideally I'd like the compiler to know what those initial commands are that result in ([Event s], s)
13:38:51 <Akii> (because theoratically a Command could result in multiple Events)
13:38:53 <ski> by "initial state", do you mean the input state argument to `execute' ? or perhaps you are referring to `seed :: s' ?
13:39:00 <Akii> the seed
13:39:05 <Akii> that doesn't exist
13:39:16 <Akii> there is no "NewOrganization" - it's something I made up
13:39:36 <Akii> you either have an organization or you don't
13:39:44 <Akii> and you get one by executing a command
13:39:45 * ski didn't even get what "NewOrganization" was meant to indicate
13:39:52 <Akii> exactly
13:40:40 <ski> anyway .. looking at `main', it looks like you'd want the execution of the latter commands there to be influenced by the execution of the earlier commands
13:41:01 <ski> specifically, the first `execute ...' should operate on data loaded by `load ...' above it
13:41:30 <ski> similarly, the second `execute ...' should operate on (modified) data resulting from `execute ...' and `load ...' above it
13:41:33 <ski> Akii : is this correct ?
13:42:24 <Darwin226> Hey guys, why does Applicative (MaybeT m) require Monad m instead of just Applicative m?
13:42:36 <Akii> ski:  yes
13:42:46 <Akii> all of that is really the state monad :D
13:43:02 <ski> specifically, i'm guessing that you'd want the state resulting from the `load' call to be passed as "seed" state into the first `execute' call, and furthermore, the state resulting from *that* `execute' call to be passed as "seed" into the second `execute' call
13:43:22 <Akii> no, load is using past events to derive state
13:43:38 <Akii> seed is just a bad way to get the first state to apply events on
13:43:54 <Akii> execute is using commands which, if valid, alter state through events
13:44:00 <ski> Darwin226 : because `MaybeT m a' is iso to `m (Maybe a)', and so we need to look at the result of executing this action before knowing how to continue, in `(>>=)'
13:44:34 <ski> Darwin226 : er, sorry, that was not quite right
13:44:42 <Darwin226> ski: Would that mean that it's imposible to implement it with just Applicative or that it would simply have the wrong semantics?
13:45:09 <meoblast001> is it normal to get strange behaviour when you start using two IORefs in one function?
13:45:17 <Darwin226> because I have my own type that's quite similar to MaybeT and I've managed to implement the Applicative without Monad
13:45:33 <Darwin226> so I don't know if now I have a broken instance since I mostly just followed the types
13:45:39 <ski> Darwin226 : on second thought, i think it ought to work just fine, requiring only `Applicative m'
13:45:51 <Akii> (afk like 10 mins :D)
13:47:09 <Darwin226> ski: What's the deal then?
13:48:17 <ski> Darwin226 : given `MaybeT m (a -> b)' and `MaybeT m a', we unpack and pair into `(m (Maybe (a -> b)),m (Maybe a))', "smash" on `m' (using `uncurry (liftA2 (,))', say) into `m (Maybe (a -> b),Maybe a)', "smash" on `Maybe' (using `liftA (uncurry (liftA2 (,)))', say) into `m (Maybe (a -> b,a))', apply (using `(liftA . liftA) (uncurry ($))') into `m (Maybe b)', and pack back to `MaybeT m b'
13:48:24 <ski> Darwin226 : so i dunno
13:49:13 <Darwin226> i just did fmap (<*>) to go from m (Maybe (a -> b)) to m (Maybe a -> Maybe b)
13:49:34 <Darwin226> and then <*> that with the other m (Maybe a)
13:49:41 <ski> yeah, that sounds easier
13:49:59 <Gurkenglas> Applicatives compose in general, we don't need to look at anything Maybe-specific
13:50:08 <ski> (i just wrote down the first thing that came to mind)
13:50:25 <Darwin226> Gurkenglas: That's good to know because it should mean that it works for my type then
13:50:35 <Darwin226> ski: Yeah, you did it way faster than what it took me haha
13:50:59 <Gurkenglas> ( https://hackage.haskell.org/package/transformers-0.4.2.0/docs/Data-Functor-Compose.html )
13:51:26 <Darwin226> Gurkenglas: Got any idea why the MaybeT requires a monad then?
13:52:19 <ski> meoblast001 : using any concurrency ?
13:52:28 <ski> meoblast001 : or perhaps you have an aliasing problem ?
13:52:35 <Gurkenglas> Nope. https://github.com/aelve/haskell-issues :D
13:53:36 <Gurkenglas> (Probably legacy from before FAM)
13:54:36 <ski> <Akii> execute is using commands which, if valid, alter state through events
13:54:51 <ski> Akii : so it must get that state to alter from somewhere, no ?
13:55:56 <ski> Akii : i'm not sure what (/which) part(s) of my "specifically, ..." statement you objected to
13:57:20 <meoblast001> ski: no concurrency. somehow the issue went away after a recompile and i'm not sure how
13:57:39 <ski> strange
13:58:40 <meoblast001> yeah :/
13:59:03 <ski> you used the same input ?
13:59:20 <ski> (no randomness or other changed circumstances ?)
14:01:07 <Jinxit> I blame cosmic rays
14:01:58 * ski . o O ( there's only one CosmicRay )
14:02:34 <Akii> ski:  specifically, the first `execute ...' should operate on data loaded by `load ...' above it
14:02:39 <Akii> yes
14:02:49 <Akii> but not the first first execute
14:02:56 <Akii> because in the beginning there is nothing to load
14:03:14 <ski> "first first execute" ?
14:03:15 <Akii> so execute s -> Command ... is missing the first s
14:03:16 <zoie> hi there! Does anyone know why isn't Writer a MonadPlus?
14:03:16 <ski> where's that ?
14:03:27 <Akii> that is when the first command creates the first state
14:03:42 <Akii> CreateAggregateCommand
14:03:51 <ski> zoie : how write `mempty' ?
14:04:32 <zoie> ski: well…
14:04:33 * ski sees no mention of `CreateAggregateCommand' in the paste
14:04:50 <Akii> ski: it's "FoundOrganization"
14:05:03 <ski> ditto for that
14:05:11 <Akii> I'd like this to be known to the compiler as well
14:05:17 <ski> (perhaps i should look in a different file ?)
14:05:43 <Akii> https://gist.github.com/Akii/f54d25e28ce52bf8d3dc#file-organization-hs-L55
14:05:46 <Akii> kind of this case
14:05:54 <ski> (zoie : for that matter, `mplus' seems to be problematic as well ..)
14:06:08 <Akii> it's encoded in this NewOrganization "thing"
14:06:12 <zoie> zoie: ok I got it, thanks!
14:06:19 <zoie> ski: ok I got it, thanks!
14:06:26 <ski> np
14:06:54 <ski> Akii : /ll_new Organisation
14:06:55 <ski> er
14:07:29 <Akii> basically the ideal thing would be "in case there is no state, one can use Commands of type x to get state, afterwards you need to executes Command on state"
14:07:43 <ski> (ok, i see i missed that paste before)
14:08:20 <Akii> executing FoundOrganization twice must result in a compile time error
14:08:23 <ski> (as before, `(NewOrganization) -> ' could be `NewOrganization -> ', `(Organization { closed = True })  -> ' could be `Organization { closed = True }  -> ', &c.)
14:09:23 <ski> Akii : hmm. the simplest way to achieve that would be to distinguish between `InitialCommand' and `InternalCommand' (or however you want to call them)
14:09:36 <Akii> yes I thought about that
14:09:52 <Akii> so basically replace "seed" with "create"
14:10:03 <Akii> create :: InitialCommand -> (Event s, s)
14:10:17 <Akii> the execute part must change to (Event s, s) at least
14:10:22 <ski> Akii : the next simplest (assuming you want to keep some machinery common to them (if this is sensible, i'm not sure)), would be to use a GADT to keep track of what kind of states commands needs to execute in (and what kind of state the resulting state is)
14:11:08 <ski> Akii : .. a variant of the former would be to build the `FoundOrganization' in to the operation which starts off a sequence of commands
14:11:15 <Akii> GADT looks like the Free programs you build in scala
14:11:32 * ski isn't sure what "Free programs" in Scala is
14:11:50 <Akii> ye sorry for being vague
14:12:20 <ski> <ski> <Akii> execute is using commands which, if valid, alter state through events
14:12:23 <ski> <ski> Akii : so it must get that state to alter from somewhere, no ?
14:12:24 <Akii> like the little algebra you build to make a program that you magically lift into a monad and then execute with an interpreter
14:12:26 <ski> did you respond to that ?
14:12:27 * hackagebot Spock-lucid 0.3.0.0 - Lucid support for Spock  https://hackage.haskell.org/package/Spock-lucid-0.3.0.0 (Artyom)
14:12:57 <Akii> exactly
14:13:05 <ski> (actually, i think the GADT thing i was thinking of would require indexed monads ..)
14:13:08 <Akii> the initial state comes from evaluating the initial command
14:13:20 <ski> (or indexed applicatives, as the case may be)
14:13:30 <Akii> so NoState -> FoundOrganization -> SomeState
14:13:50 <Akii> whereas State -> DoThingToOrganization -> Either Error State
14:13:55 <Akii> ehm Event
14:13:56 <ski> Akii : so is `load' in your paste there (in `main') supposed to be that initial command ?
14:14:01 <Akii> which results in State
14:14:16 <Akii> no, load just takes what has already happened
14:14:37 <ski> so `load' should also take an input state ?
14:15:03 <Akii> load takes the initial event and folds over all the other events to create state
14:15:23 <ski> is there a need to distinguish the initial event from other events ?
14:15:28 <Akii> no
14:15:44 <Akii> events have happened, this is just about deriving state from events
14:16:08 <ski> then `load' should also take an input state, no ?
14:16:12 <Akii> if, for whatever reason, you can't apply an event it's just an error in code
14:16:29 <Akii> not really, events are the state basically
14:16:39 <Akii> that's so meta
14:16:50 <Akii> it's [event] -> state
14:16:55 <Akii> doesn't matter what event
14:17:00 <ski> `apply :: s -> Event s -> s' to me looks like events describe how to update a "before" state" to an "after" state
14:17:17 <Akii> yes that's because you have seed
14:17:25 <Akii> without seed that looks different
14:17:29 <ski> yes, but we're trying to get away from `seed', no ?
14:17:39 <Akii> https://gist.github.com/Akii/f54d25e28ce52bf8d3dc#file-organization-hs-L67
14:17:44 <Akii> yes
14:17:53 <Akii> apply reflects this quite well I think
14:18:20 <ski> so in the case of `apply' at least, it looks like "events are the state basically" isn't correct
14:18:37 <ski> presumably `apply' will apply changes to the input state, according to the event, to compute the output state
14:18:58 <Akii> yes apply would horribly crash on anything if it weren't started by OrganizationFounded
14:19:18 <ski> hm, i see
14:19:29 <Akii> also a thing I need to work on
14:19:46 <Akii> one event creates initial state, the following events mutate state
14:19:49 * ski feels like we're parhaps arguing a bit in circles, here
14:19:58 <Akii> and in the end you have derived state ^^
14:20:12 <Akii> and on that state you execute commands, commands are validated, events emitted
14:20:14 <ski> in any case, i'm not quite sure what it is you'd like to achieve atm here
14:20:27 <Akii> the basic term is event sourcing
14:21:03 <Akii> in OOP you'd call new Organization(..) and internally it would hold the creation event
14:21:10 <Akii> which you later extract and persist
14:21:31 <Akii> and then you'd have something like Organization::load(EventStream) where EventStream is [Event]
14:21:54 <Akii> and it would mutate state until you're done replaying events
14:22:34 <Akii> in FP this shifts to Command -> ([Event], state)
14:22:37 <ski> if `load' is always supposed to start by handling a creation event in the list, then i'd suggest using `undefined' (or better, a call to `error'), instead of `seed'
14:23:00 <Akii> I agree the first event is kinda special
14:23:39 <Akii> funny, never thought of it like that
14:24:00 <ski> (however, in general i'd try to avoid doing stuff like that)
14:24:30 <Akii> in the state monad, where does the first state come from?
14:24:36 <ski> itym `Command -> [Event] -> state', maybe ?
14:24:52 <johnw> this feels like an abstract data type where you've reified calls to interface methods as values
14:24:52 <ski> Akii : from whoever constructs the initial state
14:25:15 <Akii> that looks pretty right
14:25:32 <Akii> a Command will result in a series of events which can be derived to state
14:25:33 <ski> Akii : often, the one constructing the initial state could be a "run function" that you're exporting
14:26:02 <Akii> so the first command would start the thing by calling run
14:26:11 <Akii> that is the essence of FoundOrganization
14:26:13 <ski> Akii : anyway, i think you'd modify that to `Command -> [Event] -> state -> state', so that later commands can modify the state output by earlier commands
14:27:17 <ski> anyway, it's a bit hard to give useful advice here, since it's not clear how this is supposed to be used
14:27:59 <ski> the fact that you're using a common abstraction, `Aggregate', for both `User' and `Organization', seems to suggest that you'd prefer to not have one `run'-function for `User', and other for `Organization'
14:28:02 <Akii> ye it's funny that this is an issue
14:28:18 <Akii> I've to think about this
14:28:22 <ski> perhaps you'd even want to be able to mix commands pertaining to users with commands pertaining to organizations, in the same "command stream"
14:28:30 <Akii> (also note that User was copied from the initial gist)
14:28:55 * ski has no idea which the initial gist was, nor who made it
14:29:18 <Akii> let initialGist = https://gist.github.com/Fristi/7327904
14:29:34 <ski> ok
14:29:37 <Akii> :D
14:29:38 <shachaf> ski: I don't even know what a gist homomorphism is.
14:29:50 <ski> so do you want to have `User' in your program as well ?
14:30:01 <ski> shachaf :)
14:30:05 <Akii> ye I will but one thing at a time ^^
14:30:39 <ski> (Akii : ok, that gist)
14:30:52 <Akii> it will be an instance of Aggregate and have one or more initial command to create, and multiple others to alter state
14:31:23 <Akii> this is a very basic form of persistence
14:31:34 <ski> so would it be valid to create more than one user, in a command stream ?
14:31:42 <ski> more than one organization ?
14:32:03 <Akii> that depends on what you mean by "command stream"
14:32:14 <ski> i don't know, yet :)
14:32:22 <Akii> command is something you want to do
14:32:29 <Akii> an event is something that has happened
14:32:44 <ski> i'm thinking of something your calls in `main', one to `load' and two to `execute'
14:32:46 <Akii> commands are executed on aggregates (e. g. one user)
14:33:21 <ski> presumably when developed further, such commands to execute on a state would come from some source in your program
14:33:36 <ski> by "command stream" i meant that source, whatever it may turn out to be
14:34:13 <Akii> command stream if you do command sourcing
14:34:22 <Akii> I'm aiming for event sourcing
14:34:30 <Akii> both options are possible
14:34:41 <ski> Akii : so, can an aggregate have more than one user ? more than one organization ? both (at least) one user and (at least) one organization ?
14:34:46 <Akii> no
14:34:58 <Akii> I mean, yes if that's the business case but no, not in this case
14:35:05 <ski> ok
14:35:10 <Akii> one organization has a stream of events
14:35:28 <Akii> from that stream the state of the organization is derived
14:35:55 <Akii> state orga = apply ev1 (apply ev2 ..))
14:36:07 <ski> how are events related to commands ?
14:36:18 <Akii> not at all actually
14:36:25 <Akii> commands result in events
14:36:31 <Akii> in the end, only events matter
14:36:39 <Akii> events = things have happened
14:37:01 <ski> may events cause new commands to be executed ?
14:37:03 <Akii> that's why they are stored in an event store, an append only database
14:37:19 <Akii> yes but event emitted cause new commands
14:37:28 <Akii> that's a bit down the road
14:37:53 <Akii> so it doesn't stop with calling a command
14:37:59 <Akii> command -> [event]
14:38:23 <Akii> afterwards you take those events and persist them (in the store) and then "publish" them
14:38:42 <ski> mhm
14:38:59 <Akii> this doesn't concern the aggregate organization anymore though
14:39:31 <ski> atm, i'm attempting to understand the situations in which you're to use `load' and `execute'
14:40:05 <Akii> load should ideally be [event] -> state#
14:40:12 <Akii> without the # ofc
14:40:25 <Akii> and execute should be Command -> state -> [event]
14:40:34 <Akii> (with possible failure)
14:40:45 <Akii> and then you take those events, persist them
14:40:59 <Akii> so that in the next load you get the state after the command
14:41:15 <ski> should `execute' result in a (possibly) new state ?
14:41:20 <Akii> and ofc, because things would be too easy otherwise, you publish those new events onto other things
14:42:10 <Akii> state `execute` event -> Either (Error) ([Event], state')
14:42:23 <ski> right
14:42:26 <Akii> oh god, client, what are you doing
14:42:44 <ski> so you want to use the state monad here, right ?
14:42:49 <Akii> each Command executed on State can result in an Error or a series of Events
14:43:05 <ski> are you wondering how to do that, or do you already know how to fix that part ?
14:43:05 <Akii> well that could work, maybe
14:43:24 <Akii> that was the basic idea
14:43:41 <Akii> not sure how that works with command resulting in multiple events
14:43:45 <Akii> hence state changes
14:44:06 <Akii> also there are still more things to cover
14:44:13 <ski> you'd presumably need to handle the new events in some order (?)
14:44:26 <Akii> lol ye right
14:44:30 <Akii> events have an order
14:44:59 <Akii> so with each event created by an aggregate the "version" of that aggregate is increased
14:45:52 <ski> @unmtl StateT s (Either (Error s)) (Event s)
14:45:52 <lambdabot> s -> Either (Error s) (Event s, s)
14:46:23 <ski> means `execute :: s -> Command s -> Either (Error s) (Event s,s)' can be expressed as `execute :: Command s -> StateT s (Either (Error s)) (Event s)'
14:46:26 <Akii> I love how in Haskell it's just there
14:46:37 <Akii> where as in Scala you need a lib
14:46:42 <ski> (sorry, what's just there ?)
14:46:48 <Akii> StateT
14:47:07 <Gurkenglas> That's in a lib, lambdabot just imports lotsa libs by default
14:47:10 <Iceland_jack> You need the 'mtl' library to use StateT
14:47:21 <Akii> oookay I take that back :D
14:47:25 <ski> @index StateT
14:47:25 <lambdabot> Control.Monad.Trans.State.Strict, Control.Monad.Trans.State.Lazy, Control.Monad.Trans.State
14:47:25 <Iceland_jack> ;)
14:47:27 <Tekkkz> >2+3
14:47:33 <Iceland_jack> > 2+3
14:47:35 <lambdabot>  5
14:47:40 <Akii> let's just say, cool to have that as a lib :D
14:47:54 <Akii> but yes, State monad
14:48:27 <ski> so, i think you should be able to express the three actions in `main' as state-actions, using something like that
14:49:17 <Akii> some StartWithThisCommand which results in a State
14:49:29 <Akii> somehow and then just apply events
14:51:17 <ski> a member can't be both administrator and moderator ?
14:51:31 <Tekkkz> > 5-2
14:51:33 <lambdabot>  3
14:52:05 <Akii> ski:  nope
14:52:15 <ski> Tekkkz : fyi, you can also `/query lambdabot' / `/msg lambdabot > 5-2' privately
14:52:16 <Akii> administrator basically > moderator
14:52:50 <Akii> thought that might come in handy later in if Role > Role
14:52:57 <ski> instead of using `Maybe Role', you could possibly add another alternative to `Role'
14:53:06 <Akii> yes already there
14:53:20 <Akii> refactored that to data Role = Member | Administrator | Moderator deriving (Eq, Ord, Show, Read, Bounded, Enum)
14:53:23 <ski> ok
14:53:44 <Akii> derive all the things
14:54:19 <Akii> got rid of data Member and replaced that with type (UUID, Role) for the Map
14:54:25 <ski> is it possible to close an organization which still has members left ?
14:54:44 <Akii> interesting question, I'd say yes
14:55:02 <Akii> but the result is undefined
14:55:10 <Akii> very intersting question indeed
14:56:30 <ski> you can't found a new organization, when the old one has been closed ?
14:56:35 <Akii> this is a thing where I might go for `ClosedOrganization orgId title description`
14:57:45 <Akii> the basic idea is: when I might want to re-open it, then what
14:57:53 <Akii> but I haven't thought that case through yet
14:58:01 <ski> to me, `execute' for `Organization' looks like it wants to use GADTs .. i'm not sure it's worth it, though
14:58:07 <Akii> as for organizations: you can create howmany you want
14:58:48 <Akii> except for the pattern matching, I think it's expressive enough
14:59:13 <Akii> or not except for
14:59:27 <Akii> like this is acceptable imo
14:59:39 <Akii> it's missing validation, sure
15:02:18 <Akii> I really need to get going, thank you so much ski
15:02:31 <ski> should `MembershipGranted' check whether the user is already a member ?
15:02:39 <Akii> no
15:02:43 <Akii> that's an event
15:02:52 <ski> ok
15:03:03 <ski> yes, i see
15:03:13 <Akii> if something goes wrong during `apply` the program should ideally crash
15:03:24 <ski> ok
15:03:25 <Akii> or not compile
15:03:33 <Akii> if that's even possible, probably not
15:03:49 <Akii> this goes as far as migrating events
15:04:03 <Akii> to let's say MembershipGranted_v2
15:04:21 <Akii> which takes a reason why the membership was granted.. etc
15:04:29 <Akii> brb
15:07:44 <ski> Akii : you'd have to use a variant of a list, which keeps track of the current "kind of state", inbetween each event
15:08:17 <ski> Akii : in the case of `Organization', this could start at `NoOrganization', go to `OpenOrganization', then to `ClosedOrganization'
15:11:04 <ski> Akii : then e.g `FoundOrganization' and `OrganizationFounded' could only be used in a state abstractly described by `NoOrganization', and would result in a state described by `OpenOrganization'
15:11:32 <ski> Akii : whether it's worthwhile (and workable, in a larger context), to organize things like this, i'm not sure
15:12:39 <Akii> NoOrganization would then be my "NewOrganization" I guess
15:12:53 <Akii> it really is NoOrganization
15:13:18 <Akii> it's nothing, then it's something and eventually it'll be closed
15:13:22 <runeks> Is it possible to analyze a particular Haskell program to see if all possible exceptions are handled properly? Sometimes it's not obvious to me that a particular function can throw an exception (for example "accept": https://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket.html#v:accept ), so I'd really like to have some way to make sure I've
15:13:23 <runeks> caught everything that can make my program abort unexpectedly.
15:13:26 <Akii> FSM ^^
15:15:11 <Cale> runeks: It's a bit tricky. Such an analysis would be quite a useful thing to add to GHC, but I'm not altogether sure how it could be done, even ignoring the possibility for async exceptions between threads.
15:15:16 <ski> Akii : in this case, `NoOrganization' would not be a constructor of `Organization'
15:16:00 <ski> Akii : `NewOrganization :: Organization NoOrganization' would be the signature
15:16:08 <Cale> runeks: The mechanism for defining exception types is sort of programmably-extensible in a way that might make analysis a bit of a challenge.
15:17:13 <Cale> runeks: The tradeoff is that you can define a new types of exception which act as unions or arbitrary refinements of existing exception types.
15:17:31 <Cale> -a
15:17:34 <ski> Akii : and `Organization :: {...} -> Organization OpenOrganization', and `FormerOrganization {...} -> Organization ClosedOrganization' (i renamed your `ClosedOrganization' to `FormerOrganization' to not clash with my distinct use of the name `ClosedOrganization')
15:17:39 <runeks> Cale: Isn't the advantage of the pure function sort of lost when it can just throw an exception, ie. have a side effect that way instead?
15:18:15 <ski> (runeks : exceptions can't be caught in evaluation, only I/O execution)
15:18:18 <Cale> runeks: Well, exceptions thrown by error through *evaluation* generally are not intended to be caught
15:18:49 <Cale> You typically only throw an exception in that way if you think the case is impossible.
15:19:03 <Cale> Or if you just aren't done writing the program yet
15:19:29 <Cale> (and don't mind having the entire program stop if it ever gets evaluated, because it's nicer than an infinite loop)
15:19:48 <ski> an effect (in this case exception) tracking system would be interesting .. but i think it would probably be unrealistic for anything but executions thrown by execution
15:20:51 <Cale> Yeah, exceptions thrown by the execution of IO actions are actually reasonable to catch
15:21:21 <Cale> It's still a complicated business detecting that they will actually be caught... I could give some examples which show why it might be tricky.
15:21:27 <ski> runeks : in the case of `accept', i think the exception is thrown by I/O execution ?
15:21:34 <Cale> yes, it would be
15:21:58 <ski> (so the "the advantage of the pure function" is irrelevant here then, no ?)
15:22:18 <icicled> could someone please point out what I'm doing incorrectly w/regards to TVars: http://lpaste.net/5847313814172729344
15:22:28 <icicled> I can create a new TODO but the Ids never increment
15:22:30 <Cale> Also, while you don't really have the opportunity to fix other people's APIs all the time, if you want to signal that some IO action has an exceptional case, consider giving it a type like IO (Either e a)
15:22:46 <Cale> ski: indeed
15:23:58 <Cale> icicled: Why are you using swapTVar and then ignoring the result?
15:24:05 <ski> icicled : looks like each use of `todos' in `server' will create a new `TVar' holding an `IntMap Todo'
15:24:12 <nolraiU> I wounder what a linear combinator calculus would look like.
15:24:17 <ski> icicled : presumably you wanted to make a single, shared, one ?
15:24:18 <icicled> since I don't need the old value
15:24:27 <Cale> icicled: yeah, but there's writeTVar for that
15:24:35 <icicled> yes, I was [incorrectly] assuming that it would be shared
15:24:49 <icicled> what is the proper way to go about it?
15:25:16 <icicled> Cale: got it, will change to writeTVar
15:25:29 <Cale> icicled: Yeah, todos is the action which creates a new TVar containing an empty IntMap each time you run it
15:25:33 <ski> create the `TVar' once, then use it (possibly more than zero times)
15:25:55 <Cale> The solution is to run todos exactly once, and pass along the resulting TVar to the rest of the code
15:26:03 <ski> either create the `TVar' so that you can use it in scope, or pass it in as a parameter to the action that needs to refer to it
15:26:11 <icicled> got it
15:26:17 <ski> in this case you probably want the latter variant
15:26:38 <icicled> thanks, I'll give that a whirl
15:26:47 <icicled> appreciate it!
15:27:05 <ski> (the former would require your `server' to be declared inside whatever action creates your `TVar (IntMap Todo)')
15:27:16 <runeks> ski: I'm not sure what throws the exception, to be honest. But looking at it again I can see you are right, accept isn't a pure function. But the function I construct, in which I use accept, *is* a pure function, so I guess it makes sense that I need to catch  IO errors within this function, since it uses an impure function like accept.
15:27:40 <ski> runeks : `accept' is a pure function
15:28:02 <runeks> ski: Because it returns an IO action?
15:28:15 <ski> every Haskell function is pure
15:28:29 <Cale> icicled: It's very important to understand that when something has type IO t it's not at all the same as something whose type is t. A value of type IO t is an action which, each time it is executed, provided that it terminates normally, will result in a value of type t.
15:28:44 <ski> if it did I/O, without involving `IO' in the result type, *then* it would be impure (have a *side*-effect)
15:29:17 <ski> because the `IO' is declared as part of the result type, the effect is not happening on the *side*. it's just an effect, declared for in the interface
15:29:27 <Cale> icicled: So, just thinking about the type of todos, it should be apparent that it's not a TVar, but something which gives you a TVar each time it is executed. When you look at the implementation, you see that it's an action that just makes a new TVar.
15:29:59 <ski> runeks : what is the type of "the function I construct, in which I use accept" ?
15:30:28 <runeks> ski: acceptLoop :: Socket -> ((Socket, SockAddr) -> IO ()) -> IO ()
15:30:45 <ski> ok. that also has `IO' in the result type
15:30:47 <icicled> thanks Cale, that clears it up
15:30:58 <ski> (so i'm not sure what you meant by "the function I construct, in which I use accept, *is* a pure function", then)
15:31:07 <Cale> In particular, accept is the function which, given a Socket, produces the action which *when executed* will accept a connection on that socket.
15:31:14 <Cale> It is a pure function from sockets to actions
15:31:16 <runeks> So just because a function is pure doesn't mean it can't terminate without returning a result?
15:31:28 <Cale> But the ensuing execution of that action is not pure
15:31:40 <Cale> For a simpler example
15:31:47 <Cale> putStrLn :: String -> IO ()
15:32:06 <Cale> is a pure function which, given a String, gives you the action which, each time it is executed, will print that String to the terminal
15:32:18 <Cale> Evaluating the application of that function has no effects
15:32:32 <Cale> Executing the resulting action does though, it prints stuff on the terminal.
15:32:46 <ski> runeks : you need to distinguish between evaluation (of an expression) and execution (of an action, which is a particular kind of value, specifically a value of type `M T', for `T' some type, and `M' a monad (or applicative functor))
15:32:50 <runeks> Cale: Ah. I guess I wasn't clear on the difference between the IO action itself and the result of its execution.
15:34:12 <ski> runeks : calling `accept' and evaluating the result (an I/O-action), will not perform the effects *described* by that action. later *executing* that action may sometimes terminate abnormally (without a resulting value of type `(Socket,SockAddr)')
15:34:21 <pigworts2> Can anyone see why this is not working (it syntax errors on me):      (:) :: (Applicative m, Monoid (m b), Eq b) => b -> m b -> m b 
15:34:43 <hpc> ':' is a capital symbol, to put it in the stupidest-sounding of terms
15:34:57 <pigworts2> Ah, any reason why?
15:35:03 <hpc> it's like that for the syntactic rule of constructors starting with upper-case letters/symbols
15:35:12 <hpc> and (:) is the cons constructor for lists
15:35:32 <ski> runeks : an action is like a recipe for a cake. the result of executing the action will (normally) be a cake. depending on the details of the kind of action (I/O-action, state-action, `Maybe'-action, &c.), the result may differ in some way from "just a cake" -- this is what we call an effect
15:35:48 <jle`> pigworts2: it's a similar error you'd get if you tried to define Foo :: Int -> Bool
15:35:57 <jle`> capital letter names are reserved for constructors
15:36:01 <hpc> fun logical consequent of this though, you can use symbols as constructors if you start them with ':'
15:36:06 <ski> runeks : anyway, the recipe of a cake is not a cake. in particular, it (in general) doesn't "contain" a cake
15:36:09 <jle`> @let Foo x = x + 3
15:36:10 <lambdabot>  .L.hs:298:1: Not in scope: data constructor ‘Foo’
15:36:10 <lambdabot>  
15:36:10 <lambdabot>  .L.hs:298:9:
15:36:10 <ski> @quote /bin/ls
15:36:10 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
15:36:42 <hpc> type (:=>) = Kleisli -- in the right code something like this might be quite handy
15:37:07 <pigworts2> hpc: So is there any way I can redefine (:) to accept applicative monoids (i.e I can do (pure a) <> b)
15:37:27 * nolraiU muses. I wounder what a linear combinator calculus would look like.
15:37:34 <jle`> pigworts2: are you trying to shadow the definition of (:) ?
15:37:43 <hpc> perhaps something like <$:>
15:37:46 <jle`> you can't really "redefine" it, remember
15:38:02 <nitrix> let (:) in ...
15:38:03 <hpc> to "rhyme" with (<$>) = a similar combination of pure and (<*>)
15:38:20 <nitrix> You could shadow it, but I don't see the point.
15:38:21 <jle`> you can achieve something similar with PatternSynonyms but that'd be kind of silly
15:38:38 <jle`> nitrix: that doesn't work, just like let True = ... doesn't work
15:38:44 <ski> > let (:) = \xs x -> xs ++ [x] in "foo" : '!'
15:38:45 <lambdabot>      Constructor ‘:’ should have 2 arguments, but has been given none
15:38:46 <lambdabot>      In the pattern: (:)
15:38:46 <lambdabot>      In a pattern binding: (:) = \ xs x -> xs ++ [x]
15:39:00 <jle`> > let True = 5 in True
15:39:01 <lambdabot>      No instance for (Num Bool) arising from the literal ‘5’
15:39:02 <lambdabot>      In the expression: 5
15:39:02 <lambdabot>      In a pattern binding: True = 5
15:39:18 <hpc> pigworts2: to dig more to the heart of the issue though, what goal are you using this to solve(?), and in all likelyhood you don't want to be doing it that way
15:39:29 <ski> (`xs : x = xs ++ [x]' obviously doesn't work, either)
15:39:53 <ski> > let True = () in True
15:39:54 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘()’
15:39:54 <lambdabot>      In the expression: ()
15:39:54 <lambdabot>      In a pattern binding: True = ()
15:40:08 <ski> (key words being "pattern binding")
15:40:13 <jle`> pigworts2: i'd just give your function a new name that isn't :
15:40:26 <jle`> it's kind of weird to export functions that have the same name as standard constructors/functions
15:40:36 <jle`> it happens sometimes, though
15:40:52 <jle`> Control.Category exports its own (.)
15:41:25 <jle`> before the AMP, Data.Foldable exported its own length to generalise Data.List's length
15:41:38 <jle`> but for the most part things like that just cause confusion and pain
15:41:43 <jle`> just make your own function with its own name :)
15:45:56 <LysergicDreams> Is there a good way to get Aeson & Persistent to spit out JSON like: "{ errors: { name: "This field is required." } }"
15:46:44 <dmj`> @package digestive-functors-aeson
15:46:44 <lambdabot> http://hackage.haskell.org/package/digestive-functors-aeson
15:46:45 <LysergicDreams> Or should I just make wrap my API model fields in "Maybe" and do it all in my custom post parsing validation?
15:46:57 <ij> What's the difference between Data.{Ini,ConfigFile}?
15:47:33 * hackagebot bond-haskell-compiler 0.1.2.0 - Bond code generator for Haskell  https://hackage.haskell.org/package/bond-haskell-compiler-0.1.2.0 (blaze)
15:47:35 * hackagebot bond-haskell 0.1.2.0 - Runtime support for BOND serialization  https://hackage.haskell.org/package/bond-haskell-0.1.2.0 (blaze)
15:47:46 <LysergicDreams> dmj`: Wow, that example is almost exactly like mine :D Thanks 
15:53:14 <dmj`> c_wraith: ping
16:32:43 <MichaelBurge> Is there a way to rexport a module while hiding one of its functions(that I'm trying to replace)?
16:34:30 <Axman6> module Foo (bar, bax, module ModuleToExport) where import ModuleToExport hiding (foo bar baz)
16:38:28 <MichaelBurge> Axman6: I see. And you can still import ModuleToExport qualified if you need to use its copy of bar. Thanks
16:41:15 <Axman6> yep
16:47:35 * hackagebot prometheus 0.2.0 - Prometheus Haskell Client  https://hackage.haskell.org/package/prometheus-0.2.0 (LukeHoersten)
16:47:53 <antique> If function application has the highest precedence, why is $ in an expression like sum $ [1,2,3] not interpreted as the first argument to sum?
16:50:28 <mniip> antique, it's an operator
16:51:01 <kadoban> antique: Because operators like that can't be function arguments; it couldn't be parsed like that.  f ($) [1,2,3] -- could be though
16:51:02 <mniip> it's a different syntax.. uh.. pattern
16:53:03 <antique> So operators are handled differently?
16:53:22 <hexagoxel> looking at what is/is not an operator/symbol comes before any precedence considerations.
16:54:18 <antique> I see, that makes sense, thank you.
16:57:02 <mniip> antique, that's a bit like asking why a^{b*c} doesn't do a^b first and *c last
16:57:10 <mniip> it's syntactially differeny
16:57:12 <mniip> different
16:57:33 <hpc> in particular, it's different in the way that there doesn't exist an (a ^ b) to begin with
16:57:38 <mniip> yup
16:57:49 <hexagoxel> it probably even is lexically different.
16:58:11 <mniip> a b c + d * e f  -->  (a b c) + (d) * (e f)
16:58:13 <mniip> no matter what
16:59:10 <hexagoxel> while precedence is a rather late step in the parser, given that the user can define operator precedences.
17:03:30 <hexagoxel> (you can't just use an example that makes us of these convenient {} and then omit them. the problem is exactly about the implicit {}'s of haskell..)
17:04:15 <c_wraith> dmj`, pong
17:04:58 <hexagoxel> different q: how stable are `StableName`s on functions?
17:05:50 <c_wraith> hexagoxel, as much as they are for any other expression. 
17:06:45 <hexagoxel> c_wraith: but there is the `evaluation can make things unequal` caveat. that does not exist for functions, right?
17:07:28 <c_wraith> hexagoxel, I don't see why that'd be true. function expressions can be evaluated. 
17:08:14 <c_wraith> hexagoxel, particularly with full laziness
17:11:23 <hexagoxel> c_wraith: ah indeed, thanks.
17:28:43 <ertes> comment from a colleague: "oh, that's haskell?  that's pretty beautiful code!"
17:31:03 <ertes> (about a quick-n-dirty program to preprocess a CSV file for import)
17:35:09 <icicled> thanks earlier for helping me to sort out my TVar issues - this is the end result: https://github.com/joncfoo/todobackend-servant
18:10:20 <athan> Why is the `Cabal` library a dependency of the `Cabal` package? :S
18:11:27 <athan> http://lpaste.net/155837
18:12:04 <athan> extra wonky, hold the mayo
18:15:18 <geekosaur> that sounds wrong.
18:15:44 <geekosaur> granted, it's a case of self-hosting, but ghc(js) should come with a Cabal that it can bootstrap without using the normal Cabal mechanism
18:16:05 <geekosaur> unfortunately, this appears to be using cabal-install, which requires a Cabal library
18:16:38 <geekosaur> are you sure there is not some other way specified to install a boostrap Cabal library fpr ghcjs? 
18:18:19 <athan> geekosaur: I must have screwed it up - I built ghcjs-boot with stack, maybe that's my issue
18:18:39 <geekosaur> oh, that would probably require you to do something special to get at it, then
18:19:03 <geekosaur> eg.stack exec -- cabal ...
18:19:12 <athan> ahhh that makes sense
18:28:55 <MichaelBurge> What's a good way to lift an EitherT e IO x into an EitherT e (SomeTransformerT IO) x?
18:36:45 <icicled> I don't think there is a generic way to do that
18:37:39 <icicled> IIRC you'll have to write the lift code for between each transformer
18:39:01 <icicled> e.g. https://github.com/themoritz/diener/blob/master/src/Diener.hs
18:39:01 <MichaelBurge> icicled: Thanks for the response. I guess I'll just unwrap it like you suggest.
18:42:40 * hackagebot pandoc 1.17.0.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.17.0.1 (JohnMacFarlane)
18:52:06 <ertes> MichaelBurge: most transformers provide a 'hoist' operation
18:52:41 <ertes> hoist :: (forall a. f a -> g a) -> T f a -> T g a
18:53:30 <ertes> sometimes it's called 'map', like 'mapEitherT', but the more modern name is 'hoist'
19:00:54 <MichaelBurge> ertes: Thanks for the information.
19:14:59 <Herby_> Evening, everyone!
19:15:15 <sm> evening Herby_ 
19:15:47 <castlelore> hello how come gpipe is so slow is there anything that can be done about this?
19:30:34 <belph> Hi, I'm learning Haskell through the book "Haskell Road to Logic, Math and Programming". What do you think about this book? Is it great to start learning the language?(considering I have some background with functional programming)
19:57:44 * hackagebot mbox 0.3.3 - Read and write standard mailbox files.  https://hackage.haskell.org/package/mbox-0.3.3 (GershomBazerman)
20:06:10 <ski> belph : hm, haven't read it, unfortunately
20:07:34 <ski> there are probably others in the channel who have read it (can't recall names), but i suspect they're asleep atm
20:09:41 <shachaf> I read some of it. I don't think it's particularly helpful as an introduction to Haskell.
20:10:07 <shachaf> Maybe it's a good introduction to logic, maths and programming.
20:10:23 <shachaf> I liked Hutton's book, _Programming in Haskell_, as an introduction.
20:10:36 <shachaf> The specifics are a bit outdated now, though.
20:10:47 <shachaf> Oh, belph is gone.
20:12:31 <sand_bird> how is 'Learn You a Haskell?'
20:16:22 <clintm> Is there a way to express something akin to "FromJSON a => data Tx = Tx { tx_data :: a }"?  Probably sounds crazy.  The problem I'm trying to solve is that CouchDB gives view (query) results as json in the form of {row_info:X, rows: [ what I care about that's FromJSON-able]}.
20:18:40 <clintm> I'd also like to make it generalized enough that I can write general queries and use type inference, rather than hardcoding a view fetch for every type i might want to fetch.
20:36:19 <ski> clintm : `data Tx = forall a. FromJSON a => Tx { tx_data :: a }' ?
20:37:23 <clintm> I didn't know I could do that. heh.  Thank you!  Sounds like I need to get the haskell book.
20:37:45 <ski> clintm : this would be an "existential data type" (conceptually, it's really the argument type of the data constructor that is existential : `Tx :: (exists a. FromJson a *> { tx_data :: a }) -> Tx')
20:37:58 <ski> whether this is what you want here, i don't know
20:38:05 <tippenein> sand_bird: #haskell-beginners would have a lot of input on that question. IMO LYAHFGG is only useful for syntax and a giggle
20:38:33 <clintm> ski: I will try it and find out.  Thanks again!
20:39:51 <ski> clintm : for the suggested `Tx'. you can plug a value of any type `a' into such a `Tx' type, provided only `a' is in `FromJSON' .. so the data constructor is polymorphic : `Tx :: forall a. FromJSON a => { tx_data :: a } -> Tx' (which happens to be conceptually the same as the other signature i gave above)
20:40:19 <ski> clintm : since `a' isn't mentioned in the result type of the data constructor, the effect of it is to *hide* the type `a'
20:41:01 <ski> clintm : and because of this, given a value of type `Tx', you have no way of knowing *which* type `a' was used when constructing it, so when you unpack you only know that that type `a' is in `FromJSON'
20:41:13 <ski> clintm : if that sounds like it fits the bill, go ahead
20:44:29 <c_wraith> few of the best uses of existentials involve quantification over a class. 
20:45:18 <clintm> ski: I think so.  I want to parse an 'a' that has a FromJSON instance, which will contain another 'a' who's type I don't know - only that it has an instance of FromJSON.  The idea was to provide a generalized function, say 'get_view' that returns a 'ViewResult' (Tx, above), the rows of which have an instance of FomJSON. So then I could say "get_view x y z :: IO TypeImExpectingInRows".
20:45:32 <clintm> This seems like it would work.  I'm going to experiment with it here in just a sec.
20:46:31 <c_wraith> I'm skeptical. the FromJSON class is the directions on how to parse the data. 
20:46:46 <c_wraith> if it doesn't know the right type, it can't parse it. 
20:47:11 <hnordt> hello!
20:47:17 <hnordt> any bash experts here?
20:47:27 <c_wraith> I'd just store the data of unknown structure as an aeson Value 
20:49:59 <markan> @pl \n -> n == abs n
20:50:04 <lambdabot> ap (==) abs
20:50:08 <c_wraith> and then use fromJSON when I had a concrete type to convert to. 
20:50:49 <c_wraith> markan, I'd write that as (>= 0)
20:51:22 <Xnuk> :t abs
20:51:37 <lambdabot> Num a => a -> a
20:55:46 <ski> c_wraith : hm, i suppose `FromJSON' doesn't have `Typeable' as a superclass ?
20:55:56 <c_wraith> it does not
20:56:08 <ski> clintm : see what c_wraith said above
20:56:57 <markan> c_wraith: yes, I know, I was simplifying a different function
20:57:47 * hackagebot dixi 0.6.9.0 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.6.9.0 (LiamOConnorDavis)
21:00:13 <clintm> ski / c_wraith - yep, that's a much better approach.  Thank you!
21:02:17 <markan> anyone know where I could get something like @pl without having to bother the irc everytime I use it?
21:02:39 <shachaf> @hackage pointfree
21:02:39 <lambdabot> http://hackage.haskell.org/package/pointfree
21:02:55 <markan> thanks
21:24:19 <Gurkenglas> markan, /query lambdabot
21:52:49 * hackagebot kdt 0.2.4 - Fast and flexible k-d trees for various types of point queries.  https://hackage.haskell.org/package/kdt-0.2.4 (giogadi)
22:16:12 <Gurkenglas> *reads http://docs.idris-lang.org/en/latest/tutorial/introduction.html * *reads http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf * Hmmmm. Someone plagiarized someone.
22:17:25 <Gurkenglas> "The goal of the Idris project is to build a dependently typed language suitable for verifiable systems programming." What's the goal of the Agda project?
22:21:51 <Gurkenglas> (Oh, those have their own channels. Nevermind then)
22:31:16 <jle`> i hear that ther's a lot of overlap on the purpose of Agda and Idris, but Idris tends to be the more practical real-world programming as they got applied in practice
22:33:13 <jle`> most agda i see is for proof assistance and most idris i see is for application-oriented goals, but that could just be a coincidence from my limited sample size
22:33:54 <jle`> this could be more of a reflection of the culture of the community than of the intended purpose of the language
22:41:04 <EvanR> jle`: i get the feel idris programs would replace C programs rather than ... uh whatever applications are written in
22:42:08 <EvanR> haskell programs
22:42:50 <EvanR> ah thats what gurkenglas was saying
23:10:42 <cocreature> edwin brady also said in the type theory podcast that agda simply did not exist when he started writing idris
23:11:27 <EvanR> heh
23:11:37 <EvanR> did not know that
23:11:53 <Horv> How old is Idris?
23:13:55 <moxotter> Hoax
23:14:19 <cocreature> ftr this is the episode I was talking about http://typetheorypodcast.com/2014/09/episode-2-edwin-brady-on-idris/
23:14:40 <ent> there's a type theory podcast :o
23:14:53 <cocreature> yeah sadly it has very few episodes
23:16:18 <ent> i guess it's not the easiest topic for podcasts
23:18:11 <cocreature> I quite enjoy listening to it although some of it is over my head
23:20:35 <moxotter> Podcasts still exist?
23:20:49 <ent> sure
23:20:57 <ent> http://www.haskellcast.com/ is also nice
23:23:03 <toph> is there a hayoo mirror?
23:23:55 <cocreature> toph: afaik no, you’ll have to use hoogle
23:27:16 <liste> &away
