00:53:27 <ij> Can stack.yaml do darcs?
00:55:32 <rekado> does anyone know if hugs could be used to bootstrap any version of GHC after 4.08.x?
00:56:13 <ij> Ok, I found docs about it, never mind!
01:00:17 <nullzero> hello there
01:00:49 <nullzero> no one care
01:24:34 * av_ needs installation advice
01:24:52 <av_> Hi guys, I'm trying to figure out how to install ivory
01:25:38 <av_> ivory 0.1.0.0 depends on base-4.6.*, which is what shipped with ghc 7.6, but that's not available from my distro
01:25:52 <av_> so I played with stack, but that won't go below ghc 7.8 either
01:27:01 <av_> so what can I do to use ivory?  or is getting started with ivory a bad idea because it requires old software that is (relatively) hard to install?
01:28:31 <Myrl-saki> I need something like Sequence.
01:28:33 <Myrl-saki> sequence*
01:28:39 <Myrl-saki> Which returns Nothing if everything is Nothing.
01:28:41 <jle`> av_: that's kind of a shame, ivory seemed like a nice project
01:28:54 <Myrl-saki> Actually, this is stupid.
01:29:19 <jle`> Myrl-saki: asum ?
01:29:38 <jle`> > asum [Nothing, Just 10, Just 3, Nothing]
01:29:40 <lambdabot>  Just 10
01:29:44 <jle`> > asum [Nothing, Nothing, Nothing, Nothing]
01:29:47 <lambdabot>  Nothing
01:30:26 <Myrl-saki> jle`: TIL, asum. But nope.
01:30:27 <Myrl-saki> :t asum
01:30:30 <jle`> or foldMap (:[])
01:30:31 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
01:30:37 <Myrl-saki> asum looks nice.
01:30:41 <jle`> > foldMap (:[]) [Nothing, Just 10, Just 3, Nothing]
01:30:44 <lambdabot>  [Nothing,Just 10,Just 3,Nothing]
01:30:46 <jle`> oops
01:30:53 <jle`> > foldMap (fmap (:[])) [Nothing, Just 10, Just 3, Nothing]
01:30:55 <lambdabot>  Just [10,3]
01:31:06 <jle`> > foldMap (fmap (:[])) [Nothing, Nothing, Nothing, Nothing]
01:31:08 <lambdabot>  Nothing
01:31:09 <cocreature> av_: it looks like ivory is alive there just hasn’t been a release for some time, you might want to try building the master branch https://github.com/GaloisInc/ivory
01:31:13 <Myrl-saki> lambdabot: Yep, that.
01:31:16 <cocreature> looks like it is even 8.0 ready
01:31:21 <Myrl-saki> jle`: *
01:31:24 <Myrl-saki> jle`: Looks nice.
01:32:21 <av_> cocreature: thanks, I might try that
01:32:23 <jle`> tell that to the people who think Maybe's default Monoid instance should be different :O
01:32:44 <jle`> #teamsemigroupembedder
01:33:11 <Myrl-saki> jle`: What do people think is better?
01:33:17 <Myrl-saki> jle`: Just (mempty)?
01:33:26 <Myrl-saki> (Sweet jesus, no.)
01:33:43 <jle`> that the default instance should be the same as the First instance
01:33:49 <jle`> aka <|>
01:34:07 <Myrl-saki> jle`: Wait, what's a default instance?
01:34:28 <jle`> the instance you get when you just use Monoid methods on naked Maybe values
01:34:35 <jle`> > Just "hello" <> Just "world"
01:34:35 <av_> cocreature: it seems the github version now proclaims 7.8 and 7.10 compatibility and recommends using stack -- not sure why the cabal package hasn't been updated
01:34:37 <lambdabot>  Just "helloworld"
01:34:39 <jle`> > Just "hello" <> Nothing
01:34:41 <lambdabot>  Just "hello"
01:34:55 <Myrl-saki> :T (<>)
01:34:57 <Myrl-saki> :t (<>)
01:34:59 <lambdabot> Monoid m => m -> m -> m
01:35:03 <Myrl-saki> Is <> mappend?
01:35:05 <jle`> that's mappend from the Monoid typeclass
01:35:07 <jle`> yes
01:35:13 <jle`> it's what gets called when you use foldMap
01:35:23 <Myrl-saki> :t Just 1 <> Just 2
01:35:25 <lambdabot> (Num a, Monoid a) => Maybe a
01:35:31 <Myrl-saki> > Just 1 <> Just 2
01:35:34 <lambdabot>      No instance for (Show a0)
01:35:34 <lambdabot>        arising from a use of ‘show_M27883527877521717922634’
01:35:34 <lambdabot>      The type variable ‘a0’ is ambiguous
01:35:39 <Myrl-saki> I see...
01:35:43 <Myrl-saki> :t (<|>)
01:35:45 <lambdabot> Alternative f => f a -> f a -> f a
01:35:48 <jle`> too bad Int/Integers/most number types aren't Monoids
01:35:58 <Myrl-saki> Just "A" <|> Just "a"
01:36:05 <Myrl-saki> > Just "A" <|> Just "a"
01:36:07 <lambdabot>  Just "A"
01:36:12 <Myrl-saki> jle`: Oh, I see what you mean now.
01:36:18 <jle`> > First (Just "A") <> First (Just "a")
01:36:19 <Myrl-saki> jle`: I actually didn't know this before.
01:36:20 <lambdabot>  First {getFirst = Just "A"}
01:36:48 <Myrl-saki> :t First "a"
01:36:50 <lambdabot>     Couldn't match expected type ‘Maybe a’ with actual type ‘[Char]’
01:36:50 <lambdabot>     In the first argument of ‘First’, namely ‘"a"’
01:36:50 <lambdabot>     In the expression: First "a"
01:36:55 <Myrl-saki> Ehhhh
01:36:57 <jle`> you can get different monoid instances by using newtype wrappers
01:37:04 <jle`> :t First (Just "a")
01:37:05 <lambdabot> First [Char]
01:37:09 <Myrl-saki> Wtf?
01:37:21 <Myrl-saki> jle`: What is First's definition?
01:37:24 <jle`> the point is that `First (Just "a")` is identical to (Just "a") for all intents and purposes
01:37:29 <jle`> data First a = First (Maybe a)
01:37:36 <jle`> er, newtype First a = First (Maybe a)
01:37:44 <Myrl-saki> jle`: Oh.
01:37:47 <jle`> except, the difference is that they have different Monoid instances, so different behavior with <>
01:37:57 <Myrl-saki> jle`: Right.
01:38:02 <jle`> it's the same deal for Sum and Product, Any and All
01:38:07 <jle`> > Sum 1 <> Sum 3
01:38:09 <lambdabot>  Sum {getSum = 4}
01:38:11 <jle`> > Product 1 <> Product 3
01:38:11 <Myrl-saki> jle`: I actually thought that Just x <> Just y is Just x.
01:38:13 <lambdabot>  Product {getProduct = 3}
01:38:15 <Myrl-saki> Not Just (x <> y)
01:38:17 <Myrl-saki> jle`: <.<
01:38:28 <jle`> ah yeah, that's the default naked instance
01:38:37 <jle`> that's why foldMap did what it did earlier
01:38:45 <Myrl-saki> jle`: Yeah, that's why I was so confussed. :P
01:38:51 <Akii> ski: forgot all about FSM, this is just an FSM :D thank you again for your time yesterday!
01:39:13 <Myrl-saki> Akii: Flying Spaghetti Monster? :P
01:39:22 <Akii> worse: finite state machine
01:39:28 <Myrl-saki> Akii: Gahahaha.
01:41:11 <Myrl-saki> Hmmm....
01:41:26 <av_> łquit
01:41:39 <Myrl-saki> foo f g x y = f (g x) (g y)
01:41:52 <Myrl-saki> :t liftA2
01:41:53 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:42:07 <John[Lisbeth]> http://sprunge.us/FUJb
01:42:52 <jle`> Myrl-saki: you want 'on'
01:42:54 <jle`> :t on
01:42:56 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:43:13 <Myrl-saki> jle`: Ohhh right.
01:43:14 <Myrl-saki> jle`: Thanks.
01:43:32 <John[Lisbeth]> Compile error on 5:49 "="
01:43:51 <jle`> np
01:44:03 <jle`> (->)'s Applicative and Monad instances are all about applying the same value to different functions
01:44:11 <jle`> 'on' is about applying the same function to different values
01:46:14 <mniip> [11:43] (jle`) (->)'s Applicative and Monad instances are all about applying the same value to different functions
01:46:20 <mniip> flip id much?
01:46:58 <jle`> hm?
01:47:38 <shanemikel> why is cabal always complaining that reinstalls are dangerous?
01:48:37 <mniip> :t \g -> join $ (.) . (. g) . flip (.)
01:48:39 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:48:58 <mniip> functions are arguments anyway
01:49:00 <jle`> :P
01:49:06 <jle`> yes
01:51:10 <Myrl-saki> ...
01:51:16 <Myrl-saki> mniip: What. The. Fuck.
01:51:26 <Myrl-saki> @pl on
01:51:26 <lambdabot> on
01:51:28 <shanemikel> mniip: please don't put that in a real program
01:51:29 <Myrl-saki> ...
01:51:37 <Myrl-saki> @pl f g x y -> f (g x) (g y)
01:51:37 <lambdabot> (line 1, column 11):
01:51:37 <lambdabot> unexpected '>'
01:51:37 <lambdabot> expecting operator
01:51:44 <Myrl-saki> @pl \f g x y -> f (g x) (g y)
01:51:45 <lambdabot> join . ((flip . ((.) .)) .) . (.)
01:51:53 <Myrl-saki> Even better?
01:52:26 <shanemikel> what's this @pl thing you're doing?
01:52:33 <shanemikel> @pl \f x -> f x
01:52:34 <lambdabot> id
01:52:47 <shanemikel> @pl \f g x -> g x
01:52:47 <lambdabot> const id
01:53:05 <shanemikel> @pl \f g x -> g (g x)
01:53:05 <lambdabot> const (join (.))
01:53:16 <Myrl-saki> shanemikel: Converts it to point-free.
01:53:25 * hackagebot aivika 4.3.3 - A multi-paradigm simulation library  https://hackage.haskell.org/package/aivika-4.3.3 (DavidSorokin)
01:53:27 <Myrl-saki> @pl f (g (h x))
01:53:27 <lambdabot> f (g (h x))
01:53:27 * hackagebot aivika-transformers 4.3.3 - Transformers for the Aivika simulation library  https://hackage.haskell.org/package/aivika-transformers-4.3.3 (DavidSorokin)
01:53:32 <Myrl-saki> ....?
01:53:40 <Myrl-saki> @pl \x -> f (g (h x))
01:53:40 <lambdabot> f . g . h
01:53:50 <Myrl-saki> Kawaii desu ne?
01:54:01 <mniip> Myrl-saki, I can do pl in my head
01:54:31 <Myrl-saki> mniip: It's not that hard.
01:54:44 <mniip> sure
01:55:22 <shanemikel> I can't read that first one
01:55:30 <Myrl-saki> shanemikel: Which one?
01:55:41 <shanemikel> @pl \g -> join $ (.) . (. g) . flip (.)
01:55:41 <lambdabot> join . ((.) .) . (. flip (.)) . flip (.)
01:56:14 <shanemikel> :t it
01:56:16 <lambdabot>     Not in scope: ‘it’
01:56:16 <lambdabot>     Perhaps you meant one of these:
01:56:16 <lambdabot>       ‘id’ (imported from Data.Function),
01:56:30 <mniip> \g -> join $ \f f' x y -> g (f x) (f' y)
01:56:44 <mniip> \g -> join $ \f f' x -> g (f x) . f'
01:56:57 <shanemikel> wait
01:56:59 <shanemikel> :t join
01:57:00 <lambdabot> Monad m => m (m a) -> m a
01:57:12 <mniip> \g -> join $ \f f'-> (. f') . g . f
01:57:42 <mniip> \g -> join $ \f'-> ((. f') . g .)
01:57:52 <mniip> \g -> join $ (.) . (. g) . flip (.)
01:58:53 <mniip> join . ((.) .) . (. flip (.)) . flip (.)
01:59:07 <jle`> shanemikel: not sure why you would expect pl to make something *more* readable :p
01:59:22 <jle`> usually people do it to go the other way
01:59:27 <jle`> (make it less readable)
01:59:53 <jle`> @unpl \g -> join $ (.) . (. g) . flip (.)
01:59:53 <lambdabot> \ g d -> (\ r b c k -> g (b c) (r k)) d d
01:59:56 <shanemikel> somebody help me understand about cabal complaining about "dangerous" reinstalls?
02:00:14 <shanemikel> is that something I'm doing wrong, or is it just political
02:00:31 <jle`> i think cabal calls all reinstalls dangerous, because they usually are
02:00:35 <quchen> shanemikel: When packages depend on packages that you reinstall, those depending packages might break.
02:00:43 <quchen> It's technical, not political.
02:00:46 <jle`> any reason why you have to use cabal directly instead of stack?
02:00:54 <shanemikel> yeah, okay.. but that's obvious.. so it's political then
02:01:15 <purelazy> In ghci, who does one defined a type *and* function? like a :: [a] -> [a]; a list = reverse list
02:01:20 <purelazy> who=how
02:01:28 <quchen> No, it's not obvious. And being obvious does not make something political anyway.
02:01:29 <jle`> purelazy: you need to use 'let' syntax to do that in ghci
02:01:31 <shanemikel> but it doesn't make a difference in a sandbox, right? 
02:01:40 <mniip> just like that
02:01:44 <Myrl-saki> :t foldMap
02:01:46 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
02:01:47 <jle`> it does make a difference in the sandbox, and it can corrupt your sandbox
02:01:52 <Myrl-saki> Mmm....
02:01:57 <jle`> but at least it only corrupts your sandbox, not the global environment
02:02:03 <purelazy> > let fun :: [a] -> [a]
02:02:06 <lambdabot>  <no location info>: not an expression: ‘let fun :: [a] -> [a]’
02:02:10 <shanemikel> quchen: political, like to keep non-devs using cabal as a package manager (for regular use) from getting frustrated
02:02:14 <jle`> purelazy: > evaluates functions
02:02:16 <Myrl-saki> :t (:[])
02:02:17 <lambdabot> a -> [a]
02:02:19 <jle`> er, values
02:02:28 <jle`>  > evaluates expressions
02:02:30 <Myrl-saki> Oh.
02:02:39 <purelazy> > fun :: [a] -> [a]
02:02:41 <lambdabot>      Couldn't match type ‘a1’ with ‘Char’
02:02:41 <lambdabot>        ‘a1’ is a rigid type variable bound by
02:02:41 <lambdabot>             an expression type signature: [a1] -> [a1] at <interactive>:1:1
02:02:48 <jle`> fun :: [a] -> [a] is not an expression
02:02:54 <quchen> I don't think documentation is political per se.
02:02:55 <jle`> or well, it is, if fun is defined
02:02:57 <jle`> i should sleep v.v
02:03:04 <Myrl-saki> OHHH
02:03:08 <shanemikel> jle`: but not if I'm reinstalling the application, only dependencies
02:03:18 <Myrl-saki> Wait.
02:03:21 <Myrl-saki> foldMap is not concatMap.
02:03:24 <Myrl-saki> :t concatMap
02:03:26 <shanemikel> and if I do reinstall a dep, how can I do a non-dangerous rebuild.. or force rebuild + reinstall
02:03:26 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
02:03:30 <shanemikel> ?
02:03:34 <Myrl-saki> WTF is foldMap then
02:03:44 <jle`> Myrl-saki: map + fold
02:03:53 <quchen> foldMap f = fold . fmap f
02:03:54 <Myrl-saki> jle`: In which order?
02:04:00 <jle`> foldMap f xs = fold (fmap f xs)
02:04:04 <Myrl-saki> Oh.
02:04:05 <Myrl-saki> :t fold
02:04:07 <lambdabot> (Foldable t, Monoid m) => t m -> m
02:04:07 <jle`> the only order that would typecheck, heh
02:04:19 <purelazy> jle` I would like to provide a type definition with the function definition
02:04:21 <quchen> … given your data structure is also a Functor, of course
02:04:21 <Myrl-saki> Hmmm
02:04:30 <Myrl-saki> fold Just "a"
02:04:36 <jle`> purelazy: you can define things in ghci with 'let'
02:04:36 <Myrl-saki> > fold $ Just "a"
02:04:38 <lambdabot>  "a"
02:04:41 <purelazy> I know how to define functions with let
02:04:41 <Myrl-saki> > fold $ Just "ab"
02:04:43 <lambdabot>  "ab"
02:04:45 <jle`> purelazy: like, 'let foo x = 10'
02:04:48 <Myrl-saki> Meh.
02:04:55 <jle`> and you can annotate them like 'let foo :: Int -> Int; foo x = 10'
02:05:04 <Myrl-saki> :t fold
02:05:06 <lambdabot> (Foldable t, Monoid m) => t m -> m
02:05:10 <jle`> Myrl-saki: fold just <>'s all of the items together
02:05:23 <Myrl-saki> jle`: Oh...
02:05:35 <jle`> quchen: yeah, i guess to be safe, foldMap f = fold . map f . toList
02:05:45 <quchen> For lists, mconcat = fold.
02:05:59 <jle`> Myrl-saki: fold [x,y,z] = x <> y <> z
02:06:05 <quchen> jle`: Good point.
02:06:11 <Myrl-saki> This is what I was confused with.
02:06:20 <Myrl-saki> now I remember.
02:06:42 <purelazy> jle`; Thanks. I never did type def and fun def on one line like that before
02:06:44 <jle`> foldMap f [x,y,z] = f x <> f y <> f z
02:06:51 <Myrl-saki> fold [Just 1, Just 2]
02:06:56 <Myrl-saki> > fold [Just 1, Just 2]
02:06:58 <lambdabot>      No instance for (Show a0)
02:06:58 <lambdabot>        arising from a use of ‘show_M5843067795697237103326’
02:06:58 <lambdabot>      The type variable ‘a0’ is ambiguous
02:07:01 <jle`> no Monoid instance for (Just 1)
02:07:01 <Myrl-saki> Hmmm
02:07:03 <Myrl-saki> :t fold
02:07:04 <lambdabot> (Foldable t, Monoid m) => t m -> m
02:07:08 <Myrl-saki> jle`: Oh, right.
02:07:24 <Myrl-saki> Thanks, I remember now.
02:07:41 <quchen> > fold ["hello", "world"]
02:07:43 <lambdabot>  "helloworld"
02:08:06 <quchen> > foldMap show [Just 1, Just 2]
02:08:08 <lambdabot>  "Just 1Just 2"
02:08:22 <jle`> i meant to say "no Monoid instance for Maybe Int"
02:08:31 <Myrl-saki> jle`: Hmmm
02:08:36 <jle`> > fold [Just "hello", Nothing, Just "world"]
02:08:38 <lambdabot>  Just "helloworld"
02:08:41 <quchen> > foldMap (\x -> show x ++ ", ") [Just 1, Just 2]
02:08:43 <lambdabot>  "Just 1, Just 2, "
02:08:45 <Myrl-saki> > [Nothing] <> [Nothing]
02:08:46 <lambdabot>  [Nothing,Nothing]
02:08:52 <jle`> <> for lists is ++
02:08:53 <Myrl-saki> > fold [Nothing] <> [Nothing]
02:08:55 <lambdabot>      Couldn't match expected type ‘Maybe a’
02:08:55 <lambdabot>                  with actual type ‘[Maybe a0]’
02:08:55 <lambdabot>      In the second argument of ‘(<>)’, namely ‘[Nothing]’
02:09:01 <Myrl-saki> > fold $ [Nothing] <> [Nothing]
02:09:03 <lambdabot>  Nothing
02:09:41 <Myrl-saki> Oh okay...
02:09:43 <jle`> might be easier to see as `fold [Nothing, Nothing]
02:10:00 <Myrl-saki> Gahahaha, this is insane.
02:10:03 <jle`> [Nothing] <> [Nothing] = [Nothing] ++ [Nothing] = [Nothing, Nothing]
02:10:11 <jle`> you might be confusing <> for Maybe vs. <> for lists
02:10:28 <Myrl-saki> jle`: Yeah, I was confused with what you did.
02:10:34 <Myrl-saki> jle`: But I get it now.
02:10:58 <Myrl-saki> jle`: I didn't actually think of using it that way.
02:11:13 <jle`> it's interesting that Nothing <> Nothing works here
02:11:27 <Myrl-saki> jle`: [Just x] -> [Just [x]]
02:11:29 <jle`> it's because it picks the Nothing to be `Maybe ()`
02:11:31 <Myrl-saki> jle`: [Just x] -> [Just [x]] -> Just [x]
02:11:37 <Myrl-saki> I didn't think of doing it that way.
02:11:44 <Myrl-saki> -> here is from what type to what type.
02:12:11 <Myrl-saki> jle`: That was pretty genius.
02:12:24 <Myrl-saki> jle`: I'm talking about your `foldMap (fmap (:[]))`
02:12:47 <jle`> well, i just wanted to use 'fold' to accumulate everything, and so you can turn it into [a]'s so that fold would accumulate them, because of maybe's Monoid instance
02:18:26 * hackagebot wai-extra 3.0.15 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.15 (MichaelSnoyman)
02:36:17 <echo-area> mniip: How do you go from `\ f f' -> (. f') . g . f` to `\ f' -> (((. f') . g) .)`?  (You wrote `\ f' -> ((. f') . g .)` though, which could not compile)
02:37:12 <echo-area> Is f' in the second form supposed to be f in the first form?
02:37:30 <echo-area> renaming, I mean
02:38:04 <joco42> > "\n" ++  unlines $ map ("bla" ++ )  ["1","2"]
02:38:06 <lambdabot>      Couldn't match expected type ‘[[Char]] -> t’
02:38:06 <lambdabot>                  with actual type ‘[Char]’
02:38:06 <lambdabot>      The first argument of ($) takes one argument,
02:38:15 <mniip> echo-area, I swapped f and f' yes
02:38:19 <joco42> why is this a problem ?
02:38:19 <mniip> echo-area, I swapped f and f' yes
02:38:28 <mniip> since they're the same value
02:38:36 <joco42> > "\n" ++  (unlines $ map ("bla" ++ )  ["1","2"])
02:38:38 <lambdabot>  "\nbla1\nbla2\n"
02:38:45 <joco42> why is this difference ?
02:38:51 <joco42> why do i need the parenthesis ?
02:38:57 <echo-area> mniip: Okay, I see, thanks
02:39:25 <joco42> i though that unlines binds stronger than ++
02:40:24 <quicksilver> unlines has nothing to bind to
02:40:27 <quicksilver> unlines has no parameters
02:40:34 <quicksilver> it is the binding of $ that is the question
02:40:43 <quicksilver> (and ++ binds tighter than $ indeed)
02:40:46 <joco42> ahh
02:40:59 <joco42> > "\n" ++  unlines ( map ("bla" ++ )  ["1","2"])
02:41:01 <lambdabot>  "\nbla1\nbla2\n"
02:41:04 <joco42> right
02:41:35 <joco42> so i would need a $ that would bind tighter than ++ right ?
02:41:45 <joco42> to get rid of the parenthesis
02:43:30 <pyrtsa> joco42: I'd rather just use parentheses like you did.
02:43:44 <Jinxit> > (++) "\n" $ unlines $ map ("bla" ++) ["1", "2"]
02:43:46 <lambdabot>  "\nbla1\nbla2\n"
02:43:47 <Jinxit> :^)
02:43:49 <Jinxit> (don't)
02:43:49 <joco42> hmm, yeah, but you are used to them :) 
02:44:06 <joco42> thanks Jinxit 
02:44:29 <pyrtsa> Haha, was in the middle of writing what Jinxit did. Tongue in cheek.
02:45:30 <pyrtsa> joco42: Just try not to use $ where it interferes with operators. For everyone's sanity.
02:46:37 <joco42> yeah, but i am afraid that Haskell becomes Lisp....
02:48:05 <joco42> btw, is there some nice color coding for parenthesis for emacs or something ?
02:49:33 <lieven> lispers use paredit. no idea how well it works for haskell
02:49:57 <joco42> > ("BEFORE" ++) $  unlines ( map ("bla" ++ )  ["1","2"])
02:49:59 <lambdabot>  "BEFOREbla1\nbla2\n"
02:50:20 <joco42> > (++ "after") $  unlines ( map ("bla" ++ )  ["1","2"])
02:50:22 <lambdabot>  "bla1\nbla2\nafter"
02:50:31 <joco42> how can ++ do that ?
02:50:45 <pyrtsa> joco42: Every operator can.
02:51:07 <pyrtsa> Those are operator sections.
02:51:17 <joco42> yeah
02:51:19 <pyrtsa> https://wiki.haskell.org/Section_of_an_infix_operator
02:51:33 <joco42> but what is interesting is that it is aware which argument is missing
02:51:49 <pyrtsa> It depends on which side the provided argument is.
02:51:52 <joco42> ok
02:51:55 <joco42> it has a flip
02:52:04 <joco42> so it is syntax sugar for a flip
02:52:10 <pyrtsa> Kinda.
02:52:30 <joco42> "(^2) (right section) is equivalent to flip (^) 2, "
02:52:38 <quicksilver> lieven: I have used paredit for haskell. I mostly find it useful if editing nested data structures (lists of tuples, say)
02:53:00 <joco42> i have a look at paredit
02:54:08 <quicksilver> ("\n"++) . unlines . map ("blah"++) $ ["1","2"]
02:54:30 <quicksilver> is probably how I'd write it
02:54:31 <joco42> that is even less parens
02:54:57 <pyrtsa> Sometimes, just sometimes, it also makes sense to give names to intermediate expressions using `let` or `where`. Just saying.
02:55:32 <joco42> the less parens, the better,  on my eyes...
02:55:45 <pyrtsa> ^ It also avoids parens.
02:56:07 <joco42> thanks for that tip, quicksilver , i think i start to use that style...
02:57:30 <joco42> pyrtsa:  yeah, let and where... are my good friends too
02:58:26 <pyrtsa> > (`flip` 10) (-) 30   -- :^)
02:58:29 <lambdabot>  20
02:59:02 <joco42> oh my
02:59:27 <joco42> the dot is missing from that on
02:59:28 <joco42> e
02:59:31 <joco42> :)
03:25:00 <echo-area> joco42: https://www.emacswiki.org/emacs/RainbowDelimiters  I find rainbow delimiters is good for coloring parentheses
03:27:36 <joco42> thanks for the tip echo-area 
03:55:40 <quicksilver> wow emacs wiki changed its theme
03:56:48 <oherrala> neat
04:13:08 <a3gis> Hello! I am having the following error when starting ghc: <command line>: can't load .so/.DLL for: libiconv.dylib (dlopen(libiconv.dylib, 5): image not found)
04:13:25 <a3gis> is there a way to find which cabal package (which I assume is the issue) is causing it?
04:16:36 <Axman6> a3gis: libiconv isn't a cabal package, which OS are you on?
04:16:52 <a3gis> Axman6: I know, but couldn't acabal package be using it? I am on os x
04:17:29 <Axman6> which OS X? which ghc version?
04:20:09 <a3gis> el capitan 10.11.1, ghc 7.10.2
04:20:20 <a3gis> cabal 1.22.0.0
04:20:28 <Axman6> hmm, very odd, since libiconv comes with OS X
04:20:38 <Axman6> what exactly are you trying to do?
04:21:12 <Axman6> and how did you install ghc?
04:23:48 <a3gis> Axman6: i remember messing with libiconv a while back, but I can't quite recall the context
04:23:54 <a3gis> I am just trying to run ghci
04:24:25 <Axman6> how did you install ghc
04:24:26 <a3gis> basically I couldn't cabal install anymore because of a permission issue
04:24:33 <a3gis> so I disable system integrity protection
04:24:39 <Axman6> :\
04:24:40 <a3gis> now I can run cabal install, but I can't run ghc anymore
04:24:53 <a3gis> iirc, http://ghcformacosx.github.io/
04:24:55 <Axman6> any reason you're not using stack?
04:25:04 <a3gis> none
04:25:10 <Axman6> I would recommend that
04:25:55 <a3gis> dyld: Library not loaded: /usr/local/lib/gcc/5/libgcc_s.1.dylib
04:25:56 <a3gis>   Referenced from: /Users/aegis/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/bin/ghc”
04:26:05 <a3gis> I should probably re-install the whole thing
04:26:23 <Axman6> possibly... it all seems extremely broken
04:26:52 <a3gis> alright; thanks for your help! :)
04:27:31 <Axman6> give stack a go, I haven't needed to install ghc myself since starting to use it, but you might still have these issues if the problem is still a broken system
04:38:32 * hackagebot aeson 0.11.1.2 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-0.11.1.2 (AdamBergmark)
04:59:09 <sammij> @djinn [a] -> (a -> State s b) -> State s [b]
04:59:09 <lambdabot> Error: Undefined type []
04:59:50 <sammij> \talk lambdabot 
04:59:59 <quchen>  /msg lambdabot
05:00:08 <quchen> (in most clients)
05:01:49 <sammij> djinn does not know about lists?
05:03:07 <lpaste> sammij pasted “something State monad” at http://lpaste.net/156085
05:03:45 <sammij> I'm actually wondering if I reimplemented some standard functionality from the State monad... http://lpaste.net/156085
05:04:47 <opqdonut> sammij: looks like foldM
05:06:26 <opqdonut> sorry, mapM
05:06:50 <ggVGc> I need to hold a dict of things where entries will be mutated a lot. Is my best bet to just have a HashTable a (MVar b)
05:06:53 <ggVGc> ?
05:07:06 <ggVGc> or is there a hashtable implementation that supports my use case better
05:08:09 <opqdonut> > runState (mapM (\x -> state $ \s -> (x+1,s+x)) [1,2,3]) 0 -- sammij
05:08:11 <lambdabot>  ([2,3,4],6)
05:08:39 <opqdonut> ggVGc: that sounds reasonable
05:09:11 <opqdonut> ggVGc: unless you need to see a consistent "snapshot" of the whole map, in which case MVar (Map a b) is better
05:09:33 <ggVGc> yeah, I don't need that
05:09:34 <ggVGc> thanks
05:09:58 <ggVGc> it's for a game server, and I need to map active game sessions to ID's
05:10:36 <ggVGc> at some later point this will not be a hashtable, but separate threads
05:10:46 <ggVGc> but it's just a prototype for now
05:14:13 <sammij> opqdonut: thanks
05:22:50 <marrrk_> I am trying to move a type into a type alias but it doesn't work. http://lpaste.net/9187289870572191744
05:26:17 <opqdonut> marrrk_: the problem is that a :> b :> c :> d is a :> (b :> (c :> d))
05:26:28 <opqdonut> marrrk_: so you can't extract (b :> c) from there
05:27:20 <opqdonut> marrrk_: but you might be able to package b :> c into an equivalent type X and then do a :> X :> d
05:28:15 <marrrk_> Damn I get some weird smileys out of that
05:28:37 <opqdonut> indeed :)
05:28:54 <opqdonut> marrrk_: or you can try "type LimitAndOffset a = QueryParam "limit" Limit :> QueryParam "offset" Offset :> a"
05:29:00 <opqdonut> marrrk_: and then "type API = PlantPath :> LimitAndOffset :> Get '[JSON] [Plant]
05:29:04 <opqdonut> oops
05:29:13 <opqdonut> I meant "type API = PlantPath :> LimitAndOffset (Get '[JSON] [Plant])"
05:29:21 <opqdonut> but that's not as nice of course
05:29:56 <marrrk_> Hmm.
05:30:10 <opqdonut> marrrk_: or can you reorder those terms? and do query :> query :> path :> get
05:30:22 <marrrk_> I will show you the rest.
05:30:33 <opqdonut> I'm not that familiar with servant to be honest
05:30:58 <marrrk_> http://lpaste.net/3056883350191996928
05:32:02 <marrrk_> Shouldn't the plant path bit already fail already?
05:33:36 <opqdonut> you mean PlantIdPath for example? yeah I think so
05:38:44 <marrrk_> thanks I have to go
05:38:45 <marrrk_> thank you
05:39:01 <opqdonut> well I wasn't much help was I
05:55:14 <ph88> is it possible to run   stack ghci  from the global project even when the shell is in a project directory ?
05:57:48 <MarcelineVQ> I think stack exec ghci does, give it a shot
05:58:47 <ph88> yes works thx MarcelineVQ 
05:58:52 <lpaste> sammij pasted “Is it possible to tie this know?” at http://lpaste.net/156087
05:59:11 <sammij> s/know/knot/
05:59:57 <opqdonut> sammij: just move the stuff from "where" into the "let" and it should work
06:01:43 <sammij> opqdonut: unfortunately that does not work..., because then IIRC gt in mkWeak gs gt is undefined
06:01:58 <sammij> s/undefined/not in scope
06:02:34 <opqdonut> oh right
06:04:31 <mniip> opqdonut, gt (via gts and s') depends on wgt
06:04:33 <mniip> which cannot be
06:05:23 <opqdonut> yeah I guess this needs MonadFix?
06:05:42 <mniip> maybe
06:23:28 <sammij> opqdonut: MonadFix is definitely something in the right direction, but I do not yet quite see how to apply it in this instance
06:38:38 * hackagebot purescript-bridge 0.1.0.0 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.1.0.0 (eskimo)
06:39:54 <lpaste> sammij annotated “Is it possible to tie this know?” with “Is it possible to tie this know? (annotation: found solution)” at http://lpaste.net/156087#a156089
06:40:22 <sammij> opqdonut: thanks, I think I found a solution due to your suggestion
06:40:45 <opqdonut> great
06:42:52 <quchen> sammij: Why MonadFix? I don't see monadic recursion in your solution
06:43:26 <quchen> Oooh.
06:43:29 <quchen> Sneaky. Ignore me.
06:43:32 <opqdonut> quchen: gt -> wgt -> gts -> gt
06:43:36 <opqdonut> yeah
06:43:54 <quchen> Understanding whether or why this terminates is going to be tricky.
06:56:34 <saurabhnanda> hey, does anyone know how to work with rawQuery in Persistent? in the following do block: do { res <- rawQuery "select MAX(request_id) from aria2_logs" } what will be the data type of res?
06:56:49 <EvanR> what is the type of rawQuery
06:57:11 <saurabhnanda> rawQuery :: (MonadResource m, MonadReader env m, HasPersistBackend env SqlBackend) => Text -> [PersistValue] -> Source m [PersistValue]
06:57:17 <EvanR> yowzer
06:57:32 * saurabhnanda HATES monad transformers
06:57:46 * EvanR hates rando typeclass stacks
06:57:47 <saurabhnanda> :t Source
06:57:49 <lambdabot>     Not in scope: data constructor ‘Source’
06:57:49 <lambdabot>     Perhaps you meant variable ‘coerce’ (imported from Control.Lens)
06:58:08 <saurabhnanda> :t Data.Conduit.Source
06:58:09 <lambdabot>     Not in scope: data constructor ‘Data.Conduit.Source’
06:58:09 <EvanR> Source might be a type family making this type even more fun
06:58:13 <saurabhnanda> :k Data.Conduit.Source
06:58:14 <lambdabot> (* -> *) -> * -> *
06:58:24 <saurabhnanda> the Source in that type is Data.Conduit.Source
06:58:33 <saurabhnanda> how am I supposed to deal with that?
06:58:45 <saurabhnanda> type Source m o = ConduitM () o m ()
06:58:58 <saurabhnanda> where ConduitM itself is a monad
06:58:59 <EvanR> ok well to answer the question res will be [PersistentValue]
06:59:31 <saurabhnanda> why won't it be (m [PersisValue])? The 'do' block will "unwrap" one layer of the monad, right?
06:59:40 <EvanR> the monad is probably Source m
07:00:26 <sammij> quchen: I'm not quite sure it terminates, but that is a minor defect I can fix later ;P (when I have got the other details right)
07:02:10 <EvanR> sammij: as long as you pass another argument, like []
07:02:15 <saurabhnanda> how is one supposed to "understand" this ? type Source m o = ConduitM () o m ()
07:02:33 <EvanR> its a type synonym with 2 arguments
07:02:35 <mniip> it's a type synonym
07:02:49 <mniip> wherever you see 'Source m o' it's actually 'ConduitM () o m ()'
07:02:53 <saurabhnanda> I'm actually getting fed-up of so many types. Dealing with a new type is like dealing with a new mini-language.
07:03:05 <EvanR> you can turn the type checker off if you want ;)
07:03:10 <EvanR> and do it all blind
07:03:20 <mniip> you can?
07:03:24 <tdammers> yes
07:03:25 <EvanR> defer-type-errors
07:03:26 <Akii> wow
07:03:29 <saurabhnanda> mniip: that I understood -- it's a type synonym. I can't figure out how one can reason about "ConduitM () o m ()"
07:03:31 <mniip> that's uhh
07:03:35 <Akii> should be yolo
07:03:35 <mniip> a bit different
07:03:40 <EvanR> this is how they do it other languages
07:03:47 <EvanR> seat of your pants
07:03:48 <tdammers> it doesn't make the type errors go away, it just allows the compilation to go through, and then things blow up at runtime instead
07:03:51 <tdammers> just like in a dynamic language
07:04:08 <mniip> how about 'print ()'
07:04:10 <dramforever> Even blow up more
07:04:15 <mniip> does the Show instance lookkup happen at runtime
07:04:31 <dramforever> this IIRC blows up: putStrLn ("x" :: Int)
07:04:45 <dramforever> mniip: So unfortunately no, that's not how it works
07:05:11 <dramforever> IMHO you can't just turn off the typechecker because that's not how Haskell works
07:06:06 <sammij> what is the difference between ST from Prelude and State from Control.Monad.State.Lazy?
07:07:30 <EvanR> saurabhnanda: these database libs seem to be heavily steeped in type megatricks, but there are some that do it with less safety
07:07:56 <EvanR> it would be nice to get a sweet spot
07:09:03 <saurabhnanda> now, a rawQuery gives me back a PersistValue, which is an ADT over PersistText Text | PersistByteString ByteString | PersistInt64 Int64 ... and so on. Do I have to pattern-match on res?
07:09:19 <saurabhnanda> even though I know that my query will return an Int64?
07:09:47 <EvanR> so [PersistentInt64 i] <- rawQuery....
07:10:20 <EvanR> and it will crash if your "knowledge" is wrong
07:10:29 <lambda-11235> sammij: State is just a wrapper for the function s -> (a, s), while ST uses actual mutable memory.
07:10:30 <EvanR> ... it will execute `fail'
07:10:37 <lambda-11235> See http://stackoverflow.com/questions/5545517/difference-between-state-st-ioref-and-mvar.
07:11:57 <sammij> thanks lambda-11235 
07:12:23 <lambda-11235> np
07:12:24 <saurabhnanda> EvanR: thanks, let me try that.
07:13:20 <EvanR> thats usually what i want anyway, no returns an empty list or i silently ignore extra results i didnt expect nonsenses
07:26:47 <sammij> is concatMap just mapM specialized for the List monad?
07:28:21 <pavonia> concatMap also joins the result lists
07:28:49 <cnr> sammij: concatMap is (=<<); mapM is traverse
07:29:40 <sammij> aha :)
07:38:11 <obadz> raichoo et al.: am struggling getting ghc-mod to work in neovim. I get ghcmod#command#type: Cannot guess type on everything
07:38:18 <obadz> Any ideas?
07:45:48 <sammij> does the generalization of zipWith have a name?
07:46:47 <cocreature> sammij: Applicative is some sort of generalization, it depends on how exactly you want to generalize
07:47:37 <obadz> > (,) <$> [1,2] <*> [3,4]
07:47:39 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
07:47:43 <sammij> cocreature: anything that preserves its behavior on lists and is applicable to other stuff
07:47:45 <obadz> doesn't look like zipWith to me
07:47:55 <cocreature> there is a ZipList newtype
07:48:04 <obadz> oh
07:48:17 <sammij> > zipWith (+) [1,2,3] [2,3,4]
07:48:19 <lambdabot>  [3,5,7]
07:48:20 <cocreature> > (,) <$> ZipList [1.2] <*> ZipList [3,4]
07:48:22 <lambdabot>  ZipList {getZipList = [(1.2,3)]}
07:48:31 <sammij> > liftA2 (+) [1,2,3] [2,3,4]
07:48:33 <lambdabot>  [3,4,5,4,5,6,5,6,7]
07:48:39 <cocreature> > (,) <$> ZipList [1,2] <*> ZipList [3,4]
07:48:40 <lambdabot>  ZipList {getZipList = [(1,3),(2,4)]}
07:48:48 * hackagebot haste-compiler 0.5.4.2 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.4.2 (AntonEkblad)
07:48:49 <obadz> Cool
07:49:01 <aarvar> sammij: no, concatMap generalizes over foldables
07:49:03 <cocreature> iirc lens or something has Zippable
07:49:09 <infandum> Is this how I parallelize x :: IO a and y :: IO a into [x, y]? :     result <- sequence $ x `par` y `pseq` [x, y]
07:49:10 <aarvar> @type concatMap
07:49:12 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
07:49:13 <cocreature> ah no it’s the keys package
07:49:16 <cocreature> it has a Zip typeclass
07:49:18 <aarvar> @type (=<<)
07:49:20 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:49:24 <infandum> It seems to use only 100% of the cpu even with -N8
07:50:03 <sammij> > liftA2 (+) (ZipList [1,2,3]) (ZipList [2,3,4])
07:50:05 <lambdabot>  ZipList {getZipList = [3,5,7]}
07:50:10 <cocreature> infandum: I don’t think par makes sense in an IO context, you want forkIO or a higher level abstraction of that (i.e. the async package)
07:51:02 <roelof> Why do I see here (http://lpaste.net/156092) a exception : ExitSuccess and not with the hangman game in the haskell book written by bitemyapp
07:51:07 <ciel_> hi
07:51:36 <sammij> cocreature: interesting, any idea why the ZipList behavior is not the default for liftA2 and lists?
07:51:51 <infandum> cocreature: But I didn't want to use separate threads. So I am doing recursion down a tree and I wanted to use asynchronous computation all the way down. But if I make a thread for each x and y, they each make x1 and y1 and so on and there would be too many threads so the granularity would be lost
07:51:53 <portnov> :t fmap fmap fmap
07:51:54 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:52:09 <ciel_> hello there guys im a programmer i know multiple langages and networking im trying to learn hack can you guide me pliz 
07:52:17 <portnov> :t fmap fmap fmap fmap
07:52:18 <lambdabot> (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
07:52:28 <portnov> hm
07:52:29 <infandum> cocreature: It looked like using parallel instead of concurrency was the way to go, because the computer would figure out if it "could" use another processor or not, so the granularity would not take a hit
07:52:36 <cocreature> sammij: there is no monad instance for it, also since lists don’t have a fixed length zip always feels a bit weird
07:52:43 <portnov> ciel_: return -ETOOFAT;
07:53:12 <markan> I just installed lambda bot thru cabal, how do I use it?
07:53:26 <ciel_> so any ideas?
07:53:34 <cocreature> infandum: fwiw haskell threads are very lightweight, so you can spawn a million of them without any problems, but yeah at some point there will be overhead
07:53:58 <infandum> cocreature: It would be log(n), where n is a million
07:54:05 <infandum> so actually maybe that's not too bad
07:54:14 <infandum> I'll try out async, looks easy enough
07:54:38 <cocreature> infandum: what do your io actions do?
07:54:50 <sammij> cocreature: aha, so you are saying there is no possible extension of zipWith to Monads that preserves the behavior on lists?
07:55:05 <ciel_> guys hello 
07:55:30 <infandum> cocreature: Returns a tree
07:55:35 <infandum> subtree
07:56:00 <infandum> in that subtree, those computations are run again
07:56:14 <cocreature> infandum: I was trying to get at the IO part, returning a tree could just be a pure function in which case par is fine
07:56:38 <ciel_> guys come on be friendly 
07:58:10 <cocreature> sammij: something like that. in the end both choices of the list applicative are sensible, but we can only have one as the default. since one allows to also give lists a (useful) monad instance it’s reasonable to chose that one
07:58:36 <infandum> cocreature: Actually it returns (R s (Tree TreeData))
07:58:44 <sammij> cocreature: very enlightening
07:59:05 <infandum> cocreature: But H.io should be of type IO a -> m a
07:59:44 <ciel_> youre talking about tree in C?
07:59:59 <cocreature> infandum: you’re missunderstanding to me, I was trying to get a feeling for what the IO action is (reading a file, performing db access, http requests, …) to get a feeling for whether forkIO is a sensible thing to use here
08:00:13 <sammij> ciel_: https://wiki.haskell.org/Meta-tutorial
08:00:30 <infandum> cocreature: R monad, so doing an R computation (literally the R language)
08:01:02 <infandum> cocreature: async might work, I just need to fiddle with the types
08:01:16 <cocreature> infandum: ah ok, I think async/forkIO is the right thing to use here
08:01:52 <cocreature> infandum: you can just use mapConcurrently in a lot of cases
08:02:52 <infandum> cocreature: OOOoooo another toy! Let me check that one out
08:02:58 <cocreature> infandum: it’s in async
08:03:35 <cocreature> it hides all the thread creation and collecting of results from you
08:03:39 <cocreature> it’s awesome :)
08:06:35 <infandum> cocreature, hmmm, it takes in an IO performing function but the type is R s a, so I need to figure out how to make it take that. H.io usually works, but it's having issues probably because it's what is returned, not what it takes
08:07:19 <cocreature> sry not familiar with R even less familiar with the way to access it from haskell
08:07:25 <statusfailed> Are there formal definitions for what "denotational semantics" and "operational semantics" are? I'm reading page 33 of TAPL, and AFAICT denotational semantics subsumes operational semantics. I'm also not really sure how axiomatic semantics defines how a term can be evaluated...
08:08:20 <lpaste> purelazy pasted “Installing gtk” at http://lpaste.net/156093
08:08:46 <purelazy> can anyone help with installing gtk
08:09:23 <purelazy> its the most complicated thing I've tried to do
08:10:10 <purelazy> it fails on cairo I think
08:10:29 <purelazy> and glib
08:11:28 <cocreature> purelazy: looks like your cabal version is too old
08:11:37 <cocreature> try cabal update && cabal install cabal-install
08:12:00 <purelazy> cocreature: OK. Will do
08:13:33 <purelazy> cocreature: should cabal update be done before every install as a safety precaution
08:13:51 <saurabhnanda> more type madness: how do I figure out if rawQuery will compose with runSqlite (wrt Persistent/Yesod)?
08:14:35 <saurabhnanda> runSqlite :: (Control.Monad.IO.Class.MonadIO m, Control.Monad.Trans.Control.MonadBaseControl IO m) => Data.Text.Internal.Text -> SqlPersistT (Control.Monad.Logger.NoLoggingT (Control.Monad.Trans.Resource.Internal.ResourceT m)) a -> m a
08:14:53 <saurabhnanda> rawQuery :: (MonadResource m, MonadReader env m, HasPersistBackend env SqlBackend) => Text -> [PersistValue] -> Source m [PersistValue]
08:16:23 <roelof> Why do I see here (http://lpaste.net/156092) a exception : ExitSuccess and not with the hangman game in the haskell book written by bitemyapp ?
08:18:12 <lazywriter> in haskell, is there a way to do "compile time include this entire file as a single string" ? basically, I want to hard code an entire file into my haskell program (why? well, I'm compiling via ghc + ghcjs; and paths become weird if I have to make them work both locally and over the net; so I'd prefer to just hard code the file into my *.hs sources)
08:18:20 <saurabhnanda> how do I compose them on the repl and check if they will work? I've tried a lot of combinations and nothing seems to work?
08:19:00 <saurabhnanda> :t (runSqlite "") >>= (rawQuery "" [])
08:19:02 <lambdabot> Not in scope: ‘runSqlite’
08:19:02 <lambdabot> Not in scope: ‘rawQuery’
08:19:20 <saurabhnanda> :t $$
08:19:22 <lambdabot> parse error on input ‘$$’
08:20:04 <saurabhnanda> :t Data.Conduit.$$
08:20:06 <lambdabot> parse error on input ‘Data.Conduit.$$’
08:20:11 <saurabhnanda> :t (Data.Conduit.$$)
08:20:12 <lambdabot> Monad m => conduit-1.2.5:Data.Conduit.Internal.Conduit.Source m a -> conduit-1.2.5:Data.Conduit.Internal.Conduit.Sink a m b -> m b
08:20:41 <saurabhnanda> okay, so the example at http://www.yesodweb.com/book/persistent#persistent_persistent_raw_sql uses Data.Conduit.$$ to consume whatever rawSql is giving back. What fresh hell is htis?
08:21:35 <purelazy> roelof: where is exitSuccess defined
08:21:55 <purelazy> roelof: can you provide a bit more context
08:22:06 <c_wraith> saurabhnanda, it's the operator to hook a source to a sink and run the whole thing. if that makes no sense to you, you skipped a section on conduits
08:22:32 <roelof> exitSucess comes from System.IO , purelazy 
08:22:49 <saurabhnanda> c_wraith: Do I really need to understand yet another library to run an MAX() sql query and get the maximum value from a table?
08:23:27 <roelof> as I said , I try to solve one of the challenges of the Haskell Book written by bitemyapp 
08:23:33 <saurabhnanda> c_wraith: is there an easy way to get a Conduit.Source to behave like a list/array -- so that I can just pick the first row from it and call it a day?
08:25:09 <purelazy> roelof: I import System.IO and I get h.hs:4:14: Not in scope: `forever', h.hs:9:10: Not in scope: `exitSuccess'
08:25:24 <roelof> sorry, wrong library : here it is : http://hackage.haskell.org/package/base-4.8.2.0/docs/System-Exit.html#v:exitSuccess
08:25:28 <c_wraith> saurabhnanda, https://hackage.haskell.org/package/conduit-1.2.6.4/docs/Data-Conduit-List.html#v:head
08:25:39 <c_wraith> saurabhnanda, use that as your sink
08:26:12 <purelazy> roelof: And where is forever defined?
08:26:27 <saurabhnanda> :t Data.Conduit.List.head
08:26:29 <lambdabot> Monad m => conduit-1.2.5:Data.Conduit.Internal.Conduit.ConduitM a o m (Maybe a)
08:26:33 <c_wraith> saurabhnanda, and follow the types. for your purposes, knowing the type of ($$) and that you have a source and a sink is good enough. 
08:26:39 <saurabhnanda> c_wraith: the return type is not a [a]
08:26:44 <purelazy> @hoogle forver
08:26:46 <lambdabot> No results found
08:26:49 <purelazy> @hoogle forever
08:26:49 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
08:27:03 <saurabhnanda> :t (Data.Conduit.$$)
08:27:05 <lambdabot> Monad m => conduit-1.2.5:Data.Conduit.Internal.Conduit.Source m a -> conduit-1.2.5:Data.Conduit.Internal.Conduit.Sink a m b -> m b
08:27:11 <c_wraith> saurabhnanda, no, it gets the first result and returns it, if there is one. 
08:27:13 <roelof> purelazy:  yep, here : http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:forever
08:27:48 <c_wraith> saurabhnanda, that is, it pretends the conduit is a funny list and does the head operation, except with a sane return type. 
08:28:17 <purelazy> *Main> palindrome 
08:28:17 <purelazy> radar
08:28:18 <purelazy> This ia a palindrome
08:28:18 <purelazy> house
08:28:18 <purelazy> Nope!
08:28:19 <purelazy> *** Exception: ExitSuccess
08:28:21 <purelazy> *Main> 
08:28:48 <roelof> yep, that is what I mean 
08:29:32 <saurabhnanda> c_wraith: I think I found an easier function. rawSql :: :: (RawSql a, MonadIO m) => Text -> [PersistValue] -> ReaderT SqlBackend m [a]
08:29:50 <saurabhnanda> c_wraith: conduits, conduits, go away. Come again.... NEVER!
08:30:05 <purelazy> roelof: exitSuccess is supposed to do that
08:30:48 <purelazy> @hoogle exitSuccess
08:30:48 <lambdabot> System.Exit exitSuccess :: IO a
08:30:48 <lambdabot> System.Exit ExitSuccess :: ExitCode
08:30:49 <roelof> purelazy:  wierd, when I use that on a hangman game I do not see that exception part 
08:32:20 <purelazy> roelof: Can you lpaste the hangman game?
08:32:30 <saurabhnanda> :t Single
08:32:31 <lambdabot> Not in scope: data constructor ‘Single’
08:32:38 <roelof> purelazy:  moment 
08:34:04 <purelazy> roelof: Does "exitSuccess" do what you expect?
08:34:44 <purelazy> roelof: i.e. the program terminates
08:35:17 <roelof> purelazy:  yep, it terminates
08:35:30 <roelof> here the code of the hangman game : http://lpaste.net/156095
08:35:56 <roelof> the only thing what is missing is a dict list which must be in data/
08:36:21 <saurabhnanda> If I'm creating a newtype for an Int, how do I derive '+' for it?
08:37:11 <roelof> schould that no be , deriving Ord , saurabhnanda 
08:37:34 <hexagoxel> (+) is Num, right?
08:41:20 <crough> saurabhnanda: GeneralizedNewtypeDerivung
08:41:27 <crough> *Deriving
08:41:32 <purelazy> roelof: the exitSuccess calls appear to be in the right places. Can you explain your problem again?
08:41:45 <saurabhnanda> let me try
08:42:05 <saurabhnanda> newtype X = X Int deriving (Show, Ord, Eq)
08:42:12 <saurabhnanda> (X 10) + (X 11)
08:42:17 <saurabhnanda> No instance for (Num X) arising from a use of ‘+’
08:43:10 <saurabhnanda> doesn't work with :set -XGeneralizedNewtypeDeriving
08:43:28 <nolraiU> You still need to declare it.
08:43:32 <saurabhnanda> should it have anything to do with MAppend or AppendM?
08:43:38 <saurabhnanda> nolraiU: how do I do that?
08:43:47 <roelof> purelazy:  if I do the hangman game and it exist I see : You loose. The word is Ivar's 
08:43:49 <nolraiU> deriving (Show, Ord, Eq, Num)
08:44:17 <roelof> when I end the palindrome function I see the exception : exitSuccess output 
08:44:19 <saurabhnanda> nolraiU: works now. Does deriving (Num) depend on XGeneralizedNewtypeDeriving
08:44:29 <nolraiU> Yes.
08:44:34 <roelof> I wonder why ? purelazy 
08:45:41 <saurabhnanda> thanks, but no luck. The data-type is being created in some TemplateHaskell blackmagic by Persistent. Can I derive instances for a data-type AFTER it has been declared?
08:46:53 <saurabhnanda> :t (1+)
08:46:55 <lambdabot> Num a => a -> a
08:51:39 <purelazy> Sorry roelof, I'm not sure what you're having an problem with.
08:52:31 <purelazy> roelof: Perhaps lpaste the dialogue and point out where your confusion lies
08:57:40 <ph88> http://pastebin.com/msVjfZz2 isn't this a default haskell package? why i do i have to add it to build depends?  i use stack by the way
08:58:13 <roelof> purelazy:  I think I found it. I did a stack exec hangman-exe and did not see the exception 
08:58:29 <roelof> when I run it in ghci I see the exception 
08:58:40 <purelazy> roelof: So you're OK now?
08:58:54 <roelof> yep, im oke and learned another thing 
08:59:16 <purelazy> roelof: what did you learn?
08:59:36 <roelof> that output in ghci can differ from stack exec 
08:59:57 <roelof> apperently stack exec does not print the exitcode's 
09:00:41 <purelazy> roelof: I am a noob and not (yet anyway) a stack user
09:01:10 <roelof> im also a noob. I try to learn haskell by following the haskell book 
09:01:28 <purelazy> roelof: and, funnily enough, you never even mentioned stack :)
09:01:52 <purelazy> roelof: I'll help whenever I can
09:02:07 <roelof> stack and cabal differ not a lot when building projects. One thing where stack is better is handeling installs of libraries with dependencies 
09:02:33 <purelazy> roelof: I should probably start using stack
09:02:43 <Cale> ph88: base is the only default dependency
09:03:03 <purelazy> roelof: Have you tried using gtk?
09:08:41 <saurabhnanda> how is this bypassing type-checks? http://lpaste.net/156096
09:10:23 <aweinstock> saurabhnanda: probably (deriving Num), but it depends on exactly what you mean "bypassing type-checks"
09:10:45 <aweinstock> @let newtype Foo = Foo Int deriving (Show, Num)
09:10:46 <lambdabot>  .L.hs:302:29:
09:10:46 <lambdabot>      Can't make a derived instance of ‘Num Foo’:
09:10:46 <lambdabot>        ‘Num’ is not a derivable class
09:11:18 <aweinstock> lambdabot doesn't do GeneralizedNewtypeDeriving?
09:12:20 <geekosaur> that's deriving Num, es
09:12:21 <geekosaur> yes
09:12:22 <geekosaur> :t 100
09:12:24 <lambdabot> Num a => a
09:12:27 <aweinstock> saurabhnanda: try ((1+) :: Aria2RequestId -> Aria2RequestId)
09:12:59 <aweinstock> you don't need to explicitly wrap/unwrap, Num will handle that for you
09:13:05 <roelof> purelazy:  gtk , like the gtk which Gnome is using ? 
09:13:12 <saurabhnanda> aweinstock: I'm passing a Num to a function who's type-sig clearly states that it requires Aria2RequestId. shouldn't the compiler cry bloody murder?
09:13:27 <purelazy> roelof: yes
09:13:52 <roelof> nope, First I want to learn haskell very well 
09:13:54 <purelazy> roelof: I'm learning gtk today
09:14:03 <saurabhnanda> aweinstock: hmm... what's the point of creating a newtype wrapping Num, in that case? I was trying to prevent accidental misuse of Id-A where Id-B is exepcted
09:14:05 <roelof> purelazy:  why this question 
09:14:06 <aweinstock> saurabhnanda: Num isn't a type, (Num a => a) is, and Aria2RequestId is an instance of the Num typeclass
09:14:25 <saurabhnanda> * newtype wrapping Int
09:14:34 <purelazy> roelof: I just wondered
09:14:46 <aweinstock> saurabhnanda: it will prevent that, try: incrementAria2RequestId (100 :: Int)
09:14:46 <ph88> can anyone tell me why i'm getting an error output here?  https://www.pastery.net/tffkbm/
09:14:48 <geekosaur> saurabhnanda, numeric literals are Num a => a, not Integer
09:14:58 <geekosaur> and there is no such thing as "a Num"
09:15:15 <purelazy> roelof: I am struggling to install gtk - perhaps cos I do not use stack
09:15:29 <purelazy> roelof: due to dependency hell
09:15:54 <ph88> Cale, so   import Data.Char (isPrint)  is in base, but  Data.Text  is not in base ?
09:16:10 <Cale> Data.Char is in base, yeah
09:16:13 <purelazy> roelof: So I guess it's time for me to learn how to use stack
09:18:57 <roelof> purelazy:  can be a solution 
09:19:00 <Shockk> just wondering, where can I find someone who is able to fix a mistake on a page on wiki.haskell.org?
09:19:01 <saurabhnanda> aweinstock: thanks, got it.
09:19:48 <purelazy> roelof: Have you come across the concept of Monoid?
09:20:19 <Shockk> on this page https://wiki.haskell.org/Avoiding_partial_functions it uses the word "Whereever" but it should be "Wherever", which isn't a huge issue but I thought I should let someone know
09:21:51 <Cale> Shockk: got it
09:22:02 <Shockk> great, thanks
09:23:52 * hackagebot sloane 5.0.0 - A command line interface to Sloane's OEIS.  https://hackage.haskell.org/package/sloane-5.0.0 (AndersClaesson)
09:23:54 * hackagebot hops 0.5.0 - Handy Operations on Power Series  https://hackage.haskell.org/package/hops-0.5.0 (AndersClaesson)
09:25:50 <ph88> how come some parts of Data. are in base and others not ?
09:26:17 <Gurkenglas> Why doesn't stack install C libraries?
09:27:21 <puregreen> ph88: well, since anyone can make a Data. module
09:27:51 <Cale> ph88: Note that the hierarchical nature of modules is an illusion formed by allowing '.' in module names.
09:28:06 <Shockk> ph88: Data. is the first part of the module name, afaik it's typically used for modules that define a data type and functions to operate on that data type, like Data.Maybe; base has some modules that are Data.Something, but I can make my own module called, say, Data.ChessBoard
09:28:07 <Cale> There's really nothing more to it than that.
09:28:10 <roelof> nope, that is 2 chapters away from where I m at the moment. First testing is explained and then Monoids 
09:28:23 <chattered> Any recommended easy-to-use libraries for animated vector graphics?
09:28:38 <ph88> i see ^^
09:28:43 <Cale> Well, there's *slightly* more to it in that GHC will look in subdirectories according to the module name segments separated by '.'
09:28:59 <puregreen> ph88: in fact, I could take *any* module and make an extension module (X.Y.Z → X.Y.Z.Utils) and put it into my xyz-utils package, and this would be okay
09:30:00 <ph88> hey puregreen i just trying your suggestion from before .. seems to go wrong somewhere https://www.pastery.net/tffkbm/  oh i had to leave out the T.pack part otherwise the types wouldn't line up
09:30:18 <obadz> Is there a REPL story in vim like there is in Emacs?
09:30:45 <Cale> Also, people won't like it, but it is technically possible to put a module named Data.Text in your own package.
09:36:27 <obadz> Is haskellmode-vim a dead project?
09:39:13 <Gurkenglas> How would I correctly define something like "type instance Id a = a -> a"?
09:39:36 <Gurkenglas> Actually "type instance Id a = id :: a -> a"
09:42:22 <ph88> puregreen, i'm back another time
09:48:12 <roelof> someone who have made a wizard/multiform in Haskell and is willing to share it with me ?
09:50:54 <purelazy> roelof: can you be more specific
09:51:29 <purelazy> roelof: you want a haskell to any platform wizard?
10:00:28 <sm> roelof: take a look at http://hackage.haskell.org/package/wizards & examples
10:02:49 <roelof> purelazy:  nope, what I mean is a form with multiple pages. Like this one in jquery : http://lazy-coding.com/j-forms-advanced/forms/order_multistep_with_steps/index.html
10:09:12 <saurabhnanda> is there an easy way to update an entire record in Persistent/Yesod?
10:09:55 <lpaste> Gurkenglas revised “Can't install idris. Why? This is after a restart suggested by a text like this. I only see one cygwin1.dll”: “No title” at http://lpaste.net/2539959567689711616
10:11:06 <saurabhnanda> got it -- replace & repsert
10:13:16 <tdammers> "repsert"... these neologisms are getting out of hand
10:17:14 <hiptobecubic> repsert? how is that different from upsert?
10:21:01 <railswalker_> @help
10:21:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:21:17 <railswalker_> @help list
10:21:18 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
10:21:26 <railswalker_> @list
10:21:26 <lambdabot> What module?  Try @listmodules for some ideas.
10:21:37 <railswalker_> list
10:21:42 <railswalker_> 'list'
10:21:57 <railswalker_> @help 'list'
10:21:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:22:11 <railswalker_> @listmodules
10:22:11 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
10:22:15 <railswalker_> @list
10:22:15 <lambdabot> What module?  Try @listmodules for some ideas.
10:22:26 <railswalker_> @help pl
10:22:26 <lambdabot> pointless <expr>. Play with pointfree code.
10:22:41 <railswalker_> @pl x+3
10:22:41 <lambdabot> x + 3
10:22:52 <puregreen> railswalker_: perhaps it'd be better to converse with lambdabot directly
10:22:59 <puregreen> “/query lambdabot”
10:23:34 <UberLambda> https://gist.github.com/UberLambda/01f188715eae08576f6f <- Any errors or improvements to do in this code snippet? It's my first Haskell module
10:28:21 <infandum> Is there a way to derive Num for a newtype using DeriveAnyClass?
10:32:15 <aweinstock> infandum: GeneralizedNewtypeDeriving
10:33:47 <xa0> :t (\x y -> x:[y])
10:33:48 <lambdabot> a -> a -> [a]
10:34:11 <xa0> :t (\x -> (x:) . [])
10:34:12 <lambdabot>     Couldn't match expected type ‘a -> [a1]’ with actual type ‘[t0]’
10:34:12 <lambdabot>     Relevant bindings include x :: a1 (bound at <interactive>:1:3)
10:34:12 <lambdabot>     In the second argument of ‘(.)’, namely ‘[]’
10:34:43 <xa0> :t (\x -> (x:) . ([]))
10:34:44 <lambdabot>     Couldn't match expected type ‘a -> [a1]’ with actual type ‘[t0]’
10:34:45 <lambdabot>     Relevant bindings include x :: a1 (bound at <interactive>:1:3)
10:34:45 <lambdabot>     In the second argument of ‘(.)’, namely ‘([])’
10:34:52 <xa0> :t (\x -> (x:) . (:[]))
10:34:54 <lambdabot> a -> a -> [a]
10:35:19 <nitrix> xa0: So pointfree, much readable.
10:35:34 <xa0> This is more of a mental exercise than useful
10:35:43 <xa0> Can I get rid of the x too?
10:35:47 <xa0> I feel like I can
10:35:53 <xa0> But it's hard
10:36:12 <nitrix> @pl (\x -> (x:) . (:[]))
10:36:12 <lambdabot> (. return) . (:)
10:36:23 <obadz> foreign import ccall unsafe "atoi" atoi' :: CString -> CInt
10:36:25 <xa0> Ahaha
10:36:26 <obadz> atoi :: String -> Int; atoi = fromIntegral . unsafePerformIO . fmap atoi' . newCString
10:36:29 <xa0> Very good.
10:36:29 <obadz> would that be the right way to FFI atoi ?
10:36:47 <obadz> (not that one would ever want to..)
10:37:06 <nitrix> xa0: return would bring it to the [] monad.
10:37:12 <nitrix> :)
10:37:16 <xa0> Yeah
10:37:18 <xa0> Clever
10:37:21 <jle`> i'd use (:[]) over return most days though, heh
10:37:28 <jle`> it's already 'point free' anyway
10:37:46 <jle`> obadz: looks like it'd work, although i'm not sure how that'd behave with GC/allocation and also some edge cases for inlining
10:37:54 <nitrix> Doesn't Data.List have a function `singleton` that does that anyway?
10:37:57 <nitrix> Or is it only maps?
10:38:03 <xa0> :t (.(:[])).(:)
10:38:05 <lambdabot> a -> a -> [a]
10:38:10 <Jinxit> beautiful
10:38:17 <obadz> jle`: so is there a better way?
10:38:18 <xa0> Heh
10:38:39 <Jinxit> good thing we went away from lisp, eh
10:38:54 <xa0> Indeed
10:39:03 <osfameron> @pl (\x y -> [x,y])
10:39:03 <lambdabot> (. return) . (:)
10:39:21 <xa0> What is @pl anyway?
10:39:26 <nitrix> Pointless.
10:39:30 <jle`> obadz: not sure :|
10:39:38 <jle`> it's a lot of black magic for me
10:39:40 <xa0> Was that a pun :p
10:39:49 <nitrix> xa0: It's a pun on point-free, correct.
10:39:53 <jle`> s/for/to
10:39:58 <Aruro> guys, is there a way to have multiple declarations of same thing but mean just last one? needed with .lhs
10:40:41 <jle`> Aruro: not really, but you can always have the first declarations not be birded
10:40:54 <Aruro> mm, i want it to be beautiful :)
10:40:56 <the_2nd> which type should I define my functions for, if I require floating point? (currently defined for Double)
10:41:07 <jle`> it works in ocaml because multiple lets is just syntatic sugar for nested lets with shadowing basically
10:41:16 <jle`> the_2nd: Double is fine for most purposes
10:41:24 <jle`> but you can also leave it polymorphic if you're feeling that itch
10:41:36 <jle`> Floating a => ..., etc., whatever typeclass you require
10:42:11 <Aruro> when u write a text in lhs u naturally iterate on variations of same thing, i dont want to go always up to comment out
10:42:14 <jle`> nice advantage of Floating a =>>  etc. is that you can use neat libraries like 'ad' with it, that offer esoteric Num instances
10:43:09 <Zemyla> What should I import to get the definition of RealWorld?
10:43:28 <jle`> Aruro: i think in lhs cases like that, most people usually just give each one different names, like foo1, foo2, etc
10:43:32 <jle`> not very beautiful, i know :|
10:43:37 <Aruro> there should be ghc option -lhs-accept-last
10:43:59 <jle`> that sort of breaks the idea in haskell that ordering doesn't matter though
10:44:07 <jle`> what if you use the name in the middle, between definitions?
10:44:51 <jle`> opens up a can of worms about things in haskell that you really shouldn't have to worry about
10:45:03 <jle`> if you want, you write your entire file in a big Identity monad, heh
10:45:10 <jle`> that gives automatic shadowing behavior
10:45:22 <Aruro> last is unique no?
10:45:26 <Aruro> should not be problems
10:45:35 <Aruro> jsut inore everything but last
10:45:40 <Aruro> just*
10:45:51 <jle`> sounds like it might break functions that use it in the middle
10:45:57 <jle`> 'moddle'
10:46:00 <jle`> *middle
10:46:10 <chattered> muddle?
10:46:51 <Aruro> ok there should be pragma/import like statement Decl-accept-last (list of functions)
10:47:19 <Aruro> u can have it for only one declaration name f example
10:48:25 <obadz> Aruro: in a do block let statements work this way
10:49:23 <jle`> sounds like a lot of complications and complexity in the language for an obscure use case :)  people already complain about haskell being bloated already
10:49:24 <obadz> Aruro: do let x = 1 ⏎ let y = 2 ⏎ let x = 3 ⏎ x + y
10:49:26 <obadz> Aruro: ⇒ 5
10:49:38 <infandum> aweinstock: But GeneralizedNewtypeDeriving conflicts with DeriveAnyClass
10:50:06 <alphonse23_> I know this is like a no-no topic, but how much does a haskell developer typically make?
10:50:07 <Aruro> jle`: academically its very usefull case, it follows logic of presentation
10:50:25 <Aruro> we are iterating on functions being presented and computer gets it, thats all
10:50:32 <Aruro> discussed*
10:51:11 <Aruro> for example im creating Euclids proposition 1 in diagrams, and it has name proposition1, im adding stuff to it as i go
10:51:45 <Aruro> obadz: yes ghci also gets last declaration behaviour
10:51:59 <obadz> Aruro: ghci is one giant do block
10:52:19 <Aruro> yep :)
10:52:40 <Aruro> im just saying this pragma-option if very natural if we have .lhs support
10:52:49 <obadz> it gives me weird parse errors though
10:52:51 <obadz> > do { let x = 1; let y = 2; x + y }
10:52:52 <lambdabot>  <hint>:1:34: parse error on input ‘}’
10:52:58 <obadz> why is there a parse error here?
10:53:11 <jle`> i'm not saying it's not useful in this specific situation, i'm just saying that you'd have to justify it to be more generally useful
10:53:39 <jle`> > runIdentity $ do { let {x = 1}; let {y = 2}; return (x + y) }
10:53:41 <lambdabot>  3
10:53:46 <Aruro> in light of supporting .lhs its firs order thing, probably people can ask same question about .lhs support
10:53:48 <jle`> obadz: there's an ambiguous parse if you don't have the brackets
10:54:43 <jle`> or well, it's not am ambiguous parse, but let in a do block introduces layouting
10:55:03 <obadz> jle`: http://pasteboard.co/2sCTJuzL.png
10:55:06 <obadz> jle`: this parses fine
10:55:16 <Aruro> probably u forgot to use IN
10:55:21 <Aruro> let in
10:55:30 <obadz> Aruro: no need for in in do block
10:55:55 <jle`> obadz: that's because you're taking advantage of layouting
10:56:04 <obadz> what's layouting?
10:56:04 <jle`> g
10:56:21 <jle`> like, your indenting tells the compiler what means what
10:56:24 <jle`> and what to group where
10:56:48 <jle`> things like case statements, do blocks, etc.trigger layouting blocks
10:57:05 <obadz> > do { x <- [1]; y <- [2]; return (x + y) }
10:57:07 <lambdabot>  [3]
10:57:13 <obadz> am I not using layouting here?
10:57:14 <jle`> you can chose to forego layouting and tell ghc to ignore it/turn it off with brackets, {}
10:57:33 <jle`> no, you're telling ghc to turn off layouting with {}
10:57:33 <Cale> itym layout
10:57:50 <jle`> hm, maybe, but i'm using it like a verb :O
10:57:54 <jle`> should it be a verb?
10:58:03 <djbeau> xa0: I am late to the conversation, but I like (lmap pure) . (:)
10:58:06 <Aruro> definitely
10:58:12 <Aruro> everything can be a verb
10:58:30 <xa0> Lmao?
10:58:36 <jle`> obadz:  "do" introduces a layout block, so you negated it with {}
10:58:39 <xa0> *lmap?
10:58:50 <xa0> :t lmap
10:58:51 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
10:58:55 <xa0> Ah!
10:58:56 <djbeau> xa0: from profunctors :)
10:58:59 <jle`> obadz: "let" in a do block also introduces a new layout block, so you need a {} also
10:59:00 <xa0> Oh that's clever
10:59:29 <jle`> (if you wanted to ignore layouting rules)
10:59:50 <djbeau> I think of lmap as "modify the first argument of a function"
11:00:15 <obadz> jle`: had didn't realize let worked this way
11:00:18 <obadz> anyway:
11:00:20 <obadz> > do { let { x = 1 }; let { y = 2 }; x + y }
11:00:22 <lambdabot>  3
11:00:49 <obadz> > do { let { x = 1 }; let { y = 2 }; let { x = 3 }; x + y } -- Aruro 
11:00:52 <lambdabot>  5
11:01:28 <Aruro> obadz: i know its possible in do blocks, i was asking globally in a .lhs file
11:01:45 <obadz> Aruro: write your file in a big do block ;-)
11:02:05 <Aruro> obadz: one option :)
11:02:20 <Aruro> jle`: jle already mentioned it :) with identity monad
11:02:26 <lpaste> Michael pasted “Simulation” at http://lpaste.net/156102
11:02:29 <obadz> no need for Identity monad
11:02:39 <obadz> just do block
11:02:57 <Cale> jle`: I would refer to the process as layout -- layouting is weird, because it's like treating layout as a verb and then turning it back into a noun
11:03:02 <mick> Hi Guys, I can't get my code to compile and I am stuck. Please can someone help me. Code is at: http://lpaste.net/156102
11:03:05 <Aruro> obadz: u have to have monad for do block
11:03:14 <obadz> Aruro: what's the monad in my example above?
11:03:18 <Aruro> IO
11:03:19 <mick> I added the priceJump function and it doesn't compile now
11:03:24 <Aruro> u are inside ghci
11:03:28 <jle`> Aruro: actually, you don't really need one, do blocks are a straightforward desugaring
11:03:29 <obadz> Aruro: nope
11:03:43 <mick> I'm getting this error: Couldn't match expected type ‘m Double’ with actual type ‘Double’ …                                                                                                            Relevant bindings include                                                                                                                                                                                      g :: Gen (PrimState m)                           
11:03:48 <jle`> do { let x = y; z } desugars to let x = y in z
11:04:05 <jle`> you only need to have a Monad instance if your desugaring ever needs >>= or >>
11:04:14 <obadz> … or return
11:04:18 <jle`> @undo do { let {x = y}; z }
11:04:18 <lambdabot> let { x = y} in z
11:04:31 <jle`> @undo do { let {x = y}; z; k }
11:04:31 <lambdabot> let { x = y} in z >> k
11:04:50 <markan> I installed lambdabot thru cabal, anyone know how to run it?
11:05:04 <Aruro> jle`: do let x = 5 and then layouted x does not work in ghc :)
11:05:06 <Cale> mick: Try replicateM 10 (fmap (priceJump 100.00 0.05 0.2 0.01) (normal 0 1 g))
11:05:20 <Aruro> jle`: i suspect u need brackets for that to work
11:05:31 <dcoutts> markan: you may want to put ~/.cabal/bin in your $PATH
11:05:42 <Cale> mick: You want to execute normal 0 1 g to get a random value, and then supply that value to priceJump
11:05:46 <jle`> obadz: yeah, let in a do block introduces a layout block because you can put more than one declaration in a 'let'
11:05:59 <Aruro> jle`: in fact global level let also does not work
11:06:01 <obadz> Aruro: http://pasteboard.co/2sCTJuzL.png
11:06:01 <jle`> do { let {x = y; z = x; y = z}; ... }, etc.
11:06:17 <obadz> jle`: yes I didn't know about multilet ;-)
11:06:24 <Aruro> jle`: i dont want brackets :)
11:06:25 <Cale> mick: whereas what you wrote would pass the *action* to priceJump (which if it had an appropriate type, would allow it to run the generator as many times as it liked)
11:06:26 <mick> holy smokes that works!!
11:06:28 <mick> thanks man
11:06:33 <mick> i've been on it for hours!!
11:06:35 <obadz> Aruro: you don't need brackets. see my link.
11:06:40 <jle`> yeah, that's actually the "default" behavior of let, because it allows you to chose between "letrec" and shadowing-let
11:06:49 <markan> dcoutts: thanks
11:07:02 <jle`> if you declar things the same "let block", they are recursive bindings and don't shadow
11:07:07 <Cale> mick: Perhaps more straightforward would be   replicateM 10 $ do v <- normal 0 1 g; return (priceJump 100.00 0.05 0.2 0.01 v)
11:07:26 <Cale> mick: no problem :)
11:07:40 <Aruro> obadz: yeah ty, did not know that
11:07:59 <Aruro> obadz: i thought do defined in terms of monad no?
11:08:07 <mick> yeah that looks even better @Cale
11:08:11 <mick> i will do that
11:08:17 <mick> thanks again
11:08:23 <mick> best channel in the world!
11:08:31 <Cale> :)
11:08:32 <obadz> Aruro: it desugars <- in monadic terms
11:09:12 <obadz> Aruro: but if you don't use <- (and don't have multiple instructions not in let statements which would require >>), and don't use return, no monad needed
11:09:27 <lpaste> lambda-11235 pasted “Reactive Banana changes with other value” at http://lpaste.net/156103
11:09:49 <Aruro> obadz: ty, nice to know
11:10:05 <Shockk> #haskell only becomes the best channel once you require an answer to be evaluated
11:10:24 <lambda-11235> In reactive banana, how would I create an Event that changes with a behavior, but has the last value of another behavior?
11:11:18 <Cale> lambda-11235: I... that question doesn't make semantic sense
11:11:49 <Cale> Did you switch occurrences of "behavior" and "event" there?
11:11:58 <Aruro> is there a functor instance like this fmap:: (a->b)->(a,a)->(b,b) ?
11:12:14 <scshunt> Aruro: I'm not aware of one, but you could easily write it
11:12:18 <Aruro> i know there is bifunctor
11:12:20 <Cale> Because it makes more sense if it's "How would I create a Behavior that changes with an Event, but has the last value of another Event"
11:12:28 <Aruro> but im lazy to supply second function
11:12:35 <Cale> The other way around doesn't make any sense.
11:12:43 <puregreen> Aruro: well, there's “both” in various lens libraries
11:13:05 <puregreen> so your function is going to be “over both”
11:13:20 <chattered> Aruro: Define data F a = F a a and deriveFunctor.
11:14:16 <Aruro> there is Data.Bifunctor and it has bimap :: (a->b)->(c->d)-> p a c -> p b d and instance for (,)
11:14:52 <Aruro> so u need to write like bimap (+1) (+1) (1,1)
11:15:24 <puregreen> then you could write “join bimap”
11:16:31 <chattered> Aruro: And you could easily define your own "both" as \f -> bimap f f
11:16:58 <Aruro> i just realized that if u know u have list of exactly two elements u need to use (a,a) instead of list :)
11:17:28 <chattered> You certainly should do.
11:17:30 <Cale> lambda-11235: Is my guess correct?
11:17:31 <Shockk> you don't *need* to, but I would do so myself
11:18:31 <Aruro> seems to be more safe because of the type?
11:19:25 <Gurkenglas> A list of two elements need not make the choice of (a, a) optimal, since traverse, fmap, etc. don't anymore have the expected behavior. Perhaps dependently typed vectors?
11:19:28 <Shockk> pretty much; using (a,a) sets the intention that you want exactly 2 values of type a
11:20:04 <Aruro> Gurkenglas: yes before we were talking about bifunctors for this cause
11:20:21 <Cale> lambda-11235: If so, then it's perhaps  foo e e' = do b <- stepper Nothing (fmap Just e'); return (b <@ e)
11:20:42 <Gurkenglas> bifunctors only if the very nature of the algorithm makes it madness to talk about doing it with three arguments, instead
11:21:47 <Gurkenglas> You can do fmap and traverse with (a, a): They're called "over both" and "both"
11:22:08 <chattered> It still boils down to bitraverse.
11:22:34 <Gurkenglas> But that (a, a) is not what you want is already clear from you having to write a twice
11:22:46 <Cale> lambda-11235: (here, I used Maybe because the second event may not be the one to fire first... you can apply filterJust to the resulting Event if you'd rather discard occurrences of Nothing
11:22:49 <Cale> )
11:23:09 <Gurkenglas> (Unless your algorithm would work as well with two different types there, and you just happen to want the same one in each place this time)
11:25:10 <Shockk> would Linear.V2 be useful for them perhaps?
11:27:21 <nitrix> Curiously, doesn't lens's `over both` kind of make bifunctors useless?
11:27:54 <shachaf> No.
11:28:16 <chattered> `both` has bifunctor as an inherited constraint.
11:28:24 <nitrix> Oh I see.
11:30:01 <jle`> :t both
11:30:02 <lambdabot> (Applicative f, Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
11:31:46 <joco42> any opinions : http://stackoverflow.com/questions/36162127/is-the-cake-pattern-missing-from-haskell-why-and-when-would-i-need-to-use-the
11:32:24 <joco42> anyone wants a slice of the cake ?
11:34:28 <obadz> > fromIntegral (3 :: Word) :: Int
11:34:31 <monochrom> what is cake pattern?
11:34:31 <lambdabot>  3
11:34:59 <obadz> This goes from Word to Integer to Int which feels inefficient. Is there a better way other than unsafeCoerce ?
11:35:43 <Cale> http://okmij.org/ftp/Haskell/ScalaCake.hs oh good, oleg got there first
11:36:16 <obadz> Also looks like there are {-# RULES #-} ⇒ http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Real.html#fromIntegral
11:36:16 <monochrom> how do you know it goes through Integer?
11:36:22 <obadz> which might avoid going through Integer
11:36:31 <obadz> monochrom: implementation is fromIntegral = fromInteger . toInteger
11:37:30 <monochrom> how do you know that that line of code is always used, verbatim, without optimization or replacement that completely changes the machine code?
11:37:57 <monochrom> for example, have you look at the generated Core code? Cmm code? assembly?
11:38:01 <joco42> monochrom:  yeah
11:38:26 <joco42> Cale wrote it
11:38:45 <Cale> What did I write?
11:38:57 <joco42> what is the cake pattern
11:39:20 <Cale> monochrom asked, but I also had the same question
11:39:24 <joco42> ahh
11:39:35 <Cale> But Oleg answered in a helpful way
11:39:42 <Cale> with a Haskell implementation
11:39:43 <joco42> yes
11:39:44 <obadz> monochrom: I did not, but since Integers are arbitrary precision, it feels unlikely to my uneducated self that the compiler could decide to bypass it..
11:40:02 <monochrom> ok, look at Core code first
11:40:09 <monochrom> do not trust anything else
11:40:31 <joco42> i was told that large systems benefit from cake pattern
11:40:43 <obadz> does ghci apply rewrite rules?
11:41:25 <monochrom> so called "source code of base" contains so many #ifdef's and RULES's that unless you have completely all of base's source code and done your thorough global analysis (yes it has to be global), you completely don't know what the generated code looks like
11:41:43 <obadz> https://gist.github.com/obadz/12d3572c4615327c41f8 ⇐ getting y = 9 and expecting 12
11:42:00 <Cale> obadz: Yeah, there are rewrite rules in the libraries, not just in GHC
11:42:15 <Cale> {-# RULES ... #-} pragmas add rewrite rules to the optimiser
11:42:48 <Cale> So even if it doesn't optimise away the intermediate Integer, you could add a pragma which would make it do so.
11:43:14 <Cale> I believe there are a bunch of RULES for going between various common numeric types
11:43:24 <scshunt> obadz: are you compiling with -O
11:43:25 <Cale> But I could be wrong about that
11:43:31 <obadz> scshunt: just loading in ghci
11:43:54 <Cale> Yeah, you need to turn optimisations on.
11:44:03 <Gurkenglas> Does the optimizer turn "uncurry (NE.:|) . fromJust . uncons . NE.toList" into id?
11:44:23 <Cale> Gurkenglas: That is quite doubtful...
11:44:38 <Cale> But try it!
11:45:48 <obadz> I put {-# OPTIONS_GHC -fobject-code -O #-} in my file as suggested in http://stackoverflow.com/questions/27881725/how-can-i-load-optimized-code-in-ghci and triggered a ghc panic
11:46:46 <monochrom> I wouldn't put -O as a pragma. what's wrong with -O on the command line or as a .cabal/config setting?
11:46:57 <obadz> monochrom: I'm trying to play in ghci
11:48:25 <monochrom> ghci is going to be completely irrelevant to code optimization. or rather, code optimization is going to be completely irrelevant to ghci
11:49:10 <obadz> if I type :l blah.hs in ghci, it doesn't optimize blah does it?
11:49:11 <monochrom> in other words if your objective is to play with ghci, then you simply don't ask performance questions
11:49:28 <monochrom> and if your objective is to ask performance questions, then you simply don't play with ghci
11:49:33 <obadz> I wanted to see how rewrite rules work, apparently not an option in ghci
11:53:14 <geekosaur> ghci does not optimize
11:53:42 <monochrom> it doesn't even build assembly code
11:54:13 <obadz> understood
11:55:46 <monochrom> -fobject-code can tell ghci to build assembly code that it won't use
11:56:59 <monochrom> and ghci can use assembly code that it doesn't build. (to build, it has to be "ghc -c -dynamic")
11:57:36 <monochrom> overall -fobject-code is not how you convinced ghci to use optimized code
11:58:11 <monochrom> the world is really not simple or intuitive. you have to read the GHC user's guide cover to cover to see what it offers and doesn't offer.
11:58:47 <monochrom> and even then there are always a few important points they forgot to document
11:59:46 <monochrom> from least trustworthy to most trustworthy: yourself, user's guide, scientific evidence
12:17:45 <xa0> i need a function Bifunctor p => (a -> b) -> (c -> d) -> (p a e, p f c) -> (p b e, p f d)
12:19:58 <xa0> :t \x y -> bimap (first x) (second y)
12:20:00 <lambdabot> Bifunctor p => (b -> c) -> (b1 -> c1) -> p (b, d) (d1, b1) -> p (c, d) (d1, c1)
12:20:19 <xa0> er
12:20:21 <xa0> oh
12:20:38 <xa0> :t \x y -> bimap (Data.Bifunctor.first x) (Data.Bifunctor.second y)
12:20:39 <lambdabot> (Bifunctor p, Bifunctor p1, Bifunctor p2) => (a -> b) -> (b1 -> c1) -> p (p1 a c) (p2 a1 b1) -> p (p1 b c) (p2 a1 c1)
12:20:49 <xa0> yeah
12:20:50 <xa0> okay
12:22:28 <Sornaensis> okay
12:23:31 <xa0> @pl \x -> Data.Bifunctor.bimap (Data.Bifunctor.second x) (Data.Bifunctor.first x)
12:23:31 <lambdabot> liftM2 Data.Bifunctor.bimap Data.Bifunctor.second Data.Bifunctor.first
12:24:44 <Sornaensis> what is the easiest way to generate a list comprehension like: [[a,b,c,d] | a <- list, b <- list, c <- list, d <- list, someConstraint a b c d]
12:24:54 <Sornaensis> but for any sized list n>1
12:25:09 <athan> Sornaensis: Like a `guard`?
12:25:31 <Sornaensis> well the issue is nesting the (>>=) I guess
12:25:42 <Sornaensis> hrmm
12:25:56 <athan> maybe something like `(\a b c d -> guard $ someConstraint a b c d) <$> list1 <*> list2 <*> list3 <*> list4`
12:26:19 <athan> or `guard ...... someconstraint` :D
12:27:48 <Sornaensis> HMM
12:29:02 * hackagebot aeson 0.11.1.3 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-0.11.1.3 (AdamBergmark)
12:29:04 * hackagebot cryptonite-conduit 0.1 - cryptonite conduit  https://hackage.haskell.org/package/cryptonite-conduit-0.1 (VincentHanquez)
12:29:06 * hackagebot octane 0.4.3 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.3 (fozworth)
12:33:06 <lazywriter> Question: https://gist.github.com/anonymous/8556c61cd04cedfe0aa8 <-- can you help me with the "EDSL / promoting value" part of this ?
12:34:06 <johnw> isn't "promotion" here just calling a value constructor?
12:34:23 <lazywriter> hmm
12:34:33 <lazywriter> so instead of writing "1+x", write (i 1) + (v x) ?
12:34:50 <johnw> you probably need something other than "+", but yeah
12:35:07 <lazywriter> johnw: assume I've hidden Prelude.+ and defined my own +
12:35:11 <johnw> ok then
12:35:16 <lazywriter> is it possible to write 1 + x, or do I have to write (i 1) + (v "x") ?
12:35:25 <johnw> what you're doing is constructed a parse tree to represent the expression "1 + x"
12:35:32 <lazywriter> we have overloaded strings extension
12:35:41 <lazywriter> I wnat "overlaoded Ints" to overload 1 alos as (MathExprInt 1)
12:35:52 <monochrom> what is the type of x?
12:36:17 <lazywriter> I want x to expand to ==> MathExprVar "x"
12:36:30 <lazywriter> I suspect some TH may have to be involved since "x" isn't globally defined
12:37:07 <johnw> sure, with TH you could do it, but that's just a compile-time equivalent to using Parsec on a string in this case; are you avoiding Parsec, or parsers?
12:37:20 <lazywriter> I don't want to do string => Haskell Expr
12:37:30 <johnw> any particular reason why?
12:37:33 <lazywriter> I've used Parsec before, but prefer to avoid it for this problem
12:37:36 <lazywriter> no, no valid reason
12:37:46 <lazywriter> I'd also like some flexibility in 'injecting' haskell 
12:37:56 <lazywriter> which seems easier if it's an EDSL and harder if it's Parsec :: String -> Expr
12:37:58 <johnw> so, you want to build a DSL for, say, do-notation, that feels like writing native expressions but instead yields parse trees
12:38:09 <lazywriter> johnw: yeah, precisely
12:38:14 <lazywriter> thanks for clarifying my unclear question
12:38:15 <johnw> x -> MathExprVar "x" will not be possible
12:38:20 <johnw> not in any general way
12:38:34 <lazywriter> okay suppose I define a bunch of "x_ :: MathExpr \n x_ = MathExprVar "x" "
12:38:41 <johnw> yeah, that will work
12:38:45 <lazywriter> how about the 'promoting 1' ?
12:38:47 <johnw> I do exactly the same thing for my own case of this
12:39:15 <johnw> I'm not sure about that, I've never tried to overload ints themselves
12:39:24 <johnw> I usually create a wrapper like "int 1"
12:39:31 <johnw> int 1 + var "x"
12:39:42 <johnw> makes for better errors too
12:41:51 * shapr sneaks a copy of Borland C++ into johnw's briefcase
12:41:52 <mnoonan> cant you just give your MathExpr a Num instance to get promoted numbers?
12:43:11 <shapr> Who hosts lambdabot these days?
12:43:15 <monochrom> int-e
12:43:37 <shapr> int-e: are the various chunks of state saved online somewhere? quotes and all that?
12:43:40 <monochrom> are you going to sneak Borland C++ into lambdabot too? :)
12:43:44 <shapr> I want to run my own local copy of lambdabot
12:44:13 <shapr> monochrom: nope, I'm hoping to sneak lambdabot into my workplace so that people want to write plugins.
12:44:42 <APic> ,o0(„#pragma“)
12:45:23 <shapr> oh wow, someone has already created a lambdabot-slack repo on github
12:49:57 <int-e> shapr: not online, and yes I've been slacking...
12:50:40 <shapr> int-e: funny, I just grabbed lambdabot-slack
12:50:48 <shapr> does that mean that's your repo? :-)
12:50:50 <int-e> (I've made various excuses, the latest being to wait for ghc 8.0.1)
12:51:37 <lambda-11235> Cale: Sorry, internet cut out. If you were wondering why I suddenly left.
12:51:57 <johnw> shapr: haha
12:52:03 <johnw> shapr: what version?
12:52:13 <shapr> johnw: 1.0, of course
12:52:18 <johnw> oh, I didn't work on that one :(
12:52:27 <shapr> johnw: which ones did you work on?
12:52:35 <xa0> > let (%) = zipWith ((.(:[])).(:)) in putStrLn . map (toEnum . (+105)) . concat . uncurry (%) . join (***) concat . join B.bimap (uncurry (%)) . (B.bimap <$> B.second <*> B.first) (map (*4)) $ (([-8, 3], [4,-2]), ([4,1], [-73, 6]))
12:52:36 <johnw> Borland C++ 5.0, C++Builder 1.0-6.0
12:52:37 <lambdabot>  Not in scope: ‘B.bimap’Not in scope: ‘B.bimap’Not in scope: ‘B.second’Not in...
12:52:41 <xa0> aw
12:52:48 <johnw> on any of those, run bcc32 -Team :)
12:52:55 <int-e> hmm, actually making the state accessible should be easy... but I need to get away from work first (I don't have the right ssh key right now)
12:53:16 <int-e> @tell int-e make some symlinks ;-)
12:53:16 <lambdabot> You can tell yourself!
12:53:31 <int-e> meh :P
12:53:37 <int-e_> @tell int-e make some symlinks ;-)
12:53:37 <lambdabot> Consider it noted.
12:53:50 <Cale> lambda-11235: ah, that's all right -- did you see my responses?
12:54:07 <shapr> Last week my laptop burned my lap during my first run of "stack build" on some project with many dependencies. So I bought a laptop with a Xeon and 64GB of RAM, take THAT Haskell!
12:54:29 <Cale> shapr: hahaha
12:55:10 <int-e> shapr: No, I'm part of the "official" lambdabot team. I "just" need to get back to working on it.
12:57:26 <shapr> Cale: right now my maxed out ThinkPad W550s at work is crawling while I try to stack build lambdabot-slack
12:59:11 <squall> Im trying to write an alternative instance for a custom graph to use in an Unfoldable instance, i can easily implement cons an something like (++) but i struggle to create an applicative instance since i dont know how to create a graph of functions the same shape as the graph they are applied to. Can anyone help?
12:59:20 * hackagebot protocol-buffers 2.3.0 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.3.0 (k_bx)
12:59:21 * hackagebot protocol-buffers-descriptor 2.3.0 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.3.0 (k_bx)
13:00:06 <Cale> squall: What sort of graphs? I wouldn't expect arbitrary graphs to be Applicative
13:00:17 <Cale> at least, not in any straightforward useful way
13:00:48 <Cale> Maybe there's some kind of Kronecker-product-ish way to make things work out.
13:01:00 <squall> Its a list of indexed nodes and another list of pais of indexes indicating edges
13:01:05 <lambda-11235> Cale: Got it working. Thanks.
13:01:07 <johnw> Cale: why is that?
13:02:37 <Cale> johnw: Well, when you go to implement <*> and you have a graph labelled with functions and a graph labelled with arguments, how do you combine those two graphs? (Even just ignoring the labels... what should we do?)
13:02:42 <johnw> what about a graph of functions applied to a graph of values?  It would produce a resulting graph where every value node was expanded to new graph where every function node had been applied to it
13:02:43 <squall> Intersection would lazily evaluate an infinite graph used for pure
13:02:50 <johnw> and then merged
13:02:54 <Cale> I suppose you could form the Cartesian product of the graphs
13:03:02 <Cale> If you really wanted?
13:03:05 <johnw> I actually worked this out with Tikhon once
13:03:10 <johnw> let me see if i still have the code
13:03:19 <Cale> Or Kronecker product, yeah.
13:03:20 <shapr> sounds nifty
13:03:31 <shapr> I went to kronecker.com, but they didn't have the product I expected :-(
13:03:41 <Cale> heh
13:04:20 * hackagebot hprotoc 2.3.0 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.3.0 (k_bx)
13:04:24 <Cale> shapr: If you look up Kronecker product on wikipedia, you'll get something which talks about matrices, which you can think of as being the adjacency matrices for an operation on graphs
13:04:35 <johnw> Cale: https://github.com/jwiegley/notes/blob/master/Tikhon.hs
13:04:36 <squall> It assumes there is a bijection between the graph nodes
13:04:43 <johnw> and for the proofs: https://github.com/jwiegley/notes/blob/master/Tikhon.v
13:05:00 <johnw> to show that it's both an applicative and a monad
13:05:13 <Cale> That's a zipper...
13:05:20 <squall> Not sure im after the cartesian product
13:05:25 <johnw> it's a node, and all the incoming edges and the outgoing edges
13:05:32 <Cale> oh, okay
13:05:36 <johnw> not the most efficient graph representation
13:05:40 <johnw> but it's what Tikhon was working with
13:06:00 <Cale> So not on the whole graph, but on each context
13:06:08 <Cale> That's interesting
13:06:08 <johnw> I suppose so
13:06:16 <johnw> I should do the full graph version based on a more common representation
13:07:02 <Cale> johnw: You immediately run into the issue of which Contexts go with which. You can do all pairs, I suppose.
13:07:29 <johnw> exercise for the reader, maybe? :)
13:07:41 <johnw> I'm trying to dodge the nerd-snipe
13:07:59 <squall> Its a monad but i want the kroneker product but the cartesian product
13:08:02 <Cale> squall is talking about doing something zip-like, but I don't know what happens to edges in that case
13:08:22 <Cale> Kronecker product would make the most sense for edge-labelled graphs
13:08:34 <EvanR> so you can zip two graphs that have the same structure
13:08:57 <EvanR> with values on the nodes or the edges
13:09:00 <EvanR> or both
13:09:04 <squall> cons relables the index of the appended node by adding the largest node index to it
13:09:29 <EvanR> so an indexed family of graph types
13:09:35 <EvanR> indexed by graph structure
13:10:14 <Cale> oh, I guess Kronecker product works for vertex-labelled graphs too
13:11:01 <squall> [(a,Int)] [(Int,Int)]
13:11:59 <xa0> bifunctors are arrows right?
13:12:05 <Cale> Applicative is a whole lot easier to handle than Monad in that regard, but I think you might be able to get a Monad even.
13:12:24 <Cale> But is it useful even a little bit? I don't know.
13:12:45 <squall> My plan is to generate an infinite graph to use as pure using unfold, which uses <|>
13:13:20 <squall> <*> would take the intersection
13:13:21 <Cale> Yeah, that's the trouble with the zipping strategy
13:13:43 <Cale> Is you need to deal with infinite graphs... which means you don't have the nice efficient Map representation.
13:14:02 <xa0> have you tried comonads?
13:14:20 <nitrix> first :: k a1 a2 -> k (a1, b) (a2, b)
13:14:20 * hackagebot h-gpgme 0.4.0.0 - High Level Binding for GnuPG Made Easy (gpgme)  https://hackage.haskell.org/package/h-gpgme-0.4.0.0 (rethab)
13:14:24 <nitrix> first :: (a1 -> a2) -> p a1 b -> p a2 b
13:14:31 <nitrix> xa0: There's a minor difference.
13:14:36 <Cale> xa0: Hughes' Arrows are Bifunctors, not the other way around.
13:14:43 <xa0> ah.
13:14:47 <Cale> Er, Profunctors, rather
13:14:47 <xa0> thanks
13:14:50 <squall> Trouble? Whats the problem with the infinite graph as pure if <*> takes a fininte intersection
13:15:39 <Cale> (they might be called bifunctors in a categorical context, but wouldn't be instances of Bifunctor in Haskell -- they're contravariant in the first argument)
13:16:12 <xa0> gotcha
13:16:23 <squall> An Unfoldable Functor is a CoMonad?
13:16:25 <Cale> squall: Well, you can't represent an infinite graph using a Data.Map, so you need something more clever.
13:16:39 <Cale> I don't know what Unfoldable is.
13:16:45 <squall> Its just two lists
13:16:48 <xa0> neither
13:16:56 <squall> Of edges and nodes
13:17:27 <Cale> https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#t:Unfoldable -- are you talking about this recursion scheme shenanigans?
13:18:23 <squall> Unfoldable uses <|> to construct an infinite datastructure
13:18:51 <Cale> What?
13:19:14 <Cale> But yeah, lists of edges is a really poor representation performance-wise
13:19:31 <squall> For list <|> = (++)
13:19:43 <Cale> Most of your operations that should be O(log n) or better will be O(n), and most stuff which should be O(n log n) will be quadratic time.
13:20:25 <squall> I can write an unfoldable instance for Data.Map
13:20:45 <Cale> What's Unfoldable?
13:20:50 <squall> So i can write an infite pure
13:20:59 <squall> Infinite*
13:22:02 <Cale> Are you actually using Ed's recursion-schemes package?
13:22:27 <nitrix> Cale: unfold :: Unfolder f => f a -> f (t a)
13:22:35 <Cale> wat
13:23:16 <Cale> oh, this? https://hackage.haskell.org/package/unfoldable-0.8.3/docs/Data-Unfoldable.html
13:23:23 <nitrix> Mhm :)
13:23:37 <squall> https://hackage.haskell.org/package/unfoldable-0.8.3
13:24:03 <Cale> Well, that's a little less scary
13:24:09 <squall> Yes
13:24:21 * hackagebot gitit 0.12.1.1 - Wiki using happstack, git or darcs, and pandoc.  https://hackage.haskell.org/package/gitit-0.12.1.1 (JohnMacFarlane)
13:24:46 <squall> choose = fold
13:25:10 <Cale> (I'm not convinced I'd use this library for real either ;)
13:25:46 <nitrix> The idea is nice, but when I look at the type constraint on Unfolder, it's ugly.
13:26:33 <squall> I am happy about it, it requires you specify an unfolder
13:27:24 <Cale> Unfolder looks like something which ought not to be a typeclass.
13:28:05 <Cale> Well, I dunno
13:28:10 <squall> But by default its only abstract function 'choose' is just fold using Alternative
13:28:15 <Cale> I guess there are good enough instances for a bunch of types
13:28:43 <Cale> But I'd expect to want more control there.
13:29:05 <squall> Its the package im writing infact
13:29:43 <Gurkenglas> Did I hear Alternative? http://lpaste.net/150858
13:29:45 <squall> So if you desire some functionality or syntax pease say
13:30:39 <Cale> Gurkenglas: hah, desperately
13:31:23 <Peaker> Gurkenglas: why Monad constraint/liftM instead of Functor/fmap?
13:32:13 <Gurkenglas> Peaker, (Functor m, Monad m) => Alternative (MaybeT m)
13:33:03 <cocreature> is there a nice way to let bind a set of values depending on a condition? I can put each of them in an if but then I end up repeating myself over and over because the condition is always the same
13:33:13 <squall> The idea is to use state monad or something to conrol the unfolding
13:33:17 <scshunt> cocreature: what do you mean?
13:33:18 <Peaker> Gurkenglas: AMP is here! :)
13:33:26 <scshunt> can you provide an example?
13:33:35 <Cale> squall: Oh, I see how you sidestep the need to provide choose as an explicit argument to unfold by picking f cleverly
13:33:40 <Peaker> Gurkenglas: where do you use the Monad constraint?
13:33:46 <Cale> squall: yeah
13:33:56 <Cale> hmm
13:33:58 <Gurkenglas> Peaker, this uses it https://hackage.haskell.org/package/transformers-0.5.1.0/docs/src/Control-Monad-Trans-Maybe.html#line-134
13:34:23 <Gurkenglas> We've gotta decide whether we execute effects on the right hand side of the <|> based on whether the left one failed
13:34:27 <cocreature> scshunt: I’m trying to translate some c code which uses something like http://lpaste.net/156161 and then has some code operating on those values. I suppose the best way is to extract that code in a function and then just call it once for each case
13:35:00 <Peaker> Gurkenglas: ah, I see. And you want pre-AMP support?
13:35:29 <Gurkenglas> Peaker, nah I wrote liftM instead of fmap there for the same reason I write (.) instead of fmap
13:35:53 <Gurkenglas> I'm lensing down into a data structure, and I know it's a monad, so I say liftM to help the reader
13:35:58 <squall> Wow how do you do that!?
13:36:10 <squall> The thing with (.)
13:36:37 <squall> Perhaps an unnescacary aside
13:36:37 <Peaker> Gurkenglas: (.) is a concrete type,  liftM should be deprecated :P  you only know it's a Monad instead of Functor, you still don't know which type it is
13:36:40 <scshunt> cocreature: hard to see what you're thinking of until you translate it to haskell
13:36:47 <scshunt> I am not sure I understand why you're talking about binds at all
13:36:58 <scshunt> these sorts of computations are pure, no need for a monad
13:37:18 <cocreature> scshunt: I was talking about let bindings
13:37:30 <Gurkenglas> Peaker, we can use (.) without knowing what types we have, to a point
13:37:52 <cocreature> I can do let iw = if cond then x else y
13:37:58 <cocreature> but I have four bindings each using the same condition
13:38:10 <Gurkenglas> Hmm. I wonder how much everyone's head would explode if we made (.) an infix alias for fmap
13:38:23 <squall> A foldable applicative has a bind, an unfoldable alternative has a cojoin?
13:38:24 <scshunt> cocreature: personally, I'd do the computation and then determine how to map it to values based on the condition
13:38:40 <scshunt> or you could use tuples
13:40:24 <squall> If i understand correctly my task is to write <*> where the arguments may be infinite
13:40:41 <cocreature> scshunt: what do you mean by “determine how to map it to values based on the condition”?
13:40:46 <squall> resulting from use of unfold
13:41:11 <Gurkenglas> ("As many as possible, but not none." <- the temptation to replace that with "As some as possible" is real)
13:41:43 <squall> Essentially its just ziplist
13:41:47 <scshunt> cocreature: e.g. let i1 = thumb, i2 = blah; if cond then iw = i1; blah; else ih = i1; blah
13:41:51 <squall> I think
13:43:10 <squall> Basically im just trying to write an Unfoldable instance for Data.Map
13:43:54 <squall> Can anyone confirm this?
13:45:07 <squall> Or if it exists already elsewhere in some other guise
13:45:39 <squall> (lens unfold...)
13:47:12 <squall> Ok ill post my attempt soon
13:53:35 <Darwin226> Hey guys, is there a way to constrain a HKT so it has to be a Monoid for any type it's applied to?
13:53:46 <Darwin226> So like Monoid (MyType a) => ...
13:54:11 <squall> For lists unfold :: ([a]-> a) -> [a]
13:55:24 <Enigmagic> Darwin226: yes, that should work
13:55:49 <Darwin226> Enigmagic: Yeah, the problem is I want this context as a class requirement
13:56:06 <Darwin226> and it wont let me since the type variable a isn't mentioned in the head of the class
13:56:21 <Enigmagic> Darwin226: put it on the instance instead?
13:57:00 <Darwin226> Enigmagic: Yeah, hopefully that will work
13:57:06 <squall> Its strange i had previously used monad to do my unfolding
13:57:21 <squall> Via join
13:57:23 <Darwin226> The thing is, my class is one of those Monad* classes so it kind of implies Monad
13:57:27 <barrucadu> Is it possible to provide two default definitions for a typeclass function: one using DefaultSignatures, which is preferred, and one fallback?
13:57:38 <barrucadu> My use-case is that I have a typeclass I'm trying to make it really easy to add transformer instances to
13:58:12 <Enigmagic> barrucadu: i don't think so, but i think there is an open ticket on trac to allow something like this.
13:58:22 <barrucadu> So if there's a suitable MonadBase constraint there I want to lift the definition in the transformed monad. But otherwise there's a fairly sensible default.
13:58:26 <barrucadu> Enigmagic: Aw. Oh well
14:01:42 <Darwin226> Ahhh this won't work. Ok guys I'd like some advice. My Monad* class is tagged with an extra parameter (similar to MonadState, MonadReader and so on)
14:01:54 <Darwin226> but I want one of the methods to be able to change that type
14:02:07 <Darwin226> How can I make this work
14:03:07 <scshunt> Darwin226: I think the answer you're looking for is GADTs
14:03:27 <Darwin226> scshunt: How do they help in this context?
14:03:58 <Darwin226> I'm having trouble with defining this as an interface. A specific instance implementation isn't a problem.
14:04:06 <scshunt> "interface"?
14:04:13 <scshunt> can you paste your code?
14:04:27 <Darwin226> Sure, let me just strip out the irrelevant details
14:06:50 <Ainieco> hello, im looking for paper where some cpp guy(probably stroustrup himself) describes his plans to bring in more haskell/fp features into cpp like some form of pattern matching with destructuring
14:07:11 <Darwin226> scshunt: Ok, check this out http://lpaste.net/5014160213960294400
14:07:14 <Ainieco> i just can't find it and can't think of right query maybe you've seen that paper
14:07:45 <lyxia> Darwin226: Have you considered making the typeclass accept something of kind * -> * -> * instead
14:07:46 <Darwin226> scshunt: So this is fine, but that last `m a` shouldn't really be the same type. It should be the same transformer or whatever, but he state type it's indexed with should be s2
14:08:19 <Darwin226> lyxia: Well, one problem is that I can't constrain it to a monad, but ignoring that I haven't managed to get the order right
14:08:21 <lyxia> Lens' s' s -> m s a -> m s' a or something
14:08:52 <Darwin226> lyxia: Yeah that'd be fine, but other than StateT, what other transformer would fit in that instance?
14:09:06 <Darwin226> lyxia: They don't have the state as their second parameter.
14:09:11 <Darwin226> *first
14:09:45 <lyxia> I think you'll need some kind of "Monad1" typeclass instead of Monad
14:10:05 <Enigmagic> or https://hackage.haskell.org/package/category-extras-0.52.1/docs/Control-Monad-Indexed.html
14:10:50 <lyxia> oh that's it Enigmagic!
14:11:00 <Darwin226> That still wouldn't help with other instances
14:11:03 <scshunt> Darwin226: see Control.Lens.Zoom
14:11:11 <scshunt> for an example of what you're trying to do
14:12:20 <Darwin226> I see. So I just have an extra monad parameter in the class head and then just use the same transformer when writing the instances
14:12:22 <Darwin226> Cool stuff
14:12:27 <Darwin226> I'll see how that works out
14:28:08 <Geraldus> Hi folks! o/
14:28:26 <Geraldus> Can I do with arrows following transformation (a -> b) -> (c -> d) -> (a, c) -> (b, d) ?
14:29:14 <Geraldus> More precise I want to (a -> b) -> (c -> d) -> m (a, c) -> m (b, d)
14:31:51 <scshunt> Geraldus: yes
14:32:01 <scshunt> just use *** and fmap
14:34:47 <Geraldus> scshunt: oh, I misread definition of Arrow class. a there is a value constructor, so in case of couples it is (,)
14:34:54 <Geraldus> thanks
14:35:06 <scshunt> yep
14:36:39 <obadz> so what's the reason we don't have an ML-style module system in Haskell? A lot of people seem to call for it.. is there a meaningful technical barrier to implementing it?
14:38:00 <hpc> type classes serve the same role
14:38:36 <obadz> hpc: similar but in practice not the same.. you wouldn't want to have a ByteString typeclass with ByteStringLazy and ByteStringStrict being the two instance..
14:51:23 <dolio> Type classes also make it non trivial to implement.
14:52:14 <scshunt> obadz: the way Haskell handles typeclasses would make that problematic
14:52:38 <scshunt> it would be a redesign of some bits of that to get working
14:52:41 <scshunt> not unsurmountable
14:52:45 <scshunt> but it can't just be a bolt-on
14:53:48 <obadz> can it be backward compatible?
14:57:14 <Enigmagic> obadz: also look at http://plv.mpi-sws.org/backpack/
14:57:28 <Enigmagic> i think they're still working on it
14:58:38 <Enigmagic> well i think ezyang is still working on it :p
15:01:12 <dolio> Unfortunately, the original paper is an example of something that ignores type classes. :)
15:01:16 <orion> In the unordered-containers package, I see the HashMap is an instance of Traversable: traverse f = traverseWithKey (const f) <-- What is the (const f) for?
15:01:44 <obadz> Enigmagic: do you know what the allude to as recursive linking in Haskell ?
15:02:29 <Enigmagic> obadz: i haven't read the paper, just saw a presentation at icfp a few years ago
15:02:39 <Enigmagic> and i don't remember much else :-)
15:04:55 <obadz> Enigmagic: can't find video :-/
15:05:33 <Enigmagic> obadz: https://www.youtube.com/watch?v=0dF9zuwTSTc
15:06:29 <obadz> Enigmagic: cool, thanks!
15:06:52 <thoughtpolice> obadz: It means that you can have modules that are mutually recursive while still allowing separate compilation. If you have a 'mixin' of M1 and M2, then the exports of each can be used to satisfy the imports of the other.
15:07:02 <thoughtpolice> The MixML paper talks about this a bit: http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43982.pdf
15:09:34 <thoughtpolice> Backpack has gone through several overhauls at this point. If you're brave, you can in theory use some signatures, etc today, like this - http://blog.ezyang.com/2014/08/a-taste-of-cabalized-backpack/. IDK how much as exactly changed.
15:14:24 <mvr_> is there a canonical "data Pair a = Pair a a" anywhere?
15:14:35 <scshunt> mvr_: (a,a)
15:14:48 <johnw> (a,a) isn't the same
15:15:02 <johnw> it's Functor instance only maps the second element, for example
15:15:04 <mvr_> wrong instance for Applicative, for example
15:16:40 <mvr_> I guess "Product Identity Identity" works
15:16:42 <johnw> mvr_: there's one in GHC.Pair
15:17:43 <mniip> jmm
15:17:44 <mniip> hmm
15:17:59 <mniip> is there a Join f a = Join (f a a) somewhere
15:18:33 <mniip> I'm pretty sure you could write Biapplicative p => Applicative (Join p)
15:44:07 <barrucadu> Is it possible to get the type of a function inside template haskell? I've got a function :: MonadTransControl t => (forall a. StT t a -> a) -> DecsQ, and I want to be able to splice that 't' into the declaration I am constructing
15:44:37 <barrucadu> I'm trying ot generate a typeclass instance, and the instance head is of the form "instance Foo (t m)", so I need that t
15:56:36 <jle`> mniip: there's one in type-combinators
15:57:25 <jle`> mvr_: there's one in linear, heh
15:57:33 <jle`> but i wouldn't call it canonical
15:58:39 <jle`> obadz: it ignores the key
15:58:48 <jle`> obadz: traverseWithKey (\k v -> f v)
15:58:58 <jle`> but (\k v -> f v) is const f
15:59:07 <jle`> it's (\k -> f)
15:59:49 <jle`> oops, that was for oron
15:59:54 <jle`> * orion 
16:00:57 <orion> Thank you jle`.
16:01:13 <jle`> np
16:12:03 <Darwin226_> so, this is a valid signature `(CanSignal '[Int, String] sigs, MonadSignal sigs m) => m ()`, but this isn't a valid type alias `type C sigs m = (CanSignal sigs sigs', MonadSignal sigs' m)`
16:12:09 <Darwin226_> Any way to get around that?
16:12:38 <Axman6> mention sigs' in the name of the type?
16:12:42 <Darwin226_> I mean I get that the sigs' variable appears out of nowhere but I only need it as a connection between the two constraints
16:13:09 <Darwin226_> Axman6: I could do that but it seems kind of pointless since in the original type signature sigs isn't mentioned outside of the context
16:14:11 <Darwin226_> Axman6: Currently the type reads like "if I have a sigs with this property, then m needs this property with respect to sigs"
16:14:46 <Darwin226_> Axman6: If I make it visible in the type alias it's confusing since the alias hides what the variable is for
16:19:31 <Axman6> but... does it work? :P
16:20:30 <Darwin226_> Axman6: Yeah
16:20:53 <Darwin226_> But now `(C '[Int, String] m sigs) => m ()` looks totally rediculous
16:21:03 <jle`> Darwin226_: what happens when you try type C sigs m = forall sigs'. (CanSignal sig sigs', MonadSignal sigs' m) ?
16:21:16 <jle`> (it probably won't work, just wondering)
16:21:16 <Darwin226_> jle`: Apparently that's an illegal constraint
16:21:21 <jle`> that is true
16:21:23 <jle`> oh well
16:22:30 <johnw> what about type C (sigs :: [Constraint]) m ...?
16:22:32 <nitrix> Does haskell has a quantifier for `exists` ?
16:22:45 <johnw> haskell's exists is done by use of forall
16:22:49 <Tendies> elem?
16:23:19 <nitrix> johnw: How come? Does universal quantification lets you do existantial?
16:23:23 <jle`> yeah, naked exists wouild be a bit weird
16:23:31 <jle`> but yea,h you can write existentials with forall's
16:23:32 <johnw> nitrix: yes
16:23:35 <nitrix> Oh I see.
16:23:36 <johnw> it's the same in Coq even
16:23:38 <Darwin226_> johnw: I'd like to hear more :D
16:23:40 <johnw> exists is implemented using forall
16:23:46 <johnw> data Exists = Exists (forall a. Num a => a)
16:23:51 <johnw> you can put any number in there
16:24:00 <johnw> but afterward, you can't know what the original type was
16:24:04 <johnw> only that it's a number
16:24:07 <nitrix> I see
16:24:10 <jle`> `exists a. a` => (forall a. a -> r) -> r
16:24:23 <jle`> so there's the translation :)
16:24:55 <akegalj> I am using HsOpenSSL for crypto. I would like to send RSAPubKey over the wire (https://hackage.haskell.org/package/HsOpenSSL-0.11.1.1/docs/OpenSSL-RSA.html#t:RSAPubKey) so I have to serialize/deserilize rsa public key. Wiki says I can distribute the keys by sending (n, e) key pair https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Key_distribution and I can get that with rsaN and rsaE from RSA.hs so 
16:25:01 <akegalj> serialization is not a problem, but how can deserialize now (ie create RSAPubKey) ? 
16:26:28 <Clint> i suggest not using HsOpenSSL
16:26:43 <akegalj> :/
16:27:19 <int-e> shapr: http://silicon.int-e.eu/lambdabot/State/ should cover the important (non-sensitive) lambdabot state files
16:28:10 <int-e> except there's a permissions problem, hmm
16:30:19 <jle`> johnw: wait, (forall a. Num a => a) is not (exists a. Num a => a)
16:30:31 <johnw> wrapped in a data constructor it is
16:30:42 <johnw> since data constructors are, actually, functions of a sort
16:31:45 <johnw> take your example: `exists a. a` => forall r. (forall a. a -> r) -> r
16:31:53 <johnw> that right-hand side is actually just final encoding of Identity
16:32:02 <johnw> so it's as if you had written Identity (forall a. a)
16:32:25 <johnw> or rather: data Identity' = Identity' (forall a. a)
16:34:31 * hackagebot hakyll 4.7.5.2 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.7.5.2 (JasperVanDerJeugt)
16:48:13 <lethjakman-l> So, I feel like this is related to a reader monad but isn't actually a reader monad. 
16:48:15 <lethjakman-l> https://github.com/lethjakman/yesod/blob/b6c21c56c0e368d7ea5cc89b75475410234e9a8f/yesod-core/Yesod/Core/Handler.hs#L928-L932
16:48:25 <lethjakman-l> Is it possible to thread things to that getRequest would work in handlerForm?
16:53:07 <nitrix> johnw: Small question, does that means that everytime one has existantial quantification, it's rank-2 ?
16:53:28 <nitrix> (or higher)
16:55:21 <johnw> nitrix: I think perhaps there's an interpretation where it's rank-2
16:56:12 <johnw> I'm not sure what GHC does inside when you use ExistentialQuantification, for example
16:56:27 <nitrix> Nevermind then.
17:00:50 <__Myst__> Hi
17:01:02 <__Myst__> I was wondering if there was a way to group together elements in a list even if they're unsorted
17:01:33 <__Myst__> such as, `somehowGroup [1, 2, 3, 2, 3, 1]` returning `[[1, 1], [2, 2], [3, 3]]`
17:01:37 <johnw> if speed is no concern, certainly
17:01:44 <__Myst__> johnw: No, no concern
17:01:51 <Enigmagic> easiest way: sort it first
17:02:20 <__Myst__> I thought about that
17:02:22 <__Myst__> Doesn't work
17:02:38 <johnw> I'm assuming you want somehowGroup [1, 3, 2, 2, 3, 1] to return [[1, 1], [3, 3], [2, 2]]?
17:02:43 <johnw> if the order doesn't matter, then yeah, sort it first
17:03:48 <Enigmagic> __Myst__: what do you mean by doesn't work?
17:04:05 <Enigmagic> > group . sort $ [1, 3, 2, 2, 3, 1]
17:04:07 <lambdabot>  [[1,1],[2,2],[3,3]]
17:04:47 <__Myst__> Enigmagic: Fixed it
17:05:04 <__Myst__> Basically, I was actually trying to sort some.. well data-types?
17:05:06 <__Myst__> I have no idea how to call them
17:05:20 <johnw> if you're sorting them, they're values
17:05:34 <__Myst__> Something around the lines of `Term Double [Double]` and needed to sort by that second `[Double]`
17:05:43 <__Myst__> (Wow, I suck at explaining.. this is why I usually ask other people to post code)
17:05:49 <Cale> You can sort values of a type which you defined, so long as there is an instance of Ord
17:06:39 <__Myst__> Cale: Yes, I know
17:06:41 <__Myst__> let me make some example code
17:08:19 <Axman6> there's also sortBy
17:08:22 <__Myst__> http://hastebin.com/kodejebiwo.hs
17:08:24 <__Myst__> Think this should work
17:12:52 <__Myst__> Anyways, thanks for the help!
17:12:55 <__Myst__> 0613:)
17:13:20 <__Myst__> Great.
17:13:34 <__Myst__> Now I have to figure out how to group by the sorted result but keep roder..
17:13:36 <__Myst__> order*
17:14:04 <Enigmagic> group/groupWith should preserve the order already
17:14:18 <__Myst__> "groupWith"?
17:14:31 <__Myst__> well
17:14:33 <Enigmagic> err groupBy
17:14:33 <__Myst__> I need a groupBy too
17:14:43 <__Myst__> but I need to preserve order of the unsorted list
17:15:02 <johnw> aha, I wondered if that would be a requirement
17:15:16 <__Myst__> johnw: Just figured out it is
17:16:57 <__Myst__> Anything I can do?
17:17:07 <__Myst__> I seem to be horrible at googling
17:17:30 <__Myst__> To be honest I'm trying to make a polynomial adder and trying to group together like terms to add them
17:19:33 * hackagebot octane 0.4.4 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.4 (fozworth)
17:37:15 <Enigmagic> __Myst__: yes, haskell can do that :p
17:40:27 <Cale> __Myst__: The usual way I like to do that kind of thing is using Data.Map
17:40:32 <Cale> :t M.fromListWith
17:40:34 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
17:40:41 <Cale> :t M.fromListWith (+)
17:40:42 <lambdabot> (Num a, Ord k) => [(k, a)] -> M.Map k a
17:41:18 <Cale> :t \xs -> M.fromListWith (+) $ zip xs (repeat 1)
17:41:20 <lambdabot> (Num a, Ord k) => [k] -> M.Map k a
17:41:32 <Cale> :t \xs -> M.toList . M.fromListWith (+) $ zip xs (repeat 1)
17:41:33 <lambdabot> (Num a, Ord k) => [k] -> [(k, a)]
17:41:52 <Cale> > (\xs -> M.toList . M.fromListWith (+) $ zip xs (repeat 1)) "abracadabra"
17:41:54 <lambdabot>  [('a',5),('b',2),('c',1),('d',1),('r',2)]
17:42:09 <lool`> How would I make a nonsilly `natToFin`? (i.e. one that actually picks the right number of `FS` depending on the input `Natural`) http://lpaste.net/156193
17:42:53 <Cale> Oh, preserving the order is a bit more obnoxious
17:43:08 <Enigmagic> not by much
17:43:56 <Cale> But yeah, once you've made a Map of counts, you can go revisit the original list
17:44:17 <Enigmagic> just zip with the position
17:44:22 <Enigmagic> no need to count anything
17:44:33 <Cale> zip what with the position?
17:45:10 <Enigmagic> the original list
17:45:15 <Enigmagic> zip xs [1..]
17:45:28 <Enigmagic> then you just need to preserve the minimum index/position when building the groups
17:45:52 <Cale> I thought the goal was to e.g. determine coefficients when collecting like terms in a polynomial without changing the order of initial occurrence of any given term
17:46:20 <Cale> Ah, I see what you mean
17:46:29 <sm> with shake, how do you ignore failing shell commands ?
17:46:30 <Cale> accumulate the minimum position along with the count
17:46:34 <johnw> > let xs = [1,3,4,2,2,1] in group (sortBy (\x y -> elemIndex x xs `compare` elemIndex y xs) xs)
17:46:42 <lambdabot>  [[1,1],[3],[4],[2,2]]
17:46:55 <Cale> hah
17:47:23 <Cale> comparing (`elemIndex` xs)
17:47:47 <Cale> (that's awful performance, but cute)
17:48:27 <johnw> > let xs = [1,3,4,2,2,1] in group (sortOn (`elemIndex` xs) xs)
17:48:36 <johnw> a little less bad, but still
17:48:36 <lambdabot>  [[1,1],[3],[4],[2,2]]
17:49:03 <Cale> yeah
17:49:05 <sm> ah, use command and force its type to be an Exit code I guess
17:53:47 <dibblego> what is the name of the fractional part of a real number, and does there exist a library for that?
17:55:16 <Hafydd> Given that the real numbers are not all computable, there probably isn't.
17:58:49 <mmachenry> dibblego: Fractional part and whole part is what I usually hear them called.
17:59:12 <mmachenry> dibblego: A library for doing what with them?
17:59:55 <dibblego> I think I have it figured, sorry, thanks
18:00:03 <mmachenry> np
18:03:35 <dmwit_> > (\xs -> map (M.fromListWith (+) [(x,1) | x <- xs] M.!) (nub xs)) "abracadabra"
18:03:37 <lambdabot>  [5,2,2,1,1]
18:04:34 <dmwit> > (\xs -> let counts = M.fromListWith (+) [(x,1) | x <- xs] in [(x, counts M.! x) | x <- nub xs]) "abracadabra"
18:04:36 <lambdabot>  [('a',5),('b',2),('r',2),('c',1),('d',1)]
18:07:04 <Zekka|Sigfig> So is there a good uncomputable reals library around?
18:07:06 <Zekka|Sigfig> Someone needs to get on that
18:08:00 <dmwit> lool`: Do you know how to make a value of type `KnownNat k => Maybe (Fin k)` which is `Just FZ` if `k>0` and `Nothing` otherwise?
18:08:22 <dmwit> lool`: If so, it's just a matter of recursing and applying `FS <$>`.
18:10:15 <Gurkenglas> > (\xs -> (map . second) length $ sortOn (last . snd) $ M.toList $ M.fromListWith (++) $ zip xs $ (:[]) <$> [0..]) "abracadabra"
18:10:18 <lambdabot>  [('a',5),('b',2),('r',2),('c',1),('d',1)]
18:10:29 <Gurkenglas> (Because nub is quadratic)
18:10:39 <lool`> dmwit: No, I get complaints about being unable to match `k` with `k0 + 1` if I try to call `FZ :: Fin n`
18:34:36 * hackagebot digit 0.2.5 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.2.5 (TonyMorris)
18:36:16 <athan> I vote that `<$>` should be pronounced "uniformly"
18:36:37 <athan> ..because.. uh... `over` is more general :D
18:42:00 <Enigmagic> lool`: i think it's easier to define FZ :: Fin 0 and FS ::Fin (K - 1) -> Fin k
18:42:20 <Enigmagic> oh
18:42:25 <Enigmagic> sorry reading the idris code now
18:42:26 <Enigmagic> :p
18:42:55 <Enigmagic> + doesn't work very well in ghc
18:43:53 <Cale> athan: I just pronounce it "fmap"
18:44:31 <EvanR> dont try to pronounce haskell you might hurt yourself
18:44:37 * hackagebot BlogLiterately 0.8.1.6 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.1.6 (BrentYorgey)
18:49:37 * hackagebot mockery 0.3.3 - Support functions for automated testing  https://hackage.haskell.org/package/mockery-0.3.3 (SimonHengel)
18:51:08 <Enigmagic> lool`: is this the type sig you were looking for? http://lpaste.net/156193
18:51:19 <Enigmagic> seems to work okay
18:53:58 <Enigmagic> isn't actually correct though :-)
19:09:39 * hackagebot octane 0.4.5 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.5 (fozworth)
19:30:04 <lambda-11235> Cale: Or just "map".
19:32:37 <Enigmagic> lool`: alright, now it works correctly (i think). this is why we don't use dependent types in haskell yet :-) http://lpaste.net/156193
19:32:50 <Enigmagic> unless you have a desire for pain, that is.
19:33:05 <EvanR> in the far future fmap replaces map (and the word map replaces the word fmap) in general functional vocab
19:36:44 <lambda-11235> EvanR: Do you mean there will be `class Functor f where map :: (a -> b) -> f a -> f b`, or the we'll use fmap on lists and depreceate map?
19:37:00 <EvanR> both
19:39:54 <lambda-11235> EvanR: I meant use the symbol `fmap` and depreceate the symbol `map`.
19:40:30 <EvanR> no 
19:40:33 <EvanR> other way around
19:41:15 <EvanR> i said both just to troll the unquoted use of "fmap" to mean same thing as future use of the word map
19:43:58 <lambda-11235> EvanR: fmap will be what they say when they get a type error from using `map`.
19:52:30 <maybefbi> im thinking of selling monads to my OOP coding friend as composable factories. would that be a fair characterization? i cant get him hooked using the actual definition even though i told him about everything it can abstract away
19:53:44 <bitemyapp> maybefbi: doesn't sound accurate.
19:53:49 <maybefbi> ok :(
19:54:05 <bitemyapp> maybefbi: you don't need to stretch or chase bling for Haskell to be compelling.
19:54:24 <maybefbi> yeah i learned it using the definition
19:54:25 <bitemyapp> maybefbi: it's just _nice_. That's it. Makes you faster, makes your work easier. There's no single 'trick', it's just the overall design / big picture that makes it so.
19:54:42 <EvanR> i monad is like a riddle wrapped in an enigma
19:54:50 <EvanR> a*
19:54:53 <lambda-11235> maybefbi: Try telling him a monad is a data structure that can contain one element, be mapped over, and flattened.
19:55:13 <EvanR> it might not be a data structure containing anything
19:55:19 <EvanR> example reader monad
19:55:43 <EvanR> cont monad
19:55:54 <lambda-11235> EvanR: That's were the example breaks done, but it's a start.
19:56:15 <EvanR> hrm... well providing an example and saying this is what it is... doesnt seem to work other areas
19:56:30 <EvanR> "imagine a monoid is like a rubicks cube"
19:56:36 <icicled> I don't think monads are a compelling reason to use haskell
19:56:51 <icicled> it's nice...but not the bees knees if you will
19:57:09 <EvanR> yes monads are like the side show
19:57:34 <EvanR> ... which kind of explains why they are more notable
19:57:41 <icicled> it's a powerful tool in the toolbelt but I don't them being used as often as [people outside the haskell community] make it out to be
19:57:47 <icicled> see them*
19:58:03 <shanemikel> okay, I'm switching to emacs.. what are people using to complement haskell mode to get autocompletion, live typechecking.. and type popup/tooltips on hover, things like that in emacs 
19:59:37 <Ashy> I hope you're using evil mode
20:00:03 <shachaf> Ashy: Please don't.
20:00:14 <shanemikel> yeah, I am
20:00:49 <shanemikel> I saw there's something called 'scion' but it looks abandoned
20:01:07 <icicled> shanemikel: I have had success with ghc-mod
20:01:36 <icicled> limited success
20:01:53 <icicled> it works great when there are no errors in the file
20:01:58 <icicled> but otherwise breaks down
20:02:08 <icicled> which I guess isn't its fault
20:02:15 <shanemikel> I have all that stuff working nicely in atom
20:02:27 <shanemikel> and I think it relies on ghc-mod for everything
20:03:34 <shanemikel> actually, lets focus on the live type-checking and type tooltips things.. because I know the autocompletion is implemented differently.. and it's less important to me
20:05:35 <shanemikel> oh, actually it looks like haskell-mode has support for autocompletion
20:13:16 <jackdalton> leave
20:13:18 <jackdalton> Whoops
20:14:12 <shanemikel> yeah, so inferior-haskell-type seems to be what I'm looking for
20:14:29 <shanemikel> I just have to figure out how to set it up and get the workflow right
20:15:04 <lq> http://shrinkmy.com/ZFmSN1C6
20:35:55 <Guest20020> Is it possible to run a single .hs file with stack without creating a project?
20:38:37 <jle`> Guest20020: yeah, stack runghc foo.hs
20:38:59 <jle`> or runhaskell
20:42:18 <lambda-11235> "A monad is like somthing you should never make an analogy for"
20:45:44 <EvanR> its not a problem with monads its a problem the pattern "a class foo is like <an instance of class foo>"
20:45:51 <Guest20020> thanks you lead me to what I needed: stack ghc -- x.hs -o x 
20:46:29 <EvanR> made worse when whats in < > is actually just nonsense instead of an actual example
20:48:12 <EvanR> its like rain on your wedding day
20:56:43 <Guest20020> It looks like .stack-work/ is full of system specific binaries. Is it reasonable to say it doesn't belong in git and should be in my .gitignore?
21:02:00 <MarcelineVQ> yeah that's where stack puts the objects and libraries it builds for a project so I'd put it in ignore
21:23:26 <MichaelK> Does anyone know where I can find the specification of the type theory used in Haskell?
21:31:41 <EvanR> MichaelK: the haskell report says "the [haskell] kernel is not formally specified"
21:32:08 <EvanR> which i would guess includes the type system
21:32:51 <EvanR> you can look up system F for a starting point
21:37:06 <MichaelK> EvanR: well that explains why I couldn't find it.. So the only way to find the actual type rules/implications is to read the source? 
21:37:50 <EvanR> no, ghc has a manual which explains each type system extension
21:37:58 <EvanR> the haskell report explains the base language
21:38:42 <EvanR> you probably want to start with the report before attempting to grok the ghc manual
21:39:25 <MichaelK> EvanR: great, thanks
21:55:54 <Squarism> are there any notable software written in haskell?
21:56:21 <EvanR> .oO(the c++ bot in ##c++)
21:57:20 <Squarism> Thats the second most used program after MS Word right?
21:58:38 <EvanR> .oO(ghc, agda, idris)
21:59:27 <shanemikel> Okay, it looks like flychecker is the plugin that does these things in emacs.. and it has backends for ghc-mod, hdevtools, and haskell-mode
21:59:47 * hackagebot BlogLiterately-diagrams 0.2.0.3 - Include images in blog posts with inline diagrams code  https://hackage.haskell.org/package/BlogLiterately-diagrams-0.2.0.3 (BrentYorgey)
22:00:10 <shanemikel> Squarism: a lot of programming language parsers/interpreters/compilers
22:01:23 <Squarism> i try to push haskell on Statistician at my work. I think it could be a perfect fit for them
22:01:54 <EvanR>  @faq can haskell do statistics
22:02:07 <EvanR> Yes it cant!
22:02:58 <Squarism> was that a joke? I missed it
22:03:11 <EvanR> used to be
22:04:19 <Squarism> Would be interresting to hear what the funny part - as in im curious
22:04:51 <EvanR> er, well i spelled "can" wrong
22:05:06 <EvanR> other than that, thats it
23:39:17 <xpika> Is there any difference between using an MVar Stream and a Control.Concurrent.Chan  ?
23:41:43 <EvanR> yes
23:42:11 <EvanR> you cant do writeChan on the MVar Stream
23:44:18 <xpika> what about modify with a ++ ?
23:44:33 <EvanR> Streams are infinite, so ++ doesnt do anything
23:46:06 <xpika> what about using a linked list then?
23:47:37 <EvanR> ah, then you may have invented a Chan
23:48:01 <EvanR> though inefficiently
23:48:15 <xpika> ok so in that sense channels are faster
23:48:40 <EvanR> theres a hierarchy of Chan speeds
23:49:05 <EvanR> this page has a picture whose colors cannot be disputed https://hackage.haskell.org/package/unagi-chan
23:51:22 <xpika> looks like when you read from a channel it deletes the data from memory too
23:52:06 <EvanR> i hope not
23:53:33 <xpika> reading is like a pop operation
23:53:37 <MichaelK> Is it possible to define a (non-trivial) data type (or class?) that distributes over (->)? So like "D (a -> b) ~ D a -> D b"?
23:57:03 <EvanR> it would be same if you used a list
23:57:35 <EvanR> MichaelK: sort of like a Functor ?
23:57:53 <EvanR> Functor f => f (a -> b) -> f a -> f b such that
23:58:00 <EvanR> ^ fmap ::
23:58:01 <EvanR> such that
23:58:10 <EvanR> fmap (f . g) = fmap f . fmap g
