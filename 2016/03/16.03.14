00:01:21 <Lokathor> so i have a line in a benchmark, (evalState (replicateM 10000000 (state System.Random.next)))
00:01:37 <Lokathor> i want it to run a RandomGen 10 million times
00:02:05 <Lokathor> but if you use that with nf from criterion, forcing the whole list all at once uses like 475mb of RAM
00:02:47 <Lokathor> Is there a better way to just cause the RNG to run 10 million times without having the list creation getting in the way?
00:03:54 <opqdonut> you could use e.g. last instead of nf
00:04:15 <opqdonut> the list should get fused away if you compile using optimizations
00:04:57 <Lokathor> using -O2, the list sure doesn't appear to get fused away
00:05:04 <Lokathor> maybe it will with last though
00:05:06 <EvanR> Lokathor: replicateM_ ?
00:05:25 <opqdonut> oh right, EvanR's suggestion is best
00:05:38 <Lokathor> that seemed to give me problems where all three RandomGen types took the exact same time becaue it wasn't actually forcing the right thing
00:06:12 <Lokathor> i'll double check on replicateM_
00:06:35 <opqdonut> Lokathor: also, use execState to get the modified RNG back
00:06:49 <opqdonut> Lokathor: using evalState with replicateM_ will you immediately give you ()
00:06:55 <Lokathor> wow that uses even more RAM with replicateM_
00:07:12 <Lokathor> it is not at all immediate
00:07:15 <Lokathor> but exec is a good call
00:08:36 <opqdonut> it also might be building up a huge thunk since you're not using the generated numbers
00:09:13 <Lokathor> yeah what it was doing, i suppose, was generating the entire list of 10 million results into memory
00:09:23 <Lokathor> which is, in fairness, what i told it to do after all.
00:09:23 <opqdonut> no, not necessarily that
00:10:11 <opqdonut> the most reliable way is to do something like "loop !rng 0 = (); loop !rng n = next rng `seq` loop rng (n-1)"
00:10:13 <Lokathor> well, execState and replicateM_ seems to be a bust, spiked to 3.7gb of memory used
00:10:17 <opqdonut> (I'm not sure I got that right)
00:10:35 <opqdonut> no, I didn't, next returns the generator too
00:11:21 <Lokathor> also appears to have lost it in an infinite loop somehow, or at least took way way longer than normal
00:13:13 <Lokathor> well, if it's too much to fiddle with it's not the worst. as long as all the different gen types are being sent through the same loop we can still compare the relative results
00:15:18 * hackagebot language-puppet 1.1.5.1 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.1.5.1 (SimonMarechal)
00:19:14 <Ferdirand>  
00:20:38 * hackagebot hesh 1.4.0 - the Haskell Extensible Shell: Haskell for Bash-style scripts  https://hackage.haskell.org/package/hesh-1.4.0 (ChrisForno)
00:34:06 <bajsa> I've never had the need for haskell, but I'm trying to find the need, but I can't. Can you help me? :p
00:34:27 <Hafydd_> Hahaha.
00:34:40 <Hafydd_> bajsa: why are you "trying to find the need" for Haskell?
00:34:57 <bajsa> Hafydd: i like useful things
00:35:12 <Pupnik2> there is no need for any computer language, another can always take its place.
00:35:19 <Hafydd> bajsa: but you currently believe that Haskell is useless, so why do you care about it?
00:36:19 <bajsa> Hafydd: you're an idiot. I never said I beleive its useless.
00:36:30 <srhb> bajsa: That's a bit harsh.
00:36:54 <bajsa> srhb: I know by experience that it cuts out all the bullcrap pretty fast, saves both me and others time.
00:37:10 <srhb> bajsa: Well, you should still behave nicely towards others in here. :)
00:37:44 <Hafydd> bajsa: but you've "never had the need for" Haskell, so as far as you know, it is useless. What makes you think there is a "need" to find?
00:37:45 <bajsa> srhb: the next thing someone like that would typically say is "but you are free to use whatever you want" and other irrelevant blander. That's not useful, that's PMS.
00:37:57 <shachaf> Yes, this behavior is not acceptable.
00:38:20 <bajsa> thank you shachaf, that's why I tell people to be more on topic.
00:38:29 <srhb> bajsa: PMS?
00:38:40 <bajsa> srhb: lets move on. (postmenstrual syndrome)
00:38:46 <srhb> Uh, okay...
00:38:47 <shachaf> bajsa: Your behavior is not acceptable. If you keep it up you won't be able to participate in this channel.
00:39:04 <bajsa> shachaf: drop it, lets move on
00:39:47 <bajsa> Hafydd: but you've "never had the need for" Haskell, so as far as you know, it is useless.". No, that sentence make no sense, what is there to build upon a false statement.
00:40:13 <Hafydd> bajsa: which part of it do you disagree with. You surely can't disagree with the antecedent, because that's exactly what you said.
00:40:16 <Hafydd> *?
00:40:17 <bajsa> Hafydd:  "What makes you think there is a "need" to find?". Again, you're making an AWFUL LOT of assumptions here. I'm trying to find one, I'm not saying that there is or isn't one.
00:40:45 <Hafydd> bajsa: I see; well, my question is: why are you trying to find a need?
00:41:14 <Hafydd> bajsa: or why does the fact that you "like useful things" motivate you to do this?
00:41:29 <bajsa> Hafydd: may I ask how that's relevant?
00:41:55 <Hafydd> bajsa: it's relevant to me understanding your question.
00:42:00 <bajsa> It's an open-ended question :)
00:42:09 <bajsa> Where's the need for haskell
00:42:12 <Hafydd> bajsa: and I am just interested to know, because your question is unusual.
00:42:52 <bajsa> Hafydd: I like useful thing (I can't for my life see how you infered "dont' think haskell is useful" by that sentence)
00:43:31 <bajsa> use your imagination, it's an open-ended question. People usually have opinions of their own (rather than being obsessed by made up ones of mine)
00:43:38 <srhb> Haskell gives you a lot of tools for analyzing the correctness of your programs. A lot of people find that useful.
00:43:52 <Walther> in the same way as human species started developing tools in ancient pre-history, the same quest for improvement goes on now. Haskell is pioneering the programming world, inventing new things for the programming world
00:44:54 <bajsa> that sounds interesting Walther
00:45:59 <bajsa> srhb: are those tools more robust or something than the corresponding tools for say C++?
00:46:32 <Hafydd> Haskell has non-strict evaluation built into the language, which allows many useful abstractions, such as infinite lists (cf. generators) to be expressed effortlessly and succinctly.
00:46:40 <Walther> Haskell is also very good at making you think in new ways, and that will help you with other languages too
00:46:44 <srhb> bajsa: I think so, yes. There aren't really that many corresponding tools in C++ land, it's a product of the stronger type system in Haskell.
00:47:40 <Hafydd> I like it just because it is pleasurable to write programs in, compared to other languages.
00:47:55 <merijn> Instead of dragging this out, let me point out that this entire discussion is, poorly, trying to restate Hughes' "Why Functional Programming Matters"
00:48:14 <Walther> :)
00:48:18 <merijn> http://worrydream.com/refs/Hughes-WhyFunctionalProgrammingMatters.pdf
00:48:56 <bajsa> Hafydd: sorry for being rude earlier (it's not ok). Sounds like there could be a lot of abstraction and make the programs smaller
00:49:21 <Hafydd> Although that's probably a good thing to read, the question isn't quite about "functional programming."
00:51:59 <oherrala> Haskell has spoiled other programming languages for me. Difficult to feel comfortable with anything else any more
00:51:59 <merijn> Hafydd: Justifying Haskell from an FP perspective is simpler. It's one of the better designed, more popular, and actively evolving ones :)
01:17:30 <ner0x652> Hi!
01:18:25 <ner0x652> What blogs, forums do you reccomend/follow on Haskell and/or FP?
01:22:53 <Horv> bajsa: Also, is your question "For what is haskell useful" or more "Why is FP useful?"
01:27:54 <quchen> ner0x652: The "24 days" posts by ocharles are a pretty good overview of cool libraries.
01:28:06 <quchen> … and the most popular language extensions.
01:29:15 <ner0x652> quchen: thanks :)
01:29:21 <liste> ner0x652: there's https://planet.haskell.org/
01:29:26 <simony> ner0x652: not blog nor forum, but I get quite a bit from Twitter
01:29:30 <liste> and a lot of other awesome blogs too
01:30:11 <ner0x652> liste: simony: thanks :)
01:31:20 <cocreature> the haskell reddit is also fairly good as a blog aggregrator
01:32:22 <jle`> yeah, i usually just subscribe to blogs i see pop up on the subreddit
01:32:48 <simony> and along those lines, some stuff also pops up on lobste.rs (both Haskell and FP)
01:35:40 * hackagebot heist 0.14.1.2 - An Haskell template system supporting both HTML5 and XML.  https://hackage.haskell.org/package/heist-0.14.1.2 (DougBeardsley)
01:37:23 <EvanR> lambda_foo: oops, youre not lambdabot
01:38:27 <cnr> Hi, I'm using a library on stackage that doesn't export an internal module containing a data constructor I'd like to use. What are some solutions short of contacting the library author? (My current "solution" is to unsafeCoerce an equivalent ADT (yuck). Hoping there's a more appealing option for the short-term.)
01:38:31 <Horv> merijn: There's several keynote versions from John Hughes on Why FP matters aswell: https://www.youtube.com/watch?v=Z35Tt87pIpg
01:39:52 <EvanR> cnr: fork the library, reconsider that that might be a bad idea
01:39:57 <mgsloan> cnr: You can use TH to break that restriction https://hackage.haskell.org/package/true-name
01:40:24 <EvanR> whoa
01:42:57 <icicled> Does someone here use tasy-hspec?
01:43:37 <icicled> tasty-hspec *
01:44:30 <icicled> I'm looking for an example of how to actually use it - the code for the package doesn't have an example
01:45:20 <naevathecat> Super quick question (I'm being a newb) converting a custom data type to Data.Text.Text
01:45:57 <liste> icicled: do you know how to use tasty or hspec on their own?
01:46:07 <liste> naevathecat: go ahead
01:46:30 <icicled> liste: yes, I have tasty working with hunit (following the example on the docs)
01:46:47 <icicled> tasty-hspec exports: testSpec :: TestName -> Spec -> IO TestTree
01:46:56 <liste> icicled: write your hspec tests and graft then into your tasty TestTree using that
01:47:12 <naevathecat> So if I was going to string I'd just define some instance of show, what's the equivalent for Data.Text?
01:47:39 <liste> naevathecat: just write a "MyType -> Text" function
01:47:58 <icicled> liste: I'm trying to graft the hspec test to the TestTree but as you can see "testSpec" returns in IO
01:49:29 <liste> icicled: then you need something like "main = do { myTests <- testSpec mySpec; defaultMain myTests }"
01:49:33 <naevathecat> liste: The Text constructors are all in terms of Char or String though, so I'd be going MyType -> String -> Text which suffers the same performance hit of just using String?
01:50:19 <liste> naevathecat: https://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text-Lazy-Builder.html
01:51:01 <solirc> icicled: If you want to use Hspec, I recommend to use it standalone
01:51:09 <liste> naevathecat: there's also standard builders for numeric types
01:51:21 <icicled> liste: looks like I'll have to do just that 
01:51:50 <icicled> liste: I was confused as to *why* "testSpec" returns in IO
01:51:50 <solirc> icicled: e.g. you get hspec-discover and source location for failing tests if you do so
01:52:16 <naevathecat> liste: Thanks :)
01:52:18 <icicled> gotcha
01:53:03 <icicled> a small note on the docs or in the code would be helpful!
01:54:34 <W4RH4WK> hey, is there an easy way to compose views to match on multiple elements, using Sequence Int, I am currently at:  (viewl -> 0 :< (viewl -> EmptyL))
01:56:03 <fr33domlover> Anyone knows how I can in Darcs (1) rollback/remove a patch that isn't the last one (2) manually fix any conflicts (3) get clean history in which that patch doesn't exist anymore?
01:56:05 <lpaste> tdammers pasted “How do I fix this warning?” at http://lpaste.net/154663
01:56:17 <tdammers> ^ I'm getting this here
01:56:51 <tdammers> but making it forall conn. IConnection conn => ... says that that's invalid syntax
01:57:34 <W4RH4WK> ::188
02:15:49 <marrrk> How can I easily create a Docker image that just runs my stack project?
02:22:24 <mgsloan> marrrk: The documentation on this is light, but http://docs.haskellstack.org/en/stable/yaml_configuration/#image
02:22:54 <mgsloan> (the detailed "Docker integration" section of the docs covers the docker build integration, but not the image creation stuff
02:23:11 <marrrk> yeah that's what it looked like to me
02:23:48 <marrrk> So the executables are passed to the container already then?
02:24:26 <mgsloan> Yep
02:24:41 <marrrk> They won't be started automatically, though, right?
02:24:51 <mgsloan> right
02:25:07 <marrrk> maybe I don't want that either, I'm not sure.
02:59:29 <sbrg> 3
03:06:22 <quchen> W4RH4WK: You can define your own viewing functions in such cases
03:06:56 <W4RH4WK> quchen, i just discovered pattern synonyms which seems to be an adequate solution
03:14:16 <quchen> W4RH4WK: While you're at it, have a look at pattern guards as well
03:14:23 <quchen> (Those are standard, even)
03:14:50 <W4RH4WK> quchen, thanks, i already use them in a different module
03:30:41 <W4RH4WK> pattern x :<: xs <- (viewl -> x :< xs)   together with   infixr 5 :<:   works like a charm 
03:44:19 <unit73e> hey
03:44:39 <unit73e> why doesn't cabal have colors? was it a conscious decision?
03:45:24 <merijn> unit73e: Keeps the dependency footprint low, I'm guessing
03:45:42 <merijn> unit73e: You need to bootstrap cabal by hand if you're not using a package manager. So it's preferable to have not to many dependencies
03:46:39 <unit73e> merijn: ok, makes sense. thanks.
03:46:47 <tdammers> also, priorities, I guess
03:47:05 <merijn> I think there were some people working on, e.g. ghci-ng and stuff adding Quality of Life improvements to ghc
03:47:22 <unit73e> that would be nice
03:47:24 <tdammers> "add colored output to build system? make build system better at resolving dependencies? which one should I spend my limited time on?"
03:47:29 <merijn> I think stuff like colouring outputs, etc. is the kinda stuff that makes for good beginner projects
03:47:54 <merijn> The core contributors of ghc/cabal don't have time/focus on my critical issues, but I don't think anyone objects to this stuff, if done carefully
03:48:04 <merijn> s/my//
03:48:18 <merijn> no clue where that word came from :p
03:49:11 <unit73e> I think there are too things that retract newbies. No autocomplete like Eclipse and friends (or at least I didn't find any obvious thing like that) and no colors.
03:49:43 <unit73e> but I didn't do anything to fix it so I'm just complaining
03:49:48 <merijn> unit73e: Well, at least you know a good first project now ;)
03:49:49 <unit73e> :P
03:50:03 <unit73e> yeah I thought about it
03:50:12 <tdammers> "if lack of auto-completion and colored build output are show stoppers to you, then you don't deserve Haskell!"
03:50:14 <tdammers> :x
03:50:34 <unit73e> there are not but it would be a very nice to have
03:50:39 <merijn> tbh, I think many people overestimate the difficulty of contributing to GHC/cabal. There's some hairy bits, but most of the real complexity is stuff like the type checker.
03:51:15 <merijn> The haskell style used in GHC is fairly simple and readable and since it's all purely functional it's easier to dive in then other large projects, because you can always tell where stuff is coming from :)
03:51:47 <tdammers> fwiw, it's still possible to write super obscure Haskell
03:51:51 <tdammers> pure functional or not
03:52:31 <merijn> Sure
04:05:47 * hackagebot jump 0.0.0.0 - Nothing to see here, move along  https://hackage.haskell.org/package/jump-0.0.0.0 (MichaelSnoyman)
04:06:01 <exio4> merijn: "most of the complexity comes from things which are complex (by design)"? 
04:29:20 <marrrk> So there is this: https://github.com/freebroccolo/docker-haskell
04:29:38 <marrrk> It says iteratively developHaskell application with a Dockerfile utilizign the build cache:
04:29:43 <marrrk> Does that work with stack as well?
05:01:35 <quchen> merijn: GHC isn't really "purely functional". Most of the typechecker is directly in IO.
05:01:51 <merijn> quchen: IO is purely functional
05:01:58 <quchen> Not that discussion again.
05:02:12 <quchen> You have mutable, implicit state. Call that what you want.
05:02:46 <merijn> Last time I looked at the typechecker there was IO, but no shared state, just file operations
05:03:00 <quchen> What I mean is that many of the benefits of purely functional code aren't very present in the typechecker, at least in my experience.
05:03:40 <merijn> They are in my experience, (close to) all state is passed in through function arguments/reader instead of twiddling MVars all over the place
05:04:15 <quchen> Maybe the difficulty contributing is overestimated, but I don't think it's in the class "easy to contribute".
05:04:24 <quchen> On the other hand, I would really like to see colours in GHC(i).
05:04:36 <quchen> (It's on my long-term todo list ...)
05:05:27 <quchen> merijn: Many functions in the typechecker have types (...) -> TcM (). I think that's pretty intransparent, because almost anything could happen in TcM.
05:05:47 <quchen> Well, anything *could* happen in TcM; the knowledge what could not happen is implicit.
05:07:22 <quchen> Now that you've called the typechecker the "real complexity", I wonder what the rest of GHC looks like. Maybe some of the things I liked to do but never actually did are easier! :-)
05:13:40 <jophish> Is it possible to print the version of an installed package from within ghc?
05:14:10 <merijn> jophish: "ghc-pkg list"?
05:16:05 <jophish> merijn: I have a suspicion that ghci is using a different package than ghc-pkgs reports due to some Nix shell shenanigans 
05:17:01 <merijn> jophish: Sounds like a question for Nix, then?
05:17:29 <jophish> yeah, I thought that getting the version straight from ghci would clear things up
05:19:54 <Jinxit> a bit more mathy than haskell, but can you think of a way to rewrite P(g(G(chi), P⁻¹(x, Z(x))) using function composition? (.)
05:19:57 <Jinxit> maybe it's too messy
05:21:02 <Jinxit> P, g, G and Z are all functions, P⁻¹ is the inverse of P
05:21:13 <quchen> You can't write all values using only function composition.
05:21:14 <liste> @pl P(g(G(chi), P'(x, Z(x))
05:21:14 <lambdabot> (line 1, column 11):
05:21:14 <lambdabot> unexpected ","
05:21:14 <lambdabot> expecting variable, "(", operator or ")"
05:21:20 <liste> @pl P(g(G(chi), P'(x, Z(x)))
05:21:20 <lambdabot> (line 1, column 25):
05:21:20 <lambdabot> unexpected end of input
05:21:20 <lambdabot> expecting variable, "(", operator or ")"
05:21:26 <liste> I fail :<
05:21:34 <Jinxit> yeah it's not haskell formatted
05:21:35 <quchen> If you're asking whether there's a point-free version of that function, then yes. But pointfree is rarely useful.
05:22:08 <Jinxit> yeah I guess that's true
05:22:40 <jophish> @pl (\x chi -> (P(g(G(chi), P'(x, Z(x)))))
05:22:40 <lambdabot> (line 1, column 39):
05:22:40 <lambdabot> unexpected end of input
05:22:40 <lambdabot> expecting variable, "(", operator or ")"
05:23:09 <quchen> ?pl \p g gg chi p' z x -> p (g (gg chi) (p' x (z x)))
05:23:10 <lambdabot> (. flip (flip . ((flip . (((.) . (.) . (.)) .)) .) . (.)) ap) . (.) . (.) . (.) . (.) . (.)
05:23:35 <jophish> straight after thinking "liste really should have tried that out first as a PM to lambdabot"
05:24:11 <Jinxit> I mean the functions are fixed
05:25:00 <jophish> @pl \chi x -> p (g (gg chi) (p' x (z x)))
05:25:00 <lambdabot> (p .) . (. ap p' z) . g . gg
05:25:12 <thomie> jophish: try ':show linker'
05:26:00 <jophish> thomie: that doesn't seem to show any packages but base
05:26:09 <Jinxit> but yeah that still looks awful
05:28:06 <LordBrain> i think point free should only be used when it actually improves readability, which it does on some rare occasions
05:28:50 <LordBrain> if you're using hlint, turn off that hint
05:29:54 <lokien_> @quote train
05:29:54 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
05:30:29 <sagittarian> chocolate robots, mmmm
05:31:00 <Jinxit> LordBrain: yeah in this instance it's not even for haskell code, just math in a paper, and I was curious to see if someone could find a better way to rewrite it
05:31:05 <LordBrain> chocolate robots sounds like a great product really, potential to outsell those little bunnies
05:31:09 <Jinxit> because the expression is pretty daunting as it is already
05:34:16 <LordBrain> well, even if you cleaned it up, it wouldn't really add clarity
05:34:40 <LordBrain> just make it easier to tell how the parenthesis match up
05:35:09 <LordBrain> cleaning it up would just put some onus on the reader to unravel your higher level definitions likely
05:35:36 <LordBrain> not that i have a clue, as i don't know what you are writing and such
05:35:56 <{AS}> That function :|
05:36:07 <LordBrain> my only point is that just making something look pretty and concise doesn't actually make it easier to grok
05:36:51 <JagaJaga> `toAdd :: forall a . AuthClient '[JSON] a -> AddM a` What does ' mean in '[JSON]?
05:37:13 <LordBrain> AS, i know but topically, he might want to emphasize one part of the function over another, and he could do that by tucking some stuff away using a definition of an operator or something.
05:37:29 <xmons>  https://www.reddit.com/r/softwareswap was killed. what is the alternative?
05:38:33 <Jinxit> yeah I'm making it slightly simpler
05:38:45 <Jinxit> but I can't really get away with much more
05:44:27 <jophish> JagaJaga: it means it's a promoted constructor
05:44:43 <jophish> in this case, '[JSON] is a type level list, a singleton containing just the type JSON
05:46:18 <JagaJaga> jophish: thank you
05:47:16 <thomie> jophish: make sure the package you're interested in is actually loaded and linked. For example: > :m Data.Map, > empty, > :show linker, shows containers-0.5.7.1 for me
06:04:16 <WeaponX> hi all, what is the iHaskell equivalent of ghci.conf / ~/.ghci ?
06:05:10 <WeaponX> I basically want a few imports and definitions to already be available when I open up a fresh new iHaskell notebook
06:10:53 <jophish> thomie: ah, great, thanks
06:44:08 <clintm> How do you all migrate persisted data once the types that define it change?  For instance, if I have a database full of 'Customers' and down the road, 'Customers' needs to have a new field added, are there any elegant options for still being able to read the entries that haven't been updated to the new version yet, or am I far better off running migration scripts that add the new fields?
06:44:59 <johnw> clintm: a package like persistent can do this automatically
06:45:09 <johnw> but you didn't specify the kind of persistence
06:45:41 <clintm> johnw: right, and I certainly like persistent, but we've been leaning, for this particular application, toward couchdb or riak.
06:46:14 <clintm> and I realized I've never had to solve this problem before.  Persistent was always there for me in my time of need. hehe
06:46:42 <johnw> the "traditional" way to do it is with a VERSION table, and an ever-growing script that manually migrates from version to version
06:47:16 <johnw> every time you change the schema, you update the version and update the migration script for that change
06:47:21 <clintm> johnw - yea, that's probably best in the end, rather than trying to play fast and loose with the data.
06:48:38 <clintm> I should take a look at persistent again.  I seem to remember some experimental, or maybe by this time not so experimental, couchdb support.
06:51:04 <Nux_> hi I'm having trouble with the Data.Time.Clock module. it doesn't seem to be exporting diffTimeToPicoseconds
06:53:36 <Nux_> In the meantime, does anyone know an easy way of fetching some multiple of the number of seconds since an arbitrary point in time according to my system clock as a Double?
06:53:52 <geekosaur> sounds like you are not using the most current version
06:54:11 <Nux_> of ghc? 7.10.3
06:54:44 <liste> Nux_: of the `time' package
06:55:28 <Nux_> hmmm
06:55:36 <geekosaur> it should be exported in time-1.5.0.1 that is a ghc bootlib, though
06:56:06 <geekosaur> it's not in time-1.4.0.1 (ghc 7.8)
06:56:08 <Nux_> I'm using cabal install time
06:56:30 <Nux_> hopefully this will fix my issue, but am I right in saying this should be bundled with haskell?
06:56:37 <geekosaur> (also exported in time-1.6 per the haddock)
06:57:07 <liste> Nux_: you mean it should be in base?
06:57:27 <quchen> Nux_: Run `ghc pkg-list time` to see your version.
06:57:38 <geekosaur> hyphen in wrong place?
06:57:44 <geekosaur> ghc-pkg list time
06:57:46 <quchen> Oh, yes.
06:58:12 <Nux_> ok well apparently I did need to just install the latest version of 'time'
06:58:36 <Nux_> I don't remember explicitly installing that, so I'm assuming I have it through a dependency
06:58:43 <quchen> Time comes with GHC.
06:59:10 <Nux_> well it apparently didn't come with GHC as the latest version
06:59:29 <geekosaur> [14 13:55] <geekosaur> it should be exported in time-1.5.0.1 that is a ghc bootlib, though
07:00:05 <Nux_> I saw what you wrote geekosaur, but I'm not sure what a bootlib is
07:00:10 <geekosaur> (I checked ghc 7.10.3 which you claimed to have. https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ shows time-1.5.0.1 with that function exported)
07:00:19 <geekosaur> a library that is used by, and therefore comes with, ghc
07:00:33 <Nux_> I'm not sure what happened with my installation then
07:01:04 <quchen> What does `ghc --version` say?
07:02:03 <Nux_> "The Glorious Glasgow Haskell Compilation System, version 7.10.3"
07:02:09 <Nux_> that is what I used to check my version
07:02:20 <quchen> And what's the result of `ghc-pkg list time`?
07:02:52 <quchen> It should point inside your GHC installation path, not ~/.cabal.
07:03:35 <Nux_> C:/Program Files (x86)/Haskell Platform/7.10.3\lib\package.conf.d:
07:03:37 <Nux_>     time-1.5.0.1
07:03:39 <Nux_> C:\Users\TSCAdmin\AppData\Roaming\ghc\i386-mingw32-7.10.3\package.conf.d:
07:03:40 <Nux_>     time-1.6
07:04:11 <Nux_> say hello to my directory structure btw
07:05:02 <Nux_> so is the first couple of lines there my original installation version?
07:05:33 <Nux_> if so it seems like I had that version but it didn't properly export what it was supposed to
07:06:46 <quchen> I'm out of ideas in this case :-|
07:07:35 <Nux_> hmm
07:07:54 <geekosaur> could mean that an older version was "cabal install"ed, possibly as a dependency of something else
07:08:02 <Nux_> I've just noticed I have 'Haskell Platform' in both Program Files and Program Files (x86)
07:08:22 <Nux_> could this be caused by me having multikple installations
07:08:33 <Nux_> in case you haven't guessed already, I'm on Windows
07:08:46 <geekosaur> ghc 7.10.3 will not (and can not) use versions of things built for 7.8.x
07:08:57 <geekosaur> (or other ghc versions in general)
07:09:16 <Nux_> ah
07:09:45 <Nux_> btw, this function was the only one I found in that package that hadn't been exported
07:09:56 <geekosaur> if you somehow got it to see them then it would throw an internal error reading the .hi file
07:09:56 <Nux_> others such as the inverse function were exported fine
07:10:24 <geekosaur> it was the only function I noticed as having been added since ghc 7.8.3/4's version of the time package
07:11:28 <Nux_> strange
07:13:06 <Nux_> HaskellPlatform-7.10.3-i386-setup.exe was what I installed with
07:13:40 <Nux_> I also have a couple of earlier installers here sitting around
07:13:45 <Nux_> HaskellPlatform-2014.2.0.0-i386-setup.exe
07:13:50 <Nux_> HaskellPlatform-2014.2.0.0-x86_64-setup.exe
07:14:57 <Nux_> I have struggled to get things to install in the past. I don't remember removing the time package specifically but there's a chance I didn't this by accident
07:15:22 <Nux_> is it worth investigating to see if something hasn't been logged correctly?
07:17:55 <Nux_> ignoring all of that, now that I have a NominalDiffTime, how do I get a DiffTime?
07:18:38 <ertes> Nux_: you don't, because they represent different things
07:19:11 <Nux_> due to NominalDiffTime ignoring leap-seconds?
07:19:17 <ertes> yes
07:19:36 <ertes> there is actually no correct way to convert between them on most systems
07:19:56 <Nux_> I guess I'm looking in the wrong place
07:20:02 <ertes> i just joined; what are you trying to do?
07:21:25 <Nux_> if I can get access to system clock ticks since epoch I'll be happy
07:21:40 <ertes> what is a "clock tick"?
07:22:05 <Nux_> some kind of measure of time as understood by my computer
07:22:06 <ertes> you can certainly get the number of nanoseconds since the epoch
07:22:14 <Nux_> It doesn't need to be too exact
07:22:39 <ertes> it's going to be pretty precise anyway =)
07:22:47 <ertes> i recommend using the 'clock' library for that, though
07:22:55 <ertes> getTime Realtime
07:23:16 <ertes> that gives you nanoseconds since the epoch with some system-specific accuracy
07:23:50 <Nux_> clock library? as in I should grab a package e.g. 'cabal install clock'?
07:23:59 <Nux_> or do you mena Data.Time.Clock
07:24:01 <Nux_> *mean
07:24:17 <ertes> the former, or you should make your package dependent on 'clock', if it is cabalised
07:24:30 <ertes> that gives you System.Clock
07:25:25 <Nux_> by 'cabalised' do you mean I have set up some sort of '.cabal' file
07:25:30 <Nux_> I have little experience with this
07:25:54 * hackagebot hpdft 0.1.0.4 - A tool for looking through PDF file using Haskell  https://hackage.haskell.org/package/hpdft-0.1.0.4 (keiichiroShikano)
07:25:58 <ertes> Nux_: yes…  it's pretty easy to get started: just use 'cabal init'
07:26:31 <Nux_> fair enough, but one thing at a time
07:26:57 <ertes> you can just install it as a user package for now:  cabal install clock
07:27:49 <ertes> Nux_: even then you're going to get a nominal difference though
07:27:50 <Nux_> so now what do I import after installing clock?
07:28:02 <Nux_> better yet, where do I find out for myself?
07:28:03 <ertes> if you actually want the time even counting leap seconds you need to use TAI
07:28:17 <ertes> you import System.Clock
07:28:23 <ertes> https://hackage.haskell.org/package/clock-0.6.0.1/docs/System-Clock.html
07:28:51 <ertes> i still don't know what your application looks like, but are you sure you need the time since the epoch?
07:29:07 <ertes> because that one is nominal…  it means that sometimes there will be a second jump
07:29:31 <ertes> if you need something that doesn't jump (for example for a game or a simulation), then what you really want is the monotonic clock
07:29:47 <ertes> getTime Monotonic
07:36:39 <Nux_> fair enough, cheers ertes
07:36:46 <Nux_> I'll  try that when I have chance
07:37:07 <Nux_> I didn't understand that from the 'ignores leap-seconds' description in the other module
07:38:50 <Nux_> I interpreted 'nominal ignores leap-seconds' as 'your observation of nominal time is unaffected by whether a leap second occurs or not'
07:39:19 <darkmercenary> hey, i have a problem im working on at work. I'm trying to perform some calculation but I would like it to timeout if it takes longer than a certain time to perform
07:39:21 <ertes> Nux_: exactly the opposite…  in nominal time every day is defined to be 86400 seconds long
07:39:35 <darkmercenary> I was thinking something like data Computation a = Finished a | Timeout
07:39:41 <ertes> so if there is a leap second, you will observe either a repeated second or (much more likely) a jump
07:39:52 <darkmercenary> and runWithTime :: a -> Computation a
07:40:01 <darkmercenary> but im not sure how to proceed
07:40:11 <ertes> darkmercenary: there is System.Timeout
07:41:58 <darkmercenary> ertes, thanks! ill try it right now
07:42:09 <ClaudiusMaximus> darkmercenary: it'd better be   runWithTime :: TimeLimit -> a -> IO (Computation a)  but you have to be careful about strictness too, you could construct a  Finished a  where the a has a large unevaluated computation
07:43:36 <Sornaensis> how do I make ghc do my taxes for me
07:43:38 <Sornaensis> pls help
07:43:56 <darkmercenary> id have to put control deepseq on top as well then too right
07:44:23 <ertes> Sornaensis: you import hledger into GHCi and write a ledger file =)
07:47:48 <puregreen> can I somehow make ekg-generated stats available as another page in my Spock application?
07:52:16 <Nux_> ertes, I guess I was wrong to assume that as the diff function for nominal times ignores leap-seconds, so does nominal time itself. I take it that the documentation is being clear that, though leap seconds may have occurred, these are known to the diff function that only knows the start and end points and how much time would have occurred between if no leap-seconds had occurred
07:52:47 <Nux_> ertes, 'aren't known to the diff function
07:53:34 <ertes> Nux_: think of NominalDiffTime as a time difference that assumes days to be exactly 86400 seconds long, so if it's 15:00 and you add a day, you will be at exactly 15:00 again
07:54:04 <ertes> that's why a nominal difference in seconds from the epoch will *not* be the number of seconds since the epoch
07:54:10 <ertes> that's TAI
07:54:24 <ertes> but again ask yourself what you need it for
07:54:41 <ertes> most applications don't really need to concern themselves with this
07:55:05 <Nux_> ertes, yes I'm not going to use nominal time, you're right that it's a bad choice
07:55:25 <Nux_> I'm just checking the stuff I wasn't sure about before
07:55:38 <ertes> Nux_: if you wouldn't mind explaining your application, maybe i can give you a direction
07:56:16 <Nux_> ertes, I don't have an end goal in mind at the moment. I'm just playing
07:57:19 <ertes> Nux_: i see…  consider playing with an actual application then…  it helps =)
07:57:29 <ertes> like a tea timer vs. an alarm clock
07:57:57 <ertes> those two seem very similar, but they need vastly different clocks
07:58:47 <Nux_> ertes, to be exact, I'm playing with my own 3D rendering software written in haskell making use of SDL2 bindings
07:59:09 <Nux_> my interest in time is with a view to 3D simulation
07:59:21 <ertes> so you need time deltas between frames?
07:59:30 <Nux_> that sort of thing
07:59:46 <ertes> then you'll want the monotone clock, because all others jump
08:00:00 <Nux_> yes, thanks I understand that now
08:02:22 <ertes> i could use this opportunity to advertise my library for time arithmetic:  https://hackage.haskell.org/package/timelike
08:03:03 <ertes> it allows to express things like: "the next second" or "next hour" easily…  things that are usually very difficult to do with time/clock
08:03:35 <ertes> and it has actions to wait for certain points in time (rather than certain durations)
08:05:52 <marrrk> How do I get rid of this code repetition? 
08:05:54 <marrrk> server :: SqlBackend -> Server API
08:05:54 <ertes> a 'time' interface (timelike-time) is done and production-ready, and i'm hoping to release a 'clock' interface this week (timelike-clock)
08:05:54 <marrrk> server connection = getPlantsHandler   connection
08:05:56 <marrrk>                :<|> getPlantHandler    connection
08:05:57 <marrrk>                :<|> updatePlantHandler connection
08:05:57 <marrrk>                :<|> deletePlantHandler connection
08:06:50 <ertes> marrrk: let (f .<|> g) x = f x :<|> g x in ...
08:07:29 <ertes> alternatively, if you like brain-teaser-code: let (.<|>) = liftA2 (:<|>) in ...
08:13:28 <purelazy> ertes: Any examples of doc?
08:13:38 <purelazy> of = or
08:13:51 <mniip> @hoogle liftA2
08:13:53 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:14:21 <mniip> or am I misinterpreting the question
08:14:32 <marrrk> the first one is already brainteasery enough for me
08:17:46 <Akii> can anyone recommend me a book for learning haskell?
08:17:56 <rom1504> yes
08:18:02 <andromeda_galaxy> What would the performance impact be of using StateT to keep track of STRefs?
08:18:06 <purelazy> @pl server connection = getPlantsHandler   connection :<|> getPlantHandler    connection :<|> updatePlantHandler connection :<|> deletePlantHandler connection
08:18:06 <lambdabot> server = ap ((:<|>) . ap ((:<|>) . liftM2 (:<|>) getPlantsHandler getPlantHandler) updatePlantHandler) deletePlantHandler
08:18:16 <Akii> rom1504: correct answer!
08:18:16 <ertes> purelazy: for my library?  the haddocks should explain it, and if they don't, please let me know =)
08:18:47 <ertes> purelazy: https://hackage.haskell.org/package/timelike-0.2.0/docs/Data-Time-Class.html
08:18:59 <Akii> what's a good book for learning haskell?
08:19:31 <purelazy> @pl (\connection -> getPlantsHandler   connection :<|> getPlantHandler    connection :<|> updatePlantHandler connection :<|> deletePlantHandler connection)
08:19:32 <lambdabot> ap ((:<|>) . ap ((:<|>) . liftM2 (:<|>) getPlantsHandler getPlantHandler) updatePlantHandler) deletePlantHandler
08:19:44 <andromeda_galaxy> purelazy: /query lambdabot?
08:21:51 <purelazy> Akii: wikibooks
08:22:00 <Nux_> ertes, off-topic but you said "it allows to" where did you pick that grammatical usage of 'allows' up? I've been seeing people say that more and more often yet I'm pretty sure it's not standard English
08:22:15 <andromeda_galaxy> Akii: there seem to be a lot of opinions on that...
08:22:27 <Akii> andromeda_galaxy: thought so, hence the question
08:22:55 <andromeda_galaxy> Akii: I haven't used it myself, but I've heard a lot of good things about this one:
08:22:58 <andromeda_galaxy> @where haskellbook
08:22:58 <lambdabot> http://haskellbook.com
08:23:26 <Akii> ah the gigantic expensive one
08:24:04 <andromeda_galaxy> Akii: there's a comparison that I personally found useful at http://bitemyapp.com/posts/2014-12-31-functional-education.html, but I don't know if it's still totally up to date
08:24:13 <Akii> purelazy: thanks!
08:24:33 <purelazy> Akii; http://mabboux.pagesperso-orange.fr/informatique/haskell/en/Tutoriel/Wikibooks-Haskell.pdf
08:24:49 <purelazy> Akii: 290 pages should keep you busy
08:25:10 <Akii> purelazy: the one from wikibooks is 600 pages long
08:25:26 <Akii> I also have LYAHFGG
08:25:27 <purelazy> Akii: How can I get that?
08:25:32 <andromeda_galaxy> Akii: I used Hutton + LYAH + RWH whatever actual code I could find + enforced absence from #haskell to learn, but I wouldn't really recommend it...
08:25:41 <purelazy> The 600 page version
08:25:44 <Akii> purelazy: https://upload.wikimedia.org/wikipedia/commons/2/26/Haskell.pdf
08:26:23 <andromeda_galaxy> Akii: in the form of lecture notes instead of a book, my experience agrees with the assessment tha the cis194 course is quite good as a first introduction
08:26:40 <ertes> Nux_: i'm not a native english speaker (german), so allow i me the one or the other grammatikal error =)
08:26:42 <purelazy> Akii: For monads http://www.randomhacks.net/2007/03/12/monads-in-15-minutes/
08:26:50 <ertes> Nux_: i guess "allows one to" would be more correct
08:27:16 <darkmercenary> so from earlier, this is what i ended up writing.
08:27:18 <andromeda_galaxy> (back to my other question for a moment: more generally, what's the accepted way of keeping track of STRefs?  Most ST examples that I can find do everything in one function, but I'd like to try replacing a StateT with an ST for performance reasons)
08:27:34 <darkmercenary> runWithTime :: (NFData a) => Int -> a  -> IO (Maybe a)
08:27:35 <Nux_> ertes, I by no means wish to punish you for a mistake, I'm just genuinely curious
08:27:43 <darkmercenary> runWithTime i comp = timeout i (evaluate (force comp))
08:28:02 <darkmercenary> evaluate from Control.Exception and force from Control.DeepSeq
08:28:42 <Nux_> ertes, I'd be interested to know if it's mostly speakers of English as a second language that use that strange grammar
08:28:43 <darkmercenary> and timeout from system.timeout
08:29:38 <darkmercenary> this should be what im looking for right? i want the computation to be fully evaluated and if it takes too long, return Nothing
08:29:45 <Nux_> ertes, I would agree that 'allows one to' would be correct grammatically
08:30:04 <ertes> Nux_: no offense taken…  i don't know where i picked it up, but it doesn't even sound that weird to me
08:30:43 <Nux_> ertes, interesting... cheers!
08:30:56 * hackagebot clash-lib 0.6.12 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.12 (ChristiaanBaaij)
08:30:58 * hackagebot clash-ghc 0.6.12 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.12 (ChristiaanBaaij)
08:31:27 <purelazy> <andromeda_galaxy> /query lambdabot? Eh?
08:31:44 <ertes> alright, see you later =)
08:32:08 <andromeda_galaxy> purelazy: when you have lots of @pl, etc. operations it's usually considered polite to /query lambdabot and then work in there, so the main channel doesn't get everything
08:33:26 <purelazy> <andromeda_galaxy> OK. Great. Thanks
08:33:44 <andromeda_galaxy> purelazy: np
08:37:58 <gromak> Is there wai middleware which can help me to redirect GET request to localhost/ to localhost/index.html?
08:43:56 <johnw> gromak: isn't that a pretty simple route to setup manually?
08:46:21 <GLM> Is there a way in the "stack test" command to specify a proxy?
08:49:48 <gromak> johnw: is it proper way? http://sprunge.us/QfGF
09:02:18 <fr33domlover> Q: I'd like to generate a random integer between 1 and N with strong randomness and where N can be very big (much much more than what Int64 can hold). Aside of using HsOpenSSL, is there a Haskell way to do that? perhaps cryptonite allows it?
09:02:47 <fr33domlover> I'm just not exactly sure yet, but before I go very deep into the code, maybe someone already knows? :)
09:02:53 <nitrix> fr33domlover: Haskell has a Random Integer instance.
09:03:39 <fr33domlover> nitrix, but can I rely on it for crypto as much as I can rely on OpenSSL's BigNum random number generation?
09:04:14 <nitrix> It's a pseudorandom generator.
09:04:37 <nitrix> If you want to do cryptography, there are probably better libraries out there.
09:04:40 <mnoonan> looks like Random Integer just does Random Int with some toIntegers thrown in
09:04:55 <fr33domlover> I want to be sure I'm not weaking the crypto of the package I'm patching :P
09:05:03 <fr33domlover> (the 'ssh' package)
09:05:53 <nitrix> You want a cryptographically secure pseudorandom number generator then.
09:06:42 <fr33domlover> nitrix, yes, i suppose so. The 'tls' package does it somehow I believe, but I know too little about crypto to be confident
09:07:48 <nitrix> fr33domlover: Haven't looked yet, but maybe https://hackage.haskell.org/package/crypto-api-0.13.2/docs/Crypto-Random.html
09:07:50 <nitrix> Or similar.
09:11:27 <unit73e> why does SDL2 use Text instead of String?
09:12:16 <maerwald> for what?
09:12:28 <unit73e> to create a window
09:12:38 <unit73e> https://hackage.haskell.org/package/sdl2-2.1.1/docs/SDL-Video.html#v:createWindow
09:13:05 <geekosaur> String is disrecommended for all but the simplest uses
09:13:05 <bergmark> unit73e: it makes more sense to ask the converse, why would it accept String instead of Text?
09:13:44 <unit73e> because it's just a title? is text more powerful than string?
09:13:52 <bergmark> yes it handles unicode better
09:14:09 <geekosaur> it handles pretty much everything better
09:14:17 <maerwald> unit73e: you can also use SDL.Raw.Video if you dislike the types I guess
09:14:22 <maerwald> then you have CString
09:16:31 <unit73e> it's not that I prefer String it's just that I didn't know why Text was used
09:16:44 <unit73e> so it is common to use Text instead of String right?
09:17:09 <maerwald> for text
09:17:32 <unit73e> and this too OverloadedStrings?
09:18:03 <unit73e> why not simply use Text for every case?
09:18:23 <maerwald> pattern matching is more easy with String I think
09:18:53 <unit73e> ok
09:18:57 <geekosaur> the Haskell standard is a bit long in the tooth, and specifies the overly simplistic and inefficient String type. we've since come up with Text which is much better, but because of the standard the compiler will still use String for literals. so OverloadedStrings is a compiler extension allowing it to use literal strings as Text instead of String
09:19:04 <maerwald> and web stuff often uses ByteString
09:19:51 <unit73e> ok so it is just a legacy quirkiness
09:19:52 * geekosaur suspects Text pattern matches could be converted to view patterns or w/e, if someone writes it
09:19:55 <geekosaur> yes
09:19:56 <unit73e> fair enough
09:20:25 <nitrix> Almost. OverloadedStrings doesn't just allow string literals as Text.
09:20:40 <maerwald> geekosaur: except they seem to confuse the compiler and you sometimes get wrong warnings about non-exhaustive pattern matches
09:20:44 <nitrix> It generalize string literals with IsString type class.
09:20:54 <maerwald> depending on what you do ofc
09:21:21 <maerwald> or maybe that was PatternSynonyms
09:21:33 <nitrix> Same way that number literals are generalized as :: Num a => a
09:21:38 <geekosaur> yeh. I think that is a known bug, but trying to fix it led to ghc 8.1rc1's exploding exhaustivity check
09:21:44 <maerwald> hah
09:21:55 <geekosaur> er exhaustiveness
09:24:08 <unit73e> maybe haskell 2018 will forget about String
09:24:11 <unit73e> :p
09:24:17 <Ke> heh
09:26:11 * hackagebot json-autotype 1.0.13 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-1.0.13 (MichalGajda)
09:26:16 <geekosaur> well, the haskell committee kinda fell apart. there's been an attempt to set up a new one but I have not heard much activity on that front
09:28:15 <johnw> I haven't either
09:28:23 <johnw> I thought we'd found enough volunteers, but then what happened?
09:29:14 <fr33domlover> nitrix, thanks
09:30:23 <unit73e> fell apart?
09:30:34 <unit73e> so there's no committee anymore?
09:31:36 <geekosaur> yes. after haskell 2010 they were to meet at least yearly to decide if a new version of the standard was warranted and what it should include. iirc they met in 2011 and 2012 and decided nothing was needed, then there was no 2013 meeting and none since
09:32:11 <unit73e> ok that's new to me
09:32:41 <unit73e> Text is utf-16... isn't utf-8 better?
09:33:35 <simpson> Depends.
09:33:59 <simpson> UTF-8's better for encoding, but UTF-16 tends to be much faster when you have lots of non-ASCII characters.
09:34:02 <sphinxo> Are types first class in haskell?
09:34:23 <geekosaur> to be fair, most of the things that are stable enough to be standardized are actually somewhat problematic (notably, MultiParameterTypeClasses needs either functional dependencies or type families, type families were found to not allow some things fundeps are currently used for... and in exploring that it was realized that fundeps allow them because fundeps are not actually safe)
09:34:40 <geekosaur> sphinxo, in what sense?
09:35:10 <simpson> geekosaur: Well, they're not called "safedeps"~
09:35:46 <sphinxo> something like http://lpaste.net/7960113200370810880 geekosaur 
09:36:36 <unit73e> well those things can be fixed
09:36:41 <unit73e> eventually
09:37:55 <unit73e> I guess SDL2 guys just stuck to Text for everything since it is apparently better
09:38:45 <unit73e> thanks
09:41:15 <gromak> How can I get Text.Blaze.Html.Html from file? Pandoc doesn't work unfortunatelly
09:46:47 <freeside>    /msg NickServ VERIFY REGISTER freeside sjpaudfokgmr
09:46:49 <freeside> ahem
09:47:13 <freeside> right, where was i.
09:48:29 <simpson> Resetting your password?
09:48:53 <EvanR> its a trap
09:49:26 <ggole_> Fairly long, randomish... not a terrible password, really.
09:49:46 <dolio> It's not as good as hunter2.
09:52:32 <icicled> all I see is ******
09:52:35 <icicled> must be my password
09:53:02 <simpson> icicled: Oh, your password is *******. I mean, hunter2.
09:54:20 <geekosaur> sphinxo, in what sense?
09:54:31 <desophos>  /msg nickserv verify register desophos hunter2
09:54:50 <geekosaur> there's an OO sense where, since everything "must" be an object, types are also objects (that is, live in value space). This is not true in Haskell.
09:55:21 <geekosaur> But types have their own space and increasingly this space supports many of the operations that value space does.
09:56:12 <desophos> geekosaur: is that good or bad? seems like supporting operations on types would make the type system more flexible/powerful?
09:56:22 <desophos> not that i know what it means to operate on types :)
09:56:46 <simpson> Also there's a great few pearls that show off various ways to reflect types safely, if all you want is the reflection.
09:57:31 <geekosaur> desophos, that would be why type level programming is a thing and becoming more powerfull all the time
09:58:28 <EvanR> desophos: sometimes you dont want power, in the sense of unsafeCoerce, unchecked pointer arithmetic followed by dereference
09:58:32 <geekosaur> what isnt there is treating types as values or values as types (the latter being dependent typing); there's tradeoffs there, since allowing values and types to mingle freely means you lose a lot of compile time type checking / type safety
09:58:49 <EvanR> a language construct that could possibly freeze if you use it the wrong way
09:59:23 <desophos> shouldn't have gotten involved in this conversation, i don't even understand type level programming
10:00:44 <geekosaur> I don't really understand it either, to be honest
10:00:45 <EvanR> a pervasive facility to check the type of objects at runtime arbitrarily when there is no need to
10:01:10 <geekosaur> (and yes, this means I'll answer what seems to be a simple question related to type level stuff and suddenly find myself in the deep end)
10:03:34 <thoughtpolice> sphinxo: No, you currently can't write that in Haskell today. Interestingly, you will be able to write that in GHC 8.0, but only at the type level! Not the value level. 
10:04:55 <dolio> Can't you already write it at the type level?
10:05:35 <jle`> well, there are already ways to do type-level calculations at the value level -- turn types to values, manipulate the values, move them back to types -- though it can be a bit cumbersome
10:05:45 <jle`> (in response to the original question)
10:06:17 <juanca_> Hi everyone, i have a question since i'm writing a parser for specific files. I want to use conduit
10:06:30 <juanca_> is parsec a recommendable library
10:06:36 <juanca_> for that purpose
10:08:13 <dolio> Yes, you can write essentially that in 7.10.
10:08:17 <thoughtpolice> dolio: Oh, yes, you can. Duh. (In 8.0, you can actually have something more dependent. Clearly I was cross eyed, just a minute ago)
10:09:49 <thoughtpolice> Well, 'more dependent'. You can just have something like 'F (a :: b) (c :: a)', which isn't what the question was about (so, irrelevant).
10:11:24 <EvanR> just drop the value level 
10:11:31 <EvanR> now we have dependent types
10:11:41 <EvanR> who wants to run programs anyway
10:12:01 <thoughtpolice> Are you implying I don't run my programs when I use :kind! :)
10:17:35 <shapr> juanca_: attoparsec is popular for parsing large binary file formats
10:18:38 <shapr> juanca_: if you're parsing binary files, this might be helpful: http://newartisans.com/2012/08/parsing-with-haskell-and-attoparsec/
10:19:18 <juanca_> shapr: the files i want to parse are plain text like files
10:19:25 <shapr> oh, Parsec would be fine for that
10:19:28 <juanca_> but i;m not sure how conduit will work
10:19:34 <juanca_> since it is a stream
10:19:46 <shapr> I've not tried to use them together
10:19:48 <juanca_> is there any considerationÇ
10:19:50 <juanca_> ?
10:20:20 <juanca_> shapr: oh i see :(. that was my concern how to make thwm work together
10:20:37 <shapr> The way I understand it, I think conduit is just about strictifying lazy IO, is that right?
10:20:44 <thoughtpolice> Normally, you'd use an interop library to glue Conduit onto your parsing library. That way, when you have a parser for some value, you can turn it into a conduit that will stream you results incrementally.
10:23:09 <orion> I have a function foo :: IO (Maybe Foo). What's the most concise way to assign a variable fooResult such that if foo == Nothing, then execute doFoo :: IO Foo?
10:23:19 <Cale> I know there's an attoparsec-conduit package
10:23:44 <Clint> it's obsoleted
10:24:06 <Cale> ah, okay, conduit-extra now contains that
10:24:13 <juanca_> shapr: kind of
10:24:21 <dmj> orion: what do you mean 'assign a variable'
10:24:32 <juanca_> thoughtpolice: do you know some some library to make them work together
10:24:35 <Cale> orion: foo will never be equal to Nothing, since its type is not Maybe t
10:24:54 <Cale> orion: You want to execute the action foo, and check if its result is Nothing
10:25:15 <orion> right
10:25:24 <dmj`> let doFoo :: IO Foo = fromMaybe defaultFoo <$> foo
10:25:25 <Cale> orion:  do r <- foo; case r of Nothing -> doFoo; Just f -> ...
10:26:03 <Cale> Yeah, there are some more concise things which can be done, but start with case, and then figure out what's happening in the other branch before you figure out anything more clever :P
10:26:55 <orion> In my case the following works: mt <- getGroupToken groupId; token <- case mt of; Just t  -> return t; Nothing -> getToken
10:27:05 <orion> I guess I'm looking for something more clever.
10:27:11 <thoughtpolice> foo >>= maybe doFoo return
10:27:13 <thoughtpolice> I think
10:27:20 <Cale> yeah, that'll work
10:27:30 <orion> Nice.
10:27:44 <Cale> I'm always suspicious about using maybe in this way
10:27:59 <Cale> Whenever I have to return to code which uses it, I end up unfolding it into a case expression again
10:28:27 <Cale> But if you're reasonably confident you'll never do anything in the other branch, it's fine :)
10:29:07 <icicled> is this the correct command for wanting stack to run my test & pass it some command line flags?  stack test -- --help
10:29:38 <hc> Hi everyone, I need to write some code that parses a huge file (~500MB) and stores the data in an sqlite database. Is attoparsec a possibility there, or am I better off using parsec or something else?
10:30:28 <Hijiri> that is probably a good use case for attoparsec
10:30:30 <dmj`> hc: probably attoparsec
10:30:40 <hc> Great; any hints on how to use IO with attoparsec?
10:31:15 <Hijiri> You want to store things in the database as you go along?
10:31:19 <dmj`> hc: that's a large file, so you'll want to use stream parsing
10:31:24 <hc> Yeah
10:31:33 <hc> Trouble is, I also need to keep some state while parsing the stuff
10:31:49 <thoughtpolice> Cale: Yeah, I think it's mostly just habit for me, because I often reach for 'maybe' (or 'either' or 'bool') commonly instead of less general cases (like fromMaybe), and I normally end up taking 'maybe f g' and lifting 'f' and 'g' out into names anyway, so it's mostly a style thing, to avoid the pattern match itself, I suppose.
10:31:56 <hc> Like, there is a table definition in the file which I need to be able to reference throughout the parsing process
10:32:18 <hc> table data is not necessarily in one piece in the file, so I need that state until parsing is complete
10:34:05 <dmj`> hc: maybe make two passes, first pass to construct the table, next pass to actually parse
10:34:34 <hc> Hmm, that'd work
10:35:12 <dmj`> hc: 500MB is a lot, you might want to use stream parsing too, at least on the second pass
10:35:41 <dmj`> withFileAsInput "foo.txt" $ \inputStreamBS -> parseFromStream myAttoParser inputStreamBS
10:35:55 <dmj`> @package io-streams
10:35:55 <lambdabot> http://hackage.haskell.org/package/io-streams
10:35:56 <hc> Are you sure parsec isn't easier/maybe even faster than two attoparsec passes?
10:36:28 <dmj`> hc: it probably won't be faster, I can't speak to the simplicity since I don't understand the task well enough
10:37:30 <dmj`> hc: well, two passes might be slower yes, but attoparsec is usually faster than parsec
10:37:33 <hc> It's basically a line oriented format. It contains a) table definitions and b) rows of the tables as defined by the table definitions. However, the rows of various tables can be mixed (!), there's always a header that says something like "now come 5 rows of table foo; 5 rows follow, next header..."
10:38:14 <hc> Tables are guaranteed to be defined before rows of a particular table are supplied
10:39:17 <dmj`> is there specification for this format?
10:39:27 <hc> not really; it's quite proprietary
10:40:52 <hc> but in general it goes like this: "TABLE foo has 5 columns; column 1 is of type string and 10 chars wide, column 2 ... etc". Then come lines that say "Now comes a row of table foo" and then the data for that row comes in the next line, and you need to know the length of each of the table's fields in order to be able to parse that line
10:44:50 <mnoonan> say I have some quite polymorphic function f :: T, used in a couple different places in my program.
10:45:01 <dmj`> hc: so every row can potentially be different?
10:45:12 <mnoonan> is there a name for the least polymorphic type T' such that f :: T' still works in that program?
10:49:35 <marrrk> In persistent is there any way of telling when doing upsert whether an update or an insert were performed?
10:54:54 <yyyyy> hc: i had a similar problem than yours recently while processing real-time data from a social media provider — paid stream, mixed data types coming in lines. my solution was to separate in multiple processes.
10:55:29 <yyyyy> one that simply streamed the data, without any processing but clearing keepalives and splitting by lines. this was basic conduit usage, with some STM.
10:56:07 <eitanChatav> hello
10:56:09 <yyyyy> this data is then written unprocessed to a database
10:56:24 <yyyyy> you use a separate process, in a different executable, to parse it
10:56:33 <eitanChatav> anybody know a way to time an IO operation, which doesn't screw up due to laziness?
10:56:58 <eitanChatav> tried the timeit library but I think i'm getting incorrect results
10:57:00 <yyyyy> for that i also used STM, and each worker was basically parsing line by line into a sum type of product types.
10:57:10 <yyyyy> in your case, you would have to chunk in more than lines.
10:57:51 <yyyyy> but the principle remains the same. you can backtrack if you reach the end of something using conduit and pipes and then start over again.
10:58:24 <yyyyy> i didn't use the lens package (sorely regret not doing it now), but i think prisms will also help you on this.
10:58:51 <yyyyy> sorry, conduit OR pipes :)
10:59:04 <marrrk> How would this look without do notation:  do
10:59:05 <marrrk>            _ <- upsert plant []
10:59:05 <marrrk>            return plant ?
11:00:11 <dmj`> eitanChatav: maybe nfIO w/ criterion
11:00:13 <eitanChatav> marrrk: upsert plant [] >> return plant
11:00:23 <marrrk> oh okay, thanks
11:00:30 <marrrk> for some reason I thought return was only in do notation
11:00:30 <eitanChatav> dmj`: thanks
11:00:48 <eitanChatav> marrrk: return is a normal function
11:01:04 <eitanChatav> return :: Monad m => a -> m a
11:01:15 <marrrk> Alright, thanks
11:01:26 <eitanChatav> np
11:04:14 <jophish> It's worth noting that all the cool kids use 'pure' nowadays 
11:06:36 <Cale> That's silly though
11:06:45 <Cale> If you know that you have a monad anyway
11:09:23 <jophish> unless you need to infer the Monad constraint, why not be as general as possible. It could make the transition to applicative code a little nicer
11:09:41 <jophish> (or enable ApplicativeDo) to work
11:09:55 <jophish> err, not quite sure how the brackets got in there :/
11:11:47 <Cale> Well, when you know it's, for example IO anyway...
11:13:23 <Cale> There's no difference between pure and return, except that using pure is unconventional.
11:15:26 <jophish> I use pure so that applicative and monadic code is more consistent. If it were'nt for a historical accident return wouldn't even be there.
11:15:27 <Cale> I suppose if we're going to insist that the Applicative instance always coincides with the Monad instance, then it might make sense at some point for return to be generalised.
11:15:34 <jophish> (I'm sure we both agree this is a pretty minor point though)
11:16:09 <Cale> I still consider Applicative a bit of a second class concept
11:16:32 <Cale> (relative to Functor and Monad)
11:16:52 <emmanuel_erc> The only place where I've seen applicative code make sense is in modeling an independent probabibility distribution.
11:17:03 <Cale> It naturally fits in between them, but it's pretty rare when you have something which is Applicative and not also a Monad
11:17:26 <jophish> dealing with regular languages springs to mind
11:17:57 <jophish> at the moment I'm using "Signal" from clash which doesn't have a Monad instance
11:18:06 <jophish> (although that's a pretty "out there" case)
11:19:22 <ott> What's the procedure/etiquette around becoming maintainer of what seems to be an abandoned package?
11:19:51 <Jinxit> try to get in touch with the owner?
11:20:11 <jophish> ott: email the maintainer. If you can't make contact talk to someone in #haskell-infrastructure
11:21:07 <Gurkenglas> Can we get CHronicle in lambdabot?
11:21:25 <jophish> Another good use of Applicative is making Haxl more efficient
11:21:44 <Gurkenglas> *Chronicle
11:21:46 <jophish> although I agree with the sentiment that there are far more uses of Monad than Applicative and not Monad
11:22:22 <EvanR> i feel like theres more applicatives
11:22:41 <EvanR> or more use cases
11:23:35 <hc> yyyyy: hmm... i think for now i'll just use parsec instead of attoparsec to keep the state
11:24:11 <hc> your solution seems very suited to parse real time data, but i don't need real time
11:24:19 <Gurkenglas> By use cases, you mean that there's more things that only need applicative than things that need monad?
11:25:03 <EvanR> i guess when im using applicative for something i dont even think what the monad would be like, if anything
11:25:34 <EvanR> like, using monad to do it doesnt even make sense
11:25:39 <EvanR> even if its possible
11:25:56 <marrrk> These function bodies are exactly the same. I would like to factor out the code duplication. I don't know what constraints to define though. I think that "Something" must be a PersistEntity. https://gist.github.com/i-am-the-slime/8b1127c6eef1221b0218
11:26:33 <iphy> is there a logBase for Integer?
11:26:37 <EvanR> more use cases for <*> and not >>=
11:27:16 <iphy> I want log2 :: Integer -> Integer
11:27:29 <bshelden> Cale: Error accumulation and parallel computation are both pretty common concepts with applicative encodings and not monadic ones.
11:27:30 <iphy> or log2 :: Integer -> Int
11:27:54 <Gurkenglas> marrrk, remove the type signature and see what it deduces
11:28:18 <marrrk> Okay
11:29:03 <Cale> EvanR: That's odd. Usually when I'm using <*> in any case where there's a Monad instance I tend to still be thinking about it in terms of the Monad.
11:29:38 <jophish> iphy: https://hackage.haskell.org/package/integer-gmp-1.0.0.0/docs/GHC-Integer-Logarithms.html#v:integerLogBase-35-
11:29:39 <marrrk> Gurkenglas: I get this error if I remove the annotation: https://gist.github.com/i-am-the-slime/8b1127c6eef1221b0218
11:30:09 <iphy> jophish: excellent, thanks
11:30:12 <marrrk> I don't understand it though.
11:31:11 <Gurkenglas> Hmm. Could he define a Constraint C without giving its signature and say "getPlantsHandler :: C => SqlBackend -> Maybe Int -> Maybe Int -> Handler [Plant]", letting ghc deduce C's definition if it's possible?
11:33:56 <EvanR> Cale: i dont get that
11:34:07 <Gurkenglas> marrrk, it's saying that it couldn't verify the type it inferred which was "(PersistEntity b, MonadIO m, PersistEntityBackend b ~ SqlBackend) => SqlBackend -> Maybe Int -> Maybe Int -> m [b]"
11:34:23 <Cale> EvanR: I mean, mf <*> mx executes mf and mx in turn and then applies the resulting function to the resulting value.
11:34:44 <marrrk> So it infers some type but is not sure of it?
11:34:58 <Gurkenglas> Which means that m must be a monad transformer stack with IO at the bottom, like Handler, b must be a PersistEntity, and the PersistEntityBackend family must map it to SqlBackend
11:35:56 <Cale> mf <*> mx = do f <- mf; x <- mx; return (f x)
11:35:57 <Gurkenglas> Oh wait actually it says that that last constraint is not allowed, you're not allowed to check whether (those?) two types are equal, and that you should activate one of the two language extensions GADTs or TypeFamilies
11:36:13 <Gurkenglas> Which you would do with adding it in the LANGUAGE bracket in the first line if you have one
11:36:19 <Gurkenglas> (you probably do)
11:36:19 <Cale> ^^ this is true in any case where the Applicative is really a Monad
11:36:47 <Cale> In other cases, you don't quite have a notion of "then", so it becomes a bit strange.
11:37:04 <Gurkenglas> You know, reading this again it *seems* really obvious but I'm also pretty sure that the next error message in this style is also going to take ages to read correctly
11:37:13 <EvanR> Cale: yeah thats so cumbersome, and i dont usually deal with the "diagonal" monads
11:37:17 <dolio> But notation like that is valid even if there is no Monad.
11:37:20 <marrrk> Okay
11:37:22 <marrrk> So wait
11:37:27 <Cale> dolio: right, fair enough :)
11:37:54 <Cale> EvanR: I don't see how it's cumbersome?
11:38:32 <EvanR> mf <*> mx vs do f <- mf; x <- mx; return (f x) 
11:38:41 <Cale> btw, MonadIO m doesn't necessarily mean that m is formed by application of a monad transformer
11:38:50 <Gurkenglas> What else has MonadIO?
11:38:51 <EvanR> i really try not to think about monads if i dont have to
11:38:54 <dolio> Well, in that case it's obviously more verbose.
11:39:02 <Cale> It just means that someone wrote a MonadIO instance, which can be done manually as well.
11:39:09 <Gurkenglas> yea but who does that
11:39:10 <marrrk> It compiles with GADTs
11:39:11 <Cale> (you just implement liftIO directly)
11:39:51 <Cale> EvanR: I mean, the do-block is clearly more verbose, but I think of <*> as a shorthand for the same idea
11:40:19 <EvanR> heh, <*> is... function application
11:40:22 <Cale> There are only a few cases where <*> means something else
11:40:25 <Cale> It's not function application
11:40:38 <marrrk> Gurkenglas: How do I get the inferred type now. I tried stack ghci but *Main API Models PlantsAPI Types UsersAPI> :t UsersAPI.getUsersHandler this yields taht it's not in scope.
11:40:44 <marrrk> I mean "?"
11:40:52 <EvanR> it seems obvious to me as container function application
11:40:55 <Cale> Well, it's obviously related to function application
11:41:31 <Cale> In that you're executing a pair of actions to get a function and an argument and applying the resulting function to the resulting argument :P
11:41:38 <EvanR> or structural function application
11:41:41 <Gurkenglas> marrrk, dunno but "(PersistEntity b, MonadIO m, PersistEntityBackend b ~ SqlBackend) => SqlBackend -> Maybe Int -> Maybe Int -> m [b]" should work :P
11:41:58 <EvanR> i dont think of it as executing actions
11:42:00 <EvanR> at all
11:42:06 <Gurkenglas> (Replacing m with Handler can be done, but could be argued against)
11:42:09 <iphy> how do you get an Int from an Int#?
11:42:21 <marrrk> Damn I should have just said Integer and it would have told me the expected type.
11:42:29 <Cale> Right, that's what's weird to me -- essentially all the Applicatives you're going to run into will have that interpretation.
11:42:39 <Gurkenglas> What do you mean, said Integer?
11:42:42 <EvanR> welp ;)
11:42:46 <Cale> (even when they're not instances of Monad)
11:43:12 <EvanR> especially given the usual warning that evaluation is not the same as execution
11:44:29 <EvanR> if i have a stream, a finite container of fixed size, a diagram with (a->b) and a inputs and b outputs, i dont see any execution going on
11:46:14 <EvanR> in the case of validation, i return to an evaluative picture
11:46:39 <EvanR> the IO applicative is obviously executive
11:46:43 <Gurkenglas> Who wrote the Alternative instance for ChronicleT? It seems all wrong :D
11:48:14 <Cale> EvanR: Well, what it means to execute a thing depends on what the thing is.
11:48:31 <Cale> EvanR: Executing a list, for example, means picking an element from it (in all possible ways)
11:48:31 <marrrk> Gurkenglas: It did work! Cool thanks. What's the "~" mean?
11:48:45 <Gurkenglas> type equality pretty sure
11:49:04 <Cale> yeah, type equality
11:49:19 <Gurkenglas> Why isn't there "MonadChronicle c m => m a -> m (These c a)"?
11:49:31 <iphy> jophish: integerLog2# returns an Int#, how do I turn that into an Int?
11:50:48 <Enigmagic> I#
11:53:16 <Enigmagic> :t GHC.Types.I#
11:53:17 <lambdabot> GHC.Prim.Int# -> Int
11:55:52 <benzrf> wots a Chronicle
11:55:59 <jophish> benzrf: https://hackage.haskell.org/package/these-0.6.2.1/docs/Control-Monad-Chronicle.html#v:chronicle
11:59:51 <iphy> Enigmagic: https://www.irccloud.com/pastebin/U10b8RRn/
12:02:50 <mnoonan> (repeating a question, just in case anybody has any ideas)
12:03:11 <mnoonan> say you have a function (or any value, I guess) with very polymorphic type f :: T
12:03:22 <mnoonan> and a specific program that uses f at a variety of types
12:03:44 <mnoonan> what would you call the least-polymorphic type T' such that f :: T' is still a valid type for f?
12:05:00 <mnoonan> like if you had fst :: a -> b -> a but it was only ever used at b ~ a, you'd specialize to fst :: a -> a -> a
12:16:12 <dolio> mnoonan: I don't think there's a specific term. However, polymorphism induces a partial order on types.
12:16:23 <dolio> (a -> b -> a) < (a -> a -> a)
12:16:34 <Prettyboy2000> hello
12:17:01 <dolio> In your case, all uses of f in your program will have type T_i > T.
12:17:13 <dolio> And T' is the greatest lower bound of the T_i.
12:17:36 <dolio> I believe.
12:18:20 <Gurkenglas> Why does ChronicleT's mplus definition discard recordings that ended on confess, as opposed to keeping them? (i.e. replace "Left  _ -> y" with "Left c -> dictate c >> y")
12:27:24 <lifter> What is the relationship between Liquid Haskell and Dependently Typed Haskell?
12:27:36 <lifter> Are these two distinct efforts?
12:28:07 <geekosaur> yes
12:31:23 <lifter> Are they accomplishing distinctly different goals?
12:37:50 <geekosaur> Dependent Haskell is a research project, so it's kinda making things up as it goes along. Liquid Haskell is an implementation of an existing dependent types mechanism (refinement types)
12:37:56 <mnoonan> dolio: yes, exactly. I'm finishing up a paper that uses that glb in passing in an example, so I was hoping there was some common term I could use. I guess the idea is clear enough as is. 
12:39:26 <geekosaur> (Dependent types in general are antagonistic to some Haskell features, notably type inference. Dependent Haskell is looking at ways to provide the power of dependent types without completely losing those features. https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell)
12:40:15 <hpc> dependent types admit some limited inference, but not nearly to the extent of default haskell's "nearly every definition can have its type inferred"
12:45:36 <dolio> I think the bigger difference is how they're going about it.
12:47:21 <dolio> Liquid Haskell is a separate checker. So the things you do with it are necessarily not as first-class as GHC language features.
12:48:17 <dolio> You won't be doing type class dispatch off the refined type, for instance.
12:49:07 <dolio> I mean, there are also other big differences. Like I'm not sure I'd say that refinement types 'are' dependent types.
13:09:32 <lifter> Thanks for the info re: Liquid H. and Dependent H.
13:16:36 <EvanR> solid haskell, liquid haskell
13:16:40 <EvanR> twin haskells
13:17:17 <koz_> EvanR: We need a gaseous Haskell now.
13:17:38 <EvanR> (reverse) solidus haskell
13:18:47 <dolio> Does Twin Haskells make jet engine noises when it type checks your code?
13:20:21 <dmj`> only if it's a twin turbo pascal engine
13:34:34 <Enigmagic> iphy: don't use $
13:35:00 <Enigmagic> :k ($)
13:35:01 <lambdabot> Not in scope: type constructor or class ‘$’
13:35:04 <Enigmagic> derp
13:35:11 <Enigmagic> :t ($)
13:35:13 <lambdabot> (a -> b) -> a -> b
13:36:59 <Enigmagic> > GHC.Types.I# (GHC.Integer.Logarithms.integerLog2# 100)
13:37:01 <lambdabot>  Not in scope: data constructor ‘GHC.Types.I#’    Not in scope: ‘GHC.Integer....
13:37:08 <Enigmagic> well whatever, there ya go.
13:39:17 <geekosaur> :t GHC.Types.I# (GHC.Integer.Logarithms.integerLog2# 100# )
13:39:18 <lambdabot>     Couldn't match expected type ‘Integer’
13:39:18 <lambdabot>                 with actual type ‘GHC.Prim.Int#’
13:39:18 <lambdabot>     In the first argument of ‘GHC.Integer.Logarithms.integerLog2#’, namely
13:39:45 <geekosaur> :t GHC.Types.I# (GHC.Integer.Logarithms.integerLog2# 100 )
13:39:46 <lambdabot> Int
13:40:00 <geekosaur> ...
13:40:04 <Enigmagic> yeah ..
13:40:43 <yyyyy> if one wants to avoid the historical baggage of the prelude and use something that's more generalised, what are the better recommendations nowadays?
13:41:24 <geekosaur> sorry, no, that worked but my connection to my bouncer keeps going away and I thought it was the bot until I got the disconnect
13:42:11 <yyyyy> I'm thinking of something along the lines of PureScript's base libraries, where things are more generalised when compared to Haskell's prelude+base.
13:44:16 <eitanChatav> you can use Hask, nice and general :-) https://hackage.haskell.org/package/hask
13:45:31 <geekosaur> I don't think there's one preferred alternative Prelude at this point. I know people use ClassyPrelude 
13:45:59 <bobic171> hello o/
13:46:25 <bobic171>  
13:47:13 <geekosaur> (ClassyPrelude does have its issues, and I suspect a proper replacement along those lines wants to start over from scratch instead of trying to provide Prelude-compatible interfaces)
13:48:31 <yyyyy> eitanChatav: lol. even if i take the plunge i think any coworker or my future self reading the code will hate me for that.
13:50:00 <bobic171> would any one mind giving me a little help ? :] 
13:50:14 <parsecChar> when using Groundhog, like https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/groundhog , is there a way to auto derive PersistField and PrimitivePersistField ?
13:51:36 <yyyyy> geekosaur: what kind of issues come to mind?
13:51:46 <bobic171> how do i go about filtering inside each word when using words ?
13:52:49 <Cale> bobic171: map (filter p) ?
13:53:27 <geekosaur> yyyyy, it uses mono-traversible to generalize the list operations (since all the standard String operations are actually list operations). this can lead to pathological behavior, in the worst case it has to convert every packed string type to [Char] and back
13:54:58 <bobic171> hmm efficiency isn't key at the moment 
13:57:18 <icicled> geekosaur: isn't that only when you use "repack" or are there other instances?
13:57:46 <icicled> I just started using it so any info would be nice
13:58:18 <bobic171> words starters (countLetters starwars a = length $ filter (== a) starters) that is what i came up with but i dont think its right :/ 
13:58:42 <geekosaur> icicled, there are RULEs (compiler pragmas) that force unpacking of Text and ByteString on all of the String/list operations, then try to merge operations to make them streaming instead of unpack/pack. If the merge fails then you're left with the pack/unpack version
13:58:43 <bobic171> dam auto correct starters are all starwars
13:59:07 <benzrf> lmao
13:59:34 <yyyyy> geekosaur: so assuming you're using Text instead of String nothing bad should happen with ClassyPrelude?
13:59:38 <geekosaur> icicled, when the merges succeed you can get code that is much, much faster than the String.list operations
13:59:55 <lyxia> bobic171: what are you trying to do
14:00:21 <icicled> got it
14:00:26 <bobic171> count the number of words that contain a specific letter 
14:01:05 <geekosaur> well, you would hope. unfortunately ghc is still not particularly great at stream fusion so it fails more often than you could wish, and the result is really slow code. and the fact that it's polymorphic instead of e.g. Text-specific causes stream fusion to fail more often than it otherwise would
14:01:49 <naudiz> does anyone else have problems installing cabal-install or stack on Gentoo?
14:02:00 <lyxia> bobic171: \words a -> length (filter (elem a) words)   ?
14:02:00 <geekosaur> so this is a case where using the polymorphic Prelude replacement can make your code much worse
14:02:39 <bobic171> so with that a would be string right 
14:02:51 <bobic171> wait no 
14:03:04 <geekosaur> (part of the problem is that ghc's RULEs are rather blunt instruments)
14:03:59 <lyxia> bobic171: words :: [String], a :: Char
14:04:02 <geekosaur> I could imagine someone putting together a ghc plugin (this is a newish feature and still evolving) that can do a better job of it than a bunch of ad-hoc RULE pragmas --- but I suspect writing it would be a rather large job
14:05:57 <yyyyy> got it. i think i'll give it a shot at using classy-prelude and check if performance drops considerably — tweaking where needed. maybe as a nice side-project i'll try porting the purescript base libraries to haskell, if someone hasn't done it yet.
14:06:13 <bobic171> so i would write     words a -> length (filter starwars (elem a) words)
14:06:44 <lyxia> why filter starwars
14:06:55 <bobic171> its just the name of the string 
14:07:35 <lyxia> oh you need to apply words to the string to get words. Sorry I used variable shadowing.
14:07:53 <bobic171> i dont know what that is :s 
14:08:16 <lyxia> bobic171: countWordsWithLetter string letter = (length . filter (elem letter) . words) string
14:12:48 <bobic171> ah okay so its   countWordsWithLetter starwars a =(length.filter(elem a).words)starwars
14:13:55 <lyxia> exactly
14:16:34 <bobic171> hmm I'm getting parse error on input ‘=’
14:17:21 <pwestling> I'm having a problem with (I think) polymorphism - I want to represent a series of transformation to a structure CharData (it's a game character) in a serializable way
14:17:37 <pwestling> my first thought was to create structures like Race, Class, Ability
14:17:46 <pwestling> and have them implement a typeclass like
14:18:12 <pwestling> class Modifier a where toTrans :: a -> CharData -> CharData
14:18:50 <lyxia> bobic171: are you writing that in ghci?
14:19:05 <pwestling> then I could hold them in a list as the original data type, and when I want to make the character, map toTrans to the list and apply the functions to a basic template
14:19:05 <bobic171> yeah in the terminal 
14:19:14 <lyxia> bobic171: you need to prefix definitions with let
14:19:58 <pwestling> I've found though, that it seems to be impossible to make (Modifier a) => [a]
14:20:01 <pwestling> for all as
14:20:13 <pwestling> i.e. a list where the elements are different members of a typeclass
14:20:32 <lyxia> right, lists must have elements of the same type
14:20:43 <zomg> pwestling: you can create a sum type for it, data GameThing = Race | Class | Ability or something along those lines
14:21:12 <pwestling> is there any option other than that? toTrans looks really ugly doing it that way
14:21:25 <pwestling> given that each of the options will have tons of sub options and so on
14:22:36 <johnw> pwestling: slightly different would be [forall a. Modifier a => a] (an impredicative type), except that you could *only* interact with each member by that interface
14:23:17 <pwestling> that's exactly what I want - once these things are in the list it;s fine if all I can do is use the toTrans fn
14:23:23 <lyxia> you need an existential type, not a universal one
14:23:24 <zomg> the function would probably look less ugly if you were to split it into smaller function which deal with the individual types :)
14:23:35 <scionaura> Howdy folks, quick question
14:23:55 <lyxia> pwestling: why not simply store them as CharData -> CharData in the first place
14:23:58 <johnw> so, the impredicativity here means that the list might end up including a member of its own type
14:24:02 <scionaura> How come Haskell is such a shitty language, compared to Javascript?
14:24:07 --- mode: ChanServ set +o johnw
14:24:09 <lyxia> I mean that's all you'll be able to do with them once they're in the list
14:24:17 <pwestling> zomg: it's still a lot of sum types even with that, but yes that's how I would do it. With 9 races, 12 classes, many many Abilities etc it's a lot to have in a tree of sum types
14:24:43 <johnw> pwestling: scionaura has a point
14:24:45 <pwestling> lyxia: I need to be able to serialize the data
14:24:46 --- mode: johnw set -o johnw
14:24:51 <lyxia> oh right
14:24:56 <pwestling> lyxia: or I would do exactly that
14:25:02 <bobic171> thanks Lyxia ^^
14:25:16 <lyxia> *facepalm*
14:25:28 <pwestling> lol johnw, true, I'll just switch to javascript and all my problems will be solved
14:25:31 <pwestling> clearly
14:26:10 <pwestling> lyxia: still a good idea, I'm noob enough I could have just been doing it entirely wrong
14:26:20 * hackagebot hailgun 0.4.0.4 - Mailgun REST api interface for Haskell.  https://hackage.haskell.org/package/hailgun-0.4.0.4 (RobertMassaioli)
14:27:07 <scionaura> @pwestling: yeah, clearly a noob. because only noobs use Haskell
14:27:07 <lambdabot> Unknown command, try @list
14:27:37 <johnw> scionaura: just a friendly warning that such attitudes are not accepted here
14:28:30 <scionaura> Can anybody help me concatenate two lists in javascript? I read the docs and it doesn't say anywhere
14:28:44 <johnw> this channel is for Haskell discussion, not Javascript
14:29:09 <zomg> scionaura: you should try trolling on the JS channel, it's much more poorly moderated than this channel
14:29:34 <scionaura> haha ok. I just want to troll. Thank zomg
14:29:49 --- mode: ChanServ set +o mauke
14:29:49 --- kick: scionaura was kicked by mauke (troll elsewhere)
14:29:54 <zomg> poor guy
14:30:03 <zomg> ...and I'm on the JS channel, let's see what happens
14:30:08 <lifter> He's gonna go to a JS channel and ask them why JS is such a shitty lang compared to Haskell
14:30:17 <lifter> (or she)
14:31:20 * hackagebot hedis 0.7.7 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.7.7 (k_bx)
14:31:22 <zomg> disappointingly they just quit without saying anything
14:31:24 <zomg> =)
14:31:49 --- mode: mauke set -o mauke
14:46:21 * hackagebot operational-extra 0.2 - Interpretation functions and simple instruction sets for operational  https://hackage.haskell.org/package/operational-extra-0.2 (andrewthad)
14:47:47 <iphy> what would be the best way to safely convert Int to Maybe Word8, so that any values outside the range result in Nothing?
14:52:04 <johnw> iphy: I would just write a function to do that
14:52:23 <johnw> if x is greater than 2^8 then Nothing, otherwise Just x
14:52:57 <undergrad> hey guys can any1 answer me some questions about Reader monad?
14:53:14 <Clint> johnw: or less than 0
14:53:21 <johnw> yeah, that too
14:53:30 <johnw> undergrad: better to just ask
14:54:40 <undergrad> lets say we have a Reader monad object. the definition (on the wiki) says: newtype Reader e a = Reader { runReader :: (e -> a) }. Does this mean this is just a function?
14:55:15 <undergrad> so if I have a Reader r, calling (r e) will run the runReader function?
14:55:17 <johnw> yes, Reader "actions" are functions wrapped by a newtype wrapper
14:55:24 <johnw> you still need runReader r e
14:55:51 <undergrad> hmm then my problem is I dont understand the binding ops def then
14:56:02 <undergrad> (Reader r) >>= f = Reader $ \e -> runReader (f (r e)) e
14:56:06 <EvanR> simply passing arguments to a function is the classic way to do dependency injection, this is expressed as such with the Reader type's type
14:56:17 <EvanR> well, implementation
14:56:22 * hackagebot clash-lib 0.6.13 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.13 (ChristiaanBaaij)
14:56:24 * hackagebot clash-ghc 0.6.13 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.13 (ChristiaanBaaij)
14:56:35 <johnw> undergrad: what is the point of confusion?
14:56:39 <undergrad> well
14:58:23 <undergrad> I figured (r e) will be type a, then (f (r e)) will be a Reader type, so I figured (f (r e)) e --->this would be type a
14:58:41 <undergrad> but if thats type a then why do I have to call runReader?
14:58:49 <johnw> f (r e) returns a Reader value
14:58:52 <EvanR> you wrapped the whole thing a Reader
14:58:53 <johnw> so runReader is needed to unwrap it
14:59:18 <johnw> you can't call the reader function without unwrapping
14:59:35 <EvanR> = Reader $ \e -> (... :: a)
15:00:00 <EvanR> (f (r e)) e didnt happen yet
15:00:08 <EvanR> it needs an e
15:00:44 <undergrad> oooh
15:00:46 <undergrad> so
15:01:49 <undergrad> no, I still dont get it, what I dont seem to understand is the difference between r and f (r e). Both should be Readers shouldnt they?
15:02:11 <EvanR> r is a function
15:02:23 <EvanR> so no
15:03:52 <cmotoche> Hey people. I'm using cabal for dependency manage, but I'm getting "At least the following dependencies are missing: (list of all the dependencies)". Not sure why.
15:05:13 <undergrad> oh, you are right, Reader r means I pattern matched and r is the function I give to the typeconstructor Reader, right?
15:05:29 <undergrad> *data constructor
15:05:34 <johnw> right
15:06:14 <undergrad> but f (r e) gives me and actual Reader, and runReader gives me its function
15:06:33 <undergrad> ok I get it now thanks guys
15:06:56 <EvanR> yeah the F { getF :: x } pattern is kind of funny
15:06:58 <EvanR> at first
15:07:10 <EvanR> getF :: F -> x
15:08:33 <EvanR> not really getting an F ;)
15:08:49 <EvanR> getting from an F
15:09:00 <Clint> D-
15:13:27 <jle`> it depends on the thing i guess; i always considered cute record accessor tricks like this to be somewhat of an abuse, heh
15:13:59 <jle`> it makes sense for things like getSum (foldMap Sum [1,2,3,4]), i guess
15:16:04 <deepfire> Is there a general strategy for selective disabling of GHC warnings?
15:16:23 * hackagebot random-variates 0.1.3.0 - "Uniform RNG => Non-Uniform RNGs"  https://hackage.haskell.org/package/random-variates-0.1.3.0 (kpratt)
15:16:25 * hackagebot operational-extra 0.3 - Interpretation functions and simple instruction sets for operational  https://hackage.haskell.org/package/operational-extra-0.3 (andrewthad)
15:16:52 <deepfire> I face a warning for what I found no documented ways of disabling
15:17:19 <deepfire> "Both DeriveAnyClass and GeneralizedNewtypeDeriving are enabled ..."
15:17:47 <deepfire> How do people deal with such situations?
15:19:12 <lyxia> Doesn't DeriveAnyClass take precedence over GeneralizedNewtypeDeriving?
15:19:18 <lyxia> so the latter is useless?
15:21:23 * hackagebot riak 1.0.0.1 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-1.0.0.1 (lambda_foo)
15:26:23 * hackagebot microformats2-parser 1.0.1.4 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-1.0.1.4 (myfreeweb)
15:27:55 <deepfire> lyxia: hmm, you are right..
15:28:29 <deepfire> I thought DAC didn't trup GND for where GND actually had things to provide, but apparently it does..
15:28:42 <deepfire> *trump
15:30:31 <deepfire> it's sad.. I'd love to have GND for Num, and DAC for Generic
15:32:39 <deepfire> No, DAC not for Generic, sorry for confusion, it was for something else I don't remember
15:34:07 <lyxia> that would be nice to have. it seems https://ghc.haskell.org/trac/ghc/ticket/10598 has some ideas
15:48:58 <deepfire> lyxia, thank you for help!
15:52:20 <deepfire> (still, even if my specific problem was solved, I'd love to know about a general strategy for selectively shooting down GHC warnings..)
15:52:59 <deepfire> (I know there's some talk for adding in-source suppressors, but I was thinking of a flag-based way)
15:53:02 <koz_> deepfire: You can basically have a custom warning set.
15:53:11 <koz_> Since GHC has complete control over which warnings to enable or disable.
15:53:15 <koz_> (kinda like GCC and friends)
15:53:17 <deepfire> koz_, how?
15:53:30 <koz_> deepfire: Each warning can be turned on or off using a GHC flag.
15:53:43 <koz_> So you just pick the ones you want, and pass in the necessary set of flags to enable them, and *only* them.
15:54:00 <deepfire> koz_, I have this lovely "Both DeriveAnyClass and GeneralizedNewtypeDeriving are enabled ..."
15:54:13 <dimsuz> Hi! I learning Haskell and need to run a monadic action in a manner very similar to 'take 50 $ iterate (...)', but can not find the right library function for this. Few look promising in monad-loops, but not quite. See my function and struggles: http://lpaste.net/154705
15:54:21 <dimsuz> any hint would be appreciated!
15:54:28 <deepfire> koz_: how do I go from a warning message to a flag?  I was looking at the documentation and didn't find one
15:54:46 <koz_> deepfire: I'm not sure what flag controls *that* particular class of warnings, I'm afraid.
15:54:56 <koz_> dimsuz: So, are you trying to chain together monadic actions?
15:55:20 <dimsuz> koz_: yes, next one depends on previous
15:55:30 <koz_> dimsuz: Look up <=< and >=>
15:55:54 <koz_> I'm not completely sure if that's what you want, but it's a place to start.
15:56:18 <dimsuz> koz_: and this needs to be done lazily because I have indefinite progression from which I want only a limited set
15:56:33 <dimsuz> aha, this is kleisli-something, seen it somewhere :)
15:56:55 <koz_> dimsuz: Yeah, Kleisli composition. Is that not what you want or something?
15:57:32 <dimsuz> koz_: not sure. basically I have a starting point from it I generate a "monadic" point (random), from which a next one and so on.
15:57:57 <dimsuz> koz_: thanks for pointers, will investigate
15:58:55 <koz_> dimsuz: No worries - sorry I can't be of more help.
15:59:07 <dimsuz> basically I need simply "take 10 $ iterate (\p -> nextMonadicValue) initialValue" => m [value]"
16:01:07 <nitrix> That's a syntax error.
16:04:36 <c_wraith> dimsuz, that can't be done for most m. 
16:05:21 <c_wraith> dimsuz, that's the basic problem streaming libraries like conduit and pipes were created to deal with. 
16:05:44 <dimsuz> c_wraith: hmm. maybe I'll need to rethink this then. I set out on a task to plot a set of random points (sierpinsky) each successive depends on previous
16:06:11 <dimsuz> and this is where I arrived now... struggle to solve this led me here :)
16:06:16 <lyxia> the number of iterations will need to be a part of your iterating function
16:07:08 <dimsuz> lyxia: yes, I suspected that too. I tried to fit it into unfoldrM somehow, but that didn't go well.
16:07:44 <dimsuz> c_wraith: thank you, I will check them out. What should I look for in those libraries, or should I just read their docs?
16:07:57 <lyxia> I think handwriting it from scratch will be cleaner at this point
16:08:30 <c_wraith> dimsuz, mostly you should look for something that makes sense to you. those libraries have a reputation for being complex. 
16:08:48 <dimsuz> lyxia: that was actually my thought before c_wraith suggested pipes/conduit. Will do, thank you. Considering I'm a begginer trying to put monad theory into practise
16:09:01 <dimsuz> thank you all, I need to sleep now
16:09:09 <c_wraith> dimsuz, there is a reason for that, and it's mostly opacity of interface rather than true complexity 
16:09:24 <adamCS_> dimsuz: You could also look at something where, once you have the seed, generating the next random number is not monadic.
16:09:30 <c_wraith> dimsuz, but mostly, yeah, write it from scratch once. 
16:09:38 <dimsuz> i've seen them mentioned several times on various sources
16:10:25 <dimsuz> adamCS_: yes, another idea to explore
16:18:01 <GLM> Does anyone know how to have a test suite run by stack use a proxy?
16:41:28 * hackagebot cheapskate-highlight 0.1.0.0 - Code highlighting for cheapskate  https://hackage.haskell.org/package/cheapskate-highlight-0.1.0.0 (Artyom)
16:56:18 <myname_> Is there a way to have literals in data types, something like "data Foo = 1 | 2"?
16:56:41 <Cale> myname_: No
16:57:01 <Cale> myname_: The newly introduced constructors of your data type have to be not already in scope.
16:57:29 <myname_> Cale: I don't understand
16:57:33 <Cale> (you can name constructors the same thing if they live in different modules, but then you have to import and use them qualified)
16:57:47 <Cale> When you write a data declaration you're introducing multiple new things
16:58:00 <kadoban> Numeric literals *are* all of type Num a => a though, so if what you're dealing with makes sense as an instance of Num, you can do something that works a little like that.
16:58:18 <Cale> data Foo = A Integer | B String Double | C [Foo]
16:58:29 <Cale> will introduce not only a new type called Foo
16:58:36 <Cale> but also the constructors A, B, and C
16:58:43 <Cale> which are functions
16:58:47 <Cale> A :: Integer -> Foo
16:58:52 <Cale> B :: String -> Double -> Foo
16:58:58 <Cale> C :: [Foo] -> Foo
16:59:56 <Cale> (they may simply be values of type Foo, rather than functions, if you don't list any types after the constructor name)
17:00:17 <myname_> Cale: What I want is a Num but I want to constrain the values it can take
17:00:22 <Cale> e.g. we might have made it  data Foo = A Integer | B String Double | C [Foo] | D
17:00:27 <Cale> in which case, you'd have
17:00:29 <Cale> D :: Foo
17:00:30 <Cale> also
17:00:57 <Cale> myname_: Yeah, that's not really doable with Haskell's type system
17:01:19 <myname_> Okay, thanks
17:01:28 <Cale> What you *can* do is to make a newtype of an underlying numeric type
17:01:48 <Cale> and introduce functions that build values of that newtype, which don't really let you create just any number
17:02:01 <Cale> and then don't export the newtype's data constructor from the module
17:02:09 <Cale> So, e.g.
17:02:29 <Cale> newtype EvenInteger = EI Integer
17:02:42 <Cale> and then you might have
17:02:50 <Cale> twice :: Integer -> EvenInteger
17:02:56 <Cale> twice n = EI (2 * n)
17:03:05 <Cale> and maybe some other stuff
17:03:15 <Cale> (almost certainly some other stuff!)
17:03:28 <Cale> and then at the top of your module, you'd have:
17:03:42 <Cale> module EvenInteger (EvenInteger, twice, ...) where
17:03:51 <Cale> where importantly, we're not exporting EI from the module
17:04:06 <Cale> so the only way to make values of type EvenInteger are functions such as twice, which enforce the guarantee
17:04:26 <Cale> However, that's a bunch of work, and you have to ask yourself whether or not it's worthwhile
17:04:41 <Cale> myname_: ^^
17:05:51 <myname_> Cale: I guess not.
17:06:16 <Cale> Sometimes it does turn out to be worth the trouble... it depends on the individual situation.
17:06:38 <myname_> Cale: But how is Num defined?
17:06:39 <Cale> But yeah, there's nothing like "The type of integers between n and m" so easily in Haskell, since we don't have types which depend on values.
17:06:45 <Cale> Num is a type class
17:07:03 <Cale> (I'll get the definition, just a moment)
17:08:02 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.2.0/src/GHC-Num.html#Num
17:08:54 <Cale> So, any type which implements the operations (+), (*), abs, signum, fromInteger, and one of negate or (-) can be an instance of Num
17:09:07 <Cale> You write an instance declaration, providing the implementations of those functions
17:09:48 <Cale> and then a type variable which is constrained by the Num type class will be allowed to range over your new type of numbers
17:10:12 <Cale> (in addition to Integer, Double, etc. which are already instances of Num)
17:11:05 <myname_> Cale: I think the interesting thing is fromInteger, that is what ties it to literals?
17:11:17 <Cale> yeah
17:11:27 <Cale> When you write an integer literal like 76
17:11:48 <Cale> that is syntax sugar for something like  (fromInteger (76 :: Integer))
17:12:45 <Cale> :t 76
17:12:46 <lambdabot> Num a => a
17:12:53 <Cale> > 76 :: Double
17:12:55 <lambdabot>  76.0
17:12:59 <Cale> > 76 :: Word32
17:13:00 <lambdabot>  76
17:13:06 <Cale> > 76 :: Complex Rational
17:13:07 <lambdabot>      No instance for (RealFloat (Ratio Integer))
17:13:07 <lambdabot>        arising from the literal ‘76’
17:13:07 <lambdabot>      In the expression: 76 :: Complex Rational
17:13:09 <Cale> aww
17:13:12 <Cale> > 76 :: Complex Float
17:13:13 <lambdabot>  76.0 :+ 0.0
17:13:26 <Cale> (forgot that Complex requires RealFloat)
17:13:47 <Cale> > 76 :: Rational
17:13:49 <lambdabot>  76 % 1
17:13:59 <myname_> Cale: I think I understand now. Thanks
17:14:03 <Cale> A similar thing takes place with fractional literals
17:14:07 <Cale> :t 7.6
17:14:09 <lambdabot> Fractional a => a
17:14:14 <Cale> :t fromRational
17:14:15 <lambdabot> Fractional a => Rational -> a
17:14:23 <Cale> ^^ that gets used to interpret them
17:14:46 <Cale> > 74.57481975892301748932718942370894023784903278940237891407389201567318078923057812907328914023 :: Rational -- perhaps even with no loss of precision
17:14:48 <lambdabot>  7457481975892301748932718942370894023784903278940237891407389201567318078923...
17:15:09 <Cale> > 74.57481975892301748932718942370894023784903278940237891407389201567318078923057812907328914023 :: Float
17:15:10 <lambdabot>  74.57482
17:15:16 <Cale> Or perhaps with a lot of loss :P
17:17:26 <hpc> > pi :: CReal -- exact math can get a bit ridiculous with the right types
17:17:27 <lambdabot>  3.1415926535897932384626433832795028841972
17:17:39 <hpc> (pretend there's a "..." at the end there)
17:21:07 <japesinator> I'm having a weird problem with ghc-mod
17:21:07 <japesinator> || parse error in ghcmod! Could not parse the following ghc-mod output:ghc-mod: <command line>: cannot satisfy -package-id base-4.8.1.0-075aa0db10075facc5aaa59a7991ca2f
17:21:20 <japesinator> how might I fix this?
17:24:20 <jasonkuhrt> Hi, newb question, I am working with the `wreq` library and trying to wrap certain API requests behind helper functions which will return `IO (Response ...)` but I'm having trouble with the `...` part.
17:24:58 <jasonkuhrt> When I let Haskell infer the type it is `bytestring-0.10.6.0:Data.ByteString.Lazy.Internal.ByteString` which doesn't seem to be a valid type identifier for me to use in my source code?
17:25:29 <jasonkuhrt> I've tried a few other variations, leading to not in scope errors mostly. Any advice?
17:26:17 <LysergicDreams> jasonkuhrt: newb here, I'd try importing the Bytestring type from Data.ByteString.Lazy and using that
17:26:37 <LysergicDreams> jasonkuhrt: may have to add bytestring package to your cabal file
17:28:45 <jasonkuhrt> LysergicDreams: thanks for the tips. Not solving the issue exactly yet, but I'll keep poking
17:32:12 <LysergicDreams> jasonkuhrt: From the haddocks that looks like the right type, what error you getting now?
17:35:44 <jasonkuhrt> LysergicDreams: Thanks, all good now. I had to get my capitals and such right. I also need to get more comfortable with how imports and qualifications work in Haskell
17:36:42 <jasonkuhrt> My import is now `import Data.ByteString.Lazy` and my type is `getWeather :: AccessToken -> Float -> Float -> IO (Response ByteString)`
17:37:16 <jasonkuhrt> Shouldn't `import Data.ByteString` with `getWeather :: AccessToken -> Float -> Float -> IO (Response Lazy.ByteString)` also work?
17:40:05 <jasonkuhrt> Hm, no
17:40:09 <LysergicDreams> jasonkuhrt: I'm not sure, I would have to guess that either the Data.ByteString module is required to explicitly export the Lazy module & it doesn't, or modules can't export modules
17:40:37 <jasonkuhrt> `import Data.ByteString.Lazy` with `getWeather :: AccessToken -> Float -> Float -> IO (Response Data.ByteString.Lazy.ByteString)` does work
17:41:05 <LysergicDreams> jasonkuhrt: Usually I do "import qualified Data.ByteString.Lazy as L" and use it like "getWeather :: AccessToken -> Float -> Float -> IO (Response L.ByteString)"
17:41:14 <geekosaur> modules can export modules but they get the name of the exporting module
17:41:36 <nitrix> How bad is it if I put all my types in a Types module? I've been trying to carefully design my game and I can't seem to avoid cyclic dependency this time.
17:41:43 <nitrix> Even with polymorphism.
17:42:05 <jasonkuhrt> geekosaur: "but they get the name of the exporting module" <-- Can you expand on this?
17:44:22 <geekosaur> if you have `module A (module B, ...) where` and import that qualified in module C, the names exported from B via A will be A.foo, not B.foo
17:48:29 <jasonkuhrt> geekosaur: Ok thanks
17:54:28 <fr33domlover> Hmmm I noticed something: If you want to generate a random integer within a range of odd size, you can't just check how many bits you need and generated based on that, because then you really generate in a range bigger by 1. Am I mistaked or is this implementation incorrect: crandomR_Num function in http://haddock.stackage.org/lts-5.8/monadcryptorandom-0.7.0/src/Control-Monad-CryptoRandom.html
17:54:58 <ertes> nitrix: i do that a lot
17:55:14 <ertes> either .Types containing only types or .Core containing only a minimal, self-contained core
18:04:30 <fr33domlover> ah ok,it was indeed me being mistaken
18:04:39 <fr33domlover> the implementation is fine :P
18:05:03 <lyxia> yeah they retry if they go out of range
18:05:53 <lyxia> kind of a waste of bits
18:24:01 <linman32> is it possible for a state like monad to change the state's type throughout the do notation?
18:24:42 <dmj> linman32: no
18:24:52 <dmj> instance Functor (State s) where
18:24:56 <dmj> s doesn't get modified
18:25:25 <jle`> linman32: you can use natural transformations/functors to "lift" state operations sometimes
18:25:39 <jle`> withOtherState :: State s' a -> State s a
18:25:52 <jle`> so you can do a small sub-component of your computation with a different state
18:26:07 <jle`> but the lines of the do block itself has to all be with the same state type
18:26:23 <cjay> how solid is ghc's ARMv7 support nowadays? I'm thinking about renting a cheap ARM server.
18:26:44 * hackagebot hip 1.0.1 - Haskell Image Processing (HIP) Library.  https://hackage.haskell.org/package/hip-1.0.1 (lehins)
18:27:04 <linman32> jle` dmj: is there anything that can do that type of thing? like arrows?
18:27:56 <jle`> you can use Either as your state parameter perhaps, but it depends on what you really want to do
18:29:03 <linman32> was thinking to munge data, then process. munge data, then process
18:29:32 <linman32> munge data changes the type. like 2d matrix to 3d matrix
18:30:38 <jle`> you can do something like what i mentioned
18:32:58 <linman32> jle`: thx
18:33:54 <jle`> or you can use Either as well
18:34:00 <jle`> to be less typesafe
18:34:05 <enthropy> that withOtherState is probably done with Control.Lens.zoom
18:35:09 <jle`> yeah, zoom gives you nice convenient ways to get those
18:38:33 <enthropy> linman32: why not have    main = print =<< process =<< munge =<< load, so you could have  "munge :: Raw -> IO Munged" for example
18:41:22 <linman32> well, i'm not sure how to do what i want (can't comment on your idea exactly either), but here is something along the lines of it..
18:41:46 <linman32> one sec
18:43:11 <linman32> http://lpaste.net/154713
18:44:47 <linman32> maybe having a container type would work fine. and do pattern matching on that
18:44:53 <linman32> instead of changing the types inbetween
18:46:46 <linman32> ok, i'm just going to stick with container type approach and do pattern matching.
18:46:54 <linman32> g2g. thx
19:58:53 <japesinator> when I try to use ghc-mod, I get a weird error
19:58:54 <japesinator> "|| parse error in ghcmod! Could not parse the following ghc-mod output:ghc-mod: <command line>: cannot satisfy -package-id base-4.8.1.0-075aa0db10075facc5aaa59a7991ca2f
19:58:57 <japesinator> "
19:59:04 <japesinator> how might I fix this?
20:02:20 <echo-area> I read somewhere that Mu(F) represents least fixpoint of F, while Nu(F) represents greatest fixpoint of F.  Why are they isomorphic?
20:20:28 <pavonia> echo-area: In what way are they isomorphic?
20:22:03 <echo-area> pavonia: There are functions to convert between the Mu(F) and Nu(F)
20:36:02 <Cale> echo-area: They're isomorphic roughly because it's impossible to prevent recursive data structures from becoming infinite in Haskell. We don't have any sorts of restrictions on how recursion is used.
20:38:45 <Cale> echo-area: For example, in Coq and Agda, recursive functions on inductive data types are usually required to be structurally recursive -- that is, the recursive application of a function must, at least in one parameter, be applied to some child of the data structure directly as it was pattern matched.
20:39:48 <Cale> echo-area: while functions on coinductive data structures don't have that restriction, but instead, recursive functions producing coinductive data can only recurse inside an application of a (co-)data constructor for the type
20:39:50 <EvanR> so that doesnt really prevent recursive data structures as such
20:40:12 <EvanR> it prevents ill-founded data structures
20:48:14 <echo-area> Cale: I don't quite understand your explanations now, but I'll read more and think about them.  Thank you
20:48:28 <mmercer> completely unsafe for work but it is so cool i have to post it! http://www.cam4.com/hotnoielya
20:49:29 <dmj`> @where ops
20:49:29 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
20:49:52 --- mode: ChanServ set +o dibblego
20:50:02 --- mode: dibblego set +b *!*bc812366@*.bstnma.fios.verizon.net
20:52:02 <lpaste> tippenein pasted “parser help” at http://lpaste.net/154719
20:52:40 <tippeneinn> trying to figure out how to directly parse a data type from a string into a list of data types ^
20:53:59 <tippeneinn> it would be nice to parse out any constructor of the Thing type
20:54:01 <Axman6> tippeneinn: Derp <$> string "Derp " *> parseContent <|> Herp <$> string "Herp " *> parseHerpContent ...
20:55:01 <Axman6> that might not be the best was to do it, depending on what the content might be. is the content structured? or does it just take everything until it sees Derp or Herp or Stuff in the string?
20:56:02 <pavonia> As all contructors have the same type you could also do something like (Derp <$> string "Derp " <|> ...) <*> parseString
20:56:44 <tippeneinn> it would take further parsing (it's an FFR) but it should swallow up all the content until the next Thing type
20:56:55 <Axman6> FFR?
20:57:28 <tippeneinn> fixed format response
20:58:25 <tippeneinn> so you'd get something like "Derp some stuff Herp and such" and would expect [Derp "some stuff", Herp "and such"]
21:06:27 <dmj`> is anyone aware of a sliding window like Chan
21:07:12 <dmj`> I'd like writes to be non-blocking, and 'slide' as new 'a's are written onto the write end of the queue. I'd only like a peek operation to see what is at the head, enqueue O(1) would be nice
21:07:50 <dmj`> peek O(1), and no dequeue (since elements 'fall off' as they are written)
21:15:02 <danilo2> Hello! :) Does anybody know an explanation why Haskell's Vectors are so "hackish"? I mean - they behave differently than any other structure. If I've got a vector and add an element to it, add onother one and so on, the vector is being copied with every such operation, unless I use VectorM and the ST - like monad to update it. Why GHC doesnt just "glue" these usages and doesnt operate on single copy
21:15:12 <danilo2> if there are no branches in my pure code?
21:15:59 <danilo2> (bybranches I mean - data-flow branches - the vector is just updated step by step). Of course I can use the bulk update, but sometimes we just cannot to and have to fall-back to the monadic interface.
21:17:07 * hackagebot http2 1.5.3 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.5.3 (KazuYamamoto)
21:20:02 --- kick: mmercer was kicked by dibblego (mmercer)
21:43:38 <ggVGc> is there a binary version of read and show?
21:43:43 <ggVGc> for easy serialising?
21:44:28 <Clint> you mean like binary/cereal?
21:45:13 <ggVGc> well, maybe
21:45:17 <ggVGc> I'l check it
21:46:20 <ggVGc> Clint: with binary I have to write my own serialiser though right?
21:46:23 <ggVGc> rather than just derive show
21:46:31 <Clint> ggVGc: you can do it with generics
21:46:50 <Clint> ggVGc: see top of https://hackage.haskell.org/package/binary-0.8.2.1/docs/Data-Binary.html
21:47:02 <ggVGc> thanks
21:59:16 <EvanR> ggVGc: the point of binary is kind of that you are expected to write your own instance because you know better than just encoding the show string as bytes
22:00:28 <EvanR> utf8 is technically "binary"
22:01:40 <ggVGc> EvanR: yeah I was just thikning something simple like giving each identifier a number
22:01:45 <ggVGc> rather than a byte per character
22:01:54 <ggVGc> I don't care about the serialization format for this
22:01:58 <ggVGc> jsut want persistance quick and easy
22:02:00 <EvanR> well, then use show?
22:02:11 <ggVGc> yep, just wondered if there was a binary version of it
22:02:17 <ggVGc> all good
22:02:22 <EvanR> encodeUtf8 ;)
22:03:15 <EvanR> binary does have good default instances for certain things
22:15:49 <ij> What does one do when a package doesn't build because of fatal source errors?
22:16:02 <ij> or when its deps don't build
22:18:30 <ij> cabal update, of course!
22:22:30 <Axman6> or, better yet, start using stack and avoid these problems altogether
22:22:49 <ij> How does it solve this? 
22:25:41 <Axman6> you are almost guaranteed that packages will build, and they will always build because their versions are locked down
22:27:07 <Axman6> if the package is in an LTS release, then you know it and its deps will build together (the only thing that might affect that is if a package depends on a C dependency, but that's not very common)
22:39:47 <cr00kz> o/
23:42:12 * hackagebot task-distribution 0.1.0.2 - Initial project template from stack  https://hackage.haskell.org/package/task-distribution-0.1.0.2 (axm)
23:44:29 <codebje> :r
23:55:12 <ij> stack setup gives me this: http://lpaste.net/2386873107760545792 ghc fails sanity check
23:56:19 <ij> I might try --no-system-ghc.
23:57:14 <liste> ij: worth a try. how did you install your system ghc?
23:57:25 <ij> pacman
23:58:00 <montanonic> Is there a way to do auth in Yesod through JSON instead of HTML? I'm specifically looking at "authLayout" in Yesod Auth, but it's defined to require an HTML type.
