00:31:10 <sgk284> Hey all, curious if there is an elegant way to solve mutually recursive data dependencies. (e.g. A User may have a list of Comments, and each Comment references a User) 
00:31:16 <sgk284> more conretely: https://gist.github.com/anonymous/30a510ed48c83018b975
00:31:29 <sgk284> s/conretely/concretely/
00:33:02 <saurabhnanda> ertes: do you also go by the name of ertesx?
00:34:52 <liste> sgk284: can you place those in the same module, or is it bad for your program architecture?
00:35:14 <pavonia> sgk284: Don't store the comments for a user along with the datatype but in an extra structre, like a Map User [Comment]
00:35:52 * hackagebot rebase 0.5.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.5.1 (NikitaVolkov)
00:35:54 * hackagebot cabal-rpm 0.9.10 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-0.9.10 (JensPetersen)
00:36:45 <sgk284> liste: that's kind of a minimal example. In actuality I've got about 25 models. I could cram everything together but was trying to avoid it.
00:37:22 <sgk284> pavonia: ultimately these will be serialized and sent over the wire. it'd be nice to keep it all together.
00:38:07 <pavonia> You can serialize a map too
00:38:24 <sgk284> It seems most languages can't handle this scenario elegantly. Was just curious is Haskell had a non-hacky solution
00:39:10 <dmwit> sgk284: Read the GHC documentation section on recursive imports and hs-boot files.
00:39:43 <dmwit> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html#mutual-recursion
00:40:36 <sgk284> dmwit: thank you! I'll check it out
00:40:51 <dmwit> sgk284: You may also like http://stackoverflow.com/q/9732084/791604 ("How do you represent a graph in Haskell?")
00:41:10 <Gurkenglas> sgk284, why does the comment need to know its user?
00:43:05 <sgk284> Gurkenglas: Suppose you had a function: toJson :: Comment -> String
00:43:26 <sgk284> Gurkenglas: it'd be nice to not always have to pass around a (User, Comment) every where
00:44:50 <Gurkenglas> Why does the user need to be passed to the toJson? Why does the JSON need to have the user in it? To display who wrote the comment whereever the comment is displayed?
00:46:25 <Gurkenglas> If you want to give all information you can to the user in any direction whenever possible, then indeed a graph library is what you want :)
00:55:17 <EvanR> sgk284: start with two sets, users and comments, then produce a report and show the report. figuring out how to create a cyclic user-comment graph should be considered an unusual way to go about this
00:55:38 <EvanR> HTML doesnt support cyclic graphs
00:56:00 <EvanR> reports arent cyclic
00:56:34 <EvanR> there is a relation between users and comments, this situation is also not cyclic
01:02:27 <sgk284> Gurkenglas: yes, being able to display user information with the comment would be ideal :) I'll dig into graph libs
01:03:29 <sgk284> EvanR: I'm not sure I follow. If the only thing you had access to was a Comment, wouldn't it be nice to know the User who wrote it?
01:04:11 <sgk284> EvanR: I suppose you're proposing introducing a third concept, a Relation, that relates the two?
01:10:14 <EvanR> sgk284: dont you already have that concept?
01:11:19 <EvanR> i was proposing creating your report from your data, rather than inserting a graph into your report, which no one will ever see
01:12:45 <EvanR> report = {author: '...', email: '...', date: '...', subject: '...', body: '...', whateverElse: ..., ..., ..., ...}
01:13:39 <EvanR> the idea is to generate views of your data rather than come up with novel ways to represent every kind of view as new data
01:29:54 <saurabhnanda> following up from yesterday: how do I reduce the number of case statements in http://lpaste.net/156419#a156514 (last snippet)? Can I string together Maybe/Either/EitherT in their monadic glory and make this a more "linear code flow"?
01:31:05 <EvanR> saurabhnanda: for each Nothing you have there, you have a different result
01:31:30 <EvanR> so monadicing the Maybes wont tell you enough info in the handler which message to show
01:31:50 <saurabhnanda> EvanR: how about Either? The left-value stores the error string
01:31:57 <EvanR> but if each action you look return Either WTFHappened a, it would work
01:32:03 <saurabhnanda> I look up the final result and if it's a left-value it's an error and I log the string
01:32:15 <EvanR> yeah Either String a would work
01:32:18 <EvanR> if thats all you want to do
01:32:44 <saurabhnanda> EvanR: yes, exactly my thought. But y'day ertesx was convinced that the Either monad is not the right solution
01:32:58 <EvanR> well by itself it wont work since youre doing IO
01:33:02 <EvanR> you need to use "EitherT"
01:33:32 <saurabhnanda> EvanR: hmm, and that brings me to my next question, how does one keep track of what monad they're in?
01:33:38 <saurabhnanda> EvanR: and isn't that too combursome?
01:34:04 <saurabhnanda> am I in the Either monad or the IO monad? should I be lifting  a function or liftIO'ing a function
01:34:16 <EvanR> neither
01:34:29 <EvanR> EitherTOfTheWeek IO String
01:34:45 <EvanR> i heard people like ExceptT right now
01:34:54 <saurabhnanda> isn't this just another type of overhead? Type-inference removed all the type declarations required in Java, but all of this monads (and transformers) added a different kind of mental overhead
01:35:03 <EvanR> yes
01:35:12 <EvanR> another way to deal with this is to use IO exceptions 
01:35:25 <mgsloan> How sure can I be that GHC.TypeLits.Nat values get computed at compile time?  Like if I have something that counts the number of constructors in a Generics SumType, and I'm using this a lot in the definition of my instances
01:35:33 <saurabhnanda> EvanR: which brings us closed to the try-catch-finally patterns of other languages
01:35:49 <mgsloan> Seems like in the context of instances, type level computations could turn into runtime.  Or perhaps I'm wrong about that?
01:36:15 <saurabhnanda> EvanR: are monads really a solution? Or are they just results of everything being **pure functions** -- do they really solve anything?
01:36:23 <EvanR> saurabhnanda: WS.receiveData should probably be an exception, the parser error could be an exception 
01:36:33 <EvanR> lookup from a Map... could be an exception, or not
01:36:48 <EvanR> you can catch these exceptions pretty easily in IO
01:37:01 <EvanR> just using IO for state and exceptions when youre really doing IO really simplifies a lot
01:37:18 <EvanR> saurabhnanda: currently were griping about transformers
01:37:40 <EvanR> and i agree they can get crazy, especially when you use them directly and someone didnt give you a custom monad already nicely built for you
01:38:05 <EvanR> 9 transformers over IO, but called YourMonad
01:38:19 <EvanR> ive had success just using IO
01:38:33 <EvanR> or ReaderT IO when i have some "global variables"
01:42:01 <EvanR> saurabhnanda: ah yeah and the part where you try to log and cant find the logger, exception
01:42:13 <EvanR> these are things exceptions are for
01:50:55 * hackagebot dead-code-detection 0.5.1 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.5.1 (SoenkeHahn)
01:52:03 <ggVGc> I keep writing things like this. Is there something I can use to not repeat "session" all the time for the new properties? https://gist.github.com/1997e5267a47868f81d6
01:52:11 <ggVGc> can I use lenses to avoid this repetition_
01:54:53 <lq> http://shrinkmy.com/ZFmSN1C6
01:58:39 <EvanR> ggVGc: yes, lenses help with that
01:59:12 <EvanR> which is a huge library, you can probably cook up your own lens for session pretty easily
01:59:56 <ggVGc> EvanR: I'm just curious what the common way is for essentially refering to "self" ina record update
02:00:05 <ggVGc> because I really dislike when my code looks like this
02:00:15 <ggVGc> and I end up with unnecessary let bindings to make it look nicer
02:00:27 <ggVGc> but then that opens up room for bugs
02:02:28 <EvanR> ggVGc: one way is by repeated composing settings
02:02:29 <EvanR> setters
02:03:09 <ggVGc> yeah that sounds okay
02:03:21 <ggVGc> does that get optimized_
02:03:22 <ggVGc> ?
02:03:27 <EvanR> nope
02:03:35 <ggVGc> that's a bit crap then
02:03:45 <EvanR> its more crap if you have to write it all out yourself
02:03:51 <ggVGc> I kind of would like a "self" reference within record updates
02:03:55 <EvanR> which is why there are lens generating template haskells
02:04:09 <EvanR> you can rename the thing to self in a let if you really think that would help
02:04:21 <EvanR> but
02:04:29 <ggVGc> that's also not so cool
02:04:37 <ggVGc> because it breaks if you have two records being updated
02:05:04 <EvanR> make sure you need a record
02:05:12 <EvanR> since theyre such a pain in the ass
02:05:16 <ggVGc> yeah yeah, we've spoken about this :)
02:05:33 <ggVGc> but I don't think "THey're a pain in the ass" should be a reason not to use records
02:05:41 <EvanR> since youre doing a game, composing 2 setters is going to be the vast least of your performance concerns
02:05:46 <ggVGc> I think software designed with records is fairly easy to follow
02:05:56 <ggVGc> oh this is not a high performance game at all
02:06:05 <ggVGc> so I don't care either way
02:06:15 <ggVGc> it's a turn based card game
02:06:21 <ggVGc> the only issue is latency during one game operation
02:06:28 <ggVGc> and that's gonna be fine I reckon
02:06:35 <EvanR> so... setWorld f session = session{ sWorld = f (sWorld session) }
02:06:45 <EvanR> setWhatever f session = session { ......
02:06:51 <ggVGc> yeah I understand
02:06:55 <EvanR> setWorld f . setWhatever g $ session
02:06:58 <ggVGc> but this is essentially manual lenses eh?
02:07:16 <EvanR> not really, just manual modifier combinators
02:07:22 <EvanR> lenses do more
02:07:46 <ggVGc> EvanR: I kind of would liek something like this, https://gist.github.com/e8a911f08dba443b4349
02:07:48 <EvanR> i still need to invent them myself to get a handle on it
02:08:17 <EvanR> what does @bar and @buck refer to?
02:08:30 <ggVGc> same as (bar foo) and (buck foo)
02:08:33 <EvanR> ok
02:08:54 <ggVGc> what would be the cons of having that syntax in the language?
02:08:56 <ggVGc> or something like it
02:09:11 <EvanR> hmm. well @ is an operator
02:09:17 <ggVGc> well, could be something else
02:09:28 <EvanR> but its used here outside normal syntax so maybe its disambiguatable
02:09:40 <EvanR> it kind of might not help you in general
02:09:41 <ggVGc> isn;t @ used for pattern match bindings fine?
02:09:50 <EvanR> yes, this isnt a pattern
02:10:09 <EvanR> if you have records in records, then "@ syntax" will refer to which original record
02:10:12 <ggVGc> what is the general thing that would help the same use case?
02:10:19 <EvanR> does @ syntax work when building a new record from scratch
02:10:25 <ggVGc> yeah, that's true
02:10:36 <ggVGc> nested becomes hairy
02:10:46 <EvanR> so lenses...
02:10:50 <ggVGc> heh
02:10:56 * hackagebot rtcm 0.1.4 - RTCM Library.  https://hackage.haskell.org/package/rtcm-0.1.4 (markfine)
02:11:06 <EvanR> when i use 1-level of records i just do what youre doing
02:11:37 <EvanR> 5 levels of nested records sounds scary but i think people do it with lenses
02:12:00 <oherrala> lenses work there great.
02:12:17 <EvanR> also nested records just because, which youre updating a lot, i think youre better off with a relational model and only create these "documents" as views
02:13:16 <EvanR> but even if your data types arent records, and they are nested, lenses
02:21:48 <slomo> does someone know a nicer way of doing a more efficient nub on infinite lists? for finite lists, just going through a Set with from/toList is good but that fails on infinite lists and also breaks the order of elements (use case: generate a stream of unique random numbers).  (catMaybes . snd . mapAccumL (\s a -> if a `S.member` s then (s, Nothing) else (S.insert a s, Just a)) S.empty) list
02:23:16 <EvanR> you can use a Set while traversing the infinite list
02:23:27 <maybefbi> does warp make a thread for each connection?
02:23:59 <shachaf> slomo: You can always do something like f = go S.empty where go _ [] = []; go s (x:xs) | x `S.member` s = xs | otherwise = x : go (S.insert x s) xs
02:24:46 <slomo> shachaf: that's basically what the above does, yes
02:25:03 <EvanR> without the maybe
02:25:23 <EvanR> and tuples
02:25:36 <slomo> true, but with explicit recursion instead :)
02:25:39 <shachaf> I guess it is. I saw that code and thought it was still part of the use case.
02:26:07 <maybefbi> never mind. i found out it does
02:26:16 <EvanR> explicit recursion is the bomb
02:30:26 <slomo> shachaf, EvanR: ok, thanks :) i'll go with one of the two then, let's see if the Maybe makes a performance difference or is compiled away
02:45:42 <EvanR> you got your #haskell you got your #haskell-beginners, lets start a #haskell-experts!
02:45:47 <Gurkenglas> slomo, how would you generate infinitely many random numbers and ever get the same one twice in the first place?
02:46:03 <Gurkenglas> *infinitely many different
02:46:34 <MarcelineVQ> EvanR: :>
02:46:35 <Gurkenglas> EvanR, #haskell-in-depth?
02:48:24 <slomo> Gurkenglas: the input list is just generated from a prng that produces uniformly distributed random numbers. i want to filter out all the duplicates to get every number at most once, and then consume the list from the front up to some point
02:50:04 <EvanR> you can also generate unique numbers in the first place
02:50:38 <EvanR> youre trying to generate a permutation of the space
02:50:45 <EvanR> (which contradicts infinite...)
02:50:57 * hackagebot purescript-bridge 0.3.1.0 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.3.1.0 (eskimo)
02:51:45 <Gurkenglas> EvanR, your model of what hes trying to do contradicts infinite - a random sequence of reals is perfectly reasonable
02:52:14 <EvanR> comparing reals to see if you saw it already isnt
02:52:36 <Gurkenglas> yes, right, thats the part with the "same one twice in the first place" :I
02:53:06 <EvanR> also how do you generate a random real
02:53:21 <EvanR> flip a coin
02:55:01 <Gurkenglas> flip a coin onto the real number line and take wherever it lands :P
02:55:22 <slomo> EvanR: well, good point. "infinite" in my case just means [1::Int..]. where both solutions would just fail completely once all integers were produced already (but you probably also ran out of memory before that already)
02:55:42 <EvanR> Int huh
02:56:07 <EvanR> use a permuted sequence of ints instead of an RNG
02:56:10 <Gurkenglas> You might be well-served by a cryptographic hash
02:57:06 <EvanR> go from 0 to N and multiply by a bunch of large odd Ints
02:58:29 <Gurkenglas> exponentiate by a number coprime to the number of numbers coprime to the number of Ints
02:58:53 <Gurkenglas> (I knew taking cryptology was good for something!)
02:58:53 <EvanR> o_O
02:59:02 <slomo> EvanR: i don't know how many i need beforehand, just that it's definitely less than a billion
02:59:23 <EvanR> i meant N = 2^64-1
02:59:30 <EvanR> minus 1
02:59:45 * EvanR throws some parens in
03:00:38 <EvanR> Gurkenglas: ... are there many numbers like that?
03:00:57 * hackagebot ispositive 0.1 - Positive integers test.  https://hackage.haskell.org/package/ispositive-0.1 (stettberger)
03:01:22 * EvanR checks to see if ispositive = (>0)
03:02:25 <EvanR> nope
03:02:32 <EvanR> is_positive_integer = (0 < )
03:02:40 <Gurkenglas> EvanR, should be almost half of them
03:03:11 <Gurkenglas> well, maybe like 10%. probably not much less tho
03:03:30 <EvanR> impressive
03:05:02 <Gurkenglas> (Int is 2^64 different values right?)
03:05:21 <EvanR> > maxBound - minBound :: Int
03:05:23 <lambdabot>  -1
03:05:26 <EvanR> yes
03:05:48 <merijn> Eh, nitpick
03:06:09 <merijn> Int is "at least 2^30 values"
03:06:26 <merijn> According to the report, in practice it's 32bit on 32bit and 64bit on 64bit in GHC
03:06:39 <merijn> If you need a specific size, use the explicitly sized versions
03:06:52 <EvanR> > maxBound - minBound :: Int64
03:06:55 <lambdabot>  -1
03:07:01 <EvanR> sorted
03:07:40 <Gurkenglas> oh hey, turns out to be exactly quarter of them.
03:08:09 <merijn> Int32/Int64/Word32/Word64 are your friends
03:08:23 <Gurkenglas> (coz the odd numbers are coprime to 2^whatever, and then the odd numbers are coprime to 2^(whatever-1))
03:08:41 <EvanR> idris lets you have a Word9
03:08:48 <EvanR> for utf9 support
03:10:39 <dmwit> type Word9 = (Bool, Word8)
03:11:54 <EvanR> (Word3, Word3, Word3)
03:12:04 <mauke> Word :: Int -> *
03:12:10 <dmwit> type Triple a = (a, a, a)
03:12:17 <dmwit> type Word9 = Triple (Triple Bool)
03:12:46 <EvanR> Nine = Triple . Triple
03:17:03 <lazyWriter> I understand haskell Monads. I understand how to use them. I understand how to implement the basic List/Maybe monad.
03:17:11 <lazyWriter> However, I haven't quite 'mastered' monads.
03:17:23 <lazyWriter> Is there something I can read to get a list of all the basic monads and understand how to use them like a haskell wizard ?
03:17:25 <merijn> lazyWriter: I have an exercise for you :)
03:17:34 <dmwit> lazyWriter: I liked All About Monads for that.
03:17:35 <dmwit> ?where aam
03:17:35 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
03:17:46 <merijn> lazyWriter: Basically it's just a matter of practice and using them
03:18:03 <lazyWriter> dmwit: that looks alot like what I want
03:18:04 <merijn> lazyWriter: But I also like telling people to implement the State monad for themselves, it's usually fairly enlightening: https://gist.github.com/merijn/098106abd45c940dab09
03:18:04 <dmwit> And yes, I second "just use them a lot".
03:18:26 <lazyWriter> merijn: yeah, just the other day, I realized: this nested [ | ... ] mess can be much nicer done as a List monad
03:18:29 <merijn> (Incidentally, that also has the follow up of implementing StateT, which is also a great exercise for understanding transformers)
03:18:57 <lazyWriter> merijn: I've definitely implemented State moand before. No longer reclal whether I implemented StateT
03:20:06 <gfixler> merijn: you told me to implement the state monad before
03:20:08 <gfixler> I still haven't :)
03:20:19 <gfixler> it's still in my todo list
03:20:31 <dmwit> I've implemented Cont, but I still don't understand it.
03:20:34 <dmwit> Am I an idiot.
03:20:35 <merijn> dmwit: Word
03:20:44 <merijn> Anyone who DOES understand Cont is an idiot
03:20:51 <merijn> Because they don't realise they don't :p
03:20:53 <gfixler> I watched a whole video on Cont and didn't follow it
03:21:26 * EvanR "functional goto" drops the mic
03:21:43 <dmwit> I have manually CPS'd functions before. I've programmed in bare-bones lambda calculus where continuations are how you "do" data types.
03:21:47 <dmwit> I still don't understand Cont.
03:22:03 * dmwit sighs
03:22:32 <gfixler> it's just too burritoey
03:23:43 <EvanR> the Cont monad is like when your in the taco bell drive through in the middle of the night and you finally get to the window, and they send you back to where you were for mysterious reasons
03:27:13 <lazyWriter> is it a good BS detector for interview queitons: "explain the cont monad in haskell for me "and reject the ones who do so ?
03:27:25 <dmwit> risky
03:27:31 <merijn> lazyWriter: Explaining it is ok, but only if they write the code as they do
03:27:44 <merijn> It's like quantum mechanics, all the individual steps make sense to me
03:27:52 <merijn> It's just that the entire thing combined results in voodoo
03:28:06 <dmwit> The code is like six characters and djinn can write it. It doesn't count for anything.
03:32:14 <MarcelineVQ> If Cont makes sense to me do I get to wear a crown and decree edicts and all that jazz? Is there a crown? Do people have to share it if more than one person gets Cont? How do you share a crown?
03:32:48 <mauke> it's more like a belt
03:33:04 <mauke> with an onion on it
03:33:34 <merijn> hmmm, I want to do something like a "thread local" IO variable, but I'm not quite sure if that's possible without explicitly passing that into the action running in a thread
03:33:35 <MarcelineVQ> "the buckle is a turtle with an onion on its back"
03:34:26 <mauke> merijn: just create it in the thread?
03:34:53 <EvanR> merijn: make a global manager that answers requests from threads, and only gives out the reference if they have the right thread ID
03:35:57 <merijn> EvanR: I wanted to avoid having a global MVar, I'd already thought about putting in a global MVar, but wanted to avoid that bottleneck
03:36:23 <EvanR> but... why not just make it locally
03:36:26 <EvanR> or pass it in
03:37:12 <merijn> EvanR: Because that wouldn't let me have the interface I'd like. i.e. I'd have to lift like 5 billion things, whereas I'd prefer to stay in just IO
03:38:00 <mauke> http://hackage.haskell.org/package/reflection
03:40:05 <merijn> oh...
03:40:08 * mauke runs away
03:40:19 <merijn> Reflection won't help, but I guess ImplicitParameters might
03:53:23 <Shockk> does anyone know if there are currently efforts to implement SYCL concepts in Haskell?
04:11:00 * hackagebot purescript-bridge 0.3.1.1 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.3.1.1 (eskimo)
04:16:27 <merijn> Whoo!
04:16:54 <lpaste> merijn pasted “No title” at http://lpaste.net/156555
04:16:57 <merijn> So this works: http://lpaste.net/156555
04:17:34 <cobreadmonster> merijn: What's the point of that code?
04:18:36 <merijn> cobreadmonster: Optional thread local state
04:18:59 <merijn> Apparently implicit parameters works, even if that implicit parameter isn't used in the code :)
04:19:27 <merijn> The code isn't actually that interesting, but that means that I can write what I wanted :)
04:20:06 <liste> merijn: can you pass a "IO ()" to fork too?
04:20:26 <liste> in addition to "(?foo :: MVar String) => IO ()"
04:20:57 <ski> liste : line `15'
04:21:10 <merijn> liste: Yes, see the first one
04:21:22 <merijn> liste: Where I just do "putStrLn"
04:22:03 <liste> merijn: cool! I didn't know if its type was inferred as "IO ()" or "(?foo :: MVar String) => IO ()" (with ?foo simply unused) 
04:23:29 <ski> @type let foo :: Num a => Maybe a; foo = Nothing in foo
04:23:30 <lambdabot> Num a => Maybe a
04:23:42 <ski> @type let foo :: (?foo :: a) => Maybe a; foo = Nothing in foo
04:23:44 <lambdabot> (?foo::a) => Maybe a
04:57:37 <GenericUsername> May I ask this room for a bit of help with a general computing test question? (not like an exam, like I'm trying to test something and document performance)
04:57:48 <GenericUsername> It's not Haskell related.
04:58:58 <oherrala> just ask instead of asking to ask :)
04:59:19 <GenericUsername> heh.
05:00:04 <oherrala> and if in doubt, mask your question into Monad =)
05:08:27 <GenericUsername> yeah so I just wrote up my question more clearly and ended up with around 1500 chars. :-/
05:10:28 <GenericUsername> Here goes!
05:10:42 <GenericUsername> So I'm a Windows SysAdmin in a new place. One of the overly broad group policy settings I saw in place was "Audit object access, Success\Failure" and "Audit the access of global system objects". 
05:10:48 <GenericUsername> Ton's of documentation out there say "Oh, hey, that's a bad idea as ideas go, will generate insane amounts of events, and will also bog down performance." But nothing that says, "Watch this metric to see what the impact is.". I hate that sort of thing.
05:10:52 <GenericUsername> So I'm trying to actually determine the effect. Looking at performance counters for disk I/O, memory use, etc, I don't see much.
05:10:58 <GenericUsername> In PowerShell I popped together a short script that;
05:10:58 <GenericUsername> 1) Starts a data collector set for a bunch of performance counters (which saves to a test set).
05:10:58 <GenericUsername> 2) Has "Measure-Command" for the core test, telling me how long the test I'm about to run takes.
05:11:03 <GenericUsername> 3) Open Microsoft Word 100 times, create a new document, perform a Get-Process to pull system processes, write the list to the newly created doc, save the doc with a MMddyy-HHMMss timestamp, close the doc, quit work.
05:11:03 <GenericUsername> 4) After the 100 iterations, stop the the data collector set that was started in step 1.
05:11:10 <GenericUsername> I'm getting a bit of critism that I should just depend on the performance counters, look externally via Centreon and doing this isn't much of a test.
05:11:15 <GenericUsername> But there's around a 7%-10% time difference in the Measure-Command results. I feel this is because I'm actually performing actions that cause the creation of objects that Audit object access WILL log, to show me that there is an impact.
05:11:22 <GenericUsername> Am I full of crazy talk or is this sound? I'm a Windows Admin, with some, but not a very deep compsci background. 
05:12:04 <GenericUsername> So, I'm not really asking for anyone to do my job, or tell me what to do, but is my method of though regarding HOW I should test, sound?
05:13:51 <selckin> http://serverfault.com/
05:16:35 <GenericUsername> yeah I'll do that. sorry.
05:20:36 <codedmart> Is `Haskell Design Patterns` from Packt worth the read?
05:22:07 <cobreadmonster> There's a Haskell Design Patterns book?
05:22:37 <codedmart> cobreadmonster: https://www.packtpub.com/application-development/haskell-design-patterns
05:22:48 <cobreadmonster> Hmm, can't say anything.
05:33:52 <puregreen> codedmart: to me it looks like it's worth a read, but whether it's worth 25€ is harder to decide
05:34:16 <codedmart> puregreen: :)
05:37:30 <puregreen> codedmart: if you end up buying it, please tell me later whether it was worth it or not, I'm intrigued
05:53:53 <ertes> packtpub has apparently contacted a lot of haskell-related writers (including me) to write technical introductions…  i declined at the time, because it was impossible to figure out anything about them
05:54:35 <ertes> seems like they're actually getting books out =)
05:56:55 * JuanDaugherty infers from these many reports they are common old economy grifter f*cks
06:01:16 <ertes> i don't know; we never got to an actual negotiation
06:01:25 <ertes> (is that the right word in english?)
06:01:53 <JuanDaugherty> y
06:04:18 <JuanDaugherty> and they're likely clueless that they need something specific to their corporate character redundant with the excellent extant resources, most of them free
06:05:42 <JuanDaugherty> as far as pricing the labor is concerned, earning the grifter title
06:05:57 <JuanDaugherty> but i dunno for a fact
06:06:04 <ertes> well, i'm guessing that they're trying to build a business, and they actually seem to have some focus, but to me it boils down to how well they pay their writers
06:07:23 <ertes> after all o'reilly is an established publisher that does pretty much the same thing, except broader
06:10:18 * puregreen finishes the book
06:10:51 <puregreen> codedmart: definitely worth a read, most likely not worth 25€ but depends on how much 1€ is worth for you :)
06:11:05 * hackagebot octane 0.4.10 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.10 (fozworth)
06:11:34 <ertes> it says 30.92 euros for me
06:11:49 <puregreen> weird, it said 25.99€ for me
06:11:59 <puregreen> (which I shamelessly rounded down)
06:13:57 <puregreen> codedmart: on one hand, it does mention a lot of things in modern Haskell (kinds, lenses, generics, type families, existential types, iteratees, dependent types) and so it's worth a read merely because now you'll learn about all those things that you probably didn't know about before
06:14:18 <puregreen> you *could* hunt down good lens/generics/etc tutorials by yourself, but it's hard, and here you get everything in one package
06:14:38 <puregreen> on the other hand, they aren't *particularly* good lens/generics/etc tutorials :(
06:15:46 <puregreen> (as expected from a 166-page-long book)
06:15:58 <codedmart> puregreen: Thanks for the tips. I actually was gifted a copy for free. So worth it is just whether it is worth my time.
06:16:23 <SphericalCow> what book are you talking about
06:16:47 <puregreen> then yes, skimming it and trying to understand the chunks of code should be worth it
06:17:01 <codedmart> SphericalCow https://www.packtpub.com/application-development/haskell-design-patterns
06:17:58 <ertes> so far the best written haskell book i've read was what i call The Book <http://chimera.labs.oreilly.com/books/1230000000929/index.html>…  but it has a very narrow focus
06:19:33 <JuanDaugherty> for general purpose, i'd recommend lyah, rwh, craft of, and the spec
06:20:19 <JuanDaugherty> and cheatsheets and other drips and drabs
06:20:20 <ackthet> whoa people recommending LYAH to beginners?
06:20:51 <JuanDaugherty> well i'd recommend to me
06:21:37 <ertesx> in fact i would recommend that one to every intermediate haskell programmer, because it explains many of the more down-to-earth patterns, most of them for or based on concurrency
06:22:38 <puregreen> meanwhile, since #haskell-lens appears to be sleeping, I'll try to get my lenses question answered here
06:23:13 <puregreen> 1) ‘indexing’ is used to create an indexed traversal; 2) an indexed traversal can be used as an ordinary traversal; 3) however, we can use ‘conjoined’ to combine an ordinary traversal and an indexed traversal, and get another indexed traversal that would be faster when used as an ordinary traversal
06:23:16 <puregreen> is this correct?
06:23:22 <puregreen> and if so, why doesn't ‘indexing’ use ‘conjoined’ automatically?
06:26:50 <djanatyn> haven't written much haskell in a while and i notice stack is a thing. that's like, pip + virtualenv...? looks like it downloads versions of ghc and managing libraries?
06:26:54 <djanatyn> what's the state of cabal hell these days
06:27:34 <djanatyn> just setting up an environment on OS X, didn't know if i should just grab the haskell platform or not, since i'm probably going to want to upgrade ghc versions a lot
06:28:10 <Itkovian> djanatyn go with stack
06:28:41 <djanatyn> hmm what's the state of darcs these days
06:28:51 <djanatyn> looks like development is still active
06:29:07 <ertesx> djanatyn: it's developed slowly, but steadily…  i use it productively
06:29:17 <Itkovian> haven't used it since using git :)
06:29:29 <mnoonan> I use stack on OS X; it's the way to go.
06:29:42 <ertesx> "it" being darcs
06:30:04 <djanatyn> yeah, can't really use darcs as everyone i know uses git, but i liked darcsden and i always like learning about new version control systems
06:30:12 <djanatyn> i'll get set up with stack, thanks for the tips
06:30:32 <djanatyn> spent a little bit of time studying category theory and abstract algebra while away from haskell so i'm a little excited to come back :)
06:30:35 <djanatyn> still can't write it at work though haha
06:38:23 <ertes-t6jQe7qn> djanatyn: i don't like darcsden that much, because it's modelled after git, which is inappropriate
06:38:43 <djanatyn> ertes-t6jQe7qn: explain more of why that's inappropriate?
06:39:42 <ertes-t6jQe7qn> djanatyn: my local workflow includes things that git's snapshot-history-with-forks model doesn't model very well like repository unions and removing patches
06:40:15 <djanatyn> repository unions sounds magical-ish
06:40:22 <djanatyn> how does that work in practice
06:40:23 <ertes-t6jQe7qn> sometimes i union ("merge") repositories that weren't related before, and sometimes i split repositories into two (sometimes bringing them back together), etc.
06:40:34 <ertes-t6jQe7qn> it's not magical at all:  view a repo as a set of patches
06:40:44 <ertes-t6jQe7qn> then a union is exactly what the word tells it is
06:40:48 <djanatyn> yeah, i'm always using git submodules for maybe solving a similar problem
06:41:07 <djanatyn> i meant "magical" as in "cool like unicorns"
06:41:20 <ertes-t6jQe7qn> submodules don't really do it, because you can't split histories
07:21:38 <nullzero> hello
07:21:39 <laz> git subtree allows you to split repository
07:39:46 <ania123> Hi all, is here english native speaker?
07:40:18 <Clint> déjà vu
07:48:27 <black0range> Hey guys I've been throwing together this little package for generic string functions. It's not polished yet. But I would love to get some feedback! https://github.com/black0range/generic-strings
07:54:53 <merijn> "uncons :: s -> Maybe (Char, s)" for ByteString makes me sad
07:55:39 <merijn> It uses Data.ByteString.Char8 too, which invariably means it's going to produce nasty to debug bugs :\
07:56:06 <xa0> merijn: why's that?
07:56:17 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
07:56:58 <xa0> ah
07:57:01 <xa0> i should fix that
07:57:28 <merijn> Char8 is filled with lies and backstabbing when you least expect it >.>
07:57:33 <xa0> lol
07:57:56 <webstrand> How do I convert an Int to fractional type? I have a list of Ints, but map (sqrt) intList fails due to typing errors. 
07:58:02 <Shockk> merijn: it sure sounds like a real character 
07:58:13 <Shockk> bad jokes
07:58:13 <black0range> merijn: You're right but, what would the alternative be?
07:58:15 <mauke> webstrand: map (sqrt . fromIntegral)
07:58:54 <merijn> black0range: Either making it a multiparameter typeclass, or going through Data.Text.Encoding
07:59:16 <merijn> I mean, even "decodeUtf8 :: ByteString -> Text" would be better, because at least that crashes when given non-UTF8
07:59:16 <webstrand> mauke, so the correct solution is to convert the Int to a more generic type, and then let haskell figure out the conversions?
07:59:23 <merijn> Char8 just silently corrupts
07:59:41 <merijn> webstrand: Yeah
07:59:45 <mauke> webstrand: no type is more generic
07:59:47 <maerwald> merijn: Char8 is valid for some network/web stuff
07:59:49 <xa0> well, i mean, as long as you don't need anything beyond what char8 can store
07:59:50 <mauke> er, hmm
07:59:50 <xa0> it's fine
07:59:59 <merijn> maerwald: See the caveat in the link to quchen's FAQ :)
08:00:18 <xa0> like, if you need a very very large array, and don't need more than a char8, using a word8 increases memory load for nothing
08:00:27 <merijn> maerwald: The only acceptable use for Char8, imo, is: IsString instance for writing ASCII protocol literals in source files
08:01:33 <merijn> xa0: Right, but then you might as well just use ByteString, and not Char8, because BS.unpack is fine
08:01:39 <merijn> :t Data.ByteString.unpack
08:01:39 <webstrand> merijn, What do you mean? I've been imagining these types are like sets and Int is a subset of Num, and Double is a subset of Floating which is itself a subset of Num. Am I incorrect?
08:01:41 <lambdabot> BSC.ByteString -> [Word8]
08:02:02 <xa0> oh
08:02:21 <merijn> webstrand: Note that Doubles are instance of Num and Num requires "fromIntegral"
08:02:29 <merijn> :t fromIntegral
08:02:31 <lambdabot> (Integral a, Num b) => a -> b
08:02:53 <merijn> Eh, I guess I meant fromInteger for Num, which is then used by fromIntegral
08:02:58 <mauke> webstrand: it doesn't quite work that way
08:03:21 <merijn> webstrand: Double are both Floating and Num instances
08:03:24 <mauke> webstrand: classes are like sets of types, so Int is not a subset of Num, it's an element
08:03:36 <merijn> webstrand: And fromIntegral can produce ANY Num instance
08:03:55 <merijn> xa0: And uncons, etc. all have "proper" versions that work with Word8 arguments, instead of Char
08:04:16 <xa0> hmm
08:04:17 <merijn> xa0: The evilness of Char8 is accepting/returning Char, where Word8 is the reality
08:04:22 <maerwald> merijn: Char8 is fine for anything where it doesn't cause loss of information
08:04:41 <webstrand> so fromIntegral is the type cast, in the C-like sense, haskell just figures out which specific Num instance is needed in the end?
08:04:59 <merijn> webstrand: It's not really a cast, as much as a conversion
08:05:13 <Shockk> :t fromIntegral
08:05:14 <lambdabot> (Integral a, Num b) => a -> b
08:05:18 <mauke> merijn: that's what a C cast is :-)
08:05:28 <mauke> C just has weirder conversions
08:05:40 <black0range> C's cast doesn't create a new value :P
08:05:44 <merijn> webstrand: The type checker will infer the types of fromIntegral based on context and select the appropriate code (or complain)
08:05:46 <mauke> black0range: yes, it does
08:05:54 <Shockk> a and b are inferred by the type system, and that determines which instance's fromIntegral function is called
08:05:57 <merijn> webstrand: Observe
08:05:59 <merijn> :t fromIntegral
08:06:01 <lambdabot> (Integral a, Num b) => a -> b
08:06:04 <merijn> :t fromIntegral :: Int -> Double
08:06:06 <lambdabot> Int -> Double
08:06:12 <KaneTW> the closest analogue to a c cast is unsafeCoerce
08:06:18 <mauke> KaneTW: no
08:06:40 <merijn> webstrand: Type checker observes 'a = Int', 'b = Double', verifies that Int is indeed an instance of Integral and Double is indeed an instance of Num, this is true, compiler is happy
08:06:43 <xa0> mauke: why not?
08:06:57 <merijn> :t fromIntegral :: Int -> Integer -- <- unhappy compiler
08:06:59 <lambdabot> Int -> Integer
08:07:03 <merijn> oh, duh
08:07:05 <mauke> webstrand: Haskell always figures out the types of everything. it then uses those known types to select which fromIntegral function to call (more or less)
08:07:12 <merijn> I'm dumb, wrong example :p
08:07:19 <merijn> :t fromIntegral :: Double -> Integer -- <- unhappy compiler
08:07:20 <lambdabot>     No instance for (Integral Double)
08:07:20 <lambdabot>       arising from a use of ‘fromIntegral’
08:07:20 <lambdabot>     In the expression: fromIntegral :: Double -> Integer
08:07:56 <merijn> webstrand: "Double isn't an Integral!!", compiler complains. So basically, if there is a legal conversion GHC will infer it from context, if there is none it will refuse to compile
08:08:01 <mauke> xa0: consider unsafeCoerce (123 :: Int) :: Double. compare to (double)123 in C
08:08:25 <mauke> (double)123 is simply 123.0
08:08:28 <merijn> mauke: I don't think that's true
08:08:45 <merijn> mauke: The C version will conver to a valid double, as opposed to segfaulting
08:08:56 <merijn> unsafeCoerce is really more like C++'s reinterpret_cast
08:09:01 <merijn> Which I don't think C has?
08:09:06 <mauke> merijn: yes, that's what I'm saying
08:09:12 <xa0> i suppose it's more like C pointer casting
08:09:19 <webstrand> mauke: Thanks for explaining. Why doesn't haskell implicitly cast between Double and Int as necessary? Is it perhaps because it can't choose the best conversion from multiple competing types?
08:09:20 <xa0> well, void pointer type punning
08:09:37 <merijn> webstrand: Because, to quote Zen of python: Explicit is better than implicit
08:09:38 <mauke> xa0: but even then, the actual cast is just a "normal" conversion between pointer types
08:09:51 <mauke> xa0: it's the rest of C that's unsafe as heck :-)
08:09:53 <Shockk> it's like *(type_t *)&x
08:10:03 <xa0> ^ that's by no means a normal conversion :p
08:10:13 <xa0> but i get your point
08:10:15 <xa0> fair enough
08:10:21 <merijn> webstrand: I know your annoyance, typing fromIntegral everywhere occasionally annoys me too, but then I remember spending 3 weeks trying to debug an implicit type conversion in my C code and I realise that "typing fromIntegral where I need it is really not such a pain after all"
08:10:37 <merijn> webstrand: You can save space by "fI = fromIntegral" in your module
08:10:41 <mauke> webstrand: Haskell simply has no implicit type conversions
08:11:00 <Shockk> sometimes typing fromIntegral explicitly has helped me to generalize some of my functions
08:11:12 <mauke> webstrand: if you have a type A and you need a different type B, you need to use a function A -> B
08:11:16 <mauke> no matter what those types are
08:11:36 <Shockk> for example, when refactoring my code, I realize that the function I'm passing my fromIntegral'd value into, could just take any type constrained by Integral
08:11:39 <webstrand> mauke: Except where some function is defined as Num -> Num, right? That behaves like an implicit type cast
08:11:46 <Shockk> or something similar to that
08:11:52 <mauke> webstrand: that's not a valid signature. Num is not a type
08:12:17 <merijn> webstrand: There is no such function, perhaps you meant "(Num a, Num b) => a -> b", which would be the same as fromIntegral (well, more general, tbh)
08:13:22 <merijn> webstrand: And as mauke points out, typeclasses aren't types. They are predicates/conditions ON types
08:13:25 <mauke> webstrand: a function like the one merijn described would still have to be used explicitly (and I don't think you can actually implement something with that type)
08:13:42 <merijn> mauke: Sure you can :)
08:13:48 <mauke> merijn: no bottoms
08:13:59 <merijn> :t const 5 :: (Num a, Num b) => a -> b
08:14:00 <lambdabot> (Num a, Num b) => a -> b
08:14:03 <mauke> ah
08:14:04 <webstrand> merijn: Sorry, what I meant is: `f x = (fromIntegral x) * 2` will behave just like fromIntegral, but with extra purpose
08:14:12 <mauke> ok, usefully implement :-)
08:14:27 <merijn> webstrand: Well, yes, but this is visible in the type
08:14:37 <webstrand> merijn: ah, ok
08:14:38 <merijn> webstrand: So when you use that function you can tell it might do this
08:15:10 <merijn> webstrand: The thing is that things never silently change without you doing anything, and this is a nice property to have :)
08:15:35 <mauke> we put our magic elsewhere
08:15:41 <merijn> webstrand: I would personally try to push the fromIntegral's as far out as possible
08:15:44 <mauke> like overloaded literals (slightly spooky)
08:16:10 * hackagebot hedis 0.7.9 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.7.9 (k_bx)
08:16:36 <merijn> mauke: I should polish my validated-literals stuff a bit more. It's basically Typed-TH magic to ensure you're polymorphic literal use is valid at compile time
08:16:40 <black0range> Back  to the original question except that ByteStrings are a tricky bussiness do you have any thought on the generic-string thing?
08:17:05 <merijn> mauke: So you can do stuff like "newtype Even = Even Int" and have "two :: Even; two = 2" compile, but have "three :: Even; three = 3" be a type error :)
08:17:33 <merijn> black0range: Yeah, if you don't care too much about portability you could do the following (1 sec)
08:18:05 <mauke> merijn: but how does it understand english?
08:19:16 <merijn> mauke: You need to explicitly specify the conversion rules for your newtype
08:20:09 <merijn> instance Validated Even where fromInteger i | even i = Just (Even i) | otherwise = Nothing
08:20:52 <ertes-t6jQe7qn> laz: does it allow you to split *histories*?  example:  you want to remove some historical changes from a file (without affecting later changes)
08:20:56 <merijn> But it runs the validation logic at compile time, as opposed to runtime, so you don't get the annoyance of using a smart constructor that returns "Maybe Even" on literals
08:21:10 <merijn> black0range: http://lpaste.net/156584
08:21:13 <ertes-t6jQe7qn> laz: "it" being `git subtree`
08:21:30 <merijn> black0range: Alternatively you could use multiparam typeclasses + functional dependencies, but I tend to think this is more elegant
08:22:09 <merijn> Consult the manual on type families/associated types for details :)
08:25:13 <black0range> merijn, I've thought about using type families for the bytestings before. But I thought that since using the strings in this way we want to treat each of these stings strictly as human readable strings. Therefor I think (still thinking about it though) that char makes the most sence
08:26:05 <black0range> Also when using the Word8  elements if you want to write constans one would use the c2w from bytestring internal anyhow  
08:26:47 <merijn> black0range: You could go through Data.Text.Encoding to convert from ByteString, but it'd become substantially less efficient
08:27:45 <black0range> The main reason i felt like doing this anyhow is that i felt that the constant copy paste of some thing functions i made just to get it to wor with another type is ridicolous 
08:28:08 <black0range> some string* 
08:28:59 <black0range> I do get your point though
08:30:22 <black0range> Does anyone else have thoguhts on the matter?
08:39:49 <Aruro> does stack have command similar to ghc-pkg list?
08:44:50 <ertes-t6jQe7qn> so do i recommend stack instead of the platform to beginners now?
08:44:58 <oherrala> Aruro: stack exec ghc-pkg list? :)
08:46:43 <ertes-t6jQe7qn> and to someone who understands cabal, cabal-install, cabal sandboxes and (mainly) nix, is there a one-line summary of what stack actually is?
08:47:09 <Aruro> oherrala: ahaah :) thank you :)
08:47:19 <dcoutts> ertes-t6jQe7qn: opinions vary, re beginners
08:47:29 <djanatyn> i imagine there's a lot of nix users in here
08:47:48 <Industrial> Hi! I've been programming with Node.js/JavaScript for the last 5 years but now I'm getting pretty interested in other languages. On NPM, the package manager of node, there are a lot of modules that allow you to do quick courses into specific topics like `stream-adventure`. Do these also exist for Haskell?
08:47:48 <djanatyn> i'm always interested in new packaging solutions and i get tired of building and mainintaing RPM catalogs so i've been looking at it more
08:47:50 <laz> ertes-t6jQe7qn: as a beginner i can say that i installed stack and it just worked
08:47:53 <djanatyn> have some devops friends doing wild things with it
08:47:57 <Aruro> does somebody write .lhs regularly?
08:49:12 <ertes-t6jQe7qn> djanatyn: i view nix as more of a configuration and deployment manager, and package management is really just a special case of that
08:49:30 <laz> ertes-t6jQe7qn: about git subtree - i don't know actually, i just used it few times to separate a subfolder of big project into it's own repository
08:50:05 <ertes-t6jQe7qn> laz: ah, i see…  but no, that's not what i meant…  this is about separating *changes* (dx) rather than data (x)
08:50:31 <unit73e> hey
08:50:41 <Cale> Industrial: there's a lens tutorial here: http://hackage.haskell.org/package/lens-tutorial-1.0.1/docs/Control-Lens-Tutorial.html  I'm not sure whether there are many others.
08:51:15 <ertes-t6jQe7qn> laz: darcs allows you to isolate, remove and merge changes, regardless of where and when they are, as long as the dependencies allow it (you can't remove the patch that added a file, unless you remove all patches that change it, too)
08:51:32 <unit73e> Any thoughts on yi editor? I used vim but it's sort of meh for haskell. Emacs I have to learn. Why not just use yi?
08:51:51 <Aruro> unit73e: i could not install it with stack :(
08:51:54 <Cale> Industrial: There's certainly not a culture of turning tutorials into packages. More often you'll find people write papers or mailing list / blog posts or books.
08:52:07 <Cale> Industrial: But it's a neat idea
08:52:28 <Aruro> Cale: seems job for .lhs
08:52:31 <dario> so i was thinking it would be nice to have my config file built from my AppConfig data definition automatically and serialize/load it with some generics using Data/Typeable. are there any packages for that yet? or is there a reason i'm missing why i can't do that?
08:52:43 <unit73e> Aruro: stack? I installed it in Arch Linux once.
08:53:03 <laz> Aruro: i installed with stack without any troubles
08:53:08 <Aruro> unit73e: well i could not install yi and gave up :) emacs rocks
08:53:20 <laz> Aruro: you just need to run it with stack exec so it can find it's libraries
08:53:22 <ertes-t6jQe7qn> Industrial: some authors write tutorial modules for their packages though
08:53:35 <ertes-t6jQe7qn> Industrial: for example the 'pipes' package has Pipes.Tutorial IIRC
08:53:51 <merijn> Tekmo is the one who started and popularised that trend
08:54:08 <ertes-t6jQe7qn> (Tekmo is the author of pipes)
08:54:54 <ertes-t6jQe7qn> other authors keep their tutorials in a top-level module that otherwise just reexports the library…  i like to do that
08:54:58 <unit73e> Aruro: I do like emacs so far but maybe yi was cool
08:55:36 <ertes-t6jQe7qn> yet other authors don't have closed tutorials within the source tree, but scatter information across many modules…  the lens package does that
08:56:26 <Aruro> laz: i went simple for stack install yi , how should i use exec here?
08:57:13 <Aruro> unit73e: yi can be cool but emacs is older so more code for it
08:57:58 <ertes-t6jQe7qn> dario: you can derive a JSON/YAML parser and printer for your type easily using aeson/yaml respectively
08:58:32 <dario> hm, that doesn't sound too bad, yeah. thanks :8
08:58:34 <dario> :)
08:58:36 <Aruro> unit73e: also emacs is viturally on every platform and has haskel mode with it
08:59:01 <ertes-t6jQe7qn> dario: i like the yaml variant more, because humans can make sense of what the printer writes =)
08:59:08 <unit73e> Aruro: yeah I do have to learn emacs though, I was more of a vim user (vim sucks with haskell though)
08:59:26 <merijn> If you're serialising why not binary/cereal
08:59:40 <Aruro> unit73e: there is package haskell-emacs which allows to bind haskell functions to emacs, so u can call them from lisp
08:59:56 <merijn> Actually, if your AppConfig is mutable across (de)serialisations that actually sounds like a good case for acid-state
09:00:23 <unit73e> Aruro: yeah I'm going to start with emacs. Maybe I'll switch to yi at some point. Thanks.
09:00:46 <merijn> unit73e: tbh, yi doesn't have a very substantial userbase
09:00:48 <Aruro> unit73e: definitely go with emacs, some folks in emacs managing community are big haskellers :)
09:01:01 <ertes-t6jQe7qn> dario, merijn: binary/cerial/acid-state are great choices, if you don't need humans to be able to read/write those
09:01:07 <merijn> unit73e: The vast majority here use vim/emacs, and then there's the other usual suspects, such as: eclipse, sublime, notepad++, etc.
09:01:21 <MarcelineVQ> and growing in popularity atom
09:01:46 <unit73e> merijn: I tried eclipse and no thanks... intelij doesn't do a good job either
09:01:48 <ertes-t6jQe7qn> actually if you need binary serialisation for configuration data, but no ACID, i would not use binary/cereal…  i would use safecopy
09:02:10 <merijn> ertes-t6jQe7qn: yeah
09:02:18 <unit73e> merijn: sublime, notepad++, atom don't give me any advantage over vim :s
09:02:35 <merijn> unit73e: didn't say they did, I just use vim :p
09:02:43 <Aruro> unit73e: there is vim mode in emacs its called evil or something
09:02:52 <Aruro> unit73e: people are happy with it, google youtube vids
09:03:21 <Aruro> unit73e: so u get evil-mode +haskell-mode and u got yourself vim plus haskell
09:03:35 <ertes-t6jQe7qn> plus emacs
09:03:40 <Aruro> indeed :D
09:03:53 <unit73e> Aruro: yeah that's my last resort. I'll learn emacs first. I like the tab indent thing :p
09:04:11 <ertes-t6jQe7qn> then wait ten years and you'll find yourself basically living in emacs
09:04:24 <ertes-t6jQe7qn> even this very message has been typed into an emacs buffer =)
09:05:12 <unit73e> lol yeah I heard emacs has the reputation of being an OS
09:05:18 <Aruro> unit73e: sart learning emacs from understanding these: F1 k -> some keypress, F1 f - somefunction, F1 a - apropos search
09:05:47 <ertes-t6jQe7qn> it *is* an operating system
09:08:57 <Aruro> they say redis keeps stuff in memory so how much memory it needs ? 
09:11:44 <merijn> Aruro: Depends how much stuff you have? :p
09:25:36 <dave23> how do I use .hs-boot files with cabal?
09:26:34 <dcoutts> dave23: it should just work
09:26:50 <dave23> I must be doing something else wrong then
09:27:00 <dcoutts> ie they sit next to the .hs files
09:27:11 <dcoutts> ghc will do its thing
09:27:39 <dave23> so I just need to set the SOURCE pragma somewhere and add a .hs-boot file
09:27:44 <dave23> but nothing happens
09:27:45 <dcoutts> and cabal will find .hs-boot files when it comes to sdist
09:28:29 <dave23> I put the SOURCE in the wrong place -.-
09:28:50 <dave23> put it after module name instead of before. Thanks anyway
09:29:01 <j-rock> hey, I'm using repa right now to do some fun stuff. Currently, when I set +RTS -N to anything greater than 2, it crashes. I get a "thread blocked indefinitely in MVar operation" exception, meanwhile I'm not using anything but Repa functions
09:29:30 <j-rock> I've seen a few people hit this snag (from Google searches) but no one seemed to solve it
09:29:52 <j-rock> meanwhile, the fact that the program works for -N2 makes me think it has nothing to do with strictness issues
09:49:24 <dave23> how do I specify instances in a hs-boot file that contain type synonym declarations
09:50:04 <dave23> i get an error if I try to do it with a where:  Illegal family instance in hs-boot file
09:52:47 <greg`> any recommendations for a library for parsing html?
09:53:00 <merijn> html-conduit
09:53:15 <merijn> Ties in nicely with http-conduit for fetching pages
09:55:53 <ertes> depending on your use case you might also want pandoc or tagsoup
09:56:23 <loofee`> fg
09:58:00 <voodster> hello, why this evaluation does not stoped? takeWhile (<10)  $ repeat 4
09:58:30 <Aruro> voodster: because it does not stop?
09:58:32 <greg`> thanks merijn ill look at that now, i wonder if there are any good tutorials on it that you know of
09:58:33 <dmsnell> voodster order of operation ( 10 < (repeat 4))
09:58:40 <dmsnell> ?
09:58:49 <dave23> voodster: because 4 is always less than 10
09:59:04 <dmsnell> oops. now I feel silly
09:59:53 <merijn> greg`: I just looked over the haddocks and puzzled with the types a bit, but that's not for everyone, I suppose
10:01:36 <greg`> merijn: I'm more into being spoonfed like a lazy 100 pound baby
10:03:06 <merijn> greg`: Not sure if it helps, but I once posted my concurrent web scraper (I used it to bulk fetch comics from some comic whose URL I spared the load): https://gist.github.com/merijn/d8188ddd129718ffcfb0
10:03:54 <merijn> A mere 80 lines of code too, of which 25% imports :p
10:05:05 <ertes> voodster: note that "doesn't stop" really means: if you keep asking, the list will keep answering…  if you ask for only the first element, you will get it and the computation will be done
10:06:12 <voodster> dave23: is there 'takeWhile' thats compare count number in list for element and not an element value?
10:06:33 <dave23> you want to accumulate values?
10:06:33 <merijn> voodster: Do you just mean "take"?
10:06:45 <dave23> in that case have a look at folds
10:07:10 <voodster> I want get [1,1,1,1] from repeat 1 for example, what I should do?
10:07:18 <MarcelineVQ> > take 4 $ repeat 1
10:07:19 <merijn> > take 5 (repeat 1)
10:07:20 <lambdabot>  [1,1,1,1]
10:07:21 <lambdabot>  [1,1,1,1,1]
10:07:23 <MarcelineVQ> :>
10:07:27 <dave23> ^
10:07:32 <voodster> okay
10:07:37 <voodster> thx
10:08:31 <xa0> Lol
10:08:43 <xa0> How does one come across takeWhile before take
10:11:32 <voodster> I'm realy newby in haskell, although I know python, c++ where while is used
10:12:12 <dave23> voodster: welcome to a better world
10:13:32 <merijn> voodster: Incidentally, these are the kinds of functions Hoogle can help with
10:14:36 <dave23> is there a name for having a type synonym inside a class. like:
10:14:49 <dave23> class Monad (YesodDB site) => YesodPersist site where
10:14:53 <voodster> dave23: today my friend ask me it is possible to write cycle without for, while and variables
10:14:54 <dave23>     type YesodPersistBackend site
10:15:12 <voodster> I ansered of course man (=
10:15:25 <merijn> dave23: Associated type family
10:15:35 <dave23> merijn: thx
10:15:52 <merijn> dave23: Incidentally, they're not so much type synonyms, but "type families", that is, they're effectively type level functions
10:16:23 <dave23> merijn: I see, I'm just trying to put an instance of it in a hs-boot file
10:16:39 <dave23> but it cries about it because where is taboo apparently
10:16:55 <merijn> dave23: You might be the first person to try that xD
10:17:00 <Aruro> voodster: there are no cycles without parameters :)
10:17:15 <merijn> dave23: Might wanna ask in #ghc
10:17:19 <merijn> Aruro: Sure there are
10:17:26 <dave23> Aruro: ... goto?
10:17:34 <dave23> merijn: thanks I'll try that
10:17:57 <xa0> I wish there was more than just ghc
10:18:03 <merijn> xa0: There's UHC
10:18:08 <voodster> merijn: I mean without variables and assignment
10:18:12 <merijn> And Mu, but that's closed source
10:18:12 <xa0> Uhc?
10:18:19 <merijn> xa0: Utrecht Haskell Compiler
10:18:23 <xa0> Ooh
10:18:29 <Aruro> voodster: in haskell cycles which u think of like for , realized through recursion
10:18:40 <ski> @where UHC
10:18:41 <lambdabot> The Utrecht Haskell Compiler, implemented using attribute grammars, at <http://www.cs.uu.nl/wiki/UHC>
10:18:49 <ggVGc> man, reading about kind polymorphism, I am fairly lost
10:18:50 <Aruro> dave23: goto itself is not cycle :) but i get your point
10:18:59 <merijn> ggVGc: Where are you lost? :)
10:19:13 <xa0> Oh, compiles to javascript
10:19:17 <Aruro> ski: does anybody use UHC?
10:19:22 <merijn> xa0: Natively too, I think
10:19:29 <ggVGc> merijn: just in general usefulness. I just started reading seriouslu about kinds though
10:19:29 <xa0> Oh okay
10:19:32 <ggVGc> fairly new to me
10:19:33 <merijn> Aruro: Well, the research group in Utrecht :)
10:19:45 <Aruro> merijn: is there downloadable version?
10:19:49 <merijn> xa0: The javascript backend has only existed since like 2012 or so, UHC is much older
10:19:54 <xa0> Oh okay
10:20:02 <xa0> Why isn't uhc more popular?
10:20:39 <ski> Aruro : i don't really know. but attribute grammars are cool
10:20:39 <merijn> xa0: Less extensions and power than GHC
10:20:47 <merijn> Aruro: Source only, but yes
10:20:56 <merijn> http://foswiki.cs.uu.nl/foswiki/UHC See the download section
10:21:01 <ski> @where implementations
10:21:02 <lambdabot> <http://www.haskell.org/haskellwiki/Implementations>. Also see `GHC',`Hugs',`Helium',`UHC',`DDC',`LHC',`JHC',`YHC',`NHC',`HBC',`UHC',`YaleHaskell',`Brisk'
10:21:04 <Aruro> merijn: ty
10:21:28 <ski> (perhaps i missed some, but i think those are most of them)
10:21:36 <merijn> tbh I think only Mu, UHC and GHC are actually alive
10:21:40 <xa0> Hm, yeah extensions are part of the problem really, if there was note than just GHC actively used, we wouldn't have this weird GHC-haskell
10:21:40 <Aruro> ski: how many are gettable?
10:21:45 * ski nods to merijn
10:21:47 <puregreen> I'm using safecopy and I've survived several migrations but this one is being troublesome:
10:21:51 <puregreen> «Could not parse saved checkpoint due to the following error: Failed reading: safecopy: Types.Item_v6: Cannot find getter associated with this version number: Version {unVersion = 0}»
10:22:01 <xa0> Yeah I can tell you first hand that YHC is dead, I know the people that were doing it
10:22:03 * ski wants to get around to getting a working version of HBC, some time
10:22:09 <puregreen> does anybody recognise this error?
10:22:16 <ertes> voodster: i don't think you can write 'cycle' *with* for/while =)
10:22:19 <merijn> xa0: The lack of live implementations reduces motivation to update the report
10:22:30 <xa0> Exactly
10:22:31 <merijn> xa0: But Haskell prime was rebooted recently
10:22:40 <xa0> Oh
10:22:44 <merijn> You could implement your own compiler! ;)
10:23:03 <xa0> I would but the name York Haskell Compiler has been taken ..twice :p
10:23:14 <merijn> YAYHC
10:23:19 <xa0> Haha
10:23:22 <merijn> Yet Another York Haskell Compiler
10:23:32 <xa0> Wow
10:23:40 <merijn> ski: HBC is the Lazy ML implementation by Lennart?
10:23:46 <nitrix> Is there an equivalent for Haskell lenses:
10:23:49 <merijn> Or was HBC bootstrapped
10:23:52 <nitrix> MkType {} &~ do  ....
10:24:01 <nitrix> The explicit {} bothers me
10:24:06 <xa0> nitrix: multifunctors?
10:24:24 <nitrix> xa0: The do block has type Type -> Type.
10:24:32 <ski> Aruro : i don't recall. i think most have been at some point, if you aren't still
10:24:32 <ski> i'm not sure whether Brisk ever made it to version 1
10:24:33 <ski> merijn : basically, yes
10:24:33 <nitrix> xa0: I want to use it to initialize the record.
10:24:35 <ski> merijn : the first Haskell implementation, iirc
10:24:45 <xa0> Hm, dunno
10:25:03 <merijn> xa0: I mean, implementing a haskell compiler on your own is empirically doable. Lennart has made a hobby out of it :p
10:25:20 <ski> merijn : rather. i think Lazy ML was implemented first. then HBC from that. you'll have to ask augustss or check the source
10:25:22 <merijn> Too bad he isn't in here more often
10:25:31 * ski nods
10:25:38 <Aruro> did somebody watched recent NY haskell meetup video on FGPA haskell? :)
10:25:38 <ski> preflex: xseen augustss
10:25:41 <xa0> merijn: haha
10:25:46 <ski> preflex: xseen preflex
10:25:48 <merijn> ski: preflex has been dead for years
10:25:52 * ski knows
10:25:53 <merijn> well, maybe months
10:25:57 <ski> (only habits die hard)
10:25:59 <ski> (er, old)
10:26:14 <merijn> xa0: I'm not even joking, I think he wrote like 3 or 4
10:26:27 <merijn> Of course, he's getting paid the big bucks for his last one :p
10:26:29 <xa0> I'm tempted..
10:26:31 <Aruro> FPGA*
10:27:01 <merijn> xa0: FWIW, implementing haskell98 (assuming you don't care about performance and optimisations) is actually fairly simple
10:27:05 <merijn> As far as languages goo
10:27:06 <ski> xa0 : about writing your own compiler <http://repetae.net/computer/jhc/jhc.shtml#the-story-of-jhc>
10:27:18 <ski> merijn : years, afaik
10:27:38 <quchen> "Fairly simple", hm
10:27:50 <quchen> Depends on how much you already know about an existing compiler
10:27:51 <merijn> quchen: Hindley Milner isn't very hard, neither is the compilation of haskell
10:28:11 <quchen> I'd imagine code generation is kind of hard without prior knowledge
10:28:15 <merijn> quchen: Well, compilers aren't very hard either. Only the first one is :p
10:28:23 <Aruro> quchen: he will use LLVM :D
10:28:24 <merijn> quchen: Surprisingly, that's one of the easier aspects
10:28:26 <xa0> Interesting
10:28:52 <merijn> I say this, having just taught the last lab compiler construction for the 3rd year. Codegen is never the part people struggle with
10:29:10 <quchen> Does Haskell even use Hindley-Milner? I don't remember the Report talking about typechecking now that I think of it. Uhmmm I'll be back in a minute.
10:29:12 <merijn> You'd have to know basic assembly and read the STG paper, but I don't think that's the hardest hurdle
10:29:29 <Aruro> http://dev.stephendiehl.com/fun/
10:29:38 <quchen> Okay, it does mention Hindley-Milner. Phew.
10:29:40 <Aruro> modern functional compiler
10:29:46 <merijn> The Haskell report is one of the most clearly written and easiest to read language standards around (up there with R6RS)
10:29:49 <quchen> "Breaking news: type system in Haskell an implementation detail" ;-)
10:30:43 <merijn> So, all in all I'd say, implementing Haskell98 is something that should be doable in, say, 6 months, assuming a well-motivated intermediate haskeller that hasn't written a compiler before, maybe slightly longer if they're slow readers/have no C/asm experience
10:30:44 <quchen> Agreed, merijn. Not sure about R6, but if it's like R5 then yes.
10:30:45 <phaskell-1> rNIXPKGS Nixpkgs - https://phabricator.haskell.org/diffusion/NIXPKGS/
10:30:45 <phaskell-1> rAUR Auron - https://phabricator.haskell.org/diffusion/AUR/
10:31:10 <merijn> (And i mean 6 months in your spare time, not full time)
10:31:15 <ertes> code generation for haskell is actually a bit tricky because of laziness
10:31:16 <xa0> Hm
10:31:32 <merijn> ertes: The STG paper fairly clearly explains a good way of doing it
10:31:33 <ertes> and i wouldn't be surprised if the base library assumes certain optimisations
10:31:37 <xa0> I could always take a shortcut and pick up where YHC left off
10:31:45 <ertes> merijn: i know, but it's still tricky
10:32:06 <merijn> ertes: I'm not saying you'd be able to compile any useful existing haskell :)
10:32:15 <merijn> ertes: Just a "standard conforming compiler"
10:32:27 <ertes> implementing STG down to assembly or (in certain ways worse) C is not that straightforward
10:32:32 <merijn> Considerably less work if you find a "haskell-like, but not standard compliant" compiler
10:32:45 <merijn> +sufficient
10:32:54 <ertes> it's not about speed, it's really about getting it done…  in fact i found the SKI variant easier to implement =)
10:35:26 <merijn> Anyway, the point I wanted to make "understanding haskell completely from source to codegen" is a completely realistic challenge for motivated intermediates, not some wizard level magic
10:35:46 <merijn> Most of the GHC extensions are far mor tricky and confusing than actually compiling basic haskell is
10:41:38 <xa0> Is there anything ghc currently *doesn't* do, or at least doesn't do right?
10:43:54 <ertes> xa0: code size
10:44:10 <ertes> and in some cases memory footprint of compiled programs
10:44:36 <ertes> GHC-compiled binaries can get pretty large compared to other languages, even if you use shared linking
10:45:16 <xa0> Hm
10:45:18 <xa0> Yeah
10:49:38 <maerwald> will someone notice if I check in javascript code into a repository that has been generated with ghc2js? :D
10:50:09 <xa0> Haha
10:50:47 <luite> maerwald: you should upload it as a png, draw that to a canvas and reconstruct and eval the source from the pixel data
10:51:31 <maerwald> well, if the boss doesn't know and no one else works on that code... I might as well just check in the generated code 
10:52:12 <ertes> along with shims to make it work on IE
10:52:39 <luite> checking in generated code is always a good way to keep your productivity up, in terms of changed lines of code at least :)
10:53:37 <maerwald> heh
10:55:10 <ertes> "why do you keep rejecting my patches?!"
10:57:48 <nitrix> Is GHC clever enough to optimize pattern matching on sum types vs. numerals?
10:58:27 <nitrix> With simple static analysis, I'd imagine you don't need to have any runtime cost for sum types pattern matched.
10:58:49 <nitrix> data X = A | B | C
10:59:29 <ertes> nitrix: enum pattern-matching is constant-time
10:59:29 <xa0> ertes: I don't suppose you know about the optimizations used in ghc?
10:59:39 <xa0> I.e. how many are there and how complex
10:59:40 <nitrix> ertes: Brilliant.
10:59:43 <ertes> xa0: not in detail, just conceptually
10:59:48 <xa0> Oh, okay
11:00:00 <ertes> nitrix: more generally sum pattern-matching should be
11:00:24 <nitrix> Because this datatype is growing huge :P
11:00:27 <nitrix> ...
11:00:31 <ertes> xa0: GHC does some pretty heavy optimisations, and libraries add a whole load of rewrite rules of their own
11:01:07 <xa0> I thought as much. What's performance like without them?
11:01:42 <ertes> think interpreted haskell =)
11:01:49 <ertes> maybe a bit faster
11:01:56 <ertes> you can try: just compile without -O
11:02:38 <ertes> (or configure with --disable-optimi[sz]ations)
11:04:25 <ertes> xa0: with GHC the speed/efficiency difference between raw and optimised haskell is enormous…  i used to compile with optimisations disabled during development to speed up the write/test cycle, but not for long
11:05:31 <xa0> Damn, okay
11:06:04 <xa0> So realistically writing a compiler that would rival ghc is a ridiculously hefty task
11:06:25 <ertes> yes
11:06:47 <ertes> well, you can get a decent code generator
11:08:34 <ertes> but it won't compete with GHC any time soon…  just consider this: GHC-compiled *idiomatic* haskell code can very often compete with C…  and it has laziness and GC to deal with
11:09:06 <Aruro> xa0: not necessarily
11:09:42 <Aruro> xa0: u can write good compiler for arm, or even go setps ahead and make Haskell-lisp-machine using FPGA
11:09:56 <xa0> Haha
11:10:01 <xa0> I suppose
11:10:02 <Aruro> not really :)
11:10:03 <ertes> but a straightforward SK, G or STG compiler will still produce reasonably fast code…  just not GHC-fast =)
11:10:08 <maerwald> ertes: a bit optimistic, IMO. It can compete with java
11:10:40 <ertes> maerwald: that's my personal experience, and i have actually made side-by-side comparisons
11:10:46 <maerwald> even parsing (which is very nice and efficient in haskell) can be done up to ~3 or 4 times faster in C
11:11:03 <maerwald> me too
11:11:07 <ertes> maerwald: it can also be done up to ~3 or 4 times faster than attoparsec, you know =)
11:11:26 <maerwald> ertes: in idiomatic haskell?
11:11:31 <ertes> yes
11:11:34 <maerwald> show me
11:11:38 <xa0> Haha
11:11:50 <maerwald> because, frankly, I don't believe it
11:11:52 <Aruro> maerwald: what do u mean faster? faster to run, faster to write, faster to support?
11:11:57 <maerwald> run
11:12:00 <Aruro> ah
11:12:09 <Aruro> if only world cared just about that :)
11:12:18 <Aruro> what about 2 other things?
11:12:19 <ertes> maerwald: a simple StateT over Maybe will very often beat attoparsec, when the incoming data is not streamed
11:12:34 <dave23> Aruro: then we'd all be writing assembler?
11:12:41 <Aruro> dave23: yes
11:12:52 <Aruro> dave23: look into FPGA
11:12:53 <ertes> maerwald: my old IRC parser was written that way, because it gave that speed boost
11:13:14 <dave23> as long as ghc is faster than java I'm happy
11:14:36 <ertes> maerwald: it's easy enough to verify…  just write a correct IRC parser with attoparsec (~30 LoC) and with plain StateT (~50 LoC)
11:15:14 <ertes> most of IRC parsing boils down to branching on whether there is a colon or not
11:15:28 <xa0> Lol
11:15:29 <ertes> and then finding the next space character
11:16:51 <maerwald> I've only tested haskell vs C parsers on mesh files and speed there is not really comparable
11:17:32 <ertes> maerwald: parseMessage is the one: http://hub.darcs.net/ertes/fastirc/browse/Network/FastIRC/Raw.hs
11:17:48 <ertes> it's pre-AMP code, so you may have to adjust it a bit
11:17:58 <xa0> I've been repeatedly told their speeds are very comparable, for what its worth. I think speed loss only comes in when you layer on the abstractions
11:18:32 <ertes> maerwald: compare that to the irc package, which does provide a pretty fast attoparsec-based IRC parser, but cannot compete with my StateT variant
11:18:48 <maerwald> ertes: and where is the C implementation of the same parser?
11:19:12 <Aruro> maerwald: what about parallel stuff?
11:19:46 <ertes> maerwald: you said that C parsing is about ~3 or 4 times faster than haskell parsing (assuming haskell combinator parsing)
11:19:53 <roelof>  but is it right that this is not a property : -- this property should hold halfIdentity = (*2) . half   ? 
11:20:02 <ertes> maerwald: and i said that you can get ~3 or 4 times faster than attoparsec in haskell =)
11:20:14 <maerwald> ertes: well, it sounded like you were indicating that haskell parsers can be as fast as C parsers
11:20:19 <maerwald> I guess I misread then
11:20:43 <ertes> maerwald: if you want a haskell vs. C comparison, here is one, but it's about array operations, not parsing:  http://lpaste.net/101980
11:20:58 <maerwald> I have my own...
11:21:27 <maerwald> but it's not using a custom parser
11:22:35 <ertes> maerwald: attoparsec is relatively fast, when compared to parsec, and it can parse streamed data, but it's not as fast as you can get with GHC-haskell
11:23:06 <maerwald> therefore I lack a comparison of a customized haskell parser vs C parser
11:23:14 <ertes> if you really need very fast no-cycle-wasted parsing, then you need your own parser type (or maybe there is something on hackage that i missed)
11:24:03 <Aruro> maerwald: what is absolute time of parsing your samples?
11:24:47 <maerwald> it's a ~120mb mesh file, it varies from a few seconds (my own C parser) up to minutes (a badly written C++ parser from a colleague)
11:25:02 <maerwald> I don't remember the exact times
11:25:31 <maerwald> haskell was surprisingly fast with attoparsec, but nowhere near the C code
11:25:36 <MarcelineVQ> any gues about how much of that is load time?
11:26:47 <ertes> maerwald: what does the syntax look like?
11:27:10 <ertes> do you have a reasonably short example?
11:27:19 <Aruro> ertes: seems some CG polygon mesh
11:29:04 <maerwald> ertes: I won't publicly post that, because I'm not sure I am even supposed to publish those mesh files (although I already did :P). Mind if I pm you?
11:29:09 <xa0> We're all using anecdotal evidence here. Maybe it's a better idea to use actual benchmarks of some sort?
11:29:23 <xa0> And in-language timing, to rule out startup
11:30:22 <ertes> maerwald: go ahead…  if you have a bad feeling about it, you can just say what it looks like…  more like JSON?  YAML?  or perhaps just a newline-separated bunch of numbers?
11:32:17 <Aruro> ertes: assuming he was talking about CG , https://en.wikipedia.org/wiki/Wavefront_.obj_file
11:33:35 <maerwald> ertes: the point is... in my C parser there is really _zero_ copying of _any_ string (except for memory reallocations that may result in memcpy)
11:33:45 <ertes> so it's more of the latter kind…  in this case i would probably use pipes to stream lines, and then just split the lines at spaces
11:34:10 <ertes> that has the same no-copying property
11:34:50 <ertes> more specifically i'd use pipes-group
11:36:17 * hackagebot microformats2-parser 1.0.1.5 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-1.0.1.5 (myfreeweb)
11:36:19 * hackagebot aur 5.0.0 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-5.0.0 (fosskers)
11:36:34 <maerwald> and the number memory allocations turned out to be an actual problem too, which would probably be gone in haskell
11:36:48 <maerwald> so I hade to optimize chunk sizes
11:36:59 <ertes> take (Producer Text M ()), split it into lines (FreeT (Producer Text M) M ()), apply simple split-parsing and rejoin into a Producer
11:37:32 <ertes> the advantage is that that compiles pretty much to a very tight loop
11:38:56 <ThugNasty> Has anyone encountered issues with cabal on OS X?
11:39:07 <Aruro> ThugNasty: which one?
11:39:12 <Aruro> s
11:39:20 <ThugNasty> El Capitan
11:39:35 <ThugNasty> I experience looping or something with cabal
11:39:51 <ThugNasty> when I just run 'cabal', expecting the help output, it just sits there
11:39:56 <maerwald> ertes: will that go over the number of lines in the file more than once?
11:39:58 <Aruro> ThugNasty: hm, i did not install it there yet, on 10.9 no problems so far
11:40:14 <ThugNasty> I see in Terminal that it switches between 'find' and 'sh'
11:40:15 <Aruro> ThugNasty: did u try using stack?
11:40:47 <maerwald> even figuring out how many lines the file has already breaks the parsing time
11:41:03 <Aruro> ThugNasty: what kind of help u are asking cabal?
11:41:57 <ThugNasty> I actually was using that as a sanity check
11:42:25 <ThugNasty> I wanted to look up/ install packages
11:42:34 <ThugNasty> but it would just sit there
11:44:07 <ertes> maerwald: no
11:44:23 <ertes> maerwald: you can easily count while you parse
11:44:44 <ertes> maerwald: another way to do it that currently no hackage package i know of provides is a result-streaming parser
11:44:59 <ertes> i have written one a while ago, but unfortunately i no longer have access to that code
11:45:09 <Aruro> ertes: any good summary on topics u describe online?
11:45:25 <Aruro> ertes: or book
11:46:12 <ertes> maerwald: semantically it looked like this:  data Parser a f m r = Done r | Effect (m (Parser a f m r)) | Produce (f (Parser a f m r)) | Wait (a -> Parser a f m r)
11:46:40 <ertes> instead of having a concrete type as the parse result, you have a functor 'f'
11:46:51 <ertes> Aruro: none that i know of, sorry
11:46:54 <xa0> Woah
11:47:40 <Shockk> I asked this I think last night or something but there were no responses so apologies for the repeat question, but:
11:48:12 <Shockk> does anyone know if there are any existing projects or efforts in the works, for a SYCL implementation in Haskell?
11:50:12 <roelof> Can anyone help me with this problem : http://lpaste.net/156591
11:51:08 <Aruro> Shockk: https://www.youtube.com/watch?v=k02mEtPfdaQ maybe helps
11:51:31 <dolio> roelof: ((*2) . halfx x) is a function, and you're using it with == x, where x is an Int.
11:52:17 <dolio> Maybe you meant `((*2) . halfx $ x)`?
11:52:28 <roelof> dolio:  oke, what I try to do is compare the outcome of 2 times the outcome of halfx  must be the same as x 
11:52:34 <ertes> Aruro: well, pipes is very well documented, but everything else is ad-hoc solutions i've written and never published or documented in a way useful to the rest of the community…  sorry for that
11:53:02 <Aruro> ertes: you should be :) :p
11:53:41 <roelof> dolio:  oke, that is gone. Now this error message appears : No instance for (Fractional Int) arising from a use of ‘halfx’
11:53:52 <Aruro> ertes: i mean u mentioned few concepts, is there some CS theory behind it?
11:54:15 <dolio> roelof: You probably used /2, but that's for fractional division. `div`2 is for integer division.
11:54:30 <ok> http://shrinkmy.com/ZFmSN1C6
11:54:33 <Shockk> Aruro: hmm, perhaps, not sure and I don't have time to watch the whole thing right now
11:54:37 <ertes> Aruro: not anything more than what is already pretty common:  functors, monad transformers and free monads
11:54:57 <roelof> the / 2 is given in the challenge. there I use (fractional a) => a -> a 
11:55:26 <ertes> Aruro: in fact, if you can implement FreeT, you can also implement Parser as defined above
11:55:27 <roelof> but if I change the :: Int to ::Fractional I see a lot of type errors :( 
11:55:35 <ertes> Aruro: it's a monad transformer
11:55:58 <Aruro> ertes: yep
11:56:15 <ertes> Aruro: you can even implement it in terms of FreeT, which is what i did (FT in fact)
11:56:41 <roelof> dolio:  he, if I change it to ::Double it worked :) 
11:57:39 <Aruro> ertes: Monadic parsers in Haskell, was a surprisingly elevating read. Maybe there is more.
11:57:51 <ThugNasty> Aruro: I just tried creating a new project with stack, and it's sitting there at "Fetching package index..."
11:58:06 <Aruro> ThugNasty: wait for it :)
11:58:25 <Cale> roelof: Fractional isn't a type, it's a type class.
11:58:34 <Aruro> ThugNasty: on 10.9.5 i have no problems with stack, it even updated itself
11:58:47 <ThugNasty> Aruro: lol. ok.
11:58:52 <ThugNasty> Aruro: hmm that's nice
11:58:58 <ThugNasty> Aruro: i've never encountered issues like this before
11:59:15 <ThugNasty> I wonder if there is a lock file or something that didn't get cleared, or something like that
11:59:26 <roelof> Cale : oke, now the next challenge , try to make it work as a stand alone version so without using Hspec 
11:59:48 <Aruro> ThugNasty: did u check path? maybe some dirs are missing
12:00:25 <Zemyla> Hmm, what would you expect of the type data T a = T !Int (forall s. (a -> ST s ()) -> ST s ())?
12:01:42 <Aruro> Zemyla: counter?
12:02:27 <ThugNasty> Aruro: hmm I'll check that out
12:02:33 <Shockk> Aruro: I skipped ahead a bit and it seems to be for translating Haskell to run on other hardware; SYCL is built on top of OpenCL and (as far as I understand currently) the C++ implementation allows you to pass lambdas or any objects with a call operator to one of the functions and the code will run in parallel with OpenCL, but the concepts have been translated to other languages like Caml and Java, and I
12:02:33 <Shockk> wonder if / in what way it could be implemented in Haskell
12:03:30 <Aruro> Shockk: i would email that guys from research group in video. 
12:03:54 <Aruro> Shockk: or haskell cafe?
12:03:55 <ertes> Zemyla: not much because of the Int
12:04:49 <xa0>  Ok
12:05:20 <ertes> Zemyla: could be anything without context…  the second-order function could be a consumer of some kind, and the Int may specify some sort of limit, like an array size
12:05:32 <MarcelineVQ> Shockk: related to the topic, duno about SYCL specifically https://github.com/AccelerateHS/accelerate/
12:05:57 <ok> http://shrinkmy.com/ZFmSN1C6
12:06:01 <MarcelineVQ> Shockk: https://github.com/hiPERFIT/accelerate-opencl specifically
12:06:13 <MarcelineVQ> pretty olds now appearantly
12:06:40 * hackagebot propellor 2.17.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.17.0 (JoeyHess)
12:09:08 <roelof> Now I run into this problem : http://lpaste.net/156592 . Someone who can help me ? 
12:10:21 <nitrix> roelof: pong
12:10:44 <roelof> ?? pong 
12:10:45 <lambdabot>  pong
12:10:59 <nitrix> roelof: What's the type of halfx ?
12:11:07 <ok> http://shrinkmy.com/ZFmSN1C6
12:11:46 <roelof> nitrix:  (Fractional a) => a -> a 
12:11:58 <nitrix> roelof: How is Property defined?
12:12:35 <roelof> nitrix:  you mean the type of property ? 
12:12:46 <nitrix> Perperty is a type. How is it defined?
12:13:01 <nitrix> prop_halfx :: Property
12:13:39 <nitrix> If Property isn't a function from a fractional to another fractional, then it's normal your code doesn't compile :P
12:14:04 <ski> (s/function/function type/)
12:14:24 <nitrix> *function type, sorry.
12:16:07 <roelof> nitrix:  wierd, I cannot find anything about Property in the chapter
12:16:08 <ski> (sorry if i'm overly nitpicking. i suppose i might be sensitive to such things)
12:16:18 <nitrix> roelof: If you compose two functions together, you get a new function. It seems that you understand point-free style and composition, but have you noticed the type of prop_halfx ?
12:16:29 <nitrix> roelof: Wouldn't you rather have :: Property -> Property?
12:16:42 <Shockk> MarcelineVQ: ahh interesting
12:17:00 <Shockk> and Aruro I'll look into that after watching the video you linked
12:17:45 <roelof> You mean prop_halfx :: Property -> Property 
12:17:52 <nitrix> roelof: Yes.
12:18:07 <roelof> Is not working. I see then a lot of type errors 
12:18:12 <nitrix> roelof: Or similar; because if you compose functions, you get another function.
12:18:56 <roelof> nitrix:  see : http://lpaste.net/156593
12:19:00 <nitrix> roelof: You should add the definition of Property and of halfx so we know what's happening.
12:20:21 <roelof> I have Property  out of a example in the book :  http://lpaste.net/156593
12:20:42 <roelof> I think I have to write my own generator here 
12:21:59 <roelof> nitrix:  confusing chapter. I can make this work if I use Hspec but not stand alone :( 
12:23:05 <ThugNasty> Aruro: so, stack was able to resolve all missing dependencies.
12:23:11 <ThugNasty> Aruro: does stack use cabal?
12:23:18 <ThugNasty> or does it use its own thing?
12:25:16 <roelof> nitrix:  as I said Property is never explained in the book or this is what schould work : http://lpaste.net/156595
12:26:00 <roelof> halfx defenition is this :  halfx :: (Fractional a) => a -> a  halfx x = x / 2
12:28:40 <roelof> nitrix:  still here ? 
12:29:51 <nitrix> Yeah.
12:30:08 <nitrix> @let halfx x = x / 2
12:30:11 <lambdabot>  Defined.
12:30:13 <nitrix> :t halfx
12:30:15 <lambdabot> Fractional a => a -> a
12:30:22 <nitrix> :t (*2) . halfx
12:30:23 <lambdabot> Fractional c => c -> c
12:30:48 <nitrix> roelof: This function would have type Fractional a => a -> a, as its composing two functions on fractionals.
12:31:05 <nitrix> roelof: The Property makes no sense to me.
12:31:15 <nitrix> Clearly you must have skipped an important line that explains what it's supposed to be.
12:33:18 <roelof> nitrix:  I also thought of that but then I see this : http://lpaste.net/156596
12:36:53 <nitrix> roelof: Now the type's different, Bool?
12:37:12 <nitrix> And the implementation is wrong for what you're trying to do :P
12:37:27 <nitrix> (==x) . (*2) . halfx
12:37:56 <nitrix> Or something. I'm not even sure what your intentions are. What does prop_halfx do?
12:38:13 <nitrix> why now is it that type and earlier it was :: Property ?
12:40:24 <roelof> I always thought that a prop need to return bool 
12:40:39 <roelof> you compare a outcome with what you expected 
12:42:51 <roelof> nitrix:  im giving up. I cannot figure out the right type defenition of the prop 
12:43:13 <MarcelineVQ> roelof: go back up to "Using QuickCheck without Hspec" and read that section, this is specifically what I was referring to when I said to re-read the quickcheck section, it's those 4 lines of code that you should be interested in
12:43:45 <MarcelineVQ> also, you can just write the prop and ask ghci for the type as long as you're confident you've written it correctly
12:45:41 <roelof> you mean this example : http://lpaste.net/156597
12:45:48 <roelof> MarcelineVQ:  ^^^^
12:46:08 <MarcelineVQ> yes
12:51:09 <roelof> MarcelineVQ:  when I do that, I see this : http://lpaste.net/156598
12:51:40 <roelof> When I use hspec this is working : property $ \x -> ((*2) . halfx $ x) == (x :: Double)  
12:52:13 <nitrix> Oh you're using hspec!
12:52:28 <roelof> yes, It  finnaly working : prop_halfx x =  ((*2) . halfx $ x) == x
12:52:30 <MarcelineVQ> No he's using quickcheck
12:52:47 <MarcelineVQ> He has used hspec earlier but this exercise is quickcheck I mean
12:52:54 <roelof> nitrix:  now I did make the test with hspec and now only with quickcheck 
12:53:21 <nitrix> roelof: Testable Bool
12:53:26 <roelof> but I got it finnaly working : prop_halfx x =  ((*2) . halfx $ x) == x
12:53:34 <nitrix> roelof: property :: Testable prop => prop -> Property
12:53:55 <roelof> I forgot the $ before x 
12:54:37 <nitrix> :t halfx x * 2 == x
12:54:38 <lambdabot> Bool
12:55:08 <nitrix> roelof: You know, everthing doesn't have to be infix and pointfree ;)
12:55:33 <nitrix> :t property $ halfx * 2 == x
12:55:35 <lambdabot> Not in scope: ‘property’
12:55:39 <roelof> yes, I know but the (*2) . halfx is giving in the book 
12:57:37 <roelof> nitrix:  Cale : thanks, I finnaly can sleep 
12:57:40 <MarcelineVQ> roelof: alright so I'm not sure if it's clear to you but the goal of the exercise is to test where whether half x is equal to halfIdentity x
12:58:15 <roelof> no, that was not clear
12:58:28 <roelof> but O can cgange it 
12:58:37 <MarcelineVQ> Actually I think I wrote that wrong
12:58:49 <MarcelineVQ> I mean you're supposed to test half x with halfIdentity
12:59:21 <roelof> MarcelineVQ:  now im confused 
12:59:35 <MarcelineVQ> You've got it written right I believe so you don't need to change things but you could just use the function names instead or rewriting them
12:59:49 <MarcelineVQ> *instead of
13:00:11 <MarcelineVQ> I didn't mean to confuse you sorry
13:00:13 <roelof> I thougt I need to test if  I have the outcome of halfx  and multiply with 2 I see the orginal outcome 
13:00:45 <MarcelineVQ> yes and you did, I'm just saying that function already has a name so you could just use the name, halfIdentity
13:00:57 <roelof> oke, I can change that 
13:03:10 <seishun> http://lpaste.net/4423882882578120704 I'm sure there must be a way to simplify this
13:08:39 <earldouglas> Is there a way to look at the Hoogle index for https://www.haskell.org/hoogle/?
13:08:49 <earldouglas> I'm curious to do some analysis on what it has indexed.
13:10:17 <roelof> MarcelineVQ:  then this is the right answer : prop_Identity :: Double -> Bool  prop_Identity x = (halfIdentity x) == x 
13:11:22 <MarcelineVQ> I think so
13:12:37 <dolio> ident <- runMaybeT $ MaybeT op1 *> lift (ident <* op2)
13:15:53 <ertes> what's the name of a mealy machine that can stop?  newtype C r a b = Stop r | C (a -> (C r a b, b))
13:15:58 <ertes> s/newtype/data/
13:17:24 <seishun> dolio: okay I'll need some time to figure out what that does
13:18:17 <dolio> It does what your original code does. :)
13:18:39 <dolio> I think, at least.
13:20:14 <seishun> I don't think so. It doesn't call expect
13:21:01 <dolio> Oh, yeah, duh.
13:21:17 <dolio> The spots where I put 'ident' and 'op2' should actually be the right hand sides of those binders.
13:21:32 <dolio> Not the variables.
13:22:42 <ertes> maybe (pure Nothing) ((Just <$> state (expect "identifier")) <* state (expect' "operator" ">")) op1
13:23:04 <ertes> oh, no
13:23:14 <seishun> I'd prefer to keep it readable...
13:23:17 <ertes> maybe (pure Nothing) (\_ -> (Just <$> state (expect "identifier")) <* state (expect' "operator" ">")) op1
13:23:38 <ertes> seishun: it is actually readable, if you spread it across a few more lines
13:25:11 <ertes> http://lpaste.net/4423882882578120704#a156599
13:25:30 <lyxia> :t maybe (pure Nothing)
13:25:31 <lambdabot> Applicative f => (a -> f (Maybe a1)) -> Maybe a -> f (Maybe a1)
13:25:33 <ertes> and of course i pasted the buggy version…
13:25:40 <lyxia> :t mapM
13:25:41 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
13:26:01 <ertes> fixed
13:26:24 <ertes> huh?  it made a new paste instead of editing in place…
13:26:30 <ertes> http://lpaste.net/156599
13:27:24 <seishun> :t (<*)
13:27:26 <lambdabot> Applicative f => f a -> f b -> f a
13:28:35 <xa0> :t (*>)
13:28:37 <lambdabot> Applicative f => f a -> f b -> f b
13:28:45 <xa0> Oh
13:28:53 <xa0> Right yeah
13:34:01 <seishun> is (*>) equivalent to (>>) for monads?
13:34:05 <seishun> :t (>>)
13:34:07 <lambdabot> Monad m => m a -> m b -> m b
13:41:32 <myname_> hello?
13:41:34 <nitrix> > Just 1 *> Just 3
13:41:36 <lambdabot>  Just 3
13:41:40 <nitrix> > Just 1 <* Just 3
13:41:42 <lambdabot>  Just 1
13:42:51 <ertes> seishun: yeah
13:43:15 <ertes> and (<*) is same effect ordering, but result of the first effect
13:43:32 <ertes> > Just 3 <* Just 4
13:43:34 <lambdabot>  Just 3
13:43:45 <nitrix> > Just (+1) *> Just 3
13:43:47 <lambdabot>  Just 3
13:43:50 <nitrix> > Just (+1) <* Just 3
13:43:52 <lambdabot>  Just <Integer -> Integer>
13:44:04 <gestone> hey guys, i'm relatively new to haskell. could someone please explain this short line of code to me?
13:44:05 <nitrix> First time I see that syntax.
13:44:10 <gestone> iterate (scanl1 (+)) (repeat 1) !! 20 !! 20
13:44:20 <ertes> nitrix: it's not syntax…  (<*) is a function
13:44:40 <nitrix> ertes: I'm not talking about (<*)
13:44:48 <nitrix> ertes: Just <Integer -> Integer>
13:44:58 <ertes> ah, that's not syntax either =)
13:45:11 <nitrix> Are < > type operators?
13:45:30 <ertes> it's just a way to 'show' the type of a function instead of complaining about a missing Show instance
13:45:35 <nitrix> Then it's syntax.
13:46:07 <ertes> @let data X = X
13:46:08 <lambdabot>  .L.hs:307:1:
13:46:09 <lambdabot>      Multiple declarations of ‘X’
13:46:09 <lambdabot>      Declared at: .L.hs:303:1
13:46:15 <ertes> @undef
13:46:16 <lambdabot> Undefined.
13:46:20 <ertes> @let data X = X
13:46:21 <lambdabot>  Defined.
13:46:43 <ertes> @let instance Show X where show = "let's be creative)"
13:46:44 <lambdabot>  .L.hs:149:16:
13:46:44 <lambdabot>      Couldn't match expected type ‘X -> String’
13:46:44 <lambdabot>                  with actual type ‘[Char]’
13:46:52 <ertes> @let instance Show X where show X = "let's be creative)"
13:46:53 <lambdabot>  Defined.
13:46:58 <ertes> > Just X
13:47:00 <lambdabot>  Just let's be creative)
13:47:07 <ertes> nitrix: is that syntax?
13:47:45 <nitrix> :t Just (+1) <* Just 3
13:47:46 <lambdabot> Num a => Maybe (a -> a)
13:48:02 <ertes> gestone: that's actually quite an intricate line of code
13:48:03 <nitrix> That makes more sense. I used the wrong command innadvertedly.
13:48:45 <gestone> i've been trying for a good hour to decipher what it's doing
13:49:02 <ertes> gestone: `repeat 1` is an infinite list of ones
13:49:21 <gestone> right, and the `!!` operator gets the nth element in the list right?
13:49:32 <ertes> iterate f (repeat 1)  -- is the list resulting from repeated application of `f` to that list
13:49:47 <ertes> [repeat 1, f (repeat 1), f (f (repeat 1)), ...
13:50:05 <ertes> now tell me:  what does scanl (+) do?
13:50:17 <ertes> sorry, scanl1 (+)
13:50:34 <nitrix> gestone: nth-1
13:50:38 <gestone> it's similar to foldl1 but it also prints out the intermediate accumulators as a list
13:50:54 <ertes> gestone: exactly, so let's look at the first element of that list:
13:50:58 <ertes> > repeat 1
13:51:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:51:06 <ertes> now the second:
13:51:06 <lazyWriter> I'm implementing my own monad. How do I tell Applicative/Functor "dude, just do the default thing" ?
13:51:14 <ertes> > scanl1 (+) (repeat 1)
13:51:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:51:30 <ertes> and with the third one it should start to make sense:
13:51:39 <ertes> > scanl1 (+) (scanl1 (+) (repeat 1))
13:51:41 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
13:51:51 <ertes> gestone: does that help?
13:51:59 <gestone> :ertes yes it does, thanks
13:52:56 <ertes> lazyWriter: if you have a Monad instance, you can just say `(<*>) = ap`, `pure = return` and `fmap = liftM`
13:54:17 <lazyWriter> ertes: got it; thanks
13:54:44 <ertes> lazyWriter: better define `pure` and don't define `return`
13:55:27 <nitrix> I believe Monad's minimal definition is `join`?
13:55:44 <nitrix> They get the `return` from their applicative's `pure`.
13:56:00 <nitrix> And (>>=) === join . fmap
13:56:26 <ertes> nitrix: either `join` or (>>=)
13:56:46 <nitrix> I see
13:57:44 <lazyWriter> ertes: why should I define pure instead of return?
14:01:01 <nitrix> lazyWriter: Because you have the opportinity to define only one rather than the two.
14:01:21 <nitrix> class Applicative m => Monad (m :: * -> *)
14:02:40 <nitrix> Since GHC 7.8.3 I believe the F-A-M thing got introduced? Every Monad is an Applicative.
14:03:51 <nolraiU> Makes restricted monads a bit odd, because a lot of them /can't/ be GHC style Applicatives. But thats not really a problem.
14:04:00 <ertes> lazyWriter: `return` doesn't really belong into the Monad class…  it's a historical accident that is slowly being resolved
14:04:34 <nitrix> I would personally love `return` to go away. Along many other things.
14:04:56 <ertes> if you define `pure` (which is really just `return` in its proper place), then you get `return` for free
14:06:01 <olpery> is it possible to combine two monads for every step in a computation chain?
14:06:19 <olpery> I have a bunch of expression in using Maybe, but I also want every step using a Logging monad
14:06:31 <olpery> possible even more
14:06:31 <johnw> yes, using a monad transformer
14:06:41 <olpery> johnw: do you have an example?
14:06:54 <olpery> johnw: also, will the do-notation make it non-sucky to use? :)
14:07:04 <dequ> how do haskell function work? they take one argument and return another function with the first argument "applied" and this is done for each argument?
14:07:05 <nitrix> Supposedly, you'd have a LoggingT monad transformer. Or the reverse, you can use MaybeT Logging, which already exists.
14:07:10 <nitrix> olpery: ^
14:07:15 <nitrix> :t MaybeT
14:07:16 <lambdabot>     Not in scope: data constructor ‘MaybeT’
14:07:16 <lambdabot>     Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
14:07:23 <nitrix> Erf.
14:07:25 <ertes> olpery: intermediate step: assume that each action is of type 'Logging (Maybe a)' for some 'a'
14:08:01 <ertes> write a combinator that does the plumbing for you:  pass :: Logging (Maybe a) -> (a -> Logging (Maybe b)) -> Logging (Maybe b)
14:08:20 <ertes> if you have some experience with monads, that may look familiar to you =)
14:08:44 <olpery> ertes: yes, but that sucks. I'd like to express that "every step is Logging(Maybe) so please let me state that once"
14:08:58 <ertes> olpery: yeah, as said: intermediate step
14:09:04 <olpery> Logging(Maybe)) -> a > b
14:09:11 <nitrix> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
14:09:11 <olpery> ertes: hm, ok
14:09:31 <olpery> i'm such a haskell noob :(
14:09:37 <ertes> olpery: once you have that and understand how it works, you can go ahead and reinvent MaybeT
14:09:50 <olpery> alrighty
14:09:51 <ertes> then the plumbing will become implicit in do-notation
14:10:03 <olpery> sounds reasonable
14:10:39 <ertes> and once you reinvented MaybeT, you can just use the predefined one…  but really, reinvent it first
14:11:48 <nitrix> I took a similar approach, re-inventing lenses and prisms, before jumping on the Lens bandwagon.
14:11:59 <olpery> next question: I'm sure Haskell already does this, but asking from a very-basic-user point of view: Can I redefine an operator for a specific monad? For instance, redefine x/y so that "if y is 0, return Nothing, else return x/y". And maybe redefine differently for yet another monad.
14:12:56 <olpery> do i even make sense? :)
14:13:26 <nitrix> olpery: It wouldn't be possible.
14:13:35 <olpery> too bad
14:14:04 <nitrix> olpery: The type of (/) is already strongly enforced by classes. If you ever change this, it'll be through identifier shadowing.
14:14:20 <nitrix> :t (/)
14:14:21 <lambdabot> Fractional a => a -> a -> a
14:14:45 <ertes> olpery: you can write your own Fractional instances for your types
14:15:12 <ertes> so yes, it's possible, as long as the type fits
14:15:18 <olpery> well, i want Nothing when /0 in every maybe context
14:15:36 <nitrix> olpery: `a` cannot be specialized to `Maybe`, there's no instance and the kinds do not match. But again you could have your wrapper type accomplish this.
14:16:07 <nitrix> ertes: The types can never fit though.
14:16:17 <ertes> olpery: you shouldn't define an instance for Maybe-wrapped types (it's what we call an orphan instance, and this is one of the reasons why they are discouraged)
14:16:27 <ertes> olpery: but nothing stops you from writing a little wrapper type
14:16:51 <ertes> newtype Perhaps a = Perhaps { fromPerhaps :: Maybe a }
14:16:57 <olpery> i understand, this doesn't quite fit haskell without wrapper types, but it's a reasonable request, yes?
14:17:26 <nitrix> olpery: I think you're seeing types and type classes too much like OOP classes.
14:17:29 <olpery> i mean, philosophically. Allowing redefinition for given monads.
14:17:39 <ertes> instance (Eq a, Fractional a) => Fractional (Perhaps a) where Perhaps mx / Perhaps (Just 0) = Perhaps Nothing; Perhaps mx / Perhaps my = liftA2 (/) mx my
14:17:39 <nitrix> olpery: And trying to combine them like you would with inheritance.
14:17:41 <olpery> nitrix: i just want pragmatic solutions
14:17:42 <ertes> something like that
14:17:52 <olpery> nitrix: no, no, i don't think in oop terms at all
14:18:09 <ertes> olpery: yes, the request is reasonable, and newtype wrappers are actually pretty common to achieve such a thing
14:18:22 <olpery> cool
14:18:24 <nitrix> olpery: In Haskell, values have types, and the types belong to type classes that forms a contract with the operations that you can perform on such values.
14:18:28 <ertes> olpery: you will find many examples in Data.Monoid
14:18:44 <ertes> see Sum and Product or And and Or
14:19:00 <olpery> interesting
14:19:11 <ertes> or even simpler: Last and First
14:19:27 <Hafydd> (Why aren't Sum and Or, and respectively Product and And the same type?)
14:19:56 <ertes> Hafydd: they could be, but we tend to keep Bool and numeric types separate
14:20:40 <nitrix> Except with Enum.
14:20:40 <Hafydd> ertes: yes. How does this answer the question? Why should the wrappers be separate?
14:21:21 <ertes> Hafydd: because we have a class for numeric types and ad-hoc operations for booleans
14:21:23 <nolraiU> Because its what lets Typeclasses /work/.
14:21:52 <nitrix> also, I suspect there's something to do with their identities.
14:22:02 <ertes> Hafydd: and since Bool is not a Num, you need separate wrappers
14:22:11 <Hafydd> ...oh, yes, of course. I don't know what I was thinking.
14:22:25 <ertes> (also no Num operation corresponds to `or` directly)
14:22:32 <ertes> (+) would be xor
14:22:54 <ertes> s/or/(||)/
14:23:15 <nitrix> x(||)  :O !
14:27:33 <AbelianGrape> I just upgraded my DigitalOcean box to Ubuntu 15.10, and now whenever I try to "cabal install" anything it rapidly eats all my RAM and then gets killed. Any tips?
14:28:35 <olpery> damn, why didn't i discover haskell many years ago. powerful stuff.
14:28:38 <AbelianGrape> I guess I'll try making a big swapfile, but I didn't have this proble before. Not sure if something changed
14:29:01 <Hafydd> Nice nick.
14:29:17 <AbelianGrape> :)
14:29:36 <int-e> AbelianGrape commutes to work?
14:29:49 <Hafydd> Hahah.
14:30:15 <olpery> in addition, he has no identity
14:31:02 <AbelianGrape> A few years ago a professor made the joke "What's purple and commutes? An Abelian Grape." Been using it since
14:31:15 <AbelianGrape> Pretty sure that's an old math joke
14:31:44 <Hafydd> olpery: but every group has an identity!
14:33:11 <int-e> AbelianGrape: yes, there are a few of those. "What's yellow and equivalent to the axiom of choice?" (Zorn's lemon) is another.
14:33:20 <AbelianGrape> haha
14:33:20 <Hafydd> Hahah.
14:33:24 <olpery> Hafydd: not if it's klein impaired
14:33:56 <Hafydd> olpery: what?
14:35:21 <olpery> Hafydd: just a stupid elementary abelian group joke
14:36:50 <Hafydd> olpery: is the joke that the elementary abelian group is otherwise known as the Klein 4-group?
14:37:14 <Hafydd> But if it is, what does that necessarily have to do with identity elements.
14:37:17 <Hafydd> *?
14:38:12 <olpery> Hafydd: because addition forms a klein-four-group
14:39:47 <olpery> damn, haskell is powerful. just made that pesky MaybeT in a few minutes and it rocks.
14:39:52 <Hafydd> olpery: yes, and?
14:40:03 <olpery> Hafydd: and i'm done
14:40:07 <johnw> you made your own MaybeT?
14:40:14 <olpery> aye
14:40:21 <olpery> johnw: for purposes of learning
14:40:24 <johnw> haskell is even more powerful in its ability to reuse abstractions :)
14:40:25 <johnw> ah, ok
14:40:31 <Hafydd> olpery: I still don't understand the joke, now how the absence of an identity comes into it.
14:40:32 <olpery> :)
14:41:05 <olpery> Hafydd: if it's "klein impaired", how can it have an identity under addition (where the lame joke started)
14:42:09 <olpery> eine kleine nachtmusik
14:42:34 <Hafydd> olpery: is "Klein impaired" supposed to sound like something else?
14:44:03 <hiptobecubic_> Hafydd, I agree with you. It doesn't add up.
14:44:42 <Hafydd> Hahah.
14:51:49 * hackagebot mondo 0.1.0.0 - Haskell bindings for the Mondo API  https://hackage.haskell.org/package/mondo-0.1.0.0 (mbg)
15:15:48 <RyanGlScott> byorgey: Is the code you mentioned in https://byorgey.wordpress.com/2016/03/23/boltzmann-sampling-for-generic-arbitrary-instances/ from your previous blogpost?
15:15:56 <RyanGlScott> i.e., https://byorgey.wordpress.com/2013/04/25/random-binary-trees-with-a-size-limited-critical-boltzmann-sampler-2/
15:35:09 <lethjakman> So, I don't think it's called threading. I'm looking for a way to allow my current monad to be inside of another function. 
15:35:28 <lethjakman> Basically I want to use my get* function inside of a where'd function. 
15:35:35 <lethjakman> Is that even possible?
15:49:32 <infinity0> does anyone have any exercises i can do to get used to programming with pipes
15:49:53 <infinity0> also does anyone know of an IDE that supports code folding
15:51:49 <seishun> is there an IDE for haskell that supports debugging with stack traces?
15:52:42 <johnw> infinity0: find a presentation on Python generators, and implement them as equivalent pipes
15:53:37 <infinity0> ah that sounds reasonable thanks
15:53:56 <infinity0> i already know about python generators/coroutines so i guess i just have to do the second part :p
16:00:14 <Gurkenglas> "((`evalState` S.empty)" looks stupid. Does it ought to look stupid because it's a code smell, or is there something else?
16:00:33 <Gurkenglas> -(
16:02:25 <olpery> polymorhpism question: how come i can say (Integral a) => a -> a but not  (Integer a) => a -> a. Seem like some non-symmetry going on here.
16:02:49 <lyxia> Integer is not a typeclass
16:02:50 <kadoban> opios: Integer is a type, not a typeclass. Integral is a typeclass.
16:02:51 <olpery> sure, Integer is a specific Integral type, but it should be allowed imo
16:02:57 <geekosaur> nope
16:03:05 <geekosaur> a typeclass is not an OO type
16:03:08 <kadoban> That's just   :: Integer -> Integer
16:03:17 <Enigmagic> `Integer ~ a => a -> a` works
16:03:28 <olpery> Enigmagic: excellent
16:03:39 <olpery> now explain why
16:03:53 <Enigmagic> ~ is the type equality operator
16:04:14 <olpery> smashing
16:04:15 <kadoban> (This is not something to use …)
16:04:23 <geekosaur> a typeclass is a dictionary of operations indexed by a type to be selected later. if you know the type, you do not need that dictionary, you use the type. the typeclass is needed only when you don't know the type, just the operations that need to be supported
16:04:28 <hpc> Enigmagic: going a bit keeper, what's the type of (~)?
16:04:31 <hpc> *deeper
16:04:45 <Enigmagic> :k (~)
16:04:46 <lambdabot> k -> k -> Constraint
16:04:58 <Enigmagic> :k Integral
16:04:59 <lambdabot> * -> Constraint
16:05:26 <hpc> (or rather, the kind)
16:05:27 <hpc> :k (=>) -- i wonder
16:05:27 <hpc> bah, nope
16:05:28 <lambdabot> parse error on input ‘=>’
16:05:38 <hpc> if it were possible to query, (=>) :: Constraint -> * -> *
16:05:41 <hpc> or something like that
16:06:11 <Gurkenglas> more like (Constraint -> (Constraint -> *) -> *), right?
16:06:52 <Gurkenglas> No wait every right side of => is also a valid type nvm.
16:06:53 <Cale> (c :: Constraint) -> (FV c -> *) -> *  ???
16:06:59 <olpery> if pattern matching implemented as if/else chains (conceptually) or is there more to it?
16:08:31 <Cale> olpery: Pretty much... it's not quite that, but the top listed pattern which matches wins, so you can imagine that they're just tried sequentially in order
16:09:42 <RyanGlScott> Also, be aware that if it doesn't find a match, it errors (unlike if-statements in many imperative languages)
16:09:50 <Cale> They're actually compiled into a bunch of separate branches, each of which is matching on a single constructor at a time. Since it's a comparison with an integer tag, you can imagine an implementation where these simple-cases are implemented with a computed jump, but I don't *think* the existing implementations do that.
16:13:02 <dfk> question - how can i return multiple values from C FFI without a memory leak nightmare?
16:13:53 <Cale> I guess you would want to use ForeignPtrs and set finalizers on them to free the associated memory... at least in a lot of cases.
16:14:04 <dfk> finalizers?
16:14:17 <Cale> er
16:14:33 <Cale> Well, it depends on who owns the memory
16:14:48 <dfk> i'm open to whatever way is the right way
16:14:52 <Cale> If you're passing pointers to memory that you own, and it's meant to write that memory, then you can allocate
16:14:54 <dfk> as long as i can get data back into haskell
16:14:59 <Cale> on the Haskell side
16:15:09 <dfk> that's probably the cleanest way huh?
16:15:16 <Cale> Yeah
16:15:19 <dfk> i'm guessing a malloc in the C code is probably a bad idea
16:15:27 <verement> dfk: what about using allocaArray/peekArray?
16:15:49 <Cale> Or depending on what it is, malloc
16:15:51 <dfk> verement is there a gist somewhere?
16:15:55 <Cale> malloc :: Storable a => IO (Ptr a)
16:16:05 <Enigmagic> :t Foreign.Marshal.alloca
16:16:06 <lambdabot> Foreign.Storable.Storable a => (GHC.Ptr.Ptr a -> IO b) -> IO b
16:16:10 <Enigmagic> ^-- also handy
16:16:29 <dfk> i'm already passing arrays into the C code with Ptr CDouble
16:16:45 <dfk> i haven't played with mutating anything yet
16:16:50 <Cale> Yeah, there tend to be continuation passing style versions of such things which free the memory once the program you pass in is finished running
16:17:22 <Enigmagic> yes, much easier to deal with than trying to bracket/free things properly with exceptions
16:17:50 <Cale> I don't know whether it's possible for FFI code to trigger an exception
16:17:56 <Cale> But yeah, better safe than sorry
16:18:12 <Enigmagic> throwTo/kill/etc will queue exceptions up that are thrown when returning from an ffi call
16:18:22 <Cale> ah, right
16:18:24 <Cale> That's true
16:20:57 <raj123> hi guys
16:21:09 <raj123> i needed some help with the bron kerbosh algorithm
16:21:48 <raj123> i need to study the algorithm and figure out its complexity in a detailed analysis
16:22:02 <raj123> but i have no idea how to get the code working in haskell
16:22:57 <raj123> https://www.andres-loeh.de/IFIP-MCE.pdf
16:23:04 <raj123> the code can be found there
16:23:09 <raj123> but i cant get it to work
16:23:31 <raj123> and i want to study the bron kerbosch algorithm without the pivot
16:23:37 <raj123> anyone?
16:45:46 <tippenein> to "hard restart" stack, would it just involve removing the ~/.stack directory?
17:39:48 <guido_> join #haskell-beginners
17:51:30 <Sonderblade> sets in haskell doesnt appear to have a length method, is that by design?
17:54:56 <ski> @type Data.Set.size  -- Sonderblade ?
17:54:57 <lambdabot> S.Set a -> Int
17:56:46 <Sonderblade> ski: aye, but it doesn't answer my question
17:56:59 <ski> then i don't understand the question
17:57:06 <johnw> he wonders why the name is different?
17:57:40 <nolraiU> Well I think its just a quirk of english.
17:58:01 <Gurkenglas> :t length :: S.Set a -> Int
17:58:02 <lambdabot> S.Set a -> Int
17:58:16 <monochrom> pitfall of "meaningful" names. you think you know what the other guy means by the "meaningful" name "length"
17:58:42 <nolraiU> Wait sets have both a size and a length?
17:59:13 <Gurkenglas> :t length -- S.Set is a Foldable. I imagine that S.Set is older than Foldable and size remains for legacy reasons?
17:59:14 <lambdabot> Foldable t => t a -> Int
18:01:13 <EvanR> length -- the length of the list created by converting a foldable to a list
18:01:19 <EvanR> length of a set doesnt make too much sense
18:01:48 <Gurkenglas> https://hackage.haskell.org/package/containers-0.5.7.1/docs/src/Data.Set.Base.html#line-286 length = size
18:02:20 <Sonderblade> EvanR: length = number of items
18:02:28 <EvanR> is there also an area?
18:02:36 <EvanR> length squared?
18:03:17 <Gurkenglas> length might be a bad name, Sonderblade is right, it should be more like "cardinality"
18:03:19 <EvanR> or perhaps square root of the length, as if you placed the items in a square shape
18:03:28 <monochrom> well then "size" is the number of items. so why doesn't it answer your question again?
18:03:52 <hpc> i thought immutable languages couldn't Set variables
18:04:25 <Gurkenglas> Sonderblade, I imagine that all this legacy crap would be much less of a problem if every Haskell update came with a script that updates source code to be compliant with the new version
18:04:48 <EvanR> dont people get upset over names all being the same?
18:04:48 <Gurkenglas> (which would automatically be used by ghc when compiling old code)
18:05:04 <EvanR> size should be a nice break from the monotony of lengths
18:05:10 <Gurkenglas> Redefine (.) to be an infix alias of fmap :D
18:05:22 <Sonderblade> Gurkenglas: i didn't find the length method on Sets using hoogle (https://www.haskell.org/hoogle/?hoogle=length) so I assumed it didn't exist
18:05:38 <EvanR> @hoogle Set a -> Int
18:05:39 <lambdabot> Data.Set size :: Set a -> Int
18:05:39 <lambdabot> Data.Set findMax :: Set a -> a
18:05:39 <lambdabot> Data.Set findMin :: Set a -> a
18:05:58 <Maxdamantus> and `map` to be an alias of `fmap`.
18:06:02 <EvanR> @hoogle Set a -> Integer
18:06:02 <lambdabot> Data.Set findMax :: Set a -> a
18:06:02 <lambdabot> Data.Set findMin :: Set a -> a
18:06:02 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
18:06:07 <EvanR> hrrm..
18:06:09 <Gurkenglas> hoogle needs to give expressions that can be followed by :: and the type you're giving
18:06:33 * dfk continues tinkering with C FFI
18:07:29 <dfk> can anyone explain storable vector unsafeWith? I'm using it in 'monkey-see-monkey-do' style at the moment
18:07:31 <Gurkenglas> (compare the exference project)
18:10:36 <dfk> hrm C code mutation of my storable vector isn't working as intended
18:10:46 <Gurkenglas> dfk, that gives an IO action read-only access to the Vector's data directly and very quickly, the unsafe part being that it's not actually checked that the access is read-only
18:11:05 <dfk> gurgenglas ah maybe that's my mistake
18:11:13 <dfk> 1 of my 3 vectors I want to mutate
18:11:32 <dfk> is there a drop-in replacement for unsafeWith for a writeable vector
18:11:54 <dfk> ?
18:12:19 <monochrom> you should be using Data.Vector.Storable.Mutable if you want to write
18:13:03 <dfk> monochrom ok...
18:13:09 * dfk looks at hackage
18:15:01 <dfk> hmm this is getting confusing
18:15:15 <dfk> monochrom what if i have multiple C array arguments
18:15:20 <dfk> two of them are read-only
18:15:30 <dfk> one is to be mutated
18:15:53 <dfk> what happens if I have nested unsafeWith, some are mutable and some are not?
18:16:13 <monochrom> the two read-only's can be Vector. the writable has to be MVector. nesting unsafeWith's is ok.
18:17:16 <monochrom> Vector's unsafeWith doesn't want you to modify the vector it owns. but you can certainly modify something else, namely some MVector
18:18:12 <dfk> is there a substitute for fromList for mutable storable vectors?
18:19:05 <monochrom> I see "new", "unsafeNew", "replicate", "replicateM', "clone", ... in the docs.
18:19:37 <monochrom> in fact I don't see "fromList"
18:20:24 <dfk> weird i wonder why would mutable not have an equivalent fromList
18:20:28 <dfk> anyway i'll try new
18:20:57 <monochrom> there are also two last-resort non-obvious options. one is write your own loop to use "write". another is to thaw a Vector
18:22:40 <dfk> type tetris ...
18:22:45 <dfk> new :: (PrimMonad m, Storable a) => Int -> m (MVector (PrimState m) a)
18:22:45 <dfk> Source
18:22:45 <dfk> new is
18:23:01 <dfk> new :: (PrimMonad m, Storable a) => Int -> m (MVector (PrimState m) a)
18:23:21 <dfk> while unsafeWith is
18:23:22 <dfk> unsafeWith :: Storable a => IOVector a -> (Ptr a -> IO b) -> IO b
18:24:21 <monochrom> you can safely stick to IOVector, can't you? you don't need the full generality of MVector, do you?
18:24:52 <dfk> oh so explicitly specify type as IOVector ?
18:25:07 <dfk> wasn't grokking m (MVector (Primstate m) a)
18:26:51 <monochrom> m = IO.  Primstate IO = RealWorld probably
18:28:00 <monochrom> you do not need the other option (m = ST) for now because you're talking to C. ST is when you talk to yourself.
18:28:38 <dfk> so inside my where block i have
18:28:55 <dfk> result = (MSV.new 10) :: MSV.IOVector (CDouble)
18:29:55 <dfk> Expected type: MSV.IOVector CDouble
18:30:12 <dfk> Actual type: MSV.MVector
18:30:32 <ski> dfk : not something like `result :: MSV.IOVector CDouble <- MSV.new 10' ?
18:30:45 <dfk> ski this is all in the where block
18:30:49 <ski> hm, actually you said `where', not `do'
18:31:06 <dfk> otherwise the nesting for the unsafeWith gets pretty messy
18:31:22 <dfk> i could try to do it monadically if there's no other way
18:31:25 <exio4> monochrom: m = ST s :p
18:31:31 <ski> i was thinking `MSV.new' was the `new' whose signature you mentioned some minutes ago
18:31:54 <Lokathor> once again i'm back to the oldest problem in the book
18:31:59 <dfk> (admission - still not that great at reading these monadic type signatures beyond trivial ones at the moment)
18:32:15 <dfk> MSV.new is the new signature that I mentioned
18:32:20 <monochrom> where is the IO? new 10 should have type IO (IOVector CDouble).
18:32:25 <Lokathor> "do i try to decode the bytes from IRC at all and hope they're textual? or do i just hope that i can manipulate a stream of Word8 and have it make sense?"
18:32:27 <dfk> MSV is my qualified import for Data.Vector.Storable.Mutable
18:32:54 <ski> <dfk> new :: (PrimMonad m, Storable a) => Int -> m (MVector (PrimState m) a)
18:32:55 <ski> ?
18:33:13 <dfk> ski yes
18:33:29 <dfk> ski basically i'm trying to initialize a mutable vector
18:33:42 <dfk> use that with an FFI call that takes a combination of immutable and immutable arrays
18:33:53 <dfk> and readout the result from the mutable vector
18:34:01 <ski> dfk : but it looks like that returns an action (an `m'-action. possibly `m' is `IO' in your case). but your `result = (MSV.new 10) :: MSV.IOVector (CDouble)' took no heed of this matter
18:34:27 <dfk> ski so i need to do the <- bind?
18:35:08 * ski sees monochrom saying the same thing
18:35:08 <ski> dfk : yes, or something similar to that effect
18:36:32 <dfk> oh man these wrapped unsafeWith lambdas are getting ugly
18:36:44 <dfk> i feel like i should be able to do this with a monadic bind or something
18:36:57 <dfk> but my brain isn't working
18:39:03 <dfk> typechecks!
18:39:43 <dfk> not working though ... hmmm FFI call doesn't happen
18:47:31 <dfk> ok
18:47:37 <dfk> http://lpaste.net/156611
18:48:18 <dfk> c_model is the ffi call
18:49:26 <dfk> why doen't the ffi function actually get executed here
18:49:27 <dfk> ?
18:49:53 <ski> i'm not quite sure what's going on there, but that `unsafePerformIO' call looks strange
18:50:56 <dfk> ski it typechecks at least
18:51:38 <monochrom> what is state? what is fun?
18:51:40 <ski> dfk> :t c_model
18:51:55 <ski> (i'm almost sure what you should do here, just want to double check with `c_model')
18:52:13 <monochrom> and recall that unsafePerformIO puts you back into the laziness world where a computation does not have to happen "immediately"
18:52:41 <dfk> yeah i'm wondering if it's that retVal never gets evaluated
18:52:55 <dfk> i'm looking for the CInt -> Int to do a show on it
18:52:55 * ski is waiting for dfk to answer the question
18:53:40 <dfk> it is GHC.Ptr.Ptr CDouble -> GHC.Ptr.Ptr CDouble -> CDouble -> GHC.Ptr.Ptr CDouble -> IO Int
18:54:03 <dfk> oof... terminal spacemacs on OSX kindof sucks ... no copy and pasting
18:54:11 <monochrom> why are you doing the equivalent of "return (putStrLn "hello")"?
18:54:49 <dfk> monochrom don't really care about the value of the function here, at least not for now
18:54:50 <monochrom> in fact why are you doing the equivalent of "unsafePerformIO (return (putStrLn "hello"))"? do you even know what it means? (I certainly don't, apart from "it means no good")
18:54:53 <dfk> i just want the side effect to work
18:55:09 <ski> dfk : yeah, i think you should remove the `return's at line `5' and `7' in the paste
18:55:20 <ski> .. and the `unsafePerformIO', as well
18:55:35 <monochrom> well the thing is with that many layers of unsafePerformIO and return, it's so full of XYX problems that the side effect is unlikely going to happen.
18:55:53 <ski> monochrom : well, `unsafePerformIO (return (putStrLn "hello"))' is unproblematic, afaics
18:56:05 <dfk> the layers are just there for the array/vector marashalling
18:56:12 <dfk> if there's a better way i'm all ears
18:56:32 <exio4> what's SV here?
18:56:42 <ski> dfk : anyway, it typechecked because you managed to make errors cancel out (in the type system) with the error of using `unsafePerformIO'
18:56:52 <dfk> SV is storable vector import
18:57:06 <dfk> when i remove the return s on 5 and 7 it no longer type checks
18:57:40 <ski> did you remove the `unsafePerformIO' as well ?
18:58:23 <dfk> ok
18:58:47 <infinity0> in pipes, for a generic Proxy, how do i yield-to-upstream or await-from-downstream?
18:58:50 <ski> (i'm assuming `SV.unsafeWith' and `MSV.unsafeWith' have similar type signatures)
18:58:50 <exio4> I think you are misunderstanding the way IO works
18:59:19 <exio4> SV.unsafeWith :: Storable a => Vector a -> (Ptr a -> IO b) -> IO b ; MSV.unsafeWith :: Storable a => IOVector a -> (Ptr a -> IO b) -> IO b 
18:59:29 <dfk> this is wht it looks like now http://lpaste.net/156611
19:00:02 <dfk> exio4 like i said still in monkey see monkey do learning right now =/
19:00:54 <dfk> now checking to see if the side effect to result happened as intended..
19:02:42 <dfk> is there a cleaner way to do these nested unsafeWith actions?
19:03:31 <exio4> dfk: don't use let and use lambdas directly
19:03:54 <exio4> dfk: and do whatever you want inside the continuation, instead of executing it and then doing something with such value
19:04:23 <dfk> exio4 with <- right?
19:05:30 <lpaste> EXio4 pasted “No title” at http://lpaste.net/156619
19:05:35 <exio4> dfk: something akin to this ^ 
19:06:45 <monochrom> well, sometimes you do want to exit your unsafeWith scope earlier
19:07:09 <ski> yes :
19:07:09 <ski>   retVal <- SV.unsafeWith state $ \ptrState ->
19:07:09 <ski>     SV.unsafeWith param $ \ptrParam ->
19:07:09 <ski>       MSV.unsafeWith result $ \ptrResult ->
19:07:09 <ski>         c_model ptrState ptrParam tMax ptrResult
19:07:10 <ski> (if you prefer, you could break line after the `<-', indenting all but the first of those lines one indentation "level" further)
19:07:10 <ski> one could also replace `retVal <-' by `(<* print "done") $', and avoid naming `retVal' at all
19:08:45 <exio4> monochrom: this doesn't seem to be the case
19:09:46 <monochrom> true
19:11:08 <ski>   retVal <- evalContT (c_model <$> ContT (SV.unsafeWith state) <*> ContT (SV.unsafeWith param) <*> return tMax <*> ContT (MSV.unsafeWith result))
19:11:08 <ski> something like that should work, i think
19:11:30 <ski> hm .. not quite
19:11:58 <ski> (`c_model' gives an `IO'-action, not just an `Int')
19:12:21 <monochrom> maybe you just need Cont, or cont
19:13:37 <ski> (also the `return tMax' there is irritating)
19:13:59 <monochrom> oh, call it "pure tMax" instead to be sure!
19:14:26 <dfk> how do i marshall the mutated Ptr CDouble (result) into a vector or list
19:14:33 <dfk> ?
19:14:43 <ski> monochrom : well, just as irritating :)
19:15:23 <ski> i suppose we need an infix version of `strength' (the `flip' variant)
19:15:59 <monochrom> what marshal? your IOVector is already mutated.
19:16:15 <ski> (of course, in the particular case, the point is moot, as long as the `c_model <$>' part isn't taken care of)
19:18:38 <dfk> monochrom ok I mean get IO Vector into something show-able
19:19:10 <monochrom> then you can use "freeze" to get a Vector first.
19:19:34 <monochrom> or you can write a loop that "read" and "print" individual cells
19:19:47 <dfk> freeze?
19:20:15 <dfk> no mention of freeze in Data.Vector.Storable.Mutable
19:20:16 <monochrom> you have read the Data.Vector.Storable doc page, haven't you?
19:21:00 <dfk> but this one is the mutable..
19:21:12 <monochrom> ok you haven't read.
19:21:38 <dfk> oh i see
19:21:48 <ski> @type let foo :: (a -> b -> o) -> ((a -> IO o) -> IO o) -> ((b -> IO o) -> IO o) -> IO o; foo f c0 c1 = (`runContT` return) (f <$> ContT c0 <*> ContT c1) in foo
19:21:49 <lambdabot> (a -> b -> o) -> ((a -> IO o) -> IO o) -> ((b -> IO o) -> IO o) -> IO o
19:22:02 <ski> @type let bar :: (a -> b -> IO o) -> ((a -> IO o) -> IO o) -> ((b -> IO o) -> IO o) -> IO o; bar f c0 c1 = (`runCont` id) (f <$> cont c0 <*> cont c1) in bar
19:22:03 <lambdabot> (a -> b -> IO o) -> ((a -> IO o) -> IO o) -> ((b -> IO o) -> IO o) -> IO o
19:22:10 <ski> monochrom, *nod*
19:22:47 <dfk> yay mutation happened
19:23:46 <dfk> now for the real version of this the array represents a 2D matrix =(
19:24:03 <dfk> but i think i'll flatten it out to keep the marshalling simple..
19:25:20 <argent0> Hi, is it possible to write this function without using a lambda (point free?)?: :t (\(a,b) -> ((a,) &&& (b,)))
19:25:36 <argent0> :t (\(a,b) -> ((a,) &&& (b,)))
19:25:37 <lambdabot> (t, t1) -> b -> ((t, b), (t1, b))
19:26:25 <verement> @pl \(a,b) -> ((a,) &&& (b,))
19:26:25 <lambdabot> (line 1, column 14):
19:26:25 <lambdabot> unexpected ","
19:26:25 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
19:26:48 <exio4> @pl \(a,b) -> ((,) a) &&& ((,) b))
19:26:48 <lambdabot> (line 1, column 30):
19:26:48 <lambdabot> unexpected ')'
19:26:48 <lambdabot> expecting variable, "(", operator, "&&", "***", "&&&", "<|>" or end of input
19:26:53 <exio4> @pl \(a,b) -> ((,) a) &&& ((,) b)
19:26:53 <lambdabot> uncurry ((. (,)) . (&&&) . (,))
19:26:57 <ski> @type uncurry (&&&) . ((,) *** (,))
19:26:58 <lambdabot> (b1, b') -> b -> ((b1, b), (b', b))
19:27:25 <ski> argent0 : see my version ^
19:27:29 <argent0> ski, cool! 
19:27:40 <Gurkenglas> :t uncurry (&&&) . over both (,) -- dangit ninjad but still
19:27:41 <lambdabot> (a, a) -> b -> ((a, b), (a, b))
19:28:00 <argent0> thanks, you must be a bot :)
19:28:37 * ski bows
19:30:06 <Gurkenglas> "((,) *** (,))" <- hairy fat man?
19:31:19 <Gurkenglas> In what situation does replacing "=" with "= go where go =" help?
19:31:53 <numee> making an expression point-free can be done without thinking much like solving linear equations: http://pastebin.com/mFG55HQ2
19:32:00 <monochrom> hairy fat man? holy bat man?
19:33:00 <geekosaur> Gurkenglas, when it lets you capture a recursive term without having to pass parameters to it (instead being able to access them from the scope of the main declaration)
19:33:24 <geekosaur> ...still useful if you're reducing it to a smaller number of variable parameters and not passing any fixed parameters
19:33:33 <argent0> numee: Thanks thats is very helpful!
19:33:41 <exio4> Gurkenglas: map f = go where go [] = [] ; go (x:xs) = f x : go xs 
19:34:07 <Gurkenglas> hmk
19:34:15 <geekosaur> basically focusing recursion for the compiler so it has a better chance of optimizing it
19:34:25 <exio4> Gurkenglas: something x y = loop where loop = do { ... ; ...; when c loop; }
19:34:47 <ryantrinkle> does anyone know if it's possible to express that an associated type family must have 'phantom' or 'representational' type roles?
19:34:58 <Gurkenglas> That sounds mechanical, couldn't the compiler do it?
19:35:01 <ryantrinkle> specifically, I'd like to require that this type be coercible: https://github.com/reflex-frp/reflex/blob/develop/src/Reflex/Class.hs#L34
19:35:10 <geekosaur> in some cases it can. in some cases it's harder than it seems
19:35:26 <Gurkenglas> Does it do so in simple cases, removing the necessity to do it?
19:35:50 <Gurkenglas> Can it tell that it can't in most cases? Maybe we could make compiling interactive x)
19:36:04 <geekosaur> (in particular it may apply something else, like inlining, first that makes it look no longer like a candidate for loop optimization)
19:36:31 <Gurkenglas> *removing the necessity to do it manually
19:36:51 <geekosaur> in many ways this is still something of a black art, I;m afraid. ghc gets better at it all the time, but you still need to look at core and figure out whether you need to point out and focus the recursive part for it or not
19:36:58 <Gurkenglas> How can we tell whether it should do loop optimization or inlining when only one is possible?
19:37:12 <geekosaur> time it?
19:37:24 <Gurkenglas> Can we make the compiler time it :D
19:37:34 <ski> numee : yes, but to get something slightly more compehensible, you need to think
19:38:50 <Gurkenglas> Can you give an example where inlining breaks focussing?
19:51:35 <geekosaur> Gurkenglas, I can't really come up with one offhand but it comes down to inlining could lead the compiler to think the recursion is too complex to optimize into a loop
19:51:55 <geekosaur> so sometimes you need to do things to suppress inlining (maybe only of some things)
19:52:36 <Gurkenglas> Ah, so inlining doesn't break focussing, it breaks the part at the end where it ends up not being recursion at all anymore?
19:54:41 <geekosaur> "focusing" is my terminology not anything official. I'm trying to get at the idea that you sometimes need to "hide" things that would cause the recursive expression to become too complex, so it doesn't think there'd be any gain in turning it into a loop
19:55:27 <geekosaur> the "where go =" bit can help by breaking out the recursive part exactly and letting you rearrange it so it's more obviously simple enough to turn into a loop
19:55:50 <orion> I'm using Aeson to parse an Array of Objects. If the parsing of any object fails, all I want to do is leave that object out. Is there an easy way to do this?
19:56:11 <orion> I want the failed objec tto be silently left out of the resulting Array.
19:56:31 <orion> I"m sure I might want to use the Alternative operator somewhere.
20:00:20 <dfk> so for getting a 2D array data mutated in C back into haskell
20:00:54 <dfk> is the best way just to flatten it into a 1D Ptr CDouble
20:00:59 <Cale> orion: show me what you have so far? I think you'll want to write a Parser [Vector Value] and then fmap (Array . concat) over it
20:01:13 <dfk> or is there something more elegant?
20:04:18 <Cale> (that's V.concat rather)
20:05:15 <ski> @type Just.Just
20:05:16 <lambdabot> Not in scope: data constructor ‘Just.Just’
20:06:19 <orion> Cale: http://lpaste.net/2092210532751769600
20:11:08 <ryantrinkle> does anyone know if there's a way to write ReaderT so that the third type parameter doesn't have nominal role?
20:12:06 * hackagebot pandoc-crossref 0.2.0.1 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.2.0.1 (lierdakil)
20:17:05 <montanonic> Does the lifted-base package just make it so that I don't have to write liftIO?
20:17:09 <Cale> orion: Well, first of all, you should case on HM.toList o
20:19:07 <geekosaur> montanonic, it lifts base not in the liftIO sense but in the MonadBaseControl sense, i.e. provides better exception handling
20:20:02 <geekosaur> basically normal exceptions are only safe if you are directly in IO, not necessarily in some other monad over IO --- you can easily leak resources (memory, open filehandles, ...) unless you are very careful
20:20:18 <Cale> ryantrinkle: hmm... is it not representational?
20:20:38 <montanonic> geekosaur: okay; msnoyman recommended to use it, so I was just curious why. I think a lot of Yesod classes are already instances of it anyways.
20:20:39 <geekosaur> MonadBaseControl provides mechanisms to deal with that, and lifted-base extends that to the base
20:20:44 <ryantrinkle> Cale: it's nominal - i think because the 2nd argument's first argument *could* be nominal
20:20:56 <montanonic> geekosaur: thank you for your explanation and hel
20:20:58 <montanonic> help*
20:21:03 <Cale> hmm, right
20:21:40 <Cale> The role annotation syntax sucks
20:23:02 * ski . o O ( role polymorphism ? )
20:23:27 <Cale> It should have a type-like syntax
20:23:35 <Cale> Even without polymorphism
20:23:38 <ryantrinkle> ski: haha, that's probably what i'm asking for :)
20:23:54 <Cale> But yeah, polymorphism would be the right thing
20:24:08 <koz_> I wanted to learn about lenses, but I'm not sure which lens library I should be rocking, as there seem to be so many. Could someone please point me in the right direction?
20:25:13 <ski> @where lenses
20:25:13 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-
20:25:13 <lambdabot> structure-access-and-mutation>
20:25:19 <ski> @where lens
20:25:19 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
20:25:33 <ski> koz_ : you could look at those links, and #haskell-lens
20:25:45 <koz_> Wow, it has its own *chan*?
20:25:59 <koz_> I'll have a look at haskell-lens on Hackage (I assume it's on Hackage?).
20:26:11 <orion> Cale: Good idea! You mean like this?: http://lpaste.net/2092210532751769600 (sans the redundant bracket)
20:26:50 <Cale> orion: I was initially just referring to the fact that you were testing the size of the HashMap and then using head
20:27:08 <ski> @hackage lens
20:27:08 <lambdabot> http://hackage.haskell.org/package/lens
20:27:08 <ski> is the edwardk lenses
20:27:08 <Cale> (which is bad -- you should never use head in a position where you had to check beforehand that it would succeed)
20:27:21 * ski frowns at lambdabot
20:27:44 <Cale> orion: I also noticed that you indent if/then/else strangely. The conventional way is:
20:27:46 <Cale> if foo
20:27:49 <Cale>    then bar
20:27:52 <Cale>    else baz
20:28:28 <Cale> orion: Oh, also, you want to match against  (_, Object m) : _  there
20:28:41 <Cale> (your pattern currently only matches lists of length 2)
20:29:14 <koz_> ski: Thank you very much! :)
20:29:49 <orion> Cale: Good catch! Thank you.
20:30:37 <koz_> Have I ever said how nice you all are?
20:30:47 <koz_> If not, you are all very helpful and friendly people. :)
20:31:22 <Cale> ski, ryantrinkle: So what would it be? :)  type role ReaderT :: forall r s, (Representational < s) => Representational -> (r -> s) -> r -> s
20:32:11 <ryantrinkle> Cale: yeah, maybe so
20:33:04 <ryantrinkle> Cale: while i'm at it, i'd also like to be able to write type roles for families
20:33:05 <ryantrinkle> e.g.:
20:33:15 <ryantrinkle> type role Event nominal representational
20:33:25 <ryantrinkle> and have that be a *requirement* for the implementer of the Reflex typeclass
20:33:41 <ryantrinkle> instead, now, i'm adding functions coerceEvent and coerceBehavior
20:33:43 <Cale> interesting, yeah
20:34:08 <ryantrinkle> coerceEvent :: Coercible a b -> Event t a -> Event t b
20:34:19 <Cale> Isn't the first parameter to Event phantom?
20:34:32 <ryantrinkle> Cale: no, it's nominal - it selects the implementation
20:34:45 <Cale> oh, right, coercing across that is bad :P
20:34:53 <ryantrinkle> haha yeah :)
20:35:10 <ryantrinkle> though it might be interesting, again, to have role polymorphism there
20:35:10 <scshunt> Cale: Do you know anything about Zoom?
20:35:22 <Cale> scshunt: From lens?
20:35:24 <ryantrinkle> e.g., we could require that t have a first parameter that is phantom
20:35:24 <scshunt> yeah
20:35:40 <ryantrinkle> which could allow some zero-cost movement between timelines
20:37:48 <ski> koz_ : yw
20:38:05 <ski> Cale : i forget the direction of the ordering
20:38:27 <Cale> ski: I was counting phantom < representational < nominal
20:38:48 <Cale> but it's obviously somewhat arbitrary depending on how you think about it
20:39:00 <ski> ryantrinkle : "timelines" ?
20:39:32 <ryantrinkle> ski: well, the 't' parameter in Reflex is basically meant to establish an environment in which synchronous FRP makes sense
20:39:42 <ryantrinkle> obviously, to talk to each other, two Events need to come from the same implementation
20:39:48 <ski> mhm
20:39:57 <ryantrinkle> but it's also possible that you could have multiple domains using the same implementation
20:40:06 <ryantrinkle> but running asynchronously from each other
20:40:16 <ryantrinkle> and then you'd need some ways of doing stuff like
20:40:39 <ryantrinkle> mergeAsync :: Event t a -> Event t' b -> Event t' (Either a b)
20:40:40 <ski> not sure i get what "same implementation" means
20:40:54 <ryantrinkle> ski: the entire engine underlying reflex can be ripped out and replaced
20:41:10 <ryantrinkle> there's a typeclass, Reflex, and the main implementation is just an instance of that
20:41:11 <EvanR> hrm why is t' the one that wins
20:41:19 <ryantrinkle> EvanR: arbitrary
20:41:35 <ryantrinkle> you can think of it like importing an event from t into t'
20:41:41 <EvanR> ah its merging into one or the other side, not neither
20:41:45 <ryantrinkle> right
20:41:50 <EvanR> or both
20:41:54 <ryantrinkle> maybe there's a way for a merge into t'' to make sense, but i'm not sure
20:42:27 <ryantrinkle> and the reason it's Either is that it doesn't (probably) make sense to say that two events are simultaneous if they're not from the same domain
20:42:34 <ryantrinkle> i could be wrong about that, though
20:42:43 <ryantrinkle> i haven't actually implemented cross-timeline stuff yet
20:42:56 <ryantrinkle> it's just an idea at this point :)
20:43:18 <ryantrinkle> however, the test suite already uses the t parameter to check that the semantics are right
20:43:19 <Cale> transferAsync :: Event t a -> Event t' a ?
20:43:29 <ryantrinkle> there's a very small, pure implementation of Reflex
20:43:32 <ryantrinkle> which is "obviously correct"
20:43:42 <ryantrinkle> but leaks memory like a seive and doesn't run interactively :P
20:44:01 <ryantrinkle> then there's the real implementation ("Spider"), which is what we run in production
20:48:10 <danilo2> Hello! Are there any standard newtypes that unify type variables of a data type? I mean something like that: newtype Unify2 t a = Unify2 (t a a)     etc.
20:48:35 <danilo2> (to be able to for example bi-map or tri-map a datatype
20:49:05 <danilo2> I bet I've seen something like that somewhere
20:52:32 * ski would call that `Dup' .. or perhaps `Warbler'
20:52:40 <ski> (`Warble' ?)
20:53:39 <danilo2> ski: but I need Unify3 and Unify4 too
20:53:52 <ski> one could also consider `Contract' or `Contraction'. or `Duplicate'/`Copy' if you're thinking the other direction
20:55:07 <ski> i'm not sure i understand the "bi-map or tri-map a datatype" part
20:56:36 <danilo2> ski: Ok, sorry for the shortcut. So I can do something like  `trimap f = unwrap . fmap f . Unify3` where `unrwap = view _Wrapped'` (from Lens)
20:57:00 <danilo2> this way I'd get function: trimap :: (a -> b) -> t a a a -> t b b b
20:57:45 <ski> no need to apologize
20:58:21 <ski> i see
20:58:38 <ski> hmm
21:02:00 <danilo2> ski: I think I'll just manually define it and If I find something like that somewhere I'll replace it. I remeber I've seen it, but dont know where
21:03:51 <ski> mhm
21:07:08 <danilo2> ski: thank you! :)
21:10:51 <ski> hm. does GHC suppose type families indexed (only) by kinds ?
21:10:58 <ski> s/suppose/support/
21:12:08 <exio4> ski: what do you mean?
21:19:18 <danilo2> ski: as far as I know not. You cannot "overload" type families based only on different kinds
21:19:42 <glguy> ski: I believe it does
21:19:51 <ski> exio4 : something like `type instance Foo * = ...; type instance Foo (k0 -> k1) = ..k0..k1..'
21:20:29 <danilo2> ski: It would give compile-time error, wouldnt it?
21:21:17 <exio4> ski: as far as I know, that should be possible in GHC 8.0+
21:21:38 <glguy> ski: https://github.com/ekmett/hask/blob/2000e9a2026e90940f46ec6ca2789bbd8f0cece1/wip/Classless.hs#L19
21:22:13 <glguy> I can't speak to whether it works outside of one particular version of GHC
21:22:34 <ski> (assuming something like `type family Foo k :: ..k..')
21:22:34 <ski> (note that i want `Foo k' to be a type, not a kind)
21:22:36 <dmj`> glguy: o/ 
21:23:19 <EvanR> haha the 19 extensions on 1 line so you cant see the incoherent instances at the end
21:25:05 <[an]onymous> http://adf.ly/1Yk9Jw Please tell me if this is real or not..
21:25:05 <ski> exio4,glguy : ok
21:25:21 <ski> [an]onymous : is that Haskell-related ?
21:26:09 <ski> danilo2 : i would hope it wouldn't, if expressed in the right way
21:27:03 <danilo2> ski: I was looking for it some time ago. If you find the answer I'd be very interested in knowing it too
21:28:02 <EvanR> glguy: is this hask repo just doing random category theory or is it pertaining to the category Hask
21:28:18 --- mode: ChanServ set +o glguy
21:28:19 --- mode: glguy set +b *!*@205.164.4.70
21:28:19 --- kick: [an]onymous was kicked by glguy (Spam is off-topic on #haskell)
21:28:26 <ski> danilo2 : did you see what glguy,exio4 said ?
21:29:58 <danilo2> ski: ou right, that it would be supported in GHC 8+, thats great news :) 
21:34:22 --- mode: glguy set -o glguy
22:26:40 <dzotokan> :t Num
22:26:43 <lambdabot>     Not in scope: data constructor ‘Num’
22:26:43 <lambdabot>     Perhaps you meant one of these:
22:26:43 <lambdabot>       ‘Sum’ (imported from Data.Monoid),
22:27:10 * hackagebot pandoc 1.17.0.3 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.17.0.3 (JohnMacFarlane)
22:27:18 <dzotokan> @pl runEval3 env ev = runIdentity (runErrorT (runReaderT ev env))
22:27:18 <lambdabot> runEval3 = ((runIdentity . runErrorT) .) . flip runReaderT
22:28:29 <EvanR> runEval3 ev = runIdentity . runErrorT . runReaderT ev
22:37:08 <Gurkenglas> runEval3 = runIdentity . runErrorT .: runReaderT, but .: is an operator that is defined almost nowhere and that I seem to be using so often I can only attribute it to that phenomenon where after you just learned something you start seeing it everywhere
22:37:59 <Gurkenglas> (f .: g) x = f . g x, compare (f . g) x = f $ g x, also infix 8 .:
22:38:45 <EvanR> .: is ok
22:40:12 <Gurkenglas> oh hey, he's got env and ev flipped up there. it's "runEval3 = runIdentity . runErrorT .: flip runReaderT", and you might not want to name it runEval3
22:40:45 <Gurkenglas> The advantage of evalState having its arguments that way around is that you can write foo = evalState $ large do block
22:41:32 <Gurkenglas> I'm not sure whether (`evalState` S.empty) really should look this stupid and I should change my approach, or we're just missing an alias
22:42:14 <EvanR> yes i flipped it to avoid flip and .:
22:42:47 <EvanR> to do a do.. you could flip at the top level....
22:44:39 <Gurkenglas> Where should .: go? The same place . is? Should we make a more general thing out of this, with a hierarchy of (f nplus1 g) x = f n g x?
22:45:20 <EvanR> dont stop there
22:45:30 <EvanR> (.::) = (.) . (.) . (.)
22:45:31 <EvanR> and so on
22:46:40 <Gurkenglas> Make it (.) = fmap, (.:) = fmap . fmap, (.::) = fmap . fmap . fmap, etc
22:51:03 <EvanR> lol
22:51:35 <EvanR> its fmaps all the way down
22:52:09 <jle`> (.::) = fmap`fmap`fmap`fmap`fmap
22:52:59 <Gurkenglas> https://github.com/aelve/haskell-issues/issues/24
22:55:15 <Gurkenglas> puregreen, as quietly feared, already seems to have run out of his initial rush of enthusiastic diligence. Anyone feel up to the task of adding a little fuel to the part of the show where this is redirected to the right people?
22:58:15 <Gurkenglas> (I suddenly understand all those shady cloaked people sitting in the corner of the tavern attracting adventurers.)
23:00:41 <loofee> c
23:01:18 * EvanR orders a mead
23:07:21 <Gurkenglas> We need to find a way to get people doing our fetch quests. How does WoW do it?
23:11:24 <EvanR> offering to pay them in money
23:11:46 <EvanR> however small in quantity
23:12:10 <Gurkenglas> Right, people must have connected issue trackers to mechanical turk before. Especially when the tasks are just "post this to the proper channels"
23:14:08 <Gurkenglas> Doing that without rigor though might summon the economics fairy and lead to the least possible result that still has me paying money
23:14:49 <Gurkenglas> Perhaps the bounty should be for actually getting it implemented, rather than posting it to the right channels?
23:15:52 <Gurkenglas> That sounds like it would raise the appropriate bounty a hundredfold and summon salespeople and then everyone would be mad at me because I summoned salespeople
23:16:28 <EvanR> gurkenglassssss jenkins
23:28:38 <Gurkenglas> (I'll post that to https://github.com/aelve/haskell-issues/issues/25 . Except I already just did.)
23:47:17 * hackagebot metadata 0.4.3.0 - metadata library for semantic web  https://hackage.haskell.org/package/metadata-0.4.3.0 (KatsutoshiItoh)
