00:07:38 * hackagebot insert-ordered-containers 0.1.0.1 - Associative containers retating insertion order for traversals.  https://hackage.haskell.org/package/insert-ordered-containers-0.1.0.1 (phadej)
00:07:38 * hackagebot yesod-pnotify 1.1.3.2 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-1.1.3.2 (KatsutoshiItoh)
00:29:21 <Ralith> any hsqml users around? I'm trying to work out how to dynamically create objects and access their properties
00:29:31 <Ralith> unclear what, if any, API there is for this
00:31:25 <myname_> Hi
00:32:22 <myname_> I'm trying to modify gitit, but I'm having problems
00:35:58 <myname_> what does this type signature mean: "getWikiBase :: ServerMonad m => m String"
00:37:37 <pavonia> myname_: What part don't you understand?
00:37:46 * hackagebot MASMGen 0.5.0.0 - Generate MASM code from haskell  https://hackage.haskell.org/package/MASMGen-0.5.0.0 (petercommand)
00:38:15 <myname_> what does "=>" mean
00:38:36 <pavonia> It adds constraints to the type
00:38:57 <pavonia> So m must have a ServerMonad instance
00:39:13 <myname_> whats a instance
00:39:38 <ralu> instance tels what functions it provides
00:39:56 <liste> myname_: instance is the realization of a type class for a type
00:40:59 <liste> myname_: e.g. there's a type class Eq which describes equality, a type Bool and an instance "instance Eq Bool" which describes how you can determine the equality of two Bools
00:42:11 <myname_> liste: Could you write an example type sig
00:43:54 <liste> myname_: an example signature using Eq: "foo :: Eq a => a -> a -> Maybe a"
00:46:16 <myname_> liste: How I understand the right side: Take two things, return another or nothing; all have the same type 
00:46:18 <liste> myname_: that means roughly "for type `a' for which equality is defined, take two `a's as parameters and return a Maybe a" (but note the currying)
00:46:37 <liste> myname_: your understanding is correct
00:46:48 <liste> myname_: the thing left of => limits the possible types
00:47:01 <liste> to types for which equality is defined
00:47:08 <pavonia> myname_: You might want to read http://learnyouahaskell.com/types-and-typeclasses
00:49:07 <myname_> liste: I'll try that
00:49:38 <myname_> *pavonia
00:57:46 * hackagebot haskmon 0.2.2.0 - A haskell wrapper for PokeAPI.co (www.pokeapi.co)  https://hackage.haskell.org/package/haskmon-0.2.2.0 (pjrt)
00:58:45 <hefesto_> hi :) how can i change Lazy Text to Strict Text? Do I have to go through ByteString?
00:59:14 <bernalex> :t toStrict
00:59:15 <lambdabot>     Not in scope: ‘toStrict’
00:59:15 <lambdabot>     Perhaps you meant ‘BSLC.toStrict’ (imported from Data.ByteString.Lazy.Char8)
00:59:30 <bernalex> hefesto_: Data.Text.Lazy.toStrict
01:00:24 <hefesto_> I see. Thanks!!!!!
01:02:46 * hackagebot handwriting 0.1.0.2 - API Client for the handwriting.io API.  https://hackage.haskell.org/package/handwriting-0.1.0.2 (IsmailMustafa)
01:02:48 * hackagebot xlsx-tabular 0.1.0.0 - Xlsx table decode utility  https://hackage.haskell.org/package/xlsx-tabular-0.1.0.0 (KazuoKoga)
01:04:56 <spinda> Anyone know when the next Cabal version (I believe 1.24) is supposed to come out?
01:05:26 <spinda> I'm really looking forward to the custom-setup stuff.
01:22:52 <knittl> hello. I'm making some first steps with haskell. I tried to combine to functions, but the result is unexpected. I have let sum a b = a+b ; let mult3 = (*)3 ; and let sumMult = fmap sum mult3 ; now, I'd expect sumMult 5 6 to be 33 (= (5+6)*3), but instead it is 21  (= 5*3+6). why?
01:25:35 <lyxia> knittl: sumMult 5 6 = (sum . mult3) 5 6 = sum (mult3 5) 6
01:26:27 <knittl> how can I change precedence?
01:27:00 <lyxia> it's not a matter of precedence
01:27:12 <lyxia> to get what you want you must apply mult3 to the result of sum
01:27:20 <lyxia> (fmap . fmap) mult3 sum
01:28:00 <knittl> I don't get it :]
01:29:12 <lyxia> just write it with the arguments axplicitly sumMult x y = mult3 (sum x y)
01:29:26 <knittl> is it not possible to use fmap?
01:29:32 <lyxia> I did it
01:29:36 <lyxia> you said you didn't get it
01:30:14 <knittl> ah. I mistyped
01:30:50 <lyxia> fatal mistake in haskell... hahaha
01:31:41 <knittl> would this then be the same function as fmap (fmap mult3 sum)?
01:32:21 <knittl> hm. obviously not
01:32:26 <lyxia> indeed
01:32:45 <lyxia> fmap (fmap mult3) sum
01:33:11 <knittl> interesting. I still have a lot to learn. thanks :)
01:33:35 <lyxia> yw
01:33:58 <knittl> so fmap will turn a -> a into f a -> f a?
01:34:12 <GGuy> Hi everyone, I'm trying to work why I get a memory leak when using Strict State monad within a monad transformer. Any ideas?
01:34:14 <opqdonut> knittl: yes
01:34:14 <lyxia> :t fmap
01:34:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:34:19 <lpaste> GGuy pasted “Control.Monad.State.Strict memory leak?” at http://lpaste.net/154319
01:34:29 <lpaste> GGuy revised “Control.Monad.State.Strict memory leak?”: “No title” at http://lpaste.net/154319
01:36:09 <MichaelBurge> GGuy: I'd try two things: 1. Use a strict bytestring(or explicitly set chunking and force chunks) 2. Try using blaze-html over lucid
01:37:06 <MichaelBurge> GGuys: Also, try using the profiling options to see which objects specifically are leaking.
01:37:23 <GGuy> MichaelBurge: but a HtmlT (HtmlT Identity) () doesn't leak which seems weird to me
01:37:32 <GGuy> yeah sure
01:38:06 <GGuy> MichaelBurge: sure, it could be lucid being weird, I'll keep investigating
01:38:15 <bezirg> hello, I want to have a filterM function for Data.IntMap , but there is only a filter there, is there a better way to do it than havign a my-custom containers lib? This is because the Datatype IntMap is abstract.
01:39:58 <lyxia> What's the problem of converting it to a list?
01:41:14 <bezirg> lyxia: because I want to have a filtered intmap as the result, not a list. Do you think I should go that way? Is the toList . filter. fromList more expensive?
01:41:36 <GGuy> MichaelBurge: I've profiled my own app, is there a ghc option for me to turn on profiling for lucid as well? I already have the lucid compiled with profiling just couldn't work out the execute options to show other libraries.
01:41:53 <bezirg> lyxia: sorry I meant:   fromList . filterM . toList
01:42:28 <lyxia> bezirg: fromAscList and toAscList (the latter being synonymous with toList in practice)
01:42:44 <bezirg> lyxia: y
01:43:42 <lyxia> I'm not sure to what extent it matters to use the Asc conversions actually
01:44:36 <MichaelBurge> GGuy: Try setting  'ghc-prof-options: -O2 -fprof-auto' in your cabal file
01:44:50 <lyxia> bezirg: but it shouldn't be that much more expensive than a specialized filterM from a custom containers
01:45:00 <bezirg> lyxia: maybe you are right
01:45:12 <lyxia> bezirg: mainly because filtering could break the whole tree anyway
01:45:30 <hvr> MichaelBurge: fyi, with recent cabals there's a     --profiling-detail=level         Profiling detail level    flag
01:46:02 <GGuy> MichaelBurge: I current run: ghc -O2 -isrc -o prof -odir tmp -prof -auto-all -caf-all -osuf p_o -hisuf p_hi src/Main.hs
01:46:26 <GGuy> but that only gives me profiling for the current app (not lucid)
01:48:30 <bezirg> lyxia: y u r right. In terms of complexity it must be similar. But I think in practice it should be slightly faster because of the intermediate list? Anyway, I will try your suggestion for now. Thank you!
01:50:09 <MichaelBurge> GGuy: It's been awhile since I've done this, but I remember making a sandbox and reinstalling all dependent libraries with profiling options enabled.
01:50:23 <MichaelBurge> If you turn on profiling, but don't compile with extra cost annotations, they might not show up in your output
01:51:45 <MichaelBurge> But, I think your compilation options are correct. You probably just need to compile lucid with them enabled too.
01:51:47 <GGuy> MichaelBurge: Oh right, maybe I missed out extra cost annotation options
01:52:08 <GGuy> MichaelBurge: Thanks!
01:52:33 <GGuy> now just to work out how to add that into my NIXPKG options :S
01:52:45 <GGuy> lol
01:53:52 <MichaelBurge> I recommend using cabal for this, with a sandbox. This guy's article looks familiar: https://nikita-volkov.github.io/profiling-cabal-projects/
01:54:03 <MichaelBurge> Otherwise you'll end up mixing your benchmark code with system libraries
01:55:46 <GGuy> i'm on https://nixos.org/ so all of that fandangled stuff is handled for me, just not pro tweeking build in it yet :(
01:56:51 <hexagoxel> spinda: try asking in #hackage
01:58:12 <mick_> Hi Guys, total noob here. I'm trying to write simulation program and I am using the mwc random library. The trouble I am having is that I when I create my generator, I want to pass that to a function to use which will use it in a loop. I can pass in the generator put I can't reference it because it's in a monad. I am not doing some right or idiomatic here so I need help.
01:58:24 <mick_> createGenerator :: PrimMonad m => m (Gen (PrimState m))                                              | createGenerator = do                                                                                 |   gen <- create                                                                                      |   return gen
01:58:34 <spinda> hexagoxel: thanks!
01:58:40 <mick_> then I can't do this:
01:58:40 <mick_> returnPRNG 0 1 = normal 0 1 createGenerator
01:58:47 <mick_> it barfs big time
01:58:53 <mick_> but in ghci I can do this
01:59:02 <mick_> gen <- create
01:59:08 <mick_> v <- normal 0 1 gen
01:59:22 <mick_> I want to be able to replace gen with createGenerator
01:59:31 <hexagoxel> mick_: please post longer (than 1 line) code in lpaste, not in channel
01:59:36 <liste> mick_: fmap is your friend
01:59:43 <mick_> sorry man
01:59:44 <liste> (or liftM, or <$>)
01:59:47 <hexagoxel> @where paste
01:59:47 <lambdabot> Haskell pastebin: http://lpaste.net/
01:59:48 <mick_> new to IRC
02:00:10 <hexagoxel> mick_: no prob
02:00:21 <mick_> liste: i don't know what you mean
02:00:37 <mick_> i'm a total noob - please can you expand
02:01:21 <MichaelBurge> mick_: ghci takes place inside of a monad that I think is equivalent to IO. It looks like mcw expects you to be in either IO or ST with that PrimMonad constraint.
02:01:41 <liste> mick_: the problem is that createGenerator produces a monadic action and normal expects a value *produced* by that action
02:02:50 <liste> mick_: so you need to run that action first
02:04:00 <exio4> by the looks of it, he wants =<<
02:04:32 <hexagoxel> mick_: are you aware that »m >>= return  =  m«, i.e. »create >>= \gen -> return gen« (your do-block) is just »create« ?
02:04:52 <EvanR> heh » with >>= isnt confusing is it ;)
02:05:05 <EvanR> (and =<<)
02:05:24 <hexagoxel> raaah :D yeah, but "`" is bad as well for escaping half of the time.
02:05:45 <EvanR> i know and then you have trouble explaining """
02:05:50 <EvanR> so "" is out
02:06:08 <EvanR> quotation is broken
02:06:13 <hexagoxel> „abc“ ?
02:06:34 <hexagoxel> →abc← ?
02:07:37 <liste> ``abc'' ?
02:07:51 <EvanR> "abc" ?
02:07:57 <hexagoxel> abc'' would be a valid identifier..
02:09:13 <Ashy> Is there an example somewhere of how to do Facebook and Twitter login with servant?
02:11:16 <{AS}> What did ever happen to SparseCheck, and why is it not as used as QuickCheck?
02:12:53 * hackagebot gore-and-ash-logging 2.0.0.0 - Core module for gore-and-ash with logging utilities  https://hackage.haskell.org/package/gore-and-ash-logging-2.0.0.0 (NCrashed)
02:17:30 <MichaelBurge> {AS}: I hadn't heard of it before, but I wouldn't use it because its homepage 404s and there's no real documentation on Hackage for it.
02:18:24 <{AS}> MichaelBurge: Yeah, I guess so. Thanks for the answer. So last I heard about it was that it used narrowing to generate tests instead of random generation, and th.
02:18:39 <{AS}> and though if there is any efficiency comparison
02:20:11 <{AS}> thought*
02:21:25 <{AS}> But I guess lack of maintenance is influential as well 
02:21:45 <elfeck> hello, can someone tell me how I can redirect stderr to a logfile ie. errors generated by head [] or something
02:22:55 <MichaelBurge> {AS}: I've had efficiency problems in QuickCheck. Usually they boil down to changing the Arbitrary instances to test different code paths equally, or restricting it from generating huge instances that suck up lots of memory.
02:23:24 <MichaelBurge> {AS}: If SparseCheck embeds a mini-DSL and tries to generate adversarial cases, it reminds me of Microsoft's PEX, though I haven't used that seriously.
02:23:59 <{AS}> MichaelBurge: Yeah, that is the idea of it, but I read about it through an academic article, and couldn't find how to use it in the wild
02:27:07 <MichaelBurge> {AS}: At that point, it's probably easier to use a theorem prover, which is something I almost never say.
02:29:05 <EvanR> elfeck: ./myprogram 2> error.log
02:29:32 <elfeck> EvanR: I would like to do that within the haskell code to integrate with other logging
02:29:34 <{AS}> MichaelBurge: Oh, I just wanted to check out the tool (or another narrowing-based tool, for curiousity), not proving any theorem. But thanks for the suggestion
02:29:44 <EvanR> elfeck: well, how does your other logging work
02:30:14 <elfeck> not at all right now. I was thinking about using HsLogger
02:30:58 <EvanR> the crash caused by head [] is an exception, so if you are catching exceptions from some thread that youre going to restart, then print out any exception you get to your logs
02:31:27 <EvanR> and if this is development, rethrow the exception so the whole thing crashes
02:31:32 <EvanR> and fix the bug
02:31:47 <EvanR> or just dont catch
02:31:58 <mniip> is Store a lawful monad under Monoid s?
02:32:21 <elfeck> Hm
02:33:19 <elfeck> This is not a production project. I was looking for a quick fix that writes all of stderr (and more) from within the application to some logfile
02:33:42 <elfeck> Going through every  "dangerous" call to catch exceptions will take a lot of time
02:33:53 <EvanR> that is 2> errors.log
02:34:17 <EvanR> any messages that pop up from threads crashing will go to that file
02:34:53 <elfeck> okay. There is no option to redirect that from within the application?
02:34:57 <elfeck> without piping it
02:35:10 <maybefbi> is there a :: [a] -> [Maybe b] -> [(a,b)]
02:35:18 <maybefbi> hoogle says no
02:35:21 <MichaelBurge> elfeck: I think the freopen() function from libc does that. I imagine it's exposed in Haskell somewhere
02:35:26 <EvanR> there is a way to do it
02:35:35 <srhb> maybefbi: How would that work? How do you zip [1] [Nothing] ?
02:35:39 <EvanR> but this is the "quick fix" that you are asking for
02:35:51 <maybefbi> srhb, if you zip that you'd get an empty list
02:35:54 <EvanR> next time ask for the "not so easy way"
02:35:56 <srhb> maybefbi: Ah, ok.
02:36:07 <elfeck> alright fair enough
02:36:15 <elfeck> thanks
02:36:15 <maybefbi> gotta write with zipWith i guess
02:36:36 <{AS}> maybefbi It is some kind of combination of zip/traverse/filterMaybe?
02:36:55 <maybefbi> {AS}, yeah
02:39:03 <{AS}> maybefbi: \x y -> mapMaybe sequence $ zip x y
02:39:04 <srhb> > zipWith (\a b -> (a,) <$> b) [1,2,3] [Nothing, Just 2, Just 3]
02:39:05 <lambdabot>  [Nothing,Just (2,2),Just (3,3)]
02:39:13 <srhb> Seems sensible, yes.
02:39:30 <{AS}> @pf \x y -> mapMaybe sequence $ zip x y
02:39:30 <lambdabot> Maybe you meant: pl bf
02:40:06 <{AS}> @pl \x y -> mapMaybe sequence $ zip x y
02:40:06 <lambdabot> (mapMaybe sequence .) . zip
02:40:18 <{AS}> maybefbi: ^
02:42:16 <EvanR> (foo .) . bar is not that impressive...
02:42:38 <EvanR> i try to hide the existence of such things from people not familiar with haskell ;)
02:43:07 <{AS}> EvanR: I gave her both versions
02:47:48 <{AS}> But yeah, I would never have written in myself like that without the bot
02:53:00 * hackagebot hmidi 0.2.2.1 - Binding to the OS level MIDI services  https://hackage.haskell.org/package/hmidi-0.2.2.1 (BalazsKomuves)
03:10:28 <nschoe> Hi, anybody know the proper way to issue a 'query' sql command that has 'LIKE' in it, with happstack?
03:10:59 <nschoe> Smth like: query conn "SELECT COUNT(*) FROM client WHERE name LIKE %?%" (Only name)
03:11:45 <nschoe> Except it fatal error. I'm wondering if I should simply use "LIKE ?" and manually concatenate the '%' in the 'name' variable?
03:12:10 <liste> nschoe: what's the database access library? postgresql-simple?
03:12:37 <nschoe> liste, yes indeed (sry)
03:13:29 <nschoe> liste, okay I've just confirmed that manually concatenating the '%' works: "LIKE ?" (Only $ '%' <> name <> '%') works. But it seems ugly ^^
03:14:36 <liste> nschoe: it works like that with all parametrized SQL queries AFAIK
03:14:48 <nschoe> Well actually forget what I said. It makes sense. What if I wanted to make complex search like "mandatoryBeginning%mandatoryEnding". I have to make it manual. So forget what I asked ^^
03:15:15 <liste> nschoe: mind the injection - if name comes from input, the user may input %'s too
03:15:26 <liste> you'd need to escape them
03:15:49 <nschoe> liste, exactly, but I thought that the whole point of making parameterized queries was that happstack was escapign everything
03:21:46 <Cooler> how do you build with cabal?
03:22:41 <dramforever> Literally cabal build
03:23:10 <liste> Cooler: I'd recommend stack for newcomers. if you want to stick with cabal, the general workflow is 1) make a sandbox for your project 2) cabal install --only-dependencies 3) cabal build
03:23:29 <dramforever> But you kinda need to maintain the list of exposed-modules and other-modules, IIRC
03:23:52 <dramforever> +1 for stack, it's generally nicer
03:24:58 <liste> (my list expects the configuration, .cabal file etc to be in order)
03:24:59 <Cooler> what wrong with cabal?
03:26:29 <dramforever> nothing wrong, in fact stack is a wrapper around Cabal (the library)
03:27:04 <liste> stack just makes the common tasks easier
03:27:13 <dramforever> The main thing is that it sets up the entire building environment for you, from ghc up
03:29:34 <dramforever> also the use of stackage snapshots sort of avoids strange dependency problems that you will likely run into pretty soon. It does so by maintaining lists of fixed versions of packages, and you go list to list, not package to package
03:29:43 <dramforever> (when updating)
03:30:07 <hvr> fwiw, next-gen cabal will avoid 'strange dependency problems' as well, but in a more general way than stack
03:30:37 <hvr> without requiring stackage snapshots
03:30:39 <mniip> djinn can't do rankntypes, can it
03:31:35 <hvr> (and no need to explicitly sandbox anymore)
03:33:26 <dramforever> hvr
03:34:06 <dramforever> hvr: That's interesting indeed
03:34:27 <Cooler> need some help with implementing a parser
03:34:40 <Cooler> i am trying to do this problem http://www.scs.stanford.edu/14sp-cs240h/labs/lab1.html
03:34:43 <dramforever> but the benefit of just do stack setup && stack build to build any stack-based project is still therr
03:34:44 <hvr> dramforever: cabal 1.24.x will have it as tech-preview
03:35:02 <dramforever> well, perhaps native deps is still a problem, but hey!
03:35:21 <hvr> tbh, I think stack can be emulated by some wrapper on top of the new functionality in cabal 1.24.x
03:35:47 <hvr> and handle stuff like calling apt-get install for you etc
03:35:58 <Cooler> i have gotten so far http://lpaste.net/154330
03:36:12 <cocreature> hvr: well apt-get install doesn’t work for multiple ghc versions, no?
03:36:20 <hvr> cocreature: it does if you use my ppa =)
03:36:25 <cocreature> fair enough :)
03:37:07 <hvr> cocreature: also I wouldn't recommend using generic ghc bindists for creating mission critical executables
03:37:27 <Cooler> i am not sure how you implement * in the glob matching
03:37:34 <hvr> cocreature: if those are compiled against a different glibc/kernel than the one where executables are to be deployed
03:38:03 <mniip> Monad m => (forall r. m (forall s. m (a -> s) -> s) -> r) -> r) -> forall t. m (a -> t) -> t
03:38:12 <mniip> ideas?
03:38:23 <cocreature> hvr: good point, I don’t create executables that I would call mission critical so I’m not too worried about that :)
03:38:43 <hvr> Linux is not like windows where you have a uniform ABI
03:39:13 <hvr> the only more or less stable ABI is between userspace and kernelspace in a backward-compatible way
03:39:30 <cocreature> yeah I recently had to try to get c++ executables running on an older ubuntu version
03:39:41 <cocreature> it was a pretty painful
03:39:53 <cocreature> s/was a/was/
03:40:01 <hvr> even trying to backport GHC to an ancient SLES distro is awful ;)
03:40:35 <hvr> (ancient but still not EOL'ed)
03:41:00 <cocreature> and every time I tried something to get it working I had to recompile llvm & clang so iterating wasn’t exactly quick
03:41:10 <cocreature> anyway I’m getting offtopic
03:41:22 <hvr> long story short: I'm a big fan of compiling GHC for your target platform
03:41:32 <hvr> and using that
03:42:17 <hvr> and I'm very skeptical of using a GHC compiled for a completely different Linux distro
03:43:20 <cocreature> my lazyness is bigger than my scepticism in that case :)
03:43:33 <cocreature> but you definitely have valid points
03:48:18 <maybefbi> {AS}, thanks but i used good old pattern matching http://lpaste.net/6091697809797414912
03:48:34 <fao> Hello. I'm using monad-coroutine and have something like this: Coroutine (Yield Int) (State MyState) Int. Inside this coroutine i'm doing some state manipulation and would like to use the Zoom functionality provided by lens. But I cannot come up with correct Zoom instance for it. Anyone can help me with that? 
03:49:36 <Totodile> Heyo
03:50:00 <liste> hi Totodile 
03:52:07 <Totodile> I don't even know how I ended up here.
03:52:21 <obadz> mniip: looks a bit join-esque
03:53:02 * hackagebot hint 0.4.3 - Runtime Haskell interpreter (GHC API wrapper)  https://hackage.haskell.org/package/hint-0.4.3 (mvdan)
03:54:01 <myname_> How would I go about combining monads?
03:55:54 <mpickering> In general, the composition of two monads isn't a monad. However, there are lots you can compose together. Most people do so with monad transformers, which you can find in the transformers package
03:57:21 <myname_> mpickering: I think want to use ReaderT, but it's all really confusing  
03:57:37 <obadz> myname_: always is at the beginning :)
03:57:55 <liste> myname_: http://book.realworldhaskell.org/read/monad-transformers.html may help (RWH is general is old, but that section still applies)
04:01:38 <mniip> obadz, it is and it's also wrong
04:01:44 <mniip> should go the other way
04:01:50 <mniip> duplicate-esque
04:02:10 <obadz> mniip: I don't know what you are trying to do :)
04:04:55 <maybefbi> how can i derive a client to request an endpoint which has two possible JSON responses? is this ok: type API = Get '[JSON] (Either A B) 
04:05:00 <maybefbi> *servant client
04:15:23 <Cooler> how do you make sure cabal build builds into the sandbox?
04:16:08 <liste> Cooler: use --require-sandbox switch
04:16:59 <liste> e.g. "cabal --require-sandbox install --only-dependencies"
04:17:20 <Cooler> no for building not installing
04:17:54 <liste> cabal builds into dist/ folder, not sandbox
04:18:32 <Cooler> why? whats the sandbox for then?
04:18:54 <liste> it's for dependencies
04:19:30 <liste> e.g. you have projects A and B in your hard drive, A depends on text-1.0 and B depends on text-1.1
04:20:44 <hexagoxel> it is for any `install`ing, even the current package.
04:26:44 <hexagoxel> mniip: your type above does not parse.
04:28:17 <hexagoxel> some missing ")"
05:09:00 <myname_> How would I concatenate Monad String and String? (Does that even make sense?)
05:10:24 <liste> myname_: do you mean `Monad m => m String' and `String' ?
05:10:44 <myname_> liste: yes exactly
05:10:52 <liste> > ("hello " ++) <$> readLine
05:10:53 <lambdabot>      Not in scope: ‘readLine’
05:10:53 <lambdabot>      Perhaps you meant one of these:
05:10:53 <lambdabot>        ‘readFile’ (imported from Prelude),
05:11:13 <liste> > ("hello " ++) <$> getLine
05:11:14 <lambdabot>  <IO [Char]>
05:11:14 <liste> I meant
05:11:28 <liste> note that the return type is "Monad m => m String"
05:11:56 <liste> so you're defining a new monadic "action" that runs the old action and concatenates it with a string value
05:13:00 <bernalex> I would use (<>) instead of (++).
05:14:12 <liste> > (++ ", nice to see you!") <$> getLine -- the other way round
05:14:13 <quchen> I think do-notation is clearer than fmap.
05:14:13 <lambdabot>  <IO [Char]>
05:14:46 <liste> > do {name <- getLine; return ("hello " ++ name)} -- in do-notation
05:14:47 <quchen> \str1 -> do { str2 <- stringThing; pure (str1 ++ str2) }
05:14:48 <lambdabot>  <IO [Char]>
05:15:03 <bernalex> I disagree, although I'd use mappend instead of an infix operator.
05:17:09 <liste> is there a variant of `trace' that doesn't output a newline? I'm trying to get a rough count of the number of updates by outputting dots
05:17:20 <myname_> I can't get either to work 
05:17:30 <liste> myname_: please show us how it fails
05:18:17 <myname_> liste: The line is: Just b    -> return (do {name <- getBaseUrl; return (b ++ name)})
05:18:30 <quchen> liste: write your own dirty trace function, I don't think Debug.Trace does this
05:19:11 <myname_> liste: it fails with: Couldn't match type ‘ServerPartT
05:19:11 <myname_>                            (transformers-0.4.2.0:Control.Monad.Trans.Reader.ReaderT
05:19:14 <myname_>                               WikiState IO)
05:19:16 <myname_>                            String’
05:19:20 <quchen> ?where paste
05:19:20 <lambdabot> Haskell pastebin: http://lpaste.net/
05:19:26 <quchen> ^ Use that pastebin :-)
05:19:36 <quchen> I assume the "return" after the "->" is too much.
05:19:55 <myname_> http://lpaste.net/154333
05:20:28 <liste> quchen: something like "dirty s x = (unsafePerformIO (putStr s)) `seq` x; {-# NOINLINE dirty #-}" ?
05:20:49 <quchen> liste: Yeah, something like that.
05:20:51 <liste> (plus NoBuffering)
05:21:24 <quchen> liste: You could also edit Debug.Trace's code to delete the explicit "\n" :-)
05:21:38 <quchen> It's a single module so you can just copy+paste it into your project
05:21:59 <quchen> Although that's probably a bit much for such a dirty hack
05:22:30 <quchen> myname_: What's the "b"?
05:22:39 <quchen> Is it a string, or a list of strings?
05:23:04 <myname_> string
05:23:13 <myname_> i think
05:24:06 <tdammers> this is getting annoying... stack install still seems to hang on some packages, but I can't figure out why or even be certain which ones
05:24:58 <quchen> myname_: Could you paste the full program?
05:25:45 <liste> quchen: thanks, got my dirty trace going
05:25:54 <myname_> The whole program is pretty big (it's gitit). Should I paste the whole file?
05:26:47 <quchen> myname_: Yes please.
05:28:31 <myname_> quchen: Done
05:30:17 <Cooler> need some help with this please
05:30:18 <Cooler> http://lpaste.net/154336
05:32:26 <Shockk> Cooler: what's the problem with it?
05:32:46 <Cooler> i an struggling to figure out how to do set matching
05:32:50 <Cooler> am*
05:35:33 <Cooler> anybody?
05:36:01 <xa0> ?
05:38:26 <opqdonut> Cooler: you'll just need to find the matching ]
05:38:33 <opqdonut> Cooler: of course escaping makes it a bit harder
05:38:51 <opqdonut> Cooler: also, you could consider using an actual parser library instead of writing this out by hand
05:40:01 <Cooler> opqdonut, doesn't that kind of defeat the point? its supposed to be a exercise to learn haskell
05:40:28 <Cooler> theres probably a library that can already more complex regexing
05:40:36 <Cooler> do more*
05:40:47 <opqdonut> sure
05:40:58 <opqdonut> but I'd suggest not supporting escaped ]s for now
05:41:00 <opqdonut> you can handle them later
05:41:46 <Cooler> the problem is ranges in the set matching
05:42:15 <Cooler> like [a-dfb-z]
05:42:18 <opqdonut> I'd write a separate function that parses the contents of the []
05:42:53 <Cooler> yeah thats what i am doing
05:42:57 <opqdonut> that function can probably just pattern match like: f (x:'-':y:rest) = Range x y : f rest
05:44:32 <Shockk> and make sure to match \ before x-y so you escape \-
05:47:44 <Cooler> i was thinking a better way to do this is to remove the escape sequences
05:48:02 <Cooler> replace each escape sequence with the proper character
05:49:11 <Cooler> nvm that doesn't work
05:50:34 <opqdonut> indeed
05:50:57 <opqdonut> but a separate "lexing" pass for the escape characters might be useful
05:51:22 <opqdonut> you could have something like: data Token = Literal Char | RangeStart | RangeEnd | ...
06:17:02 <Cooler> i feel like i am complicating this way too much
06:17:41 <Cooler> http://lpaste.net/154338
06:18:07 * hackagebot stack 1.0.4.2 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.0.4.2 (borsboom)
06:19:08 <Cooler> is this how you are supposed to do this?
06:19:13 <ggVGc> is there builtin for this? map (,) (zip [0..] list)
06:19:33 <c_wraith> ggVGc: err.  What type are you looking for?
06:19:48 <opqdonut> Cooler: that looks ok
06:20:08 <xa0> ggVGc: that map is redundant(?)
06:20:58 <ggVGc> haha, yeah
06:20:59 <ggVGc> sorry
06:21:03 <ggVGc> I was being a bit dumb
06:21:04 <ggVGc> thanks
06:21:11 <opqdonut> Cooler: setbuilder is obviously unfinished, and you could use span instead of takeWhile & dropWhile
06:21:27 <opqdonut> > span (/=']') "abcd]efgh"
06:21:28 <lambdabot>  ("abcd","]efgh")
06:31:40 <ggVGc> I've got this, how do I write it so I don't get Maybes in the result type? Do I have to do another filter? https://gist.github.com/8e787ce8856ef91802ce
06:32:00 <ggVGc> Rather than filtering on isJust I'd like to transform all those values to non-Maybe
06:33:05 <narendraj9> Any datakinds tutorial?
06:33:12 <ClaudiusMaximus> ggVGc: a list comprehension might be cleanest, something like [ (a, b) | (Just a, b) <- ... ]
06:34:00 <narendraj9> Does data Nat = Zero | Succ Nat causes Nat to be a datakind that has Zero and Succ as the types? Thinking of datakinds as sets of types
06:40:13 <merijn> edwardk: wrt my Ptr CChar/ByteString lens question, my raw data would be immutable (so I guess it's not so much a lens as it is a Getter), my main problem was wanting to be able to use code written for/on Text without the cost of repeatedly copying data.
06:40:31 <purelazy> why doesn't fmap work on simple numbers 
06:40:49 <xa0> simple numbers?
06:40:50 <purelazy> > fmap (+1) 1
06:40:50 <edwardk> Text internally will force you to copy a lot of crap around because it uses ByteArrays under the hood which need to be gc managed
06:40:51 <lambdabot>      No instance for (Show (f0 b0))
06:40:52 <lambdabot>        arising from a use of ‘show_M371835205880647143626558’
06:40:52 <lambdabot>      The type variables ‘f0’, ‘b0’ are ambiguous
06:40:55 <quchen> narendraj9: Did you read the GHC user's guide? I think it provides a pretty good introduction to what kinds are generated by -XDataKinds: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
06:41:03 <edwardk> if you were talking about ByteString you'd have a much better chance
06:41:09 <xa0> purelazy: you want ($) not fmap
06:41:19 <xa0> there is no functor there
06:42:15 <Cooler> opqdonut, so i got this far http://lpaste.net/154338
06:42:18 <purelazy> do I have to somehow have to functorise a number to make fmap work?
06:42:31 <quchen> fmap is not something you want to do to numbers.
06:42:39 <xa0> why do you want it to work?
06:42:46 <Cooler> it fails to handle a lot of cases
06:43:06 <purelazy> xa0, quchen: just curious
06:43:07 <Cooler> for example it can't handle \] while setmatching
06:43:26 <merijn> edwardk: Well, I'm not 100% married to Text. But I have unicode binary data that I want to expose to the user without the cost of reallocating/copying all the time. And it seems the only way to do that would be to implement my own Text like primitive and unicode decoding, and that makes me sad, because that sounds like annoying amounts of work >.>
06:43:42 <edwardk> yep
06:43:47 <opqdonut> Cooler: yeah, as I said that's the harder part
06:44:06 <opqdonut> Cooler: one approach is to have a separate lexing step that handles escaping
06:44:10 <edwardk> also Text internally does all sorts of fancy stream fusion stuff
06:44:18 <purelazy> its seems fmap works for everything that contains numbers, but not numbers
06:44:23 <opqdonut> Cooler: the other approach is to handle escaping in setmatch and setbuilder
06:44:25 <tdammers> so I wiped ~/.stack, ./.stack-work, uninstalled stack and reinstalled it from scratch, wiped ~/.ghc and ~/.cabal
06:44:31 <opqdonut> but it's quite a bit of code either way
06:44:33 <purelazy> it seems fmap works for everything that contains numbers, but not numbers
06:44:34 <tdammers> and stack still hangs while installing my projects
06:44:37 <Cooler> opqdonut, after or before doing the normal lexing?
06:44:52 <xa0> purelazy: it requires a functor, or it doesn't really make sense
06:44:55 <edwardk> the benefit of ByteArrays over ForeignPtr solutions is that the memory used is visible to the garbage collector and can be managed
06:45:00 <narendraj9> quchen: Okay. I will do that now. Thanks.
06:45:15 <edwardk> the benefit of ForeignPtr/Ptr solutions is that you can mix with external libraries much more easily
06:45:18 <ggVGc> ClaudiusMaximus: yeah, that's great, thanks!
06:45:22 <tdammers> the peculiar thing is that it doesn't seem to depend on the project I'm compiling; several ones fail, on different dependencies, and even older versions that used to compile just fine no longer do
06:45:26 <xa0> > fmap (+1) [1]
06:45:28 <lambdabot>  [2]
06:45:29 <merijn> edwardk: I was hoping that with those utf8 lenses I could get away with only selectively copying small bits of data to feed as input to code
06:45:32 <ggVGc> never occured to me to use pattern matching in a list comprehension..
06:45:34 <xa0> > fmap (+1) $ Just 1
06:45:35 <purelazy> xa0: why aren't number Functors?
06:45:35 <lambdabot>  Just 2
06:45:35 <ggVGc> but yeah, that makes compete sense
06:45:45 <tdammers> I'm kind of lost as to what else I could tr
06:45:47 <tdammers> y
06:45:57 <purelazy> xa0: why aren't numbers Functors?
06:46:01 <merijn> edwardk: I'm working with mmap'ed stuff, so whether I make it a ForeignPtr or something else seems kinda arbitrary
06:46:05 <edwardk> merijn: i suspect every solution here will suck for different reasons
06:46:08 <opqdonut> Cooler: as part of lexing. take in 'a\[b[x\]y]' and output something like [Lit 'a', Lit '[', Lit 'b', StartSet, Lit 'x', Lit ']', Lit 'y', EndSet] and then parse that
06:46:19 <edwardk> i mmap into ByteStrings fairly regularly
06:46:27 <xa0> purelazy: i don't know how to sensibly answer that
06:46:46 <merijn> edwardk: Yeah, sure, but then you still need a way to operate on ByteString as unicode data :)
06:47:03 <edwardk> but you can't really mmap into a ByteArray, since they get moved all over by the RTS
06:47:11 <purelazy> if almost anything can be a functor, why not numbers
06:47:22 <opqdonut> Cooler: on the other hand since the syntax inside the set is different than the syntax outside, it might not make sense to do this
06:47:35 <quchen> purelazy: "Mapping over things that contain numbers" has something to do with Functor, and is completely independent of the fact that you've used numbers while experimenting.
06:47:57 <xa0> purelazy: do you understand what a functor is?
06:48:10 <Cooler> opqdonut, yeah well that does seem like it would make things easier
06:48:15 <Cooler> or atleast look nicer
06:48:26 <purelazy> xa0: Sometihng to can apply a function to
06:48:47 <quchen> purelazy: Similarly, you can map string functions over "things with strings in their types", but that doesn't mean Functor has something to do with strings.
06:48:49 <xa0> i think that definition is what's screwing you
06:48:54 <hexagoxel> tdammers: what do the logs say? what exactly hangs?
06:49:01 <kqr> is Monoid.mempty and Alternative.empty always the same thing?
06:49:10 <kqr> (for things that are both monoids and alternatives, obviously)
06:49:14 <merijn> kqr: No, that doesn't even make sense
06:49:19 <tdammers> stack install -v hangs after installing a bunch of dependencies
06:49:24 <tdammers> last line looks something like:
06:49:27 <quchen> purelazy: Are you coming from a C++ background by any chance? Because C++ functors are something entirely different than in Haskell.
06:49:29 <merijn> kqr: The kinds are wrong
06:49:34 <tdammers> 2016-03-09 15:24:35.415129: [info] primitive-0.6.1.0: download @(stack_COhPD0SUWBs7s1VUFLBNcf:Stack.Fetch src/Stack/Fetch.hs:456:38)
06:49:59 <tdammers> it's always the same dependency for the same project, but different dependencies for different projects
06:50:04 <kqr> merijn, i'm probably missing something, but in the case of lists, empty = mempty = [], and in the case of maybe, empty = mempty = Nothing, right?
06:50:07 <merijn> kqr: Alternative.empty for Maybe would be "Nothing", while you could argue that "Monoid.mempty" SHOULD be "Just mempty"
06:50:08 <xa0> purelazy: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
06:50:08 <tdammers> and previous incantations of that line seem to work fine
06:50:13 <Shockk> kqr: mempty :: a, Alternative.empty :: f a
06:50:23 <kqr> hm
06:50:26 <purelazy> xa0: "i think that definition is what's screwing you" - You could be right
06:50:29 <merijn> kqr: That's because the Monoid for Maybe is bad
06:50:54 <merijn> kqr: Think of parsers, "empty :: Parser a" is just a failing parser, which is presumably not the monoid you want for a Parser
06:51:29 <kqr> !
06:51:32 <kqr> that's a really good example
06:51:34 <kqr> thanks
06:51:35 <merijn> (For example, attoparsec uses the sensible "mempty = pure mempty; mappend = liftA2 mappend"
06:52:13 <kqr> this is actually something that's been lurking in my mind for way too long
06:52:14 <xa0> purelazy: or perhaps, not to confuse you further, but you may be interested in the identity functor
06:52:19 <kqr> now I'll just have to build intuition for it
06:52:22 <xa0> > fmap (+1) $ Identity 1
06:52:23 <lambdabot>  Identity 2
06:52:55 <purelazy> xa0: I probably have no idea what a functor is
06:53:24 <xa0> that link will go some way to giving you an idea
06:53:29 <purelazy> xa0: Do you have a link to somewhere that can enlighten me?
06:53:37 <xa0> purelazy: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
06:53:49 <kqr> i often come across situations where I'd like to provide some sort of null-ish default value, and I'm always reaching for monoid.mempty before realising what I probably want is alternative.empty
06:54:14 <kqr> I gotta build intuition for the concept that an identity element does not necessarily mean a null-like element
06:54:17 <latro`a> purelazy, the vague answer is that it's a type constructor taking one parameter, which allows you to "apply functions" to its "contents"
06:54:30 <latro`a> eh, the first set of scare quotes shouldn't be there
06:54:48 <purelazy> xa0: thank you
06:55:01 <latro`a> the rule fmap id = id ensures that fmap itself can't change the structure (for instance it can't change the length of a list)
06:55:07 <xa0> np
07:18:39 <mick_> where does the liftM function live?
07:18:52 <mick_> do I need to import a package
07:19:46 <myname_> Control.Monad
07:21:16 <c_wraith> mick_: Note that in recent versions of GHC (7.10 and newer) it does the exact same thing as fmap and (<$>), which are both exported by Prelude
07:21:27 <c_wraith> mick_: (and therefore don't need an import)
07:21:33 <mick_> thanks mate!
07:23:53 <c_wraith> Hey, I got no bites on my code review request on stack exchange a while back, so I figured it might be time to throw it in here and see if anyone here is more helpful than all of codereview.stackexchange (which is quite likely)  http://codereview.stackexchange.com/questions/121909/code-generation-with-template-haskell
07:24:45 <obadz> is `read <$> many1 digit´ the best way to write Parser :: Int (for positive numbers) ?
07:25:29 <c_wraith> obadz: Probably not, just because read isn't all that efficient.
07:26:32 <roelof> Is it easy to setup a haskell development in Docker. So stack and for example Sublime Text or Atom ? 
07:27:51 <punkcoder> Is this one of the best resources to learn haskell?
07:27:53 <punkcoder> "Write Yourself a Scheme in 48 Hours
07:28:57 <obadz> c_wraith: so better to write atoi myself?
07:29:13 <c_wraith> punkcoder: it's a very good exercise if you want a project to do to use the basics to do something interesting.  It's not the best intro for learning those basics
07:29:36 <c_wraith> obadz: depends.  Which Parser type are you using?
07:29:51 <obadz> c_wraith: Text.Parsec.String
07:30:37 <Aruro> ls
07:30:37 <roelof> punkcoder: I find the Haskell book written by bitemyapp the best book to learn haskell 
07:31:00 <c_wraith> obadz: Hmm.  I know people have written very solid numeric parsers..  what's the package I'm thinking of..  scientific?
07:32:48 <c_wraith> Hmm, no, it's not scientific.  I don't remember what it was.  I just know people have done atoi in haskell before.
07:32:59 <punkcoder> c_wrait , iread the six chapters of learn you haskell but it is slowly na d i get bored, and i read in a forum it would be a good idea to jump to "Write Yourself a Scheme in 48 Hours" , if i read the beggining of the book lyh
07:34:22 <liste> obadz: there's a bunch of number parsers in Numeric (@base)
07:34:42 <liste> obadz: http://haddock.stackage.org/lts-5.6/base-4.8.2.0/Numeric.html#v:readInt
07:35:37 <obadz> liste: any reason to think that's going to be better than read?
07:36:21 <liste> obadz: it offers more control, at least. don't know about performance
07:36:27 <c_wraith> punkcoder: I don't think LYAH is all that great either.  But if you've gone through that much, you can probably handle the scheme implementation.
07:36:44 <obadz> anyway I was not really too concerned about perf
07:36:53 <obadz> I'm just uneasy about read being a partial function
07:37:20 <c_wraith> obadz: well, in your initial implementation, it won't ever get input it fails on.
07:37:29 <c_wraith> obadz: so it's fine to pretend it's total. :)
07:37:40 <obadz> c_wraith: right, that's why I wrote it that way..
07:38:24 <Moggle1> I'm investigating a space leak in my program, and after profiling I've discovered that "MAIN" seems to be taking up most of the memory. Is this the main function, and if it is why is it not lowercase like every other function?
07:38:28 <dramforever> punkcoder: yeah it's a neat beginners' project :) just make sure when you find something you don't understand, you get into and learn it, instead of quitting with a remark "Haskell is hard" :)
07:41:07 <obadz> I suppose if I was paranoid I could also: (\ s -> maybe (fail "Failed to read Int") return (readMaybe s)) =<< many1 digit
07:43:10 <obadz> > read $ take 1000 $ repeat '1' :: Int
07:43:12 <lambdabot>  8198552921648689607
07:43:21 <obadz> that's a bit annoying..
07:43:59 <dramforever> Integer if you want
07:44:11 <dramforever> let me see...
07:45:01 <liste> > maxBound :: Int
07:45:03 <lambdabot>  9223372036854775807
07:45:26 <c_wraith> obadz: it's the only reason read :: String -> Int isn't partial when the input consists only of digits
07:45:55 <dramforever> > let x = 2^90 :: Integer in (if x > fromIntegral (maxBound :: Int) then error "ouch" else fromInteger x) :: Integer
07:45:57 <lambdabot>  *Exception: ouch
07:46:05 <c_wraith> I guess I could pretend this is GHC 8 and write that as read@Int now
07:47:57 <dramforever> :t fromInt -- Please!
07:47:58 <lambdabot>     Not in scope: ‘fromInt’
07:47:59 <lambdabot>     Perhaps you meant one of these:
07:47:59 <lambdabot>       ‘fromRat’ (imported from Numeric),
07:48:05 <dramforever> :(
07:48:38 <greg`> :t fromIntegral
07:48:39 <lambdabot> (Integral a, Num b) => a -> b
07:49:00 <dramforever> Yeah, but see use case above
07:49:26 <obadz> c_wraith: not sure that's an advantage ;-)
07:49:35 <obadz> c_wraith: I assume it's more of a performance consideration
07:50:17 <roelof> Is it easy to setup a haskell development in Docker. So stack and for example Sublime Text or Atom ? 
07:51:19 <obadz> does Parsec become more inefficient when I use try, or is it always inefficient because it supports try?
07:52:25 <dramforever> obadz: If efficiency matters you probably shouldn't be using parsec
07:52:31 <obadz> for instance if I have a l :: Parser Line and want to write Parser [Line] = sepBy l eol >> eof, will I be able to Parse very large files efficiently?
07:52:43 <dramforever> you'd want smth like attoparsec
07:54:35 <obadz> I thought Parsec 3 was getting closer?
07:55:33 <obadz> I meant more memory effiency rather than speed anyway
07:56:31 <dramforever> obadz: in that case the parser would retain the whole list in memory until it finishes
07:56:44 <dramforever> because otherwise it can't fail
07:57:00 <obadz> that's true of both, right?
07:57:12 <dramforever> yep afaik
07:58:15 <obadz> I guess one can use unlines and map over the parser to prevent that from happening..
07:58:18 <dramforever> obadz: I think you can just read in each line and parse each individually
07:58:31 <dramforever> oh yeah right :)
07:58:56 <dramforever> :t lines -- i think you mean lines not unlines
07:58:57 <lambdabot> String -> [String]
07:59:13 <obadz> yeah yeah.. :)
07:59:50 <LysergicDreams> Is there something that will let me save diffs or revisions of Persistent model instances? Something I could use as a history/auditlog/revert mechanism?
08:06:57 <mick_> Guys, I'm going around in circles at the monad with my Haskell code. I need help. I did ask before but I'm still confused.
08:07:01 <mick_> Here is the code:
08:07:05 <mick_> :lpaste
08:07:09 <mick_> createGenerator :: PrimMonad m => m (Gen (PrimState m))                                              | createGenerator = do                                                                                 |   gen <- create                                                                                      |   return gen                                                                                         |                                      
08:07:20 <liste> @lpaste -- mick_
08:07:20 <lambdabot> Haskell pastebin: http://lpaste.net/
08:07:22 <mick_> ignore the vertical bars on the left
08:07:38 <LysergicDreams> but not the ones on the right?
08:07:46 <mick_> http://lpaste.net/154342
08:08:07 <mick_> I get this error:
08:08:19 <mick_> Couldn't match expected type ‘Double’ with actual type ‘m0 Double’
08:08:32 <mick_> I just want the first random number to pop out
08:08:42 <liste> mick_: returnPRNG can't have that type signature
08:09:04 <mick_> what do i need to change so I can get a double out
08:09:09 <mick_> which is the first random number
08:09:30 <liste> it'd need to be "PrimMonad m => Int -> Int -> m Double"
08:09:40 <mick_> let try that
08:10:19 <liste> and then you need another do block (or <$> or >>= if you're familiar with those)
08:10:37 <mick_> I get this now: Couldn't match type ‘PrimState m’ with ‘Gen (PrimState Gen)’
08:10:38 <haskell198> @pl f d = (,d) <$> foo d
08:10:38 <lambdabot> (line 1, column 6):
08:10:38 <lambdabot> unexpected " "
08:10:38 <lambdabot> expecting operator
08:10:44 <mick_> Couldn't match type ‘PrimState m’ with ‘Gen (PrimState Gen)’
08:10:59 <haskell198> @pl f d = (,) <$> foo d <*> pure d
08:11:00 <lambdabot> f = ((,) <$>) . liftM2 (<*>) foo pure
08:16:17 <dramforever> @pl f d = liftA2 (foo d) (pure d)
08:16:17 <lambdabot> f = liftM2 liftA2 foo pure
08:16:42 <djbeau> obadz: I have been trying to use pipes-parse (and other related libraries such as pipes-test) as of late, but it still feels a bit awkward
08:16:49 <dramforever> haskell198: looks like @pl doesn't understand applicative operators well enough
08:16:54 <djbeau> I can't quite put my finger on why
08:17:26 <dramforever> ouch sorry I take it back
08:17:50 <obadz> djbeau: are they meant to disallow failures/backtracking?
08:19:35 <djbeau> it specifically allows for re-queuing leftovers, but that may not be exactly the same thing as backtracking
08:19:43 <djbeau> or maybe it's a more manual approach
08:19:53 <dramforever> @pl f d = liftM2 (,) (foo d) (return d)
08:19:53 <lambdabot> f = ap (liftM2 (,) . foo) return
08:20:02 <dramforever> @pl f d = liftA2 (,) (foo d) (pure d)
08:20:02 <lambdabot> f = ap (liftA2 (,) . foo) pure
08:21:21 <LysergicDreams> mick_: You probably want something like `do { gen <- create; x :: Int <- uniform gen; y :: Int <- uniform gen; return (x, y) }
08:21:52 <djbeau> there may be some concept in all of this that I am not fully grasping yet
08:23:22 <LysergicDreams> mick_: (do { gen <- create; return gen }) === create
08:24:09 <liste> note that you need ScopedTypeVariables for x :: Int <- uniform gen
08:24:09 <obadz> interesting
08:24:31 <djbeau> obadz: I think the attractiveness of parsec, attoparsec and the like is the ease of which one can use 'try' or alternatives (<|>) - I haven't found the same thing in pipes-parse and I am not sure if I am just missing something or if it is simply not possible due to design
08:41:42 <Normen> New to Haskell & Stack, want to "stack new <projectname> <template>" w/o an internet connection but get failed internet connection while stack tries to download <template>. I already created a project w/ stack, so the template is already there. Is there an option to run stack in offline mode?
09:13:48 <quchen> Normen: Hmm, there's no option like that. But you can just copy your old project and edit the files, there's no magic in stack new
09:14:22 <quchen> Normen: It's really just filling a default directory with a foo.cabal and stack.yaml
09:22:41 <njksdf> Hi, when is ghc 8.0 expected and will it include records?
09:22:59 <hiptobecubic> haskell already has records
09:23:08 <hiptobecubic> if you mean overloaded records, then i think yes
09:26:15 <quchen> njksdf: You can view the user's guide of master here: https://downloads.haskell.org/~ghc/master/users-guide/8.0.1-notes.html
09:26:20 <bitonic> is there a function that splits a `String` containing args as if they were the arguments of `:main`? E.g. I'd go from `"foo \"bar rab\" baz"` to `["foo", "bar rab", "baz"]
09:27:11 <deni> is there a better way of doing "insert if not exists" than this: http://dpaste.com/0JY6S8E (using persitent and postgresql)
09:27:13 <deni> ?
09:27:27 <quchen> deni: No standard function, but you could write a parser to do this yourself :-)
09:27:32 <xa0> i think that's nontrivial enough that it wouldn't be a builtin, bitonic 
09:27:37 <ph88^> deni, isn't that upsert ?
09:27:50 <bitonic> xa0: I'm not asking for a builtin, any library, piece of code is fine
09:27:54 <deni> quchen: I did see mention of upsert beinng added for persiste-postgresql but I can't find how to use it....
09:27:57 <deni> has it been removed?
09:28:09 <xa0> none that i know of, then
09:28:14 <quchen> deni: Oh, I meant to tell that to bitonic, sorry
09:28:36 <bitonic> quchen: well, I'd rather not write a parser myself :)
09:28:58 <deni> ph88^: that is upsert yes...but like I said I saw it being added and can't find it any more
09:29:09 <xa0> it wouldn't be as hard as you might think!
09:29:12 <jle`> parsers are super easy to write in haskell :3
09:29:18 <jle`> it's the 'killer app', as they say
09:30:28 <ph88^> deni, uf ok i don't think i would have stronger google skills
09:30:40 <deni> ph88^: It's ungooglable :D
09:30:44 <ph88^> :(
09:30:50 <ph88^> try  with  site:blabla
09:30:51 <deni> ph88^: I was hoping that somebody knows some backstory here
09:30:56 <ph88^> maybe search on hackage that way
09:31:11 <ph88^> jle`, do you know if i can download grammars ?
09:32:04 <jle`> curl grammer.grm ?
09:32:11 <ph88^> ha ?
09:32:18 <deni> cause I might be crazy but I do seem to recall michael posting something about removing something because something....my memory sucks
09:32:38 <jle`> download in what sense?
09:33:08 <ph88^> jle`, like this https://github.com/antlr/grammars-v4  but then for a haskell parser
09:33:08 <deni> ph88^: and the docs on hackage are rebuilding currently so I can't access them
09:33:15 <deni> I need to learn how to have offline docs
09:33:30 <ph88^> for sure
09:33:35 <ph88^> i use httrack a lot
09:37:35 <quchen> bitonic: Writing parsers can be quite a bit of fun in Haskell, I really like doing it. I don't know any pre-defined function that does what you want, so it seems like this is your only option.
09:37:51 <bitonic> quchen: I think I'm past that phase ehe. I found this http://haddock.stackage.org/lts-5.6/debian-3.89/src/Debian-Sources.html#quoteWords
09:38:19 <quchen> I'm past that phase as well, but I re-enter it on a regular basis :-D
09:39:45 <deni> bitonic: https://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text.html#v:splitOn
09:39:50 <deni> if you use Text instead of String
09:40:01 <deni> and it's easy enough to convert between the 2
09:40:09 <bitonic> deni: that doesn't do what I want
09:41:59 <deni> bitonic: that's true...my bad
09:42:00 <ph88^> jle`, what about building a parser to convert grammar definitions ?
09:42:11 <bitonic> deni: no problems :)
09:42:32 <deni> but in general i found that Text is much richer with these kinds of functions...perhaps you can figure something out
09:42:39 <deni> either that or yeah writing a parser
09:42:52 <bitonic> I already found and modified that `quoteWords` to my needs
09:43:03 <bitonic> Seems to work
09:44:48 <deni> cool
09:44:51 <deni> ph88^: http://www.yesodweb.com/blog/2014/08/announcing-persistent-2
09:45:01 <deni> "added an upsert operation (update or insert)"
09:45:06 <deni> but where??? :D
09:48:14 * hackagebot slack-api 0.7 - Bindings to the Slack RTM API.  https://hackage.haskell.org/package/slack-api-0.7 (mpickering)
09:49:10 <ph88^> deni, maybe it's an easter egg in the binary
09:52:18 <deni> ph88^: it seems that insertBy does what I want it to
09:52:24 <deni> perhaps upsert got renamed to that or something
09:52:33 <ph88^> weird
09:52:40 <deni> so this works boardId <- insertBy $ Board "Default Board"
09:52:59 <deni> however I have to have UniqueName name constraint
10:31:12 <rtok> i am familiar with imperative C, but not familiar with functional Haskell
10:31:57 <rtok> i like the impression i have of Haskell, but i'd like more than an impression to persuade me, i'd like to understand technically why i'd learn Haskell
10:32:29 <rtok> can a body help me in brief message?
10:32:46 <Rembane> rtok: It will make you think in new and more powerful ways.
10:35:55 <rtok> Rembane: do you have a very to the point and well explained text i can read to understand it and/or get comfortable with Haskell?
10:36:39 <Rembane> rtok: No, it's a huge subject.
10:36:44 <Rembane> rtok: This is a start though: https://github.com/bitemyapp/learnhaskell
10:37:28 <titusg> honestly cabal is fucking frustrating
10:37:38 <Rembane> It is indeed.
10:37:46 <mnoonan> stack will make all your dreams come true
10:38:08 <dcoutts> similarly for those currently beta testing the next gen cabal
10:38:33 <titusg> can I install xmonad etc via stack? It seems just for dev tasks
10:39:22 <Rembane> titusg: Have you tried installing it with your distribution's package manager?
10:40:36 <monochrom> stack is certainly geared towards devs
10:40:39 <titusg> yep, but I can't compile new xmonad.hs
10:41:58 <geekosaur> stack exec -- xmonad --recompile
10:44:38 <Cooler> opqdonut, thanks for the help
10:44:44 <Cooler> i think this works now http://lpaste.net/1845005606902038528
10:45:19 <Cooler> adding a lexing step to convert the pattern to a simpler syntax helps a lot
10:46:07 <jackhill> :t (>>>)
10:46:08 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
10:47:07 <jackhill> that type seems to have gotten more complicated as well. How do I interpret (cat :: k -> k -> *)? How is k :: BOX different than k :: * ?
10:49:20 <titusg> @mnoonan it certainly hasn't so far
10:49:20 <lambdabot> Unknown command, try @list
10:49:39 <titusg> Failure when adding dependencies:  X11-xft: needed (>=0.2), not present in build plan (latest is 0.3.1) needed for package: xmonad-contrib-0.12
10:50:09 <mnoonan> "stack solver" might help
10:50:42 <opqdonut> Cooler: great, that looks nice
10:51:14 <Cooler> opqdonut, oops forgot to parse *
10:52:41 <runeks> If I have a type, data CoolType = CoolType String String, for which the serialization format is well-defined, will the serialization format of (String -> CoolType) also be well-defined? Ie. CoolType only applied to a single String.
10:52:43 <titusg> mnoonan: that wants me to create <pkgname>.cabal, but I'm trying to install xmonad as an application 
10:53:57 <dcoutts> titusg: so it should work to do: cabal sandbox init; cabal install xmonad [--dry-run] 
10:54:28 <dcoutts> titusg: it puts the binary into the sandbox to by default, but you can copy it elsewhere
10:56:00 <titusg> dcoutts: tx will try
10:56:10 <rtok> what's the difference between a compiled Haskell program and a compiled C program? does the Haskell executable encapsulate expressions which are evaluated?
10:56:30 <dcoutts> rtok: with ghc, not that much difference actually
10:56:46 <dcoutts> it's not doing runtime interpretation
10:57:31 <dcoutts> rtok: of course the effect is evaluation of expressions, but if you're interesting in what it's doing at a low level then it's closer to C than say to python
10:57:43 <dcoutts> interesting/interested
10:57:58 <rtok> dcoutts: thanks for clearing that up
10:59:55 <dcoutts> rtok: there's a paper on STG to explain how it works, it explains how to translate functional evaluation into what CPUs do efficiently
10:59:59 <rtok> how is a function in Haskell different to a function in C?
11:00:03 <adarqui> hey, anyone have a sec that can help me get rid of these params and make this point free? runClientGetNsTriggers ns = fixResult <$> runEitherT (clientGetNsTriggers ns) ... can't figure it out
11:00:23 <mauke> rtok: heh. what do they have in common? :-)
11:00:52 <rtok> mauke: they take input and produce output?
11:01:09 <mauke> rtok: void foo(void);
11:01:21 <rtok> mauke: they are a list of instructions?
11:01:26 <monochrom> rtok: I wonder if this helps: https://github.com/takenobu-hs/haskell-ghc-illustrated
11:01:29 <mauke> that's exactly not what haskell functions are
11:01:40 <kadoban> rtok: A function in haskell is more like a mathematical function. A function in C isn't really a function, it's a procedure. Its output depends on things other than the input(s) to the function.
11:01:53 <mauke> a C function is a labelled block of statements
11:03:01 <rtok> mauke: kadoban: that's very great clarification, thanks
11:03:51 <monochrom> I have a feeling that, due to the context, the question means: "when GHC compiles a Haskell function to machine code, and gcc compiles a C function to machine code, (nevermind they stand for different things), how do the two pieces of machine code compare?"
11:04:51 <xa0> haskell machine code is magic. doesn't resemble the original source
11:05:31 <dolio> Does compiled C code resemble the original source?
11:05:49 <mauke> yes, in some way
11:05:51 <xa0> at least vaguely.
11:05:59 <dcoutts> no, but more so than Haskell
11:06:02 <mauke> especially if you switch off optimizations
11:06:08 <xa0> yes. definitely
11:06:09 <shachaf> Compiled Haskell also resembles the source at least vaguely.
11:06:48 <monochrom> on this subject people have already made up their mind what they believe
11:08:55 <dolio> The more optimizations you switch off, the more the compiled Haskell code will also resemble the original code, of course.
11:09:31 <dolio> It isn't too difficult to learn to read Haskell in the way that the machine code ends up, either.
11:09:55 <monochrom> we're really better off "arguing" over "is Obama really that tall?" than this.
11:09:56 <dolio> There are operational meanings for the various constructs given in the STG paper.
11:10:18 <dolio> Because STG is pretty similar to Haskell.
11:10:37 <maerwald> let's write an immutable filesystem in haskell!
11:10:58 <mauke> oleg has done that
11:11:02 <mauke> zipperfs
11:11:06 <maerwald> omg xD
11:11:07 <maerwald> link
11:11:30 <mauke> http://okmij.org/ftp/continuations/zipper.html#zipper-fs
11:11:45 <maerwald> that man is crazy :D
11:12:11 <broma0> how is a multi-param type like "M a b" modeled in ghc's types? I need to generate one with template haskell, and i'll ive found is "appT :: TypeQ -> TypeQ -> TypeQ" for a single-param type like "M a"
11:12:14 <maerwald> when you think about something impossible, either oleg or edward have it implemented :D
11:12:42 <mauke> broma0: (M a) b
11:15:04 <monochrom> which is to say, (M `appT` a) `appT` b, in a sense
11:15:09 <broma0> mauke: perfect
11:15:52 <broma0> monochrom: thank you
11:20:21 <rtok> a
11:20:22 <rtok>  
11:20:40 <rtok> s/a//
11:28:20 <Cooler> what function takes 2 strings and searches the 2nd string until it finds a character in the 1st one
11:28:30 <Cooler> ?
11:29:15 <xa0> and returns what
11:29:34 <johnw> any (\x -> x `elem` string1) string2?
11:29:44 <johnw> or any (`elem` string1) string2?
11:31:42 <Athas> Is there something like the process package, but with the result as a ByteString or Text?
11:33:13 <Athas> Hm: https://hackage.haskell.org/package/process-extras
11:33:19 <Athas> It even appears maintained.
11:34:06 <Cooler> a function of type  String -> String -> Something
11:34:43 <Cooler> a function of type  String -> String -> String
11:35:02 <Cooler> it should return the suffix after you find the character
11:35:43 <Cooler> f "abc" ['a'..'z'] == ['d'..'z'] for example
11:36:28 <bennofs> Cooler: what would f "cab" ['a'..'z'] be?
11:37:06 <Cooler> f "4$#" "1123$1231244122" == "1231244122" for example
11:37:13 <rtok>  
11:37:13 <rtok> /unrelated, there was a word of note used in a
11:37:28 <rtok> nvm, i erroneously did that
11:37:48 <rtok> http://pastebin.com/dyPJx7fb
11:38:11 <rtok> i'd appreciate feedback?
11:38:12 <bennofs> Cooler: but then f "abc" ['a'..'z'] = ['b'..'z'], no?
11:38:53 <xa0> i think he wants some sort of lstrip?
11:39:18 <Cooler> bennofs, oh yeah your right
11:39:28 <xa0> or not
11:39:29 <Cooler> is there such a function?
11:40:00 <Cooler> i found dropWhile which might work given the correct predicate
11:40:03 <rtok> if i do understand that paste, then i think i understand the neatness of replacing a loop with that
11:40:22 <kadoban> rtok: That looks like one possible answer, sure.
11:41:03 <bennofs> :t \chars -> drop 1 . dropWhile (\char -> not (char `elem` chars)) -- should work Cooler 
11:41:04 <lambdabot> (Eq a, Foldable t) => t a -> [a] -> [a]
11:41:14 <xa0> :t \xs -> tail . dropWhile . not . (`elem` xs)
11:41:15 <lambdabot>     Couldn't match type ‘[a0] -> [a0]’ with ‘[a1]’
11:41:15 <lambdabot>     Expected type: (a0 -> Bool) -> [a1]
11:41:15 <lambdabot>       Actual type: (a0 -> Bool) -> [a0] -> [a0]
11:41:21 <xa0> oops
11:41:36 <kadoban> rtok: There's improvements that could be made in a couple of directions, but I think your goal is more to just understand how functions work than anything, so I don't think any of them would really be super helpful in that regard.
11:41:48 <xa0> there's about three things wrong there, actually >_> what bennofs said
11:44:04 <rtok> kadoban: yes i am just trying to understand, but feel free to say anything
11:45:13 <Cooler> xa0, i don't know about using tail with dropwhile
11:45:23 <kadoban> Well, I mean there's a closed-form solution to the sum of 1 to n  (n * (n + 1) / 2). There's also ways to sum up numbers in haskell without writing a recursive function (which is helpful because it's less error-prone and less verbose)
11:45:25 <Cooler> tail produces an error if the list is empty
11:45:48 <kadoban> > sum [1..5] -- for instance
11:45:50 <lambdabot>  15
11:45:50 <xa0> hadn't even considered that..
11:47:23 <Cooler> also both your functions take only one argument?
11:47:28 <Cooler> it needs to take 2 strings
11:47:42 <Cooler> one set to search with and a string to search inside
11:48:42 <bennofs> Cooler: my version uses drop 1 which returns an empty list if the argument is empty
11:49:07 <bennofs> Cooler: my function takes two arguments, look at the type
11:49:09 <bennofs> :t \chars -> drop 1 . dropWhile (\char -> not (char `elem` chars)) -- should work Cooler 
11:49:10 <lambdabot> (Eq a, Foldable t) => t a -> [a] -> [a]
11:49:22 <bennofs> :t \chars -> drop 1 . dropWhile (\char -> not (char `elem` chars)) -- should work Cooler 
11:49:24 <lambdabot> (Eq a, Foldable t) => t a -> [a] -> [a]
11:49:30 <bennofs> :t \(chars :: [a]) -> drop 1 . dropWhile (\char -> not (char `elem` chars))
11:49:31 <lambdabot> Eq a => [a] -> [a] -> [a]
11:50:01 <xa0> yeah
11:50:05 <xa0> pretend i said that
11:50:12 <parsecChar> i'm building a haskell -> javascript translator; what is a word that is like 'translate' but shorter ?
11:50:18 <xa0> port
11:50:30 <mauke> parsecChar: compile
11:50:54 <parsecChar> compile is still 7 chars
11:50:59 <parsecChar> maybe somehting 2-3 chars?
11:51:03 <parsecChar> compileExpr not as nice as xyzExpr
11:51:18 <parsecChar> I'm going to use "cc" as a shorthand for compile
11:51:21 <mauke> expr2JS
11:51:46 <Cooler> bennofs, thats weird
11:51:56 <Cooler> how does \chars -> take 2 arguements?
11:52:13 <bennofs> Cooler: the lambda returns a function
11:52:29 <bennofs> Cooler: drop 1 . dropWhile (\char -> ...) is a function
11:54:14 <samba1_> I ran stack image container, and it seemed to build everything and exit successfully, but there's no new image in either my working directory or dockers images dir and docker images shows nothing new - what did it do? How can I get that image so I can use it?
11:55:39 <Cooler> bennofs, wait your using a dropWhile inside the predicate?
11:55:51 <bennofs> Cooler: no
11:55:52 <johnw> samba1_: there is also #haskell-stack, they might know
11:56:32 <samba1_> johnw: thanks I thought I looked there and saw it empty but I maybe didnt have the dash
11:58:59 <xa0> :t \(chars :: [a]) -> drop 1 . dropWhile (\char -> not (char `elem` chars))
11:59:00 <lambdabot> Eq a => [a] -> [a] -> [a]
11:59:14 <xa0> :t \(chars :: [a]) -> drop 1 . dropWhile (not . (`elem` chars))
11:59:15 <lambdabot> Eq a => [a] -> [a] -> [a]
11:59:29 <xa0> yeah, that's what i was originally going for
11:59:39 <xa0> but i missed a lot of brackets and didn't use drop
12:00:28 <shachaf> :t notElem
12:00:30 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
12:00:39 <xa0> interesting
12:01:46 <xa0> :t \(chars :: [a]) -> drop 1 . dropWhile . (`notElem` chars)
12:01:47 <lambdabot>     Couldn't match type ‘[a0] -> [a0]’ with ‘[a1]’
12:01:47 <lambdabot>     Expected type: (a0 -> Bool) -> [a1]
12:01:47 <lambdabot>       Actual type: (a0 -> Bool) -> [a0] -> [a0]
12:01:52 <xa0> er
12:01:55 <xa0> :t \(chars :: [a]) -> drop 1 . dropWhile (`notElem` chars)
12:01:56 <lambdabot> Eq a => [a] -> [a] -> [a]
12:06:03 <parsecChar_> https://gist.github.com/anonymous/1817d705e351da4253d4 -- is there a way to tell ghc, when called like this, to put the *.o and *.hi files elsewhere (i.e. not in place) ?
12:06:19 <xa0> i really want to make that into a not-lambda
12:06:25 <xa0> but I don't think you can
12:08:05 <bollu> what happens when I rename a package?
12:08:16 <bollu> like, if I try to upload it to Hackage after renaming it?
12:08:18 * hackagebot uniform-pair 0.1.11 - Uniform pairs with class instances  https://hackage.haskell.org/package/uniform-pair-0.1.11 (ConalElliott)
12:08:39 <Cooler> how do you have several wheres?
12:08:40 <Cooler> http://lpaste.net/1845005606902038528
12:08:47 <Cooler> line 44
12:08:54 <Cooler> 43-45
12:09:10 <bennofs> :t (drop 1 .) . dropWhile . flip notElem -- xa0 you can, but it is ugly (alternatively, you can also write fmap (drop 1) . dropWhile . flip notElem)
12:09:11 <lambdabot> (Eq a, Foldable t) => t a -> [a] -> [a]
12:09:28 <bollu> what happens if I rename a package and upload it to Hackage?
12:09:31 <xa0> ah
12:09:39 <bennofs> Cooler: just remove the 2nd and 3rd 'where'
12:09:42 <bennofs> Cooler: and repace it by space
12:09:52 <xa0> the legendary (.).(.) operator
12:10:09 <bennofs> Cooler: such that the 's' from 'set' is directly under the 'x' from 'xonwards' and so on
12:10:51 <newsham> ?type let c = (.) in c c c
12:10:53 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:11:13 <geekosaur> parsecChar, DynFlags has objectDir and hiDir fields
12:11:30 <parsecChar> geekosaur: ah, that should do it
12:11:32 <geekosaur> (you would modify dflags in your snippet)
12:16:11 <Cooler> bennofs, http://lpaste.net/1845005606902038528
12:16:15 <Cooler> line 43
12:16:39 <Cooler> what exactly do you do there
12:17:04 <bennofs> Cooler: that does look correct. do you use tabs?
12:20:24 <Cooler> bennofs, no the indentation is correct, the predicate for dropWhile was wrong
12:20:44 <Cooler> bennofs, http://lpaste.net/1845005606902038528
12:20:53 <Cooler> this works, but am i over complicating this
12:20:53 <Cooler> ?
12:24:47 <Cooler> i am not sure if this is supposed to be this complex
12:24:52 <Cooler> http://lpaste.net/1845005606902038528
12:25:02 <Cooler> there seems to be a lot of repeated code
12:28:16 <joco42> a phylosphical question: are data declarations invented or discovered ? (ala Wadler)
12:29:22 <monochrom> I discover that I can invent them.
12:29:23 <joco42> i mean, is there some mathematical object which is isomorphic to data type declarations ?
12:29:55 <joco42> the other side of the coin is pattern matching?
12:30:15 <monochrom> data types already qualify as mathematical objects.
12:30:25 <joco42> scrap last question mark
12:30:30 <joco42> yeah
12:31:03 <monochrom> but that doesn't help with "are they invented or discovered?". I discovered that I can invent mathematical objects, too. for example, I discovered that I can invent data types.
12:31:41 <joco42> well in the Wadler sense - i meant
12:33:08 <joco42> Wadler at StrangeLoop
12:47:40 <runeks> How can I make GHC automatically derive the Serialize instance of a data type whose get function is "Constructor <$> get <*> get <*> get <*> get <*> get <*> get"  (with a get for each field with a well-defined Serialize instance)?
12:55:50 <bennofs> runeks: enable -XDeriveGeneric, import GHC.Generics, add deriving (Generic) to your data type and write "instance Serialize YourData" without giving any definitions
12:55:52 <EvanR> runeks: this sounds like generics territory
12:56:15 <runeks> bennofs: Thanks. I will try that.
13:01:17 <runeks> bennofs: Woo! Works like a charm.
13:01:58 <EvanR> i cant wait for -XDeriveBoringButAddictiveMMO
13:04:00 <malademental> Hi everybody, I'm learning haskell and want to create some 2d graphical things (like fractals, mazes, spirals). Which library should I use, and should I follow a tutorial before digging deeper into haskell. I began programming with php, C, python, JS, since almost 8 years.
13:04:18 <EvanR> you can try graphics-drawing-combinators
13:04:33 <liste> @hackage gloss -- malademental, for interactive stuff this can be neat
13:04:33 <lambdabot> http://hackage.haskell.org/package/gloss -- malademental, for interactive stuff this can be neat
13:05:04 <liste> check out the examples: http://gloss.ouroborus.net/
13:05:39 <malademental> liste: yeah that was my first choice but it didn't install easily so I prefered to ask #haskell
13:08:06 <lifter> :r
13:09:19 <liste> malademental: diagrams is cool for static diagrams and other pretty pictures: http://projects.haskell.org/diagrams/
13:09:52 <liste> it should be easy to install
13:10:18 <malademental> that's what i thought when i saw their logo ;)
13:10:48 <malademental> do you think it's good to play with graphics to learn haskell?
13:11:05 <liste> malademental: absolutely
13:11:15 <runeks> How do I define the Serialize instance of a list of some data type?
13:11:38 <Moggle1> I'm investigating a space leak in my program, and after profiling I've discovered that "MAIN" seems to be taking up most of the memory. Is this the main function, and if it is why is it not lowercase like every other function?
13:12:55 <malademental> liste: and I'm wondering to transfer my openbox uses to xmonad too
13:13:04 <malademental> after drawing some cool background for my pc
13:14:02 <runeks> GHC complains about the type "Put [NegotiationRecord]" but it's fine with "Get [NegotiationRecord]"
13:14:56 <olpery> hi, new to func programming. Is there are difference between currying and partial application?
13:15:21 <simpson> olpery: More or less they are two names for the same concept.
13:15:21 <liste> olpery: yes
13:15:34 <liste> :t curry - this is currying
13:15:36 <lambdabot> Not in scope: ‘this’
13:15:36 <lambdabot>     Not in scope: ‘is’
13:15:36 <lambdabot>     Perhaps you meant one of these:
13:15:40 <liste> :t curry -- this is currying
13:15:41 <lambdabot> ((a, b) -> c) -> a -> b -> c
13:15:48 <xa0> partial application is taking a function a -> a -> a to a -> a, for example, by applying one of it's arguments
13:16:03 <mauke> olpery: I'd say partial application in general is not limited to the first argument
13:16:04 <runeks> My mistake. Put doesn't have a return type.
13:16:09 <olpery> partial application returns a new function with one or more bound arguments, yes?
13:16:09 <liste> malademental: cool, many have had their first touch to Haskell that way
13:16:10 <xa0> currying is taking a function that takes it's arguments as a tuple, to one that supports partial application
13:17:17 <olpery> the answers so far are inconsistent and thus leaves me confused
13:17:17 <malademental> thx liste ;)
13:17:56 <mauke> welcome to elves
13:17:59 <mauke> also the internet
13:17:59 <olpery> xa0: are you saying currying is the mechanism that enables partial application?
13:18:34 <geekosaur> olpery, not so much enables as makes it convenient
13:18:52 <olpery> so partial application without currying is... what?
13:19:44 <xa0> in most languages partial application is (or at least can be) done with lambdas
13:20:07 <geekosaur> perl 6 has an "assuming" method applicable to things doing the Callable role, that lets you partially apply the callable. it's nowhere near as convenient and syntactically noisy
13:20:09 <xa0> but in haskell, thanks to currying, it's promoted to language level syntax
13:20:36 <xa0> clojure has (partial f arg1 arg2..)
13:20:45 <olpery> xa0: oh I see, so haskell basically does the lambda-fication for me?
13:20:46 <EvanR> ;_;
13:21:30 <EvanR> partial application without currying: (\x -> f (x, 6))
13:21:38 <xa0> yep. because of currying, in haskell a function that takes two arguments is actually a function that takes one argument, and returns a function that takes another argument, which then returns the result
13:21:42 <jle`> yeah, haskell has sugar to reduce usage of anomymous function syntax
13:21:52 <olpery> ahhh, that simple
13:21:53 <jle`> instead of writing foo = \x -> \y -> \z -> x+y+z
13:21:54 <olpery> thanks
13:21:57 <jle`> we can write foo x y z = x+y+z
13:21:59 <mauke> there's syntactic autocurrying (my term) going on because foo x y z = ... means foo = \x -> \y -> \z -> ...
13:22:38 <jle`> but, currying can be done without anonymous functions too
13:22:51 <jle`> implemented, at least
13:23:08 <jle`> but yeah, that's probably beside the point :)
13:23:15 <mauke> yeah, just malloc up some machine code
13:23:17 <olpery> jle`: but conceptually it's conversion to lambdas, right? :) 
13:23:27 <EvanR> partial application can be done without lambdas
13:23:36 <olpery> trying to get a mental image imprinted
13:23:36 <EvanR> i.e. closures
13:23:44 <EvanR> and all of this is a big mishmash of ideas
13:23:46 <fr33domlover> Question about monad-logger / yesod : When would I want / not want to use the non-TH logging functions?
13:24:00 <olpery> next question:
13:24:05 <olpery> what's a monad?
13:24:09 <fr33domlover> Clearly they're great for debugging but I don't need source file info in e.g. access logs
13:24:11 <olpery> j/k
13:24:19 <xa0> you made my blood run cold there...
13:24:22 <olpery> no burritos tonight
13:24:37 <EvanR> something tangentially related to haskell that isnt that spectacular ;)
13:24:41 <mauke> @quote robots
13:24:42 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
13:24:49 <olpery> haha
13:24:51 <xa0> hahaha
13:25:11 <xa0> that doesn't even make sense to me, and I get monads
13:25:18 <EvanR> its not supposed to
13:25:25 <xa0> i see
13:25:36 <pdxleif_> I'd learn functors, first.
13:25:37 <EvanR> i finally get monads 
13:25:46 <xa0> woo
13:25:49 <pdxleif_> a monad is a more specific type of functor.
13:26:13 <mauke> I get monads for cheap at walmart
13:26:59 <EvanR> for a few monads more
13:27:06 <olpery> sounds like a nasty disease with blood coming out of the orifices
13:27:11 <olpery> "monad night"
13:27:26 <pdxleif_> olpery: Did you ever have group theory or anything in math?
13:27:47 <olpery> pdxleif_: not, i'm a high school drop out, 17 and dumb as fucks
13:27:48 <mauke> anything, yes, but not group theory
13:28:56 <mauke> just for fun, I'd look into monoids. they're mostly unrelated to monads (in practice, in haskell), but they're a fairly simple and easy to understand abstract mathematical object
13:29:14 <pdxleif_> If you run ":info Monad" at the repl, it'll describe what methods the Monad interface defines, along with listing some types that have that interface defined.
13:29:22 <pdxleif_> Same for "Functor"
13:30:44 <pdxleif_> "inheritance hierarchy" of some different typeclasses: https://wiki.haskell.org/wikiupload/d/df/Typeclassopedia-diagram.png
13:31:43 <EvanR> looking at monads and related topics in math it is amazing that it has any use whatsoever in programming
13:31:50 <mauke> if you're new to typeclasses in general, I'd probably do this order: Show, Eq, Monoid, Read, Num, Functor, Applicative
13:32:07 <koz_> EvanR: Well, it's kinda like how people didn't think number theory had many uses until public-key crypto became a big thing. :P
13:32:30 <EvanR> the structure seems accidentally applicative to imperative style code
13:32:31 <xa0> people don't do maths for applications, usually applications are found for branches of maths
13:32:38 <EvanR> applicable*
13:33:59 <pdxleif_> @type (+)
13:34:00 <lambdabot> Num a => a -> a -> a
13:34:02 <EvanR> actually it might be that its more generally not, and its application to imperative style code is more awkward than it needs to be, and we should drop monads from stuff like IO ;)
13:34:32 <EvanR> clearing up a lot of confusion on all sides
13:37:48 <Cooler> can you explain what a monad is then?
13:38:11 <johnw> knowing what love is doesn't make one capable of explaining it :)
13:38:32 <xa0> http://i.imgur.com/f7FdEdG.jpg
13:39:17 <Cooler> is that a no?
13:39:35 <EvanR> its a functor equipped with two extra operations that satisfy some laws
13:39:42 <olpery> the bind and return on every turn, that's how monads work: by churn!
13:40:21 <EvanR> not unlike what is a monoid or monoid object
13:40:36 <EvanR> and why anyone should care comes from examples
13:41:59 <olpery> a functor in haskell is really type construction right? not function object, as in lesser languages?
13:42:11 <EvanR> yes
13:42:25 <EvanR> its a mapping from types to types, and operations to operations
13:42:47 <mauke> olpery: that sounds like the C++ definition of "functor"
13:42:54 <olpery> exactly
13:42:56 <EvanR> regular functions are "function objects"
13:43:07 <olpery> right, what i figured
13:43:12 <mauke> the ocaml definition is "a module -> module mapping", IIRC
13:43:29 <mauke> or maybe s/mapping/function/
13:44:19 <Cooler> so a monad is a functor with 2 extra operations : bind and return?
13:44:20 <olpery> so it seems to me that a monad is a functor, type construction, that needs to satisfy the two monad operations (return/unit) with some algebraic laws that i don't need to understand yet
13:44:24 <olpery> and that's about it (?)
13:44:49 <EvanR> Cooler: well, join and return. bind is something we use in haskell which is a combination of join and fmap
13:45:04 <olpery> isn't join another name for return?
13:45:07 <Cooler> O-O
13:45:10 <xa0> no
13:45:11 <EvanR> pure is another name for return
13:45:12 <mauke> olpery: no, unit is another name for return
13:45:16 <olpery> oh
13:45:24 <xa0> so many names for return
13:45:37 <mauke> unit is more mathematical
13:45:44 <mauke> return was probably inspired by imperative programming
13:45:58 <Cooler> so whats a functor?
13:46:03 <olpery> well, dang, makes sense. got it mixed up. So a type construction with join (op chaining) and unit
13:46:06 <mauke> Cooler: a type you can map over
13:46:33 <EvanR> you can convert any function from A to B to a function from f A to f B
13:46:34 <Cooler> so a functor is any type that derives Mappable?
13:46:35 <mauke> Cooler: basically, a type T that supports the operation fmap :: (a -> b) -> (T a -> T b)
13:46:39 <mauke> what
13:46:43 <mauke> Mappable is Functor
13:47:04 <mauke> and types don't derive
13:47:16 <olpery> so this boils down to monads being type satisfying fmap, join and unit + the algebraic laws, right?
13:47:40 <EvanR> yeah
13:47:48 <olpery> alright, wtf is the fuzz about
13:47:51 <mauke> (the compiler can derive instances (= write the code for you) for certain classes in certain situations)
13:47:57 <EvanR> plus Applicative was thrown into the mix a few months ago
13:48:01 <pdxleif_> yep. Monad is the interface; you say types that have an implementation that satisfy that interface have a monad instance.
13:48:07 <olpery> i suppose i should grok the laws
13:48:17 <olpery> but i think they just state the obvious use pattern
13:48:44 <olpery> pdxleif_: makes sense
13:48:45 <EvanR> the functor laws are the easiest
13:48:48 <xa0> EvanR: applicative is more than a few months old (?)
13:49:07 <EvanR> xa0: the applicative dependency in the monad class?
13:49:39 <xa0> oh specifically that. though wasn't even that change about 2 years ago?
13:49:46 <pdxleif_> A simpler example: Semigroup is the interface: a -> a -> a. That is, a closed binary operator (returns the same type as its two args). The law for it is just associativity, meaning you can combine things in a different order and still get the same result. e.g. (a + b) + c == a + (b + c)
13:50:08 <Cooler> So can you give an example of a functor?
13:50:13 <mauke> Cooler: []
13:50:23 <mauke> and Maybe, but Maybe is basically just a list with a max length of 1
13:50:25 <jdt> anyone know what this error message indicates? /tmp/pkgConf-base-orphans-0.520420.3: hGetContents: invalid argument (invalid byte sequence)
13:50:38 <pdxleif_> Knowing the laws isn't necessary for using it. Just helpful for knowing what kind of refactorings you can do, or if you want to define an instance for your new type.
13:50:55 <jdt> I'm trying to use halcyon and chef to automate deployment of a snap application.
13:51:09 <pdxleif_> > map (+1) [1,2,3]
13:51:10 <lambdabot>  [2,3,4]
13:51:13 <pdxleif_> > fmap (+1) [1,2,3]
13:51:15 <lambdabot>  [2,3,4]
13:51:17 <jdt> my commands run fine from a command-line, but fail with that error on that package when run from chef.
13:51:20 <olpery> pdxleif_: the associativity rule is easy enough. What else?
13:51:20 <pdxleif_> > fmap (+1) (Just 2)
13:51:22 <lambdabot>  Just 3
13:51:28 <mauke> > fmap length ["cool", "story", "bro"]
13:51:29 <lambdabot>  [4,5,3]
13:51:32 <mauke> I can change types!
13:51:38 <HallaSurvivor> mauke, I've never thought of Maybe as [] or [x]... very interesting
13:51:56 <kadoban> jdt: Is that the hGetContents from Data.Text? Maybe it's a decoding error, like an invalid UTF-8 input, or whatever input encoding it uses.
13:51:57 <geekosaur> jdt, I would guess that the locale under Chef is C or some ISO8859 instead of a UTF8 locale
13:52:02 <xa0> there are functions for the conversion too
13:52:09 <xa0> :t maybeToList
13:52:10 <lambdabot> Maybe a -> [a]
13:52:13 <xa0> :t listToMaybe
13:52:15 <lambdabot> [a] -> Maybe a
13:52:17 <Cooler> <EvanR> you can convert any function from A to B to a function from f A to f B
13:52:22 <Cooler> when you say that
13:52:24 <jdt> okay, I'll check that out geekosaur
13:52:31 <geekosaur> have the chef recipe do `echo $LOCALE $LC_ALL` to check
13:52:43 <pdxleif_> Cooler: If you run ":info Functor" at the repl, it'll give you some more things that have Functor defined.
13:52:43 <geekosaur> er $LANG not $LOCALE
13:52:46 <geekosaur> derp
13:52:47 <EvanR> you can convert any function from A to B to a function from [A] to [B], thats the classic map
13:52:47 <jdt> cool - thx.
13:52:59 <mauke> data Maybe a = Nothing | Just a
13:53:00 <mauke> data []    a = []      | (:)  a ([] a)
13:53:20 <Cooler> lessThanFive :: Int -> Bool
13:53:35 <Cooler> lessThanFive x = x < 5
13:53:37 <olpery> so under the new world rules, a monad is a kind of applicative. The question that pops into mind now is... what other kind of non-trivial applicatives are there?
13:53:38 <EvanR> > fmap (<5) [1, 3, 5, 7, 9]
13:53:40 <lambdabot>  [True,True,False,False,False]
13:53:45 <mauke> > let lessThanFive x = x < 5 in fmap lessThanFive in [1 .. 10]
13:53:46 <lambdabot>  <hint>:1:49: parse error on input ‘in’
13:53:50 <mauke> > let lessThanFive x = x < 5 in fmap lessThanFive [1 .. 10]
13:53:52 <lambdabot>  [True,True,True,True,False,False,False,False,False,False]
13:53:59 <pdxleif_> The only difference in the above is that the second constructor recurses in the list case.
13:54:18 <xa0> olpery: an example of an applicative that isn't a monad is zipList
13:54:32 <olpery> xa0: ah, yes, makes sense
13:54:33 <xa0> which is the other applicative that falls out of Lists
13:54:38 <Cooler> how doyou change that function into   functor :: (lessThanFive Int) -> (LessThanFive Bool)
13:54:48 <EvanR> fmap (<5)
13:55:00 <EvanR> though your notation is a little weird
13:55:12 <mauke> Cooler: that makes no sense
13:55:17 <EvanR> Cooler: the f i used earlier is [_]
13:55:22 <Cooler> yeah it doesn't make sense
13:55:26 <Cooler> thats why i am asking
13:55:31 <mauke> Cooler: what
13:55:37 <olpery> I like haskell now. I'm convinced.
13:55:42 <EvanR> not the function you are mapping
13:55:48 <Cooler> lessThanFive Bool shouldn't even work since it takes an int argument
13:55:49 <pavonia> Cooler: What would be LessThanFive?
13:56:02 <mauke> Cooler: no, lessThanFive Bool shouldn't work because there is no type called "lessThanFive"
13:56:13 <EvanR> Cooler: f A and f B, these f's are type constructors not functions
13:56:20 <mauke> alternatively, there is no value called "Bool"
13:56:34 <Cooler> mauke, i am talking about types
13:56:45 <Cooler> <EvanR> you can convert any function from A to B to a function from f A to f B
13:56:45 <mauke> <mauke> Cooler: no, lessThanFive Bool shouldn't work because there is no type called "lessThanFive"
13:56:57 <mauke> Cooler: f is a type there
13:57:00 <mauke> not your function
13:57:10 <Cooler> oh
13:57:15 <Cooler> thats confusing
13:57:16 <EvanR> Cooler: example f are [ ], Maybe, (e,)
13:57:20 <EvanR> (r ->)
13:57:21 <mauke> Cooler: yes :-)
13:57:22 <Cooler> why would you use f instead of T?
13:57:29 <mauke> Cooler: because it's a *f*unctor
13:57:31 <Cooler> types are supposed to start with capitals
13:57:32 <EvanR> f is a variable, T is some type
13:57:38 <pdxleif_> f has to be something of type (kind?) Type -> Type
13:57:44 <pdxleif_> @kind Maybe
13:57:45 <lambdabot> * -> *
13:57:48 <pdxleif_> @kind []
13:57:49 <lambdabot> * -> *
13:58:00 <mauke> :t fmap
13:58:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:58:07 <EvanR> Cooler: read what i said as "for any functor f, you can convert a function from A to B to a function from f A to f B"
13:58:13 <mauke> Cooler: it's lowercase because in the definition of fmap it's a type variable
13:58:33 <Cooler> types are supposed to start with capitals, why are you using small f?
13:58:33 <EvanR> the type of fmap says all this in less characters
13:58:39 <EvanR> Cooler: its a variable
13:58:56 <EvanR> its also not a type
13:58:57 <Cooler> yeah and the variable isn't a normal variable right? is a type?
13:59:08 <Cooler> its*
13:59:09 <pavonia> It's a type variable
13:59:09 <EvanR> :k Maybe
13:59:10 <lambdabot> * -> *
13:59:16 <EvanR> its a type ctor variable ;)
13:59:39 <mauke> Cooler: why are you complaining about f but not a and b?
13:59:41 <Cooler> yeah so why would you use small letter f instead of capital T?
13:59:53 <mauke> Cooler: because it's a variable, not a concrete type
14:00:00 <EvanR> i am quantifying over all functors f, not talking about any particular F
14:00:04 <Cooler> oh
14:00:05 <pdxleif_> It would think T would be some concrete type in scope it had to look for.
14:00:30 <Cooler> so why not use small t instead of small f?
14:00:38 <EvanR> though i could have used small A and B, but i chose to talk about particular A and B implicitly
14:00:50 <pdxleif_> You could. I think they use "f" for "functor".
14:00:56 <EvanR> Cooler: well functors arent strictly types, they are mappings from one type to another
14:00:57 <mauke> <mauke> Cooler: because it's a *f*unctor
14:01:01 <Cooler> because there are a lot of places which use small f as a function
14:01:10 <mauke> why am I lagging
14:01:42 <Cooler> mauke, i know its a functor
14:01:44 <Cooler> because there are a lot of places which use small f as a function
14:01:46 <pdxleif_> It's a different namespace, though - you don't have to worry about the type variable "f" conflicting with a function called "f" - the first is in the type namespace, the latter is a value.
14:01:50 <EvanR> Cooler: t is also used sometimes like in this type sig
14:01:52 <EvanR> :t length
14:01:53 <lambdabot> Foldable t => t a -> Int
14:02:03 <EvanR> same thing
14:02:21 <johnw> EvanR: they aren't even not strictly types, they're type formers
14:02:29 <Cooler> yeah so just use small t? it avoids a lot of confusion
14:02:29 <pdxleif_> Like [] and [] are in different namespaces, and it's no problem. One's a type constructor, one's a data constructor.
14:02:33 <pdxleif_> :k []
14:02:34 <lambdabot> * -> *
14:02:35 <pdxleif_> :t []
14:02:36 <EvanR> heh formers
14:02:37 <lambdabot> [t]
14:03:12 <EvanR> Cooler: f indicates a functor when its obvious were not talking about a function
14:03:17 <pdxleif_> You could write that latter type as forall t . [t]
14:03:28 <EvanR> f A where A is some type, cant be a function
14:03:30 <pdxleif_> (t : Type) -> List t, basically.
14:03:30 <Cooler> EvanR, its not obvious is the problem
14:03:34 <mauke> Cooler: why not name your variables "v" to avoid confusion?
14:03:35 <Cooler> anyway
14:03:48 <EvanR> after mulling through this this long, it will be obvious to you ;)
14:04:16 <xa0> Cooler: i don't see the confusion, it's denoted  f cause it's a functor, not a a type
14:04:35 <mauke> it's all intuitively obvious after you've spent enough time learning the correct intuition
14:04:36 <Cooler> nvm
14:04:47 <EvanR> getting the hang of idioms can speed up communication later
14:04:57 <EvanR> everything we said can be summarized:
14:04:58 <EvanR> :t fmap
14:04:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:05:04 <pavonia> :t fmap :: Functor functor => (oldParameterType -> newParameterType) -> functor oldParameterType -> functor newParameterType  -- less confusing? ;)
14:05:05 <lambdabot> Functor functor => (oldParameterType -> newParameterType) -> functor oldParameterType -> functor newParameterType
14:05:09 <pdxleif_> you could even use the type var f in the type sig for the function "f". e.g. f : Functor f => f String -> f Int; f = fmap length
14:05:19 <Cooler> i still think its unnesseccarily confusing
14:05:44 <EvanR> will it help to tell you that functions in haskell cant take types as arguments?
14:05:52 <EvanR> only values
14:06:20 <EvanR> if you dont know this, then youre going to be confused for longer
14:06:26 <Cooler> uh
14:06:36 <Cooler> don't constructors take types?
14:06:45 <Cooler> like Just a
14:06:47 <EvanR> like Just? no
14:06:49 <Cooler> Just Int
14:06:57 <EvanR> Just Int is not right
14:07:03 <EvanR> Maybe Int is right
14:07:21 <xa0> > Just Int
14:07:21 <pavonia> Type constructors take types as parameters, data constructos take values
14:07:22 <lambdabot>      Not in scope: data constructor ‘Int’
14:07:23 <lambdabot>      Perhaps you meant one of these:
14:07:23 <lambdabot>        ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
14:07:24 <xa0> > Just 3
14:07:25 <lambdabot>  Just 3
14:07:32 <xa0> > Maybe 3
14:07:33 <lambdabot>      Not in scope: data constructor ‘Maybe’
14:07:33 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
14:07:39 <xa0> > :t Maybe Int
14:07:40 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:07:52 <jdt> yeah, geekosaur - it's C
14:07:54 <Cooler> right so Maybe Int takes a type as argument
14:08:02 <pavonia> No
14:08:02 <EvanR> Maybe isn't a function though
14:08:17 <Cooler> its a type constructor right? thats not a function?
14:08:17 <mauke> Cooler: Maybe takes a type as an argument; Maybe Int doesn't
14:08:31 <xa0> Maybe is a type constructor, it takes a single type argument
14:08:46 <mauke> I'm ok with calling Maybe a type-level function
14:09:12 <Cooler> yeah so Maybe does take a type arguemtn
14:09:15 <Cooler> argument
14:09:16 <Cooler> *
14:09:21 <xa0> and because haskell isn't dependently typed (;_;) type-level functions aren't value-level functions
14:09:47 <EvanR> Cooler: so theres two separate levels here and they have different characteristics
14:10:01 <Cooler> ok
14:10:08 <EvanR> so when reading the type sig of fmap you need to know youre on the type level
14:10:18 <pdxleif_> You can write "Just Int" in Idris or Agda or something...
14:10:18 <Cooler> :t fmap
14:10:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:10:25 <EvanR> so f is a "type function" not a regular function
14:10:34 <xa0> :k Maybe
14:10:35 <Cooler> btw whats that => ?
14:10:35 <lambdabot> * -> *
14:10:51 <mauke> :t (Functor ⲧ) => т -> τ -> (ⲧ т -> ⲧ τ)
14:10:52 <lambdabot> parse error on input ‘=>’
14:10:58 <EvanR> constraints go on the left of the =>
14:11:08 <Cooler> don't you use :: to specify types?
14:11:21 <EvanR> fmap :: Functor f => (a -> b) -> f a -> f b
14:11:32 <Cooler> oh
14:11:43 <Cooler> so whats the => then?
14:12:10 <xa0> constraints
14:12:12 <EvanR> visual cue to separate constraints from the rest of the type sig
14:12:48 <EvanR> without Functor f =>, it would mean "for all f"
14:12:55 <Cooler> isn't a constraint something like (< 5) ?
14:13:01 <Cooler> a predicate essentially
14:13:09 <EvanR> this is a different kind of predicate
14:13:15 <EvanR> it means "has a functor instance"
14:13:20 <pavonia> (<5) is on the value level
14:13:22 * hackagebot react-flux 1.0.4 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.0.4 (JohnLenz)
14:13:56 <EvanR> and this condition is checked at compile time not runtime
14:14:29 <Cooler> what condition?
14:14:35 <EvanR> that f has a functor instance
14:14:38 <mauke> <EvanR> it means "has a functor instance"
14:14:45 <xa0> it's interesting that his intuition is naturally towards dependent typing
14:14:52 <Cooler> ok whats a instance?
14:15:05 <mauke> Cooler: you're doing all this completely ass-backwards
14:15:09 <xa0> Cooler: member of the typeclass
14:15:18 <EvanR> the implementation of fmap
14:15:50 <EvanR> heh that is how it usually goes though, backwards ;)
14:16:01 <Cooler> so is Functor defined somewhere else?
14:16:08 <xa0> backwards in time, full of little chocolate trains?
14:16:19 <EvanR> Functor is a class
14:16:28 <EvanR> types have or dont have Functor instances
14:16:52 <mauke> Cooler: Functor seems to be defined in GHC.Base (but exported from Prelude)
14:17:03 <mauke> and Data.Functor
14:17:19 <Cooler> :t fmap
14:17:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:17:31 <EvanR> you probably find the Functor instance for whatever f in the file that defines f
14:17:44 <Cooler> so fmap takes 2 arguments then?
14:17:50 <EvanR> yeah
14:17:53 <Cooler> f and (a->b) ?
14:17:57 <EvanR> no
14:18:02 <EvanR> (a -> b) and f a
14:18:11 <Cooler> right
14:18:22 <xa0> Cooler: fmap CANNOT take f as an argument
14:18:32 <xa0> f is a type constructor
14:18:32 <Cooler> what happens if f isn't a functor?
14:18:40 <EvanR> type error
14:18:43 <Cooler> ok
14:19:43 <Cooler> whats the implementation of fmap?
14:19:50 <EvanR> depends on f
14:20:08 <olpery> > zip "hsle" "akl"
14:20:09 <lambdabot>  [('h','a'),('s','k'),('l','l')]
14:20:13 <Cooler> does it have to inverse f a then using the function to get b and apply f again?
14:20:19 <olpery> someone help me make it spell haskell
14:20:29 <olpery> that god damn e
14:20:45 <EvanR> does what have to do what?
14:20:56 <pavonia> > zip "hsle" "akl!"
14:20:58 <lambdabot>  [('h','a'),('s','k'),('l','l'),('e','!')]
14:21:04 <olpery> close
14:21:16 <pavonia> > zip "hsel" "akl!"
14:21:18 <lambdabot>  [('h','a'),('s','k'),('e','l'),('l','!')]
14:21:23 <olpery> yes!!!!
14:21:26 <olpery> thank you
14:21:35 <pavonia> O.o
14:21:38 <dmj> olpery: homework?
14:21:40 <olpery> i see what you did there
14:21:42 <olpery> dmj: no
14:21:49 <dmj> olpery: final project?
14:21:52 <EvanR> Cooler: type classes like Functor let you overload names like fmap, there are many fmaps and it magically knows which one you want depending on the context
14:21:53 <olpery> no
14:22:05 <olpery> dmj: i'm a drop out, just learning by fudging around
14:22:32 <xa0> >concat $ zipWith (\a b -> [a,b]) "hsel" "akl!"
14:22:37 <xa0> > concat $ zipWith (\a b -> [a,b]) "hsel" "akl!"
14:22:39 <lambdabot>  "haskell!"
14:22:41 <Cooler> does fmap have to 1. reverse the effects of f to get a 2. apply (a->b) to a to get b 3. apply f on b to get fb that it needs to return?
14:22:50 <Cooler> is that how its implemented?
14:22:51 <olpery> xa0: cute :)
14:22:57 <xa0> :)
14:23:04 <elpetrero> is there a Data.ByteString.split function but for String?
14:23:21 <elpetrero> @hoogle a -> [a] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
14:23:22 <lambdabot> Parse error:
14:23:22 <lambdabot>   a -> [a] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
14:23:22 <lambdabot>                         ^
14:23:23 <EvanR> Cooler: in the case of list, for example yeah, its going to look at the lists internals to decide what to do
14:23:24 <xa0> :t Data.ByteString.split
14:23:26 <lambdabot> Word8 -> BSC.ByteString -> [BSC.ByteString]
14:23:39 <xa0> elpetrero: is 'words' what you're looking for?
14:23:47 <EvanR> Cooler: either it needs to apply the a -> b or it needs to stop because its the end of the list
14:23:57 <elpetrero> kind of, but I need to separate by dots
14:24:05 <elpetrero> mmm will see how is words implemented
14:24:35 <EvanR> Cooler: actually Functor is special in that there isnt really much decision on what to do, because of the functor laws, so you dont really even have to write this code. you can use deriving
14:25:24 <pavonia> elpetrero: Have a look at Data.List.Split
14:25:46 <pavonia> :t splitOn "." "foo.bar.baz"
14:25:48 <lambdabot> [[Char]]
14:25:50 <pavonia> > splitOn "." "foo.bar.baz"
14:25:51 <lambdabot>  ["foo","bar","baz"]
14:26:11 <elpetrero> OK, so an package has it defined
14:26:33 <saml> let f x == if x < 0 then 0 else x      -- what would you call this function?
14:26:56 <shachaf> Rectifier
14:27:03 <elpetrero> Mmm I will just `show . ByteString.split 0.x2e . pack` to not pull a dependency lol
14:27:08 <saml> thanks i just rectified
14:27:12 <shachaf> https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
14:28:16 <shachaf> Or ramp.
14:28:21 <shachaf> Or (max 0).
14:29:18 <Moggle1> Is it possible to add strictness notations onto a type declaration?
14:29:18 <pavonia> elpetrero: Note that this will fail terribly if your String contains non-ASCII characters
14:29:22 <Moggle1> type X = !Y?
14:29:43 <elpetrero> nah it will be fine, it is a IP address
14:29:43 <Cooler> So in normal maths fmap would take a function like f(x) = 2x and a domain like the real numbers R and give its output in another domain (in this case R)
14:29:58 <Cooler> so how is that different from mapping?
14:30:04 <elpetrero> network byte order and inet_ntoa aren't exactly friends
14:30:27 <EvanR> Cooler: this is a valid functor on the reals
14:30:55 <EvanR> but its boring because theres only 1 object in your category
14:31:29 <elpetrero> functors are about `mapping that preserve the structure`
14:31:43 <elpetrero> on haskell you can think about the data-structure
14:32:10 <elpetrero> ie on a tree it will map each value to another but it wont remove leaves or branches because it would change the structure
14:33:09 <elpetrero> if you understand why Set cannot be a functor, your have mastered them and you will receive a black bell on your mailbox
14:33:32 <EvanR> haha
14:33:46 <EvanR> the functors merit badge
14:34:05 <hotdog> hi, what is the cleanest way to get stack, git, g++, make, etc. working on windows 10?
14:34:26 <hotdog> do i have to use 3 separate installers, one for git, one for stack, and one for the rest?
14:34:56 <kadoban> hotdog: Install linux in a VM?
14:35:22 <hotdog> kadoban: i'm running opencl code, and i'm not sure if that would be simpler
14:39:43 <Cooler> elpetrero, a Set is a key pair table right?
14:40:23 <Cooler> is this Set different?
14:40:45 <Cooler> why can't it be a functor?
14:40:59 <EvanR> a Set is just the keys
14:41:06 <EvanR> no pair
14:41:11 <Cooler> oh right
14:41:21 <Cooler> just a set of keys
14:41:27 <EvanR> keys of type a
14:41:28 <Cooler> and no key can appear twice
14:41:29 <EvanR> Set a
14:41:41 <elpetrero> Cooler: that last point is the important
14:41:48 <hpc> and if you fmap (\_ -> thing that can't be determined unique)
14:41:51 <hpc> you have a bad
14:42:12 <hpc> for instance, fmap (\_ -> readFile "/etc/shadow")
14:42:17 <Cooler> i don't know why you would even need to say no key can appear twice, otherwise you wouldn't call them keys
14:42:23 <EvanR> er i have been informed that its ok to lose a few keys in the fmapping process ;)
14:42:34 <hpc> it's okay to lose keys in the fmapping process
14:43:10 <hpc> but no key appearing twice is still the important bit
14:43:20 <hpc> because you have to know one way or the other, and for some types that's impossible
14:43:28 <geekosaur> I thught the issue was that fmap has to preserve structure, but Set and Map have an adiditonal internal structure expressed by an Ord constraint which would be lost by fmap?
14:43:37 <elpetrero> yep
14:44:09 <hpc> geekosaur: the property of preserving structure is an observation based on the Functor laws
14:44:20 <EvanR> i find it odd that structure would be preserved (in a non haskell setting) by ending up with less elements
14:44:21 <Cooler> right what are the functor laws?
14:44:34 <elpetrero> preserve composition
14:44:37 <hpc> http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#t:Functor
14:44:42 <elpetrero> mapping to the identity does nothing
14:44:51 <elpetrero> you should not talk about... wait
14:44:55 <EvanR> but that is a general thing that happens in the homomorphism-like fmap (f . g) = fmap f . fmap g
14:44:56 <elpetrero> that one not
14:45:02 <xa0> Cooler: i read the scrollback. how familiar are you with category theory, and calculus, and what is your definition of "mapping"?
14:45:20 <hpc> it's important to note you can write instances for Set/Map if you use indexed whatevers
14:45:21 <EvanR> it preserves composition, so some structure survives
14:45:31 <EvanR> if its perfectly surviving its isomorphism
14:45:52 <hpc> like instance IndexedFunctor Set Ord where ...
14:45:55 <EvanR> Cooler: for all *functions* f and g, fmap (f . g) = fmap f . fmap g
14:46:11 <hpc> class IndexedFunctor f c where fmap :: (c a, c b) => (a -> b) -> f a -> f b
14:46:15 <elpetrero> select bad f and g
14:46:24 <hpc> that i believe should be a perfectly possible instance/class to write
14:46:26 <hpc> with the right extensions
14:47:07 <elpetrero> hpc: I feel we would need some kind of fundeps for that kind of class
14:47:13 <elpetrero> and then we end up mostly the same
14:47:23 <hpc> probably
14:47:29 <monochrom> in fact you will need ContraintKind
14:47:32 <Cooler> EvanR, thats confusing fmap takes 2 arguments not on2
14:47:37 <Cooler> one*
14:47:47 <EvanR> Cooler: well that is why you are using .
14:47:49 <hpc> well, fundeps is needed to say that Set implies Ord
14:48:01 <hpc> but the major point there is that you're limiting the types that (a -> b) is able to take on
14:48:12 <EvanR> Cooler: remember f and g also take 1 argument, also not shown. we are doing function composition
14:48:16 <hpc> to the realm of mappings that produce sensical input and output sets
14:49:04 <EvanR> Cooler: remember that you can think of fmap as taking 1 argument, it takes a function A -> B to f A -> f B
14:49:14 <EvanR> its mapping a function to a function
14:49:26 <EvanR> and f maps a type to a type
14:49:41 <pdxleif_> you could throw an extra var on there: for all f, g, and x, fmap (f . g) x = (fmap f . fmap g) x
14:49:51 <EvanR> or more vars
14:49:58 <EvanR> to get rid of all .
14:51:02 <monochrom> for maximum confusion: fmap (\x -> f (g x)) x = fmap (\x -> f x) (fmap (\x -> g x) x)
14:51:12 <pdxleif_> the "fmap id = id" law can also be written  "fmap id x = x"
14:52:09 <pdxleif_> monochrom: Isn't there some lambdabot command that'll do that for you - the opposite of @pl?
14:52:09 <Cooler> fmap id x == id x?
14:52:23 <pdxleif_> sure
14:52:51 <mauke> @unpl fmap id
14:52:51 <lambdabot> fmap (\ a -> a)
14:52:54 <EvanR> Cooler: there are two laws, i gave you the one with more meat
14:52:55 <pdxleif_> just means mapping "id" shouldn't change anything - fmap should be "structure preserving"
14:52:55 <monochrom> no. the maximum confusion version for that is fmap (\x -> id x) x = id x
14:53:01 <Cooler> what do those 2 laws actually mean though?
14:53:12 <mauke> monochrom: needs more 'ask'
14:53:24 <EvanR> it means the function acts the same way on the original types as the target types
14:53:30 <EvanR> (target of the functor)
14:53:37 <mauke> (\x -> ask x) fmap ...
14:54:02 <EvanR> there will be "no surprises" by using an fmapped function
14:54:19 <pdxleif_> homomorphism?
14:54:37 <Cooler> because i look at fmap (f . g) == fmap f . fmap g and think -3(4 + 5) = -3.4 + -3.5
14:54:42 <Cooler> or something like that
14:54:54 <EvanR> fmap distributes over composition
14:54:55 <mauke> fmap (\x -> ask x) x = fmap fix return x
14:55:11 <Cooler> otherwise known as the distributive property
14:55:16 <pdxleif_> @type (.)
14:55:17 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:56:18 <EvanR> -3(4+5) = -3*4 + -3*5
14:56:48 <Cooler> so would the functor there be the set of integers I?
14:56:58 <EvanR> heh
14:57:03 <mauke> that's not a functor
14:57:06 <EvanR> if + were composition in some weird way
14:57:39 <Cooler> no i supppose not the set of integers would be fA the input to fmap
14:58:10 <EvanR> you could look at ring homomorphisms which has a similar law
14:58:12 <Cooler> so what would be f there?
14:58:53 <johnw> it's saying that identity and composition transports across the morphism mapping; that is, the structure of the category is preserved
14:59:43 <johnw> a functor must map between categories; it can't map from a category to a non-category.  The laws are saying basically this.
15:00:10 <Cooler> so why can't a Set be a functor?
15:00:10 <EvanR> but not just any old way
15:00:27 <xa0> this discussion is driving me crazy
15:00:32 <johnw> Cooler: in mathematics, sets ARE functors.  In Haskell, the Ord constraint is too weak for the functor laws to hold.
15:00:36 <Cooler> its still the same structure just fewer elements in some cases
15:00:59 <Zekka|Sigfig> Cooler: Try playing around and seeing if you can find some code that compiles but with a result that violates the functor laws
15:01:03 <Zekka|Sigfig> (this is possible to do)
15:01:51 <Cooler> the Ord constraint is too weak?
15:02:03 <Cooler> what do you mean weak?
15:03:07 <johnw> Cooler: https://www.reddit.com/r/haskell/comments/2090x3/ask_rhaskell_why_is_there_no_functor_instance_for/
15:03:45 <johnw> see especially the comment "This is true for sets as long as the law x == y => f x == f y."
15:04:08 <EvanR> no functor instance for Set is a really good example of how Haskell is about "no compromises, period"
15:04:24 <EvanR> in most of language settings when someone had the idea of mapping over a set, it would have become a thing
15:04:34 <EvanR> most other*
15:05:02 <EvanR> there would be a mappable class and set would be in it ignoring any issues
15:05:44 <EvanR> "let them deal with it at runtime"
15:06:21 <johnw> right, we can't force the laws, but we care about them deeply :)
15:07:04 <EvanR> its like, taking your own dogma seriously ;)
15:07:05 <johnw> people have proposed strengening Ord so that equality transports, but this imposes too much rigidity
15:09:02 <johnw> https://www.reddit.com/r/haskell/comments/1njlqr/laws_for_the_eq_class/
15:09:31 <EvanR> aaaand then we think about Double and how our Eq laws can be laws
15:09:37 <EvanR> and i eat my words
15:09:44 <EvanR> cant*
15:11:59 <EvanR> the lack of sense in the type class instances for Float and Double are a great example of how Haskell presents itself as based on higher math principles and then conveniently disposes of those principles out of pragmatism or lack of a better idea ;)
15:12:50 <EvanR> (with no opposite followup for other languages)
15:13:20 <pdxleif_> I ran some quickcheck tests on Doubles and they came back true. Only because quickcheck didn't think to also test for "whole numbers", e.g. things like "1.0"
15:13:38 <EvanR> oh geez
15:14:01 <hpc> duh, those are integers
15:14:09 <pdxleif_> :/
15:14:12 <hpc> :P
15:14:46 <GodThisNickRegis> tered.
15:14:59 <hpc> quickcheck is relentlessly arbitrary in its choice of cases
15:15:02 <johnw> floats seem always to stand at the divide between computing and pure math
15:15:31 <hpc> floats are a bad encoding of a hard-to-get-right mathematical concept
15:15:46 <hpc> but they're so good enough in just the right ways
15:15:53 <hpc> and broken in just the wrong ways
15:15:59 <EvanR> i followed the "unum" reference from a few days ago and that seems interesting, if not very well defined
15:16:22 <EvanR> promises to satisfy sane laws
15:16:25 <GodThisNickRegis> that's why it's called float. it's like a soda float, not quite soda, but not quite icecream
15:16:28 <EvanR> and increase efficiency
15:16:36 <Lokathor> https://github.com/Lokathor/ludolib/blob/master/src/Util/PPFOV.hs Converted a module over to using all unboxed values internally and got another nice speedup.
15:16:52 <Lokathor> feel free to suggest possible additional time savings, if you spot any
15:19:22 <GodThisNickRegis> Lokathor: what's a boxed value?
15:19:43 <EvanR> [9]
15:20:13 <EvanR> [⊥]
15:20:21 <GodThisNickRegis> [aye]
15:20:23 <Lokathor> GodThisNickRegis, a boxed value is a normal haskell value. An unboxed value is where you fiddle with more primitive forms of data like you would in C
15:21:27 <GodThisNickRegis> does that incur a memory hit?
15:21:33 <Lokathor> the opposite in fact
15:22:02 <GodThisNickRegis> Haskell code is more memory efficient than C?
15:22:15 <EvanR> depends on the C code
15:22:21 <Lokathor> it saves on memory, but you take a lazyness hit (all unboxed values must be strict) and you also take a usability hit (unboxed values have a much more limited set of operations)
15:22:33 <GodThisNickRegis> sure
15:22:51 <Zekka|Sigfig> GodThisNickRegis: Its default sequence and string representations are pretty wasteful
15:22:54 <EvanR> C sucks enough at general memory management that practically you often take liberties with memory usage to preserve sanity
15:23:11 <Zekka|Sigfig> lists use an extra pointer for every element, Strings use an extra pointer for every character
15:23:15 <Lokathor> no such thing as a memory leak if you just never free any memory :3
15:23:23 <Zekka|Sigfig> so practically IIRC strings are about 16 bytes per character
15:23:25 <GodThisNickRegis> Hmm, okay, Zekka|Sigfig 
15:23:33 <Zekka|Sigfig> But there are some alternatives to those
15:23:34 <EvanR> yeah String is pretty bad
15:24:09 <GodThisNickRegis> Sanity is good for memory, yes 
15:24:11 <Zekka|Sigfig> there is nothing stopping you from operating on C-style arrays in Haskell, and GC overhead is not outrageous
15:24:31 <Lokathor> I think my PPFOV is as fast as it's gonna go for now
15:24:33 <GodThisNickRegis> Appreciate the irony
15:24:38 <EvanR> Text <-
15:24:38 <Lokathor> this has been a fun few evenings
15:26:07 <EvanR> String = [Char] is a gimmicky thing thats fun to amuse visitors with, but if String = Text that would be pretty nice for IRL
15:26:34 <Lokathor> submit a pull request for GHC 9
15:26:35 <GodThisNickRegis> string as char? lol. y u no arrays??
15:26:43 <EvanR> list of Char
15:26:54 <EvanR> Text is an array
15:27:15 <GodThisNickRegis> ah okay
15:27:47 <GodThisNickRegis> it would be less typeous
15:28:08 <Cooler> uh, i didn't understand that reddit post on why Sets can't eb functors
15:28:49 <EvanR> Cooler: what if you wanted to map a set of Ints to a set of functions?
15:28:56 <GodThisNickRegis> Link?
15:29:14 <Cooler> EvanR, why would you do such a thing XD
15:29:41 <Lokathor> guess you can't constrain fmap to say that b also has to implement Ord
15:29:42 <EvanR> Cooler: because the Functor f => (a -> b) -> f a -> f b where b is any type you want
15:29:45 <Cooler> a set of Ints to a set of lessThanInt functions?
15:29:58 <EvanR> whatever kind of functions you want
15:30:04 <EvanR> GodThisNickRegis: https://www.reddit.com/r/haskell/comments/2090x3/ask_rhaskell_why_is_there_no_functor_instance_for/
15:30:22 <EvanR> the answer is, you want to do this to satisfy the type signature
15:30:33 <EvanR> we dont like type signatures which are lying
15:30:52 <Lokathor> Cooler, that link was for you I suspect
15:31:05 <EvanR> no Cooler is asking about this link
15:31:21 <Lokathor> that's waht i said, you typed a different name
15:31:32 <EvanR> GodThisNickRegis asked for the link
15:31:47 <Lokathor> oh oh, i see
15:32:19 <Cooler> EvanR, so whats the problem if you want to map from a set of ints to a set of functions?
15:32:30 <EvanR> how do you build a Set of functions
15:32:37 <EvanR> without being able to order them
15:32:44 <Cooler> is this because the number of elements might get reduced?
15:32:55 <GodThisNickRegis> " it should also hold that x == y   =>  f x == f y for any f :: a -> b and x, y :: a"
15:32:57 <GodThisNickRegis> i agree
15:33:10 <EvanR> no, Set construction requires a < operation
15:33:13 <Cooler> EvanR, ohhhhhhhhhhh
15:33:15 <Cooler> ok
15:33:17 <GodThisNickRegis> unless specified in the functions?
15:33:19 <Cooler> that makes sense
15:33:34 <GodThisNickRegis> there's really something to that
15:33:39 <Cooler> wait so how is a Set a functor in pure maths?
15:33:50 <Cooler> how do you order functions there?
15:34:05 <EvanR> in math youre sets dont use ordering
15:34:11 <EvanR> your sets use equals
15:34:21 <EvanR> which we also dont have for functions
15:34:40 <Sgeo> People don't mind if I ask questions related to both Haskell and another language, right? >.>
15:34:55 <johnw> try us
15:35:02 <Cooler> EvanR, so its not a functor?
15:35:39 <Sgeo> What are some use cases for the open-union package? I semi-independently wrote my own version for Rust, but without thinking of any real usefulness
15:35:43 <EvanR> well time to be more precise, is what not a functor? which categories are we mapping between
15:35:59 <Cooler> is a Set a functor?
15:36:14 <EvanR> Haskell and Sets ? Sets and Sets?, magic haskell and magic sets of haskell values?
15:36:33 <GodThisNickRegis> i discovered i was a functor, especially after behavior problems, what other perceive as "disruptive behavior"
15:36:39 <EvanR> in magic haskell you can tell when two functions are the same
15:37:31 <EvanR> so you could make a magic set data type which used that to work on any type
15:37:35 <GodThisNickRegis> *others perceive
15:37:41 <Cooler> uh, a haskell set has the same definition as a set in maths right?
15:37:47 <EvanR> no
15:37:57 <johnw> Cooler: not even close, really
15:38:11 <johnw> there's definitely a resemblance
15:38:20 <Cooler> so sets being functors in maths has nothing to do with haskell sets at all then
15:38:25 <johnw> correct
15:38:40 <Cooler> because we have been talking about 2 completly different things
15:39:11 <EvanR> magic set is a functor, but a haskell eq set uses Eq which isnt available on all types in haskell
15:39:16 <GodThisNickRegis> can Haskell f(infinity?, yes|no,
15:39:34 <GodThisNickRegis> ) ^_^
15:39:57 <GodThisNickRegis> if not, we're not there yet, guys
15:40:05 <EvanR> > (\x -> if x == 1/0 then True else False) 4
15:40:06 <lambdabot>  False
15:40:10 <EvanR> > (\x -> if x == 1/0 then True else False) (1/0)
15:40:12 <lambdabot>  True
15:40:26 <EvanR> :t (==1/0)
15:40:27 <lambdabot> (Eq a, Fractional a) => a -> Bool
15:40:59 <GodThisNickRegis> 1 div 0 is the definition of infinity?
15:41:00 <int-e> Cooler: newtype Set a = Set { rebmem :: a -> Bool }; member = flip rebmem   would come close to how mathematicians define sets. And that would have a proper Functor instance in Haskell too, where  fmap f (Set m) = Set (m . f)
15:41:08 <EvanR> > 1/0
15:41:10 <lambdabot>  Infinity
15:41:14 <EvanR> can't argue with that
15:41:45 <GodThisNickRegis> they're two mutually exclusive concepts, though
15:41:56 <GodThisNickRegis> 1 is something, 0 is nothing
15:42:15 <GodThisNickRegis> divide something by nothing and get infinity>
15:42:25 <GodThisNickRegis> holy shit, but, wat
15:42:36 <EvanR> dont think about this too hard
15:42:42 <Cooler> what does flip do?
15:42:46 <Cooler> :t flip
15:42:47 <lambdabot> (a -> b -> c) -> b -> a -> c
15:42:50 <pdxleif_> > 1 / 0 - 1 / 0
15:42:51 <lambdabot>  NaN
15:43:01 <EvanR> (a -> b -> c) -> (b -> a -> c)
15:43:03 <Zekka|Sigfig> So if you have Set -> a -> Bool, flipping it gets you a -> Set -> Bool
15:43:14 <Zekka|Sigfig> (well, Set a -> a -> Bool, a -> Set a -> Bool)
15:43:40 <Cooler> i just realized we haven't even talked about applicative functors or monads yets
15:43:41 <GodThisNickRegis> so abc = chewbacca
15:43:42 <Cooler> yet*
15:43:51 <EvanR> good ;)
15:44:04 <int-e> Err my "functor" is contravariant. The functor would involve an inverse image, which Haskell can't do.
15:46:29 <EvanR> a -> Bool is kind of like a -> a -> Bool, but we didnt use a type class to ruin all the fun
15:46:31 <Cooler> why do sets have to satisfy Ord, don't you just need Eq?
15:46:47 <int-e> Cooler: for efficiency
15:46:49 <Cooler> is this because a Set is sorted data structure?
15:47:13 <int-e> Exactly; with Eq alone you wouldn't be able to sort the keys.
15:47:28 <Cooler> well why sort keys when you can hash map them?
15:47:46 <int-e> That would be yet another type class.
15:48:03 <geekosaur> that structure is also available, but Hashable is also a constraint
15:48:13 <Cooler> most languages implement sets as hashmaps i think
15:48:52 <int-e> :t Data.HashMap.Strict.lookup
15:48:53 <lambdabot> (Eq k, hashable-1.2.3.3:Data.Hashable.Class.Hashable k) => k -> unordered-containers-0.2.5.1:Data.HashMap.Base.HashMap k v -> Maybe v
15:49:20 <EvanR> Hashable, Eq, Ord, pick your poison
15:49:34 <EvanR> for an arbitrary type with no constraints, you cant really do anything at all
15:49:43 <Cooler> yeah
15:49:45 <EvanR> another different between haskell and languagefoo
15:49:45 <GodThisNickRegis> i prefer chaotic-containers
15:50:00 <int-e> Cooler: in many languages arrays are more convenient than algebraic data types (encoding trees) - Haskell is the opposite, in my opinion.
15:50:05 <GodThisNickRegis> pick a card, any card 
15:50:07 <GodThisNickRegis> :D
15:50:36 <Cooler> why can't haskell sets be mathematical sets then?
15:50:58 <int-e> Cooler: so it's really more natural in Haskell to implement some balanced trees.
15:51:09 <GodThisNickRegis> because philosophy of maths?
15:51:17 <GodThisNickRegis> at some point, we have to rely on a definition
15:51:33 <Cooler> whats the mathematical definition of a set?
15:51:54 <Cooler> a bunch of keys with no duplicates>?
15:52:13 <EvanR> its a thing you dont want to be asked to define
15:52:28 <Cooler> is that not the definition?
15:52:35 <EvanR> its not a very good one
15:52:56 <EvanR> "a bunch" is just as good
15:53:17 <GodThisNickRegis> it's not great
15:54:42 <HaskellFromTheBo> ng.
15:54:44 <Cooler> hmm well
15:54:52 <Cooler> so what are applicative functors?
15:55:02 <Cooler> having some idea now about what functors are
15:55:04 <HaskellFromTheBo> hell if i know
15:55:47 <EvanR> functors you can apply
15:55:56 <EvanR> > Just (+1) <*> Just 2
15:55:57 <lambdabot>  Just 3
15:56:42 <johnw> Cooler: you may find introductory material on Haskell a much more efficient way to acquire these details, rather than asking here
15:56:57 <HaskellFromTheBo> Just 3 = Just x 3? or am i misreading the syntax?
15:57:18 <david_koontz> Just 3 = (Just 3) as in construct a new Just with the value 3
15:57:19 <EvanR> yeah you really need to run through a tutorial or something and for gods sake write some code
15:57:34 <EvanR> even LYAH would be better than this ;)
15:57:42 <david_koontz> harsh
15:57:58 <HaskellFromTheBo> johnw: "put the blunt down just for a second, don't get me wrong it's not a new method, inhale... exhale
15:58:16 <HaskellFromTheBo> "there's water inside, dont' smell it."
15:58:53 <HaskellFromTheBo> thanks david_koontz 
15:59:19 <david_koontz> it would be more accurate for me to say “it constructs a new Maybe of type Just 3”
15:59:29 <david_koontz> er, dang that’s wrong too
15:59:33 <johnw> that would not be accurate at all :)
15:59:37 <david_koontz> the type is Maybe, the constructor is Just
15:59:43 <johnw> the type is Maybe Int
16:01:01 <pdxleif_> forall (a : Type, x : t) -> Just x : Maybe a
16:01:02 <pdxleif_> erm
16:01:12 <pdxleif_> s/a/t/
16:02:20 <HaskellFromTheBo> "And every once in a while, Just may become Maybe, and never exist at all."
16:02:40 <Cooler> EvanR, well i read a LYAH
16:02:45 <HaskellFromTheBo> that's some quantum shit, yo!
16:02:55 <johnw> HaskellFromTheBo: if you could please stay on topic, thanks
16:02:59 <mpickering> Do new versions of stack insist on managing your ghc installation for you..?
16:03:04 <Cooler> and also a lot of tutorials didn't really help
16:03:11 <mpickering> I just tried "stack upgrade" and it started downloading a copy of ghc for me..
16:03:27 <HaskellFromTheBo> Will do, johnw 
16:03:31 <peddie> mpickering: there is a way to use the locally installed GHC, but it doesn't seem too reliable
16:03:39 <Cooler> and i have written some code, but its all using just functions so far
16:04:06 <Cooler> no functors or applicative functors and no monads either other than main::IO()
16:05:26 <mpickering> It seems strange to me that "stack upgrade" needs to download a copy of ghc
16:06:03 <Cooler> EvanR, whats a applicative functor?
16:09:20 <peddie> mpickering: in my experience, anything that stack isn't controlling (including paths, etc.) itself will cause it to fail in one way or another, so you kind of have to let it do what it wants
16:09:49 <mpickering> well I just installed 7.10.3 and now it seems happy to use that at least to upgrade so we'll see how far we get using a system ghc
16:10:01 <mpickering> thanks for your comments
16:10:32 <peddie> sorry, probably not too helpful -- good luck
16:15:55 <shanemikel> as an exercise (and It looks like I needed it, because it's tripping me up a bit) I decided to play around with json serialization/deserialization.. 
16:16:01 <hoot> Has anyone else noticed that Service Oriented Architectures in imperative languages basically mimic some
16:16:16 <hoot> oops. Didn't mean to send that yet
16:16:52 <hoot> Mimic some concepts of functional languages? 
16:17:19 <shanemikel> I'm wondering if there's something obvious I could have done to clean up the definition of ''Value, my first thought was, it would be nice to have sum type aliases
16:17:41 <shanemikel> http://lpaste.net/3210268293168365568
16:18:00 <shanemikel> but I know you wouldn't be able to get at the data in the type without the constructors
16:18:29 * hackagebot riak-protobuf 0.21.0.0 - Haskell types for the Riak protocol buffer API  https://hackage.haskell.org/package/riak-protobuf-0.21.0.0 (lambda_foo)
16:18:31 * hackagebot riak 1.0.0.0 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-1.0.0.0 (lambda_foo)
16:19:13 <shanemikel> hoot: distributed systems an concurrent systems are more vulnerable to side effect related problems.. it's only natural that they would do similar things, they're solving similar problems.. just from a different layer
16:22:00 <jle`> shanemikel: do you mean something like anonymous sums?
16:22:05 <jle`> like how we have anonymous products?
16:22:11 <shanemikel> I guess
16:22:14 <jle`> or, ad-hoc unions
16:22:18 <shanemikel> though never heard of 'em
16:22:31 <shanemikel> oh, do you mena tuples
16:22:37 <jle`> there is some proposed syntax for anonymous sums
16:22:42 <jle`> yeah, anonymous products are tuples
16:24:16 <shanemikel> got a link?
16:24:34 <shanemikel> not this is it? https://hackage.haskell.org/package/anonymous-sums-0.4.0.0/docs/Data-Sums.html
16:26:00 <shanemikel> jle`: actually, with a sum of more than a few types, that kind of thing is rather clumsy.. don't want to remember the way the type is enumerated.. I was thinking there might be a cleaner way with phantom types or classes or something
16:31:10 <Rotaerk> shanemikel: missing some context but maybe DSum is of interest to you?
16:31:21 <Rotaerk> I'm missing some *
18:43:22 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
18:43:22 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
19:04:37 <Moggle1> is there a way to run stack from outside a directory with a project in it?
19:04:43 <Moggle1> the --working-dir flag wasn't what i wanted
19:27:55 <mgsloan> Moggle1: --stack-yaml
19:28:05 <Moggle1> thanks.
19:38:45 * hackagebot bloodhound-amazonka-auth 0.1.0.0 - Adds convenient Amazon ElasticSearch Service authentication to Bloodhound.  https://hackage.haskell.org/package/bloodhound-amazonka-auth-0.1.0.0 (MichaelXavier)
19:43:58 <shanemikel> how can I get ghci to format datatypes that have show derived.. especially record types, in a readable way (for debugging and experimenting)
19:44:45 <shanemikel> for instance, only putting one factor per line in a record, or one entry in a list
19:44:50 <shanemikel> and doing indentation
19:45:56 <shanemikel> err, rather to pretty-print the output of show for derived datatypes
19:46:20 <shanemikel> err, rather to pretty-print the output of show for datatypes with show derived
19:50:49 <OhTrueful> @pl \s -> if (s=="test") then "yey" else "boo"
19:50:50 <lambdabot> flip (flip if' "yey" . ("test" ==)) "boo"
19:53:49 <EvanR> shanemikel: perhaps experiment with https://hackage.haskell.org/package/wl-pprint-1.2/docs/Text-PrettyPrint-Leijen.html
20:02:21 <pavonia> @hackage pretty-show  -- shanemikel
20:02:21 <lambdabot> http://hackage.haskell.org/package/pretty-show  -- shanemikel
20:04:27 <pavonia> shanemikel: You could also re-parse the Show string with haskell-src-exts and use it's pretty-printer to convert it back to a string
20:27:09 <shanemikel> awesome.. thanks pavonia -interactive-print flag to ghci + the pretty-show package
20:28:46 * hackagebot http2 1.5.2 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.5.2 (KazuYamamoto)
20:28:48 * hackagebot midair 0.1.0.0 - Hot-swappable FRP  https://hackage.haskell.org/package/midair-0.1.0.0 (TomMurphy)
20:38:46 * hackagebot midair 0.1.0.1 - Hot-swappable FRP  https://hackage.haskell.org/package/midair-0.1.0.1 (TomMurphy)
20:43:07 <OhTrueful> :q
20:43:46 * hackagebot midair 0.1.0.2 - Hot-swappable FRP  https://hackage.haskell.org/package/midair-0.1.0.2 (TomMurphy)
20:46:44 <tippeneinn> is there a way to pull specific data from hoogle for the .hoo files?
20:47:30 <tippeneinn> i could do hoogle data all, but I don't want the full database
21:13:40 <emmanuel_erc> Is it possible, with aid of lazy evaluation, to lazy produce a computation that doesn't need to start producing its results a particular location of its structure? (I hope that makes sense).
21:19:35 <emmanuel_erc> Never mind.
21:43:02 <Tendies> in using parsers, when you have something such as the "item" parser, i'm confused how this works: item :: Parser Char     item = \inp -> case inp of    [] -> []     (x:xs) -> [(x,xs)]
21:43:13 <Tendies> ill lpaste that h/o
21:46:00 <Tendies> http://lpaste.net/154399
21:46:04 <lyxia> Tendies: to parse a character, return the head of the string, the tail being what's left to parse.
21:47:16 <Tendies> lyxia: i dont think i was clear what i wanted to know there, maybe the paste is clearer
21:47:29 <lyxia> Tendies: what's the definition of Parser
21:47:34 <lyxia> isn't it a function
21:47:44 <lyxia> and what's the definition of parse
21:48:39 <Tendies> it applies the passed parser to the passed string
21:49:16 <lyxia> just like "p inp" isn't it
21:52:18 <Tendies> like i have to do "parse upper "parsethis"" for it to actually do the parse
21:52:21 <Tendies> upper "parsethis" 
21:52:24 <Tendies> doesnt work
21:53:08 <lyxia> can you be more specific than "doesn't work"
21:53:33 <Tendies> crashes the function
21:54:12 <Tendies> it gives a type error if i call it as just `upper "parsethis"'
21:54:36 <lyxia> it can't both crash the function at runtime and give a type error
21:56:30 <Tendies> heres what i see http://lpaste.net/154400
21:56:55 <Tendies> but in the previous code it appears as though the parser "p" is applied on inp by just saying p inp
21:57:38 <lyxia> well in the previous code it is applied actually as you said
21:58:51 <Tendies> why do i need to type `parse upper "parsethis"' but in the function, `upper "parsethis"' works
21:59:41 <lyxia> I don't think it would work.
22:00:02 <lyxia> are you sure it works
22:00:15 <lyxia> show the code
22:00:49 <Tendies> the first paste is the code of (+++)
22:01:51 <lyxia> but that's not the full code. Give me something that compiles to prove that "`upper "parsethis"' works"
22:02:04 <Tendies> i said that does not work
22:02:09 <Tendies> and i am asking why it does not work
22:02:58 <lyxia> Parser is apparently not synonymous with a function type.
22:03:03 <lyxia> so you can't apply it
22:04:41 <lyxia> Tendies: you can only apply something of type "a -> b"
22:23:26 <average> does this look weird, it's just cheese pasta & sauce ? http://i.imgur.com/zYYqt3V.jpg
22:24:49 <selckin> looks from a can
22:25:22 <average> the sauce is from a bottle i bought
22:25:34 <average> the pasta is from.. well.. a pack i bought
22:25:41 <average> the cheese is from.. a roll i bought
22:25:50 <average> so.. yeah i guess you could say it's from a "can"
22:29:40 <Athas> Where can I find a RegexLike instance for Text?
22:30:45 <average> selckin: btw, i actually boiled the apsta
22:30:45 <average> *pasta
22:31:06 <selckin> welcome to adult life
22:31:45 <average> right
23:13:51 * hackagebot download 0.3.2.4 - High-level file download based on URLs  https://hackage.haskell.org/package/download-0.3.2.4 (psibi)
23:53:25 <runeks> Is there a way to bind together (using >>=) two functions which return a result with a third function that takes the two results as (its only two) arguments? 
23:53:52 <scshunt> I'm not aware of a combinator to directly do that
23:54:21 <scshunt> but you can of course do it yourself or use do-notation
23:55:42 <runeks> scshunt: I will use do-notation then. I just wanted to know if I was missing some sleek trick wrt. binding.
23:55:48 <liste> > (,) <$> getLine <*> getLine -- runeks, you mean like this?
23:55:50 <lambdabot>  <IO ([Char],[Char])>
23:56:25 <runeks> liste: Oh, right, applicative. I guess I might be able to use that
23:56:26 <liste> > (,) `liftM` getLine `ap` getLine -- in Monad Land (which is nowadays in Applicative Continent)
23:56:27 <lambdabot>  <IO ([Char],[Char])>
23:58:15 <scshunt> ah right
23:59:01 <gfixler> > liftM2 (,) getLine getLine
23:59:03 <lambdabot>  <IO ([Char],[Char])>
23:59:03 <runeks> liste: It totally works. Although I'm having second doubts about readability.
23:59:21 <liste> runeks: check out gfixler's solution
23:59:30 <liste> it's basically the same thing
23:59:40 <liste> but more readable
