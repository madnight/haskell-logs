00:03:21 <pkmx> Is there an unsafe way to access the underlying `Any` within a `Dynamic`?
00:06:13 <jle`> pkmx: i suppose unsafeCoerce would do it
00:06:17 <jle`> oh, wait
00:06:20 <jle`> nvm
00:07:40 * hackagebot pandoc 1.17.0.3 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.17.0.3 (JohnMacFarlane)
00:07:40 * hackagebot metadata 0.4.3.0 - metadata library for semantic web  https://hackage.haskell.org/package/metadata-0.4.3.0 (KatsutoshiItoh)
00:21:33 <EvanR> pkmx: you can get the hidden constructor with this http://hackage.haskell.org/package/true-name
00:21:34 <Gurkenglas> phax, (\(Dynamic _ any) -> any)?
00:22:05 <Gurkenglas> ah, nvm
00:26:00 <pkmx> EvanR: thanks, i will look into that
00:34:15 <lazyWriter> in lucid, <g> elements, how do I specify attributes ?
00:34:19 <lazyWriter> https://github.com/jeffreyrosenbluth/lucid-svg/blob/master/src/Lucid/Svg.hs seems to show I can create a <g>
00:34:29 <lazyWriter> but I can't create a <g transform="translate(...,...)"> .... </g>
00:36:03 <Gurkenglas> Ctrl-F attributes
00:37:08 <lazyWriter> yeah, it shows how to set attributes to rect_/line_
00:37:11 <lazyWriter> but not to g_
00:37:17 <lazyWriter> https://hackage.haskell.org/package/lucid-svg-0.6.0.1/docs/Lucid-Svg-Elements.html#v:g_
00:37:26 <lazyWriter> in particular, in type sigantures, those with attributes have [Attribute] -> ....
00:37:28 <lazyWriter> whereas g_ does not have that
00:38:18 <Gurkenglas> Instead, it has an arg argument, lets look at the Term class
00:39:28 <lazyWriter> I will admit I'm a Lucid newb
00:39:44 <Gurkenglas> looks like termWith is what you want, since g_ in the source is 'term "g"' and termWith adds an [Attribute] argument
00:39:52 <Gurkenglas> So am I, this is the first I hear of that package :P
00:39:59 <lazyWriter> I think I want to use https://hackage.haskell.org/package/lucid-svg-0.6.0.1/docs/Lucid-Svg.html#v:with
00:40:11 <lazyWriter> which has the nice preoprty of "a -> [Attribute] -> a"
00:40:23 <lazyWriter> oh great ghc, may you help the blind lead the blind :-)
00:41:58 <lazyWriter> even better would be sighted help the sighted with ghc
00:42:09 <Gurkenglas> Dunno, maybe. I think 'termWith "g" attributelist' in place of 'g_' will work, but with may work too.
00:42:25 <Gurkenglas> You can also consult the source on rect_ and see how that does it if you want.
00:46:45 <lazyWriter> okay
00:46:48 <lazyWriter> got it working, with with
00:46:58 <lazyWriter> got it working with "Lucid.Svg.with"
00:59:46 <lazyWriter> I am opearting insider a "ReaderT ... (MaybeT ....) ... "
00:59:52 <lazyWriter> how do I trigger a "Nothing" ?
01:00:01 <lazyWriter> if I do "return $ foo", it's like "Just foo"
01:00:07 <lazyWriter> but I don't know how to return a Nothing to indicate failure
01:01:31 <jle`> lazyWriter: depending on how your type is organized, you can use mzero
01:01:44 <jle`> or empty
01:01:44 <lazyWriter> yeah, It looks like mzero or fail
01:01:49 <jle`> maybe not fail
01:01:53 <lazyWriter> but the key is 'depending on how your type is organized'
01:02:02 <lazyWriter> how do I check this and understand this piece by piece 
01:02:23 <jle`> the Alternative/MonadPlus instance for `ReaderT r m` defers to the MonadPlus instance for m
01:03:12 <jle`> for the behavior of the transformers in the `transformers` library, this pattern sort of implies that it'll trigger mzero on the "highest up" MonadPlus instance
01:03:23 <lazyWriter> dumb question: why does tthis go 'outside -> inside' ?
01:03:38 <lazyWriter> which piece of code shows that this goes outside -> inside for transformers ?
01:03:39 <jle`> but things like this are why it's not generally advisable to program directly towards monad transformers
01:03:49 <jle`> lazyWriter: what do you mean?
01:04:02 <lazyWriter> why does ReaderT have the first option to handle mzero ?
01:04:07 <lazyWriter> then it defers to MaybeT ?
01:04:25 <lazyWriter> why this ordering -- and what is my alternative to 'program directly towards monad transformers'
01:04:28 <jle`> MonadPlus m
01:04:28 <lazyWriter> what is my alternative ?
01:04:43 <jle`> your MonadPlus is (ReaderT ... (MaybeT ...))
01:04:59 <jle`> and the MonadPlus instance for (ReaderT r m) is implemented to follow mzero for 'm'
01:05:18 <lazyWriter> okay
01:05:21 <jle`> when you write 'mzero', you're writing mzero :: ReaderT r m a
01:05:33 <jle`> and so, to get the behavior, you look at the MonadPlus instance for ReaderT r m
01:05:44 <jle`> because it's mzero :: ReaderT r m
01:05:59 <lazyWriter> makes sense
01:06:01 <jle`> just like, if you wrote mempty :: [r], it'd look for the Monoid instance for [r]
01:06:01 <lazyWriter> thanks
01:06:13 <lazyWriter> what is my alternative to 'program directly towards monad transformers'
01:06:14 <jle`> if you wrote return True :: Maybe Bool, i'll look for the Monad instance for maybe
01:06:17 <jle`> etc.
01:06:23 <jle`> program your logic generically over interfaces
01:06:31 <jle`> and only constrain it over the interfaces you need
01:06:40 <lazyWriter> what is an example of this 'program your logic generallyically over interfaces'
01:06:45 <jle`> so instead of writing it for ReaderT r m a, write foo :: MonadPlus m => m a
01:07:08 <jle`> so you aren't programming against ReaderT, you're programming against all MonadPlus's
01:07:30 <lazyWriter> so you want me to do: MonadPlus m, MonadReader m => m a .... ?
01:07:54 <jle`> (MonadPlus m, MonadReader r m) => m a, if you only use mzero and 'ask'
01:08:10 <jle`> if you only use mzero and not ask, you can just do MonadPlus m => m a
01:08:29 <jle`> constrain it to the interfaces that your actual logic requires talking about
01:08:35 <koz_> Is there a general Catamorphism typeclass living somewhere? I'm looking at the Typeclassopedia for Foldable, and it mentioned that Foldable doesn't express the full power of catamorphisms.
01:09:13 <jle`> koz_: have you looked at the Foldable in recursion-schemes ?
01:09:22 <koz_> jle`: Nope. Will look now.
01:09:27 <jle`> or is that the Foldable you're referring to
01:09:28 <jle`> ah ok
01:09:50 <lazyWriter> jle`: damn, this is so insighftul, thanks!
01:10:13 <lazyWriter> it's like programming vs an interface vs programming vs an implementation
01:10:19 <koz_> lazyWriter: Exactly.
01:10:30 <jle`> np!  monad transformers have their role, but these days people usually don't program logic directly against monad transformers anymore for the most part
01:10:31 <koz_> Basically, try and kick the concreteness can down the road as far as you can.
01:10:34 <jle`> except for small one-offs
01:11:07 <jle`> sometimes your eventual implementation might not even be implemented using monad transformers
01:11:15 <lazyWriter> jle`, koz_: suppose I have (MonadPlus m, MonadReader r m) => m a .... how do I actually build up an concrete instance of "m" ? do I do that vis monad transforemrs, or is there a different way to do that?
01:11:35 <jle`> monad transformers gives you a "free" way to do it
01:11:37 <jle`> but there are other ways
01:11:57 <koz_> lazyWriter: It'd depend what particular m you're interested in.
01:12:09 <lazyWriter> liek data JlePlusReaderMonad ... ; instance JlePlusReaderMonad MonadPlus ... ; instance MonadReader JlePlusReaderMonad
01:12:15 <jle`> i'm fond of making my own monads from scratch 
01:12:17 <lazyWriter> and just implement those typecalsses manually ?
01:12:21 <jle`> and giving them MonadReader, MonadPlus instances
01:12:29 <jle`> but you have a lot of freedom here
01:12:42 <jle`> yup
01:12:56 <jle`> the haskell ecosystem actually has a rich variety of ways to roll your own monads
01:13:06 <koz_> jle`: s/monads/damn near anything
01:13:12 <jle`> heh indeed
01:13:35 <koz_> Heck, with Template Haskell, you can basically build your own DSL syntax on top of Haskell and program in that if that's what takes your fancy.
01:15:01 <jle`> lazyWriter: there's one cute way to do it that's been trendy recently, it's to build a non-recursive algebraic data type representing actions and then use 'Free' to turn it into a monad with sequencing
01:15:07 <koz_> As an aside, I'm trying hard to understand lenses, and I'm kinda failing at it.
01:15:20 <koz_> I suspect I just need to re-watch his talk and read the libraries more carefully.
01:15:21 <lazyWriter> jle`: can you point me to a tutorial on this?
01:15:22 <jle`> the advantage is that you get a lawful Monad instance for free, which is pretty neat
01:15:26 <lazyWriter> I've been hearinga bout free moand lately
01:16:17 <jle`> there's this -- http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
01:16:27 <jle`> but the documentation for the library actually explains things decently well too
01:16:57 <koz_> There was also something more recent talking about free monads and how they could do IO better than our current arrangement.
01:17:05 <koz_> But I can't track it down for the life of me...
01:18:33 <jle`> lazyWriter: but yeah, if you wanted to make a type that was MonadReader Int, MonadPlus, and could do IO, you could write data MyTypeF f a = Ask (Int -> f a) | Fail | IOAction (IO (f a))
01:18:38 <koz_> Also, jle`: I get the feeling that I'm not well-equipped enough mentally to fully grasp recursion-schemes.
01:18:45 <koz_> At least not presently.
01:18:52 <jle`> lazyWriter: and `Free MyTypeF` would be your monad that is MonadPlus, MonadReader Int, and MonadIO
01:18:59 <lazyWriter> whoa
01:19:17 <jle`> koz_: on the topic of lenses, i liked the lenses over tea blog series :3
01:19:23 <koz_> jle`: Link?
01:19:30 <jle`> lazyWriter: you'll have to write the MonadPlus, MonadReader Int, and MonadIO instances yourself
01:19:37 <jle`> s/you'll/you'd
01:21:23 <jle`> type MyType = Free MyTypeF; instance MonadIO MyType where liftIO io = Free (Pure <$> io)
01:21:36 <jle`> etc.
01:21:57 <jle`> alternatively, you could use monad transformers from the 'transformers' library, and use ReaderT Int (MaybeT IO)
01:22:12 <jle`> you have a variety of options :)
01:22:51 <dmj`> :k ReaderT Int (MaybeT IO)
01:22:53 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
01:22:53 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
01:23:57 <dmj`> @def data MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
01:23:58 <lambdabot>  Defined.
01:24:02 <dmj`> :k ReaderT Int (MaybeT IO)
01:24:04 <lambdabot> * -> *
01:24:09 <lazyWriter> okay, so http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Reader.html shows
01:24:18 <lazyWriter> if m has a MonadPlus, then "ReaderT r m" has MonadPlus
01:24:21 <lazyWriter> okay
01:25:01 <lazyWriter> https://hackage.haskell.org/package/base-4.4.1.0/docs/src/Control-Monad.html#mplus ==> why, for Maybe, is it
01:25:07 <lazyWriter> xs `monadPlus` ys = xs ?
01:25:16 <lazyWriter> xs `mplus` ys = xs ?
01:25:34 <jle`> read the line above
01:26:28 <lazyWriter> instance MonadPlus Maybe where    mzero = Nothing     Nothing `mplus` ys  = ys    xs      `mplus` _ys = xs
01:27:33 <lazyWriter> https://en.wikibooks.org/wiki/Haskell/MonadPlus
01:27:37 <lazyWriter> MonadPlus [] makes sense
01:27:46 <lazyWriter> MonadPlus Maybe is weird for just discarding 2nd solution
01:27:48 <lazyWriter> if both are Just's 
01:29:41 <jle`> it has to discard one or the other
01:30:07 <jle`> biasing on the first means that the <|> acts like a "choice" operator, this or that
02:07:24 <lazyWriter> https://gist.github.com/anonymous/7610a448bb1305e89856 how do I impelmente line 50 and line 54? I'm trying to promote "MonadLog" across ReaderT and MaybeT
02:14:24 <lyxia> lazyWriter: lift
02:17:16 <lazyWriter> of course, it's the outer monad's job of implementing "how to lift stuff across this monad"
02:37:47 <Gurkenglas> lazyWriter, log = lift . log for each of those
02:37:54 <lazyWriter> yeah
02:38:00 <lazyWriter> Gurkenglas: realized that :-)
02:38:10 <Gurkenglas> oh misread your last line before my last line then
03:38:27 <paldepind> `m` is a monad and I have a `m a`, a `m b` and a `a -> b -> m a`. How do I apply the function the the two monadic values?
03:39:06 <bennofs> :t liftA2
03:39:07 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:39:14 <bennofs> paldepind: ^^^
03:39:19 <bennofs> oops,
03:39:32 <bennofs> :t \f ma mb -> join $ liftA2 f ma mb
03:39:33 <lambdabot> Monad m => (a1 -> b -> m a) -> m a1 -> m b -> m a
03:39:34 <paldepind> But applicative is only for when the function does not return a monad.
03:39:50 <bennofs> yeah sorry I read too fast :D
03:40:04 <paldepind> bennofs, yes. Like that. Isn't there a standard function for that?
03:40:27 <bennofs> paldepind: I don't think there is. 
03:43:19 <paldepind> Sad :( Seems quite useful to me.
03:47:32 <lazy-seq> Hi, I'm trying to debug an issue with the Debug.Trace module
03:47:41 <lazy-seq> however, the trace function doesn't provide any output
03:48:11 <lyxia> lazy-seq: are you sure it is being evaluated
03:48:38 <lazy-seq> Yes, I added traces to cases that fail
03:48:43 <lazy-seq> and the cases fail, but no output
03:49:26 <lyxia> that's odd. Can you paste it?
03:51:40 <lazy-seq> Well, I think it is too big context-wise to paste
03:52:38 <lazy-seq> the actuall line is:
03:52:40 <lazy-seq> where     matchConnectAcl uri (ConnectStringAcl acl) = trace ("Comparing " ++ show uri ++ " with " ++ show (aclUri acl)) (uri == (aclUri acl))
03:52:48 <lazy-seq> but I don't think that will be of any use
03:53:10 <lazy-seq> I'm using conduit and parMap
03:53:30 <lazy-seq> not sure if that will thwart my output
03:54:04 <lazy-seq> can it be influenced by compiler  flags?
03:54:06 <olpery> aloah
03:55:46 <olpery> give a list comprehension like [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50] !! 3
03:56:07 <lyxia> lazy-seq: I don't think so.
03:56:12 <olpery> where i grab element 3... is Haskell smart enough to compute element 3 directly, or does it always run through the list?
03:57:13 <lazy-seq> lyxia: mmm, it is something of a mystery to me why it doesn't work (new to Haskell)
04:01:47 <lyxia> With the binary library I don't see a way to write both a get and a put without duplicating their structures. Does a solution for this exist in some other package? Or is there something fundamental making a bidirectional binary impossible?
04:05:10 <bennofs> lyxia: I haven't used it myself, but the description of https://hackage.haskell.org/package/codec seems to fit your problem description
04:06:34 <lyxia> bennofs: that's... exactly it
04:06:44 <lyxia> cool, thanks
04:06:53 <Industrial> Hi. I have a problem installing ghc-mod with cabal; https://gist.github.com/Industrial/834be5e11f1710228dd5
04:10:26 <lyxia> Industrial: have you tried installing happy?
04:11:10 <Industrial> What's that? I need this ghc-mod for a plugin for a code editor (atom)
04:11:16 <Industrial> lyxia: ^
04:11:33 <lyxia> it is present in the build-tools but not in build-depends of the package haskell-src-exts
04:11:40 <lyxia> Industrial: it's a haskell parser generator
04:12:35 <lyxia> https://github.com/haskell/cabal/issues/220 seems like a known problem
04:13:17 <lyxia> just cabal install happy
04:14:12 <Industrial> right, thanks, seems like it's working :-)
04:15:05 <lyxia> great!
04:15:45 <roelof> Hello, I have this function and test function : http://lpaste.net/156725 .If I want to test it with floats and doubles do I need to use seperate functions or can I use some sort of generator 
04:18:44 <Guest51519> http://shrinkmy.com/ZFmSN1C6
04:21:54 <bennofs> Is there already a package for the following: say I have functions f1..fN which are all actions in a Monad m and take arguments of types T1..Tn (not all functions require all of those arguments). Also, each function fx returns a value of type Tx. Now I want to chain these functions without having to keep track manually of all the values, relying on typeclasses for the "plumbing"
04:21:54 <phaskell-1> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
04:24:14 <lkj> is there a good example of wrapping C++ code in a C interface for FFI?
04:25:10 <cocreature> lkj: llvm-general might be worth looking at
04:25:42 <lkj> cocreature I'm  looking for more of a hello-world level gist
04:26:02 <lkj> oh i see sorry
04:26:16 <lkj> i guess this is a different way to do it
04:27:42 <cocreature> lkj: the idea is to write a simple c++ file containing the necessary wrappers inside of an extern C block, those wrappers then call the c++ functions. you can simply put that c++ file in the c-sources in your cabal file
04:28:11 <Guest51519> http://shrinkmy.com/ZFmSN1C6
04:31:30 <lyxia> roelof: you could use the generator for Either Float Double. you still need to write the name of the property twice in "either prop_Identity prop_Identity" though.
04:31:36 <lkj> urgh damn bot
04:32:45 <roelof> lyxia:  oke, then that is almost the same as writing a prop-function for both , so I have one for float and one for double 
04:33:54 <lyxia> yeah you have to specialize the prop at some point
04:34:00 <lyxia> by hand
04:34:04 <roelof> lyxia:  or do I misunderstood what you mean 
04:34:36 <roelof> oke, thanks for the help, lyxia 
04:34:42 <seishun> how does one debug haskell?
04:34:54 <seishun> the wiki has this: A common idiom to trace a function is:
04:34:54 <seishun> myfun a b | trace ("myfun " ++ show a ++ " " ++ show b) False = undefined
04:34:54 <seishun> myfun a b = ...
04:35:15 <seishun> but adding this to my function causes it to have different behavior
04:35:29 <lyxia> how so
04:35:51 <seishun> how should I know
04:35:56 <seishun> I don't even understand this synta
04:36:07 <seishun> is there any saner way to debug haskell?
04:36:10 <lyxia> what does it do differently
04:36:31 <seishun> the program terminates with a different error
04:36:47 <lyxia> it has to force a and b to print them
04:37:35 <lyxia> so if an error is in a and b, it will fail there before whatever other error should happen afterwards without the annotation
04:37:44 * hackagebot mondo 0.2.0.0 - Haskell bindings for the Mondo API  https://hackage.haskell.org/package/mondo-0.2.0.0 (mbg)
04:38:43 <lyxia> you can set breakpoints in ghci, but I've never used them
04:39:09 <lyxia> and you can get a kind of stack trace with the right compiler options
04:39:43 <lyxia> with stack it's just stack build --trace
04:44:05 <j0llyr0tten> yo!
04:44:29 <j0llyr0tten> i keep getting `Not in scope: data constructor¬
04:44:32 <seishun> ok, trying stack now. Trying to get a stack trace using the commands provided on the wiki gave me undecipherable errors
04:44:58 <j0llyr0tten> grrrrrrr, why??? can i not do - :type Bool    ?
04:45:23 <j0llyr0tten> if i can do - :type False    why can i not do - :type Bool     ?
04:45:26 <seishun> Bool is a type, not a value
04:45:44 <j0llyr0tten> and don't type have types?
04:46:33 <seishun> not as far as I know
04:46:36 <seishun> :i Bool
04:46:41 <kaol> Types have kinds. You could write :kind Bool instead.
04:46:48 <seishun> :k Bool
04:46:49 <lambdabot> *
04:48:42 <lyxia> ghci tells you that it's looking for a data constructor, Bool is a type constructor.
04:49:52 <seishun> >stack will use the GHC on your PATH
04:49:58 <seishun> should I be worried about this?
04:50:09 <seishun> I assume it's going to be using GHC from haskell platform
04:51:01 <j0llyr0tten> :k Bool
04:51:03 <lambdabot> *
04:51:21 <j0llyr0tten> uh? *
04:51:30 <kaol> :k Maybe
04:51:31 <lambdabot> * -> *
04:51:33 <lyxia> I don't know how stack interacts with the platform
04:51:41 <j0llyr0tten> lambdabot: please explain *
04:51:53 <lyxia> it's the kind of types
04:51:59 <kaol> :m Maybe ()
04:52:01 <kaol> :k Maybe ()
04:52:02 <lambdabot> *
04:52:14 <j0llyr0tten> :k False
04:52:15 <lambdabot> Bool
04:52:22 <j0llyr0tten> :t Bool
04:52:23 <lambdabot>     Not in scope: data constructor ‘Bool’
04:52:23 <lambdabot>     Perhaps you meant variable ‘bool’ (imported from Data.Bool)
04:52:36 <narendraj9> :k Bool
04:52:37 <lambdabot> *
04:52:41 <j0llyr0tten> last one, sorry ... :t Bool
04:52:52 <lyxia> You can PM lambdabot
04:53:08 <j0llyr0tten> lyxia: thank you, good to know!
04:57:03 <inad922> hello
04:57:46 <inad922> I'm trying to understand TransformListComp and ParallelListComp but I get errors with the following -> https://gist.github.com/jakab922/67174b1a2542e73f5104 code.
04:57:57 <inad922> Errors are included
04:58:23 <inad922> Could someone explain me why can't I use filter in the way I use it in the then clause of the list comprehension?
04:59:37 <mgsloan> lyxia: It will attempt to use the platform installed GHC and global DB if available.  Best to uninstall the platform
05:00:33 <bennofs> is there a way to define T with constructors A and B such that 'A :: T and 'B :: * -> T ?
05:00:45 <bennofs> (where 'A and 'B are the promoted constructors of T)
05:00:56 <bennofs> I'm using GHC 7.10
05:03:15 <bennofs> oh, it seems GHC allows promoting existentially quantied types! so data T = A | forall s. B s works
05:07:45 * hackagebot concurrent-rpc 0.1.0.0 - An abstraction for inter-thread RPC based on MVars  https://hackage.haskell.org/package/concurrent-rpc-0.1.0.0 (LarsPetersen)
05:15:15 <lyxia> inad922: it seems a then clause expects a function that doesn't look at the contents of the list, of type forall a. [a] -> [a]
05:17:46 <seishun> <lyxia> with stack it's just stack build --trace
05:17:53 <seishun> how do I run it so that I get traces?
05:18:18 <lyxia> +RTS -xc
05:18:19 <inad922> lyxia: I see. What's the forall a. [a] -> [a] type? I mean what's the "forall a." prefix?
05:19:01 <seishun> lyxia: getting "the flag -xc requires the program to be built with -prof" followed by a page of help
05:20:38 <seishun> googling stack traces for stack is impossible
05:20:52 <EvanR> check stack overflow
05:20:59 <EvanR> for stack stack traces
05:21:26 <EvanR> wait, we have stack traces now?
05:24:58 <lyxia> inad922: It's a universal quantifier. This is what implicitly binds a when you write :: [a] -> [a]
05:25:16 <lyxia> inad922: it just means that for any type a, this function has type [a] -> [a].
05:25:32 <inad922> lyxia: Ah I see. 
05:25:45 <inad922> lyxia: Can I have one more question?
05:25:53 <lyxia> just one
05:25:56 <lyxia> jk
05:26:14 <inad922> There is the "oldest k tbl" example on https://ocharles.org.uk/blog/guest-posts/2014-12-07-list-comprehensions.html
05:26:28 <seishun> "stack exec +RTS -xc my-thing-exe" is this how I'm supposed to run it?
05:26:36 <inad922> What I don't understand here is what't the by keyword(?) there
05:26:52 <lyxia> seishun: oh you're passing +RTS to stack here
05:26:53 <inad922> 't -> 's
05:27:00 <lyxia> stack exec my-exe -- +RTS -xc
05:27:48 <seishun> still no stack trace
05:28:21 <EvanR> ah those stack traces
05:28:36 <lyxia> EvanR: what should they be called
05:29:31 <EvanR> i dont really get what -xc does so no idea
05:30:26 <lyxia> inad922: it is the "then by" clause explained in your schoolofhaskell link
05:30:36 <seishun> is there any way to find out what arguments a function that errored was called with, without modification to the code?
05:30:54 <lyxia> EvanR: you know what -prof does?
05:31:04 <EvanR> sort of
05:31:35 <lyxia> among other things it keeps track of a stack of call-sites
05:31:52 <lyxia> -xc (apparently) prints this stack whenever an exception is raised
05:31:52 <inad922> lyxia: Ah yeah I realized that that "then f by g" is an expression
05:32:02 <EvanR> interesting
05:40:30 <seishun> uh, what the hell. I changed the error string and now the program terminates with a different error
05:40:39 <seishun> [] -> error ("Couldn't parse full identifier ")
05:40:53 <seishun> [] -> error ("Couldn't parse full identifier " ++ show tree ++ " " ++ show identifier ++ " " ++ show strongonly)
05:41:19 <seishun> this shouldn't change the behavior of the program no matter how I look at it
05:42:16 <lyxia> I said it earlier, if there is an error in tree or identifier, the latter is going to raise it before encountering the error you wrote there.
05:48:50 <EvanR> > fix error
05:48:51 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
05:57:08 <seishun> well I found the mistake but it was mostly luck
05:57:19 <seishun> is there a tutorial that teaches how to debug haskell?
05:58:00 <seishun> because apparently conventional methods don't apply here
05:58:16 <EvanR> https://wiki.haskell.org/Debugging
05:59:04 <seishun> that's basically a mishmash of various tools
05:59:26 <seishun> without a detailed explanation of any
05:59:41 <EvanR> https://wiki.haskell.org/Memory_leak
06:00:02 <EvanR> they have links to the various tools
06:00:12 <EvanR> the blog posts at the bottom of memory leak are ok
06:00:45 <EvanR> i agree a one-stop-shop which has a detailed step by step of each technique would be awesome, especially for infinite loops
06:06:29 <ongy> How *bad* is unsafePerformIO? Is it "stay away at all costs" or more "use it if you know what you are doing"?
06:08:22 <hexagoxel> i always know what i am doing until i mess up.
06:08:58 <EvanR> one case where unsafePerformIO is ok is if the IO action doesn't actually use any IO
06:09:21 <EvanR> seems pointless but it's a good place to start
06:09:50 <joachifm> ongy: if you think you need it and you're not writing ffi, rethink your approach
06:10:25 <EvanR> next on the ladder to haskell hell is unsafePerformIO is ok when the IO action doesn't have any side effects
06:10:47 <EvanR> for example using it for pure ffi calls
06:11:01 <ongy> is it ever usefull outside ffi?
06:11:06 <EvanR> this is still tricky though
06:11:56 <ongy> tricky? as far as I understand it it should be ok when I have an IO action that has no sideeffects on the world and is deterministic (does not get affected by the world)
06:12:19 <EvanR> yes but combined with FFI you might mess up
06:13:07 <boggle> hey, recently switched my distro to arch linux. what's the best way to set up my haskell environment? what should i let the package manager handle vs. install through hackage?
06:13:09 <EvanR> so another case is using it for no-side-effect-code totally within haskell
06:13:21 <joachifm> ongy: can you give an example of such an IO action that does anything interesting?
06:13:24 <EvanR> also tricky since you need to be careful how you use the IO
06:14:34 <joachifm> ongy: I can't think of any, except for low-level performance critical code, where you're better off using existing libraries
06:14:43 <mannyz> how to access google cache version of the page when you don't get an arrow to click on it? i know it is still cached on google because translate option works
06:14:45 <mannyz> uhm wrong channel
06:15:03 <EvanR> theirs a good summary of weirdness that can happen when trying to use unsafePerformIO for a non trivial purpose on hackage https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Unsafe.html
06:16:14 <lpaste> ongy pasted “unsafePerformIO” at http://lpaste.net/156733
06:16:29 <ongy> the integer constants are wrong, I just took out the hsc code in there
06:16:47 <EvanR> are you trying to do IP4 -> String ?
06:17:28 <EvanR> are you sure that this CString can't be modified by any actor?
06:17:41 <EvanR> or the Ptr IP4
06:20:10 <ongy> yes and yes, since both of them are local to this function, one is created by the `with' (with a Storable instance of IP4) and the other is from the allocaBytes
06:20:37 <EvanR> oh, IP4 is a normal value passed in
06:21:01 <EvanR> that should work with UPIO
06:21:28 <EvanR> (as long as inet_ntop satisfies certain assumptions)
06:28:07 <jgoux> Hi
06:28:57 <ij> isn't "a <* b" the same as "x <- a; b; x"?
06:29:23 <jgoux> is there a name for this function signature : [a, b] -> [f, g] -> [f(a), g(b)]
06:29:37 <jgoux> I limited to two elements, but no matter the number of elements
06:29:46 <EvanR> :t zipWith (&)
06:29:47 <lambdabot> [a] -> [a -> c] -> [c]
06:30:02 <jgoux> a list of values, a list of functions, and the result is the application of each function to the corresponding value with the same index
06:30:39 <EvanR> @djinn [a] -> [a->b] -> [b]
06:30:39 <lambdabot> Error: Undefined type []
06:31:47 <s_aly> can one implement the concept of pointers in haskell?
06:31:58 <maerwald> it already is I believe
06:32:05 <s_aly> Like if one wanted to implement certain data structures.
06:32:13 <maerwald> be more specific
06:32:15 <ongy> Foreign.Ptr exists if you want that
06:32:16 <EvanR> its not unheard of to have an IntMap and then your Int are pointers
06:32:17 <pavonia> ij: x has to be applied to b. Beside that, (<*) operates on Applicatives
06:32:20 <s_aly> linked lists.
06:32:27 <maerwald> s_aly: what kind
06:32:28 <pavonia> ij: Err, b to x
06:32:30 <EvanR> with the same level of safety as pointers
06:33:03 <s_aly> doubly linked lists for integers.
06:33:25 <EvanR> you might want a zipper for that
06:33:35 <ij> pavonia, I'm talking about things that are both Monads and Applicatives here.
06:33:48 <maerwald> https://stackoverflow.com/questions/9732084/how-do-you-represent-a-graph-in-haskell
06:33:58 <EvanR> or a general graph yeah
06:34:08 <ij> pavonia, And what do you mean "has to be applied"? Isn't <*/*> like const/seq?
06:34:13 <pavonia> ij: But even then it's wrong, because the latter requires a Monad instance
06:34:24 <maerwald> I think this answer http://stackoverflow.com/a/9742998 is the better one
06:35:33 <pavonia> ij:  a <* b is do { x <- a; b; return x }
06:35:53 <ij> yeah, sorry I had a "return x" in my code
06:35:59 <s_aly> that is interesting
06:36:54 <maerwald> tying the knot is a horrible technique though that very likely will give you brain cancer, but here's doubly linked list with that approach https://wiki.haskell.org/Tying_the_Knot#Migrated_from_the_old_wiki
06:37:22 <EvanR> ah its maerwald 
06:37:49 * hackagebot twitter-types 0.7.2.1 - Twitter JSON parser and types  https://hackage.haskell.org/package/twitter-types-0.7.2.1 (TakahiroHimura)
06:38:11 <maerwald> EvanR: ?
06:38:23 <ij> pavonia, So you do agree <* is { x <- a; b; return x }? So these should be the same? http://sprunge.us/FOWA
06:38:51 <s_aly> tying the knot is indeed gonna give one a tough time.
06:39:12 <seishun> I have "data Node = ClassNode { childNodes :: [Node] } | EnumNode :: {childNodes :: [Node]}" How would I write a function that takes a Node (either EnumNode or ClassNode) and adds a Node to its childNodes? The only solution I can think of is to pattern match and duplicate the unwrapping/wrapping for both constructors
06:39:14 <maerwald> I tried it for a data structure that is more complicated than doubly linked list... 
06:39:19 <maerwald> just don't try
06:39:32 <pavonia> ij: It should work if you use parentheses around "flip brReadSome (2^15) $ responseBody res"
06:39:55 <pavonia> ij: (<*) has a stronger precedence than ($)
06:40:26 <ij> But it typechecks.
06:41:08 <s_aly> well technically what I wanted to implement was a skip list. This would be a nightmare with "Tying the knot"
06:41:20 <maerwald> s_aly: look for a library that already implements what you need... if it doesn't exist, use something like fgl to write it easier...
06:41:36 <pavonia> ij: It has a different meaning
06:42:07 <EvanR> s_aly: its possible to do anything with IORefs or FFI to C if you really want to, but its easier to implement functional data structures in haskell
06:42:11 <pavonia> Hhm, or maybe not
06:42:30 <pavonia> ij: What means "doesn't work" in your paste?
06:42:37 <maerwald> if the data structure in question can be easily implemented in a functional way that is
06:43:13 <maerwald> I'd use IORef/C really as last resort
06:43:30 <ij> pavonia, Has a different behaviour. The manual one gets data, the <* one closes connection, doesn't return data and whines on stderr about it.
06:43:39 <maerwald> @hackage tskiplist
06:43:40 <lambdabot> http://hackage.haskell.org/package/tskiplist
06:43:43 <EvanR> the implication is that its a functional datastructure, not a functionalization of something like a skip list
06:44:28 <ij> pavonia, You're right. I thought it wouldn't typecheck since "responseBody res" probably wasn't a monad. But it was.
06:45:37 <s_aly> cool!
06:46:03 <ij> yup
06:46:22 <ij> It's so weird to have something like this typecheck a different way.
06:50:29 <dalastboss> can anyone who has used megaparsec offer some insight -- i've been trying to fix a bug for a while
06:50:39 <dalastboss> but not sure whats going wrong
06:51:28 <puregreen> dalastboss: can you describe your bug?
06:52:19 <dalastboss_> oops, connectivity
06:52:31 <dalastboss_> but yes this is my problem:
06:52:39 <dalastboss_> i run this parser on a source file http://pastebin.com/3QmpkJ5C
06:53:08 <dalastboss_> i see 1, 2, 3, and 4 output in order to stdout
06:53:21 <dalastboss_> but then I get an error
06:53:28 <dalastboss_> "expecting expression"
06:53:47 <dalastboss_> except, the very next line after the "trace 4" parses an expression
06:55:01 <puregreen> hm, no, I haven't worked with indentation combinators
06:55:22 <dalastboss_> dang
06:56:20 <Myrl-saki> Why does group check only adjacent elements, but nub checks all elements against each other?
06:57:02 <hodapp> Question from elsewhere: Does anyone know the font in this editor? http://tinyurl.com/nfevygz
06:57:46 <EvanR> :t group
06:57:47 <lambdabot> Eq a => [a] -> [[a]]
06:57:50 <EvanR> :t nub
06:57:51 <lambdabot> Eq a => [a] -> [a]
06:58:13 <Myrl-saki> EvanR: group is O(n) and nub is O(n^2)
06:58:15 <EvanR> group is for speed, nub is for impressing company
06:58:31 <Myrl-saki> EvanR: wut
06:58:36 <Myrl-saki> Also, like...
06:58:42 <EvanR> also they do two different things
06:58:51 <Myrl-saki> EvanR: Yes, but they treat their input similarly.
06:58:51 <EvanR> why would they be implemented the same way
06:59:26 <EvanR> are you looking for a group-like half-nub
06:59:55 <Myrl-saki> EvanR: No.
07:00:04 <Myrl-saki> EvanR: I'm just curious why it was implemented this way.
07:00:10 <EvanR> also i thought nub actually doesnt compare everything to everything else, it uses filter
07:00:28 <Myrl-saki> EvanR: Hmmm...
07:00:39 <EvanR> which is still n^2 but
07:00:51 <EvanR> potentially better
07:01:01 <Myrl-saki> EvanR: Yeah, it uses filter.
07:01:27 <Myrl-saki> EvanR: But why not `map head . group . sort`
07:01:33 <Myrl-saki> O(n log n)
07:02:11 <EvanR> maybe because nub can outperform that if you dont have many unique values
07:02:35 <Myrl-saki> EvanR: Ah, true.
07:02:54 <EvanR> but not better than n
07:03:31 <EvanR> not sure how good sort is
07:07:01 <dalastboss_> so I've converted my parser into a non-indentation based one that exhibits the same issue:
07:07:04 <dalastboss_> http://pastebin.com/dCp60t4H
07:07:09 <hebg> @pl (\ xs n x -> take (n - length xs) (repeat x) ++ xs)
07:07:09 <lambdabot> flip =<< ((flip . ((++) .)) .) . flip flip repeat . (((.) . take) .) . subtract . length
07:07:20 <xa0> ...
07:07:36 <EvanR> so
07:07:42 <xa0> how does pl work?
07:07:47 <EvanR> the @pl command produces something
07:07:57 <EvanR> but does it try to make it "optimal" ?
07:07:57 <xa0> no i know what it does, but how
07:08:00 <dalastboss_> puregreen if you are still up to the challenge
07:08:43 <ongy> Myrl-saki: iirc nub doesn't reorder values, so using sort in the implementation would change it
07:08:59 <puregreen> dalastboss_: can you paste the full source so that I'd be able to compile it? with definitions for ‘expr’ and so on
07:09:08 <dalastboss_> certainly!
07:09:11 <boggle>  /lastlog boggle
07:09:15 <boggle> lul
07:09:31 <boggle> hey, recently switched my distro to arch linux. what's the best way to set up my haskell environment? what should i let the package manager handle vs. install through hackage?
07:10:52 <dalastboss_> the full project is here
07:10:54 <dalastboss_> https://github.com/zachhalle/Hudson
07:11:04 <dalastboss_> i'm working in src/Parser.hs right now
07:11:20 <Myrl-saki> ongy: What do you mean?
07:11:42 <EvanR> nub is stable
07:11:55 <firefall> Hi I read that functions in Haskell dont have side-effects. What does that mean?
07:11:59 <Myrl-saki> EvanR: sort is stable too.
07:12:11 <EvanR> actually im not sure if nub being stable makes sense
07:12:24 <Myrl-saki> Oohhh
07:12:27 <Myrl-saki> I get his point now.
07:12:44 <Myrl-saki> I see.
07:12:51 <EvanR> the first occurence of each unique value wont be reordered relative to the others
07:13:14 <Myrl-saki> Yes.
07:13:52 <dalastboss_> puregreen I pushed the latest version, including the test it barfs on
07:16:38 <pavonia> firefall: It means whenever you evaluate a function with the same input it yields the same output without having any other effects such as silently changing global state, deleting of files or launching missiles
07:17:32 <boggle> firefall: i'm no expert, but as i understand it. functions cannot arbitrarily change the values of variables outside them (like gloal variables).
07:17:49 <osense> hello
07:18:04 * hackagebot editpipe 0.1.0.0 - Edit stdin using an editor before sending to stdout.  https://hackage.haskell.org/package/editpipe-0.1.0.0 (puffnfresh)
07:18:05 <osense> could someone enlighten me as to what is going on here: http://lpaste.net/156737 ?
07:18:05 <boggle> firefall: functions can only return side effects, not change the values of unrelated variables in the function body
07:18:42 <EvanR> interesting way to describe it, returning side effects ;)
07:19:01 <EvanR> so if anything, they arent side anymore
07:19:24 <ongy> no side effects is the most fun about learning haskell coming from C
07:19:53 <boggle> firefall: as pavonia said, this means the same function will always give the same results given the same arguments. this is called referential transparency, and it makes reasoning about your code much easier since you don't need to worry about changes to some global variable ocurring outside the function changing the output of the function
07:20:01 <EvanR> no no
07:20:07 <EvanR> that is not referential transparency
07:20:12 <lyxia> ongy: can you try eta-expanding the definition of liftMap
07:20:15 <boggle> EvanR: please correct me
07:20:21 <lyxia> ongy: that looks like monomorphism restriction
07:20:28 <EvanR> youre describing purity
07:20:34 <ongy> lyxia: I think you wanted to highlight osense ?
07:20:38 <lyxia> osense: 
07:20:42 <lyxia> sorry ongy 
07:20:45 <ongy> np
07:20:46 <lyxia> and thanks
07:21:38 <hexagoxel> @where mmr
07:21:38 <lambdabot> https://wiki.haskell.org/Monomorphism_restriction
07:21:42 <osense> lyxia: as in 'liftMap g = liftA (second (fmap g))'? Yes, that works fine
07:22:00 <osense> is it because 'fmap f' is getting bound to a specific applicative for some reason?
07:22:03 <boggle> ahh, should have known i wasn't qualified to field that one.
07:22:27 <lyxia> I meant liftMap x = liftA (second (fmap f)) x, but the point was for the definition to have an explicit argument
07:22:36 <osense> ah
07:23:00 <osense> yeah, that works as well
07:23:03 <firefall> pavonia: boggle: thank you very much now I got it
07:23:19 <EvanR> boggle: referential transparency relates to the idea of substituting equals for equals, when you can legally substitute one expression for another equivalent one, then youre in a referentially transparent context
07:23:33 <lyxia> osense: the reason is that if you write a single identifier on the LHS: "liftMap = ...", it will not infer an overloaded type for it
07:23:42 <EvanR> in haskell "equivalent" has to do with the = sign
07:23:48 <puregreen> dalastboss_: (still building dependencies)
07:24:14 <lyxia> osense: you either need to eta-expand, give it a type signature, or turn off monomorphism restriction
07:24:24 <dalastboss_> OK, no worries! Thanks so much for taking a crack at this. To run you do "stack exec hudsonc <file name>"
07:24:25 <EvanR> substitutability lets you use equational reasoning
07:25:08 <osense> lyxia: interesting, I will need to read up on that. Thank you!
07:26:33 <lyxia> yw
07:28:04 * hackagebot text-show 3.1 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.1 (ryanglscott)
07:29:01 <boggle> pavonia: one neat thing about all this is that since the compiler guarantees your functions will only return values, not arbitrarily change values that will affect the evaluation of other functions, a clever compiler (GHC) can abstract over the evaluation order. this allows you to get parallelism for free without having to bother with expressing concurrency. if the compiler guarantees a function 
07:29:07 <boggle> evaluation won't affect the outside world, it's easy to plug it into something like the par monad and execute it on as many cores as you have, or plug in the repa module and execute stuff in parallel on the gpu.
07:29:39 <EvanR> supercomputing made easy!
07:30:10 <ongy> but I think haskell makes optimizing code for speed hard (compared to imperative+strict languages)
07:32:41 <EvanR> well, there are ways that imperative languages make optimizing hard
07:32:46 <EvanR> (for the compiler)
07:33:20 <EvanR> of course the programmer always knows better and will often want to write the machine code by hand
07:34:25 <boggle> ongy: it's definitely way over my head. i never have any idea what i'm looking at when i read through an example of optimizing something.
07:35:16 <EvanR> immutable data can really help optimize certain operations
07:35:26 <EvanR> and reduce memory usage through sharing
07:36:42 <inad922> When I'm translating with ghc is there a way to dump desugared versions of expressions of ghc extensions?
07:37:36 <puregreen> dalastboss: I used this function
07:37:37 <puregreen> http://lpaste.net/156739
07:37:49 <puregreen> (everywhere instead of ‘trace’)
07:38:00 <lyxia> inad922: there's a -ddump-ds, I don't know what it does exactly
07:38:05 <kjka> what function do I use to convert CDouble -> Double ?
07:38:13 * hackagebot BlogLiterately 0.8.2 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.2 (BrentYorgey)
07:38:15 * hackagebot reverse-arguments 0.1.0.0 - Reverse the arguments of arbitrary functions.  https://hackage.haskell.org/package/reverse-arguments-0.1.0.0 (JonasScholl)
07:38:17 <kjka> can't seem to find anything on hoogle
07:38:23 <puregreen> dalastboss: and I got the following result: http://lpaste.net/156740
07:38:25 <EvanR> kjka: realToFrac ?
07:38:37 <lyxia> inad922: there's a lot of -ddump-* options you'll probably find something close to what you want there
07:39:28 <ongy> EvanR: I don't want to do the assemblers job... have you ever seen the assembler guide from Intel? ~1800 pages
07:39:33 <lyxia> kjka: CDouble is defined as a newtype around Double
07:40:14 <kjka> EvanR realToFrac works, what exactly is the relationship between Fractional and Double?
07:40:23 <dalastboss> huh
07:40:26 <EvanR> Double is an instance of Frctional
07:40:31 <dalastboss> not sure why "before 2" occurs multiple times
07:40:33 <ongy> compiler not assembler job, but doesn't change the fact that writing efficient computer code is hard these days
07:40:36 <EvanR> Fractional is a type class
07:40:44 <EvanR> :t (/)
07:40:45 <lambdabot> Fractional a => a -> a -> a
07:40:50 <EvanR> :t fromRational
07:40:51 <lambdabot> Fractional a => Rational -> a
07:40:51 <kjka> lyxia : how do you extract the underlying type from the typeclass?
07:40:54 <puregreen> dalastboss: yep, me neither
07:41:02 <puregreen> looking at the actual thing that is being parsed now
07:41:38 <lyxia> kjka: It's not a typeclass. Here's a lambda: \(CDouble x) -> x
07:42:39 <puregreen> dalastboss: interesting
07:43:03 <puregreen> at the very beginning the input is “a + b + c ...” and it should be “let sum = a + b + c ...”
07:43:11 <kjka> lyxia sorry meant to say newtype, not typeclass
07:43:36 <Myrl-saki> @pl zip3 <*> tail <*> (tail . tail)
07:43:36 <lambdabot> zip3 <*> tail <*> (tail . tail)
07:43:43 <Myrl-saki> No cleaner way?
07:44:20 <mniip> it's already point-free what do you want
07:44:34 <Myrl-saki> mniip: lol
07:44:43 <dalastboss> puregreen: ah true
07:44:44 <Myrl-saki> mniip: tail . tail looks too redundant to me.
07:44:59 <dalastboss> blockBinding doesn't even try to parse the let though, although it should
07:45:09 <dalastboss> because the inBinding is wrapped in a try
07:45:09 <mniip> :t sequence . take 3 . tails
07:45:10 <lambdabot> [a] -> [[a]]
07:45:30 <mniip> no wait that's wrong
07:45:44 <Myrl-saki> map (take 3) . tails
07:45:51 <Myrl-saki> > map (take 3) . tails $ [1,2,3,4,5]
07:45:53 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
07:45:58 <Myrl-saki> Oh.
07:45:59 <Myrl-saki> -.-
07:46:01 <xa0> lol
07:46:08 <mniip> yeah map
07:46:13 <Myrl-saki> Not that either.
07:46:32 <ongy> :t tails
07:46:34 <lambdabot> [a] -> [[a]]
07:46:43 <Myrl-saki> You know.
07:46:46 <Myrl-saki> History's repeating itself.
07:46:52 <Myrl-saki> I remember asking about this like 6 months ago.
07:46:58 <xa0> tails x = x =>> id
07:47:13 <Myrl-saki> xa0: =?>>?
07:47:14 <Myrl-saki> =>>?
07:47:16 <kjka> how do I convert a storable vector to something manipulable... ike a Data.Vector?
07:47:20 <xa0> cobind
07:47:28 <xa0> :t (=>>)
07:47:29 <lambdabot>     Not in scope: ‘=>>’
07:47:29 <lambdabot>     Perhaps you meant one of these:
07:47:29 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
07:47:35 <Myrl-saki> Great. I'm even more lost that unusual. Hahaha.
07:47:36 <xa0> :t Control.Comonad.(=>>)
07:47:38 <lambdabot> Not in scope: data constructor ‘Control.Comonad’
07:47:38 <lambdabot>     Not in scope: ‘=>>’
07:47:38 <lambdabot>     Perhaps you meant one of these:
07:47:47 <lyxia> kjka: a storable vector is already manipulable
07:47:51 <lyxia> it has the same interface
07:47:54 <xa0> hm, well it's a thing
07:47:59 <mniip> traverse ZipList . take 3 . tails
07:48:05 <mniip> Myrl-saki
07:48:08 <kjka> lyxia as Data.Vector?
07:48:12 <lyxia> yes
07:49:13 <lyxia> is something missing from your point of view?
07:49:19 <puregreen> dalastboss: okay, do you still need help? (I guess adding let-parsing to blockBinding should solve the problem)
07:50:12 <dalastboss> huh
07:50:14 <dalastboss> weird
07:50:30 <mniip> > traverse ZipList . take 3 . tails $ [1,2,3,4,5,6,7]
07:50:31 <lambdabot>  ZipList {getZipList = [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7]]}
07:50:38 <dalastboss> indeed it did solve the problem, though I'm not sure why, because as you said, the "let" was already consumed
07:50:41 <kjka> lyxia, well I can do 
07:50:43 <kjka> TRUMP: Wow. Whoa. That is some group of people. Thousands.
07:50:43 <kjka> So nice, thank you very much. That’s really nice. Thank you. It’s great to be at Trump Tower. It’s great to be in a wonderful city, New York. And it’s an honor to have everybody here. This is beyond anybody’s expectations. There’s been no crowd like this.
07:50:43 <kjka> And, I can tell, some of the candidates, they went in. They didn’t know the air-conditioner didn’t work. They sweated like dogs.
07:50:43 <kjka> (LAUGHTER)
07:50:43 <kjka> They didn’t know the room was too big, because they didn’t have anybody there. How are they going to beat ISIS? I don’t think it’s gonna happen.
07:51:31 <Shockk> O_o
07:51:38 <mniip> probably mispaste?
07:51:42 <kjk2> whoops
07:51:45 <kjk2> errant copy paste sorry
07:52:00 <EvanR> everyone paste their clipboard into irc right now
07:52:12 <EvanR> https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Unsafe.html
07:52:15 <kjk2> lol
07:52:24 <kjk2> i was copy-pasting some trump speech into a sentiment analysis visualization
07:52:31 <kjk2> anyway
07:52:47 <kjk2> lyxia I can do (V.fromList [1,2,3]) V.! 0
07:53:02 <kjk2> lyxia but I can't do that on a foo V.! 0
07:53:07 <kjk2> where foo is a storable vector
07:53:18 <kjk2> V is a qualified import of Data.Vector
07:53:59 <kjk2> oh i guess I can do foo SV.! 0 though
07:54:02 <dalastboss> puregreen: still works after adding the indentation combinators back in ! :)
07:54:05 <lyxia> kjk2: indeed
07:54:08 <dalastboss> thanks a ton for your help
07:54:14 <kjk2> duh
07:54:27 <kjk2> ok
07:54:28 <lyxia> kjk2: the Data.Vector.Generic covers both
07:54:50 <lyxia> so that you can do G.! on any kind of vector
07:55:07 <kjk2> nice
07:55:12 <kjk2> is there a performance cost?
07:55:12 <lyxia> it's pretty neat, not sure why it's not simply reexported by others
07:55:19 <lyxia> none
07:55:37 <lyxia> Data.Vector.Whatever all simply rebind the Generic interface
07:55:53 <kjk2> how do people usually go about representing 2D matrix sort of data? vector of vectors? list of lists? hmatrix?
07:56:24 <kjk2> need this to be fast...
07:56:27 <chelfi> Myrl-saki: not sure if still relevant, but one way to get a fast nub is scanning the list and storing the elements in a set. You get O(nln(n)) if you assume O(ln(n)) insertion and lookup
07:56:28 <lyxia> vectors of vectors are okay
07:56:34 <chelfi> though of course the space complexity gets worse
07:56:36 <bennofs> if the 2d matrix data is dense, I usually just convert (Int,Int) -> Int and then use a single vector
07:56:56 <bennofs> (assuming the "width" of each row is constant)
07:57:42 <kjk2> bennofs each row is constant, so do you right a one off function with the dimension hard coded?
07:57:56 <EvanR> it would be nice to have a matrix library for this
07:58:13 <kjk2> i could use hmatrix but i'm not sure if those representations are fast..
07:58:26 <EvanR> theres repa
07:58:28 <lyxia> chelfi: Myrl-saki: nub = Set.toList . Set.fromList
07:58:55 <kjk2> EvanR yeah, I wish repa was a little more fluid for interactive analysis. doesn't even have a pretty printer..
07:59:00 <kjk2> but maybe i'll write my own around it
07:59:15 <kjk2> so here's my setup at the moment
07:59:27 <chelfi> lyxia: you lose relative order of your list if you do this
07:59:40 <kjk2> I have C code doing ODE integration with GSL
07:59:51 <kjk2> I wrote my own direct FFI binding (don't like the list intermediary in hmatrix-gsl)
08:00:05 <kjk2> that returns a time series trajectory of state which I can represent as a 2D matrix
08:00:17 <kjk2> I want to wrap that in a probabiistic MCMC inference procedure
08:00:36 <lyxia> chelfi: Oh right.
08:00:47 <kjk2> so i have the FFI and the gsl stuff working. the time series state data I'm getting back as a mutable storable vector
08:01:11 <boggle> hey, recently switched my distro to arch linux. what's the best way to set up my haskell environment? what should i let the package manager handle vs. install through hackage?
08:01:26 <kjk2> 1-dimensional (i don't know how to pass 2D arrays back and forth between haskell and C)
08:01:41 <kjk2> I freeze the mutbale storable vector so now it's just a stroable vector
08:01:50 <kjk2> now i'm wondering what representation I should use for this outer logic
08:01:57 <kjk2> of MCMC iterations and likelihood function calculations
08:02:03 <chelfi> lyxia Myrl-saki you may want something along the line (sorry for horrible code) nub = go s.empty where go s (x:xs) = if x `elem` s then go s xs else x : go (s.insert x) xs
08:02:22 <cocreature> boggle: I installed ghc and cabal via pacman and then stack from hackage and since then I only use stack to manage everything
08:02:24 <ongy> boggle: I have ghc+cabal from pacman, everything else via cabal install, there is a arch-haskell project somewhere but I have no idea how complete/recent it is
08:02:25 <chelfi> with of course base cases and usuals
08:02:34 <kjk2> i'm thinking of converting the 1D storable vector into a repa 2D matrix. Does that seem reasonable or is that too much overhead for something in a deep inner loop?
08:03:01 <kjk2> is there a more direct way to connect repa matrices with C FFI?
08:03:40 <kjk2> any thoughts?
08:06:32 <boggle> cocreature: what's stack? is it similar to cabal?
08:06:48 <cocreature> boggle: http://haskellstack.org/
08:07:40 <boggle> ongy: thanks :)
08:08:30 <kjk2> boggle: serves some similar functionality to cabal install, but works soooo much better
08:11:46 <ij> Wouldn't it be nice to have >>= with a non-symbollic(e.g. bind) name as well?
08:12:19 <kjk2> ij not sure , why?
08:12:22 <boggle> kjk2: what makes you prefer stack over cabal?
08:12:28 <ij> parseConfig = (>>= findValues) <$> readIniFile
08:12:33 <seishun> how does one usually indent runState with a long do block? for example http://lpaste.net/4212377810792087552
08:12:37 <ij> wouldn't have to do parenthesis
08:13:26 <kjk2> ij isn't >>= sugare basically what the do sugar is for?
08:13:43 <kjk2> boggle: you don't replicate package installations per-project
08:13:50 <ij> Perhaps, but this doesn't need "do". It's two calls.
08:14:09 <kjk2> kjk2 also there's way fewer dependency problems as well
08:14:24 <kjk2> er kjk2 = boggle :P
08:14:37 <boggle> kjk2: does it just install the same version of each package once and symlink to it from inside the project or something?
08:14:56 <puregreen> seishun: I usually say use “flip runState $ do”
08:14:56 <puregreen> *
08:16:34 <seishun> puregreen: you mean "flip runState myState $ do"?
08:18:11 <puregreen> well, yeah
08:18:25 <seishun> I see. that should be more readable indeed
08:18:57 <puregreen> it'd be nice if runState, etc. had different order of arguments, but they don't and I haven't ever seen a good synonym for “flip runState”
08:19:18 <Rotaerk> not a huge fan of using flip directly in the calling code; makes it a little less readable imo
08:19:34 <Rotaerk> I tend to define synonyms if they don't exist
08:20:22 <seishun> someone should write a module that just exports "flip runState"
08:20:49 <seishun> but it would be bad if a lot of code started to depend on it and then the author decided to delete it...
08:27:42 <seishun> >I haven't ever seen a good synonym for “flip runState”
08:27:49 <seishun> "stateRun"?
08:28:26 <ij> It's too short, it doesn't need a synonym.
08:28:41 <ij> It's «flip runState» and that's okay.
08:30:53 <Myrl-saki> Guys.
08:31:13 <Myrl-saki> What do you call it when you represent types through numbers(?)?
08:31:30 <Myrl-saki> Say, T = A*T*T + 1
08:32:34 <puregreen> type algebra, I think
08:33:13 * nitrix pets Myrl-saki. Getting back to Haskell huh :p ?
08:33:36 <Myrl-saki> nitrix: Just because of a HackerRank challenge. :P
08:34:07 <pkmx> seishun: Well, in lens you can write `runState ?? s $ m`
08:34:23 <Myrl-saki> nitrix: To be more exact, I use Haskell exclusively; I've just been more into learning concepts recently.
08:35:15 <seishun> pkmx: lens looks like dark magic to me
08:35:16 <Cale> Myrl-saki: That's not so much that you're representing types as numbers, but using a notation which happens to look a lot like numbers to talk about the categorical properties that a type satisfies.
08:36:03 <Myrl-saki> Cale: Ah.
08:36:15 <Cale> (though sometimes interesting things can be gleaned by really thinking about it in terms of honest numbers, or power series)
08:36:17 <Myrl-saki> Cale: Wait, categorical properties?
08:36:51 <Cale> Yeah, multiplication corresponding to categorical product and addition to coproduct
08:37:55 <Cale> So you're asking for a type T which is isomorphic to the coproduct of the unit type 1, and (the product of A, T, and T).
08:38:34 <Myrl-saki> ._.
08:38:49 * Myrl-saki is lost. :s
08:38:52 <Cale> Coproduct is like disjoint union here, if that helps
08:38:59 <Cale> and product is Cartesian product
08:39:15 <Cale> A binary tree type would satisfy this condition
08:39:22 <Cale> in a natural way
08:39:26 <Cale> Something like
08:39:36 <Cale> data Tree = Tip | Branch A Tree Tree
08:40:27 <Cale> Here, the coproduct is reflected in the two cases we have for the constructors Tip and Branch
08:40:34 <pkmx> seishun: i don't think that (??) has anything to do with lens actually, you can just pretend that (??) :: (e -> a -> b) -> a -> (e -> b)
08:40:53 <Myrl-saki> Cale: Coproduct is like sum?
08:40:56 <Cale> yeah
08:41:03 <Cale> It's often called "sum" as well
08:41:11 <Myrl-saki> Ah.
08:41:39 <seishun> pkmx: isn't that equivalent to flip?
08:41:41 <Cale> The name "coproduct" highlights the fact that it has the same definition as "product" except all the arrows are reversed.
08:41:46 <seishun> :t (??)
08:41:47 <lambdabot> Functor f => f (a -> b) -> a -> f b
08:42:17 <seishun> :t flip
08:42:18 <lambdabot> (a -> b -> c) -> b -> a -> c
08:42:41 <pkmx> seishun: fancy infix flip :)
08:44:05 <Myrl-saki> lol
08:44:35 <Cale> If you have objects A and B in some category, then a product of them is an object P together with arrows p_A: P -> A and p_B: P -> B such that for any other object Z and arrows a: Z -> A and b: Z -> B, there is a unique arrow u: Z -> P such that p_A . u = a and p_B . u = b
08:46:01 <Cale> A coproduct of them is an object S together with arrows i_A : A -> S and i_B: B -> S such that for any other object Z and arrows a: A -> Z and b: B -> Z, there is a unique arrow u: S -> Z such that u . i_A = a and u . i_B = b
08:46:42 <Cale> It can take a bit to really piece together what these definitions mean in any particular context.
08:48:04 <Myrl-saki> Hmmm
08:48:17 <Cale> But the intuition is that if you think of a: Z -> A and b: Z -> B in the first case as "elements" of A and B (which would pretty much be the case if A and B were sets and Z was a one element set, these would be functions picking out particular elements)
08:48:32 <Myrl-saki> Cale: I should probably review Category Theory; I haven't read about it for quite some time because I was busy with my schoolwork.
08:48:58 <Cale> Then u is an "element" of the product P which we can sort of take apart again into a and b
08:49:09 <Cale> that is, it's something like the ordered pair (a,b)
08:49:59 <Cale> We might even choose to use the ordered pair (a,b) as notation for this arrow p, in which case we have p_A . (a,b) = a, and p_B . (a,b) = b
08:50:40 <Cale> which looks quite a bit like applying a projection directly to the ordered pair -- you just have to be careful that it's really an arrow! :)
08:53:01 <Cale> In general, in the category of sets, we'll have the product be the Cartesian product A x B = { (a,b) : a in A, b in B }, with p_A : AxB -> A by p_A (a,b) = a, and similarly for p_B, projecting out the second component instead
08:54:23 <Cale> and then if we have functions f: Z -> A and g: Z -> B, we can build a function <f,g> : Z -> AxB by way of <f,g>(z) = (f z, g z)
08:55:03 <Cale> and that's really the only thing which would satisfy the condition that's required
08:55:15 <lpaste> infinity0 pasted “Polykinded typeclasses” at http://lpaste.net/156742
08:55:44 <infinity0> so the above code gives an error The first argument of ‘Reverse’ should have kind ‘*’, but ‘d’ has kind ‘* -> * -> *’
08:56:14 <infinity0> i intend Reverse just to be a marker typeclass, so it should admit type constructors of any number of params. is this possible in haskell?
08:57:09 <infinity0> for n=2 i can fix things by defining some dummy method in Reverse that implies that u and d are of kind * -> * -> *, but really this shouldn't matter
08:57:31 <Cale> infinity0: Do you have the PolyKinds extension turned on?
08:58:06 <infinity0> Cale: oh now it works lol, magic
08:58:27 <infinity0> a lot of the time the error message tells me what i need to switch on, so i didn't know there was something to switch on here
08:59:46 <ongy> Myrl-saki: now I'm doing hackerrank challenges... thanks for that
08:59:51 <Cale> There's also the possibility of giving explicit kind signatures
09:02:32 <infinity0> also if I write "instance Reverse d u => Reverse u d where" to hopefully save repetition, later it gives me "duplicate instance declarations" when i actually define something concrete
09:02:40 <infinity0> is there a way around that?
09:03:17 <Zekka|Sigfig> infinity0: You could use OverlappingInstances although that is an evil extension
09:03:57 <Zekka|Sigfig> you could also make people instantiate OneWay and then write both instance OneWay d u => Reverse d u and instance OneWay d u => Reverse u d
09:04:26 <Cale> That instance overlaps with every other possible instance. It's important to understand that when determining which instance to use, the algorithm is not allowed to rely on the class constraints on instances to determine whether or not to commit to them
09:04:48 <Cale> So to the instance selector, that instance looks like  instance Reverse u d where ...
09:05:38 <Cale> also, if it *did* look at the constraints, there would be nothing to stop it from immediately recursing when it tried to determine if there was an instance Reverse d u
09:06:05 <infinity0> yeah, i can understand why the restriction is in place, but thought this pattern might be common enough that there's a workaround
09:06:52 <infinity0> ok thanks all, i'll try the suggestions
09:07:19 <Cale> Something to note: if you have no methods that you need to define, you don't need the 'where'
09:08:15 * hackagebot fresco-binding 0.1.0 - Fresco binding for Haskell  https://hackage.haskell.org/package/fresco-binding-0.1.0 (PeterAlthainz)
09:08:17 * hackagebot HGamer3D 0.7.0 - Toolset for the Haskell Game Programmer  https://hackage.haskell.org/package/HGamer3D-0.7.0 (PeterAlthainz)
09:08:18 <infinity0> ack
09:12:52 <Myrl-saki> ongy: I'll finish this tomorrow.
09:13:05 <Myrl-saki> ongy: My head's too much of a mess right now. :/
09:14:14 <Myrl-saki> Good night.
09:22:39 <seishun> is there something like a StringBuilder monad in the standard libraries?
09:24:39 <lyxia> ByteString.Builder ?
09:24:52 <lyxia> not a monad...
09:25:28 <seishun> I think I might just use Writer with [String]
09:25:40 <seishun> since all I'm going to need is appending a line
09:28:23 <Sornaensis> ur mom is a monad HAHAHAHAHAHA
09:28:28 <xa0> lmao
09:42:15 <augur> i wonder.. is   newtype Set a = Set { runSet :: (a -> Bool) -> Bool }   the true set monad in haskell? hmm
09:42:50 <augur> no thats probably not quite right
09:43:07 <Peaker> splitting my code into many modules slowed it down by ~1.7x, apparently, doh :(
09:43:16 * hackagebot cryptohash 0.11.8 - collection of crypto hashes, fast, pure and practical  https://hackage.haskell.org/package/cryptohash-0.11.8 (VincentHanquez)
09:43:45 <augur> a -> Bool  cant be a monad b/c its contravariant in 'a'
09:44:07 <augur> but, surely we can get true sets somehow
09:44:24 <Peaker> Constraint kinds?
09:44:30 <augur> such as?
09:45:02 <Peaker> Data.Set as an instance of some generalized GFunctor Ord ?
09:46:34 <augur> but its not a monad, b/c of implementation details leading to equality failure
09:46:54 <Peaker> not a Monad, but it can be a GMonad, no?
09:47:01 <augur> dunno
09:47:11 <augur> but Set should be a monad, punkt, not a GMonad
09:47:17 <Peaker> or you mean the lack of a law that (a==b) implies they're indistinguishable?
09:47:19 <augur> so im curious how to get such a beast
09:47:55 <augur> but also, sets are peculiar beasts because all we can know is membership. unlike lists, we cant inspect and look at particular elements in any meaningful way
09:48:17 <augur> because there's no order, there's no way to distinguish elements, whereas w/ lists there's a first, and some rest (if there's anything, anyway)
09:48:24 <Peaker> you mean set theory sets? Data.Set is more like lists
09:48:54 <Peaker> finite sets can just choose an arbitrary order
09:49:09 <augur> just finite sets
09:50:18 <augur> arbitrary order isnt quite right, because by encoding as lists, we have a way to inspect and get elements out
09:50:38 <augur> but we shouldnt be able to grab ahold of a set's elements, only test membership
09:51:59 <Peaker> augur: for finite sets, can't you translate membership test into a full enumeration?
09:52:14 <EvanR> augur: "true sets", the category of sets is that way
09:52:25 <augur> Peaker: only if you have a way of enumerating the members of the type in question
09:52:30 <EvanR> this is Hask
09:53:04 <EvanR> also membership testing may or may not be "true sets"
09:54:48 <EvanR> theres abstract sets and concrete sets, abstract sets are more like the type of elements and concrete sets are more like subsets of some agreed upon set
09:55:09 <EvanR> membership operations, union, intersection, complement make sense on the subsets
09:55:37 <Cale> I'm not sure membership testing is the right thing... you want to be able to ask the question of whether elements belong to the set in the sense of a proposition, which means you need a dependent type for that relation. :)
09:56:34 <Cale> (a type which depends on both the "element" and the "set")
09:56:43 <monochrom> Peaker: that is strange because GHC goes out of its way to ignore module boundaries (even library boundaries) when optimizing. (so out of its way to cause cabal hell)
09:56:48 <EvanR> this is still subsets
09:57:32 <Peaker> monochrom: I am checking all the intermediate git commits, maybe I changed something I don't think I did
09:57:39 <EvanR> all elements are elements by virtue of being in some set, which amounts to its type. and propositions can restrict to some of the elements
09:57:42 <monochrom> heh
09:58:09 <augur> i wonder also if somehow there's a way to think about quotienting via some kind of higher-order transformation
09:58:26 <EvanR> a type level transformation ;)
09:58:31 <augur> i dont mean that :p
09:58:46 <augur> like, we know we can use Yoneda to construct some formal definitions of what some such thing might be
09:58:49 <EvanR> seems like a quotient is another type?
09:58:56 <augur> eg exponentials of functors
09:58:56 <Cale> augur: Setoids? Higher inductive types?
09:59:18 <augur> even tho we dont necessarily have a way to get back from the fancy equivalent thing to some more familiar gadget
09:59:25 <Cale> There are lots of nice ways to approach this stuff which aren't really usable in Haskell.
10:00:21 <Peaker> monochrom: false alarm, it seems my laptop just isn't very stable at benchmarking
10:00:33 <augur> in the same way that twanvl's lens type    Lens s t a b = forall f. functor f => (a -> f b) -> s -> f t    is equivalent to the first-order store-based lens type
10:01:40 <augur> or in the way that there is a free monoid type that uses the monoid type class, iinm
10:03:01 <EvanR> its because functors and monoids are more functional than sets
10:03:04 <augur> is there some similar think to get quotients via higher-order constraints?
10:03:38 <augur> s/think/thing
10:03:54 <augur> can we have, eg, a true type of free group?
10:04:38 <augur> where we need to have inverses, but a first-order representation can never have a true free group b/c it would require some kind of normalization that cant always exist?
10:05:00 <augur> hmm hmm
10:06:04 <EvanR> haskell is based on lambda calculus so youre restricted to computable or crash/freezing math ;)
10:06:25 <EvanR> why didnt they base it all on set theory
10:06:53 <augur> hmm right, here's the free monoid type that edwardk gives:    newtype FM a = FM { unFM :: forall m. Monoid m => (a -> m) -> m }
10:07:21 <augur> and in general i guess:   newtype F c a = F { unF :: forall b. c b => (a -> b) -> b }
10:07:30 <augur> the constraint continuation type
10:09:50 <augur> so then, if we could define (sub)set like behavior with a type class   Setlike a s   (where this means s is a type of sets-of-a's)   then   F (Setlike a)   is the true set type??
10:11:06 <EvanR> sweet
10:11:24 <EvanR> now what is the Setlike class
10:11:30 <augur> good question :)
10:11:56 <EvanR> union intersection complement available to overload for performance ;)
10:12:32 <augur> class Setlike a s where   empty :: s  ;  singleton :: a -> s  ;  member :: a -> s -> Bool  ;  union :: s -> s -> s  ;  intersection :: s -> s -> s
10:12:35 <augur> lets say?
10:12:51 <augur> we'd want laws too but
10:13:21 <Cale> comprehension
10:13:38 <augur> compression is monadic bind tho
10:13:54 <augur> .. compression lol
10:13:57 <augur> comprehension*
10:14:07 <augur> or definable in terms of it, anyway
10:14:51 <augur> comp :: Set a -> (a -> Bool) -> Set a   ;   comp s p = s >>= \x -> if member x s then singleton x else empty
10:15:11 <EvanR> a function of type (a -> Bool) .....
10:15:16 <EvanR> dunno
10:15:26 <EvanR> thats a filter right
10:15:33 <augur> comprehension is set filter, yes
10:15:35 <Cale> You could just use Codensity Set if you want a proper Monad instance for something Set-like, but it's no better than just using lists and converting to a Set at the end.
10:16:08 <augur> Cale: thats a good point
10:17:32 <EvanR> add a new class (or set of classes) for Prop a and make it Prop a -> s
10:17:42 <EvanR> Prop a s -> s
10:17:44 <augur> whats Prop a supposed to be
10:18:04 <EvanR> proposition about a's
10:18:26 <augur> whatever those might be :)
10:18:55 <augur> certainly its true that we can define   Setlike a (a -> Bool)   of course
10:19:24 <EvanR> and Ord a => SetLike a (Set a)
10:19:27 <augur> well, at least when a has testable equality, i guess
10:20:18 <EvanR> you can also just use a list and ignore the fact that there are duplicates
10:20:22 <augur> but then that ruins the quest for a true Set type
10:20:50 <augur> sure, i mean, the quest is to find a type that doesnt require ignoring anything :)
10:21:05 <augur> via silly higher-order fun!
10:21:07 <Cale> The only thing you're ignoring with the Codensity approach is performance
10:21:29 <Cale> which you have to ignore with any approach that's going to give you (>>=)
10:21:47 <Cale> because (>>=) isn't allowed to depend on an Ord instance, which is required for good performance
10:22:05 <EvanR> how about ignoring that == isnt computable for a lot of sets so why bother
10:22:31 <EvanR> no need for identity
10:22:46 <Cale> Well, if you want honest ZFC sets, you can do that in dependent type theories, but they don't look anything at all like sets of values of various types.
10:22:53 <joco42> any idea why linear does not compile from hackage ? https://www.irccloud.com/pastebin/gTvfZ6C9/
10:22:56 <EvanR> all sets are bijective with some abstract set of some cardinality
10:23:09 <EvanR> so make an ordinal type
10:23:15 <EvanR> or cardinal type
10:23:16 <joco42> 7.10.2
10:24:23 <Cale> joco42: Looks like a package version constraint is messed up slightly
10:24:29 <Cale> perhaps
10:24:30 <EvanR> data Set a = Fin Integer | Inf Ordinal
10:24:51 <joco42> hmm maybe its too old
10:25:02 <augur> i dont want ZFC sets, ZFC is kinda gross
10:25:03 <Cale> If an instance got added to base-orphans, and the bound on linear didn't get adjusted to account for it
10:25:05 <joco42> i need to try a newer versino
10:25:20 <augur> i just want something like List quotiented by repetition and order
10:25:24 <Cale> EvanR: Finite ordinals are ordinals too
10:25:42 <EvanR> well Inf is alpha raised to some power
10:25:44 <ij> Why can't TDFA do non-capturing groups? :(
10:25:45 <EvanR> aleph
10:26:08 <Cale> oh, you want cardinalities
10:26:11 <EvanR> starting with zero when you get to omega
10:27:15 <EvanR> now when you are given a set, you can label the elements however you want!
10:27:21 <EvanR> its all isomorphic
10:28:18 * hackagebot cryptohash 0.11.9 - collection of crypto hashes, fast, pure and practical  https://hackage.haskell.org/package/cryptohash-0.11.9 (VincentHanquez)
10:28:25 <Cale> ij: only because the string notation for regular expressions sucks, I think.
10:28:55 <ij> Perhaps, but you could just not use ?: and the effect would be the same.
10:29:01 <Cale> ij: The underlying Pattern type appears to have a PNonCapture constructor, which looks suspiciously like what you want
10:30:23 <posco> maybe a dumb question, but there terms seem hard to google: I'm trying to get subparser on commands to show help of what commands there are when no args are given in optparse-applicative
10:30:26 <Cale> (though I'm not sure there's much point to it...)
10:30:29 <shapr> Hm, cryptohash could be good for my bloom filter kata
10:30:49 <posco> I can't figure it out. If I run with no args it tells me to run with a COMMAND, but no list of commands
10:31:08 <augur> Cale: you dont like regular expressions? :(  whats wrong with them?
10:31:15 <ij> Cale, well then I have to find indices of strings that I don't care about and then drop them from match list.
10:31:21 <augur> did you know that regex bizippers are the statespace for the recognizer NDFA? :D
10:32:05 <EvanR> theres a regex lib that has better syntax for regex
10:32:06 <Cale> augur: I like regular expressions, I dislike the awkward string notation which the various regex libraries parse variants of.
10:32:17 <EvanR> it uses applicative i think
10:32:18 <augur> Cale: example, to clarify what you mean?
10:32:33 <Cale> augur: Regular expressions should be an algebraic datatype.
10:32:53 <Cale> Not some awful string syntax with weird escaping for things
10:33:05 <augur> oh you mean you want to write something like the parse tree for the regex strings
10:33:29 <EvanR> ^(?:(?:(?:0?[13578]|1[02])(\/|-|\.)31)\1|(?:(?:0?[13-9]|1[0-2])(\/|-|\.)(?:29|30)\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})$|^(?:0?2(\/|-|\.)29\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:(?:0?[1-9])|(?:1[0-2]))(\/|-|\.)(?:0?[1-9]|1\d|2[0-8])\4(?:(?:1[6-9]|[2-9]\d)?\d{2})$
10:33:38 <Cale> and in the case of that situation, I actually meant that it was the parser for those strings which was lacking
10:33:49 <augur> like...   data Regex = C Char | Opt Regex | Plus Regex | Seq Regex Regex
10:34:03 <Cale> because the underlying library, from the point of having the algebraic Pattern type onward, supported non-capturing groups
10:34:13 <EvanR> augur: yes just being able to save parts of your regex in a let and reuse it would greatly improve usability
10:34:27 <augur> s/Seq/(:>) maybe
10:35:00 <Cale> posco: I ran into this before and solved it, but I don't remember the solution... let me have a look
10:35:01 <augur> it'd be nice to have this in haskell
10:35:14 <augur> probably other langs dont have it b/c they lack algebraic data types
10:35:19 <posco> Cale: thanks!
10:35:26 <EvanR> man if people like randomish symbol syntax like that, imagine what kind of proper parser languages you could be writing instead!
10:35:40 <EvanR> K or J
10:35:44 <EvanR> forth
10:35:56 <lpaste> argent0 pasted “How to combine Folding functions?” at http://lpaste.net/156748
10:36:19 <Cale> oh, right
10:36:28 <Cale> posco: what are your ParserPrefs?
10:36:38 <Cale> posco: I think you want prefShowHelpOnError = True
10:36:46 <shapr> Cale: is that regex ADT written up somewhere?
10:37:03 <shapr> EvanR: APL is better
10:37:10 <posco> Cale: okay. I was just running with execParser, and didn't see how to set prefs with that, so I skipped it...
10:37:10 <Cale> posco: I have: parserPrefs = ParserPrefs { prefMultiSuffix = "", prefDisambiguate = False, prefShowHelpOnError = True, prefBacktrack = True, prefColumns = 80 }
10:37:20 <augur> EvanR: is there such a lib for haskell?
10:37:21 <shapr> although someone compared Haskell to APL at my most recent intro
10:37:24 <Cale> x <- customExecParser parserPrefs allOpts
10:37:42 <argent0> Is there a way to combine functions so that one can compute various values from a list in one pass?
10:37:43 <posco> :) easy enough. trying
10:37:54 <Cale> shapr: In a number of places...
10:38:18 <Cale> shapr: In fact the TDFA library which was just mentioned actually uses one internally
10:38:30 <Cale> https://hackage.haskell.org/package/regex-tdfa-1.2.1/docs/Text-Regex-TDFA-Pattern.html#t:Pattern
10:38:43 <shapr> ooh, neat
10:39:10 <EvanR> augur: https://hackage.haskell.org/package/regex-applicative
10:39:16 <augur> neat
10:39:44 <augur> also this makes me wonder if there's a larger more expressive family of grammars that can be represented in a way parallel to regex
10:39:46 <augur> like
10:40:09 <augur> regular languages can be represented w/ production rules of a certain sort, right
10:40:11 <lpaste> Cale pasted “Regular.hs” at http://lpaste.net/156750
10:40:40 <Cale> ^^ here's a not-terribly-practical library I wrote a while back to study some things
10:40:45 <augur> but you can also represent them by regular expressions which have no abstract symbols, just combinators for various kinds of operations
10:40:56 <posco> Cale: thanks! That worked great (although, tend to think help should be the default option).
10:41:03 <Cale> posco: I agree
10:41:22 <Cale> posco: It took me quite a while to figure out what the heck was going on too.
10:41:41 <augur> so i wonder, is there a larger set of combinator-y things which have the same kind of bizipper traversal property
10:41:41 <posco> really appreciate saving me the time!
10:42:05 <shapr> Cale: did you write a blog post about that lpaste?
10:42:10 <Cale> shapr: nope
10:42:16 <shapr> aw
10:42:34 <Cale> It was just something I hacked together because someone was asking me questions about an algorithm in a paper
10:42:48 <shapr> it's neat
10:43:41 <Cale> In case it's not totally clear, the (=<=) operation will tell you whether the set of strings matched by one regular expression is a subset (or equal to) the set of strings matched by another.
10:43:58 <Cale> and (===) tests for equivalence
10:45:21 <shapr> could be fun to use that for simplifying regexes
10:45:46 <Cale> Yeah, I didn't do any NFA/DFA minimisation.
10:46:30 <Cale> and I didn't implement the other direction NFA a -> Reg a
10:46:44 <Cale> But that might be something which could be added to this
10:49:16 <augur> Cale: you might find this interesting   https://github.com/psygnisfive/RegExWithZippers
10:50:32 <augur> i need to rewrite the tutorial to really explain what's going on, but basically, if you take a bizipper of the a given regex, you can traverse it to do matching
10:50:43 <augur> and it turns out that this forms the states of an NFA
10:51:21 <augur> not just any NFA, either -- the NFA you get from the usual translation into state machines
10:53:27 <augur> this was written long ago before i started to properly document things xD
10:53:32 <augur> gosh its pretty unreadable
10:55:31 <augur> but its interesting, because it turns out that this bi-zipper view looks VERY similar to the stack machine dynamics for a functional program
10:55:51 <augur> in particular a non-deterministic stateful language
10:56:59 <augur> you have precisely the right stack constructs and everything. the regex is an imperative language, in this view
10:58:19 * hackagebot HGamer3D 0.7.1 - Toolset for the Haskell Game Programmer  https://hackage.haskell.org/package/HGamer3D-0.7.1 (PeterAlthainz)
10:58:21 * hackagebot fresco-binding 0.1.1 - Fresco binding for Haskell  https://hackage.haskell.org/package/fresco-binding-0.1.1 (PeterAlthainz)
10:58:28 <augur> and augmenting it with things like captures and back references becomes really simple b/c its just a matter of augmenting the state to include not just the remainder of the input string but also some capture values
10:59:41 <seishun> is there a shorthand for `data T = T`?
11:00:00 <augur> seishun: no, but that type is already defined anyway: ()
11:00:01 <osa1> seishun: ()
11:00:07 <augur> data () = ()
11:00:31 <puregreen> seishun: note that you can also write “data T” if you enable some extension that I don't remember (if you need just the type and not the constructor)
11:00:47 <monochrom> EmptyDecls
11:00:51 <Iceland_jack> {-# LANGUAGE EmptyDataDecls #-} 
11:00:56 <monochrom> oops
11:00:57 <seishun> but I want to make it an instance of a typeclass
11:01:30 <augur> what are you trying to do, seishun
11:01:52 <augur> puregreen: you cant write "data T" to mean "data T = T" tho
11:01:59 <augur> data T will be a type with no values
11:02:05 <puregreen> yep, I knnow
11:02:06 <puregreen> *
11:02:06 <augur> data T = T is a type with exactly one value
11:02:17 <augur> so i doubt that's what seishun wants. or maybe it is! who knows :)
11:02:29 <danza> hi all, i am going to write an Application Programming Interface wrapper, and i am thinking to use Servant. Any caveats about it? Any alternative i should consider? I remember reading some criticism about how Servant uses the type system
11:03:26 <augur> danza: you can just say API x3
11:03:37 <danza> yeah but i hate that :D
11:03:44 <augur> danza: im using servant currently for my software's API
11:03:51 <augur> i really like servant
11:03:59 <augur> >> #servant
11:05:01 <danza> yep i have met a lot of fans of Servant so far, which is cool. I am curious about caveats and alternatives, though
11:05:17 <danza> sounds like nobody can mention any ... so ... Servant will be :D
11:05:30 <augur> i dont know any other systems, so i cant comment
11:05:44 <augur> servant is really simple and quick to just start using, tho
11:05:53 <augur> other things are big and bulky and complex piles of functionality
11:06:03 <danza> cool
11:06:18 <seishun> basically I'm using a typeclass to define a collection of functions. So instead of passing a bunch of functions to a function, I just pass it an instance of the typeclass
11:07:21 <EvanR> you could also use implicit parameters!
11:07:31 <augur> seishun: dont use type classes to bundle functionality. that's not what they're for
11:08:01 <seishun> what should I use then?
11:08:40 <kahn> Servant is great
11:08:49 <augur> if you're only ever concerned with one particular bundle of functionality, and you just want to pass it around as needed, just make a record type with the functionality
11:09:06 <EvanR> seishun: just pass in a bunch of functions
11:09:41 <augur> data SomeJunk = SomeJunk { junk1 :: foo, junk2 :: bar }
11:10:07 <augur> theJunk :: SomeJunk  ;  theJunk = SomeJunk { junk1 = aFoo, junk2 = aBar }
11:10:15 <augur> and pass theJunk around
11:10:48 <EvanR> theJunk SomeJunk junk1 foo bar yes... quite clear ;)
11:12:18 <seishun> I suppose I could just define a record type with a field for each function
11:12:33 <EvanR> hell yeah
11:12:51 <augur> EvanR: it is what it is!
11:13:18 <EvanR> reminds me of variable names i used when i was in high school
11:13:45 <EvanR> in VB / DarkBasic
11:14:29 <augur> EvanR: better than   data T = T { f :: a, g :: b }   :)
11:14:51 <EvanR> T_T
11:15:12 <augur> the best way, i find, to demystify an approach, is to use absurdly eh...
11:15:23 <augur> plain? vulgar? but not lewd? names
11:15:34 <augur> TheThing   SomeJunk   Whatever   WhoCares
11:16:01 <EvanR> yeah when i get tired of coming up with variable names
11:16:15 <augur> because it emphasizes that the name doesnt matter, by picking an obviously farcical name that communicates that the intent behind it is more important
11:16:24 <monochrom> john jon jone joan joanne
11:16:35 <augur> its a nice disarming approach. it makes it not-so-scary
11:16:37 <EvanR> foo3, foo9, goo90, floozFlop, barf
11:16:39 <augur> good for teaching
11:19:04 <EvanR> teach the controversy
11:19:12 <EvanR> tabs vs spaces
11:20:45 <monochrom> FOO vs F00
11:22:48 <u-ou> __ ___ ____ _____ ______ _______
11:25:02 <shapr> u-ou: trying to underscore the controversy?
11:28:23 <hpc> i am disappointed that there's no strikethrough formatting code for irc, but i guess you have to draw the line somewhere
11:29:12 <danza> augur, would you say that Servant is more suitable to produce interfaces (APIs), rather than consume them? 
11:29:28 <danza> i am considering Wreq as a less type-safe alternative
11:29:42 <shapr> hpc: wow, I love that terrible pun.
11:29:59 <shapr> @remember hpc i am disappointed that there's no strikethrough formatting code for irc, but i guess you have to draw the line somewhere
11:29:59 <lambdabot> I will never forget.
11:30:09 <augur> danza: i dont thin Servant is really intended for using APIs. its a convenient way to make type-safe web servers
11:30:17 <danza> right
11:30:28 <danza> that confirms my impression, thanks!
11:40:53 <ij> This seems wrong: λ: let regeq a b = (a :: String) =~ (b :: String) :: [[String]]
11:40:54 <ij> λ: "!id foo  bar baz" `regeq` "^!([^ ]+)( +[^ ]+)+ *$"
11:40:56 <ij> [["!id foo  bar baz","id"," baz"]]
11:43:04 <seishun> is there a standard type synonym for, or something with similar functionality to, Writer [String] ()?
11:45:00 <seishun> I could define it myself, but I feel like I'm reinventing a wheel
11:46:51 <ij> You're asking whether you can import "type Something = Writer [String] ()" from somewhere?
11:47:10 <monochrom> I think the reason we don't have one is that Write [String] is pretty inefficient so no one should be using it outside toys
11:47:29 <dolio> What functionality does that type have that [String] doesn't?
11:48:08 <seishun> ij: yeah, or something else with similar functionality
11:48:48 <Zekka|Sigfig> Wouldn’t be too hard to write one that builds in reverse, would it?
11:50:03 <seishun> really all I need from it is just `tell ["whatever"]`
12:11:25 <seishun> what was the function that creates a list of x same elements?
12:12:11 <seishun> :t replicate
12:12:12 <lambdabot> Int -> a -> [a]
12:13:07 <monochrom> there is also "repeat" if you want unlimited amount
12:13:24 * hackagebot haskell-gi-base 0.13 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.13 (inaki)
12:22:54 <cpa> hi guys, quick question: when should I use a free monad and when should I use a typeclass (eg MonadSomething) ?
12:28:21 <monochrom> use both. and your free moand is an instance of your typeclass. but there are usually other instances you will want.
12:28:58 <lpaste> Mick pasted “Looping” at http://lpaste.net/156757
12:28:58 <lazyWriter> does anyone here have latest vim-haskell-now (which requires stack) working with either ghc-mod or hdevtools ?
12:29:11 <monochrom> (generally in life it is true that the answer to "which one to choose?" is "do both" or at least "try both")
12:29:44 <mick> Hi, I'm stuck on how to update the value passed into a function whilst looping
12:30:00 <mick> I've pasted the code here: http://lpaste.net/156757
12:30:02 <monochrom> (example: "which one to learn, Haskell or SVG?" answer: both)
12:30:11 <j0llyr0tten> why can't i say    :t (\x)    or    :t (\x -> y)     in Haskell at the repl?
12:30:39 <mick> in the outerloop function, the priceJump gets passed a value of 100 to represent the starting price
12:30:43 <ksf> what's the state of the art regarding combining compositional data types (that expression problem thing) and binders?
12:30:43 <monochrom> (\x) is obviously a syntax error. (\x -> y) begs the question of "but where is y defined?"
12:31:04 <cpa> monochrom: but are they semantically equivalent?
12:31:11 <mick> during the loop I want it to take on the next value of the priceJump function
12:31:20 <mick> what's the best way to do that?
12:31:22 <quchen> They don't have semantics.
12:31:30 <monochrom> they are not semantically equivalent
12:31:54 <monochrom> indeed, all the more reason to do both, since they aren't equivalent
12:31:54 <j0llyr0tten> :)
12:32:41 <cpa> ok, so what's the difference? I guess I can inspect several layers at the same time using free monads, whereas type class restricts me to one at a time? Is it the only difference?
12:33:05 <j0llyr0tten> so with :t (\x -> \y -> x)   what happens to the y that isn't paired up?
12:33:27 <monochrom> that y is discarded
12:33:44 <j0llyr0tten> why doesn't it say, "but where is y defined?"
12:34:10 <ksf> and oh my god paper titles already arrived at "compilation a la carte"
12:34:30 <ksf> it's not far until we get "a la carte papers a la carte".
12:34:34 <j0llyr0tten> did you want to use that title?
12:34:37 <monochrom> because it already says, "y is not in scope"
12:35:16 <hexagoxel> monochrom: your advice seems to result in "use any language feature and construct, regardless of the problem to be solved".
12:35:23 <monochrom> oh, about (\x -> \y -> x)? because you aren't using "y", so there is no question of "where can I find y"
12:36:17 <Cale> j0llyr0tten: \u -> v brings the variable u into scope within the expression v
12:36:23 <monochrom> hexagoxel: now if you add "compare the results", you get the best kind of scientific investigation, don't you?
12:36:44 <j0llyr0tten> so can you give me an example of a free variable in Haskell speak?
12:36:57 <monochrom> (\x -> y)  this y is free
12:37:06 <hexagoxel> monochrom: but then, your "answer" to a valid question is "investigate that exact question scientifically"?
12:37:17 <Cale> j0llyr0tten: So in the case of (\x -> (\y -> x)), the x is free in "(\y -> x)", but bound in "(\x -> (\y -> x))"
12:37:27 <j0llyr0tten> so why can't i say it? why does the repl complain, why doesn't it go, "ok, y is free"
12:38:15 <Cale> j0llyr0tten: Because in order to interpret an expression, all the free variables in it have to be in the environment.
12:38:23 <monochrom> hexagoxel: the alternative is "ask MythBuster to do it for you"
12:38:33 <Cale> If they are not, you get an error, because the variable doesn't refer to anything you've specified.
12:38:37 <hexagoxel> monochrom: as advice that is perfectly fine, don't understand me wrong. but you made it sound like giving an answer.
12:39:15 <monochrom> I am giving an answer. but if you disagree and say it's not an answer, it's an advice, that's ok
12:39:23 <hexagoxel> (i am only pushing the point because i find the question interesting myself.)
12:39:49 <j0llyr0tten> but if i'm just asking for the type? like   :t (\x -> y)    does it have to "interpret" it?
12:40:01 <monochrom> if you ask about the type of (\x -> y), it is necessary for the answerer to be told the type of y. if no one knows the type of y, no one can proceed.
12:40:37 <j0llyr0tten> can't it just say type unknown?
12:41:15 <Cale> Yeah, the same thing goes for typechecking -- the typechecker also maintains an environment of variables with their types as it goes. It's invalid to use a variable which is not bound in the environment.
12:41:16 <j0llyr0tten> i suppose that would be a different language...
12:41:16 <monochrom> it could
12:41:51 <j0llyr0tten> and I asked about Haskell, and you gave me very succint answers that I understand
12:42:13 <monochrom> send in a feature request that says "I want the set of error messages for :type to be completely distinct from the set of error messages for compilation, so that you minimize software reuse"
12:42:16 <Cale> Yeah, one could imagine a typechecker like that
12:42:43 <Cale> You could introduce free type variables for each unbound free variable, and then list the corresponding free variables and their corresponding free type variables at the end
12:43:05 <Cale> (perhaps unification would lead to some things being known about the types of the free variables even)
12:43:05 <monochrom> in fact, also send it money for getting it done
12:43:19 <j0llyr0tten> it seems to me that the simplest valid types can be enumerated thus: 0 _|_ () 1 (\x -> x) 2 (\x -> \y -> x) (\x -> \y -> y) 3 …
12:43:48 <Cale> wait, what? None of those things are types.
12:43:51 <j0llyr0tten> monochrom: LOL
12:44:01 <j0llyr0tten> hilarious answer
12:44:35 <ksf> Cale, I think that's even how I implemented my first toy typechecker.
12:44:53 <ksf> mostly for the reason that it didn't actually handle free variables.
12:44:56 <j0llyr0tten> uh? valid function types? you know what i mean
12:45:48 <saurabhnanda> hey people, what's a Haskell IDE that works? I've been struggling with Sublime Text 2 and I just can't get the build system to work. Nor the definition lookup. Nor the Hayoo lookup. Or anything apart form syntax highlighting for that matter. It's slowing down my development & learning cycle.
12:45:59 <hexagoxel> cpa: i am only starting to be familiar with free monads, so this might be wrong: you can effectively change the "implementation" for your free monad during its evaluation. i.e. a free monad is more expressive than a typeclass where none of your implementations are free monads.
12:46:11 <ksf> but there's certainly something nice to be said about being able to typecheck random source fragments individually, and have the results be composable.
12:46:47 <Cale> j0llyr0tten: Those are all terms rather than types, so they'd be valid functions, perhaps... though () is not a function.
12:47:16 <ksf> saurabhnanda, spacemacs.
12:47:25 <cobreadmonster> saurabhnanda: Well, emacs.
12:47:53 <ksf> saurabhnanda, ignore cobreadmonster, those are the wrong keybindings.
12:47:58 <saurabhnanda> ksf: is that an emacs build with comes with everything haskell-related pre-build and installed?
12:48:02 <cobreadmonster> lol
12:48:25 * hackagebot gi-atk 0.2.18.13 - Atk bindings  https://hackage.haskell.org/package/gi-atk-0.2.18.13 (inaki)
12:48:27 * hackagebot gi-cairo 0.1.14.13 - cairo bindings  https://hackage.haskell.org/package/gi-cairo-0.1.14.13 (inaki)
12:48:29 * hackagebot gi-gdk 0.3.18.13 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-0.3.18.13 (inaki)
12:48:31 * hackagebot gi-gdkpixbuf 0.2.32.13 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-0.2.32.13 (inaki)
12:48:37 <ksf> it's to emacs what debian is to linux: emacs is the kernel, spacemacs a distribution with a proper editor and package manager.
12:49:10 <quchen> saurabhnanda: Atom has pretty nice Haskell support as well.
12:49:26 <saurabhnanda> ksf: is installing haskell IDE-like features just one package away? or do I have to manually fiddle with dependencies and paths, like ST2?
12:49:34 <ksf> get yourself emacs, clone spacemacs into ~/.emacs.d, configure ~/.spacemacs to include haskell language support.
12:49:52 <quchen> I've never been happy with Sublime as a Haskell editor; the support was lacking at best. Watching Chris Done edit his stuff in Emacs always made me jealous.
12:50:04 <ksf> it builds upon the usual haskell command-line tools.
12:50:39 <j0llyr0tten> Cale: yes, they are terms, but they have corresponding types, it was to the types of those terms to which i was referring :)
12:50:52 <saurabhnanda> quchen: on Mac OSX, which emacs would you recommend? which editor has the minimum distance and pain to get Haskell up & running?
12:51:19 <quchen> I don't use Emacs, but I've heard Spacemacs is pretty good.
12:51:24 <klx> what's the best way of having a storable vector represent a 2D matrix?
12:51:33 <klx> quchen I use spacemacs
12:51:55 <ksf> (and yes spacemacs can also use non-vi keybindings)
12:52:06 <ksf> (why anyone would use that is beyond me, though)
12:52:13 <quchen> I'm on Atom right now, which is a pretty cool source editor apart from the embarassingly long loading times.
12:52:15 <monochrom> I would do my own index mapping, (i,j) -> n*i + j
12:52:39 <klx> monochrom just defining a hard coded function?
12:52:42 <cobreadmonster> quchen: Does atom do indentation?
12:53:00 <quchen> I don't know what "do indentation" means. Tab indents stuff, yes.
12:53:05 <monochrom> I don't understand the question
12:53:25 * hackagebot gi-gio 0.2.46.13 - Gio bindings  https://hackage.haskell.org/package/gi-gio-0.2.46.13 (inaki)
12:53:27 * hackagebot gi-girepository 0.1.46.13 - GIRepository bindings  https://hackage.haskell.org/package/gi-girepository-0.1.46.13 (inaki)
12:53:28 <saurabhnanda> quchen: I think it means auto-indent haskell code
12:53:29 * hackagebot gi-glib 0.2.46.13 - GLib bindings  https://hackage.haskell.org/package/gi-glib-0.2.46.13 (inaki)
12:53:31 * hackagebot gi-gobject 0.2.46.13 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-0.2.46.13 (inaki)
12:53:32 <cobreadmonster> Sorry, I meant can Atom automatically indent Haskell code?
12:53:33 * hackagebot gi-gst 0.1.6.13 - Gst bindings  https://hackage.haskell.org/package/gi-gst-0.1.6.13 (inaki)
12:53:37 <klx> monochrom so you'd leave the type as a 1D storable vector
12:53:39 <monochrom> but in Haskell I define functions 80% of the time
12:53:47 <monochrom> yes
12:53:48 <klx> monochrom but you'd always access elements through a function
12:54:06 <klx> the function would have a hard coded number of columns
12:54:07 <quchen> I don't think it does, and if it does, I don't know about it. Editors doing the indention for me are always wrong so I gave up on hoping someone would implement it properly in my lifetime.
12:54:11 <monochrom> yes. it's called functional programming for a reason
12:54:38 <monochrom> number of columns doesn't have to be hard-coded
12:54:47 <klx> it could be curried
12:55:26 <klx> seems as reasonable as anything, i just didn't know if there was a preferred approach, eg a specific type that people recommend for the representation
12:55:57 <saurabhnanda> ksf: I think I'm gonna get stuck installing spacemacs itself -- https://github.com/syl20bnr/spacemacs#install
12:56:17 <monochrom> you will hear two preferred approaches. one is what I said. the other is Vector (Vector a)
12:56:34 <monochrom> as for recommendation you will also hear both recommended
12:57:45 <klx> monochrom hmatrix & repa aren't up to the task?
12:57:57 <monochrom> they are
12:58:01 <klx> is there a way to cast to Vector (Vector a) without a new allocation?
12:58:15 <monochrom> I don't know
12:58:22 <klx> or alternatively casting a storable vector to a 2D hmatrix or repa structure without allocation & copy
12:58:35 * hackagebot gi-gstaudio 0.1.6.13 - GstAudio bindings  https://hackage.haskell.org/package/gi-gstaudio-0.1.6.13 (inaki)
12:58:37 * hackagebot ispositive 0.2 - Positive integers test.  https://hackage.haskell.org/package/ispositive-0.2 (stettberger)
12:58:39 * hackagebot gi-gstbase 0.1.6.13 - GstBase bindings  https://hackage.haskell.org/package/gi-gstbase-0.1.6.13 (inaki)
12:58:41 * hackagebot gi-gstvideo 0.1.6.13 - GstVideo bindings  https://hackage.haskell.org/package/gi-gstvideo-0.1.6.13 (inaki)
12:58:43 * hackagebot gi-gtk 0.3.18.13 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-0.3.18.13 (inaki)
12:59:05 <klx> monochrom performance is relatively important, since the data is from a C FFI result and all this is in the inner loop of a calculation that will be iterated millions of times at least
12:59:30 <monochrom> I think people say that repa is efficient
13:00:08 <klx> monochrom i'm sure it is if i were using it in isolation. But i'm wondering if it's still efficient when it has to interact with data coming back form C FFI via storable vectors
13:00:21 <monochrom> I don't know
13:00:42 <klx> i'm also kind of wondering the same thing if i'm using a function to index, since there's some basic div mod math... fine for general use
13:00:51 <klx> but it's something that i may use a lot
13:02:14 <monochrom> find out whether repa let's you pass from-to C directly, so that you don't need Data.Vector.Storable or any middleman at all
13:02:23 <j0llyr0tten> why can't i say at the repl> (\x -> \y -> x) putStrLn "hello, world"
13:02:57 <monochrom> what does "can't" mean?
13:03:45 * hackagebot gi-javascriptcore 0.2.10.13 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.10.13 (inaki)
13:03:47 * hackagebot gi-javascriptcore 0.2.4.13 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-0.2.4.13 (inaki)
13:03:49 * hackagebot gi-notify 0.2.32.13 - Notify bindings  https://hackage.haskell.org/package/gi-notify-0.2.32.13 (inaki)
13:03:51 * hackagebot gi-pango 0.1.38.13 - Pango bindings  https://hackage.haskell.org/package/gi-pango-0.1.38.13 (inaki)
13:03:53 * hackagebot gi-poppler 0.0.34.13 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.0.34.13 (inaki)
13:04:13 <monochrom> three common words that should trigger semantic wars: "can", "work", "best"
13:04:45 <monochrom> also should be banned from any programmer's vocab
13:04:51 <geekosaur> as written, the value of that is a function
13:04:59 <geekosaur> no Show instance
13:05:06 <geekosaur> which indeed is the error I get
13:05:18 <quchen> :t (\x -> \y -> x) putStrLn "hello, world"
13:05:19 <lambdabot> String -> IO ()
13:06:46 <sm> could somebody tell me how to interpolate a list of numbers in a postgresql-simple Query, eg for "... WHERE id NOT IN (?) ..." ?
13:07:38 <monochrom> it is not an error in emacs haskell-mode repl. when there is no Show instance, it is not an error, instead the type is printed.
13:07:48 <klx> monochrom well usually people don't mean those in an absolute sense. implicitly they're asking about preferred practices
13:08:04 <klx> their asking for advice in the http://haskelliseasy.com/ sense
13:08:44 <monochrom> that only explains or excuses "best"
13:08:55 * hackagebot gi-soup 0.2.52.13 - Soup bindings  https://hackage.haskell.org/package/gi-soup-0.2.52.13 (inaki)
13:08:57 * hackagebot gi-vte 0.0.42.13 - Vte bindings  https://hackage.haskell.org/package/gi-vte-0.0.42.13 (inaki)
13:08:59 * hackagebot gi-webkit 0.2.4.13 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-0.2.4.13 (inaki)
13:09:01 * hackagebot gi-webkit2 0.2.10.13 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-0.2.10.13 (inaki)
13:09:03 * hackagebot gi-webkit2webextension 0.2.10.13 - WebKit2WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-0.2.10.13 (inaki)
13:09:06 <monochrom> but programmers, of all people, are the ones who know that "can" and "work" are always too vague
13:09:45 <monochrom> because when it is a "lame" "end-user" who reports to the programmer "your app doesn't work", the programmer knows that the report is completely useless.
13:10:19 <monochrom> now just apply "don't unto others what you don't want done to you"
13:10:33 <klx> monochrom what can i say, english and people are imprecise. should be better, but these days i try to deal with the world's systemic deficiencies as they are
13:11:37 <monochrom> look, I am fine with non-programmer end-users saying, or starting with, "your app doesn't work". they are not programmers.
13:12:55 <seishun> is it common to use "flip mapM_" to execute a chunk of code for each element of list?
13:13:01 <seishun> or is there a better way?
13:13:03 <Zekka|Sigfig> seishun: It’s more common to use forM_
13:13:09 <Zekka|Sigfig> @src forM_
13:13:09 <lambdabot> forM_ = flip mapM_
13:13:19 <seishun> ooh, thanks
13:14:05 * hackagebot haskell-gi 0.13 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.13 (inaki)
13:16:14 <ReinH> monochrom: "it doesn't work" is arguably the most ambiguous sentence in the entire english language.
13:16:29 <Enigmagic> Zekka: or for_
13:16:31 <Enigmagic> :t for_
13:16:32 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
13:16:35 <Enigmagic> :t forM_
13:16:36 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
13:16:48 <Sonderblade> if you write "foo" haskell stores it as a list of 3 integers right?
13:17:23 <ReinH> No.
13:17:28 <ReinH> There are no negative characters.
13:17:46 <geekosaur> it's a bit more complex than that
13:17:51 <Zekka|Sigfig> ‘Char’ is a datatype running through this range
13:17:58 <Zekka|Sigfig> > (minBound, maxBound) :: (Char, Char)
13:17:59 <lambdabot>  ('\NUL','\1114111')
13:18:03 <Sonderblade> i was wondering if haskell has more efficient data types for storing text and how they are implemented
13:18:10 <ReinH> Yes. Data.Text.
13:18:16 <geekosaur> Data.Text is the preferred one for most purposes
13:18:21 <j0llyr0tten> monochrom: excuse me :) ignore "can't", i get an error when i say at the repl> (\x -> \y -> x) putStrLn "hello, world"
13:18:23 <Zekka|Sigfig> so you’re getting a list of values that run from ‘\NUL’ to \’1114111’
13:18:37 <seishun> is for_ equivalent to forM_ for monads?
13:18:40 <Sornaensis> :k Char
13:18:40 <lambdabot> *
13:18:44 <Sornaensis> :k Monad
13:18:45 <lambdabot> (* -> *) -> Constraint
13:18:59 <j0llyr0tten> :k Eq
13:19:00 <lambdabot> * -> Constraint
13:19:14 <Zekka|Sigfig> seishun: If you specialize it to allow only monaddy functions, you get forM_
13:19:25 <geekosaur> String aka [Char] is a linked list of cons cells linking lifted Char values (thatr is, a pointer to a thing containing a constructor tag and a value whose size depends on the native word size)
13:19:27 <Zekka|Sigfig> if you allow just any applicativey function, you get for_
13:19:31 <Enigmagic> seishun: nowadays they're equal, because all Monad instances are Applicative instances.
13:19:44 <geekosaur> it' *very* inefficient. its also very fast for some common uses, as long as your strings are short
13:19:51 <Enigmagic> well, i mean for_ can be used wherever forM_ is used.
13:19:53 <Enigmagic> not the other way around
13:20:04 <seishun> yeah
13:24:22 <Sonderblade> it looks like Data.Text uses packed utf16 to store strings. that's not very efficient
13:24:55 <Enigmagic> there was a gsoc project (i think) to convert it to utf8
13:25:14 <Enigmagic> i think perf wise it ended up being a wash but i don't know what they were measuring
13:25:32 <Enigmagic> certainly would use less memory than utf16 for english :p
13:30:15 <dolio> Go ahead and keep using lists of unicode codepoints, then.
13:30:42 <Enigmagic> Sonderblade: https://jaspervdj.be/posts/2011-08-19-text-utf8-the-aftermath.html
13:31:36 <Sonderblade> Enigmagic: thanks, skimming that link
13:35:06 <j0llyr0tten> i just want to say that haskell is very cool and that i like it a lot, that is all
13:35:16 <madgen> Hello everyone, is there a resource that explains when memory sharing occurs for a data structure?
13:39:21 <ok> http://www.spaste.com/s/LX4bDo
13:39:28 <Sonderblade> Enigmagic: he claims the string needs 48 chars on 64 bit before utf8 saves any memory, that sounds fishy
13:39:34 <monochrom> madgen: my http://www.vex.net/~trebla/haskell/lazy.xhtml talks about some of it
13:39:52 <monochrom> it's probably all of it but I haven't added enough examples
13:40:47 <dolio> No, it says it takes 48 characters before the space used for the characters is larger than the space used for the overhead.
13:41:05 <dolio> In UTF-8.
13:41:12 <geekosaur> ^
13:42:12 <Sonderblade> ok but even if the string is only 1 character, utf8 would save space in most cases
13:42:31 <geekosaur> not enough to be relevant
13:42:51 <geekosaur> another thing to consider is that it's not usual to allocate exact sizes, because that leads to memory fragmentation
13:42:57 <dolio> For 1 character you'd be, maybe, storing 49 bytes instead of 50 bytes.
13:43:06 <monochrom> this is one of those rare cases where benchmarking does not settle the competition because different people are going to insist on opposing benchmarks
13:43:26 <geekosaur> so a 1-byte Text is going to be the same allocated size as a larger one, how large depends on the exact allocator
13:44:13 <geekosaur> (power of 2 is common so on a 64-bit system you can guess reasonably that a 1-byte Text and a 63-byte Text use the same amount of allocated space)
13:44:46 <Sonderblade> i dont think so
13:46:17 <Sonderblade> 9 chars in utf16 would be 9 * 2 + 48 = 66, aligned to 16 = 80 bytes
13:46:18 <geekosaur> hm, no, 48 byte preamble not 64, so not quite that bad. (am somewhat underslept, sigh. magic cures for excessively drainy nose solicited...)
13:46:46 <geekosaur> 16 bytes before you hit the next allocation bump
13:46:51 <Sonderblade> 9 chars in utf6 = 9 * 1 + 48, aligned to 16 = 64 bytes
13:47:08 <Sonderblade> eh, utf6/utf8
13:48:28 <dolio> The memory for the characters is not necessarily going to be contiguous with the memory for the overhead, though.
13:50:03 <Sonderblade> oh. i thought haskell made sure of that for performance reasons
13:51:08 <geekosaur> it depends. I don't know how Text represents this stuff internally but I thought most of it was contiguous because it's manually managing a ByteArray# instead of using Haskell values
13:51:20 <geekosaur> (ByteString works that way, I thought Text did too)
13:51:56 <dolio> The characters are in a ByteArray, and the overhead is Int# values and constructor tags. Laying all that out as a single memory region isn't something that GHC has support for, I think.
13:52:55 <dolio> Because ByteArrays are independent things that may not even be wrapped in a constructor.
13:53:35 <dolio> Laying them all out together would require allocating the memory for the data type when you allocate the byte array, knowing that you are going to pack the array in the data type.
13:54:09 <dolio> I think it's pretty unlikely that it's going to do all that.
13:54:16 <dolio> Except by chance.
13:55:01 <s_aly> how does one generate a random number in haskell?
13:56:14 <Sonderblade> regardless, reading from that blog post i cant see why haskell didn't like utf8 over utf16
13:56:43 <Sonderblade> it's not a big win for small strings, ok. but it is not a *loss* anywhere either. and a big win for like html documents
13:57:07 <kadoban> https://www.xkcd.com/221/ <--- like this.   Real answer: https://hackage.haskell.org/package/random-1.1/docs/System-Random.html  look at stuff like randomRIO or randomIO first
13:57:11 <kadoban> s_aly: ^
13:57:34 <monochrom> kadoban: is 221 where the random number is always 4?
13:57:53 <kadoban> Yep, heh.
13:59:49 <s_aly> hahaha. I have seen that before kadoban. That's something which our prof. showed us in the first semester and it technically it works. xD
13:59:51 <geekosaur> Sonderblade, I think the gist of that one is how they had to rework text-icu (binding to external C library designed for Java) to support utf8?
13:59:51 <s_aly> Thanks!
13:59:56 <monochrom> I don't understand the wording "Haskell didn't like"
14:00:02 <geekosaur> they just converted Data.Text, but it's rarely used in ssolation
14:00:59 <geekosaur> in fact they make a point of saying that there would be a *lot* of knock-on ecosystem effects, and the small savings they saw with utf8 didn't justify the thrashing
14:01:20 <monochrom> but ask yourself this. suppose there are two implementations. first one has been around for years and has been tested to death. second one is new, seems to be 5% more efficient, but is not quite tested because it's new. will you switch? screw "like".
14:02:20 <dolio> The example of where you might save doesn't really make sense, either.
14:02:21 <monochrom> (now enter Monty Python who opens a door to reveal a goat. will you switch?)
14:02:31 <s_aly> YES!
14:02:44 <s_aly> Always switch.
14:02:58 <dolio> If `h = unstream . ... . stream` and `p = encodeUtf8 . h . decodeUtf8`, it's likely that the encode and decode functions would also be streaming.
14:03:23 <dolio> So unless the fusion _fails_, there would be no advantage to the utf-8 version.
14:03:51 * hackagebot giphy-api 0.2.0.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.2.0.0 (passy)
14:04:00 <dolio> You'd only get savings if the text is realized in the proposed encoding.
14:04:03 <s_aly> is there a chan for theoretical computer science?
14:04:07 <geekosaur> sigh. switching to backup connection
14:04:07 <Sonderblade> monochrom: i would. for certain scenarios, like grepping through files and stuff i'm sure the win is > 5%
14:04:35 <kadoban> s_aly: ##cs and #algorithms, the second is bigger for things that are relevent in both. There's also other specific channels for other areas.
14:04:37 <geekosaur> they didn't change text-icu, they just noted that much of the ecosystem using Data,Text also uses text-icu and it would require significant effort to modify to support utf8 interfaces
14:04:56 <geekosaur> read the "The results" section of that blog page carefully
14:05:32 <s_aly> thanks again kadoban!
14:05:40 <dolio> Yeah, icu uses utf-16. Right now text just copies the data and passes to icu, but if it were utf-8, it'd have to convert from that to utf-16 and back for various operations, I think.
14:06:07 <s_aly> anything specific for the theory of computation itself? or Quantum or would they fit in nicely under ##cs?
14:06:28 <monochrom> is ##cs really computer science rather than Counter Strike?
14:06:50 <hpc> you should ask /r/rust
14:07:44 <s_aly> counter strike is one of the best games i have played. entertaining competitive stuff.
14:07:46 <kadoban> monochrom: Yeah, it is comp sci
14:08:19 <monochrom> thanks
14:09:11 * hackagebot giphy-api 0.2.1.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.2.1.0 (passy)
14:09:37 <monochrom> maybe I should lurk there to see if my students get homework help there (I'm TA of a computability and complexity course)
14:10:23 <monochrom> anyway, I asked because on efnet #cs is Counter Strike
14:11:01 <s_aly> that's cool monochrom! where at?
14:11:29 <monochrom> efnet. do you want an example server?
14:12:01 <monochrom> irc.choopa.net and irc.servercentral.net are two. go to www.efnet.org for more servers
14:12:08 <MarcelineVQ> your TA mono
14:19:11 * hackagebot giphy-api 0.2.2.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.2.2.0 (passy)
14:23:44 <puregreen> is there a way to run the executable (provided by my package) with stack without building it? like “cabal run”
14:25:46 <kadoban> puregreen: 'stack exec the-executable' ?
14:26:02 <kadoban> (it doesn't automatically pick the executable like cabal run does, unfortunately)
14:26:46 <puregreen> kadoban: “stack exec” runs an already built executable, while “cabal run” seems to use runghc/ghci/something under the hood
14:27:46 <geekosaur> then you want stack runghc or stack runhaskell
14:28:24 <hexagoxel> `cabal run` is/contains `cabal build` under the hood.
14:28:57 <hexagoxel> there is `stack build --exec myexecutable`, which is close i believe.
14:28:59 <kadoban> If you want stack's exec to work more like that, you have to 'stack build && stack exec whatever', I believe that's a pretty close correspondence
14:29:05 <kadoban> Oh yeah, or that.
14:29:24 * hackagebot bits-bytestring 0.1.0.0 - Bits instance for bytestrings.  https://hackage.haskell.org/package/bits-bytestring-0.1.0.0 (oldmanmike)
14:29:26 * hackagebot bits-bytestring 0.1.0.1 - Bits instance for bytestrings.  https://hackage.haskell.org/package/bits-bytestring-0.1.0.1 (oldmanmike)
14:29:36 <puregreen> okay, thanks
15:01:38 <subttle> hi, is there name for a bifunctor that is contravariant in the second argument and covariant in the first? 
15:01:48 <subttle> there a name*
15:02:16 <shachaf> Probably not, but it's like a profunctor.
15:02:19 <Cale> subttle: well, that's a profunctor except you have the arguments swapped
15:02:39 <Cale> It's a profunctor on the opposite category :)
15:02:40 <subttle> yeah, I'm using a flipped profunctor I just wanted to know if there is a name for it :D
15:02:48 <subttle> coprofunctor? lol
15:03:08 <Cale> hahaha
15:03:11 <kadoban> copro is not a good prefix XD
15:03:27 <subttle> agreed :)
15:04:26 * hackagebot present 4.0.1 - Make presentations for data types.  https://hackage.haskell.org/package/present-4.0.1 (ChrisDone)
15:05:04 <klx> hey anyone use IHaskell / Jupyter?
15:05:19 <klx> i've got it working, but i'm not sure if i'm confused by the module support
15:05:26 <klx> or IHaskell just doesn't support modules...
15:08:00 <jle`> :t \p -> has $ prism' id (mfilter p . pure)
15:08:01 <lambdabot> (s -> Bool) -> s -> Bool
15:20:39 <Moggle> Hey, I'm trying to convert an old project to stack, and the issue I'm running into is I have a file Config.hs (was too lazy to get a config file parser) and stack is claiming it's a member of the hidden package ghc-7.10.3
15:20:50 <Moggle> how can I tell it, no, it's in the local directory?
15:29:36 <Moggle> problem fixed, wasnt using hs-source-dirs
15:29:38 <kadoban> Moggle: What's the layout of the files in the directory structure? Can you lpaste the .cabal file?
15:29:40 <kadoban> Ah.
15:29:41 * hackagebot present 4.0.2 - Make presentations for data types.  https://hackage.haskell.org/package/present-4.0.2 (ChrisDone)
15:29:54 <Moggle> thanks for the attempt to help anyways, kadoban, i appreciate it :)
15:30:01 <Moggle> fortunately i was able to fix my idiocy just in time
15:30:03 <kadoban> :)
15:47:40 <haskell037> Hi, I'm working on a project with multiple dependency, I was using stack 1.02 and I upgraded to stack 1.04. Now I have conflicts, but I didn't change my cabal file and I'm using the same version of LTS. What does upgrading stack does that make ?
15:55:47 <dmj`> haskell037: you're probably using a newer LTS version, trying changing the version back to what you were using previously
15:56:30 <shapr> Igloo: when was the last time you wibbled?
15:58:47 <haskell037> I have the same resolver version in stack.yaml, in fact, this file didn't change
15:59:38 <dmj`> haskell037: can you paste the error?
15:59:44 <dmj`> @where paste
15:59:44 <lambdabot> Haskell pastebin: http://lpaste.net/
16:00:54 <haskell037> lpaste is down :( http://pastebin.com/pAR6taK5
16:02:25 <dmj`> it's up for me, http://lpaste.net/156764
16:02:34 <dmj`> oh, you're using pastebin
16:03:02 <haskell037> maybe I was just unlucky I guess haha
16:04:37 <Igloo> shapr: Who can say
16:05:06 <shapr> Igloo: I just haven't seen a wibble from you in years.
16:44:43 * hackagebot hnn 0.3 - A reasonably fast and simple neural network library  https://hackage.haskell.org/package/hnn-0.3 (AlpMestanogullari)
16:52:13 <MP2E> hey, I'm a newbie to stack and trying to use it to set up a project, via 'stack init --solver', but some of the external dependencies on hackage have some overly restrictive package bounds. I'm pretty sure it would just work if I removed those, but manually removing them will involve downloading 5 libraries and modifying all of their .cabal files
16:52:35 <MP2E> just was curious if there is an automatic command to try the solver with removed upper bounds
16:53:33 <MP2E> if not, i might have to get nixos running : P
17:10:08 * hackagebot idris 0.11 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.11 (EdwinBrady)
17:15:20 <sydneyhacker> Question about monadplus and parsec. Newbie q
17:15:46 <sydneyhacker> So would mzero give you a different error message 
17:16:31 <sydneyhacker> E.g. myparse <|> mzero
17:16:47 <hjulle> Different from what?
17:17:18 <sydneyhacker> The parser that yoh combine using the plus operation
17:18:55 <hjulle> Just test it yourself,
17:25:23 <hjulle> sydneyhacker: How did the experiment go?
17:26:07 <sydneyhacker> Will try later no access to compiler atm. Thanks
17:27:16 <Moggle> is it a syntax error to do the following:
17:27:16 <Moggle> let x = do
17:27:24 <Moggle> can you not set do statements
17:27:26 <Moggle> to let statements?
17:27:32 <Moggle> or if you do, do you need to do some really weird indentation?
17:28:25 <verement> > let x = do return 3 in x :: Maybe Int
17:28:26 <lambdabot>  Just 3
17:28:39 <Moggle> *sigh* then this code hates me for other reasons
17:28:42 <Moggle> alright probably indentation
17:29:05 <Moggle> yep
17:29:07 <Moggle> indentation
17:29:08 <Moggle> had to
17:29:10 <Moggle> indent absurdly
17:29:22 <Moggle> the do block has to be indented more than the x = ?
17:30:49 <mistralcontrasti> while on the topic is there a complete guide on how indentation works in Haskell like one that covers the case just described.
17:32:04 <hjulle> https://en.wikibooks.org/wiki/Haskell/Indentation
17:32:54 <madgen_> merci
17:34:38 <newsham> ?karma ghc
17:34:38 <lambdabot> ghc has a karma of 8
17:34:49 <newsham> ghc++
17:34:50 <hjulle> (It is the first google result for "haskell indentation". ;))
17:35:38 <madgen_> I realised. I do feel ashamed.
17:36:45 <t7> > length "𠆢"
17:36:47 <lambdabot>  1
17:45:57 <Xnuk> > length "ㅅ"
17:45:58 <lambdabot>  1
18:22:06 <cjay> hmm looks like I actually polluted my stack snapshot packages by using --extra-lib-dirs and --extra-include-dirs with stack install
18:44:03 <nitrix> Hi, is there a Haskell monad that'd behave like so?  f >>= g =  do { x <- f; case x of Nothing -> return g; Just y -> Just y }
18:44:33 <nitrix> I'm a little tired, but my goal is to take Just if there's one, otherwise, _lazyly_ keep going through IO actions.
18:46:08 <nitrix> Things like sequence or mapM doesn't cut it, because they seem to strictly accumulate the results. I looked at MonadPlus and ehm the First monoid.
18:46:41 <dmj> nitrix: looks like Either or EitherT
18:47:17 <dmj> you want to short circuit the computation in the presence of Nothing, yet continue on otherwise
18:48:14 <dmj> > Left 4 >>= \x -> return (x + 1) >>= \y -> return (y + 1) 
18:48:15 <lambdabot>  Left 4
18:48:18 <dmj> > Right 4 >>= \x -> return (x + 1) >>= \y -> return (y + 1) 
18:48:19 <lambdabot>  Right 6
18:48:33 <nitrix> Right, excepted I'm working with something of type    MaybeT IO Identifier   already.
18:49:12 <nitrix> Well lets say :: IO (Maybe Identifier)  for the sake of simplying things.
18:49:41 <nitrix> dmj: How would traverse a list of those, evaluating only until the first Just?
18:49:45 <dmj> nitrix: that's ok, you can execute and either action inside of a MaybeT
18:52:05 <monochrom> nitrix: it looks like mplus. equivalently, Alternative's <|>
18:52:31 <nitrix> I'm looking at mappend right now.
18:52:36 <nitrix> Combined with First.
18:52:42 <monochrom> > Just 5 `mplus` undefined
18:52:44 <lambdabot>  Just 5
18:52:53 <monochrom> > Nothing `mplus` Just 6
18:52:55 <lambdabot>  Just 6
18:53:07 <monochrom> but mplus is more direct
18:54:51 <nitrix> IO doesn't seem to be a MonadPlus though.
18:55:03 <dmj> nor Alternative
18:55:10 <dmj> nitrix: MaybeT is though
18:55:11 <monochrom> I see, I misread
18:55:21 <nitrix> Oh!
18:56:52 <nitrix> x <- runMaybeT $ (MaybeT $ do { return Nothing }) `mplus` (MaybeT $ do { return $ Just "Hi!" })
18:56:57 <nitrix> > x <- runMaybeT $ (MaybeT $ do { return Nothing }) `mplus` (MaybeT $ do { return $ Just "Hi!" })
18:56:58 <lambdabot>  <no location info>:
18:56:58 <lambdabot>      not an expression: ‘x <- runMaybeT $ (MaybeT $ do { return Nothing }) `m...
18:57:13 <dmj> nitrix: lambdabot doesn't have latest transformers I believe
18:57:19 <dmj> :t runMaybeT
18:57:20 <lambdabot> Not in scope: ‘runMaybeT’
18:57:23 <nitrix> Ah.
18:57:43 <nitrix> It saddens me that it isn't updated more often.
18:57:52 <dmj> @def data MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) } deriving Show
18:57:52 <lambdabot>  .L.hs:150:26:
18:57:53 <lambdabot>      No instance for (Show (m (Maybe a)))
18:57:53 <lambdabot>        arising from the first field of ‘MaybeT’ (type ‘m (Maybe a)’)
18:57:56 <dmj> @def data MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) } 
18:57:57 <lambdabot>  Defined.
18:58:25 <nitrix> Well, it'll work but there'll be no instance for MonadPlus, right?
18:58:30 <nitrix> > x <- runMaybeT $ (MaybeT $ do { return Nothing }) `mplus` (MaybeT $ do { return $ Just "Hi!" })
18:58:31 <lambdabot>  <no location info>:
18:58:32 <lambdabot>      not an expression: ‘x <- runMaybeT $ (MaybeT $ do { return Nothing }) `m...
18:58:37 <nitrix> Whoops
18:58:45 <nitrix> I'll just use ghci.
18:58:47 <ggVGc> if I start having nested do's with different monads, that's when I would want to use monad transformers right?
18:59:07 <monochrom> no
18:59:12 <ggVGc> :(
18:59:21 <ggVGc> when do I want transformers?
19:00:00 <monochrom> when the different monads are inseparably interleaved, rather than simply nestable
19:00:17 <monochrom> nestable implies separable implies keep them separated
19:00:22 <ggVGc> ah, yeah, that makes some sense
19:14:42 <Newcomers>  Hi
19:14:48 <anastiel> hi
19:15:13 <Newcomers>  test
19:15:28 <anastiel> o-o go |test|
19:15:58 <Newcomers>  hello
19:17:18 <anastiel> I'm from Brazil and I'm starting in haskell intend to create projects on top of it like the way he works and I'm User arch linux
19:32:53 <benzrf> if i install stack, should i remove my ghc packages?
19:35:12 <ludat> benzrf: AFAIK nope
19:35:13 * hackagebot ghc-imported-from 0.3.0.0 - Find the Haddock documentation for a symbol.  https://hackage.haskell.org/package/ghc-imported-from-0.3.0.0 (CarloHamalainen)
19:36:09 <ryantrinkle> is there a datatype like Data.Map but with a monoid/measure like FingerTree?
19:36:11 <kadoban> benzrf: I do, there's not a lot of reason for them to be around for me.
19:36:46 <ryantrinkle> in particular, I'm looking for something that will keep track of the maximum value in the map efficiently
19:37:11 <koz_> ryantrinkle: Can't you shove the map in a Writer monad?
19:37:14 <monochrom> there is probably a finger tree library on hackage
19:37:44 <ryantrinkle> monochrom: yeah, https://hackage.haskell.org/package/fingertree-0.1.1.0/docs/Data-FingerTree.html looks promising
19:38:03 <ryantrinkle> but i'm not sure about how I'd do things like union/intersection
19:38:10 <ryantrinkle> koz_: I'm not sure i follow
19:38:18 <monochrom> IntMap is also a finger tree inside, but on the outside it insists on Int
19:38:28 <koz_> ryantrinkle: You said that you wanted to keep track of maximum map value.
19:38:48 <ryantrinkle> koz_: yes, but i also need to be able to update the map and (efficiently) update the maximum as well
19:38:58 <Cale> ryantrinkle: is PSQueue what you're looking for?
19:39:03 <Cale> https://hackage.haskell.org/package/PSQueue
19:39:05 <ryantrinkle> Cale: it might be
19:39:59 <Cale> ah, yeah, you again don't have something which is quite as good as hedge-union
19:40:16 <monochrom> no, go for http://hackage.haskell.org/package/psqueues instead
19:40:44 <Cale> nice
19:41:12 <ryantrinkle> ah yes, OrdPSQ looks a lot like what i need
19:42:22 <Cale> It's really unfortunate that there's no mechanism for GHC to be able to generate better code for specialisations of FingerTree
19:43:00 <ryantrinkle> Cale: yeah, are there any specializations of datastructures at all?
19:43:07 <ryantrinkle> there are definitely times that i'd like that
19:43:09 <Cale> not as far as I know
19:46:39 <Cale> http://hackage.haskell.org/package/fingertree-psqueue-0.3/docs/src/Data-FingerTree-PSQueue.html -- I wrote this fingertree-psqueue a long time ago, just as an example for how to use fingertree, but the performance (as you can see in the graphs there) is pretty terrible in terms of the constant factors.
19:47:37 <ryantrinkle> interesting
19:47:58 <ryantrinkle> i may need to look at that soon :)
19:52:19 <ludat> uit: Leaving.  [23:51]
20:01:37 <HoloIRCUser5> Hmmm, testing irc client on android
20:02:53 <jerin> parseNumber = liftM (Number . read) $ many1 digit
20:03:10 <jerin> I'm trying to convert this code from write yourself a scheme tutorial
20:03:20 <jerin> to using >>=
20:03:36 <jerin> I already did the do notation mentioned in exercise
20:03:49 <jerin> can't quite understand how to use the >>=
20:03:51 <jerin> here.
20:03:54 <jerin> can someone help?
20:04:54 <monochrom> convert do-notation to >>=
20:06:11 <jerin> monochrom:  parseNumberCompact = (many1 digit) >>= \x -> return . (Number . read) x
20:06:16 <jerin> what am I doing wrong here?
20:07:31 <monochrom> does "f . g x" mean "(f . g) x"? "f . (g x)"?
20:08:42 <ludat> first one `(f . g) x`
20:08:48 <monochrom> no
20:08:59 <monochrom> you have one more chance
20:09:12 <dmj> jerin: return $ Number (read x)
20:10:11 <jerin> dmj: thanks. so return can't be composed with the other functions?
20:11:35 <dmj> jerin: it can, just not in that way
20:11:49 <dmj> Number . read <$> many1 digit
20:12:22 <jerin> that's just fmap, same as what liftM did
20:12:24 <jerin> right?
20:12:30 <dmj> jerin: yes, same thing
20:15:57 <mounty> Is this an appropriate channel in which to ask about Database.Persistent.SQLite usage ?
20:16:19 <monochrom> yes
20:16:45 <mounty> Thanks monochrom:  I did get some answers in #yesod but need a bit more explanation.
20:16:59 <mounty>  In https://groups.google.com/forum/#!topic/yesodweb/69NSzZKh6-c M.Snoyman wrote "keeping a pool of SQLite connections is very rarely a scalable solution, I wouldn't recommend it for production."
20:18:07 <mounty> chreekat explained that since SQLite connections are just an open file, it doesn't help to have a pool of more than one connection since you can't multiply open a local file.  (I paraphrase;  that's my summary of what he said)
20:18:47 <mounty> but if your back-end is Postgresql for example then multiple connections might well help since the database itself will accept multiple connections.
20:19:26 <mounty> My problem is that the explanation, while entirely reasonable, doesn't quite fit with M.Snoyman's phraseology.
20:20:01 <mounty> He doesn't say that there's no point in keeping a pool of connections;  he says that it's not scalable.
20:20:52 <mounty> Is that just 'casual' phrasing on his part, or is he making a different point?
20:21:17 <ertes> mounty: i assume the former…  you get the same performance (and likely worse) with multiple "connections" to an sqlite database
20:21:25 <mounty> I wish Snoyman were here himself but I suppose he has to sleep sometimes.
20:21:56 <ertes> precisely because it's just a single file, and even if you would open it multiple times your filesystem will not get faster
20:22:44 <mounty> ertes:  yep, that makes obvious sense.  So if you want to scale, you have to have a more powerful machine somewhere running Postgresql or other DB.
20:23:23 <monochrom> postgresql is also vulnerable to having a bottleneck at the file system
20:23:25 <ertes> mounty: you don't necessarily need a more powerful machine…  the same machine will perform better with postgresql than with sqlite, but you will lose the convenience of having just a plain file
20:23:55 <ertes> (though there may be pitfalls, but it's difficult to get worse performance than with sqlite)
20:24:15 <mounty> ertes:  Oh!  SQLite is really quite bad then.  I didn't know.
20:24:40 <ertes> it's not *bad*…  it just doesn't replace a full database system
20:24:48 <ertes> the tradeoffs are different
20:25:05 <mounty> So Snoyman's advice might be better worded as "Using SQLite is very rarely a scalable solution, I wouldn't recommend it for production."
20:25:54 <ertes> i don't want to speak on his behalf, but my personal experience/opinion is that sqlite is just fine for simple applications, and if you ever need to scale, you can switch to a different system
20:25:59 <dmj> mounty: this might relevant: https://www.sqlite.org/whentouse.html
20:26:06 <dmj> might be*
20:26:44 <mounty> OK, got it.  Thanks ertes and dmj.  I'll look at that link.  I have to understand this.
20:28:14 <ertes> mounty: for many applications i actually prefer to use acid-state…  it's not a database system, but rather a way to have saved state
20:28:42 <ertes> it's like StateT, but the state is stored and provides the usual ACID guarantees you'd want
20:28:47 <mounty> From that link -- "SQLite works great as the database engine for most low to medium traffic websites"
20:30:06 <mounty> Thanks ertes but this is a Yesod app. so I'd prefer to do it in the the Yesod documentation does it.  Furthermore, as I want to make my application commercial, it'll have to scale so I'll want an abstracted API that plugs to SQLite, Postgresql etc.
20:30:07 <dmj> trippin' on acid state
20:30:35 <dmj> ertes: acid-state spoils you
20:31:14 <ertes> mounty: if you expect your site to grow, you might as well just use postgresql right away
20:31:20 <dmj> mounty: use postgresql
20:31:40 <ertes> then you're definitely future-proof
20:31:48 <dmj> mounty: if you need to scale w/ postgresql, use RDS, or even, https://www.citusdata.com/
20:32:18 <dmj> mounty: what does your app do?
20:32:44 <mounty> Thanks ertes and dmj but I expect there'll be multiple installations;  some customers will run their own server and SQLite might be easiest for them, and others will use a internet-facing server provided by me, in which case Postgresql will be more appropriate.
20:33:36 <dmj> mounty: on premise installations of your software can be a maintenance headache :/ can you go 100% SaaS?
20:33:59 <ertes> i should note that postgresql in its default configuration is rather conservative about resources…  if you run into the performance wall, i strongly recommend to read its documentation, which has a section dedicated to making postgresql faaaaaaaaaast
20:34:16 <ertes> (but there is no need to do that right now)
20:34:18 <Cale> While we're on the topic, does anyone know whether there are SQL databases other than Oracle which support registering queries with the DB server such that the application can be notified whenever a commit would affect the result of the query? This kind of feature is really interesting with respect to its potential interaction with an FRP system.
20:34:30 <mounty> dmj:  it's a web-implemented spaced repetition flashcard application.  http://www.landcroft.com/jackrose/
20:35:09 <ertes> Cale: postgresql's trigger system is quite powerful, but i don't know if it does that one specifically
20:35:15 <mounty> dmj:  on-premises:  I expect some customers would have confidential data that they would rather keep in-house.  That would be their decision.
20:35:44 <ertes> Cale: well, it may…  you can bind triggers to views, and a view is basically just a query
20:36:11 <Cale> hmm, interesting
20:36:16 <mounty> Cale:  there's a nasty thread about Oracle on https://developers.slashdot.org/story/15/10/15/1933206/beware-of-oracles-licensing-traps-law-firm-warns
20:36:33 <mounty> ... in case you get sucked into just using them.
20:36:55 <Cale> mounty: Yeah, there are lots of other technical concerns with building something on top of Oracle as well
20:37:12 <ertes> Cale: the downside is that it requires maintenance, which makes a binding to FRP rather ugly
20:37:28 <mounty> Cale:  like mortgaging your immortal soul?
20:37:28 <Cale> ertes: What sort of maintenance?
20:37:29 <ertes> you need to create and destroy views as well as triggers
20:38:34 <ertes> Cale: it's nominal and imperative…  at the very least you'll need a name source and some form of regioning/GC
20:38:36 <Cale> ertes: Well, I was always intending that some database-level state would be affected, so that's possibly reasonable.
20:39:46 <ertes> Cale: i remember that there is an event-driven database, but it's not SQL…  let me see if i can find it
20:40:35 <ertes> rethinkdb
20:41:24 <ertes> Cale: you may find that one interesting: https://rethinkdb.com/
20:41:24 <dmj> Cale: I assume this is the Oracle feature you're alluding to, https://docs.oracle.com/cd/B28359_01/appdev.111/b28424/adfns_cqn.htm
20:41:33 <Cale> yep
20:41:46 <Cale> ertes: hmm
20:42:06 <Cale> I think at some point we'll just have to make our own database and query language, because everything is terrible
20:42:19 <ertes> i haven't used it myself, but as far as i understand the documentation it's entirely push-based
20:43:27 <ertes> Cale: i agree, and it could be realistic, if we build it layer by layer
20:43:46 <ertes> i suggest starting with a transactional, mutable ByteString library
20:48:49 <dmj> Cale: sounds very cool, would you still use SQL?
20:49:31 <Cale> dmj: I'd still want something similar to SQL, but perhaps not exactly SQL.
20:49:39 <ertes> relational algebra
20:50:23 <Cale> Yeah, I don't want a "here is some unstructured JSON" or "key value pairs only" database.
20:50:58 <Cale> It should be founded on relational algebra and category theory.
20:51:03 <ertes> that's basically SQL, but in haskell with infix operators with a slight semantical difference: SQL uses multisets, while RA uses actual sets
20:52:35 <dmj> Cale: sure, I'd just love to have a database that could be run as simply as any haskell executable
20:52:56 <Cale> One primary goal would be better support for columns with sum types. It's too hard at present to say "this thing is a key of table A, or of table B, and we know which"
20:53:11 <ertes> dmj: there was the HaskellDB project, which gives you relational combinators and translates them to SQL
20:53:14 <Cale> and then have reasonable operations in queries to work with that
20:53:21 <ertes> but it's not a database system itself, just an interface
20:57:25 <dmj> Cale: yes, that sounds very nice
20:58:05 <dmj> @package hssqlppp
20:58:05 <lambdabot> http://hackage.haskell.org/package/hssqlppp
20:58:12 <Adeon> this is a bit on the side but in my work we use a system that gives SQL-like interface to various data sources
20:58:22 <Adeon> it can read from csv-like files and actual postgresql
20:58:37 <dmj> Cale: ^ this project I believe has a full parser front-end for a SQL version supported by postgreSQL
20:58:39 <Adeon> it's pretty unreliable software actually but I like the idea of having a translation layer
21:01:16 <dmj> ertes: nice, reminds me of opaleye
21:32:05 <Ashy> The latest version of docpad is completely broken in my blog repo,  so I'm swapping to hakyll,  it's been really smooth so far
21:33:49 <barryburd> Beginner’s question: In the definition fib'' = fix (\f -> \n -> if n < 2 then n else f (n-1) + f (n-2)), why is it okay to apply the Data.Function fix function to (\f -> \n -> if n < 2 then n else f (n-1) + f (n-2))? As far as I can see, fix requires a function a -> a as its argument, but (\f -> \n -> if n < 2 then n else f (n-1) + f (n-2)) does not have type a -> a.
21:35:23 <aarvar> @type (\f -> \n -> if n < 2 then n else f (n-1) + f (n-2))
21:35:24 <lambdabot> (Num a, Ord a) => (a -> a) -> a -> a
21:37:07 <barryburd> aarvar and lambdabot — I don’t understand your responses.
21:37:42 <aarvar> so a = a' -> a'
21:38:15 <barryburd> !!!! OK. I got it. Thank you.
21:59:27 <saurabhnanda> quick question: can pattern matching be used only for ADTs? Can I write a function with two definitions -- one for String and the other for Num, basically two types which have nothing in common?
22:06:06 <EvanR> saurabhnanda: String is a type and Num is not
22:06:09 <mniip> saurabhnanda, you can use typeclasses which are like pattern matching on types
22:06:15 <EvanR> so if you made String a Num, then yes!
22:06:22 <saurabhnanda> EvanR: I rephrase, say String & Integer
22:06:31 <EvanR> then no
22:06:59 <EvanR> but you can make an instance of class Foo for String and Integer if that makes sense
22:07:00 <saurabhnanda> what if I want my function to accept, both, String & Integer arguments?
22:07:13 <EvanR> you could accept Either String Integer
22:07:16 <mniip> what do you want your function to do
22:07:28 <EvanR> or make two different functions
22:07:55 <mniip> yeah, (Either a b -> t) ~ (a -> t, b -> t)
22:08:05 <saurabhnanda> if it receives a String, try parsing it as integer. If it succeeds, return the integer, if it fails, return zero. If it is passed an Integer, then return it as-is. One small example.
22:08:17 <saurabhnanda> Either can handle two values.
22:08:32 <saurabhnanda> what if I had to do Either UTCTime Integer String
22:08:37 <mniip> I'd do it with typeclasses
22:08:49 <EvanR> how would UTCTime be interpreted as an integer?
22:08:54 <saurabhnanda> ensureDate :: (UTCTime, Integer, String) -> UTCtime
22:09:06 <saurabhnanda> milliseconds since epoch
22:09:14 <EvanR> it goes down to 10^-12
22:09:18 <EvanR> so rounding?
22:09:26 <EvanR> this pattern is kind of sloppy
22:09:38 <saurabhnanda> or seconds since epoch
22:09:40 <EvanR> but you can do with with ConvertibleToInteger type class
22:09:59 <EvanR> its just not as flexible as just converting to an integer however you want at the use site
22:10:12 <mniip> @let class Foo a where foo :: a -> Integer
22:10:13 <lambdabot>  Defined.
22:10:26 <saurabhnanda> how do I do it with a typeclass?
22:10:41 <EvanR> if "abc" is converted to 0 then youre basically doing PHP
22:10:53 <mniip> @let instance Foo String where foo s = case reads s of [] -> 0; (x,_):_ -> x
22:10:54 <lambdabot>  Defined.
22:10:54 <saurabhnanda> class FunkyType a where // ensureTime :: a -> UTCTime
22:11:03 <mniip> @let instance Foo Integer where foo = id
22:11:04 <lambdabot>  Defined.
22:11:05 <saurabhnanda> and make String, Integer, and UTCtime instances of FunkyType?
22:11:11 <mniip> now you can say foobar :: Foo a => a -> ...
22:11:32 <mniip> > foo "123"
22:11:34 <lambdabot>  123
22:11:35 <mniip> > foo 123
22:11:36 <lambdabot>  123
22:11:41 <EvanR> >foo "abc"
22:11:46 <EvanR> > foo "abc"
22:11:47 <lambdabot>  0
22:11:48 <mniip> but
22:11:54 <EvanR> ;_;
22:11:55 <mniip> what is the actual problem you're trying to solve here
22:12:32 <saurabhnanda> mniip: general class = be lenient in what I accept from the network.
22:12:52 <mniip> are you parsing json or something/
22:13:08 <saurabhnanda> mniip: I'm expecting a certain field in a JSON to be a date, but even if it's not an iso8601 but something that can be parsed into a date, I can proceed with everything else.
22:13:12 <EvanR> saurabhnanda: the network only gives you 1 thing, ByteString
22:13:20 <EvanR> its not a random type
22:13:28 <EvanR> the parser decides what the output it
22:13:29 <EvanR> is
22:13:52 <EvanR> as far as JSON goes the parser framework in Aeson handles this
22:13:53 <saurabhnanda> EvanR: but as soon as I run Aeson.decode on it, it converts e'thing into a "native JSON types"
22:14:02 <EvanR> using FromJSON
22:14:23 <saurabhnanda> EvanR: does it? If I mark a field in a record as String and the network sends Integer, won't it barf?
22:14:37 <mniip> you can tell it to check for either
22:14:48 <mniip> and do the appropriate thing
22:14:48 <EvanR> if you want numbers to be stringified... then youll need a newtype
22:15:01 <saurabhnanda> hmmm, generally is this "weak types" frowned upon in Haskell?
22:15:12 <saurabhnanda> I guess so
22:15:13 <mniip> weak types?
22:15:17 <saurabhnanda> stupid question
22:15:26 <saurabhnanda> basically it's kind of implicit coercion
22:15:44 <EvanR> if you dont want it to convert to the wrong type or crash, then just decode as Value
22:15:48 <mniip> it wouldn't be wrong if you did it in the part it belongs in -
22:15:50 <mniip> the parser
22:15:51 <EvanR> then you can operate on exactly what it is
22:16:14 <EvanR> but producing a sane normal haskell data type is better
22:16:24 <saurabhnanda> EvanR: mniip: cool, thanks. But if I ever need something like this, typeclasses is the way to go?
22:16:38 <EvanR> FromJSON is already a class for dealing with that case
22:17:20 <saurabhnanda> another question: was trying to install spacemacs (on OSX), but it's getting confused because /usr/bin/emacs points to an older version of emacs, not the one I installed via brew. Don't know where the old version came from. Is there a way to check? How do I safely uninstall it?
22:23:53 <saurabhnanda> got spacemacs running, but it's complaining about 'evil' being unavailable. Any hints?
22:24:37 <saurabhnanda> :i Num
22:26:32 <saurabhnanda> as the famous beatles said, "Let it be, let it be...." I got it running
22:37:42 <lool`> How would I demonstrate that two `SomeNat`s are equal? Is that even a thing that makes sense?
22:37:47 <saurabhnanda> is this recommended for emacs + haskell: https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/haskell
22:39:56 <Axman6> lool`: a ~ b perhaps?
22:40:07 <Axman6> as a constraint?
22:40:19 <Axman6> assuming these are type level lats you're talking about
22:40:53 <lool`> That would work for `KnownNat`, but I'm trying to work with `SomeNat` where the `n` aren't known at compile time
22:41:16 <orb> Hi.  I am trying to write the equivalent of Lens' (Either (a, b) (a, c)) a.  How would I do that?
22:41:32 <EvanR> if you had a type class involving two SomeNats and some other property involving the two all which resulted in a ~
22:41:49 <EvanR> or :~:
22:42:25 <lool`> yeah, I was trying to work with :~: but couldn't quite get it
22:42:34 <EvanR> lool`: in your own words, why are they equal?
22:42:42 <Axman6> orb: ePairFst e f = case e of Left (a,b) -> left . (,b) <$> f a; Right (a,c) -> Right . (,c) <$> f a
22:42:48 <Axman6> s/left/Left
22:42:51 <jle`> orb: myLens f (Right (x, y)) = (\x' -> Right (x', y)) <$> f x
22:42:53 <jle`> etc.
22:43:12 <orb> Axman6: Thanks.  Hmm, I'd have hoped for a combinator that already exists.
22:43:35 <lool`> orb: Or you can use https://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Lens.html#v:lens
22:43:46 <Axman6> there might be something for Either a a, but that doesn't match your type
22:44:26 <orb> Axman6: I thought of doing something like: toBothSides _2 _2 . extract1
22:44:36 <orb> But I'm not sure how to do the `toBothSides' bit.
22:45:22 <jle`> bitraverse?
22:45:47 <EvanR> lool`: whatever reason they are equal, you can encode into more type(classe)s
22:47:59 <lool`> EvanR: My actual end goal is to be able to say "I have two lists and I don't necessarily know their lengths, but I know their lengths are equal". http://lpaste.net/156890 doesn't work
22:48:24 <EvanR> ok, so you need the list type which contains its length in the type
22:48:59 <lool`> yes, I was looking at https://hackage.haskell.org/package/vector-sized for that part
22:49:19 <lool`> But it seems like it would have to be extended for the use case I descibed above
22:49:34 <EvanR> hrm thats different
22:49:58 <EvanR> data Vect :: n -> a -> *
22:50:07 <EvanR>   Nil :: Vect n a
22:50:28 <EvanR>   Cons :: a -> Vect n a -> Vect (n+1) a
22:51:21 <EvanR> erm, Nil :: Vect 0 a
22:52:34 <lool`> The inductive definition like that make it easier to "prove" things, right?
22:53:26 <EvanR> well, this form makes it easy to state your particular condition
22:53:40 <EvanR> zip :: Vect n a -> Vect n b -> Vect n (a,b)
22:53:51 <EvanR> n = n = n
22:55:20 <EvanR> whether you can convert a Vect m b to Vect n b depends on your theory and what you start with
22:57:06 <bluezone> Thinking of trying my hand at learning haskell for the 3rd time 
22:57:55 <bluezone> all I do is Java and JavaScript in enterprise and it's all a mess :/
22:58:36 <jle`> bluezone: welcome back :)
22:58:49 <bluezone> thanks ^^
23:00:47 <lool`> EvanR: I can define that `zip` with `vector-sized` too, can't I? It seems like the hard part is getting the two matching `n`s on, say, a list of lines I read from stdin
23:01:13 <EvanR> you can have the same types and laws to use for primitive vectors that have the same type
23:01:32 <EvanR> the above is just how you could do it in the language
23:01:59 <EvanR> you said "list" so thats what Vect is
23:02:44 <jle`> lool`: the zip works with vector-sized, too
23:02:54 <jle`> the problem is that you need dependent types to get things like that to work
23:03:20 <lool`> right. But doesn't Haskell have any dependent machinery to make it possible at this point? Even if it's ugly?
23:03:20 <EvanR> you can state the type required, but the question is how you would make it go
23:03:23 <jle`> it does
23:03:31 <lool`> s/any/enough/g
23:03:32 <jle`> there are a couple of ways to go about this --
23:03:47 <EvanR> hard coded lists of the same length is the easiest case
23:04:11 <jle`> lool`: btw, i would recommend looking into the idris book being written if you're interested in this
23:04:21 <jle`> this exact problem is actually one of the very first examples of dependent types that they give
23:04:40 <jle`> examples of working with runtime-determined dependent types
23:05:54 <EvanR> lool`: this is kind of what i was curious about earlier, how can you know at compile time (just looking at the code) that two lists will have the same length? unless they are hardcoded, then you have to have some additional reasoning
23:06:08 <jle`> lool`: haskell handles things like these with existential types
23:06:12 <EvanR> i was curious what your reasoning was
23:06:23 <jle`> your 'foo' right now has the type foo :: forall n1 n2. Maybe (n1 :~: n2)
23:06:29 <jle`> but, that's the wrong type of the thing you want to say
23:07:03 <jle`> for a function like that, the caller is free to determine the n1 and n2 they want to 'prove equal'.  the location where foo is used gets to determine what n1 and n2 are
23:07:21 <jle`> but, that's not what you want.  you want to provide an :~: for a *specific* n1 and n2, not for all desired n1 and n2
23:08:06 <jle`> you really want exists n1 n2. Maybe (n1 :~: n2)
23:08:55 <EvanR> why Maybe
23:08:59 <EvanR> where did foo come from
23:09:04 <jle`> the lpaste
23:09:40 <EvanR> ah then forall would work
23:09:56 <EvanR> it could work
23:09:56 <lool`> jle`: I think I'm following so far
23:10:21 <jle`> forall isn't what you're trying to state, you don't really want to provide a proof for all n1 and n2
23:10:25 <EvanR> exists n1 n2 would only be able 2 specific types
23:10:27 <bluezone> I'm having trouble with the 5 minute tutorial on haskell.org, oh goodness, lord help me
23:10:33 <jle`> you want to provide a proof for the specific nats inside your SomeNat's
23:10:59 <EvanR> jle`: because of the Maybe its trying to do a runtime test based on the types, so Nothing if they are different and Just Refl if they are the same
23:11:05 <jle`> yes, that's what foo is trying to do.  provide the proofs only for the nats inside two and three
23:11:21 <EvanR> for any two types
23:11:40 <EvanR> up to the caller
23:11:41 <jle`> not quite; there are two specific types that it looks like lool` is trying to prove there
23:11:44 <Job316> Is there a way to modify this code to work with >>= http://lpaste.net/156912 Or is there something that already does this?
23:11:47 <jle`> it's supposed to *not* be up to the caller
23:11:53 <jle`> it's supposed to be up to whatever is inside 'two' and 'three'
23:12:48 <jle`> you aren't supposed to be able to requiest Maybe (n1 :~: n2) for any n1 and n2 you want, you only want to get it for the n1 and n2 that are inside two and three
23:13:12 <EvanR> oh. then it should be written SomeNat (Proxy 2) :~: SomeNat (Proxy 3)
23:13:34 <EvanR> Maybe
23:14:07 <EvanR> in which case you can use the 2 and 3
23:14:59 <EvanR> foo = Nothing
23:15:04 <jle`> lool`: you can get what you want by representing exists n1 n2. Maybe (n1 :~: n2) somehow, but getting it to be what you want here might be the answer to the wrong question
23:15:35 <EvanR> a better type for this is Decidable (2 = 3)
23:15:46 <EvanR> which will give you evidence at runtime that they are not equal
23:15:56 <EvanR> in this case Nothing can work either way
23:16:06 <jle`> when working with dependent types in Haskell, there are two major ways to represent existentials.  when you read in a vector from stdin, you're going to be storing it/using it as one of the two
23:16:35 <jle`> once you have it in this form, it's a little easier to see what you want to do with them
23:17:54 <jle`> there's the continuation-based representation, `(forall n. Vec n a -> r) -> r`, which is common in haskell because you don't have to create any new data types
23:18:14 <jle`> you might see a function like mkVec :: [a] -> ((forall n. Vec n a -> r) -> r)
23:18:51 <jle`> which basically encodes vector ([a]) into exists n. Vec n a
23:19:19 <jle`> you'd do something like: main = do v <- readList; mkVec v $ \vec -> ....
23:19:33 <jle`> and within the ..., you basically have (Vec n a) to work with
23:20:19 <jle`> main = do l1 <- readList; l2 <- readList; withVec l1 $ \v1 -> withVec l2 $ \v2 -> ....
23:20:26 <jle`> and in the .. there, you have a (Vec n a) and a (Vec m a) to work with
23:21:04 <EvanR> poor readList should already return the unknown n anyway?
23:21:22 <jle`> readList :: IO [Int], or something heh.  it has no length in its type
23:21:31 <jle`> l1 and l2 don't have lengths, but v1 and v2 have lengths in their type
23:21:48 <jle`> now, at this point, you don't have any proof that v1 and v2 have the same length in their type.  so that's when you'd use `sameNat`
23:21:51 <EvanR> within the ... how are we any better off than if readList just returned an extentially typed Vect
23:22:28 <jle`> well, this is just going through two steps to get the existentially typed vector.  readList to get the [a], and withVec to get the exists n. Vec n a
23:22:43 <bluezone> what have people built with this language? :)
23:22:44 <EvanR> ok
23:22:45 <jle`> you could go directoy to an `exists n. Vec n a` from IO too
23:23:03 <bluezone> Can you write microservices and the like with it?
23:23:14 <EvanR> sameNat takes KnownNats, so is that lool` problem?
23:23:44 <EvanR> also ... how do you get KnownNats form this 
23:24:09 <jle`> ah yeah, a useful withVec would be withVec :: [a] -> (forall n. KnownNat n => Vec n a -> r) -> r
23:24:14 <jle`> or, exists n. KnownNat n => Vec n a
23:24:38 <EvanR> KnownNat n *> Vec na
23:25:05 <jle`> at this point, in your ..., you have v1 :: Vec n a and v2 :: Vec m b, but you want to try to work in a scope where n and m are the same
23:25:23 <jle`> so you can do case sameNat (Proxy :: Proxy n) (Proxy :: Proxy m) of Just Refl -> ...; Nothing -> ...
23:25:38 <jle`> in the first ..., n and m are the same.  so you can basically work as if they were the same.  so 'zip' would work
23:25:50 <jle`> in the second ..., they aren't the same, so you wouldn't be able to do things like zip
23:25:59 <EvanR> Just p -> ... p ... right, in case you need this
23:26:25 <jle`> yeah, but you need to explicitly match on the Refl constructor
23:26:40 <jle`> the Refl constructor is the actual proof.  within that branch, (n ~ m)
23:26:54 <EvanR> isnt p = Refl necessarily
23:27:29 <jle`> could potentially be bottom i suppose
23:27:43 <Job316> is there an easy way to do eg [("a",3),("b",3),("r",2)] yields [["a","b"],["r"]]  - that is, when the number changes, start a new list?
23:28:00 <jle`> groupBy ((==) `on` snd) ?
23:28:13 <EvanR> i wondering how you can transfer the type facts from putting Refl there and then using a "potentially other" Refl within the branc
23:28:43 <Job316> oh nice
23:29:00 <EvanR> you basically need a value of type n :~: m, but the only posssible place it exists is within Just p ->
23:29:05 <jle`> lool`: alternatively, you can have a function sameVec :: Vec n a -> Vec m b -> Maybe (Vec p a, Vec p b)
23:29:16 <jle`> which you can implement using sameNat
23:29:21 <jle`> um, that's wrong
23:29:43 <Job316> still curious about this one if anyone has a sec: Is there a way to modify this code to work with >>= http://lpaste.net/156912 Or is there something that already does this?
23:29:49 <jle`> sameVec :: Vec n a -> Vec m b -> Maybe (exists p. (Vec p a, Vec p b))
23:30:18 <jle`> so sameVec :: Vec n a -> Vec m b -> (forall p. Maybe (Vec p a, Vec p b) -> r) -> r
23:30:30 * bluezone is taking half an hour for the 5 minute introductory exercise, why have these kind folk lied to bluezone
23:30:45 <EvanR> and hopefully these runtime tests die out soon after the input stage
23:30:55 <EvanR> and you can then use just logic
23:30:57 <jle`> bluezone: i've built a lot in haskell :D
23:31:22 <bluezone> jle`: do you have some examples i can see ^_^
23:31:52 <EvanR> Job316: that is basically fmap
23:31:54 <jle`> hm, not all of my examples are the most visible, but i've written my blog, http services, numerical algorithms, neural nets, games, etc.
23:32:12 <EvanR> > fmap (+1) (Just 5)
23:32:14 <lambdabot>  Just 6
23:32:16 <bluezone> like http restful services?
23:32:18 <EvanR> > fmap (+1) Nothing
23:32:19 <lambdabot>  Nothing
23:32:23 <Job316> but fmap is for functors, not monads, right? Isn't maybe a monad?
23:32:29 <EvanR> all monads are functors
23:32:33 <Job316> oh right
23:32:34 <Job316> duh
23:32:36 <Job316> thanks
23:32:40 <jle`> yeah, some simple ones.  and other network/distributed services
23:32:43 <bluezone> > functors
23:32:44 <lambdabot>  Not in scope: ‘functors’
23:32:51 <bluezone> ty
23:34:32 <bluezone> Ok, I will finish up this exercice and see you guys tomorrow morning! I am glad to see this is a nicer community, i've come from really toxic ones. Will be fun :)
23:35:09 <jle`> happy haskelling :D
23:35:55 <EvanR> Job316: and in case you didnt know that Maybe is a functor, the monad version of fmap has the name liftM
23:36:16 <EvanR> but fmap is better >:)
23:38:40 <Job316> ah right
23:39:20 <systemfault> The more general the constraint, the better, right?
23:39:46 <systemfault> I mean... If I have the choice between fmap and liftM... then fmap should be used because it only requires functor?
23:40:10 <jle`> fmap and liftM are often implemented differently
23:40:19 <EvanR> i just never see a reason to use liftM
23:40:28 <jle`> liftM is fmap implemented in terms of >>= and return
23:40:40 <lazyWriter> is there something like jquery/xquery for manipulating haskell data structures?
23:40:43 <lazyWriter> or is the best we have 'lens' ?
23:40:48 <bluezone> is there a function to convert "a" to 'a' 
23:40:58 <bluezone> toChar or something?
23:41:01 <jle`> liftM has one use case .... it's when you define a Monad instance, but are too lazy to write a Functor instance by hand
23:41:07 <lazyWriter> it seems to me that in 'lens', the 'path' is a function, whereas in jquery/xquery, the 'path' is a data list
23:41:10 <jle`> so you can just write instance Functor Foo where fmap = liftM
23:41:12 <EvanR> (would be interesting to have a jquery for manipulating js datastructures)
23:41:19 <jle`> lazyWriter: people say lens is the answer :)
23:41:23 <EvanR> bluezone: head
23:41:25 <jle`> bluezone: not safely
23:41:28 <EvanR> > head "a"
23:41:29 <jle`> but you can pattern match
23:41:30 <lambdabot>  'a'
23:41:35 <jle`> or use uncons
23:41:36 <lazyWriter> jle`: can you store 'lens' as a data list ?
23:41:44 <Cale> bluezone: What should it convert "" to?
23:41:48 <lazyWriter> jle`: it seems taht lens creates these 'opaque' things that I can combine, but I can't convert a 'path' to a lens
23:42:13 <Cale> bluezone: also, what should it convert "abc" to?
23:42:19 <EvanR> obviously you only use it on non empty strings!
23:42:26 <EvanR> of length 1
23:43:25 <jle`> > case "a" of (x:_) -> Just x; [] -> Nothing
23:43:26 <lambdabot>  Just 'a'
23:43:40 <jle`> > fmap fst (uncons "a")
23:43:42 <lambdabot>  Just 'a'
23:43:45 <lool`> jle`: I'm having trouble with `withVec`. It seems like even if I get it, it'll essentially be luck. You've recommended the Idris book. Is there also a good collection/summation of applying those sorts of techniques in Haskell? Or is it mostly scattered throughout papers?
23:43:50 <EvanR> > case "abc" of [x] -> Just x; [] -> Nothing
23:43:52 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
23:43:59 <EvanR> > case "abc" of [x] -> Just x; - -> Nothing
23:44:00 <lambdabot>  <hint>:1:32: parse error on input ‘->’
23:44:04 <EvanR> > case "abc" of [x] -> Just x; _ -> Nothing
23:44:05 <lambdabot>  Nothing
23:44:15 <jle`> lool`: withVec :: [a] -> (exists n. KnownNat n => Vec n a)   -- do you get that part?
23:44:21 <jle`> lool`: oh, do you mean understanding it, or implementing it?
23:44:30 <bluezone> > let (_, b) = (10, "abc") in filter (=='a') b
23:44:32 <lambdabot>  "a"
23:44:55 <lool`> I mean I'm having trouble implementing because I don't think I understand enough of how all these encodings work in haskell
23:45:20 * bluezone wonders why it is not giving him 'a' in the first place
23:45:37 <jle`> ah.  yeah, implementing it is one of those tricks that you sort of realize in a flash of inspiration, to me
23:45:42 <jle`> bluezone: try 'find', instead of 'filter'
23:45:47 <jle`> > filter (== 'a') "abcabc"
23:45:48 <bluezone> oh because it is operating on an array
23:45:48 <lambdabot>  "aa"
23:45:50 <EvanR> i think size-indexed lists are not that idiomatic really. in haskell you use vectors by the seat of your pants, just because the support is so clunky otherwise
23:45:51 <jle`> > find (== 'a') "abcabc"
23:45:53 <lambdabot>  Just 'a'
23:46:02 <bluezone> ok i see
23:46:18 <jle`> you can also use filter and listToMaybe
23:46:26 <jle`> > listToMaybe (filter (=='a') "abcabc")
23:46:27 <lambdabot>  Just 'a'
23:46:33 <jle`> but i think find f = listToMaybe . filter f
23:46:55 <bluezone> For awhile I thought the ` in your name was haskell syntax
23:46:59 <jle`> lool`: the other encoding might be more intuitive to a normal Haskeller
23:47:24 <lool`> The `sameVec` version?
23:47:42 <jle`> lool`: data SomeVec a = forall n. KnownNat n => SV (Vec n a), or data SomeVec :: * -> * where SV :: KnownNat n => Vec n a -> SomeVec a
23:50:03 <EvanR> ideally you use dependent types to avoid runtime tests rather than at length remind yourself to do them
23:50:59 <EvanR> especially when a failed test would be an error
23:52:00 <EvanR> example when constructing two vectors element by element, after n iterations they have the same length without checking at runtime
23:52:40 <EvanR> if you take the first n elements from a Vect m where m >= n then you have a Vect n
23:52:52 <EvanR> (what zip normally does)
23:53:32 <EvanR> if you zip a vect with its reverse, they have the same length
