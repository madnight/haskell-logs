00:15:41 * hackagebot jose 0.4.0.1 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.4.0.1 (frasertweedale)
01:02:35 <roelof> Hello, Has someone made a wizard/multipage form where I can look how to make such a thing ? 
01:07:50 <gfixler> is there an ML channel?
01:08:22 <gfixler> or does anyone here know ML?
01:08:47 <roelof> gfixler:  what does ML exactly mean ? 
01:09:19 <gfixler> roelof: https://en.wikipedia.org/wiki/ML_%28programming_language%29
01:10:42 <gfixler> I found #ocaml - I'll ask questions there
01:17:25 <lazyWriter> what is a good word for 'layer right above base/foundation' ? I have a graphics layer, the base layer is called "SvgNode" (which maps to HTML SvgNodes); now I have a 'combinator' layer of sorts on to of that
01:17:29 <lazyWriter> what's a good name for it?
01:20:44 * hackagebot apiary 2.0.1.1 - Simple and type safe web framework that generate web API documentation.  https://hackage.haskell.org/package/apiary-2.0.1.1 (winterland)
01:24:14 <loofee> ?
01:34:41 <loofee> names
01:36:00 <saurabhnanda> so, what's the point of a ReaderT? Why not simply use a global variable and let the functions access it? As long as the global variable is immutable (which is the case in Haskell), what value does a ReaderT monad add?
01:36:31 <Oejet> gfixler: There's #sml.
01:39:12 <rcyr> saurabhnanda: Gotta love coupling.
01:39:39 <saurabhnanda> rcyr: how's this any more coupled that a ReaderT monad?
01:40:25 <rcyr> saurabhnanda: You pass the environment to the reader when you run it, you can change it depending on the application.
01:40:42 <saurabhnanda> rcyr: same thing can be done with a global variable
01:41:03 <saurabhnanda> change it and recompile your code
01:41:17 <rcyr> saurabhnanda: What if I need two?
01:41:22 <saurabhnanda> even if you're changing the ReaderT environment you have to recompile your code
01:41:49 <saurabhnanda> rcyr: make it a HashMap or HashList -- don't you need to do that in a ReaderT as well?
01:42:07 <saurabhnanda> btw, manged to get my first stracktrace. How do read this?
01:42:08 <saurabhnanda> ["Main.main (Main.hs:(10,1)-(17,13))","Nightwatch.Websocket.startAria2WebsocketClient (Nightwatch/Websocket.hs:(221,1)-(223,11))","Nightwatch.Websocket.aria2WebsocketClient (Nightwatch/Websocket.hs:(214,1)-(218,11))","Control.Concurrent.Async.waitAnyCancel (/var/folders/fv/ct49fxsj14z0rknfclr1mvpm0000gp/T/ghc81258_0/ghc_1.hscpp:(456,1)-(457,46))","Control.Concurrent.Async.waitAny (/var/folders/fv/ct49fxsj14z0rknfclr1mvpm0000gp/T/ghc8
01:42:08 <saurabhnanda> 1258_0/ghc_1.hscpp:(447,1)-(450,57))","Control.Concurrent.Async.waitSTM (/var/folders/fv/ct49fxsj14z0rknfclr1mvpm0000gp/T/ghc81258_0/ghc_1.hscpp:(375,1)-(377,27))","Nightwatch.Websocket.startAria2WebsocketClient.\\ (Nightwatch/Websocket.hs:222:128-289)"] 
01:42:20 <rcyr> Ok, that's just trolling. Have a great night.
01:42:59 <saurabhnanda> rcyr: let me reader more and come back to you on that. Don't have a good feeling about the value that ReaderT brings on to the table.
01:43:05 <saurabhnanda> *let me read more
01:43:07 <kadoban> Heh … I have map, fmap and <$> all in the same like 5 word expression. That can't be good.
01:43:51 <kaol> kadoban: Add . for extra points.
01:44:14 <kadoban> I shall try
01:44:58 <kadoban> Lol … I can too *does*
01:46:08 <saurabhnanda> hmm, the stacktrace isn't very helpful. The Sqlite library is the originator of the exception, but it doesn't seem to feature in the stacktrace. What gives?
02:35:46 * hackagebot hspec-core 2.2.3 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.2.3 (SimonHengel)
02:35:48 * hackagebot hspec-discover 2.2.3 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.2.3 (SimonHengel)
02:35:50 * hackagebot hspec 2.2.3 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.2.3 (SimonHengel)
02:42:18 <aupiff> are ideas from (A Comblnator-based Compiler for a Functional Language --http://haskell.cs.yale.edu/wp-content/uploads/2011/03/CombComp-POPL84.pdf) and David Turner's SASL graph reduction on programs compiled to combinators still used in GHC? If so, which compilation phase?
02:46:25 <gfixler> would I be far off in saying that GADTs allow the creator of a data type to fill in the type parameters for certain constructors?
02:47:11 <EvanR> normal ADTs can do that
02:47:20 <EvanR> Just :: forall a . a -> Maybe a
02:47:55 <gfixler> hmmm
02:48:00 <gfixler> but the a isn't filled in
02:48:09 <EvanR> Just 'a'
02:48:21 <EvanR> i just filled it in (implicitly) with a=Char
02:48:34 <gfixler> but you're the user of the type
02:48:36 <gfixler> not the creator of it
02:49:01 <EvanR> oh allow the creator of the type... 
02:49:13 <EvanR> well in that case GADTs let you do more than that
02:49:22 <gfixler> is that part of it?
02:49:32 <EvanR> you can pick a=Char or a=Foo b
02:49:38 <gfixler> I'm thinking that regular ADTs still allow it, though, recursively
02:49:45 <Copperis> which typeclass do I have to implement for "head" to work?
02:49:46 <gfixler> with an extension I forget now
02:49:58 <gfixler> :t head
02:49:59 <lambdabot> [a] -> a
02:50:04 <gfixler> head works on lists
02:50:14 <Copperis> ok, thanks
02:50:35 <saulzar_> gfixler, I think the answer of your question is yes..  (allows you to fix parameters for certain constructors)
02:50:47 <EvanR> gfixler: the key difference with GADTs is really that pattern matching will give you different type info in different branches of the case
02:51:10 <gfixler> EvanR: isn't that also possible with recursive ADTs?
02:51:10 <EvanR> the type variables may have different types in different branches
02:51:13 <gfixler> again, with some extension
02:51:45 <EvanR> its possible to express the type changes with regular ADTs but in one case expression you will always have the same variables 
02:52:14 <EvanR> the expressing is much more natural with GADTs, but the case analysis is the real win
02:52:16 <ggVGc> what's a common use case for GADTs?
02:52:36 <gfixler> ggVGc: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#gadt
02:52:44 <gfixler> expression evaluators?
02:53:35 <EvanR> ggVGc: a fairly mechanical use case ive seen is that you can take programs youd normally write and delay their evaluation, by making all your functions return a data-version of their own syntax, in a way that retains the original type restrictions
02:54:01 <EvanR> then another piece of code can interpret ASTs that you constructed with normal looking haskell code
02:54:04 <EvanR> perhaps differently
02:54:23 <EvanR> so DSL ASTs
02:55:14 <EvanR> you can also use them for dependently typed programming-light
02:55:15 <gfixler> EvanR: would you say that GADTs feel like a very large topic that takes a long time to master?
02:55:23 <gfixler> I like to get a sense of the scale of things I want to learn
02:55:57 <EvanR> the actual feature and how it works is actually easy, the GADTs syntax is easier for me to explain and comphrehend than normal data syntax
02:56:07 <EvanR> which i now consider a shorthand for GADTs syntax
02:56:33 <lazyWriter> what is the difference between (1) dynamic bound / implicit parameters, i.e. https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/other-type-extensions.html and ... (2) reader monad ?
02:56:36 <EvanR> what you can do with it is sort of like "mastering things you can do with <whatever programming language>"
02:56:59 <gfixler> EvanR: that sounds about like what I expected - thanks
02:57:01 <EvanR> know how it works then keep it in your toolbox
02:57:06 <gfixler> yeah
02:57:20 <gfixler> probably gonna need many concrete examples to help me find the edges
02:58:20 <EvanR> lazyWriter: reader monad is a monad, implicit parameters doesnt involve monads
02:58:32 <EvanR> they are just implicit parameters
02:59:37 <lazyWriter> if I can use implicit parameters instead of the reader monad, is ther eanywya to pick the reader monad over implicit parameters?
03:00:19 <srhb> lazyWriter: Types?
03:00:25 <EvanR> i think implicit parameters is even more clunky than ReaderT
03:00:34 <lazyWriter> implicit parameters are typed
03:00:35 <saurabhnanda> I'm looking at http://lpaste.net/157133 and wondering if the only way to run my app with an SQL connection pool is to basically convert all top-level function (the ones being called from main) into SqlPersistM actions? Right now I had managed to stay away from SqlPersitM by calling runSqlite at every call-site, effectively converting an SqlPersistM -> IO ()
03:01:14 <Copperis> is there a List typeclass?
03:01:24 <srhb> Copperis: No standard one, no. Why would you want one?
03:01:33 <saurabhnanda> and since I'm forking in my top-level functions, I'm not sure how the Sql Connection pool is going to behave if it's shared across threads.
03:01:42 <saurabhnanda> any help?
03:02:09 <srhb> Copperis: There are type classes that generalize some of the concepts that work on lists, like Foldable and Traversable.
03:02:11 <EvanR> gfixler: try to encode the grammar for simply-typed lambda calculus as a GADT
03:02:38 <EvanR> so that the expression is well-typed by construction
03:02:50 <EvanR> then write the evaluator
03:02:55 <gfixler> EvanR: that sounds like a good exercise
03:03:01 <Copperis> srhb, I have a "data AType = AType [Int]" and would like to be able to call head on a "AType" variable
03:03:16 <gfixler> EvanR: also went to a meetup about HOAS a few months back, and just watched it again - the lambda calc factors into that, too
03:03:36 <EvanR> the rabbit hole goes deeper ;)
03:03:41 <lazyWriter> should the lower case version of TeXOptions be texOptions or teXOptions ?
03:03:58 <gfixler> it's so deep already - I don't think it's rabbits down here anymore
03:05:15 <srhb> Copperis: You can look at the newtype package for that.
03:05:35 <LaT0rtue> .
03:06:34 <EvanR> saurabhnanda: if its written to work across threads, then thats great
03:06:41 <EvanR> check if thats the case
03:07:00 <fr33domlover> srhb, it's shared
03:07:02 <EvanR> if not, maybe dont worry about pooling
03:07:07 <fr33domlover> the connection pool is meant for that
03:07:13 <fr33domlover> (concurrent use)
03:08:34 <EvanR> Copperis: also you can use (head . toList) instead
03:09:05 <EvanR> if you wrote newtype AType = AType { toList :: [Int] }
03:09:35 <saurabhnanda> fr33domlover: EvanR: yep, I guess connection pool will solve the concurrent access problem. But I'm struggling with how to evolve my code to use connection pools. I was using runSqlite at multiple places to convert SqlPersistM() -> IO(). Each call-site behaved independently of each other. Now, I need to pass around the connectionPool object, which would mean changing the function signature of almost every single function in my code!
03:10:13 <EvanR> saurabhnanda: the simplest way is to literally pass a connection pool reference anywhere it will be used
03:10:30 <EvanR> unless you can store "user data" in the persistent context
03:11:16 <saurabhnanda> EvanR: yes, but that would mean changing a lot of function signature. Converting to a ReaderT also doesn't solve anything -- even that leads to function signature changes, while adding even more complexity.
03:12:03 <fr33domlover> saurabhnanda, don't pass it around; put it in a ReaderT
03:12:27 <fr33domlover> that would be the standard and easy way to do it
03:13:56 <fr33domlover> saurabhnanda, example: SSH server that uses persistent to connect to a SQL database http://hub.darcs.net/fr33domlover/vervis/browse/src/Vervis/Ssh.hs
03:14:04 <saurabhnanda> fr33domlover: does that mean almost every function doing DB access now needs to return a ReaderT action? Or am I doing something wrong? Is so much refactoring a standard affair?
03:14:29 <EvanR> saurabhnanda: your main gripe is that to change the way the whole program is working, youd have to add an argument to "all functions ever"
03:14:34 <fr33domlover> saurabhnanda, monad transformers are super common :P
03:14:44 <EvanR> which even if thats not an exaggeration, makes sense
03:14:44 <fr33domlover> it's the /usual/ solution
03:14:45 <srhb> saurabhnanda: Doing it this way is pretty common, yes. :)
03:15:01 <EvanR> in haskell the type sigs will help you greatly to "refactor" your code to do this
03:15:19 <saurabhnanda> EvanR: not only that, there's a lot of liftIO'ing that follows. Too much of type-jigsaw-boilerplate
03:15:29 <EvanR> having to modify "all" the functions would be horrendous in ruby or js
03:15:42 <EvanR> so this is where point-hacks come in
03:15:51 <saurabhnanda> EvanR: point-hacks?
03:16:11 <EvanR> you do a thing that changes the behavior of the whole program but in a way that only changes code in some probably obscure file somewhere
03:16:17 <EvanR> spooky action at a distance
03:16:31 <EvanR> this leads to spaghetti 
03:16:57 <EvanR> if threads are sharing SQL connections somehow, it needs to be evident in the code
03:17:57 <EvanR> saurabhnanda: as far as transformer hell, you can always create a custom monad which has all the features you want and using them doing involve any lifting in the "user code"
03:17:58 <saurabhnanda> explicit vs implicit? Yes, that's what got me started with Haskell in the first place. Too much magic in a 150k LoC Rails codebase is hard to manage.
03:18:17 <fr33domlover> Q: Is there a way to use monad transformers in a way that avoids 'lift' everywhere and allows for flexibility in the order of the MTs in the stack (i.e. like with mtl), but also doesn't require that all the MTs are (conditionally) instances of all monad classes?
03:18:22 <zipper> Template Haskell is like macros for haskell? Yet there are macros in haskell
03:18:50 <EvanR> saurabhnanda: using them wouldnt involve any lifting... i think i was trying to say
03:18:51 <saurabhnanda> is this kind of stuff normal? i.e. defining your own data-types over monad-stacks? http://hub.darcs.net/fr33domlover/vervis/browse/src/Vervis/Ssh.hs#49 
03:19:02 <saurabhnanda> EvanR: how?
03:19:37 <zipper> What's the difference between metaprogramming and macros?
03:19:39 <EvanR> yes if youre going "full-transformer" then youd do well to write some synonyms to be able to type it all
03:20:13 <fr33domlover> saurabhnanda, it's just a shortcut there. Example from a library: in the 'swish' package you have 'SwishStateIO' which is... StateT IO
03:20:15 <EvanR> but just passing the connection pool around is probably not as bad as you think
03:20:56 <fr33domlover> In the Yesod scaffoldings, the connection pool is passed to all handler threads
03:21:07 <fr33domlover> that's the common way to do it, then
03:21:15 <EvanR> zipper: macros output source code, template haskell outputs haskell abstract syntax
03:21:22 <fr33domlover> and they concurrently take and release connections from the ppol
03:21:24 <fr33domlover> *pool
03:21:28 <EvanR> thats one difference
03:21:44 <EvanR> i dont know what is or isnt "metaprogramming"
03:23:30 <saurabhnanda> EvanR: fr33domlover: stuff like this was handled very well in Common Lisp via dynamic bindings. Any parallel in the Haskell universe?
03:24:03 <fr33domlover> saurabhnanda, referencial transparency?
03:24:21 <saurabhnanda> fr33domlover: didn't understand your question
03:24:50 <fr33domlover> saurabhnanda, ah sorry, then ignore the question mark
03:24:51 <EvanR> saurabhnanda: are you talking about your connection pool issue? or "macros" ?
03:25:00 <saurabhnanda> anyways, given a choice between passing the connectionPool around, or resorting to monad-transformers all the way down, what's recommended?
03:25:13 <EvanR> youre effectively asking for a global variable for your connection pool
03:25:29 <EvanR> which you can do, but its not a good idea
03:25:31 <saurabhnanda> btw, I wasn't able to break the forkIO $ forever barrier last time I tried the monad-transformer route. Wasn't able to solve the type-jigsaw puzzle.
03:25:36 <fr33domlover> the connection pool already stores its fields as MVar / TVar / IORef
03:25:49 <fr33domlover> putting it inside a global var is unnecessary
03:25:57 <fr33domlover> just pass it around, it's safe
03:26:02 <EvanR> saurabhnanda: use functional programming to take out the repeated parts and put them in a function
03:26:04 <saurabhnanda> zipper: was asking about macros. I'm very well versed with Macros after 3 years of coding in Common Lisp.
03:26:31 <EvanR> this is one of the nice parts of haskell, even the IO crunchy bits can be factored out into functions
03:26:40 <zipper> saurabhnanda: Nice, tell me more.
03:26:40 <saurabhnanda> btw, I wasn't able to break the forkIO $ forever barrier last time I tried the monad-transformer route. Wasn't able to solve the type-jigsaw puzzle.
03:26:55 <Copperis> EvanR, thanks. Got the example compiling. 
03:27:01 <EvanR> saurabhnanda: what exactly was the problem?
03:27:04 <Copperis> Can anyone explain what happens on line 19 if getAddress returns a Nothing? http://lpaste.net/157137 Does it still execute further code or it somehow breaks?
03:27:04 <zipper> I just started a job writing clojure and macros seem like a big thing.
03:27:15 <EvanR> they are
03:27:25 <EvanR> good luck with that ;)
03:27:28 <zipper> EvanR: UH and the source code from macros become AST after the first step of compilation?
03:27:39 <EvanR> most of the theings clojure uses macros for normally are normal code in haskell
03:27:48 <EvanR> pattern matching, traversing of data structures
03:27:52 <zipper> EvanR: You know understanding the compilation process in a lisp is so easy.
03:27:53 <EvanR> control flow
03:28:00 <saurabhnanda> zipper: I know practical uses of Lisp macros. Don't know much about how Haskell approaches them. But IIRC macros is just a way of doing meta-programming. Meta-programming is a general principle where you write a program which writes another program. There are multiple ways of doing that. Macros being one of them.
03:28:14 <zipper> I have been writing haskell for a while now and GHC is still much a black box to me :(
03:28:38 <hpc> zipper: the ghc trac has a commentary section that's a VERY interesting read
03:28:42 <zipper> saurabhnanda: I've written haskell macros to get around supporting different versions of GHC and other libs
03:28:43 <EvanR> zipper: lisp lore tends to pretend there is no difference between textual code, abstract syntax, and runtime representations
03:28:43 <pavonia> Copperis: If note does what I think it does, the whole execution stops at the point one of the Maybes returns Nothing
03:28:53 <zipper> hpc: Please refer me to it.
03:28:53 <EvanR> which is completely misleading
03:29:02 <hpc> @where commentary
03:29:02 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
03:29:08 <hpc> that's not it
03:29:12 <saurabhnanda> zipper: homoiconicity is such a pleasure to work with. The first time I wrapped by head around reader & compiler macros, it just blew my mind. It took me to whole new programming dimension.
03:29:19 <hpc> https://ghc.haskell.org/trac/ghc/wiki/Commentary
03:29:39 <zipper> EvanR: Yes it does so, I thought in lisps there actually isn't.
03:30:04 <zipper> At least that mental model hasn't broken down for me yet.
03:30:05 <saurabhnanda> zipper: ah, C and Haskell, in that case, have a different connotation for the work 'macros', which is very different from how lisps use the word.
03:30:10 <EvanR> homoiconicity is one of those concepts which cant really stand scrutiny, when you want a definition that isnt "what a lisp is"
03:30:33 <EvanR> zipper: it has for me, thankfully
03:30:42 <saurabhnanda> EvanR: please elaborate.
03:30:43 <zipper> hpc: Thanks :)
03:31:02 <EvanR> saurabhnanda: that would probably start a flamewar
03:31:14 <zipper> EvanR: I'm not very experienced though, so I haven't done many hard core things.
03:32:38 <Copperis> pavonia, right, so it short-circuits as I understand, because I still get a Left with the message 
03:38:02 <EvanR> zipper: and more generally its nice to notice when various concepts that are all considered "the same" by some culture, what those different conceptus are, and then in what way someone may consider them the same
03:38:24 <EvanR> example integers and real numbers are sometimes considered the same data type
03:39:08 <EvanR> and in set theory integers and real numbers are considered sets of sets of sets of...
03:39:26 <EvanR> "its all the same" is where dynamically typed programming gets its difficulty from
03:41:03 * hackagebot dead-code-detection 0.6 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.6 (SoenkeHahn)
03:41:50 <zipper> EvanR: Both are meta programming though, right?
03:42:04 <EvanR> both?
03:43:29 <srhb> > (Left >=> Right) "Yep, short cirtuits on Left" -- Copperis
03:43:31 <lambdabot>  Left "Yep, short cirtuits on Left"
03:46:03 * hackagebot stylish-haskell 0.5.16.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.5.16.0 (JasperVanDerJeugt)
03:46:31 <zipper> EvanR: Both macros and TH
03:46:50 <pavonia> :t (>=>)
03:46:51 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:47:00 <EvanR> they are both code generation
03:47:43 <EvanR> meta-programming sounds like a buzz, and obscures common techniques like domain specific languages
03:48:02 <EvanR> programming is already meta basically
03:51:24 <Copperis> srhb, thanks
04:06:03 * hackagebot webkitgtk3-javascriptcore 0.13.1.2 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.13.1.2 (HamishMackenzie)
04:06:05 * hackagebot webkit-javascriptcore 0.13.1.2 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkit-javascriptcore-0.13.1.2 (HamishMackenzie)
04:22:16 <saurabhnanda> will someone be nice enough to explain the first code snippet at http://lpaste.net/157133#a157133 ? what're all the run*T calls doing?
04:22:41 <saurabhnanda> withSqlitePool return an (m a) where (MonadBaseControl IO m, MonadIO m, MonadLogger m)
04:23:48 <pavonia> run*T usually indicates unwrapping a monad transformer layer
04:32:33 <saurabhnanda> pavonia: what would be the concrete type returned by withSqlitePool in this case? Is there any easy way to work that out?
04:34:13 <saurabhnanda> why is runResourceT required?
04:34:22 <lyxia> put a hole there and ghc will tell you its type
04:35:05 <saurabhnanda> lyxia: you mean _hole? and how will GHC tell its type? do I have to apply some special keybinding on spacemacs to get that? and will it stil tell me the type if the entire program doesn't compile?
04:36:01 <lyxia> just replace withSqlitePool with _withSqlitePool and compile
04:36:41 <lyxia> it will tell you the type inferred for it
04:37:02 <lyxia> there's no special option, it's built in
04:38:44 <saurabhnanda> let me try that.
04:39:02 <saurabhnanda> in the meantime, what's the best way to string-along a monad-stack across the forkIO boundary?
04:39:28 <saurabhnanda> fn :: ReaderT (blah) and I want to forkIO fn -- how do I do it?
04:40:14 <lyxia> monad-control maybe
04:41:59 <lyxia> heh, your types already have the MonadBaseControl constraint
04:50:44 <saurabhnanda> lyxia: what does that mean?
04:51:01 <saurabhnanda> actually I don't understand the difference between MonadBaseControl and MonadIO
04:51:32 <saurabhnanda> these transformers are really confusing. I mean, isn't IO supposed to be a monad? What does MonadIO really mean beyond that?
04:53:14 <liste> saurabhnanda: MonadIO basically means "any monad where IO actions can be performed", ie. a transformer stack where IO is the bottom
04:55:58 <saurabhnanda> liste: vs MonadBaseControl?
04:57:29 <liste> saurabhnanda: MonadBase is basically a generalization of MonadIO to other "base" monads (ST etc..) and MonadBaseControl generalizes that to allow control operations like `catch'
04:58:12 <saurabhnanda> generalization overload
04:58:58 <liste> writing MonadBaseControl instances is *hard*, at least for me
04:59:04 <saurabhnanda> so, why would one have MonadBaseControl and MonadIO constraints on the same type? Isn;t MonadIO the most restrictive out of the two?
04:59:49 <fr33domlover> saurabhnanda, maybe your function uses functions with MonadIO constraint, and functions with MonadBaseControl?
04:59:59 <fr33domlover> and then you may need to specify both
05:01:32 <saurabhnanda> fr33domlover: on the same type variable?
05:02:57 <fr33domlover> saurabhnanda, sure. I don't know specifically about these 2 classe, but in general why not? Did you check whether MonadBaseControl (over IO) implies MonadIO?
05:03:26 <fr33domlover> If yes, /then/ using both is unnecessary (just like MonadIO implies Monad, so you never need to specify both afaik)
05:03:58 <saurabhnanda> gawd, how much I hate monad transformers. That and the lack of optional arguments. Biggest gripes with Haskell.
05:07:06 <osfameron> I think the lack of optional arguments is a feature
05:07:16 <osfameron> or at least, it's the thing that enables other features
05:11:30 <joco42> i am looking for some solution what would unwrap a data type , something like data W = W1 Int | W2 String, unwrap :: W -> Maybe String, the idea is that unwrap should be generated, any suggestions ? is there already something like that ? maybe with TH ?  
05:11:30 <phaskell-1> W2 Welcome - https://phabricator.haskell.org/W2
05:11:30 <phaskell-1> W1 Ignore this, there is no way to delete panels. :( - https://phabricator.haskell.org/W1
05:13:32 <Gothmog_> joco42: You could write a class Unwrappable t with unwrap :: W -> t
05:14:14 <joco42> Gothmog_:  yeah, but i guess maybe TH could write that for me ?
05:14:20 <Gothmog_> Sure.
05:14:35 <joco42> i was wondering  if something like that already exists
05:14:36 <Gothmog_> But it might not be worth it :)
05:14:43 <Gothmog_> dunno
05:14:49 <joco42> coz this seems to be a general pattern
05:15:27 <joco42> on the other hand, i think the lens has it already, and they might be called prisms ?
05:15:39 <joco42> need to look into that
05:19:32 <joco42> i think this might be what i want https://hackage.haskell.org/package/Chart-1.1/docs/src/Control-Lens-TH.html#makePrisms
05:21:06 * hackagebot hsdev 0.1.7.2 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.7.2 (AlexandrRuchkin)
05:29:03 <hexagoxel> joco42: i guess you want `lens`.
05:29:21 <hexagoxel> > Left "abc" ^? _Left
05:29:22 <lambdabot>  Just "abc"
05:29:25 <hexagoxel> > Left "abc" ^? _Right
05:29:27 <lambdabot>  Nothing
05:34:10 <zipper> Using this to learn Template Haskell https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html
05:34:16 <zipper> You think it's a good resource?
05:40:59 <aeyalcinoglu> hello, a newbee question: why is the type of this function : answer1 xs =  sum [x | x <- xs, (mod x 3  == 0) || (mod x 5 == 0)] is Integral a => [a] -> a?
05:42:25 <lyxia> because it works for any Integral type
05:42:31 <maerwald> :t mod
05:42:32 <lambdabot> Integral a => a -> a -> a
05:47:29 <aeyalcinoglu> but i put a list inside the function not an integral
05:47:43 <aeyalcinoglu> (btw this is my second day with haskell so please explain with easy terms)
05:48:29 <lyxia> "Integral" means "like an integer"
05:49:19 <maerwald> aeyalcinoglu: are you asking why the output is not a list?
05:49:29 <aeyalcinoglu> i thought answer1 :: list -> int
05:49:33 <Rotaerk> the type of that expression isn't Integral a => [a] -> a though
05:49:40 <Rotaerk> it's just Integral a => a
05:50:06 <aeyalcinoglu> Rotaerk: when i write :t answer1 it tells me Integral a => [a] -> a
05:50:17 <gfixler> Rotaerk: it takes a list - xs
05:50:34 <Rotaerk> oh, I missed the "answer1"
05:50:39 <Rotaerk> thought the expression started with sum
05:50:47 <gfixler> :t mod
05:50:48 <lambdabot> Integral a => a -> a -> a
05:50:55 <gfixler> that's where the Integral constraint comes from
05:51:01 <maerwald> gfixler: scroll up ;)
05:51:04 <lyxia> The type is "[a] -> a", and "Integral a" is a constraint on the type variable a
05:51:21 <gfixler> maerwald: ah, good show
05:51:52 <maerwald> I don't understand what exactly his problem is though
05:52:11 <maerwald> maybe he hasn't had typeclasses yet?
05:52:21 <gfixler> (or she)
05:52:44 <aeyalcinoglu> okay i will do some reading and try to figure out by myself, or come back and ask again
05:52:46 <aeyalcinoglu> thanks all
05:52:56 <gfixler> aeyalcinoglu: we want to help, though :)
05:53:30 <maerwald> number stuff is a little bit awkward in haskell, but there is more than just "Int"
05:54:02 <maerwald> depending on which functions you use, the compiler will try to fix the minimum of constraints
05:54:49 <maerwald> "Int" is pretty strong... if you have a function that just uses "+" you don't really want Int, see
05:54:49 <maerwald> :t (+)
05:54:50 <lambdabot> Num a => a -> a -> a
05:55:00 <maerwald> it can be more general
05:55:06 <Schrostfutz> hi, is there a n:1-map in haskell? Ideally it would have a dynamic n, such that the mapped function can determine it at runtime.
05:56:30 <Rotaerk> Schrostfutz, what's a "n:1-map"?
05:56:57 <Rotaerk> is there more to it than just "a function that maps a list into a single value"?
05:57:30 <Schrostfutz> Rotaerk: my use-case is a tokenizer that transforms a charstream into tokens. Depending on the token the length of the string consumed is not predetermined.
05:58:12 <Rotaerk> oh; the thing that comes to mind for me is parsec
05:58:13 <gfixler> Schrostfutz: that sounds more like parsing, or folding
05:58:54 <Schrostfutz> Rotaerk, gfixler: okay, I'll look into parsec for it. Thank you :)
05:58:56 <gfixler> mapping maintains list length
05:59:06 <gfixler> folding doesn't have that constraint
05:59:37 <xa0> :t (=~)
05:59:38 <lambdabot>     Not in scope: ‘=~’
05:59:38 <lambdabot>     Perhaps you meant one of these:
05:59:38 <lambdabot>       ‘==’ (imported from Data.Eq), ‘#~’ (imported from Control.Lens),
06:33:27 <numee> What is the best way to get the AST of a Haskell expression?
06:34:11 <tsw> Why can't we give default definitions for methods of a superclass?
06:34:44 <tsw> Like `pure = return` in Monad?
06:35:19 <phanimahesh> The default definitions are `pure=pure` etc.
06:35:47 <EvanR> numee: if you have an Exp, then.. that is it
06:35:53 <tsw> phanimahesh: what, in Monad?
06:36:00 <EvanR> thats an AST
06:36:34 <EvanR> there is a proposal to allow superclass defaults
06:36:49 <tsw> Oh... what's it called, do you know?
06:36:54 <numee> EvanR: the program I'm writing receives an expessoin as a String
06:37:04 <EvanR> https://wiki.haskell.org/Superclass_defaults
06:37:22 <EvanR> numee: yurg... well then i guess you need a parser
06:37:28 <tsw> Thanks, EvanR!
06:37:41 <EvanR> haskellhttps://hackage.haskell.org/package/haskell-src-exts
06:37:44 <EvanR> https://hackage.haskell.org/package/haskell-src-exts
06:38:11 <numee> EvanR: thank you!
06:39:04 <saurabhnanda> does the 'hole' feature of GHC give the most generic type or the most specific type?
06:39:32 <EvanR> there might be many most specific types so thatd be unhelpful
06:39:44 <saurabhnanda> Main.hs:13:3: Found hole ‘_withSqlitePool’ Main.hs:13:3: Found hole ‘_withSqlitePool’  Main.hs:13:3: Found hole ‘_withSqlitePool’  Main.hs:13:3: Found hole ‘_withSqlitePool’ 
06:39:51 <EvanR> there are variables involved so i assume this is the unique most general type
06:40:47 <saurabhnanda> Main.hs:13:3: Found hole ‘_withSqlitePool’ …      with type: String -> Integer -> (ConnectionPool -> IO ()) -> IO a0    Where: ‘a0’ is an ambiguous type variable    Relevant bindings include main :: IO () (bound at Main.hs:12:1)
06:41:15 <saurabhnanda> is main :: IO () restricting the type of withSqlitePool, which is supposed to return some MonadIO magic
06:42:12 <joco42> can haskell be compiled to ios/android?
06:43:52 <EvanR> joco42: ive heard rumors that it can
06:44:32 <EvanR> saurabhnanda: ehm... so a0 can be anything it seems. 
06:44:39 <EvanR> like its not used
06:45:01 <saurabhnanda> EvanR: but it's IO a0, not (m a0)
06:45:11 <joco42> i wonder if this 3penny gui would be good to make ios apps ?
06:45:22 <EvanR> saurabhnanda: ... and?
06:45:35 <EvanR> whats wrong with IO
06:46:09 * hackagebot semiring-simple 1.0.0.1 - A module for dealing with semirings.  https://hackage.haskell.org/package/semiring-simple-1.0.0.1 (pharpend)
06:46:59 <ertes> tsw: superclass defaults can be done with -XDefaultSignatures
06:47:00 <joco42> or haskell can be compiled to js...
06:47:22 <ertes> joco42: there are a number of ways to do that: GHCJS, haste, …
06:47:29 <joco42> yeah
06:47:30 <ertes> search for "javascript problem" on the haskellwiki
06:49:35 <EvanR> saurabhnanda: if youre asking why m=IO, probably because youre trying to define main which has a known type
06:57:13 <saurabhnanda> EvanR: right, that's what I thought. So the 'hole' features solves as many type-equations as possible and then tells the most specific type possibly known till that point
06:57:57 <ertes> > let x = 3 in x + _y
06:57:58 <lambdabot>      Found hole ‘_y’ with type: a
06:57:58 <lambdabot>      Where: ‘a’ is a rigid type variable bound by
06:57:58 <lambdabot>                 the inferred type of it :: a at <interactive>:1:1
06:58:28 <EvanR> saurabhnanda: no, its the most general
06:58:38 <ertes> usually x would most likely be of type Integer…  GHC seems to try to infer a more general type
06:58:47 <EvanR> :t 3
06:58:49 <lambdabot> Num a => a
07:00:39 <saurabhnanda>  Expected type: IO ()      Actual type: monad-logger-0.3.17:Control.Monad.Logger.NoLoggingT (resourcet-1.1.7:Control.Monad.Trans.Resource.Internal.ResourceT IO) ()
07:00:42 <saurabhnanda> .....and I'm stuck with transformers, yet again! 
07:00:48 <EvanR> yep
07:01:02 <saurabhnanda> aren't transformers supposed to _behave_ like whatever you want them to behave?
07:01:04 <EvanR> "monad base control" o_O
07:01:34 <EvanR> no, transformers are kind of nuts
07:01:41 <saurabhnanda> why can't I throw a NoLoggingT ResourceT IO () into IO ()
07:01:47 <EvanR> the types dont match
07:02:11 <EvanR> you need to use a run function of some sort, or if its MonadIO, liftIO
07:02:22 <saurabhnanda> EvanR: can you help me with what's happening in the first snippet at http://lpaste.net/157133#a157133
07:02:38 <maerwald> -1 transformers +1 proper effect system :P
07:02:55 <EvanR> alright... so what is the type of runStderrLoggingT
07:04:12 <saurabhnanda> runStderrLoggingT :: MonadIO m => LoggingT m a -> m a
07:04:55 <EvanR> whats the type of withSqlitePool
07:05:44 <saurabhnanda> that's what I was trying to find out with the hole above
07:05:52 <EvanR> isnt not documented?
07:06:12 <saurabhnanda> withSqlitePool :: (MonadLogger m, MonadIO m, Control.Monad.Trans.Control.MonadBaseControl IO m) => T.Text -> Int -> (ConnectionPool -> m a) -> m a
07:06:23 <EvanR> ok
07:06:29 <EvanR> getting closer to the answer
07:06:29 <saurabhnanda> it's too confusing to read because of generalizations, wanted to see what it was in the spot where I'm using it
07:06:55 <EvanR> well in that spot its all up to you
07:07:35 <EvanR> :t liftIO
07:07:36 <lambdabot> MonadIO m => IO a -> m a
07:07:41 <EvanR> so
07:07:50 <EvanR> in your lambda that starts with \pool ->
07:08:20 <EvanR> youre using liftIO, which it taking an IO and converting to "some monad". but youre trying to be in m = IO 
07:08:23 <saurabhnanda> so look at the last snippet at http://lpaste.net/157133#a157283
07:08:35 <EvanR> take out the liftIO
07:08:58 <EvanR> if the argument to liftIO was IO Foo, then that is what you want, m = IO
07:09:27 <saurabhnanda> EvanR: actually the first snippet is not my actual code, It's straight from the Yesod/Persistent tutorial. The lowest-level fn of my code is the last snippet.
07:09:36 <EvanR> ...
07:10:05 <saurabhnanda> EvanR: I'm trying to understand what the first snippet is doing, and trying to use that learning to do what I want in my actual code.
07:10:11 <EvanR> so... what are you asking now
07:10:16 <EvanR> i dont see much in the last snippet
07:10:27 <saurabhnanda> http://lpaste.net/157133#a157283
07:10:36 <saurabhnanda> the hole, with everything generic
07:10:36 <EvanR> i see that
07:10:43 <EvanR> runDb pool operation = _runSqlPool operation pool
07:10:44 <saurabhnanda> Found hole ‘_runSqlPool’ with type: t1 -> t2 -> t
07:10:51 <saurabhnanda> what am I supposed to do with that!
07:10:56 <EvanR> i dont know what the context is
07:10:59 <EvanR> theres no type sig
07:11:04 <EvanR> theres no use site
07:11:13 <EvanR> this is like
07:11:20 <EvanR> f a b = _ b a
07:11:23 <EvanR> and asking whats wrong
07:11:40 <lyxia> indeed you're supposed to use holes where there is stuff to infer
07:11:42 <EvanR> try f a b = flip f b a
07:12:12 <EvanR> dont actually try that
07:12:39 <EvanR> my equational reasoning automatically filled that in as if f was an argument
07:12:55 <saurabhnanda> okay
07:12:59 <EvanR> saurabhnanda: try putting a type sig
07:13:05 <saurabhnanda> so holes don't work across module boundaries?
07:13:13 <EvanR> that is not the issue here
07:13:20 <saurabhnanda> EvanR: I don't know what the type sig should be -- because of all the transformer magic going on
07:13:27 <EvanR> well you need to solve that
07:13:30 <saurabhnanda> okay, let's stick with the first snippet
07:13:37 <saurabhnanda> if I understand that, I can make sense of the other call sites
07:13:51 <EvanR> what is the type of runResourceT
07:17:02 <saurabhnanda> :t runResourceT
07:17:03 <lambdabot> Not in scope: ‘runResourceT’
07:17:26 <dougia> @pl triangle2 left centre right  x  = fuzzyTrunc ( f left centre right x)
07:17:27 <lambdabot> triangle2 = (((fuzzyTrunc .) .) .) . f
07:18:29 <EvanR> saurabhnanda: do you understand a simple transformer run type sig such as runReaderT ?
07:18:41 <saurabhnanda> :t Control.Monad.Trans.Resource.runResourceT
07:18:42 <lambdabot> Control.Monad.Trans.Control.MonadBaseControl IO m => Control.Monad.Trans.Resource.Internal.ResourceT m a -> m a
07:18:55 <saurabhnanda> EvanR: one 'run*T' I understand
07:19:13 <saurabhnanda> it's the stackign which causes all the confusing
07:19:16 <saurabhnanda> *confusion
07:19:47 <EvanR> ok do you understand how to combine a runReaderT with a runWriterT
07:19:47 <Sindriava> saurabhnanda: run*T unwraps the transformer and returns the underlying monad.
07:20:06 <EvanR> you just need to understand the type signatures first
07:20:09 <EvanR> :t runReaderT
07:20:11 <lambdabot> ReaderT r m a -> r -> m a
07:20:14 <EvanR> :t runWriterT
07:20:15 <lambdabot> WriterT w m a -> m (a, w)
07:20:31 <EvanR> when you use these together, `m' is going to be one thing in one, and another thing in the other
07:20:39 <EvanR> its important to know what m is at each point
07:22:31 <saurabhnanda> EvanR: how is this even remotely useful! It's completely coupling my application code with the internal structure of a library that I'm using
07:22:39 <Sindriava> (I think the suspended computation analogy for monads is the best one I heard so far)
07:22:54 <saurabhnanda> EvanR: isn't there a magical unwrap function which unwraps whatever it has to unwrap
07:23:20 <EvanR> no
07:23:43 <EvanR> each run is dedicated to implementing how a particular monad works
07:23:46 <Sindriava> saurabhnanda: Generic unwrapping of monads isn't possible.
07:23:47 <saurabhnanda> look at the first snippet at http://lpaste.net/157133#a157133 -- one needs to know the precise order in which to call the run*T unwrapper functions. Which means either the library can never change its internal, or my code will break the day they decide to change their internals
07:24:28 <EvanR> saurabhnanda, let me try to explain how this is supposed to work
07:24:30 <saurabhnanda> in that case, I understand. There's not magic happening at all. One needs to look at the exact monad stack, in the exact order, and call the run*T functions.
07:24:37 <EvanR> theres no magic.
07:25:00 <EvanR> lets say you are trying to write a giant imperative program with many ridiculous features
07:25:05 <EvanR> which it looks like you are
07:25:30 <saurabhnanda> now, my question is, what *is* runResourceT? why is that being called after the pool has been created vs runStderrLoggingT being called **before** the pool has been created?
07:25:35 <EvanR> now you throw your hands up and say, man i wish i just had a "monad" Foo a which has all the commands i want to do all th things
07:25:44 <EvanR> so what you can do is
07:25:57 <EvanR> implement this type Foo and all its functionality, including ways to do IO
07:26:17 <EvanR> implement Foo's Monad instance, and expose a bunch of commands to the client code that uses all these features
07:26:26 <EvanR> the client code will depend on all these features
07:26:49 <EvanR> if the internal structure of your monad type is changed, but your interface stays the same, thats fine the client code wont need to know about it
07:26:52 <dougia> @pl fuzzyTruncFn  (f left centre right)
07:26:52 <lambdabot> fuzzyTruncFn (f left centre right)
07:26:54 <EvanR> alright so theres that
07:27:02 <EvanR> next, you go to implement this type Foo for the first time
07:27:12 <dougia> fuzzyTruncFn  (f left centre right)
07:27:14 <EvanR> and someone tells you to use transformers to do it
07:27:22 <dougia> @pl fuzzyTruncFn  (f left centre right)
07:27:22 <lambdabot> fuzzyTruncFn (f left centre right)
07:27:23 <EvanR> and that is what youa re doing
07:27:32 <EvanR> unfortunately you are doing it in the main function of the program
07:27:35 <EvanR> there is no client code
07:27:48 <EvanR> its inside of your transformer-based implementation of your applications monad
07:27:55 <Sindriava> EvanR: I think there might be some underlying misunderstanding about how transformers or even monads work
07:28:10 <EvanR> yes there is
07:28:13 <saurabhnanda> EvanR: what do you mean by "client code"?
07:28:31 <EvanR> but im trying to address saurabhnanda's interpretation of how transformers are making your program rely on internal implementation details of things
07:28:54 <saurabhnanda> EvanR: btw, when I was talking about "library" earlier I was referring to the Persistent library. And how as a user of the library I have to be acutely aware of the exact monad stack that the author has decided to use.
07:28:55 <EvanR> saurabhnanda: indeed lets get more precise about this since its important to modularity
07:28:59 <Deved> hello an easy question: why 'a' :: Char but 4 :: Num a => a? why not 4 :: Int or 4 :: Num?
07:29:15 <Sindriava> EvanR: Yeah, I was thinking that not understanding how transformers work may severely hinder any undestanding of how to isolate them
07:29:32 <Sindriava> Deved: Simple! Let me explain:
07:29:39 <EvanR> saurabhnanda: each part of your program will use support from some other part, the part using support is the client code, or user code
07:29:55 <EvanR> saurabhnanda: its nice if these parts are separated, and not all mixed up
07:30:12 <Sindriava> Deved: When you say 'a', Haskell doesn't know how to interpret it other than a Char, so it says that 'a' :: Char
07:30:21 <saurabhnanda> EvanR: here you're talking of the program I'm writing, not generic libraries
07:30:42 <Sindriava> Deved: However, 4 could be a whole plethora of things! 4 could be an Int, or a Float, or even a Vector :)
07:30:45 <EvanR> saurabhnanda: in your 1 pasted example, the client code is `insert $ Person "Michael" "Snoyman" 26'
07:31:09 <EvanR> this is your code after you have opened up looks like 5 different transformers
07:31:12 <miltondts> hello, how can I check in ghci if some variable(e.g. in a function) is boxed?
07:31:16 <Sindriava> Deved: So until you tell Haskell more information about the 4, it has no idea of knowing what 4 is, other than a literal for "Num"
07:31:29 <Deved> Sindriava: so is that means int - float - vector have typeclass of Num?
07:32:18 <Sindriava> Deved: Exactly. Anything that acts like a number should be a Num – that's why addition, subtraction (and so on) are defined on Num, instead of on Int, Float, etc.
07:32:20 <EvanR> saurabhnanda: so you would like your code to depend on your applications "giant application monad" such as `MyApp a' and not a page of persistent type signatures
07:32:24 <Sindriava> :t (+)
07:32:25 <lambdabot> Num a => a -> a -> a
07:32:59 <Sindriava> Deved: The above type signature tells you, that (+) can work on ANYTHING that's a Num, but that it can only add two things of the same type, that are Num
07:33:16 <EvanR> saurabhnanda: and when you start your program you would like to enter this MyApp monad by putting 2 or 3 arguments that it needs to go, and beginning a do block where the first thing you do could be `insert person'
07:33:19 <Deved> Sindriava: thank you very much
07:33:30 <Sindriava> Deved: You can't add Ints and Floats, because that would mean that Int = a = Float int he above type signature
07:33:42 <EvanR> saurabhnanda: this part of the code doesnt need to know that you implemented MyApp and runMyApp using 11 crazy transformers
07:34:03 <Sindriava> Deved: No problem! Feel free to ask anything at any time, no questions are too simple or stupid – only those not asked :)
07:34:07 <EvanR> it only needs to know the requirements (database path)
07:34:10 <saurabhnanda> EvanR: right, basic DRY
07:34:21 <EvanR> i dont think DRY is relevant here
07:34:33 <saurabhnanda> EvanR: which is what I was trying to do via my 'rubDb pool operation' function
07:35:00 <EvanR> if the pool were the only thing you needed youd just pass it around or use runReaderT but it looks like you have way more going on
07:35:18 <EvanR> so you really want to make a MyApp monad with all 1000 features and enter that as soon as possible and stay there
07:35:30 <EvanR> with runMyApp
07:35:33 <saurabhnanda> EvanR: **I** don't have way more going on.... Persistent seems to be OD-ing on Monads
07:35:45 <EvanR> and your code will want to use persistent commands right?
07:35:53 <saurabhnanda> EvanR: yup
07:36:04 <saurabhnanda> EvanR: okay, I got this part
07:36:09 <EvanR> then MyApp's implementation must incorporate persistent
07:36:26 <EvanR> you just need to hide MyApp's implementation somewhere
07:36:51 <saurabhnanda> EvanR: BUT, looking at snippet 1, the unWrapping seems to be split across the withSqlitePool function boundary. Why is that?
07:37:12 <saurabhnanda> EvanR: and if that indeed is required, then the implementation details are going to leak
07:37:30 <EvanR> well, if persistent is 1 monad or 1 transformer, and its 11 different transformers, then thats what you need to do
07:37:38 <saurabhnanda> EvanR: I can't have a giant runMyApp function sitting inside 'main' and call it a day
07:37:43 <EvanR> why do you think implementation details are going to leak
07:37:50 <EvanR> why cant you write runMyApp
07:37:55 <Sornaensis> how do I maximize my monads
07:38:04 <Sornaensis> this is the most important question one can ask imo
07:38:18 <saurabhnanda> EvanR: hang on, let me show you the real code...
07:38:31 <EvanR> maximize :: [Monad a] -> Monad a
07:39:33 <EvanR> for the record, this sort of transformer hellish library design draws a lot of ridicule about haskell in general, and it sucks because theres so much simpler things in haskell
07:39:53 <EvanR> that many people wont ever know about because "monads"
07:40:12 <Sornaensis> transformer hellish lib?
07:40:28 <saurabhnanda> EvanR: https://github.com/vacationlabs/nightwatch/blob/haskell/Main.hs and https://github.com/vacationlabs/nightwatch/blob/haskell/Nightwatch/Websocket.hs#L210-L220 and https://github.com/vacationlabs/nightwatch/blob/haskell/Nightwatch/Telegram.hs#L219
07:40:35 <EvanR> saurabhnanda's previous 10 pastes
07:40:46 <EvanR> what exactly do you want me to look at
07:41:11 <Sindriava> This use of transformers relates to making cleaner code abou as much as stabbing carrots into your eyes improves eyesight
07:41:11 <saurabhnanda> EvanR: trying to say why I can't write a giant runMyApp unwrapper
07:41:47 <Deved> is there a command which tells typeclass of something?
07:42:02 <EvanR> (unwrapper is a bad way to think about this, youre really running a monadic action in another monad)
07:42:16 <Sindriava> Deved: What do you mean by "telling typeclass" ?
07:42:22 <EvanR> or in the case of non-transformers, in no other monad
07:42:26 <EvanR> saurabhnanda: so whats the issue
07:43:15 <EvanR> saurabhnanda: i see a main that starts with a hole, and two files with nothing to do with anything
07:44:04 <Deved> Sindriava: for example in Eq typeclass there is Int etc. , if I want to learn all typeclasses Int belongs to ...
07:44:11 <saurabhnanda> EvanR: there's a forkIO at https://github.com/vacationlabs/nightwatch/blob/haskell/Nightwatch/Telegram.hs#L219 which seems to be causing the problem, I think
07:44:17 <EvanR> runMyApp :: DbFilePath -> Integer -> (Pool -> MyInsaneApp ()) -> IO ()
07:44:34 <Sindriava> Deved: I see! You can use :info or :i in Ghci :)
07:44:36 <saurabhnanda> EvanR: this is WIP code, btw, I was trying a lot of things to make connection pooling work
07:44:49 <Deved> Sindriava: thank you again :)
07:44:57 <Sindriava> No prob!
07:45:09 <saurabhnanda> and what's the type of MyInsaneApp () ?
07:45:13 <EvanR> that is the type
07:45:29 <EvanR> what is the implementation?
07:45:29 <saurabhnanda> as in internally it's a wrapper over a bunch of things, right?
07:45:41 <EvanR> it might be or it might be a custom monad
07:45:58 <saurabhnanda> no, god, no. No more monads.
07:46:18 <EvanR> usually people use a bunch of transformers, that is, MyApp uses the transformer types, and runMyApp use the run functions of all those types in that order
07:46:32 <sm> :)
07:46:41 <Sindriava> saurabhnanda: I strongly suggest a healthy dose of humility when learning Haskell – Or indeed when learning anything new.
07:48:16 <EvanR> i agree, you could actually completely ignore the existence of monads if you use only IO
07:48:30 <EvanR> the fact that IO is a monad is inconsequential
07:48:53 <saurabhnanda> Sindriava: why, what happened? I'm not giving knee-jerk reaction, btw, if that's what you feel. Please take a look at https://github.com/vacationlabs/nightwatch/commits/haskell?page=2 -- I've been trying to hack at this project for 2 months now. And Monad Transformers has the only thing that is frustrating me so much.
07:48:56 <EvanR> that was when i suggested passing the pool around
07:49:49 <Sindriava> saurabhnanda: It's a general recommendation, not particularly related to anything you said.
07:53:52 <saurabhnanda> EvanR: okay, to answer your question, the unwrapping in the example (snippet 1) seems to be split at the 'withSqlitePool' & 'runSqlPool' function boundaries. Now, because I didn't want every single function to return SqlPersistM() actions, I need to call 'runSqlPool' at all the call sites. But that's a problem, because it seems like it needs to be partially unwrapped using runResourceT
07:54:32 <EvanR> saurabhnanda: so in another file, you can do type MyApp a = T1 X (T2 Y (T3 Z (T4 IO a))), or however many transformers it takes. then runMyApp x y z (MyApp t1action) = runT4 . runT3 z . runT2 y . runT1 x $ action, adjusted for actually getting each T right and the proper arguments you need passed in. not that T4 IO.. means you can do IO in the action
07:54:32 <phaskell-1> T4: Get a NixOS image on Rackspace - https://phabricator.haskell.org/T4
07:54:32 <phaskell-1> T3: Move wiki mysql to mysql01 - https://phabricator.haskell.org/T3
07:54:32 <phaskell-1> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
07:54:32 <phaskell-1> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
07:54:35 <saurabhnanda> EvanR: which is why I feel, a big giant runMyApp isn't going to ork.
07:55:05 <EvanR> "every single action" can return MyApp
07:55:08 <saurabhnanda> did you mean "NOTE that T4 IO.. means you can do IO in the action"
07:55:17 <EvanR> yes note
07:56:00 <EvanR> why do you want to call runSqlPool at all call sites
07:56:05 <saurabhnanda> every single action returning MyApp would result in a whole lot of liftIO's? Or not?
07:56:15 <EvanR> no... its MyApp
07:56:32 <EvanR> do you mean when you call an IO action which isnt MonadIO ?
07:56:59 <saurabhnanda> otherwise the type of the call site becomes SqlPersistM() and the whole function needs to move from the IO() monad to the SqlPersistM() monad, which means carefully placing liftIo's all over the place.
07:57:07 <EvanR> if you ever have to do that, then yes youll need to convert it with liftIO, but all your persistent stuff is MonadIO
07:57:20 <EvanR> saurabhnanda: ... the "whole function" is "MyApp"
07:57:27 <EvanR> not IO not SqlPersistM
07:58:24 <saurabhnanda> EvanR: take a look at https://github.com/vacationlabs/nightwatch/blob/haskell/Nightwatch/Telegram.hs#L168-L177 to get what I mean
07:58:26 <dougia> @pl "shoulder " ++ show  (leftShoulder 1 2 1.25)
07:58:27 <lambdabot> "shoulder " ++ show (leftShoulder 1 2 1 . 25)
07:58:39 <EvanR> for any action that you use a lot that is IO and not MonadIO, you can move that into yet another MyApp utility action that does liftIO on it
07:59:09 <saurabhnanda> line #172 is where SqlPersistM() appears and see what it's doing to the code around it
07:59:25 <EvanR> saurabhnanda: are you referring to the putStrLns ?
07:59:36 <saurabhnanda> in this function, processIncomingMessages, I've not used runDb or runSqlPool at the call site. 
07:59:53 <saurabhnanda> yes, and the 'case'
08:00:07 <saurabhnanda> and the readChan
08:00:26 <EvanR> well your code is using IO guts directly a lot
08:00:36 <EvanR> if you were using MyApp then all this would be hidden
08:00:37 <dougia> @pl replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))
08:00:37 <lambdabot> replicate 100 (product (map (3 *) (zipWith max [1, 2, 3, 4, 5] [4, 5, 6, 7, 8])))
08:00:59 <EvanR> youd have a logger or printer utility action that does liftIO
08:01:31 <EvanR> because all this stuff is not that bad in IO directly, is why i was suggesting using no transformers
08:01:49 <EvanR> but you can lift all this into MyApp in various ways
08:03:26 <saurabhnanda> EvanR: but I can't not use transformers because of persistent, right? Is there a way to do that?
08:03:41 <EvanR> in this particular function, why do you have to use transformers
08:03:48 <EvanR> it looks like a thread worker?
08:04:07 <saurabhnanda> EvanR: actually, it seems that I have to use un-transformers
08:04:18 <saurabhnanda> EvanR: because it's doing a DB call
08:04:18 <EvanR> huh
08:04:28 <EvanR> so you have to use an IO action
08:04:59 <saurabhnanda> hang on, let me share the compiler error
08:05:14 <EvanR> this seems like an unproductive way to get help...
08:05:34 <EvanR> you have a huge codebase that is half refactored
08:06:06 <saurabhnanda> EvanR: yes, that's true. I was in the middle of refactoring and got stuck. Which took me down this path.
08:06:58 <saurabhnanda> EvanR: okay, let it be... let me try again tomorrow with a fresh mind. and let me think about the MyApp approach.
08:07:15 <EvanR> also think about the IO approach
08:07:35 <saurabhnanda> EvanR:  thanks for taking out the time to help me. ( Sindriava )
08:11:12 * hackagebot machines-io 0.2.0.10 - IO utilities for the machines library  https://hackage.haskell.org/package/machines-io-0.2.0.10 (aloiscochard)
08:16:12 * hackagebot propellor 2.17.1 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.17.1 (JoeyHess)
08:18:32 <bitemyapp> frase: I fork everything. You'll start getting Issue/PR spam if I start using it.
08:19:13 <sm> joeyh_: http://joeyh.name/blog/entry/type_safe_multi-OS_Propellor pretty cool, congrats
08:23:52 <maerwald> pretty boring that it only supports debian on linux though
08:31:15 <joeyh> maerwald: (and ubuntu) but, the idea is to make it easy to incrementally port to other linuxes
08:32:55 <maerwald> is that modular?
08:33:07 <maerwald> or do you have to go over the whole codebase
08:33:10 <sm> I like that it got some funding (and shuttleworth funding)
08:34:20 <joeyh> it's modular, you can port only the properties you use
08:34:48 <joeyh> the funding was incidental; I was funded to do anything (so it was likely going to be some haskell thing ;)
08:37:55 <sm> ah
08:38:15 <sm> well +1, one of these days I hope to use it
08:39:00 <tommd> Ditto, thanks for continual opensource contributions joeyh.
08:40:04 <maerwald> how do you test that the properties are correctly deployed?
08:40:46 <joeyh> if it can't be caught at the type level, runtime errors get printed in red..
08:40:59 <maerwald> what does that mean?
08:41:21 <maerwald> do you have a CI system that actually tries to run the stuff?
08:42:17 <maerwald> e.g. ssh configuration may be invalid, you won't know until you run it
08:42:17 <joeyh> oh, you mean test the properties themselves? I run most of them pretty frequently, but propellor is very much a try it and fix it if it breaks for you kind of thing
08:46:34 <joeyh> but, you could have propellor generate the configuration from a (G)ADT that avoids many broken configurations
08:46:49 <joeyh> probably can't avoid telling it key pairs that don't match, etc ;)
08:49:47 <sm> joeyh: at http://propellor.branchable.com/security, propellor --add-key should be propellor-config --add-yey right ?
08:50:33 <sm> hmm i'm confused
08:50:49 <joeyh> sm: there's typically a propellor in path, that will pass it off to the propellor-config program
08:51:53 <sm> stack install propellor installed propellor and propellor-config exes, and only the latter seems to understand --flags (but it calls itself propellor in the built-in help)
08:53:49 <joeyh> does it give an error? (maybe take this to /msg)
08:56:05 <joeyh> I guess you could be seeing it setting up ~/.propellor and building the propellor-config it's gonna eventually run in order to process your --add-key
08:57:56 <Pennyw95> Hi, I'd like to ask for some advice: I've gone through most of the theory of haskell and I'd like to practice with something to really get stuff going (like a GUI calculator, or maybe a game like snake or flappy bird) but the thing is, I have no idea how to translate concept like the main loop and rendering. I assume it's a matter of using the state monad and an external library, like Gloss (which hooks to openGL)?
08:58:20 <Pennyw95> The question is, is there something like a common path you can point me to?
08:58:51 <Jinxit> there's #haskell-game i think
08:59:03 <Jinxit> they might be more passionate about the subject
08:59:04 <maerwald> game programming is rather rare in haskell, I'd start with a GUI calculator
08:59:40 <nak> John Carmack wrote Wolfenstein 3D to cut his teeth in haskell and finished it in 2 hours
08:59:46 <Pennyw95> hmm okay, calculator then..so the make GUIs i need an external library, correct? too used to javax xD
08:59:50 <maerwald> RPN calculator should be easy enough
08:59:56 <Jinxit> nak: he didn't do all of wolfenstein
09:00:02 <Jinxit> just enough to see the concepts working
09:00:15 <maerwald> and linus torvalds wrote the initial version of git in 1-2 weeks
09:00:20 <nak> Jinxit have you found the source ?
09:00:22 <maerwald> not sure that's a useful statement though
09:00:32 <Jinxit> nah I don't think he released it
09:00:36 <Jinxit> but that's what he said
09:00:39 <bennofs> With the vector library, is there a way to unsafeFreeze a vector temporarily, and later unsafeThaw it again and *access it through the same mutable vector as before*?
09:00:44 <nak> Jinxit i heard him talk about it in a quakecon talk
09:00:50 <Jinxit> he got to shooting then he got bored
09:00:56 <nak> ah ok
09:00:57 <maerwald> all I heard was talk about it, never code/demo
09:00:57 <Jinxit> iirc
09:01:13 <Pennyw95> so, gloss? is that what you use for graphics?
09:01:15 <bennofs> i.e. is the following safe? f vector = unsafeFreeze vector >>= unsafeThaw >> ... now work with vector again ..
09:01:17 <nak> Carmack is still the best of the best ^_^
09:01:30 <sm> joeyh: ok, msg coming
09:01:40 <maerwald> Pennyw95: what graphics?
09:02:14 <Pennyw95> any graphics..like a common GUI
09:02:17 <maerwald> no
09:02:22 <lambda-11235> Pennyw95: I'd recommend reactive banana for a use with a GUI library like Gtk or wxWidgets.
09:02:53 <maerwald> I don't think recommending FPR libraries is a good idea for a beginner
09:03:02 <maerwald> *FRP
09:03:15 <maerwald> just use the raw GTK or QT bindings
09:03:30 <sm> Pennyw95: have you built much in haskell yet ?
09:03:42 <maerwald> and then you can read the original C/C++ tutorials and things will still kinda match
09:04:05 <Pennyw95> not much...just solving math problems, the one they give for every language
09:04:06 <EvanR> recommending toolkits to anybody at any time is probably a bad idea, but we do it anyway
09:04:22 <Pennyw95> i know java already
09:04:30 <nak> >.<
09:04:37 <Pennyw95> lol
09:04:40 <maerwald> Pennyw95: just do the cli part of the calculator then
09:04:47 <maerwald> adding GUI on top of it should be modular anyway
09:05:17 <nak> yeah start small but a calculator sounds so boring
09:05:24 <nak> maybe do wolfenstein 3d
09:05:27 <nak> hahaha jk
09:05:28 <Pennyw95> I already did that, I want to learn GUIs
09:05:30 <EvanR> ust make an MMO
09:05:36 <nak> haha EvanR 
09:05:59 <maerwald> Pennyw95: then you gotta learn a toolkit
09:06:00 <EvanR> Pennyw95: so GTK is probably your best bet really
09:06:03 <EvanR> sorry to say
09:06:30 <EvanR> you can also check this out https://hackage.haskell.org/package/threepenny-gui
09:06:35 <nak> Pennyw95 are your familiar with Cookie Clicker ?
09:06:51 <Pennyw95> nope
09:06:56 <nak> http://orteil.dashnet.org/cookieclicker/
09:07:02 <nak> it's a simple little, addictive game
09:07:12 <nak> well cookie clicker is deceptively "simple"
09:07:15 <EvanR> talk about things that are bad to recommend
09:07:28 <nak> EvanR yeah cookie clicker is crack cocaine
09:07:37 <nak> but it might be fun to make a clickeresque game!
09:07:40 <EvanR> now Pennyw95 will stop learning haskell and begin clicking on a damn cookie for the next 9 weeks
09:07:41 <Pennyw95> yeah I think making a simple game would be nice practice
09:07:41 <tzaeru> ugh, I've used probably +20 hours of my work time to that game
09:07:42 <nak> more fun than a calculator 
09:07:50 <nak> haha
09:07:53 <Pennyw95> ahah
09:08:00 <nak> EvanR i'm at 24.09 quintillion cookies per sec :(
09:08:06 <EvanR> thats all?
09:08:09 <nak> yeah :(
09:08:20 <nak> only been playing like 7 weeks i think
09:08:22 * EvanR refrains from talking about "strategy" of this awful game
09:08:33 <Jinxit> I think card games are the best ways to learn how to structure something complex in a programming language
09:08:34 <nak> there's totally strategy !
09:08:38 <Pennyw95> would advice GTK for replicating a game like that as well?
09:08:44 <Pennyw95> would you*
09:08:48 <EvanR> it only took me a few days to get to multisyllabic numbers i couldnt pronounce
09:09:01 <EvanR> but you have to be patient sometimes
09:09:01 <tzaeru> Jinxit, I think coding experience is the best way to learn that :P
09:09:08 <nak> EvanR when did you play tho? the 2.0 is scaled for a much longer game
09:09:15 <EvanR> oh god, nevermind
09:09:15 <nak> and has prestige/ascension mechanics
09:09:22 <EvanR> yes i ascended once
09:09:23 <Jinxit> tzaeru: depends on what you're coding
09:09:24 <nak> where you restart your progress while keeping achievements
09:09:24 <nak> lol
09:09:33 <EvanR> yes mutagen
09:09:41 <nak> ok we can bin the cookie clicker talks :)
09:09:47 <Jinxit> doing LYAH will learn you nothing of architecture
09:09:47 <maerwald> I'd code things that feel more natural in haskell for starters. Not stuff that has only been done by a few pioneers.
09:09:57 <maerwald> so... not really games
09:10:08 <EvanR> games. the final frontier
09:10:09 <nak> are we still recommending LYAH ?
09:10:21 <Deved> Hi, here i m confused:        sum' :: (Num a) => [a] -> a       sum' [] = 0       sum' (x:xs) = x + sum' xs  , I don't understand how [a] doesnt mean a list with just an element which has a type in Num
09:10:29 <EvanR> these are the voyages of the starship haskellprise
09:10:50 <Pennyw95> [a] means a list that contains n elements of type a
09:10:57 <EvanR> strange new game loops, and new FRP libraries
09:11:14 <Pennyw95> the function takes a list of a, which is instance of Num, and returns only one a value
09:11:32 <Pennyw95> Deved
09:11:34 <EvanR> Pennyw95: note that `n' isnt included in this type
09:11:42 <EvanR> you dont know how long the list is
09:11:45 <Pennyw95> sorry I meant, and arbitrary number
09:11:49 <Deved> Pennyw95: is this logical because a list can only contain one type of elements?
09:11:50 <EvanR> k
09:11:56 <nak> well [a] has at least 1 element in it, so not n = 0
09:12:03 <nak> [] is an empty list
09:12:03 <Jinxit> what
09:12:07 <EvanR> what
09:12:11 <nak> yes ?
09:12:12 <Jinxit> not on a type level
09:12:12 <EvanR> [a] has at least 0 elements in it
09:12:12 <Pennyw95> correct
09:12:20 <nak> oh ok i'm braindying
09:12:25 <nak> nevermind me lol
09:12:30 <EvanR> (a,[a]) has at least 1 element ;)
09:12:32 <Deved> did you say correct to me or?
09:12:34 <Pennyw95> Deved: lists contain elements of the same type
09:12:40 <maerwald> there are list types that can express "nonempty list" though
09:12:44 <maerwald> but that's another story
09:12:50 <Pennyw95> you can't have ["cia", 2]
09:13:01 <Deved> all right, thanks all
09:14:26 <Pennyw95> do you use a IDE to code? maybe I haven't searched hard enough, but I'm still using notepad++
09:14:41 <EvanR> i use ghci and vim
09:14:41 <Jinxit> only a text editor
09:14:51 <nak> sublime
09:15:05 <EvanR> reload your code in ghci when you want to test something out
09:15:14 <Pennyw95> sure
09:15:44 <EvanR> because you cant do that much in just ghci, like data type declarations are a sort of pain
09:16:05 <EvanR> (you actually can do a helluva lot in ghci)
09:16:52 <maerwald> Pennyw95: try http://leksah.org/ 
09:16:53 <Pennyw95> so, this GTK library...can I jus stick it in my environment folder and import its stuff?
09:17:07 <sm> short of investing the time to set up a good idea, I would totally recommend running ghcid in nearby window
09:17:11 <sm> ide
09:17:40 <EvanR> note that Pennyw95 is on windows
09:17:48 <maerwald> ouch
09:17:51 <EvanR> somebody give good advice for windows ;)
09:18:09 <Pennyw95> wait what was the bad advice? leksah?
09:18:26 <EvanR> give any advice for windows
09:19:07 <Sindriava> Don't use windows is the best advice I can give for windows :(
09:19:20 <sm> there seems to be a version of Atom for windows
09:20:36 <Sindriava> Just out of curiosity, have you considered moving this (and associated) channels to Slack? Or is there one already that I'm not aware of?
09:21:05 * EvanR forwards this question to freenode just incase they didnt think of that
09:21:46 <Jinxit> sure let's go full proprietary tech, what could go wrong?
09:21:47 <Pennyw95> how is LYAH bad?
09:22:00 <maerwald> it's overly verbose
09:22:07 <maerwald> can be fun to read though
09:22:10 <sm> Pennyw95: just know that configuring a good IDE setup (beyond ghcid), installing and learning a haskell GUI framework, and writing a real game are three "full-time jobs", better pick one at a time
09:22:12 <Copperis> verbose is good
09:22:18 <maerwald> depends
09:22:19 <EvanR> except its verbose about not haskell
09:22:19 <Copperis> for learning at least
09:22:34 <Jinxit> I used LYAH to get an intro to the language, so you know how to write functions and data types syntactically, but then you need exercises
09:22:36 <MarcelineVQ> I don't think it's bad but the stuff you read doesn't stick super-well because there's no exercises along with the reading.
09:22:39 <EvanR> and its haskell is explained in riddles
09:22:40 <maerwald> it doesn't have enough meat and not really exercises
09:22:53 <bergey> Sindriava: There's a haskell channel on http://fpchat.com/  It's low-traffic compared to here.  Iassume you've heard most of the arguments against Slack already. =)
09:23:23 <Copperis> rewrite all the examples from LYAH, don't use ctrl+c
09:23:25 <hpc> slack or stack?
09:23:31 <maerwald> haskell is so alien for the first time that you can read all of LYAH and still not be able to code a simple 5 LOC programm :P
09:23:37 <Sindriava> bergey: Yeah, I did, but I figured that it's a lot better than IRC in a lot of ways and it couldn't hurt to have it, and I'd be quite happy to take care of it :)
09:23:54 <Sindriava> maerwald++
09:24:23 <EvanR> i use slack for work, and i hope i never leave IRC for slack for my personal life
09:24:41 <EvanR> especially if "free"node like network goes to slack
09:25:12 <kaol> It'd be a fork of #haskell, not a migration.
09:25:17 <hpc> ultimately, slack is an irc network with a proprietary client
09:25:36 <hpc> and not the type of network i feel terribly comfortable talking in
09:25:54 <joeyh> imagine, it could steal away, maybe 500 users. This would still be nearly the most populated irc channel on freenode ;)
09:26:13 <Sindriava> hpc: Not even close, there's so many things about IRC that I hate that Slack solves, that I have a hard time equating those two
09:26:15 * hackagebot yesod-table 2.0.3 - HTML tables for Yesod  https://hackage.haskell.org/package/yesod-table-2.0.3 (andrewthad)
09:26:32 <Sindriava> I would like to see Slack open up a little, though :(
09:26:34 <EvanR> i though #haskell was very crowded but i think i was proven wrong
09:26:59 <hpc> this channel is decidedly uncrowded because people don't really crowd the chat
09:27:05 <Sindriava> EvanR: IMO Haskell is populated but not crowded
09:27:10 <hpc> try visiting a twitch stream chat sometime
09:27:15 <hpc> that's technically irc
09:28:06 <EvanR> im glad slack happened, so every other intern that got hired would shut up about the next greatest IRC replacement startup
09:28:12 <hpc> this is actuallyin the low part of the day for channel population
09:28:41 <hpc> EvanR: man, i would have loved to hear their insane theories on monetization
09:29:04 <Sindriava> haha
09:29:16 <hpc> also nowadays the new intern thing is the next greatest bitcoin replacement startup
09:30:20 <hpc> someone pointed out to me the other day that the wikibook for haskell has improved quite a bit
09:30:26 <hpc> since i last checked a few years ago
09:30:35 <EvanR> yes it seems quite nice 
09:30:42 <hpc> i can confirm it has improved, but the CPS page is still pants
09:30:53 <hpc> but pants with better markup now at least
09:30:54 <Sindriava> That reminds me, are we ever going to have working syntax highlighting on the Wiki?
09:31:15 * hackagebot avers 0.0.15 - empty  https://hackage.haskell.org/package/avers-0.0.15 (wereHamster)
09:31:17 * hackagebot avers-api 0.0.3 - Types describing the core and extended Avers APIs  https://hackage.haskell.org/package/avers-api-0.0.3 (wereHamster)
09:31:35 <tzaeru> EvanR, you mean to say that slack made all the other irc-replacement projects pointless?
09:31:45 <EvanR> tzaeru: it sort of won
09:32:10 <hpc> interns don't like big ideas that already have competition
09:32:14 <tzaeru> I guess. ..we too actually use it at work, but I haven't really followed that communication software scene at all :)
09:32:57 <fkurkowski> don't you guys use the irc gateway with slack?
09:33:01 <hpc> right now my ideal communication software (for programmers at least) is an irc network on a server everyone can ssh into
09:33:06 <hpc> that only listens on localhost
09:33:14 <EvanR> we used IRC until slack
09:33:24 <fkurkowski> i use slack through an irc client
09:33:30 <tzaeru> we switched to Slack (mostly) from Skype.
09:33:32 <fkurkowski> so i can be here and on the company slack server
09:33:38 <scshunt> fkurkowski: that's possible?
09:33:43 <fkurkowski> yep
09:33:45 <tzaeru> though still use Skype for some VOIP and video comm
09:33:50 <Sindriava> hpc: I'd take IRC as it is now, that doesn't require me to be online all the time
09:33:50 <fkurkowski> i personally use weechat with wee-slack
09:34:22 <tzaeru> Sindriava, so you'd take a remote shell service? :-p
09:35:24 <Sindriava> tzaeru: Sure, and I'll put bean bags in my car instead of seats – hey, it works, right?
09:35:31 <tzaeru> holy shit slack's been valued to 2.76 billion dollars last march
09:35:37 <Sindriava> wait what
09:36:02 <tzaeru> I can't imagine how it would generate more than a few mills a year from its users
09:36:07 <hpc> microsoft should trade minecraft for slack
09:36:15 * hackagebot avers-api 0.0.4 - Types describing the core and extended Avers APIs  https://hackage.haskell.org/package/avers-api-0.0.4 (wereHamster)
09:36:17 * hackagebot avers-server 0.0.3 - Server implementation of the Avers API  https://hackage.haskell.org/package/avers-server-0.0.3 (wereHamster)
09:36:27 <EvanR> corporate contracts + expected future profits
09:36:41 <tzaeru> yeah
09:36:43 <EvanR> + whatever people in silicon valley are taking
09:36:58 <EvanR> to feel so good
09:36:59 <hpc> plus ecosystem
09:37:15 <tzaeru> those value estimations are really pretty ridiculous in that they give ordinary people and even ordinary investors really unrealistic expectations..
09:37:18 <hpc> you can put whatever crap you want into a communications platform that you own 100%
09:37:53 <shapr> Is there a tutorial for writing binary file format parsers?
09:38:17 <ARM9> something something attoparsec
09:38:23 <EvanR> attoparsec docs
09:39:31 <hpc> scary thought: microsoft buys slack and builds it into exchange
09:40:10 <tzaeru> 2 billions is worth like.. 2000 programmers working for 10 years? :-p
09:40:35 <EvanR> they went through a lot of mythical man-months
09:40:41 <tzaeru> assuming your company uses 100,000k a year per programmer
09:44:00 <Pennyw95> back
09:48:53 <Pennyw95> does leksah add libraries by itself?
09:49:19 <maerwald> what does that mean?
09:50:44 <Pennyw95> i phrased that wrong
09:51:23 <Pennyw95> first time I open it, it asks where it should unpack cabal packages...is that what I'd manually do to add a library like GTK?
09:53:29 <MichaelK> Hi, why isn't "class C (b -> c)" equivalent to "class (a ~ (b -> c)) => C a"? It seems to me that they should be effectively equivalent, but the first throws an "Unexpected type" error.
09:54:36 <MichaelK> (nevermind, it'd be more like "Class C a where dummy :: (a ~ (b -> c)) => Proxy")
09:56:32 <EvanR> class constraints => C a b c d where
09:57:40 <EvanR> MichaelK: do you really want to put the -> constraint in the class ?
09:58:58 <xa0> i kinda want a (.) at the type level
09:59:16 <xa0> clean up my transformer stack
09:59:20 <EvanR> https://hackage.haskell.org/package/TypeCompose-0.9.11/docs/Control-Compose.html ?
09:59:43 <xa0> >_>
09:59:45 <EvanR> type O = (:.)
09:59:48 <xa0> EvanR: TIL
10:00:08 <EvanR> i wish i could remember what TIL means
10:00:16 <Elision> today i learned
10:00:16 <MichaelK> EvanR: well if the class is a class of functions then yes (maybe?)
10:00:43 <joeyh> that's implemented lazily
10:00:45 <EvanR> MichaelK: typeclasses are classes of types, rather than 1 specific type
10:01:02 <cocreature> MichaelK: and a newtype around a function can’t work?
10:01:32 <MichaelK> cocreature: it can work, I'm just wondering why it's not in the syntax.
10:02:10 <EvanR> you typically want constraints on implementations rather than typeclasses or datatype definitions
10:02:10 <Pennyw95> what is this? <>
10:02:15 <EvanR> :t (<>)
10:02:16 <lambdabot> Monoid m => m -> m -> m
10:02:16 <MichaelK> EvanR: well what about Eq/Show, which are for non-functional types?
10:02:31 <EvanR> what about em
10:03:14 <Pennyw95> in the function hello s = "Hello " <> s, is it like ++?
10:03:20 <EvanR> yes
10:03:33 <Pennyw95> is it an abstract monoid version of adding?
10:03:39 <EvanR> but "Hello " might not be a String if there are OverloadedStrings going on
10:03:46 <EvanR> so <> works with Text and ByteString too
10:03:52 <Pennyw95> oh, I see
10:03:56 <Pennyw95> thanks
10:03:58 <johnw> Pennyw95: "adding" is one concept that fits within Monoid, but not the only one
10:04:01 <EvanR> <> is the monoid fusing operation
10:04:11 <EvanR> operator synonym for mappend
10:04:20 <Pennyw95> ahhh
10:04:32 <Pennyw95> ok, I didn't know mappend had an operator
10:04:41 <EvanR> it didnt used to, that one won
10:05:14 <orion> <> is the semigroup operation
10:05:29 <EvanR> well. if you include Semigroup instead of Monoid
10:05:41 <jle`> it's not the semigroup operation in current ghc base :'(
10:05:50 <maerwald> not that useful though, is it? most of the time it's just an alias for something that already exists
10:05:53 <cocreature> did the semigroup monoid stuff make it into 8.0?
10:06:05 <Jinxit> maerwald: working with any monoid?
10:06:19 <volhovm> what does this notation mean? : `class MyClass s m | m -> s where`
10:06:23 <jle`> maerwald: do you maen <> vs. mappend?
10:06:26 <volhovm> I mean `m -> s`?
10:06:26 <EvanR> maerwald: <> is very useful
10:06:31 <tommd> Functional dependencies.
10:06:40 <jle`> <> is just an alias, but it's sometimes more convenient to have an operator
10:06:49 <jle`> like how we use (.) instead of `compose` or something
10:06:52 <tommd> Informally, "the type of 'm' dictates the type of 's'".
10:06:58 <orion> Why can't semigroup be in base?
10:07:06 <volhovm> tommd: That's something like type families?
10:07:13 <EvanR> putting `union` or `smush` everywhere would be annoying in a monoid based lib
10:07:13 <volhovm> tommd: Found related article, thanks!
10:07:23 <tommd> volhovm: They solve similar problems.  Functional dependencies were first actually.
10:07:34 <Jinxit> orion: out of curiosity, what would it be useful for?
10:07:45 <tommd> WRT GHC and Haskell/publications at any rate.
10:07:53 <cocreature> orion: I think it is in 8.0
10:08:03 <jle`> Jinxit: the same reason why we have a Functor and Applicative typeclass
10:08:04 <orion> cocreature: Awesome. :)
10:08:08 <cocreature> https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
10:08:14 <jle`> Jinxit: there are some useful things that are semigroups, but aren't monoids
10:08:21 <jle`> like how some useful things are Functors but not Monads
10:08:25 <orion> I always like to use the most general structure possible.
10:08:26 <Jinxit> ah okay
10:08:29 <EvanR> heh yeah but
10:08:29 <maerwald> EvanR: I mean, a lot of stuff has Monoid instances you rarely use anyway
10:08:42 <jle`> Jinxit: or, some useful things are Num, but not Fractional
10:08:48 <EvanR> maerwald: who me?
10:08:54 <maerwald> and it's usually very trivial to write them since you just do aliases to existing functionality
10:09:09 <EvanR> yes monoids crop up a helluva lot
10:09:13 <jle`> maerwald: the point is to use them with Monoid-polymorphic code
10:09:15 <EvanR> not sure why that makes it not that useful
10:09:25 <maerwald> jle`: and I don't see that very often
10:09:28 <cocreature> there is a great functional pearl showing the use of monoids in diagrams
10:09:29 <jle`> maerwald: there is a lot of code written in libraries that's polymorphic over all Monoids
10:09:39 <EvanR> the Writer monad is monoid polymorphic
10:09:54 <jle`> maerwald: Writer, 'fold' in base
10:09:57 <EvanR> lots of libraries make use of monoids for different things
10:10:01 <Jinxit> lens has some monoid stuff iirc
10:10:03 <jle`> the Const applicative
10:10:08 <cocreature> foldMap
10:10:26 <EvanR> also monoidal categories ++
10:10:31 <jle`> Const applicative shows up a lot when working with traversals
10:11:44 <jle`> maerwald: also, if you ever decide to write your code in monoid-polymorphic manner, you gain a lot of type safety and correctness proofs
10:11:51 <jle`> and of course, reusability
10:12:21 <MichaelK> would it be possible to define something like "undefinedEq :: Eq a => a" which would return an error if you did anything other than check for equality with it? 
10:12:27 <maerwald> I've only done that once for my own Diagram type, otherwise I've never had use for it
10:12:49 <EvanR> event streams in frp are usually monoids with merging
10:13:05 <EvanR> sorted streams are monoids with merging
10:13:25 <EvanR> graphics tends to have monoids for pictures or for masking
10:13:59 <EvanR> futures are monoids
10:14:04 <EvanR> the sooner one wins
10:14:32 <EvanR> i guess, the "more defined" one wins
10:14:39 <laserpants> What is the identity for futures?
10:14:52 <EvanR> the Text type seems to not have a name of its own for <>
10:15:09 <EvanR> laserpants: hang
10:15:13 <cocreature> I thought Text has append
10:15:17 <EvanR> ah
10:16:38 <laserpants> oh.. i was thinking about promises .hehehe
10:16:54 <EvanR> i think im getting them mixed up, what is the diff?
10:17:16 <EvanR> a yeah a future such as hang isnt promising anything
10:17:24 <EvanR> but neither do promises really
10:17:31 <laserpants> I don't know if I have ever used Futures actually
10:18:02 <EvanR> maybe that should be a law of promises, you can be sure youll eventually get something, even if its Timeout
10:18:47 <Blogle> Is there a library or tool for generating c bindings to Haskell code. I can only find basic examples that send int or strings across the barrier
10:18:52 <cocreature> according to wikipedia a future is a read-only placeholder and a promise is a writable single assignment container that sets the value of a future
10:19:11 <cocreature> and as we all know wikipedia is always right
10:19:11 <EvanR> ... *rewrites the wikipedia article*
10:19:39 <laserpants> does it mention monoids
10:21:04 <cocreature> Blogle: there is c2hs and c2hsc but both are not completely generating c bindings but they assist you (a lot) when writing them
10:22:56 <Sindriava> Ok, seriously, what are we using for syntax highlighting on the wiki?
10:23:11 <Blogle> Cocreature: do you know of a good tutorial off the top of your head or should I simply continue digging through Google?
10:23:17 <cocreature> Blogle: I’ve only used c2hs and been quite happy with it, but since c2hsc is written by johnw it’s probably awesome as well :)
10:23:58 <cocreature> Blogle: there is http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/ for c2hs
10:24:16 <cocreature> and the docs in the wiki are pretty readable
10:25:11 <Blogle> cocreature: thanks I will look over the link, much appreciated!
10:26:46 <cocreature> Blogle: also if you’re looking for a fairly simple example (shameless self-plug), I wrote bindings for nanovg the other day https://github.com/cocreature/nanovg-hs
10:29:00 <mpickering> am I misunderstanding what the 'newcode' option is for in lhs2tex? It doesn't seem that useful as it inserts the formatting into the code
10:31:17 * hackagebot yesod-bin 1.4.18 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.18 (MichaelSnoyman)
10:32:26 <hackrilege> hi, im checking out https://hackage.haskell.org/package/category-extras-0.53.4/docs/src/Control-Functor-Indexed.html#IxFunctor
10:32:33 <hackrilege> indexed functor
10:32:50 <hackrilege> im wondering why imap :: (a -> b) -> f j k a -> f j k b
10:33:02 <hackrilege> f a b c!?
10:33:13 <hackrilege> why is my indexed functor paramatrised by 3 types?
10:33:36 <hackrilege> i guess i should supply an index type, and a contents type, but i cant see why i would need 3...
10:33:40 <hackrilege> any ideas?
10:33:43 <Blogle_> cocreature: I will check out your repo, although that sounds like you went  the opposite direction
10:33:57 <cocreature> Blogle_: that repo is using c2hs
10:34:34 <Blogle_> To expose c to Haskell though right, not expose Haskell to c?
10:35:02 <cocreature> oh dang I misread your question all along
10:35:05 <cocreature> sry
10:35:17 <Blogle_> That's alright
10:38:27 <hackrilege> sorry i got disconnected, did anyone have any ideas what ekmett means by each of the 3 parameters of an indexed functor!? refering to https://hackage.haskell.org/package/category-extras-0.53.4/docs/src/Control-Functor-Indexed.html#IxFunctor
10:39:48 <Gurkenglas> hackrilege, the instances might help, available in the haddocks: https://hackage.haskell.org/package/category-extras-0.53.5/docs/Control-Functor-Indexed.html https://hackage.haskell.org/package/category-extras-0.53.5/docs/src/Control-Monad-Indexed-Cont.html#IxContT
10:40:01 <Gurkenglas> (You do realize you're working with an ooooold version yes?)
10:40:26 <hackrilege> oh no i didnt
10:41:25 <hackrilege> https://hackage.haskell.org/package/indexed-0.1/docs/Control-Monad-Indexed.html
10:41:30 <hackrilege> is that the correct version?
10:41:43 <Gurkenglas> That's what I just found, of course thats also from 2012 ^^
10:42:01 * hackagebot yesod-test 1.5.1.0 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.5.1.0 (MichaelSnoyman)
10:42:03 * hackagebot giphy-api 0.2.4.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.2.4.0 (passy)
10:42:51 <hnordt> isPicked sounds like a good name for a DatePicker option?
10:42:57 <hackrilege> hmmm im getting redirected when i try to view the source, thats how i ended up with the wrong versions source
10:43:10 <hackrilege> anyway im happy to rewrite the bits i need
10:43:19 <jle`> hackrilege: the type parameters of 'iap' might give you a hint
10:43:29 <hackrilege> i just wnted to know the rationality behind what seems to be a superfluous type parameter
10:43:42 <jle`> compare with the type parameters of (.) from Control.Category
10:43:48 <jle`> :t (C..)
10:43:49 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
10:43:50 <hackrilege> jle' yeah i put them above, but i cant quite see whats happening with i j and k in that example
10:44:01 <jle`> cat a b -> cat b c -> cat a c
10:44:21 <hackrilege> iap :: m i j (a -> b) -> m j k a -> m i k b
10:44:32 <Gurkenglas> indexed doesnt contain any instances for that class, lets look at indexed-extras, which https://hackage.haskell.org/package/category-extras-1.0.2 says is the only reverse dependency of indexed
10:44:42 <jle`> cat i j -> cat j k -> cat i k
10:44:53 <hackrilege> yeah
10:44:58 <jle`> m i j (a -> b) -> m j k a -> m i k b
10:45:02 <jle`> see the similarity?
10:45:22 <hackrilege> i get that kind of so in, f a b c, a and b represent (a->b) and c is the stored type?
10:45:33 <jle`> it might not be a stored type
10:45:42 <jle`> just the thing that 'fmap' acts on
10:45:52 <hackrilege> thats how i define the "contents"
10:45:56 <jle`> sure
10:46:49 <hackrilege> so for example a list would expect a nice instance of IxFunctor
10:47:01 * hackagebot yesod 1.4.2.1 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-1.4.2.1 (MichaelSnoyman)
10:47:03 <hackrilege> then [] is f in f a b c
10:47:09 <jle`> not really, it's the wrong kind
10:47:24 <jle`> [] :: * -> *, but f :: * -> * -> * -> *
10:47:27 <hackrilege> or [c] is f a b c
10:47:33 <hackrilege> so [] is f a b
10:47:39 <hackrilege> better?
10:48:13 <hackrilege> i guess its trying to handel the fact that i could opperate on the index type?
10:48:36 <jle`> it's trying to specify relationships between different f i j a's when you combine then using things like iap
10:48:51 <jle`> like how the two parameters in Category work
10:49:10 <jle`> (C..)'s parameters represent things you're allowed to "combine"
10:49:14 <hackrilege> so pure would turn a function on types into a function on functors of types
10:49:28 <jle`> and gives the resulting indexes of the new thing
10:49:32 <hackrilege> alowing alteration of both the stored type and the index type?
10:49:43 <jle`> (C..) is like a partial/non-total (<>) from Monoid
10:50:08 <hackrilege> i dont understand where you are getting this (C..) from
10:50:48 <hackrilege> what do the two parameters in category represent? are categories mappings between types?
10:51:30 <hackrilege> or is a mapping between types a category and actually a category is the more general two parameter datatype
10:51:39 <hackrilege> ?
10:52:34 <hackrilege> was i wrong about my suspicion that in f a b c, 'a' and 'b' were types of the index?
10:53:30 <hackrilege> are these questions badly phrased?
10:54:17 <Cale> hackrilege: The idea is that basically if you have an instance Category c, then (c a b) is the type of arrows from a to b in the particular category
10:55:37 <hackrilege> hmm so categories have contents of various types?
10:56:02 <hackrilege> otherwise i would have c a a
10:57:32 <Cale> You just know that for each pair of types u and v, there is some type c u v, and for each type u, there is an specified value  id :: c u u, and for each three types u, v, w, there is a specified function c v w -> c u v -> c u w
10:58:03 <Cale> How the type parameters actually get used is up to the instance in question
10:58:27 <hackrilege> so actually all the elements in the category have different type?
10:58:40 <Cale> Not all
10:58:47 <hackrilege> if id is the only thing mapping c a a
10:58:56 <Cale> it's not necessarily the only thing
10:59:03 <hackrilege> oh
10:59:05 <hackrilege> ok
10:59:07 <Cale> It's required to exist, so c a a can't be empty
10:59:12 <hackrilege> ok
10:59:19 <Cale> But c a a may have many other elements, for a given c
10:59:26 <Cale> Think about c = (->)
10:59:38 <Cale> There, you have c a b = a -> b
10:59:52 <Cale> So, while for any type a, you have id :: a -> a
11:00:00 <Cale> there are many other functions Integer -> Integer
11:00:10 <hackrilege> so a category could be for example [], the category of lists with various type parameters can be supplied
11:00:22 <Cale> [] doesn't have two type parameters
11:00:45 <Cale> However, there is a category instance related to lists...
11:01:03 <hackrilege> [a] -> [b]
11:01:08 <hackrilege> ?
11:01:21 <Cale> http://hackage.haskell.org/package/thrist-0.3.0.2/docs/Data-Thrist.html
11:01:25 <hackrilege> mappings between lists of various content type
11:01:58 <Cale> yeah, you can do that as well
11:02:02 * hackagebot th-expand-syns 0.4.0.0 - Expands type synonyms in Template Haskell ASTs  https://hackage.haskell.org/package/th-expand-syns-0.4.0.0 (DanielSchuessler)
11:02:20 <Cale> and generally, for any monad m, there's a Category (Kleisli m)
11:03:12 <hackrilege> so these ekmett indexed functors, f a b c have the contents and these other two type parameters, something to do with some other type that changes when mapping using iap
11:03:15 <Cale> newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
11:04:06 <hackrilege> i dont get how a functor has so many type paramenters
11:04:12 <Cale> Yeah, if you only look at the Functor instance, it won't make sense what's going on
11:04:13 <hackrilege> parameters*
11:04:20 <hackrilege> ah
11:04:20 <hackrilege> ok
11:04:26 <Cale> Or IxFunctor rather
11:04:32 <hackrilege> so if i removed one of them when would i get unstuck?
11:04:39 <Cale> It's IxApplicative and IxMonad where things get interesting
11:04:51 <Cale> look at the type of ijoin
11:04:56 <Cale> ijoin :: IxMonad m => m i j (m j k a) -> m i k a
11:05:02 <hackrilege> :t join
11:05:04 <lambdabot> Monad m => m (m a) -> m a
11:05:19 <hackrilege> ok that makes sense at first glance
11:05:38 <hackrilege> i see how it casts a monad of monads to a monad
11:05:44 <Cale> So, if you think of the types i and j as somehow representing, perhaps open resources for example
11:06:06 <hackrilege> no use a different terminology
11:06:13 <hackrilege> i dont know "open resources"
11:06:22 <Cale> I mean, like when you open a file
11:06:30 <hackrilege> handles
11:06:32 <Cale> Maybe we want to keep track of all the file handles you have open
11:06:41 <Cale> so that we can force you to remember to close them
11:06:56 <Cale> (this is awkward in Haskell, but if you were going to do it, you'd do it with something like this setup)
11:07:15 <hackrilege> !?
11:07:19 <hackrilege> i dont get this aside
11:07:37 <Cale> So, if you look at ijoin there, when we run the outer computation, we move from state i to state j with respect to what's open
11:07:55 <Cale> and then we run the inner computation, and it takes us from state j to state k
11:08:07 <Cale> and so the joined computation goes from state i to state k
11:08:11 <hackrilege> ijoin :: IxMonad m => m i j (m j k a) -> m i k a
11:08:22 <simony> hm, I tried running https://github.com/simonmar/parconc-examples/blob/master/strat.hs, but don't see a parallel speedup when I compiled with `ghc -O2 strat.hs -threaded -rtsopts -eventlog` and ran with `./strat +RTS -N2 -l -s`
11:08:44 <hackrilege> so what does type i represent?
11:08:51 <hackrilege> it does nt change
11:09:08 <simony> where the parallel and concurrent programming book says I should see them running in parallel here: http://chimera.labs.oreilly.com/books/1230000000929/ch03.html
11:09:18 <Cale> In this analogy, it's the initial state of what resources are open
11:09:37 <hackrilege> eg "readOnly"
11:09:41 <hackrilege> ?
11:10:19 <hackrilege> anyway, i seems to be redundant
11:10:23 <Cale> It's not
11:10:45 <Cale> You're expressing how the computation changes things from one state to another, at the type level
11:10:56 <red1ynx> цу э33ээ23ээ3333ххааажжаааххпээаэай
11:10:58 <Cale> So it's indexed by both the state it comes from, and the state it changes to
11:11:05 --- mode: ChanServ set +o Cale
11:11:55 <hackrilege> i have a functor it must have contents, i must apply a type parameter, its indexed, i must pupply an index type. this thisng has 3 parameters, apparently like the contents type and two other types indicating what "resources are open" something like the types of the elements of catagories beeing mapped between by arrows
11:12:02 * hackagebot giphy-api 0.2.5.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.2.5.0 (passy)
11:12:42 <hackrilege> :t iap
11:12:43 <lambdabot>     Not in scope: ‘iap’
11:12:43 <lambdabot>     Perhaps you meant one of these:
11:12:43 <lambdabot>       ‘map’ (imported from Data.List),
11:13:06 <hackrilege> iap :: m i j (a -> b) -> m j k a -> m i k b
11:13:18 --- mode: Cale set -o Cale
11:14:43 <hackrilege> takes a ixmonad indexed by i and j containing a function from a to b and returns a function between a ixmonad containing type a indexed by types j and k and another containing type a indexed by i and k
11:15:00 <hackrilege> where here k is not changing
11:15:08 <Cale> hackrilege: Yeah, it might be easiest if you just think of the i, j, k as states that the machine running the computation may be in, and m i j a means that the computation is allowed to start in state i, and will result in changing the state of the machine to j, and produce a result of type a
11:15:17 <hackrilege> so why does ijoin change the seccond index parameter, but iap changes the first!?
11:15:31 <hackrilege> that indicates some different significance of these two parameters
11:15:35 <xa0> :t void . sequence . map (print . show)
11:15:37 <lambdabot> Show a => [a] -> IO ()
11:15:41 <xa0> is this function standard anywhere?
11:15:51 <xa0> or similar
11:15:55 <xa0> "poor man's printf"
11:16:03 <shachaf> The function you want is probably "mapM_ print".
11:16:20 <shachaf> What you wrote is probably not what you want.
11:16:24 <hackrilege> :t mapM_ putStrLn
11:16:25 <lambdabot> Foldable t => t String -> IO ()
11:16:26 <Cale> hackrilege: just think about what order you're running things in
11:16:43 <xa0> huh, fair enough
11:17:02 <xa0> except definitely not putStrLn
11:17:57 <xa0> :t print
11:17:58 <lambdabot> Show a => a -> IO ()
11:18:03 <xa0> oh i see
11:18:07 <xa0> i thought that took a string
11:19:44 <xa0> shachaf: what's the diference, curiousity
11:20:33 <shachaf> Try it.
11:20:49 <hackrilege> so IxFunctor has 3 parameters, each datatype which instantiates is represents a computational machine which may exist in two states and return a output with some type
11:21:45 <simony> is there a better place to ask questions about the parallel and concurrency programming in haskell book than here?
11:21:47 <hackrilege> basically representing the "index" type of the functors at each end of the arrow????
11:22:04 <hackrilege> simony, no
11:22:44 <hackrilege> am i nearly understanding it yet Cale?
11:22:51 <Cale> sorry meeting
11:22:56 <hackrilege> kk
11:22:58 <Cale> brb
11:22:58 <simony> an example in ch3 doesn't seem to be getting the speedup the book claims it should be getting, and i'm totally stumped on why :(
11:23:15 <xa0> shachaf: oh, right void
11:23:33 <vektorweg1> hackrilege: simony: what about reddit?
11:23:39 <hackrilege> but thats got even architecture considerations, are you compiling it with the right flags
11:23:42 <hackrilege> ?
11:23:55 <shachaf> It's inefficient because of the (void . sequence) thing, and it prints the wrong thing because of the (print . show) thing.
11:24:02 <simony> I tried running https://github.com/simonmar/parconc-examples/blob/master/strat.hs, but don't see a parallel speedup when I compiled with `ghc -O2 strat.hs -threaded -rtsopts -eventlog` and ran with `./strat +RTS -N2 -l -s`
11:24:11 <hackrilege> reddit might be better or worse, not sure
11:24:28 <simony> this is with ghc-7.10.3 on osx
11:25:38 <simony> and I end up getting "SPARKS: 2 (0 converted, 0 overflowed, 0 dud, 1 GC'd, 1 fizzled)"
11:25:44 <hackrilege> os threading used by ghc is pretty good, perhaps an upgrade since the book automates the parallel control you think you are implementing. but honestly i have no clue so yes perhaps reddit is better....
11:26:05 <simony> thanks, I'll try posting there as well
11:26:13 <hackrilege> but ill cut out of the convo for a bit to see if anyone else can answer
11:26:41 <hackrilege> anyway, im reimplementing indexing using only one type parameter and i dont care what happens
11:26:52 <hackrilege> take that category theory
11:27:14 <hackrilege> :t range
11:27:15 <lambdabot> Ix a => (a, a) -> [a]
11:27:36 <hackrilege> :t unfold
11:27:37 <lambdabot>     Not in scope: ‘unfold’
11:27:37 <lambdabot>     Perhaps you meant one of these:
11:27:37 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
11:28:19 <hackrilege> unfold :: CoMonad m => (m a -> a) -> m a
11:28:39 <hackrilege> :t cojoin
11:28:41 <lambdabot>     Not in scope: ‘cojoin’
11:28:41 <lambdabot>     Perhaps you meant one of these:
11:28:41 <lambdabot>       ‘join’ (imported from Control.Monad.Writer),
11:29:46 <hackrilege> can anyone see a problem with that type for unfold?
11:33:08 <hackrilege> cojoin     :: w a -> w (w a)
11:33:59 <hackrilege> http://stackoverflow.com/questions/12537149/theoretically-is-this-a-valid-comonad-instance-for-a-list
11:34:24 <johnw> hackrilege: I was just reading about cofree recursive comonads, from Uustalo, you might enjoy it
11:34:50 <johnw> Uustalu, excuse me
11:35:02 <johnw> http://www.sciencedirect.com/science/article/pii/S1571066111000570
11:35:11 <johnw> in it I think he has some sort of coiter that is like your unfold
11:40:08 <simony> anyways, I've made a post on /r/haskellquestions. I'd appreciate it if someone can take a look: https://www.reddit.com/r/haskellquestions/comments/4cbh58/example_not_working_from_parallel_and_concurrent/
11:43:57 <amalloy> is there a better way to write this? i've tried two alternatives, but neither seems super amazing. (1) (,) <$> y <*> y where y = f x    (2) join (liftA2 (,)) $ f x
11:48:12 <Gurkenglas> amalloy, are you sure you want that done exactly twice, and substituting a three in another version of your program would be downright silly? If not, replicateM 2
11:49:04 <Gurkenglas> (I wonder why that's got a monad constraint.)
11:49:41 <amalloy> Gurkenglas: i'm doing a monte carlo estimate of pi, so generating random points in 2D space
11:49:55 <MichaelK> amalloy: 1) (((<*>) =<< ((,) <$>)) .) and 2) (join (liftA2 (,)) .) are what's given by pointfree
11:49:58 <Gurkenglas> Right, you could do that in 3D.
11:50:09 <amalloy> you could, but why?
11:50:25 <Gurkenglas> I'm not saying you should, I'm just saying [a] fits closer than (a, a), and thus replicateM is sane
11:50:37 <amalloy> fair enough, i suppose
11:51:23 <dolphines> i need a little help
11:51:49 <phanimahesh> !ask
11:52:04 <phanimahesh> oops, not #git. :P
11:52:15 <dolphines> trying to install https://github.com/Euterpea/Euterpea2
11:52:22 <dolphines> but it wont download the other modules
11:52:24 <dolphines> using windows
11:52:40 <phanimahesh> dolphines: Please ask your question directly. Someone will answer if and when they can.
11:52:55 <Gurkenglas> @where ask
11:52:55 <lambdabot> Don't ask to ask, just ask.
11:53:08 <phanimahesh> Oh. sorry, I have no idea about windows. been long since I used windows.
11:53:29 <phanimahesh> Kewl! I'll need to checkout lambdabot commands.
11:53:32 <Gurkenglas> Did you use a console command to try to install that?
11:53:51 <dolphines> http://i.imgur.com/jaRdDs6.png
11:54:00 <dolphines> install cabal
11:54:05 <dolphines> cabal install*
11:55:00 <dolphines> when did i do incorrectly
11:55:01 <dolphines> http://i.imgur.com/bIQFn8X.png
11:58:35 <Gurkenglas> paste C:\Users\d0x\AppData\Roaming\cabal\logs\HCodecs-0.5.log, please. If you'd pasted the text instead of a screen there, I wouldn't have needed to copy that line :P
11:59:27 <cubuspl42> Hello
12:02:19 <Gurkenglas> @where ask
12:02:19 <lambdabot> Don't ask to ask, just ask.
12:03:34 <dolphines> gurkengies
12:03:38 <dolphines> thats file is blank
12:05:06 <dolphines> C:\Users\d0x\AppData\Roaming\cabal\log
12:05:13 <dolphines> aww fuck my life
12:05:16 <dolphines> http://i.imgur.com/rnHRDnT.png
12:05:42 <dolphines> do i have to download each module by hand or can i do this in cmd
12:06:48 <dolphines> Failed to install PortMidi-0.1.5.2
12:07:52 <cubuspl42> Is this "PortMidi" thing a dependency of something you're trying to install via cabal?
12:08:08 <dolphines> yes
12:08:38 <dolphines> https://github.com/Euterpea/Euterpea
12:08:49 <cubuspl42> I'm new to haskell, but I had some issues with cabal similar to yours. When I wanted to install X and with dep Y, and Y failed to install, the error was laconic and unhelpful
12:08:58 <dolphines> There is a stable version of Euterpea on Hackage, so one can easily 
12:08:58 <dolphines> install Euterpea with:
12:08:58 <dolphines>     cabal install euterpea
12:09:01 <dolphines> this dails me
12:09:06 <cubuspl42> But then when I did "cabal install Y", the error was clear
12:09:09 <cubuspl42> And helpful
12:09:09 <dolphines> fails*
12:09:31 <cubuspl42> Try to install "cabal install PortMidi", maybe the error will be clear
12:09:59 <Cale> simony: A fizzled spark means that the computation was done in the main thread before it was able to be computed in parallel
12:10:24 <dolphines> http://i.imgur.com/4uDILWP.png
12:11:38 <Cale> simony: still here?
12:11:44 <simony> yup
12:12:04 * hackagebot codex 0.4.0.10 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.4.0.10 (aloiscochard)
12:12:59 <cubuspl42> dolphines: No idea :( I can tell you that I fixed my problem by adding ~/.cabal/bin to PATH, but your issue is probably unrelated
12:13:11 <dolphines> i am on windows
12:13:17 <Cale> simony: try changing the second rpar to an rseq there
12:13:19 <dolphines> cabal is a vaild command
12:13:25 <dolphines> but no matter what
12:13:29 <Cale> simony: and see if that does any better
12:14:10 <dolphines> i found the problem
12:14:25 <dolphines> http://i.imgur.com/1QD8hzn.png
12:14:30 <mgsloan> dolphines: I don't know windows well, but I do know of a relevant issue on the stack tracker: https://github.com/commercialhaskell/stack/issues/1448 
12:14:43 <mgsloan> It sounds like some poeple have success using a different terminal than the default windows one
12:14:58 <mgsloan> Like bash or whatever cygwin provides
12:15:02 <cubuspl42> I'd recommend badum 
12:15:28 <cubuspl42> badun *
12:15:37 <dolphines> well i fixed it
12:15:38 <cubuspl42> http://babun.github.io/
12:15:39 <simony> Cale: nope, just ends up with one less spark, but does get rid of the fizzle
12:16:00 <cubuspl42> dolphines: What was the problem, then?
12:16:06 <geekosaur> someone needs to write a script(1)-alike for windows to deal with text copy-paste being less than obvious
12:16:08 <mgsloan> dolphines: With stack, I think it's sufficient to just do "stack exec bash".  Not sure how to do this stuff if you have your own custom setup / cabal install stuff
12:16:29 <dolphines> http://i.imgur.com/1QD8hzn.png
12:16:35 <dolphines> ^ thts why
12:16:47 <mgsloan> Ah
12:16:48 <geekosaur> (I have no idea *how* you'd do that, given that the cmd.exe window is "special" and windows doesn't have ptys)
12:16:58 <dolphines> i unlocked it
12:17:21 <cubuspl42> I'm not sure what that means ^^ Was your cmd "run as admin" ?
12:17:38 <dolphines> on windows things have permissions
12:17:50 <dolphines> i had locked out the appdata folder from running ,.exe fukes
12:17:53 <cubuspl42> Well, they do have permissions on unix, too :P
12:17:54 <dolphines> i had forgot
12:18:10 <dolphines> http://i.imgur.com/wMx4uhH.png
12:18:33 <cubuspl42> Is this some commercial software?
12:18:48 <cubuspl42> or Windows Ultimate? Or what
12:18:59 <dolphines> ultra virus killer
12:19:03 <Cale> simony: Yeah, hmm
12:19:27 <cubuspl42> Ok, it's good you fixed your issue
12:20:12 <simony> Cale: adding -A16M does...something
12:21:06 <dolphines> slightly impressed
12:21:11 <dolphines> i didnt even have to set up midi
12:22:22 <Cale> simony: ah, hmm
12:22:57 <desophos> is it really necessary to learn type theory in order to write good programs (in general)? it seems like functional languages are so powerful, expressive, correct, etc. but it's so hard to learn the concepts necessary for taking advantage of their features
12:22:58 <simony> Cale: if you're curious, i'm getting help in #haskell-beginners
12:24:07 <cubuspl42> desophos: I guess you can take advantage of much stuff w/o knowing type theory
12:24:25 <cubuspl42> I'm a noob, tho. I'm learning haskell in my spare time
12:26:05 <EvanR> desophos: type theory, category theory, etc are good for making your head explode. if youre into this then go for it
12:26:26 <cubuspl42> Guys, I have a question: what IDE/Editor/Plugin has functionality like this: "show info and documentation for the symbol under the cursor". I know leksah has "search metadata", but it searches by string and it finds many results, not taking my particular usecase into consideration
12:26:34 <EvanR> otherwise it doesnt seem like people in other languages have needed it up to this point
12:27:06 <cubuspl42> I'm open to vim / yi
12:27:41 <cubuspl42> I have problems mostly with crazy operators like <+> or whatever
12:27:50 <cubuspl42> Because i can't google them
12:29:27 <desophos> EvanR: i want to write good code, i'm just not really interested in type theory
12:30:59 <EvanR> @hoogle (<+>)
12:31:01 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
12:31:02 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
12:31:02 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
12:31:32 <cubuspl42> I guess that the output above is meaningful to you
12:31:42 <EvanR> actually
12:32:27 <EvanR> i guess <+> really is from ArrowPlus
12:32:56 <cubuspl42> Mhm, but suppose that I'd like to guess what it does
12:33:05 <EvanR> so you can at least read the docs for Control.Arrow
12:33:30 <EvanR> but because all it says is "monoid for arrows", you are left guessing at exactly how its used in specific arrow instances
12:33:36 <EvanR> (monoidal arrow instances)
12:33:49 <EvanR> at least you found something
12:34:25 <cubuspl42> yeah, thanks. What do you use for haskell development?
12:35:27 <EvanR> vim ghci haddocks
12:35:43 <cubuspl42> pure vim, or some support for haskell specific?
12:36:58 <EvanR> no haskell support
12:37:21 <cubuspl42> I'm trying to learn haskell, I was really enthusiastic. But it seems like tooling is lightyears behind mainstream stuff like Java / Kotlin / C#
12:37:42 <cubuspl42> Everything is so deep, elite and pure ^^
12:39:13 <MichaelK> EvanR: why not haskell-vim-now?
12:39:24 <Cale> cubuspl42: The tools built into GHC are pretty nice
12:40:02 <Cale> cubuspl42: Personally, I think it's best to just let people use whatever they like to edit text and put all the tools elsewhere.
12:40:07 <cubuspl42> unix-tty-vim-terminal-gdb-kind--style nice, right? :D
12:41:09 <Cale> You can get HTML and postscript output in some cases, and there's ThreadScope :)
12:41:21 <Cale> (which I am actually installing right now)
12:41:35 <EvanR> ekg for checking runtime statistics
12:41:52 <Cale> Yeah, ekg isn't built-in, but it's also very nice
12:41:57 <cubuspl42> Cale: I thought like that once, but now I'm developing Java professionaly (I mean: as my job) and IntelliJ tought me that the IDE done right is a time saver
12:42:27 <EvanR> i was about to smash my computer trying to configure intelliJ
12:42:31 <xa0> i believe in using an IDE only for java
12:42:32 <Zemyla> If t is Foldable and Applicative, then foldMap f ((pure :: a -> t a) a) = f a, correct?
12:42:32 <Cale> I'm also very suspicious of interactive debuggers, in that yes, they can help you figure out what's going on in cases where you wouldn't be able to understand it
12:42:34 <EvanR> i was like why... 
12:42:40 <Zemyla> And foldMap f empty = mempty?
12:42:56 <Cale> However, this means that you can quickly end up with code which is beyond anyone's capacity to understand.
12:43:09 <hpc> everything i have ever wanted an IDE for in java has been accomplished in haskell simply by better choices in language design
12:43:12 <cubuspl42> EvanR: I thought that intellij is zero-configuration
12:43:28 <EvanR> really? someone should have told the intelliJ guys
12:43:29 <Cale> So you *have* to use the interactive debugger to maintain anything, which is just a terrible way to live.
12:43:42 <EvanR> if java was zero configuration, that would be something
12:44:15 <xa0> haskell isn't one of the languages {Java, C#, ?} that *needs* an IDE
12:44:34 <EvanR> otoh a haskell IDE would probably be cool
12:44:44 <EvanR> for people who like IDEs
12:44:54 <hpc> i don't really know what a haskell ide would even have
12:45:12 <Cale> I've worked on codebases which started out with -- let's just say much less experienced -- development teams, and the ability to patch things up iteratively by using the debugger resulted in code which I think was beyond any hope of human comprehension.
12:45:24 <EvanR> hpc: animated answer http://caryrobbins.com/intellij-haskforce/
12:45:31 <xa0> ..syntax highlighting and project support? that's about the extent of what's necessary
12:45:40 <hpc> xa0: sounds like vim
12:45:44 <xa0> exactly.
12:46:02 <Cale> It's best to fix bugs by breaking the code down into smaller parts until you understand each part and can ensure that it does what it is meant to.
12:46:05 <EvanR> i should probably forward these gifs to cubuspl42 
12:46:10 <EvanR> cubuspl42: http://caryrobbins.com/intellij-haskforce/
12:46:10 <cubuspl42> I'd like: good autocomplete, instant doc access for symbols under cursor, syntax highlighting
12:46:34 <EvanR> if installing and configuring this thing for intellij was like configuring it for clojure... good luck
12:47:02 <Cale> Well, syntax highlighting you're going to get with any text editor at all.
12:47:14 <cubuspl42> I know that's the easy part
12:47:39 <xa0> autocomplete is fairly easy with vim too
12:47:40 <EvanR> i was never able to get my javacode jumping to work
12:47:43 <Cale> I know there's stuff which does autocomplete for vim and emacs at least... I don't use it, but it's there.
12:47:48 <xa0> ^
12:47:58 <cubuspl42> Smart layout, I guess? It's important in haskell, right?
12:47:59 <Cale> Doc access is more complicated
12:48:05 <Zemyla> You know what I would want in terms of an IDE?
12:48:18 <Cale> All I really want is for my editor to understand the layout rule
12:48:25 <Cale> and no editor attempts this
12:48:31 <Zemyla> The ability to explore variables as a tree of constructors and unevaluated thunks, and selectively evaluate them.
12:48:33 <EvanR> cubuspl42: theres style guidelines but... you really need to understand the layout rules before you let the computer send you into oblivion
12:48:36 <simony> Cale: that's an interesting perspective on debuggers
12:48:38 <mgsloan> Cale: Emacs attempts that
12:48:48 <mgsloan> (well, haskell-mode)
12:48:51 <Cale> Any edit which causes the first non-whitespace character following 'let', 'do', 'of', or 'where' to move should cause the rest of the block to move accordingly.
12:49:11 <EvanR> Zemyla: thats more like a simulator?
12:49:16 <EvanR> or runtime debugger
12:49:30 <mgsloan> Cale: structured-haskell-mode does that, but you need to accept all its other opinions
12:49:36 <johnw> I'd like a switch that causes all my typed holes to be accepted by assuming a call to error with the file/line/position
12:49:40 <Cale> structured-haskell-mode doesn't really do taht
12:49:47 <Zemyla> EvanR: Shouldn't IDEs have integrated debuggers?
12:49:48 <Cale> It just doesn't let you edit the layout at all
12:49:56 <mgsloan> Cale: Yes it does
12:50:13 <gfixler> I want a marriage between Unison and Vim
12:50:16 <mgsloan> There are operations like indenting and dedenting a particular expression
12:50:24 <Cale> Yeah, I suppose
12:50:39 <mgsloan> It might not do fully automatically what you're suggesting, been a little while since I used it
12:50:39 <gfixler> and I want Vim, but moreso - I've hit the limits of Vim's vimness, and crave more
12:50:48 <EvanR> so time to rant on the "ideal" of "integration". why does everyone want everything integrated? why is it considered good? when you have modular systems, they dont integrate, they fit together exactly right in a way that lets they detach and reattach to something else. integrate sounds like grossly fusing two system together forever
12:50:49 <Cale> But yeah, I don't want that, I just want to edit text.
12:50:53 <xa0> more vimness, or more than vim?
12:50:53 <mgsloan> Anyway, I had an implementation of this in FP Haskell Center
12:51:01 <Cale> Also, its keys are horrible
12:51:08 <Cale> and nonsensical
12:51:12 <gfixler> EvanR: agreed, but it fits with what I've seen
12:51:15 <mgsloan> True, they're only tolerable to someone who knows paredit, I think
12:51:44 <cubuspl42> I guess that people want integration, because things aren't 100% optimized for typical workflow if stuff is not integrated
12:51:50 <gfixler> xa0: both - I have a ton of Vim-like ideas that up the power of Vim, but aren't in Vim
12:51:50 <mgsloan> I've been meaning to have a swing at doing structured-haskell-mode for the non-paredit-guy
12:51:59 <xa0> ah
12:52:02 <mgsloan> But there's so much to do
12:52:19 <gfixler> I've seen some things lately that actually give me hope beyond text editing for the first time ever
12:52:32 <gfixler> I love editing text, but have also dabbled with visual editors
12:52:39 <gfixler> but they never cut it - text was always best
12:52:46 <gfixler> but now I'm starting to change my mind a bit
12:53:27 <gfixler> cubuspl42: I think people want integrated because they don't want to do any integrating
12:53:45 <gfixler> cubuspl42: also, there's something to be said for everyone having the same setup, for multiple reasons
12:54:10 <cubuspl42> In my company (it's a giant one, tbh) everyone has the same dev setup
12:54:18 <gfixler> yep - mine too
12:54:31 <gfixler> that's the norm everywhere I've been
12:54:32 <cubuspl42> I mean, on the low level. There is a command that does build & testing.
12:54:48 <cubuspl42> And if it fails, it will fail in CI. If it does not fail, it won't fail in CI.
12:55:00 <gfixler> I'm always the weird guy, with Vim, git, command line, even sneaking linux in :)
12:55:16 <gfixler> then I ask for help, and people go "Just click on... you don't have a mouse? Wait, what is this?"
12:55:21 <xa0> @pl \(a,b) -> map (flip (,) b . (:a)) []
12:55:21 <lambdabot> uncurry (flip flip [] . (map .) . flip ((.) . flip (,)) . flip (:))
12:55:29 <xa0> amazing
12:55:34 <cubuspl42> well, the command line + git + linux is standard in mine! :)
12:55:36 <xa0> i've never seen so many flips
12:55:39 <cubuspl42> So i'm lucky
12:55:53 <gfixler> I like that each flip flips a different thing
12:56:27 <Blogle> Anybody know of resources for exposing Haskell to C, or how to build a shared library with Haskell?
12:56:35 <cubuspl42> gfixler: I don't like that
12:57:00 <cubuspl42> If they are different stuff, I won't be able to tell that, because hoogle will give me all results
12:57:01 <gfixler> cubuspl42: well don't flip out on me
12:57:06 <xa0> hahaha
12:57:58 <gfixler> for a while there I was using vim-arpeggio and a custom ftplugin file to add includes in single, chorded key presses
12:58:10 <gfixler> sorry, language extensions, not includes
12:58:25 <EvanR> i have a standard paste to get everything i ever use imported ;)
12:58:32 <gfixler> :)
12:58:45 <cubuspl42> So you import unneeded things too?
12:58:54 <EvanR> when im lazy
12:59:03 <EvanR> there are plugins to show you whats unneeded
12:59:06 <gfixler> I could press nmr, e.g., as a single keypress, and it would auto-add {-# LANGUAGE NoMonomorphismRestriction #-} at the top
12:59:08 <cubuspl42> And does your editor change colors of unused imports?
12:59:11 <johnw> Blogle: http://www.well-typed.com/blog/30/
12:59:17 <cubuspl42> Intellij does :(
12:59:20 <cubuspl42> For java
12:59:33 <EvanR> cubuspl42: did you see the intellij plugin i posted?
12:59:39 <cubuspl42> I did
12:59:51 <gfixler> but what I really wanted was to not worry about imports and language extensions, and to just have them auto-add as I worked
13:00:04 <EvanR> just activate all extensions ;)
13:00:05 <gfixler> and query me at the end about conflicts
13:00:14 <gfixler> ha, don't many of them compete?
13:00:26 <EvanR> dunno
13:00:32 <cubuspl42> @EvanR I'll have to check this out later
13:00:32 <lambdabot> Unknown command, try @list
13:00:48 <cubuspl42> Seems quite cool, solves many of issues that came into my mind
13:02:43 <cubuspl42> EvanR: It's interesting why that plugin is not written in Frege :P
13:03:18 <cocreature> is there a nice way to embed a function (r -> a) into a reader monad? (a nicer way than fmapping over ask)
13:03:50 <Blogle> johnw: that looks like a good start, I think the biggest unknown is how to Marshall my data across the language barrier
13:04:05 <danilo2> Hello! Is there any mechanism that I dont know about or will be there (maybe in GHC > 8.0) any mechanism to have better control over haskell inference errors while expanding instances? Lets consider something like: `class Foo a b c` and `type Bar a = Foo a a a`. If used `Bar` I would errors to be reported in this form, not in the expanded one. I know we can utilize newtypes here, but making newtypes everywhere in your code is not the
13:04:09 <johnw> Blogle: Storable is typical
13:05:18 <EvanR> cubuspl42: because frege isn't ready for prime time, whatever that means
13:05:51 <cubuspl42> EvanR: why?
13:06:29 <Blogle> johnw: there wouldn't happen to be a derive Storable would there?
13:06:30 <EvanR> because it consists of a github Pages ?
13:06:35 <EvanR> instead of an actual website?
13:06:45 <cubuspl42> I don't get it
13:06:49 <nitrix> Hi, how would I compose two Map lookup if my data structure uses nested maps?
13:07:07 <nitrix> I tried  lookup y <$> lookup x m
13:07:26 <nitrix> but I get a type error, obviously I'd have to join the two monads but I don't think fmap lets me do tha,t right?
13:07:35 <EvanR> frege appears to be a fraction of the age of idris, and idris is not ready for prime time, whatever that means, so QED
13:07:56 <danilo2> nitrix: lookup y =<< lookup x m ?
13:08:18 <dmj> :t \x m1 m2 -> M.lookup m1 x <|> M.lookup m2 x
13:08:20 <lambdabot> Ord k => M.Map k a -> k -> k -> Maybe a
13:08:29 <gfixler> EvanR: I started reading the Idris book and doing the examples, and running into weird issues right away
13:08:39 <gfixler> felt kinda alpha-stage to me
13:08:43 <nitrix> dmj: Alternative would be wrong for the behavior I'm looking for.
13:08:52 <nitrix> Apparently it's bind that I want.
13:08:57 <nitrix> danilo2: Thanks. My brain's off today.
13:09:09 <cubuspl42> But... isn't frege nearly identical to haskell?
13:09:25 <danilo2> nitrix: no problem, there is also Control.Monad.join, that lets you fuse nested monads together
13:09:27 <EvanR> let me read through frege code on gitrepo and tell you
13:09:28 <gfixler> is frege a port or a rewrite?
13:09:28 <cubuspl42> Is haskell ready for its prime time?
13:09:34 <EvanR> the fact that i can probably do that is going to say a lot
13:09:50 <EvanR> *the frege git repo
13:10:19 <dmj> nitrix: cool
13:11:26 <nitrix> danilo2: I know about join, but I was trying to do fmap & join, stupidly.
13:11:39 <nitrix> danilo2: I just noticed, (>>=) = fmap . join
13:11:50 <nitrix> Sorry, join . fmap
13:12:02 <danilo2> nitrix: experimenting is never stupid! :)
13:12:06 <dmj> :t join . fmap
13:12:07 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a1)
13:12:07 <lambdabot>     Expected type: (a1 -> a) -> f a1 -> f a1 -> a
13:12:07 <lambdabot>       Actual type: (a1 -> a) -> f a1 -> f a
13:12:20 <EvanR> oh man... frege's concurrency is based on java's concurrency
13:12:33 <EvanR> single tear
13:13:16 <EvanR> they dont have flexible instances...
13:13:23 <EvanR> among other things
13:13:34 <dmj> :t \(m :: m a) (f :: a -> m b) ->  join (fmap f m)
13:13:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:13:39 <dmj> nitrix: ^
13:14:16 <sachs4> why does       instance Eq Int => A Bool where ...        need UndecidableInstances?
13:15:12 <cubuspl42> EvanR: thanks for the research ;)
13:15:32 <EvanR> k. its not nearly identical to haskell ;)
13:16:03 <cubuspl42> That's a pity. I guess it will take years till I'll be able to understand the difference
13:16:31 <EvanR> all the haskell like languages out there right now have taken liberties with type system features and standard library layout, which is great. thats how we will eventually be free of haskells hysterical raisins
13:16:59 <gfixler> just use -XNoHystericalRaisins
13:22:07 * hackagebot ginger 0.1.8.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.8.0 (TobiasDammers)
13:26:12 <Sindriava> +1 for hysterical raising
13:26:18 <Sindriava> *raisins
13:27:36 <Gurkenglas> :t join .: fmap -- You mean this, (=<<)?
13:27:37 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
13:37:55 <mettekou> Is there a way to parse juxtaposition as function application associating to the left using parser combinators (specifically Megaparsec), as Haskell does?
13:39:48 <Sindriava> :t (.:)
13:39:49 <lambdabot> (b -> c) -> (t -> a -> b) -> t -> a -> c
13:40:03 <EvanR> mettekou: in Text.Megaparsec.Expr you can define a left assoc operator... whose parser is whitespace
13:40:18 <mettekou> EvanR: Awesome, thanks!
14:11:25 <danilo2>  Hello! Is there any mechanism that I dont know about or will be there (maybe in GHC > 8.0) any mechanism to have better control over haskell inference errors while expanding instances? Lets consider something like: `class Foo a b c` and `type Bar a = Foo a a a`. If used `Bar` I would errors to be reported in this form, not in the expanded one. I know we can utilize newtypes here, but making newtypes everywhere in your code is not th
14:23:48 <mettekou> EvanR: Tried out makeExprParser, but it doesn't seem to be able to handle recursive calls? This code fails on input "\A : Set -> A": http://lpaste.net/7507928207245443072; with the error message: "unexpected '-'
14:23:48 <mettekou> expecting "Proposition", "Set", "Type", '(', '\', letter, or space".
14:24:32 <EvanR> where in the string does it fail
14:25:15 <EvanR> i see, at -
14:25:17 <mettekou> Position 10, the start of the arrow.
14:25:21 <mettekou> Uhu.
14:25:34 <EvanR> include -> as a valid token
14:26:43 <mettekou> In parseTerm'?
14:27:16 <EvanR> i dont know what youre trying to do but it clearly accepted \, space, and Set
14:27:29 <EvanR> so wherever those are
14:28:25 <athan> Is there a quickcheck-instances alternative with newtypes for non-empty containers?
14:28:28 <mettekou> The line _ <- string "->" is already in parseFunction.
14:28:40 <EvanR> makeExprParser is specifically for the case where you have operator separated sequence of terms where terms are recognized by some other parser
14:28:59 <mettekou> Oh okay.
14:29:21 <mettekou> Then I guess I just need to put it in multiple places.
14:29:43 <EvanR> so if you had a parser that worked on \A or : or Set or -> or A then you could get a ((((\A) :) Set) ->) A
14:29:50 <athan> hmm...
14:29:50 <EvanR> which ... doesnt make much sense to me
14:30:48 <mettekou> I need a parser which allows for applications in type annotations as well (types are first class).
14:31:12 <mettekou> Stuff like: \xs : List A -> xs should be Valid.
14:31:30 <EvanR> its the same parser, just with a different term parser
14:32:12 <EvanR> Parser Expr -> Parser Expr, vs Parser TypeTerm -> Parser TypeTerm
14:32:35 <EvanR> both can use the same space-separated left-assoc becomes-nested-apply parser internally
14:33:12 <EvanR> i guess you also need to pass in the ctor for regular apply vs type apply
14:33:47 <mettekou> It's the same constructor, types are just values (CoIC).
14:35:46 <EvanR> well then... hopefully you have the same terms too then
14:36:02 <EvanR> and this is the same exact thing use in only 1 place! ;)
14:37:27 <rtur> I'm struggling to write a map function for churchlists (untyped lambda calculus), but can't wrap my head around the types involved. I have given "type Churchlist t u = (t -> u -> u) -> u -> u", with this the type definition for the mapChurch function is "mapChurch :: (t -> s) -> (Churchlist t u) -> (Churchlist s u)" . I also have the hint to use the function concat operator "." . My thinking is something
14:37:29 <rtur> like "mapChurch f c = \x y -> ((c f).(x (mapChurch f y))".. which doesn't work. I don't need a solution, since I could look it up on the next page :), just a hint or two to better understand the Churchlist type I think. I understand the Churchlist when written in the untyped lambda calculus (can't think of a map term for it either :/) but can't wrapt my head around the Churchlist type .
14:38:11 <jle`> rtur: church lists are basically foldr
14:38:18 <jle`> partially applied foldr's
14:38:37 <jle`> toChurchList xs = \f z -> foldr f z xs
14:38:54 <jle`> so if you can write map in terms of foldr, you can write map with church list s:)
14:39:21 <rtur> jle`, thank you, I'll give it a try :)
14:39:52 <johnw> jle`: I'd say that church lists can be implemented using foldr
14:39:56 <johnw> but it doesn't have to be a fold
14:44:15 <jle`> fair
14:44:18 <jle`> :)
14:45:45 <athan> Shoot... so newtypes' type arguments _must_ be of kind *?
14:46:10 <bitemyapp> athan: not to the best of my knowledge. Mu works.
14:47:05 <athan> bitemyapp: Wait yeah, you just need -XKindSignatures and put the explicit annotation
14:55:05 <athan> bitemyapp: Ever seen anything like this? https://github.com/athanclark/quickcheck-combinators/blob/master/src/Test/QuickCheck/Combinators.hs
14:55:22 <athan> in regards to quickcheck stuff
14:57:21 <bitemyapp> I don't understand context for, "in regards to" - I don't recall discussing QuickCheck with you. I've seen this before, looks nice.
15:00:25 <mgsloan> athan: Nifty, I like it!
15:01:38 <athan> thanks mgsloan! I'm probably going to throw in some Ord stuff too, like `Monotone`, maybe. Not sure
15:02:29 <mgsloan> It'd be nice if that could be written in a way that doesn't filter results and instead just generates within the range, but arbitrary doesn't support it :/
15:03:02 <mgsloan> (I'm just imagining `Between` potentially rejecting lots of picked values)
15:03:09 <athan> mgsloan: I agree, maybe there's a way with `choose` and `replicateM` for finite sets :)
15:03:14 <athan> yeah :\
15:12:40 <lazyWriter> what's the idiomatic way to matrix-transpose a (IntMap (IntMap a)) ?
15:18:00 <EvanR> try a list comprehension
15:20:07 <lazyWriter> transpose :: SparseMatrix a -> SparseMatrix a transpose sm = do   DIS.map fromList $ fromList [ (k2, (k1, v2))  | (k1,v1) <- toList sm, (k2,v2) <- toList v1 ]
15:21:10 <EvanR> brilliant
15:21:33 <lazyWriter> it still seems too complicated
15:21:43 <EvanR> haha
15:21:52 <lazyWriter> I want "transpose sm = switchIndexLocation 0 1 sm"
15:22:06 <lazyWriter> the fromList/toList seems very opaque / non-intuitive
15:22:12 <mgsloan> Yeah, that's the idiomatic approach.  You might get some performance boost from doing something more complicated with "unionWithKey"
15:22:19 * hackagebot postgrest 0.3.1.1 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.3.1.1 (begriffs)
15:22:26 <lazyWriter> when I look at "DIS.map fromList $ fromList [ (k2, (k1, v2))  | (k1,v1) <- toList sm, (k2,v2) <- toList v1 ]" , the first thing that comes ot mind is not "oh, that's transpose"
15:22:33 <EvanR> youre implementing the spare matrix type
15:22:39 <lazyWriter> yeah
15:22:50 <EvanR> if you had switchIndexLocation... you wouldnt need to implement it
15:23:10 <mgsloan> Yeah, it's a little like wanting "quake3 :: IO ()"
15:23:25 <lazyWriter> suppose I wanted to swpa indices 1 and 3 of a (IntMap (IntMap (IntMap a)))
15:23:35 <lazyWriter> I want a generic "switchIndexLoc" routine
15:23:43 <lazyWriter> rather than brekaing into lists and reassembling as a map
15:24:26 <EvanR> well whats the type of the generic routine
15:24:39 <lazyWriter> hmm, I can't type it
15:24:46 <EvanR> shucks ;)
15:24:59 <EvanR> if it has no type, then theres no hope!
15:25:57 <EvanR> there actually is a type
15:26:16 <EvanR> of course youll need dependent types!
15:26:28 <klajion> hi all
15:26:46 <klajion> is there a good way to define a map from a list where the key ordering corresponds to the ordering in the list?
15:27:14 <klajion> .. instead of the ordering characteristic of the key type
15:27:34 <klajion> or is the only way to do that to define your own ADT with a corresponding custom ordering?
15:27:52 <EvanR> you want to use the list index as the key?
15:28:24 <klajion> i want to use the fst of each tuple as the key, but the map ordering correspond to the list ordering
15:28:25 <klajion> so for example
15:28:39 <klajion> fromList [(5, 'a'), (3, 'b')]
15:28:57 <klajion> I'd like keys to return [5,3]
15:29:03 <klajion> instead of [3,5]
15:29:05 <EvanR> then you want to use the list index as the key, and you happen to have a pair as the value
15:29:20 <EvanR> oh, then no i dont get it
15:29:33 <klajion> I could do it as you describe
15:29:52 <klajion> the downside is I'd have to define a bunch of my own accessors to pull out the pair values
15:30:08 <lethjakman> So, I have a project using template haskell...and I'd like to see what's being generated. Is there any way to see that?
15:30:11 <klajion> instead of leaning on built-in Map functions
15:30:42 <EvanR> can you describe what you want again
15:31:01 <mgsloan> lethjakman: -ddump-splices ghc option
15:31:03 <lethjakman> Specifically I want to see what all Yesod Routes are generating. 
15:31:06 <klajion> I want to be able to operate on the map as I normally would
15:31:12 <lethjakman> mgsloan: With a build?
15:31:15 <klajion> for exmaple fromList [(5, 'a'), (3, 'b')]
15:31:38 <mgsloan> lethjakman: Yup.  It won't force build dirtiness though, so introduce a change in the file you're interested in
15:31:40 <lethjakman> stack build -ddump-splices
15:31:47 <klajion> I want to be able to, say, update with these keys
15:31:47 <lethjakman> It's saying that it's not an option. 
15:31:55 <amalloy> it sounds like you want a map that, instead of having an Ord constraint on the key, takes a (k -> k -> Ordering) to its constructor
15:31:55 <klajion> the only behavior I'm looking for that's different
15:31:59 <EvanR> but you want the toList to return the list in its original ordering?
15:32:09 <EvanR> that seems impossible
15:32:11 <klajion> is that the key ordering is derived from the original ordering, so keys, toList, yeah...
15:32:21 <klajion> yeah that's what i'm thinking
15:32:23 <EvanR> conversion to a map destroys that information
15:32:30 <EvanR> you could save it of course
15:32:33 <klajion> well, the map has an inherent ordering
15:32:43 <EvanR> yes and its not the one you want
15:32:43 <klajion> it's just derived form Ord characteristic of the key tyep
15:32:53 <EvanR> its not derivable from your keys at all
15:33:01 <klajion> so I could get this to work by defining my own Key type
15:33:07 <EvanR> how/
15:33:24 <klajion> like i said Data.Map has a notion of ordering
15:33:33 <EvanR> ..... 
15:33:59 <amalloy> EvanR: is there something like Data.Map that takes (k -> k -> Ordering) in its constructor? so that you can use something other than the keys' natural ordering
15:34:00 <klajion> but it's implied by the Ord typeclass
15:34:16 <klajion> as per the docs
15:34:16 <amalloy> with that it would be easy for klajion to implement the asked-for behavior
15:34:19 <klajion> "An efficient implementation of ordered maps from keys to values"
15:34:27 <EvanR> no it would not
15:34:39 <amalloy> it would, because you could construct such a function from the input list
15:34:41 <johnw> amalloy: you can always "pass in" the ordering by using a newtype wrapper
15:34:44 <klajion> the problem is that the ordering is fixed for the type of the key
15:35:04 <EvanR> you would still not get the list back in the same order it came in
15:35:05 <klajion> so I can get my own ordering by defining a key type from scratch with a set ordering
15:35:22 <EvanR> the list index is independent of the key 
15:35:28 <EvanR> unless theres something you didnt tell me
15:35:29 <klajion> my only problem with that is it's quite a bit of boilerplate
15:35:49 <klajion> that's what i'm asking about
15:36:12 <klajion> is there an idiom such that the notion of ordering is effectively derived from the original list instead of the key type's ordering
15:36:19 <EvanR> if thats NOT what you want, and you want to use a different ordering on Ints, then use newtype
15:36:21 <klajion> i'm guessing the answer is no
15:36:31 <klajion> g2g for a bit
15:40:04 <athan> mgsloan: I had to use Unfoldable and Monoid for empty, sadly, but it's much better now
15:40:05 <mgsloan> lethjakman: stack build --ghc-oiptions -ddump-splices
15:40:15 <mgsloan> (sans typo)
15:40:30 <johnw> amalloy: https://gist.github.com/5fd29935f4bf271fc102
15:40:38 <johnw> that's a dynamic way to choose Ord instances at runtime
15:41:01 <johnw> you'd use: reify (compare :: Foo -> Foo -> Ordering) $ ... code ...
15:41:13 <johnw> also, wrapping the data you want to vary using "O"
15:41:22 <johnw> much longer discussion of this technique here: https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection
15:42:01 <johnw> in effect we've using principled implicit parameters to manually choose our instance dictionary
15:42:07 <amalloy> interesting
15:42:29 <johnw> this way you don't need 50 newtypes if you really have 50 different Ord choices
15:42:53 <EvanR> indeed a Map that takes the dang function would be nice
15:42:58 <johnw> oh, you only need UndecidableInstances in that code
15:43:07 <thoughtpolice> unsafeCoerce is incredibly principled. Only in this one exact case, anyway. :)
15:43:29 <johnw> it's totally principled; people just don't ask what the principle is :)
15:45:07 <int-e> "in principle, we could implement this---less efficiently---without unsafeCoerce"
15:46:15 <thoughtpolice> :P In this one case, at least, unsafeCoerce is basically guaranteed to do the right thing. That is, unsafeCoerce is guaranteed to not crash if you remove a newtype wrapper (or add one). The bit that isn't principled is the dictionary elaboration, really.
15:46:23 <johnw> amalloy: updated gist; I forgot to transfer some things from thoughtpolice's example
15:46:48 <johnw> int-e: and Oleg's originally paper does exactly that
15:47:07 <int-e> johnw: yes I know
15:47:41 <EvanR> so any time you guarantee you are unsafeCoercing from to the same type by type parachute between the library and the user, its principled?
15:48:43 <EvanR> feels a bit like void*
15:50:36 <johnw> you're saying that the type system thinks two things are different, but they aren't at runtime so don't complain
15:51:22 <EvanR> yes, so it works... as long as the library doesnt screw up
15:51:30 <johnw> in cases where this is clearly true (newtypes), you can use "coerce" safely
15:51:37 <thoughtpolice> EvanR: I just mean, there are few situations where it is actually guaranteed to do something 'sane' without crashing horribly or not. newtypes are one of them. In this case, reflection encapsulates both the newtype and the call to unsafeCoerce
15:51:39 <thoughtpolice> So, it's fine.
15:52:05 <shachaf> thoughtpolice: => vs. -> isn't a newtype
15:52:27 <EvanR> ah interesting, so unsafeCoerce might explode in your face when its not newtype?
15:52:29 <shachaf> Or maybe I'm missing context here.
15:53:05 <thoughtpolice> In our surface syntax, it isn't. At the core level, => is just ->. Maybe in this case the distinction isn't very important. I just wanted to follow up on my original joke.
15:53:45 <int-e> EvanR: arguably the newish "coerce" captures the principled uses of unsafeCoerce.
15:53:47 <thoughtpolice> Arguing whether the 'bad' bit about reflection is the unsafeCoerce itself or the fact it working relies on GHC's elaboration mechanics is a bit irrelevant at the end of it, I guess.
15:55:32 <thoughtpolice> EvanR: Yes. Maybe. Depends on what the actual type is. The cases where it is OK to use and won't explode are elaborated on here: https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Prim.html#v:unsafeCoerce-35-
15:55:59 <klajion> back
15:56:26 <thoughtpolice> And the TL;DR is casting between Any, a few limited unlifted types, ADTs of exactly the same exact 'shape', or newtypes. Literally anything else will explode, most likely.
15:57:37 <EvanR> ok i assumed you could convert a boxed type to Any and back to itself
15:57:39 <EvanR> seems you can
15:57:59 <EvanR> (in ghc)
15:59:42 <Taylor> Sort of new to Haskell, I'm wondering if I can use list comprehension to pull the contents of two lists to a single variable, something like [x | x <- xs, x <- ys]. The result I'm getting is not what I'm wanting, and quite frankly I'm not sure why it's resulting in what it is..
16:00:04 <Axman6> Taylor: what result are you expecting?
16:00:05 <hpc> what output are you expecting?
16:00:08 <hpc> lol
16:00:26 <Taylor> [x | x <- [1,2], x <- [3,4]] produces [3,4,3,4] and I'm expecting [1,2,3,4]
16:00:37 <Taylor> I could concatenate the two but I'm wanting to add additional conditions
16:00:47 <Axman6> what you've written says "for each x in xs and for each x (a new x whish shadows the old one's name) in ys, return me the (new) x
16:01:09 <hpc> list comprehensions don't work in a way that will make what you want possible
16:01:11 <tommd> "for each _ in [1,2] and for each x in [3,4] return x
16:01:12 <kadoban> If it helps, it's the same as [x | zzz <- [1,2], x <- [3,4]]
16:01:14 <Cale> Taylor: perhaps you meant to write [x | x <- [1,2] ++ [3,4]] ?
16:01:15 <Axman6> list comprehensions are all about cartesian products
16:01:37 <Cale> Taylor: (which will let you add some more conditions afterward)
16:01:41 <Taylor> Alright, I see why I'm getting what I'm getting. I'm probably attacking this problem the wrong way.
16:01:53 <hpc> what conditions do you want to add after, btw?
16:02:32 <Taylor> determine whether x is an element of one list but not the other
16:02:45 <hpc> ah, perhaps something like
16:02:57 <hpc> :t \x y -> filter (`elem` x) y
16:02:59 <lambdabot> (Eq a, Foldable t) => t a -> [a] -> [a]
16:03:09 <hpc> er
16:03:11 <hpc> :t filter
16:03:12 <lambdabot> (a -> Bool) -> [a] -> [a]
16:03:18 <hpc> oh no, that's right
16:03:33 <hpc> that'll produce only the elements of y that are also in x
16:03:41 <klajion> i'm a bit bummed python has made people think list comprehensions are the ultimate list processing tool, function composition is a much better/more general foundation
16:04:08 <Cale> klajion: List comprehensions still have their place -- if you'd otherwise be writing lots of concatMaps, it's quite nice.
16:04:36 <Cale> I also really like the almost-degenerate case of a list comprehension with no generator, but a guard condition
16:04:39 <Taylor> I've only got very basic experience with python, it's just that my professor has just gone over list comprehension and I figured it might fit the bill
16:04:49 <jophish_> I quite like list comprehensions for filtering (and consuming) a single constructor in a list of ADT values
16:04:53 <klajion> Cale they
16:04:56 <Cale> [x | cond] is an empty list if cond fails, but [x] if it succeeds
16:05:08 <klajion> are convenient, i just don't think of them as foundational
16:05:09 <jophish_> Cale: nice
16:05:16 <shachaf> Cale: Not a fan of [x|] as a MonadComprehensions syntax for return x?
16:05:26 <Cale> shachaf: haha
16:05:28 <shachaf> Unfortunately it's a syntax error.
16:05:45 <Cale> [x | True] should work
16:05:46 <klajion> to me they're kind of a limited, pre-defined composition.
16:05:49 <jophish_> NullaryComprehensions extension incoming 
16:05:52 <shachaf> Cale: If you have MonadZero.
16:05:59 <Cale> yeah
16:06:03 <shachaf> Or does it use fail?
16:06:07 <shachaf> I guess it does.
16:06:14 <hpc> klajion: they're a wonky form of do-notation, is probably the idea you're after
16:06:16 <Cale> I'm not sure
16:07:20 <hpc> it's really easy to write sub-par code with comprehensions that would be faster or even easier to understand and modify if you wrote it functionally
16:07:30 <Axman6> hmm, I'm sure I've written if foo then [x] else [] many times before, I should definitely try using [x|foo]. Rwads nicely too, return x given foo
16:07:37 <hpc> once you get past the trivial cases
16:07:46 <hpc> Axman6: try guard foo
16:08:01 <johnw> well, x <* guard foo
16:08:03 <Axman6> that doesn't give me x though
16:08:06 <Axman6> right
16:08:10 <johnw> or x <$ guard foo, I meant
16:08:20 <hpc> ^
16:08:33 <klajion> hpc isn't it basically a map and filter?
16:08:59 <hpc> [x | body] = do body; return x
16:09:06 <HallaSurvivor> so why exactly is a monoid useful?
16:09:11 <HallaSurvivor> as in, why have a classification for it
16:09:20 <hpc> [... | x <- m, ...] = do x <- m; ...
16:09:40 <hpc> [... | ..., boolean condition, ...] = do ...; guard (boolean condition); ...
16:09:58 <amalloy> HallaSurvivor: because you can usefully write functions that operate on any monoid, such as mconcat
16:10:32 <hpc> klajion: those are the translation rules for list comprehensions (roughly) - check out the MonadComprehensions language extension which generalizes it
16:10:35 <HallaSurvivor> amalloy, so what functions might I write that use them
16:10:36 <klajion> amalloy generic programming (is that the right term for it?)
16:10:38 <johnw> Wadler's original paper on monads for Haskell describes them in terms of comprehensions
16:10:52 <hpc> klajion: it actually used to be fully generalized, but was later made more specific
16:11:21 <Cale> HallaSurvivor: I wrote a little example... let me find the link
16:11:35 <EvanR> and monoids dont stop at Monoid theres several monoid classes for special cases
16:11:35 <Cale> HallaSurvivor: https://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx
16:11:42 <klajion> hpc not surprising..
16:11:48 <HallaSurvivor> Cale, ty
16:11:56 <Cale> The lifting instances for Monoid get you lots of other interesting monoids for free
16:11:59 <Cale> basically
16:12:12 <klajion> hpc the dominance of python bums me out in general :P
16:12:13 <Cale> But also, yeah, there are things like Writer, which are parameterised over a choice of monoid
16:12:16 <Cale> Or FingerTree
16:12:21 * hackagebot texmath 0.8.6 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.6 (JohnMacFarlane)
16:12:21 <hpc> klajion: if you've ever thought do-notation for lists was confusing, that translation might actually make it easier to understand
16:12:26 <hpc> klajion: same
16:12:59 <hpc> so many bad philosophies being spread by python programmers who find themselves writing in other languages
16:13:18 <Cale> FingerTree is so beautiful, I just wish it performed a little better so we could actually use it directly on a more regular basis instead of taking the idea and then hand-specialising the code.
16:13:40 <hpc> at least javascript programmers have the sense (or lack of) to keep all the crazy in their own little world
16:13:44 <HallaSurvivor> Cale, That's super cool. I would never have thought to use two comparison functions like that O.o
16:13:57 <klajion> hpc i just want to say "no we can do better",. and compared to java and C++ pythonistas feel like python is some sort of haiku poetry, and that's the extent of their comparative experience
16:14:04 <EvanR> Monoid m => Monoid (a -> m) 
16:14:04 <shachaf> Cale: (e -> a) is a monoid when a is a monoid and e is a comonoid
16:14:16 <Cale> shachaf: :)
16:14:43 <hpc> haikus are pretty
16:14:46 <hpc> but sometimes they don't make sense
16:14:50 <hpc> refrigerator
16:15:11 <MarcelineVQ> it's snowing on mt. fuji
16:15:22 <Cale> HallaSurvivor: Basically, whenever we use trees throughout computer science, we're usually doing it in order to summarize the elements of the tree at the leaves somehow, to facilitate traversing the structure later
16:15:28 <klajion> the other thing that kills me is all the numerical/scientific computing ecosystem is locked into it now
16:15:48 <hpc> this probably belongs in -blah
16:15:57 <klajion> there's no turning back until a generation or two of scientific computing people die off. sorry... OT
16:16:00 <shachaf> Cale: Hmm, (e -> a) is a comonoid when e is a monoid and a is a comonoid?
16:16:04 <Cale> HallaSurvivor: In order to make that happen, you need a way to combine summaries
16:16:11 <HallaSurvivor> Cale, that makes a lot of sense. I'm still a toddler in programming terms, let alone haskell, haha
16:16:23 <Cale> HallaSurvivor: So as to say how the summaries of subtrees are combined to form the summary on the root
16:16:24 <HallaSurvivor> Cale, what do you mean by summaries?
16:16:34 <shachaf> Cale: Maybe not.
16:16:38 <klajion> getting some dinner
16:16:55 <klajion> (ps i can't get into -blah anymore)
16:17:08 <hpc> you need to reconnect with encryption
16:17:16 <Cale> Well, it might be something different in each use case, but for example, maybe we want to know the maximum element in the subtree (or -infinity if it's empty)
16:17:17 <hpc> Oejet's gone mad with power ;)
16:17:39 <klajion> why oh why? the whole point of blah is that the conversation is inconsequential :P
16:17:57 <Cale> HallaSurvivor: that will let us know (by looking at the summary on the left subtree) whether something lies in the left or right subtree, if we store everything in order
16:18:16 <klajion> alright dinnertime
16:18:35 <Cale> HallaSurvivor: Or perhaps we might store the sum of the elements, in order to be able to later chop the tree into two parts whose sum is roughly the same
16:18:38 <hpc> HallaSurvivor: the general strategy being, take a large bunch of information, split it up a bit, solve those parts into smaller parts, and keep shrinking the problem until you have one thing left
16:19:24 <Cale> HallaSurvivor: But regardless of what a "summary" is, in order to make such algorithms efficient, we tend to want to keep the trees "balanced", i.e. the number of elements in the left and right subtrees should be roughly the same
16:19:55 <Cale> HallaSurvivor: In order to make it possible to rebalance trees, we need our mechanism for combining summaries to be associative
16:20:16 <Cale> and we may or may not also need that it has an identity element, depending on the precise formulation of the trees
16:20:35 <Cale> that is, the conditions on a monoid are pretty much exactly what's required
16:20:40 <hpc> Cale: probably want to draw a picture for that part ;)
16:20:46 <Cale> yeah...
16:21:11 <hpc> the visualization between (a + b) + c as a tree isn't something you can make the logical leap of when first starting out
16:21:40 <hpc> much less expanding it into an imbalanced tree and seeing how the laws let you move things
16:21:43 <Cale> :)
16:21:47 <Cale> Yeah, fair enough
16:21:55 <MarcelineVQ> is that explained somewhere?
16:22:34 <hpc> Cale: if you do draw it out, put it on the h.org wiki someplace
16:22:45 <Gurkenglas> I have the feeling newcomers would have less trouble with IO if "Program" was an alias for "IO ()" and used in tutorials
16:22:47 <hpc> because it's a pretty snazzy realization
16:22:57 <Cale> HallaSurvivor: If you *do* know the relationship between expressions like a * (b * (c * d)) and trees, then the basic idea is that associativity is what gets us from imbalanced trees like that one there (which has too many elements in its right subtree) to something like (a * b) * (c * d) which is balanced
16:23:09 <johnw> Gurkenglas: except that wouldn't connect with any of the error messages they'd see
16:23:17 <Cale> Gurkenglas: Or if we just used Program as an alias for IO itself
16:23:18 <hpc> Gurkenglas: no way, they'd just be surprised that their Program if of type IO String and why can't it just be a program because it's obviously blahblah
16:23:46 <maerwald> Program is a pretty fuzzy description
16:24:05 <Cale> Yeah, there's really nothing to get around explaining that there is a distinction between evaluation and execution
16:24:11 <Gurkenglas> maerwald, how about "Instruction"
16:24:17 <hpc> type Executed = IO
16:24:18 <hpc> ?
16:24:19 <johnw> Cale: that distinction is really the key too
16:24:38 <johnw> if there's one thing imperative does, it makes you think there is only one model
16:24:54 <hpc> (type Evaluated = Identity)
16:25:08 <maerwald> Cale: and execution is undefined in haskell :P
16:25:12 <MichaelK> Heya, is there a good way to get the derived type of the class method of a particular instance in ghci?
16:25:13 <Gurkenglas> johnw, why don't error messages try to use aliases anyway?
16:25:23 <johnw> Gurkenglas: sometimes they do
16:25:25 <hpc> execution is defined as whatever the machine decides it is
16:25:36 <maerwald> it's defined by the compiler implementation afaik
16:25:47 <johnw> maerwald: and the runtime .o that's linked in
16:25:50 <maerwald> yes
16:25:56 <maerwald> but the language does not define it
16:26:02 <hpc> one could argue that POSIX is the specification for IO
16:26:36 <hpc> *is a specification
16:27:16 <maerwald> that doesn't really define what IO triggers in the GHC RTS though
16:27:16 <johnw> A monad tutorial is properly constructed when a monad tutorial about monad tutorials clearly implies a monad tutorial.
16:27:21 * hackagebot zip-archive 0.3.0.1 - Library for creating and modifying zip archives.  https://hackage.haskell.org/package/zip-archive-0.3.0.1 (JohnMacFarlane)
16:28:15 <monochrom> haha johnw
16:28:27 <maerwald> I think I've not seen a single haskell tutorial though that starts with explaining the difference of evaluation and execution and how that distinction is different in haskell compared to e.g. C
16:29:27 <monochrom> true. in the far future, my lazy evaluation article will address that (it is forced to), but that's in the far future.
16:29:49 <monochrom> (essentially, I haven't got to I/O, where it becomes necessary)
16:29:52 <Axman6> ba dum tsh
16:30:32 <hpc> i could have sworn LYAH covered it early, but now i look back and it tenaciously avoids using IO for about 6 chapters
16:32:59 <maerwald> you read more than 2 chapters? :P
16:33:26 <hpc> it's how i learned haskell
16:33:59 <hpc> it was fluffy and ridiculous, but the concepts were in the right order imo
16:34:16 <monochrom> on the bright side (or is it the dark side), there are C textbooks that can go on for 10 chapters and still no tree data structure.
16:34:38 <johnw> they are usually much more fond of linked lists
16:34:40 <hpc> i think a better example might be if they go 10 chapters before mentioning typedef struct
16:34:47 <maerwald> johnw: you mean arrays
16:35:23 <hpc> maerwald: you mean dictionary hash-dict buffer sequences
16:35:28 <maerwald> :P
16:35:35 <johnw> sure, but those aren't really "data structures", in that it's just a pointer to an area of memory with definite size, not a structure that builds up some kind of representation
16:36:01 <Jinxit> of course arrays are data structures
16:36:03 <Jinxit> if a bit simple
16:36:29 <EvanR> heh, its a pointer to an area of memory... at least
16:36:44 <hpc> let's go even further, is void* a data structure?
16:36:49 <EvanR> size is subjective
16:37:20 <maerwald> C array != C pointer please
16:38:05 <johnw> maerwald: are you making that argument at compile-time, or run-time :)
16:38:10 <hpc> C arrays are actually numbers that are indexed by variable names
16:38:18 <EvanR> or preprocessor time
16:38:21 <hpc> that's why i always dereference using 5[variable] syntax
16:38:23 <orion> It's all just ones and zeroes.
16:38:33 <monochrom> I am sorry I mentioned C
16:38:46 <maerwald> http://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c
16:38:46 <johnw> monochrom: as if you didn't know by now :)
16:38:52 <EvanR> data IO = I | O
16:38:53 <hpc> monochrom: oh no, there's far more ridiculousness left in this conversation
16:38:54 <monochrom> but void* is simply Ptr a
16:39:02 <hpc> EvanR: lol
16:39:21 <cubuspl42> C standards defines what array is, so it can be formally proven that array != pointer ;)
16:39:30 <johnw> anyway, back to Haskell
16:39:57 <hpc> johnw: oh don't be fooled, this conversation has deep consequences for haskell ;)
16:39:58 <EvanR> if programming languages were stereotypical behavior of programming language users
16:40:07 <monochrom> pointers and arrays are both Ptr a.
16:41:03 <EvanR> unboxed vector of unboxed unsigned char
16:41:11 <monochrom> @quote monochrom semantics.*IO
16:41:11 <lambdabot> monochrom says: <monochrom> great way to answer a semantics question by commenting on the font  <monochrom> "what is the semantics of IO?" "the I may be narrower than O in some fonts, and same width in some other fonts"  <monochrom> "on very old typewriters, it also denotes the number 10 (ten), for those of you looking for a denotation" XD
16:41:32 <hpc> what's the difference between pointers and arrays, beyond the operational detail of there being additional defined memory outside its range
16:42:09 <maerwald> compiler troll mode: -Wall -Wextra -pedantic -ansi 
16:42:19 <maerwald> oh, forgot -Werror
16:42:21 <johnw> is there a list of "IO primitives"?  That is, functions in IO one can't write without using those same functions?
16:42:23 <Jinxit> ansi
16:42:24 <Jinxit> save me
16:42:28 <maerwald> :D
16:42:31 <Axman6> s/troll/is your best friend/
16:42:39 <EvanR> johnw: all you need is peek and poke
16:42:50 <johnw> EvanR: can I make system calls with those?
16:42:58 <bitemyapp> johnw: I think only implicitly and imperfectly with the prims list and the flags thingy that says something isn't ref trans.
16:43:01 <EvanR> yyyyy.... no
16:43:11 <bitemyapp> johnw: could be nice if such a thing existed.
16:43:12 <EvanR> unfortunately
16:43:12 <hpc> if peek and poke can change registry values, they are enough
16:43:22 <monochrom> johnw: I think there is, but it is scattered over various GHC.* modules
16:43:25 <Axman6> is that sufficient for syscalls? (peek and poke)
16:43:37 <EvanR> bitemyapp: pure?
16:43:37 <bitemyapp> oh you mean higher level than that.
16:44:04 <johnw> so, to define a semantics of IO, I'd need a domain in which to give the denotations of these IO primitives, where for every one I'd have to include the possibility of an exception...?
16:44:11 <EvanR> you cant actually do a syscall by doing a peek or poke
16:44:26 <hpc> johnw: remember, IO includes the possibility of lightning strikes
16:44:41 <johnw> LightningException
16:45:27 <monochrom> the domain should already have exceptions built-in
16:45:29 <EvanR>   LightningException gigawatts | gigawatts == 1.21 -> 
16:45:56 <johnw> monochrom: ah, good point
16:47:27 <babaca> ola pessoal
16:47:57 <johnw> monochrom: has anyone done research in this area?
16:48:07 <monochrom> I don't know
16:48:16 <lazyWriter_> I'm implementing my own sparse matrix library. To be consistent with haskell, should I be 0-indexing or 1-indexing ?
16:48:17 <guri> how?
16:48:31 <hpc> always be 0-indexing
16:48:38 <babaca> is the here brazilians?
16:49:06 <EvanR> there should be a form of semantics which assigns to each program a semi-detailed report of football plays
16:49:14 <hpc> babaca: there's a link to a list of channels in the topic, follow that and see if there's a -br sub-channel
16:49:35 <EvanR> with the advantage that timing issues are built in and things are constantly blocked on confusion over the rules, so its a good match
16:49:42 <monochrom> it does seem (denotation people) ∩ (interaction people) = {conal} but conal just does FRP and not I/O
16:50:04 <monochrom> the rest of the interaction people use automata
16:50:38 <EvanR> i guess this counts as interaction
16:51:22 <monochrom> so for example if you look at Nancy Lynch, she defines "I/O automata". 
16:52:06 <johnw> so, for IO, we really just thoughtpolice & co. not to be insane
16:52:10 <johnw> s/just/just trust
16:53:27 <Sindriava> Did someone say Rust?!
16:53:38 <Sindriava> Oh, trust, nevermind.
16:59:49 <EvanR> Sindriava: rust no one
17:00:08 <Sindriava> In Rust we trust
17:00:25 <monochrom> forkIO is going to be a main difficulty. because the whole point of denotational semantics is to ignore such control flow as multi-threading
17:01:11 <mgsloan> pi calculus!
17:01:14 <monochrom> whereas putChar, getChar, getChar that can throw an EOF exception, and IORef are all denotable
17:01:21 * mgsloan spouts without really being sure if that's a denotational semantics
17:03:04 <Sindriava> I never really understood exceptions in rust
17:03:14 <Sindriava> They seem… out of place.
17:03:15 <monochrom> that is probably not worrisome because either pi calculus counts as denotation, or pi calculus is denotable.
17:05:52 <Sindriava> Is someone in here a bit more familiar with stack? I think I'm using it wrong
17:06:49 <mgsloan> Quite familiar with stack, what's up?
17:06:57 <johnw> there appears to be research on DS for asynchronous concurrent systems
17:07:10 <blume> ohhh i want to get into stack too
17:07:16 <blume> i only know cabal hell.
17:07:25 <Sindriava> mgsloan: For starters, I don't think that `stack install X' ever worked for me. the lts resolver is pretty much useless it feels
17:07:39 <Sindriava> mgsloan: gimme a second, I'll reinstall stack, so I can give some examples
17:08:01 <blume> haskell
17:08:07 <blume> 's so beautifully complex.
17:08:24 <blume> thanks to all you devs out there
17:08:25 <blume> x]
17:09:21 <Sindriava> blume: There's a very thin line between complex and complicated :(
17:09:37 <mgsloan> Sindriava: Stack isn't really meant to be a package manager, it's more of a build tool for projects consisting of multiple cabal packages
17:09:55 <mgsloan> So it isn't surpsing when "stack install X" fails for packages outside of stackage
17:10:10 <Sindriava> mgsloan: Yeah I keep hearing that, but I don't see an alternative around :/
17:10:35 <Sindriava> That was the catchphrase for cabal too, "it's not a package manager"
17:10:45 <mgsloan> There's this issue for giving the option of having a global "stack install" be a bit cleverer https://github.com/commercialhaskell/stack/issues/1693
17:10:58 <mgsloan> Yeah, you know why?  Because it's a pain to be a package manager
17:11:09 <blume> pacman is an awesome package manager.
17:11:10 <mgsloan> We will probably still implement uninstall / removal and such
17:11:19 <blume> or nix
17:11:21 <Sindriava> mgsloan: Yeah well it's a pain to be a user of that shit :D
17:11:22 <blume> no w8
17:11:28 <blume> ;p
17:11:37 <Sindriava> mgsloan: I go to Snap's website says "cabal install snap && snap init"
17:11:54 <mgsloan> Ok
17:11:57 <eze> what tutorial can you recomend me for latex writing with literate haskell?
17:12:14 <blume> woah tooo muc jquery and js last ye
17:12:16 <Sindriava> Now I'm not to argue what cabal / stack are or are not, but people seem to use it to install packages and we can't really have it both ways :/
17:12:20 <blume> year
17:12:23 * hackagebot jsaddle 0.3.0.2 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.3.0.2 (HamishMackenzie)
17:13:07 <monochrom> the problem is that "manage packages" is much more than "install packages"
17:13:42 <mgsloan> Sindriava: The question is, is stack more about building your code, or more about installing someone else's code?
17:13:48 <Sindriava> monochrom: I get that, but if something is going to install a binary that I'm to use for work, i expect it to be more than a glorified `wget' :(
17:13:53 <mgsloan> Reliably building a complicated project is the hard problem, we focus on that
17:13:57 <Sindriava> mgsloan: Don't take this strictly as a criticism of cabal / stack, I realise it might have sounded that way a lot, but it's mostly because I've grown bitter of the issues I've had
17:14:02 <blume> ywa everyone's got their package....... and project..........
17:14:26 <mgsloan> Sindriava: Fair.  Keep in mind stack development is less than a year old.
17:14:31 <Sindriava> mgsloan: I'm more than open to the idea that I'm the dumbass here, using the wrong end of a screwdriver
17:14:39 <monochrom> and after a while, you notice that stack likes to pin and freeze version choices, which is in fact kind of anti-manage-package, because all other package managers prefer you to always upgrade
17:15:00 <mgsloan> Sindriava: Right, once you learn stack a bit it's quite easy to use to install other people's packages
17:15:06 <conal> johnw: i doubt one could ever come up with a useful (non-degenerate) denotation for (Haskell's) IO. in part because IO serves as the repository for everything we don't understand denotationally. see http://conal.net/blog/posts/notions-of-purity-in-haskell#comment-442 .
17:15:15 <mgsloan> It just doesn't make the global configuration install case a braindead simple operation
17:15:27 <mgsloan> Because it isn't the case we care about
17:15:37 <blume> ooooh
17:15:39 <mgsloan> and what we've got is powerful enough
17:15:39 <conal> johnw: as for a list of IO primitives, consider that there's everything that could possibly be FFI'd.
17:15:59 <blume> ewww ffis
17:16:05 <blume> and thh 
17:16:10 <blume> :o
17:16:20 <blume> C
17:16:22 <blume> ;
17:16:43 <Sindriava> mgsloan: Well, care or not, it's what people seem to be using it. I don't se an easy way to install ghc-mod, hoogle or snap other than stack, and stack should IMO aim to be a universal CLI tool for haskell developers, covering as much as it can
17:16:57 <Sindriava> mgsloan: Now granted, this may not be what Stack wants to be
17:16:59 <conal> johnw: in that link, see especially the "Toxic Avenger" paragraph.
17:17:14 <mgsloan> Sindriava: Anywho, point is, contributions are appreciated.  For our work we do not have need for streamlining usage of stack for easily installing programs on demand.  It isn't hard to make this better, but there are at least 20 other improvements that aren't very hard either, which yield more value
17:17:19 <Sindriava> mgsloan: But my main issue really is that IMO `stack install X' should never fail "because package not found", that's what the resolver is for, right?
17:17:25 <bloom> oh conal
17:17:32 <conal> bloom: hey
17:17:43 <mgsloan> Sindriava: Maybe you had a typo in the name?
17:17:50 <bloom> frp... beautiful
17:17:56 <conal> :)
17:17:59 <Sindriava> mgsloan: Sorry, "dependency for X not found"
17:18:01 <mgsloan> Sindriava: It can install anything from hackage, but it might not find a workable plan
17:18:08 <Sindriava> Yeah, that's my point
17:18:12 <mgsloan> Ah right, that's because the dep isn't in stackage so you need to specify it
17:18:21 <mgsloan> Did you look at the issue I linked to? 
17:18:25 <mgsloan> It covers this _exact_ case
17:18:27 <nineonine> hey everyone
17:18:29 <Sindriava> I'm reading through it now :)
17:18:36 <nineonine> IO related question
17:18:37 <bloom> he nineonine 
17:18:42 <bloom> y
17:18:57 <nineonine> what is the easiest way to pause execution ?
17:18:58 <hjulle> eze: https://wiki.haskell.org/Literate_programming is decent
17:19:09 <lethjakman> conal: Wait...are you conal elliot? 
17:19:15 <EvanR> nineonine: you dont have a start button?
17:19:24 <conal> johnw: rather than trying to find a denotation for IO, i suggest finding more ways to move IO functionality into implementations of abstractions having precise & elegant denotations.
17:19:27 <nineonine> like print "!" >> wait 8 >> print "8 seconds passed"
17:19:32 <Enigmagic> nineonine: threadDelay
17:19:36 <Sindriava> mgsloan: Bottom line is, I'm not just here to criticise and I'd love to help. I fell in love with Haskell and I'd like to make it as easy to use and great as possible, s I'll look into making contributions to stack :)
17:19:37 <conal> lethjakman: almost! i'm conal elliott.
17:19:39 <eze> hjulle: thanks
17:19:55 <lethjakman> Whoops. 
17:20:02 <mgsloan> Sindriava: Great, I look forward to reviewing some PRs :-)
17:20:02 <bloom> ^.^
17:20:03 <conal> ;)
17:20:08 <nineonine> EvanR: no i dont :D
17:20:25 <EvanR> yeah Control.Concurrent.threadDelay
17:20:28 <bloom> unbelievable huh
17:20:31 <nineonine> Enigmagic: thanks !
17:20:40 <EvanR> and you will get more precision by using -threaded when you compile
17:20:46 <lethjakman> conal: I didn't think I'd ever catch you on here. I really enjoyed the episode of the haskell cast with you on it.
17:21:34 <conal> lethjakman: ah. thanks! i enjoyed doing that interview. and i'm around here fairly often, even if just lurking while i'm working on projects.
17:21:43 <Sindriava> mgsloan: I know that stack is pretty early in the development stage, and I'd be completely content with just hearing "Yeah, we want that to happen eventually". I think we could learn a great deal from existing ecosystems (RubyGems / NPM?) or even younger stuff (I like how Elm enforces semantic versioning)
17:21:51 <Need> Hello, i need some help! (newbie)
17:22:13 <conal> right now, i'm working on an overhaul of my haskell-to-hardware plugin for ghc.
17:22:23 <EvanR> Sindriava: having suffered through rubygems technology... and npm... im convinced its hopeless
17:22:31 <conal> ... *much* faster than the old version.
17:22:35 <lethjakman> conal: Also, thank you for your work. :) I know you've influneced a lot of things that I use these days. 
17:22:46 <EvanR> maybe we would be better off avoiding past mistakes
17:23:05 <conal> lethjakman: :D. thaks. delightful for me to hear.
17:23:06 <lethjakman> haskell-to-hardware. Would this be anything like running haskell on embedded projects?
17:23:10 <Sindriava> EvanR: Well, I did say "learn from", not "copy from" :)
17:23:17 <mgsloan> Sindriava: Yeah, there's lots of stuff we're keen on, this included!  I'm just trying to be realistic as to what's going to get implemented in the immediate term
17:23:36 <mgsloan> One thing I'm really pumped about is the potential to specify testing your package against different dependency versions
17:23:39 <mgsloan> https://github.com/commercialhaskell/stack/issues/1568
17:23:47 <Sindriava> mgsloan: Ooh, that sounds tasty
17:23:54 <mgsloan> Cabal-install generally encourages you to wait until maybe someone finds a dependency breakage
17:24:02 <mgsloan> This approach will actually test your version bounds
17:24:06 <Need> I'm trying to sort a list of tuple in descending order but when the first element of the tuple is equal, i want it in the increasing order of the second element.
17:24:55 <monochrom> oooh that's interesting
17:25:13 <Sindriava> Need: Should be fairly easy, by newtyping the tuple and implementing Ord on it?
17:25:16 <EvanR> :t sortBy . comparing snd
17:25:17 <lambdabot>     Couldn't match type ‘Ordering’ with ‘(a1, a) -> Ordering’
17:25:17 <lambdabot>     Expected type: (a1, a) -> (a1, a) -> (a1, a) -> Ordering
17:25:17 <lambdabot>       Actual type: (a1, a) -> (a1, a) -> Ordering
17:25:23 <monochrom> use Data.List.sortBy.  provide your own comparator that does what you said
17:25:37 <Sindriava> Or that ^
17:26:25 <Need> i have a failure: "sortBy not in scope"
17:26:41 <geekosaur> yes, Data.List is not imported by default
17:26:51 <Sindriava> Need: Did you `import Data.List (sortBy)` ?
17:27:04 <EvanR> :t sortBy (comparing snd)
17:27:05 <lambdabot> Ord a => [(a1, a)] -> [(a1, a)]
17:27:11 <nineonine> is it possible to use threadDelay in ghci ?
17:27:18 <EvanR> yes!
17:27:19 <mniip> to do what
17:27:27 <monochrom> yes nineonine, but you won't notice that it works
17:27:53 <monochrom> this is because ghci by default adds a "forkIO" over your request
17:27:58 <nineonine> uhmm why :)
17:28:00 <nineonine> oh
17:28:05 <Need> Sindriava: "parse error on input 'Data.list' when i write import Data.list in the shell
17:28:12 <nineonine> got it ! 
17:28:14 <EvanR> threadDelay delays the prompt reappearing for me in ghci, good enough
17:28:24 <mniip> Need, doublecheck what you wrote and what you were told to write :)
17:28:28 <EvanR> maybe because of my old version
17:28:37 <Sindriava> Need: Uhhh, by `shell' you mean Ghci, right?
17:28:43 <Sindriava> bash don't eat that stuff
17:29:08 <monochrom> use "ghci -fno-ghci-sandbox" to kill the forkIO
17:29:11 <Need> Sindriava: *facepalm* it work well! Yeah i meant Ghci
17:29:36 <nineonine> im entering ghci using cabal repl
17:29:51 <Sindriava> Need: Great :) Generally, it's good to use Hoogle for these things, it can be really useful!
17:29:57 <mniip> :set -fno-ghci-sandbox
17:30:00 <mniip> should do it
17:30:01 <monochrom> Sindriava: capital L in Data.List. is that the issue?
17:30:22 <EvanR> not using no-ghci-sandbox here...
17:30:38 <EvanR> this forkIO thing would be fascinating if it were actually happening
17:30:44 <Sindriava> Need: For example, i know I need to compare two a's, and sort a list. So I'd search for something like (a -> a -> Ordering) -> [a] -> [a]
17:31:04 <EvanR> :t comparing snd
17:31:05 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
17:31:26 <monochrom> EvanR: I see, you're probably right
17:31:28 <Sindriava> Oh hey, I even got the signature of sortBy right off
17:31:46 <monochrom> nineonine: another thing to watch out for is that threadDelay wants a huge number. its unit is 10^-6 seconds
17:31:50 <EvanR> monochrom: if it were happening that would explain the epic failure of GL
17:32:14 <Need> Sindriava: well i searched on google and came here in despair. I'm not a native English and it's kinda hard to find thought the big data of technical vocabulary
17:32:23 <EvanR> another thing to watch out for is threadDelay maxBound doesnt seem to work
17:32:38 <Sindriava> Need: https://www.haskell.org/hoogle/
17:32:55 <aeyalcinoglu> hello a quick newbee question: what is the difference between filter and takeWhile?
17:33:00 <EvanR> on either windows or linux, or its fixed now
17:33:14 <verement> EvanR: it doesn't?
17:33:20 <EvanR> i used to get an exception
17:33:30 <Need> Sindriava: oh you really meant hoogle and not google ^-^' my bad again
17:33:43 <Sindriava> Need: No prob, the name might be confusing :)
17:34:06 <Clint> aeyalcinoglu: what do you think that filter does?
17:34:10 <EvanR> https://ghc.haskell.org/trac/ghc/ticket/7325
17:34:18 <Sindriava> aeyalcinoglu: takeWhile stops on the first element that doesn't satisfy the predicate.
17:34:36 <aeyalcinoglu> Sindriava: thank you very much!
17:34:39 <Sindriava> > takeWhile (> 2) [3, 2, 1, 2, 3]
17:34:40 <lambdabot>  [3]
17:34:52 <Sindriava> > filter (> 2) [3, 2, 1, 2, 3]
17:34:54 <lambdabot>  [3,3]
17:34:55 <EvanR> theres several of these bugs it seems, mostly fixed
17:35:18 <Need> Sindriava: what is the ordering type? What does it wait?
17:35:40 <EvanR> @src Ordering
17:35:40 <lambdabot> data Ordering = LT | EQ | GT
17:35:55 <Sindriava> Need: http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#t:Ordering
17:36:30 <Sindriava> Need: Ordering is a predefined datatype that describes the three situations that can occur when comparing elements in a totally ordered set
17:36:44 <Sindriava> Need: (e.g. not having incomparable elements)
17:36:57 <Need> yeah i understood that on your link ^^
17:37:13 <charco> Hi!
17:37:48 <nineonine> basically what I am doing is checking the endpoints and trying to parse the responses. The JSON I am receiving is very inconsistent and often lacks some fields. I have my data type where I tried to consider all the possible fields for particular responses. It sometimes fails however to parse the responce because it doesn't have some fields. I am trying to test it in ghci doing something like that ( forM [1..100] $ \n -> print n >> 
17:37:48 <nineonine> runRequest n >> threadDelay 4000 ) but due to rateLimit it fails
17:37:49 <Sindriava> Need: sortBy wants a comparator (a function, that compares two elements of the same type, e.g. a -> a -> Ordering), and sorts the list based on that
17:37:57 <nineonine> should I jsut write unit test for that ?
17:38:04 <charco> Quick question: I want to get the contents of a file, but when I do result <- hGetContent and then hClose, I lose the result :(
17:38:23 <Need> Sindriava: So if i want a list sort like that "[(5 ; 4) ; (7 ; 4) ; (3 ; 3) ; (4 ; 3) ; (1 ; 2) ; (6 ; 1) ; (2 ; 0)]" i have to sort the snd of the tupple and then sort the fst?
17:38:40 <nineonine> i mean i have to use threadDelay due to rateLimit
17:38:42 <EvanR> nineonine: heh... if you make all the fields Maybe would that help? ;)
17:38:58 <nineonine> haha i was considering that :)
17:38:58 <Sindriava> Need: If you want to sort by the first element and then the second element, you can do this:
17:38:59 <EvanR> then you can write more code to crash when theyre all missing
17:39:01 <dmj`> charco: withFile "filename" ReadMode $ \handle -> ...
17:39:06 <nineonine> looks like its the best solution for me
17:39:21 <EvanR> usually you need at least something to make it through
17:39:53 <monochrom> dmj`: withFile is even worse. it adds a hClose for you
17:40:02 <monochrom> charco: simply don't hClose.
17:40:03 <Sindriava> Need: mycompare (a1, b1) (a2, b2) = let c1 = compare a1 a2; c2 = compare a2 b2 in (if c1 == EQ then c2 else c1)
17:40:23 <Sindriava> Need: It could probably be a bit nicer, but this demonstrates what the codes does pretty nicely
17:40:40 <EvanR> Ordering is a monoid!
17:40:49 <Sindriava> Oh really! Neato
17:41:12 <EvanR> > LT <> GT <> GT
17:41:13 <lambdabot>  LT
17:41:20 <EvanR> > EQ <> EQ <> GT
17:41:21 <lambdabot>  GT
17:41:22 <dmj`> monochrom: in the presence of an exception, yes.
17:41:28 <charco> monochrom, the problem is that I have to open ~1000 files, and I don't want to have 1000 files open
17:41:47 <monochrom> then probably you don't want to use hGetContent
17:41:49 <charco> (mostly because haskell tells me that it can't have that many files open)
17:42:01 <monochrom> dmj`: no, not just that.
17:42:01 <Need> Sindriava: I'll try that! thanks and thanks EvanR to!
17:42:03 <charco> monochrom, what can I do to get the contents of a file?
17:42:16 <charco> readFile?
17:42:33 <Axman6> charco: read it in as a strict bytestring, if you can keep it all in memory (which it sounds like you have to)
17:42:36 <monochrom> readFile is simply openFile-hGetContents
17:42:39 <Sindriava> EvanR: That is really useful, thanks
17:42:43 <Cale> Not only is Ordering a Monoid, but for any type e, we have that e -> e -> Ordering is a Monoid which does pretty much what you'd expect
17:42:54 <Sindriava> > GT <> LT
17:42:54 <monochrom> you will likely have to use hGetChar, hGetLine, hGetBuf etc
17:42:55 <lambdabot>  GT
17:43:02 <charco> ugh
17:43:24 <Sindriava> > :t compare
17:43:26 <lambdabot>  <hint>:1:1: parse error on input ‘:’
17:43:26 <charco> Axman6, yes, I have to keep all the information in memory.
17:43:29 <monochrom> and if you say there are libraries such as "pipes" and "conduit" for that, yes they are good options
17:43:29 <Sindriava> :t compare
17:43:30 <lambdabot> Ord a => a -> a -> Ordering
17:43:33 <Cale> i.e. take the result of the first function -- if it's anything but EQ, that's the result of your comparison, but if it is EQ, take the result according to the second function.
17:43:36 <dmj`> monochrom: yes, you're right,
17:43:38 <Sindriava> > compare <> compare
17:43:40 <lambdabot>  <() -> () -> Ordering>
17:43:49 <Sindriava> whaaaa
17:44:01 <Cale> > sortBy (comparing length <> compare) (words "here is a list of words to sort first by length and then alphabetically")
17:44:02 <lambdabot>  ["a","by","is","of","to","and","here","list","sort","then","first","words","...
17:44:07 <Axman6> that's really Ord a => a -> a -> Ordering
17:44:09 <geekosaur> ExtendedDefaultRules, ain't it fun?
17:44:13 <Axman6> it's just defaulting
17:44:29 <Axman6> :t comparing fst <> comparing snd
17:44:30 <lambdabot> (Ord a, Ord a1) => (a1, a) -> (a1, a) -> Ordering
17:44:37 <nineonine> alright I still want to try make threadDelay work in ghci 8-) could you please remind me what should I do for that ? (im using cabal repl)
17:44:50 <EvanR> nineonine: did you just try it?
17:44:58 <nineonine> nothing happens
17:45:04 <EvanR> did you use the number 1 million
17:45:05 <Cale> nineonine: Use a larger number
17:45:08 <monochrom> threadDelay 10000000
17:45:16 <monochrom> (10 million)
17:45:29 <Need> Sindriava: When i cut my list with (x:xs) can i compare (fst x,snd x) with (fst (fst xs),snd (fst xs)) ? it seems realy ugly to me
17:45:39 <monochrom> you know what, "nothing happens for 10 seconds" is a good thing
17:45:39 <Axman6> charco: your other option is to ensure that all the data is read, by doing something like readFile "foo.txt: >>= \foo -> let !_ = length foo in ...
17:45:49 <EvanR> Need: ((l,r):xs) ?
17:45:53 <Cale> nineonine: It's measured in microseconds.
17:46:14 <charco> Axman6, yes, I need the whle contents of the file
17:46:21 <nineonine> it worked 8)
17:46:23 <Axman6> :t foldr (<>) (comparing fst <> comparing snd)
17:46:24 <lambdabot> (Ord a, Ord a1, Foldable t) => t ((a1, a) -> (a1, a) -> Ordering) -> (a1, a) -> (a1, a) -> Ordering
17:46:25 <monochrom> ok good
17:46:33 <Cale> It kind of bothers me that it's threadDelay :: Int -> IO () and not threadDelay :: NominalDiffTime -> IO ()
17:46:35 <nineonine> thanks !
17:46:36 <Need> EvanR: it's a list of tuple
17:46:55 <Cale> But I guess putting time in a place which would allow that would be annoying.
17:47:09 <EvanR> indeed they are both base 10
17:47:14 <Sindriava> Need: xs is a list, not a tuple. fst doesn't work on it ;)
17:47:16 <EvanR> NominalDiffTime is a Pico
17:47:29 <Need> meh ._.
17:47:36 <Sindriava> :t fst
17:47:37 <lambdabot> (a, b) -> a
17:47:56 <EvanR> instead of fst snd, use pattern matching to break open a pair
17:48:09 <Sindriava> Need: Why are you cutting the list? You don't need to work with the list, sortBy does it for you ^^
17:48:27 <Cale> EvanR: yeah, and making this change would quietly break lots of stuff by making it take a million times longer
17:48:40 <EvanR> yep
17:48:56 <monochrom> um, shorter, not longer?
17:49:02 <Cale> because NominalDiffTime is measured in seconds (but allows fractions)
17:49:10 <monochrom> oh, oops
17:49:24 <EvanR> you can have a different delay function 
17:49:26 <Need> Sindriava: i don't understand how sortBy work with a list of tuple ^-^''
17:49:34 <Cale> So threadDelay 1000000 would suddenly mean a million seconds, with the numeric literal being interpreted as NominalDiffTime
17:49:40 <Cale> EvanR: for sure
17:49:41 <Sindriava> Need: Look at the definition of sortBy:
17:49:49 <Sindriava> :t Data.List.sortBy
17:49:50 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
17:50:11 <monochrom> sortBy (\(a,b) (x,y) -> compare x a <> compare b y)
17:50:39 <Sindriava> Need: sortBy doesn't care what you're sorting, as far as sortBy cares it's just marbles.
17:51:03 <monochrom> it's "compare x a" for descending according to first component. when there is a tie, it's "compare b y" for ascending according to second component
17:51:10 <Sindriava> Need: But it doesn't know how to compare them (do you compare marbles by weight? color? number on it? sortBy don't know ¯\_(ツ)_/¯)
17:51:54 <Sindriava> Need: So you just tell it "Hey, this is how you compare two values of the type `a', see?" and it does the sorting for you, because it only need to know how to compare them to sort them.
17:52:12 <Sindriava> "Hey, this one is larger according to the compare function! It goes to the end!"
17:53:51 <Need> Sindriava: so if i call my list of tuple "x", i have to write sortBy (the condition , x)?
17:54:24 <Sindriava> Need: No, you'll write `sortBy myCompare myListOfTuples'
17:54:31 <Sindriava> Need: where myCompare is something like:
17:54:52 <Sindriava> myCompare (a, b) (x, y) = compare a x <> compare b y
17:55:01 <Sindriava> and myListOfTuples is something like:
17:55:24 <Sindriava> myListOfTuples = [(1, 'a'), (2, 'b'), (3, 'c')]
17:55:37 <Sindriava> > let myCompare (a, b) (x, y) = compare a x <> compare b y
17:55:38 <lambdabot>  <no location info>:
17:55:39 <lambdabot>      not an expression: ‘let myCompare (a, b) (x, y) = compare a x <> compare...
17:55:50 <Sindriava> > myCompare (a, b) (x, y) = compare a x <> compare b y
17:55:51 <lambdabot>  <hint>:1:25: parse error on input ‘=’
17:56:19 <charco> Axman6, I see. You are using length so it can read the whole file. ( I don't understand what the !_ is for), how can I do something similar inside a do... ?
17:56:23 <Sindriava> Eh, I can't remember how to make lambdabot remember bindings (the irony!)
17:56:28 <charco> like _ <- length results
17:57:35 <Sindriava> Haha, I like ` !_ '
17:57:47 <Sindriava> "Discard this value, and discard it NOW!"
17:57:58 <EvanR> we need a _!_
17:58:10 <charco> But when I do !_ <- length results I get errors :(
17:58:12 <EvanR> extra hazardous _|_
17:58:37 <Sindriava> EvanR: It should beep the PC Speaker when parsed
17:59:52 <Axman6> charco: let !_ = length foo
17:59:56 <Axman6> inside the do
18:00:38 <charco>  Illegal bang-pattern (use BangPatterns):
18:00:56 <Sindriava> charco: Have you tried using BangPatterns?
18:01:00 <Axman6> add {-# LANGUAGE BangPatterns #-} to the very top of your file
18:01:02 <Need> Sindriava: i really fail to understand... In python i would finished it in 2 second by i don't get it in Haskell xD
18:01:19 <charco> oh I see. It's a feature that I have to add! :P
18:01:24 <charco> It's not part of haskell2010?
18:01:26 <EvanR> haskell is quite different from python and python-like things
18:01:38 <Axman6> charco: no
18:01:46 <Sindriava> Need: It's okay, it takes some time for Haskell to click in your brain :)
18:02:29 <bloom_> _!?
18:02:31 <bloom_> _
18:02:33 <bloom_> :o
18:02:36 <bloom_> warning signals
18:02:42 <bloom_> meh
18:03:08 <Need> i have to write "let myCompareName (a, b) (x, y) = compare a x <> compare b y" and in the line after "sortBy myCompareName myListOfTuple" ?
18:04:05 <Axman6> any reason you're using the build in implementation of compare for tuples?
18:04:05 <charco> I don't really like that I have to add all these stuff. It looks like I'm doing something wrong :(
18:04:36 <Axman6> charco: maybe you are, if you share more information about what you're trying to achieve we might be able to give better tips
18:05:00 <charco> I have to apply some functions to the contents of several files.
18:05:34 <Axman6> can you be a bit more specific? you've basically described any program which opens a file :P
18:06:15 <charco> Sorry
18:06:47 <Need> Axman6: well i want to sort my list of tuples in decreasing order for the snd of the tuple and if there is 2 same snd, i want it in ascending order of the fst
18:07:26 <Axman6> Also, don't feel bad, lazy IO is something that is generally looked upon as a bad thing, and haskellers have spent a lot of time building systems which provide better alternatives
18:07:29 <Need> Axman6: like that [(5 ; 4) ; (7 ; 4) ; (3 ; 3) ; (4 ; 3) ; (1 ; 2) ; (6 ; 1) ; (2 ; 0)]
18:07:46 <Axman6> s/;/,
18:08:07 <charco> I have to work on a tuple of (tags, fileContents), and I have functions that work over that, iterating over the fileContents
18:09:12 <charco> For example, calculating the amount of words in each file and the average words per file
18:09:30 <Axman6> Need: so, you want something like: myCompare = comparing snd <> flip (comparing fst)
18:10:34 <Axman6> > let myCompare = comparing snd <> flip (comparing fst) in sortBy myCompare [(5 , 4) , (7 , 4) , (3 , 3) , (4 , 3) , (1 , 2) , (6 , 1) , (2 , 0)]
18:10:36 <lambdabot>  [(2,0),(6,1),(1,2),(4,3),(3,3),(7,4),(5,4)]
18:10:56 <Axman6> > let myCompare =flip ( comparing snd) <> comparing fst in sortBy myCompare [(5 , 4) , (7 , 4) , (3 , 3) , (4 , 3) , (1 , 2) , (6 , 1) , (2 , 0)]
18:10:58 <lambdabot>  [(5,4),(7,4),(3,3),(4,3),(1,2),(6,1),(2,0)]
18:11:03 <Need> Axman6: yes but i don't get the syntaxe to use sortBy, i have to write "let myCompare blabla" on a line and the line after "sortBy myCompare myListOfTuple"?
18:11:33 <Axman6> Need: are you working in a file or ghci?
18:11:34 <charco> Axman6, so I don't know if it is possible to move all the code inside the openFile and the closeFIle, I think it is better to load all the files in memory.
18:11:48 <Need> Axman6: on a file that i load in ghci
18:12:25 <Axman6> Need: well, you can define myCompare in that file, and then use it inside main. without seeing your file I can't help more
18:12:31 <Axman6> also, it's lunch time
18:13:09 <xa0> :t (:<)
18:13:10 <lambdabot>     Not in scope: data constructor ‘:<’
18:13:10 <lambdabot>     Perhaps you meant one of these:
18:13:10 <lambdabot>       ‘Seq.:<’ (imported from Data.Sequence),
18:15:03 <Need> when i write "let var = xxx" i have a parsing error
18:17:01 <monochrom> in where?
18:17:16 <Need> in my file
18:17:26 <Need> when i load it on ghci
18:17:31 <monochrom> yeah, in a file you delete "let "
18:19:40 <zRecursive> How to make cabal use "~/.cabal/config" not "c:/z\Application Data\cabal\config" ?  
18:20:05 <monochrom> perhaps boot linux? I don't know :)
18:20:39 <blume> ugh windows
18:20:43 <zRecursive> I guess the space between Application and Data will cause some problem ? At least, it is NOT so convenient.
18:20:48 <blume> those paths just looks so ... wrong xD
18:21:01 <EvanR> no more bashing windows
18:21:01 <blume> look*
18:21:06 <blume> ok sry
18:21:06 <hjulle> cygwin?
18:21:11 <zRecursive> yeah
18:21:19 <blume> hope windows wasnt hurt personally
18:21:49 <blume> phew;;;
18:21:59 <blume> :i 
18:22:01 <blume> :i id
18:22:04 <blume> :t id
18:22:05 <lambdabot> a -> a
18:22:10 <blume> lambdabot: 
18:22:25 <Need> myCompare = ( comparing snd) <> (comparing fst) in sortBy myCompare [(5 , 4) , (7 , 4)]. What i have to write in "comparing snd" and "comparing fst" ?
18:22:37 <monochrom> if you're entering the path manually at the command prompt, %appdata%\cabal\config should work.
18:23:01 <monochrom> in other contexts, paths with spaces should not hurt, Windows itself uses a lot of such paths already
18:23:48 <blume> i tried installing remix OS
18:23:50 <blume> but then again
18:23:55 <blume> android and haskell...
18:24:00 <blume> what about RNN and haskell?
18:24:10 <blume> like /r/deepdream
18:24:15 <EvanR> kind of a weird question, if you have a function foo :: Foo b => a -> b -> X, then if the Foo b is like an implicit parameter, how does partial application work? i.e. foo A :: Foo b => b -> X. it seems like its applying arguments out of order
18:24:41 <zRecursive> monochrom: i am trying `cabal --config-file=c:/z/.cabal/config update` noww
18:24:58 <monochrom> ah, I forgot about that
18:25:21 <lyxia> EvanR: imagine there are implicit flips
18:25:47 <hjulle> Need: I do not understand the question.
18:26:11 <EvanR> what if its a multiparameter type class?
18:26:37 <lyxia> How is that relevant?
18:26:58 <monochrom> Need: both "comparing" and "fst", "snd" are already provided by Prelude. you don't implement them. you use them.
18:27:00 <EvanR> i assume you mean the constraint parameter will be flipped ahead, closer to where the variable is
18:27:48 <EvanR> so i guess if it involved `a', it would be filled in by that point... Foo A b => b -> X
18:28:05 <lyxia> in a way foo A gets desugared to \ dict_Foo_b -> foo dict_Foo_B A
18:29:00 <Need> can you copy/paste on ghci?
18:29:04 <EvanR> funny that this happens it never comes up in here
18:29:37 <lyxia> EvanR: this doesn't do anything
18:29:50 <EvanR> so is this desugaring done prior to the partialling
18:29:52 <lyxia> EvanR: it's like writing id' = id :: Int -> Int
18:29:55 <hjulle> Need: Yes.
18:29:59 <MarcelineVQ> monochrom: for posterity I think comparing is from Data.Ord
18:30:15 <monochrom> Need: depends on what you paste. paste legal stuff only.
18:30:27 <monochrom> I mean don't paste syntax errors
18:30:30 <Need> hjulle: can you tell me how? ^^' Ctrl+C / Ctrl + V doen't work for me
18:30:38 <lyxia> EvanR: just specializing a type variable has no direct consequence at runtime
18:30:51 <EvanR> the order of arguments is what im interested in
18:30:51 <hjulle> Need: On windows?
18:30:52 <monochrom> oh, that depends on whether it's Windows or Linux or ...
18:30:57 <Need> hjulle: yes
18:31:03 <Need> windows
18:31:27 <hjulle> I think you can right-click and paste from the menu
18:31:37 <monochrom> there is a left-top corner thing that you can click, it will show you a menu, there is an "edit" somewhere, and then there is "paste" somewhere inside
18:33:22 <EvanR> lyxia: so in some sense are all dict arguments moved all the way to the end of the chain of -> ?
18:34:22 <lyxia> I don't think that's right
18:34:43 <EvanR> so partial application has this effect of rearranging via lambdas
18:35:45 <mgsloan> EvanR: Constraints are just satisfied when they are satisfied, it doesn't really matter where they are satisfied.  It does matter for implicit parameters, but the rule there is simple: they're provided where the function is referenced
18:35:46 <lyxia> My mental model is that everytime you have an expression e :: Constraints => SomeType, it gets desugared to \ (c :: Constraints) -> e', where e' is obtained from e by passing the c argument around
18:36:19 <lyxia> I can't say how that's actually done in GHC though
18:37:12 <mgsloan> Yes, it looks like that when it makes it to "core"
18:37:16 <mgsloan> explicit passing of dicts
18:39:29 <Need> EvanR: can i use sortBy in a file?
18:39:40 <EvanR> in a source file yes
18:40:00 <Need> EvanR: i have to import Data.List in the file before ?
18:40:08 <hjulle> Yes
18:40:56 <hjulle> And Data.Ord for comparing
18:41:05 <Need> Hum... I have multiple errors when i write import Data.List at the start of my file
18:41:21 <EvanR> maybe you should check out a basic guide on haskell syntax
18:42:16 <Need> it's not the same syntax on ghci and file?
18:42:30 <hjulle> Not exactly
18:42:41 <EvanR> well, if you need explicit help you have to tell us what the error message is
18:42:57 <EvanR> but you might not need explicit help after reading a basic guide on haskell syntax
18:46:10 <dilinger> newinst
18:46:27 <dilinger> whoops, wrong window
18:47:09 <icicled> anyone know what happened to the supposed recurring "Ask /r/haskell" thread?
18:49:02 <icicled> nvm
18:56:09 <EvanR> nice... wikipedia calls pi types dependent products, this paper calls sigma dependent products
18:56:32 <EvanR> i feel like i dont know what to call them
18:56:52 <Cale> haha
18:57:24 <Cale> EvanR: you understand why there's confusion though, right?
18:57:30 <EvanR> no
18:57:34 <Cale> oh, okay
18:57:53 <Cale> So, the elements of pi types look like functions
18:57:55 <monochrom> there is no satisfactory terminology. Sigma talks about pairs, too, so saying "product" could be right
18:58:05 <EvanR> sigma looks like a pair
18:58:08 <Cale> yeah
18:58:17 <EvanR> how is pi a product
18:58:41 <EvanR> (also sigma is referred to as a sum on wikipedia)
18:58:46 <Cale> But the notation Pi is chosen to make you think of Pi (x:A), B(x) like the Cartesian product over elements x in A, of the sets B(x)
18:59:13 <EvanR> ok
18:59:14 <Cale> i.e. it's like an *iterated* product over all the elements in A
18:59:17 <monochrom> yeah, the thing is Pi has an aspect that feels product, and Sigma has an aspect that feels sum.
18:59:38 <monochrom> it's all mixed up and you should give up on dependent types :)
18:59:39 <Cale> Sigma (x:A), B(x) is like the disjoint union of all the B(x)
18:59:57 <Cale> i.e. it's an iterated sum
19:00:24 <monochrom> I took the alternative. I gave up on meaningful names.
19:00:53 <Cale> So if you're thinking about what they do at the type level, Sigma looks like a sum, Pi looks like a product. At the term level, Sigma looks like a product, and Pi looks like an exponential.
19:01:11 <monochrom> if you say "Monad m => a -> m a" is called "return", and Pi is called "product", I'll just memorize them and move on.
19:01:43 <EvanR> so pi is an indexed family of types
19:01:53 <EvanR> but... its also a function?
19:02:14 <Cale> Well, Pi and Sigma both act on an indexed family of types in order to produce a type
19:02:24 <Cale> Here, B: A -> Type
19:03:07 <EvanR> wait, B is taking a value of type A?
19:03:16 <Cale> If  f: Pi (x:A), B(x)  that means f is a function which when given some x in A, will produce an element in B(x).
19:03:17 <Cale> yes
19:03:31 <EvanR> so its indexed by values of a single type
19:03:33 <Cale> That's where the whole dependent type thing comes in
19:03:44 <Cale> B(x) is a type which depends on a value x
19:03:48 <EvanR> and sum is being tagged by values of a single type
19:03:58 <Cale> yeah
19:04:03 <EvanR> ok
19:04:49 <Cale> The first part of a pair in Sigma (x:A), B(x) is an element x of A, and the second part has type B(x) (i.e. its type depends on the value of the first part)
19:05:04 <EvanR> in Pi (x:A), B(x) notation (the point me looking this stuff up)... x is the value or the type?
19:05:26 <EvanR> if its the type, i was trying to lookup better notation...
19:05:38 <EvanR> because normally x:A x is a value 
19:05:41 <EvanR> of type A
19:06:00 <Cale> x:A means that x has type A
19:06:25 <EvanR> yes when encountered alone
19:06:46 <Cale> If f: Pi (x:A), B(x), then f is a function which when given an element x of type A, produces a result f x of type B(x).
19:07:17 <Cale> (the type of the result of f depends on the value of its argument)
19:07:51 <EvanR> alright
19:08:05 <Cale> So you can think of such a function f as being a giant (perhaps infinite) tuple, which has a component for each x in A, and the function tells you what each component is.
19:08:06 <monochrom> EvanR: Suppose I want to say my function f does this: f's domain is {0,1}, but the codomain varies. f(0) = 'x' :: Char but f(1) = () :: ().  Then we're looking at: f :: Pi (x:{0,1}) (if x==0 then Char else ())
19:08:08 <EvanR> so this : notation means pretty much the same as : at the top level
19:08:12 <Cale> yep
19:09:02 <Cale> Now, if p : Sigma (x:A), B(x), then fst p : A, and snd p : B(fst p)
19:09:10 <EvanR> monochrom: er, this is well typed?
19:09:38 <monochrom> yes, provided Char and () are available
19:09:45 <Cale> and you can think of this as being a disjoint union of the B(x), with the first component of the pair telling you which part of the disjoint union you're in
19:09:46 <lyxia> welcome to dependent types
19:09:47 <monochrom> oh, and {0,1} is available
19:10:10 <Cale> Or, to put it another way, consider what happens when A = Bool in each case
19:10:57 <Cale> Pi (x:Bool), B(x) is basically the same thing as the product type B(False) * B(True)
19:11:14 <Cale> Or what we'd call in Haskell notation (B False, B True)
19:11:27 <EvanR> is that what the product is referring to?
19:11:30 <EvanR> a giant tuple?
19:11:31 <Cale> (though confusing pairs and products is not a road we want to go down)
19:11:32 <Cale> yeah
19:11:40 * EvanR facepalm
19:11:56 <EvanR> thats silly
19:12:04 <Cale> while Sigma (x:Bool), B(x) is basically the same thing as Either (B False) (B True)
19:12:06 <monochrom> this is not giant yet. but Pi (x:{0,1,2,...}) B(x) is.
19:12:17 <EvanR> yes, or uncountable number of compnents
19:12:20 <Cale> Well, with Bool, it's not giant at all :)
19:12:28 <EvanR> not my favorite characterization of functions
19:13:33 <EvanR> ok so im never referring to pi as product again... its a function
19:14:10 <monochrom> Ironically, the axioms of choice is an example of when you really like to identify a dependent function with a giant cartesian product (because both perspectives gives you good but different intuitions)
19:14:34 <EvanR> yes that stuff gives me the creeps
19:14:41 <monochrom> But the irony is that with dependent types you usually also reject the axiom of choice
19:15:20 <EvanR> is there a way to encode typeclasses with pi types?
19:17:40 <monochrom> in the April Toronto Haskell meetup I'm going to bring up the axiom of choice as a great example of wanting to use Pi to its fullest, to add salt to the irony.
19:18:13 <monochrom> (because we plan to look at Martin-Löf part II then)
19:18:38 <monochrom> and we have assigned someone to kidnap Cale to that meetup, too :)
19:18:47 <Cale> haha
19:18:54 <Cale> Yeah, I wanted to make it to the last one
19:19:01 <Cale> But there was no way to get home after
19:19:23 <Cale> No trains or buses headed the other direction that late
19:23:07 <monochrom> I think you simply convert a type class to a record of methods. so you just need tuples and functions. it is not always dependent. but if you add dependency, you obtain a horrible vision of dependent type class
19:23:31 <EvanR> haha
19:24:17 <EvanR> wikipedias list of dependent types languages includes perl 6
19:24:20 <EvanR> now...
19:24:39 <EvanR> how did they pull that off
19:24:48 <Cale> Perl 6: Approximately lots of stuff
19:24:59 <geekosaur> `where` trait
19:25:03 <Adeon> I thought perl 5 wasn't ready yet
19:25:32 <geekosaur> perl 6.c was released 2015 Dec 25
19:25:33 <Adeon> I guess I haven't seen perl in a while
19:31:09 <dmj`> did 'Unbox' replace 'Prim' in vector for constraining types stored in unboxed vectors
19:31:22 <EvanR> Cale: i think i know where im getting confused, in the notation (x:A) -> x -> B x, the first argument is not x, its A, and the second argument is not x, its a type error
19:31:37 <EvanR> even though both are `x' just one has an annotation
19:31:44 <Cale> Well, unless A is a type of types
19:32:00 <Cale> in which case, it might not be a type error to write that
19:32:02 <Cale> But otherwise, yeah
19:32:08 <EvanR> well if A is a type universe, then its well typed and even more confusing
19:32:26 <EvanR> the first argument is "an A" and the second argument is "an x"
19:33:02 <EvanR> so its not just an annotation
19:35:21 <lyxia> dmj`: it's not simply a replacement, the main point is the representation of vectors of pairs I think.
19:37:09 <koz_> What's the recommended library for interfacing a Haskell program with SQLite?
19:38:47 <osa1> can anyone tell me some packages that take very long to compile because of its own compile times? (e.g. times spent for dependencies don't count)
19:40:16 <monochrom> text
19:40:24 <monochrom> I think Cabal too
19:40:26 <Adeon> koz_: I would probably go with sqlite-simple
19:40:45 <koz_> Adeon: OK, I'll investigate. Thank you!
19:40:52 <Adeon> koz_: it makes you write raw SQL but has some features to avoid sql injection and stuff
19:41:00 <Adeon> so if you are looking for something higher level might need to look for something else
19:41:02 <osa1> monochrom: thanks, noted
19:41:21 <osa1> monochrom: feel free to send more packages ^_^
19:41:42 <lyxia> osa1: lens?
19:41:53 <osa1> lyxia: I thought it's taking too long becuase of dependencies?
19:41:59 <Adeon> gl maybe
19:42:14 <Adeon> gl has lots of modules
19:42:19 <osa1> Adeon: right, thanks
19:42:32 <monochrom> hxt
19:42:43 <geekosaur> xmonad-contrib because 200+ modules >.>
19:42:54 <monochrom> actually I no longer remember which one took longer, text or hxt
19:43:12 <osa1> alright I already have 5 packages. thanks all.
19:43:32 <osa1> text, Cabal, gl, hxt, xmonad-contrib
19:44:01 <lyxia> osa1: lens itself still takes a minute apparently
19:44:56 <osa1> lyxia: actually it may be a good candidate for my benchmarks becuase it has some template-haskell stuff. I'm going add that to the list too.
19:45:07 <geekosaur> sure, the expensive parts are TH splicing and type inference in *users* of lens >.>
19:48:51 <lyxia> osa1: vector
19:49:05 <monochrom> ooohhh, so we just need xmonad-contribs-lens...
19:49:50 <geekosaur> someone in #xmonad threatens to redo xmonad in terms of lens every so often...
19:49:57 <osa1> lyxia: noted, ty
19:50:49 * geekosaur still grumpy about Data.Default. maybe if the lens-y config makes it go away again...)
19:51:48 <Ashy> osa1: are you benchmarking ghc performance?
19:51:52 <osa1> Ashy: yes sir
19:53:06 <osa1> hxt: https://gist.github.com/osa1/4e14aa21d1473a02ac12
19:57:37 <monochrom> heh, Text.XML.HXT.Arrow.XmlArrow is pretty challenging, memory-wise of not time-wise
19:58:10 <monochrom> but the rest seems pretty run-of-the-mill, apart from just having many modules
20:00:00 <osa1> text: https://gist.github.com/osa1/cdd67d4958f452831004
20:00:15 <osa1> Data.Text.Lazy.Builder.RealFloat is a good one
20:01:16 <osa1> haskell-src-exts https://gist.github.com/osa1/6afbc7cea6ca8af558ba
20:01:37 <osa1> I'd expect Language.Haskell.Exts.Annotated to take a lot of time because of all the generated code
20:01:53 <osa1> but it seems like Language.Haskell.Exts.InternalParser is taking all the time
20:06:09 <codygman> What is a better way to write this code that is essentially filtering and getting values out of a Either a MyType { myvalues = [AMemberOfSumType]}? code here: http://lpaste.net/157376
20:06:14 <osa1> gl is slow becuase if has lots of modules https://gist.githubusercontent.com/osa1/ec24867fa8b1e65e26ab/raw/f9813b981f0ad0fbc3dfa5c1819f186c7574c1d0/gistfile1.txt Graphics.GL.Internal.FFI is taking 5 seconds but other than that it's just compiling lots of modules
20:06:22 <Ashy> osa1: so CodeGen is the big section for everything by the looks
20:06:48 <osa1> Ashy: yeah that's surprising to me
20:07:43 <osa1> Ashy: note that current timings are not detailed enough. for example, I don't know where STG-to-STG passes are, it's probably in the CodeGen part although it probably shouldn't
20:08:02 <osa1> Ashy: basically CodeGen has many steps in it that need to be separated
20:08:16 <java_pro> hey
20:08:31 <Ashy> can you finer grained profiling data with the current ghc?
20:08:36 <Ashy> can you get*
20:08:39 <montanonic> codygman: first off, unless you plan on expanding 'A', make 'A' a newtype, which eliminates any runtime penalty for using a datatype
20:08:50 <monochrom> perhaps CodeGen uses an inefficent data structure, e.g., []
20:08:58 <osa1> Ashy: this is as best as you get with HEAD atm but I'm going to make those more detailed hopefully tomorrow or sometime this week
20:08:59 <java_pro> is there a way to use "where" clauses in a record assignment?
20:08:59 <montanonic> codygman: you can make it a `newtype` because its constructor has only one field; it is not a sum type
20:09:01 <thoughtpolice> osa1: Glad to see you doing a lot of profiling of packages in the wild!
20:09:18 <osa1> thoughtpolice: I just started actually :) thanks to bgamari's patch
20:09:51 <thoughtpolice> I know. Thank you either way, that's the stuff we need (bgamari and I have 10 trillion billion other things to do, so stuff like that is really valuable).
20:11:10 <Ashy> wish i could help more, ive pinged ggVGc in the hopes that he has time to help out too
20:11:13 <thoughtpolice> osa1: I think CodeGen can be split up a bit, FWIW. There are a few different phases but Ben's patch didn't handle them (for example regalloc vs pretty printing, etc). Are you planning on doing that when you mean 'more detailed' info?
20:11:25 <thoughtpolice> Or just stuff like core2core?
20:11:27 <Ashy> would be great you find some low hanging fruit and give ghc a 20-30% speed boost
20:11:39 <java_pro> I want to be able to do something like: Foo { x = y where y = 4 }
20:12:01 <codygman> montanonic: Alright, thanks. I still am not sure if that's a great way to do the task I'm doing.
20:12:10 <montanonic> codygman: secondly, you can use the 'filter' function to clean up your code in 'takeFirstC' (which should have a different name, by the way)
20:12:22 <osa1> thoughtpolice: yes, I actually wanted a more structured timing output, for things like individual Core-to-Core passes. I'll definitely split CodeGen into smaller steps also.
20:12:40 <geekosaur> java_pro, no
20:12:47 <osa1> Ashy: yeah that'd be really awesome. like when you add a `seq` and make your program 10x more memory efficient :p
20:12:59 <geekosaur> (a) where clauses are part of declaration syntax, not arbitrary expressions (b) record updates are even more limited
20:13:26 <montanonic> codygman: well, what are you trying to do? you're using a pretty complicated data type, you sure that you can't turn this whole thing into an `Either String (Map String String)` ?
20:14:27 <lyxia> java_pro: use let
20:14:52 <montanonic> codygman: your datatype is just saying that you have a Thing which is either a name, or a key-value mapping; how is that not just the type I wrote above?
20:15:02 <thoughtpolice> osa1: Hmmm, maybe I should try your script to get some benchmarks on binary vs binary-serialise-cbor...
20:15:40 <thoughtpolice> (FWIW, binary-serialise-cbor probably isn't a good test case because it's so much better! It generates a lot less code. binary can generate some large instances relatively speaking.)
20:15:52 <java_pro> geekosaur lyxia thanks
20:16:00 <Ashy> osa1: yeah haha, i'd also love it if stack had a binary cache for packages somewhere too so i didnt have to burn my macbook into oblivion when i update to a newer stack snapshot...
20:16:14 <Ashy> though maybe that's a feature that belongs in nix?
20:17:03 <osa1> Ashy: I hear Cabal's getting some nix-like features, maybe that could be possible with Cabal in the future? I don't follow Cabal developments too closely though
20:17:36 <Ashy> me either, i only want to know about stack these days...
20:17:48 <montanonic> codygman: also, it doesn't seem like you actually need the A constructor at all, if I'm not mistaken. [Maybe Thing] should suffice
20:17:53 <codygman> montanonic: It mirrors a problem I had for work. The examples sum types can be collapsed into an Either String (Map String String) but the real example cannot.
20:18:06 <codygman> I'll try to make a better example later
20:18:59 <thoughtpolice> It depends on what you mean by 'binary cache'. If you mean "Do not compile things that do not need to be recompiled on my machine", then that could be done by Stack or Cabal with 'nix features' (the nix feature branch basically accomplishes this already quite nicely).
20:19:28 <osa1> I think he meant an online cache e.g. a repo of binaries
20:19:35 <thoughtpolice> If you mean "Download binaries off the internet as needed", that probably does not belong in either tool, IMO.
20:20:20 <montanonic> codygman: okay, that might help, since knowing which datatypes best express a problem is important in solving it efficiently and cleanly. Good luck
20:20:30 <thoughtpolice> (Mostly because it's tedious to get right beyond the easy stuff I imagine, and yes, you would basically end up reinventing Nix most likely, only more poorly.)
20:22:47 <Ashy> thoughtpolice: Yeah fair enough, last I looked into nix the binary caches for mac weren't really set up yet
20:23:01 <thoughtpolice> If you really want that you're probably better off using vendored dependencies IMO (like, from your custom build system packaged for your OS). For general development you'll get more bang for your buck just reducing turnaround time and optimizing that.
20:24:31 <Ashy> It's a relatively minor annoyance really, just would be nice if it was all automatically fixed through stack at some point
20:25:15 <Ashy> Anyway I didn't mean to derail the ghc optimisation discussion, please ignore me haha
20:25:44 <codygman> montanonic: thanks
20:34:35 <Newby> Hello i have a newbie question, can someone help me? ^^
20:35:40 <Newby> I am trying to concatenate two list in a list
20:35:44 <dmj`> @ask
20:35:45 <lambdabot> Who should I ask?
20:35:50 <dmj`> Newby: go ahead and ask
20:37:32 <Newby> Like a list [1,2,3] and a list [4,5,6]. I can't do x:y to get the list [[1,2,3],[4,5,6]]
20:38:20 <jle`> try [x, y]
20:39:18 <geekosaur> actually what you were doing was almost right. do you understand what (:) actually does?
20:40:46 <Newby> well i'ts a bit more complicated ^-^'. I have a tuple (Int,[[Int]]) . So i can't write (10,list,list). Right?
20:41:05 <Newby> (:) add an item in front of a list no?
20:41:32 <jle`> (10, [x,y]) ?
20:41:46 <jle`> or (10, [xs,ys]), to emphasize that xs and ys are two lists
20:41:48 <geekosaur> right, but the types have to match. if you have two lists and you want a single list of lists, it'd be [x,y] which is equivalent to x:y:[]
20:41:58 <jle`> > let xs = [1,2,3]; ys = [4,5,6] in (10, [xs,ys])
20:42:00 <lambdabot>  (10,[[1,2,3],[4,5,6]])
20:42:09 <geekosaur> x:y would try to make the first list the first element of the second list
20:42:28 <geekosaur> and [[1,2,3],4,5,6] is a type error
20:43:48 <geekosaur> I am not seeing what you're getting at with the tuple, btw. perhaps show a concrete example of what you have and what you want the result to be, including the tuple(s)?
20:43:49 <Newby> I tryied to put (Int,[list,list]) but now i have a problem in my program :P . I surely made a mistake somewhere
20:44:02 <jle`> Newby: you might be mixing up types and values
20:44:10 <jle`> Int is a type, but [list,list] isn't really a type
20:45:13 <Newby> yeah when i wrote list it means [Int] sorry ^^
20:45:37 <jle`> [[Int],[Int]] isn't a type, either
20:45:45 <jle`> do you mean [[Int]] ?
20:45:51 <Newby> yes xD
20:46:00 <Newby> rep :: ([Int],[Int]) -> (Int,[[Int]])
20:46:52 <jle`> @let rep :: ([Int],[Int]) -> (Int -> [[Int]]); rep (xs, ys) = (1000, [xs,ys]) in rep ([1,2,3],[4,5,6])
20:46:52 <lambdabot>  Parse failed: Parse error: in
20:47:00 <jle`> > let rep :: ([Int],[Int]) -> (Int -> [[Int]]); rep (xs, ys) = (1000, [xs,ys]) in rep ([1,2,3],[4,5,6])
20:47:02 <lambdabot>      Couldn't match expected type ‘Int -> [[Int]]’
20:47:02 <lambdabot>                  with actual type ‘(Integer, [[Int]])’
20:47:02 <lambdabot>      In the expression: (1000, [xs, ys])
20:47:04 <jle`> :(
20:47:19 <jle`> > let rep :: ([Int],[Int]) -> (Int, [[Int]]); rep (xs, ys) = (1000, [xs,ys]) in rep ([1,2,3],[4,5,6])
20:47:21 <lambdabot>  (1000,[[1,2,3],[4,5,6]])
20:47:28 <jle`> what is the behavior you really want?
20:50:25 <Newby> well i have my fonction "rep :: ([Int],[Int]) -> (Int,[[Int]])" and  have to put [Int] in the [[Int]] recurcively 
20:51:09 <Newby> to put a [int] "created" with ([Int],[Int])
20:51:42 <mauke> that means nothing
20:51:48 <jle`> can you show an example of inputs and outputs?
20:51:53 <jle`> it's a bit difficult to understand
20:52:01 <jle`> what should rep ([1,2,3], [4,5,6]) be?
20:52:58 <Newby> Well that's a tricky exercice, hard to explain without detail x)   input : ([1,2,6,3,3,3],[2,1,3,3,4,1,4]) output : (7,[[5],[3,7],[1,2,3,4,5,7],[4,5,7],[1,3,4],[5,6,7]])
20:54:08 <java_pro> are their advantages to using linear over hmatrix?
20:54:54 <Newby> it is a matrix exercice
20:56:07 <jle`> java_pro: hmatrix uses blas and laplack etc., industry standard linear algebra C libraries
20:56:10 <pavonia> Newby: Explain the mathematical function/algorithm/exercise definition
20:56:12 <mauke> that's why we're asking for detail
20:56:18 <jle`> java_pro: linear is mostly pure haskell
20:56:20 <Newby> Inputs are matrix vertival and horizontal projections
20:56:50 <java_pro> jle` i take it hmatrix is faster for most thigns?
20:57:04 <jle`> java_pro: there's a module in the linear library that uses 'vector'-library vectors, too, but it implements pure haskell functions on the c-like arrays from the vector package
20:57:16 <jle`> hmatrix outsources the entire algorithm/functions to blas etc.
20:57:30 <Newby> and with both of them i have to create a compact representation
20:57:40 <jle`> for a lot of things hmatrix might be faster, but i can imagine linear being faster for certain citations, to
20:57:56 <jle`> dot producting two 2-element vectors might be faster in linear because it doesn't have to ffi out
20:58:07 <Newby> it's a school exercice, i have step to follow ^^
20:58:30 <pavonia> Newby: What is the vertical/horizontal projection of a matrx?
20:58:31 <java_pro> jle` i have some experience using hmatrix. actually right now i'm circumventing it with my own C bindings for some GSL work (not satisfied with the list-based interface)
20:58:36 <java_pro> jle` but i don't have experience with linear
20:58:40 <jle`> or, it doesn't have to allocate vectors etc. like you would with hmatrix
20:58:55 <java_pro> and i only have a tiny bit of experience with repa so far
20:59:06 <jle`> but for large vectors and large matrices, yeah, hmatrix should usually be much much faster
20:59:35 <jle`> one disadvantage with hmatrix is that it doesn't work in ghcjs directly, but linear/vector does, because it's implemented with pure haskell and vectors
20:59:39 <Newby> pavonia: here is the matrix = [[B,B,B,B,B,B,N],[B,B,N,B,N,B,B],[N,B,N,N,N,N,N],[B,B,B,N,N,B,N], [N,N,N,B,B,B,B],[B,B,B,N,N,B,N]]. The projection are the number of N il line/collumn
20:59:59 <Newby> in*
21:00:27 <java_pro> jle` not too happy with hmatrix's design decisions. feels like a klunkier python (if that were possible)
21:00:48 <java_pro> but unfortunately it seems more mature than most other options in the ecosystem
21:01:02 <pavonia> Newby: Okay, and what would the result of rep be?
21:01:37 <java_pro> (with repa there doesn't even seem to be a function to print matrices with proper line breaks!)
21:01:43 <jle`> feel free to submit an issue or PR if you have any ideas, the maintainer of hmatrix is always really open to considerations about api/usage :)
21:02:00 <jle`> but yeah, try out linear too
21:02:23 <Newby> rep give the compact representation. Let me translate what is it for you
21:02:30 <java_pro> jle` well right now i'm using GSL and i just wrote my own bindings because going through standard lists seems hopelessly slow
21:02:52 <java_pro> (+ unsafe calls)
21:03:10 <jle`> also, you can always stop by #numerical-haskell any time, where we spend all day talking about things like this
21:03:17 <java_pro> and it works, ODE integrations are blazingly fast unlike with hmatrix. but that's more of my special case
21:03:17 <jle`> but, it's been inactive over the past year or two
21:03:54 <java_pro> my general issue with hmatrix is a little less specific, just that the design doesn't feel particularly compositional or functional
21:04:06 <java_pro> it feels more like a poor man's matlab
21:04:15 <Newby> The compact representation is like  (Int (the number of line),[[Int](index of the position of "N" in the matrix)]
21:04:27 <java_pro> with glued C ecosystem here and there
21:04:37 <jle`> yeah, i think that's a view shared by many
21:05:21 <java_pro> jle` is repa still in serious development?
21:05:49 <jle`> i haven't been following repa, but i still hear things about it every once in a while
21:05:58 <jle`> accelerate too
21:05:59 <java_pro> there were a couple posts by idontgetoutmuch that seemed to suggest that repa development has slowed down somewhat
21:06:28 <jle`> accelerate is someone a work of art, both in theory and in engineering
21:06:32 <java_pro> carter seems pretty occupied with real work
21:06:33 <jle`> s/someone/somewhat
21:06:37 <java_pro> i haven't tried accelerate
21:06:52 <jle`> but most people use accelerate specifically for numerical GPU programming
21:06:57 <java_pro> i thought it was kind of low level though and not strictly for numerics..
21:07:06 <jle`> i'm not sure if it's usable as a general purpose CPU library, but i don't see why it wouldn't be
21:07:15 <java_pro> at least not in the way something like hmatrix/repa/numerical would be
21:07:17 <jle`> most accelerate applications i've seen have been numerical in nature
21:07:24 <pavonia> Newby: What if there is more than one solution?
21:07:38 <jle`> but yeah, you'd have to implement things from scratch, it doesn't have a linear algebra platform's features really
21:07:39 <java_pro> i'm looking for something that is usable interactively though (substituting for python/R)
21:07:41 <Newby> more than one?
21:07:56 <java_pro> but would also smooth the transition to production use better than those dynamically typed languages
21:08:20 <pavonia> Newby: Think of rep ([1,1], [1,1])
21:08:28 <jle`> yeah, i don't know if i can give you a library with a good story
21:08:32 <jle`> for exploratory data analysis
21:08:49 <jle`> i use hmatrix's Static module sometimes, because the API is a bit simpler and consolidated
21:08:50 <java_pro> a lot of my work is in scientific research, so i don't have the luxury of jumping straight into engineering
21:09:13 <jle`> so hmatrix's Static interface has been my go-to, but it's still heavily under development
21:09:31 <java_pro> jle` yeah bums me out. for now i'm doing a lot from scratch
21:09:41 <jle`> linear is nice for exploratory stuff too, its interface is pretty simple and it lets you leverage common haskell abstractions like Functor, Applicative, Monad
21:09:44 <jle`> Traversable, Foldable, etc.
21:09:52 <java_pro> C FFI is kind of a fallback. If I could figure out a better C++ FFI story it would be an even better fallback.
21:10:12 <jle`> you might have a nice time with linear because of how it integrates with the rest of the haskell ecosystem
21:10:23 <jle`> the only problem is that it's definitely slower for serious applications
21:10:33 <jle`> (linear algebra applications)
21:10:37 <java_pro> i'm a little hesitant to use linear since I figure ed has like a million things he's juggling
21:10:37 <jle`> except for edge cases, probably
21:10:51 <java_pro> how does linear compare to just rolling things from scratch with Data.Vector ?
21:10:52 <jle`> ed is a superman, so
21:11:05 <jle`> well, most of linear's types is actually pure haskell
21:11:10 <jle`> data V2 a = V2 a a
21:11:15 <jle`> er, V2 !a !a of course
21:11:25 <java_pro> i imagine Data.Vector has gotta be faster (?)
21:11:27 <jle`> but linear does have a wrapper over Data.Vector vectors
21:11:50 <jle`> maybe, but i can imagine (V2 1 2) `dot` (V2 0 4) being faster, because it doesn't require allocating vectors.  but i haven't benchmarked
21:12:18 <jle`> linear does have a warpper over Data.Vector vectors for larger vector sizes and faster zippy+foldy operations (like dot)
21:12:26 <java_pro> jle` how's the pretty printing defaults with linear. can i print a damn matrix? :P
21:12:31 <jle`> but, it doesn't have a real matrix implementation
21:12:39 <jle`> matrices in linear are vectors of vectors
21:12:54 <jle`> matrices will be printed as vectors of vectors :P
21:13:22 <java_pro> so probably ugly
21:13:26 <java_pro> :/
21:13:27 <jle`> so, if you do anything involving matrices (ie, almost any sort of linear algebra), linear is somewhat unusable
21:13:38 <jle`> by somewhat i mean pretty much, for serious application
21:13:53 <java_pro> hm... what about jacobians and such, or doing some basic SVD
21:13:56 <jle`> but it does have the prettiest/most beautiful mathematical API and typeclass structure though
21:14:38 <jle`> any algorithms for jacobians and stuff like that would be on vectors of vectors, so inherently sluggish.  i'm not even sure if they are implemented generically
21:14:51 <java_pro> does it have some basic eigenvector/eigenevalue decomposition  routines?
21:15:01 <java_pro> ... probably not  i'm guessing
21:15:10 <jle`> i see linear less of a featured linear algebra/numerical library and more of utility functions for tuples with a beautiful mathematical api
21:15:44 <java_pro> hm
21:16:00 <jle`> so, it might be nice for things like simple 2D games
21:16:17 <jle`> where the most advanced thing you're going to do is projecting 2d vectors on each other
21:16:18 <java_pro> i'm sure the co-everything stuff is nice, but i'm not doing enough typeclass trickery yet
21:16:50 <java_pro> yeah for now i need to get some calculations doen in a reasonable amount of time so I don't get fired for not using python
21:16:50 <jle`> actually it's less of that, and more of a traditional linear algebra hierarchy
21:17:04 <jle`> a class for vector spaces, a class for metric spaces
21:17:18 <jle`> sort of what i'd do if i wanted to codify linear algebra and related fields using typeclasses
21:17:27 <jle`> metric spaces yield a dot product and a norm, etc.
21:18:03 <jle`> but i think the most advanced thing i'd use linear for is things on the order of complexity of 2d game physics
21:18:13 <java_pro> ok it looks nice. maybe i'll make light use of it for storing some data..
21:18:49 <java_pro> but if i'm going to go low-level (as far as available functionality), i'm thinking repa might be more bang for the buck considering the performance gains
21:19:11 <java_pro> (or at least, advertised performance gains ... haven't really stress tested it myself)
21:19:31 <codedmart> Is there a copyFile that creates missing dir?
21:19:55 <jle`> you mentioned earlier that you were disappointed in the lack of things ready-to-go.  i was too, but maybe you can see it from the perspective i've adopted --- it gives you a chance to be there when it all begins, and be a trail blazer :3
21:20:10 <jle`> you get a chance to contribute and carve the future of haskell :D
21:21:00 <jle`> and innovate
21:21:33 <pavonia> codedmart: You can use createDirectoryIfMissing before copying
21:21:45 <jle`> java_pro: i always heard that repa's main performance selling point was in it stream fusion?  if that's true, then the perf gains wouldn't be there if you are using it interactively 
21:22:09 <codedmart> pavonia: Do I need to strip the file name from the end of the path before using createDirectoryIfMissing or will is ignore it?
21:22:16 <jle`> but i might be misinformed
21:22:49 <java_pro> jle` well i'm using it both interactively and non-interactively. part of my motivation ofr haskell is to smooth the transition
21:23:04 <pavonia> codedmart: You have to strip it, I think, otherwise it will create a dir with the same name
21:23:14 <java_pro> jle` tbh i haven't investigated limitations of ghci but i understand it's kind of limited wrt optimization level
21:23:17 <codedmart> pavonia: OK thanks!
21:23:54 <jle`> i've had some ideas for my ideal interactive numeric platform but not the time to really implement/explore them
21:24:24 <java_pro> jle` so ghci can't do stream fusion magic?
21:24:28 <jle`> but isn't that the story of our lives ~
21:24:35 <java_pro> yeah it really is
21:24:48 <java_pro> especially haskell where there's so much left to do and so few people to do them.
21:24:49 <jle`> ghci doesn't do any optimizations afaik
21:25:05 <jle`> (i could be wrong)
21:25:06 <java_pro> wasn't chris done working on a "next-gen" ghci?
21:25:54 <jle`> yes, this is my secret motivation in my haskell evangelism ... recruiting bodies to help fill up the ecosystem >_>
21:25:55 <java_pro> i think you're right, which makes the C FFI route a bit more compelling, in spite of well... its beauty limitations
21:26:38 <java_pro> me too. i can't tell if it's moving or not. from inside it "feels" like there's momentum, but whenever i see hard stats that doesn't seem to be the case.
21:27:04 <jle`> ;_;
21:28:09 <java_pro> like from my vantage point it's like "everyone is reading chris's book, yay. look at all these production stories". then i check google trends and it's basically a flat line.
21:28:45 <jle`> yeah, and #haskell's explosive growth during 2012-2014 has slowed down
21:29:45 <java_pro> i started in 2015 so i didn't notice that
21:29:59 <java_pro> i think the learning curve is just too steep
21:30:05 <java_pro> for most programmers
21:31:45 <java_pro> the upside is you select for really dedicated/good people. but brute force by population size has its advantages. you just need like 1 out of 1000 javascript programmers to hit on a good approach to be able to move the ecosystem forward.
21:32:48 <java_pro> anyhoo i'm steering into haskell-blah territory (blame the silly verification rules there...)
21:33:16 <jle`> wax on :)
21:42:34 <java_pro> alright time 4 sleep
21:48:25 <hjulle> Why does haskell-blah require ssl?
21:49:05 <Ralith> a better question would be why some channels don't
21:49:17 <Ralith> encryption-by-default is important
21:50:23 <hjulle> Ok, let me rephrase it: Why does haskell-blah require higher security than #haskell?
21:53:06 <Ralith> inaction bias
21:54:43 <jle`> wax on :)
21:54:50 <hjulle> In other words...
21:55:03 <jle`> oops, sorry
21:56:14 <Cale> hjulle: I'm boycotting it because it requires TLS
21:57:01 <Cale> It's needlessly complicated technology serving no purpose, as far as I can tell.
21:58:54 <Cale> Anyone who turns on TLS can join the channel, so there's no reason to encrypt it in the first place.
21:59:51 <c_wraith> Cale: you can't turn on TLS per-channel, so it means your whole connection is over TLS, including authentication.
21:59:58 <Cale> c_wraith: correct
22:00:10 <Cale> c_wraith: There is a reason, perhaps, to enable TLS in your client
22:00:12 <c_wraith> So there is a purpose to connecting via TLS
22:00:26 <Cale> There is not a reason to force people to enable it to join a channel
22:01:02 <Ralith> contributing to the estalishment of a norm of encrypted rather than plaintext traffic is a pretty good reason
22:01:14 <hjulle> There is reason to forece people to enable it in general, but on a channel basis is a bit silly.
22:01:31 <Cale> If freenode really wants to require TLS network-wide, I'm all for it.
22:01:53 <Cale> (Well, with some reservations -- it will make IRC bots more annoying to write)
22:02:09 <Cale> (and it will temporarily kill lambdabot)
22:02:45 * hackagebot MailchimpSimple 0.2.0.0 - Haskell library to interact with Mailchimp JSON API Version 3.0  https://hackage.haskell.org/package/MailchimpSimple-0.2.0.0 (dananji9131)
22:02:47 <Cale> But requiring it on a channel-by-channel basis is impolite and pointless.
22:03:07 <Cale> You're just inconveniencing the users of the channel.
22:06:34 <nitrix> Hi, question. I have a `class Gridable a where toGrid :: Ord b => a -> (b, b)`
22:06:36 <hjulle> I guess it's a way of allowing the community to choose for themselves if they want to enforce it. If your main channel is enforcing encryption, you will probably go through the effort of enabling it. If some less important channel like ##haskell-blah is enforcing it, it's most likely just turning people away from it.
22:06:47 <Cale> "Contributing to the establishment of a norm of encrypted rather than plaintext traffic" sounds similar in terms of reasoning to me to "Contributing to a norm of sequined rather than unsequined clothing"
22:07:04 <nitrix> The instance I created for it is specialized as :: Coordinate -> (Integer, Integer).
22:07:24 <nitrix> My understanding is that Integer belongs to the typeclass Ord, thus should be allowed, yet I get a type error.
22:07:29 <Cale> It presumes that there's some reason that encrypted traffic is somehow inherently better, while unencrypted protocols also have advantages.
22:07:39 <scshunt> ^
22:07:44 <johnw> Cale: sad to say, but this is -blah material itself :)
22:07:50 <nitrix> "Couldn't match type ‘b’ with ‘Integer’  ‘b’ is a rigid type variable bound by the type signature for toGrid :: Ord b => Coordinate -> (b, b)"
22:07:56 <nitrix> Expected type: Coordinate -> b
22:08:01 <nitrix> Actual type: Coordinate -> Integer
22:08:05 <nitrix> Any clue what's happening?
22:08:30 <hjulle> nitrix: Your type class says that you have the function for any Ord b, not just a specific one.
22:08:32 <johnw> nitrix: you can't infer Integer from Ord b => (b, b)
22:08:37 <monochrom> nitrix: you are literally promising "the user chooses an instance of Ord". this is not going to allow the implementer to choose.
22:09:50 <nitrix> Mhhh...
22:09:55 <Cale> johnw: Yeah, too bad I'm not allowed in, because my client doesn't have TLS enabled
22:10:11 <monochrom> polymorphism is a two-person zero-sum game
22:10:27 <scshunt> I don't even understand why requiring TLS for a channel is a feature.
22:10:27 <jle`> nitrix: imagine writing "foo :: Show a => a; foo = True"
22:10:48 <jle`> the type signature is clearly false; it's saying that foo could be any 'a' you want, as long as 'a' is a Show instance
22:10:53 <monochrom> now, that's a capitalist way of putting it. the communist way to put it is: polymorphism is a dialectic class struggle between user and implementer
22:10:59 <Cale> scshunt: I can imagine valid uses for it -- if your channel is invite only or requires a password.
22:11:03 <jle`> but your implementation will always give a Bool
22:11:09 <nitrix> jle`: Right.
22:11:12 <jle`> what if you wanted `foo :: Int` ?  or `foo :: [Double]` ?
22:12:01 <nitrix> I understood that part fairly well, but I'm still confused as to how I'd let my datastructure work on any type that's something Gridable.
22:12:23 <mauke> that's easy; there are no valid instances of Gridable
22:12:33 <nitrix> My data structure has the necessary constraints on `Gridable a`, I just can't seem to be able to implement any instances.
22:12:36 <nitrix> mauke: Why not?
22:12:47 <nitrix> All the data structure needs are the operations guaranteed by Ord.
22:12:49 <monochrom> what is your data structure? I haven't seen it.
22:12:50 <mauke> because you can't conjure up a 'b' from nothing
22:13:11 <Cale> nitrix: Ord b doesn't give you a way to construct values of type b
22:13:31 <Cale> nitrix: In fact, an empty type can be a valid instance of Ord
22:13:48 <nitrix> _|_
22:14:12 <jle`> ( _|_ is a value, i think we're referring to types like `data Void`)
22:14:21 <Cale> So the only possible things which toGrid can return are _|_ and (_|_, _|_)
22:14:32 <nitrix> I don't think an empty type exists in Haskell, does it?
22:14:38 <jle`> in some libraries it does
22:14:44 <mauke> not completely empty
22:14:49 <nitrix> Anyway, we can postpone that discussion to later.
22:14:52 <Cale> Right, it doesn't, but if it did, then it could be a valid instance of Ord anyway :)
22:14:53 <mauke> but morally empty
22:15:03 <jle`> oh hey, it's in base now too
22:15:06 <jle`> http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Void.html
22:15:10 <Cale> and yeah, Haskell Void can also be an instance of Ord
22:15:12 <Guest31866> hey guys -- i'm trying to write an opengl program that uses a compute shader to modify a texture
22:15:13 <jle`> and it has an Ord instance :3
22:15:38 <jle`> Ix instance too hehe
22:15:47 <hjulle> nitrix: In other words, you need to change the class to make it implementable.
22:15:49 <Guest31866> is there any way to do this with the standard opengl package?
22:17:21 <Cale> I don't know, but there's pretty much guaranteed to be a way to do it with http://hackage.haskell.org/package/gl (latest version doesn't have docs yet, click the previous one for doc links)
22:17:51 <Guest31866> ok, ty Cale
22:18:03 <Guest31866> i've been trying with https://hackage.haskell.org/package/OpenGL
22:18:06 <Ralith> Cale: I don't want to get into a big offtopic debate here, but suffice to say there's good reasons google's pushing that direction (for example)
22:19:17 <Guest31866> ahhh -- had no idea previous version had docs. very helpful
22:19:55 <nitrix> data Grid k v = MkGrid (M.Map k (M.Map k (S.Set v))) (M.Map v (S.Set (k, k)))
22:20:49 <nitrix> Cale: hjulle monochrom johnw: What if I want this data structure to work for any type that has two dimensions and can be decomposed into those two Ord k => k's needed as keys?
22:21:00 <nitrix> (I know the datastructure is monstruous.)
22:21:03 <Cale> Ralith: In cases where you don't want people to be able to easily create programs for interacting with something, it's a good way to make it a bit more work.
22:21:17 <jle`> nitrix: you can't make any type of typeclass for types that can be decomposed to any two Ord k => k's
22:21:26 <jle`> because there are no values of Ord k => k
22:21:46 <Ralith> Cale: I sympathize with whoever's maintaining lambdabot but it's really easy to speak SSL from haskell in general :P
22:22:03 <johnw> jle`: what is there no value of type Ord k => k?
22:22:04 <jle`> nitrix: you can change your return type to be something other than Ord
22:22:09 <nitrix> jle`: You're telling me that this map as-is, is somewhat too generic for Haskell's type system?
22:22:09 <Cale> Ralith: I'm not talking about lambdabot specifically.
22:22:17 <jle`> there are no values of type forall a. Ord k => k
22:22:17 <johnw> foo :: Ord k => k; foo = (1 :: Int)
22:22:33 <jle`> @let foo :: Ord k => k; foo = (1 :: Int)
22:22:34 <lambdabot>  .L.hs:152:8:
22:22:34 <lambdabot>      Couldn't match expected type ‘k’ with actual type ‘Int’
22:22:34 <lambdabot>        ‘k’ is a rigid type variable bound by
22:22:34 <Cale> Ralith: It's just an extra layer of complexity for some beginner programmer to have to learn about and deal with before they can write something that works.
22:22:51 <Ralith> Cale: so was virtual memory, once
22:23:27 <jle`> functions like foo :: Ord k => Int -> k are uninhabited   (barring bottomy stuff)
22:23:30 <hjulle> nitrix: You could try `class Gridable a b where toGrid :: Ord b => a -> (b, b)`
22:23:32 <johnw> foo :: (Ord k => k -> r) -> r; foo k = k (1 :: int)
22:23:55 <jle`> that's not forall k. Ord k => k, that's exists k. Ord k => k
22:23:57 <Cale> Ralith: Hey, if you want to put encryption in at the OS level in a way where people don't have to worry about it at the application level, that's fine
22:23:58 <johnw> yeah
22:24:08 <hjulle> nitrix: I mean `class Ord b => Gridable a b where toGrid :: a -> (b, b)`
22:24:11 <jle`> (forall k. Ord k => k) is a value that is a member of every Ord instance
22:24:14 <Cale> But that's not the situation we have here :P
22:24:22 <jle`> only one such value qualifies -- bottom
22:24:37 <Ralith> Cale: I'd like that, but nothing like that is going to happen unless there's a pressing demand for it
22:24:45 <johnw> jle`: right, sorry for the confusion
22:25:05 <jle`> np, it was a good opportunity to clarify because it's a point central to the conversation heh
22:26:00 <jle`> if foo :: Ord k => Int -> k was inhabited, we could get Void, with (foo 10 :: Void)
22:26:22 <johnw> only if there was an instance Ord Void
22:26:32 <Cale> nitrix: I think you're misinterpreting what the types are saying.
22:27:12 <jle`> johnw: there is :D
22:27:19 <Cale> nitrix: If you give me something of type forall t. (Ord t) => ... t ..., then whatever type t that *I* choose, as the user of that thing, the implementation has to work.
22:27:29 <jle`> http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.Void.html#line-43
22:27:36 <nitrix> Cale: I'm just looking for a way to keep my data structure generic.
22:27:37 <johnw> jle`: huh, TIL
22:27:52 <jle`> i just learned too ten minutes ago >_>
22:28:20 <Guest31866> what's the difference between the gl package and the OpenGLRaw package ? (https://hackage.haskell.org/package/gl vs https://hackage.haskell.org/package/OpenGLRaw)
22:28:21 <jle`> i'm not sold on the implementation though
22:29:13 <jle`> but i guess any other implementation would be isomorphic
22:29:20 <nitrix> 20 minutes ago, it worked just fine for any Ord as key, for both dimension, but I typically work with a Coordinate type that contains those two dimensions, so I figured I'd have a type class that expresses things that have dimensions that can be broken down, this way the datastructure can break the dimensions and use those.
22:29:31 <Cale> jle`: would you prefer  compare x y = absurd x (absurd y) ? :)
22:29:53 <shachaf> compare x y = compare (absurd x) (absurd y)
22:30:01 <nitrix> I see nothing out of the ordinary from my request. I've seen plenty of packages doing just that. So what's wrong with my approach? 
22:30:20 <nitrix> It's getting stupid far right now with MultiParamTypeClasses and RankNTypes.
22:30:26 <jle`> nitrix: having it return Ord k => (k, k) is the problem
22:30:35 <Cale> nitrix: Okay, let's take a step back and have a look at what you're trying to abstract over
22:30:44 <nitrix> jle`: We both know it's the problem. I'm looking for solutions.
22:30:47 <Cale> nitrix: I don't think I saw that part.
22:31:09 <nitrix> data Grid k v = MkGrid (M.Map k (M.Map k (S.Set v))) (M.Map v (S.Set (k, k)))
22:31:19 <Cale> Can you show me at least two examples of the sort of function you'd like to capture with your type class method?
22:31:26 <jle`> Cale: is the fact that there is only one inhabitant of (Void -> a) for any a also still true in the presence of bottom ?
22:31:29 <nitrix> Both the k and v are instances of Ord.
22:31:54 <nitrix> All this data structure does is call things of Map and Set, it's _nothing_ fancy.
22:31:58 <Cale> jle`: no
22:32:33 <Cale> jle`: Computable functions are monotone (and continuous, in that they preserve limits of increasingly-defined chains)
22:32:45 <Cale> jle`: But you can have f x = 5 for example
22:32:50 <Cale> Void -> Integer
22:33:07 <nitrix> As is, I'd end up with something like :: Grid Integer String, which I don't like because it's showing the type of the index, instead of using the dedicated type I have for points,
22:33:09 <jle`> is there another Void -> Integer that is not isomorphic to f x = 5 ?
22:33:21 <Cale> f x = 8
22:34:26 <Cale> > let f x = 5; g x = 8 in (f undefined, g undefined)
22:34:27 <lambdabot>  (5,8)
22:34:42 <jle`> oh huh.
22:34:51 <jle`> because Void has an inhabitant considering bottom.
22:35:08 <jle`> so is the current implementation _ == _ = EQ incorrect?
22:35:15 <Cale> yes
22:35:27 <jle`> how unfortunate
22:35:31 <Cale> er, no
22:35:40 <Cale> I misread your question
22:35:50 <Cale> It's fine
22:36:24 <jle`> s/EQ/True
22:36:37 <Cale> ah, haha
22:36:38 <Cale> yeah
22:36:53 <Cale> Also, we usually only enforce type class laws for defined values
22:37:13 <Cale> So to some degree, it doesn't matter what the result of these operations are.
22:37:41 <jle`> but, why not x == y = absurd x == absurd y ... is that any more or less correct?
22:37:43 <jle`> ah yeah, that's true too
22:37:50 <Cale> But True is natural, in that Void has exactly one value
22:38:05 <jle`> that too is true
22:38:09 <Cale> That would be ambiguously typed
22:38:19 <hjulle> nitrix: Was there a problem with using this class? `class Ord b => Gridable a b where toGrid :: a -> (b, b)`
22:38:27 <jle`>  :: ()
22:38:29 <Cale> Also, if you have aggressive defaulting turned on, you'd get defaulted to ()
22:38:30 <jle`> ... maybe ...
22:38:39 <Cale> which would make it evaluate to True
22:38:47 <Cale> in which case you haven't gone anywhere
22:39:16 <Cale> actually, is that the case?
22:39:17 <nitrix> hjulle: Well Haskell complained about with too many parameters, I added the extension and testing atm.
22:39:22 <jle`> i'm not sure if absurd _ = ()
22:39:28 <jle`> but
22:39:32 <Cale> > (undefined :: ()) == ()
22:39:34 <lambdabot>  *Exception: Prelude.undefined
22:39:36 <Cale> nope
22:39:42 <Cale> okay, so that would be changing things
22:39:51 <Cale> it would result in a pattern match failure instead :P
22:40:56 <Cale> or an undefined exception
22:41:50 <Cale> nitrix: You'll probably end up wanting functional dependencies
22:42:03 <Cale> nitrix:  class Ord b => Gridable a b | a -> b where ...
22:42:25 <Newby> Someone know how to concate the head of a list recursively?
22:42:35 <Cale> nitrix: That will allow the compiler to infer the type b given the type a, but restrict you to a single instance for any given type a.
22:42:47 <Cale> Newby: Not sure what you mean
22:42:53 <Cale> Newby: can you give an example
22:42:54 <Cale> ?
22:45:07 <Newby> Cale: kinda hard to find a example xD
22:45:14 <Newby> Cale: i'm searching
22:46:20 <Newby> Cale: like rec ((x:xs),(y:ys)) = ((length xs)+1, [x+y,[rec (x,y)]]
22:46:49 <Cale> Newby: can you just give examples of input and output lists?
22:47:10 <Cale> also, that looks like a type error
22:47:17 <Cale> [x + y, [...]]
22:47:32 <Newby> my function is like that rep :: [Int] -> [Int] -> (Int,[[Int]])
22:47:35 <Cale> is a type error (unless you have an instance of Num for lists, which would be unusual)
22:47:53 <Cale> So what should rep [] [] produce?
22:48:36 <Newby> nothing, it's a matrix exercice and a bit hard to explain without all the details
22:49:02 <Cale> I'm trying to understand what the function you're trying to define actually does
22:49:08 <hjulle> Can you show an example input and output?
22:49:15 <Cale> Yeah, *any* example would help
22:50:01 <Cale> But I was thinking that looking at small examples might actually lead you in the direction of an implementation
22:50:11 <Newby> input ([1,2,6,3,3,3],[2,1,3,3,4,1,4]) output:  (7,[[5],[3,7],[1,2,3,4,5,7],[4,5,7],[1,3,4],[5,6,7]])
22:50:29 <Newby> the numbers will say nothing for you
22:51:00 <jle`> in any case, it doesn't sound like your problem is a haskell question, but an algorithm question
22:51:04 <Newby> but each call give me a [[Int]] but i only need the head of it
22:51:08 <Cale> Okay, so the first list says how long the lists in the second part of the output are
22:51:18 <Cale> I have no idea what the second list means yet
22:51:45 <Cale> Perhaps you just want map head ?
22:52:03 <Cale> > map head [[1,2,3],[4,5],[6,7,8],[9],[10,11]]
22:52:04 <lambdabot>  [1,4,6,9,10]
22:52:11 <Newby> no it's not that
22:52:13 <Cale> > map head [[1,2,3],[4,5],[6,7,8],[9],[],[10,11]]
22:52:15 <lambdabot>  [1,4,6,9,*Exception: Prelude.head: empty list
22:52:27 <Cale> ^^ careful with it though
22:53:23 <hjulle> Newby: You probably want to use a helper function to do the recursion and a main function to give the interface.
22:53:30 <Newby> i have no idea how to explain my problem bettre
22:53:51 <Cale> more context
22:54:14 <Cale> The program you're trying to write, what does it do?
22:54:25 <Axman6> Newby: what input and output do you expect
22:54:47 <Axman6> if you are given [[1,2,3],[4,5],[6]] what should the output be?
22:55:22 <Newby> Axman6: input are ([Int],[Int]) only
22:56:24 <Newby> it's a matrix exercice... a bit complex and it's the last question so i can't realy tell you without telling about whole exercice
22:56:29 <Axman6> ok, what should the output for ([1,2,3],[4,5]) be?
22:57:08 <Cale> Newby: Can you link the exercise, or paste it on lpaste.net?
22:57:38 <hjulle> and/or paste your code so far on lpaste.net
22:57:38 <Newby> Axman6: thoose are not good output, the sum of each side have to be equal
22:58:00 <Newby> Cale: Are you good in French ? xD
22:58:26 <Cale> My French is bad, but I'll probably understand well enough.
22:59:08 <Newby> my code : http://lpaste.net/157410
23:00:11 <Newby> Rep the answering function
23:02:04 <jle`> Newby: can you maybe describe the algorithm in normal words, as if you were teaching someone how to do it by hand?
23:02:49 <jle`> step-by-step
23:03:48 <Newby> if you want the exercice in french : http://lpaste.net/7298385978463354880  Good luck :p
23:03:51 <Newby> ok jle` 
23:05:02 <Newby> You have matrix like g0 = [[B,B,B,B,B,B,N],[B,B,N,B,N,B,B],[N,B,N,N,N,N,N],[B,B,B,N,N,B,N], [N,N,N,B,B,B,B],[B,B,B,N,N,B,N]]. I did a function (question 2) projV and projH who are doing verticale and horizontal projection of the matrix
23:05:56 <Newby> that mean it put il a [Int] the number of "N" per line or collumn (for projV or projH)
23:06:01 <Newby> in*
23:06:44 <Newby> projV and projH are my inputs
23:06:56 <Newby> for rep (Question 6)
23:08:18 <hjulle> Newby: Your current version of rep type-checks, what needs to change?
23:08:22 <kosmikus> mpickering: "newcode" applies formatting directives, whereas "code" does not. this can be very useful, but only if you define different formatting directives for "newcode" and "poly".
23:08:22 <Newby> I have to start for thoose projection to create the compact representation. The output (Int,[[Int]])
23:08:58 <Newby> hjulle: the "head" and "snd" 
23:09:59 <Newby> hjulle: for each call of rep i need the [l1 (cplW y 1) x] be added in my result
23:10:32 <dmtd> hi all, how do you check to see what the type is of a function in ghci command line?
23:10:46 <Walther> dmtd: :t
23:10:50 <Walther> > :t even
23:10:51 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:11:07 <Walther> welp, should work in ghci
23:11:08 <hjulle> Newby: Like this? `rep (x:xs) y = (length y, l1 (cplW y 1) x : snd (rep xs (vRec y (l1 (cplW y 1) x) 1))))
23:11:31 <Newby> but with head(snd) it only take the 1st list even if there is a million recurcive call
23:12:01 <Newby> hjulle: yes! That's what i did first but you can't use : for list
23:12:15 <dmtd> walther: what if I have something like thing xy = head (tail xy)
23:12:35 <dmtd> when I put that in ghci, it says <interactive>:1:11: parse error on input ‘=’
23:12:49 <dmtd> after :type
23:13:06 * hackagebot warp 3.2.4 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.4 (MichaelSnoyman)
23:13:20 <Newby> hjulle: you can't do [Int]:[Int]
23:13:42 <hjulle> No, but you can do [Int]:[[Int]]
23:14:53 <Walther> dmtd: say "let foo = ..." your function, and then you should be able to say :t foo
23:15:04 <dmtd> oh! ok
23:15:30 <Newby> hjulle: well i tried. I wrote "rep (x:xs) y = (length y, [l1 (cplW y 1) x : [rep xs (vRec y (l1 (cplW y 1) x) 1)]])" but i have type issue after that
23:16:57 <hjulle> yes, because [rep ...] is of type [(Int,[[Int]])] and you need type [[Int]]
23:16:59 <dmtd> Walther: it says xy is not in scope, and then for thing it says: thing :: [a] -> a. Does the a mean it couldn't find a type?
23:18:15 * hackagebot yesod-core 1.4.20 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.20 (MichaelSnoyman)
23:18:17 * hackagebot yesod-auth 1.4.13 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.13 (MichaelSnoyman)
23:18:31 <hjulle> Newby: [x:xs] means "create a list with one element wich is itself a list of x added to the list xs"
23:18:45 <Newby> hjulle: yeah i know
23:19:02 <Newby> hjrep (x:xs) y = (length y, l1 (cplW y 1) x : snd([rep xs (vRec y (l1 (cplW y 1) x) 1)])) i'm getting closer but still have 1 error
23:20:06 <Newby> hjulle: Couldn't match expected type `(a0, [[Int]])' with actual type `[(Int, [[Int]])]'
23:20:09 <hjulle> Newby: try adding some let/where-clauses and specify the types explicitly of the parts. That usually helps clearing up the type mess.
23:21:45 <Newby> hjulle: why does it say curent type is  `[(Int, [[Int]])]' when the result is not even in a list ? ^^'
23:22:28 <hjulle> snd [a] is obviously impossible because snd :: (a,b) -> b, and [a] :: [a]
23:23:05 <hjulle> You are giving snd a list: "snd([rep ..."
23:23:15 * hackagebot yesod-persistent 1.4.0.4 - Some helpers for using Persistent from Yesod.  https://hackage.haskell.org/package/yesod-persistent-1.4.0.4 (MichaelSnoyman)
23:23:17 * hackagebot yesod-form 1.4.7 - Form handling support for Yesod Web Framework  https://hackage.haskell.org/package/yesod-form-1.4.7 (MichaelSnoyman)
23:23:35 <Newby> hjulle: my rep type is a tuple
23:23:54 <Newby> ho nvm
23:23:55 <hjulle> yes, but [rep ...] is a singleton list
23:25:08 <hjulle> Newby: Anyways, you should probably use some variables for the parts of the expression, so it becomes readable.
23:25:15 <Newby> hjulle: i have a new error type :p
23:25:53 <Newby> i don't really know how to use variables in Haskell ^-^' 
23:26:22 <hjulle> let {x = asdf; y = qwer} in x + y
23:27:36 <hjulle> or f x = y + z \n where y = g z \ n z = h y
23:28:02 <hjulle> (\n should be newline)
23:29:06 <Ashy> thoughtpolice: is there a writeup somewhere on how to profile ghc itself?
23:31:57 <Newby> hjulle: I found the solution !!! Thank you for your help (i didn't use variables but listen to your advice)
23:32:10 <Newby> hjulle: i was stuck for hours...
23:32:23 <lpaste> hjulle revised “Matrix”: “No title” at http://lpaste.net/157410
23:32:58 <hjulle> Here is an example of how you could use variables
23:33:23 <lpaste> hjulle revised “Matrix”: “oops, typo” at http://lpaste.net/157410
23:33:59 <hjulle> Newby: Fill in the underscores with the actual types.
23:34:10 <Newby> hjulle: okay ^^ thx
23:35:52 <hjulle> Newby: Btw, I got the result (7,[[5],[3,7],[1,2,3,4,5,7],[4,5,7],[1,3,4],[5,6,7],[]]) when running the fixed program, so I think there was another small error.
23:36:31 <Newby> hjulle: yes that's what i got to. I only need to find how to remove the [] at the end
23:37:12 <hjulle> Newby: .. or not add it in the first place ;)
23:37:53 <hjulle> Try to figure out where it comes from.
23:38:34 <Newby> hjulle: yes xD. The stop condition is 'if length of the left input =1 return (length y, [l1 (cplW y 1) x]' 
23:38:46 * hackagebot wai 3.2.0.1 - Web Application Interface.  https://hackage.haskell.org/package/wai-3.2.0.1 (MichaelSnoyman)
23:38:48 * hackagebot wai-app-static 3.1.5 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.5 (MichaelSnoyman)
23:38:48 <Newby> hjulle: now i have to find how to translate this in Haskell xD
23:38:50 * hackagebot conduit-extra 1.1.12 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.12 (MichaelSnoyman)
23:40:39 <hjulle> Newby: There is a much easier fix :)
23:41:30 <Newby> hjulle: with the line "rep (x:xs) _ = (0,[[]])" ?
23:41:46 <hjulle> Exactly
23:42:09 <hjulle> or wait, do you have a line like that? :S
23:42:27 <Newby> hjulle: yes ^-^'''
23:42:56 <hjulle> How does your code look now?
23:45:02 <Newby> line 1,2,3 didn't changed and i fixed the 4th
23:45:19 <hjulle> I thought it looked like "rep [] _ = (0,[[]])"?
23:45:36 <hjulle> Btw, the first case is redundant.
23:46:25 <hjulle> > length [[]]
23:46:26 <Newby> hjulle: line 8th on the lpaste
23:46:27 <lambdabot>  1
23:47:20 <Newby> hjulle: True...
23:48:42 <Newby> hjulle: but still don't know how to not add the final [] ^^
23:50:04 <hjulle> You need to remove 2-4 characters from the code
23:51:07 <Newby> rep :: [Int] -> [Int] -> (Int,[[Int]])   \n  rep [] _ = (0,[[]])   \n   rep (x:xs) y = (length y, l1 (cplW y 1) x : snd(rep xs (vRec y (l1 (cplW y 1) x) 1)))
23:51:15 <Newby> My code is like that atm
23:51:41 <Guest31866> when you use "malloc" from Foreign.Marhsal.Alloc, do you have to worry about freeing the same you would in an imperative language? or does haskell garbage collection take care of it
23:51:46 <hjulle> Newby: How long is the list in "rep [] _ = (0,[[]])"?
23:52:08 <Newby> hjulle: the input list?
23:52:24 <hjulle> Newby: The output list.
23:52:46 <Newby> hjulle: length 1? x)
23:53:14 <Newby> hjulle: ok it worked....
23:53:33 <hjulle> =D
23:53:38 <Newby> hjulle: >_____<
23:53:41 <Hijiri> Guest31866: You have to worry
23:54:08 <Hijiri> If you  want it to be automatic, use  alloca
23:54:40 <Hijiri> it can't detect when it's safe because C code could still be using the memory
23:54:44 <Guest31866> Hijiri: ty
23:54:49 <Hijiri> e.g. in another thread
23:55:35 <Newby> hjulle: Thanks a lot!
23:56:18 <hjulle> np
23:58:47 <Newby> hjulle: but it's to late to sleep for me now T_T. Have to go to class
