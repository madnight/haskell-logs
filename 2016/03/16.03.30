00:33:45 * hackagebot true-name 0.1.0.1 - Template Haskell hack to violate module abstractions  https://hackage.haskell.org/package/true-name-0.1.0.1 (LiyangHu)
00:36:02 <adarqui> anyone here use mysql-simple? having a problem trying to supply a value to LIMIT, ie, query "select * from blah LIMIT ?" [limit] .. seems like it's doing LIMIT '1' for example, which is breaking the query
00:39:10 * hackagebot conduit-extra 1.1.12.1 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.12.1 (MichaelSnoyman)
00:39:55 <adarqui> i may have figured it out
00:40:08 <adarqui> query "blah LIMIT ?" (Only 1)
00:52:51 <zRecursive> How to fix "<interactive>: C:\haskell\ghc-7.10.3\lib\time_IYbjC7tGONY15oDy1fGJKz\HStime-1.5.0.1-IYbjC7tGONY15oDy1fGJKz.o: unknown symbol `__localtime32'" ?
00:55:52 <sandbox> hello
00:56:10 <sandbox> is there any human in this channel ?
00:56:32 <hjulle> No, there are only bots here.
00:56:38 <sandbox> k den
00:56:44 <hjulle> :)
00:57:26 <liste> Haskell is too hard for humans to comprehend, that's why there's only bots here (/joke)
00:57:47 <sandbox> LISP > HASKELL *grabs popcorn
00:58:26 <hjulle> > "LISP" > "HASKELL"
00:58:28 <lambdabot>  True
00:58:39 <Hafydd> Hahah.
00:59:10 <sandbox> "BATMAN V SUPERMAN" > "HASKELL"
01:00:13 <liste> > LISP > HASKELL
01:00:15 <lambdabot>  False
01:00:34 <hjulle> > LISP < HASKELL
01:00:37 <lambdabot>  True
01:00:50 <liste> lambdabot knows
01:01:09 <rydgel> > PHP < HASKELL
01:01:11 <lambdabot>  Not in scope: data constructor ‘PHP’
01:01:14 <rydgel> lel
01:01:19 <sandbox> nope
01:01:32 <sandbox> PHP > (HASKELL * 99999999999999999)
01:01:59 <sandbox> 2+2
01:02:17 <sandbox> lamdabot 2+2
01:02:21 <sandbox> lambdabot 2+2
01:02:26 <sandbox> @lambdabot 2+2
01:02:26 <lambdabot> Unknown command, try @list
01:02:32 <sandbox> try @list
01:02:35 <sandbox> @list
01:02:36 <lambdabot> What module?  Try @listmodules for some ideas.
01:02:40 <liste> sandbox: try /q lambdabot @listmodules
01:02:42 <sandbox> list
01:03:09 <sandbox> lambdabot @listmodules
01:03:12 --- mode: ChanServ set +o shachaf
01:03:21 <liste> sandbox: you missed the /q
01:03:34 <sandbox> didn't work
01:03:45 <sandbox> /q lambdabot @listmodules
01:03:48 <liste> it opens a new window/tab
01:03:53 <sandbox> nope
01:05:04 --- kick: sandbox was kicked by shachaf (sandbox)
01:06:41 <hjulle> > LISP > HASKELL *grabs popcorn
01:06:43 <lambdabot>  False
01:07:18 --- mode: shachaf set -o shachaf
01:37:54 <merijn> Hmmm, I want an "invalidatable" TVar, i.e. updates should be disallowed after some time, so I just insert an extra Bool to track this an rely on STM atomicity? Or is there a better idea?
01:43:51 <j0llyr0tten> could someone explain this?
01:43:52 <j0llyr0tten> (1 2) :: (Num (a -> t), Num a) => t
01:44:45 <liste> j0llyr0tten: number literals are polymorphic, so they can (theoretically) be functions
01:44:53 <j0llyr0tten> oh
01:45:03 <liste> if you define a Num instance for (a -> t)
01:45:27 <j0llyr0tten> :t (False True)
01:45:28 <lambdabot>     Couldn't match expected type ‘Bool -> t’ with actual type ‘Bool’
01:45:28 <lambdabot>     The function ‘False’ is applied to one argument,
01:45:28 <lambdabot>     but its type ‘Bool’ has none
01:45:35 <liste> False and True are not polymorphi 
01:45:41 <j0llyr0tten> :)
01:45:45 <merijn> :t 1
01:45:46 <lambdabot> Num a => a
01:45:50 <merijn> :t False
01:45:51 <lambdabot> Bool
01:45:57 <j0llyr0tten> ohhh
01:46:21 <merijn> j0llyr0tten: Numeric literals can be any type that is an instance of Num :)
01:46:31 <merijn> The advantage is you can do things like
01:46:34 <merijn> > 1 :: Complex Double
01:46:35 <lambdabot>  1.0 :+ 0.0
01:46:55 <merijn> > 3 + (1.5 :+ 2.3)
01:46:57 <lambdabot>  4.5 :+ 2.3
01:47:55 <merijn> j0llyr0tten: But it gets a little confusing when you write things like "1 2". The error gives a hint "Num (a -> t)" <- this is saying it's looking for a Num instane for the type "a -> t" at which point you should think "mmm, that looks off..."
01:48:33 <j0llyr0tten> may i ask a really basic question: t ::= v | abs | app     abs ::= \ x . t     app ::= t t
01:48:55 <j0llyr0tten> so app could be     x x       what does it mean to apply a var to a var?
01:49:18 <jophish> > let x = 0 in sin x
01:49:19 <lambdabot>  0.0
01:49:24 <lyxia> variables are meant to be substituted
01:49:42 <jophish> `sin x` is a var applied to a var
01:49:49 <j0llyr0tten> i mean app could be      v v       what does it mean to apply a var to a var?
01:49:56 <hjulle> j0llyr0tten: What language is that?
01:50:08 <j0llyr0tten> just POLC
01:50:17 <j0llyr0tten> Plain ol' lambda calculus
01:51:20 <lyxia> it means that the context should bind the applied variable to a function so that you can keep reducing.
01:51:37 <merijn> j0llyr0tten: Note that since every value in LC is a function, so variables always hold functions
01:51:47 <j0llyr0tten> lyxia: but the first term may not be a function, it may be a variable!
01:51:49 <merijn> j0llyr0tten: Therefore "applying a var to a var" is just function application
01:51:56 <j0llyr0tten> according to my reading of the texts
01:52:11 <nineonine> could someone help me out with wrapping FreeT in newtype ? im getting an error
01:52:15 <merijn> j0llyr0tten: If the first variable is free (i.e. unspecified) the term isn't reducible
01:52:36 <nineonine> http://lpaste.net/157625
01:52:47 <nineonine> the error says
01:53:09 <nineonine> The second argument of ‘FreeT’ should have kind ‘* -> *’,
01:53:10 <nineonine>   but ‘m’ has kind ‘*’
01:53:15 <dmwit> j0llyr0tten: One should be careful to say what they mean by "mean".
01:53:29 <j0llyr0tten> merijn: so what happens then is implementation dependent? or could the answer be "Nothing"
01:53:39 <j0llyr0tten> dmwit: LOL
01:54:00 <nineonine> in the type FreeT (BaseF m) m a
01:54:11 <dmwit> j0llyr0tten: Often the "meaning" of a LC term is given in terms of a context which maps all unbound variables to other terms.
01:54:20 <dmwit> j0llyr0tten: That was not a joke. I'm very serious.
01:54:58 <dmwit> j0llyr0tten: And moreover there are well-formedness rules about the context saying that the terms that variables are mapped to may only refer to earlier variables.
01:55:09 <merijn> nineonine: Unused type parameters are inferred as having kind *
01:55:17 <merijn> nineonine: Provide an explicit KindSignature for BaseF
01:55:23 <dmwit> j0llyr0tten: So to ask "what is the meaning of `v v`?" without giving a context that maps `v` to some term is not an answerable question.
01:56:12 <merijn> nineonine: "data BaseF :: (* -> *) -> * -> * where" is probably what you want (plus {-# LANGUAGE KindSignatures #-})
01:56:29 <dmwit> j0llyr0tten: One can certainly ask about the meaning in a context which does not map `v` to any other term; in such a case the only answer you can give is "`v v` does not take any reduction steps".
01:56:43 <merijn> nineonine: Or "data BaseF (m :: * -> *) (a :: *) where"
01:56:43 <dmwit> j0llyr0tten: (This is called a "stuck term" by some.)
01:57:18 <nineonine> it worked !
01:57:20 <nineonine> thanks
01:58:50 <j0llyr0tten> dmwit: I said LOL because i do philosophy and "meaning making" is a central concern to us
01:59:01 <j0llyr0tten> :t ("a" "b")
01:59:02 <lambdabot>     Couldn't match expected type ‘[Char] -> t’
01:59:02 <lambdabot>                 with actual type ‘[Char]’
01:59:02 <lambdabot>     The function ‘"a"’ is applied to one argument,
01:59:21 <j0llyr0tten> so that could be interpreted as a "stuck term" ?
01:59:26 <nineonine> merijn: thanks a lot !!! i've been trying to fix it the whole day :)
01:59:59 <dmwit> j0llyr0tten: Indeed.
02:00:02 <merijn> nineonine: If you'd used 'm' somewhere it would've been inferred fine, it's just that you need to know the (fairly obscure) fact that ununsed type parameters are always inferred as * :>
02:00:09 <dmwit> j0llyr0tten: There is also a theorem that well-typed terms do not get stuck.
02:00:24 <merijn> Not really a theorem as much as a definition
02:00:41 <dmwit> No, it is a theorem. It requires some work to prove.
02:00:47 <ggVGc> I've concluded that working with records in haskell without lenses is an excercise in masochism
02:00:55 <ggVGc> it's really really bad, or I'm really really bad
02:01:02 <nineonine> I wonder why didnt it work when I added (Monad m)  => constraint
02:01:04 <merijn> dmwit: No, I meant that the DEFINITION of "a well typed term" is "a term that does not get stuck"
02:01:18 <dmwit> merijn: No, that's not correct. There are ill-typed terms which do not get stuck.
02:01:22 <merijn> dmwit: Not that it doesn't require a proof to prove that's the case :)
02:01:27 <dmwit> merijn: e.g. `if True then "a" else ()`
02:01:36 <j0llyr0tten> dmwit: that's why i said that maybe the type of (Literal Literal) is Nothing (Bottom) because it reminds me of functions which are guaranteed not to return
02:01:44 <merijn> hmm, good point
02:02:06 <merijn> ggVGc: It depends on whether you're nesting a lot
02:02:07 <dmwit> j0llyr0tten: Bottom is a different beast.
02:02:08 <ggVGc> what does it mean for a term to "get stuck"
02:02:24 <ggVGc> merijn: just two levels of nesting is already crappy. BUt I don't know how to write my software in another way, yet
02:02:26 <dmwit> ggVGc: It means no reduction rules apply, and the term is not yet a value.
02:02:33 <ggVGc> ah okay
02:02:36 <ggVGc> thanks
02:02:42 <j0llyr0tten> "get stuck" here means an irreducible application
02:03:06 <ggVGc> why doesn't "if True then "a" else ()" get stuck?
02:03:18 <ggVGc> it seems like it does to me?
02:03:24 <dmwit> ggVGc: Because there is a reduction rule for if-then-else terms that can fire.
02:03:50 <dmwit> ggVGc: Namely, the rules are `if True then e1 else e2` reduces to `e1`, and similarly, `if False then e1 else e2` reduces to `e2`.
02:03:59 <ggVGc> ah right
02:04:11 <ggVGc> so the term is ill-typed, but it can be reduced to something well-typed
02:04:12 <dmwit> ggVGc: (If we're being careful, we should talk about contexts and stuff. But for now let's just talk about closed terms.)
02:04:12 <ggVGc> interesting
02:04:28 <dmwit> Indeed, well-typed-ness is generally preserved by reduction but not by expansion.
02:05:52 <j0llyr0tten> dmwit: I'd like to argue that point. Because bottom can be used for functions that raise exceptions. This is like raising an exception "i'm stuck: ..."
02:06:13 <dmwit> POLC doesn't have exceptions.
02:06:31 <j0llyr0tten> POLC has Bottom, right?
02:06:32 <merijn> All bottoms are the same in POLC
02:06:41 <dmwit> POLC has non-terminating terms.
02:06:49 <merijn> j0llyr0tten: You can't distinguish different kinds of non-termination
02:07:07 <j0llyr0tten> Ok, i do mean POLC with types
02:07:19 <dmwit> "bottom" is a denotational semantics concept, which is in some sense slightly outside the purview of POLC.
02:07:22 <j0llyr0tten> Not untyped POLC
02:07:38 <j0llyr0tten> dmwit: ok, totally agreed
02:07:46 <dmwit> STLC does not have non-terminating terms (and hence does not have any terms whose denotation is bottom).
02:07:49 <ggVGc> what is PO in POLC?
02:07:52 <j0llyr0tten> merijn: elaborate?
02:07:55 <merijn> ggVGc: Plain Old
02:08:00 <ggVGc> that'swhat I figured :)
02:08:12 <j0llyr0tten> like POJO, Plain ol' Javascript Objects
02:08:34 <merijn> j0llyr0tten: Which kinds of types? Do you mean Simply Typed LC?
02:08:42 <merijn> Because STLC does not have non-termination
02:09:11 <dmwit> I will admit that I don't know off the top of my head what denotation is given to stuck terms.
02:09:25 <j0llyr0tten> dmwit: THANK YOU!
02:09:47 <j0llyr0tten> that is what i am trying to find out, i can't find a reference to it anywhere
02:09:57 <j0llyr0tten> if it is in TAPL i can't see it
02:10:19 <dmwit> I would guess that denotations are given only to closed terms (which can't get stuck, I don't think).
02:10:30 <j0llyr0tten> i'll Google "stuck terms", should i Google anything else?
02:10:55 <dmwit> For small-step semantics, there is nothing further to say about stuck terms than "no reduction applies".
02:11:12 <j0llyr0tten> if i asked this over on ##typetheory i'd never get an answer, they'd say i'm "holding it wrong"
02:11:21 <merijn> I think TaPL used the denotation that types are sets of values and that bottom is an element that's in the set of every type
02:11:33 <merijn> And non-termination is equated to this bottom element
02:11:41 <j0llyr0tten> dmwit: so just come up with an operational semantics for "no reduction applies"
02:11:50 <merijn> TaPL doesn't bother giving a denotation for stuck terms as they proof that well-typed terms cannot get stuck
02:11:58 <dmwit> j0llyr0tten: ...huh?
02:12:29 <merijn> i.e. it only gives a denotation of well-typed terms and thus avoids the need to invent a denotation for stuck terms
02:12:42 <j0llyr0tten> yes, but if you can query the type, like :t foo   where foo is a stuck term it'd be nice to have a reasonable answer
02:12:44 <dmwit> j0llyr0tten: An operational semantics is nothing more than a collection of reduction rules. If none of them applies... then... none of them applies.
02:13:04 <merijn> j0llyr0tten: If well-typed terms cannot get stuck, then a stuck term is by definition, not well-typed
02:13:15 <merijn> Therefore you can't give a type to stuck term
02:13:22 <j0llyr0tten> it's the bottom of a set of operational semantics
02:13:39 <merijn> Now you're mixing semantic domains
02:13:42 <dmwit> Operational semanticses don't have bottoms.
02:13:55 <j0llyr0tten> that's ok. you know what i mean
02:13:59 <dmwit> No. I don't.
02:14:03 <merijn> j0llyr0tten: I actually don't :)
02:14:14 <j0llyr0tten> the meta-language is a language
02:14:14 * hackagebot werewolf-slack 0.1.0.0 - A Slack chat client for playing werewolf (https://github.com/hjwylde/werewolf)  https://hackage.haskell.org/package/werewolf-slack-0.1.0.0 (hjwylde)
02:15:48 <dmwit> TAPL doesn't cover denotational semantics at all. So I question merijn's claim that it uses the denotation that types are sets.
02:16:27 <merijn> dmwit: I admit I might be mixing things up :)
02:18:39 <j0llyr0tten> Definition 1. A closed term t is stuck if t is not a value and t 
02:18:41 <j0llyr0tten> → v .
02:19:39 <j0llyr0tten> oof, pasted across two lines. That's from pg. 123 of "Foundations of software science and computational structures: 15th international conference, FOSSACS 2012"
02:20:05 <dmwit> I would bet that arrow there is actually a crossed-out arrow.
02:20:18 <j0llyr0tten> yes
02:20:23 <dmwit> I also wouldn't be surprised if there was a star in there.
02:20:30 <j0llyr0tten> it is, and the v is a subscript
02:20:54 <dmwit> The v is a subscript? Huh.
02:21:55 <j0llyr0tten> Yeah, I'll pastebin it
02:22:39 <montanonic> How do I only test a single file using `stack test`? I'm having difficulty figuring out the proper syntax
02:22:46 <dmwit> Don't bother, I believe you.
02:24:52 <user_9753> http://ah.pe/bCJ
02:26:08 <montanonic> From this: http://docs.haskellstack.org/en/stable/build_command/?highlight=stack%20test, it seems like `stack build` works only on the level of a package? Is there anyway to just get it to operate on individual files, or the contents of a folder?
02:26:37 <srhb> montanonic: Not afaik, but you can specify targets (defined in the cabal file) after build or test.
02:26:39 <montanonic> As my test suite grows, I'm tiring of having to run the *entire suite*, just to check if my latest test works
02:26:55 <j0llyr0tten> dmwit: merijn: thanks for letting me bounce those ideas off you
02:27:01 <montanonic> srhb: how might I do that?
02:27:22 <montanonic> srhb: I'm alright with compiling the whole thing so long as when I run the tests I can pick which ones to run
02:27:37 <srhb> montanonic: stack test yourTest?
02:27:54 <merijn> montanonic: You can have multiple test-suite definitions in your cabal file and have it only run a named suite
02:28:04 <merijn> With cabal anyway, so I'm assuming stack does too
02:28:11 <montanonic> merijn: oh, okay, so I have to do it in cabal
02:28:14 <srhb> merijn: Correct.
02:28:23 <montanonic> Yeah, that's what it says, I was just wondering if there was another way
02:28:45 <srhb> montanonic: Make your test thingy take a command line argument to decide what to do
02:28:48 <montanonic> I'm using Yesod's scaffold which has a built-in test set-up, and so I'm a bit noob-ish on how to do anything beyond what's pre-loaded
02:29:01 <dmwit> cabal test also has a tagging mechanism in its interface. But I haven't used it so I can't say much more than "look in the documentation".
02:29:10 <dmwit> It has a way to run only tests with a certain tag.
03:11:12 <Nahiyan> hi everyone I have a small question
03:11:25 <Nahiyan> code: [... | (x:y,z)<-[(a,b),(b,a)], ...]
03:11:41 <Nahiyan> from a function definition that takes arguments a and b
03:11:59 <Nahiyan> what does the comma , operator in the tuple mean?
03:12:06 <Nahiyan> (x:y,z) <-
03:12:21 <Nahiyan> oh... I just understood..
03:15:15 <opqdonut> oh that's tricky
03:15:41 <Nahiyan> I think it's just (x:y,   b)
03:15:57 <dogui> Nahiyan: yeah, it's that
03:16:05 <Nahiyan> so x=a, y=b, and z = (b,a)
03:16:05 <opqdonut> yeah it is
03:16:13 <Nahiyan> so stupid...
03:16:13 <dogui> > :t \a b -> [ (x,y,z) | (x:y,z) <- [(a,b), (b,a)]]
03:16:15 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:16:18 <dogui> :t \a b -> [ (x,y,z) | (x:y,z) <- [(a,b), (b,a)]]
03:16:19 <lambdabot> [t] -> [t] -> [(t, [t], [t])]
03:16:22 <dogui> pretty cool
03:16:33 <Nahiyan> confused myself >_<
03:16:36 <Nahiyan> anyway gtg ty!!
03:16:44 <opqdonut> it's a tricky way of going through the cases "x:y=a, z=b" and "x:y=b, z=a"
03:16:55 <dogui> careful, z is not (b,a)
03:17:00 <Nahiyan> huh...
03:17:01 <dogui> it's as opqdonut says
03:17:06 <dogui> try it and see what happens
03:17:17 <Nahiyan> ok I'll try it later after I come back sorry thanks!!
03:17:29 <dogui> no need to say sorry man, see ya!
03:17:36 <Nahiyan> ok ty :) bye!
03:57:37 <hiddenlotus> exit
04:03:04 <Guest81952> http://shrinkmy.com/ZFmSN1C6
04:25:51 <puregreen> montanonic: “stack test” has an argument “--test-arguments” that lets you pass arguments to the test executable
04:26:40 <puregreen> montanonic: and I think testing frameworks usually interpret those arguments and let you run some particular test (if the tests are named) or do other changes to the process
04:27:16 <montanonic> puregreen: that's helpful to know, I'll try that out
04:28:07 <montanonic> puregreen: thank you
05:05:15 * hackagebot ghc-imported-from 0.3.0.2 - Find the Haddock documentation for a symbol.  https://hackage.haskell.org/package/ghc-imported-from-0.3.0.2 (CarloHamalainen)
05:05:17 * hackagebot RNAlien 1.1.1 - Unsupervized construction of RNA family models  https://hackage.haskell.org/package/RNAlien-1.1.1 (FlorianEggenhofer)
05:08:31 <riaqn> Hi, now I defined 'Data Mytype a = Mycons a'. How I get the type Mytype $ Mytype $ Mytype ... ?
05:09:02 <riaqn> oops, 'Data' should be 'data'
05:09:08 <Fylwind> riaqn: Mycons (Mycons (Mycons …
05:09:25 <riaqn> Nop, I want to get the type.
05:09:41 <Fylwind> Mytype (Mytype (Mytype …))) ?
05:09:57 <riaqn> yes, how can I write it? 
05:10:08 <Fylwind> oh you want an INFINITE stack?
05:10:33 <Fylwind> you can't do that in Haskell without wrapping it in another type
05:10:52 <riaqn> Ok, so that's the only way out.
05:11:02 <riaqn> thank you.
05:17:03 <merijn> riaqn: You want "Mu"
05:17:20 <merijn> "newtype Mu f = Mu (f (Mu f))
05:17:45 <riaqn> merijn: huh, yes I got it. thank you.
05:22:19 <hjulle> Can you launch ghci from inside haskell? (not the executable, the session should live in the same runtime (and possibly have access to variables from the parent))
05:24:29 <aweinstock> hjulle: I think https://hackage.haskell.org/package/hint does something similar?
05:25:48 <hjulle> Yeah, that sounds promising.
05:33:21 <maerwald> anyone got leksah working with yi?
05:46:37 <merijn> Man, I wish Prelude exported Data.Tuple.swap...having to add an import kinda defeats the advantage of not defining it inline
05:55:34 <Fylwind> merijn, riaqn: FYI some places call Mu "Fix" or just "F"
05:55:36 <Lewix> 1. Why was haskell designed ? 2. What is it mainly used for? 3. what are its stength? (saying that it's a general purpose language is not helpful)
05:57:16 <Walther> Why not? :) It's used for a plenty of things, and among others, it's a nice "r&d language" where new features get invented and implemented and other languages can follow
05:57:42 <Walther> Strengths - separation of pure and impure code (e.g. IO actions)
05:57:51 <Fylwind> merijn: I have that same sentiment about a lot of functions :P
05:57:52 <Walther> others can probably fill me in here
05:58:03 <ahihi> the "why" is described in http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
05:59:38 <pchiusano> when will a Haskell thread be GC'd?
06:00:04 <tdammers> pchiusano: first thought: if you need to ask, then your design is probably wrong ;D
06:00:34 <pchiusano> will the thread be GC'd if a) it is blocked on a TQueue or MVar read that no other thread has access to?
06:01:20 <pchiusano> tdammers: eh, I don't agree
06:01:21 <tdammers> Lewix: re 2., haskell is most seen in the wild in R&D, language design, and generally anything that requires strong compile-time assertions in unusual problem domains. It's also somewhat popular in finance and insurance.
06:02:26 <tdammers> Lewix: which probably also hints at its strengths. IMO, the unique selling point is the type system, and how the type system also captures all sorts of effects, which makes for very reliable and maintainable code
06:03:06 <tdammers> Lewix: another strong point is applying a DSL approach, i.e., design a domain-specific language that fits your problem domain, and solve the problem in the DSL
06:03:48 <ertes> the type system also serves as a tool in haskell…  it guides you toward a solution…  it helps you *make* types and write implementations quickly, because it's very interactive
06:04:06 <ertes> not yet agda/idris-interactive, but very still interactive compared to most other languages
06:05:08 <Gurkenglas> Can you make ghci attempt to minimize token length of the type returned for an expression by using type aliases?
06:06:56 <ertes> Gurkenglas: i believe it doesn't expand type aliases unless necessary, but type classes (more precisely instances) can screw that up
06:07:18 <Lewix> tdammers: I see. r&d, language design, somewhat finance and insurance. A strong type system and good for DSL 
06:07:32 <ertes> Gurkenglas: you can probably use -XTypeSynonymInstances to limit that, but only for your own instances
06:07:51 <tdammers> Lewix: still, it's first and foremost a general-purpose language
06:08:00 <ertes> Lewix: good for interactive development (at least with emacs)
06:08:15 <ertes> "rapid prototyping", as people like to call it
06:09:24 <tdammers> Lewix: I don't really use it for any of these, except maybe language design; my use cases are web development, web services, development tools, scraping, text / document analysis, data wrangling in general, music notation, systems programming, and about a dozen other domains
06:09:44 <tdammers> and yes, Haskell is great for prototyping, as counterintuitive that may sound
06:10:13 <tdammers> it's a strongly typed language, but you can still start out with very generic data structures and refine them as your program evolves
06:10:30 <Lewix> tdammers: is it your languae of choice for most of it? What languages have you had experience with in the past and how does it compare in terms of productivity/reliability/ecosystem
06:11:08 <Lewix> tdammers: web development, web services will be my use case
06:11:34 <ertes> Gurkenglas: just tried…  type synonym instances don't even help there
06:11:47 <tdammers> haskell is my go-to language. I've done, let's see, Pascal, C, C++, JS, PHP, Python, C#, Java, VB.NET, Clojure, Bash, and a bit of Scheme, Common Lisp, Perl, Ruby, ...
06:12:07 <ertes> Gurkenglas: data X = X; type Y = X; instance Monoid Y where { mempty = X; mappend _ _ = X }
06:12:07 <ertes> let x = mappend X X
06:12:08 <ertes> still the type is X, not Y
06:12:35 <tdammers> for all but a few niches, I would say that Haskell kicks the others around the room
06:12:46 <tdammers> as far as my personal needs and preferences are concerned, anyway
06:12:49 <Lewix> here is the thing, I want to build a platform that handles transactions on a daily basis. User make and receive payments concurrently. The platform will talk heavily with an external  API no built by us (example twitter) and fetch and send data heavily
06:13:45 <ertes> Lewix: one weak point of haskell is that you usually need longer than in other languages to get a project started, because it involves more engineering (and also you might start to adopt the habit of thinking longer before you start)
06:13:51 <Gurkenglas> https://github.com/aelve/haskell-issues/issues/28 , then.
06:13:56 <Lewix> tdammers: is it ideal for haskell? library easy to find...basically i don't want my productivity to be hindered
06:14:02 <twoolie> Lewix, Haskell excells at all those things
06:14:07 <twoolie> ask the Haxl peeps
06:14:13 <ertes> Lewix: at least for the use case of quick-n-dirty scripting people have written libraries, but that's really a niche
06:14:39 <bartavelle> where Haskell isn't too mature IMO is observability of the production system
06:14:57 <twoolie> bartavelle, EKG does a pretty good job
06:15:00 <bartavelle> this can be compensated with lower bug rate, but I don't think this is enough in all cases
06:15:11 <tdammers> ertes: I don't really agree... if you're venturing into a new problem domain, getting started takes a little while due to reading up on the relevant libraries and APIs, but if you already know what you need, starting a new project doesn't have more overhead than any other language
06:15:17 <bartavelle> twoolie, it only covers memory monitoring AFAIK ?
06:15:39 <Lewix> bartavelle: seems like a big deal
06:15:44 <tdammers> same drill, really - initialize project, initialize git repo, define dependencies, write stuff in Main.hs, build.
06:15:52 <twoolie> not just memory, other stats too. you can always interface with statsd if you need more fine grained stats and logging
06:16:08 <ongy> what's the best way to define a function on Integral that behaves different when the type is also an instance of Bounded?
06:16:19 <bartavelle> Lewix, it really depends on your needs ... for a very complex system I would think it to be a dealbreaker, but perhaps not for long with the DWARF stuff
06:16:26 <ertes> tdammers: that's my experience…  i usually need longer to get started, even in problem domains i'm familiar with…  bottom line is that i'm not always done faster with haskell, but i do end up with very efficient code that is easy to maintain for years
06:16:34 <bartavelle> for other use cases ... well I do use haskell everyday
06:16:57 <tdammers> ertes: yeah, but by now, I'm faster in Haskell despite doing some reading upfront
06:17:10 <bartavelle> twoolie, yet it's a far cry from what you get with stuff that work on the JVM
06:17:28 <tdammers> plus, in something like JS or Python, there's always a fat chance that at some point I fail to contain the complexity, hit a dead end, and throw away and rewrite half the code
06:17:28 * Lewix might also look into erlang
06:17:53 <tdammers> agree on the observability / monitoring thing
06:17:55 <ertes> tdammers: i might have gotten slower to start in general, but i can't tell, because since haskell i haven't really used other languages much, except for the occasional shell script
06:18:06 <tdammers> but then, a sane haskell program doesn't require as much hand-holding, so it's a tradeoff
06:18:20 <twoolie> bartavelle, true, but the JVM tends to suck all the functionality into it. Haskell is happy to interface with external services (e.g. statsd) to get the job done.
06:18:31 <ertes> and Makefiles…  i still love my Makefiles (and yes, i'm aware of shake) =)
06:18:51 <tdammers> Makefiles are nice
06:19:09 <twoolie> bartavelle, personal choice whether you want all the functionality in-ecosystem or easy interfacing with best-of breed software that already solves the problem
06:19:10 <tdammers> still, my Haskell makefiles usually contain just one rule that says stack install --haddock --test
06:19:15 <Lewix> damn bartavelle the production is really a deal breaker. The platform i have in mind is relatively complex
06:19:50 <twoolie> Lewix, what's the sticking point for you?
06:19:50 <bartavelle> twoolie, being able to dump the memory and inspect it at any moment, or know which thread is doing what just rocks
06:19:50 <bartavelle> I hope that with DWARF support and generic tooling it would be possible to get the "stack trace per thread" thing, but I don't see how one would get the "why is this green thread blocked"
06:19:57 <bartavelle> twoolie, how would you do the memory dump and analyze as a library ??
06:20:02 <ertes> tdammers: mine are longer, because i don't use cabal-install/stack
06:20:04 <tdammers> Lewix: it's not like you cannot monitor Haskell processes at all, you just can't inspect the GHC runtime as deeply as you can inspect the JVM
06:20:13 <bartavelle> this has to be part of the runtime
06:20:49 <bartavelle> twoolie, also haskell programs are in my experience a lot less complex than the equivalent java, especially for multi threaded services
06:21:03 <twoolie> of course it's going to be easier to inspect an interpreted language at runtime.
06:21:15 <ertes> Lewix: we have all the abstractions for logging and monitoring though…  you really just need to use them
06:21:54 <ertes> what we don't have are good bindings to existing tools like the unforunately very popular zabbix and similar things
06:22:27 <ertes> but they usually provide simple shell interfaces anyway, so it shouldn't be a big deal
06:22:31 <hjulle> aweinstock: Unfourtunately "hint" wasn't what I needed. What I want is a simple repl, hint is an api for accessing the interpreter, on which it would at least be very difficult to build a repl. Also, I hoped for running multiple sessions at once, but the interpreter is apparently not thread safe. OTOH http://packdeps.haskellers.com/reverse/hint seems to suggest that there are plenty of packages that use hi
06:22:37 <hjulle> nt, so perhaps one of them is a repl.
06:23:58 <tdammers> yeah, that's another angle to the story - writing sane multi-threaded Haskell code is much easier than doing it in Java, so debugging thread deadlocks on a production system is not something you'll be doing on a daily basis
06:24:35 <bartavelle> there are tons of problems you get with java you won't get with haskell
06:24:51 <twoolie> NullPointerException
06:24:51 <bartavelle> it's debugging the tricky problems that only arise in production that can be hard if you did not prepare for it
06:25:06 <trollando> what´s up guys
06:25:44 <ertes> writing multi-*process* haskell is a different story though…  nowadays with distributed-process it has become easier, but there is still some engineering effort needed, especially for dealing with exceptional situations (dying processes, failing network connections, etc.)
06:26:15 <trollando> I have a question regarding haskell + vim
06:26:21 <bartavelle> trollando, shoot
06:26:22 <ertes> personally i tend not to use distributed-process, but use postfix-style communication via the filesystem and sockets, usually in JSON
06:26:38 <twoolie> ertes, cloud-haskell never took off?
06:27:21 <tdammers> ertes: I did the JSON-over-sockets/pipes thing on a recent project, but eventually changed it to HTTP
06:27:24 <ertes> twoolie: i don't really know…  distributed-process comes with complexity and i'm not sure whether i find it that elegant
06:27:29 <trollando> bartavelle, I have ghcmod-vim & neco-ghc did I need something for indentation?
06:27:55 <ertes> especially the static closure serialisation story is really ugly
06:28:02 <tdammers> main reason was because one of the components had to be in JS, and JS is notorious for doing things asynchronously and polluting stdout/stderr from all over the place
06:28:37 <tdammers> trollando: I use just a vanilla vim for Haskell, no plugins whatsoever, and I'm not missing much
06:29:21 <bartavelle> trollando, don't know what neco-ghc is, but for ghcmod-vim gives you special command for getting types and stuff. For indentation you need a syntax package (such as vim2hs)
06:29:45 <bartavelle> also something like syntastic gives you compile + show errors on save, which I find increases my productivity
06:29:51 <trollando> I saw vim2hs and hindent
06:30:25 <bartavelle> finally I use hdevtools, which is faster than ghcmod after the first save ...
06:30:27 <ertes> twoolie: you might be more productive by using ZeroMQ (or network-transport) and writing the discovery layer yourself
06:31:47 <ertes> nowadays i'm converging away from the traditional server/client model, because honestly in most situations it's used for it's stupid
06:32:55 <Lewix> Ok thanks guys I think I zeroed in my choice
06:34:05 <twoolie> Lewix, let us know how it goes
06:34:40 <ertes> Lewix: overall i'm happy with haskell, because it's fast, safe, cheap and very active (GHC comes with *interesting* new features in almost every release)…  but it has its dark sides, too, and i'm aware and honest about it
06:35:24 <tdammers> ertes: agree on the server/client thing, but in this particular case, it mapped pretty naturally
06:38:10 <ertes> my personal summary: haskell shines when you want to do engineering, and it sucks when you need to do engineering
06:38:19 <bartavelle> :)
06:38:36 <trollando> thanks bartavelle 
06:46:19 <riaqn> Fylwind: Yeah I know, recursive type.
06:46:51 <ongy> Is there a way to define a function that uses a type constraint if it is available but has a default implementation for other types?
06:48:25 <ski> ongy : i don't think so
06:48:55 <ski> (i don't think that's a reasonable thing to ask for, given OWA)
06:51:48 <ski> the closest you could get would be with `OverlappingInstances', but i think it could still be possible to get the default implementation when you expect the specialized one
06:52:12 <ski> (perhaps not if both are declared in the same module)
06:52:21 <ongy> ski: yes, if the current type cannot be infered specific enough
06:53:21 <ongy> what i wanted to do is a "save divide (x/y)" that fails gracefully for y=0, and use maxBound as value, but for unbounded (Integer) just return x
06:53:50 <ski> that sounds strange
06:54:08 <ski> what would be the use for this ?
06:54:09 <bartavelle> aeson kind of has it
06:54:16 <bartavelle> default toJSON :: (Generic a, GToJSON (Rep a)) => a -> Value
06:54:55 <bartavelle> the default implementation has extra constraints compared to the standard toJSON signature
06:55:02 <ongy> ski: I don't really care if one value is wrong so I defaulted to *something* and wanted to make it sane-ish, but there is no real reason I don't always return 1 or similar
06:55:38 <tdammers> ongy: the sane way to implement a "safe /" would have a type like :: a -> a -> Maybe a
06:55:50 <ski> how about giving `Nothing' in case the denominator is zero, and `Just q' with `q' the quotient, otherwise ?
06:56:09 <tdammers> or force the user to provide a default for the divide-by-zero case :: a -> a -> a -> a
06:57:05 * ski . o O ( `a -> (d :: a) -> (d ~ 0 => a) -> a' )
06:57:29 <ongy> those would be cleaner, I think I'll go "provide default"
06:58:00 <ongy> ski: is that related to my question?
06:58:13 <tdammers> if you have the Maybe one, writing the default one is trivial
06:58:14 <ski> ongy : one drawback with default would be that it's not always clear at the point of call what would be a sensible default value
06:58:20 <ski> (cf. exceptions)
06:58:33 <ski> ongy : only tangentially. feel free to ignore
06:58:35 <tdammers> I'd say if you're writing a library, it'd be good form to provide both
06:58:57 <ideuler> Heya! Making a distributed system, where I need to store the users that are logged in, and those who are registered. In an imperative language would probably use a global structure. Considering in haskell it is recursively listening for more clients, I seem to have no better way than to use database connections to do so?
06:59:19 <tdammers> you can have mutable variables in Haskell alright
06:59:33 <tdammers> popular choices include IORef, MVar, TVar, TMVar
06:59:57 <Clint> mute them like crazy
06:59:59 <tdammers> all else being equal, I'd probably go with TVar
07:00:33 <twoolie> ideuler, "Making a distributed system" "would probably use a global structure"
07:00:39 <twoolie> seems contradictory
07:00:45 <tdammers> oh, also, yes, what twoolie said
07:01:04 <tdammers> unless the authentication part isn't distributed
07:01:13 <Jinxit> DHT #1
07:01:47 <twoolie> use a distributed db to back authentication, try riak
07:02:34 <ideuler> Indeed. As of now was thinking only about a single server with multiple clients. And so would need to store users registered. I will look into both options, thanks twoolie and tdammers !
07:02:57 <tdammers> ideuler: that's not really a distributed system
07:03:17 <tdammers> ideuler: but, anyway, you probably still want some sort of persistence, because otherwise stopping and restarting your server will lose all users
07:04:22 <pavonia> Is there a common pattern for incrementally updating the fields of a large record value (by processing some user input)? What I'm doing ATM is having a temporary data type with the same fields but Maybe types that is initialized with Nothing values, and later converting from the temp to the real type, failing if one of the fields is still Nothing
07:04:53 <twoolie> ideuler, looked at acid-state?
07:05:54 <tdammers> pavonia: something I do sometimes is start with a default value and then incrementally construct the real value from there
07:06:30 <ideuler> twoolie looking at it now, thanks!
07:06:47 <pavonia> tdammers: By default value you mean e.g. empty Strings, zero Ints etc.?
07:07:02 <Jinxit> that's what I did last time, pavonia 
07:07:18 <Jinxit> but of course default changes between contexts
07:07:39 <pavonia> The problem with that is it becomes harder to check if a field is missing in the input
07:07:40 <ski> pavonia : i'm not sure whether it's much help, but it would be possible to use `data Foo f = MkFoo { blah :: f Blah,bleh :: f Bleh,... }', and then use `Foo Maybe -> Maybe (Foo Identity)' .. saves on defining a separate type
07:07:45 <tdammers> pavonia: whatever makes sense for your data type, but yes, probably empty strings, zeroes, etc.
07:08:08 <ggole> That
07:08:19 <ggole> 's usually called the builder pattern in other languages
07:08:33 <Jinxit> yep
07:08:35 <ggole> Where that situation is often handled with mutation
07:08:39 <tdammers> I call it the builder antipattern
07:09:08 <Jinxit> why is it different from what you're doing tdammers?
07:09:13 <tdammers> it's not
07:09:18 <tdammers> mine is also an antipattern
07:09:27 <ski> an "ideal" (static) solution might be instantiation states (as in Mercury)
07:09:29 <Jinxit> I don't see how
07:09:53 <tdammers> the problem is that your data structure is in an inconsistent state at some point
07:10:00 <twoolie> builder pattern allows you to build an object through mutation and then freeze it into an immutable object.
07:10:04 <Jinxit> no, not if your defaults make sense
07:10:10 <twoolie> the haskell solution doesn't allow that
07:10:35 <tdammers> the defaults make sense, but conceptually, you still have a half-initialized object at some point
07:10:53 <Jinxit> depends on the context
07:11:06 <Jinxit> if the defaults are enough to construct the object, then it's not half-initialized
07:11:06 <tdammers> it's not a practical problem in Haskell, because there is no way to access the incomplete object from the outside, but it's still kind of inelegant
07:11:11 <ggole> ski: is that really ideal? Sometimes the builder object/data has additional bookkeeping that can be discarded once the thing is complete, which doesn't seem to fit well with that.
07:11:16 <ertes> ideuler: in a distributed system consider authenticating by cryptographic properties
07:11:49 <tdammers> what I mean is that halfway through the construction, you have an object that is half default, half updated - it may be formally consistent at some level, but conceptually, it is not in a useful state
07:12:08 <tdammers> ertes: I think what ideuler is trying to build at this point isn't really a distributed system at all
07:12:29 <Jinxit> so you mean the problem is that not all fields are updated at once?
07:12:36 <pavonia> I found an article (I haven't read yet) suggesting the builder pattern can be expressed by comonads http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
07:12:39 <tdammers> kind of, yes
07:12:41 <ggole> That's why the builder pattern frequently introduces another type to represent the thing under construction, from which you extract the final value
07:13:01 <ski> ggole : not sure what kind of additional bookkeeping you're thinking of. but i was hoping it was clear that what i mentioned would only apply in certain specific circumstances
07:15:55 <Jinxit> tdammers: I mean at some point it has to change one field at a time no matter how you twist it, I fail to see the problem
07:22:32 <aeyalcinoglu> hello, http://lpaste.net/157656 how can i write this as a function without variable (not a function with same objective, but a function with same objective/with iterate function and without variable)
07:24:14 <ski> aeyalcinoglu : are you asking about how to make it pointless ?
07:25:09 <aeyalcinoglu> ski: i don't now what pointless mean, but for example i want: not f x = 3+x but f = (+3)
07:25:28 <ski> ok, you want "pointless", aka "pointfree"
07:25:46 <ski> the "point" here referring to the input variables/parameters
07:25:57 <aeyalcinoglu> :ski good to know thanks :)
07:26:04 <ski> why do you want this ?
07:26:37 <aeyalcinoglu> :ski no reason, just challange ( i m learning haskell, obviously)
07:26:45 <ski> in many cases, it doesn't really help with readability, to make code more pointless (aka less pointful)
07:27:41 <ski> well, you could try to rewrite/massage the code so that you could drop parameters
07:27:44 <ski> something like
07:27:45 <ski>   f g n x = iterate g x !! n
07:28:01 <ski>           = (!! n) (iterate g x)
07:28:11 <ski>           = ((!! n) . iterate g) x
07:28:22 <ski>   f g n = (!! n) . iterate g
07:28:47 <ski>         = (. iterate g) (flip (!!) n)
07:28:56 <ski>         = ((. iterate g) . flip (!!)) n
07:29:06 <ski>   f g = (. iterate g) . flip (!!)
07:29:09 <aeyalcinoglu> :ski thank you! i didnt know that i could use !! like that, I will now think about it
07:29:27 <ski>   f g = (. flip (!!)) (flip (.) (iterate g))
07:29:42 <ski>   f g = ((. flip (!!)) . flip (.) . iterate) g
07:29:46 <ski>   f = (. flip (!!)) . flip (.) . iterate
07:29:49 <aeyalcinoglu> :))
07:29:57 <Clint> @pl \g n x -> iterate g x !! n
07:29:57 <lambdabot> flip . ((!!) .) . iterate
07:30:03 <ski> there's probably many other ways to do it, but that would be one way
07:33:03 <ski> aeyalcinoglu : fwiw, IRC custom, when addressing a message to someone, is to start that message with the nickname of the person in question (not prefixed by any kind of sigil like `:' or `@'). many IRC clients notify the user on such messages (but not if the nickname isn't the first thing)
07:33:59 <aeyalcinoglu> ski thanks :)
07:34:25 <aeyalcinoglu> ski: or like this?
07:34:30 <ski> that's also fine
07:34:41 <ski> some people seem to prefer to use a comma instead
07:41:43 <aeyalcinoglu> ski: (!!) :: [a] -> Int -> a, but (!! 5) :: [a] -> a and ((!!) [1,2,3]) :: Num a => Int -> a, so !! takes 2 input and we can create a function with both of them, but i thought because of type of !!, we can only create a function with ((!!) [1,2])), is this a special thing for !!?
07:42:56 <geekosaur> aeyalcinoglu, [1,2,3] is one parameter
07:43:30 <geekosaur> it is not a list of parameters, which is what you seem to be saying
07:43:31 <ski> aeyalcinoglu : this is called a "section" (specifically, left vs. right sections). it can be done with any operator (except `-', which is handled a bit specially)
07:43:48 <aeyalcinoglu> geekosaur: yes I'm aware of that, maybe I asked wrongly (I'm not native english speaker)
07:45:14 <aeyalcinoglu> ski: but for example map (+3) is a function but map [1,2,3] not, did you understand where I'm confused?
07:45:33 <geekosaur> :t map [1,2,3]
07:45:34 <lambdabot>     Couldn't match expected type ‘a -> b’ with actual type ‘[Integer]’
07:45:35 <lambdabot>     In the first argument of ‘map’, namely ‘[1, 2, 3]’
07:45:35 <lambdabot>     In the expression: map [1, 2, 3]
07:45:57 <ski> aeyalcinoglu : this is a syntactic matter. `!!' is an infix operator. `map' isn't
07:45:59 <geekosaur> actually it's a function just with an inappropriate type
07:46:28 <jacek> Hi I'm stuck with exercises on haskell-programming-0.10.2-screen.pdf
07:46:46 * geekosaur didn't think that one through fully, would need the magic list stuff for that to typecheck (and it would be a very weird type)
07:46:57 <jacek> I don't seem to understand the typeclasses to pass the exercises on page 206
07:47:04 <ski> aeyalcinoglu : `([2,3,5,7] !!) 2' means `[2,3,5,7] !! 2'. and `(!! 2) [2,3,5,7]' also means `[2,3,5,7] !! 2' (which is syntactic sugar for `(!!) [2,3,5,7] 2', where `(!!)' is the infix operator `!!' "converted" to an "ordinary expression" (function expression))
07:47:49 <ski> aeyalcinoglu : similarly, `(2 ^) 3' means `2 ^ 3' (which is `8'), but `(^ 2) 3' means `3 ^ 2' (which is `9')
07:48:34 <ski> aeyalcinoglu : with `(2 ^)', we've already provided the *left* argument to the infix operator `^', and a remaining input (such as `3') will be "placed" in the right argument position
07:48:40 <srhb> jacek: What pdf is that?
07:48:59 <ski> aeyalcinoglu : while with `(^ 2)', we've already provided the *right* argument to the infix operator `^', and a remaining input (such as `3') will be "placed" in the left argument position
07:49:09 <ski> aeyalcinoglu : does that make sense ?
07:50:16 <srhb> ski: So which one is the right and which one the left section? :-)
07:50:22 <ski> aeyalcinoglu : for completeness, `(^) 2 3' means `2 ^ 3' (not `3 ^ 2')
07:50:28 <aeyalcinoglu> :ski yes, so for !! it can understand which input should be first (a list), so if we have a binary infix operator which has to different input types, than this works?
07:50:40 <ski> srhb : i can never remember :D
07:50:46 <srhb> ski: Yeah, me too. :-P
07:50:54 <vxk> question about spock monads
07:50:58 <aeyalcinoglu> ski:  ... which as two different ...
07:51:15 <vxk> http://lpaste.net/157659
07:51:20 <vxk> i find this strange, the first function compiles
07:51:28 <vxk> the second funcgtion returns a type ambiguity error
07:51:30 <ski> aeyalcinoglu : sectioning an infix operator works the same, regardless of the types
07:51:39 <vxk> however the first function never uses its argument!
07:51:51 <vxk> how does adding a parameter to the function resolve the type ambiguity?
07:52:22 <ski> srhb : it's a bit like the question whether `a * (b + c) = (a * b) + a * c' .. is this left or right distributivity ? (imho, it ought to be right, but i'm not sure whether convention agrees)
07:52:26 <jacek> Write the Eq instance for the datatype provided.
07:52:26 <jacek> data TisAnInteger =
07:52:26 <jacek> TisAn Integer
07:52:26 <jacek> data TwoIntegers =
07:52:26 <jacek> Two Integer Integer
07:52:28 <aeyalcinoglu> ski: okay, but if types are different it 'seems' like 'commutative'?
07:52:45 <ClaudiusMaximus> vxk: MonomorphismRestriction perhaps
07:53:03 <aeyalcinoglu> :ski and is there command to check if a function is infix or not?
07:53:10 <srhb> ski: I pretend the sectioned side is where the variable is "cut away"
07:53:20 <aeyalcinoglu> ski: and is there a command to check if a function is infix or not?
07:53:21 <vxk> damn you monomorphism restriction
07:53:23 <ski> aeyalcinoglu : commutativity is unrelated. `^' being commutative would mean that `(x ^)' was the same as `(^ x)'
07:53:34 <vxk> claudiusmaximus can you elaborate how adding an argument resolves that?
07:53:47 <srhb> ski: I totally think that's right distribution too. :P
07:53:54 <ClaudiusMaximus> vxk: the MR only applies to terms without arguments
07:54:12 <ski> aeyalcinoglu : "if a function is infix or not" is meaningless. functions are values. infix or not is about syntax, before values happen
07:55:06 <vxk> claudiusmaximus thanks. i don't have a good intuition for MR errors :(
07:55:10 <aeyalcinoglu> ski: for example i can use mod, !! as an infix operator but not map, how can i check for this?
07:55:11 <ClaudiusMaximus> vxk: you can add an explicit type annotation to terms without arguments or use {-# LANGUAGE NoMonomorphismRestriction #-}
07:55:17 <ski> aeyalcinoglu : if the identifier consists of symbols, then it's an operator. you can also make an identifier consisting of (roughly) alphanumerics into an operator, by surrounding it by backticks (and you can then section it, if you like)
07:55:37 <ski> > mod 16 7
07:55:39 <lambdabot>  2
07:55:42 <ski> > 16 `mod` 7
07:55:44 <lambdabot>  2
07:55:48 <ski> > (16 `mod`) 7
07:55:50 <lambdabot>  2
07:55:54 <vxk> claudiusmaximus can you give some intuition as to what a monomorphism restriction is? i get that it has to do with type ambiguity but i don't understand how to reason about them?
07:55:56 <ski> > (`mod` 7) 16
07:55:58 <lambdabot>  2
07:56:17 <hexagoxel> @where mmr
07:56:17 <lambdabot> https://wiki.haskell.org/Monomorphism_restriction
07:56:49 <ski> jacek : done
07:57:09 <twoolie> vxk, What is the type of 7 ?
07:57:21 <vxk> that wiki page doesn't make for a great tutorial it looks like a copy-paste of a comment section
07:57:29 <vxk> twoolie ambiguous
07:58:00 * ski would rather think the wiki page *is* a comment section
07:58:01 <vxk> twoolie sure but how does the error go away just by sticking an extension at the top?
07:58:21 <vxk> claudiusmaximus it was an MR error, disappears when i include the extension
07:58:29 <twoolie> yep, so if we wrote a simple program, say main = print 7, how do we figure out the type of 7 to select a show instance?
07:59:59 <vxk> twoolie that's why Num had some defaults under the rug right?
08:00:07 <twoolie> the answer is we cheat. MonoMorphism Restriction says that instead of picking the most general type 7 :: (Integral a) => a, we will pick concrete types by certain rules to make sure that simple programs do what people expect
08:00:50 <vxk> twoolie what does "most general" mean? if multiple types just implement the same typeclass?
08:01:20 <Deved> :t (+)
08:01:21 <lambdabot> Num a => a -> a -> a
08:01:24 <vxk> and i still don't understand what changes when NoMonomorphismRestriction gets added as an extension
08:01:27 <twoolie> as in, 7 does not have a concrete type, just a typeclass restriction
08:01:42 <ski> Deved : there's also `/msg lambdabot'
08:01:46 <Gurkenglas> Can I, as the author of a typeclass and its instance, tell the monomorphism restriction what type to assume?
08:01:53 <Gurkenglas> *instances
08:02:48 <twoolie> NoMonomorphismRestriction stops picking concrete types for you. It means that main = print 7 will no longer be a valid program
08:03:23 <twoolie> because you haven't provided enough information to the typechecker for it to have a concrete type for 7
08:03:44 <twoolie> and hence, it can't select an instance of Show to use when printing
08:03:53 <gfixler> what's the difference between Float and Double?
08:03:57 <gfixler> I'm never sure which to use
08:04:14 <twoolie> Float is 32 bit IEEE floating point
08:04:18 <vxk> twoolie wouldn't that add compilation errors? how is it that compilation errors disappear when I add the extension?
08:04:22 <twoolie> Double is 64 bit IEEE floating point
08:04:36 <gfixler> ah
08:04:40 <gfixler> I just found this: https://wiki.haskell.org/Performance/Floating_point
08:04:41 <twoolie> gfixler, depends on the precision you need
08:04:46 <gfixler> point 1 is interesting
08:05:02 <twoolie> vxk, Sometimes you want your numerical code to be completely general
08:05:29 <twoolie> i.e. you want (+ 1) :: (Integral a, Num a) :: a -> a
08:05:58 <deli> :t (f 4)
08:06:00 <lambdabot> FromExpr t => t
08:06:11 <twoolie> With MMR it would be (+ 1) :: Integer -> Integer because MMR chooses a concrete type for the number
08:06:53 <Enigmagic> twoolie: the NoMonomorphism restriction wouldn't affect `main = print 7`, that's related to defaulting
08:06:54 <twoolie> NoMMR is a double-edged sword. It will fix certain problems, and break others. You must know when to use it
08:07:55 <Cale> NoMMR probably ought to be the default though :)
08:08:11 <gfixler> what is MMR?
08:08:18 <Cale> monomorphism restriction
08:08:22 <gfixler> ah
08:09:04 <twoolie> Enigmagic, It's been a while, i should probably reread the wiki page for this then. care to elaborate while i do that?
08:09:04 <Cale> It says, roughly, that if you have a pattern binding (as opposed to a function binding), which doesn't have an explicit type signature, then it's not allowed to be type class polymorphic
08:09:43 <Cale> twoolie: main's type there is not in question
08:10:05 <Cale> twoolie: and the monomorphism restriction doesn't apply to arbitrary expressions, only to pattern bindings
08:11:18 <vxk> gfixler the bane of haskell noobs :(
08:12:02 <gfixler> vxk: I've run into it many times, learned all about it each time, and promptly forgotten all I've learned immediately thereafter
08:13:32 <Cale> It's basically that if a pattern binding doesn't have an explicit type signature, then any type variables in its type which are constrained by type classes are not allowed to be generalised -- i.e. it's not allowed to be type class polymorphic
08:13:54 <Cale> The reason for this is that if you write something like
08:13:59 <Cale> x = product [1..1000]
08:14:34 <Cale> you might expect that x is computed once, and the result retained if x is used in multiple places
08:14:51 <Cale> However, if x gets a type like  x :: Num a => a
08:15:21 <Cale> then x is secretly a function of the type class dictionary, and so its value will be recomputed at each usage
08:15:52 <vxk> my problem is that it pops up in such weird places though where it's not obvious there's a type ambiguity
08:16:09 <vxk> for example this function that performs a get operation for spock
08:16:26 <Gurkenglas> If I make my typeclass relate (MaybeT m) to m instead of (IdentityT m), I save any user the need to unwrap IdentityT, but those who write general code would have to insert type signatures sometimes. Is there a third way?
08:16:32 <vxk> why the heck does adding a function parameter that never gets used suddenly resolve the type ambiguity
08:16:33 <vxk> ?
08:17:25 <Cale> vxk: if a *pattern binding* doesn't have an explicit type signature, it's not allowed to be type class polymorphic
08:17:39 <Cale> vxk: If you add a function parameter, it becomes a function binding.
08:17:46 <Cale> and so the monomorphism restriction no longer applies
08:19:14 <Cale> vxk: so then the ambiguity goes away because the decision about which type of thing you have can be deferred. You could also just add an explicit type signature.
08:20:16 <vxk> that makes sense but i wouldn't have thought of it...
08:20:16 <ski> vxk : DMR isn't really about ambiguity
08:21:04 <Cale> Well, it can cause an error about ambiguity, because it forces type variables to get resolved
08:21:34 <Cale> vxk: The MR basically just exists to protect people from writing things which they think are constants, but are actually functions that will be recomputed each time. It probably doesn't really deserve to be anything more than a warning.
08:22:09 <Cale> There are some rare cases where it actually helps code be more concise too, through numeric defaulting.
08:22:51 <Cale> But it causes confusing problems probably more often than it's actually helpful
08:24:43 <Cale> I recall at one point I got bitten by it pretty hard when I was working on some code which used the ST monad, back before forM existed in the libraries, and I'd thrown in forM = flip mapM hastily without writing a type signature, and that caused the types of my ST computations to lose their generalisation in the 's' type parameter, so I couldn't apply runST
08:25:04 <Cale> Took quite a while to work out what was going on :)
08:25:28 <hpc> Cale: haha, awesome
08:26:03 <hpc> the MR could probably have special-cased types that have (->) at their root, but that's getting pretty perl-y for haskell
08:26:45 <Cale> It really is very different from the rest of the language spec, in that it can't be justified on the basis of semantics.
08:30:35 * hackagebot mainland-pretty 0.4.1.3 - Pretty printing designed for printing source code.  https://hackage.haskell.org/package/mainland-pretty-0.4.1.3 (GeoffreyMainland)
08:33:07 <hexagoxel> i have been bitten by NoMMR when a generic type caused rather bad performance in a tight loop.
08:34:34 <Hafydd> It sounds like you were bitten by your purposeful definition of an overly polymorphic type.
08:49:39 <Gurkenglas> puregreen, may I have the ability to add labels like project to issues like https://github.com/aelve/haskell-issues/issues/29 ?
08:54:12 <puregreen> Gurkenglas: I just made you a collaborator
08:55:35 * hackagebot nist-beacon 0.2.0.0 - Haskell interface to the nist random beacon.  https://hackage.haskell.org/package/nist-beacon-0.2.0.0 (bstamour)
08:56:39 <ertes> interestingly i've never run into any issues with the MMR
08:56:50 <ertes> and my code would probably perform terribly if it weren't the default
08:57:58 <ertes> maybe i've subconsciously adapted my coding style to it (write type signatures for top-level stuff, don't write type signatures for local stuff)
09:02:11 <merijn> The reason that MMR is on by default is that it applies in cases where the compiler can make 2 choices. The MMR merely opts to make the choice "good performance and compile time error in case of mistake", where-as NoMMR opts to make the choice "always compiles, but silent performance degradation in some cases"
09:02:47 <merijn> Clearly, the explicit compile time failure is preferable to silent performance degradation, ESPECIALLY since you can get the NoMMR behaviour by simply adding a type signature
09:03:15 <johnw> merijn: agreed; it's a specious convenience in that sense
09:04:57 <ertes> i agree and wouldn't want it disabled by default
09:08:05 <ski> merijn : .. except that sometimes you can't add the explicit type signature .. without enabling `PatternSignatures'/`ScopedTypeVariables', i.e.
09:09:11 <geekosaur> which is an argument that one or both of those should become standard/on by default
09:09:29 <geekosaur> (not that we don't have lots of arguments for STV being the default already...)
09:10:07 <Gurkenglas> Why isn't there ($>)?
09:10:08 <rcat> s
09:12:02 <hpc> :t (<$)
09:12:03 <lambdabot> Functor f => a -> f b -> f a
09:12:42 <hpc> Gurkenglas: either it would be flip const, or flip (<$)
09:13:04 <hpc> and i assume the author's interpretation of what '<' and '$' mean in those symbol names would have made it flip const
09:13:08 <Gurkenglas> Yes, flip (<$)
09:13:14 <ertesx> ScopedTypeVariables should be on by default, and i was really sad that it didn't make it into H2010
09:13:20 <hpc> (lens has a similar language behind its operator names)
09:13:57 <Gurkenglas> flip const? Why?
09:15:32 <ski> ertesx : fwiw, i think the requirement with the `forall' in `ScopedTypeVariables' is exactly the wrong way around ..
09:16:11 <jophish> ski: what do you mean?
09:16:59 <ski> if i say `foo :: forall a. ..a..' and later `foo = ...', then i would expect that the `a' in the type signature is *not* in scope in the defining equation
09:17:27 <ski> otoh, if i say `foo :: ..a..', then i think it could be reasonable to allow this `a' to be in scope in the defining equation(s)
09:17:48 <ski> in the latter case, i could think of it as an implicit `forall a.' being inserted, like :
09:17:52 <ski>   forall a.
09:17:54 <ski>     foo :: ..a..
09:17:55 <jophish> I imagine that the behaviour is as it is because otherwise it could have broken existing code
09:17:58 <ski>     foo = ..a..
09:18:08 <ski> yes, i also imagine that
09:18:19 <ertesx> ski: i agree, but the other way would break code
09:18:19 <ski> (still irks me every time i think about it)
09:18:55 <impure_hate> ohai. I've got this fancy error while trying to cabal install stack - templatezmhaskell_LanguageziHaskellziTHziSyntax_zdfMonadQzuzdczgzgze_closure. what's the way out this misery as the rest of the packages is broken. reinstalling them?
09:19:07 <ertesx> although it's not completely unreasonable:  forall is a binder, so it should introduce a new variable, while without binders you should refer to variables in scope
09:19:15 <dolio> Why would quantifying the variable make it not in scope _inside_ the definition?
09:19:35 <dolio> That's backwards from how it usually works.
09:19:54 <ski> clearly `foo :: forall a. ..a..' ought to be the same as `foo :: (forall a. ..a..)'. in the latter, clearly the scope of `a' is (apparently) (only) the `..a..'
09:20:43 <ertesx> ski: i think in haskell the question itself is the problem
09:20:55 <ertesx> we have separate levels for types and values, and we have no value-level binder for types
09:21:07 <ertesx> so it's going to be awkward either way
09:21:30 <dolio> The rule for concluding `Gamma |- foo :: forall a. T` has a premise that says, `Gamma, a |- foo :: T`
09:21:53 <dolio> Typically.
09:21:55 <geekosaur> impure_hate, that looks like a link-time symbol, and suggests there's something wrong with your compiler installation
09:22:21 <ertesx> take agda for example:  if you don't bind the type as a function argument, you don't get to access it…  the type-level binder is indeed limited to the type signature
09:22:40 <ski> (fwiw, i think it would be reasonable to allow multiple type signatures for the same identifier, as long as they're all equivalent. one might want to do this, to emphasize different ways of viewing it)
09:22:43 <ertesx> if we'd be pedantic, then we would ScopedTypeVariables to be an illogical extension altogether
09:22:48 <impure_hate> geekosaur: hmm. it's ghc-7.8.4 from Fedora repos
09:22:54 <ertesx> +regard
09:23:33 <geekosaur> impure_hate, could you be missing a package then? probably a template-haskell devel package
09:23:41 <sm> impure_hate: must you install stack via cabal ?
09:24:02 <impure_hate> sm: what's the other way? doesn't seem to be included in repos
09:24:25 <sm> there are binaries for several platforms
09:24:27 <impure_hate> geekosaur: ghc-template-haskell-devel-2.9.0.0-46.fc23.x86_64 is installed
09:24:51 <impure_hate> sm: well, I do prefer installing code from source as cabal makes it quite nice
09:24:58 <nolrai2> Okay so if I am thinking about this right , while two stage computation is a monad, multi-stage isn't. 
09:25:21 <ertesx> would anyone mind if i'd ask a physics question in here?  (it's for a haskell project, but not a haskell question)
09:25:50 <ski> ertesx : fwiw, i preferred it when `PatternSignatures' allowed me to say `foo (x :: ..a..) = ..a..' or `foo :: ..a.. = ..a..', without having to introduce `a' explicitly beforehand
09:25:57 <sm> impure_hate: well, it would be quite nice if it worked.. :) but you say it's borked. If you don't care about your existing cabal package db, you could erase it and start over
09:26:21 <jophish> ertesx: sure, but you might be better in #physics or #haskell-blah
09:26:36 <impure_hate> sm: yup. sounds like the only way, I need to separate that huge library into stacks anyway so :)
09:26:54 <sm> or you can try it inside a fresh cabal sandbox
09:27:04 <impure_hate> hmm. true
09:27:11 <impure_hate> thanks for the hints!
09:27:13 <ertesx> jophish: in this particular case i believe that #physics is not a good place to ask, because it's more a question of opinion
09:27:27 <jophish> #physics is full of opinions :)
09:28:19 <milkshakeS_> Hi all, i'm new here
09:28:34 <Gurkenglas> hpc, <$ is a -> f b -> f a, so $> is f a -> b -> f b, right?
09:28:46 <Xandaros> milkshakeS_: Welcome! How can we help you? :)
09:29:36 <hpc> Gurkenglas: unless it's a -> f b -> f b, which would be weird
09:29:43 <hpc> but the only explanation i can think of for the omission
09:30:10 <hpc> (as i expect is running through your mind, the omission is indeed quite weird)
09:30:46 <Xandaros> I might be naive, but I'd just assume ($>) = flip (<$)...
09:31:25 <schell> hi all - i’m trying to profile some code (including upstream libs) but i’m not seeing functions from other libraries (like containers) included in the resulting .prof 
09:31:44 <jophish> schell: did you compile them with profiling enabled?
09:31:45 <schell> is there a flag i’m missing? or can you only profile “local” executables and libraries?
09:32:08 <schell> jophish: yes - i’m using `stack build --executable-profiling --library-profiling --ghc-options="-fprof-auto”`
09:32:51 <milkshakeS_> nothing really, thanks for asking. 
09:33:05 <jle`> :t ($>)
09:33:06 <lambdabot>     Not in scope: ‘$>’
09:33:06 <lambdabot>     Perhaps you meant one of these:
09:33:06 <lambdabot>       data constructor ‘Seq.:>’ (imported from Data.Sequence),
09:33:12 <milkshakeS_> just starting again irc after more than 10 years stop
09:35:42 <jophish> ertesx: what's the question anyway?
09:35:53 <OhTrueful> @pl \i -> if (i == 'a') then 'aa' else repeat a 
09:35:53 <lambdabot> (line 1, column 28):
09:35:53 <lambdabot> unexpected "a"
09:35:53 <lambdabot> expecting expression
09:36:21 <OhTrueful> 18:35 OhTrueful @pl \i -> if (i == 'a') then "aa" else repeat a 
09:36:42 <OhTrueful> @pl \i -> if (i == 'a') then "aa" else repeat a 
09:36:42 <lambdabot> flip (flip if' "aa" . ('a' ==)) (repeat a)
09:39:22 <OhTrueful> @pl \i -> (if (i=='a') then "aa" else repeat  i)
09:39:22 <lambdabot> ap (flip if' "aa" . ('a' ==)) repeat
09:40:55 <ertesx> i'm currently writing a 3D sound library, and to achieve attenuation i use the following equation:  d1^2 * v1 = d2^2 * v2, where d1 is recording distance, v1 is recording amplitude, d2 is listening distance, v2 is listening amplitude
09:42:01 <ertesx> now i thought that there is no inherent reason why this has to be a *3D* sound engine…  it could just as well be 2D or 200D, but wave physics would want me to replace the exponents in the equation by the dimensionality, and that would have strange effects
09:42:38 <ertesx> sounds in 1D would never vanish regardless of distance, and sounds in 6D couldn't be heard even if you were almost right next to the sound source
09:43:10 <Jinxit> isn't there always an energy loss?
09:43:20 <jle`> that's sort of an implication of how attenuation works.  in a 3d world, the energy from the a source spreads out in a sphere
09:43:27 <ertesx> Jinxit: not in 1D
09:43:30 <jle`> and the *total* energy at every conicentric slice of that sphere is the same
09:43:44 <jophish> ertesx: that sounds good to me
09:44:01 <jophish> although make sure to expose a 3D interface for us mortals who want an easy to use library
09:44:14 <jle`> so the energy per solid angle on the spheres gets smaller and smaller based on how the surface area of the sphere increases with radius
09:44:14 <ertesx> the question is:  should i keep the intuitive equation above that we're used to from our 3D reality, or should i do it physically plausible?  or is it just a crazy idea to generalise to n-D anyway?
09:44:27 <sm> jophish: pfff, the types will explain
09:44:31 <ertesx> jophish: it's a matter of selecting f = V3 =)
09:44:51 <jophish> ertesx: physically correct sound is a huge problem
09:45:28 <ertesx> jophish: it won't be…  it should just be *plausible*, not necessarily *precise* or *correct*
09:46:00 <ertesx> a full sound simulation wouldn't scale too well, although i remember that one game engine tried to do it
09:46:01 <jle`> it depends on what you are even trying to achieve in an n-D engine, i think.   For a 2D physics engine, people usually aren't trying to model an actual 2d physics, they mean to model a projection of physics in a 3d world
09:46:36 <Jinxit> that's a good point
09:46:51 <ertesx> jle`: i guess i'll do the plausible thing and leave it to the user to decide whether they want 2D physics or just projection
09:46:52 <jle`> er, that is to say, a 2d projection of 3d physics
09:47:11 <ertesx> because you can still select f = V3 even when making a 2D game
09:47:20 <jordanl> jle`: isn't the energy emitted through a solid angle constant. if you measure at a distance R away though, the energy drops off like 1/R^2
09:47:33 <jle`> also, if it's for a game, the most important factor should be playability, not physical accuracy
09:47:44 <ertesx> i imagine it will be interesting to hear an approximation of what 6D sound would feel like anyway =)
09:48:38 <jle`> jordanl: yeah, i misspoke, i didn't mean solid angle, i meant unit area element
09:48:42 <jle`> thanks
09:49:02 <ertesx> jle`: for a game just select V3 to get the usual equations…  performance-wise this is one of the rare cases without the curse of dimensionality
09:50:18 <jle`> physically you can imagine this phenomenon as energy "leaking" into extra dimensions, so for a 6D case, the same energy has to be spread out in expanding over all 6 dimensions instead of just 2 or 3.
09:50:38 * hackagebot doctest 0.11.0 - Test interactive Haskell examples  https://hackage.haskell.org/package/doctest-0.11.0 (SimonHengel)
09:51:00 <ertesx> jle`: i'm familiar with the physics behind it…  as said, i'm more asking for your opinions here
09:51:12 <jle`> yeah, i was more intending that for jordanl or others following
09:51:18 <Gurkenglas> Has someone built a engine that models physics as it would work in 2D? What with gravity being divided by the distance, not its square, etc
09:51:37 <jle`> ertesx: i'd say, for a library perspective, if it's easy to generalize, then might as well
09:51:46 <jordanl> jle`: sorry, i couldn't help myself. i studied physics 10 years ago and i still love it
09:51:48 <ertesx> i really want to hear what a high-dimensional doppler effect sounds like…  probably sounds like nothing, because you need to put your hyper-ears right next to the sound source =)
09:52:01 <ertesx> jle`: yeah, that was my thought
09:52:12 <EvanR> Gurkenglas: eh.. that doesnt result in stable orbits
09:52:17 <jle`> if generalization introduces a lot of extra complexity, then it'd probably be some judgment call.  but in this case it doesn't sound like there is much extra complexity
09:52:50 <ertesx> jle`: it introduces one type class that reflects the dimensionality, and nothing more
09:53:18 <ertesx> class (Functor f) => Dim f where dim :: proxy f -> Int
09:53:19 <jle`> as long as you already have the type class and are using it in other places :D
09:53:20 <ertesx> something like that
09:53:37 <EvanR> using type classes for dimensions?
09:53:45 <EvanR> why not phantom types
09:53:53 <ertesx> jle`: the linear library doesn't seem to provide it by itself…  you can get the dimensionality by using Foldable, but then you're actually counting coordinates
09:54:06 <jle`> ertesx: what about Linear.V
09:54:15 <Gurkenglas> EvanR, objects that start out next to each other wouldn't fly apart infinitely because that'd take infinite potential energy, so there must be some sort of orbiting
09:54:28 <dkov> @pl foo a b = bar b a
09:54:29 <lambdabot> foo = flip bar
09:54:37 <ertesx> jle`: too specialised
09:54:38 <EvanR> Gurkenglas: well thatd be "generalized orbit" meaning, some path
09:54:45 <EvanR> but it wouldnt be pretty
09:54:53 <ertesx> jle`: also uses Vector internally, so won't unbox
09:55:35 <EvanR> in fact i think youll get mostly collisions and singularities at finite time
09:56:21 <EvanR> basically for cartoon physics 1/r isnt good
09:57:08 <ertesx> i'd really like to have separate types for homogenous coordinates (H3 ≃ V4)
10:08:01 <Ptival> what is the fastest way to wrap an IO computation so that it may not run in parallel with itself? (calls are stalled and processed sequentially)
10:08:14 <Ptival> fastest in terms of coding it :(
10:08:36 <johnw> you mean, you want to replicate it N times in N threads, and ensure that only one runs at a time, with the order insignificant?
10:09:03 <johnw> there are a few libraries like parallel-io and async-pool that can make this easy to do
10:09:21 <johnw> they don't "wrap" the IO, they just manage how a list of IOs is processed
10:09:23 <ertesx> the simplest way is to lock on an MVar ()
10:09:35 <EvanR> withMVar_
10:09:37 <Ptival> johnw: they will be called by Snap handlers, so yes sort of that, there might be N threads trying to run that computation, I want them to wait if someone is already running, but I'd like the order to matter though
10:09:54 <johnw> then yeah, MVar is the basis of pretty much all such solutions
10:09:58 <Ptival> I don't have the list upfront
10:10:13 <Ptival> ok, MVar it is, thanks everyone :)
10:10:22 <Ptival> will that cause ordering problems though?
10:10:25 <ertesx> Ptival: so there is not only locking, but also ordering?
10:10:34 <johnw> so far we've ignored ordering
10:10:35 <Ptival> ertesx: yes :s
10:10:46 <ertesx> locking on MVar () will not guarantee any ordering
10:10:51 <Ptival> do I need to build a queue then?
10:11:03 <ertesx> Ptival: it depends on how you determine the order
10:11:13 <ertesx> when does a thread know that it can execute the action?
10:11:24 <ertesx> when/how
10:11:42 <c_wraith> ertesx, true by specification, but ghc uses a FIFO implementation for mvar locks. at least, it did last time I checked. 
10:12:03 <Xandaros> c_wraith: You should never rely on that, though
10:12:14 <ertesx> c_wraith: still does, but that doesn't guarantee ordering, only fairness
10:12:21 <Ptival> hmmm, I guess this raises another issue then, because if my HTTP packets arrive in wrong order then the server cannot recover the intended order
10:12:24 <c_wraith> depends on how much you want to tie yourself to implementation details. 
10:12:28 <Ptival> I guess I'll have to fix it client-side then
10:12:32 <Ptival> sorry for the noise
10:12:54 <ertesx> Ptival: in any case, the most generic solution is STM, which gives you 'check'
10:13:01 <c_wraith> Ptival, wait, what? tcp should give them to you in the correct t order, even if the network doesn't. 
10:13:07 <ertesx> Ptival: you can retry based on predicates with STM
10:13:33 <c_wraith> Ptival, or do you mean multiple independent http requests? 
10:13:35 <dedgrant> Does Control.Concurrent.Chan have the necessary properties?
10:13:35 <ertesx> c_wraith: we've got HTTP pipelining
10:13:45 <Ptival> I mean multiple independent HTTP requests
10:14:08 <c_wraith> dedgrant, no. it has the same guarantee as MVar
10:14:14 <dedgrant> I see
10:14:27 <Ptival> yeah I think I need to get my story straight on the client side anyway (which is not Haskell)
10:14:48 <ertesx> c_wraith: for example if the client side is a browser and the client-side application is in javascript, there is no way to guarantee request ordering, unless you actually introduce an event-based dependency
10:14:58 <Ptival> ertesx: exactly
10:15:30 <c_wraith> the more I use js, the more I wish I didn't. 
10:15:34 <Ptival> :)
10:15:49 <Ptival> it is not too terrible once you use enough libraries
10:16:11 <ertesx> you can write the client-side application in haskell with haskell concurrency though, if you don't mind the monstrously huge compiled JS of GHCJS =)
10:16:26 <Ptival> I started using RxJS to do reactive programming and it made everything much clearer
10:16:44 <Ptival> oh yeah I stopped using GHCJS, but I did for a while :)
10:16:58 <ertesx> Ptival: i really liked bacon.js, because with a bit of discipline it allows you to use FRP semantics
10:17:34 <Xandaros> I actually started using ghcjs recently with reflex-dom. I'm pretty surprised - web dev can actually be fun
10:17:38 <Ptival> ertesx: good to know, I just chose RxJS because it seemed very library-like rather than framework-like, and I don't have time to bite into a framework at the moment, but I saw bacon
10:18:01 <ertesx> Ptival: bacon is similar in that regard
10:18:13 <Ptival> and also, I'm not entirely functional, there are some side-effects in some observables
10:18:19 <Ptival> but yeah, it seems nice!
10:19:11 <ertesx> Xandaros: i love GHCJS, especially the way it gives you full haskell concurrency (even including STM!)…  but the output is simply too large to sell
10:19:46 <ertesx> even with closure-compiler and compression you're still transferring a few hundred KiB for pretty much "hello world"
10:20:41 <Xandaros> Yeah, that is an issue. I personally don't mind too much, though
10:21:00 <suppi> a question regarding marlow's book
10:21:06 <suppi> I'm using GHC 7.10.3
10:21:20 <suppi> and there's a ghci command called :sprint
10:21:50 <suppi> in marlow's book he demonstrates defining: let xs = [1..10]
10:22:08 <suppi> and then `length xs` and `:sprint x`
10:22:35 <suppi> in the book he shows the result of `:sprint x` as [_,_,_,_,_,_,_,_,_,_]
10:22:51 <suppi> i mean, x = [_,_,_,_,_,_,_,_,_,_]
10:22:57 <suppi> but I only get x = _
10:23:08 <dmj> suppi: did you call length on it?
10:23:08 <suppi> did something change?
10:23:17 <suppi> dmj, yes
10:23:19 <ertesx> suppi: that's probably MMR at work again
10:23:28 <ertesx> suppi: try this:  let xs = [1..10] :: [Integer]
10:23:33 <suppi> MMR?
10:23:42 <ertesx> monomorphism restriction
10:24:30 <ertesx> suppi: even with the code above, don't necessarily expect [_,_,_,_,_,_,_,_,_,_]
10:24:44 <Xandaros> With that, it seems to evaluate fully
10:24:46 <Xandaros> interesting
10:24:54 <suppi> ertesx, yes, same results as Xandaros 
10:25:01 <ertesx> suppi: if you want to observe that one, try adding a function application
10:25:11 <ertesx> let xs = map (^2) [1..10] :: [Integer]
10:26:00 <ertesx> otherwise the interpreter may not bother to make those trivial-to-evaluate thunks
10:26:15 <suppi> ertesx, that works :)
10:26:43 <Xandaros> Interesting... how does it know they are trivial to evaluate?
10:26:54 <ertesx> too uninteresting to be lazy =)
10:26:59 <suppi> ertesx, interesting, when I did xs = [1,2,undefined,4] i got [1,2,_,4]
10:27:12 <dmj> those [Int] must not be considered thunks, so during length the actual values are traversed
10:27:15 <ertesx> Xandaros: probably by an ad-hoc database of known idioms
10:28:26 <ertesx> suppi: when GHCi knows what the evaluated value is going to be without non-trivial computation, it will generally just put the values there
10:28:39 <ertesx> 'undefined' is non-trivial in that regard
10:30:42 <suppi> ertesx, thanks for explaining :)
10:32:14 <Xandaros> 'Slightly' different topic: Do you think Haskell will ever get a typeclass hierarchy like purescript's? (https://github.com/purescript/purescript-prelude/tree/master/src/Control)
10:32:41 <suppi> Xandaros, I'd say, probably not
10:33:09 <Xandaros> :(
10:34:08 <texasmynsted> what is the best way to produce javascript from haskell? ghcjs?
10:34:20 <texasmynsted> Are there other things I should look at?
10:34:48 <jophish> texasmynsted: you might want to take a look at Haste
10:34:56 <texasmynsted> Thank you
10:34:59 <texasmynsted> I will check it out
10:35:00 <jophish> but GHCJS is certainly the Soup du Jour
10:35:52 <Xandaros> There's also fay, I guess
10:36:10 <ertesx> GHCJS compiles GHC haskell, including concurrency, which makes it The Compiler
10:36:27 <jophish> you might want to investigate purescript, or the number of other haskell-like offerings in that space
10:36:47 <ertesx> unfortunately The Compiler produces The Monster-Code
10:37:21 <ertesx> at least you can benefit from The Book (marlow's concurrency/parallelism book)
10:37:50 <jophish> does JS have actual concurrency?
10:37:57 <koala_man> yes
10:38:18 <Xandaros> It can do concurrency, one way or another. Not sure about parallelism, though
10:38:35 <dmj> jophish: it's like using ghci for concurrency, single threaded, but it's there
10:38:48 <koala_man> you can do multithreaded, multi-CPU javascript processing
10:38:55 <jophish> ah, gotcha. Javascript sounds like the worst
10:39:09 <jophish> I wonder how long it'll be before ghc can target web assembly 
10:39:24 <duckbob> hi i have a problem with traversable graphs can anyone help?
10:39:37 <Xandaros> duckbob: Not without knowing the actual problem :)
10:41:04 <duckbob> http://lpaste.net/157670
10:41:13 <duckbob> i made a paste
10:42:03 <duckbob> i would like to use Traversable to use fmapDefeault
10:42:27 <duckbob> i have a nasty recursive 2d graph type
10:42:46 <jophish> duckbob: https://hackage.haskell.org/package/mono-traversable-0.10.1/docs/Data-MonoTraversable.html#t:MonoFunctor
10:43:05 <jophish> might be useful
10:43:38 <duckbob> what is it!?
10:43:49 <jophish> it's your EndoFunctor
10:44:00 <duckbob> ah
10:44:05 <duckbob> no i need fmap really
10:44:29 <duckbob> leaving the old elements not updated isnt a solution
10:44:46 <texasmynsted> Wow!  Haste is really interesting.  Thank you.  I think that is what I am looking for. 
10:45:31 <duckbob> the test uses foldMap, fmap does not work
10:45:44 <jophish> duckbob: you can also derive Functor and Foldable for QuadTuple instead of writing them yourself
10:45:56 <duckbob> really!!?
10:45:58 <duckbob> coool
10:45:59 <duckbob> thanks
10:47:10 <duckbob> but not really, my fmap definition needs to handle the updating of the neighbors reference to each element
10:47:42 <duckbob> but yes, the ones given here are the derived ones i guess
10:47:55 <jophish> Sounds like something best left to another function, not fmap
10:48:08 <duckbob> no, its the only way to write fmap
10:48:52 <duckbob> to traverse like the fold does, handling the backwards directions differently
10:49:39 <duckbob> but because fmap has constrained type, i cant just pass fmap to the forward direction
10:50:32 <jophish> I don't understand what you're trying to do. But I'd be very surprised if your instance for Functor differed from the derived instance
10:50:45 <duckbob> the derived one breaks
10:50:54 <duckbob> i need to handle infinite loops
10:51:21 <duckbob> you need to check link
10:51:54 <jophish> yeah, I didn't quite get what you're trying to do there
10:52:15 <duckbob> thats how im linking them, its a 2d double linked list, its recursive, the double links are mutually recusivly referenced
10:54:10 <jophish> yeah, I get that but I'm still not sure what the problem is. Either you need to tie the knot in a neato way, or use some kind of pointer system
10:54:40 <duckbob> hmm that sounds promising
10:54:45 <duckbob> can you say any more on that?
10:55:26 <duckbob> i dont know how to pass the pointer in along with fmap
10:56:01 <jophish> duckbob: leave fmap as the derived definition
10:56:08 <jophish> do all this crazy stuff in another function
10:56:26 <jophish> https://wiki.haskell.org/Tying_the_Knot
10:56:33 <duckbob> but i want fmap to work!
10:56:50 <duckbob> i wold at least use my solution to implement fmap
10:57:05 <duckbob> buti can see how i might not like being constrained to the types of fmap
10:57:56 <jophish> Please explain from the beginning: What invariant does QuadTuple have which prohibits derived fmap from working
10:58:23 <duckbob> invarient?
10:58:30 <duckbob> it creates an infinite recursion
10:58:59 <jophish> no Quadtuple doesn't create anything, it's just a 4-vector
10:59:04 <duckbob> rather than referencing the return value of fmap, it is repeatedly called on the unupdated reference
10:59:38 <duckbob> quadtuple derived fmap is fine, except when its used in GridNode
10:59:58 <duckbob> then we would like only to operate on the forward directions of the Quadtuple
11:00:06 <jophish> then GridNode shouldn't be using fmap
11:00:22 <duckbob> hmm
11:00:25 <duckbob> perhaps
11:00:49 <duckbob> in any case, i cant see how to update the reference
11:01:30 <jophish> take a look at `fix`
11:01:57 <tzh> duckbob: just by glancing over your code, it seems like you might want to use something more structured than `GridNode`? i think what you're trying to do is establish a 2d grid of tiles, where you can navigate from one to any other by delving deeper into any given gridnode's quadtuple, right?
11:02:00 <duckbob> data Fix a = Nil  | Roll (Fix a)
11:02:06 <tzh> or am i completely off base here?
11:02:21 <duckbob> thats right tzh
11:02:43 <duckbob> the constructors and accessors will make for a fast nearest neighbour later
11:03:35 <jophish> duckbob: you might want to take a look at Zippers too
11:03:49 <duckbob> its annoying, i could get to the same point by various different paths, i cant see how to make them all point to the same thing without using pointers using the datatype im writing
11:04:07 <duckbob> what about zippers whould be helpful here
11:04:10 <duckbob> ?
11:05:41 <tzh> it depends on what exact concerns are the most important, but an infinitely-nested tree of neighbors is probably just asking for more work than you have to do
11:05:48 <duckbob> i understand its something like descending into a stack
11:05:54 <duckbob> the zipper thinh
11:05:57 <duckbob> thing*
11:06:11 <duckbob> tzh, i just want to know how to make it work
11:06:26 <duckbob> its really important for what im doing
11:07:02 <duckbob> im trying to handle that exact structure in Haskell
11:07:12 <duckbob> thats why i wrote the example
11:07:26 <duckbob> http://lpaste.net/157670
11:07:37 <duckbob> check how im constructing using link
11:12:27 <tzh> duckbob: i think the fundamental problem is that once you make a two-way link anywhere, your data structure becomes infinite, and so then trying to fold through it, or print the entire thing, will go forever. that's just a consequence of the data structure as constructed -- if you want something else, you could try using actual pointers (so there are only as many items as there are actual tiles) or something like a zipper that takes out the 
11:12:28 <tzh> recursive element and gives you a flat data structure that allows you to shift around the "current" tile
11:12:53 <duckbob> i can do it this way though
11:13:23 <duckbob> only go forwards, update references of backwards ellements by passing them into fmap
11:13:38 <duckbob> or another function
11:14:10 <duckbob> do you know how i could do that?
11:14:15 <duckbob> it confuses me
11:14:26 <tzh> well, when there are four directions to go, which ones are "forwards" and which are "backwards"?
11:14:59 <duckbob> the function backwards is defined, and also you can infer it from foldMap
11:15:21 <duckbob> im taking Up and Right to be forwards
11:15:36 <duckbob> so foldMap only uses [a,b]
11:16:42 <duckbob> foldMap isnt a problem, but when i try and write fmap, i get into problems
11:17:18 <duckbob> the links are not updated to values already calculated
11:17:28 <duckbob> im wondering how to do that
11:19:08 <maerwald> can I set haddock options in cabal file?
11:19:36 <maerwald> e.g. I do {-# OPTIONS_HADDOCK ignore-exports #-} in my modules, but it would make more sense to define that in cabal file I think
11:21:45 <levp> I'm new to Haskell and I want to implement TLS server. What is the simplest way to do it? It would be ideal to find something as simple as ssl module in Python
11:22:28 <Zemyla> maerwald: I read that as "ignore-esports", which is a sound position pretty much all the time. :V
11:22:56 <maerwald> ?
11:24:24 <duckbob> levp, a google search shows warp and http client, they are good
11:24:25 <thoughtpolice> levp: Check out the 'network-simple' and 'network-simple-tls' modules. They make it quite easy.
11:24:49 <thoughtpolice> Unless you want HTTP(S) server. In which case, warp and warp-tls will work.
11:26:05 <thoughtpolice> levp: Here's an example - https://github.com/k0001/network-simple-tls/blob/master/examples/tls-echo.hs
11:28:06 <levp> thoughtpolice: thank you, network-simple-tls seems quite similar to what I actually wanted
11:28:07 * andrew`
11:48:27 <ertesx> for the record: what duckbob had there is not EndoFunctor, it's not-functor-at-all
11:48:46 <ertesx> or not-enough-to-be-functor
12:02:42 <ertesx> does GHC do any cascading to make updating fields of large records more efficient?
12:03:04 <ertesx> i have a record with five fields, and all of them except one may be updated
12:03:25 <ertesx> and i'm thinking of splitting the type to make updating more efficient
12:03:54 <Peaker> ertesx: do you mean you update multiple fields at once and you want to have just 1 copy per multi-field update rather than a copy-per-update?
12:04:42 <ertesx> Peaker: no, i update one field
12:05:05 <ertesx> i'd expect GHC to have to copy the whole record to update it
12:05:45 <kadoban> ertesx: I'm fairly sure that's not how it works.
12:06:22 <Peaker> how wouldn't it copy the entire record?
12:07:18 <kadoban> Isn't a record just a record full of pointers to (evaluated on unevaluated) thunks? So I would think it only copies mostly just the pointers.
12:07:47 <eacameron> kadoban: I believe that's correct. That means it does sharing.
12:07:48 <ertesx> Peaker: by cascading the record to make it tree-shaped
12:08:16 <ertesx> kadoban: copying five pointers in an inner loop could ruin the efficiency in this case
12:08:20 <ertesx> that's why i'm asking
12:08:54 <ertesx> or is GHC smart enough to update in-place, if GC allows it?
12:08:59 <Peaker> ertesx: it would add indirection penalties.. I think it's nicer that indirections are explicit
12:09:30 <Peaker> Maybe if it can optimize the record away completely it'd update-in-place -- but I don't think it has anything to do with GC
12:09:55 <ertesx> hmm…  maybe a CPSed representation could be faster then, but i doubt it
12:10:25 <eacameron> ertesx: You could always make the elements of the record mutable...
12:10:53 <ertesx> or maybe the cache will just save me =)
12:11:04 <ertesx> i'll just benchmark and see how expensive it is
12:12:26 <eacameron> ertesx: http://stackoverflow.com/questions/4265660/updating-a-big-state-fast-in-haskell
12:13:45 <ertesx> (i really wish we had uniqueness/affine types for this)
12:14:19 <ertesx> (or maybe GHC is indeed smart enough to do it in-place)
12:14:27 <EvanR> ertesx: yes, using smallish records and using an optimized recursion combinator will let the generational collector do its thing
12:14:39 <dolio> How come people always come ask this question before checking that what they're worried about is actually slow?
12:15:13 <EvanR> ertesx: allocation and scribbling of a few pointers is fast
12:15:22 <ertesx> dolio: it will take a while before i can run benchmarks, so i wanted to gather some known facts about it upfront
12:15:34 <EvanR> the last N iterations will be efficiently dropped before anything gets to main memory
12:16:09 <EvanR> mutable references however will require you to contend with the write barriers and a less efficient GC strategy
12:17:08 <EvanR> of course, you can always do something that is faster than before
12:17:29 <ertesx> EvanR: i'm aware of that…  i'll just go ahead with the non-CPSed one right now…  if i'm unlucky, i'll have to rewrite everything
12:17:31 <EvanR> the optimization process never terminates, so i dont even start ;)
12:18:43 <EvanR> it also saves me from struggling to optimize a thing that is already orders of magnitude slower than some other thing i didnt even know about
12:18:51 <EvanR> er, orders of magnitude faster
12:18:57 <EvanR> the other thing is slower
12:19:37 <EvanR> "but by optimizing whatever right here right now, we wont have to do it later!"
12:20:47 <ertesx> in this particular case in-place update would be the most sensible thing to do operationally (best cache performance, least amount of cycles), but the engineering effort would be high and would lead to really ugly code, so i'll probably not do it, even if this turns out to be too slow
12:21:33 <EvanR> in-place update of anything within the haskell runtime will require tracking of mutation by gc
12:21:52 <EvanR> so the only "sensible" way would be to use FFI
12:22:00 <EvanR> which has its own overhead
12:22:05 <aisqwe> my leksah is stuck at updating metadata and its ram or cpu usage doesnt seem to change, what should I do?
12:22:21 <cocreature> just rewrite everything in assembly
12:22:47 <ertesx> EvanR: there are certain cases when GHC knows that it can safely overwrite…  and at least for simple opaque types of the Int* and Word* family it does that…  i'll just have to see what happens
12:23:45 <EvanR> using an IO Ref?
12:25:07 <tdammers> Jinxit: the point is that with either of the builder pattern like approaches, the type checker won't keep me from forgetting one of the fields
12:25:19 <EvanR> an IORef with boxed Word64's will have to be tracked in order to be collected, at least for large values
12:25:25 <tdammers> either I initialize correctly, or it won't typecheck
12:25:30 <tdammers> that's the idea
12:25:48 <EvanR> and if were creating new boxed Word64's each time anyway... might as well use recursion instead of mutation
12:25:59 * hackagebot giphy-api 0.3.0.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.3.0.0 (passy)
12:26:48 <ertesx> EvanR: i mean pure machine-word-sized values that are replaced by going out of scope in favour of a new value (e.g. by recursion or a tail call)
12:27:06 <ertesx> (i hate the word "call", but "tail application" sounds weird)
12:27:19 <EvanR> oh are you using unboxed
12:27:42 <ertesx> EvanR: no, regular Int, Int32, Int64, etc.
12:27:50 <alger1> wow i saw these many people for the first time at irc!
12:27:56 <EvanR> heh... highly optimized boxed arithmetic ;)
12:28:29 <sphinxo> How should I do something like  '\0' | 'a' << 8 | 's' << 16 | 'm' << 24 in haskell?
12:28:39 <alger1> hello guys
12:28:41 <sphinxo> ( that's binary or )
12:29:03 <EvanR> Data.Bits
12:29:23 <EvanR> make a function to convert a Char into whatever Bits numeric type
12:29:24 <ertesx> sphinxo: for most binary operations you need Data.Bits, which gives you (.||.) as well as shiftL
12:29:52 <EvanR> f '\0' .|. (f 'a' `shiftL` 8) .|. ...
12:30:00 <alger1> i too have a question guys, can i use irc commands in flash game's chat window to get the required output? like kicking someone or something?
12:30:13 <ertesx> sphinxo: you can't bitwise manipulate a Char directly, but you can use 'ord' and 'chr' to go to an Int
12:30:23 <sphinxo> EvanR: where f is?
12:30:31 <EvanR> fromIntegral . ord
12:31:23 <alger1> hey man someone hearing me?
12:31:35 <ertesx> alger1: yeah, but you're in the wrong channel for that topic =)
12:31:51 <alger1> oh sorry for that bro
12:31:54 <ertesx> this channel is about the haskell programming language
12:32:24 <alger1> oh thanks, i may go to another channel :)
12:32:40 <ertesx> try #irc or ##irc, if they exist here
12:34:35 <sphinxo> Where can I get ord
12:34:39 <sphinxo> Oh nvm
12:35:31 <ertesx> sphinxo: you can write a little helper function that does the ord/chr roundtrip for you:  withOrd :: (Int -> Int) -> Char -> Char
12:36:44 <EvanR> or just say chr . f . ord
12:36:56 <ertesx> sphinxo: but i have a feeling that you actually need the *number*, not the *character* that results from your arithmetic (it'll be an invalid character)
12:36:58 <EvanR> though looks like that wasnt the point
12:37:14 <sphinxo> Yeah it'd be the number
12:37:28 <ertesx> > ord 'A'
12:37:29 <lambdabot>  65
12:37:36 <ertesx> > shiftL (ord 'A') 8
12:37:38 <lambdabot>  16640
12:39:55 <sphinxo> Is there a uint32 type in haskell?
12:40:14 <kadoban> Word32
12:40:41 <sphinxo> ok great
12:43:24 <EvanR> > maxBound :: Word32
12:43:25 <lambdabot>  4294967295
12:43:37 <EvanR> > maxBound + 1 :: Word32
12:43:38 <lambdabot>  0
12:46:16 <sphinxo> I have a big table of data like http://lpaste.net/8277124839567785984
12:46:44 <sphinxo> Should I create a adt type thing like data Instruction = Nop | Loop etc...
12:47:06 <sphinxo> How should I assign the ids?
12:47:16 <ertesx> sphinxo: i'd do that, unless the numbers have a primary meaning and the names are only secondary
12:47:30 <Peaker> sphinxo: surely each opcode has associated data when encoding an instruction?
12:47:37 <ertesx> sphinxo: there is the Enum class, but that one assumes that you don't have gaps
12:47:44 <sphinxo> Yes Peaker 
12:47:47 <Peaker> sphinxo: perhaps make an ADT for the entire instruction, and then write encoder/decoder of entire instructions?
12:47:51 <sphinxo> They will
12:47:57 <EvanR> you need a encode and decode function for each ctor
12:48:08 <EvanR> well case in the encode and decode functions
12:48:28 <ertesx> sphinxo: i'm with Peaker there: write a full AST type for your language/instruction set rather than just the names
12:50:16 <miko__> So I have a List :: [IO String]. I'd like to chain them and get the result. I'm stuck at "foldr (\m s1-> m >>= (\s2 -> s1 ++ s2)) return",  but that's not correct.
12:50:28 <Cale> miko__: sequence
12:50:44 <Cale> Which is  foldr (liftM2 (:)) (return [])
12:50:57 <Cale> or
12:51:00 * hackagebot propellor 2.17.2 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.17.2 (JoeyHess)
12:51:22 <ertesx> miko__: you can't "chain" [IO String], but Cale's suggestion runs each action in sequence and collects the results
12:51:36 <ertesx> miko__: if you want actual "chaining", you need something like [String -> IO String]
12:52:09 <Cale> @src sequence
12:52:09 <lambdabot> sequence []     = return []
12:52:09 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:52:09 <lambdabot> --OR
12:52:09 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:52:16 <miko__> ertesx, I'm not sure what you mean by "chaing". What cale said is just what i wanted
12:52:27 <Cale> was going to type it but then remembered @src exists :P
12:52:47 <ertesx> miko__: that's just sequencing…  the individual actions don't communicate with each other (except perhaps via IO effects)
12:53:01 <Cale> miko__: How do you obtain the list?
12:53:14 <miko__> lambdabot, Ok, I could have come up with the first definition by my self...
12:53:34 <Cale> miko__: note that there's  mapM f xs = sequence (map f xs)
12:53:59 <Cale> miko__: as well as  forM xs f = mapM f xs
12:54:12 <Cale> so that you can write things like  forM [1..10] $ \x -> do ...
12:54:13 <Gurkenglas> (also traverse and for which are strictly more general than mapM and forM)
12:54:45 <Gurkenglas> or "[1..10] `for` do ..." for less tokens!
12:55:17 <ertesx> miko__: look at the definition of liftM2, then the second definition should be clear, too
12:55:30 <EvanR> "not chaining, but sequencing" ehh 
12:55:32 <ertesx> liftM2 f action1 action2 = do x <- action1; y <- action2; return (f x y)
12:55:51 <EvanR> vague jargon is vague
12:55:54 <sphinxo> Something like this for serializing/encoding? http://lpaste.net/8805128589721731072
12:56:20 <miko__> I'm not sure if the desin makes any sense. I want to process a file, cpp style. I split the input into lines, than map a function over these lines that either returns the line, or a readfile of that list.
12:56:46 <miko__> Then I'm going to try to find a fixed point of that operation.
12:56:47 <Gurkenglas> Kinda thinking that surely there's already a library that works with the DAG of types right while writing http://lpaste.net/5597101036826263552
12:57:18 <ertesx> miko__: like CPP, but limited to #include?
12:57:29 <miko__> ertesx, yes, exactly
12:58:15 <ertesx> seems like a reasonable design, if this is one of your first projects
12:58:47 <ertesx> once you're somewhat fluent in haskell, you'd probably use a streaming abstraction, because your current solution actually reads the source file into memory to process it
12:59:03 <ertesx> (unless you're using lazy I/O, which is a topic of its own)
12:59:36 <EvanR> a very short topic
12:59:52 <ertesx> although i'm not sure what you mean by finding the fixed point
13:00:16 <monochrom> "until no change" or "until no more #include"
13:00:24 <miko__> yes
13:00:31 <ertesx> ah
13:00:38 <Gurkenglas> int-e, can we get the recursion-schemes package trusted by lambdabot?
13:02:40 <sphinxo> Any feedback on the above approach in the paste?
13:03:10 <johnw> why not use an existing serialization scheme?
13:03:13 <miko__> What would a suitable streaming design be? What library to use?
13:03:14 <johnw> like 'binary'
13:03:29 <ertesx> sphinxo: the Data.Int module provides integer types of certain bit-sizes you might prefer over Int
13:03:37 <johnw> you can even use Generics to pretty much get the instances for free
13:03:39 <ertesx> sphinxo: Int8, Int16, etc.
13:03:45 <sphinxo> ertesx: those where just place holders, but thanks
13:04:11 <ertesx> sphinxo: i'm saying it, because the size of Int varies from platform to platform
13:04:19 <ertesx> on 32 bit platforms Int ≃ Int32
13:04:28 <ertesx> (assuming GHC)
13:04:33 <sphinxo> ertesx: What about Floats?
13:04:48 <sphinxo> I notice there is no Data.Float
13:05:03 <ertesx> sphinxo: i believe it's safe to assume that Float is 32 bits and Double is 64 bits
13:05:31 <ertesx> Float and Double are exported by the Prelude
13:06:05 <sphinxo> Got them thanks
13:06:42 <ertesx> design note: i wouldn't write a type class
13:07:03 <sphinxo> ertesx: What do you mean?
13:07:14 <sphinxo> How could I do it instead?
13:07:27 <sphinxo> obviously with fns but why?
13:07:41 <ertesx> just functions
13:08:16 <sphinxo> Why?
13:09:51 <sphinxo> Is there a way I can destructure without pattern matching?
13:10:27 <ertesx> sphinxo: do you expect to write generic functions that use the class, but are not bound to any particular instance?  remember that such functions must not make any assumptions about instances, unless there are certain laws associated with the class
13:11:05 <sphinxo> ahh
13:11:07 <ertesx> if not, then a type class is most likely inappropriate…  it's easy to mistake them as a modularity feature, but they aren't
13:11:14 <sphinxo> wait
13:11:18 <sphinxo> I mean eg
13:11:22 <Gurkenglas> :t let msumCofree (a :< as) = mplus (return a) $ as >>= msumCofree in alaf ListT (msumCofree .: coiter) -- Tada, recursive imports. (Imports are appended to the end of the line list, with breadth-first search.)
13:11:23 <lambdabot> Monad n => (b -> n [b]) -> b -> n [b]
13:12:07 <ertesx> sphinxo: all destructuring boils down to pattern-matching, but you can abstract it away
13:12:23 <ertesx> folds are a common way to do that
13:12:29 <sphinxo> where data Value = I32 Int32 | I64 Int64 | F32 Float | F64 Double want a function that takes a Value and calls a function on the inside value 
13:12:54 <sphinxo> where the function I call is something like  Intergral a => a -> [Word8]
13:13:27 <ertesx> how do you handle the F32/F64 cases?
13:13:35 <sphinxo> ahh :)
13:14:05 <sphinxo> I see your point
13:14:11 <duckbob> can someone check this for me? http://lpaste.net/157670
13:14:30 <duckbob> i think it works now
13:14:47 <duckbob> the Functor instance
13:15:07 <ertesx> sphinxo: you could pass it Rational instead of ((Integral a) => a)
13:15:56 <ertesx> but remember that Rational can use a lot of memory for large-values floats
13:16:01 <ertesx> large-valued
13:16:03 <sphinxo> I think quotRem needs it to be integral or something
13:16:24 <ertesx> sphinxo: what is your function supposed to do?
13:16:35 <ertesx> turn the number into byte-code?
13:16:43 <sphinxo> turn number into array of word8s
13:17:00 <ertesx> "array of word8s" could mean anything really =)
13:17:10 <sphinxo> list then
13:17:59 <sphinxo> I'm trying to write an assembler for web assembly
13:18:05 <ertesx> i mean semantically:  it could be a digital representation of the integer part, it could be some packed floating-point representation, it could be an encoded Rational, etc.
13:18:18 <sphinxo> I suppose I could just output the s expressions varient
13:18:26 <sphinxo> I'll have to do that anyway
13:20:38 <int-e> Gurkenglas: eek, another Foldable class
13:23:29 <duckbob> would anyone be able to help me with this datatype? http://lpaste.net/157670
13:23:46 <ertesx> https://ro-che.info/ccc/20
13:26:02 <duckbob> its my attempt to tie the knot
13:28:18 <duckbob> anyone!?
13:28:20 <pklausler> duckbob: using record fields might work better; Quadtuple{ up, down, left, right :: a }
13:28:26 <duckbob> sure thanks
13:28:56 <pklausler> then you can ditch the get/set functions
13:29:13 <duckbob> ok
13:29:36 <duckbob> sorry about that
13:30:54 <duckbob> what about the recursion?
13:31:04 <duckbob> its good?
13:31:33 <int-e> duckbob: you cannot tie such knots incrementally. you'll end up with a node 1' that has 2'' to its right, which has 3' above, which has 2' below which has nothing to the left.
13:31:45 <duckbob> what!!!?
13:31:53 <duckbob> that sounds very bad
13:32:17 <int-e> duckbob: (nodes 1, 2 and 3 would be the ones created by the 'emptyNode' calls. those are gone.
13:32:24 <int-e> )
13:32:47 <duckbob> yeah they must die
13:32:52 <duckbob> they are old
13:33:02 <duckbob> the updated reference is ok?
13:33:25 <int-e> "set" creates a fresh node.
13:33:25 <duckbob> using 'this;
13:33:53 <duckbob> butit refers to the correct object
13:34:01 <sphinxo> How should I split something like this in an adt? http://lpaste.net/6786494712221007872
13:34:03 <duckbob> even if its a copy, at least its correct
13:34:33 <pklausler> duckbob: but other nodes still point to the old version not the new copy
13:34:49 <duckbob> no! how?
13:35:00 <duckbob> i update it after
13:35:45 <duckbob> only the corner ends up with Nothing to the Right and Down
13:35:53 <duckbob> i hope...
13:36:41 <duckbob> i cant see the reference to the old object...
13:36:45 <Peaker> huh: λ> toJSON (Nothing :: Maybe (Maybe Int)) == toJSON (Just Nothing :: Maybe (Maybe Int)) ==> True
13:37:01 <Peaker> Nothing == Just Nothing == Just (Just Nothing) == ...
13:37:33 <sphinxo> How can I remove repitition?
13:37:43 <duckbob> :t nub
13:37:44 <lambdabot> Eq a => [a] -> [a]
13:37:58 <duckbob> > nub [1,1,2,3,4,5,4,6]
13:38:00 <lambdabot>  [1,2,3,4,5,6]
13:38:15 <sphinxo> Not like that :) in http://lpaste.net/6786494712221007872
13:38:33 <duckbob> lol
13:38:35 <pklausler> if only nub were Ord a => [a]->[a] instead, it would be faster
13:39:01 <sphinxo> Could I have something like Data Op = Load | Store | Load8 | ...
13:39:09 <duckbob> can you tell me why you think there are old references in my datatype?
13:39:30 <int-e> duckbob: see the annotation  http://lpaste.net/157670#a157688
13:39:31 <Peaker> oh I see it's already reported
13:39:41 <duckbob> oh sorry
13:39:47 <pklausler> duckbob because set creates new records; you can't update extant records in place
13:39:54 <Peaker> aeson is full of surprises!
13:40:02 <int-e> duckbob: (I've flattened the 4-tuple... it should be more readable that way)
13:41:03 <Peaker> "Parser" type which is really a CPS'd Either, and the convertor to a straight-forward Either is called "parseEither", but instead of being Parser a -> Either String a, it is: (x->Parser a) -> (x->Either String a)  where 'x->' is clearly superfluous
13:41:32 <Peaker> Need nicer "pickler combinators" instead of all the encoders/decoders, too
13:41:59 <duckbob> um, what should i do?
13:42:25 <t7> duno m8
13:44:12 <Peaker> duckbob: the lens library makes that kind of code easiser
13:44:29 <int-e> duckbob: don't tie the knot, use some IntMap with node ids instead. The knot-tying is possible, but difficult, and once done you can no longer modify the graph. (The 'fmap' would lose all the sharing, for example) It's hardly ever worth the effort.
13:45:28 <sphinxo> If I have something like http://lpaste.net/2765821435246018560
13:45:32 <sphinxo> how can I represent the value?
13:45:46 <sphinxo> Something after (Signedness, Width)
13:45:59 <sphinxo> or perhaps I should include it the width and call width something else?
13:46:09 <int-e> duckbob: (To tie the knot, you need an untied representation of the whole graph first anyway.)
13:46:27 <sphinxo> Although there will times when I don't want an value included eg a function sig
13:47:38 <pklausler> duckbob: I typically solve this kind of problem with a level of indirection, such as an Array, that vanishes once the graph is fully evaluated.
13:48:15 <duckbob> i want to step to my nearest neighbor
13:48:20 <duckbob> thats all
13:48:43 <duckbob> i want to traverse a cyclic graph defined in a recursive way
13:48:48 <duckbob> i need to tie the knot
13:49:09 <duckbob> so why would my fmap lose all sharing?
13:49:57 <pklausler> yes.  initialize the up/down/left/right fields to references to (other) values in an Array
13:50:08 <Gurkenglas> sphinxo, you can write "| Const Signedness Width" and then you'd have a constructor Const with two arguments.
13:50:32 <duckbob> what is the point of trying to make a fast custom datatype if i would have to implement it using Array1?
13:50:41 <sphinxo> Gurkenglas: and then the actual const value would be?
13:50:54 <sphinxo> (where)?
13:50:57 <pklausler> the Array vanishes in a puff of garbage collection once the graph is built
13:50:59 <duckbob> there is a reason i took the time to write this example and it was not to be told to use Array!
13:51:18 <duckbob> im having trouble with refering to old objects
13:51:24 <duckbob> in cyclic datatypes
13:51:32 <pklausler> we get that
13:51:48 <Gurkenglas> Oh, I read "something other than (Signedness, Width)" where you wrote "Something after (Signedness, Width)". What sort of value do you want to represent there?
13:52:13 <duckbob> i still want to use cyclic datatypes
13:52:21 <sphinxo> Well what ever value is the correct signedness and width
13:52:31 <pklausler> think of the Array as being a temporary array of pointers to your new nodes, used only during graph construction
13:53:03 <pklausler> yes, you'll have a cyclic graph structure when you're done, it'll be great.
13:53:04 <duckbob> i want to construct it using 'link'
13:53:31 <sphinxo> I suppose i could just have a big list of all the combinations of signedness and widths
13:53:45 <duckbob> specifically i want to update the references
13:54:01 <duckbob> do i need TVar?
13:54:07 <duckbob> or something like that?
13:54:08 <pklausler> then you want another programming language, such as ML, with updateable references.
13:54:10 <duckbob> it seems too much...
13:54:16 <Gurkenglas> sphinxo, so you want a different type there depending on what value of the parameter type you get? That's called dependent types and you can do it with, for example, type families
13:54:45 <pklausler> you can have cyclic structures in Haskell, you just have to be clever when you build them.  it's not a big deal.
13:54:47 <duckbob> my function update seems to do well no?
13:54:58 <pklausler> no
13:55:09 <EvanR> duckbob: you can update the references by rebuilding the graph
13:55:12 <duckbob> i would like to understand how it fails so i can fix it
13:55:14 <pklausler> it's not an update, it's a clone with modification
13:55:20 <duckbob> its fine
13:55:28 <pklausler> i'm done here
13:55:30 <duckbob> so long as the data is correct
13:55:39 <EvanR> immutable data is updated by doing a (full or partial) rebuild
13:55:59 <duckbob> im not after performance
13:56:05 <duckbob> rebuilding is fine
13:56:10 <sphinxo> hmm ok thanks Gurkenglas 
13:56:31 <prsteele> what does a type declaration inside of a class declaration do? E.g. class Foo a { type FooBar a ... } ?
13:56:32 <EvanR> in that case, definitely dont use TVars ;)
13:56:38 <duckbob> just so long as everything is referring to an object with the right data in
13:57:01 <int-e> duckbob: did you understand my annotation? the "link" function does not touch the reference to n3' when it produces n2''.
13:57:03 <EvanR> prsteele: its an associated type synonym
13:57:07 <duckbob> i mean, it would be great to have lots of references to one pice of data rather than lots of copies of the data
13:57:08 <EvanR> see TypeFamilies
13:57:29 <duckbob> yes int-e, but what about fmap?
13:58:44 <prsteele> EvanR: thanks!
13:59:06 <duckbob> it kind of needs to spread out updating everything at once, like i have tried to do with fmap, so maybe the required technique is there
13:59:45 <danilo2> Hello guys! I want to create a pure function `tListLength :: Proxy (lst :: [k]) -> Int` but without any Constraints (because theoretically we don't need any - any type-level list has length, and we don't need to check for KnownNats here). Is it currently doable somehow (even in hackish way)? 
14:00:47 <EvanR> class HasLength a where tListLength :: Proxy a -> Int
14:00:52 <danilo2> or maybe will be doable with some kind-magic in GHC8 ?
14:01:22 <EvanR> implement that for empty list, and for any type level list, the cons of some type and that list
14:01:25 <danilo2> EvanR: It doesn't work, because this constrain will remain as long as we don't know exact type of the list, which I want to avoid
14:01:26 <EvanR> recursively
14:01:56 <EvanR> danilo2: in order to get values from type level stuff, you have to use type classes
14:02:06 <EvanR> and you dont need a constraint
14:02:15 <int-e> duckbob: I really think you should create the graph with a different representation. then, *maybe*, tie the knot in the end, once everything has been built.
14:03:07 <duckbob> im trying to build an unfold
14:03:09 <int-e> duckbob: http://lpaste.net/157670#a157690 is what the final knot-tieing could look like (though perhaps you want to puzzle this out for yourself, spoiler alert...).
14:03:13 <EvanR> like you dont need to put Ord Int :: Int -> Bool to do x < 5
14:03:27 <EvanR> er Ord Int => Int -> Bool
14:03:45 <duckbob> i dont see what you are doing with (!)
14:04:38 <danilo2> EvanR: hmm, my intention is to provide such function in the API, but I dont want any constraint to appear to user even if he uses it in some polymorphic function, where the list is not known yet. We can do something similar using GADTs - consider the following: http://lpaste.net/157691
14:04:45 <miko__> What is the Reason I can't use strings in pattern maching? f "hello" = ... does not work, while f ('h':'e':'l':'l':'o') = ... does. I was told the former was just syntatic sugar for the later.
14:04:58 <duckbob> can you check my fmap definition?
14:04:59 <EvanR> danilo2: this is for "any type level list" so you know that much right?
14:05:17 <EvanR> miko__: you can use strings in a pattern
14:06:02 <danilo2> Yep, but I dont know the type, I only know its kind, like for example `lst :: [*]`, so the constraint will remain
14:06:09 <geekosaur> miko__ show an actual example?
14:06:09 <kritzcreek> what tokenizer could I use to lex a sourcefile for an earley parser?
14:06:43 <danilo2> EvanR: It would be theoretically possible to provide such function for any type of this kind, because EVERY type of thi kind has this property
14:06:54 <EvanR> danilo2: ... you dont want the user to *see* the constraint when they look at the type sig of tListLen ?
14:07:02 <geekosaur> the place where I have seen people becoming confused is that something like foo ("hello":...) doesn't work
14:07:08 <int-e> duckbob: I.! is an infix operator (qualified names for infix operators are ugly...) it's a lookup into an IntMap, unsafe in the sense that it bottoms out if the element isn't there.
14:07:29 <duckbob> and your using that to make references to this?
14:07:32 <geekosaur> ("hello" is 'h':'e':'l':'l':'o':[] and you can't make the :[] at the end go away)
14:07:33 <duckbob> 'this'*
14:08:04 <danilo2> EvanR: yes. The reason is not to propagate the cosntrrain he nuser uses this function with polymorhic types with know constraint. Constraints in Haskell are great to "warn" that they have to be met when you put a concrete tye there, but should be avoided if the result doesnt depend on the type
14:08:04 <int-e> duckbob: the knot is tied in the construction of g... it contains all nodes of the constructed graph simultaneously, in a way that they can be found by their id.
14:08:36 <EvanR> danilo2: the result.. does depend on the type
14:08:36 <danilo2> EvanR: look at the code I've pasted - it does magic without any constraints and is very pure for the user
14:08:52 <miko__> geekosaur, here is a example: A very primitie parsing function. I get a parsing error and it does not compipile. http://pastebin.ca/3428727. Yes, the tailing :[] is missing, that was in my "rest" pattern.
14:09:02 <danilo2> EvanR: nope, no mather what type I use (if its kin is [*]) the result's type is Int
14:09:02 <duckbob> no id
14:09:04 <duckbob> please
14:09:09 <duckbob> im trying to do something
14:09:19 <duckbob> i really gettired being told not to
14:09:27 <miko__> Well, I thik i got it: "" adds a tailing [], and that's not what i want.
14:09:28 <geekosaur> miko__, that is exactly what does not work because the "hello" already is a complete string
14:09:43 <geekosaur> ("hello":...) is a pattern matching a list of strings
14:09:53 <geekosaur> it is not matching a string that starts with "hello"
14:09:54 <duckbob> i guess ill try again tomorrow
14:09:55 <pklausler> duckbob, you're going to have to have per-node ids if you want to do fmap
14:10:01 <duckbob> no
14:10:05 <duckbob> no no no
14:10:11 <duckbob> thats the whole point
14:10:21 <duckbob> im telling you im close
14:10:23 <EvanR> danilo2: in your paste, the function is operating on a particular type
14:10:46 <EvanR> tListLen operates on any type that hasa tListLen defined
14:10:56 <geekosaur> (mind, it would occasionally be nice to have that particular shorthand, but at the same time it's not very reusable and it's not something I personally run into often enough for it to be worth it)
14:11:01 <pklausler> and the reason is that you need to be able to compare nodes for equality, but you can't compare their edges, so you have to have something in the node that you can compare
14:11:11 <geekosaur> (if I really cared I'd probably write a preprocessor :p )
14:11:18 <duckbob> there is a forward direction of traversal, and you can update the backwards drection by passing in the reference to the object you are traversing from
14:11:41 <danilo2> EvanR: I've updated the code, look at the implementation of take - we use here natVal, so we have to put the KnownNat constraint, but then we access the n'th element of a hetero-list, which normally would need some constraints, but we can assure haskels TC its true, so we don't need any. I'm looking for a hack to write this length-like function this way, if its possible
14:11:56 <geekosaur> oh, actually I think someone played with using pattern synonyms for something like that? (would require ghc 7.10)
14:12:01 <duckbob> i dont understand why you dont like my fmap????
14:12:16 <duckbob> sorry the link falls short
14:12:20 <geekosaur> could imagine someone defining a pattern synonym using (++)
14:12:26 <EvanR> danilo2: to get a numeric value from an unknown type, you need a constraint. earlier i think you were talking about computing types from types. if you just want to produce the type Int, well thats easy but i think youre trying to get an accurate numeric answer at the value level
14:13:02 <EvanR> danilo2: this has KnownNat constraint
14:13:02 <duckbob> because it uses set
14:13:21 <duckbob> omg why is this so hard
14:13:55 <Iceland_jack> geekosaur: who were you responding to
14:14:00 <danilo2> EvanR: Of course. In fact I'm not trying to produce numerical value from any type (like with using KnownNat - which makes perfect sense). I want to produce numerical value from a type which is a type-level list, which is denoted by its kind and we are sure the numerical value would be produced for any such type, so the situation differs
14:14:10 <duckbob> it should work im sure, i dont see why it cant
14:14:12 <geekosaur> Iceland_jack, miko__ 
14:14:46 <EvanR> danilo2: still but its still different types, despite they happen to have the same kind
14:15:01 <EvanR> sure but*
14:15:08 <danilo2> EvanR: I know that normally that  doesnt even matter. I'm just looking for a way for the maximum api puriness and looking where are the curent boundaries
14:15:45 <danilo2> EvanR: sure, but exactly the same sentence we can tell about my `take` function, still we area able to write it without constraints
14:15:47 <Iceland_jack> miko__: You can easily create a pattern synonym 
14:15:48 <Iceland_jack>     include (Include file) = ...
14:15:59 <EvanR> danilo2: ... but take has constraints
14:16:50 <miko__> Iceland_jack, ok
14:17:51 <danilo2> EvanR: heh :D Sorry for just over-symplifying things. Yes it has constraints, but only for converting the initial Nat to Int, nut doesnt have any constraints that raise from searching for the value inside this hetero-list, which will normally be there if you implement it using stadard type--class machinery
14:17:52 <EvanR> Value -> Value, function. Type -> Value, type class. Type -> Type, type families. your asking for Type -> Value and the fact that the Types are not kind * doesnt seem to factor in, with any technology i know
14:17:54 <Iceland_jack> If you have a function
14:17:54 <Iceland_jack>     parseInclude :: String -> Maybe String
14:17:54 <Iceland_jack> you can define a (bidirectional) synonym
14:17:54 <Iceland_jack>     pattern Include file <- (parseInclude -> Just file)
14:17:55 <duckbob> i dont understand the problem with my function set...
14:17:57 <Iceland_jack>       where Include file = "#include <" ++ file + ">"
14:18:01 <Iceland_jack>     
14:18:09 <EvanR> danilo2: haha yeah and youre trying to convert something to Int!
14:19:07 <danilo2> EvanR: much better example is the `last` function here :P 
14:19:20 <EvanR> last  :: Lens  (List lst) (List (Append x (Init lst))) (Last lst) x
14:19:23 <miko__> Now, something completly different. Is there a valid use for "_" in haskell expressions? If not wouldn't it be a handy language extension to use it for Scala-like placeholer for values yet to curry?
14:19:28 <duckbob> oh man this is super anoying i worked all day on this
14:19:39 <EvanR> not sure what Lens is
14:19:47 <danilo2> EvanR: Control.Lens
14:19:52 <duckbob> i just have to go now and no one even gave me feedback on the function i was working out
14:20:02 <duckbob> thanks for the help you gave me
14:20:18 <EvanR> danilo2: if its some function type... then this is operating on a known type, List
14:20:19 <duckbob> but its really hard to get to the bottom of these things with such sparse discussion
14:20:20 <mauke> miko__: where do you insert the lambda?
14:20:21 <pklausler> miko: _ is a catchall pattern
14:20:26 <Enigmagic> miko__: _ is used for holes already... but i do wish we had something like scala's _ or c++'s _1 _2 _3 would be nice sometimes
14:20:34 <mauke> pklausler: not in expressions
14:20:34 <EvanR> thats why there is no constraint
14:20:49 <Iceland_jack> miko__: Determining the binding site would be a problem
14:21:04 <pklausler> ah.  you want something like APL's alpha and omega.
14:21:05 <miko__> One coule write _*_+_ insteand of \ x y z -> x*y+z
14:21:21 <danilo2> EvanR: not exactly, because `List lst` is just a type level hetero list, like `List '[Int,String,Char]` and you are accessing in this function the last element of it
14:21:25 <mauke> miko__: why not (\x y -> x * y) + z?
14:21:47 <pklausler> sections and partial application cover a lot of those cases
14:21:57 <Iceland_jack> miko__: for fun https://github.com/mmirman/lambda-placeholders
14:22:01 <EvanR> danilo2: i see that List is literally a data type up there
14:22:30 <EvanR> even if its promoted... last :: is treating it like a type not a kind
14:23:03 <miko__> Mauke, Is there a difference? When I learned haskell I was told I could think of haskell lambdas taking only one arguemnt ever, so they return the curried funktion if there are not enough.
14:23:16 <geekosaur> and now I'm imagining perl 6's $^x :p
14:24:18 <EvanR> danilo2: you can literally write length for List like a normal function, because it is
14:24:22 <mauke> miko__: yes, there is a difference between f (\x -> x) and (\x -> f x)
14:24:41 <EvanR> but '[] are not data types
14:25:18 <EvanR> functions cant operate on them
14:25:34 <danilo2> EvanR: Yes, I understand it. I was just curious about this because I feel we can theoretically do better here. But I might be of course wrong. I've got to rethink this once again. I jsut dont like constraints that doesnt introduce any information to the user, because no matter what type user puts there, the cosntraint would be solved. 
14:25:48 <EvanR> you probably can, but not in any way i know in haskell
14:26:01 <EvanR> danilo2: i agree, constraints to do this stuff is silly
14:26:22 <danilo2> EvanR: in fact the constraints that I posted in the examples are ok for me. The problem is a constraint that is really big and uses nested TF-s that just appeared on front of me in one of the functions
14:26:24 <EvanR> even if it does provide information, its hard to figure out what
14:26:53 <Enigmagic> danilo2: yeah, i run into this issue frequently with closed type families
14:26:53 <EvanR> give up and use dependent types !
14:27:00 <danilo2> EvanR: exactly - and because of that I was asking if something chaged maybe in GHC8 tahat would allow for hiding this unused complexity
14:27:40 <danilo2> EvanR, Enigmagic: "glad" I'm not alone with this problem here :D
14:28:36 <danilo2> Enigmagic: look at my code, you can fight some of the issues using unsafecoerce (of corse if yuo use it wisely) : http://lpaste.net/157691
14:28:52 <danilo2> unfortunetally not all of them :/
14:29:44 <EvanR> i dont even know if that is solving the same problem youre talking about
14:29:48 <danilo2> EvanR: these are some kind of dependent types in hs, arent they? ;)
14:30:08 <danilo2> EvanR: I think a very,very,very relative one
14:30:38 <EvanR> the point about DT is that asking for the length of the list would have already been solved
14:30:47 <EvanR> because a type level list is just a regular list
14:31:09 <aisqwe> leksah is stuck at updating metadata !!??
14:40:45 <Enigmagic> danilo2: i just deal with the constraints for now :-) i like to avoid unsafeCoerce#
14:41:03 * hackagebot language-c-quote 0.11.5 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.5 (GeoffreyMainland)
14:41:29 <danilo2> Enigmagic: sure thing. I'm using it very rarely, when implementig really low-level stuff, like fancy hetero-lists :)
14:49:23 <Enigmagic> danilo2: one thing i'm hoping is fixed/improved in GHC 8 is pattern matching on GADTs
15:01:48 <j0llyr0tten> :t ((\x -> (\y -> (y x))) y)
15:01:49 <lambdabot> (Expr -> r) -> r
15:03:42 <j0llyr0tten> another place says it should be y1 -> y1 y
15:04:29 <j0llyr0tten> :k ((\x -> (\y -> (y x))) y)
15:04:30 <lambdabot> parse error on input ‘\’
15:04:34 <Enigmagic> :r
15:04:50 <j0llyr0tten> ?
15:04:58 <danilo2> Enigmagic: that would be really helpful!
15:05:40 <danilo2> Enigmagic: I'm dreaming about another feature - ability to do the same ith TypeFamilies and newtypes as you can currently do with GADTs
15:05:59 <j0llyr0tten> can someone help me reason through this?     ((\x -> (\y -> (y x))) y)
15:06:20 <j0llyr0tten> i'm writing a top lisp and i can't figure out if i'm getting the correct result
15:06:44 <j0llyr0tten> so i tried it in haskell but of course 'y' is not found
15:07:13 <j0llyr0tten> i need third y to clash with other one
15:07:40 <j0llyr0tten> a toy* lisp :)
15:11:04 <Enigmagic> danilo2: looksl ike the answer is no.. at least with 8.0-rc2 https://gist.github.com/NathanHowell/b63d6b92d9e814384ae7592a7ec44b56
15:11:16 <Enigmagic> at least for the case that bothers me :-)
15:12:27 <danilo2> Enigmagic: I'm also interesting in this case. Anyway there are more important things in GHC right now, compilation time performance - I think this is crutial. Then ome fancy stuff for geeks :D
15:14:23 <Enigmagic> danilo2: agreed, i was curious how much the new pattern match warning stuff has changed. apparently not much for fancy types and gadts :-)
15:23:31 <RyanGlScott> Enigmatic: Why would you expect that code to typecheck?
15:24:32 <RyanGlScott> That error message seems sensible to me. There's no way to conclude that a ~ 'Y or b ~ 'Y.
15:24:41 <Enigmagic> RyanGlScott: i don't expect it to, bottom gets in the way a lot :p
15:24:57 <Enigmagic> it would be nice if it did though.
15:25:51 <RyanGlScott> Sure, but even without that, there's other cases you've missed, no? e.g., f (AY _) (AZ _ _)
15:26:12 <RyanGlScott> So it's not like GHC could even conclude that that's the only case remaining
15:27:00 <Enigmagic> RyanGlScott: indeed i did
15:27:04 <Enigmagic> however it doesn't work anyways
15:27:17 <Enigmagic> bad reduced test case :-)
15:27:35 <danilo2> hello mgsloan ! :) Have you received my mail? :)
15:28:13 <RyanGlScott> The only changes you'd observe in 8.0 are when pattern matching refutes equality constraints are in scope
15:28:32 <danilo2> mgsloan: sory for catching you this way, your nick just appeared in my window so I though I'll try to catch you here :)
15:28:42 <RyanGlScott> But f doesn't do anything of the sort, AFAICS
15:29:25 <Enigmagic> RyanGlScott: that's what it seems. i never read through the ticket, just saw lots of stuff about space leaks and whatnot.
15:29:52 <RyanGlScott> Well, hopefully those are gone now. If not, please revive the ticket :)
15:35:14 <jophish_> What do people prefer out of these https://gist.github.com/c92ea2d4f68caa14202b4aa6516f37b7
15:35:28 <jophish_> one has overlapping instances, the other is a little more funky with the constraints
15:37:00 <danilo2> jophish_: the second one
15:37:23 <danilo2> jophish_: why would you allow such constraint to appear in some type resolutions while your users would use the library ?
15:39:28 <jophish_> I suppose it would be nice if ghc could infer one from the other
15:41:34 <j0llyr0tten> it would be nice if ghc could infer from my thoughts what i want
15:42:13 <dmj> :set -XInferThoughts
15:42:22 <j0llyr0tten> super
15:42:51 <jophish_> j0llyr0tten: Just make your program a member function of a class and DeriveAnyClass
15:44:08 <haskell674> Hi
15:44:17 <haskell674> I'm doing examples from here http://learnyouahaskell.com/starting-out
15:44:28 <haskell674> doubleMe x = x + x  
15:44:35 <haskell674> is giving me <interactive>:6:12: parse error on input ‘=’
15:44:37 <haskell674> error
15:45:03 <dmj> haskell674: add a 'let' in front of it
15:45:08 <dmj> let doubleMe x = x + x 
15:45:22 <haskell674> Thanks
15:45:23 <dmj> @def doubleMe x = x + x 
15:45:25 <lambdabot>  Defined.
15:45:27 <dmj> > doubleMe 10
15:45:29 <lambdabot>  20
15:45:31 <Gurkenglas> In https://hackage.haskell.org/package/reactive-banana-1.1.0.0/docs/Reactive-Banana-Combinators.html#g:6 , in the definition of accumE, couldn't you replace the conversion of e2 to a behavior and application to e1 with a zipping of e2 with e1? If so, how can this introduce time-varying behavior, if every time only interacts with itself?
15:45:57 <haskell674> I then declare a function like this
15:45:58 <haskell674> let remo :: Eq a => a -> [a] -> [a]
15:46:05 <haskell674>     The type signature for ‘remo’ lacks an accompanying binding
15:46:10 <Gurkenglas> umm, "time varying behavior" might be badly worded there lol, I mean how can earlier times impact later ones in the result e2?
15:46:27 <haskell674> This is supposed to take a list and an element from list and then return a list
15:48:04 <geekosaur> haskell674, if doing this at the ghci prompt then you need to do them on the same line:    let remo :: Eq a => a -> [a] -> [a]; remo ...
15:49:05 <haskell674> Sorry I'm a bit unfamiliar with haskell what do you mean by that?
15:49:56 <geekosaur> the page you are referencing from LYAH expects you to put definitions in a file
15:50:22 <haskell674> oh ok
15:50:34 <haskell674> thank you very much
15:50:44 <dmj> "Once inside GHCI, do :l baby. Now that our script is loaded, we can play with the function that we defined."
15:51:05 * hackagebot vector-sized 0.3.2.0 - Size tagged vectors  https://hackage.haskell.org/package/vector-sized-0.3.2.0 (jophish)
15:52:50 <geekosaur> if you are doing them at the ghci prompt instead then you need to combine them in one line (using semicolon in place of new lines) and prepend "let", as I showed
15:53:01 * geekosaur sighs --- keep losing connection to bouncer
15:53:23 <ertesx> is there a way to make GHCi compile instead of interpret in interactive mode?
15:53:47 <geekosaur> this isn't needed for *all* definitions, just ones where you are using the same name (like when attaching a type signature)
15:56:06 * hackagebot acme-left-pad 1.0 - free your haskell from the tyranny of npm!  https://hackage.haskell.org/package/acme-left-pad-1.0 (JoeQuinn)
15:58:10 <ertesx> nevermind…  i've lowered the sample rate, so GHCi is fast enough now =)
15:59:28 * mgsloan just used that publishing of acme-left-pad to test a fix to a little stack regression :)
15:59:34 <mgsloan> It's not useless afterall!!!
16:00:03 <hpc> mgsloan: :D :D :D
16:00:18 <hpc> cabal didn't warn that i was publishing an empty exposed module list
16:01:04 <mgsloan> I guess it could be valuable to have a package with no exports.  Like if you just depend on it for TH side effects XD
16:01:06 * hackagebot acme-left-pad 2.0 - free your haskell from the tyranny of npm!  https://hackage.haskell.org/package/acme-left-pad-2.0 (JoeQuinn)
16:02:11 <ertesx> "Deprecated in favour of: base"
16:03:12 <hpc> i cannot get a foo -any dependency to work for the life of me
16:03:53 <ertesx> hpc: `build-depends: foo`, doesn't work?
16:04:31 <hpc> i mean, it should
16:05:09 <hpc> oh woops, acme-left-pad, not left-pad
16:05:30 <hpc> i am so smart, smrt
16:05:30 <Cale> hpc: Now you just need to wait until you have a dependency, and then make a version 3.0 which exports no modules again
16:05:52 <jle`> is it accurate to say that vanilla Haskell already has dependent products?
16:06:02 <Cale> jle`: ... no?
16:06:05 <jle`> just not dependent sums?
16:06:11 <Cale> no, it has neither
16:06:18 <hpc> Cale: you say that, the first dependency is going to be acme-php
16:06:29 <hpc> but i just cannot be a programmer for 3 seconds to make it work
16:06:49 <jle`> isn't a `forall a. Maybe a` a dependent product?
16:07:02 <Cale> Not depending on values
16:07:03 <hpc> i was made by scientists in a secret government lab for the sole purpose of writing this garbage code
16:07:24 <Cale> In a dependently typed language with universes, you'd get that as a special case of the dependent product
16:07:27 <jle`> then how about forall a. Proxy a
16:07:37 <hpc>   Build-depends:       acme-left-pad >=2, base >=4 && <5
16:07:41 <hpc> what am i doing wrong there?
16:07:44 <jle`> for any a, you can get a Proxy a
16:07:56 <hpc> (ignore that base, i am on an older ghc)
16:07:57 <jle`> a dependent product over the universe of types
16:08:03 <Cale> jle`: yeah
16:08:16 <Cale> But Haskell only allows types to depend on other types
16:08:25 <j0llyr0tten> i have a company called acme-left and we make pads
16:08:28 <jle`> ah
16:08:34 <jle`> of course
16:08:41 <jle`> thank you for helping me clear that up
16:08:50 <Cale> no problem :)
16:09:27 <j0llyr0tten> and that's not really depending, right? depending is only dependent on values iirc?#
16:10:53 <Cale> j0llyr0tten: Well, if this were agda or something, Maybe would depend on a value in a universe type, i.e. a type inhabited by types.
16:11:06 * hackagebot vulkan 1.6.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-1.6.0.0 (jophish)
16:12:54 <ertesx> jle`: you can get the expressivity equivalent to a dependently typed language in haskell with a bunch of extensions, but you don't get dependent types themselves
16:13:02 <joeyh> what's the right way to get singleton Nats? I want DataKind promotion so I can have types like Port 80
16:13:04 <hexagoxel> hpc: could you please check the issue tracker, and add an issue about the empty exposed list for libraries? seems indeed like a useful check.
16:13:33 <joeyh> $(singletons [d|data Foo = Foo Nat|]) -- fails to build, Couldn't match type ‘Integer’ with ‘Nat’
16:14:16 <jle`> you need to parameterized
16:14:24 <jle`> *parameterize
16:14:31 <joeyh> what seems to be going on is singletons is using natVal in the fromSing implementation for Nats.. but that generates an Integer, not a Nat
16:14:46 <jle`> at least in the current state of Haskell and singletons, unfortunately
16:14:48 <ertesx> jle`: you might find this paste interesting: http://lpaste.net/109388
16:15:01 <jle`> you need data Foo nat = Foo nat
16:15:14 <jle`> and your value level will be Foo Integer
16:15:21 <jle`> your type level will be kind Foo Nat
16:15:36 <jle`> Integer and Nat have Sing instances that make it all work out
16:16:15 <jle`> the singleton of a Foo Integer works out to be a kind-Foo Nat, according to the Sing instance for Nat
16:16:17 <joeyh> how would I use such a data type?
16:16:35 <jle`> it's super annoying but it gets you want you want
16:16:38 <joeyh> oh, I see, sorry missed line
16:16:43 <joeyh> yeah, that is annoying!
16:17:16 <jle`> hopefully we can figure out something better in the future
16:17:54 <joeyh> so how do I write the type Foo 80? Something like Foo Nat 80 ?
16:19:56 <joeyh> ie, let x = sing :: Foo 80 -- not quite
16:21:06 * hackagebot varying 0.5.0.0 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.5.0.0 (SchellScivally)
16:23:33 <jle`> erresx:  thanks!
16:23:50 <jle`> *ertesx
16:24:16 <ertesx> jle`: you're welcome…  the paste is from 2014, but i believe it's still up to date
16:36:07 * hackagebot acme-left-pad 3.0 - free your haskell from the tyranny of npm!  https://hackage.haskell.org/package/acme-left-pad-3.0 (JoeQuinn)
16:36:11 <jle`> joeyh: try let x = sing :: Sing (Foo 80)
16:36:37 <hpc> acme-left-pad now comes with revolutionary new features like successful compilation
16:37:30 <jle`> not enough dependencies
16:37:41 <hpc> jle`: wait for it
16:38:17 <jle`> i actually *have* written unlawful padding lenses in the past
16:38:29 <joeyh> The first argument of ‘Foo’ should have kind ‘*’, but ‘80’ has kind ‘Nat’
16:38:37 <hpc> (keep waiting)
16:38:45 <jle`> joeyh: do you have PolyKinds turned on?
16:38:56 <joeyh> oh no, not polykinds again
16:39:15 <joeyh> well, didn't seem to help in this case
16:39:21 <c_wraith> that should need DataKinds, not PolyKinds
16:39:45 <EvanR> can't wait for -XKindInKind
16:39:52 <jle`> joeyh: what is :t SFoo 80 ?
16:40:07 <geekosaur> shouldn't that be covered by TypeInType in the New World Order?
16:40:08 <jle`>  :t SFoo (80 :: Integer)
16:40:11 <joeyh> SFoo 80 :: forall (nat :: BOX) (n :: nat). Num (Sing n) => Sing ('Foo n)
16:40:14 <jle`> neat
16:40:14 <EvanR> i guess so
16:40:19 <dmj> does polykinds automatically turn on data kinds?
16:40:21 <jle`> so things are working correctly
16:40:48 <c_wraith> dmj, negatory 
16:41:06 <dmj> c_wraith: I see. That's interesting
16:41:07 * hackagebot acme-php 0.0.4 - The flexibility of Haskell and the safety of PHP  https://hackage.haskell.org/package/acme-php-0.0.4 (JoeQuinn)
16:41:10 <EvanR> speaking of explain stuff to beginners... the kind stuff should interesting once TypeInType is a thing
16:41:38 <hpc> ah, there it is
16:41:41 <EvanR> * is the kind of haskell types... that have values. unless you have TypeInType enabled, then its also the type of itself
16:41:56 <EvanR> should clear things up
16:42:28 <EvanR> and * will be deprecated
16:43:53 <c_wraith> depreciating * is probably a good idea. it took me forever to internalize that it isn't polymorphic 
16:44:08 <c_wraith> ... deprecating 
16:44:58 <EvanR> how would it be confused for some kind of polymorphism
16:45:28 <c_wraith> * is often a symbol used by wildcards 
16:45:32 <EvanR> ah
16:45:38 <EvanR> * = "any type"
16:45:45 <c_wraith> yep. 
16:46:14 * EvanR immediately clears the screen so as not to think of it that way
16:46:54 <EvanR> god now you have me worried that people will be thinking of that when i show slides with a * on it
16:47:03 <pavonia> How is * different from the "any type" interpretation?
16:47:12 <ertesx> the subtle difference between "any" and "all"
16:47:32 <EvanR> its not any nor is it all, its a randomly chosen type name
16:47:33 <magbo> Hello, everyone! I hope it's okay to link a haskell-cafe thread I've started here and ask for feedback. https://mail.haskell.org/pipermail/haskell-cafe/2016-March/123528.html
16:48:02 <EvanR> forall a . a <- any type
17:03:07 <maerwald> not really a haskell question, but regarding a haskell project of mine: given a path "/foo/bar/baz"... is there any scenario where the systemcall `realpath "/foo/bar" would fail, but the non-canonicalized "/foo/bar/baz" would still point to an existing file? I wonder if I can assume failure of reading "/foo/bar/baz" when `realpath "/foo/bar" already fails
17:09:00 <xa0> @
17:10:30 <zRecursive> sorry again ! what does "ghc.exe: unable to load package `time-1.5.0.1'" and "Leaving GHCi.\n  <interactive>: C:\haskell\ghc-7.10.3\lib\time_IYbjC7tGONY15oDy1fGJKz\HStime-1.5.0.1-IYbjC7tGONY15oDy1fGJKz.o: unknown symbol `__localtime32'" mean ? How can i fix it ?
17:12:14 <zRecursive> `nm HStime-1.5.0.1-IYbjC7tGONY15oDy1fGJKz.o | grep -i localtime32` => U __localtime32\n  00002280 D _timezuIYbjC7tGONY15oDy1fGJKzz_DataziTimeziFormat_zdfFormatTimeLocalTime32_closure
17:21:36 <j0llyr0tten> Cale: indeed
17:23:09 <Zemyla> Can an overlapping instance define a type or data family?
17:24:35 <harwiltz> Hey guys. I'm making a puzzle game in haskell and I'm getting a really weird issue. I have a function that returns IO(Int,Int,Int), and my issue arises when I retrieve the first Int in that tuple. If I print its value immediately after I retrieve it, I get the correct value. However, when I pass it directly to another function (that doesn't change the value) the value somehow is different.
17:24:40 <harwiltz> Any idea how that's possible?
17:24:49 <harwiltz> I have pastebin'd the code if you want
17:25:11 <caconym> harwiltz: getting a look at the code is probably the first step
17:25:29 <harwiltz> caconym: http://ideone.com/Awju8l
17:26:15 <harwiltz> You don't have to look at the entire if/else chain. I retrieve the value right around where you see mvWAddStr in the if/else, and then pass it to the same function recursively
17:26:30 <harwiltz> For example, check lines 21-23
17:27:38 <harwiltz> I'm really confused at how this happens since haskell has no 'side effects', so not sure how my value is changing when I'm not explicitly changing it
17:28:36 <caconym> well
17:28:51 <caconym> `IO a` might have side effects
17:29:09 <caconym> since it's in IO
17:29:19 <harwiltz> caconym: Ok, fair enough, but in my code there is nothing happening to the said variable in between prints
17:30:12 <harwiltz> I basically print it, pass it to a function, and print it again. Nothing should be happening to it in between
17:30:24 <caconym> i'm not an expert on these aspects of Haskell but it is possible to have a "lazy value" come out of an IO action that has not actually been evaluated yet
17:30:42 <harwiltz> caconym: But if it was printed hasn't it already been evaluated?
17:30:48 <caconym> ah, yes
17:31:16 <harwiltz> That's what I don't get. I'm basically printing it twice in a row and getting different results.
17:31:16 <caconym> that is correct as far as i know
17:31:43 <harwiltz> I should also add that the results are kind of predictable. In most error cases, it just appends the number 5 to the ideal value
17:31:43 <kadoban> harwiltz: What prints are you talking about exactly?
17:32:03 <harwiltz> kadoban: It's a ncurses program, so I'm printing to the ncurses window with mvWAddStr
17:33:05 <harwiltz> It doesn't add the number 5, it appends it, like as if both Ints were Strings. For example, if my value should be 8, it prints 85, and if my value should be 0, it prints 05
17:33:32 <harwiltz> It's not necessarily a 5 either. 
17:33:57 <kadoban> I don't think I'm really following you, sorry.
17:34:12 <caconym> same here
17:34:23 <harwiltz> Sorry guys, probably bad explanation, I'll try again
17:34:41 <harwiltz> I get this error after I make a move in the game (I print the value twice after I make the move)
17:34:56 <ghostman> hi
17:34:58 <johnw> caconym: unsafeInterleaveIO will somewhat do what you describe
17:34:59 <harwiltz> If I'm moving to position 8, the first time it prints 8 and the second time it prints 85
17:35:15 <johnw> although it's usually a bad idea to use directly
17:35:17 <harwiltz> If I'm moving to position 0, the first time it prints 0 and the second time it prints 05
17:37:24 <harwiltz> The first time I print it is directly after I retrieve the value, the second time is right after I pass it to the function
17:37:37 <harwiltz> There shouldn't be any difference between both prints
17:37:49 <caconym> using curses muddies the water a bit
17:37:56 <caconym> have you tried cutting that out of the loop?
17:38:35 <harwiltz> caconym: I'm not sure how that would change anything. The only curses code I have here are the 'print statements', and I tried removing those but I still get buggy behavior due to the error
17:41:07 <caconym> it's pretty easy to have curses do unexpected stuff relative to simple print statements, is all i mean; if you still see buggy behavior then that's probably not the issue
17:42:04 <harwiltz> caconym: Fair enough. But all lines after the first print statement seem completely independent of that variable. That's why I'm so confused
17:42:13 <MarcelineVQ> is it always a 5 it adds? what's the value of scrSize?
17:42:29 <harwiltz> MarcelineVQ: It's not always 5. Sometimes it's 0 I think
17:42:33 <harwiltz> I'll check the scrSize
17:42:47 <lkj> hey all
17:43:06 <lkj> is there a preferred package between units and dimensional?
17:43:18 <lkj> for dimensional analysis?
17:44:03 <harwiltz> MarcelineVQ: scrSize returns (64,116). Actually, the values appended are independent of scrSize because I'm running the window half-size now and I'm getting the same errors as before
17:44:23 <harwiltz> And just confirmed that sometimes it appends 0
17:48:25 <caconym> the 'appending' behavior makes me thing you're printing two different numbers on top of each other due to curses being curses
17:48:52 <harwiltz> caconym: I was thinking that, but I'm pretty sure I'm still getting bugs even when I don't print
17:48:56 <caconym> even if there is a bug, said behavior might be a red herring
17:49:07 <harwiltz> caconym: What does that mean?
17:49:23 <caconym> by which i mean something that's obscuring the problem by presenting its own bizarre behavior
17:49:31 <caconym> i.e. ints are behaving like strings
17:49:48 <caconym> and being appended with a mysterious value from who knows where
17:49:50 <harwiltz> Oh so the problem is something else, but I'm fixating on the wrong thing
17:49:57 <harwiltz> Makes sense
17:49:59 <caconym> yeah, just an idea i suppose
17:50:08 <harwiltz> Makes the most sense so far!
17:50:37 <caconym> maybe sending these print statements to a file or similar would elucidate matters?
17:51:03 <harwiltz> I'm going to try printing to stdout and checking once I end the ncurses window
17:51:12 <caconym> that's what i would do
17:51:38 <caconym> if there's a value being printed "under" the one you expect, it may be familiar once you see it in its entirety
17:52:32 <harwiltz> good point
17:53:28 <harwiltz> nope still getting the same crap. But for some reason it's printing on my ncurses window when I use putStrLn. I'll try writing to a file
17:53:51 <MarcelineVQ> do you have this as a project you could share?
17:53:55 <caconym> ncurses messes with the "terminal settings" or whatever the technical term is, i think
17:55:39 <maerwald> ncurses sucks
17:55:39 <harwiltz> MarcelineVQ: you want to see the whole source?
17:55:51 <caconym> btw i recommend checking out the 'vty' package as a possible alternative to ncurses
17:56:01 <harwiltz> It's not that long, but I don't see how anything other than what I posted has any affect
17:56:05 <geekosaur> harwiltz, terminals do not have windows
17:56:23 <harwiltz> caconym: I know, I've heard, but I'm just trying to write this quickly for fun and I already know a bit of hscurses
17:56:27 <geekosaur> if you are mixing putStrLn and curses I/O, absolutely they will get tangled together
17:56:42 <harwiltz> geekosaur: evidently so hahaha
17:56:43 <geekosaur> (same with vty or any other terminal-based package)
17:57:13 <geekosaur> don't mix them at all, do your other output to a file or something
17:57:20 <caconym> agreed
17:57:22 <harwiltz> geekosaur: Im going to try that
17:57:27 <caconym> "it's the only way to be sure"
17:57:51 <MarcelineVQ> "<harwiltz> MarcelineVQ: you want to see the whole source?" yus
17:58:10 <geekosaur> alternately you can do the output to a separate panel, but you will need to learn about now curses panels work to do that
17:58:14 <geekosaur> *about how
17:58:20 <harwiltz> MarcelineVQ: As you wish, though I should warn you my code is terrible.
17:59:28 <harwiltz> MarcelineVQ: http://ideone.com/DqTgHN
18:03:59 <harwiltz> Ok guys. Apparently it's getting the right values. Now I see where the error comes from I think.
18:04:14 <harwiltz> caconym: I think you were right, it seems to have been printing stuff on top of itself
18:04:14 <caconym> hooray!
18:04:27 <harwiltz> hooray for peace of mind indeed hahaha
18:04:32 <harwiltz> I thought I was going nuts
18:04:52 <harwiltz> now to find the real source of the problem...
18:04:53 <erikd> zRecursive: it looks like your ghc installation is broken. how did you install it and when?
18:05:33 <MarcelineVQ> Glad you narrowed it down, I can't even get it to run hehe, curses be crazy
18:05:49 <caconym> harwiltz: good luck!
18:05:53 <Gurkenglas> Can stack install missing C libraries for me on windows?
18:07:00 <harwiltz> caconym: thanks
18:07:06 <harwiltz> Thanks for the help everyone
18:07:09 <geekosaur> not last I checked. it does install a mingw to provide some necessary libraries but it doesn't go beyond that
18:07:13 <geekosaur> (or it did install)
18:08:31 <MarcelineVQ> harwiltz: you don't need a single do in applyMove btw
18:09:16 <MarcelineVQ> well maybe the top one, I haven't cleaned up up to see, but for the most part just about every do in this source code is redundant
18:10:05 <average> will we all write Haskell by 2020 ?
18:10:37 <MarcelineVQ> average: yes but we'll call it Faskelltro, that's a portmanteux of future haskell restro
18:10:44 <MarcelineVQ> retro :>
18:11:03 <caconym> by 2020 i will have been replaced in my job by a robot
18:11:06 <harwiltz> MarcelineVQ: Ok, thanks. I think I just put them there just in case
18:11:08 <caconym> maybe the robot will use haskell
18:11:10 * hackagebot printf-safe 0.1.0.0 - Type safe interface for Text.Printf  https://hackage.haskell.org/package/printf-safe-0.1.0.0 (kcsongor)
18:11:57 <average> Simon Peyton Jones defens Haskell like a true badass
18:12:01 <average> *defends 
18:12:02 <average> https://www.youtube.com/watch?v=iSmkqocn0oQ
18:12:58 <xa0> hvr: what is the status on this proposal https://ghc.haskell.org/trac/ghc/ticket/10448 ?
18:13:07 <average> Simon is soooooo gooood at selling things
18:13:15 <average> oh man, he's like.. amazing at selling stuff
18:13:21 <caconym> and if you bad-mouth haskell he's always listening: http://research.microsoft.com/en-us/um/people/simonpj/Pictures/spjJun06.8rot.jpg
18:13:31 <xa0> RyanGlScott: cc
18:13:38 <MarcelineVQ> caconym: amazing pic
18:14:03 <caconym> yeah it's a real gem haha
18:14:34 <RyanGlScott> xa0: Probably won't happen until after GHC 8.0 is released.
18:14:59 <xa0> RyanGlScott: I see, okay thanks
18:16:08 <maerwald> average: I think he is quite open-minded and maybe less convinced of haskell than a lot of other people... although that doesn't show in his extrodinary commitment. It's research after all.
18:16:45 <maerwald> (and yes, I understand the pun in the video)
18:17:25 <MarcelineVQ> harwiltz: do is typically just to make using >>= and >> cleaner. this page may help a bit to clarify what that means in practice https://en.wikibooks.org/wiki/Haskell/do_notation
18:17:55 <harwiltz> MarcelineVQ: Thanks. I'll be checking into that. Never really understood monads
18:19:41 <average> there's this entire obsession that Haskell has with types
18:19:56 <average> it's as if.. all bugs were caused by types
18:20:11 <average> and somehow Simon Peyton Jones, and that bearded Philip Wadler guy
18:20:20 <average> they figured out this huge secret that nobody had ever thought about
18:20:42 <average> (or whoever designed Haskell)
18:21:48 <average> amazing
18:23:50 <maerwald> well, it's a class of bugs, not all
18:24:30 <MarcelineVQ> It's a pretty old idea, it probably began in the 30's or even earlier really, ratified by curry and howard with their https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
18:24:34 <average> maerwald: yeah but i mean when Haskell is promoted
18:24:36 <maerwald> and it also depends on how people use them... there are strill stronger and weaker types
18:24:44 <average> every promoter hits hard on the type-bugs thing
18:25:01 <average> he's like "oh yeah, and all other languages suck because types and side-effects, Haskell wins yay !!"
18:25:02 <maerwald> You can still express data structures with strings and pass them around your program in haskell...
18:25:15 <maerwald> which isn't a good idea, but still happens
18:25:53 <maerwald> or abuse Int/Bool/tuples etc
18:26:04 <average> I mean check out Simon, he's like a role-model for any aspiring technology/software seller https://www.youtube.com/watch?v=xmjvOLlCdFU
18:26:08 <average> he sells haaaaard
18:26:55 <zRecursive> erikd: just come back! I installed them from ghc-7.10.3-i386-unknown-mingw32.tar.xz and cabal-1.22.0.0-i386-unknown-mingw32.exe.
18:31:11 <erikd> zRecursive: what version of windows are you on?
18:46:00 <zRecursive> erikd: windows XP
18:46:19 <zRecursive> An old HP box
18:48:20 <erikd> zRecursive: i'm a linux guy so my windows knowledge is rather shakey. i wonder if XP is still supported. did you read the release notes from where you got the ghc install?
18:48:50 <icicled> anyone know what's going on with Hackage w/regards to the docs not being generated?
18:49:25 <icicled> I'm seeing package versions from late last year that don't have their docs generated
18:51:11 * hackagebot scotty-resource 0.1.0.0 - A Better way of modeling web resources.  https://hackage.haskell.org/package/scotty-resource-0.1.0.0 (taphu)
18:51:27 <geekosaur> icicled, try in #hackage?>
18:51:38 <icicled> will do thanks
18:51:55 <geekosaur> some packges won't have docs because they're for windows (there is only a linux buildbot), some because the buildbot lacks the necessary C libs
18:52:01 <zRecursive> erikd: Indeed this problem is VERY weird. GHC works great on my freebsd and linux box too.
18:52:04 <geekosaur> every so often they shut off the builder because of overload
18:53:18 <icicled> is it a resource issue?
18:54:48 <erikd> zRecursive: i really do suspect that most people are installing that tarball on a later version of windows.
18:55:23 <zRecursive> yeah
19:54:38 <mathstuf> hi, im trying to compile ghc from ports on freebsd and hitting an error in bytestring
19:54:55 <mathstuf> it says there's a parse error with '#)'
19:55:08 <mathstuf> in a macro expansion
19:55:12 <mathstuf> getting a link to the line..
19:56:14 <mathstuf> (349 for anyone with faster internet right now)
19:57:44 <mathstuf> https://github.com/haskell/bytestring/blob/master/Data/ByteString/Builder/ASCII.hs#L349
19:57:59 <geekosaur> mathstuf, that sounds like it's hitting the clang cpp issue
19:58:27 <mathstuf> i am using clang (the one that comes with freebsd)
19:59:01 <mathstuf> is there a workaround?
20:00:55 <geekosaur> there's probably code to handle it on OS X, which nobody thought to also enable for freebsd 10
20:01:57 <mathstuf> ill check macports for a patch. there isnt anything in bytestring's repo
20:02:45 <geekosaur> macports builds with gcc from macports. I'm not using or closely following freebsd atm but I thought they were considering the same kind of solution on freebsd versions that use clang in base
20:04:50 <mathstuf> hrm
20:05:07 <mathstuf> would like to avoid having gcc hanging out in a jail
20:05:41 <geekosaur> some workarounds were attempted on the ghc side but there are some things that can't be turned off in clang's cpp
20:06:33 <mathstuf> is it trying to parse it as a preprocessor directive?
20:09:29 <mathstuf> meh, just acting as if INTEGER_GMP isn't defined seemed to work
20:09:49 <mathstuf> maybe... :/
20:11:18 <geekosaur> yes. ANSI C has a bunch of additional preprocessor directives, in particular # and ## are used for token pasting (and `#)` cannot yield a valid token)
20:11:31 <geekosaur> (sorry, still having local network iussues)
20:11:46 <mathstuf> same here :)
20:11:58 <mathstuf> apt wireless is ~256 kBps and up to 3 connections at a time
20:12:02 <mathstuf> or so it seems
20:12:24 <mathstuf> (even DNS fails if there are a few pipes downloading or the speeds are up around 200 kBps)
20:12:41 <mathstuf> lots of joy
20:15:16 <mathstuf> ok, yeah, more '#' failures
20:15:22 <mathstuf> back to gcc it seems
20:19:13 <Gurkenglas> :t (Data.Functor.$>) -- hpc, jle` - looks like it just isn't imported by L.hs ._.
20:19:14 <lambdabot> Functor f => f a -> b -> f b
20:29:47 <echo-area> What's the name of #haskell-blah?  My attempt to join it was redirected to ##nossl
20:31:26 <geekosaur> echo-area, IIRC #haskell-blah now requires connections authenticated via SASL
20:31:55 <geekosaur> or presumably using irc over ssl, given the redirect
20:32:04 <echo-area> geekosaur: I see, thanks.
20:41:15 * hackagebot quiver-binary 0.1.0.0 - Binary serialisation support for Quivers  https://hackage.haskell.org/package/quiver-binary-0.1.0.0 (IvanMiljenovic)
20:53:02 <jle`> echo-area: see the topic of ##nossl for more details
20:53:08 <Chief_life> !notes
20:53:13 <Chief_life> or rules?
20:54:00 <Chief_life> good day
20:54:08 <echo-area> jle`: Yep, I've re-logged in via tls and in that channel :)
20:54:45 <EvanR> are any other channels redirecting to #nossl because if not the fact that the topic doesn't even mention #haskell-blah could cause confusion
20:54:55 <jle`> :D
21:04:38 <ij> How do I make a UTCTime, if it's only made by getCurrentTime?
21:05:47 <ij> buildTime, I guess
21:06:10 <mathu> lambdabot's @src command outputs a different source than is found on hoogle+hackage. what is it querying instead?
21:06:35 <mathu> oh it's on github i can probably dig and find it
21:06:45 <kadoban> mathu: lambdabot's @src is full of lies. It's just a text file someone wrote
21:07:01 <mathu> really? lmao that's... a little bit surprising
21:07:42 <kadoban> Yeah. Most of them are … useful at least. It's missing a lot though, and there's no real reasoning behind what's in there and not AFAIK.
21:09:00 <EvanR> ij: UTCTime is a Num
21:09:04 <Gurkenglas> https://www.reddit.com/r/technology/comments/4clgv6/microsoft_is_adding_the_linux_command_line_to/ wooo so much about the installing C libraries problem
21:09:04 <EvanR> and Fractional
21:09:13 <Gurkenglas> Maybe even network will work now!
21:09:23 <EvanR> er no thats not right
21:09:47 <ij> EvanR, ah, right
21:09:55 <EvanR> its not Num nor Fractional
21:10:13 <EvanR> UTCTime is the combination of a Day and number of seconds past midnight
21:10:24 <EvanR> so you can created it that way, or you can parse a string
21:10:37 <ij> i went with parsing a string.
21:11:04 <EvanR> if you have another time type there are ways to convert it into UTCTime either directly or if you provide more information (like time zone)
21:11:53 <EvanR> ij: here is the missing map! https://github.com/evanrinehart/time-diagram
21:12:39 <ij> sweet
21:13:42 * echo-area imagines EvanR draws that diagram instantly
21:14:23 <mathstuf> geekosaur: so even with gcc, im getting errors
21:14:44 <mathstuf> utils/hpc/HpcParser.hs:100 or so
21:15:10 <mathstuf> #define LT(n,m) ((Happy_GHC_Exts.tagToEnum# (n Happy_GHC_Exts.<# m)) :: Bool)
21:15:23 <mathstuf> says that Happy_GHC_Exts.< is not a valid symbol
21:15:50 <mathstuf> hrm
21:15:57 <mathstuf> config.log says its still using clang :/
21:16:01 <EvanR> POSIXTime is Num but adding two POSIXTimes together is probably a recipe for disaster
21:16:58 <mathstuf> gah, missed the ghc package in my sed to switch the option around
21:17:13 <mathstuf> ok, well, hopefully by the time i wake up, this will be done
21:29:48 <ij> Looking for a function that would prettyprint NominalDiffTime. e.g. 1h 3m 4s
21:32:40 <EvanR> ij: hmm. i think you have to do the math yourself
21:32:48 <ij> ok!
21:32:48 <EvanR> divMod 3600, divMod 60
21:32:58 <EvanR> well, floor first
21:34:29 <lifter> Many open src Haskell libraries use the BSD license... Can anyone help me understand the license requirements? If my own Haskell project (also open src and BSD3) uses, say the well-known "text" lib (BSD3), then I have to make the text lib's BSD3 license file available for viewing to the users of my software, correct?
21:34:47 <dmj`> > putStrLn . formatTime defaultTimeLocale "%T" =<< posixSecondsToUTCTime <$> getPOSIXTime
21:34:48 <lambdabot>  Not in scope: ‘formatTime’Not in scope: ‘defaultTimeLocale’Not in scope: ‘po...
21:34:55 <dmj`> ij: ^
21:35:14 <dmj`> ij: or just getCurrentTime
21:35:25 <kadoban> lifter: Only if you're actually distributing the code of 'text' yourself, which you're pretty likely not doing.
21:35:27 <EvanR> that doesnt pretty print NominalDiffTime
21:35:33 <dmj`> ij: type POSIXTime = NominalDiffTime
21:35:40 <dmj`> EvanR: it doesn't?
21:35:46 <dmj`> does for me
21:35:53 <EvanR> well you got a UTCTime
21:36:03 <EvanR> so no
21:36:14 <lifter> kadoban, ok, I see. Hmm.
21:36:39 <dmj`> EvanR: he wants to pretty print the number of hours since 1970?
21:36:49 <EvanR> ... no
21:37:36 <EvanR> and %T shows the time of day as HH:MM:SS
21:37:53 <dmj`> that's what he requested...
21:38:09 <EvanR> no its totally not
21:38:30 <EvanR> NominalDiffTime is some number of seconds, like a duration
21:38:43 <lifter> kadoban, re-reading the license, that makes sense. Thanks.
21:39:10 <dmj`> EvanR: yes, the number of seconds since 1970
21:39:19 <EvanR> that is what POSIXTime is
21:39:30 <EvanR> which is a (almost) encoding of UTCTime
21:39:33 <EvanR> which is not a duration
21:39:38 <dmj`> I see
21:39:45 <EvanR> you cant add two POSIXTimes together and get anything reasonable
21:40:02 <EvanR> so should really be a newtype, i think
21:40:02 <dmj`> got it
21:40:32 <EvanR> its just not for convenience i guess, to be able to subtract without another set of utility functions for that
21:43:02 <EvanR> also %T wont show a number of hours more than 23 or 24
21:43:56 <Clint> ij: i do pretty = text . concat . unfoldr durU . unpack on a newtype
21:44:24 <dmj`> EvanR: right
21:44:43 <lpaste> Clint pasted “duration fun” at http://lpaste.net/157728
21:44:49 <Clint> ij: where durU is ^
21:44:54 <dmj`> but it depends on if hours is the largest time measurement he wants to track
21:46:06 <EvanR> no combination of date and time display will show a duration properly whether you only care about hours, or want the days (and wtf would "months" even mean)
21:46:56 <dmj`> why not?
21:47:05 <EvanR> "its been july 30th 11:10:09 seconds since..."
21:47:25 <dmj`> I mean like, .004 months, .01 hours, etc
21:47:25 <EvanR> theres a big diff between number of seconds and a date/time
21:47:37 <EvanR> a month isnt a length of time
21:47:44 <dmj`> it isn't?
21:47:47 <EvanR> no!
21:47:56 <dmj`> you can measure time in months
21:48:10 <EvanR> you could but thats not really convertible to seconds in any way
21:48:19 <dmj`> sure it is
21:48:21 <EvanR> (any correct way)
21:48:28 <dmj`> oh, I see
21:48:49 <dmj`> you'd have to say 30 days exactly == 1 month
21:48:51 <EvanR> however the combination of year and month is a proper "point in time" type
21:48:57 <dmj`> or something inaccurate
21:49:01 <EvanR> just not a duration type
21:49:11 <dmj`> right, sure
21:49:26 <Cale> EvanR: ...well, with about a day's worth of error
21:49:41 <EvanR> no, point in time types are abstract spaces 
21:49:52 <EvanR> you can subtract them to get integers and add integers to get new months
21:50:00 <EvanR> no error
21:50:33 <Cale> I mean, if you want to know whether a given point in time lies within a given year and month, you really need a time zone.
21:51:14 <EvanR> when you (are right now) saying point in time, you are implicitly using something like UTCTime
21:51:20 <EvanR> which isnt appropraite
21:51:45 <EvanR> its like the difference between integers and real numbers
21:52:06 <EvanR> and the difference between physical time models and calendars
21:52:41 <EvanR> a month type would be useful in a lot of practical situations
21:53:30 <EvanR> the clients business plans often speak of which month something applies to without regard to how many days are in a month
21:53:56 <dmj`> this is true
21:54:06 <montanonic> I'm having a weird little problem. I'm pretty new to web devel so I may be thinking about this the wrong way, but I'm trying to figure out how to use a rough equivalent to this function in the Yesod test suite: http://haddock.stackage.org/lts-5.10/yesod-test-1.5.0.1/Yesod-Test.html#v:post
21:54:39 <montanonic> I'd like one of my handlers to send a request to a particular url and return the result, but I *don't* want to redirect the user
21:55:57 <montanonic> The `post` function does exactly that, but only within a test. In an actual Yesod Handler, it seems like the only thing I can do is a redirect, instead of sending a request from the server to that url.
22:44:26 <jdt> trying to figure out the right way to do this: https://github.com/justindthomas/blog/blob/master/src/Site.hs#L48
22:45:23 <jdt> ...and having some trouble. I get errors like "Expected type 'Article -> T.Text', actual type 'T.Text'"
22:46:14 <jdt> I'm having a brain spasm trying to figure out how to make it work (i.e., to take markdown data stored in a database and render it to HTML before splicing it in to the page).
22:47:28 <jdt> here's the full text of the compiler error: https://gist.github.com/justindthomas/b1bf659553c5754814baaf722ca970e9
22:48:41 <Moggle> What's the typical way you set up a new project with git/stack?
22:48:48 <Moggle> If you make a new project on github, then clone it
22:48:55 <Moggle> stack init will complain that the folder already has files
22:49:06 <Moggle> I guess the easier way is stack init then overriding the github repo?
22:50:05 <dmj`> stack setup ?
22:52:02 <Moggle> dmj` does stack setup make a basic stack.yaml file for you? i thought it just grabbed ghc etc.
22:52:27 <dmj`> I think stack setup is if you already have a cabal file, but not a stack file, I could be wrong
22:52:46 <Moggle> what should i run if i have no cabal file or anything, just starting a new project?
22:53:22 <liste> Moggle: create a new folder and run `cabal init' in it
22:53:33 <Moggle> ah, that makes more sense
22:53:34 <Moggle> thanks liste
22:53:40 <liste> Moggle: you're welcome (:
22:53:41 <Moggle> stupid of me in retrospect
22:54:45 <liste> `stack new' should work too, but I've never used it
22:55:10 <liste> it makes a more complete skeleton
22:55:21 <liste> `cabal init' just makes the .cabal file
22:57:24 <jle`> i should really look into figuring out how to make a stack new template for my projects
22:58:07 <dmj`> Moggle: 'stack new' if you don't have anything
23:01:19 * hackagebot google-search 0.2.0.0 - EDSL for Google and GMail search expressions  https://hackage.haskell.org/package/google-search-0.2.0.0 (LiyangHu)
23:09:03 <i-amd3> Hi, everybody.
23:09:11 <liste> hi i-amd3 
23:09:39 <i-amd3> hi liste!
23:09:41 <i-amd3> Can anyone answer me to a question?
23:09:55 <i-amd3> I wanna know some projects who using Cloud Haskell.
23:10:31 <dmj`> i-amd3: are you asking because you'd like to contribute, or are you asking if it's useable in industry?
23:12:41 <i-amd3>  i am asking if it's useable in industry.
23:13:08 <liste> i-amd3: you can get some idea from https://twitter.com/intent/user?original_referer=https%3A%2F%2Fhaskell-distributed.github.io%2F&ref_src=twsrc^tfw&region=count&screen_name=CloudHaskell&tw_p=followbutton
23:13:59 <liste> I'd think at least Galois would use it
23:17:26 <i-amd3> Sorry liste, i don't know why but i cannot to access to url...
23:18:10 <liste> it's the Twitter followers of @CloudHaskell
23:18:40 <mauke> ah, url stops at ^
23:18:50 <mauke> is unescaped ^ valid in urls?
23:20:05 <Fylwind> mauke: according to this SO answer, no http://stackoverflow.com/a/30402168
23:20:20 <Fylwind> need to escape it using %
23:21:20 * hackagebot vector-th-unbox 0.2.1.5 - Deriver for Data.Vector.Unboxed using Template Haskell  https://hackage.haskell.org/package/vector-th-unbox-0.2.1.5 (LiyangHu)
23:21:43 <i-amd3> thanks list, mauke and Fylwind. i looked it:D
23:38:41 <zipper> What do we call types like Maybe?
23:39:35 <dmj`> type constructors
23:42:33 <Cale> Or (parametrically) polymorphic types
23:45:04 <Maxdamantus> vands.
23:47:37 <Maxdamantus> What do you pass to type constructors?
23:48:14 <liste> Maxdamantus: types!
23:49:13 <Maxdamantus> Even type constructors of kind (* -> *) -> *?
23:50:24 <liste> well, if type constructors are parametrically polymorphic types, that means that they're types too
23:50:50 <liste> just types of different kind than *
23:51:06 <Maxdamantus> > let f :: IO; f = f in 4
23:51:07 <lambdabot>      Expecting one more argument to ‘IO’
23:51:07 <lambdabot>      Expected a type, but ‘IO’ has kind ‘* -> *’
23:51:07 <lambdabot>      In the type signature for ‘f’: f :: IO
23:51:15 <Maxdamantus> Apparently they're not necessarily types.
23:51:29 <zRecursive> In ghci, what's the difference between ":m + Foo" and ":l Foo" ?  ":l Foo" failed, but ":m + Foo" succeed .
23:52:01 <zRecursive> FYI, Foo is installed by `cabal install`.
23:52:34 <Cale> zRecursive: :l loads something relative to the current path (usually in the current directory)
23:53:06 <Cale> While :m + Foo  is basically  import Foo
23:53:17 <zRecursive> Cale: thanks!
23:53:26 <Cale> Note that :l accepts a filename
23:53:58 <zRecursive> ok
23:54:42 <Cale> Maxdamantus: Yeah, there's a bit of an awkward naming issue regarding whether "types" are just the things which may be inhabited by values, or type level entities of all kinds.
23:55:02 <Maxdamantus> Yeah. I think we need a new term.
23:55:10 <liste> Maxdamantus: good point. so types are nullary type constructors, so in that case you pass type constructors to type constructors
23:55:15 <Maxdamantus> I've suggested "vands", something between values and kinds.
23:55:16 <srhb> I think most people ignore GHCs terminology here.
23:55:20 <Cale> Well, eventually we should do away with the distinction
23:55:23 <srhb> It seems a dated approach.
23:55:53 <Cale> Well, there's another problem with "type constructor"
23:56:02 <Maxdamantus> Well, if you start calling things like `Maybe` and `ListT` "types", you're going to confuse people who want to do away with the distinction.
23:56:09 <Cale> In that Maybe is definitely a type constructor, but is  Either String  a type constructor?
23:56:15 <srhb> Maxdamantus: I think that's worth it.
23:56:17 <Maxdamantus> because in Agda and Idris, those are just plain functions.
23:56:25 <Rotaerk> Either is a type constructor constructor
23:56:34 <srhb> * -> * not being types is completely arbitrary
23:56:45 <Cale> What about the type variable m in return :: (Monad m) => a -> m a -- is it a type constructor? It's not uppercase...
23:56:55 <Maxdamantus> Rotaerk: is `StateT Int` a type constructor?
23:56:56 <srhb> Clearly it's a type constructor variable
23:57:26 <Rotaerk> why wouldn't it be?
23:57:48 <Maxdamantus> srhb: a variable? What's it called?
23:57:50 <Cale> Rotaerk: Think about the difference between "data constructor" and "function"
23:57:53 <srhb> Maxdamantus: What's what called?
23:58:00 <Maxdamantus> srhb: the variable.
23:58:05 <Rotaerk> hmm k
23:58:06 <Cale> We have a similar distinction going on at the type level
23:58:09 <srhb> Maxdamantus: In Cales example it was called 'm'
23:58:20 <Maxdamantus> Oh, sorry, thought you were responding to me.
23:58:22 <Cale> and "type constructor" sort of conflates things a bit
23:58:27 <srhb> Maxdamantus: My bad, wasn't being clear. :)
23:58:44 <Cale> These are all type-level functions
23:59:10 <Maxdamantus> Except `Int` isn't a function.
23:59:14 <srhb> As goes with value constructors, except the nullary ones.
23:59:19 <Maxdamantus> The best term atm is probably just "type-level things"
23:59:26 <Cale> Right, and what about Int? Is it a type constructor? We wouldn't usually call it that.
23:59:33 <srhb> Why on earth not?
