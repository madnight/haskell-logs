00:03:24 <MichaelK> EvanR: hmmm... I think I'm just fighting the associativity of (->), wanting D a -> d ~ D b -> D c -> d, but that's an infinite type. Do any of the current extensions allow anything like infinite types or will I have to stick with inductive instances?
00:04:37 <shachaf> No GHC extensions allow equirecursive types, and it's not clear that you really want them.
00:04:55 <shachaf> But you can use a newtype.
00:05:16 <EvanR> what if D was a type family?
00:07:39 * hackagebot octane 0.4.5 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.5 (fozworth)
00:07:39 * hackagebot BlogLiterately-diagrams 0.2.0.3 - Include images in blog posts with inline diagrams code  https://hackage.haskell.org/package/BlogLiterately-diagrams-0.2.0.3 (BrentYorgey)
00:07:42 <MichaelK> EvanR: How could that work?
00:08:09 <EvanR> nevermind im confused by the meaning of D a -> d ~ D b -> D c -> d
00:11:03 <shachaf> It might be possible to do whatever you're trying to accomplish with D.
00:12:00 <xpika> Is there a function that will fork a thread and make it daemonize like when calling a program with nohup ?
00:12:19 <MichaelK> EvanR: How about a class "D a b where f :: a -> b" and want "instance (Constant a, D b c) => D (a -> b) c"
00:12:27 <ggVGc> man, I'm starting to become comfortable enough in haskell now to use it for random small hacky personal things
00:12:43 <ggVGc> stuff I would have used python or something for in the past
00:12:46 <ggVGc> it's pretty great
00:13:38 <ggVGc> still only scratching the surface of haskell though I feel
00:13:42 <xpika> ggVGc:  yep, Haskell is best ( No bias ^_^ )
00:13:49 <ggVGc> but I'm not sure how much of the advanced features are really necessary for everyday work
00:14:32 <ggVGc> been using it fairly frequently the past 6 months and have yet to write a class instance myself
00:14:57 <EvanR> xpika: i dont understand what you mean demonize... you mean keep it running?
00:15:14 <xpika> EvanR: Yes, run in the background.
00:15:23 <xpika> after the program has exited
00:15:32 <EvanR> ... no threads are part of the process
00:15:39 <EvanR> but you can spawn another process
00:15:54 <xpika> EvanR: Yep that's what I want.
00:15:59 <EvanR> System.Process
00:16:14 <EvanR> ggVGc: good ;)
00:17:09 <MichaelK> ggVGc: I just started a project that needs a bunch (unless I end up using TH). the part I'm using most is doing induction using instances, which can be pretty useful
00:20:23 <xpika> ggVGc: probably the reason you havn't needed to write a class instance yourself is because there are so many already available. I use fmap all the time.
00:20:50 <ggVGc> xpika: right, hence why I said the advanced features of haskell aren't really necessary to get into to do everyday stuff
00:21:12 <ggVGc> I only seriously started using haskell after doing some stuff in Elm a while back
00:21:50 <ggVGc> and it was a good. Elm is very much like a simple haskell, and going into haskell afterwards I think helps keep focus
00:22:05 <ggVGc> because I now much easier differentiate between the different parts of the language
01:15:59 <lpaste> nocturne777 pasted “type checking” at http://lpaste.net/156303
01:16:05 <nocturne777> is anyone familiar with this type check error?
01:17:42 <pavonia> What is App?
01:22:11 <lpaste> nocturne777 revised “type checking”: “type checking” at http://lpaste.net/156303
01:22:56 <nocturne777> pavonia: App is my monad stack, which is also  available in the paste now
01:24:11 <pavonia> It probably can't infer App because there could a possible second instance MonadBaseControl IO m
01:24:21 <pavonia> +be
01:24:57 <nocturne777> pavonia: I see. so my only option is to mention the App in the signature then
01:27:43 <nocturne777> I don't like mentioning the entire App monad in a function's signature like that. It gives the impression that the function could be doing anything. 
01:29:49 <pavonia> Doesn't give the first signature the same implression? If it uses IO, it basically could do anything
01:36:05 <martinvlk> @pl (\e _ -> entityVal e)
01:36:05 <lambdabot> const . entityVal
01:36:52 <lyxia> nocturne777: where does the error happen
01:42:19 <lpaste> nocturne777 revised “type checking”: “type checking” at http://lpaste.net/156303
01:42:46 <nocturne777> lyxia: I updated the paste with the actual code to show where the error happens
01:42:50 <nocturne777> pavonia: you're right
01:45:16 <MichaelK> nocturne777: This reminds me of a similar issue where a lack of dependence on previous IO actions resulted in them being skipped. Maybe add a phantom type so that ghc sees the dependence?
01:46:40 <nocturne777> MichaelK: where would I add the phantom type in this case?
01:46:58 <lyxia> nocturne777: why void
01:47:10 <lyxia> nocturne777: what's the type of wait
01:47:28 <lyxia> wait :: MonadBaseControl IO m => Async (StM m a) -> m a ?
01:47:48 <nocturne777> lyddonb: yeap
01:47:59 <lyxia> what happens if you get rid of void
01:48:36 <nocturne777> lyxia: it makes no difference. I added void there so that I don't write "return ()" as the last statement
01:49:25 <lyxia> get rid of void and don't add return ()
01:49:38 <MichaelK> nocturne777: I'm not sure, maybe fork and mapConcurrently? I never like "_ <- ".
01:49:43 <nocturne777> lyxia: interestingly, mapConcurrently does not cause this problem
01:50:05 <lyxia> I'm not sure why but the error seems to complain about deleteUserSessions not having a specific return type.
01:51:54 <lyxia> oh wait no that's not it
01:52:51 <lyxia> it doesn't do unification
01:53:05 <nocturne777> lyxia: "runCassOp $ CQ.write qus pus" gives "m ()"
01:53:31 <lyxia> nocturne777: so have you tried what I suggested, remove void and don't add return
01:53:38 <lyxia> this way it will infer that a0 is ()
01:54:34 <lyxia> use void when you want to ignore a non-unit return value
01:54:45 <lyxia> but here it is already unit
01:55:32 <lyxia> and putting void actually confuses the compiler because it cannot tell what the return type of "wait deleteUserSessions" is.
01:55:55 <quchen> What's the GHC flag to dump all possible flags again?
01:55:57 <nocturne777> lyxia: you are right, it works
01:56:16 <nocturne777> lyxia: thank you 
01:56:24 <lyxia> yw
02:05:12 <inad922> hi
02:05:19 <sammij> hello
02:06:51 <inad922> I'm trying to figure out why this snippet -> https://gist.github.com/jakab922/982a8d065cd5b6eb5eb2 is running slower than the equivalent python snippet. Insertion should work in O(log n) according to the hackage documentation. Is this slow because we also copy the Map each time we make an insert?
02:07:20 <quchen> No.
02:07:28 <quchen> Inserting doesn't require copying the entire map.
02:07:28 <sammij> I am wondering how to decide on the correct order of combination of the IO and the State monads. Is there some general guidance or does it depend on my specific code?
02:07:47 <inad922> quchen: Is this because random number generation is slow?
02:08:22 <quchen> inad922: Could be. The default System.Random is somewhat poor quality, unfortunately.
02:09:01 <inad922> quchen: Is there an alternative to that? I might even rewrite the snippet with a single infinite list and just insert elements from that to the Map
02:09:40 <EvanR> not as bad as classic C rand but
02:09:51 <EvanR> maybe that just makes it worse because its "good enough"er
02:10:37 <quchen> Criterion uses mwc-random, for example.
02:10:43 <quchen> ?hackage mwc-random
02:10:43 <lambdabot> http://hackage.haskell.org/package/mwc-random
02:11:24 <sammij> inad922: how are you comparing? What optimizations if any are you using to run your haskell code. What is the equivalent python code?
02:12:41 <sammij> inad922: also it might be faster (I don't know) to construct the map in one go, using fromList
02:12:42 * hackagebot dead-code-detection 0.4.0.1 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.4.0.1 (SoenkeHahn)
02:13:07 <EvanR> even faster if keys are sorted
02:13:20 <EvanR> you can use fromListAsc
02:13:24 <sammij> inad922: plus you probably want to use a Strict Map
02:13:30 <inad922> sammij: I compile with ghc -O2 --make -dynamic <file_name>
02:13:54 <inad922> sammij: Strict Map?
02:14:48 <inad922> sammij: This is the equivalent python code -> https://gist.github.com/jakab922/f5081fa675abbc7d0f66
02:15:27 <sammij> inad922: the default Map is lazy in its values. But since you are not using the values perhaps it will only get slower if you really have to generate any random numbers. https://downloads.haskell.org/~ghc/latest/docs/html/libraries/containers-0.5.6.2/Data-Map-Strict.html#g:21
02:16:17 <EvanR> strict map of numbers will put less pressure on memory possibly improving speed
02:17:23 <inad922> sammij: Yep when I use Strict Map with random numbers it gets slower
02:17:49 <EvanR> bummer. lazy ftw
02:27:59 <ij> GHC 7.10.3 is taking 100% cpu and not finishing for 10 minutes. I'm installing encoding-0.8 with stack lts-5.7.
02:28:32 <xintron> For checking the validation of x509 certificates (mainly validating the before/after dates of the certificate chain), should I go for hsOpenSSL or hs-tls? I might want to do cipther testing in the future as well (verify which ciphers a server accepts)
02:31:53 <sammij> inad922: your ``equivalent'' python does not compute the size of the dictionary
02:32:20 <ski> Akii : mhm
02:33:14 <Akii> I also found this https://github.com/BardurArantsson/cqrs
02:33:20 <Akii> but didn't look at it in detail yet
02:33:53 <Akii> this was interesting though https://github.com/BardurArantsson/cqrs/blob/master/cqrs-core/src/Data/CQRS/Types/AggregateAction.hs
02:34:05 <Akii> I think that's "apply" :D
02:35:35 <MichaelK> Akii: I was thinking that looked familiar.. 
02:37:27 <sydneyhacker> I have been learning Haskell on and off (and Elm) for a while but the problem is that it makes me want to do it full time. And therein lies the problem there is now only one company in my city with Haskell jobs. And I've applied to them already! What do I do I wonder? I am thinking how can I convince my current company to try it.
02:39:47 <cobreadmonster> sydneyhacker: That's all of our problems.
02:39:52 <cobreadmonster> Have you applied to Galois?
02:40:52 <ski> Akii : hm, i suppose so (but they just define a type, not a class, from what i see)
02:41:03 <MichaelBurge> sydneyhacker: I think your main choices are A. Convince your company to let you use it B. Become a freelancer C. Start your own software company
02:41:06 <Akii> the type signature is interesting
02:41:08 <sydneyhacker> cobreadmonster: ha ha
02:41:16 <Akii> starting with Nothing -> apply Just Aggregate
02:41:20 <Akii> looks very promising
02:42:10 <sydneyhacker> no Galois are in the US. If I were young and more importantly not married and even more importantly didn't have kids I'd move for Haskell. I'd move to the Arctic circle.
02:42:44 <cobreadmonster> sydneyhacker: Apply to Optiver.
02:43:15 <sydneyhacker> Really Optiver. I could give that a go. Didn't realize they want Haskell people.
02:43:38 <MichaelK> if I don't care what the value is, how can I get a value of some type? Is there a "standard" way or should I just define a type class?
02:43:51 <sammij> inad922: I also just noticed that ghc refuses to recompile my code when it thinks it is not newer than an already compiled executable. That messes up the used optimizations and measurements. Not sure how to force it to do work
02:44:01 <MichaelBurge> MichaelK: There's Data.Default or (undefined :: a)
02:44:03 <ski> MichaelK : not all types have a (total) value
02:44:18 <ski> MichaelK : what are you going to use the value for ?
02:44:28 <inad922> sammij: touch <source_file>
02:45:39 <MichaelK> I have a class of functions like asTypeOf, so there's a typed argument that needs to be filled to get to the rest
02:46:01 <ski> MichaelK : use `Proxy' ?
02:47:07 <sammij> inad922: and there is a -fforce-recomp flag :)
02:49:17 <ski> @hackage tagged
02:49:17 <lambdabot> http://hackage.haskell.org/package/tagged
02:49:24 <ski> MichaelK : and <https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Proxy.html>
02:49:37 <sammij> inad922: in my own comparison, haskell version runs in 1.6s when 1000000 is the input, python version runs in 2.9s with same input.
02:50:07 <MichaelK> ski: I think undefined will work as it will never be evaluated (so the error should never happen). Proxy seemed to throw off the type..
02:50:54 <sammij> inad922: using lazy or strict Maps does not seem to make a difference...
02:51:17 <ski> MichaelK : `Proxy' ensures that it will neven be evaluated, as there's no value to evaluate
02:51:25 <ski> s/neven/never/
02:52:15 <MichaelK> ski: you mean compile-time checked?
02:54:23 <lpaste> sammij pasted “map_insert for inad” at http://lpaste.net/156325
02:54:54 <sammij> I am wondering how to decide on the correct order of combination of the IO and the State monads. Is there some general guidance or does it depend on my specific code?
02:55:47 <ski> MichaelK : if there is no value that could be evaluated, then it can't be evaluated. i suppose, you could call that compile-time checked, if you like
02:56:14 * ski idly wonders how an anaphore-based explanation of that first sentence would look like
02:56:24 <lyxia> sammij: what other combination than StateT s IO can you think of
02:56:35 <MichaelK> ski: fair enough. I'll use that then, as the source for undefined feels a little too hacky
02:57:03 <lyxia> sammij: or is that not what you call a "combination"
02:57:03 <sammij> lyxia: IO (State a) and State (IO a)
02:57:26 <lyxia> ah really composition like that
02:57:38 * ski . o O ( `Not (exists it :: Value. Possible (Evaluated it)) => Not (Possible (Evaluated it))' ??? )
02:58:05 <sammij> lyxia: maybe my thinking of composition is part of the problem and I really need to use StateT IO...
02:58:22 <ski> lyxia : .. backwards state ?
02:58:31 <ski> (using `mfix' for `IO', of course)
02:59:30 <ski> (or i suppose you'd possibly rather think of that as a combination of `IO' and `BackwardsState' ..)
02:59:42 <ggVGc> I have yet to use State
02:59:53 <ggVGc> I often think I'll need it, but then it turns out a fold was enough
03:00:48 <ski> sammij : with `IO (State s a)', what I/O actions to perform may not depend on results computed in the `State s' monad which depends on the initial state
03:00:55 <sammij> lyxia: basically using Weak references introduced the IO monad in my State monad computation and now ghc complains about the types of course, but I am not sure what type to aim for... :(
03:02:12 <ski> sammij : with `State s (IO a)', which I/O actions to perform may depend on the initial state and results computed from that in the `State s' monad. but otoh, what `State s' actions to take later may not depend on results computed by I/O actions
03:02:47 * hackagebot dead-code-detection 0.5 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.5 (SoenkeHahn)
03:02:55 <ski> sammij : so if you want to be able to "interleave" the dependencies of the `IO' and the `State s' monad, you need something else, like `StateT s IO'
03:04:17 * ski . o O ( `(forall it :: Value. Not (Possible (Evaluated it))) => Not (Possible (Evaluated it))' ?? -- still out of scope )
03:05:41 * ski . o O ( `exists it :: Value. (Not (Possible (Evaluated it)) => Not (Possible (Evaluated it)))' ? -- but this is using a classical principle, i think )
03:06:26 <sabrehagen> i'm coming from the javascript channel to ask advice from people who's language demands pure fp of them, so they never have the option to cut corners and make bad habits. hi.
03:06:52 <ski> hello sabrehagen
03:07:15 <ski> (s/who's/whose/, nitpicking)
03:07:15 <sammij> ggVGc: well, State is mostly for convenience...
03:07:32 <sammij> ski: thanks for giving me something to think about
03:07:53 <ski> sammij : consider
03:08:06 <ski> @unmtl IO (State s a)
03:08:06 <lambdabot> IO (s -> (a, s))
03:08:12 <ski> @unmtl State s (IO a)
03:08:12 <lambdabot> s -> (IO a, s)
03:08:15 <ski> @unmtl StateT s IO a
03:08:16 <lambdabot> s -> IO (a, s)
03:08:37 <sabrehagen> i want to name an assertion: the ES6 function of the form (key) => typeof key === 'function'. what would you name this function?
03:08:43 <ski> sammij : with some practice, you can read off the above dependencies and independencies from those types ^
03:09:50 <ski> sabrehagen : not quite sure i understand the question
03:10:28 <ski> sabrehagen : are you talking about a function that, given as input any "key" value (whatever that is), will return as result the "type" of the "key" ?
03:10:41 <sammij> ski: thanks, I understand better now which types exactly I am comparing to one another. It is good to be reminded of unwrapping the State newtype.
03:11:00 <ahihi> it looks like an "isFunction" to me
03:11:28 * ski didn't understand the "=== 'function'" part, ignored
03:11:33 <sabrehagen> it's declarative definition is a type check. it's imperative definition is a function which takes in a value, and that value's string representation is checked for equality with the string 'function'
03:11:41 <ski> ahihi : but i suppose that sounds reasonable ..
03:12:15 <MichaelBurge> sabrehagen: You mean you want to assert that a value is a function? I'd use assertIsFunction x or assertIsOfType x type, where type is a value like (Proxy (a -> b))
03:12:19 * ski twaps around with a s/it's/its/
03:13:17 <ski> sabrehagen : wait, so is the string representation of the *type* of the value checked, or the string representation of the *value* itself checked ?
03:13:46 <ski> (i assume the former, on second look)
03:14:11 <sabrehagen> ski: the type of the value
03:14:16 <sabrehagen> my apologies
03:14:42 <ski> sabrehagen : what does the function do in either case ? terminate with no result, resp. abort computation (exception ?) ?
03:14:58 <ski> if so, i second MichaelBurge's suggestion
03:15:19 <ski> (translated to your context, of coursE)
03:15:23 <ahihi> isn't it just a predicate?
03:15:33 <sabrehagen> ahihi: yes, it's a predicate
03:15:50 <ski> ok, so drop the "assert" part of the name then
03:15:53 <ahihi> then I stand by my suggestion :)
03:16:01 * ski nods to ahihi
03:16:36 * ski isn't quite sure what this has to do with "pure fp", though
03:17:43 <sabrehagen> ahihi: is that name as personal as any other variation in the haskell community, or is that the naming convention defined by haskells 'ethos'/paradigm
03:18:08 <ahihi> we have a number of isFoo predicates
03:18:26 <ahihi> > isUpper 'X'
03:18:29 <lambdabot>  True
03:18:51 <MichaelBurge> sabrehagen: I mean, you've got 3 votes for isFunction and 0 for anything else.
03:19:03 <ski> sabrehagen : i think `isFoo'/`foo?'/`is_foo' is quite a common convention, across many languages
03:19:22 <verement> > isInfinite (1/0)
03:19:24 <lambdabot>  True
03:19:37 <sabrehagen> thanks peeps
03:20:12 <MichaelBurge> @ty isInfinite
03:20:14 <lambdabot> RealFloat a => a -> Bool
03:20:59 <ski> e.g. in Haskell we have `isJust',`isNothing',`isDigit',&c., but `even',`odd',`null' (not `isEven',`isOdd',`isEmpty'). in Scheme, there's `even?',`odd?',`null?'
03:21:06 <ski> sabrehagen ^
03:21:53 <MichaelBurge> ski: I always figured that was just a historical accident of the Prelude that got entrenched.
03:22:13 <MichaelBurge> Speaking of which, are there any plans to replace String with something else(like Text)?
03:22:44 <ski> sabrehagen : e.g., if i wanted a predicate expressing that a list/sequence/whatever is ordered, i'd probably call it just `ordered' in Haskell, rather than `isOrdered', but the latter would be ok as well. apply as appropriate to the langauge community and group you find yourself in
03:23:32 <ski> with `isDigit' it's not obvious that a name `digit' would refer to a predicate. with `ordered', one could argue that it's more obvious
03:24:01 <ski> (though i suppose you might call a local variable `ordered', if it is/has been ordered)
03:24:27 <sabrehagen> ski: yes, i like how tenses are important
03:24:40 <ski> (as in .. `.. where list = ...; ordered = sort list' or something like that)
03:24:43 <sabrehagen> it's another partition that's essential to meaning
03:24:52 <ahihi> ski: more obvious, but not entirely obvious :) e.g. python has sorted(), which is a sort function rather than a predicate
03:25:15 <sabrehagen> ahihi: yes, great example
03:25:15 <ski> ahihi : *nod*, with methods, that's another possibility
03:25:54 <ski> (you could imagine something like `data Foo = MkFoo { ... , ordered :: Foo , ... }' perhaps, simulating methods)
03:26:53 <ski> (it would be less sensible to call a type class method `ordered', if it's to convert something to an ordered variant)
03:27:55 <ski> MichaelBurge : (the former), perhaps
03:41:36 <ggVGc> I have a list of objects, and a function that could throw an exception that I want to map over these objects, and I would like to silently ignore any exceptions thrown. What's my best course of action?
03:42:07 <ski> what's the type of the function ?
03:42:44 <ski> @type mapMaybe  -- one version
03:42:45 <lambdabot> (a -> Maybe b) -> [a] -> [b]
03:43:11 <ggVGc> ski: a -> IO()
03:43:29 <ski> and your desired result is `IO ()' ?
03:43:33 <ggVGc> yes
03:43:37 <sammij> is it possible to get ghc to tell you what it thinks the type of a function is even if it will not accept/compile a module?
03:43:58 <jle`> sammij: there are some nice ways, but what i usually do myself is just say something like foo :: Int
03:44:03 <ski> use `mapM_'/`forM_', and catch the exceptions ?
03:44:08 <jle`> and ghc will tell me that it's not supposed to be an Int but a blah blah blah
03:44:17 <sammij> jle`: ah, smart :)
03:44:28 <jle`> there is probably a better way though, heh
03:44:34 <ski> @type Control.Exception.catch
03:44:36 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
03:44:36 <MichaelBurge> ggVGc: Look in the Control.Exception library. There's functions like mask that will probably work for you.
03:44:36 <gfixler> lie-driven development
03:44:38 <ski> @type Control.Exception.catchJust
03:44:39 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
03:44:56 <ggVGc> thanks
03:45:33 <ski> ggVGc : usually you're better off restricting "any exceptions" to "exceptions belong to some specific category"
03:46:09 <martinvlk> Is there a way to pattern match on values nested in data constructors, without importing the actual constructors into my module? E.g. data A = B Int | C Bool and I need say f :: A -> String which will return "num" for B and "bool" for C, but B and C are not available for importing.
03:46:28 <martinvlk> or maybe nt even pattern match, just enerally a way to get at the values
03:46:38 <jle`> well, the type might offer an API for doing things like this
03:46:43 <jle`> like, Maybe offers isJust, isNothing
03:47:00 <ski> martinvlk : if the module exports operations for inspecting those value
03:47:28 <jle`> List offers `uncons`, which you can use to simulate pattern matching on (:)/[]
03:47:29 <ski> martinvlk : is the module fixed, or are you writing it ?
03:47:42 <martinvlk> jle', ski: so in general the answer is no, there must be something provided by the API author.
03:47:50 <ski> martinvlk : correct
03:47:58 <martinvlk> I can change the module, just wondering if there is a way in general
03:47:58 <sammij> jle`: unfortunately the other problems that ghc detects are so severe that it does not fall for the trick
03:47:59 <hpc> if you have absolutely no scruples, unsafeCoerce it to a type you can inspect
03:48:09 <hpc> (but don't do that0
03:48:18 <jle`> martinvlk: you can do it if the type is an instance of Data or Generic
03:48:27 <jle`> but that probably counts as a "provided API"
03:48:34 <martinvlk> jle': ah, right, thanks
03:48:42 <ski> martinvlk : what's the situation that creates a problem(?) here ?
03:49:24 <martinvlk> ski: just me hesitating to change the interface of modules in the company where I work. I can do it, but exploring ways to keep them if possible.
03:49:27 <jle`> martinvlk: but, you can't hide typeclass instances when you import things
03:49:30 <ski> sammij : you can try commenting out portions of the module
03:49:34 <MichaelBurge> I notice that assert has the ability to report source file and line where it's used. I know how to get something similar with Template Haskell, but it'd be nice to avoid TH if possible for my own error-reporting functions.
03:49:45 <jle`> martinvlk: so if you hid the constructors, you'd still be able to access the instances
03:49:49 <jle`> (if they exist)
03:49:54 <MichaelBurge> Is there a way to define 'here :: String' that gives equivalent information?
03:50:03 <ski> martinvlk : what's the use of this `f :: A -> String' ?
03:50:14 <martinvlk> jle': understood
03:50:30 <jle`> MichaelBurge: i believe so, with some of the new implictparams-based things in 7.10+
03:50:32 <martinvlk> ski: none, just a dummy example I thought up
03:51:09 <martinvlk> ski: in reality I have some configurations, different types, and I need to build GUI for each type differently
03:51:19 <ski> martinvlk : ok. what's the use for being able to, externally, distinguish between the constructors ?
03:52:03 <jle`> MichaelBurge: https://hackage.haskell.org/package/located-base
03:52:25 <jle`> that library exports versions of base's favorite partial functions, but the error messages come with line numbers etc. about where they are
03:52:28 <martinvlk> ski: I think the types are currently not so well suited for what I need to do so I will ahve to change the API slightly
03:52:33 <jle`> so looking into how they do it might help
03:52:54 <MichaelBurge> jle`: Righteous - The hint about implicit params helps too, since it treats callstack information specially. Thanks for the pointers.
03:52:58 <jle`> https://hackage.haskell.org/package/located-base-0.1.0.0/docs/src/GHC-Err-Located.html#undefined
03:53:02 * hackagebot hlint 1.9.32 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.32 (NeilMitchell)
03:53:03 <jle`> np
03:53:04 * hackagebot js-jquery 1.12.2 - Obtain minified jQuery code  https://hackage.haskell.org/package/js-jquery-1.12.2 (NeilMitchell)
03:53:11 <jle`> i believe there might be a performance overhead
03:53:21 <jle`> well, i heard someone say it once but i haven't verified
03:53:51 <MichaelBurge> jle`: I imagine there is, since you can't easily inline the calls or you'd have to generate separate values for each call
03:54:01 <jle`> mhm
03:54:04 <MichaelBurge> jle`: But I imagine it'd be limited to the places that throw errors
03:54:46 <jle`> perhaps.  TH-based approaches seem to be a bit nicer, as it's all basically out of the picture after compiletime
03:55:54 <ski> martinvlk : one alternative might be to make a "more private" version of the module, which defines the datatype (and perhaps more/most stuff), exporting the data constructors, and a "more public" version of the module, which reexports the previous (and perhaps adds something more), but doesn't reexport the data constructors
03:56:15 <jle`> MichaelBurge: TH might seem like the more natural approach; it's the path chosen by snoyman for monad-logger
03:56:22 <jle`>   https://hackage.haskell.org/package/monad-logger-0.3.18/docs/Control-Monad-Logger.html
03:56:38 <MichaelBurge> jle`: I've had bad experiences with TH making things harder to deploy. Like, sometimes TH-dependent modules running in GHCi on Windows will give trouble.
03:56:53 <jle`> ah, how unfortunate
03:57:21 <MichaelBurge> jle`: It does seem more natural in the sense that 'here' should be equivalent to a string literal.
03:57:23 <ski> martinvlk : so, only modules which depends on knowing the internal representation would import the private version, and only they would need to be changed, if you change the internal representation. that's the idea
03:57:34 <martinvlk> ski: yes, that sounds like an option - thanks!
03:57:54 <jle`> MichaelBurge: yeah, just compile $(undefined) as `error "undefined at line xxx"` during the compilation process, and after that, it's free
03:58:02 * hackagebot vector-sized 0.3.0.0 - Size tagged vectors  https://hackage.haskell.org/package/vector-sized-0.3.0.0 (jophish)
03:58:03 <ski> martinvlk : hard to give better advice, without knowing more about the situation ..
04:00:07 * ski ponders how to (classically) prove `((forall x. P x) -> O) -> (exists x. (P x -> O))'
04:01:39 <MichaelBurge> ski: I'm not sure you can. Wouldn't the empty model satisfy the condition?
04:02:39 <martinvlk> ski: this is a perfectly relevant advice, there isn't uch more to it.. and I was basically curious about the possibilities
04:02:48 <MichaelK> If I have a typeclass T a b c, can I define: U a b = T a b b somehow? 
04:02:55 <martinvlk> ski: now I know :-)
04:03:19 <jle`> martinvlk: type U a b = T a b b ?
04:03:23 <jle`> * MichaelK 
04:03:39 <jle`> it should work with ConstraintKinds i think
04:03:44 <ski> MichaelBurge, hm. only if `O' is true, no ?
04:03:48 <jle`> which is possibly a bit of a misnomer
04:04:17 <ski> MichaelBurge : but i suppose that's enough. so we need an inhabited model
04:04:18 <MichaelBurge> ski: Yes, if O is some absolutely true statement the condition will be true. But there won't exist an x that makes even a universally true thing hold.
04:04:56 <ski> MichaelBurge : so i suppose i'm trying to find out conditions which would make this step valid
04:05:14 <roelof> If I want to test out the lastest version of servant. How can I do that with stack ?
04:06:20 <ski> martinvlk : i think it's possibly better to not "tempt" "ordinary" users of your module to depend on the internal representation, if you see a potential for it to change (as opposed to just being extended) in the future
04:06:22 <MichaelK> jle`: It works! now I'm up to 8 extensions for ~100 lines of code..
04:07:06 <ski> MichaelBurge : so if you like. replace the statement by `forall y. (((forall x. P x) -> O) -> (exists x. (P x -> O)))'
04:07:24 <ski> (or, equivalently, `(exists y. ((forall x. P x) -> O)) -> (exists x. (P x -> O))')
04:07:36 <martinvlk> ski: yes, the list of configurations might change and users may end up with partial functions...
04:08:31 <ski> @djinn ((forall a. p a) -> o) -> Not (forall a. (p a -> o) -> Void)
04:08:31 <lambdabot> Error: kind error: (KStar,KVar 2)
04:08:56 <ski> hmpf, i expected an error complaining about higher-rank
04:09:25 <EvanR> so i have an embarrassment of riches here for ways to compute the nth fibbonacci number
04:09:41 <MichaelBurge> ski: Classically, I'd probably introduce an explicit universe that I'm quantifying over in the 'forall x.'. Then I'd partition it into the P and ~P elements and do a case breakdown.
04:09:44 <EvanR> but whats an efficient way to compute the nth fib and its successor?
04:10:08 <MichaelBurge> ski: But it depends on what logic you're using, and if it's a formal or informal proof.
04:10:17 <puregreen> EvanR: successor = n+1-th number?
04:10:37 <EvanR> the fib after the one i asked for
04:10:40 <EvanR> (or before)
04:10:45 <EvanR> i want 2
04:11:13 <puregreen> compute ((1 1)(1 0)) to the power of n
04:11:28 <puregreen> and you'll get not 1, not 2, but 3 numbers
04:11:53 <puregreen> https://www.nayuki.io/page/fast-fibonacci-algorithms
04:12:00 <EvanR> im already doing it like that and i noticed the coefs were fib numbers so thought i could speed it up somehow
04:12:23 <puregreen> wait
04:12:37 <puregreen> the matrix already gives you 3 consecutive numbrs
04:12:38 <puregreen> *
04:12:46 <puregreen> what's the problem then?
04:12:53 <EvanR> i thought this was too slow
04:13:00 <EvanR> or slower than it needed to be
04:13:45 <EvanR> is n matrix mult faster than n additions?
04:14:17 <puregreen> if you're doing it by squaring, you'll only have O(log n) multiplications
04:14:42 <EvanR> ah right
04:15:10 <EvanR> brilliant
04:18:32 <EvanR> > (-1)^(-1)
04:18:34 <lambdabot>  *Exception: Negative exponent
04:18:35 <ski> MichaelBurge : hm, i suppose i had something like Gentzen's LK system in mind. extended with proof terms a la continuations, in some form
04:19:40 <ski> (atm i'm attempting to constructively prove `forall y. ((forall x. P x) -> O) -> Not (forall x. Not (P x -> O))')
04:19:58 <ski> > (-1) ^^ (-1)
04:20:00 <lambdabot>  -1.0
04:20:29 <EvanR> so many powers
04:21:05 <verement> > let fibs = (0,1) : (1,1) : zipWith (\(x,y) (z,w) -> (w, y + w)) fibs (tail fibs) in fibs !! 10
04:21:06 <lambdabot>  (55,89)
04:21:15 <sammij> state creates (State s a) values, but what function/constructor creates (StateT s IO a) values?
04:22:13 <ski> sammij : `StateT'
04:22:25 <ski> @type Control.Monad.State.StateT
04:22:27 <lambdabot> (s -> m (a, s)) -> StateT s m a
04:22:49 <ski> sammij : however in many cases it's enough to use `put',`get',`modify'
04:23:29 <MichaelK> is there a good way to write something like: instance T a => not T b?
04:23:31 <ski> @type StateT reads
04:23:33 <lambdabot> Read a => StateT String [] a
04:23:33 <sammij> ah, and I also need to use runStateT... tricksy
04:24:05 <ski> you normally use `runStateT' once, when you want to pass the initial state, and extract the final result
04:24:13 <ski> MichaelK : i don't think there is
04:24:24 <ski> (maybe there's a tricksy, olegian way)
04:24:34 <MichaelK> ski: what about iff?
04:25:18 <ski> i suppose you could say `class C a => D a' and also `class D a => C a'
04:25:28 <ski> but perhaps you wanted something more finegrained ?
04:25:50 <ski> also, perhaps you want to define one of them as a type (class) family instead ?
04:26:22 * ski . o O ( `/\(y : A). \(prem : (forall x : A. P x) -> O). \(k : forall x : A. Not (P x -> O)). k [y] (\(hyp_y : P y). prem (/\(x : A). abort (k [x] (\(hyp_x : P x). ..hmm..))))' ? )
04:27:09 <MichaelK> hmmmm.... something like: Constant a, Relation a b <=> (a ~ b)
04:27:37 <ski> is that meant to be `(Constant a,Relation a b) <=> (a ~ b)' ?
04:28:07 <MichaelK> ski: yes
04:32:22 <ski> MichaelK : i'm wondering where one'd attach this information
04:32:35 <verement> > let fibs n = (fib n, fib $ n + 1) where fib n = let n' = fromIntegral n in round $ ((1 + sqrt 5)^n' - (-1 + sqrt 5)^n' * cos (n' * pi)) / (2^n' * sqrt 5) in fibs 10
04:32:37 <lambdabot>      Could not deduce (Num r0) arising from a use of ‘fromIntegral’
04:32:37 <lambdabot>      from the context (Integral t, Integral t1)
04:32:37 <lambdabot>        bound by the inferred type of
04:36:24 <ski> MichaelK : hm. now i'm wondering if you meant `(Constant a,Relation a b) <=> (a ~ b)', or possibly `Constant a => (Relation a b <=> a ~ b)'
04:38:38 <MichaelK> ski: I can't tell the difference.. I'm trying to make an `EQ a b' class with coercions `a -> b` and `b -> a`, we'll see if it works 
04:39:17 <ski> MichaelK : with the former, you're claiming (among other things) that `Constant a' holds for every `a'
04:40:29 <ski> that latter claims that if `a' is constant, then the only thing it is related to is itself (and also that it *is* related to itself)
04:40:42 <ski> (related in one direction, i.e.)
04:41:15 <verement> > let fibs n = (fib n, fib $ n + 1) where fib n = let n' = fromInteger n in round $ ((1 + sqrt 5)**n' - (-1 + sqrt 5)**n' * cos (n' * pi)) / (2**n' * sqrt 5) in fibs 10
04:41:17 <lambdabot>  (55,89)
04:41:32 <MichaelK> ski: then the latter, sorry for the ambiguity 
04:41:48 <ski> constant things are right-related to themselves, and only themselves
04:43:17 <ski> (btw, sometimes the statement of a math theorem or definition makes this mistake .. confusing presuppositions with extra conditions)
05:03:04 * hackagebot purescript-bridge 0.3.0.0 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.3.0.0 (eskimo)
05:26:52 <savi0r> hi all , I am a fresh haskell coder
05:27:12 <splodingsocks> codedmart I see you and Noah are the main contributors on the Haskell Rethinkdb driver. Do you know of example code anywhere I can reference?
05:28:06 <codedmart> splodingsocks: Noah? You mean Etienne :)
05:28:38 <splodingsocks> Oh, yes! Sorry, I got mixed up.
05:28:43 <codedmart> :)
05:30:09 <codedmart> splodingsocks: There are simple examples littered through the code in comments. Or Sean Hess's serials repo has stuff in it: https://github.com/seanhess/serials/blob/master/server/Serials/Model/Lib/Crud.hs
05:30:17 <codedmart> splodingsocks: Or feel free to ask me anything.
05:30:41 <splodingsocks> great! Thanks. Just trying to get started at all atm
05:31:24 <splodingsocks> I was making stuff up, but looking at the benchmark code, I think I was wrong :)
05:31:36 <codedmart> splodingsocks: Here is tests that illustrate simple use of it in ghci: https://github.com/AtnNn/haskell-rethinkdb/blob/master/Database/RethinkDB/Functions.hs#L34-L70
05:33:06 <codedmart> splodingsocks: Etienne(AtnNn) works for rethinkdb so he is pretty knowledgeable about it :)
05:33:23 <splodingsocks> \o/
05:33:39 <codedmart> Just ping me if I can help in anyway.
05:34:40 <splodingsocks> I'll send you a pm, codedmart
05:34:47 <codedmart> :)
05:52:45 <nomeata> Another standard charters job advert. Are they having trouble finding people and keep posting the same positions, or are they growing that fast?
05:53:06 * hackagebot purescript-bridge 0.3.0.2 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.3.0.2 (eskimo)
05:53:40 <xa0> purescript is a really nice language, at a glance
05:53:46 <xa0> i just wish it didn't compile to javascript
06:02:42 <mkoenig> is there a slick way to convert a list of integers to a list of strings
06:03:39 <pavonia> :t map show
06:03:40 <lambdabot> Show a => [a] -> [String]
06:05:43 <mkoenig> thanks. sorry, i'm new to haskell
06:07:05 <verement> > let { fibs 0 = (0, 1); fibs n | even n = (a, b) | otherwise = (b, a + b) where (x, y) = fibs (n `div` 2); a = x * (2 * y - x); b = y * y + x * x } in fibs 10
06:07:08 <lambdabot>  (55,89)
06:10:36 <verement> EvanR: I like that one best
06:12:36 * ski looks at savi0r
06:19:12 <puregreen> verement++
06:20:35 <osfabibisi> xa0: that's a slightly odd complaint, no? ;-)
06:21:18 <xa0> never :p
06:28:13 * hackagebot purescript-bridge 0.3.0.3 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.3.0.3 (eskimo)
06:35:39 <merijn> Anyone aware of a library for task trees/supervisors stuff like Erlang has, but for forkIO?
06:35:42 <merijn> i.e. async, but for long-lived threads, instead of one shot IO tasks
06:39:42 <Gurkenglas> By what algebra can one formally decide whether a type has exactly one inhabitant?
06:41:00 <ski> if you're thinking of stuff like `forall a. a -> a', you may want to look into parametricity. not sure whether that qualifies as algebra, though
06:48:59 <aweinstock> > let phi = (1 + sqrt 5) / 2 in map (floor . (\n -> (phi**n - (-phi)**(-n))/sqrt 5)) [0..]
06:49:01 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:49:52 <aweinstock> verement: ^
06:51:45 <ggVGc> I have a list of things, and one of them can be "active" at any given time, but also none can be active. how should I model this?
06:51:56 <ggVGc> I am thinking a zipper with a flag
06:52:08 <ggVGc> but that doesn't seem great
06:52:33 <scshunt> it depends on the exactly model
06:52:41 <Gurkenglas> Does the state of activity move primarily between adjacent things?
06:53:09 <scshunt> if order is important, I'd store active :: Maybe Thingy; inactive :: [Thingy]
06:53:34 <Gurkenglas> scshunt, where in the list does active belong?
06:53:39 <scshunt> Gurkenglas: it doesn't
06:53:41 <scshunt> err
06:53:42 <ggVGc> Gurkenglas: no, it's random access.. which also makes a zipper not great
06:53:45 <scshunt> I meant to say *isn't* important
06:53:58 <ggVGc> scshunt: yeah, that seems good
06:54:05 <ggVGc> and similar to a zipper
06:54:15 <ggVGc> thanks
06:54:32 <Gurkenglas> By random access do you mean arbitrary or randomized?
06:54:44 <ggVGc> Gurkenglas: I mean, that any one can become active at anu time
06:55:01 <Gurkenglas> How do you decide which one is active at the next time?
06:55:13 <ggVGc> it's for a game server, and this is the list of clients. It's for a turn based game and one of the clients can at any time "take" the turn for a period of time
06:55:37 <ggVGc> Gurkenglas: so, most of the time no client is the active one, but at any moment some client can say "I want the turn"
06:55:51 <ggVGc> I think I'm gonna do what scshunt suggested
06:55:53 <ggVGc> seems solid
06:55:58 <Gurkenglas> I'd replace inactive by a constant list of all players
06:56:15 <scshunt> yeah, in this case, I'd probably use a constant list and an identifier into the list
06:56:21 <scshunt> or a map into it
06:56:26 <scshunt> I'm doing a game engine right now where a lot of data is being stored in maps
06:56:33 <aweinstock> map/vector if it's random-access, I'd think
06:56:36 <ggVGc> I have this atm, which doesn't seem great, https://gist.github.com/9a838a334b11d6d93f6e
06:56:52 * ski . o O ( "constant set and an identifier into the set" )
06:58:45 <verement> > let phi = (1 + sqrt 5) / 2 in map (floor . (\n -> (phi**n - (-phi)**(-n))/sqrt 5)) [0..] !! 72 -- aweinstock: don't think this is right
06:58:47 <lambdabot>  498454011879265
07:00:03 <aweinstock> verement: I took it from https://en.wikipedia.org/wiki/Fibonacci_sequence#Closed-form_expression
07:00:06 <Gurkenglas> Are you using activeTurnClient only to handle user events? If so, you could replace activeTurnClient by something like (Input -> State Game ()) (not sure whether this is actually a good idea)
07:00:18 <aweinstock> maybe it's a floating point precision issue?
07:00:29 <verement> aweinstock: floating point gets you into trouble
07:00:58 <ggVGc> Gurkenglas: nah, I also need the information on who is active to tell the other clients
07:01:06 <Gurkenglas> Is there a data type that would do these computations with whatever precision is required to get the right answer?
07:01:35 <Gurkenglas> (Like, if its just supposed to print pi, infinite precision. If it's floor (1000*pi), three digits.)
07:01:36 <ski> > ((!! 72) . fix) (\fibs0 @ ~(_:fibs1) -> 0 : 1 : zipWith (+) fibs0 fibs1)
07:01:38 <lambdabot>  498454011879264
07:03:10 <ski> > showCReal 100 pi
07:03:11 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
07:04:20 <Aruro> > showCReal 100 e
07:04:21 <lambdabot>      Couldn't match expected type ‘CReal’ with actual type ‘Expr’
07:04:22 <lambdabot>      In the second argument of ‘showCReal’, namely ‘e’
07:04:22 <lambdabot>      In the expression: showCReal 100 e
07:07:50 <geekosaur> Aruro, for whatever reason pi is in the Prelude (as part of the Floating class, even) but e isn't
07:08:06 <Aruro> > showCReal 100 (exp 1)
07:08:08 <lambdabot>  "2.7182818284590452353602874713526624977572470936999595749669676277240766303...
07:08:34 <Aruro> geekosaur: probably they were afraid of single letter constant :)
07:08:35 <Hafydd> One probably has less cause to use e alone than one does to use pi alone.
07:09:20 <Gurkenglas> Aruro, the point is that you don't specify precision, it's supposed to be always lazily infinite, but only computed to the required precision
07:09:35 <Hafydd> > showCReal 100 (2 * asin 1)
07:09:37 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
07:11:22 <Aruro> im suprised CReal is part of lbot
07:12:02 <Gurkenglas> Oh wait, ski introduced those, not Aruro
07:13:15 * hackagebot purescript-bridge 0.3.0.4 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.3.0.4 (eskimo)
07:13:18 <ggVGc> scshunt: by maps you mean hashtables eh?
07:13:22 <shapr> Is there some way to use an nvidia graphics card to speed up my GHC compiles? :-)
07:13:37 <Itkovian> o hai shapr 
07:13:45 <shapr> hoi Itkovian! hoe gaat het?
07:13:52 <Itkovian> cava eh
07:14:20 <shapr> Itkovian: I've been writing Haskell again the past few weeks, ended up buying a massive laptop (Xeon & 64GB of RAM) because I was frustrated at GHC compile times.
07:14:36 <Itkovian> :-p
07:14:42 <sm> woah. Too much RAM :)
07:14:44 <shapr> Itkovian: how's code with you?
07:14:49 <Itkovian> python, mostly
07:14:51 <shapr> sm: yeah, 640k is enough for anybody :-P
07:15:12 <sm> shapr: has it solved the problem ?
07:15:13 <shapr> sm: I am seriously going to time all my compiles and compare them with the wimpy i3 in my ThinkPad X230
07:15:22 <shapr> sm: it doesn't arrive until April 1st :-(
07:15:30 <sm> ack
07:15:33 <frontendloader> I'd take 64GB of ram, then I could run a VM for each project :/
07:15:35 <shapr> sm: but I do want tips on telling GHC to use more resources for compilations
07:15:50 <Itkovian> the question is: does it need more RAM
07:16:03 <shapr> The laptop also comes with a middlin' decent nvidia card, so I figured I should figure out how to use OpenCL or something to speed up GHC compiles ;-)
07:16:22 <Aruro> ghc has some ram problems on Raspbery Pi
07:16:31 <Aruro> first versions
07:16:36 <Aruro> 1g seems fine
07:16:50 <ralu> building or running?
07:16:58 <Aruro> building
07:17:07 <ralu> building ghc?
07:17:27 <shapr> I got frustrated at long "stack build" times
07:17:31 <shapr> so running ghc
07:17:32 <Aruro> ah, sorry, running; compiling yesod f e
07:18:55 <shapr> Itkovian: I don't know, but soon I'll figure out all the build options that let me offer GHC *lots* of RAM!
07:19:33 <Aruro> shapr: what are you compiling?
07:19:42 <Itkovian> if the computation is not stuck on too much GC, it will not matter one bit
07:20:15 <shapr> Aruro: for now, lambdabot-slack and the github libraries
07:22:24 <shapr> Aruro: still, on a ThinkPad W550s with 32gb of ram, lambdabot-slack took 15 minutes to build, with all cores at 100%
07:24:22 <shapr> Aruro: how long does it take you to compile yesod?
07:24:28 <ski> Gurkenglas : i think `CReal' computes with the required precision internally. that `100' only tells it how much you want for the displayed answer
07:30:29 <saurabhnanda> hey good people, any Aeson champs here? In a JSON received over the network, I want to check the data-type associated with a key. If it's a String something needs to happen, if it's a Number, something else needs to happen. I've hacked together a solution, but it depends on the internal structure of the 'Object' returned by Aeson.decode (it's a HashMap, and I can use HM.lookup on it), but that is probably wrong.
07:31:20 <puregreen> saurabhnanda: (processNumber <$> o .: "key") <|> (processText <$> o .: "key")
07:31:23 <saurabhnanda> Does Aeson expose an API to do this easily? else I'll have to run TWO parseMaybe's. Instead of want to do something like "case (Aeson.lookup key obj) of" and pattern match on the result
07:31:40 <puregreen> okay, you can do that too
07:31:54 <puregreen> field <- o .: "key"; case field of ...
07:31:57 <saurabhnanda> :t (<|>)
07:31:59 <lambdabot> Alternative f => f a -> f a -> f a
07:32:17 <saurabhnanda> what, good lord, is an Alternative?
07:32:31 <saurabhnanda> :t Data.Aeson.(.:)
07:32:32 <lambdabot> Not in scope: data constructor ‘Data.Aeson’
07:32:50 <saurabhnanda> puregreen: (.:) :: FromJSON a => Object -> Data.Text.Internal.Text -> Parser a
07:33:15 <saurabhnanda> that returns a Parser which needs to be run inside the **extremely unwieldy** parseMaybe 'interpreter'
07:33:31 <saurabhnanda> :t processNumber
07:33:32 <lambdabot> Not in scope: ‘processNumber’
07:33:44 <saurabhnanda> :t (<$>)
07:33:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:33:49 <puregreen> processNumber is supposed to be the function you are using to process the numbr
07:33:50 <puregreen> *
07:33:52 <ski> saurabhnanda : `Alternative' is a subclass of `Applicative', with `empty' and `(<|>)' as methods. should form a monoid. and probably interact with the `Applicative' operations in some distributive way
07:33:55 <puregreen> can you show the code you have?
07:34:14 <ski> @type (Data.Aeson..:)
07:34:15 <lambdabot> aeson-0.9.0.1:Data.Aeson.Types.Class.FromJSON a => aeson-0.9.0.1:Data.Aeson.Types.Internal.Object -> Data.Text.Internal.Text -> aeson-0.9.0.1:Data.Aeson.Types.Internal.Parser a
07:34:55 <puregreen> “a <|> b” in the context of Aeson means “if something failed during parsing ‘a’, then parse ‘b’”
07:35:07 <ski> saurabhnanda : in the case of parsers, `(<|>)' would typically express alternative ways of parsing. like if the left one fails, try the right one
07:35:47 <ski> (depending, the right one could be tried even if the left one doesn't fail)
07:36:38 <saurabhnanda> can I apply my function inside a Parser monad? Becase (.:) returns a Parser monad to me
07:37:25 <saurabhnanda> puregreen: will non-working code do? I have three iterations of my incomplete code right now
07:37:30 <puregreen> yep, sure
07:38:16 * hackagebot octane 0.4.6 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.6 (fozworth)
07:38:20 <saurabhnanda> don't judge me on this: http://lpaste.net/156419
07:38:39 <saurabhnanda> there were two things I was trying to do
07:38:43 <ski> saurabhnanda : you can use `myFunction <$> aParser' to apply `myFunction' to the parsing result that `aParser' produces
07:38:44 <saurabhnanda> one is figure out Aeson parsing
07:39:42 <saurabhnanda> the other is to figure out how to not write too many case statement. One of the USPs of Monad & Maybes, etc. is that they can compose. But I'm not being able to compose my lower-level functions. I'm not being able to handle Nothings returned at various levels.
07:39:58 <saurabhnanda> one of the reasons being that each Nothing needs to have a side-effect of a logging statement.
07:40:01 <ski> saurabhnanda : note that this whole `myFunction <$> aParser' will return a new parser that will only apply your `myFunction' when this parser is "executed", iow when (ultimately) a "run parser" operation like `parserMaybe' is called on this parser (or one built from pieces including it)
07:40:31 <ski> "USP" ?
07:40:40 <saurabhnanda> Unique Selling Proposition :)
07:41:17 <puregreen> it looks to me that you're handling JSON manually (in which case you don't even need parseMaybe or anything like that)
07:43:23 <puregreen> perhaps you should just make a data type encoding the information you want to receive
07:43:57 <puregreen> tho I guess there's no reason to do that if you're only receiving response_id
07:45:16 <saurabhnanda> puregreen: take a look at http://lpaste.net/156419#a156420 -- I've written down my logic there. What's the most elegant way to write such stuff using various monads, combinators, and type-fu?
07:46:22 <saurabhnanda> right now every approach is turning out into a bunch of if-then-else or case-matches. Which feels like writing imperative code.
07:48:16 * hackagebot purescript-bridge 0.3.0.5 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.3.0.5 (eskimo)
07:48:20 <ertesx> saurabhnanda: you could use MaybeT there, but personally i'd probably just use 'maybe'
07:48:26 <ertesx> :t maybe
07:48:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:48:46 <johnw> if-then-else is not necessarily an imperative idea; imperative generally means, "do this, then do this, then do this".  Pure if-then-else is logic.
07:49:17 <ertesx> let (c :: IO (Maybe A)), then (c >>= maybe nothingCase justCase) is a common idiom, at least for me
07:49:37 <saurabhnanda> the logic outlined at http://lpaste.net/156419#a156420 -- should I be using (>>=) to chain a bunch of lower level functions or should I just use case-matching and write some nested code.
07:50:17 <ertesx> MaybeT starts to get interesting, as soon as you have many of those, particularly if they are nested
07:50:33 <saurabhnanda> :i MaybeT
07:51:02 <saurabhnanda> are MaybeT and EitherT related?
07:51:11 <ertesx> one particularly common idiom for me is:  c >>= maybe (throwIO (userError "error message")) pure
07:51:25 <ertesx> that effectively turns an IO (Maybe A) into an IO A that throws an exception
07:51:39 <ertesx> MaybeT is to Maybe what EitherT is to Either
07:51:40 <saurabhnanda> where do I find MaybeT: https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-Maybe.html
07:51:50 <ertesx> that's the one
07:52:02 <saurabhnanda> ertesx: doesn't work
07:52:21 <ertesx> you could be a bit more specific =)
07:53:08 <saurabhnanda> ertesx: is this the right one? http://hackage.haskell.org/package/MaybeT-0.1.2/docs/Control-Monad-Maybe.html
07:53:53 <ertesx> no, use the one from 'transformers': https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Maybe.html
07:54:06 <ertesx> but reconsider first if you really need it
07:54:18 <saurabhnanda> ertesx: is there a way to get MaybeT to return info about which function in the function chain return a Nothing? That will help collect ALL log statements at the very end. Or is that something that EitherT can do?
07:54:59 <ertesx> Nothing communicates no information…  EitherT can do it
07:55:21 <saurabhnanda> is https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Except.html the Haskell version of plain-ol' try-catch-finally blocks in other languages?
07:55:38 <ertesx> no, that's Control.Exception
07:56:19 <ertesx> throwIO, catchJust and finally correspond to try/catch/finally in most other languages
07:56:23 <ertesx> and throw
07:56:29 <saurabhnanda> Stability	experimental
07:56:52 <saurabhnanda> A sequence of actions terminates normally, producing a value, only if none of the actions in the sequence throws an exception. If one throws an exception, the rest of the sequence is skipped and the composite action exits with that exception.
07:56:59 <saurabhnanda> ^^^ doesn't that mean the same thing?
07:57:30 <ertesx> the same as …?
07:59:05 <Shockk> saurabhnanda: in the context of Except, the exception is communicated simply through a Left value, so it's like wrapping stuff inside Either, that's probably a bad description but does that make sense?
07:59:36 <saurabhnanda> ertesx: the same as try-catch-finally
08:00:18 <saurabhnanda> Shockk: does that mean the return value of a runExcept needs to be pattern matched with a Left/Right, which is not the case with Control.Exception?
08:00:46 <Shockk> the return value is an Either value yes
08:00:55 <Shockk> :t runExcept
08:00:57 <lambdabot> Except e a -> Either e a
08:01:22 <ertesx> saurabhnanda: that prose only describes 'throw' semantics
08:01:34 <ertesx> it doesn't include catch/finally
08:02:22 <ertesx> saurabhnanda: exception semantics is well modelled by Either as a monad
08:02:36 <ertesx> Left is throw, 'either' is catch
08:02:45 <ertesx> and you can easily model 'finally' in terms of those
08:05:17 <roelof> someone who knows a answer to this problem : https://github.com/haskell-servant/servant/issues/424
08:07:48 <Aruro> any good libraries to work with continued fractions?
08:09:37 <xa0> how would you articulate the relationship between [] and Maybe
08:10:12 <ski> `Maybe' is for "zero or one element". `[]' is for "zero or more elements, ordered"
08:10:37 <xa0> "...maybe is isomorphic to a list with maximum one element.."
08:11:10 <xa0> yeah okay
08:11:48 <ertesx> if you need to explain the relationship between Maybe and [] to someone, chances are you shouldn't use words like "isomorphic"
08:12:12 <ertesx> (unless that person has a math background anyway)
08:12:24 <xa0> marginally
08:12:54 <Aruro> xa0: why do u need to articulate anything? maybe has very natural motivation
08:13:18 <xa0> yes
08:13:24 <Aruro> xa0: failed or successful computation
08:13:33 <elfeck> heyoh, can someone help me with hslogger?
08:13:39 <Aruro> guy pickes up the phone or not :)
08:13:42 <ertesx> Aruro: Maybe and [] both form interesting monoids, and it's useful to compare them
08:14:07 <elfeck> I want to only (!) log to a file via a fileHandler
08:14:21 <ertesx> whenever you get to choose an Alternative functor, Maybe is the at-most-one monoid, while [] is the arbitrarily-many monoid
08:14:27 <Aruro> ertesx: well that goes deeper into types, seems he just needs motivation for Maybe type
08:14:29 <elfeck> But   updateGlobalLogger "log" (setHandlers [infoFileHandler', noticeFileHandler'])  still logs to the stdout
08:14:51 <ertesx> Aruro: it doesn't really seem anything…  we don't have any context so far =)
08:15:00 <ertesx> except the marginal math background
08:15:01 <Aruro> ertesx: :D indeed
08:15:36 <Aruro> ertesx: marginal math background is being awake
08:17:25 <ertesx> i can haz long division
08:21:23 * sm wishes "qualified" appeared at the end of an import line
08:28:18 * hackagebot octane 0.4.7 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.7 (fozworth)
08:38:18 * hackagebot pandoc 1.17.0.2 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.17.0.2 (JohnMacFarlane)
08:59:09 <elfeck> can someone tell me how to suppress hslogger to write to stdout?
09:05:43 <elfeck> nobody can help me out with hslogger?
09:08:04 <eacameron> elfeck: Not ATM apparently :/
09:08:17 <eacameron> Never used it myself.
09:08:22 <pavonia> elfeck: Could you paste the code you are using?
09:09:20 <pavonia> hslogger has different handlers, so if you use e.g. a file handler, it shouldn't print to stdout, IMHO
09:11:10 <inad922> hello
09:11:11 <kadoban> Its default handler outputs stuff if it's above a certain priority I think, you probably just have to remove or reconfigure that one.
09:11:13 <geekosaur> there's an example of disabling the default stderr (not stdout) printer in the docs: http://hackage.haskell.org/package/hslogger-1.2.9/docs/System-Log-Logger.html#v:removeHandler
09:11:28 <inad922> I'm trying to install "aeson" via cabal
09:11:39 <inad922> version 0.11.1.3
09:11:45 <elfeck> pavonia: yes sec
09:11:54 <inad922> It just fails to compile
09:12:34 <pavonia> inad922: With what error?
09:12:53 <elfeck> pavonia: http://lpaste.net/156426
09:13:25 <pavonia> elfeck: Try the solution geekosaur provided
09:13:50 <ertesx> inad922: just guessing without an error message: a common cause is an outdated compiler, as most of hackage requires GHC 7.8 and a considerable fraction of that even needs 7.10
09:14:22 <elfeck> geekosaur: But from setHandler: Set the 'Logger'\'s list of handlers to the list supplied. All existing handlers are removed first.
09:14:34 <elfeck> geekosaur: It should remove everything
09:14:41 <elfeck> geekosaur: But I will try it nonetheless
09:15:10 <inad922> https://gist.github.com/jakab922/d04b6795ddd9eaa46efb
09:15:15 <inad922> pavonia: ^
09:15:50 <elfeck> geekosaur: okay the mistake was that the logging was inherited by the rootLogger
09:15:59 <elfeck> geekosaur: its solved now, thanks
09:16:15 <inad922> ertesx: Nah my version is 7.10.3-1. The newest availble on Arch
09:16:35 <inad922> I managed to install aeson-0.11.1.1
09:16:41 <inad922> I guess it's okay
09:17:54 <inad922> 0.11.1.(2-3) have been submitted yesterday according to hackage. I guess they are broken
09:30:22 <obadz> is the GHC primary code base in darcs or git?
09:33:11 <{AS}> As far as I understand GHC has a close development model
09:33:20 * hackagebot purescript-bridge 0.3.0.6 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.3.0.6 (eskimo)
09:33:22 * hackagebot creatur 5.9.10 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.10 (AmyDeBuitleir)
09:33:22 <{AS}> but you can submit patches etc.
09:33:34 <obadz> looks like answer is git? ⇒ http://git.haskell.org/ghc.git/tree
09:34:07 <{AS}> Yeah, I guess
09:34:14 <{AS}> it says GHC main repository
09:34:40 <obadz> http://www.infoq.com/news/2011/04/haskell-git ⇒ looks like at some point the goal was to move to github?
09:37:04 <sm> obadz: it moved from darcs to git a few years back
09:37:57 <obadz> but not to github?
09:39:43 <cocreature> nope, afaik that’s also not planned
09:39:47 <cocreature> not sure if it was at some point
09:40:43 <sm> they uses some fancy additional tools - phabricator ?
09:40:55 <cocreature> yep
09:44:34 <saurabhnanda> hey people, I'm back with monads, either, Maybes and function composition. Will this compile? http://lpaste.net/156419#a156429 (last code snippet). Is this readable/maintainable? How do you know which Monad is a particular 'do' block 'operating inside'?
09:48:05 <jle`> saurabhnanda: x <- return y is just let x = y
09:49:02 <saurabhnanda> jle`: your comment is with reference to?
09:49:30 <jle`> lines 5, 6 on the annotated version
09:53:03 <{AS}> saurabhnanda: I would probably partition this code into smaller functions
09:54:01 <{AS}> especially the result <- do ..., I would make it its own function
09:55:50 <ertesx> i wouldn't
09:56:45 <ertesx> since this is IO i would work with regular exceptions there
10:01:13 <ertesx> does that code actually compile?  it looks like a syntax error to me
10:01:51 <saurabhnanda> jle`: exactly my point. You didn't realize that later down the line there's some IO happening, right?
10:01:55 <ertesx> lines 10-14 are a binding at the end of the do-block, which isn't allowed
10:02:30 <saurabhnanda> ertesx: i didn't try compiling it. Can't compile it right now. A lot of code around it will have to change for the project to build.
10:03:09 <ertesx> saurabhnanda: GHC actually allows you to use placeholders called holes
10:03:24 <ertesx> just prefix a name with an underscore like _x
10:03:47 <saurabhnanda> ertesx: good catch. Fixed and updated.
10:04:10 <saurabhnanda> ertesx: say, what?
10:04:29 <ertesx> GHC will then just assume that _x will be defined later…  it shows you its inferred type, and if you try to evaluate it, you'll get a run-time error
10:04:42 <ertesx> > sin _x
10:04:44 <lambdabot>      Found hole ‘_x’ with type: a
10:04:44 <lambdabot>      Where: ‘a’ is a rigid type variable bound by
10:04:44 <lambdabot>                 the inferred type of it :: a at <interactive>:1:1
10:04:54 <saurabhnanda> generally, isn't this very, very confusing. Even when righting I had to constantly keep thinking whether I'm in the IO monad or the Either moand. 3 days down the line, I, myself, won't remember.
10:05:13 <saurabhnanda> ertesx: interesting
10:05:48 <ertesx> saurabhnanda: you can actually use holes for that
10:05:52 <saurabhnanda> what's the Haskell equivalent of the slime-repl in emacs for common lisp? Can I keep a ghci running in my editor and keep evaluating one function at a time? as I define them?
10:06:11 <ertesx> throw _action somewhere into the do-block, and GHC will tell you the inferred type
10:06:22 <ertesx> > do _action; putStrLn "blah"
10:06:23 <saurabhnanda> so, is there a better way to interleave code in two monads, in this case, IO and Either?
10:06:24 <lambdabot>      Found hole ‘_action’ with type: IO a0
10:06:25 <lambdabot>      Where: ‘a0’ is an ambiguous type variable
10:06:25 <lambdabot>      In a stmt of a 'do' block: _action
10:07:13 <ertesx> i use haskell-mode…  it provides haskell-interactive-mode, which is basically a full haskell IDE in emacs
10:07:27 <MarcelineVQ> ertesx: You need to -fdefer-typed-holes to get them to be runtime checked instead of compiletime errors iirc
10:07:29 <saurabhnanda> anything in sublime? I've been off emacs for 3 years now. 
10:07:45 <saurabhnanda> how do I copy paste a multi-line function in ghci?
10:07:46 <bennofs> Assume I have some kind of state that consists of some quite large vectors which I do not which to copy. Now I want to write functions operating on these (mutable) vectors that are pure (they only read this vector) and I don't want to force them all to be in the ST monad. Is there a way to accomplish that?
10:07:49 <ertesx> MarcelineVQ: true
10:09:07 <ertesx> bennofs: if you're absolutely sure that the vector won't be changed during evaluation of those functions, then you can use unsafeFreeze (assuming the 'vector' library)
10:09:12 <bennofs> I thought that the following should be safe: write a function readableView :: NFData a => MVector s b -> (Vector b -> a) -> ST s a, which could use unsafeFreeze
10:09:37 <bennofs> do you think that would work
10:10:02 <bennofs> (readableView vector compute = unsafeFreeze vector >>= evaluate . force . compute)
10:10:10 <ertesx> bennofs: looks reasonable to me…  there is something similar exactly in the other direction for storable vectors
10:12:28 <ertesx> bennofs: though i'd use unsafeFreeze directly and make sure that evaluation is complete before modifying the mutable version…  'evaluate . force' doesn't guarantee anything and may needlessly make things less efficient
10:12:40 <saurabhnanda> hmm, my function is giving a parse error on input 'case' == any hints on why? (i'm pasting it in GHCi with multi-line mode enabled)
10:12:54 <newsham> ?bot
10:12:54 <lambdabot> :)
10:12:58 <newsham> ?quote thunk
10:12:58 <lambdabot> lispy says: Schoedinger's cat is really in a thunk not a box
10:13:11 <bennofs> ertesx: why would evaluate . force not make sure that the computation is done before continuing?
10:13:19 <saurabhnanda> ?quote haskell
10:13:19 <lambdabot> haskell says: BONUS> as you can see, one of the best parts of Haskell is #haskell
10:13:21 * hackagebot lentil 0.1.11.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.11.0 (fffaaa)
10:13:25 <saurabhnanda> ?quote monads
10:13:25 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
10:13:39 <bennofs> btw, is there an "evaluate" for the ST monad?
10:13:41 <ertesx> saurabhnanda: please update the code to remove all the 'return' applications that aren't necessary…  they are extremely confusing
10:13:47 <saurabhnanda> ?quote monad transformers
10:13:47 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
10:14:02 <ertesx> saurabhnanda: "y <- return x" = "let y = x"
10:14:08 <saurabhnanda> ?quote readert
10:14:09 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I just don't know what it means.
10:14:38 <saurabhnanda> well, I'm not the only one who feels this way about monad transformers :-)
10:15:18 <hpc> oh yeah, what ever happened to BONUS?
10:16:02 <ertesx> bennofs: oh, i confused something there…  anyway, enforcing NF is usually not a good idea
10:16:07 <saurabhnanda> ertesx: that would apply to line 5 & 6?
10:16:52 <bennofs> ertesx: yes, but it was the only way I could see to make it guarranted safe
10:17:36 <ertesx> saurabhnanda: yeah…  there is also this confusingly nested 'do' with 'result' and what you called 'finalResult' before
10:18:08 <saurabhnanda> ertesx: I can't convert those to 'let' ... how will the monadic magic with Either happen if I do that
10:18:19 <ertesx> (do x <- do { a; b; c }; f x) = do a; b; x <- c; f x
10:18:22 * hackagebot cryptonite-openssl 0.1 - Crypto stuff using OpenSSL cryptographic library  https://hackage.haskell.org/package/cryptonite-openssl-0.1 (VincentHanquez)
10:18:40 <ertesx> saurabhnanda: i don't see any monadic magic with Either
10:18:46 <ertesx> and you can, definitely, because that's a monad law
10:18:58 <ertesx> whenever you see 'y <- return x', you can rewrite it
10:19:47 <saurabhnanda> ess_sing: please take a look at http://lpaste.net/156419#a156431
10:19:52 <saurabhnanda> especially line 10
10:19:58 <saurabhnanda> which is causing my confusion
10:20:09 <saurabhnanda> the topmost do is inside IO
10:20:18 <saurabhnanda> then I go inside an Either 'do'
10:20:23 <saurabhnanda> and inside that do I need to do IO again
10:20:31 <saurabhnanda> major confusion happens
10:20:57 <ertesx> i'm not completely sure, but it seems like you tried to rewrite "x <- return c" to "x <- c", which is not valid
10:21:14 <ertesx> "x <- c" is not the same thing as "let x = c"
10:22:39 <ertesx> unindent lines 5-15, then remove line 4, then add "result <- " in front of "runDb" in what is currently line 11
10:22:49 <ertesx> that gets rid of the confusing nested do
10:23:36 <ertesx> it's an instance of this:  (do x <- do { a; b; c }; f x) = do a; b; x <- c; f x
10:30:06 <Cale> ertesx: Which is a valid transformation by the monad associativity law :)
10:32:53 <saurabhnanda> sorry, got disconnected
10:33:04 <hpc> Cale: that's actually a good example for the even broader case of why laws on type classes are important
10:33:06 <ertesx> Cale: i'm trying to avoid new terminology, until the code works…  the first-what-then-why approach usually works for me =)
10:33:56 <hpc> from the perspective of a programmer that is used to imperative languages, that might look like a pretty neat invariant to be able to guarantee
10:34:11 <ertesx> saurabhnanda: http://lpaste.net/156432
10:34:14 <Cale> ertesx: Yeah, I just felt the need to say that, because I think it's a good way of thinking about what that associativity law means from a practical day-to-day standpoint.
10:34:14 <hpc> for code inlining and such
10:34:45 <saurabhnanda> ertesx: I'm not sure I understand. I'll explain the Either monadic magic that i'm expecting. if line #5 results in a Left... I want everything to skip and go directly to line 16
10:34:50 <saurabhnanda> will that not happen?
10:35:02 <hpc> (especially in javascript where the meaning of something using 'this' can change wildly with the addition of a function call further up)
10:35:24 <ertesx> saurabhnanda: there is absolutely nothing monadic going on there with Either
10:35:41 <ertesx> you're really just converting a Maybe to an Either, and nothing more
10:36:16 <saurabhnanda> okay, let me manually de-sugar lines 4-9 manually and show you
10:37:24 <ertesx> saurabhnanda: i suggest that you rewrite the code from scratch, line by line, and you use holes heavily in order to see what's going on in each part
10:37:37 <ertesx> the main 'do' block describes an IO action
10:38:59 <ertesx> the only other monad (potentially) that i see there is introduced by runDb…  i don't know its full type, so i'm not sure…  it might just be IO
10:39:22 <ertesx> nothing else is monadic in this code
10:39:37 <ertesx> you're just applying functions and pattern-matching
10:43:34 <saurabhnanda> ertesx: hang on... manual de-sugaring takes time
10:43:42 <sphinxo> I seem to be getting a tcmalloc error when trying to compile lamdu http://lpaste.net/8780065149152133120
10:44:09 <sphinxo> Any ideas?
10:45:14 <saurabhnanda> ertesx: http://lpaste.net/156419#a156434
10:45:47 <sphinxo> the specific error is src/tcmalloc.cc:278] Attempt to free invalid pointer 0x2757550
10:46:21 <ertesx> saurabhnanda: that doesn't seem correct, and also i'm not sure that desugaring this helps at all
10:47:14 <ertesx> saurabhnanda: you're trying to somehow force monadicness onto the Either stuff, which, again, is simply not monadic
10:47:27 <ertesx> you're *only* converting Maybe to Either and nothing more
10:48:53 <ertesx> this is what you had before:  do xE <- return (maybeToEither str xM); ...
10:49:09 <ertesx> as said, that's equivalent to:  do let xE = maybeToEither str xM; ...
10:49:20 <ertesx> now tell me, what's the type of xE?
10:49:24 <roelof> How to solve this list : http://lpaste.net/156433
10:52:22 <saurabhnanda> ertesx: Either
10:52:47 <ertesx> saurabhnanda: exactly, it's of type Either String Something, assuming that xM is of type Maybe Something
10:53:22 <ertesx> saurabhnanda: what do you need to do to process the Something value (that potentially isn't there)?
10:56:14 <saurabhnanda> so xE can be a Left or Right
10:56:34 <saurabhnanda> if it's Right, further computations should happen, if it's a Left further computations should NOT happen
10:57:00 <saurabhnanda> xE >>= (\s -> Either String SomethingElse)
10:57:43 <ertesx> you need to pattern-match
10:57:57 <ertesx> don't worry, you will learn how to avoid it, but not now
10:58:07 <ertesx> (not avoid it, but make it implicit)
10:58:59 <ertesx> in other words:  do let xE = _fromXM; case xE of Left err -> _errCase; Right x -> _xCase
10:59:18 <ertesx> (GHC will accept this code and tell you which hole is of which type)
11:01:25 <saurabhnanda> why the 'do' block here?
11:01:36 <saurabhnanda> ertesx: btw I'm trying to avoid pattern matching
11:02:09 <saurabhnanda> ertesx: doing a pattern match after every function that returns a Maybe is not very different from C error codes.
11:02:19 <ertesx> first you need to understand how to make this work *with* pattern-matching
11:02:42 <ertesx> then you can learn how to make it implicit (or just use IO exceptions)
11:02:47 <saurabhnanda> ertesx: okay, let me give you the pattern-matching code, I think my haskell-fu is at that level. 
11:03:07 <ertesx> the do-block is not strictly necessary, neither is the 'let'
11:03:26 <ertesx> case _fromXM of Left err -> _errCase; Right x -> _xCase
11:09:41 <xa0> is haskell a concatenative language?
11:11:45 <crough> xa0: No, but it can be used as one.
11:11:58 <xa0> i see
11:12:05 <xa0> what exactly is the difference
11:13:42 <crough> If you program almost exclusively in the Arrow typeclass, you get semantics similar to concatenation langauges
11:13:58 <xa0> ah, okay
11:14:04 <crough> Concat. languages typically *only* allow composition and deal as little as possible with concrete values
11:14:36 <xa0> so the whole function/value definition and do syntax thing throw it off
11:14:53 <crough> a few other things, too. Haskell's composition isn't first class re: syntax
11:15:02 <ertesx> saurabhnanda: i've got to go now…  once you have the pattern-matching version done and working, invent the following convenience function:  passEither :: IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)
11:15:03 <crough> `a b c` in a concat language means `c . b . a`
11:15:12 <xa0> ah yeah, wrong way round
11:15:33 <crough> And we have to use an operator. Our first class "application" is function application, not function composition
11:15:40 <ertesx> saurabhnanda: make it infixr and use it infix:  action `passEither` \x -> ...
11:15:59 <ertesx> saurabhnanda: then you're only one step away from inventing EitherT and make it completely implicit
11:16:00 <xa0> oh i see
11:16:21 <crough> Hence the arrow class being *very* similar to concatinative programming :)
11:16:23 <ertesx> saurabhnanda: i'm sure someone else here will guide you through the process
11:16:43 <xa0> that's starting to make sense now
11:16:58 <xa0> thanks :p
11:17:22 <crough> yeah of course!
11:17:50 <ertesx> saurabhnanda: oh, and please do it in this order…  passEither will help you a lot with inventing EitherT…  and yes, i want you to *invent* it, not use the existing EitherT
11:18:01 <ertesx> good luck and see you later =)
11:18:34 <crough> Also just FYI, don't use the existing EitherT... ever? It's been depricated for ExceptT
11:31:33 <johnw> well, "community deprecated"
11:40:47 <Lemmata> hello, I'm trying to cabal install hsqml but it throws an error saying that it can't find the qt5qml (external) dependency. I have the package installed and I know the directory the library is located in, how do I get cabal or hsqml to recognize it?
11:43:25 * hackagebot vinyl-plus 0.1.0.0 - Vinyl records utilities  https://hackage.haskell.org/package/vinyl-plus-0.1.0.0 (andrewthad)
11:43:27 * hackagebot hopenpgp-tools 0.17.1 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.17.1 (ClintAdams)
11:43:29 <yyyyy> Lemmata: are you sure you have the includes and not just the library?
11:43:52 <yyyyy> Lemmata: i.e. is it in /usr/include or under /usr/lib, for example
11:44:35 <Lemmata> yyyyy: it's in usr/lib/x86_64-linux-gnu as a .so
11:46:14 <Joe___> Hi -- I'm working through Haskell School of Expression, but on mac. Has anyone gotten the sample code to work? Even using the new GLFW version it's as if keyboard events aren't being received. The GLFW sample code seems to work though (it gets the keyboard events). This is with ghc (not ghci as suggested by the net). The only other reference I found seem to be running it in a VM. I imagine is something simple but I'm haskell newbie.
11:47:08 <shapr> Joe___: Is that the Thompson book?
11:47:24 <Joe___> Paul Hudak
11:47:28 <suppi> shapr, hudak's book
11:47:31 <shapr> ah right
11:48:04 <shapr> Joe___: The software for that book has been updated several times in the past fifteen years, but I lost track of whether there's code that works right now with the latest Haskell
11:48:46 <Joe___> I've got code from 2014 which seems to be the most recent.
11:48:52 <shapr> Joe___: does it not work?
11:49:06 <Joe___> Not quite. 
11:49:11 <shapr> Joe___: what's the error?
11:49:47 <Joe___> No error, the GL window appears and the graphics show up, but no keyboard events arrive.
11:50:03 <Lemmata> yyyyy:  both qt4 and qt5 directories are under /usr/lib/x86_64-linux-gnu and there seems to be a qt4 directory under /usr/include but not qt5 directory (dunno if that matters)
11:50:39 <Aruro> Joe___: dont waste time with this just go throught the book :)
11:51:53 <Joe___> But the book is all about drawing stuff (and playing audio). 
11:53:27 <Joe___> I suspect there is some mac specific call that has to be made to receive events.
11:53:46 <Joe___> Enable receiving events that is.
11:55:25 <shapr> Joe___: I don't know the answer, but I do love playing with Haskore
11:57:39 <Joe___> shapr: Are you using a mac?
11:58:25 * hackagebot ViennaRNAParser 1.2.9 - Libary for parsing ViennaRNA package output  https://hackage.haskell.org/package/ViennaRNAParser-1.2.9 (FlorianEggenhofer)
11:58:53 <shapr> Joe___: nope, I do everything on Linux
11:59:02 <shapr> Joe___: I don't even have a mac I could use to help, sorry.
11:59:16 <Aruro> Joe___: what are your other sources of learning Haskell?
12:02:33 <Aruro> Joe___: this book is a bit strange for teaching haskell to beginners
12:03:07 <Joe___> Aruro: Just the other online tutorials. SoE was appealing because of its IO orientation. I've using several functional languages in the past -- pure scheyyme, ML, scala, etc. so I'm mostly learning haskell (as opposed to FP generally.
12:03:25 * hackagebot derive 2.5.24 - A program and library to derive instances for data types  https://hackage.haskell.org/package/derive-2.5.24 (NeilMitchell)
12:03:27 * hackagebot VKHS 1.6.0 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-1.6.0 (SergeyMironov)
12:03:28 <Joe___> Suggestions?
12:04:27 <Aruro> Joe___: definitely, wait.
12:05:07 <Aruro> http://www.cis.upenn.edu/~cis194/spring13/
12:05:34 <Aruro> for your graphics desires http://projects.haskell.org/diagrams/
12:06:29 <Aruro> this is very good : https://www.haskell.org/tutorial/
12:06:43 <Aruro> written by physicists partly
12:07:14 <Aruro> then to get grip with practice u go here : http://book.realworldhaskell.org/read/
12:08:33 * hackagebot VKHS 1.6.1 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-1.6.1 (SergeyMironov)
12:08:35 <Joe___> Aruro: Cool, thanks.
12:08:35 <Aruro> after that u are free. Can find interesting this: https://wiki.haskell.org/Typeclassopedia
12:09:19 <Aruro> Joe___: and ask questions here
12:10:15 <shapr> Joe___: yes, ask lots of questions here!
12:10:16 <Joe___> Are there any moderate to large open-source "production" systems in haskell other than yesod?
12:10:27 <shapr> well, yesod is a framework for making production systems...
12:10:29 <Aruro> Also check modern stuff : https://www.schoolofhaskell.com/
12:10:32 <shapr> Facebook uses Haskell
12:10:43 <shapr> lots of big companies use Haskell in various places
12:11:05 <shapr> Several companies in the Atlanta area hire Haskellers for their codebases
12:12:01 <Aruro> shapr: Facebook haskell use case is already a cliche :)
12:12:26 <Adeon> I use haskell in adtech
12:12:49 <Aruro> Joe___: look here: https://github.com/commercialhaskell/commercialhaskell
12:12:57 <Joe___> I thought Facebook was primarly php. Adeon: What's your app do?
12:12:58 <Aruro> list of companies who participate is below
12:13:51 <Adeon> mostly I use it to orchestrate big data processing jobs on thread and server-level but lately I've also used to compute certain metrics from data
12:14:08 <Adeon> lots and lots of ugly IO code
12:14:26 <Adeon> in my case the STM and excellent support for concurrency have been wins
12:14:45 <Adeon> most of my haskell code doesn't really strain the CPU, it's the jobs it fires off that do that
12:20:11 <Joe___> Adeon: I imagine lots of companies have people/teams that write a bit of haskell here and there. I was wondering if haskell was in anyone's main critical path -- like twitter with scala (they published a lot network libraries and concurrency frameworks) or Storm which a lot companies depend on or Play.
12:22:16 <Adeon> Joe___: yeah we don't have that
12:22:46 <Adeon> well technically if the haskell parts stop working lots of other things also stop working so in that sense it's critical
12:23:13 <Joe___> shapr Aururo Adeon: Thanks for the help & links.
12:24:20 <shapr> Joe___: make sure to try Haskore, it's really fun
12:24:32 <shapr> I did some Godel Escher Bach stuff with Haskore
12:26:33 <Joe___> Adeon: Sure, but you're not really concerned with performance (but maybe nobody is these day with giant memories and multi-cores) and, coordinating distributed instances, big deployments, etc. Do you talk to a rdb? If so, is there a library you can reccomend?
12:27:17 <Adeon> I talk to postgresql
12:27:20 <Adeon> I use postgresql-simple
12:27:22 <Joe___> shapr: will do. Hudak I think is working on a new book: Haskell School of Music; it's available online at the moment. It looks fun.
12:27:34 <Adeon> I also talk a lot to S3 but I fire off s3cmd, aws or gof3r for that
12:27:37 <shapr> oh cool!
12:27:44 <Aruro> shapr: did you do any of Bachs scores?
12:28:03 <Joe___> Adeon: Cool! 
12:28:04 <shapr> Aruro: yeah, some simple stuff, I can probably find them deep in the onion of my home dir tarballs
12:28:10 <Adeon> I think postgresql-simple is pretty good if you just to write plain SQL with sensible escaping so you won't be vulnerable to injections or anything
12:28:13 <shapr> I got SoE right when it came out
12:28:33 <Adeon> I think there's a very similar library for mysql on hackage as well
12:28:33 <Aruro> shapr: github it :) community made WTC in haskell will be nice
12:28:34 <shapr> I was most excited about the crab canon, so I think I have some of that.
12:28:39 <shapr> wtc?
12:28:58 <Aruro> Well-Tempered-Clavier
12:29:02 <Adeon> I'm also concerned with performance
12:29:03 <shapr> Joe___: found any parts of Haskell you enjoy yet?
12:29:14 <shapr> Adeon: Haskore has a Performer type ;-)
12:29:17 * shapr is joking
12:29:20 <Aruro> shapr: did u take a look at diagrams library? its much more advanced
12:29:21 <Adeon> my heaviest haskell job uses almost all the memory of an amazon r3.8x instance
12:29:30 <Adeon> that's about 250 gigabytes of memory and 32 processors
12:29:32 <shapr> Oh yeah, I used diagrams in my GSoC project!
12:29:46 <Adeon> and I use about 50 of those servers at the same time as well
12:29:51 <shapr> Aruro: https://ghclive.wordpress.com/
12:29:51 <kadoban> Adeon: Nice
12:30:13 <Adeon> although even then it's really C code that does the heavy lifting that's just compiled inside the haskell program
12:30:25 <Adeon> but it's like
12:30:27 <Adeon> 20 lines of C
12:30:29 <Adeon> rest is haskell
12:30:38 <Adeon> and still 99.9% of time is spent on that C code on 32 threads
12:30:45 <xa0> lol
12:31:46 <Aruro> shapr: so u did diagram rendering in ghci thats very nice :)
12:32:04 <Joe___> shapr: I like fp in general. Haskell seems fine although I'm not a fan of layout (in python too). I think it makes it hard to read the code.
12:32:49 <MarcelineVQ> you don't have to use layout, haskell can use { } and ; as well
12:33:23 <xa0> you can literally write it like C...
12:33:35 <Joe___> Adeon: I'm a postgresql fan too. That is a pretty hefty app; what are you computing?
12:33:59 <Joe___> Sure, but no one else writes code with curlies & semis.
12:34:01 <oherrala> Adeon: why that 20 lines of C is not Haskell?
12:35:02 <monochrom> it is possible to use explicit {;} instead of layout
12:35:43 <monochrom> > let { x :: Int; x = 4; y :: Int -> Int; y g = x + g } in y x
12:35:46 <lambdabot>  8
12:40:32 <shapr> Joe___: you can use braces and semicolons, but other people will be sad
12:40:37 <shapr> like me!
12:41:27 <dolio> Yeah, other people will think your braces and semicolons makes your code hard to read.
12:42:01 <monochrom> I am most happy if you use {;}, and layout, and comments that explain your nesting.
12:42:32 <monochrom> that way, people who want layout can tell their editors to hide {;} and the comments
12:42:49 <monochrom> people who want {;} can tell their editors to hide whitespace and comments
12:42:50 <oherrala> sounds like we need International Obfuscated Haskell Coding Competition
12:43:17 <monochrom> and people who understand neither layout nor {;} and tell their editors to hide whitespace and {;}
12:44:16 <cocreature> I’m not sure hiding everything that you don’t understand helps you to understand things :)
12:44:20 <ski> @wiki Obfuscation
12:44:20 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
12:44:22 <ski> oherrala ^ ?
12:44:39 <Adeon> Joe___: I think the company might consider my computation secret sauce but it's a really simple mathematical computation, just have to perform it on huge amounts of data
12:44:42 <Joe___> monochrom: that's really the right answer (for all languages) -- indentation, layout, "helper" syntax should all be part of the presentation.
12:44:45 <oherrala> ski: oh, cool
12:44:56 <Adeon> oherrala: because it's difficult to write really performant low-level haskell
12:45:00 <monochrom> oh, but the point of this scheme is to have so much redundancy you can safely hide things
12:45:05 <kadoban> cocreature: Sounds like something douglas adams would have come up with though, so maybe it'll lead to hilarity.
12:45:12 <Adeon> oherrala: not that it's impossible but it's also easy to just write those 20 lines in C
12:45:17 * ski remembers the zeroeth one
12:45:36 <cocreature> kadoban: hilarity sounds like a goal I could get behind :)
12:45:52 <oherrala> Adeon: That's something I suspected
12:46:08 <Adeon> yeah there's lots of memory mapped files involved
12:46:12 <Adeon> I actually use haskell to memory map
12:46:15 <ph88> hi puregreen 
12:46:15 <Adeon> pass the pointer to C
12:46:15 <oherrala> Adeon: anyway, are you familiar with inline-c? https://github.com/fpco/inline-c/blob/master/README.md
12:46:17 <Adeon> C does computation
12:46:19 <ph88> hi all
12:46:24 <Adeon> yeah I know about it
12:46:29 <Adeon> haven't actually used it yet in my code
12:46:38 <Adeon> didn't know about it when I wrote that big job
12:47:37 <dicej> Hi all.  Can someone tell me why GHC can't/won't infer the type of e.g. "foo = return ()" as "Monad m => m ()"?
12:48:10 <monochrom> just like when you buy a model ship (assembly required), the box comes with English instruction, German instruction, Swedish instruction, Italian instruction, French instruction, Quebec French instruction...
12:48:12 <Cale> dicej: Because that's a pattern binding and so the monomorphism restriction applies to it.
12:48:34 <Cale> It actually does infer that type
12:48:46 <monochrom> and it is pretty safe to ignore the 5 instructions you don't understand
12:48:59 <Cale> But with the monomorphism restriction turned on, pattern bindings are not allowed to be type class polymorphic
12:50:18 <dicej> Cale: thanks, I'll try the NoMonomorphismRestriction pragma
12:52:45 <shachaf> Cale: Not inferred to be, at least.
12:56:54 <dolio> monochrom: Instructions in other languages are usually in distinct parts of a booklet, not all interleaved, though.
12:57:04 <dolio> Because it would take significantly more effort to process the latter.
13:00:29 <puregreen> ph88: hi
13:00:53 <dolio> I.E. ignoring things isn't necessarily free.
13:02:30 <ph88> puregreen, could you take a look at my parser program ?  https://www.pastery.net/axkenu/
13:06:00 <puregreen> okay
13:06:43 <puregreen> ph88: is there any reason why many' and not many?
13:07:59 <puregreen> actually, nevermind
13:08:20 <ph88> puregreen, many from which package? i only have many' many1 and many1'
13:08:29 <ph88> and manyTill of course
13:08:35 * hackagebot snap-loader-dynamic 0.10.0.4 - Snap: A Haskell Web Framework: dynamic loader  https://hackage.haskell.org/package/snap-loader-dynamic-0.10.0.4 (DougBeardsley)
13:11:38 <cocreature> ph88: control.applicative?
13:12:00 <ph88> cocreature, for <|>
13:12:15 <ph88> didn't know how to just import that function
13:12:32 <cocreature> ph88: it is for (<|>), Alternative is in Control.Applicative
13:12:43 <cocreature> https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:many
13:13:08 <puregreen> ph88: the problem is that pRule already consumes the “->”
13:13:19 <puregreen> and then pRuleStatement tries to consume it again, and fails
13:14:05 <puregreen> protip— um, just tip: if you write “traceShowM =<< takeText” at any place in your parser, it'll print the remaining (unconsumed) input, that's helpful while debuggint
13:14:08 <puregreen> * debugging
13:14:16 <puregreen> traceShowM comes from Debug.Trace
13:16:19 <puregreen> also, some combinators, like ‘many’, ‘some’, and ‘<|>’ come from Control.Applicative, so you didn't have to use «many'»
13:16:28 <sm> what is this function called: a -> [(a -> a)] -> a ? I'd rather not write foldl (flip id) x fs as at http://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#g:4
13:16:36 <ph88> ye i was missing some debugging tools
13:16:41 <sm> and I'm not finding it in hoogle for some reason
13:16:44 <ph88> do you know any other good debug tools as well ?
13:16:45 <puregreen> (and ‘some’ looks nicer than ‘many’ but that's just what I think)
13:17:47 <sm> ohh.. "alpha version, type search doesn't work"
13:18:20 <johnw> sm: I think it's flip asum
13:18:37 <johnw> :t flip asum
13:18:38 <lambdabot> (Foldable t, Alternative ((->) b)) => b -> t (b -> c) -> c
13:19:11 <kini> :t flip (foldl (.) id)
13:19:13 <lambdabot> Foldable t => c -> t (c -> c) -> c
13:19:58 <kini> I guess foldl (flip id) is the most compact...
13:20:44 <xa0> flip id?
13:20:48 <xa0> :t flip id
13:20:49 <lambdabot> b -> (b -> c) -> c
13:20:51 <ij> what does stack do that cabal executable doesn`t?
13:20:51 <kini> (without leaving the prelude)
13:20:53 <dolio> @type flip $ ala Endo foldMap
13:20:55 <lambdabot> Foldable t => b -> t (b -> b) -> b
13:21:08 <johnw> yeah, dolio has the right one
13:21:17 <johnw> there is no Alternative ((->) b) that I can find
13:22:10 <dolio> Way back in the day, it could have been `flip fold`, I think.
13:22:11 <sm> thanks, all. I'm having trouble parsing dolio's answer
13:22:40 <sm> did you say, it's foldMap  ?
13:23:02 <puregreen> ph88: http://lpaste.net/156436
13:23:35 <Zekka|Sigfig> dolio: Are you sure that composes in the right order?
13:23:45 <puregreen> now you can write e.g. “rule <- debug pRule” instead of “rule <- pRule” and get some info about what the parser has consumed and what is the remaining input
13:23:50 <Zekka|Sigfig> (I don’t know either way right offhand)
13:24:01 <Zekka|Sigfig> I thought foldMap was analogous to a right fold and then map, though, not a left fold
13:24:11 <Zekka|Sigfig> Wait
13:24:18 <Zekka|Sigfig> Uh, never mind, we’re talking about an associative operation
13:24:34 <dolio> Zekka|Sigfig: No, but it's not difficult to modify to get the other order if you want it, though.
13:24:53 <Zekka|Sigfig> Yeah, I’m thinking of something that none of these solutions does, which is modify order
13:25:00 <Zekka|Sigfig> they might vary in grouping but that should be inconsequential
13:25:59 <sm> I guess I'll stick with "let opts = foldl (flip id) defaultOptions optmods", though it's not very clear
13:26:12 <sm> surprising, I thought this would be in the standard libs
13:26:20 <dolio> foldl with application actually is the opposite order to mine, I believe.
13:26:25 <hexagoxel> stupid question time. i iterate twice over a free monad. i want to forward information from the first iteration to the second, but only between the "same nodes of the monad structure". i wonder how (if it is possible) to define the equality that might allow me to talk of "the same nodes".
13:27:43 <puregreen> sm: if you happen to import Data.Function you can write “foldl (&)”, this might be slightly clearer
13:27:48 <hexagoxel> there is no way to define that equality unless i have an equality on the underlying values of the underlying functor, right?
13:28:07 <ph88> puregreen, how should i apply that function ?
13:28:07 <hexagoxel> s/underlying values/values/
13:30:24 <sm> puregreen: nice, thanks
13:31:45 <sm> and base-prelude provides & by default
13:32:31 <puregreen>  > now you can write e.g. “rule <- debug pRule” instead of “rule <- pRule”
13:32:35 <puregreen> ph88: ^
13:33:02 <puregreen> or have I misunderstood?
13:33:39 <ph88> eh sorry i missed that line :/
13:33:58 <byorgey> sm: there's no standard name for it.  It is also sometimes written as   flip (getEndo . mconcat . map Endo)
13:34:18 <byorgey> whoops, missed the scrollback
13:34:30 <sm> thanks
13:34:33 <dolio> Hmm, it's actually harder than I thought to modify my thing to get the opposite order.
13:34:48 <dolio> Due to the way unwrapped works, and ala not composing.
13:35:06 <dolio> There's probably some ala derivative that you can use, but I don't know the name.
13:35:31 <ph88> puregreen, it's nic1e
13:35:33 <ph88> !
13:35:33 <hexagoxel> ij: stack applies more sophisticated sandboxing (by default, in contrast to cabal-install where you have to manually manage sandboxes).
13:39:22 <hexagoxel> ij: i.e. stack caches compiled libraries even between different projects. convincing cabal-install to not recompile libraries for each project would require a good amount of manual effort.
13:42:42 <ania123> is here english native speaker?
13:43:41 <Zekka|Sigfig> ania123: I speak English natively
13:44:59 <ania123> may I pm you?
13:45:02 <Zekka|Sigfig> Sure
13:46:09 <reygoch> I want to install cabal package globally from source but it allways ends up installing into local sandbox
13:46:22 <dcoutts> reygoch: cd ~/
13:46:28 <reygoch> windows :D
13:46:33 <dcoutts> do the equivalent
13:46:36 <dcoutts> any other dir
13:46:40 <reygoch> and than what?
13:46:43 <dcoutts> install
13:46:50 <dcoutts> then you're not in the sandbox
13:47:00 <hexagoxel> dcoutts: then it would not be a install "from source"..
13:47:09 <dcoutts> ohhh, I see
13:47:12 <reygoch> lol
13:47:19 <dcoutts> sorry, all our packages are from source :-)
13:47:45 <hexagoxel> yeah, the phrasing is somewhat ambiguous :D
13:47:48 <reygoch> I tried runhaskell configure / build / install but than it complains about dependencies
13:48:37 <reygoch> Just to rephrase, I have folder with cabal project
13:48:45 <reygoch> and I want to install that project globally
13:48:56 <hexagoxel> you can `cabal install --bindir=C:\cabal-install\bin --datadir=C:\cabal-install\share`
13:49:05 <hexagoxel> or something like that. in the sandbox.
13:49:13 <reygoch> hm... no other way?
13:49:23 <reygoch> I could swear there was a better way.
13:51:24 <hexagoxel> reygoch: user-global or system-global?
13:52:19 <hexagoxel> reygoch: do you want to register the library in a global db, or just the executable in a location outside the sandbox?
13:52:44 <byorgey> reygoch: you should be able to cd into a different directory and then  cabal install path/to/package/source/
13:52:50 <reygoch> oh
13:53:16 <byorgey> with a trailing path separator, so cabal knows it is a path and not a package name
13:53:23 <orion> Does anyone know of a method by which I can keep the connection to an HTTP server alive after perocessing the response?
13:53:41 <reygoch> perfect!
13:53:43 <reygoch> thanks
13:54:06 <orion> I'm doing a request -> response -> process -> new request cycle with the same server over and over, and it'd be nice to keep the expensive TLS connection open.
13:54:54 <johnw> orion: you've not said anything about the framework which is managing the HTTP connection for you
13:55:16 <orion> johnw: Ah, I'm using HTTP conduit.
13:55:27 <johnw> so you have a Manager
13:55:36 <johnw> I'm pretty sure you can manage the Manager yourself, and it will stay open
13:55:45 <orion> Oh, indeed I do.
13:56:10 <kadoban> orion: Use something like websockets instead?
13:56:21 <johnw> HTTP conduit can make use of websockets these days, btw
13:56:21 <orion> I don't have a choice. It's not my web server.
13:57:04 <orion> But it seems that keeping the manager floating around should be sufficient, thanks johnw.
14:09:56 <shapr> johnw: are you attending Lambda Conf this year?
14:10:12 <johnw> no
14:10:23 <johnw> they accepted my workshop proposal, but I backed out because it wasn't solidly enough grounded yet
14:10:30 <lopex> int-e: hiya, any chance inviting lambdabot to #scala.pl ?
14:12:03 <sphinxo> Are there any fp programming conference type things in the uk?
14:12:22 <shapr> johnw: aw, too bad
14:12:45 <shapr> lopex: I can temporarily invite lambdabot there until the next restart
14:13:21 <lopex> shapr: cool, any chance of making it persistent ?
14:13:35 <lopex> shapr: thanks
14:13:40 <shapr> nope, you have to get int-e to do that for you
14:13:44 <shapr> lopex: or run your own!
14:13:46 <lopex> ok
14:13:53 <shapr> I just built lambdabot for slack, it's not too bad :-)
14:14:01 <lopex> shapr: yeah, I have been, but lost a machine
14:14:20 <shapr> ah, that's frustrating
14:14:21 <lopex> shapr: it ran on solaris :)
14:14:24 <shapr> whoa, crazy!
14:14:35 <shapr> I've never tried Haskell on anything but Linux 
14:14:56 <lopex> I'm not a solaris expert by no means
14:15:03 <shapr> neither am I
14:15:12 <lopex> I was lucky enough though to compile it
14:15:34 <shapr> how long did it take?
14:15:42 <shapr> Is it real SPARC hardware? or x86 solaris?
14:15:55 <lopex> shapr: it was quite a bit ago though, after that we had a multibot that relied lambdabot via privmsgs
14:16:46 <lopex> shapr: the thing joyent was running it was free until they decided to delete them all
14:16:54 <shapr> aw
14:17:04 <lopex> shapr: actually I'm not sure it was an intel
14:17:20 <shapr> I bet building GHC on SPARC was exciting
14:17:28 <lopex> shapr: but damn, those package systems
14:17:29 <shapr> I know pasco ported GHC to SPARC loooong ago
14:19:04 <lopex> oh I used blastwave.org 
14:19:09 <lopex> for the deps
14:19:28 <lopex> no longer a thing it seems ?
14:29:35 * hackagebot aeson 0.11.1.4 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-0.11.1.4 (AdamBergmark)
14:29:37 * hackagebot giphy-api 0.1.0.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.1.0.0 (passy)
14:41:04 <tr3> hi, may I ask a question? 
14:41:22 <shachaf> You already did.
14:41:27 <tr3> :D
14:41:29 <tr3> indeed :D
14:41:47 <tr3> uhm, so, "may I ask an haskell-related question?"
14:42:16 <dmj`> tr3: yes
14:42:35 <shachaf> @where ask
14:42:35 <lambdabot> Don't ask to ask, just ask.
14:42:42 <tr3> when declaring this newtype: newtype Flip f a b = Flip (f b a)
14:42:43 <shachaf> Hm.
14:42:53 <tr3> how should I read the (f b a) part?
14:43:06 <tr3> it's the single element of the Flip newtype
14:43:27 <shachaf> Do you know how to read newtype T a = T (Maybe a)?
14:43:33 <tr3> yes
14:43:47 <shachaf> How about newtype T f a = T (f a)?
14:44:03 <tr3> i suppose it's the same but more polymorphic
14:44:26 <tr3> with f a generic Type constructor with kind * -> 
14:44:29 <tr3> * -> *
14:44:34 <shachaf> Then newtype T f a b = T (f b a)?
14:44:54 <tr3> a generic type constructor with kind * -> * -> * ? 
14:44:59 <tr3> ok, that was a stupid question =)
14:47:29 <dmj`> @def newtype Flip f a b = F f b a
14:47:29 <lambdabot>  Parse failed: newtype declaration constructor must have exactly one parameter.
14:47:40 <dmj`> @def data Flip f a b = F f b a
14:47:43 <lambdabot>  Defined.
14:48:19 <dmj`> @typ F Either String Int 
14:48:20 <lambdabot>     Not in scope: data constructor ‘Either’
14:48:20 <lambdabot>     Perhaps you meant variable ‘either’ (imported from Data.Either)
14:48:20 <lambdabot>     Not in scope: data constructor ‘String’
14:48:25 <tr3> I think that's the reason I was confused
14:48:36 <dmj`> heh :] 
14:48:57 <tr3> i was thinking "f b a" as the same as "(f b a)"
14:51:56 <shachaf> It is.
14:53:35 <c_wraith> but "g f a b" is "(g f a) b", not "g (f a b)" 
14:55:21 <tr3> shachaf: if it's the same why the newtype doesn't accept it without parentheses?
14:56:00 <c_wraith> tr3, because of what I said. 
14:57:36 <tr3> c_wraith: ok, got it
14:57:40 <tr3> thanks
14:59:10 <tr3> with the parentheses the single field for the newtype is the application of a and b to f
14:59:12 <tr3> right?
14:59:31 <c_wraith> yes. 
14:59:56 <c_wraith> without parens, it's 3 different arguments, instead. 
15:00:49 <tr3> so there's no way to partial apply g
15:01:07 <tr3> unless you change it to a "data" type
15:01:11 <tr3> ?
15:01:40 <c_wraith> newtypes can have multiple type arguments. but only one value argument. 
15:02:52 <tr3> ok
15:24:45 <sindriava> So I'm trying to create a GUI app on OSX.
15:25:24 <sindriava> However, any and all GUI libraries seem to be horrifically unfit for this task. Is trying to work with C from inside Haskell a good idea?
15:32:29 <ij> hexagoxel, Thanks! 
15:37:37 <maerwald> sindriava: does gtk+ not exist for OSX?
15:39:09 <sindriava> maerwald: Exist? Yes. Is it even remotely usable? Not really
15:40:07 <sindriava> maerwald: gtk+ is a lot less portable than people like to think. Currently, I can't get it to even build on OSX
15:57:59 <lispy> sindriava: how are you building it?
15:58:48 <lispy> sindriava: I was able to install it using brew
16:00:23 <a3gis> Hello! I am having a weird issue, not sure if I am just tired or strange things are going on... https://gist.github.com/a3gis/83d2eaf5e8a4ddf4514c
16:01:57 <a3gis> ooooh, type casting to Int
16:02:27 <shachaf> There's no such thing as type casting.
16:02:33 <adas> Is it possible to add `deriving` clauses to GADT types?
16:02:48 <RyanGlScott> adas: That depends. What are you trying to derive?
16:02:59 <verement> > (15 ^ 17, 15 ^ 17) :: (Int, Integer)
16:03:01 <lambdabot>  (6292404967145601295,98526125335693359375)
16:03:07 <a3gis> shachaf: well, the signature forces the arithmetic to be performed on Int instead of Integer
16:03:10 <shachaf> Yes.
16:03:20 <lispy> that's because of defaulting
16:03:35 <lispy> (the fact that you get different things with no type signature present)
16:04:29 <lispy> https://www.haskell.org/onlinereport/decls.html#default-decls
16:05:30 <a3gis> lispy: ah, thanks!
16:05:43 <lpaste> adas pasted “deriving Show” at http://lpaste.net/156443
16:06:21 <adas> RyanGlScott: could you please take a look at that link
16:06:44 <RyanGlScott> adas: Yeah, deriving Show typically doesn't work with sufficiently complex GADTs, but
16:06:58 <RyanGlScott> with -XStandaloneDeriving, you could do
16:07:07 <RyanGlScott> deriving instance Show a => Show (List n a)
16:07:21 <adas> what does standalonederiving do?
16:07:34 <RyanGlScott> It allows you to have deriving statements outside of a data definition
16:07:54 <adas> but here im not trying to do a derive outside a data definition
16:07:55 <RyanGlScott> So the code above is independent of the definition of List
16:08:04 <RyanGlScott> Right, you can put it in the same module
16:08:13 <RyanGlScott> It'll derive Show just as well
16:08:48 <RyanGlScott> It's necessary since GHC can't/won't figure out the instance context for datatypes with enough sophistication
16:10:04 <RyanGlScott> So you need to use -XStandaloneDeriving to specify the context yourself
16:10:13 <adas> ill try it out
16:15:08 <Nuxular> https://www.haskell.org/tutorial/stdclasses.html it seems like the second implementation of readsTree never works (if it ever did) for tree with branches within branches
16:15:45 <Nuxular> lex seems to grab more than the single character strings that this implementation seems to expect it to
16:16:44 <Nuxular> I meant to say "no longer works"... I'm tired
16:17:05 <adas> i tried instance Show a => Show (List Nat a) but it doesn't work
16:17:37 <RyanGlScott> adas: That's because something like that won't kindcheck
16:17:41 <adas> oh I know whats happening
16:17:50 <adas> Nat is type
16:17:53 <RyanGlScott> Yep :)
16:17:58 <adas> but with data kinds its also a Kind
16:18:01 <adas> so whats the problem?
16:18:30 <RyanGlScott> It's expecting a type of kind Nat
16:18:34 <RyanGlScott> Nat isn't of kind Nat
16:18:37 <RyanGlScott> Try: deriving instance Show a => Show (List n a)
16:20:31 <adas> sweet it works without 'Nat'.
16:20:43 <Nuxular> does somebody maintain https://www.haskell.org/tutorial/stdclasses.html who I can notify about this?
16:21:04 <RyanGlScott> adas: If you were feeling cheeky, you could say something like: Show (List 0 a)
16:21:16 <RyanGlScott> Then only Nil could be shown :)
16:21:30 <RyanGlScott> Er, sorry: Show (List Z a)
16:21:31 <adas> you mean Show (List Nil a)?
16:21:35 <adas> Oops
16:21:36 <adas> i mean
16:21:38 <adas> yea
16:21:41 <adas> Show (List Z a)
16:21:52 <nolraiU> That even makes sense if there isn't a (Show a)
16:22:24 <adas> but I still don't understand why I should use a type variable like 'n' when 'Nat' is a kind that restricts 'n' to either 'Z' or 'S n'
16:22:53 <adas> When I simply do Show (List n a), that 'n' could be anything
16:22:56 <nolraiU> for the same reason you cant write (nil + Nat)
16:23:37 <RyanGlScott> Yep, n is a type. Nat is a kind. Make sure not to cross the streams.
16:23:52 <adas> what is 'n'? 'n' is in place for "any kind". am i correct?
16:24:01 <RyanGlScott> (I should say, Nat is a kind in this context)
16:24:10 <RyanGlScott> n is some type of kind Nat
16:24:25 <RyanGlScott> You could write Show (List (n :: Nat) a) if you want to make that explicit
16:24:33 <adas> ah.. yesss
16:24:39 <adas> thats what Im' tyring
16:24:49 <adas> explicit is always better than implicit
16:24:58 <adas> thanks
16:28:58 <sphinxo> does eta reduction ever have an impact on performance?
16:29:31 <hpc> not in ghc
16:29:39 <sphinxo> ok great :)
16:30:26 <RyanGlScott> Careless eta expansion, on the other hand, has been known to cause bad things to happen: https://ghc.haskell.org/trac/ghc/ticket/7436
16:30:29 <hpc> there's not enough operational specification to say for other hypothetical implementations, but ghc lambdas come out to identical implementations either way
16:30:34 <hpc> unless... that
16:30:52 <hpc> or the dreaded monomorphism restriction
16:32:21 <hpc> huh, that bug is both really obvious and something i would never have thought of
16:33:37 <hpc> actually no it isn't, i have no idea how the asymptotic complexity changes
16:33:53 <RyanGlScott> Here's an explanation of it: http://accidentallyquadratic.tumblr.com/post/134605666547/ghc-derived-foldable-and-traversable-instances
16:34:22 <RyanGlScott> tl;dr When used with recursive data structures, it results in O(n^2) lambda reductions at runtime
16:34:24 <hpc> that's a really specific tumblr
16:34:55 <RyanGlScott> That's Tumblr™
16:35:04 <hpc> #hashtag-tumblr
16:42:19 <coderook> Haskell is a computer lang? like C?
16:42:29 <Clint> you could say that
16:42:54 <Zekka|Sigfig> (because it’s true)
16:42:55 <coderook> ok? how could i say it better then
16:43:16 <Zekka|Sigfig> Haskell isn’t a very close relative of C so a lot ofp eople don’t like the comparison
16:44:52 <coderook> What exactly is the difference between each lang? is it just like a "What i like better thing?" Im currently learning Golang as my first lang...I just thought i would ask
16:46:58 <Zekka|Sigfig> coderook: It’s partially personal preference, but it comes down to what they were designed for
16:47:25 <Zekka|Sigfig> C has a lot of features that the developers of Haskell thought weren’t useful, or too hard to use correctly
16:48:20 <Zekka|Sigfig> Haskell has several features that make the language a little more complicated in ways the developers of C didn’t think were important — but Haskell programmers think those features are very helpful to making sure programs are correct
16:48:26 <Zekka|Sigfig> (that’s not *all* the difference, but that’s a big part of it)
16:49:38 <Zekka|Sigfig> Haskell also has some convenience features that C doesn’t have, which the authors of Haskell thought would make it a lot easier to write short programs
16:50:02 <Zekka|Sigfig> There’s names for a lot of these tradeoffs
16:50:29 <Zekka|Sigfig> People say Haskell, unlike C, has parametric typing, for instance: parametric typing is one of those correctness features that the C guys didn’t want
16:51:22 <Zekka|Sigfig> it also has automatic memory management instead of manual memory management, which is also a correctness feature — but it comes with a performance tradeoff
16:52:00 <Zekka|Sigfig> (it’s much easier to guarantee that a C program uses only a certain amount of memory)
16:52:52 <dolio> I don't know about that.
16:53:07 <Zekka|Sigfig> dolio: Well, it’s easier to guarantee that about *certain* C programs
16:54:31 <unit73e_> hey
16:54:31 <Zekka|Sigfig> if you write a program that creates and throws away a lot of intermediate data structures in C, you will be able to be pretty sure those intermediate data structures go away before the next one comes into existence
16:54:32 <tr3> dolio: usually you know when you free() memory in C
16:54:35 <Zekka|Sigfig> you might not be as sure about that in Haskell
16:54:43 * hackagebot hspec-snap 0.4.0.1 - A library for testing with Hspec and the Snap Web Framework  https://hackage.haskell.org/package/hspec-snap-0.4.0.1 (DanielPatterson)
16:54:52 <tr3> dolio: as I usually say: nev... Segmentation Fault
16:55:29 <dysinger> anyone in here using spacemacs w/ stack & flycheck? I'm getting an error everytime I save about exiting with a 1 and no output
16:55:48 <unit73e_> I noticed emacs tabs indent haskell quite nicelly. Does vim have an equivalent to emacs tabs?
17:03:59 <greg`> hello , im using scapel but am unsure on how to create a selector that matches on a tags text, rather than its attributes
17:04:44 <xyzabc> http://goo.gl/Vj7Eep
17:05:39 <greg`> is that supposed to crash safari?
17:11:15 <int-e> lopex: I added #scala.pl to lambdabot's channel list
17:14:25 <lopex> int-e: thank you!
17:44:57 * hackagebot language-javascript 0.6.0.3 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.3 (ErikDeCastroLopo)
18:03:17 <Axman6> 22
18:03:19 <Axman6> whoops
18:03:22 * Clint nods.
18:05:06 * hackagebot hsebaysdk 0.3.1.0 - Haskell eBay SDK  https://hackage.haskell.org/package/hsebaysdk-0.3.1.0 (ChristopherReichert)
18:09:53 <lethjakman> Has anyone tried any of the web frameworks on a pi?
18:10:16 <lethjakman> I'm wondering how you'd do something like flash an LED from a web command. 
18:53:10 <nak> how is liftA2 different than liftM2 ?
18:53:35 <nak> can we demonstrate with an example ?
18:53:56 <geekosaur> it's more general. best to think of liftM2 as historical artifact
18:54:35 <nak> > liftA2 (+) (Just 1) (Just 4)
18:54:37 <lambdabot>  Just 5
18:54:50 <nak> > liftM2 (+) (Just 1) (Just 4)
18:54:52 <lambdabot>  Just 5
18:55:16 <nak> geekosaur sooo... are they the same thing or no ?
18:55:20 <jle`> nak: the Monad laws dictate that liftM2 and liftA2 should always produce the same result
18:55:27 <jle`> or maybe it's the Applicative laws
18:55:35 <jle`> hm yeah, i think it's an Applicative law
18:55:46 <geekosaur> (liftM2 is liftA2 from a time when Applicative didn't exist and Functor was not a prerequisite for Monad, so liftM reinvents fmap using only Monad interfaces and liftM2 and ap "invent" Applicative using only those
18:56:13 <nak> ok so there's some side learning there for me
18:56:19 <jle`> you should be able to use liftA2 wherever you'd use liftM2 and get the same result, it's actually a direct applicative law application
18:56:21 <nak> a Monad *must* be a Functor, yes?
18:56:24 <jle`> liftM2 really only exists for historical reasons
18:56:26 <nak> but a Functor does not have to be a Monad
18:56:26 <geekosaur> now, yes
18:56:45 <geekosaur> but before ghc 7.10 it was not necessary for a Monad to be declared as a Functor
18:56:47 <jle`> yes, there are bunches of functors that aren't monads
18:56:56 <jle`> in common everyday usage too
18:57:03 <nak> jle` just fling one at me
18:57:14 <jle`> Map
18:57:20 <jle`> Const k
18:57:24 <jle`> ZipList
18:57:33 <nak> got it
18:57:34 <nak> ok makes sense
18:58:05 <jle`> liftM2 at this point is 100% a historical accident, i believe
18:58:11 <geekosaur> yep
18:59:52 <nak> @src liftM2
18:59:52 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:59:55 <nak> @src lifttA2
18:59:56 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:00:03 <nak> @src liftA2
19:00:03 <lambdabot> liftA2 f a b = f <$> a <*> b
19:00:12 <nak> can we dissect these a little bit
19:00:23 <nak> i'm not very good at this kind of thing
19:00:28 <nak> x1 <- m1
19:00:33 <nak> that's even foreign to me
19:00:48 <geekosaur> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:00:48 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
19:00:53 <geekosaur> although that may not be much better
19:00:58 <jle`> are you familiar with do notation?
19:01:25 <nak> ah ok so <- is bind
19:01:43 <nak> but wait
19:01:46 <nak> m1 and m2 are  monads ?
19:01:54 <geekosaur> monadic actions
19:02:03 <geekosaur> a monad is a type, not a value
19:02:09 <jle`> they're m1 ::  m a, m2 :: m b
19:03:41 <nak> ok so m1 >>= \x1 ->
19:03:55 <nak> that is like "unboxing" the monad and inserting the value in as x1 in this lambda
19:04:10 <jle`> not really
19:04:20 <jle`> hm
19:04:27 <nak> @src >>=
19:04:27 <lambdabot> Source not found. My mind is going. I can feel it.
19:04:49 <geekosaur> it's "executing" a monadic action, for whatever "executing" means in that monad. (this may only be conceptual execution)
19:05:09 <jle`> it's sequencing m1 and m2, and calling their results x1 and x2; the final result is (f x1 x2), f applied to the results
19:05:23 <carlwi> and it may also be literal execution, as in the hitler monad
19:05:27 <nak> > (Just 1) >>= \x1 -> (Just 2) >>= \x2 -> return (x1 + x2)
19:05:29 <lambdabot>  Just 3
19:05:33 <nak> ok
19:05:34 <nak> ya
19:05:35 <nak> gotcha
19:05:43 <nak> @src liftA2
19:05:43 <lambdabot> liftA2 f a b = f <$> a <*> b
19:05:48 <geekosaur> note that even in IO it does not mean actual execution, just scheduling it for execution at some point *if* the resulting computation is ever scheduled
19:05:48 <nak> this is like ... way weirder to me
19:06:36 <geekosaur> (otherwise "if bla then action1 else action2" would always execute both actions)
19:06:36 <nak> <$> and <*>
19:07:02 <jle`> `f <*> x` sequences f and x, and the result is the result of f applied to the result of x
19:07:26 <jle`> `f <$> x <*> y` sort of is read as, sequence x and y, and the rsult is f applied to the results of x and y
19:07:45 <geekosaur> <$> is just infix fmap
19:07:51 <nak> oooooo
19:08:04 <nak> ok that helps a lot
19:08:08 <nak> is <*> infix anything ?
19:08:15 <Welkin> yes
19:08:16 * nak guesses....
19:08:18 <Welkin> it is `ap`
19:08:19 <jle`> it's (f <$> x) <*> y
19:08:30 <carlwi> :t (<*>)
19:08:30 <nak> `ap` aww snap
19:08:32 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:08:52 <Welkin> https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:ap
19:09:07 <carlwi> so it takes a function buried inside an Applicative context, and calls it with an argument inside an Applicative context
19:09:10 <nak> ok yeah, looking at liftA2, i like that much better than liftM2
19:09:30 <nak> fmap and ap makes more sense to me
19:09:30 <EvanR> in f <*> x no results are being applied necessarily
19:09:31 <carlwi> the reason why it was buried inside applicative was because you didn't apply all the arguments to it with fmap (or <$>)
19:09:44 <geekosaur> I said earlier that liftM2 was "inventing" Applicatives before they existed; that's how. ap is the generalization of liftM2, liftM3, etc. which can be done as foo `liftM` bar `ap` baz ...
19:09:46 <nak> but i suppose i should be more familiar with the <- =<< and >>= too
19:09:49 <EvanR> f <*> x is just "applicative application", the f is being applied (applicatively)
19:09:58 <geekosaur> so we infix-ed them in Applicative to begin with
19:10:11 <nak> geekosaur yeah that makes more sense now thank you
19:10:14 <Welkin> (<-) is just syntax sugar
19:10:15 <jle`> EvanR: in f <*> x, the result of f is applied to the result of x
19:10:19 <EvanR> no
19:10:26 <Welkin> you only need to know about >>=
19:10:40 <Welkin> >> is just >>= where the first parameter is ignored
19:10:43 <jle`> well, the result is the result of f applied to the result of x
19:10:50 <EvanR> no
19:11:01 <nak> Welkin ">> is just >>= where the first parameter is ignored"
19:11:02 <carlwi> EvanR explain
19:11:03 <EvanR> what is "the result" of f ?
19:11:08 <nak> Welkin  i've never seen ">>"
19:11:09 <carlwi> a function
19:11:12 <EvanR> no
19:11:13 <nak> Welkin can you show me a use of it ?
19:11:25 <carlwi> EvanR yes 
19:11:29 <EvanR> youre thinking of a specific applicative, such as IO
19:11:31 <jle`> f :: f (a -> b), x :: f a
19:11:44 <carlwi> nope. it works with any applicative
19:11:47 <EvanR> theres not necessarily any function a -> b involved
19:12:04 <carlwi> :t (<*>)
19:12:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:12:07 <jle`> yeah, i clarified a bit; the result is the result of f applied to the result of x
19:12:18 <jle`> so if a result exists, it would be the result of f applied to the result of x
19:12:18 <EvanR> theres not necessarily any result of f
19:12:20 <carlwi> how, when first argument is f (a -> b)?
19:12:27 <EvanR> f is just a data structure
19:12:36 <jle`> there is not necessarily a result, but if there is a result, it's the result of f applied to the result of x
19:12:40 <jle`> or result(s)
19:12:46 <EvanR> theres always a result of f <*> x
19:12:56 <carlwi> if the result is nothing (as in the Maybe applicative), then there's no f, and nothing is applied to anything. is that what you meant?
19:12:58 <nak> :t liftA2
19:13:00 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:13:02 <nak> ok that really helps too
19:13:04 <EvanR> but each component isnt producing results like IO actions
19:13:28 <EvanR> this is thinking of specific instances only
19:13:58 <jle`> by 'result', i'm somehwat informally referring to the abstract 'b' in (f b)
19:14:19 <jle`> so in whatever sense you interpret the b to be, it's the same sense you interpret the (a -> b) and the a in f (a -> b) and f a
19:14:24 <EvanR> for example in the data Two a = Two a a applicative, when you do Two (+1) (-1) <*> Two 0 0, what is "the result" that is being applied?
19:14:50 <EvanR> if "the result" is Two (+1) (-1) then what is it the result of?
19:15:08 * hackagebot octane 0.4.8 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.8 (fozworth)
19:15:13 <EvanR> i would prefer not to call Two (+1) (-1) a result
19:15:16 <carlwi> 0 is being applied to (negate 1)
19:15:23 <jle`> Two (+1) (-1) isn't the result
19:15:43 <jle`> the result is the interpretation of the 'b' in (f b)
19:15:45 <EvanR> what is the result of f and the result of x ?
19:15:58 <nak> i'm sorry i didn't mean to spur an argument :\
19:16:07 <EvanR> more like Two (+1) (-1) is being applied to Two 0 0
19:16:15 <nak> > (fmap (+) (Just 1)) `ap` (Just 2)
19:16:17 <lambdabot>  Just 3
19:16:21 <nak> sweeeet
19:16:26 <EvanR> (i mean subtract 1)
19:16:28 <nak> ok that is very obvious to me what is happening
19:16:54 <nak> it's cool to think about a Functor holding a partially applied function
19:17:17 <EvanR> its not necessarily holding a function either
19:17:32 <EvanR> even though it is in the case of Two
19:17:33 <nak> > fmap (+) (Just 1)
19:17:35 <lambdabot>  Just <Integer -> Integer>
19:17:38 <EvanR> and Maybe
19:17:42 <nak> EvanR how is that not holding a function ?
19:17:49 <jle`> yeah, lots of Functor instances don't "hold functions"
19:17:53 <jle`> for an f (a -> b)
19:18:07 <jle`> but specific functor instances (like Maybe) can potentially hold partially applied functions
19:19:11 <nak> ok let's see about
19:19:15 <nak> > fmap (+) [1,2,3]
19:19:18 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
19:19:55 <nak> > (fmap (+) [1,2,3]) `ap` [10,100,1000]
19:19:58 <lambdabot>  [11,101,1001,12,102,1002,13,103,1003]
19:19:58 <EvanR> List is just a longer Maybe
19:20:01 <nak> whoa
19:20:18 <jle`> nak: Const k (a -> b) doesn't hold any functions, (++) <$> getLine doesn't hold any functions :)
19:20:31 <EvanR> but the applicative is more involved than just zipping
19:20:33 <nak> ok
19:20:34 <nak> i'm a noob
19:20:40 <nak> so yeah i don't have awareness of all those things
19:20:40 <jle`> we are all noobs :D
19:20:44 <nak> nah lol
19:20:49 <nak> you guys are way more advanced than me
19:20:52 <nak> side question
19:21:00 <nak> someone tlaked about the built-up computational chain on IO
19:21:05 <nak> when you fmap or bind it doesn't actually execute
19:21:17 <nak> how do you actually execute an IO
19:21:26 <jle`> you can't execute an IO action within Haskell
19:21:37 <jle`> you can compile one with 'ghc', and your computer can execute it
19:21:53 <jle`> cause your computer/CPU has access to IO stuff needed to execute an IO action
19:22:01 <nak> i see
19:22:02 <carlwi> result of (++) <$> getLine a function though (provided it doesn't fail). so how is it different than Maybe in this regard? apart from the usual differences between Maybe and IO
19:22:05 <Adeon> you need to make that IO action be bound together with one run from main :: IO ()
19:22:18 <Adeon> difficult to explain
19:22:18 <carlwi> :t (++) <$> getLine
19:22:19 <lambdabot> IO ([Char] -> [Char])
19:22:20 <jle`> carlwi: `(++) <$> getLine`, the dat structure itself, doesn't 'contain' any functions
19:22:21 <Adeon> it gets philosophical
19:22:23 <kadoban> nak: You set   main = <your IO action>   and then run the program however
19:22:25 <nak> Adeon yeah it kinda makes sense
19:22:31 <jle`> *data
19:22:41 <nak> this is for the sake of functional purity i assume
19:22:44 <jle`> just like the dat structure "getLine" doesn't contain any strings
19:22:46 <klkdf> hi all
19:22:49 <carlwi> jle`, the result of executing that action is a function. just like the result of "executing" a maybe action
19:22:57 <dmj`> @typ (++) <$> getLine <*> getLine
19:22:58 <lambdabot> IO [Char]
19:23:03 <jle`> carlwi: yeah, but (++) <$> getLine itself doesn't contain any functions
19:23:04 <klkdf> are there any good tutorials for building projects w/ C/C++ FFI using stack?
19:23:40 <jle`> in contract, [succ, pred] actualy contains actual functions
19:24:03 <EvanR> Adeon nak no, nothing philosophical about it. IO is just an abstract data type. You can't look in it, you can just build them and then give it to the runtime system
19:24:46 <mgsloan> klkdf: It's pretty much identical to doing that with cabal, so you can use tutorials that don't mention stack.
19:24:47 <EvanR> nak: since IO actions are normal first class values, this opens up a lot of convenient ways to manage IO
19:25:08 <EvanR> you can put them in data structures, send them through channels (if you want), hide them in closures
19:25:09 <mgsloan> The only stack specific stuff might be that you can use docker or nix to manage your C dependencies
19:25:11 <carlwi> jle in a way it does. (++) is contained, and it is just waiting for getLine to execute to plug in the string
19:25:31 <klkdf> mgsloan I'm running into undefined symbol errors
19:25:34 <mgsloan> And also that stack.yaml has an extra-lib-dirs field, which might also be necessary for such external deps
19:25:43 <jle`> nak: haskell is about describing IO actions using pure functions.  then you can give it to a computer or a web browser or a whatever, and that thing can execute the action you describe
19:25:48 <mgsloan> klkdf: Searching the stack issue tracker might be informative
19:25:58 <klkdf> mgsloan where are the .o files supposed to go so that stack build finds them?
19:25:59 <mgsloan> Unfortunately, C FFI is not my strong suit
19:26:17 <mgsloan> Well, GHC will build your C sources for you and put them in the right spot
19:26:25 <jle`> carlwi: sure, the (++) is stored, but not the (String -> String) suggested by IO (String -> String)
19:26:28 <mgsloan> (by invoking gcc)
19:26:47 <klkdf> mgsloan just with stack build?
19:26:51 <mgsloan> Yup
19:27:14 <klkdf> i'm using stack build and it doesn't seem to be figuring out the C dependency
19:27:27 <klkdf> I can compile the .c file manually to .o no problem
19:27:34 <mgsloan> "stack path --dist-dir" might be helpful.  All the build results go in the "build" subdir of that folder
19:27:38 <klkdf> but stack build gives me an undefined symbol error for the ffi calls
19:28:05 <mgsloan> Do you have it listed in your "c-sources" field in your cabal file?
19:28:30 <klkdf> nope... let me try adding that
19:28:46 <nak> jle` EvanR interesting, thank you
19:28:50 <mgsloan> Well yes, if you don't tell it to build your C code it won't build your C code ^_^
19:29:18 <jle`> np!
19:29:24 <jle`> thank you for the discussion
19:29:30 <EvanR> the IO type is a convenient replacement for impurity + lambdas
19:29:34 <nak> jle` yeah you guys are always really helpful
19:29:38 <EvanR> way nicer 
19:29:54 <nak> is there something like IO in racket ?
19:29:57 <nak> or scheme ?
19:30:06 <EvanR> you can make one
19:30:14 <EvanR> using lambda wrappers
19:30:26 <EvanR> but it wont amount to much type safety since you can still do IO other ways
19:30:59 <klkdf> mgsloan sweet it works
19:31:27 <EvanR> (IO is actually a replacement for an older oddball I/O system haskell had... the lazy I/O streams)
19:31:33 <klkdf> now let's see if i can get it to work with some real C libraries and not this rinky dink hello world stuff
19:33:40 <carlwi> nak I think this article does a good job explaining the argument why IO monad is pure. it implements an IO-like monad that just builds a tree structure when use >>= or do. http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
19:33:52 <carlwi> when you use*
19:34:35 <nak> carlwi i'll check it out in a sec, thank you :)
19:35:18 <EvanR> it would be interesting to go beyond a custom IO ADT and try to implement the runner for such a thing in pure haskell ;)
19:35:47 <EvanR> which includes timing issues, concurrency, and is faithful to some non trivial semantics
19:46:10 <klkdf> oh man
19:46:30 <klkdf> C FFI for the gnu science library works!
19:46:33 <klkdf> woohoo
19:48:32 <klkdf> hmm stack build doesn't seem clever enough to rebuild .c files if they've been touched
19:51:02 <mgsloan> klkdf: If "--force-dirty" fixes the issue, then it's a stack problem.  If not, then it's a cabal / ghc issue
19:52:50 <klkdf> mgsloan would --force-dirty rebuild the whole project though?
19:53:12 <mgsloan> No.  It just forces stack to think that the package is dirty
19:53:35 <mgsloan> It doesn't force GHC to recompile everything.  That's "--ghc-options -fforce-recomp"
19:54:27 <klkdf> mgsloan --force-dirty isn't a stack argument, where do i put that?
19:55:05 <kadoban> klkdf: Use it with whatever stack build or stack install command you're doing was probably the intent.
19:55:39 <kadoban> stack build --force-dirty     for example
20:00:12 <klkdf> whoo marshalling data to GSL
20:00:29 <klkdf> this is great :D
20:01:04 <klkdf> hmm now stack seems to be recognizing changes "unregistering (local file changes: app/foo.c)"
20:01:48 <klkdf> does the current version of the C FFI no longer need .h files?
20:02:06 <klkdf> haskell seems to figure out the interface from the .c file alone, or is that my imagination?
20:07:39 <klkdf> yup doesn't seem to need .h files
20:08:25 <kadoban> .h files aren't really a hard requirement in C, at least not always. So that's not surprising to me.
20:08:57 <kadoban> They're only needed when you structure you code a certain (normal) way.
20:42:02 <EvanR> just realized there is Numeric.Natural
20:42:15 <EvanR> which ive never seen used ever
20:42:41 <EvanR> peopl are usually only inerested in Nats on the type level
20:43:06 <Axman6> There has been discussion of adding GMP's unsigned integer type
20:47:22 <jle`> it'd be nice if Numeric.Natural was more common, but it came really recently, with no fanfare or announcement really
20:47:26 <jle`> and it has a partial Num instance
20:47:28 <jle`> so like, what even
20:48:11 <EvanR> oh
20:48:29 <EvanR> well Num is prone to being partial for being too many things
20:48:49 <jle`> the numeric typeclass hierarchy is a bit unsuited for something like Natural i think
20:49:40 <jle`> *in haskell
20:50:01 <EvanR> just dont use subtraction :)
20:50:50 <EvanR> (without a proof of greater thanness)
20:51:01 <jle`> and use only Nat-monomorphic subtraction? maybe, but it still is a bit of friction
20:51:11 <jle`> it'd be nice if Nat was Natural
20:51:20 <jle`> so DataKinds and singletons stuff would work cleanly
20:51:24 <jle`> that would be the dream
20:53:23 <jle`> right now something like `data Foo = Foo Bool` works with DataKinds in a nice way
20:53:38 <jle`> `data Foo = Foo Nat Bool` works only at the type level
20:53:46 <jle`> `data Foo = Foo Natural Bool` works only at the value leve
20:54:04 <jle`> it'd be nice of we could write one `data Foo = Foo Natural Bool` that works at both the value and type level with literals
20:54:52 <EvanR> you could have Natural which is algebraic normally but secrely implemented as GMP on the value level
20:55:11 <EvanR> but i dont know how common that is to do inside GHC, i always get the feel everything is above board
20:55:12 * hackagebot egison 3.6.0 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.6.0 (SatoshiEgi)
20:55:19 <EvanR> like data Bool = True | False, nothing up my sleeve
20:55:45 <jle`> Nat already works nicely, the type-level Nat arithmetic is done with the same mechanisms as with Integer
20:55:57 <EvanR> orly
20:56:07 <jle`> so type-level Nat arithmetic is basically implemented with Integer I believe
20:59:41 <EvanR> egison looks interesting
21:00:12 * hackagebot octane 0.4.9 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.9 (fozworth)
21:00:14 * hackagebot postgrest 0.2.11.0 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.2.11.0 (begriffs)
21:10:43 * hackagebot postgrest 0.2.12.0 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.2.12.0 (begriffs)
21:10:45 * hackagebot postgrest 0.2.12.1 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.2.12.1 (begriffs)
21:10:47 * hackagebot postgrest 0.3.0.1 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.3.0.1 (begriffs)
21:10:49 * hackagebot postgrest 0.3.0.3 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.3.0.3 (begriffs)
21:10:51 * hackagebot postgrest 0.3.0.4 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.3.0.4 (begriffs)
21:15:53 * hackagebot postgrest 0.3.1.0 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.3.1.0 (begriffs)
21:37:06 <EvanR> http://www.mail-archive.com/haskell@haskell.org/msg03721.html interesting historical blurb about non-linear pattern matching and an aside about discussion of an ancient class called MonadZero
22:05:25 <lazyWriter> where can I read about let vs where ?
22:05:32 <lazyWriter> I used to use let all the time, but I'm starting to like hwere
22:05:39 <lazyWriter> I want to read more about let vs where
22:06:26 <jle`> lazyWriter: 'let ... in ...' is an expression
22:06:31 <jle`> and can be used wherever expressions are expected
22:06:38 <jle`> where can only be used with declarations, and is a part of declaration syntax
22:07:04 <jle`> the haskell report gives a nice concise explanation :)
22:07:35 <jle`> lazyWriter: foo = ... is a declaration, so you can do foo = ... where ...
22:07:53 <jle`> "5 + 6" is an expression, so "let x = 5 in x + 6" works too
22:25:09 <eyepatch> I'm getting a strange runtime error that I can't figure out. It says that head is encountering an empty list, but the list I pass in isn't empty, and it doesn't change. http://ideone.com/ucAn7U
22:25:51 <Gurkenglas> It sure is empty
22:25:55 <Gurkenglas> > [5..1]
22:25:57 <lambdabot>  []
22:26:08 <eyepatch> oops. I see it.
22:31:02 <manju> is there any good MOOC to start learning Haskell?
22:31:59 <bollu> hey guys
22:32:47 <bollu> so if I'm writing a library, and I want some operators (say .+) or something to be something like .+ :: a -> a -> a, AND .+ :: Int -> a -> a, AND .+ :: a -> Int -> a
22:32:50 <bollu> what's my best bet?
22:33:12 <bollu> I basically want to overload the operator to work on both my custom type and interop with Haskell's number types
22:33:29 <bollu> I'm writing a FFI for sympy, that needs to allow you to easily create equations and studd
22:33:35 <bollu> stuff*
22:33:48 <bollu> so I'd like to do things like: do x <- newVariable("x") return x + 100
22:34:02 <bollu> so my operator (+) needs to be able to interop with both types
22:34:05 <bollu> any ideas?
22:36:12 <Gurkenglas> Sounds like what IsString is doing
22:36:52 <bollu> what do you mean?
22:38:35 <EvanR> bollu: in the end, what are all the things you want .+ to do, "anything" doesnt count
22:39:27 <EvanR> a a a, Int a a, a Int a, Int Int a, Int a Int, a Int Int, and Int Int Int ? ... and a a Int?
22:39:55 <EvanR> are you sure you dont want to just use Int
22:40:16 <EvanR> and is a "any type" or is it some type in your library
22:53:12 <bollu> EvanR: not any type
22:53:17 <bollu> EvanR: just the type "symbol"
22:53:22 <bollu> and similar ones
22:53:53 <EvanR> maybe you want to define a small universe of types including Int and "symbol" and .+ works on this type
22:54:07 <bollu> I guess the exact type I'm looking for would be (.+) :: (a | Int) -> (a | Int) -> 
22:54:19 <EvanR> well, what is a
22:54:28 <EvanR> and what is on the right hand side of the last ->
22:54:30 <bollu> crap, I meant symbol
22:54:46 <bollu> (.+) :: (Symbol | Int) -> (Symbol | Int) -> Symbol
22:54:56 <bollu> let's exclude Int -> Int -> Symbol for now?
22:55:09 <EvanR> so
22:55:20 <EvanR> .+ :: Symbol -> Int -> Symbol
22:55:25 <EvanR> +. :: Int -> Symbol -> Symbol
22:55:32 <bollu> yes
22:55:37 <EvanR> there you go
22:55:42 <bollu> ah
22:55:47 <bollu> I see
22:55:54 <bollu> hmm, thanks.
22:55:59 <bollu> But that's a little more clunky than what I had in ind
22:56:00 <bollu> mind*
22:56:07 <bollu> I was hoping for just one operator
22:56:23 <bollu> I don't think that's possible though?
22:56:23 <EvanR> it sort of is, and has better safety
22:56:37 <bollu> how?
22:56:37 <EvanR> now the checker will tell you if you put the args in the wrong order
22:56:42 <bollu> oh that way
22:56:57 <bollu> EvanR: what if I want only one operator? is there any way to construct that?
22:57:16 <EvanR> data MyU = S Symbol | I Int
22:57:25 <EvanR> + :: MyU -> MyU -> Symbol
22:57:48 <bollu> EvanR: now the problem is that I can't do 5 + s, right? my 5 would first need to be promoted to I 5
22:58:02 <bollu> ditto with my s :: Symbol, it would have to be promoted to s S
22:58:16 <bollu> is there any way to make the "promotion" automatic?
22:58:33 <Gurkenglas> class PointPlus a b where (.+) :: a -> b -> Symbol; instance PointPlus Symbol Symbol where <...>; instance PointPlus Symbol Int where <...>; instance PointPlus Int Symbol where <...>
22:58:48 <EvanR> multiparameter type class
22:59:27 <EvanR> im not sure if youll need functional dependencies
22:59:29 <jle`> you can give MyU a Num instance so '5' is parsed as "I 5", perhaps
22:59:47 <EvanR> ah i didnt take that seriously when i thought of it
23:00:02 <EvanR> without more context on what this library is supposed to do, its kind of hard to give any good ideas
23:01:03 <EvanR> (also the IsString class could turn a string literal into a Symbol)
23:01:33 <EvanR> and then theres quasiquoters!
23:01:55 <bollu> the library is a FFI bridge for symbolic computation
23:02:05 <bollu> (symEngine bindings to Haskell))
23:02:20 <EvanR> is that system typed at all?
23:02:27 <EvanR> or is it just a big expression tree
23:02:35 <bollu> EvanR: it has a weak notion of types, yes
23:03:04 <EvanR> so you might want to start by encoding that into a haskell type
23:03:24 <EvanR> then .+ or whatever operates on that
23:03:49 <EvanR> GADTs let you specify extra constraints on expression languages
23:06:13 <bollu> hm, I see
23:08:18 <EvanR> and or give your type a Num instance 
23:12:11 <bollu> EvanR: would a num instance let it interact with Int?
23:12:14 <bollu> :info Num
23:12:25 <EvanR> it would let you write number literals
23:15:00 <EvanR> which is technically "interacting with Integer"
23:15:50 <EvanR> Fractional would let you do the same for Rational expressions like 3.14
23:16:19 <EvanR> > 355 % 113
23:16:21 <lambdabot>  355 % 113
23:16:32 <EvanR> > realToFrac $ 355 % 113
23:16:34 <lambdabot>  3.1415929203539825
23:16:53 <EvanR> god these names are so weird
23:18:18 <ggVGc> I keep having namespace issues with record field :(
23:18:24 <ggVGc> I feel I'm using haskell wrong
23:18:51 <EvanR> gotta keep em separated
23:19:25 <ggVGc> EvanR: I mean I keep having issues where a record might want the field "length" but that clashes with "length" for List etc.
23:19:40 <dmwit> lool`: yes, and for good reason
23:19:43 <EvanR> naming things the same as Prelude names is a recipe for disaster
23:19:47 <ggVGc> right
23:19:52 <ggVGc> but it's annoying
23:20:10 <dmwit> lool`: you will need to use the knownnat instance
23:20:16 <ggVGc> I always end up going data Foo=Foo{fooLength :: Int} and similar
23:20:19 <ggVGc> but it doesn't feel good
23:20:26 <EvanR> its funny that we have a mechanism to write fmap fmap fmap . fmap fmap, but no one really wants to write that
23:20:40 <EvanR> but record field names...
23:21:02 <dmwit> lool`: to get a gadt that reifies the typelevel info about 0 or k+1 cases
23:21:18 <ggVGc> I don't really know how a better record implementation would look though
23:21:20 <EvanR> ggVGc: uwot
23:21:28 <EvanR> oh, naming it with a prefix
23:21:37 <ggVGc> removing some of the current issues of haskells records comes with other tradeoffs
23:21:44 <jle`> purescript utilizes an interesting approach
23:21:57 <jle`> but there are also overloaded record fields extensions being vetted for inclusion in soon-to-come ghc versions
23:22:09 <EvanR> idris auto namespaces fields, so youd put Foo.length everywhere (also it doesnt have a real module system)
23:22:24 <ggVGc> EvanR: yeah, but that's also not so cool
23:22:35 <EvanR> at least you didnt name it fooLength
23:22:49 <jle`> purescript has values that are actual objects, like { length: 10, name: "hello" }
23:23:10 <EvanR> er, it has row types you mean?
23:23:39 <EvanR> (proper record types)
23:23:52 <jle`> er, yeah
23:24:00 <ggVGc> why doesn't EvanR fix every programming issue I have?
23:24:02 <ggVGc> he;'s a bad friend
23:24:20 * EvanR fixes ggVGc's perception of `issue'
23:24:25 <ggVGc> cheers
23:24:27 <jle`> "author = { name: "Phil", interests: ["Functional Programming", "JavaScript"] }"; so :t author => { name :: String, interests :: [String] }
23:24:46 <ggVGc> is that essentially structural typing?
23:24:50 <ggVGc> like Ocaml?
23:25:05 <jle`> so to jump back and forth between haskell, you'd get newtype Foo = Foo { name :: String, interests :: [String] }
23:25:13 <ggVGc> I've asked before why haskell doesn't have structural typing, and there are apparently good reasons
23:25:14 <EvanR> i call it record types
23:25:23 <jle`> but the records are extensible, you can only specify parts of constraints
23:25:49 <EvanR> if you add row polymorphism then you can talk about the type of forgetting or adding fields
23:25:52 <jle`> for example, if you want to take something that only requires a name, you can do foo :: { name :: String | otherStuff } -> ...
23:26:07 <ggVGc> right, that's like in OCaml afaik
23:26:10 <ggVGc> or at least F#
23:26:12 <ggVGc> I quite liked that
23:26:12 <EvanR> yes
23:26:35 <EvanR> regular haskell's type system is actually pretty simple ;)
23:27:23 <EvanR> there is a library called vinyl which pulls out the "Haskell2" shenanigans for extensible records, you might want to check it out if youre really having a hard time
23:27:43 <EvanR> but i havent done anything where thats really worth it
23:28:31 <jle`> the proposed overloaded record fields extension does it with something similar to typeclasses, i think
23:28:34 <ggVGc> nah, it's not that much hassle. I just feel I'm using haskell wrong because I shouldn't end up in naming problems as much as I do
23:28:39 <ggVGc> well, that's the feeling at least
23:28:51 <EvanR> you can also "give up" and define data Shrug a = O (HashMap Text (Shrug a)) | A (Vector (Shrug a)) | D a
23:29:46 <EvanR> ggVGc: true, naming is tricky when theres a culture already here for doing a certain class of things with a lot of short namespaceless names
23:29:57 <EvanR> a problem you dont have in Java
23:36:46 <dmwit> Modules are a bit like namespaces.
23:37:17 <dmwit> Side question: does row polymorphism imply having something like `foo :: { name :: Not Defined } -> ...`?
23:37:53 <EvanR> uhg i hope not
23:37:59 <dmwit> Why not?
23:38:05 <EvanR> thats = not having the name field
23:38:13 <dmwit> no
23:38:52 <dmwit> I would want `{ name :: String } subtypeOf {}` but not `{ name :: String } subtypeOf { name DoesNotExist }`.
23:39:03 <EvanR> if you could have no field, field but no value, field with a value that is _|_, field with a value that is Nothing, that seems even more insane than usual
23:39:50 <dmwit> I don't want "field X exists but has no value". I want "field X does not exist", as opposed to "does not require field X".
23:39:52 <EvanR> and what *is* a subtype of {name DoesNotExist} ?
23:40:28 <EvanR> are you talking about complement type?
23:41:14 <dmwit> Ah. You are pointing out that I want these things to live in the contsraint language rather than the type language. I agree.
23:41:53 <EvanR> it might make sense if you have set theoretic subtyping going on
23:41:56 <EvanR> but
23:42:03 <dmwit> So I'm imagining you would have something like `forall x. { name :: String } < x => x -> ...` to say "I can take any type of record as long as it's got a `name`".
23:42:45 <dmwit> And what I'm asking is whether you would also have something like `forall x. NotIn name x => x -> ...` to say "I can take any type of record as long as it doesn't mention `name`".
23:43:33 <EvanR> do we typically have the ability to talk about Not stuff with constraints
23:43:38 <dmwit> no
23:44:04 <EvanR> you could compile code, and then invalidate it by add new record types in another module... maybe
23:44:09 <dmwit> Negative constraints strike me as something that would be quite hard (but perhaps easier if you have a fixed set of atomic "negatives").
23:45:01 <EvanR> or if you had a fixed universe of possible fields
23:45:41 <EvanR> like HTTP... nevermind X- headers
23:46:05 <dmwit> A fixed finite set, you mean?
23:46:26 <EvanR> that would definitely make it easier
23:46:54 <dmwit> But that's also very restrictive.
23:47:00 <EvanR> now whats the critical difference between a fixed finite set and the set of all (finite) strings
23:47:29 <dmwit> The critical difference is I can convert "doesn't have X" into a positive statement and still store the positive statement in memory.
23:47:32 <dmwit> Given enough memory.
23:47:47 <EvanR> the complement is finite or not... k
23:48:22 <EvanR> yep negative sucks
23:48:46 <EvanR> you can of course do anything you can prove with dependently typed records
