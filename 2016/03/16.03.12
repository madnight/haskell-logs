00:01:38 <pharpend> screw it, I'll mail an ML
00:03:29 <ontop> http://lpaste.net/4751780623192948736 -- Trying to implement State and it's Functor for practice. Can't understand 3
00:03:39 <ontop> What the heck does s refer to there? The entire function? The type of s?
00:03:50 <ontop> It's burning a hole in my brain.
00:03:54 <ontop> line 3*
00:04:09 <pharpend> ontop: s is the type of the state variable
00:04:31 <mauke> well, the result has to be a Super, so you can write 'Super (???)' instead of '???'
00:04:44 <pharpend> huh
00:04:47 <mauke> and Super takes a function, so ... = Super (\x -> ???)
00:04:57 <ontop> So, if I were to say: instance (Super s a), it'd be the type of both the state variable and the "value"?
00:05:14 <pharpend> the type of the value is a, the type of the state variable is s
00:05:24 <ontop> Okay.
00:05:25 <mauke> instance Functor (Super s a) would be a kind error
00:05:26 <pharpend> (the return value and the state variable are two separate things)
00:05:38 <pharpend> kind = quasi-type
00:05:43 <pharpend> not as in the error would be kind
00:05:47 <ontop> Ah. * -> * those things?
00:05:50 <pharpend> yes
00:05:50 <dmj`> ontop: The Super data constructor takes a function
00:05:59 <ontop> Yeah. I'm working on making that function
00:06:06 <ontop> Keep getting stuck because it says: THIS SHOULD BE TYPE s
00:06:12 <ontop> And I'm like: What the hell is type s!?
00:06:20 <ontop> Anyway, will continue to work.
00:06:21 <ontop> Thx
00:07:19 <mauke> well, so far we've got: fmap f (Super g) = Super (\x -> ???)
00:07:31 <mauke> for ??? we need to find an expression of type (b, s)
00:07:59 <ontop> Right, I think I have to feed g the state I get \x to massage out the value and the new state.
00:08:00 <mauke> and the variables we have are f :: a -> b; g :: s -> (a, s); x :: s
00:09:59 <ontop> Omg
00:10:01 <ontop> I did it
00:10:02 <ontop> I think...
00:10:05 <ontop> It hurts :(
00:11:16 <mauke> @djinn (a -> b) -> (s -> (a, s)) -> s -> (b, s)
00:11:17 <lambdabot> f a b c =
00:11:17 <lambdabot>     case b c of
00:11:17 <lambdabot>     (d, e) -> (a d, e)
00:11:39 <ontop> mauke: http://lpaste.net/4751780623192948736 ?
00:11:42 <ontop> Seems correct.
00:11:54 * ontop moves on to applicative.
00:12:01 <mauke> oldState is not a state, though
00:12:07 <mauke> s is the old state
00:12:45 <mauke> yeah, that looks right
00:12:53 <ontop> What.
00:13:00 <ontop> If oldState isn't a state, I'm really confused.
00:13:10 <mauke> oldState is a function
00:13:11 <ontop> It's a "State" isn't it? A state processor function.
00:13:22 <ontop> State is defined as a state processor afaik.
00:13:24 <mauke> yes
00:13:41 <mauke> but you've written (..., newState) = oldState s ...
00:13:59 <mauke> it's more like (..., newState) = process oldState
00:14:14 <mauke> namingwise
00:14:44 <ontop> Hmm.
00:14:46 * ontop thinks
00:15:40 <ontop> Welp, I just ruined my brain.
00:15:52 <mauke> it'll stop hurting tomorrow
00:16:06 <ontop> See, to me the oldState variable marks the oldStateProcessor
00:16:24 <ontop> And because that processes states, we apply that to the newStateProcessor to get a newerStateProcessor
00:16:25 <ontop> lol.
00:16:40 <mauke> huh?
00:16:51 <mauke> you have a state processor, g
00:16:55 <ontop> Yep.
00:16:58 <ontop> And s
00:17:00 <mauke> and an old state, s
00:17:10 <ontop> Oh. Hm.
00:17:11 <mauke> you apply g to s to get a new state (and a result on the side)
00:17:19 <ontop> I think I might be backwards on what's new and old.
00:17:38 <ontop> I thought that s was newer than the one being fmapped over.
00:17:52 <mauke> you're fmapping over a state processor, not a state
00:17:57 <ontop> Right.
00:18:18 <mauke> your whole fmap definition is building a new state processor
00:18:25 <ontop> Yea.
00:18:37 <ontop> Okay. I think I get what you're saying. And it makes sense.
00:18:41 <mauke> namely one that takes an old state, calls the old state processor (embedded within), then mangles the result of that
00:18:55 <mauke> those two "old"s are different
00:18:59 <mauke> bah, language is annoying
00:19:17 <ontop> Yea.
00:19:29 <ontop> That's what I was saying, there's sort of like two levels of new/oldness.
00:19:36 <ontop> Let me see if this makes more sense to you then
00:19:53 <ontop> http://lpaste.net/4751780623192948736
00:20:14 <mauke> yes, it does :-)
00:20:19 <ontop> Ok. Good. Now to try applicative.
00:28:33 <ontop> mauke: I feel dirty about this implementation. Something must be wrong: http://lpaste.net/4751780623192948736
00:28:40 <ontop> I'm throwing away a newState :(
00:29:29 <mauke> yeah, that's incorrect
00:29:38 <ontop> Hm.
00:29:46 <ontop> I have to think about what the hell applicative should do to state.
00:29:53 <ontop> Just in general
00:49:23 <ontop> mauke: My implementation does the same thing as the real implementation :(
00:49:36 <ontop> What am I doing wrong?
00:49:55 <ontop> http://lpaste.net/5414934349768294400
00:49:57 <ontop> f1 == f2
00:50:11 <ontop> Er, fn1 == fn2
00:51:24 <ontop> Hm.
00:51:29 <ontop> Maybe I'm supposed to chain the state transforming.
00:52:13 <Ongy> is there a way (ghc extension) to specify an instance of a class for a type (T a) and a more spcialised version for (T T2)?
00:55:41 <Ongy> ok I can define them with FlexibleInstances, but wehn I want to use it I get an error about overlaping instances
00:55:54 <Ongy> adding a type annotation doesn't help though
00:58:14 <lyxia> Ongy: You need overlapping instances it's described somewhere in the ghc manual
00:58:41 * hackagebot twitter-types 0.7.2 - Twitter JSON parser and types  https://hackage.haskell.org/package/twitter-types-0.7.2 (TakahiroHimura)
00:58:43 * hackagebot twitter-types-lens 0.7.2 - Twitter JSON types (lens powered)  https://hackage.haskell.org/package/twitter-types-lens-0.7.2 (TakahiroHimura)
00:58:48 <lyxia> Ongy: 7.6.3.5. Overlapping instances
01:03:12 <Ongy> lyxia: thank you
01:57:16 <CaptainCoward> so what are monads exactly? is it correct to say that a pure function is being applied to its output repeatedly by the impure environment that includes I/O and side effects?
01:58:49 <Ralith> a monad is a datatype associated with a handful of functions that satisfy some simple properties known as the monad laws
01:59:41 <mauke> CaptainCoward: that sounds sort of like IO but not really. and nothing like monads
02:01:06 <noteventime> A monad m is a functor such that it makes sense to compose arbitrary functions a -> m b and b -> m c into a -> m c 
02:01:07 <mniip> ah the usual thing where people think monads are IO, while it's actually the opposite
02:02:13 <CaptainCoward> I think I will stick with a language that just rhymes with haskell but is easier to understand
02:02:52 <mauke> what do you find hard about haskell?
02:04:13 <noteventime> Also, to quote Pynchon, “Why should things be easy to understand?” :)
02:04:22 * hackagebot chorale 0.1.1 - A module containing basic functions that the prelude does not offer  https://hackage.haskell.org/package/chorale-0.1.1 (FranzBenjaminMocnik)
02:04:31 <CaptainCoward> I tried OCaml more seriously than haskell. I found the main problem with it that it is too easy to introduce so much abstraction that the code no longer makes sense
02:12:10 <fsvehla> I’d need a hint on why parseTimeM with :: Maybe Day will return Nothing on unparsable dates but :: Either String Day will throw an exception.
02:12:35 <fsvehla> The type is (Monad m, ParseTime t) => Bool -> TimeLocale -> String -> String -> m t
02:13:31 <mauke> the Monad instance of Either uses the default fail
02:13:36 <mauke> which throws
02:15:23 <fsvehla> fail in prelude?
02:15:25 <fsvehla> Ah I see
02:19:10 <Ongy> does depending on your own library in cabal not work?
02:19:45 <Ongy> when I depend on the library defined in the same .cabal file, I get an error that a Module is hidden, which is not directly (but inderectly) included by my executable
02:28:30 <lyxia> Ongy: you need to specify the modules your library exports
02:30:12 <Ongy> lyxia: I have https://github.com/Ongy/netlink-hs/blob/master/netlink.cabal I want to remove the other-modules sections on the executables and add a dependencie on the netlink library that's defined at the bottom of the file
02:30:41 <Ongy> when I do that, I get an error about the System.Linux.Netlink.C module being hidden, which I don't inlcude, System.Linux.Netlink includes it
02:31:04 <mniip> ooh
02:31:10 <mniip> my bug will be fixed in 8.0.1
02:39:58 <lyxia> Ongy: Oh, because your library and your executables are all in one directory, the compiler is confused, and when it compiles the executables it first looks for .hs files considered as part of the executable instead of already compiled modules as part of the library
02:40:18 <lyxia> Ongy: One fix is to put executables and the library in separate folders
02:43:39 <Ongy> lyxia: oh, that explains the problem
02:43:41 <Ongy> thanks again
02:43:57 <lyxia> yw
02:54:26 <mniip> "The most popular type-level programming extension is TypeFamilies, which allows users to write functions on types."
02:54:49 <mniip> idunno, they aren't very popular with me thanks to the very issues mentioned in the next paragraph
03:05:13 <fsvehla> @mniip What article are you referring?
03:05:13 <lambdabot> Unknown command, try @list
03:05:20 <mniip> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/injective-type-families-acm.pdf
03:09:43 <mniip> wait
03:10:16 <mniip> "(t,t)~(s,[s]). Is that possible"
03:10:43 <mniip> that doesn't even unify using HM
03:11:08 <mniip> are they saying that occurence checks are irrelevant when dealing with type families?
03:11:54 <aerialB> I don't seem to have System.Random. Does it not come with ghc? (using the standalone Arch package here)
03:13:26 <unit73e> hey
03:14:12 <mniip> aerialB, that's the 'random' package
03:14:18 <unit73e> is it correct to say that if an expression has a syntax error that means it does not evaluate? Or saying "does not evaluate" is stupid?
03:14:35 <mniip> unit73e, calling it an "expression" is stupid
03:15:13 <aerialB> mniip: Ah, I've installed that with cabal now
03:15:15 <unit73e> mniip, what do you call something that returns a result than?
03:15:28 <mniip> unit73e, well something with a syntax error doesn't return a result
03:15:42 <unit73e> mniip, hum you have a point
03:17:01 <unit73e> mniip, so '2 + - 3' is just a line of code? or do you have another name for that?
03:17:35 <mniip> that's valid haskell though?
03:18:11 <unit73e> it's not you have to wrap -3 in parentheses
03:18:47 <unit73e> doesn't return anything
03:19:48 <mniip> ah you are right
03:20:08 <mniip> but yes, you wouldn't call something that doesn't parse an expression
03:20:42 <unit73e> I want to make a question like "Why doesn't '2 + - 3' work?" but that's not a great way to ask that question. Suggestions?
03:21:16 <mniip> I've no idea what you're trying to ask here
03:22:42 <unit73e> It's just a test question. Maybe "Why doesn't '2 + - 3' parse?" makes more sense?
03:23:15 <ahihi> "because it does not conform to the grammar"
03:24:01 <unit73e> hum so I have to be more explicit
03:24:36 <unit73e> now I know how difficult it is to make tests :p
03:25:50 <unit73e> How about "Why doesn't '2 + -3' result in -1?"
03:26:38 <unit73e> you could still say "because it does not conform to the grammar" but you would know what I'm going for?
03:28:09 <mniip> no?
03:28:21 <mniip> do you mean to ask "why is the grammar that way"?
03:29:28 <unit73e> that's a good idea
03:31:25 <unit73e> something like "Why do you have to wrap -3 in parentheses in the following expression '2 + (-3)'?" would be better?
03:32:04 <srhb> unit73e: The answer is still "because that is how the grammar works." Do you want the motivations from the ones who chose that the grammar is like that? I don't know them, by the way.
03:32:51 <aerialB> srhb: I remember that being answered in the "History of Haskell: Being Lazy with Class" paper (paraphrasing)
03:32:54 <srhb> unit73e: Perhaps this discussion will interest you: https://mail.haskell.org/pipermail/haskell-cafe/2006-September/017941.html
03:33:04 <srhb> aerialB: Ah, I did not remember that. :)
03:33:46 <mniip> so, can anyone answer,
03:33:56 <aerialB> yeah, it was basically down to compromise. They thought the alternatives were too awkward.
03:34:09 <mniip> are type families somehow allowed to violate occurrence checks in hindley-milner?
03:34:37 <unit73e> I remember reader that paper once. I'll check again. Thanks.
03:34:57 <unit73e> Because I don't know the answer myself :p
03:35:07 <aerialB> hopefully my memory serves me correctly. I did read it pretty recently :)
03:35:24 <srhb> unit73e: I'm afraid there isn't a terribly good one. It could have gone either way. In the end it boils down to "someone agreed to do it like this." :P
03:35:33 <mettekou> When using the bound library's instantiate functions, is there a way to retrieve the original bound variable name from the Scope value?
03:35:56 <merijn> mettekou: Not unless you store it somewhere
03:39:25 * hackagebot lfst 1.0.0 - L-Fuzzy Set Theory implementation in Haskell  https://hackage.haskell.org/package/lfst-1.0.0 (claudiogreco)
03:41:08 <mniip> I'm reading the injective type families paper, and inthe "awkward examples" section, the Z family doesn't make any sense to me
03:43:37 <mniip> why are we supposed to give up injectivity for cases that aren't even valid
03:54:25 * hackagebot lfst 1.0.1 - L-Fuzzy Set Theory implementation in Haskell  https://hackage.haskell.org/package/lfst-1.0.1 (claudiogreco)
03:57:30 <hexagoxel> can anyone confirm that manually uploading documentation to hackage works as expected?
03:58:57 <mniip> hexagoxel, it was tricky as hell last time I tried
03:59:05 <mniip> I wish I saved the command I used...
03:59:26 * hackagebot envparse 0.3.0 - Parse environment variables  https://hackage.haskell.org/package/envparse-0.3.0 (MatveyAksenov)
04:00:13 <hexagoxel> mniip: i more meant on the server-side; my cabal-install version has `cabal upload --docs`.
04:00:36 <hexagoxel> (and there is the script in the lens package.)
04:01:17 <hexagoxel> i am asking because i had an instance where hackage reported "docs uploaded by user" but there still were no docs displayed.
04:02:03 <mniip> oh that I don't know
04:02:33 <mniip> I've never uploaded docs to haddock, just generated them with hyperlinks properly linking to haddock
04:04:26 * hackagebot lfst 1.0.2 - L-Fuzzy Set Theory implementation in Haskell  https://hackage.haskell.org/package/lfst-1.0.2 (claudiogreco)
04:39:01 <asdfds> Hi. How can I write a main function to print IO [String]?
04:39:24 <mniip> can you elaborate?
04:40:10 <asdfds> In GHCi I have a function that returns type IO [String], but I'm trying to carry that over to a Main.hs with a main function, so I can compile it for larger bits of data.
04:40:41 <asdfds> (or is GHCi going to be almost as fast as compiled?)
04:41:49 <mauke> :t (>>= print)
04:41:51 <lambdabot> Show a => IO a -> IO ()
04:42:18 <roberth> :t mapM_ putStrLn
04:42:20 <lambdabot> Foldable t => t String -> IO ()
04:52:53 <Gurkenglas> Is mapM_ putStrLn slower than putStrLn . unlines, because each action has its own output overhead?
05:00:11 <asdfds> Thanks guys
05:00:49 <asdfds> Haskell Community = win.
05:01:05 <hvr> Gurkenglas: 'putStrLn :: [Char] -> IO ()' is already quite terrible
05:01:26 <hvr> as it may output each single 'Char' via a separate write(2) call
05:01:59 <mauke> never use NoBuffering
05:07:26 <asdfds> Congratulations to me. I have created the slowest parser ever.
05:15:00 <srhb> asdfds: Good job!
05:36:17 <toon> hi everybody, I am using happy to create a small C compiler. So far it's working well but I would like to generalize some rules. For example declaring parameters of function and passing args to a function have the same syntax SOMETHING [, SOMETHING]*. Is there a way to do it in happy ? (the relevant part of my code : http://lpaste.net/154550)
05:55:33 <PrettyBoy2000> hi!!! everyone
06:03:57 <oherrala> toon: no idea about your question, but should the line 3 in your example have "param ',' params" ?
06:08:09 <toon> oherrala: it works in both ways
06:10:22 <toon> it's not optimal though because prepending would be much faster that concatening 2 arrays but it reverses the order of params
06:10:41 <oherrala> ok
06:13:12 <mniip> asdfds, or is it
06:20:39 <unit73e> An operator in haskell grammar is called a what? A grammar element?
06:20:47 <NeverDie> asdfds: Congrats!
06:29:00 <srhb> unit73e: Not sure what you're getting at. In the language spec it's called an "op" at the level where you can actually talk about operators.
06:31:58 <unit73e> srhb, it's just to I can say that operators are distinguished from other elements by having only a special set of characters, thus any of these are valud '2+2' or '2 +2' or '2+ 2' '2 + 2'
06:32:23 <unit73e> srhb, and to relearn something, I don't remember anything grammar classes from college :p
06:32:30 <srhb> unit73e: Oh, the naming rule is called varsym
06:34:18 <unit73e> srhb, thanks
06:34:57 <srhb> unit73e: And consym for type level ones. (constructor) :)
06:40:51 <ggVGc> is there something like zip that loops the shorter list up until the length of the longer one_
06:40:55 <ggVGc> ?
06:41:37 <ggVGc> hm, or rather, a function for repeating a list endlessly?
06:41:52 <Ongy> ggVGc: concat . repeat? both from Data.List
06:42:02 <ggVGc> Ongy: repeat only repeats one value right_
06:42:03 <ggVGc> ?
06:42:07 <Ongy> oh cycle
06:42:08 <ggVGc> oh, I get it now
06:42:10 <ggVGc> yeah
06:42:21 <ggVGc> thanks
06:43:02 <ertes> ggVGc: if you don't know beforehand, which of the lists is the shorter one, you need to write that function yourself
06:43:16 <ggVGc> yeah, I know
06:43:20 <ggVGc> but in this case I know
06:43:23 <unit73e> god finally figured out why sometimes xmonad keys freeze
06:44:07 <ggVGc> is there a function for "take until a predicate matches"?
06:44:21 <ggVGc> I guess with find and take
06:44:26 <Ongy> ggVGc: takeWhile
06:44:35 <Ongy> or Unitl
06:45:01 <ggVGc> Ongy: yeah, but takeWhile doesn't stop on first match
06:45:05 <ggVGc> where is until?
06:45:18 <Ongy> nah, only takewhile exists, so you can do takeWhile (not predicate)
06:45:20 <ggVGc> I'm thininking findIndex and take
06:46:13 <ggVGc> Ongy: takeWhile (not predicate) isn't correct. Imagine a list like [1,2,3,2,2,3], and takeWhile (not (==) 3)
06:46:21 <ggVGc> I would get the other 2's after the first 3
06:46:23 <ggVGc> which is wrong
06:46:24 <ertes> ggVGc: if you want only the first one, you could combine dropWhile with a negated predicate with foldr (const . Just) Nothing
06:46:37 <ertes> (the latter is really just safeHead)
06:46:49 <ggVGc> ertes: hm, findIndex and take seems more intuitive to me
06:46:59 <Ongy> ggVGc: takeWhile stops, what you described right now is filter
06:47:08 <geekosaur> ^
06:47:10 <ertes> ggVGc: try not to work with indices
06:47:11 <ggVGc> oh, right, sorry
06:47:12 <ggVGc> thanks
06:47:58 <ggVGc> ertes: well, the data structure I have represents a sequence of note triggers, and the cutoff point is the loop point of the sequence. So it is inherently indices
06:48:29 <Ongy> btw. why is there no takeUntil? I had the case a few times where I wanted to actually have the element that works as delimiter in the resulting list, easy to implement but annoying
06:48:54 <ertes> ggVGc: sounds to me like Data.Sequence would be a better fit, at least as long as your sequences are finite
06:49:04 <ertes> but it depends on your operations
06:49:43 <ertes> that one has cheap indexing, splits and iterations from both ends
07:06:06 <ggVGc> can I write something like "get (length a) a" without repeating a?
07:06:21 <mniip> get =<< length
07:06:25 <roconnor> @pl \a -> get (legnth a) a
07:06:25 <lambdabot> get =<< legnth
07:06:34 <ggVGc> thanks
07:07:14 <aweinstock> :t (<*> id)
07:07:15 <lambdabot> (a -> a -> b) -> a -> b
07:11:13 <PrettyBoy> hi
07:11:17 <PrettyBoy> everyone
07:11:47 <PrettyBoy> how can i access violent desire
07:12:11 <mniip> huh?
07:12:20 <PrettyBoy> in darknet
07:12:25 <PrettyBoy> im so curious
07:12:35 --- mode: ChanServ set +o mauke
07:12:35 --- kick: PrettyBoy was kicked by mauke (PrettyBoy)
07:13:11 <Ongy> how does the get =<< length work? is that something with arrows?
07:13:35 <mniip> the reader monad instance
07:13:37 <mauke> no, plain monads + functions
07:13:48 <mauke> specifically, instance Monad ((->) e)
07:14:35 --- mode: mauke set -o mauke
07:15:17 <ertes> (do x1 <- f1 {- f1 of theArgument -}; x2 <- f2 {- f2 of theArgument -}; pure (x1 + x2)) theArgument
07:15:44 <ggVGc> hrm.. can't do it. How would I rewrite this with bind to not repeat "trig" twice? https://gist.github.com/71d518e09170bc54d110
07:15:48 <ertes> > (do l <- length; pure (l + 5)) "the argument"
07:15:50 <lambdabot>  17
07:16:31 <mauke> @pl \trig -> (take (trig&trigLength)) (trig&trigEntries)
07:16:31 <lambdabot> liftM2 take (& trigLength) (& trigEntries)
07:17:00 <ertes> ggVGc: don't, it will get ugly
07:18:01 <ggVGc> mkay
07:18:30 <mniip> mindless pointfree is bad for comprehensibility
07:19:04 <Ongy> there's that point where pointfree becomes pointless
07:19:09 <mniip> @pl \(x, y) (z, t) -> (x z, y t)
07:19:09 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
07:19:11 <ggVGc> yeah, I thought it would make this nicer
07:19:18 <ggVGc> but I realise now it's a bit complex
07:19:40 <ggVGc> @pl \mniip -> undefined
07:19:40 <lambdabot> const undefined
07:20:51 <Ongy> (,) as operator is one of the things that confuses me the most
07:21:52 <mniip> so uh, I'll ask again
07:22:35 <ertes> i like to use -XTupleSections, but for some reason (,) itself is so ugly that i avoid it
07:22:51 <ertes> > map (, 2) "abc"
07:22:53 <lambdabot>  [('a',2),('b',2),('c',2)]
07:23:04 <mniip> in the injective type families paper, in the "three awkward cases" section, the third family is said to be non-injective because there exists a counterexample to the original definition
07:23:43 <mniip> what I don't understand though, is that the mentioned example is invalid, at least within HM type inference, so why would we lose injectivity over it?
07:25:06 <mniip> the article: http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/injective-type-families-acm.pdf#page4
07:27:14 <mniip> type family F a; type instance F [a] = (a, a); type instance F (Maybe a) = (a, [a])
07:27:42 <mniip> is said to be non-injective, because there exists type family G a where G a = [G a]
07:28:12 <Ongy> > zip (repeat 2) "abc"
07:28:14 <lambdabot>  [(2,'a'),(2,'b'),(2,'c')]
07:28:15 <mniip> which would satisfy an "s ~ [s]" constraint that arises while unifying the LHSes of the instances
07:28:52 <mniip> but satisfying such a constraint is in direct conflict with hindley-milner, is it not?
07:29:28 <geekosaur> ghc isn't hindley-milner, it's system fc
07:32:22 <mniip> geekosaur, doesn't that go in direct conflict with the typechecker still?
07:33:38 <mniip> like, I can't go
07:33:43 <mniip> :t fix head
07:33:44 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ [a]
07:33:44 <lambdabot>     Expected type: a -> a
07:33:44 <lambdabot>       Actual type: [a] -> a
07:34:33 <geekosaur> ok, I see what you're talking about, and in fact that is mentioned in the text "Is that possible? Youmight think not – after all, the two types do not unify."
07:35:27 <icicled> what's the typical/ideal way to deal with I/O related errors/exceptions within a transformer stack?
07:36:09 <icicled> do you wrap each call site or catch it higher up when calling runStack?
07:36:11 <mniip> geekosaur, right
07:36:24 <geekosaur> in fact I think that's the point, that particular system could force it to unify those when it otherwise wouldn't, because the constraint sneaks in through the back door
07:36:30 <mniip> so what sense does it make to talk about how G invalidates F's injectivity
07:36:34 <mniip> if G is not in itself valid
07:36:51 <geekosaur> IIRC there are similar tricks that can be done to avoid the more prosaic one you demonstrated as well
07:37:58 <geekosaur> that is, the way it reduces those type equations allows the (s ~ [s]) to sneak in
07:38:38 <xa0> would infinite types *really* be so bad? :p
07:38:39 <geekosaur> and there's no good way to check for it
07:39:01 <xa0> <everyone> xa0: yes
07:39:14 <hpc> can't you get unsafeCoerce out of infinite types?
07:39:26 <xa0> huh, cool
07:39:43 <hpc> don't quote me on it, i don't remember ;)
07:39:48 <mniip> hpc, you could unsafeCoerce the Fix newtype
07:40:07 <mauke> hpc: that would surprise me
07:43:20 <mniip> geekosaur, can you provide an example where injectivity of Z could be maliciously exploited by a G-like thing?
07:45:13 <geekosaur> mniip, I more or less understand what that paper is demonstrating there but I'm not really good at type theory; someone else would have to figure out ramifications. :/
07:45:33 <mniip> I see the idea too,
07:45:45 <mniip> but I don't see the point in considering Z to be non-injective
07:45:57 <geekosaur> (like I can see the point here is that reducing the type equations using the proposed typing rules never *explicitly* generates the (s ~ [s]), but I can't go much beyond that)
07:46:41 <geekosaur> I can do "mindless" rule-following, I can't reason about them :(
07:47:07 <geekosaur> oh, I think that is just that these rules are specifically about injectivity
07:47:29 <mauke> .oO( you can still become a great Go player )
07:47:57 <geekosaur> if you're using them then you are producing an injective type family. here they produce an infinite type, so it's essentially proof by contradiction that the type family is injective
07:47:59 * mniip . o O ( is alphago written in go? )
07:48:03 <geekosaur> *not injective\
07:48:14 <parsecChar> i'm trying to install ghcjs on ubuntu
07:48:20 <parsecChar> but the version of node is outdated
07:48:24 <parsecChar> how do I get latest node on ubuntu?
07:48:30 <simpson> mniip: Considering its authors, it's probably several intertwined codebases of C++ and Java.
07:48:39 <mniip> parsecChar, well one way would be compiling it yourself
07:50:33 <parsecChar> mniip: hmm, I do have latest
07:50:43 <parsecChar> but it happens that /usr/bin is before /usr/local/bin, so I was getting outdated version
07:50:55 <parsecChar> time to watch ghcjs boot :-)
07:51:09 <mniip> geekosaur, "And so Z is not injective, according to Definition 1."
07:52:32 <geekosaur> mm, yes, Ithink I was discounting that because it implies that that's not the only possible definition, but then it talks as if it is
07:52:45 <geekosaur> nice brain shortcomings...
07:53:24 <geekosaur> (one of the other awkward cases even says "this looks injective to a mathematician")
07:54:41 <mniip> "Now  use  Definition  1  on  the  first  and  last  of  this  chain  of  equalities,  to  deduce [G Int] ~ Maybe (G Int),  which  is  unsound."
07:54:48 <mniip> well duh, ex falso sequitur quodlibet
07:55:34 <hpc> dolor sit amnet
07:55:42 <parsecChar> ocaml scala clojure
07:55:59 <EvanR> Oh My
07:56:09 <hpc> carbonara con gnachi e spinachi
07:56:24 <Ongy> Schweinsbraten mit sauerkraut?
07:56:28 <mniip> omelette du fromage
07:58:31 <mauke> http://inutile.club/estatis/falso/
08:00:08 <parsecChar> why has no one rewritten nixos, using haskell as the scripting languge?
08:00:21 <parsecChar> we can even keep all the work that nixos has already done by just 'translating' the scripts from nixos-script to haskell
08:00:25 <dgpratt> in mathematical notation, is there a general meaning to a line over a variable (a Greek letter if it matters)? From the context, I'm contemplating whether it could mean "any number of like things here"
08:00:42 <mauke> it might mean boolean negation
08:00:46 <geekosaur> which mathematical notation?
08:01:06 <hpc> geekosaur: like h-bar, but with arbitrary letters
08:01:15 <dgpratt> brb, one sec...
08:01:27 <Gurkenglas> it might mean the complement set, or the residue class
08:01:44 <geekosaur> hpc, yes, I know, my point is I've seen that used in a number of contexts with different meanings
08:02:07 <Gurkenglas> The last one is closest to what you said: over 2, working in the set of integers modulo 5, it means the set {...-8,-3,2,7,12,...}
08:02:43 <dgpratt> http://dev.stephendiehl.com/fun/006_hindley_milner.html#types
08:03:18 <dgpratt> in that section, there is an example of what I'm trying to describe
08:04:19 <dgpratt> it looks like "forall alpha_with_line_over_it. tau"
08:04:58 <dgpratt> not sure that's tau, actually...not so good with the Greek letters
08:06:19 <mniip> looks like a tau to me
08:06:55 <mauke> dgpratt: possibly "list of"
08:07:26 <dgpratt> ah
08:07:40 <dgpratt> that would make sense to me
08:08:01 <mniip> mauke, "Resistant to Gödel attacks" lost it
08:15:19 <parsecChar> woot woto woot stack ghcjs works
08:15:38 <parsecChar> do I have to have to separate stack.yaml files in two different directories
08:15:46 <parsecChar> or can I stuff them into one stack.yaml file ?
08:17:55 <parsecChar> in stack, is there a way to specify "main-is:" (like one does in cabal) ?
08:23:00 <EvanR> wow the interface to acid-state is gnarly
08:26:38 <hpc> it's worth the effort
08:28:21 <EvanR> the code and haddock front page dont seem to jump out with an obvious view of whats going on
08:28:26 <EvanR> i blame the type classses
08:28:47 <EvanR> i wonder if there is a better way with modern haskell
08:29:00 <Gurkenglas> Is there a way to write "MonadPlus f => Cofree f a -> f a" without explicit recursion?
08:31:49 <dburbani_> I'm trying to create a function which takes an arbitrary function f of n Ints, a list of k Ints, and returns the function of n-k Ints obtained by evaluating f in the first k entries, is there a way to do this in Haskell?
08:31:54 <dburbani_> Both n and k can vary
08:32:46 <ertes> Gurkenglas: not with that signature, but if f is also Traversable, it might be possible (but not necessarily with the semantics that you want)
08:33:19 <Gurkenglas> dburbani_, can you write out the type signature for clarity?
08:33:38 <dburbani_> Gurkenglas: No, that's kind of the problem, I don't know how to write out a type signature for this
08:34:22 <ertes> dburbani_: like (f g [1,2,3] = g 1 2 3)?
08:34:46 <dburbani_> I mean, I guess it's something like: (Int ->)^n -> [Int] (-> Int)^k
08:34:51 <jaarod> not possible. type wouldn't be known at compile time
08:34:52 <dburbani_> But that's obviously not valid syntax
08:35:17 <ertes> dburbani_: you could do it with a lot of type-level hacking, but honestly: don't
08:35:59 <Gurkenglas> ertes, with recursion it's possible: f (a :< as) = mplus (return a) $ as >>= f
08:36:01 <dburbani_> ertes: What if I really insist? It's just a curiousity exercise, this isn't for any serious code
08:37:02 <ertes> Gurkenglas: yes, but there is nothing predefined there, basically because Cofree is rather production-oriented rather than reduction
08:37:20 <Gurkenglas> dburbani_, something like ([Int] -> a) -> [Int] -> (a, [Int])?
08:37:33 <ertes> it only has Foldable and Traversable instances that might be helpful, but most likely not with the semantics that you need
08:38:18 <ertes> dburbani_: then you need to learn a few type system extensions first…  there are a number of ways to do it, but probably the cleanest way is to use singleton types (see e.g. the singletons library)
08:39:17 <ertes> but be warned: it probably won't pay off, because dependently typed programming in haskell is currently very ugly
08:39:34 <breadmonster> Not if eir has his way.
08:39:49 <ertes> (except in a few special cases where you can use simple reflection; see the reflection library)
08:39:54 <dburbani_> Gurkenglas: How does the (a, [Int]) return value represent my new function?
08:41:00 <Gurkenglas> dburbani_, "[Int] -> (a, [Int])" is the function that takes n Ints, removes k of them (although you'll have to tell it what k is) and returns the result of putting those k through f, and the remaining n-k ints
08:41:52 <Gurkenglas> :t \k f -> first f . splitAt k
08:41:53 <lambdabot> Int -> ([a] -> c) -> [a] -> (c, [a])
08:42:10 <lingxiao> hey all
08:43:14 <lingxiao> im following a tutorial to create a chat server
08:43:20 <lingxiao> and her's what i have: http://lpaste.net/154552
08:43:25 <lingxiao> probelm is ... i have no idea how to run this
08:43:57 <dburbani_> Gurkenglas: What do you mean by the "remaining n-k Ints", the return value should be a (n-k)-ary function
08:44:04 <lingxiao> so if i call main in ghci nothing is happening .. 
08:44:11 <lingxiao> i think the process is running ..
08:44:41 <dburbani_> ertes: Okay, thanks for the advice, I'll look into it
08:46:32 <Gurkenglas> dburbani_, what is a "function of i ints"?
08:47:54 <dburbani_> Gurkenglas: Something like Int -> Int -> ... Int -> a, where Int is repeated i times
08:49:37 * hackagebot optparse-generic 1.0.1 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.0.1 (GabrielGonzalez)
08:50:30 <ertes> dburbani_: "functions of i Ints" can have a statically known type if i itself is statically known... however, lengths of lists are typically not statically known, which makes writing your function impossible without dependent types
08:50:37 <Gurkenglas> dburbani_, okay, that is what I thought you meant (and expressed via [Int] -> a to make it possible
08:51:11 <Gurkenglas> So given that function and that list, and after evaluating the function on its first k entries, what should it do with the remaining n-k ones?
08:51:26 <dburbani_> Gurkenglas: Nothing, just return the resulting function
08:51:36 <dburbani_> The list has length k
08:52:02 <ertes> dburbani_: you want currying based on a data structure…  to do that your data structure must be type-indexed by its length
08:52:06 <ertes> then you can do it with a type class
08:53:14 <ertes> straightforward approach using associated types:  apply :: (Apply fn) => fn -> Args fn -> Result fn
08:53:15 <Gurkenglas> dburbani_, what function results? Do you mean "just return the result of the function we applied to the first k entries"?
08:53:50 <ertes> hmm, no, an MPTC would be better
08:53:57 <Gurkenglas> Ohhhh I'm stupid, the function takes more ints than the list has ._.
08:55:18 <Gurkenglas> Something like [Int] -> (Int, [Int] -> a) -> (Int, [Int] -> a)
08:56:40 <Gurkenglas> :t \xs (n, f) -> (n - length xs, f . (xs ++))
08:56:42 <lambdabot> [a] -> (Int, [a] -> c) -> (Int, [a] -> c)
08:57:12 <mniip> wait,
08:57:26 <mniip> if we allow "type C" injectivity, wouldn't that let us write something like
08:57:57 <mniip> type family Equals a b = (r :: Bool) | r a -> b, r b -> a where Equals a a = True; Equals a b = False
08:58:10 <mniip> type NotEquals a b = (Equals a b ~ False)
08:59:21 <mniip> unless I'm misreading the paper, the equations for Equals will pass injectivity checks
08:59:38 * hackagebot hspec-wai 0.6.5 - Experimental Hspec support for testing WAI applications  https://hackage.haskell.org/package/hspec-wai-0.6.5 (SimonHengel)
08:59:42 <mniip> and then 'Equals X b ~ False' will have to be inlined into a constraint on b
08:59:48 <mniip> but which constraint?
09:01:27 <mniip> hmm actually, you can already kind of write an injective "Equals", just not abstracted over some 'a'
09:01:35 <mniip> I'll go fiddle with that
09:02:59 <mniip> oh
09:03:06 <mniip> yeah ok, Equals is not injective
09:08:28 <iwmrby> Hello! How can I build a matrix that has double elements using the matrix builder? matrix 4 4 $ \(i, j) -> (1 / (i + j - 1)) fails with "No instance for (Fractional Int) arising from a use of ‘/’"
09:08:30 <z16> Late to the discussion but what?
09:08:37 <z16> Why would equals not be injective?
09:09:38 <mniip> z16, the second equation is not injective in itself
09:10:02 <z16> Maybe I shouldn't talk, I'm not good with Haskell
09:10:03 <mniip> if you pinpoint r~False and a~() you cannot uniquely determine b
09:10:09 <z16> Just surprises me, from a mathematical standpoint
09:10:13 <iwmrby> Looking at the source, it has "((Int,Int) -> a) -- ^ Generator function" which shouldn't be a problem for me since i and j are indeed Ints. The result isn't an Int
09:10:45 <mniip> iwmrby, you can't / and Int
09:10:51 <mniip> / an Int*
09:11:19 <mniip> z16, I'm talking about a (k -> k -> Bool) type function
09:11:25 <mniip> it's not injective
09:11:40 <iwmrby> mniip: hm... so there isn't a way to build that matrix using the builder?
09:11:46 <mniip> iwmrby, there is,
09:11:50 <mniip> just don't divide ints
09:11:58 <mniip> convert them into whatever datatype you need
09:12:02 <mniip> you probably want fromIntegral
09:12:32 <jaarod> you can div an int
09:12:35 <jaarod> > div 5 2
09:12:38 <lambdabot>  2
09:12:56 <mniip> z16, or rather, injectivity is the wrong term, as in mathematics "partially injective" is rather meaningless
09:13:13 <z16> mniip: Again, I'm not very good with Haskell, so tell me to shut up when I'm just being stupid
09:13:36 <ertes> dburbani_, Gurkenglas: http://lpaste.net/154553
09:13:40 <z16> Er
09:13:46 <z16> Let me process that
09:13:54 <mniip> z16, there's nothing wrong with asking stupid questions :)
09:14:24 <ertes> dburbani_, Gurkenglas: that one is the exclusively static one (and thus pretty useless)…  in order to make this dynamic, you need both more extensions and a lot more code
09:15:00 <ertes> and the end result would be pretty much what you'd likely better do with simply functions of lists
09:16:19 <z16> "Injective" mathematically means that a function mapping A to B can never map more than one element from A to each element from B
09:16:26 <z16> But
09:16:42 <z16> In mathematics equality is a binary mapping from A to A
09:16:52 <z16> In programming it's usually (AxA) -> Bool
09:17:03 <z16> Or k -> k -> Bool in Haskell
09:17:15 <jpfuentes2> anyone here have experience with conduit? any reason why there seems to be UDP server missing? it has convenient TCP server of course
09:17:15 <dburbani_> ertes: Yeah it looks pretty messy, I'll probably settle for a function of lists solution then, thanks
09:17:26 <z16> So it depends on what you consider to be the "equality function" in this case
09:17:29 <opqdonut> z16: equality is a binary relation, which is equivalent to (AxA) -> Bool
09:17:35 <ertes> z16: (judging from context) it's mathematical equality here, which is not a boolean function, but a proposition
09:17:45 <mniip> z16, haskell typesystem has some means to represent relations
09:17:56 <mniip> so the "equality relation" is a thing
09:18:01 <mniip> :k (~)
09:18:03 <lambdabot> k -> k -> Constraint
09:18:13 <z16> But in that case I would think that Equals is bijective, and by extension injective
09:18:19 <z16> Or what case would invalidate that?
09:18:32 <mniip> but yeah, we're talking about k->k->Bool here
09:18:47 <simpson> jpfuentes2: The short answer is that "UDP server" is not a thing; binding to a UDP port does not give you the sort of behavior that a TCP port does.
09:19:39 <mniip> z16, I'm talking about a functional dependency, it's a bit different and more general then "injectivity" or "bijectivity"
09:20:05 <mniip> I guess in your language it's best expressed by "Partially applying f to one argument produces a bijection"
09:20:14 <z16> Ok, like I said, I'm not very involved with common terminology in the Haskell world
09:20:22 <mniip> which is not true for our 'Equals' family
09:20:24 <z16> I figured it was just a misunderstanding
09:20:46 <mniip> there's no bijection in a function that returns True for Bool and False for everything else
09:20:46 <simpson> jpfuentes2: That said, there's a thing in conduit-extra: https://hackage.haskell.org/package/conduit-extra-1.1.11/docs/Data-Conduit-Network-UDP.html
09:20:51 <jpfuentes2> sure, simpson, the protocols are different, but UDP is often used in streaming contexts as well
09:22:11 <simpson> jpfuentes2: You know that UDP packets can be delivered out-of-order or go totally missing, right?
09:22:16 <jpfuentes2> yep
09:22:30 <simpson> Okay. The thing in conduit-extra appears to be useful for building a UDP-based thing.
09:22:42 <jpfuentes2> i'm writing a UDP-based gossip protocol: SWIM gossip
09:22:45 <simpson> But it doesn't appear to handle any of the stuff that would make a UDP transport reliable. You'll have to write that yourself.
09:23:04 <jpfuentes2> yeah, SWIM incorporates basic ack which i need to write
09:23:21 <ertes> simpson: there is nothing wrong with using a stream abstraction to handle streams of UDP packets, even if there is no order or reliability
09:23:28 <jpfuentes2> i was hoping for the 1st class support b/c ultimately i'd need to serve *both* TCP/UDP where UDP is the dominant protocol
09:23:37 <jpfuentes2> precisely, ertes ^
09:24:09 <simpson> ertes: Sure, I'm just explaining why conduit-extra might not carry such a thing.
09:24:22 <simpson> Namely, because the conduit author doesn't want to mislead people about how UDP functions.
09:24:42 <ertes> that might be the case, but more likely it's just that nobody has done it =)
09:25:08 * hackagebot concurrent-output 1.7.4 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.7.4 (JoeyHess)
09:25:37 <jpfuentes2> that's my guess: UDP is often 2nd class citizen
09:26:11 <ertes> jpfuentes2: that said it's easy enough to program that yourself… basically it's just a receive/yield loop
09:26:22 <EvanR> if you want reliable, and your network is not known to be reliable, why would you use UDP
09:26:35 <lingxiao> hey all
09:26:45 <lingxiao>  i have some rudimentary questions about chat server ..
09:26:51 <ertes> EvanR: for some applications you *want* to lose packets, most notably multimedia
09:26:52 <lingxiao> could someone walk me through some of the concepts?
09:27:02 <EvanR> right which fails my questions premise
09:27:10 <EvanR> UDP shines when you dont want/need reliable
09:27:16 <mniip> lingxiao, which chat server you mean
09:27:18 <EvanR> or when your network is reliable
09:27:20 <simpson> ertes, jpfuentes2: The docs I linked contain the function `sourceSocket :: MonadIO m => Socket -> Int -> Producer m Message`. Is this not sufficient?
09:27:38 <lingxiao> this one:http://lpaste.net/154554
09:27:47 <lingxiao> i ran main in ghci
09:27:48 <jpfuentes2> i'll give that a shot, simpson, thanks. and thanks ertes 
09:27:54 <lingxiao> but im not sure what i should be seing
09:28:02 <lingxiao> for example wher is the "hello world" being sent to?
09:28:08 <lingxiao> and how would i see it?
09:28:17 <lingxiao> see .. my questions are very rudimentry  :(
09:28:36 <mniip> lingxiao, it launches a server on port 4242
09:28:54 <mniip> the hello world is being send to any clients connecting on that port
09:28:57 <mniip> sent
09:29:11 <lingxiao> how would i connnect to that port as a client?
09:29:18 <mniip> what OS do you use?
09:29:28 <lingxiao> mac os X
09:29:42 <mniip> uhh that I'm not sure
09:29:46 <nitrix> Can I call a :: `State Game Keycode` from a :: `State Game Bool` ?
09:29:47 <mniip> maybe you have netcat or nc?
09:29:54 <glguy> OS X does come with nc
09:30:00 <ertes> simpson: not sure, because you need to use recvFrom for UDP
09:30:10 <mniip> yeah then you can 'nc localhost 4242' from the shell
09:30:11 <nitrix> I'm assuming that's just >>= ?
09:30:22 <mniip> nitrix, looks like a fmap to me?
09:30:23 <lingxiao> mniip im sorry can i ask you what's port 4242 .. i tried looking it up but cant find a succint answer
09:30:28 <nitrix> mniip: okay
09:30:48 <lingxiao> and no i dont have netcat i think .. i can install it though
09:30:57 <mniip> lingxiao, 'nc'
09:30:59 <lingxiao> sorry to clog the channels with such elementary questions
09:31:16 <simpson> ertes: The attached docs appear to let you bind to any standard Socket (from the `network` package). What more could you want?
09:31:28 <lingxiao> ahh typing nc on my console does say something 
09:31:35 <lingxiao> it tells me about usage 
09:31:48 <mniip> 1457803677 [20:27:57] <mniip> yeah then you can 'nc localhost 4242' from the shell
09:32:07 <Gurkenglas> :t foldl unwrap --ertes, dburbani_. w a1 (or, more specifically, "Cofree ((->) a) a1") is the type of functions of some number of arguments. Of course Free would be more suited to this, as it contains information on whether the function is done taking arguments. Is there a way to tear down one step of a Free?
09:32:47 <mniip> Gurkenglas, yes I think
09:33:01 <ertes> simpson: as i don't use UDP much i'm not sure whether bind makes the socket "connected"
09:33:05 <Gurkenglas> lambdabot is gone! Panic D:
09:33:42 <ertes> simpson: in either case i'd expect recvFrom to be more flexible, because you don't need to bind to a particular address
09:33:50 <mniip> :t Control.Monad.Trans.Free.partialIterT
09:34:00 <lambdabot> Monad m => Integer -> (forall a. f a -> m a) -> Control.Monad.Trans.Free.FreeT f m b -> Control.Monad.Trans.Free.FreeT f m b
09:34:52 <jpfuentes2> in my case, ertes, i want to bind to a particular address
09:35:02 <lingxiao> mniip ok i did that but so far seeing nothing
09:35:25 <ertes> Gurkenglas: Cofree ((->) a) b ≃ (b, a -> Cofree ((->) a) b)
09:35:47 <ertes> Gurkenglas: doesn't seem that useful as an abstraction of functions, but more of parametric streams
09:35:55 <mniip> Gurkenglas, yeah sounds like you want a Free ((->) a) instead
09:36:15 <mniip> which sounds rather familiar :)
09:36:59 <Gurkenglas> Yea I did think of yoctoparsec immediately but wasn't sure how to use that in a solution :P
09:37:10 <mniip> Parser Identity
09:37:18 <mniip> is an n-ary function
09:37:39 <simpson> ertes: There's no portable way to listen to all UDP traffic; you have to pick a port.
09:37:43 <mniip> can be applied to an infinite stream of arguments using parseStream
09:37:51 <Gurkenglas> :t foldl (\(Control.Monad.Free.Free f) -> f) -- dburbani_ 
09:37:55 <mniip> (parseStream won't do because it needs a MonadPlus)
09:37:56 <mniip> er
09:37:57 <simpson> ertes: But no, you don't need to bind the socket. Haskell knows what's up.
09:37:58 <lambdabot> Foldable t => Control.Monad.Free.Free ((->) a) t1 -> t a -> Control.Monad.Free.Free ((->) a) t1
09:38:00 <mniip> (parseString won't do because it needs a MonadPlus)
09:38:17 <ertes> simpson: does haskell know what's up, or do BSD sockets?
09:38:54 <simpson> ertes: Sure. Yes.
09:39:15 <mniip> Gurkenglas, you could write something like
09:39:27 <Gurkenglas> (It's times like this that I think the fold* functions have their second and third argument flipped)
09:40:05 <mniip> sumUntilZero = do x <- token; if x == 0 then return 0 else (x +) <$> sumUntilZero
09:40:22 <ertes> simpson: that was a "which one?" question =)
09:41:07 <simpson> ertes: The `network` package is inseperable from BSD sockets.
09:41:40 <mniip> then assuming we use Cofree Identity as our infinite stream,
09:42:37 <mniip> parseStream (\(a :< b) -> Identity (a, b))
09:42:39 <mniip> will do the trick
09:42:43 <Gurkenglas> sumUntilZero = fmap sum $ many $ mfilter (/= 0) token -- mniip
09:42:47 <ertes> ok
09:42:58 <mniip> Gurkenglas, that requires MonadPlus
09:43:16 <Gurkenglas> hmm, so it does
09:43:18 <mniip> which is what we're avoiding here because our "backtracking" monad is Identity
09:44:15 <mniip> you know I just realized something
09:44:22 <mniip> basically,
09:44:32 <mniip> parseStream annihilates a Free with a Cofree
09:44:44 <mniip> how crazy is that
09:44:59 <lingxiao> ok go it thanks mniip! 
09:45:11 <lingxiao> btw can i ask you for a high level explanation of what this port 4242is?
09:45:23 <mniip> lingxiao, um
09:45:26 <mniip> it's just a number?
09:45:27 <ertes> lingxiao: a number
09:45:27 <lingxiao> am i sending msg to my own coputer over the internet?
09:45:39 <mniip> lingxiao, no you're sending it over loopback
09:45:49 <lingxiao> what's loopback?
09:46:03 <mniip> a special network device that corresponds to your own computer
09:46:18 <mniip> pseudo-device, that is
09:46:44 <mniip> the 127.0.0.1 address belongs to the loopback interface
09:46:52 <ertes> lingxiao: you can associate certain services with certain numbers (like HTTP is commonly 80), but otherwise there is nothing special about that number…  and if you connect to yourself, your packets don't leave your computer at all
09:47:15 <lingxiao> ah ok i have a lot to learn but thanks for getting me started!
09:47:55 <Gurkenglas> :t fmap sum . runIdentityT . manyLazy . mfilter (/= 0) . lift -- mniip
09:47:56 <lambdabot> (Eq b, Monad m, Num b) => m b -> m b
09:48:21 <ertes> :t mfilter
09:48:23 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
09:48:38 <Sornaensis> bumdongle
09:49:09 <mniip> Gurkenglas, wait what
09:50:37 <mniip> int-e, hey ho, can we get Free and Cofree in lambdabot?
09:50:46 <Gurkenglas> lift puts it into MaybeT, mfilter NothingTs the 0s, manyLazy runs that until it fails (and turns the MaybeT into an IdentityT because many is guranteed to work), runIdentityT gets rid of the IdentityT, fmap sum sums the results. (fmap is over Identity)
09:51:11 <mniip> Gurkenglas, which part of the stack says MaybeT? o-O
09:51:18 <Gurkenglas> Cofree can be imported, Free can't. We want all of the free package
09:51:40 <ontop> Can anyone vet my Monad instance for a "State" re-implementation? http://lpaste.net/2082785514783506432
09:51:48 <Gurkenglas> mniip, lift is into MaybeT because PointedAlternative http://lpaste.net/150858 has "instance Monad m => PointedAlternative (MaybeT m) (IdentityT m)"
09:52:03 <ontop> I can't test it :(
09:52:54 <Gurkenglas> ("As many as possible, but not none." <- the temptation to replace that with "As some as possible" is real)
09:53:17 <ertes> ontop: haven't tested it, but looks fine, except perhaps for a few style notes
09:53:21 <mniip> ontop, looks good
09:53:31 <ontop> Thanks guys :D
09:53:31 <mniip> well, tbf it looks bad
09:53:33 <mniip> but valid
09:53:35 <ontop> Haha
09:53:43 <ontop> the naming is awful I know :(
09:53:57 <ontop> Can you suggest a better way?
09:54:18 <nitrix> Is there such thing as withState, but that'd do this instead:   withState' f m = modify f >> return m    (notice the return)
09:54:21 <ertes> ontop: use shorter names…  they'd actually make the code more readable in this case
09:54:28 <ontop> Oh wow, on my screen that = is not indented.
09:54:32 <mniip> fmap f (State s) = State $ first f . s
09:54:47 <Gurkenglas> ontop, "(value2, newerState) = s st' in (value2, newerState)" <- why not "s st'"?
09:55:01 <ontop> Rofl. Omg good point Gurkenglas 
09:55:10 <ontop> Hahaha
09:55:17 <ertes> nitrix: you could use (<$)
09:55:24 <nitrix> ertes: o: !
09:55:37 <nitrix> True, it's a functor o:
09:55:49 <ertes> x <$ modify f
09:56:10 <ertes> i wouldn't write a function for that…  most likely unnecessary indirection
09:57:06 <mniip> Gurkenglas, have you seen my generalized functors btw :o
09:57:38 <Gurkenglas> i think not
09:57:53 <Gurkenglas> (no meta-questions :P!)
09:58:03 <mniip> http://lpaste.net/154525
09:58:31 <ontop> I managed to test it, same result as the real monad!
09:58:46 <ontop> I still don't understand how I did it or what it does though. I think that's the real failure here (past the style).
09:59:03 <ertes> mniip: those look familiar from a library
09:59:15 <ertes> i think edwardk has at least some of them
09:59:17 <int-e> so why is Data.Coerce not trustworthy?
10:00:07 <mniip> I think it can be broken down with malicious type role annotations?
10:00:09 <ertes> ontop: a `State s a` is really just a function of type `s -> (a, s)`
10:00:24 <ontop> Yeah. "State processor"
10:00:36 <ertes> ontop: Functor allows you to map over the *result* part of the result of that function
10:01:10 <mniip> data D a = D { unD :: D a }
10:01:14 <mniip> type role D phantom
10:01:18 <ertes> Applicative allows you to combine results of multiple such functions while threading state, and Monad allows you to chain stateful functions
10:01:21 <mniip> safeCoerce = unD . coerce . D
10:01:34 <ertes> ontop: don't read too much into "state"…  it's just functions
10:01:43 <ontop> Yea.
10:01:57 <ontop> I was trying to learn it in depth
10:02:00 <mniip> and safeCoerce is one step away from safePerformIO
10:02:01 <ontop> So I could use mutable arrays.
10:02:10 <ontop> I think I'm at that level uf understanding now.
10:02:12 <ertes> ontop: you won't use mutable arrays with State
10:02:21 <ontop> I thought there was some ST thing
10:02:24 <ontop> That was similar?
10:02:31 <ertes> State and ST are almost completely unrelated
10:02:37 <ontop> Oh great. What a waste of time :D
10:02:42 <mniip> well
10:02:42 <ertes> not at all =)
10:02:47 <mniip> they are both "stateful"
10:03:09 <ertes> ontop: to understand ST you should understand IO
10:03:15 <ertes> rather than State
10:03:33 <ertes> it's a language for expressing effects
10:03:46 <ertes> certain effects that is, like side effects
10:03:51 <ontop> Yea.
10:04:20 <ontop> I -think- I get IO in that it exists, and is annoying, and you work around it with monads and bind to work on the values while keeping it around annoyingly the entire time. :D
10:04:30 * mniip . o O ( safePerformIO = safeCoerce runST ? )
10:04:46 <ertes> IO is one of my favourite types in haskell
10:04:56 <ertes> it starts as annoying, but you will learn to love it =)
10:04:56 <ontop> I guess it's ok
10:05:00 <ontop> :|
10:05:00 <mniip> ertes, clearly you haven't looked at its implementation
10:05:05 <ontop> Haha
10:05:19 <ontop> I like the pure part of Haskell the most. Everything else mostly sucks so far.
10:05:38 <ontop> I mean yeah yeah everything's pure etc
10:05:45 <ertes> mniip: i have, and it's ugly, but that doesn't concern me…  i mean the idea of first-class actions in general that you don't get in most other languages
10:05:56 <ertes> just consider that stuff like 'catch' is a *function* in haskell
10:05:59 <ertes> that's what i mean
10:07:15 <monochrom> IO could also be implemented elegantly (and therefore inefficiently) if you wanted.
10:08:13 <mniip> monochrom, you mean as a free-ish monad? that's hardly elegant as it's not as easily extensible
10:10:10 * hackagebot reactivity 0.2.3.0 - (Yet another) alternate implementation of push-pull FRP. This is based on the Reactive package (http://haskell.org/haskellwiki/reactive).  https://hackage.haskell.org/package/reactivity-0.2.3.0 (JamesCandy)
10:11:00 <monochrom> free-ish monads already lose to the current ugly implementation on efficiency
10:11:55 <monochrom> my point is that you shouldn't conflate "has ugly implementation" with "has ugly nature"
10:12:17 <mniip> well true,
10:12:26 <monochrom> even the simple and beautiful mathematical function of "factorial" gets ugly once you try to make it fast
10:12:32 <mniip> good job on abstracting the ugly hacks away
10:12:41 <int-e> Oh of course, Data.Coerce can break the distinction between nominal and representational type roles.
10:13:06 <monochrom> in fact, those who know the fast ways for factorial actually yell or scorn at those of us who do "product [2..n]"
10:13:06 <ertes> i consider IO's low-level definition to be an implementation detail, and i've never needed it even when i was doing unsafe stuff
10:13:27 * int-e wonders.
10:14:45 <monochrom> http://www.luschny.de/math/factorial/FastFactorialFunctions.htm
10:15:16 <mniip> monochrom, can you go noticeably faster then product = go 1 where go !r 0 = r; go r n = go (r * n) (n - 1)
10:15:20 <mniip> than*
10:15:26 <int-e> Actually, no... the whole point is that one can convert *values* with the same representation, but this does not carry over to nominal type arguments. So what am I missing here?
10:15:27 <ertes> mniip: waaaaaaaaaaaaay faster
10:15:28 <mniip> err
10:15:35 <mniip> s/product/factorial/ even
10:15:38 <monochrom> the point is yes
10:15:55 <ertes> mniip: but it involves some same-size multiplication tricks, and if you really want to get fancy, some number theory
10:16:02 <mniip> ah
10:16:24 <mniip> the point was that there are algorithmically faster factorial algorithms?
10:16:36 <mniip> I thought you meant the laziness of foldr
10:16:52 <monochrom> yes and they get complicated and ugly and dirty as you want more speed
10:17:16 <ertes> mniip: the naive recursive definition is not much slower than the iterative one, because the product grows very quickly, making the difference negligible
10:17:25 <monochrom> the point is that GHC IO is implemented ugly due to efficiency not due to IO the idea being ugly
10:18:27 <ertes> it's not even that ugly…  it's really just a rather simple strictness hack
10:18:33 <ertes> could be a lot worse
10:18:35 <monochrom> and this is a familiar phenomenon in programming. "X has a beautiful specification but efficient implementations have to be ugly" holds for many X's.
10:19:25 <monochrom> and the corollary is that "read the source code" rarely helps
10:19:47 <monochrom> most often it's more misleading than enlightening
10:25:29 <mniip> monochrom, well idunno, reading the sources of IO taught me a lo
10:25:29 <mniip> t
10:26:15 <ontop> Is GHC written in Haskell?
10:26:34 <monochrom> mostly. the runtime system contains C
10:26:40 <ontop> o
10:27:07 <ontop> This language seems like it's compiler would be retardedly hard to make.
10:27:29 <hiptobecubic> Have you looked at a C++ compiler lately?
10:27:48 <ertes> ontop: haskell is difficult to compile *efficiently*
10:27:54 <mniip> well
10:28:03 <mniip> typechecking a haskell program is hell of a task
10:28:05 <ontop> hiptobecubic: I saw a Tic Tac Toe game implemented completely in C++ template language. Which probably speaks to some complexity lol.
10:28:07 <ertes> both in terms of compilation time and produced code efficiency
10:28:28 <wrmsr|> c++ is like 5 languages
10:28:45 <ertes> and yes, if you implement modern haskell, which is a lot more than just the standard language, your type system code will be huge
10:29:04 <mniip> on a related note,
10:29:24 <mniip> I heard someone say GHC's typesystem is system-FC
10:29:33 <mniip> but I'm reading up on system-F and that seems not true?
10:30:06 <ertes> it isn't…  haskell's type system is a weird mix…  a point somewhere in the middle of the lambda cube that moves as you switch on extensions
10:30:40 <mniip> lambda cube?
10:31:19 <wrmsr|> https://en.wikipedia.org/wiki/Lambda_cube
10:31:30 <wrmsr|> (<- idris fan)
10:32:40 <ontop> Anyone want to remind me quick which of Integer or Int is the C-like int equiv (fast and efficient one)?
10:33:01 <ontop> I thought it was Int.
10:33:08 <quchen> ontop: CInt.
10:33:10 <ertes> ontop: neither
10:33:13 <ontop> Awkward.
10:33:23 <ontop> Haskell ruins my life again. There's ANOTHER int?
10:33:25 <mniip> Int#!
10:33:46 <mniip> ertes, I see, I guess my type-theory-fu isn't strong enough yet
10:33:54 <ertes> ontop: in haskell Int is much closer to what you would consider a "machine integer", while in C it's usually 32 bits, even when the machine is 64 bits
10:34:11 <ontop> Okay. That's good enough for me.
10:34:19 <ontop> Integer was too long to type anyway.
10:34:33 <ertes> ontop: Integer generally reduces to Int, if it can
10:35:18 <monochrom> eventually you will have dissociate "C-like" from "fast and efficient"
10:35:36 <ontop> When? I don't see that day coming.
10:36:03 <monochrom> I don't mean to say that "C-like" does not imply "fast and efficient". but there are other meanings of "C-like" such as "compatible when I use FFI"
10:36:19 <ontop> Fair.
10:36:41 <monochrom> so for example CInt is "C-like" because that's what gets a faithful translation to C's int.
10:37:05 <monochrom> however it still has all the overhead associated with Int32
10:37:11 <ertes> ontop: i've written haskell code that outperformed equivalent C code
10:37:21 <ertes> not by a huge margin, but nevertheless
10:38:50 <ontop> ertes: I don't think any Haskell code can outperform C if the algorithm is equivalent, and written properly for both languages.
10:39:36 <ertes> ontop: http://lpaste.net/101980
10:39:40 <shiin> I'd like to install the current stable haskell platform on debian wheezy, but haven't been successful so far.
10:39:54 <ertes> ontop: and that was years ago…  meanwhile GHC has improved
10:40:08 <monochrom> tee hee hee! http://xkcd.com/1654/
10:40:28 <ontop> The challenge here is that I can't write equivalent C to outperform this ertes?
10:41:25 <shiin> First I tried to download the haskell-platform source and compile it. I found out haskell-platform needs cabal-install, so I downloaded that source and tried to compile it. I found out cabal-install needs ghc, so I downloaded that source and tried to compile it. I found out it wants ghc installed, so I installed ghc. But the ghc on wheezy is too old. What do I do now?
10:41:27 <ertes> ontop: yes…  you can build on my C version, if you'd like
10:42:03 <ontop> I have a dentist appointment now. Or I'd take you up on this challenge! Nothing outperforms C when written properly - unfortunately. Maybe Rust...
10:42:06 <ertes> but i don't see any way to improve it
10:42:25 <Azel> ontop: A sucker's bet that. Assembly does :P
10:42:29 <ontop> Hah.
10:42:43 <mniip> Azel, you wish
10:42:55 <ertes> ontop: that's not true…  C can be outperformed
10:43:07 <monochrom> I'm just going to write microcode
10:43:11 <mniip> I used to think that too until I discovered that 'loop' is slower then 'dec rcx; jz'
10:43:33 <ertes> example: when you write "f(); g();" in C, and they come from different libraries, then there is a whole, call-return-call cycle
10:43:41 <mniip> now I just let compiler do its job
10:43:43 <Azel> mniip: I never said it would be easy :D
10:43:50 <ertes> that cycle doesn't exist the same way in GHC-haskell
10:44:22 <ontop> Ah, that's interesting :D
10:44:23 <mniip> ertes, yeah, instead you just invoke the allocator 15 times xD
10:44:40 <ontop> ertes: But, unless I'm insane or silly, Haskell has a GC. Correct?
10:44:46 <ertes> correct
10:44:54 <Azel> mniip: Same reason I never do web development in C. Yes it's faster to do it in C. It's also a pain in the backside to code.
10:45:00 <ontop> That should interfere sufficiently to ruin any hope you have.
10:45:11 * hackagebot cplex-hs 0.2.0.1 - high-level CPLEX interface  https://hackage.haskell.org/package/cplex-hs-0.2.0.1 (stefanjhlk)
10:45:13 <ertes> ontop: common misconception…  in fact it can be faster
10:45:13 <mniip> Azel, nah I mean, sometimes GCC will create better assembly than you will
10:45:59 <ertes> ontop: a C stack cleanup can be way slower than a GC, and if you use malloc/free, it would be even worse
10:46:10 <monochrom> ontop: if you don't allocate a lot, GC doesn't get triggered
10:46:37 <ertes> in fact most looped GCs are free…  that is they translate to *no* instructions…  you can't get any faster than this =)
10:46:38 <ontop> monochrom: Bookeeping is usually required on alloc though.
10:47:03 <ontop> Otherwise, how does your GC know what there is on it's heap to free?
10:47:35 <ontop> ertes: Fair, I don't know anything about Haskell's GC. Speaking mostly about ideas from Ruby/Go's here.
10:47:37 <ertes> ontop: GC requires book-keeping only when the scope of a heap object is not known statically
10:48:06 <obadz> ertes: if it is then can't it be put on the stack?
10:48:25 <ontop> obadz: Size matters.
10:48:41 <ertes> ontop: you might remember the old saying that the compiler likely produces better assembly code than a human programmer
10:48:53 <ertes> haskell applies this to memory management and thread management, too
10:49:10 <ontop> Welp
10:49:14 <ontop> Gotta go to the dentist.
10:49:23 <ontop> mapConcurrently is the greatest function ever btw.
10:49:41 <Azel> mniip: I think that would even be frequently the case. You /can/ write the same ASM given enough time and probably get some improvements on it flouting the standard calling convention, but it will take you long enough that it isn't worth it.
10:49:46 <ertes> as a compiler GHC can use memory plans that aren't straightforward to program manually…  and it can make them crazily efficient
10:50:08 <monochrom> ontop: you probably have to go soon, so let me just point you at https://github.com/takenobu-hs/haskell-ghc-illustrated for bookmarking for now. the short story is that GHC's heap allocation does not have a "what is the free-list saying now?" step.
10:50:43 <ertes> obadz: not sure what you mean (note: GHC-compiled programs don't use a call stack at all, except when interfacing with foreign code)
10:50:46 <kaol> I made a local version of a package with a bug fix and bumped the version number and did a cabal install with it. My own package builds now fine with cabal build but if I try to load any files in my project with ghci it finds the hackage version. Why doesn't ghci pick the later version?
10:51:08 <ontop> Thx monochrom, I'm out guys. Later :D
10:53:08 <obadz> ertes: interesting, never thought about that…
10:54:02 <obadz> ertes: is every object always 'allocated' then?
10:57:21 <monochrom> obadz: yes
10:58:29 <kaol> I suppose I should do something with ghc-pkg.
10:59:08 <monochrom> if you say, "some static analysis can figure out that a certain cons cell will not be given to the caller, therefore it could safely live on the stack" (aka "escape analysis"). yes, but GHC hasn't done that.
11:02:15 <monochrom> and if you ask, "why not?", then it's because it is a pretty low priority thing. at present, "heap allocation" is already down to a simple "if heap pointer > heap limit then GC else increase heap pointer by 48"
11:02:38 <monochrom> meaning that heap allocation is no slower than stack allocation
11:03:16 <monochrom> (so the only benefit of stack allocation over heap allocation is one fewer node to consider during GC)
11:09:48 <monochrom> overall, speed is not a major problem with GHC heap. allocation is already as fast as stack. the GC algorithm is also among the fastest known in the whole world.
11:11:00 <monochrom> the major problem is memory footprint. because the GC algorithm is among the fastest known, it contains a part that famously says "let's occupy twice as much memory" (similar to double-buffering in graphics)
11:12:03 <monochrom> therefore, for example, if you know that your list should only take 500MB, sometimes your OS may report to you that the program is occupying 1GB
11:12:59 <ertes> side note: that double-buffering does not apply to mutable memory objects *referenced* from the heap…  in other words: your usual mutable array/vector isn't affected
11:13:52 <monochrom> yeah. it usually shows up with programs that use [a] greatly and naïvely
11:13:55 <orion> monochrom: The Haskell/GHC GC algorithm is famous?
11:14:27 <monochrom> my exactly wording is "contains a part that famously says". do you understand what it means?
11:14:45 <simpson> orion: Its predecessor is, yes. Lemme find the paper.
11:15:29 <simpson> orion: http://www.pipeline.com/~hbaker1/CheneyMTA.html
11:16:34 <hpc> the GHC GC algorithm is certainly famous among people who care though
11:16:46 <hpc> it's probably the only GC in production that can compare to the JVM's
11:18:46 <orion> It's a shame Haskell isn't more popular given those facts.
11:18:58 <ertes> GHC is probably famous for a lot of things that are traditionally considered to be better done manually
11:19:09 <ertes> it's threading code is similarly excellent
11:19:48 <ertes> another case of "outperforms C when used properly"
11:20:30 <osfameron> and I guess it outperforms *badly* manually written C even more often :-)
11:20:33 * hackagebot aeson 0.11.1.1 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-0.11.1.1 (AdamBergmark)
11:21:44 <ertes> however, it also infamous for a few things
11:21:46 <osfameron> hpc: I found Java  GC to be quite slow, e.g. when I used IntelliJ back in the day, it would stop the world to do GC quite noticeably
11:22:01 <Blue_> Hey, is it ok that I ask a question about an assignment I have here/
11:22:11 <simpson> If you're talking Java, don't forget that Zing exists.
11:22:15 <monochrom> yes. but I don't know what answers you will get.
11:22:28 <hpc> osfameron: back in which day? it's certainly better now than it was a decade ago
11:22:30 <ertes> like program startup times that can get noticable if you do unixy things (like run a haskell program in a loop)
11:22:55 <hpc> i only ever notice JVM GCs in minecraft
11:23:05 <monochrom> heh
11:23:12 <Blue_> Well Basically I need to write a function that returns another function, I have a definition of a binary tree of bools
11:23:16 <osfameron> hpc: yeah, probably more than a decade (I briefly thought about going into J2ME development for mobile phones ;-)
11:23:19 <Blue_> it is defined like so
11:23:42 <Blue_> data Tree :: ∗ → ∗ where Tip :: a → Tree a Bin :: Tree a → Tree a → Tree a deriving (Eq, Show)
11:23:52 <monochrom> we encourage you to use lpaste.net to show not-short code
11:23:54 <osfameron> what are the unicode mojibake?
11:23:54 <hpc> arguably the fact that it's improving at all is what makes the JVM GC famous
11:24:12 <hpc> so many scripting languages it seems like the GC was written in a day and then never touched again
11:24:16 <Blue_> it is pretty short monochrom
11:24:32 <Blue_> anyway, I need to write a function that creates all the possible trees of size n
11:24:57 <Blue_> it looks like this: > boolTreesE :: (Int -> [Tree Bool])
11:24:58 <ertes> Blue_: "size"?  height?  leaf count?
11:25:14 <Blue_> the size of a Tree is all the Bin and Tips of it
11:25:22 <Blue_> so basically you can only have Odd trees
11:25:33 <mniip> monochrom, that's a cool pdf but
11:25:43 <Blue_> I have function that does that.
11:25:57 <mniip> it's weird
11:26:11 <monochrom> alright, I guess there is no such thing as "my tree has size 0" then? then the base case is "boolTreesE 1"
11:26:19 <Blue_> http://lpaste.net/154560
11:26:22 <mniip> you can only learn things you already know, you can't learn anything new from it because you don't understand the diagrams
11:26:42 <Blue_> Thats the function, and it works
11:26:49 <Blue_> However I need to write it in a different stype
11:26:50 <ertes> Blue_: what is Enumeration?
11:27:08 <Blue_> Its a function from Int -> [a]
11:27:10 <ertes> Enumeration a = Int -> [a]?
11:27:11 <ertes> ok
11:27:17 <Blue_> yes exactly
11:27:28 <Blue_> I need to write it in a style in which I don't take the n
11:27:32 <Blue_> functors maybe?
11:27:51 <Blue_> I can't understand really how to do that, I have an example of peano numbers written in that style
11:28:07 <ertes> Blue_: you always take the n…  you mean a style such that you don't write the n in the definition?
11:28:22 <Blue_> ertes, exactly
11:28:25 <ertes> that would be called point-free style
11:28:29 <Blue_> I'll post the sample I have
11:28:48 <ertes> well, you need *some* way to pattern-match on the n
11:29:03 <Blue_> this is a similar thing for peano numbers
11:29:06 <Blue_> http://lpaste.net/154561
11:29:47 <ertes> Blue_: your pastes are messed up somehow…  also they're incomplete
11:29:55 <Blue_> there is a lot of functions I didnt paste, however it illustrates the style I need
11:30:27 <ertes> your pastes should at least be *complete*, because auxiliary definitions matter
11:30:34 * hackagebot wai-middleware-metrics 0.2.3 - A WAI middleware to collect EKG request metrics  https://hackage.haskell.org/package/wai-middleware-metrics-0.2.3 (Helkafen)
11:30:38 <ertes> for example i can only guess what 'unionE' is
11:30:45 <Blue_> Ok, I can't paste everything. Just a sec
11:34:24 <Blue_> ertes: http://lpaste.net/154562
11:34:30 <Blue_> this is all of the code
11:36:00 <Blue_> So I can't figure a way yo do that in the same way for the trees
11:45:26 <mniip> so wait
11:45:30 <mniip> what's ~#
11:56:18 <lingxiao> hey all
11:56:32 <AleXoundOS> hi
12:05:35 * hackagebot foldl 1.1.6 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.1.6 (GabrielGonzalez)
12:09:33 <EvanR> man TMVar and TChan as a drop in replacement for MVar and Chan is really noisy with the atomicallys
12:10:38 <simpson> EvanR: But it gives you the flexibility to raise those `atomically` higher up, if you want to have bigger transactions that can violate the invariants while they're running.
12:10:54 <EvanR> i cant since there is interspersed IO
12:11:36 <simpson> Oh, yes. That's what `atomically` is for; it sequences STM actions with other IO actions.
12:11:52 <simpson> e.g. writing to a log after every storage transaction.
12:11:53 <EvanR> but i have the unfounded notion that TChan has better performance than Chan
12:12:44 <EvanR> screw it going back to non transactional
12:13:30 <EvanR> simpson: im basically using it on 1 stm action at a time, so its awful
12:15:49 <simpson> EvanR: No worries. Just keep building your building blocks and factor when you can.
12:17:54 <lewis1711> is there a function like "map", but isn't a bijection? I want to map over a list of elements, but sometimes there will be clusters of them, and I want to map those clusters to one thing
12:18:34 <EvanR> sounds like you either dont want to use a list, or you want to keep your list sorted then using group
12:18:39 <EvanR> use group
12:19:04 <ReinH> lewis1711: if you take a ~ [c], you get fmap :: ([c] -> b) -> [[c]] -> [b]
12:19:12 <ReinH> lewis1711: is that what you meant by "clustered"?
12:19:51 <roelof> simonmichel : are you here ? 
12:19:57 <ReinH> Otherwise, how do you define "clusters"?
12:20:22 <lewis1711> ReinH, what is the ~ notation? EvanR it's more for parsing. if I have a list of strings, I want to just map over them, but sometimes they represent delimeters
12:20:23 <EvanR> > map length . group . sort . map reverse $ ["pickles", "bananas", "smoked-sausage", "chirashi"]
12:20:24 <lambdabot>  [1,1,1,1]
12:20:27 <ReinH> lewis1711: type equality
12:20:33 <lewis1711> ah
12:20:43 <ReinH> lewis1711: how do you define "clustered"?
12:20:48 <EvanR> then you need a parser
12:20:54 <EvanR> :t sepBy
12:20:55 <lambdabot> Eq a => [a] -> [a] -> [[a]]
12:21:01 <EvanR> er
12:21:22 <lewis1711> I am already at that point. I have the lexemes
12:21:39 <EvanR> tokenizing! classic
12:21:43 <ReinH> lexing and parsing are different steps :)
12:21:53 <lewis1711> but then I have say ["foo", "=", "bar", ";"]
12:22:10 <ReinH> You have tokenized.
12:22:12 <ReinH> Now you need to parse.
12:22:12 <lewis1711> where "Foo" can just be mapped over lineraly, but the stuff inside of "=" and ";" is another separate thing
12:22:29 <lewis1711> I know how to do it with mutable data structures
12:22:33 <EvanR> > sepBy ["="] ["foo", "=", "bar", ";"]
12:22:35 <asdf__> Hello, can anyone point me in the right direction of exposing GHC's own unlit feature, so I can call it myself from haskell code?
12:22:35 <lambdabot>  [["foo"],["bar",";"]]
12:22:51 <ReinH> parser combinators don't only operate on strings
12:23:04 <ReinH> they operate on streams generically, so they can operate on token streams
12:23:21 <EvanR> i dont often tokenize, but when i do, my lexer is id
12:23:24 <ReinH> heh
12:23:41 <ReinH> So: you've tokenized your input, now you need to parse it.
12:24:04 <ReinH> You may find that tokenizing was unnecessary in the first place, and that you can more easily combine it with parsing into a single step.
12:24:21 <lewis1711> say something like, ["lol", "=", "lmao", "rofl", ";", "pi", "=", "3.14", ";"]
12:24:38 <lewis1711> yeah true
12:24:55 <ReinH> sepBy ; and then map sepby =
12:25:06 <ReinH> gets you lists of lists of pairs
12:25:20 <ReinH> well, of 2-element lists
12:25:39 <lewis1711> oh sepBy is in a library called parsec?
12:25:43 <EvanR> that tokenization is in a lost valley between using parser combinations of the string directly, and the classic [identifier, equals, identifier, identifier, semicolon, identifier, equals, floatliteral, semicolon]
12:25:47 <ReinH> it's in most parser combinator libraries
12:26:02 <EvanR> combinators*
12:26:07 <ReinH> EvanR: right, it wasn't lexed, it was just separated into tokens
12:26:21 <ReinH> which isn't very useful, really :)
12:26:32 <ReinH> you can easily tokenize during your parse
12:26:36 <ReinH> @hackage parsers
12:26:37 <lambdabot> http://hackage.haskell.org/package/parsers
12:26:41 <ReinH> has some nice combinators for dealing with tokens
12:27:03 <ReinH> that work with whichever parser library you want to use, Parsec, trifecta, etc
12:27:19 <lewis1711> I really don't need a parser library just for this surely
12:27:32 <ReinH> (trifecta is really nice for parsing programming languages because you get clang-style error messages for free)
12:27:52 <EvanR> a sequence of string = string; isnt that hard 
12:27:55 <EvanR> either way
12:27:59 * ReinH shrugs
12:28:01 <ReinH> you're parsing
12:28:07 <ReinH> if you want to do it manually, you can do that
12:28:24 <asdf__> Hello, can anyone point me in the right direction of exposing GHC's own unlit feature, so I can call it myself from haskell code?
12:28:31 <lewis1711> eh. my technique before was just to have flat IR, and let the VM deal with it
12:28:40 <lewis1711> but I will check out sepBy 
12:29:59 <ReinH> @hackage split
12:29:59 <lambdabot> http://hackage.haskell.org/package/split
12:30:03 <ReinH> lewis1711: maybe this is all you need ^
12:30:58 <ReinH> > map (splitOn "=") . splitOn ";" $ "foo=bar;bizz=bazz"
12:31:00 <lambdabot>  [["foo","bar"],["bizz","bazz"]]
12:32:15 <lewis1711> oh that is good
12:32:18 <ReinH> > concat . map (splitOn ["="]) . splitOn [";"] $ ["foo","=","bar",";","bizz","=","bazz"]
12:32:19 <lambdabot>  [["foo"],["bar"],["bizz"],["bazz"]]
12:32:37 <ReinH> same idea as with sepBy
12:33:00 <ReinH> > map ([x,y] -> (x,y)) . concat . map (splitOn ["="]) . splitOn [";"] $ ["foo","=","bar",";","bizz","=","bazz"]
12:33:01 <lambdabot>      Pattern syntax in expression context: [x, y] -> (x, y)
12:33:08 <ReinH> > map (\[x,y] -> (x,y)) . concat . map (splitOn ["="]) . splitOn [";"] $ ["foo","=","bar",";","bizz","=","bazz"]
12:33:09 <lambdabot>  [*Exception: <interactive>:3:6-20: Non-exhaustive patterns in lambda
12:33:14 <ReinH> anyway
12:40:03 <ertes> Blue_: pattern-matching and point-free style are basically conflicting notions…  you can use point-free style, but you basically just move the pattern-matching into a combinator
12:40:17 <ertes> see for example the 'maybe' combinator
12:40:19 <ertes> :t maybe
12:40:19 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:40:55 <ertes> instead of `f Nothing = n; f (Just x) = j x` you would then write `f = maybe n j`
12:41:34 <Blue_> I'm pretty new, so How would I write the function that I wrote, (I wrote it with pattern matching) in a point free style?
12:42:01 <broma0> with conduit, is there a blocking function that takes one element off a source?
12:43:10 <ertes> Blue_: by introducing a pattern-matching combinator for your type
12:43:25 <ertes> try to define `maybe` yourself
12:43:33 <ertes> it's the pattern-matching combinator for Maybe
12:43:56 <asdf__> Hello, can anyone point me in the right direction of exposing GHC's own unlit, so I can call it myself from haskell code?
12:44:18 <ertes> write a similar combinator for lists:  list :: (a -> [a] -> r) -> r -> [a] -> r
12:44:31 <ertes> then learn how to write such a combinator for your own type
12:44:55 <Blue_> thank you ertes
12:47:16 <broma0> how can i turn a conduit into a Concurrent.Chan?
12:48:32 <ertes> broma0: "turn into"?  try expressing the type of what you want
12:49:07 <dmj> broma0: you can probably write the contents of the conduit to a Chan with a Sink
12:49:13 <broma0> ertes: well my original desire was this function :: "takeOne :: Conduit () IO Int -> IO Int"
12:49:31 <broma0> ertes: and takeOne should block on no input
12:50:21 <Rotaerk> is there a simple way to emulate the behavior of "tail -f" in haskell?  particularly, read a file and subscribe to appends of that file, such that as lines are added to it, the line is read and appended to a list or something
12:50:57 <ertes> broma0: takeOne sounds more like a conduit itself to me
12:51:13 <ertes> takeOne :: (Monad m) => Conduit a m a
12:51:58 <Guest68531> Hi. Can someone tell me if it is possible to construct a function that can pattern match one of its arguments to be eiter [item] or http://en.wikipedia.org/wiki/Special:Search?go=Go&search=item? I guess it is not possible. Are there any alternatives to this approach?
12:52:19 <EvanR> Rotaerk: sounds like getContents, or forkIOing a thread to the read input file normally and signal a new line has been read, repeat
12:52:20 <broma0> ertes: http://lpaste.net/154571 - see what im trying to do? basically interleave a command prompt with a TCP client
12:52:21 <Guest68531> that link was supposed to be a list of lists of items
12:52:32 <EvanR> to read the*
12:52:56 <ReinH> Rotaerk: there's no easy way to do it, you basically have to stat the file in a loop and read if it increases.
12:52:59 <ertes> Rotaerk: no easy way, and in fact even tail's implementation is rather complicated
12:53:06 <EvanR> oh
12:53:17 <EvanR> thats awful!
12:53:23 <ReinH> And you have to be careful about avoiding busy wait in the loop that stats the file, etc
12:53:26 <EvanR> (also you can use file system events)
12:53:40 <Rotaerk> hmm k; maybe I'll just read stdin instead, and pipe tail -f into my program
12:54:13 <Rotaerk> just trying to build a client for ii :P
12:54:21 <Rotaerk> or rather, a GUI
12:54:46 <ReinH> ii?
12:55:13 <ReinH> If you're on linux, you can use HInotify.
12:55:14 <Rotaerk> ReinH: http://tools.suckless.org/ii/
12:55:32 <Rotaerk> IRC-client-as-a-local-service
12:55:33 <ReinH> Rotaerk: oh right
12:55:43 <Rotaerk> and then I can have multiple UI's to interact with it
12:55:45 <ReinH> I remember now
12:56:27 <ertes> broma0: sorry, i'm not that fluent in conduit, but if takeOne should do what its name suggests, then it should really just be a conduit
12:56:31 <ReinH> you probably want to look at using inotify
12:56:41 <ertes> (or a pipe, or an enumeratee, or …)
12:57:12 <ertes> ReinH, Rotaerk: if you decide to do it by hand, you can at least make it portable by using fsnotify (rather then inotify)
12:57:34 <ReinH> @hackage fsnotify -- purports to be portable
12:57:34 <lambdabot> http://hackage.haskell.org/package/fsnotify -- purports to be portable
12:57:40 <Rotaerk> I'm not stuck on ii; if having out as a file rather than named pipe is inconvenient, I can write my own ii-like thing
12:58:20 <Rotaerk> ertes: could you elaborate on what you meant by using pipe instead of inotify?  is that just the idea of piping tail -f into my program?
12:58:36 <Rotaerk> or is that ... having the irc-client-service write to a named pipe instead of to a file
12:58:42 <Rotaerk> and then reading that named pipe
12:58:52 <ertes> Rotaerk: the pipe part was for broma0, not for you =)
12:58:56 <Rotaerk> ahh k
13:03:06 <mniip> can someone explain, or link me to an explanation of this coercion stuff in GHC?
13:06:27 <lyxia> Data.coerce?
13:06:32 <mniip> no
13:07:43 <lyxia> unsafeCoerce?
13:09:36 <mniip> lyxia, no it's a typechecker thing I think
13:09:37 <thoughtpolice> mniip: If you mean 'coercions' in the context of the Core language - they're the way GHC implements features like type equality and GADTs.
13:10:08 <mniip> oh
13:10:30 <mniip> so like Num a is internally an implicit argument containing a dictionary of Num functions,
13:10:46 <mniip> a ~ b is a similar dictionary with coercion functions? 
13:11:28 <thoughtpolice> If you have a GADT like 'data Foo a where Baz :: Foo Int; Bar :: Foo Bool', you have a GADT where the 'a' is constrainted to 'Int' whenever you have a Baz, and 'Bool' when you have a 'Bar'. You can write this another way: data Foo a = { (a ~ Int) => Baz a | (a ~ Bool) => Bar b }, so essentially a GADT is some sugar for an ADT, where each constructor carries
13:11:29 <thoughtpolice> a type equality.
13:12:57 <mniip> right
13:12:59 <mniip> I see that, yes
13:13:00 <thoughtpolice> So now imagine you pattern match on 'Foo a', where each alternative match fixes 'a' to a different type. When GHC translates this to core, those type equalities become coercions. And the coercions establish facts like 'a ~ Int',
13:13:21 <thoughtpolice> The System FC paper is probably the best read for the basics on how GHC uses them: http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/fc-tldi.pdf
13:14:29 <mniip> thanks
13:14:49 <thoughtpolice> The first/second page basically gives the exact example above, FWIW
13:14:55 <thoughtpolice> With an example of the core
13:15:47 <mniip> thoughtpolice, and what are "unlifted" equalities?
13:16:25 <thoughtpolice> Type equality between unlifted types.
13:17:17 <thoughtpolice> Right now, (~) is really a kind of type-level magical operator, so it actually has a kind. It looks something like,
13:17:26 <thoughtpolice> (~) :: forall k. k -> k -> Constraint
13:17:58 <mniip> and why can't we just use it with k ~ # ?
13:19:20 <augur> anyone know how to reduce backtracking overlap in parsec?
13:19:35 <puregreen> are there any attoparsec vs parsec benchmarks?
13:19:57 <mniip> thoughtpolice, I mean we can already use ~ at higher (arrowed) kinds
13:19:58 <Zemyla> Are there ways to construct Read and Show instances simultaneously in such a way that they're guaranteed to stay in sync?
13:20:16 <augur> like when you have multiple rules that have the same prefix??   eg    a -> (x|w|z) q    b -> (x|w|z) r    c -> (x|y|z) s
13:20:21 <ertes> Zemyla: derived instances should have that
13:20:55 <Zemyla> ertes: I mean if you can't derive them and need to construct them manually.
13:20:55 <augur> er, s/w/y/   :(
13:21:00 <thoughtpolice> mniip: To completely handwave it: because reasons, that have to do with the way GHC internally works. Right now GHC only reasons about lifted equalities, IIRC.
13:21:27 <augur> if you try to then parse with   a|b|c   and the actual string is "zs"  this is obviously going to do a lot of nasty backtracking
13:21:30 <ertes> Zemyla: there are libraries to construct parser-printers, like boomerang
13:21:49 <mniip> thoughtpolice, well that kinda makes sense, because we can't have a quantified unlifted type
13:21:53 <ertes> Zemyla: if you don't want to use such a library, then your best bet is careful programming and a test suite
13:22:03 <augur> what's the smart/conventional way to do this???
13:22:17 <thoughtpolice> Higher-kinds or polymorphic kinded things are OK. In GHC 8.0, we can even establish a kind of 'heterogeneous type equality', but I'm not sure how levity polymorphism and all the new machinery people are thinking about for unlifted types fits in.
13:22:27 <puregreen> augur: there's probably nothing you can do apart from factoring x|y|z out
13:22:30 <thoughtpolice> But I think unlifted things are still out. Richard would know more about this.
13:23:43 <augur> puregreen: that wont fix it tho. i mean, if you define   f -> x|y|z   and replace x|y|z with f in those rules, you still have to try f each time. that's just code refactoring, not process refactoring
13:24:13 <puregreen> no, I meant “p = x|y|z q|r|s”
13:24:43 <thoughtpolice> mniip: Oh, it might work in GHC 8.0, but not with ~, sorry, I forgot about that. You have to use ~# I think.
13:25:18 <thoughtpolice> Yes, so now we have ~#, ~~ and ~, and (~~) and (~) are built on ~#, I think.
13:25:25 <augur> puregreen: oh i see. well, that wont work either, i think, at least not directly, since you might not have a, b, and c all showing up in the same places
13:26:17 <mniip> ooh
13:26:29 <mniip> the levity stuff is different in 8.1
13:27:02 <mniip> so, all unboxed types have their own kind now?
13:27:03 <infinity0> is there a standard name for this operator: let (xx) f g = \ (x, y) -> (f x, g y)
13:27:14 <mniip> infinity0, bimap
13:28:11 <ertes> there is also (***) in another thread of generalisation
13:29:45 <infinity0> ah, thanks
13:31:06 <EvanR> er 8.1?
13:31:17 <EvanR> what happened to 8.0 did it go the way of windows 9
13:32:25 <nocturne777> when people put stuff into folder "Internal",  does it  mean that library users should not directly refer to the modules under Internal to avoid breakage?
13:33:01 <ertes> nocturne777: it means that the stuff there is internal, for some meaning of that word
13:33:24 <ertes> usually it means 'unsafe', either in terms of code safety or API stability
13:33:55 <nocturne777> OK, so to differentiate the between public and internal API 
13:34:23 <mniip> depends on the use case
13:35:04 <ertes> as an author when you put something into an .Internal module, you express something along the lines of: "i don't recommend using this directly, but i acknowledge that it might come in handy in some cases"
13:35:33 <mniip> consider a package that provides a datatype that has a strong invariant
13:35:36 <nocturne777> ertes: that makes sense
13:35:54 <mniip> you can use smart constructors and not export the actual constructor, to preserve the invariant
13:36:23 <mniip> but a smarter move would be to define your datatype in an Internal module
13:36:29 <ertes> as a user when you see an .Internal module, you would avoid it unless your use case requires temporary violation of some assumption or invariant
13:36:35 <mniip> so that if someone really wants to do shady stuff - they are able to
13:45:54 <nocturne777> thanks for the explanation
14:00:39 * hackagebot lp-diagrams-svg 1.1 - SVG Backend for lp-diagrams  https://hackage.haskell.org/package/lp-diagrams-svg-1.1 (JeanPhilippeBernardy)
14:00:41 * hackagebot lp-diagrams 2.0.0 - An EDSL for diagrams based based on linear constraints  https://hackage.haskell.org/package/lp-diagrams-2.0.0 (JeanPhilippeBernardy)
14:05:15 <parsecChar> I have a ghc+ghcjs setup in stack. "stack --stack-yaml=server/stack.yaml build" works, but "stack --stack-yaml=server/stack.yaml ghci" can't find the corresponding modules.
14:09:57 <mgsloan> parsecChar: Is there output above the bit where it can't find modules?
14:10:40 <mgsloan> Usually what happens is that "stack ghci" tells you various reasons why doing the load might be problematic, and then goes ahead with it.  If there's an issue loading a module, the ghci-script will constinue running and attempt to import it
14:11:06 <mgsloan> But since the module didn't get loaded, it'll appear to be missing
14:11:52 <mgsloan> Note that stack ghci by default loads up all of your library targets.  This isn't possible in general, but works in many cases
14:16:15 <Rotaerk> hmm think I might make my own IRC client as local service
14:16:55 <Rotaerk> files seem to be kind of a sloppy mechanism for communicating a stream of data, such as IRC messages
14:17:33 <Rotaerk> since even if I'm notified that a file is changed, I still have to re-open the file, seek to the position I was at before, and read until then end
14:17:52 <Rotaerk> when I could just use a better mechanism for streaming data
14:19:10 <Rotaerk> fifo seems better for that, but either I'm doing something wrong, or there can't be multiple readers for a fifo
14:19:27 <mniip> ghc-cabal: Version mismatch between ghc and ghc-pkg: /home/mniip/r/ghc/inplace/bin/ghc-stage1 is version 8.1.20160311 /home/mniip/r/ghc/inplace/bin/ghc-pkg is version 8.1.20160312
14:19:34 <mniip> do I have to recompile stage1 every day :(
14:20:13 <ertes> Rotaerk: you're trying to build some kind of IPC?
14:21:04 <Rotaerk> ertes: in general, I like the idea of an IRC client running locally, and allowing multiple processes to read from channels and write to channels
14:21:34 <Rotaerk> ertes: the particular mechanism that ii uses is that I send my messages to a FIFO, which ii reads and sends over the network
14:21:42 <Rotaerk> and messages from the channel get dumped into an out file
14:21:52 <mniip> Rotaerk, are you planning to have one process for each channel or something?
14:22:06 <ertes> Rotaerk: that seems pretty ugly…  it's probably better solved using sockets
14:22:11 <Rotaerk> but if I just want to "listen" for new messages, monitoring for changes to that out file seems like a sloppy approach
14:22:19 <mniip> you want unix domain sockets
14:22:26 <Rotaerk> okay, thanks, I'll look into that
14:22:37 <ertes> seconded, use unix sockets
14:22:51 <mniip> they're a hybrid of files, sockets, pipes and something else
14:23:13 <ertes> (bonus: you can turn it into a fully fledged TCP server easily later)
14:23:13 <Rotaerk> and yea, I might have one process per channel; or more... I'm envisioning being able to open a new window anywhere I am, check the messages, send some messages, close the window, and it's still running in the background
14:23:31 <Rotaerk> and then maybe my status bar (xmobar) will monitor this as well to notify me of messages
14:23:35 <ertes> one process per channel might be difficult, unless you're prepared for some IPC
14:23:46 <parsecChar> mgsloan: http://stackoverflow.com/questions/26419321/ghci-cannot-find-modules-of-my-program appears to have fixed it
14:23:47 <Rotaerk> IPC is fine
14:23:50 <ertes> IRC requires some connection-global state
14:23:58 <mniip> Rotaerk, that seems excessive
14:24:08 <geekosaur> for xmobar you probably want fifo support. (be warned that fifos are nonintuitive at best)
14:24:21 <mniip> I have so many channels but my PID table is only so large
14:24:22 <ertes> rather than processes consider using haskell concurrency
14:24:26 <parsecChar> how are fifo's nonintuitive? first in first out ....
14:24:39 <mniip> parsecChar, he means linux pipes
14:24:58 <geekosaur> the POSIX fifo (named pipe) has a bunch of gotchas
14:25:20 <mniip> ah, they're posix?
14:25:20 <parsecChar> mniip: yeah, I've used linux fifos, and have not run into especially weird problems
14:25:24 <Rotaerk> ertes: it would be one process for the entire service connecting to IRC
14:25:26 <parsecChar> though maybe pain tolerance increased
14:25:35 <Rotaerk> but then I would have one process per GUI instance connected to that service
14:25:41 <geekosaur> depending on what you did, you might well not notice them
14:25:48 <Rotaerk> and I would probably, for simplicity sake, only connect to one channel per GUI
14:25:55 <ertes> Rotaerk: that seems fine, as long as you don't have any shared state
14:25:59 <ertes> IPC is horrible
14:26:23 <Rotaerk> the GUI is only intended to read the messages being pumped out from the service, and writing my messages to the service
14:26:42 <Rotaerk> and then I might have other GUIs for, say, getting user list in a convenient format or something
14:26:53 <mniip> Rotaerk, how many channels are you in currently?
14:26:56 <geekosaur> but for example, once you read EOF on one you must close and reopen to clear it (and will block on the open until a writer opens it). if you open O_RDWR to avoid this then you will never see when a writer disconnects
14:26:58 <ertes> Rotaerk: you might be interested in distributed-process (a.k.a. Cloud Haskell)
14:27:26 <geekosaur> this is actually consistent if you understand that it is truly a named pipe, but inconsistent if you are thinking of it as a socket-alike which is what most people tend to expect when using them
14:27:36 <geekosaur> programmatically
14:27:37 <Rotaerk> mniip: not many right now; I'm using mibbit and webchat :P but normally... maybe 10ish?
14:27:59 <Rotaerk> ertes: I'll look into that
14:28:02 <mniip> geekosaur, named pipe(2) you mean?
14:28:29 <geekosaur> mniip, man 7 fifo
14:28:44 <geekosaur> (on linux; manpage will vary in name and section on other OSes)
14:29:58 <geekosaur> an older linux implementation also did fun things like decide that if you did a non-blocking open, it would not be counted as an open as far as the other side was concerned (that is, the open would never actually complete)
14:30:29 <ravst> hi I have problem when writing the .cabal file. I want to add there information that the build needs the hprotoc binary in order to succeed. I added in in the build-tools section but I get an error "Unknown build tool hprotoc" . How can I fix that?
14:30:36 <ertes> if i were to write an IRC client in haskell, it's probably no surprise that i would do it with FRP
14:32:36 <mniip> Rotaerk, that explains your naive approach ;)
14:33:33 <Rotaerk> mniip: you referring to my question in #archlinux? :P
14:34:49 <mniip> no, about the 1 process per channel thing :)
14:35:10 <nocturne777> do most people now prefer Control.Exceptions over Control.Exception.Lifted ?
14:36:09 <ertes> nocturne777: do you understand the difference?
14:36:25 <ertes> (i'm assuming that you meant Control.Exception)
14:36:41 <Rotaerk> mniip: I'm just exploring the notion of breaking functionality outside of the notion of a containing "app"
14:36:50 <nocturne777> ertes: I meant the exceptions package 
14:36:58 <Rotaerk> and instead having the functionality running in the background, with multiple interfaces to it
14:37:06 <Rotaerk> which seems to necessitate multiple processes
14:37:18 <Rotaerk> (one per interface)
14:37:18 <ertes> nocturne777: ok, then it's not a matter of preference
14:37:30 <ertes> nocturne777: they are different points in the abstraction space
14:37:39 <mniip> I have 90 processes on my laptop right now, and that count would more than double if I had a process for every channel I'm in ;)
14:37:50 <ertes> nocturne777: in particular monad-control is much much much more general than exceptions
14:37:57 <geekosaur> mniip, perhaps a channel here is not an IRC channel but a client connection?
14:38:02 <Rotaerk> mniip: is process *count* something I should be concerned about?
14:38:18 <mniip> I think yes
14:38:18 <Rotaerk> mniip: also, in no way would I have a GUI open for every channel
14:38:18 <nocturne777> ertes: what I see is that  both "exceptions" package and "lifted-base" allow one to lift exceptions into the monad stack 
14:38:37 <Rotaerk> I would open a GUI for a channel, use it, then close it, or just leave it open to watch it
14:38:43 <Rotaerk> but I wouldn't be watching 90 channels at once
14:38:54 <Rotaerk> so I'd only have a GUI open per channel I'm currently focused on
14:38:55 <ertes> nocturne777: in general if you can use exceptions, you might have an easier time, plus more instances to choose from
14:39:22 <ertes> nocturne777: if you need the generality of monad-control, you'll use that one
14:39:43 <Rotaerk> to me it makes sense to let my window manager handle switching between channels, rather than having window-management built into every application
14:39:48 <nocturne777> ertes: I want to use the exceptions, but the thing is my moand stack (ReaderT AppConfig (ExceptT ServantErr IO) a) does not allow me to use MonadMask
14:39:51 <Rotaerk> (I don't use windows within vim... I just open a new vim instance)
14:40:15 <ertes> Rotaerk: makes sense, but that has little to do with processes
14:40:50 <mniip> Rotaerk, I have a nifty map of channel activity in the channel switcher
14:41:04 <Rotaerk> ertes: I suppose if there's a way to tell a singular background process to spawn windows for me on demand, then I could live with one process
14:41:07 <mniip> so I can see when there's activity in some channel, and look at if if I have to
14:41:27 <Rotaerk> mniip: I would probably make a separate GUI for providing a high level overview of channels like that
14:41:44 <ertes> Rotaerk: emacs sometimes has dozens of windows here
14:41:57 <ertes> in fact just today it has overtaken IRC =)
14:42:27 <nocturne777> ertes: so, in some cases I won't be able to put stuff in "finally"
14:42:31 <Rotaerk> ertes: do you actually need that many? or do you just get lazy and not clean-up after yourself :P
14:42:48 <Rotaerk> (I've had lots of windows open but usually it's because I forgot about closing them; not actually USING them anymore)
14:43:00 <kadoban> Can't emacs do tabs or whatever?
14:43:16 <ertes> Rotaerk: i tend to garbage-collect when my RAM runs full…  otherwise there is usually little reason to close any window
14:43:17 <sidoaight> Tabs would just be a minibuffer that lists open buffers /joke
14:43:55 <mniip> does it include itself?
14:44:16 * mniip . o O ( is there a buffer that lists all buffers that include themselves? )
14:44:29 <mniip> er
14:44:32 <monochrom> yes
14:44:33 <mniip> don't include themselves
14:44:34 <ertes> mniip: yes
14:44:44 * sidoaight giggles aloud
14:45:18 <ertes> in that case i have no answer for you =)
14:45:41 <ertes> need buffer levels
14:46:05 * geekosaur will stick with his earlier comment; multiple irc channel support can be done by the client, either in tabs or multiple windows but with a single (quite possibly multithreaded) process
14:46:54 <monochrom> tomorrow someone will implement one virtual machine per irc channel
14:46:55 <geekosaur> ...note that this can be used as one process per channel if you really must, while not requiring that model
14:47:13 <geekosaur> monochrom, there's probably already a systemd plugin for it >.>
14:47:24 <glguy> monochrom: Perhaps using HaLVM and running them on Xen?
14:47:24 <ertes> plugin?  come on…  it's built-in
14:47:28 <geekosaur> using docker of course
14:48:43 <Rotaerk> geekosaur: i'll look into a way to have a background process that I can send a command to and have it spawn a window, within the same process
14:48:49 <Rotaerk> if that's possible, I'm content with one process
14:50:03 <geekosaur> that's pretty much a normal thing in most window systems/libraries
14:50:25 <Rotaerk> I just want to be able to, say, run a command like "irc freenode #haskell", and then that creates a window to show the channel
14:50:33 <Rotaerk> (but this doesn't *join* the channel; that's already joined in the background)
14:51:19 <geekosaur> for example both windows explorer and unix file managers have a background component that listens for "open a window on this folder"
14:51:33 <ertes> Rotaerk: there are many ways to design such an application
14:51:45 <ertes> server-daemon + client-daemon + client-control-program
14:52:06 <ertes> application-daemon (both network and GUI) + control-program
14:52:11 <ertes> firefox is an example of the latter
14:52:31 <ertes> server-daemon + client-program (e.g. quassel)
14:52:37 <Rotaerk> I'd probably go with the former, because not all "clients" to the server are going to be the same type of thing
14:53:00 <Rotaerk> server-daemon, possibly multiple client daemons, and corresponding client programs
14:53:02 <ertes> you still need to choose whether you want to model the client as a daemon itself
14:53:12 <ertes> otherwise you're going to have a multi-process application anyway
14:53:28 <geekosaur> and there's irc clients that already do this (smuxi, quassel) as well as wrappers that do it with irssi
14:53:37 <ertes> if you want a single-process client, then you need a short-lived control program
14:54:53 <Rotaerk> k, thanks; you've given me good ideas; just need to figure out the how...
14:54:59 <mniip> ohhhh
14:55:04 <mniip> it makes sense now
14:55:17 <Rotaerk> what does
14:56:18 <mniip> data D a where D :: Int -> D Int
14:56:35 <mniip> it's just D :: forall a. (a <-> Int) -> Int -> D a
14:56:44 <mniip> where a <-> b = (a -> b, b -> a)
14:57:30 <mniip> and 'D 3' is actually 'D (id, id) 3'
14:57:35 <mniip> which makes total sense
14:57:49 <ertes> mniip: here is the CPS form of that one:  newtype D a = D { runD :: forall r. ((a ~ Int) => a -> r) -> r }
14:58:00 <mniip> yup
14:58:05 <dmj`> why is newIORef undefined >>= readIORef a no-op ?
14:58:23 <mniip> dmj`, what?
14:58:42 <dmj`> I'd assume it would exception
14:58:45 <ertes> dmj`: semantically it seems equivalent to `pure undefined`
14:58:49 <mniip> ^
14:59:02 <ertes> dmj`: `pure undefined` is not the same as `undefined`
14:59:15 <glguy> IORefs aren't strict, putting undefined into/taking it out of one is ok
14:59:16 <hiptobecubic> ertes, "firefox is an example of the latter"  How so?
14:59:27 <ertes> the former is a working action that returns `undefined`, while the latter is an undefined action (→ exception)
14:59:53 <ertes> hiptobecubic: firefox -remote
14:59:59 <dmj`> glguy: I see, hadn't seen that before. k :: GHC.Prim.Any <- newIORef undefined >>=readIORef
15:00:12 <hiptobecubic> ertes, oh right.
15:00:14 <dmj`> evaluting k does eventually explode
15:01:29 <dmj`> I guess I expected it to explode in ghci
15:01:47 <ertes> dmj`: try this:  yourStuff >>= (pure $!)
15:01:50 <dmj`> since I thought 'print' get's called implicitly
15:01:52 <ertes> that one will explode
15:01:56 <dmj`> λ: print =<< do newIORef undefined >>= readIORef, blows up
15:03:38 <ertes> > runST $ do newSTRef undefined >>= readSTRef
15:03:40 <lambdabot>  *Exception: Prelude.undefined
15:03:47 <glguy> dmj`: GHCi doesn' try to print Any or (), it will print Int, though
15:03:48 <ertes> > runST $ do newSTRef undefined >>= readSTRef >> pure ()
15:03:49 <lambdabot>  ()
15:03:57 <dmj`> glguy: ah, that explains it, thanks
15:04:01 <ertes> > runST $ do newSTRef undefined >>= readSTRef >>= (pure $!)
15:04:03 <lambdabot>  *Exception: Prelude.undefined
15:04:11 <ertes> > runST $ do newSTRef undefined >>= readSTRef >>= (pure $!) >> pure ()
15:04:12 <lambdabot>  *Exception: Prelude.undefined
15:09:10 <Rotaerk> ertes: is cloud haskell still worth looking into if I only intend for all these components to be running on one machine
15:09:25 <Rotaerk> (well, probably still worth looking into *in general*, but is it relevant)
15:09:42 <ertes> Rotaerk: yes, it frees you from the low-level nightmares of IPC
15:09:46 <Rotaerk> k
15:09:52 <Rotaerk> cool
15:10:15 <ertes> in particular it makes the otherwise completely stringly-typed communication mostly transparent
15:11:11 <ertes> also it helps you deal with exceptions properly (imagine one process got SIGKILLed)
15:14:27 <parsecChar> ghcjs-dom
15:14:32 <parsecChar> is tnere a nice way to include it in a ghc object?
15:14:41 <parsecChar> i'm getting into all types of webkitgtk-3 issues
15:14:52 <parsecChar> I just want ghcjs-dom to be included in my ghc project so I can type check the code w/o running ghcjs
15:15:02 <parsecChar> since ghci reload is faster than rerunning ghcjs for type cehcking code
15:15:48 <Rotaerk> a program using ghcjs-dom can be compiled with ghc
15:16:13 <Rotaerk> that's what I'm doing for my GUIs
15:17:03 <tomus> youcompleteme: no semantic completers for filetypes ['haskell'] <- have you ever seen this? omnifunc is set to necoghc#omnifunct
15:17:14 <parsecChar> Rotaerk: what linux distro are you on?
15:17:34 <parsecChar> i'm having trouble installing ghcjs-dom 0.2.3.1 via stack on latest ubuntu 
15:17:50 <parsecChar> in particular, I run into webkitgtk / pangocairo (the native pacakges, not haskell bindings) problems
15:17:53 <ertes> parsecChar: i don't know if that's going to help, but ghcjs-dom has a gtk3 flag that's enabled by default
15:18:27 <parsecChar> ertes: I dunno either ; I just want it to compile for type checking purposes
15:18:45 <ertes> parsecChar: try playing around with the flags
15:24:04 <kadoban> You shouldn't need to mess with the flags, you probably just have to install the native -dev packages in ubuntu
15:24:16 <kadoban> At least that's what worked for me getting ghcjs-dom installed.
15:25:49 <tomus> ghc-mod: cabal-helper-wrapper: /home/tom/haskell-parser/Cabal.cabal: openFile: does not exist (No such file or directory)
15:25:54 <tomus> why should Cabal.cabal exist?
15:29:55 <tomus> cabal clean worked
15:30:02 <tomus> don't know what the fuck is going on
15:30:30 <tomus> I am getting very good at debuggin vim + ycm + ghc-mod though
15:31:04 * tomus should've learned C# and filed a bug with MS if VS was playing up
15:33:23 <thewormkill> hello everyone, I am currently working on providing bindings to a medium-sized C library. Thus, early in the process, I decided to use c2hs to do the heavy lifting. This works out well, but said library uses anonymous unions from C11, which language-c (that is used by c2hs) doesn't support. Thus, I need to resort to ugly hacks to get the appropriate members when writing my `Storable` instances. That's the
15:33:26 <thewormkill> point where the alignment of C structures bites me, obviously :P. Anyone a general idea on how I should handle that case? Experience/tips regarding tooling etc. maybe?
15:39:42 <EvanR> ertes: i am quite enjoying the nightmares of IPC right now
15:39:57 <EvanR> i didnt even know you could send an FD over a socket
15:40:44 <ertes> that stuff is actually quite useful if you do unixy things like upgrading an application in-place
15:40:58 <ertes> without losing state that is
15:42:41 <EvanR> heh
15:42:57 <EvanR> upgrading, sending all my connections over a socket to a lifeboat process
15:43:07 <EvanR> upgraded, can i have all my connections back
15:43:41 <ertes> or just pass them to the new process directly
15:43:55 <EvanR> does this actually work
15:43:59 <ertes> yes
15:44:08 <hiptobecubic> Yes but you have to be drunk
15:44:26 <EvanR> two processes can communicate with a connected part at the same time?
15:44:29 <EvanR> party
15:44:33 <ertes> EvanR: working with skarnet software makes you believe in that stuff =)
15:44:54 <ertes> especially with execline and s6
15:46:22 * EvanR imagining 1 program replace itself without interrupting the X window
15:47:03 <EvanR> this opens up whole new possibilities!
15:47:44 <ertes> EvanR: no trouble at all, if the old process can communicate all necessary state
15:55:00 <geekosaur> if you're using xcb (or xhb) which doesn't (or shouldn't) hide state where you can't get at it, you should be able to pass your display fd and your state to another process. this won't work with xlib, it has too much hidden state
15:56:21 <ertes> i don't know how well the RTS plays along though
15:57:23 <ertes> there might be some gotchas particularly with the threaded RTS
15:59:28 <EvanR> how would threaded RTS ruin something
16:01:34 <ertes> not sure, but it's highly stateful, and there is probably no easy way to transfer that state…  i guess it shouldn't affect execve-ing though…  you need to reconstruct your application state after the exec anyway
16:02:28 <ertes> it's just an intuitive feeling that the threaded RTS may have some gotchas, if you do…  you know…  unix
16:03:25 <EvanR> opengl uses thread local state, but not sure about X
16:07:52 <ertes> EvanR: X is a network protocol, so the only thing that might be in your way is the X library you use
16:08:12 <ertes> unless you use some extensions with direct memory access
16:08:24 <geekosaur> most of that state is related to thinks that you would have to transfer over (fds, which you'd open Handles on and then the rts knows about them), or things that would have to be torn down in the old process and recreated in the new (such as threads themselves)
16:12:19 <EvanR> is there a way to get opengl to cooperate?
16:13:01 <EvanR> sendGlContext(x)
16:14:54 <geekosaur> I doubt it
16:15:21 <geekosaur> you have zero visibility into what e.g. nvidia's opengl glue does
16:15:49 <EvanR> spooky
16:16:04 <ertes> OpenGL has an incredibly wrong mix of too-high-level-where-it-should-be-low-level and vice versa
16:16:34 <desophos> has anyone here used stack's docker integration? i'm getting a SQLite3 ReadOnlyError when trying to stack build after enabling docker in a stack project in a VM shared folder
16:17:40 <desophos> a folder shared from the host OS to the guest OS, that is
16:22:20 <Rotaerk> those of you who use arch linux ... do you recommend the ArchHaskell route?
16:22:38 <Rotaerk> or just use the official repository and cabal
16:25:44 <thewormkill> Rotaerk: well, I personally use stack on arch and avoid installing things via cabal
16:26:35 <Rotaerk> ah, I actually just ran across that when looking into cloud haskell; didn't realize it handled things at that level
16:26:40 <thewormkill> so dependencies for my projects are local to the project and things in the official repos might have dependencies in haskell-* packages, for instance pandoc
16:26:54 <ertes> there is also nix, which is among other things cabal-sandbox on steroids
16:27:05 <Rotaerk> did you install anything of haskell manually outside of stack? or *just* setup stack and then let it handle everything else?
16:27:27 <thewormkill> Rotaerk: for code I *write* I only use stack
16:27:38 <Rotaerk> I see
16:27:42 <thewormkill> for code I use (like pandoc), I use system-wide packages
16:27:55 <Rotaerk> k, makes sense
16:28:00 <thewormkill> and the tools I've written I can install as a user via stack as well
16:30:03 <Rotaerk> seems lix nix and stack overlap in their purpose, though this one article seems to indicate they can work together
16:30:40 <Rotaerk> soo much to learn, so little time
16:30:48 <andromeda-galaxy> With GHC 7.10, is there any way to get a promoted type constructor that has type arguments?  In GHC8 I can do 'data Foo = Foo Type', but that doesn't work with 7.10...
16:31:18 <ertes> Rotaerk: they don't really overlap, as stack seems to be about version/API stability, while Nix is more a generalisation of many concepts like package management, deployment, build environments, etc.
16:31:29 <Rotaerk> ah
16:31:43 <ertes> in particular when you develop with Nix, you don't actually use cabal-install at all
16:32:02 <Rotaerk> hmm I see; I'll try using both then
16:32:38 <fr33domlover> Is there a monadic loop function which (1) executes an action repeatedly until some condition occurs (2) combines the results in some way (e.g. a list) and returns them?
16:32:55 <fr33domlover> [i prefer to reuse if such a thing is available)
16:33:06 <Rotaerk> sequence?
16:33:24 <simpson> fr33domlover: There's a pile of those sorts of functions here: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
16:33:30 <ertes> fr33domlover: nothing predefined, and those two things should really be separate anyway
16:33:49 <ertes> fr33domlover: i'd probably use a streaming abstraction in that case; at least something like the foldl library
16:34:14 <fr33domlover> simpson, ertes, thanks
16:36:45 <ertes> Monad-loops: The Problems of the Past Reloaded
16:40:58 <Cale> fr33domlover: The trouble is that there are so many close variations on such things, that just writing the recursion can often be clearer.
16:41:49 <andromeda-galaxy> oh never mind, data Foo = MkFoo :: a -> Foo works
16:42:32 <Cale> andromeda-galaxy: wait, what? That looks like a syntax error to me
16:49:40 <fr33domlover> Cale, yeah, if it's not something people recognize it's less readable than recursion. A design pattern is much more useful when many people know it :P
16:55:56 <andromeda-galaxy> am I correct in thinking that with GHC 7.0 there's no way to get a promoted version of something like 'data Foo where MkFoo :: Ord a => a -> Symbol -> Foo'?
16:57:11 <mniip> that's right
16:57:31 <mniip> promotable GADTs are only in 8.0 iirc
16:57:38 <ertes> with constraints?
16:59:12 <mniip>     • Illegal constraint in a type: Show a0
16:59:13 <mniip> apparently not
16:59:47 <ertes> that would be very surprising, as GHC 8 doesn't introduce a level above kinds as far as i know
17:00:57 <mniip> ertes, it doesn't even introduce kinds
17:01:05 <mniip> kinds are just types!
17:01:12 <mniip> * :: *
17:01:33 <ertes> at some point we should probably just get -XDependentTypes instead of duplicating more and more of the value language in the type language
17:01:57 <mniip> I'm not too sure that'll ever happen
17:02:51 <ertes> IIRC they are working on it
17:03:01 <ertes> i even remember watching a talk about it
17:03:44 <EvanR> 8 deletes kinds rather than adding more levels
17:04:07 <EvanR> as part of a dependent types flagship agenda
17:04:34 <ertes> that's good and bad news i guess
17:05:20 <EvanR> * :: * looks funny (Type :: Type i guess with -XTypeInType) but the issue tracker seems to claim that this is not a problem
17:05:33 <ertes> not for programmers
17:05:39 <ertes> for mathematicians it's definitely a problem
17:05:44 <EvanR> theres some kind of trick that saves ghc from girards paradox
17:07:07 <danilo2> Hello guys! Does anybody use stack to run benchmarks? I've defined benchmarks suites in cabal config and when I run stack bench I see that the benchmark files get compiled but no benchmark is beingg run. In fact I get output "<pkg name> : benchmarks" and nothing more
17:17:09 <Wizek_> Hello! is there a way to see what is taking up how much space in an executable compiled by GHC? 
17:17:35 <Wizek_> I have a binary that is around 31 MB, and I wish to see if there is any way I may reduce it.
17:18:18 <amateur> you mean how much each function etc. takes up?
17:19:47 <Wizek> Hmm, that might be a good start, yes.
17:20:18 <Wizek> I am not sure how much of an overview that would provide since I imagine individual functions may not take up much
17:20:39 <amateur> that's most likely true yes
17:21:03 <Wizek> Maybe modules? Or like a hierarchy tree of dependencies, if that is even possible
17:21:34 <amateur> check this article out: http://book.realworldhaskell.org/read/profiling-and-optimization.html
17:21:43 <amateur> go to the section "Space profiling"
17:22:15 <amateur> ahem
17:22:18 <Wizek> checking
17:22:20 <amateur> i think i fucked up
17:22:29 <amateur> this is memory usage
17:22:32 <amateur> not disk
17:22:36 <Wizek> seems so
17:22:37 <Cale> Yeah, that's runtime space usage
17:22:53 <Cale> If you'd like to reduce the disk usage of your Haskell programs, you can turn on split objects
17:23:16 <Cale> But that will make the binaries less portable, since you'll need to carry over the shared objects
17:23:30 <Cale> The reason the binaries are so large is that they're statically linked
17:23:35 <Cale> (for the most part)
17:24:02 <amateur> you could try cmpile flag -dynamic
17:24:06 <Cale> yeah
17:24:07 <amateur> not sure if that's a good idea though
17:24:29 <mniip> hey Cale
17:24:34 <Cale> mniip: hi
17:24:48 <Wizek> Well, but even then wouldn't I need to carry the exact same amount of data in separate .dll's/.o files?
17:24:51 <mniip> did you hear that levity has undergone a yet another change?
17:24:56 <Cale> Wizek: yes, pretty much
17:25:02 <Cale> mniip: nope
17:25:09 <mniip> there's no # now
17:25:13 <Cale> mniip: I don't really follow it so closely
17:25:18 <mniip> every unboxed type is of its own kind bascially!
17:25:19 <Cale> oh?
17:25:31 <Cale> Ah, well, that makes a whole lot more sense, actually.
17:26:02 <Cale> Though I'd expect that unboxed types could be collected into kinds based on physical size
17:26:30 <mniip> that's more or less what they did
17:26:59 <mniip> data RuntimeRep = VecRep VecCount VecElem | PtrRepLifted | PtrRepUnlifted | VoidRep | IntRep | WordRep | Int64Rep | Word64Rep | AddrRep | FloatRep | DoubleRep | UnboxedTupleRep
17:27:07 <mniip> data TYPE (w :: RuntimeRep)
17:27:25 <Cale> This is getting pretty elaborate :)
17:27:43 <srhb> Also very interesting.
17:27:52 <Cale> I'm totally okay with this apart from exposing any part of it from the Prelude
17:28:17 <Cale> Having it somewhere is great
17:28:42 <mniip> yeah no, it's not visible in Prelude
17:29:07 <Cale> (even in the type of ($)?)
17:29:53 <mniip> well, there's an active proposal to fix that, but no, it still says
17:29:58 <mniip> ($) :: forall (r :: GHC.Types.RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
17:35:38 <shapr> Cale: would you happen to know the right way to turn the result of Crypto.Hash.MD4.hash into an Integer?
17:36:28 <shapr> I tried unpacking the ByteString into a list of Word8, and then left shifting each of the Word8 into an Integer, but it's a different result from the hex value of the hash.
17:37:35 <shapr> What am I missing?
17:38:55 <amateur> not sure how you did it
17:39:22 <amateur> are you sure there's no fuckups with the ASCII/hex conversion?
17:39:52 <shapr> might be
17:40:40 <shapr> I bet it would help to boil the problem down to a small chunk of code.
17:44:47 <shapr> amateur: are you writing some cool code?
17:45:44 <Wizek> Seems to be related: http://stackoverflow.com/questions/1051597/is-there-a-function-size-profiler-out-there Although executing it tells me "nm: ./exe no symbols"
17:46:21 <Wizek> I wonder if it would find symbols if I build with profiling
17:46:45 <geekosaur> I think there's a bug already that you can't suppress symbol stripping
17:46:47 <amateur> shapr: i'm afraid i'll have to disappoint you tonight
17:47:00 <geekosaur> symbols used to be completely useless with Haskell code because debuggers can't understand it
17:47:58 <geekosaur> but ghc8 added DWARF support for backtraces --- unfortunately the tooling still strips symbols
17:48:15 <mniip> geekosaur, what kind of backtraces?
17:48:34 <mniip> closure entry backtraces, or fake made up function backtraces?
17:51:04 <Cale> shapr: I think you'd be better served using some binary encoding of an Integer? What's the bigger picture about what you're doing?
17:52:04 <shapr> Cale: I'm building a bloom filter, so I need to mod the hash according to the size of the bit vector I'm using.
17:52:28 <shapr> Cale: what kind of binary encoding of an integer?
17:52:43 <Cale> oh, so you're really just interested in the length of the ByteString?
17:54:06 <shapr> Cale: nah, I need the value of the hash result, and that gets `mod` size(bitvector)
17:54:53 <shapr> I'd bet there are already Haskell bloom filter libraries, but I'm trying to do this myself for learning purposes.
17:55:28 <Cale> What's the size of the bitvector?
17:55:55 <shapr> I want to vary the size of the bitvector later, but for now it's 128 bits
17:56:31 <Cale> So long as it's an appropriate power of two, you can mod by that without having to convert to Integer or really doing any arithmetic at all
17:56:38 <Cale> You just take the appropriate number of bytes off the end
17:56:51 <shapr> oh, that is easier
17:57:17 <shapr> but then, I still need to turn the result into a Integer
17:57:29 <Cale> Fair enough :)
17:58:06 <shapr> The crytpo lib has this bit of code: http://lpaste.net/154582
17:58:44 <shapr> but the hash result passed to that 'roll' function didn't give me the same result as the hex value of the hash
17:58:55 <shapr> am I missing something? shouldn't they have been the same value?
17:58:55 <Cale> Yeah, because it's reversing the bytes
17:59:28 <Cale> Try reversing the list of Word8's first and see what you get
17:59:31 <shapr> ah!
17:59:52 <Cale> (or switch to using foldl')
18:00:13 <Cale> Using foldl' will be better in this case for long lists
18:01:48 <shapr> reversing the list totally worked!
18:01:50 <shapr> Cale: thanks!
18:02:05 * shapr hops cheerfully
18:03:15 <Cale> roll' = foldl' unstep 0 where unstep a b = a `shiftL` 8 .|. fromIntegral b -- (note the arguments are flipped)
18:03:59 <Cale> You usually prefer to have a bit of strictness whenever you're taking a large amount of data and turning it into a summary (in fact, that's a good characterisation of basically every time that you want strict evaluation)
18:05:33 <shapr> cool, thanks!
18:13:13 <ontop> Can someone explain to me the difference between State s a and StateT SomeRidiculousImport.Something etc etc and why when I don't cast my State it ends up this?
18:16:19 <geekosaur> type State s a = StateT s Identity a
18:16:37 <ontop> Ah, I think the Identity thing is the thing with the ridiculously long import path.
18:17:16 <ontop> Is this because it's a Monad transformer?
18:17:22 <geekosaur> yes, that's just because if you haven't explicitly imported it, ghc will give you a fully qualified name including package it came from
18:17:48 <geekosaur> and yes, the point is that State is a type alias for the StateT transformer over the Identity monad
18:17:57 <geekosaur> (the do-nothing monad)
18:18:29 <MarcelineVQ> The hardest working do-nothing I ever seen
18:21:20 <ontop> lol.
18:21:30 <ontop> geekosaur: It all makes sense. Thx :)
18:26:34 <ontop> Now, I just have to learn how to use ST, and I can finish a program I started at Christmas time.
18:26:35 <ontop> :D
18:31:38 <radens> Is there a channel devoted to the lambda calculus around here?
18:35:50 * hackagebot optparse-generic 1.1.0 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.1.0 (GabrielGonzalez)
18:35:58 <radens> Is there a function which takes some input and a function and a number n and applies the input to the function n times?
18:37:48 <verement> :t iterate
18:37:50 <lambdabot> (a -> a) -> a -> [a]
18:39:43 <verement> > iterate (* 2) 1 !! 5
18:39:45 <lambdabot>  32
18:42:00 <NaOH> Hi everyone! I'am fairly new to Haskell (and to functional programming) and I am having some issues with recursive functions.... could any one lend me a hand?
18:42:33 <simpson> NaOH: Go ahead and ask your question.
18:46:29 <NaOH> I have a series of recursive functions (which should be tail recursive) that are nested. The issue I am having is that the memory usage goes to the roof as this functions call themselves over and over again. I have tried throwing some "seq" here and there to try and force evaluation to no avail. My question is if there is any simple way to try and isolate the part of my code that is making the memory usage spike (for instance, using pr
18:46:44 <NaOH> If I could know which function is the culprit I could try and solve the issue
18:47:11 <mniip> what do you mean "tail recursive"
18:48:35 <NaOH> the function evaluates something, if it's true, it just returns the arguments you've passed to it, if it not, it calls itself with new arguments
18:48:59 <NaOH> I can paste the code, but I don't think it would make a lot of sense out of context
18:49:38 <mniip> @where lpaste
18:49:39 <lambdabot> http://lpaste.net/
18:52:25 <NaOH> http://lpaste.net/154583
18:55:45 <NaOH> those are the recursive functions (namely, walkUntilCrash' and runContact), if you need the rest of the code I can paste the whole file
18:59:53 <Cale> NaOH: I'll have a look
19:00:47 <Zearen1> Is there a way to reference a type parameter from the top level type signature ?
19:02:05 <Cale> NaOH: Try replacing the 'where' with 'case'
19:02:41 <Zearen1> E.g. f :: Clazz t => t ; f = (dummy :: t) -- would assert the 't' in the top level sig in and the one in the expression are the same.
19:03:01 <pdxleif> Huh; pijul got rewritten into Rust
19:03:06 <Cale> Zearen1: Yeah, that's provided by an extension called ScopedTypeVariables
19:03:29 <Cale> Zearen1: You turn on that extension, and you use an explicit forall to bind the variable t in the signature for f
19:03:39 <Cale> f :: forall t. Clazz t => t
19:04:02 <Zearen1> Oh, cool.  Thanks :)
19:04:05 <Cale> and then if you use t in the definition of f, it'll refer to the same t
19:04:41 <shachaf> There's one place where ScopedTypeVariables changes behavior even without forall.
19:05:18 <NaOH> Cale: in which way do you mean? how can I replace a where with a case?
19:05:38 <Adeon> as in the same code compiles with and without ScopedTypeVariables but the behaviour is different?
19:05:40 <Cale> case takeRandomStep (g',gen) of (g'',gen') -> ...
19:05:41 <Adeon> that would be interesting
19:06:10 <Cale> NaOH: I think I'd need to see more of the code in order to really work out what was going on
19:06:24 <parsecChar> in my *.cabal file, how do I specify to use ghcjs instead of ghc ?
19:06:32 <Cale> NaOH: But your functions look kind of strict apart from the fact that they're lazily binding these pairs
19:06:35 <Adeon> I don't know why 'case something of (blah :: Type) -> ...' is part of ScopedTypeVariables
19:06:53 <parsecChar> it requires "ScopedTypedVariables" for the blah, since it's not top level
19:07:04 <Zearen1> Interesting, it seems this wants you to explicitly forall all type variables if you quantify any of them.
19:07:14 <Cale> Zearen1: yeah
19:07:29 <Adeon> ohhhhhhhh
19:07:39 <Adeon> I had to take a few seconds to understand that explanation
19:09:13 * Zearen looks at her function and counts 5 type variables >_>
19:09:44 <Lokathor> Zearen, it's okay
19:09:45 <simpson>       
19:09:46 <simpson> 19:02:39          pdxleif | Huh; pijul got rewritten into Rust                                                                       │ __zxq9__        
19:09:49 <Cale> Zearen: You don't have to write forall multiple times, in case you were unaware -- you can write  forall a b c d e. ...
19:09:49 <simpson> Oops, sorry.
19:10:12 <Lokathor> Zearen, sometimes you write something worse like this: visitCoord :: VisionBlocked -> Int# -> Int# -> Int# -> Int# -> Int# -> Int# -> STRef s (Set Location) -> STRef s [View] -> ST s ()
19:10:32 <shachaf> Zearen: You can also use an alternative syntax with ScopedTypeVariables for function arguments.
19:10:40 <Zearen> I'm aware, I just use longer type variable names to aid readability.
19:10:46 <shachaf> :t let f (x :: a) y = undefined :: a in f
19:10:47 <lambdabot> a -> t -> a
19:11:08 <Cale> I do that too, when it makes sense, but it rarely does...
19:11:19 <Cale> Most of my type variables are pretty meaningless
19:11:48 <Zearen> It's just after successfully deoding some of the full ParsecT and Snap types, I've learned to appreciate 'userState' over 'u' :p
19:12:14 <Cale> Fair enough :)
19:12:29 <Lokathor> forever :: Monad m => m a -> m loopsforever
19:12:32 <Lokathor> :3
19:13:30 <Zearen> :p
19:15:38 <Cale> I recently had the occasion to name a type constructor variable "notification"
19:17:55 <Zearen> Oh, for the benefit of others who might be listening, if 't' is a class type var (I forget the formal name, but e.g. @class Clazz t where ...@), then you need to omit it from the forall. clause.  (In fact the forall clause seems unnecessary in this case modulo other fanciness).
19:18:23 <mniip> Zearen, no you still can include it
19:18:52 <mniip> my immediate guess is that you put the forall binding in the wrong place though
19:19:09 <Zearen> The compiler yelled at me, so...
19:19:27 <shachaf> You use forall to quantify over a new variable.
19:20:13 <shachaf> If you're writing "class Clazz t where x :: ...t...; x = ...", t isn't a new universally quantified variable so you don't need to quantify it.
19:20:22 <mniip> yeah that's true
19:20:33 <shachaf> In fact that's the case I was talking about earlier.
19:20:34 <NaOH> Cale: replacing the where with a case didn't work. Here is the code with some extra context and comments http://lpaste.net/154583
19:20:35 <Zearen> That appears to be what the compiler told me.
19:20:38 <mniip> I thought they were talking about forall a. Num a => a
19:21:06 <shachaf> But that's pretty unusual.
19:22:04 <Cale> NaOH: Is this enough code that I can run it?
19:22:19 <barryburd> I’m working through the edX Functional Programming course. I copied some code from the lecture and posted it at http://allmycode.com/Main.hs. I’ve attached the error message at the bottom. It looks as if the compiler is seeing Main.return [(x, y)] even though my code says Main.return (x, y) without brackets. Can someone help me understand why?
19:23:19 <Cale> NaOH: I'm tempted to replace a lot of the fiddly passing of generators using some sort of random generation monad
19:25:04 <mniip> barryburd, Parser is a type-synonym
19:25:28 <mniip> so when you say Parser (Char, Char), you actually say String -> ((Char, Char), String)
19:25:44 <mniip> and the monad instance used in the do block is that of the ((->) String) moand
19:25:46 <mniip> monad
19:26:22 <parsecChar> Snap Snappity Snap // testing if Snap bot in #snapframework fires off comment
19:27:35 <mniip> barryburd, you seem to declare your own 'return' to account for this, but you don't realize that the 'do' block syntax makes use of the >>= function
19:28:12 <NaOH> Cale: yeah, I know that it doesn't look right, but do you think that could be the root of the issue?
19:28:13 <mniip> which still is of the reader monad
19:28:54 <Cale> NaOH: Well, it's just making it a little harder for me to understand performance.
19:29:23 <NaOH> (just for reference, here is runnable code http://lpaste.net/154588 )
19:29:33 <Cale> ah, excellent
19:30:17 <mniip> that's some wide-ass layout
19:30:38 <NaOH> (there are lot's of things commented out, so that it's the bare minimum to run)
19:31:35 <barryburd> mnilp: Thanks. I’ll have to take some time thinking about that.
19:35:10 <mniip> wow
19:35:13 <mniip> woooooooow
19:35:18 <mniip> TypeInType lets us write
19:35:21 <mniip> type family KindOf (a :: k) where KindOf (a :: k) = k
19:36:48 <mniip> what's left is exporting Typeable's internal datacon inspection machinery as a type family
19:37:00 <mniip> then we could have type introspection in the typesystem!
19:46:16 <slack1256> hi, eh I need a quick favor. I am doing a DCC module for irc-core yet glirc fails on the connect. I am starting to suspect it is getaddrinfo and the loopback device. To check this I would like to see I can get files from the outside net
19:46:32 <slack1256> can somebody de me a /dcc send slack1256 tinyFile?
19:47:04 <Cale> NaOH: hmm, in runContact, it's going to test whether or $ loopToList (listRead g), however, this will already have been tested by limitContact
19:47:38 <Cale> NaOH: er, sorry, nevermind, wrong function -- this one isn't actually used :P
19:47:59 <mniip> slack1256, wow DCC, is this 1995?
19:48:19 <slack1256> it is post-1995, so it still exists
19:48:25 <slack1256> (also xdcc is really useful)
19:48:30 <mniip> shrug
19:48:46 <NaOH> Cale: oh yeah, in the complete code I use limitContact which takes an Int to count a maxinum number of steps, otherwise I would run out of memory before the or $ loopToList (listRead g) returns true
19:49:21 <slack1256> thanks Cale
19:49:49 <Cale> NaOH: Okay, I'm just rewriting this thing in order to understand what it's doing :)
19:50:33 <NaOH> Cale: Thank you very much for taking the time to look into this! I'm also editting the file to remove all the code which was just for testing along the way
19:51:15 <NaOH> Cale: Also, in the other pasted code I wrote some comments on what the functions are supposed to be doing
19:51:45 <NaOH> (here http://lpaste.net/154583 )
19:55:37 <mniip> int-e, so is Free not coming or something?
19:56:28 <NaOH> Cale: Also for reference, if it's any help, the problem I'm trying to solve is this: there is a grid in polar coordinates, each cell can be occuppied or not. The inner ring is occuppied. A random walk starts from the outer ring, until it reaches an occupied cell, in which case it sets the cell where it  was in the previous step to occupied (True)
19:57:50 <Cale> resetGrid is just moving left until moving left once more would give Nothing, which it doesn't do, correct?
19:58:11 <NaOH> this is "walkUntilCrash", runDeposit is the one that sets to True the last cell in the random walk. And runContact (or limitContact), calls walkUntilCrash (generating many random walks) until one stops at the outer ring
19:58:42 <NaOH> yes, resetGrid moves left on the ListZipper, which is moving out in the polargrid
19:59:47 <NaOH> (until it reaches the outer ring, or the first element in the ListZipper)
20:04:40 <et09> in this notation (semi-regex) - ([^)]*) -> .* - the part in parentheses is always the argument to a function, is that correct?
20:07:12 <pavonia> et09: What is the context of this?
20:07:19 <et09> a type declaration
20:07:30 <mniip> what kind of
20:07:43 <et09> not sure
20:07:48 <et09> let's say a functions
20:11:19 <pavonia> In a type "a -> b", a is the argument and b the result type (if that was the question)
20:12:38 <et09> let's say you have (a -> b) -> (a -> b) -> (a -> b)
20:12:44 <et09> i'm assuming that's valid
20:12:56 <et09> the first parenthesized term is the argument(s)?
20:13:19 <et09> maybe i should just google haskell type declarations
20:13:24 <pavonia> The first two (a -> b) and the last a are the arguments
20:13:42 <NaOH> et09: I'm no expert here, but as I far as I understand (a -> b) -> (a -> b) -> (a -> b) takes two functions from a to b, and returns a function from a to b
20:14:04 <mniip> which is the same as taking the third argument a and returning b
20:14:11 <mniip> all functions are unary
20:14:57 * mniip off
20:15:26 <pavonia> So (a -> b) -> (a -> b) -> a -> b  =  (a -> b) -> (a -> b) -> (a -> b)  =  (a -> b) -> ((a -> b) -> (a -> b))
20:36:14 <spopejoy> lens/iso help? doing  toListOf(traverse.toPair.firsting ???) [Foo 1 2, Foo 3 4].  toPair is an iso from (Foo a b) to (a,b), need to convert the _1 slot into a list (ie return)
20:38:15 <spopejoy> (firsting is a new Iso over bifunctors, applying an Iso to the _1 slot)
20:39:24 <spopejoy> ie, toListOf(traverse.toPair.firsting ???) [Foo 1 2, Foo 3 4] ===> [([1],2),([3],4)]
20:41:31 <Cale> NaOH: okay, it really is thunks building up from takeRandomStep
20:41:46 <Cale> NaOH: I've got the space down to <3MB
20:42:20 <NaOH> Cale: wow, that's incredible, it was sucking out all my RAM hehe
20:43:09 <NaOH> Cale: so takeRandomStep was not being evaluated? and returned thunks instead?
20:44:31 <Cale> NaOH: I think it's actually in loopLeft/loopRight -- one sec while I fix this in a less sledgehammery way
20:44:37 <Cale> (which should also improve performance again)
20:45:03 <NaOH> ok!
20:45:28 <NaOH> takeRandomStep does have recursion, but given that it would seldom happen I didn't worry about it too much
20:48:44 <spopejoy> ok this works but is icky: toListOf (traverse.toPair.lmapping' (iso return head))
20:52:20 <Cale> NaOH: ohhhhh, hah, it's the fact that you're going left and right via fmap, and not evaluating the resulting loops
20:52:50 <Cale> NaOH: ... I think
20:53:47 <NaOH> haha and is it possible to enforce the evaluation through fmap?
20:57:40 <Cale> NaOH: no, I think we just have to deepseq here
20:57:45 <Cale> unfortunately
20:57:54 <Cale> There might be some more clever approach
20:59:15 * ontop tries to understand ST and Mutable arrays
20:59:18 * ontop dies
21:00:08 <lpaste> Cale pasted “sodium hydroxide” at http://lpaste.net/154592
21:00:12 <Cale> NaOH: ^^
21:01:03 <LysergicDreams> Any web framework that matches up nicely with JSON-API spec? http://jsonapi.org
21:01:17 <Cale> NaOH: for example, it might actually be better just to index things and use a Map
21:02:08 <NaOH> Cale: Ok, thank you very much for your help! I'm going to review the code ;)
21:02:25 <Cale> NaOH: you'll notice I included a version using Data.Sequence in a comment there
21:02:43 <Cale> NaOH: It seems to perform slightly better space wise (didn't track time)
21:02:59 <Cale> But I wanted to be sure it wasn't also helping in some way, so I put your implementation back
21:03:50 <Cale> The seq's in the movement functions could also be removed now that we're just using the deepseq sledgehammer
21:04:53 <Cale> NaOH: You'll notice that using Rand helps a fair amount for readability (at least I think so)
21:05:23 <Cale> NaOH: I did something slightly clever when it comes to takeRandomStep, hopefully that code makes sense -- it picks an action uniformly at random, and then runs that
21:05:47 <ontop> data Command = Command !Op Point Point <- What's the ! there for?
21:06:02 <Cale> ontop: That makes the field strict
21:06:14 <ontop> o
21:06:14 <Cale> ontop: any pattern match on Command will cause the Op field also to be evaluated
21:06:26 <ontop> I guess that's good :|
21:06:47 <Cale> It may or may not be necessary
21:07:33 <ontop> The thing I'm trying to understand right now, is where the heck writeArray is and why it returns an "ST s ()"
21:07:35 <tippeneinn> looking for something like this: (a,b,c) -> (a -> b -> c)
21:07:53 <ontop> Oh. Found it.
21:07:55 <tippeneinn> curry on 3 tuple
21:07:58 <ontop> Scrolled too fast :|
21:09:17 <Cale> ontop: Well, it produces the action which when executed, will write the given array at the given position with the given element
21:10:25 <Cale> tippeneinn: do you mean ((a,b) -> c) -> (a -> b -> c)?
21:10:36 <Cale> or ((a,b,c) -> d) -> (a -> b -> c -> d)?
21:11:10 <Cale> tippeneinn: I think the best thing in that case is just to write the lambda
21:11:26 <Cale> (\f x y z -> f (x,y,z))
21:11:57 <Cale> (sometimes you can reduce out the f if you know what the function is)
21:21:01 <ontop> Cale: I have two points, and I need to write to my mutable array for each x,y coord in between the points. What's a good way to do that?
21:21:09 <ontop> I need a for i loop dammin :(
21:21:12 <ontop> dammit*
21:21:47 <ontop> I could do it recursively I suppose.
21:22:25 <ontop> Seems like a pain.
21:32:41 <NaOH> Cale: First of all, thank you so so so much for your time! My code was a mess and you went through it and fixed it :D
21:33:22 <NaOH> Cale: definitely using the monad to take care of the random generators is way cleaner 
21:33:56 <NaOH> Cale: on the use of seq.... I should go to read a little bit online because I don't know the syntax being used there...
21:34:41 <NaOH> Cale: one final question, could you explain me what is going on in "maybe (takeRandomStep g) return (goOut g)" inside the takeRandomStep function?
21:36:55 <dmj`> :t \l m -> maybe l return m
21:36:56 <lambdabot> Monad m => m a -> Maybe a -> m a
21:39:09 <NaOH> Cale: nevermind, I think I get it from the type definition of maybe.. it takes (goOut g), if it's a Just value, it applies return to it, if it's a Nothing, it evaluates to (takeRandomStep g)
21:39:38 <dmj`> NaOH: yes, you got it
21:40:08 <NaOH> dmj`: thanks
21:40:09 <dmj`> > maybe 1 (const 2) Nothing
21:40:10 <lambdabot>  1
21:40:22 <dmj`> > maybe 1 (const 2) (Just "foo")
21:40:23 <lambdabot>  2
21:40:33 <NaOH> great, thanks :)
21:42:46 <NaOH> Cale: well, thank you again for your time! Later I wil try and refactor it so it ends up as clean as possible, for now, I can keep tweaking somethings now that it works
21:46:14 <NaOH> Cale: Here is a sample result using the new code http://imgur.com/4KM3tog . I'm trying to model the fractals that are produced when you electrodeposit Zinc from a Zinc ring into a wire in the center ;)
22:08:47 <xoitx> anyone know how to check chat history?
22:10:57 <sidoaight> xoitx - http://ircbrowse.net/day/haskell/today/recent
22:13:01 <xoitx> doesn't seem to back that far
22:14:33 <sidoaight> I'd say going back to 2001 going back pretty far.
22:14:42 <sidoaight> *is going back
22:16:11 <sidoaight> Check out http://ircbrowse.net/calendar/haskell and http://ircbrowse.net/browse/haskell
22:16:19 <xoitx> damn
22:16:20 <xoitx> yea
22:16:22 <xoitx> got it
22:16:24 <xoitx> thanks
22:16:41 <xoitx> how long have you been learning haskell?
22:22:49 <sidoaight> Me?  I just started, so I don't know anything.
22:23:12 <sidoaight> Been aware of Haskell for several years though.
22:25:57 * hackagebot sensei 0.0.0 - Automatically run Hspec tests on file modifications  https://hackage.haskell.org/package/sensei-0.0.0 (SimonHengel)
22:46:19 <xoitx> you know of any philosophical programmers out there?
22:48:30 <Rotaerk> xoitx, I'm a programmer, and I'm philosophical
22:48:48 <Rotaerk> for some definition of philosophical...
22:50:29 <solidsnack> Is it fair to treat “tagged union” and “variant type” as synonymous?
22:51:15 <Rotaerk> solidsnack: wikipedia seems to think so
22:53:36 <ontop> I spent like all day rewriting my program to use mutable arrays so it'd be performant
22:53:43 <ontop> And it still runs like an absolute dog
22:54:00 <ontop> I tried to profile it, but the function it's crying about is so simple I can't imagine why it's so slow :(
22:54:29 <ontop> My go version of this program that does basically the same thing runs in under 1s
22:55:27 <ontop> Anyone want to give me a hand?
22:55:28 <ontop> http://lpaste.net/6050024360599617536
22:55:36 <ontop> Prof output at the bottom.
23:02:02 <macalimlim> hello all :) im having a problem with stack lately `Compiler version mismatched, found ghc-7.10.3 (x86_64), but expected minor version match with ghc-3.10.7 (x86_64)`
23:02:11 <macalimlim> can anybody help?
23:03:24 <cocreature> macalimlim: could you post your stack.yaml?
23:03:52 <ontop> Omg.
23:03:53 <ontop> I fixed it.
23:04:08 <cocreature> ontop: how? I was just looking at it and didn’t find anything so far :)
23:04:14 <macalimlim> resolver: lts-5.7
23:04:22 <macalimlim> thats it basically...
23:04:39 <ontop> cocreature: There's nothing wrong with the program turns out. Just had to BangPatterns and smash ! absolutely everywhere. Laziness was killing me.
23:04:52 <cocreature> ontop: ah :(
23:05:00 <ontop> The specific spot where it seemed to have the most impact was the print in main: print $ ... -> print $!
23:05:06 <ontop> And suddenly the thing was almost as fast as the Go program.
23:05:16 <cocreature> ontop: you might want to consider streaming the input
23:05:46 <ontop> cocreature: The Go version does that. It'd probably be better, yea.
23:05:58 <cocreature> I like pipes for that
23:06:06 <ontop> Wassat?
23:06:18 <ontop> A haskell thing or just like... file piping?
23:06:21 <cocreature> https://hackage.haskell.org/package/pipes
23:06:34 <cocreature> there is a great tutorial in the Pipes.Tutorial module
23:06:45 <ontop> Really? That'd be an absolute first
23:06:53 <ontop> Good documentation with examples in Haskell!?!?!?
23:06:58 <cocreature> yep
23:07:03 <cocreature> gabriel is good at that :)
23:07:40 <macalimlim> hello all :) im having a problem with stack lately `Compiler version mismatched, found ghc-7.10.3 (x86_64), but expected minor version match with ghc-3.10.7 (x86_64)` can anybody help?
23:08:41 <cocreature> macalimlim: what version of stack are you running?
23:09:08 <ontop> cocreature: Yeah, I was able to remove BangPatterns and just keep the putStrLn $! and it's still fast :)
23:09:51 <cocreature> macalimlim: also take a look at https://github.com/commercialhaskell/stack/issues/1903 but from a quick look I don’t see a solution there
23:10:24 <macalimlim> ok wait :)
23:10:25 <cocreature> here https://github.com/commercialhaskell/stack/issues/1907 installing stack from homebrew seems to have solved the problem
23:10:29 <cocreature> if you are on os x
23:11:23 <cocreature> either way you could try to use a provide binary to build git master or something like that
23:13:34 <macalimlim> ok thanks :)
23:18:24 <aarvar> ontop: what happens if you make Point strict?
23:18:48 <ontop> aarvar: Where exactly?
23:18:57 <aarvar> e.g. data Point = Point !Int !Int
23:19:07 <ontop> (!Int, !Int)
23:19:09 <ontop> Does that work?
23:19:50 <aarvar> ontop: no
23:20:01 <ontop> Doesn't seem like there's a way to do that syntactically without changing from (Int, Int) to something else. And then I'd have to change my whole program :(
23:20:19 <ontop> But it's fast now, so it's okay ^_^
23:21:01 <macalimlim> @cocreature thanks its building now.... i just installed the stack that came with my distro
23:21:01 <lambdabot> Unknown command, try @list
23:21:03 <aarvar> wouldn't it be trivial to change?
23:21:40 <ontop> aarvar: Yeah, but currently it's giving wrong output so I'm more curious why it's not correct rather than alternative optimization methods :)
23:22:24 <ontop> If you want the input file to test and try yourself I can pastebin it.
23:23:25 <xoitx> is the computer faster than the brain?
23:24:25 <ontop> aarvar: It does still run slowly in ghci mind you. So maybe your fix would actually help that.
23:59:11 <LysergicDreams> Anyone use a haskell REST server w/ Ember.js?
