00:00:21 <runeks> I'm doing this: (functionThatTakesTwoArgs <$> funcA <*> funcB) >>= anotherFunction
00:00:22 <liste> though .. <$> .. <*> .. <*> .. <*> .. pattern is used a lot so many are used to it
00:00:47 <runeks> I'm not sure if the parenthesis is necessary
00:00:50 <gfixler> runeks: liftA2 (,) getLine getLine
00:00:53 <gfixler> :)
00:00:53 <dibblego> runde: liftA2
00:01:00 <dibblego> runeks: liftA2
00:02:06 <runeks> dibblego: Looks like I was looking for liftA2 all along
00:02:16 <liste> there's also liftM[2-7]Â if you need to target 7.8
00:02:27 <liste> or earlier
00:02:42 <runeks> Although it may make it even less readable to me
00:03:02 <liste> runeks: then go with the readable one (:
00:03:18 <runeks> liste: Yeah I think I will :o)
00:04:34 <gfixler> liftA2 (,) getLine getLine >>= return . swap
00:06:00 <gfixler> â‰ˆ liftA2 (flip (,)) getLine getLine
00:06:30 <gfixler> liste: what was that bit about targeting 7.8? what changed?
00:08:04 <quchen> gfixler: Applicative became a superclass of Monad, which made the liftM[2..] functions redundant
00:08:06 <liste> gfixler: Applicative => Monad, so having Applicative for all Monads wasn't guaranteed
00:08:26 <gfixler> oh, that
00:08:30 <gfixler> gotcha
00:08:31 <liste> (most Monads had them anyway though)
00:09:07 <quchen> You can find plenty of monads without applicative instances in old code
00:09:18 <quchen> In particular newtype wrappers that were hastily thrown together suffer from this
00:09:19 <gfixler> quchen: yes, in all of my old code
00:34:35 * hackagebot cereal-conduit 0.7.3 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  https://hackage.haskell.org/package/cereal-conduit-0.7.3 (MichaelSnoyman)
00:34:37 * hackagebot conduit 1.2.6.4 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.6.4 (MichaelSnoyman)
01:05:20 <medfly> hi
01:05:55 <medfly> what's the most modernish almost-haskell that doesn't require a haskell compiler to boot
01:06:18 <NeverDie> What.
01:06:37 <quchen> NeverDie: ?
01:06:41 <medfly> I wanna boot GHC without having GHC in the first place.
01:07:00 <dmj> medfly: what do you mean by 'almost-haskell'?
01:07:05 <merijn> medfly: You have to start with unregistered cross-compiled GHC and boot up from there
01:07:09 <medfly> no
01:07:24 <merijn> medfly: Bootstrapping GHC is a lot of work
01:07:37 <medfly> dmj: well, I only need stage 0, not everything...
01:08:22 <dmj> I see
01:10:04 <medfly> so, what's a good starting point? hugs?
01:10:31 <merijn> Hugs can't compile, can it?
01:11:03 <merijn> Even if it can, it can probably only compile ancient GHCs, so you'd have to use hugs to build an old GHC to build a newer GHC, etc. until you reach the version you want
01:11:09 <merijn> medfly: What's your actual problem?
01:11:10 <tdammers> merijn: it wouldn't have to, as long as it can run a GHC that can bootstrap GHC
01:12:10 <merijn> tdammers: Right, but considering you'd only be able to bootstrap an ancient GHC using hugs, since GHC uses GHC extensions
01:12:30 <merijn> And there's not a lot of effort being put into keeping GHC compilable with older GHCs
01:12:42 <merijn> So the odds of making huge version leaps aren't very good
01:12:44 <Peaker> I wish GHC was split up from a huge monolithic project to tons of little modular packages, that would make things like this so much easier
01:13:08 <Peaker> haskell-src-exts was split off, but as a copy! they kept the original inside GHC too
01:13:13 <medfly> merijn: some people have strong resistance to the idea of not being able to boot a compiler
01:14:04 <merijn> Peaker: There's plans to expose the GHC AST directly, afaik
01:14:07 <nshepperd> I wish core was an actual public api so i could just write an interpreter for it
01:14:16 <merijn> medfly: You can boot via unregisterised cross compilation
01:14:25 <nshepperd> Seems like a simple solution to cross compiling
01:14:29 <merijn> nshepperd: You can extract Core and feed it into GHC, afaik
01:14:33 <Peaker> merijn: but a huge monolithic project is hard to start workiing on, hard to build, hard to bootstrap, etc.
01:14:52 <Peaker> merijn: in my dream world, GHC is just a bunch of C libs and cabal packages
01:14:56 <medfly> merijn: doesn't that require GHC too?
01:15:11 <merijn> medfly: On another platform, yes
01:15:30 <merijn> medfly: You build the unregisterised cross compilation on, e.g. intel and then run that on ARM
01:15:51 <hvr> Peaker: that's a nice dream... but hard to make reality due to the way GHC is entangled with its boot libs
01:16:00 <merijn> Peaker: tbh, GHC is much easier to start working on than many smaller projects that exist
01:16:19 <merijn> And actually I kinda like that all GHC code is in one monolithic repository, makes it easier to jump to definitions
01:16:25 <Peaker> hvr: I never fully understood that entanglement
01:16:27 <merijn> (Using ctags, etc)
01:16:44 <Peaker> merijn: https://hackage.haskell.org/package/codex
01:17:03 <Peaker> I don't use it since I found ghci-ng is so much nicer, but I did contribute a big patch to it :)
01:17:38 <hvr> Peaker: fwiw, GHCi 8.0 merged back all of ghci-ng's functionality...
01:17:56 <merijn> Peaker: I've looked at codex (and local hoogle, etc.) but tbh usually it turns out to be a huge hassle to setup correctly and get working
01:18:02 <Peaker> hvr: cool, so ordinary haskell-mode should now have all the goodies from the chrisdone emacs config?
01:18:13 <hvr> Peaker: yeah... but somebody needs to test that :-)
01:18:17 <Peaker> merijn: when? I was annoyed by that too and sent a patch to fix my issues with it
01:18:32 <Peaker> merijn: iirc, I made it so it Just Works with emacs (when it was mostly geared towards vim users)
01:18:48 <nshepperd> In my dream world ghc is just a front end that compiles all these fancy Haskell features into plain old core then some boring simple backend translates that into an executable
01:19:19 <Peaker> nshepperd: yes, it's the same dream world! Those are cabal packages doing the front end and backend translations
01:19:27 <merijn> Peaker: I don't use emacs, I use vim, but tbh I find most of the vim plugins take WAAAAY too much hassle to setup too
01:19:32 <medfly> So, is hugs the best choice?
01:19:40 <merijn> nshepperd: Eh, that already exists? :)
01:19:43 <medfly> Other than avoiding Haskell...
01:19:46 <Peaker> merijn: If you just run codex to yield a tags file -- isn't that all the setup you need?
01:19:54 <merijn> nshepperd: Intel had a project where they took Core dumped by GHC and compiled it to asm themselves
01:20:04 <merijn> Peaker: I'll have to look into it again
01:25:14 <barrucadu> medfly: Hugs hasn't been updated in nearly a decade, it take a lot of time to get from there to a modern GHC (if possible at all)
01:25:24 <medfly> that's why I'm wondering if there's anything better
01:25:59 <barrucadu> Why do you need to bootstrap ghc from scratch?
01:26:00 <liste> medfly: you want to bootstrap from Haskell source on the target platform?
01:26:11 <medfly> a better question is why am I the only one that seems to give a damn?
01:26:31 <srhb> medfly: I guess most compilers are self hosted these days?
01:26:32 <liste> medfly: not e.g. Cmm or LLVM IR ?
01:26:37 <srhb> So it's just the way things are?
01:27:07 <medfly> When I complained to the Go guys that the latest binutils update broke the boot process they promised they will fix it
01:27:49 <medfly> Still works
01:29:52 <merijn> medfly: You can't bootstrap, e.g. gcc/clang easily on a new platform either...
01:30:02 <srhb> I may be missing the point, what's the point of being able to bootstrap ghc without ghc?
01:30:05 <merijn> Bootstrapping compilers is just messy business
01:30:08 <srhb> Or rather, why is it important?
01:30:11 <medfly> srhb: you don't need to trust someone else's binaries.
01:30:20 <srhb> medfly: Erm, how so?
01:30:22 <medfly> srhb: and all the binaries he chose to trust, too.
01:30:24 <tdammers> you still need to trust *some* binaries
01:30:33 <tdammers> maybe not GHC binaries, but you need to compile GHC using *something*
01:30:35 <merijn> medfly: You have to trust *someone's* binaries anyway
01:30:35 <barrucadu> Unless you compile by hand, you're still executing a binary
01:31:01 <merijn> Well, you can cross-compile using a trusted compiler, but then you need to bootstrap a trusted compiler before crosscompiling :p
01:31:05 <bernalex> tdammers: merijn: missingthepoint.png
01:31:12 <cocreature> is trusting a binary provided by the ghc devs really worse than trusting the source code? you canâ€™t reasonably audit it on your own anyway
01:31:19 <medfly> cocreature: yes
01:31:25 <medfly> cocreature: absolutely
01:31:58 <merijn> bernalex: Please enlighten me on how to bootstrap ANY compiler without trusting someone's binaries?
01:31:58 <medfly> You can make a compiler vulnerable in a way that is not going to be visible in the source code
01:32:01 <bernalex> tdammers: merijn: you could e.g. choose to trust a selected few binaries, that you've gotten from a selected few sources. that you must therefore accept that binaries are to be trusted is a non-sequitor.
01:32:13 <medfly> C gets a pass because there's more than one C compiler
01:32:17 <merijn> bernalex: I didn't say you have to trust ALL binaries
01:32:29 <bernalex> fwiw when I upgrade GHC I *always* bootstrap it from my existing installation.
01:32:30 <merijn> bernalex: You have to trust SOMETHING
01:32:36 <medfly> so you can use the other ones to check it.
01:32:44 <bernalex> merijn: saying "so therefore you should just trust the ghc binary" is still a non-sequitor.
01:32:45 <merijn> bernalex: And how did you bootstrap your first install?
01:33:10 <barrucadu> medfly: How? If you have a single C program, how can you reasonably compare the output of different compilers to make sure nothing nefarious has been put in?
01:33:12 <bernalex> merijn: iirc via a binary from a competent friend I trust. idr how he got it tho. :]
01:33:31 <merijn> bernalex: I'm not saying you should, but you need to pick something to trust. And why blame the GHC developers for not providing a path from your trusted binaries to a GHC install?
01:33:43 <medfly> barrucadu: http://www.dwheeler.com/trusting-trust/
01:33:45 <merijn> barrucadu: You can do trusted double compilation
01:33:53 <merijn> barrucadu: Of course, that's not guaranteed to work
01:34:05 <srhb> Don't we need deterministic builds for that?
01:34:05 <merijn> barrucadu: But it requires an N-wary compromise instead of a single one
01:34:29 <merijn> bernalex: You want a trusted path from your definition of trusted binaries to GHC? Fine. But don't go be entitled about GHC devs not providing it for you
01:34:29 <tdammers> "in order to bootstrap GHC, first acquire a sufficient amount of silicon"
01:34:35 <bernalex> merijn: I'm not blaming anyone for anything, I'm just saying that anyone is free to not trust a binary provided by the GHC folk, and the fact that they trust some other binary provided by some other folk, that doesn't mean that they logically need to trust the GHC binary.
01:34:42 <cocreature> tdammers: trusted silicon!
01:34:53 <tdammers> cocreature: silicon with DRM!
01:35:05 <merijn> bernalex: My complaint is the entitlement that it's somehow the GHC teams job to provide a trusted path beyond their own binaries
01:35:34 <medfly> Entitlement?
01:35:35 <bernalex> merijn: I never said anything to that extent whatsoever. GHC is free software and nobody is entitled to anything.
01:35:46 <medfly> I asked whether there's a better choice than hugs for this
01:35:49 <medfly> I didn't ask anyone to write code
01:36:06 <srhb> I wonder if one could conceivably go back to a C version of GHC
01:36:10 <merijn> bernalex: I'm not saying you did
01:36:12 <srhb> Probably way harder :-P
01:36:16 <merijn> srhb: Was there ever a C version of GHC?
01:36:19 <merijn> srhb: I don't think there was
01:36:37 <srhb> merijn: Oh, maybe not. 
01:36:40 <merijn> srhb: Lennart's initial haskell compiler was in lazy ML, afaik. I would assume GHC was bootstrapped using an existing haskell compiler
01:36:51 <srhb> merijn: I may have just imagined it :)
01:38:28 <bernalex> it's a lot nicer if you can compile a compiler using a different compiler than itself. alas that's not nearly the case in languages like haskell or scala.
01:39:03 <tdammers> OTOH, getting to "self-supporting" ASAP seems to be a common priority for compiler makers
01:39:49 <medfly> So, aside from pointless babble, since nobdoy else plans to do anything
01:39:52 <barrucadu> medfly: That approach seems to require the compiler you're building from source and your trusted compiler produce bit-for-bit identical output on the source code of the compiler you're building. So it rules out any sort of optimising compiler and requires deterministic builds.
01:39:54 <medfly> is there any better choice than hugs
01:39:57 <tdammers> strange, I'm still getting this weird behavior from stack, where it just hangs while installing
01:40:06 <bernalex> tdammers: being self-hosted is also great. but having no other option is not so great.
01:40:09 <tdammers> but I only get it on one machine, not the other
01:40:19 <Cale> medfly: Well, the best choice if your goal is to get GHC bootstrapped on something else, is to cross-compile a binary
01:40:23 <tdammers> even though they should, in theory, be running the same software stack
01:40:27 <fr33domlover> Q: When parsing a network protocol, how do I choose between attoparsec and Data.Binary.Get?
01:40:33 <merijn> srhb: Just checked, the initial commit in the GHC git is indeed haskell
01:40:35 <fr33domlover> it seems they both can do what i need
01:40:36 <Cale> medfly: This will take work, but much less work than most of the other options...
01:40:44 <Ke> well depending on a huge lib like llvm is not always completely self-hosting imo
01:40:48 <opqdonut> merijn: didn't ghc migrate from darcs?
01:40:51 <merijn> fr33domlover: I would use Data.Binary for binary protocols and attoparsec for "text" protocols
01:40:52 <Cale> medfly: What's your goal here?
01:40:54 <Ke> though ghc strictly does not
01:40:57 <merijn> opqdonut: Yes, but obviously they converted the commits
01:41:05 <merijn> opqdonut: The initial commit is from 1996
01:41:05 <opqdonut> oh right
01:41:14 <bernalex> Cale: well the best option would be to get a GHC binary that you trust, and use that to bootstrap GHC. :]
01:41:21 <fr33domlover> merijn, could you plz explain why? :)
01:41:38 <Cale> bernalex: Well, sure... but maybe such a binary doesn't exist for the platform you'd like to run GHC on
01:41:39 <merijn> fr33domlover: Completely arbitrary and whimsical personal intuition?
01:41:53 <merijn> fr33domlover: attoparsec seems to have more convenient combinators for large pieces of text
01:42:00 <bernalex> Cale: then I guess hugs is the closest you get. IDK how far behind UHC is.
01:42:07 <medfly> bernalex: it requires GHC.
01:42:09 <merijn> fr33domlover: binary has nice combinators for stuff like Word32/64/Float/Double
01:42:11 <Cale> If you're really stuck in such a position, then your best bet right now is to cross compile GHC
01:42:24 <fr33domlover> merijn, hmm good point
01:42:34 <merijn> Cale: Right, but then you need to trust your cross-compiling GHC :p
01:42:37 <Cale> You can't build GHC with anything that's not GHC right now, and all the other implementations of Haskell are years of work away from being able to do so
01:42:53 <Cale> merijn: That's supposing that this has something to do with trust...
01:43:04 <merijn> Cale: The initial discussion did
01:43:04 <Cale> oh, I missed part of this
01:43:14 <Cale> Yes, sure
01:43:25 <merijn> For the interested: https://github.com/ghc/ghc/tree/e7d21ee4f8ac907665a7e170c71d59e13a01da09
01:43:29 <merijn> The very first GHC commit :p
01:44:11 <Cale> of course, retroactively constructed
01:44:12 <merijn> oh, it's version 0.26, so presumably some older versions exist SOMEWHERE
01:44:31 <Cale> git didn't exist back then, and neither did darcs
01:44:50 <bernalex> maybe they used the master race vcs -- gzipped tarballs
01:44:54 <merijn> Cale: Sure, but I would've assumed the migration from CVS/SVN to darcs would've saved the history
01:44:56 <medfly> or, you know, cvs
01:45:43 <bernalex> medfly: svn is pretty new.
01:45:48 <bernalex> sorry merijn ^
01:45:59 <bernalex> GHC existed long before svn. idk if they used svn at some point though.
01:46:05 <medfly> CVS has been around since 1990.
01:46:22 <bernalex> tarballs -> cvs -> svn -> darcs -> git sure would be a lot of migrations
01:46:33 <srhb> medfly: And ghc, what, 1991?
01:46:41 <merijn> Maybe they used VCS and went "VCS -> darcs"?
01:46:49 <merijn> VCS is 70s, or so, no?
01:47:10 <opqdonut> VCS or RCS?
01:47:19 <bernalex> srhb: ghc was released in 92.
01:47:24 <jcdietrich> VCRs?
01:47:29 <bernalex> opqdonut: I would assume RCS not VCS myself.
01:47:37 <merijn> oh, I forgot about RCS
01:47:38 <srhb> bernalex: OK :)
01:47:52 <bernalex> srhb: so I guess they probably had code in 91, heh
01:47:54 <merijn> Anyone know if Lennart's original compiler source was preserved somewhere?
01:48:07 <jcdietrich> now I'm picturing storing source on VCR tapes
01:48:26 <bernalex> merijn: hbc?
01:48:58 <bernalex> *someone* must have the code lying around somewhere :]
01:54:40 * hackagebot proteaaudio 0.6.3 - A wrapper for the proteaaudio library.  https://hackage.haskell.org/package/proteaaudio-0.6.3 (CsabaHruska)
02:24:42 * hackagebot vulkan 1.5.1.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-1.5.1.0 (jophish)
02:27:55 <tdammers> seriously, how do I figure this out - two machines, both running the same OS with the same APT sources, both up-to-date, both running the latest stack release, and both compiling the same project; one builds just fine, the other hangs, with the last message being about downloading a package (temporary-1.2.0.3, but it hangs on other packages for different projects)
02:28:46 <jophish> tdammers: network problems?
02:29:06 <hyPiRion> tdammers: clean the cache and retry maybe?
02:30:08 <dzotokan> Hi there! Anyone keen on helping with monad transformers understanding?
02:30:14 <tdammers> hyPiRion: Did that - nuked ~/.cabal, ~/.ghc, ~/.stack, ./.stack-work on both machines, repeatedly, but the behavior remains consistent
02:30:44 <tdammers> I also fiddled with different stack releases, but anything from 3.17 to 5.5 shoes the same behavior
02:31:11 <liste> dzotokan: probably - you can always just ask your question and wait for someone with the skills and knowledge to see the question and perharps answer
02:31:15 <tdammers> network problems was on my list, but considering how it fails at exactly the same point, consistently, and the other machine consistently works fine while on the same network, I doubt that too
02:33:07 <dzotokan> So, I have a signature like this `f :: (M1 IO m, M2 m) => Thing -> Int -> LibT m a -> m a` and can't figure out how to dig through to the result.
02:33:40 <merijn> dzotokan: That seems like less of a transformers confusion and more of a "mtl typeclasses" confusion? :)
02:33:40 <luigy> tdammers try `stack -v build i-am-the-package-that-hangs-1.2.3`
02:33:44 <hyPiRion> tdammers: whelp, that's... interesting. Are the specs otherwise similar (e.g. same amount of memory)?
02:33:54 <tdammers>  hold the horses
02:34:03 <dzotokan> I would like `f` to run in main.
02:34:06 <tdammers> it turns out I wasn't actually using the same network connection after all
02:34:09 <liste> dzotokan: is M1 something like MonadBase or MonadBaseControl ?
02:34:30 <tdammers> the machine that works fine accidentally sat on my phone's wireless AP
02:34:42 <dzotokan> @liste - exactly. M1 - MonadBaseControl IO m and M2 - MonadResource m
02:34:42 <lambdabot> No module "- exactly. M1 - MonadBaseControl IO m and M2 - MonadResource m" loaded
02:34:58 <tdammers> so apparently corporate IT is doing some deep package inspection here
02:34:59 <merijn> dzotokan: The thing with mtl style typeclasses is that they're nice for writing individual bits and pieces, but to RUN a monad stack, you HAVE to decide on a concrete stack to execute
02:35:00 <tdammers> or some such
02:35:25 <merijn> dzotokan: i.e. you have to pick a specific transformer stack to represent the 'm' type
02:36:55 <dzotokan> hmmm...not sure I'm following 100%. Does it mean I have to specify the exact `m`?
02:38:55 <lyxia> yes
02:40:14 <dzotokan> <merijn> Let me try make it clearer :) So, in my `main :: IO ()` I'm running the monad and getting back a `LibT m0 OAuthToken`. I would like to print what's inside that to begin with
02:42:09 <merijn> dzotokan: You can't run it without picking an value for 'm'
02:42:28 <merijn> dzotokan: Presumably you do like "runLibT :: LibT m a -> m a", right?
02:42:50 <dzotokan> yeah!
02:42:59 <merijn> dzotokan: That means that after doing LibT you just have "m a", well, how do you "run" an 'm a'? You can't, unless you pick a SPECIFIC 'm'
02:43:34 <merijn> This confusion is why I dislike mtl for people new to transformers...
02:43:51 <dzotokan> right, ok! I guess i'm not sure what `picking` means...
02:44:01 <merijn> dzotokan: i.e. you'd have to say "ReaderT Foo (StateT s IO)"
02:44:28 <merijn> dzotokan: You're m is polymorphic, it's basically "this works for any 'm' IF it is an instance of the typeclasses M1 and M2"
02:44:41 <merijn> You need a specific type that is an instance of M1 and M2 and use that
02:45:09 <dzotokan> yep, I get that part.
02:46:00 <merijn> dzotokan: So it's hard to say without knowing what M1 and M2 are what an example would be
02:48:30 <dzotokan> merijn: the lib is `ig-0.6.1`. trying to get basic auth going by passing `getUserAccessTokenURL2` into the runnerT of the lib
02:49:33 <merijn> dzotokan: Do you have a minimal example of code with real types?
02:52:04 <dzotokan> merjin: Sure!   `token <- runInstagramT credentials mgr $ getUserAccessTokenURL2 redirectUri code`
02:55:01 <merijn> dzotokan: That's not really helpful, as I don't know the types of any of those things :)
02:56:01 <dzotokan> runInstagramT :: Credentials -> Network.HTTP.Client.Types.Manager -> InstagramT m a -> m a
02:56:36 <dzotokan> sorry =(
02:56:50 <merijn> Right, so the question is then, what's the type of "getUserAccessTokenURL2 redirectUri code"?
02:58:35 <dzotokan> merijn: `getUserAccessTokenURL2 :: (MonadResource m,MonadBaseControl IO m) => RedirectUri -> Text -> InstagramT m OAuthToken`
02:59:23 <dzotokan> Should constrains help answer my questions and I just don't understand how to read these signatures?
03:00:23 <merijn> dzotokan: So you need to find a monad that is an instance of MonadResource and MonadBaseControl
03:00:53 <merijn> dzotokan: Presumably this'll be, for example, "ResourceT IO OAuthToken"
03:01:04 <dzotokan> and use its transformer? 
03:05:51 <dzotokan> _goes back to studying monads_
03:10:26 <dzotokan> merijn: It worked! Thank you SO much!  :)
03:17:33 <John[Lisbeth]> [ x:y:[] | x <-[False,True], y <-[False,True]]
03:26:29 <Shockk> I had a weird idea and I'm unclear on the details so this might be kind of vague and messy, but:
03:28:35 <Shockk> I'm wondering if it would be possible, using DataKinds, to make use of say '[String, Int] and somehow create a tuple type by mapping over the types in that list, eliminating the need to have all these data definitions
03:28:37 <Shockk> http://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Tuple.html
03:29:01 <EvanR> you can make a nested tuple type like that
03:29:22 <EvanR> (String, (Int, ()))
03:29:27 <EvanR> and so on
03:29:33 <Shockk> ahh right
03:29:54 <EvanR> youd need a mechanism to get a value for any type though
03:30:09 <zyla> Shockk: HList does something similar I think
03:30:09 <Shockk> would that be equivalent, in performance, to (String, Int)?
03:30:30 <EvanR> i dont think so, but maybe there is an optimization going on
03:30:47 <Shockk> right, and I should also look at HList, I've heard of that in the past
03:31:06 <EvanR> i think HList predates a lot of the current tricks and hacks to do these things
03:32:03 <EvanR> for your question, you still have to answer what is the general mechanism to produce values of the given (any) types
03:32:29 <Shockk> hmm I didn't really think about that
03:32:58 <EvanR> that is why types are awesome, they force you to actually answer questions you may never thought to ask ;)
03:33:41 <EvanR> or reconsider why boldly giving an answer like "obviously use NULL" would have the consequences it does
03:35:31 <Shockk> my head hurts thinking about types like this
03:35:48 <EvanR> Shockk: one way is to use a type class to describe a certain property of the list of types, a property that allows you to construct values
03:36:44 <Shockk> that's true
03:37:37 <EvanR> then the algorithm would look like HasTheProperty ts us => ts -> us, and HasTheProperty would need to be a MTCP where | ts -> us is a fundep. ts is either '[] or t':ts, and us is () or (u,us)
03:37:43 <EvanR> i think
03:37:48 <Shockk> MTCP?
03:37:56 <EvanR> multiparameter typeclass
03:38:03 <EvanR> MPTC
03:38:06 <Shockk> oh right
03:38:45 <EvanR> HasTheProperty the class can have a superclass like Default or Show or something which lets you build values
03:39:01 <EvanR> or Read, and or takes other input to build types with
03:39:14 <Shockk> I think I understand
03:39:25 <EvanR> er build values with
03:39:42 <Shockk> building types with could be fun
03:40:02 <EvanR> for building types, i think type families might work better
03:40:42 <EvanR> let me tell you about a recent experience i had trying to use '[t1,t2,...] for this and what i replaced it with
03:41:05 <Shockk> okay
03:41:39 <EvanR> instead of having a complex property class to do something with a properly chosen list of types, and having the class constraint be pretty mysterious on the use-site signature... 
03:42:08 <EvanR> to build the correct sequence of values i made a builder data type which used the type list as a phantom type
03:42:40 <EvanR> you append to this builder a value of the next type, and compose until you reach empty list of types, and youre done
03:42:52 <Shockk> ahh irght
03:42:54 <Shockk> ahh right*
03:43:07 <Shockk> I've done something similar to that for a thing I wrote like last year 
03:43:18 <EvanR> the phantom type has the current "missing types" list, but internally a rank2 type has the correct final type
03:43:34 <EvanR> so whatever has access to the internals of the builder can use the result
03:44:06 <EvanR> so that ended up being more understandable from the outside
03:45:11 <EvanR> it answers the question of how you produce values, however the user wants to
03:45:22 <Shockk> urp
03:45:24 <Shockk> yep*
03:45:45 <nrky> hello, could lazyness be the reason why a `trace` is not being run in a case _ of? if so, how can I debug the code?
03:45:48 <Shockk> I kind of want to go and prototype something like this 
03:47:08 <nrky> https://dpaste.de/XOrQ this is the function. I can see the `RET ATOM` but not any of the traces of the guards.
03:48:03 <EvanR> you return a case expression
03:48:04 <Gurkenglas> Now I find myself needing, anologously to "(f .: g) x = f . g x" or "(f . g) x = f $ g x", "(y >>_= f) x = y >>= f x"... anyone else encountered that need? These all have in common that they allow you to separate the x out with a $ rather than brackets if x takes multiple lines. Is there a way to have a $ that has highest precedence to the left, but lowest precedence to the right?
03:48:33 <nrky> EvanR: but it evalutes, right? if not, how can I make it evaluate?
03:48:49 <EvanR> wherever that case ends up, you can make it evaluate with a bang pattern
03:49:02 <EvanR> though whatever the bang pattern is in needs to evaluate for it to matter
03:49:33 <EvanR> you can also do it locally
03:49:43 <EvanR> using seq
03:50:03 <{AS}> @pl \f g x -> f . g x
03:50:03 <lambdabot> (.) . (.)
03:50:03 <Gurkenglas> As in, something that would act like the parser had a preprocessor that replaced every occurence of that operator with a pair of brackets spanning from there to the end of the definition
03:50:08 <nrky> EvanR: how can I do that?
03:50:11 <{AS}> Gurkenglas: ^
03:50:33 <{AS}> @pl \x -> f . g x
03:50:33 <lambdabot> (f .) . g
03:50:44 <{AS}> or the one above I think is the one you are looking for
03:50:44 <EvanR> seq thatThing (return thatThing)
03:51:09 <Gurkenglas> {AS}, right, but I'm asking for a general solution.
03:51:28 <EvanR> it might be easier to just put the case in a let, assign the result to a banged variable, and return the variable
03:51:43 <EvanR> or use seq
03:51:50 <Gurkenglas> Like an empty lambda
03:52:07 <{AS}> Gurkenglas: what do you mean lowest precedence to the right?
03:52:17 <Gurkenglas> <Gurkenglas> As in, something that would act like the parser had a preprocessor that replaced every occurence of that operator with a pair of brackets spanning from there to the end of the definition
03:53:03 <Gurkenglas> Everything to the right of it is put into brackets and plugged into the thing immediately to the left of it
03:53:31 <{AS}> so a $ b $ c would become a $ (b $ c) ? 
03:53:56 <Gurkenglas> yep, let's call it ($)
03:54:07 <Gurkenglas> whoops mistype I meant (§)
03:54:30 <{AS}> so a Â§ b Â§ c would become what? 
03:54:32 <EvanR> the simoleon operator
03:54:47 <Gurkenglas> f >>= g § x + y = f >>= g (x + y)
03:54:48 <{AS}> Gurkenglas: I am just trying to understand
03:55:16 <{AS}> Gurkenglas: Ah, that just requires that you give Â§ higher precedence than >>= but lower than +
03:55:53 <Gurkenglas> And that isn't always the case, so I want something that to the right acts like something with lowest precedence, and to the left like something with highest
03:57:20 <Gurkenglas> Which would probably have to be implemented at the same level of compiler extension that do blocks would?
03:57:42 <{AS}> Gurkenglas: So you are saying if you have a1 op a2 op a3 ... op an Â§ b1 op b2 op b3 ... op bn then that would become a1 op a2 op a3 ... op an Â§ (b1 op b2 op b3 ... op bn) ?
03:58:39 <Gurkenglas> It would become "a1 op a2 op a3 ... op an (b1 op b2 op b3 ... op bn)"
03:59:37 <Gurkenglas> (But yes yours is still correct and would be maximally reduced if after parsing, § wouldnt be just an alias for $)
03:59:37 <{AS}> Gurkenglas: It depends on the parsing framework, but yes it would be possible
04:00:03 <{AS}> I don't think it is possible with Haskell's fixity declarations though
04:00:22 <Gurkenglas> Yea which is why I said that thing with it would need a ghc extension
04:01:28 <{AS}> You would have to factor our the grammar so it becomes something like ExprWithoutÂ§ ::= ....; Expr ::= ExprWithoutÂ§ 'Â§' Expr | ExprWithoutÂ§ or something like that
04:02:47 <{AS}> Which basically makes Â§ have lowest precedence and right associativity
04:03:28 <{AS}> You can't have it another way I think
04:03:50 <{AS}> e.g. if you have a >>= b Â§ c and you want to give >>= lower precedence
04:05:07 <{AS}> because it is not possible for the parser to know if it should have (a >>= b) Â§ c or a >>= (b Â§ c)
04:06:31 <{AS}> Maybe if you use a contextual grammar 
04:07:06 <Gurkenglas> Would a preprocessor be too hacky that replaces every § with a (, goes forward to the next ) that was not balanced by a ( we traversed since the §, (or to the end of the definition) and inserts another )?
04:08:26 <quchen> Just use parentheses.
04:09:01 <quchen> GHC is terrible enough in its support of ($) in order to avoid parentheses, please do not extend that pattern.
04:09:04 <Gurkenglas> Even if the right side of the § takes multiple lines, for example a do block?
04:09:48 <quchen> Yes.
04:11:03 <quchen> There were some talks about allowing something like `runST do { ... }`, but since the community is split on the topic it likely won't land.
04:11:30 <{AS}> quchen: wouldn't runST $ do {Â ...Â } already work?
04:11:46 <quchen> Yes, that would work, but it requires a very questionable hack in GHC to work.
04:11:54 <ggole> That only type checks because it is hacked into GHC at the syntax level
04:11:55 <quchen> That ($) isn't easy to typecheck.
04:12:04 <{AS}> Oh
04:12:15 <ggole> Try ($) runST (...) and see.
04:12:26 <quchen> > ($) runST (pure ())
04:12:26 <{AS}> I guess that is why Idris has it hacked in the parser :)
04:12:27 <lambdabot>      Couldn't match type â€˜f0 ()â€™ with â€˜forall s. ST s aâ€™
04:12:27 <lambdabot>      Expected type: f0 () -> a
04:12:27 <lambdabot>        Actual type: (forall s. ST s a) -> a
04:12:40 <quchen> > runST $ pure ()
04:12:41 <lambdabot>  ()
04:12:48 <ggole> It really is a dodgy hack.
04:12:56 <{AS}> Yeah
04:13:05 <ggole> Not *harmful*, but totally ad hoc.
04:13:31 <{AS}> > (#) (pure ()) runST
04:13:33 <lambdabot>  <hint>:1:3: parse error on input â€˜)â€™
04:13:52 <quchen> > pure () & runST
04:13:53 <lambdabot>      Couldn't match type â€˜f0 ()â€™ with â€˜forall s. ST s bâ€™
04:13:53 <lambdabot>      Expected type: f0 () -> b
04:13:53 <lambdabot>        Actual type: (forall s. ST s b) -> b
04:14:03 <{AS}> Thanks
04:14:23 <quchen> ?let f $$$ x = f x
04:14:25 <lambdabot>  Defined.
04:14:28 <quchen> > runST $$$ pure ()
04:14:30 <lambdabot>      Couldn't match type â€˜f0 ()â€™ with â€˜forall s. ST s tâ€™
04:14:30 <lambdabot>      Expected type: f0 () -> t
04:14:30 <lambdabot>        Actual type: (forall s. ST s t) -> t
04:14:34 <quchen> ?undef
04:14:34 <lambdabot> Undefined.
04:14:41 <{AS}> Why does it require f0 () ?
04:14:41 <quchen> It's really just for infix ($).
04:14:45 * hackagebot scientific 0.3.4.6 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.6 (BasVanDijk)
04:15:20 <quchen> I don't know.
04:15:26 <{AS}> Ah I see
04:16:09 <quchen> Here's a paragraph on the issue: https://github.com/quchen/articles/blob/master/fbut.md#-has-special-powers
04:17:08 <{AS}> I think it is because it requires a dependent ($) to work
04:17:23 <quchen> Dependent?
04:17:24 <{AS}> and Haskell doesn't have that (for obvious reasons)
04:17:29 <quchen> There are no dependent types involved here.
04:17:50 <quchen> runST has a rank-2 type, that's the issue.
04:19:31 <breadmonster> Hello.
04:20:16 <ggole> AS: I think f0 is just a unification variable. If the forall did not prevent further type checking, presumably it would be unified with ST s.
04:20:29 <srhb> :t runST $$$ undefined
04:20:31 <lambdabot>     Not in scope: â€˜$$$â€™
04:20:31 <lambdabot>     Perhaps you meant one of these:
04:20:31 <lambdabot>       â€˜$$â€™ (imported from Text.PrettyPrint.HughesPJ),
04:20:35 <srhb> Oh, undeffed.
04:21:04 <{AS}> > ($) runST (pure () :: forall s. ST s ())
04:21:05 <lambdabot>      Couldn't match type â€˜ST s0 ()â€™ with â€˜forall s. ST s aâ€™
04:21:05 <lambdabot>      Expected type: ST s0 () -> a
04:21:05 <lambdabot>        Actual type: (forall s. ST s a) -> a
04:21:58 <{AS}> > ($ :: forall s. ST s () -> ()) runST (pure ())
04:21:59 <lambdabot>  <hint>:1:4: parse error on input â€˜::â€™
04:22:04 <{AS}> > (($) :: forall s. ST s () -> ()) runST (pure ())
04:22:06 <lambdabot>      Couldn't match expected type â€˜f0 () -> tâ€™ with actual type â€˜()â€™
04:22:06 <lambdabot>      The function â€˜($) :: forall s. ST s () -> ()â€™
04:22:06 <lambdabot>      is applied to two arguments,
04:22:18 <quchen>  /msg lambdabot
04:22:25 <{AS}> quchen: Yeah, sorry
04:44:46 <clintm> k
04:44:58 <clintm> oops.  window focus. :P
04:45:08 <mniip> k
05:00:27 <Aleksejs> Hi, what should I do to make this work: ((1 /) . floor) 2.3
05:00:48 <mniip> sounds like you want the opposite?
05:00:52 <mniip> floor . recip
05:01:59 <Aleksejs> recip . floor actually, but the problem is with type
05:02:09 <Aleksejs> (recip . floor) 2.3
05:02:12 <Aleksejs> > (recip . floor) 2.3
05:02:13 <lambdabot>      No instance for (Show a0)
05:02:13 <lambdabot>        arising from a use of â€˜show_M456270744512247049018538â€™
05:02:13 <lambdabot>      The type variable â€˜a0â€™ is ambiguous
05:02:49 <sbrg> > (recip . floor) 2.3 :: Double
05:02:50 <lambdabot>      No instance for (Integral Double) arising from a use of â€˜floorâ€™
05:02:50 <lambdabot>      In the second argument of â€˜(.)â€™, namely â€˜floorâ€™
05:02:50 <lambdabot>      In the expression: recip . floor
05:02:56 <sbrg> eh
05:03:02 <sbrg> oh..
05:03:03 <mniip> :t floor
05:03:04 <lambdabot> (Integral b, RealFrac a) => a -> b
05:03:07 <mniip> ^
05:03:15 <sbrg> > recip . fromIntegral . floor $ 2.3 
05:03:16 <lambdabot>  0.5
05:05:02 <Aleksejs> thanks!
05:05:14 <nrky> hello, /EXIT 
05:05:17 <nrky> ugh
05:05:59 <mniip> hello /exit ineed
05:15:04 * hackagebot language-fortran 0.5 - Fortran lexer and parser, language support, and extensions.  https://hackage.haskell.org/package/language-fortran-0.5 (DominicOrchard)
05:20:04 * hackagebot camfort 0.615 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-0.615 (DominicOrchard)
05:25:11 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
05:25:11 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
05:31:29 <mpickering> stack is hanging after a simple "stack build", how can I debug this?
05:32:10 <tdammers> mpickering: I was told to use -v, see if that pops up anything more useful
05:33:11 <mpickering> so it apparently starts downloading the package and then just hangs
05:33:32 <tdammers> yeah, had the same thing happen to me
05:33:40 <tdammers> switching to a different network connection fixed it
05:33:55 <cocreature> mpickering: is that a git package?
05:33:58 <mpickering> I don't understand how everyone else apart from me has a pain-free time with stack, I always run into these annoying problems
05:34:04 <cocreature> they can take a fair amount of time
05:34:18 <mpickering> no, I just added the package to my cabal file
05:34:35 <Peaker> mpickering: if you have network trouble it can probably hang a lot
05:34:39 <cocreature> hm no idea then
05:34:52 <tdammers> in my case, I am rolling with the tentative hypothesis that corporate IT has some sort of broken content filtering in place that suffers false positives
05:34:58 <mpickering> ok so can I use "cabal get" and then just install it into the stack db somehow?
05:35:13 <mpickering> I'm on a university network so it should be ok
05:39:23 <mpickering> and I just installed a bunch of other packages so no idea what the problem is now
06:28:03 <Cooler> so i am looking at the source of the IO monad
06:28:14 <Cooler> whats the # operator do?
06:28:51 <nschoe> Cooler, can you give the link?
06:29:44 <stelleg> Cooler: my guess is that it's the magic hash
06:29:56 <stelleg> https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/syntax-extns.html
06:30:21 <Cooler> http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#line-1064
06:32:24 <aweinstock> #'s are used for 3 different things in that snippet: inline pragmas {-# INLINE foo -#}, unboxed tuples (# s, x #), and MagicHash names (State#)
06:33:14 <aweinstock> unboxed tuples are a special datastructure that mean something like "pass these in registers"
06:33:49 <aweinstock> MagicHash names are a naming convention that make primitives (like State#, Int#, Addr#, and so on) stand out
06:34:05 <aweinstock> # isn't an operator in any of these uses
06:35:07 <Cooler> its a postfix modifier
06:35:21 <Cooler> why is it used as prefix in # s?
06:36:25 <demize> Cooler: It's not a prefix.
06:36:37 <demize> It's (# #).
06:37:38 <Cooler> why isn't it (s#, x#)?
06:38:09 <demize> ... Because it's not related to s and x.
06:39:09 <demize> (# foo, bar, baz, froobz #) constructs an unboxed tuple.
06:39:46 <Cooler> does x # mean you are calling x on #?
06:39:48 <demize> Which is used when you don't want the heap allocations that a regular tuple would give you.
06:41:18 <pavonia> Cooler: Again, "it's not related to s and x"
06:41:32 <aweinstock> # is very magic in these contexts
06:41:58 <pavonia> Normal tuple syntax is ( , , , ), unboxed tuple sytax is (# , , , #)
06:42:29 <Cooler> what do you mean when you say that? do you mean arbitrary and implementation dependant?
06:42:40 <barrucadu> It's a piece of syntax
06:43:01 <aweinstock> yes, # is a GHC-specific thing (and hence implementation dependent)
06:44:09 <Cooler> so (# s, x #) is really (#, s, x, #) ?
06:44:39 <pavonia> No
06:44:48 <pavonia> The commas are separateing the variables
06:45:30 <demize> Just as (s, x) isn't actually (, s, x, ).
06:48:29 <pavonia> Cooler: Instead of simple parentheses you use parentheses with a hash symbol on the both sides. What's so confusing about that?
06:48:29 <Cooler> oh i thought the # were part of identifiers
06:48:29 <Cooler> ok so you go from () to (# #)
06:48:29 <demize> You were told that twice. :/
06:48:29 <demize> Well, more than twice..
06:48:29 <merijn> Unboxed tuples are pretty deep implementation voodoo
06:48:29 <demize> And have restrictions.
06:48:29 <Cooler> ok now the code makes a lot more sense
06:48:53 <merijn> FYI, IF you're gonna dive into implementation voodoo of IO, you probably want to read the "Lazy Functional State Threads" paper
06:50:18 <pgens> hi I'm trying to create thumbnails(package https://hackage.haskell.org/package/thumbnail-plus-1.0.5/docs/Graphics-ThumbnailPlus.html) inside forkIO but I get this error: "No instance for (MonadResource IO) arising from a use of â€˜createThumbnailsâ€™ ". I am pretty new to haskell :) so how can I wrap the result of createThumbnails into an IO Monad, or is this the right way to go?
06:50:47 <{AS}> pgens: What type does your function have?
06:51:07 <{AS}> Oh, forkIO
06:54:42 <{AS}> pgens: Try runResourceT $ createThumbnails cfg fp
06:54:53 <{AS}> inside the forkIO
06:55:17 <pgens> {AS}: ok thank you, I will try this
06:55:39 <Shockk> createThumbnails is constrained by MonadResource m, so your monad has to be a MonadResource,
06:56:37 <Shockk> one of the instances of MonadResource is (MonadThrow m, MonadBase IO m, MonadIO m, Applicative m) => MonadResource (ResourceT m), which just means there's an instance for (ResourceT m), and ResourceT can be used like other monad transformers
06:57:51 <Shockk> runResourceT :: ResourceT m a -> m a, so when your function is in IO, this would be ResourceT IO a -> IO a
06:57:53 <scshunt> sjfasldfj hackage
06:57:53 <Gurkenglas> (All the other MonadResource instances require you to already have a MonadRessource instance, (and the deducable instances are always larger than the required one), so you must start with that one)
07:01:18 <{AS}> I am not sure why there is not just a (MonadThrow m, MonadBase IO m, MonadIO m, Applicative m) => MonadResource m instance
07:01:29 <{AS}> or that MonadResource is just a constraint alias of those constraints
07:01:37 <scshunt> is there a good guide somewhere to using MonadControl?
07:02:00 <scshunt> err
07:02:04 <scshunt> MonadTransControl and MonadBaseControl
07:02:09 <scshunt> (and the difference between them)
09:04:13 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
09:04:13 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
09:04:13 <ARM9> ^_^
09:04:19 <ARM9> Yes that looks useful
09:04:42 <EvanR> all your monad base control
09:08:04 <{AS}> pgens: that is have runResouceT after forkIO $ before the do
09:12:24 <Gurkenglas> pgens, by the way, "lift (liftIO getCurrentTime)" should just be "liftIO getCurrentTime" unless some library author didn't lift MonadIO instances
09:14:20 <pgens> {AS}: Yeah it worked :-) Thank you so much!!
09:14:38 <{AS}> pgens: sure :)
09:14:58 <pgens> Gurkenglas: thank you, I will fix that :)
09:17:59 <seishun> is there any documentation for =~ and =~~? this isn't very informative http://hackage.haskell.org/package/regex-posix-0.95.2/docs/Text-Regex-Posix-Wrap.html#v:-61--126-
09:18:58 <EvanR> nice, i was just complaining about this kind of type sig
09:19:15 <EvanR> A a, B b, C c => a -> b -> c
09:20:37 <EvanR> seishun: from the source, it says something like (=~) r x = ... in match (make r) x
09:20:55 <EvanR> so the first arg is the regex, and the second arg is the thing youre scanning
09:21:06 <EvanR> but its typeclassed to hell to make it flexible
09:21:47 <seishun> EvanR: namely I wanted to know the difference between =~ and =~~
09:22:03 <EvanR> ... and =~~ uses matchM
09:22:39 <EvanR> see the monad constraint on =~~
09:22:48 <EvanR> it returns an m target instead of target
09:23:15 <xa0> :t (=~)
09:23:16 <lambdabot>     Not in scope: â€˜=~â€™
09:23:17 <lambdabot>     Perhaps you meant one of these:
09:23:17 <lambdabot>       â€˜==â€™ (imported from Data.Eq), â€˜#~â€™ (imported from Control.Lens),
09:23:49 <EvanR> since it works on any monad and doesnt seem to use the monad for anything against the other types, i am going to guess that it simple `returns' the answer so you can use it in do notation
09:24:46 <EvanR> xa0: (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
09:24:50 <seishun> I ~think~ =~~ returns just the first match
09:25:14 <seishun> and if it doesn't match it return the fail form of the monad (whatever it's properly called)
09:25:18 <xa0> ty
09:25:19 <EvanR> well target is heavily polymorphic
09:25:28 <EvanR> hard to say
09:25:33 <EvanR> but that would make sense
09:53:05 <icicled> anyone remember the url for the Lens talk at NICTA (I think)?
09:53:35 <parsecChar> if I'm writing a js backend, is https://hackage.haskell.org/package/js-good-parts a good target, or should I aim for something else?
09:54:11 <icicled> I remember distinctly that in one part the speaker mentioned how to use lenses to limit the scope of a function within a transformer (or something to that effect)
09:54:33 <icicled> within a reader
09:54:51 <c_wraith> icicled, that sounds like zoom for state
09:56:14 <Cooler> so anyone here used GLFW?
09:56:21 <c_wraith> icicled, or magnify for Reader, I suppose
09:56:23 <Cooler> GLFW-b to be precise
09:56:34 <Cooler> for doing rendering?
09:56:54 <icicled> thanks c_wraith that's a good starting point for me
09:57:06 <c_wraith> icicled, https://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Zoom.html discusses those operations. 
09:57:21 <c_wraith> icicled, I don't know about the talk you mentioned, though. 
10:02:20 <icicled> thanks!
10:04:08 <Fylwind> anyone know of a codegolf-y (pointless) way of writing: let whenM mc mx = mc >>= \ c -> when c mx ? :P
10:05:02 <Fylwind> I mean besides (. flip when) . (>>=) â€¦ which feels kind of artificial
10:08:46 <mniip> Fylwind, that's what I got too
10:08:58 <EvanR> Fylwind: this combinator is in monad-loops among other things
10:09:13 <EvanR> just use whenM in real ode
10:10:05 <seishun> `flip when mx <$> mc` ?
10:10:15 <Fylwind> EvanR: I don't see that combinator in monad-loops
10:10:32 <mniip> seishun, that's wrong
10:11:18 <EvanR> me neither
10:11:22 <EvanR> :t guard
10:11:23 <lambdabot> Alternative f => Bool -> f ()
10:11:43 <mniip> that's different
10:12:09 <EvanR> well it exists in some more or less tangential packages, might as well just define it somewhere in your code
10:12:32 <seishun> mniip: why?
10:12:47 <mniip> seishun, <$> is not >>=
10:13:09 <EvanR> @djinn Monad m => m Bool -> m () -> m ()
10:13:10 <lambdabot> f _ a = a
10:13:21 <mniip> djinn can't into typeclasses iirc
10:13:46 <EvanR> cant argue with that implementation tho
10:14:18 <Fylwind> EvanR: haha
10:14:37 <EvanR> try to avoid returning or tolerating Bool returns anyway
10:14:44 <EvanR> shit like this ends up being necessary
10:16:16 <Fylwind> well in this case the Bool is an environment variable for controlling debug mode
10:16:59 <EvanR> oh god, then you dont want to be putting whenEs literally everywhere
10:17:28 <EvanR> er whenM
10:17:34 <Fylwind> fortunately it's only 2-3 places
10:20:58 * hackagebot distributed-process-ekg 0.1.1.0 - Collect node stats for EKG  https://hackage.haskell.org/package/distributed-process-ekg-0.1.1.0 (AlexanderBondarenko)
10:21:23 * fr33domlover thinks he finally understands why applyFst and applySnd are that common or needed... we already have 'first' and 'second' from Control.Arrow
10:21:35 <fr33domlover> *aren't that common
10:22:12 <Cale> Yeah, or just lambdas
10:23:02 <Cale> Or if you don't mind the extreme overkill, lenses
10:24:13 <Cooler> what does when do?
10:24:27 <Cooler> https://github.com/bsl/GLFW-b-demo/blob/master/src/Main.hs#L149
10:24:44 <fr33domlover> Cooler, run the action only if the boolean is True
10:24:46 <MarcelineVQ> @src when
10:24:46 <lambdabot> when p s = if p then s else return ()
10:25:13 <fr33domlover> Cale, lambdas work but it's annoying when repeated :P
10:26:24 <fr33domlover> (\ (x, y) -> (f x, y)) (a, b)     VS     applyFst f (a, b)    VS    first f (a, b)
10:27:09 <Cooler> it returns a empty tuple?
10:27:35 <Cooler> i mean creates a monad of an empty tuple?
10:28:22 <fr33domlover> Cooler, example: when userWantsOutput $ putStrLn "hello world"
10:28:45 <fr33domlover> it doesn't create a monad; monads are types you defin in the code, not create at runtime
10:29:17 <Cooler> i mean creates a monad of an empty tuple?
10:29:32 <fr33domlover> Cooler, i suggest you read the Haskell Wikibook a bit first
10:29:35 <Cooler> return creates a monad right?
10:29:56 <fr33domlover> Cooler, a monad is a type, it's not created at runtime
10:29:56 <Cooler> it gives the value a minimum amount of context?
10:30:20 <fr33domlover> 'return' is a method of the 'Monad' class
10:30:30 <Cooler> it creates a monadic value?
10:30:33 <fr33domlover> if that doesn't tell you much, plz read a bit in the wikibook
10:30:54 <EvanR> > return 3 :: Maybe Int
10:30:55 <lambdabot>  Just 3
10:31:01 <fr33domlover> Cooler, hmm that's closer but i wouldn't say "creates"
10:31:17 <Cooler> it outputs a monadic value?
10:31:18 <fr33domlover> in Haskell pure code doesn't "create" :P
10:31:33 <fr33domlover> :t return
10:31:34 <lambdabot> Monad m => a -> m a
10:31:37 <fr33domlover> Cooler, ^
10:31:52 <fr33domlover> it lifts a "plain" value into a monad
10:32:07 <Cooler> right "lifts"
10:32:10 <EvanR> values are immutable objects created at runtime, it helps to think of them like this to attempt to wrangle performance predictions
10:32:45 <EvanR> there are no values at compile time, there are no types at runtime
10:32:45 <fr33domlover> Cooler, personally i strongly suggest you read the Haskell Wikibook, at least the basics part
10:32:56 <fr33domlover> that's how i learned haskell and it's amazing
10:33:04 <fr33domlover> (of course i also needed a lot of practice...)
10:33:48 <Cooler> when you use the term "lifts" what does that actually mean? if it doesn't mean create or output
10:33:56 <Cooler> converts?
10:34:11 <xa0> Yes!
10:34:31 <Cooler> isn't converting just creating a new value and destroying the older one?
10:34:40 <xa0> No!
10:35:07 <xa0> You see in pure code, nothing is mutable. You don't "create" values, you work with them
10:35:16 <xa0> You can never destroy a value, only ignore it
10:35:40 <Cooler> i know but how do you convert something that is immutable?
10:36:14 <xa0> You return the lifted value, and ignore the original
10:36:15 <simpson> Cooler: How do you feel about Just?
10:36:26 * hackagebot timelike-time 0.1.1 - Timelike interface for the time library  https://hackage.haskell.org/package/timelike-time-0.1.1 (esz)
10:36:38 <simpson> > Just 42 -- totally "lifting" 42 into the Maybe Monad
10:36:40 <lambdabot>  Just 42
10:37:34 <Cooler> xa0 what you said seems to imply it creates a new value
10:38:19 <david_koontz> Cooler, it might help to think of this process as an image editor where every time you make any edit, there is a new copy created and the edit is applied to the new file, the old file is still on disk and you can go back to it, but now you have file1, file1.1, file1.2, etc.
10:38:20 <Cooler> return the lifted value and ignore te original, what do you mean by lift there?
10:38:23 <xa0> Create is entirely the wrong word
10:38:24 <seishun> is there a way to simplify: fromMaybe (error "oops") $ listToMaybe $ identifier =~~ identifierPattern
10:38:49 <nitrix> simpson: I don't like your use of lifted and Monad there.
10:39:04 <seishun> that =~~ should be =~
10:39:09 <simpson> > return 42 :: Maybe Int -- nitrix: And yet it's the Maybe Monad!
10:39:10 <lambdabot>  Just 42
10:39:28 <Cooler> david_koontz, the problem with that analogy is that you aren't actually creating anything
10:39:42 <Cooler> in haskell
10:39:44 <nitrix> simpson: Except the kinds don't match. Maybe isn't a monad.
10:39:59 <Cooler> what? Maybe is a monad
10:40:05 <nitrix> `Maybe a` is.
10:40:15 <Cooler> oh
10:40:15 <Gurkenglas> Pretty sure Maybe is the monad
10:40:24 <Clint> yup
10:40:27 <Cooler> isn't Maybe a the monadic value?
10:40:30 <Gurkenglas> It says "instance Monad Maybe"
10:40:33 <xa0> Yeah I think that's extreme overpedantism
10:40:37 <david_koontz> well, yeah you are, if I have a record {a = 5, b = â€œfooâ€} and I update that record, the old record isnâ€™t destroyed, I have a new record in memory that is {a = 6, b = â€œfooâ€} or whatever update I performed
10:40:40 <Gurkenglas> Cooler, to answer one of your earlier questions, "return ()" is the action that does nothing. (return x is the action that does nothing except having the value x. () is the value that has no information.)
10:41:07 <nitrix> Cooler: No, Maybe a is a type, Just 42 is the monadic value.
10:41:12 <david_koontz> the old record is still there and anyone who it was passed to can continue to hold onto it and use it
10:41:34 <david_koontz> so we have 2 values where before we had 1
10:41:47 <david_koontz> thatâ€™s the whole idea behind immutable data
10:41:50 <david_koontz> er values
10:41:50 <Cooler> yeah so Maybe is a monad
10:42:30 <Gurkenglas> ( https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#t:Monad <- There, all the instances don't mention the last type parameter)
10:42:32 <nitrix> `Maybe a` is a Monad. `Just 42` is a monadic value. You, instead, claimed `Maybe` was a monad and `Maybe Int` was a monadic value (it's wrong it's a type).
10:42:50 <Cooler> david_koontz, yeah but again the problem is apparently you are not allowed to just create stuff
10:43:05 <Gurkenglas> Maybe is a monad and Maybe Int could be called a monadic value type :D
10:43:12 <shachaf> nitrix: No, "Maybe" is a monad. "Maybe a" isn't.
10:43:22 <nitrix> My bad, I actually got `Maybe` wrong.
10:43:26 <nitrix> The monadic value still stand.
10:43:40 <Cale> You would usually not make a big deal out of the fact that Just 42 happened to belong to a type which was constructed by a monad though.
10:43:42 <nitrix> Gurkenglas: The hell is a "monadic value type" ?
10:43:47 <shachaf> Well, "monadic value" isn't a very standard term, but people will probably understand what you mean.
10:43:48 <Gurkenglas> A type of monadic values.
10:43:58 <nitrix> What does that even mean?
10:44:00 <xa0> Cooler: if I have the function f(x) = xÂ² in maths, and I apply 3 to f, does f "create" 9?
10:44:02 <david_koontz> not allowed? If you do `a = 4 : 5 : 6 : 7 : []` did you not just create a new list of Int?
10:44:13 <xa0> Or is that a terrible use of terminology
10:44:14 <Gurkenglas> Just 2 is a monadic value. Just 2's type is therefore a monadic value type.
10:44:22 <xa0> Because that is the point we want to make here
10:44:58 <nitrix> Gurkenglas: Monadic type I'd imagine?
10:45:00 <Cooler> xa0, well in that example, your talking about pure math
10:45:07 <Cale> I actually kind of dislike the uses of "monadic"
10:45:13 <Clint> functoric
10:45:20 <xa0> Cooler: And we're talking about pure code :)
10:45:23 <Cale> "Monadic" already meant something in mathematics, and we're using it incorrectly here.
10:45:38 <Gurkenglas> applicatic or applicativic?
10:45:38 <mnoonan> ^ "somethingS"
10:45:40 <xa0> A function in maths is the same as a function in Haskell.
10:45:49 <xa0> They are conceptually identical
10:45:55 <xa0> Do not differentiate them
10:46:02 <Cooler> xa0, well so what do you mean when you say create a value then?
10:46:03 <Cale> (but it was something that has been kind of irrelevant to us so far, so maybe it's not too bad to co-opt the word)
10:46:04 <nitrix> Cale: I'm doing this exercise because this is how we end up with monads called burritos and weird terminology for everything. Call me pedantic, it jumped to my eyes and had to ask him.
10:46:37 <Cale> But yeah, I mean, I would normally just say that Just 42 was a Maybe Integer or whatever
10:47:05 <Cale> The fact that Maybe happens to be a monad is mostly not relevant
10:47:08 <xa0> Cooler: create implies the imperative notion of variable allocation and assignment etc.
10:47:14 <Cale> Because it doesn't affect what Just 42 happens to be
10:47:29 <Cale> It's not intrinsic in any way to what Just 42 is
10:47:32 <ijmustafa> hey guys, what's the best way to send a ByteString as a response using Servant?
10:47:42 <nitrix> In interrupted because `Just 42` isn't "lifting to the Maybe monad" in my book.
10:47:49 <Cooler> xa0, see thats the problem with that pure maths example you gave
10:47:53 <MarcelineVQ> Cooler: I'm not sure if it's been explained yet, there's a couple tangents in the convo atm, but return or pure are methods you use to wrap a value in a type that implements pure or return. What that happens to be depends on what the type checker infers. in foo :: Char -> Maybe Char; foo b = return b would infer return to be the return from the Maybe instance for Monad, which happens to be return x = Just x I believe
10:48:00 <nitrix> Nor is Just Int a "monadic _value_" in my book.
10:48:01 <Cale> Similarly, the fact that IO is a monad doesn't really say anything about what getLine is
10:48:04 <nitrix> Maybe Int*
10:48:08 <xa0> Cooler: where is the problem?
10:48:12 <Cooler> xa0, in that example, it would make no sense to say "variable allocation"
10:48:25 <xa0> Exactly. It also makes no sense in haskell
10:48:25 <Cooler> theres no allocating memory in maths
10:48:30 <Cale> If you need a word, you can say that getLine is an action (in the IO monad)
10:48:31 <xa0> Neither is there in haskell
10:48:56 <xa0> Allocating memory is a side effect. Haskell has no side effects. QED
10:48:57 <Cooler> sure if you have haskell == maths
10:49:06 <david_koontz> xa0: you canâ€™t ignore that there is a runtime that has to execute on an actual computer at some point
10:49:11 <xa0> Of course
10:49:14 <nitrix> Cale: I agree. Besides my mistake of Maybe's kind, I still think it should be important that we try to be a little bit more pedantic. I hear things like "IO monad" way too frequently.
10:49:18 <nitrix> IO is more than a monad.
10:49:19 <xa0> But the whole IO shortcut fixes that
10:49:31 <Cale> nitrix: Yes! I agree with you on that
10:50:10 <Cale> The fact that IO is a monad doesn't really tell you enough to justify mentioning that it's a monad constantly.
10:50:39 <nitrix> (>>=) is just a glorified join . fmap :P
10:50:49 <Cooler> so why do you say "lifts" a value to a monadic value? does that mean the same as converts?
10:50:55 <Cale> Well, join is part of what it means to be a monad as well
10:51:05 <Cale> Cooler: where?
10:51:08 <nitrix> Cale: Yeah, I think join is the minimal definition for Monads?
10:51:19 <nitrix> Cale: (Along return). Is that the case in Haskell too?
10:51:22 <Cooler> Cale, from way earlier
10:51:49 <Cale> Cooler: "lifting" is a term used by people to mean various sorts of conversion from a type which is "smaller" or "simpler" to a type which is "larger" or "more expressive"
10:52:06 <nitrix> I personally don't like the term lifting.
10:52:09 <Cale> return :: (Monad m) => a -> m a   is always injective
10:52:12 <nitrix> :t fmap
10:52:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:52:25 <nitrix> To me, fmap is this, not some kind of (a -> b) -> (f a -> f b)
10:52:26 <Cale> Well, I say "always"
10:52:44 <Cale> But there is at least one monad in Haskell for which it is not
10:52:54 <Cale> It is *typically* injective anyway
10:53:29 <Cale> and so it's natural to think of it as "including" the values of type a among the values of type m a
10:53:50 <jakob1> i want to combine two functions as a predicate (for filter). is there an shorter way than: (\x -> f x && g x) ?
10:53:51 <jakob1> something that looks more like (f && g) ?
10:54:17 <Cale> (The counterexample is with e.g. the trivial monad,  data T a = T)
10:54:20 <Cooler> so in here
10:54:25 <Cooler> @src when
10:54:25 <lambdabot> when p s = if p then s else return ()
10:54:26 <nitrix> Cale: Can you even implement fmap if it had the type signature :: (a -> b) -> (f a -> f b) ?
10:54:39 <Cooler> what does return () mean?
10:54:41 <Cale> nitrix: What do you mean?
10:55:06 <dolio> Including the parentheses or not is the same.
10:55:13 <Cale> Cooler: return () is the action which "does nothing" (whatever that means for the monad in question), and produces the result ()
10:55:35 <Cale> Cooler: return is a function which is defined separately for each monad
10:55:48 <nitrix> Cale: I've seen people (the same people that likes using the term lifting) pretend that fmap "lifts" a function from (a -> b) to (f a -> f b), while this analogy could work because of currying, it's not practical. You can't implement fmap if it had such type I think.
10:56:17 <Cale> Cooler: So it's a little bit hard to express what it does in general, but it always has the flavour that return v will represent an action which does nothing except to, well, return v
10:56:27 <shachaf> They aren't pretending and it's not an analogy.
10:56:36 <Cooler> what is the () in return ()?
10:56:36 <nitrix> fmap' :: (a -> b) -> (f a -> f b)
10:56:39 <nitrix> fmap' f = ...
10:56:42 <shachaf> That's the type of fmap.
10:56:43 <mnoonan> nitrix: but they are literally the same type?
10:56:45 <nitrix> How would you implement it?
10:56:46 <shachaf> fmap' = fmap
10:56:51 <Cooler> because usually () are used in the context of tuples
10:57:02 <Cale> nitrix: For any given functor f, that *is* the type of fmap
10:57:06 <Cale> :t fmap
10:57:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:57:14 <Cale> -> associates to the right
10:57:17 <Cale> So this is the same as
10:57:22 <Cale> (a -> b) -> (f a -> f b)
10:57:28 <Enigmagic> :t fmap id
10:57:28 <lambdabot> Functor f => f b -> f b
10:57:37 <Cale> :t fmap (*2)
10:57:38 <lambdabot> (Functor f, Num b) => f b -> f b
10:57:44 <nitrix> Cale: I'm almost convinced you can't implement fmap' without using fmap.
10:57:49 <Cale> nitrix: huh?
10:58:03 <MarcelineVQ> jakob1: not that I can see, that's pretty terse
10:58:38 <Cale> data AtMostTwo a = None | One a | Two a a
10:58:44 <Cale> instance Functor AtMostTwo where
10:59:15 <Cale>   fmap f = (\x -> case x of None -> None; One v -> One (f v); Two u v -> Two (f u) (f v))
10:59:26 <Cale> easy
11:00:04 <Cale> Actually, joking aside this approach is often good when the thing is recursive
11:00:04 <nitrix> But that'd have type (a -> b) -> (f a -> f b)
11:00:16 <nitrix> Is it isomorphic?
11:00:20 <Cale> huh?
11:00:22 <nitrix> Is Haskell okay with that?
11:00:25 <mnoonan> nitrix: no, it's *equal*
11:00:26 <Cale> Is what isomorphic to what?
11:00:26 <dolio> It is the same type.
11:00:38 <Cale> Whenever you see A -> B -> C, it means A -> (B -> C)
11:00:46 <Cale> those are notations for the same type
11:00:57 <jakob1> thank you
11:01:01 <Cale> Similarly whenever you see  f x y  it means  (f x) y
11:01:26 <nitrix> The former is currying and the latter is function application, which has the highest precedence.
11:01:38 <Cale> nitrix: That's not currying
11:01:38 <nitrix> I'm not foreign to the concepts, I think I'm just getting the point accross wrong.
11:01:55 <Cale> Currying is the process of turning a function of type (A, B) -> C into a function of type A -> (B -> C)
11:01:56 <mnoonan> no, currying is this: (a,b) -> c  ~  a -> b -> c
11:02:42 <Cale> You will tend to hear things like "functions in Haskell are curried", because people usually expect functions of multiple parameters to take a tuple as an argument
11:03:01 <Cale> and so they imagine that this process of currying has already been done
11:03:06 <dgpratt> @type curry
11:03:07 <lambdabot> ((a, b) -> c) -> a -> b -> c
11:03:12 <hpc> or to be more precise, they won't know the difference and just assume you have to pass all the parameters at once
11:03:13 <Cale> But really, the uncurried function usually never got written
11:03:49 <nitrix> Cale: So, the associativity of (->) is enough to emulate it?
11:04:40 <Cale> I mean, when you write A -> B -> C, the compiler parses that as A -> (B -> C), there's no separation of any kind between the two
11:04:51 <Cale> apart from at the concrete syntax level
11:05:06 <Cale> (that you happened to write some extra parens in one case)
11:05:18 <Cooler> @src when
11:05:19 <lambdabot> when p s = if p then s else return ()
11:05:29 <Cooler> what does the () in return () mean?
11:05:34 <Cooler> is it a empty tuple?
11:05:34 <Cale> It's an empty tuple
11:05:34 <dgpratt> @type ()
11:05:35 <lambdabot> ()
11:05:37 <Cooler> ok
11:05:40 <nitrix> Cale: My point is, doesn't having the parenthese explicitly prevent whatever magical currying you're talking about?
11:06:01 <Cooler> Cale, so why do you need a empty tuple?
11:06:02 <Cale> nitrix: hm?
11:06:24 <nitrix> fmap' :: (a -> b) -> (f a -> f b)
11:06:32 <Cale> nitrix: The currying I'm talking about is where we write functions with types like  map' :: (a -> b, [a]) -> [b]
11:06:37 <nitrix> Will (+1) `fmap'` Just 5  type check?
11:06:44 <Cale> nitrix: and then curry that to get  map :: (a -> b) -> [a] -> [b]
11:07:02 <Cale> nitrix: Apart from the fact that you left out a Functor constraint
11:07:16 <Cale> well, even so, yes, that'll typecheck
11:07:18 <dgpratt> Cooler, it's like those plastic inserts in the refrigerator door on the opposite side of the hinge
11:07:41 <nitrix> Cale: How come? fmap' arity is 1.
11:07:41 <shachaf> nitrix: What you should do is forget about type classes, which are too complicated and beside the point, and just think about regular functions.
11:07:41 <Cale> (Functor f) => (a -> b) -> (f a -> f b)
11:07:42 <Cale> and
11:07:47 <shachaf> Like (+) :: Int -> Int -> Int
11:07:52 <Cale> (Functor f) => (a -> b) -> f a -> f b
11:07:53 <dgpratt> you have a type/value hole, but you don't actually need it in a particular case
11:07:55 <Cale> are the *same*
11:08:00 <Cale> they're not just isomorphic
11:08:02 <dgpratt> so () fills the hole
11:08:03 <Cale> they are the same type
11:08:12 <Cale> They're notation for the very same thing
11:08:13 <nitrix> Cale: How come? The arity seems completly different to me.
11:08:20 <Cale> There is no notion of function arity in Haskell
11:08:27 <Cale> All functions take exactly one argument
11:08:32 <Cale> Always
11:08:44 <Cale> Those which appear to take more are just producing other functions
11:09:04 <meToo_> Coming from an OO world (everybody has to start somewhere!), I would appreciate a few hints/tips on how one would implement an equivalent, in Haskell, of something very basic, like an invoice recording system where in the OO world, you wouldn't be shocked to find packages/modules for a domain-model (quite anaemic Invoice, InvoiceLine, Customer classes a few "value-objects"), a service layer...
11:09:05 <meToo_> ...(to expose, effectively, CRUD on the domain, encapsulating some cross-domain-object business logic, and also often defining tx boundaries) and DAO/repository layer to encapsulate RDBMS access (and, I'm afraid, ORM functionality).
11:09:08 <meToo_> It seems like such an architecture is not in the spirit of FP, and, neither is such a domain-model, and probably nothing else about it either!
11:09:10 <Cooler> Cale, so why do you need a empty tuple?
11:09:16 <nitrix> @let fmap' = fmap :: Functor f => (a -> b) -> (f a -> f b)
11:09:17 <lambdabot>  Defined.
11:09:24 <Cale> Cooler: We use it as a value whenever we don't have anything interesting to producer
11:09:27 <Cale> produce*
11:09:28 <nitrix> > (+1) `fmap'` Just 5
11:09:29 <lambdabot>  Just 6
11:09:33 <nitrix> What the.
11:09:46 <Cooler> Cale why not a [] then?
11:10:14 <hpc> () is the only inhabitant of the type ()
11:10:19 <hpc> [] is not the only inhabitant of its type
11:10:21 <Cooler> would return [] work just as well?
11:10:27 <Cale> Cooler: Because that would mean that s would be returning a list of some sort
11:10:30 <nitrix> Cale: It seems to me what I just did just happens to magically work because Haskell function application is left to right.
11:10:37 <Cooler> doesn
11:10:45 <Cale> Cooler: In this case, we just insist that s doesn't produce any kind of interesting result
11:10:49 <Cooler> doesn't return () mean its returning a tuple of some sort?
11:11:01 <Cale> Cooler: It means that s also must produce an empty tuple
11:11:05 <hpc> specifically, using [] as the empty result would mean you might also use [1, 2, 3, 4, 5], [True, False], or "BZORP"
11:11:10 <nitrix> Cooler: return doesn't actually return things.
11:11:23 <nitrix> Cooler: It's not an operator that changes control-flow.
11:11:25 <Cale> Well, return v actually returns v when you run it
11:11:34 <hpc> also () is not a tuple, though it looks like one
11:11:42 <Cale> But yeah, return v doesn't have the control flow properties that return has in other languages
11:11:52 <Cale> It's just an action which does nothing except to return v
11:12:00 <simpson> nitrix: Here's a puzzler: What's the arity of the common function `id`? How about `id fmap`?
11:12:03 <Cale> Which means if it's in the middle of a do-block, it's basically a no-op
11:12:07 <Cooler> i am aware, we had a long discussion of what it actually does a few minutes ago
11:12:07 <hpc> you could call it the 0-tuple, but then what's the 1-tuple?
11:12:11 <hpc> it'd probably be Identity, but who cares
11:12:18 <Cale> hpc: There's no 1-tuple type
11:12:28 <hpc> it's not interesting to think about anyway
11:12:28 <nitrix> simpson: Going with Cale's definition, it doesn't have an arity.
11:12:29 <Cooler> so () isn't a empty tuple?
11:12:41 <Cale> It's okay to refer to () as an empty tuple I think
11:12:41 <hpc> and there's no real common property it has with 2+ tuples that you would ever care about
11:12:55 <hpc> () is Unit
11:12:57 <Cale> I mean, the notation was clearly chosen to suggest that
11:13:05 <Cale> You can also call it the unit type
11:13:09 <Cooler> why is it you can't use return [] if you can use return ()?
11:13:13 <Cale> It's the type with a single defined element
11:13:28 <Cale> (it's not actually a unit for (,) but close enough)
11:13:32 <hpc> Cooler: you can, it just means something different
11:13:35 <hpc> :t return ()
11:13:36 <lambdabot> Monad m => m ()
11:13:38 <hpc> :t return []
11:13:39 <lambdabot> Monad m => m [t]
11:13:47 <Cooler> huh
11:13:48 <simpson> nitrix: You have an implicit assumption that it's not possible to apply more arguments to a function than its arity, but in Haskell, functions all have an arity of "one more argument". (Roughly.)
11:13:49 <Cale> Cooler: Consider what the type of the other branch of the 'if' has to be
11:13:55 <Cooler> :t return []
11:13:56 <hpc> :t return [undefined]
11:13:58 <lambdabot> Monad m => m [t]
11:13:58 <lambdabot> Monad m => m [t]
11:14:02 <hpc> note those have the same type
11:14:14 <hpc> but one is clearly "wrong"
11:14:28 <Cale> @let whenList b s = if b then s else return []
11:14:29 <lambdabot>  Defined.
11:14:32 <Cale> :t whenList
11:14:33 <lambdabot> Monad m => Bool -> m [t] -> m [t]
11:14:34 <Luke> anyone know how to write a 3 bytes to a ByteString.Builder? We have the value in a Word32
11:14:45 <Cale> :t whenList (2 == 3) getLine
11:14:46 <lambdabot> IO [Char]
11:14:54 <Cooler> Cale, but if you use return () doesn't the other branch of the if have to return a tuple too?>
11:14:55 <hpc> :t \p -> (guard p >>)
11:14:56 <lambdabot> (Monad m, Alternative m) => Bool -> m b -> m b
11:14:59 <Cale> Cooler: yes.
11:15:03 <Cale> Cooler: an empty one
11:15:03 <nitrix> simpson: I've heard of the saying that they all have a single argument and evaluates to a single value (since functions are also first-class citizens)
11:15:18 <nitrix> simpson: But the "one more argument" is a first. I'm confused.
11:15:18 <Cale> Cooler: You can only use 'when' in the case that the action you provide has no interesting result
11:15:34 <Cale> @let whenMaybe b s = if b then s else return Nothing
11:15:36 <lambdabot>  Defined.
11:15:40 <Cale> :t whenMaybe
11:15:40 <meToo_> ... is there any reason why one wouldn't use haskell for such a system (which is almost pure CRUD, and not a lot of logic)?
11:15:41 <lambdabot> Monad m => Bool -> m (Maybe a) -> m (Maybe a)
11:15:56 <Cale> of course, we might actually want something a little different there...
11:15:58 <Cale> @undefine
11:15:58 <lambdabot> Undefined.
11:16:06 <Cale> @let whenMaybe b s = if b then fmap Just s else return Nothing
11:16:07 <lambdabot>  Defined.
11:16:10 <Cale> :t whenMaybe
11:16:11 <simpson> nitrix: I mean that when you have a Haskell function, it can take a single argument and return a single value. Sometimes that returned value is another function, sometimes not. Anything more complex (over-application, supercombining, etc.) is generally an implementation problem, not a problem for users.
11:16:12 <lambdabot> Monad f => Bool -> f a -> f (Maybe a)
11:16:24 <Cale> ^^ this is perhaps the more natural thing to write
11:16:48 <Cale> Cooler: There are a lot of variations on these control structures we might choose to write
11:16:53 <hpc> Cale: not nearly haskelly enough - call it "perhaps" ;)
11:16:59 <Cale> Cooler: when is just a handy point in the design space
11:17:22 <Cale> hpc: haha, I like that
11:17:23 <shachaf> Cale: Why not Maybe (f a) -> f (Maybe a)?
11:17:37 <Cale> shachaf: Yeah, well, that already exists
11:18:03 <nitrix> Cale: simpson: I think we got side tracked, but all in all, good to know I had a misconception. I'll be more careful around it in the future.
11:18:04 <Cale> (it's the sequence for Maybe's Traversable instance)
11:18:37 <Cale> nitrix: Yeah, sorry, is there anything still worrying you about that?
11:18:56 <Luke> anyone know how to write a 3 bytes to a ByteString.Builder? We have the value in a Word32
11:19:02 <Cooler> Cale, when you implement when
11:19:17 <Cooler> why can you implement it so the other side of the if has to return a tuple?
11:19:27 <Cale> why?
11:19:38 <Cale> I mean, the two branches of an if-expression must always have the same type
11:19:57 <Cale> Whatever type the 'else' part has, so must the 'then' part, and vice-versa
11:20:27 <nitrix> Cale: simpson: If the fmap' function was flipped, now it'd be an issue, right?
11:20:31 <Cale> Cooler: So if the 'else' part is  return () :: m ()
11:20:33 <maerwald> unless we add duck-typing to haskel :D
11:20:42 <Cale> Cooler: then the 'then' part must also have type  m ()
11:20:44 <nitrix> Cale: Or maybe not.
11:20:52 <simpson> nitrix: No worries; technical communication is hard. It's good that we can continue to communicate and work out differences.
11:21:14 <nitrix> @let flippedFmap' = flip fmap'
11:21:14 <Cale> nitrix: Well, it makes some difference what order the arguments come in.
11:21:15 <lambdabot>  .L.hs:145:21:
11:21:15 <lambdabot>      Not in scope: â€˜fmap'â€™
11:21:15 <lambdabot>      Perhaps you meant â€˜fmapâ€™ (imported from Control.Monad.Writer)
11:21:24 <nitrix> Where did my fmap' go !
11:21:28 <Cale> nitrix: A -> B -> C and B -> A -> C are different types for sure
11:21:44 <Cale> I did an @undefine a moment ago, sorry
11:21:53 <nitrix> @let fmap' = fmap :: Functor f => (a -> b) -> (f a -> f b)
11:21:54 <lambdabot>  Defined.
11:21:58 <shachaf> fmap' is literally the same thing as fmap.
11:22:00 <nitrix> @let flippedFmap' = flip fmap'
11:22:01 <lambdabot>  Defined.
11:22:04 <Cale> :t fmap'
11:22:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:22:19 <nitrix> :t flippedFmap'
11:22:20 <lambdabot> Functor f => f a -> (a -> b) -> f b
11:22:20 <Cale> ^^ the compiler doesn't like to write the extraneous parens
11:22:37 <nitrix> Even the flipped fmap...
11:22:42 <nitrix> Alright, point taken then.
11:22:43 <Cale> :t flippedFmap' :: Functor f => f a -> ((a -> b) -> f b)
11:22:45 <lambdabot> Functor f => f a -> (a -> b) -> f b
11:22:51 <Cale> It's literally the same thing
11:22:59 <nitrix> Yeah! That's exactly what I wanted to see.
11:23:04 <nitrix> Very cool.
11:23:15 <meToo_> looking at the brilliant technical discussion about the language idioms/programming details, maybe my question is a bit high-level (design/architecture for this room)... is there another forum my question would be better suited to, but still with a purely haskell flavour? 
11:23:21 <nitrix> TIL.
11:23:22 <Cale> nitrix: To show why arity is fun...
11:23:28 <Cale> :t id
11:23:29 <lambdabot> a -> a
11:23:31 <Cale> :t id id
11:23:32 <lambdabot> a -> a
11:23:34 <Cale> :t id id id
11:23:35 <lambdabot> a -> a
11:23:36 <Cale> :t id id id id
11:23:37 <lambdabot> a -> a
11:23:44 <Cale> How many arguments does id take?
11:24:15 <nitrix> Cale: Always one, returns one.
11:24:19 <Cale> yep
11:24:44 <nitrix> Id makes sense though. It not as illustrative as the fmap' for me.
11:24:56 <hpc> how many arguments does ($) take?
11:24:57 <hpc> :t ($)
11:24:59 <lambdabot> (a -> b) -> a -> b
11:25:04 <Cale> > foldr (\x xs n -> if n < 10 then xs (x + n) else xs n) id [1..20] 0
11:25:06 <lambdabot>  10
11:25:07 <nitrix> A single argument, returns one as well.
11:25:11 <hpc> nitrix: :D
11:25:32 <simpson> meToo_: Hi. To put it simply, most of the stuff that's built up in the object-oriented paradigm worldview is very specific to object-oriented paradigms; it's not really a facet of any language.
11:25:37 <Cale> You can use foldr to produce a function like that
11:25:43 <Cale> and get "stateful folds"
11:26:13 <nitrix> Oh I've done that before :)
11:26:24 <meToo_> @simpson: yes, but it is hard to find examples of tried and tested idioms/architectures for this kind of app in haskell.
11:26:25 <lambdabot> Unknown command, try @list
11:26:34 <Cale> and yeah, it breaks the idea that foldr has a definite arity
11:26:57 <Cale> (apart from just saying 1)
11:27:19 <nitrix> Cale: foldl can't right?
11:27:23 <Cale> Now, the compiler... the compiler figures out arities for functions in order to compile more efficient things
11:27:24 <nitrix> If I understand what you mean properly.
11:27:29 <Cale> foldl can too
11:27:31 <Cale> :t foldl
11:27:32 <nitrix> Oh?
11:27:33 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
11:27:38 <Cale> ^^ it produces a result of type b
11:27:49 <Cale> (ignoring the Foldable polymorphism)
11:27:55 <Cale> b could be a function type
11:28:11 <nitrix> Mkay.
11:28:37 <Cale> > foldl (\f x n -> if x > 10 then f (x + n) else f n) id [1..20] 0
11:28:39 <lambdabot>  155
11:28:49 <Cale> > foldl (\f x n -> if n > 10 then f (x + n) else f n) id [1..20] 0
11:28:51 <lambdabot>  0
11:29:15 <dmj`> that foldable polymorphism :) 
11:29:30 <dmj`> :t length
11:29:30 <nitrix> o:
11:29:31 <lambdabot> Foldable t => t a -> Int
11:30:05 <Cale> > length (1,2)
11:30:06 <lambdabot>  1
11:30:15 <Cooler> got dced
11:30:23 <meToo_> simpson: do people build such "business apps" with quite simple, usually CRUD functionality, in haskell? Would you have records for the domain objects, possibly grouping some common "fields" like id and timestamp (for optimistic locking) in a data? My questions really at that sort of level. Would you have such a 3 tier split as I outlined on a greenfield haskell impl of something like this? 
11:30:36 <Cale> (the length of a pair is 1, because that's the number of elements which fmap will affect)
11:30:40 <EvanR> meToo_: i would say that a record of IO stuff is an idiomatic way to present an oop-like interface to some resource
11:30:49 <Cooler> Cale, so why can't you implement when p s = if p then s else return [] ?
11:31:13 <EvanR> meToo_: oh, "ORM" style stuff... i want to believe that is not idiomatic ;)
11:31:17 <dmj`> Cooler: when doesn't terminate like that
11:31:20 <Cooler> whats so special about () compared to []?
11:31:26 <hpc> :t ()
11:31:27 <lambdabot> ()
11:31:31 <hpc> :t []
11:31:33 <lambdabot> [t]
11:31:44 <Cooler> where did it get that t from?
11:31:46 <hpc> :t \when p s = if p then s else return []
11:31:47 <lambdabot> parse error on input â€˜=â€™
11:31:51 <Cale> meToo_: I work for a company called Obsidian Systems and we build business web applications in Haskell (using Haskell both for the backend web server, and for the frontend which is compiled using GHCJS to Javascript)
11:31:54 <simpson> meToo_: There are object-*based* languages, and many object-oriented concepts were discovered in them, but there are things in Haskell like http://hackage.haskell.org/package/objective which are definitely "objects, but not as we know them."
11:31:56 <hpc> Cooler: [] is the empty list
11:32:02 <hpc> Cooler: meaning it is of type "list of things"
11:32:06 <meToo_> EvanR: ;) OK, but there is no requirement to stay married to any of the design I outlined. The goal is to learn how to achieve the same result (the working app) staring from scratch in haskell.
11:32:06 <Cooler> why isn't :t [] == []?
11:32:07 <hpc> and t is that thing it's a list of
11:32:09 <Cale> meToo_: We share a common schema of data types between the frontend and backend
11:32:24 <hpc> :t [1,2,3]
11:32:25 <lambdabot> Num t => [t]
11:32:29 <hpc> that's a list too
11:32:32 <hpc> of things
11:32:43 <EvanR> meToo_: youre basically asking for "Enterprise Haskell Integration" ;)
11:32:43 <Cooler> :t [] == []
11:32:44 <geekosaur> an empty list does not have a different type from lists with contents
11:32:45 <lambdabot> Bool
11:32:48 <hpc> with a constraint that t is a numeric thing
11:32:53 <EvanR> let me give you my business card
11:32:56 <Cooler> (:t []) == []
11:32:57 <meToo_> Calle: that sounds interesting
11:33:05 <hpc> Cooler: ":t" is a lambdabot command
11:33:10 <hpc> that means "what is the type of this"
11:33:11 <Cale> meToo_: These both get reflected directly in our database (using groundhog... though I'm not sure I can really recommend it, it does the job), and get translated to and from JSON (using Aeson) for communication over a websocket
11:33:13 <hpc> :t False
11:33:14 <lambdabot> Bool
11:33:15 <simpson> meToo_: Wow, IRC lag. Anyway, you probably want to look at the stacks that are used to build big enterprisy Haskell apps, as those are the patterns that you'll want to emulate.
11:33:25 <meToo_> Calle: there was a system called Obsidian in the 90s on the AS/400
11:33:55 <Cale> https://obsidian.systems/
11:34:05 <meToo_> simpson: EvanR: yes, enterprisey systems.
11:34:20 <EvanR> Cale: you have internalized websocket technology? how does this fair on the mobile platform ?
11:34:57 <Cooler> so whats wrong with when p s = if p then s else return [] ?
11:34:59 <hpc> Cooler: so,
11:35:08 <hpc> :t let when p s = if p then s else return [] in when
11:35:09 <lambdabot> Monad m => Bool -> m [t] -> m [t]
11:35:32 <meToo_> Calle: thanks, it's not the same one ;)
11:35:36 <Cooler> where did it get that t from?
11:35:36 <mnoonan> Cooler: the then and else clauses need to be expressions with the same type
11:35:47 <hpc> Cooler: lists have to be lists of something
11:35:48 <geekosaur> Cooler, data [] t = [] | (t : [] t)
11:35:59 <Cooler> but a empty list is just empty
11:36:03 <geekosaur> no
11:36:05 <Cale> EvanR: I haven't personally been involved in much related to the mobile stuff... but I think it works?
11:36:12 <geekosaur> because you can't append a value to a tuple
11:36:12 <hpc> an empty list has no values
11:36:24 <geekosaur> you can prepend a value to a list
11:36:28 <hpc> but its type is "list of something"
11:36:39 <Cale> EvanR: I'll be getting into that side of things soon enough with the project I'm on now.
11:36:42 <geekosaur> [] is not a distinct type from other lists
11:36:56 <hpc> otherwise you would never be able to use [] and [1, 2, 3] at the same time
11:36:56 <Cale> EvanR: I haven't heard of anything special being required.
11:36:59 <simpson> EvanR: Works as fine as WS on other platforms, which is to say that it's janky compared to long-polling but does more or less what it says on the tin. Dunno about Haskell-specific bits, as WS is almost totally orthogonal to Haskell.
11:37:00 <meToo_> Cale: just for fun https://en.wikipedia.org/wiki/Synon
11:37:01 <Cooler> yes but you haven't actually specified a type anywhere, all you have said is return [], so where is it getting that type from?
11:37:15 <geekosaur> because a type is required
11:37:22 <geekosaur> :k []
11:37:23 <lambdabot> * -> *
11:37:23 <Cooler> required where?
11:37:32 <geekosaur> please look up
11:37:37 <hpc> Cooler: the type was always there
11:37:42 <geekosaur> I just asked the bot to tell me the kind of a list constructor
11:37:49 <geekosaur> (a kind is the "type" of a type)
11:38:04 <geekosaur> the point of that is that the [] type constructir requires another type
11:38:04 <xa0> Cooler: what have you been using to learn haskell/functional programming? i feel like you've got a fundamental misunderstanding of a lot of concepts, you might want to retry with a different perspective
11:38:04 <hpc> specifically, the type of [] is [t] simply from how it's defined as a constructor of the list type
11:38:07 <geekosaur> always
11:38:37 <hpc> it never gets unified with anything else of importance, so there's no type equations to make it more specific
11:38:40 <hpc> and it remains t
11:38:40 <Cooler> so in that new implementation of when
11:38:49 <geekosaur> so if you use the *value* [], its type must be [some_type_here] (or ([] some_type_here) equivalently)
11:38:52 <Cooler> would you have to specify it in s?
11:39:03 <geekosaur> thus `return []` must have type [t] for some unknown t
11:39:04 <Cooler> specify the type that is
11:39:36 <geekosaur> in the new "when" based on [], the `then` leg must have a type which lets it resolve the unknown type t
11:39:51 <Cooler> in when p s = if p then s else return [], would you be forced to specify the type in s?
11:39:56 <geekosaur> because [10 19:34] <lambdabot> Monad m => Bool -> m [t] -> m [t]
11:40:06 <hpc> s can make the type more specific, yes
11:40:15 <geekosaur> and the "then" part is the only way you have to control that type
11:40:30 <hpc> but the larger problem is that you've defined a when that can yield results
11:40:34 <hpc> plural results, even!
11:40:35 <meToo_> Cale: GHCJS is another of the reasons I would like to try out something like this in Haskell. Sharing some data types, even validation logic and seamless browser-server communication seems quite compelling. But I just wouldn't know where to start modelling the domain in Haskell.
11:40:51 <hpc> and that's a far cry from the current definition of when
11:41:08 <Cooler> uh s isn't supposed to return anything?
11:41:08 <hpc> the current definition uses the type (), which has only the value ()
11:41:30 <hpc> so when you see the type (), it means "the value for this type doesn't matter"
11:41:49 <hpc> when you see [t] (for whatever t), that type says "the value for this type is zero or more ts"
11:41:52 <hpc> :t when
11:41:53 <lambdabot> Applicative f => Bool -> f () -> f ()
11:42:25 <hpc> so that type says there's no information in the () parts, so all the programmer should pay attention to is the f part
11:42:35 <Cooler> wait so s isn't supposed to return anything?
11:42:37 <hpc> because that's what when is acting on
11:42:51 <adarqui> hey, when using optparse-applicative.. i have some Text arguments instead of String. so, argument str (blah) fails to compile.. if I use argument auto (blah) it compiles but then it can't actually parse it. It relies on ReadM for Text.. any idea on how I can use Text instead of String?
11:43:00 <hpc> s returns ()
11:43:02 <hpc> :t return ()
11:43:03 <lambdabot> Monad m => m ()
11:43:07 <hpc> which is basically returning nothing
11:43:17 <hpc> because you don't get any information out of it
11:43:18 <hpc> so yes
11:43:34 <Cooler> yeah so that mean you would only use when if s has side effects? otherwise this doesn't make sense
11:43:41 <geekosaur> yes
11:43:52 <hpc> you would use 'when' if s consists of ONLY side effects
11:43:58 <Cooler> oh ok
11:44:06 <hpc> :t when False (putStrLn "bacon")
11:44:06 <geekosaur> the convention is that an IO action that only has side effects (putStrLn, print, writeIORef, etc.) produces IO ()
11:44:07 <lambdabot> IO ()
11:44:11 <hpc> :t when False readLine
11:44:12 <lambdabot>     Not in scope: â€˜readLineâ€™
11:44:13 <adarqui> i wish i could compose it with Text.unpack tho or something
11:44:13 <lambdabot>     Perhaps you meant one of these:
11:44:13 <lambdabot>       â€˜readFileâ€™ (imported from Prelude),
11:44:27 <geekosaur> :t when False readLn
11:44:28 <lambdabot> IO ()
11:44:38 <geekosaur> hm...
11:44:41 <hpc> :t when False getLine -- what i was going for
11:44:42 <lambdabot>     Couldn't match type â€˜[Char]â€™ with â€˜()â€™
11:44:43 <lambdabot>     Expected type: IO ()
11:44:43 <lambdabot>       Actual type: IO String
11:44:50 <geekosaur> oh, because () is an instance of Read
11:44:56 <hpc> :P
11:44:57 <geekosaur> derp
11:45:48 <nitrix> > let x = () in show . read $ x
11:45:50 <lambdabot>      Couldn't match type â€˜()â€™ with â€˜[Char]â€™
11:45:50 <lambdabot>      Expected type: String
11:45:50 <lambdabot>        Actual type: ()
11:46:00 <nitrix> > let x = () in read . show $ x
11:46:02 <lambdabot>  ()
11:46:04 <nitrix> Woo! :D
11:53:37 <parsecChar> is there a haskell bulitn for "head, but if empty, return this default value" ?
11:53:52 <Clint> :t safeHead
11:53:53 <lambdabot> Not in scope: â€˜safeHeadâ€™
11:54:51 <dolio> fromMaybe x . listToMaybe
11:54:52 <parsecChar> hmm, I can't find it in hoogle either
11:54:54 <mmachenry> :t fromMaybe
11:54:55 <lambdabot> a -> Maybe a -> a
11:56:13 <parsecChar> hmm, should I define safehead as :: [a] -> a -> a
11:56:17 <parsecChar> or a -> [a] -> a  ?
11:56:52 <shachaf> Take inspiration from fromMaybe.
11:56:54 <mnoonan> a -> [a] -> a is more consistent with maybe
11:56:54 <shachaf> :t fromMaybe
11:56:55 <adarqui> figured out the optparse-applicative text argument question.. just for reference:
11:56:55 <lambdabot> a -> Maybe a -> a
11:56:58 <adarqui> text :: ReadM Text
11:57:00 <adarqui> text = ReadM (asks T.pack)
11:57:17 <parsecChar> shachaf , moonan: makes sense
11:57:39 <roberth> > maybe 0 (* 2) $ listToMaybe [10]
11:57:40 <lambdabot>  20
11:58:34 <roberth> > fromMaybe 0 $ listToMaybe [10]
11:58:36 <lambdabot>  10
11:59:13 <nkaretnikov> sclv: hi, any plans to make the recent compose conf talks publicly available?
11:59:30 <Athas> Is there a list of papers written about Accelerate somewhere?
11:59:57 <dolio> nkaretnikov: The keynote's up. I think the others are coming.
12:00:25 <nkaretnikov> dolio: cool!
12:02:55 <sclv> nkaretnikov: we're going to get them up as processed, roughly 1/week?
12:03:47 <meToo_> ... perhaps https://wiki.haskell.org/Enterprise_Haskell   is an interesting place to start.
12:04:46 <nkaretnikov> sclv: great to hear, thanks! :)
12:05:37 <Pennyw95> Hmm...is there a good book for learning haskell that you would advice me? I'm almost finished with "Learn you a Haskell for great good" and I'd love to have some more examples / exercises of anything really
12:05:59 <meToo_> it seems that being so used to "modeling the domain" in an OO mindset might be an obstacle to solving the same class of problems in idiomatic FP.
12:07:39 <geekosaur> LYAH is a good tour of Haskell bnut not a good way to learn Haskell
12:07:43 <geekosaur> @where rwh
12:07:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:07:53 <geekosaur> a little out of date but free
12:07:58 <geekosaur> @where haskellbook
12:07:58 <lambdabot> http://haskellbook.com
12:08:14 <geekosaur> still in development, some Haskellers do not like it, not free
12:09:09 <meToo_> Penntw95: Functional Thinking in Haskell is quite engrossing
12:09:58 <Pennyw95> indeed :)
12:10:09 <Pennyw95> Thank you geekosaur
12:10:33 <geekosaur> I am not a good judge of these things myself
12:10:52 <geekosaur> there's also various resources in
12:10:56 <geekosaur> @where learnhaskell
12:10:56 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:11:47 <Cale> meToo_: Let me give you a link to an excellent talk about an approach to functional programming design. The approach isn't always easy to apply, but when it works, it tends to work extremely well.
12:12:23 <meToo_> Cale: That would be great. 
12:12:33 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
12:13:16 <meToo_> is that about the Naval system they prototyped in various languages in the 90s?
12:13:21 <Cale> no
12:13:55 <Cale> The example used is financial contracts
12:14:00 <Cale> also, puddings :)
12:14:00 <meToo_> I will watch that SPJ is always fun to listen too
12:14:23 <Cale> meToo_: The basic idea is to design a language for expressing the problems surrounding the one(s) you actually want to solve
12:15:27 <meToo_> Cale: Yes, Debashish Ghosh writes about that sort of thing too (but he moved from haskell to Scala a few years ago)
12:15:30 <Cale> in a compositional way, such that the solutions to the problems can be constructed recursively from the description, by solving subproblems and manipulating the solutions to those to obtain the solution to the combined problem
12:16:36 <meToo_> cale: I wonder if that is the source of the apparent mismatch: in a fairly dumb CRUD app, there doesn't seem to be much to compose
12:16:38 <Cale> So, instead of solving one problem, you build a language in which the solution to the problem is easy to express, and you get something which is very resilient to many types of changes in specification that way
12:16:59 <meToo_> Cale: very nicely described, thank you.
12:17:03 <Cale> Well, there are components of that space which we can do quite a good job in
12:17:34 <Cale> We might not (yet) understand the space of all CRUD applications well enough to design an elegant combinator language for handling them all
12:18:52 <Cale> But for example, on the UI side of things, the library that the company I work for uses, called reflex, is used to compositionally handle things which are changing over time (especially in the frontend for the time being, though eventually we'd like to be able to use it on the backend as well)
12:20:32 <Cale> It's what's called a functional reactive programming system -- we have two basic types: for any type a, there is a type Behavior t a (ignore the t for now, it refers to the implementation mechanism to use) which represents something which is a value of type a whenever you care to look at it, but which may change arbitrarily often, and won't notify you of the changes
12:20:46 <meToo_> Cale:  sounds a bit like Elm and REDUX/ReactJS
12:21:14 <Cale> and secondly, there is a type Event t a which is something that occurs at many particular points in time, and has a value of type a at those time
12:21:14 <Cale> s
12:21:36 <Cale> (or possibly never occurs)
12:22:06 <meToo_> Cale: that stuff I actually find quite intuitive, and will use whether the domain is modelled FPly or not.. 
12:22:35 <Cale> so we have a lot of operations for combining events and behaviours to produce further events and behaviours
12:22:53 <obadz> Is the FGL graph implementation basically a data Graph k = Map k (Set k, Set k) ?
12:23:26 <Cale> and there's also a notion of a Dynamic t a which is a combination of an Event and a Behaviour which changes only when the event occurs, to the value of the event.
12:23:37 <Cale> (so it's like something which changes over time, but notifies you when)
12:23:42 <meToo_> Cale: so your events would also include things like "invoice-line added to invoice" and "persist invoice"
12:24:59 <Cale> Yeah, so things like the current position of the mouse, the current contents of a text field, or an entire subform, the current hitpoints of a monster, the current contents of the database -- basically the current whatever -- are modelled as behaviours
12:25:35 <Cale> While things like the sequence of mouse clicks or keystrokes, the sequence of button clicks or sequence of requests made to the backend, or responses coming back from it
12:25:51 <Cale> The sequence of attacks made by a monster, or the sequence of sound files to play
12:26:00 <Cale> Those are all examples of things which would be events
12:26:14 <parsecChar> is there a way, in haskell, to "escape" a Text ?
12:26:21 <meToo_> Cale: maybe I'm making too much of big deal about modelling the domain in an FP way. I am so used to drawing UML diagrams ;-) 
12:26:26 <Cale> and we can do things like  Event t XhrRequest -> m (Event t XhrResponse)
12:27:13 <Cale> So you construct an Event which expresses which XML HTTP requests to make to the backend, and put this widget in your page, and it gives you back an Event with the responses coming back asynchronously
12:27:47 <meToo_> Cale: that all sounds very neat, and very clear.
12:27:58 <Cale> and you can use *that* event to accumulate perhaps a Dynamic table of information from which you build the DOM
12:28:25 <Cale> and the display is updated automatically as responses come back, without you having to fiddle about making sure that things update in the correct order
12:28:42 <Cale> The library takes care of making sure that everything is consistent with your description of what it should be
12:29:31 <Cale> meToo_: We also do this with database table listeners, to send the user updates on their view of the relevant portions of the database automatically via a websocket
12:29:56 <meToo_> Cale: that sounds a bit like Meteor 
12:30:00 <Cale> meToo_: So there's a bunch of Dynamic Map datastructures which are passed around our application and used to build the UI
12:30:25 <meToo_> Cale: very nice and very modern design
12:30:27 <Cale> and changes on the database on the backend are automatically propagated through to the frontend via that websocket, and then *everything based on them* is updated live
12:30:45 <Cale> and we don't really even have to think about it once that mechanism is in place
12:31:32 <Cale> Though for our current work, we've started needing to design something a bit better to reflect exactly what the user is looking at so that the backend can do a better job of restricting the communication to just what's needed.
12:31:59 <meToo_> Cale: do you have notification with surgical precision in component trees or does the parent widget get told and then redraws all its children/
12:32:07 <Cale> Still, it's not too hard to get that kind of thing happening -- we can collect up a Dynamic Set of things that the user is interested in
12:32:24 <meToo_> Cale: actually that is the same problem as I just stated re the UI updates
12:32:39 <Cale> Well, for constructing the DOM, things are more precise
12:33:17 <Cale> But in our older applications, there's a lot of irrelevant communication, the client has access to more of the database than it really needs
12:33:29 <meToo_> Cale: right but some frameworks do a coarse update in the virtual-dom and trust the diffing to update just enough DOM
12:33:30 <Cale> (well, for those applications it wasn't such an issue)
12:34:36 <meToo_> Cale: if your domain consisted of monsters and players (and maybe monsters "are" players),  that were persisted so you can finish the game when you wake up the next day, would you model monsters and players with "data" and/or typeclasses or ....
12:34:39 <Cale> Yeah, I don't think we have any story with respect to the virtual DOM for the time being, though I've heard some people interested in working on that. We've open sourced a good portion of our library, and it's been getting a nice amount of interest.
12:34:44 <meToo_> Cale: that is where I seem to get stuck
12:35:01 <EvanR> you dont have to believe me but, when you recompute a nest of dom elements of a giant string of HTML, and replace a single parent with a single parent, it is fast
12:35:03 <Cale> So, yeah, that's always a tricky issue
12:35:21 <shachaf> If Applicative is a natural API for context-free languages, what would be the equivalent for regular languages?
12:35:24 <Cale> Oh, we don't ever construct an HTML strong
12:35:25 <Cale> string*
12:35:31 <EvanR> no one does
12:35:35 <Cale> The program manipulates the DOM directly.
12:35:35 <EvanR> they think its too slow
12:35:45 <Cale> Just because that's what's natural to do
12:35:46 <EvanR> because they are used to DOM manipulations being slow
12:35:52 <EvanR> because they are
12:36:11 <EvanR> most js frameworks iteratively traverse doms and insert children one by one
12:36:12 <meToo_> EvanR: it's not necessarily slow, some frameworks outperfom the likes of React without a virtual DOM
12:36:39 <Cale> A nice thing is that if you compile a reflex-dom program with GHC, the DOM gets managed entirely by native code.
12:36:50 <Cale> (You get a webkit application)
12:36:53 <EvanR> its actually really fast to recompute a huge element from a string and replace 1 in the dom
12:36:59 <dolio> shachaf: Is applicative context-free?
12:37:01 <EvanR> it just sounds too dumb to work
12:37:17 <EvanR> so its proof by performance assumption
12:37:41 <shachaf> dolio: That was my impression.
12:38:13 <mnoonan> shachaf: In what way? I can't quite see it..
12:38:28 <dolio> Or is the infinite grammars you can construct in Haskell/with codata what lets you do context free things?
12:38:42 <dolio> Are, even.
12:38:45 <Cale> EvanR: Well, it *does* make a huge difference in some cases.
12:38:56 <meToo_> EvanR: I will definitely play with https://github.com/reflex-frp/reflex ; thanks for the tip
12:38:57 <EvanR> when?
12:39:01 <shachaf> dolio: I thought the infinite grammars let you do context-sensitive things.
12:39:10 <dolio> Yes, they let you do that, too.
12:39:16 <meToo_> Cale: re https://github.com/reflex-frp/reflex  thanks 
12:39:29 <Cale> EvanR: I actually tried that method for SVG, and it worked to a point, but when my diagrams got complicated enough, the browser seemed to get pretty unhappy with my dumping thousands of new elements in all at once.
12:39:44 <EvanR> i was going to guess SVG or <video> or something
12:39:54 <EvanR> it makes sense that that would not work
12:40:01 <Cale> meToo_: https://github.com/reflex-frp/reflex-platform for a tutorial and a nice way to get things set up
12:40:13 <meToo_> Cale: perfect
12:40:29 <EvanR> SVG is kind of insanely represented as a dom element
12:40:32 <Cale> meToo_: Our documentation is still very much lacking
12:40:45 <meToo_> Cale: ... if only I knew how to make a Haskell domain model to feed changes to it from !!
12:40:51 <Cale> meToo_: but if you ask me questions, or just ask in #reflex-frp, there are lots of people who will help
12:41:10 <Cale> meToo_: well, yeah, I was going to say something about that
12:41:10 <meToo_> Cale: very good to know, cheers
12:41:25 <meToo_> Cale: ... I'm all ears
12:41:47 <Cale> meToo_: It's much easier to automatically serialise data which is represented as a simple algebraic way, i.e. not as objects
12:41:53 <dolio> shachaf: My question is, has someone characterized the correspondence between Applicative and context-free grammars in a setting without general recursion and such?
12:41:57 <milesrout> I want to implement a very simple functional programming language. is there a simple canonical syntax description for such a language. something like haskell but without all its extra advanced features
12:42:00 <milesrout> I know that this isnâ€™t #functional-programming-in-general, but you guys are usually the experts on this stuff.
12:42:18 <Cale> However, even in Haskell, there are certainly cases where you *want* data structures which look like objects -- i.e. they're records of functions
12:42:19 <dolio> Or is it just something people say?
12:42:19 <kadoban> milesrout: Have you looked at SICP?
12:42:32 <simpson> milesrout: How do you feel about Scheme?
12:42:33 <meToo_> Cale: OK, so what does monster look like? date Actor = Player | Monster
12:42:34 <milesrout> kadoban: I assume you mean s-expressions?
12:42:44 <kadoban> https://mitpress.mit.edu/sicp/full-text/book/book.html <-- that, but yes
12:42:49 <milesrout> yeah s-expressions could always work
12:42:52 <meToo_> *data
12:43:07 <EvanR> write yourself a scheme in 24 hours
12:43:09 <milesrout> although I personally prefer Haskell-style h = (f . g) etc.
12:43:19 <Cale> meToo_: right, so the "algebraic" or "traditional FP" approach would be to use something like that, where you'd give Player and Monster all the right fields, and maybe there are lots of different cases for each type of Monster
12:43:32 <shachaf> dolio: I don't know. I'd like an answer to that question also.
12:43:39 <Cale> meToo_: well, I mean, you'd have things like a field for the position and orientation and hitpoints and so on
12:43:44 <meToo_> Cale: well let's say they need id and timestamp
12:43:51 <EvanR> Cale: case records?
12:43:51 <milesrout> iâ€™ll try to work out a simple subset of Haskellâ€™s syntax I suppose
12:44:08 <milesrout> is haskell semi-derived from something simpler? Iâ€™ve heard of ML, does that have similar syntax?
12:44:10 <dolio> shachaf: The applicative/alternative things seem a lot like regular language combinators.
12:44:11 <Cale> meToo_: This approach makes it easy to write new functions which act on values of that type, just by case analysis
12:44:13 <Cale> "easy"
12:44:21 <Cale> But if you want to extend the available cases
12:44:27 <Cale> then all of those functions need to change
12:44:30 <shachaf> dolio: Yes.
12:44:40 <dolio> (<|>) is choice, empty is failure, pure is empty string, (<*>) is concatenation.
12:44:40 <shachaf> byorgey: Do you know?
12:44:45 <meToo_> Cale: sort of like th eexpression problem
12:44:46 <Cale> which kind of sucks for a type that's going to represent your various monsters, sometimes...
12:44:53 <Cale> Yes, this is exactly the expression problem
12:45:25 <dolio> You actually don't even have * without recursion or a special combinator.
12:45:25 <shachaf> dolio: And for parsing context-free languages people generally use recursion, I guess.
12:45:38 <Cale> So the other way to go is to have some record of functions which express how to do all the things you were planning to do with those various cases -- a single case
12:45:40 <meToo_> Cale: so ... why will nobody volunteer 5 lines of code for a Player and a Monster I can persist (id and timestamp and name)
12:45:45 <Wizek_> Has anyone seen an error close to this? https://gist.githubusercontent.com/Wizek/09f435b53dac0ad5db06/raw/gistfile1 
12:45:49 <Cale> a single case of which methods you have available
12:45:50 <EvanR> because all your monsters are "obviously all monsters" doesnt mean you should make them all the same type or the same class
12:45:54 <dolio> Although I guess many and some are in a class now?
12:45:55 <Cale> but many possible implementations of those methods
12:46:02 <Cale> that's sort of the "OO approach"
12:46:11 <david_koontz> milesrout: the simpler something is the typed lambda calculus
12:46:16 <meToo_> Cale: exactly
12:46:25 <david_koontz> milesrout: which is also what ML comes from, so there are lots of similarities
12:46:42 <dolio> shachaf: More importantly, they use corecursion.
12:46:45 <Cale> meToo_: but of course, if you stare at it, that's functional programming too -- we're sticking a bunch of functions in a data structure!
12:46:46 <meToo_> cale: but my goal is to explore how to do it in nice FP, but I don't know where to start
12:47:08 <meToo_> Cale: "in" sounds very OO
12:47:10 <EvanR> the OOP way doesnt even work in OOP, for games
12:47:15 <EvanR> in my experience
12:47:18 <__monty__> milesrout: ML's syntax isn't really simpler, as david_koontz implies.
12:47:27 <Cale> Well, it should be able to work in principle.
12:47:38 <EvanR> it quickly devolves into adhoc exceptions for everything
12:47:43 <Wizek_> I am working with yesod, if that matters
12:47:46 <EvanR> because your framework you made isnt actually fitting
12:48:02 <Cale> Yeah, you have to be careful about exactly what the methods are
12:48:03 <meToo_> EvanR: I am not defending OO (although I happily would). I am just saying I kno wexactly what to do in OO, it is secoond nature for me after 20 years of doing it. But I wouldn't know where to start in FP
12:48:03 <__monty__> milesrout: I'd just start working on a Haskell clone and not worry about most of the syntactical details.
12:48:08 <Wizek_> And trying to add a new model + field with derivePersistField
12:48:10 <Cale> But you can do some very compositional things with it
12:48:23 <milesrout> __monty__: I already have the semantic core pretty much worked out
12:48:52 <milesrout> I left the syntax for last because itâ€™s the least important thing :)
12:49:09 <EvanR> Cale: i think it harms compositionality, and performance, and sanity because in the end its not really the principles that matter its that the graphics appear on the screen in the right way
12:49:22 <EvanR> so you do what needs to be done to fudge it
12:49:28 <__monty__> milesrout: Then what exactly are you looking for?
12:49:31 <Cale> Instead of subclasses here, you just have functions which are building records of methods differently, and if you do it right, you can write functions which take objects of this type and combine them in various ways
12:49:43 <Cale> So you start getting back to a combinator-style approach
12:49:52 <meToo_> Cale: now we're getting somewhere!
12:49:54 <Cale> With objects at the bottom
12:50:13 <milesrout> __monty__: well I had a look at Haskellâ€™s grammar, but itâ€™s written in a pertty complicated way because it probably supports a hundred different types of integer literal and lots of syntax for typeclasses and this and that and the other thing. 
12:50:17 <hpc> EvanR: from my webdev experience, composability is even more important in graphical work
12:50:20 <EvanR> well you get back to everything being IO (), which is very composable
12:50:36 <Cale> Another thing worth mentioning is that you can abstract everything over a choice of monad
12:50:43 <meToo_> so even the "fields" and which objects have which fields, and their values, are dynamically determined by functions
12:50:45 <EvanR> hpc: which doesnt help you in an opengl clusterfuck
12:50:52 <dolio> shachaf: So, the uses of recursion that are so obvious that they get packaged up into the class are still regular constructions.
12:50:55 <Cale> So instead of  data Object = Ob { method1 :: ... -> IO (), ... }
12:50:57 <Cale> you have
12:50:58 <milesrout> I was wondering if anyone had written up a nice formal grammar for the simple subset of Haskell that people probably want when playing around with FP language design
12:51:00 <Wizek_> A longer version of the error when I `stack build`: https://gist.githubusercontent.com/Wizek/09f435b53dac0ad5db06/raw/gistfile2.txt
12:51:05 <Cale> So instead of  data Object m = Ob { method1 :: ... -> m (), ... }
12:51:07 <dolio> I'm not sure what you'd need for context free parsing.
12:51:08 <milesrout> simple subset of haskellâ€™s grammar, that is
12:51:09 <Cale> er, lol
12:51:12 <Cale> I just edited the line
12:51:24 <Cale> you have  data Object m = Ob { method1 :: ... -> m (), ... }  instead
12:51:31 <EvanR> meToo_: you should try this method in haskell and see for yourself what happens, and then hopefully it helps to see where OOP languages go off the rails
12:51:54 <milesrout> Cale: so instead of X, you have X instead.
12:52:02 <Cale> milesrout: heh
12:52:08 <Cale> milesrout: ignore my half-edited version
12:52:15 <shachaf> dolio: You mean some and many?
12:52:22 <Cale> milesrout: We've abstracted IO out, and turned it into a variable m
12:52:31 <dolio> Yes. Those are Kleene star.
12:52:51 <shachaf> Yes.
12:53:17 <EvanR> small scale OOP works nicely, but when "everything is an object" it will explode
12:53:18 <meToo_> EvanR: I think this might well be enough to get me started. Thanks you. Cale: I will go over your whole architecture tutorial you've just poured into this room, very nice, thanks.
12:53:24 <Cale> meToo_: I consider subtyping the largest mistake of typed OO languages, because it breaks type inference horribly, and doesn't really buy you all that much -- all you really need is a way to make objects of a given type which have different implementations for the methods. That shouldn't need subtyping in principle.
12:53:51 <meToo_> Cale: yes, but you can do most of OO with composition
12:54:01 <Cale> meToo_: Instead, you have functions which produce records of methods, and the parameters to those functions are the "private" data.
12:54:02 <EvanR> which is also painful
12:54:03 <dolio> shachaf: I guess part of the issue is that I don't know of any, "add this to regular expressions and they're not context free."
12:54:07 <meToo_> and you can use context bounds in Scala for ad-hoc inheritance
12:54:26 <dolio> It's just a different system for specifying them.
12:54:48 <icicled> that video about lenses + transformers if anyone is curious: https://www.youtube.com/watch?v=GZPup5Iuaqw
12:54:51 <dolio> Er, "they're context free."
12:54:54 <meToo_> * ad-ho polymorphism
12:54:57 <Cale> meToo_: Yes, it's a bit of a different story if you really want to have some objects with an extended set of methods
12:55:03 <Cale> But mostly you don't want that
12:55:08 <EvanR> meToo_: it hurts a lot to see a single choice of object nests hard coded, when there are many ways to view the data of your game
12:55:10 <Cale> It creates all sorts of problems
12:55:14 <__monty__> milesrout: Maybe there's a grammar in here somewhere: http://dev.stephendiehl.com/fun/
12:55:40 <EvanR> the same issue with object databases
12:55:41 <meToo_> EvanR: that is an interesting angle. Views on the data
12:55:53 <milesrout> __monty__: thanks
12:55:54 <Cale> So yeah, I was going to say, something we can do in Haskell is abstract the object types over the choice of monad in which their methods will run.
12:55:55 <milesrout> will take a look
12:56:12 <milesrout> maybe I should write this in Haskellâ€¦ itâ€™s well known that itâ€™s a good language for writing parsers
12:56:24 <Cale> That's not always a useful thing to do
12:56:32 <__monty__> What language did you write it in?
12:56:58 <meToo_> Cale: so the Monad would be used to split the behaviour from the data?
12:56:59 <Cale> But sometimes it's really nice to be able to use some kind of fake State World instead of IO for testing.
12:57:00 <EvanR> meToo_: a big game has a lot of data, its nice to think of all of it separately, for separate purposes
12:57:23 <EvanR> support particular systems, like the physics, or the economy, or the animations
12:57:40 <EvanR> or the "scripting" "events"
12:57:45 <EvanR> cinematics
12:57:46 <parsecChar> I'm trying to build a Haskell/GHC.Core -> JS compiler. I'm having trouble compiling Haskell pattern matching to JS code. Any suggestions on what to read?
12:57:54 <Cale> Of course, this is of limited use in a game setting...
12:57:58 <parsecChar> In particular, I'm not sure how to layout haskell "data ... = ... " in JS land to make pattern matching nice.
12:58:12 <Cale> But for other applications of this "OO" approach, I think swapping out the monad can be really powerful
12:58:38 <Cale> (basically, this is the van Laarhoven free monad thing, just slightly disguised)
12:58:46 <__monty__> parsecChar: I'd assume ghcjs would be a good source :)
12:58:57 <meToo_> EvanR: Cale: It seems that the FP way for modelling a domain is much less perscriptive
12:59:03 <simpson> EvanR: Out of curiosity, how does "everything is an object" break at scale? I'd love to know of the fundamental problems.
12:59:06 <suppi> or elm/purescript
12:59:27 <meToo_> ... almost like you have to come up with the best way of doing it on a per domain basis
12:59:27 <MarcelineVQ> Wizek_: linking errors like that are usually caused by forgetting to add a module to other-modules or exposed modules, possibly something called first based on this error. http://stackoverflow.com/questions/32041732/haskell-cabal-build-undefined-reference-error-and-duplicate-recompilation
12:59:28 <Cale> meToo_: There's no one best way to do anything -- everything involves tradeoffs
12:59:39 <meToo_> Cale: very true
12:59:54 <Cale> meToo_: FP just gives you all the tools you need to be able to make those decisions the way you want
13:00:12 <Cale> How you actually decompose the problems is up to you
13:00:31 <Cale> Well, "all" -- there are quite likely lots of things yet to be found
13:00:45 <Cale> But Haskell has a lot of tools :)
13:01:04 <dolio> shachaf: So, if you had ways of manipulating a stack, and a combinator that did recursion by wrapping in a pre-stack thing and a post-stack thing, that might be context free.
13:01:08 <broma0> what's everyone thinking about the OverloadedRecordFields work? is it a game-changer for you? 
13:01:37 <meToo_> Cale: It would just be very useful if there was an example app, maybe on GitHub, that shows at least one way to build the server-side of a simple "Enterprise" CRUD. It would probably be 30 lines of code, but would really help people see how to think in Haskell for such "boring" apps.
13:01:40 <suppi> broma0, not until records are extensible and first class :}
13:01:45 <EvanR> simpson: it will be awkward to do most new tasks, because you didnt think about needing to operate on all the stuff you just hid in various places. if objects implies mutating internal state, now we have a large universe of mutating internal state to consider for a new task. and if we somehow ended up with a way to solve new problems by quickly tossing together temporary objects in a well-formed combination, its probably easier to type it and read it if it
13:01:47 <Cale> broma0: I can't really see it as a game changer... it might be syntactically nice at the expense of making type errors annoying.
13:02:04 <Cale> broma0: But it's not going to really affect what I can already do
13:02:14 <meToo_> even the TodoMVC app in GHCJS is a start!
13:02:27 <Wizek_> MarcelineVQ, Thanks for the pointer, trying to add a few things in there. 
13:02:33 <meToo_> but just not enough of a domain to be instructive or provocative
13:02:57 <dolio> shachaf: I'm not sure if just adding the stack stuff lets you do context free things if your only recursion is star, though.
13:03:39 <EvanR> meToo_: the crud paradigm was invented to correspond precisely to what crud technology was good at doing, to adapt haskell to be crud and do crud isnt really exciting or enlightening in any way. but i guess it can pay bills
13:03:50 <dolio> Maybe it is, though, because that's the difference between PDA and DFA.
13:04:23 <EvanR> meToo_: i would be excited to see less crud and more of what Cale's job uses, or something even less webby
13:04:27 <Cale> EvanR: There are moderately-exciting places where we can run with that story, I think.
13:04:40 <meToo_> EvanR: that's not how I see it. In a proper real-world app, there is sometimes a need for CRUD, but that does not mean there is more interesting stuff too
13:04:41 <Cale> I mean, I sort of think of what we're doing as fitting into that space
13:04:54 <simpson> EvanR: Well, why are objects necessarily mutable?
13:04:58 <__monty__> meToo_: Reflex has a todomvc example: https://github.com/reflex-frp/reflex-todomvc
13:05:12 <Cale> Our applications really do create, read, update (and rarely delete) things
13:05:13 <broma0> suppi: you're right about extensible/first-class
13:05:41 <broma0> Cale: fiar enough, thanks for the input
13:05:42 <Wizek_> MarcelineVQ, That was exactly it, thanks a bunch!
13:05:43 <Cale> and it's *mostly* about providing some sort of nice way for users to manipulate a database
13:05:47 <EvanR> simpson: they arent, which is usually an argument to make, but in ruby smalltalk and whatever IRL oop system, they are and they are leveraged for that. thats an optional source of exploding heads for my warnings
13:05:48 <MarcelineVQ> Wizek_: excellent
13:06:04 <meToo_> __monty__ : I will take a look thanks. My main aim is to see how people who know Haskell well model domains. maybe it is not so "this is hwo you do it" as it is in the OOP world/.
13:06:20 <Cale> broma0: We usually prefix all our record field names with the name of the record type anyway
13:06:25 <EvanR> simpson: that just gets into what OOP is, what "everything is an object" means really
13:06:28 <simpson> EvanR: Monte's references are immutable by default, because we inherited it from E. Modern ECMAScript also inherits this trait from E.
13:06:48 <simpson> EvanR: There are no values that aren't objects. (Objects are bundles of state and behavior.)
13:06:56 <Cale> broma0: which is a little annoying, but it's always possible to throw a type class on top of that, if you really need to abstract over "everything which has an X"
13:06:58 <broma0> Cale: that can get a bit cumbersome if the type hsa a long name
13:07:08 <Cale> It's *slightly* cumbersome
13:07:08 <broma0> Cale: lens :D
13:07:10 <EvanR> simpson: ive enver really considered javascript to be in any OOP camp
13:07:21 <Cale> but yeah, lens does a nice job with such things
13:07:28 <simpson> EvanR: Even though it's clearly descended from Self?
13:07:35 <Cale> the template haskell has an easy time with it
13:08:08 <EvanR> yeah, its not culturally oop. theres some attempts to restore that kind of idea but js people dont really care
13:08:29 <simpson> EvanR: Ah, okay. So, I'm not talking about object-oriented patterns; I'm talking about object-based languages.
13:08:32 <Cale> meToo_: Yeah, there's much less consensus here about "the right way" to model a domain.
13:08:47 <simpson> EvanR: Is there a reason why the semantics of object-based languages fail at scale?
13:08:49 <Cale> meToo_: and more recognition that every way of doing it has advantages and drawbacks
13:09:03 <broma0> Cale: im working on a th library that wraps HDBC by allowing the user to supply a path to a .sql file. the lib uses markers in the .sql file like ":username" or ":owner" to create a record. that record is then filled out and called with a generated function to run the SQL. multiple .sql files with the same identifiers generate clashing record names
13:09:04 <EvanR> i was talking about oop thinking of designs
13:09:15 <meToo_> Cale: for sure. That is what I am trying to enjoy.
13:09:28 <meToo_> todoItem :: MonadWidget t m
13:09:29 <meToo_>          => Dynamic t Task
13:09:31 <meToo_>          -> m (Event t (Task -> Maybe Task))
13:09:34 <EvanR> if theres objects you never see in all the libs or in the implementation then doesnt seem to matter if you never use them
13:09:36 <simpson> EvanR: Oh, okay. Yeah, "object-oriented" is pretty boring. There's lots of random loosely-associated ideas in that space, and few of them are worth pursuing these days; we've learned and moved on.
13:10:28 <broma0> Cale: the generated record type "holds" all the parameter subsitution information
13:10:44 <EvanR> clojure is an object based language because the implementation is 100% java objects for every function ;)
13:10:52 <simpson> EvanR: Yes.
13:11:06 <EvanR> but i dont have to know that
13:11:09 <meToo_> simpson: but OO helps capture and describe business concepts. Monads are good at implementing them in clever ways
13:11:10 <Cale> meToo_: that's a pretty interesting type...
13:11:10 <Cale> meToo_: I'm not sure it's what I'd have gone with
13:11:20 <simpson> EvanR: (It would not be the case were it not possible to import Java objects directly into Clojure and use them as values.)
13:11:34 * dgpratt is trying to grok this https://github.com/sdiehl/write-you-a-haskell/blob/master/chapter7/poly/src/Infer.hs#L155 and is having a hard time
13:11:45 <meToo_> Cale: reflex todomvc
13:11:54 <Cale> meToo_: yeah, I realised
13:12:02 <dgpratt> line 153, we infer the type of e1, which is the function being applied, fine
13:12:09 <simpson> meToo_: Sure.
13:12:20 <EvanR> meToo_: actually me experience with business concepts has been that they are relational data and transactions
13:12:25 <broma0> dgpratt: taking a look..
13:12:34 <meToo_> Cale: just wanted to make sure you didn't think I could write that (yet!)
13:12:35 <EvanR> to dredge up a debate from 1994 ;)
13:12:35 <Cale> meToo_: (be aware that this is something that Ryan probably hacked together in a few hours, so it might not be architecturally the most sound example)
13:12:50 <dgpratt> line 134, we infer the type of e2, the argument to the function
13:13:06 <dgpratt> err...154, not 134
13:13:17 <dgpratt> line 155...umm...
13:13:46 <meToo_> Cale: I know. What I want is something with a few more domain objects, and relationships. My current goal is to see how they are modelled rather than how the UI is updated reactively
13:13:48 <EvanR> im not sure how oop got into business, it was originally invented for GUIs. maybe because the terminology has more active-sounding words
13:13:57 <dgpratt> let's see...there's an arrow type here, basically "t2 -> tv"...
13:14:06 <meToo_> EvanR: Smalltalk played a big part
13:14:35 <Cale> meToo_: Our biggest problem right now are the constraints on how that's done which are put on us by SQL
13:14:38 <broma0> dgpratt: i tap out already. good luck
13:14:54 <Cale> meToo_: SQL is really really bad at sum types
13:14:55 <dgpratt> thanks for the encouragement, broma0 :D
13:15:11 <Cale> meToo_: and so are most of the ways of interacting with a postgresql database
13:15:13 <meToo_> EvanR: most of the GoF design patterns book's impls are in the GUI space
13:15:15 <dgpratt> Cale, one of the few things I really dislike about SQL
13:15:19 <dgpratt> so sad
13:15:34 <csongor> Hi! I'm looking for example programs that would break should partial type family application be implemented - (something like when from "f a ~ Maybe Int", f == Maybe and a == Int is deduced, which wouldn't be possible with partial app) - thanks!
13:15:41 <meToo_> Cale: that is another key point. In OO you are fighting the "impedence mismatch'
13:15:47 <geekosaur> simpson, re OOP at scale, it turns out that most OOP systems behave very idiosyncratically as the message passing becomes more complex. IIRC there are some pathological cases where even apparently simple messages do not behave in a predictable or reproducible way; as the design gets more complex this is more likely to happen
13:16:10 <meToo_> which also shapes and constrains he solution to some extent
13:16:15 <Cale> meToo_: So to some extent, even if I could show you the code we're using in production, we're not even really very happy with how we're doing the domain modelling, it's a compromise for being able to use postgresql
13:16:25 <dgpratt> of course, I can actually blame Haskell for disliking that aspect of SQL because before Haskell I didn't miss sum types
13:17:12 <Cale> But! It's already more of a compromise than required to get easy JSON representations.
13:17:45 <Cale> So we also get to use Aeson's template haskell stuff for generating ToJSON and FromJSON instances for everything
13:18:20 <geekosaur> (also that's without involving known pain points like multiple inheritance)
13:19:40 <meToo_> Cale: I sort of was expecting that I can still model the domain with the usual OO tools (class diag, seq diagram, action diag etc) to get my head around the business concepts (monsters and players etc) but maybe that colours the possible impls too much and limits how to best do it in Haskell/FP
13:19:49 <EvanR> meToo_: we need a GoF for FP patterns ;)
13:20:09 <EvanR> and decommission most of whats in Design Patterns
13:20:16 <meToo_> EvanR: how many Monad tutorials do you think there already are?!
13:20:20 <EvanR> ...
13:20:28 <EvanR> decommission all those too
13:20:39 <david_koontz> yeah what youâ€™re talking about feels a bit like â€œor use category theoryâ€
13:21:04 <david_koontz> although monad transformers is probably more of a â€œdesign pattern for FPâ€ kind of thing
13:21:08 <david_koontz> as is Free
13:21:27 <EvanR> category theory with a skin should be #1 thing on the as yet unimplemented Enterprise Haskell Integration Patterns Incorporated
13:21:44 <Cale> The thing is, most of what would be our "design patterns" are not design patterns, because our language is strong enough to just express them directly
13:21:47 <EvanR> objects are customers and arrows are services
13:21:48 <Cale> So they're libraries.
13:21:52 <meToo_> EvanR: put me down for a copy
13:22:20 <Cale> However, there *are* some design patterns which are properly design patterns -- it's just they're quite hazy
13:22:40 <Cale> Like the whole approach of "design an embedded domain specific language"
13:22:43 <EvanR> if a pattern is good, then the next generation language will be able to make it into a library
13:22:52 <meToo_> it is true that several design patterns are just getting around deficiencies in the impl language
13:22:53 <EvanR> even DSLs ;)
13:22:55 <Cale> That's hard to just capture as a library directly
13:23:21 <EvanR> a new DSL might be a sort of fixed point in the design pattern pattern
13:23:22 <Cale> We don't know how to do it well enough to write the library, or add a single specific feature to the language
13:23:34 <Cale> We've already kind of made it easy to do in various ways
13:23:39 <Cale> pattern matching, type classes and such
13:23:52 <Cale> But there's still some part of that process which is not easily captured
13:24:05 <Cale> We don't understand it well enough
13:24:37 <Cale> meToo_: I sort of see all design patterns as being deficiencies in the host language
13:24:57 <Cale> If the host language were better, you would abstract the pattern away, and never write it again
13:25:14 <EvanR> quasiquoters!
13:25:15 <dolio> 'Design an embedded language' is so vague, I'm not sure how you'd make it a library.
13:25:29 <meToo_> Cale: but before the defiency was discovered, people had to still get work done, and it sort of captures what they learnt
13:25:32 <Cale> dolio: Right, it's almost too vague to be a real pattern
13:25:43 <EvanR> meToo_: sometimes, or sometimes its an anti pattern
13:25:45 <Cale> dolio: But there's something there which we're doing over and over
13:26:00 <dolio> Some parts of it can become libraries.
13:26:03 <Cale> yeah
13:26:14 <Cale> We have been attacking that monster for quite some time :)
13:26:26 <dolio> But to some degree, it's like saying, "write a program," is a pattern that we're doing over and over.
13:26:28 <meToo_> EvanR: what don't yo ulike about Singleton in Java 1.5?!
13:27:04 <EvanR> its something we learned to do and not question
13:27:11 <Cale> It's almost *the* monster to go after. Almost all techniques for better software engineering come out of trying to abstract some part of the process of constructing domain specific languages.
13:27:14 <EvanR> in the name of producing more keystrokes
13:28:28 <david_koontz> are you saying the Lisp people were right all along and all of programming is just about gowing your DSL up to meet the problem youâ€™re tring to solve? ;)
13:28:44 <EvanR> yes
13:28:44 <simpson> geekosaur: That's fair; I'm not sure if it's especially different from calling functions at scale, but you're right that the behavior of a system gets quite complex as it gets big due to unexpected interactions between components.
13:28:53 <EvanR> they just didnt think types would help
13:29:01 <david_koontz> which has always boggled my mind
13:29:03 <Cale> david_koontz: Well, it's not like we're not doing the same stuff in Haskell. Haskell is practically a recognition of all the patterns which people were doing in Lisp.
13:29:10 <dmj`> david_koontz: DSLs ftw
13:29:11 <david_koontz> yeah I was being facetious
13:29:14 <Cale> david_koontz: Like, look at pattern matching on algebraic types
13:29:22 <Cale> SICP talks about that pretty much
13:29:26 <simpson> david_koontz: Some Haskell libraries make me really sad in that way.
13:29:28 <Cale> and Haskell makes it into a language feature
13:29:33 <dolio> The problem is that Lisp people were bad at it. :)
13:29:41 <david_koontz> well to be fair, they were pioneers
13:29:56 <david_koontz> and no type system is easier to implement than no type system
13:30:03 <simpson> Like blaze-html, for example. Monte lets me say html`<p>$this is pretty cool</p>`; I've yet to see a sufficiently nifty HTML library in Haskell.
13:30:21 <Zekka|Sigfig> davean: The lisp people are not the only people who say that, even though they claim it
13:30:22 <Cale> There's an extent to which we're also bad at it, and with enough experience, we'll figure out how to make the next programming languages.
13:30:23 <geekosaur> simpson, the main confounding factor is that it's relatively easy to end up with message delivery (i.e. method call), which is done at runtime, where you cannot be absolutely certain what actually receives the message
13:30:34 <Zekka|Sigfig> I donâ€™t think they were even the first.
13:30:35 <Cale> simpson: reflex-dom is pretty nifty
13:30:45 <simpson> geekosaur: Isn't that just polymorphic dispatch?
13:30:53 <Cale> simpson: But it's nifty in a very different way
13:31:19 <geekosaur> part of the impetus behind C++ style OO was making that more deterministic, while retaining polymorphic dispatch
13:31:23 <david_koontz> Zekka|Sigfig: Lisp may not have been the first, but it certainly seems like the communiy that best popularized the idea
13:31:28 <simpson> Cale: Wow, yes, that's pretty intense.
13:31:36 <meToo_> is there an archive of this channel?
13:31:42 <Cale> meToo_: yes...
13:31:43 <geekosaur> sadly I do not recall the example and finding it in my logs would be difficult because it's hard to grep abstract concepts >.>
13:31:50 <david_koontz> itâ€™s in the title
13:31:51 <Cale> http://ircbrowse.net/
13:32:33 <geekosaur> (also my older logs are offline until local network folks fix the local network --- I'm tethered to phone currently)
13:32:35 <meToo_> thanks Cale: I want to study your description of your system later. 
13:32:43 <meToo_> ... download complete; off to watch SPJ's contract talk.  Good night!
13:32:53 <Cale> g'night!
13:35:31 <geekosaur> (I *think* the particular pathological behavior is specific to Smalltalk/Objective C style OOP as opposed to C++ style. I'm not sure where Java sits in that space but I think it's closer to C++. Perl and Python OOP are still different things but I think don't fall afoul of the specific issue)
13:35:43 <Zekka|Sigfig> david_koontz: FWIW, I think â€œwho popularized Xâ€ or â€œwho was first to say Xâ€ are not good ways to evaluate implementations of X, but Iâ€™m personally a little more into Lispâ€™s code generation support than to Haskellâ€™s
13:36:26 <Zekka|Sigfig> itâ€™s just easier-to-understand imho â€” and that goes for a lot of Lisp, even though I really hate the syntax
13:36:51 <simpson> geekosaur: (FWIW I think that a large part of my kookiness comes from being in the corner of the object-based universe that rejects most of the object-oriented doctrine. No inheritance, no access modifiers, no ambient authority, no reflection, no attribute access.)
13:37:00 <geekosaur> ah
13:37:19 <david_koontz> Zekka|Sigfig: ok I would restate it then as â€œthe Lisp community seems like the first to really embrace the idea of growing an app specific DSL and thus has put a lot of collective mental energy into figuring out what works and what doesnâ€™tâ€
13:37:59 <david_koontz> Iâ€™m not advocating to go program in Lisp or that they are doing things better than Haskell, just that if there are to be gleaned some nuggets of wisdom from 40 years of experimentation, that community seems an ok place to go look
13:39:18 <EvanR> look but dont touch ;)
13:40:37 <Zekka|Sigfig> david_koontz: Iâ€™m not arguing thatâ€™s not true, just trying to cheerfully warn against being too mythological about the history of code generation!
13:40:53 <david_koontz> ah, perhaps I misunderstood
13:41:06 <david_koontz> I was speaking to DSLâ€™s in general, not any particular implemenation of getting a DSL
13:41:14 <david_koontz> of which Iâ€™m sure there are many
13:41:33 * hackagebot Unique 0.4.3 - It provides the functionality like unix "uniq" utility  https://hackage.haskell.org/package/Unique-0.4.3 (kapral)
13:42:17 <S11001001> @remember david_koontz and no type system is easier to implement than no type system
13:42:17 <lambdabot> Done.
13:42:38 <david_koontz> lol, what does that do?
13:43:05 <EvanR> its delivered directly to the tabloids
13:43:11 <Twey> @quote david_koontz
13:43:11 <lambdabot> david_koontz says: and no type system is easier to implement than no type system
13:43:19 <david_koontz> ah, I am immortalized
13:43:47 <Zekka|Sigfig> I think you probably donâ€™t have to go as far as Lisp to come up with good lessons for codegen folks in Haskell to examine
13:44:13 <Zekka|Sigfig> Maybe one to start with would be this: try using primitives that take less than a full page to introduce to new users.
13:45:17 <david_koontz> have you seen jdegoes talk on the future of FP langs, or Emily by Andi McClure?
13:45:23 <Zekka|Sigfig> david_koontz: I havenâ€™t
13:45:34 <david_koontz> both of those jumped to to me as recent examples of people trying to get more to the simple set of core parts
13:45:56 <david_koontz> those are not DSLâ€™s though, so I may be steering this converastion in the wrong direction
13:46:07 <david_koontz> they were more about FP langs just in general
13:52:03 <Zekka|Sigfig> david_koontz: FWIW I still donâ€™t know what a DSL is, exactly
13:52:14 <Zekka|Sigfig> I know what the term is and what people use it for, but they seem to use it for almost everything
13:52:39 <david_koontz> well just like a â€œgeneral purpose langaugeâ€ is pretty non-specific
13:52:57 <Zekka|Sigfig> I think most people would agree regex is a DSL, and probably a lot of people would say free monads are a way of implementing a DSL â€” but I donâ€™t really see a line between a DSL and an API
13:53:14 <david_koontz> I think that is a fantasitc observation
13:53:18 <david_koontz> why does there need to be one
13:53:39 <david_koontz> a sufficiently â€œgoodâ€ api is a DSL, I think processing built on top of Java is a prime example of this
13:53:47 <Zekka|Sigfig> A lot of the techniques Haskell people seem to like to use for expressing the things they call DSLs seem to carry bizarre amounts of baggage not really relevant to the problem â€” so I donâ€™t like those things â€” but I like really problem-specific APIs that donâ€™t surprise me very much
13:53:49 <david_koontz> I didâ€™t realize it was Java for some time
13:54:35 <simpson> Zekka|Sigfig: Some languages have a hard barrier between (quasi-)literal program strings embedded within the source code and regular parameters.
13:54:45 <simpson> Zekka|Sigfig: Regexes, for example, in many modern languages. They are a DSL.
13:54:46 <Zekka|Sigfig> (in this case Iâ€™m mostly talking about free monads, but theyâ€™re really not the only trick Iâ€™ve seen to overload lots of existing syntax according to some kind of laws)
13:55:04 <david_koontz> the only place I see the â€œcarrying around baggageâ€ bit being useful is if it allows you to change the rules in a context, like â€œin here all our commands are run in parallel and then merged into a stream for us
13:55:48 <Zekka|Sigfig> I guess what Iâ€™m really skeptical of is the idea of DSL tricks â€” there arenâ€™t really â€œAPI tricksâ€ but there are lots of designated kinds of baggage that seem to be introduced when people decide theyâ€™re doing a DSL
13:56:10 <david_koontz> so what youâ€™re saying is, you can overengineer a solution in any language
13:56:22 <simpson> Zekka|Sigfig: You're right that, operationally, there's no difference. It's about the size and style of the Archimedean lever which you give to your users.
13:56:55 <Zekka|Sigfig> the API trick for associativity is defining a monoid â€” but it seems like the DSL trick is to make it a free monad
13:56:56 <pantsman-> you're right, there's a class of programming practices that are frowned upon which suddenly become OK once you say "but I'm doing a DSL@
13:57:14 <pantsman-> like having a bad monad instance just because do notation is handy
13:57:17 <Zekka|Sigfig> Of course, Haskell doesnâ€™t have it so bad â€” in Ruby, if itâ€™s a DSL, all of a sudden you have to find a way to put it in blocks
13:59:24 <Zekka|Sigfig> AFAICT the line of thought goes â€œcode generation is hard, letâ€™s have a bunch of features targeted towards thatâ€ <=> â€œletâ€™s use the code generation to write things we couldnâ€™t as-easily write before which we call DSLsâ€ <=> â€œthose code generation features are DSL featuresâ€ <=> â€œif youâ€™re writing DSLs, use these featuersâ€
13:59:36 <simpson> pantsman-: To borrow a concept, the Pythonistas said "Namespaces are a great idea -- let's do more of those!" and then decided to do more namespaces instead of more ideas.
13:59:50 <Zekka|Sigfig> Maybe the moral thing to do here is to avoid coming up with abstractions that are mostly useful for coming up with other abstractions.
14:00:09 <Zekka|Sigfig> (Which Iâ€™m pretty sure makes Haskell the Great Satan. Whoops.)
14:06:33 * hackagebot hsexif 0.6.0.8 - EXIF handling library in pure Haskell  https://hackage.haskell.org/package/hsexif-0.6.0.8 (EmmanuelTouzery)
14:08:00 <EvanR> pantsman-: i dont think thats OK
14:08:03 <EvanR> DSL or not
14:12:46 <pantsman-> neither do I. I think (embedded) DSL is a marker for, "I'm probably doing something weird here, but I'm convinced it's worth it for some reason"
14:14:56 <Zekka|Sigfig> Well, thereâ€™s two versions of â€œbad monad instance"
14:15:06 <Zekka|Sigfig> one is pure evil and involves having a bind that doesnâ€™t mean anything and is just there for do notation
14:15:59 <Zekka|Sigfig> one is, for normal type Normal, refusing to let people operate on anything other than State Normal
14:16:30 <EvanR> hrm.
14:16:58 <EvanR> i was going to say that second one is a straightforward application of a custom monad
14:17:17 <EvanR> like a self contained set of global variables
14:17:44 <EvanR> cant be denied monads can do that
14:19:58 <acertain> i want a data structure that is an IntMap but has fast "delete less than n"
14:20:04 <Lokathor> so I seem to have written a RandomGen type that's about twice as fast as StdGen is at the expense of twice the memory use (two Word64 instead of two Int32)
14:20:12 <Lokathor> just did an actual speed comparison a bit ago
14:20:28 <EvanR> but will it split?
14:20:50 <Lokathor> yep, it's a full RandomGen instance with split and genRange too
14:20:59 <Lokathor> better range than StdGen actually
14:21:24 <acertain> nevermind, a normal IntMap will work
14:22:45 <parsecChar> modify :: <-- is there a variant of this, which *returns* the new value ?
14:22:55 <parsecChar> so (s -> s) -> State s, instead of (s -> s) -> State ()
14:23:21 <Lokathor> don't think so, but it'd also be trivial to write
14:23:36 <parsecChar> I'm just surpirsed modify' doesn't exist
14:23:44 <parsecChar> since modify can be trivially implement as "void $ modify' "
14:23:59 <Lokathor> i'm pretty sure that modify' does, but that it's not what you want
14:23:59 <Twey> modify' f = modify f >> get
14:24:03 <Lokathor> i think it's strict modify
14:24:39 <parsecChar> what sould I call it?
14:24:42 <parsecChar> I don't like the name modify0
14:24:46 <parsecChar> maybe call it modify_
14:24:48 <parsecChar> but use of _ is weird
14:25:02 <Twey> modifyAndGet ;)
14:25:04 <Lokathor> modGet
14:25:11 <parsecChar> Twey: you're brilliant
14:25:17 <parsecChar> modifyGet
14:25:44 <Twey> I probably wouldn't name it
14:25:50 <Twey> The expression is too short and obvious to name
14:25:53 <scshunt> is there a library to let you run computations in a monad without side-effects
14:26:01 <Twey> At least at the top level where names matter
14:26:08 <Lokathor> EvanR, it might be possible to make my RandomGen even faster, but probably not much even faster at this point, since I already use unpacked strict Word64
14:26:09 <Zekka|Sigfig> scshunt: Most monads donâ€™t involve side effects
14:26:12 <scshunt> e.g. in State, you do { s <- get; result <- someAction; put s }
14:26:27 <scshunt> Zekka|Sigfig: Monadic side effects, not true side effects
14:26:34 <Zekka|Sigfig> OK, sorry to interrupt you
14:26:39 <scshunt> which causes the side effects of someAction, namely any manipulation of state, to be undone
14:26:50 <Lokathor> scshunt, you mean perform a non-monadic computation within a monad?
14:26:54 <scshunt> Lokathor: No.
14:27:03 <scshunt> someAction still has acess to the state while it's executing
14:27:12 <scshunt> just that at the end, its changes are undone
14:27:18 <Lokathor> oh like local
14:27:20 <Lokathor> for reader
14:27:21 <scshunt> yeah
14:27:26 <monochrom> could you write the type signature of what you want?
14:27:41 <fr33domlover> scshunt, maybe you mean the ST monad?
14:27:45 <Lokathor> monochrom, the type signature wouldn't tell as much of the story
14:27:47 <scshunt> except that local works by virtue of the fact that the reader's "state" is immutable, so it's safe to undo
14:28:10 <Zekka|Sigfig> Iâ€™m pretty sure you canâ€™t do that in general (how would you implement it for IO?), but itâ€™s not hard to define it for specific monads
14:28:17 <Lokathor> scshunt, well you could write a version of local for state just like you showed there, and overwrite the state after someAction back to waht it was before
14:28:19 <scshunt> Zekka|Sigfig: Right
14:28:27 <EvanR> Lokathor: Word64 based RNGs are cool, but did you use normal arithmetic or did you get access to an instruction that gives you a carry?
14:28:32 <scshunt> I'm wondering if there's a library with appropriate typeclasses for monad transformers for it
14:28:32 <monochrom> the type signature is a sanity check
14:28:44 <scshunt> since I've just written one and would gladly borrow someone else's
14:28:44 <Zekka|Sigfig> OK, now I understand what you want. Not sure if it exists though
14:29:08 <fr33domlover> scshunt, iirc there's a library that holds an "undo stack" of states
14:29:09 <amf> does anyone use docker with a haskell (ghc) service in docker with the +RTS -Mx param set?
14:29:21 <Lokathor> EvanR, i used the PCG style RNG (http://www.pcg-random.org/), so it uses normal bit fiddling operations from Data.Bits
14:29:26 <fr33domlover> so you can push and pop temporary states etc.
14:29:53 <scshunt> fr33domlover: that's kind of neat
14:29:58 <Lokathor> perhaps if I change it to be unboxed Word64# values I could make it go faster, but *# looks like it's kinda dodgy when I read the docs
14:30:25 <fr33domlover> I wrote an undo stack myself but iirc never published it because the project somehow stopped, i don't remember :P
14:30:30 <scshunt> I'm looking for a transformer approach specifically, so that if I decide to use MonadError or MonadWriter for error handling or logging, I can just discard the seide-effects there too
14:30:41 * fr33domlover should probably release that code, it's 99% finished...
14:30:48 <scshunt> although I guess I'll probably want an undo stack too, that will come later and I'll probably just implement it with Zoom
14:31:45 <fr33domlover> scshunt, maybe you want something broader then, like a MonadDiscard class for monads which can discard effects? :P
14:33:45 <Lokathor> i was going to submit my thing for use in a random-1.2 release, but i guess if there's double the space used, it's a fair choice between space and time, not really a strict upgrade
14:34:15 <scshunt> fr33domlover: that's exactly what I ended up writing
14:34:19 <scshunt> except I called it MonadSimulate
15:49:56 <parsecChar> the js code I am generating are ugly
15:50:09 <parsecChar> maybe haskell -> js isn't such a good idea after all, and maybe ghcjs/haste did everything right
15:50:26 <geekosaur> does it matter? once you minify it it won't be readable anyway >.>
15:50:55 <dmj`> parsecChar: haskell -> js is a good idea, js itself was a bad idea
15:51:00 <parsecChar> yeah; but my compiler is buggy, so I have to debug things
15:51:07 <parsecChar> and my js code is ugly; making my debugging life hell
15:54:13 <mushroom_tip> Is looking up the solution to a problem bad if you understand and learn from said solution, rather than just shrug off the problem as solved?
15:56:56 <dmj`> mushroom_tip: depends on the problem, but in general learning how solutions work is a good idea.
16:31:38 * hackagebot camfort 0.62 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-0.62 (DominicOrchard)
16:43:12 <Lokathor> EvanR, i overspoke, after a small bugfix I had to perform, the result is only 35% faster than StdGen
16:44:36 <erisco> what Haskell web servers are being used in production?
16:44:51 <monochrom> I think at least warp
16:45:57 <erisco> seems like it has some attention over the past 5 years, which is good
16:46:38 * hackagebot Unique 0.4.4 - It provides the functionality like unix "uniq" utility  https://hackage.haskell.org/package/Unique-0.4.4 (kapral)
16:56:38 * hackagebot camfort 0.700 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-0.700 (DominicOrchard)
17:29:24 <byorgey> shachaf, dolio: re: the relationship between Applicative and context-free etc., I don't know of any formal references, it's just "folklore" as far as I know
17:29:37 <byorgey> which probably means that working it out carefully would yield some interesting/surprising results =)
17:31:40 * hackagebot repa-scalar 4.2.0.2 - Scalar data types and conversions.  https://hackage.haskell.org/package/repa-scalar-4.2.0.2 (BenLippmeier)
17:43:35 <shachaf> byorgey: (There was a bit more discussion in #-lens later, if you're interested.)
17:52:44 <Lokathor> unboxed tuples slow down my program
17:52:49 <Lokathor> by just a bit, but it's there
17:52:54 <bitemyapp> Lokathor: my condolences
17:52:55 <Lokathor> troublesome
17:53:06 <dmj`> the struggle is real
17:53:19 <Lokathor> the docs said they would do the opposite!
17:53:22 * Lokathor shakes fist at sky
17:54:26 <emmanuel_erc> Have any of guys actually used the fix or mfix functions in your code? 
17:54:57 <dmj`> emmanuel_erc: yea
17:55:26 <emmanuel_erc> Oh... what was the situation? 
17:55:32 <Lokathor> cycle is based on fix, so yes i have
17:55:43 <dmj`> emmanuel_erc: it's good for re-entry logic
17:56:55 <dmj`> emmanuel_erc: https://ro-che.info/articles/2015-09-02-monadfix
17:57:25 <dmj`> emmanuel_erc: look at the guessNumber part
17:57:29 <emmanuel_erc> ok thanks!
17:57:54 <dmj`> emmanuel_erc: it's nice for loops where you want to cancel upon a condition, and otherwise recurse
17:58:08 <dmj`> :t fix
17:58:09 <lambdabot> (a -> a) -> a
17:58:27 <dmj`> 'a' here can be any monad too
17:58:58 <dmj`> @typ fix :: (IO () -> IO ()) -> IO ()
17:58:59 <lambdabot> (IO () -> IO ()) -> IO ()
17:59:23 <emmanuel_erc> I wonder if I could have used fix in some I jut finished writing.
18:00:37 <emmanuel_erc> I wanted to cancel/halt a computation (based on a list of Eithers) if it ever encountered a left value.
18:01:09 <emmanuel_erc> Anyway, I'll read the article now.
18:02:19 <Lokathor> faster next and faster split
18:02:29 <Lokathor> i'm feelin confident about this
18:04:32 <dmj`> :t takeWhile isRight
18:04:34 <lambdabot> [Either a b] -> [Either a b]
18:05:34 <dmj`> :t \g xs -> forM_ [ x | Right x <- takeWhile isRight xs ] g
18:05:37 <lambdabot> Monad m => (a -> m b) -> [Either a1 a] -> m ()
18:10:32 <emmanuel_erc> dmj`: I also need to record the Left value that would have been the cause of the failed computation. I should have included that.
18:13:03 <emmanuel_erc> I just wrote a custom strict left fold and called it a day.
18:15:29 <emmanuel_erc> Well, I need to be clearer. I won't get into the guts of the thing.
18:15:31 <dgpratt> if anyone here would enjoy nothing better than fielding a bunch of naive questions about HM and type inference and unification and such things, by all means please let me know :)
18:17:27 <eacameron> Is there a generic exception I can throw just for the sake of being caught? I just want to get to my exception handler so it can convert all failures to the same thing.
18:18:15 <geekosaur> undefined?
18:19:35 <geekosaur> (which is (ErrorCall "Undefined") iirc)
18:20:22 <geekosaur> or ErrorCall "Prelude: Undefined" or some such
18:24:08 <Cale> dgpratt: You'd get a better response just asking the questions
18:24:10 <geekosaur> basically ErrorCall is as generic as it gets. you could of course create your own Exception instance to act as a placeholder, perhaps storing information about the original exception in it
18:25:20 <Cale> dgpratt: Generally it's not a good idea to ask whether anyone would be interested in answering your questions without saying what those questions are.
18:25:21 <geekosaur> although "get to my exception handler so it can convert all failures to the same thing" sounds more like you just want to catch \(e :: SomeException) -> ...
18:26:26 <dgpratt> Cale, yes I know that's the usual advice
18:26:46 <dgpratt> and it's probably the right advice, too
18:28:06 <dgpratt> but I was reluctant to waste my breath (so to speak) and spam the channel with a long-winded question on a rather esoteric topic without some encouragement :)
18:28:48 <dgpratt> that being said, I'll take your advice, Cale
18:32:25 <dgpratt> I'm looking at this http://imgur.com/nXWMqzk from http://dev.stephendiehl.com/fun/006_hindley_milner.html
18:32:45 <eacameron> geekosaur: Yes, that's precisely what my handler looks like. But in the midst of my exception throwing code, I have some Maybe's that I want to convert back into exceptions! ;)
18:33:14 <dgpratt> presumably that definition corresponds to this Haskell definition https://github.com/sdiehl/write-you-a-haskell/blob/master/chapter7/poly/src/Infer.hs#L88
18:33:54 <geekosaur> dgpratt, fwiw if a question/answer looks like it's running into other activity it can be moved to #haskell-overflow or etc. --- but it should start in here, not there
18:34:34 <dgpratt> one actual question I have is what code corresponds to the Uni-Con rule?
18:35:16 <dgpratt> it looks like function application, but of course it's at the type level
18:35:17 <eacameron> geekosaur: Thanks for pointing out ErrorCall. That is indeed very generic. throwIO (ErrorCall "bad data") should do the trick.
18:37:36 <geekosaur> you could of course just rethrow the SomeException
18:38:13 <geekosaur> oh, that may not fit what you described (somewhat obliquely)
18:38:32 <verement> @src error
18:38:33 <lambdabot> error s = throw (ErrorCall s)
18:38:51 <eacameron> I'm not a fan of lazy explosives
18:39:13 <eacameron> lazy pure explosives, even
18:39:18 <monochrom> aka time bomb
18:39:29 <geekosaur> you're already throwing an exception, you bought that farm >.>
18:39:41 <geekosaur> (mixed metaphors r us...)
18:40:10 <eacameron> geekosaur: But I can't catch lazy, pure exceptions easily (without doing deep seq or something)
18:41:12 <monochrom> sync exceptions are still more easily reasoned than async imprecise exceptions
18:42:13 <eacameron> geekosaur: lazy pure exceptions once bit me in an FFI binding...yeah, it was not fun. The FFI does not like exceptions at all.
18:44:26 <codebje> would anyone be willing to glance over a Lambda Jam presentation proposal and give me feedback?
18:54:44 <tobiasBora> Hello,
18:54:56 <dmj`> tobiasBora: Hello
18:55:24 <tobiasBora> I would like to know if it's possible to specify a title to a whole plot done with Graphics.EasyPlot, and also give names to axis
18:55:54 <tobiasBora> If it's not possible, do you have another good plot library *that can be used within GHCI in an natural way* ?
19:02:05 <Cale> dgpratt: It says that in order to determine whether tau_1 tau_2 is unifiable with tau_1' tau_2' via the composite substitution theta_2 . theta_1, we need to check that tau_1 is unifiable with tau_1' via theta_1, and we need to check that [theta_1] tau_2 is unifiable with [theta_1] tau_2' via theta_2
19:02:46 <Cale> dgpratt: However, it seems as if the code examples don't have type application
19:03:01 <Cale> dgpratt: The closest thing is the specialisation to type level (->)
19:03:18 <Cale> which occurs in the next rule, and in the code via the rule for TArr
19:03:57 <Cale> dgpratt: If there were TApp, that rule would tell us how to implement it though :P
19:05:48 <Cale> dgpratt: If you want to translate those logic-style rules with the horizontal lines in them into programs that check things, you read them upside-down -- the thing below the line says what you're checking, the things above the line tell you what you need to recursively check
19:05:49 <codebje> if anyone has 30 seconds to glance over a draft presentation abstract (https://gist.github.com/codebje/8701d62fea75238fa711) and comment, I would appreciate it
19:06:43 <codebje> working title is "composing with monoids" but I think "composing" doesn't quite fit the current abstract
19:07:06 <Cale> codebje: The category theoretical description of a monoid is maybe a little heavy if you're introducing someone to monoids in the same talk
19:07:46 <Cale> Especially as it requires the introduction of what a monoidal category is... unless you're going to give the definition which doesn't capture monad under the same umbrella
19:08:06 <Cale> (but even then, you have the categorical product and terminal objects to deal with...)
19:08:20 <codebje> yes, the product monoid is the aim of the category theoretic viewpoint
19:08:36 <Cale> Which monoid?
19:08:39 <dgpratt> thanks Cale, that more or less confirms my suspicions
19:08:53 <codebje> instance (Monoid a, Monoid b) => Monoid (a, b)
19:09:03 <Cale> oh, that doesn't require any category theory
19:09:23 <Cale> Just the ordinary definition of a monoid
19:09:27 <codebje> no, nothing about monoids really does
19:09:49 <Cale> Uh, well, the category theoretical definition of monoid captures lots of other things which are not ordinary monoids
19:09:51 <codebje> it's good feedback, I'll have a serious think about whether I should just omit the category theory
19:09:53 <Cale> Such as monads
19:10:22 <codebje> "a monoid as a category" -> "one object, many morphisms" is a nice platform for the transformation monoid, without needing to go into monoidal categories or Mon
19:10:44 <Cale> Oh, there is that, yeah
19:11:02 <codebje> this is a conference with ekmett keynoting, so I expect most attendees have been browbeaten with the objects-and-arrows notion already
19:11:27 <Cale> Yeah, that's different from what I thought you meant by "the category theoretic description of a monoid"
19:11:46 <Cale> Perhaps say "the description of a monoid as a special case of a category"
19:11:48 <dgpratt> I was also puzzling over http://imgur.com/mFJsip6
19:11:59 <codebje> I wasn't quite sure if I'd just do a monoid as a category or introduce Mon, but I think you've convinced me 30mins isn't enough for all of this
19:12:11 <dgpratt> mostly because there seems to be a lot more going on in the code than would be suggested by the rule definition
19:12:36 <Cale> dgpratt: Yeah, there's some substitutions which are being inferred along with the types.
19:13:15 <Cale> We're doing the unification at the same time as inference
19:13:27 <dgpratt> Cale, inferred in the context of the rule definition, you mean?
19:13:30 <codebje> cale, thanks very much for the feedback :-)
19:13:58 <dgpratt> since this whole thing is about inferring things, I wasn't sure :)
19:14:54 <dgpratt> that's the problem with those math guys, they leave so much unsaid
19:15:01 <Cale> dgpratt: Like, there are a couple of those unification rules being used here
19:15:14 <Cale> dgpratt: in order to make the code do two things in one pass
19:15:21 <dgpratt> ok
19:16:50 <dgpratt> maybe if I have some time, I'll try something closer to the rule defintion and try to figure out where it goes wrong
19:16:59 <dgpratt> *definition
19:17:00 <Cale> It won't go wrong
19:17:09 <Cale> It just won't compute the substitution for you at the same time
19:17:17 <dgpratt> oh
19:18:25 <dgpratt> well you've been quite helpful as usual, Cale :)
19:18:42 <Cale> no problem
19:18:48 <dgpratt> I have more questions, but alas it's my bedtime :)
19:18:55 <dgpratt> have a good night
19:19:16 <Cale> g'night!
19:20:07 <eacameron> I love how github.com/lens has edwardk as its avatar 
19:20:27 <eacameron> Nothing depicts lenses better than edwardk himself.
19:25:40 <Lokathor> fromIntegral is suprisingly costly
19:37:04 <Cale> Lokathor: yeah, I think there are some rewrite rules which try to eliminate it in many cases though
19:37:23 <Cale> Lokathor: but if those don't fire for whatever reason, it's obscene
19:37:51 <Cale> Well, that's a bit much, realToFrac is the real obscene time waster :)
19:38:05 <Cale> (It converts via Rational)
19:40:45 <Lokathor> well, it was Word63 into Int
19:41:17 <Lokathor> er, 64
19:42:19 <Lokathor> I think next and split are both as fast as they're going to get at this point
19:42:43 <scshunt> understandably
19:42:45 <scshunt> err
19:43:34 <NemesisD> i'm writing a parser for a file format that has the form of some preamble fields, a list of a single type of field that could be very large and then a final field. i'm trying to figure out what sort of API i could expose
19:44:47 <NemesisD> so something like data File = File Preamble [BodyField] Checksum, i'm using attoparsec. i'm wondering if i should keep those fields lazy and use attoparsec's lazy bytestring parser
19:45:32 <NemesisD> i also imagine users would want to easily hook the library up to something like conduit for parsing the stream in the middle of the file
19:54:11 <Lokathor> scshunt, ?
20:21:45 * hackagebot handwriting 0.1.0.3 - API Client for the handwriting.io API.  https://hackage.haskell.org/package/handwriting-0.1.0.3 (IsmailMustafa)
20:46:46 * hackagebot repa-scalar 4.2.0.3 - Scalar data types and conversions.  https://hackage.haskell.org/package/repa-scalar-4.2.0.3 (BenLippmeier)
20:46:48 * hackagebot repa-convert 4.2.1.1 - Packing and unpacking flat tables.  https://hackage.haskell.org/package/repa-convert-4.2.1.1 (BenLippmeier)
21:09:58 <scshunt> Lokathor: that was directed at Cale
21:10:22 <Lokathor> oh
21:31:33 <adarqui> hey, what's the best way to 'install binaries, from stack install', into some local dir? i mean there's stack path etc.. but.. dno what's the simplest/best way. I guess i'd like to just install them into ./bin/
21:33:44 <codebje> "stack install" puts them in ~/.local/bin, so you could just add that to $PATH
21:33:53 <codebje> otherwise cp(1) will do fine
21:34:20 <codebje> if you want them to update, you could also symlink into ~/bin/
21:35:03 <adarqui> cool thanks.. i forgot that everything is installed in ~/.local/bin
21:40:47 <mgsloan> adarqui: stack install --local-bin-path ~/bin
21:40:59 <mgsloan> But yeah, best stick with .local/bin 
21:43:26 <mgsloan> Oh wow, someone's salty
21:44:01 <mgsloan> Gershom just deleted comments on the cabal issue tracker because someone was bumping the "cabal-install has no ssl" issue
21:45:37 * EvanR deletes mgsloan's mention of this topic from irc logs
21:45:53 <mgsloan> :D
21:45:54 * EvanR clears screen
21:46:18 <sclv> mgsloan: the deletion was because its a tracker, not a "let's gossip" thread on reddit
21:47:09 <mgsloan> Fair, but he has a point that the state of cabal / hackage security is still poor.  I'm glad it's almost fixed, I did not know that
21:47:31 <sclv> there's been a beta of hackage security for like six mos
21:47:47 <sclv> and the last cabal update talked about the process of merging the full patch set and the timeline
21:48:08 <adarqui> mgsloan: thanks
21:48:13 <mgsloan> What if I accidentally upload a proprietary package?  How can I get it taken down + out of the tarball?
21:48:21 <adarqui> that helps.. i wanted one cmd to just install into a local dir
21:48:26 <adarqui> that'll do it
21:48:39 <sclv> mgsloan: the same way it has been done the last three times
21:48:59 <sclv> and that has nothing to do with the security ticket anyway
21:49:17 <mgsloan> Oh, I wasn't aware.  I thought the append-only tarball kiboshed removals
21:49:17 <sclv> what if i commit my password to github?
21:49:30 <sclv> i mean, that's not a bug in github
21:49:33 <mgsloan> Then you can force push it out of existence!
21:50:01 <mgsloan> I don't know, it would be a bug in github if accidental data leaks were uneraseable
21:50:03 <mgsloan> IMHO
21:50:16 <sclv> the main thing is not to remove the metadata -- that ship sailed. the main thing is to remove the package contents themselves
21:50:19 <davean> mgsloan: you publish something to the web, its out there forever
21:50:19 <EvanR> uploading anything to the internet almost guarantees its unerasability
21:50:23 <davean> thats how its always worked
21:50:25 <mgsloan> Ahh so if you accidentally upload proprietary metadata you're hosed :/
21:50:41 <sclv> what if i forward a "i hate you" email to my boss
21:50:41 <davean> next time you publish your password to github, check everywhere, even places like archive.org
21:50:45 <sclv> can i recall that email
21:50:46 <sclv> ban email
21:50:55 <EvanR> sclv: in outlook i think you can
21:51:00 <EvanR> "unsend"
21:51:01 <mgsloan> davean: True!
21:51:04 <sclv> no, you can ask that it gets recalled
21:51:19 <sclv> and then we all see the recall message as a plaintive sad cry
21:51:22 <sclv> along with the original
21:51:24 <EvanR> man email really is primitive, you cant unsend
21:51:59 <EvanR> record data needs to be time symmetrical for posterity
21:52:14 <EvanR> recording*
21:53:53 <sclv> btw, there _is_ a case for making new package uploads candidates-by-default and there's been some discussion of that
21:54:07 <sclv> its an ergonomics issue and UI question much more than a technical one
21:55:31 <mgsloan> Makes sense, especially because that way you could get build results when it tries to build the docs
23:06:51 * hackagebot opengles 0.8.2 - Functional interface for OpenGL 4.1+ and OpenGL ES 2.0+  https://hackage.haskell.org/package/opengles-0.8.2 (capsjac)
23:07:04 <lambda-11235> Anyone find it kinda funny that Haskell's "fix" *breaks* its consistensy as a logic system?
23:07:38 <dibblego> No.
23:14:36 <inad922> Hi
23:15:18 <inad922> What's the easiest way to create tags(ctags) with hasktags of the modules installed with cabal and the standard ghc distribution?
23:31:04 <mniip> hmm
23:31:28 <mniip> so this is what injective tyfams are for
23:32:04 <mniip> when a fundep'd mptc won't inline due to quantified variables
23:51:32 <erisco> how can you declare functions which are not in esqueleto's base set? for example, say my rdbms supports an 'average' function which I might type in Haskell as average :: Float -> Float -> Float?
23:51:51 <erisco> this is especially important for extensions
23:52:24 <erisco> I am not at all interested in portability, but I am interested in having a type checked embedded SQL language
23:53:10 <mniip> @let type family Id a = b | b -> a where Id x = x
23:53:10 <lambdabot>  Parse failed: Parse error: =
23:53:20 <mniip> aww shame
23:54:18 <erisco> @let type family Id a b | b -> a where Id x = x -- not that?
23:54:19 <lambdabot>  Parse failed: Parse error: |
23:54:39 <erisco> oh hm :P isn't | b -> a the new injective type family stuff?
23:55:23 <mniip> yup
23:55:37 <erisco> so lambdabot does not have this yet
23:55:53 <erisco> > fitler (+1) [1,2,3]
23:55:54 <lambdabot>      Not in scope: â€˜fitlerâ€™
23:55:55 <lambdabot>      Perhaps you meant one of these:
23:55:55 <lambdabot>        â€˜filterâ€™ (imported from Data.List),
23:55:59 <erisco> ah someone undefined it
23:56:15 <mniip> maybe that was me
23:56:42 <mniip> I came up with a neat idea but I dont have a compiler at hand
23:57:13 <erisco> are the injective families closed?
23:58:02 <mniip> they can be
