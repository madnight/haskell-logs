00:42:26 <Iceland_jack> k
00:42:35 <orion> l
00:46:35 * hackagebot Earley 0.11.0.0 - Parsing all context-free grammars using Earley's algorithm.  https://hackage.haskell.org/package/Earley-0.11.0.0 (OlleFredriksson)
00:54:27 <Zhell> Hi I am a beginner, how do I load my file.hs into `stack ghci`?
00:54:37 <Zhell> I want to test the function I've built
00:57:06 <Zhell> ah, found it `:load filename`
01:00:15 <quchen> Zhell: You can also use the shorter version :l
01:00:18 <michaelt293> you can do :l too .....a little shorter
01:01:00 <Zhell> thanks
01:06:36 * hackagebot regex-pderiv 0.2.0 - Replaces/Enhances Text.Regex. Implementing regular expression matching using Antimirov's partial derivatives.  https://hackage.haskell.org/package/regex-pderiv-0.2.0 (KennyLu)
01:06:38 * hackagebot haskintex 0.6.0.1 - Haskell Evaluation inside of LaTeX code.  https://hackage.haskell.org/package/haskintex-0.6.0.1 (DanielDiaz)
01:20:03 <marrrk> So I have this monad transformer stack which is EitherT ServantErr IO . In do notation how do I massage values into that shape? So let's say I have an Either ServantErr a
01:20:18 <marrrk> How do I get the a into IO and turn the whole thing into the actual transformer stack?
01:22:13 <lyxia> meretrix: EitherT? isn't it ExceptT
01:22:37 <lyxia> marrrk: ^
01:22:41 <marrrk> type Handler = EitherT ServantErr IO
01:23:20 <lyxia> well in any case you can look at the definition of EitherT
01:24:00 <lyxia> is that the one from the either package? it has hoistEither
01:24:34 <lyxia> but you can also build it by hand with the constructor: EitherT . return
01:27:47 <marrrk> hmm okay
01:27:50 <marrrk> and to get something into IO?
01:28:42 <lyxia> I'm not sure what you mean. return?
01:30:09 <marrrk> probably yeah
01:30:12 <marrrk> Okay I got to go
01:30:16 <marrrk> Thank you for your hlep
01:30:17 <marrrk> help
02:00:16 <Zhell> Hi, I am trying to solve the first exercise of CIS194. `toDigitsRev x = (x `mod` 10):(toDigitsRev (x `div` 10))
02:00:59 <Zhell> I honestly don't know how to solve the normal toDigits without resort to using the ++ operator to append to the list, but the first chapter doesn't include this operator at all.
02:01:28 <Zhell> could you give me some hints?
02:01:38 <Zhell> please.
02:01:52 <Rembane> Zhell: What's the exercise? Do you have a link?
02:01:57 <Zhell> http://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
02:02:29 <Zhell> this is the chapter
02:02:30 <Zhell> http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
02:03:07 <angerman> Zhell how about using : ?
02:03:25 <mniip> Zhell, you can implement toDigits using toDigitsRev
02:03:54 <Zhell> hmm
02:06:55 <funrep> maybe i just come to this question since i don't understand lambda calculus, but what's the point of ycombinator when ucombinator ( \f.f(f) ) is so much simpler?
02:08:49 <Zhell> mniip, you mean with like a helper function to deconstruct toDigitsRev and somehow reverse the list?
02:09:08 <Zhell> mniip, then just make toDigits use this helper function.
02:09:42 <Zhell> I must be really stupid, because I still don't see how. lol
02:10:03 <mniip> well, I'm not really sure what the exercise intended you to do,
02:10:08 <mniip> but I would just use 'reverse'
02:10:32 <ggole__> funrep: for one thing, assigning a type to that combinator needs recursive types
02:10:58 <Zhell> mniip, that's not allowed. Since it is not in the first chapter :(
02:11:11 <lyxia> funrep: Is it also simpler to program with
02:11:36 <mniip> Zhell, well you could do the reverse list generation pattern
02:11:42 <lyxia> or did you really mean simpler syntactically only, which is kind of poor
02:11:49 <mniip> where you have a helper function that carries an extra argument
02:12:01 <mniip> which is initially [], but gets prepended to, as you recurse
02:12:09 <mniip> and then in the last iteration it is the value that you return
02:12:16 <Zhell> mniip, hmm, but. That's what I tried doing
02:12:35 <Zhell> mniip, helper_reverse (x:xs) = x:(helper_reverse xs)
02:12:45 <mniip> that does nothing
02:13:01 <Zhell> yes indeed
02:13:08 <Zhell> but if I could 'append' it would
02:13:22 <mniip> well that has nothing to do with what I just said
02:13:47 <mniip> instead of appending to the list, you generate it from the end
02:14:05 <mniip> you should, that is
02:14:24 <Zhell> hmm, I haven't learned how to carry an entire array throughout the entire iteration just yet, though
02:14:33 <mniip> array?
02:15:08 <Rembane> Zhell: It's a linked list.
02:15:50 <Zhell> Sorry I meant Linked LIst
02:16:03 <Zhell> it is just a mnemonic for me
02:16:43 <Rembane> Zhell: They work quite differently. :)
02:17:28 <Zhell> yep I know
02:19:21 <Zhell> Sorry, got interrupted
02:20:10 <Zhell> I meant I haven't learnt how to carry a parameter across all the iterations
02:21:41 * hackagebot language-javascript 0.5.14.5 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.14.5 (ErikDeCastroLopo)
02:22:52 <Rembane> Zhell: Send it as an argument to your recursive function
02:22:53 <funrep> ggole: lyxia: interesting, i will probably need to investigate this further to understand what a recursive type means
02:22:59 <mniip> Zhell, you are already doing that
02:24:18 <merijn> Recursive type? Are we talking Mu (aka Fix) or Free?
02:25:27 <funrep> merijn: talking lambda calculus here (maybe Mu and free is still relevant but i don't know what those are so not sure)
02:26:26 <mniip> omega :: Fix (Cont r) ?
02:26:53 <mniip> no wait, omega : Fix (Op r)
02:27:26 <ggole> That's hiding the necessary recursion behind a type constructor
02:27:53 <ggole> With recursive types you expose it directly
02:28:05 <ggole> And without recursive types at all, you can still get away with Y.
02:28:07 <merijn> funrep: Haskell doesn't (directly) support recursive types, i.e. it only supports those when hidden behind a newtype Mu and Free are the most common uses
02:28:39 <merijn> So Mu and Free would at least be instructive about what sort of recursive types are actually useful
02:29:19 <ggole> Well, data types sort of include-but-hide recursive types, and they are very useful
02:29:48 <ggole> Haskell programmers can mostly ignore this, but it does make sense to consider it if you are studying a typed lambda calculus.
02:30:15 <funrep> alright
02:31:42 * hackagebot hedis 0.7.8 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.7.8 (k_bx)
02:32:33 <merijn> funrep: "newtype Mu f = Mu (f (Mu f))" and (simplified) "data Free f a = Pure a | Free (f (Free f a))"
02:32:53 <merijn> Mu is basically "fix", but on the type level :)
02:35:13 <funrep> i see :)
02:37:53 <ggole> I think you only really need recursive types directly if you start doing structural things
02:38:25 <ggole> As in typing the OCaml function let rec test = function `Foo x -> test x | y -> y
02:57:48 <W4RH4WK> can stack be used to install a dynamic library, or only executables?
03:02:58 <Zhell> hmm, I really don't understand how to start from the bottom of the recursion
03:03:30 <Zhell> only the first element
03:03:30 <Zhell> helperReverse (x:[]) (y:ys) = y:[]
03:03:57 <Zhell> for, helperReverse [1,2,3,4] [1,2,3,4]
03:04:58 <Zhell> oh no that's wrong
03:04:59 <Zhell> :/
03:11:32 <Zhell> How can I just reverse a list in haskell?
03:11:37 <Zhell> without the function
03:11:49 <Zhell> `reverse`
03:11:59 <Rembane> Zhell: With the reverse function in Data.List
03:12:06 <Zhell> without it
03:12:31 <dogui> Zhell: foldl (flip (:)) []
03:12:47 <Zhell> hmm, without that as well, the most basic of basics
03:13:32 <Zhell> just using :, [], no auxiliary functions
03:13:41 <dogui> reverse [] = []; reverse (x:xs) = reverse xs ++ [x] ?
03:13:49 <dogui> Zhell: then take an extra argument and buidl the result there
03:13:54 <Zhell> except ++ because that's appending
03:13:54 <dogui> Zhell: essentially what foldl does
03:14:00 <ggole> Write the left fold by hand?
03:15:45 <Zhell> dogui, How am I suppose to know how to write a foldl `http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html`
03:15:50 <Zhell> dogui, from this information alone?
03:17:01 <ggole> let rev = go [] where; go acc [] = acc; go acc (x:xs) = go (x:acc) xs
03:17:10 <ggole> Although where isn't mentioned
03:17:10 <merijn> I wouldn't use foldl as a complete beginner
03:17:23 <merijn> I'd use the "naive" solution dogui proposed
03:17:37 <ggole> You could write it as a separate top-level function, I suppose
03:18:07 <Zhell> there's one way for me to write, toDigits by calculating how many digits a number contain and then just diving it by 10^(digits), then (digits--) for each iteration
03:18:17 <Zhell> but that seems naive as well
03:19:04 <Zhell> merijn, the chapter hasn't covered `++` :(
03:19:24 <Zhell> ggole, neither what you proposed
03:20:08 <Zhell> `++` is very slow as well given that it is a linked list (I guess)
03:21:06 <merijn> Yes, the best way would be to use a DList, but given that you're in lecture 1, that seems a bit too advanved to throw in :p
03:22:26 <Akii> Zhell: you're at the toDigits excercice?
03:23:52 <Zhell> Akii, yes. I figure, I'd just make a `numberOfDigitsInInteger` function and use that approach to know how many times to divide by ten and use modulo to capture the last digit.
03:24:37 <Akii> this is definitely the right direction, however you don't need to know how many times to divide
03:24:38 <Zhell> Akii, but reversing isDigitsRev, would be so much easier
03:24:48 <Akii> oh well I actually did that
03:24:57 <Akii> does it say that you shouldn't? :D
03:25:00 <Zhell> Akii, that's cheating unless you can do that (somehow?)
03:25:08 <Akii> dang it :D
03:25:27 <Akii> there is a repo on GH with the solutions btw, just found it today
03:25:38 <Akii> only for verification of course :D
03:25:47 <Zhell> I am afraid of looking at solutions, it makes me feel weaker, lol
03:26:12 <Akii> well I just couldn't figure some things out
03:26:19 <Zhell> no I don't mean that
03:26:35 <Akii> you mean because the solution is probably more elegant?
03:26:35 <Zhell> I mean I look at their solution, and then I look at the crap I created
03:26:39 <Akii> haha :D
03:26:58 <Akii> but that's an important lesson as well
03:27:04 <Zhell> That is true.
03:27:25 <Akii> and even better if you find that their solution is exactly yours
03:27:35 <Akii> had that in one case, felt good :D
03:27:51 <Zhell> hehe, where is this repo?
03:27:55 <Zhell> :D
03:28:26 <Akii> https://github.com/BerndSchwarzenbacher/cis194-solutions
03:28:58 <Zhell> Akii, thank you
03:29:03 <Akii> np :D
03:29:11 <Akii> this course is really hard (for me)
03:29:14 <Akii> but surely rewarding
03:30:07 <Zhell> We didn't travel to the moon because it was easy...
03:30:09 <Zhell> :)
03:30:15 <Akii> well said
03:40:39 <Zhell> Akii, http://sprunge.us/NgED
03:40:46 <Zhell> \o/
03:41:14 <Akii> not bad :D
03:41:15 <Zhell> toDigitsHelper 1234 4 = [1,2,3,4]
03:41:50 <Zhell> Akii, thanks, now I feel content.
03:45:24 <Zhell> may I add assertions like small unit tests in my file, so when I load it with `stack ghci` `:l myfile.hs` it can report back if it was successful or not?
03:45:51 <Zhell> e.g: assert (toDigit 1234 == [1,2,3,4])
03:49:19 <lyxia> you can put them in a toplevel binding at the cost of an extra command after loading the file
03:51:32 <sveri> Hi, I am new to haskell. I managed to write a function and tests for it. Now I want to iterate with another function and another test. My idea was to put the new test into a different test file, but looking at my projects cabal file I see that I can define only one `main-is`, whatever is means here. Running `stack test` also only executes the test of one file. How do I add more test files to the `main-is` declaration?
03:51:57 <Zhell> lyxia, can you give me an example, please? Like I wouldn't mind one extra command. e.g executing unitTestExecute function, but how do I stack up functions within a function?
03:52:26 <Akii> I'd be interested too
03:53:18 <merijn> sveri: "main-is" means "the file that has "main", it doesn't make sense to have more than one file with main
03:53:40 <merijn> sveri: That's like having a C program with multiple main functions. Perhaps you're wanting to build a library, rather than an executable?
03:53:45 <lyxia> Zhell: define a value tests :: IO () that reports which tests failed, or even tests :: () using assert, which evaluates to () if tests pass, raises an exception otherwise
03:55:02 <sveri> merijn: Ok, that makes sense. My idea was to split different tests into different files, I guess this is a common idiom?
03:55:54 <merijn> sveri: Well, you either want a library build up of multiple modules, or multiple executables. But it's hard to say which is best for you, since I don't quite understand the problem, plus I don't use stack
03:59:01 <sveri> merijn: Seems like stack only generates the first cabal file
03:59:12 <Zhell> lyxia, but how may I stack several functions?
03:59:29 <lyxia> Zhell: I'm not sure what you mean. What do you have now
03:59:32 <Zhell> lyxia, http://sprunge.us/jhcQ
04:00:13 <lyxia> Zhell: ah, replace commas by dots and append "$ ()" to it
04:00:31 <Zhell> lyxia, where should I append "$ ()"?
04:01:01 <Zhell> $ has to do with precedence iirc
04:01:20 <lyxia> Zhell: put it right below the last test
04:01:35 <lyxia> oh your assert is different
04:01:45 <lyxia> I was thinking of Control.Exception.assert
04:01:55 <Zhell> lyxia, http://sprunge.us/YdZK
04:02:08 <Zhell> Sorry, I am very new to haskell.
04:02:19 <lyxia> no worries
04:02:22 <Zhell> I just need to know how to stack asserts
04:02:42 <lyxia> let me lpaste it
04:04:48 <lpaste> lyxia pasted “to Zhell” at http://lpaste.net/154997
04:04:50 <Zhell> oh wait
04:05:09 <Zhell> I can just use guards to accomplish what I want
04:05:23 <lyxia> or that yes
04:05:28 <Zhell> lyxia, thanks
04:05:46 <Akii> but this solution composes, guards don't or am I missing something
04:06:29 <lyxia> I'd say appending && (other test) is a composable solution.
04:07:43 <Darwin226> Hey, anyone know when the GHC8 release can be expected?
04:09:06 <Wizek> Is it possible to do forkIO in such a way that it survives even after the parent thread is done?
04:11:18 <hc> Wizek: that's normal behaviour; however, you'll need to keep the initial thread alive
04:11:28 <Zhell> lyxia, http://sprunge.us/RbWj
04:11:33 <Zhell> lyxia, what am I doing wrong here?
04:11:51 <lyxia> | otherwise
04:11:52 <Zhell> lyxia, sorry, http://sprunge.us/FaRA
04:11:58 <lyxia> you don't need assert
04:12:10 <lyxia> guards just expect a boolean
04:12:22 <Zhell> lyxia, the assert is defined as boolean, http://sprunge.us/FaRA
04:12:46 <lyxia> there is the | before otherwise missing
04:13:18 <lyxia> this assert is just "not"
04:13:18 <Zhell> lyxia, thanks now it works
04:15:06 <lyxia> Wizek: wait for the children thread
04:16:29 <lyxia> concurrency terminology could have been so cute...
04:19:14 <Zhell> Akii, http://sprunge.us/JJjM
04:20:25 <Akii> not bad
04:20:39 <Akii> this is later taken to the next level when you start doing property based testing
04:25:22 <Akii> lyxia: lol
04:31:47 <quchen> Darwin226: "Soon"
05:08:03 <UrbK> is the Show typeclass suppose to be:
05:08:19 <UrbK> read . show?
05:08:48 <UrbK> as in, is show supposed to output a string which can be converted back with read?
05:09:05 <bergmark> there's not a consensus on that
05:10:56 <quchen> UrbK: I think it's best practice to implement Show according to the guidelines given for derived instances. http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#t:Show
05:11:23 <quchen> In particular, "The result of [derived] show is a syntactically correct Haskell expression containing only constants".
05:13:15 <merijn> In practice it's expected that show and read are inverses AND valid haskell
05:13:29 <merijn> Hence why you should use something else when pretty printing
05:14:30 <greg`> silly question but how does one add a stack dependency to a stack project
05:14:50 <greg`> is it enough to do stack build {projectname} from within the project
05:14:58 <greg`> or must one edit the stack.yaml?
05:15:09 <cocreature> most importantly you must edit the cabal file
05:15:27 <cocreature> if it is not in stackage you also need to add it to extra-deps in stack.yaml
05:15:45 <greg`> will stack not edit the cabal file if you do a stack build?
05:16:02 <cocreature> no, stack never edits your cabal file afaik
05:16:45 <greg`> thanks
05:24:47 <T0BI> hi
05:30:28 <ij> irc-client's "start" sends out USER, NICK and then starts event loop. How could I make it send some messages inbetween USER and the event loop? 
05:36:49 * hackagebot hint 0.5.1 - Runtime Haskell interpreter (GHC API wrapper)  https://hackage.haskell.org/package/hint-0.5.1 (mvdan)
05:36:51 * hackagebot streaming-bytestring 0.1.4.2 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.4.2 (MichaelThompson)
05:45:18 <ironChicken> i'm chasing this segfault in my ghc-compiled program that uses a foreign library
05:45:30 <ironChicken> i have a mallocForeignPtr on which i then do unsafeForeignPtrToPtr in order to get a pointer to put into a field which is then poked into a struct in the C library
05:45:51 <ironChicken> i implemented that a while ago and it has been working fine
05:46:18 <merijn> ironChicken: o.O
05:46:21 <Freundlich> ironChicken: Depending on the rest of your application, the foreign ptr could be garbage collected right away.
05:46:40 <merijn> Or really, the foreignptr can be garbage collected whenever while this poitner is in your struct
05:46:49 <ironChicken> i've just been adding some touchForeignPtr calls
05:46:51 <merijn> How did you ever think that was going to work?
05:47:07 <ironChicken> :-(
05:47:10 <ironChicken> dunno
05:47:14 <merijn> ironChicken: What happens when the ForeignPtr is GCed, the malloced memory is freed and you C struct still has that pointer in it?
05:47:23 <Freundlich> The easiest way to fix this in your Haskell application is to use something like bracket.
05:47:34 <merijn> No, that won't help
05:47:47 <merijn> I'm assuming it's segfaulting in the C code when it tries to use said struct
05:48:11 <merijn> If you're storing a pointer in a struct you have to make sure it doesn't get freed while someone is using that struct
05:48:22 <ironChicken> if i generate lots of debugging output and write to the terminal it runs without segfaulting
05:48:26 <merijn> So it depends on what your program/the C code is doing with said struct
05:48:27 <Freundlich> And bracket is an easy way to do that.
05:48:32 <Freundlich> Usually...
05:48:55 <merijn> Freundlich: Bracket will enforce freeing after the FFI call is done, but if the pointer is stored then that doesn't help
05:49:26 <Freundlich> merijn: I mean something like whileThePtrNeedsToBeAlive f = bracket allocPtr freePtr f
05:49:27 <merijn> You need to prevent it being freed until that pointer is no longer stored. And the best way to do that depends on what your program/C code is doing
05:49:38 <Freundlich> Then your code can use said ptr in f.
05:49:41 <merijn> Freundlich: You're assuming the lifetime is related to the code
05:49:45 <Freundlich> I do. :/
05:49:58 <merijn> Freundlich: Consider the fact that storing in a struct might leave it in that struct after 'f' returns
05:51:14 <ironChicken> i've been thinking of trying to re-factor such that my record type uses a non-pointer, and perhaps the poke implementation can be responsible for extracting a pointer at the last minute
05:51:34 <merijn> ironChicken: You need to describe what your C code is doing
05:51:44 <merijn> Else we're just taking blind guesses when suggesting solutions
05:51:56 <ironChicken> merijn: yes, but when i try and add debugging printfs it fails to segfault
05:52:14 <merijn> Welcome to the world of memory corruption
05:52:21 <Freundlich> Try to describe it on a higher level.
05:53:48 <ironChicken> um
05:56:27 <browstki> Hello everybody, I could need some help on Problem 9 from '99 Haskel problems'
05:56:59 <browstki> I am trying to make a function that uses pattern matching as follows:
05:57:09 <browstki> pack (x1:x2:xs)
05:57:09 <browstki>  | x1 /= x2 = [x1] : pack (x2:xs)
05:57:09 <browstki>  | x1 == x2 = [[x1, x2]] ++ pack xs
05:57:59 <browstki> However, this only works on two duplicate consecutive elements, not on multiple ones
05:58:38 <ironChicken> the function i'm calling is this one <https://github.com/TransformingMusicology/libaudioDB/blob/master/src/query.cpp#L25>, the struct i pass to it is one of these <https://github.com/TransformingMusicology/libaudioDB/blob/master/include/audioDB/audioDB_API.h#L117>, and the foreignPtr i'm fiddling with at the moment is a pointer to one of these
05:58:38 <ironChicken> <https://github.com/TransformingMusicology/libaudioDB/blob/master/include/audioDB/audioDB_API.h#L26>.
05:58:51 <ironChicken> this, of course, is not a high-level description of my problem, so don't worry; i'll just get on with it.
05:59:17 <ironChicken> no, in fact, i'm going to get some lunch :-)
06:05:55 <lyxia> browstki: think about the result of the recursive call to "pack xs" and what you can do to modify it to get the result of "pack (x1:x2:xs)"
06:10:47 <browstki> lyxia: do you mean the call to " pack xs " in the 2nd guard? I thought my problem lies in " [[x1, x2]] "
06:13:40 <lyxia> Yes I do. Sure but you're not going to fix it by just appending something else to pack xs.
06:14:09 <lyxia> another solution is to use span
06:14:27 <lyxia> or to simply look at the implementation of group...
06:14:34 <lyxia> (which is what you are trying to do)
06:14:51 <joeyh_> https://ghc.haskell.org/trac/ghc/wiki/TypeNats/Basics says that GHC.TypeLits implements singletons. But I can't find eg, sing in there. Is that documenting a newer ghc than 7.10?
06:16:17 <joeyh_> hmm, I think that page is actually well out of date
06:16:46 <quchen> joeyh_: Such pages usually help documenting the development of extensions, not the final state
06:17:01 <quchen> The GHC wiki has this dual role of being a scratchpad and a source commentary
06:17:59 <joeyh_> so they were going to build singletons into base, but it got able to be implemented externally (in eg, the singletons package)
06:18:26 <browstki> lyxia: ok thankks, gonna take a look at that. I know about span, But I am  trying to not use library functions
06:23:19 <Ainieco> hello
06:23:35 <tnsmith> hi!
06:24:35 <Ainieco> what are truly original ideas haskell has? i mean not something that already has been present in simpsons^W ML
06:27:46 <browstki> lyxia: I have another question.. The implementation of groupBy in Data.List uses span, but where can I find the implementation of span? It does not seem to be in the Data/List.hs
06:28:03 <Ashy> Ainieco: "Avoid success at all costs."
06:29:28 <merijn> Ainieco: Typeclasses
06:29:40 <merijn> Ainieco: There's also all the extensions stuff in GHC
06:30:02 <merijn> Ainieco: I.e., support for RankN types (don't think ML has those), not sure about ML and GADTs either
06:30:05 <Axman6> Ainieco: there's plenty of things which are much more elegantly expressed in haskell due to its type system. the first one which comes to mind are lenses, which are nice in haskell because of typeclasses
06:30:16 <merijn> Ainieco: The whole type families/dependent haskell stuff is kinda neat
06:30:31 <merijn> Ainieco: But if you're an MLer and wanna explore that stuff Idriss and Agda might be more up your alley
06:30:36 <lyxia> browstki: it's also in there
06:31:26 <merijn> Ainieco: Oh, and of course the notions of Functor/Applicative/Monad really shine in the presence of typeclasses, which is a lot more cumbersome in ML (note, my only ML experience is some very basic ocaml)
06:32:18 <Ainieco> merijn: dependent types and type families were present in coq for ages, it doesn't counts
06:32:23 <ggole> "Not in ML" and "truly original in Haskell" are very different
06:33:29 <merijn> Ainieco: Coq is hardly ML
06:33:39 <Ainieco> ggole: i meant the latter one, ml was a joke, it's known that haskell been influenced by ton of other PLs(inlcuding ML), that's why i'm asking
06:34:05 <merijn> Ainieco: I'd say the Applicative/Monad stuff and typeclasses are the main truly unique things, well, that and laziness
06:34:28 <ggole> There were lazy languages before Haskell, like Miranda 
06:34:31 <Ainieco> merijn: laziness is not unique
06:34:39 <merijn> ggole: Was Miranda pure?
06:35:01 <Ainieco> but i got it re Monad/Applicative, good point, haven't seen those before haskell anywhere in PLs
06:35:06 <merijn> I thought Haskell was the first lazy language that was purely functional?
06:35:17 <ggole> I don't think it was
06:35:38 <Axman6> Ainieco: if you're looking for a fight, which you seem to be, you will have better luck elsewhere
06:36:03 <merijn> Ainieco: Wadler popularised them as a solution for IO and State, because laziness with side-effects was very problematic (although the idea didn't get "discovered") until Haskell 1.4 I think? Not sure, maybe earlier
06:36:16 <browstki> lyxia: ok found it in GHC/List.lhs, not Data/List.hs. maybe i was on an outdated site..
06:36:18 <ggole> No, apparently it was. I was probably thinking of Hope or something like that.
06:37:09 <Ainieco> merijn: cool, thanks for info
06:37:44 <lyxia> browstki: oh I see. I just clicked on the "source" link next to http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:span
06:37:56 <lyxia> didn't see it took me to GHC.List
06:38:41 <merijn> Ainieco: "Monads for Functional Programming" by Wadler is the original paper you want, very readable
06:39:03 <merijn> Applicative, surprisingly wasn't discovered until 2004 or so
06:39:15 <merijn> I forget the paper, but pretty sure it was McBride and some others
06:39:30 <Akii> nice
06:40:23 <Ainieco> merijn: much appreciated for paper, yeah i know re applicative, but applicative is superclass of monad now, at last
06:41:22 <Ainieco> can't wait for ghc8 and overloaded fields, so many delays, sigh
06:57:06 <Ainieco> Due in 7 days (Mar 25, 2016 12:00:00 PM) i guess that means mid april
06:59:50 <lokien_> Hey guys, have you seen stack overflow survey? Why is Haskell dropping in popularity so much? 
07:01:47 <ggVGc> maybe people started writing it instead of talking about it
07:02:17 <opqdonut> :)
07:02:31 <hpc> everyone's learned it already
07:02:36 <hpc> no more questions left to ask
07:02:36 <hpc> :P
07:03:03 <ggVGc> good ting haskell is so stable
07:03:16 <marrrk_> So how do I massage this: Couldn't match expected type ‘EitherT ServantErr IO ByteString’ with actual type ‘Either ServantErr (IO ByteString)
07:03:30 <hpc> honest answer: as haskell progresses the questions that are most relevant to it get increasingly asked in the CS/math stack exchanges?
07:03:34 <hpc> numbers on that would be interesting
07:05:17 <marrrk_> Or actually this: expected: EitherT ServantErr IO ByteString and actual: Either ServantErr ByteString
07:06:58 <suppi> I hardly ever use SO for Haskell. When I used Java I had to use it all the time
07:07:21 <suppi> even if I had questions, asking here or in reddit is simpler
07:08:36 <hpc> heh, that'd be pretty funny if that mentality is widespread enough to be true
07:08:43 <hpc> that our community is better than SO at solving problems
07:09:25 <byorgey> marrrk_: EitherT . return :: Either ServantErr ByteString -> EitherT ServantErr IO ByteString
07:09:52 <byorgey> marrrk_: EitherT e m a  is a newtype around   m (Either e a)
07:09:57 <marrrk_> are there many returns?
07:10:04 <marrrk_> With different inputs?
07:10:16 <marrrk_> And they will all yield the correct MT stack?
07:10:32 <byorgey> marrrk_: I just meant that the expression  EitherT . return   has that type
07:10:37 <byorgey> you don't have to write the type
07:11:16 <byorgey> so if you have an  Either ServantErr ByteString  but you want an  EitherT ServantErr IO ByteString, you can apply  (EitherT . return)
07:11:25 <marrrk_> Yeah, but I was wondering why it has that type. Why does the input not have any IO and what if I already had something wrapped in IO. Could I then not use return or is return "overloaded"?
07:11:36 <byorgey> return is overloaded.
07:11:40 <byorgey> :type return
07:11:44 <byorgey> @type return
07:11:46 <lambdabot> Monad m => a -> m a
07:11:53 <byorgey> it works for any Monad.
07:12:42 <byorgey> hmm, but maybe you are asking what to do with  Either ServantErr (IO ByteString) ?  That is a little different
07:13:22 <byorgey> in that case you can write   EitherT . sequence
07:13:38 <suppi> what is the difference between EitherT and ExceptT ?
07:15:11 <byorgey> suppi: good question.  I forget.
07:16:12 <suppi> :0
07:16:14 <suppi> :)
07:25:36 <marrrk_> Yeah, okay so it's not that easy :)
07:27:16 * hackagebot autoexporter 0.1.4 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-0.1.4 (fozworth)
07:32:16 * hackagebot flow 1.0.4 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.4 (fozworth)
07:37:18 * hackagebot lackey 0.1.2 - Generate Ruby consumers of Servant APIs.  https://hackage.haskell.org/package/lackey-0.1.2 (fozworth)
07:37:28 <xa0> :t let f g (x,y) = (g x, g y) :: (forall a. a -> b) -> (x, y) -> (b, b) in f
07:37:30 <lambdabot>     Couldn't match expected type ‘(forall a. a -> b2)
07:37:30 <lambdabot>                                   -> (x2, y2) -> (b2, b2)’
07:37:30 <lambdabot>                 with actual type ‘(t3, t3)’
07:43:26 <jophish> Is Hackage down?
07:47:48 * hackagebot ratel 0.1.2 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-0.1.2 (fozworth)
07:47:50 * hackagebot ratel-wai 0.1.1 - Notify Honeybadger about exceptions via a WAI middleware.  https://hackage.haskell.org/package/ratel-wai-0.1.1 (fozworth)
07:47:52 * hackagebot strive 2.2.1 - A client for the Strava V3 API.  https://hackage.haskell.org/package/strive-2.2.1 (fozworth)
07:50:42 <jackhill> jophish: I can browse packages from here.
07:56:50 <xoitx> any haskell guides out there?
07:57:15 <xoitx> Can haskell be used to code AI?
07:57:33 <sm> nah, it's self-explanatory
07:57:37 <xoitx> I find the whole stateless concept very appealing
07:58:15 <xoitx> its almost static yet dynamic
07:58:24 <xoitx> seems worth exploring
07:58:42 <xoitx> just got to know about haskell
07:58:46 <xoitx> :D
07:59:37 <suppi> xoitx, www.haskellbook.com or https://github.com/bitemyapp/learnhaskell I think
08:02:48 * hackagebot octane 0.4.2 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.2 (fozworth)
08:06:42 <jmatsushita> "I love stateless systems." "Don't they have drawbacks?" "Don't what have drawbacks?"
08:10:45 <NaOH> hey there, quick question: If I have a type "data A a = B [[a]] Int | C [[a]] Int" and I want to define a function that doesn't care about B or C, it just acts on the double list [[a]] of any A a, is there a way to do it without pattern matching against the constructors B or C ?
08:11:40 <Ainieco> jmatsushita: lol
08:11:45 <NaOH> I mean, I could do f (B xs n ) = B (something xs) n    and f (C xs n) = C (something xs) n
08:12:09 <NaOH> but is there a way to avoid that?
08:12:42 <NaOH> (as the f is doing the exact same thing on either B or C, but evaluating the corresping constructor)
08:14:06 <Ainieco> NaOH: no, i don't think you can
08:14:36 <bergmark> NaOH: you can do it with GHC Generics
08:14:56 <lyxia> why don't you define it as ([[a]], A') and A' = B Int | C Int instead
08:16:22 <NaOH> lyxia: the thing is, for this particular function I dont' care if it's a B or a C, but in other functions I do care
08:16:54 <NaOH> bergmark: I will look into GHC Generics then
08:22:31 <amf> with +RTS -M256M, im seeing my server's memory slowly increase until i get a heap exhaustion and this: "internal error: wakeup_gc_threads". google doesnt shed much light on this error. any hints for getting around this?
08:23:50 <__brian__> ?src (reverse)
08:23:50 <lambdabot> Source not found. There are some things that I just don't know.
08:27:24 <merijn> Is there a library like async, but instead of for terminating tasks with a result it's for constructing trees of long running threads? i.e. like erlang' supervisor stuff
08:28:10 <merijn> Hacking together my own cleanups with exceptions is nasty :\
08:35:31 <cocreature> merijn: if you find one, please tell me about it :)
08:37:56 <aerialB> https://gist.github.com/TiredSounds/176547120e9f03fd2c33 could someone tell me a better way to do this? I don't like the repetition
08:39:37 <xa0> so guys
08:39:56 <xa0> what do you think is the next extension that will make it into the language?
08:40:49 <m1dnight_> When using alex/happy. I have a token "All" (forall) which get tokenized as a Type variable ( TkTypeVar) instead of the TkForAll token.
08:41:06 <m1dnight_> In Alex the "All" rule is above the TkTypeVar rule. What else could cause this..?
08:41:43 <m1dnight_> https://www.refheap.com/116113 <- that is the entire parser
08:42:49 <m1dnight_> Lexer*
08:42:50 * hackagebot git-annex 6.20160318 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160318 (JoeyHess)
09:01:05 <xoitx> siri with haskell :O
09:01:14 <mightybyte> New Compose video just posted: https://www.youtube.com/watch?v=BHjIl81HgfE
09:01:35 <mightybyte> "Add a type parameter! One 'simple' design change, a panoply of outcomes"
09:07:20 <lambda-11235> m1dnight_: There's no TkTypeVar in the code you posted. Additionslly, All correctly lexes as TkForAll.
09:19:37 <tyho> Is it possible for me to overide the show method of a type synonym of a tupel?
09:20:10 <shachaf> No.
09:20:16 <Cale> tyho: no, type synonyms are not actually different types
09:20:34 <Cale> The type system will treat them in every way identical to the original type, it's just an alias.
09:20:53 <tyho> so can i overide the default show method on the tuple then?
09:20:58 <Cale> Nope
09:21:07 <ggole> You can wrap it in a newtype.
09:21:15 <tyho> only on algibraic types?
09:21:23 <Cale> Yeah, with a newtype, you could make a new instance
09:21:26 <tyho> ggole, how?
09:21:50 <Cale> But you usually wouldn't do this, because show is intended to produce a useful code representation of the thing for debugging
09:22:15 <ggole> newtype T = T (a, b, c) and then write an instance for T as usual.
09:22:40 <tyho> yeah, and say i had a big tuple, and wanted it to show with some custom formatting, there is no obvious way to do it?
09:23:01 <Cale> tyho: Given that you want custom formatting, I wouldn't use show at all.
09:23:18 <Cale> Write a prettyprinter of some sort, and just keep it separate from show
09:23:22 <geekosaur> also, if you have a big tuple, you probably want an ADT anyway
09:23:49 <tyho> Thanks :-)
09:24:00 <Cale> You typically want show to produce something that can be easily copy/pasted as Haskell source code.
09:32:58 <sbrg> So what's the FOTM in logging libraries? I read about katip, but it seems a bit overkill for what I want to do. monad-logger looks decent. but I'd like to explore my options, etc. 
09:40:25 <DavidNcl> Is this a good place to ask about getting set up with haskell-mode in emacs?
09:42:06 <suppi> DavidNcl, sure
09:44:42 <DavidNcl> Ok cool. I'm on mac os, with emacs 25.51. I've install haskell-mode via M-x package-install RET haskell-mode and it's working to the extent that it fontifies haskell souce
09:45:22 <DavidNcl> I can run a haskell repl at the shell with 'stack ghci' 
09:45:41 <DavidNcl> but I cant figure out how to start a repl from within emacs
09:46:24 <DavidNcl> doing C-c C-l tells me to setup a haskell interaction mode
09:46:47 <DavidNcl> cant find out how to do that
09:52:57 <tippenein> Is there a mechanism for mapping show over the constructors of a data type?
09:53:27 <tippenein> data Thing = Derp | Stuff  ... map show Things => ["Derp", "Stuff"]
09:53:41 <dedgrant> DavidNcl: haskell-interactive-bring is giving you this error?
09:54:10 <c_wraith> tippenein, if you have your type implement Enum, it's sane enough. 
09:54:45 <c_wraith> tippenein, since that will make it easy to get a list of values of that type. 
09:55:05 <suppi> DavidNcl, there are more haskell apps you need to install for it to work I think
09:56:18 <DavidNcl> C-c C-l is bound to inferior-haskell-load-file 
09:56:27 <suppi> DavidNcl, have you seen this? https://github.com/haskell/haskell-mode/wiki
09:58:22 <tippenein> c_wraith: sounds about right. I'll mess with that. I assume Generics can derive that for me
09:58:30 <dedgrant> tippenein: further to what c_wraith said if you also derive bounded then you can [minBound :: Thing ..] to cover the range of values.
09:58:45 <DavidNcl> @suppi yes, specificaly this bit https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Compiling#load-into-ghci
09:58:45 <lambdabot> Unknown command, try @list
09:58:50 <c_wraith> tippenein, actually, it's just a standard class ghc can derive without extensions 
09:59:04 <DavidNcl> @suppi was what made me ask for help
09:59:04 <lambdabot> Unknown command, try @list
09:59:53 <c_wraith> tippenein, and the code would look like.. map show [FirstConstructor ..]
10:00:00 <suppi> DavidNcl, did you try M-x haskell-interactive-bring?
10:00:12 <DavidNcl> no
10:00:16 <DavidNcl> I will now
10:00:24 <c_wraith> tippenein, that space after the constructor name is important. :) 
10:00:53 <suppi> DavidNcl, https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Setup
10:02:03 <DavidNcl> ok.. you see that list of elisp (require ... )? I suppose they're meant to go in .emacs, but where?
10:02:54 <DavidNcl> also haskell-interactive-bring seems to start a repl, but it's unresponsive
10:03:05 <DavidNcl> I can type 2+2 RET and nothing happens
10:03:35 <suppi> DavidNcl, maybe put it at the end of the .emacs file?
10:03:52 <statusfailed> How do I use Data.Map.Strict.alter when my "altering" function has side effects?
10:04:02 <suppi> DavidNcl, did it load and give you a "welcome message" ?
10:07:43 <DavidNcl> Ok... got to walk dog. You've given me some stuff to try, thanks.
10:16:45 <dmj`> anyone know why my in-place quicksort w/ unboxed mutable vectors is so slow? http://lpaste.net/155008
10:16:50 <dmj`> :(
10:17:39 <dmj`> on collections of 1k elements it takes seconds, Data.List.sort takes microseconds
10:17:46 <black0range> Hey! Using emacs flycheck-haskell how do i make ghc-mod know whats the root? 
10:17:54 <puregreen> has anybody already written something to make SafeCopy migrations easier? e.g. I want to be able to just specify “[DeletedField "created", NewField "modified" [|someexpr|]]” instead of copying the datatype and assigning everything manually
10:18:55 <aznashwan> black0range: not that easy; best route is to revert to the version of ghc-mod which didn't rely on being run in the root of the project...
10:19:55 <c_wraith> dmj`, are you running it on already sorted input? 
10:20:11 <black0range> aznashwan: Hmm what version may that be?
10:20:23 <c_wraith> dmj`, that implementation will be O(n^2) on sorted input. 
10:21:41 <aznashwan> black0range: i'm using 5.3.0, but anything pre 5.4 basically...
10:22:03 <dmj`> c_wraith: and you're saying the linked list qsort version won't be O(n^2) on sorted input
10:22:40 <c_wraith> dmj`, you're underestimating the library code. 
10:22:50 <monochrom> eh? Data.List.sort does not use quicksort.
10:23:08 <c_wraith> dmj`, it's a merge sort that uses maximal runs as initial sections. 
10:23:11 <dmj`> c_wraith: well, I'm sure there are a lot of optimizations going on, with the lists
10:23:21 <c_wraith> dmj`, it's O(n) for sorted input. 
10:23:24 <dmj`> monochrom: not the in-place version ye
10:23:29 <dmj`> s/ye/yes
10:24:04 <dmj`> c_wraith: I have the lists reversed
10:24:09 <monochrom> and it is not exactly mergesort either. it is something that has hints of mergesort but really a custom algorithm that won benchmarks
10:24:35 <c_wraith> dmj`, still O(n) for lists and O(n^2) for your code. 
10:24:58 <dmj`> c_wraith: you're saying the list code sorts in linear time?
10:25:14 <c_wraith> dmj`, if the input is sorted or reverse sorted, yes. 
10:25:28 <c_wraith> dmj`, it's a good algorithm
10:25:37 <monochrom> have you read it for real?
10:26:01 <dmj`> c_wraith: microseconds vs. 1.8 seconds is a huge discrepancy
10:26:16 <monochrom> http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.OldList.html#sort
10:26:25 <c_wraith> dmj`, n verses n^2 is a big difference. 
10:26:51 <c_wraith> dmj`, this is why algorithmic analysis should not be neglected. it matters. 
10:26:51 <dmj`> oh, I forgot the base library used merge sort, it used to use naive list 'quick sort'
10:28:20 <monochrom> in fact, it was, not is, mergesort. scroll up a bit to see "GHC's mergesort replaced by a better implementation, 24/12/2009."
10:28:53 <dmj`> c_wraith: I don't think it's being neglected... I just had a faulty assumption. But this still doesn't account for the massive time difference
10:29:06 <black0range> I've allways found it interesting that Haskell has trouble with most algorithms  
10:29:30 <dmj`> monochrom: yes, since merge sort can guarantee O(n log n), I think that was the reasoning
10:29:51 <zomg> black0range: is that actually the case? Mostly when I've seen people having trouble with algos was when they were porting alogs line by line from some other language and it was very "un-Haskell" :)
10:30:03 <c_wraith> dmj`, your code has some inefficiencies, yes. but that's almost irrelevant compared to the algorithmic problem. 
10:30:36 <black0range> zomg: I'm thinking about alorithms that require state such as quicksort
10:30:59 <c_wraith> dmj`, for instance, don't store the index in an STRef. that's *really* bad for a bunch of reasons. 
10:33:18 <dmj`> c_wraith: I assume that performs allocation, defeating the purpose
10:33:30 <c_wraith> it does indeed. 
10:33:53 <c_wraith> it's also unnecessarily lazy
10:35:28 <dmj`> c_wraith: you mean the list allocation, to perform the loop
10:35:34 <Lemmata> hello, I'm trying to cabal install the hsqml package and am getting dependency issues.  It says that I need the external package Qt5Qml. I have the package and I know where it is, how do I point cabal to it?
10:35:59 <c_wraith> dmj`, actually I was talking about the thunk created by (+1)
10:36:21 <c_wraith> dmj`, stored in the STRef
10:37:14 <dmj`> c_wraith: ah 
10:37:16 * dmj` adds ($!)
10:38:06 <c_wraith> you'd be better off turning that loop into a recursive function that passes a new i value when needed. 
10:38:19 <dmj`> c_wraith: yes,  i <- newSTRef low is probably killing it
10:38:23 <dmj`> on each call of partition
10:38:23 <c_wraith> GHC optimizes that far better. 
10:43:45 <dmj`> c_wraith: strictness seems to have made it slower
10:45:31 <c_wraith> dmj`, well, strictness isn't a magic wand. it hurts as often as it helps. maybe more. you need to be careful with it, and understand why it matters at a particular point. 
10:46:29 <scshunt> > let m = (Data.Map.empty :: Data.Map.Map Int String) in (at 4) (const (putStr "hi" >> return $ Just "bye")) m
10:46:31 <lambdabot>  Not in scope: ‘Data.Map.empty’    Not in scope: type constructor or class ‘D...
10:47:35 <dmj`> c_wraith: ghc seems to be more often than not, better at that than I am
10:50:19 <dmj`> c_wraith: on randomized input the results are more realistic, but still not satisfying, merge sort w/ lists takes 452 μs, mutable quicksort (w/ only one allocation for the index) 35ms and finally insertion sort 1.16s
10:51:17 <c_wraith> dmj`, well, get rid of that STRef and see how that version does. 
10:52:41 <c_wraith> dmj`, just mutating an STRef is bad for performance. it allocates, and it's makes a mess of the garbage collector's job a pain.
10:53:05 <c_wraith> .. pretend that last clause makes sense, please. 
10:53:45 <dmj`> I'm tracking
10:54:36 <dmj`> c_wraith: I will try the loop
10:55:00 <c_wraith> basically, the gc algorithms are optimized for immutability. mutable cells make a mess of its approach, and slow it way down. 
10:57:44 <seishun> I have a bunch of functions that modify a list. I want to use them both as-is and as State monad. What's the usual approach?
10:58:06 <dmj`> c_wraith: makes sense, thanks
10:59:15 <Zekka|Sigfig> seishun: Define the plain version, then use modify f when you’re in State?
10:59:26 <Zekka|Sigfig> :t modify
10:59:28 <lambdabot> MonadState s m => (s -> s) -> m ()
10:59:47 <Zekka|Sigfig> (more specialized: (s -> s) -> State s ())
11:00:13 <seishun> :t state
11:00:14 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
11:01:49 <seishun> I assume I need to use "state" since they also return results
11:04:13 <seishun> can someone recommend a gentle introduction to multi-parameter typeclasses?
11:13:48 <sm> urgh.. docopts is a great start but too immature. What's another good/recent command-line options parsing lib, that's not optparse-applicative ?
11:14:13 <sm> s/docopts/docopt/
11:14:46 <ph88> how would i go about building a program that converts antlr grammar to haskell ?
11:16:59 <pavonia> ph88: What does it mean to convert a grammar to Haskell? Do you want to write a parser?
11:17:27 <ggVGc> I guess generate a parser in haskell for a grammer?
11:17:34 <ggVGc> like lexx/yacc_
11:17:34 <ggVGc> ?
11:17:45 <mpickering> Does anyone actually still use arrows?
11:17:58 <jle`> well, people use Arrow instances all the time
11:18:01 <ggVGc> mpickering: I use arrows all the time. why not?
11:18:10 <ph88> pavonia, either use a parser combinator or a parser generator .. i have to express the grammar in some way !
11:18:23 <mpickering> ggVGc: So what do you use them for?
11:18:32 <ggVGc> I often go foo&(bar>>>baz>>>boo)
11:18:39 <jle`> but few people use arrow-polymorphic tools these days, like proc notation
11:18:48 <jle`> mpickering: most people use the (->) instance all the time
11:18:52 <ph88> ggVGc, would generating a parser combinator qualify as generating a parser ?
11:19:02 <jle`> ggVGc: that'd probably be more of using a Category combinator than an Arrow combinator
11:19:12 <mpickering> My question is more about arrow notation yes
11:19:28 <jle`> proc-do notation is mostly used in very specialized cases these days
11:19:41 <pavonia> ph88: Depending on how complex the grammar is, you could use parsec/attoparsec or Happy
11:19:43 <jle`> there are situations where it's still used, but for the most part, it's not a part of general usage
11:20:28 <jle`> the thing is that a lot of the functionality using arrow-based interfaces that people would have written ten years ago are now provided through an Applicative-based interfaces
11:20:44 <ph88> pavonia, ggVGc sorry i had a connection problem
11:21:10 <jle`> so ever since Applicative came out, Arrow-based interfaces have become obsolete in most previous use cases
11:21:10 <pavonia> ph88: Depending on how complex the grammar is, you could use parsec/attoparsec or Happy
11:22:08 <ph88> pavonia, ok let's say i pick attoparsec .. so i want to build a program that converts antlr grammar to attoparsec notation .. is that feasible ?
11:22:34 <jle`> hm, not sure if you'd want to convert antlr grammar into attoparsec notation.  why not just parse antlr grammar into a parser?
11:22:38 <jle`> an attoparsec parser?
11:23:04 <ph88> because there are lot's of antlr grammars out there and you would have to convert each one manually
11:23:24 <jle`> i mean, parse the grammar
11:23:40 <jle`> don't antlr grammars all follow a format?
11:23:40 <ph88> yes that's what i want to do
11:23:44 <ph88> https://github.com/antlr/grammars-v4
11:23:45 <ph88> yes they do
11:23:46 <jle`> yes, parse the grammar into a parser
11:24:03 <xoitx> any links on the abstracts of haskell.. not syntax .. just pure abstract reading?
11:24:10 <ph88> parsing the grammar i think it will be ok ... but what about the "into a parser" part ?
11:24:25 <jle`> parse it into a trifecta, attoparsec, etc. parser
11:24:25 <xoitx> cant seem to find any youtube videos 
11:24:36 <jle`> are you familiar with parser combinator libraries in haskell?
11:24:41 <monochrom> that's quite a bit meta :)
11:24:53 <jle`> a `Parser a` is something that can parse a source (like a string) into an 'a'
11:24:54 <ph88> jle`, would i be generating attoparsec haskell source code ?
11:24:58 <jle`> no
11:25:01 <jle`> you'd be generating a parser
11:25:18 <ph88> i thought many haskell parsers are expressed as haskell source code
11:25:20 <jle`> Parser (Parser a)
11:25:28 <ph88> isn't that haskell?
11:25:38 <jle`> you wouldn't be generating source code
11:25:41 <jle`> you'd be returning a Parser
11:25:55 <jle`> a `Parser Int` is something that parses a string into an Int
11:26:03 <ph88> then how can i compile the parser ?
11:26:08 <jle`> a Parser (Parser a) is something that parsers a string or something into a `Parser a`
11:26:20 <jle`> you'd just use it
11:26:24 <jle`> like any other parser
11:26:24 <ph88> i don't want it to be reading the original grammar each time it needs to parse something
11:27:04 <pavonia> Do don't need to
11:27:07 <pavonia> *You
11:27:26 <pavonia> Once the parser is written, it can parse any grammars
11:27:52 <ph88> parsing the grammar is just the first step
11:28:21 <ph88> 1. parse antlr grammar 2. make parser for the grammar in haskell 3. compile the parser into binary
11:28:42 <eacameron> ph88: If you want to generate a new executable binary that only knows how to parse a grammar (that you've parsed) then you'd need to generate code somehow, perhaps with TH
11:29:04 <ph88> yes that's what i thought .. i need to generate code
11:29:05 <jle`> ph88: if you want, you can parse the grammar text into an ADT that represents it
11:29:06 <ph88> what's TH ?
11:29:15 <eacameron> ph88: Although you're probably just as well to embed the grammar in the exe and reparse it on exe init and then parse the input.
11:29:15 <jle`> that represents the syntax tree of the grammar
11:29:28 <jle`> and write a `Grammar -> Parser a` function
11:29:45 <jle`> but, parsing the grammar might not be your bottleneck here
11:30:09 <jle`> so, you could write a `Parser Grammar` that parses things into an ADT representation of the grammar
11:30:23 <jle`> and then just use your `Grammar -> Parser a` function to turn that thing into a parser, which you can then use
11:30:40 <eacameron> ph88: Yeah, as long as you let the exe parse multiple inputs without restarting, I'm not sure how much performance you'll gain by compiling with TH (template haskell)
11:30:50 <ph88> how do i go about making the Grammar -> Parser function ?
11:30:57 <jle`> well, first define your grammar type
11:31:08 <jle`> data Grammar = ANumber
11:31:17 <jle`> grammarToParser ANumber = digit
11:31:42 <tippenein> c_wraith: that's perfect, thanks
11:32:17 <ph88> jle`, once i have my parser "digit" how do i turn it into a binary so that i have a specialized parser for just that 1 grammar without reading the original grammar back ?
11:32:33 <jle`> i don't really think that a metaprogramming approach is really ever the best thing to do at a high level in haskell
11:32:45 <jle`> ph88: you can create a binary with the Grammar adt
11:33:00 <jle`> and just run your grammarToParser function to get your parser to start off your parsing
11:33:05 <ph88> jle`, my train is arriving, ill be back in 20min can we continue to talk then ?
11:33:15 <xoitx> just googled metaprogramming
11:33:17 <jle`> i'll be leaving soon too, but feel free to leave me a ping
11:33:21 <xoitx> is it even possible
11:33:23 <ph88> ok thx
11:33:33 <xoitx> sounds ridiculous 
11:33:43 <jle`> xoitx: in general, or in haskell?
11:33:49 <eacameron> ph88: Yeah jle` is right, that's how you'd likely do it in Haskell. If you really need to generate a binary *just* for that grammar then you can do it, but that's primarily the job of things like YACC and happy
11:33:51 <xoitx> in general
11:34:01 <xoitx> is it possible in haskell? :O
11:34:01 <ph88> eacameron, i be right back, got to go offline now
11:34:02 <jle`> yeah, languages like lisp are built around metaprogramming idioms
11:34:19 <jle`> sort of, but it's not really "how things are done", except for some small situations
11:34:21 <xoitx> I made a commitment to learn haskell
11:34:32 <xoitx> now I'm confused
11:34:32 <jle`> haskell solutions tend to avoid metaprogramming when possible
11:34:51 <xoitx> is metaprogramming related to stateless concept?
11:34:54 <jle`> for the most part, you can avoid it completely
11:35:02 <jle`> not really related
11:35:08 <eacameron> xoitx: Because they can. You rarely need metaprogramming in Haskell, whereas in other langs, like Lisp and Python, it's all over the place.
11:35:23 <scshunt> Depends
11:35:30 <scshunt> TH sees its uses
11:35:40 <scshunt> usually as a code generator
11:35:57 <eacameron> Sorry, "rarely" is relative. I write Python every day, metaprogramming is like air around here.
11:35:57 <jle`> the main situation where you have to fall back on metaprogramming in haskell these days is when you want to generate names/identifiers
11:36:02 <scshunt> it's not used so much for reflection
11:36:22 <xoitx> stateless implies no reference point ..well almost. I think and metaprogramming seems to be shifting the reference point around
11:36:40 <jle`> a lot of situations where we used to use metaprogramming (like generating json parsers for data types, for example) we can now do using generics
11:37:20 <jle`> xoitx: nah, a consider the common lisp macro example, the 'if': it takes a bool and two programs, and returns the first program if the bool is true, and the second program if the bool is false
11:37:25 <jle`> no state involved there
11:37:40 <eacameron> xoitx: Statelessness and metaprogramming are orthogonal concepts 
11:37:52 <xoitx> hmm
11:38:09 <eacameron> I.e. you can very stateful metoprograms. :)
11:38:11 <xoitx> any good reads on the theoritical concepts?
11:39:12 <eacameron> But keep in mind that metaprogramming basically exponentiates the complexity of your code. Now you not only have variables along the runtime axis, but you have variables of variables!
11:47:16 <hnordt> hello
11:47:26 <Iceland_jack> hey hnordt 
11:47:40 <hnordt> I'm a javascript programmer learning functional programming
11:48:00 <hnordt> I have a question that maybe haskell programmers can answer easily
11:48:04 <Iceland_jack> shoot
11:48:11 <hnordt> why operations proceed from right to left for compose()?
11:48:48 <eacameron> That's how the math guys did it long, long ago: https://en.wikipedia.org/wiki/Function_composition
11:49:30 <Iceland_jack> As eacameron said hnordt, it's has to do with historical reasons
11:49:52 <hnordt> so it's only a "mathematical taste"? I may use left to right too? 
11:50:09 <Iceland_jack> hnordt: In Haskell we have (>>>) that composes from left-to-right, so yes
11:50:24 <hnordt> ah, awesome, thank you!
11:50:25 <eacameron> Yeah, just don't call it "compose" or people will get confused. We call it "chain" or "pipe" in Python
11:50:38 <Iceland_jack> But it's mainly as a result of how function application looks
11:50:45 <hnordt> right, I'm using Ramda.js, they have a pipe function too
11:51:49 <Iceland_jack> Applying three functions in succession
11:51:49 <Iceland_jack>     validName (getFirstName (getName person))
11:51:49 <Iceland_jack> the right-to-left composition is
11:51:49 <Iceland_jack>     (validName . getFirstName . getName) person
11:51:54 <Iceland_jack>  
11:52:14 <monochrom> "f(g(x)) = (f . g) x" is why "." preserves that direction, i.e., your parameter comes from the right.
11:52:20 <Iceland_jack> Other direction would look like
11:52:20 <Iceland_jack>     (getName >>> getFirstName >>> validName) person
11:52:49 <hnordt> getName(getFirstName(validName())) = left to right
11:52:49 <hnordt> validName(getFirstName(getName))) = right to left
11:52:49 <hnordt> am I right?
11:53:02 <xoitx> coding optical sensors with haskell?
11:53:13 <Iceland_jack> hnordt: The syntax is off 
11:53:27 <Iceland_jack> hnordt: This also makes the type of composition (.) somewhat awkward
11:53:27 <Iceland_jack> :t (.)
11:53:28 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:54:02 <monochrom> if one day you find a language that puts parameters on the left, e.g., "((x)f)g", then "((x)f)g = x (f >>> g)" makes sense.
11:55:17 <hnordt> oh right, thank you for the quickly answers
11:55:27 <hnordt> you have an amazing community
11:56:03 <Iceland_jack> hnordt: Consider the reversed type
11:56:04 <Iceland_jack> :t (>>>) :: (a -> b) -> (b -> c) -> (a -> c)
11:56:05 <lambdabot> (a -> b) -> (b -> c) -> a -> c
11:56:35 <Iceland_jack> If you think about it as directions on a map:
11:56:35 <Iceland_jack>     I can walk from A to B
11:56:35 <Iceland_jack>     I can walk from B to C
11:56:35 <Iceland_jack>       so
11:56:38 <Iceland_jack>     I must be able to walk from A to C
11:56:41 <Iceland_jack>  
11:56:52 <Iceland_jack> I don't know how familiar you are with Haskell
11:57:17 <Iceland_jack> hnordt: Also, to show off how cool Haskell is, this is the definition of (.)
11:57:17 <Iceland_jack> @src (.)
11:57:17 <lambdabot> (f . g) x = f (g x)
11:58:05 <ralu> does fixity for (.) matters?
11:58:28 <monochrom> yes, fixity always matters
11:58:32 <Iceland_jack> It's associativity doesn't, since (.) is associative
11:58:43 <Iceland_jack> so
11:58:43 <Iceland_jack>     a.(b.c) == (a.b).c
11:58:53 <hnordt> I need to learn haskell syntax
11:59:00 <Iceland_jack> hnordt: yup
11:59:00 <hnordt> I don't know anything yet
11:59:12 <Iceland_jack> @whereis LYAH
11:59:12 <lambdabot> Maybe you meant: where+ where
11:59:13 <hnordt> I heard about haskell because I was researching about functional programming
11:59:15 <Iceland_jack> @where LYAH
11:59:15 <lambdabot> http://www.learnyouahaskell.com/
11:59:24 <Iceland_jack> hnordt: Check LYAH out
11:59:40 <seishun> is there a standard function that take a list and returns a tuple of head and tail?
11:59:53 <Iceland_jack> seishun: "uncons"
12:00:02 <Iceland_jack> from Data.List
12:00:09 <seishun> thanks
12:00:10 <Zekka|Sigfig> You may want pattern matching, mind (then again, you may not)
12:00:27 <Iceland_jack> > uncons "Hello"
12:00:31 <lambdabot>  mueval-core: Time limit exceeded
12:00:32 <hnordt> awesome, thank you @Iceland_jack
12:01:02 <Iceland_jack> it's a pretty recent addition
12:01:07 <ralu> > (,) <$> head <*> tail $ [1,2,3]
12:01:09 <lambdabot>  (1,[2,3])
12:01:12 <seishun> hoogle doesn't know it
12:01:20 <Iceland_jack> You're welcome hnordt, you better become a great Haskeller
12:01:24 <osfameron> I don't have an uncons in my Data.List
12:01:38 <Iceland_jack> It was added in base 4.8.0.0
12:01:39 <osfameron> (head &&& tail)  also works (importing Control.Arrow)
12:02:18 <Iceland_jack> Which is 7.10, you may have an older version
12:02:25 <Iceland_jack> well 7.10.1 iirc
12:03:08 <seishun> oh, it returns a maybe. Can't wrap that in state, can I?
12:03:37 <Iceland_jack> seishun: What should it return given an empty list?
12:03:57 <seishun> error
12:04:19 <Iceland_jack> My moral compass doesn't allow that
12:05:03 <osfameron> given that's what both head and tail return given an empty list, it seems somewhat appropriate :D
12:05:04 <Iceland_jack> If you know you have a non-empty list, uncons from Data.List.NonEmpty may be what you want
12:05:04 <Iceland_jack>     uncons :: NonEmpty a -> (a, Maybe (NonEmpty a))
12:09:44 <acertain> is there a rnf somewhere that avoids traversing shared data?
12:09:59 <roelof> Does anyone how I can use the package System.Console.byLine with stack ? 
12:14:04 <eacameron> roelof: extra-deps: [byline-0.2.1.0]
12:15:01 <eacameron> Add that to your stack.yaml
12:15:33 <ph88> jle`,  ?
12:17:30 <roelof> hmm, still the message : cannot find module "System.Console.byLine"
12:19:48 <sm> added to stack.yaml ? stack build to install the new dep ? restart GHCI if you're in that ?
12:22:11 <nitrix> roelof: Checking.
12:22:12 <dmj> c_wraith: ping
12:22:41 <c_wraith> I suppose I exist. but I'm not at a computer.. 
12:22:43 <nitrix> roelof: The module is System.Console.Byline not byLine.
12:23:34 <nitrix> roelof: The library is called `byline`. It isn't on stackage.
12:23:49 <nitrix> roelof: So you'll want to have byline in both your cabal file and stack.yml file.
12:24:39 <nitrix> roelof: More specifically, the extra-deps: section of the stack.yml, so that it knows the resolver can't resolve it and fallback to hackage.
12:24:44 <dmj`> c_wraith: I removed the STRef's but the performance gains were negligible
12:25:39 <nitrix> roelof: Oh and for the cabal file, you want it in your executable block, under the build-depends section.
12:26:21 <sm> so many parts to line up just so... :)
12:28:01 <sm> how simple *could* it be, if the Haskell community used a time warp and rebuilt all tools from scratch ?
12:28:54 <raichoo> Off to the Tardis Monad! /o/
12:29:08 <Akii> tardis monad?
12:29:20 <Akii> as in blue box flying through space and time monad?
12:29:24 <raichoo> https://hackage.haskell.org/package/tardis-0.3.0.0/docs/Control-Monad-Tardis.html
12:29:44 <geekosaur> there is actually a MonadTardis on hackage, so named because it uses laziness to accomplish apparent "time travel"
12:30:10 <Akii> "How do you use a Tardis?"
12:30:13 <Akii> haha
12:30:15 <sm> btw, Primer is an interesting movie about time travel (on netflix)
12:30:31 <dmj`> c_wraith: it's 6-8x slower than the naive quicksort
12:30:37 <dmj`> c_wraith: http://lpaste.net/155021
12:30:48 <dmj`> and it does no explicit allocation afaict
12:31:33 <dmj`> who needs algorithmic analysis when you have GHC I guess
12:31:53 <dmj`> heh
12:36:19 <c_wraith> I don't see the issue offhand. I'd need to experiment to figure it out. 
12:38:03 <dmj`> c_wraith: when just evaluating to whnf the naive sort goes down to 212 microseconds, 20x performance improvement over the nf naive sort version, the unboxed mutable version stays the same.. ~30ms
12:38:47 <nitrix> (\(k1,b1) (k2,b2) -> (min k1 k2, b1 || b2))
12:38:55 <nitrix> Any cleaner way to write this?
12:38:59 <nitrix> It feels repetitive.
12:39:32 <c_wraith> dmj`, well, yes. getting only the first element out, the list version degenerates to an O(n) quickselect
12:40:04 <c_wraith> dmj`, vectors don't have laziness properties that allow that. 
12:40:29 <Iceland_jack> nitrix: I think Biapplicative or something similar 
12:41:04 <c_wraith> :t min *** (||) 
12:41:06 <lambdabot> Ord b => (b, Bool) -> (b -> b, Bool -> Bool)
12:41:51 <c_wraith> heh. then you just need to apply it. 
12:42:13 <Iceland_jack> ghci> (min, (||)) <<*>> (4, True) <<*>> (10, False)
12:42:13 <Iceland_jack> (4,True)
12:42:28 <c_wraith> that's definitely better. 
12:42:31 <dmj`> c_wraith: I see, still would like to know why the nf version is so much slower
12:42:45 <Iceland_jack> If they had the same types, you could use regular applicative and V2 or pairs
12:43:04 <c_wraith> dmj`, it's a good question, but not one I can look into now. 
12:44:07 <nitrix> Fancy!
12:44:20 <Iceland_jack> I guess with 'bipure'
12:44:20 <Iceland_jack> ghci> bipure min (||) <<*>> (4, True) <<*>> (10, False)
12:44:20 <Iceland_jack> (4,True)
12:44:53 <Iceland_jack> ghci> biliftA2 min (||) (10, False) (666, False)
12:44:54 <Iceland_jack> (10,False)
12:45:01 <Iceland_jack> First time using Biapplicative
12:45:23 <nitrix> My lambda is the folding function of a foldr though.
12:45:27 <roelof> nitrix:  I did addd byLine-0.2.1.0 at the builds-depends but still the same error 
12:45:47 <nitrix> roelof: builds-depends of the cabal file, now you want extra-deps of the stack file too.
12:46:09 <nitrix> roelof: Then the import name must be System.Console.Byline (Haskell is case sensitive)
12:47:15 <nitrix> I'll go with *** (arrows I think?)
12:47:21 <nitrix> Because it needs to be applied by foldr.
12:48:29 <Iceland_jack> nitrix: do you mean like
12:48:29 <Iceland_jack> foldr (biliftA2 min (||)) :: Foldable t => (Int, Bool) -> t (Int, Bool) -> (Int, Bool)
12:48:29 <Iceland_jack>   :: Foldable t => (Int, Bool) -> t (Int, Bool) -> (Int, Bool)
12:48:33 <Iceland_jack> ?
12:48:48 <nitrix> Yup !
12:49:43 <Iceland_jack> also, both (Int, min) and (Bool, (||))
12:50:38 <Iceland_jack> or well, (Int, min) is a semigroup
12:52:01 <nitrix> Iceland_jack: I'm kind of impressed how easily you came up with that.
12:52:02 <Iceland_jack> nitrix: So maybe you want something like
12:52:02 <Iceland_jack>     fold :: [(Min Int, Any)] -> (Min Int, ANy)
12:52:05 <Iceland_jack> *Any
12:52:21 <nitrix> Iceland_jack: Nah, the foldr on biliftA2 worked fine.
12:53:13 <nitrix> Iceland_jack: How many years eating my Haskell breadcrumbs will it take to get there :P ?
12:53:33 <Iceland_jack> Hm I started Haskell some years ago
12:53:57 <Iceland_jack> I took Haskell 101 in 2012, but I had played with it before that
12:54:16 <c_wraith> foldr uses O(n) stack there. I'd be wary, since a foldl' (properly set up) could do it with O(1) stack. 
12:54:41 <nitrix> Oh crap.
12:54:48 <nitrix> foldr is the one that recurses first?
12:55:26 <c_wraith> Uh. for some definition of "first" 
12:55:45 <c_wraith> it nests the recursive call inside the call to f
12:55:59 <c_wraith> in Haskell, that doesn't always mean it happens first. 
12:57:03 <infandum> How do you (temporarily, not permanently) change the linker from ld.gold to ld.bfd in ghc?
13:03:32 <quchen> infandum: GHC takes flags to control which programs are invoked by it, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-phases.html#replacing-phases
13:05:07 <infandum> quchen, yeah, I tried "-pgml /usr/bin/ld.bfd" and the like, but it still ignored that and was building with /usr/bin/ld (which symlinks to the gold linker right now)
13:05:47 <infandum> cabal install --ghc-options="-pgml etc"
13:06:16 <quchen> Maybe it's a compilation issue?
13:06:29 <quchen> Source doesn't change so nothing recompiles (or re-links)
13:06:49 <tippenein> does anyone here use swap spaces on small server instances to build with stack?
13:07:00 <infandum> basically here "http://stackoverflow.com/questions/13046319/haskell-ghc-compiling-linking-error-not-creating-executable-linux"
13:07:03 <tippenein> just trying to weigh my options for ghc out of memory errors
13:07:20 <davean> tippenein: how small re you talking?
13:07:25 <infandum> it looks like it was trying to recompile, I'll try again
13:07:58 <tippenein> 1gb mem
13:08:27 <davean> I build all of hackge on a 2GB RAM system
13:08:55 <infandum> quchen: Nope, -fforce-recomp had the same issue (and still said it was using /usr/bin/ld)
13:09:04 <davean> All the system does though is build hackage
13:09:17 <quchen> infandum: What happens when you temporarily rename ld?
13:09:25 <quchen> (Not sure whether that's a good idea.)
13:09:38 <quchen> (Well, it's most certainly a terrible idea, but … science!)
13:09:39 <infandum> quchen: yeah, I didn't want to do that but it probably will work
13:09:50 <infandum> like, that's what I did to get ld.gold in the first place
13:09:54 <infandum> replace the sym link
13:10:02 <dmj`> c_wraith: INLINE brought it down to 5ms, from 30ms
13:11:35 <tippenein> davean: hmm, I'm not really sure I'm willing to pay 2x the amount for a server quite yet
13:11:55 <tippenein> seems like 1gb should be sufficient
13:12:40 <infandum> quchen: Yeah that worked. I guess I'll just keep going back and forth by deleting the linkers over and over
13:12:50 <infandum> haha there's no way this will end in tears!
13:15:28 <quchen> infandum: This sounds like a bug.
13:15:44 <quchen> infandum: Maybe spend a couple of minutes finding out whether it's reported already? :-)
13:19:58 <nitrix> Can foldl' bomb on a large enough list, or reaching the end of the list before folding strictly doesn't need anything on the stack?
13:20:27 <nitrix> I'd imagine there's still a call stack; maybe it's on the heap instead of the actual stack?
13:20:35 <nitrix> Is Haskell's stack reserved for values only?
13:21:03 <nitrix> I know this isn't very relevant to Haskell; just fed up of unpredictable time cost.
13:22:48 <Zemyla> foldl' shouldn't bomb the stack, it's tail recursive.
13:23:18 <quchen> Tail recursive functions can still (make something that) bomb the stack.
13:23:25 <quchen> Canonical example, foldl (+) 0.
13:24:25 <quchen> Furthermore, foldl' isn't even tail recursive.
13:24:28 <quchen> ?src foldl'
13:24:29 <lambdabot> foldl' f a []     = a
13:24:29 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:24:36 <quchen> That's a `seq` as the tail call.
13:25:48 <quchen> "The stack" usually means "the call stack"; in GHC there's a pattern-match stack instead, which has different semantics.
13:26:12 <quchen> As a result, tail recursion is much less important. Many common functions (that don't overflow) are not tail recursive.
13:26:15 <quchen> ?src forever
13:26:15 <lambdabot> Source not found. Maybe you made a typo?
13:26:36 <quchen> Well, any function in do-notation is not tail recursive, because the last call in it is (>>).
13:27:02 <quchen> (Not counting redundant `do` like x = do x)
13:28:10 <quchen> nitrix: If you're wondering whether foldl' can build up "huge things" then yes. It uses `seq`, so it only does a shallow force (WHNF).
13:29:42 <tommd> nitrix: If you are having trouble in a particular case then a minimum example can help direct discussion.
13:32:38 * shapr hops cheerfully
13:32:51 <shapr> Yay more Haskell code!
13:33:03 <quchen> Hello Shapr! Welcome to our community!
13:33:05 <shapr> I may end up fixing all of the samples in the github library
13:33:18 <shapr> quchen: oh hai! I've heard Haskell is a fun language that's somewhat like Java
13:33:20 <shapr> quchen: is that true?
13:33:22 * hackagebot heroku-persistent 0.2.0 - Parse DATABASE_URL into configuration types for Persistent  https://hackage.haskell.org/package/heroku-persistent-0.2.0 (jferris)
13:33:31 <shapr> quchen: I've also heard the Haskell community is friendly and helpful!
13:33:34 <quchen> shapr: Yes! With lots of curly braces
13:33:48 <shapr> quchen: funny you should say that, I wrote some Haskell code with braces and semicolons this week
13:33:54 <quchen> GHC? :-)
13:34:02 <cocreature> was just about to mention ghc :)
13:34:23 <shapr> I taught an Introduction to Haskell at the FP meetup I organize in Atlanta
13:34:46 <shapr> and I claimed that Haskell uses significant whitespace like Python, but is perfectly fine with braces and semicolons, so my audience asked me to demonstrate.
13:35:03 <quchen> "Perfectly fine"
13:35:21 <tommd> shapr: How did you decide on the syllabus?
13:35:22 <quchen> Just as fine as using 7 spaces for indentation
13:35:27 <shapr> so I added a bunch of semicolons and a few braces, and it typechecked
13:35:40 <tommd> But then seg faulted?
13:35:49 <davean> tommd: what?
13:36:11 <shapr> tommd: I have a standard lesson I teach for Python and Haskell, use http to grab a book in text format from gutenberg.org, then tokenize the book and count the words, then show the top ten and bottom ten.
13:36:33 <shapr> I've only done that once for Haskell, so it took me 1.5 hours, but I can do it in 55 minutes in Python
13:36:51 <shapr> teaching with lists is boring, showing off fold is fun
13:38:15 <shapr> tommd: do you have a lesson you teach?
13:39:55 <tommd> shapr: No, I don't tend to teach but I am trying to come up with a reasonable order to introduce concepts in a book.
13:40:27 <shapr> oh, I've discovered that many concepts can be 'ignored' and students will understand them implicitly
13:40:34 <shapr> that's shortened my lessons considerably
13:40:41 <tommd> It is not yet another Haskell book, but a closely related language.
13:40:55 <shapr> on the other hand, I'm used to quickly changing the level of any lesson to match the audience
13:41:03 <tommd> shapr: So types vs classes / constraints vs values ...
13:41:07 <quchen> shapr: What concepts in particular?
13:41:23 <shapr> quchen: anything they don't ask about?
13:41:42 <shapr> I tend to aim a bit higher level than I think the class will actually grasp, and then dial back when they ask questions
13:41:47 <tommd> ha.  If I did that then I'm not sure I'd ever talk about Haskell to a beginner.
13:42:10 <shapr> tommd: also, teaching your lesson to lots of random people over and over can really refine things
13:42:26 <shapr> I have a good grasp on which questions people will ask, what confuses them
13:42:42 <shapr> for example, the first time someone sees a function type in a type signature INSTANT CONFUSION
13:43:23 * hackagebot haxr 3000.11.1.4 - XML-RPC client and server library.  https://hackage.haskell.org/package/haxr-3000.11.1.4 (BrentYorgey)
13:58:23 * hackagebot groundhog-converters 0.1.0 - Extended Converter Library for groundhog embedded types  https://hackage.haskell.org/package/groundhog-converters-0.1.0 (scottmurphy09)
14:07:04 <fr33domlover> How do I disable a flag in stack? e.g. --flag mypkg:myflag enables the flag, but how do I disable a flag?
14:08:56 <nineonine> hi there
14:08:59 <nineonine> cabal question
14:09:08 <nineonine> im doin cabal install and it fails with this error
14:09:25 <shapr> fr33domlover: do you specifically want to disable a library? or what?
14:09:32 <nineonine> setup-Simple-Cabal-1.22.4.0-x86_64-osx-ghc-7.10.2: can't find source for
14:09:33 <nineonine> Destination/To/File in src/, dist/dist-sandbox-88b7a676/build/autogen
14:09:48 <nineonine> i removed the source for that file
14:10:00 <nineonine> but cabal is still looking for it
14:10:05 <shapr> is it still listed in the cabal file?
14:10:24 <nineonine> oh yeah
14:10:24 <nineonine> :)
14:10:26 <nineonine> thanks
14:10:41 <shapr> we're here to help!
14:10:43 <shapr> @botsnack
14:10:43 <lambdabot> :)
14:11:17 <geekosaur> fr33domlover, mypkg:-myflag
14:11:26 <shapr> well, except for lambdabot
14:11:26 <fr33domlover> shapr, i want to build a package with one of its ---
14:11:29 <geekosaur> https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#flags-and-ghc-options
14:11:31 <fr33domlover> ah, thanks geekosaur 
14:14:28 <nineonine> next cabal question
14:14:28 <nineonine> hehe
14:14:43 <nineonine> im entering cabal repl
14:14:46 <nineonine> and loading Main
14:14:56 <nineonine> Could not find module ‘Network.HTTP.Client.TLS’
14:15:19 <nineonine> that happened when I unregistered older version of tls in global context
14:15:28 <nineonine> and left only the latest one
14:15:53 <Drezil> do you need cabal?
14:15:57 <nineonine> its weird because this is referring to http-client-tls
14:16:09 <Drezil> does stack not work for some reason or so?
14:16:12 <nineonine> well, im just learning it
14:16:20 <nineonine> yeah I was considering trying it
14:16:23 <nineonine> should I ?
14:17:03 <Drezil> yes. because it solves nearly all issues with cabal (it uses cabal underneath it)
14:17:12 <nineonine> got it !
14:17:14 <Drezil> and instead of cabal repl you do stack repl..
14:17:36 <Drezil> and it does not install everything in every sandbox, but saves it globally and just links it in the correct version..
14:17:50 <Drezil> and you never have conflicting versions again (as long as they are in lts)
14:18:10 <nineonine> sounds reasonable !
14:24:02 <tyho> I am getting a confusing error using Text.Printf: My format string is "%-3d: %s\n" and when compiling I get the error:     Illegal literal in type (use DataKinds to enable): "%-3d: %s\n"
14:24:27 <jle`> tyho: looks like you're trying to use a string as a type?
14:24:34 <jle`> instead of a value?
14:24:47 <jle`> > 1 :: "hello"
14:24:49 <lambdabot>      Expected a type, but ‘"hello"’ has kind ‘GHC.TypeLits.Symbol’
14:24:49 <lambdabot>      In an expression type signature: "hello"
14:24:49 <lambdabot>      In the expression: 1 :: "hello"
14:25:15 <tyho> jle`, s/::/=/
14:25:17 <tyho> doh
14:25:38 <jle`> maybe you're used to a language that defines things with :=
14:25:42 <jle`> ^^
14:26:22 <tyho> jle`, I have no idea how you managed to guess I am most familiar with Go. but well done !
14:26:57 <n1cky> I recently came across this tweet that talked about a JIT ruby compiler and something impressive it could do:
14:26:57 <jle`> well, both :: and = are similar to :=, so maybe you went in the opposite direction :p
14:27:07 <n1cky> it could constant fold "eval([1, 2, 3].inspect).sort[1] * 2 => constant value 4"
14:27:52 <n1cky> and it got me thinking about how things are declared in haskell, with the description of how the data types map
14:28:18 <n1cky> but couldn't that be extended to some bit? Eg: the reason that someone could inline the above thing in ruby is because the JIT is able to figure out that it becomes constant
14:28:25 * hackagebot tasty-groundhog-converters 0.1.0 - Tasty Tests for groundhog converters  https://hackage.haskell.org/package/tasty-groundhog-converters-0.1.0 (scottmurphy09)
14:28:49 <n1cky> but if we had the ability to say, "sort will take in a list of cardinality X and produce a list of cardinality X", you'd be able to do a lot of interesting compiler tricks
14:30:00 <Maxdamantus> The same thing can happen in Haskell.
14:30:19 <Maxdamantus> you can probably find cases like that where it already happens in GHC.
14:31:16 <Maxdamantus> It's often quite easy to inline and expand function application. When you do that enough times, you're just running parts of the program in the compiler.
14:33:25 * hackagebot hsdev 0.1.7.1 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.7.1 (AlexandrRuchkin)
14:33:29 <jle`> n1cky: don't forget about the issue that it's hard to check 'sort will terminate'
14:34:24 <Maxdamantus> Though if you have the code for `sort`, you can just expand it a couple of steps and see that it terminates by then.
14:34:39 <Maxdamantus> or see that the `[1]` operation can terminate.
14:36:01 <dfeuer> I really want to be able to promote unlifted tuples. 
14:36:12 <dfeuer> Why can't I?
14:36:52 <jle`> i want to know why i am not allowed to have implicit params constraints on typeclass instances
14:38:25 * hackagebot flow 1.0.5 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.5 (fozworth)
14:38:39 <dfeuer> jle`, while that's an interesting question, I'm a bit curious why do you want implicit params anyway.
14:38:43 <tippenein> looking for something like (Enum a) => String -> a
14:38:57 <dfeuer> tippenein, and what do you want that to do?
14:39:33 * dfeuer has never found any use whatsoever for implicit parameters.
14:39:42 <jle`> for implicit configurations :D
14:39:44 <tippenein> data Thing = Yes | No  --- unknownFunction "No" => No 
14:39:57 <jle`> i started using them in my last project and they removed a lot of overhead/boilerplate
14:40:00 <tippenein> turn a string back into an enum
14:40:02 <monochrom> that is the job of Read, not the job of Enum
14:40:14 <greg> hello ive down stack new, then changed to the  folder , edited my cabal file to add shpider to the library dependencies (shpider is in stackage apparently) and yet when i do stack build it recommends adding shpider-0.2.1.1 to extra deps, what gives?
14:40:19 <monochrom> one might say, turn a string back to a read
14:41:01 <jle`> tippenein: you can use read or readMaybe, but there's no way to do it in general for any Enum
14:41:02 <Wizek> Hey! Anyone has any idea how this could be written in similarly concise terms (or even more concisely) that type-checks? https://gist.github.com/Wizek/8a8c3127bc318e791992
14:41:33 <Wizek> (it fails on line 10)
14:41:34 <tippenein> jle`: ok. I've heard to avoid using `read` so I didn't consider it
14:41:53 <mgsloan> greg: It isn't in stackage - this page doesn't list any snapshots https://www.stackage.org/package/shpider
14:42:17 <tippenein> I suppose readMaybe takes care of that partial function case
14:42:26 <jle`> yeah
14:42:45 <jle`> there are other reasons to not use read/readMaybe, but something simple like this is sort of the thing that Read was made for
14:42:50 <monochrom> Enum a => String -> a would suffer the exact same problem as Read a => String -> a
14:43:05 <jle`> ideally, though, you'd never have to work directly with a String "No"
14:43:14 <monochrom> changing the class name doesn't wave a wand and make parse errors go away
14:43:37 <monochrom> this is the problem with listening to hearsay without asking why
14:43:39 <jle`> actually with Enum you have enough information to make "default" things
14:43:48 <jle`> to return on failed parses
14:43:53 <jle`> but yeah, the point stands
14:44:09 <greg> mgsloan: thanks i see , i thought just it being on the page meant it was somehow linked
14:44:19 <greg> ok ill add the dependencies
14:45:22 <tippenein> yeah, I appreciate the input. In the specific case, the parser has already found a match of the enum I'm looking for, so it's just a matter of turning it back to an enum to construct a new data type
14:45:33 <anoe> hello, i have two different json files and I need to parse it both in the same library. So I am declaring the types of Data to parse it. I works separately but I have 2 fields that have the same name so I get a 'multiple declaration' error at compile time. How to manage that ?
14:45:47 <anoe> (using aeson)
14:45:59 <dfeuer> jle`, how are implicit params better for that than reflection?
14:46:11 <puregreen> anoe: put the types into separate files, or rename one of the fields
14:46:49 <n1cky> jle`: Maxdamantus: What about the eval(foo.inspect) portion?
14:47:07 <anoe> I can not chose the name of the fields of the json file I get from an api. So I have to put types in different files I guess.
14:47:12 <n1cky> ( .inspect is essentially toString in other languages)
14:47:30 <puregreen> anoe: if you are generating instances via Generic, you can name your fields like “fooX” instead of “X” and then do https://artyom.me/aeson#generics-customising-field-names
14:47:32 <n1cky> If I was designing a language, I'd let functions refer to each other as inverse
14:47:41 <Maxdamantus> n1cky: and it's still a case of function application.
14:47:52 <n1cky> so eval is mutally an inverse with inspect
14:47:57 <anoe> puregreen: ok thanks!
14:48:01 <n1cky> Maxdamantus: what do you mean?
14:48:42 <n1cky> How is GHC's equivilant of eval to know that an arbitrary string corresponds to some output? It cannot be known at compile time
14:48:54 <n1cky> but if you know that they undo each other, you can effectively cancel them out
14:48:56 <Maxdamantus> It can if it knows the string.
14:49:16 <n1cky> But GHC is not a jit, right?
14:49:23 <Maxdamantus> `show [1, 2, 3]` only depends on things that are statically known.
14:49:45 <Maxdamantus> It can be, but that's not really relevant.
14:50:11 <n1cky> statically meaning fixed, or statically meaning globally?
14:50:16 <monochrom> there is some overlap between JIT and lazy evaluation. you know that?
14:50:19 <hpc> it can be a JIT of sorts, if you take the definition a bit too literally
14:50:24 <Maxdamantus> statically as in not depending on runtime input.
14:50:41 <geekosaur> ghc doesn't have eval. (read is not eval.)
14:51:00 <Maxdamantus> eg, the user isn't writing `[1, 2, 3]` there. It's hardcoded into the program.
14:51:17 <fr33domlover> Q: When trying to build gitit, it fails every time with this error when building happstack: http://paste.rel4tion.org/296 . Any ideas what I can do with it? :-/
14:51:21 <geekosaur> read is a parser that recognizes what by intent are constant expressions
14:51:54 <n1cky> Maxdamantus: i understand now.
14:51:57 <n1cky> took me a sec.
14:52:18 <Maxdamantus> geekosaur: how is that different to an evaluator for constant expressions?
14:52:30 <hpc> Maxdamantus: it doesn't execute code
14:52:50 <geekosaur> Maxdamantus, "eval" is not an evaluator for constant expressions, it executes code that may include variables and have side effects
14:52:52 <Maxdamantus> Right, `read` itself doesn't.
14:53:33 <Drezil> fr33domlover: it does not find network-uri-2.6.0.3 .. is that in the stack-lts you use?
14:53:37 <geekosaur> at least, that is the conventional usage that non-Haskellers generally expect from eval
14:53:41 <monochrom> "read" calls user-written code or library code only.
14:53:46 <Drezil> normally stack makes sure those things build .. :/
14:53:49 <Maxdamantus> but it wouldn't be unreasonable to have something of type `String -> Value` which evaluated constant expressions.
14:54:14 <Maxdamantus> and it would be subject to this compile-time evaluation in exactly the same way as read/show
14:54:16 <jle`> but that String -> Value might not terminate
14:54:23 <hpc> from wikipedia: "Eval and apply are instances of meta-circular evaluators, interpreters of a language that can be invoked within the language itself"
14:54:30 <Maxdamantus> read/show might not terminate either.
14:54:36 <hpc> that's a step above being just a parser
14:54:38 <jle`> yes, but they're not done at compile-time
14:54:39 <monochrom> note that library code is still standard Haskell and therefore under the same limitation, e.g., there is no "eval" to call for help
14:54:46 <Maxdamantus> They can be done at compile time.
14:54:47 <hpc> it's a runtime API
14:54:52 <jle`> not necessarily
14:54:57 <monochrom> this basically forces "read" to be just a parser
14:54:58 <hpc> > read "5 + 7" :: Int
14:55:00 <lambdabot>  *Exception: Prelude.read: no parse
14:55:01 <Drezil> fr33domlover: you could try giving it --resolver=lts-5.8 which should have that package included...
14:55:05 <hpc> that's the difference ^
14:55:07 <jle`> unless you do some tricks like using template haskell
14:55:19 <Maxdamantus> You just expand a few steps, and if the reduction is smaller you'd probably avoid including the previous overall evaluation in teh program.
14:55:22 <fr33domlover> Drezil, i use 4.0 which is what gitit's stack.yml specifies :P
14:55:28 <Maxdamantus> if it's larger, you might abort expanding that branch.
14:55:32 <fr33domlover> i just did `stack install`
14:55:47 <fr33domlover> i'll try 5.8
14:55:54 <Drezil> normally it is safe to upgrade ....
14:56:09 <Maxdamantus> You don't need to prove termination about these things. You can do incremental evaluation and stop at any time.
14:56:27 <Drezil> especially since the 4.x-branch had a regression with aeson-0.10 or so causing very long compile-times (and memory-costs)..
14:56:48 <Maxdamantus> and I'm pretty sure GHC already does it by default.
14:57:19 <n1cky> Maxdamantus: why put that burden on the compiler instead of on the programmer?
14:57:22 <n1cky> that's what I don't get.
14:57:40 <Maxdamantus> if you can turn `show [1, 2, 3]` into the string `"[1, 2, 3]" in few enough steps, you're probably not going to have the `show [1, 2, 3]` bit in your final program.
14:58:09 <Maxdamantus> it'll just be as if you wrote the Char list literal "[1, 2, 3]".
14:58:40 <Maxdamantus> n1cky: because programmers are meant to write understandable code. Compilers are meant to transform it into something that runs efficiently.
14:59:03 <Maxdamantus> n1cky: code inlining is a fairly standard compilation technique.
14:59:12 <Maxdamantus> and that's really all this ise.
14:59:29 <hpc> inlining is weaker than evaluation
14:59:43 <hpc> and thus easier to automate
14:59:58 <hpc> compile-time evaluation is a very hard thing to do in a way that's useful
15:00:02 <Maxdamantus> I'd say it is a form of evaluation.
15:00:07 <tippenein> what am I looking for if I'm trying to parse a string from a list of possible strings? like a string "stuff" <|> string "other" but generated from a list of possibles
15:00:11 <Maxdamantus> It's incremental evaluation.
15:00:20 <hpc> it's only definitional substitution
15:00:23 <hpc> alpha renaming
15:00:37 <monochrom> tippenein: there is mconcat
15:00:39 <Maxdamantus> Which is a legitimate way to evaluate something in the LC.
15:00:40 <n1cky> Maxdamantus: putting that assumption aside, if two functions reciprocate, and the programmer intends for that to happen, would it not be useful for the programmer to explicitly declare that?
15:00:47 <n1cky> not just for the compilers sake, but for theirs?
15:01:07 <hpc> er, not alpha renaming
15:01:30 <Maxdamantus> I'd be inclined to call it "small-step reduction".
15:01:52 <Maxdamantus> but that might imply additional things like that after each step you still have a valid Haskell program.
15:01:58 <Maxdamantus> which isn't necessary in implementation.
15:02:36 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/104783/
15:07:15 <n1cky> Thanks for the conversation, I've got to be going
15:07:24 <n1cky> thanks for helping me think a bit. :)
15:07:48 <numee> hi, why is mempty for Maybe a is Nothing rather than Just mempty, which is the identity element?
15:09:02 <milesrout> numee, who says (Just mempty) is defined?
15:10:40 <puregreen> milesrout: I think it is, 'cause Monoid a => Monoid (Maybe a)
15:10:52 <milesrout> oh is it
15:10:55 <milesrout> nvm then
15:11:43 <hpc> there's two different valid monoids, and they just picked one
15:12:01 <monochrom> the doc says they use this instance to lift a semigroup, not to lift a monoid
15:12:08 <puregreen> (well, more than 2, see https://byorgey.wordpress.com/2011/04/18/monoids-for-maybe/)
15:12:11 <hpc> the one with mempty = Nothing is the "multiplication" monoid, because mempty = 0 in some squint-a-little-bit sense
15:12:18 <geekosaur> numee, that would also be a valid definition, but it's a question of whether you want mempty to mean an empty Maybe or a Maybe with an empty in it
15:12:51 <hiptobecubic> wouldn't the other way require `a` to have an instance of `Maybe` as well? You don't always have that
15:13:02 <hiptobecubic> errr. monoid
15:13:18 <geekosaur> isn't that what puregreen said?
15:13:43 <hpc> puregreen: neat
15:15:27 <geekosaur> I think that instance is predefined, so either way would be valid. suppose the one numee would prefer should be a newtype, it being reasonably obvious given the instance.
15:16:15 <geekosaur> in fact it's wrapped twice. see the First and Last newtypes
15:16:53 <geekosaur> neither of which are the thing wanted here oops
15:17:55 <geekosaur> in any case it'd be easy enough to create that newtype. perhaps the fact that it doesn't exist indicates that nobody has really wanted it that badly
15:19:29 <puregreen> isn't Alt going to be that newtype?
15:19:43 <hpc> Control.Alt.Delete
15:20:04 <monochrom> but Alt does the same thing as First for Maybe
15:20:25 <monochrom> haha hpc
15:20:58 * puregreen is a bit disappointed this isn't a thing
15:21:15 <monochrom> I think we should create it
15:21:22 <milesrout> lol
15:21:22 <puregreen> what's going to be there?
15:21:44 <hpc> a thin wrapper around .NET
15:24:03 <fr33domlover> Drezil, same error: http://paste.rel4tion.org/297
15:24:27 <fr33domlover> i did the same, but this time with lts-5.8
15:24:47 <fr33domlover> maybe the happstack-server package has a bug?
15:26:19 <lpaste> Yuras pasted “Why Vector.length (Vector.replicate n 0) not get fused?” at http://lpaste.net/155039
15:26:43 <Yuras> Hi all. Should "Vector.length (Vector.replicate n 0)" fuse? ^
15:27:12 <Yuras> for some reason it produces an intermediate vector :(
15:29:45 <numee> it took me a while to understand ... okay Monoid for Maybe b lifts a semigroup `a` to a monoid ... even though it has (Monoid a) constraint in it
15:30:21 <numee> it'd make much more sense if the constraint were Semigroup not Monoid I think
15:30:34 <geekosaur> eventually that should change, Semigroup will be in base instead of a separate library
15:31:33 <jle`> numee: yeah, the semigroups library actually has a Maybe-like type with that instance
15:34:10 <mgsloan> fr33domlover: I'm not sure what can cause that condition, but I occasionally see it.  My current untested theory is that maybe the linker doesn't like SIGTERM or SIGKILL
15:34:53 <mgsloan> fr33domlover: You can either try a surgical approach to resolving it, "stack exec -- ghc-pkg uninstall network-uri" 
15:36:03 <mgsloan> Or use a big hammer and do "stack clean --full" and delete ~/.stack/snapshots/x86_64-linux/lts-4.* and lts-5.*
15:36:18 <mgsloan> And delete all the nightlies
15:37:47 <fr33domlover> mgsloan, i did that in a clean environment :P
15:38:15 <fr33domlover> i'll try the 1st one and if it doesn't work i'll clean
15:38:19 <fr33domlover> thanks mgsloan 
15:45:18 <Yuras> and "runIdentity $ Stream.length (Stream.replicate n (0 :: Int))" is successfully fused, as expected
15:45:27 <Yuras> where "Stream" is "Data.Vector.Fusion.Stream.Monadic"
15:45:38 <Yuras> I'm confused completely...
15:45:44 <dino-> Guys, using regex-compat, am I crazy or is this wrong:
15:45:46 <dino-> > subRegex (mkRegex ".*(bar)") "\\1quux" "foobar"
15:45:48 <lambdabot>  Not in scope: ‘subRegex’Not in scope: ‘mkRegex’
15:45:49 <dino-> "\\1quux"
15:45:59 <dino-> Shouldn't that have been "fooquux"  for output?
15:46:01 <dino-> :/
15:46:41 <dino-> Oh wait, capture wrong place?
15:47:20 <dino-> wow, same output
15:47:22 <dino-> > subRegex (mkRegex "(.*)bar") "\\1quux" "foobar"
15:47:24 <lambdabot>  Not in scope: ‘subRegex’Not in scope: ‘mkRegex’
15:47:24 <dino-> "\\1quux"
15:47:32 <geekosaur> that should have produced barquux not \\1quux
15:48:13 <geekosaur> oh, hm, is that doing BRE or ERE?
15:48:46 <dino-> No idea. I've tried \1 \\1 and \\\1 too
15:49:41 <geekosaur> looks like it should default to extended. (basic would require the capture to be \\( \\) )
15:52:42 <fr33domlover> ah, i found a clue: when i build with lts-5.8, happstack-server SocketTH module still looks for network-uti in the lts-4.0 folder! dunno why
15:52:56 <fr33domlover> but that explains why the build keeps failing
15:53:36 <fr33domlover> now trolling by deleting everything and having /only/ 5.8... :)
15:53:56 <geekosaur> oh
15:54:04 <geekosaur> dino-, you misunderstood the order of parameters
15:54:17 <geekosaur> subRegex regex inputstring replacementstring
15:54:27 <dino-> oh that's ridiculous
15:55:27 <dino-> thanks for catching that geekosaur
15:56:00 <dino-> After I'm wildly fligning around backslashes :P
16:32:03 <nineonine> question: im calling tests with
16:32:14 <nineonine> cabal test --show-details=always
16:32:40 <nineonine> is there to always show details without specifying it every time ?
16:32:47 <nineonine> way*
16:33:29 * hackagebot language-javascript 0.5.14.6 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.14.6 (ErikDeCastroLopo)
16:54:13 <Javran> any recommendation for priority queues that supports non-root element deletion / update?
16:56:12 <Javran> say I want to implement Dijkstra's algorithm and that requires maintaining a queue based on distance.
16:58:30 * hackagebot language-javascript 0.6.0.0 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.0 (ErikDeCastroLopo)
16:58:32 <fr33domlover> one weird error follows another weird error... http://paste.rel4tion.org/298
16:58:41 <fr33domlover> still trying to build gitit there
17:00:34 <fr33domlover> Javran, maybe use Map or IntMap? from containers package
17:03:42 <Javran> fr33domlover:  that looks perfect, I wasn't aware Data.Map has Min / Max supports, thanks!
17:04:27 <fr33domlover> Javran, np
17:05:49 <fr33domlover> Javran, btw if you ever want to see an existing implementation, iirc 'fgl' has n dijkstra implementation (if not, maybe another fgl package has)
17:09:40 <Javran> fr33domlover: thanks for the info!
17:37:29 <black0range> Hey guys what do you call the data that often replaces 'infininite' lists when reading data? 
17:38:23 <monochrom> I don't understand. when I read data, I just read data, not replace anything.
17:41:31 <erikd> black0range: when you do 'xs <- readFile "/tmp/wibble"' the xs is an "unevaluated thunk"
17:41:34 <Javran> fr33domlover: just realized I was wrong .. Data.Map sorts elements based on key, so can't use that as a priority value
17:42:51 <monochrom> fr33domlover: you may like http://hackage.haskell.org/package/psqueues
17:43:01 <black0range> erikd: Might just thought about something retareded... :)
17:43:03 <erikd> Javran: https://hackage.haskell.org/package/psqueues ?
17:43:03 <Javran> fr33domlover: maybe I don't have to delete non-root element after all, given that the element is only updated when its distance can be relaxed .. so keeping the old element is fine
17:43:36 <monochrom> oh, not fr33domlover, nevermind
17:44:08 <Javran> erikd: monochrom: thanks I guess that should work
17:52:53 <black0range> When creating a package do you thin it's acceptable for 'users' to deal with ExceptT? 
17:53:44 <black0range> (making a http server as a hobby project)
18:28:07 <anand> has anybody here had an existential crisis? because I'm having one right now. I can't derive generic!!!!
18:28:30 <CharlesMax> Hi
18:29:00 <CharlesMax> I usually always am having existential crisis
18:29:33 <haskell025> hi
18:29:45 <anand> so, the crisis is this: I've got this type
18:29:48 <anand> data Shell = Shell {_environments :: forall a. NFData a => M.Map ASSheetId (SEXP a 'Env)}
18:30:06 <anand> and I can't specify NFData for Shell.
18:30:38 <haskell403> hello
18:30:49 <haskell403> hello
18:31:06 <haskell403> hello from the other side
18:31:10 <anand> in particular, can't do this: instance NFData Shell where rnf s = seq (s^.environments) ()
18:31:39 <CharlesMax> I see, but this is to advanced for me now XD
18:32:16 <haskell403> is Shell an isomorphic decidable type?
18:32:48 <anand> Sorry, don't really know what that means... can you explain?
18:33:24 <haskell403>  in a dependent calculus without annotations on the abstractions, it is undecidable to show typeability of a term in a non-empty context. Both of those hypotheses are necessary: in the empty context, typability reduces to that of the simply-typed λ-calculus (decidable by Hindley-Milner) 
18:34:29 <anand> how do I prove that it is an isomorphic decidable type?/
18:35:52 <haskell403> if we’re restricted to just talking in Haskell, it is a little difficult to tell what this definition means when talking about monads: a monad m does not have kind *, it has kind * -> *. The usual inspired guess would be for monads m1 and m2, you want a function iso :: forall a, m1 a -> m2 a and osi :: forall a, m2 a -> m1 a. 
18:36:48 <haskell403> see http://stackoverflow.com/questions/21113387/how-to-define-a-strict-existential-type
18:40:27 <anand> I've already seen that link actually; when trying the following:
18:40:30 <anand> data Shell = forall a. (NFData a) => Shell {_environments :: M.Map ASSheetId (SEXP !a 'Env)} 
18:40:36 <anand> instance NFData shell where 
18:40:49 <anand> I get an "unexpected strictness annotation" error
18:41:11 <anand> I thought this didn't apply to data declaration
18:43:49 <haskell403> there seems to be a stray ` in your data declaration
18:44:21 <anand> oh the apostrophe is for a constructor that has been promoted
18:45:23 <haskell403> do you have {-# LANGUAGE ExistentialQuantification #-}
18:45:38 <anand> I do.
18:46:05 <anand> is there anything obviously wrong with the declaration?
18:46:17 <haskell403> other than the fact that one of your types starts with ass, no
18:55:32 <Gurkenglas> dont forget the constructor starting with sex
19:03:07 <muesli4> Hi, is it possible to parse arguments in pairs of two with optparse-applicative? (I read some unsatisfying stack exchange posts about it...) :)
19:10:25 <Rainb> can I learn haskell
19:10:27 <Rainb> to learn math
19:11:25 <scshunt> Rainb: I wouldn't say you can. But understanding haskell can help you with math and vice-versa
19:11:51 <Rainb> Yeah, well
19:11:59 <Rainb> sometimes I don't understand some math concepts.
19:12:06 <Rainb> So I believe haskell could help me
19:12:16 <Rainb> since they're mathy instructions
19:16:25 <anand> how would I write a lens for this type?
19:16:28 <maerwald> I don't think it helps you with maths. In practical haskell programming there's not more maths than you have in any sort of programming. Depends solely on the problem, not the lanugage.
19:16:28 <anand> data Shell = forall a. (NFData a) => Shell {_environments :: M.Map ASSheetId (SEXP a 'Env)}
19:16:54 <anand> as I understand, makeLenses doesn't work with existential quantification
19:18:35 * hackagebot hip 1.0.1.1 - Haskell Image Processing (HIP) Library.  https://hackage.haskell.org/package/hip-1.0.1.1 (lehins)
19:20:55 <EvanR> haskell lets you solve problems in a more math minded way, if you can come up with one
19:21:54 <maerwald> EvanR: example?
19:30:33 <parsecChar> is it possible in haskell to code erlang style
19:30:36 <parsecChar> with lots of cheap forkIOs
19:30:40 <parsecChar> that pass typed msgs to each other
19:30:56 <parsecChar> or is the haskell forkIO green thread more expensive than an erlang beam 'process' ?
19:31:50 <c_wraith> iirc, they're cheaper than beam processes
19:32:45 <xa0> They don't come with the total isolation of mutable state per process, like Erlang, iirc
19:33:05 <c_wraith> but no one has really built a full system like the OTP, and that's where the majority of erlang's excellent system comes from. 
19:33:11 <xa0> Also you can use MVars to send messages
19:35:19 <c_wraith> but yeah... 100k threads is no big deal on GHC, assuming they spend most of their time asleep. 
19:36:17 <c_wraith> 100k might require a somewhat beefy machine or tuning runtime params. but it can be done. 
19:38:47 <parsecChar> why do I need genserver if my threads do't crash?
19:38:58 <parsecChar> I thought the advantage of genserver is 'management' and 'restarting stuff when stuff dies'
19:39:15 <parsecChar> but if my typesafe code doesn't crash, why do I need genserver and all those monitors ?
19:40:30 <c_wraith> typesafe code only doesn't crash until it encounters the real world, with all its wonderful broken FFI bindings, OS issues, network issues, hardware issues... 
19:40:33 <Adeon> if you open files or make connections or something it might be convenient to just let things crash than to handle it
19:40:50 <Adeon> yeah that
19:44:22 <c_wraith> I much prefer haskell to erlang as a language. but I will happily praise the OTP for being a fantastic piece of engineering that nothing in Haskell can match up with (yet - maybe someday) 
19:50:30 <EvanR> maerwald: combinators
19:51:09 <maerwald> EvanR: of what
19:51:21 <echo-area> Do I need to care about reentrancy of functions I use in a signal handler for System.Posix.Signals, or is it already taken care of by the library?
19:52:06 <EvanR> all the way down
19:52:45 <scshunt> combinators are like turtles?
19:56:29 <maerwald> EvanR: well, they are not really unique to haskell
19:56:46 <EvanR> no
19:57:09 <EvanR> but haskell makes it easier to do than say ruby
19:57:26 <maerwald> I can see that at it's core it feels more mathy, but in practice I really barely see much correlation
19:57:35 <echo-area> https://ro-che.info/articles/2015-07-06-haskell-signals  Helpful
19:57:52 <EvanR> well if it doesnt feel more mathy, i dont know how else you know its mathy
19:58:20 <maerwald> if I write an implementation for a graph-like data structure I don't feel a lot of "math"
19:58:33 <EvanR> if you have a problem, which contains laws, and you identify the laws, then you can build a language which makes any combination automatically follow the laws
19:59:00 <EvanR> a graph data structure isnt really what i mean by combinators
19:59:03 <maerwald> if I do image processing, it's horrible low-level haskell code... pretty similar actually to the C implementation, with a few style differences
19:59:36 <EvanR> imagine that in math you compose a bunch of symbols for some reason, you can do this easier in haskell
19:59:50 <maerwald> if I write a web app in haskell, I don't feel math... I just use a framework
19:59:51 <xa0> You can do things like image convolution using comonads
19:59:51 <EvanR> THAN X
20:00:10 <EvanR> you win maerwald, haskell isnt mathy because the web exists ;)
20:00:11 <maerwald> so basically... I feel math when the problem is an actual math problem
20:00:24 <EvanR> thats what i said
20:00:43 <EvanR> if you can come up with a math way to think about it, then...
20:00:53 <maerwald> well, that goes for pretty much any language though
20:01:25 <EvanR> many languages really get in the way of using a totally different language to talk about the issue
20:01:38 <EvanR> youre stuck in the original language dealing with irrelevant things
20:02:24 <maerwald> EvanR: oh well, that's an argument you can throw at haskell too... although I agree that writing a DSL can be easier in haskell
20:02:26 <EvanR> or theres an ambient culture of NOT thinking about things in anything but the moving parts, the capacitors of the TV rather than the image on the TV
20:51:21 <nshepperd> combinators don't really work in other languages because everything has the wrong type
21:13:39 * hackagebot nemesis 2016.3.19 - a task management tool for Haskell  https://hackage.haskell.org/package/nemesis-2016.3.19 (JinjingWang)
21:15:57 <ij> I wrote a little script that `sort's my imports without taking "qualified" token into account for use in vim: http://sprunge.us/SdfK 
21:17:29 <ij> paramap echo = id, paramap tac, would take each paragrah and reverse its lines with paragraphs themselves staying in the same order.
21:22:34 <EvanR> grumble, cabal install gloss wont build gloss because Illegal BangPattern use -XBangPatterns
21:24:11 <eklavya> I am trying to setup Haskforce plugin for intellij, as soon as the setup paths for the binaries (ghc-mod etc) and open a haskell file, Intellij hard freezes
21:24:38 <eklavya> sorry if its not the right channel to seek help for this
21:27:35 <xoitx> hey there haskellers
21:28:04 <xoitx> whats the difference between program as a variable and function as a variable
21:28:17 <xoitx> don't they seem to be the same thing?
21:36:31 <nitrix> What do you mean, a program as a variable?
21:36:32 <ij> in haskell source code?
21:40:09 <nitrix> xoitx: A program would be a collection of instructions meant to be run on a target computer; regardless of what process it undergo to be generated.
21:41:24 <nitrix> xoitx: As far a computer is concerned, "variables" and "functions" aren't meaningful, since they are language-dependent features.
21:42:55 <nitrix> Although simplified a little, I hope it helps you assign them different realms mentally.
21:45:36 <xoitx> so the computer would not be able to discern between the two
21:45:47 <xoitx> what about mathematics?
21:46:11 <nitrix> It simply executes instructions. Variables and functions are language abstractions.
21:49:26 <nitrix> xoitx: Mhh. Haskell variables are immutable, thus probably similar in essence to variables in mathematics.
21:53:41 <xoitx> well then how is metaprogramming possible in haskell?
21:54:46 <nitrix> xoitx: A computer in itself only buys you arithmetic. You still have to reason about the operations and give meaning to the various numbers. Thus, data structures, encoding, and the need for abstrations like programming languages.
21:55:06 <nitrix> xoitx: My concept of metaprogramming is probably very different than what you're asking.
21:55:35 <dmj`> xoitx: generics, template haskell, free monads
21:56:35 <xoitx> I guess metaprogramming is not anything more than a mere if-else then?
21:57:00 <dmj`> xoitx: hm..?
21:57:31 <nitrix> In my book, metaprogramming just means that you have programs manipulate (create/transform) other programs, or even itself.
21:58:15 <xoitx> transforming its self? That seems to be beyond a linear operation
21:58:43 <dmj`> linear operation?
21:59:19 <xoitx> sequential processing
21:59:31 <nitrix> xoitx: I'm not sure how time/space complexity is relevant to the definition of those terms or roles.
22:00:25 <dmj`> sequential processing?
22:00:27 <xoitx> time space?
22:00:31 <nitrix> Maybe someone who speaks your jargon would be better suited to help you.
22:00:51 <xoitx> lol
22:01:41 <xoitx> by sequential I meant a single instruction at a time
22:01:58 <dmj`> xoitx: how is that related to meta-programming
22:02:31 <xoitx> that is my confusion when people say a program modifies itself
22:03:39 <nitrix> Compiler boostrapping is the first thing that comes to mind.
22:05:22 <toph> metaprogramming is pretty general, the wikipedia page has a good explanation
22:08:22 <xoitx> hmmm
22:08:56 <xoitx> so is it possible for a computer to generate another program and delete itself?
22:10:04 <montanonic> is it performant to use Data.String.QQ to write a multiline string, and then use Text.pack to convert it into a text? This versus just using the \ escape char to write a multiline string by hand with overloaded strings on.
22:10:29 <montanonic> Unless Data.String.QQ works with overloaded strings already?
22:12:39 <bitemyapp> montanonic: I use this to generate Text values: https://hackage.haskell.org/package/raw-strings-qq-1.1/docs/Text-RawString-QQ.html
22:12:59 <montanonic> bitemyapp: much appreciated
22:13:14 <bitemyapp> montanonic: I think the unpack function in Text is pretty heavily optimized, I wouldn't worry about it too much unless you've got something demonstrable in a benchmark.
22:13:25 <bitemyapp> montanonic: remember that it'll probably get CAF'd and evaluated once only.
22:13:42 * hackagebot ig 0.7 - Bindings to Instagram's API.  https://hackage.haskell.org/package/ig-0.7 (cdepillabout)
22:39:41 <shanemikel> can somebody help me figure out how to get: EitherT a m b -> m (Either a b)
22:39:55 <jle`> runEtiherT
22:39:59 <jle`> * runEitherT
22:40:12 <jle`> but also, EitherT is deprecated
22:40:36 <jle`> in favor of ExceptT from transformers
22:41:18 <jle`> :t runExceptT
22:41:20 <lambdabot> ExceptT e m a -> m (Either e a)
22:41:30 <shanemikel> oh
22:41:39 <shanemikel> does it use exceptions?
22:41:44 <jle`> hm?
22:41:54 <jle`> IO exceptions?
22:42:18 <shanemikel> hackage page for `either` package doesn't show deprecation afaict
22:42:23 <jle`> ... no?  although i'm not sure how it would use io exceptions
22:42:50 <shanemikel> Just asking because of the name
22:42:59 <shanemikel> is it much different than eitherT? 
22:43:09 <jle`> oh no, it's not any different from EitherT
22:43:17 <jle`> except for the fact that it comes with GHC
22:43:26 <pavonia> I think ErrorT is deprecated in favour of ExceptT
22:43:28 <jle`> so it's like, you can import a package that defines lists
22:43:33 <jle`> or you can just use the lists that come with ghc
22:43:54 <pavonia> where EitherT doesn'T have a constraint on the first parameter
22:44:12 <jle`> EitherT and ExceptT are more or less identical, except for the fact that ExceptT comes with GHC
22:44:24 <jle`> so there really isn't any good reason to use EitherT
22:44:44 <jle`> unless you want to be a rebel :)
22:45:53 <montanonic> Hmmm, I can't seem to find any string quasiquoter that allows for multiline strings but doesn't render newlines. 
22:46:24 <montanonic> I want a long string that's nice to read in the code, but that renders as just a single string, no "\n" 
22:47:08 <jle`> pavonia: ErrorT is definitely deprecated, and you even get a compiler warning if you accidentally use it
22:47:14 <montanonic> and using \   \ makes editing the content of the string take too long, as I have to reposition all the escape chars.
22:47:42 <dino-> I've been transitioning over to ExceptT under the understanding that it's the new ErrorT too. Does that sound right?
22:48:26 <jle`> yes, that's actually what the compiler warning says when you use ErrorT :)
22:48:31 <jle`> s/says/suggests
22:48:39 <EvanR> I wonder why i have the gloss source trying to compile it, and it seems to depend on GLFW-b [1.4.1, 2) and i have glfw-b 1.4.7, and the glfw backend does not compile and the entire module looks like it was written against an entire different library...
22:48:55 * hackagebot language-javascript 0.6.0.1 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.1 (ErikDeCastroLopo)
22:48:55 <pavonia> jle`: Yeah, looks like ExceptT doesn't have that Error e constraint anymore
22:48:57 * hackagebot hjsmin 0.2.0.0 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.2.0.0 (ErikDeCastroLopo)
22:49:04 <jle`> pavonia: ExceptT never had an Error e constraint
22:49:09 <jle`> ErrorT did/does
22:49:20 <pavonia> Yes, that's what I mean
22:49:25 <jle`> ah ok
22:49:38 <EvanR> i true rebel master writes his own isomorphic version of EitherT
22:49:48 <shanemikel> thanks
22:50:06 <jle`> but yeah, to answer your original question, it'd be runEitherT, or runExceptT if you're using ExceptT
22:50:30 <shanemikel> and instead of hoistEitherT it's (ExceptT . return)
22:50:35 <jle`> under normal circumstances ExceptT would be named EitherT, but i think there was some drama with the transformers maintainer
22:51:09 <jle`> and also, there would have been a name clash with EitherT from the either package i guess
22:51:32 <jle`> but it was specificaly introduced to replace EitherT, so it's kind of weird
22:52:21 <shanemikel> yeah, that's a little annoying.. I rather like the `Monad a`T naming convention.. easy to find
22:53:48 <jle`> mhm, it's nice, but i guess that reason could be considered superficial to some
22:53:50 <jle`> (not me)
23:03:55 * hackagebot hjsmin 0.2.0.1 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.2.0.1 (ErikDeCastroLopo)
23:08:21 <jle`> shanemikel: also instead of (ExceptT . return), you can do `either throwE return`
23:08:36 <jle`> that makes a little bit more sense to me, semantically
23:08:41 <jle`> but, it's a stylistic thing too
23:10:16 <jle`> or, there's also either throwError return
23:10:20 <jle`> :t either throwError return
23:10:21 <lambdabot> MonadError e m => Either e a -> m a
23:10:23 <jle`> :t either throwE return
23:10:25 <lambdabot>     Not in scope: ‘throwE’
23:10:25 <lambdabot>     Perhaps you meant one of these:
23:10:25 <lambdabot>       ‘throw’ (imported from Control.Exception),
23:10:28 <jle`> aw
23:11:09 <jle`> :t either throwE return
23:11:11 <lambdabot> Monad m => Either e a -> ExceptT e m a
23:12:39 <parsecChar> anyone here using neovim with haskell ?
23:12:51 <parsecChar> I'm currently using tmux + vim + ghci repl + vim-haskell-now
23:13:03 <parsecChar> but I'm starting to see people replace tmux + vim + vim-haskell-now with "newovim + vim-haskell-now"
23:13:11 <parsecChar> anyone here developing haskell with vim-haskell-now ?
23:16:07 <lf94> Emacs + Spacemacs + Haskell packages = greatness
23:16:15 <lf94> Power of vim and everything else
23:16:28 <lf94> You could even remove tmux in favor of Emacs running in daemon mode.
23:16:49 <lf94> (neovim supports daemon mode, so that's why they ditch tmux)
23:17:37 <parsecChar> I tried emacs; never got the hang of it
23:17:46 <parsecChar> elisp encourages me to script it
23:17:50 <parsecChar> but then I'm like -- why is elisp not haskell
23:17:55 <parsecChar> why is elisp not even scheme ?
23:17:55 <lf94> Spacemacs has vim bindings
23:18:05 <parsecChar> I never have this problem in vim -- vimscript is so annoying I never try to script it
23:18:21 <hiptobecubic> I don't know why people keep saying evil mode is as good as vim. It's like saying bash has all the power of emacs because it uses readline. There are a great many things that emacs does better than vim, but acting like vim is not one of them, unfortunately.
23:18:22 <parsecChar> tried spacemacs once; it's insane; it's really like an OS
23:18:48 <lf94> hiptobecubic, vim is known for its input interface.
23:19:03 <parsecChar> amazing how a question in about neovim, in #haskell, might result in an emacs/vim flamewar
23:19:05 <lf94> Providing the input interface is great
23:19:24 <lf94> nah, no flamewar. Use what you like :)
23:19:40 <hiptobecubic> Right. So calling something "as good as vim" when it doesn't fully provide the only thing vim is really good at seems weird to me.
23:20:01 <lf94> I never said as good as vim ;)
23:20:02 <hiptobecubic> I have an emacs install that I keep trying to use and I always end up giving up because it's not quite there
23:20:12 <lf94> You should try Spacemacs.
23:20:21 <hiptobecubic> I did. It was insane
23:20:39 <lf94> I think spacebar layers is great
23:20:47 <parsecChar> insane is the right word
23:20:52 <johnw> this isn't really #haskell relevant
23:21:04 <parsecChar> sorry, started with my question about haskell dev environments
23:21:10 <parsecChar> we'll stop it
23:21:14 <johnw> thx!
23:21:30 <parsecChar> johnw: make yi as good as emacs/vim, and we won't have these problems :-)
23:21:36 <parsecChar> or maybe leksah
23:21:40 <lf94> Emacs :: String -> [Pixel]
23:21:43 <johnw> I already have an editor job :)
23:36:04 <sleblanc> lf94, pretty sure that's IO [Pixel] ;)
23:36:51 <sleblanc> parsecChar, if you are interested, there is a package called haskell-emacs which claims to allow writing emacs extensions in Haskell.
23:40:59 <parsecChar> sleblanc: I would really like something like yi/yeksah where it's native ahskell rather than "oh, here's a plugin which gives you 2nd class access to a subset of emacs which sorta sometimes work when the moon is full and you slaughter 5 chickens and dip them in goat's blood"
23:44:09 <EvanR> you know what would be cool
23:45:02 <EvanR> you can currently get cool "live coding" by either recompiling, relinking, and restarting haskell processes OR you can reload code from within ghci which is much faster but not as flexible
23:45:17 <EvanR> what would be cool is to have both
23:45:40 <EvanR> fast reloading using whatever technology ghci uses but from another haskell process
23:46:03 <parsecChar> I find reloading within ghci perfectly fine, except for occasionall "THE IMPOSSIBLE HAPPENED" bug reports
23:46:22 <EvanR> its fine, but you dont want to edit your code from in ghci
23:46:34 <EvanR> or write your song, or design your SVG
23:46:47 <EvanR> or shift the placement of mobs
23:47:05 <parsecChar> I write my code in vim; then I press :make, which tells tmux to tell it's embeded ghci to reload
23:47:07 <parsecChar> and I'm happy
23:47:47 <EvanR> yeah so what would be cool is a library to use one of these embedded ghci so that, our "cool thing" not limited to ghci OR vim
23:48:15 <EvanR> its easy to say the new feature should simply go into vim or emacs
23:49:27 <EvanR> but thats not modular
23:50:59 <sleblanc> EvanR, haskell-mode (emacs) is pretty much this
23:52:56 <sleblanc> EvanR, although it's not always stable; I don't see "THE IMPOSSIBLE HAPPENED" messages, but sometimes the interactive interpreter buffer is "out of sync" and it will no longer let me write to it. I have not found a way to recover other than reloading the session
