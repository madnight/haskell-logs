00:04:08 <naevathecat> Hey all, anyone know how to read a specific number of lines from a file, process them and repeat. Trying to implement an external sort and a bit stumped (without doing it super ugly(
00:04:34 <johnw> naevathecat: sure, there are a few ways to do that, depending on which libraries you're comfortable with
00:05:13 * hackagebot with-location 0.1.0 - Use ImplicitParams-based source locations in a backward compatible way  https://hackage.haskell.org/package/with-location-0.1.0 (SimonHengel)
00:05:18 <naevathecat> johnw: Well processing files as Data.Text.Text but otherwise pretty happy to use anything (that isn't lens :P)
00:05:29 <cocreature> there is hGetLine in Data.Text.IO
00:05:36 <johnw> i'd use pipes and lens to process lines from a file
00:05:41 <johnw> but hGetLine is pretty straightforward
00:05:53 <naevathecat> cocreature: That gets one, it's the repetition in chunks I am confused over
00:06:11 <johnw> in particular pipes-group is about chunking a stream into sub streams
00:06:13 <cocreature> naevathecat: sry I don’t get the question then
00:07:04 <cocreature> you can just use replicateM do get a specific number of lines
00:07:18 <cocreature> or just read them one at a time
00:07:20 <naevathecat> cocreature: External sorting, I have verybigfile.txt I need to divide it into subsets of n, sort those and output them sequentially, then in subsets of m of those files of n merge the results recursively
00:07:53 <naevathecat> johnw: I will take a look at pipes-group :) cheers
00:08:01 <naevathecat> cocreature: Thanks, did not know about that function
00:08:08 <johnw> don't expect it to be obvious on how to use it the first time :)
00:08:18 <johnw> pipes-group is sort of notoriously difficult to use, for what it does
00:08:30 <naevathecat> I see :(
00:08:53 <naevathecat>  uses FreeT and **lenses**
00:08:58 <johnw> yep
00:09:02 <naevathecat> deception!
00:09:11 <EvanR> er... replicateM with hGetLine ?
00:09:29 <johnw> yeah, that might be easier
00:09:45 <johnw> main benefit of pipes is that once you master it, it becomes useful for a whole lot of problems
00:10:17 <naevathecat> johnw: probably worth doing in the long run, this I need to get done by this weekend
00:10:17 <EvanR> easy to learn, hard to master
00:11:14 <cocreature> to be fair pipes itself is not that hard. it’s pipes-parse & pipes-group that is a bit confusing
00:15:51 <naevathecat> cocreature: say I decide to be a scrub and ignore pipes-group for now. If I'm doing the replicateM thing over the file. Then how to repeat until the EOF? you have something like h <- openFile; MAGIC (replicateM parseNlines) h
00:16:08 <naevathecat> It's almost like a fold, but not quite
00:16:34 <EvanR> use recursion luke
00:16:47 <cocreature> naevathecat: yeah manual recursion is probably easier and then catch isEofError
00:17:35 <PrettyBoy2000> hello there can someone explain what different betwen darknet and deepweb
00:18:07 <naevathecat> But I don't neccessarily know how large the input file is?
00:18:59 <cocreature> naevathecat: that’s why you read until you get an eof error
00:19:44 <naevathecat> cocreature: manual recursion it is then
00:19:52 <naevathecat> ty for the help :)
00:19:53 <cocreature> yeah seems like the easiest solution
00:26:05 <johnw> PrettyBoy2000: this isn't the channel for such questions
00:26:18 <Skuzzzy> THe easiest solution is to use a real programming language ie not haskell
00:26:24 <Skuzzzy> toy for math geeks
00:26:33 <johnw> no trolling either
00:26:53 <Skuzzzy> oh whoops sorry
00:30:38 <EvanR> sometimes i feel like thats true, when i think haskell stuff is so awesome, but no one i meet seems to think so, am i missing something
00:39:48 <Krikey_Sanchez> is there a function that's like map but maps over nested lists and preserves the structure?
00:40:02 <Krikey_Sanchez> so, something like nestedMap :: (a -> b) -> [[a]] -> [[b]] ?
00:40:09 <johnw> fmap . fmap
00:40:09 <liste> :t map . map
00:40:10 <lambdabot> (a -> b) -> [[a]] -> [[b]]
00:41:41 <cocreature> fmap fmap fmap :)
00:41:55 <EvanR> gross
00:42:06 <cocreature> sry
00:44:21 <liste> :t fmap (fmap fmap fmap) (fmap fmap fmap)
00:44:22 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
00:52:05 <jle`> Krikey_Sanchez: map takes a (a -> b) and turns it into an [a] -> [b], so (map . map) takes an (a -> b) and turns it into an ([[a]] -> [[b]])
00:52:35 <Krikey_Sanchez> map . map works for me
00:52:36 <Krikey_Sanchez> thansk
00:53:22 <yaz> hello
00:55:14 * hackagebot digit 0.2.3 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.2.3 (TonyMorris)
00:59:20 <kellytk> Is it correct to think about haskell as a language which constrains where side-effects may take place?  I'm thinking about a language like JavaScript, and any function in any scope can modify state it has a reference to, and I imagine a language that instead would constrain where state may be modified
00:59:34 <kellytk> I don't know if there's anything there
01:00:00 <jle`> side-effects in haskell are explicit
01:00:16 <jle`> in other languages, they're often implicit
01:00:46 <shachaf> I,I Haskell gives you extra freedom by allowing you to write functions which are guaranteed to be side-effect free.
01:00:57 <kellytk> What is an example of how side-effects are explicit please?
01:01:20 <Lokathor> in haskell, you can generally only take in values and return new values. But some contexts hold values in the background that can appear to change over time
01:01:34 <ner0x652> Hi!
01:01:38 <Lokathor> IO, State, ST, STM, etc
01:02:00 <ner0x652> I wrote a simple Singly Linked List type constructor
01:02:07 <kellytk> Ok so you isolate to explicit places where state may exist?
01:02:14 <ner0x652> something is wrong in my implementation
01:02:28 <ner0x652> can you please take a look at this gist https://gist.github.com/ner0x652/a0e0fb3bcf22f8f27079 , what is wrong? 
01:02:47 <Lokathor> kellytk, yes. if a function's type doesn't include State in the type, and you use it during a State action, you can be sure that it won't touch your State's background state, for example
01:03:01 <kellytk> Are all types of state expected to change over time?  (meaning no notion of constants IIUC)
01:03:21 <Lokathor> no, Reader is a type that's specifically for when your state is not expected to change over time
01:03:52 <kellytk> I designed a language that has the feature you describe Lokathor.  I've had the feeling for a while Haskell may implement more of the designs I've come up with but I don't know enough about Haskell to say yet
01:04:00 <ner0x652> the result is LNode 8 EmptyNode , the other numbers are missing, I need somehow to link those nodes :-/
01:04:08 <EvanR> a context that holds values that appear to change over time... seems like a sloppy way to cover IO, State, ST and STM
01:04:09 <liste> ner0x652: line 8
01:04:29 <liste> ner0x652: you seem to be inserting to the end of the list
01:04:32 <kellytk> Lokathor: State must be explicitly declared, and its nature may be specified
01:04:49 <Lokathor> EvanR, well, they're not really literally changing
01:04:56 <EvanR> kellytk: what "state" and "side effects" even are really need to be reimagined once you start doing haskell
01:05:01 <kellytk> Can I function have multiple types?
01:05:09 <EvanR> Lokathor: in the case of IO... they dont even exist
01:05:14 <liste> ner0x652: or, rather, trying to insert
01:05:30 <Lokathor> it can have a polymorpihc type that allows for more than one type to be used with it, but must have one specific type
01:05:40 <kellytk> EvanR: How would you sum it up?
01:05:47 <EvanR> i cant
01:05:49 <Lokathor> for example, id :: a -> a, so you can use id on any type of value, but id's type itself is the same all the time
01:06:16 <EvanR> kellytk: when you do a fold, would you consider this having state?
01:06:39 <Lokathor> EvanR, an IORef exists, for example
01:07:24 <EvanR> well, mutable variables is one way to construe "state"
01:08:01 <EvanR> i can see where youd see a commonality between those four monads, mutable variables
01:08:13 <kellytk> What if I asserted any values not in code form as state?
01:08:13 <martinvlk> @pl (fmap (fmap (\(Entity _ v) -> v))                     <$> runApiCheck apiDbRuleListByType (tagDyn rtypeDyn reload))
01:08:14 <lambdabot> (line 1, column 23):
01:08:14 <lambdabot> unexpected "_"
01:08:14 <lambdabot> expecting operator or ")"
01:08:33 <EvanR> kellytk: values not in code form?
01:08:34 <martinvlk> @pl (fmap (fmap (\(Entity _ v) -> v)) <$> runApiCheck apiDbRuleListByType (tagDyn rtypeDyn reload))
01:08:34 <lambdabot> (line 1, column 23):
01:08:34 <lambdabot> unexpected "_"
01:08:34 <lambdabot> expecting operator or ")"
01:08:50 <Lokathor> martinvlk, you gotta name that _ as something
01:08:57 <martinvlk> ah okay, ta!
01:09:10 <martinvlk> @pl (fmap (fmap (\(Entity k v) -> v)) <$> runApiCheck apiDbRuleListByType (tagDyn rtypeDyn reload))
01:09:11 <lambdabot> (line 1, column 23):
01:09:11 <lambdabot> unexpected "k"
01:09:11 <lambdabot> expecting operator or ")"
01:09:14 <EvanR> oh god
01:09:30 <EvanR> lambdabot has PM
01:09:58 <Lokathor> oh you're using pl with it. Yeah you can't make your expression into pl form like it is. it's a somewhat limited feature. Also, yes, PM might be best if you need to fiddle a lto
01:10:39 <martinvlk> okay.. I was essentially trying to see if it gives me a simpler form, not necessarily pointfree..
01:10:40 <Lokathor> martinvlk, you need to phrase it as a lambda, basically, otherwise it doesn't know what the points it should be removing are
01:10:41 <EvanR> kellytk: a stateful system reacts differently each time you use it, somehow using mutable variables, and something somewhere messing with them tends to cause this, but there are other ways. 
01:10:56 <EvanR> a stateless system doesnt
01:10:58 <martinvlk> Lokathor: thanks!
01:11:39 <EvanR> but when your system is never used more than once, this distinction disappears
01:11:42 <kellytk> I see that like an interface design agreement
01:11:44 <Lokathor> kellytk, it might also help to say that a stateful system reacts based on things other than the explicit arguments passed
01:11:53 <EvanR> that is the case with "pure state" like State and folds
01:12:18 <srhb> I think conflating state and purity is confusing.
01:12:23 <EvanR> Lokathor: thats like impurity
01:12:58 <EvanR> specifically pure vs not pure functions
01:13:05 <kellytk> What does pure mean here?
01:13:30 <EvanR> a pure function's result is a (math-like) function of its arguments
01:14:15 <EvanR> which you can pull off even using mutable variables behind the scenes
01:14:18 <kellytk> And nothing other than its arguments, with the same result each run correct?
01:14:53 <EvanR> hmm. yes thats implied by being a function of the arguments
01:14:57 <Lokathor> EvanR, it only implies impurity if you ignore that there's implicit arguments passed (in haskell this is generally within one of the 4 monads mentioned, or in other languages just all over the place)
01:15:17 <EvanR> IO actions and state actions arent functions
01:15:25 <kellytk> What are they?
01:15:30 <EvanR> :t getChar
01:15:31 <lambdabot> IO Char
01:15:35 <EvanR> some data 
01:15:43 <kellytk> How is that an action?
01:15:55 <EvanR> i dunno thats just what people call it
01:15:59 <Lokathor> kellytk, "action" is a special term in Haskell
01:16:07 <kellytk> How is IO action and state action used?
01:16:15 <kellytk> Lokathor: What does it mean here?
01:16:18 <EvanR> :t runState
01:16:19 <lambdabot> State s a -> s -> (a, s)
01:16:41 <EvanR> you can run a big state computation by providing the initial state
01:16:45 <kellytk> I don't know Haskell I would need it in English
01:16:55 <EvanR> and you get the answer and the final state
01:16:56 <Lokathor> an action is basically a monadic value that will affect the monad's condition (i'm trying to avoid using the word "state" here) without accepting an argument
01:17:12 <Lokathor> so a function accepts an argument, but an action doesn't accept an argument
01:17:22 <kellytk> That's very interesting
01:17:43 <Lokathor> main :: IO (), main is an action, not a function. putStrLn :: String -> IO (), putStrLn is a function that you give a String and then it becomes an action
01:17:43 <EvanR> if you know unix commands, `ls' or `ps' or `du' are actions
01:18:15 <EvanR> they access the system and give you data back
01:18:18 <kellytk> What does it mean to affect a monad's condition?
01:18:28 <Lokathor> well, depends on the monad
01:18:38 <Lokathor> in IO, it's something that can interact with the real world
01:18:46 <kellytk> Do all actions use external state to generate a value?
01:18:53 <EvanR> no
01:18:55 <Lokathor> no
01:19:02 <johnw> "an action is basically a monadic value that will affect the monad's condition" <-- I do not agree with this statement at all
01:19:03 <kellytk> Do actions operate in a context with which they do their purpose?
01:19:11 <johnw> no affecting happens at any time
01:19:17 <johnw> an IO action does not interact with the real world
01:20:02 <Lokathor> kellytk, i'm not sure i follow the question
01:20:04 <johnw> an IO action is a value that may be handled by the Haskell runtime to cause effects in the real world; but the IO action is a pure value
01:20:04 <EvanR> kellytk: actions are just normal data values, you combine them with >> and >>= to get another action
01:20:32 <EvanR> IO is special in that you never use this value for anything, the runtime system executes it, namely the main :: IO () action
01:20:42 <EvanR> but other monads are more concrete
01:20:48 <EvanR> > Just 4 >> Nothing
01:20:50 <lambdabot>  Nothing
01:20:58 <EvanR> > Just 4 >> Just 5
01:21:00 <lambdabot>  Just 5
01:21:07 <kellytk> Thank you
01:21:17 <EvanR> combining possibly non-existent values
01:21:26 <EvanR> fails if any are non-existent
01:21:32 <Lokathor> yes, anything that's an instance of Monad can be said to have "actions". An action is just some computation that will get you a result once you go perform it
01:22:16 <EvanR> before getting into philosophy, and monads and stuff, you should be familiar with algebraic data types, i think
01:22:27 <EvanR> and probably the Functor class
01:22:40 <kellytk> Is it practical to build web apps with Haskell?  I'll be rewriting a Node.js app in a week and I may feel saucy enough to make this an opportunity to work with an "exotic" language
01:22:46 <liste> if values of type "Monad m => m a" are (colloquially) called actions, then what are values of type "Applicative f => f a" called?
01:22:58 <Lokathor> kellytk, haskell is particularly well suited to web apps
01:23:00 <liste> kellytk: yeah, Web is one of Haskell's strong points
01:23:02 <EvanR> ..... applicative actions .....
01:23:04 <johnw> they are only called "actions"; this naming has no special meaning
01:23:17 <kellytk> It is?  Well that's interesting
01:23:21 <johnw> it's not necessarily a computation, and doesn't necessarily return a result
01:23:38 <EvanR> the term action for all monads or applicatives is annoying to me
01:23:52 <kellytk> Is it a take it or leave it choice where I cannot also use other pieces in my stack such as PostgreSQL, Nginx, ..?
01:23:56 <shachaf> Values of type "Monad m => m a" aren't called much. Maybe you mean values of type "m a" for some Monad m.
01:24:12 <liste> kellytk: sure, there's database access libraries
01:24:34 <Lokathor> kellytk, you can run haskell behind nginx by having nginx forward some connections on to the haskell program
01:24:37 <liste> kellytk: and you can put a reverse proxy in front of a Haskell web app like anything else
01:24:38 <Lokathor> and haskell can talk to all the major db types
01:25:11 <kellytk> I reverse proxy HTTP requests to Node.js using Nginx just the same
01:25:14 <liste> shachaf: yeah, I meant "exists m. Monad m => m a"
01:25:29 <shachaf> Maybe you meant "Monad m *> m a"
01:25:31 <vev> we re looking for voluntary devs to help us on idea creation tools - join us on #libreidea
01:25:46 <shachaf> But "exists m. Monad m => m a" doesn't make sense.
01:25:48 <kellytk> Lokathor: Does that mean Haskell has DB access built into the core language, or that all major DBs have available open source libraries?
01:25:50 <Krikey_Sanchez> if I have a list of integers
01:26:02 <Lokathor> kellytk, there are libraries for each db type
01:26:04 <liste> shachaf: interesting. what's that *> called?
01:26:09 <Krikey_Sanchez> how do I extract sublists of that list, consiting only of streaks of increasing integers?
01:26:17 <Lokathor> kellytk, in fact there are even libraries that will help abstract away the differences between db types
01:26:23 <shachaf> It's not real syntax, but it's the closest to an established syntax.
01:26:26 <Krikey_Sanchez> so, like, [1,2,3,2,2,1,2] -> [[1,2,3],[1,2]]
01:26:35 <shachaf> You could define it with e.g. data k *> a = k => Foo a
01:26:40 <Krikey_Sanchez> I would need some kind of list traversal function that can look at elements pairwise, I would think
01:26:43 <EvanR> Krikey_Sanchez: homework?
01:26:47 <Krikey_Sanchez> unless I'm missing a better way to do this
01:27:01 <EvanR> Krikey_Sanchez: use takeWhile in a loop
01:27:14 <Krikey_Sanchez> EvanR, no, I have an actual problem that is equivalent to this
01:27:17 <kellytk> What are the leading Haskell equivalents to Node.js?
01:27:27 <EvanR> thankfully there arent any
01:27:32 <kellytk> Please go on
01:27:33 <Kaidelong> what do you mean by equivalent to "node.js?"
01:27:40 <MasseR> kellytk: node.js equivalent is haskell?
01:27:46 <Krikey_Sanchez> my actual data can be mapped easily to integers, it's the take while increasing only logic I don't know how to write
01:27:49 <kellytk> Something to accept unix socket-based HTTP requests, for handling
01:27:53 <MasseR> Or do you mean some specific library/framework from node
01:28:00 <Kaidelong> socket
01:28:02 <Lokathor> kellytk, there's a few frameworks and such, but might i suggest that you practice more deeply with Haskell in general before trying to jump into a web app?
01:28:31 <Lokathor> it's very, very different from other languages, and you can get lost easily if you try to do too much at once
01:28:37 <EvanR> Krikey_Sanchez: hrm. well you can zip the list with itself to be able to look at pairs of adjacent numbers
01:28:43 <Kaidelong> well if you want to write a web page you don't really need to learn to handle sockets yourself
01:28:47 <Kaidelong> you could use CGI
01:28:50 <kellytk> Lokathor: The only way I would be able to justify this would be by jumping in with the product I'm working on.  Even if simple in initial scope, at least web app
01:28:56 <EvanR> then group by less than
01:29:20 <MasseR> kellytk: yesod, snap, happstack, scotty, socket.io for them or something like that
01:29:23 <liste> @hackage scotty -- kellytk: this is a Web framework that doesn't use Haskell's more advanced features much
01:29:24 <lambdabot> http://hackage.haskell.org/package/scotty -- kellytk: this is a Web framework that doesn't use Haskell's more advanced features much
01:29:27 <Kaidelong> learning the socket library would mostly be of interest for you to write your own server
01:30:17 <MasseR> Kaidelong: I think he meant websocket with sockets
01:30:24 <MasseR> not tcp sockets
01:31:05 <liste> kellytk: though you need to be familiar with Haskell's build tools first, before you can use libraries
01:31:18 <MasseR> either that or nodes evented framework, which basically comes for free for any haskell web-framework
01:31:30 <MasseR> *underlying evented io
01:31:33 <Kaidelong> kellytk: my personal experience with this is that I switched to F# for the backend and Elm for the frontend after evaluating Haskell
01:31:33 <Lokathor> johnw, i hear what you're saying and all, but i think that fiddling too much with the fine details when you're trying to give the 10,000ft view to a beginner isn't as helpful
01:31:37 <Kaidelong> in this role
01:31:37 <EvanR> er... i can cabal install and use libraries without being able to build anything of my own
01:31:45 <Kaidelong> so don't expect it to work out for you 100%
01:32:28 <EvanR> Lokathor: things are weird enough and subtle enough that giving misleading analogies is probably not good
01:32:30 <kellytk> The project uses WebSockets, but I was referring to the unix socket Nginx currently routes requests to Node.js via
01:32:39 <liste> (by build tools, I meant ghc, cabal-install, perharps stack)
01:33:08 <Kaidelong> Visual Studio and elm-reactor are both great tools that Haskell ecosystem don't have good answers for yet that I've found
01:33:22 <Kaidelong> and tools matter a lot
01:33:36 <kellytk> Kaidelong: May I ask why you decided against using Haskell everywhere?
01:33:44 <MasseR> kellytk: sorry, at least I don't quite understand what you mean by 'unix socket nginx currently routes'
01:33:57 <Lokathor> EvanR, if you care to PM me about each of my mistakes in explanation and also what i should say next time I promise to read them and get back to you; however, for now I must go to sleep.
01:34:09 <kellytk> Thank you Lokathor 
01:34:10 <EvanR> me too
01:34:19 <Kaidelong> kellytk: time to prototype, essentially, particularly working with people who had never seen an FPlang before
01:34:36 <kellytk> MasseR: HTTP requests to Nginx are reverse proxied to Node.js via unix sockets in the current iteration of my web app
01:35:20 <kellytk> How is the job market for Haskell web app dev?  I'm working on a startup of my own but if it fails I'd like to have a marketable plan B skill
01:35:30 <MasseR> ah. I'm not sure if I've seen unix socket used in web frameworks. Not to say that there aren't any
01:35:39 <kellytk> (Node.js/being very plan B)
01:35:44 <Kaidelong> close to zero I think
01:35:47 <Kaidelong> but
01:35:50 <Lokathor> kellytk, my "hello world" stage web program i started the other day looks like this: https://github.com/Lokathor/picon-server/blob/master/src/Main.hs
01:36:06 <kellytk> MasseR: I wasn't speaking about web frameworks, rather HTTP engines for Haskell
01:36:06 <Kaidelong> if you do find a job like that, less competition for it too
01:36:43 <MasseR> kellytk: well the web frameworks use the underlying 'http engines' and there are more web frameworks than http engines :P
01:36:55 <kellytk> Lokathor: That's fun thank you for sharing
01:36:58 <Kaidelong> anyway the particular thing about Elm that made it great was the workflow, it's just like PHP
01:37:06 <Kaidelong> when you want to see a change, you hit refresh in the browser
01:37:16 <Kaidelong> it just works
01:37:18 <Kaidelong> pretty amazing
01:37:18 <MasseR> Well there's a sentence I haven't seen often
01:37:23 <kellytk> That's how I've the Node.js environment set up
01:37:56 <Kaidelong> with F# it was mainly just having a complete editing and debugging environment out of the box
01:38:23 <Kaidelong> although we had to build monodevelop from source for a linux box
01:38:40 <Kaidelong> which was a pain
01:38:44 <MasseR> There's a language I'd like to try at some point
01:39:55 <Kaidelong> (we were using Visual Studio Code for Elm editing, it was alright)
01:40:18 * hackagebot yeshql 0.2.0.0 - YesQL-style SQL database abstraction  https://hackage.haskell.org/package/yeshql-0.2.0.0 (TobiasDammers)
01:42:20 <MasseR> Kaidelong: do you have some description on your setup? libraries, frameworks, glue etc
01:42:26 <kellytk> Kaidelong: On a purely language basis, do you think Elm is better than Haskell?
01:44:01 <Kaidelong> kellytk: No, absolutely not
01:45:04 <Kaidelong> Elm is okay if you want to make a website that will talk to a server, in an MVC model, which is what we wanted to do
01:45:18 <Kaidelong> we tried taking it further on our own time and making a simple chess game with AI
01:46:37 <Kaidelong> Elm is both pure and strict, so if you need performance, the only way to really do it is to interop with javascript
01:46:40 <Kaidelong> and that has overhead
01:47:08 <Xatenev> Heya
01:47:24 <Xatenev> How come Haskell got released 1990 but just got attention months earlier ?
01:47:43 <kellytk> What is your opinion of Haskell v. Clojure?
01:47:51 <Kaidelong> you don't have ST or other constructions for destructive updates and mutable states, and there are none of Haskell's clever optomizations
01:47:52 <EvanR> "avoid success at all costs"
01:47:57 <davean> Xatenev: I think you just happened to hear about it months ago
01:48:32 <Xatenev> davean: Yea but why :O I feel like haskell is 5x as fame as before now.
01:48:39 <merijn> Xatenev: #haskell has had a 1000+ population for years now :)
01:48:46 <MasseR> kellytk: opinion? Burn clojure in fire :). It's okayish for rapid testing, until you start having problems with keeping the underlying 'types' in check in your head. Or you start maintaining it. Or you take over from a previous maintainer. Or ..
01:48:49 <merijn> Xatenev: It's slowly percolating more and more into the mainstream
01:48:54 <davean> Xatenev: Thats a common effect of not realizing how filtered one's internet experiance is
01:49:03 <Kaidelong> MasseR: Arch Linux for server, F# used as a scripting language with CGI, JSON for data exchange, Elm for client side
01:49:10 <Kaidelong> it's not very pretty
01:49:11 <Xatenev> merijn: davean guess so:) thanks
01:49:15 <Kaidelong> but it was done in a rush
01:49:16 <merijn> Xatenev: This has been going on for several years (haskell slowly gaining fame/popularity)
01:49:23 <quchen> Haskell has been a temporary fad for over 25 years now.
01:49:29 <Kaidelong> we might get rid of Elm in favor of Purescript
01:49:48 <merijn> quchen: To be fair, since I started hanging out here and learning haskell I've seen massive growth, so it certainly getting more popular
01:49:51 <Kaidelong> it's easier to set up than GHCJS
01:50:06 <quchen> merijn: My gut agrees :-)
01:50:13 <Kaidelong> might move to Sauve.io with F# to have a proper web server
01:50:18 <kellytk> What does Haskell have in common with lisps?
01:50:28 <merijn> kellytk: "Not a whole lot" :)
01:50:41 <kellytk> Are they as different as Haskell and JavaScript?
01:50:47 <Xatenev> Is there any good list comparing functional programming to object oriented programming (pros and cons) ?
01:51:07 <merijn> kellytk: Well, one thing that I would argue is that both lisp and haskell have a very neat, simple and elegant core language
01:51:25 <merijn> kellytk: But Haskell has more syntactic sugar layered on top of it than lisp, so it's not as obvious to beginners
01:51:35 <Kaidelong> Xatenev: probably not, such a list wouldn't be useful, they are not mutually exclusive and even if they were nobody can seem to agree on what either of the terms mean anymore
01:51:56 <Kaidelong> merijn: Common LISP is not a great beginner language, it wasn't for me anyway
01:52:22 <Kaidelong> syntax sugar is regular, LISP changes syntactic conventions on you all the time because programmers have so much freedom to invent their own
01:52:25 <merijn> Xatenev: I'm assuming you're already a programmer. I've got a question for you: what would you say the biggest problems/sources of bugs are in programming?
01:53:01 <Kaidelong> also static typing is amazing for discoverability
01:53:18 <Xatenev> merijn: Umm..
01:53:27 <merijn> Kaidelong: Sure, I'm not saying lisp is a beginner language, but if you asked me to pinpoint a common ground between lisp and haskell and why they attract people wanting to explore programming I'd say the one thing that I can think of is "elegant core"
01:53:33 <doofin> what is the mathematical Foundation for reactive programming?
01:53:33 <Kaidelong> Common LISP did have a good answer for that in its extensive documentation
01:53:42 <kellytk> merijn: Thank you that was a nice description.  Is Haskell's additional syntax able to, once the additional learning is done, pay dividends over lisp's simplicity?
01:53:55 <Kaidelong> defintiely true, lambda calculus for both, whitespace is application
01:54:06 <merijn> kellytk: I think so :)
01:54:30 <kellytk> "Kaidelong> also static typing is amazing for discoverability" are lisps not statically typed?
01:54:38 <merijn> doofin: "functional reactive programming" or this bastardised "reactive" stuff people are pushing nowadays?
01:54:41 <Kaidelong> not Common LISP, anyway
01:54:44 <quchen> Leveraging the type system cannot be over-praised. Lisps usually don't have that.
01:54:52 <Kaidelong> the most successful typed lists I know about are Qi and Typed Racket
01:54:59 <kellytk> doofin: I would also like to know the mathematical foundation for reactive programming
01:55:03 <merijn> kellytk: I think this talk by Wadler is excellent and covers why I like haskell a lot: https://www.youtube.com/watch?v=IOiZatlZtGU
01:55:03 <Kaidelong> typed LISPs*
01:55:11 <Kaidelong> I haven't tried either
01:55:18 <Kaidelong> so I can't comment on them
01:55:36 <kellytk> I'm a very strong proponent of typing
01:55:47 <kellytk> I'm flexible on the model but really, I like order
01:55:52 <merijn> kellytk: The keypoint he makes was "haskell was discovered" (well, the core haskell is based on, i.e. type lambda calculus) whereas other languages are "invented" (and as Wadler puts it "you can tell, can't you?")
01:56:20 <Kaidelong> doofin: continuous differentiable maps, which is why you need to parameterize time
01:56:25 <merijn> kellytk: Well, in that case I even more strongly recommend that talk, because it covers the mathematical origins of haskell and why all of this makes sense on a theoretical level :)
01:56:33 <EvanR> kellytk: doofin check out the Reactive paper
01:56:38 <merijn> It's also a pretty accessible talk
01:56:41 <kellytk> Thank you for the video link merijn I'll watch it shortly
01:57:00 <merijn> (and fairly funny, for a lecture on logic :p)
01:57:07 <Kaidelong> if you look into some of the original work calculus pops up quite a bit
01:57:12 <Kaidelong> which is unusual for "real programs"
01:58:12 <doofin> but seems that there are also discrete events the
01:58:15 <merijn> doofin: Anyway, for functional reactive programming I think conal's paper are pretty good intros to the theory and ideas of FRP.
01:58:25 <kellytk> My research took me through Leibniz' calculus ratiocinator and characteristica universalis.  What language best reflects his work?
01:58:49 <merijn> doofin: Most frameworks advertised as FRP/reactive are not reactive by conal's definition, and I would agree with him, lemme dig up some links
01:59:09 <Kaidelong> doofin: this is because FRP as it was originally conceived turned out not to map terribly well into the real world, in particular, it allowed you to express nonsense like violations of causality that didn't correspond to any clear semantics on how to run that program
01:59:22 <EvanR> doofin: event processing systems are kind of a weird reinventing of something else which acquired the frp brand
01:59:26 <Kaidelong> modern "FRP" frameworks largely have to ignore the original notion of what FRP was
01:59:39 <merijn> kellytk: Languages like Haskell, ML, ocaml, etc. are all fundamentally built upon various lambda calculi
02:00:00 <merijn> kellytk: Wadler's talk covers the discovery that for every logic there is a corresponding lambda calculus
02:00:15 <EvanR> Kaidelong: but wait, violating causality is ok!
02:00:43 <Kaidelong> oh really?
02:00:54 <Kaidelong> I guess I should write a program that gets stock market data from the future
02:00:56 <Kaidelong> FRP will make me rich
02:01:00 <merijn> doofin: I always recommend the FRAN (http://conal.net/fran/) and Push-Pull FRP (http://conal.net/papers/push-pull-frp/) papers as intros
02:01:08 <EvanR> when i was working on frp, i tried to stick the original semantics, where events were positioned in time, in order
02:01:16 <doofin> seems that reactive programming arise mostly from practical experience ,unlike monad ..
02:01:21 <merijn> Kaidelong: Wait, wut
02:01:23 <Xatenev> Where is the GHC compiler in a windows installation on 7.10.3 ?
02:01:26 <EvanR> and it turned out to make sense to map time forwards or backwards
02:01:32 <Xatenev> Im wondering what directory I have to put into my path :O
02:01:41 <merijn> Kaidelong: "it allowed you to express nonsense like violations of causality" <- explain?
02:01:43 <Xatenev> Got it.
02:02:07 <EvanR> Kaidelong: i had a "pure" version of the library, which literally used Time -> a and [(Time,a)] and so time reversal and predicting the future ought to have worked, but i was getting inefficiencies
02:02:10 <Kaidelong> merijn: you could depend on the future to create a value in the past. Sometimes this made sense, but not when you allow arbitrary IO into the mix
02:02:16 <merijn> Kaidelong: The main issue I'm aware with is "time leaks", i.e. needing to keep track of past indefinitely leading to poor performance. I've never heard of problems with the denotational semantics
02:02:35 <Kaidelong> in theory you could model IO as functions of time
02:02:38 <ggVGc> what's my best course of action if I have a bunch of objects made up of functions, and want them to have an identity, in order to be comparable? Should I just keep them in a dict with enums for each instance?
02:02:42 <EvanR> of course if you executed the program in IO mode, you may get a "acausality" error IF you got an event that was not predicted
02:02:46 <merijn> Kaidelong: The FRP denotational semantics don't have a notion of IO, though?
02:02:48 <Kaidelong> but this doesn't actually work because you can't just give any time you want
02:02:49 <quchen> Xatenev: `stack path` shows you interesting paths
02:03:05 <EvanR> i question an model of IO being some function of time
02:03:19 <EvanR> ignoring IO and just making something that makes sense though, could work
02:03:20 <merijn> Kaidelong: Modelling  IO in FRP is crazy, that way lies madness
02:03:22 <Kaidelong> merijn: right, but this means you can't do FRP as originally envisioned if you need IO
02:03:31 <Kaidelong> you need to complicate things
02:03:32 <merijn> Kaidelong: You'd need a denotational semantics of IO, which doesn't exist
02:03:37 <EvanR> Kaidelong: this isnt true
02:03:48 <merijn> In fact, I'm not sure a denotational semantics of IO *could* exist
02:03:53 <EvanR> theres a lot of assumptions that can kill FRP ideas
02:03:58 <EvanR> that are unfounded
02:04:22 <merijn> Kaidelong: Nonsense, you just need a way to convert IO into FRP things. IO should correspond to events
02:04:32 <merijn> They can happen at any time
02:04:55 <merijn> Kaidelong: reactive, reactive-banana, all handle IO just fine...
02:04:56 <EvanR> well events that happen at any time is only a particular kind of IO, namely, I
02:05:01 <Kaidelong> pure FRP can model discrete events as functions over time
02:05:19 <EvanR> events as signals is annoying
02:05:22 <Kaidelong> but you need events from IO to be something separate, something new
02:05:23 <merijn> Kaidelong: Events and Behaviours are different
02:05:32 <merijn> Kaidelong: Why can't IO be an Event?
02:06:18 <Kaidelong> merijn: isn't the choice to make it an event exactly how people break from FRP?
02:06:21 <EvanR> answering how IO even plays into anything is a huge quagmire in this topic
02:06:27 <merijn> Kaidelong: No
02:06:35 <merijn> Kaidelong: The lack of Behaviours is
02:06:57 <Kaidelong> well I guess you can still come up with graphs for the pure part that work the same and then hook up the events
02:07:06 <merijn> Kaidelong: My and conals objection isn't that people treat IO as Event, it's that their system ONLY has Events and no Behaviour
02:07:06 <Kaidelong> you need to anyway, if just to hook up a clock
02:07:17 <EvanR> Kaidelong: frp is not really about graphs
02:07:21 <Kaidelong> okay fair enough, I misunderstood that
02:07:45 <lpaste> magthe pasted “Rigid type error” at http://lpaste.net/154788
02:08:10 <magthe> I'm having a hard time understanding the rigid type error above :(
02:08:22 <merijn> Kaidelong: You might want to builtin some special "pull" IO as Behaviour directly (say, clock values that can always be obtained), but those shouldn't be blocking and tbh, that's not that interesting to me
02:08:25 <Kaidelong> usually that means you need a RankNType
02:08:32 <Kaidelong> lemme see if I can figure it out though
02:08:38 <merijn> That or ScopedTypeVariables
02:08:48 <merijn> Impossible to tell without source, though
02:09:16 <lpaste> magthe revised “Rigid type error”: “No title” at http://lpaste.net/154788
02:09:21 <EvanR> merijn: a lot of things act like behaviors, getting a webpage, reading a small file, getting a database snapshot (datomic-like), checking the clock, random variables
02:09:28 <kellytk> Thank you merijn 
02:09:44 <Kaidelong> @hoogle foldFree
02:09:45 <lambdabot> No results found
02:09:51 <magthe> merijn, Kaidelong: sorry about that, added the code
02:10:13 <EvanR> and unfortunately, the joystick support in OSes
02:10:16 <magthe> foldFree comes from Control.Monad.Free
02:13:05 <Kaidelong> magthe: why is the second case commented out?
02:13:57 <magthe> Kaidelong: just me trying to concentrate on one thing at a time
02:14:42 <magthe> same error with both cases (I'll adjust the paste)
02:15:03 <lpaste> magthe revised “Rigid type error”: “No title” at http://lpaste.net/154788
02:15:27 <kellytk> Are there web dev teams using Haskell that write about their experience?
02:15:54 <EvanR> theres HaskellCEO on twitter
02:15:59 <Kaidelong> magthe: I think you need ScopedTypeVariables
02:17:10 <Kaidelong> try factoring out f to the top level and see if that helps, though
02:17:53 <mniip> magthe, what's " a type expected by the context: S LogF SimpleFileF x -> IO x          at Free2.hs:46:16"
02:18:03 <quchen> kellytk: Well, FPComplete does a lot with Yesod, and I think Pusher published a few articles recently. But those aren't on webdev exclusively (or even mostly).
02:18:05 <mniip> there are no 'x' tyvars in the code you posted
02:18:10 <Kaidelong> eitherS f _ (A1 x) = f x; eitherS _ g (A2 x) = g x
02:18:16 <Kaidelong> then
02:18:25 <Kaidelong> rather than f, use
02:18:34 <Kaidelong> (eitherS f1 f2)
02:19:31 <merijn> EvanR: You mean because you can stream those things?
02:19:42 <Kaidelong> at the very least it might make the error clearer
02:20:21 <merijn> EvanR: I mean, I certainly wouldn't argue AGAINST adding primitives to turn, e.g., streaming IO into Behaviours. I'm just saying that's not the part that makes those things "not FRP" to me :)
02:20:24 <magthe> mniip: exactly, I'm not sure what the 'x' is doing there
02:20:42 <kellytk> Thank you quchen 
02:21:31 <Kaidelong> isn't HaskellCEO a troll account?
02:21:39 <lpaste> magthe annotated “Rigid type error” with “Rigid type error (annotation)” at http://lpaste.net/154788#a154791
02:21:51 <magthe> Kaidelong: you mean something like that annotation there?
02:21:58 <Kaidelong> yeah
02:22:06 <merijn> The guy who wrote BazQuux (the RSS reader) wrote a bunch of stuff on his experience using Ur/Web and Haskell for it, afaik
02:22:23 <Kaidelong> maybe with a type signature, though
02:22:38 <kellytk> Is anyone familiar with Leibniz' work on https://en.wikipedia.org/wiki/Characteristica_universalis and https://en.wikipedia.org/wiki/Calculus_ratiocinator
02:22:46 <Kaidelong> that is probably a function you should factor out anyway
02:22:55 <lpaste> magthe annotated “Rigid type error” with “Rigid type error (annotation) (annotation)” at http://lpaste.net/154788#a154792
02:23:06 <magthe> Kaidelong: that errors out in a similar way
02:24:30 <Kaidelong> magthe: would you give f an explicit type signature? Without it the error probably would be the same
02:24:45 <Kaidelong> I'm surprised that didn't hit the monomorphism restriction, actually
02:24:47 <merijn> kellytk: Not really, but scanning the wikipedia I think that this is related to the usual computability questions?
02:25:08 <kellytk> I'd like to find the nearest language that exists to it
02:25:13 <EvanR> merijn: no not streaming, just that you can check them at any point
02:25:18 <EvanR> like it was a variable
02:25:44 <EvanR> streaming means you are getting data incrementally or in packets determined by the source
02:25:51 <EvanR> im talking about polling
02:26:15 <merijn> kellytk: "theoretical universal logical calculation framework" <- the problem with this is Gödel's incompleteness theorem :) You can't have such a framework that is both complete (i.e. universal) AND sound (doesn't allow contradictions)
02:26:39 <kellytk> I'm not so sure
02:26:41 <merijn> EvanR: That's something of a higher primitive that you could implement using lower FRP primitives
02:26:48 <merijn> kellytk: Not so sure about what part?
02:27:03 <Kaidelong> Gödel Completeness is not really that useful to talk about
02:27:08 <kellytk> The Godel fellow you mentioned
02:27:22 <EvanR> merijn: heh. well this is the primitive
02:27:29 <Kaidelong> when I was studying logic in formal education they never used Gödel's idea of completeness
02:27:35 <EvanR> the idea of a thing that has a value at any point in time
02:27:41 <Kaidelong> proofs that systems are both sound and complete were the norm
02:27:54 <EvanR> but if youre talking or thinking about a specific set of primitives id be glad to hear which one
02:28:03 <Xatenev> $ ghc -O2 --make A.hs -threaded -rtsopts
02:28:16 <Xatenev> Lol nvm
02:28:29 <merijn> EvanR: The problem with using it as a direct primitive (I'm guessing you mean something pull based) is tricky because fetching pages is blocking
02:28:56 <merijn> EvanR: There's a value in supporting pull IO primitives (like I suggested for the clock), but allowing them to be blocking is theoretically unsound
02:29:02 <EvanR> merijn: sure, that one is stretching it
02:29:11 <merijn> Xatenev: FYI, --make is redundant nowadays, it's automatic
02:29:12 <EvanR> merijn: all IO queries take some time
02:29:20 <merijn> EvanR: Checking the system clock does not
02:29:26 <EvanR> ... yes it does
02:29:27 <merijn> EvanR: Or at least negligible
02:29:39 <Xatenev> merijn: oh thanks :)
02:29:43 <merijn> EvanR: Compared to any other FRP computations that time is nonexistent
02:29:44 <EvanR> so "theoretically unsound" isnt the right way to put it
02:30:03 <cocreature> Kaidelong: gödel’s completeness theorem is about systems containing the natural numbers, so systems that are sound and complete can ofc exist, they just can’t express all theorems on natural numbers
02:30:07 <EvanR> youre referring to concrete FRP things heh
02:30:12 <EvanR> soehow
02:30:34 <EvanR> which framework is this discussion assuming anyway
02:30:34 <Xatenev> Wheres the difference between o2 and o?
02:30:35 <merijn> Kaidelong: There's plenty of systems that are complete and sound, but they can't be universal :)
02:30:49 <Xatenev> as compile option for ghc I mean
02:31:47 <Kaidelong> magthe: any luck?
02:31:55 <EvanR> merijn: what part of blocking does not appeal to you, that it implies it will take longer than not blocking ?
02:31:59 <merijn> kellytk, Kaidelong: I mean, this is the reason why there's so much research going into total languages, how expressive can we make a system (how close can we get to universality) without losing soundness or completeness
02:32:18 <lpaste> magthe annotated “Rigid type error” with “Rigid type error (annotation) (annotation)” at http://lpaste.net/154788#a154793
02:32:33 <kellytk> merijn: Is "total language" the term being used for this?
02:32:42 <magthe> Kaidelong: nope, error remains
02:32:43 <EvanR> merijn: reactive is implemented with many things that are blocking ;)
02:32:52 <merijn> EvanR: It disrupts the continuity of the denotational semantics. A Behaviour has a value at ALL points in continuous time
02:32:56 <Kaidelong> okay well
02:32:59 <merijn> EvanR: Yes, but they are Events, not Behaviour
02:33:05 <Kaidelong> now we know it is a problem with runSum, specifically, somehow
02:33:26 <merijn> kellytk: Total languages are terminating languages, i.e. language for which the Halting problem does not exist. This necessarily implies they are NOT Turing complete
02:33:30 <EvanR> merijn: it has a value at all points in time, but you cant observe this anyway, you can only poll at points in time
02:33:42 <EvanR> as an external observer you are limited to polling at points in time
02:33:47 <merijn> kellytk: The current research is focussed on "how close can we get to the expressivity of Turing completeness without losing termination"
02:34:11 <EvanR> and non-blocking doesnt solve that
02:34:24 <merijn> EvanR: My point is that you either need to prefetch the page to have a value to return at time X, or computing at time X blocks until time Y
02:34:35 <EvanR> well thats an optimization
02:34:49 <EvanR> the point is that it makes sense to check a webpage at any point in time
02:34:49 <merijn> EvanR: It's not an optimisation. It's impossible
02:34:56 <merijn> EvanR: It's the cache invalidation problem
02:34:57 <EvanR> its not impossible
02:35:07 <merijn> EvanR: You need to know to fetch the page before it's value is required
02:35:14 <EvanR> unless its proof by lack of imagination ;)
02:35:41 <merijn> EvanR: You can't compute using the value of a webpage at time X unless it's fetched before time X
02:35:50 <merijn> but you don't know in advance that it'll be required
02:35:54 <EvanR> implicit in your gripe is that it will take time=10 instead of time=1, which ... doesnt seem like a theoretically unsound situation
02:36:08 <merijn> Which is why I said such a behaviour can be implemented in FRP, it just can't be primitive
02:36:31 <merijn> EvanR: I'm not saying it can't be done, I'm saying it can't be a primitive
02:36:38 <EvanR> as far as the system is concerned, that is its value at that time
02:36:58 <merijn> EvanR: Then you can have "Behaviour Webpage", merely "Behaviour (Maybe Webpage)"
02:37:00 <Kaidelong> magthe: okay so I think the problem is that "foldFree" is expecting something in the form (forall x. f x -> g x), a natural transformation
02:37:01 <milesrout> haskell is fucking amazing
02:37:03 <merijn> s/can/can't
02:37:05 <milesrout> it's so fucking amazing
02:37:06 <milesrout> i love it
02:37:08 <EvanR> well thats fine, though to keep talking about "the" primitives of frp seems a bit overspecific when were not talking about any model in particular
02:37:14 <Kaidelong> but Haskell is restricting your result of f to be of a particular type for some reason
02:37:17 <kellytk> I'm surprised lisps are getting more web dev attention (such as om) than Haskell
02:37:33 <milesrout> web dev seems perfect for haskell
02:37:34 <merijn> EvanR: Well, if we're talking "fetching webpages" we are overspecific anyway, as that assumes lots of things :)
02:37:34 <Kaidelong> what happens if you change the type of f to
02:37:53 <merijn> kellytk: Webdev have poor taste in languages :p
02:37:53 <EvanR> i wish i never used that particular example
02:38:03 <EvanR> "check the hard drive sector"
02:38:05 <milesrout> webdev people use javascript and php
02:38:18 <merijn> EvanR: If you'd used "clock", like I did, we wouldn't be having a discussion at all :)
02:38:28 <Kaidelong> f :: (forall a. LogF a -> IO a) -> (forall a. SimpleFileF a -> IO a) -> (S LogF SimpleFileF a -> IO a)
02:38:30 <EvanR> and no, you wouldnt model it as a maybe hard drive sector, since youre modeling it as a behavior
02:38:32 <merijn> kellytk: Witness the popularity of JS and node :)
02:38:35 <Kaidelong> can you use this type?
02:38:43 <Kaidelong> if you can't use this type, I think you can't use foldFree here
02:38:49 <EvanR> merijn: i did use the clock as an example, which itself is also "theoretically unsound" in your view
02:38:54 <milesrout> I've heard of these free monad things
02:38:57 <milesrout> is there a good article on them
02:39:22 <EvanR> the value of the clock can never be correctly discovered at any time t
02:39:32 <kellytk> milesrout: What about Haskell seems perfect for building web apps?
02:39:46 <EvanR> its inaccurate, but you can change your idea of what is correct
02:40:25 <milesrout> kellytk, everything about it, honestly. the way it allows you to differentiate at the type system between strings that have been sanitised and those that haven't, for example
02:41:35 <kellytk> I can see that being useful
02:42:13 <rydgel> Is Netwire still in development?
02:42:25 <magthe> Kaidelong: with RankNTypes on that seems to pass muster, with only a warning that one of the 'forall a' shadows another
02:42:50 <Kaidelong> well you can use a b for the second
02:42:55 <merijn> rydgel: It was last I checked?
02:43:23 <rydgel> merijn: last commit seems to be December 30, 2014
02:43:49 <magthe> Kaidelong: yupp, realised that too :)
02:44:02 <Kaidelong> anyway this is a stricter type
02:44:12 <Kaidelong> it might ruin the plans you had for it
02:44:32 <merijn> rydgel: hmmm, that's longer than I remembered. You can try emailing him, he was pretty responsive last time I did
02:45:03 <rydgel> merijn: I'm still looking at darcs, maybe it moved to github or something
02:45:20 * hackagebot nonempty-alternative 0.4.0 - NonEmpty for Alternative types  https://hackage.haskell.org/package/nonempty-alternative-0.4.0 (guaraqe)
02:45:31 <kellytk> https://gist.github.com/honza/5897359 is interesting
02:45:32 <magthe> I'll see if I can get to where I want to go
02:45:43 <magthe> thanks for the help!
02:46:19 <milesrout> I've heard of these free monad things is there a good article on them?
02:46:46 <quchen> ?google stackoverflow what are free monads
02:46:47 <lambdabot> http://stackoverflow.com/questions/13352205/what-are-free-monads
02:46:47 <lambdabot> Title: haskell - What are free monads? - Stack Overflow
02:46:48 <raidenfreeman> I'm following "learn you a haskell", and I'm getting this error message http://imgur.com/qaVEhje while expecting this http://imgur.com/lj6sbVH . I'm using GHCI v7.10.3 and the tutorial is at 6.X . Why am I getting such a less descriptive error?
02:46:57 <quchen> milesrout: That SO post might be a good start
02:47:13 <rydgel> I learned Yampa tho, but I wanted to see the differences.
02:47:14 <milesrout> thanks dude
02:47:28 <merijn> raidenfreeman: Missing a type signature
02:47:31 <milesrout> it's always hard to know if the best google results are necessarily the best results in reality
02:47:48 <ggVGc> milesrout: https://twitter.com/HaskellCEO/status/686236379551002625
02:47:51 <ggVGc> :)
02:47:53 <merijn> raidenfreeman: GHCi (unlike GHC) has "extended defaulting", i.e. it guesses more when type are unknown
02:48:07 <raidenfreeman> merijin: I know that, it's supposed to happen, I'm wondering why my error message is less descriptive than the tutorials
02:48:08 <merijn> raidenfreeman: In this case specifically it's guessing "String -> ()"
02:48:18 <milesrout> ggVGc, shouldn't your name be ggcG?
02:48:25 <merijn> raidenfreeman: Because the tutorial assumes you're using ghc
02:48:33 <merijn> raidenfreeman: Try putting it in a .hs files and compiling
02:48:34 <ggVGc> milesrout: http://ggvgc.com
02:48:41 <merijn> raidenfreeman: You will get the descriptive error
02:48:42 <raidenfreeman> ok tyvm!
02:49:26 <merijn> raidenfreeman: That was my point, ghci tries to guess what you meant more than GHC. i.e. GHC sees "String -> a" and goes "can't tell what 'a' is!", whereas ghci goes "welp...you probably meant ()!" and then complains it can't parse "5"
02:49:41 <merijn> raidenfreeman: Note that the example is a compile time error, whereas the ghci error is a runtime error
02:49:47 <merijn> > read "5" :: ()
02:49:49 <lambdabot>  *Exception: Prelude.read: no parse
02:49:51 <merijn> > read "5"
02:49:53 <lambdabot>  *Exception: Prelude.read: no parse
02:49:55 <merijn> hmmm
02:50:02 <merijn> guess lambdabot also has extended defaulting
02:50:11 <milesrout> ggVGc, anyway lol
02:50:17 <haskell311> hi
02:50:27 <merijn> raidenfreeman: After putting it in a .hs file and compiling, try adding a ":: ()" annotation and you'll see it'll compile but fail at runtime
02:50:54 <merijn> raidenfreeman: (Which, incidentally, is why you should Text.Read.readMaybe instead of read :))
03:10:02 <merijn> bah, I hate it when I run into functions whose argument order is really inconvenient for partial application... 
03:10:29 * hackagebot miku 2016.3.16.1 - A minimum web dev DSL in Haskell  https://hackage.haskell.org/package/miku-2016.3.16.1 (JinjingWang)
03:15:29 * hackagebot hspec-wai 0.6.6 - Experimental Hspec support for testing WAI applications  https://hackage.haskell.org/package/hspec-wai-0.6.6 (SimonHengel)
03:19:45 <merijn> Anyone know of a way to avoid this redundancy when using getAddrInfo http://lpaste.net/5558942438539657216 ?
03:45:30 * hackagebot partage 0.1.0.1 - Parsing factorized  https://hackage.haskell.org/package/partage-0.1.0.1 (JakubWaszczuk)
03:47:48 <rydgel> does Haskell has some sort of HotCode swapping/reloading
03:48:03 <rydgel> basically I want to develop a game as the game runs
03:49:00 <simpson> rydgel: There's a couple techniques, but nothing built into the language.
03:49:03 <Kaidelong> it doesn't
03:49:50 <simpson> rydgel: The basic idea is to split your game into some pile of "dynamic" files that can change, and some "static" Haskell that both understands how to interpret the dynamic files to have a game, and also how to reload those files when they change.
03:50:10 <simpson> And the dynamic files usually end up being some dynamic language, like Lua, that is well-built for the purpose.
03:50:34 <simpson> I eventually want to do this with Monte as the dynamic language, but writing code is hard, so I don't have anything to show.
03:52:07 <rydgel> I see
03:52:15 <merijn> Is there a library that exposes ContT versions of bracket and friends?
03:52:57 <gromak> Is it safe to use `getPOSIXTime` and `randBytes` (from OpenSSL.Random) from within unsafeIOToSTM?
03:53:30 <fr33domlover> merijn, iirc you can directly wrap bracket with ContT? something like: val <- ContT $ bracket x y z   ?
03:53:35 <merijn> gromak: If you like potentially debugging horrific races :)
03:53:49 <merijn> fr33domlover: Sure, but I was hoping to avoid that messiness :p
03:54:34 <fr33domlover> merijn, i was looking for that too some weeks ago, didn't find anything useful but i also didn't look very thorughly :P
03:55:47 <fr33domlover> rydgel, there's a library that works like xmonad
03:55:55 * fr33domlover goes to hackage search
03:56:41 <fr33domlover> ah, dyre
03:56:51 <fr33domlover> but it's just for dynamic config
03:57:07 <fr33domlover> rydgel, check out how "yesod devel" works
03:57:13 <rydgel> fr33domlover: interesting
03:57:25 <fr33domlover> it automatically discovers file changes and rebuilds and reruns the app
03:59:21 <rydgel> fr33domlover: yeah, it reruns it. But I wanted to develop as the game is running without having to restart it. But I guess it's hard with the way Haskell is. I know Java can do it, but it's probably thanks to the JVM.
03:59:22 <fr33domlover> rydgel, i'd also try a web search for some blog posts because i think it's a generally interesting issue in the haskell game dev community (there are many game related tools for haskell, it seems)
04:00:04 <fr33domlover> rydgel, i believe other people already asked this in the past, try a web search and ask in the ML :)
04:00:25 <fr33domlover> so that you know what the state-of-the-art is in this area
04:00:55 <rydgel> fr33domlover: sure
04:02:45 <rydgel> anyway game development is interesting
04:02:50 <rydgel> especially with FRP
04:03:29 <rydgel> gloss/glfw-b is an issue tho (on OS X), ghci is crashing.
04:03:33 <rydgel> But SDL2 is fine
04:04:37 <rydgel> I made a cool flappy bird game with sounds and stuff. I would like to start a series of blog post on haskell game development
04:04:56 <rydgel> Looking for a simple and funny game to code first
04:05:52 <rydgel> And my heart can't decide if I prefer Yampa or Netwire
04:20:40 <simpson> rydgel: Java's code reloading involves a lot of reflection. GHC isn't really designed for that sort of thing, so you'd either have to use hint (which would incur a relatively steep penalty) or design a Haskell runtime that has that sort of reflection.
04:23:14 <hpc> you might also be able to do some dll trickery
04:23:38 <hpc> or http://hackage.haskell.org/package/plugins
04:35:31 * hackagebot language-javascript 0.5.14.3 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.14.3 (ErikDeCastroLopo)
04:37:17 <ondrejj> Hello. Is there an easy way to transform MVector CCchar -> Ptr CChar? I am using unsafeForeignPtrToPtr . (\(ptr,_,_) -> ptr) . V.unsafeToForeignPtr
04:37:31 <ondrejj> but that doesn't seem good.
04:47:00 <merijn> fr33domlover: oh, looks like Tekmo's Managed is a good way to do this
04:48:02 <quchen> Yes, managed is a specialized ContT for stuff like bracket
04:48:21 <quchen> See the post about the service pattern for a good use case
04:48:21 <quchen> ?google haskell service pattern
04:48:23 <lambdabot> https://www.fpcomplete.com/user/meiersi/the-service-pattern?show=tutorials
04:50:14 <merijn> Having to continually liftIO inside the runManaged is a bit annoying, but ok
04:52:43 <fr33domlover> merijn, but but... where are the wrappers?
04:52:53 <fr33domlover> you still do: managed $ withFile .....
04:53:03 <fr33domlover> just like ContT $ withFile $ ...
04:53:31 <fr33domlover> i think i saw that lib when i was logging
04:53:33 <fr33domlover> *looking
04:53:37 <merijn> fr33domlover: Easier to use Managed as base monad
04:53:48 <merijn> ContT doesn't play nicely with lots of other stuff
04:54:12 <merijn> Although not much more convenient, I suppose
04:55:59 <fr33domlover> i'll try it if/when i get back to the project where i started using ContT... a terminal emulator written in Haskell. That lead me to writing a new X11 client lib which is boring like everything about X11.... :P
04:57:14 <rydgel> someone tried the frp reflex framework?
04:58:14 <merijn> fr33domlover: Do you have the source somewhere? (Of your terminal emulator), I've been meaning to work on a tmux/screen-alike in haskell, but that means reimplementing a lot of the terminal emulator...I've looked at vty a bit, but more examples is always good :)
04:59:28 <fr33domlover> merijn, i have the source but it doesn't touch the terminal code stuff yet. i find the source code of the suckless 'st' terminal useful because it's small
04:59:39 <fr33domlover> (but many things don't work on it so don't rely just on it)
05:02:19 <fr33domlover> merijn, ah, also this: github.com/dimkr/tty8
05:02:32 <fr33domlover> i didn't look but it should be a minimal multiplexer in C
05:03:34 <fr33domlover> merijn, another example is how emulation in SSH works, i suppose openssh and libssh implement that
05:04:34 <lpaste> montanonic pasted “myLines” at http://lpaste.net/170186451311394816
05:05:02 <montanonic> \me didn't intend to do that; oops
05:05:04 <montanonic> wow
05:05:12 * montanonic didn't intend to do that either
05:50:34 * hackagebot wai-extra 3.0.14.3 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.14.3 (MichaelSnoyman)
05:52:28 <Gurkenglas> :t \s -> unfoldr $ fmap (second (dropWhile (== s)) . break (== s)) . mfilter (not . null) . pure -- no explicit recursion!
05:52:29 <lambdabot> Eq a => a -> [a] -> [[a]]
05:54:13 <ertes> > (\s -> unfoldr $ fmap (second (dropWhile (== s)) . break (== s)) . mfilter (not . null) . pure) 'a' "abcadeaaa"
05:54:15 <lambdabot>  ["","bc","de"]
06:01:55 <Javran> hi all, I have a question about extensible-effects, in GHCi `runLift (liftIO (putStrLn "Hello"))` works but I don't know how it is managed to find MonadIO instance?
06:04:28 <ertes> :t \s -> unfoldr (\xs -> case break (== s) xs of ([], []) -> Nothing; (pfx, sfx) -> Just (pfx, dropWhile (== s) sfx))
06:04:29 <lambdabot> Eq a => a -> [a] -> [[a]]
06:05:44 <ertes> less clever = more readable =)
06:06:26 <Javran> https://hackage.haskell.org/package/extensible-effects-1.11.0.2/docs/Control-Eff-Lift.html nvm, I think I got it
06:08:03 <Javran> but why isn't it considered orphan instance? it's not defined in the same place as MonadIO, nor the same place as Free, as Eff is just a type synonym
06:08:56 <merijn> hmmm
06:09:13 <Gurkenglas> :t \s -> evalState $ manyLazy $ modify (dropWhile (== s)) >> mfilter (not . null) (state $ break (== s)) -- enough clever can turn it around again
06:09:15 <lambdabot> Eq a => a -> [a] -> [[a]]
06:09:52 <lyxia> Javran: liftIO is from effect-handlers I suppose, not transformers
06:10:18 <Gurkenglas> (manyLazy from http://lpaste.net/150858 is pretty much the same as many, except that it's lazy and transforms stuff like StateT s Maybe into stuff like StateT s Identity = State s, because many can't be empty)
06:10:58 <lyxia> Javran: oh no I'm confused
06:11:16 <merijn> Any pipes experts know how to nicely mix pipes-concurrency and pipes-parse? My parser results in a 'Producer a m (e, Producer b m r)' which can't be composed with the 'Consumer a m ()' that I get from "toOutput"
06:13:10 <Gurkenglas> Naming question: If f' is strict when f is lazy, what is lazy when g is strict?
06:13:43 <fr33domlover> Gurkenglas, gLazy ?
06:14:10 <benzrf> Gurkenglas: just name g g' to begine with :]
06:14:30 <Gurkenglas> If it was my place to say, many would have been lazy to begin with :[
06:14:41 <Gurkenglas> Gotta get around to writing that proposal at some point
06:15:19 <ertes> :t unfoldr (mfilter (not . null . fst) . pure . break (== ',') . dropWhile (== ','))
06:15:20 <lambdabot> [Char] -> [[Char]]
06:15:23 <ertes> uh
06:15:38 <ertes> :t \c -> unfoldr (mfilter (not . null . fst) . pure . break (== c) . dropWhile (== c))
06:15:39 <lambdabot> Eq a => a -> [a] -> [[a]]
06:16:39 <magthe> Kaidelong: I can report that it all worked out just fine :)
06:16:58 <benzrf> ertes: that's unreadable
06:17:16 <ertes> benzrf: readability doesn't seem to be Gurkenglas' concern =)
06:17:25 <ertes> i wouldn't write it that way in real code
06:17:25 <Kaidelong> excellent!
06:20:08 <magthe> Kaidelong: it'll hopefully make it into a blog post shortly :)
06:23:42 <Kaidelong> magthe: it actually wound up helping me too, I was trying to figure out phi for the free monad a while back, I think it's just foldFree
06:23:55 <Kaidelong> althought foldFree doesn't close back to Set
06:31:17 <Gurkenglas> :t \s -> takeWhile (not . null) . unfoldr (Just . break (== c) . dropWhile (== c)) -- why's there no unfoldr without Maybe?
06:31:18 <lambdabot> r -> [Expr] -> [[Expr]]
06:35:44 <cocreature> merijn: what do you expect to happen to the result?
06:35:47 <mniip> Gurkenglas, what's the purpose of that
06:35:56 <mniip> :t unfoldr
06:35:58 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
06:37:12 <Gurkenglas> :t \c -> takeWhile (not . null) . unfoldr (Just . break (== c) . dropWhile (== c)) -- I meant to post this, and it was just a back-and-forth between me and ertes about how to write unlines
06:37:14 <lambdabot> Eq a => a -> [a] -> [[a]]
06:37:18 <merijn> cocreature: I expect to end up with an Effect that gives an error for early termination on either side
06:37:20 <Gurkenglas> *linesBy
06:37:25 <mniip> :t \f -> map snd . iterate (f . snd) . (undefined,)
06:37:27 <lambdabot> (b -> (a, b)) -> b -> [b]
06:37:36 <mniip> er
06:37:45 <mniip> :t \f -> map fst . iterate (f . snd) . (undefined,)
06:37:46 <Gurkenglas> yea a tail at the end there
06:37:47 <lambdabot> (b -> (a, b)) -> b -> [a]
06:38:26 <merijn> cocreature: Right now I can either 1) drop the parse error on the floor or 2) pretend toOutput can't early terminate using evil voodoo
06:39:24 <Gurkenglas> > (\f -> map fst . iterate (f . snd) . (undefined,)) (splitAt 2) "abcdefg"
06:39:27 <lambdabot>  ["*Exception: Prelude.undefined
06:39:37 <Gurkenglas> > (\f -> tail . map fst . iterate (f . snd) . (undefined,)) (splitAt 2) "abcdefg"
06:39:39 <lambdabot>  ["ab","cd","ef","g","","","","","","","","","","","","","","","","","","",""...
06:41:04 <cocreature> merijn: can you just fmap Left on the parser and fmap (const (Right ()) on the consumer and then combine them?
06:42:18 <Cypi> Hi. I'm trying to install a package with cabal. First step: get a fresh installation of ghc version 7.4.1 (provided by the system's package manager). Second step: "cabal install cabal cabal-install". This does not work because mtl cannot be installed, because "cabal: At least the following dependencies are missing: transformers ==0.4.* && ==0.5.2.0". What should I do?
06:42:27 <merijn> cocreature: Maybe I should just use SafeT and throw an exception in both cases...
06:50:41 <magthe> Kaidelong: I'm not sure what phi is, beyond it beeing a Greek letter...
06:53:01 <Kaidelong> magthe: neither am I, at this point, but it seems to be a function that proves the universal property for a free structure
06:54:24 <magthe> sounds useful, especially if someone else defines it and proves it, so I can use it without having to think too much about :)
07:00:04 <merijn> hmmm
07:00:25 <hexagoxel> Cypi: can you lpaste the full output?
07:00:38 <merijn> I want to spawn two threads that have handlers to kill each other when they die. Is there something for this already or am I best of using IO's MonadFix instance for this?
07:06:38 <zelenooka> Is there a package for something like a resource pool, but with a set of values. So you that it blocks in set is empty and grabs first one released? I'm sure there should be
07:06:50 <zelenooka> blocks if set is empty
07:07:17 <Cypi> hexagoxel : http://pastebin.com/XF0m9MjJ
07:12:11 <hexagoxel> Cypi: "There are files missing in the `mtl-2.2.1' package" did you delete ~/.cabal at some point? either way, you can either delete your user package db by deleting ~/.ghc or clean up affected packages manually.
07:13:10 <Cypi> This is literally the first time I did "apt-get install ghc" and then "cabal update" and then "cabal install cabal cabal-install"
07:17:32 <Cypi> I tried again after deleting ~/.ghc: same result
07:20:11 <hexagoxel> Cypi: and you have tried `cabal install mtl-2.2.1` already, right?
07:20:45 <reverse_light> Hello, I started learning Haskell for configuring Xmonad to make Xmonad great again. Nice to meet you.
07:21:27 <Cypi> Yes. Same result of course: "cabal: At least the following dependencies are missing: transformers ==0.4.* && ==0.5.2.0"
07:22:04 <fr33domlover> hello reverse_light 
07:22:56 <hexagoxel> (also i really have no clue how this error would occur on a clean install.)
07:23:04 <hexagoxel> Cypi: what cabal version are you currently using?
07:24:00 <Cypi> hexagoxel : cabal --version returns "cabal-install version 0.14.0 using version 1.14.0 of the Cabal library"
07:26:06 <hexagoxel> Cypi: that's .. rather old. out of curiosity, what os are you on, exactly?
07:26:17 <Cypi> It's a 12.04 LTS, I know :/
07:26:35 <Cypi> I was hoping to be able to upgrade Cabal from this.
07:26:42 <Cypi> (Ubuntu I mean)
07:28:06 <rydgel> Cypi: do you have haskell-platform installed?
07:28:27 <Cypi> Looks like I don't
07:29:05 <kadoban> Cypi: Are you just trying to get a working haskell setup, or do you need this particular version? stack is much easier than all of this stuff, it can install GHC and etc. for you and it's really the best way to go nowadays.
07:29:30 <kadoban> (but it can only do GHC down to version like … 7.8 or something, so if you really need ancient GHC it can't help)
07:30:11 <hexagoxel> Cypi: the alternative route is to bootstrap the current cabal-install. this avoids the currently installed cabal-install, which apparently is broken in some way.
07:30:27 <rydgel> +1 for using Stack if you can
07:31:03 <Cypi> I'll try Stack, that looks good to me. I did not know it existed.
07:31:04 <Cypi> Thanks.
07:32:03 <Cypi> (To answer your question, I want an up-to-date GHC actually)
07:32:11 <Cypi> (well, at least recent)
07:32:17 <kadoban> Ah great, should be a good way to start then.
07:32:18 <rydgel> Cypi: then go Stack, 7.6 is pretty old
07:49:53 <ur> What are the problems with this implementation of a grid?
07:50:02 <ur> data Grid a = Grid   { value :: a   , left, right, down, up :: Maybe (Grid a)   }
07:50:37 <Lokathor> well, you'll have trouble trying to set up your circular references i expect
07:50:41 <Lokathor> though that's just a guess
07:50:54 <opqdonut> that's just a standard tying-the-knot exercise
07:51:12 <opqdonut> that grid is great for local modifications, crappy for random access
07:51:27 <opqdonut> it's effectively a zipper
07:53:43 <ur> wonder how representing a (scrabble) board with that kind of a grid would work out
07:54:31 <ggVGc> that data structure looks like it gives room for easy mismatches of neighbours
07:54:40 <ggVGc> since you'll have to manage the mutual references manually
07:55:17 <ggVGc> but is probably what you'd need if you need easy modifications
07:55:26 <ggVGc> err, efficient modifications I guess I meant
07:55:44 <ggVGc> I would probably use a Zipper (Zipper a) for a grid
07:56:17 <ur> hm, I guess I should look into Zipper. I haven't actually head of that before. Just learning
07:57:08 <ggVGc> ur:  a zipper is essentially "a structure with a focus", but mostly people mean a List Zipper when they say Zipper. A List Zipper is a list, with the notion of a current value
07:57:46 <ggVGc> if you have a Zipper (Zipper a), you have the notion of "focused row" and "focused column"
07:58:14 <ur> Aha, that's interesting
07:58:20 <ggVGc> and yu don't have the problem of making sure te neighbours all match manually
07:58:43 <Cypi> kadoban: It looks like Stack works. I have one last problem: the project I'm trying to build rely on happy/bnfc. They are specified as 'build-tools' in the .cabal file, but Stack won't install them. What is the correct way to have them installed?
08:03:33 <zipper> Man having the name zipper and being in the haskell channel isn't easy.
08:03:42 <kadoban> Cypi: You can just do 'stack install happy' and it'll go into ~/.local/bin/, which you should add to your PATH
08:03:57 <kadoban> Cypi: Probably same for the other, though I've never heard of it.
08:04:58 <Cypi> Ah, thanks
08:05:17 <Cypi> aaand, of course it does not work for bnfc indeed :)
08:05:33 <Cypi> Ah. It works with BNFC...anyway, thanks
08:07:47 <ur> zipper: oh hey, we were just talking about you
08:23:19 <Luke> What's the best way to make a UTF8 encoded decimal of a double in Data.Text?
08:23:24 <Luke> I feel like I'm missing something obvioius
08:24:06 <opqdonut> use the text-show package?
08:24:15 <opqdonut> or just pack.show
08:24:24 <Luke> yeah I guess pack . show is it
08:24:30 <Luke> what's text-show? I'll have a look
08:25:04 <hodapp> Where's Peaker? I found another vaguely similar project to Lamdu... http://unisonweb.org/2015-05-07/about.html
08:25:10 <Luke> oh nice text-show is awesome. thanks opqdonut 
08:28:07 <pavonia> UTF-8 doesn't matter, though, if you use Text
08:29:50 <merijn> Luke: Hold on, what, exactly are you trying to do?
08:30:04 <Luke> pak.show
08:30:08 <Luke> pack
08:30:08 <merijn> Luke: Are you just trying to output Text to a file?
08:30:15 <merijn> and/or terminal
08:30:19 <Luke> no
08:30:58 <merijn> "UTF8 encoded" implies outputting to file, network, whatever
08:31:12 <merijn> So if you're not doing that, your question is probably the wrong question
08:31:54 <Luke> bytesring output
08:32:37 <Luke> merijn: why don't you just tell me what solution you're thinking and we can see if that's a good fit?
08:32:50 <Luke> telling me i'm asking the wrong question is a noop
08:33:02 <pavonia> Luke: The problem is that you question isn't very clear to us
08:33:20 <merijn> ByteString output is outputting to a file/network/disk/whatever, no?
08:33:25 <Luke> yeah
08:33:28 <Luke> potentially
08:33:31 <merijn> Anyway, if you want to output ByteString, use Text.Encoding
08:34:00 <merijn> Specifically: Data.Text.Encoding.encodeUtf8 :: Text -> ByteString
08:34:10 <Luke> i mean... that's not the API i have at this point. The Text eventually gets dumped to a ByteString. that's completely different here
08:34:19 <Luke> I'm looking for Double -> Text
08:34:23 <Luke> you are giving Text -> ByteString
08:34:37 <merijn> Then, "text-show" or "pack.show"
08:34:42 <Luke> yeah
08:34:56 <pavonia> Luke: Why did you asked for UTF-8 then? It has nothing to do with the question
08:35:21 <Luke> pavonia: thanks for all your help
08:35:29 <glguy> There's also stuff in the text package for building up Texts with Builders http://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text-Lazy-Builder-RealFloat.html
08:35:49 <Luke> glguy: yeah but then I have to encode it myself right?
08:35:53 <Luke> I just have a single Double here
08:35:57 <glguy> encode what?
08:36:04 <Luke> the Double
08:36:21 <glguy> No, you pass the double as an argument to the function
08:36:22 <Luke> oh i see what you're saying
08:36:40 <Luke> so just run the builder right away
08:36:41 <Luke> yeah
08:36:59 <Luke> thanks I'll look into that too
08:38:52 <Luke> glguy: good call. I think formatRealFloat is exactly what I want.
08:39:04 <Luke> thanks mate
08:46:54 <Luke> merijn: i see what you were getting at before. i was on the phone so it was hard for me to type full responses
09:47:09 <Forgetaboutit> #haskell, is there a general library for (un)escaping of text or strings?  I'd be nice to specify the escaping rules once and derive efficient escaping and unescaping functions automatically.  Or am I looking for a solution to a non-existing problem?
09:47:24 <merijn> Forgetaboutit: What sort of escaping?
09:48:00 <Zekka|Sigfig> Forgetaboutit: I’m not aware of that existing — it’s a need I didn’t know I had until you mentioned it!
09:48:27 <Zekka|Sigfig> Now I want it to exist — I frequently have to interop with e.g. C, Java, misc scripting languages, and there’s a lot of subtle incompatibility
09:48:59 <Zekka|Sigfig> (that is, interop using the command line or sockets or something)
09:49:01 <Forgetaboutit> merijn: It's pretty basic in my current use case.  It's basically replacing single characters by one or more characters for a simple text-based protocol
09:49:47 <Forgetaboutit> merijn: Something along the lines of 'replace " " with "\\s"' and a couple more
09:50:25 <ironChicken> i have an ordered list of (Int,Int), i.e. by the fst of each pair the list is in ascending order
09:50:30 <ertes> Forgetaboutit: unfortunately there are no general escaping rules
09:50:34 <Forgetaboutit> Zekka|Sigfig: Good to hear there's a real need for that :)
09:50:42 * hackagebot hsdev 0.1.7.0 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.7.0 (AlexandrRuchkin)
09:50:42 <ironChicken> now i want to group them into [[(Int,Int)]] such that the gaps between the snd of a pair and the fst of the next pair being below a given threshold causes those pairs to be in the same group
09:50:49 <ertes> Forgetaboutit: but you can use any of the parsing libraries to do it yourself
09:51:03 <ironChicken> i have: groupBy (\(_,a) (b,_) -> b - a <= 2) [(1,5),(6,8),(12,17)]
09:51:31 <Zekka|Sigfig> It wouldn’t be too hard to write a function that turns [(String, String)] into an escape/unescape function (where the left string is original, right is replacement)
09:52:18 <ertes> assuming String
09:52:23 <Forgetaboutit> ertes: You're probably right.  I guess I it's naive to assume `unescape . escape = id` can be fulfilled by a mechanical implementation
09:52:25 <Zekka|Sigfig> there are some subtleties that suggest you’d want to do this from scratch (or using a parsing library if you really want to) — e.g. if you’re escaping \ into \\ and newlines into \n, you don’t want to get \\n out the other side
09:52:33 <lyxia> ironChicken: looks like you'll have to write your own groupBy
09:52:35 <fr33domlover> it's not so easy to make it work for all cases
09:52:54 <fr33domlover> e.g.what if the number of chars you want to replace isn't known in advance
09:52:56 <ertes> Forgetaboutit: that's possible (see the boomerang library)
09:53:06 <fr33domlover> e.g. replace \xNNNNNN with a unicode char
09:53:31 <Zekka|Sigfig> Forgetaboutit: I don’t think it’s that important that the library be absolutely able to guarantee that
09:53:53 <Zekka|Sigfig> most people are probably implementing rules from other languages which either guarantee you can encode anything, or they don't
09:54:02 <Forgetaboutit> Zekka|Sigfig: That would be a start.  I'm a bit concerned, however, about the effiency
09:54:07 <ertes> Forgetaboutit: the boomerang library, due to its bidirectional nature, is not a full library…  neither is it very convenient
09:54:09 <Zekka|Sigfig> and your library’s job is not to fix that
09:54:16 <ertes> → full parsing library
09:54:40 <Forgetaboutit> ertes: That's probably still ok for a lot of cases
09:54:49 <Zekka|Sigfig> Forgetaboutit: You can probably do it in linear time either way assuming one string’s escape code only occupies at most a constant number of characters
09:55:13 <Zekka|Sigfig> which is true in most languages (iirc there’s no way to escape one character that takes more than 12 chars in Java, for instance)
09:55:18 <ertes> Forgetaboutit: it should handle the usual escaping rules just fine…  the trouble starts if you need back-references
09:55:52 <ertes> stuff like \n and \xNNN should be no problem
09:56:01 <Forgetaboutit> Zekka|Sigfig: right
09:56:12 <ertes> though \xNNN is not actually fully invertible
09:56:33 <ertes> example: '\x20' = ' '
09:56:53 <fr33domlover> It may be easier to write a set of all the common escape sequences than create something fully generic
09:57:09 <ertes> fully generic is impossible anyway
09:57:10 <fr33domlover> Most langs use the same sequences, same concepts
09:57:23 <Zekka|Sigfig> I’m just cautioning against getting *too* smart! Although I hink \x?? and \u???? are common and useful
09:57:39 <Forgetaboutit> fr33domlover: That would be pretty helpful already
09:57:56 <ertes> > '\032' == ' '
09:57:58 <lambdabot>  True
09:58:15 <ertes> now try in your shell:  echo -e "\032"
09:58:18 <ironChicken> lyxia: does groupBy not do what i want?
09:58:27 <ertes> they disagree in important details
09:58:50 <lyxia> ironChicken: groupBy will keep comparing to the first of the group
09:58:50 <Zekka|Sigfig> there are languages with really strange escape syntax, but if you can just support like C, Java, URL encoding, JavaScript, you probably have a lot of the most common needs
09:59:15 <Zekka|Sigfig> and you probably don’t need a terribly smart interface to capture all those
09:59:16 <ironChicken> lyxia: ah yes,
09:59:19 <ironChicken> i see
09:59:51 <ertes> you need language-specific rules, otherwise you'll summon demons from hell
10:00:09 <ertes> the only generic ones are things like \n and \r
10:00:22 <Zekka|Sigfig> Yeah, but what I’m saying is that the language specific rules for each of those only take a couple different forms
10:00:30 <lyxia> ironChicken: I don't think you're ever supposed to rely on that behavior either, but it's how it's implemented.
10:00:56 <ertes> yet they are different, and you need to account for that
10:01:12 <Zekka|Sigfig> I suspect you don’t need an incredible diversity of language-specific rules to have a library versatile enough for what most people will actually want to express — but if you sit down and say “I want to have an escaping library that captures everything” you will probably define far more rules than you need
10:02:51 <ertes> it depends on the application, but in most cases you'll actually want a comprehensive set of rules…  missing a case will in the best case produce a C compiler error, and in the worst case you'll end up processing untrusted input into insecure PHP
10:04:09 <ertes> my point: don't write a general library…  write a library for the target language in question, and when required, add alternative rule-sets for other languages
10:05:14 <ertes> ideally: write your application in a way such that you don't need such a library…  for example when you generate C code, you can link binary blobs
10:06:58 <Forgetaboutit> ertes: You're probably right.  I guess it would be sufficient for a lot of cases to be able to specify escaping characters and a few replacement rules
10:07:29 <ertes> alternative ideal:  filter incoming strings such that you generate valid strings in the target language without handling every possible case…  you may not even know every case, because languages evolve, and almost all compilers/interpreters support some language extensions
10:17:55 <haskell849> hi
10:18:02 <Athas> Hello.
10:19:59 <haskell849> so I have this code print "X",  forkIO f, print "Y", and sometimes the code "hangs" after printing X. It always "eventually" gets to Y, but there's sometimes a long gap after printing the  X. This confuses me because I  thought that forkIO would return immediately.  For  context, this is for spawning a new thread for each request to a websocket  server. 
10:20:27 <haskell849> when I change f to  a simple function, like putStrLn, then Y is always printed quickly
10:20:43 <merijn> haskell849: Quick question: Are you compiling with the threaded runtime? :)
10:20:49 <haskell849> there might be something wrong  about f,  the processMessage function for an  incoming request, that may cause this
10:20:54 <haskell849> yes, compiling with threaded
10:20:55 <merijn> haskell849: i.e. are you actually using multiple threads :p
10:20:58 <merijn> hmmm
10:21:14 <merijn> Are you setting the number of capabilities to use?
10:21:31 <merijn> i.e. "+RTS -N +RTS"
10:21:42 <merijn> Or whatever the right syntax is
10:21:48 <haskell849> to be a bit clearer, the library in the cabal  filie doesn't have -threaded but  the executable does. The executable also  has the -N option. 
10:22:21 <merijn> hmmm
10:22:26 <merijn> ok, then I'm confused
10:22:38 <merijn> But I need to run, so good luck
10:22:42 <haskell849> ok
10:23:40 <eacameron> haskell849: I might slightly suspect stdout buffering? print "X" doesn't necessary flush I don't think.
10:24:00 <eacameron> but I'm confused too
10:24:30 <haskell849> i tried hFlush stdout right after the  print Y and sometimes it still  hangs between X and Y. Is there anything special  about f that may cause this? for example,  f accesses an mvar on the main thread, it takes a long time/resources to finish, etc??
10:24:48 <haskell849> "hangs' just means takes a long time here. It always gets to Y eventually. 
10:24:58 <eacameron> haskell849: You'd need to flush after each print
10:25:40 <haskell849> ok i haven't tried printing after the X,  i guess  i can try that. could you explain stdout bufferring to  me?
10:25:51 <haskell849> * haven't tried hflush after printing the X
10:26:11 <eacameron> haskell849: Well, if you're actually seeing the X and then a hang, I suppose that wouldn't be buffering
10:26:28 <eacameron> (provided you flush after the Y)
10:26:48 <haskell849> by flush, do you mean hflush stdout?
10:26:52 <eacameron> yeah
10:26:55 <purelazy> haskell849: buffering, in general, means .... errr yeah ... flushing
10:27:53 <eacameron> Yeah, it just fills up a queue before actually writing the output (unless you tell it to not wait for the queue to fill up, which is what flush does)
10:28:15 <haskell849> can you guys think of any situation where forkIO may not return immediately? For context, f is  currently a function that handles a request  on our  websocket haskell backend. When I send it five requests that  I expect to take a long time, and then  a bunch of requests that i  expect it to take  a short time, the "short" requests exhibit this behavior. Each request is supposed to fork. 
10:28:56 <eacameron> I'm guessing you're doing FFI or system calls in those threads?
10:29:46 <haskell849> pretty sure that we're not doing ffi, but may be using libraries that  internally use ffi. how would i know if we're using system calls  (i don't think we are), and regardless, why would that explain the given behavior?
10:30:08 <eacameron> If you're accessing the network stack then you're definitely at least doing system calls.
10:30:28 <eacameron> I've read about some wonkiness if your main thread does any system calls that block.
10:30:43 * hackagebot monad-connect 0.1 - Transformer for TCP connection with TLS and SOCKS support  https://hackage.haskell.org/package/monad-connect-0.1 (akrasner)
10:30:45 <eacameron> It doesn't *seem* like that's what you're doing, but I don't know.
10:30:53 <haskell849> suppose that  those threads were doing system calls (using zmq for example?). how could that explain how x prints but y doesn't
10:32:15 <eacameron> try calling yield in `f` immediately in your code
10:32:26 <eacameron> Just a shot in the dark :/
10:33:22 <haskell849> you mean the first line of f is yield :: IO ()?
10:33:27 <eacameron> Yeah
10:34:57 <jophish> I have a Name for a type. Is it possible to use this inside a declaraion splice?
10:35:11 <jophish> sorry, declaration quotation
10:42:40 <fuhej> I'm not able to get indentation working in "@" blocks in my .cabal file -- what's the syntax for that?
10:45:44 * hackagebot twentyseven 0.0.0 - Rubik's cube solver  https://hackage.haskell.org/package/twentyseven-0.0.0 (lyxia)
10:46:43 <haskell697> when profiling, i see data.serialize.get/put near the top. what can i do to lower this bottlneck? for context, i'm serializing a bunch of  datatypes to bytestrings,  and  then  using hedis to put them into  redis.
11:03:28 <johnw> @tell Lokathor the problem is that by confounding many issues, and using terminology that's not really appropriate, it makes the matter seem much more complex than it is
11:03:28 <lambdabot> Consider it noted.
11:27:46 <prettyboy2000> hei
11:39:02 <fizbin> Anyone know when (i.e. at what version) cabal changed from --enable-library-profiling to --enable-profiling ?
11:43:01 <nitrix> Gwaaargh. Haskell's module system drives me nuts.
11:43:37 <nitrix> I've been trying to carefully split the dependencies to avoid mutually recursive modules and I failed.
11:44:17 <johnw> nitrix: there's always boot files
11:44:18 <nitrix> I'm at the point of moving everything in a module and I'm the point it might kill the project if I fail.
11:44:24 <nitrix> Erf :(
11:46:17 <Cale> nitrix: Typically the solution is to pull out type definitions and put them in their own module
11:46:29 <digitalmentat> I'm trying to use the auto-generated Paths module in my library but I'm receiving an `undefined symbol` error
11:46:29 <Cale> nitrix: That's the usual cause of circularity
11:46:46 <Cale> nitrix: If you really can't beat it, there's always the option of writing .hs-boot files
11:46:52 <digitalmentat> I'm a bit confused because it should be reachable, but I was wondering if there were any caveats around the autogen for libraries in a cabal file?
11:47:42 <EvanR> nitrix: yeah its kind of a towers of hanoi
11:48:26 <EvanR> just let the IDE figure it out (...)
11:50:15 <EvanR> i wonder if its the module systems fault or the way haskell code has so much mutually recursive definitions, in which case, its not the module systems fault (which is not really much different from ruby or pythons module system)
11:50:15 <geekosaur> digitalmentat, might need to be listed in other-modules
11:50:25 <Cale> It's kind of sad, because the Report explicitly says that modules may be mutually recursive
11:50:35 <digitalmentat> mmmh, okay, along with a "dummy" one or without?
11:50:49 <Cale> It's just tricky to actually make that a reality.
11:51:30 <digitalmentat> geekosaur, adding it (without a dummy paths module) appears to have worked
11:51:35 <digitalmentat> geekosaur, thank you
11:55:02 <jophish> D: Q isn't an instance of MonadFix
12:01:17 <nitrix> Maybe in GHC 9 ;-; ?
12:01:42 <Cale> jophish: Oh, that also is pretty interesting.
12:02:03 <Cale> I don't really understand why it couldn't be.
12:02:15 <Cale> Particularly given that IO is.
12:05:15 <yyyyy> I have this big pile of different XML documents that need to be parsed into Haskell for further processing. Currently I'm using XsdToHaskell followed by manual tweaking and writing ad-hoc xml-conduit services. Is there a better way?
12:06:16 <yyyyy> Usually I feel like copying the types from APIs that serve XML or JSON is the longest part of the job, and highly mechanical. Once it's done I can accomplish a lot with very few lines — that is, once it's expressed already as a Haskell ADT.
12:06:30 <yyyyy> Anyone sharing the pain?
12:08:07 <EvanR> Cale: since you want source code to be finite?
12:09:18 <ertes> > runST (mfix (pure . (1 :)))
12:09:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:09:42 <EvanR> a Q Expr that used mfix could be like 3 + 3 + 3 + ...
12:10:07 <ertes> never used TemplateHaskell before, but isn't Q a monad?
12:10:19 <EvanR> yes
12:10:31 <ertes> then you can trivially create infinite source code without MonadFix
12:10:47 <EvanR> i just thought of that, but not cause its a monad
12:11:00 <ertes> Applicative is sufficient
12:11:11 <EvanR> recursive let is a sufficient?
12:11:23 <ertes> you still need 'pure'
12:11:37 <ertes> or some other means to actually construct a Q Expr
12:12:02 <simpson> Why worry about infinity when Ackermann's function exists?
12:12:05 <EvanR> nope
12:12:34 <EvanR> looks like you need to use the Q monad to create new exprs
12:12:47 <EvanR> so how were you thinking of doing it without monad fix
12:13:08 <ertes> now i'm lost
12:13:24 <EvanR> infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
12:13:37 <EvanR> ExpQ = Q Exp
12:14:33 <ertes> allow me to repeat that i have no experience with writing Qs…  i avoid mr. Q like the plague and only occasionally invoke him as a user, and more often than not he pulls me into one of his twisted mind games =)
12:16:19 <EvanR> really this is about monad fix
12:17:12 <EvanR> ah
12:17:52 <EvanR> nope
12:17:54 <EvanR> dunno
12:17:56 <mgsloan> The TH API is pretty straightforward really, but it can look intimidating.  It's just a couple dozen functions for asking questions that the compiler knows how to answer, and datatypes defining haskell's AST (with extensions, which makes the API bigger)
12:18:19 <ertes> my only point was that you don't need MonadFix to construct infinite values, you need it for *effectful* infinite values
12:20:18 <EvanR> well
12:20:50 <EvanR> in a monad api where you can only construct new data using monad actions, then im not sure you can get infinite values of that data type
12:21:03 <EvanR> without monad fix
12:21:09 <EvanR> effects or not
12:22:08 <ertes> :t fix (fmap (1 :))
12:22:09 <lambdabot> (Functor f, Num a) => f [a]
12:22:36 <ertes> (which proves me wrong: you don't even need Applicative)
12:23:13 <EvanR> (1:) is an example constructor that you can use freely outside of a monad
12:23:45 <ertes> EvanR: perhaps i'm misunderstanding you
12:24:01 <EvanR> but like constructFoo :: A -> B -> m Foo isnt, if Foo's ctors arent exported
12:24:15 <EvanR> where m is some monad
12:24:52 <lyxia> TH constructors are exported though
12:25:00 <ertes> you can always construct the undefined value, as long as there is some ∀ a. a -> m a
12:25:21 <EvanR> ah Exp ctors are exported, so why is infixE the way it is?
12:25:22 <ertes> or are you not counting bottoms?
12:25:36 <EvanR> i dont see how _|_ is infinite
12:25:38 <lyxia> for ease of use
12:25:52 <EvanR> so yeah you can construct infinite expressions at will
12:25:57 <ertes> EvanR: it's semantically equivalent to an infinite loop
12:25:58 <jophish> Cale: I'd be surprised if I'm the first person to want for MonadFix q
12:25:59 <jophish> Q*
12:26:34 <lyxia> but monadfix isn't necessarily about constructing infinite expressions
12:26:38 <ertes> data Blah = Blah !Blah;  pure (fix Blah)
12:26:40 <EvanR> ertes: eh no... were talking about an infinite data structure which is guaranteed to produce values, _|_ is freeze up or halt + catch fire
12:26:46 <Prettyboy2000> hello
12:27:06 <EvanR> lyxia: no i was just thinking of Exp literally as the TH type
12:27:20 <jophish> I was hoping to use it for generating a cyclic graph (ish thing). Without monadfix I have to allocate all the newNames in advance and pass that into the graph generator
12:27:34 <jophish> it would be much nicer to pass the output of the graph generator into itself :)
12:27:45 <EvanR> jophish: cant you do a liftIO ?
12:27:52 <EvanR> i guess not
12:28:00 <jophish> Q isn't MonadIO sadly
12:28:10 <EvanR> boggling
12:28:25 <EvanR> you can do IO though
12:28:45 <jophish> I'm thinking of making it ACME.MyCreditCards which creates a list of all the credit card numbers found on the users system :)
12:28:47 <ertes> EvanR: if the data structure is recursive, and you can construct recursive values, there is no trouble at all constructing infinite values
12:28:52 <EvanR> runIO :: IO a -> Q a
12:28:58 <EvanR> you can monadfix that
12:29:20 <jophish> well, only if there's a way to put `newName` into IO
12:29:26 <EvanR> ertes: you keep saying correct things, and ignoring my point i was making
12:29:28 <lyxia> you can convert back and forth between Q and IO
12:29:35 <jophish> ah, right
12:29:40 <ertes> EvanR: probably because i don't understand your point
12:30:08 <EvanR> in a monad api where you can only construct new data using monad actions, then i dont think you can get infinite values of that data type
12:30:15 <EvanR> if the ctors for that type arent exported
12:30:39 <ertes> EvanR: it depends on the actions you have access to
12:30:59 <EvanR> right, something like monadfix can be exported
12:31:20 <ertes> you don't necessarily need mfix for that
12:32:00 <EvanR> something like monad fix, like loop :: (A -> A) -> m A
12:32:39 <EvanR> so yeah, you can program it to build recursive structures, or you can stop the user from building recursive structures
12:32:41 <ertes> cons :: a -> M (F a) -> M (F a) → fix (cons x)
12:32:55 <johnw> what is a "monad api"?
12:32:59 <EvanR> ertes: that wont work
12:33:09 <EvanR> fix doesnt do join
12:33:25 <ertes> > let cons x cxs = fmap (x :) cxs in runST (fix (cons 'x'))
12:33:27 <lambdabot>  "*Exception: stack overflow
12:33:28 <EvanR> you dont get an (F a) out of it, you get a M (F a)
12:33:59 <EvanR> johnw: youre exposing functionality using a Monad, user is going to use do notation etc
12:34:09 <ertes> > let cons x cxs = fmap (x :) cxs in fix (cons 'x') :: Maybe _
12:34:10 <lambdabot>      Found hole ‘_’ with type: [Char]
12:34:11 <lambdabot>      To use the inferred type, enable PartialTypeSignatures
12:34:11 <lambdabot>      Relevant bindings include
12:34:20 <ertes> oh, come on
12:34:25 <EvanR> heh, using : again
12:34:26 <johnw> EvanR: if "Monad m" is your api, then "return" is the only way to construct new data
12:34:27 <ertes> > let cons x cxs = fmap (x :) cxs in fix (cons 'x') :: Maybe String
12:34:31 <lambdabot>  mueval-core: Time limit exceeded
12:34:53 <ertes> EvanR: it doesn't matter…  cons is the interface for constructing a data structure
12:35:06 <ertes> without exposing the data structure itself
12:35:36 <ertes> (:) is just conveniently predefined =)
12:35:52 <EvanR> ... for a type that doesnt have its ctors exported
12:35:57 <EvanR> which is hidden behind the library
12:36:03 <EvanR> unlike lists
12:36:14 <ertes> imagine cons being the only function to construct lists
12:36:29 <EvanR> then how would you use :
12:36:31 <ertes> and imagine that i don't have a strictness bug in there
12:36:41 <ertes> you wouldn't…  that was your point, wasn't it?
12:37:06 <WarzoneCommand> Is there some convenient way of doing some sort of type-safe indexing (in the following sense)? Supose that I have some data structure (think of it as an array), that can provide some set of index items, that can be used *only* with the data structure that provides them? 
12:37:09 <EvanR> list is a bad example if youre already confused. take a circuit instead
12:37:37 <ertes> > data MyStream a = Cons a (MyStream a)  -- constructors hidden
12:37:39 <lambdabot>  <hint>:1:1: parse error on input ‘data’
12:37:41 <ertes> uhm
12:37:46 <EvanR> WarzoneCommand: theres phantom types
12:37:46 <ertes> @let data MyStream a = Cons a (MyStream a)  -- constructors hidden
12:37:49 <lambdabot>  Defined.
12:37:52 <WarzoneCommand> I'm thinking of doing something like: tag the data struct and the indices with phantom types, and use ST to generate unique indices that also have the correct phantom type
12:38:09 <ertes> @let cons x = fmap (Cons x)  -- the only thing that's exported is this
12:38:14 <lambdabot>  Defined.
12:38:29 <ertes> EvanR: is that what you mean?
12:38:47 <WarzoneCommand> but I would like to avoid having people deal with ST stuff explicitly 
12:39:02 <EvanR> why do you need ST?
12:39:56 <EvanR> ertes: if you create a data structure and didnt export the ctors, then thats part of the previous discussion
12:39:59 <EvanR> created*
12:40:16 <WarzoneCommand> I'm not sure yet. But you would need to generate the indices (that are tagged with some phantom type) somehow don't you?
12:40:29 <ertes> WarzoneCommand: if the types of those indexed values are available elsewhere, then one way is to "confine" the values
12:40:48 <ertes> WarzoneCommand: newtype Confined a = Confined { fromConfined :: a }
12:40:58 <ertes> don't export fromConfined
12:41:40 <EvanR> WarzoneCommand: youre programmatically creating new index types at runtime? or you have a finite number like 8 levels, and you dont want to mix indexes into level 7 with level 2
12:42:23 <WarzoneCommand> ertes: I don't see how that helps in this case. But maybe I haven't explained my use case well enough
12:42:26 <EvanR> you need to consider the kind of operations you will want to do
12:42:44 <ertes> WarzoneCommand: no worries, i seem to be highly confused today =)
12:42:45 <EvanR> and how it would or wouldnt make sense to use types
12:43:04 <EvanR> what kind of code you are protecting yourself against
12:44:49 <lyxia> WarzoneCommand: will you need to use multiple instances of such a structure at once?
12:45:27 <WarzoneCommand> EvanR: basically I want to have some data structue of type D s a, where s is some phantom type (and a the usual type of stuff we are storing), that is indexed by things of type Index s. Functions would be: new :: D s a  -- so here you need to invent the s somehow, and get :: Index s -> D s a -> a 
12:45:50 <EvanR> well you cant invent brand new unique types at runtime
12:46:20 <EvanR> i guess you can do the ST thing where its not different but the type checker cant know that
12:46:25 <WarzoneCommand> lyxia: multiple; if I have a d1 :: D s a and a d2 :: D s' a, and I have an index for d1, I don't want to be able to use it for d2 
12:47:39 <EvanR> how do you get indexes?
12:47:40 <lyxia> You could have a state-like monad transformer that takes care of one instance at a time...
12:47:48 <EvanR> like even if it wasnt phantomly typed
12:47:58 <EvanR> what are valid ways to get indexes
12:48:17 <EvanR> in the case of Map, one way is to remember how you built the map
12:48:28 <WarzoneCommand> EvanR: ah yes, I would also need something like: indices :: D s a -> [Index s] or so 
12:48:30 <EvanR> but there might be other arguments you can make to get new valid indexes
12:48:40 <EvanR> ah
12:48:46 <EvanR> there you go then
12:49:33 <EvanR> the only safe thing to do with that is to use all the indexes in the list, so really youre just doing a map or traversal over the DS
12:49:45 <EvanR> which you dont need indexes for
12:50:09 <WarzoneCommand> that might be much more expensive than using get though
12:50:25 <lyxia> What's your use case, what do you do with these tables
12:50:26 <EvanR> one way to be more efficient is to remember the indexes you used to build the DS
12:51:15 <WarzoneCommand> hmm 
12:51:20 <EvanR> if youre not modifying the DS then s -> a is more efficient ;)
12:51:46 <EvanR> or I -> a
12:51:53 <WarzoneCommand> lyxia: I'm trying to implement an efficient representation of (static) planar graphs 
12:51:59 <WarzoneCommand> i.e. something like: https://github.com/noinia/hgeometry/blob/master/src/Data/PlanarGraph.hs
12:52:35 <WarzoneCommand> the edges (arc's) are basically Ints that index into an array (the graph), and I want to avoid that edges from one graph (array) can be used to index in another graph
12:52:40 <jophish> When I use the data data declaraion created here https://gist.github.com/expipiplus1/3d71d73d775a36e161c9 I get a compile error later on saying that "A" has been declared multiple times (Note that both constructors are called "A"). When I ddump-splices I can see that all the constructors have been given distinct names "A_0" "A_1"
12:52:57 <WarzoneCommand> EvanR: true. However my DS is static ;)
12:52:57 <jophish> does `newName` not return a unique name every time?
12:53:52 <ertes> WarzoneCommand: if there is only one way to initially create the data structure, say 'new', then one simple way is to CPS it with a rank-2 type:  new :: (forall s. D s a -> r) -> r
12:54:19 <ertes> WarzoneCommand: that prevents the 's' from unifying with any other type, unless type signatures allow it to
12:54:52 <lyxia> oh yes very nice
12:55:28 <WarzoneCommand> but new is now basically just a "do the entire computation that involves D" right?
12:55:39 <ertes> WarzoneCommand: yeah
12:55:52 <lyxia> jophish: It does.
12:57:28 <jophish> lyxia: 'It does "return a unique name every time"' or 'It does "not return a unique name every time"'
12:59:16 <EvanR> WarzoneCommand: this comes up whenever youre trying to do "total" programming and you have indexing, the tricky bit is that you need to encode possible correct use cases into the types. so you need to know what is possible before hand. which is what im confused about. you clearly wont want to use arbitrary numbers to index a graph, but how do you create one in the first place?
12:59:37 <lyxia> jophish: It should return a unique name every time, as shown by your dump
12:59:43 <EvanR> (and youll need a body of theorems which allow you to do stuff you proved is ok to do)
13:00:29 <EvanR> WarzoneCommand: i tried something like this for static pacman levels, there were only a few levels and each had its own phantom type. and the names of nodes in the graph were type correctly for where they want
13:00:35 <jophish> lyxia: what could be causing the duplicate definition warning then?
13:00:44 <EvanR> that works because its all static in the source code
13:01:02 <EvanR> typed correctly for where they went*
13:01:35 <EvanR> so in this case it worked because the indexes and graphs were all spelled out in the source code, not generated through an algorithm
13:03:45 <EvanR> you can take something with a phantom type during construction: new :: s -> [Edge] -> (D s, [Index s]), linked :: D s -> Index s -> Bool
13:03:45 <WarzoneCommand> hmm yes, in this case I don't want to have the graph to be fixed in the code. But I also don't really want this sort of "single usage" that you get with the (forall s. D s a -> r) -> r approach. 
13:03:49 <EvanR> you can tag*
13:03:53 <WarzoneCommand> Maybe what I wan't is simply not possible
13:04:19 <WarzoneCommand> hmm yes that sounds kind of reasonable. 
13:04:19 <lyxia> jophish: can you give me an example that compiles
13:04:21 <EvanR> in the above you can use different singleton types
13:04:41 <EvanR> and you can use rank2 to story the D and Index together in 1 data structure
13:04:49 <jophish> lyxia: sure, just a minute
13:05:31 <EvanR> but i am kind of questioning how useful it will be as-is because what kind of useful things will you do with the indexes (which are now indexed by Int)
13:06:18 <WarzoneCommand> hmm I think I'll go for the explicit proxy during construction approach for now
13:06:23 <WarzoneCommand> EvanR: what do you mean?
13:06:50 <EvanR> nevermind, i need breakfast
13:07:11 <WarzoneCommand> ok. Thanks for the hints :)
13:07:47 <EvanR> type safe indexing is basically an exercise in dependent types, so an exercise in restricting the kinds of programs you can write a lot
13:08:01 <EvanR> and expanding the kinds of things to can do will involve proving theorems
13:08:43 <EvanR> the classic basis where i have a DS and an index operation, and i dont care what i will do or how i will do it just doesnt fit right
13:08:59 <WarzoneCommand> I prefer the idea of restricting types and having to prove a theorem once in a while over having to write unit tests though ;)
13:09:21 <jophish> lyxia: https://gist.github.com/expipiplus1/54825f08924f228abb55
13:09:56 <jophish> a file with `duplicateConstructors` at the top level exhibits the odd behavior
13:11:27 <lyxia> hmm very odd
13:12:26 <lyxia> it's probably not meant to be used that way, whatever it is
13:12:43 <lyxia> jophish: why are you generating constructor names like that though
13:12:45 <jophish> ok, how should I be generating constructor names?
13:12:48 <jophish> :)
13:12:55 <lyxia> haha
13:13:08 <jophish> lyxia: because I don't know any better is probably the best answer 
13:13:49 <jophish> I need to generate a bunch of states for a state machine, I don't care what there called just as long as they're unique
13:17:08 <jophish> lyxia: I've arrived at a temporary solution using "mangleName" here https://ghc.haskell.org/trac/ghc/ticket/5398
13:25:46 <lyxia> nice
13:25:56 <lyxia> well, as nice as TH can be
13:29:55 <mgsloan> I wonder if that mangleName function is guaranteed to work.  No doubt SPJ knows this stuff well, but I think that does have a small chance of colliding with a name the user picked (which would have to end in the number, heh)
13:32:31 <mgsloan> jophish: I've used something like this in the past:
13:32:32 <mgsloan> fmap headMay (filterM lookupValueName (map (\ix -> if ix == 0 then base else base ++ show ix) [0..]))
13:32:44 <mgsloan> Errr lol that will infinite loop
13:33:06 <mgsloan> findM lookupValueName (map (\ix -> if ix == 0 then base else base ++ show ix) [0..])
13:35:52 * hackagebot prometheus 0.1.0.1 - Prometheus Haskell Client  https://hackage.haskell.org/package/prometheus-0.1.0.1 (LukeHoersten)
13:47:14 <meretrix> I have a very strange problem.. I built a process manager using System.Process.shell.  It works well for a while, but after a few hours, the processes it launches will no longer be able to accept any TCP connections -- they'll just hang.  Any idea how to debug this?
13:48:08 <johnw> using lsof, see whether you're building up connections that you're not closing
13:48:32 <geekosaur> also check if you are running out of either sockets or TCP ports
13:48:43 <geekosaur> TCP4
13:48:55 <geekosaur> TCP4's got a ludicrously small namespace
13:49:02 <meretrix> Thanks, i'll check those out.
13:49:41 <meretrix> To complicate things further, I've been running it in docker and haven't been able to reproduce outside, but probably haven't tried it long enough.
13:50:22 <geekosaur> docker config could also be imposing a port / socket limit of its own
13:53:27 <sphinxo> How can I check if a file exists?
13:53:43 <johnw> I always forget the name of that function
13:53:51 <jomg> doesFileExist, i believe
13:53:58 <jomg> in System.Directory
13:54:04 <johnw> indeed
13:54:18 <bstamour> That's the one
13:54:31 <glguy> sphinxo: The more common way to find out is to try to open it and do whatever you were going to do and then handle the exception if it in fact does not exist
13:54:31 <johnw> or fileExist in unix, 
13:54:51 <sphinxo> glguy: I just need to check if it exists
13:55:24 <sphinxo> I guess that'd still work
14:06:19 <monochrom> here is when you want to go ahead open and catch exception: you will open anyway after knowing that it exists. recall that "go ahead open" is more atomic than "does it exist? if yes, open"
14:08:19 <monochrom> 50 years from now, people will finally consider transactional file systems, so that you won't need to worry about this subtlety.
14:12:05 <nullzero> gimmick!
14:13:36 <bergey> ]
14:22:16 <infandum> Is it possible that output (writing to stdout or a file) will just hang in the middle of outputting a bunch of data? Like, trace shows that the list is fully evaluated (so not waiting on input), but outputting gets stuck mid-line and just hangs?
14:22:33 <koala_man> yes
14:22:48 <infandum> really? uh oh
14:22:56 <infandum> Is there a quick fix?
14:22:56 <geekosaur> output buffering will have that effect, yes
14:23:07 <infandum> like...it's super hanging
14:23:21 <infandum> even though the list is only like a few thousand strings long
14:23:36 <infandum> only gets to ~ 1000 or so and stops
14:24:37 <koala_man> so the haskell program doesn't continue? as opposed to the haskell program doing something else but you only see half the list in the file?
14:24:49 <nullzero> we're going on a trip with our favorite rocket ship.... zooming to the skies... "Little Einstein"
14:25:56 <Cale> infandum: Is there any reason for the write to block? Writing to various things *can* block, but it's a little atypical.
14:26:00 <infandum> koala_man: Like, it's a bunch of calculations, ends up in a list (traceShows shows the list is finished and complete), the list is being written...freeze. Waiting does nothing really and I put a "print "Test"" before and after and the first gets executed but the second does not
14:26:24 <infandum> Cale: Not that I'm aware of. It should just print the text
14:26:41 <geekosaur> if it's block buffered then the buffer is only written when it is full; if your program continues to write, it just collects into the buffer and will be forced out when the buffer is full or when the program exits normally (which flushes all buffers)
14:26:46 <Cale> Is the computation of the output terminating?
14:26:49 * geekosaur sighs, lost connection to buffer
14:26:53 <geekosaur> er to bouncer
14:28:04 <infandum> Ah, I take it back! It's hanging on generating the string
14:28:07 <infandum> for some reason
14:28:14 <infandum> from [T.Text] -> T.Text
14:28:20 <infandum> let's see...
14:30:14 <infandum> wait nevermind, I just put the trace in the wrong spot
14:30:20 <infandum> the Text is complete
14:30:38 <infandum> so it's from T.writeFile and T.putStrLn (either or, tried both)
14:31:14 <Cale> infandum: Those don't normally block (they technically can, but it's highly unusual)
14:31:36 <Cale> infandum: So my first thought is that the computation of the text you're trying to putStrLn is not terminating
14:32:23 <infandum> Cale: But I see the complete text with traceShow right before putStrLn
14:32:34 <eikke> any Stackage admins around?
14:33:29 <Cale> infandum: hm
14:33:43 <infandum> I should mention that I'm in the R monad, using H.io . T.putStrLn . SUCCESSFULL STRING . etc
14:33:46 <Cale> infandum: Can we just see your whole program already? :)
14:33:53 <infandum> wonder if that has to do with it
14:38:11 <marcmp> hi all
14:38:21 <Cale> hello
14:52:29 <sashok22> does anyone know how the MOTO protocol work (dialup pdq machines), those that dial authorisation centres to authorise credit/debit cards?
14:53:51 <infandum> OK, when I change from T.putStrLn and T.writeFile to actual handles and close the handles, it works (even on line buffering), so I have no idea why
15:01:48 <infandum> Hm, now it will get to the end of the program but won't close
15:07:09 <infandum> AH! The input was also making it hang!
15:07:29 <infandum> So pipes does not close input, even using runSafeT with pipes text!
15:11:28 <infandum> aaaaand I take it all back, I just didn't have a big enough data for that run
15:15:07 <vlad__> hey, I'm having some trouble with the gloss package
15:15:41 <vlad__> when I try to run my gloss program I get "*** Exception: user error (unknown GLUT entry glutInit)"
15:16:22 * hackagebot stm-conduit 2.8.0 - Introduces conduits to channels, and promotes using conduits concurrently.  https://hackage.haskell.org/package/stm-conduit-2.8.0 (ClarkGaebel)
15:16:51 <purelazy> vlad__: What platform are you using?
15:17:04 <purelazy> Windows? Linux?
15:17:08 <purelazy> OSX?
15:17:12 <vlad__> Ubuntu 15.10
15:17:47 <sphinxo> How can I compare a field in a record against something?
15:17:54 <purelazy> Do you have glut installed?
15:18:22 <purelazy> i.e. apt-get install glut...
15:18:44 <ertes> sphinxo: one way would be: fieldName recordValue == theThingYouWantToCompareTo
15:18:52 <vlad__> purelazy: I'm not sure - I assume that the haskell GLUT package would not have installed otherwise
15:19:05 <sphinxo> ertes: oh ok :) thanks didn't realise it was so simple
15:19:29 <purelazy> Haskell doesn't go that far. 
15:20:05 <purelazy> Have you used apt-get install before?
15:20:41 <vlad__> purelazy: so I have freeglut3-dev installed
15:21:00 <purelazy> You do?
15:21:12 <ertes> sphinxo: fields turn into, among other things, accessor functions
15:21:21 <vlad__> purelazy: according to apt-cache policy freeglut3-dev I do
15:21:22 * hackagebot prometheus 0.1.0.2 - Prometheus Haskell Client  https://hackage.haskell.org/package/prometheus-0.1.0.2 (LukeHoersten)
15:22:45 <vlad__> purelazy: gah seems to be a known issue https://github.com/haskell-opengl/GLUT/issues/21
15:24:19 <purelazy> vlad__ I did a bit of OpenGL recently
15:25:23 <vlad__> interesting, I can compile my program but can't run it in ghci
15:25:29 <vlad__> I guess I'll have to settle for that
15:25:48 <purelazy> vlad__ I had that happen to me to
15:26:55 <geekosaur> I think that;s known, yes
15:27:47 <purelazy> vlad__ I have windows and mint on this machine
15:27:58 <purelazy> vlad__ in windows at the moment
15:37:44 <rpglover64> I'm trying to install hoodle with gtk3 using stack, and I'm getting an ld link error:
15:37:58 <rpglover64> .stack-work/install/x86_64-linux/lts-5.8/7.10.3/lib/x86_64-linux-ghc-7.10.3/hoodle-core-0.15.0-G5DS0GP26NUFbDdsanSVay/libHShoodle-core-0.15.0-G5DS0GP26NUFbDdsanSVay.a(c_initdevice.o): In function `initdevice':
15:38:04 <rpglover64> (.text+0x3f1): undefined reference to `gdk_devices_list'
15:38:12 <rpglover64> collect2: error: ld returned 1 exit status
15:38:25 <rpglover64> anyone have any advice?
15:39:18 <johnw> rpglover64: have you failed to link in a library?
15:44:03 <lispy> names in haskell are usually camel case, so I would hazard a guess that gdk_devices_list is a C function. And in turn the most likely explanation is that a C library is missing in the link step
15:45:29 <rpglover64> Yes, it's a function that was removed from the GTK API
15:48:15 <rpglover64> lispy: What's confusing me is that I can't find any reference to it in the Haskell code.
15:49:49 <Peaker> sdl2 requires a newer version of SDL (2.0.3) than Linux mint has available (2.0.2) :-(  Why is it so picky about the minor ver?
15:53:40 <cat-o-the-thrill> Does anyone know of a good tutorial for doing a full project with tests? I've seen https://jaspervdj.be/posts/2015-03-13-practical-testing-in-haskell.html and http://book.realworldhaskell.org/read/testing-and-quality-assurance.html, but neither really fit what I'm looking for.
15:55:02 <purelazy> cat-o-the-thrill what are you looking for?
15:56:02 <cat-o-the-thrill> Something maybe in github or with a repo attached that has step by step project structure and code.
15:56:27 <acertain> is there a package on haskell that has `data A a where
15:56:31 <acertain> nvm
15:57:28 <cat-o-the-thrill> purelazy Thanks for asking. Clarifying my thoughts has made it seem a little more ridiculous than in my head.  
15:57:44 <cat-o-the-thrill> @purelazy
15:57:44 <lambdabot> Unknown command, try @list
15:58:01 <purelazy> cat-o-the-thrill Are you a beginner in Haskell
15:58:08 <cat-o-the-thrill> Yes
15:58:14 <purelazy> or now ready to do something serious
15:58:17 <infandum> OK, I don't think it's an IO problem, because deleting all of the IO still results in the hang. It seems to be cause by a recursive function in the R monad.
15:59:35 <purelazy> cat-o-the-thrill Are you of the creed that you write the test *before* the code?
16:00:12 <cat-o-the-thrill> purelazy Yes
16:00:43 <purelazy> cat-o-the-thrill I just Googled haskell testing
16:01:06 <purelazy> There's something called HUnit
16:01:25 <purelazy> Maybe that's a good starting point
16:02:27 <cat-o-the-thrill> Yup yup I've been to https://hackage.haskell.org/package/HUnit 
16:03:10 <cat-o-the-thrill> The things that I'm missing. Is an overall view of how to integrate it into a project. 
16:03:53 <purelazy> cat-o-the-thrill What is your software testing background? 
16:04:16 <purelazy> I've never tested a thing - beyond "It seems to work"
16:05:55 <zomg> I find that Haskell's typesafety catches a lot of the bugs you'd normally use unit tests for
16:06:07 <zomg> At least when it comes to unit tests in dynamic langs like JavaScript
16:06:13 <purelazy> zomg: Ain't that the case :)
16:06:32 * hackagebot coordinate 0.0.20 - A representation of latitude and longitude  https://hackage.haskell.org/package/coordinate-0.0.20 (TonyMorris)
16:06:49 <purelazy> > maxBound :: Int
16:06:51 <lambdabot>  9223372036854775807
16:06:54 <Eduard_Munteanu> cat-o-the-thrill, check out the Yesod scaffolding for example, they include some unit testing bits IIRC
16:07:06 <purelazy> > succ 9223372036854775807
16:07:09 <lambdabot>  9223372036854775808
16:07:22 <purelazy> Why doesn't that break??!?
16:07:30 <jle`> it defaults to Integer
16:07:40 <simpson> > succ 9223372036854775807 :: Int
16:07:42 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
16:07:52 <purelazy> jle' simpson yey!
16:08:10 <purelazy> I missed that
16:08:25 <Eduard_Munteanu> > (+ 1) 9223372036854775807 :: Int
16:08:27 <lambdabot>  -9223372036854775808
16:08:54 <jle`> > last $ iterate succ (0::Int)
16:08:57 <purelazy> And explains why succ (maxBound :: Char) failed
16:09:01 <lambdabot>  mueval: ExitFailure 1
16:09:08 <Eduard_Munteanu> I wonder why overflow checks aren't implicit.
16:09:09 <purelazy> > succ (maxBound :: Char)
16:09:12 <lambdabot>  *Exception: Prelude.Enum.Char.succ: bad argument
16:09:29 <Eduard_Munteanu> For addition, multiplication etc.
16:10:26 <Eduard_Munteanu> x86 at least has an overflow flag it can trap on.
16:10:51 <purelazy> Eduard_Munteanu : Its the runtime overhead
16:11:16 <purelazy> Eduard_Munteanu : Or its a design decision
16:11:22 <Eduard_Munteanu> Is there any if you just trap on the OF bit, really?
16:12:02 <purelazy> Not really
16:12:13 <purelazy> nanosecs
16:12:53 <purelazy> but you got to build interrupt handlers somewhere
16:14:37 <cat-o-the-thrill> Eduard_Munteanu thanks so much. That's actually exactly what I'm looking for. I figured I could learn about cabal and how to bring in dependencies and such through reading, but I'm much better at learning from example.
16:15:16 <Peaker> Eduard_Munteanu: http://blog.regehr.org/archives/1154 <-- according to this, there's no trap on overflow in Intel/ARM?
16:16:07 <purelazy> FYI its OV bit, not OF bit
16:16:23 <Eduard_Munteanu> Hm.
16:16:31 <purelazy> I think
16:16:48 <purelazy> Perhaps different chips have different names
16:18:07 <purelazy> So its a TestForOverFlow instruction after every math op
16:18:25 <purelazy> Or let it overflow
16:18:49 <Peaker> Probably a conditional branch is needed after every potentially overflowing instruction
16:19:00 <Peaker> would bloat the code a lot
16:19:31 <purelazy> Peaker: indeed
16:21:41 <Eduard_Munteanu> Peaker, would be interesting to use it for whole pure functions, if possible
16:22:03 <Eduard_Munteanu> Just run the whole computation speculatively and check at the end.
16:22:13 <Peaker> Eduard_Munteanu: I think the flag is reset by any further operations
16:22:23 <Eduard_Munteanu> Ah. :(
16:24:56 <Enigmagic> Peaker: might not be that bad... .NET/CLR has integer overflow checks enabled by default..
16:26:09 <c_wraith> could you use an SMT solver to only insert checks in places that might actually overflow? 
16:26:13 <Peaker> code bloat might not be too bad for performance, yeah -- mostly reduce icache performance and shorten the prediction window
16:26:33 * hackagebot miku 2016.3.17 - A minimum web dev DSL  https://hackage.haskell.org/package/miku-2016.3.17 (JinjingWang)
16:26:39 <Peaker> c_wraith: that could be cool -- especially if common patterns like checking bounds once outside the loop make the solver's life really easy
16:28:47 <Enigmagic> Peaker: I wouldn't say that GHC emits cache friendly code as-is :p
16:28:49 <zv> c_wraith: i've done quite a bit of work with SAT and SMT solvers and it's rarely that easy
16:29:26 <zv> Typical stack overflow checks use a random canary value and heap overflows use magic numbers.
16:30:17 <zv> That is to say, inbetween the instruction pointer being popped off the stack and the cleanup of the latest subroutine, code checks if a random value located on the stack has changed and exits if it has.
16:30:48 <c_wraith> Oh, I was only considering arithmetic overflow issues. 
16:31:31 <Enigmagic> i really do wish ghc did integer overflow checks by default
16:31:32 <zv> Thats even harder
16:31:41 <zv> (to check via SMT)
16:31:50 <zv> (in the general case)
16:31:54 <Peaker> Enigmagic: why not use 'Integer'?
16:32:15 <zv> Enigmagic: lots of problems with common optimizations as I recall.
16:32:40 <c_wraith> zv, I was considering something like liquid haskell, with an implicit "is in bounds" refinement on every Int expression 
16:32:43 <zv> you can't always just check the overflow flag and move on.
16:32:49 <zv> or AL
16:32:50 <Eduard_Munteanu> If you go that way, you could use Integer and disallow arithmetic on Int, so you can still use them as opaque handles.
16:33:05 <Enigmagic> Peaker: i suspect most uses of Int/Int32/Int64/etc would benefit from default overflow checks
16:34:21 <Peaker> Enigmagic: why not avoid those types and just use Integer everywhere, if you overflow check everywhere?
16:34:25 <davean> Enigmagic: the overflows are one of the reasons I pick those types 
16:34:30 <Peaker> (unboxing benefits?)
16:34:36 <davean> Peaker: performance
16:34:37 <Enigmagic> Peaker: unboxing, ffi, etc
16:34:40 <Enigmagic> performance
16:35:11 <Enigmagic> unless you're writing crypto or hash functions
16:35:32 <davean> The overflows are really nice
16:36:09 <Eduard_Munteanu> They are, but perhaps they should require an explicit "trust me" from the programmer.
16:36:10 <Enigmagic> in c# you can turn it off for some lexical scope
16:36:43 <davean> ick
16:36:46 <Enigmagic> so that way people that really need overflow can get it, and everyone else gets a better default
16:36:47 <davean> thats anti-haskell
16:36:55 <davean> you might want a checked version at the type level
16:36:57 <davean> but it should be in the type
16:37:08 <Enigmagic> how about OverflowingInt :P
16:37:12 <davean> Sure
16:37:17 <Enigmagic> and Int gets the good behavior
16:37:22 <davean> But you should not change semantics lexically - thats terrible!
16:37:37 <Axman6> what behaviour do you want for maxBound + maxBound :: Int then?
16:37:38 <Enigmagic> we already do that with pragmas :-)
16:37:54 <Eduard_Munteanu> Axman6, exception
16:38:03 <davean> Enigmagic: I'm actually not sure where you'd want to use an Int and not want the overflow come to think of it
16:38:06 <Enigmagic> Axman6: launch missiles.
16:38:24 <davean> Enigmagic: whats the use case?
16:38:38 <Enigmagic> davean: using a type besides Integer?
16:38:38 <davean> Enigmagic: if you're integrating with FFI or something, you have to do the numerical methods EITHER way
16:39:00 <davean> Enigmagic: And what useful semantics do you get with overflow checked? exceptions? Then you want to do the numerical methods then too ...
16:39:02 <Enigmagic> davean: i'm pretty sure you'll find a whole lot of Haskell code that doesn't use Integer :p
16:39:13 <c_wraith> davean, performance is the most common reason. Int is way faster in CPU limited code. 
16:39:15 <davean> Enigmagic: I know, its annoying, the prelude is full of those issues
16:39:25 <Enigmagic> right... so reality is prevailing here
16:39:25 <davean> c_wraith: and you ahve to do the numerical methods there
16:39:32 <Eduard_Munteanu> For FFI you don't have to expose an Integer in your high-level API.
16:39:35 <Enigmagic> people use Int and friends and make errors in their code
16:39:37 <davean> Enigmagic: I go and get the Integer versions
16:39:38 <Eduard_Munteanu> Erm, an Int.
16:39:51 <EvanR> davean: in C i daresay you usually dont think about int overflowing
16:39:54 <Enigmagic> davean: great, but a lot of people don't.
16:40:00 <Enigmagic> i'm glad you write good code :P
16:40:12 <davean> Enigmagic: right, I feel the use of the Int version in the prelude is a bug in the Prelude personally
16:40:32 <davean> and should be immediately fixed myself
16:40:33 <Eduard_Munteanu> It kinda is, yeah.
16:40:46 <carter_cloud> There's a fun ghc trac ticket about how there's several differs semantics we can do for int but that we don't pick any of them consistent toy :)
16:40:53 <carter_cloud> Consistently.
16:40:58 <davean> carter_cloud: I know :/
16:41:00 <carter_cloud> Safe-int is a package
16:41:02 <purelazy> And then there's "Integer" (not Int) overflow to consider :)
16:41:03 <davean> carter_cloud: I've been there
16:41:17 <EvanR> purelazy++ ;)
16:41:21 <davean> purelazy: you mean running out of RAM?
16:41:28 <Enigmagic> yes, also a security bug
16:41:33 <Eduard_Munteanu> Luckily there's a trap for that.
16:41:34 <Eduard_Munteanu> Oh?
16:41:35 <carter_cloud> We don't have real Turing machines !
16:41:41 <Enigmagic> aeson hit that with integer iirc
16:41:51 <purelazy> davean: Or even battery :)
16:42:03 <Enigmagic> hence wanting people to use scientific instead of integer or something like that
16:42:06 <davean> purelazy: The generators should cook in well before the UPSs run down
16:42:08 <carter_cloud> Enigmagic: that we don't have resource aware timeouts ?
16:42:25 <Enigmagic> carter_cloud: specially crafted json would eat up infinite memory
16:42:33 <carter_cloud> I thought the issue was with scientific rather than integer :)
16:42:44 <EvanR> scientific makes more sense for json
16:42:55 <carter_cloud> Double makes the most sense ;)
16:42:59 <EvanR> no!
16:43:01 <davean> carter_cloud: NO
16:43:10 <davean> carter_cloud: Go back in your investment bank hole
16:43:19 <davean> carter_cloud: back!
16:43:51 <carter_cloud> davean: go back to your presentation by a senior engineer At that bank
16:44:01 <carter_cloud> It has pretty pictures generated using Haskell.
16:44:58 <enthropy> if I have a Seq (Maybe a), is there some sensible way to make lookup of which indices are Nothing fast?
16:46:06 <Cale> enthropy: Not any faster than O(n)
16:46:06 <davean> enthropy: no, and you'll always be O(n)
16:46:15 <carter_cloud> davean: but anything that can't be rounded to a valid double won't round trip in Json land to other languages :(
16:46:15 <davean> enthropy: even if there was a special optimization
16:46:30 <infandum> Okay, now I'm totally confused. Here is the code: http://pastebin.com/QeReiPgL
16:46:31 <enthropy> I'm making this Seq, so that part is negotiable
16:46:34 * hackagebot unlit 0.3.2.0 - Tool to convert literate code between styles or to code.  https://hackage.haskell.org/package/unlit-0.3.2.0 (pepijnkokke)
16:46:34 <davean> carter_cloud: other languages have bugs. And some will round trip fine
16:46:35 <infandum> The relevant code
16:46:37 <infandum> Cale
16:46:45 <infandum> It's non-deterministic
16:46:51 <Cale> enthropy: Perhaps you can store an IntSet alongside it
16:46:52 <EvanR> carter_cloud: no other language?
16:46:52 <infandum> which is weird, because it should be deterministic
16:46:54 <EvanR> i doubt it
16:46:56 <carter_cloud> Davean : we should come up with a better format
16:47:08 <davean> enthropy: you could make a FingerTree with indexing for the Nothings ... but no, its still O(n)
16:47:20 <carter_cloud> That has a spec and semantics.  And volcanos
16:47:26 <enthropy> Cale: but when I add something to the Seq, I have to update the Set
16:47:28 <EvanR> maybe we should call it XML
16:47:31 <simpson> enthropy: You can waste O(n) space to get a structure that gives you some "fast" operations, but you can't enumerate them quicker than O(n).
16:47:31 <infandum> Erasing the cases at the bottom (the output part) STILL makes it hang
16:47:32 <davean> carter_cloud: maybe CBOR makes you happy
16:47:37 <infandum> sometime
16:47:38 <infandum> s
16:47:48 <Cale> enthropy: Yeah
16:47:49 <lpaste> Cale pasted “infandum's paste” at http://lpaste.net/154821
16:47:50 <carter_cloud> Davean: ask Stu about his crazy xml code. 
16:48:02 <davean> carter_cloud: no, I refuse to talk about XML
16:48:08 <EvanR> nothing is stopping someone write writing a non-double scientific number into json, it should be blackholed because we think Double is the one true number
16:48:18 <infandum> but deleting the cluster line also results in everything working
16:48:19 <EvanR> it shouldnt8
16:48:20 <carter_cloud> I read the Cbor spec.  It's pretty nice
16:48:35 <EvanR> json doesnt have to have anything to do with javascript
16:48:47 <Enigmagic> don't forget about ASN.1
16:48:53 <davean> carter_cloud: have you looked at Haskell's imp yet? Do you know what it does with Integer?
16:49:11 <infandum> cluster :: Height -> ID -> V.Vector (RowID, Record) -> R.SomeSEXP -> R s (Tree TreeData)
16:49:25 <infandum> I really do wonder if it's something about the R monad not closing or something
16:49:27 <carter_cloud> Of Cbor?  The one in the binary branch or the ones by other folks that's on hackage ?
16:49:41 <Cale> infandum: hmm, yeah
16:49:56 <davean> EvanR: Without JS, JSON isn't very well defined
16:50:16 <Cale> infandum: Something involving waiting for some communication with R?
16:50:21 <davean> carter_cloud: the binary branch
16:50:23 <Cale> I'm not sure why...
16:50:34 <Cale> infandum: Does withEmbeddedR have a result?
16:50:36 <simpson> davean: It is independently specified by ECMA: http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf
16:51:07 <Cale> infandum: If so, what happens if you build and simply return an IO action as the result, and then run it afterward?
16:51:19 <infandum> Cale: But it's non-deterministic. Sometimes it will run (with small enough data) and sometimes it will hang. ON THE SAME DATA!
16:51:34 * hackagebot unlit 0.3.2.1 - Tool to convert literate code between styles or to code.  https://hackage.haskell.org/package/unlit-0.3.2.1 (pepijnkokke)
16:51:37 <davean> simpson: Go look at that, how do numbers work again?
16:51:38 <infandum> Cale: Even if I have the R monad return () it still hangs
16:51:39 <Cale> Yeah, sounds like some kind of buggy behaviour from the R bindings
16:51:43 <Cale> ah
16:51:48 <davean> simpson: it doesn't say
16:51:56 <simpson> davean: Series of digits.
16:52:09 <davean> simpson: no, the encoding is more complicated then that
16:52:13 <davean> and it doesn't tell you how it decodes
16:52:32 <davean> simpson: thats not a spec, its at best a format
16:52:41 <davean> its highly ambiguous if you don't refer to JS
16:52:42 <infandum> Cale: But another weird thing is, it ALWAYS calculates the right result (verified with traceShow right before the output) so what would R be waiting for? Isn't it finished?
16:52:43 <simpson> davean: That's because JSON's semantics when decoded are *up to the program hosting the decoder*.
16:52:45 <EvanR> davean: json is defined just fine
16:52:52 <simpson> davean: "It  does  not  attempt  to  impose  ECMAScript’s  internal  data 
16:52:54 <simpson> representations on other programming languages. Instead, it shares a small subset of ECMAScript’s textual 
16:52:54 <Cale> infandum: No idea
16:52:56 <simpson> representations with all other programming languages. "
16:52:59 <simpson> ...Thanks IRC.
16:53:07 <Axman6> Enigmagic: bit late, but if you want to see how to do numbers properly, Ada is definitely worth looking at. makes a lot of things explicit and has very clear semantics, plus built in checks
16:53:14 <simpson> davean: Anyway, whatever. You win; I don't care.
16:53:34 <EvanR> davean: if you gotta ask, youll never know type thing ;)
16:53:39 <infandum> Cale: What do you mean by build and return an IO action as a result, then run it afterward?
16:53:52 <Cale> infandum: I mean return the IO action which does the output you want
16:54:01 <davean> EvanR: haha
16:54:13 <Cale> and actually run the IO action outside the call to withEmbeddedR
16:54:32 <infandum> Cale: like, after the R part, return (result) then output that?
16:54:49 <Cale> return (T.putStrLn ...)
16:54:56 <Cale> or whatever
16:55:01 <infandum> I'll try, but I'm not sure how to make the types work. Lift the embedded R?
16:55:37 <Cale> I mean, your R action will produce an IO action as its result, and then you run that IO action afterward
16:56:14 <Cale> x <- R.withEmbeddedR ... $ do ... stuff ... ; return (T.writeFile ...)
16:56:15 <Cale> x
16:56:48 <EvanR> davean: i like how the json.org site says "a number is very much like a C number"
16:56:58 <EvanR> incredibly specific
16:57:00 <Cale> I'm assuming here that withEmbeddedR actually produces a result
16:57:25 <carter_cloud> Davean I've not looked at it too much.   Should look at it more.  You are correct
16:57:26 <infandum> No instance for deepseq...no idea where that came from
16:58:04 <infandum> looks like withEmbedded R returns IO a
16:58:55 <Cale> infandum: right, so it produces the result of whatever computation it was you gave it
16:59:11 <Cale> infandum: So that result could potentially be an IO action to be carried out later
16:59:36 <infandum> yeah I did x <- R.withEmbeddedR blah blah return(result); T.putStrLn x
16:59:39 <infandum> that still hangs
16:59:49 <infandum> (but works on smaller data like it could before)
17:00:21 <infandum> what could that mean?
17:00:41 <infandum> although this time it doesn't even partially compute (like I thought before it was a buffering issue), here it just hangs
17:00:51 <infandum> like nothing is printed
17:00:58 <infandum> as opposed to stopping mid-line
17:01:19 <EvanR> in this standard... numeric values that cant be represented as a sequence of digits (infinite, nan) arent permitted. which may or may not imply one-third is not permitted, depending on whether you allow infinite sequences!
17:01:29 <EvanR> clevery left this out
17:02:00 <EvanR> i guess an infinite json file is obviously not valid
17:02:35 <EvanR> though a streaming infinite-or-not-we-dont-know-yet json array could work
17:03:28 <infandum> Cale: I guess by definition, as it doesn't print anything (when it hangs, again, non-deterministic but 90% of times it hangs) but the other way it printed partially, means that it MUST be R monad related, right, not buffer related?
17:04:09 <Cale> infandum: yeah, I don't see any reason this would be related to buffering
17:06:13 <infandum> Cool. Now I just need to figure out how to fix it haha
17:06:17 <infandum> halfway there
17:06:49 <mogunus> Hi, I’m getting the error “not in scope, ‘run’” in GHCi, after using :l on a file that has import Control.Monad. How do I fix this?
17:07:21 <Axman6> where is run defined?
17:08:22 <mogunus> Ugh nevermind, it’s in another file, sorry.
17:41:02 <Apocalisp> if the algebras for [] are monoids, what are the algebras for Free []?
18:06:36 * hackagebot bower-json 0.8.0 - Read bower.json from Haskell  https://hackage.haskell.org/package/bower-json-0.8.0 (hdgarrood)
18:16:37 * hackagebot coordinate 0.0.21 - A representation of latitude and longitude  https://hackage.haskell.org/package/coordinate-0.0.21 (TonyMorris)
18:56:38 * hackagebot digit 0.2.4 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.2.4 (TonyMorris)
19:06:57 <bayor99> new here.. are newbies allowed here to learn Haskell from scratch?
19:07:38 <bayor99> i'm looking for where to start learning Haskell
19:08:01 <kadoban> bayor99: Of course. http://haskellbook.com/ is a good place to start, I've heard. Or https://github.com/bitemyapp/learnhaskell has good advice if it must be free.
19:09:05 <bayor99> thanks @kadoban
19:11:38 * hackagebot aeson-better-errors 0.9.0.1 - Better error messages when decoding JSON values.  https://hackage.haskell.org/package/aeson-better-errors-0.9.0.1 (hdgarrood)
20:08:19 <lyndoncloud> Hey Haskellers
20:08:58 <lyndoncloud> Does anyone know if there's an easy way to normalize symbolic numeric expressions from the Data.Number.Symbolic package?
20:09:10 <lyndoncloud> I tried hooking up uniplate, but the constructors seem to be private.
20:51:53 * hackagebot configuration-tools 0.2.14 - Tools for specifying and parsing configurations  https://hackage.haskell.org/package/configuration-tools-0.2.14 (larsk)
20:57:32 <dramforever> > undefined * 0 :: Integer
20:57:33 <lambdabot>  0
20:58:08 <ij> > 0 * undefined
20:58:10 <Axman6> that is definitely a surprising result
20:58:10 <lambdabot>  *Exception: Prelude.undefined
20:58:15 <nitrix> Is it possible to conditionally call `return` inside do-notation?
20:58:38 <nitrix> if (or shouldHalts) then return True else return $ whateverIsTheCurrentReturn
20:58:41 <Axman6> nitrix: and have it act like return in say C or Java?
20:58:54 <dramforever> nitrix: If you are asking that, you are misunderstanding return
20:59:00 <nitrix> I looked at `when` but its type is :: f ()
20:59:07 <nitrix> dramforever: I am not.
20:59:39 <dramforever> nitrix: ok, what do you want the result type be?
20:59:40 <nitrix> It's the State monad and I can't seem to be able to conditionally change the result of the evaluation.
20:59:42 <Axman6> what does whateverIsTheCurrentReturn mean?
20:59:45 <nitrix> dramforever: State Game Bool
20:59:51 <nitrix> Axman6: ^
21:01:20 <Axman6> yeah I'm confused and don't know what you want
21:01:22 <tzh> sure, but where are you actually getting that value from otherwise?
21:01:30 <dramforever> nitrix: so why the code you wrote doesn't work?
21:01:58 <nitrix> dramforever: I don't remember saying anything about code that doesn't work.
21:02:03 <nitrix> My current project works and compile just fine.
21:02:29 <Axman6> .. then you don't have a problem?
21:02:32 <dramforever> ...what made you ask, then?
21:02:33 <nitrix> You're starting with misconceptions that seems to make the process of answering my question more complicated than it needs to be, really.
21:02:46 <nitrix> I don't have a problem, I asked a question.
21:02:55 <Axman6> well you haven't explained what the (non-)problem is
21:03:19 <nitrix> I'm not to blame for that.
21:03:45 <Axman6> ...
21:03:56 <Axman6> you're not to blame for not providing enough information?
21:04:02 <Axman6> seriously?
21:04:17 <tzh> are you looking for something like `when` or `unless`? you said when's type was `:: f ()` (which it's not, but, disregarding that), so like... are you looking for something with a type of `:: f a` or something
21:05:09 <Axman6> clearly that can't be done though, because you can't magically produce a value of type a without executing the expression passed
21:05:17 * dramforever reviews the question...
21:06:24 <tzh> right, because `when` is basically `\b v -> if b then v else return ()`, and you can't magic up a value of an arbitrary type to make that not end up with a terminal type of `m ()`
21:06:27 <nitrix> tzh: I believe if you apply `when` to two arguments, the result is in fact :: f ()
21:06:29 <nitrix> :t when
21:06:31 <lambdabot> Applicative f => Bool -> f () -> f ()
21:06:36 <nitrix> I stand correct.
21:06:51 <Axman6> yes...
21:06:53 <nitrix> This channel is headed south. I'll look the documentation on my own then.
21:07:13 <Axman6> ... wow
21:07:34 <Axman6> somehow it's own fault that, when asked for clarification in answering your question, you couldn't give it?
21:07:39 <Axman6> our*
21:07:43 <dramforever> if you find that better
21:08:56 * dmj` sings kumbaya
21:22:05 <tippeneinn> "have it act like return in C or Java" - that's problematic ^_^
21:26:19 <ij> When `stack build` doesn't work, is changing the snapshot entry of stack.yaml a common solution?
21:27:05 <kadoban> ij: Probably not usually. Did it used to work/does it work for others? Where did the resolver setting come from? What "doesn't work"?
21:28:07 <ij> I think no deps worked. Then I added some cabal deps and http://sprunge.us/aSjF or with -v http://sprunge.us/cFfj this happened.
21:28:21 <ij> Also, that log file it provides — has no new info, the same thing.
21:29:36 <kadoban> ij: Why are you doing 'stack install network'? I assume that's some dependency of the thing you're actually trying to build?
21:30:01 <ij> kadoban, Well stack build failed with network, so I did just stack install network... hoping that would somehow help
21:30:10 <lpaste> tippenein pasted “many parser question” at http://lpaste.net/154830
21:30:30 <tippeneinn> Does anyone have advice on dealing with parsing out data types with > 50 constructors? data Thing = One String | Two String .... | Fifty String
21:30:39 <tippeneinn> Is that a job for template haskell?
21:31:08 <tippeneinn> the example I posted above is somewhat close to what I'm suggesting, if the Thing type had 50 more constructors
21:32:18 * hackagebot werewolf 0.4.9.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.9.0 (hjwylde)
21:35:10 <Axman6> tippeneinn: TH probably is the right tool for the job there
21:35:32 <Axman6> ij: can you share your stack.yaml and .cabal file?
21:37:05 <ij> Here they are: http://sprunge.us/AOJH
21:37:42 <ij> It's pretty much the default with some build-dependes for the executable.
21:38:35 <Axman6> the indentation of the cabal file seems weird, but I doubt that's the problem
21:39:19 <Axman6> I assume irc-client is in lts-5.8?
21:39:43 <ij> It's just what the formatting macro for shell does. `ls` is indented too.
21:40:28 <Axman6> sure, but things like hs-source-dirs: should be indented more than library
21:41:05 <ij> Oh, vim broke it then, sorry.
21:41:53 <ij> Yeah, irc-client is in 5.8.
21:48:01 <slacktest> I didn't know irc-client, only irc-core. Good to know
21:49:48 <ij> Ok, downgrading to lts-5.7 worked. Not sure if 5.8 at fault or I just had messed something up with the build.
21:50:55 <tippeneinn> I have a rational fear of TH
22:08:43 <ggVGc> anyone tried this and can recommend it? https://github.com/nfjinjing/miku
22:08:52 <ggVGc> I want to prototype a backend for a game, and it seems like a good fit
22:16:06 <codedmart> If I have a aeson Value. How do I delete a specific key?
22:17:34 <dmj`> codedmart: is this value an object per se?
22:17:41 <jle`> codedmart: if it's made with the Object constructor, you can use the methods from http://hackage.haskell.org/package/unordered-containers-0.2.7.0/docs/Data-HashMap-Strict.html#t:HashMap
22:18:04 <codedmart> dmj`: Yes it is sorry for not mentioning that.
22:18:38 <dmj`> let Object o = someVal in Object $ Data.HashMap.delete "key" o
22:38:42 <guest4398> Hello, I just have a super quick question. A Google search didn't turn anything up, so what is the "lgo" function in haskell? As in "lgo z (x:xs) = lgo (f z x) xs"
22:39:41 <shachaf> You should know, you're the one who just typed it here.
22:40:20 <guest4398> To provide some context, it's from the source code that defines the foldl function
22:40:37 <guest4398> http://hackage.haskell.org/package/base-4.3.1.0/docs/src/GHC-List.html#foldl
22:40:55 <shachaf> That's the definition of lgo.
22:42:08 <dmj`> guest4398: that's just a helper function to aid in the defintion of foldl, it probably means "left go", since "go" is a common helper function name
22:42:24 <dmj`> s/aid/aide
22:42:29 <shachaf> It might mean "let's go".
22:42:38 <dmj`> shachaf :D
22:42:49 <guest4398> ...Okay, wow that was a really dumb question on my part. Sorry about that, I'm trying to wrap my brain around haskell and it's very different from what I'm used to
22:43:16 <dmj`> guest4398: why would you think that was a dumb question? That was not a dumb question
22:44:01 <dmj`> guest4398: things aren't always intuitive you know
22:47:06 <guest4398> Well thank you for that
22:49:06 <codedmart> dmj`: For got to say thanks!
22:51:06 <dmj`> codedmart: np!
23:09:22 <dmj`> @src sequence
23:09:22 <lambdabot> sequence []     = return []
23:09:22 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:09:22 <lambdabot> --OR
23:09:22 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:10:15 <verement> @src liftM2
23:10:16 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:10:42 <julianleviston> If I’m in a Writer do block, and I have a list of Strings called say “strings”, how would I add each of them to the writer in sequence?
23:11:06 <julianleviston> one uses “put” or something, doesn’t one?
23:11:13 <julianleviston> I should probably look up Writer
23:12:21 <verement> mapM_ tell strings, perhaps?
23:12:23 <julianleviston> Ah ok. tell. I guess it also depends on the data being held in the writer.
23:12:25 <julianleviston> thansk
23:12:33 <julianleviston> verement:  but I’m in a do block…
23:12:44 <verement> so?
23:12:44 <julianleviston> verement:  ooh… pretty. ok. :)
23:13:04 <julianleviston> verement:  sorry :) I just looked up the signature of mapM_ and it made sense.
23:18:16 <julianleviston> verement:  ah thanks very much… worked a treat. There was an underlying MT in the particular monad I’m using (it’s in the HaTeX library) that has its own version of tell called textell and that worked great. :)
23:19:19 <verement> glad it worked out
23:36:01 <ggVGc> would it make sense to write a server in Erlang, and have each cient interaction be it's own process, written in haskell?
23:36:10 <ggVGc> would the overheard of each haskell process be way too much?
23:36:28 <ggVGc> I'm looking to get the fault tolerance of erlang with the type safety of the actual application logic from haskell
23:37:10 <EvanR> how about the fault tolerance of haskell!
23:37:10 <ggVGc> so I was imagining doing the routing and general server behaviour with erlang and writing the actual application in haskell
23:37:20 <dmj`> ggVGc: haskell threads are cheaper than erlang threads
23:37:28 <EvanR> dmj`: really?
23:37:37 <Xe> [citation needed]
23:37:47 <julianleviston> ggVGc: I guess it depends what you mean by “process” in haskell :)
23:38:24 <ggVGc> if there's a runtime exception or an infinite evaluation or similar in my haskell program, how do I make sure it gets killed and doesn't affect other client interactions, with haskell?
23:38:42 <ggVGc> julianleviston: I meant that for each new client connection the erlang process would start a new haskell program
23:38:46 <liste> ggVGc are you sure you can't get the same fault tolerance with distributed-process ?
23:38:48 <EvanR> theres System.Timeout for timeouts
23:38:56 <EvanR> and async for monitoring
23:39:01 <ggVGc> liste: not sure at all, hence why I'm asking. I'm still quite new to haskell
23:39:12 <julianleviston> ggVGc: wouldn’t the startup time be prohibitive?
23:39:12 <ggVGc> okay, I guess I'll give haskell a go for the whole thing
23:39:25 <julianleviston> ggVGc: you should probably look at cloud haskell if you haven’t yet.
23:39:28 <EvanR> theres a nice pattern you can use where you spawn the process, the block waiting for its answer or the exception it threw when it died
23:39:29 <ggVGc> julianleviston: no, since it's for a game server. Each interaction would be long running
23:39:31 <liste> ggVGc: https://wiki.haskell.org/Cloud_Haskell
23:39:40 <julianleviston> yep.
23:39:46 <ggVGc> cheers
23:40:16 <julianleviston> ggVGc: erlang is ideally suited for this though…
23:40:21 <EvanR> and you can get runtime resource statistics from GHC or from the ekg package
23:40:22 <dmj`> EvanR: let me fact check myself
23:40:28 <lifter> Indeed check out Cloud Haskell.
23:40:39 <dmj`> EvanR: I know it's true though
23:40:45 <EvanR> i wish it was true ;)
23:41:09 <ggVGc> julianleviston: hence why I wanted to use it. BUt I also want to write the core application in haskell
23:41:18 <ggVGc> so I was trying to find a compromise
23:41:24 <julianleviston> ggVGc: cool :)
23:41:25 <EvanR> haskell for a server seems like a no brainer to me
23:41:29 <ggVGc> but I think there will be to much overhead because of multiple processes
23:41:44 <EvanR> i dont worry about IPC either though
23:41:47 <ggVGc> EvanR: I also just want to write a real world program in erlang, rather than just dabble in it off and on
23:41:49 <liste> ggVGc: forkIO threads are very lightweight
23:41:57 <julianleviston> ggVGc: if you haven’t read the marlow book, that’s worth reading.
23:42:18 <julianleviston> ggVGc: http://chimera.labs.oreilly.com/books/1230000000929
23:42:24 <ggVGc> thanks
23:43:04 <julianleviston> ggVGc: you might want to consider elixir… it takes a lot of the pain out of writing erlang.
23:43:17 <EvanR> ive been hearing about elixir
23:43:26 <EvanR> exactly what kind of pain is it solving?
23:43:35 <codebje> "what is this syntax I don't even"
23:43:38 <julianleviston> EvanR: syntax
23:43:40 <julianleviston> :)
23:43:43 <Xe> erlang has weird syntax
23:43:47 <EvanR> the syntax looks just as weird as erlang
23:43:53 <julianleviston> EvanR:  really?
23:43:57 <codebje> when #haskell complains about weird syntax, you know it's _weird_
23:43:59 <julianleviston> EvanR: interesting.
23:44:02 <ggVGc> julianleviston: yeah, I was going to use it. But the primary purpose is to also get this game and server written and deployed
23:44:11 <ggVGc> so if erlang isn't a good match I won't use it this time
23:44:23 <lifter> codebje: That's what I was thinking.
23:44:24 <julianleviston> ggVGc: you should use whichever lang you know the most then
23:44:50 <julianleviston> Haskell doesn’t have weird syntax. It has lots of operators, is all.
23:44:57 <EvanR> ok erland does have some weird stuff but
23:45:14 <codebje> ggVGc, I employ an "innovation limit" princple to my work these days: no more than two new things, else I'll spend all my time learning the new things and not producing results
23:45:18 <EvanR> not sure the order of magnitude improvement in elxir
23:45:27 <ggVGc> the client is already written in Elm, so I'm gonna port it to haskell with Helm and use GHCJS to deploy it, while using most of the application code for the server which will also be in haskell. I was just thinking I could maybe use erlang as the supervisor
23:45:36 <ggVGc> codebje: yep, fair
23:45:36 <julianleviston> EvanR: fair. It’s mostly (from what I understand) designed for people who understand ruby, I think.
23:45:45 <EvanR> right, and i understand ruby
23:45:52 <EvanR> which is why im questioning it all
23:46:14 <julianleviston> EvanR:  well, given it was written by jose valim...
23:46:23 <ggVGc> julianleviston: not just lots of operatiors, but people keep implementing their own operators a lot..
23:47:01 <julianleviston> ggVGc: Yeah, the problem is people think the operators are syntax.
23:47:06 <julianleviston> ggVGc: part of the problem.
23:47:30 <julianleviston> understandably so.
23:48:57 <ggVGc> yep I had a lot of issues with it when I first got into haskell
23:49:15 <ggVGc> then I started understanding that the core syntax is actually super simple and is jsut literally applications of functions
23:49:20 <EvanR> i remember being alienated by seeing wild usage of <*>
23:49:33 <EvanR> and it frightening coworkers and small children
23:50:02 <julianleviston> hehe :)
23:50:12 <EvanR> it seems obvious now
23:50:22 <EvanR> i need to remember it wasnt always so
23:50:28 <ggVGc> anyting's obvious when you're used to it
23:50:30 <julianleviston> it’s pretty nice realising that even (.) isn’t special.
23:50:49 <ggVGc> I must say I really dislike the record model in haskell though
23:50:55 <julianleviston> Oh god yes.
23:51:05 <julianleviston> ggVGc: purescript’s is much nicer.
23:51:06 <ggVGc> I'd say it's a fairly big design failure
23:51:25 <EvanR> theres some oddball record syntax
23:51:28 <julianleviston> ggVGc: I actually often wonder why more of purescript isn’t the way Haskell works.
23:51:28 <ggVGc> julianleviston: I've been using Elm a bit the past months, and Records are super nice there. Maybe same as purescript
23:51:38 <julianleviston> ggVGc: not exactly.
23:52:03 <ggVGc> anyway, I think everyone agrees records are a bit crap in haskell, but it's hard to change now
23:52:14 <EvanR> they are just very basic
23:52:18 <ggVGc> maybe we need a new data type RecordMk2 for a transition period
23:52:19 <julianleviston> purescript has a nice destructuring on it… but Elm’s are quite nice.
23:52:19 <EvanR> they are pulled straight from type theory
23:52:25 <julianleviston> ggVGc: I think they’re working on it!
23:52:58 <EvanR> as basic as they are, there still isnt the equivalent of foo { field = bar } in like javascript or ruby (built in or idiomatic at least)
23:53:23 <julianleviston> EvanR: huh?
23:53:28 <julianleviston> EvanR: what do you mean?
23:53:29 <EvanR> i thought that was cool when i learn about it in haskell
23:53:35 <ggVGc> the fact we need lenses is a hint that we messed up records imo
23:53:37 <julianleviston> EvanR: you mean field setter syntax?
23:53:39 <EvanR> you can do a record field replacement in js or ruby
23:53:43 <EvanR> cannot*
23:53:43 <ggVGc> EvanR: yeah, up to the point where yo have a nested record
23:53:46 <Cale> That's true, the closest you get is mutation
23:53:47 <julianleviston> EvanR:  why not?!
23:54:01 <Cale> There's no immutable field replacement
23:54:16 <EvanR> ive tried all kinds of weird ways in both languages and none really work
23:54:20 <julianleviston> oh… “new one but this field different” ok.
23:54:25 <EvanR> or two fields
23:54:34 <julianleviston> Cale: bet pretty trivial to create one, no?
23:54:44 <EvanR> nothing idiomatic
23:54:52 <EvanR> you will get weird looks
23:54:58 <julianleviston> EvanR: but it’s idiomatically mutable, so...
23:55:05 <julianleviston> EvanR: the idiom is mutation.
23:55:10 <EvanR> its kind of not
23:55:30 <EvanR> people know that mutating records that are being passed around is insane, if you have half a brain and half a year experience
23:55:49 <julianleviston> EvanR:  I mean the idiom for changing things is mutation.
23:56:01 <EvanR> kind of? not in web ruby
23:56:06 <julianleviston> EvanR: you would just use a merge in ruby.
23:56:26 <ggVGc> EvanR: _(foo).cloneDeep().set('field', bar)
23:56:27 <ggVGc> :)
23:56:28 <julianleviston> EvanR: thisHash.merge(thisOtherHash). Pretty sure that’s what’s idiomatic.
23:57:01 <julianleviston> EvanR:  … assuming you want a new hash with some keys different? 
23:57:10 <julianleviston> EvanR: i mean, there aren’t such a thing as records in ruby ANYWAY really.
23:57:23 <EvanR> well thats what that is
23:57:33 <EvanR> yeah merge works
23:57:49 <julianleviston> EvanR: unless you’re talking about structs… but even there they’re basically simply hashs I think.
23:58:12 <EvanR> theyre not
23:58:20 <julianleviston> EvanR: ok.
23:58:20 <EvanR> but theres 11 such things and its annoying
23:59:11 <EvanR> right so merge doesnt mutate the original, merge! though
23:59:44 <julianleviston> EvanR:  but you wouldn’t use a Hash for something that’s a Struct… or an object.
23:59:54 <julianleviston> EvanR: This is OOP versus FP, right. :)
23:59:57 <julianleviston> at this point.
23:59:59 <EvanR> depending on who you ask, you would
