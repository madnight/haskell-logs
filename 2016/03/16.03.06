00:00:11 <jle`> > let myMap = M.fromList [(1, "hello"), (2, "world"), (3, "foo"), (4, "bar")]
00:00:13 <lambdabot>  <no location info>:
00:00:13 <lambdabot>      not an expression: ‚Äòlet myMap = M.fromList [(1, "hello"), (2, "world"), ...
00:00:21 <jle`> @let myMap = M.fromList [(1, "hello"), (2, "world"), (3, "foo"), (4, "bar")]
00:00:23 <lambdabot>  Defined.
00:00:30 <jle`> > M.lookup 3 myMap
00:00:32 <lambdabot>  Just "foo"
00:12:11 <ggVGc> shachaf: thanks
00:22:59 <hunteriam> I have a question about using free monads
00:23:10 <hunteriam> I'm implementing Settlers of Catan
00:23:18 <hunteriam> I need to be able to validate a sequence of actions
00:23:37 <hunteriam> My first instinct was an action data type that I can apply to the game state and validate as I go
00:24:27 <hunteriam> But I'm sing javascript and I cant make simple copies of my state
00:24:33 <hunteriam> So its a mess that way
00:24:44 <hunteriam> I'm wondering how I would approach a problem like this using free monads
00:24:49 <hunteriam> If its even a good fit or not
00:51:38 <osfameron> any ideas how, using Lucid, to add "data-*" attributes to elements?
00:53:25 <osfameron> aha, there's a data_ constructor that takes 2 arguments.
01:03:32 <tekkkz> G'Morning. CAn anybody tell me how I could "automate" or put following code in fewer lines? https://bpaste.net/show/42bfab9eb218 I want to get a list of the factors then. How can I "automate " it?
01:08:14 <purelazy1> tekkkz: I think I can help
01:08:41 <tekkkz> purelazy1, whats your idea?
01:09:31 <purelazy1> First I look at what each line has in common
01:10:12 <tekkkz> okay, then?
01:11:26 <purelazy1> getEffectivenessFactor $ matchEffectiveness (fun1 typeSpecAtk) (fun2 typeSpecDef) typeList
01:11:54 <purelazy1> tekkkz: so only fun1 and fun2 are different in each line
01:12:00 <tekkkz> thats true
01:13:10 <purelazy1> we can supply fun1 & fun1 as arguments
01:13:13 <purelazy1> eFactor fun1 fun2 = getEffectivenessFactor $ matchEffectiveness (fun1 typeSpecAtk) (fun2 typeSpecDef) typeList
01:14:08 <purelazy1> eFactor11 becomes eFactor fst fst
01:14:32 <tekkkz> ahh yeah okay
01:14:41 <purelazy1> eFactor12 becomes eFactor snd fst
01:14:48 <tekkkz> and then i can try to do some automation with map .. but how ?
01:15:43 <ahihi> eFactors = [ eFactor f1 f2 | f1 <- fs, f2 <- fs ] where fs = [fst, snd]
01:15:47 <thevaliantx> for someone with no calculus or 'functional programming' background, would functional programming be best described as 'passing variables along to functions'?  I tried googling for the meaning of 'state' in programming, and still don't know what it means.
01:16:02 <tekkkz> thanks
01:16:52 <thevaliantx> i have been following along in programming books (ie, Python) and none of the books I have talk about 'state'
01:19:34 <purelazy1> thevaliantx: It's hard to sum up FP is a nutshell :)
01:19:55 <thevaliantx> your answer aligns with your username
01:20:01 <thevaliantx> j/k :D
01:20:08 <ahihi> some key elements of functional programming are referential transparency, immutable data, and the use of higher-order functions
01:20:44 <purelazy1> and "computation as substitution"
01:20:45 <thevaliantx> ahihi: pretend i don't know how to limit the flow of water to a hose.
01:20:55 <thevaliantx> lol ..
01:21:24 <purelazy1> thevaliantx: have you tried ghci?
01:21:49 <thevaliantx> purelazy: as in trying examples at the cli?
01:21:56 <purelazy1> oh yeah - haskell is pure and lazy
01:22:03 <purelazy1> yeah
01:22:38 <thevaliantx> there has to be a better way of explaining Haskell, or more specifically, functional programming, to someone who doesn't have a CompSci or otherwise engineering background.
01:22:47 <thevaliantx> yes.  i a reading LYAH right now.  
01:23:11 <purelazy1> thevaliantx: you understand by doing
01:23:19 <thevaliantx> just in the beginning of it, though.  "Baby's first functions"
01:23:20 <purelazy1> (old chinese proverb)
01:23:56 <thevaliantx> Right.  But if you were trying to sell Haskell on a manager or team I don't think that approach is going to fly.
01:24:24 <purelazy1> Code works first time??
01:24:32 <purelazy1> hehe
01:25:05 <purelazy1> Its hard to write code that fails
01:26:10 <thevaliantx> fails in compile / interpret time or run-time?  Two different things.  
01:26:19 <ahihi> haskell has a relatively powerful type system, which is made possible through referential transparency
01:26:27 <ahihi> so the compiler can verify a lot of things about your code statically
01:27:09 <ahihi> which eliminates entire classes of bugs
01:27:14 <purelazy1> 99% (my guess) of possible runtime errors are caught as compile time
01:27:20 <thevaliantx> ahihi, I'm way down here.  
01:27:51 <thevaliantx> bbl....nice chatting with all
01:29:00 <tekkkz> how was the function called which does: List 1: ["a", "b", "c"] List 2: [1, 2, 3]   => Result: [(1,"a"), (2,"b")...
01:29:01 <tekkkz> ?
01:29:12 <ahihi> :t zip
01:29:14 <lambdabot> [a] -> [b] -> [(a, b)]
01:29:19 <shachaf> You can find out using Hoogle.
01:30:26 <purelazy1> tekkkz: You can Hoogle [a] -> [b] -> [(a, b)]
01:30:35 <purelazy1> and it'll show "zip"
01:30:41 <tekkkz> oh ok never understood how hoogle works
01:30:51 <tekkkz> ty
01:30:55 <purelazy1> or type zip
01:31:24 <purelazy1> so hoogle can search on both type signature as well as function names
01:31:59 <ahihi> to be pedantic, that particular example would be [b] -> [a] -> [(a, b)], i.e. flip zip
01:32:55 <purelazy1> tekkkz: you know "flip"?
01:33:12 <tekkkz> yep
01:33:17 <purelazy1> cool
01:33:47 <tekkkz> ?
01:34:04 <purelazy1> ?
02:01:20 <Oejet> SSL
02:02:58 <przembot> @pl \a b -> a ++ f b
02:02:58 <lambdabot> (. f) . (++)
02:03:10 <tekkkz> so zip is putting two lists together. But I need to put three lists together in a 3-tuple (a,b,c) ... how to do that?
02:03:20 <tekkkz> is there a built-in function for that?
02:03:44 <cocreature> tekkkz: zip3 :)
02:03:46 <tekkkz> oh
02:03:47 <tekkkz> xD
02:03:56 <tekkkz> next time i first hoogle
02:07:13 <przembot> @pl \a b -> f a ++ b
02:07:13 <lambdabot> (++) . f
02:07:33 <jle`> \a -> (f a ++)
02:10:09 * hackagebot geojson 1.3.1 - A thin GeoJSON Layer above the aeson library  https://hackage.haskell.org/package/geojson-1.3.1 (domdere)
02:11:55 <tekkkz> why do i get at thsi code: http://ix.io/pfM following error? parse error on input ëtypeAtkí
02:12:40 <puregreen> tekkkz: I think you need to indent the declarations further than ‚Äúlet ‚Äù
02:12:53 <tekkkz> they are
02:12:57 <tekkkz> jsut in the paste it failed
02:12:59 <tekkkz> wait a moment
02:13:02 <puregreen> at least like this: http://lpaste.net/154093
02:13:29 <tekkkz> http://i.imgur.com/VoVlcX7.png
02:14:36 <tekkkz> why two tabs indentation?
02:15:01 <puregreen> not two tabs, just further than the word that the declarations refer to (i.e. ‚Äúfacs‚Äù)
02:15:57 <puregreen> same with e.g. do: http://lpaste.net/154094
02:17:36 <puregreen> it'd be nice if both variants were accepted, and I don't know why it is like it is (but perhaps if it worked then it'd mess up something else)
02:19:10 <puregreen> maybe this is the reason: http://lpaste.net/154095
02:25:31 <jle`> to me, it's because when you start a declaration like 'foo', the new "column 0" is where the f is
02:25:44 <jle`> so everything is sort of like shifted relative to where foo starts
02:26:05 <jle`> foo = bar
02:26:08 <jle`>   where ...
02:26:10 <jle`> is the same as
02:26:13 <jle`> let foo = bar
02:26:19 <jle`>       where ...
02:26:36 <jle`> it's like...everything is just shifted relative to the 'f'
02:36:11 <whald> hi! does someone know which cabal user hook(s) is/are needed when i want to pre-process some files with an external tool, which in turn should be part of the cabal "data-files"?
02:37:53 <whald> specifically, i have a tool with an embedded webserver presenting a UI. previously, this was done using plain html + js and served by locating the files using the cabal data-files mechanism. now i've opted for doing the UI using elm, and so the elm compiler has to be run during build.
02:38:21 <whald> maybe there is a project somewhere which does a similar thing, where i can have a look?
02:39:58 <pavonia> The gtk package does, IIRC
02:40:44 <whald> pavonia, i'll have a look, thanks!
02:51:23 <saurabhnanda> is it possible to have functions with the same name but different number of arguments in Haskell?
02:52:19 <jle`> you can accomplish something similar using typeclasses or type families
02:52:36 <jle`> but it might be a sign that you're trying to find the wrong solution to the wrong problem
02:54:27 <jle`> the Text.Printf module uses a trick with typeclasses, but it would hardly be called idiomatic
02:54:33 <saurabhnanda> jle`: need a bunch of functions that insert a row into the DB. Each function dealing with a different set of arguments.
02:55:06 <jle`> any reason why you can't just give them different names?
02:55:09 <saurabhnanda> jle`: and this is not about optional arguments or default values. each function deals with a different data-type.
02:55:41 <saurabhnanda> jle`: I can give them different names. It's just that multiple names seems clunkier. I'm anyways dealing with very long data-type names, thanks to Persisten.
02:55:46 <saurabhnanda> *Persistent
02:57:36 <pavonia> You probably want a typeclass for all objects that can be written to/read from the DB
02:57:49 <Maxdamantus> Can Text.Printf actually be implemented in Haskell?
02:58:32 <tekkkz> my code contains an unclear error: https://bpaste.net/show/07e1f516f159 error: https://bpaste.net/show/bb6ccb53c51e Any idea what I did wrong?
02:58:38 <pavonia> Maxdamantus: Isn't it already implemented in Haskell?
02:58:53 <saurabhnanda> pavonia: I already have that, due to Persistent. It's called Entity or PersistEntity or something like that
03:00:53 <tekkkz> ahh i know waht i did wrong
03:00:54 <pavonia> tekkkz: Did you redefine fst and snd?
03:00:56 <tekkkz> no
03:00:59 <tekkkz> tahts the m,istake
03:00:59 <tekkkz> hehe
03:01:02 <saurabhnanda> can I curry (partially apply) only a few fields in a record constructor? 
03:01:10 <mpickering> sure
03:01:29 <mpickering> You can use it just like a normal data constructor
03:02:28 <saurabhnanda> mpickering: if I don't use the record syntax, I can curry it. But it makes the whole thing positional, which defeats the purpose of using records. Is it possible to curry a call to a constructor while using the record syntax?
03:02:40 <mpickering> no
03:02:49 <Maxdamantus> pavonia: apparently not.
03:03:00 <Maxdamantus> instance (a ~ ()) => PrintfType (IO a) where
03:03:17 <saurabhnanda> well, that's pretty irritating
03:03:35 <Maxdamantus> So GHC's implementation uses GADTs .. you could probably alternatively use FlexibleInstances.
03:03:37 <mpickering> How would you expect that to work?
03:04:31 <saurabhnanda> mpickering: was that for me?
03:04:38 <mpickering> I guess you *can* do what you want but you end up with 'undefined' in uninitialised fields
03:04:38 <mpickering> yes
03:05:13 <saurabhnanda> createUser = User{username="blah"} // u = createUser{firstName="Saurabh"}
03:06:01 <mpickering> ok that will work but you will have undefined in unitialised fields
03:06:05 <mpickering> and ghc will warn
03:07:11 <saurabhnanda> Fields of ‚ÄòUser‚Äô not initialised: firstName, lastName
03:07:16 <saurabhnanda> throwing an error
03:07:24 <saurabhnanda> sorry, that was a warning
03:07:37 <pavonia> Maxdamantus: I don't understand. What makes you think the implementation uses an external library?
03:08:10 <saurabhnanda> mpickering: yes, it works, but with a warning
03:08:35 <mpickering> yes, I said
03:09:06 <Maxdamantus> pavonia: the implementation makes use of some GADTs features, which afaik are not part of Haskell.
03:10:00 <pavonia> Oh
03:10:52 <saurabhnanda> what are these called officially? Record types?
03:19:44 <Maxdamantus> Actually, I guess it can be implemented in plain Haskell.
03:20:37 <Maxdamantus> Hm, dunno.
03:20:53 <Maxdamantus> Maybe not.
03:21:16 <saurabhnanda> Any help with: http://stackoverflow.com/questions/35826229/how-to-deal-with-housekeeping-fields-in-record-types
03:30:24 <lyxia> saurabhnanda: these are just ADTs, records are only a syntactical convenience.
03:30:24 * hackagebot download 0.3.2.2 - High-level file download based on URLs  https://hackage.haskell.org/package/download-0.3.2.2 (psibi)
03:30:26 * hackagebot hedis 0.7.2 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.7.2 (k_bx)
03:30:28 * hackagebot hedis 0.7.5 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.7.5 (k_bx)
03:33:15 <latermuse> Is it possible to replace an internal function in an external module without downloading and modifying the actual module's code?
03:34:01 <latermuse> Like maybe import base, but use a custom function for `liftA` that all the other functions in base then recognize
03:35:24 * hackagebot hedis 0.7.6 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.7.6 (k_bx)
03:35:26 * hackagebot download 0.3.2.3 - High-level file download based on URLs  https://hackage.haskell.org/package/download-0.3.2.3 (psibi)
03:39:28 <zcourts> f21 :: Int -> Int8 -> Int16 -> Int32 -> Int64 -> Int
03:39:28 <zcourts> f21 1 267766 3 4 5 = 10
03:39:28 <zcourts> {-
03:39:30 <zcourts> I apply it with
03:39:32 <zcourts> *HelloWorld> f21 1 267766 3 4 5
03:39:34 <zcourts> <interactive>:3:7: Warning:
03:39:36 <zcourts>     Literal 267766 is out of the Int8 range -128..127
03:39:38 <zcourts> 10
03:39:40 <zcourts> -}
03:39:57 <zcourts> Why does it match since it's out of range? Should that diverge?
03:40:04 <zcourts> Shouldm't*
03:42:04 <pacak> saurabhnanda: I think this can be implemented with help of TH. You'll need a "class Finalaze a where finalize :: a -> IO a"  or "on_update :: a -> IO a; on_create :: a -> IO a" and tweak DB layer to call corresponding methods whenever needed.
03:44:34 <saurabhnanda> pacak: hmm
03:45:26 <pacak> TH (you'll have to write it) can generate corresponding instances based on magical field names.
03:53:03 <saurabhn_> here's a philosophical question. what's the best way to separate out one kind of impure code from the another kind of impure code?
03:55:07 <saurabhn_> I had a working program, which was doing a lot of network IO. Now, I want to introduce some DB-related code, say simply logging request/response for the network calls to the DB. Here's what I find myself doing: (a) functions which dealt with pure network IO, now need to have a DB call at the beginning or at the end, and (b) the simple type a -> IO () of each function seems to be getting converted to a complex ReaderT SqlBackend m IO (a) 
03:55:07 <saurabhn_> type
03:55:23 <saurabhn_> is this the best way to deal with something like this?
03:55:26 <noteventime> saurabhn_: https://ocharles.org.uk/blog/posts/2016-01-26-transformers-free-monads-mtl-laws.html might be relevant
03:55:49 <saurabhn_> or should I be 'lifting' the network-related functions into the DB-related functions. Or vice-versa
03:56:08 <saurabhn_> If I mix every thing up, running each function from the REPL will also become a pain
03:57:26 <pavonia> Abstracting to a new monad transformer layer is an often used way to do these kind of things, I think
03:57:59 <pavonia> So you can e.g. hide the logging in new primitves of that transformer
04:07:04 <saurabhnanda> Nails it. This is why I HATE monad transformers. "This is unfortunate ‚Äì lift is mostly noise that we don‚Äôt want to be concerned with. There is also the problem in that the amount of lifts to perform is tied directly to the underlying definition of M. If I later decide I want to layer in the chance of failure (perhaps with MaybeT), I now have to change almost all code using lift, by adding an extra one in! "
04:07:12 <Eduard_Munteanu> saurabhnanda, take a look at how Yesod does it
04:07:55 <Eduard_Munteanu> saurabhnanda, you wrap DB calls into a runDB function. IO stuff is just liftIO-ed then.
04:07:57 <saurabhnanda> Eduard_Munteanu: Yesod or Persistent?
04:08:26 <Eduard_Munteanu> saurabhnanda, Yesod's helpers for using Persistent... https://hackage.haskell.org/package/yesod-persistent-1.4.0.3/docs/Yesod-Persist-Core.html
04:09:13 <Eduard_Munteanu> saurabhnanda, e.g. see what the scaffolded site gives you
04:09:40 <Eduard_Munteanu> You get the Handler monad which is an instance of MonadIO and YesodPersist.
04:13:15 <Eduard_Munteanu> saurabhnanda, and don't use a bunch of plain 'lift's, that's silly
04:13:51 <saurabhnanda> Eduard_Munteanu: why is that silly?
04:14:50 <Eduard_Munteanu> When you have a bunch of transformers in your stack, you usually have helper instances that lift automatically. E.g. you can use 'ask' in 'StateT s m' because it's an instance of MonadReader when m is.
04:15:23 <Eduard_Munteanu> :t ask >> get
04:15:24 <lambdabot> (MonadReader a m, MonadState b m) => m b
04:15:25 * hackagebot haphviz 0.2.0.0 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.2.0.0 (Norfair)
04:16:09 <saurabhnanda> Eduard_Munteanu: okay, that's what's written in https://ocharles.org.uk/blog/posts/2016-01-26-transformers-free-monads-mtl-laws.html
04:16:09 <Eduard_Munteanu> > runStateT (runReaderT (ask >> get) 0) 0
04:16:11 <lambdabot>      No instance for (Show (m0 (a0, a0)))
04:16:11 <lambdabot>        arising from a use of ‚Äòshow_M559584556129574905112142‚Äô
04:16:11 <lambdabot>      The type variables ‚Äòm0‚Äô, ‚Äòa0‚Äô are ambiguous
04:16:30 <saurabhnanda> "an inductive case, stating that if we know there is a MonadReader instance somewhere within the stack (that is, somewhere in the stack we are using ReaderT), then the outer monad transformer (in this case StateT) is also an instance of MonadReader by simply passing those operations through to the underlying instance via one application of lift. "
04:17:48 <saurabhnanda> but https://ocharles.org.uk/blog/posts/2016-01-26-transformers-free-monads-mtl-laws.html still doesn't answer my question. If I want 10 network functions to now also do DB-ops, should I be inserting the DB call directly into those functions or should I keep them as-is, create separate DB functions, and somehow compose them together?
04:18:37 <pavonia> The lift in that case is only necessary if the ask/get/whatever call is ambiguous
04:19:33 <saurabhnanda> isn't composing, almost always, better?
04:19:53 <pavonia> Better than what?
04:20:23 <saurabhnanda> better than changing existing network functions to also do DB-operations
04:20:42 <Eduard_Munteanu> saurabhnanda, you can add logging directly to your network functions, provided you can mock up a null DB connection for testing.
04:21:03 <Eduard_Munteanu> Depends on what you need to log.
04:21:26 <Eduard_Munteanu> If you're ok with logging in the caller of the network functions, do that then.
04:22:33 <saurabhnanda> Eduard_Munteanu: going around changing types of 10 functions
04:22:33 <saurabhnanda> ?
04:22:37 <Eduard_Munteanu> And by the way, if you're just logging, which means you're only doing inserts, then perhaps monad-logger or using Writer is better.
04:23:08 <Eduard_Munteanu> saurabhnanda, can you provide an example of such a type?
04:24:26 <saurabhnanda> will >>= be able to compose IO (ByteString)  >>= ByteString -> SqlPersistM (Entity AriaLog)
04:24:47 <saurabhnanda> IO(ByteString) >>= (ByteString -> SqlPersistM (Entity AriaLog))
04:25:04 <saurabhnanda> :t (>>=)
04:25:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:25:20 <Eduard_Munteanu> saurabhnanda, well, for one thing, you should probably start avoiding using  concrete types. E.g. use MonadIO m => m instead of IO.
04:25:29 <saurabhnanda> how do I check if SqlPersistM will by IO-like?
04:25:48 <Eduard_Munteanu> It won't work, right.
04:26:20 <saurabhnanda> Eduard_Munteanu: how can I do that? the library functions which I'm using are returning IO (a). I can't generalize that, right?
04:26:33 <Eduard_Munteanu> saurabhnanda, sure you can...
04:26:35 <Eduard_Munteanu> :t liftIO
04:26:36 <lambdabot> MonadIO m => IO a -> m a
04:26:38 <lokien_> Hello guys, how's with hash tables performance nowadays? I've heard it's been poor
04:27:07 <Eduard_Munteanu> :t ask >>= liftIO . print
04:27:08 <lambdabot> (Show a, MonadIO m, MonadReader a m) => m ()
04:27:17 <saurabhnanda> :t (>>=
04:27:18 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
04:27:19 <saurabhnanda> :t (>>=)
04:27:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:27:52 <Eduard_Munteanu> The same 'm' is both MonadReader SqlBackend and MonadIO, for example.
04:28:22 <saurabhnanda> Eduard_Munteanu: right, so SqlPersistM will compose with IO, right? Because it's a MonadIO as well?
04:28:39 <Eduard_Munteanu> saurabhnanda, no, it will be the same monad everywhere
04:28:56 <Eduard_Munteanu> saurabhnanda, SqlPersistT IO something
04:29:11 <saurabhnanda> **exact** same monad, or duck-typed same-ish, kinda works the same way?
04:29:12 <Eduard_Munteanu> You just don't spell it out explicitly.
04:29:19 <Eduard_Munteanu> Exact.
04:29:26 <saurabhnanda> bah
04:30:08 <Eduard_Munteanu> Your functions will have a signature like (MonadIO m, MonadReader SqlBackend m) => ByteString -> m ByteString
04:30:09 <saurabhnanda> :t liftIO
04:30:10 <lambdabot> MonadIO m => IO a -> m a
04:31:13 <saurabhnanda> :t readChan
04:31:15 <lambdabot> Not in scope: ‚ÄòreadChan‚Äô
04:31:23 <saurabhnanda> lambdabot: what?
04:31:46 <Eduard_Munteanu> :t Control.Concurrent.Chan.readChan
04:31:47 <lambdabot> Control.Concurrent.Chan.Chan a -> IO a
04:31:50 <saurabhnanda> :t Control.Concurrent.Chan.readChan
04:31:52 <lambdabot> Control.Concurrent.Chan.Chan a -> IO a
04:32:15 <Eduard_Munteanu> :t liftIO $ Control.Concurrent.Chan.readChan ?chan
04:32:16 <lambdabot> (?chan::Control.Concurrent.Chan.Chan a, MonadIO m) => m a
04:32:24 <saurabhnanda> wow, I'm having to think too hard about composing these functions
04:32:47 <saurabhnanda> I'm inside a readChan do block, inside which I need to do some network IO and then write the request/response to a DB
04:32:52 <Eduard_Munteanu> You just need to wrap IO calls (one or multiple) in liftIO.
04:33:19 <saurabhnanda> which means I can't 
04:33:29 <saurabhnanda> I can't **be** inside an IO monad
04:33:43 <saurabhnanda> I need to be inside the most general monad , which happens to be SqlPersistM
04:34:19 <Eduard_Munteanu> Well, you liftIO the readChan and network functions, and then log.
04:34:35 <saurabhnanda> :t liftIO
04:34:36 <lambdabot> MonadIO m => IO a -> m a
04:34:40 <hpc> sqlFoo = do
04:34:49 <hpc>   liftIO $ getIOSomethings
04:35:04 <saurabhnanda> which is better? // liftIO . readChan chan // OR // lifIO (readChan chan)
04:35:05 <hpc> er, something <- liftIO $ ...
04:35:18 <hpc>   and then whatever with that something
04:36:05 <Eduard_Munteanu> saurabhnanda, I do   liftIO $ readChan chan   or   liftIO (readChan chan)
04:38:11 <Eduard_Munteanu> :t do { r <- get; liftIO (print r); put (r + 1) }
04:38:12 <lambdabot> (Num s, Show s, MonadIO m, MonadState s m) => m ()
04:39:46 <saurabhnanda> when in a MonadIO do-block, every single IO call will need to be liftIO-ed? eg. putStrLn?
04:40:10 <Eduard_Munteanu> saurabhnanda, yes... though you can liftIO a whole do block
04:40:31 <Eduard_Munteanu> Or a bigger IO-only function.
04:41:07 <saurabhnanda> :t modifyMVar_
04:41:08 <lambdabot> Not in scope: ‚ÄòmodifyMVar_‚Äô
04:41:21 <saurabhnanda> :t Control.Concurrent.modifyMVar_
04:41:22 <lambdabot> GHC.MVar.MVar a -> (a -> IO a) -> IO ()
04:41:35 <saurabhnanda> every single thing that I'm doing in that block has to be liftIO-ed?
04:41:38 <saurabhnanda> not a good idea
04:42:30 <saurabhnanda> probably not "interleaving" IO and DB calls is a better idea
04:42:37 <saurabhnanda> keep IO monad separate and MonadIO separate
04:42:43 <saurabhnanda> and have only one single point of composition
04:47:34 <saurabhnanda> does Haskell have any form of variadic arguments?
04:47:56 <saurabhnanda> If I have to define a helper fn who's type-sig is exactly the same as another function, do I have to type the sig all over again?
04:48:03 <xa0> there is a hacky solution used by Text.Printf
04:48:07 <ggole> No, although there are some dumb tricks.
04:48:13 <ggole> Usually you should just use a list.
04:48:13 <xa0> ^
04:48:58 <saurabhnanda> "just use a list" means type it out?
04:49:01 <Ashy> saurabhnanda: haskell type signatures are almost entirely optional, so you can leave it out if you like and ghc should figure out what you meant
04:49:10 <ggole> Dumb tricks meaning things like http://okmij.org/ftp/Haskell/polyvariadic.html
04:49:28 <saurabhnanda> Ashy: what about typing out the number and order of arguments?
04:49:28 <Ashy> also "type it all over again" sounds super manual, you should be able to copy and paste and modify easily with your editor
04:49:39 <Ashy> vim or emacs are both well worth learning at some point
04:49:59 <saurabhnanda> Ashy: it's not about the keystrokes. It's about DRY.
04:50:14 <ggole> If you are typing out the same type again and again, define a type synonym
04:50:26 <mauke> foo, bar, baz :: A -> Common -> Type
04:51:36 <saurabhnanda> What's the Haskell equivalent of --> def fn(a, b, c, d); blah; end; //// def fn_with_logging(*args); Logger.info("fn called"); fn(*args); end
04:51:42 <saurabhnanda> that's Ruby
04:52:36 <ggole> There is none of that kind of variadicity in Haskell
04:52:50 <xa0> you don't need it though
04:52:52 <xa0> for that
04:53:09 <xa0> er
04:53:20 <xa0> if you're in IO that is
04:53:33 <xa0> because you can wrap without arguments
04:54:00 <saurabhnanda> xa0: right. I forgot the (.) operator
04:54:09 <saurabhnanda> xa0: that's what you mean?
04:54:21 <xa0> yeah exactly
05:03:46 <saurabhn_> :t liftMaybe
05:03:47 <lambdabot> Not in scope: ‚ÄòliftMaybe‚Äô
05:28:24 <Xnuk> :t maybe
05:28:25 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:28:29 <purelazy1> How does one declare the type of args in anonymous function literals?
05:29:05 <purelazy1> let f = (\x::Int -> x)
05:29:15 <purelazy1> > let f = (\x::Int -> x)
05:29:16 <lambdabot>  <no location info>: not an expression: ‚Äòlet f = (\x::Int -> x)‚Äô
05:29:29 <purelazy1> :(
05:30:15 <ggole> :t (\x -> x) :: Int -> Int
05:30:16 <lambdabot> Int -> Int
05:30:23 <ggole> Alternatively:
05:30:28 <ggole> :t (\x -> x :: Int)
05:30:29 <lambdabot> Int -> Int
05:30:50 <ggole> Haskell's ascription does not extend to patterns for some reason
05:32:35 <mauke> > (\(x :: Int) -> x) 2
05:32:37 <lambdabot>  2
05:33:09 <ClaudiusMaximus> i think that requires -XScopedTypeVariables ?
05:33:16 <mauke> unlikely
05:33:57 <ClaudiusMaximus> in ghci i get      Illegal type signature: ‚ÄòInt‚Äô
05:33:58 <ClaudiusMaximus>       Perhaps you intended to use ScopedTypeVariables
05:33:58 <ClaudiusMaximus>     In a pattern type-signature
05:34:49 <deepfire> are there any trifecta-based JSON parsers?
05:35:10 <deepfire> the errors produced by aeson are.. unhelpful
05:36:59 <mauke> ClaudiusMaximus: PatternSignatures?
05:37:30 <mauke> oh, that's deprecated
05:37:36 <mauke> weird
05:38:45 <cocreature> deepfire: I don‚Äôt know of a trifecta-based json parser but you can often improve aeson‚Äôs error messages using withObject and/or typeMismatch
05:39:58 <purelazy1> ggole: Thank you
05:42:16 <purelazy1> :t (\x -> x :: Int) :: Int -> Int
05:42:18 <lambdabot> Int -> Int
05:42:37 <purelazy1> :t (\ (x :: Int) -> x) :: Int -> Int
05:42:38 <lambdabot> Int -> Int
05:43:10 <purelazy1> :t (\ (x :: Int) (s :: String) -> x) 
05:43:12 <lambdabot> Int -> String -> Int
05:43:17 <deepfire> cocreature: the problem is with derived parsers -- i.e. default behavior 
05:43:31 <deepfire> cocreature: I don't want to customize everything just to get better messages
05:43:45 <cocreature> deepfire: sorry can‚Äôt help you in that case
05:46:00 <deepfire> cocreature: the use case you can probably sympathise with -- covering a large body of a pre-existing REST API
05:46:26 <cocreature> deepfire: absolutely, I just have no idea to get better error messages in that case :)
05:47:32 <deepfire> cocreature: sometimes I think we would benefit from a parser library abstracting over common parts of trifecta and attoparsec
05:48:10 <cocreature> deepfire: I thought parsers was that library?
05:48:20 <deepfire> wow
05:48:25 <cocreature> https://hackage.haskell.org/package/parsers
05:48:34 <cocreature> but I might be wrong
05:49:09 <deepfire> but is it switchable -- as in, can the user decide (ideally at run-time) which parser to use?
05:49:33 <t0by> I'm sorry, is there an op in here?
05:49:58 <deepfire> if it is.. it'd be uber cool to give aeson the ability to choose between them
05:50:52 <cocreature> deepfire: if you define your parsers generically over some typeclasses anything that has an instance for that should work. afaik parsers supplies instances for trifecta, parsec & attoparsec
05:53:57 <deepfire> cocreature, the remaining serious problem would be parsers coverage, then -- whether aeson has to reach out to parts of attoparsec that aren't covered?
05:54:37 <cocreature> no idea, but since aeson seems to be fairly optimized I doubt you‚Äôll be able to make it generic easily
05:54:50 <deepfire> meh : -)
05:54:57 <cocreature> but give it a try :)
05:55:16 <deepfire> I guess I'll start lazy and make a github issue first : -)
06:02:06 <deepfire> oh
06:02:09 <maybefbi> once ive figured out typeclasses, how can i start learning type families and kinds. is there a *-opedia for those?
06:02:24 <maybefbi> what is the difference between type families and kinds?
06:03:11 <deepfire> type families are "just" a limited set of type-level expressions, namely a type-level case
06:03:47 <deepfire> maybefbi: type families 1) dispatch on their arguments types and 2) map these to result types
06:04:03 <maybefbi> so type families are functions
06:04:20 <deepfire> maybefbi: a very, very limited subset of, yes
06:04:31 <deepfire> maybefbi: kinds are essentially types for types
06:05:01 <maybefbi> so type of type families are kinds?
06:05:22 <deepfire> yes
06:05:51 <maybefbi> hmm ok where can see encyclopedia of kinds and type families commonly used?
06:06:14 <maybefbi> like functors/monoids for type classes
06:06:14 <deepfire> have you seen haskell wiki about those?
06:06:43 <maybefbi> deepfire, you mean these https://wiki.haskell.org/GHC/Type_families ?
06:07:09 <deepfire> maybefbi: yes
06:08:15 <deepfire> there is probably nothing like an encyclopedia, as there are no names involved
06:09:04 <deepfire> cocreature: I have realised the mistake I made
06:09:12 <maybefbi> ok
06:09:29 <deepfire> cocreature: by the time you get to the aeson errors, there's no parser involved
06:09:44 <cocreature> ah makes sense
06:09:58 <deepfire> cocreature: the errors relevant to the programmer, in aeson's case, are all about perfectly parsed Value's
06:10:14 <maerwald> mh, I think one could use viewPatterns/Patternsynonyms in order to avoid exporting a constructor, yes?
06:11:52 <deepfire> cocreature: it's especially silly for me to having make that mistake because I have only recently read https://ro-che.info/articles/2014-04-20-json-validation-combinators
06:12:11 <cocreature> deepfire: we all do silly things :)
06:12:55 <deepfire> cocreature: he specifically talks about that problem, and how he had to work around it
06:13:22 <deepfire> the perfectionist in me craves for a JSON parser library based on that.. : -/
06:15:47 <deepfire> ah the perils of infinite amounts of tangents to pursue to one's original motivation.. : -)
06:15:56 <deepfire> *on the road to
06:16:22 <saurabhnanda> is there a function that can check for undefined values?
06:16:39 <purelazy1> > let (!) n = product [1..n]
06:16:40 <lambdabot>  <no location info>: not an expression: ‚Äòlet (!) n = product [1..n]‚Äô
06:17:09 <deepfire> saurabhnanda: ChasingBottoms comes to mind, but I'm not sure it's /exactly/ what yo need
06:17:19 * deepfire waves at nkaretnikov
06:17:51 <nkaretnikov> deepfire: yo
06:19:05 <saurabhnanda> deepfire: can it be used to check if a field (in a record) is undefined?
06:19:18 <deepfire> nkaretnikov: I'm aeson's victim now as well
06:20:10 <cocreature> saurabhnanda: you could catch ErrorCall and check if the argument is Prelude.undefined
06:20:20 <cocreature> saurabhnanda: but if you need to check for undefined you have probably done something wrong
06:20:24 <deepfire> saurabhnanda: I'm not sure, I haven't looked at it in detail, but at the very least it has `isBottom`
06:21:21 <saurabhnanda> deepfire: cocreature: let me finish what I was doing, then I'll share a gist, which will explain my motivation for doing this
06:22:26 <nkaretnikov> deepfire: i've started writing a new json lib but haven't done anything besides defining the types
06:22:54 <purelazy1> :set -XPostfixOperators
06:22:57 <saurabhnanda> how to reduce the duplication in stuff like this: // instance Timestamped User // instance Timestamped Aria2Log // instance Timestamped Download
06:23:10 <purelazy1> > let (!) n = product [1..n]
06:23:12 <deepfire> nkaretnikov, what is the library's supposed scope?
06:23:12 <lambdabot>  <no location info>: not an expression: ‚Äòlet (!) n = product [1..n]‚Äô
06:23:28 <nkaretnikov> deepfire: don't know what you mean by "scope" here
06:24:10 <deepfire> nkaretnikov: you said "json lib", but that's a pretty wide scope -- what is it supposed to do?
06:24:40 <nkaretnikov> deepfire: parse and print json in a friendly way, have a friendly internal representation, too
06:24:51 <nkaretnikov> deepfire: the speed is not a major concern at the moment
06:25:19 <deepfire> nkaretnikov: what are you considering for the underlying parser?
06:25:32 <nkaretnikov> deepfire: i don't really know at the moment
06:25:46 <deepfire> I would be ecstatic to have trifects, since it's "the kind of error messages"
06:25:55 <saurabhnanda> how do I combine: IO (val) and  (val -> ReaderT SqlBackend m (Key val)), where (MonadIO m)?
06:26:00 <nkaretnikov> deepfire: trifecta, you mean?
06:26:11 <deepfire> nkaretnikov: yes -- it gives you an error caret by default
06:26:32 <saurabhnanda> hang on, ReaderT is also MonadIO
06:26:40 <nkaretnikov> deepfire: hmmm, i'm not even done with the types at the moment
06:26:56 <nkaretnikov> deepfire: haven't researched what to pick for representing numbers internally
06:27:02 <nkaretnikov> deepfire: aeson uses scientific
06:27:15 <nkaretnikov> deepfire: haven't checked whether it matches the spec on json.org
06:27:51 <nkaretnikov> deepfire: anyway, i'd like to focus my ghc work right now, but feel free to ask more questions
06:27:54 <nkaretnikov> on*
06:28:15 <deepfire> nkaretnikov: cool!
06:57:02 <iphy> is there an inet_ntoa that's not in IO?
06:57:10 <iphy> or: why is inet_ntoa in IO?
07:01:10 <geekosaur> because windows :/ it only works under withSocketsD
07:01:15 <geekosaur> withSocketsDo
07:01:58 <iphy> I see
07:02:00 <hsk3> If I quickCheck a function foo :: [Double] -> Bool, how does QuickCheck pick that list of Doubles?
07:02:01 <hsk3> What edge cases does it look at? How large lists does it create?
07:02:40 <iphy> but all I want is to turn 0x01020304 into 4.3.2.1 (for all values)
07:02:47 <iphy> what's IO about this?
07:03:11 <geekosaur> iphy, nothing on Unix. you'd have to ask Microsoft why they require Winsock initialization for it to work
07:03:56 <nitrix> hsk3: Typically, 100 checks.
07:04:02 <geekosaur> hsk3, quickCheck doesn't know anything special about Double. the default is to do 100 tests
07:04:03 <pavonia> hsk3: I think it just picks some random numbers
07:04:32 <geekosaur> and it will generate a lazy list of Double-s for the tests, from which it will take 100 numbers if all you are testing is a single call to that function
07:04:34 <geekosaur> er
07:04:35 <geekosaur> no
07:04:49 <geekosaur> parm is a list not a single Double, derp
07:04:55 <geekosaur> I don't know how it picks list sizes offhand
07:04:59 <hsk3> geekosaur: I thought QuickCheck was smart about looking at edge cases. Like the empty list. Or 0. Or the largest/smallest Double on the platform.
07:05:23 <nitrix> > quickCheck (<= 'Z')
07:05:25 <lambdabot>      Couldn't match expected type ‚ÄòQuickCheck-2.8.1:Test.QuickCheck.Random.QC...
07:05:25 <lambdabot>                  with actual type ‚ÄòChar -> Bool‚Äô
07:05:25 <lambdabot>      In the first argument of ‚ÄòquickCheck‚Äô, namely ‚Äò(<= 'Z')‚Äô
07:05:40 <geekosaur> hsk3, it handles some common edge cases, it doesn't know that IEEE floating point has its own special cases
07:05:59 <hsk3> ok
07:07:04 <nitrix> hsk3: Try verboseCheck instead.
07:07:14 <nitrix> hsk3: It'll show you the data it's using.
07:07:19 <geekosaur> iphy, if you're doing this only on Unix you might FFI-bind directly to libc's inet_ntoa
07:08:19 <geekosaur> iphy, oh, sorry, it has to allocate a C string, that is unambiguously IO
07:08:42 <iphy> fine
07:08:44 <runeks> Why won't this snippet compile? http://lpaste.net/154101
07:08:46 <iphy> I'll rewrite the function in haskell
07:09:00 <iphy> it's super simple, I just hoped that it would exist already
07:09:26 <hsk3> nitrix: nice thanks
07:09:41 <geekosaur> runeks, if line 8 is supposed to be an additional parameter to the mapLeft expression then it needs to be indented
07:09:41 <runeks> "Could not deduce (Serialize a1) arising from a use of ‚Äòget‚Äô"
07:10:01 <geekosaur> (althought hat may not be the precise problem here)
07:10:48 <runeks> geekosaur: I still get the same error
07:10:51 <geekosaur> oh, you're assuming the a in (Get a) is the same as the one in the signature for parseMessage
07:10:57 <geekosaur> it's not, it's a completely unknown type
07:11:16 <geekosaur> you could use ScopedTypeVars extension to get around that
07:12:16 <lpaste> geekosaur annotated ‚ÄúNo title‚Äù with ‚ÄúNo title (annotation)‚Äù at http://lpaste.net/154101#a154102
07:13:03 <geekosaur> there may be better ways to avoid that but I have no idea what most of those functions are so no way to know if ScopedTypeVars could be avoided
07:13:37 <runeks> geekosaur: Thanks. I will read up on that.
07:14:18 <geekosaur> people often assume that if you use something like that :: Get a, the a there means the same a as in the type signature. it doesn't, what you did was tell it that it could be *any possible* a
07:14:35 <geekosaur> many people think scoped type vars should be on by default...
07:18:49 <deepfire> geekosaur: maybe once they are included in next Haskell201x.. one can hope : -)
07:19:20 <deepfire> (unless other implementations revolt against this outragoues mischief..)
07:19:30 <geekosaur> nobody knows how much code would be broken. (you can check against hackage but that doesn't help with the massive amounts of proprietary code in e.g. financial companies
07:20:11 <deepfire> geekosaur, see how much code breaks every time new GHC comes out.. nobody complains much
07:20:14 <runeks> geekosaur: So let's say I modified parseMessage to also take an argument of type "a", then it would work? Although I'd have to pass a MessageType to the function to get it to return one?
07:20:45 <geekosaur> deepfire, not sure where you've been hiding, FTP caused a *lot* of headaches
07:20:51 <hsk3> For a func :: Int -> Int -> Bool,   how to limit the second argument to be nonzero before passing it into quickCHeck?
07:21:25 <deepfire> geekosaur, even ignoring FTP
07:21:40 <geekosaur> runeks, yes to the first part, I don't know enough about the functions in question to say about the second
07:22:17 <deepfire> geekosaur, GHC 8 broke a lot of stuff, without FTP being involved
07:22:32 <deepfire> geekosaur: people fix things and move along
07:23:05 <pavonia> :t (==>)
07:23:06 <lambdabot> STestable prop => Bool -> prop -> Test.QuickCheck.Safe.SProperty
07:23:09 <geekosaur> deepfire, there's a lot of stuff you don't see if you just hang out in here. *many* people are annoyed by the constant language thrashing from ghc. it's one reason some places have moved from haskell to ocaml
07:23:20 <pavonia> hsk3: ^ Use this I guess
07:23:32 <geekosaur> open source types seem to be used to things changing constantly. not so much in business and financial contexts
07:23:47 <hsk3> pavonia: what?
07:23:48 <deepfire> geekosaur: well, other languages are very very similar
07:24:03 <geekosaur> and from what I've seen open source types often live in their echo chamber and simply do not get this at all
07:24:03 <deepfire> geekosaur: the industrial approach is to fix a version of the language
07:24:06 <pavonia> hsk3: The (==>) function
07:24:19 <geekosaur> they[re absolutely certain it's not a problem, and don't want to hear otherwise
07:25:15 <deepfire> geekosaur, Java breaks things routinely, very industrial language
07:25:33 <deepfire> from what I hear, anyway
07:25:43 <hsk3> pavonia: you have an example?
07:25:46 <geekosaur> yes, and that's why it's a fertile source of security holes. they can
07:25:56 <geekosaur> 't just u[grade to the latest security fix
07:26:14 <deepfire> it's well tolerated in the industry, as you can see
07:26:42 <deepfire> yet somehow when breakage happens across versions in Haskell it becomes an issue
07:27:16 <geekosaur> yes, it's normal for industry to ignore security issues as with the Java example
07:27:27 <geekosaur> whatever, the echo chamber listens only to itself again
07:27:28 <pavonia> @quickcheck \x y -> x > 0 ==> signum x == signum (abs y)
07:27:28 <lambdabot> Unknown command, try @list
07:27:34 <pavonia> @check \x y -> x > 0 ==> signum x == signum (abs y)
07:27:35 <lambdabot>  : -1: -1:Ambiguous infix expression
07:28:19 <deepfire> the security tangent to Java is also special -- Haskell doesn't attempt to provide a sandbox
07:28:33 <deepfire> you just don't run untrusted code in Haskell
07:29:09 <maerwald> deepfire: you read all code before you run it?`:o
07:29:14 <deepfire> so the security tangent is much deemphasized, and so sticking to a version is even less of a problem in Haskell than in Java
07:29:37 <deepfire> maerwald: do you run Haskell code in some sort of a sandbox?
07:29:42 <maerwald> yes
07:29:50 <pavonia> @check \x -> not (null x) ==> ([head x] == take 1 x)  -- hsk3
07:29:51 <lambdabot>  <hint>:1:77:
07:29:51 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
07:30:04 <pavonia> God ...
07:30:05 <deepfire> maerwald: can you tell about it?
07:30:09 <pavonia> @check \x -> not (null x) ==> ([head x] == take 1 x)
07:30:11 <lambdabot>  +++ OK, passed 100 tests.
07:30:14 <pavonia> hsk3: ^
07:30:44 <hsk3> pavonia: so ==> essentially is for skipping things?
07:30:44 <maerwald> deepfire: it's a WIP filemanager... types are meaningless when dangerous IO operations can happen and haskell doesn't give you that much benefit when it comes to IO bugs
07:31:04 <maerwald> so because I don't really know whether it will erase my whole hard drive
07:31:09 <maerwald> I run it in a docker container
07:31:11 <pavonia> hsk3: It's for defining constraints
07:31:31 <deepfire> maerwald, so not the same kind of sandboxing guarantees (sic) that Java provides
07:31:38 <hsk3> pavonia: so if that constraint is not satisified, it doesn't go into the test
07:31:51 <hsk3> pavonia: and i assume you can have multiple constraints with many ==>s
07:31:55 <hsk3> chained together
07:32:14 <maerwald> the point is that haskell doesn't save you from dangerous things happening, so sandbox is still a good idea if possible
07:32:22 <deepfire> absolutely
07:32:45 <deepfire> but Haskell doesn't try provide one for general code, out of the box, like Java does
07:32:48 <pavonia> hsk3: Not sure if you can chain them, but you can combine them using (&&)
07:33:01 <hsk3> ok nice thanks
07:33:01 <maerwald> accessDatabase :: IO Database -- might launch the missiles ;)
07:33:25 <deepfire> and the point was that it makes the security tangent much less important, because the insecurity is factored into the program design/use cases
07:34:00 <deepfire> so you will get less security problems from fixing GHC version, than what you get with Java
07:34:28 <deepfire> so if version fixing is viable in Java, it is even more viable in Haskell
07:34:35 <maerwald> well, that's a moot point though
07:34:48 <maerwald> it's not really an advantage
07:35:02 <deepfire> it's a circumstance
07:36:05 <maerwald> it's like saying you don't have that many security bugs in gcc... because well, the security bugs are in the program code instead 
07:36:24 <deepfire> maerwald: the whole picture is what is important
07:36:34 <deepfire> people complain that GHC break things, yet this is accepted in Java -- all this in context of increased viability of version fixing in Haskell
07:36:36 <maerwald> centralizing that is always good, whether it's the compiler (in the case of rust for example) or a sandbox
07:38:54 <maerwald> deepfire: that's true, you are left with the security concerns yourself
07:39:19 <maerwald> so version fixing is less "problematic"
07:39:37 <maerwald> (it should be problematic ;)
07:39:50 <deepfire> but also
07:40:02 <deepfire> most Java code isn't run in a sandbox
07:40:55 <deepfire> there's a lot of code that is run server-side, and for them the same considerations apply
07:41:08 <deepfire> they just don't care about sandbox vulnerabilities
07:41:21 <maerwald> if I could tell GHC "only these ~5 functions are actually allowed to _write_ to disk"... I could probably just remove my sandbox mechanisms. But all I have is IO, which is basically everything.
07:42:21 <maerwald> so for every IO function I have to assume it can try to delete my whole hard drive
07:42:44 <deepfire> what about unsafePerformIO
07:42:55 <maerwald> yeah, that makes it even worse
07:43:03 <maerwald> but I'm not using it
07:43:16 <maerwald> and I'm only talking about MY code
07:45:22 <sm> ClaudiusMaximus: I'm updating rss2irc for buildability.. did you already do this, or use older GHC/deps or something ?
07:53:54 <geekosaur> maerwald, there have been attempts to subdivide IO and use typeclasses or other resource identifiers to constrain it. IIRC it rapidly becomes unwieldy
07:54:38 <ClaudiusMaximus> sm: i've been using ghc-7.8.2 because updating to 7.10 seemed quite a hard task
07:55:56 <maerwald> geekosaur: because you need a proper effect system
07:56:56 <ClaudiusMaximus> sm: also my darcs-fu is too weak to know how to split a patch into two, as you recommended
07:57:13 <geekosaur> that still doesn't save you, sadly. at some point it becomes a question of how much you trust your interface between the language and the outside world
07:57:51 <maerwald> that's already the case with the impure GHC implementation, is it not?
07:58:27 <sm> ClaudiusMaximus: ah, ok. Just updated for 7.10 here. Let me see if I can preserve your authorship while splitting
08:05:20 <sm> ClaudiusMaximus: though, it looks pretty easy in this case: just "darcs unrecord", answer yes for both patches, and record new ones
08:07:30 <dramforever> A just curious question: Why are some of the functions in GHC's source code of libs [1] written with :: and = so far away?
08:07:40 <dramforever> [1] e.g. http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#until
08:08:30 <dramforever> Some, but not all. Also I don't think I've ever seen this style elsewhere
08:09:13 <sm> dramforever: they're lining up successive declarations, so you can more easily scan them all and see similarities/differences
08:10:03 <sm> it seems a bit questionable there. Maybe it looked better in the past
08:10:35 <dramforever> yeah
08:11:01 <dramforever> Perhaps that's how they used to do it?
08:11:23 <dramforever> (Also TIL until is a thing)
08:11:49 <sm> I frequently do it with case patterns and similar
08:12:41 <zebr> hi all. is there an easier way of writing do { False <- lift f ; lift g } :: MaybeT m () ?
08:12:50 <ClaudiusMaximus> sm: ok, but do i need to do anything to push the diverged repo?
08:13:14 <ClaudiusMaximus> will give it a go
08:13:32 <sm> ClaudiusMaximus: yes, you'll need to obliterate the old patches on darcs hub: ssh hub.darcs.net obliterate rss2irc and say yes twice
08:13:32 <dramforever> sm: but that's already cross-function aligning... Might be useful, but really sounds weird
08:13:44 <ClaudiusMaximus> sm: ok, thanks
08:14:16 <sm> ClaudiusMaximus: you may want to rebase on my latest too (ie pull it)
08:17:46 <E3mber> hello
08:18:00 <joneshf-laptop> Is there a way to get ghci to spit out a slightly less polymorphic type signature when you use `:t`? For example, If I wanted `fmap :: (a -> b) -> [a] -> [b]`, what sort of thing could I type into ghci to make this happen?
08:18:25 <joneshf-laptop> Or I guess, i'm really asking if you can choose a constraint with `:t`.
08:18:56 <bollu> how does one push a Haskell package into Stackage?
08:18:58 <dramforever> :t fmap :: <that type there>
08:19:00 <lambdabot> parse error on input ‚Äò<‚Äô
08:19:07 <bollu> as in, what's the process?
08:19:19 <dramforever> ouch, but you get it :)
08:19:46 <dramforever> :t fmap :: (a -> b) -> [a] -> [b]
08:19:47 <joneshf-laptop> dramforever, yeah, but is there a way to do that without just typing in the type signature I actually want? :)
08:19:47 <lambdabot> (a -> b) -> [a] -> [b]
08:20:02 <sm> bollu: send a pull request adding it to the stackage config file.. see their docs for details
08:20:05 <ClaudiusMaximus> sm: how do i do that?  i just recorded the split patches locally
08:20:45 <sm> ClaudiusMaximus: ok, they probably won't conflict; try darcs pull hub.darcs.net:simon/rss2irc now
08:21:28 <joneshf-laptop> dramforever, maybe somehting similar to `asTypeOf`?
08:21:37 <joneshf-laptop> :t asTypeOf
08:21:38 <lambdabot> a -> a -> a
08:21:56 <synergistics> What's useful about ((->) r) being a monad? Also, what does really mean?
08:21:57 <dramforever> joneshf-laptop: not really :/ but there is an extension in (not yet released) ghc 8.0 that allows you to pick type variables
08:22:15 <nitrix> synergistics: That'd be the reader monad.
08:22:27 <joneshf-laptop> dramforever, ah, dang. Oh well.
08:22:30 <joneshf-laptop> dramforever, thanks though
08:23:16 <dramforever> :t liftA2 (/) sum (fromIntegral . length) [4,7,5,8] -- one-liner avg (admittedly having to traverse the list twice... but hey!)
08:23:17 <lambdabot> Fractional t => t
08:23:19 <Maxdamantus> > do{ a <- id, b <- (*2); return (a + b) } 5
08:23:20 <lambdabot>  <hint>:1:12: parse error on input ‚Äò,‚Äô
08:23:33 <Maxdamantus> > (do{ a <- id, b <- (*2); return (a + b) }) 5
08:23:34 <lambdabot>  <hint>:1:13: parse error on input ‚Äò,‚Äô
08:23:49 <Maxdamantus> Meh, tired.
08:23:54 <ClaudiusMaximus> sm: merged and pushed
08:23:55 <Maxdamantus> > (do{ a <- id; b <- (*2); return (a + b) }) 5
08:23:57 <lambdabot>  15
08:24:00 <nitrix> synergistics: ^
08:24:00 <sm> great
08:24:14 <xa0> neat
08:24:24 <dramforever> > liftA2 (/) sum (fromIntegral . length) [4,7,5,8]
08:24:26 <lambdabot>  6.0
08:24:46 <nitrix> synergistics: The value 5 is being trapped in the monadic context; thus, you can see the reader monad as sort of computational "environments" in which you have access to the value whenever needed.
08:24:46 <xa0> so is that the sort of thing you use the reader monad for?
08:24:54 <nitrix> xa0: yeah.
08:25:00 <xa0> cool
08:25:15 <dramforever> well, technically that's a benefit of it being an applicative... but you see all monads are applicatives nowadays
08:25:33 <sm> ClaudiusMaximus: no need to split the utf8 fix by file, but it's no problem
08:26:01 <sm> hmm.. the connect fix depends on the utf8 fix
08:26:14 * dramforever almost always only use the ((->) r) monad for one-liners
08:26:28 <nitrix> I don't.
08:26:53 <ClaudiusMaximus> sm: yes, it uses the two helper functions from the earlier patch
08:26:54 <sm> I would really like to keep encoding related fixes independent of other things, and with tests
08:27:06 <nitrix> dramforever:   mainLoop :: Game -> Environment IO ()
08:27:22 <nitrix> dramforever: I use it for my game, where multiple functions needs the window, the renderer and a few other things to properly work.
08:27:33 <nitrix> (Read-only)
08:28:27 <nitrix> Depending what the function needs, it just  renderer <- asks envRenderer  at the begining :)
08:28:28 <ClaudiusMaximus> sm: maybe the irc needs to be rewritten to use ByteString for network IO instead of going String -> ByteString -> String -> IO
08:28:34 <dramforever> nitrix: If I ever needed something larger, yes like that, chances have been high that I would need a monad transformer stack
08:28:38 <sm> could be, indeed
08:28:49 <synergistics> (id >>= \a -> (* a 2) >>= return (a + b)) 5
08:28:56 <synergistics> > (id >>= \a -> (* a 2) >>= return (a + b)) 5
08:28:58 <lambdabot>      Couldn't match expected type ‚Äòa0 -> b‚Äô with actual type ‚ÄòExpr‚Äô
08:28:58 <lambdabot>      Relevant bindings include
08:28:58 <lambdabot>        a :: a0 -> b (bound at <interactive>:1:10)
08:29:00 <nitrix> dramforever: Yeah, Environment is a monad transformer.
08:29:03 <nitrix> dramforever: type Environment m a = ReaderT Environment' m a
08:29:03 <sm> ClaudiusMaximus: how can we test the utf8 fix, even manually ?
08:29:13 <synergistics> > (id >>= \a -> (* a 2) >>= \b -> return (a + b)) 5
08:29:15 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ a1 -> a
08:29:15 <lambdabot>      Expected type: (a1 -> a) -> a1 -> a
08:29:15 <lambdabot>        Actual type: a -> a
08:29:34 <nitrix> dramforever: Still pretty cool :)
08:29:45 <Maxdamantus> > (id >>= \a -> (* 2) >>= \b -> return (a + b)) 5
08:29:47 <lambdabot>  15
08:30:02 <ClaudiusMaximus> sm: i guess create a feed file with strange characters and force announcing them to a test channel (or terminal without irc)
08:31:30 <sm> yeah, we'll need something like that for any encoding fixes, since it is such a swamp 
08:32:02 * sm looks for existing tests
08:32:21 <sm> none :)
08:32:27 <dramforever> in which case it'll be MonadReader, or ReaderT
08:32:28 <dramforever> otoh I often find myself using interesting bits of ((->) r) to point-free-ify functions
08:32:28 <dramforever> it's useful when combining results of functions, like the avg above
08:32:28 <dramforever> yeah pretty cool :)
08:34:27 <orion> Is the documentation here wrong?: https://hackage.haskell.org/package/http-client-0.4.27/docs/Network-HTTP-Client.html#t:Request
08:34:37 <orion> "The constructor for this data type is not exposed. Instead, you should use either the def method to retrieve a default instance"
08:34:57 <orion> The problem is that none of the record fields are exposed, making it impossible to do what the code below demonstrates.
08:35:48 <dramforever> they are :)
08:35:56 <dramforever> just do what you expect
08:36:21 <dramforever> see "method", "secure", etc. below?
08:37:02 <dramforever> orion ^
08:37:24 <geekosaur> the fields are not exported as part of a constructor, so you can't e.g. pattern match on them. the projection functions *are* exported
08:37:39 <orion> No, those are accessors.
08:38:13 <dramforever> The one downside of this approach is that it‚Äôs not immediately obvious from the Haddocks that you can actually change the settings via record syntax. That‚Äôs the point of this chapter: to clarify what‚Äôs going on in the libraries that use this technique.
08:38:14 <dramforever> says the link
08:38:29 <sm> ClaudiusMaximus: I thought it had the ability to read feed items from a file, but alas not yet
08:38:40 <orion> If I try to do what the code tells me, I get this error: ‚Äòmethod‚Äô is not a (visible) constructor field name
08:39:35 <dramforever> !?
08:39:46 <geekosaur> what ghc version?
08:41:01 <ClaudiusMaximus> sm: i thought i saw that in the code, branching on file://
08:42:04 <sm> oh, yay
08:42:11 <orion> 7.10.3
08:43:39 <Rotaerk> orion: if you look at the source, method is a field of the record, so you should be able to use it in the way it's suggesting
08:44:52 <sm> ClaudiusMaximus: yes, rss2irc -q -n1 file:test.xml
08:45:19 <Rotaerk> orion: what does your code look like that's producing that error?
08:47:30 <sm> shelltestrunner would be one way to automate
08:47:41 <orion> I just tracked it down. There is a conflict between Network.Wai.Request and Network.HTTP.Client.Request.
08:47:52 <Rotaerk> no wai
08:49:51 <dramforever> orion: glad you solved it :)
08:51:03 * hackagebot path 0.5.7 - Support for well-typed paths  https://hackage.haskell.org/package/path-0.5.7 (ChrisDone)
08:55:44 <ClaudiusMaximus> sm: cool.  i go out now, back later
08:56:35 <sm> ClaudiusMaximus: me too.. thanks for working on it
09:03:36 <roelof> is it correct that hutton's razor is here at tree : http://lpaste.net/154108
09:16:04 * hackagebot rss-conduit 0.2.0.0 - Streaming parser/renderer for the RSS 2.0 standard.  https://hackage.haskell.org/package/rss-conduit-0.2.0.0 (koral)
09:18:05 <roelof> another question : can I use a case statement into a foldr ? 
09:18:53 <maerwald> just make the "case statement" in another function?
09:19:54 <roelof> oke, I have to make a huttons razor that can calculate this : Add (Lit 1) (Add (Add (Add (Lit 1) (Lit 9001)) (Lit 1)) (Lit 20001)) maerwald  
09:20:42 <roelof> so I wonder if I could make a one case for Lit and one for Add to make this work 
09:21:06 <Geraldus> hi friends!
09:21:07 <Geraldus> o/
09:22:48 <roelof> Geraldus: hello 
09:24:39 <Geraldus> I have a library for DOM manipulation using GHCJS.  Currently it uses `JSString`s everywhere, I tended to substitute it with more general type, e.g. `IsString a => a -> ‚Ä¶`.  But now I'm not certain is it good idea?  I suppose this will bring some overhead at runtime due to conversions, and maybe other issues related to polymorphism.  Can anyone say about pros and cons of
09:24:39 <Geraldus> IsString approach?
09:25:58 <Geraldus> The library itself is designed to be compatible with GHC, because it supposed to be used in monolithic server-and-client apps
09:30:11 <tippeneinn> Why would someone avoid using partial functions? Is there some sort of ghc penalty?
09:32:14 <tippeneinn> ah, there's a write-up about it https://wiki.haskell.org/Avoiding_partial_functions
09:34:33 <tippeneinn> actually, it's not very convincing. this reads more like "use case instead of if/then/else"
09:35:46 <MarcelineVQ> partial functions throw exceptions if given an input they don't handle, in practise this can mean there's a crash waiting to happen in your program, depending on the use and the function. https://wiki.haskell.org/Partial_functions linked from the page you were on says a bit more about it
09:35:48 <tippeneinn> ohhhh, I've confused partial application with partial function.
09:36:16 <roelof> tippeneinn:  I think the answer is in the first line. If you use partials , you could make functions that crash like head on a empty list 
09:36:44 <roelof> oops, MarcelineVQ  beats me 
09:48:05 <maerwald> meh, I think I'm gonna have to write another path library
09:48:29 <danharaj> edwardk: hey, is concurrent supply deterministic?
09:55:23 <quchen> Is there a reason `stack --coverage` does not generate coverage reports for the testsuite itself?
09:56:20 <quchen> Just wondering, no specific use case
09:59:34 <hsk3> This works of course: getSum (Sum 2)
09:59:35 <hsk3> But this works in the same way: getSum (2 :: Sum Int)
09:59:36 <hsk3> Why? I'm not sure why.
09:59:41 <hsk3> Is this some special feature of newtype?
10:00:28 <Eduard_Munteanu> hsk3, Sum is an instance of Integral
10:01:10 <Eduard_Munteanu> :t fromInteger
10:01:11 <lambdabot> Num a => Integer -> a
10:01:17 <Eduard_Munteanu> Er, Num.
10:01:31 <roelof> MarcelineVQ:  I solved rewritting the big if then function we talked yesterday  into a map 
10:01:50 <roelof> So the telephone challenge is finally solved 
10:01:55 <Eduard_Munteanu> hsk3, every number literal is actually sugar for fromInteger
10:03:07 <Eduard_Munteanu> Every integer literal, even.
10:04:03 <Eduard_Munteanu> > 'a' :: Int
10:04:04 <lambdabot>      Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚ÄòChar‚Äô
10:04:04 <lambdabot>      In the expression: 'a' :: Int
10:04:08 <MarcelineVQ> roelof: yes your convertSentence changed looked good. you're almost done but your fingerTaps function doesn't do what it's supposed to
10:04:22 <Eduard_Munteanu> > 1 :: Char
10:04:23 <lambdabot>      No instance for (Num Char) arising from the literal ‚Äò1‚Äô
10:04:23 <lambdabot>      In the expression: 1 :: Char
10:04:33 <Eduard_Munteanu> Which is why you get that error message.
10:04:52 <osfameron> hmm, Lucid script_ tags don't seem to work as I'd expect
10:05:02 <osfameron> e.g.   script_ "some javascript"  does work
10:05:16 <osfameron> but:  script_ [src_ "path/to/some.js"]   doesn't
10:05:39 <roelof> MarcelineVQ:  how do you mean. When I enter a char I see the right output as far as I can see 
10:05:49 <osfameron> I think I'm going to stop using Lucid.  It's maddening and barely documented.
10:06:10 <geekosaur> ...it's illucid? :p
10:06:18 <osfameron> geekosaur: hah, yes
10:06:31 <hsk3> Eduard_Munteanu: ah ok. So this works because Sum is an instance of Integral.
10:06:33 <hsk3> thanks, nice to know
10:06:43 <Eduard_Munteanu> hsk3, of Num
10:06:49 <puregreen> osfameron: it has to be ¬´script_ [src_ "path/to/some.js"] ""¬ª
10:06:53 <Eduard_Munteanu> @instances Sum
10:06:56 <lambdabot> Couldn't find class `Sum'. Try @instances-importing
10:07:07 <Eduard_Munteanu> @instances Num
10:07:09 <lambdabot> (Data.Fixed.Fixed a), (Shrink2 a), Blind a, CReal, Complex a, Double, Expr, Float, Int, Int16, Int32, Int64, Int8, Integer, Interval a, Large a, Natural, Product a, Ratio a, Small a, Sum a, Sym a, Word, Word16, Word32, Word64, Word8
10:07:39 <puregreen> osfameron: it's a bit annoying that you can't use often-empty tags like textarea and script without giving a "" parameter, but I think that's pretty consistent
10:07:55 <osfameron> puregreen: oh.  thanks.  how would I have figured that out?
10:07:57 <MarcelineVQ> roelof: fingerTaps wants you to make a single Int that is the total of every button press you do to write a sentence or conversation
10:08:16 <hsk3> thanks
10:08:31 <MarcelineVQ> in other words, given a list of [(Digit, Presses)] what is the total of Presses
10:08:37 <osfameron> https://hackage.haskell.org/package/lucid-2.9.4/docs/Lucid.html has no example with src_ 
10:08:50 <osfameron> and the Lucid.Html5 docs simply show the type: script_ :: TermRaw arg result => arg -> result
10:08:54 <osfameron> (which makes no sense)
10:09:54 <puregreen> osfameron: well, I figured it out by accidentally trying to add "" and seeing it work, so I agree that the documentation could be improved
10:10:28 <osfameron> heh
10:10:37 <roelof> MarcelineVQ:  oke, then I can better rename my function. My function convert a char to a (char, int)  where char is the input char and int the place where the char can be found. 
10:10:58 <puregreen> but otherwise Lucid has been pretty pleasant for me, so... okay, I guess we just had different experience with it
10:11:04 <osfameron> in the mean time, I'm going to look at heist and the shakespearean templates
10:11:05 <roelof> I took the liberty to do it another way as the book described 
10:11:30 <roelof> osfameron:  have yoyu tried blaze-html ? 
10:11:34 <MarcelineVQ> roelof: the place it can be found is the presses though isn't it? that names arne't important
10:12:01 <roelof> oke, so a little change  ? 
10:12:05 <osfameron> puregreen: may be my general inexperience with haskell.  Lots of cases where I'd tie myself in knots because of it being monadic (and not understanding what that means)
10:12:11 <roelof> Take the int out of the tuple 
10:12:28 <osfameron> roelof: Lucid was billed as "a better blaze", so I think if I didn't get on with Lucid I should try a different type of thing entirely.
10:12:54 <MarcelineVQ> It just wants the total button presses you have to do for a given messages, which it does not correctly do at the moment.
10:13:54 <roelof> MarcelineVQ:  oke, I try to see what has to be changed 
10:14:29 <roelof> so fingerTaps has to work for only 1 message , right ? 
10:14:45 <quchen> Is there a reason I should generalize a ST computation to (PrimMonad m)? There's stToIO if I want to embed the computation inside IO after all, and the ST-monomorphic type is more readable.
10:15:10 <quchen> s/monomorphic/non-parametric
10:15:40 <roelof> MarcelineVQ:  and the message is in normal text or already changed into presses ? 
10:15:40 <parsecChar> is there any tutorial out there on how to buid your own langauge wiht haskell-src-exts ?
10:15:45 <parsecChar> something sorta like Fay, but a step by step tutorial
10:16:52 <quchen> Ah, nevermind, PrimMonad can also be a transformer with a PrimMonad at the base.
10:16:56 <MarcelineVQ> roelof: use whatever your convertSentence results in
10:17:14 <quchen> But even then I could use (liftIO . stToIO) to lift an ST computation into the stack.
10:17:23 <roelof> oke, I have to dig into it , moment  MarcelineVQ 
10:17:38 <monochrom> wait, does that mean "PrimMonadT (PrimMonadT PrimMonad) a" is a thing?!
10:17:58 <parsecChar> how does ghc api and haskell-src-exts compare when I just want a *.hs -> typed AST transformer ?
10:20:11 <quchen> monochrom: I don't know. Is that a joke? I can't tell.
10:20:21 <monochrom> it is a joke, don't worry :)
10:20:54 <quchen> Phew.
10:21:23 <quchen> Speaking of ST, I don't understand the difference between lazy and strict.
10:21:40 <quchen> And the documentation doesn't clarify it, unfortunately.
10:22:19 <quchen> What's IO? StrictST RealWorld or LazyST RealWorld?
10:22:20 <monochrom> I know some of it but not all. http://lpaste.net/63925 shows some experiments
10:22:30 <monochrom> the strict one
10:22:40 <quchen> Hm.
10:22:48 <monochrom> except when you use unsafeInterleaveIO
10:22:49 <maerwald> Mh... I can't really think of a usable Path type. If you encode information about the file type (as in Dir vs File) you'll end up with some weirdness that might be async to what is really going on at the IO level. If you don't encode that information, you lose safety wrt </> and friends operators
10:22:56 <quchen> Thanks for the link, monochrom.
10:24:20 <Eduard_Munteanu> maerwald, I think it's more worthwhile to distinguish relative and absolute paths rather than file/dir.
10:24:30 <maerwald> I think so too
10:24:38 <maerwald> but it's still going to open you up to some problems
10:24:43 <Eduard_Munteanu> E.g. so that rm -rf foo/bar// doesn't accidentally kill everything.
10:26:08 <maerwald> but what does the user mean if he inputs "/foo/", and what happens if "/foo" is in fact a file? You always have the Path-level disconnected from the filesystem level
10:26:56 <Eduard_Munteanu> Well, you only really know /foo is really an existing file or directory only at runtime.
10:27:29 <maerwald> yes and what you gonna do if the user inputs "/foo/" but the thing is not a directory?
10:27:34 <maerwald> do you compare that even?
10:27:49 <maerwald> and you only can if the Path-type contains Dir vs File information
10:29:05 <maerwald> but if you do, it ends up being a nuisance, because a lot of operations don't care if it's a file or directory... only a few ones
10:29:20 <maerwald> I feel like I'd need dependent types here
10:32:07 <Rotaerk> I don't understand how this :~: operator in Data.GADT.Compare is supposed to work
10:32:45 <Rotaerk> foo (a :: a) (b :: b) = case (Refl :: a :~: b) of Refl -> 1; _ -> 0
10:32:58 <Thassa> I remember when i haskelled
10:33:03 <Thassa> So long ago hweh
10:33:20 <Rotaerk> foo "Foo" "Bar"  returns 5
10:33:34 <Rotaerk> foo "Foo" 5  produces a compile-time error
10:33:44 <Rotaerk> is that the intention behind the operator?
10:36:06 <obadz> Rotaerk: well is (:~:) the type equality operator?
10:36:27 <obadz> Rotaerk: if so it stands to reason that it can't unify [Char] and Num a => a ?
10:38:14 <Rotaerk> obadz: I think I was just inferring from the name "Refl" that it would operate similar to .NET reflection:  at runtime
10:38:22 <Rotaerk> so if the types don't match, it would be a runtime error
10:38:42 <Rotaerk> but apparently not
10:39:01 <obadz> Actually I'm not familiar enough with this to say anything definitive about it
10:40:09 <Rotaerk> kind of drowning in haskell at the moment
10:41:01 <mauke> Refl sounds more like reflexive equality
10:41:10 <blogle> how do I circumvent infinite types in code like the following http://lpaste.net/154119
10:41:55 <Rotaerk> mauke: ah, that would make sense
10:42:16 <Rotaerk> also, these docs keep using the word "witness" in a way with which I'm not familiar
10:42:23 <mauke> blogle: what is that function supposed to do?
10:42:45 <Rotaerk> for instance the CEq class's geq method produces a "witness of type equality"
10:42:54 <mauke> Rotaerk: one meaning of witness is: a value of type T is a "witness" for that type
10:42:55 <Rotaerk> where can I find clarity around the meaning of that?
10:43:05 <Rotaerk> ah
10:43:15 <Rotaerk> similar to how Proxy works?
10:43:20 <mauke> it's probably related to curry/howard
10:44:41 <obadz> Rotaerk: your foo function infers this type sig: foo :: Num a => b -> b -> a
10:44:44 <blogle> mauke: well nothing right now really as its more an example case, but the idea is to accumulate state in the closure for message passing or effectful computations. 
10:44:54 <mauke> blogle: counter seems to take an Int, followed by an infinite stream of Msgs
10:44:58 <mauke> blogle: but it never produces any results
10:45:11 <mauke> you could model that as: Int -> [Msg] -> a
10:47:07 <mauke> blogle: a "state transformer" function would have a type like: Msg -> (Int -> Int)
10:47:17 <obadz> trying to understand Refl as mentionned by Rotaerk, why doesn't this typecheck? ‚áí let foo :: forall a b. a -> b -> Bool ; foo x y = case (Refl :: a :~: b) of Refl -> True ; _ -> False
10:47:31 <roelof> MarcelineVQ:  I try to solve this : http://lpaste.net/154120  and then I think I have got it working. 
10:47:35 <mauke> which is equivalent to Msg -> (Int -> ((), Int))
10:47:46 <mauke> which is Msg -> State Int ()
10:47:50 <roelof> I hope I see which function is missing something 
10:47:52 <obadz> Says "Couldn't match type ‚Äòa‚Äô with ‚Äòb‚Äô", Expected type: a :~: b, yada yada..
10:51:39 <ggole> obadz: you can't just produce a Refl of the desired type, it has to be produced such that it can be seen by the type checker to have that type
10:51:47 <roelof> mauke:  can you help me with this : http://lpaste.net/154120
10:51:56 <roelof> sorry mauke 
10:51:59 <MarcelineVQ> roelof: you don't need to use convertSentence as part of fingertaps definition you can just use convertSentence's output. if convertSentence results in [(String, Int)] then fingerTaps would be fingerTaps :: [(String, Int)] -> Int
10:53:17 <blogle> mauke: I am not sure transformers are what I want but I will look more closely... I *think* I am doing something along the lines of CPS
10:53:21 <obadz> ggole: not sure I understand. Is there a document somewhere that explains how to use Refl/:~: in simple terms?
10:53:25 <broma0> where can i find the 'd' quasi-quoter? saw it in a template haskell tutorial and they didnt specify where it comes from
10:53:37 <broma0> the qoter results in a "Q [Dec]"
10:54:15 <MarcelineVQ> roelof: That's an aside though, the issue with this is the function you're providing to map
10:54:46 <roelof> I thought that. IM a little confused now 
10:55:13 <ggole> obadz: usually you use a coercion function with a type like (a :~: b) -> a -> b (or sometimes (a :~: b) -> f a -> f b)
10:55:15 <MarcelineVQ> map expects to be provided with something in the form of  a -> b but your lambda is more like (t, a) -> a -> a
10:55:49 <roelof> MarcelineVQ:  you mean that I can pattern matching so I can take the second number out of the tuple ? 
10:56:52 <MarcelineVQ> sure, you can pattern match out the values of your tuple, you've done it multiple times in the book so far both yourself and using a library function for it
11:01:49 <roelof> MarcelineVQ:  oke, I have this : http://lpaste.net/154123 . Now I have to find out how I can make it work so the output of convertSentence is used 
11:04:02 <broma0> in general, how does one create a function using template haskell? 
11:04:17 <MarcelineVQ> it already works with the output of convertSentence
11:04:54 <MarcelineVQ> it takes [(String, Int)] which is what convertSentence gives
11:05:26 <roelof> oke, so I have to do fingertaps (convertSentence "roelof) 
11:07:08 <roelof> yes, when I do this it has a output  :) 
11:07:34 <mauke> broma0: re [d|...], https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html#th-syntax
11:07:38 <roelof> Now I have to rewrite the costs functions to use the new function 
11:07:53 <broma0> mauke: where is 'd' i cant find it for the life of me
11:08:02 <broma0> probably at the link you mentioned..
11:08:09 <mauke> what
11:08:21 <broma0> the 'd' quasiquoter, where is it defined
11:08:27 <MarcelineVQ> second line of A expression quotation is written in Oxford brackets, thus:
11:09:08 <mauke> broma0: it's built into the compiler
11:09:30 <broma0> mauke: ah, so it's exposed with the -XTemplateHaskell extension
11:09:33 <broma0> thank you
11:10:04 <mauke> further down: "The quoter cannot be "e", "t", "d", or "p", since those overlap with Template Haskell quotations."
11:13:10 <broma0> mauke: assuming i have the variable "s :: String" in scope, how can i define a function called `s` with a signature of `:: String`. Essentially, if `s == "myFunc"`, how can I define a function `myFunc = "myFunc"` using string interpolation?
11:13:49 <mauke> ... that's not a function
11:14:31 <broma0> ok fine, myFunc _ = "myfunc"
11:14:40 <mauke> wat
11:14:47 <Clint> clever
11:15:00 <broma0> this is a case of the XY problem - ill just give you the 'X' part :)
11:15:30 <roelof> MarcelineVQ:  happy with this solution : fingerTaps list = foldr (\((_,y):zs) res -> res + y) 0 list
11:16:14 <puregreen> broma0: I think it'd be ‚Äú[d|myFunc = $(stringE s)|]‚Äù
11:19:39 <MarcelineVQ> roelof: did you try it?
11:20:18 <roelof> yep, and it gave a integer back 
11:21:12 <gigglypuff> Okay, so, for those who have read SICP: How good was it (from one to ten)? What do I stand to gain from reading it? I'm thinking of reading it as an intro to functional programming, among other topics, due to it's prestigious reputation.
11:21:37 <MarcelineVQ> roelof: What was the number?
11:22:45 <mauke> broma0: http://lpaste.net/2137378878442700800
11:23:37 <asdfds> gigglypuff: 10/1
11:23:43 <asdfds> gigglypuff:  10/10*
11:24:28 <splanch> gigglypuff: SICP, both the book and lectures, are wonderful
11:25:09 <asdfds> gigglypuff: Reading SICP is like becoming Neo. Except programmers can already see the code so you can like see the code of the code. Or something.
11:25:14 <roelof> MarcelineVQ:  wierd, I loaded it a second time and now type errors  
11:25:51 <broma0> mauke: that's it exactly! thanks. how would that look using the [d| .. |] quoter? 
11:26:20 <gigglypuff> asdfds, splanch: Would you mind highlighting some specific rewards that reading SICP offer? Like, in what ways does it make you Neo lol? How is it a 10/10 read?
11:26:48 <mauke> broma0: no idea, I've never used quasiquoting
11:27:08 <gigglypuff> I'm checking out the Wordpress PDF atm for SICP
11:27:08 <asdfds> gigglypuff: Overall, it just provides a lot of insights to the nature of programming. It makes you think about code in ways day-to-day programming, and even the typical University Computer Science course, won't.
11:27:15 <roelof> MarcelineVQ:  see here : http://lpaste.net/154124
11:28:00 <gigglypuff> asdfds: https://sicpebook.files.wordpress.com/2012/11/sicp.pdf That's the version I'm reading atm. Is there a preferred/better variant I'm missing?
11:28:11 <broma0> mauke: when writing TH do you generally just stick to the syntax-tree types/constructors like StringE, ValD etc?
11:28:11 <asdfds> gigglypuff: It's hard to quantify. It's like, "How does learning to code, or learning Math, change how you think about the world?" Similar thing between SICP and coding.
11:28:15 <roelof> MarcelineVQ:  I think the problem is here : (\((_,y):zs) 
11:28:24 <MarcelineVQ> Yes that's right
11:28:35 <asdfds> gigglypuff:  Just use the HTML from SICP's website?
11:28:46 <mauke> broma0: I don't use TH
11:29:02 <broma0> mauke: fair enough.
11:29:24 <asdfds> gigglypuff: I used this one: http://mitpress.mit.edu/sicp/full-text/book/book.html
11:29:31 <roelof> I try to pattern match the list so it took the second number out of the tuple and the rest of the list 
11:29:56 <MarcelineVQ> Yes, the problem is there isn't a list
11:29:58 <roelof> so what I do here function ( (x,y):zs) 
11:29:59 <horrorcheck> gigglypuff: I didn't like it as much as most folks seem to. I thought it was pretty boring and difficult.
11:30:01 <MarcelineVQ> :t foldr
11:30:03 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:30:29 <MarcelineVQ> the function you're making is (a -> b -> b) a is one item of t a, one item of [(String, Int)] in this case
11:30:36 <roelof> of course, it already took a value out of the lists, stupid mistake 
11:30:42 <mauke> broma0: mkDecl = [d| $(varP (mkName s)) = $(stringE s) |] works
11:31:08 * hackagebot jammittools 0.5.0.3 - Export sheet music and audio from Windows/Mac app Jammit  https://hackage.haskell.org/package/jammittools-0.5.0.3 (mtolly)
11:31:54 <roelof> MarcelineVQ:  when I use this : fingerTaps list = foldr (\(_,y) res -> res + y) 0 list with fingerTaps (convertSentence "roelof" buttons)  I see as output 17 
11:32:16 <gigglypuff> horrorcheck: I've mostly seen good reception, but there is a significant amount of bad I've seen. Care to give a quick explanation? I'm reading it right now, but if it's boring, it'll probably leave me with a bitter taste as well
11:32:38 <broma0> mauke: it does indeed.. but not when i add 
11:32:57 <broma0> mauke: [d| $(varP (mkName s)) :: IO String |] above it
11:33:12 <broma0> or any kind of signature
11:33:16 * mauke checks
11:33:30 <MarcelineVQ> roelof: good job
11:34:36 <horrorcheck> gigglypuff: it's been a while, so lemme go look at the pdf and see if jogs some memories
11:34:55 <Rotaerk> I think the hackage page for Data.Dependent.Sum is wrong
11:35:11 <Rotaerk> the example, at least, seems inaccurate
11:35:39 <Rotaerk> https://hackage.haskell.org/package/dependent-sum-0.3.2.1/docs/Data-Dependent-Sum.html
11:35:47 <MarcelineVQ> roelof: as far as I can see you're done with fingerTaps, good job making a foldr for it. here's another way to write that just so you're aware of it, fingerTaps = sum . map snd 
11:35:59 <roelof> now the last challenge. Huttons razor, How can I recursive solve this :  eval (Add (Lit 1) (Lit 9001))
11:36:04 <Rotaerk> DSum has two type-params, but the example is treating it as having one
11:36:40 <roelof> MarcelineVQ:  oke, so you made a map of all the second values and the sum them 
11:37:19 <MarcelineVQ> That's what I did but your method is just as good
11:38:50 <tippeneinn> where would be a good place to tell lambdaconf ppl that the website has a merge conflict diff in the html
11:38:56 <asdfds> gigglypuff: I suppose to say, one of the bigger insights -- well, in programming we like to look at the imperative, the effective, nature of code. We like to talk about instructions, we like to say "I like x language because I can see what the C code would be like." We like to think about code in terms of computers.
11:39:39 <cocreature> roelof: I think at some point (probably < 0.3) it had only one so the docs simply haven‚Äôt been updated. you could open an issue
11:39:47 <cocreature> eh ^ Rotaerk 
11:39:56 <asdfds> gigglypuff: SICP, what it does, is asks us to step away from the computers, forget "the code does this," and think about what the code's really saying.
11:40:06 <puregreen> broma0: yeah, you can't generate a name for a signature with [| |], you have to use sigD
11:40:24 <Rotaerk> cocreature: k; yea the old behavior of :=> indicated by the examples seems to match the *current* behavior of ==>
11:40:44 <puregreen> broma0: so you won't be able to use [| |] for all your code and you'd still have to assemble declarations from pieces
11:41:11 <puregreen> broma0: I wrote a TH tutorial that deals largely with that stuff, maybe it would help: https://artyom.me/lens-over-tea-6#template-haskell
11:41:31 <cocreature> Rotaerk: not really, it has the same type signature, but ==> uses the applicative instance to go from a to f a whereas the previous versions simply stored an a
11:41:40 <mauke> broma0: sigD (mkName s) (conT ''String), but I can't find a way to make it work with quasiq.. oh, what puregreen said
11:41:43 <asdfds> gigglypuff: For example, a lot of people like to point out that it really hammers home the notion of functions are data.
11:42:07 <Rotaerk> cocreature: true; is there a page explaining how to submit an issue for this kind of thing?
11:42:13 <Rotaerk> not sure what the appropriate method to do so is
11:42:20 <puregreen> broma0: and generally, you still want to use [| |] whenever you can, it makes code much nicer
11:42:30 <cocreature> Rotaerk: go to the hackage page, find the github link and open an issue
11:42:35 <horrorcheck> gigglypuff: okay, I remember now. my experience may not be too useful. I was studying with some friends and got caught up on all the math very early on, so I couldn't keep up. :/ 
11:42:35 <Rotaerk> k
11:42:50 <roelof> Can someone help me figure out what schould been in xxx and yyy here : http://lpaste.net/154125
11:42:52 <saurabhnanda> when pattern matching with a constructor, do I need to specify the same number of fields in the pattern? Or if I'm interested in the first two, I can pattern-match only those?
11:43:30 <puregreen> saurabhnanda: you have to specify the same number of fields or no fields (by using {} ‚Äì i.e. Just{} instead of Just _)
11:43:35 <puregreen> but you can't pattern-match only 2 first fields
11:43:37 <asdfds> gigglypuff: But I guess I should say, the book doesn't really teach functional programming. You'll get a taste, but the book's really teaching how to think about programming.
11:43:43 <mauke> saurabhnanda: if you don't use record syntax, you need to match all or none
11:43:59 <saurabhnanda> puregreen: mauke: hmm, that's bad...
11:44:22 <asdfds> gigglypuff: Here's the review of Google's director of research made for the book: http://www.amazon.com/review/R403HR4VL71K8
11:46:13 <Rotaerk> cocreature: heh; someone else beat me to it
11:46:22 * Rotaerk just signed up for github.
11:46:51 <cocreature> Rotaerk: looks like there is even a pr with a fix https://github.com/mokus0/dependent-sum/pull/8
11:47:12 <cocreature> but no responses
11:47:38 <saurabhnanda> wonder what this means. Whatever it is, it's making Persistent a pain to use! "We split our definition into two separate modules in this case. This is necessary due to the GHC stage restriction, which essentially means that, in many cases, Template Haskell generated code cannot be used in the same module it was created in. "
11:48:14 <roelof> How can I make this recursive so it 's also working with 3 , 4 or more numbers ?  http://lpaste.net/154126
11:49:27 <liste> roelof: eval (Add x y) = ???
11:50:14 <roelof> liste : that I solved already, Im now trying to make it recursive so I will work on more then 2 numbers 
11:51:01 <liste> roelof: you have only eval (Add (Lit x) (Lit y))
11:51:08 <liste> that only handles the literals
11:51:13 <liste> it's too specific
11:53:02 <roelof> liste:  so I cannot change it so I can calculate  this : Add (Add (Lit 1) (Lit 9001)) (Lit 1)
11:53:12 <liste> roelof: yes you can change it
11:53:34 <liste> you know, you can evaluate non-literal subexpressions (:
11:53:44 <liste> that is, eval (Add x y) = ???
11:53:55 <deepfire> is it possible to "open" a module in ghci -- to experiment with alternative definitions of its functions?
11:54:08 <liste> roelof: what'd be the types of x and y be in that pattern match?
11:54:49 <roelof> liste:  bioth Lit ? 
11:54:56 <roelof> liste:  both Lit ? 
11:54:57 <puregreen> deepfire: I've never ever heard of it being possible so I think the answer is ‚Äúno‚Äù but I'm not 100% sure
11:55:01 <mauke> roelof: Lit is not a type
11:55:02 <liste> roelof: Lit's not a type
11:55:16 <deepfire> puregreen: wouldn't it be awesome?
11:55:42 <roelof> oke, tomorrow back to the tree chapter in the Haskell book 
11:56:18 <deepfire> puregreen: I suspect that without having access to module source it's not possible, since the .hi file probably doesn't contain enough information per se
11:57:28 <deepfire> actually even with the source requirement it would be still awesome
11:58:02 <roelof> liste:  last try before I goto sleep : type is Expr 
11:58:08 <liste> roelof: yep
11:58:14 <liste> and how do you evaluate an Expr ?
11:58:57 <roelof> with the eval function that I try to write 
11:59:06 <liste> roelof: exactly
11:59:55 <roelof> liste:  but I cannot pattern match every case   ? 
12:00:32 <liste> roelof: you can pattern match (Lit e) and (Add x y)
12:01:03 <mauke> roelof: there are only two cases, Lit and Add
12:01:07 <mauke> you've already done Lit
12:01:10 <quchen> Why does runST have a rank-2 type? Wouldn't `runST :: ST Uninhabited a -> a` provide the same guarantees?
12:01:12 <deepfire> ..even if the changes wouldn't be propagated to downstream modules
12:01:17 <mauke> and you're half done with Add
12:01:36 <hpc> quchen: you can unify multiple Uninhabiteds
12:01:45 <quchen> hpc: How so?
12:02:07 <roelof> oke, I think I have to find a way to find the rest of the expr and make with that part the recursion , 
12:02:30 <mauke> roelof: what rest?
12:02:34 <quchen> I mean the point of the "s" is that you can't specialize the "s" parameter or runST won't typecheck.
12:03:00 <hpc> quchen: the point of the s is that it's different for every runST
12:03:00 <quchen> When using Uninhabited, you would equally require the "s" parameter to be left open so you can unify it with Uninhabited.
12:03:12 <hpc> like, you do
12:03:30 <mauke> quchen: no, you would only require it to be Uninhabited
12:03:36 <hpc> :t runST :: newSTRef
12:03:37 <lambdabot>     Couldn't match expected type ‚ÄònewSTRef1‚Äô
12:03:38 <lambdabot>                 with actual type ‚Äò(forall s. ST s a0) -> a0‚Äô
12:03:38 <lambdabot>       ‚ÄònewSTRef1‚Äô is a rigid type variable bound by
12:03:41 <hpc> er
12:03:48 <hpc> :t runST $ newSTRef ()
12:03:49 <lambdabot>     Couldn't match type ‚Äòa‚Äô with ‚ÄòSTRef s ()‚Äô
12:03:49 <lambdabot>       because type variable ‚Äòs‚Äô would escape its scope
12:03:49 <lambdabot>     This (rigid, skolem) type variable is bound by
12:03:51 <quchen> hpc: Oh, I see. Right. So even if we had "get :: ST s s", we couldn't use runST as we have it right now to leak state, but with my Uninhabited we could.
12:03:59 <hpc> yeah
12:04:00 <quchen> Thanks!
12:04:07 <quchen> Obvious now that you've mentioned it :-)
12:04:14 <hpc> well, i still had to think about it too
12:04:43 <roelof> liste:  suppose I have this :  Add (Add (Lit 1) (Lit 9001)) (Lit 1)
12:05:09 <roelof> the first run takes the Lit 1 and the Lit 9001  
12:05:29 <roelof> then the last Lit 1 is not applied yet. that is what I mean with the rest 
12:05:36 <liste> roelof: you're thinking bottom-up
12:05:41 <liste> try thinking top-down
12:05:43 <roelof> ??
12:06:01 <mauke> roelof: the first run takes Add (...) (...)
12:06:20 <roelof> I think you mean , make the tree on paper 
12:06:56 <horatiohb> There doesn't seem to be a way to determine if a thread (threadId) is running. Is there any particular reason for that?
12:07:08 <liste> roelof: There's a (Add x y) on the top. you can calculate x and y, and you can calculate their sum
12:07:23 <hpc> :t newSTRef
12:07:24 <lambdabot> a -> ST s (STRef s a)
12:07:35 <roelof> yep, that is what I mean to say 
12:08:04 <roelof> then the recursion have to go on with the rest of the tree 
12:08:19 <mauke> horatiohb: if there was a way, what would you do with it?
12:08:36 <liste> roelof: try concentrating on one level at a time
12:08:42 <roelof> oke 
12:09:22 <quchen> hpc: But ‚Ä¶ since we don't have `get :: ST s s`, how could we leak the Uninhabited?
12:09:39 <quchen> hpc: Question being, couldn't the API prevent the leaking, as opposed to the type system?
12:10:15 <hpc> well, it's happening at compile time
12:10:19 <saurabhn_> does anyone know if derivePersistField (from Persistent DB Library) derives only enum/String fields? Can it not derive an Int64/Integer field?
12:10:21 <hpc> so the type system /is/ the api
12:10:41 <quchen> hpc: Well, the cost is a GHC extension
12:11:00 <quchen> hpc: What I mean is "why can't we do something equally safe without the extension"
12:11:05 <roelof> liste:  Thanks, I call it a day., Too tired to think 
12:11:34 <liste> roelof: maybe you know the answer in the morning (: good night!
12:11:45 <quchen> hpc: I get that using the type system to ensure something is a good thing, but from a user perspective (as opposed to an implementor's) it shouldn't matter what way the safety is guaranteed
12:11:48 <roelof> you also a good night/day 
12:22:34 <jakeehrlich> What is the diffrence between ForgienPtr and Ptr? Also what is the best way to represent a void*?
12:22:46 <jakeehrlich> For the purposes of FFI that is
12:23:49 <mauke> Ptr a or Ptr () or something
12:23:54 <geekosaur> ForeignPtr is a Ptr plus a function to be called when the Ptr goes out of scope, so you can release any FFI-allocated resources related to it
12:25:32 <geekosaur> I should say when the Ptr is garbage-collected because no references to it exist in Haskell any more
12:29:04 <jakeehrlich> Thanks! perfect!
12:36:10 * hackagebot alloy 1.2.2 - Generic programming library  https://hackage.haskell.org/package/alloy-1.2.2 (NeilBrown)
12:59:08 <saurabhnanda> Does anyone know how to export ALL the data-types created by the mkPersist Persistent TemplateHaskell?
13:05:48 <Algebr> I can't get hakyll to compile with cabal on ubuntu using nix, JuicyPixels, (Great name by the way), craps out on missing zlib. I have also tried nix-shell -p zlib and no luck. google shows to be common and long running problem
13:06:28 <koshmar> hey, I am learning/playing around Data.Vector. I wanted to oveload (+) etc. Here I get the error http://paste.ofcode.org/h35gE4psiLGcwGxuSxdGEY . I know it is wrong to do it this way, but still.
13:06:56 <saurabhnanda> :t liftIO
13:06:57 <lambdabot> MonadIO m => IO a -> m a
13:06:58 <koshmar> Num works alright but not Fractional...
13:07:34 <Algebr> Okay, now trying stack
13:11:51 <geekosaur> koshmar, look closely, you are missing something on line 13 (compare to line 4)
13:13:12 <geekosaur> the errors are even telling you this (hint: Vector is a type, not a class)
13:13:16 <purelazy> koshmar: any reason why Vector needs to be qualified as V?
13:13:50 <geekosaur> purelazy, because things like `map` conflict with Prelude
13:14:42 <koshmar> yay
13:14:43 <geekosaur> this is also why things like Data.Map are imported qualified
13:14:44 <koshmar> thanks
13:15:51 <koshmar> more smart way to do it is hmatrix?
13:16:30 <geekosaur> probabaly, yes. in particular I don't think  many people would expect that definition for (*) --- although note that you can't really write the one they *would* expect because of the type of (*)
13:16:50 <purelazy> geekosaur: I see. But one can always import Prelude hiding (,ap)
13:16:52 <geekosaur> hmatrix provides its own multiplication operators
13:16:55 <purelazy> (map)
13:17:50 <geekosaur> purelazy, yes there are other ways around it, and in fact in ghc 7.10 you should be able to use the Prelude one because of FTP. but this is the way that has become customary in the Haskell community
13:18:07 <purelazy> Then all the "V."s can disappear
13:18:22 <geekosaur> as such, if you want other people to understand your code, it's best to stick to the community convention
13:18:47 <geekosaur> (and if n this case, if you also want it to be valid on pre-7.10 ghc)
13:18:57 <geekosaur> s/if n/in/
13:19:06 <purelazy> FTP?
13:19:28 <geekosaur> Foldable/Traversable Proposal, where a bunch of Prelude stuff got generalized from lists
13:19:50 <geekosaur> (or "Foldable/Traversable Prelude" if you  prefer since it's no longer a proposal >.> )
13:20:07 <purelazy> I'm in the dark here.
13:20:20 <geekosaur> :t map
13:20:20 <purelazy> Thanks for the heads up
13:20:21 <lambdabot> (a -> b) -> [a] -> [b]
13:20:30 <geekosaur> oh, lb's using the old one
13:20:52 <geekosaur> the Foldable typeclass generlizes folds; the Traversable typeclass generalizes maps
13:21:44 <geekosaur> in ghc 7.10 and later, the Prelude no longer exports things with list-specific types (like for map above) if a more general one can be made via Foldable or Traversable
13:22:34 <geekosaur> oh, hm, maybe map itself wasn't geenralized. so you'd still need V.map, or import Prelude's qualified so you can also use the non-Vector map
13:23:29 <geekosaur> ah, Traversable has mapM, not map
13:23:32 <Bruuuuuno> I'm using reactive banana on a concurrent environment and I need to "merge" the behaviors from two different threads, any tips?
13:24:13 <purelazy> Bruuuuuno: I haven't a clue
13:24:44 <purelazy> I'm still learning FRP
13:26:12 <cstrahan> in `lens`, is there any way to have a traversal like `template`, but passes through children of the target type recursively?
13:27:02 <cstrahan> i'd like to grab all variable bindings recursively in an AST.
13:29:27 <Jinxit> sounds like a job for traverse
13:33:22 <johnw> cstrahan: the uniplate stuff in lens will do that
13:34:15 <johnw> > ("hello",("world","?"),["!!!"])^..biplate :: [String]
13:34:16 <lambdabot>  ["hello","world","?","!!!"]
13:36:12 * hackagebot secp256k1 0.4.5 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-0.4.5 (xenog)
13:39:26 <cstrahan> johnw: with your example, that works. but if the target type is recursive, it only traverses immediate children of that type, and not all transient descendents
13:39:43 <cstrahan> johnw: I'm actually using lens and your hnix project :)
13:39:47 <johnw> ah
13:39:51 <cstrahan> I'm trying to do something like this:
13:39:57 <cstrahan> _var :: forall s a. (Data s) => Text -> Traversal' s (Binding NExpr)
13:39:57 <cstrahan> _var name = biplate.filtered ((== name) . varName)
13:39:58 <johnw> i thought that syb could do this, and so lens should be able to 
13:41:02 <cstrahan> that, unfortunately, doesn't find bindings on the right hand side of bindings higher up in the tree.
13:41:13 * osfameron has had a look at a few xml/html lens modules, and is surprised there aren't functions to extract an XPath expression into a lens
13:41:35 <osfameron> (I may be missing the point entirely, but it seems like the kind of thing that would be useful)
13:42:12 <cstrahan> there are these two blurbs in Control.Lens.Plated:
13:42:15 <johnw> osfameron: i'd think that would be fairly useful too
13:42:30 <cstrahan> "This same ability to explicitly pass the Traversal in question is why there is no analogue to uniplate's Biplate.
13:42:30 <cstrahan> Moreover, since we can allow custom traversals, we implement reasonable defaults for polymorphic data types, that only traverse into themselves, and not their polymorphic arguments."
13:42:38 <johnw> build an XPath parser, evaluating the structure to a lens
13:42:41 <johnw> (or traversal)
13:42:52 <johnw> cstrahan: ah
13:43:09 <cstrahan> I think I can probably compose some stuff together, but my brain is having a hard time of figuring out how to do so.
13:43:46 <cstrahan> Stupid brain. Looking forward to a world in which transplants are a possibility.
13:44:13 <osfameron> johnw: ah, good.  maybe I'll have a look at making something like that if I have tuits
13:48:32 <johnw> cstrahan: thanks for the work with hnix :)
13:49:43 <cstrahan> johnw: oh, I don't know if I have anything to contribute back (unless the Data & Generic instances in `data-fix` count) - thank you for making hnix :)
13:51:33 <ddellacosta> speaking of lens ...I'm doing something much more basic, working my way through tel's tutorial here: https://www.schoolofhaskell.com/user/tel/lenses-from-scratch.  But I'm getting an error when playing around with some of this stuff in the repl (see line 14): https://gist.github.com/ddellacosta/e289ed20e9856ce95144
13:52:12 <ddellacosta> can anyone tell me what I'm confused about there?
13:53:02 <johnw> what is >-?
13:53:15 <ddellacosta> johnw, he's using that for Lens composition in the tutorial
13:53:22 <johnw> instead of "."?
13:53:23 <ddellacosta> (>-) :: Lens a b -> Lens b c -> Lens a c
13:53:41 <johnw> oh, instead of flip (.)
13:53:51 <byorgey> ddellacosta: well,  _1 >- _1  is a lens into the x in  ((x,y), z)
13:54:04 <byorgey> but it can't change the type
13:54:26 <byorgey> so if you have ((1,2),5),  the lens  _1 >- _1  accesses the value 1
13:54:33 <byorgey> so you could only set it to a different number
13:54:36 <byorgey> not to a tuple
13:55:15 <ddellacosta> byorgey: I see, that helps a lot--actually I was misunderstanding the types entirely, not attempting to swap a number for a tuple.  Thank you very much!
13:55:48 <ddellacosta> right, so I can do `set (_1 >- _1) 3 ((1, 2), 5)`
13:55:55 <byorgey> yes, that should work
13:56:27 <ddellacosta> awesome, thanks again byorgey...the lightbulb just went on for me, about the type sig and also what Lenses are about (per this example at least)
13:56:37 <byorgey> ddellacosta: great, glad I could help!
13:56:40 <byorgey> incidentally, in the actual 'lens' library lenses *can* change type
13:56:59 <byorgey> > ((1,2),5) & _1 . _1 .~ (6,7)
13:57:01 <lambdabot>  (((6,7),2),5)
13:57:13 <ddellacosta> byorgey: yes, I think tel hints at this in the tutorial when he talks about how the toy implementation is limited compared to his original 'set' function, that's a good clue
13:57:34 <byorgey> > set (_1 . _1) (6,7) ((1,2),5)  -- without fancy operators
13:57:36 <lambdabot>  (((6,7),2),5)
13:57:43 <ddellacosta> aha, right
14:00:47 <cstrahan> Aha, I figured out my problem from just a moment ago
14:00:54 <cstrahan> behold:
14:00:57 <cstrahan> Œª> let l = Fix (C 1 (Fix (C 2 (Fix (C (3::Int) (Fix N))))))
14:01:09 <cstrahan> Œª> l^..biplate :: [L Int (Fix (L Int))]
14:01:09 <cstrahan> [C 1 (C 2 (C 3 (N)))]
14:01:18 <cstrahan> Œª> l^..cosmosOn biplate :: [L Int (Fix (L Int))]
14:01:18 <cstrahan> [C 1 (C 2 (C 3 (N))),C 2 (C 3 (N)),C 3 (N),N]
14:01:42 <saurabhn_> :t void
14:01:43 <lambdabot> Functor f => f a -> f ()
14:02:03 <cstrahan> That does mean that I need to make the type an instance of Plated, though.
14:02:04 <saurabhn_> :t fork
14:02:05 <lambdabot>     Not in scope: ‚Äòfork‚Äô
14:02:05 <lambdabot>     Perhaps you meant one of these:
14:02:05 <lambdabot>       ‚ÄòforM‚Äô (imported from Data.Traversable),
14:02:34 <saurabhn_> :t Control.Concurrent.fork
14:02:35 <lambdabot> Not in scope: ‚ÄòControl.Concurrent.fork‚Äô
14:02:39 <saurabhn_> :t Control.Concurrent.forkIO
14:02:40 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
14:02:41 <johnw> huh, cosmosOn
14:03:09 <saurabhn_> :t Control.Concurrent.forever
14:03:11 <lambdabot>     Not in scope: ‚ÄòControl.Concurrent.forever‚Äô
14:03:11 <lambdabot>     Perhaps you meant ‚ÄòControl.Monad.Cont.forever‚Äô (imported from Control.Monad.Cont)
14:03:23 <cstrahan> Yeah. It would be nice to have something like `cosmosOn biplate`, but without the need for the Plated instance.
14:03:36 <saurabhn_> :t Control.Monad.forever
14:03:37 <lambdabot> Monad m => m a -> m b
14:03:56 <cstrahan> The docs actually recommend using the *Of functions in Control.Lense.Plated, rather than polluting Plated with orphan instances.
14:06:13 * hackagebot eventstore 0.11.0.0 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.11.0.0 (YorickLaupa)
14:07:28 <cstrahan> Aha! Finally clicked. This works, too: l^..cosmosOnOf biplate uniplate
14:08:05 <cstrahan> cosmosOn is defined as: cosmosOn d = cosmosOnOf d plate
14:08:50 <cstrahan> and I realized that I could just pass my own traversal - in this case, biplate - which is actually the default implementation for plate in the Plate type-class :)
14:09:13 <cstrahan> et voila - no need for a Plated instance.
14:09:44 <cstrahan> though a bit noisy. probably worth giving it a name, at least within my own code base.
14:11:13 <cstrahan> Finally picked up `lens` and `uniplate` the past week or two. The concision is almost scary.
14:11:25 <johnw> heh
14:12:08 <cstrahan> too much time NixOSing, and not enough Haskelling :)
14:18:58 <Algebr> is this a common error:     Not in scope: ‚Äòmconcat‚Äô
14:19:29 <mauke> @hoogle mconcat
14:19:31 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
14:19:36 <mauke> import Data.Monoid
14:20:04 <Algebr> is that part of the standard library
14:21:36 <Algebr> ah yes, looks like it is
14:29:12 <cstrahan> ah, damn - cosmosOnOf only gives me a Fold, and not a Traversal...
14:33:51 <cstrahan> hmmm... if I define my own copies of cosmos* and discard the Contravariant constraints, it compiles and works. I'm curious if dropping those constraints violates some law(s)...
14:34:50 <cstrahan> edwardk: could I ask you about the above? ^^^
14:45:12 <Rotaerk> Cale: how did you figure out how to do anything non-trivial in reflex-dom?
14:45:41 <Rotaerk> Cale: without documentation, I'm kind of lost when it comes to doing anything less trivial than the calculator example they have on the get started page
14:45:56 <Cale> Yeah, we definitely need to write lots more documentation.
14:46:19 <Cale> Did you look through the quick references?
14:46:52 <Rotaerk> my issue is more DOM-specific
14:47:18 <Rotaerk> i.e. trying to figure out how to handle key-presses at the document level, not key presses for a particular control
14:47:32 <Cale> ah, okay
14:48:04 <Rotaerk> I figured maybe getKeyEvent was relevant, but I don't understand how to use it
14:49:21 <Rotaerk> Cale: also doesn't help that the GHCJS documentation is barren
14:49:58 <Rotaerk> it's not clear what the purpose of GHCJS's EventM's first type argument is
14:50:06 <Cale> Rotaerk: I don't think there's already a hook for the events you want, but if we can figure out how it would be done in JS, we can probably do it.
14:50:55 <Cale> The first type argument is the type of thing that the event applies to
14:50:59 <Cale> on :: (IsEventTarget t, IsEvent e) => t -> EventName t e -> EventM t e () -> IO (IO ())
14:52:22 <Cale> This thing takes an event target, the event which we're adding a listener for, and the handler itself, and gives an IO action which adds the listener and returns an IO action which can be used to remove it again.
14:52:27 <Rotaerk> Cale: e.g. if it's the Keypress event, then it's the target of that keypress?
14:52:40 <Cale> yeah
14:54:14 <Rotaerk> so the problem is that there's no way of getting the body itself as a target
14:54:15 <Rotaerk> I guess
14:54:18 <mauke> ooh, IO (IO ())
14:54:24 <mauke> I hereby name this the "destructor pattern"
14:55:28 <monochrom> and is "HIHO (HIHO ())" the seven-dwarves pattern? :)
14:55:36 <shachaf> @hackage spawn
14:55:36 <lambdabot> http://hackage.haskell.org/package/spawn
14:55:47 <shachaf> Uses IO (IO a) for another purpose.
14:55:59 <jakeehrlich> is there a way to perform atomic writes using ForignPtr somehow?
14:56:49 <Cale> Rotaerk: Yeah, there is a way though, it's just not completely straightforward because reflex-dom tends to run your widget entirely inside the body... let me give it a shot
14:58:22 <Rotaerk> Cale: I'm not particularly experienced with web dev; I see a SO post about handling keypresses via jQuery, but not sure what that's doing under the hood
14:59:28 <Rotaerk> Cale: ah:  http://stackoverflow.com/questions/12153357/how-to-register-document-onkeypress-event
15:00:09 <Cale> Rotaerk: Right, so we just need to add a listener to the document itself.
15:05:06 <Eduard_Munteanu> By the way... any chance we may be seeing a ghcjs platform thingy? That is, builds of GHCJS and libs.
15:07:47 <Cale> Rotaerk: got it
15:07:56 <Rotaerk> nice
15:08:50 <lpaste> Cale pasted ‚ÄúCapture keypresses‚Äù at http://lpaste.net/154135
15:08:51 <lpaste> Cale pasted ‚ÄúCapture keypresses‚Äù at http://lpaste.net/154136
15:09:01 <Cale> heh, lpaste was being sluggish
15:09:48 <Rotaerk> heh; let's see...
15:09:59 <Rotaerk> what's askDocument from
15:10:19 <Cale> That's from Reflex.Dom.Class
15:12:43 <Cale> The thing about GHCJS.DOM is that while it usually doesn't turn out to be too hard to do the thing you want, there's just so much *stuff* that finding the thing you want can be tricky.
15:13:05 <Rotaerk> yea that's fairly simple, looking at it
15:13:16 <Rotaerk> I just didn't know about askDocument; didn't expect that to be in Classes
15:13:33 <Rotaerk> and wrapDomEvent ... well seeing a usage example helps
15:13:39 <Rotaerk> thanks
15:16:36 <Cale> Yeah, wrapDomEvent's type is scary until you realise that second thing is basically the type of 'on' pre-applied to its second argument.
15:17:05 <Rotaerk> Cale: I don't understand uiKeyCode
15:17:34 <Rotaerk> Cale: it's apparently an EventM
15:18:22 <Cale> EventM is basically a glorified reader monad, where the environment you have access to is a bit different based on which sort of event it is
15:18:46 <Cale> it gives you access to various information about the event which occurred
15:19:35 <Cale> uiKeyCode (which is defined in the GHCJS.DOM.EventM module) is one of the things that it gives you, it just extracts the keycode of the event
15:19:48 <Rotaerk> hmm, so uiKeyCode indicates which environment (and thus which information to obtain) about the event
15:20:04 <Cale> Well, it actually obtains a piece of information
15:20:17 <Cale> (the keycode of the key which was pressed)
15:20:58 <Rotaerk> hmm k, cool; time to tinker to solidify my understanding
15:26:22 * hackagebot servant-haxl-client 0.1.0.0 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-haxl-client-0.1.0.0 (willfancher)
16:26:25 * hackagebot data-clist 0.1.0.0 - Simple functional ring type.  https://hackage.haskell.org/package/data-clist-0.1.0.0 (jeremyjh)
16:33:20 <Zemyla> What's the name of the library where SQL statements get turned into a type-safe monad DSL?
16:34:43 <Guest62564> esqueleto?
16:34:44 <johnw> Zemyla: esqueleto?
16:36:00 <gigglypuff> I'm a bit confused: What's this talk of the functional paradigm potentially growing in popularity due to parallelism and multi-core CPUs? Can someone explain?
16:39:07 <Cale> gigglypuff: Well, it's not so much that functional programming makes concurrency and parallelism easy so much as it's that imperative programming is like shooting yourself in the foot from the start.
16:39:40 <johnw> although, STM is infinitely easier to use correctly than anything based on pthreads
16:40:10 <Cale> gigglypuff: If your standard way of accomplishing anything is through mutation, then everything is thread-unsafe, and it requires great feats of heroism to recover from this.
16:40:11 <johnw> (or rather, the direct use of pthreads)
16:40:26 <maerwald> gigglypuff: "shared global state is the root of all evil"... you can fix the state part, or the shared part
16:40:41 <maerwald> functional programming is not the only way
16:41:34 <maerwald> but the benefits there often come from immutability and statelessness
16:42:56 <Cale> Also, in Haskell we tend to have ways to control very precisely which stateful effects are allowed
16:43:36 <Cale> STM uses that to great benefit -- memory transactions need to be possible to roll back, so you need some sort of guarantee that other effects can't happen inside them
16:43:48 <maerwald> if you think imperative programming needs a fix... look at rust, which has a borrow-checker and fixes the "shared" part of the problem
16:43:54 <maerwald> so I think stuff is improving on both sides
16:45:59 <timbod7> I want to turn on -fwarn-incomplete-patterns, but there are a few places in my code where the match is superficially incomplete, but actually complete given other invariants.  Is there an established convention for implementing the missing cases? ie, something like ... error "this pattern match failure shouldn't happen!" ... ??
16:46:12 <Cale> It's true that minimising the extent to which you share state is useful, but ultimately you *do* need to communicate state in order to accomplish anything. "No shared state" is always a bit of a lie -- if you're passing messages, that's sharing state, it's just a little more explicit. You do end up with many of the same problems, just on a larger scale.
16:47:56 <Cale> (but that's significantly better than nothing, because at least you don't have to deal with those problems *everywhere*)
16:49:30 <Cale> timbod7: Something like that, or just leave the warnings.
16:49:39 <gigglypuff> So functional languages work quite well with multi-core processors?
16:49:51 <Cale> gigglypuff: Haskell in particular does.
16:49:56 <maerwald> I don't know if Scala works well there
16:50:37 <timbod7> Cale: thanks. Don't like the idea of leaving the warnings - then you have to mentally filter them whenever you compile.
16:50:47 <maerwald> and it's probably generally difficult if you have open IO, I guess
16:50:55 <Cale> gigglypuff: In general, the fact that expression evaluation is referentially transparent is *extremely* useful as a starting point.
16:51:19 <Lokathor> so sometimes I've heard that -O is enough for haskell programs, and that -O2 can even perform optimizations that make a program wrong; and other times I hear "just use -O2 all the time it'd fine if you don't mind the compile times"
16:51:24 <Lokathor> anyone care to take a side?
16:51:48 <Cale> Lokathor: -O2 is fine, and if it makes your program go wrong, file a bug against GHC
16:51:50 <MarcelineVQ> my side is, just profile
16:52:09 <Cale> I don't know of any current problems with -O2, but I might just not be aware of something.
16:52:21 <Lokathor> hmm
16:52:24 <Lokathor> okay
16:53:18 <Lokathor> MarcelineVQ, stop being so pragmatic and reasonable
16:53:28 <Lokathor> i'm looking for some wild and unspported accusations here
16:53:33 <Cale> Lokathor: If one was always the right call to make, then the option probably wouldn't exist
16:53:49 <Cale> Lokathor: But optimisations are not supposed to change the result of your program
16:53:54 <maerwald> the reason a lot of haskell programs are not thread safe are simpler things like relying on $PWD... which the language doesn't really solve :P
16:53:59 <Cale> Only the amount of time and space required
16:55:06 <MarcelineVQ> Lokathor: you should make a lib that generates every possible profiling flag combo builds them all, and runs your programs test-suit (which has bene set up to be assisted by methods of your lib) against them to find the best option each meajor release
16:55:17 <Cale> lol
16:55:25 <Cale> That's probably a little overboard
16:55:33 <MarcelineVQ> I saw a genetic programming post about that actually iirc
16:55:52 <MarcelineVQ> But each case is so different I'm not sure why fitness should be part of the job
16:57:01 <Lokathor> that's less a lib and more a shell script i think
16:57:19 <Lokathor> you just have your .cabal file carry no flags, and then pass in extra flags at the command line, and the shell just runs through them all
16:57:53 <MarcelineVQ> depends how thorough your tests need to be, whether there's profiling invovled that'll change measurements, things that like, I dunno man, I ain't doin it
16:58:04 * Lokathor doesn't have a single test at all with his current library because he's a no good dirty rebel
16:59:26 <MarcelineVQ> is your lib ncurses?
16:59:45 <Zemyla> How do you handle a type which should be a Fractional, because recip and (/) exist, but fromRational doesn't exist in any meaningful form?
17:01:43 <gigglypuff> I know SICP *uses* Scheme, but's it's mostly related to general programming--and touches on functional programming--so, would it be appropriate if I asked questions related to the text here? You all seem like a nicer-than-average lot; more tolerable of noobs like myself.
17:02:01 <MarcelineVQ> it's better to ask forgiveness
17:02:17 <Lokathor> gigglypuff, if you can accept that we'll answer from a very Haskell perspective on things, compared to say a scheme or python channel :P
17:02:35 <Lokathor> MarcelineVQ, yes, that lib
17:03:26 <MarcelineVQ> Lokathor: I ask because afaik curses has issues with threading you might want to look into if you haven't
17:03:58 <Lokathor> oh it probably does :P
17:04:16 <Lokathor> "only draw with one thread" is the basic advice for all UI though
17:04:17 <Lokathor> so
17:05:51 <nocturne777> I am developing a web app with Haskell. I am trying to make each module as self-sufficent as possible. That's why I am not putting all of my models in Types.hs and such. I might do that if the dependencies of data types get complex. Is this the right way to go ?
17:07:22 <Lokathor> nocturne777, if a module doesn't need to expose a data type, you might as well keep it entirely within the moduhle, sure
17:07:38 <Lokathor> just be careful about circular dependencies though
17:16:36 <nocturne777> Lokathor: Since it's a webapp and I need to validate input a lot, I am also relying on GADTs a lot. For instance, data Bio :: ValidationState -> * where 
17:16:36 <nocturne777>     BioV :: Text -> Bio 'Validated
17:16:36 <nocturne777>     BioU :: Text -> Bio 'Unvalidated
17:16:37 * hackagebot distributed-process-monad-control 0.5.1.2 - Orphan instances for MonadBase and MonadBaseControl.  https://hackage.haskell.org/package/distributed-process-monad-control-0.5.1.2 (jeremyjh)
17:16:53 <nocturne777> do you think this is a good approach ?
17:18:47 <Lokathor> I do not really know
17:19:28 <Lokathor> I mean I've parsed incoming Text before into an internal data type, but it was just like an (Either String ParseResult) sort of deal
17:27:17 <HallaSurvivor> does anybody know of some simple, real world projects I can read to help me learn haskell? Xmonad is a bit too complex, but anything up to that would be fine :)
17:42:32 <sm> HallaSurvivor: how about shelltestrunner
17:45:32 <geekosaur> most of the projects I know of are more complex than xmonad
17:45:39 <HallaSurvivor> I'll look into it :) thanks!
17:45:54 <HallaSurvivor> yeah, I'm still getting started
17:46:41 <geekosaur> otoh you could drop in to #xmonad and usually there's someone around to help
17:46:59 <HallaSurvivor> oooh, that's a good idea
17:47:05 <geekosaur> also the book _Real World Haskell_ can be helpful since xmonad is one of its examples
17:47:14 <geekosaur> (readable online even)
17:47:20 <geekosaur> @where realworldhaskell
17:47:21 <lambdabot> http://www.realworldhaskell.org/
17:47:32 <geekosaur> hm, thought that linked directly to the book :/
17:49:17 <HallaSurvivor> don't worry about it. 
17:49:24 <HallaSurvivor> now I know it's online, I can find it :P
17:49:27 <HallaSurvivor> google is magic
17:49:54 <HallaSurvivor> yup, found it
18:02:05 <Lokathor> HallaSurvivor, https://github.com/Lokathor/fbmessageparse here try this
18:02:24 <Lokathor> I wrote it all in an afternoon, like 60 lines, should be small enough to investigate, but it does a thing
18:06:49 * hackagebot distributed-process-lifted 0.2.0.1 - monad-control style typeclass and transformer instances for Process monad.  https://hackage.haskell.org/package/distributed-process-lifted-0.2.0.1 (jeremyjh)
18:06:56 <HallaSurvivor> Lokathor: Thanks! I'm reading it now
18:08:47 <HallaSurvivor> :t withFile
18:08:49 <lambdabot>     Not in scope: ‚ÄòwithFile‚Äô
18:08:49 <lambdabot>     Perhaps you meant one of these:
18:08:49 <lambdabot>       ‚ÄòwriteFile‚Äô (imported from Prelude),
18:09:03 <HallaSurvivor> :t System.IO.withFile
18:09:04 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
18:15:21 <hefesto> Hi :)    Is there such a function like isNum?
18:15:37 <Lokathor> hefesto, what.. do you think isNum would do?
18:15:51 <hefesto> isNum :: Text -> Boolean
18:16:00 <maerwald> https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isNumber
18:16:06 <splanch> Data.Char
18:16:15 <maerwald> otherwise, use a proper parser
18:17:17 <hefesto> sigh... so parser it is :(
18:17:21 <hefesto> thanks!
18:17:57 <Lokathor> you could also use https://hackage.haskell.org/package/safe-0.3.9/docs/Safe.html#v:readMay
18:18:05 <Lokathor> and see if you get something out
18:18:34 <dmj> Text.Read.readMaybe :: Read a => String -> Maybe a
18:18:44 <maerwald> > readMay "162" :: Maybe Int
18:18:45 <lambdabot>  Not in scope: ‚ÄòreadMay‚Äô
18:21:28 <hefesto> maerwald: thanks!!!!
18:21:30 <hefesto> :)
18:21:49 * hackagebot distributed-process-zookeeper 0.2.1.0 - A Zookeeper back-end for Cloud Haskell.  https://hackage.haskell.org/package/distributed-process-zookeeper-0.2.1.0 (jeremyjh)
18:22:32 <maerwald> but it's not as strict... it accepts whitespaces and maybe even other crap, not sure
18:23:04 <maerwald> as in: readMay "  162     " :: Maybe Int -- works
18:28:58 <Lokathor> (\x -> (show <$> (readMay x :: Maybe Int)) == Just x)
18:31:50 * hackagebot higher-leveldb 0.3.0.1 - A rich monadic API for working with leveldb databases.  https://hackage.haskell.org/package/higher-leveldb-0.3.0.1 (jeremyjh)
18:38:53 <Lokathor> is there a way to make GHCI print '√Ü' and other extended characters as their character form rather than as things like '\198'?
18:40:15 <Lokathor> alright, let me rephase I guess: why does print mangle it but putStrLn does? I take it string's Show instance is at fault here?
18:42:40 <nitrix> Lokathor: I rekon this has been raised on the GHC bug tracker.
18:42:47 <Cale> Lokathor: Show tends to try to make representations that are easy to use as code
18:43:02 <Lokathor> fair enough
18:43:25 <nitrix> Lokathor: You might be able to find the thread with the motivation and such.
18:43:28 <Lokathor> i'll have to ~manually use putStrLn~, like some kind of ancient cave-skeller instead of a modern haskeller
18:43:45 <Cale> Rather than what?
18:43:52 <Cale> print?
18:43:58 <Cale> print is just putStrLn . show
18:44:12 <Lokathor> well rather than just putting in the bare expression
18:47:07 <geekosaur> how about don;t use print or show unless you actually intend that?>
18:47:22 <geekosaur> Strings are alreay Strings, types are static compile time so you know what is a String and what isn';t
18:47:27 <Lokathor> but that's just what ghci does?
18:47:36 <Lokathor> i'm not talking about a compiled binary
18:49:04 <geekosaur> then why do you care?
18:49:20 <Lokathor> because.... i'm using ghci?
18:49:54 <geekosaur> and of course it is required to mutate Show into something that does not do what Show is supposed to do
18:50:16 <geekosaur> Show is not intended to produce human readable output, it is supposed to produce something as close to source code as it can
18:50:38 <Lokathor> I was just asking if there was some option
18:50:48 <Lokathor> If there's no option already it's totally fine
18:51:18 <geekosaur> there's -finteractive-print and making your own typeclass (or maybe one of the prettyprinters happens to do what you want)
18:51:35 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/interactive-evaluation.html#ghci-interactive-print
18:53:54 <geekosaur> and deriving that typeclass for all of your types including those from any libraries you use, because they probably don't do so already and because trying to make an instance to make any Show-able value fit the typeclass will overlap every other instance
18:55:43 <Lokathor> sounds like a "possible but very complicatd"
18:56:57 <geekosaur> I didn't say "will probably overlap"
19:13:40 * geekosaur thinks about above, realizes he's kinda useless in his current state, backs away from keyboard
19:16:59 <ijmustafa> Anyone know of any tutorials on how to upload a package to Hackage including documentation and all that good stuff?
19:19:56 <dmj`> ijmustafa: cabal sdist and then cabal upload, for documentation I'd check the user guide, https://www.haskell.org/haddock/doc/html/
19:22:30 <Lokathor> dmj`, were you the one that talked about Latin-1 vs ASCII the other day when I asked about ByteString?
19:24:48 <dmj`> Lokathor: ReinH
19:25:05 <ijmustafa> dmj`: Great! thanks
19:25:30 <Lokathor> i remember ReinH saying some of it, but someone with a punctuation in their name also said some of it
19:25:37 <Lokathor> i thought it was either you or jle`
19:25:54 <Clint> all those punctuation names
19:27:42 <Lokathor> here's a fun question before I start, is making a deepseq instance spooky?
19:27:45 <Lokathor> or simple?
19:28:04 <Lokathor> I newtyped (Int,Int), but now i need a deeqseq instance to benchmark stuff with criterion
19:28:31 <hppavilion[2]> I'm trying to make a Haskell-like language that compiles to JS to run on the web. Are there any good features I should add that Haskell itself doesn't usually have?
19:29:00 <hppavilion[2]> Perhaps features that would be good for web, but are excluded because they're otherwise bad?
19:29:11 <Lokathor> hppavilion[2], you're already familiar with purescript, and elm, and fay, and ghcjs I take it?
19:29:24 <hppavilion[2]> Lokathor: Not particularly xD
19:29:31 <Lokathor> :3c
19:29:40 <hppavilion[2]> Lokathor: I've heard of elm and considered using it, but decided not to
19:29:47 <Lokathor> I've only dabbled in purescript, but it breaks up "IO" into different sub-effects, so that Console use and Random use can be tracked separatedly, for example
19:29:56 <hppavilion[2]> Lokathor: This is just a fun project for me in writing a transpiler
19:30:37 <hppavilion[2]> Lokathor: The most important thing I'm thinking of is probably support for an Elem type as a primitive
19:30:40 <hppavilion[2]> Also, JS objects
19:31:20 <hppavilion[2]> Or maybe Elem should be a typeclass...
19:31:25 <Lokathor> if it's just a toy, do whatever. If you want to really use it in the future, i'd seriously suggest that you look at Purescript to learn about their Extensible Effects and Row Polymorphism
19:31:30 <Lokathor> they're pretty interesting ideas
19:31:51 <hppavilion[2]> OK
19:38:25 <Lokathor> instance NFData Location where rnf l@(Location (x,y)) = x `seq` y `seq` l `seq` ()
19:38:35 <Lokathor> will this... do the right thing for DeepSeq?
19:39:10 <Lokathor> I don't want to stick it directly on the data type because then the main library would need to depend on deepseq, I just want to have the instance for benchmarking is all
19:39:30 <geekosaur> if x and y are guaranteed to seq fully, it looks right to me
19:39:54 <Lokathor> they're both Int
19:39:54 <geekosaur> (so for most Num instances it should be ok)
19:40:19 <jakeehrlich> how do I force stackage to not use the system‚Äôs ghc?
19:55:25 <barryburd> According to Meier‚Äôs EdX course, the following definition is correct:
19:55:32 <barryburd> concat [] = []
19:55:47 <barryburd> concat (xs : xss) = xs ++ concat xss
19:56:08 <John[Lisbeth]> what happened to haskell-blah?
19:56:16 <barryburd> But I‚Äôm getting errors ‚Äî ‚ÄúNon-exhaustive patterns with ghci‚Ä¶‚Äù
19:56:17 <Lokathor> barryburd, that looks.. correct?
19:56:25 <barryburd> Other type errors with ghc
19:57:23 <Lokathor> John[Lisbeth], do you have TLS on? https://pbot.rmdir.de/uOw-dPSkYSPTbz6l_tSSnA
19:57:32 <barryburd> Error:(29, 25) ghc: No instance for (Num Char) arising from the literal ‚Äò1‚Äô
19:57:33 <barryburd>     In the expression: 1
19:57:34 <barryburd>     In the expression: [1, 2]
19:57:34 <Lokathor> not sure if that change has gone into effect yet
19:57:35 <barryburd>     In the first argument of ‚Äòcon‚Äô, namely ‚Äò[[1, 2], [3, 4]]‚Äô
19:58:11 <Lokathor> :t (++)
19:58:13 <lambdabot> [a] -> [a] -> [a]
19:58:18 <shachaf> barryburd: You shouldn't paste more than about 2 lines into IRC. Use hpaste.org
19:58:20 <Lokathor> I'm so confused
19:58:30 <barryburd> ok
19:58:36 <shachaf> barryburd: In this case you should specify how you're using ghci. hpaste your full ghci session.
19:59:02 <barryburd> ok ‚Äî I‚Äôll log on a little later and use hpaste. Thanks.
19:59:20 <shachaf> Or your file, if you're using a file.
20:01:38 <geekosaur> actually in ghci you need to combine those somehow
20:01:58 <geekosaur> e.g.: let concat [] = []; concat (xs : xss) = xs ++ concat xss
20:02:44 <geekosaur> if you try to do them on separate lines and don't have multiline mode on then the second one will shadow the first and complain about non-exhaustive patterns
20:08:09 <doublenix> What book should I read to learn Haskell?
20:08:13 <Lokathor> i take it an "ns" is smaller than a "us", by 1,000ish probably
20:08:23 <doublenix> What's the best book in your opinion?
20:08:29 <Lokathor> doublenix, if you have the cash to spend on a book, http://www.haskellbook.com/
20:08:35 <Lokathor> if not, http://www.seas.upenn.edu/~cis194/spring13/lectures.html
20:11:40 <doublenix> Lokathor, but that book isn't finished :/
20:11:53 * hackagebot handwriting 0.1.0.0 - API Client for the handwriting.io API.  https://hackage.haskell.org/package/handwriting-0.1.0.0 (IsmailMustafa)
20:12:11 <Lokathor> it already covers enough material to keep you learning for weeks
20:12:44 <Lokathor> they already cover more than many other "complete" sources do
20:13:52 <geekosaur> it's not complete but already better than most books (and especially LYAH which is a good overview but won't teach you how to write Haskell code)
20:14:47 <doublenix> Lokathor, ah, LYAH. I am almost on the monad part.
20:15:07 <Profpatsch> cheers
20:15:08 <doublenix> Lokathor, do you think doing the exercises from http://www.seas.upenn.edu/~cis194/spring13/lectures.html
20:15:31 <doublenix> would it complement LYAH's lack of not teaching you how to code?
20:15:38 <Profpatsch> I‚Äôm wondering if there exists a viable solution to the Undo/Redo problem?
20:15:58 <Profpatsch> That is how to encode Actions that can be undone.
20:16:00 <geekosaur> doublenix, that was actually what we recommended before haskellbook.com was started
20:16:13 <Profpatsch> Are there libraries?
20:16:34 <shachaf> geekosaur: Who's "we"?
20:16:38 <doublenix> geekosaur, I'll purchase haskellbook when it is finished, thanks!
20:16:58 <geekosaur> a number of people on the channel who tend to field such questions
20:17:01 <Lokathor> doublenix, Haskellbook already covers twice as much as LYAH does
20:17:04 <geekosaur> !where learnhaskell
20:17:07 <geekosaur> er
20:17:10 <geekosaur> channel...
20:17:14 <geekosaur> @where learnhaskell
20:17:14 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:17:23 <geekosaur> (/me has been botting elsewhere...)
20:17:24 <barryburd> I hope an image file is okay. What‚Äôs wrong with my session at http://burd.org/concat.tiff ?
20:18:04 <shachaf> barryburd: Yes, it's what geekosaur said. Each of those lines is defining a new definition of concat.
20:18:11 <Lokathor> why would you make a tiff of all things :/
20:18:21 <geekosaur> [07 04:01] <geekosaur> actually in ghci you need to combine those somehow
20:18:21 <geekosaur> [07 04:01] <geekosaur> e.g.: let concat [] = []; concat (xs : xss) = xs ++ concat xss
20:18:25 <Lokathor> and yes, the problem is that those two lines are overwriting each other
20:18:29 <shachaf> So the second one doesn't interact with the first one.
20:18:51 <geekosaur> in a file you don't need to do it that way, but ghci is kinda dumb
20:19:40 <barryburd> Hmm‚Ä¶?! I haven‚Äôt had this trouble before with multiple lines in ghci.
20:19:53 <geekosaur> it's only when you have a definition like that
20:20:06 <barryburd> ‚ÄúLike that‚Äù in what way?
20:20:27 <geekosaur> if you define different things on multiple lines in ghci, it will work. but when you are providing multiple cases for the same name then they must be done together in ghci
20:20:57 <geekosaur> s/cases/patterns/
20:21:23 <barryburd> I could swear that I‚Äôve defined functions on multiple lines and haven‚Äôt had that trouble. But, I‚Äôll take your word for it. Anyway, I‚Äôm having similar issues when I type these lines into a file and use ghc.
20:21:33 <barryburd> Pardon me, but I have no experience with hpaste.
20:21:45 <geekosaur> well, if you pu tthem in a file and run ghci on the file, it will also work. just not at the prompt
20:22:49 <barryburd> Can I put a .hs file at a URL and put the URL here on the chat? Would that be okay?
20:23:32 <Lokathor> yes
20:23:52 <Lokathor> lpaste also works, you just put the code in the box and press "public" and give the URL
20:24:09 <Lokathor> basically any paste website, but some people get picky about their paste sites
20:24:16 <mitochon> hi ‚Ä¶ anyone know how to create an Arbitrary instance for ‚Äòdata S n a = S (n a) a‚Äô
20:24:43 <Lokathor> mitochon, well are all of the subcomponenets also arbitrary?
20:25:13 <Lokathor> wait, no, i read that wrong, i take it back
20:26:08 <mitochon> Lokathor, the ‚Äòa‚Äô can be arbitary, but n has to be a Traversable ‚Ä¶ let‚Äôs assume its a List
20:26:10 <gigglypuff> What are some books you guys read that jumpstarted your general programming development skills?
20:26:15 <gigglypuff> Just curious.
20:26:33 <sm> BASIC Computer Games
20:26:47 <Lokathor> wanting to do a thing, and then doing part of that thing, and then more each time until you get it
20:26:57 <beatdown> hahahHahahah hahaHahaha hahahHahahahaHahahahahah hahahHahahahha hahahaHahahahah haHa haha hahahHahahah hahaHahaha hahahHahahahaHahahahahah hahahHahahahha hahahaHahahahah haHa haha hahahHahahah hahaHahaha hahahHahahahaHahahahahah hahahHahahahha hahahaHahahahah haHa haha hahahHahahah hahaHahaha hahahHahahahaHahahahahah hahahHahahahha hahahaHahahahah haHa haha hahahHahahah hahaHahaha hahahHahahahaHahahahahah hahahHahahahha hahahaHahahahah haHa haha haha
20:27:02 <dmj`> @where ops
20:27:03 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
20:27:15 --- mode: ChanServ set +o Cale
20:27:20 <Cale> heh
20:27:21 <Lokathor> gigglypuff, http://chimera.labs.oreilly.com/books/1230000000929/index.html gets a strong vote from me
20:27:40 <barryburd> Please check http://burd.org/Main.hs
20:27:46 --- mode: Cale set -o Cale
20:28:09 <sm> Masters of Doom is a fun one
20:28:18 <shachaf> barryburd: putStrLn :: String -> IO prints a String.
20:28:18 <Lokathor> barryburd, try this: main = putStrLn $ show $ con [[1,2],[3,4]]
20:28:38 <Cale> Just use print in place of putStrLn
20:28:39 <shachaf> barryburd: [1,2,3,4] isn't a String, so you get an error. You can try print instead of putStrLn.
20:29:13 <barryburd> Lokathor - Thank you
20:29:23 <barryburd> shachaf - Thank you
20:30:21 <barryburd> I got it now. Bye
20:31:05 <gigglypuff> That O'Reilly book looks especially promising; noted
20:32:20 <dmj`> gigglypuff: this list helped me, http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read
20:33:14 <sm> bah, no BASIC Computer Games!
20:34:26 <gigglypuff> That is a pretty good book compilation
20:35:17 <sm> yes, that http://www.codersatwork.com is awesome
20:36:27 <Lokathor> frustratingly, removing a function that i'm not even calling from a module causes the benchmark time to go up
20:37:17 <sm> ‚ÄúWhen the limestone of imperative programming is worn away, the granite of functional programming will be observed.‚Äù ra ra!
20:37:46 <dmj`> gigglypuff: this too: http://www.catb.org/esr/faqs/hacker-howto.html, classic
20:38:25 <Lokathor> okay so why would my benchmark time go up by about 0.2 when I eliminate a function that I don't even call
20:39:10 <Cale> Lokathor: How are you benchmarking?
20:39:16 <Cale> Lokathor: Are you using criterion?
20:39:25 <Lokathor> specifically, this module https://github.com/Lokathor/ludolib/blob/master/src/Util/PPFOV.hs and the checkView function
20:39:27 <kadoban> 0.2 what?
20:39:27 <Lokathor> Cale, yes I am
20:39:59 <Lokathor> kadoban, 0.2 us, but it's a consistant difference across a few runs
20:40:35 <Cale> Is the function causing the types of other things to be inferred differently?
20:41:03 <Cale> Actually... that doesn't seem so likely.
20:41:24 <Lokathor> I.. don't think so? I never call it. The only difference between PPFOV and PPFOVNew is that I commented out checkView in PPFOVNew and changed no other code
20:41:45 <geekosaur> affects inlining somehow?
20:42:06 <Cale> hmm
20:42:07 <Lokathor> it might.. change the size of the module.. which changes what gets inlined?
20:42:35 <Cale> I wouldn't expect the inliner to be affected by a definition which isn't used... but hmm
20:42:46 <Cale> It's probably worth looking at the Core
20:42:55 <Cale> Build with --ddump-simpl
20:43:13 <Cale> er, sorry, that's one -
20:43:26 <Cale> -ddump-simpl
20:43:30 <geekosaur> but if it's exported then in theory another module could inline differently based on the possibility that it could be involved. but I don't know...
20:43:54 <Cale> -ddump-simpl-stats might also indicate something before you go digging through all that core code
20:45:34 <Lokathor> uh, where do the -dump-simple-stats go?
20:45:40 <Lokathor> there's no new file in the root directory
20:45:46 <Lokathor> and nothing got put into the standard out
20:46:10 <Lokathor> I changed my .cabal to be: ghc-options:        -O2 -ddump-simpl-stats
20:46:31 <Lokathor> and rebuilt with stack, if stack affected it somehow
20:47:08 <shachaf> It goes to stdout.
20:47:52 <Lokathor> didn't seem to, http://lpaste.net/154147
20:48:58 <shachaf> I've never used stack. When I compile a file with ghc, it goes to stdout (you can test the same way I did, with plain ghc).
20:49:49 <kadoban> Lokathor: I believe that kind of stuff goes somewhere inside where 'stack' builds things currently. I forget the exact location. Maybe check where it builds executables or something.
20:50:37 <Lokathor> ah ha, LudoBench.dump-simpl
20:50:39 <Lokathor> seems to be it
20:51:48 <Lokathor> alright so.. what am i looking for now?
20:55:48 <Lokathor> Result size of Tidy Core = {terms: 148, types: 139, coercions: 39}
20:55:52 <Lokathor> seems to say that in both versions
21:00:47 <Lokathor> https://www.diffchecker.com/6rjreb7a commented out on the left, uncommented on the right. The only difference seems to be identifier names :/
21:21:59 <Guest2> hi guys
21:22:08 <Guest2> so there were only 2 major haskell standards
21:22:10 <Guest2> 98 and 2010
21:22:17 <Guest2> when's next one
21:26:18 <tommd> Guest2: No, there were Haskell standards prior to 98.
21:26:39 <tommd> Guest2: Is there a particular ambiguity or feature you are hoping to see in a standard?
21:27:08 <tommd> Guest2: Much of the progress in language develoment takes the form of language extensions and doesn't necessarily find its way into a standard.
21:27:46 <tommd> Guest2: Perhaps the most heavily used extension was, or is, MPTC, which still aren't standard but are in a huge swath of the libraries.
21:29:12 <kadoban> tommd: They actually left about a minute after they asked :-/
21:29:55 <tommd> kadoban: Oh, one of those non-serious people.  Why do people even ask, a misunderstanding of how IRC works?
21:30:44 <jle`> i'm more impressed that your irc client tab-completed the name even though they weren't in the room
21:31:03 <tommd> jle`: irc-core from glguy
21:31:11 <kadoban> Yeah I think they misunderstand IRC or access via some interface that they're not sure works or something.
21:37:41 * hackagebot Gifcurry 0.1.1.0 - Create animated GIFs, overlaid with optional text, from video files.  https://hackage.haskell.org/package/Gifcurry-0.1.1.0 (lettier)
21:58:56 <cunntasl> anyone here own an exotic car?
21:59:37 <dmj`> cunntasl: how is this haskell related
21:59:58 <cunntasl> it isn't it's related to how much the dealer wants to fuck me
21:59:59 <shachaf> cars are offtopic in here. Try #lisp.
22:00:04 <shachaf> (Don't try #lisp.)
22:00:13 --- mode: ChanServ set +o shachaf
22:05:36 <julianleviston> conal: can I ask you a question or two?
22:06:46 <julianleviston> Actually I can probably ask anyone/everyone‚Ä¶ it‚Äôs about FRP. 
22:06:51 <julianleviston> Why is Event needed?
22:07:41 <julianleviston> Why can‚Äôt an event simply be a input-resolution ranged continous function that changes over time‚Ä¶?
22:10:18 <purelazy> julianleviston: I don't thing events change over time
22:10:37 <julianleviston> purelazy: usually they‚Äôre modeled as discrete moments in time.
22:10:41 <purelazy> julianleviston: They happen AT a specific time
22:10:46 <jle`> what do you mean by "input-resolution ranged continuous function" ?
22:10:49 <julianleviston> purelazy: as in [(T,a)]
22:11:01 <purelazy> :t (<$)
22:11:03 <lambdabot> Functor f => a -> f b -> f a
22:11:47 <julianleviston> jle`: I mean a function from time to value, but that uses uses ranged times to ‚Äúkeep‚Äù its values‚Ä¶ for example we know that the resolution of input of a click is +/- 1 nanosecond, say‚Ä¶ then that‚Äôs ‚Äúwhen‚Äù it happens in the Behavior.
22:12:04 <jle`> that's a different idea, semantically
22:12:09 <julianleviston> jle`: but this is dependent on the sampling resolution of the output to a degree.
22:12:11 <julianleviston> jle`: howso?
22:12:38 <purelazy> Events "can" be dependent on time, but in general they are dependent on people clicking buttons and keys being pressed
22:12:43 <julianleviston> jle`: the output resolution decides the granularity of the input resolution sampling (just like any other behavior).
22:12:55 <julianleviston> purelazy: these things happen in time, though, no?
22:12:59 <jle`> why can't we say that the integers are just real numbers but restricted to +/- 0.0001 of whole numbers?
22:13:10 <jle`> why do we even need integers?
22:13:14 <julianleviston> purelazy: as far as I understood Event, it was described as TimeT t => [(t,a)]
22:13:46 <julianleviston> jle`: I don‚Äôt really follow, sorry.
22:13:48 <purelazy> julianleviston: yeah, but not all things are "dependent" on time 
22:13:58 <julianleviston> purelazy: I thought all events *were*.
22:14:04 <julianleviston> purelazy: in FRP
22:14:15 <jle`> what's the difference between integers and real numbers?
22:14:19 <purelazy> julianleviston: you choose when you click a button - not any clock
22:14:23 <julianleviston> jle`: constraint?
22:14:41 <julianleviston> purelazy: yes‚Ä¶ so?
22:15:02 <julianleviston> purelazy: you can still have a continuous function on seemingly discrete inputs...
22:15:07 <Cale> julianleviston: I can explain my perspective on it
22:15:10 <julianleviston> purelazy: the function is just different.
22:15:16 <julianleviston> Cale: ok :) cool :)
22:16:22 <Cale> julianleviston: The fundamental difference is that Behaviours don't provide any way to tell when they are changing, which is why they can change continuously.
22:16:38 <julianleviston> Cale: sure, they‚Äôre continuous.
22:16:43 <Cale> (or more frequently than you would like to do computation, for example)
22:16:52 <julianleviston> Cale: yeah, infinitely, one might say ;-)
22:17:03 <Cale> Well, sometimes not infinitely often
22:17:16 <Cale> But for example, you might have some part of the system which is processing audio samples
22:17:19 <purelazy> I'm running GHCi 7.6.3 and it does not start up with (<$) loaded. 
22:17:20 <Cale> at 44kHz
22:17:24 <julianleviston> Cale: well, assuming you use Double for T (which he does), then yes.
22:17:35 <purelazy> I have to import GHC.Base. Is that normal?
22:17:36 <Cale> and then some other part of the system is rendering some graphics at 60Hz
22:17:42 <julianleviston> purelazy: I think that <$ is in a different module.
22:18:22 <Cale> You wouldn't want a 44kHz Event going from the audio part of the system to the graphics part, because that effectively gives the graphics part the "right" to do computation 44 thousand times every second, which it shouldn't have.
22:18:40 <Cale> However, it's fine to expose a Behavior
22:18:56 <julianleviston> Cale: yeah, sure. The output things are sampling things, at their rate of ‚Äúinterest‚Äù (concern / decided updating)
22:19:23 <Cale> The graphics part of the system might only have events which occur at most 60 times per second, and it would only be able to observe the values of the behaviours from the audio part of the system that often
22:19:42 <Cale> (Maybe some Behaviour would provide an FFT summary of the audio)
22:19:42 <julianleviston> sure
22:20:11 <julianleviston> yeah, the sampling resolution of calculation should be done by the output mechanism(s) ?
22:20:42 <Cale> Behaviours are "pull", Events are "push"
22:20:55 <julianleviston> I don‚Äôt know why events need to be different though.
22:21:14 <julianleviston> is it because they don‚Äôt have a simple description?
22:21:37 <Cale> Behaviours are things which are always there whenever you look at them, but they never notify you of anything. Events are things which only occur at particular points in time, but they tell you when.
22:21:54 <julianleviston> Cale: sure. But that‚Äôs not different.
22:22:10 <julianleviston> Cale: it only seems different.
22:22:14 <Cale> hm?
22:22:41 <julianleviston> Let me put it a different way‚Ä¶ Output is the only ‚Äúevent‚Äù that we need. 
22:23:07 <julianleviston> But that‚Äôs the underlying mechanism‚Äôs domain, not the programmer‚Äôs 
22:23:08 <Cale> In Reflex, if a function only has one Behavior as input, and it produces an Event, it is guaranteed that the Event never fires.
22:23:13 <julianleviston> meaning the designer of the FRP system.
22:23:41 <Cale> You can only produce occurrences of output events at times when your input events are firing.
22:24:11 <julianleviston> Cale: yeah, I‚Äôm pretty familiar with what has been done. I‚Äôm wondering about why, though.
22:24:18 <Cale> Well, okay, maybe if you had a Behavior t (Event t a)... :)
22:24:26 <julianleviston> No. Remove Event entirely.
22:24:46 <Cale> And replace it with what?
22:24:50 <julianleviston> Behavior.
22:25:06 <julianleviston> Output ‚Äúresolution‚Äù describes how the system runs.
22:25:15 <julianleviston> which informs the input behaviors.
22:25:48 <Cale> hm?
22:26:35 <jle`> resolution/sampling rate isn't supposed to be a part of the semantic picture of FRP
22:26:38 <Cale> Do you mean setting a fixed clock?
22:26:45 <julianleviston> jle`: and it wouldn‚Äôt be.
22:27:00 <Cale> and just computing the values of your behaviours on every clock tick?
22:27:02 <julianleviston> jle`: it‚Äôs just to do with the actualy implementation
22:27:10 <Cale> That's wasteful
22:27:20 <jle`> yeah, but FRP is a semantic model, not an operational description
22:27:21 <julianleviston> Cale: it depends what the system needs.
22:27:27 <julianleviston> jle`: yep.
22:27:35 <Cale> The purpose of Event is that you only have to do computation when events are occurring.
22:27:42 <julianleviston> jle`: that concern is orthogonal to what I‚Äôm talking about.
22:28:00 <julianleviston> Cale: You wouldn‚Äôt need to at all, though.
22:28:06 <julianleviston> Cale: your entire system could be lazy.
22:28:12 <Cale> The input events that you give to some part of the system determine how often it is allowed to compute things -- they effectively give you that "clock"
22:28:13 <julianleviston> Cale: I mean non-strict.
22:28:17 <totorystal> in /etc/sudoers ducument eg. root ALL=(ALL:ALL) ALL. what's the certain mean about the two "ALL"?
22:28:26 <Cale> But with the advantage that *inside* the system, you can manage this
22:28:43 <Cale> and provide many fewer event occurrences to things which are presumably expensive
22:29:09 <julianleviston> Cale: why calculate events at all if you don‚Äôt need to?
22:29:20 <julianleviston> Cale: if they were behaviors, you wouldn‚Äôt need to.
22:29:51 <Cale> If you only had Behaviors in Reflex, as the library stands, you would never compute anything.
22:30:06 <julianleviston> Cale: sorry I don‚Äôt know much about Reflex. I‚Äôm yet to use it.
22:30:14 <Cale> (Though it depends a bit on the driver which is running the system forward, I suppose.
22:30:16 <Cale> )
22:30:23 <julianleviston> Cale: exactly.
22:30:40 <julianleviston> Cale: there is only one ‚Äúevent‚Äù, which is the ‚Äúrun loop‚Äù, which is decided on by the outputs.
22:30:49 <jle`> i don't think you could really emulate any of the things that event is used for with Behavior
22:30:50 <Cale> But you want the system to have a way to notify the driver "hey, something is supposed to happen right now"
22:30:57 <jle`> behavior is not powerful enough to do what event does
22:30:58 <Cale> and not have the driver need to check on every frame
22:31:02 <julianleviston> Cale: the outputs would describet the runtime ‚Äúsemantics‚Äù of all the internal plumbing.
22:31:15 <julianleviston> Cale: well, what is ‚Äúright now‚Äù? that is the driver, right?
22:31:23 <julianleviston> jle`: I don‚Äôt see why yet.
22:31:32 <julianleviston> Cale: well, what‚Äôs a ‚Äúframe‚Äù ?
22:31:39 <jle`> Cale just described a few
22:31:55 <julianleviston> jle`: a few what?
22:31:56 <Cale> julianleviston: a moment in time at which an event may be occurring :)
22:31:57 <julianleviston> jle`: frames?
22:32:02 <jle`> things that Event can do that Behavior can't
22:32:08 <julianleviston> jle`: I‚Äôm not sure what.
22:32:17 <julianleviston> jle`: I think you might be stuck in thinking about events, perhaps.
22:33:01 <julianleviston> Cale: sure, you‚Äôd need to model input as output, actually.
22:33:21 <julianleviston> Cale: so that output calculation happens at the finest requirement your system has.
22:33:33 <Cale> So, if there were *only* events in the system, and no behaviours, then the result at each moment in time would be a pure function of what was going on with the inputs at that moment. It would be stateless.
22:33:37 <julianleviston> Cale: but output ‚Äúactivity/action‚Äù happens at the resolution of the output.
22:34:15 <Cale> Behaviours let you "remember" things.
22:34:16 <julianleviston> Cale: I think there needs to be ONE event‚Ä¶ the runloop‚Ä¶ and everything else behaviour‚Ä¶ 
22:34:40 <julianleviston> Cale: the runloop shouldn‚Äôt be the concern of the application-level programmer, though.
22:34:43 <jle`> the runloop isn't a part of the semantic picture of frp, though
22:34:49 <julianleviston> jle`: exactly.
22:35:17 <julianleviston> jle`: but call it whatever makes you happier‚Ä¶ it‚Äôs irrelevant if you model everything as behavior.
22:35:18 <jle`> and, frp implementations don't necessitate a run loop
22:35:21 <Cale> julianleviston: That's fine, you can do that, but it's a less sophisticated way of doing things, which is equivalent to having a single clock Event as input to the system
22:35:36 <Cale> Maybe we want more places where Events can come from
22:35:54 <julianleviston> Cale: you have ‚Äúclocks‚Äù anyway‚Ä¶ why not unify them‚Ä¶ it‚Äôd make the description of the system much simpler.
22:35:55 <Cale> Not just a steady clock
22:36:12 <Cale> Maybe we *don't* want a clock
22:36:13 <julianleviston> Cale: what I was saying doesn‚Äôt preclude other inputs.
22:36:28 <julianleviston> Cale: The ‚Äòclock‚Äô your talking about is simply whatever outputs there are in the system‚Ä¶
22:36:33 <Cale> hm?
22:36:52 <julianleviston> Cale: well, whatever you‚Äôve descibed as a concern for the application you‚Äôre building.
22:37:40 <Cale> julianleviston: I'm trying to understand how you want to model Events as Behaviours, and the only way I can imagine you're proposing to do it is to use a Behaviour (Maybe a), which just hopes to be set for an appropriate amount of time to cause whatever it's supposed to cause to happen
22:37:56 <julianleviston> Cale: no.
22:38:05 <Cale> Okay, can you describe it better?
22:38:12 <julianleviston> Cale: imagine a mouse‚Ä¶ 
22:38:17 <julianleviston> Cale: so it has x and y.
22:38:22 <Cale> Let's do an event-heavy example
22:38:29 <julianleviston> Cale: oh ok. your call then.
22:38:32 <Cale> Suppose I want to make XML HTTP requests to a server
22:38:37 <Cale> and get responses back
22:38:56 <Cale> In Reflex.DOM, I'd have something like  Event t Request -> m (Event t Response)
22:39:12 <Lokathor> so, why might having an explicit list of exports affect benchmark timing?
22:39:33 <julianleviston> Cale: sure.
22:39:50 <Cale> julianleviston: So which Behaviours should we use for something like this?
22:41:10 <julianleviston> Cale: well, this is up to the system‚Ä¶ but as an application level programmer, you‚Äôd create a  ‚ÄúBehavior Maybe Response‚Äù which has Nothing in it, or your last response.
22:41:21 <julianleviston> Cale: I suppose. If you wanted to model it that way
22:41:42 <Cale> But what if two responses come in very nearly at the same time?
22:41:46 <Cale> I don't want to lose one of them
22:42:08 <julianleviston> Cale: It depends how you want to build your application
22:42:10 <Cale> I'm firing off multiple requests, and the responses are coming back asynchronously
22:42:13 <cunntasl> may i ask for an honest opinion here?
22:42:34 <Cale> cunntasl: If it's related to Haskell :)
22:42:37 <julianleviston> Cale: if you‚Äôre sending mulitple requests to different URLs, then you have the request in there too, right, so they‚Äôre parameterised across these.
22:42:52 <cunntasl> damn it cale
22:43:06 <cunntasl> well technically actually no
22:43:08 <Cale> julianleviston: Well, don't worry so much about the details, there's nothing too special about the fact that they're HTTP requests specifically.
22:43:35 <Cale> julianleviston: It could be any kind of message-based communication with an external server
22:43:44 <julianleviston> Cale: sure. Well if you want to send multiple requests, then I suppose you‚Äôd have a [Request] rather than a Request. Right?
22:43:57 <julianleviston> Cale: it depends what you want.
22:44:15 <Cale> Yeah, in fact, we have (Traversable f, MonadWidget m) => Event t (f Request) -> m (Event t (f Response))
22:44:39 <julianleviston> Cale: haha you‚Äôre stuck in Reflex! :)
22:45:03 <Cale> I just mean, it doesn't even just have to be a list
22:45:10 <julianleviston> Cale: sure. It can be whatever you like.
22:45:14 <Cale> It's quite useful to use the pair instance of Traversable
22:45:15 <julianleviston> Cale: I don‚Äôt care what the value is.
22:45:29 <Cale> So that you can tag your request with some additional information which comes back alongside the response
22:45:31 <julianleviston> Cale: because‚Ä¶ Behavior is more about reality, to me.
22:45:36 <julianleviston> Cale: sure.
22:45:47 <Cale> But okay, so how are we going to do this with Behaviours?
22:45:49 <julianleviston> Cale: reality has no ‚Äúdiscrete time events"
22:45:54 <Cale> (I think we can't do it in a really sensible way)
22:45:56 <julianleviston> Cale: as I described. Behavior a
22:46:17 <Cale> I mean, suggest a type comparable with Event t Request -> m (Event t Response)
22:46:32 <julianleviston> Cale: Behavior a.
22:46:37 <Cale> What's a?
22:46:44 <Cale> Where's the request and response?
22:46:47 <julianleviston> Cale: I suppose you‚Äôd have to be inside IO, though. :)
22:46:57 <julianleviston> Cale: Are you asking me how I‚Äôd build the system?
22:47:07 <Cale> Yeah, just pick something, and I'll shoot holes in it :)
22:47:18 <Cale> If you only use Behaviours, you're going to have a bad time here.
22:47:23 <julianleviston> Cale: that‚Äôs not terribly fair, because I have never built one of these systems. :)
22:47:25 <julianleviston> Cale: ok.
22:47:36 <julianleviston> Cale: so your answer to why can‚Äôt we just use Events is that ‚Äúyou can't"
22:47:36 <julianleviston> ?
22:47:45 <julianleviston> sorry ‚Äúcan‚Äôt just use Behaviours"
22:47:52 <Cale> Well, there are many problems
22:48:03 <julianleviston> I haven‚Äôt actually heard any of them yet.
22:48:08 <Cale> Behaviours are things which change over time, and they hold their values over a range of times
22:48:10 <julianleviston> As far as I could tell.
22:48:23 <julianleviston> Cale: sounds exactly like what people call events to me, too...
22:48:39 <purelazy> Too hoogle from ghci  :def hoogle \str -> return $ ":! firefox https://www.haskell.org/hoogle/?hoogle=" ++ str
22:48:48 <julianleviston> Cale: you can model semi-discrete things as continuous if you specify a range of error of the input device...
22:49:07 <purelazy> then :hoogle fmap
22:49:48 <julianleviston> Cale: I should say ‚Äúapparently discrete"
22:50:00 <Cale> julianleviston: Yeah, you can do that... it's just going to be very prone to horrible bugs, and impose weird limitations that probably shouldn't be there -- like you have to decide *up front* what is the smallest amount of time between requests
22:50:02 <julianleviston> Cale: anyway, I‚Äôll keep noodling, I suppose. I was just wondering, is all.
22:50:13 <julianleviston> Cale: no you don‚Äôt, by the way.
22:50:18 <julianleviston> Cale: you decide at runtime.
22:50:31 <julianleviston> Cale: based on what the IO resolutions require
22:50:46 <Cale> The Behaviour changes over time to indicate what? Which request to make, right?
22:51:01 <julianleviston> Cale: whatever it is you‚Äôre modeling, sure.
22:51:17 <julianleviston> Cale: I think you‚Äôre stuck in the current FRP model.
22:51:24 <Cale> If you're going to do something involving behaviours here, you need the user of your library to provide you with some kind of behaviour that says which request to make
22:51:32 <julianleviston> Cale: Ideally, one would want an extremely simple semantics.
22:51:33 <Cale> right?
22:51:42 <Cale> What might that Behaviour's type be?
22:51:45 <julianleviston> Cale: sure.
22:51:53 <julianleviston> Cale: I haven‚Äôt built this system.
22:52:08 <julianleviston> Cale: so I might not be the best person to answer that ;-)
22:52:16 <Cale> I have built these systems :)
22:52:18 <julianleviston> Cale: I guess it‚Äôs fine to say you can‚Äôt help me understand this. It‚Äôs all good.
22:52:36 <julianleviston> Cale: oh‚Ä¶ which system(s) did you build?
22:53:00 <julianleviston> Cale: I need to try for myself, I think :)
22:53:11 <julianleviston> that‚Äôs probably the only way I‚Äôm going to find out what the problems are.
22:53:14 <Cale> I worked on a precursor to Reflex with Ryan Trinkle, and I'm now working on Reflex as part of my job (though Reflex itself has been pretty stable)
22:54:18 <nshepper1> uh, I think Behaviours and Events really just have different information?
22:54:30 <Cale> Back then, it was an very different looking FRP system (but with similar concepts) which used a reformulated Arrow type class
22:54:34 <Cale> nshepper1: I agree
22:54:36 <nshepper1> you can't fold over "each value" of a Behaviour
22:54:42 <Cale> Correct.
22:54:48 <nshepper1> it doesn't make sense
22:54:56 <Cale> You *can* fold over each value that a Behaviour takes on at given points in time
22:54:58 <julianleviston> nshepper1: why do you need to fold over anything exactly?
22:55:04 <julianleviston> Cale: yep.
22:55:23 <Cale> But that's the weird global clock thing that julianleviston was suggesting. It's less flexible and I don't know why you'd want to limit yourself like that
22:55:31 <julianleviston> Cale: you‚Äôve misunderstood me.
22:55:35 <julianleviston> Cale: I apologise.
22:55:49 <nshepper1> julianleviston: folding is pretty common?
22:55:51 <julianleviston> Cale: I wasn‚Äôt suggesting a static global clock or anything like that. You thought I meant a clock.
22:56:02 <julianleviston> nshepper1: to do what though?
22:56:14 <julianleviston> nshepper1: folding only makes sense over discrete values, doesn‚Äôt it?
22:56:20 <julianleviston> nshepper1: you can‚Äôt fold over a function, can you?
22:56:23 <Cale> julianleviston: Which is what Events provide.
22:56:24 <nshepper1> say you want to count how many particles have been received at you geiger counter
22:56:30 <nshepper1> julianleviston: that's the point
22:56:31 <julianleviston> Cale: yes, but why do you need to fold over events?
22:56:34 <nshepper1> Behaviour is just a function
22:56:42 <nshepper1> you can't fold over it
22:56:55 <julianleviston> nshepper1: you acn write an accumulating behaviour pretty easily, can‚Äôt you?
22:57:02 <Cale> julianleviston: Because maybe the events represent attacks made by a monster, and you want to determine the hitpoints of the hero somehow
22:57:05 <nshepper1> julianleviston: nope
22:57:06 <julianleviston> nshepper1: a function from time to Sum for example ? ;-)
22:57:10 <julianleviston> nshepper1: yeah, you can.
22:57:21 <nshepper1> julianleviston: exactly what are you going to accumulate?
22:57:22 <julianleviston> nshepper1: it‚Äôs a monoidal a.
22:57:35 <julianleviston> nshepper1: geiger clicks? I dunno that was your suggestion, no?
22:58:14 <nshepper1> julianleviston: if you're suggesting going outside of FRP and writing your Behaviour from scratch in IO, that's exactly what we don't want to do
22:58:24 <nshepper1> that's throwing away compositionality
22:58:32 <julianleviston> never mind. I need to go work this stuff out myself.
22:58:36 <julianleviston> Clearly I‚Äôm stupid.
22:58:56 <julianleviston> Tho a lot, when I ask these stupid questions, I‚Äôm on to something. 
22:59:33 <nshepper1> if you represent your geiger clicks as a Behaviour you can't count them. if you represent them as Events, you can easily and compositionally
22:59:40 <Cale> julianleviston: Oh, I should say something about what we call Dynamic in Reflex
22:59:45 <julianleviston> nshepper1: why can‚Äôt it be a Sum Geiger ?
23:00:00 <julianleviston> Cale: I‚Äôve seen dynamics at work a bit :) 
23:00:07 <julianleviston> Cale: just a smidge. But yeah, I‚Äôm all ears :)
23:00:22 <nshepper1> julianleviston: why can't *what* be Sum Geiger?
23:00:31 <julianleviston> nshepper1: your counting geiger clicks thing...
23:00:32 <nshepper1> Behaviour (Sum Geiger) isn't any use
23:00:35 <julianleviston> nshepper1: why not?
23:00:49 <nshepper1> julianleviston: because you can't fold behaviours...
23:01:02 <Cale> julianleviston: In Reflex, we have a type Dynamic which is effectively a pair of an Event and a Behaviour, the Event tells you when the Behavior is changing, and to which value. The Behavior only changes at those points.
23:01:13 <julianleviston> nshepper1: I must be idiotic. I apologise.
23:01:21 <julianleviston> Cale: yep.
23:01:42 <nshepper1> julianleviston: I want a Behaviour that represents the total number of clicks seen by far. I want to *write* this thing using FRP
23:01:44 <Cale> julianleviston: In Reflex.Dom we use those a lot, because the DOM isn't going to poll our program, that's just not how it works
23:01:52 <Cale> We need to push changes to the page
23:02:07 <julianleviston> nshepper1: using FRP, you probably can‚Äôt do that.
23:02:15 <julianleviston> nshepper1: I mean, you absolutely can‚Äôt.
23:02:22 <nshepper1> julianleviston: yes, you can, if you have Events
23:02:23 <julianleviston> nshepper1: but I‚Äôm not talking about normal FRP, obviously.
23:02:28 <Cale> So while you might think that the current page to be displayed is naturally a Behavior, in practice, we need those Events to tell us when to actually do the work of updating.
23:02:37 <julianleviston> nshepper1: I was saying you can‚Äôt fold over an FRP behavior as you said.
23:03:06 <julianleviston> Cale: yeah, I understand this.
23:03:17 <julianleviston> Cale: to me that‚Äôs nothing to do with what I‚Äôm talking about, though.
23:03:24 <Cale> It would be possible to make a system which actually did poll a Behavior
23:03:36 <Cale> But its performance would be terrible
23:03:45 <julianleviston> Cale: yes, I agree. But I‚Äôm not talking about that either.
23:03:48 <nshepper1> julianleviston: I'm confused... so we agree that you can do this with Events, but you can't do it with Behaviours?
23:03:57 <julianleviston> Cale: I really am talking about simplifying the programming interface...
23:03:59 <nshepper1> isn't it clear why Events are useful then?
23:04:05 <julianleviston> nshepper1: I‚Äôm not talking about current FRP.
23:04:11 <julianleviston> nshepper1: absolutely!
23:04:21 <julianleviston> nshepper1: in FRP, events are indispensible
23:04:30 <julianleviston> but what I‚Äôm talking about is NOT ‚Ä¶ FRP
23:04:50 <julianleviston> it‚Äôs just pure Behaviors, declared, and then a system that runs these things.
23:04:58 <parsecChar> is there a monadic text/string builder?
23:05:06 <julianleviston> And I was wondering why this wouldn‚Äôt be possible‚Ä¶ but yes
23:05:09 <parsecChar> I want a monad where I can build parts of the string part by part instead of ++ all over the place
23:05:18 <Cale> julianleviston: It's possible, but you won't be able to do the same things with it.
23:05:29 <julianleviston> Cale: I‚Äôm not sure why.
23:05:53 <Cale> parsecChar: You can use Writer for that, but... well, what are you doing?
23:06:12 <julianleviston> I thought there WAS a string builder called something like that that did exacttly that
23:06:27 <julianleviston> Cale: TimeT t => [(t,a)] looks VERY similar to TimeT t => (t -> a) to me.
23:06:32 <parsecChar> Cale: I'm writing a haskell-src-exts -> js compiler
23:06:41 <parsecChar> Cale: and now I'm outputting the *.js file
23:06:44 <Cale> julianleviston: It's not very similar...
23:06:54 <julianleviston> Cale: Ok. I think I‚Äôll shut up then. It‚Äôs probably less pain for everyone.
23:07:08 <nshepper1> julianleviston: yes, and pure Behaviours can't do what I described because it doesn't have Events...?
23:07:13 <Cale> julianleviston: *unless* you have a very peculiar and specific notion of what a time is
23:07:43 <Cale> (which wouldn't actually fit most of the applications we want to use these systems for very well)
23:07:43 <julianleviston> Let‚Äôs just say I disagree so far, and that‚Äôs fine. I‚Äôll go find out why I‚Äôm wrong now.
23:07:48 <julianleviston> Thanks for the convos!
23:07:51 <nshepper1> unless you've redefined Behaviour somehow...
23:07:59 <julianleviston> nshepper1: well obviously! :)
23:08:08 <julianleviston> nshepper1: that‚Äôs why I kept saying this isn‚Äôt FRP ;-)
23:08:29 <Cale> julianleviston: It might be better to use some other word, if the thing really can't just be thought of as a pure function of time.
23:08:30 <julianleviston> nshepper1: it‚Äôs my question about why the semantics of FRP are the way they are, using a hypothetical system as an example
23:08:43 <julianleviston> Cale: indeed. :)
23:09:03 <Cale> (though I think "pure function of time" actually specifies way more information than behaviors as realistically implemented usually have)
23:09:16 <julianleviston> What about this? https://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text-Lazy-Builder.html
23:09:31 <julianleviston> or is that totally the wrong answer.
23:09:41 <julianleviston> that‚Äôs pretty much just writer isn‚Äôt it
23:10:00 <Cale> It's at least the thing you'd want to use Writer to write
23:10:05 <nshepper1> anyway, the frp api is pretty simple already imo
23:10:17 <Cale> i.e. it's a Monoid with efficient concatenation
23:10:20 <julianleviston> nshepper1: yep :)
23:10:31 <nshepper1> it's 80% functor and applicative instances with like two more functions
23:10:38 <julianleviston> Cale: ah, Haskell is so pretty :)
23:11:12 <julianleviston> nshepper1: yeah, the new Reactive one Conal did is pretty awesome.
23:11:29 <julianleviston> nice: http://stackoverflow.com/questions/29102772/haskell-should-i-use-data-text-lazy-builder-to-construct-my-text-values
23:12:22 <julianleviston> O (n + m) sounds pretty yerk.
23:13:02 <julianleviston> Cale: nshepper1: thanks heaps for that convo, BTW. Very useful!
23:14:11 <Cale> julianleviston: One thing that I would really like people to think about is equational specifications for the FRP system that we already have.
23:14:39 <Cale> Most of the descriptions of what FRP "is" have been in terms of semantic interpretations.
23:15:13 <Cale> But that's like trying to do group theory where you study the general linear group only, and you don't really have a definition of an abstract group
23:16:16 <julianleviston> Cale: Oh, I‚Äôm pretty familiar with Conal‚Äôs specifications. I think he‚Äôs great.
23:16:46 <Cale> Yeah, and he's been pretty successful through them
23:16:50 <julianleviston> Cale: It‚Äôs actually incredibly simple. The trouble is, it‚Äôs very simple.
23:17:00 <julianleviston> People don‚Äôt seem to go well with simplicity. It‚Äôs too hard ;-)
23:17:01 <Cale> But I think there's something a bit overspecifying about it
23:17:27 <Cale> You don't necessarily want your Behaviours to really be *all* functions of time.
23:17:32 <julianleviston> Cale: his use of ¬µ and the whole denotational semantics without actually specifying what it is what a bit of a mistake, perhaps.
23:17:37 <Cale> They are just particular functions of time
23:17:48 <julianleviston> Cale: oh‚Ä¶ explain about that to me? :)
23:17:53 <Cale> and what "time" is actually affects greatly the operations you can perform on functions of time
23:18:01 <julianleviston> Cale: what‚Äôs an example of a B that isn‚Äôt a t -> a ?
23:18:18 <Cale> Oh, they're all "functions of time" in some sense
23:18:23 <julianleviston> Cale: ah ok
23:18:24 <Cale> But if time is the real numbers
23:18:35 <julianleviston> Cale: oh, that‚Äôs an implementation detail tho, right?
23:18:36 <Cale> Then you're allowed to do things like add an arbitrarily small constant to the input
23:18:45 <julianleviston> Cale: it‚Äôs just ‚Äúyou have to represent time as SOMETHING‚Äù ;-)
23:19:08 <Cale> Well, it really drastically affects the nature of the resulting system to choose a different idea of what time is
23:19:09 <julianleviston> Cale: maybe Time could be Nat ? ;-)
23:19:27 <julianleviston> Cale: I kid.
23:19:40 <Cale> and the operations you're allowed to perform on these functions also very dramatically changes the sorts of things which can be expressed and the potential implementation mechanisms
23:19:48 <Cale> Are you allowed to integrate?
23:20:04 <Cale> Do you have access to the identity function?
23:20:17 <julianleviston> Why not?
23:20:18 <nshepperd> Maybe time could be Complex Double </monster>
23:20:26 <Cale> It seems very natural that there would be a reflection of the identity function in the FRP system
23:20:40 <julianleviston> but surely, this is very implementation-specific stuff.
23:20:46 <Cale> But these actually tend to be pretty scary things to let users of the system have
23:21:05 <Cale> Because the current time is always out of date
23:21:22 <Cale> Well, it all matters in the end
23:21:32 <Cale> If you want to build real-world production systems with this stuff
23:21:37 <Cale> you need a really good story about implementation
23:21:53 <julianleviston> Sure.
23:22:02 <Cale> and the list and function implementation is totally impractical, since you have to provide all your input up front
23:22:27 <Cale> (we have that implementation of Reflex for testing)
23:24:08 <julianleviston> I‚Äôm reading http://conal.net/blog/posts/why-classic-frp-does-not-fit-interactive-behavior
23:24:19 <Cale> So, I'm hoping at some point that we'll figure out some set of primitives with equational laws of some sort. We have an okay candidate set in reflex from the perspective of "everything we want can be implemented in terms of these", but their types are a bit fancy to easily write laws down.
23:24:21 <julianleviston> ‚ÄúOne can argue as follows that this model applies to interactive behavior as well. Behaviors interacting with inputs are functions of time and of inputs. Those inputs are also functions of time, so behaviors are just functions of time. I held this perspective at first, but came to see a lack of composability.‚Äù
23:25:20 <nocturne777> Ppeaking of FRP, I am planning to use Elm for a new web project. It seems really cool. Have you guys had any experience with it?
23:25:23 <Cale> I think it's crucial that at some point we begin to understand FRP in an algebraic sort of way, which doesn't fix a notion of time at all.
23:25:25 <nocturne777> Speaking*
23:25:33 <Cale> I haven't used Elm myself.
23:25:48 <Cale> It does look interesting
23:26:33 <julianleviston> I‚Äôve used Elm.
23:26:40 <Cale> I think they might have a much better new user story than reflex-dom, but reflex-dom might have a better story in production, since you're using real Haskell on your frontend, so you get to pull in random things off of Hackage as you need them.
23:26:41 <nocturne777> Cale: I like the way how it treats html and css as first class citizens
23:26:50 <julianleviston> It suffers from precisely the things conal mentions these things suffer from‚Ä¶ 
23:27:18 <julianleviston> you have to compose everything as event streams, basically. It‚Äôs tiresome when you want to only react to certain parts of input.
23:27:43 <Cale> julianleviston: Can't you filter the event streams?
23:27:49 <julianleviston> Cale: sure.
23:28:00 <julianleviston> Cale: but not based on state‚Ä¶ which is what I wanted to do
23:28:07 <julianleviston> Cale: they have this foldp (fold over time) function.
23:28:22 <nocturne777> julianleviston: the whole thing feels like a state machine
23:28:25 <julianleviston> Cale: and all your event streams get merged or mapped into a single value that progresses the state based on inputs.
23:28:27 <julianleviston> yep. it is.
23:28:34 <julianleviston> nocturne777: yeah, exactly.
23:28:56 <julianleviston> Cale: the problem is that sometimes you don‚Äôt want mouse position to refresh the DOM.
23:29:34 <julianleviston> Cale: I wanted ‚Äúmodes‚Äù of my app that would change what the app listened to, but that‚Äôs not really possible as far as I could tell‚Ä¶ 
23:29:42 <Cale> Oh, does that happen, even if you filter the event?
23:29:51 <julianleviston> Cale: you can‚Äôt filter based on state.
23:29:53 <Cale> I don't know what Elm's FRP stuff really looks like
23:29:55 <Cale> hmm
23:30:04 <julianleviston> Cale: it‚Äôs pretty simple. Take you about an hour to look at..
23:30:07 <Cale> Only on the current value of the Event?
23:30:43 <nocturne777> julianleviston: are the limititations you ran into dealbreakers ?
23:30:47 <julianleviston> Cale: well‚Ä¶ you can filter on all kinds of things, but the folding function is the only thing with access to the state‚Ä¶ and that has to result in a State, which is the thing that forces the rendering of the view.
23:31:09 <julianleviston> nocturne777: I‚Äôm not sure, really‚Ä¶ i think I could kludge around it‚Ä¶ but it‚Äôs DEFINITELY not FRP.
23:31:47 <nshepperd> Oh, elm doesn't have behaviours does it?
23:31:49 <Cale> julianleviston: hmm... I'm wondering whether you might be able to statefully construct a Signal Bool, and then use *that* to filter the occurrences
23:32:02 <julianleviston> nshepper1: no. Everything is a Signal, which is an Event, basically.
23:32:07 <Cale> ah
23:32:08 <nocturne777> Could someone help me understand how these queries actually compile? https://github.com/chrisdone/lpaste/blob/bad90874d6052e817bd7163cbfdcab740bf7ff0b/src/Hpaste/Model/Paste.hs
23:32:11 <Cale> Signal is Event?
23:32:13 <Cale> hmm
23:32:17 <julianleviston> Cale: yeah, you can‚Ä¶ it has these things where you can post to mailboxes...
23:32:25 <nshepperd> Normally you would just pair the event with the state behaviour and filter that
23:32:36 <nocturne777> query takes an IsString, but those query strings are in an array
23:32:36 <Cale> nshepperd: Yeah...
23:32:49 <nocturne777> when I write the same code, it does not compile
23:33:05 <nocturne777> I also enable the OverloadedStrings extension
23:34:23 <julianleviston> nocturne777: it seemed a lot of hacking around how things normally work to get it working. (Fighting the system). But this could just be my lack of understanding.
23:35:10 <Cale> No wait, Signal is something weirder
23:35:20 <Cale> I think Signal is closer to Dynamic than Event
23:35:24 <nocturne777> julianleviston: I also heard that Redux + React is kind of trying to implement the same idea as Elm 
23:35:32 <Cale> Look at the type of filter
23:35:43 <Cale> filter : (a -> Bool) -> a -> Signal a -> Signal a
23:35:49 <nocturne777> julianleviston: but even in that stack, you are not supposed to modify state
23:35:58 <Cale> That second parameter is totally out of place if Signal were Event
23:36:03 <nocturne777> julianleviston: so I figured, instead of using that stack, I would use Elm
23:36:10 <julianleviston> nocturne777: yeah, state machines pretending to be FRP are the new thing. 
23:36:37 <julianleviston> nocturne777: Elm doesn‚Äôt modify state as far as I know.
23:36:58 <nocturne777> julianleviston: Elm does not, it creates new state
23:36:59 <Cale> Elm Signals have an initial value, before any updates.
23:37:07 <julianleviston> nocturne777: it‚Äôs just a loop‚Ä¶ the foldp transfers stepped states through Signal-driven ‚Äútime"
23:37:13 <julianleviston> nocturne777: yeah.
23:37:48 <nshepperd> Yeah they have an event at -infinity
23:38:15 <julianleviston> I really like Evan‚Äôs attempt at simplifying things, though.
23:38:25 <ontop> In the readme of this: https://hackage.haskell.org/package/htoml it shows how to pull a value from the table using `table ! "keyname"`
23:38:32 <nshepperd> I think here you have to make a mailbox and post your state there, then map2 that together with your events
23:38:37 <ontop> I can't get it to type check though :(
23:38:39 <julianleviston> nshepper1: yep.
23:38:45 <nshepperd> That will let you filter
23:38:55 <nshepperd> Pretty ugly
23:39:26 <Cale> By "mailbox", do you just mean a foldp somehow?
23:39:36 <nocturne777> julianleviston: the thing is, Elm eliminates the need for a lot of JS libraries
23:40:19 <kadoban> ontop: At a guess, maybe it needs OverloadedStrings ?
23:40:26 <ontop> Hm.
23:40:28 <julianleviston> Cale: a mailbox is a Signal  wrapper that you can ‚Äúpost‚Äù to.
23:40:28 <ontop> You might be right.
23:40:30 <Cale> oh, I see mailboxes
23:40:43 <julianleviston> nocturne777: yeah, Elm is extremely fast to do simple things with, too...
23:40:51 <julianleviston> nocturne777: you can learn it in about an hour.
23:40:56 <nshepperd> Cale: mailbox is iirc a thing that can receive custom events (as if from io)
23:40:59 <julianleviston> nocturne777: which is pretty nuts considering what it is.
23:41:02 <nocturne777> julianleviston: I already went through their examples
23:41:04 <ontop> kadoban: It says Expected type: Map Text TValue, Actual type: Table
23:41:05 <ontop> Hmm.
23:41:06 <Cale> ah... this is... "interesting"
23:41:13 <nshepperd> Here I'm just using it to get around elm being strict
23:41:23 <nshepperd> To allow recursive signals
23:41:31 <kadoban> ontop: Maybe the wrong (!) in scope.
23:41:48 <dmj`> how would one represent a Signal in elm? I don't think elm signals can quite be mimicked in Haskell with Chan/TChan/TQueue
23:41:59 <dmj`> I mean, a signal in *Haskell
23:41:59 <ontop> kadoban: Which one do I need I wonder? I imported Data.Map
23:42:08 <Cale> dmj`: At the very least you need an initial value too.
23:42:13 <nocturne777> could anyone help me understand how this thing compiles? https://github.com/chrisdone/lpaste/blob/bad90874d6052e817bd7163cbfdcab740bf7ff0b/src/Hpaste/Model/Paste.hs#L87
23:42:40 <dmj`> Cale: sure, if we abide by the model :: model, update :: update -> model -> model, view :: model -> Html pattern
23:42:41 <julianleviston> dmj`: it‚Äôs built in Haskell‚Ä¶ maybe the source might help
23:43:02 <kadoban> ontop: https://hackage.haskell.org/package/htoml-0.1.0.3/docs/Text-Toml-Types.html#t:Table it's not a Data.Map
23:43:07 <nocturne777> The query in the examples are not supposed to be an array
23:43:17 <Cale> dmj`: I mean, a value of type Signal t gives you a value of type t before any updates happen.
23:43:18 <ontop> kadoban: That's brilliant. Where'd he define his ! operator for Table? :|
23:43:29 <dmj`> julianleviston: well, not quite. A lot of datatypes are defined in js, and ffi'd I believe
23:43:38 <julianleviston> dmj`: ah, sorry :)
23:43:38 <kadoban> ontop: Probably the one from Data.HashMap I guess? (hopefully?)
23:43:39 <dmj`> julianleviston: for example, with signal, you'll find Native.Signal referenced
23:43:46 <ontop> Let's hope. TRYING
23:43:55 <julianleviston> dmj`: yeah, I did notice that a lot actually the native stuff.
23:45:44 <dmj`> Cale: ah I see
23:46:13 <ontop> kadoban: Ugh, how is this so unfindable lol. Doesn't appear to be in any of those.
23:46:37 <ontop> Let me provide a full error
23:47:01 <julianleviston> Cale: then there‚Äôs PureScript‚Äôs Halogen - have you seen that? That‚Äôs fascinating, too.
23:47:06 <dmj`> Cale: Signals can be combined in elm, this is problematic if we try to represent an elm signal with a TQueue / TChan, since you have to associate the read / write ends of the chan together. 
23:47:11 <nocturne777> nvm, I figured it out. Author defined some extra functions
23:47:13 <ontop> kadoban: http://lpaste.net/8522543887951069184
23:47:18 <ontop> Is that more helpful?
23:47:43 <julianleviston> Cale: he seems to use functions of time to time-function.
23:47:49 <julianleviston> Cale: assuming I‚Äôve understood it.
23:48:02 <julianleviston> Cale: the types get *quite* long.
23:48:03 <dmj`> Cale: otherwise, I'm not sure how a Signal t can be represented in Haskell, with say ghcjs :]
23:49:05 <ontop> Oh yeah! Found it.
23:49:09 <ontop> :D
23:49:24 <kadoban> ontop: I'm not really sure what's going on there. It's uncertain from that error message what Map is (which one you have imported). It looks like Table isn't a Map Text TValue though, it's a Map Text Node
23:49:39 <kadoban> (with Map being the one from Data.HashMap.Strict or something
23:49:46 <ontop> kadoban: Apparently it was in unordered-containers Data.HashMap.Lazy
23:49:51 <ontop> Or at least the lazy one works.
23:51:34 <kadoban> Hmm, well glad it works at least.
23:51:42 <ontop> Yeah, thanks for trying ^^
23:54:55 <Guest64988> @type map
23:54:56 <lambdabot> (a -> b) -> [a] -> [b]
23:56:55 <saurabhnanda> hello good people. Is there any way I can avoid littering my code with liftIO's? http://lpaste.net/154149
23:59:37 <Guest64988> @pl \(a, b) -> Just (a, [])
23:59:38 <lambdabot> Just . flip (,) [] . fst
