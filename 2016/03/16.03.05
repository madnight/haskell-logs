00:07:37 * hackagebot pinchot 0.14.0.0 - Build parsers and ASTs for context-free grammars  https://hackage.haskell.org/package/pinchot-0.14.0.0 (OmariNorman)
00:07:37 * hackagebot wai-middleware-throttle 0.2.1.0 - WAI Middleware for Request Throttling  https://hackage.haskell.org/package/wai-middleware-throttle-0.2.1.0 (ChristopherReichert)
00:30:22 <tekkkz> Hello. I want to use CmdArgs for my project. But I don't really understand how to use it. I mean I got their example working, but I have following question now: https://github.com/ndmitchell/cmdargs#readme In the first example I have following code: »sample = Sample{hello = def}« But I dont want to just print the input with a different formatting out, I want to give it to my functions and want to print this result 
00:30:22 <tekkkz> out then. How to do that?
00:37:00 <cocreature> tekkkz: something like "do args <- cmdArgs sample; someFunctionThatTakesArgs arg" should work
00:37:59 <tekkkz> huh i dont understand
00:38:07 <tekkkz> can you show me code example please
00:38:12 <cocreature> I just did?
00:38:22 <cocreature> maybe I didnâ€™t understand your question
00:39:52 <tekkkz> i want to parse the "def", so I think thats the input it received via cmdarg to an function and get its output
00:40:05 <tekkkz> instead of just printing the "def" like in its example
00:41:48 <cocreature> cmdArgs does the parsing, after that you just have get an IO a if you passed in an a and (after binding) you can pattern match on that do get to individual options
00:43:35 <tekkkz> I really dont understand ... so they show me in their example at this line: "sample = Sample{hello = def}" that when I give the function sample the argument -h text that i will print it out ... but I want to operate with text and print it then out, something like: "sample = Sample {hello = (reverse def)}"
00:43:38 <tekkkz> but this is not working
00:45:38 <tekkkz> cocreature, you understand what i mean?
00:45:44 <cocreature> tekkkz: let me make an example
00:45:49 <tekkkz> yeah thanks
00:46:12 <cocreature> tekkkz: http://lpaste.net/154064
00:48:03 * hackagebot dbus-th 0.1.2.0 - TemplateHaskell generator of DBus bindings  https://hackage.haskell.org/package/dbus-th-0.1.2.0 (IlyaPortnov)
00:48:05 * hackagebot path-io 1.1.0 - Interface to directory package for users of path  https://hackage.haskell.org/package/path-io-1.1.0 (mrkkrp)
00:53:27 <tekkkz> cocreature, where is parsedSample defined?
00:53:44 <tekkkz> ah lol
00:53:45 <tekkkz> sorry
00:53:46 <tekkkz> xD
00:54:01 <tekkkz> just woke up some minutes ago :D
00:54:59 <tekkkz> uh but what I dont understand, what is hello doing? at hello parsedSample
00:55:10 <cocreature> are you familiar with records in haskell?
00:55:46 <cocreature> Sample is a record with one field called hello, hello takes a Sample and extracts the hello field from it
00:59:01 <tekkkz> i need to have a look at this topic, ok? but one question left. How does it work if I have multiple modes like in their second example?
01:02:10 <tekkkz> also records are handling this hm? but could you please gimme a code example?
01:05:53 <cocreature> sorry I need to go, maybe someone else can help you more
01:06:58 <tekkkz> ohh no
01:07:03 <mniip> tekkkz, you mean records on variant datatypes?
01:07:08 <tekkkz> just this last question please?
01:09:03 <tekkkz> mniip, no i dont know, did you follow my question and answers here?
01:09:15 <mniip> I skimmed quickly
01:09:17 <tekkkz> cocreature provided an example how I can do what i want to doo
01:09:35 <tekkkz> but we just looked how to do it when i have one possible argument, the hello
01:10:05 <tekkkz> we didnt looked how it works for multiple modes like they described on their example readme
01:10:15 <tekkkz> so how to realize all this with muliple modes?
01:10:55 <mniip> "modes"?
01:11:32 <tekkkz> yeah i mean multiple arguments ... have a look at https://github.com/ndmitchell/cmdargs#multiple-modes
01:13:03 <tekkkz> how to distinguish between the modes?
01:13:20 <mniip> well you have a datatype with 2 constructors
01:13:40 <mniip> you should be able to distinguish between the two, shouldn't you?
01:14:09 <mniip> the same way you check whether a Maybe is a Just or a Nothing
01:14:13 <tekkkz> yeah but how? im new and this is very confusing for me at the moment
01:14:20 <mniip> pattern matching
01:14:34 <tekkkz> yeah ... so i need an extra functions which does this?
01:15:24 <daedalus_> Hey everyone, my adventures in nested lists continue, and I am starting to get some promising results.
01:15:34 <daedalus_> Essentially, what I am trying to do boils down to solving this problem (https://byorgey.wordpress.com/2007/08/16/mapping-over-a-nested-functor/)  by using GADTs.
01:15:42 <mniip> tekkkz, no?
01:15:54 <daedalus_> Here is what I've got so far:
01:15:55 <daedalus_> https://gist.github.com/filonik/af7a947e82e869d59c38
01:16:22 <daedalus_> Which allows things like:
01:16:23 <daedalus_> persons `groupby` status `select` name
01:16:38 <tekkkz> mniip, then i dont know what you mean. could you please gimme an example?
01:16:45 <mniip> daedalus_, I don't think that's possible
01:16:49 <mniip> due to ambiguity reasons
01:17:02 <daedalus_> Well, yes.
01:17:20 <daedalus_> I have certainly been running into some challenges.
01:17:24 <mniip> > case Just "tekkkz" of Just x -> "Just: " ++ x;  Nothing -> "Nothing"
01:17:25 <lambdabot>  "Just: tekkkz"
01:17:31 <mniip> > case Nothing of Just x -> "Just: " ++ x;  Nothing -> "Nothing"
01:17:33 <lambdabot>  "Nothing"
01:17:34 <daedalus_> And it feels like I am fighting the typesystem a bit.
01:18:04 <daedalus_> But I have it working in one direction (adding layers of nesting).
01:18:37 <mniip> hmm
01:18:55 <daedalus_> Unfortunately, when wanting to be able to remove layers of nesting (e.g. apply aggregates), I am stuck.
01:19:23 <daedalus_> Well, not so much stuck, but I have to specify the return type explicitly, as it cannot be deduced.
01:20:44 <mniip> I don't think it's possible without a nasty hack like -XKitchenSink
01:20:45 <daedalus_> And yes, I am using AllowAmbiguousTypes.
01:20:53 <mniip> uh
01:20:58 <daedalus_> Hm, that's a shame.
01:20:58 <mniip> you don't want that
01:21:10 <daedalus_> Yeah, I worried that might be the case.
01:21:16 <mniip> you'll need to deduce type-inequality
01:22:14 <mniip> type families might be of assistance but that's probably stretching it too far
01:22:47 <daedalus_> Well, GADTs + Typefamilies definitely help.
01:22:58 <daedalus_> That's what I have in my current solution.
01:24:06 <daedalus_> I have a feeling that there is probably a really fundamental reason why this doesn't work, and that's why I have to dance around so much and use all these extensions.
01:24:42 <daedalus_> Kind of a frustrating problem, because it feels like it should be easy enough to deduce.
01:26:06 <daedalus_> If I have a [a] and a "a -> [b]", then I can make a [[b]]. If I have a [[b]] and a "[b] -> c", then I can make a [c], etc.
01:27:04 <daedalus_> But of course, the problem is that you want the same function to work for varying levels of nesting.
01:27:17 <mniip> the problem is that if you have 'sort :: [a] -> [a]'
01:27:18 <daedalus_> I.e. apply the right amout of fmaps...
01:27:32 <mniip> there's nothing preventing it from actually having the type [[a]] -> [[a]]
01:27:43 <daedalus_> Yes, I see the ambiguity there.
01:28:19 <daedalus_> But if you could rule out that a ~ [b]?
01:29:12 <daedalus_> Because, in practice, you will always start with a flat list.
01:29:16 <mniip> in the best case, you have to check whether a ~ A or a ~ g c
01:29:29 <mniip> but that's not possible with the class/instance stuff
01:29:49 <tekkkz> mniip, now I fund out how CmdArgs works. But I think its not good for what I want. CmdArgs is handling functions with special arguments, but I just want to handle arguments ... 
01:30:31 <daedalus_> So, I totally understand why this is impossible to solve in general, but if I can make some assumptions, such as, the starting point will always be a flat list.
01:31:06 <daedalus_> Then I should be able to keep track of the amount of nestings that have been added in my type.
01:31:24 <daedalus_> That is what I currently do.
01:31:33 <daedalus_> And that seems to work well enough.
01:31:56 <mniip> that doesn't help at all
01:31:57 <daedalus_> But like I said, the implementation was a bit awkward and I had to enable way to many extensions for my taste.
01:32:06 <mniip> your assumption
01:32:07 <mniip> that is
01:33:40 <daedalus_> mniip: Hm, I think I can sort of see what you are saying, but not quite, how come?
01:33:57 <daedalus_> Oh, well.
01:34:09 <daedalus_> I mean, that and there would have to be other restrictions.
01:34:20 <mniip> nope
01:34:28 <mniip> it's just that that's only one layer
01:34:35 <mniip> out of N
01:34:48 <daedalus_> That works fine by induction.
01:34:49 <mniip> and the other N-1 have the same problem as the original
01:34:56 <mniip> no it doesn't?
01:35:04 <daedalus_> See my example.
01:35:05 <daedalus_> persons `groupby` status `groupby` age `select` name
01:35:14 <daedalus_> https://gist.github.com/filonik/af7a947e82e869d59c38
01:36:42 <daedalus_> I am not saying the solution is particularly nice, but it seems to work.
01:36:50 <mniip> ok wow
01:36:57 <mniip> do you have a more minimal example?
01:37:31 <daedalus_> Hehe, yeah, apologies, I tried to strip out as much as I could. :)
01:38:15 <daedalus_> The idea is that the type is parameterised by the nesting depth.
01:39:03 <mniip> that's not in any way related to your original problems
01:39:09 <daedalus_> I actually came here hoping that somebody could suggest simplifications.
01:39:22 <mniip> here you use GADTs indexed with bunch of type-level information
01:39:32 <mniip> in your original question you were telling apart [] from [[]]
01:39:44 <mniip> er, [a] vs [[a]] I mean 
01:39:48 <daedalus_> Sorry, I was paraphrasing.
01:40:06 <mniip> which kinda means,
01:40:08 <daedalus_> The lists are not plain haskell lists.
01:40:23 <mniip> ok, let's say arbitrary functors
01:40:32 <mniip> 'f a' versus 'f (g a)'
01:40:37 <daedalus_> Well, no.
01:40:40 <mniip> that's even less possible to tell apart
01:40:45 <daedalus_> Because I realise it is impossible.
01:40:59 <daedalus_> That's why it has to be less general.
01:41:18 <mniip> no it just has to be different
01:41:21 <daedalus_> My list type does not work like standard lists.
01:41:53 <daedalus_> I.e. a list of list is not the same as a list with an extra level of nesting.
01:42:12 <daedalus_> That's what gets rid of the ambiguity.
01:42:45 <mniip> NList is to [] as tensors are to vectors, or am I mistaken?
01:43:07 <daedalus_> No.
01:43:11 <daedalus_> Not exactly.
01:43:16 <daedalus_> The shape isn't fixed.
01:43:31 <daedalus_> Only the nesting has to be uniformly deep.
01:43:42 <mniip> sure is, it's always going to be of a specific rank
01:43:55 <daedalus_> Yes, the rank is fixed.
01:44:01 <daedalus_> But the dimensions are not.
01:44:08 <mniip> ofc
01:44:09 <daedalus_> Just wanted to clarify that.
01:45:05 <daedalus_> So this is a valid NList: fromList' _2 [[1],[1,2],[1,2,3]].
01:45:21 <daedalus_> The _2 represents the nesting depth.
01:45:37 <daedalus_> And it is type-level.
01:46:03 <mniip> right
01:46:21 <mniip> (not sure why you'd need the singleton here)
01:47:01 <daedalus_> Yeah, I started with that, but maybe I can get rid of it.
01:47:39 <daedalus_> Or do you mean why do I have to pass it to fromList'?
01:48:20 <mniip> fromList'/toList' don't have to take singletons
01:48:22 <daedalus_> Because List is a type family.
01:48:26 <mniip> NList isn't
01:48:32 <daedalus_> So I cannot get the n from that.
01:49:05 <mniip> why can't you
01:49:11 <daedalus_> But what would I pattern match on?
01:49:30 <mniip> on an internally produced singleton
01:50:10 <mniip> fwiw you can just say fromList'' = fromList' natSing
01:50:13 <mniip> or whatever it is
01:50:18 <daedalus_> Yes, I played around with that for a bit, but I couldn't get it to work.
01:51:49 <daedalus_> Not sure, because wouldnt that give me a NList _1 (NList _1) as opposed to an NList _2?
01:52:05 <daedalus_> (They are not the same.)
01:52:30 <daedalus_> (That's how I get rid of the ambiguity regarding nesting depth.)
01:53:00 <daedalus_> But the construction of NLists is acually not such a big issue, in my opinion.
01:53:39 <daedalus_> Because in practice, I will always construct them from a flat list, so I could just say fromList = fromList' _1
01:54:38 <daedalus_> Then I will perform some operations on it (xs `groupby` ... `select` ... `groupby` ..).
01:54:48 <daedalus_> And then turn it back into a list.
01:56:01 <daedalus_> I just want to have a nice and simple sql like embedded language, without manually having to keep track of nesting and applying fmaps.
02:06:09 <daedalus_> mniip: Alright, I'm taking a break from this. Thanks for your suggestions, though!
02:26:01 <spoing> hello! I'm trying to make a small program that generates ascii fantasy worlds (like in some roguelikes, such as dwarf fortress) and I've currently made a program that generates a list of random locations with a random location and a random name. I want to improve the world gen so that I create blobs of a certain terrain (so that mountains and fores
02:26:01 <spoing> ts aren't scattered all over the map, but rather cluster together), and I'm trying to make a function to create such blobs: http://pastebin.com/61Gt02UC
02:27:49 <spoing> I'm still getting to grips with how IO works, and in this case I get an error on compile that tells me that the list I'm trying to build in the helper function (go) cant match expected type [Point] with actual type IO Point
02:32:47 <xa0> spoing: go _ l 0 = 0 returns [Point]
02:33:00 <xa0> Assuming the other branch of the function does too
02:33:14 <xa0> But you want [IO Point] (?)
02:33:44 <spoing> not really, but I thought I needed it since I'm doing randomly generated numbers
02:33:54 <spoing> I thought IO "tainted what it touched"
02:35:50 <spoing> I do get the same error though, it complains that i have an IO Point but it's looking for a [Point]
02:36:26 <xa0> spoing: it does, that's what I mean, your function should be returning whatever is in that list
02:36:34 <xa0> Once you're in IO you can't get out
02:41:08 <xa0> spoing: would it be okay to return an IO [Point] instead in your gen function
02:41:17 <spoing> yes
02:41:32 <xa0> I reccomend you do that then, it should make things much easier
02:41:58 <spoing> okay. whats the difference between [IO Point] and IO [Point]? In practical terms
02:42:50 <xa0> In IO [Point] the generation of the list and everything in it is sideeffectful. In [IO Point] the list itself is pure, but each element is an action
02:43:04 <xa0> So you've split the IO over the points, in the second one
02:43:12 <xa0> Which isn't always.. possible?
02:43:30 <spoing> yeah ok!
02:43:31 <spoing> i get it
02:45:55 <spoing> the helper function is still doing some weird stuff though. It seems like it wants the first argument to be a list of points. I guess I'll try to explicitly name the types
02:47:07 <xa0> Yeah that should help
02:49:31 <spoing> thanks a lot! I'll try to play around with it  some more and see if I can get it to work. btw, when I'm in a do block and I write something like x <- randomRIO (0, 4) :: IO Int, is the x also of the type IO Int?
02:49:48 <spoing> or does IO Int generate an Int which is placed into x?
02:49:50 <shachaf> No, x is of type Int.
02:49:56 <shachaf> @quote /bin/ls
02:49:56 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
02:50:42 <spoing> yeah okay, that's what I thought. good to know! :)
02:53:06 * hackagebot osm-conduit 0.1.0.0 - Parse and operate on OSM data in efficient way  https://hackage.haskell.org/package/osm-conduit-0.1.0.0 (przembot)
02:56:58 <saurabhnanda> test
03:20:10 <saurabhnanda> victory. I finally managed to understand the types of Yesod/Persistent
03:20:22 <saurabhnanda> :t runSqlite ":memory:" ((liftIO getCurrentTime) >>= (\time -> insert $ User (Just "Saurabh Nanda") "saurabhnanda@gmail.com" time time))
03:20:24 <lambdabot> Not in scope: â€˜runSqliteâ€™
03:20:24 <lambdabot> Not in scope: â€˜getCurrentTimeâ€™
03:20:24 <lambdabot> Not in scope: data constructor â€˜Userâ€™
03:22:46 <dicioccio> ls
03:26:32 <synthmeat> is it possible to get pandoc to output whatever css he usually generates in head of html, to file?
03:46:54 <raek> does stack have a command like "cabal get"? I want to download the hsqml-demo-samples to look at some examples (I don't want to the package as a dependency to my project or anything)
03:49:31 <demize> raek: stack unpack
04:00:59 <raek> demize: thanks
04:03:08 * hackagebot haphviz 0.1.2.1 - Graphviz code generation with Haskell  https://hackage.haskell.org/package/haphviz-0.1.2.1 (Norfair)
04:09:15 <frangor> hi
04:14:45 <voltz> How does category theory and type theory differ? 
04:17:18 <adimit> I want a function f :: m (Maybe b); I have an action k :: m (Maybe a) and an action l :: a -> m b. I can do f = do { a <- k; case a of ; Nothing -> Nothing; (Just a' -> l a) } but I want to lose the case statement, because it's ugly. Is there a better way with fmap or so?
04:20:46 <voltz> :t fmap
04:20:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:25:58 <raek> let's see. fmap l k :: m (m (Maybe a))
04:26:05 <raek> :t join
04:26:06 <lambdabot> Monad m => m (m a) -> m a
04:26:34 <raek> join (fmap l k)
04:26:50 <pavonia> :t (>>=)
04:26:50 <raek> that should have the right type, I think
04:26:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:29:00 <Bender_Maximo> hi
04:29:29 <raek> gah, my head hurts when I think of the types of nested monads...
04:30:05 <Bender_Maximo> cool
04:30:39 <raek> adimit: There is a MaybeT monad transformer. Perhaps it could be used. Anyone else have an idea?
04:32:33 <cocreature> how about k >>= traverse l?
04:33:18 <raek> :t traverse
04:33:19 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
04:38:22 * hackagebot pandoc-crossref 0.2.0.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.2.0.0 (lierdakil)
04:47:59 <Sangeet> can anyone help me with DRUPAL error?
04:48:36 <Sangeet> it is very simple,actually it is logical error or something i missed during coding
04:48:41 <adimit> raek: yeah, nesting monads can get tricky.
04:48:58 <adimit> I thought there might be a cool solution, I'll try traverse after lunch :-) Thanks.
04:49:45 <Sangeet> Hmmm
04:50:13 <Sangeet> i am already wasted my half saturday but still not able to find the solution for it
04:50:52 <srhb> Sangeet: This channel is about the Haskell programming language. Perhaps there are other channels out there that can help you?
04:51:36 <Sangeet> Ohh.sorry i read somewhere that this is good group for programming,even i did not know that#HASKELL is a language.
04:51:51 <srhb> Sangeet: No problem, and good luck. :)
04:52:16 <Sangeet> SORRY.there is group for drupal but it looks like people are enjoying there saturday or working 2X hard
04:52:21 <Sangeet> OK.
04:53:33 * hackagebot dbus-th-introspection 0.1.0.0 - Generate bindings for DBus calls by using DBus introspection and dbus-th  https://hackage.haskell.org/package/dbus-th-introspection-0.1.0.0 (IlyaPortnov)
04:55:39 <pavonia> Sangeet: Have you tried #drupal-support?
04:58:52 * hackagebot download 0.3.2.1 - High-level file download based on URLs  https://hackage.haskell.org/package/download-0.3.2.1 (psibi)
05:28:08 <xa0> I'm having trouble pinning down exactly what "higher kinded types" are
05:28:34 <hpc> have you ever used monad transformers?
05:28:37 <hpc> :k ReaderT
05:28:38 <lambdabot> * -> (* -> *) -> * -> *
05:28:40 <xa0> Yep
05:28:51 <hpc> there you go then ;)
05:28:55 <xa0> Is it just anything with a kind that isn't just *?
05:29:27 <xa0> Or anything which takes a type constructor as a type argument
05:29:32 <hpc> it's something with (not *) as a parameter
05:29:36 <hpc> yeah
05:29:37 <xa0> Ah okay
05:29:42 <xa0> That makes sense then
05:29:46 <xa0> Gotcha, thanks
05:30:04 <hpc> much like higher order functions have types like a -> (b -> c) -> d -> e
05:30:11 <hpc> but not a -> b -> c -> d -> e
05:31:42 <xa0> Yeah I think I get the idea
05:32:58 <hpc> for extra credit, there's a deeper moral there about type and value levels being the same which you can learn about elsewhere :D
05:34:01 <xa0> Dependent typing? :p
05:34:25 <hpc> yep
05:35:55 <hpc> and on that excellent note, back to writing java :(
05:39:49 <funrep> are there any heterogenous lists in Java?
05:40:40 <funrep> OR is there some way to define a type containing different types that could be past to List<T>?
05:43:00 <echo-area> Two functions f and g are equal, if and only if they have the same domain and codomain, and for every value x in domain(f), g(x) = f(x), and for every value x in domain(g), f(x) = g(x), right?
05:44:04 <seishun> ugh this last chapter in lyah. I can't help thinking "what the hell is the point of this"
05:46:17 <xa0> From a stylistic point of view, "a . b $ c" or "a $ b c"? (Specifically for three items, or I'd go pointwise)
05:48:23 <funrep> i think a . b $ c is mostly used but i personally like a $ b c since it reads more like unix pipes
05:48:50 <funrep> is there any way of using the haskell pattern "data Foo = Str String | Num Int; type Bar = [Foo]" in java ?
05:49:06 <xa0> Yeah
05:49:39 <hpc> xa0: for only three items, a (b c)
05:49:46 <hpc> or i would find a way to drop the c and write (a . b)
05:49:57 <xa0> Brackets? Hm, interesting
05:50:22 <hpc> it's an old lisp feature that somehow got ported over :P
05:50:31 <xa0> Haha
05:50:36 <funrep> guys im writing a lisp intepreter in Java, if i want a list of strings and ints and bools, how do i do that?
05:50:57 <funrep> it doesnt support heteregenous lists so i need to somehow represent several different types as one type to pass to List<T>
05:51:04 <echo-area> hpc: What Lisp feature is that?
05:51:16 <hpc> echo-area: parens (it was a joke)
05:51:26 <echo-area> Oh
05:51:27 <funrep> xa0: you could just write a . b aswell
05:51:36 <funrep> or maybe not
05:51:57 <funrep> (i assumed c was a argument but could be something else ofc)
05:52:54 <hpc> if you're feeling particularly obfuscatory, you can write ($ c) (a . b)
05:53:19 <xa0> Well that's just cheeky :p
05:57:30 <osfameron> funrep: haven't done Java for a long time, but maybe Union types?
05:58:30 <osfameron> also you can have a list of values conforming to a specific Interface, can't you?
06:01:08 <ahihi> you can sort of emulate sum types with sealed classes: http://www.drmaciver.com/2007/09/how-to-create-sealed-classes-in-java/
06:02:44 <funrep> okey thanks for the suggestion, but there most be a more idiomatic way right? tons of programs needs lists of several types
06:03:20 <funrep> the core problem i have is to represent lisp AST, i tried to use sum types and lists but maybe there is another way which is a better fit for java?
06:03:39 <ahihi> ##java might be more appropriate
06:04:53 <hodapp> or #lisp
06:05:46 <funrep> oh im in the wrong channel sorry
06:06:42 <hodapp> ##java also ends up being the wrong channel for any question, really
06:10:12 <xa0> hodapp: hahah
06:10:19 <hodapp> srsly.
06:10:33 <xa0> I don't doubt, it's just amusing
06:29:25 <bollu> hello everyone
06:30:29 <bollu> I was wondering what's the requirements to upload a package onto Hackage?
06:30:35 <bollu> I mean, what's the threshold of quality?
06:31:30 <bollu> I have bindings to symEngine that I've just started writing
06:31:35 <bollu> I'd like to upload it to stackage
06:31:43 <Ashy> you just sign up for an account and upload it to hackage
06:32:05 <Ashy> bollu: https://hackage.haskell.org/upload
06:34:36 <xa0> So basically, the threshold is "compileable"
06:35:14 <bollu> xa0: I have uploaded packages before, but they were tooling written in haskell
06:35:23 <bollu> this is different, as a library, I feel somewhat more.. responsible
06:35:37 <xa0> Heh
06:36:04 <sm> bollu: nothing is enforced, but some nice things are: configure a readme and a changelog in other-files (or extra-source-files ? I can never remember), and set PVP-style bounds, especially on base to limit it to compatible versions of GHC
06:36:20 <sm> nice haddocks that build without error..
06:36:23 <bollu> sm: PVP is..? both lower and upper bounds?
06:36:33 <sm> I forget, there's a page somewhere
06:36:43 <bollu> sm: oh, right. I've never written haddocks documentation
06:36:55 <bollu> sm: where can I get docs on haddock?
06:36:58 <sm> https://wiki.haskell.org/Package_versioning_policy
06:37:03 <sm> the ghc user guide
06:37:23 <sm> cabal/stack haddock will build them I think
06:38:30 <sm> also, good metadata in the cabal file - maintainer, description, hackage categories, repo, issues..
06:39:05 <sm> there's also cabal check 
06:39:24 <slack1256> To compile with -prof is absolutely neccesary that all my dependencies were profiled builds, right?
06:39:48 <slack1256> I even if I kind of know where my error is on my project and can guarrantee is not on the dependencies?
06:40:05 <sm> buildable cross-platform, otherwise a prominent note..
06:40:54 <sm> slack1256: yes
06:41:13 <slack1256> damn, well
06:43:47 <meditans> hi, I prepared a file to ask a question (on type system programming in general, and vinyl in particular): https://gist.github.com/meditans/25aa96755718bb892f2f
06:45:24 <meditans> the inspiration is an actual problem in the design of music-suite (the question is at the bottom of the file)
06:48:37 <ClaudiusMaximus> sm: hi, any thoughts on http://hub.darcs.net/simon/rss2irc/issue/3
06:49:48 <sm> ClaudiusMaximus: odd.. is it possible you've been blocked for too many connections ?
06:50:29 <ClaudiusMaximus> sm: that's the first additional connection i've made for a few days, let me try fire up another normal irc client...
06:50:30 <EvanR> meditans: are the vinyl records only so you dont have to have all 3 properties on every note
06:50:34 <sm> ok
06:51:08 <meditans> EvanR: yes, so I can write [c,d,e] and generate the correct representation
06:51:24 <EvanR> ok so you can do that without vinyl
06:51:29 <meditans> EvanR: but crucially, I want to be able to do that for different record types
06:51:50 <meditans> EvanR: using essentially typeclasses?
06:51:56 <EvanR> no
06:52:12 <EvanR> im kind of suspicious when things get too typeclassy
06:52:23 <ClaudiusMaximus> sm: i can connect with another client without problems
06:52:36 <meditans> EvanR, ok, let's see how (the current implementation of the concept in the library doesn't use typeclasses, but in the end feels difficult to understand)
06:52:47 <sm> ClaudiusMaximus: the command looks correct, but it times out for me also
06:52:55 <meditans> how would you achieve the result?
06:53:03 <ClaudiusMaximus> sm: ok, good to know it's not just me i guess :/
06:53:16 <EvanR> to do what i said, though it might not be what youre looking for, you have a type for the note and it has all the properties all the time
06:53:27 <sm> strange
06:53:45 <EvanR> but its a monoid
06:53:56 * hackagebot data-fix 0.0.2 - Fixpoint data types  https://hackage.haskell.org/package/data-fix-0.0.2 (AntonKholomiov)
06:54:18 <EvanR> so if c is a value with pitch c and default other stuff, you can mappend a value of loudness 5 to get a pitch c loudness 5 note
06:54:27 <EvanR> loudness 5's default pitch doesnt affect the result
06:54:49 <EvanR> now this doesnt allow you to use arbitrary record types as notes
06:55:01 <EvanR> however you can use a type variable to allow the user to use whatever monoid they want
06:55:25 <EvanR> and another type class for how to derive the pitch 
06:55:32 <EvanR> maybe
06:55:51 <EvanR> i would go for the monomorphic way first though
06:57:52 <meditans> EvanR: a monoidal trick similar to this is what's is used in the current version of the library. However, as we cannot choose the arbitrary record we are forced to simulate that with nested types, like in https://github.com/music-suite/music-preludes/blob/master/src/Music/Prelude/Standard.hs#L64
06:58:50 <EvanR> meditans: then something like vinyl seems like an upgrade, but whats your problem with it?
06:59:10 <meditans> the crucial point is that "c" should mean different things in different contexts, so it's difficult to start from a value with "all the attributes", because you may not know there they are, or may want to swap one for another
06:59:37 <meditans> so, I want to express a concept but cannot because my type-level-fu is still weak xD
06:59:47 <meditans> I want to say that, eg, c, has type
07:00:24 <meditans> c :: (RecAll Default (rs `Excluding` PitchValue), rs `Has` PitchValue) => Rec Attr rs
07:00:32 <EvanR> for c to be mean different things in different contexts, then it either needs to be bound nearby, in the context, or it needs to be a monad (to hind the binding)
07:01:04 <EvanR> otherwise its not refernentially transparent
07:01:15 <meditans> no I mean, what I want is this: c is a thing with pitch C, and the default for the other values
07:01:36 <EvanR> you have a nested tuple there
07:01:42 <EvanR> but what i was suggesting was
07:02:08 <EvanR> { pitch :: Maybe Pitch, loudness :: Maybe Loudness, ... }
07:02:32 <EvanR> im not sure what the tuple is getting you
07:03:03 <meditans> EvanR: which tuple are you referring to? The current implementation one?
07:03:20 <EvanR> you could compute stuff on it with typeclasses if the the children were type variables but they are concrete types
07:03:23 <EvanR> yes
07:04:00 <meditans> it's because we don't want to decide a priori which fields a note should have
07:04:07 <EvanR> in my way it could be c = { pitch :: Just C, loudness :: Nothing, ...}
07:04:19 <meditans> that part has to depend on the particular program you want to write
07:04:20 <KaneTW> adimit:
07:04:27 <KaneTW> :t \l -> fmap (>>= l)
07:04:28 <lambdabot> (Monad m, Functor f) => (a -> m b) -> f (m a) -> f (m b)
07:04:52 <EvanR> meditans: but... whats with AllDefaults
07:04:54 <meditans> because for example, you may be working in a context without loudness, but with a property invented specifically to model the kind of music you're describing
07:05:07 <xa0> KaneTW: that's terrifying
07:05:36 <KaneTW> it's exactly what he wanted, though
07:05:42 <KaneTW> also kinda cute
07:05:51 <xa0> heh
07:05:56 <EvanR> meditans: is pitch a special property?
07:05:57 <meditans> EvanR I want the remaining records to have default values, _for all_ the choices of record, ie. I don't want to commit to a particular representation earlyu
07:06:14 <sm> ClaudiusMaximus: but it worked just now
07:06:44 <ClaudiusMaximus> sm: hm
07:06:48 <meditans> EvanR: for example c :: Rec Attr [PitchValue, Loudness] should work, but also c :: Rec Attr [Part, PitchValue], or whatever the user may want
07:06:57 <meditans> no, Pitch is not particularly special
07:07:02 <EvanR> as long as they have PitchValue?
07:07:08 <ClaudiusMaximus> sm: any clues how to make it reliable?
07:07:25 <meditans> EvanR: yes exactly, as long as they have pitchvalue and a default instance for the other types
07:07:30 <sm> it usually is.. freenode may have been getting DDOSed or something
07:08:00 <EvanR> man thats a gnarly property to require in the type :S
07:08:07 <EvanR> just having pitch seems doable
07:08:11 <sm> I restart all rss2irc's periodially with cron because of the memory leak, so that helps
07:08:12 <EvanR> but that all other values are the default value
07:08:35 <meditans> EvanR: having pitches is easy, it's basically the â‰… constraint in vinyl
07:08:48 <ClaudiusMaximus> sm: well so far i've not managed to connect at all, which naturally limits my ability to hack on the code to hopefully help fix the unicode/memleak issues
07:09:04 <meditans> I suspect that I should use for the default part RecAll Attr rs Default
07:09:15 <sm> still not working, even now ?
07:09:50 <sm> however, you may be able to debug a lot without the irc connection (just omit the irc server argument)
07:10:05 <meditans> and maybe use the reifyConstraints function to manipulate the constraints where I need the
07:10:06 <meditans> them*
07:10:14 <meditans> but I continue to get stuck xD
07:10:25 <ClaudiusMaximus> sm: same timeout, just tried
07:10:37 <ClaudiusMaximus> sm: ok, i'll try without real irc
07:11:49 <ClaudiusMaximus> sm: i didn't realize that I could just omit the irc server argument to simulate, was hunting for a special command line flag
07:11:52 <sm> it doesn't seem like your connects just now would get you blocked, but maybe it happened earlier ? they are quick to block clients, I had to go to #freenode to get a special exception
07:12:10 <ClaudiusMaximus> sm: ah ok
07:12:27 <sm> but, I saw the problem too just now. Still, something to keep in mind if it doesn't start working soon
07:12:29 <ClaudiusMaximus> sm: but still, i tried a different network and it failed there too
07:12:34 <sm> ok
07:14:14 <sm> strange, then. Worth trying from a different ISP too
07:15:23 <ClaudiusMaximus> sm: sure, but that's a bit tricky for me (haven't got a haskell toolchain on any servers i have access to) suppose i could go to the pub and use their wifi though
07:15:32 <sm> yup
07:16:23 <sm> if you're at home/work, it seems unlikely IRC would be blocked, but testing never hurts
07:16:24 <ClaudiusMaximus> sm: how would you prefer contributions?  a fork on darcshub?
07:17:10 <sm> ClaudiusMaximus: I guess, unless you want to take it over and move it somewhere else
07:17:31 <ClaudiusMaximus> sm: i barely maintain my own stuff, so i don't plan on taking over more
07:17:36 <sm> damn
07:17:39 <ClaudiusMaximus> hehe
07:17:39 <sm> :)
07:19:20 <jophish_> mniip: What is it about Nat that's so broken? I've not had much luck searching around this topic and have never run into a problem with them myself
07:19:34 <sm> if all else fails, you could ask #freenode for help. They might be blacklisting certain IP ranges or something
07:20:44 <ClaudiusMaximus> sm: well i'm on irc from home, and test connection worked too - will see how far i get without irc to start with
07:21:38 <bennofs> jophish_: when working with Nat, you oftentimes want to have a full solver for arithmetic equalities. For example, I don't think that ghc can conclude that (a + b) + c ~ a + (b + c) right now (if it can do that, then there's certainly other stuff that it can't)
07:22:33 <jophish_> There seem to be quite a few plugins capable of doing that though
07:22:49 <jophish_> sorry, I should have mentioned that first thing
07:23:20 <EvanR> in what sense is (a + b) + c = a + (b + c) ?
07:23:24 <EvanR> (in haskell)
07:23:48 <EvanR> oh Nat
07:26:16 <f-a> I am not really getting the difference between `type parameter` and `type argument`. http://stackoverflow.com/questions/34779980/is-type-variable-the-alias-of-type-parameter I read this but I am still confused
07:27:04 <EvanR> data Maybe a = -- parameter?
07:27:15 <EvanR> -> Maybe Int -- argument?
07:27:33 <f-a> that's what I thought, but the link apparently says otherwise
07:28:03 <f-a> "in Foo (Maybe a), I would call a a type argument and (Maybe a) a type argument"
07:28:17 <EvanR> er 8 updoots must be right
07:29:02 <EvanR> yeah you are applying Maybe to a
07:29:14 <geekosaur> hm. I'd read it as EvanR does
07:29:52 <f-a> yeah I was weirded out
07:30:44 <geekosaur> oh, given that quote by itself I can actually see that interpretation
07:31:15 <geekosaur> a is a type argument, which happens to be a type variable, to Maybe; (Maybe a) is a type argument to Foo
07:32:06 * geekosaur still having network issues so SO page has not loaded yet x.x
07:32:07 <unit73e> hey
07:32:33 <unit73e> I'm having issues with hindent => renameFile: unsupported operation (Invalid cross-device link)
07:32:41 <unit73e> know anything about that?
07:33:36 <geekosaur> unit73e, I think that's a known bug, it's assuming renameFile will work from /tmp to the location of the original file but /tmp may well be a different filesystem
07:34:06 <mauke> s/may well be/usually is/
07:34:16 <geekosaur> (especially on systems where systemd has been configured to give every login a distinct "/tmp")
07:34:45 <unit73e> yeah the file exists anyway but it is annoying
07:35:13 <unit73e> perhaps pipeline style will work
07:35:26 <mauke> https://github.com/chrisdone/hindent/issues/170
07:37:27 <geekosaur> f-a, ok,having finally gotten the page to load, I'm sticking with my most recent comment
07:37:43 <unit73e> lost connection
07:37:49 <unit73e> anyway pipelining seems to work
07:37:53 <mauke> https://github.com/chrisdone/hindent/issues/170
07:38:21 <geekosaur> as the expression does not appear to be a declaration, there are no type parameters (which, if I were being pedantic, I'd call "formal type parameters") present
07:38:37 <unit73e> ok so it will be eventually fixed
07:38:38 <unit73e> thanks
07:38:53 <unit73e> I'll just use pipeline for now
07:38:55 <f-a> geekosaur: ok, so let's see if I get this right. Parameters are on the left side of the = in data declarations
07:39:00 <f-a> (lowercase)
07:39:07 <geekosaur> yes
07:39:10 <EvanR> formally, they are formal type parameters, if i were to be formally formal
07:39:14 <f-a> variables are everything lowercase
07:39:42 <f-a> and arguments are the, mh, leftmost appliable thing, whether it is lowercase or else?
07:39:54 <mauke> parameters are the variables in the function definition, arguments are the expressions in the function call
07:39:58 <mauke> at least that's what I learned in C
07:40:16 <EvanR> its like, the word argument is used when you have an example thing to be used 
07:40:16 <geekosaur> yes. although these are "functions" at the type level instead of the value level
07:40:33 <EvanR> when youre talking about what could go there in general, its a parameter
07:40:58 <EvanR> i can see how its easy to mix up because its talking about the same thing...
07:41:07 <f-a> geekosaur: data Foo a = F (Maybe a) <-- is Maybe a an argument?
07:41:20 <EvanR> that short hand is a little weird
07:41:29 <EvanR> data Foo :: * -> * where
07:41:33 <unit73e> well in learned that parameters are the signature of a function while arguments are what is used when calling the function
07:41:35 <EvanR>   F :: Maybe a -> Foo a
07:41:38 <unit73e> but its all the same
07:41:43 <geekosaur> I'd say (Maybe a) is a parameter to the data constructor F, yes. although it's a little unclear
07:41:55 <EvanR> f-a: what youre pointing to on the right is really odd shorthand syntax, not really code
07:42:01 <geekosaur> as EvanR just showed, the GADT-style declaration makes it a bit more obvious
07:42:01 <EvanR> its shorthand for what i wrote
07:42:27 <f-a> thanks
07:52:40 <unit73e> is it common to have commas at the beginning of a line in haskell? I'm used to having commas at the end of the line
07:53:08 <geekosaur> it's a common way to format things in lists or records, yes
07:53:17 <unit73e> ok I'll follow that style
07:53:20 <unit73e> thanks
07:57:48 <gigglypuff> another thing: i was talking to an old guy in IT who was giving me tips and stuff, and he said that i should be "focusing on algorithms" instead of programming, because "programmers are a dime a dozen"
07:58:06 <gigglypuff> it all seemed very vague, honestly. any idea as to what he meant?
07:59:05 <unit73e> he meant that anyone can make unreadable inneficient programs but it takes skill to know how to make readable efficient programs
07:59:14 <geekosaur> pretty much, yes
08:00:32 <sm> ClaudiusMaximus: --debug-irc shows that 
08:00:49 <gigglypuff> what does focusing on algorithms entail? it seemed like he was strongly recommending that i stop learning languages altogether, from his tone and the context of the discussion
08:01:13 <gigglypuff> was he recommending that i become a theoretician or something?
08:01:40 <ClaudiusMaximus> sm: i used --debug-irc
08:01:55 <gigglypuff> that's what came to mind first, because most of them have a reputation for being able to write code better than your average joe in programming
08:02:04 <gigglypuff> (even if most don't)
08:02:11 <sm> then that's strange. I can see how it would timeout if its not receiving that message from you
08:02:27 <ClaudiusMaximus> yes
08:03:36 <geekosaur> gigglypuff, algorithms are kinda disjoint from languages: if you learn algorithms, you can use them in any language
08:03:58 <ryanar> gigglypuff, first off, most companies in interviews will focus on data structures and algorithms knowledge, being able to use and understand algorithms and datastructures appropriately to solve problems and optimize time and space complexity is important
08:04:03 <geekosaur> and you will write better code in the language(s) you know.
08:05:16 <geppettodivacin> I don't think it's wrong to understand many languages, either, since that helps make you a better programmer in the languages that you know, too.
08:05:27 <geppettodivacin> But algorithms are generally more applicable.
08:05:29 <geekosaur> languages are tools. algorithms and data structures are about knowing how to use your tools effectively
08:06:16 <ryanar> you can bumble along copy pasting code from stackoverflow and getting stuff together to work, but your design might suffer from bugs, slowness at scale, lack of extensibility, and incur technical debt later on down the road. Really imo you kinda want the whole package, but a lot of people focus on languages in their interviews, I know java, or I know C++, while its good to know languages, they are just tools, like a hammer, if you 
08:06:16 <ryanar> know how to build a house, it won't take you long to learn the tool that the company wants you to use to build it, unless its Haskell :)
08:07:04 <ryanar> I really want to delve into Osaki's functional data structures book at some point!
08:07:11 <gigglypuff> well, that's a bit more fleshed out than "algorithms" alone. how does one go about learning "algorithms"? "algorithms" seems extremely vague, like telling some to "go learn some code, dude"
08:07:35 <geekosaur> see, I;d argue there that Haskell forces you to learn more stuff up front, but someone who uses (say) Java well has invested as much time and effort into understanding Java as a Haskell programmer has into understanding Haskell
08:07:41 <sm> algorithms are unimportant for a huge segment of working programmers
08:07:43 <geppettodivacin> ryanar: I got that book for Christmas. It's pretty good and surprisingly understandable.
08:08:27 <ryanar> well that's good to hear geppettodivacin !
08:08:30 <sm> you'll mostly get them for free from all the libs and tools you use
08:09:30 <ryanar> sm, true which is what the IT guy gigglypuff mentioned early was saying, a lot of programmers will just use libraries that have done all the heavy lifting and integrate them, at which point its better to understand design
08:09:32 <sm> but the term isn't vague, wikipedia would be a good start
08:10:30 <gigglypuff> it doesn't give me much of a starting point, though
08:10:55 <ryanar> gigglypuff, to learn algorithms i'd really recommend a couple of books.. one sec let me find the links
08:11:37 <sm> "basic algorithms" finds some good places
08:11:42 <ryanar> the CLR book is really popular http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844
08:11:48 <ryanar> for teaching algorithms
08:12:14 <Sonarpulse> I think "algorithms" tend to be way over valued
08:12:30 <nitrix> Does lambdabot lets you load extensions?
08:12:37 <nitrix> Or temporarily enable one?
08:12:43 <ryanar> Sonarpulse, I do too, but its still what is asked in interviews :(
08:12:55 <nitrix> :set -XOverloadedStrings
08:13:10 <geekosaur> nitrix, no
08:13:13 <Sonarpulse> well, depends what you are applying to
08:13:22 <geekosaur> but I thinkt hat one is enabled for you
08:13:25 <ryanar> http://erikdemaine.org/classes/ here is a course that goes along with the CLR book
08:13:29 <nitrix> :t "Hello"
08:13:30 <lambdabot> [Char]
08:13:34 <nitrix> geekosaur: Doesn't seem like it.
08:13:57 <nitrix> :t "Hello" :: IsString a => a
08:13:58 <lambdabot>     Couldn't match expected type â€˜a1â€™ with actual type â€˜[Char]â€™
08:13:58 <lambdabot>       â€˜a1â€™ is a rigid type variable bound by
08:13:58 <lambdabot>            an expression type signature: IsString a1 => a1
08:14:05 <ryanar> and here is a quora post with the top ones https://www.quora.com/Massive-Open-Online-Courses-MOOCs/What-are-the-best-Algorithms-MOOCs
08:14:12 <nitrix> Rigid huh. Yeah nah, it isn't enabled.
08:16:02 <geekosaur> thought I remembered it being in there but in fact it's not, sigh
08:16:29 <geppettodivacin> I think the importance of algorithms is usually less about actually memorizing particular algorithms but instead to help people practice thinking elegantly about code.
08:20:05 <geppettodivacin> gigglypuff: I think the old IT person was probably just tired of seeing lots of programmers who can't really program.
08:20:14 <EvanR> i dont want to think about algorithms if im trying to think elegantly about code
08:20:26 <geppettodivacin> gigglypuff: http://blog.codinghorror.com/why-cant-programmers-program/ -- It's an old article, but it's still pretty true.
08:20:58 <sm> gigglypuff: and for deeper motivation and a bigger picture, you could check out this old IT person :) http://www.cs.utexas.edu/users/EWD 
08:22:01 <EvanR> fizzbuzz type questions in an interview seem to be not that great for anyone involved
08:22:27 <geppettodivacin> EvanR: I agree, but it's still pretty sad when people can't think of any way to do it.
08:22:48 <Athas> Does anyone know of some other IRC channel, mailing list, forum, or whatnot, for discussing functional programming and the implementation thereof?  (I assume #haskell is mostly about Haskell.)
08:23:21 <EvanR> in an interview i was asked for a program to sort money or something, but the 3 word haskell program was not enough for them
08:23:36 <EvanR> it needed to the one most optimal known algorithm from art of computer programming
08:23:39 <nitrix> Granted, a lot of the questions sometimes implies frames of mind already to succeed. Questions like "Write a loop that counts to 10"; sure you can have a recursive function in Haskell that kinda count to 10, but it's not like you can really manipulate control-flow at will like procedural languages would let you.
08:24:01 <nitrix> The interviewer might get disapointed.
08:24:23 <EvanR> yes
08:24:38 <geppettodivacin> EvanR: Well, that sounds like the most disappointing interview question ever.
08:24:40 <nitrix> It's not the best example but the point is there I think.
08:25:09 <EvanR> geppettodivacin: it was partition the coins into equally valued stacks
08:25:26 <geppettodivacin> > mapM_ putStrLn $ map show [1..10]
08:25:28 <lambdabot>  <IO ()>
08:25:39 <geppettodivacin> Pbbt.
08:26:03 <nitrix> geppettodivacin: That could be argued as not a loop, from an execution/control-flow perspective.
08:26:04 <EvanR> my original gripe here is that the questions are usually so far removed from what youre going to need to be able to do, namely, move json data from point A to point B
08:26:12 <ggole_> Athas: you mean language implementation?
08:26:21 <Athas> ggole_: well, or design.
08:26:22 <ClaudiusMaximus> sm: which version were you testing?  the new line 43-44 here looks suspect to me  http://hub.darcs.net/simon/rss2irc/patch/6f93fba1917a0690d13c633dc9622dabd481dd4f
08:26:43 <geppettodivacin> nitrix: I've seen several arguments made here that lists are the best form of a loop
08:26:46 <ggole_> There's #compilers (which is very slow) or, uh, that language design channel I can never remember
08:26:58 <Athas> ggole_: I just realised there is no place I can discuss such things apart from conferences and my department, and I figured I'd see if anything existed.  There is programming.reddit.com of course...
08:27:02 <ggole_> #proglangdesign
08:27:02 <nitrix> geppettodivacin: By the way, you could mapM_ print instead. print is a combination of show and putStrLn.
08:27:42 <nitrix> geppettodivacin: Only infinite lists.
08:27:46 <EvanR> Athas: theres #oasis maybe
08:27:58 <geppettodivacin> Mm, true. I usually forget that it adds the newlines.
08:28:08 <nitrix> e.g cycle [0,1]
08:28:30 <geppettodivacin> nitrix: Aren't finite lists and infinite lists still computed equivalently, except that one has a definite break?
08:28:46 <EvanR> one ends in [], the other doesnt
08:29:12 <Athas> And amusingly, Haskell does not have a proper built-in type for infinite lists.
08:29:27 <EvanR> haskell doesnt have built-in types
08:29:31 <nitrix> They are similar, but I think you were trying to demonstrate a loop, and for that you'd need circular lists.
08:29:37 <Athas> Oh, right, standard library type.
08:29:44 <EvanR> data Stream a = Stream a (Stream a)
08:30:06 <nitrix> geppettodivacin: Which, Haskell can achieve with infinite lists and lazyness.
08:30:10 <Athas> Yeah, it's easy to define myself.  I do that all the time.  I just find it sort of amusing that lists are usually used for this purpose, despite not really being nice for infinite lists.
08:30:20 <EvanR> its a pretty standard hackage package
08:30:24 <nitrix> geppettodivacin: The finite ones I think doesn't demonstrate any loop whatsoever.
08:30:24 <sm> ClaudiusMaximus: "rss2irc 1.1". I'll try the latest HEAD to be sure
08:30:31 <ggole_> The advantage is that you can reuse many of the list functions
08:30:37 <ggole_> take, zip, etc
08:30:42 <EvanR> you could also say, haskell doesnt have a built in type for UTCTime
08:31:20 <nitrix> Small question, does RankNTypes allowed for heterogenous lists?
08:31:23 <nitrix> *allows
08:31:26 <geppettodivacin> nitrix: I suppose it depends on what you consider a loop. In C++, (int i = 0; i < 10; ++i) cout << i << endl; has an obvious end to it, too. Haskell just enforces that end much nicer.
08:31:46 <nitrix> geppettodivacin: Yes, but `for` in C++ affects control-flow.
08:31:52 <EvanR> a loop is really a cultural thing
08:32:03 <EvanR> rather than technology
08:32:10 <ggole_> There are objective definitions of loops
08:32:10 <geppettodivacin> Eh. Point taken.
08:32:23 <ggole_> But they may not correspond well to what people intend by using the term.
08:32:26 <nitrix> geppettodivacin: Thus, my original claim that the interviewer might get very disapointed even of trivial questions.
08:32:31 <nitrix> *on
08:32:47 <sm> ClaudiusMaximus: actually I don't have time right now.. if it's any help my rss2irc binary was built on june 15 2014, it's probably HEAD as of that date
08:32:50 <ggole_> eg, the technical definition of loop in a CFG
08:32:52 <Athas> Another thing, does anyone know what is considered the fastest way to program GPUs in a functional language (or in any high-level matter, really)?  Accelerate seems to be the best of the bunch for Haskell, but it's also quite restricted.
08:33:33 <ClaudiusMaximus> sm: ok, that's around the date of the last batch of patches, so hard to be sure
08:33:39 <sm> I'd try without Bernd's patches
08:52:33 <sm> oh, and mine around that date too, definitely
08:58:35 <scshunt> Is there a syntactic extension to doing case inside a do?
08:58:40 <scshunt> something like case <- x of
08:58:45 <scshunt> I feel like there was but can't find it
08:59:04 <scshunt> I know I can do x >>= \case
09:02:25 <kuribas> why not just do y <- x; case y of ...?
09:03:21 <quchen> scshunt: \case is as far as you can get.
09:03:57 <quchen> What do you want to do that's impossible with it, or maybe inconvenient?
09:03:59 * hackagebot atomic-primops 0.8.0.3 - A safe approach to CAS and other atomic ops in Haskell.  https://hackage.haskell.org/package/atomic-primops-0.8.0.3 (RyanNewton)
09:06:40 <scshunt> nothing super special
09:10:51 <lpaste> jts pasted â€œParseUnicodeCharâ€ at http://lpaste.net/154074
09:11:36 <jts> This is certainly a newbie question, but I'm having trouble understanding how to write the above function more elegantly
09:11:50 <quchen> [h1, h2, h3, h4] <- replicateM 4 hexDigit
09:12:58 <jts> beautiful, thanks!
09:13:08 <TOB1> hi
09:13:09 <pavonia> Also, head can fail with a pattern match error
09:13:50 <quchen> jts: http://lpaste.net/154074
09:14:04 <quchen> See the annotation. I've used pattern matching instead of head/fst.
09:14:22 <quchen> This way you'll get a parse error if the pattern doesn't match, instead of a hard program crash. :-)
09:17:44 <jts> noted. In this case is is possible for fst . head to fail if one of the hexDigit parses hasn't already failed?
09:18:28 <jts> or maybe I'm assuming more eager evaluation than occurs here
09:20:15 <quchen> jts: The point is you don't have to care. Using pattern matching should usually be preferred to functions like fst/head/... for several reasons. For one, "fst" doesn't tell you much, whereas in a pattern you can give things useful names. Second, a failing "x:_" pattern will give you a compiler warning (or in the case of monadic code that supports 'fail', a parse error for example).
09:20:53 <quchen> foo = fst (head xs)  vs  (foo,_):_ = xs
09:21:04 <quchen> I say the latter is much more readable.
09:21:20 <quchen> You can see the structure you're deconstructing immediately. You see which parts you ignore.
09:21:56 <quchen> In the former case, you have to walk through the things to see what's actually being looked at. "fst, oh this is a tuple. Alright, head, so it's a list. It's a tuple of lists. Oh wait, wrong order, it's a list of tuples."
09:23:12 <jts> I'd agree, it's clearer, I think I have a bit of a pathology to avoid left-hand sides that I need to overcome
09:23:44 <quchen> I felt pattern matching in 'let' awkward too for some time :-)
09:23:51 <quchen> +was
09:24:49 <jts> yeah, that's a bit of a hurdle for me too, it seems like it forces me to use a do that I could otherwise avoid
09:25:09 <jts> (or the lambda syntax, which I feel is both less idiomatic and uglier)
09:35:00 <John[Lisbeth]> I am studying different types of recursion and I was interested in recursion using finite state machines in imperative languages such as c, and how they are very efficient with memory and speed.
09:35:17 <John[Lisbeth]> But I am told that those finite state machines are not in fact capable of doing lambda calculus.
09:37:09 <EvanR> a recursion state machine in C will actually not work
09:37:14 <dbushenko> hi all!
09:37:27 <EvanR> it will leak memory until you get stack overflow
09:37:42 <dbushenko> I'm trying to fetch latest stack package index -- it just freezes...
09:37:53 <dbushenko> is something wrong with latest stack?
09:38:46 <EvanR> you can fix it by trampolining but
09:38:54 <EvanR> then its not really recursive
09:39:30 <Eduard_Munteanu> EvanR, depends on the compiler, some will do tail call elimination
09:39:46 <EvanR> ive heard of this but never seen it
09:40:14 <John[Lisbeth]> My friend is claiming he can do recursion with state machines that do not increase in memory.
09:40:15 <Eduard_Munteanu> s/some/many/
09:40:21 <EvanR> and since its not idiomatic C or commonly supported technology might as well not be a thing in C
09:40:21 <HoloIRCUser1> Hey guys good news.
09:40:27 <ggole_> gcc will do sibling call elimination, which is not the same thing as proper tail call elimination
09:40:37 <HoloIRCUser1> the problem iwas having a few days ago has been fixed
09:40:43 <monochrom> to ease the comparison, you don't have to talk about lambda calculus. you can talk about Turing machines and other automata first.
09:40:49 <HoloIRCUser1> I finally got cabal update set up 
09:40:54 <ggole_> And there are various things which will prevent the optimisation even for sibling calls
09:40:57 <HoloIRCUser1> on windows 7.
09:40:58 <quchen> Eduard_Munteanu: Now that you mention it, what about "tail-recursive do"? Anything in do-notation is a (>>=)-term, do you know what GHC does to ensure recursive do doesn't blow up the stack? sequence for example should require something like this
09:41:00 <ggole_> tldr: don't rely on it
09:41:06 <HoloIRCUser1>  :D
09:41:29 <monochrom> but then it is known that finite state machines can't do some things pushdown automata can do. and in turn, pushdown automata can't do some things Turing machines can do.
09:42:09 <HoloIRCUser1> Sorry for really driving you guys nuts with my questions <p
09:42:12 <monochrom> you just need one final theorem about "Turing machines and lambda expressions are mutually convertible" to finish the whole product line.
09:42:32 <Eduard_Munteanu> quchen, well, as long as you don't hold on to prior stack "frames", they'll go away
09:42:46 <EvanR> quchen: hrm... i never noticed that there would be a problem with recursively defined functions using do, or are you talking about recursive do
09:43:33 <EvanR> @src forever
09:43:33 <lambdabot> Source not found. stty: unknown mode: doofus
09:43:44 <EvanR> i guess @src is kaput
09:44:10 <quchen> EvanR: Just standard do notation, not the extension
09:44:27 <quchen> forever m = m >> forever m -- not tail recursive
09:45:07 <EvanR> depending on the monad that could be bad
09:45:10 <quchen> I guess due to Haskell's (or better, GHC's) evaluation model, this might automatically not grow the stack because of laziness
09:45:12 <EvanR> but IO works
09:45:38 <quchen> I know. But why? :-)
09:45:42 <EvanR> IO is special
09:45:59 <spoing> what are some good terminal gui libraries?
09:46:04 <dbushenko> guys, can anyone check if stack is able to feth latest index?
09:46:04 <quchen> spoing: vty
09:46:12 <EvanR> can any other monad do forever for some productive thing?
09:46:40 <quchen> spoing: Or brick
09:46:41 <Eduard_Munteanu> Conduit.
09:46:41 <luigy> dbushenko what command are you trying out? stack is working fine
09:46:46 <quchen> (based on vty)
09:46:55 <dbushenko> I'm trying to create a new project
09:47:04 <dbushenko> oh, at last
09:47:11 <dbushenko> luigy: sorry for bothering
09:47:13 <quchen> EvanR: Writer?
09:47:19 <dbushenko> looks like I had to wait
09:47:23 <EvanR> > forever [1]
09:47:27 <lambdabot>  mueval-core: Time limit exceeded
09:47:28 <quchen> That's List
09:47:38 <EvanR> > forever (tell 1)
09:47:39 <lambdabot>      No instance for (Show (m0 b0))
09:47:39 <lambdabot>        arising from a use of â€˜show_M351240034759188507124332â€™
09:47:39 <lambdabot>      The type variables â€˜m0â€™, â€˜b0â€™ are ambiguous
09:47:39 <quchen> EvanR: Or a transformer with IO in it
09:47:47 <EvanR> well right, IO
09:47:59 <EvanR> > forever (tell 1) :: Writer Int ()
09:48:01 <lambdabot>      No instance for (Monoid Int) arising from a use of â€˜foreverâ€™
09:48:01 <lambdabot>      In the expression: forever (tell 1) :: Writer Int ()
09:48:04 <spoing> quchen: thanks!
09:48:07 <EvanR> FFFFFUUUUUUUUU
09:48:24 <EvanR> a lazy monoid could work
09:48:28 <EvanR> if Writer is lazy enough
09:48:35 <quchen> > execWriter (forever (tell [()]))
09:48:37 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
09:48:40 <EvanR> good
09:49:05 <quchen> Now imagine Writer+State
09:49:23 <quchen> That's like a state machine that can report intermediate results.
09:49:30 <EvanR> if not written properly the >>='s would accumulate memory
09:49:33 <quchen> So it's not just IO.
09:49:47 <EvanR> i see that now
09:49:49 <quchen> I don't understand evaluation of Haskell good enough :-(
09:50:05 <EvanR> you can see how forever tell [()] can work by using graph reduction
09:54:22 <quchen> EvanR: I'm not as smart as GHC though
09:54:32 <quchen> So *my* stack might overflow, but GHC's doesn't have to
09:57:29 <OhTrueful> @pl \x y -> filter (geq y) x
09:57:29 <lambdabot> flip (filter . geq)
10:09:31 <obadz> foldl :: (b -> a -> b) -> b -> [a] -> b
10:09:33 <obadz> foldl f x0 xs = foldr (flip f) x0 (reverse xs)
10:09:40 <obadz> is this a valid way to write foldl in terms of foldr?
10:09:54 <obadz> https://wiki.haskell.org/Foldl_as_foldr â‡ it's done here differently
10:12:36 <quchen> obadz: Well, you're using 'reverse', which is itself a fold already, so your definition is a bit cyclic.
10:13:06 <quchen> ?src reverse
10:13:06 <lambdabot> reverse = foldl (flip (:)) []
10:13:29 <obadz> right I noticed that
10:14:35 <obadz> I guess I failed the exercise I had set out for myself
10:15:40 <quchen> obadz: foldl in terms of foldr is a pretty hard exercise if you ask me
10:16:05 <quchen> And it's still a small puzzle after years of Haskell to write it down from scratch (because I always forget it)
10:16:22 <obadz> makes me feel better
10:16:32 <obadz> now I'm trying to do it after having glanced at the solution
10:17:12 <quchen> obadz: This might be a helpful intermediate step: https://github.com/quchen/articles/blob/master/useful_techniques.md#bouncy-folds
10:17:25 <obadz> yay I did it :)
10:17:26 <quchen> obadz: It allows you to hold state in a foldr
10:17:34 <quchen> And foldl's "state" is the accumulator
10:17:37 <quchen> Congrats :-)
10:17:51 <quchen> What's your solution?
10:17:58 <obadz> foldl''' f x0 xs = foldr'' (\ x g p' -> g (f p' x)) id xs x0
10:18:06 <quchen> That looks right
10:18:08 <quchen> :t \f z xs -> foldr (\y ys acc -> ys (f acc y)) id xs z
10:18:10 <lambdabot> Foldable t => (a1 -> a -> a1) -> a1 -> t a -> a1
10:18:21 <obadz> I saw that the solution had id as the inital state
10:18:33 <obadz> and 3 arguments to the inner function
10:18:38 <obadz> worked out the rest of the puzzle
10:18:40 <quchen> id isn't initial in any way here
10:18:47 <quchen> It's the last thing that is evaluated
10:19:04 <obadz> quchen: ok terminal state
10:19:08 <obadz> whatever you want to call it :)
10:19:16 <quchen> I wouldn't call it state in the first place
10:19:36 <obadz> it's the second argument of foldr, what else would you call it?
10:19:45 <obadz> endofunctorish state :)
10:20:02 <quchen> It doesn't change, it's not applied repeatedly.
10:20:18 <quchen> You could call it "the final state transition function", but I don't think that's very helpful.
10:20:31 <obadz> ok foldr's second argument is a terminal argument then?
10:20:36 <quchen> I call foldr's second argument "foldr's second argument" ;-)
10:20:52 <obadz> the plug at the end of the chain
10:20:54 <quchen> Maybe "base value" or something. Depends on the context.
10:21:14 <quchen> I haven't heard a good name for it yet
10:21:44 <ggole_> I think of it as [] replacement
10:21:57 <quchen> That's correct, but not a good name ;-)
10:22:14 <ggole_> Names are hard.
10:22:22 <quchen> "foldr takes a walker function and a nil replacer" :-D
10:23:25 <ggole_> "foldr takes a cons replacer and a nil replacer" isn't such a bad explanation of the arguments
10:23:49 <ggole_> ...at least, not if you already know what foldr does
10:28:09 <quchen> ggole_: It's correct, but completely unhelpful.
10:28:33 <quchen> And in terms of correct, but completely unhelpful, and entertaining, that #1 spot is taken by the fishy monad tutorial.
10:30:31 <ggole_> I don't think knowing about the correspondence between the arguments to foldr and the constructors of list is unhelpful.
10:31:07 <ggole_> In general, that is - probably doesn't do much for the sucker trying to implement foldl
10:31:22 <monochrom> I think the only possible reason why "foldr takes a cons replacer and a nil replacer" is possibly unhelpful is that it is terse and it could use an example.
10:31:47 <ggole_> Yeah, it needs more exposition.
10:31:55 <ggole_> I think there was a talk about it?
10:33:22 <quchen> monochrom: foldr was one of the hardest things to understand for me in basic Haskell. I've read all the things, seen all the pictures, and still didn't "get" it.
10:33:33 <quchen> monochrom: So now I'm veeeery careful giving advice on it.
10:33:39 <quchen> For comparison, monads were much easier.
10:34:18 <quchen> So I eagerly tell people what monads are and how to picture them ;-P
10:34:35 <xa0> really?
10:35:08 <quchen> xa0: Was that directed at me? If yes, then yes, really.
10:35:21 <xa0> how strange
10:35:22 <quchen> Except the part with the winking smiley, that one not really.
10:35:25 <monochrom> I surely had my own old days of struggling with foldr. but at the end two perspectives did me in.
10:35:28 <xa0> lol
10:35:40 <narendraj9> Installing haskell-platform doesn't install cabal. Why is that?
10:37:16 <monochrom> one perspective is, on intuitive days, an example like "foldr (#$) z [1,2,3] = 1 #$ (2 #$ (3 #$ z)" which is exactly the nil-replacer, cons-replacer story, except we recognize that a few symbolic examples are worth a thousand slogans.
10:38:07 <quchen> monochrom: I think it's key to realize that foldr doesn't consume the entire list, and repeat and stress that a thousand times.
10:38:24 <monochrom> the other perspective is, on logical days, the theorem: f = foldr (#$) z iff for all x and xs, f [] = z, f (x:xs) = x #$ f xs
10:38:34 <quchen> Picture Bart at the black board writing "foldr is not tail recursive and that's important"
10:40:38 <ggole_> Maybe lists are the wrong data structure to explain folds.
10:41:06 <ggole_> Because the number of arguments happens the same between foldr and foldl, inviting confusion.
10:41:13 <ggole_> *happens to be the same
10:42:46 <quchen> Foldable is much easier to explain: "It provides toList along with some convenient definitions". But that requires the student to know about list folds already.
10:43:43 <quchen> It's not exactly right, but for most practical purposes it's pretty good. (It fails on data structures that are naturally traversed from right to left, for example, because foldr/foldl may have switched roles in that case.)
10:44:31 <aerialB> https://gist.github.com/TiredSounds/4dcd8aaaad7ffc8a1961 I've written this function to flatten a nested list. Could someone give me point me in the right direction for writting a version which works on arbitrarily nested lists? I don't want the answer though :)
10:44:52 <aerialB> (sorry, typos)
10:45:01 <ggole_> aerialB: but Haskell lists are not arbitrarily nested
10:45:05 <aerialB> oh?
10:45:20 <quchen> aerialB: "Arbitrarily nested Haskell lists" aren't well-typed. You have to write your own type for representing that.
10:45:28 <ggole_> What would the type of a nested list be?
10:45:35 <bollu> quchen: I think Free would work?
10:45:36 <aerialB> [[a]]
10:45:50 <aerialB> for one level of nesting
10:46:01 <quchen> bollu: Yes, but that's not a list anymore, it's some tree-shaped structure. When hearing "list" I think of [] and (:).
10:46:12 <quchen> That's what I meant with the "own type".
10:46:24 <bollu> Free f a = Roll f (Free f a) | Pure a right? I always screw up constructing Free
10:46:27 <quchen> data List a = Nil | Cons a (List a) | Nested (List (List a)) -- should work, for example
10:46:28 <bollu> quchen: ah right, understood
10:46:35 <monochrom> you can use [[a]] if you want exactly one level of nesting.
10:46:35 <aerialB> So [[[a]]] would be considered an abuse of lists?
10:46:36 <ggole_> Instead, you should probably write something like data Sexp a = Nil | Atom a | Cons (Sexp a) (Sexp a) and then flatten that
10:46:36 <quchen> Hooray polymorphic recursion
10:46:51 <monochrom> you can use [[[a]]] if you want exactly two levels of nesting.
10:46:59 <bollu> aerialB: no, but that does not give you *arbitrary* nesting
10:47:12 <bollu> it feels so weird that a year ish back I didn't even understand what Functor was
10:47:12 <shlomo> sp
10:47:29 <bollu> ny god humanity is *awesome* :D
10:47:37 <monochrom> you can define "data X a = Zero [a] | One [[a]] | Two [[[a]]]" if you want 0, 1, or 2 levels of nesting.
10:48:30 <aerialB> I understand. But do you kind of see what I mean? Isn't it possible to write a recursive function which stops when the type is [a] instead of [[a]]? This is just for my own experimentation of course.
10:48:50 <ggole_> aerialB: are you doing that 99 problems thing?
10:48:52 <monochrom> it is possible in untyped languages such as PHP
10:49:05 <aerialB> Nope, I'm just fooling around :)
10:49:10 <monochrom> in which you can, at run time, ask "what is the type of my parameter?"
10:49:25 <monochrom> but there is no such runtime information in Haskell
10:49:31 <aerialB> I see
10:49:40 * exio4 hands monochrom some Typeable and hides again
10:49:54 <ggole_> That's why you use a data type that indicates the structure of the list
10:50:25 <quchen> exio4: That's the equivalent of saying that you could use only String in Haskell.
10:50:43 <bollu> 	how do I give my module itself some documentation in Haddock?
10:50:46 <bollu> like, the way lens does
10:50:52 <ggole_> The one I suggested is close (well... sort of) to the structure of terms in languages like Lisp or Prolog
10:50:53 <monochrom> exio4: in fact, you could just hand me some OverlappingInstances and that could do it
10:51:01 <bollu> https://hackage.haskell.org/package/lens
10:51:02 <quchen> bollu: You can write Haddock comments before "module"
10:51:04 <bollu> I want that documentation
10:51:09 <bollu> quchen: ohh, I see :)
10:51:13 <quchen> bollu: Oh, that's in the .cabal file
10:51:23 <exio4> quchen: it's possible! nobody should do it, but it's possible!
10:51:35 <bollu> exio4: which one? :P 
10:51:37 <quchen> bollu: what you linked to is *package* documentation.
10:51:43 <aerialB> So if I understand, this boils down to this type of function just not fitting the philosophy of the language? I'm perfectly happy if that's the case. I'll continue writing some sorting functions instead :)
10:51:59 <bollu> quchen: right, I want that, along with the docs for things like this :https://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens.html
10:52:08 <exio4> aerialB: you just don't want to use lists but something else
10:52:15 <bollu> aerialB: yes, we want strong types that reflect your data
10:52:16 <exio4> bollu: which one what? :P
10:52:26 <bollu> exio4: like, at a module level :P
10:52:31 <monochrom> be GÃ¶del! use only natural numbers in Haskell!
10:52:44 <aerialB> So a tree? I've not worked with those yet
10:52:47 <quchen> bollu: The answer to that question is what I said earlier, "Haddock comment for 'module'".
10:53:01 <ggole_> aerialB: arbitrarily nested things are pretty much trees, yes
10:53:07 <aerialB> cool :)
10:53:09 <quchen> bollu: Look at the source of that module, it begins with "-- |", that's an ordinary Haddock block
10:53:16 <exio4> monochrom: data Nat = S !Nat | Z should be enough for everybody? 
10:53:19 <bollu> ohh, I see. Thanks!
10:53:38 <bollu> exio4: I'm not familiar with the !Nat syntax
10:53:45 <monochrom> it was certainly enough to prove incompletness :)
10:53:56 <bollu> exio4: and isn't that just Free Mybe a?
10:53:58 <quchen> exio4: data Nat = Z | S | SS | SSS | SSSS â€¦ -- pick as many as you need
10:54:00 <bollu> Maybe*
10:54:24 <bollu> quchen: ah, wait, that's haskell syntax?
10:54:33 <quchen> bollu: what?
10:55:00 <bollu> quchen: dat Nat = S !Nat | Z? The "!" is part of Haskell syntax?
10:55:13 <quchen> bollu: Yes, that's standard Haskell
10:55:13 <exio4> bollu: it's a "strictness annotation", S âŠ¥ = âŠ¥
10:55:40 <bollu> exio4: oh! I didn't realize you could give it at the type level. I've seen it used to force *values*
10:55:57 <Rotaerk> having a lot of trouble with understanding monadfix
10:55:58 <quchen> bollu: In patterns, it's a BangPattern, which is not standard Haskell
10:56:10 <Rotaerk> the [] implementation in particular is confusing the hell out of me
10:56:11 <bollu> hm, tell me this interacts badly with `sequence` or something :P I don't understand `sequence`
10:56:21 <quchen> On the ordinary value level, ! is a normal operator (Vector uses it I think?)
10:56:22 <exio4> er? give it at the type level?
10:56:35 <exio4> oh, I see.
10:57:19 <bollu> what's a decent lower and upper bound on base?
10:57:51 <quchen> bollu: 4 <= base < 5
10:58:07 <bollu> cool, thanks
10:58:17 <quchen> Narrow/expand as necessary. I don't think it matters that much, since base is pretty stable.
10:58:29 <quchen> Except the parts that are not as stable ;-)
10:58:51 <quchen> If you don't use experimental stuff, the version of base shouldn't matter much.
10:59:46 <bollu> thanks!
11:01:37 <Rotaerk> I guess I can understand basically *what* mfix is doing... in "mfix (\p -> x)", p becomes a sort of alias for x so that you can refer to the return value from within itself
11:01:41 <aerialB> Haskell's syntax is very intuitive I think. I'm not sure why people think it looks terse, when they're happy to use bash!
11:01:56 <Rotaerk> but the *how* of it, reading the implementation of instance MonadFix []... that's making my brain hurt
11:02:17 <bollu> I had a package uploaded as a candidate, but now I want to upload it "for real"
11:02:22 <bollu> it's not letting me upload my package
11:02:26 <bollu> what am I doing wrong?
11:04:05 * hackagebot symengine-hs 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/symengine-hs-0.1.0.0 (bollu)
11:04:07 <quchen> bollu: Click on "maintain"
11:04:10 <quchen> It's a tiny link somewhere
11:04:19 <quchen> Probably at the top of your package page
11:04:30 <quchen> There you can release it (or was it "publish"?)
11:04:54 <bollu> ohh thank you!
11:05:04 <bollu> ouch ouch ouch, I need to fix the templates
11:05:11 <bollu> aargh releasing a package is so stressful
11:05:11 <bollu> :(
11:05:20 <bollu> I don't know how you guys manage it
11:05:47 <quchen> Templates?
11:07:30 <xa0> c++ disguised as haskell
11:10:28 <Athas> Template Haskell is even nastier than C++.
11:10:35 <bollu> how do I login to hackage?
11:10:58 <sleblanc> I doubt bollu is talking about TH
11:11:03 <bollu> oh hm, so this is published?
11:11:03 <bollu> https://hackage.haskell.org/package/symengine-hs
11:11:13 <bollu> no, I was talking about the default stack template :)
11:11:19 <bollu> I gotta change the package description
11:11:28 <bollu> is this published? https://hackage.haskell.org/package/symengine-hs
11:11:29 <sleblanc> bollu, yes, see up there, a few lines above, hackagebot reported it
11:11:48 <sleblanc> (at 14:03:40)
11:12:04 <quchen> Template Haskell has nothing to do with C++ templates.
11:12:21 <bollu> crap
11:12:26 <bollu> hmm
11:12:33 <quchen> TH lets you talk about the Haskell syntax tree, and build it during compile time. C++ templates are a very poor version of parametric polymorphism.
11:12:34 <bollu> I need to be more careful in future
11:12:43 <bollu> I feel like a kid in a candy store or something. I'm inexperienced at this
11:12:53 <sleblanc> TH is similar to quasiquoting, right?
11:13:23 <quchen> sleblanc: Yes. Quasiquoting is based on TH.
11:13:28 <bollu> is there anyway to "hide" the IO that I incur from crossing the FFI?
11:13:43 <exio4> unsafePerformIO :)
11:13:43 <Clint> "yes"
11:13:45 <quchen> bollu: That's what unsafePerformIO is there for.
11:13:50 <bollu> like, my types will pay the penalty of IO Int or whatever just because they cross the border
11:13:51 <bollu> ooh, nice
11:13:52 <sleblanc> quchen, the notion of quasiquoting, or a data type / class Quasiquoting?
11:13:57 <bollu> :t unsafePerformIO
11:13:58 <lambdabot> Not in scope: â€˜unsafePerformIOâ€™
11:14:01 <exio4> IO a -> a
11:14:09 <bollu> heh, neat
11:14:15 <quchen> sleblanc: Well, quasiquoting means you're building Haskell from a string. That's a specialized use case of TH.
11:14:19 <bollu> okay, so, what are the guiding principles on this thhing?
11:14:22 <geekosaur> strictly speaking the FFI documentation says to use unsafeLocalState
11:14:27 <quchen> bollu: Step 1: BE CAREFUL
11:14:43 <quchen> Step 2: read unsafePerformIO's documentation closely
11:14:45 <bollu> quchen: how do I know when I'm breaking referential transparency and when I'm not?
11:14:45 <geekosaur> which is almost identical to unsafePerformIO (it avoids a step that is needed for actual IO but not for FFI)
11:14:54 <quchen> Step 3, make sure you understand GHC's evaluation model reasonably well
11:15:07 <bollu> quchen: I need a crash course on (3)
11:15:08 <quchen> geekosaur: Oh, I didn't know that!
11:15:23 <bollu> All I know is that IO ~ newtyped State monad
11:15:29 <bollu> and laziness
11:15:34 <bollu> do I need to know "more"?
11:15:52 <quchen> bollu: That's wrong already. IO is not "newtyped State".
11:16:16 <quchen> There is something called "State#" in IO, but it's not "that State monad you know".
11:16:21 <bollu> ohh, I see
11:16:23 <bollu> go on
11:16:29 <geekosaur> bollu, for FFI purposes you can use unsafeLocalState if the thing you are calling via FFI does not block and does not allocate or change process global state
11:16:45 <quchen> bollu: Here are some code locations to look at IO's implementation in GHC. https://github.com/quchen/articles/blob/master/fbut.md#where-is-io-defined
11:16:51 <bollu> geekosaur: is memory allocation considered as "allocation"?
11:16:57 <geekosaur> yes
11:18:06 <geekosaur> if it's allocatiung memory then you definitely do not want to "hide the IO"
11:18:24 <bollu> hm, okay
11:18:27 <sleblanc> geekosaur, does this include cases where all allocated memory is then released?
11:18:39 <bollu> yeah, if the memory is managed by a smart pointer
11:18:40 <bollu> ?
11:18:51 <bollu> so it looks like I need a deeper understanding of IO
11:19:04 <geekosaur> it does, because one of the risks is two things modifying C-level memory allocation pointers at the same time
11:19:07 <quchen> bollu: If you want to unsafePerformIO something, ask yourself whether it would be wrong to evaluate it 10000 times.
11:19:08 <geekosaur> (malloc is not reentrant)
11:19:11 <bollu> here's my GSoC application under SymPy - to create SymEngine bindings to Haskell
11:19:13 <bollu> https://github.com/sympy/sympy/wiki/GSoC-2016-Application-:-Haskell-Bindings-to-SymPy-Engine
11:19:23 <quchen> 10000 times malloc is bad.
11:19:27 <bollu> so I _need_ to know how to create "correct" FFI's
11:19:29 <bollu> quchen: right
11:19:49 <bollu> I could really use a mentor-like person on the Haskell side for the project
11:19:59 <bollu> doesn't have to be an official mentor, just someone whom I can ping to answer questions
11:20:03 <quchen> #haskell is that person.
11:20:10 <bollu> heh, I suppose :)
11:20:18 <bollu> but what if the timing is odd or something?
11:20:23 <bollu> I'm on UTC +5 30
11:20:25 <maerwald> finally someone trying to end the filepath madness https://hackage.haskell.org/package/path
11:20:33 <bollu> so not a lot of people are online when I'm up
11:20:42 <quchen> +2 here
11:20:48 <quchen> Wait, +1 right now
11:21:02 <maerwald> unfortunately it depends on the filepath package :/
11:21:44 <quchen> maerwald: Just because something depends on something broken doesn't mean it's broken itself. It might be a safe wrapper, for example.
11:21:52 <maerwald> I hope so
11:21:54 <monochrom> plate tectonics and continental drift are causing quchen to shift time zone by 1 hour every year :)
11:21:58 <bollu> quchen: right, so, could you go on about IO and FFI?
11:22:29 <nshepperd> huh? why would there be anything wrong with allocating things in something unsafePerformIO'd?
11:22:30 <quchen> bollu: I have nothing more to say, I didn't prepare a lecture :-| But I can try answering questions
11:22:53 <quchen> nshepperd: Allocating and then not deallocating is what we meant, I think.
11:23:14 <nshepperd> assuming you return the allocated memory some way or another
11:23:39 <bollu> quchen: hm, very well
11:23:49 <bollu> quchen: can I have references as to how IO works formally?
11:23:54 <bollu> I think I'm in for a hell of a ride
11:24:03 <quchen> nshepperd: Then you should probably do the entire thing in IO, wrap it with bracket so memory is freed, and then unsafePerformIO then
11:24:07 <quchen> s/then/that/
11:24:32 <nshepperd> why?
11:25:10 <quchen> Because the compiler can run pure values as often as it wants, and allocating twice but freeing once causes leaks.
11:25:31 <bollu> quchen: what to you mean "wrap it with brakcet"?
11:25:35 <quchen> :t bracket
11:25:36 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:25:47 <nshepperd> so how does runSTArray work then
11:25:49 <quchen> Haskell's "try/catch/finally"
11:26:39 <quchen> nshepperd: Good point, I don't know. Can you explain it?
11:27:21 <bollu> wait what? TIL
11:27:26 <bollu> that exists?
11:27:35 <quchen> bracket? It's super useful.
11:27:42 <quchen> Marlow's book has nice sections about exceptions.
11:27:45 <bollu> I don't think I quite understand it
11:27:47 <quchen> Maybe have a look at those.
11:27:48 <bollu> can I have an example?
11:28:11 <quchen> bracket (openFile "xxx") (\handle -> closeFile handle) (\handle -> doStuff handle)
11:28:16 <nshepperd> quchen: oh, maybe you're thinking of unsafeDupableIO?
11:28:53 <nshepperd> unsafePerformIO actuallly has guards to prevent it from being run twice in the same thunk iirc
11:29:05 <quchen> nshepperd: Oh! I did not know that.
11:29:08 <nshepperd> presumably runST does also
11:29:28 <quchen> IO = ST RealWorld, no?
11:29:30 <bollu> quchen: oh, okay. so it;s like a finalizer?
11:29:33 <quchen> So ST should have similar mechanisms
11:29:37 <nshepperd> yeah
11:29:40 <quchen> bollu: Exactly.
11:29:49 <quchen> bollu: "bracket before after thing" is the idiom.
11:29:57 <monochrom> alloca, withArray, withCString etc already does the bracket for you
11:30:08 <nshepperd> bracket is like "try { } finally { }" if you've ever used that
11:30:20 <quchen> The argument order is so you can write "bracket open close (\h -> ...)" conveniently, where "..." is the main work horse
11:30:38 <monochrom> unsafeDupableIO has a new name unsafeLocalState in Foreign.Marshal.Unsafe. its doc has sound advice.
11:31:20 <quchen> unsafeLocalState = unsafePerformIO without the "double" checking?
11:31:24 <bollu> quchen: what's your github picture a reference of? I don't understand - you're doing a closed loop integral with the loop as an exterior derivative? what are you integrating over?
11:31:30 <ggole_> :t bracket
11:31:31 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:31:38 <ggole_> Hmm
11:31:43 <ggole_> It's a bit like under
11:31:49 <quchen> bollu: It's Stoke's theorem (half of it), which was very influential for me.
11:31:58 <ggole_> Except all IOified
11:32:10 <quchen> bollu: https://en.wikipedia.org/wiki/Stokes'_theorem
11:32:17 <aerialB> https://gist.github.com/TiredSounds/01237534decf4405473d how could I modify this function so that :: (a -> a -> b) -> [a] -> [b] ?
11:32:26 <bollu> quchen: ahh, I didn't know there was such a "high level" generalization
11:32:29 <bollu> but of course there is one
11:32:43 <quchen> bollu: The lower-level version is 'mask'.
11:32:47 <bollu> isn't it nuts that all of vector calc works?
11:32:50 <quchen> But it's a bit more complicated.
11:33:02 <quchen> Marlow does a great job explaining it!
11:33:03 <quchen> :t mask
11:33:05 <lambdabot> ((forall a. IO a -> IO a) -> IO b) -> IO b
11:33:24 <bollu> quchen: I was referring to stokes' theorem as a generalization :)
11:33:33 <bollu> but I didn't know mask existed either
11:35:42 <sleblanc> aerialB, remove the case where reduceCouples handles a single-item list
11:36:15 <sleblanc> aerialB, if you remove the type definition, it becomes (t -> t -> a) -> [t] -> [a]
11:37:43 <aerialB> sleblanc: I see. So should I give an error in the case of a list of odd numbered length? As in reduceCouples _ [x] = error "foobar"?
11:38:24 <sleblanc> aerialB, or provide an alternative definition. You could make it a monoid and use mempty for instance
11:38:45 <aerialB> I haven't gotten to that point in my learning yet (monads, monoids etc)
11:39:49 <sleblanc> sticking to this seems the most logical. You will have to ensure the list has at least two items to make it safe
11:40:44 <aerialB> sleblanc: Sounds good, thanks
11:41:03 <bollu> is there a command line way to push to hackage from stack?
11:41:18 <bollu> oh cool, "stack upload"
11:41:36 <bollu> hm, "FailedConnectionException2 "hackage.haskell.org" 443 True getAddrInfo"
11:42:18 <srhb> bollu: What a useful error message.
11:42:20 <sleblanc> aerialB, as an alternative, you could also write your function so it accepts a list of tuples instead, and write a second function that converts a standard list into such a list
11:42:33 <Athas> Stack seems to compile slightly faster than Cabal.  (For quick rebuilds.)
11:43:00 <bollu> srhb: that's what stack gave me, unfortunately :/
11:43:09 <bollu> Uploading symengine-hs-0.1.1.0.tar.gz... FailedConnectionException2 "hackage.haskell.org" 443 True getAddrInfo: does not exist (nodename nor servname provided, or not known)
11:43:12 <srhb> bollu: Yes, it's the raw value from http-client
11:43:24 <sleblanc> > let myZip (x:y:xs) = (x,y) : myZip (y:xs)
11:43:26 <lambdabot>  <no location info>:
11:43:26 <lambdabot>      not an expression: â€˜let myZip (x:y:xs) = (x,y) : myZip (y:xs)â€™
11:43:32 <bollu> srhb: any ideas why this is screwing up?
11:43:36 <srhb> Athas: Peculiar.
11:44:07 <quchen> ?let myZip (x:y:xs) = (x,y) : myZip (y:xs)
11:44:08 <lambdabot>  Defined.
11:44:09 <quchen> sleblanc: ^
11:44:15 <quchen> > myZip [1..10]
11:44:15 <sleblanc> yee-haw!
11:44:17 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)*Exception: /tmp/muev...
11:44:22 <sleblanc> oops!
11:44:26 <quchen> Yup :-)
11:44:26 <sleblanc> :t myZip
11:44:28 <lambdabot> [t] -> [(t, t)]
11:44:32 <quchen> > myZip [1,2,3]
11:44:33 <aerialB> sleblanc: oh!
11:44:34 <lambdabot>  [(1,2),(2,3)*Exception: /tmp/mueval21139038817684930.hs:160:1-46: Non-exhaus...
11:44:35 <srhb> bollu: Nope.
11:44:38 <quchen> Non-exhaus...
11:44:46 <bollu> hm, shall I create an issue on stack?
11:44:50 <quchen> sleblanc: Write your definition in GHCi with -W enabled
11:44:58 <quchen> :set -W    <--- the command to do that
11:45:01 <srhb> bollu: If for no other reason than the error message is horribad, yes :P
11:45:03 <sleblanc> ok
11:45:08 <srhb> bollu: If you have the newest version anyway :)
11:45:17 <sleblanc> quchen, wow, cool stuff. thanks
11:45:24 <quchen> :-)
11:45:26 <Athas> srhb: I suppose the metadata gathering phase is just faster.
11:45:41 <Athas> I still would like it if Stack would link in parallel.  That would really speed things up.
11:46:17 <srhb> Athas: Isn't that a ghc option?
11:46:23 <sleblanc> I knew that my function was ill-defined; my intention was to shift the responsability of handling 1-item lists from aerialB's function to a separate function out of aerialB's problem's domain 
11:46:33 <bollu> srhb: yeah, I think I do 
11:46:46 <sleblanc> time to edit my .ghci!
11:46:47 <Athas> srhb: not linking, no.
11:46:53 <bollu> quchen: -W does?
11:47:16 <srhb> Athas: How can it not be? It's ghc --make that does the linking, is it not?
11:47:20 <quchen> bollu: Enables warnings
11:47:24 <srhb> That is, not Stack.
11:47:35 <Athas> srhb: yes, but GHC is only asked to produce one executable at a time.
11:47:41 <srhb> Athas: Ah, yes.
11:47:49 <Athas> I think the Stack-side solution would just be to invoke several GHCs concurrentely.
11:47:51 <quchen> bollu: In case of sleblanc's code there's an non-exhaustive pattern, which generates such a warning
11:48:01 <bollu> oh, neat!
11:48:27 <srhb> Athas: I suppose. Building with cabal + nix is faster for most cases anyway, I only use Stack for distribution.
11:48:38 <bollu> srhb: issue - https://github.com/commercialhaskell/stack/issues/1877
11:49:22 <Athas> srhb: "most cases"?  I worry about one case mostly, where I have a large-ish Haskell program producing half a dozen executables, and I need to rebuild after making a small change in a single file.  That is my normal workflow.
11:49:36 <Athas> Stack is still pretty damn slow, but about twice the speed of cabal-install, it seems.
11:50:00 <srhb> Athas: I don't know what the result would be there. That's certainly not a use case I see a lot. :)
11:50:16 <Athas> srhb: do others stick to testing in ghci?
11:51:25 <bollu> in what module would something like SymEngine fit?
11:51:32 <bollu> it's bindings to SymPy
11:51:34 <srhb> Athas: I don't think so, but I've never seen that many executables for testing, either. Anyway, it would be nice to know which solution is faster in that case, too. :)
11:52:04 <ontop> Can anyone explain to me ByteString vs String vs Word8 etc and why I want them?
11:52:33 <shapr> :t String
11:52:35 <lambdabot>     Not in scope: data constructor â€˜Stringâ€™
11:52:35 <lambdabot>     Perhaps you meant one of these:
11:52:35 <lambdabot>       variable â€˜tryingâ€™ (imported from Control.Exception.Lens),
11:52:39 <shapr> hrm
11:52:43 <Athas> You want ByteString if you work with binary things, you never want String, and you want Word8 when you want a single byte.
11:52:45 <bollu> ontop: String - linked list of Char. ByteString - deal with bytes. Data.Text - sane strings
11:53:10 <ontop> Sane strings meaning?
11:53:20 <ontop> UTF8 encoded or something?
11:53:34 <bollu> ontop: no, um, performant is the right word I suppose :)
11:53:40 <ontop> Fair.
11:53:53 <bollu> is Data.Symengine an okay space to take up for a module?
11:53:53 <Athas> The Haskell String type has an overhead of something like 1600% in memory usage compared to a packed ASCII string.
11:54:00 <ontop> Oh wow.
11:54:01 <Athas> And its CPU behaviour is even worse, if you can imagine it.
11:54:02 <ontop> Why?
11:54:06 <ontop> Because it's a real list?
11:54:08 <Athas> It is a linked list of characters, yeah.
11:54:14 <ontop> Yikes. Okay. I understand.
11:54:18 <Athas> Each Char is a heap-allocated thunk, and so is every cons in the list.
11:54:19 <aerialB> sleblanc: The issue here is what do I want to do with an odd length list? Discard the last element? Include it untouched? I'm not sure which would make more sense as I have no use for it yet.
11:54:28 * hackagebot symengine-hs 0.1.1.0 - SymEngine symbolic mathematics engine for Haskell  https://hackage.haskell.org/package/symengine-hs-0.1.1.0 (bollu)
11:54:30 <ontop> So, how do I -use- the other ones? Do I say like "rofl" :: Data.ByteString?
11:54:47 <mauke> ontop: that works if you enable overloaded strings
11:54:47 <Athas> ontop: well, you don't use ByteStrings for text, you use Text.
11:55:06 <ontop> Well, the library I'm using wants a bytestring (for god knows what reasons, it's an oauth token, just a string)
11:55:06 <Athas> The Text type is really good.
11:55:20 <Athas> I think Text supports easy conversion to and from ByteStrings.
11:55:45 <ontop> I'm looking for like String -> ByteString
11:55:51 <ontop> But it looks like it's only Word8 -> ByteString :(
11:56:30 <ClaudiusMaximus> ontop: first use pack :: String -> Text, then encodeUtf8 :: Text -> ByteString  (both functions are in the text package)
11:56:39 <ontop> Ok.
11:56:41 <ontop> Thanks :)
11:56:46 <ontop> Data.Text?
11:56:49 <Athas> Yes.
11:57:10 <sleblanc> aerialB, if it makes no sense right now, I suggest you leave it undefined, then visit it later if you change your mind
11:57:32 <ontop> Thanks for the help guys.
11:57:38 <aerialB> sleblanc: yes, you're right.
11:57:39 <sleblanc> The thing is that your definition conflicts with the types you use. A [a] naturally has no constraint on the number of items it contains
11:58:10 <aerialB> so I should really make this about a list of tuples?
11:58:15 <aerialB> sleblanc: ^
11:58:33 <aerialB> the whole thing I mean
11:58:44 <sleblanc> if it makes sense, yes. So the problem of checking whether the list is valid is shifted to another function
11:59:17 <aerialB> That's probably foolproof. I'll do that.
12:00:11 <aerialB> *more
12:00:26 <sleblanc> but then, you will realize that you can make your function very general: reduceCouples f [(x,y):xs] = f x y : reduceCouples xs
12:00:35 <sleblanc> which reduces to applying f on each item of a list
12:00:52 <sleblanc> (uncurried)
12:01:36 <xa0> same as map (f . uncurry), right?
12:01:53 <xa0> er
12:02:12 <xa0> map (curry f) i mean
12:02:24 <sleblanc> xa0, yes!
12:02:47 <aerialB> sleblanc: well... You're right. Haha!
12:02:56 <aerialB> So I don't have to do anything :P
12:03:19 <sleblanc> lazy programming at its full extent
12:03:25 <aerialB> haha
12:03:36 <xa0> lol
12:07:11 <quchen> Hm, why is uncurry defined in terms of fst/snd, and not pattern matching? http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.Tuple.html#uncurry
12:08:00 <quchen> I don't see how this affects strictness of the function, but that seems the only valid reason to do something like that
12:08:10 <horatiohb> When trying to add a local package by 'cabal sandbox add-source', the add-source itself works fine, but the subsequent install fails, complaining that it can't find the add-sourced module. Any ideas?
12:08:20 <Athas> quchen: probably a style issue.
12:08:22 <sleblanc> quchen, probably because since fst and snd are defined right above, it removes some redundancyâ€¦
12:08:29 <quchen> Ah, nevermind.   uncurry f âŠ¥ is well-defined if f ignores its argument.
12:08:30 <Athas> Much old Haskell code is written in an odd style.
12:08:34 <quchen> arguments*
12:09:05 <quchen> So the pattern matching approach is more strict indeed.
12:09:20 <sleblanc> oh, interesting
12:09:28 * hackagebot reflex-orphans 0.1 - Useful missing instances for Reflex  https://hackage.haskell.org/package/reflex-orphans-0.1 (davean)
12:10:37 <sleblanc> dealing with âŠ¥ is so tricky. Is there crash-course material on this? I know a few rules of thumb, like avoiding non-exhaustive pattern matches
12:11:09 <Athas> quchen: one could use an irrefutable pattern, yes?
12:11:19 <quchen> Yes, that should work.
12:11:57 <scshunt> sleblanc: try to avoid introducing it into your program!
12:12:17 <quchen> sleblanc: It's not just about crashing behaviour. Things that aren't strict in an argument defer its computation longer, avoiding unnecessary work in the best case.
12:13:54 <quchen> sleblanc: Consider uncurry. `uncurry (\_ _ -> ()) expensive` reduces to () immediately. If we had used pattern matching, we'd have to evaluate `expensive` enough to find out whether it's âŠ¥ or not.
12:14:07 <quchen> So the lazy version saves us from doing this unnecessary work.
12:21:13 <aerialB> Is it right that uncurrying turns Haskell type functions into the traditional type seen in other languages? foo (bar,baz) is the analog of foo(bar, baz)?
12:22:12 <quchen> aerialB: Yes, you could say that.
12:23:13 <aerialB> quchen: awesome :)
12:39:00 <elpetrero> I am new to network/socket programming. How do I decide which is the correct protocol number when calling 'socket'?
12:39:29 * hackagebot type-unary 0.3.0 - Type-level and typed unary natural numbers, inequality proofs, vectors  https://hackage.haskell.org/package/type-unary-0.3.0 (ConalElliott)
12:39:43 <elpetrero> I think it is causing my error between those two lines
12:40:01 <elpetrero> http://lpaste.net/154081
12:42:36 <levi> What error do you get?
12:45:09 <elpetrero> freeze of the main app, it's irc-core
12:47:43 <elpetrero> maybe I should forkIO a thread to do this
12:48:47 <levi> What happens if you try to connect to the address via some other means?  Is it actually reachable?
12:49:37 <elpetrero> well the other adress it is mine, I am launching this DCC commands from the same machine through freenode
12:49:59 <elpetrero> so yeah, the adress should be valid. I printf-style say they were on the code also
12:53:08 <elpetrero> so I am also slack1256, when I do the dcc command to send something
12:54:17 <slack1256> well at least with forkIO it didn't crash, so good on that front
12:54:29 <slack1256> Now I need to actually send the data :-)
13:22:38 <ontop> Hey guys. How in the world do I make an ID for Github.Data.PullRequests.PullRequest using this http://haddock.stackage.org/lts-5.5/github-0.14.1/GitHub-Data-Id.html ?
13:22:49 <ontop> It says it's a smart constructor, and wants some proxy entity type, I have no idea how to win here :(
13:25:52 <gigglypuff> Quick question: Why should I read books when there's such a dedicated Haskell following on IR willing to answer my questions in a much more succinct, cut and dried manner than any book?
13:26:00 <gigglypuff> *IRC
13:26:05 <MitchellSalad> ontop: ah, you can pass e.g. a Proxy from Data.Proxy
13:26:13 <MitchellSalad> or just use the Id constructor directly
13:26:21 <MitchellSalad> since it's exported
13:27:21 <marchelzo> gigglypuff: 1. you may not know which questions to ask. books are more structured. 2. people will get sick of answering the same questions from different people over and over again, and refer them to books.
13:27:47 <MitchellSalad> ontop: you good?
13:29:46 * hackagebot reflex-orphans 0.1.0.1 - Useful missing instances for Reflex  https://hackage.haskell.org/package/reflex-orphans-0.1.0.1 (davean)
13:30:11 <ontop> MitchellSalad: Hmm.
13:30:17 <ontop> Data.Proxy?
13:30:21 <ontop> Want to see what's in there
13:30:53 <MitchellSalad> ontop: actually, I looked at the PullRequest type you referred to, and I don't see an Id in there anywhere
13:31:14 <ontop> I'm using the function Github.Endpoints.PullRequests.pullRequest'
13:31:15 <MitchellSalad> but, if you need an "Id Foobar" for example, just use the Id constructor.
13:31:17 <ontop> And it wants an id.
13:31:54 <MitchellSalad> ah
13:31:56 <tufflax> Anyone use Vim? My `.` turns into question marks in boxes, see http://i.imgur.com/uu1Iiep.png Why?
13:32:14 <MitchellSalad> ontop: so pass it an id =)
13:32:21 <ontop> I'm trying to make one :(
13:32:29 <ontop> But this mkId thing is in my way.
13:32:37 <MitchellSalad> the Id constructor has type: Id :: Int -> Id a
13:32:44 <MitchellSalad> in your case, Id :: Int -> Id PullRequest
13:32:52 <ontop> Oh?
13:33:07 <MitchellSalad> yes, that's what i kept saying :D
13:33:12 <ontop> Where do you see that though?
13:33:18 <slack1256> tufflax: font? windows cli? not very related to haskell though.
13:33:19 <MitchellSalad> in the definition of the Id newtype
13:33:23 <ontop> The constructors: Id Int
13:33:23 <ontop> ?
13:33:25 <slack1256> maybe better luck on #vim
13:33:29 <MitchellSalad> ontop: yup
13:33:31 <ontop> Hm.
13:33:39 <xa0> tufflax: made me laugh though, thanks
13:34:22 <ontop> MitchellSalad: I guess I got confused because Id PullRequest makes no sense to me.
13:34:30 <MitchellSalad> ontop: think of the Nothing constructor from the Maybe type. it will type check as any Maybe whatsoever - "Nothing :: Maybe Bool", "Nothing :: Maybe Int", etc
13:34:36 <tufflax> slack1256: not cli. Just though someone here might have had experience with it
13:34:47 <MitchellSalad> same idea here - "Id :: Id Foo", "Id :: Id Bar", they're all valid types, and can be made with the Id constructor
13:35:39 <MitchellSalad> ontop: makes no sense because?
13:35:44 <ontop> So basically I have: Id :: Id PullRequest?
13:35:58 <ontop> Haskell must be autoconverting it for me
13:35:58 <MitchellSalad> almost, Id :: Int -> Id PullRequet
13:36:06 <MitchellSalad> yep
13:36:33 <ontop> Oh I see
13:36:37 <ontop> newtype Id entity = Id Int
13:36:58 <ontop> So PullRequest is just an integer in this case?
13:37:16 <ontop> Id :: Int -> Id Int in reality.. it's just aliased in some way?
13:37:20 <MitchellSalad> PullRequest is just a meaningless tag, to add a little faux type safety 
13:37:27 <ontop> Right.
13:37:32 <ontop> Ok, that's making more sense now.
13:38:13 <MitchellSalad> it lets you make an Id PullRequest in a type-unsafe way once, and then you can't ever pass it into a function that expects an Id Issue, for example
13:38:20 <MitchellSalad> even though they're both Ints
13:38:46 <ontop> Right.
13:38:57 <ontop> The only confusing part is.. I don't understand where the aliasing is actually done.
13:39:35 <ontop> It seems like using this function, I could make an ID of any type in the world
13:39:55 <MitchellSalad> you can
13:40:06 <MitchellSalad> what aliasing?
13:40:29 <ontop> Well. I guess I'm still confused exactly what the newtype is doing. I should look at my book some more I think.
13:40:54 <ontop> But first, I have to finish this ugly program!
13:40:56 <ontop> Thank you!
13:41:22 <MitchellSalad> sure. the newtype is just giving a different type to Int; nothing more.
13:41:42 <elpetrero> to not pass wrong arguments to wrong functions inside your programs
13:41:50 <elpetrero> the most bare use of newtypes
13:41:58 <ontop> Right.
13:42:34 <slack1256> l
13:55:16 <ontop> What's the cool way to rip off Maybe/Either from a list of Maybe/Either?
13:55:32 <ontop> Like I've verified I only have [Right X], now I want [X]
13:55:41 <ontop> I could build a function for this, but it feels like there's already a way.
13:57:09 <ontop> I found it ^_^ Hoogle wins.
13:57:24 <MitchellSalad> filter isRight
13:57:35 <MitchellSalad> or something
13:57:46 <MitchellSalad> map unRight
13:57:56 <MitchellSalad> no, neither of those
13:58:10 <MitchellSalad> some fold.
13:58:27 <ClaudiusMaximus> > rights [Left 9000, Right "ami"]
13:58:28 <lambdabot>  ["ami"]
13:59:29 <ontop> Yeah, I found rights from Data.Either
14:09:50 <subttle> hi, this may be wishful thinking but is there an extension to enable defining functions starting with an uppercase (I'm not even sure it's totally possible for the compiler to disambiguate?)
14:11:00 <sleblanc> subttle, I don't think you can. https://stackoverflow.com/questions/26938802/how-can-i-define-functions-in-haskell-using-uppercase-letters
14:11:18 <subttle> sleblanc: ah, thanks!
14:11:29 <Cale> subttle: If a function's name starts with an uppercase letter, it is a data constructor
14:11:33 <sleblanc> If you need it to translate to another library with such function names, you could prefix them with an underscore
14:12:02 <Cale> subttle: This syntactic difference makes it easy to work out what things are variables brought into scope by patterns, and what things are being matched by the pattern.
14:12:33 <subttle> yeah, it's just I'm working with sets and it would be really nice if I could keep the name used in mathematics consistent with my naming in haskell :) Thanks everyone
14:18:47 <sleblanc> ontop, where you looking for sequence earlier? Removing rights and justs from a list?
14:18:59 <sleblanc> > sequence $ [Just 1, Just 2, Just 3]
14:19:00 <lambdabot>  Just [1,2,3]
14:19:04 <sleblanc> > sequence $ [Just 1, Just 2, Nothing]
14:19:06 <lambdabot>  Nothing
14:19:10 <ontop> Oh. That one is useful.
14:19:13 <sleblanc> > sequence $ [Left 1, Left 2]
14:19:14 <lambdabot>  Left 1
14:19:24 <sleblanc> > sequence $ [Right 1, Right 2, Right 3]
14:19:25 <lambdabot>  Right [1,2,3]
14:19:28 <sleblanc> > sequence $ [Right 1, Right 2, Right 3, Left 1]
14:19:30 <lambdabot>  Left 1
14:19:35 <ontop> Interesting.
14:19:44 <ontop> Yeah, that's exactly what I wanted.
14:19:45 <nitrix> Gives all the rights or the first left.
14:19:56 <ontop> Sounds like the function I wrote
14:19:56 <sleblanc> sequence, with [Either a b], returns all bs, or the first a if there is an "error"
14:19:59 <ontop> getFirstFailure
14:20:01 <ontop> :|
14:20:13 <sleblanc> In the "error", "valid" sense of Either a b
14:20:45 <nitrix> Maybe works the same way. All the `Just` values; unless there's a Nothing, in which case you get Nothing.
14:21:05 <sleblanc> Yeah, in this sense, Maybe acts as a generic "no-message" error
14:21:12 <nitrix> I wonder what it does on tuples.
14:21:27 <sleblanc> sequence $ [(1,2), (2,3)]
14:21:32 <sleblanc> > sequence $ [(1,2), (2,3)]
14:21:34 <lambdabot>      No instance for (Show t0)
14:21:34 <lambdabot>        arising from a use of â€˜show_M238584317509325431529205â€™
14:21:34 <lambdabot>      The type variable â€˜t0â€™ is ambiguous
14:21:56 <ontop> So. I have a function I'm trying to make, it has an IO x and I want to return an x
14:22:02 <ontop> Is this possible or does this ruin the IO monad?
14:22:03 <sleblanc> sequence $ (1,2)
14:22:08 <sleblanc> > sequence $ (1,2)
14:22:09 <lambdabot>      No instance for (Show (m0 (t0, a0)))
14:22:09 <lambdabot>        arising from a use of â€˜show_M604770444562269736429230â€™
14:22:09 <lambdabot>      The type variables â€˜m0â€™, â€˜a0â€™, â€˜t0â€™ are ambiguous
14:22:17 <Rotaerk> Cale: I'm using the "try reflex" thing; pretty neat what it can do...
14:22:18 <geekosaur> if you need to do IO then it must be in IO
14:22:28 <nitrix> ontop: You theorically cannot escape the IO type.
14:22:29 <ontop> Aha. So then how can I pull args out if it has to be an IO thing
14:22:30 <geekosaur> ontop, it sounds like you need to learn how to work with IO
14:22:31 <Rotaerk> Cale: I'm not really clear what browser it's running though, when I compile to a binary, and run that
14:22:35 <ontop> geekosaur: Learning :(
14:22:54 <geekosaur> you can't make the IO go away. you *can* lift pure code into IO.
14:23:02 <geekosaur> since main :: IO a, you always start out in IO
14:23:05 <nitrix> ontop: You typically use IO as a functor, applicative or monad, by feeding it the function that you want to perform the on monadic value.
14:23:08 <nocturne777> I wonder if I should go simply with postgresql-simple instead of "persistent + esqueleto"
14:23:21 <nitrix> ontop: The function will be applied, but the monadic context (IO) will still be preserved.
14:23:29 <geekosaur> perhaps explain what you are trying to do in a bit more detail?
14:23:31 <nocturne777> this template stuff looks strange in persistent
14:23:52 <nitrix> ontop: Showing your code or looking at the type signature of (>>=) could help.
14:23:54 <ontop> Well, basically I have something that looks like: IO (Either a b) -> IO (), and I just want to print a (the error) or b (the value)
14:24:03 <ontop> But I don't know how to pattern match
14:24:05 <ontop> With IO in the mix
14:24:17 <ontop> It tells me it can't find the IO constructor.
14:24:28 <nitrix> I don't think IO has a constructor, does it?
14:24:34 <ontop> I guess not :D
14:24:50 <ontop> So how do you pattern match on that? Or can you just not?
14:25:06 <MitchellSalad> either_a_b <- action
14:25:10 <nitrix> ontop: Have you read what I took the time to write for you?
14:25:36 <ontop> nitrix: Yes. But I couldn't understand it.
14:25:38 <sleblanc> ontop, IO has no constructor (it's hidden deep inside GHC internals; good thing) so you can only "type match" against it, no pattern
14:26:02 <geekosaur> ontop, you don't pattern match against IO. you use <- in do syntax, or you use >>=
14:26:08 <ontop> Ok.
14:26:12 <nitrix> getLine >>= \x -> putStrLn $ "Hi " ++ x
14:26:12 <sleblanc> The only way to extract an IO value is to bind it in a "do" syntax expression
14:26:16 <MitchellSalad> ontop: (>>=) :: IO (Either a b) -> (Either a b -> IO ()) -> IO ()
14:26:19 <sleblanc> what geekosaur said
14:26:48 <nitrix> I'd recommend learning >>= first, as <- is just syntaxic sugar for >>=.
14:27:04 <ontop> nitrix: I've seen it. I think I've done something that tripped me up quite badly though.
14:27:17 <ontop> Essentially I've ended up with an [IO (Either a b)]
14:27:22 <ontop> And I wanted to do things to that
14:27:30 <MitchellSalad> sequence :: [IO (Either a b)] -> IO [Either a b]
14:27:33 <sleblanc> ontop, not too bad, you can sequence them too
14:27:38 <ontop> Oh. Wow.
14:27:40 <sleblanc> :-)
14:27:41 <ontop> That fixes EVERYTHING.
14:27:42 <ontop> Thank you.
14:27:57 <sleblanc> looks like what you needed to learn today was `sequence`
14:28:36 <ontop> Well, it's sure helped.
14:28:38 <ontop> What a handy function.
14:29:20 <ontop> nitrix: Thanks for trying btw. I'm still a bit thick-skulled at this stuff :(
14:29:43 <ontop> Oh. mapM actually helped too.
14:29:48 <ontop> This linter is so sick.
14:29:49 <MitchellSalad> you can write it yourself, too: sequence [] = return []; sequence (m:ms) = do { x <- m; xs <- sequence ms; return (x:xs) }
14:30:04 <ontop> sequence $ map (funcTHatReturnsIO) stuff
14:30:07 <ontop> mapM
14:31:17 <nitrix> :t sequence . map
14:31:18 <lambdabot> Traversable ((->) [a1]) => (a1 -> a) -> [[a1] -> a]
14:31:21 <nitrix> :t mapM
14:31:22 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
14:31:34 <nitrix> Oh not quite.
14:31:53 <MitchellSalad> :t sequence . fmap
14:31:55 <lambdabot> (Monad m, Traversable ((->) (m a1))) => (a1 -> a) -> m (m a1 -> a)
14:32:07 <nitrix> That's more like it :)
14:32:15 <MitchellSalad> i can't read that :P
14:32:16 <ontop> Ah.
14:32:29 <nitrix> MitchellSalad: It isn't as bad as it looks :)
14:32:52 <MitchellSalad> I'm pretty sure it is exactly as bad as it looks
14:33:27 <Rotaerk> MitchellSalad: which part throws you?
14:33:58 <MitchellSalad> no part in particular, I'm just saying this "combinator" is useless
14:35:18 <ontop> Is there any way to nicely concatenate Text? Or should I build it as a string and then pack it at the end?
14:35:30 <MitchellSalad> (<>)
14:35:36 <ontop> Oh right.
14:36:16 <ontop> Hm.
14:36:22 <ontop> Does that get imported from Data.Text?
14:36:37 <MitchellSalad> Data.Monoid
14:36:45 <ontop> Tyvm
14:37:30 <nitrix> > Sum 5 <> Sum 3
14:37:31 <lambdabot>  Sum {getSum = 8}
14:37:54 <sleblanc> How does it work, though? Hoogle does not say that Text has a Monoid instance: https://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text.html#t:Text
14:39:00 <Rotaerk> sleblanc: https://hackage.haskell.org/package/text-1.2.2.0/docs/src/Data-Text.html
14:39:30 <Rotaerk> sleblanc: search for monoid in that
14:39:49 <nitrix> instance Monoid Text where
14:39:53 <nitrix> mappend = append
14:40:43 <MitchellSalad> that is weird that the haddocks don't say it's a monoid
14:40:48 <ontop> I think I've done the worst thing in the world.
14:40:52 <ontop> Like
14:40:54 <ontop> The worst thing ever.
14:41:14 <MitchellSalad> ok... haha
14:41:16 <ontop> http://lpaste.net/7263621297693786112
14:41:19 <ontop> Please save me from this :(
14:41:30 <MitchellSalad> eh?
14:41:34 <geekosaur> if you haven't invented acme-php then probably not the worst thing :p
14:41:38 <ontop> pack pack pack pack pack pack...
14:41:38 <MitchellSalad> what do you need exactly?
14:41:46 <ontop> I just want to use Text because people told me to!
14:41:52 <MitchellSalad> you can turn on OverloadedStrings
14:41:58 <ontop> What's that?
14:42:00 <nitrix> MitchellSalad: It's getting confused by Data.Text.Internal
14:42:18 <Cale> Also, you could use  concatMap pack [list, of, strings]
14:42:21 <MitchellSalad> ontop: a language extension that lets you use string literals for a variety of types
14:42:43 <MitchellSalad> put "{-# language OverloadedStrings #-}" at the top of your file
14:43:05 <Cale> oh, sorry, the Text version of concatMap can't cope with that :P
14:43:51 <MitchellSalad> ontop: you could also just use String, even though it's inefficient, and blah, blah
14:43:53 <Cale> Well, you can  T.concat . map T.pack $ [list, of, strings]  anyway
14:44:41 <ontop> Hm.
14:45:25 <Shockk> ontop: in the way that integer literals in Haskell are polymorphic over the Num typeclass, using the OverloadedStrings extension makes string literals polymorphic over a typeclass called IsString
14:45:58 <Shockk> (as opposed to being of the rigid type String)
14:46:16 <nshepperd> foldMap T.pack?
14:46:23 <nitrix> IsString has a single method of type :: String -> a
14:46:38 <ontop> Shockk: Neat.
14:46:39 <nitrix> For example, using Clay, "#cc00000" can actually become a Color :)
14:46:49 <nshepperd> I wonder if that's better or worse performant than (pack . fold)
14:46:49 <nitrix> Instead of a String :)
14:47:12 <ontop> Is there an intersperse for list?
14:47:22 <MitchellSalad> yes, it's called intersperse
14:47:23 <Clint> :t intersperse
14:47:24 <lambdabot> a -> [a] -> [a]
14:47:31 <MitchellSalad> (Data.List)
14:48:00 <ontop> -_-
14:48:06 <nitrix> > intersperse 0 [1,2,3,4,5]
14:48:08 <ontop> Damn Prelude making me think it was useless.
14:48:08 <lambdabot>  [1,0,2,0,3,0,4,0,5]
14:49:10 <MitchellSalad> > intercalate [0,1,2] [[3,4,5],[6,7,8]]
14:49:12 <lambdabot>  [3,4,5,0,1,2,6,7,8]
14:49:50 * hackagebot repline 0.1.5.0 - Haskeline wrapper for GHCi-like REPL interfaces.  https://hackage.haskell.org/package/repline-0.1.5.0 (sdiehl)
14:53:34 <echo-area> How to prove if f :: forall a. a -> a, then f = id?
14:55:00 <marchelzo> i don't think you can
14:55:17 <hsk3> Why doesn't "cabal install --dep" also install dependencies listed under tests-suite ? It only seems to grab the ones from library.
14:55:42 <ontop> Yay I did it.
14:56:06 <ontop> http://lpaste.net/7263621297693786112
14:56:09 <ontop> It's still awful
14:56:12 <echo-area> marchelzo: Why?
14:56:15 <ontop> But feels more haskelly now.
14:56:27 <toby1851> this feels like an faq, but search hasn't turned up an answer: Couldn't match expected type â€˜Messageâ€™ with actual type â€˜Messageâ€™
14:56:28 <marchelzo> echo-area: f x = f x
14:58:59 <Cale> toby1851: How is Message defined? That looks like possibly a problem with the pretty printer. If Message is kind-polymorphic, maybe kind parameters to it are being obscured?
14:59:05 <echo-area> marchelzo: Is that the same as bottom?
14:59:34 <Cale> toby1851: I think whenever you get a message of that sort from GHC, it's valid to file a bug :)
14:59:52 <Cale> toby1851: It really ought to try hard to show you what the difference between the two types is.
15:00:02 <aerialB> So, what do I do with a `Maybe a`? I'm getting it from Data.List.find
15:00:09 <marchelzo> echo-area: I believe so
15:00:12 <toby1851> Cale: good point :) will do
15:00:25 <marchelzo> echo-area: so maybe you were right
15:00:38 <marchelzo> because that f is forall a b. a -> b, not forall a. a -> a
15:01:05 <aerialB> or rather `Just a`
15:01:55 <marchelzo> f x = f x `seq` x also has the type forall a. a -> a
15:02:40 <prashtx> anyone familiar with persistent-sqlite? i have a simple Scotty app that seems to run fine, but a basic hspec test apparently runs into some sort of timing or connection management issue
15:02:55 <prashtx> the gist of it is here: http://lpaste.net/8785369343568379904
15:03:07 <toby1851> Cale: to answer your first question, Message is a Persistent database table in a yesod project, so there's TH involved, and a fair few extensions
15:03:28 <toby1851> Cale: but it's been behaving perfectly for months, till i just now moved some code from one file to another
15:03:35 <Cale> hmm
15:03:42 <prashtx> Depending on how I try to connect and the type of db I try to create (:memory:, temp, explicit temp file), I'll get something like a StatementAlreadyFinalized error
15:03:53 <toby1851> Cale: i'll see if i can reproduce it in anything smaller
15:04:24 <prashtx> or else the migrations that were run in LD.bootstrap have disappeared
15:04:56 <prashtx> the latter seemed to happen when using a pool, I guess because the connection was getting closed and a new DB created
15:06:25 <adimit> if want to include the development version of, say, servant in a stack build, do I just put its directory in the stack.yml under packages?
15:07:18 <fr33domlover> adimit, there's a way to specify the git repo URL itself iirc
15:07:28 <fr33domlover> under 'packages'
15:07:43 <adimit> fr33domlover: oh, that'd be nicest.
15:07:57 <adimit> if I could also reference a specific commit that'd be awesomest.
15:08:13 <fr33domlover> adimit, but i don't remember exactly how, see the stack docs and hope they mention it :P
15:08:48 <fr33domlover> anyway worst case you can clone it manually and specify the path in 'packages' like you said
15:09:15 <fr33domlover> (i did the latter yesterday)
15:17:06 <dmwit_> aerialB: Pattern match on it.
15:17:42 <dmwit> toby1851: Is that the exact error? Often that error comes from having two versions of a single package involved and getting a version mismatch.
15:17:56 <dmwit> toby1851: But in that case GHC usually prints package version information in the error.
15:19:52 <dmwit> echo-area: See the paper "Theorems for Free!" by Phil Wadler.
15:19:56 <adimit> fr33domlover: found the syntax. it's -location: git: <url>\n    commit: <sha>. Next problem: servant's repository is actually several different packages. Now I need to reference *those*.
15:20:01 <dmwit> echo-area: This is a parametricity property.
15:20:51 <fr33domlover> adimit, possible too iirc by specifying the subdir
15:22:03 <adimit> fr33domlover: found it! subdirs.
15:23:20 <hsk3> Why doesn't "cabal install --dep" also install dependencies listed under tests-suite ? It only seems to grab the ones from library.
15:23:36 <dmwit> ?free a -> a
15:23:36 <lambdabot> Extra stuff at end of line
15:23:45 <dmwit> ?free f :: forall a. a -> a
15:23:45 <lambdabot> g . f = f . g
15:24:49 <adimit> fr33domlover: https://gist.github.com/adimit/e59f063288bf547dac1e â† the whole shebang. Thanks :-)
15:25:32 <adimit> now comes the problem that my app doesn't build with this new version of servant. Holy fundeps. ah, but that's solvable :-D
15:26:19 <dmwit> hsk3: I vaguely recall a bug on the cabal issue tracker about this.
15:26:21 <mcnster> greetings :) anyone know what version of llvm works with ghc-7.10.3?  i'm getting errors with 3.7.1....
15:26:29 <dmwit> hsk3: Does `--dependencies-only --enable-tests` work?
15:26:34 <aerialB> dmwit: thanks
15:26:54 <hsk3> dmwit: yeah, thanks!
15:31:08 <dmwit> mcnster: The download page mentions llvm 3.5.
15:31:15 <ontop> So, I've stumbled around looking for a way to print a list of things, one per line. With only built in stuff (I can do this with my own function but yeah..)
15:31:35 <ontop> Any sweet advice for that? Some sequence of monads or mapping printLnStr over something?
15:31:40 <dmwit> :t mapM_ print
15:31:41 <lambdabot> (Show a, Foldable t) => t a -> IO ()
15:31:51 <dmwit> :t \f -> mapM_ (putStrLn . f)
15:31:53 <lambdabot> Foldable t => (a -> String) -> t a -> IO ()
15:31:57 <ontop> That's pretty much exactly it. Thanks!
15:32:02 <fr33domlover> adimit, np. it was you, i didn't do anything :P
15:32:28 <dmwit> ontop: Are you MichaelAS on StackOverflow?
15:32:36 <ontop> I am not. Why?
15:32:48 <dmwit> Sounds very like a recent question of theirs.
15:33:00 <dmwit> Just curious whether it was the same or just coincidence.
15:33:07 <ontop> :D
15:33:30 <ontop> I ask questions here because the answers you get are insanely good compared to SO.
15:33:51 <dmwit> I'd be surprised about that. It's almost the same community of people answering here and there.
15:33:52 <adimit> fr33domlover: helps having someone to talk to :-P
15:36:07 <tomus> does haskell have green threads similiar to go?
15:36:14 <ontop> I suck so bad at this language. Man oh man. It just took me like 5 hours to write something it takes me 10 minutes to write in Go :(
15:36:16 <Sonarpulse> tomus: ...yes...
15:36:30 <Sonarpulse> ontop: learning curve don't worry
15:36:49 <maerwald> ontop: it's not really the same though
15:37:48 <ontop> maerwald: What do you mean?
15:37:55 <ontop> I mean, they're tools. I should be able to get better at this.
15:38:02 <ontop> After reading a 900 page book, and developing a few small things.
15:38:07 <ontop> You'd think I'd be starting to get the hang of it.
15:38:08 <ontop> lol.
15:38:35 <dmwit> Don't tell me what I would think!
15:39:11 <maerwald> ontop: I'm saying that if you have solved something in haskell you may get some benefits you don't get with e.g. Go
15:39:34 <dmwit> There are many skills required to write good Haskell code that are disjoint from the skills needed to write good code in mainstream languages.
15:40:18 <ontop> It's just kinda crazy. It seems like the breadth of knowledge required to do the smallest things is immense
15:41:01 <dmwit> That is true of mainstream languages, too.
15:41:11 <dmwit> You've just forgotten how broad your knowledge is because you've had it so long. =)
15:41:17 <ontop> This is totally possible.
15:41:17 <maerwald> dmwit: uhm, no
15:41:20 <tomus> has anyone pitted go vs haskell for concurrency. I've only just learned about green threads
15:41:48 <dmwit> tomus: Check the computer language shootout.
15:42:02 <dmwit> http://benchmarksgame.alioth.debian.org/
15:42:05 <maerwald> dmwit: I've hacked on an SMTP implementation that was written in javascript without knowing javascript at all. There was practically no learning curve. Not much of knowledge required
15:42:11 <maerwald> that's different with haskell
15:42:33 <ontop> Yeah. I dunno. It seems like everything I do requires a lot of learning.
15:42:35 <maerwald> haskell has more "concepts" than some other languages
15:42:43 <dmwit> maerwald: I dare you to claim that you have written in no language that is close to Javascript before that project.
15:43:20 <maerwald> it's still not the same
15:43:30 <ontop> Anyone know of a good tab writer library?
15:43:45 <dmwit> lilypad, perhaps?
15:44:13 <adimit> maerwald: imperative languages are basically the same. You know one, adapting to another one is easy. Haskell is difficult because you need to re-learn how to think about code in a strict functional paradigm.
15:44:20 <dmwit> Oops, I meant lilypond, not lilypad.
15:44:33 <maerwald> adimit: again, I don't think that's the only point
15:44:47 <maerwald> haskell has more concepts you gotta learn before you can do the same thing 
15:44:52 <adimit> so the learning curves are *relative*, not absolute. JS doesn't have a shallow one, and Haskell's, while steeper than most, isn't too far out there.
15:45:52 <adimit> maerwald: I think the biggest difference is that Haskell doesn't allow you to do things shoddily, whereas other languages (php, js) allow you to fudge details and cut corners.
15:46:23 <hpc> i was abandoned as a baby and wolves taught me to program
15:46:42 <Sonarpulse> hpc ha
15:47:08 <maerwald> adimit: I think the biggest difference is the amount of concepts you have to understand 
15:47:45 <dmwit> I would be curious to meet somebody who learned in the FP style first and moved to imperative programming second, and see to what extent it is a "first language first" thing and to what extent it is a "language vs. brain" thing.
15:47:50 <maerwald> in C you need to understand pointers... well... uh.
15:48:23 <shachaf> Cale: Well, it was better in context.
15:48:37 <dmwit> Until we have that kind of comparison, I think it's kind of hard to claim we know much.
15:49:20 <hpc> certain things make more intuitive sense than others
15:49:40 <hpc> and those intuitions map more or less correctly to the mechanics of each concept
15:49:53 <maerwald> dmwit: I think that makes literally no difference
15:50:03 <maerwald> because both styles don't have that much in common
15:50:07 <hpc> for instance, people struggle with C pointers
15:50:40 <hpc> because thinking about memory as a giant blob of bytes doesn't map easily to "i want to print a list of prime numbers"
15:50:53 <hpc> or whatever
15:51:13 <Rotaerk> adimit: haskell does let you do things shoddily though
15:51:26 <hpc> people struggle with IO because thinking about what (>>=) "actually does" hurts their brain
15:51:48 <Rotaerk> adimit: you could probably just do everything in the IO monad, and pretend you're using a procedural language
15:51:50 <adimit> Rotaerk: it's not shoddy by default to the extent php is, or, say java 1.4
15:52:03 <hpc> meanwhile at my high school everyone learned function composition through the guise of algebra
15:52:04 <maerwald> hpc: people struggle with IO, because all that semi-relevant purity talk of haskellers confuse them ;)
15:52:38 <Rotaerk> people tend to talk about IO as "the IO monad", but you don't need to understand monads in order to use IO
15:52:51 <Rotaerk> you can use it and just pretend the do blocks are a magical sub-language syntax
15:53:11 <dmwit> maerwald: I will be interested to see what evidence you have that there is no difference.
15:53:26 <maerwald> dmwit: didn't know this is a science battle
15:53:35 <dmwit> Now you know. =)
15:53:47 <hpc> the unfortunate thing about IO is that learning it correctly in all facets involves a ton of conceptual build-up
15:53:56 <hpc> and learning it easily takes shortcuts and lies to you
15:53:59 <ontop> ^
15:54:05 <hpc> with things like "do notation is for sequencing"
15:54:06 <kadoban> hpc: If that different than â€¦ anything?
15:54:55 <hpc> so there's a school of thought for each individual dependent concept of "this can be lied about" vs "this needs to be first" vs "this needs to be after Functor" vs ...
15:55:42 <hpc> and at the end of the day, you need a reasonable understanding of it to make your code compile
15:56:03 <hpc> with pointers, there's one explanation with very shallow conceptual build-up
15:56:44 <hpc> you have a long line of bytes and this pointer is a number that says "here's where it is in that line"
15:57:12 <davean> hpc: and yet, I very rarely talk to a profesional C programmer who can answer technical questions about pointers correctly
15:57:15 <hpc> you can go into how memory is laid out in blocks and virtualized and swapped and deduplicated
15:57:23 <davean> this is a common source of issues in C code
15:57:29 <hpc> but that's totally useless for using pointers
15:57:37 <hpc> until you get into hard stuff
15:57:59 <hpc> then it all falls down, because the concept of a pointer is false simplicity
15:58:09 <davean> Pointers, at least in C, are far more complicated then "a memory address"
15:59:06 <hpc> people generally begin their struggle with pointers by not knowing how to apply "list of bytes" to "store a string to integer hashmap"
15:59:37 <hpc> then they build their own understanding which gets absolutely demolished once they have to care about locality and whatnot
16:00:00 <hpc> but crucially, their false understanding of pointers doesn't use "list of bytes" at all either!
16:00:30 <hpc> usually it ends up being some kind of object/reference kind of logic, where what's past the end of the array is vacuous nothing
16:01:04 <davean> hpc: hey, that can be true
16:01:20 <mauke> that is true
16:01:48 <davean> mauke: Whats past the end of an array, reached by pointer addition, can be "vacuous nothing" in very specific cases
16:01:58 <hpc> in very specific cases
16:02:06 <mauke> C objects are islands in a sea of nothing
16:02:10 <davean> IIRC the C pointer on a LISP machine is such a case
16:02:25 <mauke> a.k.a. "sections" to asm people
16:02:35 <Rotaerk> are you a poet mauke ?
16:02:44 <mauke> no, a C programmer
16:02:53 <Clint> same thing
16:02:54 <Eduard_Munteanu> Closest thing to a poet.
16:02:56 <Eduard_Munteanu> :)
16:03:00 <hpc> anyhoo, IO puts it all out in front of you
16:03:08 <davean> Eduard_Munteanu: no, poets can sometimes find happiness
16:03:17 <Eduard_Munteanu> :D
16:03:44 <hpc> you don't show someone a "list of bytes" pointer and have them start asking "what about cache locality and virtual memory?"
16:04:03 <hpc> but in IO you frequently get "why can't i end a do-block with x <- y"
16:04:12 <hpc> which you can answer with "it just does"
16:04:35 <hpc> but it's not a satisfying answer to a question that's staring you right in the face
16:05:13 <hpc> or you ask what's the difference between (<-) and let
16:06:50 <hpc> just the way IO works beckons the learner to dig deeper, while "list of bytes" presents a pretty complete lie
16:07:01 <hpc> and on that note, movie time
16:07:52 <davean> hpc: I'm a litle worried you're building up an analogy with something we've abjectly failed to teach. Not that its wrong but it seems hard to learn from
16:08:13 <hpc> yeah, probably
16:08:25 <davean> What do we really gain from an analogy between IO and pointers when we've clearly absolutely failed to convey pointers to C programmers?
16:08:37 <hpc> no idea
16:08:41 <hpc> mostly that was just rambling ;)
16:08:44 <davean> hpc: well, ok then :)
16:12:03 <nitrix> Hi
16:12:05 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Main.hs#L56
16:12:25 <nitrix> I need help with line 56. I'd like to ensure pollEvents is strict and always run on this main thread.
16:13:02 <nitrix> I looked at deepseq, it says on the tin exactly what I need, but it seems to work on some NFData data type.
16:14:05 <nitrix> Maybe seq would work equally as well? It doesn't say anything about the thread behavior though.
16:14:58 <davean> nitrix: so, the action will happen in the thread its done in, its just the pure evaluation that could move.
16:15:34 <davean> nitrix: and you should read http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#g:8
16:15:43 <davean> because Haskell threads are not OS threads
16:15:46 <nitrix> I really need pollEvents to happen on the main thread; as this is a limitation of SDL.
16:15:56 <nitrix> It's causing a crash with ekg.
16:17:59 <nitrix> davean: I see, that's actually helpful, to some degree.
16:19:25 <davean> nitrix: of course, "Note in particular that the main program thread (the thread running Main.main) is always a bound thread"
16:20:07 <nitrix> Could I just add runInBoundThread ?
16:20:37 <nitrix> Seems expensive. I think it creates a temporary thread everytime.
16:21:24 <nitrix> (Oh, when the calling thread isn't bound, it says)
16:40:42 <Tenson> hi morbid
16:40:58 <Rush_Dillion> Hi morbididty.
16:41:17 <MORBiDiTY> sup
16:41:27 <Rush_Dillion> Do you know how to program a pix controller using C? Should I use a special library call out?
16:41:41 <Rush_Dillion> I need to hack into the main frame.
16:42:51 <MORBiDiTY> i dont even know what a pix controller is
16:42:52 <MORBiDiTY> lol
16:43:27 <Tenson> hes a smith
16:43:37 <marchelzo> nitrix: I was thinking you would just do: mainLoop game = runInBoundThread $ do ...
16:43:57 <marchelzo> I wonder how that would affect performance
16:44:03 <MORBiDiTY> you mean like a wild life cam Rush?
16:44:54 * hackagebot mvc 1.1.2 - Model-view-controller  https://hackage.haskell.org/package/mvc-1.1.2 (GabrielGonzalez)
16:47:57 <nitrix> marchelzo: mainLoop :: Game -> Environment IO ()
16:48:10 <marchelzo> ah
16:48:17 <marchelzo> I'm not very observant
16:48:28 <nitrix> marchelzo: I can lift . runInBoundThread the whole function, but then, it used to call renderGame which is also an Environment IO () ... (that's the reader monad)
16:49:03 <nitrix> The function could become IO, I don't mind, but then I have to run this other reader inside.
16:49:57 <Rush_Dillion> http://www.pixcontroller.com/eagles/
16:50:04 <Rush_Dillion> watch a bald eagle.
16:51:34 <Tenson> wow this is lifechanging
16:52:19 <nitrix> marchelzo: That seems to run flawlessly.
16:52:40 <Rush_Dillion> Yea the camera footage of the bald eagle is flawless.
16:52:41 <marchelzo> nitrix: is it noticeably slower?
16:52:50 <nitrix> marchelzo: There's not enough logic to tell.
16:53:10 <nitrix> marchelzo: But what I can do is moved all the heavy load to runUnboundedThread something.
16:53:20 <marchelzo> oh, true
16:53:37 <nitrix> Anyway, I guess at this point is just figuring out what does or doesn't need thread pinning.
16:54:07 <nitrix> (bounded threads)
16:55:34 <Cale> Rush_Dillion, Tenson: You're in #haskell, this is a channel for discussion of the functional programming language Haskell. Please take other discussion elsewhere. Thanks.
17:01:30 <Rush_Dillion> Ok. 
17:08:10 <nitrix> Cale: marchelzo: Turns out, Main.main is only on a bounded thread when the program is standalone, not on ghci.
17:08:32 <nitrix> Cale: Sorry for the highlight.
17:08:58 <marchelzo> so you don't need runInBoundThread?
17:09:28 <nitrix> marchelzo: I need it when developing on GHCI, so the performance cost can be ignored.
17:09:33 <marchelzo> right
17:09:49 <synergistics> Are any of the haskellbook authors here?
17:10:09 <nitrix> synergistics: See bitemyapp on #haskell-beginners.
17:10:25 <synergistics> That's Chris?
17:10:29 <marchelzo> yes
17:10:29 <nitrix> Yes.
17:10:36 <synergistics> Ah, thank you
17:11:05 <marchelzo> what is your workflow like? it seems like it would be hard to run a video game in ghci
17:11:40 <nitrix> marchelzo: Change expressions, reload, type checks, run main. Move around, try things, rinse and repeat.
17:12:01 <nitrix> It's a simple 2D game. There's a lot going on, the CPU isn't the happiest, but the GPU has almost nothing to do.
17:12:13 <marchelzo> I see
17:14:39 <dmwit_> nitrix: Ah, funny one. Possibly `:main` would run it in a bound thread.
17:15:04 <dmwit> nitrix: If not, I would consider making that a bug report on Trac.
17:15:45 <nitrix> Let's try
17:16:03 <nitrix> :main is also unbound.
17:16:49 <geekosaur> ?
17:16:53 <geekosaur> it's a ghci command
17:17:17 <dmwit> I think he's saying that `:main` doesn't seem to run `main` on a bound thread.
17:17:23 <geekosaur> oh
17:17:30 <dmwit> nitrix: For the purposes of writing this bug report, how did you test that?
17:18:39 <geekosaur> they got rid of the sandbox option I see
17:19:07 <geekosaur> (I had thought that they killed the sandbox stuff so it would be using the normal bound thread)
17:19:27 <dmwit> nitrix: Never mind, I see there is `isCurrentThreadBound` of appropriate type.
17:19:37 <d-snp> oO marchelzo what a coincidence that you are also a Haskeller :P
17:20:02 <marchelzo> d-snp: :)
17:22:12 <dmwit> nitrix: Oddly, even compiling `main = isCurrentThreadBound >>= print` results in `False`.
17:22:18 <dmwit> Which... can't be right, can it?
17:22:59 <maerwald> what's an alternative to ghc-mod? It's constantly broken in vim+syntastic. I know there was some other thing, but I forgot the name
17:23:20 <nitrix> dmwit: It's what I'm doing. It gives false for GHCI, true for standalone (stack exec appname)
17:23:50 <dmwit> I just tossed that in a file and ran `ghc test.hs && ./test`.
17:23:58 <marchelzo> nitrix: maybe it's a coincidence
17:24:00 <dmwit> It printed `False`. Are you saying it prints `True` for you?
17:24:07 <marchelzo> maybe main is not guaranteed to be run in a bounded thread
17:24:14 <marchelzo> but it _can_ be?
17:24:30 <dmwit> I am pretty sure they promise to start `main` from a bound thread.
17:24:37 <rcyr> maerwald: hdev
17:24:39 <rcyr> ?
17:24:46 <maerwald> no
17:24:54 <maerwald> not the same set of features
17:24:55 <Adeon> are you compiling with -threaded
17:25:07 <dmwit> doh
17:25:10 <dmwit> That was dumb. =P
17:25:13 <dmwit> Adeon++
17:25:31 <maerwald> (and am using it already)
17:27:46 <nitrix> marchelzo: "Note in particular that the main program thread (the thread running Main.main) is always a bound thread"
17:27:53 <nitrix> marchelzo: I think this is somewhat misleading then.
17:28:29 <marchelzo> I was just speculating. I think that is true.
17:29:06 <nitrix> marchelzo: I'm passing it to GHC. You were a great help though.
17:29:08 <nitrix> Very appreciated (:
17:31:26 <dmwit> nitrix: https://ghc.haskell.org/trac/ghc/ticket/11682
17:37:31 <nitrix> :]
17:38:59 <nitrix> At least, be it only for consistency. I don't know how much of an issue it really is.
17:42:55 <geekosaur> OS X native GUI stuff gets rather grumpy if it's not on a bound thread. So does OpenGL IIRC
17:47:09 <nocturne777> has anyone ever used persist's migration feature in production
17:51:06 <asdfds> I know it's off topic, but can anyone give me the name of the products from that one web comic?
17:51:27 <asdfds> There's two things/products that are essentially the same thing, but have completely different sets of fanboys.
17:51:31 <average> judging by the comments in this thread I've read
17:51:31 <average> https://www.reddit.com/r/haskell/comments/493suw/code_review_request_dijikstras_algorithm/
17:51:48 <average> what do people here think of Haskell taking a lot of effort to write a simple loop ?
17:51:56 <sleblanc> average, I disagree
17:52:06 <sleblanc> The concept of a loop is hard to define in Haskell
17:52:21 <asdfds> Yeah, you don't write so many of those loops in Haskell that the intro-books have you do.
17:52:35 <average> so uhm..
17:53:09 <asdfds> So, how new are you to programming?
17:53:21 <asdfds> Know Python/Ruby/JS, and checking out what this functional thing is all about?
17:53:31 <sleblanc> Haskell is about breaking down your problems into minuscule components, composing functions and using features like pattern matching to allow for different cases (e.g. empty lists)
17:53:57 <sleblanc> Substitute Haskell with functional programming
17:54:13 <Adeon> haskell is so much different from the most used languages that it feels weird and is difficult to learn
17:54:20 <average> so my story is really simple
17:54:25 <average> I've been told in 2007 about Haskell
17:54:44 <average> ever since, I've been looking at Haskell every now and then.. always trying to find a compeling reason to learn it
17:55:00 <average> since 2007, I've been trying really hard to find a good excuse to learn it and found only 1 so far
17:55:07 <asdfds> What's that?
17:55:09 <average> which has to do with a Perl module for permutations I've written a while back
17:55:37 <zen_> what are your opinions wrt to AST annotations combined with bound? I'd like to carry arbitrary annotations _and_ binding information (from bound). 
17:55:38 <average> that Perl was way too dynamic for, and didn't have any features for more mathematical programming
17:55:52 <jle`> i don't really get the "good reason" thing, as if you're trying to find a "killer app" for haskell before using it
17:55:55 <average> but the module itself is quite useless, it was just something I was curious about
17:55:55 <sleblanc> Well, for a start, Perl is way different from Haskell, so you might have trouble at first to adjust
17:56:00 <jle`> the truth is that haskell is a general language that can improve *any* application you're talking about
17:56:17 <jle`> if you ever program anything ever, then there's a good reason to learn haskell, because haskell can take that domain and improve it :)
17:56:18 <average> now.. turning back to Haskell, I still to this day, cannot understand what the deal is
17:56:21 <jle`> and help you program better at it
17:56:28 <average> and mind you, I've looked at it for quite some time
17:56:37 <asdfds> The reason to learn Haskell is because you like abstractions. You think it's stupid to try to tell the computer what to do step-by-step. You think it's dumb to waste time messing with memory management. You think it's going to result in buggy code having to worry about writing loops all the time.
17:56:37 <maerwald> jle`: there are certainly domains where haskell has little to no penetration
17:57:04 <zen_> should I just build an ABT later on? or hand roll the binding information in the actual annotations?
17:57:08 <jle`> maerwald: sure, but those are the exceptions
17:57:18 <jle`> it's not like haskell is useless except for a few domains.  it's the other way around :)
17:57:33 <sleblanc> average, to me, Haskell is both the most powerful language and the easiest to type that allows me to describe my problem in its own domain-specific language.
17:57:45 <jle`> in almost every case, haskell can take whatever you're working on, and make it faster, more maintainabile, faster to write, etc.
17:57:51 <jle`> and with more guaruntees on correctness
17:57:53 <average> sleblanc: ok but how do you explain that loop thing in the link I've posted ?
17:58:07 <average> it seems like a loop in Haskell is unwieldy and hard to express
17:58:12 <asdfds> average: Loops can be buggy and rely on stateful programming.
17:58:22 <sleblanc> The dijkstra's algorithm post? Hang on a sec
17:58:28 <asdfds> average: In Haskell, we don't really like loops.
17:58:56 <average> asdfds: c'mon man.. what's next, in Haskell you don't like variables
17:58:56 <maerwald> haskell doesn't have dependent types, so I'd not call it the most powerful language
17:59:02 <average> in Haskell you don't like conditional statements
17:59:05 <Cale> asdfds: I don't know if I'd go that far... we use loops in Haskell, they're just not built in.
17:59:08 <average> in Haskell you don't like classes
17:59:13 <average> in Haskell you don't like programming
17:59:15 <Cale> asdfds: What is forM if not a loop?
17:59:41 <sleblanc> average, no, the thing about loops is that it's true
17:59:42 <asdfds> average:  Do you ever see loops in Math?
17:59:51 <zen_> between fold and map the majority of the usecases for loops are generalized
17:59:51 <sleblanc> The concept of a loop is so specific to its implementation
17:59:51 <Cale> asdfds: Yes, sort of :)
17:59:57 <maerwald> I like loops.
18:00:02 <average> asdfds: you do, there are algorithms in maths in a lot of places
18:00:21 <asdfds> average: They're usually not described in a "Do this, now do it again, now do it again" manner.
18:00:36 <Cale> Loops are recursion over lists, and there's plenty of recursion over lists in Haskell.
18:00:48 <average> asdfds: they are actually.. there are many examples
18:01:00 <average> asdfds: how familiar are you with mathematics ?
18:01:13 <asdfds> average: Not as far as I'd like. :(
18:01:25 <average> how about the greatest common divisor
18:01:28 <average> are you familiar with that ?
18:01:44 <mysiticity> Loops are just repeating statements, with a different init value until a condition, You can do that with or without a imperative loop construct. 
18:02:44 <average> mysiticity: are you suggesting the use of recursion just because loops are not favored in Haskell ?
18:03:18 <zen_> loops are a special case of recursion
18:03:33 <asdfds> average: Oh, right. You can have an algorithm to derive the GCD.
18:03:44 <jle`> things you'd normally write using loops you'd write using other abstractions in haskell, like
18:03:49 <jle`> > map (*2) [1,2,3]
18:03:49 <asdfds> average: But I'm not sure where anywhere in math a GCD is defined as a loop performed.
18:03:50 <lambdabot>  [2,4,6]
18:03:57 <Cale> @let gcd' a 0 = a; gcd' a b = gcd' b (a `mod` b)
18:03:58 <lambdabot>  Defined.
18:04:37 <average> asdfds: the most common and wide-spread and popular version of Euclid's algorithm is iterative
18:04:50 <average> it is a loop
18:04:58 <mysiticity> average: Haskell, and functional languages deal with immutable values, and tail-recursion for loops. The compiler can then easily do tail call optimisations, which makes the recursion as costly as loops, and less costly than calling multiple functions
18:05:01 <Cale> Right, just like the one I wrote is a loop :)
18:05:47 <average> so.. because we're beating a bit around the bush..
18:05:57 <average> are you saying that in Haskell, one should avoid loops ?
18:05:58 <Cale> Though in the case of Haskell, discussing tail-call optimisation is weird, because there is no call stack to begin with.
18:05:59 <sleblanc> average, many cases of loops are eliminated through the use of pattern matching and recursion: average, say you want to add 1 to every number in a list. The closest you'll get to a loop is with addOneToList [] = [], addOneToList (x:xs) = (x+1) : addOnetoList xs
18:06:01 <average> and use recursion instead ?
18:06:14 <Gurkenglas_> average, looking at sid-kap's reddit thread, I would try to refactor that code to use MaybeT instead of booleans. For example, why is it important that the Queue is not empty? If the next step requires you to pop the queue, I would try to use something like StateT maxView (using https://hackage.haskell.org/package/pqueue-1.3.1/docs/Data-PQueue-Max.html#v:maxView )
18:06:16 <Cale> average: Loops are just one particular form of recursion, it's not really to be avoided.
18:07:06 <average> Cale: but in that reddit thread, one of the commentors proposes that the OP define his own operators in order to mimic a simple loop
18:07:14 <jle`> average: it's not like loop = recursion
18:07:22 <average> Cale: doesn't that exceed a reasonable effort level for such a simple concept ?
18:07:24 <jle`> just use the right tool for the right job
18:07:36 <jle`> use the right abstraction for the right job
18:07:44 <Cale> average: Such things exist in the libraries already
18:07:54 <Cale> average: You don't typically have to write them yourself.
18:08:07 <average> Cale: why not in Haskell's core tho ?
18:08:18 <Cale> The base package is pretty core.
18:08:24 <average> Cale: IIUC you're suggesting a 3rd party library
18:08:32 <average> ah ok, so it is in core
18:08:38 <Cale> I'm suggesting a library which comes installed with GHC
18:08:46 <Cale> and every Haskell implementation
18:09:00 <Cale> :t forM
18:09:01 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
18:09:15 <Cale> That's kind of ridiculously generalised...
18:09:22 <Cale> Let's pretend that it says...
18:09:31 <Cale> [a] -> (a -> IO b) -> IO [b]
18:09:42 <Cale> So, it's a function which, given a list of things to iterate over
18:10:07 <Cale> and a loop body, that is a function which will take an element of the list and determine an action to be performed (whose result has type b)
18:10:24 <Cale> will produce an action which will carry out the loop, collecting a list of the results
18:10:38 <average> so maybe similar to map
18:11:00 <Cale> Yeah, you can define it in terms of map and another function called sequence
18:11:10 <sleblanc> :t sequence
18:11:11 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
18:11:28 <sleblanc> e.g. [IO a] -> IO [a]
18:11:32 <Cale> sequence :: [IO a] -> IO [a] will take a list of IO actions, and produce a single IO action that when executed will carry out each action in turn, and collect a list of the results
18:11:37 <Cale> We can write that recursively:
18:11:54 <Cale> sequence [] = return [] -- if the list is empty, produce the action which does nothing except to return an empty list.
18:12:01 <average> but is there really value in writing something recursively..
18:12:26 <average> I have no problem with writing something with a base case, and a general case based on previously computed values
18:12:27 <Cale> sequence (x:xs) = ... -- if the list is nonempty, and starts with an action x, continuing with the list xs
18:12:32 <average> but.. is there a point ?
18:12:44 <Cale> sequence (x:xs) = do v <- x; ... -- first execute x, getting some result v
18:13:04 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- then execute the rest of the actions, collecting up a bunch of results vs
18:13:22 <average> I think Haskell is sold a lot with recursion examples, I could sell Bash with recursion examples.. they would surely be more simple than Haskell's
18:13:23 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- finally, return the combined list of results
18:13:31 <asdfds> average: What's the point of what?
18:13:41 <Cale> average: Well, there are a few points here
18:13:55 <Cale> average: One point is that really this function does not *just* work with IO actions, not really.
18:14:26 <Cale> But it works with values in any monad, for example, the same sequence function also operates on lists of lists, rather than lists of IO actions.
18:14:49 <Cale> There, the analogue for lists of "running an action", i.e. "running a list" means to pick an element from it in all possible ways
18:14:56 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
18:14:57 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
18:15:02 <sleblanc> average, there are things that are succinctly defined in terms of recursion, like Peano numbers, which allow you to have value-dependent type
18:15:10 <Cale> and sequence picks one element from each of the lists in all possible ways
18:15:28 <Cale> It also works on parsers, forming a concatenation of the parsers
18:15:33 <Cale> and in many other libraries
18:15:37 <average> but isn't this just some mirage that in practice falls prey to abstraction-breaking corner-cases ?
18:15:43 <Cale> nope
18:15:53 <Cale> It works perfectly all the time
18:16:06 <average> like, yes you can have abstract things, but that doesn't lift the burden of treating all the corner-cases on your behalf
18:16:14 <Cale> What corner cases?
18:16:30 <zen_> the whole point of abstraction in any language is to avoid those corner cases
18:16:44 <Cale> The monad abstraction is pretty water tight.
18:16:52 <average> zen_: yes, but you will still have to cover them
18:17:02 <asdfds> average: Like, what, null?
18:17:05 <Cale> If you implement the monad operations in a lawful way, then this will do something sensible and predictable for your monad.
18:17:13 <sleblanc> In Haskell, you can express a data type as e.g. "A list of 10 numbers" and a function that takes a list of n numbers and returns a list of (2*n) numbers, enforced by the static type system
18:17:16 <zen_> depends, with a judicious choice of abstraction they can arise naturally
18:17:36 <Cale> sleblanc: ehh... but you wouldn't.
18:17:39 <maerwald> average: yes, but that's an implementation problem. Some haskell libraries do it properly, others not. It's just that the type system allows you to easily catch those corner cases.
18:17:42 <Cale> sleblanc: Well, I wouldn't :P
18:17:58 <maerwald> e.g. filepath handling has a sh**load of corner cases
18:18:11 <average> look, maerwald knows what I'm saying
18:18:12 <Cale> Haskell isn't properly dependently typed, so trying to do serious computation at the type level is annoying.
18:18:13 <sleblanc> Cale, IMO it's useful if you want to statically assert constructs in your domain-specific language
18:18:24 <sleblanc> I agree
18:18:25 <average> asdfds: every time I come in this channel, I feel like you're an artist
18:18:26 <Cale> You *can* do it... if you really must
18:18:29 <average> asdfds: or a poet
18:18:31 <maerwald> so you can either use strings (and the most widely used haskell library does)...  or you can use proper types
18:18:34 <average> asdfds: we have talked before
18:18:39 <asdfds> average: No we haven't.
18:18:57 <Cale> average: Yeah, but there are plenty of useful abstract things we can do where there are no annoying corner cases.
18:19:34 <zen_> qq: how do you guys annotate your asts with source position and type information and how do you combine that with binding information?
18:19:52 <zen_> I've been trying to combine annotations and bound unnsuccessfully for a while now
18:20:24 <maerwald> average: "/foo" </> "/"
18:20:30 <maerwald> </> stand for concatenation of paths
18:20:36 <maerwald> what would you expect the result to be?
18:20:43 <pavonia> zen_: Wrapping it into a newtype is one way
18:21:06 <zen_> pavonia: explain? I've been using cofree for annotations but I can't seem to combine that with `bound`
18:21:27 <pavonia> Err, no idea what that is, sorry
18:21:38 <average> here's another claim that I've read from some people: "Haskell production code you write today will not work in 2 months because Hackage is constantly changing" (if this makes little sense, I think maybe a little clarification would help: in eco-systems of languages like Java or C++, backwards-compatiblity is valued more than it is in Haskell)
18:21:49 <maerwald> that's correct
18:22:00 <zen_> thats why you can use stackage
18:22:25 <asdfds> Yeah, there's a lot of tooling to get around that.
18:22:26 <jle`> stackage is nice :)  you can fix your builds to snapshots and they'll work forever ~
18:22:36 <maerwald> haskell is nowhere near an eco-system like C where some library is ABI-compatible for years, lol
18:22:41 <Cale> average: That is basically true, if you have lots of dependencies and you don't fix the version numbers on things, you're in for some trouble.
18:22:42 <maerwald> we have no ABI compatibility ;)
18:23:12 <sleblanc> maerwald, ABI compatibility is useless when you get loads of "undefined symbol x...." right when you start the program ;-)
18:23:29 <Cale> average: If you want to update packages, I recommend doing it one at a time -- usually there's no trouble, but sometimes things do change. You can't make anything better without changing it of course.
18:23:51 <sleblanc> average, compared with say, Python, Haskell has been more stable for me
18:24:43 <Cale> Of course, it probably depends a lot on which specific packages your project depends on -- some of them change much more quickly than others.
18:25:08 <average> sleblanc: because you.. tend to use well-known staples rather than exotic Haskell packages ? (I would define something as being exotic based on the length of its longest dependency chain to a base package)
18:25:38 <sleblanc> average, indeed, because I do not often feel the need to go beyond common Haskell packages
18:26:35 <Clint> i haven't had an api change forced on me in months
18:26:40 <average> sleblanc: what sort of code do you write ?
18:26:48 <Cale> We have seen some changes land in the Prelude in the last year.
18:26:56 <sleblanc> Parsers, automation, 
18:27:00 <sleblanc> real-time stuff
18:27:06 <average> sleblanc: you get paid for it ?
18:27:10 <sleblanc> I try to
18:27:38 <asdfds> average: How about instead of trying to prove us wrong for using Haskell, why don't you spend a couple weeks learning it yourself? https://github.com/bitemyapp/learnhaskell
18:27:48 <sleblanc> I don't ship a lot of Haskell code, but I spend a lot of time "twiddling" with it. It even helps me express my problems in other languages
18:28:51 <sleblanc> For instance, it taught me to avoid state at all costs (if not too inconvenient)
18:29:08 <cjay> what is the usual way to chose the version constraints for dependencies in cabal files?
18:29:18 <asdfds> average: Very few have ever regretted learning Haskell. Even when they feel it's not the right language for them to ever use again, it's extremely common to believe it's changed how one thinks about programming.
18:29:18 <Cale> I'm doing web applications in Haskell with the guys at Obsidian Systems. We use Haskell both for the frontend (using ghcjs to compile Haskell to Javascript along with reflex-dom), and the backend (using Snap to serve the web service, and groundhog/postgresql for the database)
18:29:26 <sleblanc> cjay, you can write package==1.2.3.4
18:29:43 <Cale> average: (and I'm paid for it :)
18:29:55 <average> Cale: I am very surprised to hear someone is getting paid for such things
18:30:05 <average> maybe I'm just weird for being surprised about that..
18:30:16 <sleblanc> cjay, as a guideline, packagers are invited to keep their library compatible when they increase the minor version number (1.x), so you can target package<= 3.0 when you use package==2.8
18:30:32 <maerwald> average: someone is getting paid for programming? err....
18:30:33 <shachaf> Cale: Your company's name keeps changing but it keeps being the same people.
18:30:33 <average> I wonder how you sell such things to a client Cale ..
18:30:38 <Cale> shachaf: hehe
18:30:39 <average> maerwald: no no no..
18:30:43 <average> maerwald: Haskell programming..
18:30:51 <maerwald> pretty common in some industries
18:30:54 <sleblanc> "such things". You're so judgmental!
18:31:18 <average> I'm not saying it's that different
18:31:32 <Clint> try more neutral trolling
18:31:34 <Cale> average: You'd have to ask Ryan (ryantrinkle on IRC) or Ali (abrar on IRC) about that -- I mostly haven't had the chance to interact with clients since I work remote.
18:31:40 <average> I'm just saying I would not write Haskell code and sell it unless I'd know Haskell really well
18:31:42 <sleblanc> average, Haskell wrote that huge spam analysis system in Haskell
18:31:54 <maerwald> average: that goes pretty much for any language
18:31:55 <average> because I'm sure I might bump into something that would be problematic for me to debug
18:31:59 <average> and then I'd be really stuck
18:31:59 <sleblanc> oops
18:32:01 <Cale> average: But hey, we know Haskell pretty well, and we deliver stuff that works.
18:32:04 <sleblanc> Facebook, not Haskell
18:32:15 <average> and since this would be a paid project, I would not want such a thing to happen
18:32:29 <maerwald> that sort of doesn't make much sense
18:32:34 <zen_> doesnt the same thing apply to any language?
18:32:43 <zen_> i wouldn't write C code unless i knew how to debug it
18:32:46 <sleblanc> average, if you do find such a bug, you won't be stuck. You can work around it. Haskell has very painless FFI integration
18:33:01 <maerwald> sleblanc: unless you hit structs, mate
18:33:09 <sleblanc> maerwald, let us not go there
18:33:17 <maerwald> so why do you call it painless then
18:33:30 <asdfds> Man, all the bugs I've encountered in Haskell have been trivial compared to bugs I get in Java :\
18:33:32 <Cale> maerwald: What's so painful about structs?
18:33:43 <sleblanc> maerwald, if you interface your own code with Haskell, you aren't bound to structs; you can serialize your data in the other language before sending it over to Haskell
18:33:43 <cjay> sleblanc: ok sounds good. I ported an old package from lts-2.14 to lts-5.5, so the first thing I had to do was to throw out all the version constraints, otherwise stack would complain a lot.
18:34:20 <Cale> maerwald: Don't you just write appropriate instances of Storable... and there are tools to help with it even, if you don't want to do that by hand.
18:35:24 <average> Cale: considering there are more mature eco-systems out there, why is Obsidian Systems choosing to use Haskell ?
18:35:38 <average> 04:31 ( Clint) try more neutral trolling
18:35:56 <sleblanc> average, define mature. Also, why are people using Ruby on Rails, Django, Node.js, et al. then?
18:36:04 <average> Clint: try.. understanding what I'm talking about
18:36:32 <Cale> average: Well, there are a lot of reasons, but one is likely that the FRP library we've developed would be absolutely absurd to try to write in anything else, and it is responsible for a ton of productivity.
18:37:09 <average> sleblanc: well.. RoR,django,nodejs have gathered some momentum, there are some web frameworks for them already, plus a number of libraries that cover common needs in real applications
18:37:11 <asdfds> average: What you're doing is closer to trolling. Coming to a Haskell channel and telling us we're all wrong for using Haskell, rather than trying to actually learn about Haskell. Or if your'e doing the latter, you really need to work on your people skills.
18:37:35 <average> all popular web frameworks in those eco-systems were built during real projects for clients
18:38:00 <sleblanc> average, sounds similar to Cale's framework.
18:38:39 <sleblanc> average, and what would you say of Flask and Bottle?
18:38:46 <average> sleblanc: I use Flask
18:39:53 <average> https://github.com/mitsuhiko/flask
18:40:15 <average> 5.7k forks, 18k stars
18:40:20 <average> yes I know.. that's not a measure of success
18:40:46 <Cale> average: Our FRP system (which actually isn't just for writing web applications, though that's mostly what we've done with it thus far) gives you two basic concepts for things which change over time:
18:40:59 <average> however, yes.. Flask is popular, easy to use(except when you need some 3rd party module that should've shipped with Flask but doesn't.. and it's not working properly or you're having a hard time reading the docs..)
18:41:01 <sleblanc> Flask was originally an April's fools joke. Pretty far from a "real (paid) project for a client"
18:41:53 <Cale> Behaviors are things which always have a value whenever you look at them, but may change faster than you can observe them (even continuously), things like the current time, or the current contents of a form field, or the current set of bids that a user has made on various items, or the current HP of a monster, or what to currently display on the screen.
18:43:03 <Cale> Events are things which occur at particular discrete points in time, and only have a value at those times, things like the sequence of keystrokes or mouse clicks, the sequence of requests made to a backend, or the sequence of responses from it, the sequence of button clicks on a form, the sequence of attacks made by a monster, or sounds to be played
18:43:24 <Cale> average: and our library gives you lots of ways to combine Events and Behaviors into new Events and Behaviors
18:43:38 <Cale> and it takes care of making sure that everything stays up to date
18:44:15 <Cale> So in the context of our web applications, we can for instance, have a websocket open to the backend, and across that we send a bunch of notifications about changes to the user's visible portion of the database
18:44:47 <Cale> Those get turned into a bunch of Events and Behaviors (really Dynamics which are a combination of the two), and those Dynamics are used to define the page the user is seeing
18:44:57 <sleblanc> Cale, is your library open sourced?
18:45:11 <Cale> So a change happens in the database, and it automatically updates what the user sees, and you don't have to do anything very special to make that happen.
18:45:25 <Cale> sleblanc: reflex and reflex-dom are
18:46:26 <average> I'm fascinated by this idea that someone starts a company
18:46:41 <average> and decides to use an exotic language like Haskell
18:46:51 <Cale> average: Well, it's not *that* exotic
18:46:54 <Cale> Not at this point
18:47:14 <average> which is effectively the hammer he uses to build the software part of a business
18:47:14 <Cale> Look at the user count in this channel :P
18:47:31 <average> Cale: is that really a measure of mainstreamness ?
18:47:36 <Cale> Well, not necessarily
18:47:52 <Cale> We are pretty friendly here, and that must contribute a bit to the channel's popularity :)
18:48:02 <sleblanc> Is mainstreamness really a measure of the value of a programming language?
18:48:17 <average> sleblanc: No
18:48:21 <Cale> But in any case, there are a decent number of companies who have been using Haskell in production for several years now
18:48:40 <average> I'm just puzzled by people choosing certain languages, perhaps what I'm interested in is the reason why they chose something
18:48:54 <average> or their judgement/thought process when doing it
18:49:00 <sleblanc> FXL is written in Haskell: http://thenextweb.com/facebook/2013/01/24/behind-the-scenes-facebook-fights-spam-with-a-new-in-house-programming-language/
18:49:11 <Cale> average: Well, once you learn Haskell and discover how bad most of the other languages you know are... you'll probably understand :)
18:49:22 <davean> average: I choose it because I was tired of the maintance headaches
18:50:11 <sleblanc> better source: https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/
18:50:19 <average> davean: since Haskell code can get really dense.. how does Haskell maintenance feel ?
18:50:31 <davean> average: simple
18:50:35 <Cale> average: I've done refactorings where I've changed the definition of a fundamental data structure which then resulted in hundreds of changes across thousands of lines of code, where the Haskell compiler helped me every step of the way, and when it finally stopped complaining about type errors, the whole thing actually worked.
18:50:38 <davean> Its such a relief
18:50:42 <Cale> On the first try.
18:51:09 <Cale> If this happened only once, I would be less convinced, but it happens on an almost regular basis.
18:51:10 <Ashy> even the small projects ive messed around with in Haskell, you really notice how good the compiler is
18:51:21 <Ashy> it's a totally different feeling when you refactor anything
18:51:39 <Ashy> it feels "safer" so you just change away without worry
18:51:53 <Adeon> yeah that part of haskell is awesome
18:52:05 <davean> well, also, theres less spooky action at a distance. There is a clear procedure for figuring out what affects what
18:52:19 <davean> You never have to untangle the program to figure out a line of code
18:52:21 <Adeon> there are some specific peeves of haskell that I find annoying but they are not super serious
18:52:30 <Adeon> but one of them is juggling between String/ByteString/Text
18:52:31 <maerwald> average: refactoring is the actual fun part in haskell
18:52:47 <Adeon> raw data often is bytestring
18:52:47 <maerwald> and doesn't involve 3+ hours of gdb session
18:52:50 <Adeon> text used a lot internally
18:52:53 <Adeon> but some apis only take string
18:52:55 <davean> And its obvious how to upgrade to a new version of a library a few years later
18:53:02 <davean> Without reviewing the entire program to get it right
18:53:06 <Adeon> and it all causes noise in code
18:53:27 <davean> Adeon: I never use string - String is terrible.
18:53:35 <maerwald> I just changed a fundamental data type in my filemanager code and am now going robot mode on the type errors. After that, it usually just works.
18:53:35 <Cale> Well, to say that it's always fun would be lying. One of the things I was thinking about when I wrote that story above was pretty ridiculously tedious -- but it would have been *impossible* in something like Python.
18:53:36 <sleblanc> A while ago, someone was looking for a way to extract all Just instances from a list, after having verified that it indeed only contained such values. I pointed that person to the sequence function, and they realized they did not need to check for Just anymore. Adding that function meant removing a line.
18:53:47 <Adeon> I think you probably do actually use String because not everything in haskell ecosystem uses text
18:53:55 <sleblanc> > sequence $ [Just 1, Just 2]
18:53:57 <lambdabot>  Just [1,2]
18:53:59 <Adeon> okay I'm making assumptions
18:54:00 <Cale> You would have just scrapped the entire project and rewritten it, if you were using anything dynamically typed.
18:54:04 <sleblanc> > sequence $ [Just 1, Just 2, Nothing]
18:54:05 <lambdabot>  Nothing
18:54:23 <davean> Adeon: I even use valid POSIX path names
18:54:24 <maerwald> Cale: imagine a duck-typed language :D
18:54:26 <davean> Adeon: Not strings
18:54:37 <maerwald> the compiler never complains
18:54:48 <davean> Adeon: So no, I'm sure my use of string is pretty marginal
18:55:01 <davean> String should be removed from Base
18:55:10 <Adeon> yeah sorry about that
18:55:29 <maerwald> the point is... I change my mind pretty often about things in my code and haskell sort of helps me with that
18:55:44 <Cale> and in something like Java, the compiler might have helped a bunch, but you'd have probably ended up with something that didn't work... though I can't even imagine the codebase I was working on then being written in Java in the first place. It's just not something which would have been possible to do.
18:56:12 <sleblanc> Adeon, isn't that string/bytestring stuff true of all languages, in general? Or else, they are considered equal and the compiler can't warn you when you do stupid things
18:56:15 <maerwald> yeah, in java the types are strict, but you still have too much state
18:56:20 <Cale> yeah
18:56:33 <Adeon> I think in many languages they just implicitly change on fly
18:56:33 <Cale> and the consequent debugging would have been a nightmare
18:56:37 <davean> sleblanc: Sorta, ByteString/Text makes sense, its String thats a problem.
18:56:46 <Adeon> haskell forces you to decide how to convert from bytestring to text for example
18:56:54 <Cale> This was code that manipulated and simplified a typed heterogeneous graph
18:56:59 <davean> Adeon: well, there is no sane default.
18:57:01 <sleblanc> Cale, yeah, in Java, you would have to write a compiler that would compile a language that, oddly enough, resembles Haskell
18:57:09 <maerwald> xD
18:57:23 <Cale> With lots of GADTs and stuff
18:57:35 <Adeon> String comes up a lot even if you don't want it
18:57:41 <Adeon> e.g. you can't open a file with base functions without FilePath
18:57:43 <nshepperd> in inexpressive type systems like Java's, you probably would have used a lot of escape hatches like coercing things to Object
18:57:52 <maerwald> FilePath should be removed from core libraries
18:58:23 <sleblanc> I always laugh when I see "C++ Optional template". 170 lines of code.
18:58:26 <davean> Adeon: which is why one avoids the file functions in Base
18:58:30 <Cale> nshepperd: Yeah, which would have resulted in lots of horrible down-casting which would probably get screwed up and blow everything up
18:59:36 <maerwald> String is a weak type
19:00:05 <maerwald> the only place I want to see it is where user input happens and I have to parse it
19:00:11 <maerwald> after that, I don't want to see it anywhere
19:00:15 <davean> maerwald: I don't even want it there
19:00:18 <maerwald> hehe
19:00:25 <davean> Why would you want it there?
19:00:34 <maerwald> because gtk+ gives me that...
19:00:44 <davean> I'd consider that a bug in GTK+
19:00:51 <maerwald> gl convincing them
19:01:11 <davean> maerwald: I'd probably do what I normally do and maintain an internal form with a saner API
19:01:15 <davean> *fork
19:01:27 <maerwald> rewrite gtk+? :o
19:01:36 <davean> the haskell bindings
19:01:55 <maerwald> even then you still get strings at some point
19:02:06 <maerwald> that's what those pesky C functions will give you
19:02:23 <davean> maerwald: no?
19:02:33 <davean> A C string is vastly different then a Haskell String
19:02:33 <maerwald> for gtk+, yes
19:02:40 <maerwald> indeed
19:02:57 <maerwald> but you still parse at some point
19:03:02 <nocturne777> do most people use Persist for inserting and Esqueleto for quering?
19:03:04 <davean> maerwald: ?
19:03:05 <Adeon> it doesn't mean it has to be String
19:03:13 <Adeon> you can totally parse bytestrings and texts
19:03:17 <davean> maerwald: I looked at the C bingings right now, they use C-strings
19:03:19 <maerwald> davean: you parse the user input
19:03:23 <davean> maerwald: which there are direct conversions to Text
19:03:28 <davean> maerwald: so? You can parse on Text
19:03:33 <davean> It works better even
19:03:37 <maerwald> erm
19:03:46 <maerwald> where's the difference?
19:03:48 <davean> I have no idea what you're going on about, very confused here
19:03:55 <davean> maerwald: difference in what?
19:04:08 <maerwald> I don't care if it's Text, BysteString or String... that wasn't really the point
19:04:17 <davean> maerwald: I do
19:04:18 <maerwald> they all have pretty much the same problem
19:04:25 <davean> maerwald: I care that its Text over String, a lot
19:04:25 <maerwald> they can represent anything
19:04:34 <davean> Which was my specific point
19:04:45 <maerwald> so you still have to parse it
19:04:50 <davean> So? Parsing is easy
19:04:54 <maerwald> wat?
19:05:00 <maerwald> that's not what I'm talking about, jeez
19:05:17 <maerwald> seems I lost you somewhere
19:05:21 <maerwald> nvm
19:05:49 <davean> I don't think you lost me, I think you mgiht have been confused about my point.
19:08:55 <horrorcheck> nocturne777: I don't know about most people, but I like Opaleye
19:12:36 <nocturne777> horatiohb: this is not an ORM, is it ?
19:34:38 <horrorcheck> you mean me?
19:35:01 <horrorcheck> I'm not sure if it counts as an ORM.
19:36:15 <nocturne777> horrorcheck: sorry, I meant to refer to you but my irc client failed to auto-complete the nick part.
19:42:47 <levi> Opaleye is not an object/relational mapping, it's more of a haskell/relational mapping that is faithful to the relational model underneath. At least as far as I understand Opaleye.
19:43:40 <nocturne777> levi: they are saying that it is difficult to get started with it
19:45:22 <horrorcheck> Yeah, it's a little complicated.
19:46:55 <horrorcheck> It uses arrows a lot. On the hand, I can still use it, without understanding arrows very well at all, so that's not as much of a barrier as you might think
19:47:40 <levi> I haven't used it, so I couldn't give any personal experience as to whether I found it difficult to get started with or not.
19:50:18 <horrorcheck> I kinda hope some folks who use the libraries you mentioned will pop in to this convo because I'd like to know how they compare as well
19:57:37 <levi> I have used Persist once, and postgresql-simple once.  They're both relatively easy to use; Persist is less flexible but provides handy stuff like migration and extra type safety, while postgresql-simple is, well, simple. You just use SQL directly.
19:59:02 <horrorcheck> I usually start with PostgreSQL.Simple and then when stuff gets unwieldy move to Opaleye 
20:05:12 <levi> Sounds reasonable. :)
20:06:36 <Azel> obadz: I think so.
20:33:07 <nocturne777> horrorcheck: does Opaleye sometimes generate bad queries?
20:40:15 <horrorcheck> I don't think so! Sometimes the SQL is pretty gnarly, but it's not slow or wrong.
20:44:51 <nocturne777> the thing I don't like about persist so far is that the models don't have id. so I have to create another datatype with the same fields plus id. pretty much all the time, when you serialize it to json to return the results to the UI, you want the Ids to there
20:45:03 <broma0> recommendations for a sql library? im stuck between postgresql-simple requiring me to match type constructor arguments to columns positionally and HDBC being far too verbose.
20:45:30 <nocturne777> broma0: I am in the same boat right now as well
20:45:48 <broma0> nocturne777: for me, persistant also isnt an option due to how it hijacks my data declarations
20:47:18 <nocturne777> broma0: what do you mean by hijacking ?
20:48:59 <horrorcheck> there's a lot of boilerplate with opaleye too, apparently you can get around it with template haskell, but I find typing boilerplate kinda pleasantly meditative so I haven't bothered
20:49:10 <broma0> nocturne777: having to define my types through `mkPersist [persist| ... |]`
20:49:53 <broma0> i just HATE how i cant have standard data declarations! why hijack the normal `data Blah = MkBlah` with QQ and template haskell??
20:52:21 <nocturne777> broma0: I dont' like that either. on top of that, it forces one to declare similiar looking types outside of the template stuff because of the missing id issue
20:53:16 <nocturne777> broma0: esqueleto requires types to be declared the same way, right ?
20:54:04 <broma0> nocturne777: i believe so.. it uses persistent as a backend :/
20:54:56 <nocturne777> broma0: I am currently looking at Opaleye. some of the gents here suggested that library. here are some examples: https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialBasic.lhs
20:55:01 * hackagebot indentation 0.2.1.2 - Indentation sensitive parsing combinators for Parsec and Trifecta  https://hackage.haskell.org/package/indentation-0.2.1.2 (AlekseyKliger)
20:58:20 <horrorcheck> nocturne777: I'm not a gent, I'm a lady
20:58:44 <nocturne777> horrorcheck: my apologies
20:58:55 <broma0> nocturne777: opaleye looks ok.. but im thinking more like Clojure's YeSQL library
21:03:14 <broma0> thoughts on a SQL library where you'd write a simple query like this: http://lpaste.net/154086 ?
21:07:00 <dmj`> broma0: postgresql-simple-sop will substitute sql table field names for haskell record field names
21:07:09 <dmj`> @package postgresql-simple-sop
21:07:09 <lambdabot> http://hackage.haskell.org/package/postgresql-simple-sop
21:07:17 <dmj`> check ginsertInto
21:07:28 <dmj`> although generics are slower
21:08:35 <mitchty> how would I get stack to try compiling all of hackage or at least all of what it knows of?
21:09:02 <dmj`> mitchty: stack install acme-everything
21:09:08 <dmj`> @package acme-everything
21:09:08 <lambdabot> http://hackage.haskell.org/package/acme-everything
21:09:25 <dmj`> is one way
21:09:28 <mitchty> dmj`: heh awesome name, danke :)
21:10:00 <mitchty> trying to come up with a way to test my ghc port a bit more extensively
21:27:57 <Ashy> mitchty: what did you port it to?
21:29:12 <mitchty> Ashy: alpine linux x86_64 http://lists.alpinelinux.org/alpine-aports/2573.html working on arm as well, it... sorta works just not enough to compile itself yet
21:31:52 <lifter> :r
21:32:36 <mitchty> and i find fun things along the way https://github.com/haskell/c2hs/issues/159#issuecomment-191693558
21:32:59 <mitchty> which leaves me patching stdlib.h :)
21:34:12 <Ashy> oh nice, hadnt seen alpine linux
21:34:43 <mitchty> i (ab)use it to make static binaries I can run on any linux
21:35:14 <mitchty> that said, ghc static binaries are huge 4 megs
21:36:17 <mitchty> and 3.9megs on arm for hello world
21:40:25 <pdxleif> A hello world on my 64-bit linux system is 1.1mb, 776K after stripping.
21:40:53 <mitchty> pdxleif: this is fully static, no ld.so
21:41:18 <pdxleif> A hello world in Idris is 77k
21:41:25 <pdxleif> Ah
21:46:26 <pdxleif> Was there a way of showing stacktraces from the ghci debugger?
21:46:47 <mitchty> as an example, fully static hello world is 8k stripped 
21:46:48 <mitchty> https://gist.github.com/mitchty/ff8f0bc7cb33b3653b79
21:46:53 <mitchty> in c rather
21:48:56 <emmanuel_erc> Hello there everyone!
21:49:01 <pdxleif> Running ghc -static still gives me an executable that's dynamiclly linked to a number of c libs.
21:49:41 <mitchty> pdxleif: thats glibc :) and the reason why i ported to musl so I can have static binaries
21:50:57 <mitchty> i missed them from c
21:51:19 <mitchty> though i miss the small sizes from c
21:52:42 <nocturne777> I think I will simply go with postgresql-simple
21:53:07 <nocturne777> I don't like the way persists forces me to write code
21:53:31 <nocturne777> opaleye does not generate very optimized queries
22:00:03 * hackagebot hOpenPGP 2.4.4 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.4.4 (ClintAdams)
22:21:08 <purelazy1> @pl d yr = ((a  yr && b yr) || c yr)
22:21:09 <lambdabot> d = ap ((||) . liftM2 (&&) a b) c
22:23:31 <purelazy1> :ty ap
22:23:46 <purelazy1> :t ap
22:23:47 <lambdabot> Monad m => m (a -> b) -> m a -> m b
22:36:18 <dinoocch> How would I recursively reverse a list of lists: eg [[1,2],[3,4]] becomes [[4,3],[2,1]]...The problem is I can't differentiate between lists of values and lists of lists
22:37:05 <dinoocch> I've tried pattern matching and am currently muddling my way through class/instances, and I feel like I'm missing something obvious :(
22:39:47 <Rotaerk> dinoocch: map reverse . reverse?
22:40:05 <Rotaerk> oh you want it to handle arbitrary depth?
22:41:13 <dinoocch> yeah
22:41:14 <jle`> > map reverse (reverse [[1,2],[3,4]])
22:41:15 <lambdabot>  [[4,3],[2,1]]
22:41:23 <jle`> dinoocch: you're not really supposed to be able to distinguish, because of parametric polymorphism
22:42:09 <jle`> there are some convoluted ways to do this but in general it's not a very haskelly thing to do
22:42:40 <jle`> is there a specific use case you're thinking of, or is this just a learning exercise?
22:42:49 <dinoocch> I agree, and that's exactly what I'm finding...
22:43:43 <dinoocch> It's an assignment for a class ^^ I'm pretty sure the prof didn't realize what he was assigning
22:44:12 <jle`> hm
22:44:41 <jle`> yeah, the only thing you'd get out of doing this is how to hack around haskell's typeclass system in esoteric ways
22:45:58 <breadmonster> Guys,ghc 8?
22:46:09 <Rotaerk> how is that a question?
22:46:17 <aerialB> heh
22:46:20 <bitemyapp> Rotaerk: at least there was a question mark on the end
22:46:34 <breadmonster> Rotaerk: As in, is there another delay?
22:48:01 <jle`> hm, projected date is still listed as mid-feb, but there are still some bugs on the trac
22:56:22 <breadmonster> :(
22:57:17 <tippeneinn> anyone know a way to supply your own stack templates? https://github.com/commercialhaskell/stack-templates
22:58:44 <tippeneinn> oh, I suppose I'd have to use hi or something similar, https://github.com/fujimura/hi
23:00:26 <ahihi> dinoocch: one example of the convoluted ways to it: http://sprunge.us/aSHQ?hs
23:00:44 <ahihi> s/to/to do/
23:04:13 <dinoocch> ahihi: that's sort of what I had come to...it seems very hackish though
23:04:28 <ahihi> it is, and I would not recommend it :P
23:05:05 * hackagebot machinecell 3.1.0 - Arrow based stream transducers  https://hackage.haskell.org/package/machinecell-3.1.0 (HidenoriAzuma)
23:06:30 <purelazy1> :t liftM sqrt abs -16
23:06:31 <lambdabot> (Floating r, Num (r -> r)) => r -> r
23:06:43 <purelazy1> > liftM sqrt abs -16
23:06:45 <lambdabot>      No instance for (Typeable r0)
23:06:45 <lambdabot>        arising from a use of â€˜show_M38346592570174382166334â€™
23:06:45 <lambdabot>      In the expression:
23:07:57 <ahihi> > liftM sqrt abs (-16)
23:07:58 <lambdabot>  4.0
23:08:35 <breadmonster> ahihi: What monad is liftM operating in? o.O
23:08:46 <ahihi> (->) r
23:08:50 <ahihi> it's just function composition
23:13:06 <purelazy1> Its in Control.Monad
23:13:51 <purelazy1> Weird that -16 is OK for type, but not OK for evalutation
23:14:02 <jle`> > (sqrt . abs) (-16)
23:14:04 <lambdabot>  4.0
23:14:15 <ahihi> it parses as (liftM sqrt abs) - 16
23:14:29 <purelazy1> fmap sqrt abs (-16)
23:14:31 <ahihi> which is why you get the Num (r -> r) constraint
23:14:33 <purelazy1> > fmap sqrt abs (-16)
23:14:34 <lambdabot>  4.0
23:50:06 * hackagebot frown 0.6.2.3 - LALR(k) parser generator  https://hackage.haskell.org/package/frown-0.6.2.3 (MatthewFarkasDyck)
23:51:03 <ggVGc> I have two lists A and B of type [(k,v)]. I would like to get each element in B, for which either v differs or k doesn't exist at all
23:51:06 <ggVGc> what do I do?
23:52:45 <shachaf> You could do something like "filter (\(k,v) -> lookup k a /= Just v) b"
23:53:01 <shachaf> Of course that's pretty inefficient because it can traverse all of a for every element of b.
23:54:57 <HallaSurvivor> quit
23:57:22 <ggVGc> shachaf: yeah I was looking for something else
23:57:26 <ggVGc> should I used a dict?
23:57:28 <ggVGc> or sets?
23:57:33 <shachaf> You can use Map.
23:57:34 <ggVGc> I am not well versed in haskells data structures yet
23:57:42 <shachaf> @hackage containers
23:57:42 <lambdabot> http://hackage.haskell.org/package/containers
23:58:29 <shachaf> Something like "let a' = M.fromList a in filter (\(k,v) -> M.lookup k a' /= Just v) b"
23:58:40 <shachaf> For the simplest reasonably efficient thing you could write.
23:59:13 <shachaf> You can also e.g. sort a and then traverse a and b together.
