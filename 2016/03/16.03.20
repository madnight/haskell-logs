00:01:30 <EvanR> for connection passing, that is a good case for a Reader or ReaderT
00:02:29 <EvanR> then find citiesTable 0 can be a monadic action
00:04:55 * hackagebot bench 1.0.0 - Command-line benchmark tool  https://hackage.haskell.org/package/bench-1.0.0 (GabrielGonzalez)
00:15:16 <shanemikel> somebody have a copy of http://www.cs.vu.nl/Strafunski/gmap/gmap-1.0.tar.gz from the original SYB paper (2003)? links in the paper are down
00:15:31 <shanemikel> wayback machine doesn't have the gzips
00:16:53 <cocreature> is there a way to get a pointer to a (storable) vector that I am allowed to modify? all the functions under the raw pointer section (https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable.html#g:36) say that I’m not allowed to modify the data
00:16:59 <cocreature> I want to use it for ffi purposes
00:19:03 <shanemikel> I don't really need the originals, just code that works so I can follow along with the examples in each paper in succession
00:33:31 <EvanR> cocreature: you can the stuff in  Foreign.Marshal.Array to allocate a raw array of memory which works with storable
00:33:40 <EvanR> you can use the stuff*
00:34:57 <EvanR> unsafeToForeignPtr0 :: Storable a => Vector a -> (ForeignPtr a, Int) works on immutable vectors
00:35:03 <roelof> How can I the best refractor this : http://lpaste.net/155402
00:35:09 <EvanR> for example, thats why you cant modify it
00:36:02 <EvanR> dont indent so ridiculously far over?
00:36:22 <cocreature> EvanR: yeah that’s what I did, I thought there might be something that works for mutable vectors and allows me to modify it
00:36:29 <cocreature> but I found a better solution so it’s all good :)
00:36:31 <EvanR> (\x -> ceasar (read shift) x) = ceasar (read shift)
00:37:29 <roelof> thanks, and how do I deal with the duplication of the input ?
00:38:34 <EvanR> input? messages?
00:39:09 <EvanR> ah the entire do blocks are the same
00:39:18 <roelof> yep
00:39:18 <EvanR> you can literally cut them out and move them into a let or their own function
00:39:32 <EvanR> er, not a function, but a top level IO action
00:39:36 <roelof> almost, the text of the first question is a little bit different 
00:39:53 <EvanR> you can pass the single word that is different in as an argument ;)
00:40:06 <EvanR> lambda calculus ftw
00:40:31 <roelof> oke, I will experiment with it 
00:40:49 <roelof> I think I will go for their own function 
01:09:57 * hackagebot repa-scalar 4.2.1.1 - Scalar data types and conversions.  https://hackage.haskell.org/package/repa-scalar-4.2.1.1 (BenLippmeier)
01:36:45 <EvanR> i just figured out a proof of how it is impossible for monad to pronounced moe-nad with a long O sound
01:37:15 <EvanR> because the word comonad would be unpronouncable QED
01:38:11 <ggVGc> man, porting this little game from Elm to haskell, I start missing FRP the moment I wrote the type signature for my main loop
01:38:20 <ggVGc> guess I need to learn a haskell FRP lib now
01:38:28 <EvanR> i have been messing with gloss
01:38:43 <EvanR> they have 8 or so different main loop types, all pretty sensible
01:39:06 <EvanR> only 1 probably works for a video game though
01:39:15 <ggVGc> EvanR: my view is completely powered by GHCJS and CreateJS though
01:39:21 <ggVGc> and I make all art and composition in flash
01:39:41 <ggVGc> so my main loop will just listen to events and update the CreateJS scene graph
01:39:50 <EvanR> which is actually pretty big
01:40:26 <EvanR> thats an interesting take on it, use flash
01:40:58 <ggVGc> I have a lot of experience in this pipeline, and it's the best I know for creating content for web games
01:42:30 <ggVGc> EvanR: made this game two years ago, https://www.youtube.com/watch?v=XyTYXYexfGc The engine is all written from scratch in C and Lua, and the scenes are all created in Flash and exported to javascript with CreateJS. I then made a converter that translates the CreateJS javascript output into lua, and ported most of createjs to lua and wrote a renderer for it in OpenGL
01:42:44 <ggVGc> all in all it's just around 2k lines of C+Lua, so I think that's fine
01:43:00 <ggVGc> it was mostly an experiment while also releasing a hobby game, but it worked out great
01:43:29 <ggVGc> so now I'm continuing on that track, Flash+CreateJS for content creation, but writing the software in haskell and deploying as javascript instead
01:43:47 <ggVGc> which is nicer since I'm actually using the real CreateJS implementation now rather than my own port
01:44:13 <ggVGc> and haskell is a fair bit more fun than C+Lua
01:54:43 <ggVGc> so, I have a model that needs to be updated either by a time tick or by a callback in IO. Do I just have to keep an mvar of my model and have a timer thread modifying it, and have the callbacks modify the same mvar?
01:54:47 <ggVGc> is that the way?
01:57:19 <Adeon> that's one way yes
01:57:40 <ggVGc> sdboyer: what's another way?
01:57:45 <ggVGc> Adeon: ^
01:57:51 <ggVGc> sorry
01:58:23 <Adeon> depending on how you want it to compose or what operations you need it could be IORef or TVar instead
01:58:34 <ggVGc> yeah, but it'll have to be a mutable var?
01:58:42 <ggVGc> essentially if there are callbacks involved, it's mutable state eh
01:58:50 <Adeon> that depends how your program is structured
01:59:08 <Adeon> if you can do it the pure way that's great but those MVar things are hugely convenient as well
01:59:36 <Adeon> if your program does lots of IO things anyway shouldn't be a problem
01:59:37 <ggVGc> I dobn't even see how I could do it in a pure way
01:59:43 <Adeon> yeah just use MVar
01:59:43 <ggVGc> that's what I'm trying to understand
02:00:13 <ggVGc> any solution I can come up with will essentially just be a bad FRP implementation
02:00:21 <Adeon> ah yeah you mentioned callback in IO specifically
02:00:28 <Adeon> I don't think you even have any other solution if your callback is always IO
02:01:27 <ggVGc> Adeon: the situation is that I've got an external javascript library keeping a state of the current scene graph. I need to react to events from this javascript world, update my haskell model, and modify the external JS world again
02:01:33 <ggVGc> so yeah
02:02:08 <ggVGc> the way I see it my haskell model has to be mutable. Otherwise I don't know how to share it between the callbacks
02:02:23 <Adeon> yeah go for it
02:03:02 <ggVGc> I could build an event stream in JS, and process it in haskell, which would make the processing of events and updating of the world pure. But then it's just becoming FRP essentially eh?
02:03:18 <ggVGc> i.e handling the callbacks in JS and turning them into a stream
02:03:31 <Adeon> well I'm sure you could lay an FRP layer on it
02:03:45 <ggVGc> yeah I will at some point. but I don't have the time/energy atm to learn a haskell FRP lib
02:03:53 <Adeon> yeah it's not necessary really
02:04:09 <ggVGc> I am porting an Elm game, and Elm has FRP at the core. So now I need to rewrite the IO parts without FRP
02:04:15 <ggVGc> or bring in a haskell frp lib
02:04:23 <Adeon> are you using ghcjs?
02:04:26 <ggVGc> yeah
02:04:43 <ggVGc> pretty nice so far, except extreme lack of docs
02:04:48 <ggVGc> have had to read a fair amount of source
02:04:49 <ggVGc> which is fine
02:05:03 <Adeon> I kind of want to try reflex-dom with ghcjs
02:05:07 <Adeon> although
02:05:14 <Adeon> I'm not sure I believe in FRp
02:05:16 <Adeon> FRP*
02:05:31 <Adeon> at least not the flavour I've seen with haskell
02:05:39 <ggVGc> have to say I really am missing it now that I'm rewriting FRP code into this mess of mutability in IO and callbacks
02:05:51 <ggVGc> I've only done FRP in Elm, and it was actually great
02:06:25 <ggVGc> Adeon: thsi is my main for the Elm version of the game, https://gist.github.com/b28aee9425641b9bf1f8
02:06:35 <shanemikel> I've read some positive things about Keera Hails
02:06:51 <ggVGc> sorry, with syntax hl, https://gist.github.com/5f0320b70fabd1c5c8ca
02:06:53 <shanemikel> (though no experience with any FRP yet)
02:07:32 <ggVGc> so the whole mutable main state is just in a fold over a signal
02:07:34 <ggVGc> which is real nice
02:07:49 <ggVGc> which now turns into an MVar
02:08:26 <shanemikel> will you open source this so I can see what you're doing?
02:09:30 <ggVGc> shanemikel: the game in Elm? It's very small and unfinished and now being ported to haskell, so it's not that interesting
02:09:39 <ggVGc> you can have it if you want
02:10:09 <shanemikel> no, in haskell.. I'm really interested in ghcjs
02:10:31 <shanemikel> but yeah, the elm game too, I'll compare your frp to the haskell implementation
02:10:48 <ggVGc> ah, yeah, I could put it on github. but for now it's just very early beginnings
02:13:13 <shanemikel> i'm not a critic :).. I'm really new to this "build your own tooling and frameworks" ideology; it sounds like it's working rather well for you so far
02:14:33 <ggVGc> shanemikel: http://tinyurl.com/wdrop/elm_game.zip
02:17:04 <shanemikel> cool
02:18:42 <ggVGc> not sure how useful that is to look at, but it's the basis of a working FRP program
02:18:54 <ggVGc> I am switchign to haskell becauase I want to write a server for it
02:19:05 <ggVGc> and want to share the model between client and server
02:19:14 <ggVGc> and also, haskell is a lot nicer to work in than elm
02:19:22 <ggVGc> and ghcjs is actually pretty good now
02:20:00 <shanemikel> yeah, and you could distribute a "native" version that way easier I would guess
02:20:45 <shanemikel> I think there are haskell libs similar to github's 'electron'
02:20:54 <shanemikel> or, at least there's webkit
02:21:53 <shanemikel> nvm.. acutally that would be easier with elm
02:22:13 <shanemikel> + nodejs
02:24:43 <shanemikel> you know, I'm pretty sure the elm compiler is written in haskell.. so it probably has a nice parser with haskell datatypes corresponding to elm types.. in which case there might be another angle.. but I don't know
02:24:58 <shanemikel> if that's realistic
02:25:00 * hackagebot servant-JuicyPixels 0.3.0.1 - Servant support for JuicyPixels  https://hackage.haskell.org/package/servant-JuicyPixels-0.3.0.1 (TvH)
02:25:59 <shanemikel> they don't have a haskell-based interpreter?
02:29:36 <shanemikel> ggVGc: if you don't want to open-source the haskell port, (just putting it out there, no pressure) I would respect your IP if you added me to a private repo
02:41:35 <EvanR> ggVGc: whats pure and whats not is sometimes clouded in haskell because when you start out anything involving IO (the type) must be not pure, which isnt true
02:43:11 <EvanR> and at the same time all IO code is actually pure, which confuses things
02:43:47 <EvanR> but what youre looking for is a nicer language whose semantics matches whatever the semantics are youre trying to do
02:44:57 <EvanR> mutating javascript thingies is a means but not an end
02:49:08 <Akii> hmm what's the name of things like that: {-# LANGUAGE TypeFamilies #-}
02:49:53 <EvanR> a pragma
02:51:03 <Akii> thanks
03:05:37 <shanemikel> EvanR: you're suggesting for him to design a DSL, EDSL or Monad or other abstract control type?
03:05:50 <shanemikel> or suggesting to move away from haskell?
03:06:10 <shanemikel> (the use of the word language is rather ambiguous)
03:33:43 <lpaste> montanonic pasted “Esqueleto hell” at http://lpaste.net/5262883921850269696
03:34:45 <montanonic> I've been banging my ahead against resolving that issue for a while now. Other repositories that use Esqueleto in very similar ways don't seem to have that func dep issue. I'm just, so lost...
03:50:43 <aramiscd> say hi, i have simple question, consider this:
03:50:46 <aramiscd> data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)
03:51:15 <aramiscd> how can i influnce what the show method will give?
03:51:29 <aramiscd> say i'd say i have to write data List a = Empty | Cons a (List a) deriving (Read, Eq, Ord)
03:51:42 <aramiscd> and than give my own instance declarations like
03:52:08 <aramiscd> instance Show List where show Empty = "[]"
03:52:10 <aramiscd> and so on
03:52:22 <aramiscd> but i have on issue with that
03:53:02 <aramiscd> when i derive from Show it is guaranteed that all objects of type a are also of the type class show
03:53:30 <aramiscd> but when i write my own instace declarations i have no way to put that in a signature
03:55:02 <pavonia> aramiscd: You have: instance Show a => Show (List a) where ...
03:55:43 <aramiscd> right
03:56:34 <mniip> aramiscd, if you do that, you'll be able to use a's Show from the implementation of List a's show
03:56:58 <aramiscd> say that's what i needed: type constraints for instance declarations, thank you very much
03:59:42 <cocreature> montanonic: I’m not too familiar with esqueleto, if you have a compilable example I can take a look (well something that should compile without the error)
04:50:05 <amuzzi> ?
04:52:49 <pavonia> That's a tough question
04:54:29 <amuzzi> it's matter of thought
04:55:36 <pavonia> Thinking about it, the answer probably is ⊥
05:15:25 * hackagebot casr-logbook 0.0.4 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.0.4 (TonyMorris)
05:18:00 <amuzzi> so do people actually talk in here?
05:33:36 <padre_angolano> only in case of emergency
05:34:34 <hpc> if it's a legitimate discussion the channel has ways of shutting it down
06:02:48 <shapr> good morning!
06:04:30 <shapr> Anyone used the github api library lately?
06:40:32 * hackagebot lackey 0.2.0 - Generate Ruby consumers of Servant APIs.  https://hackage.haskell.org/package/lackey-0.2.0 (fozworth)
06:44:14 <sal23> does GHC.Generics provide any easy way to get the name of the fields in record syntax, and also those fields (which are actually functions)? I see selName function but not sure if it is straightforward to use
06:52:27 <d-snp> jeez Haskell is not being cooperative, I'm debugging something and it won't show a simple data type giving the error:        uncaught exception: NonTermination (<<loop>>)
06:52:58 <d-snp> it's just a record that derives Show, no custom implementations or anything
06:58:46 <shapr> d-snp: paste the code on lpaste?
06:59:36 <d-snp> it has loads of context
07:00:59 <dfkfj> hello
07:03:59 <d-snp> shapr: http://lpaste.net/155531 
07:04:21 <d-snp> I think for some reason the type is recursive, though I'm not sure how that could happen
07:04:51 <dfkfj> is there an idiom for having trace to print out the evaluation value? 90% of the time that's all i'm looking to do
07:05:35 <d-snp> I mean, there's a chance it's a StructureType, which has a Type elementTypes field, but I don't see how you could construct an infinite one, or how that would occur in my code
07:09:04 <cocreature> d-snp: let resultType' = QualifiedType (Ptr resultType') defaultTypeQualifiers -- there is your loop
07:10:43 <dfkfj> is there a haskell package for modeling petri nets?
07:11:14 <cocreature> dfkfj: there is traceShowId
07:11:39 <dfkfj> cocreature excellent thanks
07:12:39 <dfkfj> now if only there was a version with line numbers =P
07:12:49 <dfkfj> oh well
07:19:30 <d-snp> cocreature: oh jeez
07:19:53 <d-snp> I'm an idiot :D
07:20:07 <cocreature> nah, I make that mistake all the time
07:20:29 <cocreature> that’s imho one of the nice things about ml, you need to declare recursive lets explicitely
07:28:47 <eyepatch> Is there a better way to do this? I don't like having to make an alias for complement just because I need to specify a type. http://lpaste.net/155532
07:32:03 <raek> eyepatch: one way to do it is "interact (unlines . map (show . (complement :: Word32 -> Word32) . read) . tail . lines)"
07:32:21 <eyepatch> Ah. That's what I was looking for, thanks!
07:40:10 <orion> If I have a newtype Foo = Foo [Text] and I want to write a function mergeFoo :: [Foo] -> Foo, what pattern match would be necessary?
07:40:30 <orion> Or is there a way to do it without pattern matching?
07:42:55 <Peaker> I wonder why the excellent-looking https://hackage.haskell.org/package/control-monad-exception didn't catch on
07:49:49 <orion> Actually, what does foo (Foo f:fs) mean? Does fs get unwrapped in addition to f?
07:49:53 <lyxia> orion: coercion
07:50:11 <lyxia> orion: that's foo ((Foo f):fs)
07:50:31 <lyxia> only the head is unwrapped here
07:50:33 <orion> ah ok, thanks.
07:52:13 <orion> lyxia: So if I understand correctly, given newtype Foo = Foo [Text], mergeFoo :: [Foo] -> Foo can be defined as, "concat . coerce", correct?
07:53:03 <lyxia> coerce concat
07:53:10 <lyxia> or coerce . concat . coerce
07:53:16 <lyxia> with some type annotations I guess
07:53:37 <orion> hmm
07:53:51 <lyxia> Foo . concat . coerce
07:54:22 <lyxia> the one coerce you wrote is the most "useful" one
07:54:36 <lyxia> but you still need to convert back to a Foo
07:54:46 <orion> Doesn't typecheck for me. :(
07:55:12 <orion> Couldn't match representation of type ‘t0 [Text]’ with that of ‘[Foo]’ Relevant role signatures: type role [] representational
07:55:26 <lyxia> coerce (concat :: [[Text]] -> [Text])
07:55:40 <lyxia> yeah coerce needs its argument to have a very precise type
07:55:56 <orion> I see.
07:56:05 <lyxia> because instance resolution doesn't do unification, something like that
07:56:28 <orion> Works, thanks!
07:58:02 <lyxia> yw
08:20:57 <pwned> hi, can I use haskell as a fast alternative to ruby with less quirks than c++ ?
08:21:46 <obadz> pwned: or a slow alternative to C++ with less quirks than ruby
08:23:21 <pwned> I use ruby for data processing but sometimes it is dog slow and rewriting in c++ just takes too much energy (but in the end it works super fast)
08:23:32 <pwned> I was just looking for a saner language which is both succint and fast
08:23:42 <obadz> pwned: I think Haskell fits the bill
08:24:44 <obadz> pwned: only danger is once you become proficient you won't want to touch other languages…
08:27:14 <lambda-11235> obadz: I now feel that other languages (c, c++, ...) have broken type systems, as far as type theory is concerned.
08:27:38 <obadz> I rest my case ;-)
08:34:57 <pwned> lambda-11235: is haskell's type system going to save me from thinking about efficiency, optimization and language quirks all the time?
08:35:14 <maerwald> pwned: uhm
08:35:23 <maerwald> I'd say no
08:35:27 <pwned> :-(
08:35:33 <maerwald> it saves you from certain classes of bugs though
08:35:37 <obadz> pwned: haskell's type system is going to save you from many bugs
08:35:39 <maerwald> but also only if you use sane types
08:35:46 <obadz> pwned: and enable you to think constructively about your problem
08:36:03 <obadz> pwned: but efficiency is still responsibility of programmer
08:36:13 <maerwald> e.g. most haskell libraries and applications still use "String" for file paths... which sort of renders the advantages of the type system useless for that problem
08:36:44 <maerwald> you have to actually make use of it
08:36:54 <obadz> pwned: type system won't warn you that your algorithm is O(n²) when it could be O(n log n)
08:37:30 <obadz> maerwald: you mean they use the FilePath alias?
08:37:33 <cbopt> Hey! I've been trying out Write Yourself a Scheme tutorial. However, I couldn't understand this line of code in second chapter.
08:37:35 <cbopt> It's parseNumber = liftM (Number . read) $ many1 digit
08:37:39 <maerwald> obadz: that's a String yes
08:37:59 <obadz> maerwald: yes but it's at least "documented" as a path by the alias
08:38:11 <maerwald> that's irrelevant, it's still a weak type
08:38:20 <pwned> I'm thinking about classes of problems where you would choose between lazy iteration or iterating over arrays of data. Or perhaps different ways of concatenating arrays. Does that even make sense in haskell?
08:38:42 <obadz> cbopt: many1 digit is a Parser from String to String that only lets a sequence of at least 1 digits through
08:39:09 <maerwald> the path can be absolute or not, it can end in a trailing path separator or not, it can describe a file, a dir... it can simply be invalid, malicious, normalized, not normalized....
08:39:15 <maerwald> and a hundred things more String doesn't tell you
08:39:31 <obadz> cbopt: read will take a sequence of digits and turn them into a pre-specified type that must implement the Read type class
08:40:08 <cbopt> abadz: Okay. And what is liftM doing?
08:40:14 <obadz> :t liftM
08:40:15 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:40:36 <lambda-11235> cbopt: liftM is also like fmap, you could also write it as do { x <- many1 digit; Number (read x) }.
08:40:52 <obadz> cbopt: in this case, its type signature is (String -> Int) -> Parser String -> Parser Int
08:41:11 <obadz> cbopt: it "lifts" the read function into the Parser monad
08:41:24 <cbopt> Ah! I see. Makes sense now.
08:41:33 <cbopt> abadz: thanks
08:42:24 <dfkfj> looking for some advice, I'm setting up some mathematical models and simulations. Would you define model parameters in terms of a Data.Map or a type?
08:43:10 <obadz> the String → Int function is the read function specialized for Integer. It knows that because Number is a type constructor for a LispVal whose type signature is Integer → LispVal
08:43:20 <obadz> so actually liftM here does this:
08:43:52 <obadz> (String → LispVal) → Parser String → Parser LispVal
08:45:07 <cbopt> Perfect! Got it.
08:45:16 <pwned> can I evaluate something with lambdabot?
08:45:35 <obadz> > putStrLn "pwned: yes"
08:45:37 <lambdabot>  <IO ()>
08:45:51 <obadz> Apparently it doesn't spit out stdout ;-)
08:45:59 <pwned> [x*2 | x <- [1..10], x*2 >= 12]  
08:46:07 <obadz> needs the '>'
08:46:08 <adamCS> dfkfj:  I think I would always try to make it work with a type.  So if you have different models requiring different sets parameters you will be checking i f you are passing the correct ones at compile time.  Saves all sorts of runtime checking and confusing bugs.  And it will be clearer to read, I think.
08:46:12 <pwned> > [x*2 | x <- [1..10], x*2 >= 12]  
08:46:14 <lambdabot>  [12,14,16,18,20]
08:46:19 <pwned> that's so geeky
08:46:41 <obadz> you can also do via private message if you don't want to spam the channel
08:47:02 <dfkfj> adamCS yeah, but it's less general/flexible in some ways right? if i want to change the model implementation, it's all code rather than data
08:47:17 <pwned> spam not unto others as they've not spammed you
08:48:43 <adamCS> dfkfj:  Yes.  But I think that's flexibility you will overpay for.  Hard to know until you do it.  Refactoring if you add a field to a type is pretty easya s well.  One thing that might help is to access your parameter type fields via record selectors functions (or lenses) instead of pattern matching. That way you don't break much if the layout of those types changes.
08:49:32 <pwned> I heard facebook uses haskell to stop spam
08:49:46 <dfkfj> pwned yes
08:50:02 <dfkfj> pwned https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/
08:50:03 <xa0> it's great for that kind of dataflow thing
08:50:14 <pwned> I love dataflow things, too. 
08:50:36 <dfkfj> xa0 which makes me sad that the data science / analytics ecosystem in haskell is not better than it is :(
08:50:54 <xa0> yeah :(
08:51:26 <pwned> is haskell, like, orthogonal so there's not many ways of doing the same thing?
08:51:42 <obadz> dfkfj: not a fatality… roll up your sleeves ☺
08:52:05 <dfkfj> obadz i'm trying, but i'm still a relative beginner. we need more boots on the ground.
08:54:09 <hexagoxel> eh, (const foo) is (id$> foo). another character saved!
08:54:32 <ggole> let k = const and save more
08:54:49 <ggole> In fact, why not just program in APL?
08:55:12 <pwned> what is the type of k if you let k = const ?
08:55:48 <ggole> The same?
08:55:52 <hexagoxel> ggole: the difference is whether i (have to) extend my Prelude or not.
08:56:03 <ggole> Oh, I suppose that may have changed recently
08:56:31 <hexagoxel> (and no, i won't really use that unreadable shortcut for one char :p)
08:57:11 <dfkfj> geez realizing that functors aren't introduced until ~page 600 of the haskell book. talk about deliberate pacing
08:58:36 <pwned> I am looking for a book that starts with file IO. I can learn about list comprehensions and ranges later.
08:59:33 <Pennyw95> dfkfj: which book?
08:59:37 <pwned> hwo do you even do async callbacks with this thing it's so alien
09:00:27 <dfkfj> Pennyw95 the haskell book ;)
09:00:50 <dfkfj> Pennyw95 i.e. Chris Allen's book
09:01:15 <liste> pwned: `bracket' is one function which uses async callbacks
09:01:17 <Pennyw95> thanks :)
09:01:17 <liste> :t bracket
09:01:18 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:01:33 <dfkfj> Pennyw95 if you're not familiar with it, it's what you should be learning haskell from
09:01:46 <dfkfj> urgh feeling like i'm writing a lot of generics-esque boilerplate right now, but I don't know how to write generics yet.
09:01:46 <Pennyw95> I already read LYAH, I'm just looking for more
09:02:36 <dfkfj> Pennyw95 oh you should definitely go to haskellbook.com you'll have a much deeper understanding than LYAH
09:03:03 <dfkfj> i've said it before, but I think LYAH may do more harm than good
09:03:15 <obadz> pwned: http://learnyouahaskell.com/input-and-output
09:04:29 <pwned> wait putstrln strnig is part of the type?!
09:05:04 <Iceland_jack> :t putStrLn
09:05:05 <lambdabot> String -> IO ()
09:05:09 <Pennyw95> money tho xD
09:06:44 <pwned> :t *
09:06:46 <lambdabot> parse error on input ‘*’
09:06:56 <pwned> :t (*)
09:06:57 <lambdabot> Num a => a -> a -> a
09:07:01 <pwned> \o/
09:07:16 <hpc> :k Int
09:07:17 <lambdabot> *
09:07:20 <pwned> I am a haskell expert!!
09:07:25 <hpc> int :: * :: Num a => a -> a -> a
09:07:29 <hpc> next level haskell
09:07:41 <obadz> hpc: sneaky
09:08:28 <pwned> what's all that ::
09:09:04 <hpc> secret sauce
09:09:10 <pwned> is Num float or integer if float what precision? I am so confused
09:09:42 <Pennyw95> pwned: :: is like = but for a function's type
09:09:59 <obadz> pwned: Num is a typeclass (think interface)
09:10:12 <lambda-11235> hpc: What is int?
09:10:26 <obadz> pwned: anything that implements (+) / (-) / (*) / abs and a few others functions (and abides by certain laws) is a Num
09:11:33 <obadz> pwned: includes Int, Float, Double, Rational, etc…
09:11:52 <pwned> I take my numbers very seriously.
09:12:09 <obadz> pwned: then you'll like Haskell. No implicit casts.
09:25:00 <dfkfj> Pennyw95 your learning time is worth more than the amount the book costs
09:25:07 <dfkfj> oops split
09:25:38 * hackagebot airship 0.5.0 - A Webmachine-inspired HTTP library  https://hackage.haskell.org/package/airship-0.5.0 (reiddraper)
09:27:44 <dfkfj> man it's taking friction to switch from repl driven development mindset to haskell
09:28:19 <nitrix> dfkfj: I use the repl a lot. I don't see which friction you refer to.
09:29:00 <dfkfj> nitrix i do too, but it's not quite the same
09:29:17 <int-e> well, you have to get used to writing the code in a file and using :r ... rather than defining functions directly in the repl
09:29:27 <dfkfj> languages that are designed around repl workflows
09:29:31 <tippenein> Suggestions where to look to fix this? Bad interface file: $HOME/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/base_HQfYBxpPvuw8OunzQu6JGM/System/Environment.hi mismatched interface file versions (wanted "7102", got "7103")
09:29:52 <tippenein> I removed the .stack-work directory but that does nothing
09:29:57 <statusfailed> What's that extension that automatically puts all the fields of a record in scope? I think you can type something like foo :: MyRecord -> Int; foo {} = field1 + field2, where "field1" and "field2" are fields of MyRecord
09:30:02 <dfkfj> nitrix optimize around certain things. one example is pretty printing is critical to the interface instead of an afterthought
09:30:14 <nitrix> int-e: Or just --file-watch
09:30:28 <dfkfj> eg how matrices are printed in python or R vs.
09:30:35 <geekosaur> statusfailed, RecordWildcards and use {..}
09:30:37 <dfkfj> in repa
09:30:38 <int-e> tippenein: that sounds like you're trying to use ghc-7.10.2 with libraries compiled for ghc-7.10.3
09:30:52 <statusfailed> geekosaur: noice, ty!
09:31:22 <dfkfj> or how it's pretty fluid to inspect within a context
09:31:25 <dfkfj> of state
09:31:54 <dfkfj> eg play with the repl within the frame of a function.
09:32:08 <dfkfj> in haskell, that's tricky
09:33:22 <dfkfj> even automatically populating the repl monad state on a source reload
09:33:34 <dfkfj> can only be done as far as i can tell with editor macro copy/paste hacks
09:36:56 <tippenein> ah, it looks like it might just be a ghc-mod thing. The package compiled with stack
09:37:01 <tippenein> so, stack is using 7.10.3 but system ghc is 7.10.2
09:45:38 * hackagebot pandoc 1.17 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.17 (JohnMacFarlane)
10:14:39 <klop> argh lag in spacemacs is killin me. almost ready to switch over to atom
10:19:50 <Zemyla> Heh. Someone in a thread I'm in said, "Haskell is good. Haskell is also bad, but it's bad in refreshingly different ways."
10:21:37 <klop> Zemyla the worst things about haskell for me are sociological / ecoystem related issues
10:22:25 <klop> as in if haskell had a userbase the size of python or javascript, they would solve themselves
10:24:46 <kap> hey guys, if I install the Haskell Platform from Ubuntu's repos I am not going to get the latest right?
10:25:03 <klop> kap i'd recommend against using the haskell platform
10:25:09 <klop> kap install with stack instead
10:26:54 <kap> ok then, what is the better way for that, I will basically need REPL for starters and maybe cabal later on
10:28:07 <maerwald> Zemyla: wonder if he actually meant haskell or ghc
10:28:41 <kap> klop I went for the source but I need another haskell for compiling it :D
10:30:32 <kap> klop: can I PM you for further help?
10:50:23 <pwned> hey thanks for the information
10:50:41 * hackagebot vivid 0.2.0.4 - Sound synthesis with SuperCollider  https://hackage.haskell.org/package/vivid-0.2.0.4 (TomMurphy)
10:53:20 <telmich> good evening
10:53:48 <telmich> I'm trying to understand the type system of haskell and thought I understood type classes; however when inspecting foldr, I see: foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
10:53:58 <telmich> what does the "t" next to the "a" stand for?
10:55:41 * hackagebot pagerduty 0.0.7 - Client library for PagerDuty Integration and REST APIs.  https://hackage.haskell.org/package/pagerduty-0.0.7 (BrendanHay)
10:56:46 <kap> telmich, not an expert either but t is probably exactly the type class Foldable
10:57:16 <Iceland_jack> telmich: Try understanding 'length' first
10:57:19 <Iceland_jack> :t length
10:57:21 <lambdabot> Foldable t => t a -> Int
10:57:25 <Iceland_jack> and replace "t a" with []a
10:57:27 <Iceland_jack> *[a]
10:57:30 <Iceland_jack> :t length :: [a] -> Int
10:57:31 <lambdabot> [a] -> Int
10:57:37 <Iceland_jack> or "Maybe a"
10:57:44 <Iceland_jack> :t length :: Maybe a -> Int
10:57:45 <lambdabot> Maybe a -> Int
10:57:53 <kap> yes Maybe a is a good equivalent
10:58:45 <Iceland_jack> First is
10:58:45 <Iceland_jack>     length :: [a] -> Int
10:58:45 <Iceland_jack>     length []     = 0
10:58:45 <Iceland_jack>     length (_:xs) = 1 + length xs
10:58:48 <Iceland_jack> second is
10:58:50 <Iceland_jack>     length :: Maybe a -> Int
10:58:54 <Iceland_jack>     length Nothing  = 0
10:58:57 <Iceland_jack>     length (Just _) = 1
10:59:05 <hexagoxel> telmich: both "t" and "a" are type variables. i recommend http://takenobu-hs.github.io/downloads/type_introduction_illustrated.pdf
10:59:15 <hexagoxel> (if you don't mind the comic sans .. :p)
10:59:54 <kap> hexagoxel, nice!
11:00:44 <Zemyla> How difficult is it to make values that present as immutable but are secretly mutable?
11:02:19 <Zemyla> Like, in attoparsec, the author uses a type for a buffer that is basically an array that can be snoced in amortized O(1) time.
11:04:29 <telmich> hexagoxel: thanks a lot!
11:04:54 <telmich> Iceland_jack: I see
11:05:02 <telmich> and sorry for the late reply, my connection here sucks a bit
11:06:18 <breadmonster> Hello.
11:13:12 <breadmonster> Why is the next ghc 8.0?
11:13:22 <breadmonster> What was the killer feature that resulted in a supermajor release?
11:15:32 <geekosaur> unified types and kinds, I think
11:16:14 <geekosaur> i.e. not a "killer feature" (user-visible) but fairly major implementation change
11:16:44 <roelof> any feedback on this solution : http://lpaste.net/155541
11:17:34 <breadmonster> geekosaur: Ah okay.
11:17:42 <breadmonster> I thought we finished implementing AMP.
11:17:53 <breadmonster> WAIT WHAT UNIFIED TYPES AND KINDS? o.O
11:20:23 <geekosaur> long story but I think it's the first step on the road to DependentHaskell?
11:20:42 * hackagebot morte 1.5.0 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.5.0 (GabrielGonzalez)
11:20:49 <cocreature> now we only need to figure out the value level :)
11:21:19 <Akii> anyone here that has experience with event sourcing in haskell? :D
11:22:13 <klop2> allo
11:22:14 <hexagoxel> breadmonster: because type classes are relatively well understood by now, the designers thought that kind classes are a neat idea to confuse beginners/everyone.
11:22:55 <klop2> can i use either generics or lens to auto-generate a toList on a record
11:23:14 <klop2> (where all the fields are of the same type)
11:23:16 <klop2> without the boilerplate?
11:23:32 <ertes> klop2: you can derive Foldable
11:23:49 <ertes> if that same type is parametric
11:24:29 <ertes> otherwise DeriveGeneric is probably the way to go
11:25:16 <klop2> ertes how would foldable work. There's no type parameter (the fields are all doubles)
11:25:30 <ertes> making the type parametric is definitely the most convenient way, because it gives you a lot for free
11:25:42 <ertes> like fmap, Foldable, Traversable, etc.
11:27:39 <klop2> ertes hmm maybe. i'm using this type with HMatrix for simulations though
11:27:49 <klop2> at which point a lot has to commit to things like [Double]
11:27:51 <klop2> unfortunately
11:27:55 <portnov> hi all
11:28:07 <portnov> any cmdargs specialists here? :)
11:28:16 <ertes> klop2: that shouldn't be any trouble, because where you currently use T, you can then just use T Double
11:28:38 <portnov> Q: how to define optional positional argument? 
11:28:41 <ertes> klop2: and for your convenience, if you don't have T Double right now, you can use fmap to make it Double
11:29:43 <klop2> ertes hmm deriving foldable requires an extension?
11:30:04 <ertes> klop2: yeah, pretty much all boilerplate-savers require extensions
11:31:11 <tm`> I've got a package (hackage.haskell.org/package/vivid) whose "front-page" haddock code (for example usage) isn't building right on hackage (tho it's building right locally) -- anyone know why that is?
11:32:44 <klop2> ertes hey this is pretty cool
11:32:59 <ertes> tm`: my guess is that you need an empty line between the @-block and the verbatim code block
11:33:33 <ertes> tm`: @this@ is inline formatting, so your whole @-block is really a paragraph containing only an inline code block
11:34:00 <tm`> ertes: k I'll try that (although it's strange it's building fine locally but not on hackage)
11:34:18 <klop2> oh wow
11:35:07 <ertes> klop2: note: you can usually write an Applicative instance for such a type with zipWith semantics…  that also gives you the usual applicative combinators for free =)
11:35:34 <klop2> ertes what's the idiom for converting a foldable type to a list?
11:36:02 <ertes> klop2: well, there is toList from Data.Foldable, or i'm misunderstanding your question
11:36:30 <ertes> does hmatrix really work with lists?  that seems strange
11:37:07 <klop2> ertes well hmatrix-gsl does at least. it's _really_ hacky :(
11:37:21 <roelof> any feedback on this solution : http://lpaste.net/155541
11:37:22 <klop2> ertes but there's nothing else out there that does ordinary differential equations :'(
11:37:43 <ertes> i see
11:38:17 <puregreen> ertes: hm, I use @@ for paragraphs all the time and I've never had any problems with it
11:38:22 <ertes> that's really strange, because going through lists and then back to some FFI-compatible structure is bound to be unnecessarily slow
11:38:41 <ertes> puregreen: that's fine, as long as you remember that it's a paragraph and you leave empty lines around it
11:38:52 <puregreen> ah, well, yep
11:38:54 <ertes> puregreen: but in those cases you could just as well use an actual code block
11:39:13 <klop2> ertes look at this - it makes me cry http://hackage.haskell.org/package/hmatrix-gsl-0.16.0.2/candidate/docs/Numeric-GSL-ODE.html
11:39:18 <puregreen> I think I can't link to identifiers in > code blocks
11:40:12 <klop2> ertes yeah, especially because i need to run the ODE within MCMC. but i'm not ready to give up and go python yet...
11:40:17 <ertes> roelof: i'm using a prism for accessing letters in their modular integer form
11:40:47 <ertes> uhm, sorry
11:40:51 <ertes> a traversal, not a prism
11:41:16 <roelof> ertes:  what is a prism. I have to learn  monads still. IM following the haskell book of bitemyapp 
11:42:22 <ertes> roelof: oh, it's about lenses…  if you're a beginner, then nevermind for now =)
11:42:26 <tm`> ertes: that was it, thanks
11:42:40 <ertes> roelof: but if you're interested anyway, this is my code: http://lpaste.net/155543
11:42:42 <roelof> oke, IM a beginner 
11:43:22 <klop2> roelof yeah for beginners (like myself) lenses are basically fancy accessors
11:43:26 <ertes> klop2: i wouldn't resort to python for that…  i'd probably either figure out a way to make the binding myself, or reimplement the algorithms i need in haskell
11:43:29 <roelof> ertes: thanks 
11:43:34 <ph88> anyone know how i can fix this error in my parser ? https://www.pastery.net/xcgjdc/
11:44:13 <ertes> roelof: those definitions allow you to traverse a text layer by layer
11:44:30 <ph88> fix highlighting: https://www.pastery.net/uuzgpt/
11:44:36 <klop2> ertes i'd do more of that if i had time, but this is for corporate R&D. i'm limited in the degree to which i can hold up scientific work
11:44:58 <klop2> so that i can write and optimize my own runge kutta method in haskell..
11:45:00 <roelof> oke, and a layer can be all the characters of a string  or all the sentences in a text ? 
11:45:15 <klop2> i'm hopeful of ocramz's petsc work
11:45:33 <klop2> but it sounds like that's still going to be a while
11:45:39 <koomi> so ghc 7.6.3 is appearently running into an infinite loop when compiling some code I'm working on (always fails with a stack overflow, no matter how big I make the stack)
11:46:03 <ertes> klop2: yeah, i know the problem
11:46:04 <koomi> any tips on debugging this without recompiling ghc?
11:46:23 <ertes> klop2: it's not that it's going to be unusable, but you will definitely give up some performance
11:47:25 <klop2> ertes yeah, i'm  a bit in limbo between limited amount of time to reinvent wheels and living with suboptimal design decisions of hmatrix
11:47:52 <ertes> roelof: example: T.pack "this is my plaintext" & textBlocks 3 . ix 0 . alpha +~ 3
11:48:06 <ertes> this rotates the first character in each 3-block by 3
11:48:19 <ertes> but only if it's a letter
11:48:38 <ertes> roelof: lenses are fancy, but they need getting used to, especially writing them
11:49:42 <ertes> klop2: well, the interfacing will be unnecessarily slow, but the algorithms themselves are still fast
11:50:00 <ertes> klop2: if most of the time is spent computing, it shouldn't be too bad
11:50:12 <ertes> still a bad API choice in my opinion
11:50:34 <klop2> i suspect the interfacing will bite me in the ass when the simulations are run millions of times within MCMC chains
11:51:38 <ertes> klop2: possibly…  i would expect the main interface bottleneck to be the haskell→matrix part, because it needs to construct an array from the incoming list, which probably was already an array to begin with
11:51:52 <ertes> in other words you're paying an extra memcpy
11:52:27 <ertes> if you need to store the result as yet another array (as opposed to for example simply folding directly), then you're going to pay another one
11:54:45 <ertes> memcpy by itself is a very fast operation, but it pretty much completely destroys the short-term caches
11:55:01 <ertes> L1 is gone, and depending on the size, probably L2, too
11:58:03 <charco> Hi
11:58:11 <charco> if I do :t (-) I get Num a => a -> a -> a, but if I put test = (-) in a file, and then do :t test I get Integer -> Integer -> Integer, why is that behavior?
11:58:13 <klop2> ertes yeah it's unfortunate. i wish there were more mathematical simulation options available.
12:00:25 <ertes> charco: you should write a type signature for top-level definitions, otherwise they use defaulting like local definitions
12:00:32 <klop2> can i do fmap on this Foldable instance somehow?
12:01:04 <ertes> klop2: Foldable cannot express maps; you need Traversable for that, but it's better to derive Functor and use fmap directly
12:01:22 <klop2> ah yes just tried it
12:01:25 <klop2> DeriveFunctor works
12:01:30 <klop2> like a charm
12:01:54 <ertes> DeriveFunctor works in almost all cases, even if you have functions in your fields
12:01:54 <klop2> pretty sweet extension magic :D
12:02:39 <klop2> goodbye boilerplate code.
12:03:07 <charco> I got disconnected :(
12:03:12 <charco> if I do :t (-) I get Num a => a -> a -> a, but if I put test = (-) in a file, and then do :t test I get Integer -> Integer -> Integer, why is that behavior?
12:03:31 <ertes> klop2: even this works:  newtype F a = F (forall r. (a -> r) -> r) deriving (Functor)
12:03:51 <ertes> as long as the 'a' is not in argument position, you can derive Functor
12:04:12 <klop2> that hurts my newbie head a bit
12:04:14 <Cale> charco: Because the monomorphism restriction applies to your pattern binding for test. If you add explicit function parameters to the definition, or if you add an explicit type signature, or if you put {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file, that won't happen.
12:04:17 <ertes> charco: you should write a type signature for top-level definitions, otherwise they use defaulting like local definitions
12:04:19 <klop2> haven't made that much use of forall yet
12:04:38 <Cale> Yeah, and the MR here triggers numeric defaulting to occur
12:04:58 <charco> Cale: so if I don't add type information, it will default to Integer instead of Num a ?
12:05:48 <ertes> klop2: use this then: newtype F r a = F ((a -> r) -> r)
12:05:50 <charco> ertes, Cale but why Integer instead of int? and why on file load and not when I do let test = flip (-) ?
12:06:05 <Cale> charco: Well, it's more subtle than that -- normally it would let the Num a => a -> a -> a type go through just fine, and that is the initially inferred type for the thing. But there's a somewhat questionable and arbitrary restriction which says that pattern bindings that don't have an explicit type signature are not allowed to be type class polymorphic
12:06:35 <charco> I see. Do you know where can I read more about that Cale?
12:06:45 <Cale> The Report would be the best place... one sec
12:06:59 <klop2> ertes this is great
12:07:29 <drw_> @pl fun2 = n | n == 1 = 0 | even n = n + fun2 (n `div` 2) | otherwise = fun2 (3 * n + 1)
12:07:29 <lambdabot> (line 1, column 20):
12:07:29 <lambdabot> unexpected " "
12:07:29 <lambdabot> expecting operator
12:07:34 <Cale> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5
12:07:49 <smwentum> hi
12:07:52 <ertes> klop2: (it's Cont in disguise, but that's not important…  i'm just showing that DeriveFunctor, if it should work, it usually does)
12:08:25 <ertes> klop2: there are some edge cases (existential types), but i've only hit them once and had to write a manual Functor instance
12:08:41 <Cale> charco: Basically, it's a somewhat silly restriction to prevent people from writing programs which would perform worse than they might appear. When you write something which looks like a definition of a constant, you might expect it to be evaluated once and the result stored for subsequent uses.
12:09:12 <Cale> charco: But if it's actually type class polymorphic, that means it's secretly a function of the type class dictionary, and the result won't be retained
12:09:14 <jedai> charco: basically, if a definition doesn't look like a function definition and doesn't have an explicit type, then it will be made monomorphic (no type variables)
12:09:36 <klop2> klop2 interesting with Functor/Foldable I'm using types for what i'd normally lean on linear algebra libraries for
12:09:43 <klop2> in like matlab/python/r
12:10:22 <klop2> i can fmap instead of vectorized operations for these named model parameters
12:10:26 <jedai> charco: Integer instead of Int is decided by the defaulting mechanism, which you can manipulate if you really want to (probably not a good idea). Also GHC and GHCi don't have exactly the same lists....
12:10:39 <ertes> klop2: if you write Applicative, you get pointwise functions, too
12:10:49 <ertes> klop2: vector sum = liftA2 (+)
12:11:02 <Cale> charco: You might want to compare   bigInteger :: Integer; bigInteger = product [1..50000] with  bigNum :: Num a => a; bigNum = product [1..50000]
12:11:04 <ertes> s/pointwise/componentwise/
12:11:24 <charco> I see.
12:11:34 <Cale> If you put both those definitions in a file (with the type signatures), and you go into GHCi, and evaluate each of them. The first time you evaluate them, both will take a moment
12:11:43 <klop2> is there a way to do curried exponentiation in the way that you can do curried arithmetic like (+5)? I want to do something like  (10**)
12:11:50 <Cale> But subsequently if you use bigInteger again, it will be evaluated already
12:11:57 <Cale> whereas bigNum will be re-evaluated each time
12:12:05 <ertes> klop2: (10 **) is valid haskell
12:12:12 <Cale> That's the purpose of the MR, to prevent this sort of thing from happening by accident.
12:12:25 <Cale> Many of us regard it as more of an annoyance than a help though
12:12:30 <ertes> > (10**) 3
12:12:32 <lambdabot>  1000.0
12:12:37 <ertes> > (** 3) 10
12:12:39 <lambdabot>  1000.0
12:12:54 <klop2> nice
12:13:13 <ertes> haskell has this nice property: if it should work, it usually does =)
12:13:30 <ertes> there is only one very awkward and rather arbitrary exception: (,)
12:13:42 <ertes> in order to write (, 3) you need the TupleSections extension
12:16:04 <klop2> i think common patterns of usage in these dynamical simulation models have a nice algebraic structure that nobody exploits because they're all done in matlab :/
12:17:45 <charco> Wow Cale, I can see it now. But why can't a polymorfic constant be cached?
12:17:53 <charco> I mean, it is a constant after all.
12:17:58 <charco> (bigNum)
12:18:08 <ertes> charco: because technically it's not a constant
12:18:18 <charco> I see.
12:18:32 <ertes> charco: (Integral a) => a  -- technically this is actually a function, but the argument is passed implicitly by the type system
12:18:52 <ertes> (instance selection)
12:19:21 <ertes> charco: there are pragmas to make it constant for certain types, though, as long as they are known at compile time
12:19:26 <ertes> this is called specialisation
12:19:32 <klop2> has anyone tried aikiva for simulations?
12:19:32 <klop2> https://hackage.haskell.org/package/aivika
12:19:40 <klop2> it looks massive but i have never heard of anyone using it ever
12:19:47 <charco> Cale: do you know where in the report can I read more about this?
12:20:43 <ertes> klop2: "Downloads	5190 total (209 in last 30 days)"
12:20:47 <ertes> seems rather actively used
12:21:01 <MoonOwl> Greetings
12:21:24 <ertes> klop2: note: i'm writing "seems", because for all we know that's just a number
12:21:47 <klop2> ertes i've never seen a single blog post tutorial or even a twitter mention ...
12:21:51 <charco> also, Cale, what I don't get is how ghc is assuming that test = (-) can be a constant or something like that. If I don't specify the type, it means I won't be able to use it with Ints or Floats?
12:22:22 <mitchty> anyone know how to stop the GHC Errors buffer from incessantly popping up on save in recent haskell-mode?
12:22:44 <ertes> klop2: some packages never generate those…  i use the number of downloads and the number of repository contributors to get an idea of how popular a package is
12:22:56 <ertes> klop2: this particular one has only one repo contributor
12:23:13 <ertes> (which is probably the original author themselves)
12:23:56 <ertes> another indicator is that the first uploaded revision is from 2011, and in 2016 it's still updated
12:26:19 <MoonOwl> I am extremely new to functional programming and Haskell. I'd like to know if there are any warnings you have before I continue pursuing my learning of the language?
12:26:32 <ertes> klop2: in cases like this (apparantly single-author, yet actively maintained) judge by the source code quality ("if the author disappears, can i continue to develop this package?")
12:26:55 <ertes> MoonOwl: are you new to programming in general?
12:27:37 <MoonOwl> ertes no
12:28:44 <ertes> MoonOwl: then yes: haskell needs patience to learn…  experienced programmers sometimes approach new languages with the expectation that after having learned one language, they can pick up others very quickly…  this is not true for haskell
12:28:49 <MoonOwl> My first languages were C#, C and MIPS. Working with MIPS by trying to implement some data structures made me want to explore pure functional programming.
12:29:29 <obadz> MoonOwl: you mean MIPS assembly?
12:29:32 <MoonOwl> Yes
12:30:06 <obadz> Ok be aware Haskell is at the other end of the abstraction spectrum..
12:30:21 <ertes> MoonOwl: also haskell wants you to trust it…  it takes the notion that the compiler usually writes better machine code than the human programmer, to an extreme
12:31:15 <ertes> particularly C and assembly programmers sometimes have trouble with that notion, because they are used to controlling *everything*
12:31:29 <MoonOwl> I've only gone as far as using functions in this https://www.schoolofhaskell.com/school/starting-with-haskell/introduction-to-haskell/1-haskell-basics
12:31:49 <MoonOwl> Well, I'm not too bothered by wanting to control everything
12:31:54 <Iceland_jack> MoonOwl: You can evaluate things here
12:31:55 <klop2> MoonOwl ertes i think a bit differently ...  as in there are better language designs that make the compiler more powerful AND the code easier to reason about
12:32:00 <Iceland_jack> > sum [1..10]
12:32:02 <lambdabot>  55
12:32:20 <MoonOwl> It's like writing mathematical expressions
12:32:32 <MoonOwl> And I like that a lot
12:32:48 <obadz> MoonOwl: this is a decent intro ⇒http://learnyouahaskell.com/chapters
12:32:54 <klop2> part of why it doesn't work to lean on the compiler in other languages is that there are fewer static invariants that can be proved about the code
12:33:33 <klop2> programmers come to the wrong conclusion that the compiler is only so useful, but they are conditioning on the wrong language design.
12:33:56 <MoonOwl> Thank you obadz
12:34:12 <klop2> I find this is a common pattern. people come to conclusions like "you can only have so much composition/abstraction before things get too complicated"
12:34:35 <klop2> when really they should be concluding "you can only have so much composition/abstraction before things get too complicated [in Python]"
12:35:09 <MoonOwl> I'm not a big fan of anyone shooting down abstraction as a concept
12:35:22 <ertes> klop2: not that i disagree, but keep in mind that haskell as a language is extremely difficult to compile to efficient machine code…  the quality of GHC's code comes from decades of macro- and micro-optimisations, along with providing library authors ways to express valid transformations
12:36:05 * hackagebot semiring-simple 1.0.0.0 - A module for dealing with semirings.  https://hackage.haskell.org/package/semiring-simple-1.0.0.0 (pharpend)
12:36:15 <klop2> ertes fair enough. i'm thinking along the lines of more basic things. like if a compiler knows which functions are pure functions, that's pretty important information to have.
12:36:40 <ertes> klop2: yeah, but that's available to a C compiler, too…  you just need to be explicit as a programmer
12:36:58 <ertes> kind of like how you need to be explicit about effectful functions in haskell
12:37:04 <ertes> s/functions/actions/
12:37:27 <klop2> ertes is it? i don't know of any way to tell a C compiler that a function has no side effects
12:37:32 <ph88> would be nice if the compiler could annotate functions
12:37:38 <ertes> klop2: const
12:37:58 <klop2> global variables & I/O?
12:38:24 <ph88> ??
12:38:24 <maerwald> klop2: there is
12:38:32 <ertes> klop2: i don't remember the precise syntax, but you can definitely tell the compiler, and in simple cases it can even figure it out itself…  if all else fails most compilers provide a pragma
12:38:40 <MoonOwl> I think it would be nice to have a look at how Haskell functions are implemented on a typical x86-64
12:38:55 <maerwald> klop2: see https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes
12:39:08 <maerwald> int square (int) __attribute__ ((pure));
12:39:55 <ertes> MoonOwl: you can tell GHC to abort after a certain stage, so that you can see the intermediary code
12:39:56 <klop2> maerwald is this gcc specific? i've not seen C code with this?
12:40:17 <ertes> MoonOwl: there are more stages than in other languages:  haskell → core → STG → assembly → machine code
12:40:43 <eyepatch> I'm getting Not in scope 'Array.listArray', but I"m not sure why. http://ideone.com/c9VGAG
12:40:46 <ertes> MoonOwl: for efficiency analysis usually you'd look at core and STG…  assembly is not that useful in haskell
12:41:04 <MoonOwl> I hope I made the right decision to avoid Clojure (and other Lisps) to educate myself on functional programming. Thanks for pointing that out, ertes
12:41:04 <ph88> maerwald, do you know if there is a list of such attributes for ghc ?
12:41:08 <maerwald> klop2: I don't know. But it's possible.
12:41:10 <geekosaur> klop2, __attribute__ is a gcc-ism, yes
12:41:34 <geekosaur> often programs hide it behind a macro so they can do something compiler-specific or remove it entirely for compilers without (known) ways to do it
12:41:42 <MoonOwl> ertes, for me it's not for efficiency analysis but for curiosity's sake
12:41:44 <ertes> MoonOwl: i don't think learning haskell is a mistake…  it's a good general purpose language
12:42:16 <ertes> MoonOwl: yeah, i understand that…  if you're interested, the GHC user guide documents all switches to stop the compiler early
12:42:41 <ertes> but be prepared that GHC's assembly looks nothing like what a C compiler would typically produce…  it might look very alien =)
12:42:55 <MoonOwl> My hope is that my thinking of how programs is broadened
12:43:35 <MoonOwl> *of how programs work
12:43:52 <klop2> ertes sometimes learning haskell results in pain when i have to go back to other languages or work with other programmers =P
12:44:09 <MoonOwl> ertes, that makes me even more interested
12:45:01 <MoonOwl> What I like so far about Haskell is that it looks potentially readable without the need for any commenting
12:45:17 <maerwald> uhm
12:45:30 <maerwald> then you haven't read haskell code in big projects yet
12:45:32 <Cale> Comments are still useful, but comments are not checked by the compiler like types are.
12:45:42 <eyepatch> found it!
12:45:46 <eyepatch> Sorry.
12:45:53 <Cale> So, the more information you can put into your types about what the things do, the better.
12:46:26 <Cale> Well, to a point anyway.
12:46:40 <ertes> klop2: yeah, i know the pain, as i have it in more than one area (haskell and NixOS are the most painful ones)
12:46:57 <maerwald> and some things cannot properly be expressed in your types, like whether your function 'foo :: IO Int' throws exceptions... so you'll have to document that either way
12:47:24 <Cale> It's definitely possible to overshoot the point of comfort when it comes to specificity of types. If you have to not only write the code, but spend lots of effort convincing the compiler that it does what you say it does, perhaps that's too far a lot of the time.
12:47:39 <klop2> ertes there's a greek allegory in it somewhere
12:47:42 <ertes> MoonOwl: haskell helps you to write *useful* comments…  for example: document stuff that the name and type do *not* communicate
12:48:14 <MoonOwl> ertes, like the contracts of the functions?
12:48:28 <MoonOwl> preconditions and postconditions?
12:48:34 <Cale> Yeah, Haskell sort of strikes a balance about what goes in types and what doesn't, which is far more information than most popular languages let you encode, but still less than what some other research languages will let you do.
12:48:39 <ertes> MoonOwl: yeah (we call them laws and invariants)
12:48:47 <ertes> MoonOwl: edge cases, gotchas, etc.
12:48:53 <ertes> MoonOwl: semantics
12:49:11 <Cale> Time and space complexity if you know them :)
12:49:27 <klop2> back to practical stuff... so deriving Foldable gives me toList, is there a way to get the corresponding fromList for free?
12:49:37 <ertes> everything that saves the user from having to read your code =)
12:50:05 <ertes> klop2: not really
12:50:05 <klop2> i'm afraid if I hard code the indexes, i could easily introduce bugs if i changed the record types
12:50:10 <Cale> klop2: fromList might not be possible...
12:50:25 <Cale> klop2: toList might throw away a lot of the information
12:50:28 <MoonOwl> What differentiates Haskell from the Lisp and Caml family of languages in terms of its approach to functional programming?
12:50:30 <ertes> klop2: fromList is actually pretty difficult, because it could mean so many things
12:50:35 <MoonOwl> *families
12:50:45 <Cale> MoonOwl: Well, it's a lot closer to the ML family, if you're familiar with that
12:50:51 <klop2> Cale ertes do you know what I mean though? If I write it manually, that's like a bug waiting to happen
12:51:02 <Cale> MoonOwl: In that, it's statically typed and has algebraic data types with pattern matching.
12:51:09 <ertes> MoonOwl: we use more algebraic approaches to problem solving
12:51:50 <klop2> MyType { x = lst !! 0, foo = lst !! 1, bar = lst !! 2 } ... urgh
12:51:55 <ertes> klop2: yeah, i see what you mean…  usually i would say that you shouldn't write fromList at all, but i know your problem
12:52:01 <Cale> klop2: What would the automatically-written fromList look like for (Map k)?
12:52:13 <MoonOwl> Will taking an undergraduate level algebra class improve my understanding, ertes?
12:52:32 <Cale> MoonOwl: Uhh... in some ways, maybe, but not so much directly.
12:52:58 <klop2> Cale well I realize it doesn't work in full generality. But my type is basically a vector with named elements
12:53:01 <ertes> MoonOwl: you heff to imadjinn evrysing i say with se sharming german äktsent…  in other words: i don't know, sorry =)
12:53:59 <MoonOwl> Thanks for all the information! Time for me to get to work
12:55:36 <nshepperd> klop2: I suspect you might want Traversable?
12:55:50 <klop2> nshepperd maybe
12:56:06 * hackagebot publicsuffix 0.20160320 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160320 (wereHamster)
12:56:17 <nshepperd> I have a theory that the corresponding fromList should be 'asum . map pure', but that works only for things that are listy (Applicative and Alternative) not fixed size
12:56:41 <klop2> nshepperd if my type derives foldable and traversable ...
12:59:26 <ertes> klop2: this is just something i didn't think through completely, but i have used the following idiom for configuration monoids:
12:59:34 <nshepperd> if you derive Traversable you can use partsOf traverse to get a Lens' MyType [a] 
13:00:08 <nshepperd> but you may be able to use Traversable directly to solve the problem you thought you needed list conversion for
13:00:09 <ertes> data Conf select = Conf { field1 :: select Last Int, field2 :: select [] String }
13:00:58 <ertes> if 'select' is the type-level identity, then this gives you a configuration monoid
13:01:05 <klop2> nsheppard how does  this asum . map pure thing work? i have not used asum before
13:01:15 <ertes> if it's constant Identity, then it gives you a concrete configuration
13:01:47 <ertes> in fact this is so useful that i've thought about turning this into a library, but haven't done so far
13:02:14 <nshepperd> klop2: it's not applicable to your MyType, since your MyType is fixed size
13:02:27 <nshepperd> but
13:02:30 <nshepperd> :t asum
13:02:32 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
13:02:42 <ertes> intuitively i would say that, if you add another type argument, you can mechanically derive transforms to and from lists
13:03:15 <ertes> but it's probably overengineered for your use case
13:04:23 <ertes> anyway, i don't see an elegant solution to your problem, because lists don't have field information encoded in them
13:04:41 <klop2> i feel like this must be something lenses have solved already...
13:04:49 <ertes> nope
13:04:57 <ertes> any solution you come up with is bound to be unsafe
13:05:31 <ertes> the problem here is that you shouldn't have lists in the first place, but a library forces you to
13:05:33 <nshepperd> well, I mentioned 'partsOf traverse'
13:05:43 <nshepperd> that lets you get out and put in a list of elements
13:06:09 <nshepperd> but of course it is 'unsafe' because lists have no length restriction
13:06:21 <klop2> ertes boo... maybe i'm just going to write some crummy unsafe code to get going on this for now
13:06:57 <ertes> whoops…  somehow haskell-mode just closed my #haskell buffer…
13:07:16 <klop2> lol emacs
13:07:29 <klop2> nsheppherd where is this partsOf thing?
13:07:49 <klop2> oh lens...
13:09:00 <klop2> this is why i never get any real science done when i'm trying to do scientific computing in haskell =P
13:11:19 <ertes> klop2: i found that sometimes reinventing the wheel is more productive than trying to cope with the shortcomings of a badly designed library (or even worse: trying to bind to a foreign library)
13:12:07 <ertes> if you have a good understanding of the algorithm, and it's not too complicated, haskell allows you to implement it quickly enough
13:14:26 <maerwald> can be tedious, if it's low-level though
13:16:40 <klop2> hmm stiff ODE solvers aren't that complicated, but it is still not that trivial to re-impelement
13:17:49 <klop2> esp as applied scientist and not a numerical computing expert
13:19:33 <ertes> klop2: one useful property of your application is that all your list conversion instances look like this:  fromList . f . toList
13:20:29 <ertes> make sure that you have a toList with a predictable ordering, then write the corresponding fromList
13:20:44 <ertes> simple, stupid, works
13:21:04 <ertes> or even better: wrap it up in a combinator
13:21:20 <klop2> yeah i'm overthinking it. i just know from experience (with r/python/matlab) that sooner or later there's going to be a bug where the record type gets tweaked and the fromList still compiles ..
13:21:25 <ertes> withList ([a] -> [b]) -> F a -> F b
13:21:31 <ertes> withList :: ([a] -> [b]) -> F a -> F b
13:22:03 <ertes> all list encoding/decoding is hidden in withList…  as long as that one is consistent, everything should be fine
13:22:23 <ertes> (perhaps call it mapAsList or something)
13:22:45 <ertes> (or rather applyAsList)
13:23:04 <klop2> i am leaning towards writing my own bindings now, especially since with millions of MCMC iterations, I'm almost certain i'm going to hit a performance wall with hmatrix-gsl.
13:23:13 <ertes> hmm…  actually that is indeed just a traversal
13:23:30 <ertes> asList :: Traversal' (F a) [a]
13:23:53 <ertes> asList :: Traversal (F a) (F b) [a] [b]
13:24:52 <klop2> eyeing odeint to see if it's clean/simple enough to wrap
13:25:16 <klop2> sundials is probably a nightmare. or maybe i should just go with gsl and try to do it better
13:25:19 <ertes> note: it's a traversal of the list representation, not the individual elements
13:26:06 <klop2> ertes i'm not confident enough with lens yet :/
13:26:10 <ertes> if GSL does the job well, go with it…  but it's not straightforward to write a binding that supports your type directly
13:27:01 <ertes> let's see if i got this correctly:  you have a vector of, let's say, features
13:27:19 <ertes> each feature has a name in your application, but the solver doesn't care about those…  it wants a flat vector
13:27:21 <kirill`_> Does anybody know where stack keeps local documentation files for all the installed packages? Or how I can get it to generate them?
13:27:35 <ertes> klop2: is that accurate?
13:29:08 <klop2> ertes yes
13:29:40 <cocreature> kirill`_: to generate them run stack haddock. however there is not a single folder where all docs are kept. there is one per snapshot and one per project for all non snapshot packages. running stack path inside of a project will show you both directories
13:30:05 <klop2> ertes specifically, looking at gsl's interface here now ...  https://www.gnu.org/software/gsl/manual/html_node/ODE-Example-programs.html#ODE-Example-programs
13:30:06 <ertes> klop2: then a custom binding won't help you
13:30:34 <ertes> klop2: you still have to translate…  it's just that you're going to translate into a more efficient structure
13:31:09 <klop2> ertes i would have to translate, but i could probably write it in a way that goes directly to/from the type, rather than through a [Double] intermediary
13:31:52 <ertes> klop2: the [Double] intermediary is not that expensive…  it translates pretty much to a memory copy: something you would do anyway
13:32:05 <ertes> to get rid of this step, you need to give the solver an array directly
13:32:34 <ertes> in this case lenses could actually help you:  instead of using a feature vector type, use an array and make the fields lenses into that array
13:33:20 <klop2> ertes is there a beginner-ish lens tute that goes over this simple sort of use case?
13:33:34 <ertes> klop2: how many features do you have?
13:33:42 <ertes> or rather: how many Doubles?
13:34:16 <kirill`_> cocreature: Thanks! Does it generate a top-level index too, or just per-package files.
13:34:38 <cocreature> kirill`_: the snapshot index is about as top level as you get afaik
13:35:00 <ertes> unfortuntely it's not a simple use case when it comes to lenses…  you need to write those lenses by hand, but they aren't that difficult to learn…  i think there is a lens homepage with links to quick introductions
13:35:31 <cocreature> lens tutorials are the new monad tutorials
13:36:23 <puregreen> cocreature: hm, I don't remember the last time I saw a new lens tutorial
13:36:46 <klop2> ertes describing model state: 8, describing model parameters: 9
13:36:50 <cocreature> puregreen: yeah you’re right it’s been some time. at some point I felt like a new one was popping up every few weeks
13:37:22 <ertes> klop2: oh…  in that case my suggestion is: don't bother =)
13:38:04 <klop2> lol yeah overengineering. but that could change for other models
13:38:10 <ertes> klop2: write it as straightforwardly as possible using the applyAsList combinator and benchmark it (criterion will help you)
13:38:11 <klop2> so i'm trying to figure out the right approach in some generality
13:38:31 <ertes> see if it's fast enough
13:38:35 <klop2> also keep in mind, in running MCMC, I could run this simulation tens of millions of times
13:38:42 <ertes> if not, consider forking hmatrix-gsl
13:38:53 <ertes> yeah, that's why you should benchmark it with criterion
13:39:18 <ertes> that gives you a pretty accurate figure that you can interpolate to see how well it will behave when run many times
13:39:29 <klop2> thanks giving this a try
13:40:17 <ertes> when you think, it's fast enough, grab the mwc-random library and do the MCMC part
13:42:15 <ertes> particularly useful for the first MC in MCMC: System.Random.MWC.CondensedTable
13:42:41 <ertes> it gives you super-fast weighted random selection
13:45:20 <klop2> ertes sufficiently better than random-fu?
13:45:34 <klop2> (random-fu has a nice selection of distributions)
13:47:06 <ertes> klop2: way faster, and also has many distributions predefined
13:47:17 <ertes> https://hackage.haskell.org/package/mwc-random-0.13.4.0/docs/System-Random-MWC-Distributions.html
13:48:15 <ertes> i think random-fu has more, so just check that mwc-random has all the distributions you need
13:48:26 <ertes> if it does, you should definitely use it
13:49:51 <klop2> i had tried a couple and the fastest one i had fond previously was this unsafe binding to gsl https://github.com/patperry/hs-gsl-random
13:50:18 <klop2> much faster than the more easily searchable hmatrix-gsl-stats
13:51:11 <klop2> i thought i had benchmarked it against mwc-random but it's been a while
13:51:29 <klop2> weirdly i remember trying some low level gsl bindings and they sucked because none of the FFI wasn't unsafe
13:52:54 <ertes> i don't know how it compares to GSL, but it uses only few cycles per random number, particularly if you generate many at once
13:53:07 <ertes> (for example using uniformVector or generateM)
13:53:15 <ertes> s/generateM/replicateM/
13:53:31 <ertes> (the one from the vector package, not from Control.Monad)
14:06:28 * hackagebot config-manager 0.1.0.0 - Configuration management  https://hackage.haskell.org/package/config-manager-0.1.0.0 (guyonvarch)
14:25:02 <rntz> ... where did Control.Monad.IO go?
14:25:42 <rntz> oh, it's in Control.Monad.IO.Class
14:27:05 <xa0> lol
14:30:17 <erisco> after reading some of Stack's website I do not understand what purpose it has. Why do I want Stack?
14:30:18 <Peaker> erisco: It uses a stackage snapshot specified by the yaml file, downloads ghc as needed, lets you specify other package sources as needed (e.g: specific hashes from github!)
14:30:46 <Peaker> erisco: and successfully caches compilations even across sandboxes (unlike cabal where you choose between sandboxing and build caching)
14:30:56 <erisco> how does this differ from a cabal sandbox?
14:31:31 <erisco> okay, so more options for package sources and package sharing across sandboxes
14:31:43 <Peaker> erisco: A) everything is sandboxed (no explicit action needed)  B) when you build a new package, all the deps that are the same are copied from cache instead of being re-built (when possible which is often due to the version constraints in stackage)
14:31:53 <erisco> I guess ghc version could be significant but I haven't run into that problem
14:32:22 <Peaker> erisco: so you get the best of both worlds (sandbox-wise) and you get fully reproducible builds. You get the exact same version of entire universe the package lives in, from the .yaml file
14:32:51 <erisco> well I can give it a try, though it seems more marginal than people sell it as
14:32:53 <joprice> stack is the only reason i came back try learning haskell again
14:32:55 <Peaker> if you send your package to a 3rd party, it'll "just work" when they use stack. If they use custom ghc & cabal -- it's very likely their ghc is too old, or their packages will "break" somehow
14:33:19 <greg> anyone got ghc-mod working with stack in emacs?
14:33:52 <hvr> Peaker: btw, that part about caching only holds for the non-nix-store cabal
14:33:57 <Peaker> erisco: for expert users who know their way around cabal problems -- stack is not that big a deal.  For non-experts, it's the difference between "opaque wall of text error" in cabal, and "Just works" almost always
14:34:28 <Peaker> erisco: but even for experts it's a big deal if they want to distribute their code to non-experts
14:35:06 <Peaker> erisco: oh, and for me a *huge* deal is the ability to override arbitrary hackage packages that have annoying problems
14:35:15 <hvr> Peaker: the nix-store-based cabal caches everything which can be can be cached without compromising integrity
14:35:30 <erisco> override? you mean indicate a different source for the package?
14:35:58 <Peaker> for example, if you have a hackage package with a transitive dependency that is buggy -- and the maintainer is refusing to fix the bug (I had this case!) -- with stack you can just host a fork on github, and have your .yaml file say that this deeply transitive depenedency comes from your github fork, and it'll work for everyone using "stack build"
14:36:02 <Peaker> erisco: yeah
14:36:07 <erisco> I feel like I should nuke Haskell from my system before installing stack
14:36:22 <Peaker> erisco: "stack" uses its own directory structure that does not coincide with the existing stuff
14:36:51 <Peaker> erisco: it installs stuff to ~/.local, ~/.stack,  your package's .stack-work/ (instead of dist/).  Even the installed ghc goes to one of those
14:37:06 <erisco> is "stack" the only command on path?
14:37:13 <Peaker> I think so
14:37:24 <erisco> I am worried about collisions there
14:37:30 <erisco> I think I already have a mess going on
14:37:54 <Peaker> I think it's enough to nuke ~/.stack and maybe <pkg>/.stack-work then
14:37:57 <Peaker> though I've never had to
14:38:19 <meoblast001> i think i need a sanity check. not exactly sure how this type error is coming up https://gist.github.com/meoblast001/1483a3e68595edef9dec
14:38:20 <erisco> I installed the Haskell Platform in 2014
14:38:50 <meoblast001> i'm doing a V4 a *! M44 a... M44 is V4 V4... so i'm doing a V4 a *! V4 (V4 a)
14:38:55 <meoblast001> yet the compiler does not agree
14:39:12 <hvr> erisco: what OS are you on?
14:39:17 <erisco> Windows
14:39:29 <hvr> ok, in that case Stack may be a good coice
14:40:03 <hvr> for now...
14:41:33 <Peaker> hvr: when is stack not a good choice?
14:42:46 <hvr> Peaker: if you don't want bleeding edge without having to keep adding exceptions to your stack.yaml file ;-)
14:42:54 <Peaker> perhaps this sums it? stack = cabal + uses stackage + custom package sources [even git repos] + sandbox by default + caching across sandboxes
14:43:06 <hvr> Peaker: or if you're on Linux distributions which are not compatible with the not-so-generic bindists Stack installs
14:44:16 <hvr> e.g. don't try using Stack on a non-latest SLES
14:44:53 <Peaker> .. + auto-ghc install + fully reproducible builds
14:45:06 <Peaker> So I guess that's compelling, isn't it? :)
14:45:52 <hvr> Peaker: you may be surprised, but everything but stackage-by-default and auto-ghc-install will be provided by the next-gen cabal as well
14:46:11 <hvr> auto-ghc-install is a very bad idea on Linux anyway
14:46:18 <puregreen> meoblast001: the result is going to be V4 a
14:46:35 <puregreen> meoblast001: and then you're writing it to the ioref
14:46:36 <hvr> as a GHC developer I really don't recommend the Linux GHC bindists for mission critical stuff
14:46:49 <meoblast001> ooooh. thanks :o
14:47:01 <hvr> we provide for download
14:47:02 <Peaker> hvr: everything?  custom git sources?  sandbox by default + caching across sandboxes?  "cabal freeze" by default?  
14:47:21 <Peaker> hvr: what's better than the ghc bindists?
14:47:32 <hvr> Peaker: bindists built specifically against your distribution
14:47:49 <hvr> whose autoconf values match what you're actually using, and linked against the right DSOs
14:48:37 <erisco> oh 7.10 is out? I am really behind XD
14:48:58 <hvr> erisco: we're even at GHC 8.0.1RC2
14:49:27 <hvr> Peaker: caching-accross-sandboxes is basically what the nix-store is about
14:49:30 <puregreen> hvr: when can we expect the final release?
14:49:40 <erisco> where do I find the change log?
14:49:50 <hvr> puregreen: my best guess right now: before end of april
14:49:53 <Peaker> hvr: is that only if you use nix?
14:50:00 <hvr> Peaker: nope
14:50:12 <hvr> Peaker: cabal maintains its own nix-style store
14:50:51 <hvr> Peaker: so each unmodified/non-local artifact you build gets cached there
14:51:12 <hvr> if you placed a stackage cabal.config file in scope, you'd get the same effect as using Stack's caching
14:51:39 <hvr> you can effectively quite easily emulate most of Stack's feature on top
14:52:21 <kadoban> hvr: Sounds nice, competition in tools is good stuff.
14:52:29 <hvr> cabal doesn't use yaml for reasons, but it has now a cabal.project file that has a similiar purpose
14:52:37 <Peaker> hvr: so the idea is people will distribute packages with "cabal freeze" configs?
14:52:41 <erisco> I think this is the big one here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/release-7-10-1.html
14:52:46 <hvr> Peaker: I hope not :-)
14:53:04 <hvr> Peaker: you may be able to freeze the hackage index
14:53:17 <hvr> you may be able to freeze your build-plan
14:53:19 <hvr> etc
14:53:29 <hvr> but there's still design-space to explore there
14:53:52 <hvr> (NB: if you freeze the hackage index you get reproducible builds as well since the solver is deterministic)
14:54:06 <hvr> (but without having to curate like stackage does)
14:54:33 <Peaker> hvr: I like "stackage" though -- it incentivizes the right things and solves the most painful issues.. the version flexibility of cabal has bad unintended consequences
14:54:50 <hvr> Peaker: you can still use stackage's freeze files
14:55:26 <Peaker> If stackage takes over more mind-share though -- the consequences will be good: it exerts much pressure on people to get their part of the ecosystem in decent shape
14:55:38 <hvr> once Hackage carries package-sets (a generalisation of stackage's snapshots), cabal may even be able to specify more conveniently than placing a freeze-place somewhere
14:55:45 <Peaker> "Fix your package / bump bounds --> or you're out!"
14:56:00 <toph> does anyone have the missing "hole.png" image from this article? https://www.schoolofhaskell.com/user/dpiponi/the-mother-of-all-monads
14:56:21 <hvr> Peaker: tbh, I've rather noticed that new package authors relying too much on Hackag leave off most version bounds
14:56:22 <Peaker> hvr: but what's the upside, compared to an lts snapshot?
14:56:24 <toph> (about 20% down the page)
14:56:34 <hvr> Peaker: thereby violating the Hackage package guidelines
14:56:59 <hvr> s/relying too much on Hackage/....on Stackage/
14:57:42 <Peaker> hvr: unfortunate historic mistakes:  .cabal files should only specify the knowns, not unknowns.  the unknowns can be inferred (relatively to a package index)
14:58:21 <hvr> Peaker: then you're effectively saying that the PVP as a whole is a mistake
14:58:25 <Peaker> the upper bounds are saying "I *know* this doesn't work with >= V" which is disinformation.  Better if a tool infers that "V" did not exist yet back then -- so the known/unknown is distinguished
14:58:25 <lpaste> nocturne777 pasted “lifted-async” at http://lpaste.net/155557
14:58:30 <Peaker> hvr: indeed
14:59:15 <nocturne777> Could someone help me make the compiler happy so that lifted-async plays well with my monad-stack?
14:59:25 <hvr> Peaker: well, that's a valid but different paradigm; semantic version works too... what doesn't work well is if you mix both paradigms in the same repository
14:59:27 <nocturne777> I posted the sample code in the lpaste along with the error
15:00:21 <Peaker> hvr: iirc, cabal will always prefer a.b.c.d' over a.b.c.d if d'>d, even if the version bounds of d' mismatch and d don't?  If so -- retroactively adding upper bounds when they become known is possible?
15:01:07 <hvr> Peaker: it is possible, but the way Hackage is designed makes it too costly
15:01:48 <hvr> Peaker: i.e. everything is optimised around putting in "pessimistic" upper bounds
15:02:36 <Peaker> hvr: And then nothing incentivizes fixing those bounds (besides stackage, if the package is in there)
15:03:05 <Cale> It would be really cool to somehow accumulate knowledge about which builds work and which don't in a distributed fashion.
15:03:15 <hvr> Peaker: what do you mean by "bounds mismatch"?
15:03:46 <telmich> I'm trying to use foldr to simulate foldl (as part of an exercise); I was given the information that "id" might be useful, however I'm a bit stuck in this expression: myFoldl f v l = foldr (\a b -> f b a) v l
15:03:48 <hvr> Peaker: cabal will happily backtrack to an older version if needed to satisfy constraints
15:03:52 <Peaker> hvr: if a.b.c.d lacks upper bound, so is accepted by solver, but a.b.c.d' has upper bound that disallows build
15:04:17 <telmich> has someone a hint for me, how I could pass my function further to the left without evaluating it?
15:04:28 <Peaker> hvr: I thought I recalled cabal having some specific rule about preferring a version whose 4th minor component in ver.num is higher
15:05:04 <hvr> Peaker: well, no... cabal doesn't; it has just an Eq/Ord instance on Versions, it doesn't exploit more information about the structure
15:05:34 <Peaker> telmich: My hint would be -- think of the relationship between foldr and explicit-pattern-matching functions.  Then think how you write foldl as an explicit pattern matching function
15:06:09 <Peaker> hvr: ah, then the only way is to in-place edit the .cabal on hackage.. would be nice if there was a way to supercede while retaining immutability of packages
15:06:17 <telmich> Peaker: thanks a lot - I'll dig my head into this
15:06:18 <Peaker> hvr: a.b.c.(d'>d) supercedes
15:06:20 <hvr> Peaker: however, if it did, it would break packages like transformers-compat whose .cabal files explicitly exploit the ability to backtrack
15:06:53 <nocturne777> I don't know about this "Skolem" thing..
15:06:56 <Peaker> hvr: a.b.c.(d'>d) supercedes, but a.b.(c'>c) does not, so you can still backtrack
15:07:50 <Peaker> nocturne777: it seems one has an "Either ServantErr" wrapping the type and one does not (the Skolem part is the same)
15:08:11 <Peaker> nocturne777: where exactly is the error?
15:08:34 <hvr> Peaker: yes... but you'd have a hard-time if you needed to synchronise the versions with transformers at the minor-version component
15:09:06 <nocturne777> Peaker: this part causes the error:  deleteSessions uid     (line 22)               
15:09:13 <hvr> Peaker: i.e. you could use a minor version only once
15:09:22 <Peaker> hvr: do the versions have to be perfectly in sync? Perhaps a.b.c-d can be used to indicate compatibility with a.b.c.d ?
15:09:41 <hvr> Peaker: so you'd have to spread out the minor-versions
15:09:46 <hvr> and have artificial minor version bumps
15:10:01 <Peaker> nocturne777: what is updateAccountState ?
15:10:34 <Peaker> hvr: would it be a huge problem if when transformers has a superceding package, transformers-compat does too?
15:10:50 <vektorweg1> foldl or foldr?
15:11:42 <hpc> i think there's a broader point to be made here about being able to automate package management based on semantic versioning
15:12:00 <hvr> Peaker: anyway, if you enforced such a rule in the 4th version component, you'd have to effectively require minor version bumps everything you make a version bound tighter 
15:12:15 <hpc> assuming a haskell package manager ever goes out and actually internalizes the concepts from it
15:12:43 <hvr> Peaker: as such an implicit blacklisting would lead to surprising effects
15:13:00 <hvr> blocking out solutions transitively
15:13:20 <erisco> I do not understand what a "snapshot" or "package set" is
15:13:22 <kaizoku> Hmm, how can I lookup more than one value from a Map?
15:13:35 <Peaker> telmich: hmm.. trying to act on my own advice to you -- I think I may have lead you astray :)  There's a "trick" here and the "id" hint is meant to illustrate the trick -- instead of building the final value directly you're supposed to use the "foldr" to build a compose a big function that would help create the result
15:13:48 <erisco> is this their name for a repository of packages such as Hackage?
15:13:57 <Peaker> erisco: it's a basically a (Map PackageName PackageVersion)
15:13:57 <lpaste> nocturne777 revised “lifted-async”: “No title” at http://lpaste.net/155557
15:14:21 <nocturne777> Peaker: it's a DB call. I have included in the paste as well now
15:14:22 <Peaker> erisco: you can represent such a snapshot as a cabal config file that restricts each package name to a specific version (and indeed, that's how stackage worked with cabal for a long time)
15:15:01 <erisco> I don't understand the significance
15:15:57 <hvr> erisco: stackage pins down each version of about 2000 packages
15:16:29 <hvr> erisco: in snapshots; those are tested in a CI-way to ensure they build w/o compilation failures
15:16:47 <erisco> is this something to do with conflicting dependencies?
15:16:47 <Peaker> nocturne777: that's not the whole GHC error, is it?
15:16:58 <hvr> erisco: in theory this would be already guaranteed by properly specified version bounds in each .cabal file
15:17:09 <Peaker> erisco: Do you know cabal's "butterfly problem"?
15:17:27 <Peaker> hvr: nope, because of the butterfly problem -- and because of less effective caching
15:17:32 <hvr> erisco: not really, more about eschewing packages being inaccurate about version bounds
15:17:39 <erisco> Peaker, no
15:18:03 <erisco> hvr, okay
15:18:20 <hvr> Peaker: did I miss a blogpost? :)
15:18:30 <Peaker> erisco: GHC package database has an annoying limitation -- that a (package name, version) pair is unique, can only be installed once.  The problem is that the same package, same version, may be needed twice in the same build -- each time built against different dependencies
15:18:46 <hvr> Peaker: that's not true anymore btw
15:18:53 <Peaker> hvr: https://cdsmith.wordpress.com/2011/01/17/the-butterfly-effect-in-cabal/
15:18:58 <Peaker> hvr: since when?
15:19:06 <hvr> Peaker: the GHC package database has been supporting multiple (name,version) package instances  since at least 7.10
15:19:10 <lpaste> nocturne777 revised “lifted-async”: “whole error” at http://lpaste.net/155557
15:19:26 <Peaker> hvr: so why do I still have the "installs may break existing packages" thing?
15:19:30 <nocturne777> Peaker: I pasted in the whol error as well, but I don't think the error message is very useful
15:19:36 <hvr> Peaker: it's rather cabal that didn't exploit that feature yet, but starting with 1.24 code is landing which can
15:19:52 <Peaker> hvr: OK, so s/annoying ghc limitation/annoying cabal limitation :)
15:20:00 <hvr> Peaker: because that's where the cabal nix-store feature comes into play
15:20:35 <Peaker> nocturne777: hard to debug a type error with partial info. maybe if you put it where I can git clone and debug the real thing
15:20:38 <hvr> Peaker: if you use that new mode-of-operation you never get into the 'may break existing' packages issue
15:21:19 <hvr> Peaker: that's why it was called the "no-reinstall cabal" in http://blog.ezyang.com/2015/08/help-us-beta-test-no-reinstall-cabal/
15:21:19 <nocturne777> Peaker: would it help to see the bodies of "deleteSessions" and "updateAccountState" ?
15:21:21 <Peaker> hvr, erisco: To summarize: until cabal 1.24 -> the unique-pair restriction means that lack of version freezing causes tons of "reinstall" problems.
15:21:50 <nocturne777> Peaker: I am thinking that I may need to instantiate MonadBaseControl differently
15:21:56 <Peaker> hvr, erisco: And even after cabal >=1.24 -> freezing all versions on a specific one has 2 desired effects: A) Much more successful build caching  B) incentivizing developers to update their damn packages :)
15:22:39 <Peaker> hvr: the stackage approach prevented the reinstall problem too -- by vastly simplifying the dependency graph
15:23:04 <lpaste> tippenein pasted “how to resolve a Bad Interface File problem” at http://lpaste.net/155560
15:23:05 <Peaker> packages become names, instead of (name,version) pairs, so same (name) is same graph underneath, always
15:23:18 <hvr> Peaker: yeah, that's the other way to "solve" a problem... dumb it down till the solution is trival ;)
15:23:34 <hvr> ...but then you have solved a different problem 
15:23:44 <Peaker> hvr: yes -- but this dumbness is a good thing. a proliferation of package versions is a mess and a bad thing
15:23:53 <Peaker> don't embrace it - kill it with fire :)
15:23:57 <hpc> i wonder if there's a demand for a haskell implementation of http://thedailywtf.com/articles/Release-Management-Done-Right
15:23:59 <nocturne777> I should have listend to Cale, I think. This constant lifting thing is turning out to be a headache
15:24:05 <hpc> specifically http://img.thedailywtf.com/images/201106/randb.png
15:24:23 <Peaker> tippenein: what command are you running?
15:24:43 <hpc> builds automatically get an auto-incrementing number 1.0.2.1.5648
15:24:55 <hpc> then when one passes it automatically reversions it as 1.0.2.2
15:24:55 <Cale> nocturne777: Yeah... when you use monad transformers you want to be really really sure that it's going to be worth it.
15:25:11 <hpc> and tags in source control and etc
15:25:18 <tippenein> It's an error within my vim buffer from SyntasticCheck
15:26:35 <nocturne777> Cale: with monad transformers, you are basically trading function parameters for typeclasses.
15:26:35 <Peaker> hpc: I think "cabal" is trying to solve a problem technically, when the "social solution" is cheaper & superior (the "beaten-with-stick until you comply with snapshot regulation")
15:27:03 <tippenein> I have hlint packages in 7.10.2 and 7.10.3
15:27:14 <Peaker> hpc: even with a perfect cabal that can resolve versions truly, I'm still going to have to deal with pessimistic version bounds, people who don't update their packages/bounds in time, don't fix trivialities that make them compatible with newest&greatest
15:27:21 <hvr> Peaker: the superiority heavily depends on the metric used to determine that
15:27:22 <hpc> Peaker: i was more thinking along the lines of automating "doing it right" so well that it's easier to do it that way than to do it wrong
15:27:23 <nocturne777> another sad thing is the lack of examples with lifted-async in a monad stack
15:27:34 <hvr> Peaker: I consider Stack's approach technically inferior
15:27:44 <Peaker> oy, I think I spammed hpc instead of hvr, sorry about that :)
15:27:51 <Peaker> tla's confuse me!
15:28:01 <hvr> Peaker: simply because you will be able to map stack's features on top of cabals but not the other way round
15:28:26 <Peaker> hvr: you're only looking at the technical side -- there's the social side of incentives. The actual end result of the ecosystem, built from actual people
15:28:46 <Peaker> hvr: the cabal way is general enough to accomodate and even encourage bad package maintainership
15:29:02 <Peaker> hvr: the restricted stack way beats people with a stick to the benefit of everyone
15:29:20 <hvr> Peaker: that sounds too good to be true... ;-)
15:29:22 <hpc> clearly what we need is {-# LANGUAGE PackageTypes #-}
15:29:45 <Peaker> hvr: I've witnessed it happen. I was beaten with a stick and it made me update a package that I otherwise wouldn't touch. And it's great
15:29:53 <hvr> heh
15:29:59 <hpc> hvr: the narrower the user-visible operations, the more assumptions the implementation can make to keep things from breaking
15:29:59 <hvr> Peaker: you should blog about it :)
15:30:31 <hpc> for instance, perhaps you could enforce that there's only ever one installed version of a package in a particular package set
15:30:50 <hpc> now the manager can assume whenever any package depends on that one, they refer to the same dependency
15:31:04 <hpc> then when you update that package, you can follow the dependencies back and rebuild all those other packages
15:31:16 <Peaker> if a package set is  (Map PackageName Version)  then that is true by definition, no?
15:31:19 <hpc> no more butterfly effect, in theory
15:31:31 <Peaker> (which is indeed what stackage gains you, iiuc)
15:31:44 <tippenein> my system ghc is 7.10.2 but my vim packages were compiled with 7.10.3 . What is the recommended way of upgrading the system ghc to match them>?
15:31:46 <hpc> i haven't used stack yet
15:31:54 <hpc> sounds like i really need to
15:32:48 <hpc> but then if you need to install mueval and maybe it still has pretty old dependencies, then you can do that in a separate package set and those dependencies will never mix with anything else
15:32:56 <Peaker> tippenein: perhaps you can tell vim to find the ghc installed inside stack?
15:33:00 <hpc> if you depend on mueval in another package set, it's a new instance that gets recomputed
15:33:24 <hpc> managing which one gets put on PATH might be interesting though
15:36:31 * hackagebot dotenv 0.3.0.1 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.3.0.1 (jsl)
15:54:05 <a3gis> Hello! What is the operation to "sequence" two lenses? for example, I want to apply a function over two properties of the same type
15:54:26 <puregreen> a3gis: there's no such operator
15:54:47 <a3gis> puregreen: wouldn't it make some sense to have one?
15:54:52 <puregreen> it's called “vertical composition” and it's not in lens because if you apply it to lenses that overlap, weird things would happen
15:55:12 <puregreen> https://github.com/ekmett/lens/issues/109
15:55:14 <a3gis> puregreen: oh, ok. thanks!
15:57:46 <puregreen> (but if you're curious about how it could be written, see https://github.com/ekmett/lens/issues/315)
16:15:51 <EvanR> heh so.... you got your MVector class. and then you got your MVector data family under Vector.Unboxed, and then you got your data instance MVector MVector Float
16:17:16 <EvanR> but the second MVector is in the position that a monad would go in the other MVector s a
16:17:31 <EvanR> it kind of makes you wanna use C ;)
17:05:33 <Gurkenglas> Alternative f in semigroupoids is not (Alt f, Plus f) merely for legacy reasons, right?
17:06:34 * hackagebot typed-wire 0.3.1.0 - Language-independent type-safe communication  https://hackage.haskell.org/package/typed-wire-0.3.1.0 (AlexanderThiemann)
17:09:55 <EvanR> when i read and write an unboxed vector of Float... i seem to be dealing with Floats, which are boxed right?
17:10:09 <EvanR> am i missing the point here
17:10:49 <xa0> i think i'm starting to get free monads
17:19:15 <geekosaur> EvanR, I think the point is that things you take out get boxed and things you put in get unboxed, so the vector itself can hold unboxed things for speed in manipulating the vector itself?
17:19:48 <EvanR> that would make sense, but is there a way to do calculations with the unboxed values directly?
17:20:01 <EvanR> while they are "outside" the vector
17:21:30 <eyepatch> I'm stuck trying to convert a dynamic programming program that is O(n^2) in space to O(n) in space. I'd like to have it so that it only keeps track of the current width during its calculation, but I'm getting stuck with how to handle storage of the array. http://ideone.com/c9VGAG
17:22:02 <eyepatch> The top 69 lines are comments, there's really only 10 lines there, but I thought that the other versions might be helpful to see what's happening.
17:23:48 <nocturne777> geekosaur: are you familiar with lifted-async ?
17:28:49 <geekosaur> no, sorry
17:28:55 <geekosaur> (also my irc bouncer is flapping again...)
17:33:33 <EvanR> I've heard that to optimize haskell code for super speed you should avoid recursion
17:33:48 <EvanR> which i kind of have no idea how to
17:40:23 <Gurkenglas> By that they mean that you should use the existing recursive combinators that have already been optimized for super speed, right?
17:42:35 <Job316> is the right way to think about overloadedstrings that it's changing the behavior of isstring?
17:43:22 <EvanR> Gurkenglas: alright
17:44:02 <EvanR> Job316: OverloadedStrings causes IsString to exist
17:44:26 <EvanR> so technically yes
17:53:38 <Hafydd> IsString exists regardless of whether OverloadedStrings is in effect.
17:54:28 <Hafydd> Job316: the right way to think about them is that it changes the meaning of string literals: in particular, it changes them to a "fromString" invocation.
18:02:47 <eyepatch> I'm getting a parse error on 12 and I'm not sure why. Could you take a quick look? http://ideone.com/yQwIJh
18:04:52 <mitchty> ccccccevhifnkrnktvtcifkhriefhbgrrurlktbvbgfd
18:04:57 <mitchty> gah, sorry
18:05:04 <mitchty> yubikey
18:08:36 <EvanR> eyepatch: try putting the wheres on the previous lines at the end
18:09:02 <eyepatch> EvanR I don't understand.
18:09:20 <EvanR> instead of f = a b c d e\n         where b =
18:09:31 <EvanR> f = a b c d e where\n  b =
18:10:21 <Gurkenglas> eyepatch, replace your tabs by spaces. ghc hates tabs silently and with a passion.
18:10:30 <eyepatch> I have tabs in there?
18:10:48 <EvanR> yep
18:10:57 <geekosaur> so when I paste that into a file, go is mis-indented
18:10:58 <EvanR> tabs are the devil
18:10:58 <Gurkenglas> ikr? damn invisible whitespace
18:11:02 <codebje> EvanR, you can 'avoid' recursion by expressing your algorithm as a catamorphism, or by extracting the recursion as a continuation
18:11:20 <codebje> which one makes code faster, I don't know
18:11:30 <codebje> or if there's a third, better, way
18:11:31 <EvanR> catamorphism = fold?
18:11:37 <codebje> pretty much, yes
18:12:01 <codebje> if it's a recursive transformation, a hylomorphism is like unfold.fold
18:12:32 <EvanR> whats a good resource for hylomorphisms
18:12:52 <codebje> the bananas paper is pretty accessible
18:13:10 <EvanR> barbed wire?
18:13:11 <codebje> google 'bananas lenses functional'
18:13:14 <codebje> yeah, that one
18:19:03 <EvanR> ok
18:19:23 <EvanR> of course now my bottleneck is rendering a million tiny squares with gloss
18:19:40 <EvanR> or anything really
18:30:40 <EvanR> lets say i am looping over a 2d array and i can tell when i dont need to loop to the end of the row and can skip to the next row now
18:31:28 <EvanR> i could say this using a recursive IO function, but is there some foomorphism that is faster?
18:32:12 <Gurkenglas> Why isn't there mapAccumL1?
18:32:13 <eyepatch> the tabs were the problem.
18:34:23 <Gurkenglas> EvanR, (MaybeT, many) or Control.Monad.Loops.
18:34:47 <Gurkenglas> How are you looping over it? Do you use IO at every cell?
18:35:21 <Big_G> I seem to be hearing about vector spaces a lot in my Haskell groups. Is there any application of them in Haskell beyond the standard linear aglebra methods?
18:36:22 <Gurkenglas> If you don't like monad transformer stacks with IO at the bottom, and the thing in each cell is the only place you use IO, make your looping function general in the monad at the bottom and let the caller give you a callback, which happens to end up setting the monad at the bottom to IO, but your general looping function cant use IO
18:37:08 <Gurkenglas> EvanR, do you have real code there so I can show you how I'd do it with MaybeT?
18:37:36 <EvanR> yes, IO at each cell to read the IOVector
18:42:22 <codebje> are you wedded to gloss?  a million (independent) small squares sounds like it should be ideal to run on a GPU rather than a CPU
18:42:35 <codebje> (I don't think, offhand, that gloss allows easy access to the underlying GL context)
18:42:38 <codebje> (but it might!)
18:44:42 <zennist> anyone knows how to convert between a diagram Point and linear V2?
18:44:51 <Gurkenglas> EvanR, would the cell thing be IO (Maybe (a -> a)) or a -> IO Bool or what?
18:53:25 <EvanR> Gurkenglas: Array -> (Int -> Int -> Float -> b -> b) -> b -> IO b
18:53:33 <EvanR> b is the accumulator
18:53:42 <EvanR> i guess here there is no skipping
18:54:01 <EvanR> but if it wasnt factored into a combinator, the recursive function would have type
18:54:31 <EvanR> :: Array -> Int -> Int -> b -> IO b
18:54:48 <EvanR> that IO is for getting the float, and the recursive function would decide the next Int Int
18:56:04 <Gurkenglas> And where's the information about whether to skip the rest?
18:56:05 <Gurkenglas> :t \f -> fmap isJust . runMaybeT .: traverse_ $ lift . f >=> guard
18:56:07 <lambdabot> (Monad f, Foldable t) => (a -> f Bool) -> t a -> f Bool
19:05:32 <Gurkenglas> http://lpaste.net/155565 for Traversable t => (a -> m (Maybe a)) -> t a -> m (t a), although that one requires an lpaste thats growing big enough to be a library at this rate
19:13:04 <EvanR> Gurkenglas: if im writing it directly the information is in the code that is analyzing the cell
19:13:18 <EvanR> i havent though about a combinator yet
19:13:35 <EvanR> is really going through a Maybe going to be faster?
19:14:32 <Gurkenglas> I don't think it'll be slower, I'm optimizing for I-like-it here, not speed :P
19:14:59 <EvanR> heh i liked it before i used a mutable vector 
19:17:21 <Gurkenglas> Under the assumption of "<Gurkenglas> By that they mean that you should use the existing recursive combinators that have already been optimized for super speed, right?" which I just formulated as a reasonable rationalization given that we know there's a reason to use combinators, it should be faster. At least the evanR_ one, because the second one still has to traverse the rest of the traversable to finish 
19:17:21 <Gurkenglas> transcribing elements identically
19:20:18 <EvanR> yeah if i wrote the "recursive" combinator in C that would make complete sense
19:20:42 <EvanR> do the whole algorithm in C
19:21:28 <eyepatch> I'm running into memory issues on very large inputs. Is this being as lazy as I hope it is? http://ideone.com/EvGr7B
19:22:17 <eyepatch> This should be around space of O(n) I'd think.
19:23:46 <Gurkenglas> @letlpaste 155565
19:23:46 <lambdabot>  Parse failed: Ambiguous infix expression
19:23:52 <Gurkenglas> Why is that? http://lpaste.net/155565
19:24:28 <Gurkenglas> ((f .: g) x = f . g x; infixr 8 .:)
19:26:03 <Gurkenglas> (eyepatch, I'd recommend you do "maxSlice l [x] = x" instead of line 36)
19:32:26 <Gurkenglas> eyepatch, almost randomly guessing here, try wrapping prev's definition into force from deepseq 
19:32:47 <eyepatch> Well, I don't know if it is in fact being lazy or not.
19:52:42 <Herby_> \o
20:56:42 * hackagebot hpack 0.11.1 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.11.1 (SimonHengel)
21:11:42 * hackagebot hpack 0.11.2 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.11.2 (SimonHengel)
21:24:37 <saurabhnanda> hey, have a question about Yesod/Persistent. I'm finding it easier to use runSqlite, at the call-sites of the few DB related functions, so that I don't have to deal with SqlPersistM() through my entire stack. runSqlite converts SqlPersistM() -> IO() which is composing with my existing code very well. However, my question is, will this result in new DB connections each time? Or will it use some sort of common connection pool?
21:26:27 <saurabhnanda> as a side effect, it's making my DB calls strict, as well. Otherwise I don't know how it's going to behave if I return SqlPersitM() actions from inside a modifyMVar_ block (I'll have to use lifted-base to be able to do that, in the first place). But, the point is, I'm not able to wrap my head around lazy SQL which happens when every function just return an SqlPersistM() action instead of actually executing the SQL action.
21:26:41 <saurabhnanda> any thougts?
21:43:06 <Gurkenglas> How should I go about turning my lpaste into a hackage library?
21:47:51 <bitemyapp> @pl (\s n -> (++) s (show n))
21:47:52 <lambdabot> (. show) . (++)
22:46:46 * hackagebot yi 0.12.4 - The Haskell-Scriptable Editor  https://hackage.haskell.org/package/yi-0.12.4 (DmitryIvanov)
22:52:34 <ggVGc> how would I make a macro that quotes a term with CPP in haskell? the normal way of #define quote(x) #x doesn't work. gives a parse error
22:52:57 <ggVGc> "parse error on input ‘#’"
23:16:47 * hackagebot wai-devel 0.0.0.4 - A web server for the development of WAI compliant web applications.  https://hackage.haskell.org/package/wai-devel-0.0.0.4 (urbanslug)
23:51:55 * hackagebot amazonka-core 1.4.0 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.4.0 (BrendanHay)
23:51:57 * hackagebot amazonka 1.4.0 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.4.0 (BrendanHay)
23:51:59 * hackagebot amazonka-test 1.4.0 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.4.0 (BrendanHay)
23:52:01 * hackagebot amazonka-cloudwatch-events 1.4.0 - Amazon CloudWatch Events SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-events-1.4.0 (BrendanHay)
23:52:03 * hackagebot amazonka-glacier 1.4.0 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.4.0 (BrendanHay)
23:57:05 * hackagebot amazonka-ecr 1.4.0 - Amazon EC2 Container Registry SDK.  https://hackage.haskell.org/package/amazonka-ecr-1.4.0 (BrendanHay)
