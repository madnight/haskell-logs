00:01:18 <erisco> I am guessing these are examples then https://hackage.haskell.org/package/esqueleto-2.4.3/docs/src/Database-Esqueleto-PostgreSQL.html#arrayAgg
00:01:26 <erisco> unsafeSqlFunction sounds about right
00:07:41 * hackagebot repa-convert 4.2.1.1 - Packing and unpacking flat tables.  https://hackage.haskell.org/package/repa-convert-4.2.1.1 (BenLippmeier)
00:07:41 * hackagebot opengles 0.8.2 - Functional interface for OpenGL 4.1+ and OpenGL ES 2.0+  https://hackage.haskell.org/package/opengles-0.8.2 (capsjac)
00:22:35 * hackagebot total-alternative 0.1.0.1 - Alternative interface for total versions of  partial function on the Prelude.  https://hackage.haskell.org/package/total-alternative-0.1.0.1 (guaraqe)
00:22:37 * hackagebot rlist 0.1.0 - Lists with cheap snocs  https://hackage.haskell.org/package/rlist-0.1.0 (guaraqe)
00:22:39 * hackagebot LATS 0.4.0 - Linear Algebra on Typed Spaces  https://hackage.haskell.org/package/LATS-0.4.0 (guaraqe)
00:22:41 * hackagebot nonempty-alternative 0.3.0 - NonEmpty for Alternative types  https://hackage.haskell.org/package/nonempty-alternative-0.3.0 (guaraqe)
00:27:35 * hackagebot constraint-classes 0.1.0 - Prelude classes using ConstraintKinds  https://hackage.haskell.org/package/constraint-classes-0.1.0 (guaraqe)
00:27:37 * hackagebot constraint-classes 0.2.0 - Prelude classes using ConstraintKinds  https://hackage.haskell.org/package/constraint-classes-0.2.0 (guaraqe)
00:32:35 * hackagebot LATS 0.4.1 - Linear Algebra on Typed Spaces  https://hackage.haskell.org/package/LATS-0.4.1 (guaraqe)
00:49:08 <knittl> hm. so is "f . f" the same as "f(f)"?
00:49:33 <liste> knittl: no, f $ f is f(f)
00:49:48 <liste> f . f is \x -> f (f x)
00:49:48 <knittl> ok. what is f . f then?
00:49:53 <knittl> ok
00:50:43 <knittl> so (fmap . fmap) mult3 sum is equivalent to (\x -> fmap (fmap x)) mult3 sum?
00:51:14 <mniip> yes
00:51:27 <mniip> and you can further beta-reduce that
00:51:41 <knittl> and then \x -> fmap $ fmap x
00:52:09 <knittl> now. how can I get rid of the parentheses? (trying to work some transformations to understand syntax)
00:52:29 <{AS}> knittl: which parantheses? 
00:52:36 * hackagebot opengles 0.8.3 - Functional interface for OpenGL 4.1+ and OpenGL ES 2.0+  https://hackage.haskell.org/package/opengles-0.8.3 (capsjac)
00:52:39 <knittl> around that anon function
00:54:39 <{AS}> (fmap . fmap) $ mult3 $ sum ? 
00:54:51 <knittl> no, that doesn't work
00:54:57 <knittl> it is (fmap . fmap) mult3 sum
00:55:16 <knittl> and for the sake of learning I want to transform it into parens-free form
00:55:27 <mniip> knittl, beta-reduction
00:55:39 <mniip> apply the lambda
00:55:45 <knittl> I need to refresh my lambda-calculus knowledge
00:57:01 <knittl> (fmap $ fmap mult3) sum
00:57:17 <knittl> but they are still not gone :(
00:59:34 <{AS}> knittl: Sometimes it is not always possible to eliminate the paranthesis
01:00:42 <knittl> so in this specific case it's not possible?
01:01:26 <{AS}> knittl: I am not sure
01:01:46 <{AS}> @pl \sum mult3 -> (fmap $ fmap mult3) sum
01:01:47 <lambdabot> flip (fmap . fmap)
01:02:54 <{AS}> I guess flip $ fmap . fmap ?
01:03:31 <knittl> hm. no. doesn't work
01:03:35 <knittl> but well. nevermind
01:03:54 <{AS}> knittl: Why does that not work?
01:04:11 <knittl> because I cannot call the function
01:04:17 <knittl> let mult3 = (*)3
01:04:21 <knittl> let sum = (+)
01:04:37 <knittl> let m = (fmap $ fmap mult3) sum
01:04:47 <knittl> m 5 6        = 33
01:04:59 <{AS}> Oh wait, nevermind. You need the parantheses there
01:06:50 <mniip> what was the class that did (a -> b) -> (b -> a) -> f a -> f b
01:08:25 <{AS}> actually you can fmap $ fmap mult3 <$> sum
01:08:28 <{AS}> err
01:08:32 <MarcelineVQ> mniip: Invaritant maybe
01:08:40 <{AS}> knittl fmap mult3 <$> sum 
01:09:15 <mniip> MarcelineVQ, isn't that the opposite
01:09:21 <mniip> :t invmap
01:09:22 <lambdabot>     Not in scope: ‘invmap’
01:09:22 <lambdabot>     Perhaps you meant one of these:
01:09:22 <lambdabot>       ‘imap’ (imported from Control.Lens),
01:09:33 <MarcelineVQ> invmap :: (a -> b) -> (b -> a) -> f a -> f b
01:09:40 <mniip> mhm!
01:09:43 <mniip> thanks
01:10:26 <{AS}> I remembered that <$> is exactly fmap :)
01:10:32 <mniip> :t contramap (const ()) . fmap (const ())
01:10:34 <lambdabot> (Functor f, Contravariant f) => f b1 -> f b
01:10:43 <knittl> {AS}: thanks, will try out later
01:10:58 <knittl> ghc.io doesn't know <$>, but I will find a way. thanks!
01:12:04 <shadowswalker> hey guys, I need a program(backdoor) which will run on remote system using which I should be able to have remote access on that computer...
01:13:09 <liste> knittl: it does, you need to import Control.Applicative
01:13:43 <mauke> shadowswalker: wrong channel?
01:14:06 <peddie> shadowswalker: you'll probably need Network.Simple.TCP from the network-simple package
01:15:17 <peddie> shadowswalker: http://haddock.stackage.org/lts-5.6/network-simple-0.4.0.4/Network-Simple-TCP.html
01:17:14 <shadowswalker> thanks guys, do you guys know which channel to join to ask about backdoor/trojens (like hacking stuffs) 
01:17:25 <purelazy> What is "fix f = let x = f x in x" desugared?
01:17:41 <purelazy> can lamdbabot desugar?
01:18:05 <mauke> purelazy: that looks desugared already
01:18:23 <mauke> except fix = \f -> let x = f x in x
01:19:44 <purelazy> I read that let x = y in z deshugs to (\x -> z) y
01:20:03 <liste> purelazy: not in Haskell, in Haskell let is recursive
01:20:29 <liste> and you need either recursive let to define fix, or the other way
01:21:30 <mauke> also, function parameters are monomorphic
01:21:59 <mauke> > let foo = show in (foo (), foo 'x')
01:22:01 <lambdabot>  ("()","'x'")
01:22:02 <ggole_> I don't think you can implement let with (a single version of) fix
01:22:08 <mauke> > (\foo -> (foo (), foo 'x')) show
01:22:09 <lambdabot>      Couldn't match expected type ‘()’ with actual type ‘Char’
01:22:09 <lambdabot>      In the first argument of ‘foo’, namely ‘'x'’
01:22:09 <lambdabot>      In the expression: foo 'x'
01:23:06 <ggole_> (Single-binding let should be fine, apart from the type issue mauke just mentioned.)
01:27:01 <ggole_> Never mind, Oleg shows it can be done
01:30:11 <purelazy> ggole_, mauke, liste: I was under the impression "let"s were sugar
01:31:11 <qq03> purelazy: afaik, "let"s are a fundamental feature of the type system
01:32:04 <ggole_> purelazy: let-bound variables and arguments are treated differently in terms of polymorphism in Haskell, ML, etc
01:32:40 <ggole_> Because inferring the types of arguments is difficult/impossible
01:32:58 <ggole_> In explicitly typed languages like system F, let can be considered sugar for function application.
01:34:11 <ggole_> Wait, why are there two of me
01:57:38 * hackagebot swagger2 2.0.2 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-2.0.2 (NickolayKudasov)
01:58:38 <mniip> does anyone know the set of extensions that lambdabot uses?
01:59:20 <mniip> for some reason the code that worked in lambdabot raises a kind occurs check
02:00:26 <mauke> ghc --supported-extensions | grep -i kind   # candidates to try?
02:02:15 <mniip> I 3 of the 4 enabled
02:02:20 <mniip> fourth being ConstraintKinds
02:04:35 <mniip> oh
02:04:44 <mniip> I got it wrong, that's not the code I tested in lambdabot
02:06:26 <mniip> hmm
02:06:29 <mniip> might as well ask
02:06:33 <mniip> what's wrong with
02:06:43 <mniip> @let type family F a where F (f a) = f a
02:06:44 <lambdabot>  .L.hs:152:9:
02:06:44 <lambdabot>      Family instance purports to bind type variable ‘k1’
02:06:44 <lambdabot>        but the real LHS (expanding synonyms) is: F (f a) = ...
02:12:35 <mrt2> FOR REAL MAGICK... if you take strong ayahuasca its possible to change bodies with another person by looking that person in the eyes sucking inwards, when you have taken over that body kill yourself to inhabit that body forever... go for someone younger than yourself to live longer
02:12:54 --- mode: ChanServ set +o mauke
02:12:55 --- kick: mrt2 was kicked by mauke (no)
02:13:42 <mniip> hmm
02:13:44 <mniip> looks like a bug
02:14:11 <mniip> it's supposed to catch TyFam (TySyn tyvar)
02:14:24 <mniip> but 'k1' is not a tyvar, it's a kindvar
02:14:54 --- mode: mauke set -o mauke
02:18:49 <Ferdirand> Hello #haskell, what is the proper way to do something conceptually equivalent to "show . (:: Int) . read" ? 
02:20:21 <mauke> (\x -> show (x :: Int)) . read
02:20:58 <mauke> show . (`asTypeOf` length "") . read
02:21:00 <mauke> :-/
02:21:47 <Ferdirand> yes, but these are sort of aesthetically disappointing
02:21:54 <Ferdirand> i was hoping for something pretty
02:23:20 <ggole> showint . read where showint = etc
02:23:21 <u-ou> show . (id :: Int -> Int) . read
02:24:55 <Ferdirand> u-ou: ah, that's nicer already
02:25:12 <u-ou> it's kind of silly though
02:26:06 <Ferdirand> agreed, but it's charming in its own way
02:26:17 <u-ou> (show :: Int -> a) . read :P
02:26:40 <sindriava> How would I go about creating an efficient gap buffer in Haskell?
02:26:47 <sindriava> I'm lost without arrays tbh
02:38:24 <purelazy> Is "(:: Int)" a function?
02:38:44 <purelazy> From: <Ferdirand> Hello #haskell, what is the proper way to do something conceptually equivalent to "show . (:: Int) . read" ? 
02:39:22 <mniip> no
02:40:07 <purelazy> mniip: Was the questoin valid?
02:40:11 <purelazy> question
02:41:02 <kqr> asInt :: Int -> Int; asInt = id
02:41:07 <kqr> `show . asInt . read`
02:41:09 <kqr> I guess
02:41:36 <mniip> purelazy, yes
02:41:58 <mniip> it's obvious what they meant by (:: Int)
02:42:05 <mniip> it's like an operator section of (::)
02:42:56 <purelazy> its not true that it is obvious
02:44:15 <purelazy> because it was not obvious to me
02:44:16 <ozgura> purelazy: also see: http://augustss.blogspot.co.uk/2014/04/a-small-haskell-extension.html
02:50:38 <purelazy> ozgura: Thank you for the link
02:50:41 <purelazy> it helps
03:04:38 <hexagoxel> why is there no instance for MonadMask over MaybeT ?
03:04:50 <hexagoxel> is the obvious instance invalid?
03:09:45 <hexagoxel> ah, i guess it is invalid.
03:10:04 <hexagoxel> derp.
03:24:52 <mniip> hmm this is weir
03:24:52 <mniip> d
03:26:13 <Normen> A stack related question:
03:26:13 <Normen> Having two local stack projects in different directories: `~/prj1/{prj1.cabal, stack.yaml, ...}` and `~/prj2/{prj2.cabal, stack.yaml, ...}`. How to make `prj1` using `prj2`? I guess, this is not a multi-package project as described at http://docs.haskellstack.org/en/stable/GUIDE/#multi-package-projects
03:29:41 <mniip> why does exactTyCoVarsOfTypes [f :: (k1 :: *) -> (k :: *), a :: (k :: *)] return {f, a, k}
03:29:43 <mniip> but no k1
03:30:07 <lyxia> Normen: add '../prj2' in the "packages:" field of prj1/stack.yaml
03:33:20 <mniip> oh
03:33:33 <mniip> it's exactTyCoVarsOfTypes [k, f a]
03:41:39 <Normen> lyxia Thx.
03:48:31 <fr33domlover> Q: I want to implement a client-server protocol in which each sides sends a message, waits for response, processes it, replies, etc. until one side wants to finish the loop. Is there some tool for implementing such a thing besides using 'network' sockets directly? e.g. each side doesn't wait for a response forever and has a timeout, so abstracting over timeouts can be nice too. I looked at the 'warp' code
03:48:33 <fr33domlover> but i wonder if other/generic methods exist
03:54:11 <dave23> is it possible to re-export a module qualified?
03:55:46 <tennix> Is haskell dispatching function at compile time or runtime?
03:58:50 <dramforever> tennix: what do you mean by that?
04:00:22 <tennix> oh, sorry. I misunderstood typeclass
04:00:48 <dramforever> tennix: :) I was writing a message just to say that, glad you got it right :)
04:02:00 <dramforever> just one more thing: most "fancy" programming language features do not translate between Haskell and most languages. Maybe an analogy exists, but it almost surely works in a different way
04:02:41 <simpson> tennix: That's a good question! Some Haskell compilers figure out which instances of typeclasses are used at compile time, and some defer it to runtime.
04:03:23 <dramforever> IIRC GHC handle typeclass instances and data types the same way internally, so all the inlining applies
04:03:27 <dramforever> *handles
04:03:47 <tennix> OCaml doesn't have typeclass to allow ad-hoc polymorphism, so for efficiency there must be print_int and print_string
04:04:36 <simpson> tennix, dramforever: If you have the time, here's Oleg on the subject: http://okmij.org/ftp/Computation/typeclass.html
04:06:41 <Unhammer> Could not deduce (Aeson.ToJSON ByteString) … arising from a use of ‘Aeson.toJSON’
04:06:50 <tennix> typeclass is not like generics in mainstream languages, but i thought they were alike, so i asked that question
04:06:53 <Unhammer> I feel like that one should be in there
04:07:28 <Unhammer> instance Aeson.ToJSON ByteString where
04:07:30 <Unhammer>   toJSON = Aeson.toJSON
04:08:32 <Unhammer> compiles, but is that really the way to do it?
04:08:33 <simpson> tennix: I'm going to say "same thing" because the practical effects and usage are pretty much the same. I don't know of any two languages that both have a feature called "generics" and also have exactly the same semantics for them.
04:09:39 <tennix> actually after thinking carefully, generics has relation to typeclass
04:10:15 <merijn> generics is the Java/C# terminology for parametric polymorphism
04:10:36 <tennix> Rust uses trait which is similar to typeclass, and use trait to constraint generics
04:10:49 <merijn> The relation between typeclasses and parametric polymorphism is that typeclasses can essentially restrict the allowed types chosen for a parametric type parameter
04:11:02 <merijn> afaik Rust traits are basically typeclasses
04:11:14 <tennix> merijn: yes, exactly
04:11:21 <ggole> Generics seems to mean some kind of bounded polymorphism in the C-family world
04:12:05 <merijn> ggole: Java, C#, etc. all use generics to refer to parametric polymorphism. TaPL even covers/discusses Java generics in those chapters
04:13:03 <tennix> generics is used as a template to generate typesafe code at compile time
04:13:18 <ggole> When you type Foo<T extends I> you are usually understood to be using generics
04:13:38 <tennix> that's static dispatch
04:13:44 <merijn> ggole: I was just googling bounded polymorphism to check what it was and the wiki page explicitly calls it out as being available in OO languages "supporting parametric polymorphism (generics) such as Java, C# and Scala"
04:14:34 <merijn> generics are really pretty much entirely unrelated to "generating typesafe code", because "type safe code" is an oft misused and actually rather meaningless term
04:15:07 <ggole> What some wiki editor thinks a term means and how the term is actually used are quite different things
04:16:05 <tennix> thanks, i've got to go home now. talk you guys later
04:16:31 <ggole> I suspect that the exact meaning of the term (insofar as there *is* an exact meaning) depends mainly on which language community you are speaking to
04:16:40 <merijn> ggole: The wiki merely repeats what TaPL also says
04:17:51 <merijn> I doubt you can conjure up a more authorative source on the topic than TaPL, but anyway this is a rather uninteresting argument
04:18:58 <Myrl-saki> http://stackoverflow.com/a/3870310
04:19:08 <ggole> TaPL has nothing interesting to say on the subject of how people use technical jargon.
04:19:09 <Myrl-saki> "An element of S, e : 1 → S"
04:19:31 <Myrl-saki> What does 1 -> S mean? My guess would be a concrete type or something, but that makes no sense either.
04:20:11 <merijn> 1 is usually signifying Unit, i.e., () in haskell terms
04:20:30 <merijn> Therefore it's saying "e : () -> S"
04:20:44 <Myrl-saki> Isomorphic to e : S?
04:21:01 <merijn> Myrl-saki: Yes
04:21:04 <jagtalon> Hi! I was wondering if anyone could help me with the graphviz module. Pretty new to haskell and I don't quite know how to print the labels of the node in a graph
04:21:15 <Myrl-saki> merijn: Why make it complicated though?
04:21:21 <jagtalon> So I currently have :m + Data.Graph.Inductive.Graph Data.GraphViz Data.GraphViz.Printing
04:21:29 <merijn> Myrl-saki: Mathematical accuracy
04:21:47 <jagtalon> and something like "renderDot $ toDot $ graphToDot nonClusteredParams clr479" would only produce numbers in the nodes :(
04:21:48 <Myrl-saki> merijn: Can you explain?
04:22:41 <merijn> An endofunctor is a functor that maps objects and arrows from a category, back to the same category
04:23:03 <merijn> So, for example, Maybe is an endofunctor in the category (Hask) of haskell types
04:23:13 <Myrl-saki> Right.
04:23:24 <merijn> It maps haskell types (of kind *) to haskell types (Maybe X)
04:23:31 <Myrl-saki> Mhm.
04:23:50 <merijn> So a monoid in the category of endofunctors means that the objects were thinking of are endofunctors
04:24:18 <merijn> So we must have: an associative combination and identity element
04:24:43 <merijn> The identity for endofunctors is kinda boring, it's just the trivial endofunctor that maps every object and arrow to itself
04:25:01 <Myrl-saki> merijn: Wait, just for clarification, is it defined as `e : 1 -> S` simply for side-by-side comparison, or is that the "general" definition?
04:25:35 <merijn> Myrl-saki: tbh, the notation is fairly sloppy there, because he's mixing types, sets, and functions
04:26:07 <Myrl-saki> merijn: Mmm, someone in ##programming also told me not to mix types and functions.
04:26:48 <merijn> The formal definition of a monoid is just a triple (S,*,e) where S is a set, * an associative operation on S (i.e. "S x S -> S", or "S -> S -> S" in uncurried form) and "e" an element from S which is the left and right identity of *
04:26:56 <merijn> i.e. "e * x = x = x * e"
04:27:03 <Myrl-saki> merijn: Right.
04:27:21 <merijn> If we sorta squint at the type of (well...squint a lot...)
04:27:26 <merijn> join
04:27:28 <merijn> :t join
04:27:29 <lambdabot> Monad m => m (m a) -> m a
04:27:33 <Myrl-saki> Yeah
04:27:36 <Myrl-saki> I can see how it relates.
04:27:38 <merijn> Let's imagine we make join point free
04:27:55 <merijn> "m x m -> m"
04:27:58 <Myrl-saki> Mhm.
04:28:29 <merijn> Myrl-saki: Have you seen Bartosz' blog on CT for programmers?
04:28:43 <Myrl-saki> merijn: I think I have.
04:28:54 <merijn> http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
04:28:55 <Myrl-saki> merijn: Was it the one that related it to Python?
04:28:59 <merijn> No
04:29:04 <Myrl-saki> Mmm
04:29:05 <merijn> It explains CT via haskell and C++
04:29:08 <dramforever> What about this? let * be Compose, e be Identity, -> be natural transformation, = be isomorphic,
04:29:19 <merijn> dramforever: that's about it, yes
04:29:49 <merijn> Myrl-saki: Bartosz' knows what he's talking about and his blog (certainly the first parts) are fairly accessible
04:30:06 <dramforever> type Nat f g = forall a. f a -> g a, and let's call it a day
04:31:08 <Myrl-saki> merijn: I've been looking at CT from time to time for about 6 months, haven't really related it much with any programming language except for Haskell. That's not really stating much, but I think I'll get some concepts.
04:32:10 <dramforever> The part that blocked me was the "let * be Compose" part, but YMMV
04:34:02 <merijn> Myrl-saki: tbh, as someone who likes diving into the theory I always tell beginners to not get so focussed on CT. IMO it has the lowest return on investment, there's many more valuable AND easy things to study first :)
04:34:26 <merijn> I would recommend lambda calculus, type theory and algebra before worrying about CT
04:34:33 <merijn> You'll get much faster ROI from those
04:34:56 <Myrl-saki> merijn: I've also studied them from time to time.
04:35:12 <Myrl-saki> Oh right, this reminds me of crocodiles, lol.
04:35:30 <jophish> There are probably better ways of learning LC than those crocodiles...
04:35:39 <Myrl-saki> jophish: It's still funny though.
04:35:48 <merijn> tbh, TaPL is the best way to learn both LC and type theory imo :p
04:35:52 <Myrl-saki> jophish: At first, I thought it was satire on how games today are so hard. Lol.
04:36:02 <Myrl-saki> s/are so hard/have very complicated rules/
04:36:17 <Myrl-saki> Basically, the convo went something like this.
04:36:34 <Myrl-saki> "Is this satire?" "No, it's teaching LC to children." "Oh, LC, no wonder."
04:37:32 <Myrl-saki> merijn: Anyways, thing is, I want to learn how to make monads.
04:37:36 <Myrl-saki> Wait, BRB, going to eat.
04:45:47 <Myrl-saki> Back.
04:52:23 <Myrl-saki> deko-pyon: desuuu
05:02:23 <merijn> Myrl-saki: I don't think you make monads as much as you discover them :p
05:10:45 <{AS}> knittl: Sure it does, but you have to import Data.Functor (or Control.Applicative) :)
05:11:32 <Unhammer> ♥ undefined
05:13:38 <{AS}> Unhammer: for what do you use undefined? 
05:15:06 <Unhammer> right now, changed out an underlying lib, and have to rewrite large parts of a file, so I just put undefined in various places to make the portions I've done so far testable
05:26:29 <{AS}> Unhammer: You could also use holes I guess? Is there any advantage to undefined?
05:27:54 <dramforever> {AS}: Not exactly useful if you have a hell lot of them :)
05:28:31 <dramforever> You get extremely long error messages describing things you already know/don't care for now
05:29:10 <{AS}> Ah :)
05:29:18 <pavonia> Doesn't the latest GHC versions have deferring of error type errors already?
05:29:22 <{AS}> Thanks
05:29:24 <pavonia> *Don't
05:32:38 <Unhammer> oh didn't know this https://downloads.haskell.org/~ghc/7.6.1/docs/html/users_guide/defer-type-errors.html
05:38:00 <jgertm> is there a way to have hs-tls output the RSA session key so that i can debug a connection with wireshark>
05:48:40 <seishun> do I need to manually export all the record accessors to use them in another module?
05:49:21 <nut_> seishun, no you dont
05:50:05 <seishun> nut_: what can I do then?
05:50:17 <pie_> i got nothin
05:50:18 <pie_> bbl
05:50:22 <pie_> wrong chan
05:53:05 <oherrala> seishun: you can export YourType(..) to also export accessors
05:53:38 <seishun> oherrala: that works, thanks
06:01:35 <merijn> You can silence the warnings from typed holes, though
06:01:48 <merijn> Typed holes are always better than undefined for placeholders
06:07:46 * hackagebot proteaaudio 0.6.4 - Simple audio library for Windows/Linux/OSX.  https://hackage.haskell.org/package/proteaaudio-0.6.4 (CsabaHruska)
06:19:46 <Profpatsch> merijn: Was there some progress on using typed holes for editor autocompletion in the last months?
06:19:56 <Profpatsch> Asking for a friend. :)
06:20:16 <Profpatsch> Or what is the status of the haskell editor backend project? (whatever the name was)
06:23:06 <merijn> Profpatsch: No clue, I haven't been looking at that stuff recently :)
06:24:02 <merijn> I just like pimping typed holes because I didn't put in the effort to make them more convenient to use for nothing :p
06:28:45 <tennix> Say a function `let f a b = if a < b then a else b` is polymorphism, if another function with the same definition except only handles Int, will they have efficiency difference when both applied to Int?
06:29:20 <simpson> tennix: Depends on the compiler and the environment in which `f` is applied.
06:29:26 <{AS}> tennix: Do you mean it has type Ord a => a -> a -> a ? 
06:30:04 <merijn> tennix: Are you familiar with boxed/unboxed values? (From, say, java/C#?)
06:30:15 <{AS}> as simpson said, but I believe there are some pragmas to specialize things
06:30:31 <tennix> this function is just an example. what i want to ask is whether polymorphism function is less efficient than specific functions
06:31:13 <{AS}> tennix: Specialize pragma from here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html 
06:31:31 <simpson> tennix: It depends on whether the compiler is capable of monomorphizing polymorphically-defined functions, and also on the situation in which the function is applied, which might affect the compiler's decisions WRT specializing and inlining.
06:31:35 <tennix> because in OCaml this has difference, so they make print_int, print_string etc functions
06:31:57 <sindriava> I'm trying to build a Vty project, but i'm getting "RTS doesn't support multiple OS threads (use ghc -threaded when linking)"
06:32:10 <sindriava> Yet adding ghc-options to my cabal file doesn't help. Is this a known issue?
06:32:14 <sindriava> Am I doing something wrong?
06:32:19 <merijn> Monomorphising doesn't really make things faster. The thing that helps improve performance is the fact that monomorphised code can potential unboxed
06:32:27 <merijn> sindriava: Did you "cabal clean" after adding it?
06:32:34 <sindriava> merijn: I'm using stack
06:32:48 <merijn> sindriava: cabal doesn't take compile flags into account when deciding whether it needs to recompile :)
06:32:54 <merijn> sindriava: "stack clean" or whatever it's called, then
06:32:59 <{AS}> merijn: Of course :)
06:33:32 <simpson> merijn: Isn't boxing itself a compiler-specific choice and not a mandate from the language spec?
06:33:32 <sindriava> merijn: Ah, that helped! This is terribly confusing though :(
06:33:54 <tennix> simpson: merijn: so it's not easy to determine whether ghc will do a monomorphisation, right?
06:33:59 <{AS}> merijn What I meant is that you can give a hint to the compiler if you want to monomorphise which might allow it to optimize more for your particular situation
06:34:05 <xa0> someone in ##math spent the last hour or two trying to define division by 0 for a language he's making
06:34:42 <xa0> but it did raise an interesting point, you could defer the division by zero, by making a type Div num 
06:34:43 <sindriava> xa0: Point them to ##looneybin
06:34:47 <xa0> haha
06:34:55 <simpson> tennix: It's possible to determine case-by-case whether GHC is doing certain things, but I don't know the nature or value of that.
06:35:02 <merijn> simpson: Yes, but I don't know if any language that implements parametric polymorphism without boxing, except maybe some ML versions?
06:35:13 <merijn> I guess C++ if you count templates as polymorphism...
06:35:19 <merijn> (Which I don't really)
06:35:26 <jaarod> why not?
06:35:30 <sindriava> merijn: ++
06:35:32 <xa0> they're resolved at compile time
06:35:38 <jaarod> yes
06:35:41 <merijn> jaarod: Polymorphic code, to me, means 1 code path for every type
06:35:56 <merijn> jaarod: Templates results in every type having it's own code path
06:35:58 <simpson> merijn: It's possible in a certain untyped object calculus (which which I happen to be familiar) to both not box generic objects and also still erase their types, via modern JIT technology.
06:36:02 <tennix> simpson: so that's only possible but not easy to determine
06:36:11 <simpson> merijn: But, as you say, it's not especially relevant to Haskell.
06:36:20 <sindriava> merijn: To be fair, I'm not sure that's a C++ thing, but rather a compiler thing
06:36:28 <simpson> tennix: FIIK. I'm barely even a Haskeller. You probably want somebody that knows about GHC.
06:36:30 <merijn> sindriava: No, in C++ that's what the language mandates
06:36:34 <{AS}> merijn: Why not? 
06:36:45 <{AS}> why don't you count templates as polymorphism?
06:36:48 <sindriava> merijn: Oh, good to know :) Thanks ^^
06:37:09 <xa0> {AS}: he just explained that
06:37:16 <tennix> https://en.wikipedia.org/wiki/Polymorphism_(computer_science)
06:37:17 <merijn> simpson: Yeah, I remember a guy giving a presentation on JVM optimisations/analysis to deal with boxing/unboxing :)
06:37:19 <{AS}> Ah
06:37:35 <{AS}> I missed it 
06:37:37 <tennix> that's wikipedia definition of polymorphism
06:37:57 <simpson> merijn: Basically, a JIT with this technique would apply whole-program optimization to only a small section of the code, and all of the types would become eventually monomorphic under that analysis.
06:38:28 <merijn> simpson: btw, if you're interested in supercool JIT tricks, lookup the Graal and Truffle projects :)
06:38:45 <mniip> I think I found a bug in the typechecker :o
06:38:57 <simpson> merijn: Truffle's really cool. If I were writing a JIT today, instead of two years ago, I would consider Truffle. Its only sin is requiring me to write Java.
06:39:07 <xa0> mniip: impossible!
06:39:14 <mniip> The "impossible" happened!
06:39:14 <tennix> OCaml compiler can't do monomorphism, so OCaml programmers prefer to explicit monomorphisize it
06:39:30 <merijn> simpson: I think it's the coolest project that no one ever heard about when I was at Oracle Labs
06:39:47 <simpson> merijn: JIT generators are super-cool.
06:39:47 <{AS}> I disagree, polymorphism is a semantic concept, otherwise ML would not be polymorphic :)
06:39:49 <merijn> simpson: Not really useful to me, since it's mostly focussed on dynamic languages, but still :)
06:40:55 <{AS}> Unless I am misunderstanding what a codepath is
06:41:01 <simpson> merijn: Hey, Java implementations tend to be JIT'd, and it's paid off well for them. Clearly something is interesting there.
06:41:50 <merijn> simpson: I'm more interested in higher level languages for bare metal, so the JVM/runtime requirement means it's not that interesting to me :)
06:42:14 <merijn> {AS}: My opinions are not internally consistent :p
06:42:22 <{AS}> :)
06:42:37 <vincenz> merijn: are they observationally consistent?
06:42:55 <merijn> vincenz: Probably not?
06:43:15 <vincenz> merijn: so you're saying stochastically consistent?
06:43:19 <vincenz> since you mention probability
06:43:57 <merijn> vincenz: I would say ML has polymorphism-ish, but not C++ templates, but I can't pinpoint why :p
06:45:21 <jaarod> nice thing about templates is that there is no speed penalty for abstraction
06:45:22 <vincenz> merijn: probably because c++ templates don't go through the same function, but rather duplicate the function, template-style
06:45:35 <vincenz> actually, that's probably also true for ML
06:45:43 <vincenz> type classes don't duplicat efunctions
06:45:47 <sindriava> Is there someone familiar with `vty'?
06:46:07 <merijn> sindriava: I used it once, does that count?
06:46:26 <merijn> sindriava: Are you trying to create a terminal GUI? Or just directly working with the terminal?
06:46:32 <{AS}> merijn: Maybe because C++ templates have the philosophy if it compiles everything is OK? Whereas ML at least tries to have a type system
06:46:34 <tennix> ML of course has polymorphism
06:46:35 <merijn> s/GUI/UI
06:46:42 <sindriava> merijn: UI, I'm working on an editor
06:47:24 <merijn> sindriava: Have a look at brick (the successor of the now deprecated vty-ui)
06:47:45 <merijn> sindriava: It's build on vty but has stuff like UI widgets (textboxes, etc.) and events
06:47:58 <merijn> @hackage brick
06:47:59 <lambdabot> http://hackage.haskell.org/package/brick
06:48:05 <tennix> Rust has generics to generate code at compile time, so no speed penalty either
06:48:07 <sindriava> merijn: When I exit it, it breaks my prompt, making it display "â Î»" instead of lambda
06:48:23 <sindriava> merijn: Oh, thanks! I'll have a look :)
06:49:06 <merijn> (also dialog boxes, etc.) vty-ui was miles ahead of working with vty directly, and I've heard brick has an even nicer API
06:49:28 <sindriava> merijn: yeah, it looks really straightforward just from looking at it! Thanks for the tip :)
06:54:13 <mniip> xa0, https://ghc.haskell.org/trac/ghc/ticket/11699
06:58:03 * hackagebot clash-lib 0.6.11 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.11 (ChristiaanBaaij)
06:59:17 <mniip> can any type theory person comment? :o
06:59:20 <ejbs> What do you call the property of a pure program whereby you can replace a function call with the body of the function as long as naming is taken care of to avoid name clashes?
06:59:35 <mniip> referential transparency I believe?
06:59:57 <ejbs> Yes! Haha, I had "referential integrity" stuck in my head but that's obviously not correct :)
07:01:34 <geekosaur> I keep swapping those two as well >.>
07:02:20 <merijn> mniip: eh, where is 'f' supposed to come from?
07:02:58 <jaarod> i am trying to think of an example where you could not replace a function call with the body of a function and have it work, even if it is not pure.
07:03:03 * hackagebot clash-systemverilog 0.6.6 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6.6 (ChristiaanBaaij)
07:03:05 * hackagebot clash-verilog 0.6.6 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6.6 (ChristiaanBaaij)
07:03:07 * hackagebot clash-vhdl 0.6.8 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.8 (ChristiaanBaaij)
07:03:09 <jaarod> and i can't think of any
07:03:09 * hackagebot clash-ghc 0.6.11 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.11 (ChristiaanBaaij)
07:03:26 <mniip> merijn, ?
07:03:39 <merijn> mniip: In that ticket?
07:03:46 <mniip> you mean in 
07:03:47 <mniip> type family F a where F (f a) = f a
07:03:51 <merijn> Yes
07:04:00 <mniip> it's bound in the LHS?
07:04:21 <merijn> mniip: The LHS is nonsensical, though
07:04:26 <mniip> it isn't?
07:04:33 <merijn> mniip: What's it supposed to mean?
07:05:13 <mniip> if the argument is an application, bind a to the argument and f to the, uh, the other thing?
07:05:32 <mniip> I mean, you can already say (f a) -> f, and (f a) -> a
07:05:43 <merijn> mniip: You can't match on applications, afaik
07:05:55 <merijn> I don't even see how matching on applications would even make sense?
07:06:04 <mniip> @let type family Moo a where Moo (f a) = f
07:06:05 <lambdabot>  Defined.
07:06:22 <mniip> :t Proxy :: Proxy (Moo (Either Char Int))
07:06:23 <lambdabot> Proxy (Moo (Either Char Int))
07:06:26 <merijn> That'd be like 'case foo of f a -> "blah"' being able to "match" an application on the value level
07:06:27 <mniip> er
07:06:48 <merijn> :k Moo (Either Char Int)
07:06:48 <mniip> well you definitely can say
07:06:49 <lambdabot> k -> *
07:06:56 <mniip> :t undefined :: Moo (Either Char Int) String
07:06:57 <lambdabot> Either Char String
07:07:31 <merijn> mniip: I wouldn't be sure that's intentional
07:07:39 <merijn> not sure, though
07:10:20 <sindriava> merijn: Thanks for the `brick' tip ^^ It does, however, still break my prompt :(
07:10:43 <merijn> sindriava: I would suspect your TERM environment variable is messed up
07:10:52 <merijn> And/or your locale
07:11:09 <sindriava> merijn: TERM is the same as it was before, but you might be right with the locale
07:11:55 <sindriava> merijn: Nope, locale is also unchanged when I exit the vty app
07:12:38 <sindriava> I'm using fish, so maybe there's some incompatibility there
07:13:05 <merijn> sindriava: No, I mean your TERM variable might be lying and not set to the right value for your terminal :)
07:13:13 <mniip> merijn, well any type is either a basic type or an application
07:13:24 <mniip> I don't see any problems with match on type application
07:13:55 <sindriava> merijn: Ah, I see. I don't think that should be the case, I've got it set to xterm-256color, which worked for me perfectly before
07:14:05 <sindriava> merijn: I'm using iTerm2 on the newest OS X
07:14:47 <merijn> No clue then, try filing a bug? Last time I encountered a vty problem he was fairly responsive
07:15:41 <sindriava> merijn: It looks like it dumps some garbage onto the command line on quit. when I use another terminal app, it doesn't break, but outputs "G@" O.o
07:16:03 <sindriava> merijn: Yeah, I'm going to do that. I was trying to gather some info first, but I'm just as clueless
07:16:19 <sm> brick is brilliant
07:16:37 <sm> needs more users
07:16:58 <merijn> sindriava: vty-ui had a "debug" program for reporting issues
07:17:23 <merijn> sm: Haven't used it, but vty-ui was great albeit a bit cumbersome UI, so from what I've seen brick should be a nice improvement :)
07:17:26 <merijn> Gym time now
07:19:03 <Shockk> mniip: idk if this is relevant but if I change your test case to `type family F (a :: k1) where F (f a :: k1) = f a` I get the same error about type variable `k' and not `k1'
07:19:06 <Shockk> which is weird
07:22:56 <mniip> Shockk, because it's now called k1
07:23:00 <mniip> it's not weird at all
07:23:17 <Shockk> oh, maybe I'm misunderstanding the error
07:23:47 <mniip> @let foo :: magic; foo = foo
07:23:48 <lambdabot>  Defined.
07:23:52 <mniip> :t (foo, foo, foo, foo)
07:23:53 <lambdabot> (t, t1, t2, t3)
07:24:11 <mniip> well anyway, that's just tyvar naming
07:28:04 * hackagebot fn 0.3.0.1 - A functional web framework.  https://hackage.haskell.org/package/fn-0.3.0.1 (DanielPatterson)
07:28:06 * hackagebot fn-extra 0.3.0.1 - Extras for Fn, a functional web framework.  https://hackage.haskell.org/package/fn-extra-0.3.0.1 (DanielPatterson)
07:31:20 <{AS}> > :t magic
07:31:21 <lambdabot>  <hint>:1:1: parse error on input ‘:’
07:31:27 <{AS}> What is magic?
07:32:16 <unit73e> hey
07:32:57 <unit73e> what do you guys use to edit haskell files? a text editor like vim? I tried leksah but I didn't get how it works
07:33:33 <Jinxit> just a plain text editor for me
07:33:35 <unit73e> It didn't seem to have the powers of modern IDE like Eclipse and friends
07:33:52 <unit73e> like auto-complete
07:34:03 <ClaudiusMaximus> {AS}: a type variable, just like a and b
07:34:34 <unit73e> can vim auto-complete haskell functions?
07:34:44 <{AS}> ClaudiusMaximus: Ah thanks :)
07:34:54 <{AS}> Was completely misled 
07:37:13 <sindriava> unit73e: I'm using Emacs.
07:38:43 <Profpatsch> sindriava: brick is awesome. And afaik you can use vty where brick does not provide what you need.
07:49:46 <unit73e> so I guess no IDE. I'll just stick to vim.
07:49:58 <unit73e> I tried yi too. It is ok.
08:12:24 <mniip> merijn, the great and powerful spj himself said that such type families are fine :o
08:13:06 * hackagebot iridium 0.1.5.1 - Automated Testing and Package Uploading  https://hackage.haskell.org/package/iridium-0.1.5.1 (lspitzner)
08:14:54 <sm> nice
08:15:39 <sm> very nice.
08:38:35 <NemesisD> does anyone know what kind of performance impact library/executable profiling and -fprof-auto has on haskell programs?
08:44:50 <eitanChatav> good morning
08:45:39 <shachaf> hitan
08:46:04 <eitanChatav> hi shachaf
08:46:34 <eitanChatav> :-)
08:51:55 <cmotoche> Is a good practice define all the fields in a record as strict (by adding the bang at the beginning of the type)? For instance: data Type = { field :: !Text, field2 :: !Integer, field3  :: !Boolean} 
08:57:17 <edwardk> NemesisD: anywhere from a 20x slowdown to a 5% speedup ;)
08:57:42 <NemesisD> edwardk: ouch and/or great!
08:59:22 <NemesisD> edwardk: i've got an issue occurring in which it would be helpful to have a stack trace and i'm trying to determine if i should try to build profiling versions of my executables until the issue is resolved or if i shouldn't bother and just always run profiling executables in production
09:00:00 <edwardk> profiling builds tend to do all sort of wonky things, mostly to high end optimizations
09:01:02 <EvanR> cmotoche: for fields like that, probably
09:01:28 <EvanR> if you want to save memory
09:01:47 <EvanR> but you might pay for it with time spend evaluating it all when you might not use it
09:02:14 <EvanR> if you definitely will use it, then use !
09:02:33 <EvanR> but this only applies when the field types are small things like Words Integers or Bools
09:03:12 <cmotoche> Ok, EvanR, thanks.
09:03:43 <EvanR> and when you want to pay the computation cost now and not later
09:03:48 <NemesisD> edwardk: ok, sounds like i'm probably better off trying to figure out building both versions with stack
09:09:48 <Sonolin> any reason why this doesn't work?
09:09:51 <Sonolin> a <- getArgs
09:09:57 <Sonolin> a !! 0 :: ByteString
09:10:00 <Sonolin> with OverloadedStrings of course
09:10:13 <Sonolin> getting this error: 
09:10:21 <Sonolin> Couldn't match type [char] with [ByteString]
09:10:49 <EvanR> :t getArgs
09:10:50 <lambdabot> Not in scope: ‘getArgs’
09:11:12 <EvanR> are you thinking that OverloadedStrings will make getArgs return ByteStrings?
09:11:13 <Sonolin> its from System.Environment
09:11:37 <Sonolin> I guess... I mean I'm just looking for an easy way to interact with different string(ish) types
09:11:41 <EvanR> or !! do an implicit conversion
09:12:02 <Sonolin> using Data.Aeson its really annoying because everyhting is either String, Text, and/or ByteString and having "pack" calls everywhere is cumbersome
09:12:10 <pavonia> You have to explicitly convert the String to a ByteString
09:12:16 <Sonolin> hmm I see
09:12:32 <EvanR> in aeson you should use Text for text, and ByteString for the raw json data
09:12:33 <Sonolin> so that only works for decalred strings like "test" :: ByteString ?
09:12:44 <EvanR> OverloadedStrings just lets you use string literals
09:15:25 <EvanR> since getArgs returns Strings, youll need to pack them into Text
09:15:42 <EvanR> to cooperate nicely with other Text stuff
09:15:49 <EvanR> fmap (map pack) getArgs
09:17:36 <EvanR> Sonolin: checkout optparse-applicative to skip the boring conversion from args to the proper option structure
09:37:08 <Sonolin> thank you I mostly figured out just trying to figure out my parse errors
09:37:33 <Sonolin> any idea what this means: failed to parse field test: expected (), encountered String
09:38:08 * hackagebot Plot-ho-matic 0.9.0.5 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.5 (GregHorn)
09:38:52 <hpc> is that package name a mishearing of the lyrics to technologic?
09:46:34 <ClaudiusMaximus> is there a ready made parsec parser for Double or do i have to write it myself?
09:47:31 <ClaudiusMaximus> ideally it would give me a string that i can then  readSigned readFloat  to get a Rational with full precision if i so desired
09:48:22 <mauke> so you want a parser for Double that doesn't parse a Double
09:48:26 <sm> ClaudiusMaximus: I think there's something in one of the parsec packages (megaparsec too). If not I can share one
09:48:27 <mauke> but a String. or a Rational
09:48:46 <sm> a decimal
09:49:33 <pavonia> ClaudiusMaximus: Parsec has some predefined definitions for programming languages in Text.Parsec.Language, where you could use individual parsers from
09:50:02 <EvanR> attoparsec has double :: Parser Double
09:50:26 <sm> http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Token.html#v:decimal eg
09:50:34 <EvanR> and rational :: Fractional a => Parser a
09:51:00 <ClaudiusMaximus> mauke: yeah! more precisely something that matches the output of show :: Double -> String
09:51:19 <EvanR> rational :: Fractional a => Parser a
09:51:43 <EvanR> i dont know why you want to get a String though
09:51:56 <EvanR> unless youre talking about an unparser
09:57:16 <ClaudiusMaximus> EvanR: for reasons, i think i actually want a parser for Data.Scientific (whose documentation has the reasons)
09:58:49 <EvanR> rational parser parses formats like "123e321"
09:59:09 <EvanR> but scientific works
09:59:17 <EvanR> just dont divide by 3
10:00:12 <ClaudiusMaximus> :)
10:00:29 <sm> lol
10:02:42 <obadz> Does anyone actually use Haste? the silence on the Haste IRC channel is depressing :-(
10:02:56 <Zemyla> EvanR: Couldn't you have a format that's something like (Rational)*10^(Integer) so you can get the best of both worlds?
10:06:14 <EvanR> Zemyla: er... power of 10 scaled by a rational?
10:06:26 <EvanR> i would be intested to see the arithmetic
10:07:08 <ClaudiusMaximus> Zemyla: how about storing integral :: [(Integer, Int)] where the list is the powers of the prime factorization, then rational operations become simpler
10:07:42 <ClaudiusMaximus> so 12 becomes [(2,2),(3,1)]
10:08:05 <Zemyla> ClaudiusMaximus: I want to see the addition for that type.
10:08:19 <EvanR> hey, if you dont need addition ;)
10:08:29 <ClaudiusMaximus> :)
10:08:54 <EvanR> not sure if "rational ops" become simpler... like recip?
10:09:23 <ClaudiusMaximus> so attoparsec's scientific is what i want, but i'm using regular parsec....
10:09:59 <simpson> EvanR: As a general rule (I don't know of a reason *why* or why not), all number representations have cheaper and more expensive operations compared to other representations.
10:10:21 <simpson> Rational reciprocation is cheap, and so are things like multiplication and division. Addition and subtraction are more expensive though.
10:10:52 <hpc> because we use numbers all the time and who would ever want it to be easy?
10:11:02 <EvanR> hold on youre forgetting representations where everything is more expensive! ;)
10:11:18 * geekosaur drops a Peano on EvanR >.>
10:12:32 <EvanR> hey you can add 1 very fast with peano numbers
10:13:25 <ski> addition on integers represented via prime factorization seems to be expensive
10:13:31 <simpson> Mm.
10:14:03 <nitrix> I know how we could make arithmetic simpler.
10:14:15 <EvanR> yeah just adding 1 to factored number is hellish
10:14:27 <EvanR> 1 is ruining everything
10:15:23 * ski was pondering how to define type equalities, the other day
10:15:42 <shachaf> How about type inequalities?
10:15:51 <Ladyboy2000> tities!
10:16:33 <simpson> nitrix: Shoot.
10:16:50 <Ladyboy2000> pew pew pew!!
10:17:05 <Zemyla> ski: newtype TypeEq a b = TypeEQ (forall f. f a -> f b)
10:17:36 <simpson> nitrix: No, seriously, I'm interested. What's your thought?
10:17:51 <EvanR> this punchline better be good
10:17:54 <ski> Zemyla : no, not (defining) the type of (type) equalities. defining *specific* (proofs of) type equalities
10:19:32 <parsecChar> is there anyway to install haste-compiler via stack ?
10:19:59 <ski> Zemyla : e.g. ⌜diag : ℕ ⊗ ℕ =_⋆ ℤ ⊗ ℕ⌝, translating by checking which diagonal you're in, and how far into it
10:20:32 <prooftechnique> parsecChar: https://github.com/commercialhaskell/stack/issues/1865
10:20:52 <prooftechnique> Looks like it just got resolved last week
10:21:04 <parsecChar> ha; nice!
10:21:18 <shapr> @quote cale
10:21:18 <lambdabot> Cale says: Cale: ugh, Cale: foldl f z [] = z
10:21:31 <Cale> w... what?
10:21:35 <shapr> I dunno
10:22:48 <Zemyla> Also, is there a single thing where you would use a strict finite list where a Seq wouldn't always be better?
10:23:05 <EvanR> thats a terrible quote
10:23:28 <EvanR> Zemyla: a stack?
10:24:25 <parsecChar> prooftechnique: actually, wait
10:24:28 <parsecChar> that shows how to build it from the haste dir
10:24:34 <parsecChar> what if I want to build it ousdie of haste dir?
10:24:58 <Zemyla> EvanR: cons and snoc are O(1) for a Seq as well.
10:25:08 <EvanR> right but theres some overhead for the Seq
10:25:23 <EvanR> and you dont get any benefit from the Seq since you dont care about the inside
10:25:35 <prooftechnique> parsecChar: Couldn't you just build it there, then link the binary wherever you want it? Or even copy it?
10:25:37 <EvanR> and its less convenient haskell wise
10:25:52 <parsecChar> prooftechnique: yeah; my request sounds stupid in retrosepct
10:26:36 <prooftechnique> parsecChar: It also looks like you can `stack install --local-bin-path <dir>`, though I think that's just for install, specifically
10:26:43 <prooftechnique> Rather than build
10:28:26 <parsecChar> actually, if I'm building it out of dir
10:28:29 <parsecChar> why do I want stack at all?
10:39:26 <prooftechnique> Dunno, I figured you had reasons
10:51:16 <roelof> Anyone experience with the plugins on intelij idea ? Can I on  one of them see types of variables ? 
11:02:32 <roelof> Anyone experience with the plugins on intelij idea ? Can I on  one of them see types of variables ? 
11:04:03 <pdxleif_> The Haskell plugin?
11:05:20 <roelof> pdxleif:  yes, or the Haskell Force plugin 
11:11:47 <nitrix> Well, two of my managers rage quitted today.
11:12:04 <Gurkenglas> Can you asum over a Cofree where f is Alternative, as you would fold over it where f is Foldable?
11:12:11 <nitrix> And it's friday. Party! :D
11:14:07 <roelof> nitrix:  and Monday looking for new managers ?? 
11:14:22 <johnw> Gurkenglas: if you don't know the f, it might not terminate
11:14:28 <danilo2> Hello guys! We need a crazy stuff here. Namely we want to profile some Haskell expressions, but without loosing the lazyness. In general we want to display the time an expression took to compute in runtime, but without using `seq` nand other machinery that will broke down the laziness. Is there any way to do it? I know RTS is able to somehow show such information so I bet there is a way to optain this info.
11:15:24 <Gurkenglas> johnw, that's fine if it streams lazily, the same can be said for Foldables, and I do know the Alternative :P
11:16:59 <xoitx> >
11:17:23 <xoitx> How to see chat history?
11:19:35 <mniip> danilo2, seq doesn't break down the laziness
11:19:41 <sm> xoitx: http://ircbrowse.net/day/haskell/today?mode=recent
11:20:05 <mniip> you can do something like
11:20:39 <danilo2> mniip: doesnt seq evaluate to WHNF?
11:20:49 <mniip> only when evaluated
11:21:05 <mniip> > let x = undefined `seq` undefined in ()
11:21:07 <lambdabot>  ()
11:21:19 <mniip> tracedx = unsafePerformIO $ do startTimer; r <- evaluate x; stopTimer; return r
11:21:30 <mniip> but as the function name suggests, you have to be careful
11:22:10 <danilo2> mniip: oh sure, anyway I don't want its behaviour. My mistake I mentioned it in the comment. I just want to measure the time of some function but without affecting evaluation and laziness in general
11:22:34 <mniip> the thing I posted above will affect nothing
11:22:50 <Gurkenglas> Looking for something like "(a -> f b -> b) -> Cofree f a -> b"
11:22:54 <mniip> well, with a possible exception that tracedx might possibly inline differently than x
11:24:01 <danilo2> mniip: Ok, but lets imagine I've got a lot of funcitons called dynamically in the porgram (so they are stored in some kind of list) and I'm evaluating them and storing the resulted data somewhere else. I just want to know how much time the computation took, but they are all lazy and in fact I cannot evaluate them to WHNF because they often have infinite computations inside, but the program doesnt need the infinite results and cuts i
11:24:44 <mniip> ironically, your message got cut off after "cuts i"
11:25:26 <danilo2> mniip: heh :D "cuts it down" 
11:25:46 <johnw> Gurkenglas: Cofree f a -> b isn't something you can generalize safely; b -> Cofree a you can
11:26:01 <mniip> so you have a lazily generated structure
11:26:06 <mniip> and you want to know what exactly?
11:26:11 <johnw> if you really want Cofree f a -> b, why aren't you using Free?  In Haskell it can represent infinite structures too
11:26:55 <danilo2> mniip: Yes, I've got a lot of lazy generated structure and some of them are computed to some point because I need to use it later (like write it to file or display in GUI) and I want to know how much time it was needed to compute them and in particular how much time a particular function needed to evaluate
11:27:35 <mniip> well what's the problem with my solution?
11:27:42 <Gurkenglas> Because Cofree has annotated nodes. Why's there a Foldable instance for Cofree then?
11:29:03 <mniip> danilo2, and seq doesn't "evaluate" anything,
11:29:16 <mniip> it's just a way to hook evaluation of something to evaluation of something else
11:30:01 <Gurkenglas> (Also generalize to what?)
11:30:03 <johnw> Gurkenglas: can't you write the function that you want then?
11:30:53 <Gurkenglas> Yea, trying to find a way atm to not have it feature manual recursion
11:31:56 <EvanR> danilo2: hold on hold on
11:32:07 <EvanR> danilo2: you CAN evaluate them to WHNF even if they are infinite
11:32:16 <EvanR> you can measure the time it takes to evaluate to WHNF
11:32:17 <danilo2> mniip: The problem with your solution (tracedx) is that it measures the time needed by the IO Monad, but if the function `x` is lazy and we pass this x to some further parts of the program that determine what part of `x` will be computed in reality, you're function will not result in the real time (If im not wrong)
11:33:02 <mniip> danilo2, we will determine the time it took to evaluate the WHNF of the function's result
11:33:05 <EvanR> you can also measure time it takes to deepseq something to Normal Form if applicable
11:33:13 <mniip> that too
11:33:19 <mniip> evaluate (force x)
11:33:41 <mniip> although that's questionably useful on an infinite structure
11:34:14 <EvanR> force shouldnt work on infinite data
11:34:26 <mniip> yup it would return bottom
11:34:40 <EvanR> er.. oh, is [a] NFData?
11:34:48 <danilo2> mniip, EvanR Ok but as I understand correctly, `force` will force the computation of `x` - but I dont want to do it. I want to measure the time that `x` needed but in the conditions of the program. So If `x` is a long list of numbers and only the head is needed later, I dont want to `force` computing it all
11:35:20 <EvanR> danilo2: then dont measure computing any of the list at all, measure the time it takes to do the thing with the list
11:35:42 <mniip> danilo2, then don't force
11:36:00 <mniip> hm
11:36:17 <danilo2> mniip, EvanR: In fact I see that RTS provides something very simmilar to what I need, but I would like to access the data in Haskell and in ms (not in percentage time): http://stackoverflow.com/questions/11594481/profiling-a-haskell-program   (look at the figure with "COST CENTRE" caption
11:36:22 <EvanR> WHNF on a list isnt even going to help figure out computing the contents
11:36:22 <mniip> you can put the whole thing to trace in this way...
11:37:03 <danilo2> mniip: it will not help with the problem I think, because then I'll measure the "whole thing" time, not the time of function-components
11:37:08 <EvanR> yeah profiling can tell you how much time is spent in certain expressions
11:37:15 <mniip> danilo2, function-components?
11:37:37 <EvanR> lazy evaluation kind of voids any estimate how "time it takes to evaluate a function"
11:37:50 <danilo2> mniip: I mean all the functions that was composed togethwr to provide the result. Sorry for such not-understandable abbreviation! :D
11:38:13 * hackagebot midair 0.2.0.0 - Hot-swappable FRP  https://hackage.haskell.org/package/midair-0.2.0.0 (TomMurphy)
11:38:14 <mniip> danilo2, I'm not following
11:38:18 <EvanR> you have to get a well defined thing to measure before attempting to measure ;)
11:38:28 <mniip> ^
11:38:29 <danilo2> EvanR: Ok, but please take a look at the link I provided. GHC's RTS is able to tell how much time each function took to evaluate to compute the needed data.
11:38:59 <mniip> it takes next to no time to compute functions in haskell
11:39:09 <mniip> you just create an AP closure and set the arguments
11:39:17 <mniip> what costs time is the evaluation of the result
11:39:25 <EvanR> danilo2: i have a hard time understanding the breakdown in the profiling results, i dont really know what %time means
11:40:06 <mniip> danilo2, and in the thing you linked,
11:40:33 <mniip> it's not actually time spent in functions - that's a rather meaningless concept in GHC
11:40:39 <mniip> it's time spent in thunks
11:40:48 <mniip> respective to what function they were created in
11:41:35 <danilo2> mniip: Ok, maybe that's the correct description of the problem. I would love to know what is the time needed to evaluate the thunks respective to what function they were reated in
11:42:06 <danilo2> mniip:, EvanR In fact this is what I want. I just described it to simply and didn't though about such problem statement
11:42:51 <EvanR> yeah if you have a thunk, then it can either evaluate to some WHNF in some time, or freeze/crash
11:43:00 <mniip> hmm
11:43:03 <EvanR> but in the process of evaluating 1 thunk you will force others
11:43:10 <mniip> I don't think you can introspect profiling information, can you?
11:43:39 <mniip> it's pretty trivial to write your own profiling though, in the way I described above
11:44:22 <mniip> and if you know the shape of your returned structure, you can even recursively poison it with such profiling annotations
11:44:45 <EvanR> mniip: this exercise is something youre supposed to want a profiler to do for you ;)
11:44:54 <danilo2> mniip: Maybe I just dont understand your solution, but I dont think it will give me information just like the one I get from GHCs RTS, will it? So will it work for lazy functions and just these thunks that were needed to compute omewhere later in the program ?
11:45:29 <mniip> it won't affect data evaluation in any way, it'll just invoke IO in a few spots
11:45:41 <mniip> but no, it won't get you the bits of information you get from profiling,
11:45:45 <mniip> it will only measure the time
11:47:55 <danilo2> mniip: It will only measure the time of the IO action, not the time needed to compute tht thunks, because the result of your profiling function is lazy and it will report time of 0 ion vast majority of cases
11:48:06 <mniip> no?
11:48:18 <danilo2> mniip, EvanR Is there any way to access the data provided by the RTS withing Haskell ?
11:48:32 <danilo2> mniip: why not? Sorry I must miss something here
11:49:53 <mniip> entering (attemtping to evaluate to whnf) tracedx will execute some IO, then enter x, then execute some more IO, and then tracedx will evaluate to whatever x evaluated to
11:49:54 <EvanR> dunno look through the GHC modules
11:50:37 <mniip> I'm looking at GHC.Prim.getCCSOf# but it returns an Addr#
11:50:38 <EvanR> yeah check the clock before, evaluate to WHNF, then check the clock after
11:50:43 <mniip> so it must be really tricky area
11:51:15 <EvanR> if WHNF is even interesting 
11:51:27 <Gurkenglas> Will #ifdef work in letlpaste?
11:51:30 <burp> did anyone stumble upon problems with shake ignoring changes to files (ChangeDigest, ChangeModtime etc. without effect)?
11:51:42 <danilo2> mniip: but In my cases all the funcitons are pure, so `x` is just pure
11:51:48 <mniip> danilo2, so?
11:51:57 <mniip> sum [1..1000000] is pure too
11:52:04 <EvanR> in the case of list, WHNF will measure the time to decide if the next item is the end of the list of not, but not how much time it will take to compute the contents
11:52:04 <mniip> yet it takes seconds to enter (evaluate)
11:52:46 <mniip> EvanR, yeah, you'll have to trace the items if you want that
11:52:56 <EvanR> even the items might be lazy
11:53:57 <EvanR> so in this sense haskell isnt making it hard to determine performance of particular "obvious steps" its make it hard to formulate what performance question you want to ask in the first place
11:54:02 <mniip> yeah, you have to trace the spine and if it's a cons then you add a trace to the items
11:54:34 <danilo2> mniip: ok, but will it work for something like `foo a = bar a <$> infiniteListOfNumbers; x = foo 5;` - then I use x in many places in my program and I want to collect the info of time needed of all chunks created inside the `foo` function ?
11:54:38 <EvanR> i guess the easiest is a top level question, how long does it take to produce 1 word of output
11:57:49 <myzoski> I'm trying to use stack to build a program of mine with --library-profiling --executable-profiling.  The program has some code built from C (cbits/xxhash_excerpt.c) and when 'ar' runs it complains about not being able to find xxhash_excerpt.p_o, which I guess would correspond to a profiled version of xxhash_excerpt.o.  Any idea how I can fix this?
11:58:07 <mick_> Hi, this might be a dumb question but when would I use foldr over foldl?
11:58:38 <mniip> when you want to fold right and not left?
11:58:45 <uncle-j_j> mick_: when you habe deals with infinite lists
11:59:09 <danilo2> EvanR, mniip : Thank you guys  for the discussion. It clarified a bit. I'll have to think about it a little. Thank you once again!
11:59:10 <mick_> oh right - thanks uncle-j_j
11:59:28 <mniip> danilo2, I recommend checking out how haskell code is executed at runtime
11:59:44 <danilo2> I'll do it definitely
11:59:53 <mniip> that might help understanding why profiling doesn't tell you the functions,
11:59:59 <mniip> or why there is no stacktrace
12:00:00 <Cale> @src foldr
12:00:00 <lambdabot> foldr f z []     = z
12:00:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:00:04 <Cale> @src foldl
12:00:05 <lambdabot> foldl f z []     = z
12:00:05 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:00:08 <mniip> (a conventional stacktrace, at least)
12:00:34 <Cale> If you look at the definition of foldl, it simply applies itself to new arguments until it reaches the end of the list
12:01:06 <Cale> Whereas foldr passes control to f -- only if and when f pattern matches on its second argument will the foldr continue
12:01:25 <mniip> I wonder if it's possible to write a lazier foldl
12:01:36 <mick_> thanks @Cale
12:01:37 <Cale> not really
12:02:03 <Cale> foldr also has a nicer interpretation than foldl
12:02:23 <Cale> foldr f z replaces each occurrence of (:) in the construction of the list with f, and replaces the [] at the end (if any) with z
12:02:33 <mniip> Cale, consider one that returns you an f before evaluating the spine
12:03:13 * hackagebot commander 0.1.0.0 - pattern matching against string based commands  https://hackage.haskell.org/package/commander-0.1.0.0 (jsdw)
12:03:15 <Cale> mniip: http://cale.yi.org/share/Folds.png
12:03:17 <mniip> and that f's z is an f as soon as we realize that there's at least one cons in the spine
12:03:37 <Cale> If you look at the diagram for foldl, you'll notice that the outermost f in the result of foldl f z [1,2,3,4,5] has f applied to 5
12:03:37 <mniip> Cale, none of this takes bottoms into account
12:03:55 <mniip> so?
12:04:06 <Cale> I suppose you might be able to produce f applied to something yet to be determined, that's true
12:04:14 <mniip> exactly what I'm saying
12:05:28 <monochrom> today's xkcd is a perfect answer for "how do I install Haskell?"! :)
12:05:47 <broma0> general thoughts on ExceptT's MonadError vs the exceptions' package "MonadThrow/MonadCatch"? What are the tradeoffs there?
12:06:28 <broma0> monochrom: thats awesome
12:06:47 <Cale> broma0: Which monad are you transforming?
12:08:08 <broma0> Cale: a 'ReaderT IO', but i think the question is monad-independent as long as the monad/stack doesn't already have some error handling means, no?
12:08:10 <Cale> I find that cases for really wanting an exception transformer are a little rare.
12:08:14 * hackagebot servant-elm 0.1.0.2 - Automatically derive Elm functions to query servant webservices.  https://hackage.haskell.org/package/servant-elm-0.1.0.2 (mattjbray)
12:08:16 * hackagebot Unique 0.4.5 - It provides the functionality like unix "uniq" utility  https://hackage.haskell.org/package/Unique-0.4.5 (kapral)
12:08:29 <Cale> Yeah, but IO already has error handling.
12:08:45 <Cale> of course, applying ReaderT kind of messes it up
12:09:32 <broma0> Cale: I'm getting used to the whole "one big monad transformer with functions defined in terms of mtl and classy-lens classes"
12:10:06 <broma0> Cale: and as such, looking into the differences between adding ExceptT to the stack vs deriving MonadThrow/Catch
12:10:24 <broma0> looks like MonadThrow is significantly more general
12:11:01 <mniip> wait
12:11:27 <mniip> injectivetypefamilies can't do non-bijective dependencies?
12:11:32 <Cale> Are you talking about the classes from catch-fd?
12:12:00 <EvanR> monochrom: ... no haskell nothing!
12:12:12 <broma0> Cale: no, kmett's exceptions package
12:13:55 <mniip>     • Variables ‘k, k’ occur more often
12:13:55 <mniip>         in the constraint ‘Subs n a f g’ than in the instance head
12:13:55 <mniip>       (Use UndecidableInstances to permit this)
12:14:01 <mniip> should this even happen?
12:14:01 <Cale> broma0: ah, okay
12:14:17 <mniip> (k is a kindvar)
12:14:24 <lf94> OK, someone explain Monad in 1 sentence.
12:14:49 <mniip> lf94, associative >=> operation with a left-and-right identity called return
12:14:52 <lf94> I'll give it a try: a series of things that affect each other
12:15:06 <Cale> broma0: Well, the exceptions package seems more thorough in terms of what it provides, but I'd usually expect the difference to be pretty small.
12:15:10 <Gurkenglas> monoid in the category of endofunctors
12:15:13 <broma0> lf94: a monoid in the category of endofunctors. whats the problem?
12:15:20 <broma0> lf94: :D
12:15:24 <monochrom> I don't think a 1-sentence explanation is productive
12:15:25 <broma0> Gurkenglas: you win!
12:15:34 <lf94> monochrom, just a fun exercise.
12:15:50 <monochrom> in fact, more strongly, no explanation is productive. examples and exercises, instead, are productive.
12:15:53 <lf94> also, I like to see how other people see what monad is from the "highest level" in their mind's eye.
12:16:43 <monochrom> one doesn't simply learn any programming language or its ideas by listening to 40 hours of explanations.
12:16:43 <Cale> broma0: Oh, I guess the biggest difference is that exceptions uses the Exception class explicitly, so (MonadThrow m, MonadCatch m) is similar in effect to (MonadError SomeException m)
12:16:46 <broma0> lf94: i see it as a way to sequence actions that occur in some "context" (like nondeterminism for a list, or having implicit read-only values for a reader, etc.)
12:16:58 <monochrom> a programming language is not a history course.
12:17:21 <lf94> broma0, that's a nice way to put it too.
12:17:40 <broma0> monochrom: but listening to 40 hours of explanations is, for me, the first phase of learning (well maybe not 40 hours!)
12:17:56 <broma0> monochrom: explanations can also be read or viewed, etc.
12:17:59 <Gurkenglas> There's probably some common structure that represents monads in the neurons of the people who've understood them, and it's probably possible to derive from that an explanation that actually works, but we probably don't have that explanation yet.
12:18:04 <Cale> lf94: A monad is a lax 2-functor from the terminal bicategory to Cat
12:18:19 <monochrom> you want to interleave 5-minute explanations and 5-hour exercises
12:18:35 <broma0> Cale: wow that explanation of monadthrow/catch cleared things up a bit
12:18:40 <broma0> Cale: thanks
12:19:21 <lf94> Cale: is that how you honestly see monads?
12:19:35 <Cale> lf94: Depends on what hat I'm wearing
12:19:46 <Cale> lf94: (but mostly no)
12:19:53 <Cale> It is true though.
12:20:06 <lf94> how do you see monads then
12:20:17 <lf94> when do you say 'this should be a monad'
12:20:25 <Cale> lf94: In Haskell?
12:20:29 <monochrom> I see axioms.
12:20:31 <lf94> in general
12:21:02 <lf94> (assuming monads are the conceptually the same across other FP languages)
12:21:06 <EvanR> free monad monad monad algebras
12:21:07 <Gurkenglas> lyxia, new version for the connected components of an undirected graph thing: http://lpaste.net/154492
12:21:19 <johnw> lf94: for me, if Struct (Struct a) has an obvious reduction to Struct a, and if a has an obvious inclusion into Struct a
12:21:34 <EvanR> lf94: which they kind of arent since they seem to be more like monoids from what ive seen
12:21:37 <Cale> Well, something should be a monad when it is a functor for which one can implement law-abiding natural transformations for the monad unit and multiplication
12:21:55 <Cale> (i.e. return and join)
12:22:07 <igl> Greetings, looking for some help on how to refer to a haskell syntax. Say we pattern match on some Int in a function body like this "foo n = n", where n is the Int, what would you say n was? Would you call it a binding?
12:22:19 <broma0> lf94: how about this: in a programming language like c, every line of code executes in a "scope monad" that is restricted and expanded by calling functions and defining values, etc. In haskell, non-monadic functions have no "scope monad", and monadic functions have an explicitly defined "scope monad" that allows some extra functionality (like nonderminism for a list, read-only config for a reader, etc.)
12:22:19 <lf94> Cale: cool.
12:22:54 <Cale> lf94: So in the context of Haskell, you don't usually set out to create a monad -- you can, but I think it produces sub-par results.
12:22:58 <EvanR> broma0: associating monads primarily with imperative programming is probably doing some damage
12:23:18 <Gurkenglas> igl, n is an argument? More context for a better answer maybe.
12:23:50 <Cale> lf94: You instead figure out what sort of API you want to present to the user of your library, and if that happens to involve a functor for which you can implement return and (>>=), (or return and join), then great, write a Monad instance!
12:24:17 <monochrom> (if not, write an Applicative instance instead)
12:24:29 <Gurkenglas> (if not, derive a Functor instance instead)
12:24:30 <stoopkid> hello, does anybody know of an 'implementation' of martin-lof's type theory over RDF?
12:24:36 <Cale> lf94: Generally if you have something which looks like a "type of computations that have results", then there's a likely chance you'll get a Monad instance.
12:24:55 <Cale> But yeah, if not, there are several other things you might also have
12:25:20 <Cale> stoopkid: whaaaat?
12:25:24 <monochrom> (worst comes to worst, you may still have a Foldable instance)
12:25:32 <broma0> Haskell has always seemed, to me, to be much much better for library writing than for executable writing. What do you think? It appears like there are code-architecture standards for library writing, but for executables like web servers, etc, there's no general approach 
12:25:42 <Cale> stoopkid: What does RDF stand for there?
12:25:50 <lf94> Cale: seriously, what a great way to put it. Thank you for your perspective on it.
12:25:54 <stoopkid> resource description framework
12:26:01 <igl> Gurkenglas: Thanks, well I'm doing some writing about a data type definition, and I want to make a distinction between just data constructors and things that are given some name like n. I suppose it is an argument, but you could have pattern matched on it instead and not had an "n" in scope.
12:26:13 <Cale> stoopkid: okay, I repeat my "whaaaat"
12:26:35 <hpc> broma0: actually web frameworks in haskell are a good example
12:26:48 <hpc> you write your website in the framework, and it compiles to an entire webserver executable
12:26:49 <stoopkid> like is there a sem-web language for expressing MLTT
12:26:55 <Cale> no
12:27:11 <Cale> Nor is RDF even slightly appropriate, I think
12:27:36 <Cale> (though I can't really think of many things that RDF *is* particularly appropriate for)
12:27:42 <EvanR> broma0: so "good for" means "exists some standard approach" ?
12:28:07 <EvanR> in frameworks with some standard approach, i get the feeling i end up with something "worse"
12:28:29 <EvanR> theres more than one way to do it
12:28:46 <igl> Gurkenglas, so I'm trying to find more specific definition than argument I suppose, a name that couldn't be applied to a raw data constructor
12:28:47 <broma0> EvanR: good point. to clarify - i did, in fact, mean a standard approach. BUT NOT A LIBRARY TO DO IT FOR ME
12:29:06 <broma0> EvanR: for example, i use wai and warp, but NEVER yesod or servant, etc.
12:29:16 <Gurkenglas> Something with "lazy" perhaps?
12:29:19 <EvanR> turns out IO is unpredictable and merciless, it cant be wrangled by a universal law... yet
12:29:22 <broma0> and i wonder if there is a general design pattern for doing the rest of the implementation
12:29:31 <ski> lf94 : another unintelligible (without further elaboration) version : "dynamic sequencing"
12:30:47 <igl> EvanR, IO can be modelled with dependent types rather nicely however
12:30:58 <EvanR> eh.
12:31:28 <EvanR> i can think of several examples of that and rather than rather nicely, i think about what its not able to model anymore
12:31:42 <EvanR> which is fine because thats the DSL pattern
12:31:49 <EvanR> but it falls shorts of being "IO"
12:32:03 <johnw> what is "the DSL pattern"?
12:32:23 <broma0> Anyone know of a collection of opinions on haskell best practices? beyond things like "prefix record selectors with the constructor name" and more into advanced topics like monadic programming etc.
12:32:28 <EvanR> use a domain specific language which expresses what you want better, at the expense of not being able to express something irrelevant
12:32:44 <johnw> isn't that just using a DSL?
12:32:50 <EvanR> yes?
12:33:01 <johnw> isn't that like saying that when I eat dinner, I'm employing the eating pattern?
12:33:07 <EvanR> yes
12:33:15 <hpc> johnw: try asking a java programmer if the factory pattern is just using a factory
12:33:18 <johnw> ok, I guess I just dislike the meaningless inclusion of the word "pattern" then
12:33:23 <monochrom> no, you employ the knife-and-fork pattern, or the chopstick pattern.
12:33:35 <monochrom> have you been to a fork factory? :)
12:33:48 <EvanR> apologies
12:33:49 <johnw> the pattern pattern
12:33:52 <hpc> i was once a singleton manager at a fork factory
12:34:12 <johnw> EvanR: no worries, my apologies if I'm being rude
12:34:49 <EvanR> im going to unapologetically use "the DSL pattern" at my presentation inhabited by scala people ;)
12:34:56 <EvanR> know your audience i guess
12:35:14 <bonsairoot> I get an error when I try to create a haskell project with the eclipse plugin ( http://pastebin.com/yw9JZ7Kf ). ghc and cabal are working properly. Have any of you seen something like this before?
12:35:17 <mniip> auuugh
12:35:20 <monochrom> I think DSLs vary so much that there is not much of a pattern there.
12:35:21 <mniip> the type system hates me
12:35:29 <mnoonan> EvanR: "next, let's look at the Pattern Matching Pattern.."
12:35:36 <EvanR> lol
12:35:45 <EvanR> i think they will think im making fun of them at that point
12:36:03 <mniip> how do people get all these fundepped families to play nice
12:36:50 <hpc> brute force, grad students, and a hundred million dollar research grant
12:40:18 <Darxide-> Hey #haskell, so I have a question I primarily write code in C and Go at work. I've read loads on haskell and functional languages, but I just don't get why I would want to use it
12:40:39 <johnw> what is the question?
12:40:40 <Darxide-> maybe someone can explain the real use case in where #haskell and associated languages shine?
12:40:44 <johnw> I can't answer why you'd want to use it
12:41:10 <johnw> you can be happy and successful never learning it at all :)
12:41:38 <Darxide-> johnw: I know that :p, it interests me but I don't really know how it fits and when I would want to use it over say C or GO or thing slike that
12:41:58 <johnw> i'd suggest reading some tutorials about it then, to see if it piques your interest
12:42:19 <johnw> most of us learned it because we wanted to, and not for primarily financial gain, since it's a difficult job market and a steep climb
12:42:32 <Zekka|Sigfig> Darxide-: Thinkgs to look for: Haskell is often pretty terse, and the type system makes it a little easier to write strongly-typed code around data structures
12:43:35 <monochrom> I use Haskell because it is less effort and less risk than other languages
12:43:37 <Darxide-> I guess I'm not explaining it well johnw it's not for financial gain, I'm just always looking for new tools to learn to use, but I don't really get what makes functional programming shine over other styles
12:43:44 <sm> another answer: it promotes clearer system architecture, and reduces the cost of correctness/high assurance and also of maintenance generally
12:43:57 <johnw> Darxide-: it's easier to write code that does what you intended it to do
12:44:00 <Zekka|Sigfig> I’d say the big pitch for Haskell is that it’s often pretty terse and it’s a little bit easier to write safe code in than many other languages
12:44:05 <hpc> in practice, you're able to more easily write code that would be extremely complicated or bug-prone in other languages by using different methods of expression and making the compiler constrain your code to error on invalid programs
12:44:09 <sm> you get fewer bugs per hour of programmer time
12:44:15 <johnw> Darxide-: it's harder to write code that does a lot more things than just what you intended it to do
12:44:43 <Zekka|Sigfig> (although I think people greatly overstate how much it reduces bugs)
12:45:20 <Darxide-> great answers, but whats the performence hit? I mean if I need to do some serious processing something I'd normally right in c would I take a hit writting it in haskell?
12:45:22 <Zekka|Sigfig> I mean, I wrote all my programs in Haskell for a year, all my programs in Java for a year, all my programs in Prolog for about four months — Prolog probably had the most bugs, and Java and Haskell were roughly tied
12:45:29 <EvanR> 100% of "stupid bugs" i get in ruby are caught before runtime in haskell
12:45:30 <johnw> Darxide-: one could say that it shifts software engineering costs toward the development phase, where they are cheaper
12:45:49 <xa0> how's "Cooler" doing?
12:45:54 <Zekka|Sigfig> Darxide-: In theory Haskell can perform as well as C, but it’s a hard language to benchmarks and costs are unpredictable
12:46:02 <sm> Zekka: I see a bigger difference than that, and I think a year isn't enough to see the full impact
12:46:06 <EvanR> some non stupid bugs are caught by haskell. and there are still some genuine normal bugs that get through
12:46:16 <hpc> Darxide-: if an example helps, here's something moderately complex that i wrote in an hour or two: https://github.com/headprogrammingczar/http-bench/blob/master/Main.hs
12:46:24 <Zekka|Sigfig> sm: Well, I’ve been using it for four or five years, but I only used it for everything for one year
12:46:29 <sm> and it's not hard to benchmark :)
12:46:42 <sm> ok
12:46:49 <hpc> Darxide-: it creates a thread pool of http request loops which grows and shrinks until the web server on the other side starts slowing down its responses
12:47:08 <dedgrant> One good measure for a given domain, is how far (in time and space) errors tend to manifest from their source.
12:47:10 <Darxide-> hpc: looks like R mixed with python syntacticly
12:47:12 <hpc> it's basically a denial of service tester
12:47:24 <Zekka|Sigfig> the first two years I used it I didn’t see much that was compelling about it — later I decided to give it a serious shake for about a year, and then I came away thinking “it’s easy to write code with really crazy flow control assumptions in Haskell, but otherwise this is not that valuable to me”
12:47:37 <hpc> how many amortised requests over time can your server handle at once
12:48:07 <Darxide-> I'm just thinking along the lines so I haer functional is better for data oriented software, but I have something that processesses a mass ammount of video files written in C it needs to be performant and it is, bu the data handeling is massive and a huge pain in the ass
12:48:19 <Darxide-> would I say take a huge hit using haskell over c with it?
12:48:31 <EvanR> data oriented is a good way to think about a lot of things
12:48:39 <sm> maybe it depends what you came from. I saw a big reduction in certain kinds of bug compared to large python or smalltalk codebases. If I'd been using java, maybe less so ?
12:48:39 <monochrom> I think my bug rate is also the same over Java and Haskell. however, it's only because I dare only do easy tasks in Java. 
12:49:06 <monochrom> in fact, I am too lazy to do anything sophisticated in Java.
12:49:15 <Darxide-> monochrom: don't blame you :p
12:49:21 <monochrom> and I am too lazy to learn Python
12:49:28 <EvanR> Darxide-: i would say data oriented thinking is something different from processing gigantic binary blobs
12:49:33 <sm> haskell definitely helps me think more precisely about my code
12:50:10 <Zekka|Sigfig> Has anybody done a study on bug rate by programming language? That’s obviously a fuzzy kind of question to ask, but if you articulate it a particular specific way, you’ll get a particular specific answer
12:50:13 <Darxide-> EvanR: I guess I should say the processing would probably stay in C of the binary blobs, but the data resulting from it would be easier handled elsewhere?
12:50:22 <mniip> hmm
12:50:31 <mniip> type family equations need some case-of
12:50:47 <Zekka|Sigfig> I’m a little bit suspicious that a lot of Haskell fans overstate how much it simplifies things because it was hard for them to get started with and now they’re a little invested — but I’m really only suspicious of that because I did it. I can’t speak for other people.
12:50:51 <EvanR> Darxide-: well, i have had a better time munging binary blobs in haskell. i tend to segfault in C even after a lot of C experience :(
12:51:17 <Zekka|Sigfig> Compared to C I’m pretty sure I’d always pick Haskell, of course, because you do almost everythin gmanually in C
12:51:34 <monochrom> oh, sure, I certain spent a lot of time figuring out lazy evaluation and testing my hypotheses.
12:51:43 <EvanR> i was amazed at how much my C code was screwing up in weird ways when i wrote the cocoa front end to my haskell program
12:51:48 <monochrom> but today yes lazy evaluation is easy to me
12:52:00 <Darxide-> guess I'm a massochist I kind of like to see what's going on and doing things manually :p
12:52:08 <EvanR> you can do that in haskell ;)
12:52:14 <mniip>       RHS of injective type family equation cannot be a type family:
12:52:16 <mniip> oh screw you
12:52:34 <Darxide-> I want to learn it I really think a functional language would do well under my belt
12:52:48 <EvanR> Darxide-: it gets kind of boring to inspect a union tag in a struct over and over though... Just 9 is like, wow i dont have to
12:52:49 <johnw> Darxide-: enjoy the ride :)
12:52:54 <Zekka|Sigfig> Haskell really isn’t low-level comparably to C, particularly if you compare it to C-as-it-is-actually used
12:52:56 <Darxide-> I have people at work who swear by scala, but haskell appeals to me because it's supposed to be more "pure" I guess
12:53:05 <Darxide-> and I hate JVM :p
12:53:21 <Ralith> Darxide-: doing high performance data processing like video encoding competitively in Haskell is going to be difficult but not impossible
12:53:27 <Ralith> you may need to learn quite a lot, however
12:53:53 <Darxide-> Ralith: not going to do it for this project, but was just my baseline thought since I was just working on it today
12:53:56 <EvanR> if youre already used to doing this stuff in C then youre in a good shape to optimize stuff in haskell
12:53:58 <Zekka|Sigfig> barring crazy stuff I haven’t personally seen done, you can’t really see the stack or impose your own calling convention on Haskell code
12:54:07 <Darxide-> thanks for all the answers guys it's all very informative
12:54:08 <sasooooss> ciao a tutti!
12:54:11 <sasooooss> !list
12:54:34 <EvanR> Zekka|Sigfig: well, how do you do that in C?
12:54:42 <Zekka|Sigfig> There are enough unsafe* operations to do a whole lot of the evil things you would expect to be able to do in haskell
12:54:44 <monochrom> in fact I think my bug rates over all languages are pretty much the same. sure C is a bit higher but only a bit. but here is the real reason, it's all about me and not about languages: I simply forbid myself from high bug rates.
12:54:50 <Zekka|Sigfig> EvanR: Compiler extensions!
12:54:55 <EvanR> oh geez
12:55:05 <sasooooss> ciao a tutti!
12:55:06 <Zekka|Sigfig> I guess disclaimer, most of the C I have written lately has been talking to assembly language code
12:55:09 <sasooooss> !list
12:55:14 <Zekka|Sigfig> that is probably not representative of how people who want to write applications in C use C
12:55:22 <sasooooss> ciao a tutti!
12:55:24 <sasooooss> !list
12:55:32 --- mode: ChanServ set +o johnw
12:55:34 <EvanR> heh, Haskell vs C for doing assembly level stuff
12:55:35 <Zekka|Sigfig> I was going to bring up “you can’t tell Haskell the memory layout of your globals” but you can only do that in C by means of evil
12:55:36 <monochrom> the enlightening point though is when you look at how much time I need to achieve my target low bug rate. it takes me forever for C, 1 day for Java, and 1 hour for Haskell.
12:56:09 <EvanR> Zekka|Sigfig: i really want to mess with avr using haskell
12:56:27 <Zekka|Sigfig> EvanR: AVR? I have a feeling you’re using an acronym I don’t know to refer to something I do know about
12:56:34 <bitemyapp> monochrom: may I quote you?
12:56:39 <EvanR> er, avr instruction set
12:56:54 <monochrom> yes
12:57:12 <bitemyapp> monochrom: thank you :)
12:57:20 <Zekka|Sigfig> FWIW even though I hate on Haskell occasionally I’ll concede that I usually get small programs done faster in Haskell than in other languages, and they work about as well
12:57:25 --- mode: johnw set -o johnw
12:57:44 <jrajav> I think someone asked this earlier today and I can't quite track down if there were any answers -- Are there any good IDEs (or IDE-esque plugins, etc.) for Haskell to do things like showing the type signatures of expressions on hover/key shortcut, autocompletion, etc?
12:57:49 <monochrom> I'm pretty sure my numbers contain exaggerations and gross inaccuracy. but I've already said it in public. no way to chicken out now. :)
12:58:02 <johnw> jrajav: I think ghc-mod can do that in Emacs and vi
12:58:03 <Zekka|Sigfig> I can’t authoritatively say this for large programs because I haven’t written the same large programs in Haskell as in other languages
12:58:12 <jrajav> johnw: Are those the only options?
12:58:14 <jrajav> I dislike both
12:58:19 <johnw> i'm just mentioning what I know
12:58:23 <jrajav> Okay, thanks!
12:58:30 <Zekka|Sigfig> the largest program I’ve written in multiple languages was an inference system I ported to C, Haskell, Javascript, and Java, and the Haskell version was by far the fastest to write
12:58:37 <hpc> eclipse has a functional programming plugin that may or may not suck horribly
12:59:06 <jrajav> Looks like ghc-mod might have a Sublime frontend as well, nice
12:59:14 <monochrom> it is very out of date.
12:59:20 <Darxide-> vim or gtfo :p
12:59:20 <Zekka|Sigfig> (however I had to throw out parts of the indexing system because they relied on evil to actually function — later I proved they were thread-unsafe)
13:00:35 <jrajav> I never made the plunge Darxide-, and I'm comfortable and adept with Sublime
13:00:43 <jrajav> I know, I know, I'm a failure as a coder
13:01:04 <Darxide-> jrajav: I love sublime, I have vim days and days when I can't be fucked
13:01:22 <Darxide-> vim is miserable to learn but after a month its wonderful to use
13:01:33 <jrajav> I know the "first level" of basic vim commands, enough to get around log files on a server
13:01:33 <EvanR> for C code yeah
13:01:41 <EvanR> for clojure code.....
13:01:43 <prooftechnique> Evil is my <leader>
13:01:56 * EvanR releases the dogs of editor wars 
13:02:02 <Darxide-> EvanR: I wouldn't use vim for anything JVM oriented just not good support
13:02:21 <EvanR> yeah i guess i shoulda switched to emacs at that point
13:02:36 <prooftechnique> Setting up CEDET seems like a nightmare
13:02:51 <prooftechnique> I think I tried once, but I was young and foolish
13:03:00 <Darxide-> I've never tried emacs
13:04:09 <monochrom> I write Haskell by going to Thunderbird and hitting the "Reply" or "Write" key.
13:04:09 <Darxide-> and oddly enough for some reason you mentioning emacs just reminded me of pico completely forgot about it until then
13:04:21 <Darxide-> amazing what after work beer and irc does to the brain
13:04:29 <prooftechnique> ed is the one true editor
13:05:05 * prooftechnique ducks
13:05:08 <sm> ooh wait for me!
13:05:20 <dolio> Can you guys take your editor memes to some other channel?
13:05:22 <sm> jrajav: Atom's haskell support can work pretty well
13:05:24 <monochrom> I prefer nano to pic. nano is more configurable.
13:05:32 <monochrom> sorry
13:05:44 <sm> jrajav: see today's #haskell-beginners log for some tips
13:06:00 <Darxide-> does pico stil exist? I haven't touched it since probably 2002
13:06:10 <Darxide-> just popped into my head
13:06:24 <prooftechnique> Yes
13:06:31 <orion> vim?
13:06:44 <mniip> what's the best way to implement an implication-like typeclass structure
13:07:25 <mniip> I have constraints A and B, and B x is only possible if A x, and if B x is implemented, then A x has only one right implementation (depending on B x)
13:07:50 <heedful> Can someone help me with exercise 1.19 in SICP? I am seriously about to quit reading this book, because my mathematical rigor is extremely lacking and it has so far done nothing more than make me want to off myself for being so retarded.
13:08:07 <prooftechnique> What's the exercise?
13:08:13 <mniip> should I do similar to how Applicative => Monad, and <*> = ap?
13:08:19 <mniip> or is there a better way
13:08:32 <prooftechnique> mniip: Default definitions seem like the way to go
13:08:54 <mniip> prooftechnique, hmm, well actually I have a diamond like structure
13:09:28 <mniip> so A can actually have 2 equally valid default implementations
13:10:26 <jrajav> sm: I'd rather get Sublime working if I can. Performance is a factor for me
13:10:29 * prooftechnique nopes right out of the diamond problem
13:10:30 <prooftechnique> :D
13:10:34 <jrajav> sm: Thanks for the tip though, and the new channel
13:10:44 <mniip> so like, A->B A->B' B->C B'->C
13:10:55 <sm> np
13:11:12 <johnw> heedful: thanks for that description, you made me laugh
13:11:29 <heedful> prooftechnique: https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_thm_1.19
13:15:09 <nitrix> Is there such thing as flipped mapM_ ?
13:15:27 <dolio> forM_
13:15:27 <bergmark> forM_
13:15:35 <nitrix> Amazing, thanks.
13:21:11 <bonsairoot> bonsai
13:21:51 <mniip> guys I did it
13:22:56 <lpaste> mniip pasted “generalized functors” at http://lpaste.net/154525
13:23:47 <EvanR> "zonked" "rejigged" wtf are the ghc people on
13:24:38 <mniip> I wonder if lambdabot...
13:24:49 <mniip> @letlpaste 154525
13:24:51 <lambdabot>  .L.hs:305:9:
13:24:51 <lambdabot>      Family instance purports to bind type variable ‘k1’
13:24:51 <lambdabot>        but the real LHS (expanding synonyms) is:
13:24:57 <mniip> ah right
13:25:05 <mniip> it only works on GHC HEAD, I forgot
13:26:21 <EvanR> what is zonking?
13:28:07 <tzh> remember to always zonk your skolems
13:28:47 <tzh> http://stackoverflow.com/questions/31889048/what-does-the-ghc-source-mean-by-zonk
13:30:42 <EvanR> got it
13:31:03 <EvanR> zonked you might say
13:35:24 <dolio> You don't zonk skolems.
13:35:27 <sindriava> I'm on OSX, looking to develop a GTK app. What library should I use?
13:35:31 <dolio> You zonk unification variables.
13:37:01 <dolio> I mean, you can zonk skolems, but it doesn't do anything.
13:42:57 <hpc> try writing "zonk skolems" in any other channel
13:47:52 <ott> Is MIN_VERSION_foo the only macro available for that purpose? Or is there a macro for checking ranges/exact equality?
13:48:57 <EvanR> sindriava: gtk2hs ?
13:53:44 <sindriava> EvanR: Why? Why not some other gtk library? And why not Gtk3?
13:53:58 <EvanR> ive only heard of people using gtk2hs
13:54:03 <sindriava> EvanR: To be clear, I'm not trying to disprove you, I'm genuinely asking, since there seem to be multiple
13:54:04 <sindriava> I see
13:54:28 <EvanR> this was years ago though, notably the Manatee "Environment"
13:54:48 <sindriava> @hackage gtk2hs
13:54:48 <lambdabot> http://hackage.haskell.org/package/gtk2hs
13:54:48 <EvanR> which kind of blew me away
14:00:53 <literal_boar> What's the idiomatic way to handle map lookups when I know at compile time that every key I search for will be in the map? I've been using `let (Just x) = Map.lookup ... <do stuff with x>` instead of `Map.lookup ... >>= <do stuff with value, maybe>`. 
14:01:35 <EvanR> heh, how do you know?
14:02:02 <monochrom> you can add a fromJust.
14:03:16 <literal_boar> I'm using it as part of an algorithm, EvanR. If a key isn't in fact in the map, I messed up somewhere. Thanks monochrom -- that's definitely cleaner. 
14:03:18 * hackagebot iridium 0.1.5.2 - Automated Testing and Package Uploading  https://hackage.haskell.org/package/iridium-0.1.5.2 (lspitzner)
14:04:00 <EvanR> right, i was just thinking that i would expect my program to crash sometimes because i expect to mess up
14:04:12 <EvanR> its like a personal law
14:04:21 <Zekka|Sigfig> It sounds kind of like he’s certainly messed up, bu the right thing to happen would be a crash
14:04:24 <Zekka|Sigfig> er, that is, if his match fails
14:04:25 <EvanR> > fromJust Nothing
14:04:27 <lambdabot>  *Exception: Maybe.fromJust: Nothing
14:04:33 <EvanR> best error message ever
14:04:33 <Zekka|Sigfig> so it’s not like he would be better served by trying to handle it somehow
14:04:44 <sindriava> EvanR: Welcome to Haskell :D
14:04:52 <EvanR> yes
14:05:10 <sindriava> Zekka++, m a -> a is almost never safe
14:05:19 <EvanR> there gotta be a better way to "serve" than that
14:05:29 <monochrom> you can write your own fromJust that gives your own error message
14:05:46 <Zekka|Sigfig> monochrom: That is highly valid!
14:05:51 <literal_boar> (additional context: It's for a toy compiler. I'm renaming variables to unique IDs to prevent shadowing, and I do this after type checking. So a lookup would only fail if the type checker didn't catch that a variable was never declared.) 
14:05:52 <EvanR> literal_boar: theres a package called safe which has a bunch of these kinds of functions but with the ability to add an extra error message to help with figuring out what went wrong
14:05:56 <sindriava> EvanR: There's nothing better to do than crash. That's what fromJust is for. I do agree that the message could be a bit better though.
14:06:01 <EvanR> right
14:06:25 <monochrom> you can also go out of your way to define a dependent type that lists the keys, at the type level, of your map
14:06:27 <EvanR> sindriava: even with no error message, you can figure out issues in other languages because of the stack backtrace
14:06:51 <sindriava> EvanR: I count backtrace as a "better error message"
14:06:57 <EvanR> heh
14:07:51 <sindriava> tbh I'm not sure why fromJust exists, it seems rather pointless
14:08:15 <sindriava> > let Just a = Nothing
14:08:17 <lambdabot>  <no location info>: not an expression: ‘let Just a = Nothing’
14:08:19 <Zekka|Sigfig> Well, if you’re composing a bunch of crap and you have a “this hsould never happen” case in the middle, you might as well have a builtin to put in the middle
14:08:34 <EvanR> if it really cant happen, then it works great
14:08:40 <sindriava> Zekka|Sigfig: Fair enough, I forgot about composition
14:08:46 <monochrom> it is similar to head and tail which came from Haskell inventors who came from Lisp.
14:08:48 <Zekka|Sigfig> Yeah, that’s usually where I use it
14:09:01 <sindriava> Zekka|Sigfig: I was thinking "Why not explicitly pattern match", but composition is a good point
14:09:36 <sindriava> > let Just a = Nothing in a
14:09:38 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Just a
14:09:52 <sindriava> That's kinda better I guess
14:10:06 <EvanR> in some cases where "it cant happen" but realistically you cant control whats going on, and it "should never happen", AND crashing would be really bad....
14:10:20 <EvanR> you can provide a default value to use in case of Nothing
14:10:26 <sindriava> I hear that Elm has amazing error messages
14:10:37 <EvanR> however.... you will never know that it happened
14:11:00 <EvanR> maybe an unsafePerformIO to log the "impossible has happened" would be prudent
14:11:16 <sindriava> EvanR: There are legitimate cases where you know it can't happen, though
14:11:21 <EvanR> yes
14:11:52 <EvanR> im thinking of a medical record processor where both sides have agreed that stuff cant happen, and only the engineers know the truth, that it simply "probably" wont happen
14:11:59 <EvanR> things mostly work nicely, until they dont
14:12:16 <EvanR> but you dont want to completely abort any procedure
14:12:26 <sindriava> Hah
14:12:39 <monochrom> there are also cases when crashing is more reliable than continuing with a log message that no one reads in time
14:13:15 <EvanR> yeah and then client X has just ruined the show for every other client because the server is down
14:13:22 <monochrom> I know because I keep forgetting to read my "spam" email folder. meaning if a legit email is wrongly classified as spam, I wouldn't know for 2 months.
14:13:38 <c_wraith> in erlang, crashing and logging a message no one will ever read are basically the same. 
14:13:52 <monochrom> so guess how often I read a log file if a program doesn't crash
14:14:03 <EvanR> well if it does crash why do you know ;)
14:14:12 <EvanR> email in the spam?
14:14:45 <EvanR> phone call
14:15:28 <monochrom> I'm pretty sure the world's software landscape is not completely exclusively "a server that must stay up"
14:16:01 <EvanR> no but thats a practical application
14:16:16 <monochrom> why do people think that every computer program must be either a web server or a web app?
14:16:24 <EvanR> i dont know
14:16:49 <EvanR> my example was a non-web medical record processor
14:17:05 <EvanR> which are like web servers before the web
14:17:28 <EvanR> only someone tells you its more important than the web
14:17:32 <sindriava> What the hell is the point of stack
14:17:40 <sindriava> if I download a library, and it fails to biuld
14:17:42 <sindriava> build
14:23:51 <cmotoche> Hey guys, I was using cassava for parsing a Csv file, but I get an error when I try to read a special character like: "é" that is a Spanish letter. Do you know what could I do? I thought about converting the ByteString that I try to parse to Text, and convert it to ByteString again. But, I'm not sure if that is a good way to solve this problem.
14:26:11 <pavonia> cmotoche: Is your bytestring encoded properly? I think cassava needs an UTF-8 encoded input
14:35:09 <cmotoche> pavonia, you were right, my file was encoded with ISO-8859-1, I used iconv to change the codification. Thanks.
14:35:27 <pavonia> No problem
14:35:45 <EvanR> cassava completely aborts if anything has invalid utf8?
14:41:05 <Zemyla> So if you have a witness forall f. f a -> f b, how do you transform it to the opposite, forall f. f b -> f a?
14:41:08 <Gurkenglas> Is there a way to write "MonadPlus f => Cofree f a -> f a" without explicit recursion?
14:49:22 <stealth-> Does anyone know how I can simply this to not use a lambda?
14:49:26 <stealth-> map (\x -> u x ++ d x ++ l x ++ r x ++ tl x ++ tr x ++ bl x ++ br x) arr
14:50:37 <Gurkenglas> concatMap ($ arr) [u,d,l,r,tl,tr,bl,br]
14:51:33 <pavonia> @pl map (\x -> u x ++ d x ++ l x ++ r x ++ tl x ++ tr x ++ bl x ++ br x) arr
14:51:33 <lambdabot> map (liftM2 (++) u (liftM2 (++) d (liftM2 (++) l (liftM2 (++) r (liftM2 (++) tl (liftM2 (++) tr (liftM2 (++) bl br))))))) arr
14:52:16 <Gurkenglas> If they're all just names used once and defined in a let/where next to that expression, I would make the list multi-line and inline all those names.
14:53:34 <jomg> shouldn't it be map (flip concatMap [u,d,l,r,tl,tr,bl,br] . flip id)?
14:55:22 <Gurkenglas> He didn't say to make it pointfree. flip concatMap is (>>=), if you must go that way. I'd have flip id stay ($), ($) is closer to the type we want to be using - but there's an argument to be made similar to always using fmap instead of liftA, even when we know we're working on an applicative
14:55:43 <Gurkenglas> *stay flip ($)
14:55:56 <jomg> yea, i just meant that the types in your version don't seem to match up
14:56:11 <Gurkenglas> Where's the map at the start come from btw?
14:56:36 <jomg> because we're applying this lambda to the elements of arr, not to arr itself
14:57:00 <Gurkenglas> no arr is supposed to be plugged right into the function u, d, etc
14:57:20 <stealth-> Gurkenglas: u, d, l, r, tl, tr, bl, and br are functions. I like pointfree syntax but if there's something cleaner I can use a let where
14:57:56 <Gurkenglas> waaaaaaait I'm stupid you're right jomg :D
14:58:22 <jomg> good, you had me confused there for a moment :P
14:58:22 <stealth-> So I want something like `map (flip concatMap [u,d,l,r,tl,tr,bl,br] . flip id)`?
14:58:48 <icicled> Hi, I've got a monad transformer stack like: `ReaderT AppConfig (ExceptT AppError IO) a` and so far my stack has 3 logically separate but interconnected pieces of functionality - I was wondering how folks deal with type of situation?  Do you create a MT stack for each of the pieces, let it all be in one stack, or any other way of managing complexity?
14:58:55 <jomg> stealth-, "wan't" is a different matter entirely, but that's certainly what you asked for ;)
14:59:13 <jomg> *want
14:59:26 <c_wraith> stealth-, flip concatMap x is the same as (x >>=) 
15:00:03 <stealth-> OK, I'll play around with that. Thanks guys!
15:00:16 <jomg> you're welcome :)
15:01:00 <Gurkenglas> :t map $ concat . sequenceA ?fs -- Ah I like this one
15:01:01 <lambdabot> (Traversable t, ?fs::t (a -> [a1])) => [a] -> [[a1]]
15:04:36 <icicled> a bit more context: my app/stack so far does several things - 1) listen for notifications over the network, 2) execute sql queries, 3) send emails, 4) invoke http requests
15:05:22 <benzrf> icicled: i think it would depend on how independent they are
15:05:24 <icicled> it seems a bit odd to me to allow the sql queries code to have access to the email config
15:05:34 <icicled> ^ for example
15:05:38 <Gurkenglas> icicled, you can use mtl's classes to hide the complexity of the stack from the functions that don't use it
15:05:55 <benzrf> icicled: if it would make sense to factor out and reuse one of the pieces by itself, give it its own type imo
15:06:20 <benzrf> but if the dependency graph between them is super tangled, it's probably more trouble than it's worth
15:06:24 <benzrf> (to give them separate types)
15:06:39 <Gurkenglas> "MonadReader AppConfig m => m a" will work with your stack, but would also work with one that didn't have ExceptT.
15:07:25 <icicled> the dependency looks something like: listenForNotifications >>= execQuery >>= (sendEmail or httpRequest) >>= execQuery
15:07:35 <Gurkenglas> (And so it can't use anything that would only work with access to ExceptT)
15:07:38 <icicled> not binds obviously but flow of data
15:10:40 <icicled> Gurkenglas: thanks, that will help me to refactor the pure parts of my code out
15:11:32 <icicled> any docs, blog posts, example code on dealing with this or related issues?
15:13:20 * hackagebot chorale 0.1.0 - A module containing basic functions that the prelude does not offer  https://hackage.haskell.org/package/chorale-0.1.0 (fb)
15:17:27 <noob> So I don't have $60 to spend on the Learn Haskell book by Chris and Julie. Any ideas instead? I've downloaded the CIS 194 Spring '13 course and will try that
15:19:08 <Eduard_Munteanu> noob, how about LYAH? (no strong opinions on that either way)
15:19:13 <Eduard_Munteanu> @where lyah
15:19:14 <lambdabot> http://www.learnyouahaskell.com/
15:19:38 <icicled> the two books aren't comparable
15:19:50 <dmj`> noob: the typeclassopedia
15:20:05 <dmj`> noob: real world haskell + pacpih
15:20:13 <dmj`> noob: cis 914 w/ byorgey
15:20:17 <dmj`> 194*
15:20:45 <dmj`> noob: stuart kurtz's lectures at uchicago
15:20:47 <dmj`> noob: http://cmsc-16100.cs.uchicago.edu/2015/lectures.php
15:20:52 <pavonia> What is pacpih?
15:21:04 <dmj`> parallel and concurrent pro...
15:22:02 <icicled> have a look @ https://github.com/bfpg/cis194-yorgey-lectures
15:22:31 <orion> Are there any good intermediate books?
15:22:52 <dmj`> pacpih probably
15:22:54 <icicled> ^ where someone covers each lecture in a video
15:23:03 <icicled> best to do the lecture first & then the video
15:23:43 <noob> I'll have a look at those and see what I can find at the library. Thanks!
15:24:24 <Gurkenglas> "Alternative f => Monoid (Alt * f a)" what's the * mean?
15:25:51 <Iceland_jack> Gurkenglas: It's an explicit kind
15:29:58 <pavonia> Iceland_jack: An explicit kind for what?
15:30:41 <pavonia> Alt f a :: *?
15:31:31 <Iceland_jack> pavonia: 'Alt' has kind
15:31:31 <Iceland_jack>     Alt :: (k -> Type) -> (k -> Type)
15:32:03 <Iceland_jack> so 'Alt *' is 
15:32:03 <Iceland_jack>     Alt * :: (Type -> Type) -> (Type -> Type)
15:32:24 <Iceland_jack> ghci> :set -fprint-explicit-foralls 
15:32:24 <Iceland_jack> ghci> :kind Alt
15:32:24 <Iceland_jack> Alt :: forall {k1}. (k1 -> *) -> k1 -> *
15:33:10 <Lokathor> what are some commonly used and useful packages that take a slightly bigger amount of ram to compile?
15:33:23 <Eduard_Munteanu> IIRC, you never really pass * to Alt, it's just how GHC prints it out.
15:33:24 <noob> Pardon my ignorance, but should I learn Python or Haskell first? I've done a little bit of Codecademy stuff for JS and Python, but that's about it for my prior experience. Thank you.
15:33:37 <Lokathor> noob, Haskell will serve you well
15:33:52 <Lokathor> but Python might be used more in your field, if you're some sort of science person for example
15:34:22 <Iceland_jack> Eduard_Munteanu is right
15:35:07 <monochrom> Lokathor: I think "text" takes a while and quite some memory to compile
15:35:28 <sm> also haskell-src-exts ?
15:35:52 <sm> and lens, but that's many packages
15:36:02 <Lokathor> monochrom, yes, in fact it takes over a gig of RAM
15:36:12 <EvanR> noob: haskell obv
15:36:45 <icicled> Gurkenglas: have you seen this before? https://github.com/gwils/next-level-mtl-with-classy-optics/blob/master/Slides.pdf
15:37:16 <ReinH> Lokathor: lens
15:37:23 <icicled> attempts to comparmentalize the stack via mtl typeclasses like you've mentioned
15:37:51 <icicled> but also w/a custom typeclass introduced by the lens library
15:38:16 <noob> Lol, obv Haskell okay. I'll stick with that I guess. Leaning towards Haskell then Rust, might just ignore Python for now. Thanks
15:42:27 <Gurkenglas> Haven't seen that, but have heard of the ideas except for the thing at the very end about replacing MonadReader R m with (MonadReader r m, HasDBConfig r)
15:43:06 <orion> I'm getting a very strange error with stack: "Compiler version mismatched, found ghc-7.10.3 (x86_64), but expected minor version match with ghc-3.10.7 (x86_64)"
15:43:16 <sm> lol
15:43:20 * sm high-fives orion 
15:44:18 <c_wraith> orion, looks like someone accidentally reversed the version segment list before comparison. 
15:44:33 <c_wraith> orion, which is an amazing bug to get released. 
15:45:40 <orion> Oh, and then there's this error: "The following package identifiers were not found in your indices: aeson-1.0.9.0"
15:47:23 <mgsloan> orion: Yeah someone else got that today too https://github.com/commercialhaskell/stack/issues/1903
15:47:53 <ski> Zemyla : hint or solution (sketch) ?
15:48:04 <mgsloan> orion: I have no idea how it's possible
15:48:06 <Zemyla> Nah, I think I've figured it out.
15:48:15 <mgsloan> As you'd think that lots of people would have hit it before now
15:48:37 <Zemyla> You need newtype Flip f a b = Flip { unflip :: f b -> f a }.
15:49:05 <ski> yes, to convert `forall f. f a -> f b' to `forall g. g b -> g a', set `f x = g x -> g a'
15:50:45 <ski> (is what i was going to say)
15:52:18 <mgsloan> orion: Yeah, I cannot reproduce the issue with 1.0.4.2 .  I built it with lts-5.5, though, trying again with lts-5.0 which is what 1.0.4.2 is built with by default
15:52:29 <mgsloan> orion: Did you use cabal install to install stack?
15:52:42 <orion> Yes.
15:52:45 <mgsloan> It may have picked some dependency versions that have issues.  We might need to tighten bounds
15:52:52 <mgsloan> I recommend using a stack tarball
15:53:10 <mgsloan> that's been compiled with stack, and therefore uses a fixed set of dependencies, so you'll be consistent with other people's installations
15:54:04 <orion> I'm on FreeBSD.
15:55:07 <mgsloan> Can you please run "cabal freeze" in your stack dir and paste the outputted cabal.configf?
15:55:19 <mgsloan> (to a pastebin)
15:58:29 <orion> http://lpaste.net/8952023596595675136
15:58:59 <mgsloan> thanks
16:03:09 <Ralith> Ongy: you around?
16:17:01 <EvanR> is there a way to ask the OS for a port number that is available for listening
16:20:00 <icicled> I haven't seen such a thing - best is to just try a random one and see if it works
16:20:10 <EvanR> ah ha! bind to port 0
16:20:20 <EvanR> now to figure out what the port ended up being
16:27:55 <mgsloan> EvanR: I dunno what lib you're using, but with streaming-commons / conduit-extra, you can use setAfterBind to do that
16:28:08 <EvanR> i was going to use network
16:28:10 <mgsloan> Dunno how to do it with other libs
16:28:20 <EvanR> getSocketName, im about to try
16:47:52 <mgsloan> orion: I cannot reproduce the issue even with the frozen dependencies :/
16:48:09 <mgsloan> (putting cabal.config in the dir and using "cabal install" after initing a sandbox is sufficient right?)
16:48:22 <mgsloan> I never was too good at cabal sandboxes, always just used hsenv in the pre stack days
16:48:50 <toph> so algebraic effects are a strict subclass of general monadic 'computaitonal effects'?
16:54:52 <arthur_RRS> Good Night
16:55:34 <arthur_RRS> I don't speak English.
16:55:40 <Iceland_jack> Good night arthur_RRS 
16:56:51 <arthur_RRS> I want to learn haskell, functional programming but does not enter my head. I've read SICP. I want a Council
16:57:45 <toph> try a haskell tutorial?
16:57:51 <arthur_RRS> Yes.
16:58:06 <obadz> arthur_RRS: http://pasteboard.co/2clcxuR7.png
16:59:56 <obadz> arthur_RRS: http://learnyouahaskell.com/chapters
17:01:47 <arthur_RRS> The problem is that I can not think functionally
17:02:08 <ott> Does cabal configure not work well with sandboxes?
17:02:27 <arthur_RRS> Always comes variables and states in my head. I can think of a program without variables.
17:02:38 <ott> i.e. it complains about missing packages that are in the sandbox
17:02:42 <obadz> arthur_RRS: it takes a little bit of training and practice
17:04:42 <arthur_RRS> You went through my same difficulty?
17:06:18 <obadz> different people have different backgrounds and will need varying level of efforts to get there. I don't think there's anyone that cannot get there with enough effort…
17:07:54 <arthur_RRS> Thank you guys are cool.
17:08:44 <orion> mgsloan: My library builds with cabal in a sandbox, yes.
17:09:27 <xa0> (f a -> f b) -> a -> b
17:09:31 <xa0> is this possible
17:09:49 <c_wraith> xa0, not for all f
17:10:07 <c_wraith> xa0, it's easy for f = Identity, though! 
17:10:14 <xa0> heh
17:11:02 <obadz> ∀ (Applicative f, Comonad f) ⇒ f
17:11:08 <c_wraith> I mean, if f = Proxy, there's nothing to recover. 
17:11:22 <EvanR> arthur_RRS: have you ever use unix pipes, echo "foo" | sort | uniq | cat, this sort of thing?
17:11:38 <EvanR> its a program with no variables
17:11:59 <xa0> so for all applicative comonads f, it works
17:12:13 <xa0> or it's feasible, rather
17:12:24 <toph> latest ghc wants cabal 1.25-1.26...but the latest release i can find from 9 days ago is 1.22.8
17:12:37 <ski> xa0 : hm, i remember this being discussed here, some years ago ..
17:13:09 <xa0> before my time :p
17:13:10 <c_wraith> xa0, I'm not sure there are many inhabitants of that pair of classes other than Identity 
17:13:13 <obadz> :t \f -> Control.Comonad.extract . f . pure -- xa0
17:13:15 <lambdabot> (Applicative f, Control.Comonad.Comonad w) => (f a -> w c) -> a -> c
17:13:35 <xa0> ah
17:13:37 <ski> c_wraith : `Stream' ?
17:13:44 <xa0> interesting
17:14:49 <ski> xa0 : iirc, we decided that `forall f. xa0 f . fmap f = id' was a reasonable law for it
17:14:53 <c_wraith> ski, hmm. yes, though the amount of it you end up using in that implementation is the same amount of information as Identity holds. the rest is thrown out. 
17:15:37 <ski> arthur_RRS : "I can not think functionally". you need to practice
17:16:53 <ski> xa0 : iirc, the person bringing it up wanted `Maybe' as an instance
17:16:59 <arthur_RRS> Thank sky . I will follow his advice 
17:17:28 <xa0> ah yeah i'm not looking to use any particular instance, i'm just mulling over the concept
17:19:22 <c_wraith> ski, Maybe doesn't seem like it works because of const Nothing. 
17:20:54 <ski> (hrm, on second thought, that suggested law is nonsense. i suppose i was thinking of `xa0 id . fmap id = id'. my memory of this is hazy)
17:21:29 <ski> c_wraith : istr the OP was fine with it failing in that case
17:22:38 <c_wraith> aaagh. that makes me want to go into hiding to do battle with the rust borrow checker. 
17:22:57 <Gurkenglas> Wouldn't it be applicative coapplicatives?
17:23:28 <c_wraith> it only needs pointed and copointed, if those are presumed to exist. 
17:25:04 <Eduard_Munteanu> I think there are no coapplicatives in Hask.
17:25:05 <Gurkenglas> Pointed f has a -> f a? That doesn't sound right
17:25:13 <c_wraith> it's just that pure and extract are much more commonly accepted operations. 
17:25:30 <c_wraith> Gurkenglas, that is correct. 
17:35:57 <Gurkenglas> ski, fmap id is id already, so that doesn't make sense. The first one also doesn't since you'd say it as "xa0 . fmap == id"
17:36:46 <Gurkenglas> But why not just give it the functor laws?
17:43:27 <ski> Gurkenglas : i was attempting to recall the laws we were talking about at the time, but apparently that failed
17:44:04 <Gurkenglas> ski, remember the exact phrasing of anything said back then, or who participated in the discussion?
17:46:50 <ski> closer to the former (but perhaps not the exact phrasing, as opposed to the essence of it)
17:51:36 <geekosaur> hm. the discussion of Pointed laws that I recall concluded that the only useful law was just the free theorem on it
17:51:40 <Gurkenglas> I'm guessing you aren't talking about when you sent copumpkin to #haskell-blah with his new gf 6 years ago :P
17:53:01 <geekosaur> although I thought someone (edwardk?) later came up with something, but no actual discussion
17:55:29 * ski has no idea what Gurkenglas is talking about
17:55:50 <ski> (perhaps my memory is short ?)
17:57:28 <Gurkenglas> 6 years is fine :P http://ircbrowse.net/browse/haskell?id=9479193&timestamp=1271482576#t1271482576 it's just what http://ircbrowse.net/browse/haskell?q=closer+to+the+former spit out
17:58:55 <EvanR> "supercombinator? i hardly know her!"
18:00:15 <EvanR> when its dead i here, i have a new something else to do now, read the logs from 6 years ago
18:03:23 <edwardk> geekosaur: the only law for it remains the free theorem
18:08:59 <ski> @tell Gurkenglas the closest i can find atm is <http://ircbrowse.net/browse/haskell?id=13189655&timestamp=1332289447#t1332289447>
18:09:00 <lambdabot> Consider it noted.
18:13:36 <lingxiao> hey al
18:13:53 <lingxiao> does anyone know of any resources for building chat servers beside this chapter:
18:13:55 <lingxiao> http://chimera.labs.oreilly.com/books/1230000000929/ch12.html
18:14:59 <EvanR> https://hackage.haskell.org/package/network-2.6.2.1/docs/Network.html https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html
18:17:11 <lingxiao> thanks EvanR! are there any specific implementations on github or else wehre i could study?
18:17:43 <EvanR> https://wiki.haskell.org/Implement_a_chat_server
18:17:49 <verement> lingxiao: https://github.com/verement/etamoo
18:18:25 <EvanR> holy... that is awesome verement 
18:18:25 <lingxiao> thanks!
18:19:38 <lingxiao> yeah holy is right .. that project is huge
18:19:43 <lingxiao> anyone that's a bit smaller :D
18:19:50 <verement> sorry :-)
18:19:57 <lingxiao> haha no it's ok ambitious is good
18:20:16 <verement> if you're interested in anything particular aspect I can probably point you
18:20:20 <EvanR> before implementing a chat server try implementing a server
18:20:40 <EvanR> listenOn, then forkIO accept spawn a worker thread for each connection
18:21:01 <EvanR> then you will see where and how to add bits for them to communicate with each other
18:21:19 <EvanR> you will probably want to experiment with MVar communication between threads
18:22:00 <lingxiao_> ok will do that
18:44:39 <haskell816> hey guys, didn't do haskell for quite a while and forgot the basics..
18:45:02 <haskell816> when you do the list comprehension, how do you switch the sign of a number every second number?
18:45:14 <haskell816> like getting [1, -3, 5, -7], etc.
18:45:52 <toph> does anyone else get build errors when installing the `free` package?
18:46:16 <Hafydd> > zipWith (*) [1,3..] (cycle [1, -1])
18:46:18 <lambdabot>  [1,-3,5,-7,9,-11,13,-15,17,-19,21,-23,25,-27,29,-31,33,-35,37,-39,41,-43,45,...
18:46:59 <Hafydd> haskell816: there isn't really a better way to do that with a list comprehension than what I put above, unless you're using parallel list comprehensions.
18:48:17 <haskell816> aha, thanks! i don't remember using cycles, iirc, but thanks!
18:48:18 <Hafydd> > [if i % 2 == 0 then -2*i+1 else 2*i-i | i <- [1..]]
18:48:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:48:22 <Hafydd> Er...
18:48:54 <Hafydd> > [if i % 2 == 0 then -2*i+1 else 2*i-1 | i <- [1..]]
18:48:56 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
18:49:16 <haskell816> [if x % 4 == 1 then x else -x | x <- [1, 3 ..]]
18:49:27 <verement> Hafydd: I think you want `div` rather than (%)
18:49:32 <haskell816> yeah xD
18:49:33 <Cale> `mod`
18:49:36 <Hafydd> ...
18:49:36 <Cale> not `div`
18:49:36 <Hafydd> Oh.
18:49:42 <haskell816> [if x `mod` 4 == 1 then x else -x | x <- [1, 3 ..]]
18:49:42 <Hafydd> :t (%)
18:49:43 <lambdabot> Integral a => a -> a -> Ratio a
18:49:56 <Cale> Yeah, (%) is the constructor for fractions
18:50:18 <haskell816> [if x `mod` 4 == 1 then x else (-x) | x <- [1, 3 ..]]
18:50:37 <haskell816> oh, i have to add >
18:50:47 <haskell816> > [if x `mod` 4 == 1 then x else (-x) | x <- [1, 3 ..]]
18:50:49 <lambdabot>  [1,-3,5,-7,9,-11,13,-15,17,-19,21,-23,25,-27,29,-31,33,-35,37,-39,41,-43,45,...
18:51:29 <Cale> > [s * x | (s,x) <- zip (cycle [1,-1]) [1,3..]]
18:51:31 <lambdabot>  [1,-3,5,-7,9,-11,13,-15,17,-19,21,-23,25,-27,29,-31,33,-35,37,-39,41,-43,45,...
18:51:40 <Cale> Or indeed,
18:51:50 <Cale> > zipWith (*) (cycle [1,-1]) [1,3..]]
18:51:51 <Cale> oops
18:51:51 <lambdabot>  <hint>:1:35: parse error on input ‘]’
18:51:52 <Cale> > zipWith (*) (cycle [1,-1]) [1,3..]
18:51:54 <lambdabot>  [1,-3,5,-7,9,-11,13,-15,17,-19,21,-23,25,-27,29,-31,33,-35,37,-39,41,-43,45,...
18:52:07 <Cale> Yeah, that was already given above, I see
18:52:25 <Cale> Do we have parallel list comprehensions turned on?
18:52:42 <Cale> > [s * x | s <- cycle [1,-1] | x <- [1,3..]]
18:52:44 <lambdabot>  [1,-3,5,-7,9,-11,13,-15,17,-19,21,-23,25,-27,29,-31,33,-35,37,-39,41,-43,45,...
18:52:48 <Hafydd> Nice.
18:52:50 <Cale> yes, apparently we do
18:53:22 <haskell816> oh, the last one looks great
18:53:48 <Cale> Or if you don't want to use the properties of multiplication...
18:53:58 <Cale> > [s x | s <- cycle [id,negate] | x <- [1,3..]]
18:54:00 <lambdabot>  [1,-3,5,-7,9,-11,13,-15,17,-19,21,-23,25,-27,29,-31,33,-35,37,-39,41,-43,45,...
18:54:01 <haskell816> i wasn't in the search of the best solution, but more like searching for a solution i can convert to Erlang
18:54:04 <haskell816> which i am learning atm
18:54:29 <Cale> Yeah, that probably won't convert to Erlang, it's a quirky extension to the syntax of list comprehensions
18:54:34 <haskell816> and i don't know their equivalent of "cycle"
18:54:48 <Hafydd> Heh. Unfortunately, Erlang does not support infinite lists.
18:54:48 <Cale> They probably don't have one, because Erlang is strict
18:54:59 <Cale> cycle makes an infinite list
18:55:39 <haskell816> hm
18:56:21 <Hafydd> (So, in Erlang, the best way is probably one using arithmetic, as suggested above.)
18:57:02 <haskell816> you mean the one i did myself? [if x `mod` 4 == 1 then x else (-x) | x <- [1, 3 ..]]
18:57:40 <haskell816> about [1, 3, ..], i know the length of a list in advance, that's not a problem
18:57:55 <broma0> Whos regularly writes haskell code that interacts with a SQL database?
18:58:47 <broma0> or at least, who has ever written haskell code that interacts with a SQL database
19:01:45 <Eduard_Munteanu> broma0, you might want to ask a specific question
19:02:02 <broma0> Eduard_Munteanu: fair enough
19:02:39 <Tritlo> what can cause GHC.Base not to be imported?
19:03:16 <broma0> What SQL library are you (anyone) using? 
19:06:15 <Moggle> I'm trying to use persistent, and the issue I'm running into is that the automatically generated classes it takes from my declarations aren't records, and i'd really like for them to be
19:06:26 <Moggle> is it possible to tell them to generate the class as having records?
19:06:40 <adamCS_> Is there a simple name for a thing, t, which is traversable, where (t a) is a monoid for any a and there is a function (a->t a), to make a single element value?
19:06:40 <Moggle> (i may be messing up on terminology, i apologize if so)
19:07:12 <geekosaur> Tritlo, what is trying to import that? (It doesn't exist)
19:07:42 <broma0> Moggle: how are you generating classes from your declarations? 
19:07:54 <geekosaur> (unless ghc8.1, not yet released, has it)
19:08:05 <broma0> Moggle: are you generating all the persistent stuff from a simpl 'data X = X { ... }'?
19:08:30 <Tritlo> geekosaur: I'm using MonadPlus, but it won't find it unless I import GHC.Base or Control.Monad
19:08:38 <Moggle> broma0, persistent has a TH-thing where you define a class in a special way, http://www.yesodweb.com/book/persistent (there's a code snippet a little ways down showing it first thing)
19:08:57 <Moggle> i'm just wondering if there's an option i can set to make the TH it does output the class in a recordy way.
19:09:25 <broma0> Moggle: and that's precisely why i don't use persistent! i hate that it hijacks my data declarations (by preventing me from writing them myself)
19:09:34 <broma0> Moggle: im sorry, but i can't help with your question
19:09:38 <Moggle> i agree, but i think it's really cool what it does
19:09:40 <Moggle> thanks for trying!
19:10:03 <Moggle> it'd be nice if it could take data declarations and use that to make the database tables but that's life
19:10:13 * geekosaur just checked back to ghc 6.6.1, still no GHC.Base in evidence
19:10:28 <Moggle> is there perhaps a haskell extension that can take a non-record class and define a bunch of functions that's like making it a record, maybe?
19:10:39 <Moggle> TH got me into this situation, maybe it can get me back out of it
19:11:24 <Tritlo> geekosaur: if you open ghc and do `:info MonadPlus`, it says "defined in GHC.Base"
19:13:13 <geekosaur> hm. undocumented internals, lovely
19:13:27 <geekosaur> ghci 7.10.3 can import it, it seems
19:13:38 <EvanR> verement: my friend and i were just talking about MOO, triggered by your project, and i realized i have a hacked lambdamoo server in the depths of my ancient backups, along with our old database
19:13:51 <EvanR> im about to try to deploy it
19:14:03 <geekosaur> in any case you don't want to use it directly
19:14:06 <verement> EvanR: nice, let me know how it goes
19:14:39 <geekosaur> it likely exists so that the different Preludes --- which aren't even active in ghc 7.10 as Haskell98 and Haskell2010 are both quite broken currently --- can pull stuff as needed
19:15:06 <geekosaur> (ghc's support for them, that is)
19:15:28 <Tritlo> alright, I'll try to avoid them
19:15:34 <geekosaur> you can use MonadPlus
19:15:40 <geekosaur> you should not use GHC.Base directly
19:15:43 <verement> EvanR: also I'd be interested to know what sort of things you hacked into the server
19:15:58 <EvanR> mainly color
19:16:03 <geekosaur> Control.Monad is where MonadPlus officially lives; ghc is leaking internal implementation
19:16:07 <geekosaur> details
19:16:51 <Tritlo> alright
19:16:59 <EvanR> i say that but now i have no idea 
19:17:22 <Moggle> hrm i think it may be time
19:17:22 <Tritlo> but shouldn't I be able to use (<|>) and empty (from control.applicative) without needing MonadPlus?
19:17:24 <Moggle> to learn lens
19:17:30 <Moggle> lens better than records anyways.
19:17:34 <Tritlo> if I say (Alternative m, Monad m) ?
19:18:29 <geekosaur> I would think so...
19:19:11 <geekosaur> I see no references to MonadPlus in Control.Applicative
19:20:44 <geekosaur> although Monad isn't necessary for Alternative. I see it is for MonadPlus though, so you seem to have that backwards? MonadPlus now requires Alternative, not the other way around
19:21:31 <Tritlo> yeah, but If I'm not using mzero and mplus, I should be able to have just Alternative and Monad and use <|> and empty
19:21:43 <scshunt> yes but you can't
19:21:44 <scshunt> sorry
19:22:41 <Tritlo> :/
19:23:29 * hackagebot twitter-conduit 0.1.2 - Twitter API package with conduit interface and Streaming API support.  https://hackage.haskell.org/package/twitter-conduit-0.1.2 (TakahiroHimura)
19:27:14 <prooftechnique> ?t (<|>)
19:27:14 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
19:27:27 <prooftechnique> :t (<|>)
19:27:28 <lambdabot> Alternative f => f a -> f a -> f a
19:28:02 <Tritlo> :t lift
19:28:03 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
19:28:40 <Tritlo> :t lift (<|>) 
19:28:42 <lambdabot> (Alternative f, MonadTrans t) => t ((->) (f a)) (f a -> f a)
19:28:50 <parsecChar> what is 'stack ide' ?
19:29:51 <prooftechnique> parsecChar: https://github.com/commercialhaskell/stack-ide
19:31:41 <prooftechnique> It appears to be an interface to ide-backend. How is ide-backend doing, anyway?
19:31:46 <prooftechnique> I haven't heard much, lately
19:31:52 <parsecChar> prooftechnique: hmm, it looks like teh backend part of an ide
19:31:56 <parsecChar> i.e. not the UI / editor part,
19:32:01 <parsecChar> but the things that make the editor 'smart'
19:32:34 <prooftechnique> parsecChar: Yeah, the idea is that the editor can communicate with it over a standard protocol, so it's just a matter of editor support
19:32:56 <prooftechnique> In the same sort of vein as, say, ycmd
19:43:00 <EvanR> verement: what happened was when i tried to cabal update with 128M of ram on the vps it crashed the server
19:43:12 <verement> ouch
19:43:36 <verement> no swap?
19:44:22 <EvanR> apparently not
19:44:45 <EvanR> there is swap
19:44:46 <felixn> http://lpaste.net/154534 <-- anyone know how to fix issue with implicit type constraints not working?
19:44:51 <EvanR> i guess it ran out
19:45:42 <Cale> felixn: You can't make that Functor instance, fmap's type isn't specialised enough for that to work
19:46:30 <EvanR> trying lambdamoo C code
19:46:32 <Cale> felixn: You can't implement  fmap :: (a -> b) -> Meow a -> Meow b  because you need to use the Meow data constructor at type b, so you need an instance of Show b, which you don't have.
19:46:56 <Cale> The best you could do is  fmap' :: Show b => (a -> b) -> Meow a -> Meow b
19:47:25 <felixn> Cale: ah, I was trying to plug this in to get the monad syntax sugar, so guessing that's not possible either
19:48:28 <mgsloan> parsecChar: We're no longer working on it, though, in favor of haskell-ide-engine, which has similar, though broader, goals compared with stack-ide
19:48:58 <parsecChar> mgsloan: your nick looks familiar but I can not figure out why
19:49:13 <felixn> Cale: I was trying to look up some hack to get it to work dynamically, but I couldn't get it to work since Data.Dynamic still requires Typeable constraint
19:50:24 <scshunt> felixn: in general, don't put type constraints on your type constructors
19:51:02 <scshunt> it doesn't get you anything and causes you to run into problems like this
19:52:11 <mgsloan> parsecChar: Perhaps from the stack issue tracker?  I've also been around #haskell to varying degrees for about 8 years orso
20:01:25 <parsecChar> is chris done in this channel?
20:01:43 <parsecChar> in my strict haskell -> js compiler, I am finding writing out js code tedious (especailly dealing with tail recursion)
20:01:46 <parsecChar> I'd like to steal Fay's backend
20:01:52 <parsecChar> is chris done here? could learn alot from him
20:02:07 <orion> What is currently the best/easiest way to access postgres from Haskell?
20:02:29 <orion> I'm looking for all the Haskellisms -- type safety, etc.
20:02:54 <parsecChar> orion: groundhog
20:02:57 <mgsloan> parsecChar: He isn't, and he's probably still sleeping cuz he's in europe.  I'm sure he wouldn't mind if you borrowed the backend
20:03:24 <parsecChar> mgsloan: well, I read the license file in github; but I'd like to talk to the author for insights on how to best repalce haskell-src-exts with ghc.core
20:03:31 * hackagebot with-location 0.0.0 - Use ImplicitParams-based source locations in a backward compatible way  https://hackage.haskell.org/package/with-location-0.0.0 (SimonHengel)
20:03:32 <parsecChar> since basically, fay = haskell-src-exts for parsing + fay's backend
20:03:33 * hackagebot sdl2-ttf 1.0.0 - Binding to libSDL2-ttf  https://hackage.haskell.org/package/sdl2-ttf-1.0.0 (schalmers)
20:03:41 <parsecChar> I want ghc.core (which already can access) + fay's backend
20:03:47 <mgsloan> orion: persistent and esqueleto work well too.  I haven't tried groundhog
20:03:57 <parsecChar> opaleye is nice too
20:04:14 <parsecChar> there's postgresql-simple, persistent, esqueleto, opaleye, and groundhog
20:04:17 <parsecChar> my current favorite is groundhog
20:04:23 <parsecChar> plays very nicely with snap
20:04:28 <orion> Why groundhog over opaleye?
20:04:38 <mgsloan> Have you looked at ghcjs or haste?  This is sounding kinda like those.
20:05:27 <parsecChar> mgsloan: yeah, haste is almost like writing in another languge (since the libraries don't quite match up); ghcjs is a bit slow for my taste (and the code it genreates doesn't work well on weak devices)
20:05:27 <ski> parsecChar : chrisdone seems to be connected atm, but not in the channel now
20:05:39 <parsecChar> so I'd like a 'strict' variant of ahskell compiled ot js
20:05:44 <parsecChar> that I can use ghc's type checker for
20:08:44 <mgsloan> a strict variant of haskell is going to be even more foreign than haste's flavour
20:09:32 <parsecChar> mgsloan: for writing haskell apps; it's not hackage that I want, it's ghc's insane type checking abilities I wnat
20:09:39 <mgsloan> If you want to support GHC's concurrency model, you're going to need to do the same variety of CPS transformation (IIRC) that GHCJS does, meaning you'll end up with similarly large code that is a bit expensive on slower devices
20:09:43 <mgsloan> Ah I see
20:09:47 <mgsloan> Fair 'nough!
20:10:03 <mgsloan> Good luck D:
20:10:05 <mgsloan> Err :D
20:10:06 <mgsloan> lol
20:10:08 <parsecChar> mgsloan: nope, I don't need STM in my js apps :-)
20:10:22 <mgsloan> It's not a matter of STM or not
20:10:27 <mgsloan> it's a matter of having fine grained concurrency
20:10:38 <parsecChar> for single page web apps?
20:10:43 <parsecChar> when will I need that? [serious question]
20:11:06 <luigy> bleh real js ninjas only use callbacks
20:11:53 <parsecChar> luigy: black belt js ninjas create strings on the fly and evail them
20:12:20 <luigy> hey that is what ghcjs --interactive does :)
20:13:13 <mgsloan> Well, it is handy for having things like "this is the thread that communicates with the server".  Threads are very convenient for writing things that need to block waiting for things
20:13:34 <luigy> but yeah let's never understimate what the ninjas try to use strings for 
20:13:42 <parsecChar> luigy: does ghcjsi work yet?
20:14:11 <mgsloan> This way once there is a good way to do js concurrency, all of your code can be upgraded for free!
20:14:22 <parsecChar> mgsloan: that is a good point // the no callbacks view
20:15:17 <luigy> parsecChar well no stderr currently since it is use for communication of client/server
20:16:04 <luigy> man I have a dream that improving tooling we will get more ppl involved and therefore everything else gets better
20:16:19 <parsecChar> luigy: what? you can load a webpage .... and inject new js code via ghcjsi ?
20:16:28 <luigy> parsecChar yes sir
20:16:31 <luigy> eval all the way
20:16:35 <parsecChar> no way
20:16:39 <parsecChar> how do I install this
20:16:43 <parsecChar> there goes my evening
20:17:01 <luigy> def I'm stack biased 
20:17:27 <parsecChar> http://docs.haskellstack.org/en/stable/ghcjs/ it is
20:19:11 <parsecChar> luigy: it took me quite a fe months to get my ideal ghci workflow
20:19:21 <parsecChar> luigy: is there a youtube video / doc documenting optimal "ghcjs --interactive" workflow?
20:19:25 <parsecChar> I want to learn all the tricks upfront
20:19:30 <parsecChar> instead of only learning them months down the line
20:19:52 <luigy> ghci workflow is pretty good nowadays... would really like to have the same for ghcjs
20:20:09 <luigy> you will need a ghcjs version from this month
20:20:29 <luigy> it just got merged recently
20:20:48 <parsecChar>             ghcjs-0.2.0.20151230.3_ghc-7.10.2:                   url: "https://github.com/nrolland/ghcjs/releases/download/v.0.
20:20:50 <parsecChar> that is not good enough?
20:20:52 <parsecChar> what do i need ?
20:20:59 <parsecChar>             ghcjs-0.2.0.20151230.3_ghc-7.10.2:                   url: "https://github.com/nrolland/ghcjs/releases/download/v.0.2.0.20151230.3/ghcjs-0.2.0.20151230.3.tar.gz"
20:21:11 <parsecChar> ^^ that's what I'm 44/46 packages through installing on
20:21:16 <parsecChar> but you're telling me I need something newer?
20:21:28 <luigy> it just got merged on master like this month I believe
20:21:42 <parsecChar> okay
20:21:44 <parsecChar> how do I get it via stack ?
20:22:03 <luigy> I was sitting on a separante branch almost 8 months now
20:22:29 <luigy> it***
20:22:39 <luigy> hmm let me  see
20:23:32 <parsecChar> look at your stack.yaml file, give me the "compiler:" section :-)
20:24:20 <luigy> not quite I have all sorts of forks and my public things might be a bit outdated from master :P
20:25:30 <luigy> parsecChar here is a clip from nov https://cldup.com/K4Ub9rOl9V.mp4
20:25:48 <crobbins> anyone know of some general way to make a function tail recursive if the recursive call is within a closure?
20:25:49 <crobbins> https://gist.github.com/carymrobbins/a913f449bd62c8c71cc0
20:26:50 <mgsloan> parsecChar: I think it ought to work if you just point stack at a recent tarball from here http://ghcjs.luite.com/
20:26:59 <parsecChar> luigy: that's pretty badass
20:27:11 <parsecChar> though ":r" is still slowish due to TH, but much faster than plain ghcjs
20:27:11 <luigy> lol thanks mgsloan that is exactly what I was looking for 
20:27:15 <parsecChar> also nice you're usging reflex
20:27:36 <mgsloan> Make sure you have the latest stack, though, not too long ago it was fixed to allow installing luite's tarballs (which I believe don't change ghcjs's package version)
20:29:10 <codygman> I'm having some problems getting a memory profile with information generated in a stack project, see my attempt here: http://lpaste.net/154535
20:31:34 <EvanR> verement: fission mailed... it was an old copy, and apparently to get color there were no hacks involved, just inserting an ESC char into the database in the right spot
20:33:11 <mgsloan> codygman: You are running it with "+RTS -hc", maybe try "+RTS -p"?
20:33:33 <mgsloan> I'm actually not sure what -hc does, maybe try "-hT" for the heap profile?
20:34:15 <verement> EvanR: fission mailed? not sure what you mean
20:39:38 <codygman> mgsloan: +RTS -P is what I wnated I think. I still have no output though. I'm on linux btw.
20:42:12 <mgsloan> Weird!
20:42:36 <mgsloan> If you have a test suite, then "stack test --profile" should profile the test suite
20:42:47 <mgsloan> Gotta go, tho, good luck!
20:43:17 <EvanR> verement: mission failed
20:43:28 <verement> ah
20:43:47 <codygman> thanks for your help mgsloan 
20:56:55 <parsecChar> is there a way to tell stack 'yo, make the ghc that you hve installed' visible outside of stack ?
20:57:07 <parsecChar> or does stack selfishly hide the stack that it's instlled fro the rest of the world ?
20:57:53 <kadoban> parsecChar: There is 'stack ghc' or you can add one of the directories inside ~/.stack/ to your $PATH, you have to pick which one
20:59:20 <parsecChar> you mean a dir like ~/.stack/programs/x86_64-linux/ghc-7.10.3/bin ?
20:59:26 <kadoban> Yes
21:02:12 <luigy> kadoban do you know if there is there a version manager yet? i feel like in other langs there would of been a few options now xD
21:03:19 <kadoban> Version manager?
21:04:22 <luigy> kadoban https://github.com/tj/n
21:05:44 <luigy> so imagine something liek...    gvm switch 7.10 ; ghc-mod --version ;  # ... compiled by 7.10
21:06:01 <luigy> gvm switch 7.10.3; ghc-mod --version ; # ...compiled by 7.10.3
21:06:27 <kadoban> The model stack uses, you don't really need to run GHC yourself much at all. The story for stuff like ghc-mod isn't really complete yet though, we'll have to see what haskell-ide-engine people come up with for example I guess.
21:07:44 <luigy> kadoban oh totally, I haven't had a need for it with stack, but it could definitely be wrapper around the compiler setup from stack does
21:08:51 <kadoban> Yeah it might be pretty interesting and useful to do for some things.
21:08:52 <luigy> so under the hood the tool would use stack for the compiler setup, because sandboxing :)
21:09:12 <luigy> yeah, just ghc-mod and haddock come to midnd
21:10:09 <luigy> some ppl really want stack to be a bit more like apt-get/npm and get confused when it's missing features xD
22:07:11 <elliptic00> in GHCi, how to capture the output of my code?  For example,  "> :main"  I want to redirect the output to a file
22:14:18 <EvanR> :t writeFile
22:14:21 <lambdabot> FilePath -> String -> IO ()
22:14:31 <EvanR> hrm
22:14:44 <EvanR> elliptic00: there are console capturing programs similar to screen
22:15:26 <Sornaensis> :t foldr
22:15:28 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
22:15:43 <EvanR> you can also reopen stdout in the program itself
22:28:14 <Wizek> Anyone of you might know of ways to speed up yesod builds (at least with `yesod devel`)? 
22:36:17 <Ongy> Ralith: when I'm not asleep yes
22:38:11 <Ralith> Ongy: I was going to ask you if you happened to know where to find documentation on communicating with ibus from toolkit side of things rather than the IM side of things, but since then I've decided to just put off input methods until wayland comes up with a nice modern standardized API
22:40:18 <Ongy> ah, good decision, all I could find was the general api documentation that's more a list of available functions, so I just started to read through the source of the library for anything I wanted
22:42:03 <Ralith> yeah, though the API docs seem pretty good as API docs go
22:42:09 <Ralith> lots of descriptive text
22:42:14 <Ralith> just no high-level stuff
22:42:51 <Ralith> it wasn't so much that I was turned off by the state of the documentation as that I became aware that wayland was working on better standardizing things and figured I could wait
22:43:47 <Ongy> Ralith: they are? the last thing I saw was that ibus should be compatible with wayland at some point
22:44:34 <Ralith> exactly!
22:45:14 <Ralith> meaning a toolkit can just communicate with wayland's IM-aware extensions and not worry about the rest
22:45:26 <Ralith> or at least that's my impression
23:43:38 * hackagebot gnss-converters 0.1.6 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.6 (markfine)
23:51:46 <pharpend> Anyone feel like dealing with an off-by-one error?
23:52:22 <dmj`> pharpend: sure paste it
23:52:35 <pharpend> it's a 1600 line library
23:52:46 <pharpend> https://github.com/pharpend/sd-mech <- clone the markov-prime branch, run test suite
23:53:08 <pharpend> if I run like 700 test cases, no error
23:53:18 <pharpend> but if I run 150K, it shows up, <100 times
23:53:18 <dmj`> pharpend: maybe you should isolate a few functions that are known to be off-by-one
23:53:37 <dmj`> pharpend: can you tell which input caused it
23:53:42 <pharpend> yeah
23:53:47 <dmj`> and on which function
23:53:57 <pharpend> here, i'll paste some stuff
23:55:18 <pharpend> http://lpaste.net/154543 <-- relevant test suite file
23:56:03 <pharpend> relevant library file: http://lpaste.net/154544
23:56:34 <pharpend> http://lpaste.net/154545 <- test suite output
23:56:37 <pharpend> last 500 lines
23:57:02 <pharpend> some of them are off by two or three
