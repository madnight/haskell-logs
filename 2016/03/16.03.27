00:02:08 <MichaelBurge> YellowOnion: I often find it's easier to develop on Linux and deploy to Windows, rather than develop on Windows.
00:03:46 <MichaelBurge> I don't think the compiler itself has too much trouble on Windows(although GHCi does), but a lot of packages you might depend on make assumptions
00:04:34 <YellowOnion> MichaelBurge, don't get me started on linux v windows :P
00:05:46 <YellowOnion> Possibly, been a few months since I last tried, but it would initiate a window and then promptly lock up. (its an OpenGL/GLFW app)
00:07:22 <ontop> I want ETA reduces to go away.
00:07:23 <ontop> I don't like them.
00:07:41 * hackagebot language-javascript 0.5.14.7 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.14.7 (ErikDeCastroLopo)
00:07:41 * hackagebot atndapi 0.1.0.0 - An interface of ATND API  https://hackage.haskell.org/package/atndapi-0.1.0.0 (ynishi)
00:10:20 <MichaelBurge> YellowOnion: You could probably capture the system calls being made, along with the calls to OpenGL; you can also try to make a minimal example that replicates the bug
00:10:55 <MichaelBurge> YellowOnion: Your driver might have a verbose or debugging mode on Windows.
00:14:16 <YellowOnion> MichaelBurge, I was hoping it was more simple than that, getting ghc use llvm on windows without errors was a big nightmare to begin with. as I said, I wonder if its just the wrong version of llvm.
00:14:59 <YellowOnion> I don't even know if its going to provide any performance benefits that are worth talking about.
00:17:01 <MichaelBurge> YellowOnion: Is it the OpenGL call that's locking up, or the compiled Haskell code?
00:18:42 <MichaelBurge> Like, if you attach a debugger, whose code is it stopped in?
00:19:38 <YellowOnion> the plain GHC version compiles and runs fine, so I assume its not the OpenGL.
00:22:36 <YellowOnion> MichaelBurge, just to clarify, I'm a hobbyist and at the time was learning how to write a bit of haskell, learning 5 tools at once can be a real drain on effort.
00:25:29 <YellowOnion> This is why my question was specifically about stack+llvm, because cabal is not really recomended for starting out, and though maybe it actually included llvm by default so there's less chance of version errors, mismatching compliers, and the like.
00:25:44 <YellowOnion> cabal/haskell platform.
00:28:25 <YellowOnion> Well I don't know what has chanced but it looks like it compiles with llvm now...
00:28:30 <YellowOnion> changed*
00:31:31 <YellowOnion> No, its just not showing the error, false alarm.
00:37:12 <lpaste> YellowOnion pasted “No title” at http://lpaste.net/8404959107999596544
00:43:19 <YellowOnion> Maybe I should just wait till they start packaging llvm with ghc.
00:43:57 <MichaelBurge> YellowOnion: Somehow I thought they already did that. I remember they had some patches that hadn't been merged upstream or something.
00:44:12 <MichaelBurge> I think you have to use a specific version of LLVM that is compatible with whatever they're using
00:44:26 <YellowOnion> MichaelBurge, maybe I need to upgrade ghc haha
00:44:55 <YellowOnion> Yeah, the problem is my package manager updated it.
00:46:44 <MichaelBurge> Sometimes I wish there was a limited Haskell, that didn't have such a big runtime and generated binaries that could be easily debugged with tools like gdb or strace.
00:47:13 <shachaf> What's the difficulty with strace?
00:47:15 <MichaelBurge> Like if you wanted to write a library to calculate prime numbers, you probably don't want a huge runtime when you inevitably go to profile it
00:47:29 <MichaelBurge> It works fine of course, but the runtime generates a lot of spurious system calls.
00:47:47 <shachaf> I understand the difficulty with gdb, but what sort of generated code would you prefer for ease of gdb debugging?
00:49:00 <MichaelBurge> I guess strict code that doesn't allocate new memory and generates assembly that's easily readable?
00:49:30 <YellowOnion> jhc?
00:49:32 <shachaf> Well, that changes semantics quite a bit.
00:49:33 <MichaelBurge> And the intention would be that you bury such code in a library somewhere, and layer the regular Haskell semantics on top of it
00:49:41 <MichaelBurge> Like how people have strict and lazy bytestrings
00:49:45 <zRecursive> Besides installing the haskell platform on windows, can we install both GHC and cabal repectively on windows ?
00:51:11 <YellowOnion> zRecursive, there's binaries you can download (somewhere), there's minGHC and also haskell-stack
00:51:38 <zRecursive> YellowOnion: on www.haskell.org ?
00:51:56 <MichaelBurge> YellowOnion: Maybe jhc could work. I imagine it emits object files that you could reference using the FFI
00:52:51 <YellowOnion> MichaelBurge, I though it emitted plain C code, but thats only one step to an object.
00:54:41 <YellowOnion> zRecursive, yeah you need to look at the respective pages haskell.org/cabal/download.html, and haskell.org/ghc/
00:55:57 <YellowOnion> zRecursive, I'm not sure I would recommend it though.
00:57:34 <zRecursive> YellowOnion: thanks
00:58:24 <YellowOnion> zRecursive, what are you trying to do anyway?
00:58:39 <YellowOnion> is platform too big?
01:00:12 <zRecursive> i think so
01:00:43 <YellowOnion> zRecursive, are you new?
01:01:08 <montanonic> Can anyone explain to me what the W signifies in: O(n*min(W, n)) ?
01:01:10 <zRecursive> new haskeller ? yeah
01:01:24 <montanonic> getting that complexity time from : http://hackage.haskell.org/package/unordered-containers-0.2.7.0/docs/Data-HashSet.html#g:9
01:02:39 <YellowOnion> zRecursive, I recently discovered this which I wish I new about when I started learing: https://github.com/bitemyapp/learnhaskell
01:02:53 <MichaelBurge> montanonic: My guess is the number of buckets, since it's a hash.
01:04:21 <montanonic> MichaelBurge: thank you :)
01:13:01 <zRecursive> YellowOnion: i'm still afraid of lazy in haskell which seems to make us lose control of program execution. 
01:14:28 <jle`> i think the control is still there, it's just tricker to analyze than in most languages.
01:14:43 <jle`> zRecursive: also, a nice way to install ghc + cabal these days with stack :)
01:14:46 <jle`> @where stack
01:14:46 <lambdabot> I know nothing about stack.
01:14:58 <jle`> http://docs.haskellstack.org/en/stable/README/
01:15:08 <YellowOnion> jle`, I linked him to learnhaskell which links stack.
01:15:12 <zRecursive> thanks
01:15:14 <jle`> neat!
01:17:20 <YellowOnion> zRecursive, the biggest issue I've had with laziness is thunk build up / running out of memory. You can make things strict with some hints for the compiler.
01:17:45 <jle`> yeah, ghc gives us a lot of tools to control how evaluation works, with laziness and strictness
01:17:52 <zRecursive> jle`: "tricker to analyze" makes the program hard to debug like using GDB?
01:18:09 <jle`> not sure, i've never really needed gdb to debug
01:18:17 <jle`> almost all of my haskell debugging happens at compiletime
01:18:21 <jle`> things are simpler that way :)
01:18:35 <zRecursive> YellowOnion: i ever dreamed of default to strict 
01:19:04 <jle`> strict-as-default has problems with memory and space usage, too
01:19:19 <jle`> so you are stuck with the problems that most other languages suffer from
01:19:27 <YellowOnion> Lazy is your friend.
01:19:38 <jle`> laziness helps space and time performance more often than it hurts it
01:20:19 <zRecursive> i indeed like [1..] too, it is very convenient
01:21:33 <Peaker> laziness makes space use (and consequently, performance) much harder to predict
01:22:40 <YellowOnion> > tail . tail . tail . snd $ ([1..],[3..])
01:22:42 <lambdabot>  [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,3...
01:22:54 <Peaker> I strongly disagree that laziness helps performance -- because eagerness is predictable enough that you would always insert explicit laziness where it matters for performance, but the converse is not true
01:23:27 <Peaker> laziness helps composability
01:23:28 <jle`> there are libraries in other languages that give you laziness tools to increase performance
01:23:28 <zRecursive> Peaker: like what ocaml does ?
01:23:39 <jle`> like lazy.js
01:23:48 <jle`> it benchmarks higher than underscore.js, etc. regularly
01:24:05 <jle`> (the more prominent javascript utility libraries)
01:24:12 <Peaker> zRecursive: and SML, and pretty much any language that has anonymous functions (and to a lesser extent, optional memoization)
01:24:39 <YellowOnion> > all odd [1..]
01:24:41 <lambdabot>  False
01:24:51 <YellowOnion> thats a huge peformance boost :P
01:25:14 <jle`> http://danieltao.com/lazy.js/
01:25:36 <Peaker> YellowOnion: an eager language will have short-circuiting(aka lazy) operations as needed as well
01:25:51 <jle`> benchmarks paint a strong picture :3
01:25:52 <zRecursive> YellowOnion: but you donot get all odd ?
01:26:15 <Peaker> the question isn't really laziness vs eagerness because virtually all languages mix the two. Some things gotta be one or the other.  The question is *pervasive* laziness or eagerness
01:26:53 <Peaker> When you need laziness, you'll use laziness in Haskell, OCaml, SML, or even C(!)
01:26:57 <YellowOnion> zRecursive, pardon?
01:27:10 <jle`> yeah, i don't think all-lazy or all-eager is the right answer for anything. laziness helps performance in some cases, hurts in others...eagerness helps performance in some cases, hurts in others
01:27:13 <Peaker> http://augustss.blogspot.co.il/2011/05/more-points-for-lazy-evaluation-in.html <-- gives good arguments for pervasive laziness
01:27:18 <jle`> but i think that's basically what we've been saying
01:27:47 <Peaker> jle`: There's still the question of the default. Pervasive laziness or eagerness.  I'm more inclined towards the latter these days
01:27:50 <zRecursive>  YellowOnion: i mean i donot understand the "a huge performance boost" ?
01:28:12 <jle`> having composability w.r.t. semantics is nice, though
01:28:28 <YellowOnion> zRecursive, if that was strict, it wouldn't ever terminate.
01:28:38 <Peaker> jle`: Yeah, laziness is awesome for composability, terrible for performance-predictability
01:28:49 <Peaker> (pervasive laziness, that is)
01:28:51 <jle`> YellowOnion: might be more clear if you compared something like all odd [1..100000000]
01:29:03 <zRecursive> YellowOnion: i see
01:30:23 <YellowOnion> Peaker, I had a very similar issue with iterate, and very large numbers, ended up running out of memory.
01:34:49 <Moggle> hey, i'm trying to get mueval working, but for some reason it is giving me an error trying to open /usr/lib/ghc/settings... i don't have that, i'm using stack
01:35:02 <Moggle> how can i tell it where to find a properly installed ghc location?
01:38:38 <YellowOnion> I assume mueval is doing something a bit differently to a typical package, maybe hunt through the build configs for this (seemly hardcoded) directory?
01:39:30 <Moggle> no such hardcoding as far as i can tell
01:39:36 <Moggle> maybe hint has it?
01:39:52 <Moggle> i guess one solution is just to symlink the /usr/lib/ghc dir
01:39:58 <Moggle> i'll look up how to do that
01:41:42 <Moggle> where does stack put ghc?
01:43:56 <Peaker>  ~/.stack/programs/x86_64-linux/ghc-<version> here
01:45:31 <Moggle> thanks
01:47:23 <Moggle> yep not happening 
01:47:31 <Moggle> now it wants a package db
02:00:00 <talzs> If I'm writing up a program that uses several packages that are not normally installed on a machine, is there a way to include them with my source so that ghc can build my program?
02:00:58 <Peaker> talzs: why not use cabal dependencies normally?
02:01:51 <talzs> the machines I'm looking at may not have an internet connection, and if they do the version of cabal is old enough that my code doesn't build
02:08:23 <Peaker> talzs: https://www.stackage.org/package/yackage <- might help?
02:09:10 <YellowOnion> talzs, bindings-GLFW includes source with it, maybe have a look at how they do it.
02:10:22 <talzs> thanks, I'll check those out. I Appreciate the help :)
02:11:10 <roelof> hello, with QuickCheck how can I check for a almost equality. I have to prove something with floats and then == does not work all the time 
02:11:37 <roelof> so can I do something like  a - b > 0.01  where a and b are functions 
02:13:01 <YellowOnion> talzs, I actually modified that library and a depedency on it, and installed them for my package using the cabal sandbox. so you shouldn't need a internet connection if all depedencies are already included.
02:13:15 <shachaf> roelof: You can just write that?
02:13:57 <roelof> shachaf:  Oke, I will try that 
02:14:44 <shachaf> @check \x y z -> let { a = (x+y)+z :: Double; b = x+(y+z) } in a == b
02:14:46 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 122 shrinks):
02:14:46 <lambdabot>  2.87179694363345 2.4392045060587133 -1.237776542580916
02:14:51 <shachaf> @check \x y z -> let { a = (x+y)+z :: Double; b = x+(y+z) } in abs (a - b) < 0.01
02:14:53 <lambdabot>  +++ OK, passed 100 tests.
02:17:00 <roelof> shachaf:  here I do : propAssociate :: (Num a , Eq a, Ord a  ) => a -> a -> a -> Bool  and  propAssociate x y z = (( x + y) + z) - (x + ( y + z)) < 0.00001
02:17:35 <roelof> and I see this type error: http://lpaste.net/156986
02:18:10 <roelof> but if I change Num to Fractional , I cannot work with Int anymore :( 
02:18:43 <shachaf> Sounds like the type system is doing exactly what it should?
02:20:27 <lyxia> how do you expect to interpret 0.00001 as an Int
02:20:47 <roelof> Could be, but not what I want to test,  I want to test Int, Double and Float and for the last two I need to use something like this  a - b  > 0.01 
02:21:04 <roelof> lyxia:  0.0001 is not a Int 
02:21:56 <roelof> so I need two test, one for Int and one for float and double 
02:22:53 <lyxia> or you can convert the LHS to Double
02:23:59 <roelof> LHS ??
02:24:00 <ggole__> A type class for approximate comparison with an operation approx_eq :: a -> a -> Fractional -> Bool?
02:24:15 <ggole__> The instance for Int / Integer can just ignore the third argument
02:24:36 <lyxia> roelof: the left hand side of the inequality (( x + y) + z) - (x + ( y + z)) < 0.00001
02:29:51 <roelof> Thanks all. I have got it working :) 
02:32:17 <Guest24521> http://oortr.com/ZjllYz
02:37:04 <benneh> I'm playing about with DataKinds, and I've run into a problem. I've created a natural numbers type (http://lpaste.net/156987) and homogeneous fixed-length vector types based on them (http://lpaste.net/156988). How can I define 'pure' in the Applicative instance for 'Vector n'?
02:37:43 <benneh> I want 'pure a' to be the vector consisting of n copies of a, in case that wasn't clear.
02:41:04 <benneh> For that matter, is there any way of defining '<*>' without needing the ugly third line to cover the unreachable cases and without triggering a compiler warning?
02:49:35 <haskell945> Is there operator to compose `a -> m b` and `b -> c` to `a -> m c` similar to `.` and `>=>` ?
02:50:16 <YellowOnion> fmap?
02:50:51 <Maxdamantus> benneh: wouldn't the instance be something like `Applicative (Vector n) => Applicative (Vector ('NSucc n))`?
02:51:11 <YellowOnion> haskell945, fmap, or <$> if I understand correctly.
02:51:16 <Maxdamantus> benneh: and `Applicative (Vector 'NZero)`
02:51:21 <kaol> Fun fact: . is the Functor fmap instance for (->).
02:51:31 <Maxdamantus> (dunno, not familiar with most of the extensions)
02:52:07 <Maxdamantus> but logically, I think it should be something like that, so it's defined in terms of a known `pure` and `(<*>)`
02:52:08 <benneh> Maxdamantus: If I do that, then I need to include '(Applicative (Vector n))' conditions on any function which uses the Applicative instance. I'm trying to avoid that.
02:52:51 <benneh> Because GHC doesn't seem to be able to work out that every n is covered by those two instances, unfortunately.
02:52:55 <xa0> i think he wants something with typesig (a -> m b) -> (b -> c) -> a -> m c
02:53:10 <xa0> but yeah you could do that with fmap
02:54:08 <YellowOnion> :t (>=>)
02:54:09 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:54:41 <haskell945> Yes, I want (a -> m b) -> (b -> c) -> a -> m c and fmap doesn't seem to work
02:54:42 <numee> :t (. fmap) . flip (.)
02:54:43 <lambdabot> Functor f => (a1 -> f a) -> (a -> b) -> a1 -> f b
02:54:47 <Maxdamantus> benneh: well, those functions must be the ones supplying the `n`,
02:54:54 <Maxdamantus> Seems logical.
02:55:22 <Maxdamantus> taking, rather.
02:56:06 <poi_> @help
02:56:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:56:24 <poi_> list
02:56:36 <YellowOnion> !hayoo (a -> m b) -> (b -> c) -> a -> m c
02:56:50 <haskell945> In other words is there operator to compose monadic and normal functions?
02:56:54 <Maxdamantus> Gesundheit.
02:57:28 <benneh> Maxdamantus: But there's an Applicative instance for every n, so the 'Applicative (Vector n) =>' condition isn't really necessary.
02:57:38 <xa0> haskell945: why when you can just turn the normal functions into monadic ones
02:57:38 <benneh> I'm just trying to avoid the extra code.
02:58:16 <YellowOnion> :t (->^)
02:58:17 <lambdabot>     Not in scope: ‘->^’
02:58:17 <lambdabot>     Perhaps you meant ‘>>^’ (imported from Control.Arrow)
02:58:53 <haskell945> xa0: yes I can do this f1 >=> (return . f2) but maybe there is something better
02:58:59 <YellowOnion> haskell945, there's a few functions with that type signature in hayoo.
03:00:52 <xa0> i would honestly just do (fmap g . f) where f :: a -> m b and g :: b -> c
03:01:35 <xa0> if there is an operator it's probably not worth it
03:02:09 <Maxdamantus> benneh: I feel like that's probably an impossible thing to prove in these extensions, though I'm not really familiar with them.
03:02:31 <benneh> But it's so obvious :(
03:04:56 <Maxdamantus> It would rely on there not being an extra tag in the Natural definition, for example.
03:05:42 <haskell945> xa0: fmap g . f seems to be the simplest way, thanks
03:05:53 <ggVGc> given this, how can I create an instance of MovieClip? https://gist.github.com/01721fd1a30396172f9d
03:06:12 <ggVGc> trying to wrap a javascript libary using phantom types and GHCJS and am fairly lost..
03:06:13 <xa0> np
03:07:02 <benneh> Maxdamantus: Is there no way to just have 'instance Applicative (Vector n) where ...' and then give the definitions case by case based on the constructors of n?
03:07:20 <benneh> Like defining a function case by case.
03:07:49 <Maxdamantus> I'd hope not.
03:07:58 <benneh> Why not?
03:08:03 <Maxdamantus> unless there's logic to prove the thing I alluded to above.
03:08:25 <Maxdamantus> n \in N -> n = Z or n = S m and m \in N
03:08:27 <benneh> Well, yes, you would need to ensure that every case is covered. But that seems doable.
03:08:48 <benneh> Isn't that clear from the definition?
03:09:00 <Maxdamantus> Eh, that's not a nice statement.
03:09:49 <benneh> Wouldn't it use much the same logic as GHC uses when checking that a function is everywhere defined?
03:09:52 <Maxdamantus> benneh: only when incorporating additional logic.
03:38:07 <hjulle> If you are using type level logic, you have to make a type level case analysis. And in the case of instance declarations, the type is declared at the top, which means that every new "type case" needs a new declaration.
03:40:23 <Guest29924> !ciao
03:40:34 <Guest29924> !lista
03:51:23 <JonReed> Hi, I've never used literate Haskell. Is there any way to verify that code inside .lhs file is valid (compile a file somehow)?
03:52:17 <hjulle> I think you just compile it like a normal hs file (but I'm not sure).
03:56:04 <JonReed> hjulle: Just running `ghc file.lhs` throws "unlit: No definitions in file (perhaps you forgot the '>'s?)" :( . I'm trying to compile this file https://raw.githubusercontent.com/haskell-servant/servant/57afd80d5d19e4417377586eea9f8c79fb312274/doc/tutorial/Authentication.lhs
04:02:43 * hackagebot shakespeare 2.0.8 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.8 (MichaelSnoyman)
04:03:35 <MarcelineVQ> weird file, looks more like an .md than an .lhs, all the code is in ```haskell <code>``` blocks
04:03:45 <hjulle> There are different variants of the format and the compiler assumes it is ">"-style.
04:04:05 <Ravmm> ELO
04:05:00 <Ravmm> guyz
05:03:32 <Nuxular> Anyone in here with which I could discuss category theory?
05:03:37 <Nuxular> *whom
05:05:50 <Xandaros> Nuxular: there actually is a ##category-theory channel, might want to try there :)
05:05:54 <xa0> ask a question, or alternatively try ##category-theory
05:06:04 <Nuxular> cheers
05:08:23 <Xandaros> Looks like it's ##categorytheory
05:14:34 <hjulle> What's the thing with double #'s in channel names?
05:18:58 <Xandaros> hjulle: It's a freenode thing. Single # is for projects, while ## is for anything. Since category theory, math, etc, aren't open source projects, they have to use ##
05:19:18 <Xandaros> Single # can also be companies, etc, but it has to be a 'thing'
05:19:30 <Jinxit> isn't ## official?
05:20:11 <Jinxit> oh, other way around
05:20:24 <sqrt2> @pl perform' a b c = perform a b c >> return ()
05:20:25 <lambdabot> perform' = flip flip (return ()) . ((flip . ((>>) .)) .) . perform
05:20:31 <sqrt2> is there a nice way to write that?
05:21:14 <mniip> :t fmap (fmap (fmap (>> return ())))
05:21:15 <lambdabot> (Monad m, Functor f, Functor f1, Functor f2) => f (f1 (f2 (m a))) -> f (f1 (f2 (m ())))
05:21:54 <Xandaros> "perform' a b c = void $ perform a b c" is imo slightly better. Not much, though
05:22:11 <ggVGc> hm, how could I get this cast to be implicit? https://gist.github.com/948aa2fd40eacd69b90f
05:22:34 <Jinxit> isn't that just void . perform?
05:23:11 <lyxia> (fmap . fmap . fmap) void
05:23:30 <sqrt2> well, void makes it a little nicer, i didn't know about it
05:23:31 <sqrt2> thanks
05:23:46 <Xandaros> Jinxit: Yeah, that's a trap I hate to admit I still sometimes fall into...
05:24:32 <Xandaros> Hmm, I thought lens had something like (.::)... Maybe not
05:26:52 <Xandaros> sqrt2: Looks like there is a package 'composition' which has it. You could then use "perform' = void .:: perform"
05:27:11 <Xandaros> That said - you might be better off using pointful style here
05:27:50 <Xandaros> .:: is not widely known, so unless you can justify its use, it might be better not to obscure your code with it. That's my opinion, anyway :P
05:29:57 <seishun> let's see if I got this right... In MaybeT Writer, mzero stops writing, but in WriterT Maybe, mzero discards everything written so far, correct?
05:31:14 <Xandaros> :t mzero
05:31:15 <lambdabot> MonadPlus m => m a
05:32:21 <lyxia> seishun: yes
05:32:51 <Xandaros> Shouldn't it be the other way around? Without lifting, it would apply to the outermost layer, would it not?
05:33:49 <sqrt2> Xandaros: interesting, but i agree, i'd rather keep it easily readable, so i'll leave it pointful
05:35:05 <lyxia> Xandaros: the MonadPlus instance of WriterT lifts it from the base monad
05:36:35 <Xandaros> lyxia: Well, I don't get why they behave differently at all, then...
05:37:12 <Industrial> Hi. As an excercise to learn haskell by doing something 'practical' I'd like to create a program that does a `ls -AlFG`.
05:37:45 <Industrial> If I want to read all the nodes in a directory is this the API I'm looking for? http://hackage.haskell.org/package/unix-2.7.1.0/docs/System-Posix-Directory.html
05:38:09 <lyxia> @unmtl WriterT w Maybe a
05:38:09 <lambdabot> Maybe (a, w)
05:38:20 <lyxia> @unmtl MaybeT (Writer w) a
05:38:20 <lambdabot> (Maybe a, w)
05:38:42 <Industrial> (I want mine to have better ordering, have some padding / alignment, why not a table :P)
05:39:25 <lyxia> Xandaros: ^ in Maybe (a, w) getting a "Nothing" discards w, in (Maybe a, w) you get (Nothing, w).
05:39:56 <Xandaros> I see
05:40:28 <Industrial> Oh, I just found http://hackage.haskell.org/package/directory-1.2.5.1/docs/System-Directory.html#v:getDirectoryContents and http://hackage.haskell.org/package/directory-1.2.5.1/docs/System-Directory.html#v:listDirectory too :-)
05:41:14 <ertes> and both suck =/
05:41:27 <ertes> i constantly use the unix package just to get directory streaming
05:41:35 <seishun> > runWriterT $ tell "hello" >> lift Nothing >> tell "world"
05:41:37 <lambdabot>  Nothing
05:42:46 <obadz> If I pass the output of Control.Monad.ST.Lazy
05:42:54 <Industrial> ertes: Streaming is a more IO efficient approach? (it is in Node.js)
05:43:01 <obadz> .runST to another thread, don't I risk strange things happening?
05:43:05 <seishun> > runWriter $ runMaybeT $ tell "hello" >> mzero >> tell "world"
05:43:07 <lambdabot>      No instance for (Show w0)
05:43:07 <lambdabot>        arising from a use of ‘show_M23923295294807495579820’
05:43:07 <lambdabot>      The type variable ‘w0’ is ambiguous
05:43:11 <Industrial> ertes: But is the getDIrectoryContents easier to use? I'm pretty new to haskell :-)
05:43:54 <obadz> Control.Monad.ST.Lazy
05:44:05 <ertes> Industrial: in recursive directory traversal using getDirectoryContents (as opposed to streaming) makes a noticable memory and a slight speed difference
05:45:15 <ertes> Industrial: getDirectoryContents is easier to use (TM) =)
05:45:37 <obadz> I guess my question is: «Is Control.Monad.ST.Lazy threadsafe?»
05:45:44 <ertes> perhaps in the same way people find graphical file managers easier to use than a shell =)
05:46:50 <ertes> it wouldn't even be too bad, but unfortunately FilePath has been established to be String rather than something more appropriate
05:48:25 <deepfire> why doesn't the most specific element in the superclass chain, when taken as context, imply the rest of the chain?
05:48:50 <lyxia> doesn't it?
05:49:23 <lyxia> :t fmap :: Monad m => (a -> b) -> m a -> m b
05:49:24 <lambdabot> Monad m => (a -> b) -> m a -> m b
05:49:50 <deepfire> class Super a; class Super a ⇒ Left a; class Super a ⇒ Right a; instance Left a ⇒ Right a
05:51:05 <deepfire> the 'Left a' piece, when taken as context, complains that 'Super a' doesn't follow
05:51:31 <deepfire> this works, though: class Super a; class Super a ⇒ Left a; class Super a ⇒ Right a; instance (Super a, Left a) ⇒ Right a
05:52:11 <deepfire> FlexibleInstances/UndecidableInstances implied
05:53:40 <lyxia> can you show me an example where ghc complains
05:53:56 <deepfire> lass Super a; class Super a ⇒ Left a; class Super a ⇒ Right a; instance Left a ⇒ Right a
05:54:08 <deepfire> er, leading 'c' missing
05:54:22 <deepfire> let me put together a paste..
05:55:16 <lyxia> please do
05:56:53 <deepfire> http://lpaste.net/157035
05:58:09 <lyxia> it compiles here
05:58:22 <lyxia> ghc 7.10
05:58:36 <deepfire> hmm, ghc 8 regression then?
05:59:58 <deepfire> indeed..
06:00:17 <deepfire> curious
06:00:29 <lyxia> :)
06:01:19 <deepfire> and there I was digging in the haskell2010 standard.. : -)
06:02:15 <kvxl> hello
06:03:24 <deepfire> wondering if https://phabricator.haskell.org/D1594 is related..
06:05:58 <Xandaros> I'm actually surprised it compiles in 7.10. It is smarter than I gave it credit for
06:07:31 <obadz> ST monad question: is this code threadsafe ⇒ https://gist.github.com/obadz/655cadf9a7d9889d43c3
06:07:52 <obadz> in that if `l` gets deepseq'd on different threads, will readCounters be garbage?
06:08:07 <lyxia> It's not a hard check to do
06:08:15 <lyxia> Xandaros: ^
06:09:32 <Xandaros> lyxia: Yeah, I know. I'm not sure why it surprises me so - probably ran into a similar, yet unrelated, issue at some point where it didn't work
06:10:54 <lyxia> obadz: That looks safe. If the computation is duplicated, the references will be distinct in each one.
06:11:53 <Industrial> Hi. I'm starting out with haskell and I'm trying to get this argv (which is a [String] but might be empty) and get a directory name which defaults to "." but I'm not getting it right; https://gist.github.com/Industrial/6d71bdf5d46b2261317c/b31cd008087c3b4ba8e4bda392adc77b2a483ea8
06:12:53 <obadz> lyxia: how would they be distinct? it's the same l right?
06:13:15 <obadz> lyxia: runST only gets called once (at least in some cases)
06:13:51 <Xandaros> Industrial: Here's a hint: Do a pattern match on xs
06:14:26 <Industrial> oh, got it; https://gist.github.com/Industrial/6d71bdf5d46b2261317c/7001242a2842bccd8a348b0fd825ce7231acbf3f
06:14:31 <Xandaros> Industrial: You also need a more specific type signature or you'll run into issues
06:14:36 <obadz> lyxia: I can even print the first element of list in main thread before forking subsequent threads...
06:14:36 <Industrial> Xandaros: yeah I just figured that out :-D
06:14:41 <lyxia> obadz: I think if you have multiple threads demanding l at the same time, they will both do the same calculation
06:14:49 <Industrial> Xandaros: and the signature followed. THis is awesome!
06:15:13 <Xandaros> Industrial: Good! Now try to get rid of that ugly 'head'. It's safe in this case, but careless use of it will bite you in the behind at some point :P
06:15:22 <obadz> lyxia: I guess my issue is that while l is a pure value, it mutabes memory cells somehow
06:15:26 <obadz> mutates
06:15:37 <obadz> as it gets dethunked
06:16:19 <lyxia> obadz: Uh, the whole computation has to run once you force the result of runST
06:16:36 <lyxia> leaving no mutable cells
06:16:37 <obadz> lyxia: this is the lazy version of runST
06:16:49 <obadz> lyxia: the computation is infinite
06:17:01 <Industrial> Xandaros: it's xs !! 1
06:17:03 <Industrial> ?
06:17:11 <Xandaros> Industrial: Same problem
06:17:42 <Xandaros> In your pattern match, you can actually require that the list has at least one element
06:17:43 <lyxia> obadz: Aaah I see I missed that
06:18:46 <Industrial> Hmm, looking at the behaviour of the ls program, it takes many paths; so I should support that
06:20:20 <Xandaros> Industrial: http://hastebin.com/ukebarayih.hs
06:20:23 <mikail_> Hi
06:21:27 <mikail_> In Haskell we have the iterate function which allows us to call a function n times so that we can the following behaviour: f(f(f(a))) for example.
06:21:43 * obadz has to leave but if someone answers my question I will get it later
06:22:08 <Industrial> Xandaros: right.
06:22:37 <mikail_> Is there an equivaelent function to iterate which works on function with more than one parameter? Or can I use iterate for those type of functions as well?
06:23:12 <hpc> what would it expand to?
06:23:16 <Xandaros> mikail_: How would that work? A function can only return one value - how would you pass it on?
06:23:43 <mikail_> In Scalaz you have the Endo typeclass which can do this
06:23:52 <deepfire> lyxia, I have looked through the bugs on the GHC 8 status page, and, to my limited understanding, found nothing related
06:23:56 <mikail_> but I was wondering if it can be done in Haskell
06:24:15 <mikail_> I have a problem I am dealing with at the moment and it would fit nicely
06:24:16 <deepfire> lyxia: I guess it means this should be posted on ghc-devs?
06:24:36 <lyxia> deepfire: I agree
06:25:04 <hjulle> mikail_: But what would it expand to?
06:25:35 <mikail_> From your comments, Haskell is right here
06:26:04 <mikail_> Scalaz seems to be relying on an external environment to get it work
06:26:21 <deepfire> lyxia: does "GHC 8 superclass chain constraint regression" sound like a topic that is sufficiently descriptive of the problem?
06:26:24 <Industrial> Hmm. I'm getting a `Expected type: IO () Actual type: IO [()]` at https://gist.github.com/Industrial/6d71bdf5d46b2261317c/70213ef9d84b91daaebc1a25527e66323559f14f
06:26:32 <mikail_> I just need to bounce the idea 
06:26:38 <mikail_> *needed*
06:26:44 <mikail_> point taken
06:26:51 <Industrial> I'm not sure exactly how to print a [String] :-)
06:26:54 <hjulle> mikail_: It is still unclear what you were asking for?
06:27:17 <mikail_> to clarify
06:27:25 <lyxia> deepfire: that sounds okay to me, but I'm not a GHC hacker
06:27:26 <mikail_> I have a function with more than one argument
06:27:45 <mikail_> one of the arguments needs to be updated with what the function returns in a loop scenario
06:28:01 <mikail_> this code works:
06:28:03 <Xandaros> Industrial: You can use void to discard a monadic valua. (In this particular case, turn IO [()] into IO () - In general it replaces Monad m => m a with m () )
06:28:04 <mikail_> loop gen turns price rate vol ts 
06:28:06 <mikail_>    = foldr (\rnd p -> priceJump p rate vol ts rnd) price <$> 
06:28:07 <mikail_>      replicateM turns (normal 0 1 gen)  
06:28:08 <lyxia> Industrial: mapM_
06:28:14 <Xandaros> Or mapM_
06:28:16 <Xandaros> :D
06:28:19 <lyxia> :D
06:28:38 <mikail_> that priceJump function takes as it's first parameter the initial price
06:28:40 <ertes> you really want mapM_ here rather than void =)
06:29:11 <mikail_> after each loop the price (p parameter) must be updated with the new price returned by priceJump
06:29:38 <bdesham> Is there any way to see which licenses are most popular for Hackage packages?
06:29:40 <Xandaros> Yes, I didn't think of mapM_, it basically has void built-in
06:29:41 <mikail_> I thought if I could find a function which handles that abstraction already (one which I am not aware of) then that would save me some code
06:29:41 <hjulle> > let f a = a/2 in iterate f 4 !! 2
06:29:43 <lambdabot>  1.0
06:30:12 <bdesham> I'm thinking about releasing something and I figure I should use the same license as everyone else, if one is standard
06:31:13 <ertes> bdesham: the most common license is BSD3, but there are exceptions
06:31:16 <Xandaros> bdesham: Just use the one you like the most. My personal favourite is the BSD 2-clause license - Just use what you like
06:31:33 <mikail_> Could someone explain Kleisli compositions in layman terms?
06:31:36 <koomi> mikail_: you can uncurry and return a tuple
06:31:57 <ertes> bdesham: i nowadays use the apache license 2 and some people go as far as to use a copyleft license
06:32:05 <ClaudiusMaximus> bdesham: the default license in `cabal init` is BSD3, but there are plenty of other options
06:32:17 <hjulle> mikail_: Just use a let to remove all the static argunts of the function
06:32:27 <llvem> is anyone doing much C FFI work?
06:32:34 <mikail_> @hjulle, good point
06:32:34 <lambdabot> Unknown command, try @list
06:33:11 <llvem> i'm wondering for data with some structure, do people break down values into arrays and individual variables for marshalling
06:33:23 <ertes> bdesham: fsf.org is a great resource to learn about the strengths and weaknesses of each license (and the reason why i switched from BSD3 to AL2)
06:33:45 <llvem> or is there a better way to pass struct - like things in and out of C?
06:35:28 <bdesham> ertes Xandaros ClaudiusMaximus Thanks! I used to participate in the Clojure community, where *everyone* used the Eclipse Public License, so I thought Haskell might have something similar
06:35:40 <bdesham> time to read about some licenses...
06:36:11 <ertes> bdesham: yeah, we have BSD3 as the most common license, but notable exceptions include pandoc, which is GPL-licensed
06:36:23 <Industrial> Xandaros, lyxia; so mapM_ is specifically for causing side effects by creating monadic actions of each element in a list?
06:37:05 <hjulle> Industrial: Yes
06:37:35 <bdesham> ertes: GPL isn't even on my list... I'm not that hardcore ;-)
06:37:38 <Industrial> if the _ version doesn't care about the results, so you can log with it for example, what kind of case would you use mapM in instead of mapM_ ?
06:37:46 <Xandaros> :t mapM_
06:37:47 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
06:38:03 <Gurkenglas> mikail_, if you use priceJump only there and defined it yourself, I recommend moving the rnd and p arguments to the end so you can do eta reduction (removing argument names from the lambda and the expression)
06:38:10 <ertes> bdesham: i like the GPL very much, and in a perfect world everybody would use it, but unfortunately we don't live in a perfect world =)
06:38:30 <Xandaros> Industrial: Sometimes you do IO actions where you want to use what they return. In that case you use mapM, which collects the results in a list
06:38:55 <ertes> bdesham: GPL is actually appropriate for some haskell packages, notably application packages (as opposed to libraries)
06:39:10 <Industrial> okay
06:39:15 <mikail_> Thanks Gurkenglas 
06:39:35 <hjulle> ertes: In a perfect world, we wouldn't need GPL. All software would be free by default anyways. ;)
06:40:13 <quchen> Industrial: mapM getUserById [1..100]
06:40:14 <hpc> in a perfect world all software would be already written and we could just go home ;)
06:40:37 <maerwald> you can use LGPL for libraries
06:40:44 <hjulle> hpc: No! I like programming. :(
06:40:51 <ggole__> That wouldn't be a perfect world: there wouldn't be any programming to do :(
06:41:03 <ertes> hpc: that wouldn't be a perfect world for me…  people already tell me: "this here program does that, why are you writing your own?!"
06:41:25 <ggole__> Although you could just do it again for the fun of it, I suppose.
06:42:09 <Xandaros> ertes: My usual response to that is "because I can". Could also call it practice, I guess
06:43:39 <ertes> Xandaros: not to people you want to work with
06:44:05 <ertes> my usual answer is the truth: it's more economical
06:44:13 <quchen> Your dystopian perfect worlds are disturbing :-|
06:44:34 <llvem> ggole__ welcome to the world of python/R/javascript
06:44:36 <maerwald> they are lazy and don't want to work :P
06:45:24 <hjulle> quchen: Is my perfect world dystopian as well?
06:45:47 <deepfire> ertes, do you still work on the netwire successor?
06:46:05 <Xandaros> ertes: I say that to people I want to work with, too. They usually understand :P
06:47:12 <ertes> deepfire: haven't worked on it for a long time, but recently i picked it up again along with other old projects
06:48:02 <deepfire> ertes, very nice to hear!
06:49:54 <roelof> Does anyone know if I can work with the snap framework and stack ? 
06:50:35 <ertes> deepfire: don't hold your breath though…  without use cases it's really hard to write a library…  which is why i'm writing it along with something useful: a sound engine
06:52:14 <llvem> roleof it should work
06:52:55 <seishun> feels weird to write "mzero" to emulate an early return
06:54:02 <roelof> llvem:  oke, normally I would do stack new template templatename but I cannot find a snap template for stack 
06:55:24 <llvem> roleof i would just use a basic template and add what you need to the cabal file
06:58:12 <hjulle> seishun: Hwy?
06:58:25 <ertes> seishun: as an early return it's fine…  as an early 'return' it isn't =)
06:58:54 <hjulle> *Why
06:59:01 <ertes> seishun: there are even crazier ways to get an 'abort':  for example i sometimes use ContT
06:59:19 <seishun> because it's not clear what it does
06:59:22 <seishun> :t empty
06:59:23 <lambdabot> Alternative f => f a
06:59:29 <seishun> :t mzero
06:59:30 <lambdabot> MonadPlus m => m a
06:59:58 <seishun> > empty :: Maybe String
07:00:00 <lambdabot>  Nothing
07:00:07 <seishun> > mzero :: Maybe String
07:00:08 <lambdabot>  Nothing
07:00:20 <seishun> empty seems better
07:00:21 <hjulle> You can always alias it to a new name to make your code clearer.
07:00:48 <hjulle> But yes, empty seems better
07:01:12 <deepfire> ertes, is it possible to follow your progress somewhere?
07:02:16 <Xandaros> :t empty
07:02:17 <lambdabot> Alternative f => f a
07:03:14 <Xandaros> Hmm... is there any case where Alternative and MonadPlus have different semantics? Or where only one instance exists, but not the other? (Assuming a Monad, since MonadPlus seems to imply it requires a monad... for some reason...)
07:03:57 <seishun> there's also
07:04:01 <seishun> :t mempty
07:04:02 <lambdabot> Monoid a => a
07:07:43 <mauke> > mempty :: Maybe String
07:07:45 <lambdabot>  Nothing
07:07:50 * hackagebot oi 0.4.0.2 - Library for purely functional lazy interactions with the outer world.  https://hackage.haskell.org/package/oi-0.4.0.2 (NobuoYamashita)
07:07:56 <mauke> how weird
07:09:25 <ertes> deepfire: it's on <http://hub.darcs.net/esz/wires>, but in the last few days i've rewritten it almost completely…  i'll replace the repo with the new version, because it's pretty much a new project now
07:09:43 <ertes> the FreeT-based Program monad is gone and is instead built into Wire itself
07:10:45 <ertes> deepfire: it's the exact-time semantics stuff i've talked about…  event combinators aren't ad-hoc any longer, but a written in a special monadic DSL
07:11:22 <ertes> deepfire: some auxiliary projects have already made it on hackage, most notably the 'timelike' library
07:12:20 <lyxia> Xandaros: perhaps it's something that remains from pre-AMP times
07:13:47 <ertes> seishun: what 'empty' does depends on what (<|>) does (similar for MonadPlus)
07:14:08 <ertes> seishun: it's defined as the identity of (<|>)…  you don't get to choose it, it follows from (<|>)
07:16:13 <deepfire> ertes, thank you!
07:19:03 <Gurkenglas> Must empty be a multiplicative zero for <*>?
07:19:31 <ertes> i really hope that timelike will find users and contributors…  it solves simple time arithmetic problems that are surprisingly difficult to do with 'time' and the like:  "go to the start of the upcoming monday"
07:21:35 <quchen> Gurkenglas: I don't think it's reqired, would love to learn otherwise
07:22:28 <quchen> Gurkenglas: It's maybe implied in a very strange way by "Alternative = MonadPlus" and the MonadPlus laws with >>=
07:23:02 <Gurkenglas> Any reason not to just have the Alternative laws be the Ring axioms?
07:25:08 <ertes> Gurkenglas: not sure if (<|>) always distributes
07:26:11 <ertes> also you probably want the semiring laws instead, otherwise Applicative would need "inverses"
07:26:32 <Gurkenglas> right, semiring
07:26:55 <ertes> Gurkenglas: interesting case you may want to research:  the different semantics for Either
07:27:33 <Gurkenglas> Does distribute for Maybe, doesn't for [], doesn't for State s Maybe
07:27:42 <Gurkenglas> Either e isn't an Alternative
07:27:52 <Gurkenglas> *StateT s Maybe
07:27:54 <ertes> left-catch semantics:  instance Applicative (Either e); instance (SomeArbitraryDefault e) => Alternative (Either e)
07:28:00 <Xandaros> Intuitively, I'd say that "a <|> b <|> a === a <|> b" - does distributing make any sense, then?
07:28:17 <ertes> left-distribute semantics:  instance (Monoid e) => Applicative (Either e); instance (Monoid e) => Alternative (Either e)
07:29:40 <ertes> Xandaros:
07:29:42 <Gurkenglas> Xandaros, no, for <|> = ++
07:29:55 <ertes> > ("abc" <|> "def" <|> "ghi", "abc" <|> "def")
07:29:56 <lambdabot>  ("abcdefghi","abcdef")
07:30:12 <Xandaros> Interesting
07:30:29 <Xandaros> How is Alternative different from Monoid, then?
07:30:50 <ertes> Xandaros: it isn't…  it's Monoid1 in the same way Ord1 is Ord for type constructors
07:31:20 <Xandaros> And I suppose MonadPlus is also like that
07:31:33 <ertes> MonadPlus is a historical accident =)
07:33:57 <Xandaros> In the case of Maybe, however, Alternative and Monoid have different semantics. They follow my intuition about those typeclasses (well, Monoid Maybe is debatable), I wish there was a law that states "a <|> b <|> a === a <|> b" ...
07:34:58 <ertes> Xandaros: that would make Alternative [] impossible
07:35:07 <ertes> and i like the Monoid instance of Maybe a lot
07:35:14 <Gurkenglas> That doesn't even work for MaybeT State
07:35:32 <ertes> > (Just "abc" <> Nothing, Just "abc" <> Just "def")
07:35:34 <lambdabot>  (Just "abc",Just "abcdef")
07:35:41 <lyxia> also that would exclude pretty much every type that represent some kind of effect
07:36:06 <Xandaros> ertes: It would make Alternative [] impossible. There's no point to that instance anyway, since you have Monoid [] already, which does the same thing
07:36:36 <ertes> Xandaros: Alternative and Monoid aren't *quite* the same…  they have the same laws
07:36:43 <lyxia> but Alternative is nice to write non-deterministic programs in a generic way
07:36:45 <ertes> but Monoid allows a lot more semantics than Alternative
07:37:00 <ertes> for example the Monoid instance for Maybe would be impossible with Alternative
07:37:04 <Gurkenglas> Xandaros, MaybeT! :(
07:37:27 <ertes> which is why we have both…  they are both useful, and there is no need for them to be forced equal
07:37:59 <ertes> we even have Monoid2…  it's called ArrowPlus and ArrowZero
07:38:47 <ertes> (that one is actually more sensibly designed:  ArrowPlus is Semigroup2, ArrowZero is Monoid2)
07:39:04 <Xandaros> ertes: I didn't say they are the same, I said Alternative [] and Monoid [] are the same, so nothing is lostby making Alternative [] impossible :P
07:39:36 <ertes> Xandaros: never fixate on specific examples for abstractions as generic as these
07:40:00 <Xandaros> I see <|> as some kind of "or". It selects the first one that 'works'. Alternative [] goes against that. My intuition is obviously wrong here, but why choose an operator like that, then...
07:40:28 <ertes> Xandaros: i see it as "plus"
07:40:30 <Xandaros> ertes: It was a response to you saying it makes Alternative [] impossible
07:41:09 <Xandaros> ertes: And that's what I consider <>
07:41:41 <Xandaros> > Just "a" <|> just "b"
07:41:43 <lambdabot>      Not in scope: ‘just’
07:41:43 <lambdabot>      Perhaps you meant data constructor ‘Just’ (imported from Data.Maybe)
07:41:45 <ertes> Xandaros: they are both "plus" for a very abstract plus
07:41:48 <Xandaros> > Just "a" <|> Just "b"
07:41:49 <lambdabot>  Just "a"
07:42:01 <hjulle> Xandaros: I think the analogy works perfectly for [] as well. It selects the first that works. (or rather, a list of all that works)
07:42:13 <Xandaros> > Just "a" <> Just "b"
07:42:15 <lambdabot>  Just "ab"
07:42:52 <lyxia> [a] <|> [b] is a non-deterministic computation that returns either a or b.
07:43:21 <Xandaros> > "asd" <|> "fgh"
07:43:22 <lambdabot>  "asdfgh"
07:43:36 <ertes> Xandaros: consider even the simple case of reader monads:  instance (Monoid a) => Monoid (e -> a)
07:43:48 <ertes> there is not a single Alternative instance you can write
07:44:06 <ertes> so Monoid and Alternative are really different things after all
07:44:49 <Xandaros> If they both have the same laws, why can't I write an Alternative instance? (<|>) = (<>), empty = mempty
07:45:01 <ertes> Xandaros: that's a type error
07:45:23 <ertes> you couldn't write this one:  instance Monoid (e -> a)
07:47:07 <Xandaros> I don't get it
07:48:00 <ph88> can a functor only hold values, or are there also functors for functions ?
07:48:19 <ertes> Xandaros: your 'empty' would need this type:  empty :: e -> a
07:48:31 <ertes> but mempty has this one:  mempty :: (Monoid a) => e -> a
07:48:40 <Xandaros> ph88: A functor 'holding values' is just an analogy. A function itself is a Functor
07:49:42 <hjulle> In haskell, functions are also values.
07:49:50 <ph88> literals
07:50:00 <ertes> ph88: a functor is anything that has a type argument that allows mapping to change that type argument, as long as you have a function that can actually perform the map
07:50:10 <cocreature> ph88: Proxy is also a functor and doesn’t hold anything
07:50:23 <ertes> ph88: fmap :: (a -> b) -> F a -> F b  -- "gimme a function from a -> b, and i will change F a into F b"
07:50:50 <ertes> ph88: containers are the obvious examples, but there are not-so-obvious ones that don't look like containers
07:51:11 <ph88> ertes, so a and b are the Functors, but (a -> b) is just a function and not a Functor?
07:51:22 <ertes> ph88: F is the functor
07:51:32 <ph88> yes i mean  F a   and    F b
07:51:40 <ertes> ph88: nope, F
07:51:42 <ph88> type signature doesn't say  F (a -> b)
07:51:44 <ertes> F itself is the functor
07:52:03 <Xandaros> F is the functor, F a is a value "in" the Functor
07:52:05 <ph88> F (a -> b) is that common ?
07:52:15 <ertes> ph88: yeah, actually it is
07:52:26 <ertes> ph88: [a -> b] is a list of functions of type a -> b
07:52:36 <ph88> how come that every function is a Functor ?
07:52:43 <Xandaros> ph88: Chances are, if you work a lot with F (a -> b), you want F to be an Applicative
07:52:48 <ertes> ph88: functions are values, so they can't be functors
07:53:08 <ertes> ph88: a functor is always a type constructor…  always, no exceptions
07:53:19 <ph88> Xandaros, just said "a function itself is a Functor", ertes say "functions are values, so they can't be functors"  o_O
07:53:28 <ph88> oh i see
07:53:36 <ertes> ph88: the terminilogy is a bit delicate there =)
07:53:43 <Xandaros> "(->) a" is a Functor, "(->) a b" is a value
07:53:47 <Xandaros> Sorry :P
07:53:52 <ph88> maybe if you think of a type constructor as a value constructing function  (personally i don't like to see those as functions)
07:54:14 <ertes> ph88: yeah, it's perfectly fine to view type constructors as type-level functions
07:54:20 <ertes> because in fact they are exactly that
07:54:31 <ph88> i don't like to think of them that way
07:54:36 <ph88> it's too confusing at first anyway
07:55:09 <ertes> then don't…  think of them as things constructing concrete types as soon as you give them a type:  Maybe takes a type and gives you a type
07:55:11 <ph88> which functors don't look like containers ?
07:55:29 <ertes> let's give it a type:  Maybe Integer  -- now you have a concrete type that holds values such as Just 3
07:55:38 <ph88> i know
07:55:41 <ertes> ph88: (->) e
07:55:56 <hjulle> IO
07:55:57 <ph88> where is the F   in  (->) e   ?
07:56:09 <ertes> ph88: that *is* the F
07:56:10 <Xandaros> cocreature mentioned Proxy earlier. I'd say IO also doesn't look a lot like a container, but I think the container analogy is actually very good for Functor, so with a bit of imagination you can probably always find a way too look at them like a container
07:56:12 <hjulle> F = (->) e
07:56:45 <ph88> what does the  (->) e   functor do ?
07:57:06 <ertes> i agree with Xandaros…  in fact type algebra probably always allows you to come up with an isomorphic type that does look like a container
07:57:26 <ertes> ph88: take functions of type 'e -> a' and rewrite that: (->) e a
07:57:44 <ertes> 'e -> a' and '(->) e a' are the same type, just written with different fixity
07:58:06 <Xandaros> Similar to how "5 + 6" is the same as "(+) 5 6"
07:58:16 <ph88> why would you need that functor ?
07:58:20 <ertes> if you have a function of type a -> b, you can go from 'e -> a' to 'e -> b'
07:58:40 <ph88> eh what's e then for example ?
07:58:44 <ertes> ph88: you probably don't need it that often as a functor, but it is quite a useful more-than-just-functor =)
07:58:57 <ertes> ph88: that more-than-just-functor requires it to be a functor anyway, so there you go
07:59:08 <Xandaros> lol
07:59:21 <hjulle> e is the argument function. It can be anything. 
07:59:23 <ertes> ph88: any type really…  the 'e' stands for "environment" for me
07:59:36 <hjulle> *argument of the function
07:59:37 <Xandaros> fmap is quite useful, even when dealing with the more-than-just-functor :P
07:59:58 <ph88> thanks a lot guys, i'll be back later .. i have a train to catch =)
08:00:00 <ertes> ph88: you can interpret a function 'e -> a' as a value of type 'a' that depends on an environment of type 'e'
08:00:05 <ertes> have fun =)
08:00:45 <Xandaros> There are so many things you can interpret differently in Haskell
08:01:07 <Xandaros> "fmap :: (a -> b) -> (f a -> f b)" was a relevation for me
08:01:23 <Xandaros> *revelation
08:02:02 <ertes> yeah, another one was placing the type signatures of 'fmap', (<*>), (=<<) and 'extend' underneath each other
08:02:41 <Xandaros> :t extend
08:02:42 <lambdabot> Not in scope: ‘extend’
08:02:43 <ertes> with some alignment you see the pattern
08:02:52 <ertes> Xandaros: see the 'comonad' package
08:02:56 <Xandaros> OH
08:03:00 <Xandaros> Yes
08:03:15 <ertes> a.k.a. (<<=)
08:03:20 <ertes> (such an ugly operator)
08:03:53 <Xandaros> That's how I explained fmap, (<*>) and (>>=) to my students. Maybe I should've used (=<<) a bit more, but I wanted them to use (>>=)
08:04:51 <Gurkenglas> @let import Control.Comonad
08:04:52 <lambdabot>  Defined.
08:04:55 <ertes> Xandaros: i start with explaining (>>=) as an ad-hoc IO combinator and introduce (=<<) very quickly
08:04:58 <Gurkenglas> :t extend
08:04:59 <lambdabot> Comonad w => (w a -> b) -> w a -> w b
08:05:06 <cocreature> I probably use =<< more often than >>=, for the latter I mostly just use do notation
08:05:56 <seishun> do you think using `guard False` would be better than `mzero`?
08:05:56 <hjulle> The moment when you realise that (fmap . fmap . fmap) works. 
08:06:09 <DrSyzygy> …of course it works, why shouldn't it?
08:06:41 <ertes> seishun: no…  unnecessary indirection (and possibly computation)
08:06:46 <Xandaros> The funny thing is, I sometimes use (>>=) within do-blocks. "... <- ... >>= ..." is not all that uncommon in my code
08:07:03 <hjulle> DrSyzygy: Not that it wouldn't work, just that I haven't thought about it.
08:07:50 <Xandaros> You can even do (.).(.).(.)
08:07:56 <hjulle> It's the whole "fmap :: (a -> b) -> (f a -> f b)" revelation 
08:08:03 <Xandaros> It's funny how easily these things compose
08:08:22 <hjulle> exactly
08:08:32 <ertes> i don't know…  after so many years i still prefer to use points there
08:08:53 <maerwald> Xandaros: yeah, I do that too, but I'm sometimes worried that it confuses the reader
08:09:07 <ertes> maerwald: it does!
08:09:08 <maerwald> (wrt >>= within do-blocks)
08:09:20 <ertes> oh, nevermind =)
08:09:33 <hjulle> Xandaros: Isn't (.).(.)  = fmap . fmap?
08:09:39 <maerwald> but if you do heavy GUI code, it's hard to not do that with all those IO bindings
08:09:40 <ertes> no, that one isn't…  i do that quite a lot
08:09:48 <Xandaros> ertes: I'd never actually use that in code :P
08:09:53 <ertes> xs <- getArgs >>= mapM f
08:09:58 <Xandaros> hjulle: A more specific version, but yes, I think so
08:10:08 <ertes> perfectly readable IMO
08:10:35 <DrSyzygy> hjulle: I came to Haskell from category theory and algebra. From that direction, composability of fmap is "just" functor composition, which is "just" function composition, which really should hold for anything to be interesting. :-)
08:12:27 <seishun> is there a better way to write `maybe (return ()) (\val -> do ...) myMaybeVal`?
08:12:55 <hjulle> Using things like (fmap.fmap) feels a lot like using lenses (and they have almost the same type).
08:14:04 <lyxia> the difference is that fmap is unidirectional
08:14:24 <lyxia> seishun: mapM_
08:15:06 <Xandaros> I do actually use lens - it can be quite nice
08:16:01 <ertes> lens is useful, if you use it wisely =)
08:16:08 <ertes> like magic
08:16:51 <maerwald> I don't want people to learn a new DSL just to avoid a few accessor functions I have to write myself
08:16:59 <maerwald> that is... if those are a few
08:17:05 <hjulle> I like how traverse is a Traversal without being written for it.
08:17:14 <ertes> maerwald: most of my optics are traversals or "interesting" lenses
08:17:27 <ertes> accessor lenses not so much
08:17:34 <maerwald> which also means less people will understand certain parts of my code
08:18:00 <ertes> for example i'd write rot13 with this one:  letter :: Traversal' Char Int
08:18:47 <Xandaros> I see lens as a commitment. I either use it everywhere, throughout the whole project and require people to be familiar with it, or not at all. I wouldn't use lens if I only need it in a few cases
08:19:26 <maerwald> yeah
08:19:43 <ertes> Xandaros: that seems overly strict…  you don't use free monads everywhere out of commitment, but where they actually add something
08:19:48 <hjulle> ertes: Isn't that an improper traversal?
08:20:06 <maerwald> ertes: I wouldn't really consider that the same thing in terms of commitment
08:20:10 <ertes> hjulle: nope, but it would be an improper lens
08:20:20 <ertes> hjulle: or maybe i've overlooked something
08:21:04 <Xandaros> ertes: I don't think that's the same thing... Lens can be used just about everywhere, you just usually choose not to do it, because you don't gain much. If you lensify your data structures, however, you kinda have to
08:21:09 <hjulle> Int /= N(26)
08:21:38 <Xandaros> Luckily, my main use case for lens - duplicate record fields - will soon be gone
08:21:39 <ertes> Xandaros: that's the difference…  i commonly don't lensify my data structures completely, but i do write lenses for interesting things
08:22:05 <ertes> Xandaros: and those usually turn out not to be lenses, but rather traversals
08:22:26 <ertes> prisms in some rare cases
08:25:02 <ertes> this one i wrote for a workshop i gave:  http://lpaste.net/155543
08:26:17 <ertes> interesting observation: hlint recognises (c >= 'A' && c <= 'Z') as 'isAsciiUpper c' =)
08:26:41 <mniip> ertes, looks like a bunch of unlawful traversal
08:26:43 <mniip> s
08:27:03 <ertes> ok, now that two people have said that, i'm going to recheck the laws
08:28:29 <mniip> ertes, does 'f pure = pure' ?
08:29:42 <seishun> is there a standard function to convert [Maybe a] to [a], throwing out Nothings?
08:30:11 <hpc> :t catMaybes
08:30:12 <lambdabot> [Maybe a] -> [a]
08:30:13 <mniip> :t catMaybes
08:30:14 <lambdabot> [Maybe a] -> [a]
08:30:17 <hpc> lol
08:30:19 <ph88> about the  (->) e   Functor .. is it possible that it will change your value inside the Functor based on the environment variable?
08:30:32 <seishun> awesome
08:30:53 <hpc> seishun: btw, you can search for functions by type: https://www.haskell.org/hoogle/?hoogle=[Maybe+a]+-%3E+[a]
08:31:13 <hpc> or if hoogle can't find it, http://hayoo.fh-wedel.de/
08:31:19 <hjulle> ph88: Look at the type of fmap and try to answer yourself.
08:31:22 <seishun> cool
08:31:52 <ertes> mniip: empirically yes
08:31:57 <ertes> for all three
08:32:21 <ph88> hjulle, i think fmap only comes in later
08:32:37 <ph88> i'm still at the "F a" part
08:32:48 <hjulle> fmap is in the definition of Functor
08:32:49 <ertes> mniip: and it seems sensible, too…  view Char as this:  data Char = Upper WordUpTo26 | Lower WordUpTo26 | SomethingElseOtherThanUpperOrLower Int
08:32:59 <ertes> that's how i figured it would be a traversal
08:33:16 * hackagebot aeson-compat 0.3.2.0 - Compatibility layer for aeson  https://hackage.haskell.org/package/aeson-compat-0.3.2.0 (phadej)
08:33:18 <hjulle> ph88: In that case you can't answer questions about the behaviour
08:33:33 <ph88> behaviour of what ?
08:36:00 <hjulle> What do you mean by "change your value inside the Functor"?
08:36:34 <ertes> mniip: leftOrRight :: Traversal (Either a a) (Either b b) a b  -- is that an improper traversal?
08:36:54 <Xandaros> ph88: I suggest you ignore (->) e for now. Maybe is the perfect functor to play around with at first. :)
08:37:24 <ph88> hjulle, i mean first it was  3  and now it's  7
08:38:16 <ertes> ph88: i couldn't finish earlier…  '(->) e' is a nice non-trivial functor, so i believe it's fine to try to understand it now =)
08:38:24 <ertes> ph88: but do you understand how the Maybe functor works?
08:39:07 <ph88> yes
08:39:12 <ertes> ph88: did you reinvent Maybe along with a working Functor instance?
08:39:23 <ph88> possibly
08:39:29 <ph88> likely
08:39:47 <ertes> ph88: did you write your own MyMaybe type?
08:40:32 <maybefbi> what is the best crypto library in haskell?
08:40:35 <ertes> ("reinvent" is meant positively here…  in haskell reinventing is a great way to understand things)
08:40:58 <ertes> maybefbi: there are a few libraries for different purposes…  for example cryptohash is a great library for hashing
08:40:59 <Algorythmis> @undef
08:40:59 <lambdabot> Undefined.
08:41:03 <ph88> ertes, i don't remember exactly, but i think the point is that you have a type that can be of two choices, one of which containing a value ..
08:41:05 <Algorythmis> @let x = 4
08:41:07 <lambdabot>  Defined.
08:41:29 <ertes> ph88: then perhaps it's time to revisit that exercise now =)
08:41:36 <ertes> @undef
08:41:36 <lambdabot> Undefined.
08:42:05 <maybefbi> ertes, ok
08:42:46 <maybefbi> ertes, the last time i checked some crypto library in haskell was getting its ECDSA k value from a seed made from the wall clock time.
08:42:49 <ertes> maybefbi: there is no one-to-rule-them-all library though…  in fact we go as far as to have separate libraries for certain algorithms
08:43:04 <ph88> ertes, i don't want to start over at this point, i like to know the non-trivial  (->) e   Functor
08:43:28 <ertes> maybefbi: yeah, there are some unfortunate things to be found on hackage, but you can safely go with the libraries that are widely used
08:43:45 <ertes> ph88: are you confident that you could do it easily, if you would?
08:43:54 <deepfire> sometimes I wish there was a more reliable way to choose on Hackage..
08:43:56 <maybefbi> ertes, ok
08:45:12 <puregreen> deepfire: I'm making a thing for that, stay tuned :)
08:45:14 <ertes> maybefbi: if the library was written by thomas debuisson or vincent hanquez, then it's a safe choice
08:45:32 <ph88> ertes, yes easy .. although in particular with haskell it's difficult to know if people are talking about the same thing
08:45:50 <ertes> maybefbi: they produce and maintain high-quality crypto libraries for haskell
08:46:28 <deepfire> puregreen: : -)
08:46:56 <ertes> ph88: really just your own custom Maybe type along with a Functor instance =)
08:47:12 <ertes> ph88: i.e. pretend that Maybe isn't predefined and define it yourself
08:47:21 <ertes> that shouldn't lead to confusion
08:48:16 <ertes> ph88: now [] is the functor of lists of things, Maybe is the functor of optional things, '(->) e' is the functor of things that depend on an environment of type 'e'
08:48:39 <ertes> ph88: does this completely imprecise prose make sense so far?
08:49:38 <ph88> yes it makes perfectly sense
08:49:50 <ertes> ph88: exercise:  if (F = (->) e), then what's the type of fmap?  fmap :: (a -> b) -> F a -> F b
08:50:04 <ph88> only thing is that what is  "environment of type 'e'"
08:50:33 <ertes> ph88: replace "environment" by "value"…  i'm just giving some intuitive meaning to that generic term "value"
08:52:08 <ph88> (a -> b) -> (e -> a) -> (e -> b)   ?
08:52:45 <ertes> ph88: exactly…  now that type signature says:  give me a function from 'a' to 'b' and a function from 'e' to 'a', and i'll give you a function from 'e' to 'b'
08:52:48 <ertes> does that sound familiar?
08:54:37 <ph88> now i have to think hard
08:54:54 <ph88> is this going in the direction of applicatives ?
08:55:13 <ertes> ph88: nope, just write that function:  myFmap :: (a -> b) -> (e -> a) -> e -> b
08:55:29 <ph88> well i just did? o_O
08:55:38 <ph88> oh you mean the implementation
08:55:40 <ertes> once you have an implementation that works, it will be perfectly obvious what myFmap is =)
08:55:42 <ertes> yeah
08:56:53 <ph88> .
08:57:24 <ertes> hmm?
08:57:31 <ph88> that's the implementation :P
08:58:04 <ertes> ah, (.)…  correct =)
08:58:19 <ertes> so fmap for what we call *reader functors* is just function composition
08:58:26 <ertes> let's see if it works:
08:58:30 <ph88> ok so the Functor is not a wrapping type, but a "wrapping function"  ?
08:58:37 <ertes> > fmap (^3) (+ 5) 17
08:58:39 <lambdabot>  10648
08:58:47 <ertes> > (17 + 5)^3
08:58:49 <lambdabot>  10648
08:59:09 <ertes> the functor is '(->) e' in this case
08:59:45 <ertes> it may not make sense instantly, so let me throw a seemingly weird type alias at you:
08:59:50 <ertes> type Table = (->)
09:00:02 <ph88> ok and now back to the question i came in with:  about the  (->) e   Functor .. is it possible that it will change your value inside the Functor based on the environment variable?
09:01:32 <ertes> let's see if you can answer it yourself…  did the alias make any sense?
09:01:49 <ertes> with the alias you would write:  fmap :: (a -> b) -> Table e a -> Table e b
09:02:30 <ph88> if that +5 is your environment  then your value 17 will change by   17+5  before you apply function the (^3) to your functor
09:02:31 <ph88> so i take it as yes ^^
09:03:05 <ertes> (+ 5) is a value that depends on an environment:  in (+ 5) 7, the environment is 7
09:03:26 <ertes> > (\env -> env + 5) 7
09:03:27 <lambdabot>  12
09:03:47 <ph88> oh yes the other way around
09:03:57 <ph88> 17 is the environment for the +5 functor
09:04:05 <ertes> and again:  the *functor* is a type-level thing…  values aren't functors
09:04:08 <hjulle> I would say that "a functor is a type level function that as an associated function fmap..."
09:04:40 <ertes> ph88: do you see how "function" and "table" are related concepts?
09:04:50 <ph88> i see   (->) e   is the type signature for for example the  (+5)
09:05:00 <ertes> not quite
09:05:12 <ph88> :(
09:05:20 <ertes> (+ 5) :: E -> A  -- in this case E = A
09:05:51 <ertes> let's use 'length' instead, with a stricter type signature than it has:  length :: String -> Int
09:06:21 <ertes> length :: F Int, where F = (->) String
09:06:30 <ertes> sensible?
09:06:45 <ph88> ye
09:07:15 <ggVGc> can I somehow write this to not need the bound name "childCount"? https://gist.github.com/1ab8addb86b00155cc97
09:07:24 <ertes> "length is a function from String to Int" ~ "length is an Int that depends on a value/'environment' of type String"
09:07:37 <ertes> ph88: still sensible?
09:07:50 <ph88> yes
09:08:29 <ertes> ph88: good…  now again: do you see how "function" and "table" are related concepts?
09:08:48 <hjulle> ggVGc: Yes, but it would probably be less readable.
09:09:47 <ph88> ertes, well i see that they are both    ->
09:10:35 <ggVGc> hjulle: how would it be done?
09:10:41 <ertesx> ph88: i got disconnected…  good…  now again: do you see how "function" and "table" are related concepts?
09:10:53 <ph88> ertes, well i see that they are both    ->
09:11:08 <ertesx> ph88: allow yourself to think intuitively now
09:11:24 <ertesx> ggVGc: you can use a shorter name than "childCount"…  i'd use "n"
09:11:52 <ertesx> ggVGc: but if you want to get rid of it altogether, you will end up with very ugly code that involves unreadable function composition and enumFromTo
09:12:03 <ph88> no offense, but i thought i intuitively already got it 20min ago and i'm wondering if you are not explaining it more complicated than it actually is .. but i can't proof this until i am able to explain it properly myself
09:12:42 <ertesx> ph88: i'm going to make sense of the "container" intuition for you, even with respect to functions
09:12:54 <ph88> ok
09:13:05 <ph88> ah that's were you're headed
09:14:12 <ertesx> ph88: you can interpret functions as (potentially infinite and dense) tables of values:  a value of type 'Table e a' is "a function from 'e' to 'a'" or alternatively: "an 'e'-indexed table of values of type 'a'"
09:14:12 <ph88> i think what will happen is that you will provide the environment variable once to make your functor complete .. and after that applying your functor to a bunch of different values
09:14:34 <ertesx> ph88: now what used to be "environment" became "index"
09:14:39 <Xandaros> ph88: Careful with the term 'variable' :)
09:15:24 <ph88> but still what is important is that this function-Functor will affect the value you put in before any function is applied to it with fmap
09:15:33 <ph88> at least that's my conclusion up to this point
09:16:09 <ertesx> ph88: functors are blind to how you *construct* values of their types
09:17:27 <hjulle> @pl getNumChildren c >>= \n -> mapM_ (\i -> (getChildAt i c) >>= gotoAndStop y) [0..n-1] -- ggVGc 
09:17:27 <lambdabot> mapM_ ((gotoAndStop y =<<) . flip getChildAt c) . enumFromTo 0 . subtract 1 =<< getNumChildren c
09:17:44 <ertesx> ph88: you're still confusing levels a bit…  a functor is *only* a type constructor together with an associated mapping function collectively called *fmap*
09:18:16 <ph88> ertesx, i got disconnected too http://pastebin.com/nXTcGCxv
09:19:06 <ertesx> <ertesx> ph88: functors are blind to how you *construct* values of their types
09:19:34 <ph88> ertesx, ok but that Functor requires supplying a function to implement it's functor type ..  and i'm not talking about the function that you need for doing fmap
09:19:47 <ertesx> you mean fmap itself?
09:19:53 <ph88> nooo
09:20:11 <ertesx> are you talking about a particular functor?  about (->) e?
09:20:13 <ph88> i mean if you have type signature    Table e    then what is it's implementation ?
09:20:23 <ph88> i think it could be (+5)
09:20:41 <ertesx> you could have a value of type 'Table e a' for some 'e' and 'a'
09:20:46 <ertesx> length :: Table String Int
09:22:49 <ph88> hmm now i think having   ->    or   (->) e    as Functor are quite different
09:23:39 <hjulle> Only the second one is possible
09:24:34 <ph88> ertes> type Table = (->)   
09:26:03 <ph88> i'm getting frustrated, every conclusion i make is on the level of "not quite"
09:26:28 <ertesx> ph88: ok, let me make this complete:
09:26:32 <hjulle> That sounds frustrating
09:26:45 <ertesx> ph88: instance Functor ((->) e)
09:27:01 <ertesx> ph88: this says: for every type 'e', the type '(->) e' is a functor
09:27:18 <ertesx> so (->) is a whole family of functors, but not a functor itself
09:27:19 <lpsmith> hmm, hackage.haskell.org is responding to https requests very slowly
09:28:17 <cocreature> lpsmith: it seems to be reasonably fast for me
09:28:22 <ertesx> ph88: just like (length :: String -> Int) is a integer, but for every value x of type String, (length x) is an integer
09:28:26 <rmrfroot> lpsmith: really? I have around 250 ms
09:28:39 <ertesx> whoops
09:28:45 <ertesx> ph88: just like (length :: String -> Int) is NOT a integer, but for every value x of type String, (length x) is an integer
09:28:48 <ertesx> sorry
09:29:20 <ertesx> ph88: does that help clear things up a bit?
09:29:35 <ph88> no :D
09:29:49 <hjulle> Alternatively: (->) is a type level function which takes a type and returns a functor (specifically (->) e)
09:30:11 <ertesx> ph88: ok, then we *need* to talk about kinds now
09:30:17 <ertesx> ph88: are you familiar with them?
09:31:13 <ph88> i understand what you are saying .. But this whole exercise goes like: what makes a picaso so special? Well you see that color green there? it's Yellow -> Blue -> Green  ..  so you can mix colors with ->  ?   not quite this only works when using regular paint ... when you mix beams of light it works totally different
09:32:10 <ertesx> ph88: without talking about kinds, this whole thing can only be explained in terms of imprecise prose…  and prose is always very subjective =)
09:32:27 <ertesx> so i can totally see how you feel like that (the picaso thing)
09:33:19 <ph88> i prefer to just know the intent of picaso and refining my knowledge of shades of green later on ^^
09:33:32 <Xandaros> You don't need to introduce all of kinds, either. Just * will be enough^^
09:33:51 <ertesx> Xandaros: (->) is the important thing to get
09:34:05 <ertesx> ph88: the intent of reader functors is function composition
09:34:13 <ertesx> but i suppose that doesn't help at all =)
09:34:27 <ph88> i haven't covered the reader or reader monad yet
09:34:41 <ertesx> '(->) String' is a reader functor
09:34:42 <Xandaros> Yes, but I can understand (->) being difficult to understand. I'd start with Maybe. Doing Reader in isolation, removed from (->) might also help
09:34:54 <ertesx> ph88: '(->) Integer' is another one
09:34:59 <hjulle> "(->) e" is the reader functor.
09:35:18 <ertesx> hjulle: that's exactly what confuses ph88 
09:35:30 <ertesx> at least i think
09:35:48 <ertesx> '(->) e' is a reader functor for all 'e'
09:36:11 <ph88> -> Integer  is a reader functor for all 'Integer'
09:36:35 <ertesx> ph88: '(->) e' is a reader functor for all 'e', for example e = Integer
09:36:47 <hjulle> But regarding kinds: Playing around with :k in ghci can be very helpful.
09:36:48 <ph88> :P
09:36:56 <ph88> i knew what you were gonna say haha
09:37:27 <ertesx> ph88: a functor is something of kind * -> *
09:37:35 <ertesx> (->) :: * -> * -> *  -- so not a functor
09:37:41 <Xandaros> :k Int
09:37:42 <lambdabot> *
09:37:51 <Xandaros> :k Maybe
09:37:52 <lambdabot> * -> *
09:37:55 <Xandaros> :k (->)
09:37:56 <lambdabot> * -> * -> *
09:37:56 <hjulle> :k (a -> b)
09:37:57 <lambdabot> Not in scope: type variable ‘a’
09:37:57 <lambdabot> Not in scope: type variable ‘b’
09:38:07 <Xandaros> :k Maybe Int
09:38:08 <lambdabot> *
09:38:11 <hjulle> :k (Int -> Int)
09:38:12 <lambdabot> *
09:38:18 <rmrfroot> anyone know if you can get output of what changes that triggered a rule build in Shake?
09:38:19 <ertesx> ph88: but if you apply a type to it, that yields a functor…  we call it the reader functor for that type
09:38:27 <ph88> to make  ->  a functor you need to supply it with one thing .. so it becomes * -> *  
09:38:35 <ertesx> ph88: exactly
09:38:36 <Xandaros> ph88: Exactly
09:38:43 <ertesx> :k (->) String  -- the reader functor for String
09:38:44 <lambdabot> * -> *
09:39:42 <ph88> i'm still thinking  (+5) can be an implementation for   (->) e   
09:39:51 <Xandaros> :t (+5)
09:39:52 <lambdabot> Num a => a -> a
09:40:02 <ph88> a -> a    * -> *
09:40:09 <hjulle> :k (+5)
09:40:10 <lambdabot> parse error on input ‘5’
09:40:13 <ph88> 2 things, 1 arrow
09:40:18 <Xandaros> Assuming a = Int
09:40:18 <ertesx> ph88: you cannot implement something of type '(->) e', because it's not a concrete type:  it's not of kind *
09:40:20 <Xandaros> :k Int -> Int
09:40:22 <lambdabot> *
09:40:29 <ertesx> ph88: only types of kind * can have values ("implementations")
09:40:39 <ertesx> "value" and "implementation" are really almost the same thing
09:41:20 <ph88> so all this time we are talking about   -> e   which can not be actually be implemented in haskell?? o_O
09:41:42 <Xandaros> It can't have a value
09:41:48 <Xandaros> That doesn't mean it's nota thing :P
09:41:54 <ertesx> ph88: '(->) e' is a functor…  the functor doesn't give rise to values by itself
09:42:25 <ertesx> because every functor is of type * -> *…  you shouldn't think of functors as "things", but rather "concepts"
09:42:58 <ph88> how can you control what becomes the  e  ?
09:43:12 <Xandaros> Compare it with Maybe. You can't have a value of "Maybe", only "Maybe Int", "Maybe String", etc. Not "Maybe" by itself
09:43:22 <hjulle> You can implement a list of things, but you can't implement a "list of".
09:43:24 <ertesx> ph88: the 'e' follows from your use of fmap
09:43:38 <tippenein> is the wiki.haskell.org code open source?
09:43:59 <ertesx> ph88: fmap (^2) length :: Table String Int  -- in this use case e = String
09:44:03 <arianvp> tippenein: i think it's just a mediawiki install
09:44:06 <arianvp> which is indeed open source
09:44:23 <tippenein> the code highlighting is embarassing
09:44:42 <arianvp> Oh you mean the configuration of wiki.haskell.org?
09:44:44 <arianvp> im not sure 
09:44:57 <ertesx> ph88: hjulle worded it very well:  you can't implement "list of", but that's the *functor* -- a concept
09:44:58 <arianvp> and yes I agree. could be a bit better
09:45:22 <cocreature> I managed to get ghc to panic while building ghc, do I get extra points for that?
09:45:58 <ph88> Xandaros,   :k Maybe  = * -> *      :k (->) e = * -> *     so e can not be Maybe
09:46:23 <ertesx> ph88: feel free to write "Maybe :: * -> *", because that's actually valid haskell =)
09:46:48 <Xandaros> ph88: I was comparing (->) e with Maybe, not e
09:47:00 <ertesx> ph88: and while not quite related to what Xandaros was trying to say, you are absolutely correct
09:47:12 <ertesx> e ≠ Maybe, because e :: *
09:47:31 <ertesx> there it is again: "not quite" =)
09:48:25 <ertesx> you know what:  i'll try to scratch "not quite" and "almost" from my vocabulary during teaching…  they don't really help
09:48:31 <ertesx> if it's not right, it's wrong
09:50:28 <ph88> is e polymorphic ?
09:50:43 <ertesx> 'e' is a (type) variable
09:51:02 <ertesx> the thing that has 'e' in its type is "polymorphic"
09:51:42 <ertesx> id :: a -> a  -- the id function is polymorphic (in 'a')
09:52:13 <ph88> hows  (->) e   not a container ?
09:52:15 <ph88> srsly
09:52:35 <ertesx> '(->) e' is not anything on the value level
09:52:56 <hjulle> How is "list of" not a container?
09:53:15 <Xandaros> ph88: Remember my analogy with Mabye? You can't have a 'Maybe', only a 'Maybe Int'. Similarly, you can't have a '(->) e', only a '(->) e a'
09:53:19 <ertesx> but feel free to interpret '(->) e a' as an 'e'-indexed container for values of type 'a', for all 'e' and 'a'
09:53:37 <ph88> hjulle, i would say the fact that you can do "list of" already means you are talking about a container
09:53:45 * hackagebot svg-tree 0.5.1 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.5.1 (VincentBerthoux)
09:54:09 <Xandaros> ph88: You still need to specify what kind of List. You can't have a 'list of', you can only have a 'list of <type>'
09:54:14 <ertesx> ph88: "list of" is a concept that talks about what a container is
09:54:24 <ertesx> a "list of integers" is an actual list
09:54:33 <ertesx> a realisation of that concept
09:55:02 <hjulle> "list of" is not anything concrete. It is just a concept.
09:56:17 <ph88> are you saying you can apply "list of" to anything else than a container ?
09:56:49 <ertesx> ph88: i see the confusion now…  "list of" is a concept for containers, not a container itself…  does that make sense?
09:56:58 <hjulle> I am saying that "list of" is not a container. "List of Int" is a container
09:57:14 <Xandaros> :k []
09:57:15 <lambdabot> * -> *
09:57:19 <Xandaros> :k [Int]
09:57:20 <lambdabot> *
09:57:36 <ertesx> ph88: you never say: "this thing here is a list of."
09:58:39 <hjulle> A container must have kind * otherwise it's not a tanglible thing.
09:59:13 <ertesx> ph88: in prose you can say "x is a list", but in haskell you can't…  the word "list" is *always* followed by "of"
09:59:28 <ertesx> prose:  x is a list of integers → x is a list
09:59:36 <ertesx> haskell:  x is a list of integers.
09:59:38 <xa0> ph88: it might be nicer to think of it as "Int List", not "List of Int". Say, an "Int List" is a container, but an "??? List" is unimplementable in haskell
10:00:32 <ph88> well you know the pendantic problem here is that i come in asking for "something to sit on" and you tell me "i only have chairs" and so we understand each other, but now in the land of haskell suddenly we don't understand each other because "chair" is not of the same kind/level/type/value/expr/whatever as "something to sit on"
10:00:59 <ph88> btw my laptop already complained 10x that i'm running low on battery and my train is arriving in 5min ^^
10:01:33 <ertesx> ph88: at this point i'd say: sleep over it…  let your brain work on all this input for a while =)
10:01:38 <ph88> :)
10:01:48 <ertesx> your subconcious will eventually make sense of all of this
10:02:00 <ertesx> and yes, i understand your confusion, but even more prose won't help
10:02:40 <ph88> i think my subconcious already absorbed 90% and i'm trying to make it conscious now :P
10:03:13 <Xandaros> ertesx: Btw, I still think Maybe would've been a better introduction than (->) e. With (->) e, you even have the weird syntax to make sense of and the intuitive understanding of a function, especially when coming from an imperative context, can be very confusing
10:03:13 <ertesx> possibly…  i predict that you will have a revelation in a few hours or maybe tomorrow =)
10:03:19 <ph88> ok thanks guys, see you later !
10:03:27 <hjulle> cya
10:03:32 <Xandaros> ph88: cu :)
10:03:44 <ertesx> bye ph88 
10:04:25 <ertesx> Xandaros: i believe in going just above your level…  it takes more time for revelations to kick in, but when they do, a whole range of concepts become clear
10:04:29 <ertesx> i hope that makes sense =)
10:04:44 <xa0> ph88: seeya!
10:06:33 <Xandaros> ertesx: Yeah, but when just starting, (->) e, might be a few steps too high, imo
10:06:53 <Xandaros> Ugh... let's call it reader. (->) e is annoying to type :D
10:06:55 <ertesx> Xandaros: i trusted that ph88 has done the Maybe exercise (i asked)
10:07:45 <Xandaros> Hmm, but he still seemed to struggle with the concept of a type constructor
10:08:40 <ertesx> Xandaros: yeah, it was more difficult than usual, but that's just another proof that different people learn very differently =)
10:09:24 <maerwald> haskell is just hard to teach
10:10:00 <maerwald> because you can't without lying
10:10:27 <xa0> that goes for most of maths really
10:11:07 <Xandaros> Haskell is very deep. That makes it insanely powerful and actually easy to use, but it is what makes it so difficult to learn
10:11:34 <Xandaros> There is always another thing about Haskell you can learn. It just never stops
10:11:49 <ertesx> also haskell is designed to be logical rather than intuitive…  that's what makes it so easy to use *when you understand it*
10:12:11 <maerwald> Xandaros: that's true for C++ as well, except there it's about learning new pitfalls :P
10:12:19 <ertesx> but when teaching it, you need to throw a lot of formal stuff at people
10:18:46 * hackagebot asciidiagram 1.3.1 - Pretty rendering of Ascii diagram into svg or png.  https://hackage.haskell.org/package/asciidiagram-1.3.1 (VincentBerthoux)
10:30:04 <fresheyeball> anyone out there tried to deploy their own stackage?
10:40:03 <lpaste> Kurohime pasted “compiles, but doesnt return what is expected ” at http://lpaste.net/157064
10:42:29 <ertesx> should i nowadays include a stack.yaml with releases?  i don't use stack myself
10:44:50 <kurohime> http://lpaste.net/157064 could use some help debugging this please 
10:45:05 <Xandaros> ertesx: Isn't there a cabal2stack or something? (I don't use stack, either...)
10:45:48 <lpaste> Kurohime revised “compiles, but doesnt return what is expected ”: “No title” at http://lpaste.net/157064
10:47:31 <ertesx> Xandaros: i don't know…  so far i have zero experience with stack, and i have no plans to use it either
10:47:49 <Gurkenglas> kurohime, I don't see the definition of parseMessage, and what expression should evaluate to "K"?
10:48:17 <Darwin226> Heys guys, anyone know if injective type families will be applicable to associated types in typeclasses?
10:50:49 <ertesx> Xandaros: also to be honest i'd prefer a simple file that i can stick into my skeleton repo and forget, but the question is really:  are stack.yaml files only required for projects that use stack, or does every dependent library need it, too?
10:51:19 <Xandaros> ertesx: Pretty sure only the top-level project needs it
10:51:46 <Xandaros> It still uses cabal under the hood, as far as I know
10:51:57 <lpaste> Gurkenglas annotated “compiles, but doesnt return what is expected ” with “(kurohime, some general refactoring tips)” at http://lpaste.net/157064#a157068
10:52:11 <ertesx> ok, thanks
10:53:50 <lpaste> Kurohime revised “compiles, but doesnt return what is expected ”: “compiles, but doesnt return what is expected” at http://lpaste.net/157064
10:55:07 <Gurkenglas> kurohime, the expression that should evaluate to ["Kggg"] is 'whatWentWrong messages', right?
10:55:18 <ertesx> for some reason the lpaste but doesn't display my pastes
10:55:23 <kurohime> yes
10:55:39 <ertesx> s/but/bot/
10:55:58 <kurohime> i think it's the list comp but it looks good to me
10:58:42 <lpaste> Kurohime pasted “These are the data types I'm working with” at http://lpaste.net/157071
11:00:21 <Gurkenglas> We should have aliases word and line where words = unfoldr word and lines = unfoldr line
11:02:10 <runeks> How can I shorten this using >>=? do { cs <- getChannelStore; liftIO $ lookupChannel h cs }
11:02:13 <lpaste> Gurkenglas revised “(kurohime, some general refactoring tips)”: “Yet more refactoring” at http://lpaste.net/157068
11:02:47 <Gurkenglas> kurohime, "E 51 Kggg" is matched to ("E":i:t:s), where i is 51 and t is Kggg and [] is s
11:02:54 <hpc> @undo do { cs <- getChannelStore; liftIO $ lookupChannel h cs }
11:02:54 <lambdabot> getChannelStore >>= \ cs -> liftIO $ lookupChannel h cs
11:03:02 <hpc> @pl getChannelStore >>= \ cs -> liftIO $ lookupChannel h cs
11:03:03 <lambdabot> liftIO . lookupChannel h =<< getChannelStore
11:03:15 <hpc> runeks: pick whichever of those is most readable
11:03:21 <hpc> runeks: i personally vote for not changing it at all
11:03:22 <runeks> hpc: Wow!
11:03:34 <runeks> How did you do that?
11:04:11 <Gurkenglas> He said those things and the bot replied. He'd reply to you, too. Experiment in /query lambdabot though unless you want to show us something
11:04:16 <hpc> the @undo command performs the naive translation from do-notation to regular code
11:04:17 <runeks> Yeah I guess the do notation is clearer after all
11:04:32 <hpc> and @pl takes an expression with explicit lambdas and makes them not explicit
11:05:02 <hpc> don't rely on either to produce valid expressions every time ;)
11:05:54 <runeks> hpc: Is it part of the bot itself, or some other package?
11:06:21 <Gurkenglas> You can do stack install pointfree and use it locally
11:06:39 <Hegg> Is there any way for cabal to install packages from a specific directory? Or to satisfy project dependencies with a libs dir? 
11:06:54 <kurohime> Thank you
11:07:37 <xa0> :t how can i get the unary minus in brackets
11:07:38 <lambdabot> parse error on input ‘in’
11:08:02 <xa0> (minus :t)
11:08:11 <Gurkenglas> :t (-1)
11:08:13 <lambdabot> Num a => a
11:09:22 <xa0> Gurkenglas: without a variable, that is
11:09:24 <lyxia> subtract
11:09:43 <Gurkenglas> xa0, what do you mean without a variable?
11:09:52 <xa0> :t (-)
11:09:53 <lambdabot> Num a => a -> a -> a
11:09:55 <xa0> gives me binary minus
11:10:04 <DrSyzygy> :t negate
11:10:04 <lyxia> negate
11:10:05 <lambdabot> Num a => a -> a
11:10:06 <xa0> ah
11:10:09 <xa0> thanks
11:11:53 <orion> Where in base can I find the definition of the type (->)?
11:11:58 <hsk3> > 2 :: Sum Integer
11:12:00 <lambdabot>  Sum {getSum = 2}
11:12:02 <xa0> i wish they called that "neg", i might just use (0-) instead..
11:12:03 <hsk3> Why does that work?
11:12:09 <hsk3> Is it some GHCi magic?
11:12:11 <hsk3> 2 is Num
11:12:16 <hsk3> What does it have to do with Sum?
11:13:08 <lyxia> 2 is a for any type a which is an instance of Num
11:13:32 <Gurkenglas> "Num a => Num (Sum a)" Sum inherits any Num instance of the type it encloses
11:14:00 <hsk3> ah ok of course, thanks
11:22:11 <aeyalcinoglu> hello! I have a question: What is the average amount of days/time for completing http://learnyouahaskell.com/ for a learner who knows python in your opinions?
11:22:50 <cobreadmonster> aeyalcinoglu: It really depends.
11:22:55 <cobreadmonster> I finished it in about a week.
11:23:16 <cobreadmonster> But I knew math pretty well.
11:23:44 <oherrala> knowing python might be a disanvantage
11:23:50 <aeyalcinoglu> :)
11:24:22 <oherrala> at least it's the other way around :D
11:27:50 <xa0> or is it :p
11:28:04 <xa0> learning haskell, you generally start to really not like python
11:28:10 <Jinxit> ^
11:28:14 <Jinxit> save me
11:34:21 <hexagoxel> Hegg: you can `cabal install /path/of/local/package/` for a one-shot; in a sandbox there is `sandbox add-source` which automatically reinstalls when the dependency is modified.
11:35:16 <hexagoxel> Hegg: with the stack tool, you can directly define multiple-package projects.
11:40:43 <Hegg> hexagoxel: I'm stuck with cabal 1.16, and the system doesn't have internet access. I was hoping there might be some way to easily provide all the packages needed to build my program on this machine without having to find internet access
11:46:55 <ertesx> aeyalcinoglu: non-programmers seem to have an easier time learning haskell than programmers in any mainstream language
11:49:49 <latro`a> aeyalcinoglu, a lot of the work is unlearning old conventions, I think
11:50:25 <latro`a> a fair bit of the time, you reflexively come up with the imperative answer, and the recursive answer parallels it directly (just using a list processing function instead of a for loop, say)
11:50:43 <Philonous> Is there an easy way to use http-client on unix sockets ?
11:50:44 <latro`a> but then when things get a bit more complicated, that can start blowing up in your face
11:51:41 <ertesx> aeyalcinoglu: at least with python you're going to be comfortable with haskell's syntax…  { { { a lot } of { programmers } } don't have { that advantage } }, { because { they love { their braces } } }
11:51:46 <hexagoxel> Hegg: i can think of one approach: cabal install --dry-run to see what packages you need, then download the packages on a different machine, copy them over, install each one by `cabal install /path/to/foo.tar.gz`.
11:51:46 <ertesx> (and people complain about lisp…)
11:52:47 <Illusional> (parentheses intensify)
11:53:14 <Hegg> hexagoxel: well that's a bummer, by the way, is there a way to tell cabal to install the binary to the current directory? Thanks for the help by the way
11:54:24 <hjulle> Hegg: If you are using sandboxes, that is the default.
11:54:32 <hexagoxel> Hegg: you might be able to run a hackage instance locally on the offline system. i think there are ways to copy a full copy somehow.
11:55:01 <ertesx> i actually never got that…  people keep telling me every now and then that an 8-line block of code with variable assignment etc. is more readable than:  putStrLn (if x > 3 then "more" else "not more")
11:55:05 <hexagoxel> Hegg: sorry, got to go.
11:55:19 <Hegg> hjulle: I don't think 1.16 has sandboxes, and the admin for the computer won't install cabal-dev =/
11:55:31 <Hegg> hexagoxel: no problem, thanks for the advice!
11:56:54 <Philonous> Is there an easy way to use http-client on unix sockets ?
11:56:56 <ertesx> Hegg: would they install nix?  advantage: everything necessary will be in the directory /nix, so they can delete it easily
11:57:30 <ertesx> Hegg: short-term advantage: modern cabal; potential long-term advantage: you could use nix for development and deployment
11:58:42 <Hegg> ertesx: They really wouldn't, they are not accomodating in the least. I think I may have to abandon the project and use a different language at this rate
12:00:15 <ertesx> Philonous: you could probably use 'makeConnection' in: https://hackage.haskell.org/package/http-client-0.4.27/docs/Network-HTTP-Client-Internal.html
12:00:51 <ramin`> @pl \xs n -> take n xs
12:00:51 <lambdabot> flip take
12:00:52 <Philonous> thanks
12:01:08 <ertesx> Hegg: or get a different hoster…  i avoid hosters like that like the plague
12:01:44 <ertesx> Hegg: in many cases you can also run a container/VM
12:02:01 <ramin`> @pl isNumber c = toEnum $ fromEnum c + 1
12:02:01 <lambdabot> isNumber = toEnum . (1 +) . fromEnum
12:02:34 <ertesx> Hegg: if the 'unshare' command is available and the kernel is at least 3.12, you can run a container with your own distribution
12:02:46 <ertesx> you don't need to be root to do that
12:03:05 <ertesx> (i'm assuming linux)
12:03:36 <Hegg> ertesx: its work related and they've got a "dont touch anything" attitude. It's more my fault I suppose, I knew they had an environement but I didn't count on it being so out of date. Really if I could just include the dependencies and tell ghc where they were I'd be good to go
12:03:55 <ramin`> @pl c
12:03:55 <lambdabot> c
12:04:09 <ramin`> @pl  n l = maximum $ prods n l
12:04:09 <ramin`>  
12:04:09 <lambdabot> n = fix ((maximum .) . prods)
12:04:49 <ertesx> Hegg: can you give me a one-line summary of your problem?
12:05:17 <ertesx> so far my understanding is that the system is painfully out of date, and you don't get to install anything system-wide, but you are free to do what you want in your home directory
12:05:21 <ertesx> is that accurate?
12:05:33 <MarcelineVQ> also without net access
12:06:19 <Hegg> ertesx: I rely on several packages that are needed to build, and the machines they need to build on have no internet access.
12:06:36 <xa0> how is @pl written
12:06:49 <hjulle> ramin`: You can send commands to lambdabot in privmsgs as well
12:07:13 <ertesx> Hegg: if that's all you need, as long as the architecture is the same, you can share ~/.cabal/packages with that machine
12:07:15 <maerwald> Hegg: use docker... build an image which contains the dependencies, distribute it to your work machines
12:07:21 <ertesx> uhm, scratch the requirement
12:07:27 <Hegg> ertesx: What i'd prefer is to just have a libs directory that ghc could leverage to build my src directory. I'm not convinced this is the best way to go though
12:07:27 <ertesx> you can share ~/.cabal/packages
12:08:00 <Hegg> ertesx: could I say.. add the .cabal/packages to my git and reference that without moving it to ~/.cabal/packages ?
12:08:07 <ertesx> Hegg: cabal keeps every downloaded package (except when using sandboxes) in ~/.cabal/packages
12:08:11 <ertesx> the source packages that is
12:08:14 <aeyalcinoglu> why do we need parentheses in here: take 10 (repeat 5)
12:08:22 <Hegg> what I mean is does the .cabal/packages have to be in the home directory
12:08:30 <ertesx> Hegg: yeah, that may be possible - see ~/.cabal/config
12:08:45 <ertesx> i believe that's what cabal-dev did essentially
12:09:11 <ertesx> aeyalcinoglu: you're passing two arguments to 'take'
12:09:18 <ertesx> (10) and (repeat 5)
12:10:05 <ertesx> Hegg: anyway, as said, in your case i would work with a container/VM
12:10:24 <aeyalcinoglu> I read functions have the priority so for example take 3 [4,4,4,4] works fine and take 3 repeat 4 should mean take 3 [4,4,4,...] and ...
12:10:59 <maerwald> function application is left associative
12:11:04 <hjulle> aeyalcinoglu: Otherwise it would be interpreted as ((take 10) repeat) 5
12:11:09 <ertesx> aeyalcinoglu: (take 3 repeat 4) assumes that 'take' is a 3-ary function, and you're giving it three arguments:  3, the repeat function, and 4
12:11:57 <maerwald> -> is right associative (type level), but function application is left associative
12:12:04 <maerwald> don't mix them up :)
12:12:26 <aeyalcinoglu> thank you all
12:12:29 <ertesx> maerwald: i believe this is aeyalcinoglu's first exposure to haskell…  maybe not the best time to talk about currying =)
12:13:01 <aeyalcinoglu> i read currying in some different place (i dont remember where)
12:13:11 <aeyalcinoglu> -before haskell-
12:13:38 <ertesx> aeyalcinoglu: imagine you write every function like this:  lambda x: lambda y: lambda z: ...
12:13:48 <ertesx> and then you apply like this:  f(x)(y)(z)
12:16:05 <aeyalcinoglu> another question: f a b means 1- g = f(a), g(b) or 2- f(a,b) [or are they same :) ]
12:17:24 <ertesx> aeyalcinoglu: neither really…  that's what maerwald was saying…  but you can read it like the second one:  you're passing two arguments, a and b, to f
12:17:34 <maerwald> that's the essence of currying... that you can move between both forms
12:17:48 <aeyalcinoglu> neither or both ? 
12:18:00 <ertesx> aeyalcinoglu: f a b = (f a) b
12:18:23 <maerwald> :t curry
12:18:24 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:18:34 <aeyalcinoglu> okay why maerwald said -> is right associative?
12:18:38 <ertesx> aeyalcinoglu: in python terms:  f = lambda x: lambda y: ...
12:18:42 <maerwald> or rather: ((a, b) -> c) -> (a -> b -> c)
12:19:00 <ertesx> aeyalcinoglu: then in haskell 'f a b' is read as python would read (f(a))(b)
12:20:10 <seishun> is there a function that returns the first element of a list if it's non-empty, otherwise returns the specified default value?
12:20:18 <maerwald> @hackage safe
12:20:18 <lambdabot> http://hackage.haskell.org/package/safe
12:20:30 <ertesx> seishun: foldr (\x _ -> x) def
12:20:39 <maerwald> @hoogle headMay
12:20:41 <lambdabot> No results found
12:21:03 <seishun> I see, thanks
12:21:09 <seishun> I guess I'll just pattern match instead
12:21:15 <maerwald> headDef :: a -> [a] -> a
12:21:22 <maerwald> no idea why hoogle doesn't find it
12:21:27 <ertesx> :t foldr const
12:21:28 <lambdabot> Foldable t => b -> t b -> b
12:21:34 <ertesx> seishun: see this
12:23:02 <aeyalcinoglu> so x y z t means ((x(y))(z))(t) in haskell, what does right associativity of -> mean than?
12:23:49 <Cale> aeyalcinoglu: It means ((x y) z) t
12:23:52 <ertesx> aeyalcinoglu: that's right…  a function that "takes two arguments" in haskell is really a function of this type:  X -> (Y -> Z)
12:24:15 <Cale> aeyalcinoglu: When you have a type A -> B -> C -> D, that means A -> (B -> (C -> D))
12:24:39 <ertesx> but we're allowed to omit the parentheses and the compiler will read it like that…  that's what we call right-associativity
12:24:46 <Cale> and so if we have, say, f :: A -> B -> C -> D, and suppose we have x :: A, y :: B, z :: C
12:24:47 <maerwald> yeah, and haskell builds those intermediate functions for free, where in other languages you have to explicitly make closures
12:24:51 <Cale> then f x :: B -> C -> D
12:24:55 <Cale> and f x y :: C -> D
12:25:02 <Cale> and so f x y z :: D
12:25:13 <aeyalcinoglu> oh really nice
12:25:17 <aeyalcinoglu> thanks all
12:30:44 <seishun> ertesx: I was actually going to filter it first, then get the first element. But I guess it's better to do the filtering inside the foldr
12:32:58 <ertesx> seishun: you could do that, though you'll get a nasty 'if' in the function
12:33:26 <ertesx> foldr (\x continue -> if p x then x else continue) def
12:33:53 <ertesx> i suppose it's not that bad
12:34:07 <seishun> I was going to have nasty ifs anyway
12:35:46 <hsk3> Do you think a higher IQ is needed to learn Haskell than other langs?
12:35:49 <Hegg> ertesx: I think I found a workable solution, like you said you can copy out the cabal packages, though I found the actual packages to be in .ghc/<architecture>/package.conf.d.... I copied that to my file directory and I used ghc -package-db=<copied package.conf.d dir> -i<source files> <file to compile>
12:36:23 <haskell252> Hi - I have a question about getting Liquid Haskell working with emacs.
12:36:25 <seishun> hsk3: I definitely feel like I'm too dumb for it
12:36:56 <ertesx> Hegg: somehow that solution would leave a bitter taste on my tongue…  i'd still go with the container/VM solution
12:36:57 <hsk3> seishun: i feel the same way all the time
12:37:11 <haskell252> Does anyone know how to get the plugin to call "stack exec liquid -- <file>" rather than "liquid <file>"?
12:37:35 <seishun> one problem with foldr is that you can't flip it and put a multi-line lambda as the last argument
12:37:57 <seishun> or can you?
12:38:06 <Peaker> I used to think that mapM should be equivalent to mapM_ via compiler optimizations, until the realization that mapM_ has a weaker class constraint
12:38:34 <ertesx> seishun: myFilter xs  where myFilter = flip foldr def $ \x continue -> ...
12:38:34 <haskell252> This lets liquid see packages locally in the project, not just in global scope
12:38:34 <Peaker> (it might still be nice if always-discarded values were optimized never to have been created in the first place, though)
12:38:58 <haskell252> Any ideas?  I know this is very specific
12:39:36 <Hegg> ertesx: yeah, it's not a good solution. The packages have to have been built with the same ghc for things to work, and there's a lot of crap that can go wrong. More of a last resort for me, as all decent solutions have kindly been blocked by my admins. Its a very developer unfriendly place unfortunately
12:40:13 <ertesx> Hegg: my original idea was more along the lines of copying the *source* packages
12:41:00 <maerwald> Hegg: if you need the same environment, use containers e.g. docker
12:41:25 <Gurkenglas> seishun, can you show me the code where you want to have the function as the last argument?
12:41:42 <seishun> Gurkenglas: I haven't written it yet
12:42:16 <Hegg> maerwald: I know these tools, I use them, but they don't exist where I need them to at my work. Development isn't really the focus of the business, its just something they hired one or two of us to do
12:42:41 <ertesx> Hegg: again, check whether the 'unshare' command is available
12:42:58 <ertesx> (again assuming linux)
12:43:19 <Hegg> ertesx: its linux, yeah I have access to unshare
12:43:32 <ertesx> Hegg: check the kernel version…  > 3.12?
12:43:34 <Gurkenglas> seishun, I'm expecting you to be able to get rid of at least the third argument through eta reduction, but I don't know your usecase
12:43:35 <ertesx> >=
12:44:11 <Hegg> ertesx: 3.16 actually
12:44:41 <ertesx> Hegg: that's all you need to work with containers, unless the admins disabled it specifically in the kernel…  but i assume they use a distribution kernel
12:44:50 <haskell252> Has anyone else got Liquid Haskell working with emacs?  Am I asking in the wrong place?
12:45:07 <haskell252> Is there somewhere else I should ask instead?
12:45:16 <maerwald> only with vim
12:45:23 <maerwald> you can also run it from the command line
12:45:29 <Hegg> ertesx: I'll try it out, it would be preferable
12:46:05 <ertesx> Hegg: if the LXC suite is available, use that one, otherwise you may have to climb a learning curve and create the container startup script by hand
12:46:47 <ertesx> it's not much to write, but unfortunately linux container technology is awfully documented =/
12:46:59 <ertesx> most of it i figured out by trial and error
12:47:59 <Hegg> ertesx: short of the archwiki I don't think I've ever encountered decent documentation, but a startup script by hand would probably be useful to know
12:48:30 <ertesx> Hegg: the way i would do it is:  build the program locally with nix on the same architecture, extract the nix closure (which includes your package along with all its dependencies down to glibc), write a container startup script for it
12:49:04 <maerwald> you can probably come up with a more complicated way that involves even more technology :P
12:49:21 <maerwald> chroot + tar works too
12:49:28 <ertesx> maerwald: definitely…  i'm already trying to limit it to the bare minimum =)
12:49:36 <maerwald> nix is not part of bare minimum
12:50:00 <maerwald> he'll waste a lot of time to get to know it
12:50:03 <Hegg> overengineering is a favorite pastime of mine, after this whole thing is sorted out I might revisit it and see what things can be complicated
12:50:21 <ertesx> but it gives you closures…  otherwise you'll spend a lot of time figuring out how much of your current system you need to put into the tar to make it work
12:50:33 <maerwald> huh?
12:50:49 <maerwald> all of it.
12:50:56 <maerwald> you bootstrap a chroot and are done
12:51:08 <maerwald> tar it up, distribute it
12:51:14 <ertesx> ouch =)
12:51:19 <maerwald> ?
12:51:46 <ertesx> actually, maybe a statically linked executable would already do it
12:51:59 <ertesx> statically link not only haskell libraries, but everything
12:52:03 <brian_> Terminology question: Let's say I write a recursive function called foo that results in calling itself twice, something like (foo n + foo m). Is there a term I can use to distinguish this kind of recursive function from one that calls itself once, like (n + foo n)?
12:52:13 <maerwald> containers are nothing more than a more fancy way of creating chroots
12:52:16 <ertesx> that executable will have terrible load times, but it would have no dependencies
12:52:24 <brian_> Like a recursion arity, or something?
12:52:31 <maerwald> if you don't have container technology, just do chroots
12:53:48 <ertesx> maerwald: virtual-filesystem containers *are* chroot, just in a new mount namespace, so you can mount stuff like /proc, etc.
12:53:51 * hackagebot hArduino 1.0 - Control your Arduino board from Haskell.  https://hackage.haskell.org/package/hArduino-1.0 (LeventErkok)
12:53:53 <jomg> brian_, there's "multiple recursion", i'm not sure there's a more precise term
12:53:59 <maerwald> ertesx: I am aware
12:54:46 <ertesx> maerwald: and it's not much more than unshare, then pivot_root/chroot…  but when you're going to use unshare anyway, you could just as well unshare other things, too, and get some isolation
12:55:12 <ertesx> most of it is free…  just for some of it you need scripting/configuration
12:55:16 <brian_> Then, can I talk about 'single recursion' vs 'multiple recursion', does that make sense in a discussion?
12:56:07 <jomg> brian_, at least wikipedia differentiates between those two, so i'd say probably yes :P
12:56:44 <xa0> when i hear multiple recursion i think [ foo calls bar, which calls foo ]
12:57:15 <jomg> xa0, that would be mutual recursion
12:57:22 <xa0> ahh.
12:57:22 <Xandaros> xa0: that's mutual recursion
12:57:59 <ertesx> maerwald: apropos overengineering…  my solution involves using the cabal2nix command-line utility…  it's really not that much maintenance overhead =)
12:58:03 <brian_> great. It's hard to talk about this stuff without good terms, and I find it hard to google for precise terms without knowing them first...
12:58:20 <maerwald> i prefer KISS
12:58:51 * hackagebot hArduino 1.1 - Control your Arduino board from Haskell.  https://hackage.haskell.org/package/hArduino-1.1 (LeventErkok)
12:59:14 <brian_> So, (n + foo n) is single recursion, but isn't a tail call, right?
12:59:27 <jomg> brian_, correct
13:00:01 <ertesx> maerwald: that is the most KISS solution i can come up with:  let nix create a fully self-contained tar, write a startup script, deploy as it is
13:01:03 <maerwald> the more technologies are involved the less KISS it is, because you have to deal with every layer of technology
13:02:00 <brian_> So, I've been trying to learn tricks to write recursive solutions in stack based languages (yeah, no Haskell at work, at least not yet) and I'm trying to grok trampolining. Is it true that I can only get there by setting up a tail recursion?
13:02:11 <ertesx> maerwald: by that standard none of our solutions have been KISS…  my standard is: eliminate sources of failure and target system dependencies
13:02:18 <ertesx> maerwald: nix takes care of the former, unshare of the latter
13:02:52 <brian_> Err, or put another way, I can't directly trampoline from multiple recursion, right?
13:02:52 <jomg> brian_, i was under the impression that it was the other way around: trampolining as a way to provide tail call optimization
13:02:54 <maerwald> docker is kind of KISS (let someone else do the work and do your stuff on top of it), but he said he doesn't have it, so...
13:03:11 <jomg> brian_, i must admit that i don't really know how it works myself
13:03:25 <maerwald> pretty sure there are haskell docker images too with base dependencies and specific GHC versions already installed
13:03:41 <maerwald> then it would be a matter of 2-3 lines
13:03:57 <brian_> Yeah, the trampolining demos I've seen so far are ways to do TCO in stack based languages.
13:04:30 <maerwald> and he wouldn't have to care about anything distro-specific
13:04:56 <brian_> I've got some multiple recursion I'd like to do in a stack based language, and I was trying to figure out how to trampoline it, but as far as I can tell, I'd need to convert it to a tail call first. 
13:06:10 <ertesx> maerwald: to be honest i'm not a big fan of docker, and i avoid it where i can
13:06:26 <seishun> Gurkenglas: http://lpaste.net/157088
13:07:16 <jomg> brian_, seems to me like making a multiple recursive function into a tail call would first require it to be made single recursive
13:07:18 <seishun> I'd love to get rid of this myFilter variable because I have no idea how to name it properly
13:07:59 <brian_> Yeah, it looks like there is a necessary path from multiple->single->tail call
13:08:42 <jomg> not sure that's even generally possible. for example, how would quicksort look if it were single recursive?
13:09:57 <ertesx> maerwald: ∃ (x : mainstream languages influenced by haskell). docker and nix have a relationship similar to x and haskell…  good intentions, but overly specialised, overly complicated, ad-hoc, not quite the solution
13:10:04 <seishun> ertesx: any suggestions how I could simplify that code?
13:10:40 <ertesx> seishun: call it 'filt' or something…  as long as the implementation speaks for itself, you don't need a descriptive name
13:10:41 <maerwald> ertesx: huh wat?
13:11:00 <Industrial> Hi. Trying to learn Haskell I'm writing a `ls` program. It will print stuff about the files in the dir(s). Currently I have it read the argv and on line 21 I'd like to return True when all the dirs exist; https://gist.github.com/Industrial/6d71bdf5d46b2261317c/c52316fc496834178a58679c0dbb15e5595c4096
13:11:34 <Industrial> but it can't match IO Bool with actual Bool
13:11:55 <Industrial> So far, handling these IO/Monads has been the most challenging :D
13:12:49 <seishun> Industrial: just add a return there?
13:13:32 <ertesx> Industrial: also see the 'and' function
13:13:37 <maerwald> ertesx: 1. docker is not specialised, it's a low-level solution that can be used for almost anything, 2. the reason it's KISS is not because of the technology, but because of the ecosystem, 3. docker is not influenced by nix in any way, it's more abstract than nix
13:14:06 <aakfp> Industrial: you use  <- to "remove" the IO, and return to add it back.
13:14:33 <maerwald> nix is overly complicated and overly specialised in fact... to the point that one of their main selling points (interesting for deployment) is today mostly irrelevant since people prefer proper container solutions instead of it to stay distro-agnostic
13:14:38 <ertesx> maerwald: i disagree with all three points, but let's leave it at that, because this is getting highly off-topic…  if you're interested in why i disagree, feel free to /query me =)
13:14:41 <Industrial> seishun, aakfp: right.
13:15:23 <maerwald> every solution that involves nix, also forces a particular distro on you
13:15:36 <ertesx> maerwald: you're wrong, but again:  let's leave it at that
13:15:40 <Industrial> ertesx: yeah I had `return $ not $ elem False results` and that became `return & notElem False results` and that became `return $ not results`
13:15:42 <maerwald> how so?
13:16:07 <Industrial> ertesx: using some plugins for Atom :-) pretty neat all the hints. (It's what I use daily with Node.js anyway)
13:16:14 <maerwald> if you are using nix, you are using NixOS
13:16:20 <ertesx> maerwald: no
13:16:24 <steve`> maerwald: other way round
13:16:30 <steve`> oops, wrong nick
13:16:39 <maerwald> ertesx: so... which other distro provides nix packages except NixOS?
13:16:56 <maerwald> I am aware that I can use nix on a random distro, that still means I use NixOS though
13:17:05 <ertesx> maerwald: none, and none has to…  please educate yourself before comparing technologies
13:17:10 <maerwald> ertesx: huh?
13:17:18 <maerwald> I think you don't know what you are talking about
13:17:56 <prototrout> maerwald: using Pacman on Windows doesn't mean you're using Arch; it seems analogous to me.
13:18:06 <ertesx> maerwald: i've been using NixOS on all my own systems for ~3 years now, and i've deployed with the help of nix to non-NixOS and even non-nix systems
13:18:10 <maerwald> prototrout: if you are using pacman with arch packages, then yes
13:18:15 <ertesx> maerwald: so yes, i do know what i'm talking about
13:18:40 <maerwald> ertesx: NixOS is the only distro that provides nixpkgs
13:18:44 <jomg> you should really move this discussion somewhere else
13:18:50 <aakfp> #nixos
13:19:06 <maerwald> it's irrelevant how you use nix (e.g. inside another distro)... you still depend on NixOS
13:19:11 <prototrout> Yeah, sorry for jumping in :( I have a Haskell question though!
13:19:43 <ertesx> maerwald: sorry, i won't respond to this discussion any longer…  not because i'm not interested, but because this is the wrong channel…  again: /query me, if you want to learn more
13:19:44 <michaelt> seishun: you should be able to write this with Data.Map.foldWithKey
13:19:48 <jomg> prototrout, just ask
13:20:01 <prototrout> jomg: Yep, working on phrasing :)
13:20:21 <seishun> Deprecated. As of version 0.4, replaced by foldrWithKey.
13:22:01 <seishun> but yes, I think it simplifies things
13:22:27 <michaelt> seishun: ah yes, I see that, foldrWithKey This would save you the conversion to a list. Maybe that's not expensive, I don't know.
13:22:40 <seishun> I only care about code simplicity
13:23:31 <aakfp> I have two lists, I want to create all possible lists where the elements from the second lists are replacing, in order, elements from the first list. Known combinator?
13:23:45 <seishun> in other news, I really dislike how I have to either `import Data.Map (every, single, thing, I, use)
13:23:45 <seishun> ` or import qualified and then have to use `Map.!`
13:24:11 <ertesx> aakfp: could you provide an example?
13:24:15 <prototrout> I'm writing a compiler and I have several different AST types with name substitution implemented for each. I'd like to abstract that a bit (so I don't have renameFoo, renameBar, ...) by having each indicate subexpressions within their binders, outside their binders, and the names being bound. This feels a lot like something Control.Lens can help me solve, (is it a Traversal?) but I can't name the right type. Can someone point me th
13:24:16 <prototrout> right direction?
13:24:18 <seishun> can I just remove clashing things from the import?
13:24:25 <prototrout> Woo, that was longer than I hoped.
13:24:36 <michaelt> seishun: import XYZ hiding (preludething)
13:24:48 <aakfp> foo "abc" "x" == ["abc", "xbc", "axc", "abx"]
13:24:49 <seishun> thanks, will try that
13:25:06 <ertesx> aakfp: an example with a longer second list would be helpful, too
13:25:21 <ertesx> foo "abcde" "xy" = ?
13:25:31 <aakfp> foo "abc "xy" == ["xyc", "axy"]
13:25:33 <lpaste> Gurkenglas annotated “No title” with “No title (annotation)” at http://lpaste.net/157088#a157089
13:25:48 <aakfp> first example output was wrong, shouldn't contain "abc".
13:25:49 <Gurkenglas> seishun, ^
13:26:27 <aakfp> noo.. second was also wrong.
13:26:33 <seishun> oh man, this is hard to read
13:26:35 <ertesx> aakfp: i see…  there is nothing predefined, but it should be easy enough to write recursively
13:26:38 <Gurkenglas> hmmm
13:26:57 <michaelt> seishun: in the case of Data.Map there is null , map, lookup that need hiding.
13:27:25 <aakfp> foo "abc" "xy" == ["axy", "xby", "xyc"].  hopefully that's correct :-)
13:27:42 <seishun> michaelt: but I don't need to hid them if I don't use them at all, right?
13:27:42 <prototrout> Lightbulb: I need two "Traversal' a a" and a "Traversal' a Name"
13:27:49 <ertesx> aakfp: oh, that's different…  nothing is predefined, and it's not entirely straightforward to write either =)
13:27:51 <lpaste> Gurkenglas revised “No title (annotation)”: “How about this, seishun?” at http://lpaste.net/157089
13:28:20 <lpaste> Gurkenglas revised “No title (annotation)”: “No title” at http://lpaste.net/157089
13:28:26 <ertesx> aakfp: challenging, but not a nightmare
13:28:36 <michaelt> seishun: right. If you do `import Data.Map` in ghci, then `:browse Data.Map`, the clashing things will be shown qualified
13:28:52 <llvem> hello
13:29:12 <lpaste> Gurkenglas revised “No title (annotation)”: “Dangit again” at http://lpaste.net/157089
13:29:32 <seishun> Gurkenglas: still having trouble parsing it
13:29:47 <seishun> what's & even
13:29:50 <seishun> :t (&)
13:29:52 <lambdabot> a -> (a -> b) -> b
13:29:59 <michaelt> seishun: flip ($) , reverse application
13:30:03 <xa0> reverse apply
13:30:10 <aakfp> I thought this would be useful in a parser combinator library as it is kind of what approximate matching and levenshtein distances are about.  So I was looking around for some Alternative combinators or list combinators for this stuff.  Couldn't find anything remotely approximate (pun intended). 
13:32:38 <ertesx> aakfp: i've just written it…  it's actually not too difficult to write
13:32:45 <ertesx> give it a try
13:33:01 <ertesx> λ> rep "abcde" "xy"
13:33:01 <ertesx> ["xycde","xbyde","xbcye","xbcdy","axyde","axcye","axcdy","abxye","abxdy","abcxy"]
13:33:02 <ertesx>  
13:35:52 <Industrial> Hi. I want to use the function System.Directory.getDirectoryContents but that requires me to use a FilePath type, where I have a String right now. How do I turn my String into a FilePath, and the result of getDirectoryContents (which are FilePath's) back into a String? https://gist.github.com/Industrial/6d71bdf5d46b2261317c/cf4f828db5373aedb16d367738f00bfa6357b052#file-ls-hs-L43
13:36:47 <michaelt> Industrial: it is a String
13:36:49 <lpaste> Gurkenglas pasted “aakfp, here's an implementation btw.” at http://lpaste.net/2543471377764057088
13:36:59 <michaelt> Industrial: FilePath is just a 'type synonym'
13:37:14 <Industrial> okay
13:37:32 <llvem> Q is this claim that unsafe FFI calls to C are not parallelizable true? https://stackoverflow.com/questions/4502115/interchange-structured-data-between-haskell-and-c
13:38:31 <michaelt> Industrial: it isn't type checking right? This is because you are applying mapM_ to an IO [FilePath]
13:38:48 <aakfp> ertesx, Gurkenglas: thanks! then it's probably easy to create replace :: Alternative f => [f a] -> [f a] -> f [a]
13:38:53 * hackagebot hspec-expectations-pretty-diff 0.7.2.4 - Catchy combinators for HUnit  https://hackage.haskell.org/package/hspec-expectations-pretty-diff-0.7.2.4 (myfreeweb)
13:39:05 <michaelt> Industrial: it should be ` getDirectoryContents argv >>= mapM_ putStrLn  ` or the like
13:42:33 <Peaker> prototrout: there's the "bound" library and there are some "abstract binding tree" libraries too
13:42:48 <michaelt> Industrial: Oh, wait there is also the fact that argv is a list 
13:43:01 <ertesx> aakfp, Gurkenglas: for the sake of completeness, i've annotated mine, though i would have preferred aakfp to try by themselves =)
13:43:15 <Peaker> prototrout: I'm using this style:   data AST e = Lam Name e | App e e | ... deriving (Functor, Foldable, Traversable)
13:44:26 <Peaker> prototrout: Then something like: newtype AnnotatedAST a = AnnotatedAST a (AST (AnnotatedAST a)) deriving (Functor, Foldable, Traversable)
13:44:44 <michaelt> Industrial: https://gist.github.com/michaelt/03664a410d430307170b
13:47:30 <Peaker> prototrout: what style of AST are you using?
13:53:11 <seishun> http://lpaste.net/157088 I think this is readable enough
13:53:31 <seishun> the one above I mean
13:57:15 <ertesx> seishun: the one below is terrible…  the one above is how i would have written it, except for the layout
14:17:25 <ertesx> is it safe to use MkFixed from Data.Fixed?
14:18:16 <monochrom> is it exported by Data.Fixed? if yes then yes
14:18:54 <baxbaxwalanuksiw> yes it is exported
14:19:03 <monochrom> I think yes
14:19:26 <baxbaxwalanuksiw> if it hasn't any smart constructors then just use the regular constructor
14:20:00 <ertesx> thanks
14:20:21 <ertesx> baxbaxwalanuksiw: it has fromRational, but i have an Integer that's exactly the right value
14:21:15 <monochrom> you also have Fractional methods for example "0.54 :: Fixed E3" which is likely more readable than "MkFixed 540 :: Fixed E3"
14:21:15 <phaskell-1> E3: austin - https://phabricator.haskell.org/E3
14:22:17 <baxbaxwalanuksiw> ertesx: I don't know Data.Fixed, but like monochrom said, if it's exported then it's safe
14:23:41 <baxbaxwalanuksiw> I can't figure out my Monad instance for my Neuron datatype: http://lpaste.net/157101
14:24:05 <baxbaxwalanuksiw> could you just tell me if an instance is possible or not ?
14:25:26 <Fylwind> Interesting how I find myself referencing Haskell Wiki less and less, and the GHC Trac Wiki more and more …
14:25:48 <baxbaxwalanuksiw> It seems that Neuron looks like ((->) r) but i can't reproduce the same code on my Neuron datatype
14:26:31 <monochrom> baxbaxwalanuksiw: I'm wondering whether "NeuronT m" is an Arrow instead
14:27:32 <ertesx> i'm asking because while MkFixed is exported, there is no documentation on it…  in particular nowhere is it stated that the Integer reflects the number multiplied by the resolution
14:27:57 <baxbaxwalanuksiw> I haven't studied Arrows yet, do you recommend any paper on Arrows ?*
14:28:21 <ertesx> so (MkFixed 1 :: Milli) could mean 0.001, but it could also mean 0.0000000000000000000000001 from what i know
14:30:10 <ertesx> monochrom, baxbaxwalanuksiw: it's not a monad, because it has what is known as static information
14:30:50 <baxbaxwalanuksiw> thanks monochrom, from what i've seen, my neuron datatype seems to be an arrow
14:30:59 <ertesx> and it is indeed an arrow, as long as the static information can be computed without executing the StateT
14:31:15 <monochrom> nice
14:31:16 <ertesx> if it's just (<>), then it's an arrow
14:31:24 <baxbaxwalanuksiw> a static information is what we call a parameter, right ?
14:31:48 <ertesx> baxbaxwalanuksiw: we call it static, because it's known before executing the represented action
14:32:10 <ertesx> (>>=) inherently requires all information to be dynamic, because functions are opaque in haskell
14:33:18 <ertesx> you would need to execute the StateT just to compute what c >>= f is, but that's impossible, because you don't know how to execute the underlying monad 'm'
14:34:07 <baxbaxwalanuksiw> thats exactly the problem I had when trying to implement (>>=) for my datatype, it make sense now
14:34:51 <baxbaxwalanuksiw> so its impossible to make (NeuronT m a) a Monad ? If so, then why does it works with ((->) r) ?
14:34:59 <ertesx> there is a single exception:  the fitness of c >>= f does not follow from what f returns, but can be computed from the fitness of c alone
14:35:18 <ertesx> '(->) r' does not include any static information
14:36:21 <ertesx> (i prefer to call it meta-information)
14:36:42 <fosskers> Hey guys, in Haskell, what functions/data structures have stream fusion by default, and which don't?
14:36:48 <baxbaxwalanuksiw> then I don't understand... How is my NeuronT not like a regular function ? What is the static information here ?
14:37:10 <ertesx> baxbaxwalanuksiw: the fitness…  it's meta and not computed as a result of the StateT action
14:37:31 <Fylwind> So if I'm not mistaken, OverlappingInstance is safe (no incoherence) as long as the instances are non-orphan, right?
14:38:03 <ertesx> fosskers: those that have are usually documented…  notably list functions have fusion (but not stream fusion IIRC), text and vector have stream fusion…  notably ByteString doesn't
14:38:41 <baxbaxwalanuksiw> ertesx: I still don't understand, I think I need some basic knowledge about Arrows to understand
14:39:00 <baxbaxwalanuksiw> thanks anyway monochrome and ertesx for the tip
14:39:24 <ertesx> baxbaxwalanuksiw: basically any information that raises a chick/egg problem with the fact that (>>=) takes a regular haskell function is meta/static in this way
14:39:47 <monochrom> yeah I prefer to say "meta" too.
14:41:08 <ertesx> baxbaxwalanuksiw: try implementing this:  data MyState s a = MyState { usesPut :: Bool, runMyState :: s -> (s, a) }
14:41:21 <ertesx> usesPut should be True, if 'put' is used
14:42:09 <ertesx> note that it's not a result of the stateful function, but meta-information that follows from how the action is constructed
14:42:49 <baxbaxwalanuksiw> ok, thanks
14:45:02 <lazyWriter> does haskell support 2 d arrays? i.e. can I have an matrix of "Maybe Foo" 's ?
14:45:32 <xa0> [[Maybe Foo]]
14:46:00 <ertesx> lazyWriter: vector doesn't, but repa does, and the old 'array' library does, too
14:46:11 <lazyWriter> xa0: I want matrix, constant time indexing, not lists
14:46:24 <xa0> oh
14:46:25 <llvem3> anyone use inline-c?
14:46:27 <lazyWriter> so is there no generic 'n-dimensional array' 
14:46:36 <ertesx> lazyWriter: i would use 'vector' with 'V2 Int' from 'linear' and then compute the linear address
14:46:36 <phaskell-1> V2: What DNS naming convention should we use for GHC buildbots? Come Vote https://phabricator.haskell.org/V2
14:46:58 <lazyWriter> I don't understand. I don't want to store numbers.
14:47:01 <lazyWriter> I want to store objects.
14:47:05 <llvem3> i'm wondering - are inline-c calls safe or unsafe? also, is there a way to define inline-c functions that can be called from other inline-c code?
14:47:10 <ertesx> lazyWriter: haskell itself doesn't understand arrays at all…  they are provided by libraries like the common 'vector' library
14:47:33 <lazyWriter> I see
14:47:40 <lazyWriter> you're saying: store your n-dimensional array as a 1-day array
14:47:48 <lazyWriter> then do your own translation of Int^n -> Int
14:47:49 <lazyWriter> for indexing
14:48:06 <ertesx> lazyWriter: that's what i would do…  but one question: do you need mutability?
14:48:17 <Zelte> Hi
14:48:36 <lazyWriter> ertesx: no, no mutability
14:48:59 <lazyWriter> the more I look at this, the more I'm templted to just use a map of a map
14:49:04 <lazyWriter> and have log n instead of O(1) time
14:49:13 <ertesx> lazyWriter: do you have complicated values?  in other words: values that can't be unboxed
14:49:24 <hjulle> Map (Int,Int) (Maybe Foo) works as well
14:49:27 <lazyWriter> yeah; they're complciated values; tey're haskell structures
14:49:40 <ertesx> lazyWriter: you could use Map Int (Vector T)
14:49:47 <ertesx> but to be honest i would still go with Vector T
14:49:48 <fosskers> thanks ertesx 
14:50:10 <ertesx> oh, and Vector (Vector T) is also possible, but you don't get the tight packing that way
14:50:32 <fosskers> meaning that with lists, `filter baz . map foo . foldr bar []` will fuse?
14:50:51 <Zelte> I was juste reading: A history of Haskell: Being lazy with class. Un thé section about debugging they talk about Hat. It looks pretty neat. Why is nom one talking about it?
14:51:01 <ertesx> lazyWriter: computing the linear address is very simple:  lin = w*y + x, where y = row, x = column, w = width
14:51:12 <ertesx> lazyWriter: and (y, x) = divMod lin w
14:51:18 <baxbaxwalanuksiw> Zelte: t'es français ?
14:51:45 <Zelte> ouais.
14:51:49 <Moggle> i'm trying to get mueval working, but for whatever reason it's complaining that glasgowExtensions is not exported, how can I fix this?
14:52:09 <Zelte> Le correcteur automatique me trahi. :(
14:52:19 <llvem3> hrm... think i'm going to give up on this c2hs preprocessor struct marshalling and just do everything manually with long function definitions...
14:52:20 <baxbaxwalanuksiw> ouais :D
14:53:02 <Zelte> Est-ce que ma question reste compréhensible?
14:53:48 <baxbaxwalanuksiw> ouais t'inquiète
14:53:58 <baxbaxwalanuksiw> enfin vite fait
14:54:04 <maerwald> please speak english or join #haskell-fr
14:54:22 <baxbaxwalanuksiw> sorry
14:54:29 <MichaelBurge> Zelte: If you're debugging an exception, it's usually easier to switch on profiling or get a trace from ghci.-
14:55:42 <Zelte> Sorry
15:00:43 <ackthet> todays dumb question: can i set a config options somewhere so that :set -Wall is always set on starting ghci?
15:01:13 <sm> ackthet: echo ":set -Wall" >.ghci, in your project dir or home dir
15:03:22 <ackthet> sm++
15:12:12 <puregreen> Lokathor: unfortunately, charsetdetect-ae is about 20 times slower than simply always decoding as UTF-8 (see http://lpaste.net/157104)
15:13:00 <puregreen> Lokathor: (surprisingly, if you include a Unicode character into the text, it magically speeds up and becomes only 2.5× slower)
15:13:56 * hackagebot zot 0.0.3 - Zot language  https://hackage.haskell.org/package/zot-0.0.3 (YoshikuniJujo)
15:14:29 <ksf> todays installation of "I can't believe someone really did that", have this: https://pdfs.semanticscholar.org/3416/b389892c3243ea97237a40b304dffe37eae4.pdf
15:14:58 <ksf> oh. that should've gone to -blah. It's still lambda calculus, though, so I'm not *completely* off topic.
15:18:03 <aeyalcinoglu> i have a question, what is the general code: when we have a function f from positive integers to positive integers and we want to find the list of elements smaller than n in image of f
15:18:56 * hackagebot managed 1.0.3 - A monad for managed values  https://hackage.haskell.org/package/managed-1.0.3 (GabrielGonzalez)
15:20:15 <ksf> aeyalcinoglu, you can write that generically but it's not going to terminate.
15:20:33 <aeyalcinoglu> i want something that terminates
15:21:17 <ksf> well then you need to restrict f such that you can tell "after this element, no `f x` is going to yield a y < n".
15:21:47 <ksf> or you need to calculate with a symbolic representation of the function, but that's maths.
15:22:00 <aeyalcinoglu> or maybe if you cant help me, my main question is: i started learning haskell today and am trying to solve https://projecteuler.net/problem=2 this question,  i wrote //fibonacci x = if (x == 1 || x == 2) then x else (fibonacci (x-1)) + (fibonacci (x-2))// and couldnt continue
15:23:09 <ksf> oh, fibonnacci is monotonically increasing, so that works.
15:24:04 <aeyalcinoglu> can you write me ksf?
15:24:07 <ertesx> aeyalcinoglu: you can define a list of all fibonacci numbers, then transform the list a few times
15:24:09 <ksf> step a) write a function "fibs" that represents the whole sequence (as an infinite list), b) use `takeWhile`
15:24:33 <aeyalcinoglu> i didnt learn takeWhile yet
15:24:44 <aeyalcinoglu> maybe I should contiune solving problems later
15:24:53 <ertesx> aeyalcinoglu: start with defining the list, ksf's step a)
15:25:07 <aeyalcinoglu> map fibonacci [1..] step a i guess
15:25:24 <ertesx> aeyalcinoglu: there is a simpler (and way faster) definition
15:25:26 <ksf> that's not very elegant, however, it'll sufice.
15:25:37 <ertesx> it's longer in code, but doesn't use the 'fibonacci' function
15:26:10 <ksf> ...and uses "zipWith" and is a real brain teaser for people not accustomed to laziness.
15:26:23 <ertesx> no, it uses simple recursion =)
15:26:26 <aeyalcinoglu> i suppose so, but my main objective is not solving this question perfectly, just exercesing things i have learnt
15:26:57 <ksf> well, as to takeWhile: It's easy enough to implement yourself.
15:27:04 <ertesx> aeyalcinoglu: learning how to define infinite lists is will be very helpful…  you should practice it
15:27:09 <ksf> takeWhile               :: (a -> Bool) -> [a] -> [a]
15:27:22 <ertesx> aeyalcinoglu: start by constructing an infinite list of ones
15:27:28 <ertesx> ones = [1, 1, 1, 1, 1, ...
15:27:50 <ertesx> if you can do that, construct an infinite list of increasing numbers:  [1, 2, 3, 4, 5, ...
15:27:50 <ksf> ...return elements from the list as long as the function return true on them, otherwise, return the empy list.
15:28:08 <ertesx> if you can do that, too, then you're very close to defining the list of fibonacci numbers
15:28:11 <aeyalcinoglu> okay i read takeWhile and understand how to solve this problem
15:28:50 <ertesx> aeyalcinoglu: oh, and do not use the [1..] notation for that…  define it recursively =)
15:29:05 <aeyalcinoglu> how?
15:29:13 <ertesx> aeyalcinoglu: let's start with 'ones'
15:29:16 <ertesx> ones = _
15:29:27 <ertesx> now this is a non-empty list, so it is certainly of the form _ : _, right?
15:29:43 <aeyalcinoglu> right
15:29:46 <ertesx> ones = _ : _
15:29:51 <ertesx> what's the head of that list?
15:29:58 <aeyalcinoglu> _
15:30:04 <aeyalcinoglu> i dont know :)
15:30:05 <ertesx> i mean, what should it be?
15:30:12 <aeyalcinoglu> 1?
15:30:15 <ertesx> yeah
15:30:18 <ertesx> ones = 1 : _
15:30:33 <ertesx> what is the tail?  feel free to tell me in prose rather than code =)
15:30:33 <aeyalcinoglu> ohh i see what you are doing :p
15:30:54 <aeyalcinoglu> a moment
15:31:19 <aeyalcinoglu> tail is _ in 1:_
15:31:32 <aeyalcinoglu> correct?
15:31:35 <ertesx> yes
15:32:07 <ertesx> what follows the first 1 in the list?
15:32:21 <aeyalcinoglu> 2 (at least in this question)
15:32:34 <ertesx> we're defining 'ones', an infinite list of 1
15:32:34 <aeyalcinoglu> 1:2:_
15:32:45 <ertesx> 1 : 1 : 1 : ...
15:32:55 <aeyalcinoglu> hmm okay
15:33:01 <ksf> nope (and I don't mean the number).
15:33:03 <ksf> > (:)
15:33:04 <lambdabot>      No instance for (Typeable a0)
15:33:04 <lambdabot>        arising from a use of ‘show_M821086219850173176220967’
15:33:04 <lambdabot>      In the expression:
15:33:08 <ksf> ugh.
15:33:20 <ertesx> aeyalcinoglu: tell me in prose:  the tail is the remaining list after the 1
15:33:23 <ksf> anyway, (:) has type a -> [a] -> [a]
15:33:24 <ertesx> aeyalcinoglu: what is that list?
15:33:31 <ksf> that is, the second argument needs to be a list, not an element.
15:34:35 <aeyalcinoglu> sorry let me think a little bit more
15:34:50 <aeyalcinoglu> 1:_?
15:34:56 <ertesx> aeyalcinoglu: think really really simple…  look at this list:  1 : 1 : 1 : 1 : ...
15:35:00 <ertesx> the head is 1
15:35:09 <ertesx> what is the tail?
15:35:14 <aeyalcinoglu> same list
15:35:22 <ertesx> exactly…  another list of ones =)
15:35:25 <ertesx> and what is 'ones'?
15:35:34 <ksf> or, more explicitely, 1 : (1 : ( 1 : ... ))
15:35:48 <aeyalcinoglu> i dont know
15:36:22 <ertesx> aeyalcinoglu: let's summarise
15:36:34 <ertesx> we're defining an infinite list of ones called 'ones'
15:36:41 <ertesx> ones = _thatList
15:36:54 <ertesx> we have established that this list must be of the form _ : _
15:36:58 <ertesx> ones = _head : _tail
15:37:04 <ertesx> and that _head = 1
15:37:08 <ertesx> ones = 1 : _tail
15:37:14 <ertesx> aeyalcinoglu: so far, so good?
15:37:17 <aeyalcinoglu> yes
15:37:38 <ertesx> now…  _tail must be an infinite list of ones
15:37:43 <ertesx> and what is 'ones'?
15:37:59 <aeyalcinoglu> a moment
15:38:14 <aeyalcinoglu> ones is a list of infinite ones?
15:38:32 <ertesx> yeah…  let's call it an infinite list of ones, though =)
15:38:53 <ertesx> so if _tail must be an infinite list of ones, and 'ones' is an infinite list of ones…  how do you feel about _tail = ones?
15:39:01 <ertesx> ones = 1 : ones
15:39:19 <aeyalcinoglu> yes okay
15:39:26 <ertesx> @let ones = 1 : ones
15:39:27 <lambdabot>  Defined.
15:39:30 <ertesx> > ones
15:39:31 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:39:40 <ertesx> did that make sense?
15:39:52 <aeyalcinoglu> yes
15:40:16 <ertesx> let's see why that works by pattern-matching on 'ones'
15:40:54 <ertesx> case ones of { [] -> "empty"; x : xs -> "non-empty" }
15:41:27 <ertesx> in this pattern-match…  what do you think?  which case will occur?  the [] case or the x : xs case?
15:41:42 <aeyalcinoglu> [] case?
15:42:00 <ertesx> are you new to the 'case' construct?
15:42:36 <aeyalcinoglu> this is my first day with haskell, and yes, but no i understand know, it is xs case, sorry
15:43:00 <aeyalcinoglu> i understand know = I understand now
15:43:54 <ertesx> pattern-matching means: you have a subject value (in this case 'ones') and you want to see of what form it is…  because ones = 1 : ones, it is of the form (x : xs)
15:44:13 <ertesx> so we will get "non-empty"
15:44:22 <ertesx> > case ones of { [] -> "empty"; x : xs -> "non-empty" }
15:44:23 <lambdabot>  "non-empty"
15:44:41 <aeyalcinoglu> okay
15:44:58 <ertesx> what is x in this case?
15:45:19 <aeyalcinoglu> 1?
15:46:00 <ertesx> don't ask, answer…  if something makes sense to you, it's probably correct, because haskell is very logical =)
15:46:10 <ertesx> but yes, x = 1
15:46:20 <ertesx> and xs = ?
15:47:06 <aeyalcinoglu> my real thought: in the first step xs is only [1]
15:47:25 <ertesx> look at the definition:  ones = 1 : ones
15:47:34 <ertesx> now match 'ones' against the pattern x : xs
15:47:38 <ertesx> what is xs?
15:47:43 <aeyalcinoglu> ones
15:47:48 <aeyalcinoglu> okay but this is not learning
15:47:49 <ertesx> yes!
15:47:57 <aeyalcinoglu> i m sorry, you put a real hard work for me
15:48:11 <aeyalcinoglu> but i should read some concepts by myself first i think
15:48:35 <aeyalcinoglu> but this is just a feedback
15:48:52 <aeyalcinoglu> i still want you to continue and come back to question (fib)
15:48:55 <ertesx> most of haskell is built on defining and then pattern-matching…  at least the implementation part of it
15:49:11 <ksf> aeyalcinoglu, I think your problem with understanding is not that it's too hard, it's that you're not expecting it to be *that bloody easy*.
15:49:14 <ertesx> of course you won't do it as low-level as this for the most part
15:49:48 <ertesx> aeyalcinoglu: now…  let's define a function 'intsFrom'
15:50:00 <ertesx> intsFrom 5 = 5 : 6 : 7 : 8 : 9 : ...
15:50:18 <ksf> there's a lot of stuff in most programming languages that would go into defining something like an infinite list (when do things get produced? how do i not run out of memory), whereas in haskell, due to laziness, all that comes for free.
15:50:28 <ertesx> (after that you're ready to define the list of all fibonacci numbers)
15:51:19 <aeyalcinoglu> after what?
15:51:25 <ertesx> after intsFrom
15:51:34 <Xandaros> It's very similar to recursion. You just use itself as if it was completely defined and it just works
15:51:55 <ksf> it is the exact same thing as recursion, in fact.
15:52:00 <aeyalcinoglu> okay
15:52:04 <ertesx> aeyalcinoglu: intsFrom x = _def  -- of what form is _def?  [] or (_head : _tail)?
15:52:22 <aeyalcinoglu> second one
15:52:34 <ertesx> intsFrom x = _head : _tail  -- what is _head?
15:52:48 <aeyalcinoglu> okay i got this
15:52:54 <ertesx> try it yourself =)
15:53:04 <aeyalcinoglu> how can we continue from here to fibonacci
15:53:28 <ertesx> first define this one…  if you can do it, it should already be somewhat clear how to go there
15:53:37 <aeyalcinoglu> okay
15:53:48 <aeyalcinoglu> really thank you
15:53:55 <aeyalcinoglu> for your time
15:54:14 <ertesx> no worries…  we have 4 days of weekend here =)
15:56:34 <dalcde> k
16:07:38 <aeyalcinoglu> ertesx: i did it :)
16:08:36 <ertesx> aeyalcinoglu: would you mind showing it?
16:12:34 <MarcelineVQ> whatever node he was on dropped him
16:15:25 <aeyalcinoglu> hey i couldnt read your response my pc crached
16:17:15 <chattered> Pretty niche, but does anyone have a recommended solution for nice animated 2d vector graphics? I'm currently trying to render Cairo to an SDL surface, but not sure if there are better options.
16:17:43 <ksf> cairo is pretty much standard for vector 2d nowadays.
16:17:54 <chattered> And it'll work okay for simple animations?
16:18:16 <ertesx> aeyalcinoglu: i wrote: would you mind showing it?
16:18:28 <aeyalcinoglu> fib x y = x : fib y (x+y)
16:18:42 <ertesx> aeyalcinoglu: great =)
16:18:53 <aeyalcinoglu> thx!
16:18:53 <Cale> chattered: If you're playing around and want to get stuff on the screen in a hurry, check out gloss
16:19:15 <ertesx> aeyalcinoglu: now comes the dual part: *consuming* that list
16:19:57 <ertesx> aeyalcinoglu: do you feel confident that you could write a function that transforms a list of numbers into a list that stops as soon as a certain threshold is exceeded?
16:20:23 <ertesx> example: takeWhileBelow 5 [2,3,4,5,6,7,8,9] = [2,3,4]
16:20:23 <aeyalcinoglu> yes takeWhile is pretty useful
16:20:34 <ertesx> can you define takeWhile yourself?
16:20:45 <chattered> Cale: Hmmm...I've used that before, and can't remember why I dismissed it. :/
16:21:02 <aeyalcinoglu> i guess so let me try
16:21:08 <aeyalcinoglu> i will come back :)
16:21:32 <ertesx> aeyalcinoglu: call it myTakeWhile or takeWhile'…  have fun =)
16:21:57 <chattered> Cale: Ah, I do want to be able to do fairly arbitrary complex colour fills.
16:22:28 <Cale> ah, okay
16:22:32 <ertesx> chattered: OpenGL (as in e.g. the 'gl' library) too low-level?
16:24:06 <chattered> ertesx: Not necessarily. But I assume the line drawing in OpenGL is going to be much uglier than Cairo.
16:24:30 <ertesx> definitely
16:24:41 <ertesx> and a lot more verbose, too
16:25:18 <ksf> also, cairo has a gl backend.
16:25:46 <ertesx> chattered: see also the 'diagrams' library…  i hear that it can render in real-time these days
16:26:17 <aeyalcinoglu> ertesx: can you give me hint about defining a function from int to bool?
16:26:35 <ertesx> aeyalcinoglu: what should the function do?
16:26:48 <chattered> ksf: Cheers. Will check that out.
16:27:16 <ertesx> chattered: try diagrams → cairo → gl for something very high-level yet powerful
16:27:31 <aeyalcinoglu> ertesx: my sketch: takeWhile' x y = [if y /= [] then z else [] | z <- y, z satisfies x]  but i couldnt write z satisfies x part in haskell
16:27:38 <Job316> is there an idiomatic (flip elem)?
16:27:51 <ertesx> Job316: (`elem` xs)
16:27:56 <chattered> ertesx: I'm using diagrams at the moment, but the animation stuff is a work in progress. I should be able to render out animated gifs, and maybe that'll be good enough for my purposes. But there's no backend I can see that's more flexible out of the box. So I was looking to write a simple one rendering individual frames to an SDL surface.
16:27:57 <Job316> right. Thanks
16:29:56 <ertesx> aeyalcinoglu: 'takeWhile' really has two forms, and you would just put each on its own line in haskell
16:30:29 <ertesx> aeyalcinoglu: takeWhile p [] = _xs  -- in this case the argument list was empty…  what would be the resulting list _xs?
16:31:01 <ksf> error "Use dependent types"
16:31:06 <ertesx> (oh, and call it takeWhile', sorry)
16:31:37 <ksf> oh wait I'm confusing that with plain take.
16:31:44 <monochrom> haha
16:31:45 <ksf> for takeWhile, cutting off the list is actually sane.
16:32:22 <ertesx> chattered: diagrams has a rasterisation backend that you can use to render individual pictures…  then you could use e.g. ffmpeg to create the animated gif
16:32:45 <ertesx> chattered: while developing you can use a different backend like cairo, so that you get a live preview
16:32:50 <chattered> ertesx: Yeah, I might make that my fallback. 
16:33:05 <aeyalcinoglu> ertesx: []
16:33:06 <camm> Hey guys. If I have a function "a -> IO (Maybe b)". How can I apply it to a "Maybe a", so that I can get "IO (Nothing)" when "Maybe a" is Nothing. I'm not sure if there is a funciton for that, and I don't want to use pattern matching (because, I'm already using it xP). 
16:33:19 <ertesx> aeyalcinoglu: correct…  now for the non-empty case:
16:33:21 <chattered> ertesx: I was hoping to be able to produce animations with a bit more programmatic control.
16:33:37 <ksf> camm, you can't. "Nothing" is not a type.
16:33:41 <chattered> The stuff I want to animate is machine generated.
16:34:10 <ksf> you can have plain IO (), though, which is an IO action that doesn't return anything useful.
16:34:31 <ertesx> aeyalcinoglu: takeWhile' p (x : xs) = _xs  -- now _xs can be of two forms depending on whether the predicate 'p' was satisfied on the head 'x'…  does that make sense?
16:34:55 <aeyalcinoglu> yes
16:35:05 <verement> camm: maybe (return Nothing) _func _value
16:35:18 <ertesx> aeyalcinoglu: since "predicate" is really just "function to bool", a simple way is to use 'if'
16:35:33 <ertesx> aeyalcinoglu: takeWhile' p (x : xs) = if p x then _xsYes else _xsNo
16:36:08 <ertesx> aeyalcinoglu: if the predicate did *not* match, what's the result?  i.e. what is _xsNo?
16:36:26 <aeyalcinoglu> []
16:36:56 <ertesx> aeyalcinoglu: takeWhile' p (x : xs) = if p x then _xsYes else []  -- if it did match, of what form is the result?  i'm not giving you templates this time
16:37:11 <ertesx> _xsYes = ?
16:38:39 <aeyalcinoglu> I'm sorry it will take a while for me to answer
16:38:51 <ertesx> aeyalcinoglu: take your time
16:39:07 <ertesx> aeyalcinoglu: but revisit other times i've asked the "of what form" question =)
16:40:54 <camm> Thanks verement
16:40:58 <camm> It worked.
16:41:06 <verement> np
16:42:24 <aeyalcinoglu> ertesx: i m not sure but a guess: head xs?
16:42:48 <ertesx> aeyalcinoglu: nope…  what's the type of the result?  is it a number?  a list?  a function?
16:44:09 <aeyalcinoglu> it must be a list
16:44:17 <ertesx> aeyalcinoglu: good…  lists only come in two forms:  either [] or …?
16:44:37 <aeyalcinoglu> "NonEmpty"?
16:44:55 <ertesx> that's correct prose, but not the correct form =)
16:45:05 <ertesx> look:  1 : 2 : 3 : 4 : []
16:46:47 <monochrom> add parentheses. 1 : (2 : (3 : (4 : [])))
16:49:35 <ertesx> aeyalcinoglu: you can see the two possible forms in monochrom's expansion:  a list is either of the form [] or of the form (_head : _tail), where _head is the first element and _tail is the remaining list
16:50:57 <monochrom> basic list algorithms are case-splits on those two cases
16:53:10 <NaOH> Hi, a question from a begginer: I have a type constructor "data A a = A [a] a" , and I have a synonym "type B a = A (A a)". Having it as a synonym means that I can have a function g :: A a -> A a and an f :: B a -> B a and say f = g without issue. However I now want B to have a different instance of some typeclass, but changing "type B..." to "newtype B.." breaks all the functions I had previously defined.
16:53:18 <NaOH> is there some middle ground where I can either define a different instance for B without creating a different type, or define some kind of specialization of a general function f :: A a -> A a for the case where a is A a?
16:54:13 <aeyalcinoglu> ertesx: thanks for everything i should go in the middle of a question because it is 3 am here :)
16:54:44 <ertesx> NaOH: nope, sorry, but many algorithms can be defined in terms of generic combinators, which could make it easier
16:54:47 <ksf> NaOH, overlapping instances should work but you generally don't want to use them unless you really *need* to.
16:55:53 <ksf> because overlap leads to undecidable, and undecidable leads to incoherent, and once you're incoherent you're lost on the dark side forever.
16:58:16 <ertesx> NaOH: in cases when there are no generic combinators for your use case you can define a function that exposes the isomorphism…  that replaces "unwrap, then f, then wrap" by "withUnwrapped f"
16:58:32 <NaOH> ksf: thanks, then I guess I will try to avoid that
16:58:46 <NaOH> ertesx: with generic combinators do you mean Generics.Pointless.Combinators?
16:59:23 <ertesx> NaOH: oh, no, i mean "generic" in the sense of "general":  Functor, Foldable, Traversable, Applicative, …
17:00:48 <ertesx> NaOH: perhaps with a more specific description of your use-case we could give a better answer
17:03:53 <NaOH> ertesx: I think I understand what you mean: where I had a function from B a to B a, I take that as an argument to "withUnwrapped f" where "withUnwrapped" takes the B a value, extracts the A (A a) value pattern matching with the B constructor, applies the argument to it, and then constructs a new B containing the new A (A a)
17:04:45 <NaOH> so all I have to do is add "withUnwrapped f " to all my previously defined functions
17:05:43 <NaOH> and withUnwrapped B(someA) g = B(g someA)
17:06:08 <NaOH> sorry, B(someA) should be (B someA)
17:06:40 <NaOH> ok, I will not bother you, I will try that and if it doesn't work will think a little bit more ;)
17:07:36 <ertesx> NaOH: let's say: newtype WrappedInt = WrappedInt Int
17:07:49 <ertesx> NaOH: withUnwrapped :: (Int -> Int) -> WrappedInt -> WrappedInt
17:08:15 <ertesx> or more generally: withUnwrapped :: (Functor f) => (Int -> f Int) -> WrappedInt -> f WrappedInt
17:08:47 <ertesx> when f = Identity, this is just the former, less general variant
17:08:54 <tippenein> anyone get stylish-haskell crashing vim on save?
17:09:51 <ertesx> NaOH: that's just a little convenience function that gets rid of the 'WrappedInt . f . fromWrappedInt' pattern
17:10:02 <tippenein> @type bracket
17:10:04 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:11:22 <NaOH> ertesx: Thanks! I will try it out
17:37:03 <NaOH> ertesx: another question, wrapping and unwrapping like you proposed would have some overhead associated?
17:37:32 <NaOH> or ernst, I don't recall who was helping me (sorry)
17:42:44 <geekosaur> if it's a newtype then no
17:44:10 <NaOH> ok, thanks
17:44:19 <Axman6> no* (the new coersion stuff exists because newtypes can introduce performance problems in situations where some computation isn't actually necessary)
17:45:19 <Axman6> the typical example is something like map Sum [1..100] - the machine representation of [Int] and [Sum Int] is exactly the same, but without coersion the map still traverses the list while doing no actual work
17:59:01 * hackagebot foldl 1.2.0 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.2.0 (GabrielGonzalez)
18:05:39 <joeyh_> I have some code that compiles with or without PolyKinds, but only works as intended when built with PolyKinds. Urk.
18:14:18 * koomi recently had some code that compiled fine on 7.10.3, didn't typecheck on 7.10.1, and infite looped on 7.6.3 unless compiled with -O0
18:15:03 <koomi> using singletons
18:20:35 <joeyh_> cooincendtialy, my code also uses singletons
18:20:51 <joeyh_> the relevant constraint looks like (MetaTypes metatypes' ~ (+) HasInfo metatypes, SingI metatypes')
18:24:31 <zRecursive> @hoogle System.Random
18:24:34 <lambdabot> System.Random class Random a
18:24:34 <lambdabot> System.Random module System.Random
18:24:34 <lambdabot> package Random123
18:25:18 <zRecursive> whther or not i need to `cabal install Random123` ?
18:27:15 <geekosaur> the usual System.Random is in http://hackage.haskell.org/package/random
18:28:04 <zRecursive> geekosaur: then lambdabot doesnot give such a package ?
18:28:21 <geekosaur> I have no idea what hoogle is doing there
18:29:14 <zRecursive> I actually first heard of Random123 .
18:29:34 <geekosaur> hm, hayoo also shows pretty much everything but the normal random package in the first page of results. sigh
18:29:51 <zRecursive> @package random
18:29:52 <lambdabot> http://hackage.haskell.org/package/random
18:30:03 <zRecursive> @package random123
18:30:04 <lambdabot> http://hackage.haskell.org/package/random123
18:30:30 <geekosaur> oh, if I just sayy "System.Random" instead of "module System.Random" then I get the standard one first
18:30:33 <zRecursive> I am curious which one do we need to use ?
18:30:35 <geekosaur> http://hayoo.fh-wedel.de/?query=System.Random
18:31:00 <geekosaur> note that random123 says it provides stuff under System.Random.Random123
18:31:09 <geekosaur> *not* directly under System.Random
18:31:55 <zRecursive> I will use random first.
18:40:21 <Job316> is there a better way to write (\(a,_) (b,_) -> compare a b) for sortBy?
18:41:45 <geekosaur> :t comparing fst
18:41:48 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
18:41:54 <Job316> :t comparing
18:41:55 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
18:42:07 <Job316> oh clever
18:42:21 <geekosaur> and then there's the more general version
18:42:22 <geekosaur> :t on
18:42:23 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:42:31 <Ralith> :t sortOn
18:42:32 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
18:44:02 * hackagebot jose 0.4.0.0 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.4.0.0 (frasertweedale)
18:54:29 <nak> is there a way to make lambdabot show intermediate steps for @pl ?
18:55:08 <Cale> nak: no, but maybe there's a way to make the thing which it's using to implement @pl show the intermediate steps
18:56:17 <nak> Cale what is it using ?
18:56:41 <maerwald> @hackage pointfree
18:56:42 <lambdabot> http://hackage.haskell.org/package/pointfree
18:57:09 <qqs> What's the practice around colliding module names? There's a H98 indexed monads package. If I want to make a non-H98 version, should I just let the names collide or call mine something like 'Control.Monad.Indexed.Fancy'?
18:57:20 <nak> Cale maerwald thank you
18:59:06 <ertesx> qqs: if you think it would be absurd for someone to use both packages in any way (remember that dependencies are transitive), then you can reuse the module name, but using a different one is always the safer choice
18:59:16 <numee> nak: shoe me an expression and i'll give you a point-free'ed verion of it with detailed steps
18:59:44 <numee> *show
18:59:48 <ertesx> qqs: GHC has -XPackageImports, which can help resolve such a conflict, but as a library user i hope never to encounter a use case for it
19:00:07 <nak> numee i was just reading here: http://stackoverflow.com/questions/15029843/how-can-i-understand
19:00:31 <qqs> ertesx: oh, I didn't know about -XPackageImports. It is the transitive dependencies part that makes me worry. Thanks
19:00:36 <nak> numee I think @Vitus's answer is very good as it shows how the expression is derived from a need
19:01:35 <nak> some of the techniques he used were helpful for me, and i thought it would be cool to see the intermediate steps for many point-free reductions
19:01:42 <nak> he/she*
19:02:18 <nak> and sure enough, @pl gets it right
19:02:37 <nak> @pl \f g x y -> f (g x y)
19:02:37 <lambdabot> (.) . (.)
19:03:07 <nak> i was also curious if pl takes other steps that get to the derived answer quicker, etc
19:03:11 <nak> numee that's all ^_^
19:03:34 <numee> nak: i got it
19:05:27 <ertesx> numee: \a b c d e f -> f (e d c b a) (d c b a) (c b a) (b a) a
19:10:29 <maerwald> nak: yeah, it's nice for learning purposes, but not so nice when your code is full of such "smarties" :P
19:11:02 <maerwald> do what is more readable, whether that's pointfree or pointful depends on the context
19:14:50 <nak>  maerwald yeah i'm there with you
19:15:19 <nak> my initial internal reaction to the question was "if it makes your brain hurt so bad, don't bother using it"
19:16:50 <nak> I think vitus did a great job of basically showing that (.) . (.) comes from a pretty simple need
19:17:18 <Cale> I tend to think of (.) . (.) as a specialisation of fmap . fmap
19:17:24 <Cale> :t fmap . fmap
19:17:26 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:18:09 <maerwald> which is already a lot more readable and doesn't look like a sleeping bear
19:18:10 <Cale> If you pick f t = e -> t and f1 t = e' -> t, say, that becomes (a -> b) -> (e -> e' -> a) -> (e -> e' -> b)
19:18:18 <nak> Cale i now just see it as compose a binary function with a unary one
19:18:30 <nak> @pl f g x y -> f (g x y)
19:18:30 <lambdabot> (line 1, column 11):
19:18:30 <lambdabot> unexpected '>'
19:18:32 <lambdabot> expecting operator
19:18:34 <nak> @pl \f g x y -> f (g x y)
19:18:34 <lambdabot> (.) . (.)
19:18:38 <nak> @pl \f g x y z -> f (g x y z)
19:18:38 <lambdabot> (.) . (.) . (.)
19:18:52 <nak> seeing that pattern really helps me
19:19:44 <nak> Cale but yeah, the fmap . fmap is very helpful too
19:19:58 <nak> my brain doesn't relate one to the other qutie so easily tho
19:20:40 <Cale> fmap f x applies a function f :: a -> b to the "elements" of whatever sort of structure x :: f a is -- in the case of a function, you might imagine a function (e -> a) as being like a container indexed by values of type e, holding elements of type a
19:21:25 <Cale> and so fmap :: (a -> b) -> (e -> a) -> (e -> b) just amounts to function composition
19:22:10 <nak> i think i get it 
19:22:14 <nak> but isn't like
19:22:15 <Cale> (fmap . fmap) f then digs another layer deep, and applies f to the elements of the elements
19:22:44 <Cale> Which in the case of functions, just means the same thing as applying f to the result of a two-parameter function
19:22:47 <nak> when you have two functors nested like that, isn't fmap.fmap necessary to transform the inner most value ?
19:22:57 <Cale> yeah, that's what it's doing
19:23:08 <Cale> (fmap . fmap) f x = fmap (fmap f) x
19:23:39 <nitrix> Hi, I'm looking for a key-value data structure, where the key is a 2D point and the ability to extract any region (rectangle) in a nice logarithmic time.
19:23:46 <nitrix> I tried using Map with this definition:
19:23:57 <nak> cale ah ok i think i'm following you now
19:24:11 <Cale> nitrix: quadtree?
19:24:16 <nitrix> instance Ord Coordinate where     c1 `compare` c2 = let ((P(V2 x1 y1)), (P(V2 x2 y2))) = (getCoordinate c1, getCoordinate c2) in if x1 == x2 && y1 == y2 then EQ else (if x1 >= x2 && y1 >= y2 then GT else LT)
19:24:16 <phaskell-1> V2: What DNS naming convention should we use for GHC buildbots? Come Vote https://phabricator.haskell.org/V2
19:24:37 <nitrix> Cale: I'm using vectors of :: V2 Integer, if you know the Linear package.
19:25:03 <nitrix> Cale: Quadtrees aren't infinite and the ones that are uses floating point I believe.
19:25:15 <nitrix> I'd love to be proven wrong though.
19:25:20 <Cale> phaskell-1: that poll is closed apparently
19:25:42 <Cale> nitrix: Neither are Maps...
19:25:46 <nitrix> Cale: I have a question though.
19:26:46 <nitrix> Cale: With this Ord instance, I've spent the day debugging a problem where a map initiazed from a list of pairs (key-values), gives me no result during a `lookup`. Even though the element really exists.
19:27:04 <nitrix> Cale: I believe this means my Ord instance is broken and the tree it builds makes no sense?
19:28:07 <Cale> nitrix: That "ordering" isn't antisymmetric
19:28:32 <Cale> So it's not a valid instance of Ord
19:28:36 <nitrix> I see.
19:28:48 <nitrix> Cale: Do you mind if I explain what I was trying to achieve with that? Maybe it'd be easier.
19:28:48 <Cale> Consider, e.g. (1,0) and (0,1)
19:28:54 <Cale> each is less than the other
19:28:57 <Cale> but they are not equal
19:29:40 <ertes> you don't need fork bombs when you have GHC…
19:31:10 <ertes> asking for the type of this just crashed my system, so do not try this at home: let f = join (,); g=f.f; h=g.g; i=h.h; j=i.i; k=j.j in k
19:31:23 <nitrix> Cale: It all started because I'm getting bad perfances in my game with too many elements. So I looked at Data.Map and there's a `split` function that lets you partition the map based on a key. And it's O(log n) ! I figured, brilliant, if I define a clever instance of Ord, I can do 3 (or 4) crops on that map and get any square region of the map. (Actual map coordinates, I'm storing map coordinates in my Map)
19:31:24 <nitrix> :P
19:32:06 <numee> ertes: the expression is too long i gave up here: \a b c d -> flip (flip . flip flip (b a) . flip flip (c b a) . (flip flip (d c b a) . (flip id . flip (flip (flip (flip id d) c) b) a))) a
19:32:32 <numee> i just removed last two arguments but still four remain...
19:32:35 <Cale> nitrix: You could use a Map of Maps
19:32:39 <ertes> numee: lambdabot generates pages of code for that one =)
19:32:56 <undoall_> ertes: I SHOULD'VE LISTENED
19:33:24 <Cale> nitrix: However, that may still involve doing more work than you'd really care to do
19:34:05 <nitrix> Cale: It's all wrapped into a newtype and a module. It's doing fancier stuff with Bimaps too.
19:34:08 <Cale> (you have to e.g. split out the columns you're interested in, and then split out the part of each column that you want from there)
19:34:17 <nitrix> I wouldn't mind it being complicated, I just want it to work :(
19:34:20 * hackagebot persona 0.2.0.0 - Persona (BrowserID) library  https://hackage.haskell.org/package/persona-0.2.0.0 (frasertweedale)
19:36:06 <nitrix> Cale: I think that's what I'll do.   data Grid a = Map a (Map a)  ?
19:36:12 <nitrix> Whoops
19:36:26 <nitrix> data Grid a b = Map a (Map a b)
19:36:39 <Cale> Yeah, it's not as good as a more refined sort of spatial partitioning tree
19:36:45 <Cale> But it might do
19:36:59 <nitrix> Does Haskell handle maps of maps nicely?
19:37:06 <Cale> It'll work fine
19:37:14 <nitrix> Even as :: a ~ Integer ?
19:37:40 <ertes> nitrix: more or less…  Map is quite heavy in memory
19:38:23 <nitrix> Well, I guess my priority should be to have an actual optimization that works rather than my current bogus one.
19:38:33 <nitrix> I'll implement that then.
19:38:46 <nitrix> Cale: Any recommendation of spatial partitioning other than quadtree?
19:39:07 <ertes> nitrix: you could implement actual space partitioning…  k-d-trees are very simple to implement
19:39:19 <ertes> they are a special case of BSP
19:40:03 <nitrix> ertes: My constraint is that I'm working with keys that are Integer.
19:40:35 <nitrix> Quadtree seemed problematic because it (as far as I understand), they're bound to a maximum value and, then, subdivided.
19:41:20 <Cale> http://hackage.haskell.org/package/kdt looks possibly decent
19:41:23 <stoopkid> anybody know of a unification procedure that operates on chain complexes rather than strings/graphs ?
19:41:35 <Cale> There are a few other packages
19:41:48 <maerwald> I'd just write it myself, they are both trivial in haskell
19:42:08 <maerwald> kd-tree/quadtree I mean
19:42:12 <ertes> nitrix: one way is to have a Map Integer Int and a KdTree V3 Int, then a Vector or something else of actual objects
19:42:12 <phaskell-1> V3: What DNS naming convention should we use for GHC buildbots? Come Vote https://phabricator.haskell.org/V3
19:42:30 <ertes> nitrix: if you need to index by those Integers
19:42:53 <Cale> Well, I dunno... that's the kind of thing where some hand-tuning goes a long way, and I have no idea how mature any of these packages are (they don't appear to have very high version numbers...)
19:45:04 <zRecursive> `ghc-pkg list|grep -i array` => array-0.5.1.0, however, any module uses array will reports "ghc.exe: unable to load package `array-0.5.1.0'" . it is same as other module(s).
19:46:40 <nitrix> Cale: ertes I'll go with the double map to at least make it work, then read on the subject and replace the module.
19:46:54 <nitrix> Cale: ertes Thanks for the help; very appreciated.
19:48:27 <ertes> nitrix: if you're going with that one, (Map (a, a) b) will use less memory
19:48:56 <ertes> and it's probably faster, two, because it keeps the overall structure balanced
19:49:00 <nitrix> ertes: If I do (a,a) then I can't do `split`.
19:49:04 <ertes> s/two/too/
19:49:56 <ertes> nitrix: compare (x1, y1) (x2, y2) = compare x1 x2 <> compare y1 y2
19:50:36 <nitrix> ertes: It's the map of a video game, it stores coordinates as keys and objects as values. My goal is to be able to pull out any region of the from the data-structure.
19:50:39 <undoall_> ...huh, I didn't know Ordering was a monoid
19:50:56 <Clint> now you know
19:51:12 <MarcelineVQ> and knowing is half the battle
19:51:13 <nitrix> ertes: Given bounds. I tried writing my own Ord instance but apparently my implementation is "antisymmetric".
19:53:27 <ertes> nitrix: are you trying to do voxels or something similar?
19:54:06 <nitrix> ertes: More or less, it's rogue-like, like Dwarf Fortress. Just an infinite world.
19:55:20 <nitrix> ertes: If don't know if you've seen what I wrote, but when I saw `split` O(log n), I thought I could think of a clever Ord instance and then do a few (maybe 4) split on the Map to get any region I wanted.
19:55:34 <zRecursive> it is seems ghc-7.10.3 cannot use any installed packages on windows ?!
19:56:07 <ertes> nitrix: and you want to limit what you get to objects that are actually there?
19:56:23 <ertes> so you don't get a vector of mostly empty tiles
19:56:52 <nitrix> ertes: Yeah, my goal is obviously to keep the things stored in that map small and progressively insert and remove things as you move around, but I still have to keep quite a lot due to zoom level.
19:57:17 <ertes> nitrix: can you go with Int rather than Integer?
19:57:32 <nitrix> ertes: So depending on your zoom level, I'd like to crop any rectangle (given a 2D coordinate, width and height) and display just that.
19:57:48 <nitrix> Right now, I'm doing O(log n) * amountOfTilesOnScreen lookups, and it's painful.
19:57:57 <nitrix> ertes: Nope :P
19:58:34 <Cale> nitrix: yeah, the nested maps will cut it to something more like O(log n) * width in tiles of screen
19:59:21 <ertes> nitrix: then i'd go with an object registry (HashMap Integer T) and an accompanying k-d-tree that stores indices
19:59:34 <nitrix> Cale: Not even smaller?
20:00:46 <nitrix> Cale: I was hoping to do two splits on the map for the X axis and two more splits on the map for the Y axis.
20:01:15 <nitrix> O(log n) * 4 to get any rectangle of the game's map.
20:01:57 <ertes> nitrix: with the nested maps you're going to do one of the splits for every submap
20:02:39 <ertes> split top-level map (2 splits), then split each resulting sub-map (2*numberOfSubMaps)
20:02:43 <Axman6> zRecursive: can you elaborate on your problem? if you just upgraded GHC then it cannot use libraries installed by an older version
20:04:26 <nitrix> So Cale is right, O(log n) * height + 2.
20:04:29 <Fylwind> I think Haskell needs an equivalent of https://github.com/JuanitoFatas/what-do-you-call-this-in-ruby
20:05:04 <nitrix> ertes: That seems fairly bad x]
20:05:15 <nitrix> It's better than what I currently have though...
20:05:28 <ertes> nitrix: you need space partitioning to get below linear
20:06:31 <zRecursive> Axman6: Both ghc-7.10.3-i386-unknown-mingw32.tar.xz and cabal-1.22.0.0-i386-unknown-mingw32.tar.gz are just installed on a windows XP box
20:08:33 <Axman6> zRecursive: and what problem are you having
20:10:18 <zRecursive> then i `cabal configure` , `cabal build`, `cabal install` on a test module, all is ok. `ghc-pkg list` can find the module. But once i call its exported function in ghci, it will reports "ghc.exe cannot find some already existed module"
20:10:46 <zRecursive> such as array, time,etc.
20:12:13 <zRecursive> Axman6: it is odd. i never encounter such a problem on freebsd or linux.
20:12:32 <Axman6> no me either. XP is a pretty strange OS to be using =)
20:13:31 <zRecursive> Axman6: can we instruct ghci to find out those system packages ?
20:13:36 <Axman6> zRecursive: have you tried using stack? not sure if it supports XP
20:14:08 <visual_basic_man> hi all
20:14:23 <zRecursive> Axman6: i just heard of stack, but i donot know it well
20:16:50 <zRecursive> Axman6: ghc.exe: unable to load package `time-1.5.0.1', \nghc.exe: C:\haskell\ghc-7.10.3\lib\time_IYbjC7tGONY15oDy1fGJKz\HStime-1.5.0.1-IYbjC7tGONY15oDy1fGJKz.o: unknown symbol `__localtime32'
20:17:30 <zRecursive> oh, frustrated now :(
20:19:16 <Axman6> yeah sorry I have no experience fixing these problems on windows
20:21:55 <zRecursive> welcome!
20:26:40 <nitrix> ertes: I'm looking up kd-trees, it's definitely very very promising.
20:27:43 <nitrix> ertes: It's essentially a binary tree, I get that you can easily lookup any coordinate, I'm a little more curious about how does one isolate a rectangle and obtain all the points within those.
20:28:11 <nitrix> Because your arbitrary rectangle wont happen to necessarily match any of the cuts made to the space by the kd-tree.
20:29:01 <nitrix> But I can sort of imagine it.
20:32:04 <visual_basic_man> is there anything ismilar to flat-mcmc? on hackage? but newer/less bit-rotted/better?
20:33:36 <Axman6> visual_basic_man: what is flat-mcmc?
20:34:10 <visual_basic_man> Axman6 http://jtobin.ca/flat-mcmc/
20:34:59 <nitrix> ertes: I think I understand now. You search for coordinates in the range between [X1..X2] by doing a lookup of both in the kdtree. At some point your lookup will div
20:35:47 <nitrix> ertes: diverge. and then you can just start listing what's >X1 and <X2.
20:35:50 <nitrix> o:
20:36:48 <Axman6> visual_basic_man: does it not compile?
20:37:08 <visual_basic_man> general sampling (mostly for bayesian inference)
20:37:40 <visual_basic_man> Axman6 the dependencies are a bit crufty though i'm tinkering with stack to get it to build now
20:38:01 <Axman6> make sure you submit a pull request once it's working! ;)
20:46:06 <ertes> nitrix: pretty much, yeah…  basically you allow extra elements while splitting, then you just discard the extra
20:46:23 <nitrix> ertes: Gotcha.
20:46:37 <nitrix> ertes: This will work out; pretty hyped up for tomorrow :]
20:46:46 <nitrix> Cheers, and good night :)
20:47:05 <ertes> nitrix: alternatively you can cut to single element leaves, though that'll likely be unnecessarily expensive
20:47:11 <ertes> g'night =)
20:48:41 <lethjakman> https://gist.github.com/lethjakman/b46bedd386da03e6f18d
20:48:46 <lethjakman> Is there a better type safe way of doing this?
20:49:48 <ertes> lethjakman: what don't you like about that one?
20:50:03 <lethjakman> ertes: If someone passes something in that doesn't match it'll fail...no?
20:50:27 <ertes> lethjakman: no, they'll get a type error
20:50:35 <ertes> you handled all cases there
20:50:54 <lethjakman> Oh, derp. 
20:50:57 <lethjakman> I see. 
20:51:04 <lethjakman> I did it right then. 
20:51:08 <lethjakman> Sorry. 
21:02:22 <Job316> anyone have any experience with scotty?
21:03:39 <caconym> i have used it a little
21:04:33 <caconym> have a specific question? in general I do like it, it's simple and lightweight and works
21:09:01 <Job316> yeah - just starting with it. http://lpaste.net/157117
21:09:12 <Job316> I'm trying to get a parameter to be parsable to an int
21:09:21 <Job316> but am not sure how to do it
21:11:44 <caconym> i think you should do `num <- param "num" :: ActionM Int`
21:12:12 <caconym> looks like there is a typeclass `Parseable` that's included with Scotty
21:12:36 <caconym> oh actually, i may have misunderstood the issue here
21:12:45 <caconym> what error do you get?
21:13:23 <Job316>  Couldn't match expected type Data.Text.Internal.Lazy.Text with actual type Int
21:13:38 <Job316> In the first argument of (+), namely num ,  In the second argument of ($), namely (num + 1)
21:14:40 <Job316> you can thow a show() around the num +1 and you get    Couldn't match type [Char] with Data.Text.Internal.Lazy.Text
21:14:50 <Job316> is this overloadedstrings hell?
21:15:42 <caconym> oh
21:15:56 <caconym> i think maybe `html` wants a Text?
21:16:06 <caconym> html :: Text -> ActionM ()
21:16:19 <caconym> :t show
21:16:20 <lambdabot> Show a => a -> String
21:16:30 <Job316> tried that one moment
21:17:33 <Job316> got this: http://lpaste.net/157118
21:18:14 <caconym> i think the type you're passing to `html` on line 14 is still wrong
21:18:34 <caconym> show (num + 1) :: String
21:18:46 <caconym> html :: Text -> ActionM ()
21:19:17 <caconym> OverloadedStrings won't save you from needing to convert your String to a Text
21:19:39 <Job316> ahhh. what's the right way to do that?
21:19:55 <Job316> pack
21:20:02 <caconym> yeah, that will do it
21:20:17 <caconym> more generally, this may not be a great practice but it sure is handy: https://hackage.haskell.org/package/string-conversions-0.4
21:20:27 <Gurkenglas> Is there a global operator precedence table?
21:21:17 <Job316> https://www.haskell.org/onlinereport/decls.html
21:21:18 <Job316> tb2
21:22:57 <Job316> and check fixity for any infix operators that you add w/ :i in ghci - eg :i (>>=)
21:23:11 <Job316> infixl 1 >>=
21:24:55 <Job316> tried pack, didn't quite do it. Getting a weird result: http://lpaste.net/157119
21:25:47 <Gurkenglas> Why isn't there Alternative f => Witherable f?
21:27:01 <caconym> Job316: see https://hackage.haskell.org/package/text-1.2.1.1/docs/Data-Text.html#g:1
21:27:26 <caconym> i think you're grabbing the strict one, where scotty expects the lazy one?
21:27:37 <Job316> ohhh let me try
21:27:45 <caconym> which is basically the most annoying thing ever
21:28:10 <Job316> That did it!
21:28:12 <Job316> thanks
21:28:22 <caconym> np
21:28:53 <caconym> also since you just had a bad time with types in scotty, maybe you'd like servant :)
21:30:39 <Job316> i will poke around with it
21:30:48 <Job316> trying to decide which one to use now
21:31:22 <caconym> steeper learning curve but in my limited experience you end up with way less boilerplate ingesting and validating the route/query params, req body, etc.
21:37:57 <joeyh_> ghc tells me the type signature of a function involves forall (k :: BOX) .. I tried pasting what it said into my code, and it rejects it
21:38:54 <joeyh_> doing some stuff with singletons, and this function specifically uses fromSing, and I am having trouble getting the constraints satisfied. although the code does build w/o an explicit signature
21:40:37 <johnw> joeyh_: I'd need to see the code to help
21:43:17 <joeyh_> johnw: http://lpaste.net/157120
21:44:38 <johnw> do you have PolyKinds on?
21:45:26 <johnw> and do you have ScopedTypeVariables on?
21:45:39 <joeyh_> yes to both
21:45:42 <johnw> ok
21:45:54 <johnw> if you paste in the signature, drop the two BOX variables
21:46:12 <joeyh_> so, just omit from from the forall?
21:46:14 <johnw> yeah
21:47:07 <joeyh_> that gets "The type variable ‘t0’ is ambiguous"
21:47:32 <johnw> interesting, can you show me that error?
21:48:55 <joeyh_> http://lpaste.net/157120 updated with the error
21:49:31 <joeyh_> and, that looks very much like the error I get if I use my hand-crafted signature and add the constraint DemoteRep 'KProxy ~ [MetaType]
21:50:19 <johnw> it looks like there is a declared t MetaType, and then an inferred one
21:50:36 <johnw> and something is causing them to be distinguished
21:50:50 <johnw> I don't know enough about this code to be of anymore help, I'm afraid
21:51:02 <joeyh_> fwiw, metatype is an alias for SIng
21:51:14 <joeyh_> I can show whole code if you're interested
21:51:42 <joeyh_> mostly, thoughts this is kind of weird that I can't seem to use the inferred signature
21:52:24 <joeyh_> er, ignore "metatype is an alias for SIng"
21:52:44 * joeyh_ will check if the code works, that might provide a clue ;)
21:57:05 <joeyh_> oh, I found a simpler case of the same problem: matchingTarget m (Property t _ _ _ _) = m `elem` fromSing t
22:07:18 <joeyh_> hmm, I think the code builds, but does not actually work
22:08:48 <johnw> hmm
22:20:08 * hackagebot apiary 2.0.0 - Simple and type safe web framework that generate web API documentation.  https://hackage.haskell.org/package/apiary-2.0.0 (winterland)
22:20:53 <joeyh_> here's a fully standalone test case: http://lpaste.net/157123
22:28:05 <Job316> is the line import Prelude ever necessary?
22:28:19 <joeyh_> aha, I can get the same behavior using the regular singletons library too
22:29:31 <Axman6> Job316: it can be, particularly if you're writing an Prelude alternative, or using NoImplicitPrelude
22:33:10 <joeyh_> johnw: http://stackoverflow.com/questions/36256557/what-is-the-type-of-matches-m-s-m-fromsing-s
22:37:34 <Lokathor> that first stage of adding MonadReader into a file is kinda rough
22:39:50 <Cale> Lokathor: Unless you have a really clear plan, that's why I say it's usually not worth it
22:39:55 <Job316> ah
22:40:01 <Job316> Axman6 thanks!
22:40:15 <Lokathor> Cale, I've got a fairly clear plan :3
22:40:38 <Cale> Lokathor: It's best if you can do things in a way which obscures the fact that you're using monad transformers at all
22:41:03 <Lokathor> I feel like MonadReader does that :/
22:41:11 <Cale> Well, sort of
22:41:18 <Lokathor> rather, MonadReader obscures the ordering of your stack
22:41:32 <Cale> It abstracts over the construction of the monad you're using
22:41:55 <Lokathor> right now i'm passing a socket and some other stuff to... well half the program
22:42:07 <Cale> Not just over which over you've applied monad transformers -- so in some sense it does obscure the fact that you're using transformers, because you might've implemented MonadReader directly
22:42:38 <Cale> Except that usually ask/asks isn't exactly the interface you'd have provided if you were just writing a library without monad transformers
22:43:00 <Cale> and usually something a bit more specific is better, I think
22:44:05 <Lokathor> well, there's a few things worth putting into the reader data, most of which aren't used in all parts
22:44:05 <Cale> Like, *maybe* just accessing the socket directly is okay, but perhaps it would be better just to expose operations which act on the socket.
22:44:16 <Lokathor> so i'll probably make a getter for each thing
22:44:21 <Lokathor> and then i can call that when i need to
22:44:31 <Cale> (and so eventually you end up with something that might not actually use a Socket sometimes)
22:44:38 <Lokathor> getSocket = asks _theSocket -- and such
22:45:58 <Cale> Of course, if you're constantly doing fiddly TCP configuration throughout your program, maybe just having a way to get the Socket directly is the best idea.
22:46:19 <Cale> But if you set it up once, and then only need the Socket to do reads and writes, perhaps it would be better to expose those operations instead
22:47:23 <Lokathor> well, really there's just a few parts that need to touch that socket, and most other parts were passing it through
22:47:25 <Lokathor> classic reader
22:47:35 <Lokathor> here's the messily organized code at the moment, https://github.com/Lokathor/ireniko/blob/master/src/Main.hs
22:48:38 <Lokathor> handleMessage, for example, never touches the socket, it just passes it through to sendCommand when that gets used
22:55:22 <loofee> (diminish "rcirc-omit-mode" "o")
22:56:01 <loofee> (diminish 'rcirc-omit-mode "o")
22:56:06 <loofee> (diminish 'rcirc-omit-mode ".o")
22:56:48 <loofee> (diminish 'superword-mode "")
23:00:15 <kadoban> stop that
23:00:38 <loofee> sorry.... wrong channel
23:02:30 <Job316> please no more string implementations kthx
23:04:21 <Lokathor> what a confusing type error
23:07:07 <Lokathor> ha
23:07:18 <Lokathor> liftIO $ putStrLn "foo" and putstrLn "foo" are not the same
23:07:20 <Lokathor> silly
23:08:01 <frase> bitemyapp: I notice you forked jose.  Anything I can help with?
23:20:10 * hackagebot apiary 2.0.1 - Simple and type safe web framework that generate web API documentation.  https://hackage.haskell.org/package/apiary-2.0.1 (winterland)
23:22:09 <zRecursive> c:/cygwin/bin/gcc.exe is in PATH, and C:\haskell\ghc-7.10.3\mingw\bin\gcc.exe isnot in PATH, then which gcc will GHC(cabal) use ?
23:23:28 <saurabhnanda> hey anyone using spacemacs for Haskel dev? Have a bunch of beginner questions.
23:25:13 <shanemikel_> anybody know how to use readline instead of haskeline in ghci?
23:25:36 <saurabhnanda> Wrt spacemacs: (a) why is it so slow? Loading any file leads to a bunch of "Loading Symbols for _______" which take a lot of time. (b) How do I get access to compilation/type error faster? Right now I'm using M-m m c b (which is bound to haskell-process-cabal-build) (c) why does it take so long to display the type when using C-c C-t? (d) Also, a lot of times it says it can't determine the type (and shows a bunch of compilation errors
23:25:36 <saurabhnanda> )
23:26:10 <Lokathor> shanemikel_, that sounds borderline impossible. I'd think that one or the other would be pretty fundamental to the IO system of it
23:26:56 <Lokathor> saurabhnanda, i know folks use spacemacs for haskell stuff, but you should ask in the spacemacs channels for details about why it's slow or not :3
23:27:27 <saurabhnanda> also, what's the debugging story? I've managed to complete my telegram bot, but it's failing with an Sqlite concurrency related error. I probably know what's causing the error, but I want to look at debug logs and stacktraces to be sure (and to also practice debugging a Haskell program) 
23:27:36 <saurabhnanda> Lokathor: thanks
23:28:06 <Lokathor> saurabhnanda, generally one doesn't debug a haskell program quite the same "line by line" way you step through a debugger in other languages
23:28:26 <saurabhnanda> Lokathor: what's the other approach?
23:28:26 <shanemikel_> Lokathor: afaik it used to use readline, and it was replaces with haskeline for licensing issues.. from what I've read online, I'm under the impression that it's possible to revert to readline, but I can't seem to figure out exactly how
23:28:36 <Lokathor> if possible, open ghci and run some expressions. though with a concurrency bug... that'd be obviously not really sensible
23:29:30 <saurabhnanda> https://wiki.haskell.org/Debugging doesn't seem beginner friendly
23:30:01 <Lokathor> i think that a concurrency related debug is going to be super tricky in any language
23:30:25 <Lokathor> though i'm surprised that sqlite can't manage concurrent access to the DB somehow
23:31:57 <saurabhnanda> Lokathor: it can't manage concurrent writes. I think it's the way Persistent's Sqlite library is written. Sqlite acquires a global lock on the DB during any write operation. If another thread tries writing at that time it gets a BUSY kinda response, and most libraries retry a couple of times before giving up. I don't think Persistent retries at all. Using debugging I want to validate my hypothesis.
23:32:37 <shanemikel_> yeah, so you're specifically trying to debug IO?
23:33:07 <shanemikel_> you might want to use system tooling in your case
23:33:20 <saurabhnanda> shanemikel_: system tooling, say what?
23:33:33 <shanemikel_> like strace
23:33:57 <saurabhnanda> is strace linux specific? I'm on mac OSX
23:37:00 <saurabhnanda> okay let's start with a stacktrace first. Any examples of how to use http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stack.html#v:errorWithStackTrace ?
23:37:19 <shanemikel_> are you using ipc, or a sqlite library?
23:37:35 <saurabhnanda> this is how I'm catching my error right now. How do I get it to print the stacktrace -- forkIO $ forever $ void (WS.runClient "localhost" 9999 "/jsonrpc" $ aria2WebsocketClient aria2Chan tgOutChan) `catch` (\e -> putStrLn $ "ERROR IN websocket client: " ++ (show (e :: Control.Exception.SomeException)))
23:38:31 <saurabhnanda> shanemikel_: for accessing Sqlite I'm using the Persistent Library
23:38:46 <shanemikel_> sorry, I haven't used that..
23:38:58 <saurabhnanda> shanemikel_: any help with how to get a stracktrace from an error?
23:42:02 <shanemikel_> sorry, I don't have much experience debugging haskell programs either, but , and I'm just spitballing since nobody else seems to have answers for you right now, you might look at other ways to trace the execution of your program
23:42:39 <shanemikel_> dont underestimate the value of unsafePerformIO (i.e. for inserting print statements).. or maybe see if sqlite has a --verbose flag
23:43:47 <saurabhnanda> shanemikel_: thanks for trying to help. I'm trying stuff given at http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stack.html#v:currentCallStack at the moment
23:44:20 <zipper> Does GHC internally or natively support hot code reload?
23:44:27 <saurabhnanda> forkIO $ forever $ void (WS.runClient "localhost" 9999 "/jsonrpc" $ aria2WebsocketClient aria2Chan tgOutChan) `catch` (\e -> Stk.currentCallStack >>= (\stack -> putStrLn $ "ERROR IN websocket client: " ++ (show (e :: Control.Exception.SomeException)) ++ "\nSTACKTRACE\n" ++ (show stack)))
23:47:04 <shanemikel_> saurabhnanda: you might try pasting larger sections of your code in lpaste.net
23:48:16 <shanemikel_> and linking here
23:48:54 <shanemikel_> jle`: hey, do you know of anybody using readline with ghci?
23:50:01 <zipper> Would this statement be considered true "Threads are the primary tool used to introduce concurrency in haskell..."
23:50:29 <Lokathor> zipper, gonna give that a strong "maybe"
23:50:42 <shanemikel_> maybe if you qualify the use of "Thread" with lightweight thread
23:51:23 <zipper> "lightweight threads are the ..."
23:51:32 <Lokathor> I'd say that MVar is also the core of concurrency in haskell
23:51:35 <zipper> Green or lightweight which is better?
23:51:56 <zipper> But MVar is there to be mainipulated via threads, no?
23:52:15 <Lokathor> MVar is the core element which allows threads to communicate
23:52:42 <Lokathor> (technically IORef allows this but don'tbadno)
23:53:23 <zipper> hmmmm makes sense
23:53:48 <zipper> It's symobiotic really\
23:53:56 <Lokathor> very
